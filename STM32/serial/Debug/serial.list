
serial.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002977c  08000190  08000190  00001190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000b420  0802990c  0802990c  0002a90c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08034d2c  08034d2c  00036190  2**0
                  CONTENTS, READONLY
  4 .ARM          00000008  08034d2c  08034d2c  00035d2c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08034d34  08034d34  00036190  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08034d34  08034d34  00035d34  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08034d38  08034d38  00035d38  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000190  20000000  08034d3c  00036000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .ccmram       00000000  10000000  10000000  00036190  2**0
                  CONTENTS
 10 .bss          000037fc  20000190  20000190  00036190  2**2
                  ALLOC
 11 ._user_heap_stack 00000804  2000398c  2000398c  00036190  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  00036190  2**0
                  CONTENTS, READONLY
 13 .debug_info   000978a2  00000000  00000000  000361c0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 0000890d  00000000  00000000  000cda62  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00006c78  00000000  00000000  000d6370  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000591d  00000000  00000000  000dcfe8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000370dd  00000000  00000000  000e2905  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0006b108  00000000  00000000  001199e2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0011505e  00000000  00000000  00184aea  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  00299b48  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0001f554  00000000  00000000  00299b8c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 0000005e  00000000  00000000  002b90e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	@ (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	@ (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	@ (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000190 	.word	0x20000190
 80001ac:	00000000 	.word	0x00000000
 80001b0:	080298f4 	.word	0x080298f4

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	@ (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	@ (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	@ (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20000194 	.word	0x20000194
 80001cc:	080298f4 	.word	0x080298f4

080001d0 <strcmp>:
 80001d0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001d4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001d8:	2a01      	cmp	r2, #1
 80001da:	bf28      	it	cs
 80001dc:	429a      	cmpcs	r2, r3
 80001de:	d0f7      	beq.n	80001d0 <strcmp>
 80001e0:	1ad0      	subs	r0, r2, r3
 80001e2:	4770      	bx	lr

080001e4 <strlen>:
 80001e4:	4603      	mov	r3, r0
 80001e6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001ea:	2a00      	cmp	r2, #0
 80001ec:	d1fb      	bne.n	80001e6 <strlen+0x2>
 80001ee:	1a18      	subs	r0, r3, r0
 80001f0:	3801      	subs	r0, #1
 80001f2:	4770      	bx	lr
	...

08000200 <memchr>:
 8000200:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 8000204:	2a10      	cmp	r2, #16
 8000206:	db2b      	blt.n	8000260 <memchr+0x60>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	d008      	beq.n	8000220 <memchr+0x20>
 800020e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000212:	3a01      	subs	r2, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d02d      	beq.n	8000274 <memchr+0x74>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	b342      	cbz	r2, 8000270 <memchr+0x70>
 800021e:	d1f6      	bne.n	800020e <memchr+0xe>
 8000220:	b4f0      	push	{r4, r5, r6, r7}
 8000222:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000226:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800022a:	f022 0407 	bic.w	r4, r2, #7
 800022e:	f07f 0700 	mvns.w	r7, #0
 8000232:	2300      	movs	r3, #0
 8000234:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000238:	3c08      	subs	r4, #8
 800023a:	ea85 0501 	eor.w	r5, r5, r1
 800023e:	ea86 0601 	eor.w	r6, r6, r1
 8000242:	fa85 f547 	uadd8	r5, r5, r7
 8000246:	faa3 f587 	sel	r5, r3, r7
 800024a:	fa86 f647 	uadd8	r6, r6, r7
 800024e:	faa5 f687 	sel	r6, r5, r7
 8000252:	b98e      	cbnz	r6, 8000278 <memchr+0x78>
 8000254:	d1ee      	bne.n	8000234 <memchr+0x34>
 8000256:	bcf0      	pop	{r4, r5, r6, r7}
 8000258:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800025c:	f002 0207 	and.w	r2, r2, #7
 8000260:	b132      	cbz	r2, 8000270 <memchr+0x70>
 8000262:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000266:	3a01      	subs	r2, #1
 8000268:	ea83 0301 	eor.w	r3, r3, r1
 800026c:	b113      	cbz	r3, 8000274 <memchr+0x74>
 800026e:	d1f8      	bne.n	8000262 <memchr+0x62>
 8000270:	2000      	movs	r0, #0
 8000272:	4770      	bx	lr
 8000274:	3801      	subs	r0, #1
 8000276:	4770      	bx	lr
 8000278:	2d00      	cmp	r5, #0
 800027a:	bf06      	itte	eq
 800027c:	4635      	moveq	r5, r6
 800027e:	3803      	subeq	r0, #3
 8000280:	3807      	subne	r0, #7
 8000282:	f015 0f01 	tst.w	r5, #1
 8000286:	d107      	bne.n	8000298 <memchr+0x98>
 8000288:	3001      	adds	r0, #1
 800028a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800028e:	bf02      	ittt	eq
 8000290:	3001      	addeq	r0, #1
 8000292:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000296:	3001      	addeq	r0, #1
 8000298:	bcf0      	pop	{r4, r5, r6, r7}
 800029a:	3801      	subs	r0, #1
 800029c:	4770      	bx	lr
 800029e:	bf00      	nop

080002a0 <__aeabi_uldivmod>:
 80002a0:	b953      	cbnz	r3, 80002b8 <__aeabi_uldivmod+0x18>
 80002a2:	b94a      	cbnz	r2, 80002b8 <__aeabi_uldivmod+0x18>
 80002a4:	2900      	cmp	r1, #0
 80002a6:	bf08      	it	eq
 80002a8:	2800      	cmpeq	r0, #0
 80002aa:	bf1c      	itt	ne
 80002ac:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
 80002b0:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
 80002b4:	f000 b988 	b.w	80005c8 <__aeabi_idiv0>
 80002b8:	f1ad 0c08 	sub.w	ip, sp, #8
 80002bc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002c0:	f000 f806 	bl	80002d0 <__udivmoddi4>
 80002c4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002c8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002cc:	b004      	add	sp, #16
 80002ce:	4770      	bx	lr

080002d0 <__udivmoddi4>:
 80002d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002d4:	9d08      	ldr	r5, [sp, #32]
 80002d6:	468e      	mov	lr, r1
 80002d8:	4604      	mov	r4, r0
 80002da:	4688      	mov	r8, r1
 80002dc:	2b00      	cmp	r3, #0
 80002de:	d14a      	bne.n	8000376 <__udivmoddi4+0xa6>
 80002e0:	428a      	cmp	r2, r1
 80002e2:	4617      	mov	r7, r2
 80002e4:	d962      	bls.n	80003ac <__udivmoddi4+0xdc>
 80002e6:	fab2 f682 	clz	r6, r2
 80002ea:	b14e      	cbz	r6, 8000300 <__udivmoddi4+0x30>
 80002ec:	f1c6 0320 	rsb	r3, r6, #32
 80002f0:	fa01 f806 	lsl.w	r8, r1, r6
 80002f4:	fa20 f303 	lsr.w	r3, r0, r3
 80002f8:	40b7      	lsls	r7, r6
 80002fa:	ea43 0808 	orr.w	r8, r3, r8
 80002fe:	40b4      	lsls	r4, r6
 8000300:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000304:	fa1f fc87 	uxth.w	ip, r7
 8000308:	fbb8 f1fe 	udiv	r1, r8, lr
 800030c:	0c23      	lsrs	r3, r4, #16
 800030e:	fb0e 8811 	mls	r8, lr, r1, r8
 8000312:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000316:	fb01 f20c 	mul.w	r2, r1, ip
 800031a:	429a      	cmp	r2, r3
 800031c:	d909      	bls.n	8000332 <__udivmoddi4+0x62>
 800031e:	18fb      	adds	r3, r7, r3
 8000320:	f101 30ff 	add.w	r0, r1, #4294967295	@ 0xffffffff
 8000324:	f080 80ea 	bcs.w	80004fc <__udivmoddi4+0x22c>
 8000328:	429a      	cmp	r2, r3
 800032a:	f240 80e7 	bls.w	80004fc <__udivmoddi4+0x22c>
 800032e:	3902      	subs	r1, #2
 8000330:	443b      	add	r3, r7
 8000332:	1a9a      	subs	r2, r3, r2
 8000334:	b2a3      	uxth	r3, r4
 8000336:	fbb2 f0fe 	udiv	r0, r2, lr
 800033a:	fb0e 2210 	mls	r2, lr, r0, r2
 800033e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8000342:	fb00 fc0c 	mul.w	ip, r0, ip
 8000346:	459c      	cmp	ip, r3
 8000348:	d909      	bls.n	800035e <__udivmoddi4+0x8e>
 800034a:	18fb      	adds	r3, r7, r3
 800034c:	f100 32ff 	add.w	r2, r0, #4294967295	@ 0xffffffff
 8000350:	f080 80d6 	bcs.w	8000500 <__udivmoddi4+0x230>
 8000354:	459c      	cmp	ip, r3
 8000356:	f240 80d3 	bls.w	8000500 <__udivmoddi4+0x230>
 800035a:	443b      	add	r3, r7
 800035c:	3802      	subs	r0, #2
 800035e:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000362:	eba3 030c 	sub.w	r3, r3, ip
 8000366:	2100      	movs	r1, #0
 8000368:	b11d      	cbz	r5, 8000372 <__udivmoddi4+0xa2>
 800036a:	40f3      	lsrs	r3, r6
 800036c:	2200      	movs	r2, #0
 800036e:	e9c5 3200 	strd	r3, r2, [r5]
 8000372:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000376:	428b      	cmp	r3, r1
 8000378:	d905      	bls.n	8000386 <__udivmoddi4+0xb6>
 800037a:	b10d      	cbz	r5, 8000380 <__udivmoddi4+0xb0>
 800037c:	e9c5 0100 	strd	r0, r1, [r5]
 8000380:	2100      	movs	r1, #0
 8000382:	4608      	mov	r0, r1
 8000384:	e7f5      	b.n	8000372 <__udivmoddi4+0xa2>
 8000386:	fab3 f183 	clz	r1, r3
 800038a:	2900      	cmp	r1, #0
 800038c:	d146      	bne.n	800041c <__udivmoddi4+0x14c>
 800038e:	4573      	cmp	r3, lr
 8000390:	d302      	bcc.n	8000398 <__udivmoddi4+0xc8>
 8000392:	4282      	cmp	r2, r0
 8000394:	f200 8105 	bhi.w	80005a2 <__udivmoddi4+0x2d2>
 8000398:	1a84      	subs	r4, r0, r2
 800039a:	eb6e 0203 	sbc.w	r2, lr, r3
 800039e:	2001      	movs	r0, #1
 80003a0:	4690      	mov	r8, r2
 80003a2:	2d00      	cmp	r5, #0
 80003a4:	d0e5      	beq.n	8000372 <__udivmoddi4+0xa2>
 80003a6:	e9c5 4800 	strd	r4, r8, [r5]
 80003aa:	e7e2      	b.n	8000372 <__udivmoddi4+0xa2>
 80003ac:	2a00      	cmp	r2, #0
 80003ae:	f000 8090 	beq.w	80004d2 <__udivmoddi4+0x202>
 80003b2:	fab2 f682 	clz	r6, r2
 80003b6:	2e00      	cmp	r6, #0
 80003b8:	f040 80a4 	bne.w	8000504 <__udivmoddi4+0x234>
 80003bc:	1a8a      	subs	r2, r1, r2
 80003be:	0c03      	lsrs	r3, r0, #16
 80003c0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 80003c4:	b280      	uxth	r0, r0
 80003c6:	b2bc      	uxth	r4, r7
 80003c8:	2101      	movs	r1, #1
 80003ca:	fbb2 fcfe 	udiv	ip, r2, lr
 80003ce:	fb0e 221c 	mls	r2, lr, ip, r2
 80003d2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80003d6:	fb04 f20c 	mul.w	r2, r4, ip
 80003da:	429a      	cmp	r2, r3
 80003dc:	d907      	bls.n	80003ee <__udivmoddi4+0x11e>
 80003de:	18fb      	adds	r3, r7, r3
 80003e0:	f10c 38ff 	add.w	r8, ip, #4294967295	@ 0xffffffff
 80003e4:	d202      	bcs.n	80003ec <__udivmoddi4+0x11c>
 80003e6:	429a      	cmp	r2, r3
 80003e8:	f200 80e0 	bhi.w	80005ac <__udivmoddi4+0x2dc>
 80003ec:	46c4      	mov	ip, r8
 80003ee:	1a9b      	subs	r3, r3, r2
 80003f0:	fbb3 f2fe 	udiv	r2, r3, lr
 80003f4:	fb0e 3312 	mls	r3, lr, r2, r3
 80003f8:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 80003fc:	fb02 f404 	mul.w	r4, r2, r4
 8000400:	429c      	cmp	r4, r3
 8000402:	d907      	bls.n	8000414 <__udivmoddi4+0x144>
 8000404:	18fb      	adds	r3, r7, r3
 8000406:	f102 30ff 	add.w	r0, r2, #4294967295	@ 0xffffffff
 800040a:	d202      	bcs.n	8000412 <__udivmoddi4+0x142>
 800040c:	429c      	cmp	r4, r3
 800040e:	f200 80ca 	bhi.w	80005a6 <__udivmoddi4+0x2d6>
 8000412:	4602      	mov	r2, r0
 8000414:	1b1b      	subs	r3, r3, r4
 8000416:	ea42 400c 	orr.w	r0, r2, ip, lsl #16
 800041a:	e7a5      	b.n	8000368 <__udivmoddi4+0x98>
 800041c:	f1c1 0620 	rsb	r6, r1, #32
 8000420:	408b      	lsls	r3, r1
 8000422:	fa22 f706 	lsr.w	r7, r2, r6
 8000426:	431f      	orrs	r7, r3
 8000428:	fa0e f401 	lsl.w	r4, lr, r1
 800042c:	fa20 f306 	lsr.w	r3, r0, r6
 8000430:	fa2e fe06 	lsr.w	lr, lr, r6
 8000434:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8000438:	4323      	orrs	r3, r4
 800043a:	fa00 f801 	lsl.w	r8, r0, r1
 800043e:	fa1f fc87 	uxth.w	ip, r7
 8000442:	fbbe f0f9 	udiv	r0, lr, r9
 8000446:	0c1c      	lsrs	r4, r3, #16
 8000448:	fb09 ee10 	mls	lr, r9, r0, lr
 800044c:	ea44 440e 	orr.w	r4, r4, lr, lsl #16
 8000450:	fb00 fe0c 	mul.w	lr, r0, ip
 8000454:	45a6      	cmp	lr, r4
 8000456:	fa02 f201 	lsl.w	r2, r2, r1
 800045a:	d909      	bls.n	8000470 <__udivmoddi4+0x1a0>
 800045c:	193c      	adds	r4, r7, r4
 800045e:	f100 3aff 	add.w	sl, r0, #4294967295	@ 0xffffffff
 8000462:	f080 809c 	bcs.w	800059e <__udivmoddi4+0x2ce>
 8000466:	45a6      	cmp	lr, r4
 8000468:	f240 8099 	bls.w	800059e <__udivmoddi4+0x2ce>
 800046c:	3802      	subs	r0, #2
 800046e:	443c      	add	r4, r7
 8000470:	eba4 040e 	sub.w	r4, r4, lr
 8000474:	fa1f fe83 	uxth.w	lr, r3
 8000478:	fbb4 f3f9 	udiv	r3, r4, r9
 800047c:	fb09 4413 	mls	r4, r9, r3, r4
 8000480:	ea4e 4404 	orr.w	r4, lr, r4, lsl #16
 8000484:	fb03 fc0c 	mul.w	ip, r3, ip
 8000488:	45a4      	cmp	ip, r4
 800048a:	d908      	bls.n	800049e <__udivmoddi4+0x1ce>
 800048c:	193c      	adds	r4, r7, r4
 800048e:	f103 3eff 	add.w	lr, r3, #4294967295	@ 0xffffffff
 8000492:	f080 8082 	bcs.w	800059a <__udivmoddi4+0x2ca>
 8000496:	45a4      	cmp	ip, r4
 8000498:	d97f      	bls.n	800059a <__udivmoddi4+0x2ca>
 800049a:	3b02      	subs	r3, #2
 800049c:	443c      	add	r4, r7
 800049e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80004a2:	eba4 040c 	sub.w	r4, r4, ip
 80004a6:	fba0 ec02 	umull	lr, ip, r0, r2
 80004aa:	4564      	cmp	r4, ip
 80004ac:	4673      	mov	r3, lr
 80004ae:	46e1      	mov	r9, ip
 80004b0:	d362      	bcc.n	8000578 <__udivmoddi4+0x2a8>
 80004b2:	d05f      	beq.n	8000574 <__udivmoddi4+0x2a4>
 80004b4:	b15d      	cbz	r5, 80004ce <__udivmoddi4+0x1fe>
 80004b6:	ebb8 0203 	subs.w	r2, r8, r3
 80004ba:	eb64 0409 	sbc.w	r4, r4, r9
 80004be:	fa04 f606 	lsl.w	r6, r4, r6
 80004c2:	fa22 f301 	lsr.w	r3, r2, r1
 80004c6:	431e      	orrs	r6, r3
 80004c8:	40cc      	lsrs	r4, r1
 80004ca:	e9c5 6400 	strd	r6, r4, [r5]
 80004ce:	2100      	movs	r1, #0
 80004d0:	e74f      	b.n	8000372 <__udivmoddi4+0xa2>
 80004d2:	fbb1 fcf2 	udiv	ip, r1, r2
 80004d6:	0c01      	lsrs	r1, r0, #16
 80004d8:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
 80004dc:	b280      	uxth	r0, r0
 80004de:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 80004e2:	463b      	mov	r3, r7
 80004e4:	4638      	mov	r0, r7
 80004e6:	463c      	mov	r4, r7
 80004e8:	46b8      	mov	r8, r7
 80004ea:	46be      	mov	lr, r7
 80004ec:	2620      	movs	r6, #32
 80004ee:	fbb1 f1f7 	udiv	r1, r1, r7
 80004f2:	eba2 0208 	sub.w	r2, r2, r8
 80004f6:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 80004fa:	e766      	b.n	80003ca <__udivmoddi4+0xfa>
 80004fc:	4601      	mov	r1, r0
 80004fe:	e718      	b.n	8000332 <__udivmoddi4+0x62>
 8000500:	4610      	mov	r0, r2
 8000502:	e72c      	b.n	800035e <__udivmoddi4+0x8e>
 8000504:	f1c6 0220 	rsb	r2, r6, #32
 8000508:	fa2e f302 	lsr.w	r3, lr, r2
 800050c:	40b7      	lsls	r7, r6
 800050e:	40b1      	lsls	r1, r6
 8000510:	fa20 f202 	lsr.w	r2, r0, r2
 8000514:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000518:	430a      	orrs	r2, r1
 800051a:	fbb3 f8fe 	udiv	r8, r3, lr
 800051e:	b2bc      	uxth	r4, r7
 8000520:	fb0e 3318 	mls	r3, lr, r8, r3
 8000524:	0c11      	lsrs	r1, r2, #16
 8000526:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800052a:	fb08 f904 	mul.w	r9, r8, r4
 800052e:	40b0      	lsls	r0, r6
 8000530:	4589      	cmp	r9, r1
 8000532:	ea4f 4310 	mov.w	r3, r0, lsr #16
 8000536:	b280      	uxth	r0, r0
 8000538:	d93e      	bls.n	80005b8 <__udivmoddi4+0x2e8>
 800053a:	1879      	adds	r1, r7, r1
 800053c:	f108 3cff 	add.w	ip, r8, #4294967295	@ 0xffffffff
 8000540:	d201      	bcs.n	8000546 <__udivmoddi4+0x276>
 8000542:	4589      	cmp	r9, r1
 8000544:	d81f      	bhi.n	8000586 <__udivmoddi4+0x2b6>
 8000546:	eba1 0109 	sub.w	r1, r1, r9
 800054a:	fbb1 f9fe 	udiv	r9, r1, lr
 800054e:	fb09 f804 	mul.w	r8, r9, r4
 8000552:	fb0e 1119 	mls	r1, lr, r9, r1
 8000556:	b292      	uxth	r2, r2
 8000558:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800055c:	4542      	cmp	r2, r8
 800055e:	d229      	bcs.n	80005b4 <__udivmoddi4+0x2e4>
 8000560:	18ba      	adds	r2, r7, r2
 8000562:	f109 31ff 	add.w	r1, r9, #4294967295	@ 0xffffffff
 8000566:	d2c4      	bcs.n	80004f2 <__udivmoddi4+0x222>
 8000568:	4542      	cmp	r2, r8
 800056a:	d2c2      	bcs.n	80004f2 <__udivmoddi4+0x222>
 800056c:	f1a9 0102 	sub.w	r1, r9, #2
 8000570:	443a      	add	r2, r7
 8000572:	e7be      	b.n	80004f2 <__udivmoddi4+0x222>
 8000574:	45f0      	cmp	r8, lr
 8000576:	d29d      	bcs.n	80004b4 <__udivmoddi4+0x1e4>
 8000578:	ebbe 0302 	subs.w	r3, lr, r2
 800057c:	eb6c 0c07 	sbc.w	ip, ip, r7
 8000580:	3801      	subs	r0, #1
 8000582:	46e1      	mov	r9, ip
 8000584:	e796      	b.n	80004b4 <__udivmoddi4+0x1e4>
 8000586:	eba7 0909 	sub.w	r9, r7, r9
 800058a:	4449      	add	r1, r9
 800058c:	f1a8 0c02 	sub.w	ip, r8, #2
 8000590:	fbb1 f9fe 	udiv	r9, r1, lr
 8000594:	fb09 f804 	mul.w	r8, r9, r4
 8000598:	e7db      	b.n	8000552 <__udivmoddi4+0x282>
 800059a:	4673      	mov	r3, lr
 800059c:	e77f      	b.n	800049e <__udivmoddi4+0x1ce>
 800059e:	4650      	mov	r0, sl
 80005a0:	e766      	b.n	8000470 <__udivmoddi4+0x1a0>
 80005a2:	4608      	mov	r0, r1
 80005a4:	e6fd      	b.n	80003a2 <__udivmoddi4+0xd2>
 80005a6:	443b      	add	r3, r7
 80005a8:	3a02      	subs	r2, #2
 80005aa:	e733      	b.n	8000414 <__udivmoddi4+0x144>
 80005ac:	f1ac 0c02 	sub.w	ip, ip, #2
 80005b0:	443b      	add	r3, r7
 80005b2:	e71c      	b.n	80003ee <__udivmoddi4+0x11e>
 80005b4:	4649      	mov	r1, r9
 80005b6:	e79c      	b.n	80004f2 <__udivmoddi4+0x222>
 80005b8:	eba1 0109 	sub.w	r1, r1, r9
 80005bc:	46c4      	mov	ip, r8
 80005be:	fbb1 f9fe 	udiv	r9, r1, lr
 80005c2:	fb09 f804 	mul.w	r8, r9, r4
 80005c6:	e7c4      	b.n	8000552 <__udivmoddi4+0x282>

080005c8 <__aeabi_idiv0>:
 80005c8:	4770      	bx	lr
 80005ca:	bf00      	nop

080005cc <firstMessageHandler>:
	thirdMessage = (MessageThree){{0},{0},{0},{0},{0},{0},{0}};
	fourthMessage = (MessageFour){{0},{0},{0},{0},{0}};
	fifthMessage = (MessageFive){{0},{0},{0},{0},{0}};
	sixthMessage = (MessageSix){{0},{0},{0},{0},{0},{0}};
}*/
void firstMessageHandler(uint8_t* receivedChars) {
 80005cc:	b580      	push	{r7, lr}
 80005ce:	b084      	sub	sp, #16
 80005d0:	af00      	add	r7, sp, #0
 80005d2:	6078      	str	r0, [r7, #4]
	for (int i = 0; i < 4; i++) {
 80005d4:	2300      	movs	r3, #0
 80005d6:	60fb      	str	r3, [r7, #12]
 80005d8:	e00b      	b.n	80005f2 <firstMessageHandler+0x26>
		firstMessage.initChars[i] = receivedChars[i];
 80005da:	68fb      	ldr	r3, [r7, #12]
 80005dc:	687a      	ldr	r2, [r7, #4]
 80005de:	4413      	add	r3, r2
 80005e0:	7819      	ldrb	r1, [r3, #0]
 80005e2:	4a0c      	ldr	r2, [pc, #48]	@ (8000614 <firstMessageHandler+0x48>)
 80005e4:	68fb      	ldr	r3, [r7, #12]
 80005e6:	4413      	add	r3, r2
 80005e8:	460a      	mov	r2, r1
 80005ea:	701a      	strb	r2, [r3, #0]
	for (int i = 0; i < 4; i++) {
 80005ec:	68fb      	ldr	r3, [r7, #12]
 80005ee:	3301      	adds	r3, #1
 80005f0:	60fb      	str	r3, [r7, #12]
 80005f2:	68fb      	ldr	r3, [r7, #12]
 80005f4:	2b03      	cmp	r3, #3
 80005f6:	ddf0      	ble.n	80005da <firstMessageHandler+0xe>
	}
	// skontroluj ci sme v prvej sprave dostali uvodne znaky 'H' 'e' 'l' 'o'
	// treba dorobit odpoved v pripade ze sme nedostali taketo znaky
	if(memcmp(firstMessage.initChars, secondMessage.replyChars, sizeof(secondMessage.replyChars)) == 0) {
 80005f8:	2204      	movs	r2, #4
 80005fa:	4907      	ldr	r1, [pc, #28]	@ (8000618 <firstMessageHandler+0x4c>)
 80005fc:	4805      	ldr	r0, [pc, #20]	@ (8000614 <firstMessageHandler+0x48>)
 80005fe:	f028 fae7 	bl	8028bd0 <memcmp>
 8000602:	4603      	mov	r3, r0
 8000604:	2b00      	cmp	r3, #0
 8000606:	d101      	bne.n	800060c <firstMessageHandler+0x40>
		secondMessageSender();
 8000608:	f000 f808 	bl	800061c <secondMessageSender>
	}
}
 800060c:	bf00      	nop
 800060e:	3710      	adds	r7, #16
 8000610:	46bd      	mov	sp, r7
 8000612:	bd80      	pop	{r7, pc}
 8000614:	20000000 	.word	0x20000000
 8000618:	20000004 	.word	0x20000004

0800061c <secondMessageSender>:

void secondMessageSender() {
 800061c:	b580      	push	{r7, lr}
 800061e:	b086      	sub	sp, #24
 8000620:	af00      	add	r7, sp, #0
	// vrat device ID co je rozdelene do troch 32bit hodnot
	uint32_t uid_one = HAL_GetUIDw0();
 8000622:	f001 fc83 	bl	8001f2c <HAL_GetUIDw0>
 8000626:	6138      	str	r0, [r7, #16]
	uint32_t uid_two = HAL_GetUIDw1();
 8000628:	f001 fc8c 	bl	8001f44 <HAL_GetUIDw1>
 800062c:	60f8      	str	r0, [r7, #12]
	uint32_t uid_three = HAL_GetUIDw2();
 800062e:	f001 fc95 	bl	8001f5c <HAL_GetUIDw2>
 8000632:	60b8      	str	r0, [r7, #8]
	// vsetko nasekaj do sendBuffera
	memcpy(sendBuffer, secondMessage.replyChars, 4);
 8000634:	4b49      	ldr	r3, [pc, #292]	@ (800075c <secondMessageSender+0x140>)
 8000636:	681b      	ldr	r3, [r3, #0]
 8000638:	4a49      	ldr	r2, [pc, #292]	@ (8000760 <secondMessageSender+0x144>)
 800063a:	6013      	str	r3, [r2, #0]
	sendCounter += 4;
 800063c:	4b49      	ldr	r3, [pc, #292]	@ (8000764 <secondMessageSender+0x148>)
 800063e:	881b      	ldrh	r3, [r3, #0]
 8000640:	3304      	adds	r3, #4
 8000642:	b29a      	uxth	r2, r3
 8000644:	4b47      	ldr	r3, [pc, #284]	@ (8000764 <secondMessageSender+0x148>)
 8000646:	801a      	strh	r2, [r3, #0]
	for (size_t i = 0; i < 3; i++)
 8000648:	2300      	movs	r3, #0
 800064a:	617b      	str	r3, [r7, #20]
 800064c:	e04d      	b.n	80006ea <secondMessageSender+0xce>
	{
		uint8_t UIDsplit[4];
		if (i == 0) {
 800064e:	697b      	ldr	r3, [r7, #20]
 8000650:	2b00      	cmp	r3, #0
 8000652:	d112      	bne.n	800067a <secondMessageSender+0x5e>
			UIDsplit[0] = (uid_one & 0x000000ff);
 8000654:	693b      	ldr	r3, [r7, #16]
 8000656:	b2db      	uxtb	r3, r3
 8000658:	713b      	strb	r3, [r7, #4]
			UIDsplit[1] = (uid_one & 0x0000ff00) >> 8;
 800065a:	693b      	ldr	r3, [r7, #16]
 800065c:	0a1b      	lsrs	r3, r3, #8
 800065e:	b2db      	uxtb	r3, r3
 8000660:	717b      	strb	r3, [r7, #5]
			UIDsplit[2] = (uid_one & 0x00ff0000) >> 16;
 8000662:	693b      	ldr	r3, [r7, #16]
 8000664:	0c1b      	lsrs	r3, r3, #16
 8000666:	b2db      	uxtb	r3, r3
 8000668:	71bb      	strb	r3, [r7, #6]
			UIDsplit[3] = (uid_one & 0xff000000) >> 24;
 800066a:	693b      	ldr	r3, [r7, #16]
 800066c:	0e1b      	lsrs	r3, r3, #24
 800066e:	b2db      	uxtb	r3, r3
 8000670:	71fb      	strb	r3, [r7, #7]
			memcpy(secondMessage.Tid_one, UIDsplit, 4);
 8000672:	687b      	ldr	r3, [r7, #4]
 8000674:	4a39      	ldr	r2, [pc, #228]	@ (800075c <secondMessageSender+0x140>)
 8000676:	6053      	str	r3, [r2, #4]
 8000678:	e027      	b.n	80006ca <secondMessageSender+0xae>
		} else if (i == 1) {
 800067a:	697b      	ldr	r3, [r7, #20]
 800067c:	2b01      	cmp	r3, #1
 800067e:	d112      	bne.n	80006a6 <secondMessageSender+0x8a>
			UIDsplit[0] = (uid_two & 0x000000ff);
 8000680:	68fb      	ldr	r3, [r7, #12]
 8000682:	b2db      	uxtb	r3, r3
 8000684:	713b      	strb	r3, [r7, #4]
			UIDsplit[1] = (uid_two & 0x0000ff00) >> 8;
 8000686:	68fb      	ldr	r3, [r7, #12]
 8000688:	0a1b      	lsrs	r3, r3, #8
 800068a:	b2db      	uxtb	r3, r3
 800068c:	717b      	strb	r3, [r7, #5]
			UIDsplit[2] = (uid_two & 0x00ff0000) >> 16;
 800068e:	68fb      	ldr	r3, [r7, #12]
 8000690:	0c1b      	lsrs	r3, r3, #16
 8000692:	b2db      	uxtb	r3, r3
 8000694:	71bb      	strb	r3, [r7, #6]
			UIDsplit[3] = (uid_two & 0xff000000) >> 24;
 8000696:	68fb      	ldr	r3, [r7, #12]
 8000698:	0e1b      	lsrs	r3, r3, #24
 800069a:	b2db      	uxtb	r3, r3
 800069c:	71fb      	strb	r3, [r7, #7]
			memcpy(secondMessage.Tid_two, UIDsplit, 4);
 800069e:	687b      	ldr	r3, [r7, #4]
 80006a0:	4a2e      	ldr	r2, [pc, #184]	@ (800075c <secondMessageSender+0x140>)
 80006a2:	6093      	str	r3, [r2, #8]
 80006a4:	e011      	b.n	80006ca <secondMessageSender+0xae>
		} else {
			UIDsplit[0] = (uid_three & 0x000000ff);
 80006a6:	68bb      	ldr	r3, [r7, #8]
 80006a8:	b2db      	uxtb	r3, r3
 80006aa:	713b      	strb	r3, [r7, #4]
			UIDsplit[1] = (uid_three & 0x0000ff00) >> 8;
 80006ac:	68bb      	ldr	r3, [r7, #8]
 80006ae:	0a1b      	lsrs	r3, r3, #8
 80006b0:	b2db      	uxtb	r3, r3
 80006b2:	717b      	strb	r3, [r7, #5]
			UIDsplit[2] = (uid_three & 0x00ff0000) >> 16;
 80006b4:	68bb      	ldr	r3, [r7, #8]
 80006b6:	0c1b      	lsrs	r3, r3, #16
 80006b8:	b2db      	uxtb	r3, r3
 80006ba:	71bb      	strb	r3, [r7, #6]
			UIDsplit[3] = (uid_three & 0xff000000) >> 24;
 80006bc:	68bb      	ldr	r3, [r7, #8]
 80006be:	0e1b      	lsrs	r3, r3, #24
 80006c0:	b2db      	uxtb	r3, r3
 80006c2:	71fb      	strb	r3, [r7, #7]
			memcpy(secondMessage.Tid_three, UIDsplit, 4);
 80006c4:	687b      	ldr	r3, [r7, #4]
 80006c6:	4a25      	ldr	r2, [pc, #148]	@ (800075c <secondMessageSender+0x140>)
 80006c8:	60d3      	str	r3, [r2, #12]
		}
		memcpy(sendBuffer + sendCounter, UIDsplit, 4);
 80006ca:	4b26      	ldr	r3, [pc, #152]	@ (8000764 <secondMessageSender+0x148>)
 80006cc:	881b      	ldrh	r3, [r3, #0]
 80006ce:	461a      	mov	r2, r3
 80006d0:	4b23      	ldr	r3, [pc, #140]	@ (8000760 <secondMessageSender+0x144>)
 80006d2:	4413      	add	r3, r2
 80006d4:	687a      	ldr	r2, [r7, #4]
 80006d6:	601a      	str	r2, [r3, #0]
		sendCounter += 4;
 80006d8:	4b22      	ldr	r3, [pc, #136]	@ (8000764 <secondMessageSender+0x148>)
 80006da:	881b      	ldrh	r3, [r3, #0]
 80006dc:	3304      	adds	r3, #4
 80006de:	b29a      	uxth	r2, r3
 80006e0:	4b20      	ldr	r3, [pc, #128]	@ (8000764 <secondMessageSender+0x148>)
 80006e2:	801a      	strh	r2, [r3, #0]
	for (size_t i = 0; i < 3; i++)
 80006e4:	697b      	ldr	r3, [r7, #20]
 80006e6:	3301      	adds	r3, #1
 80006e8:	617b      	str	r3, [r7, #20]
 80006ea:	697b      	ldr	r3, [r7, #20]
 80006ec:	2b02      	cmp	r3, #2
 80006ee:	d9ae      	bls.n	800064e <secondMessageSender+0x32>
	}
	// treba este vlozit velkost certifikatu tokenu pred samotny certifikat
	// velkost je ale vyssia ako 256, treba ju splitnut na uint8_t
	sendBuffer[sendCounter] = (tokenCertLen >> 8) & 0xFF;
 80006f0:	4b1d      	ldr	r3, [pc, #116]	@ (8000768 <secondMessageSender+0x14c>)
 80006f2:	881b      	ldrh	r3, [r3, #0]
 80006f4:	0a1b      	lsrs	r3, r3, #8
 80006f6:	b299      	uxth	r1, r3
 80006f8:	4b1a      	ldr	r3, [pc, #104]	@ (8000764 <secondMessageSender+0x148>)
 80006fa:	881b      	ldrh	r3, [r3, #0]
 80006fc:	461a      	mov	r2, r3
 80006fe:	b2c9      	uxtb	r1, r1
 8000700:	4b17      	ldr	r3, [pc, #92]	@ (8000760 <secondMessageSender+0x144>)
 8000702:	5499      	strb	r1, [r3, r2]
	sendCounter++;
 8000704:	4b17      	ldr	r3, [pc, #92]	@ (8000764 <secondMessageSender+0x148>)
 8000706:	881b      	ldrh	r3, [r3, #0]
 8000708:	3301      	adds	r3, #1
 800070a:	b29a      	uxth	r2, r3
 800070c:	4b15      	ldr	r3, [pc, #84]	@ (8000764 <secondMessageSender+0x148>)
 800070e:	801a      	strh	r2, [r3, #0]
	sendBuffer[sendCounter] = tokenCertLen  & 0xFF;
 8000710:	4b15      	ldr	r3, [pc, #84]	@ (8000768 <secondMessageSender+0x14c>)
 8000712:	8819      	ldrh	r1, [r3, #0]
 8000714:	4b13      	ldr	r3, [pc, #76]	@ (8000764 <secondMessageSender+0x148>)
 8000716:	881b      	ldrh	r3, [r3, #0]
 8000718:	461a      	mov	r2, r3
 800071a:	b2c9      	uxtb	r1, r1
 800071c:	4b10      	ldr	r3, [pc, #64]	@ (8000760 <secondMessageSender+0x144>)
 800071e:	5499      	strb	r1, [r3, r2]
	sendCounter++;
 8000720:	4b10      	ldr	r3, [pc, #64]	@ (8000764 <secondMessageSender+0x148>)
 8000722:	881b      	ldrh	r3, [r3, #0]
 8000724:	3301      	adds	r3, #1
 8000726:	b29a      	uxth	r2, r3
 8000728:	4b0e      	ldr	r3, [pc, #56]	@ (8000764 <secondMessageSender+0x148>)
 800072a:	801a      	strh	r2, [r3, #0]
	// vkladam uz certifikat tokenu
	memcpy(sendBuffer + sendCounter, tokenCert, tokenCertLen);
 800072c:	4b0d      	ldr	r3, [pc, #52]	@ (8000764 <secondMessageSender+0x148>)
 800072e:	881b      	ldrh	r3, [r3, #0]
 8000730:	461a      	mov	r2, r3
 8000732:	4b0b      	ldr	r3, [pc, #44]	@ (8000760 <secondMessageSender+0x144>)
 8000734:	4413      	add	r3, r2
 8000736:	4a0c      	ldr	r2, [pc, #48]	@ (8000768 <secondMessageSender+0x14c>)
 8000738:	8812      	ldrh	r2, [r2, #0]
 800073a:	490c      	ldr	r1, [pc, #48]	@ (800076c <secondMessageSender+0x150>)
 800073c:	4618      	mov	r0, r3
 800073e:	f028 fb22 	bl	8028d86 <memcpy>
	sendCounter += tokenCertLen;
 8000742:	4b08      	ldr	r3, [pc, #32]	@ (8000764 <secondMessageSender+0x148>)
 8000744:	881a      	ldrh	r2, [r3, #0]
 8000746:	4b08      	ldr	r3, [pc, #32]	@ (8000768 <secondMessageSender+0x14c>)
 8000748:	881b      	ldrh	r3, [r3, #0]
 800074a:	4413      	add	r3, r2
 800074c:	b29a      	uxth	r2, r3
 800074e:	4b05      	ldr	r3, [pc, #20]	@ (8000764 <secondMessageSender+0x148>)
 8000750:	801a      	strh	r2, [r3, #0]
	return;
 8000752:	bf00      	nop
}
 8000754:	3718      	adds	r7, #24
 8000756:	46bd      	mov	sp, r7
 8000758:	bd80      	pop	{r7, pc}
 800075a:	bf00      	nop
 800075c:	20000004 	.word	0x20000004
 8000760:	2000121c 	.word	0x2000121c
 8000764:	20001be0 	.word	0x20001be0
 8000768:	080311d4 	.word	0x080311d4
 800076c:	08030d88 	.word	0x08030d88

08000770 <thirdMessageHandler>:

void thirdMessageHandler(uint8_t* encryptedKey, uint8_t* encryptedIV, uint8_t* payload, uint8_t* deviceCertBuffer, uint16_t deviceCertLen) {
 8000770:	b590      	push	{r4, r7, lr}
 8000772:	f5ad 5db8 	sub.w	sp, sp, #5888	@ 0x1700
 8000776:	b087      	sub	sp, #28
 8000778:	af02      	add	r7, sp, #8
 800077a:	f507 64e2 	add.w	r4, r7, #1808	@ 0x710
 800077e:	f2a4 7404 	subw	r4, r4, #1796	@ 0x704
 8000782:	6020      	str	r0, [r4, #0]
 8000784:	f507 60e2 	add.w	r0, r7, #1808	@ 0x710
 8000788:	f5a0 60e1 	sub.w	r0, r0, #1800	@ 0x708
 800078c:	6001      	str	r1, [r0, #0]
 800078e:	f507 61e2 	add.w	r1, r7, #1808	@ 0x710
 8000792:	f2a1 710c 	subw	r1, r1, #1804	@ 0x70c
 8000796:	600a      	str	r2, [r1, #0]
 8000798:	f507 62e2 	add.w	r2, r7, #1808	@ 0x710
 800079c:	f5a2 62e2 	sub.w	r2, r2, #1808	@ 0x710
 80007a0:	6013      	str	r3, [r2, #0]
	// over certifikat zariadenia ci je podpisany CA
	WOLFSSL_CTX* ctx = wolfSSL_CTX_new(wolfTLSv1_2_client_method());
 80007a2:	f00e ffa9 	bl	800f6f8 <wolfTLSv1_2_client_method>
 80007a6:	4603      	mov	r3, r0
 80007a8:	4618      	mov	r0, r3
 80007aa:	f00b fd8b 	bl	800c2c4 <wolfSSL_CTX_new>
 80007ae:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 80007b2:	f103 030c 	add.w	r3, r3, #12
 80007b6:	6018      	str	r0, [r3, #0]
    if (wolfSSL_CTX_load_verify_buffer(ctx, CACert, CACertLen, WOLFSSL_FILETYPE_ASN1) != SSL_SUCCESS) {
 80007b8:	4bcc      	ldr	r3, [pc, #816]	@ (8000aec <thirdMessageHandler+0x37c>)
 80007ba:	881b      	ldrh	r3, [r3, #0]
 80007bc:	461a      	mov	r2, r3
 80007be:	2302      	movs	r3, #2
 80007c0:	49cb      	ldr	r1, [pc, #812]	@ (8000af0 <thirdMessageHandler+0x380>)
 80007c2:	f507 50b8 	add.w	r0, r7, #5888	@ 0x1700
 80007c6:	f100 000c 	add.w	r0, r0, #12
 80007ca:	6800      	ldr	r0, [r0, #0]
 80007cc:	f00d f96c 	bl	800daa8 <wolfSSL_CTX_load_verify_buffer>
 80007d0:	4603      	mov	r3, r0
 80007d2:	2b01      	cmp	r3, #1
 80007d4:	d003      	beq.n	80007de <thirdMessageHandler+0x6e>
        printf("Failed to load CA into context.\n");
 80007d6:	48c7      	ldr	r0, [pc, #796]	@ (8000af4 <thirdMessageHandler+0x384>)
 80007d8:	f028 f8e4 	bl	80289a4 <puts>
        return;
 80007dc:	e20a      	b.n	8000bf4 <thirdMessageHandler+0x484>
    }
    WOLFSSL_CERT_MANAGER* cm = wolfSSL_CTX_GetCertManager(ctx);
 80007de:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 80007e2:	f103 030c 	add.w	r3, r3, #12
 80007e6:	6818      	ldr	r0, [r3, #0]
 80007e8:	f00b fdbc 	bl	800c364 <wolfSSL_CTX_GetCertManager>
 80007ec:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 80007f0:	f103 0308 	add.w	r3, r3, #8
 80007f4:	6018      	str	r0, [r3, #0]
    if (!cm) {
 80007f6:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 80007fa:	f103 0308 	add.w	r3, r3, #8
 80007fe:	681b      	ldr	r3, [r3, #0]
 8000800:	2b00      	cmp	r3, #0
 8000802:	d103      	bne.n	800080c <thirdMessageHandler+0x9c>
        printf("Failed to get CertManager.\n");
 8000804:	48bc      	ldr	r0, [pc, #752]	@ (8000af8 <thirdMessageHandler+0x388>)
 8000806:	f028 f8cd 	bl	80289a4 <puts>
        return;
 800080a:	e1f3      	b.n	8000bf4 <thirdMessageHandler+0x484>
    }
    int ret = wolfSSL_CertManagerVerifyBuffer(cm, deviceCertBuffer, deviceCertLen, WOLFSSL_FILETYPE_ASN1);
 800080c:	f507 53b9 	add.w	r3, r7, #5920	@ 0x1720
 8000810:	881a      	ldrh	r2, [r3, #0]
 8000812:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000816:	f5a3 61e2 	sub.w	r1, r3, #1808	@ 0x710
 800081a:	2302      	movs	r3, #2
 800081c:	6809      	ldr	r1, [r1, #0]
 800081e:	f507 50b8 	add.w	r0, r7, #5888	@ 0x1700
 8000822:	f100 0008 	add.w	r0, r0, #8
 8000826:	6800      	ldr	r0, [r0, #0]
 8000828:	f00b f876 	bl	800b918 <wolfSSL_CertManagerVerifyBuffer>
 800082c:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 8000830:	f103 0304 	add.w	r3, r3, #4
 8000834:	6018      	str	r0, [r3, #0]
    if (ret != SSL_SUCCESS) {
 8000836:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 800083a:	f103 0304 	add.w	r3, r3, #4
 800083e:	681b      	ldr	r3, [r3, #0]
 8000840:	2b01      	cmp	r3, #1
 8000842:	d008      	beq.n	8000856 <thirdMessageHandler+0xe6>
        printf("Device certificate verification failed: %d\n", ret);
 8000844:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 8000848:	f103 0304 	add.w	r3, r3, #4
 800084c:	6819      	ldr	r1, [r3, #0]
 800084e:	48ab      	ldr	r0, [pc, #684]	@ (8000afc <thirdMessageHandler+0x38c>)
 8000850:	f028 f840 	bl	80288d4 <iprintf>
        return;
 8000854:	e1ce      	b.n	8000bf4 <thirdMessageHandler+0x484>
    }
    // ak ano, tak extrahuj z neho verejny kluc
    InitDecodedCert(&extractedPCCert, (byte*)deviceCertBuffer, deviceCertLen, NULL);
 8000856:	f507 53b9 	add.w	r3, r7, #5920	@ 0x1720
 800085a:	881a      	ldrh	r2, [r3, #0]
 800085c:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000860:	f5a3 61e2 	sub.w	r1, r3, #1808	@ 0x710
 8000864:	2300      	movs	r3, #0
 8000866:	6809      	ldr	r1, [r1, #0]
 8000868:	48a5      	ldr	r0, [pc, #660]	@ (8000b00 <thirdMessageHandler+0x390>)
 800086a:	f014 fcf2 	bl	8015252 <InitDecodedCert>
    ret = ParseCert(&extractedPCCert, CERT_TYPE, NO_VERIFY, NULL);
 800086e:	2300      	movs	r3, #0
 8000870:	2200      	movs	r2, #0
 8000872:	2100      	movs	r1, #0
 8000874:	48a2      	ldr	r0, [pc, #648]	@ (8000b00 <thirdMessageHandler+0x390>)
 8000876:	f017 ffb4 	bl	80187e2 <ParseCert>
 800087a:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 800087e:	f103 0304 	add.w	r3, r3, #4
 8000882:	6018      	str	r0, [r3, #0]
    if (ret != 0) {
 8000884:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 8000888:	f103 0304 	add.w	r3, r3, #4
 800088c:	681b      	ldr	r3, [r3, #0]
 800088e:	2b00      	cmp	r3, #0
 8000890:	d00e      	beq.n	80008b0 <thirdMessageHandler+0x140>
        wolfSSL_CertManagerFree(cm);
 8000892:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 8000896:	f103 0308 	add.w	r3, r3, #8
 800089a:	6818      	ldr	r0, [r3, #0]
 800089c:	f00a ff53 	bl	800b746 <wolfSSL_CertManagerFree>
        wolfSSL_CTX_free(ctx);
 80008a0:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 80008a4:	f103 030c 	add.w	r3, r3, #12
 80008a8:	6818      	ldr	r0, [r3, #0]
 80008aa:	f00b fd18 	bl	800c2de <wolfSSL_CTX_free>
        return;
 80008ae:	e1a1      	b.n	8000bf4 <thirdMessageHandler+0x484>
    }

    wolfSSL_CertManagerFree(cm);
 80008b0:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 80008b4:	f103 0308 	add.w	r3, r3, #8
 80008b8:	6818      	ldr	r0, [r3, #0]
 80008ba:	f00a ff44 	bl	800b746 <wolfSSL_CertManagerFree>
    wolfSSL_CTX_free(ctx);
 80008be:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 80008c2:	f103 030c 	add.w	r3, r3, #12
 80008c6:	6818      	ldr	r0, [r3, #0]
 80008c8:	f00b fd09 	bl	800c2de <wolfSSL_CTX_free>
    // ak ano tak mozeme desifrovat prijate data. zober sukromny kluc tokenu
    RsaKey rsaKey;
    WC_RNG rng;
    int rsaRet = wc_InitRsaKey(&rsaKey, NULL);
 80008cc:	f507 63b2 	add.w	r3, r7, #1424	@ 0x590
 80008d0:	3b1c      	subs	r3, #28
 80008d2:	2100      	movs	r1, #0
 80008d4:	4618      	mov	r0, r3
 80008d6:	f01f fc45 	bl	8020164 <wc_InitRsaKey>
 80008da:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 80008de:	6018      	str	r0, [r3, #0]
    if (rsaRet != 0) {
 80008e0:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 80008e4:	681b      	ldr	r3, [r3, #0]
 80008e6:	2b00      	cmp	r3, #0
 80008e8:	d006      	beq.n	80008f8 <thirdMessageHandler+0x188>
        printf("RSA key init failed: %d\n", rsaRet);
 80008ea:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 80008ee:	6819      	ldr	r1, [r3, #0]
 80008f0:	4884      	ldr	r0, [pc, #528]	@ (8000b04 <thirdMessageHandler+0x394>)
 80008f2:	f027 ffef 	bl	80288d4 <iprintf>
        return;
 80008f6:	e17d      	b.n	8000bf4 <thirdMessageHandler+0x484>
    }
    rsaRet = wc_InitRng(&rng);
 80008f8:	f507 63ae 	add.w	r3, r7, #1392	@ 0x570
 80008fc:	3b0c      	subs	r3, #12
 80008fe:	4618      	mov	r0, r3
 8000900:	f01e ff31 	bl	801f766 <wc_InitRng>
 8000904:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 8000908:	6018      	str	r0, [r3, #0]
    if (rsaRet != 0) {
 800090a:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 800090e:	681b      	ldr	r3, [r3, #0]
 8000910:	2b00      	cmp	r3, #0
 8000912:	d00c      	beq.n	800092e <thirdMessageHandler+0x1be>
        printf("Failed to initialize RNG: %d\n", rsaRet);
 8000914:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 8000918:	6819      	ldr	r1, [r3, #0]
 800091a:	487b      	ldr	r0, [pc, #492]	@ (8000b08 <thirdMessageHandler+0x398>)
 800091c:	f027 ffda 	bl	80288d4 <iprintf>
        wc_FreeRsaKey(&rsaKey);
 8000920:	f507 63b2 	add.w	r3, r7, #1424	@ 0x590
 8000924:	3b1c      	subs	r3, #28
 8000926:	4618      	mov	r0, r3
 8000928:	f01f fc2c 	bl	8020184 <wc_FreeRsaKey>
        return;
 800092c:	e162      	b.n	8000bf4 <thirdMessageHandler+0x484>
    }
    word32 idx = 0;
 800092e:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000932:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 8000936:	2200      	movs	r2, #0
 8000938:	601a      	str	r2, [r3, #0]
    rsaRet = wc_RsaPrivateKeyDecode(tokenPrivKey, &idx, &rsaKey, tokenPrivKeyLen);
 800093a:	4b74      	ldr	r3, [pc, #464]	@ (8000b0c <thirdMessageHandler+0x39c>)
 800093c:	881b      	ldrh	r3, [r3, #0]
 800093e:	f507 62b2 	add.w	r2, r7, #1424	@ 0x590
 8000942:	3a1c      	subs	r2, #28
 8000944:	f507 61ae 	add.w	r1, r7, #1392	@ 0x570
 8000948:	3910      	subs	r1, #16
 800094a:	4871      	ldr	r0, [pc, #452]	@ (8000b10 <thirdMessageHandler+0x3a0>)
 800094c:	f014 fa12 	bl	8014d74 <wc_RsaPrivateKeyDecode>
 8000950:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 8000954:	6018      	str	r0, [r3, #0]
    if (rsaRet != 0) {
 8000956:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 800095a:	681b      	ldr	r3, [r3, #0]
 800095c:	2b00      	cmp	r3, #0
 800095e:	d012      	beq.n	8000986 <thirdMessageHandler+0x216>
        printf("Failed to decode RSA private key: %d\n", rsaRet);
 8000960:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 8000964:	6819      	ldr	r1, [r3, #0]
 8000966:	486b      	ldr	r0, [pc, #428]	@ (8000b14 <thirdMessageHandler+0x3a4>)
 8000968:	f027 ffb4 	bl	80288d4 <iprintf>
        wc_FreeRsaKey(&rsaKey);
 800096c:	f507 63b2 	add.w	r3, r7, #1424	@ 0x590
 8000970:	3b1c      	subs	r3, #28
 8000972:	4618      	mov	r0, r3
 8000974:	f01f fc06 	bl	8020184 <wc_FreeRsaKey>
        wc_FreeRng(&rng);
 8000978:	f507 63ae 	add.w	r3, r7, #1392	@ 0x570
 800097c:	3b0c      	subs	r3, #12
 800097e:	4618      	mov	r0, r3
 8000980:	f01e ffa4 	bl	801f8cc <wc_FreeRng>
        return;
 8000984:	e136      	b.n	8000bf4 <thirdMessageHandler+0x484>
    }
    wc_RsaSetRNG(&rsaKey, &rng);
 8000986:	f507 62ae 	add.w	r2, r7, #1392	@ 0x570
 800098a:	3a0c      	subs	r2, #12
 800098c:	f507 63b2 	add.w	r3, r7, #1424	@ 0x590
 8000990:	3b1c      	subs	r3, #28
 8000992:	4611      	mov	r1, r2
 8000994:	4618      	mov	r0, r3
 8000996:	f020 fe33 	bl	8021600 <wc_RsaSetRNG>
    // desifrujeme
    uint8_t decryptedKey[256] = {0};
 800099a:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 800099e:	f5a3 732c 	sub.w	r3, r3, #688	@ 0x2b0
 80009a2:	4618      	mov	r0, r3
 80009a4:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80009a8:	461a      	mov	r2, r3
 80009aa:	2100      	movs	r1, #0
 80009ac:	f028 f93a 	bl	8028c24 <memset>
    word32 decryptedKeyLen = sizeof(decryptedKey);
 80009b0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80009b4:	f507 52b7 	add.w	r2, r7, #5856	@ 0x16e0
 80009b8:	f102 021c 	add.w	r2, r2, #28
 80009bc:	6013      	str	r3, [r2, #0]
    uint8_t decryptedIV[256] = {0};
 80009be:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 80009c2:	f5a3 736c 	sub.w	r3, r3, #944	@ 0x3b0
 80009c6:	4618      	mov	r0, r3
 80009c8:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80009cc:	461a      	mov	r2, r3
 80009ce:	2100      	movs	r1, #0
 80009d0:	f028 f928 	bl	8028c24 <memset>
    word32 decryptedIVLen = sizeof(decryptedIV);
 80009d4:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80009d8:	f507 52b7 	add.w	r2, r7, #5856	@ 0x16e0
 80009dc:	f102 0218 	add.w	r2, r2, #24
 80009e0:	6013      	str	r3, [r2, #0]
    word32 inputSize = 256;
 80009e2:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80009e6:	f507 52b7 	add.w	r2, r7, #5856	@ 0x16e0
 80009ea:	f102 0214 	add.w	r2, r2, #20
 80009ee:	6013      	str	r3, [r2, #0]
    // najprv kluc od celej spravy, sukromnym klucom tokenu
    rsaRet = wc_RsaPrivateDecrypt(encryptedKey, inputSize, decryptedKey, decryptedKeyLen, &rsaKey);
 80009f0:	f507 628e 	add.w	r2, r7, #1136	@ 0x470
 80009f4:	3a10      	subs	r2, #16
 80009f6:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 80009fa:	f2a3 7004 	subw	r0, r3, #1796	@ 0x704
 80009fe:	f507 63b2 	add.w	r3, r7, #1424	@ 0x590
 8000a02:	3b1c      	subs	r3, #28
 8000a04:	9300      	str	r3, [sp, #0]
 8000a06:	f507 53b7 	add.w	r3, r7, #5856	@ 0x16e0
 8000a0a:	f103 031c 	add.w	r3, r3, #28
 8000a0e:	681b      	ldr	r3, [r3, #0]
 8000a10:	f507 51b7 	add.w	r1, r7, #5856	@ 0x16e0
 8000a14:	f101 0114 	add.w	r1, r1, #20
 8000a18:	6809      	ldr	r1, [r1, #0]
 8000a1a:	6800      	ldr	r0, [r0, #0]
 8000a1c:	f020 fcb8 	bl	8021390 <wc_RsaPrivateDecrypt>
 8000a20:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 8000a24:	6018      	str	r0, [r3, #0]
    // potom inicializacny vektor, sukromnym klucom tokenu
    rsaRet = wc_RsaPrivateDecrypt(encryptedIV, inputSize, decryptedIV, decryptedIVLen, &rsaKey);
 8000a26:	f507 725c 	add.w	r2, r7, #880	@ 0x370
 8000a2a:	3a10      	subs	r2, #16
 8000a2c:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000a30:	f5a3 60e1 	sub.w	r0, r3, #1800	@ 0x708
 8000a34:	f507 63b2 	add.w	r3, r7, #1424	@ 0x590
 8000a38:	3b1c      	subs	r3, #28
 8000a3a:	9300      	str	r3, [sp, #0]
 8000a3c:	f507 53b7 	add.w	r3, r7, #5856	@ 0x16e0
 8000a40:	f103 0318 	add.w	r3, r3, #24
 8000a44:	681b      	ldr	r3, [r3, #0]
 8000a46:	f507 51b7 	add.w	r1, r7, #5856	@ 0x16e0
 8000a4a:	f101 0114 	add.w	r1, r1, #20
 8000a4e:	6809      	ldr	r1, [r1, #0]
 8000a50:	6800      	ldr	r0, [r0, #0]
 8000a52:	f020 fc9d 	bl	8021390 <wc_RsaPrivateDecrypt>
 8000a56:	f507 53b8 	add.w	r3, r7, #5888	@ 0x1700
 8000a5a:	6018      	str	r0, [r3, #0]
    // a nakoniec celu spravu (payload)
    Aes aes;
    int aesRet = wc_AesSetKey(&aes, decryptedKey, 16, decryptedIV, AES_DECRYPTION);
 8000a5c:	f507 735c 	add.w	r3, r7, #880	@ 0x370
 8000a60:	3b10      	subs	r3, #16
 8000a62:	f507 618e 	add.w	r1, r7, #1136	@ 0x470
 8000a66:	3910      	subs	r1, #16
 8000a68:	f507 700c 	add.w	r0, r7, #560	@ 0x230
 8000a6c:	381c      	subs	r0, #28
 8000a6e:	2201      	movs	r2, #1
 8000a70:	9200      	str	r2, [sp, #0]
 8000a72:	2210      	movs	r2, #16
 8000a74:	f011 fdae 	bl	80125d4 <wc_AesSetKey>
 8000a78:	f507 53b7 	add.w	r3, r7, #5856	@ 0x16e0
 8000a7c:	f103 0310 	add.w	r3, r3, #16
 8000a80:	6018      	str	r0, [r3, #0]
    if (aesRet != 0) {
 8000a82:	f507 53b7 	add.w	r3, r7, #5856	@ 0x16e0
 8000a86:	f103 0310 	add.w	r3, r3, #16
 8000a8a:	681b      	ldr	r3, [r3, #0]
 8000a8c:	2b00      	cmp	r3, #0
 8000a8e:	d008      	beq.n	8000aa2 <thirdMessageHandler+0x332>
        printf("AES key setup failed: %d\n", aesRet);
 8000a90:	f507 53b7 	add.w	r3, r7, #5856	@ 0x16e0
 8000a94:	f103 0310 	add.w	r3, r3, #16
 8000a98:	6819      	ldr	r1, [r3, #0]
 8000a9a:	481f      	ldr	r0, [pc, #124]	@ (8000b18 <thirdMessageHandler+0x3a8>)
 8000a9c:	f027 ff1a 	bl	80288d4 <iprintf>
        return;
 8000aa0:	e0a8      	b.n	8000bf4 <thirdMessageHandler+0x484>
    }
    uint8_t decryptedPayload[512];
    aesRet = wc_AesCbcDecrypt(&aes, decryptedPayload, payload, 512);
 8000aa2:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000aa6:	f2a3 720c 	subw	r2, r3, #1804	@ 0x70c
 8000aaa:	f107 0130 	add.w	r1, r7, #48	@ 0x30
 8000aae:	391c      	subs	r1, #28
 8000ab0:	f507 700c 	add.w	r0, r7, #560	@ 0x230
 8000ab4:	381c      	subs	r0, #28
 8000ab6:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000aba:	6812      	ldr	r2, [r2, #0]
 8000abc:	f011 fe19 	bl	80126f2 <wc_AesCbcDecrypt>
 8000ac0:	f507 53b7 	add.w	r3, r7, #5856	@ 0x16e0
 8000ac4:	f103 0310 	add.w	r3, r3, #16
 8000ac8:	6018      	str	r0, [r3, #0]
    if (aesRet != 0) {
 8000aca:	f507 53b7 	add.w	r3, r7, #5856	@ 0x16e0
 8000ace:	f103 0310 	add.w	r3, r3, #16
 8000ad2:	681b      	ldr	r3, [r3, #0]
 8000ad4:	2b00      	cmp	r3, #0
 8000ad6:	d023      	beq.n	8000b20 <thirdMessageHandler+0x3b0>
        printf("AES decryption failed: %d\n", aesRet);
 8000ad8:	f507 53b7 	add.w	r3, r7, #5856	@ 0x16e0
 8000adc:	f103 0310 	add.w	r3, r3, #16
 8000ae0:	6819      	ldr	r1, [r3, #0]
 8000ae2:	480e      	ldr	r0, [pc, #56]	@ (8000b1c <thirdMessageHandler+0x3ac>)
 8000ae4:	f027 fef6 	bl	80288d4 <iprintf>
        return;
 8000ae8:	e084      	b.n	8000bf4 <thirdMessageHandler+0x484>
 8000aea:	bf00      	nop
 8000aec:	08031ab2 	.word	0x08031ab2
 8000af0:	08031684 	.word	0x08031684
 8000af4:	0802990c 	.word	0x0802990c
 8000af8:	0802992c 	.word	0x0802992c
 8000afc:	08029948 	.word	0x08029948
 8000b00:	200001ac 	.word	0x200001ac
 8000b04:	08029974 	.word	0x08029974
 8000b08:	08029990 	.word	0x08029990
 8000b0c:	08031680 	.word	0x08031680
 8000b10:	080311d8 	.word	0x080311d8
 8000b14:	080299b0 	.word	0x080299b0
 8000b18:	080299d8 	.word	0x080299d8
 8000b1c:	080299f4 	.word	0x080299f4
    }
    memcpy(thirdMessage.timestamp, &decryptedPayload[0], 4);
 8000b20:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000b24:	f2a3 63fc 	subw	r3, r3, #1788	@ 0x6fc
 8000b28:	681b      	ldr	r3, [r3, #0]
 8000b2a:	4a35      	ldr	r2, [pc, #212]	@ (8000c00 <thirdMessageHandler+0x490>)
 8000b2c:	6013      	str	r3, [r2, #0]
    memcpy(thirdMessage.session_key, &decryptedPayload[4], 16);
 8000b2e:	4a34      	ldr	r2, [pc, #208]	@ (8000c00 <thirdMessageHandler+0x490>)
 8000b30:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000b34:	f2a3 63fc 	subw	r3, r3, #1788	@ 0x6fc
 8000b38:	1d14      	adds	r4, r2, #4
 8000b3a:	3304      	adds	r3, #4
 8000b3c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000b3e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    memcpy(thirdMessage.session_IV, &decryptedPayload[20], 16);
 8000b42:	4a2f      	ldr	r2, [pc, #188]	@ (8000c00 <thirdMessageHandler+0x490>)
 8000b44:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000b48:	f2a3 63fc 	subw	r3, r3, #1788	@ 0x6fc
 8000b4c:	f102 0414 	add.w	r4, r2, #20
 8000b50:	3314      	adds	r3, #20
 8000b52:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000b54:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    memcpy(thirdMessage.Tid_one, &decryptedPayload[36], 4);
 8000b58:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000b5c:	f2a3 63fc 	subw	r3, r3, #1788	@ 0x6fc
 8000b60:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000b62:	4a27      	ldr	r2, [pc, #156]	@ (8000c00 <thirdMessageHandler+0x490>)
 8000b64:	6253      	str	r3, [r2, #36]	@ 0x24
    memcpy(thirdMessage.Tid_two, &decryptedPayload[40], 4);
 8000b66:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000b6a:	f2a3 63fc 	subw	r3, r3, #1788	@ 0x6fc
 8000b6e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000b70:	4a23      	ldr	r2, [pc, #140]	@ (8000c00 <thirdMessageHandler+0x490>)
 8000b72:	6293      	str	r3, [r2, #40]	@ 0x28
    memcpy(thirdMessage.Tid_three, &decryptedPayload[44], 4);
 8000b74:	f507 63e2 	add.w	r3, r7, #1808	@ 0x710
 8000b78:	f2a3 63fc 	subw	r3, r3, #1788	@ 0x6fc
 8000b7c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8000b7e:	4a20      	ldr	r2, [pc, #128]	@ (8000c00 <thirdMessageHandler+0x490>)
 8000b80:	62d3      	str	r3, [r2, #44]	@ 0x2c
    memcpy(thirdMessage.PC_id, &decryptedPayload[48], 8);
 8000b82:	4b1f      	ldr	r3, [pc, #124]	@ (8000c00 <thirdMessageHandler+0x490>)
 8000b84:	f507 62e2 	add.w	r2, r7, #1808	@ 0x710
 8000b88:	f2a2 62fc 	subw	r2, r2, #1788	@ 0x6fc
 8000b8c:	3330      	adds	r3, #48	@ 0x30
 8000b8e:	3230      	adds	r2, #48	@ 0x30
 8000b90:	e892 0003 	ldmia.w	r2, {r0, r1}
 8000b94:	e883 0003 	stmia.w	r3, {r0, r1}
    wc_FreeRsaKey(&rsaKey);
 8000b98:	f507 63b2 	add.w	r3, r7, #1424	@ 0x590
 8000b9c:	3b1c      	subs	r3, #28
 8000b9e:	4618      	mov	r0, r3
 8000ba0:	f01f faf0 	bl	8020184 <wc_FreeRsaKey>
    wc_FreeRng(&rng);
 8000ba4:	f507 63ae 	add.w	r3, r7, #1392	@ 0x570
 8000ba8:	3b0c      	subs	r3, #12
 8000baa:	4618      	mov	r0, r3
 8000bac:	f01e fe8e 	bl	801f8cc <wc_FreeRng>
    wc_AesFree(&aes);
 8000bb0:	f507 730c 	add.w	r3, r7, #560	@ 0x230
 8000bb4:	3b1c      	subs	r3, #28
 8000bb6:	4618      	mov	r0, r3
 8000bb8:	f011 fe12 	bl	80127e0 <wc_AesFree>
    // skontrolujme este ci prijaty token ID ladi s tym co sme odoslali v druhej sprave
    if(memcmp(secondMessage.Tid_one, thirdMessage.Tid_one, sizeof(secondMessage.Tid_one)) != 0 ||
 8000bbc:	2204      	movs	r2, #4
 8000bbe:	4911      	ldr	r1, [pc, #68]	@ (8000c04 <thirdMessageHandler+0x494>)
 8000bc0:	4811      	ldr	r0, [pc, #68]	@ (8000c08 <thirdMessageHandler+0x498>)
 8000bc2:	f028 f805 	bl	8028bd0 <memcmp>
 8000bc6:	4603      	mov	r3, r0
 8000bc8:	2b00      	cmp	r3, #0
 8000bca:	d112      	bne.n	8000bf2 <thirdMessageHandler+0x482>
    		memcmp(secondMessage.Tid_two, thirdMessage.Tid_two, sizeof(secondMessage.Tid_two)) != 0 ||
 8000bcc:	2204      	movs	r2, #4
 8000bce:	490f      	ldr	r1, [pc, #60]	@ (8000c0c <thirdMessageHandler+0x49c>)
 8000bd0:	480f      	ldr	r0, [pc, #60]	@ (8000c10 <thirdMessageHandler+0x4a0>)
 8000bd2:	f027 fffd 	bl	8028bd0 <memcmp>
 8000bd6:	4603      	mov	r3, r0
    if(memcmp(secondMessage.Tid_one, thirdMessage.Tid_one, sizeof(secondMessage.Tid_one)) != 0 ||
 8000bd8:	2b00      	cmp	r3, #0
 8000bda:	d10a      	bne.n	8000bf2 <thirdMessageHandler+0x482>
    				memcmp(secondMessage.Tid_three, thirdMessage.Tid_three, sizeof(secondMessage.Tid_three)) != 0) {
 8000bdc:	2204      	movs	r2, #4
 8000bde:	490d      	ldr	r1, [pc, #52]	@ (8000c14 <thirdMessageHandler+0x4a4>)
 8000be0:	480d      	ldr	r0, [pc, #52]	@ (8000c18 <thirdMessageHandler+0x4a8>)
 8000be2:	f027 fff5 	bl	8028bd0 <memcmp>
 8000be6:	4603      	mov	r3, r0
    		memcmp(secondMessage.Tid_two, thirdMessage.Tid_two, sizeof(secondMessage.Tid_two)) != 0 ||
 8000be8:	2b00      	cmp	r3, #0
 8000bea:	d102      	bne.n	8000bf2 <thirdMessageHandler+0x482>
    	return;
    }
	fourthMessageSender();
 8000bec:	f000 f816 	bl	8000c1c <fourthMessageSender>
 8000bf0:	e000      	b.n	8000bf4 <thirdMessageHandler+0x484>
    	return;
 8000bf2:	bf00      	nop
}
 8000bf4:	f507 57b8 	add.w	r7, r7, #5888	@ 0x1700
 8000bf8:	3714      	adds	r7, #20
 8000bfa:	46bd      	mov	sp, r7
 8000bfc:	bd90      	pop	{r4, r7, pc}
 8000bfe:	bf00      	nop
 8000c00:	20000664 	.word	0x20000664
 8000c04:	20000688 	.word	0x20000688
 8000c08:	20000008 	.word	0x20000008
 8000c0c:	2000068c 	.word	0x2000068c
 8000c10:	2000000c 	.word	0x2000000c
 8000c14:	20000690 	.word	0x20000690
 8000c18:	20000010 	.word	0x20000010

08000c1c <fourthMessageSender>:

void fourthMessageSender() {
 8000c1c:	b5b0      	push	{r4, r5, r7, lr}
 8000c1e:	f5ad 6db0 	sub.w	sp, sp, #1408	@ 0x580
 8000c22:	af02      	add	r7, sp, #8
	// inkrementujme timestamp o 1
	uint32_t timestamp = (thirdMessage.timestamp[3] << 24) | (thirdMessage.timestamp[2] << 16) |
 8000c24:	4b62      	ldr	r3, [pc, #392]	@ (8000db0 <fourthMessageSender+0x194>)
 8000c26:	78db      	ldrb	r3, [r3, #3]
 8000c28:	061a      	lsls	r2, r3, #24
 8000c2a:	4b61      	ldr	r3, [pc, #388]	@ (8000db0 <fourthMessageSender+0x194>)
 8000c2c:	789b      	ldrb	r3, [r3, #2]
 8000c2e:	041b      	lsls	r3, r3, #16
 8000c30:	431a      	orrs	r2, r3
	     ( thirdMessage.timestamp[1] << 8 ) | (thirdMessage.timestamp[0]);
 8000c32:	4b5f      	ldr	r3, [pc, #380]	@ (8000db0 <fourthMessageSender+0x194>)
 8000c34:	785b      	ldrb	r3, [r3, #1]
 8000c36:	021b      	lsls	r3, r3, #8
	uint32_t timestamp = (thirdMessage.timestamp[3] << 24) | (thirdMessage.timestamp[2] << 16) |
 8000c38:	4313      	orrs	r3, r2
	     ( thirdMessage.timestamp[1] << 8 ) | (thirdMessage.timestamp[0]);
 8000c3a:	4a5d      	ldr	r2, [pc, #372]	@ (8000db0 <fourthMessageSender+0x194>)
 8000c3c:	7812      	ldrb	r2, [r2, #0]
 8000c3e:	4313      	orrs	r3, r2
	uint32_t timestamp = (thirdMessage.timestamp[3] << 24) | (thirdMessage.timestamp[2] << 16) |
 8000c40:	f8c7 3574 	str.w	r3, [r7, #1396]	@ 0x574
	timestamp += 1;
 8000c44:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c48:	3301      	adds	r3, #1
 8000c4a:	f8c7 3574 	str.w	r3, [r7, #1396]	@ 0x574
	// pripravme si  takmer celu stvrtu spravu podla struktury MessageFour
	fourthMessage.timestamp[0] = (timestamp & 0x000000ff);
 8000c4e:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c52:	b2da      	uxtb	r2, r3
 8000c54:	4b57      	ldr	r3, [pc, #348]	@ (8000db4 <fourthMessageSender+0x198>)
 8000c56:	701a      	strb	r2, [r3, #0]
	fourthMessage.timestamp[1] = (timestamp & 0x0000ff00) >> 8;
 8000c58:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c5c:	0a1b      	lsrs	r3, r3, #8
 8000c5e:	b2da      	uxtb	r2, r3
 8000c60:	4b54      	ldr	r3, [pc, #336]	@ (8000db4 <fourthMessageSender+0x198>)
 8000c62:	705a      	strb	r2, [r3, #1]
	fourthMessage.timestamp[2] = (timestamp & 0x00ff0000) >> 16;
 8000c64:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c68:	0c1b      	lsrs	r3, r3, #16
 8000c6a:	b2da      	uxtb	r2, r3
 8000c6c:	4b51      	ldr	r3, [pc, #324]	@ (8000db4 <fourthMessageSender+0x198>)
 8000c6e:	709a      	strb	r2, [r3, #2]
	fourthMessage.timestamp[3] = (timestamp & 0xff000000) >> 24;
 8000c70:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c74:	0e1b      	lsrs	r3, r3, #24
 8000c76:	b2da      	uxtb	r2, r3
 8000c78:	4b4e      	ldr	r3, [pc, #312]	@ (8000db4 <fourthMessageSender+0x198>)
 8000c7a:	70da      	strb	r2, [r3, #3]
	memcpy(fourthMessage.Tid_one, thirdMessage.Tid_one, 4);
 8000c7c:	4b4c      	ldr	r3, [pc, #304]	@ (8000db0 <fourthMessageSender+0x194>)
 8000c7e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000c80:	4a4c      	ldr	r2, [pc, #304]	@ (8000db4 <fourthMessageSender+0x198>)
 8000c82:	6053      	str	r3, [r2, #4]
	memcpy(fourthMessage.Tid_two, thirdMessage.Tid_two, 4);
 8000c84:	4b4a      	ldr	r3, [pc, #296]	@ (8000db0 <fourthMessageSender+0x194>)
 8000c86:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000c88:	4a4a      	ldr	r2, [pc, #296]	@ (8000db4 <fourthMessageSender+0x198>)
 8000c8a:	6093      	str	r3, [r2, #8]
	memcpy(fourthMessage.Tid_three, thirdMessage.Tid_three, 4);
 8000c8c:	4b48      	ldr	r3, [pc, #288]	@ (8000db0 <fourthMessageSender+0x194>)
 8000c8e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8000c90:	4a48      	ldr	r2, [pc, #288]	@ (8000db4 <fourthMessageSender+0x198>)
 8000c92:	60d3      	str	r3, [r2, #12]
	memcpy(fourthMessage.PC_id, thirdMessage.PC_id, 8);
 8000c94:	4b47      	ldr	r3, [pc, #284]	@ (8000db4 <fourthMessageSender+0x198>)
 8000c96:	4a46      	ldr	r2, [pc, #280]	@ (8000db0 <fourthMessageSender+0x194>)
 8000c98:	3310      	adds	r3, #16
 8000c9a:	3230      	adds	r2, #48	@ 0x30
 8000c9c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8000ca0:	e883 0003 	stmia.w	r3, {r0, r1}
	// este vygenerujme nonce
	uint8_t randomBytes[16];
	WC_RNG rng;
	if (wc_InitRng(&rng) != 0) {
 8000ca4:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000ca8:	4618      	mov	r0, r3
 8000caa:	f01e fd5c 	bl	801f766 <wc_InitRng>
 8000cae:	4603      	mov	r3, r0
 8000cb0:	2b00      	cmp	r3, #0
 8000cb2:	d177      	bne.n	8000da4 <fourthMessageSender+0x188>
	    return;
	}
	if (wc_RNG_GenerateBlock(&rng, randomBytes, sizeof(randomBytes)) != 0) {
 8000cb4:	f507 61ac 	add.w	r1, r7, #1376	@ 0x560
 8000cb8:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000cbc:	2210      	movs	r2, #16
 8000cbe:	4618      	mov	r0, r3
 8000cc0:	f01e fd63 	bl	801f78a <wc_RNG_GenerateBlock>
 8000cc4:	4603      	mov	r3, r0
 8000cc6:	2b00      	cmp	r3, #0
 8000cc8:	d005      	beq.n	8000cd6 <fourthMessageSender+0xba>
	    wc_FreeRng(&rng);
 8000cca:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000cce:	4618      	mov	r0, r3
 8000cd0:	f01e fdfc 	bl	801f8cc <wc_FreeRng>
	    return;
 8000cd4:	e067      	b.n	8000da6 <fourthMessageSender+0x18a>
	}
	wc_FreeRng(&rng);
 8000cd6:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000cda:	4618      	mov	r0, r3
 8000cdc:	f01e fdf6 	bl	801f8cc <wc_FreeRng>
	memcpy(fourthMessage.T_nonce, randomBytes, 16);
 8000ce0:	4b34      	ldr	r3, [pc, #208]	@ (8000db4 <fourthMessageSender+0x198>)
 8000ce2:	f103 0418 	add.w	r4, r3, #24
 8000ce6:	f507 63ac 	add.w	r3, r7, #1376	@ 0x560
 8000cea:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000cec:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	// nasledne zasifrujme spravu cez sessionKey
	unsigned char paddedPlaintext[512] = {0};
 8000cf0:	f507 63af 	add.w	r3, r7, #1400	@ 0x578
 8000cf4:	f5a3 730a 	sub.w	r3, r3, #552	@ 0x228
 8000cf8:	4618      	mov	r0, r3
 8000cfa:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000cfe:	461a      	mov	r2, r3
 8000d00:	2100      	movs	r1, #0
 8000d02:	f027 ff8f 	bl	8028c24 <memset>
	memcpy(paddedPlaintext, &fourthMessage, sizeof(fourthMessage));
 8000d06:	f507 63af 	add.w	r3, r7, #1400	@ 0x578
 8000d0a:	f5a3 730a 	sub.w	r3, r3, #552	@ 0x228
 8000d0e:	4a29      	ldr	r2, [pc, #164]	@ (8000db4 <fourthMessageSender+0x198>)
 8000d10:	461c      	mov	r4, r3
 8000d12:	4615      	mov	r5, r2
 8000d14:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d16:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d18:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d1a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d1c:	e895 0003 	ldmia.w	r5, {r0, r1}
 8000d20:	e884 0003 	stmia.w	r4, {r0, r1}
	Aes aes;
	int aesRet = wc_AesSetKey(&aes, thirdMessage.session_key, 16, thirdMessage.session_IV, AES_ENCRYPTION);
 8000d24:	f507 7001 	add.w	r0, r7, #516	@ 0x204
 8000d28:	2300      	movs	r3, #0
 8000d2a:	9300      	str	r3, [sp, #0]
 8000d2c:	4b22      	ldr	r3, [pc, #136]	@ (8000db8 <fourthMessageSender+0x19c>)
 8000d2e:	2210      	movs	r2, #16
 8000d30:	4922      	ldr	r1, [pc, #136]	@ (8000dbc <fourthMessageSender+0x1a0>)
 8000d32:	f011 fc4f 	bl	80125d4 <wc_AesSetKey>
 8000d36:	f8c7 0570 	str.w	r0, [r7, #1392]	@ 0x570
	if (aesRet != 0) {
 8000d3a:	f8d7 3570 	ldr.w	r3, [r7, #1392]	@ 0x570
 8000d3e:	2b00      	cmp	r3, #0
 8000d40:	d005      	beq.n	8000d4e <fourthMessageSender+0x132>
	    printf("AES key setup failed: %d\n", aesRet);
 8000d42:	f8d7 1570 	ldr.w	r1, [r7, #1392]	@ 0x570
 8000d46:	481e      	ldr	r0, [pc, #120]	@ (8000dc0 <fourthMessageSender+0x1a4>)
 8000d48:	f027 fdc4 	bl	80288d4 <iprintf>
	    return;
 8000d4c:	e02b      	b.n	8000da6 <fourthMessageSender+0x18a>
	}
	uint8_t encryptedPayload[512];
	aesRet = wc_AesCbcEncrypt(&aes, encryptedPayload, paddedPlaintext, 512);
 8000d4e:	f507 7254 	add.w	r2, r7, #848	@ 0x350
 8000d52:	1d39      	adds	r1, r7, #4
 8000d54:	f507 7001 	add.w	r0, r7, #516	@ 0x204
 8000d58:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000d5c:	f011 fc7e 	bl	801265c <wc_AesCbcEncrypt>
 8000d60:	f8c7 0570 	str.w	r0, [r7, #1392]	@ 0x570
	if (aesRet != 0) {
 8000d64:	f8d7 3570 	ldr.w	r3, [r7, #1392]	@ 0x570
 8000d68:	2b00      	cmp	r3, #0
 8000d6a:	d005      	beq.n	8000d78 <fourthMessageSender+0x15c>
	    printf("AES encryption failed: %d\n", aesRet);
 8000d6c:	f8d7 1570 	ldr.w	r1, [r7, #1392]	@ 0x570
 8000d70:	4814      	ldr	r0, [pc, #80]	@ (8000dc4 <fourthMessageSender+0x1a8>)
 8000d72:	f027 fdaf 	bl	80288d4 <iprintf>
	    return;
 8000d76:	e016      	b.n	8000da6 <fourthMessageSender+0x18a>
	}
	// a potom vlozme ju do sendBuffer na odoslanie
	memcpy(sendBuffer, encryptedPayload, 512);
 8000d78:	4a13      	ldr	r2, [pc, #76]	@ (8000dc8 <fourthMessageSender+0x1ac>)
 8000d7a:	f507 63af 	add.w	r3, r7, #1400	@ 0x578
 8000d7e:	f2a3 5374 	subw	r3, r3, #1396	@ 0x574
 8000d82:	4610      	mov	r0, r2
 8000d84:	4619      	mov	r1, r3
 8000d86:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000d8a:	461a      	mov	r2, r3
 8000d8c:	f027 fffb 	bl	8028d86 <memcpy>
	sendCounter = 512;
 8000d90:	4b0e      	ldr	r3, [pc, #56]	@ (8000dcc <fourthMessageSender+0x1b0>)
 8000d92:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8000d96:	801a      	strh	r2, [r3, #0]
	wc_AesFree(&aes);
 8000d98:	f507 7301 	add.w	r3, r7, #516	@ 0x204
 8000d9c:	4618      	mov	r0, r3
 8000d9e:	f011 fd1f 	bl	80127e0 <wc_AesFree>
	return;
 8000da2:	e000      	b.n	8000da6 <fourthMessageSender+0x18a>
	    return;
 8000da4:	bf00      	nop
}
 8000da6:	f507 67af 	add.w	r7, r7, #1400	@ 0x578
 8000daa:	46bd      	mov	sp, r7
 8000dac:	bdb0      	pop	{r4, r5, r7, pc}
 8000dae:	bf00      	nop
 8000db0:	20000664 	.word	0x20000664
 8000db4:	2000069c 	.word	0x2000069c
 8000db8:	20000678 	.word	0x20000678
 8000dbc:	20000668 	.word	0x20000668
 8000dc0:	080299d8 	.word	0x080299d8
 8000dc4:	08029a10 	.word	0x08029a10
 8000dc8:	2000121c 	.word	0x2000121c
 8000dcc:	20001be0 	.word	0x20001be0

08000dd0 <fifthMessageHandler>:

void fifthMessageHandler(uint8_t* payload, uint8_t* sigHash, uint8_t* hash) {
 8000dd0:	b590      	push	{r4, r7, lr}
 8000dd2:	f2ad 4d0c 	subw	sp, sp, #1036	@ 0x40c
 8000dd6:	af04      	add	r7, sp, #16
 8000dd8:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000ddc:	f5a3 737b 	sub.w	r3, r3, #1004	@ 0x3ec
 8000de0:	6018      	str	r0, [r3, #0]
 8000de2:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000de6:	f5a3 737c 	sub.w	r3, r3, #1008	@ 0x3f0
 8000dea:	6019      	str	r1, [r3, #0]
 8000dec:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000df0:	f5a3 737d 	sub.w	r3, r3, #1012	@ 0x3f4
 8000df4:	601a      	str	r2, [r3, #0]
	Aes aes;
	int aesRet = wc_AesSetKey(&aes, thirdMessage.session_key, 16, thirdMessage.session_IV, AES_DECRYPTION);
 8000df6:	f507 7029 	add.w	r0, r7, #676	@ 0x2a4
 8000dfa:	2301      	movs	r3, #1
 8000dfc:	9300      	str	r3, [sp, #0]
 8000dfe:	4b70      	ldr	r3, [pc, #448]	@ (8000fc0 <fifthMessageHandler+0x1f0>)
 8000e00:	2210      	movs	r2, #16
 8000e02:	4970      	ldr	r1, [pc, #448]	@ (8000fc4 <fifthMessageHandler+0x1f4>)
 8000e04:	f011 fbe6 	bl	80125d4 <wc_AesSetKey>
 8000e08:	f8c7 03f4 	str.w	r0, [r7, #1012]	@ 0x3f4
	if (aesRet != 0) {
 8000e0c:	f8d7 33f4 	ldr.w	r3, [r7, #1012]	@ 0x3f4
 8000e10:	2b00      	cmp	r3, #0
 8000e12:	d005      	beq.n	8000e20 <fifthMessageHandler+0x50>
	    printf("AES key setup failed: %d\n", aesRet);
 8000e14:	f8d7 13f4 	ldr.w	r1, [r7, #1012]	@ 0x3f4
 8000e18:	486b      	ldr	r0, [pc, #428]	@ (8000fc8 <fifthMessageHandler+0x1f8>)
 8000e1a:	f027 fd5b 	bl	80288d4 <iprintf>
	    return;
 8000e1e:	e0ca      	b.n	8000fb6 <fifthMessageHandler+0x1e6>
	}
	uint8_t decryptedPayload[512];
	aesRet = wc_AesCbcDecrypt(&aes, decryptedPayload, payload, 512);
 8000e20:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000e24:	f5a3 727b 	sub.w	r2, r3, #1004	@ 0x3ec
 8000e28:	f107 01a4 	add.w	r1, r7, #164	@ 0xa4
 8000e2c:	f507 7029 	add.w	r0, r7, #676	@ 0x2a4
 8000e30:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000e34:	6812      	ldr	r2, [r2, #0]
 8000e36:	f011 fc5c 	bl	80126f2 <wc_AesCbcDecrypt>
 8000e3a:	f8c7 03f4 	str.w	r0, [r7, #1012]	@ 0x3f4
	if (aesRet != 0) {
 8000e3e:	f8d7 33f4 	ldr.w	r3, [r7, #1012]	@ 0x3f4
 8000e42:	2b00      	cmp	r3, #0
 8000e44:	d005      	beq.n	8000e52 <fifthMessageHandler+0x82>
	    printf("AES decryption failed: %d\n", aesRet);
 8000e46:	f8d7 13f4 	ldr.w	r1, [r7, #1012]	@ 0x3f4
 8000e4a:	4860      	ldr	r0, [pc, #384]	@ (8000fcc <fifthMessageHandler+0x1fc>)
 8000e4c:	f027 fd42 	bl	80288d4 <iprintf>
	    return;
 8000e50:	e0b1      	b.n	8000fb6 <fifthMessageHandler+0x1e6>
	}
	memcpy(fifthMessage.timestamp, &decryptedPayload[0], 4);
 8000e52:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000e56:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e5a:	681b      	ldr	r3, [r3, #0]
 8000e5c:	4a5c      	ldr	r2, [pc, #368]	@ (8000fd0 <fifthMessageHandler+0x200>)
 8000e5e:	6013      	str	r3, [r2, #0]
	memcpy(fifthMessage.Tid_one, &decryptedPayload[4], 4);
 8000e60:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000e64:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e68:	685b      	ldr	r3, [r3, #4]
 8000e6a:	4a59      	ldr	r2, [pc, #356]	@ (8000fd0 <fifthMessageHandler+0x200>)
 8000e6c:	6053      	str	r3, [r2, #4]
	memcpy(fifthMessage.Tid_two, &decryptedPayload[8], 4);
 8000e6e:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000e72:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e76:	689b      	ldr	r3, [r3, #8]
 8000e78:	4a55      	ldr	r2, [pc, #340]	@ (8000fd0 <fifthMessageHandler+0x200>)
 8000e7a:	6093      	str	r3, [r2, #8]
	memcpy(fifthMessage.Tid_three, &decryptedPayload[12], 4);
 8000e7c:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000e80:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e84:	68db      	ldr	r3, [r3, #12]
 8000e86:	4a52      	ldr	r2, [pc, #328]	@ (8000fd0 <fifthMessageHandler+0x200>)
 8000e88:	60d3      	str	r3, [r2, #12]
	memcpy(fifthMessage.PC_id, &decryptedPayload[16], 8);
 8000e8a:	4951      	ldr	r1, [pc, #324]	@ (8000fd0 <fifthMessageHandler+0x200>)
 8000e8c:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000e90:	f5a3 7255 	sub.w	r2, r3, #852	@ 0x354
 8000e94:	f101 0310 	add.w	r3, r1, #16
 8000e98:	3210      	adds	r2, #16
 8000e9a:	e892 0003 	ldmia.w	r2, {r0, r1}
 8000e9e:	e883 0003 	stmia.w	r3, {r0, r1}
	memcpy(fifthMessage.T_nonce, &decryptedPayload[24], 16);
 8000ea2:	4a4b      	ldr	r2, [pc, #300]	@ (8000fd0 <fifthMessageHandler+0x200>)
 8000ea4:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000ea8:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000eac:	f102 0418 	add.w	r4, r2, #24
 8000eb0:	3318      	adds	r3, #24
 8000eb2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000eb4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	wc_AesFree(&aes);
 8000eb8:	f507 7329 	add.w	r3, r7, #676	@ 0x2a4
 8000ebc:	4618      	mov	r0, r3
 8000ebe:	f011 fc8f 	bl	80127e0 <wc_AesFree>
	// teraz vytvorme SHA256 hash z prijatej piatej spravy
	Sha256 sha;
	uint8_t genHash[SHA256_DIGEST_SIZE];
	int hashRet = wc_InitSha256(&sha);
 8000ec2:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8000ec6:	4618      	mov	r0, r3
 8000ec8:	f021 f988 	bl	80221dc <wc_InitSha256>
 8000ecc:	f8c7 03f0 	str.w	r0, [r7, #1008]	@ 0x3f0
	hashRet = wc_Sha256Update(&sha, (const uint8_t*)&fifthMessage, sizeof(MessageFive));
 8000ed0:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8000ed4:	2228      	movs	r2, #40	@ 0x28
 8000ed6:	493e      	ldr	r1, [pc, #248]	@ (8000fd0 <fifthMessageHandler+0x200>)
 8000ed8:	4618      	mov	r0, r3
 8000eda:	f021 f8b6 	bl	802204a <wc_Sha256Update>
 8000ede:	f8c7 03f0 	str.w	r0, [r7, #1008]	@ 0x3f0
	hashRet = wc_Sha256Final(&sha, genHash);
 8000ee2:	f107 0214 	add.w	r2, r7, #20
 8000ee6:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8000eea:	4611      	mov	r1, r2
 8000eec:	4618      	mov	r0, r3
 8000eee:	f021 f94a 	bl	8022186 <wc_Sha256Final>
 8000ef2:	f8c7 03f0 	str.w	r0, [r7, #1008]	@ 0x3f0
	// kontrolujme token id, PC id a nonce ci su rovnake
	if(memcmp(fifthMessage.Tid_one, fourthMessage.Tid_one, sizeof(fourthMessage.Tid_one)) != 0 ||
 8000ef6:	2204      	movs	r2, #4
 8000ef8:	4936      	ldr	r1, [pc, #216]	@ (8000fd4 <fifthMessageHandler+0x204>)
 8000efa:	4837      	ldr	r0, [pc, #220]	@ (8000fd8 <fifthMessageHandler+0x208>)
 8000efc:	f027 fe68 	bl	8028bd0 <memcmp>
 8000f00:	4603      	mov	r3, r0
 8000f02:	2b00      	cmp	r3, #0
 8000f04:	d152      	bne.n	8000fac <fifthMessageHandler+0x1dc>
			memcmp(fifthMessage.Tid_two, fourthMessage.Tid_two, sizeof(fourthMessage.Tid_two)) != 0 ||
 8000f06:	2204      	movs	r2, #4
 8000f08:	4934      	ldr	r1, [pc, #208]	@ (8000fdc <fifthMessageHandler+0x20c>)
 8000f0a:	4835      	ldr	r0, [pc, #212]	@ (8000fe0 <fifthMessageHandler+0x210>)
 8000f0c:	f027 fe60 	bl	8028bd0 <memcmp>
 8000f10:	4603      	mov	r3, r0
	if(memcmp(fifthMessage.Tid_one, fourthMessage.Tid_one, sizeof(fourthMessage.Tid_one)) != 0 ||
 8000f12:	2b00      	cmp	r3, #0
 8000f14:	d14a      	bne.n	8000fac <fifthMessageHandler+0x1dc>
					memcmp(fifthMessage.Tid_three, fourthMessage.Tid_three, sizeof(fourthMessage.Tid_three)) != 0) {
 8000f16:	2204      	movs	r2, #4
 8000f18:	4932      	ldr	r1, [pc, #200]	@ (8000fe4 <fifthMessageHandler+0x214>)
 8000f1a:	4833      	ldr	r0, [pc, #204]	@ (8000fe8 <fifthMessageHandler+0x218>)
 8000f1c:	f027 fe58 	bl	8028bd0 <memcmp>
 8000f20:	4603      	mov	r3, r0
			memcmp(fifthMessage.Tid_two, fourthMessage.Tid_two, sizeof(fourthMessage.Tid_two)) != 0 ||
 8000f22:	2b00      	cmp	r3, #0
 8000f24:	d142      	bne.n	8000fac <fifthMessageHandler+0x1dc>
		return;
	}
	if(memcmp(fifthMessage.PC_id, fourthMessage.PC_id, sizeof(fourthMessage.PC_id)) != 0) {
 8000f26:	2208      	movs	r2, #8
 8000f28:	4930      	ldr	r1, [pc, #192]	@ (8000fec <fifthMessageHandler+0x21c>)
 8000f2a:	4831      	ldr	r0, [pc, #196]	@ (8000ff0 <fifthMessageHandler+0x220>)
 8000f2c:	f027 fe50 	bl	8028bd0 <memcmp>
 8000f30:	4603      	mov	r3, r0
 8000f32:	2b00      	cmp	r3, #0
 8000f34:	d13c      	bne.n	8000fb0 <fifthMessageHandler+0x1e0>
	    return;
	}
	if(memcmp(fifthMessage.T_nonce, fourthMessage.T_nonce, sizeof(fourthMessage.T_nonce)) != 0) {
 8000f36:	2210      	movs	r2, #16
 8000f38:	492e      	ldr	r1, [pc, #184]	@ (8000ff4 <fifthMessageHandler+0x224>)
 8000f3a:	482f      	ldr	r0, [pc, #188]	@ (8000ff8 <fifthMessageHandler+0x228>)
 8000f3c:	f027 fe48 	bl	8028bd0 <memcmp>
 8000f40:	4603      	mov	r3, r0
 8000f42:	2b00      	cmp	r3, #0
 8000f44:	d136      	bne.n	8000fb4 <fifthMessageHandler+0x1e4>
		    return;
	}
	// skontrolujme, ci prijaty hash sa zhoduje s tym co sme vytvorili z prijatych dat
	if(memcmp(hash, genHash, sizeof(genHash)) == 0) {
 8000f46:	f107 0114 	add.w	r1, r7, #20
 8000f4a:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000f4e:	f5a3 737d 	sub.w	r3, r3, #1012	@ 0x3f4
 8000f52:	2220      	movs	r2, #32
 8000f54:	6818      	ldr	r0, [r3, #0]
 8000f56:	f027 fe3b 	bl	8028bd0 <memcmp>
 8000f5a:	4603      	mov	r3, r0
 8000f5c:	2b00      	cmp	r3, #0
 8000f5e:	d12a      	bne.n	8000fb6 <fifthMessageHandler+0x1e6>
		// ak ano, tak overme este, ci prijaty podpisany hash je podpisany vypoctovym zariadenim
		if(extractedPCCert.publicKey != NULL) {
 8000f60:	4b26      	ldr	r3, [pc, #152]	@ (8000ffc <fifthMessageHandler+0x22c>)
 8000f62:	681b      	ldr	r3, [r3, #0]
 8000f64:	2b00      	cmp	r3, #0
 8000f66:	d026      	beq.n	8000fb6 <fifthMessageHandler+0x1e6>
			hashRet = wc_SignatureVerify(
							WC_HASH_TYPE_SHA256,
					        WC_SIGNATURE_TYPE_NONE,    // RSA      // SHA-256
					        hash, 32,              	  // prijaty hash
					        sigHash, 256,          	  // prijaty podpisany hash
					        extractedPCCert.publicKey,
 8000f68:	4b24      	ldr	r3, [pc, #144]	@ (8000ffc <fifthMessageHandler+0x22c>)
 8000f6a:	681b      	ldr	r3, [r3, #0]
			hashRet = wc_SignatureVerify(
 8000f6c:	4a23      	ldr	r2, [pc, #140]	@ (8000ffc <fifthMessageHandler+0x22c>)
 8000f6e:	6851      	ldr	r1, [r2, #4]
 8000f70:	f507 727e 	add.w	r2, r7, #1016	@ 0x3f8
 8000f74:	f5a2 727d 	sub.w	r2, r2, #1012	@ 0x3f4
 8000f78:	9103      	str	r1, [sp, #12]
 8000f7a:	9302      	str	r3, [sp, #8]
 8000f7c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000f80:	9301      	str	r3, [sp, #4]
 8000f82:	f507 737e 	add.w	r3, r7, #1016	@ 0x3f8
 8000f86:	f5a3 737c 	sub.w	r3, r3, #1008	@ 0x3f0
 8000f8a:	681b      	ldr	r3, [r3, #0]
 8000f8c:	9300      	str	r3, [sp, #0]
 8000f8e:	2320      	movs	r3, #32
 8000f90:	6812      	ldr	r2, [r2, #0]
 8000f92:	2100      	movs	r1, #0
 8000f94:	2006      	movs	r0, #6
 8000f96:	f021 fa58 	bl	802244a <wc_SignatureVerify>
 8000f9a:	f8c7 03f0 	str.w	r0, [r7, #1008]	@ 0x3f0
							extractedPCCert.pubKeySize // extrahovany verejny kluc
					    );
			if(hashRet == 0) {
 8000f9e:	f8d7 33f0 	ldr.w	r3, [r7, #1008]	@ 0x3f0
 8000fa2:	2b00      	cmp	r3, #0
 8000fa4:	d107      	bne.n	8000fb6 <fifthMessageHandler+0x1e6>
				sixthMessageSender();
 8000fa6:	f000 f82b 	bl	8001000 <sixthMessageSender>
 8000faa:	e004      	b.n	8000fb6 <fifthMessageHandler+0x1e6>
		return;
 8000fac:	bf00      	nop
 8000fae:	e002      	b.n	8000fb6 <fifthMessageHandler+0x1e6>
	    return;
 8000fb0:	bf00      	nop
 8000fb2:	e000      	b.n	8000fb6 <fifthMessageHandler+0x1e6>
		    return;
 8000fb4:	bf00      	nop
			}
		}
	}
}
 8000fb6:	f507 777f 	add.w	r7, r7, #1020	@ 0x3fc
 8000fba:	46bd      	mov	sp, r7
 8000fbc:	bd90      	pop	{r4, r7, pc}
 8000fbe:	bf00      	nop
 8000fc0:	20000678 	.word	0x20000678
 8000fc4:	20000668 	.word	0x20000668
 8000fc8:	080299d8 	.word	0x080299d8
 8000fcc:	080299f4 	.word	0x080299f4
 8000fd0:	200006c4 	.word	0x200006c4
 8000fd4:	200006a0 	.word	0x200006a0
 8000fd8:	200006c8 	.word	0x200006c8
 8000fdc:	200006a4 	.word	0x200006a4
 8000fe0:	200006cc 	.word	0x200006cc
 8000fe4:	200006a8 	.word	0x200006a8
 8000fe8:	200006d0 	.word	0x200006d0
 8000fec:	200006ac 	.word	0x200006ac
 8000ff0:	200006d4 	.word	0x200006d4
 8000ff4:	200006b4 	.word	0x200006b4
 8000ff8:	200006dc 	.word	0x200006dc
 8000ffc:	200001ac 	.word	0x200001ac

08001000 <sixthMessageSender>:

void sixthMessageSender() {
 8001000:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001002:	f2ad 5d8c 	subw	sp, sp, #1420	@ 0x58c
 8001006:	af02      	add	r7, sp, #8
	// inkrementujme timestamp o 1
	uint32_t timestamp = (fifthMessage.timestamp[3] << 24) | (fifthMessage.timestamp[2] << 16) |
 8001008:	4b7a      	ldr	r3, [pc, #488]	@ (80011f4 <sixthMessageSender+0x1f4>)
 800100a:	78db      	ldrb	r3, [r3, #3]
 800100c:	061a      	lsls	r2, r3, #24
 800100e:	4b79      	ldr	r3, [pc, #484]	@ (80011f4 <sixthMessageSender+0x1f4>)
 8001010:	789b      	ldrb	r3, [r3, #2]
 8001012:	041b      	lsls	r3, r3, #16
 8001014:	431a      	orrs	r2, r3
		     ( fifthMessage.timestamp[1] << 8 ) | (fifthMessage.timestamp[0]);
 8001016:	4b77      	ldr	r3, [pc, #476]	@ (80011f4 <sixthMessageSender+0x1f4>)
 8001018:	785b      	ldrb	r3, [r3, #1]
 800101a:	021b      	lsls	r3, r3, #8
	uint32_t timestamp = (fifthMessage.timestamp[3] << 24) | (fifthMessage.timestamp[2] << 16) |
 800101c:	4313      	orrs	r3, r2
		     ( fifthMessage.timestamp[1] << 8 ) | (fifthMessage.timestamp[0]);
 800101e:	4a75      	ldr	r2, [pc, #468]	@ (80011f4 <sixthMessageSender+0x1f4>)
 8001020:	7812      	ldrb	r2, [r2, #0]
 8001022:	4313      	orrs	r3, r2
	uint32_t timestamp = (fifthMessage.timestamp[3] << 24) | (fifthMessage.timestamp[2] << 16) |
 8001024:	f8c7 357c 	str.w	r3, [r7, #1404]	@ 0x57c
	timestamp += 1;
 8001028:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 800102c:	3301      	adds	r3, #1
 800102e:	f8c7 357c 	str.w	r3, [r7, #1404]	@ 0x57c
	// pripravme si takmer celu siestu spravu podla struktury MessageSix
	sixthMessage.timestamp[0] = (timestamp & 0x000000ff);
 8001032:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8001036:	b2da      	uxtb	r2, r3
 8001038:	4b6f      	ldr	r3, [pc, #444]	@ (80011f8 <sixthMessageSender+0x1f8>)
 800103a:	701a      	strb	r2, [r3, #0]
	sixthMessage.timestamp[1] = (timestamp & 0x0000ff00) >> 8;
 800103c:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8001040:	0a1b      	lsrs	r3, r3, #8
 8001042:	b2da      	uxtb	r2, r3
 8001044:	4b6c      	ldr	r3, [pc, #432]	@ (80011f8 <sixthMessageSender+0x1f8>)
 8001046:	705a      	strb	r2, [r3, #1]
	sixthMessage.timestamp[2] = (timestamp & 0x00ff0000) >> 16;
 8001048:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 800104c:	0c1b      	lsrs	r3, r3, #16
 800104e:	b2da      	uxtb	r2, r3
 8001050:	4b69      	ldr	r3, [pc, #420]	@ (80011f8 <sixthMessageSender+0x1f8>)
 8001052:	709a      	strb	r2, [r3, #2]
	sixthMessage.timestamp[3] = (timestamp & 0xff000000) >> 24;
 8001054:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8001058:	0e1b      	lsrs	r3, r3, #24
 800105a:	b2da      	uxtb	r2, r3
 800105c:	4b66      	ldr	r3, [pc, #408]	@ (80011f8 <sixthMessageSender+0x1f8>)
 800105e:	70da      	strb	r2, [r3, #3]
	memcpy(sixthMessage.Tid_one, fifthMessage.Tid_one, 4);
 8001060:	4b64      	ldr	r3, [pc, #400]	@ (80011f4 <sixthMessageSender+0x1f4>)
 8001062:	685b      	ldr	r3, [r3, #4]
 8001064:	4a64      	ldr	r2, [pc, #400]	@ (80011f8 <sixthMessageSender+0x1f8>)
 8001066:	6053      	str	r3, [r2, #4]
	memcpy(sixthMessage.Tid_two, fifthMessage.Tid_two, 4);
 8001068:	4b62      	ldr	r3, [pc, #392]	@ (80011f4 <sixthMessageSender+0x1f4>)
 800106a:	689b      	ldr	r3, [r3, #8]
 800106c:	4a62      	ldr	r2, [pc, #392]	@ (80011f8 <sixthMessageSender+0x1f8>)
 800106e:	6093      	str	r3, [r2, #8]
	memcpy(sixthMessage.Tid_three, fifthMessage.Tid_three, 4);
 8001070:	4b60      	ldr	r3, [pc, #384]	@ (80011f4 <sixthMessageSender+0x1f4>)
 8001072:	68db      	ldr	r3, [r3, #12]
 8001074:	4a60      	ldr	r2, [pc, #384]	@ (80011f8 <sixthMessageSender+0x1f8>)
 8001076:	60d3      	str	r3, [r2, #12]
	memcpy(sixthMessage.PC_id, fifthMessage.PC_id, 8);
 8001078:	4b5f      	ldr	r3, [pc, #380]	@ (80011f8 <sixthMessageSender+0x1f8>)
 800107a:	4a5e      	ldr	r2, [pc, #376]	@ (80011f4 <sixthMessageSender+0x1f4>)
 800107c:	3310      	adds	r3, #16
 800107e:	3210      	adds	r2, #16
 8001080:	e892 0003 	ldmia.w	r2, {r0, r1}
 8001084:	e883 0003 	stmia.w	r3, {r0, r1}
	// treba este vlozit druhu cast hlavneho kluca, na tu vsak potrebujeme interakciu s tlacidlom na tokene
	GPIO_InitTypeDef gpioLed = {0};
 8001088:	f507 63ac 	add.w	r3, r7, #1376	@ 0x560
 800108c:	2200      	movs	r2, #0
 800108e:	601a      	str	r2, [r3, #0]
 8001090:	605a      	str	r2, [r3, #4]
 8001092:	609a      	str	r2, [r3, #8]
 8001094:	60da      	str	r2, [r3, #12]
 8001096:	611a      	str	r2, [r3, #16]
	gpioLed.Pin = GPIO_PIN_12;
 8001098:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 800109c:	f8c7 3560 	str.w	r3, [r7, #1376]	@ 0x560
	gpioLed.Mode = GPIO_MODE_OUTPUT_PP;
 80010a0:	2301      	movs	r3, #1
 80010a2:	f8c7 3564 	str.w	r3, [r7, #1380]	@ 0x564
	gpioLed.Pull = GPIO_NOPULL;
 80010a6:	2300      	movs	r3, #0
 80010a8:	f8c7 3568 	str.w	r3, [r7, #1384]	@ 0x568
	gpioLed.Speed = GPIO_SPEED_FREQ_LOW;
 80010ac:	2300      	movs	r3, #0
 80010ae:	f8c7 356c 	str.w	r3, [r7, #1388]	@ 0x56c
	HAL_GPIO_Init(GPIOD, &gpioLed);
 80010b2:	f507 63ac 	add.w	r3, r7, #1376	@ 0x560
 80010b6:	4619      	mov	r1, r3
 80010b8:	4850      	ldr	r0, [pc, #320]	@ (80011fc <sixthMessageSender+0x1fc>)
 80010ba:	f001 f889 	bl	80021d0 <HAL_GPIO_Init>

	GPIO_InitTypeDef gpioBtn = {0};
 80010be:	f207 534c 	addw	r3, r7, #1356	@ 0x54c
 80010c2:	2200      	movs	r2, #0
 80010c4:	601a      	str	r2, [r3, #0]
 80010c6:	605a      	str	r2, [r3, #4]
 80010c8:	609a      	str	r2, [r3, #8]
 80010ca:	60da      	str	r2, [r3, #12]
 80010cc:	611a      	str	r2, [r3, #16]
	gpioBtn.Pin = GPIO_PIN_0;
 80010ce:	2301      	movs	r3, #1
 80010d0:	f8c7 354c 	str.w	r3, [r7, #1356]	@ 0x54c
	gpioBtn.Mode = GPIO_MODE_INPUT;
 80010d4:	2300      	movs	r3, #0
 80010d6:	f8c7 3550 	str.w	r3, [r7, #1360]	@ 0x550
	gpioBtn.Pull = GPIO_NOPULL;
 80010da:	2300      	movs	r3, #0
 80010dc:	f8c7 3554 	str.w	r3, [r7, #1364]	@ 0x554
	HAL_GPIO_Init(GPIOA, &gpioBtn);
 80010e0:	f207 534c 	addw	r3, r7, #1356	@ 0x54c
 80010e4:	4619      	mov	r1, r3
 80010e6:	4846      	ldr	r0, [pc, #280]	@ (8001200 <sixthMessageSender+0x200>)
 80010e8:	f001 f872 	bl	80021d0 <HAL_GPIO_Init>

	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
 80010ec:	2201      	movs	r2, #1
 80010ee:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 80010f2:	4842      	ldr	r0, [pc, #264]	@ (80011fc <sixthMessageSender+0x1fc>)
 80010f4:	f001 fa20 	bl	8002538 <HAL_GPIO_WritePin>

	while (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET) {
 80010f8:	bf00      	nop
 80010fa:	2101      	movs	r1, #1
 80010fc:	4840      	ldr	r0, [pc, #256]	@ (8001200 <sixthMessageSender+0x200>)
 80010fe:	f001 fa03 	bl	8002508 <HAL_GPIO_ReadPin>
 8001102:	4603      	mov	r3, r0
 8001104:	2b00      	cmp	r3, #0
 8001106:	d0f8      	beq.n	80010fa <sixthMessageSender+0xfa>
	    // cakame kym sa stlaci tlacidlo
	}

	const char *predefinedHash = "3d9cf246585e2e116a9a4407ebd7d8dffea0dfa934a515dbe5cd6657aac7c222";
 8001108:	4b3e      	ldr	r3, [pc, #248]	@ (8001204 <sixthMessageSender+0x204>)
 800110a:	f8c7 3578 	str.w	r3, [r7, #1400]	@ 0x578
	memcpy(sixthMessage.key, predefinedHash, 64);
 800110e:	4b3a      	ldr	r3, [pc, #232]	@ (80011f8 <sixthMessageSender+0x1f8>)
 8001110:	f8d7 2578 	ldr.w	r2, [r7, #1400]	@ 0x578
 8001114:	4614      	mov	r4, r2
 8001116:	f103 0618 	add.w	r6, r3, #24
 800111a:	f104 0c40 	add.w	ip, r4, #64	@ 0x40
 800111e:	4635      	mov	r5, r6
 8001120:	4623      	mov	r3, r4
 8001122:	6818      	ldr	r0, [r3, #0]
 8001124:	6859      	ldr	r1, [r3, #4]
 8001126:	689a      	ldr	r2, [r3, #8]
 8001128:	68db      	ldr	r3, [r3, #12]
 800112a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800112c:	3410      	adds	r4, #16
 800112e:	3610      	adds	r6, #16
 8001130:	4564      	cmp	r4, ip
 8001132:	d1f4      	bne.n	800111e <sixthMessageSender+0x11e>

	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);
 8001134:	2200      	movs	r2, #0
 8001136:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 800113a:	4830      	ldr	r0, [pc, #192]	@ (80011fc <sixthMessageSender+0x1fc>)
 800113c:	f001 f9fc 	bl	8002538 <HAL_GPIO_WritePin>
	// nasledne zasifrujme celu spravu cez sessionKey
	unsigned char paddedPlaintext[512] = {0};
 8001140:	f507 63b0 	add.w	r3, r7, #1408	@ 0x580
 8001144:	f5a3 730d 	sub.w	r3, r3, #564	@ 0x234
 8001148:	4618      	mov	r0, r3
 800114a:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800114e:	461a      	mov	r2, r3
 8001150:	2100      	movs	r1, #0
 8001152:	f027 fd67 	bl	8028c24 <memset>
	memcpy(paddedPlaintext, &sixthMessage, sizeof(sixthMessage));
 8001156:	f507 63b0 	add.w	r3, r7, #1408	@ 0x580
 800115a:	f5a3 730d 	sub.w	r3, r3, #564	@ 0x234
 800115e:	4a26      	ldr	r2, [pc, #152]	@ (80011f8 <sixthMessageSender+0x1f8>)
 8001160:	4618      	mov	r0, r3
 8001162:	4611      	mov	r1, r2
 8001164:	2358      	movs	r3, #88	@ 0x58
 8001166:	461a      	mov	r2, r3
 8001168:	f027 fe0d 	bl	8028d86 <memcpy>
	Aes aes;
	int aesRet = wc_AesSetKey(&aes, thirdMessage.session_key, 16, thirdMessage.session_IV, AES_ENCRYPTION);
 800116c:	f507 7000 	add.w	r0, r7, #512	@ 0x200
 8001170:	2300      	movs	r3, #0
 8001172:	9300      	str	r3, [sp, #0]
 8001174:	4b24      	ldr	r3, [pc, #144]	@ (8001208 <sixthMessageSender+0x208>)
 8001176:	2210      	movs	r2, #16
 8001178:	4924      	ldr	r1, [pc, #144]	@ (800120c <sixthMessageSender+0x20c>)
 800117a:	f011 fa2b 	bl	80125d4 <wc_AesSetKey>
 800117e:	f8c7 0574 	str.w	r0, [r7, #1396]	@ 0x574
	if (aesRet != 0) {
 8001182:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8001186:	2b00      	cmp	r3, #0
 8001188:	d005      	beq.n	8001196 <sixthMessageSender+0x196>
		printf("AES key setup failed: %d\n", aesRet);
 800118a:	f8d7 1574 	ldr.w	r1, [r7, #1396]	@ 0x574
 800118e:	4820      	ldr	r0, [pc, #128]	@ (8001210 <sixthMessageSender+0x210>)
 8001190:	f027 fba0 	bl	80288d4 <iprintf>
		return;
 8001194:	e02a      	b.n	80011ec <sixthMessageSender+0x1ec>
	}
	uint8_t encryptedPayload[512];
	aesRet = wc_AesCbcEncrypt(&aes, encryptedPayload, paddedPlaintext, 512);
 8001196:	f507 7253 	add.w	r2, r7, #844	@ 0x34c
 800119a:	4639      	mov	r1, r7
 800119c:	f507 7000 	add.w	r0, r7, #512	@ 0x200
 80011a0:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80011a4:	f011 fa5a 	bl	801265c <wc_AesCbcEncrypt>
 80011a8:	f8c7 0574 	str.w	r0, [r7, #1396]	@ 0x574
	if (aesRet != 0) {
 80011ac:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 80011b0:	2b00      	cmp	r3, #0
 80011b2:	d005      	beq.n	80011c0 <sixthMessageSender+0x1c0>
		printf("AES encryption failed: %d\n", aesRet);
 80011b4:	f8d7 1574 	ldr.w	r1, [r7, #1396]	@ 0x574
 80011b8:	4816      	ldr	r0, [pc, #88]	@ (8001214 <sixthMessageSender+0x214>)
 80011ba:	f027 fb8b 	bl	80288d4 <iprintf>
		return;
 80011be:	e015      	b.n	80011ec <sixthMessageSender+0x1ec>
	}
	// a potom vlozme ju do sendBuffer na odoslanie
	memcpy(sendBuffer, encryptedPayload, 512);
 80011c0:	4a15      	ldr	r2, [pc, #84]	@ (8001218 <sixthMessageSender+0x218>)
 80011c2:	f507 63b0 	add.w	r3, r7, #1408	@ 0x580
 80011c6:	f5a3 63b0 	sub.w	r3, r3, #1408	@ 0x580
 80011ca:	4610      	mov	r0, r2
 80011cc:	4619      	mov	r1, r3
 80011ce:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80011d2:	461a      	mov	r2, r3
 80011d4:	f027 fdd7 	bl	8028d86 <memcpy>
	sendCounter = 512;
 80011d8:	4b10      	ldr	r3, [pc, #64]	@ (800121c <sixthMessageSender+0x21c>)
 80011da:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80011de:	801a      	strh	r2, [r3, #0]
	wc_AesFree(&aes);
 80011e0:	f507 7300 	add.w	r3, r7, #512	@ 0x200
 80011e4:	4618      	mov	r0, r3
 80011e6:	f011 fafb 	bl	80127e0 <wc_AesFree>
	return;
 80011ea:	bf00      	nop
}
 80011ec:	f207 5784 	addw	r7, r7, #1412	@ 0x584
 80011f0:	46bd      	mov	sp, r7
 80011f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80011f4:	200006c4 	.word	0x200006c4
 80011f8:	200006ec 	.word	0x200006ec
 80011fc:	40020c00 	.word	0x40020c00
 8001200:	40020000 	.word	0x40020000
 8001204:	08029a2c 	.word	0x08029a2c
 8001208:	20000678 	.word	0x20000678
 800120c:	20000668 	.word	0x20000668
 8001210:	080299d8 	.word	0x080299d8
 8001214:	08029a10 	.word	0x08029a10
 8001218:	2000121c 	.word	0x2000121c
 800121c:	20001be0 	.word	0x20001be0

08001220 <transmitBuffer>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

void transmitBuffer(uint8_t *data, uint16_t length) {
 8001220:	b580      	push	{r7, lr}
 8001222:	b084      	sub	sp, #16
 8001224:	af00      	add	r7, sp, #0
 8001226:	6078      	str	r0, [r7, #4]
 8001228:	460b      	mov	r3, r1
 800122a:	807b      	strh	r3, [r7, #2]
	// cely sendBuffer sa rozkuskuje na 64 bytove pakety ktore CDC_Transmit_FS vie preniest seriovo
	// Middlewares/ST/STM32_USB_Device_Library/Core/Inc/usbd_def.h
	// riadok 156 - #define USB_FS_MAX_PACKET_SIZE 64U - paket ma max velkost 64 bytov na transmit
    uint16_t sent = 0;
 800122c:	2300      	movs	r3, #0
 800122e:	81fb      	strh	r3, [r7, #14]
    while (sent < length) {
 8001230:	e016      	b.n	8001260 <transmitBuffer+0x40>
    	uint16_t chunk = (length - sent > 64) ? 64 : (length - sent);
 8001232:	887a      	ldrh	r2, [r7, #2]
 8001234:	89fb      	ldrh	r3, [r7, #14]
 8001236:	1ad3      	subs	r3, r2, r3
 8001238:	2b40      	cmp	r3, #64	@ 0x40
 800123a:	bfa8      	it	ge
 800123c:	2340      	movge	r3, #64	@ 0x40
 800123e:	81bb      	strh	r3, [r7, #12]
    	while (CDC_Transmit_FS(data + sent, chunk) == USBD_BUSY) {
 8001240:	bf00      	nop
 8001242:	89fb      	ldrh	r3, [r7, #14]
 8001244:	687a      	ldr	r2, [r7, #4]
 8001246:	4413      	add	r3, r2
 8001248:	89ba      	ldrh	r2, [r7, #12]
 800124a:	4611      	mov	r1, r2
 800124c:	4618      	mov	r0, r3
 800124e:	f026 fd29 	bl	8027ca4 <CDC_Transmit_FS>
 8001252:	4603      	mov	r3, r0
 8001254:	2b01      	cmp	r3, #1
 8001256:	d0f4      	beq.n	8001242 <transmitBuffer+0x22>
    		// cakame kym sa skonci prenos paketu
    	}
    	sent += chunk;
 8001258:	89fa      	ldrh	r2, [r7, #14]
 800125a:	89bb      	ldrh	r3, [r7, #12]
 800125c:	4413      	add	r3, r2
 800125e:	81fb      	strh	r3, [r7, #14]
    while (sent < length) {
 8001260:	89fa      	ldrh	r2, [r7, #14]
 8001262:	887b      	ldrh	r3, [r7, #2]
 8001264:	429a      	cmp	r2, r3
 8001266:	d3e4      	bcc.n	8001232 <transmitBuffer+0x12>
    }
}
 8001268:	bf00      	nop
 800126a:	bf00      	nop
 800126c:	3710      	adds	r7, #16
 800126e:	46bd      	mov	sp, r7
 8001270:	bd80      	pop	{r7, pc}
	...

08001274 <USBReceiveHandler>:

void USBReceiveHandler() {
 8001274:	b580      	push	{r7, lr}
 8001276:	b08c      	sub	sp, #48	@ 0x30
 8001278:	af02      	add	r7, sp, #8
	if (messageCounter == 1) {
 800127a:	4b5b      	ldr	r3, [pc, #364]	@ (80013e8 <USBReceiveHandler+0x174>)
 800127c:	781b      	ldrb	r3, [r3, #0]
 800127e:	2b01      	cmp	r3, #1
 8001280:	d112      	bne.n	80012a8 <USBReceiveHandler+0x34>
		uint8_t* receivedChars = malloc(4);
 8001282:	2004      	movs	r0, #4
 8001284:	f027 f978 	bl	8028578 <malloc>
 8001288:	4603      	mov	r3, r0
 800128a:	607b      	str	r3, [r7, #4]
		memcpy(receivedChars, &receiveBuffer[0], 4);
 800128c:	4b57      	ldr	r3, [pc, #348]	@ (80013ec <USBReceiveHandler+0x178>)
 800128e:	681a      	ldr	r2, [r3, #0]
 8001290:	687b      	ldr	r3, [r7, #4]
 8001292:	601a      	str	r2, [r3, #0]
		firstMessageHandler(receivedChars);
 8001294:	6878      	ldr	r0, [r7, #4]
 8001296:	f7ff f999 	bl	80005cc <firstMessageHandler>
		free(receivedChars);
 800129a:	6878      	ldr	r0, [r7, #4]
 800129c:	f027 f974 	bl	8028588 <free>
		messageCounter = 3;
 80012a0:	4b51      	ldr	r3, [pc, #324]	@ (80013e8 <USBReceiveHandler+0x174>)
 80012a2:	2203      	movs	r2, #3
 80012a4:	701a      	strb	r2, [r3, #0]
 80012a6:	e083      	b.n	80013b0 <USBReceiveHandler+0x13c>
	} else if (messageCounter == 3) {
 80012a8:	4b4f      	ldr	r3, [pc, #316]	@ (80013e8 <USBReceiveHandler+0x174>)
 80012aa:	781b      	ldrb	r3, [r3, #0]
 80012ac:	2b03      	cmp	r3, #3
 80012ae:	d14c      	bne.n	800134a <USBReceiveHandler+0xd6>
		uint8_t* encryptedKey = malloc(256);
 80012b0:	f44f 7080 	mov.w	r0, #256	@ 0x100
 80012b4:	f027 f960 	bl	8028578 <malloc>
 80012b8:	4603      	mov	r3, r0
 80012ba:	61bb      	str	r3, [r7, #24]
		uint8_t* encryptedIV = malloc(256);
 80012bc:	f44f 7080 	mov.w	r0, #256	@ 0x100
 80012c0:	f027 f95a 	bl	8028578 <malloc>
 80012c4:	4603      	mov	r3, r0
 80012c6:	617b      	str	r3, [r7, #20]
		uint8_t* payload = malloc(512);
 80012c8:	f44f 7000 	mov.w	r0, #512	@ 0x200
 80012cc:	f027 f954 	bl	8028578 <malloc>
 80012d0:	4603      	mov	r3, r0
 80012d2:	613b      	str	r3, [r7, #16]
		uint16_t deviceCertLen = receiveCounter - 1024;
 80012d4:	4b46      	ldr	r3, [pc, #280]	@ (80013f0 <USBReceiveHandler+0x17c>)
 80012d6:	881b      	ldrh	r3, [r3, #0]
 80012d8:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
 80012dc:	81fb      	strh	r3, [r7, #14]
		uint8_t* deviceCertBuffer = malloc(deviceCertLen);
 80012de:	89fb      	ldrh	r3, [r7, #14]
 80012e0:	4618      	mov	r0, r3
 80012e2:	f027 f949 	bl	8028578 <malloc>
 80012e6:	4603      	mov	r3, r0
 80012e8:	60bb      	str	r3, [r7, #8]
		memcpy(encryptedKey, &receiveBuffer[0], 256);
 80012ea:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80012ee:	493f      	ldr	r1, [pc, #252]	@ (80013ec <USBReceiveHandler+0x178>)
 80012f0:	69b8      	ldr	r0, [r7, #24]
 80012f2:	f027 fd48 	bl	8028d86 <memcpy>
		memcpy(encryptedIV, &receiveBuffer[256], 256);
 80012f6:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80012fa:	493e      	ldr	r1, [pc, #248]	@ (80013f4 <USBReceiveHandler+0x180>)
 80012fc:	6978      	ldr	r0, [r7, #20]
 80012fe:	f027 fd42 	bl	8028d86 <memcpy>
		memcpy(payload, &receiveBuffer[512], 512);
 8001302:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8001306:	493c      	ldr	r1, [pc, #240]	@ (80013f8 <USBReceiveHandler+0x184>)
 8001308:	6938      	ldr	r0, [r7, #16]
 800130a:	f027 fd3c 	bl	8028d86 <memcpy>
		memcpy(deviceCertBuffer, &receiveBuffer[1024], deviceCertLen);
 800130e:	89fb      	ldrh	r3, [r7, #14]
 8001310:	461a      	mov	r2, r3
 8001312:	493a      	ldr	r1, [pc, #232]	@ (80013fc <USBReceiveHandler+0x188>)
 8001314:	68b8      	ldr	r0, [r7, #8]
 8001316:	f027 fd36 	bl	8028d86 <memcpy>
		thirdMessageHandler(encryptedKey, encryptedIV, payload, deviceCertBuffer, deviceCertLen);
 800131a:	89fb      	ldrh	r3, [r7, #14]
 800131c:	9300      	str	r3, [sp, #0]
 800131e:	68bb      	ldr	r3, [r7, #8]
 8001320:	693a      	ldr	r2, [r7, #16]
 8001322:	6979      	ldr	r1, [r7, #20]
 8001324:	69b8      	ldr	r0, [r7, #24]
 8001326:	f7ff fa23 	bl	8000770 <thirdMessageHandler>
		free(encryptedKey);
 800132a:	69b8      	ldr	r0, [r7, #24]
 800132c:	f027 f92c 	bl	8028588 <free>
		free(encryptedIV);
 8001330:	6978      	ldr	r0, [r7, #20]
 8001332:	f027 f929 	bl	8028588 <free>
		free(payload);
 8001336:	6938      	ldr	r0, [r7, #16]
 8001338:	f027 f926 	bl	8028588 <free>
		free(deviceCertBuffer);
 800133c:	68b8      	ldr	r0, [r7, #8]
 800133e:	f027 f923 	bl	8028588 <free>
		messageCounter = 5;
 8001342:	4b29      	ldr	r3, [pc, #164]	@ (80013e8 <USBReceiveHandler+0x174>)
 8001344:	2205      	movs	r2, #5
 8001346:	701a      	strb	r2, [r3, #0]
 8001348:	e032      	b.n	80013b0 <USBReceiveHandler+0x13c>
	} else {
		uint8_t* payload = malloc(512);
 800134a:	f44f 7000 	mov.w	r0, #512	@ 0x200
 800134e:	f027 f913 	bl	8028578 <malloc>
 8001352:	4603      	mov	r3, r0
 8001354:	627b      	str	r3, [r7, #36]	@ 0x24
		uint8_t* sigHash = malloc(256);
 8001356:	f44f 7080 	mov.w	r0, #256	@ 0x100
 800135a:	f027 f90d 	bl	8028578 <malloc>
 800135e:	4603      	mov	r3, r0
 8001360:	623b      	str	r3, [r7, #32]
		uint8_t* hash = malloc(32);
 8001362:	2020      	movs	r0, #32
 8001364:	f027 f908 	bl	8028578 <malloc>
 8001368:	4603      	mov	r3, r0
 800136a:	61fb      	str	r3, [r7, #28]
		memcpy(payload, &receiveBuffer[0], 512);
 800136c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8001370:	491e      	ldr	r1, [pc, #120]	@ (80013ec <USBReceiveHandler+0x178>)
 8001372:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8001374:	f027 fd07 	bl	8028d86 <memcpy>
		memcpy(sigHash, &receiveBuffer[512], 256);
 8001378:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800137c:	491e      	ldr	r1, [pc, #120]	@ (80013f8 <USBReceiveHandler+0x184>)
 800137e:	6a38      	ldr	r0, [r7, #32]
 8001380:	f027 fd01 	bl	8028d86 <memcpy>
		memcpy(hash, &receiveBuffer[768], 32);
 8001384:	2220      	movs	r2, #32
 8001386:	491e      	ldr	r1, [pc, #120]	@ (8001400 <USBReceiveHandler+0x18c>)
 8001388:	69f8      	ldr	r0, [r7, #28]
 800138a:	f027 fcfc 	bl	8028d86 <memcpy>
		fifthMessageHandler(payload, sigHash, hash);
 800138e:	69fa      	ldr	r2, [r7, #28]
 8001390:	6a39      	ldr	r1, [r7, #32]
 8001392:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8001394:	f7ff fd1c 	bl	8000dd0 <fifthMessageHandler>
		free(payload);
 8001398:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800139a:	f027 f8f5 	bl	8028588 <free>
		free(sigHash);
 800139e:	6a38      	ldr	r0, [r7, #32]
 80013a0:	f027 f8f2 	bl	8028588 <free>
		free(hash);
 80013a4:	69f8      	ldr	r0, [r7, #28]
 80013a6:	f027 f8ef 	bl	8028588 <free>
		messageCounter = 1;
 80013aa:	4b0f      	ldr	r3, [pc, #60]	@ (80013e8 <USBReceiveHandler+0x174>)
 80013ac:	2201      	movs	r2, #1
 80013ae:	701a      	strb	r2, [r3, #0]
	}
	receiveCounter = 0;
 80013b0:	4b0f      	ldr	r3, [pc, #60]	@ (80013f0 <USBReceiveHandler+0x17c>)
 80013b2:	2200      	movs	r2, #0
 80013b4:	801a      	strh	r2, [r3, #0]
	memset(&receiveBuffer, 0, sizeof(receiveBuffer));
 80013b6:	f640 12c4 	movw	r2, #2500	@ 0x9c4
 80013ba:	2100      	movs	r1, #0
 80013bc:	480b      	ldr	r0, [pc, #44]	@ (80013ec <USBReceiveHandler+0x178>)
 80013be:	f027 fc31 	bl	8028c24 <memset>
	transmitBuffer(sendBuffer, sendCounter);
 80013c2:	4b10      	ldr	r3, [pc, #64]	@ (8001404 <USBReceiveHandler+0x190>)
 80013c4:	881b      	ldrh	r3, [r3, #0]
 80013c6:	4619      	mov	r1, r3
 80013c8:	480f      	ldr	r0, [pc, #60]	@ (8001408 <USBReceiveHandler+0x194>)
 80013ca:	f7ff ff29 	bl	8001220 <transmitBuffer>
	sendCounter = 0;
 80013ce:	4b0d      	ldr	r3, [pc, #52]	@ (8001404 <USBReceiveHandler+0x190>)
 80013d0:	2200      	movs	r2, #0
 80013d2:	801a      	strh	r2, [r3, #0]
	memset(&sendBuffer, 0, sizeof(sendBuffer));
 80013d4:	f640 12c4 	movw	r2, #2500	@ 0x9c4
 80013d8:	2100      	movs	r1, #0
 80013da:	480b      	ldr	r0, [pc, #44]	@ (8001408 <USBReceiveHandler+0x194>)
 80013dc:	f027 fc22 	bl	8028c24 <memset>
}
 80013e0:	bf00      	nop
 80013e2:	3728      	adds	r7, #40	@ 0x28
 80013e4:	46bd      	mov	sp, r7
 80013e6:	bd80      	pop	{r7, pc}
 80013e8:	20000014 	.word	0x20000014
 80013ec:	20000854 	.word	0x20000854
 80013f0:	20001218 	.word	0x20001218
 80013f4:	20000954 	.word	0x20000954
 80013f8:	20000a54 	.word	0x20000a54
 80013fc:	20000c54 	.word	0x20000c54
 8001400:	20000b54 	.word	0x20000b54
 8001404:	20001be0 	.word	0x20001be0
 8001408:	2000121c 	.word	0x2000121c

0800140c <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800140c:	b580      	push	{r7, lr}
 800140e:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8001410:	f000 fcf6 	bl	8001e00 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8001414:	f000 f81a 	bl	800144c <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8001418:	f000 f93e 	bl	8001698 <MX_GPIO_Init>
  MX_I2C1_Init();
 800141c:	f000 f894 	bl	8001548 <MX_I2C1_Init>
  MX_I2S3_Init();
 8001420:	f000 f8c0 	bl	80015a4 <MX_I2S3_Init>
  MX_SPI1_Init();
 8001424:	f000 f902 	bl	800162c <MX_SPI1_Init>
  MX_USB_DEVICE_Init();
 8001428:	f026 faf8 	bl	8027a1c <MX_USB_DEVICE_Init>
  MX_CRC_Init();
 800142c:	f000 f878 	bl	8001520 <MX_CRC_Init>
  MX_RNG_Init();
 8001430:	f000 f8e8 	bl	8001604 <MX_RNG_Init>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  if (dataReceivedFlag == 1) {
 8001434:	4b04      	ldr	r3, [pc, #16]	@ (8001448 <main+0x3c>)
 8001436:	781b      	ldrb	r3, [r3, #0]
 8001438:	2b01      	cmp	r3, #1
 800143a:	d1fb      	bne.n	8001434 <main+0x28>
		  USBReceiveHandler();
 800143c:	f7ff ff1a 	bl	8001274 <USBReceiveHandler>
		  dataReceivedFlag = 0;
 8001440:	4b01      	ldr	r3, [pc, #4]	@ (8001448 <main+0x3c>)
 8001442:	2200      	movs	r2, #0
 8001444:	701a      	strb	r2, [r3, #0]
	  if (dataReceivedFlag == 1) {
 8001446:	e7f5      	b.n	8001434 <main+0x28>
 8001448:	20000850 	.word	0x20000850

0800144c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800144c:	b580      	push	{r7, lr}
 800144e:	b094      	sub	sp, #80	@ 0x50
 8001450:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8001452:	f107 0320 	add.w	r3, r7, #32
 8001456:	2230      	movs	r2, #48	@ 0x30
 8001458:	2100      	movs	r1, #0
 800145a:	4618      	mov	r0, r3
 800145c:	f027 fbe2 	bl	8028c24 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8001460:	f107 030c 	add.w	r3, r7, #12
 8001464:	2200      	movs	r2, #0
 8001466:	601a      	str	r2, [r3, #0]
 8001468:	605a      	str	r2, [r3, #4]
 800146a:	609a      	str	r2, [r3, #8]
 800146c:	60da      	str	r2, [r3, #12]
 800146e:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 8001470:	2300      	movs	r3, #0
 8001472:	60bb      	str	r3, [r7, #8]
 8001474:	4b28      	ldr	r3, [pc, #160]	@ (8001518 <SystemClock_Config+0xcc>)
 8001476:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001478:	4a27      	ldr	r2, [pc, #156]	@ (8001518 <SystemClock_Config+0xcc>)
 800147a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800147e:	6413      	str	r3, [r2, #64]	@ 0x40
 8001480:	4b25      	ldr	r3, [pc, #148]	@ (8001518 <SystemClock_Config+0xcc>)
 8001482:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001484:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8001488:	60bb      	str	r3, [r7, #8]
 800148a:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800148c:	2300      	movs	r3, #0
 800148e:	607b      	str	r3, [r7, #4]
 8001490:	4b22      	ldr	r3, [pc, #136]	@ (800151c <SystemClock_Config+0xd0>)
 8001492:	681b      	ldr	r3, [r3, #0]
 8001494:	4a21      	ldr	r2, [pc, #132]	@ (800151c <SystemClock_Config+0xd0>)
 8001496:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800149a:	6013      	str	r3, [r2, #0]
 800149c:	4b1f      	ldr	r3, [pc, #124]	@ (800151c <SystemClock_Config+0xd0>)
 800149e:	681b      	ldr	r3, [r3, #0]
 80014a0:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80014a4:	607b      	str	r3, [r7, #4]
 80014a6:	687b      	ldr	r3, [r7, #4]

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80014a8:	2301      	movs	r3, #1
 80014aa:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80014ac:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 80014b0:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80014b2:	2302      	movs	r3, #2
 80014b4:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80014b6:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 80014ba:	63fb      	str	r3, [r7, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLM = 8;
 80014bc:	2308      	movs	r3, #8
 80014be:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLN = 336;
 80014c0:	f44f 73a8 	mov.w	r3, #336	@ 0x150
 80014c4:	647b      	str	r3, [r7, #68]	@ 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80014c6:	2302      	movs	r3, #2
 80014c8:	64bb      	str	r3, [r7, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLQ = 7;
 80014ca:	2307      	movs	r3, #7
 80014cc:	64fb      	str	r3, [r7, #76]	@ 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80014ce:	f107 0320 	add.w	r3, r7, #32
 80014d2:	4618      	mov	r0, r3
 80014d4:	f003 f880 	bl	80045d8 <HAL_RCC_OscConfig>
 80014d8:	4603      	mov	r3, r0
 80014da:	2b00      	cmp	r3, #0
 80014dc:	d001      	beq.n	80014e2 <SystemClock_Config+0x96>
  {
    Error_Handler();
 80014de:	f000 f9d9 	bl	8001894 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80014e2:	230f      	movs	r3, #15
 80014e4:	60fb      	str	r3, [r7, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80014e6:	2302      	movs	r3, #2
 80014e8:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80014ea:	2300      	movs	r3, #0
 80014ec:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80014ee:	f44f 53a0 	mov.w	r3, #5120	@ 0x1400
 80014f2:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80014f4:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 80014f8:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 80014fa:	f107 030c 	add.w	r3, r7, #12
 80014fe:	2105      	movs	r1, #5
 8001500:	4618      	mov	r0, r3
 8001502:	f003 fae1 	bl	8004ac8 <HAL_RCC_ClockConfig>
 8001506:	4603      	mov	r3, r0
 8001508:	2b00      	cmp	r3, #0
 800150a:	d001      	beq.n	8001510 <SystemClock_Config+0xc4>
  {
    Error_Handler();
 800150c:	f000 f9c2 	bl	8001894 <Error_Handler>
  }
}
 8001510:	bf00      	nop
 8001512:	3750      	adds	r7, #80	@ 0x50
 8001514:	46bd      	mov	sp, r7
 8001516:	bd80      	pop	{r7, pc}
 8001518:	40023800 	.word	0x40023800
 800151c:	40007000 	.word	0x40007000

08001520 <MX_CRC_Init>:
  * @brief CRC Initialization Function
  * @param None
  * @retval None
  */
static void MX_CRC_Init(void)
{
 8001520:	b580      	push	{r7, lr}
 8001522:	af00      	add	r7, sp, #0
  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
 8001524:	4b06      	ldr	r3, [pc, #24]	@ (8001540 <MX_CRC_Init+0x20>)
 8001526:	4a07      	ldr	r2, [pc, #28]	@ (8001544 <MX_CRC_Init+0x24>)
 8001528:	601a      	str	r2, [r3, #0]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 800152a:	4805      	ldr	r0, [pc, #20]	@ (8001540 <MX_CRC_Init+0x20>)
 800152c:	f000 fe33 	bl	8002196 <HAL_CRC_Init>
 8001530:	4603      	mov	r3, r0
 8001532:	2b00      	cmp	r3, #0
 8001534:	d001      	beq.n	800153a <MX_CRC_Init+0x1a>
  {
    Error_Handler();
 8001536:	f000 f9ad 	bl	8001894 <Error_Handler>
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}
 800153a:	bf00      	nop
 800153c:	bd80      	pop	{r7, pc}
 800153e:	bf00      	nop
 8001540:	20000744 	.word	0x20000744
 8001544:	40023000 	.word	0x40023000

08001548 <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
 8001548:	b580      	push	{r7, lr}
 800154a:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 800154c:	4b12      	ldr	r3, [pc, #72]	@ (8001598 <MX_I2C1_Init+0x50>)
 800154e:	4a13      	ldr	r2, [pc, #76]	@ (800159c <MX_I2C1_Init+0x54>)
 8001550:	601a      	str	r2, [r3, #0]
  hi2c1.Init.ClockSpeed = 100000;
 8001552:	4b11      	ldr	r3, [pc, #68]	@ (8001598 <MX_I2C1_Init+0x50>)
 8001554:	4a12      	ldr	r2, [pc, #72]	@ (80015a0 <MX_I2C1_Init+0x58>)
 8001556:	605a      	str	r2, [r3, #4]
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 8001558:	4b0f      	ldr	r3, [pc, #60]	@ (8001598 <MX_I2C1_Init+0x50>)
 800155a:	2200      	movs	r2, #0
 800155c:	609a      	str	r2, [r3, #8]
  hi2c1.Init.OwnAddress1 = 0;
 800155e:	4b0e      	ldr	r3, [pc, #56]	@ (8001598 <MX_I2C1_Init+0x50>)
 8001560:	2200      	movs	r2, #0
 8001562:	60da      	str	r2, [r3, #12]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8001564:	4b0c      	ldr	r3, [pc, #48]	@ (8001598 <MX_I2C1_Init+0x50>)
 8001566:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 800156a:	611a      	str	r2, [r3, #16]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800156c:	4b0a      	ldr	r3, [pc, #40]	@ (8001598 <MX_I2C1_Init+0x50>)
 800156e:	2200      	movs	r2, #0
 8001570:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2 = 0;
 8001572:	4b09      	ldr	r3, [pc, #36]	@ (8001598 <MX_I2C1_Init+0x50>)
 8001574:	2200      	movs	r2, #0
 8001576:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8001578:	4b07      	ldr	r3, [pc, #28]	@ (8001598 <MX_I2C1_Init+0x50>)
 800157a:	2200      	movs	r2, #0
 800157c:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800157e:	4b06      	ldr	r3, [pc, #24]	@ (8001598 <MX_I2C1_Init+0x50>)
 8001580:	2200      	movs	r2, #0
 8001582:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8001584:	4804      	ldr	r0, [pc, #16]	@ (8001598 <MX_I2C1_Init+0x50>)
 8001586:	f000 fff1 	bl	800256c <HAL_I2C_Init>
 800158a:	4603      	mov	r3, r0
 800158c:	2b00      	cmp	r3, #0
 800158e:	d001      	beq.n	8001594 <MX_I2C1_Init+0x4c>
  {
    Error_Handler();
 8001590:	f000 f980 	bl	8001894 <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 8001594:	bf00      	nop
 8001596:	bd80      	pop	{r7, pc}
 8001598:	2000074c 	.word	0x2000074c
 800159c:	40005400 	.word	0x40005400
 80015a0:	000186a0 	.word	0x000186a0

080015a4 <MX_I2S3_Init>:
  * @brief I2S3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2S3_Init(void)
{
 80015a4:	b580      	push	{r7, lr}
 80015a6:	af00      	add	r7, sp, #0
  /* USER CODE END I2S3_Init 0 */

  /* USER CODE BEGIN I2S3_Init 1 */

  /* USER CODE END I2S3_Init 1 */
  hi2s3.Instance = SPI3;
 80015a8:	4b13      	ldr	r3, [pc, #76]	@ (80015f8 <MX_I2S3_Init+0x54>)
 80015aa:	4a14      	ldr	r2, [pc, #80]	@ (80015fc <MX_I2S3_Init+0x58>)
 80015ac:	601a      	str	r2, [r3, #0]
  hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
 80015ae:	4b12      	ldr	r3, [pc, #72]	@ (80015f8 <MX_I2S3_Init+0x54>)
 80015b0:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80015b4:	605a      	str	r2, [r3, #4]
  hi2s3.Init.Standard = I2S_STANDARD_PHILIPS;
 80015b6:	4b10      	ldr	r3, [pc, #64]	@ (80015f8 <MX_I2S3_Init+0x54>)
 80015b8:	2200      	movs	r2, #0
 80015ba:	609a      	str	r2, [r3, #8]
  hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
 80015bc:	4b0e      	ldr	r3, [pc, #56]	@ (80015f8 <MX_I2S3_Init+0x54>)
 80015be:	2200      	movs	r2, #0
 80015c0:	60da      	str	r2, [r3, #12]
  hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
 80015c2:	4b0d      	ldr	r3, [pc, #52]	@ (80015f8 <MX_I2S3_Init+0x54>)
 80015c4:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80015c8:	611a      	str	r2, [r3, #16]
  hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_96K;
 80015ca:	4b0b      	ldr	r3, [pc, #44]	@ (80015f8 <MX_I2S3_Init+0x54>)
 80015cc:	4a0c      	ldr	r2, [pc, #48]	@ (8001600 <MX_I2S3_Init+0x5c>)
 80015ce:	615a      	str	r2, [r3, #20]
  hi2s3.Init.CPOL = I2S_CPOL_LOW;
 80015d0:	4b09      	ldr	r3, [pc, #36]	@ (80015f8 <MX_I2S3_Init+0x54>)
 80015d2:	2200      	movs	r2, #0
 80015d4:	619a      	str	r2, [r3, #24]
  hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
 80015d6:	4b08      	ldr	r3, [pc, #32]	@ (80015f8 <MX_I2S3_Init+0x54>)
 80015d8:	2200      	movs	r2, #0
 80015da:	61da      	str	r2, [r3, #28]
  hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
 80015dc:	4b06      	ldr	r3, [pc, #24]	@ (80015f8 <MX_I2S3_Init+0x54>)
 80015de:	2200      	movs	r2, #0
 80015e0:	621a      	str	r2, [r3, #32]
  if (HAL_I2S_Init(&hi2s3) != HAL_OK)
 80015e2:	4805      	ldr	r0, [pc, #20]	@ (80015f8 <MX_I2S3_Init+0x54>)
 80015e4:	f001 f906 	bl	80027f4 <HAL_I2S_Init>
 80015e8:	4603      	mov	r3, r0
 80015ea:	2b00      	cmp	r3, #0
 80015ec:	d001      	beq.n	80015f2 <MX_I2S3_Init+0x4e>
  {
    Error_Handler();
 80015ee:	f000 f951 	bl	8001894 <Error_Handler>
  }
  /* USER CODE BEGIN I2S3_Init 2 */

  /* USER CODE END I2S3_Init 2 */

}
 80015f2:	bf00      	nop
 80015f4:	bd80      	pop	{r7, pc}
 80015f6:	bf00      	nop
 80015f8:	200007a0 	.word	0x200007a0
 80015fc:	40003c00 	.word	0x40003c00
 8001600:	00017700 	.word	0x00017700

08001604 <MX_RNG_Init>:
  * @brief RNG Initialization Function
  * @param None
  * @retval None
  */
static void MX_RNG_Init(void)
{
 8001604:	b580      	push	{r7, lr}
 8001606:	af00      	add	r7, sp, #0
  /* USER CODE END RNG_Init 0 */

  /* USER CODE BEGIN RNG_Init 1 */

  /* USER CODE END RNG_Init 1 */
  hrng.Instance = RNG;
 8001608:	4b06      	ldr	r3, [pc, #24]	@ (8001624 <MX_RNG_Init+0x20>)
 800160a:	4a07      	ldr	r2, [pc, #28]	@ (8001628 <MX_RNG_Init+0x24>)
 800160c:	601a      	str	r2, [r3, #0]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 800160e:	4805      	ldr	r0, [pc, #20]	@ (8001624 <MX_RNG_Init+0x20>)
 8001610:	f003 fda8 	bl	8005164 <HAL_RNG_Init>
 8001614:	4603      	mov	r3, r0
 8001616:	2b00      	cmp	r3, #0
 8001618:	d001      	beq.n	800161e <MX_RNG_Init+0x1a>
  {
    Error_Handler();
 800161a:	f000 f93b 	bl	8001894 <Error_Handler>
  }
  /* USER CODE BEGIN RNG_Init 2 */

  /* USER CODE END RNG_Init 2 */

}
 800161e:	bf00      	nop
 8001620:	bd80      	pop	{r7, pc}
 8001622:	bf00      	nop
 8001624:	200007e8 	.word	0x200007e8
 8001628:	50060800 	.word	0x50060800

0800162c <MX_SPI1_Init>:
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{
 800162c:	b580      	push	{r7, lr}
 800162e:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 8001630:	4b17      	ldr	r3, [pc, #92]	@ (8001690 <MX_SPI1_Init+0x64>)
 8001632:	4a18      	ldr	r2, [pc, #96]	@ (8001694 <MX_SPI1_Init+0x68>)
 8001634:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8001636:	4b16      	ldr	r3, [pc, #88]	@ (8001690 <MX_SPI1_Init+0x64>)
 8001638:	f44f 7282 	mov.w	r2, #260	@ 0x104
 800163c:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 800163e:	4b14      	ldr	r3, [pc, #80]	@ (8001690 <MX_SPI1_Init+0x64>)
 8001640:	2200      	movs	r2, #0
 8001642:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8001644:	4b12      	ldr	r3, [pc, #72]	@ (8001690 <MX_SPI1_Init+0x64>)
 8001646:	2200      	movs	r2, #0
 8001648:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 800164a:	4b11      	ldr	r3, [pc, #68]	@ (8001690 <MX_SPI1_Init+0x64>)
 800164c:	2200      	movs	r2, #0
 800164e:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8001650:	4b0f      	ldr	r3, [pc, #60]	@ (8001690 <MX_SPI1_Init+0x64>)
 8001652:	2200      	movs	r2, #0
 8001654:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8001656:	4b0e      	ldr	r3, [pc, #56]	@ (8001690 <MX_SPI1_Init+0x64>)
 8001658:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800165c:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 800165e:	4b0c      	ldr	r3, [pc, #48]	@ (8001690 <MX_SPI1_Init+0x64>)
 8001660:	2200      	movs	r2, #0
 8001662:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8001664:	4b0a      	ldr	r3, [pc, #40]	@ (8001690 <MX_SPI1_Init+0x64>)
 8001666:	2200      	movs	r2, #0
 8001668:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 800166a:	4b09      	ldr	r3, [pc, #36]	@ (8001690 <MX_SPI1_Init+0x64>)
 800166c:	2200      	movs	r2, #0
 800166e:	625a      	str	r2, [r3, #36]	@ 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001670:	4b07      	ldr	r3, [pc, #28]	@ (8001690 <MX_SPI1_Init+0x64>)
 8001672:	2200      	movs	r2, #0
 8001674:	629a      	str	r2, [r3, #40]	@ 0x28
  hspi1.Init.CRCPolynomial = 10;
 8001676:	4b06      	ldr	r3, [pc, #24]	@ (8001690 <MX_SPI1_Init+0x64>)
 8001678:	220a      	movs	r2, #10
 800167a:	62da      	str	r2, [r3, #44]	@ 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 800167c:	4804      	ldr	r0, [pc, #16]	@ (8001690 <MX_SPI1_Init+0x64>)
 800167e:	f003 fe1b 	bl	80052b8 <HAL_SPI_Init>
 8001682:	4603      	mov	r3, r0
 8001684:	2b00      	cmp	r3, #0
 8001686:	d001      	beq.n	800168c <MX_SPI1_Init+0x60>
  {
    Error_Handler();
 8001688:	f000 f904 	bl	8001894 <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 800168c:	bf00      	nop
 800168e:	bd80      	pop	{r7, pc}
 8001690:	200007f8 	.word	0x200007f8
 8001694:	40013000 	.word	0x40013000

08001698 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8001698:	b580      	push	{r7, lr}
 800169a:	b08c      	sub	sp, #48	@ 0x30
 800169c:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800169e:	f107 031c 	add.w	r3, r7, #28
 80016a2:	2200      	movs	r2, #0
 80016a4:	601a      	str	r2, [r3, #0]
 80016a6:	605a      	str	r2, [r3, #4]
 80016a8:	609a      	str	r2, [r3, #8]
 80016aa:	60da      	str	r2, [r3, #12]
 80016ac:	611a      	str	r2, [r3, #16]
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80016ae:	2300      	movs	r3, #0
 80016b0:	61bb      	str	r3, [r7, #24]
 80016b2:	4b72      	ldr	r3, [pc, #456]	@ (800187c <MX_GPIO_Init+0x1e4>)
 80016b4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016b6:	4a71      	ldr	r2, [pc, #452]	@ (800187c <MX_GPIO_Init+0x1e4>)
 80016b8:	f043 0310 	orr.w	r3, r3, #16
 80016bc:	6313      	str	r3, [r2, #48]	@ 0x30
 80016be:	4b6f      	ldr	r3, [pc, #444]	@ (800187c <MX_GPIO_Init+0x1e4>)
 80016c0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016c2:	f003 0310 	and.w	r3, r3, #16
 80016c6:	61bb      	str	r3, [r7, #24]
 80016c8:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80016ca:	2300      	movs	r3, #0
 80016cc:	617b      	str	r3, [r7, #20]
 80016ce:	4b6b      	ldr	r3, [pc, #428]	@ (800187c <MX_GPIO_Init+0x1e4>)
 80016d0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016d2:	4a6a      	ldr	r2, [pc, #424]	@ (800187c <MX_GPIO_Init+0x1e4>)
 80016d4:	f043 0304 	orr.w	r3, r3, #4
 80016d8:	6313      	str	r3, [r2, #48]	@ 0x30
 80016da:	4b68      	ldr	r3, [pc, #416]	@ (800187c <MX_GPIO_Init+0x1e4>)
 80016dc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016de:	f003 0304 	and.w	r3, r3, #4
 80016e2:	617b      	str	r3, [r7, #20]
 80016e4:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80016e6:	2300      	movs	r3, #0
 80016e8:	613b      	str	r3, [r7, #16]
 80016ea:	4b64      	ldr	r3, [pc, #400]	@ (800187c <MX_GPIO_Init+0x1e4>)
 80016ec:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016ee:	4a63      	ldr	r2, [pc, #396]	@ (800187c <MX_GPIO_Init+0x1e4>)
 80016f0:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80016f4:	6313      	str	r3, [r2, #48]	@ 0x30
 80016f6:	4b61      	ldr	r3, [pc, #388]	@ (800187c <MX_GPIO_Init+0x1e4>)
 80016f8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016fa:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80016fe:	613b      	str	r3, [r7, #16]
 8001700:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001702:	2300      	movs	r3, #0
 8001704:	60fb      	str	r3, [r7, #12]
 8001706:	4b5d      	ldr	r3, [pc, #372]	@ (800187c <MX_GPIO_Init+0x1e4>)
 8001708:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800170a:	4a5c      	ldr	r2, [pc, #368]	@ (800187c <MX_GPIO_Init+0x1e4>)
 800170c:	f043 0301 	orr.w	r3, r3, #1
 8001710:	6313      	str	r3, [r2, #48]	@ 0x30
 8001712:	4b5a      	ldr	r3, [pc, #360]	@ (800187c <MX_GPIO_Init+0x1e4>)
 8001714:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001716:	f003 0301 	and.w	r3, r3, #1
 800171a:	60fb      	str	r3, [r7, #12]
 800171c:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800171e:	2300      	movs	r3, #0
 8001720:	60bb      	str	r3, [r7, #8]
 8001722:	4b56      	ldr	r3, [pc, #344]	@ (800187c <MX_GPIO_Init+0x1e4>)
 8001724:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001726:	4a55      	ldr	r2, [pc, #340]	@ (800187c <MX_GPIO_Init+0x1e4>)
 8001728:	f043 0302 	orr.w	r3, r3, #2
 800172c:	6313      	str	r3, [r2, #48]	@ 0x30
 800172e:	4b53      	ldr	r3, [pc, #332]	@ (800187c <MX_GPIO_Init+0x1e4>)
 8001730:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001732:	f003 0302 	and.w	r3, r3, #2
 8001736:	60bb      	str	r3, [r7, #8]
 8001738:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800173a:	2300      	movs	r3, #0
 800173c:	607b      	str	r3, [r7, #4]
 800173e:	4b4f      	ldr	r3, [pc, #316]	@ (800187c <MX_GPIO_Init+0x1e4>)
 8001740:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001742:	4a4e      	ldr	r2, [pc, #312]	@ (800187c <MX_GPIO_Init+0x1e4>)
 8001744:	f043 0308 	orr.w	r3, r3, #8
 8001748:	6313      	str	r3, [r2, #48]	@ 0x30
 800174a:	4b4c      	ldr	r3, [pc, #304]	@ (800187c <MX_GPIO_Init+0x1e4>)
 800174c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800174e:	f003 0308 	and.w	r3, r3, #8
 8001752:	607b      	str	r3, [r7, #4]
 8001754:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(CS_I2C_SPI_GPIO_Port, CS_I2C_SPI_Pin, GPIO_PIN_RESET);
 8001756:	2200      	movs	r2, #0
 8001758:	2108      	movs	r1, #8
 800175a:	4849      	ldr	r0, [pc, #292]	@ (8001880 <MX_GPIO_Init+0x1e8>)
 800175c:	f000 feec 	bl	8002538 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 8001760:	2201      	movs	r2, #1
 8001762:	2101      	movs	r1, #1
 8001764:	4847      	ldr	r0, [pc, #284]	@ (8001884 <MX_GPIO_Init+0x1ec>)
 8001766:	f000 fee7 	bl	8002538 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
 800176a:	2200      	movs	r2, #0
 800176c:	f24f 0110 	movw	r1, #61456	@ 0xf010
 8001770:	4845      	ldr	r0, [pc, #276]	@ (8001888 <MX_GPIO_Init+0x1f0>)
 8001772:	f000 fee1 	bl	8002538 <HAL_GPIO_WritePin>
                          |Audio_RST_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : CS_I2C_SPI_Pin */
  GPIO_InitStruct.Pin = CS_I2C_SPI_Pin;
 8001776:	2308      	movs	r3, #8
 8001778:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800177a:	2301      	movs	r3, #1
 800177c:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800177e:	2300      	movs	r3, #0
 8001780:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001782:	2300      	movs	r3, #0
 8001784:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(CS_I2C_SPI_GPIO_Port, &GPIO_InitStruct);
 8001786:	f107 031c 	add.w	r3, r7, #28
 800178a:	4619      	mov	r1, r3
 800178c:	483c      	ldr	r0, [pc, #240]	@ (8001880 <MX_GPIO_Init+0x1e8>)
 800178e:	f000 fd1f 	bl	80021d0 <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_PowerSwitchOn_Pin */
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
 8001792:	2301      	movs	r3, #1
 8001794:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001796:	2301      	movs	r3, #1
 8001798:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800179a:	2300      	movs	r3, #0
 800179c:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800179e:	2300      	movs	r3, #0
 80017a0:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 80017a2:	f107 031c 	add.w	r3, r7, #28
 80017a6:	4619      	mov	r1, r3
 80017a8:	4836      	ldr	r0, [pc, #216]	@ (8001884 <MX_GPIO_Init+0x1ec>)
 80017aa:	f000 fd11 	bl	80021d0 <HAL_GPIO_Init>

  /*Configure GPIO pin : PDM_OUT_Pin */
  GPIO_InitStruct.Pin = PDM_OUT_Pin;
 80017ae:	2308      	movs	r3, #8
 80017b0:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80017b2:	2302      	movs	r3, #2
 80017b4:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80017b6:	2300      	movs	r3, #0
 80017b8:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80017ba:	2300      	movs	r3, #0
 80017bc:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 80017be:	2305      	movs	r3, #5
 80017c0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);
 80017c2:	f107 031c 	add.w	r3, r7, #28
 80017c6:	4619      	mov	r1, r3
 80017c8:	482e      	ldr	r0, [pc, #184]	@ (8001884 <MX_GPIO_Init+0x1ec>)
 80017ca:	f000 fd01 	bl	80021d0 <HAL_GPIO_Init>

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
 80017ce:	2301      	movs	r3, #1
 80017d0:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 80017d2:	f44f 1390 	mov.w	r3, #1179648	@ 0x120000
 80017d6:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80017d8:	2300      	movs	r3, #0
 80017da:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 80017dc:	f107 031c 	add.w	r3, r7, #28
 80017e0:	4619      	mov	r1, r3
 80017e2:	482a      	ldr	r0, [pc, #168]	@ (800188c <MX_GPIO_Init+0x1f4>)
 80017e4:	f000 fcf4 	bl	80021d0 <HAL_GPIO_Init>

  /*Configure GPIO pin : BOOT1_Pin */
  GPIO_InitStruct.Pin = BOOT1_Pin;
 80017e8:	2304      	movs	r3, #4
 80017ea:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80017ec:	2300      	movs	r3, #0
 80017ee:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80017f0:	2300      	movs	r3, #0
 80017f2:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
 80017f4:	f107 031c 	add.w	r3, r7, #28
 80017f8:	4619      	mov	r1, r3
 80017fa:	4825      	ldr	r0, [pc, #148]	@ (8001890 <MX_GPIO_Init+0x1f8>)
 80017fc:	f000 fce8 	bl	80021d0 <HAL_GPIO_Init>

  /*Configure GPIO pin : CLK_IN_Pin */
  GPIO_InitStruct.Pin = CLK_IN_Pin;
 8001800:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8001804:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001806:	2302      	movs	r3, #2
 8001808:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800180a:	2300      	movs	r3, #0
 800180c:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800180e:	2300      	movs	r3, #0
 8001810:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8001812:	2305      	movs	r3, #5
 8001814:	62fb      	str	r3, [r7, #44]	@ 0x2c
  HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);
 8001816:	f107 031c 	add.w	r3, r7, #28
 800181a:	4619      	mov	r1, r3
 800181c:	481c      	ldr	r0, [pc, #112]	@ (8001890 <MX_GPIO_Init+0x1f8>)
 800181e:	f000 fcd7 	bl	80021d0 <HAL_GPIO_Init>

  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin
                           Audio_RST_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
 8001822:	f24f 0310 	movw	r3, #61456	@ 0xf010
 8001826:	61fb      	str	r3, [r7, #28]
                          |Audio_RST_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001828:	2301      	movs	r3, #1
 800182a:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800182c:	2300      	movs	r3, #0
 800182e:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001830:	2300      	movs	r3, #0
 8001832:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8001834:	f107 031c 	add.w	r3, r7, #28
 8001838:	4619      	mov	r1, r3
 800183a:	4813      	ldr	r0, [pc, #76]	@ (8001888 <MX_GPIO_Init+0x1f0>)
 800183c:	f000 fcc8 	bl	80021d0 <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_OverCurrent_Pin */
  GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
 8001840:	2320      	movs	r3, #32
 8001842:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8001844:	2300      	movs	r3, #0
 8001846:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001848:	2300      	movs	r3, #0
 800184a:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 800184c:	f107 031c 	add.w	r3, r7, #28
 8001850:	4619      	mov	r1, r3
 8001852:	480d      	ldr	r0, [pc, #52]	@ (8001888 <MX_GPIO_Init+0x1f0>)
 8001854:	f000 fcbc 	bl	80021d0 <HAL_GPIO_Init>

  /*Configure GPIO pin : MEMS_INT2_Pin */
  GPIO_InitStruct.Pin = MEMS_INT2_Pin;
 8001858:	2302      	movs	r3, #2
 800185a:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 800185c:	f44f 1390 	mov.w	r3, #1179648	@ 0x120000
 8001860:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001862:	2300      	movs	r3, #0
 8001864:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(MEMS_INT2_GPIO_Port, &GPIO_InitStruct);
 8001866:	f107 031c 	add.w	r3, r7, #28
 800186a:	4619      	mov	r1, r3
 800186c:	4804      	ldr	r0, [pc, #16]	@ (8001880 <MX_GPIO_Init+0x1e8>)
 800186e:	f000 fcaf 	bl	80021d0 <HAL_GPIO_Init>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
 8001872:	bf00      	nop
 8001874:	3730      	adds	r7, #48	@ 0x30
 8001876:	46bd      	mov	sp, r7
 8001878:	bd80      	pop	{r7, pc}
 800187a:	bf00      	nop
 800187c:	40023800 	.word	0x40023800
 8001880:	40021000 	.word	0x40021000
 8001884:	40020800 	.word	0x40020800
 8001888:	40020c00 	.word	0x40020c00
 800188c:	40020000 	.word	0x40020000
 8001890:	40020400 	.word	0x40020400

08001894 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8001894:	b480      	push	{r7}
 8001896:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001898:	b672      	cpsid	i
}
 800189a:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800189c:	bf00      	nop
 800189e:	e7fd      	b.n	800189c <Error_Handler+0x8>

080018a0 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80018a0:	b580      	push	{r7, lr}
 80018a2:	b082      	sub	sp, #8
 80018a4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80018a6:	2300      	movs	r3, #0
 80018a8:	607b      	str	r3, [r7, #4]
 80018aa:	4b10      	ldr	r3, [pc, #64]	@ (80018ec <HAL_MspInit+0x4c>)
 80018ac:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80018ae:	4a0f      	ldr	r2, [pc, #60]	@ (80018ec <HAL_MspInit+0x4c>)
 80018b0:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80018b4:	6453      	str	r3, [r2, #68]	@ 0x44
 80018b6:	4b0d      	ldr	r3, [pc, #52]	@ (80018ec <HAL_MspInit+0x4c>)
 80018b8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80018ba:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80018be:	607b      	str	r3, [r7, #4]
 80018c0:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 80018c2:	2300      	movs	r3, #0
 80018c4:	603b      	str	r3, [r7, #0]
 80018c6:	4b09      	ldr	r3, [pc, #36]	@ (80018ec <HAL_MspInit+0x4c>)
 80018c8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80018ca:	4a08      	ldr	r2, [pc, #32]	@ (80018ec <HAL_MspInit+0x4c>)
 80018cc:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80018d0:	6413      	str	r3, [r2, #64]	@ 0x40
 80018d2:	4b06      	ldr	r3, [pc, #24]	@ (80018ec <HAL_MspInit+0x4c>)
 80018d4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80018d6:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80018da:	603b      	str	r3, [r7, #0]
 80018dc:	683b      	ldr	r3, [r7, #0]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 80018de:	2007      	movs	r0, #7
 80018e0:	f000 fc18 	bl	8002114 <HAL_NVIC_SetPriorityGrouping>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80018e4:	bf00      	nop
 80018e6:	3708      	adds	r7, #8
 80018e8:	46bd      	mov	sp, r7
 80018ea:	bd80      	pop	{r7, pc}
 80018ec:	40023800 	.word	0x40023800

080018f0 <HAL_CRC_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hcrc: CRC handle pointer
  * @retval None
  */
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
 80018f0:	b480      	push	{r7}
 80018f2:	b085      	sub	sp, #20
 80018f4:	af00      	add	r7, sp, #0
 80018f6:	6078      	str	r0, [r7, #4]
  if(hcrc->Instance==CRC)
 80018f8:	687b      	ldr	r3, [r7, #4]
 80018fa:	681b      	ldr	r3, [r3, #0]
 80018fc:	4a0b      	ldr	r2, [pc, #44]	@ (800192c <HAL_CRC_MspInit+0x3c>)
 80018fe:	4293      	cmp	r3, r2
 8001900:	d10d      	bne.n	800191e <HAL_CRC_MspInit+0x2e>
  {
    /* USER CODE BEGIN CRC_MspInit 0 */

    /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 8001902:	2300      	movs	r3, #0
 8001904:	60fb      	str	r3, [r7, #12]
 8001906:	4b0a      	ldr	r3, [pc, #40]	@ (8001930 <HAL_CRC_MspInit+0x40>)
 8001908:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800190a:	4a09      	ldr	r2, [pc, #36]	@ (8001930 <HAL_CRC_MspInit+0x40>)
 800190c:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8001910:	6313      	str	r3, [r2, #48]	@ 0x30
 8001912:	4b07      	ldr	r3, [pc, #28]	@ (8001930 <HAL_CRC_MspInit+0x40>)
 8001914:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001916:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 800191a:	60fb      	str	r3, [r7, #12]
 800191c:	68fb      	ldr	r3, [r7, #12]

    /* USER CODE END CRC_MspInit 1 */

  }

}
 800191e:	bf00      	nop
 8001920:	3714      	adds	r7, #20
 8001922:	46bd      	mov	sp, r7
 8001924:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001928:	4770      	bx	lr
 800192a:	bf00      	nop
 800192c:	40023000 	.word	0x40023000
 8001930:	40023800 	.word	0x40023800

08001934 <HAL_I2C_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8001934:	b580      	push	{r7, lr}
 8001936:	b08a      	sub	sp, #40	@ 0x28
 8001938:	af00      	add	r7, sp, #0
 800193a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800193c:	f107 0314 	add.w	r3, r7, #20
 8001940:	2200      	movs	r2, #0
 8001942:	601a      	str	r2, [r3, #0]
 8001944:	605a      	str	r2, [r3, #4]
 8001946:	609a      	str	r2, [r3, #8]
 8001948:	60da      	str	r2, [r3, #12]
 800194a:	611a      	str	r2, [r3, #16]
  if(hi2c->Instance==I2C1)
 800194c:	687b      	ldr	r3, [r7, #4]
 800194e:	681b      	ldr	r3, [r3, #0]
 8001950:	4a19      	ldr	r2, [pc, #100]	@ (80019b8 <HAL_I2C_MspInit+0x84>)
 8001952:	4293      	cmp	r3, r2
 8001954:	d12c      	bne.n	80019b0 <HAL_I2C_MspInit+0x7c>
  {
    /* USER CODE BEGIN I2C1_MspInit 0 */

    /* USER CODE END I2C1_MspInit 0 */

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8001956:	2300      	movs	r3, #0
 8001958:	613b      	str	r3, [r7, #16]
 800195a:	4b18      	ldr	r3, [pc, #96]	@ (80019bc <HAL_I2C_MspInit+0x88>)
 800195c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800195e:	4a17      	ldr	r2, [pc, #92]	@ (80019bc <HAL_I2C_MspInit+0x88>)
 8001960:	f043 0302 	orr.w	r3, r3, #2
 8001964:	6313      	str	r3, [r2, #48]	@ 0x30
 8001966:	4b15      	ldr	r3, [pc, #84]	@ (80019bc <HAL_I2C_MspInit+0x88>)
 8001968:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800196a:	f003 0302 	and.w	r3, r3, #2
 800196e:	613b      	str	r3, [r7, #16]
 8001970:	693b      	ldr	r3, [r7, #16]
    /**I2C1 GPIO Configuration
    PB6     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = Audio_SCL_Pin|Audio_SDA_Pin;
 8001972:	f44f 7310 	mov.w	r3, #576	@ 0x240
 8001976:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8001978:	2312      	movs	r3, #18
 800197a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800197c:	2301      	movs	r3, #1
 800197e:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001980:	2300      	movs	r3, #0
 8001982:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8001984:	2304      	movs	r3, #4
 8001986:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001988:	f107 0314 	add.w	r3, r7, #20
 800198c:	4619      	mov	r1, r3
 800198e:	480c      	ldr	r0, [pc, #48]	@ (80019c0 <HAL_I2C_MspInit+0x8c>)
 8001990:	f000 fc1e 	bl	80021d0 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 8001994:	2300      	movs	r3, #0
 8001996:	60fb      	str	r3, [r7, #12]
 8001998:	4b08      	ldr	r3, [pc, #32]	@ (80019bc <HAL_I2C_MspInit+0x88>)
 800199a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800199c:	4a07      	ldr	r2, [pc, #28]	@ (80019bc <HAL_I2C_MspInit+0x88>)
 800199e:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 80019a2:	6413      	str	r3, [r2, #64]	@ 0x40
 80019a4:	4b05      	ldr	r3, [pc, #20]	@ (80019bc <HAL_I2C_MspInit+0x88>)
 80019a6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80019a8:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 80019ac:	60fb      	str	r3, [r7, #12]
 80019ae:	68fb      	ldr	r3, [r7, #12]

    /* USER CODE END I2C1_MspInit 1 */

  }

}
 80019b0:	bf00      	nop
 80019b2:	3728      	adds	r7, #40	@ 0x28
 80019b4:	46bd      	mov	sp, r7
 80019b6:	bd80      	pop	{r7, pc}
 80019b8:	40005400 	.word	0x40005400
 80019bc:	40023800 	.word	0x40023800
 80019c0:	40020400 	.word	0x40020400

080019c4 <HAL_I2S_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hi2s: I2S handle pointer
  * @retval None
  */
void HAL_I2S_MspInit(I2S_HandleTypeDef* hi2s)
{
 80019c4:	b580      	push	{r7, lr}
 80019c6:	b08e      	sub	sp, #56	@ 0x38
 80019c8:	af00      	add	r7, sp, #0
 80019ca:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80019cc:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80019d0:	2200      	movs	r2, #0
 80019d2:	601a      	str	r2, [r3, #0]
 80019d4:	605a      	str	r2, [r3, #4]
 80019d6:	609a      	str	r2, [r3, #8]
 80019d8:	60da      	str	r2, [r3, #12]
 80019da:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80019dc:	f107 0314 	add.w	r3, r7, #20
 80019e0:	2200      	movs	r2, #0
 80019e2:	601a      	str	r2, [r3, #0]
 80019e4:	605a      	str	r2, [r3, #4]
 80019e6:	609a      	str	r2, [r3, #8]
 80019e8:	60da      	str	r2, [r3, #12]
  if(hi2s->Instance==SPI3)
 80019ea:	687b      	ldr	r3, [r7, #4]
 80019ec:	681b      	ldr	r3, [r3, #0]
 80019ee:	4a31      	ldr	r2, [pc, #196]	@ (8001ab4 <HAL_I2S_MspInit+0xf0>)
 80019f0:	4293      	cmp	r3, r2
 80019f2:	d15a      	bne.n	8001aaa <HAL_I2S_MspInit+0xe6>

    /* USER CODE END SPI3_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2S;
 80019f4:	2301      	movs	r3, #1
 80019f6:	617b      	str	r3, [r7, #20]
    PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
 80019f8:	23c0      	movs	r3, #192	@ 0xc0
 80019fa:	61bb      	str	r3, [r7, #24]
    PeriphClkInitStruct.PLLI2S.PLLI2SR = 2;
 80019fc:	2302      	movs	r3, #2
 80019fe:	61fb      	str	r3, [r7, #28]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001a00:	f107 0314 	add.w	r3, r7, #20
 8001a04:	4618      	mov	r0, r3
 8001a06:	f003 fa6b 	bl	8004ee0 <HAL_RCCEx_PeriphCLKConfig>
 8001a0a:	4603      	mov	r3, r0
 8001a0c:	2b00      	cmp	r3, #0
 8001a0e:	d001      	beq.n	8001a14 <HAL_I2S_MspInit+0x50>
    {
      Error_Handler();
 8001a10:	f7ff ff40 	bl	8001894 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_SPI3_CLK_ENABLE();
 8001a14:	2300      	movs	r3, #0
 8001a16:	613b      	str	r3, [r7, #16]
 8001a18:	4b27      	ldr	r3, [pc, #156]	@ (8001ab8 <HAL_I2S_MspInit+0xf4>)
 8001a1a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001a1c:	4a26      	ldr	r2, [pc, #152]	@ (8001ab8 <HAL_I2S_MspInit+0xf4>)
 8001a1e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8001a22:	6413      	str	r3, [r2, #64]	@ 0x40
 8001a24:	4b24      	ldr	r3, [pc, #144]	@ (8001ab8 <HAL_I2S_MspInit+0xf4>)
 8001a26:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001a28:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8001a2c:	613b      	str	r3, [r7, #16]
 8001a2e:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a30:	2300      	movs	r3, #0
 8001a32:	60fb      	str	r3, [r7, #12]
 8001a34:	4b20      	ldr	r3, [pc, #128]	@ (8001ab8 <HAL_I2S_MspInit+0xf4>)
 8001a36:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a38:	4a1f      	ldr	r2, [pc, #124]	@ (8001ab8 <HAL_I2S_MspInit+0xf4>)
 8001a3a:	f043 0301 	orr.w	r3, r3, #1
 8001a3e:	6313      	str	r3, [r2, #48]	@ 0x30
 8001a40:	4b1d      	ldr	r3, [pc, #116]	@ (8001ab8 <HAL_I2S_MspInit+0xf4>)
 8001a42:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a44:	f003 0301 	and.w	r3, r3, #1
 8001a48:	60fb      	str	r3, [r7, #12]
 8001a4a:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8001a4c:	2300      	movs	r3, #0
 8001a4e:	60bb      	str	r3, [r7, #8]
 8001a50:	4b19      	ldr	r3, [pc, #100]	@ (8001ab8 <HAL_I2S_MspInit+0xf4>)
 8001a52:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a54:	4a18      	ldr	r2, [pc, #96]	@ (8001ab8 <HAL_I2S_MspInit+0xf4>)
 8001a56:	f043 0304 	orr.w	r3, r3, #4
 8001a5a:	6313      	str	r3, [r2, #48]	@ 0x30
 8001a5c:	4b16      	ldr	r3, [pc, #88]	@ (8001ab8 <HAL_I2S_MspInit+0xf4>)
 8001a5e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a60:	f003 0304 	and.w	r3, r3, #4
 8001a64:	60bb      	str	r3, [r7, #8]
 8001a66:	68bb      	ldr	r3, [r7, #8]
    PA4     ------> I2S3_WS
    PC7     ------> I2S3_MCK
    PC10     ------> I2S3_CK
    PC12     ------> I2S3_SD
    */
    GPIO_InitStruct.Pin = I2S3_WS_Pin;
 8001a68:	2310      	movs	r3, #16
 8001a6a:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001a6c:	2302      	movs	r3, #2
 8001a6e:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001a70:	2300      	movs	r3, #0
 8001a72:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001a74:	2300      	movs	r3, #0
 8001a76:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8001a78:	2306      	movs	r3, #6
 8001a7a:	637b      	str	r3, [r7, #52]	@ 0x34
    HAL_GPIO_Init(I2S3_WS_GPIO_Port, &GPIO_InitStruct);
 8001a7c:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8001a80:	4619      	mov	r1, r3
 8001a82:	480e      	ldr	r0, [pc, #56]	@ (8001abc <HAL_I2S_MspInit+0xf8>)
 8001a84:	f000 fba4 	bl	80021d0 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = I2S3_MCK_Pin|I2S3_SCK_Pin|I2S3_SD_Pin;
 8001a88:	f44f 53a4 	mov.w	r3, #5248	@ 0x1480
 8001a8c:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001a8e:	2302      	movs	r3, #2
 8001a90:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001a92:	2300      	movs	r3, #0
 8001a94:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001a96:	2300      	movs	r3, #0
 8001a98:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8001a9a:	2306      	movs	r3, #6
 8001a9c:	637b      	str	r3, [r7, #52]	@ 0x34
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001a9e:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8001aa2:	4619      	mov	r1, r3
 8001aa4:	4806      	ldr	r0, [pc, #24]	@ (8001ac0 <HAL_I2S_MspInit+0xfc>)
 8001aa6:	f000 fb93 	bl	80021d0 <HAL_GPIO_Init>

    /* USER CODE END SPI3_MspInit 1 */

  }

}
 8001aaa:	bf00      	nop
 8001aac:	3738      	adds	r7, #56	@ 0x38
 8001aae:	46bd      	mov	sp, r7
 8001ab0:	bd80      	pop	{r7, pc}
 8001ab2:	bf00      	nop
 8001ab4:	40003c00 	.word	0x40003c00
 8001ab8:	40023800 	.word	0x40023800
 8001abc:	40020000 	.word	0x40020000
 8001ac0:	40020800 	.word	0x40020800

08001ac4 <HAL_RNG_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hrng: RNG handle pointer
  * @retval None
  */
void HAL_RNG_MspInit(RNG_HandleTypeDef* hrng)
{
 8001ac4:	b480      	push	{r7}
 8001ac6:	b085      	sub	sp, #20
 8001ac8:	af00      	add	r7, sp, #0
 8001aca:	6078      	str	r0, [r7, #4]
  if(hrng->Instance==RNG)
 8001acc:	687b      	ldr	r3, [r7, #4]
 8001ace:	681b      	ldr	r3, [r3, #0]
 8001ad0:	4a0b      	ldr	r2, [pc, #44]	@ (8001b00 <HAL_RNG_MspInit+0x3c>)
 8001ad2:	4293      	cmp	r3, r2
 8001ad4:	d10d      	bne.n	8001af2 <HAL_RNG_MspInit+0x2e>
  {
    /* USER CODE BEGIN RNG_MspInit 0 */

    /* USER CODE END RNG_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
 8001ad6:	2300      	movs	r3, #0
 8001ad8:	60fb      	str	r3, [r7, #12]
 8001ada:	4b0a      	ldr	r3, [pc, #40]	@ (8001b04 <HAL_RNG_MspInit+0x40>)
 8001adc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001ade:	4a09      	ldr	r2, [pc, #36]	@ (8001b04 <HAL_RNG_MspInit+0x40>)
 8001ae0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8001ae4:	6353      	str	r3, [r2, #52]	@ 0x34
 8001ae6:	4b07      	ldr	r3, [pc, #28]	@ (8001b04 <HAL_RNG_MspInit+0x40>)
 8001ae8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001aea:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8001aee:	60fb      	str	r3, [r7, #12]
 8001af0:	68fb      	ldr	r3, [r7, #12]

    /* USER CODE END RNG_MspInit 1 */

  }

}
 8001af2:	bf00      	nop
 8001af4:	3714      	adds	r7, #20
 8001af6:	46bd      	mov	sp, r7
 8001af8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001afc:	4770      	bx	lr
 8001afe:	bf00      	nop
 8001b00:	50060800 	.word	0x50060800
 8001b04:	40023800 	.word	0x40023800

08001b08 <HAL_RNG_MspDeInit>:
  * This function freeze the hardware resources used in this example
  * @param hrng: RNG handle pointer
  * @retval None
  */
void HAL_RNG_MspDeInit(RNG_HandleTypeDef* hrng)
{
 8001b08:	b480      	push	{r7}
 8001b0a:	b083      	sub	sp, #12
 8001b0c:	af00      	add	r7, sp, #0
 8001b0e:	6078      	str	r0, [r7, #4]
  if(hrng->Instance==RNG)
 8001b10:	687b      	ldr	r3, [r7, #4]
 8001b12:	681b      	ldr	r3, [r3, #0]
 8001b14:	4a07      	ldr	r2, [pc, #28]	@ (8001b34 <HAL_RNG_MspDeInit+0x2c>)
 8001b16:	4293      	cmp	r3, r2
 8001b18:	d105      	bne.n	8001b26 <HAL_RNG_MspDeInit+0x1e>
  {
    /* USER CODE BEGIN RNG_MspDeInit 0 */

    /* USER CODE END RNG_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_RNG_CLK_DISABLE();
 8001b1a:	4b07      	ldr	r3, [pc, #28]	@ (8001b38 <HAL_RNG_MspDeInit+0x30>)
 8001b1c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001b1e:	4a06      	ldr	r2, [pc, #24]	@ (8001b38 <HAL_RNG_MspDeInit+0x30>)
 8001b20:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8001b24:	6353      	str	r3, [r2, #52]	@ 0x34
    /* USER CODE BEGIN RNG_MspDeInit 1 */

    /* USER CODE END RNG_MspDeInit 1 */
  }

}
 8001b26:	bf00      	nop
 8001b28:	370c      	adds	r7, #12
 8001b2a:	46bd      	mov	sp, r7
 8001b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b30:	4770      	bx	lr
 8001b32:	bf00      	nop
 8001b34:	50060800 	.word	0x50060800
 8001b38:	40023800 	.word	0x40023800

08001b3c <HAL_SPI_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hspi: SPI handle pointer
  * @retval None
  */
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8001b3c:	b580      	push	{r7, lr}
 8001b3e:	b08a      	sub	sp, #40	@ 0x28
 8001b40:	af00      	add	r7, sp, #0
 8001b42:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001b44:	f107 0314 	add.w	r3, r7, #20
 8001b48:	2200      	movs	r2, #0
 8001b4a:	601a      	str	r2, [r3, #0]
 8001b4c:	605a      	str	r2, [r3, #4]
 8001b4e:	609a      	str	r2, [r3, #8]
 8001b50:	60da      	str	r2, [r3, #12]
 8001b52:	611a      	str	r2, [r3, #16]
  if(hspi->Instance==SPI1)
 8001b54:	687b      	ldr	r3, [r7, #4]
 8001b56:	681b      	ldr	r3, [r3, #0]
 8001b58:	4a19      	ldr	r2, [pc, #100]	@ (8001bc0 <HAL_SPI_MspInit+0x84>)
 8001b5a:	4293      	cmp	r3, r2
 8001b5c:	d12b      	bne.n	8001bb6 <HAL_SPI_MspInit+0x7a>
  {
    /* USER CODE BEGIN SPI1_MspInit 0 */

    /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8001b5e:	2300      	movs	r3, #0
 8001b60:	613b      	str	r3, [r7, #16]
 8001b62:	4b18      	ldr	r3, [pc, #96]	@ (8001bc4 <HAL_SPI_MspInit+0x88>)
 8001b64:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8001b66:	4a17      	ldr	r2, [pc, #92]	@ (8001bc4 <HAL_SPI_MspInit+0x88>)
 8001b68:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8001b6c:	6453      	str	r3, [r2, #68]	@ 0x44
 8001b6e:	4b15      	ldr	r3, [pc, #84]	@ (8001bc4 <HAL_SPI_MspInit+0x88>)
 8001b70:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8001b72:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8001b76:	613b      	str	r3, [r7, #16]
 8001b78:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001b7a:	2300      	movs	r3, #0
 8001b7c:	60fb      	str	r3, [r7, #12]
 8001b7e:	4b11      	ldr	r3, [pc, #68]	@ (8001bc4 <HAL_SPI_MspInit+0x88>)
 8001b80:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001b82:	4a10      	ldr	r2, [pc, #64]	@ (8001bc4 <HAL_SPI_MspInit+0x88>)
 8001b84:	f043 0301 	orr.w	r3, r3, #1
 8001b88:	6313      	str	r3, [r2, #48]	@ 0x30
 8001b8a:	4b0e      	ldr	r3, [pc, #56]	@ (8001bc4 <HAL_SPI_MspInit+0x88>)
 8001b8c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001b8e:	f003 0301 	and.w	r3, r3, #1
 8001b92:	60fb      	str	r3, [r7, #12]
 8001b94:	68fb      	ldr	r3, [r7, #12]
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = SPI1_SCK_Pin|SPI1_MISO_Pin|SPI1_MOSI_Pin;
 8001b96:	23e0      	movs	r3, #224	@ 0xe0
 8001b98:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b9a:	2302      	movs	r3, #2
 8001b9c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001b9e:	2300      	movs	r3, #0
 8001ba0:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001ba2:	2300      	movs	r3, #0
 8001ba4:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8001ba6:	2305      	movs	r3, #5
 8001ba8:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001baa:	f107 0314 	add.w	r3, r7, #20
 8001bae:	4619      	mov	r1, r3
 8001bb0:	4805      	ldr	r0, [pc, #20]	@ (8001bc8 <HAL_SPI_MspInit+0x8c>)
 8001bb2:	f000 fb0d 	bl	80021d0 <HAL_GPIO_Init>

    /* USER CODE END SPI1_MspInit 1 */

  }

}
 8001bb6:	bf00      	nop
 8001bb8:	3728      	adds	r7, #40	@ 0x28
 8001bba:	46bd      	mov	sp, r7
 8001bbc:	bd80      	pop	{r7, pc}
 8001bbe:	bf00      	nop
 8001bc0:	40013000 	.word	0x40013000
 8001bc4:	40023800 	.word	0x40023800
 8001bc8:	40020000 	.word	0x40020000

08001bcc <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8001bcc:	b480      	push	{r7}
 8001bce:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8001bd0:	bf00      	nop
 8001bd2:	e7fd      	b.n	8001bd0 <NMI_Handler+0x4>

08001bd4 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8001bd4:	b480      	push	{r7}
 8001bd6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001bd8:	bf00      	nop
 8001bda:	e7fd      	b.n	8001bd8 <HardFault_Handler+0x4>

08001bdc <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8001bdc:	b480      	push	{r7}
 8001bde:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001be0:	bf00      	nop
 8001be2:	e7fd      	b.n	8001be0 <MemManage_Handler+0x4>

08001be4 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8001be4:	b480      	push	{r7}
 8001be6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001be8:	bf00      	nop
 8001bea:	e7fd      	b.n	8001be8 <BusFault_Handler+0x4>

08001bec <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8001bec:	b480      	push	{r7}
 8001bee:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001bf0:	bf00      	nop
 8001bf2:	e7fd      	b.n	8001bf0 <UsageFault_Handler+0x4>

08001bf4 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8001bf4:	b480      	push	{r7}
 8001bf6:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8001bf8:	bf00      	nop
 8001bfa:	46bd      	mov	sp, r7
 8001bfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c00:	4770      	bx	lr

08001c02 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8001c02:	b480      	push	{r7}
 8001c04:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8001c06:	bf00      	nop
 8001c08:	46bd      	mov	sp, r7
 8001c0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c0e:	4770      	bx	lr

08001c10 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8001c10:	b480      	push	{r7}
 8001c12:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8001c14:	bf00      	nop
 8001c16:	46bd      	mov	sp, r7
 8001c18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c1c:	4770      	bx	lr

08001c1e <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8001c1e:	b580      	push	{r7, lr}
 8001c20:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8001c22:	f000 f93f 	bl	8001ea4 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8001c26:	bf00      	nop
 8001c28:	bd80      	pop	{r7, pc}
	...

08001c2c <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 8001c2c:	b580      	push	{r7, lr}
 8001c2e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8001c30:	4802      	ldr	r0, [pc, #8]	@ (8001c3c <OTG_FS_IRQHandler+0x10>)
 8001c32:	f001 fbc3 	bl	80033bc <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 8001c36:	bf00      	nop
 8001c38:	bd80      	pop	{r7, pc}
 8001c3a:	bf00      	nop
 8001c3c:	2000313c 	.word	0x2000313c

08001c40 <_read>:
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8001c40:	b580      	push	{r7, lr}
 8001c42:	b086      	sub	sp, #24
 8001c44:	af00      	add	r7, sp, #0
 8001c46:	60f8      	str	r0, [r7, #12]
 8001c48:	60b9      	str	r1, [r7, #8]
 8001c4a:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001c4c:	2300      	movs	r3, #0
 8001c4e:	617b      	str	r3, [r7, #20]
 8001c50:	e00a      	b.n	8001c68 <_read+0x28>
  {
    *ptr++ = __io_getchar();
 8001c52:	f3af 8000 	nop.w
 8001c56:	4601      	mov	r1, r0
 8001c58:	68bb      	ldr	r3, [r7, #8]
 8001c5a:	1c5a      	adds	r2, r3, #1
 8001c5c:	60ba      	str	r2, [r7, #8]
 8001c5e:	b2ca      	uxtb	r2, r1
 8001c60:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001c62:	697b      	ldr	r3, [r7, #20]
 8001c64:	3301      	adds	r3, #1
 8001c66:	617b      	str	r3, [r7, #20]
 8001c68:	697a      	ldr	r2, [r7, #20]
 8001c6a:	687b      	ldr	r3, [r7, #4]
 8001c6c:	429a      	cmp	r2, r3
 8001c6e:	dbf0      	blt.n	8001c52 <_read+0x12>
  }

  return len;
 8001c70:	687b      	ldr	r3, [r7, #4]
}
 8001c72:	4618      	mov	r0, r3
 8001c74:	3718      	adds	r7, #24
 8001c76:	46bd      	mov	sp, r7
 8001c78:	bd80      	pop	{r7, pc}

08001c7a <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8001c7a:	b580      	push	{r7, lr}
 8001c7c:	b086      	sub	sp, #24
 8001c7e:	af00      	add	r7, sp, #0
 8001c80:	60f8      	str	r0, [r7, #12]
 8001c82:	60b9      	str	r1, [r7, #8]
 8001c84:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001c86:	2300      	movs	r3, #0
 8001c88:	617b      	str	r3, [r7, #20]
 8001c8a:	e009      	b.n	8001ca0 <_write+0x26>
  {
    __io_putchar(*ptr++);
 8001c8c:	68bb      	ldr	r3, [r7, #8]
 8001c8e:	1c5a      	adds	r2, r3, #1
 8001c90:	60ba      	str	r2, [r7, #8]
 8001c92:	781b      	ldrb	r3, [r3, #0]
 8001c94:	4618      	mov	r0, r3
 8001c96:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001c9a:	697b      	ldr	r3, [r7, #20]
 8001c9c:	3301      	adds	r3, #1
 8001c9e:	617b      	str	r3, [r7, #20]
 8001ca0:	697a      	ldr	r2, [r7, #20]
 8001ca2:	687b      	ldr	r3, [r7, #4]
 8001ca4:	429a      	cmp	r2, r3
 8001ca6:	dbf1      	blt.n	8001c8c <_write+0x12>
  }
  return len;
 8001ca8:	687b      	ldr	r3, [r7, #4]
}
 8001caa:	4618      	mov	r0, r3
 8001cac:	3718      	adds	r7, #24
 8001cae:	46bd      	mov	sp, r7
 8001cb0:	bd80      	pop	{r7, pc}

08001cb2 <_close>:

int _close(int file)
{
 8001cb2:	b480      	push	{r7}
 8001cb4:	b083      	sub	sp, #12
 8001cb6:	af00      	add	r7, sp, #0
 8001cb8:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 8001cba:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
 8001cbe:	4618      	mov	r0, r3
 8001cc0:	370c      	adds	r7, #12
 8001cc2:	46bd      	mov	sp, r7
 8001cc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001cc8:	4770      	bx	lr

08001cca <_fstat>:


int _fstat(int file, struct stat *st)
{
 8001cca:	b480      	push	{r7}
 8001ccc:	b083      	sub	sp, #12
 8001cce:	af00      	add	r7, sp, #0
 8001cd0:	6078      	str	r0, [r7, #4]
 8001cd2:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 8001cd4:	683b      	ldr	r3, [r7, #0]
 8001cd6:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8001cda:	605a      	str	r2, [r3, #4]
  return 0;
 8001cdc:	2300      	movs	r3, #0
}
 8001cde:	4618      	mov	r0, r3
 8001ce0:	370c      	adds	r7, #12
 8001ce2:	46bd      	mov	sp, r7
 8001ce4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ce8:	4770      	bx	lr

08001cea <_isatty>:

int _isatty(int file)
{
 8001cea:	b480      	push	{r7}
 8001cec:	b083      	sub	sp, #12
 8001cee:	af00      	add	r7, sp, #0
 8001cf0:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 8001cf2:	2301      	movs	r3, #1
}
 8001cf4:	4618      	mov	r0, r3
 8001cf6:	370c      	adds	r7, #12
 8001cf8:	46bd      	mov	sp, r7
 8001cfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001cfe:	4770      	bx	lr

08001d00 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 8001d00:	b480      	push	{r7}
 8001d02:	b085      	sub	sp, #20
 8001d04:	af00      	add	r7, sp, #0
 8001d06:	60f8      	str	r0, [r7, #12]
 8001d08:	60b9      	str	r1, [r7, #8]
 8001d0a:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 8001d0c:	2300      	movs	r3, #0
}
 8001d0e:	4618      	mov	r0, r3
 8001d10:	3714      	adds	r7, #20
 8001d12:	46bd      	mov	sp, r7
 8001d14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d18:	4770      	bx	lr
	...

08001d1c <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001d1c:	b580      	push	{r7, lr}
 8001d1e:	b086      	sub	sp, #24
 8001d20:	af00      	add	r7, sp, #0
 8001d22:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001d24:	4a14      	ldr	r2, [pc, #80]	@ (8001d78 <_sbrk+0x5c>)
 8001d26:	4b15      	ldr	r3, [pc, #84]	@ (8001d7c <_sbrk+0x60>)
 8001d28:	1ad3      	subs	r3, r2, r3
 8001d2a:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8001d2c:	697b      	ldr	r3, [r7, #20]
 8001d2e:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001d30:	4b13      	ldr	r3, [pc, #76]	@ (8001d80 <_sbrk+0x64>)
 8001d32:	681b      	ldr	r3, [r3, #0]
 8001d34:	2b00      	cmp	r3, #0
 8001d36:	d102      	bne.n	8001d3e <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8001d38:	4b11      	ldr	r3, [pc, #68]	@ (8001d80 <_sbrk+0x64>)
 8001d3a:	4a12      	ldr	r2, [pc, #72]	@ (8001d84 <_sbrk+0x68>)
 8001d3c:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001d3e:	4b10      	ldr	r3, [pc, #64]	@ (8001d80 <_sbrk+0x64>)
 8001d40:	681a      	ldr	r2, [r3, #0]
 8001d42:	687b      	ldr	r3, [r7, #4]
 8001d44:	4413      	add	r3, r2
 8001d46:	693a      	ldr	r2, [r7, #16]
 8001d48:	429a      	cmp	r2, r3
 8001d4a:	d207      	bcs.n	8001d5c <_sbrk+0x40>
  {
    errno = ENOMEM;
 8001d4c:	f026 ffee 	bl	8028d2c <__errno>
 8001d50:	4603      	mov	r3, r0
 8001d52:	220c      	movs	r2, #12
 8001d54:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8001d56:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8001d5a:	e009      	b.n	8001d70 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8001d5c:	4b08      	ldr	r3, [pc, #32]	@ (8001d80 <_sbrk+0x64>)
 8001d5e:	681b      	ldr	r3, [r3, #0]
 8001d60:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8001d62:	4b07      	ldr	r3, [pc, #28]	@ (8001d80 <_sbrk+0x64>)
 8001d64:	681a      	ldr	r2, [r3, #0]
 8001d66:	687b      	ldr	r3, [r7, #4]
 8001d68:	4413      	add	r3, r2
 8001d6a:	4a05      	ldr	r2, [pc, #20]	@ (8001d80 <_sbrk+0x64>)
 8001d6c:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8001d6e:	68fb      	ldr	r3, [r7, #12]
}
 8001d70:	4618      	mov	r0, r3
 8001d72:	3718      	adds	r7, #24
 8001d74:	46bd      	mov	sp, r7
 8001d76:	bd80      	pop	{r7, pc}
 8001d78:	20020000 	.word	0x20020000
 8001d7c:	00000400 	.word	0x00000400
 8001d80:	20001be4 	.word	0x20001be4
 8001d84:	20003990 	.word	0x20003990

08001d88 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8001d88:	b480      	push	{r7}
 8001d8a:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001d8c:	4b06      	ldr	r3, [pc, #24]	@ (8001da8 <SystemInit+0x20>)
 8001d8e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8001d92:	4a05      	ldr	r2, [pc, #20]	@ (8001da8 <SystemInit+0x20>)
 8001d94:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8001d98:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8001d9c:	bf00      	nop
 8001d9e:	46bd      	mov	sp, r7
 8001da0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001da4:	4770      	bx	lr
 8001da6:	bf00      	nop
 8001da8:	e000ed00 	.word	0xe000ed00

08001dac <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8001dac:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8001de4 <LoopFillZerobss+0xe>
  
/* Call the clock system initialization function.*/
  bl  SystemInit  
 8001db0:	f7ff ffea 	bl	8001d88 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8001db4:	480c      	ldr	r0, [pc, #48]	@ (8001de8 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8001db6:	490d      	ldr	r1, [pc, #52]	@ (8001dec <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8001db8:	4a0d      	ldr	r2, [pc, #52]	@ (8001df0 <LoopFillZerobss+0x1a>)
  movs r3, #0
 8001dba:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001dbc:	e002      	b.n	8001dc4 <LoopCopyDataInit>

08001dbe <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001dbe:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001dc0:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001dc2:	3304      	adds	r3, #4

08001dc4 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001dc4:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001dc6:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001dc8:	d3f9      	bcc.n	8001dbe <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001dca:	4a0a      	ldr	r2, [pc, #40]	@ (8001df4 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001dcc:	4c0a      	ldr	r4, [pc, #40]	@ (8001df8 <LoopFillZerobss+0x22>)
  movs r3, #0
 8001dce:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001dd0:	e001      	b.n	8001dd6 <LoopFillZerobss>

08001dd2 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001dd2:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001dd4:	3204      	adds	r2, #4

08001dd6 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001dd6:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001dd8:	d3fb      	bcc.n	8001dd2 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8001dda:	f026 ffad 	bl	8028d38 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001dde:	f7ff fb15 	bl	800140c <main>
  bx  lr    
 8001de2:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 8001de4:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8001de8:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001dec:	20000190 	.word	0x20000190
  ldr r2, =_sidata
 8001df0:	08034d3c 	.word	0x08034d3c
  ldr r2, =_sbss
 8001df4:	20000190 	.word	0x20000190
  ldr r4, =_ebss
 8001df8:	2000398c 	.word	0x2000398c

08001dfc <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001dfc:	e7fe      	b.n	8001dfc <ADC_IRQHandler>
	...

08001e00 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001e00:	b580      	push	{r7, lr}
 8001e02:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001e04:	4b0e      	ldr	r3, [pc, #56]	@ (8001e40 <HAL_Init+0x40>)
 8001e06:	681b      	ldr	r3, [r3, #0]
 8001e08:	4a0d      	ldr	r2, [pc, #52]	@ (8001e40 <HAL_Init+0x40>)
 8001e0a:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8001e0e:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8001e10:	4b0b      	ldr	r3, [pc, #44]	@ (8001e40 <HAL_Init+0x40>)
 8001e12:	681b      	ldr	r3, [r3, #0]
 8001e14:	4a0a      	ldr	r2, [pc, #40]	@ (8001e40 <HAL_Init+0x40>)
 8001e16:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8001e1a:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001e1c:	4b08      	ldr	r3, [pc, #32]	@ (8001e40 <HAL_Init+0x40>)
 8001e1e:	681b      	ldr	r3, [r3, #0]
 8001e20:	4a07      	ldr	r2, [pc, #28]	@ (8001e40 <HAL_Init+0x40>)
 8001e22:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001e26:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001e28:	2003      	movs	r0, #3
 8001e2a:	f000 f973 	bl	8002114 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001e2e:	2000      	movs	r0, #0
 8001e30:	f000 f808 	bl	8001e44 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8001e34:	f7ff fd34 	bl	80018a0 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8001e38:	2300      	movs	r3, #0
}
 8001e3a:	4618      	mov	r0, r3
 8001e3c:	bd80      	pop	{r7, pc}
 8001e3e:	bf00      	nop
 8001e40:	40023c00 	.word	0x40023c00

08001e44 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001e44:	b580      	push	{r7, lr}
 8001e46:	b082      	sub	sp, #8
 8001e48:	af00      	add	r7, sp, #0
 8001e4a:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8001e4c:	4b12      	ldr	r3, [pc, #72]	@ (8001e98 <HAL_InitTick+0x54>)
 8001e4e:	681a      	ldr	r2, [r3, #0]
 8001e50:	4b12      	ldr	r3, [pc, #72]	@ (8001e9c <HAL_InitTick+0x58>)
 8001e52:	781b      	ldrb	r3, [r3, #0]
 8001e54:	4619      	mov	r1, r3
 8001e56:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8001e5a:	fbb3 f3f1 	udiv	r3, r3, r1
 8001e5e:	fbb2 f3f3 	udiv	r3, r2, r3
 8001e62:	4618      	mov	r0, r3
 8001e64:	f000 f98b 	bl	800217e <HAL_SYSTICK_Config>
 8001e68:	4603      	mov	r3, r0
 8001e6a:	2b00      	cmp	r3, #0
 8001e6c:	d001      	beq.n	8001e72 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 8001e6e:	2301      	movs	r3, #1
 8001e70:	e00e      	b.n	8001e90 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001e72:	687b      	ldr	r3, [r7, #4]
 8001e74:	2b0f      	cmp	r3, #15
 8001e76:	d80a      	bhi.n	8001e8e <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001e78:	2200      	movs	r2, #0
 8001e7a:	6879      	ldr	r1, [r7, #4]
 8001e7c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8001e80:	f000 f953 	bl	800212a <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8001e84:	4a06      	ldr	r2, [pc, #24]	@ (8001ea0 <HAL_InitTick+0x5c>)
 8001e86:	687b      	ldr	r3, [r7, #4]
 8001e88:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8001e8a:	2300      	movs	r3, #0
 8001e8c:	e000      	b.n	8001e90 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 8001e8e:	2301      	movs	r3, #1
}
 8001e90:	4618      	mov	r0, r3
 8001e92:	3708      	adds	r7, #8
 8001e94:	46bd      	mov	sp, r7
 8001e96:	bd80      	pop	{r7, pc}
 8001e98:	20000018 	.word	0x20000018
 8001e9c:	20000020 	.word	0x20000020
 8001ea0:	2000001c 	.word	0x2000001c

08001ea4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8001ea4:	b480      	push	{r7}
 8001ea6:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8001ea8:	4b06      	ldr	r3, [pc, #24]	@ (8001ec4 <HAL_IncTick+0x20>)
 8001eaa:	781b      	ldrb	r3, [r3, #0]
 8001eac:	461a      	mov	r2, r3
 8001eae:	4b06      	ldr	r3, [pc, #24]	@ (8001ec8 <HAL_IncTick+0x24>)
 8001eb0:	681b      	ldr	r3, [r3, #0]
 8001eb2:	4413      	add	r3, r2
 8001eb4:	4a04      	ldr	r2, [pc, #16]	@ (8001ec8 <HAL_IncTick+0x24>)
 8001eb6:	6013      	str	r3, [r2, #0]
}
 8001eb8:	bf00      	nop
 8001eba:	46bd      	mov	sp, r7
 8001ebc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ec0:	4770      	bx	lr
 8001ec2:	bf00      	nop
 8001ec4:	20000020 	.word	0x20000020
 8001ec8:	20001be8 	.word	0x20001be8

08001ecc <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001ecc:	b480      	push	{r7}
 8001ece:	af00      	add	r7, sp, #0
  return uwTick;
 8001ed0:	4b03      	ldr	r3, [pc, #12]	@ (8001ee0 <HAL_GetTick+0x14>)
 8001ed2:	681b      	ldr	r3, [r3, #0]
}
 8001ed4:	4618      	mov	r0, r3
 8001ed6:	46bd      	mov	sp, r7
 8001ed8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001edc:	4770      	bx	lr
 8001ede:	bf00      	nop
 8001ee0:	20001be8 	.word	0x20001be8

08001ee4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001ee4:	b580      	push	{r7, lr}
 8001ee6:	b084      	sub	sp, #16
 8001ee8:	af00      	add	r7, sp, #0
 8001eea:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8001eec:	f7ff ffee 	bl	8001ecc <HAL_GetTick>
 8001ef0:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8001ef2:	687b      	ldr	r3, [r7, #4]
 8001ef4:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001ef6:	68fb      	ldr	r3, [r7, #12]
 8001ef8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8001efc:	d005      	beq.n	8001f0a <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8001efe:	4b0a      	ldr	r3, [pc, #40]	@ (8001f28 <HAL_Delay+0x44>)
 8001f00:	781b      	ldrb	r3, [r3, #0]
 8001f02:	461a      	mov	r2, r3
 8001f04:	68fb      	ldr	r3, [r7, #12]
 8001f06:	4413      	add	r3, r2
 8001f08:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8001f0a:	bf00      	nop
 8001f0c:	f7ff ffde 	bl	8001ecc <HAL_GetTick>
 8001f10:	4602      	mov	r2, r0
 8001f12:	68bb      	ldr	r3, [r7, #8]
 8001f14:	1ad3      	subs	r3, r2, r3
 8001f16:	68fa      	ldr	r2, [r7, #12]
 8001f18:	429a      	cmp	r2, r3
 8001f1a:	d8f7      	bhi.n	8001f0c <HAL_Delay+0x28>
  {
  }
}
 8001f1c:	bf00      	nop
 8001f1e:	bf00      	nop
 8001f20:	3710      	adds	r7, #16
 8001f22:	46bd      	mov	sp, r7
 8001f24:	bd80      	pop	{r7, pc}
 8001f26:	bf00      	nop
 8001f28:	20000020 	.word	0x20000020

08001f2c <HAL_GetUIDw0>:
/**
  * @brief  Returns first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
 8001f2c:	b480      	push	{r7}
 8001f2e:	af00      	add	r7, sp, #0
  return (READ_REG(*((uint32_t *)UID_BASE)));
 8001f30:	4b03      	ldr	r3, [pc, #12]	@ (8001f40 <HAL_GetUIDw0+0x14>)
 8001f32:	681b      	ldr	r3, [r3, #0]
}
 8001f34:	4618      	mov	r0, r3
 8001f36:	46bd      	mov	sp, r7
 8001f38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f3c:	4770      	bx	lr
 8001f3e:	bf00      	nop
 8001f40:	1fff7a10 	.word	0x1fff7a10

08001f44 <HAL_GetUIDw1>:
/**
  * @brief  Returns second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
 8001f44:	b480      	push	{r7}
 8001f46:	af00      	add	r7, sp, #0
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
 8001f48:	4b03      	ldr	r3, [pc, #12]	@ (8001f58 <HAL_GetUIDw1+0x14>)
 8001f4a:	681b      	ldr	r3, [r3, #0]
}
 8001f4c:	4618      	mov	r0, r3
 8001f4e:	46bd      	mov	sp, r7
 8001f50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f54:	4770      	bx	lr
 8001f56:	bf00      	nop
 8001f58:	1fff7a14 	.word	0x1fff7a14

08001f5c <HAL_GetUIDw2>:
/**
  * @brief  Returns third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
 8001f5c:	b480      	push	{r7}
 8001f5e:	af00      	add	r7, sp, #0
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
 8001f60:	4b03      	ldr	r3, [pc, #12]	@ (8001f70 <HAL_GetUIDw2+0x14>)
 8001f62:	681b      	ldr	r3, [r3, #0]
}
 8001f64:	4618      	mov	r0, r3
 8001f66:	46bd      	mov	sp, r7
 8001f68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f6c:	4770      	bx	lr
 8001f6e:	bf00      	nop
 8001f70:	1fff7a18 	.word	0x1fff7a18

08001f74 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001f74:	b480      	push	{r7}
 8001f76:	b085      	sub	sp, #20
 8001f78:	af00      	add	r7, sp, #0
 8001f7a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8001f7c:	687b      	ldr	r3, [r7, #4]
 8001f7e:	f003 0307 	and.w	r3, r3, #7
 8001f82:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001f84:	4b0c      	ldr	r3, [pc, #48]	@ (8001fb8 <__NVIC_SetPriorityGrouping+0x44>)
 8001f86:	68db      	ldr	r3, [r3, #12]
 8001f88:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001f8a:	68ba      	ldr	r2, [r7, #8]
 8001f8c:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8001f90:	4013      	ands	r3, r2
 8001f92:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001f94:	68fb      	ldr	r3, [r7, #12]
 8001f96:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001f98:	68bb      	ldr	r3, [r7, #8]
 8001f9a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001f9c:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8001fa0:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8001fa4:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8001fa6:	4a04      	ldr	r2, [pc, #16]	@ (8001fb8 <__NVIC_SetPriorityGrouping+0x44>)
 8001fa8:	68bb      	ldr	r3, [r7, #8]
 8001faa:	60d3      	str	r3, [r2, #12]
}
 8001fac:	bf00      	nop
 8001fae:	3714      	adds	r7, #20
 8001fb0:	46bd      	mov	sp, r7
 8001fb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001fb6:	4770      	bx	lr
 8001fb8:	e000ed00 	.word	0xe000ed00

08001fbc <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001fbc:	b480      	push	{r7}
 8001fbe:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001fc0:	4b04      	ldr	r3, [pc, #16]	@ (8001fd4 <__NVIC_GetPriorityGrouping+0x18>)
 8001fc2:	68db      	ldr	r3, [r3, #12]
 8001fc4:	0a1b      	lsrs	r3, r3, #8
 8001fc6:	f003 0307 	and.w	r3, r3, #7
}
 8001fca:	4618      	mov	r0, r3
 8001fcc:	46bd      	mov	sp, r7
 8001fce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001fd2:	4770      	bx	lr
 8001fd4:	e000ed00 	.word	0xe000ed00

08001fd8 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001fd8:	b480      	push	{r7}
 8001fda:	b083      	sub	sp, #12
 8001fdc:	af00      	add	r7, sp, #0
 8001fde:	4603      	mov	r3, r0
 8001fe0:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001fe2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001fe6:	2b00      	cmp	r3, #0
 8001fe8:	db0b      	blt.n	8002002 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001fea:	79fb      	ldrb	r3, [r7, #7]
 8001fec:	f003 021f 	and.w	r2, r3, #31
 8001ff0:	4907      	ldr	r1, [pc, #28]	@ (8002010 <__NVIC_EnableIRQ+0x38>)
 8001ff2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001ff6:	095b      	lsrs	r3, r3, #5
 8001ff8:	2001      	movs	r0, #1
 8001ffa:	fa00 f202 	lsl.w	r2, r0, r2
 8001ffe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8002002:	bf00      	nop
 8002004:	370c      	adds	r7, #12
 8002006:	46bd      	mov	sp, r7
 8002008:	f85d 7b04 	ldr.w	r7, [sp], #4
 800200c:	4770      	bx	lr
 800200e:	bf00      	nop
 8002010:	e000e100 	.word	0xe000e100

08002014 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8002014:	b480      	push	{r7}
 8002016:	b083      	sub	sp, #12
 8002018:	af00      	add	r7, sp, #0
 800201a:	4603      	mov	r3, r0
 800201c:	6039      	str	r1, [r7, #0]
 800201e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8002020:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002024:	2b00      	cmp	r3, #0
 8002026:	db0a      	blt.n	800203e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002028:	683b      	ldr	r3, [r7, #0]
 800202a:	b2da      	uxtb	r2, r3
 800202c:	490c      	ldr	r1, [pc, #48]	@ (8002060 <__NVIC_SetPriority+0x4c>)
 800202e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002032:	0112      	lsls	r2, r2, #4
 8002034:	b2d2      	uxtb	r2, r2
 8002036:	440b      	add	r3, r1
 8002038:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 800203c:	e00a      	b.n	8002054 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800203e:	683b      	ldr	r3, [r7, #0]
 8002040:	b2da      	uxtb	r2, r3
 8002042:	4908      	ldr	r1, [pc, #32]	@ (8002064 <__NVIC_SetPriority+0x50>)
 8002044:	79fb      	ldrb	r3, [r7, #7]
 8002046:	f003 030f 	and.w	r3, r3, #15
 800204a:	3b04      	subs	r3, #4
 800204c:	0112      	lsls	r2, r2, #4
 800204e:	b2d2      	uxtb	r2, r2
 8002050:	440b      	add	r3, r1
 8002052:	761a      	strb	r2, [r3, #24]
}
 8002054:	bf00      	nop
 8002056:	370c      	adds	r7, #12
 8002058:	46bd      	mov	sp, r7
 800205a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800205e:	4770      	bx	lr
 8002060:	e000e100 	.word	0xe000e100
 8002064:	e000ed00 	.word	0xe000ed00

08002068 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8002068:	b480      	push	{r7}
 800206a:	b089      	sub	sp, #36	@ 0x24
 800206c:	af00      	add	r7, sp, #0
 800206e:	60f8      	str	r0, [r7, #12]
 8002070:	60b9      	str	r1, [r7, #8]
 8002072:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8002074:	68fb      	ldr	r3, [r7, #12]
 8002076:	f003 0307 	and.w	r3, r3, #7
 800207a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800207c:	69fb      	ldr	r3, [r7, #28]
 800207e:	f1c3 0307 	rsb	r3, r3, #7
 8002082:	2b04      	cmp	r3, #4
 8002084:	bf28      	it	cs
 8002086:	2304      	movcs	r3, #4
 8002088:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800208a:	69fb      	ldr	r3, [r7, #28]
 800208c:	3304      	adds	r3, #4
 800208e:	2b06      	cmp	r3, #6
 8002090:	d902      	bls.n	8002098 <NVIC_EncodePriority+0x30>
 8002092:	69fb      	ldr	r3, [r7, #28]
 8002094:	3b03      	subs	r3, #3
 8002096:	e000      	b.n	800209a <NVIC_EncodePriority+0x32>
 8002098:	2300      	movs	r3, #0
 800209a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800209c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80020a0:	69bb      	ldr	r3, [r7, #24]
 80020a2:	fa02 f303 	lsl.w	r3, r2, r3
 80020a6:	43da      	mvns	r2, r3
 80020a8:	68bb      	ldr	r3, [r7, #8]
 80020aa:	401a      	ands	r2, r3
 80020ac:	697b      	ldr	r3, [r7, #20]
 80020ae:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80020b0:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 80020b4:	697b      	ldr	r3, [r7, #20]
 80020b6:	fa01 f303 	lsl.w	r3, r1, r3
 80020ba:	43d9      	mvns	r1, r3
 80020bc:	687b      	ldr	r3, [r7, #4]
 80020be:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80020c0:	4313      	orrs	r3, r2
         );
}
 80020c2:	4618      	mov	r0, r3
 80020c4:	3724      	adds	r7, #36	@ 0x24
 80020c6:	46bd      	mov	sp, r7
 80020c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80020cc:	4770      	bx	lr
	...

080020d0 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 80020d0:	b580      	push	{r7, lr}
 80020d2:	b082      	sub	sp, #8
 80020d4:	af00      	add	r7, sp, #0
 80020d6:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80020d8:	687b      	ldr	r3, [r7, #4]
 80020da:	3b01      	subs	r3, #1
 80020dc:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 80020e0:	d301      	bcc.n	80020e6 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 80020e2:	2301      	movs	r3, #1
 80020e4:	e00f      	b.n	8002106 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80020e6:	4a0a      	ldr	r2, [pc, #40]	@ (8002110 <SysTick_Config+0x40>)
 80020e8:	687b      	ldr	r3, [r7, #4]
 80020ea:	3b01      	subs	r3, #1
 80020ec:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80020ee:	210f      	movs	r1, #15
 80020f0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80020f4:	f7ff ff8e 	bl	8002014 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80020f8:	4b05      	ldr	r3, [pc, #20]	@ (8002110 <SysTick_Config+0x40>)
 80020fa:	2200      	movs	r2, #0
 80020fc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80020fe:	4b04      	ldr	r3, [pc, #16]	@ (8002110 <SysTick_Config+0x40>)
 8002100:	2207      	movs	r2, #7
 8002102:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8002104:	2300      	movs	r3, #0
}
 8002106:	4618      	mov	r0, r3
 8002108:	3708      	adds	r7, #8
 800210a:	46bd      	mov	sp, r7
 800210c:	bd80      	pop	{r7, pc}
 800210e:	bf00      	nop
 8002110:	e000e010 	.word	0xe000e010

08002114 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8002114:	b580      	push	{r7, lr}
 8002116:	b082      	sub	sp, #8
 8002118:	af00      	add	r7, sp, #0
 800211a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800211c:	6878      	ldr	r0, [r7, #4]
 800211e:	f7ff ff29 	bl	8001f74 <__NVIC_SetPriorityGrouping>
}
 8002122:	bf00      	nop
 8002124:	3708      	adds	r7, #8
 8002126:	46bd      	mov	sp, r7
 8002128:	bd80      	pop	{r7, pc}

0800212a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800212a:	b580      	push	{r7, lr}
 800212c:	b086      	sub	sp, #24
 800212e:	af00      	add	r7, sp, #0
 8002130:	4603      	mov	r3, r0
 8002132:	60b9      	str	r1, [r7, #8]
 8002134:	607a      	str	r2, [r7, #4]
 8002136:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8002138:	2300      	movs	r3, #0
 800213a:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800213c:	f7ff ff3e 	bl	8001fbc <__NVIC_GetPriorityGrouping>
 8002140:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8002142:	687a      	ldr	r2, [r7, #4]
 8002144:	68b9      	ldr	r1, [r7, #8]
 8002146:	6978      	ldr	r0, [r7, #20]
 8002148:	f7ff ff8e 	bl	8002068 <NVIC_EncodePriority>
 800214c:	4602      	mov	r2, r0
 800214e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8002152:	4611      	mov	r1, r2
 8002154:	4618      	mov	r0, r3
 8002156:	f7ff ff5d 	bl	8002014 <__NVIC_SetPriority>
}
 800215a:	bf00      	nop
 800215c:	3718      	adds	r7, #24
 800215e:	46bd      	mov	sp, r7
 8002160:	bd80      	pop	{r7, pc}

08002162 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8002162:	b580      	push	{r7, lr}
 8002164:	b082      	sub	sp, #8
 8002166:	af00      	add	r7, sp, #0
 8002168:	4603      	mov	r3, r0
 800216a:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800216c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002170:	4618      	mov	r0, r3
 8002172:	f7ff ff31 	bl	8001fd8 <__NVIC_EnableIRQ>
}
 8002176:	bf00      	nop
 8002178:	3708      	adds	r7, #8
 800217a:	46bd      	mov	sp, r7
 800217c:	bd80      	pop	{r7, pc}

0800217e <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800217e:	b580      	push	{r7, lr}
 8002180:	b082      	sub	sp, #8
 8002182:	af00      	add	r7, sp, #0
 8002184:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8002186:	6878      	ldr	r0, [r7, #4]
 8002188:	f7ff ffa2 	bl	80020d0 <SysTick_Config>
 800218c:	4603      	mov	r3, r0
}
 800218e:	4618      	mov	r0, r3
 8002190:	3708      	adds	r7, #8
 8002192:	46bd      	mov	sp, r7
 8002194:	bd80      	pop	{r7, pc}

08002196 <HAL_CRC_Init>:
  *         parameters in the CRC_InitTypeDef and create the associated handle.
  * @param  hcrc CRC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 8002196:	b580      	push	{r7, lr}
 8002198:	b082      	sub	sp, #8
 800219a:	af00      	add	r7, sp, #0
 800219c:	6078      	str	r0, [r7, #4]
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 800219e:	687b      	ldr	r3, [r7, #4]
 80021a0:	2b00      	cmp	r3, #0
 80021a2:	d101      	bne.n	80021a8 <HAL_CRC_Init+0x12>
  {
    return HAL_ERROR;
 80021a4:	2301      	movs	r3, #1
 80021a6:	e00e      	b.n	80021c6 <HAL_CRC_Init+0x30>
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 80021a8:	687b      	ldr	r3, [r7, #4]
 80021aa:	795b      	ldrb	r3, [r3, #5]
 80021ac:	b2db      	uxtb	r3, r3
 80021ae:	2b00      	cmp	r3, #0
 80021b0:	d105      	bne.n	80021be <HAL_CRC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 80021b2:	687b      	ldr	r3, [r7, #4]
 80021b4:	2200      	movs	r2, #0
 80021b6:	711a      	strb	r2, [r3, #4]
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 80021b8:	6878      	ldr	r0, [r7, #4]
 80021ba:	f7ff fb99 	bl	80018f0 <HAL_CRC_MspInit>
  }

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 80021be:	687b      	ldr	r3, [r7, #4]
 80021c0:	2201      	movs	r2, #1
 80021c2:	715a      	strb	r2, [r3, #5]

  /* Return function status */
  return HAL_OK;
 80021c4:	2300      	movs	r3, #0
}
 80021c6:	4618      	mov	r0, r3
 80021c8:	3708      	adds	r7, #8
 80021ca:	46bd      	mov	sp, r7
 80021cc:	bd80      	pop	{r7, pc}
	...

080021d0 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80021d0:	b480      	push	{r7}
 80021d2:	b089      	sub	sp, #36	@ 0x24
 80021d4:	af00      	add	r7, sp, #0
 80021d6:	6078      	str	r0, [r7, #4]
 80021d8:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 80021da:	2300      	movs	r3, #0
 80021dc:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 80021de:	2300      	movs	r3, #0
 80021e0:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 80021e2:	2300      	movs	r3, #0
 80021e4:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 80021e6:	2300      	movs	r3, #0
 80021e8:	61fb      	str	r3, [r7, #28]
 80021ea:	e16b      	b.n	80024c4 <HAL_GPIO_Init+0x2f4>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 80021ec:	2201      	movs	r2, #1
 80021ee:	69fb      	ldr	r3, [r7, #28]
 80021f0:	fa02 f303 	lsl.w	r3, r2, r3
 80021f4:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80021f6:	683b      	ldr	r3, [r7, #0]
 80021f8:	681b      	ldr	r3, [r3, #0]
 80021fa:	697a      	ldr	r2, [r7, #20]
 80021fc:	4013      	ands	r3, r2
 80021fe:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8002200:	693a      	ldr	r2, [r7, #16]
 8002202:	697b      	ldr	r3, [r7, #20]
 8002204:	429a      	cmp	r2, r3
 8002206:	f040 815a 	bne.w	80024be <HAL_GPIO_Init+0x2ee>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 800220a:	683b      	ldr	r3, [r7, #0]
 800220c:	685b      	ldr	r3, [r3, #4]
 800220e:	f003 0303 	and.w	r3, r3, #3
 8002212:	2b01      	cmp	r3, #1
 8002214:	d005      	beq.n	8002222 <HAL_GPIO_Init+0x52>
          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8002216:	683b      	ldr	r3, [r7, #0]
 8002218:	685b      	ldr	r3, [r3, #4]
 800221a:	f003 0303 	and.w	r3, r3, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 800221e:	2b02      	cmp	r3, #2
 8002220:	d130      	bne.n	8002284 <HAL_GPIO_Init+0xb4>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8002222:	687b      	ldr	r3, [r7, #4]
 8002224:	689b      	ldr	r3, [r3, #8]
 8002226:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8002228:	69fb      	ldr	r3, [r7, #28]
 800222a:	005b      	lsls	r3, r3, #1
 800222c:	2203      	movs	r2, #3
 800222e:	fa02 f303 	lsl.w	r3, r2, r3
 8002232:	43db      	mvns	r3, r3
 8002234:	69ba      	ldr	r2, [r7, #24]
 8002236:	4013      	ands	r3, r2
 8002238:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800223a:	683b      	ldr	r3, [r7, #0]
 800223c:	68da      	ldr	r2, [r3, #12]
 800223e:	69fb      	ldr	r3, [r7, #28]
 8002240:	005b      	lsls	r3, r3, #1
 8002242:	fa02 f303 	lsl.w	r3, r2, r3
 8002246:	69ba      	ldr	r2, [r7, #24]
 8002248:	4313      	orrs	r3, r2
 800224a:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 800224c:	687b      	ldr	r3, [r7, #4]
 800224e:	69ba      	ldr	r2, [r7, #24]
 8002250:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8002252:	687b      	ldr	r3, [r7, #4]
 8002254:	685b      	ldr	r3, [r3, #4]
 8002256:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8002258:	2201      	movs	r2, #1
 800225a:	69fb      	ldr	r3, [r7, #28]
 800225c:	fa02 f303 	lsl.w	r3, r2, r3
 8002260:	43db      	mvns	r3, r3
 8002262:	69ba      	ldr	r2, [r7, #24]
 8002264:	4013      	ands	r3, r2
 8002266:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8002268:	683b      	ldr	r3, [r7, #0]
 800226a:	685b      	ldr	r3, [r3, #4]
 800226c:	091b      	lsrs	r3, r3, #4
 800226e:	f003 0201 	and.w	r2, r3, #1
 8002272:	69fb      	ldr	r3, [r7, #28]
 8002274:	fa02 f303 	lsl.w	r3, r2, r3
 8002278:	69ba      	ldr	r2, [r7, #24]
 800227a:	4313      	orrs	r3, r2
 800227c:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 800227e:	687b      	ldr	r3, [r7, #4]
 8002280:	69ba      	ldr	r2, [r7, #24]
 8002282:	605a      	str	r2, [r3, #4]
       }

      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8002284:	683b      	ldr	r3, [r7, #0]
 8002286:	685b      	ldr	r3, [r3, #4]
 8002288:	f003 0303 	and.w	r3, r3, #3
 800228c:	2b03      	cmp	r3, #3
 800228e:	d017      	beq.n	80022c0 <HAL_GPIO_Init+0xf0>
      {
        /* Check the parameters */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
        
        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 8002290:	687b      	ldr	r3, [r7, #4]
 8002292:	68db      	ldr	r3, [r3, #12]
 8002294:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8002296:	69fb      	ldr	r3, [r7, #28]
 8002298:	005b      	lsls	r3, r3, #1
 800229a:	2203      	movs	r2, #3
 800229c:	fa02 f303 	lsl.w	r3, r2, r3
 80022a0:	43db      	mvns	r3, r3
 80022a2:	69ba      	ldr	r2, [r7, #24]
 80022a4:	4013      	ands	r3, r2
 80022a6:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80022a8:	683b      	ldr	r3, [r7, #0]
 80022aa:	689a      	ldr	r2, [r3, #8]
 80022ac:	69fb      	ldr	r3, [r7, #28]
 80022ae:	005b      	lsls	r3, r3, #1
 80022b0:	fa02 f303 	lsl.w	r3, r2, r3
 80022b4:	69ba      	ldr	r2, [r7, #24]
 80022b6:	4313      	orrs	r3, r2
 80022b8:	61bb      	str	r3, [r7, #24]
        GPIOx->PUPDR = temp;
 80022ba:	687b      	ldr	r3, [r7, #4]
 80022bc:	69ba      	ldr	r2, [r7, #24]
 80022be:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80022c0:	683b      	ldr	r3, [r7, #0]
 80022c2:	685b      	ldr	r3, [r3, #4]
 80022c4:	f003 0303 	and.w	r3, r3, #3
 80022c8:	2b02      	cmp	r3, #2
 80022ca:	d123      	bne.n	8002314 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 80022cc:	69fb      	ldr	r3, [r7, #28]
 80022ce:	08da      	lsrs	r2, r3, #3
 80022d0:	687b      	ldr	r3, [r7, #4]
 80022d2:	3208      	adds	r2, #8
 80022d4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80022d8:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 80022da:	69fb      	ldr	r3, [r7, #28]
 80022dc:	f003 0307 	and.w	r3, r3, #7
 80022e0:	009b      	lsls	r3, r3, #2
 80022e2:	220f      	movs	r2, #15
 80022e4:	fa02 f303 	lsl.w	r3, r2, r3
 80022e8:	43db      	mvns	r3, r3
 80022ea:	69ba      	ldr	r2, [r7, #24]
 80022ec:	4013      	ands	r3, r2
 80022ee:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 80022f0:	683b      	ldr	r3, [r7, #0]
 80022f2:	691a      	ldr	r2, [r3, #16]
 80022f4:	69fb      	ldr	r3, [r7, #28]
 80022f6:	f003 0307 	and.w	r3, r3, #7
 80022fa:	009b      	lsls	r3, r3, #2
 80022fc:	fa02 f303 	lsl.w	r3, r2, r3
 8002300:	69ba      	ldr	r2, [r7, #24]
 8002302:	4313      	orrs	r3, r2
 8002304:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8002306:	69fb      	ldr	r3, [r7, #28]
 8002308:	08da      	lsrs	r2, r3, #3
 800230a:	687b      	ldr	r3, [r7, #4]
 800230c:	3208      	adds	r2, #8
 800230e:	69b9      	ldr	r1, [r7, #24]
 8002310:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8002314:	687b      	ldr	r3, [r7, #4]
 8002316:	681b      	ldr	r3, [r3, #0]
 8002318:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800231a:	69fb      	ldr	r3, [r7, #28]
 800231c:	005b      	lsls	r3, r3, #1
 800231e:	2203      	movs	r2, #3
 8002320:	fa02 f303 	lsl.w	r3, r2, r3
 8002324:	43db      	mvns	r3, r3
 8002326:	69ba      	ldr	r2, [r7, #24]
 8002328:	4013      	ands	r3, r2
 800232a:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800232c:	683b      	ldr	r3, [r7, #0]
 800232e:	685b      	ldr	r3, [r3, #4]
 8002330:	f003 0203 	and.w	r2, r3, #3
 8002334:	69fb      	ldr	r3, [r7, #28]
 8002336:	005b      	lsls	r3, r3, #1
 8002338:	fa02 f303 	lsl.w	r3, r2, r3
 800233c:	69ba      	ldr	r2, [r7, #24]
 800233e:	4313      	orrs	r3, r2
 8002340:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8002342:	687b      	ldr	r3, [r7, #4]
 8002344:	69ba      	ldr	r2, [r7, #24]
 8002346:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8002348:	683b      	ldr	r3, [r7, #0]
 800234a:	685b      	ldr	r3, [r3, #4]
 800234c:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8002350:	2b00      	cmp	r3, #0
 8002352:	f000 80b4 	beq.w	80024be <HAL_GPIO_Init+0x2ee>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002356:	2300      	movs	r3, #0
 8002358:	60fb      	str	r3, [r7, #12]
 800235a:	4b60      	ldr	r3, [pc, #384]	@ (80024dc <HAL_GPIO_Init+0x30c>)
 800235c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800235e:	4a5f      	ldr	r2, [pc, #380]	@ (80024dc <HAL_GPIO_Init+0x30c>)
 8002360:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8002364:	6453      	str	r3, [r2, #68]	@ 0x44
 8002366:	4b5d      	ldr	r3, [pc, #372]	@ (80024dc <HAL_GPIO_Init+0x30c>)
 8002368:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800236a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800236e:	60fb      	str	r3, [r7, #12]
 8002370:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8002372:	4a5b      	ldr	r2, [pc, #364]	@ (80024e0 <HAL_GPIO_Init+0x310>)
 8002374:	69fb      	ldr	r3, [r7, #28]
 8002376:	089b      	lsrs	r3, r3, #2
 8002378:	3302      	adds	r3, #2
 800237a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800237e:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8002380:	69fb      	ldr	r3, [r7, #28]
 8002382:	f003 0303 	and.w	r3, r3, #3
 8002386:	009b      	lsls	r3, r3, #2
 8002388:	220f      	movs	r2, #15
 800238a:	fa02 f303 	lsl.w	r3, r2, r3
 800238e:	43db      	mvns	r3, r3
 8002390:	69ba      	ldr	r2, [r7, #24]
 8002392:	4013      	ands	r3, r2
 8002394:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8002396:	687b      	ldr	r3, [r7, #4]
 8002398:	4a52      	ldr	r2, [pc, #328]	@ (80024e4 <HAL_GPIO_Init+0x314>)
 800239a:	4293      	cmp	r3, r2
 800239c:	d02b      	beq.n	80023f6 <HAL_GPIO_Init+0x226>
 800239e:	687b      	ldr	r3, [r7, #4]
 80023a0:	4a51      	ldr	r2, [pc, #324]	@ (80024e8 <HAL_GPIO_Init+0x318>)
 80023a2:	4293      	cmp	r3, r2
 80023a4:	d025      	beq.n	80023f2 <HAL_GPIO_Init+0x222>
 80023a6:	687b      	ldr	r3, [r7, #4]
 80023a8:	4a50      	ldr	r2, [pc, #320]	@ (80024ec <HAL_GPIO_Init+0x31c>)
 80023aa:	4293      	cmp	r3, r2
 80023ac:	d01f      	beq.n	80023ee <HAL_GPIO_Init+0x21e>
 80023ae:	687b      	ldr	r3, [r7, #4]
 80023b0:	4a4f      	ldr	r2, [pc, #316]	@ (80024f0 <HAL_GPIO_Init+0x320>)
 80023b2:	4293      	cmp	r3, r2
 80023b4:	d019      	beq.n	80023ea <HAL_GPIO_Init+0x21a>
 80023b6:	687b      	ldr	r3, [r7, #4]
 80023b8:	4a4e      	ldr	r2, [pc, #312]	@ (80024f4 <HAL_GPIO_Init+0x324>)
 80023ba:	4293      	cmp	r3, r2
 80023bc:	d013      	beq.n	80023e6 <HAL_GPIO_Init+0x216>
 80023be:	687b      	ldr	r3, [r7, #4]
 80023c0:	4a4d      	ldr	r2, [pc, #308]	@ (80024f8 <HAL_GPIO_Init+0x328>)
 80023c2:	4293      	cmp	r3, r2
 80023c4:	d00d      	beq.n	80023e2 <HAL_GPIO_Init+0x212>
 80023c6:	687b      	ldr	r3, [r7, #4]
 80023c8:	4a4c      	ldr	r2, [pc, #304]	@ (80024fc <HAL_GPIO_Init+0x32c>)
 80023ca:	4293      	cmp	r3, r2
 80023cc:	d007      	beq.n	80023de <HAL_GPIO_Init+0x20e>
 80023ce:	687b      	ldr	r3, [r7, #4]
 80023d0:	4a4b      	ldr	r2, [pc, #300]	@ (8002500 <HAL_GPIO_Init+0x330>)
 80023d2:	4293      	cmp	r3, r2
 80023d4:	d101      	bne.n	80023da <HAL_GPIO_Init+0x20a>
 80023d6:	2307      	movs	r3, #7
 80023d8:	e00e      	b.n	80023f8 <HAL_GPIO_Init+0x228>
 80023da:	2308      	movs	r3, #8
 80023dc:	e00c      	b.n	80023f8 <HAL_GPIO_Init+0x228>
 80023de:	2306      	movs	r3, #6
 80023e0:	e00a      	b.n	80023f8 <HAL_GPIO_Init+0x228>
 80023e2:	2305      	movs	r3, #5
 80023e4:	e008      	b.n	80023f8 <HAL_GPIO_Init+0x228>
 80023e6:	2304      	movs	r3, #4
 80023e8:	e006      	b.n	80023f8 <HAL_GPIO_Init+0x228>
 80023ea:	2303      	movs	r3, #3
 80023ec:	e004      	b.n	80023f8 <HAL_GPIO_Init+0x228>
 80023ee:	2302      	movs	r3, #2
 80023f0:	e002      	b.n	80023f8 <HAL_GPIO_Init+0x228>
 80023f2:	2301      	movs	r3, #1
 80023f4:	e000      	b.n	80023f8 <HAL_GPIO_Init+0x228>
 80023f6:	2300      	movs	r3, #0
 80023f8:	69fa      	ldr	r2, [r7, #28]
 80023fa:	f002 0203 	and.w	r2, r2, #3
 80023fe:	0092      	lsls	r2, r2, #2
 8002400:	4093      	lsls	r3, r2
 8002402:	69ba      	ldr	r2, [r7, #24]
 8002404:	4313      	orrs	r3, r2
 8002406:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8002408:	4935      	ldr	r1, [pc, #212]	@ (80024e0 <HAL_GPIO_Init+0x310>)
 800240a:	69fb      	ldr	r3, [r7, #28]
 800240c:	089b      	lsrs	r3, r3, #2
 800240e:	3302      	adds	r3, #2
 8002410:	69ba      	ldr	r2, [r7, #24]
 8002412:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8002416:	4b3b      	ldr	r3, [pc, #236]	@ (8002504 <HAL_GPIO_Init+0x334>)
 8002418:	689b      	ldr	r3, [r3, #8]
 800241a:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800241c:	693b      	ldr	r3, [r7, #16]
 800241e:	43db      	mvns	r3, r3
 8002420:	69ba      	ldr	r2, [r7, #24]
 8002422:	4013      	ands	r3, r2
 8002424:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8002426:	683b      	ldr	r3, [r7, #0]
 8002428:	685b      	ldr	r3, [r3, #4]
 800242a:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 800242e:	2b00      	cmp	r3, #0
 8002430:	d003      	beq.n	800243a <HAL_GPIO_Init+0x26a>
        {
          temp |= iocurrent;
 8002432:	69ba      	ldr	r2, [r7, #24]
 8002434:	693b      	ldr	r3, [r7, #16]
 8002436:	4313      	orrs	r3, r2
 8002438:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 800243a:	4a32      	ldr	r2, [pc, #200]	@ (8002504 <HAL_GPIO_Init+0x334>)
 800243c:	69bb      	ldr	r3, [r7, #24]
 800243e:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 8002440:	4b30      	ldr	r3, [pc, #192]	@ (8002504 <HAL_GPIO_Init+0x334>)
 8002442:	68db      	ldr	r3, [r3, #12]
 8002444:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8002446:	693b      	ldr	r3, [r7, #16]
 8002448:	43db      	mvns	r3, r3
 800244a:	69ba      	ldr	r2, [r7, #24]
 800244c:	4013      	ands	r3, r2
 800244e:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8002450:	683b      	ldr	r3, [r7, #0]
 8002452:	685b      	ldr	r3, [r3, #4]
 8002454:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8002458:	2b00      	cmp	r3, #0
 800245a:	d003      	beq.n	8002464 <HAL_GPIO_Init+0x294>
        {
          temp |= iocurrent;
 800245c:	69ba      	ldr	r2, [r7, #24]
 800245e:	693b      	ldr	r3, [r7, #16]
 8002460:	4313      	orrs	r3, r2
 8002462:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 8002464:	4a27      	ldr	r2, [pc, #156]	@ (8002504 <HAL_GPIO_Init+0x334>)
 8002466:	69bb      	ldr	r3, [r7, #24]
 8002468:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 800246a:	4b26      	ldr	r3, [pc, #152]	@ (8002504 <HAL_GPIO_Init+0x334>)
 800246c:	685b      	ldr	r3, [r3, #4]
 800246e:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8002470:	693b      	ldr	r3, [r7, #16]
 8002472:	43db      	mvns	r3, r3
 8002474:	69ba      	ldr	r2, [r7, #24]
 8002476:	4013      	ands	r3, r2
 8002478:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800247a:	683b      	ldr	r3, [r7, #0]
 800247c:	685b      	ldr	r3, [r3, #4]
 800247e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8002482:	2b00      	cmp	r3, #0
 8002484:	d003      	beq.n	800248e <HAL_GPIO_Init+0x2be>
        {
          temp |= iocurrent;
 8002486:	69ba      	ldr	r2, [r7, #24]
 8002488:	693b      	ldr	r3, [r7, #16]
 800248a:	4313      	orrs	r3, r2
 800248c:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 800248e:	4a1d      	ldr	r2, [pc, #116]	@ (8002504 <HAL_GPIO_Init+0x334>)
 8002490:	69bb      	ldr	r3, [r7, #24]
 8002492:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8002494:	4b1b      	ldr	r3, [pc, #108]	@ (8002504 <HAL_GPIO_Init+0x334>)
 8002496:	681b      	ldr	r3, [r3, #0]
 8002498:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800249a:	693b      	ldr	r3, [r7, #16]
 800249c:	43db      	mvns	r3, r3
 800249e:	69ba      	ldr	r2, [r7, #24]
 80024a0:	4013      	ands	r3, r2
 80024a2:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 80024a4:	683b      	ldr	r3, [r7, #0]
 80024a6:	685b      	ldr	r3, [r3, #4]
 80024a8:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80024ac:	2b00      	cmp	r3, #0
 80024ae:	d003      	beq.n	80024b8 <HAL_GPIO_Init+0x2e8>
        {
          temp |= iocurrent;
 80024b0:	69ba      	ldr	r2, [r7, #24]
 80024b2:	693b      	ldr	r3, [r7, #16]
 80024b4:	4313      	orrs	r3, r2
 80024b6:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 80024b8:	4a12      	ldr	r2, [pc, #72]	@ (8002504 <HAL_GPIO_Init+0x334>)
 80024ba:	69bb      	ldr	r3, [r7, #24]
 80024bc:	6013      	str	r3, [r2, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 80024be:	69fb      	ldr	r3, [r7, #28]
 80024c0:	3301      	adds	r3, #1
 80024c2:	61fb      	str	r3, [r7, #28]
 80024c4:	69fb      	ldr	r3, [r7, #28]
 80024c6:	2b0f      	cmp	r3, #15
 80024c8:	f67f ae90 	bls.w	80021ec <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 80024cc:	bf00      	nop
 80024ce:	bf00      	nop
 80024d0:	3724      	adds	r7, #36	@ 0x24
 80024d2:	46bd      	mov	sp, r7
 80024d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024d8:	4770      	bx	lr
 80024da:	bf00      	nop
 80024dc:	40023800 	.word	0x40023800
 80024e0:	40013800 	.word	0x40013800
 80024e4:	40020000 	.word	0x40020000
 80024e8:	40020400 	.word	0x40020400
 80024ec:	40020800 	.word	0x40020800
 80024f0:	40020c00 	.word	0x40020c00
 80024f4:	40021000 	.word	0x40021000
 80024f8:	40021400 	.word	0x40021400
 80024fc:	40021800 	.word	0x40021800
 8002500:	40021c00 	.word	0x40021c00
 8002504:	40013c00 	.word	0x40013c00

08002508 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002508:	b480      	push	{r7}
 800250a:	b085      	sub	sp, #20
 800250c:	af00      	add	r7, sp, #0
 800250e:	6078      	str	r0, [r7, #4]
 8002510:	460b      	mov	r3, r1
 8002512:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8002514:	687b      	ldr	r3, [r7, #4]
 8002516:	691a      	ldr	r2, [r3, #16]
 8002518:	887b      	ldrh	r3, [r7, #2]
 800251a:	4013      	ands	r3, r2
 800251c:	2b00      	cmp	r3, #0
 800251e:	d002      	beq.n	8002526 <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 8002520:	2301      	movs	r3, #1
 8002522:	73fb      	strb	r3, [r7, #15]
 8002524:	e001      	b.n	800252a <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 8002526:	2300      	movs	r3, #0
 8002528:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800252a:	7bfb      	ldrb	r3, [r7, #15]
}
 800252c:	4618      	mov	r0, r3
 800252e:	3714      	adds	r7, #20
 8002530:	46bd      	mov	sp, r7
 8002532:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002536:	4770      	bx	lr

08002538 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8002538:	b480      	push	{r7}
 800253a:	b083      	sub	sp, #12
 800253c:	af00      	add	r7, sp, #0
 800253e:	6078      	str	r0, [r7, #4]
 8002540:	460b      	mov	r3, r1
 8002542:	807b      	strh	r3, [r7, #2]
 8002544:	4613      	mov	r3, r2
 8002546:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8002548:	787b      	ldrb	r3, [r7, #1]
 800254a:	2b00      	cmp	r3, #0
 800254c:	d003      	beq.n	8002556 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 800254e:	887a      	ldrh	r2, [r7, #2]
 8002550:	687b      	ldr	r3, [r7, #4]
 8002552:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 8002554:	e003      	b.n	800255e <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8002556:	887b      	ldrh	r3, [r7, #2]
 8002558:	041a      	lsls	r2, r3, #16
 800255a:	687b      	ldr	r3, [r7, #4]
 800255c:	619a      	str	r2, [r3, #24]
}
 800255e:	bf00      	nop
 8002560:	370c      	adds	r7, #12
 8002562:	46bd      	mov	sp, r7
 8002564:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002568:	4770      	bx	lr
	...

0800256c <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800256c:	b580      	push	{r7, lr}
 800256e:	b084      	sub	sp, #16
 8002570:	af00      	add	r7, sp, #0
 8002572:	6078      	str	r0, [r7, #4]
  uint32_t freqrange;
  uint32_t pclk1;

  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8002574:	687b      	ldr	r3, [r7, #4]
 8002576:	2b00      	cmp	r3, #0
 8002578:	d101      	bne.n	800257e <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800257a:	2301      	movs	r3, #1
 800257c:	e12b      	b.n	80027d6 <HAL_I2C_Init+0x26a>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800257e:	687b      	ldr	r3, [r7, #4]
 8002580:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8002584:	b2db      	uxtb	r3, r3
 8002586:	2b00      	cmp	r3, #0
 8002588:	d106      	bne.n	8002598 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800258a:	687b      	ldr	r3, [r7, #4]
 800258c:	2200      	movs	r2, #0
 800258e:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 8002592:	6878      	ldr	r0, [r7, #4]
 8002594:	f7ff f9ce 	bl	8001934 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 8002598:	687b      	ldr	r3, [r7, #4]
 800259a:	2224      	movs	r2, #36	@ 0x24
 800259c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 80025a0:	687b      	ldr	r3, [r7, #4]
 80025a2:	681b      	ldr	r3, [r3, #0]
 80025a4:	681a      	ldr	r2, [r3, #0]
 80025a6:	687b      	ldr	r3, [r7, #4]
 80025a8:	681b      	ldr	r3, [r3, #0]
 80025aa:	f022 0201 	bic.w	r2, r2, #1
 80025ae:	601a      	str	r2, [r3, #0]

  /*Reset I2C*/
  hi2c->Instance->CR1 |= I2C_CR1_SWRST;
 80025b0:	687b      	ldr	r3, [r7, #4]
 80025b2:	681b      	ldr	r3, [r3, #0]
 80025b4:	681a      	ldr	r2, [r3, #0]
 80025b6:	687b      	ldr	r3, [r7, #4]
 80025b8:	681b      	ldr	r3, [r3, #0]
 80025ba:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 80025be:	601a      	str	r2, [r3, #0]
  hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
 80025c0:	687b      	ldr	r3, [r7, #4]
 80025c2:	681b      	ldr	r3, [r3, #0]
 80025c4:	681a      	ldr	r2, [r3, #0]
 80025c6:	687b      	ldr	r3, [r7, #4]
 80025c8:	681b      	ldr	r3, [r3, #0]
 80025ca:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 80025ce:	601a      	str	r2, [r3, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();
 80025d0:	f002 fc72 	bl	8004eb8 <HAL_RCC_GetPCLK1Freq>
 80025d4:	60f8      	str	r0, [r7, #12]

  /* Check the minimum allowed PCLK1 frequency */
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 80025d6:	687b      	ldr	r3, [r7, #4]
 80025d8:	685b      	ldr	r3, [r3, #4]
 80025da:	4a81      	ldr	r2, [pc, #516]	@ (80027e0 <HAL_I2C_Init+0x274>)
 80025dc:	4293      	cmp	r3, r2
 80025de:	d807      	bhi.n	80025f0 <HAL_I2C_Init+0x84>
 80025e0:	68fb      	ldr	r3, [r7, #12]
 80025e2:	4a80      	ldr	r2, [pc, #512]	@ (80027e4 <HAL_I2C_Init+0x278>)
 80025e4:	4293      	cmp	r3, r2
 80025e6:	bf94      	ite	ls
 80025e8:	2301      	movls	r3, #1
 80025ea:	2300      	movhi	r3, #0
 80025ec:	b2db      	uxtb	r3, r3
 80025ee:	e006      	b.n	80025fe <HAL_I2C_Init+0x92>
 80025f0:	68fb      	ldr	r3, [r7, #12]
 80025f2:	4a7d      	ldr	r2, [pc, #500]	@ (80027e8 <HAL_I2C_Init+0x27c>)
 80025f4:	4293      	cmp	r3, r2
 80025f6:	bf94      	ite	ls
 80025f8:	2301      	movls	r3, #1
 80025fa:	2300      	movhi	r3, #0
 80025fc:	b2db      	uxtb	r3, r3
 80025fe:	2b00      	cmp	r3, #0
 8002600:	d001      	beq.n	8002606 <HAL_I2C_Init+0x9a>
  {
    return HAL_ERROR;
 8002602:	2301      	movs	r3, #1
 8002604:	e0e7      	b.n	80027d6 <HAL_I2C_Init+0x26a>
  }

  /* Calculate frequency range */
  freqrange = I2C_FREQRANGE(pclk1);
 8002606:	68fb      	ldr	r3, [r7, #12]
 8002608:	4a78      	ldr	r2, [pc, #480]	@ (80027ec <HAL_I2C_Init+0x280>)
 800260a:	fba2 2303 	umull	r2, r3, r2, r3
 800260e:	0c9b      	lsrs	r3, r3, #18
 8002610:	60bb      	str	r3, [r7, #8]

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 8002612:	687b      	ldr	r3, [r7, #4]
 8002614:	681b      	ldr	r3, [r3, #0]
 8002616:	685b      	ldr	r3, [r3, #4]
 8002618:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
 800261c:	687b      	ldr	r3, [r7, #4]
 800261e:	681b      	ldr	r3, [r3, #0]
 8002620:	68ba      	ldr	r2, [r7, #8]
 8002622:	430a      	orrs	r2, r1
 8002624:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 8002626:	687b      	ldr	r3, [r7, #4]
 8002628:	681b      	ldr	r3, [r3, #0]
 800262a:	6a1b      	ldr	r3, [r3, #32]
 800262c:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
 8002630:	687b      	ldr	r3, [r7, #4]
 8002632:	685b      	ldr	r3, [r3, #4]
 8002634:	4a6a      	ldr	r2, [pc, #424]	@ (80027e0 <HAL_I2C_Init+0x274>)
 8002636:	4293      	cmp	r3, r2
 8002638:	d802      	bhi.n	8002640 <HAL_I2C_Init+0xd4>
 800263a:	68bb      	ldr	r3, [r7, #8]
 800263c:	3301      	adds	r3, #1
 800263e:	e009      	b.n	8002654 <HAL_I2C_Init+0xe8>
 8002640:	68bb      	ldr	r3, [r7, #8]
 8002642:	f44f 7296 	mov.w	r2, #300	@ 0x12c
 8002646:	fb02 f303 	mul.w	r3, r2, r3
 800264a:	4a69      	ldr	r2, [pc, #420]	@ (80027f0 <HAL_I2C_Init+0x284>)
 800264c:	fba2 2303 	umull	r2, r3, r2, r3
 8002650:	099b      	lsrs	r3, r3, #6
 8002652:	3301      	adds	r3, #1
 8002654:	687a      	ldr	r2, [r7, #4]
 8002656:	6812      	ldr	r2, [r2, #0]
 8002658:	430b      	orrs	r3, r1
 800265a:	6213      	str	r3, [r2, #32]

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 800265c:	687b      	ldr	r3, [r7, #4]
 800265e:	681b      	ldr	r3, [r3, #0]
 8002660:	69db      	ldr	r3, [r3, #28]
 8002662:	f423 424f 	bic.w	r2, r3, #52992	@ 0xcf00
 8002666:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 800266a:	687b      	ldr	r3, [r7, #4]
 800266c:	685b      	ldr	r3, [r3, #4]
 800266e:	495c      	ldr	r1, [pc, #368]	@ (80027e0 <HAL_I2C_Init+0x274>)
 8002670:	428b      	cmp	r3, r1
 8002672:	d819      	bhi.n	80026a8 <HAL_I2C_Init+0x13c>
 8002674:	68fb      	ldr	r3, [r7, #12]
 8002676:	1e59      	subs	r1, r3, #1
 8002678:	687b      	ldr	r3, [r7, #4]
 800267a:	685b      	ldr	r3, [r3, #4]
 800267c:	005b      	lsls	r3, r3, #1
 800267e:	fbb1 f3f3 	udiv	r3, r1, r3
 8002682:	1c59      	adds	r1, r3, #1
 8002684:	f640 73fc 	movw	r3, #4092	@ 0xffc
 8002688:	400b      	ands	r3, r1
 800268a:	2b00      	cmp	r3, #0
 800268c:	d00a      	beq.n	80026a4 <HAL_I2C_Init+0x138>
 800268e:	68fb      	ldr	r3, [r7, #12]
 8002690:	1e59      	subs	r1, r3, #1
 8002692:	687b      	ldr	r3, [r7, #4]
 8002694:	685b      	ldr	r3, [r3, #4]
 8002696:	005b      	lsls	r3, r3, #1
 8002698:	fbb1 f3f3 	udiv	r3, r1, r3
 800269c:	3301      	adds	r3, #1
 800269e:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80026a2:	e051      	b.n	8002748 <HAL_I2C_Init+0x1dc>
 80026a4:	2304      	movs	r3, #4
 80026a6:	e04f      	b.n	8002748 <HAL_I2C_Init+0x1dc>
 80026a8:	687b      	ldr	r3, [r7, #4]
 80026aa:	689b      	ldr	r3, [r3, #8]
 80026ac:	2b00      	cmp	r3, #0
 80026ae:	d111      	bne.n	80026d4 <HAL_I2C_Init+0x168>
 80026b0:	68fb      	ldr	r3, [r7, #12]
 80026b2:	1e58      	subs	r0, r3, #1
 80026b4:	687b      	ldr	r3, [r7, #4]
 80026b6:	6859      	ldr	r1, [r3, #4]
 80026b8:	460b      	mov	r3, r1
 80026ba:	005b      	lsls	r3, r3, #1
 80026bc:	440b      	add	r3, r1
 80026be:	fbb0 f3f3 	udiv	r3, r0, r3
 80026c2:	3301      	adds	r3, #1
 80026c4:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80026c8:	2b00      	cmp	r3, #0
 80026ca:	bf0c      	ite	eq
 80026cc:	2301      	moveq	r3, #1
 80026ce:	2300      	movne	r3, #0
 80026d0:	b2db      	uxtb	r3, r3
 80026d2:	e012      	b.n	80026fa <HAL_I2C_Init+0x18e>
 80026d4:	68fb      	ldr	r3, [r7, #12]
 80026d6:	1e58      	subs	r0, r3, #1
 80026d8:	687b      	ldr	r3, [r7, #4]
 80026da:	6859      	ldr	r1, [r3, #4]
 80026dc:	460b      	mov	r3, r1
 80026de:	009b      	lsls	r3, r3, #2
 80026e0:	440b      	add	r3, r1
 80026e2:	0099      	lsls	r1, r3, #2
 80026e4:	440b      	add	r3, r1
 80026e6:	fbb0 f3f3 	udiv	r3, r0, r3
 80026ea:	3301      	adds	r3, #1
 80026ec:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80026f0:	2b00      	cmp	r3, #0
 80026f2:	bf0c      	ite	eq
 80026f4:	2301      	moveq	r3, #1
 80026f6:	2300      	movne	r3, #0
 80026f8:	b2db      	uxtb	r3, r3
 80026fa:	2b00      	cmp	r3, #0
 80026fc:	d001      	beq.n	8002702 <HAL_I2C_Init+0x196>
 80026fe:	2301      	movs	r3, #1
 8002700:	e022      	b.n	8002748 <HAL_I2C_Init+0x1dc>
 8002702:	687b      	ldr	r3, [r7, #4]
 8002704:	689b      	ldr	r3, [r3, #8]
 8002706:	2b00      	cmp	r3, #0
 8002708:	d10e      	bne.n	8002728 <HAL_I2C_Init+0x1bc>
 800270a:	68fb      	ldr	r3, [r7, #12]
 800270c:	1e58      	subs	r0, r3, #1
 800270e:	687b      	ldr	r3, [r7, #4]
 8002710:	6859      	ldr	r1, [r3, #4]
 8002712:	460b      	mov	r3, r1
 8002714:	005b      	lsls	r3, r3, #1
 8002716:	440b      	add	r3, r1
 8002718:	fbb0 f3f3 	udiv	r3, r0, r3
 800271c:	3301      	adds	r3, #1
 800271e:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002722:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8002726:	e00f      	b.n	8002748 <HAL_I2C_Init+0x1dc>
 8002728:	68fb      	ldr	r3, [r7, #12]
 800272a:	1e58      	subs	r0, r3, #1
 800272c:	687b      	ldr	r3, [r7, #4]
 800272e:	6859      	ldr	r1, [r3, #4]
 8002730:	460b      	mov	r3, r1
 8002732:	009b      	lsls	r3, r3, #2
 8002734:	440b      	add	r3, r1
 8002736:	0099      	lsls	r1, r3, #2
 8002738:	440b      	add	r3, r1
 800273a:	fbb0 f3f3 	udiv	r3, r0, r3
 800273e:	3301      	adds	r3, #1
 8002740:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002744:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 8002748:	6879      	ldr	r1, [r7, #4]
 800274a:	6809      	ldr	r1, [r1, #0]
 800274c:	4313      	orrs	r3, r2
 800274e:	61cb      	str	r3, [r1, #28]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 8002750:	687b      	ldr	r3, [r7, #4]
 8002752:	681b      	ldr	r3, [r3, #0]
 8002754:	681b      	ldr	r3, [r3, #0]
 8002756:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 800275a:	687b      	ldr	r3, [r7, #4]
 800275c:	69da      	ldr	r2, [r3, #28]
 800275e:	687b      	ldr	r3, [r7, #4]
 8002760:	6a1b      	ldr	r3, [r3, #32]
 8002762:	431a      	orrs	r2, r3
 8002764:	687b      	ldr	r3, [r7, #4]
 8002766:	681b      	ldr	r3, [r3, #0]
 8002768:	430a      	orrs	r2, r1
 800276a:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 800276c:	687b      	ldr	r3, [r7, #4]
 800276e:	681b      	ldr	r3, [r3, #0]
 8002770:	689b      	ldr	r3, [r3, #8]
 8002772:	f423 4303 	bic.w	r3, r3, #33536	@ 0x8300
 8002776:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 800277a:	687a      	ldr	r2, [r7, #4]
 800277c:	6911      	ldr	r1, [r2, #16]
 800277e:	687a      	ldr	r2, [r7, #4]
 8002780:	68d2      	ldr	r2, [r2, #12]
 8002782:	4311      	orrs	r1, r2
 8002784:	687a      	ldr	r2, [r7, #4]
 8002786:	6812      	ldr	r2, [r2, #0]
 8002788:	430b      	orrs	r3, r1
 800278a:	6093      	str	r3, [r2, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 800278c:	687b      	ldr	r3, [r7, #4]
 800278e:	681b      	ldr	r3, [r3, #0]
 8002790:	68db      	ldr	r3, [r3, #12]
 8002792:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
 8002796:	687b      	ldr	r3, [r7, #4]
 8002798:	695a      	ldr	r2, [r3, #20]
 800279a:	687b      	ldr	r3, [r7, #4]
 800279c:	699b      	ldr	r3, [r3, #24]
 800279e:	431a      	orrs	r2, r3
 80027a0:	687b      	ldr	r3, [r7, #4]
 80027a2:	681b      	ldr	r3, [r3, #0]
 80027a4:	430a      	orrs	r2, r1
 80027a6:	60da      	str	r2, [r3, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 80027a8:	687b      	ldr	r3, [r7, #4]
 80027aa:	681b      	ldr	r3, [r3, #0]
 80027ac:	681a      	ldr	r2, [r3, #0]
 80027ae:	687b      	ldr	r3, [r7, #4]
 80027b0:	681b      	ldr	r3, [r3, #0]
 80027b2:	f042 0201 	orr.w	r2, r2, #1
 80027b6:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80027b8:	687b      	ldr	r3, [r7, #4]
 80027ba:	2200      	movs	r2, #0
 80027bc:	641a      	str	r2, [r3, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 80027be:	687b      	ldr	r3, [r7, #4]
 80027c0:	2220      	movs	r2, #32
 80027c2:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 80027c6:	687b      	ldr	r3, [r7, #4]
 80027c8:	2200      	movs	r2, #0
 80027ca:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80027cc:	687b      	ldr	r3, [r7, #4]
 80027ce:	2200      	movs	r2, #0
 80027d0:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

  return HAL_OK;
 80027d4:	2300      	movs	r3, #0
}
 80027d6:	4618      	mov	r0, r3
 80027d8:	3710      	adds	r7, #16
 80027da:	46bd      	mov	sp, r7
 80027dc:	bd80      	pop	{r7, pc}
 80027de:	bf00      	nop
 80027e0:	000186a0 	.word	0x000186a0
 80027e4:	001e847f 	.word	0x001e847f
 80027e8:	003d08ff 	.word	0x003d08ff
 80027ec:	431bde83 	.word	0x431bde83
 80027f0:	10624dd3 	.word	0x10624dd3

080027f4 <HAL_I2S_Init>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s)
{
 80027f4:	b580      	push	{r7, lr}
 80027f6:	b088      	sub	sp, #32
 80027f8:	af00      	add	r7, sp, #0
 80027fa:	6078      	str	r0, [r7, #4]
#if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
  uint16_t tmpreg;
#endif

  /* Check the I2S handle allocation */
  if (hi2s == NULL)
 80027fc:	687b      	ldr	r3, [r7, #4]
 80027fe:	2b00      	cmp	r3, #0
 8002800:	d101      	bne.n	8002806 <HAL_I2S_Init+0x12>
  {
    return HAL_ERROR;
 8002802:	2301      	movs	r3, #1
 8002804:	e128      	b.n	8002a58 <HAL_I2S_Init+0x264>
  assert_param(IS_I2S_MCLK_OUTPUT(hi2s->Init.MCLKOutput));
  assert_param(IS_I2S_AUDIO_FREQ(hi2s->Init.AudioFreq));
  assert_param(IS_I2S_CPOL(hi2s->Init.CPOL));
  assert_param(IS_I2S_CLOCKSOURCE(hi2s->Init.ClockSource));

  if (hi2s->State == HAL_I2S_STATE_RESET)
 8002806:	687b      	ldr	r3, [r7, #4]
 8002808:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800280c:	b2db      	uxtb	r3, r3
 800280e:	2b00      	cmp	r3, #0
 8002810:	d109      	bne.n	8002826 <HAL_I2S_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hi2s->Lock = HAL_UNLOCKED;
 8002812:	687b      	ldr	r3, [r7, #4]
 8002814:	2200      	movs	r2, #0
 8002816:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Initialize Default I2S IrqHandler ISR */
    hi2s->IrqHandlerISR = I2S_IRQHandler;
 800281a:	687b      	ldr	r3, [r7, #4]
 800281c:	4a90      	ldr	r2, [pc, #576]	@ (8002a60 <HAL_I2S_Init+0x26c>)
 800281e:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hi2s->MspInitCallback(hi2s);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2S_MspInit(hi2s);
 8002820:	6878      	ldr	r0, [r7, #4]
 8002822:	f7ff f8cf 	bl	80019c4 <HAL_I2S_MspInit>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }

  hi2s->State = HAL_I2S_STATE_BUSY;
 8002826:	687b      	ldr	r3, [r7, #4]
 8002828:	2202      	movs	r2, #2
 800282a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  CLEAR_BIT(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 800282e:	687b      	ldr	r3, [r7, #4]
 8002830:	681b      	ldr	r3, [r3, #0]
 8002832:	69db      	ldr	r3, [r3, #28]
 8002834:	687a      	ldr	r2, [r7, #4]
 8002836:	6812      	ldr	r2, [r2, #0]
 8002838:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 800283c:	f023 030f 	bic.w	r3, r3, #15
 8002840:	61d3      	str	r3, [r2, #28]
                                      SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                      SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
  hi2s->Instance->I2SPR = 0x0002U;
 8002842:	687b      	ldr	r3, [r7, #4]
 8002844:	681b      	ldr	r3, [r3, #0]
 8002846:	2202      	movs	r2, #2
 8002848:	621a      	str	r2, [r3, #32]

  /*----------------------- I2SPR: I2SDIV and ODD Calculation -----------------*/
  /* If the requested audio frequency is not the default, compute the prescaler */
  if (hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
 800284a:	687b      	ldr	r3, [r7, #4]
 800284c:	695b      	ldr	r3, [r3, #20]
 800284e:	2b02      	cmp	r3, #2
 8002850:	d060      	beq.n	8002914 <HAL_I2S_Init+0x120>
  {
    /* Check the frame length (For the Prescaler computing) ********************/
    if (hi2s->Init.DataFormat == I2S_DATAFORMAT_16B)
 8002852:	687b      	ldr	r3, [r7, #4]
 8002854:	68db      	ldr	r3, [r3, #12]
 8002856:	2b00      	cmp	r3, #0
 8002858:	d102      	bne.n	8002860 <HAL_I2S_Init+0x6c>
    {
      /* Packet length is 16 bits */
      packetlength = 16U;
 800285a:	2310      	movs	r3, #16
 800285c:	617b      	str	r3, [r7, #20]
 800285e:	e001      	b.n	8002864 <HAL_I2S_Init+0x70>
    }
    else
    {
      /* Packet length is 32 bits */
      packetlength = 32U;
 8002860:	2320      	movs	r3, #32
 8002862:	617b      	str	r3, [r7, #20]
    }

    /* I2S standard */
    if (hi2s->Init.Standard <= I2S_STANDARD_LSB)
 8002864:	687b      	ldr	r3, [r7, #4]
 8002866:	689b      	ldr	r3, [r3, #8]
 8002868:	2b20      	cmp	r3, #32
 800286a:	d802      	bhi.n	8002872 <HAL_I2S_Init+0x7e>
    {
      /* In I2S standard packet length is multiplied by 2 */
      packetlength = packetlength * 2U;
 800286c:	697b      	ldr	r3, [r7, #20]
 800286e:	005b      	lsls	r3, r3, #1
 8002870:	617b      	str	r3, [r7, #20]
    else
    {
      i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S_APB2);
    }
#else
    i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S);
 8002872:	2001      	movs	r0, #1
 8002874:	f002 fc16 	bl	80050a4 <HAL_RCCEx_GetPeriphCLKFreq>
 8002878:	60f8      	str	r0, [r7, #12]
#endif /* I2S_APB1_APB2_FEATURE */

    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if (hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
 800287a:	687b      	ldr	r3, [r7, #4]
 800287c:	691b      	ldr	r3, [r3, #16]
 800287e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8002882:	d125      	bne.n	80028d0 <HAL_I2S_Init+0xdc>
    {
      /* MCLK output is enabled */
      if (hi2s->Init.DataFormat != I2S_DATAFORMAT_16B)
 8002884:	687b      	ldr	r3, [r7, #4]
 8002886:	68db      	ldr	r3, [r3, #12]
 8002888:	2b00      	cmp	r3, #0
 800288a:	d010      	beq.n	80028ae <HAL_I2S_Init+0xba>
      {
        tmp = (uint32_t)(((((i2sclk / (packetlength * 4U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800288c:	697b      	ldr	r3, [r7, #20]
 800288e:	009b      	lsls	r3, r3, #2
 8002890:	68fa      	ldr	r2, [r7, #12]
 8002892:	fbb2 f2f3 	udiv	r2, r2, r3
 8002896:	4613      	mov	r3, r2
 8002898:	009b      	lsls	r3, r3, #2
 800289a:	4413      	add	r3, r2
 800289c:	005b      	lsls	r3, r3, #1
 800289e:	461a      	mov	r2, r3
 80028a0:	687b      	ldr	r3, [r7, #4]
 80028a2:	695b      	ldr	r3, [r3, #20]
 80028a4:	fbb2 f3f3 	udiv	r3, r2, r3
 80028a8:	3305      	adds	r3, #5
 80028aa:	613b      	str	r3, [r7, #16]
 80028ac:	e01f      	b.n	80028ee <HAL_I2S_Init+0xfa>
      }
      else
      {
        tmp = (uint32_t)(((((i2sclk / (packetlength * 8U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 80028ae:	697b      	ldr	r3, [r7, #20]
 80028b0:	00db      	lsls	r3, r3, #3
 80028b2:	68fa      	ldr	r2, [r7, #12]
 80028b4:	fbb2 f2f3 	udiv	r2, r2, r3
 80028b8:	4613      	mov	r3, r2
 80028ba:	009b      	lsls	r3, r3, #2
 80028bc:	4413      	add	r3, r2
 80028be:	005b      	lsls	r3, r3, #1
 80028c0:	461a      	mov	r2, r3
 80028c2:	687b      	ldr	r3, [r7, #4]
 80028c4:	695b      	ldr	r3, [r3, #20]
 80028c6:	fbb2 f3f3 	udiv	r3, r2, r3
 80028ca:	3305      	adds	r3, #5
 80028cc:	613b      	str	r3, [r7, #16]
 80028ce:	e00e      	b.n	80028ee <HAL_I2S_Init+0xfa>
      }
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint32_t)(((((i2sclk / packetlength) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 80028d0:	68fa      	ldr	r2, [r7, #12]
 80028d2:	697b      	ldr	r3, [r7, #20]
 80028d4:	fbb2 f2f3 	udiv	r2, r2, r3
 80028d8:	4613      	mov	r3, r2
 80028da:	009b      	lsls	r3, r3, #2
 80028dc:	4413      	add	r3, r2
 80028de:	005b      	lsls	r3, r3, #1
 80028e0:	461a      	mov	r2, r3
 80028e2:	687b      	ldr	r3, [r7, #4]
 80028e4:	695b      	ldr	r3, [r3, #20]
 80028e6:	fbb2 f3f3 	udiv	r3, r2, r3
 80028ea:	3305      	adds	r3, #5
 80028ec:	613b      	str	r3, [r7, #16]
    }

    /* Remove the flatting point */
    tmp = tmp / 10U;
 80028ee:	693b      	ldr	r3, [r7, #16]
 80028f0:	4a5c      	ldr	r2, [pc, #368]	@ (8002a64 <HAL_I2S_Init+0x270>)
 80028f2:	fba2 2303 	umull	r2, r3, r2, r3
 80028f6:	08db      	lsrs	r3, r3, #3
 80028f8:	613b      	str	r3, [r7, #16]

    /* Check the parity of the divider */
    i2sodd = (uint32_t)(tmp & (uint32_t)1U);
 80028fa:	693b      	ldr	r3, [r7, #16]
 80028fc:	f003 0301 	and.w	r3, r3, #1
 8002900:	61bb      	str	r3, [r7, #24]

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint32_t)((tmp - i2sodd) / 2U);
 8002902:	693a      	ldr	r2, [r7, #16]
 8002904:	69bb      	ldr	r3, [r7, #24]
 8002906:	1ad3      	subs	r3, r2, r3
 8002908:	085b      	lsrs	r3, r3, #1
 800290a:	61fb      	str	r3, [r7, #28]

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint32_t)(i2sodd << 8U);
 800290c:	69bb      	ldr	r3, [r7, #24]
 800290e:	021b      	lsls	r3, r3, #8
 8002910:	61bb      	str	r3, [r7, #24]
 8002912:	e003      	b.n	800291c <HAL_I2S_Init+0x128>
  }
  else
  {
    /* Set the default values */
    i2sdiv = 2U;
 8002914:	2302      	movs	r3, #2
 8002916:	61fb      	str	r3, [r7, #28]
    i2sodd = 0U;
 8002918:	2300      	movs	r3, #0
 800291a:	61bb      	str	r3, [r7, #24]
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2U) || (i2sdiv > 0xFFU))
 800291c:	69fb      	ldr	r3, [r7, #28]
 800291e:	2b01      	cmp	r3, #1
 8002920:	d902      	bls.n	8002928 <HAL_I2S_Init+0x134>
 8002922:	69fb      	ldr	r3, [r7, #28]
 8002924:	2bff      	cmp	r3, #255	@ 0xff
 8002926:	d907      	bls.n	8002938 <HAL_I2S_Init+0x144>
  {
    /* Set the error code and execute error callback*/
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_PRESCALER);
 8002928:	687b      	ldr	r3, [r7, #4]
 800292a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800292c:	f043 0210 	orr.w	r2, r3, #16
 8002930:	687b      	ldr	r3, [r7, #4]
 8002932:	645a      	str	r2, [r3, #68]	@ 0x44
    return  HAL_ERROR;
 8002934:	2301      	movs	r3, #1
 8002936:	e08f      	b.n	8002a58 <HAL_I2S_Init+0x264>
  }

  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/

  /* Write to SPIx I2SPR register the computed value */
  hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
 8002938:	687b      	ldr	r3, [r7, #4]
 800293a:	691a      	ldr	r2, [r3, #16]
 800293c:	69bb      	ldr	r3, [r7, #24]
 800293e:	ea42 0103 	orr.w	r1, r2, r3
 8002942:	687b      	ldr	r3, [r7, #4]
 8002944:	681b      	ldr	r3, [r3, #0]
 8002946:	69fa      	ldr	r2, [r7, #28]
 8002948:	430a      	orrs	r2, r1
 800294a:	621a      	str	r2, [r3, #32]

  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  /* And configure the I2S with the I2S_InitStruct values                      */
  MODIFY_REG(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | \
 800294c:	687b      	ldr	r3, [r7, #4]
 800294e:	681b      	ldr	r3, [r3, #0]
 8002950:	69db      	ldr	r3, [r3, #28]
 8002952:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 8002956:	f023 030f 	bic.w	r3, r3, #15
 800295a:	687a      	ldr	r2, [r7, #4]
 800295c:	6851      	ldr	r1, [r2, #4]
 800295e:	687a      	ldr	r2, [r7, #4]
 8002960:	6892      	ldr	r2, [r2, #8]
 8002962:	4311      	orrs	r1, r2
 8002964:	687a      	ldr	r2, [r7, #4]
 8002966:	68d2      	ldr	r2, [r2, #12]
 8002968:	4311      	orrs	r1, r2
 800296a:	687a      	ldr	r2, [r7, #4]
 800296c:	6992      	ldr	r2, [r2, #24]
 800296e:	430a      	orrs	r2, r1
 8002970:	431a      	orrs	r2, r3
 8002972:	687b      	ldr	r3, [r7, #4]
 8002974:	681b      	ldr	r3, [r3, #0]
 8002976:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800297a:	61da      	str	r2, [r3, #28]
#if defined (SPI_I2S_FULLDUPLEX_SUPPORT)

  /* Configure the I2S extended if the full duplex mode is enabled */
  assert_param(IS_I2S_FULLDUPLEX_MODE(hi2s->Init.FullDuplexMode));

  if (hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 800297c:	687b      	ldr	r3, [r7, #4]
 800297e:	6a1b      	ldr	r3, [r3, #32]
 8002980:	2b01      	cmp	r3, #1
 8002982:	d161      	bne.n	8002a48 <HAL_I2S_Init+0x254>
  {
    /* Set FullDuplex I2S IrqHandler ISR if FULLDUPLEXMODE is enabled */
    hi2s->IrqHandlerISR = HAL_I2SEx_FullDuplex_IRQHandler;
 8002984:	687b      	ldr	r3, [r7, #4]
 8002986:	4a38      	ldr	r2, [pc, #224]	@ (8002a68 <HAL_I2S_Init+0x274>)
 8002988:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    CLEAR_BIT(I2SxEXT(hi2s->Instance)->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 800298a:	687b      	ldr	r3, [r7, #4]
 800298c:	681b      	ldr	r3, [r3, #0]
 800298e:	4a37      	ldr	r2, [pc, #220]	@ (8002a6c <HAL_I2S_Init+0x278>)
 8002990:	4293      	cmp	r3, r2
 8002992:	d101      	bne.n	8002998 <HAL_I2S_Init+0x1a4>
 8002994:	4b36      	ldr	r3, [pc, #216]	@ (8002a70 <HAL_I2S_Init+0x27c>)
 8002996:	e001      	b.n	800299c <HAL_I2S_Init+0x1a8>
 8002998:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800299c:	69db      	ldr	r3, [r3, #28]
 800299e:	687a      	ldr	r2, [r7, #4]
 80029a0:	6812      	ldr	r2, [r2, #0]
 80029a2:	4932      	ldr	r1, [pc, #200]	@ (8002a6c <HAL_I2S_Init+0x278>)
 80029a4:	428a      	cmp	r2, r1
 80029a6:	d101      	bne.n	80029ac <HAL_I2S_Init+0x1b8>
 80029a8:	4a31      	ldr	r2, [pc, #196]	@ (8002a70 <HAL_I2S_Init+0x27c>)
 80029aa:	e001      	b.n	80029b0 <HAL_I2S_Init+0x1bc>
 80029ac:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 80029b0:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 80029b4:	f023 030f 	bic.w	r3, r3, #15
 80029b8:	61d3      	str	r3, [r2, #28]
                                                 SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                                 SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
    I2SxEXT(hi2s->Instance)->I2SPR = 2U;
 80029ba:	687b      	ldr	r3, [r7, #4]
 80029bc:	681b      	ldr	r3, [r3, #0]
 80029be:	4a2b      	ldr	r2, [pc, #172]	@ (8002a6c <HAL_I2S_Init+0x278>)
 80029c0:	4293      	cmp	r3, r2
 80029c2:	d101      	bne.n	80029c8 <HAL_I2S_Init+0x1d4>
 80029c4:	4b2a      	ldr	r3, [pc, #168]	@ (8002a70 <HAL_I2S_Init+0x27c>)
 80029c6:	e001      	b.n	80029cc <HAL_I2S_Init+0x1d8>
 80029c8:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 80029cc:	2202      	movs	r2, #2
 80029ce:	621a      	str	r2, [r3, #32]

    /* Get the I2SCFGR register value */
    tmpreg = I2SxEXT(hi2s->Instance)->I2SCFGR;
 80029d0:	687b      	ldr	r3, [r7, #4]
 80029d2:	681b      	ldr	r3, [r3, #0]
 80029d4:	4a25      	ldr	r2, [pc, #148]	@ (8002a6c <HAL_I2S_Init+0x278>)
 80029d6:	4293      	cmp	r3, r2
 80029d8:	d101      	bne.n	80029de <HAL_I2S_Init+0x1ea>
 80029da:	4b25      	ldr	r3, [pc, #148]	@ (8002a70 <HAL_I2S_Init+0x27c>)
 80029dc:	e001      	b.n	80029e2 <HAL_I2S_Init+0x1ee>
 80029de:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 80029e2:	69db      	ldr	r3, [r3, #28]
 80029e4:	817b      	strh	r3, [r7, #10]

    /* Get the mode to be configured for the extended I2S */
    if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 80029e6:	687b      	ldr	r3, [r7, #4]
 80029e8:	685b      	ldr	r3, [r3, #4]
 80029ea:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80029ee:	d003      	beq.n	80029f8 <HAL_I2S_Init+0x204>
 80029f0:	687b      	ldr	r3, [r7, #4]
 80029f2:	685b      	ldr	r3, [r3, #4]
 80029f4:	2b00      	cmp	r3, #0
 80029f6:	d103      	bne.n	8002a00 <HAL_I2S_Init+0x20c>
    {
      tmp = I2S_MODE_SLAVE_RX;
 80029f8:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80029fc:	613b      	str	r3, [r7, #16]
 80029fe:	e001      	b.n	8002a04 <HAL_I2S_Init+0x210>
    }
    else /* I2S_MODE_MASTER_RX ||  I2S_MODE_SLAVE_RX */
    {
      tmp = I2S_MODE_SLAVE_TX;
 8002a00:	2300      	movs	r3, #0
 8002a02:	613b      	str	r3, [r7, #16]
    }

    /* Configure the I2S Slave with the I2S Master parameter values */
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
                         (uint16_t)tmp                   | \
 8002a04:	693b      	ldr	r3, [r7, #16]
 8002a06:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.Standard   | \
 8002a08:	687b      	ldr	r3, [r7, #4]
 8002a0a:	689b      	ldr	r3, [r3, #8]
 8002a0c:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 8002a0e:	4313      	orrs	r3, r2
 8002a10:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.DataFormat | \
 8002a12:	687b      	ldr	r3, [r7, #4]
 8002a14:	68db      	ldr	r3, [r3, #12]
 8002a16:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 8002a18:	4313      	orrs	r3, r2
 8002a1a:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.CPOL);
 8002a1c:	687b      	ldr	r3, [r7, #4]
 8002a1e:	699b      	ldr	r3, [r3, #24]
 8002a20:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 8002a22:	4313      	orrs	r3, r2
 8002a24:	b29a      	uxth	r2, r3
 8002a26:	897b      	ldrh	r3, [r7, #10]
 8002a28:	4313      	orrs	r3, r2
 8002a2a:	b29b      	uxth	r3, r3
 8002a2c:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8002a30:	817b      	strh	r3, [r7, #10]

    /* Write to SPIx I2SCFGR */
    WRITE_REG(I2SxEXT(hi2s->Instance)->I2SCFGR, tmpreg);
 8002a32:	687b      	ldr	r3, [r7, #4]
 8002a34:	681b      	ldr	r3, [r3, #0]
 8002a36:	4a0d      	ldr	r2, [pc, #52]	@ (8002a6c <HAL_I2S_Init+0x278>)
 8002a38:	4293      	cmp	r3, r2
 8002a3a:	d101      	bne.n	8002a40 <HAL_I2S_Init+0x24c>
 8002a3c:	4b0c      	ldr	r3, [pc, #48]	@ (8002a70 <HAL_I2S_Init+0x27c>)
 8002a3e:	e001      	b.n	8002a44 <HAL_I2S_Init+0x250>
 8002a40:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002a44:	897a      	ldrh	r2, [r7, #10]
 8002a46:	61da      	str	r2, [r3, #28]
  }
#endif /* SPI_I2S_FULLDUPLEX_SUPPORT */

  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 8002a48:	687b      	ldr	r3, [r7, #4]
 8002a4a:	2200      	movs	r2, #0
 8002a4c:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2s->State     = HAL_I2S_STATE_READY;
 8002a4e:	687b      	ldr	r3, [r7, #4]
 8002a50:	2201      	movs	r2, #1
 8002a52:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  return HAL_OK;
 8002a56:	2300      	movs	r3, #0
}
 8002a58:	4618      	mov	r0, r3
 8002a5a:	3720      	adds	r7, #32
 8002a5c:	46bd      	mov	sp, r7
 8002a5e:	bd80      	pop	{r7, pc}
 8002a60:	08002b6b 	.word	0x08002b6b
 8002a64:	cccccccd 	.word	0xcccccccd
 8002a68:	08002c81 	.word	0x08002c81
 8002a6c:	40003800 	.word	0x40003800
 8002a70:	40003400 	.word	0x40003400

08002a74 <HAL_I2S_TxCpltCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8002a74:	b480      	push	{r7}
 8002a76:	b083      	sub	sp, #12
 8002a78:	af00      	add	r7, sp, #0
 8002a7a:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_TxCpltCallback could be implemented in the user file
   */
}
 8002a7c:	bf00      	nop
 8002a7e:	370c      	adds	r7, #12
 8002a80:	46bd      	mov	sp, r7
 8002a82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a86:	4770      	bx	lr

08002a88 <HAL_I2S_RxCpltCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8002a88:	b480      	push	{r7}
 8002a8a:	b083      	sub	sp, #12
 8002a8c:	af00      	add	r7, sp, #0
 8002a8e:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_RxCpltCallback could be implemented in the user file
   */
}
 8002a90:	bf00      	nop
 8002a92:	370c      	adds	r7, #12
 8002a94:	46bd      	mov	sp, r7
 8002a96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a9a:	4770      	bx	lr

08002a9c <HAL_I2S_ErrorCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_ErrorCallback(I2S_HandleTypeDef *hi2s)
{
 8002a9c:	b480      	push	{r7}
 8002a9e:	b083      	sub	sp, #12
 8002aa0:	af00      	add	r7, sp, #0
 8002aa2:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_ErrorCallback could be implemented in the user file
   */
}
 8002aa4:	bf00      	nop
 8002aa6:	370c      	adds	r7, #12
 8002aa8:	46bd      	mov	sp, r7
 8002aaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002aae:	4770      	bx	lr

08002ab0 <I2S_Transmit_IT>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_Transmit_IT(I2S_HandleTypeDef *hi2s)
{
 8002ab0:	b580      	push	{r7, lr}
 8002ab2:	b082      	sub	sp, #8
 8002ab4:	af00      	add	r7, sp, #0
 8002ab6:	6078      	str	r0, [r7, #4]
  /* Transmit data */
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr);
 8002ab8:	687b      	ldr	r3, [r7, #4]
 8002aba:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002abc:	881a      	ldrh	r2, [r3, #0]
 8002abe:	687b      	ldr	r3, [r7, #4]
 8002ac0:	681b      	ldr	r3, [r3, #0]
 8002ac2:	60da      	str	r2, [r3, #12]
  hi2s->pTxBuffPtr++;
 8002ac4:	687b      	ldr	r3, [r7, #4]
 8002ac6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002ac8:	1c9a      	adds	r2, r3, #2
 8002aca:	687b      	ldr	r3, [r7, #4]
 8002acc:	625a      	str	r2, [r3, #36]	@ 0x24
  hi2s->TxXferCount--;
 8002ace:	687b      	ldr	r3, [r7, #4]
 8002ad0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002ad2:	b29b      	uxth	r3, r3
 8002ad4:	3b01      	subs	r3, #1
 8002ad6:	b29a      	uxth	r2, r3
 8002ad8:	687b      	ldr	r3, [r7, #4]
 8002ada:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 8002adc:	687b      	ldr	r3, [r7, #4]
 8002ade:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002ae0:	b29b      	uxth	r3, r3
 8002ae2:	2b00      	cmp	r3, #0
 8002ae4:	d10e      	bne.n	8002b04 <I2S_Transmit_IT+0x54>
  {
    /* Disable TXE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002ae6:	687b      	ldr	r3, [r7, #4]
 8002ae8:	681b      	ldr	r3, [r3, #0]
 8002aea:	685a      	ldr	r2, [r3, #4]
 8002aec:	687b      	ldr	r3, [r7, #4]
 8002aee:	681b      	ldr	r3, [r3, #0]
 8002af0:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002af4:	605a      	str	r2, [r3, #4]

    hi2s->State = HAL_I2S_STATE_READY;
 8002af6:	687b      	ldr	r3, [r7, #4]
 8002af8:	2201      	movs	r2, #1
 8002afa:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    /* Call user Tx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    hi2s->TxCpltCallback(hi2s);
#else
    HAL_I2S_TxCpltCallback(hi2s);
 8002afe:	6878      	ldr	r0, [r7, #4]
 8002b00:	f7ff ffb8 	bl	8002a74 <HAL_I2S_TxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }
}
 8002b04:	bf00      	nop
 8002b06:	3708      	adds	r7, #8
 8002b08:	46bd      	mov	sp, r7
 8002b0a:	bd80      	pop	{r7, pc}

08002b0c <I2S_Receive_IT>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_Receive_IT(I2S_HandleTypeDef *hi2s)
{
 8002b0c:	b580      	push	{r7, lr}
 8002b0e:	b082      	sub	sp, #8
 8002b10:	af00      	add	r7, sp, #0
 8002b12:	6078      	str	r0, [r7, #4]
  /* Receive data */
  (*hi2s->pRxBuffPtr) = (uint16_t)hi2s->Instance->DR;
 8002b14:	687b      	ldr	r3, [r7, #4]
 8002b16:	681b      	ldr	r3, [r3, #0]
 8002b18:	68da      	ldr	r2, [r3, #12]
 8002b1a:	687b      	ldr	r3, [r7, #4]
 8002b1c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002b1e:	b292      	uxth	r2, r2
 8002b20:	801a      	strh	r2, [r3, #0]
  hi2s->pRxBuffPtr++;
 8002b22:	687b      	ldr	r3, [r7, #4]
 8002b24:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002b26:	1c9a      	adds	r2, r3, #2
 8002b28:	687b      	ldr	r3, [r7, #4]
 8002b2a:	62da      	str	r2, [r3, #44]	@ 0x2c
  hi2s->RxXferCount--;
 8002b2c:	687b      	ldr	r3, [r7, #4]
 8002b2e:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002b30:	b29b      	uxth	r3, r3
 8002b32:	3b01      	subs	r3, #1
 8002b34:	b29a      	uxth	r2, r3
 8002b36:	687b      	ldr	r3, [r7, #4]
 8002b38:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 8002b3a:	687b      	ldr	r3, [r7, #4]
 8002b3c:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002b3e:	b29b      	uxth	r3, r3
 8002b40:	2b00      	cmp	r3, #0
 8002b42:	d10e      	bne.n	8002b62 <I2S_Receive_IT+0x56>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002b44:	687b      	ldr	r3, [r7, #4]
 8002b46:	681b      	ldr	r3, [r3, #0]
 8002b48:	685a      	ldr	r2, [r3, #4]
 8002b4a:	687b      	ldr	r3, [r7, #4]
 8002b4c:	681b      	ldr	r3, [r3, #0]
 8002b4e:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002b52:	605a      	str	r2, [r3, #4]

    hi2s->State = HAL_I2S_STATE_READY;
 8002b54:	687b      	ldr	r3, [r7, #4]
 8002b56:	2201      	movs	r2, #1
 8002b58:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    /* Call user Rx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    hi2s->RxCpltCallback(hi2s);
#else
    HAL_I2S_RxCpltCallback(hi2s);
 8002b5c:	6878      	ldr	r0, [r7, #4]
 8002b5e:	f7ff ff93 	bl	8002a88 <HAL_I2S_RxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }
}
 8002b62:	bf00      	nop
 8002b64:	3708      	adds	r7, #8
 8002b66:	46bd      	mov	sp, r7
 8002b68:	bd80      	pop	{r7, pc}

08002b6a <I2S_IRQHandler>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 8002b6a:	b580      	push	{r7, lr}
 8002b6c:	b086      	sub	sp, #24
 8002b6e:	af00      	add	r7, sp, #0
 8002b70:	6078      	str	r0, [r7, #4]
  __IO uint32_t i2ssr = hi2s->Instance->SR;
 8002b72:	687b      	ldr	r3, [r7, #4]
 8002b74:	681b      	ldr	r3, [r3, #0]
 8002b76:	689b      	ldr	r3, [r3, #8]
 8002b78:	617b      	str	r3, [r7, #20]

  if (hi2s->State == HAL_I2S_STATE_BUSY_RX)
 8002b7a:	687b      	ldr	r3, [r7, #4]
 8002b7c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002b80:	b2db      	uxtb	r3, r3
 8002b82:	2b04      	cmp	r3, #4
 8002b84:	d13a      	bne.n	8002bfc <I2S_IRQHandler+0x92>
  {
    /* I2S in mode Receiver ------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE) != RESET))
 8002b86:	697b      	ldr	r3, [r7, #20]
 8002b88:	f003 0301 	and.w	r3, r3, #1
 8002b8c:	2b01      	cmp	r3, #1
 8002b8e:	d109      	bne.n	8002ba4 <I2S_IRQHandler+0x3a>
 8002b90:	687b      	ldr	r3, [r7, #4]
 8002b92:	681b      	ldr	r3, [r3, #0]
 8002b94:	685b      	ldr	r3, [r3, #4]
 8002b96:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002b9a:	2b40      	cmp	r3, #64	@ 0x40
 8002b9c:	d102      	bne.n	8002ba4 <I2S_IRQHandler+0x3a>
    {
      I2S_Receive_IT(hi2s);
 8002b9e:	6878      	ldr	r0, [r7, #4]
 8002ba0:	f7ff ffb4 	bl	8002b0c <I2S_Receive_IT>
    }

    /* I2S Overrun error interrupt occurred -------------------------------------*/
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 8002ba4:	697b      	ldr	r3, [r7, #20]
 8002ba6:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002baa:	2b40      	cmp	r3, #64	@ 0x40
 8002bac:	d126      	bne.n	8002bfc <I2S_IRQHandler+0x92>
 8002bae:	687b      	ldr	r3, [r7, #4]
 8002bb0:	681b      	ldr	r3, [r3, #0]
 8002bb2:	685b      	ldr	r3, [r3, #4]
 8002bb4:	f003 0320 	and.w	r3, r3, #32
 8002bb8:	2b20      	cmp	r3, #32
 8002bba:	d11f      	bne.n	8002bfc <I2S_IRQHandler+0x92>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002bbc:	687b      	ldr	r3, [r7, #4]
 8002bbe:	681b      	ldr	r3, [r3, #0]
 8002bc0:	685a      	ldr	r2, [r3, #4]
 8002bc2:	687b      	ldr	r3, [r7, #4]
 8002bc4:	681b      	ldr	r3, [r3, #0]
 8002bc6:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002bca:	605a      	str	r2, [r3, #4]

      /* Clear Overrun flag */
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8002bcc:	2300      	movs	r3, #0
 8002bce:	613b      	str	r3, [r7, #16]
 8002bd0:	687b      	ldr	r3, [r7, #4]
 8002bd2:	681b      	ldr	r3, [r3, #0]
 8002bd4:	68db      	ldr	r3, [r3, #12]
 8002bd6:	613b      	str	r3, [r7, #16]
 8002bd8:	687b      	ldr	r3, [r7, #4]
 8002bda:	681b      	ldr	r3, [r3, #0]
 8002bdc:	689b      	ldr	r3, [r3, #8]
 8002bde:	613b      	str	r3, [r7, #16]
 8002be0:	693b      	ldr	r3, [r7, #16]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002be2:	687b      	ldr	r3, [r7, #4]
 8002be4:	2201      	movs	r2, #1
 8002be6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41


      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8002bea:	687b      	ldr	r3, [r7, #4]
 8002bec:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002bee:	f043 0202 	orr.w	r2, r3, #2
 8002bf2:	687b      	ldr	r3, [r7, #4]
 8002bf4:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002bf6:	6878      	ldr	r0, [r7, #4]
 8002bf8:	f7ff ff50 	bl	8002a9c <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }

  if (hi2s->State == HAL_I2S_STATE_BUSY_TX)
 8002bfc:	687b      	ldr	r3, [r7, #4]
 8002bfe:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002c02:	b2db      	uxtb	r3, r3
 8002c04:	2b03      	cmp	r3, #3
 8002c06:	d136      	bne.n	8002c76 <I2S_IRQHandler+0x10c>
  {
    /* I2S in mode Transmitter -----------------------------------------------*/
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE) != RESET))
 8002c08:	697b      	ldr	r3, [r7, #20]
 8002c0a:	f003 0302 	and.w	r3, r3, #2
 8002c0e:	2b02      	cmp	r3, #2
 8002c10:	d109      	bne.n	8002c26 <I2S_IRQHandler+0xbc>
 8002c12:	687b      	ldr	r3, [r7, #4]
 8002c14:	681b      	ldr	r3, [r3, #0]
 8002c16:	685b      	ldr	r3, [r3, #4]
 8002c18:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002c1c:	2b80      	cmp	r3, #128	@ 0x80
 8002c1e:	d102      	bne.n	8002c26 <I2S_IRQHandler+0xbc>
    {
      I2S_Transmit_IT(hi2s);
 8002c20:	6878      	ldr	r0, [r7, #4]
 8002c22:	f7ff ff45 	bl	8002ab0 <I2S_Transmit_IT>
    }

    /* I2S Underrun error interrupt occurred --------------------------------*/
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 8002c26:	697b      	ldr	r3, [r7, #20]
 8002c28:	f003 0308 	and.w	r3, r3, #8
 8002c2c:	2b08      	cmp	r3, #8
 8002c2e:	d122      	bne.n	8002c76 <I2S_IRQHandler+0x10c>
 8002c30:	687b      	ldr	r3, [r7, #4]
 8002c32:	681b      	ldr	r3, [r3, #0]
 8002c34:	685b      	ldr	r3, [r3, #4]
 8002c36:	f003 0320 	and.w	r3, r3, #32
 8002c3a:	2b20      	cmp	r3, #32
 8002c3c:	d11b      	bne.n	8002c76 <I2S_IRQHandler+0x10c>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002c3e:	687b      	ldr	r3, [r7, #4]
 8002c40:	681b      	ldr	r3, [r3, #0]
 8002c42:	685a      	ldr	r2, [r3, #4]
 8002c44:	687b      	ldr	r3, [r7, #4]
 8002c46:	681b      	ldr	r3, [r3, #0]
 8002c48:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002c4c:	605a      	str	r2, [r3, #4]

      /* Clear Underrun flag */
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 8002c4e:	2300      	movs	r3, #0
 8002c50:	60fb      	str	r3, [r7, #12]
 8002c52:	687b      	ldr	r3, [r7, #4]
 8002c54:	681b      	ldr	r3, [r3, #0]
 8002c56:	689b      	ldr	r3, [r3, #8]
 8002c58:	60fb      	str	r3, [r7, #12]
 8002c5a:	68fb      	ldr	r3, [r7, #12]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002c5c:	687b      	ldr	r3, [r7, #4]
 8002c5e:	2201      	movs	r2, #1
 8002c60:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 8002c64:	687b      	ldr	r3, [r7, #4]
 8002c66:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002c68:	f043 0204 	orr.w	r2, r3, #4
 8002c6c:	687b      	ldr	r3, [r7, #4]
 8002c6e:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002c70:	6878      	ldr	r0, [r7, #4]
 8002c72:	f7ff ff13 	bl	8002a9c <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002c76:	bf00      	nop
 8002c78:	3718      	adds	r7, #24
 8002c7a:	46bd      	mov	sp, r7
 8002c7c:	bd80      	pop	{r7, pc}
	...

08002c80 <HAL_I2SEx_FullDuplex_IRQHandler>:
  * @brief  This function handles I2S/I2Sext interrupt requests in full-duplex mode.
  * @param  hi2s I2S handle
  * @retval HAL status
  */
void HAL_I2SEx_FullDuplex_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 8002c80:	b580      	push	{r7, lr}
 8002c82:	b088      	sub	sp, #32
 8002c84:	af00      	add	r7, sp, #0
 8002c86:	6078      	str	r0, [r7, #4]
  __IO uint32_t i2ssr     = hi2s->Instance->SR;
 8002c88:	687b      	ldr	r3, [r7, #4]
 8002c8a:	681b      	ldr	r3, [r3, #0]
 8002c8c:	689b      	ldr	r3, [r3, #8]
 8002c8e:	61fb      	str	r3, [r7, #28]
  __IO uint32_t i2sextsr  = I2SxEXT(hi2s->Instance)->SR;
 8002c90:	687b      	ldr	r3, [r7, #4]
 8002c92:	681b      	ldr	r3, [r3, #0]
 8002c94:	4a92      	ldr	r2, [pc, #584]	@ (8002ee0 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002c96:	4293      	cmp	r3, r2
 8002c98:	d101      	bne.n	8002c9e <HAL_I2SEx_FullDuplex_IRQHandler+0x1e>
 8002c9a:	4b92      	ldr	r3, [pc, #584]	@ (8002ee4 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002c9c:	e001      	b.n	8002ca2 <HAL_I2SEx_FullDuplex_IRQHandler+0x22>
 8002c9e:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002ca2:	689b      	ldr	r3, [r3, #8]
 8002ca4:	61bb      	str	r3, [r7, #24]
  __IO uint32_t i2scr2    = hi2s->Instance->CR2;
 8002ca6:	687b      	ldr	r3, [r7, #4]
 8002ca8:	681b      	ldr	r3, [r3, #0]
 8002caa:	685b      	ldr	r3, [r3, #4]
 8002cac:	617b      	str	r3, [r7, #20]
  __IO uint32_t i2sextcr2 = I2SxEXT(hi2s->Instance)->CR2;
 8002cae:	687b      	ldr	r3, [r7, #4]
 8002cb0:	681b      	ldr	r3, [r3, #0]
 8002cb2:	4a8b      	ldr	r2, [pc, #556]	@ (8002ee0 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002cb4:	4293      	cmp	r3, r2
 8002cb6:	d101      	bne.n	8002cbc <HAL_I2SEx_FullDuplex_IRQHandler+0x3c>
 8002cb8:	4b8a      	ldr	r3, [pc, #552]	@ (8002ee4 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002cba:	e001      	b.n	8002cc0 <HAL_I2SEx_FullDuplex_IRQHandler+0x40>
 8002cbc:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002cc0:	685b      	ldr	r3, [r3, #4]
 8002cc2:	613b      	str	r3, [r7, #16]

  /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
  if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 8002cc4:	687b      	ldr	r3, [r7, #4]
 8002cc6:	685b      	ldr	r3, [r3, #4]
 8002cc8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8002ccc:	d004      	beq.n	8002cd8 <HAL_I2SEx_FullDuplex_IRQHandler+0x58>
 8002cce:	687b      	ldr	r3, [r7, #4]
 8002cd0:	685b      	ldr	r3, [r3, #4]
 8002cd2:	2b00      	cmp	r3, #0
 8002cd4:	f040 8099 	bne.w	8002e0a <HAL_I2SEx_FullDuplex_IRQHandler+0x18a>
  {
    /* I2S in mode Transmitter -------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2scr2 & I2S_IT_TXE) != RESET))
 8002cd8:	69fb      	ldr	r3, [r7, #28]
 8002cda:	f003 0302 	and.w	r3, r3, #2
 8002cde:	2b02      	cmp	r3, #2
 8002ce0:	d107      	bne.n	8002cf2 <HAL_I2SEx_FullDuplex_IRQHandler+0x72>
 8002ce2:	697b      	ldr	r3, [r7, #20]
 8002ce4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002ce8:	2b00      	cmp	r3, #0
 8002cea:	d002      	beq.n	8002cf2 <HAL_I2SEx_FullDuplex_IRQHandler+0x72>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
      the I2S TXE interrupt will be generated to manage the full-duplex transmit phase. */
      I2SEx_TxISR_I2S(hi2s);
 8002cec:	6878      	ldr	r0, [r7, #4]
 8002cee:	f000 f925 	bl	8002f3c <I2SEx_TxISR_I2S>
    }

    /* I2Sext in mode Receiver -----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2sextcr2 & I2S_IT_RXNE) != RESET))
 8002cf2:	69bb      	ldr	r3, [r7, #24]
 8002cf4:	f003 0301 	and.w	r3, r3, #1
 8002cf8:	2b01      	cmp	r3, #1
 8002cfa:	d107      	bne.n	8002d0c <HAL_I2SEx_FullDuplex_IRQHandler+0x8c>
 8002cfc:	693b      	ldr	r3, [r7, #16]
 8002cfe:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002d02:	2b00      	cmp	r3, #0
 8002d04:	d002      	beq.n	8002d0c <HAL_I2SEx_FullDuplex_IRQHandler+0x8c>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
      the I2Sext RXNE interrupt will be generated to manage the full-duplex receive phase. */
      I2SEx_RxISR_I2SExt(hi2s);
 8002d06:	6878      	ldr	r0, [r7, #4]
 8002d08:	f000 f9c8 	bl	800309c <I2SEx_RxISR_I2SExt>
    }

    /* I2Sext Overrun error interrupt occurred --------------------------------*/
    if (((i2sextsr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 8002d0c:	69bb      	ldr	r3, [r7, #24]
 8002d0e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002d12:	2b40      	cmp	r3, #64	@ 0x40
 8002d14:	d13a      	bne.n	8002d8c <HAL_I2SEx_FullDuplex_IRQHandler+0x10c>
 8002d16:	693b      	ldr	r3, [r7, #16]
 8002d18:	f003 0320 	and.w	r3, r3, #32
 8002d1c:	2b00      	cmp	r3, #0
 8002d1e:	d035      	beq.n	8002d8c <HAL_I2SEx_FullDuplex_IRQHandler+0x10c>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002d20:	687b      	ldr	r3, [r7, #4]
 8002d22:	681b      	ldr	r3, [r3, #0]
 8002d24:	4a6e      	ldr	r2, [pc, #440]	@ (8002ee0 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002d26:	4293      	cmp	r3, r2
 8002d28:	d101      	bne.n	8002d2e <HAL_I2SEx_FullDuplex_IRQHandler+0xae>
 8002d2a:	4b6e      	ldr	r3, [pc, #440]	@ (8002ee4 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002d2c:	e001      	b.n	8002d32 <HAL_I2SEx_FullDuplex_IRQHandler+0xb2>
 8002d2e:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002d32:	685a      	ldr	r2, [r3, #4]
 8002d34:	687b      	ldr	r3, [r7, #4]
 8002d36:	681b      	ldr	r3, [r3, #0]
 8002d38:	4969      	ldr	r1, [pc, #420]	@ (8002ee0 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002d3a:	428b      	cmp	r3, r1
 8002d3c:	d101      	bne.n	8002d42 <HAL_I2SEx_FullDuplex_IRQHandler+0xc2>
 8002d3e:	4b69      	ldr	r3, [pc, #420]	@ (8002ee4 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002d40:	e001      	b.n	8002d46 <HAL_I2SEx_FullDuplex_IRQHandler+0xc6>
 8002d42:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002d46:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002d4a:	605a      	str	r2, [r3, #4]

      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002d4c:	687b      	ldr	r3, [r7, #4]
 8002d4e:	681b      	ldr	r3, [r3, #0]
 8002d50:	685a      	ldr	r2, [r3, #4]
 8002d52:	687b      	ldr	r3, [r7, #4]
 8002d54:	681b      	ldr	r3, [r3, #0]
 8002d56:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002d5a:	605a      	str	r2, [r3, #4]

      /* Clear Overrun flag */
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8002d5c:	2300      	movs	r3, #0
 8002d5e:	60fb      	str	r3, [r7, #12]
 8002d60:	687b      	ldr	r3, [r7, #4]
 8002d62:	681b      	ldr	r3, [r3, #0]
 8002d64:	68db      	ldr	r3, [r3, #12]
 8002d66:	60fb      	str	r3, [r7, #12]
 8002d68:	687b      	ldr	r3, [r7, #4]
 8002d6a:	681b      	ldr	r3, [r3, #0]
 8002d6c:	689b      	ldr	r3, [r3, #8]
 8002d6e:	60fb      	str	r3, [r7, #12]
 8002d70:	68fb      	ldr	r3, [r7, #12]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002d72:	687b      	ldr	r3, [r7, #4]
 8002d74:	2201      	movs	r2, #1
 8002d76:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8002d7a:	687b      	ldr	r3, [r7, #4]
 8002d7c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002d7e:	f043 0202 	orr.w	r2, r3, #2
 8002d82:	687b      	ldr	r3, [r7, #4]
 8002d84:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002d86:	6878      	ldr	r0, [r7, #4]
 8002d88:	f7ff fe88 	bl	8002a9c <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }

    /* I2S Underrun error interrupt occurred ----------------------------------*/
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002d8c:	69fb      	ldr	r3, [r7, #28]
 8002d8e:	f003 0308 	and.w	r3, r3, #8
 8002d92:	2b08      	cmp	r3, #8
 8002d94:	f040 80c3 	bne.w	8002f1e <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
 8002d98:	697b      	ldr	r3, [r7, #20]
 8002d9a:	f003 0320 	and.w	r3, r3, #32
 8002d9e:	2b00      	cmp	r3, #0
 8002da0:	f000 80bd 	beq.w	8002f1e <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002da4:	687b      	ldr	r3, [r7, #4]
 8002da6:	681b      	ldr	r3, [r3, #0]
 8002da8:	685a      	ldr	r2, [r3, #4]
 8002daa:	687b      	ldr	r3, [r7, #4]
 8002dac:	681b      	ldr	r3, [r3, #0]
 8002dae:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002db2:	605a      	str	r2, [r3, #4]

      /* Disable RXNE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002db4:	687b      	ldr	r3, [r7, #4]
 8002db6:	681b      	ldr	r3, [r3, #0]
 8002db8:	4a49      	ldr	r2, [pc, #292]	@ (8002ee0 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002dba:	4293      	cmp	r3, r2
 8002dbc:	d101      	bne.n	8002dc2 <HAL_I2SEx_FullDuplex_IRQHandler+0x142>
 8002dbe:	4b49      	ldr	r3, [pc, #292]	@ (8002ee4 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002dc0:	e001      	b.n	8002dc6 <HAL_I2SEx_FullDuplex_IRQHandler+0x146>
 8002dc2:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002dc6:	685a      	ldr	r2, [r3, #4]
 8002dc8:	687b      	ldr	r3, [r7, #4]
 8002dca:	681b      	ldr	r3, [r3, #0]
 8002dcc:	4944      	ldr	r1, [pc, #272]	@ (8002ee0 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002dce:	428b      	cmp	r3, r1
 8002dd0:	d101      	bne.n	8002dd6 <HAL_I2SEx_FullDuplex_IRQHandler+0x156>
 8002dd2:	4b44      	ldr	r3, [pc, #272]	@ (8002ee4 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002dd4:	e001      	b.n	8002dda <HAL_I2SEx_FullDuplex_IRQHandler+0x15a>
 8002dd6:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002dda:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002dde:	605a      	str	r2, [r3, #4]

      /* Clear underrun flag */
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 8002de0:	2300      	movs	r3, #0
 8002de2:	60bb      	str	r3, [r7, #8]
 8002de4:	687b      	ldr	r3, [r7, #4]
 8002de6:	681b      	ldr	r3, [r3, #0]
 8002de8:	689b      	ldr	r3, [r3, #8]
 8002dea:	60bb      	str	r3, [r7, #8]
 8002dec:	68bb      	ldr	r3, [r7, #8]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002dee:	687b      	ldr	r3, [r7, #4]
 8002df0:	2201      	movs	r2, #1
 8002df2:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 8002df6:	687b      	ldr	r3, [r7, #4]
 8002df8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002dfa:	f043 0204 	orr.w	r2, r3, #4
 8002dfe:	687b      	ldr	r3, [r7, #4]
 8002e00:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002e02:	6878      	ldr	r0, [r7, #4]
 8002e04:	f7ff fe4a 	bl	8002a9c <HAL_I2S_ErrorCallback>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002e08:	e089      	b.n	8002f1e <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
  }
  /* The I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX Mode is selected */
  else
  {
    /* I2Sext in mode Transmitter ----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2sextcr2 & I2S_IT_TXE) != RESET))
 8002e0a:	69bb      	ldr	r3, [r7, #24]
 8002e0c:	f003 0302 	and.w	r3, r3, #2
 8002e10:	2b02      	cmp	r3, #2
 8002e12:	d107      	bne.n	8002e24 <HAL_I2SEx_FullDuplex_IRQHandler+0x1a4>
 8002e14:	693b      	ldr	r3, [r7, #16]
 8002e16:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002e1a:	2b00      	cmp	r3, #0
 8002e1c:	d002      	beq.n	8002e24 <HAL_I2SEx_FullDuplex_IRQHandler+0x1a4>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
      the I2Sext TXE interrupt will be generated to manage the full-duplex transmit phase. */
      I2SEx_TxISR_I2SExt(hi2s);
 8002e1e:	6878      	ldr	r0, [r7, #4]
 8002e20:	f000 f8be 	bl	8002fa0 <I2SEx_TxISR_I2SExt>
    }

    /* I2S in mode Receiver --------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2scr2 & I2S_IT_RXNE) != RESET))
 8002e24:	69fb      	ldr	r3, [r7, #28]
 8002e26:	f003 0301 	and.w	r3, r3, #1
 8002e2a:	2b01      	cmp	r3, #1
 8002e2c:	d107      	bne.n	8002e3e <HAL_I2SEx_FullDuplex_IRQHandler+0x1be>
 8002e2e:	697b      	ldr	r3, [r7, #20]
 8002e30:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002e34:	2b00      	cmp	r3, #0
 8002e36:	d002      	beq.n	8002e3e <HAL_I2SEx_FullDuplex_IRQHandler+0x1be>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
      the I2S RXNE interrupt will be generated to manage the full-duplex receive phase. */
      I2SEx_RxISR_I2S(hi2s);
 8002e38:	6878      	ldr	r0, [r7, #4]
 8002e3a:	f000 f8fd 	bl	8003038 <I2SEx_RxISR_I2S>
    }

    /* I2S Overrun error interrupt occurred -------------------------------------*/
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002e3e:	69fb      	ldr	r3, [r7, #28]
 8002e40:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002e44:	2b40      	cmp	r3, #64	@ 0x40
 8002e46:	d12f      	bne.n	8002ea8 <HAL_I2SEx_FullDuplex_IRQHandler+0x228>
 8002e48:	697b      	ldr	r3, [r7, #20]
 8002e4a:	f003 0320 	and.w	r3, r3, #32
 8002e4e:	2b00      	cmp	r3, #0
 8002e50:	d02a      	beq.n	8002ea8 <HAL_I2SEx_FullDuplex_IRQHandler+0x228>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002e52:	687b      	ldr	r3, [r7, #4]
 8002e54:	681b      	ldr	r3, [r3, #0]
 8002e56:	685a      	ldr	r2, [r3, #4]
 8002e58:	687b      	ldr	r3, [r7, #4]
 8002e5a:	681b      	ldr	r3, [r3, #0]
 8002e5c:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002e60:	605a      	str	r2, [r3, #4]

      /* Disable TXE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002e62:	687b      	ldr	r3, [r7, #4]
 8002e64:	681b      	ldr	r3, [r3, #0]
 8002e66:	4a1e      	ldr	r2, [pc, #120]	@ (8002ee0 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002e68:	4293      	cmp	r3, r2
 8002e6a:	d101      	bne.n	8002e70 <HAL_I2SEx_FullDuplex_IRQHandler+0x1f0>
 8002e6c:	4b1d      	ldr	r3, [pc, #116]	@ (8002ee4 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002e6e:	e001      	b.n	8002e74 <HAL_I2SEx_FullDuplex_IRQHandler+0x1f4>
 8002e70:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002e74:	685a      	ldr	r2, [r3, #4]
 8002e76:	687b      	ldr	r3, [r7, #4]
 8002e78:	681b      	ldr	r3, [r3, #0]
 8002e7a:	4919      	ldr	r1, [pc, #100]	@ (8002ee0 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002e7c:	428b      	cmp	r3, r1
 8002e7e:	d101      	bne.n	8002e84 <HAL_I2SEx_FullDuplex_IRQHandler+0x204>
 8002e80:	4b18      	ldr	r3, [pc, #96]	@ (8002ee4 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002e82:	e001      	b.n	8002e88 <HAL_I2SEx_FullDuplex_IRQHandler+0x208>
 8002e84:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002e88:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002e8c:	605a      	str	r2, [r3, #4]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002e8e:	687b      	ldr	r3, [r7, #4]
 8002e90:	2201      	movs	r2, #1
 8002e92:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8002e96:	687b      	ldr	r3, [r7, #4]
 8002e98:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002e9a:	f043 0202 	orr.w	r2, r3, #2
 8002e9e:	687b      	ldr	r3, [r7, #4]
 8002ea0:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002ea2:	6878      	ldr	r0, [r7, #4]
 8002ea4:	f7ff fdfa 	bl	8002a9c <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }

    /* I2Sext Underrun error interrupt occurred -------------------------------*/
    if (((i2sextsr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 8002ea8:	69bb      	ldr	r3, [r7, #24]
 8002eaa:	f003 0308 	and.w	r3, r3, #8
 8002eae:	2b08      	cmp	r3, #8
 8002eb0:	d136      	bne.n	8002f20 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
 8002eb2:	693b      	ldr	r3, [r7, #16]
 8002eb4:	f003 0320 	and.w	r3, r3, #32
 8002eb8:	2b00      	cmp	r3, #0
 8002eba:	d031      	beq.n	8002f20 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002ebc:	687b      	ldr	r3, [r7, #4]
 8002ebe:	681b      	ldr	r3, [r3, #0]
 8002ec0:	4a07      	ldr	r2, [pc, #28]	@ (8002ee0 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002ec2:	4293      	cmp	r3, r2
 8002ec4:	d101      	bne.n	8002eca <HAL_I2SEx_FullDuplex_IRQHandler+0x24a>
 8002ec6:	4b07      	ldr	r3, [pc, #28]	@ (8002ee4 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002ec8:	e001      	b.n	8002ece <HAL_I2SEx_FullDuplex_IRQHandler+0x24e>
 8002eca:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002ece:	685a      	ldr	r2, [r3, #4]
 8002ed0:	687b      	ldr	r3, [r7, #4]
 8002ed2:	681b      	ldr	r3, [r3, #0]
 8002ed4:	4902      	ldr	r1, [pc, #8]	@ (8002ee0 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002ed6:	428b      	cmp	r3, r1
 8002ed8:	d106      	bne.n	8002ee8 <HAL_I2SEx_FullDuplex_IRQHandler+0x268>
 8002eda:	4b02      	ldr	r3, [pc, #8]	@ (8002ee4 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002edc:	e006      	b.n	8002eec <HAL_I2SEx_FullDuplex_IRQHandler+0x26c>
 8002ede:	bf00      	nop
 8002ee0:	40003800 	.word	0x40003800
 8002ee4:	40003400 	.word	0x40003400
 8002ee8:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002eec:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002ef0:	605a      	str	r2, [r3, #4]

      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002ef2:	687b      	ldr	r3, [r7, #4]
 8002ef4:	681b      	ldr	r3, [r3, #0]
 8002ef6:	685a      	ldr	r2, [r3, #4]
 8002ef8:	687b      	ldr	r3, [r7, #4]
 8002efa:	681b      	ldr	r3, [r3, #0]
 8002efc:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002f00:	605a      	str	r2, [r3, #4]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002f02:	687b      	ldr	r3, [r7, #4]
 8002f04:	2201      	movs	r2, #1
 8002f06:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 8002f0a:	687b      	ldr	r3, [r7, #4]
 8002f0c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002f0e:	f043 0204 	orr.w	r2, r3, #4
 8002f12:	687b      	ldr	r3, [r7, #4]
 8002f14:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002f16:	6878      	ldr	r0, [r7, #4]
 8002f18:	f7ff fdc0 	bl	8002a9c <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002f1c:	e000      	b.n	8002f20 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002f1e:	bf00      	nop
}
 8002f20:	bf00      	nop
 8002f22:	3720      	adds	r7, #32
 8002f24:	46bd      	mov	sp, r7
 8002f26:	bd80      	pop	{r7, pc}

08002f28 <HAL_I2SEx_TxRxCpltCallback>:
  * @brief  Tx and Rx Transfer completed callback
  * @param  hi2s I2S handle
  * @retval None
  */
__weak void HAL_I2SEx_TxRxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8002f28:	b480      	push	{r7}
 8002f2a:	b083      	sub	sp, #12
 8002f2c:	af00      	add	r7, sp, #0
 8002f2e:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2SEx_TxRxCpltCallback could be implemented in the user file
   */
}
 8002f30:	bf00      	nop
 8002f32:	370c      	adds	r7, #12
 8002f34:	46bd      	mov	sp, r7
 8002f36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f3a:	4770      	bx	lr

08002f3c <I2SEx_TxISR_I2S>:
  * @brief  I2S Full-Duplex IT handler transmit function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_TxISR_I2S(I2S_HandleTypeDef *hi2s)
{
 8002f3c:	b580      	push	{r7, lr}
 8002f3e:	b082      	sub	sp, #8
 8002f40:	af00      	add	r7, sp, #0
 8002f42:	6078      	str	r0, [r7, #4]
  /* Write Data on DR register */
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr++);
 8002f44:	687b      	ldr	r3, [r7, #4]
 8002f46:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002f48:	1c99      	adds	r1, r3, #2
 8002f4a:	687a      	ldr	r2, [r7, #4]
 8002f4c:	6251      	str	r1, [r2, #36]	@ 0x24
 8002f4e:	881a      	ldrh	r2, [r3, #0]
 8002f50:	687b      	ldr	r3, [r7, #4]
 8002f52:	681b      	ldr	r3, [r3, #0]
 8002f54:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 8002f56:	687b      	ldr	r3, [r7, #4]
 8002f58:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002f5a:	b29b      	uxth	r3, r3
 8002f5c:	3b01      	subs	r3, #1
 8002f5e:	b29a      	uxth	r2, r3
 8002f60:	687b      	ldr	r3, [r7, #4]
 8002f62:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 8002f64:	687b      	ldr	r3, [r7, #4]
 8002f66:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002f68:	b29b      	uxth	r3, r3
 8002f6a:	2b00      	cmp	r3, #0
 8002f6c:	d113      	bne.n	8002f96 <I2SEx_TxISR_I2S+0x5a>
  {
    /* Disable TXE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002f6e:	687b      	ldr	r3, [r7, #4]
 8002f70:	681b      	ldr	r3, [r3, #0]
 8002f72:	685a      	ldr	r2, [r3, #4]
 8002f74:	687b      	ldr	r3, [r7, #4]
 8002f76:	681b      	ldr	r3, [r3, #0]
 8002f78:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002f7c:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 8002f7e:	687b      	ldr	r3, [r7, #4]
 8002f80:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002f82:	b29b      	uxth	r3, r3
 8002f84:	2b00      	cmp	r3, #0
 8002f86:	d106      	bne.n	8002f96 <I2SEx_TxISR_I2S+0x5a>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8002f88:	687b      	ldr	r3, [r7, #4]
 8002f8a:	2201      	movs	r2, #1
 8002f8c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8002f90:	6878      	ldr	r0, [r7, #4]
 8002f92:	f7ff ffc9 	bl	8002f28 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002f96:	bf00      	nop
 8002f98:	3708      	adds	r7, #8
 8002f9a:	46bd      	mov	sp, r7
 8002f9c:	bd80      	pop	{r7, pc}
	...

08002fa0 <I2SEx_TxISR_I2SExt>:
  * @brief  I2SExt Full-Duplex IT handler transmit function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_TxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
 8002fa0:	b580      	push	{r7, lr}
 8002fa2:	b082      	sub	sp, #8
 8002fa4:	af00      	add	r7, sp, #0
 8002fa6:	6078      	str	r0, [r7, #4]
  /* Write Data on DR register */
  I2SxEXT(hi2s->Instance)->DR = (*hi2s->pTxBuffPtr++);
 8002fa8:	687b      	ldr	r3, [r7, #4]
 8002faa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002fac:	1c99      	adds	r1, r3, #2
 8002fae:	687a      	ldr	r2, [r7, #4]
 8002fb0:	6251      	str	r1, [r2, #36]	@ 0x24
 8002fb2:	8819      	ldrh	r1, [r3, #0]
 8002fb4:	687b      	ldr	r3, [r7, #4]
 8002fb6:	681b      	ldr	r3, [r3, #0]
 8002fb8:	4a1d      	ldr	r2, [pc, #116]	@ (8003030 <I2SEx_TxISR_I2SExt+0x90>)
 8002fba:	4293      	cmp	r3, r2
 8002fbc:	d101      	bne.n	8002fc2 <I2SEx_TxISR_I2SExt+0x22>
 8002fbe:	4b1d      	ldr	r3, [pc, #116]	@ (8003034 <I2SEx_TxISR_I2SExt+0x94>)
 8002fc0:	e001      	b.n	8002fc6 <I2SEx_TxISR_I2SExt+0x26>
 8002fc2:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002fc6:	460a      	mov	r2, r1
 8002fc8:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 8002fca:	687b      	ldr	r3, [r7, #4]
 8002fcc:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002fce:	b29b      	uxth	r3, r3
 8002fd0:	3b01      	subs	r3, #1
 8002fd2:	b29a      	uxth	r2, r3
 8002fd4:	687b      	ldr	r3, [r7, #4]
 8002fd6:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 8002fd8:	687b      	ldr	r3, [r7, #4]
 8002fda:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002fdc:	b29b      	uxth	r3, r3
 8002fde:	2b00      	cmp	r3, #0
 8002fe0:	d121      	bne.n	8003026 <I2SEx_TxISR_I2SExt+0x86>
  {
    /* Disable I2Sext TXE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002fe2:	687b      	ldr	r3, [r7, #4]
 8002fe4:	681b      	ldr	r3, [r3, #0]
 8002fe6:	4a12      	ldr	r2, [pc, #72]	@ (8003030 <I2SEx_TxISR_I2SExt+0x90>)
 8002fe8:	4293      	cmp	r3, r2
 8002fea:	d101      	bne.n	8002ff0 <I2SEx_TxISR_I2SExt+0x50>
 8002fec:	4b11      	ldr	r3, [pc, #68]	@ (8003034 <I2SEx_TxISR_I2SExt+0x94>)
 8002fee:	e001      	b.n	8002ff4 <I2SEx_TxISR_I2SExt+0x54>
 8002ff0:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002ff4:	685a      	ldr	r2, [r3, #4]
 8002ff6:	687b      	ldr	r3, [r7, #4]
 8002ff8:	681b      	ldr	r3, [r3, #0]
 8002ffa:	490d      	ldr	r1, [pc, #52]	@ (8003030 <I2SEx_TxISR_I2SExt+0x90>)
 8002ffc:	428b      	cmp	r3, r1
 8002ffe:	d101      	bne.n	8003004 <I2SEx_TxISR_I2SExt+0x64>
 8003000:	4b0c      	ldr	r3, [pc, #48]	@ (8003034 <I2SEx_TxISR_I2SExt+0x94>)
 8003002:	e001      	b.n	8003008 <I2SEx_TxISR_I2SExt+0x68>
 8003004:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8003008:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 800300c:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 800300e:	687b      	ldr	r3, [r7, #4]
 8003010:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8003012:	b29b      	uxth	r3, r3
 8003014:	2b00      	cmp	r3, #0
 8003016:	d106      	bne.n	8003026 <I2SEx_TxISR_I2SExt+0x86>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8003018:	687b      	ldr	r3, [r7, #4]
 800301a:	2201      	movs	r2, #1
 800301c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8003020:	6878      	ldr	r0, [r7, #4]
 8003022:	f7ff ff81 	bl	8002f28 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8003026:	bf00      	nop
 8003028:	3708      	adds	r7, #8
 800302a:	46bd      	mov	sp, r7
 800302c:	bd80      	pop	{r7, pc}
 800302e:	bf00      	nop
 8003030:	40003800 	.word	0x40003800
 8003034:	40003400 	.word	0x40003400

08003038 <I2SEx_RxISR_I2S>:
  * @brief  I2S Full-Duplex IT handler receive function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_RxISR_I2S(I2S_HandleTypeDef *hi2s)
{
 8003038:	b580      	push	{r7, lr}
 800303a:	b082      	sub	sp, #8
 800303c:	af00      	add	r7, sp, #0
 800303e:	6078      	str	r0, [r7, #4]
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = hi2s->Instance->DR;
 8003040:	687b      	ldr	r3, [r7, #4]
 8003042:	681b      	ldr	r3, [r3, #0]
 8003044:	68d8      	ldr	r0, [r3, #12]
 8003046:	687b      	ldr	r3, [r7, #4]
 8003048:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800304a:	1c99      	adds	r1, r3, #2
 800304c:	687a      	ldr	r2, [r7, #4]
 800304e:	62d1      	str	r1, [r2, #44]	@ 0x2c
 8003050:	b282      	uxth	r2, r0
 8003052:	801a      	strh	r2, [r3, #0]
  hi2s->RxXferCount--;
 8003054:	687b      	ldr	r3, [r7, #4]
 8003056:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8003058:	b29b      	uxth	r3, r3
 800305a:	3b01      	subs	r3, #1
 800305c:	b29a      	uxth	r2, r3
 800305e:	687b      	ldr	r3, [r7, #4]
 8003060:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 8003062:	687b      	ldr	r3, [r7, #4]
 8003064:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8003066:	b29b      	uxth	r3, r3
 8003068:	2b00      	cmp	r3, #0
 800306a:	d113      	bne.n	8003094 <I2SEx_RxISR_I2S+0x5c>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800306c:	687b      	ldr	r3, [r7, #4]
 800306e:	681b      	ldr	r3, [r3, #0]
 8003070:	685a      	ldr	r2, [r3, #4]
 8003072:	687b      	ldr	r3, [r7, #4]
 8003074:	681b      	ldr	r3, [r3, #0]
 8003076:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800307a:	605a      	str	r2, [r3, #4]

    if (hi2s->TxXferCount == 0U)
 800307c:	687b      	ldr	r3, [r7, #4]
 800307e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8003080:	b29b      	uxth	r3, r3
 8003082:	2b00      	cmp	r3, #0
 8003084:	d106      	bne.n	8003094 <I2SEx_RxISR_I2S+0x5c>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8003086:	687b      	ldr	r3, [r7, #4]
 8003088:	2201      	movs	r2, #1
 800308a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800308e:	6878      	ldr	r0, [r7, #4]
 8003090:	f7ff ff4a 	bl	8002f28 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8003094:	bf00      	nop
 8003096:	3708      	adds	r7, #8
 8003098:	46bd      	mov	sp, r7
 800309a:	bd80      	pop	{r7, pc}

0800309c <I2SEx_RxISR_I2SExt>:
  * @brief  I2SExt Full-Duplex IT handler receive function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_RxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
 800309c:	b580      	push	{r7, lr}
 800309e:	b082      	sub	sp, #8
 80030a0:	af00      	add	r7, sp, #0
 80030a2:	6078      	str	r0, [r7, #4]
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = I2SxEXT(hi2s->Instance)->DR;
 80030a4:	687b      	ldr	r3, [r7, #4]
 80030a6:	681b      	ldr	r3, [r3, #0]
 80030a8:	4a20      	ldr	r2, [pc, #128]	@ (800312c <I2SEx_RxISR_I2SExt+0x90>)
 80030aa:	4293      	cmp	r3, r2
 80030ac:	d101      	bne.n	80030b2 <I2SEx_RxISR_I2SExt+0x16>
 80030ae:	4b20      	ldr	r3, [pc, #128]	@ (8003130 <I2SEx_RxISR_I2SExt+0x94>)
 80030b0:	e001      	b.n	80030b6 <I2SEx_RxISR_I2SExt+0x1a>
 80030b2:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 80030b6:	68d8      	ldr	r0, [r3, #12]
 80030b8:	687b      	ldr	r3, [r7, #4]
 80030ba:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80030bc:	1c99      	adds	r1, r3, #2
 80030be:	687a      	ldr	r2, [r7, #4]
 80030c0:	62d1      	str	r1, [r2, #44]	@ 0x2c
 80030c2:	b282      	uxth	r2, r0
 80030c4:	801a      	strh	r2, [r3, #0]
  hi2s->RxXferCount--;
 80030c6:	687b      	ldr	r3, [r7, #4]
 80030c8:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 80030ca:	b29b      	uxth	r3, r3
 80030cc:	3b01      	subs	r3, #1
 80030ce:	b29a      	uxth	r2, r3
 80030d0:	687b      	ldr	r3, [r7, #4]
 80030d2:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 80030d4:	687b      	ldr	r3, [r7, #4]
 80030d6:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 80030d8:	b29b      	uxth	r3, r3
 80030da:	2b00      	cmp	r3, #0
 80030dc:	d121      	bne.n	8003122 <I2SEx_RxISR_I2SExt+0x86>
  {
    /* Disable I2Sext RXNE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80030de:	687b      	ldr	r3, [r7, #4]
 80030e0:	681b      	ldr	r3, [r3, #0]
 80030e2:	4a12      	ldr	r2, [pc, #72]	@ (800312c <I2SEx_RxISR_I2SExt+0x90>)
 80030e4:	4293      	cmp	r3, r2
 80030e6:	d101      	bne.n	80030ec <I2SEx_RxISR_I2SExt+0x50>
 80030e8:	4b11      	ldr	r3, [pc, #68]	@ (8003130 <I2SEx_RxISR_I2SExt+0x94>)
 80030ea:	e001      	b.n	80030f0 <I2SEx_RxISR_I2SExt+0x54>
 80030ec:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 80030f0:	685a      	ldr	r2, [r3, #4]
 80030f2:	687b      	ldr	r3, [r7, #4]
 80030f4:	681b      	ldr	r3, [r3, #0]
 80030f6:	490d      	ldr	r1, [pc, #52]	@ (800312c <I2SEx_RxISR_I2SExt+0x90>)
 80030f8:	428b      	cmp	r3, r1
 80030fa:	d101      	bne.n	8003100 <I2SEx_RxISR_I2SExt+0x64>
 80030fc:	4b0c      	ldr	r3, [pc, #48]	@ (8003130 <I2SEx_RxISR_I2SExt+0x94>)
 80030fe:	e001      	b.n	8003104 <I2SEx_RxISR_I2SExt+0x68>
 8003100:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8003104:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8003108:	605a      	str	r2, [r3, #4]

    if (hi2s->TxXferCount == 0U)
 800310a:	687b      	ldr	r3, [r7, #4]
 800310c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800310e:	b29b      	uxth	r3, r3
 8003110:	2b00      	cmp	r3, #0
 8003112:	d106      	bne.n	8003122 <I2SEx_RxISR_I2SExt+0x86>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8003114:	687b      	ldr	r3, [r7, #4]
 8003116:	2201      	movs	r2, #1
 8003118:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800311c:	6878      	ldr	r0, [r7, #4]
 800311e:	f7ff ff03 	bl	8002f28 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8003122:	bf00      	nop
 8003124:	3708      	adds	r7, #8
 8003126:	46bd      	mov	sp, r7
 8003128:	bd80      	pop	{r7, pc}
 800312a:	bf00      	nop
 800312c:	40003800 	.word	0x40003800
 8003130:	40003400 	.word	0x40003400

08003134 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 8003134:	b580      	push	{r7, lr}
 8003136:	b086      	sub	sp, #24
 8003138:	af02      	add	r7, sp, #8
 800313a:	6078      	str	r0, [r7, #4]
  const USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 800313c:	687b      	ldr	r3, [r7, #4]
 800313e:	2b00      	cmp	r3, #0
 8003140:	d101      	bne.n	8003146 <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 8003142:	2301      	movs	r3, #1
 8003144:	e101      	b.n	800334a <HAL_PCD_Init+0x216>

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
 8003146:	687b      	ldr	r3, [r7, #4]
 8003148:	681b      	ldr	r3, [r3, #0]
 800314a:	60bb      	str	r3, [r7, #8]
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
 800314c:	687b      	ldr	r3, [r7, #4]
 800314e:	f893 3495 	ldrb.w	r3, [r3, #1173]	@ 0x495
 8003152:	b2db      	uxtb	r3, r3
 8003154:	2b00      	cmp	r3, #0
 8003156:	d106      	bne.n	8003166 <HAL_PCD_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 8003158:	687b      	ldr	r3, [r7, #4]
 800315a:	2200      	movs	r2, #0
 800315c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 8003160:	6878      	ldr	r0, [r7, #4]
 8003162:	f024 fee7 	bl	8027f34 <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 8003166:	687b      	ldr	r3, [r7, #4]
 8003168:	2203      	movs	r2, #3
 800316a:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

#if defined (USB_OTG_FS)
  /* Disable DMA mode for FS instance */
  if (USBx == USB_OTG_FS)
 800316e:	68bb      	ldr	r3, [r7, #8]
 8003170:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8003174:	d102      	bne.n	800317c <HAL_PCD_Init+0x48>
  {
    hpcd->Init.dma_enable = 0U;
 8003176:	687b      	ldr	r3, [r7, #4]
 8003178:	2200      	movs	r2, #0
 800317a:	719a      	strb	r2, [r3, #6]
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 800317c:	687b      	ldr	r3, [r7, #4]
 800317e:	681b      	ldr	r3, [r3, #0]
 8003180:	4618      	mov	r0, r3
 8003182:	f002 fa3a 	bl	80055fa <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8003186:	687b      	ldr	r3, [r7, #4]
 8003188:	6818      	ldr	r0, [r3, #0]
 800318a:	687b      	ldr	r3, [r7, #4]
 800318c:	7c1a      	ldrb	r2, [r3, #16]
 800318e:	f88d 2000 	strb.w	r2, [sp]
 8003192:	3304      	adds	r3, #4
 8003194:	cb0e      	ldmia	r3, {r1, r2, r3}
 8003196:	f002 f918 	bl	80053ca <USB_CoreInit>
 800319a:	4603      	mov	r3, r0
 800319c:	2b00      	cmp	r3, #0
 800319e:	d005      	beq.n	80031ac <HAL_PCD_Init+0x78>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 80031a0:	687b      	ldr	r3, [r7, #4]
 80031a2:	2202      	movs	r2, #2
 80031a4:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 80031a8:	2301      	movs	r3, #1
 80031aa:	e0ce      	b.n	800334a <HAL_PCD_Init+0x216>
  }

  /* Force Device Mode */
  if (USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE) != HAL_OK)
 80031ac:	687b      	ldr	r3, [r7, #4]
 80031ae:	681b      	ldr	r3, [r3, #0]
 80031b0:	2100      	movs	r1, #0
 80031b2:	4618      	mov	r0, r3
 80031b4:	f002 fa32 	bl	800561c <USB_SetCurrentMode>
 80031b8:	4603      	mov	r3, r0
 80031ba:	2b00      	cmp	r3, #0
 80031bc:	d005      	beq.n	80031ca <HAL_PCD_Init+0x96>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 80031be:	687b      	ldr	r3, [r7, #4]
 80031c0:	2202      	movs	r2, #2
 80031c2:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 80031c6:	2301      	movs	r3, #1
 80031c8:	e0bf      	b.n	800334a <HAL_PCD_Init+0x216>
  }

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80031ca:	2300      	movs	r3, #0
 80031cc:	73fb      	strb	r3, [r7, #15]
 80031ce:	e04a      	b.n	8003266 <HAL_PCD_Init+0x132>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 80031d0:	7bfa      	ldrb	r2, [r7, #15]
 80031d2:	6879      	ldr	r1, [r7, #4]
 80031d4:	4613      	mov	r3, r2
 80031d6:	00db      	lsls	r3, r3, #3
 80031d8:	4413      	add	r3, r2
 80031da:	009b      	lsls	r3, r3, #2
 80031dc:	440b      	add	r3, r1
 80031de:	3315      	adds	r3, #21
 80031e0:	2201      	movs	r2, #1
 80031e2:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 80031e4:	7bfa      	ldrb	r2, [r7, #15]
 80031e6:	6879      	ldr	r1, [r7, #4]
 80031e8:	4613      	mov	r3, r2
 80031ea:	00db      	lsls	r3, r3, #3
 80031ec:	4413      	add	r3, r2
 80031ee:	009b      	lsls	r3, r3, #2
 80031f0:	440b      	add	r3, r1
 80031f2:	3314      	adds	r3, #20
 80031f4:	7bfa      	ldrb	r2, [r7, #15]
 80031f6:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
 80031f8:	7bfa      	ldrb	r2, [r7, #15]
 80031fa:	7bfb      	ldrb	r3, [r7, #15]
 80031fc:	b298      	uxth	r0, r3
 80031fe:	6879      	ldr	r1, [r7, #4]
 8003200:	4613      	mov	r3, r2
 8003202:	00db      	lsls	r3, r3, #3
 8003204:	4413      	add	r3, r2
 8003206:	009b      	lsls	r3, r3, #2
 8003208:	440b      	add	r3, r1
 800320a:	332e      	adds	r3, #46	@ 0x2e
 800320c:	4602      	mov	r2, r0
 800320e:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8003210:	7bfa      	ldrb	r2, [r7, #15]
 8003212:	6879      	ldr	r1, [r7, #4]
 8003214:	4613      	mov	r3, r2
 8003216:	00db      	lsls	r3, r3, #3
 8003218:	4413      	add	r3, r2
 800321a:	009b      	lsls	r3, r3, #2
 800321c:	440b      	add	r3, r1
 800321e:	3318      	adds	r3, #24
 8003220:	2200      	movs	r2, #0
 8003222:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 8003224:	7bfa      	ldrb	r2, [r7, #15]
 8003226:	6879      	ldr	r1, [r7, #4]
 8003228:	4613      	mov	r3, r2
 800322a:	00db      	lsls	r3, r3, #3
 800322c:	4413      	add	r3, r2
 800322e:	009b      	lsls	r3, r3, #2
 8003230:	440b      	add	r3, r1
 8003232:	331c      	adds	r3, #28
 8003234:	2200      	movs	r2, #0
 8003236:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 8003238:	7bfa      	ldrb	r2, [r7, #15]
 800323a:	6879      	ldr	r1, [r7, #4]
 800323c:	4613      	mov	r3, r2
 800323e:	00db      	lsls	r3, r3, #3
 8003240:	4413      	add	r3, r2
 8003242:	009b      	lsls	r3, r3, #2
 8003244:	440b      	add	r3, r1
 8003246:	3320      	adds	r3, #32
 8003248:	2200      	movs	r2, #0
 800324a:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 800324c:	7bfa      	ldrb	r2, [r7, #15]
 800324e:	6879      	ldr	r1, [r7, #4]
 8003250:	4613      	mov	r3, r2
 8003252:	00db      	lsls	r3, r3, #3
 8003254:	4413      	add	r3, r2
 8003256:	009b      	lsls	r3, r3, #2
 8003258:	440b      	add	r3, r1
 800325a:	3324      	adds	r3, #36	@ 0x24
 800325c:	2200      	movs	r2, #0
 800325e:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003260:	7bfb      	ldrb	r3, [r7, #15]
 8003262:	3301      	adds	r3, #1
 8003264:	73fb      	strb	r3, [r7, #15]
 8003266:	687b      	ldr	r3, [r7, #4]
 8003268:	791b      	ldrb	r3, [r3, #4]
 800326a:	7bfa      	ldrb	r2, [r7, #15]
 800326c:	429a      	cmp	r2, r3
 800326e:	d3af      	bcc.n	80031d0 <HAL_PCD_Init+0x9c>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003270:	2300      	movs	r3, #0
 8003272:	73fb      	strb	r3, [r7, #15]
 8003274:	e044      	b.n	8003300 <HAL_PCD_Init+0x1cc>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 8003276:	7bfa      	ldrb	r2, [r7, #15]
 8003278:	6879      	ldr	r1, [r7, #4]
 800327a:	4613      	mov	r3, r2
 800327c:	00db      	lsls	r3, r3, #3
 800327e:	4413      	add	r3, r2
 8003280:	009b      	lsls	r3, r3, #2
 8003282:	440b      	add	r3, r1
 8003284:	f203 2355 	addw	r3, r3, #597	@ 0x255
 8003288:	2200      	movs	r2, #0
 800328a:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 800328c:	7bfa      	ldrb	r2, [r7, #15]
 800328e:	6879      	ldr	r1, [r7, #4]
 8003290:	4613      	mov	r3, r2
 8003292:	00db      	lsls	r3, r3, #3
 8003294:	4413      	add	r3, r2
 8003296:	009b      	lsls	r3, r3, #2
 8003298:	440b      	add	r3, r1
 800329a:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 800329e:	7bfa      	ldrb	r2, [r7, #15]
 80032a0:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80032a2:	7bfa      	ldrb	r2, [r7, #15]
 80032a4:	6879      	ldr	r1, [r7, #4]
 80032a6:	4613      	mov	r3, r2
 80032a8:	00db      	lsls	r3, r3, #3
 80032aa:	4413      	add	r3, r2
 80032ac:	009b      	lsls	r3, r3, #2
 80032ae:	440b      	add	r3, r1
 80032b0:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 80032b4:	2200      	movs	r2, #0
 80032b6:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 80032b8:	7bfa      	ldrb	r2, [r7, #15]
 80032ba:	6879      	ldr	r1, [r7, #4]
 80032bc:	4613      	mov	r3, r2
 80032be:	00db      	lsls	r3, r3, #3
 80032c0:	4413      	add	r3, r2
 80032c2:	009b      	lsls	r3, r3, #2
 80032c4:	440b      	add	r3, r1
 80032c6:	f503 7317 	add.w	r3, r3, #604	@ 0x25c
 80032ca:	2200      	movs	r2, #0
 80032cc:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80032ce:	7bfa      	ldrb	r2, [r7, #15]
 80032d0:	6879      	ldr	r1, [r7, #4]
 80032d2:	4613      	mov	r3, r2
 80032d4:	00db      	lsls	r3, r3, #3
 80032d6:	4413      	add	r3, r2
 80032d8:	009b      	lsls	r3, r3, #2
 80032da:	440b      	add	r3, r1
 80032dc:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 80032e0:	2200      	movs	r2, #0
 80032e2:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 80032e4:	7bfa      	ldrb	r2, [r7, #15]
 80032e6:	6879      	ldr	r1, [r7, #4]
 80032e8:	4613      	mov	r3, r2
 80032ea:	00db      	lsls	r3, r3, #3
 80032ec:	4413      	add	r3, r2
 80032ee:	009b      	lsls	r3, r3, #2
 80032f0:	440b      	add	r3, r1
 80032f2:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 80032f6:	2200      	movs	r2, #0
 80032f8:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80032fa:	7bfb      	ldrb	r3, [r7, #15]
 80032fc:	3301      	adds	r3, #1
 80032fe:	73fb      	strb	r3, [r7, #15]
 8003300:	687b      	ldr	r3, [r7, #4]
 8003302:	791b      	ldrb	r3, [r3, #4]
 8003304:	7bfa      	ldrb	r2, [r7, #15]
 8003306:	429a      	cmp	r2, r3
 8003308:	d3b5      	bcc.n	8003276 <HAL_PCD_Init+0x142>
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800330a:	687b      	ldr	r3, [r7, #4]
 800330c:	6818      	ldr	r0, [r3, #0]
 800330e:	687b      	ldr	r3, [r7, #4]
 8003310:	7c1a      	ldrb	r2, [r3, #16]
 8003312:	f88d 2000 	strb.w	r2, [sp]
 8003316:	3304      	adds	r3, #4
 8003318:	cb0e      	ldmia	r3, {r1, r2, r3}
 800331a:	f002 f9cb 	bl	80056b4 <USB_DevInit>
 800331e:	4603      	mov	r3, r0
 8003320:	2b00      	cmp	r3, #0
 8003322:	d005      	beq.n	8003330 <HAL_PCD_Init+0x1fc>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 8003324:	687b      	ldr	r3, [r7, #4]
 8003326:	2202      	movs	r2, #2
 8003328:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 800332c:	2301      	movs	r3, #1
 800332e:	e00c      	b.n	800334a <HAL_PCD_Init+0x216>
  }

  hpcd->USB_Address = 0U;
 8003330:	687b      	ldr	r3, [r7, #4]
 8003332:	2200      	movs	r2, #0
 8003334:	745a      	strb	r2, [r3, #17]
  hpcd->State = HAL_PCD_STATE_READY;
 8003336:	687b      	ldr	r3, [r7, #4]
 8003338:	2201      	movs	r2, #1
 800333a:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    (void)HAL_PCDEx_ActivateLPM(hpcd);
  }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */
  (void)USB_DevDisconnect(hpcd->Instance);
 800333e:	687b      	ldr	r3, [r7, #4]
 8003340:	681b      	ldr	r3, [r3, #0]
 8003342:	4618      	mov	r0, r3
 8003344:	f003 fa15 	bl	8006772 <USB_DevDisconnect>

  return HAL_OK;
 8003348:	2300      	movs	r3, #0
}
 800334a:	4618      	mov	r0, r3
 800334c:	3710      	adds	r7, #16
 800334e:	46bd      	mov	sp, r7
 8003350:	bd80      	pop	{r7, pc}

08003352 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 8003352:	b580      	push	{r7, lr}
 8003354:	b084      	sub	sp, #16
 8003356:	af00      	add	r7, sp, #0
 8003358:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800335a:	687b      	ldr	r3, [r7, #4]
 800335c:	681b      	ldr	r3, [r3, #0]
 800335e:	60fb      	str	r3, [r7, #12]

  __HAL_LOCK(hpcd);
 8003360:	687b      	ldr	r3, [r7, #4]
 8003362:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003366:	2b01      	cmp	r3, #1
 8003368:	d101      	bne.n	800336e <HAL_PCD_Start+0x1c>
 800336a:	2302      	movs	r3, #2
 800336c:	e022      	b.n	80033b4 <HAL_PCD_Start+0x62>
 800336e:	687b      	ldr	r3, [r7, #4]
 8003370:	2201      	movs	r2, #1
 8003372:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 8003376:	68fb      	ldr	r3, [r7, #12]
 8003378:	68db      	ldr	r3, [r3, #12]
 800337a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800337e:	2b00      	cmp	r3, #0
 8003380:	d009      	beq.n	8003396 <HAL_PCD_Start+0x44>
      (hpcd->Init.battery_charging_enable == 1U))
 8003382:	687b      	ldr	r3, [r7, #4]
 8003384:	7b5b      	ldrb	r3, [r3, #13]
  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 8003386:	2b01      	cmp	r3, #1
 8003388:	d105      	bne.n	8003396 <HAL_PCD_Start+0x44>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800338a:	68fb      	ldr	r3, [r7, #12]
 800338c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800338e:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 8003392:	68fb      	ldr	r3, [r7, #12]
 8003394:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  __HAL_PCD_ENABLE(hpcd);
 8003396:	687b      	ldr	r3, [r7, #4]
 8003398:	681b      	ldr	r3, [r3, #0]
 800339a:	4618      	mov	r0, r3
 800339c:	f002 f91c 	bl	80055d8 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 80033a0:	687b      	ldr	r3, [r7, #4]
 80033a2:	681b      	ldr	r3, [r3, #0]
 80033a4:	4618      	mov	r0, r3
 80033a6:	f003 f9c3 	bl	8006730 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 80033aa:	687b      	ldr	r3, [r7, #4]
 80033ac:	2200      	movs	r2, #0
 80033ae:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 80033b2:	2300      	movs	r3, #0
}
 80033b4:	4618      	mov	r0, r3
 80033b6:	3710      	adds	r7, #16
 80033b8:	46bd      	mov	sp, r7
 80033ba:	bd80      	pop	{r7, pc}

080033bc <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 80033bc:	b590      	push	{r4, r7, lr}
 80033be:	b08d      	sub	sp, #52	@ 0x34
 80033c0:	af00      	add	r7, sp, #0
 80033c2:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80033c4:	687b      	ldr	r3, [r7, #4]
 80033c6:	681b      	ldr	r3, [r3, #0]
 80033c8:	623b      	str	r3, [r7, #32]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80033ca:	6a3b      	ldr	r3, [r7, #32]
 80033cc:	61fb      	str	r3, [r7, #28]
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 80033ce:	687b      	ldr	r3, [r7, #4]
 80033d0:	681b      	ldr	r3, [r3, #0]
 80033d2:	4618      	mov	r0, r3
 80033d4:	f003 fa81 	bl	80068da <USB_GetMode>
 80033d8:	4603      	mov	r3, r0
 80033da:	2b00      	cmp	r3, #0
 80033dc:	f040 848c 	bne.w	8003cf8 <HAL_PCD_IRQHandler+0x93c>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 80033e0:	687b      	ldr	r3, [r7, #4]
 80033e2:	681b      	ldr	r3, [r3, #0]
 80033e4:	4618      	mov	r0, r3
 80033e6:	f003 f9e5 	bl	80067b4 <USB_ReadInterrupts>
 80033ea:	4603      	mov	r3, r0
 80033ec:	2b00      	cmp	r3, #0
 80033ee:	f000 8482 	beq.w	8003cf6 <HAL_PCD_IRQHandler+0x93a>
    {
      return;
    }

    /* store current frame number */
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 80033f2:	69fb      	ldr	r3, [r7, #28]
 80033f4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80033f8:	689b      	ldr	r3, [r3, #8]
 80033fa:	0a1b      	lsrs	r3, r3, #8
 80033fc:	f3c3 020d 	ubfx	r2, r3, #0, #14
 8003400:	687b      	ldr	r3, [r7, #4]
 8003402:	f8c3 24d4 	str.w	r2, [r3, #1236]	@ 0x4d4

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8003406:	687b      	ldr	r3, [r7, #4]
 8003408:	681b      	ldr	r3, [r3, #0]
 800340a:	4618      	mov	r0, r3
 800340c:	f003 f9d2 	bl	80067b4 <USB_ReadInterrupts>
 8003410:	4603      	mov	r3, r0
 8003412:	f003 0302 	and.w	r3, r3, #2
 8003416:	2b02      	cmp	r3, #2
 8003418:	d107      	bne.n	800342a <HAL_PCD_IRQHandler+0x6e>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 800341a:	687b      	ldr	r3, [r7, #4]
 800341c:	681b      	ldr	r3, [r3, #0]
 800341e:	695a      	ldr	r2, [r3, #20]
 8003420:	687b      	ldr	r3, [r7, #4]
 8003422:	681b      	ldr	r3, [r3, #0]
 8003424:	f002 0202 	and.w	r2, r2, #2
 8003428:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 800342a:	687b      	ldr	r3, [r7, #4]
 800342c:	681b      	ldr	r3, [r3, #0]
 800342e:	4618      	mov	r0, r3
 8003430:	f003 f9c0 	bl	80067b4 <USB_ReadInterrupts>
 8003434:	4603      	mov	r3, r0
 8003436:	f003 0310 	and.w	r3, r3, #16
 800343a:	2b10      	cmp	r3, #16
 800343c:	d161      	bne.n	8003502 <HAL_PCD_IRQHandler+0x146>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800343e:	687b      	ldr	r3, [r7, #4]
 8003440:	681b      	ldr	r3, [r3, #0]
 8003442:	699a      	ldr	r2, [r3, #24]
 8003444:	687b      	ldr	r3, [r7, #4]
 8003446:	681b      	ldr	r3, [r3, #0]
 8003448:	f022 0210 	bic.w	r2, r2, #16
 800344c:	619a      	str	r2, [r3, #24]

      RegVal = USBx->GRXSTSP;
 800344e:	6a3b      	ldr	r3, [r7, #32]
 8003450:	6a1b      	ldr	r3, [r3, #32]
 8003452:	61bb      	str	r3, [r7, #24]

      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 8003454:	69bb      	ldr	r3, [r7, #24]
 8003456:	f003 020f 	and.w	r2, r3, #15
 800345a:	4613      	mov	r3, r2
 800345c:	00db      	lsls	r3, r3, #3
 800345e:	4413      	add	r3, r2
 8003460:	009b      	lsls	r3, r3, #2
 8003462:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003466:	687a      	ldr	r2, [r7, #4]
 8003468:	4413      	add	r3, r2
 800346a:	3304      	adds	r3, #4
 800346c:	617b      	str	r3, [r7, #20]

      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800346e:	69bb      	ldr	r3, [r7, #24]
 8003470:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
 8003474:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8003478:	d124      	bne.n	80034c4 <HAL_PCD_IRQHandler+0x108>
      {
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 800347a:	69ba      	ldr	r2, [r7, #24]
 800347c:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
 8003480:	4013      	ands	r3, r2
 8003482:	2b00      	cmp	r3, #0
 8003484:	d035      	beq.n	80034f2 <HAL_PCD_IRQHandler+0x136>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8003486:	697b      	ldr	r3, [r7, #20]
 8003488:	68d9      	ldr	r1, [r3, #12]
                               (uint16_t)((RegVal & USB_OTG_GRXSTSP_BCNT) >> 4));
 800348a:	69bb      	ldr	r3, [r7, #24]
 800348c:	091b      	lsrs	r3, r3, #4
 800348e:	b29b      	uxth	r3, r3
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8003490:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8003494:	b29b      	uxth	r3, r3
 8003496:	461a      	mov	r2, r3
 8003498:	6a38      	ldr	r0, [r7, #32]
 800349a:	f002 fff7 	bl	800648c <USB_ReadPacket>

          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800349e:	697b      	ldr	r3, [r7, #20]
 80034a0:	68da      	ldr	r2, [r3, #12]
 80034a2:	69bb      	ldr	r3, [r7, #24]
 80034a4:	091b      	lsrs	r3, r3, #4
 80034a6:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80034aa:	441a      	add	r2, r3
 80034ac:	697b      	ldr	r3, [r7, #20]
 80034ae:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 80034b0:	697b      	ldr	r3, [r7, #20]
 80034b2:	695a      	ldr	r2, [r3, #20]
 80034b4:	69bb      	ldr	r3, [r7, #24]
 80034b6:	091b      	lsrs	r3, r3, #4
 80034b8:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80034bc:	441a      	add	r2, r3
 80034be:	697b      	ldr	r3, [r7, #20]
 80034c0:	615a      	str	r2, [r3, #20]
 80034c2:	e016      	b.n	80034f2 <HAL_PCD_IRQHandler+0x136>
        }
      }
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 80034c4:	69bb      	ldr	r3, [r7, #24]
 80034c6:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
 80034ca:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 80034ce:	d110      	bne.n	80034f2 <HAL_PCD_IRQHandler+0x136>
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 80034d0:	687b      	ldr	r3, [r7, #4]
 80034d2:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 80034d6:	2208      	movs	r2, #8
 80034d8:	4619      	mov	r1, r3
 80034da:	6a38      	ldr	r0, [r7, #32]
 80034dc:	f002 ffd6 	bl	800648c <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 80034e0:	697b      	ldr	r3, [r7, #20]
 80034e2:	695a      	ldr	r2, [r3, #20]
 80034e4:	69bb      	ldr	r3, [r7, #24]
 80034e6:	091b      	lsrs	r3, r3, #4
 80034e8:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80034ec:	441a      	add	r2, r3
 80034ee:	697b      	ldr	r3, [r7, #20]
 80034f0:	615a      	str	r2, [r3, #20]
      else
      {
        /* ... */
      }

      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80034f2:	687b      	ldr	r3, [r7, #4]
 80034f4:	681b      	ldr	r3, [r3, #0]
 80034f6:	699a      	ldr	r2, [r3, #24]
 80034f8:	687b      	ldr	r3, [r7, #4]
 80034fa:	681b      	ldr	r3, [r3, #0]
 80034fc:	f042 0210 	orr.w	r2, r2, #16
 8003500:	619a      	str	r2, [r3, #24]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8003502:	687b      	ldr	r3, [r7, #4]
 8003504:	681b      	ldr	r3, [r3, #0]
 8003506:	4618      	mov	r0, r3
 8003508:	f003 f954 	bl	80067b4 <USB_ReadInterrupts>
 800350c:	4603      	mov	r3, r0
 800350e:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8003512:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 8003516:	f040 80a7 	bne.w	8003668 <HAL_PCD_IRQHandler+0x2ac>
    {
      epnum = 0U;
 800351a:	2300      	movs	r3, #0
 800351c:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 800351e:	687b      	ldr	r3, [r7, #4]
 8003520:	681b      	ldr	r3, [r3, #0]
 8003522:	4618      	mov	r0, r3
 8003524:	f003 f959 	bl	80067da <USB_ReadDevAllOutEpInterrupt>
 8003528:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (ep_intr != 0U)
 800352a:	e099      	b.n	8003660 <HAL_PCD_IRQHandler+0x2a4>
      {
        if ((ep_intr & 0x1U) != 0U)
 800352c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800352e:	f003 0301 	and.w	r3, r3, #1
 8003532:	2b00      	cmp	r3, #0
 8003534:	f000 808e 	beq.w	8003654 <HAL_PCD_IRQHandler+0x298>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8003538:	687b      	ldr	r3, [r7, #4]
 800353a:	681b      	ldr	r3, [r3, #0]
 800353c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800353e:	b2d2      	uxtb	r2, r2
 8003540:	4611      	mov	r1, r2
 8003542:	4618      	mov	r0, r3
 8003544:	f003 f97d 	bl	8006842 <USB_ReadDevOutEPInterrupt>
 8003548:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 800354a:	693b      	ldr	r3, [r7, #16]
 800354c:	f003 0301 	and.w	r3, r3, #1
 8003550:	2b00      	cmp	r3, #0
 8003552:	d00c      	beq.n	800356e <HAL_PCD_IRQHandler+0x1b2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8003554:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003556:	015a      	lsls	r2, r3, #5
 8003558:	69fb      	ldr	r3, [r7, #28]
 800355a:	4413      	add	r3, r2
 800355c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003560:	461a      	mov	r2, r3
 8003562:	2301      	movs	r3, #1
 8003564:	6093      	str	r3, [r2, #8]
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
 8003566:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8003568:	6878      	ldr	r0, [r7, #4]
 800356a:	f000 fea3 	bl	80042b4 <PCD_EP_OutXfrComplete_int>
          }

          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 800356e:	693b      	ldr	r3, [r7, #16]
 8003570:	f003 0308 	and.w	r3, r3, #8
 8003574:	2b00      	cmp	r3, #0
 8003576:	d00c      	beq.n	8003592 <HAL_PCD_IRQHandler+0x1d6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8003578:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800357a:	015a      	lsls	r2, r3, #5
 800357c:	69fb      	ldr	r3, [r7, #28]
 800357e:	4413      	add	r3, r2
 8003580:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003584:	461a      	mov	r2, r3
 8003586:	2308      	movs	r3, #8
 8003588:	6093      	str	r3, [r2, #8]
            /* Class B setup phase done for previous decoded setup */
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
 800358a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800358c:	6878      	ldr	r0, [r7, #4]
 800358e:	f000 ff79 	bl	8004484 <PCD_EP_OutSetupPacket_int>
          }

          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8003592:	693b      	ldr	r3, [r7, #16]
 8003594:	f003 0310 	and.w	r3, r3, #16
 8003598:	2b00      	cmp	r3, #0
 800359a:	d008      	beq.n	80035ae <HAL_PCD_IRQHandler+0x1f2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 800359c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800359e:	015a      	lsls	r2, r3, #5
 80035a0:	69fb      	ldr	r3, [r7, #28]
 80035a2:	4413      	add	r3, r2
 80035a4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80035a8:	461a      	mov	r2, r3
 80035aa:	2310      	movs	r3, #16
 80035ac:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT Endpoint disable interrupt */
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 80035ae:	693b      	ldr	r3, [r7, #16]
 80035b0:	f003 0302 	and.w	r3, r3, #2
 80035b4:	2b00      	cmp	r3, #0
 80035b6:	d030      	beq.n	800361a <HAL_PCD_IRQHandler+0x25e>
          {
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 80035b8:	6a3b      	ldr	r3, [r7, #32]
 80035ba:	695b      	ldr	r3, [r3, #20]
 80035bc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80035c0:	2b80      	cmp	r3, #128	@ 0x80
 80035c2:	d109      	bne.n	80035d8 <HAL_PCD_IRQHandler+0x21c>
            {
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 80035c4:	69fb      	ldr	r3, [r7, #28]
 80035c6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80035ca:	685b      	ldr	r3, [r3, #4]
 80035cc:	69fa      	ldr	r2, [r7, #28]
 80035ce:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80035d2:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 80035d6:	6053      	str	r3, [r2, #4]
            }

            ep = &hpcd->OUT_ep[epnum];
 80035d8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80035da:	4613      	mov	r3, r2
 80035dc:	00db      	lsls	r3, r3, #3
 80035de:	4413      	add	r3, r2
 80035e0:	009b      	lsls	r3, r3, #2
 80035e2:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 80035e6:	687a      	ldr	r2, [r7, #4]
 80035e8:	4413      	add	r3, r2
 80035ea:	3304      	adds	r3, #4
 80035ec:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 80035ee:	697b      	ldr	r3, [r7, #20]
 80035f0:	78db      	ldrb	r3, [r3, #3]
 80035f2:	2b01      	cmp	r3, #1
 80035f4:	d108      	bne.n	8003608 <HAL_PCD_IRQHandler+0x24c>
            {
              ep->is_iso_incomplete = 0U;
 80035f6:	697b      	ldr	r3, [r7, #20]
 80035f8:	2200      	movs	r2, #0
 80035fa:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 80035fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80035fe:	b2db      	uxtb	r3, r3
 8003600:	4619      	mov	r1, r3
 8003602:	6878      	ldr	r0, [r7, #4]
 8003604:	f024 fdaa 	bl	802815c <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 8003608:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800360a:	015a      	lsls	r2, r3, #5
 800360c:	69fb      	ldr	r3, [r7, #28]
 800360e:	4413      	add	r3, r2
 8003610:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003614:	461a      	mov	r2, r3
 8003616:	2302      	movs	r3, #2
 8003618:	6093      	str	r3, [r2, #8]
          }

          /* Clear Status Phase Received interrupt */
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 800361a:	693b      	ldr	r3, [r7, #16]
 800361c:	f003 0320 	and.w	r3, r3, #32
 8003620:	2b00      	cmp	r3, #0
 8003622:	d008      	beq.n	8003636 <HAL_PCD_IRQHandler+0x27a>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8003624:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003626:	015a      	lsls	r2, r3, #5
 8003628:	69fb      	ldr	r3, [r7, #28]
 800362a:	4413      	add	r3, r2
 800362c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003630:	461a      	mov	r2, r3
 8003632:	2320      	movs	r3, #32
 8003634:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT NAK interrupt */
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 8003636:	693b      	ldr	r3, [r7, #16]
 8003638:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800363c:	2b00      	cmp	r3, #0
 800363e:	d009      	beq.n	8003654 <HAL_PCD_IRQHandler+0x298>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 8003640:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003642:	015a      	lsls	r2, r3, #5
 8003644:	69fb      	ldr	r3, [r7, #28]
 8003646:	4413      	add	r3, r2
 8003648:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800364c:	461a      	mov	r2, r3
 800364e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8003652:	6093      	str	r3, [r2, #8]
          }
        }
        epnum++;
 8003654:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003656:	3301      	adds	r3, #1
 8003658:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 800365a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800365c:	085b      	lsrs	r3, r3, #1
 800365e:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 8003660:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8003662:	2b00      	cmp	r3, #0
 8003664:	f47f af62 	bne.w	800352c <HAL_PCD_IRQHandler+0x170>
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8003668:	687b      	ldr	r3, [r7, #4]
 800366a:	681b      	ldr	r3, [r3, #0]
 800366c:	4618      	mov	r0, r3
 800366e:	f003 f8a1 	bl	80067b4 <USB_ReadInterrupts>
 8003672:	4603      	mov	r3, r0
 8003674:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8003678:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800367c:	f040 80db 	bne.w	8003836 <HAL_PCD_IRQHandler+0x47a>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8003680:	687b      	ldr	r3, [r7, #4]
 8003682:	681b      	ldr	r3, [r3, #0]
 8003684:	4618      	mov	r0, r3
 8003686:	f003 f8c2 	bl	800680e <USB_ReadDevAllInEpInterrupt>
 800368a:	62b8      	str	r0, [r7, #40]	@ 0x28

      epnum = 0U;
 800368c:	2300      	movs	r3, #0
 800368e:	627b      	str	r3, [r7, #36]	@ 0x24

      while (ep_intr != 0U)
 8003690:	e0cd      	b.n	800382e <HAL_PCD_IRQHandler+0x472>
      {
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8003692:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8003694:	f003 0301 	and.w	r3, r3, #1
 8003698:	2b00      	cmp	r3, #0
 800369a:	f000 80c2 	beq.w	8003822 <HAL_PCD_IRQHandler+0x466>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800369e:	687b      	ldr	r3, [r7, #4]
 80036a0:	681b      	ldr	r3, [r3, #0]
 80036a2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80036a4:	b2d2      	uxtb	r2, r2
 80036a6:	4611      	mov	r1, r2
 80036a8:	4618      	mov	r0, r3
 80036aa:	f003 f8e8 	bl	800687e <USB_ReadDevInEPInterrupt>
 80036ae:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 80036b0:	693b      	ldr	r3, [r7, #16]
 80036b2:	f003 0301 	and.w	r3, r3, #1
 80036b6:	2b00      	cmp	r3, #0
 80036b8:	d057      	beq.n	800376a <HAL_PCD_IRQHandler+0x3ae>
          {
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 80036ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80036bc:	f003 030f 	and.w	r3, r3, #15
 80036c0:	2201      	movs	r2, #1
 80036c2:	fa02 f303 	lsl.w	r3, r2, r3
 80036c6:	60fb      	str	r3, [r7, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80036c8:	69fb      	ldr	r3, [r7, #28]
 80036ca:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80036ce:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80036d0:	68fb      	ldr	r3, [r7, #12]
 80036d2:	43db      	mvns	r3, r3
 80036d4:	69f9      	ldr	r1, [r7, #28]
 80036d6:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80036da:	4013      	ands	r3, r2
 80036dc:	634b      	str	r3, [r1, #52]	@ 0x34

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 80036de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80036e0:	015a      	lsls	r2, r3, #5
 80036e2:	69fb      	ldr	r3, [r7, #28]
 80036e4:	4413      	add	r3, r2
 80036e6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80036ea:	461a      	mov	r2, r3
 80036ec:	2301      	movs	r3, #1
 80036ee:	6093      	str	r3, [r2, #8]

            if (hpcd->Init.dma_enable == 1U)
 80036f0:	687b      	ldr	r3, [r7, #4]
 80036f2:	799b      	ldrb	r3, [r3, #6]
 80036f4:	2b01      	cmp	r3, #1
 80036f6:	d132      	bne.n	800375e <HAL_PCD_IRQHandler+0x3a2>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 80036f8:	6879      	ldr	r1, [r7, #4]
 80036fa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80036fc:	4613      	mov	r3, r2
 80036fe:	00db      	lsls	r3, r3, #3
 8003700:	4413      	add	r3, r2
 8003702:	009b      	lsls	r3, r3, #2
 8003704:	440b      	add	r3, r1
 8003706:	3320      	adds	r3, #32
 8003708:	6819      	ldr	r1, [r3, #0]
 800370a:	6878      	ldr	r0, [r7, #4]
 800370c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800370e:	4613      	mov	r3, r2
 8003710:	00db      	lsls	r3, r3, #3
 8003712:	4413      	add	r3, r2
 8003714:	009b      	lsls	r3, r3, #2
 8003716:	4403      	add	r3, r0
 8003718:	331c      	adds	r3, #28
 800371a:	681b      	ldr	r3, [r3, #0]
 800371c:	4419      	add	r1, r3
 800371e:	6878      	ldr	r0, [r7, #4]
 8003720:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003722:	4613      	mov	r3, r2
 8003724:	00db      	lsls	r3, r3, #3
 8003726:	4413      	add	r3, r2
 8003728:	009b      	lsls	r3, r3, #2
 800372a:	4403      	add	r3, r0
 800372c:	3320      	adds	r3, #32
 800372e:	6019      	str	r1, [r3, #0]

              /* this is ZLP, so prepare EP0 for next setup */
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8003730:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003732:	2b00      	cmp	r3, #0
 8003734:	d113      	bne.n	800375e <HAL_PCD_IRQHandler+0x3a2>
 8003736:	6879      	ldr	r1, [r7, #4]
 8003738:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800373a:	4613      	mov	r3, r2
 800373c:	00db      	lsls	r3, r3, #3
 800373e:	4413      	add	r3, r2
 8003740:	009b      	lsls	r3, r3, #2
 8003742:	440b      	add	r3, r1
 8003744:	3324      	adds	r3, #36	@ 0x24
 8003746:	681b      	ldr	r3, [r3, #0]
 8003748:	2b00      	cmp	r3, #0
 800374a:	d108      	bne.n	800375e <HAL_PCD_IRQHandler+0x3a2>
              {
                /* prepare to rx more setup packets */
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800374c:	687b      	ldr	r3, [r7, #4]
 800374e:	6818      	ldr	r0, [r3, #0]
 8003750:	687b      	ldr	r3, [r7, #4]
 8003752:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8003756:	461a      	mov	r2, r3
 8003758:	2101      	movs	r1, #1
 800375a:	f003 f8ef 	bl	800693c <USB_EP0_OutStart>
            }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
#else
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 800375e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003760:	b2db      	uxtb	r3, r3
 8003762:	4619      	mov	r1, r3
 8003764:	6878      	ldr	r0, [r7, #4]
 8003766:	f024 fc74 	bl	8028052 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 800376a:	693b      	ldr	r3, [r7, #16]
 800376c:	f003 0308 	and.w	r3, r3, #8
 8003770:	2b00      	cmp	r3, #0
 8003772:	d008      	beq.n	8003786 <HAL_PCD_IRQHandler+0x3ca>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8003774:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003776:	015a      	lsls	r2, r3, #5
 8003778:	69fb      	ldr	r3, [r7, #28]
 800377a:	4413      	add	r3, r2
 800377c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8003780:	461a      	mov	r2, r3
 8003782:	2308      	movs	r3, #8
 8003784:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8003786:	693b      	ldr	r3, [r7, #16]
 8003788:	f003 0310 	and.w	r3, r3, #16
 800378c:	2b00      	cmp	r3, #0
 800378e:	d008      	beq.n	80037a2 <HAL_PCD_IRQHandler+0x3e6>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8003790:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003792:	015a      	lsls	r2, r3, #5
 8003794:	69fb      	ldr	r3, [r7, #28]
 8003796:	4413      	add	r3, r2
 8003798:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800379c:	461a      	mov	r2, r3
 800379e:	2310      	movs	r3, #16
 80037a0:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 80037a2:	693b      	ldr	r3, [r7, #16]
 80037a4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80037a8:	2b00      	cmp	r3, #0
 80037aa:	d008      	beq.n	80037be <HAL_PCD_IRQHandler+0x402>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 80037ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80037ae:	015a      	lsls	r2, r3, #5
 80037b0:	69fb      	ldr	r3, [r7, #28]
 80037b2:	4413      	add	r3, r2
 80037b4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80037b8:	461a      	mov	r2, r3
 80037ba:	2340      	movs	r3, #64	@ 0x40
 80037bc:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 80037be:	693b      	ldr	r3, [r7, #16]
 80037c0:	f003 0302 	and.w	r3, r3, #2
 80037c4:	2b00      	cmp	r3, #0
 80037c6:	d023      	beq.n	8003810 <HAL_PCD_IRQHandler+0x454>
          {
            (void)USB_FlushTxFifo(USBx, epnum);
 80037c8:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80037ca:	6a38      	ldr	r0, [r7, #32]
 80037cc:	f002 f8d6 	bl	800597c <USB_FlushTxFifo>

            ep = &hpcd->IN_ep[epnum];
 80037d0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80037d2:	4613      	mov	r3, r2
 80037d4:	00db      	lsls	r3, r3, #3
 80037d6:	4413      	add	r3, r2
 80037d8:	009b      	lsls	r3, r3, #2
 80037da:	3310      	adds	r3, #16
 80037dc:	687a      	ldr	r2, [r7, #4]
 80037de:	4413      	add	r3, r2
 80037e0:	3304      	adds	r3, #4
 80037e2:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 80037e4:	697b      	ldr	r3, [r7, #20]
 80037e6:	78db      	ldrb	r3, [r3, #3]
 80037e8:	2b01      	cmp	r3, #1
 80037ea:	d108      	bne.n	80037fe <HAL_PCD_IRQHandler+0x442>
            {
              ep->is_iso_incomplete = 0U;
 80037ec:	697b      	ldr	r3, [r7, #20]
 80037ee:	2200      	movs	r2, #0
 80037f0:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 80037f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80037f4:	b2db      	uxtb	r3, r3
 80037f6:	4619      	mov	r1, r3
 80037f8:	6878      	ldr	r0, [r7, #4]
 80037fa:	f024 fcc1 	bl	8028180 <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 80037fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003800:	015a      	lsls	r2, r3, #5
 8003802:	69fb      	ldr	r3, [r7, #28]
 8003804:	4413      	add	r3, r2
 8003806:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800380a:	461a      	mov	r2, r3
 800380c:	2302      	movs	r3, #2
 800380e:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8003810:	693b      	ldr	r3, [r7, #16]
 8003812:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8003816:	2b00      	cmp	r3, #0
 8003818:	d003      	beq.n	8003822 <HAL_PCD_IRQHandler+0x466>
          {
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
 800381a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800381c:	6878      	ldr	r0, [r7, #4]
 800381e:	f000 fcbd 	bl	800419c <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
 8003822:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003824:	3301      	adds	r3, #1
 8003826:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 8003828:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800382a:	085b      	lsrs	r3, r3, #1
 800382c:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 800382e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8003830:	2b00      	cmp	r3, #0
 8003832:	f47f af2e 	bne.w	8003692 <HAL_PCD_IRQHandler+0x2d6>
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8003836:	687b      	ldr	r3, [r7, #4]
 8003838:	681b      	ldr	r3, [r3, #0]
 800383a:	4618      	mov	r0, r3
 800383c:	f002 ffba 	bl	80067b4 <USB_ReadInterrupts>
 8003840:	4603      	mov	r3, r0
 8003842:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8003846:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800384a:	d122      	bne.n	8003892 <HAL_PCD_IRQHandler+0x4d6>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800384c:	69fb      	ldr	r3, [r7, #28]
 800384e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003852:	685b      	ldr	r3, [r3, #4]
 8003854:	69fa      	ldr	r2, [r7, #28]
 8003856:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800385a:	f023 0301 	bic.w	r3, r3, #1
 800385e:	6053      	str	r3, [r2, #4]

      if (hpcd->LPM_State == LPM_L1)
 8003860:	687b      	ldr	r3, [r7, #4]
 8003862:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
 8003866:	2b01      	cmp	r3, #1
 8003868:	d108      	bne.n	800387c <HAL_PCD_IRQHandler+0x4c0>
      {
        hpcd->LPM_State = LPM_L0;
 800386a:	687b      	ldr	r3, [r7, #4]
 800386c:	2200      	movs	r2, #0
 800386e:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8003872:	2100      	movs	r1, #0
 8003874:	6878      	ldr	r0, [r7, #4]
 8003876:	f000 fea3 	bl	80045c0 <HAL_PCDEx_LPM_Callback>
 800387a:	e002      	b.n	8003882 <HAL_PCD_IRQHandler+0x4c6>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->ResumeCallback(hpcd);
#else
        HAL_PCD_ResumeCallback(hpcd);
 800387c:	6878      	ldr	r0, [r7, #4]
 800387e:	f024 fc5f 	bl	8028140 <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8003882:	687b      	ldr	r3, [r7, #4]
 8003884:	681b      	ldr	r3, [r3, #0]
 8003886:	695a      	ldr	r2, [r3, #20]
 8003888:	687b      	ldr	r3, [r7, #4]
 800388a:	681b      	ldr	r3, [r3, #0]
 800388c:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
 8003890:	615a      	str	r2, [r3, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8003892:	687b      	ldr	r3, [r7, #4]
 8003894:	681b      	ldr	r3, [r3, #0]
 8003896:	4618      	mov	r0, r3
 8003898:	f002 ff8c 	bl	80067b4 <USB_ReadInterrupts>
 800389c:	4603      	mov	r3, r0
 800389e:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 80038a2:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 80038a6:	d112      	bne.n	80038ce <HAL_PCD_IRQHandler+0x512>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80038a8:	69fb      	ldr	r3, [r7, #28]
 80038aa:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80038ae:	689b      	ldr	r3, [r3, #8]
 80038b0:	f003 0301 	and.w	r3, r3, #1
 80038b4:	2b01      	cmp	r3, #1
 80038b6:	d102      	bne.n	80038be <HAL_PCD_IRQHandler+0x502>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 80038b8:	6878      	ldr	r0, [r7, #4]
 80038ba:	f024 fc1b 	bl	80280f4 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80038be:	687b      	ldr	r3, [r7, #4]
 80038c0:	681b      	ldr	r3, [r3, #0]
 80038c2:	695a      	ldr	r2, [r3, #20]
 80038c4:	687b      	ldr	r3, [r7, #4]
 80038c6:	681b      	ldr	r3, [r3, #0]
 80038c8:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 80038cc:	615a      	str	r2, [r3, #20]
    }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */
    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 80038ce:	687b      	ldr	r3, [r7, #4]
 80038d0:	681b      	ldr	r3, [r3, #0]
 80038d2:	4618      	mov	r0, r3
 80038d4:	f002 ff6e 	bl	80067b4 <USB_ReadInterrupts>
 80038d8:	4603      	mov	r3, r0
 80038da:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 80038de:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80038e2:	f040 80b7 	bne.w	8003a54 <HAL_PCD_IRQHandler+0x698>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80038e6:	69fb      	ldr	r3, [r7, #28]
 80038e8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80038ec:	685b      	ldr	r3, [r3, #4]
 80038ee:	69fa      	ldr	r2, [r7, #28]
 80038f0:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80038f4:	f023 0301 	bic.w	r3, r3, #1
 80038f8:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 80038fa:	687b      	ldr	r3, [r7, #4]
 80038fc:	681b      	ldr	r3, [r3, #0]
 80038fe:	2110      	movs	r1, #16
 8003900:	4618      	mov	r0, r3
 8003902:	f002 f83b 	bl	800597c <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003906:	2300      	movs	r3, #0
 8003908:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800390a:	e046      	b.n	800399a <HAL_PCD_IRQHandler+0x5de>
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 800390c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800390e:	015a      	lsls	r2, r3, #5
 8003910:	69fb      	ldr	r3, [r7, #28]
 8003912:	4413      	add	r3, r2
 8003914:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8003918:	461a      	mov	r2, r3
 800391a:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 800391e:	6093      	str	r3, [r2, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8003920:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003922:	015a      	lsls	r2, r3, #5
 8003924:	69fb      	ldr	r3, [r7, #28]
 8003926:	4413      	add	r3, r2
 8003928:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800392c:	681b      	ldr	r3, [r3, #0]
 800392e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8003930:	0151      	lsls	r1, r2, #5
 8003932:	69fa      	ldr	r2, [r7, #28]
 8003934:	440a      	add	r2, r1
 8003936:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800393a:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 800393e:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8003940:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003942:	015a      	lsls	r2, r3, #5
 8003944:	69fb      	ldr	r3, [r7, #28]
 8003946:	4413      	add	r3, r2
 8003948:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800394c:	461a      	mov	r2, r3
 800394e:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8003952:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8003954:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003956:	015a      	lsls	r2, r3, #5
 8003958:	69fb      	ldr	r3, [r7, #28]
 800395a:	4413      	add	r3, r2
 800395c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003960:	681b      	ldr	r3, [r3, #0]
 8003962:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8003964:	0151      	lsls	r1, r2, #5
 8003966:	69fa      	ldr	r2, [r7, #28]
 8003968:	440a      	add	r2, r1
 800396a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800396e:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8003972:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8003974:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003976:	015a      	lsls	r2, r3, #5
 8003978:	69fb      	ldr	r3, [r7, #28]
 800397a:	4413      	add	r3, r2
 800397c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003980:	681b      	ldr	r3, [r3, #0]
 8003982:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8003984:	0151      	lsls	r1, r2, #5
 8003986:	69fa      	ldr	r2, [r7, #28]
 8003988:	440a      	add	r2, r1
 800398a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800398e:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8003992:	6013      	str	r3, [r2, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003994:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003996:	3301      	adds	r3, #1
 8003998:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800399a:	687b      	ldr	r3, [r7, #4]
 800399c:	791b      	ldrb	r3, [r3, #4]
 800399e:	461a      	mov	r2, r3
 80039a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80039a2:	4293      	cmp	r3, r2
 80039a4:	d3b2      	bcc.n	800390c <HAL_PCD_IRQHandler+0x550>
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 80039a6:	69fb      	ldr	r3, [r7, #28]
 80039a8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80039ac:	69db      	ldr	r3, [r3, #28]
 80039ae:	69fa      	ldr	r2, [r7, #28]
 80039b0:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80039b4:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
 80039b8:	61d3      	str	r3, [r2, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
 80039ba:	687b      	ldr	r3, [r7, #4]
 80039bc:	7bdb      	ldrb	r3, [r3, #15]
 80039be:	2b00      	cmp	r3, #0
 80039c0:	d016      	beq.n	80039f0 <HAL_PCD_IRQHandler+0x634>
      {
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 80039c2:	69fb      	ldr	r3, [r7, #28]
 80039c4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80039c8:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 80039cc:	69fa      	ldr	r2, [r7, #28]
 80039ce:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80039d2:	f043 030b 	orr.w	r3, r3, #11
 80039d6:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                   USB_OTG_DOEPMSK_XFRCM |
                                   USB_OTG_DOEPMSK_EPDM;

        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 80039da:	69fb      	ldr	r3, [r7, #28]
 80039dc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80039e0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80039e2:	69fa      	ldr	r2, [r7, #28]
 80039e4:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80039e8:	f043 030b 	orr.w	r3, r3, #11
 80039ec:	6453      	str	r3, [r2, #68]	@ 0x44
 80039ee:	e015      	b.n	8003a1c <HAL_PCD_IRQHandler+0x660>
                                  USB_OTG_DIEPMSK_XFRCM |
                                  USB_OTG_DIEPMSK_EPDM;
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 80039f0:	69fb      	ldr	r3, [r7, #28]
 80039f2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80039f6:	695b      	ldr	r3, [r3, #20]
 80039f8:	69fa      	ldr	r2, [r7, #28]
 80039fa:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80039fe:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8003a02:	f043 032b 	orr.w	r3, r3, #43	@ 0x2b
 8003a06:	6153      	str	r3, [r2, #20]
                                USB_OTG_DOEPMSK_XFRCM |
                                USB_OTG_DOEPMSK_EPDM |
                                USB_OTG_DOEPMSK_OTEPSPRM |
                                USB_OTG_DOEPMSK_NAKM;

        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 8003a08:	69fb      	ldr	r3, [r7, #28]
 8003a0a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003a0e:	691b      	ldr	r3, [r3, #16]
 8003a10:	69fa      	ldr	r2, [r7, #28]
 8003a12:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003a16:	f043 030b 	orr.w	r3, r3, #11
 8003a1a:	6113      	str	r3, [r2, #16]
                                USB_OTG_DIEPMSK_XFRCM |
                                USB_OTG_DIEPMSK_EPDM;
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8003a1c:	69fb      	ldr	r3, [r7, #28]
 8003a1e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003a22:	681b      	ldr	r3, [r3, #0]
 8003a24:	69fa      	ldr	r2, [r7, #28]
 8003a26:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003a2a:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 8003a2e:	6013      	str	r3, [r2, #0]

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8003a30:	687b      	ldr	r3, [r7, #4]
 8003a32:	6818      	ldr	r0, [r3, #0]
 8003a34:	687b      	ldr	r3, [r7, #4]
 8003a36:	7999      	ldrb	r1, [r3, #6]
                             (uint8_t *)hpcd->Setup);
 8003a38:	687b      	ldr	r3, [r7, #4]
 8003a3a:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8003a3e:	461a      	mov	r2, r3
 8003a40:	f002 ff7c 	bl	800693c <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8003a44:	687b      	ldr	r3, [r7, #4]
 8003a46:	681b      	ldr	r3, [r3, #0]
 8003a48:	695a      	ldr	r2, [r3, #20]
 8003a4a:	687b      	ldr	r3, [r7, #4]
 8003a4c:	681b      	ldr	r3, [r3, #0]
 8003a4e:	f402 5280 	and.w	r2, r2, #4096	@ 0x1000
 8003a52:	615a      	str	r2, [r3, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8003a54:	687b      	ldr	r3, [r7, #4]
 8003a56:	681b      	ldr	r3, [r3, #0]
 8003a58:	4618      	mov	r0, r3
 8003a5a:	f002 feab 	bl	80067b4 <USB_ReadInterrupts>
 8003a5e:	4603      	mov	r3, r0
 8003a60:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8003a64:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8003a68:	d123      	bne.n	8003ab2 <HAL_PCD_IRQHandler+0x6f6>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
 8003a6a:	687b      	ldr	r3, [r7, #4]
 8003a6c:	681b      	ldr	r3, [r3, #0]
 8003a6e:	4618      	mov	r0, r3
 8003a70:	f002 ff41 	bl	80068f6 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8003a74:	687b      	ldr	r3, [r7, #4]
 8003a76:	681b      	ldr	r3, [r3, #0]
 8003a78:	4618      	mov	r0, r3
 8003a7a:	f001 fff8 	bl	8005a6e <USB_GetDevSpeed>
 8003a7e:	4603      	mov	r3, r0
 8003a80:	461a      	mov	r2, r3
 8003a82:	687b      	ldr	r3, [r7, #4]
 8003a84:	71da      	strb	r2, [r3, #7]

      /* Set USB Turnaround time */
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8003a86:	687b      	ldr	r3, [r7, #4]
 8003a88:	681c      	ldr	r4, [r3, #0]
 8003a8a:	f001 fa09 	bl	8004ea0 <HAL_RCC_GetHCLKFreq>
 8003a8e:	4601      	mov	r1, r0
                                  HAL_RCC_GetHCLKFreq(),
                                  (uint8_t)hpcd->Init.speed);
 8003a90:	687b      	ldr	r3, [r7, #4]
 8003a92:	79db      	ldrb	r3, [r3, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8003a94:	461a      	mov	r2, r3
 8003a96:	4620      	mov	r0, r4
 8003a98:	f001 fcfc 	bl	8005494 <USB_SetTurnaroundTime>

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
 8003a9c:	6878      	ldr	r0, [r7, #4]
 8003a9e:	f024 fb00 	bl	80280a2 <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8003aa2:	687b      	ldr	r3, [r7, #4]
 8003aa4:	681b      	ldr	r3, [r3, #0]
 8003aa6:	695a      	ldr	r2, [r3, #20]
 8003aa8:	687b      	ldr	r3, [r7, #4]
 8003aaa:	681b      	ldr	r3, [r3, #0]
 8003aac:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 8003ab0:	615a      	str	r2, [r3, #20]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8003ab2:	687b      	ldr	r3, [r7, #4]
 8003ab4:	681b      	ldr	r3, [r3, #0]
 8003ab6:	4618      	mov	r0, r3
 8003ab8:	f002 fe7c 	bl	80067b4 <USB_ReadInterrupts>
 8003abc:	4603      	mov	r3, r0
 8003abe:	f003 0308 	and.w	r3, r3, #8
 8003ac2:	2b08      	cmp	r3, #8
 8003ac4:	d10a      	bne.n	8003adc <HAL_PCD_IRQHandler+0x720>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
 8003ac6:	6878      	ldr	r0, [r7, #4]
 8003ac8:	f024 fadd 	bl	8028086 <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8003acc:	687b      	ldr	r3, [r7, #4]
 8003ace:	681b      	ldr	r3, [r3, #0]
 8003ad0:	695a      	ldr	r2, [r3, #20]
 8003ad2:	687b      	ldr	r3, [r7, #4]
 8003ad4:	681b      	ldr	r3, [r3, #0]
 8003ad6:	f002 0208 	and.w	r2, r2, #8
 8003ada:	615a      	str	r2, [r3, #20]
    }

    /* Handle Global OUT NAK effective Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 8003adc:	687b      	ldr	r3, [r7, #4]
 8003ade:	681b      	ldr	r3, [r3, #0]
 8003ae0:	4618      	mov	r0, r3
 8003ae2:	f002 fe67 	bl	80067b4 <USB_ReadInterrupts>
 8003ae6:	4603      	mov	r3, r0
 8003ae8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8003aec:	2b80      	cmp	r3, #128	@ 0x80
 8003aee:	d123      	bne.n	8003b38 <HAL_PCD_IRQHandler+0x77c>
    {
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 8003af0:	6a3b      	ldr	r3, [r7, #32]
 8003af2:	699b      	ldr	r3, [r3, #24]
 8003af4:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8003af8:	6a3b      	ldr	r3, [r7, #32]
 8003afa:	619a      	str	r2, [r3, #24]

      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003afc:	2301      	movs	r3, #1
 8003afe:	627b      	str	r3, [r7, #36]	@ 0x24
 8003b00:	e014      	b.n	8003b2c <HAL_PCD_IRQHandler+0x770>
      {
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8003b02:	6879      	ldr	r1, [r7, #4]
 8003b04:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003b06:	4613      	mov	r3, r2
 8003b08:	00db      	lsls	r3, r3, #3
 8003b0a:	4413      	add	r3, r2
 8003b0c:	009b      	lsls	r3, r3, #2
 8003b0e:	440b      	add	r3, r1
 8003b10:	f203 2357 	addw	r3, r3, #599	@ 0x257
 8003b14:	781b      	ldrb	r3, [r3, #0]
 8003b16:	2b01      	cmp	r3, #1
 8003b18:	d105      	bne.n	8003b26 <HAL_PCD_IRQHandler+0x76a>
        {
          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)epnum);
 8003b1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003b1c:	b2db      	uxtb	r3, r3
 8003b1e:	4619      	mov	r1, r3
 8003b20:	6878      	ldr	r0, [r7, #4]
 8003b22:	f000 fb0a 	bl	800413a <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003b26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003b28:	3301      	adds	r3, #1
 8003b2a:	627b      	str	r3, [r7, #36]	@ 0x24
 8003b2c:	687b      	ldr	r3, [r7, #4]
 8003b2e:	791b      	ldrb	r3, [r3, #4]
 8003b30:	461a      	mov	r2, r3
 8003b32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003b34:	4293      	cmp	r3, r2
 8003b36:	d3e4      	bcc.n	8003b02 <HAL_PCD_IRQHandler+0x746>
        }
      }
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8003b38:	687b      	ldr	r3, [r7, #4]
 8003b3a:	681b      	ldr	r3, [r3, #0]
 8003b3c:	4618      	mov	r0, r3
 8003b3e:	f002 fe39 	bl	80067b4 <USB_ReadInterrupts>
 8003b42:	4603      	mov	r3, r0
 8003b44:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8003b48:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8003b4c:	d13c      	bne.n	8003bc8 <HAL_PCD_IRQHandler+0x80c>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003b4e:	2301      	movs	r3, #1
 8003b50:	627b      	str	r3, [r7, #36]	@ 0x24
 8003b52:	e02b      	b.n	8003bac <HAL_PCD_IRQHandler+0x7f0>
      {
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8003b54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003b56:	015a      	lsls	r2, r3, #5
 8003b58:	69fb      	ldr	r3, [r7, #28]
 8003b5a:	4413      	add	r3, r2
 8003b5c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8003b60:	681b      	ldr	r3, [r3, #0]
 8003b62:	61bb      	str	r3, [r7, #24]

        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8003b64:	6879      	ldr	r1, [r7, #4]
 8003b66:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003b68:	4613      	mov	r3, r2
 8003b6a:	00db      	lsls	r3, r3, #3
 8003b6c:	4413      	add	r3, r2
 8003b6e:	009b      	lsls	r3, r3, #2
 8003b70:	440b      	add	r3, r1
 8003b72:	3318      	adds	r3, #24
 8003b74:	781b      	ldrb	r3, [r3, #0]
 8003b76:	2b01      	cmp	r3, #1
 8003b78:	d115      	bne.n	8003ba6 <HAL_PCD_IRQHandler+0x7ea>
            ((RegVal & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA))
 8003b7a:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8003b7c:	2b00      	cmp	r3, #0
 8003b7e:	da12      	bge.n	8003ba6 <HAL_PCD_IRQHandler+0x7ea>
        {
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8003b80:	6879      	ldr	r1, [r7, #4]
 8003b82:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003b84:	4613      	mov	r3, r2
 8003b86:	00db      	lsls	r3, r3, #3
 8003b88:	4413      	add	r3, r2
 8003b8a:	009b      	lsls	r3, r3, #2
 8003b8c:	440b      	add	r3, r1
 8003b8e:	3317      	adds	r3, #23
 8003b90:	2201      	movs	r2, #1
 8003b92:	701a      	strb	r2, [r3, #0]

          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
 8003b94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003b96:	b2db      	uxtb	r3, r3
 8003b98:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8003b9c:	b2db      	uxtb	r3, r3
 8003b9e:	4619      	mov	r1, r3
 8003ba0:	6878      	ldr	r0, [r7, #4]
 8003ba2:	f000 faca 	bl	800413a <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003ba6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003ba8:	3301      	adds	r3, #1
 8003baa:	627b      	str	r3, [r7, #36]	@ 0x24
 8003bac:	687b      	ldr	r3, [r7, #4]
 8003bae:	791b      	ldrb	r3, [r3, #4]
 8003bb0:	461a      	mov	r2, r3
 8003bb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003bb4:	4293      	cmp	r3, r2
 8003bb6:	d3cd      	bcc.n	8003b54 <HAL_PCD_IRQHandler+0x798>
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8003bb8:	687b      	ldr	r3, [r7, #4]
 8003bba:	681b      	ldr	r3, [r3, #0]
 8003bbc:	695a      	ldr	r2, [r3, #20]
 8003bbe:	687b      	ldr	r3, [r7, #4]
 8003bc0:	681b      	ldr	r3, [r3, #0]
 8003bc2:	f402 1280 	and.w	r2, r2, #1048576	@ 0x100000
 8003bc6:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8003bc8:	687b      	ldr	r3, [r7, #4]
 8003bca:	681b      	ldr	r3, [r3, #0]
 8003bcc:	4618      	mov	r0, r3
 8003bce:	f002 fdf1 	bl	80067b4 <USB_ReadInterrupts>
 8003bd2:	4603      	mov	r3, r0
 8003bd4:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8003bd8:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8003bdc:	d156      	bne.n	8003c8c <HAL_PCD_IRQHandler+0x8d0>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003bde:	2301      	movs	r3, #1
 8003be0:	627b      	str	r3, [r7, #36]	@ 0x24
 8003be2:	e045      	b.n	8003c70 <HAL_PCD_IRQHandler+0x8b4>
      {
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 8003be4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003be6:	015a      	lsls	r2, r3, #5
 8003be8:	69fb      	ldr	r3, [r7, #28]
 8003bea:	4413      	add	r3, r2
 8003bec:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003bf0:	681b      	ldr	r3, [r3, #0]
 8003bf2:	61bb      	str	r3, [r7, #24]

        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8003bf4:	6879      	ldr	r1, [r7, #4]
 8003bf6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003bf8:	4613      	mov	r3, r2
 8003bfa:	00db      	lsls	r3, r3, #3
 8003bfc:	4413      	add	r3, r2
 8003bfe:	009b      	lsls	r3, r3, #2
 8003c00:	440b      	add	r3, r1
 8003c02:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 8003c06:	781b      	ldrb	r3, [r3, #0]
 8003c08:	2b01      	cmp	r3, #1
 8003c0a:	d12e      	bne.n	8003c6a <HAL_PCD_IRQHandler+0x8ae>
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8003c0c:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8003c0e:	2b00      	cmp	r3, #0
 8003c10:	da2b      	bge.n	8003c6a <HAL_PCD_IRQHandler+0x8ae>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 8003c12:	69bb      	ldr	r3, [r7, #24]
 8003c14:	f403 3280 	and.w	r2, r3, #65536	@ 0x10000
 8003c18:	687b      	ldr	r3, [r7, #4]
 8003c1a:	f8d3 34d4 	ldr.w	r3, [r3, #1236]	@ 0x4d4
 8003c1e:	f003 0301 	and.w	r3, r3, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8003c22:	429a      	cmp	r2, r3
 8003c24:	d121      	bne.n	8003c6a <HAL_PCD_IRQHandler+0x8ae>
        {
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 8003c26:	6879      	ldr	r1, [r7, #4]
 8003c28:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003c2a:	4613      	mov	r3, r2
 8003c2c:	00db      	lsls	r3, r3, #3
 8003c2e:	4413      	add	r3, r2
 8003c30:	009b      	lsls	r3, r3, #2
 8003c32:	440b      	add	r3, r1
 8003c34:	f203 2357 	addw	r3, r3, #599	@ 0x257
 8003c38:	2201      	movs	r2, #1
 8003c3a:	701a      	strb	r2, [r3, #0]

          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 8003c3c:	6a3b      	ldr	r3, [r7, #32]
 8003c3e:	699b      	ldr	r3, [r3, #24]
 8003c40:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 8003c44:	6a3b      	ldr	r3, [r7, #32]
 8003c46:	619a      	str	r2, [r3, #24]

          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 8003c48:	6a3b      	ldr	r3, [r7, #32]
 8003c4a:	695b      	ldr	r3, [r3, #20]
 8003c4c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8003c50:	2b00      	cmp	r3, #0
 8003c52:	d10a      	bne.n	8003c6a <HAL_PCD_IRQHandler+0x8ae>
          {
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 8003c54:	69fb      	ldr	r3, [r7, #28]
 8003c56:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003c5a:	685b      	ldr	r3, [r3, #4]
 8003c5c:	69fa      	ldr	r2, [r7, #28]
 8003c5e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003c62:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8003c66:	6053      	str	r3, [r2, #4]
            break;
 8003c68:	e008      	b.n	8003c7c <HAL_PCD_IRQHandler+0x8c0>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003c6a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003c6c:	3301      	adds	r3, #1
 8003c6e:	627b      	str	r3, [r7, #36]	@ 0x24
 8003c70:	687b      	ldr	r3, [r7, #4]
 8003c72:	791b      	ldrb	r3, [r3, #4]
 8003c74:	461a      	mov	r2, r3
 8003c76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003c78:	4293      	cmp	r3, r2
 8003c7a:	d3b3      	bcc.n	8003be4 <HAL_PCD_IRQHandler+0x828>
          }
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8003c7c:	687b      	ldr	r3, [r7, #4]
 8003c7e:	681b      	ldr	r3, [r3, #0]
 8003c80:	695a      	ldr	r2, [r3, #20]
 8003c82:	687b      	ldr	r3, [r7, #4]
 8003c84:	681b      	ldr	r3, [r3, #0]
 8003c86:	f402 1200 	and.w	r2, r2, #2097152	@ 0x200000
 8003c8a:	615a      	str	r2, [r3, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8003c8c:	687b      	ldr	r3, [r7, #4]
 8003c8e:	681b      	ldr	r3, [r3, #0]
 8003c90:	4618      	mov	r0, r3
 8003c92:	f002 fd8f 	bl	80067b4 <USB_ReadInterrupts>
 8003c96:	4603      	mov	r3, r0
 8003c98:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 8003c9c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8003ca0:	d10a      	bne.n	8003cb8 <HAL_PCD_IRQHandler+0x8fc>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
 8003ca2:	6878      	ldr	r0, [r7, #4]
 8003ca4:	f024 fa7e 	bl	80281a4 <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8003ca8:	687b      	ldr	r3, [r7, #4]
 8003caa:	681b      	ldr	r3, [r3, #0]
 8003cac:	695a      	ldr	r2, [r3, #20]
 8003cae:	687b      	ldr	r3, [r7, #4]
 8003cb0:	681b      	ldr	r3, [r3, #0]
 8003cb2:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
 8003cb6:	615a      	str	r2, [r3, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8003cb8:	687b      	ldr	r3, [r7, #4]
 8003cba:	681b      	ldr	r3, [r3, #0]
 8003cbc:	4618      	mov	r0, r3
 8003cbe:	f002 fd79 	bl	80067b4 <USB_ReadInterrupts>
 8003cc2:	4603      	mov	r3, r0
 8003cc4:	f003 0304 	and.w	r3, r3, #4
 8003cc8:	2b04      	cmp	r3, #4
 8003cca:	d115      	bne.n	8003cf8 <HAL_PCD_IRQHandler+0x93c>
    {
      RegVal = hpcd->Instance->GOTGINT;
 8003ccc:	687b      	ldr	r3, [r7, #4]
 8003cce:	681b      	ldr	r3, [r3, #0]
 8003cd0:	685b      	ldr	r3, [r3, #4]
 8003cd2:	61bb      	str	r3, [r7, #24]

      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8003cd4:	69bb      	ldr	r3, [r7, #24]
 8003cd6:	f003 0304 	and.w	r3, r3, #4
 8003cda:	2b00      	cmp	r3, #0
 8003cdc:	d002      	beq.n	8003ce4 <HAL_PCD_IRQHandler+0x928>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
 8003cde:	6878      	ldr	r0, [r7, #4]
 8003ce0:	f024 fa6e 	bl	80281c0 <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
 8003ce4:	687b      	ldr	r3, [r7, #4]
 8003ce6:	681b      	ldr	r3, [r3, #0]
 8003ce8:	6859      	ldr	r1, [r3, #4]
 8003cea:	687b      	ldr	r3, [r7, #4]
 8003cec:	681b      	ldr	r3, [r3, #0]
 8003cee:	69ba      	ldr	r2, [r7, #24]
 8003cf0:	430a      	orrs	r2, r1
 8003cf2:	605a      	str	r2, [r3, #4]
 8003cf4:	e000      	b.n	8003cf8 <HAL_PCD_IRQHandler+0x93c>
      return;
 8003cf6:	bf00      	nop
    }
  }
}
 8003cf8:	3734      	adds	r7, #52	@ 0x34
 8003cfa:	46bd      	mov	sp, r7
 8003cfc:	bd90      	pop	{r4, r7, pc}

08003cfe <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8003cfe:	b580      	push	{r7, lr}
 8003d00:	b082      	sub	sp, #8
 8003d02:	af00      	add	r7, sp, #0
 8003d04:	6078      	str	r0, [r7, #4]
 8003d06:	460b      	mov	r3, r1
 8003d08:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
 8003d0a:	687b      	ldr	r3, [r7, #4]
 8003d0c:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003d10:	2b01      	cmp	r3, #1
 8003d12:	d101      	bne.n	8003d18 <HAL_PCD_SetAddress+0x1a>
 8003d14:	2302      	movs	r3, #2
 8003d16:	e012      	b.n	8003d3e <HAL_PCD_SetAddress+0x40>
 8003d18:	687b      	ldr	r3, [r7, #4]
 8003d1a:	2201      	movs	r2, #1
 8003d1c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  hpcd->USB_Address = address;
 8003d20:	687b      	ldr	r3, [r7, #4]
 8003d22:	78fa      	ldrb	r2, [r7, #3]
 8003d24:	745a      	strb	r2, [r3, #17]
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8003d26:	687b      	ldr	r3, [r7, #4]
 8003d28:	681b      	ldr	r3, [r3, #0]
 8003d2a:	78fa      	ldrb	r2, [r7, #3]
 8003d2c:	4611      	mov	r1, r2
 8003d2e:	4618      	mov	r0, r3
 8003d30:	f002 fcd8 	bl	80066e4 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8003d34:	687b      	ldr	r3, [r7, #4]
 8003d36:	2200      	movs	r2, #0
 8003d38:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8003d3c:	2300      	movs	r3, #0
}
 8003d3e:	4618      	mov	r0, r3
 8003d40:	3708      	adds	r7, #8
 8003d42:	46bd      	mov	sp, r7
 8003d44:	bd80      	pop	{r7, pc}

08003d46 <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 8003d46:	b580      	push	{r7, lr}
 8003d48:	b084      	sub	sp, #16
 8003d4a:	af00      	add	r7, sp, #0
 8003d4c:	6078      	str	r0, [r7, #4]
 8003d4e:	4608      	mov	r0, r1
 8003d50:	4611      	mov	r1, r2
 8003d52:	461a      	mov	r2, r3
 8003d54:	4603      	mov	r3, r0
 8003d56:	70fb      	strb	r3, [r7, #3]
 8003d58:	460b      	mov	r3, r1
 8003d5a:	803b      	strh	r3, [r7, #0]
 8003d5c:	4613      	mov	r3, r2
 8003d5e:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef ret = HAL_OK;
 8003d60:	2300      	movs	r3, #0
 8003d62:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8003d64:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003d68:	2b00      	cmp	r3, #0
 8003d6a:	da0f      	bge.n	8003d8c <HAL_PCD_EP_Open+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003d6c:	78fb      	ldrb	r3, [r7, #3]
 8003d6e:	f003 020f 	and.w	r2, r3, #15
 8003d72:	4613      	mov	r3, r2
 8003d74:	00db      	lsls	r3, r3, #3
 8003d76:	4413      	add	r3, r2
 8003d78:	009b      	lsls	r3, r3, #2
 8003d7a:	3310      	adds	r3, #16
 8003d7c:	687a      	ldr	r2, [r7, #4]
 8003d7e:	4413      	add	r3, r2
 8003d80:	3304      	adds	r3, #4
 8003d82:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003d84:	68fb      	ldr	r3, [r7, #12]
 8003d86:	2201      	movs	r2, #1
 8003d88:	705a      	strb	r2, [r3, #1]
 8003d8a:	e00f      	b.n	8003dac <HAL_PCD_EP_Open+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003d8c:	78fb      	ldrb	r3, [r7, #3]
 8003d8e:	f003 020f 	and.w	r2, r3, #15
 8003d92:	4613      	mov	r3, r2
 8003d94:	00db      	lsls	r3, r3, #3
 8003d96:	4413      	add	r3, r2
 8003d98:	009b      	lsls	r3, r3, #2
 8003d9a:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003d9e:	687a      	ldr	r2, [r7, #4]
 8003da0:	4413      	add	r3, r2
 8003da2:	3304      	adds	r3, #4
 8003da4:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003da6:	68fb      	ldr	r3, [r7, #12]
 8003da8:	2200      	movs	r2, #0
 8003daa:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 8003dac:	78fb      	ldrb	r3, [r7, #3]
 8003dae:	f003 030f 	and.w	r3, r3, #15
 8003db2:	b2da      	uxtb	r2, r3
 8003db4:	68fb      	ldr	r3, [r7, #12]
 8003db6:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = (uint32_t)ep_mps & 0x7FFU;
 8003db8:	883b      	ldrh	r3, [r7, #0]
 8003dba:	f3c3 020a 	ubfx	r2, r3, #0, #11
 8003dbe:	68fb      	ldr	r3, [r7, #12]
 8003dc0:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
 8003dc2:	68fb      	ldr	r3, [r7, #12]
 8003dc4:	78ba      	ldrb	r2, [r7, #2]
 8003dc6:	711a      	strb	r2, [r3, #4]

  if (ep->is_in != 0U)
 8003dc8:	68fb      	ldr	r3, [r7, #12]
 8003dca:	785b      	ldrb	r3, [r3, #1]
 8003dcc:	2b00      	cmp	r3, #0
 8003dce:	d004      	beq.n	8003dda <HAL_PCD_EP_Open+0x94>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8003dd0:	68fb      	ldr	r3, [r7, #12]
 8003dd2:	781b      	ldrb	r3, [r3, #0]
 8003dd4:	461a      	mov	r2, r3
 8003dd6:	68fb      	ldr	r3, [r7, #12]
 8003dd8:	835a      	strh	r2, [r3, #26]
  }

  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 8003dda:	78bb      	ldrb	r3, [r7, #2]
 8003ddc:	2b02      	cmp	r3, #2
 8003dde:	d102      	bne.n	8003de6 <HAL_PCD_EP_Open+0xa0>
  {
    ep->data_pid_start = 0U;
 8003de0:	68fb      	ldr	r3, [r7, #12]
 8003de2:	2200      	movs	r2, #0
 8003de4:	715a      	strb	r2, [r3, #5]
  }

  __HAL_LOCK(hpcd);
 8003de6:	687b      	ldr	r3, [r7, #4]
 8003de8:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003dec:	2b01      	cmp	r3, #1
 8003dee:	d101      	bne.n	8003df4 <HAL_PCD_EP_Open+0xae>
 8003df0:	2302      	movs	r3, #2
 8003df2:	e00e      	b.n	8003e12 <HAL_PCD_EP_Open+0xcc>
 8003df4:	687b      	ldr	r3, [r7, #4]
 8003df6:	2201      	movs	r2, #1
 8003df8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8003dfc:	687b      	ldr	r3, [r7, #4]
 8003dfe:	681b      	ldr	r3, [r3, #0]
 8003e00:	68f9      	ldr	r1, [r7, #12]
 8003e02:	4618      	mov	r0, r3
 8003e04:	f001 fe58 	bl	8005ab8 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8003e08:	687b      	ldr	r3, [r7, #4]
 8003e0a:	2200      	movs	r2, #0
 8003e0c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return ret;
 8003e10:	7afb      	ldrb	r3, [r7, #11]
}
 8003e12:	4618      	mov	r0, r3
 8003e14:	3710      	adds	r7, #16
 8003e16:	46bd      	mov	sp, r7
 8003e18:	bd80      	pop	{r7, pc}

08003e1a <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003e1a:	b580      	push	{r7, lr}
 8003e1c:	b084      	sub	sp, #16
 8003e1e:	af00      	add	r7, sp, #0
 8003e20:	6078      	str	r0, [r7, #4]
 8003e22:	460b      	mov	r3, r1
 8003e24:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8003e26:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003e2a:	2b00      	cmp	r3, #0
 8003e2c:	da0f      	bge.n	8003e4e <HAL_PCD_EP_Close+0x34>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003e2e:	78fb      	ldrb	r3, [r7, #3]
 8003e30:	f003 020f 	and.w	r2, r3, #15
 8003e34:	4613      	mov	r3, r2
 8003e36:	00db      	lsls	r3, r3, #3
 8003e38:	4413      	add	r3, r2
 8003e3a:	009b      	lsls	r3, r3, #2
 8003e3c:	3310      	adds	r3, #16
 8003e3e:	687a      	ldr	r2, [r7, #4]
 8003e40:	4413      	add	r3, r2
 8003e42:	3304      	adds	r3, #4
 8003e44:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003e46:	68fb      	ldr	r3, [r7, #12]
 8003e48:	2201      	movs	r2, #1
 8003e4a:	705a      	strb	r2, [r3, #1]
 8003e4c:	e00f      	b.n	8003e6e <HAL_PCD_EP_Close+0x54>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003e4e:	78fb      	ldrb	r3, [r7, #3]
 8003e50:	f003 020f 	and.w	r2, r3, #15
 8003e54:	4613      	mov	r3, r2
 8003e56:	00db      	lsls	r3, r3, #3
 8003e58:	4413      	add	r3, r2
 8003e5a:	009b      	lsls	r3, r3, #2
 8003e5c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003e60:	687a      	ldr	r2, [r7, #4]
 8003e62:	4413      	add	r3, r2
 8003e64:	3304      	adds	r3, #4
 8003e66:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003e68:	68fb      	ldr	r3, [r7, #12]
 8003e6a:	2200      	movs	r2, #0
 8003e6c:	705a      	strb	r2, [r3, #1]
  }
  ep->num = ep_addr & EP_ADDR_MSK;
 8003e6e:	78fb      	ldrb	r3, [r7, #3]
 8003e70:	f003 030f 	and.w	r3, r3, #15
 8003e74:	b2da      	uxtb	r2, r3
 8003e76:	68fb      	ldr	r3, [r7, #12]
 8003e78:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8003e7a:	687b      	ldr	r3, [r7, #4]
 8003e7c:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003e80:	2b01      	cmp	r3, #1
 8003e82:	d101      	bne.n	8003e88 <HAL_PCD_EP_Close+0x6e>
 8003e84:	2302      	movs	r3, #2
 8003e86:	e00e      	b.n	8003ea6 <HAL_PCD_EP_Close+0x8c>
 8003e88:	687b      	ldr	r3, [r7, #4]
 8003e8a:	2201      	movs	r2, #1
 8003e8c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8003e90:	687b      	ldr	r3, [r7, #4]
 8003e92:	681b      	ldr	r3, [r3, #0]
 8003e94:	68f9      	ldr	r1, [r7, #12]
 8003e96:	4618      	mov	r0, r3
 8003e98:	f001 fe96 	bl	8005bc8 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8003e9c:	687b      	ldr	r3, [r7, #4]
 8003e9e:	2200      	movs	r2, #0
 8003ea0:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  return HAL_OK;
 8003ea4:	2300      	movs	r3, #0
}
 8003ea6:	4618      	mov	r0, r3
 8003ea8:	3710      	adds	r7, #16
 8003eaa:	46bd      	mov	sp, r7
 8003eac:	bd80      	pop	{r7, pc}

08003eae <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8003eae:	b580      	push	{r7, lr}
 8003eb0:	b086      	sub	sp, #24
 8003eb2:	af00      	add	r7, sp, #0
 8003eb4:	60f8      	str	r0, [r7, #12]
 8003eb6:	607a      	str	r2, [r7, #4]
 8003eb8:	603b      	str	r3, [r7, #0]
 8003eba:	460b      	mov	r3, r1
 8003ebc:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003ebe:	7afb      	ldrb	r3, [r7, #11]
 8003ec0:	f003 020f 	and.w	r2, r3, #15
 8003ec4:	4613      	mov	r3, r2
 8003ec6:	00db      	lsls	r3, r3, #3
 8003ec8:	4413      	add	r3, r2
 8003eca:	009b      	lsls	r3, r3, #2
 8003ecc:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003ed0:	68fa      	ldr	r2, [r7, #12]
 8003ed2:	4413      	add	r3, r2
 8003ed4:	3304      	adds	r3, #4
 8003ed6:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 8003ed8:	697b      	ldr	r3, [r7, #20]
 8003eda:	687a      	ldr	r2, [r7, #4]
 8003edc:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8003ede:	697b      	ldr	r3, [r7, #20]
 8003ee0:	683a      	ldr	r2, [r7, #0]
 8003ee2:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 8003ee4:	697b      	ldr	r3, [r7, #20]
 8003ee6:	2200      	movs	r2, #0
 8003ee8:	615a      	str	r2, [r3, #20]
  ep->is_in = 0U;
 8003eea:	697b      	ldr	r3, [r7, #20]
 8003eec:	2200      	movs	r2, #0
 8003eee:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003ef0:	7afb      	ldrb	r3, [r7, #11]
 8003ef2:	f003 030f 	and.w	r3, r3, #15
 8003ef6:	b2da      	uxtb	r2, r3
 8003ef8:	697b      	ldr	r3, [r7, #20]
 8003efa:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 8003efc:	68fb      	ldr	r3, [r7, #12]
 8003efe:	799b      	ldrb	r3, [r3, #6]
 8003f00:	2b01      	cmp	r3, #1
 8003f02:	d102      	bne.n	8003f0a <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;
 8003f04:	687a      	ldr	r2, [r7, #4]
 8003f06:	697b      	ldr	r3, [r7, #20]
 8003f08:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8003f0a:	68fb      	ldr	r3, [r7, #12]
 8003f0c:	6818      	ldr	r0, [r3, #0]
 8003f0e:	68fb      	ldr	r3, [r7, #12]
 8003f10:	799b      	ldrb	r3, [r3, #6]
 8003f12:	461a      	mov	r2, r3
 8003f14:	6979      	ldr	r1, [r7, #20]
 8003f16:	f001 ff33 	bl	8005d80 <USB_EPStartXfer>

  return HAL_OK;
 8003f1a:	2300      	movs	r3, #0
}
 8003f1c:	4618      	mov	r0, r3
 8003f1e:	3718      	adds	r7, #24
 8003f20:	46bd      	mov	sp, r7
 8003f22:	bd80      	pop	{r7, pc}

08003f24 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef const *hpcd, uint8_t ep_addr)
{
 8003f24:	b480      	push	{r7}
 8003f26:	b083      	sub	sp, #12
 8003f28:	af00      	add	r7, sp, #0
 8003f2a:	6078      	str	r0, [r7, #4]
 8003f2c:	460b      	mov	r3, r1
 8003f2e:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 8003f30:	78fb      	ldrb	r3, [r7, #3]
 8003f32:	f003 020f 	and.w	r2, r3, #15
 8003f36:	6879      	ldr	r1, [r7, #4]
 8003f38:	4613      	mov	r3, r2
 8003f3a:	00db      	lsls	r3, r3, #3
 8003f3c:	4413      	add	r3, r2
 8003f3e:	009b      	lsls	r3, r3, #2
 8003f40:	440b      	add	r3, r1
 8003f42:	f503 731a 	add.w	r3, r3, #616	@ 0x268
 8003f46:	681b      	ldr	r3, [r3, #0]
}
 8003f48:	4618      	mov	r0, r3
 8003f4a:	370c      	adds	r7, #12
 8003f4c:	46bd      	mov	sp, r7
 8003f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f52:	4770      	bx	lr

08003f54 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8003f54:	b580      	push	{r7, lr}
 8003f56:	b086      	sub	sp, #24
 8003f58:	af00      	add	r7, sp, #0
 8003f5a:	60f8      	str	r0, [r7, #12]
 8003f5c:	607a      	str	r2, [r7, #4]
 8003f5e:	603b      	str	r3, [r7, #0]
 8003f60:	460b      	mov	r3, r1
 8003f62:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003f64:	7afb      	ldrb	r3, [r7, #11]
 8003f66:	f003 020f 	and.w	r2, r3, #15
 8003f6a:	4613      	mov	r3, r2
 8003f6c:	00db      	lsls	r3, r3, #3
 8003f6e:	4413      	add	r3, r2
 8003f70:	009b      	lsls	r3, r3, #2
 8003f72:	3310      	adds	r3, #16
 8003f74:	68fa      	ldr	r2, [r7, #12]
 8003f76:	4413      	add	r3, r2
 8003f78:	3304      	adds	r3, #4
 8003f7a:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 8003f7c:	697b      	ldr	r3, [r7, #20]
 8003f7e:	687a      	ldr	r2, [r7, #4]
 8003f80:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8003f82:	697b      	ldr	r3, [r7, #20]
 8003f84:	683a      	ldr	r2, [r7, #0]
 8003f86:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 8003f88:	697b      	ldr	r3, [r7, #20]
 8003f8a:	2200      	movs	r2, #0
 8003f8c:	615a      	str	r2, [r3, #20]
  ep->is_in = 1U;
 8003f8e:	697b      	ldr	r3, [r7, #20]
 8003f90:	2201      	movs	r2, #1
 8003f92:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003f94:	7afb      	ldrb	r3, [r7, #11]
 8003f96:	f003 030f 	and.w	r3, r3, #15
 8003f9a:	b2da      	uxtb	r2, r3
 8003f9c:	697b      	ldr	r3, [r7, #20]
 8003f9e:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 8003fa0:	68fb      	ldr	r3, [r7, #12]
 8003fa2:	799b      	ldrb	r3, [r3, #6]
 8003fa4:	2b01      	cmp	r3, #1
 8003fa6:	d102      	bne.n	8003fae <HAL_PCD_EP_Transmit+0x5a>
  {
    ep->dma_addr = (uint32_t)pBuf;
 8003fa8:	687a      	ldr	r2, [r7, #4]
 8003faa:	697b      	ldr	r3, [r7, #20]
 8003fac:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8003fae:	68fb      	ldr	r3, [r7, #12]
 8003fb0:	6818      	ldr	r0, [r3, #0]
 8003fb2:	68fb      	ldr	r3, [r7, #12]
 8003fb4:	799b      	ldrb	r3, [r3, #6]
 8003fb6:	461a      	mov	r2, r3
 8003fb8:	6979      	ldr	r1, [r7, #20]
 8003fba:	f001 fee1 	bl	8005d80 <USB_EPStartXfer>

  return HAL_OK;
 8003fbe:	2300      	movs	r3, #0
}
 8003fc0:	4618      	mov	r0, r3
 8003fc2:	3718      	adds	r7, #24
 8003fc4:	46bd      	mov	sp, r7
 8003fc6:	bd80      	pop	{r7, pc}

08003fc8 <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003fc8:	b580      	push	{r7, lr}
 8003fca:	b084      	sub	sp, #16
 8003fcc:	af00      	add	r7, sp, #0
 8003fce:	6078      	str	r0, [r7, #4]
 8003fd0:	460b      	mov	r3, r1
 8003fd2:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8003fd4:	78fb      	ldrb	r3, [r7, #3]
 8003fd6:	f003 030f 	and.w	r3, r3, #15
 8003fda:	687a      	ldr	r2, [r7, #4]
 8003fdc:	7912      	ldrb	r2, [r2, #4]
 8003fde:	4293      	cmp	r3, r2
 8003fe0:	d901      	bls.n	8003fe6 <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
 8003fe2:	2301      	movs	r3, #1
 8003fe4:	e04f      	b.n	8004086 <HAL_PCD_EP_SetStall+0xbe>
  }

  if ((0x80U & ep_addr) == 0x80U)
 8003fe6:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003fea:	2b00      	cmp	r3, #0
 8003fec:	da0f      	bge.n	800400e <HAL_PCD_EP_SetStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003fee:	78fb      	ldrb	r3, [r7, #3]
 8003ff0:	f003 020f 	and.w	r2, r3, #15
 8003ff4:	4613      	mov	r3, r2
 8003ff6:	00db      	lsls	r3, r3, #3
 8003ff8:	4413      	add	r3, r2
 8003ffa:	009b      	lsls	r3, r3, #2
 8003ffc:	3310      	adds	r3, #16
 8003ffe:	687a      	ldr	r2, [r7, #4]
 8004000:	4413      	add	r3, r2
 8004002:	3304      	adds	r3, #4
 8004004:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8004006:	68fb      	ldr	r3, [r7, #12]
 8004008:	2201      	movs	r2, #1
 800400a:	705a      	strb	r2, [r3, #1]
 800400c:	e00d      	b.n	800402a <HAL_PCD_EP_SetStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 800400e:	78fa      	ldrb	r2, [r7, #3]
 8004010:	4613      	mov	r3, r2
 8004012:	00db      	lsls	r3, r3, #3
 8004014:	4413      	add	r3, r2
 8004016:	009b      	lsls	r3, r3, #2
 8004018:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800401c:	687a      	ldr	r2, [r7, #4]
 800401e:	4413      	add	r3, r2
 8004020:	3304      	adds	r3, #4
 8004022:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8004024:	68fb      	ldr	r3, [r7, #12]
 8004026:	2200      	movs	r2, #0
 8004028:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 800402a:	68fb      	ldr	r3, [r7, #12]
 800402c:	2201      	movs	r2, #1
 800402e:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8004030:	78fb      	ldrb	r3, [r7, #3]
 8004032:	f003 030f 	and.w	r3, r3, #15
 8004036:	b2da      	uxtb	r2, r3
 8004038:	68fb      	ldr	r3, [r7, #12]
 800403a:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800403c:	687b      	ldr	r3, [r7, #4]
 800403e:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8004042:	2b01      	cmp	r3, #1
 8004044:	d101      	bne.n	800404a <HAL_PCD_EP_SetStall+0x82>
 8004046:	2302      	movs	r3, #2
 8004048:	e01d      	b.n	8004086 <HAL_PCD_EP_SetStall+0xbe>
 800404a:	687b      	ldr	r3, [r7, #4]
 800404c:	2201      	movs	r2, #1
 800404e:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  (void)USB_EPSetStall(hpcd->Instance, ep);
 8004052:	687b      	ldr	r3, [r7, #4]
 8004054:	681b      	ldr	r3, [r3, #0]
 8004056:	68f9      	ldr	r1, [r7, #12]
 8004058:	4618      	mov	r0, r3
 800405a:	f002 fa6f 	bl	800653c <USB_EPSetStall>

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800405e:	78fb      	ldrb	r3, [r7, #3]
 8004060:	f003 030f 	and.w	r3, r3, #15
 8004064:	2b00      	cmp	r3, #0
 8004066:	d109      	bne.n	800407c <HAL_PCD_EP_SetStall+0xb4>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8004068:	687b      	ldr	r3, [r7, #4]
 800406a:	6818      	ldr	r0, [r3, #0]
 800406c:	687b      	ldr	r3, [r7, #4]
 800406e:	7999      	ldrb	r1, [r3, #6]
 8004070:	687b      	ldr	r3, [r7, #4]
 8004072:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8004076:	461a      	mov	r2, r3
 8004078:	f002 fc60 	bl	800693c <USB_EP0_OutStart>
  }

  __HAL_UNLOCK(hpcd);
 800407c:	687b      	ldr	r3, [r7, #4]
 800407e:	2200      	movs	r2, #0
 8004080:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8004084:	2300      	movs	r3, #0
}
 8004086:	4618      	mov	r0, r3
 8004088:	3710      	adds	r7, #16
 800408a:	46bd      	mov	sp, r7
 800408c:	bd80      	pop	{r7, pc}

0800408e <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800408e:	b580      	push	{r7, lr}
 8004090:	b084      	sub	sp, #16
 8004092:	af00      	add	r7, sp, #0
 8004094:	6078      	str	r0, [r7, #4]
 8004096:	460b      	mov	r3, r1
 8004098:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800409a:	78fb      	ldrb	r3, [r7, #3]
 800409c:	f003 030f 	and.w	r3, r3, #15
 80040a0:	687a      	ldr	r2, [r7, #4]
 80040a2:	7912      	ldrb	r2, [r2, #4]
 80040a4:	4293      	cmp	r3, r2
 80040a6:	d901      	bls.n	80040ac <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
 80040a8:	2301      	movs	r3, #1
 80040aa:	e042      	b.n	8004132 <HAL_PCD_EP_ClrStall+0xa4>
  }

  if ((0x80U & ep_addr) == 0x80U)
 80040ac:	f997 3003 	ldrsb.w	r3, [r7, #3]
 80040b0:	2b00      	cmp	r3, #0
 80040b2:	da0f      	bge.n	80040d4 <HAL_PCD_EP_ClrStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80040b4:	78fb      	ldrb	r3, [r7, #3]
 80040b6:	f003 020f 	and.w	r2, r3, #15
 80040ba:	4613      	mov	r3, r2
 80040bc:	00db      	lsls	r3, r3, #3
 80040be:	4413      	add	r3, r2
 80040c0:	009b      	lsls	r3, r3, #2
 80040c2:	3310      	adds	r3, #16
 80040c4:	687a      	ldr	r2, [r7, #4]
 80040c6:	4413      	add	r3, r2
 80040c8:	3304      	adds	r3, #4
 80040ca:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 80040cc:	68fb      	ldr	r3, [r7, #12]
 80040ce:	2201      	movs	r2, #1
 80040d0:	705a      	strb	r2, [r3, #1]
 80040d2:	e00f      	b.n	80040f4 <HAL_PCD_EP_ClrStall+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80040d4:	78fb      	ldrb	r3, [r7, #3]
 80040d6:	f003 020f 	and.w	r2, r3, #15
 80040da:	4613      	mov	r3, r2
 80040dc:	00db      	lsls	r3, r3, #3
 80040de:	4413      	add	r3, r2
 80040e0:	009b      	lsls	r3, r3, #2
 80040e2:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 80040e6:	687a      	ldr	r2, [r7, #4]
 80040e8:	4413      	add	r3, r2
 80040ea:	3304      	adds	r3, #4
 80040ec:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 80040ee:	68fb      	ldr	r3, [r7, #12]
 80040f0:	2200      	movs	r2, #0
 80040f2:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 80040f4:	68fb      	ldr	r3, [r7, #12]
 80040f6:	2200      	movs	r2, #0
 80040f8:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 80040fa:	78fb      	ldrb	r3, [r7, #3]
 80040fc:	f003 030f 	and.w	r3, r3, #15
 8004100:	b2da      	uxtb	r2, r3
 8004102:	68fb      	ldr	r3, [r7, #12]
 8004104:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8004106:	687b      	ldr	r3, [r7, #4]
 8004108:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 800410c:	2b01      	cmp	r3, #1
 800410e:	d101      	bne.n	8004114 <HAL_PCD_EP_ClrStall+0x86>
 8004110:	2302      	movs	r3, #2
 8004112:	e00e      	b.n	8004132 <HAL_PCD_EP_ClrStall+0xa4>
 8004114:	687b      	ldr	r3, [r7, #4]
 8004116:	2201      	movs	r2, #1
 8004118:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
 800411c:	687b      	ldr	r3, [r7, #4]
 800411e:	681b      	ldr	r3, [r3, #0]
 8004120:	68f9      	ldr	r1, [r7, #12]
 8004122:	4618      	mov	r0, r3
 8004124:	f002 fa78 	bl	8006618 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8004128:	687b      	ldr	r3, [r7, #4]
 800412a:	2200      	movs	r2, #0
 800412c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8004130:	2300      	movs	r3, #0
}
 8004132:	4618      	mov	r0, r3
 8004134:	3710      	adds	r7, #16
 8004136:	46bd      	mov	sp, r7
 8004138:	bd80      	pop	{r7, pc}

0800413a <HAL_PCD_EP_Abort>:
   * @param  hpcd PCD handle
   * @param  ep_addr endpoint address
   * @retval HAL status
   */
HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800413a:	b580      	push	{r7, lr}
 800413c:	b084      	sub	sp, #16
 800413e:	af00      	add	r7, sp, #0
 8004140:	6078      	str	r0, [r7, #4]
 8004142:	460b      	mov	r3, r1
 8004144:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef ret;
  PCD_EPTypeDef *ep;

  if ((0x80U & ep_addr) == 0x80U)
 8004146:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800414a:	2b00      	cmp	r3, #0
 800414c:	da0c      	bge.n	8004168 <HAL_PCD_EP_Abort+0x2e>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800414e:	78fb      	ldrb	r3, [r7, #3]
 8004150:	f003 020f 	and.w	r2, r3, #15
 8004154:	4613      	mov	r3, r2
 8004156:	00db      	lsls	r3, r3, #3
 8004158:	4413      	add	r3, r2
 800415a:	009b      	lsls	r3, r3, #2
 800415c:	3310      	adds	r3, #16
 800415e:	687a      	ldr	r2, [r7, #4]
 8004160:	4413      	add	r3, r2
 8004162:	3304      	adds	r3, #4
 8004164:	60fb      	str	r3, [r7, #12]
 8004166:	e00c      	b.n	8004182 <HAL_PCD_EP_Abort+0x48>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8004168:	78fb      	ldrb	r3, [r7, #3]
 800416a:	f003 020f 	and.w	r2, r3, #15
 800416e:	4613      	mov	r3, r2
 8004170:	00db      	lsls	r3, r3, #3
 8004172:	4413      	add	r3, r2
 8004174:	009b      	lsls	r3, r3, #2
 8004176:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800417a:	687a      	ldr	r2, [r7, #4]
 800417c:	4413      	add	r3, r2
 800417e:	3304      	adds	r3, #4
 8004180:	60fb      	str	r3, [r7, #12]
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8004182:	687b      	ldr	r3, [r7, #4]
 8004184:	681b      	ldr	r3, [r3, #0]
 8004186:	68f9      	ldr	r1, [r7, #12]
 8004188:	4618      	mov	r0, r3
 800418a:	f002 f897 	bl	80062bc <USB_EPStopXfer>
 800418e:	4603      	mov	r3, r0
 8004190:	72fb      	strb	r3, [r7, #11]

  return ret;
 8004192:	7afb      	ldrb	r3, [r7, #11]
}
 8004194:	4618      	mov	r0, r3
 8004196:	3710      	adds	r7, #16
 8004198:	46bd      	mov	sp, r7
 800419a:	bd80      	pop	{r7, pc}

0800419c <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 800419c:	b580      	push	{r7, lr}
 800419e:	b08a      	sub	sp, #40	@ 0x28
 80041a0:	af02      	add	r7, sp, #8
 80041a2:	6078      	str	r0, [r7, #4]
 80041a4:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80041a6:	687b      	ldr	r3, [r7, #4]
 80041a8:	681b      	ldr	r3, [r3, #0]
 80041aa:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80041ac:	697b      	ldr	r3, [r7, #20]
 80041ae:	613b      	str	r3, [r7, #16]
  USB_OTG_EPTypeDef *ep;
  uint32_t len;
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];
 80041b0:	683a      	ldr	r2, [r7, #0]
 80041b2:	4613      	mov	r3, r2
 80041b4:	00db      	lsls	r3, r3, #3
 80041b6:	4413      	add	r3, r2
 80041b8:	009b      	lsls	r3, r3, #2
 80041ba:	3310      	adds	r3, #16
 80041bc:	687a      	ldr	r2, [r7, #4]
 80041be:	4413      	add	r3, r2
 80041c0:	3304      	adds	r3, #4
 80041c2:	60fb      	str	r3, [r7, #12]

  if (ep->xfer_count > ep->xfer_len)
 80041c4:	68fb      	ldr	r3, [r7, #12]
 80041c6:	695a      	ldr	r2, [r3, #20]
 80041c8:	68fb      	ldr	r3, [r7, #12]
 80041ca:	691b      	ldr	r3, [r3, #16]
 80041cc:	429a      	cmp	r2, r3
 80041ce:	d901      	bls.n	80041d4 <PCD_WriteEmptyTxFifo+0x38>
  {
    return HAL_ERROR;
 80041d0:	2301      	movs	r3, #1
 80041d2:	e06b      	b.n	80042ac <PCD_WriteEmptyTxFifo+0x110>
  }

  len = ep->xfer_len - ep->xfer_count;
 80041d4:	68fb      	ldr	r3, [r7, #12]
 80041d6:	691a      	ldr	r2, [r3, #16]
 80041d8:	68fb      	ldr	r3, [r7, #12]
 80041da:	695b      	ldr	r3, [r3, #20]
 80041dc:	1ad3      	subs	r3, r2, r3
 80041de:	61fb      	str	r3, [r7, #28]

  if (len > ep->maxpacket)
 80041e0:	68fb      	ldr	r3, [r7, #12]
 80041e2:	689b      	ldr	r3, [r3, #8]
 80041e4:	69fa      	ldr	r2, [r7, #28]
 80041e6:	429a      	cmp	r2, r3
 80041e8:	d902      	bls.n	80041f0 <PCD_WriteEmptyTxFifo+0x54>
  {
    len = ep->maxpacket;
 80041ea:	68fb      	ldr	r3, [r7, #12]
 80041ec:	689b      	ldr	r3, [r3, #8]
 80041ee:	61fb      	str	r3, [r7, #28]
  }

  len32b = (len + 3U) / 4U;
 80041f0:	69fb      	ldr	r3, [r7, #28]
 80041f2:	3303      	adds	r3, #3
 80041f4:	089b      	lsrs	r3, r3, #2
 80041f6:	61bb      	str	r3, [r7, #24]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80041f8:	e02a      	b.n	8004250 <PCD_WriteEmptyTxFifo+0xb4>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 80041fa:	68fb      	ldr	r3, [r7, #12]
 80041fc:	691a      	ldr	r2, [r3, #16]
 80041fe:	68fb      	ldr	r3, [r7, #12]
 8004200:	695b      	ldr	r3, [r3, #20]
 8004202:	1ad3      	subs	r3, r2, r3
 8004204:	61fb      	str	r3, [r7, #28]

    if (len > ep->maxpacket)
 8004206:	68fb      	ldr	r3, [r7, #12]
 8004208:	689b      	ldr	r3, [r3, #8]
 800420a:	69fa      	ldr	r2, [r7, #28]
 800420c:	429a      	cmp	r2, r3
 800420e:	d902      	bls.n	8004216 <PCD_WriteEmptyTxFifo+0x7a>
    {
      len = ep->maxpacket;
 8004210:	68fb      	ldr	r3, [r7, #12]
 8004212:	689b      	ldr	r3, [r3, #8]
 8004214:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
 8004216:	69fb      	ldr	r3, [r7, #28]
 8004218:	3303      	adds	r3, #3
 800421a:	089b      	lsrs	r3, r3, #2
 800421c:	61bb      	str	r3, [r7, #24]

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 800421e:	68fb      	ldr	r3, [r7, #12]
 8004220:	68d9      	ldr	r1, [r3, #12]
 8004222:	683b      	ldr	r3, [r7, #0]
 8004224:	b2da      	uxtb	r2, r3
 8004226:	69fb      	ldr	r3, [r7, #28]
 8004228:	b298      	uxth	r0, r3
                          (uint8_t)hpcd->Init.dma_enable);
 800422a:	687b      	ldr	r3, [r7, #4]
 800422c:	799b      	ldrb	r3, [r3, #6]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 800422e:	9300      	str	r3, [sp, #0]
 8004230:	4603      	mov	r3, r0
 8004232:	6978      	ldr	r0, [r7, #20]
 8004234:	f002 f8ec 	bl	8006410 <USB_WritePacket>

    ep->xfer_buff  += len;
 8004238:	68fb      	ldr	r3, [r7, #12]
 800423a:	68da      	ldr	r2, [r3, #12]
 800423c:	69fb      	ldr	r3, [r7, #28]
 800423e:	441a      	add	r2, r3
 8004240:	68fb      	ldr	r3, [r7, #12]
 8004242:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
 8004244:	68fb      	ldr	r3, [r7, #12]
 8004246:	695a      	ldr	r2, [r3, #20]
 8004248:	69fb      	ldr	r3, [r7, #28]
 800424a:	441a      	add	r2, r3
 800424c:	68fb      	ldr	r3, [r7, #12]
 800424e:	615a      	str	r2, [r3, #20]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8004250:	683b      	ldr	r3, [r7, #0]
 8004252:	015a      	lsls	r2, r3, #5
 8004254:	693b      	ldr	r3, [r7, #16]
 8004256:	4413      	add	r3, r2
 8004258:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800425c:	699b      	ldr	r3, [r3, #24]
 800425e:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8004260:	69ba      	ldr	r2, [r7, #24]
 8004262:	429a      	cmp	r2, r3
 8004264:	d809      	bhi.n	800427a <PCD_WriteEmptyTxFifo+0xde>
 8004266:	68fb      	ldr	r3, [r7, #12]
 8004268:	695a      	ldr	r2, [r3, #20]
 800426a:	68fb      	ldr	r3, [r7, #12]
 800426c:	691b      	ldr	r3, [r3, #16]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800426e:	429a      	cmp	r2, r3
 8004270:	d203      	bcs.n	800427a <PCD_WriteEmptyTxFifo+0xde>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8004272:	68fb      	ldr	r3, [r7, #12]
 8004274:	691b      	ldr	r3, [r3, #16]
 8004276:	2b00      	cmp	r3, #0
 8004278:	d1bf      	bne.n	80041fa <PCD_WriteEmptyTxFifo+0x5e>
  }

  if (ep->xfer_len <= ep->xfer_count)
 800427a:	68fb      	ldr	r3, [r7, #12]
 800427c:	691a      	ldr	r2, [r3, #16]
 800427e:	68fb      	ldr	r3, [r7, #12]
 8004280:	695b      	ldr	r3, [r3, #20]
 8004282:	429a      	cmp	r2, r3
 8004284:	d811      	bhi.n	80042aa <PCD_WriteEmptyTxFifo+0x10e>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8004286:	683b      	ldr	r3, [r7, #0]
 8004288:	f003 030f 	and.w	r3, r3, #15
 800428c:	2201      	movs	r2, #1
 800428e:	fa02 f303 	lsl.w	r3, r2, r3
 8004292:	60bb      	str	r3, [r7, #8]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8004294:	693b      	ldr	r3, [r7, #16]
 8004296:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800429a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800429c:	68bb      	ldr	r3, [r7, #8]
 800429e:	43db      	mvns	r3, r3
 80042a0:	6939      	ldr	r1, [r7, #16]
 80042a2:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80042a6:	4013      	ands	r3, r2
 80042a8:	634b      	str	r3, [r1, #52]	@ 0x34
  }

  return HAL_OK;
 80042aa:	2300      	movs	r3, #0
}
 80042ac:	4618      	mov	r0, r3
 80042ae:	3720      	adds	r7, #32
 80042b0:	46bd      	mov	sp, r7
 80042b2:	bd80      	pop	{r7, pc}

080042b4 <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 80042b4:	b580      	push	{r7, lr}
 80042b6:	b088      	sub	sp, #32
 80042b8:	af00      	add	r7, sp, #0
 80042ba:	6078      	str	r0, [r7, #4]
 80042bc:	6039      	str	r1, [r7, #0]
  USB_OTG_EPTypeDef *ep;
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80042be:	687b      	ldr	r3, [r7, #4]
 80042c0:	681b      	ldr	r3, [r3, #0]
 80042c2:	61fb      	str	r3, [r7, #28]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80042c4:	69fb      	ldr	r3, [r7, #28]
 80042c6:	61bb      	str	r3, [r7, #24]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 80042c8:	69fb      	ldr	r3, [r7, #28]
 80042ca:	333c      	adds	r3, #60	@ 0x3c
 80042cc:	3304      	adds	r3, #4
 80042ce:	681b      	ldr	r3, [r3, #0]
 80042d0:	617b      	str	r3, [r7, #20]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80042d2:	683b      	ldr	r3, [r7, #0]
 80042d4:	015a      	lsls	r2, r3, #5
 80042d6:	69bb      	ldr	r3, [r7, #24]
 80042d8:	4413      	add	r3, r2
 80042da:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80042de:	689b      	ldr	r3, [r3, #8]
 80042e0:	613b      	str	r3, [r7, #16]

  if (hpcd->Init.dma_enable == 1U)
 80042e2:	687b      	ldr	r3, [r7, #4]
 80042e4:	799b      	ldrb	r3, [r3, #6]
 80042e6:	2b01      	cmp	r3, #1
 80042e8:	d17b      	bne.n	80043e2 <PCD_EP_OutXfrComplete_int+0x12e>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 80042ea:	693b      	ldr	r3, [r7, #16]
 80042ec:	f003 0308 	and.w	r3, r3, #8
 80042f0:	2b00      	cmp	r3, #0
 80042f2:	d015      	beq.n	8004320 <PCD_EP_OutXfrComplete_int+0x6c>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80042f4:	697b      	ldr	r3, [r7, #20]
 80042f6:	4a61      	ldr	r2, [pc, #388]	@ (800447c <PCD_EP_OutXfrComplete_int+0x1c8>)
 80042f8:	4293      	cmp	r3, r2
 80042fa:	f240 80b9 	bls.w	8004470 <PCD_EP_OutXfrComplete_int+0x1bc>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 80042fe:	693b      	ldr	r3, [r7, #16]
 8004300:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8004304:	2b00      	cmp	r3, #0
 8004306:	f000 80b3 	beq.w	8004470 <PCD_EP_OutXfrComplete_int+0x1bc>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800430a:	683b      	ldr	r3, [r7, #0]
 800430c:	015a      	lsls	r2, r3, #5
 800430e:	69bb      	ldr	r3, [r7, #24]
 8004310:	4413      	add	r3, r2
 8004312:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004316:	461a      	mov	r2, r3
 8004318:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800431c:	6093      	str	r3, [r2, #8]
 800431e:	e0a7      	b.n	8004470 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
    }
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 8004320:	693b      	ldr	r3, [r7, #16]
 8004322:	f003 0320 	and.w	r3, r3, #32
 8004326:	2b00      	cmp	r3, #0
 8004328:	d009      	beq.n	800433e <PCD_EP_OutXfrComplete_int+0x8a>
    {
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 800432a:	683b      	ldr	r3, [r7, #0]
 800432c:	015a      	lsls	r2, r3, #5
 800432e:	69bb      	ldr	r3, [r7, #24]
 8004330:	4413      	add	r3, r2
 8004332:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004336:	461a      	mov	r2, r3
 8004338:	2320      	movs	r3, #32
 800433a:	6093      	str	r3, [r2, #8]
 800433c:	e098      	b.n	8004470 <PCD_EP_OutXfrComplete_int+0x1bc>
    }
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 800433e:	693b      	ldr	r3, [r7, #16]
 8004340:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 8004344:	2b00      	cmp	r3, #0
 8004346:	f040 8093 	bne.w	8004470 <PCD_EP_OutXfrComplete_int+0x1bc>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800434a:	697b      	ldr	r3, [r7, #20]
 800434c:	4a4b      	ldr	r2, [pc, #300]	@ (800447c <PCD_EP_OutXfrComplete_int+0x1c8>)
 800434e:	4293      	cmp	r3, r2
 8004350:	d90f      	bls.n	8004372 <PCD_EP_OutXfrComplete_int+0xbe>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 8004352:	693b      	ldr	r3, [r7, #16]
 8004354:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8004358:	2b00      	cmp	r3, #0
 800435a:	d00a      	beq.n	8004372 <PCD_EP_OutXfrComplete_int+0xbe>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800435c:	683b      	ldr	r3, [r7, #0]
 800435e:	015a      	lsls	r2, r3, #5
 8004360:	69bb      	ldr	r3, [r7, #24]
 8004362:	4413      	add	r3, r2
 8004364:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004368:	461a      	mov	r2, r3
 800436a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800436e:	6093      	str	r3, [r2, #8]
 8004370:	e07e      	b.n	8004470 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        ep = &hpcd->OUT_ep[epnum];
 8004372:	683a      	ldr	r2, [r7, #0]
 8004374:	4613      	mov	r3, r2
 8004376:	00db      	lsls	r3, r3, #3
 8004378:	4413      	add	r3, r2
 800437a:	009b      	lsls	r3, r3, #2
 800437c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8004380:	687a      	ldr	r2, [r7, #4]
 8004382:	4413      	add	r3, r2
 8004384:	3304      	adds	r3, #4
 8004386:	60fb      	str	r3, [r7, #12]

        /* out data packet received over EP */
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 8004388:	68fb      	ldr	r3, [r7, #12]
 800438a:	6a1a      	ldr	r2, [r3, #32]
 800438c:	683b      	ldr	r3, [r7, #0]
 800438e:	0159      	lsls	r1, r3, #5
 8004390:	69bb      	ldr	r3, [r7, #24]
 8004392:	440b      	add	r3, r1
 8004394:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004398:	691b      	ldr	r3, [r3, #16]
 800439a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800439e:	1ad2      	subs	r2, r2, r3
 80043a0:	68fb      	ldr	r3, [r7, #12]
 80043a2:	615a      	str	r2, [r3, #20]

        if (epnum == 0U)
 80043a4:	683b      	ldr	r3, [r7, #0]
 80043a6:	2b00      	cmp	r3, #0
 80043a8:	d114      	bne.n	80043d4 <PCD_EP_OutXfrComplete_int+0x120>
        {
          if (ep->xfer_len == 0U)
 80043aa:	68fb      	ldr	r3, [r7, #12]
 80043ac:	691b      	ldr	r3, [r3, #16]
 80043ae:	2b00      	cmp	r3, #0
 80043b0:	d109      	bne.n	80043c6 <PCD_EP_OutXfrComplete_int+0x112>
          {
            /* this is ZLP, so prepare EP0 for next setup */
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80043b2:	687b      	ldr	r3, [r7, #4]
 80043b4:	6818      	ldr	r0, [r3, #0]
 80043b6:	687b      	ldr	r3, [r7, #4]
 80043b8:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 80043bc:	461a      	mov	r2, r3
 80043be:	2101      	movs	r1, #1
 80043c0:	f002 fabc 	bl	800693c <USB_EP0_OutStart>
 80043c4:	e006      	b.n	80043d4 <PCD_EP_OutXfrComplete_int+0x120>
          }
          else
          {
            ep->xfer_buff += ep->xfer_count;
 80043c6:	68fb      	ldr	r3, [r7, #12]
 80043c8:	68da      	ldr	r2, [r3, #12]
 80043ca:	68fb      	ldr	r3, [r7, #12]
 80043cc:	695b      	ldr	r3, [r3, #20]
 80043ce:	441a      	add	r2, r3
 80043d0:	68fb      	ldr	r3, [r7, #12]
 80043d2:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80043d4:	683b      	ldr	r3, [r7, #0]
 80043d6:	b2db      	uxtb	r3, r3
 80043d8:	4619      	mov	r1, r3
 80043da:	6878      	ldr	r0, [r7, #4]
 80043dc:	f023 fe1e 	bl	802801c <HAL_PCD_DataOutStageCallback>
 80043e0:	e046      	b.n	8004470 <PCD_EP_OutXfrComplete_int+0x1bc>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 80043e2:	697b      	ldr	r3, [r7, #20]
 80043e4:	4a26      	ldr	r2, [pc, #152]	@ (8004480 <PCD_EP_OutXfrComplete_int+0x1cc>)
 80043e6:	4293      	cmp	r3, r2
 80043e8:	d124      	bne.n	8004434 <PCD_EP_OutXfrComplete_int+0x180>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 80043ea:	693b      	ldr	r3, [r7, #16]
 80043ec:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80043f0:	2b00      	cmp	r3, #0
 80043f2:	d00a      	beq.n	800440a <PCD_EP_OutXfrComplete_int+0x156>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80043f4:	683b      	ldr	r3, [r7, #0]
 80043f6:	015a      	lsls	r2, r3, #5
 80043f8:	69bb      	ldr	r3, [r7, #24]
 80043fa:	4413      	add	r3, r2
 80043fc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004400:	461a      	mov	r2, r3
 8004402:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8004406:	6093      	str	r3, [r2, #8]
 8004408:	e032      	b.n	8004470 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 800440a:	693b      	ldr	r3, [r7, #16]
 800440c:	f003 0320 	and.w	r3, r3, #32
 8004410:	2b00      	cmp	r3, #0
 8004412:	d008      	beq.n	8004426 <PCD_EP_OutXfrComplete_int+0x172>
        {
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8004414:	683b      	ldr	r3, [r7, #0]
 8004416:	015a      	lsls	r2, r3, #5
 8004418:	69bb      	ldr	r3, [r7, #24]
 800441a:	4413      	add	r3, r2
 800441c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004420:	461a      	mov	r2, r3
 8004422:	2320      	movs	r3, #32
 8004424:	6093      	str	r3, [r2, #8]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8004426:	683b      	ldr	r3, [r7, #0]
 8004428:	b2db      	uxtb	r3, r3
 800442a:	4619      	mov	r1, r3
 800442c:	6878      	ldr	r0, [r7, #4]
 800442e:	f023 fdf5 	bl	802801c <HAL_PCD_DataOutStageCallback>
 8004432:	e01d      	b.n	8004470 <PCD_EP_OutXfrComplete_int+0x1bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8004434:	683b      	ldr	r3, [r7, #0]
 8004436:	2b00      	cmp	r3, #0
 8004438:	d114      	bne.n	8004464 <PCD_EP_OutXfrComplete_int+0x1b0>
 800443a:	6879      	ldr	r1, [r7, #4]
 800443c:	683a      	ldr	r2, [r7, #0]
 800443e:	4613      	mov	r3, r2
 8004440:	00db      	lsls	r3, r3, #3
 8004442:	4413      	add	r3, r2
 8004444:	009b      	lsls	r3, r3, #2
 8004446:	440b      	add	r3, r1
 8004448:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 800444c:	681b      	ldr	r3, [r3, #0]
 800444e:	2b00      	cmp	r3, #0
 8004450:	d108      	bne.n	8004464 <PCD_EP_OutXfrComplete_int+0x1b0>
      {
        /* this is ZLP, so prepare EP0 for next setup */
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 8004452:	687b      	ldr	r3, [r7, #4]
 8004454:	6818      	ldr	r0, [r3, #0]
 8004456:	687b      	ldr	r3, [r7, #4]
 8004458:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 800445c:	461a      	mov	r2, r3
 800445e:	2100      	movs	r1, #0
 8004460:	f002 fa6c 	bl	800693c <USB_EP0_OutStart>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8004464:	683b      	ldr	r3, [r7, #0]
 8004466:	b2db      	uxtb	r3, r3
 8004468:	4619      	mov	r1, r3
 800446a:	6878      	ldr	r0, [r7, #4]
 800446c:	f023 fdd6 	bl	802801c <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
 8004470:	2300      	movs	r3, #0
}
 8004472:	4618      	mov	r0, r3
 8004474:	3720      	adds	r7, #32
 8004476:	46bd      	mov	sp, r7
 8004478:	bd80      	pop	{r7, pc}
 800447a:	bf00      	nop
 800447c:	4f54300a 	.word	0x4f54300a
 8004480:	4f54310a 	.word	0x4f54310a

08004484 <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8004484:	b580      	push	{r7, lr}
 8004486:	b086      	sub	sp, #24
 8004488:	af00      	add	r7, sp, #0
 800448a:	6078      	str	r0, [r7, #4]
 800448c:	6039      	str	r1, [r7, #0]
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800448e:	687b      	ldr	r3, [r7, #4]
 8004490:	681b      	ldr	r3, [r3, #0]
 8004492:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004494:	697b      	ldr	r3, [r7, #20]
 8004496:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8004498:	697b      	ldr	r3, [r7, #20]
 800449a:	333c      	adds	r3, #60	@ 0x3c
 800449c:	3304      	adds	r3, #4
 800449e:	681b      	ldr	r3, [r3, #0]
 80044a0:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80044a2:	683b      	ldr	r3, [r7, #0]
 80044a4:	015a      	lsls	r2, r3, #5
 80044a6:	693b      	ldr	r3, [r7, #16]
 80044a8:	4413      	add	r3, r2
 80044aa:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80044ae:	689b      	ldr	r3, [r3, #8]
 80044b0:	60bb      	str	r3, [r7, #8]

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80044b2:	68fb      	ldr	r3, [r7, #12]
 80044b4:	4a15      	ldr	r2, [pc, #84]	@ (800450c <PCD_EP_OutSetupPacket_int+0x88>)
 80044b6:	4293      	cmp	r3, r2
 80044b8:	d90e      	bls.n	80044d8 <PCD_EP_OutSetupPacket_int+0x54>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 80044ba:	68bb      	ldr	r3, [r7, #8]
 80044bc:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80044c0:	2b00      	cmp	r3, #0
 80044c2:	d009      	beq.n	80044d8 <PCD_EP_OutSetupPacket_int+0x54>
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80044c4:	683b      	ldr	r3, [r7, #0]
 80044c6:	015a      	lsls	r2, r3, #5
 80044c8:	693b      	ldr	r3, [r7, #16]
 80044ca:	4413      	add	r3, r2
 80044cc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80044d0:	461a      	mov	r2, r3
 80044d2:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80044d6:	6093      	str	r3, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 80044d8:	6878      	ldr	r0, [r7, #4]
 80044da:	f023 fd8d 	bl	8027ff8 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 80044de:	68fb      	ldr	r3, [r7, #12]
 80044e0:	4a0a      	ldr	r2, [pc, #40]	@ (800450c <PCD_EP_OutSetupPacket_int+0x88>)
 80044e2:	4293      	cmp	r3, r2
 80044e4:	d90c      	bls.n	8004500 <PCD_EP_OutSetupPacket_int+0x7c>
 80044e6:	687b      	ldr	r3, [r7, #4]
 80044e8:	799b      	ldrb	r3, [r3, #6]
 80044ea:	2b01      	cmp	r3, #1
 80044ec:	d108      	bne.n	8004500 <PCD_EP_OutSetupPacket_int+0x7c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80044ee:	687b      	ldr	r3, [r7, #4]
 80044f0:	6818      	ldr	r0, [r3, #0]
 80044f2:	687b      	ldr	r3, [r7, #4]
 80044f4:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 80044f8:	461a      	mov	r2, r3
 80044fa:	2101      	movs	r1, #1
 80044fc:	f002 fa1e 	bl	800693c <USB_EP0_OutStart>
  }

  return HAL_OK;
 8004500:	2300      	movs	r3, #0
}
 8004502:	4618      	mov	r0, r3
 8004504:	3718      	adds	r7, #24
 8004506:	46bd      	mov	sp, r7
 8004508:	bd80      	pop	{r7, pc}
 800450a:	bf00      	nop
 800450c:	4f54300a 	.word	0x4f54300a

08004510 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8004510:	b480      	push	{r7}
 8004512:	b085      	sub	sp, #20
 8004514:	af00      	add	r7, sp, #0
 8004516:	6078      	str	r0, [r7, #4]
 8004518:	460b      	mov	r3, r1
 800451a:	70fb      	strb	r3, [r7, #3]
 800451c:	4613      	mov	r3, r2
 800451e:	803b      	strh	r3, [r7, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8004520:	687b      	ldr	r3, [r7, #4]
 8004522:	681b      	ldr	r3, [r3, #0]
 8004524:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004526:	60bb      	str	r3, [r7, #8]

  if (fifo == 0U)
 8004528:	78fb      	ldrb	r3, [r7, #3]
 800452a:	2b00      	cmp	r3, #0
 800452c:	d107      	bne.n	800453e <HAL_PCDEx_SetTxFiFo+0x2e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 800452e:	883b      	ldrh	r3, [r7, #0]
 8004530:	0419      	lsls	r1, r3, #16
 8004532:	687b      	ldr	r3, [r7, #4]
 8004534:	681b      	ldr	r3, [r3, #0]
 8004536:	68ba      	ldr	r2, [r7, #8]
 8004538:	430a      	orrs	r2, r1
 800453a:	629a      	str	r2, [r3, #40]	@ 0x28
 800453c:	e028      	b.n	8004590 <HAL_PCDEx_SetTxFiFo+0x80>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 800453e:	687b      	ldr	r3, [r7, #4]
 8004540:	681b      	ldr	r3, [r3, #0]
 8004542:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004544:	0c1b      	lsrs	r3, r3, #16
 8004546:	68ba      	ldr	r2, [r7, #8]
 8004548:	4413      	add	r3, r2
 800454a:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 800454c:	2300      	movs	r3, #0
 800454e:	73fb      	strb	r3, [r7, #15]
 8004550:	e00d      	b.n	800456e <HAL_PCDEx_SetTxFiFo+0x5e>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8004552:	687b      	ldr	r3, [r7, #4]
 8004554:	681a      	ldr	r2, [r3, #0]
 8004556:	7bfb      	ldrb	r3, [r7, #15]
 8004558:	3340      	adds	r3, #64	@ 0x40
 800455a:	009b      	lsls	r3, r3, #2
 800455c:	4413      	add	r3, r2
 800455e:	685b      	ldr	r3, [r3, #4]
 8004560:	0c1b      	lsrs	r3, r3, #16
 8004562:	68ba      	ldr	r2, [r7, #8]
 8004564:	4413      	add	r3, r2
 8004566:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 8004568:	7bfb      	ldrb	r3, [r7, #15]
 800456a:	3301      	adds	r3, #1
 800456c:	73fb      	strb	r3, [r7, #15]
 800456e:	7bfa      	ldrb	r2, [r7, #15]
 8004570:	78fb      	ldrb	r3, [r7, #3]
 8004572:	3b01      	subs	r3, #1
 8004574:	429a      	cmp	r2, r3
 8004576:	d3ec      	bcc.n	8004552 <HAL_PCDEx_SetTxFiFo+0x42>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8004578:	883b      	ldrh	r3, [r7, #0]
 800457a:	0418      	lsls	r0, r3, #16
 800457c:	687b      	ldr	r3, [r7, #4]
 800457e:	6819      	ldr	r1, [r3, #0]
 8004580:	78fb      	ldrb	r3, [r7, #3]
 8004582:	3b01      	subs	r3, #1
 8004584:	68ba      	ldr	r2, [r7, #8]
 8004586:	4302      	orrs	r2, r0
 8004588:	3340      	adds	r3, #64	@ 0x40
 800458a:	009b      	lsls	r3, r3, #2
 800458c:	440b      	add	r3, r1
 800458e:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
 8004590:	2300      	movs	r3, #0
}
 8004592:	4618      	mov	r0, r3
 8004594:	3714      	adds	r7, #20
 8004596:	46bd      	mov	sp, r7
 8004598:	f85d 7b04 	ldr.w	r7, [sp], #4
 800459c:	4770      	bx	lr

0800459e <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 800459e:	b480      	push	{r7}
 80045a0:	b083      	sub	sp, #12
 80045a2:	af00      	add	r7, sp, #0
 80045a4:	6078      	str	r0, [r7, #4]
 80045a6:	460b      	mov	r3, r1
 80045a8:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
 80045aa:	687b      	ldr	r3, [r7, #4]
 80045ac:	681b      	ldr	r3, [r3, #0]
 80045ae:	887a      	ldrh	r2, [r7, #2]
 80045b0:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_OK;
 80045b2:	2300      	movs	r3, #0
}
 80045b4:	4618      	mov	r0, r3
 80045b6:	370c      	adds	r7, #12
 80045b8:	46bd      	mov	sp, r7
 80045ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80045be:	4770      	bx	lr

080045c0 <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 80045c0:	b480      	push	{r7}
 80045c2:	b083      	sub	sp, #12
 80045c4:	af00      	add	r7, sp, #0
 80045c6:	6078      	str	r0, [r7, #4]
 80045c8:	460b      	mov	r3, r1
 80045ca:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 80045cc:	bf00      	nop
 80045ce:	370c      	adds	r7, #12
 80045d0:	46bd      	mov	sp, r7
 80045d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80045d6:	4770      	bx	lr

080045d8 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80045d8:	b580      	push	{r7, lr}
 80045da:	b086      	sub	sp, #24
 80045dc:	af00      	add	r7, sp, #0
 80045de:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;
  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 80045e0:	687b      	ldr	r3, [r7, #4]
 80045e2:	2b00      	cmp	r3, #0
 80045e4:	d101      	bne.n	80045ea <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 80045e6:	2301      	movs	r3, #1
 80045e8:	e267      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80045ea:	687b      	ldr	r3, [r7, #4]
 80045ec:	681b      	ldr	r3, [r3, #0]
 80045ee:	f003 0301 	and.w	r3, r3, #1
 80045f2:	2b00      	cmp	r3, #0
 80045f4:	d075      	beq.n	80046e2 <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || \
 80045f6:	4b88      	ldr	r3, [pc, #544]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 80045f8:	689b      	ldr	r3, [r3, #8]
 80045fa:	f003 030c 	and.w	r3, r3, #12
 80045fe:	2b04      	cmp	r3, #4
 8004600:	d00c      	beq.n	800461c <HAL_RCC_OscConfig+0x44>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8004602:	4b85      	ldr	r3, [pc, #532]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004604:	689b      	ldr	r3, [r3, #8]
 8004606:	f003 030c 	and.w	r3, r3, #12
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || \
 800460a:	2b08      	cmp	r3, #8
 800460c:	d112      	bne.n	8004634 <HAL_RCC_OscConfig+0x5c>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800460e:	4b82      	ldr	r3, [pc, #520]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004610:	685b      	ldr	r3, [r3, #4]
 8004612:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8004616:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800461a:	d10b      	bne.n	8004634 <HAL_RCC_OscConfig+0x5c>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800461c:	4b7e      	ldr	r3, [pc, #504]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 800461e:	681b      	ldr	r3, [r3, #0]
 8004620:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8004624:	2b00      	cmp	r3, #0
 8004626:	d05b      	beq.n	80046e0 <HAL_RCC_OscConfig+0x108>
 8004628:	687b      	ldr	r3, [r7, #4]
 800462a:	685b      	ldr	r3, [r3, #4]
 800462c:	2b00      	cmp	r3, #0
 800462e:	d157      	bne.n	80046e0 <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 8004630:	2301      	movs	r3, #1
 8004632:	e242      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004634:	687b      	ldr	r3, [r7, #4]
 8004636:	685b      	ldr	r3, [r3, #4]
 8004638:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800463c:	d106      	bne.n	800464c <HAL_RCC_OscConfig+0x74>
 800463e:	4b76      	ldr	r3, [pc, #472]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004640:	681b      	ldr	r3, [r3, #0]
 8004642:	4a75      	ldr	r2, [pc, #468]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004644:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8004648:	6013      	str	r3, [r2, #0]
 800464a:	e01d      	b.n	8004688 <HAL_RCC_OscConfig+0xb0>
 800464c:	687b      	ldr	r3, [r7, #4]
 800464e:	685b      	ldr	r3, [r3, #4]
 8004650:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8004654:	d10c      	bne.n	8004670 <HAL_RCC_OscConfig+0x98>
 8004656:	4b70      	ldr	r3, [pc, #448]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004658:	681b      	ldr	r3, [r3, #0]
 800465a:	4a6f      	ldr	r2, [pc, #444]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 800465c:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8004660:	6013      	str	r3, [r2, #0]
 8004662:	4b6d      	ldr	r3, [pc, #436]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004664:	681b      	ldr	r3, [r3, #0]
 8004666:	4a6c      	ldr	r2, [pc, #432]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004668:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800466c:	6013      	str	r3, [r2, #0]
 800466e:	e00b      	b.n	8004688 <HAL_RCC_OscConfig+0xb0>
 8004670:	4b69      	ldr	r3, [pc, #420]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004672:	681b      	ldr	r3, [r3, #0]
 8004674:	4a68      	ldr	r2, [pc, #416]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004676:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800467a:	6013      	str	r3, [r2, #0]
 800467c:	4b66      	ldr	r3, [pc, #408]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 800467e:	681b      	ldr	r3, [r3, #0]
 8004680:	4a65      	ldr	r2, [pc, #404]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004682:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8004686:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if ((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8004688:	687b      	ldr	r3, [r7, #4]
 800468a:	685b      	ldr	r3, [r3, #4]
 800468c:	2b00      	cmp	r3, #0
 800468e:	d013      	beq.n	80046b8 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004690:	f7fd fc1c 	bl	8001ecc <HAL_GetTick>
 8004694:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004696:	e008      	b.n	80046aa <HAL_RCC_OscConfig+0xd2>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004698:	f7fd fc18 	bl	8001ecc <HAL_GetTick>
 800469c:	4602      	mov	r2, r0
 800469e:	693b      	ldr	r3, [r7, #16]
 80046a0:	1ad3      	subs	r3, r2, r3
 80046a2:	2b64      	cmp	r3, #100	@ 0x64
 80046a4:	d901      	bls.n	80046aa <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 80046a6:	2303      	movs	r3, #3
 80046a8:	e207      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80046aa:	4b5b      	ldr	r3, [pc, #364]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 80046ac:	681b      	ldr	r3, [r3, #0]
 80046ae:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80046b2:	2b00      	cmp	r3, #0
 80046b4:	d0f0      	beq.n	8004698 <HAL_RCC_OscConfig+0xc0>
 80046b6:	e014      	b.n	80046e2 <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80046b8:	f7fd fc08 	bl	8001ecc <HAL_GetTick>
 80046bc:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80046be:	e008      	b.n	80046d2 <HAL_RCC_OscConfig+0xfa>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80046c0:	f7fd fc04 	bl	8001ecc <HAL_GetTick>
 80046c4:	4602      	mov	r2, r0
 80046c6:	693b      	ldr	r3, [r7, #16]
 80046c8:	1ad3      	subs	r3, r2, r3
 80046ca:	2b64      	cmp	r3, #100	@ 0x64
 80046cc:	d901      	bls.n	80046d2 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 80046ce:	2303      	movs	r3, #3
 80046d0:	e1f3      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80046d2:	4b51      	ldr	r3, [pc, #324]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 80046d4:	681b      	ldr	r3, [r3, #0]
 80046d6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80046da:	2b00      	cmp	r3, #0
 80046dc:	d1f0      	bne.n	80046c0 <HAL_RCC_OscConfig+0xe8>
 80046de:	e000      	b.n	80046e2 <HAL_RCC_OscConfig+0x10a>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80046e0:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80046e2:	687b      	ldr	r3, [r7, #4]
 80046e4:	681b      	ldr	r3, [r3, #0]
 80046e6:	f003 0302 	and.w	r3, r3, #2
 80046ea:	2b00      	cmp	r3, #0
 80046ec:	d063      	beq.n	80047b6 <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || \
 80046ee:	4b4a      	ldr	r3, [pc, #296]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 80046f0:	689b      	ldr	r3, [r3, #8]
 80046f2:	f003 030c 	and.w	r3, r3, #12
 80046f6:	2b00      	cmp	r3, #0
 80046f8:	d00b      	beq.n	8004712 <HAL_RCC_OscConfig+0x13a>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80046fa:	4b47      	ldr	r3, [pc, #284]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 80046fc:	689b      	ldr	r3, [r3, #8]
 80046fe:	f003 030c 	and.w	r3, r3, #12
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || \
 8004702:	2b08      	cmp	r3, #8
 8004704:	d11c      	bne.n	8004740 <HAL_RCC_OscConfig+0x168>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8004706:	4b44      	ldr	r3, [pc, #272]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004708:	685b      	ldr	r3, [r3, #4]
 800470a:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800470e:	2b00      	cmp	r3, #0
 8004710:	d116      	bne.n	8004740 <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8004712:	4b41      	ldr	r3, [pc, #260]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004714:	681b      	ldr	r3, [r3, #0]
 8004716:	f003 0302 	and.w	r3, r3, #2
 800471a:	2b00      	cmp	r3, #0
 800471c:	d005      	beq.n	800472a <HAL_RCC_OscConfig+0x152>
 800471e:	687b      	ldr	r3, [r7, #4]
 8004720:	68db      	ldr	r3, [r3, #12]
 8004722:	2b01      	cmp	r3, #1
 8004724:	d001      	beq.n	800472a <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 8004726:	2301      	movs	r3, #1
 8004728:	e1c7      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800472a:	4b3b      	ldr	r3, [pc, #236]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 800472c:	681b      	ldr	r3, [r3, #0]
 800472e:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 8004732:	687b      	ldr	r3, [r7, #4]
 8004734:	691b      	ldr	r3, [r3, #16]
 8004736:	00db      	lsls	r3, r3, #3
 8004738:	4937      	ldr	r1, [pc, #220]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 800473a:	4313      	orrs	r3, r2
 800473c:	600b      	str	r3, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800473e:	e03a      	b.n	80047b6 <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 8004740:	687b      	ldr	r3, [r7, #4]
 8004742:	68db      	ldr	r3, [r3, #12]
 8004744:	2b00      	cmp	r3, #0
 8004746:	d020      	beq.n	800478a <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8004748:	4b34      	ldr	r3, [pc, #208]	@ (800481c <HAL_RCC_OscConfig+0x244>)
 800474a:	2201      	movs	r2, #1
 800474c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800474e:	f7fd fbbd 	bl	8001ecc <HAL_GetTick>
 8004752:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004754:	e008      	b.n	8004768 <HAL_RCC_OscConfig+0x190>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004756:	f7fd fbb9 	bl	8001ecc <HAL_GetTick>
 800475a:	4602      	mov	r2, r0
 800475c:	693b      	ldr	r3, [r7, #16]
 800475e:	1ad3      	subs	r3, r2, r3
 8004760:	2b02      	cmp	r3, #2
 8004762:	d901      	bls.n	8004768 <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 8004764:	2303      	movs	r3, #3
 8004766:	e1a8      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004768:	4b2b      	ldr	r3, [pc, #172]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 800476a:	681b      	ldr	r3, [r3, #0]
 800476c:	f003 0302 	and.w	r3, r3, #2
 8004770:	2b00      	cmp	r3, #0
 8004772:	d0f0      	beq.n	8004756 <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004774:	4b28      	ldr	r3, [pc, #160]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004776:	681b      	ldr	r3, [r3, #0]
 8004778:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 800477c:	687b      	ldr	r3, [r7, #4]
 800477e:	691b      	ldr	r3, [r3, #16]
 8004780:	00db      	lsls	r3, r3, #3
 8004782:	4925      	ldr	r1, [pc, #148]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 8004784:	4313      	orrs	r3, r2
 8004786:	600b      	str	r3, [r1, #0]
 8004788:	e015      	b.n	80047b6 <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800478a:	4b24      	ldr	r3, [pc, #144]	@ (800481c <HAL_RCC_OscConfig+0x244>)
 800478c:	2200      	movs	r2, #0
 800478e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004790:	f7fd fb9c 	bl	8001ecc <HAL_GetTick>
 8004794:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8004796:	e008      	b.n	80047aa <HAL_RCC_OscConfig+0x1d2>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004798:	f7fd fb98 	bl	8001ecc <HAL_GetTick>
 800479c:	4602      	mov	r2, r0
 800479e:	693b      	ldr	r3, [r7, #16]
 80047a0:	1ad3      	subs	r3, r2, r3
 80047a2:	2b02      	cmp	r3, #2
 80047a4:	d901      	bls.n	80047aa <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 80047a6:	2303      	movs	r3, #3
 80047a8:	e187      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80047aa:	4b1b      	ldr	r3, [pc, #108]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 80047ac:	681b      	ldr	r3, [r3, #0]
 80047ae:	f003 0302 	and.w	r3, r3, #2
 80047b2:	2b00      	cmp	r3, #0
 80047b4:	d1f0      	bne.n	8004798 <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80047b6:	687b      	ldr	r3, [r7, #4]
 80047b8:	681b      	ldr	r3, [r3, #0]
 80047ba:	f003 0308 	and.w	r3, r3, #8
 80047be:	2b00      	cmp	r3, #0
 80047c0:	d036      	beq.n	8004830 <HAL_RCC_OscConfig+0x258>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 80047c2:	687b      	ldr	r3, [r7, #4]
 80047c4:	695b      	ldr	r3, [r3, #20]
 80047c6:	2b00      	cmp	r3, #0
 80047c8:	d016      	beq.n	80047f8 <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80047ca:	4b15      	ldr	r3, [pc, #84]	@ (8004820 <HAL_RCC_OscConfig+0x248>)
 80047cc:	2201      	movs	r2, #1
 80047ce:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80047d0:	f7fd fb7c 	bl	8001ecc <HAL_GetTick>
 80047d4:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80047d6:	e008      	b.n	80047ea <HAL_RCC_OscConfig+0x212>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80047d8:	f7fd fb78 	bl	8001ecc <HAL_GetTick>
 80047dc:	4602      	mov	r2, r0
 80047de:	693b      	ldr	r3, [r7, #16]
 80047e0:	1ad3      	subs	r3, r2, r3
 80047e2:	2b02      	cmp	r3, #2
 80047e4:	d901      	bls.n	80047ea <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 80047e6:	2303      	movs	r3, #3
 80047e8:	e167      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80047ea:	4b0b      	ldr	r3, [pc, #44]	@ (8004818 <HAL_RCC_OscConfig+0x240>)
 80047ec:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80047ee:	f003 0302 	and.w	r3, r3, #2
 80047f2:	2b00      	cmp	r3, #0
 80047f4:	d0f0      	beq.n	80047d8 <HAL_RCC_OscConfig+0x200>
 80047f6:	e01b      	b.n	8004830 <HAL_RCC_OscConfig+0x258>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80047f8:	4b09      	ldr	r3, [pc, #36]	@ (8004820 <HAL_RCC_OscConfig+0x248>)
 80047fa:	2200      	movs	r2, #0
 80047fc:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80047fe:	f7fd fb65 	bl	8001ecc <HAL_GetTick>
 8004802:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8004804:	e00e      	b.n	8004824 <HAL_RCC_OscConfig+0x24c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8004806:	f7fd fb61 	bl	8001ecc <HAL_GetTick>
 800480a:	4602      	mov	r2, r0
 800480c:	693b      	ldr	r3, [r7, #16]
 800480e:	1ad3      	subs	r3, r2, r3
 8004810:	2b02      	cmp	r3, #2
 8004812:	d907      	bls.n	8004824 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
 8004814:	2303      	movs	r3, #3
 8004816:	e150      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
 8004818:	40023800 	.word	0x40023800
 800481c:	42470000 	.word	0x42470000
 8004820:	42470e80 	.word	0x42470e80
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8004824:	4b88      	ldr	r3, [pc, #544]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004826:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8004828:	f003 0302 	and.w	r3, r3, #2
 800482c:	2b00      	cmp	r3, #0
 800482e:	d1ea      	bne.n	8004806 <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8004830:	687b      	ldr	r3, [r7, #4]
 8004832:	681b      	ldr	r3, [r3, #0]
 8004834:	f003 0304 	and.w	r3, r3, #4
 8004838:	2b00      	cmp	r3, #0
 800483a:	f000 8097 	beq.w	800496c <HAL_RCC_OscConfig+0x394>
  {
    FlagStatus       pwrclkchanged = RESET;
 800483e:	2300      	movs	r3, #0
 8004840:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8004842:	4b81      	ldr	r3, [pc, #516]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004844:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004846:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800484a:	2b00      	cmp	r3, #0
 800484c:	d10f      	bne.n	800486e <HAL_RCC_OscConfig+0x296>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800484e:	2300      	movs	r3, #0
 8004850:	60bb      	str	r3, [r7, #8]
 8004852:	4b7d      	ldr	r3, [pc, #500]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004854:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004856:	4a7c      	ldr	r2, [pc, #496]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004858:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800485c:	6413      	str	r3, [r2, #64]	@ 0x40
 800485e:	4b7a      	ldr	r3, [pc, #488]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004860:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004862:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8004866:	60bb      	str	r3, [r7, #8]
 8004868:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800486a:	2301      	movs	r3, #1
 800486c:	75fb      	strb	r3, [r7, #23]
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800486e:	4b77      	ldr	r3, [pc, #476]	@ (8004a4c <HAL_RCC_OscConfig+0x474>)
 8004870:	681b      	ldr	r3, [r3, #0]
 8004872:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8004876:	2b00      	cmp	r3, #0
 8004878:	d118      	bne.n	80048ac <HAL_RCC_OscConfig+0x2d4>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800487a:	4b74      	ldr	r3, [pc, #464]	@ (8004a4c <HAL_RCC_OscConfig+0x474>)
 800487c:	681b      	ldr	r3, [r3, #0]
 800487e:	4a73      	ldr	r2, [pc, #460]	@ (8004a4c <HAL_RCC_OscConfig+0x474>)
 8004880:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8004884:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8004886:	f7fd fb21 	bl	8001ecc <HAL_GetTick>
 800488a:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800488c:	e008      	b.n	80048a0 <HAL_RCC_OscConfig+0x2c8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800488e:	f7fd fb1d 	bl	8001ecc <HAL_GetTick>
 8004892:	4602      	mov	r2, r0
 8004894:	693b      	ldr	r3, [r7, #16]
 8004896:	1ad3      	subs	r3, r2, r3
 8004898:	2b02      	cmp	r3, #2
 800489a:	d901      	bls.n	80048a0 <HAL_RCC_OscConfig+0x2c8>
        {
          return HAL_TIMEOUT;
 800489c:	2303      	movs	r3, #3
 800489e:	e10c      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80048a0:	4b6a      	ldr	r3, [pc, #424]	@ (8004a4c <HAL_RCC_OscConfig+0x474>)
 80048a2:	681b      	ldr	r3, [r3, #0]
 80048a4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80048a8:	2b00      	cmp	r3, #0
 80048aa:	d0f0      	beq.n	800488e <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80048ac:	687b      	ldr	r3, [r7, #4]
 80048ae:	689b      	ldr	r3, [r3, #8]
 80048b0:	2b01      	cmp	r3, #1
 80048b2:	d106      	bne.n	80048c2 <HAL_RCC_OscConfig+0x2ea>
 80048b4:	4b64      	ldr	r3, [pc, #400]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80048b6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80048b8:	4a63      	ldr	r2, [pc, #396]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80048ba:	f043 0301 	orr.w	r3, r3, #1
 80048be:	6713      	str	r3, [r2, #112]	@ 0x70
 80048c0:	e01c      	b.n	80048fc <HAL_RCC_OscConfig+0x324>
 80048c2:	687b      	ldr	r3, [r7, #4]
 80048c4:	689b      	ldr	r3, [r3, #8]
 80048c6:	2b05      	cmp	r3, #5
 80048c8:	d10c      	bne.n	80048e4 <HAL_RCC_OscConfig+0x30c>
 80048ca:	4b5f      	ldr	r3, [pc, #380]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80048cc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80048ce:	4a5e      	ldr	r2, [pc, #376]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80048d0:	f043 0304 	orr.w	r3, r3, #4
 80048d4:	6713      	str	r3, [r2, #112]	@ 0x70
 80048d6:	4b5c      	ldr	r3, [pc, #368]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80048d8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80048da:	4a5b      	ldr	r2, [pc, #364]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80048dc:	f043 0301 	orr.w	r3, r3, #1
 80048e0:	6713      	str	r3, [r2, #112]	@ 0x70
 80048e2:	e00b      	b.n	80048fc <HAL_RCC_OscConfig+0x324>
 80048e4:	4b58      	ldr	r3, [pc, #352]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80048e6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80048e8:	4a57      	ldr	r2, [pc, #348]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80048ea:	f023 0301 	bic.w	r3, r3, #1
 80048ee:	6713      	str	r3, [r2, #112]	@ 0x70
 80048f0:	4b55      	ldr	r3, [pc, #340]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80048f2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80048f4:	4a54      	ldr	r2, [pc, #336]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80048f6:	f023 0304 	bic.w	r3, r3, #4
 80048fa:	6713      	str	r3, [r2, #112]	@ 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80048fc:	687b      	ldr	r3, [r7, #4]
 80048fe:	689b      	ldr	r3, [r3, #8]
 8004900:	2b00      	cmp	r3, #0
 8004902:	d015      	beq.n	8004930 <HAL_RCC_OscConfig+0x358>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004904:	f7fd fae2 	bl	8001ecc <HAL_GetTick>
 8004908:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800490a:	e00a      	b.n	8004922 <HAL_RCC_OscConfig+0x34a>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800490c:	f7fd fade 	bl	8001ecc <HAL_GetTick>
 8004910:	4602      	mov	r2, r0
 8004912:	693b      	ldr	r3, [r7, #16]
 8004914:	1ad3      	subs	r3, r2, r3
 8004916:	f241 3288 	movw	r2, #5000	@ 0x1388
 800491a:	4293      	cmp	r3, r2
 800491c:	d901      	bls.n	8004922 <HAL_RCC_OscConfig+0x34a>
        {
          return HAL_TIMEOUT;
 800491e:	2303      	movs	r3, #3
 8004920:	e0cb      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004922:	4b49      	ldr	r3, [pc, #292]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004924:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004926:	f003 0302 	and.w	r3, r3, #2
 800492a:	2b00      	cmp	r3, #0
 800492c:	d0ee      	beq.n	800490c <HAL_RCC_OscConfig+0x334>
 800492e:	e014      	b.n	800495a <HAL_RCC_OscConfig+0x382>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8004930:	f7fd facc 	bl	8001ecc <HAL_GetTick>
 8004934:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8004936:	e00a      	b.n	800494e <HAL_RCC_OscConfig+0x376>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004938:	f7fd fac8 	bl	8001ecc <HAL_GetTick>
 800493c:	4602      	mov	r2, r0
 800493e:	693b      	ldr	r3, [r7, #16]
 8004940:	1ad3      	subs	r3, r2, r3
 8004942:	f241 3288 	movw	r2, #5000	@ 0x1388
 8004946:	4293      	cmp	r3, r2
 8004948:	d901      	bls.n	800494e <HAL_RCC_OscConfig+0x376>
        {
          return HAL_TIMEOUT;
 800494a:	2303      	movs	r3, #3
 800494c:	e0b5      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800494e:	4b3e      	ldr	r3, [pc, #248]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004950:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004952:	f003 0302 	and.w	r3, r3, #2
 8004956:	2b00      	cmp	r3, #0
 8004958:	d1ee      	bne.n	8004938 <HAL_RCC_OscConfig+0x360>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 800495a:	7dfb      	ldrb	r3, [r7, #23]
 800495c:	2b01      	cmp	r3, #1
 800495e:	d105      	bne.n	800496c <HAL_RCC_OscConfig+0x394>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8004960:	4b39      	ldr	r3, [pc, #228]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004962:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004964:	4a38      	ldr	r2, [pc, #224]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004966:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 800496a:	6413      	str	r3, [r2, #64]	@ 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800496c:	687b      	ldr	r3, [r7, #4]
 800496e:	699b      	ldr	r3, [r3, #24]
 8004970:	2b00      	cmp	r3, #0
 8004972:	f000 80a1 	beq.w	8004ab8 <HAL_RCC_OscConfig+0x4e0>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8004976:	4b34      	ldr	r3, [pc, #208]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004978:	689b      	ldr	r3, [r3, #8]
 800497a:	f003 030c 	and.w	r3, r3, #12
 800497e:	2b08      	cmp	r3, #8
 8004980:	d05c      	beq.n	8004a3c <HAL_RCC_OscConfig+0x464>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8004982:	687b      	ldr	r3, [r7, #4]
 8004984:	699b      	ldr	r3, [r3, #24]
 8004986:	2b02      	cmp	r3, #2
 8004988:	d141      	bne.n	8004a0e <HAL_RCC_OscConfig+0x436>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800498a:	4b31      	ldr	r3, [pc, #196]	@ (8004a50 <HAL_RCC_OscConfig+0x478>)
 800498c:	2200      	movs	r2, #0
 800498e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004990:	f7fd fa9c 	bl	8001ecc <HAL_GetTick>
 8004994:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004996:	e008      	b.n	80049aa <HAL_RCC_OscConfig+0x3d2>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004998:	f7fd fa98 	bl	8001ecc <HAL_GetTick>
 800499c:	4602      	mov	r2, r0
 800499e:	693b      	ldr	r3, [r7, #16]
 80049a0:	1ad3      	subs	r3, r2, r3
 80049a2:	2b02      	cmp	r3, #2
 80049a4:	d901      	bls.n	80049aa <HAL_RCC_OscConfig+0x3d2>
          {
            return HAL_TIMEOUT;
 80049a6:	2303      	movs	r3, #3
 80049a8:	e087      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80049aa:	4b27      	ldr	r3, [pc, #156]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80049ac:	681b      	ldr	r3, [r3, #0]
 80049ae:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80049b2:	2b00      	cmp	r3, #0
 80049b4:	d1f0      	bne.n	8004998 <HAL_RCC_OscConfig+0x3c0>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80049b6:	687b      	ldr	r3, [r7, #4]
 80049b8:	69da      	ldr	r2, [r3, #28]
 80049ba:	687b      	ldr	r3, [r7, #4]
 80049bc:	6a1b      	ldr	r3, [r3, #32]
 80049be:	431a      	orrs	r2, r3
 80049c0:	687b      	ldr	r3, [r7, #4]
 80049c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80049c4:	019b      	lsls	r3, r3, #6
 80049c6:	431a      	orrs	r2, r3
 80049c8:	687b      	ldr	r3, [r7, #4]
 80049ca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80049cc:	085b      	lsrs	r3, r3, #1
 80049ce:	3b01      	subs	r3, #1
 80049d0:	041b      	lsls	r3, r3, #16
 80049d2:	431a      	orrs	r2, r3
 80049d4:	687b      	ldr	r3, [r7, #4]
 80049d6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80049d8:	061b      	lsls	r3, r3, #24
 80049da:	491b      	ldr	r1, [pc, #108]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 80049dc:	4313      	orrs	r3, r2
 80049de:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 80049e0:	4b1b      	ldr	r3, [pc, #108]	@ (8004a50 <HAL_RCC_OscConfig+0x478>)
 80049e2:	2201      	movs	r2, #1
 80049e4:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80049e6:	f7fd fa71 	bl	8001ecc <HAL_GetTick>
 80049ea:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80049ec:	e008      	b.n	8004a00 <HAL_RCC_OscConfig+0x428>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80049ee:	f7fd fa6d 	bl	8001ecc <HAL_GetTick>
 80049f2:	4602      	mov	r2, r0
 80049f4:	693b      	ldr	r3, [r7, #16]
 80049f6:	1ad3      	subs	r3, r2, r3
 80049f8:	2b02      	cmp	r3, #2
 80049fa:	d901      	bls.n	8004a00 <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
 80049fc:	2303      	movs	r3, #3
 80049fe:	e05c      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004a00:	4b11      	ldr	r3, [pc, #68]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004a02:	681b      	ldr	r3, [r3, #0]
 8004a04:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8004a08:	2b00      	cmp	r3, #0
 8004a0a:	d0f0      	beq.n	80049ee <HAL_RCC_OscConfig+0x416>
 8004a0c:	e054      	b.n	8004ab8 <HAL_RCC_OscConfig+0x4e0>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8004a0e:	4b10      	ldr	r3, [pc, #64]	@ (8004a50 <HAL_RCC_OscConfig+0x478>)
 8004a10:	2200      	movs	r2, #0
 8004a12:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004a14:	f7fd fa5a 	bl	8001ecc <HAL_GetTick>
 8004a18:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004a1a:	e008      	b.n	8004a2e <HAL_RCC_OscConfig+0x456>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004a1c:	f7fd fa56 	bl	8001ecc <HAL_GetTick>
 8004a20:	4602      	mov	r2, r0
 8004a22:	693b      	ldr	r3, [r7, #16]
 8004a24:	1ad3      	subs	r3, r2, r3
 8004a26:	2b02      	cmp	r3, #2
 8004a28:	d901      	bls.n	8004a2e <HAL_RCC_OscConfig+0x456>
          {
            return HAL_TIMEOUT;
 8004a2a:	2303      	movs	r3, #3
 8004a2c:	e045      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004a2e:	4b06      	ldr	r3, [pc, #24]	@ (8004a48 <HAL_RCC_OscConfig+0x470>)
 8004a30:	681b      	ldr	r3, [r3, #0]
 8004a32:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8004a36:	2b00      	cmp	r3, #0
 8004a38:	d1f0      	bne.n	8004a1c <HAL_RCC_OscConfig+0x444>
 8004a3a:	e03d      	b.n	8004ab8 <HAL_RCC_OscConfig+0x4e0>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8004a3c:	687b      	ldr	r3, [r7, #4]
 8004a3e:	699b      	ldr	r3, [r3, #24]
 8004a40:	2b01      	cmp	r3, #1
 8004a42:	d107      	bne.n	8004a54 <HAL_RCC_OscConfig+0x47c>
      {
        return HAL_ERROR;
 8004a44:	2301      	movs	r3, #1
 8004a46:	e038      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
 8004a48:	40023800 	.word	0x40023800
 8004a4c:	40007000 	.word	0x40007000
 8004a50:	42470060 	.word	0x42470060
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 8004a54:	4b1b      	ldr	r3, [pc, #108]	@ (8004ac4 <HAL_RCC_OscConfig+0x4ec>)
 8004a56:	685b      	ldr	r3, [r3, #4]
 8004a58:	60fb      	str	r3, [r7, #12]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
#else
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8004a5a:	687b      	ldr	r3, [r7, #4]
 8004a5c:	699b      	ldr	r3, [r3, #24]
 8004a5e:	2b01      	cmp	r3, #1
 8004a60:	d028      	beq.n	8004ab4 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8004a62:	68fb      	ldr	r3, [r7, #12]
 8004a64:	f403 0280 	and.w	r2, r3, #4194304	@ 0x400000
 8004a68:	687b      	ldr	r3, [r7, #4]
 8004a6a:	69db      	ldr	r3, [r3, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8004a6c:	429a      	cmp	r2, r3
 8004a6e:	d121      	bne.n	8004ab4 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8004a70:	68fb      	ldr	r3, [r7, #12]
 8004a72:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 8004a76:	687b      	ldr	r3, [r7, #4]
 8004a78:	6a1b      	ldr	r3, [r3, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8004a7a:	429a      	cmp	r2, r3
 8004a7c:	d11a      	bne.n	8004ab4 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 8004a7e:	68fa      	ldr	r2, [r7, #12]
 8004a80:	f647 73c0 	movw	r3, #32704	@ 0x7fc0
 8004a84:	4013      	ands	r3, r2
 8004a86:	687a      	ldr	r2, [r7, #4]
 8004a88:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8004a8a:	0192      	lsls	r2, r2, #6
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8004a8c:	4293      	cmp	r3, r2
 8004a8e:	d111      	bne.n	8004ab4 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8004a90:	68fb      	ldr	r3, [r7, #12]
 8004a92:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
 8004a96:	687b      	ldr	r3, [r7, #4]
 8004a98:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004a9a:	085b      	lsrs	r3, r3, #1
 8004a9c:	3b01      	subs	r3, #1
 8004a9e:	041b      	lsls	r3, r3, #16
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 8004aa0:	429a      	cmp	r2, r3
 8004aa2:	d107      	bne.n	8004ab4 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 8004aa4:	68fb      	ldr	r3, [r7, #12]
 8004aa6:	f003 6270 	and.w	r2, r3, #251658240	@ 0xf000000
 8004aaa:	687b      	ldr	r3, [r7, #4]
 8004aac:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8004aae:	061b      	lsls	r3, r3, #24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8004ab0:	429a      	cmp	r2, r3
 8004ab2:	d001      	beq.n	8004ab8 <HAL_RCC_OscConfig+0x4e0>
#endif /* RCC_PLLCFGR_PLLR */
        {
          return HAL_ERROR;
 8004ab4:	2301      	movs	r3, #1
 8004ab6:	e000      	b.n	8004aba <HAL_RCC_OscConfig+0x4e2>
        }
      }
    }
  }
  return HAL_OK;
 8004ab8:	2300      	movs	r3, #0
}
 8004aba:	4618      	mov	r0, r3
 8004abc:	3718      	adds	r7, #24
 8004abe:	46bd      	mov	sp, r7
 8004ac0:	bd80      	pop	{r7, pc}
 8004ac2:	bf00      	nop
 8004ac4:	40023800 	.word	0x40023800

08004ac8 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8004ac8:	b580      	push	{r7, lr}
 8004aca:	b084      	sub	sp, #16
 8004acc:	af00      	add	r7, sp, #0
 8004ace:	6078      	str	r0, [r7, #4]
 8004ad0:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 8004ad2:	687b      	ldr	r3, [r7, #4]
 8004ad4:	2b00      	cmp	r3, #0
 8004ad6:	d101      	bne.n	8004adc <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8004ad8:	2301      	movs	r3, #1
 8004ada:	e0cc      	b.n	8004c76 <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8004adc:	4b68      	ldr	r3, [pc, #416]	@ (8004c80 <HAL_RCC_ClockConfig+0x1b8>)
 8004ade:	681b      	ldr	r3, [r3, #0]
 8004ae0:	f003 0307 	and.w	r3, r3, #7
 8004ae4:	683a      	ldr	r2, [r7, #0]
 8004ae6:	429a      	cmp	r2, r3
 8004ae8:	d90c      	bls.n	8004b04 <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004aea:	4b65      	ldr	r3, [pc, #404]	@ (8004c80 <HAL_RCC_ClockConfig+0x1b8>)
 8004aec:	683a      	ldr	r2, [r7, #0]
 8004aee:	b2d2      	uxtb	r2, r2
 8004af0:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004af2:	4b63      	ldr	r3, [pc, #396]	@ (8004c80 <HAL_RCC_ClockConfig+0x1b8>)
 8004af4:	681b      	ldr	r3, [r3, #0]
 8004af6:	f003 0307 	and.w	r3, r3, #7
 8004afa:	683a      	ldr	r2, [r7, #0]
 8004afc:	429a      	cmp	r2, r3
 8004afe:	d001      	beq.n	8004b04 <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 8004b00:	2301      	movs	r3, #1
 8004b02:	e0b8      	b.n	8004c76 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8004b04:	687b      	ldr	r3, [r7, #4]
 8004b06:	681b      	ldr	r3, [r3, #0]
 8004b08:	f003 0302 	and.w	r3, r3, #2
 8004b0c:	2b00      	cmp	r3, #0
 8004b0e:	d020      	beq.n	8004b52 <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004b10:	687b      	ldr	r3, [r7, #4]
 8004b12:	681b      	ldr	r3, [r3, #0]
 8004b14:	f003 0304 	and.w	r3, r3, #4
 8004b18:	2b00      	cmp	r3, #0
 8004b1a:	d005      	beq.n	8004b28 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8004b1c:	4b59      	ldr	r3, [pc, #356]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004b1e:	689b      	ldr	r3, [r3, #8]
 8004b20:	4a58      	ldr	r2, [pc, #352]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004b22:	f443 53e0 	orr.w	r3, r3, #7168	@ 0x1c00
 8004b26:	6093      	str	r3, [r2, #8]
    }

    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004b28:	687b      	ldr	r3, [r7, #4]
 8004b2a:	681b      	ldr	r3, [r3, #0]
 8004b2c:	f003 0308 	and.w	r3, r3, #8
 8004b30:	2b00      	cmp	r3, #0
 8004b32:	d005      	beq.n	8004b40 <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8004b34:	4b53      	ldr	r3, [pc, #332]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004b36:	689b      	ldr	r3, [r3, #8]
 8004b38:	4a52      	ldr	r2, [pc, #328]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004b3a:	f443 4360 	orr.w	r3, r3, #57344	@ 0xe000
 8004b3e:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8004b40:	4b50      	ldr	r3, [pc, #320]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004b42:	689b      	ldr	r3, [r3, #8]
 8004b44:	f023 02f0 	bic.w	r2, r3, #240	@ 0xf0
 8004b48:	687b      	ldr	r3, [r7, #4]
 8004b4a:	689b      	ldr	r3, [r3, #8]
 8004b4c:	494d      	ldr	r1, [pc, #308]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004b4e:	4313      	orrs	r3, r2
 8004b50:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8004b52:	687b      	ldr	r3, [r7, #4]
 8004b54:	681b      	ldr	r3, [r3, #0]
 8004b56:	f003 0301 	and.w	r3, r3, #1
 8004b5a:	2b00      	cmp	r3, #0
 8004b5c:	d044      	beq.n	8004be8 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8004b5e:	687b      	ldr	r3, [r7, #4]
 8004b60:	685b      	ldr	r3, [r3, #4]
 8004b62:	2b01      	cmp	r3, #1
 8004b64:	d107      	bne.n	8004b76 <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004b66:	4b47      	ldr	r3, [pc, #284]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004b68:	681b      	ldr	r3, [r3, #0]
 8004b6a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8004b6e:	2b00      	cmp	r3, #0
 8004b70:	d119      	bne.n	8004ba6 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8004b72:	2301      	movs	r3, #1
 8004b74:	e07f      	b.n	8004c76 <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if ((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8004b76:	687b      	ldr	r3, [r7, #4]
 8004b78:	685b      	ldr	r3, [r3, #4]
 8004b7a:	2b02      	cmp	r3, #2
 8004b7c:	d003      	beq.n	8004b86 <HAL_RCC_ClockConfig+0xbe>
             (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 8004b7e:	687b      	ldr	r3, [r7, #4]
 8004b80:	685b      	ldr	r3, [r3, #4]
    else if ((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8004b82:	2b03      	cmp	r3, #3
 8004b84:	d107      	bne.n	8004b96 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004b86:	4b3f      	ldr	r3, [pc, #252]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004b88:	681b      	ldr	r3, [r3, #0]
 8004b8a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8004b8e:	2b00      	cmp	r3, #0
 8004b90:	d109      	bne.n	8004ba6 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8004b92:	2301      	movs	r3, #1
 8004b94:	e06f      	b.n	8004c76 <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004b96:	4b3b      	ldr	r3, [pc, #236]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004b98:	681b      	ldr	r3, [r3, #0]
 8004b9a:	f003 0302 	and.w	r3, r3, #2
 8004b9e:	2b00      	cmp	r3, #0
 8004ba0:	d101      	bne.n	8004ba6 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8004ba2:	2301      	movs	r3, #1
 8004ba4:	e067      	b.n	8004c76 <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8004ba6:	4b37      	ldr	r3, [pc, #220]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004ba8:	689b      	ldr	r3, [r3, #8]
 8004baa:	f023 0203 	bic.w	r2, r3, #3
 8004bae:	687b      	ldr	r3, [r7, #4]
 8004bb0:	685b      	ldr	r3, [r3, #4]
 8004bb2:	4934      	ldr	r1, [pc, #208]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004bb4:	4313      	orrs	r3, r2
 8004bb6:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8004bb8:	f7fd f988 	bl	8001ecc <HAL_GetTick>
 8004bbc:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004bbe:	e00a      	b.n	8004bd6 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004bc0:	f7fd f984 	bl	8001ecc <HAL_GetTick>
 8004bc4:	4602      	mov	r2, r0
 8004bc6:	68fb      	ldr	r3, [r7, #12]
 8004bc8:	1ad3      	subs	r3, r2, r3
 8004bca:	f241 3288 	movw	r2, #5000	@ 0x1388
 8004bce:	4293      	cmp	r3, r2
 8004bd0:	d901      	bls.n	8004bd6 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 8004bd2:	2303      	movs	r3, #3
 8004bd4:	e04f      	b.n	8004c76 <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004bd6:	4b2b      	ldr	r3, [pc, #172]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004bd8:	689b      	ldr	r3, [r3, #8]
 8004bda:	f003 020c 	and.w	r2, r3, #12
 8004bde:	687b      	ldr	r3, [r7, #4]
 8004be0:	685b      	ldr	r3, [r3, #4]
 8004be2:	009b      	lsls	r3, r3, #2
 8004be4:	429a      	cmp	r2, r3
 8004be6:	d1eb      	bne.n	8004bc0 <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8004be8:	4b25      	ldr	r3, [pc, #148]	@ (8004c80 <HAL_RCC_ClockConfig+0x1b8>)
 8004bea:	681b      	ldr	r3, [r3, #0]
 8004bec:	f003 0307 	and.w	r3, r3, #7
 8004bf0:	683a      	ldr	r2, [r7, #0]
 8004bf2:	429a      	cmp	r2, r3
 8004bf4:	d20c      	bcs.n	8004c10 <HAL_RCC_ClockConfig+0x148>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004bf6:	4b22      	ldr	r3, [pc, #136]	@ (8004c80 <HAL_RCC_ClockConfig+0x1b8>)
 8004bf8:	683a      	ldr	r2, [r7, #0]
 8004bfa:	b2d2      	uxtb	r2, r2
 8004bfc:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004bfe:	4b20      	ldr	r3, [pc, #128]	@ (8004c80 <HAL_RCC_ClockConfig+0x1b8>)
 8004c00:	681b      	ldr	r3, [r3, #0]
 8004c02:	f003 0307 	and.w	r3, r3, #7
 8004c06:	683a      	ldr	r2, [r7, #0]
 8004c08:	429a      	cmp	r2, r3
 8004c0a:	d001      	beq.n	8004c10 <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 8004c0c:	2301      	movs	r3, #1
 8004c0e:	e032      	b.n	8004c76 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004c10:	687b      	ldr	r3, [r7, #4]
 8004c12:	681b      	ldr	r3, [r3, #0]
 8004c14:	f003 0304 	and.w	r3, r3, #4
 8004c18:	2b00      	cmp	r3, #0
 8004c1a:	d008      	beq.n	8004c2e <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8004c1c:	4b19      	ldr	r3, [pc, #100]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004c1e:	689b      	ldr	r3, [r3, #8]
 8004c20:	f423 52e0 	bic.w	r2, r3, #7168	@ 0x1c00
 8004c24:	687b      	ldr	r3, [r7, #4]
 8004c26:	68db      	ldr	r3, [r3, #12]
 8004c28:	4916      	ldr	r1, [pc, #88]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004c2a:	4313      	orrs	r3, r2
 8004c2c:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004c2e:	687b      	ldr	r3, [r7, #4]
 8004c30:	681b      	ldr	r3, [r3, #0]
 8004c32:	f003 0308 	and.w	r3, r3, #8
 8004c36:	2b00      	cmp	r3, #0
 8004c38:	d009      	beq.n	8004c4e <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8004c3a:	4b12      	ldr	r3, [pc, #72]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004c3c:	689b      	ldr	r3, [r3, #8]
 8004c3e:	f423 4260 	bic.w	r2, r3, #57344	@ 0xe000
 8004c42:	687b      	ldr	r3, [r7, #4]
 8004c44:	691b      	ldr	r3, [r3, #16]
 8004c46:	00db      	lsls	r3, r3, #3
 8004c48:	490e      	ldr	r1, [pc, #56]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004c4a:	4313      	orrs	r3, r2
 8004c4c:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8004c4e:	f000 f821 	bl	8004c94 <HAL_RCC_GetSysClockFreq>
 8004c52:	4602      	mov	r2, r0
 8004c54:	4b0b      	ldr	r3, [pc, #44]	@ (8004c84 <HAL_RCC_ClockConfig+0x1bc>)
 8004c56:	689b      	ldr	r3, [r3, #8]
 8004c58:	091b      	lsrs	r3, r3, #4
 8004c5a:	f003 030f 	and.w	r3, r3, #15
 8004c5e:	490a      	ldr	r1, [pc, #40]	@ (8004c88 <HAL_RCC_ClockConfig+0x1c0>)
 8004c60:	5ccb      	ldrb	r3, [r1, r3]
 8004c62:	fa22 f303 	lsr.w	r3, r2, r3
 8004c66:	4a09      	ldr	r2, [pc, #36]	@ (8004c8c <HAL_RCC_ClockConfig+0x1c4>)
 8004c68:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick(uwTickPrio);
 8004c6a:	4b09      	ldr	r3, [pc, #36]	@ (8004c90 <HAL_RCC_ClockConfig+0x1c8>)
 8004c6c:	681b      	ldr	r3, [r3, #0]
 8004c6e:	4618      	mov	r0, r3
 8004c70:	f7fd f8e8 	bl	8001e44 <HAL_InitTick>

  return HAL_OK;
 8004c74:	2300      	movs	r3, #0
}
 8004c76:	4618      	mov	r0, r3
 8004c78:	3710      	adds	r7, #16
 8004c7a:	46bd      	mov	sp, r7
 8004c7c:	bd80      	pop	{r7, pc}
 8004c7e:	bf00      	nop
 8004c80:	40023c00 	.word	0x40023c00
 8004c84:	40023800 	.word	0x40023800
 8004c88:	08031ab4 	.word	0x08031ab4
 8004c8c:	20000018 	.word	0x20000018
 8004c90:	2000001c 	.word	0x2000001c

08004c94 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8004c94:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8004c98:	b094      	sub	sp, #80	@ 0x50
 8004c9a:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U;
 8004c9c:	2300      	movs	r3, #0
 8004c9e:	647b      	str	r3, [r7, #68]	@ 0x44
  uint32_t pllvco = 0U;
 8004ca0:	2300      	movs	r3, #0
 8004ca2:	64fb      	str	r3, [r7, #76]	@ 0x4c
  uint32_t pllp = 0U;
 8004ca4:	2300      	movs	r3, #0
 8004ca6:	643b      	str	r3, [r7, #64]	@ 0x40
  uint32_t sysclockfreq = 0U;
 8004ca8:	2300      	movs	r3, #0
 8004caa:	64bb      	str	r3, [r7, #72]	@ 0x48

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8004cac:	4b79      	ldr	r3, [pc, #484]	@ (8004e94 <HAL_RCC_GetSysClockFreq+0x200>)
 8004cae:	689b      	ldr	r3, [r3, #8]
 8004cb0:	f003 030c 	and.w	r3, r3, #12
 8004cb4:	2b08      	cmp	r3, #8
 8004cb6:	d00d      	beq.n	8004cd4 <HAL_RCC_GetSysClockFreq+0x40>
 8004cb8:	2b08      	cmp	r3, #8
 8004cba:	f200 80e1 	bhi.w	8004e80 <HAL_RCC_GetSysClockFreq+0x1ec>
 8004cbe:	2b00      	cmp	r3, #0
 8004cc0:	d002      	beq.n	8004cc8 <HAL_RCC_GetSysClockFreq+0x34>
 8004cc2:	2b04      	cmp	r3, #4
 8004cc4:	d003      	beq.n	8004cce <HAL_RCC_GetSysClockFreq+0x3a>
 8004cc6:	e0db      	b.n	8004e80 <HAL_RCC_GetSysClockFreq+0x1ec>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8004cc8:	4b73      	ldr	r3, [pc, #460]	@ (8004e98 <HAL_RCC_GetSysClockFreq+0x204>)
 8004cca:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004ccc:	e0db      	b.n	8004e86 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8004cce:	4b73      	ldr	r3, [pc, #460]	@ (8004e9c <HAL_RCC_GetSysClockFreq+0x208>)
 8004cd0:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004cd2:	e0d8      	b.n	8004e86 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8004cd4:	4b6f      	ldr	r3, [pc, #444]	@ (8004e94 <HAL_RCC_GetSysClockFreq+0x200>)
 8004cd6:	685b      	ldr	r3, [r3, #4]
 8004cd8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8004cdc:	647b      	str	r3, [r7, #68]	@ 0x44
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8004cde:	4b6d      	ldr	r3, [pc, #436]	@ (8004e94 <HAL_RCC_GetSysClockFreq+0x200>)
 8004ce0:	685b      	ldr	r3, [r3, #4]
 8004ce2:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8004ce6:	2b00      	cmp	r3, #0
 8004ce8:	d063      	beq.n	8004db2 <HAL_RCC_GetSysClockFreq+0x11e>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004cea:	4b6a      	ldr	r3, [pc, #424]	@ (8004e94 <HAL_RCC_GetSysClockFreq+0x200>)
 8004cec:	685b      	ldr	r3, [r3, #4]
 8004cee:	099b      	lsrs	r3, r3, #6
 8004cf0:	2200      	movs	r2, #0
 8004cf2:	63bb      	str	r3, [r7, #56]	@ 0x38
 8004cf4:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8004cf6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8004cf8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004cfc:	633b      	str	r3, [r7, #48]	@ 0x30
 8004cfe:	2300      	movs	r3, #0
 8004d00:	637b      	str	r3, [r7, #52]	@ 0x34
 8004d02:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 8004d06:	4622      	mov	r2, r4
 8004d08:	462b      	mov	r3, r5
 8004d0a:	f04f 0000 	mov.w	r0, #0
 8004d0e:	f04f 0100 	mov.w	r1, #0
 8004d12:	0159      	lsls	r1, r3, #5
 8004d14:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8004d18:	0150      	lsls	r0, r2, #5
 8004d1a:	4602      	mov	r2, r0
 8004d1c:	460b      	mov	r3, r1
 8004d1e:	4621      	mov	r1, r4
 8004d20:	1a51      	subs	r1, r2, r1
 8004d22:	6139      	str	r1, [r7, #16]
 8004d24:	4629      	mov	r1, r5
 8004d26:	eb63 0301 	sbc.w	r3, r3, r1
 8004d2a:	617b      	str	r3, [r7, #20]
 8004d2c:	f04f 0200 	mov.w	r2, #0
 8004d30:	f04f 0300 	mov.w	r3, #0
 8004d34:	e9d7 ab04 	ldrd	sl, fp, [r7, #16]
 8004d38:	4659      	mov	r1, fp
 8004d3a:	018b      	lsls	r3, r1, #6
 8004d3c:	4651      	mov	r1, sl
 8004d3e:	ea43 6391 	orr.w	r3, r3, r1, lsr #26
 8004d42:	4651      	mov	r1, sl
 8004d44:	018a      	lsls	r2, r1, #6
 8004d46:	4651      	mov	r1, sl
 8004d48:	ebb2 0801 	subs.w	r8, r2, r1
 8004d4c:	4659      	mov	r1, fp
 8004d4e:	eb63 0901 	sbc.w	r9, r3, r1
 8004d52:	f04f 0200 	mov.w	r2, #0
 8004d56:	f04f 0300 	mov.w	r3, #0
 8004d5a:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8004d5e:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 8004d62:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 8004d66:	4690      	mov	r8, r2
 8004d68:	4699      	mov	r9, r3
 8004d6a:	4623      	mov	r3, r4
 8004d6c:	eb18 0303 	adds.w	r3, r8, r3
 8004d70:	60bb      	str	r3, [r7, #8]
 8004d72:	462b      	mov	r3, r5
 8004d74:	eb49 0303 	adc.w	r3, r9, r3
 8004d78:	60fb      	str	r3, [r7, #12]
 8004d7a:	f04f 0200 	mov.w	r2, #0
 8004d7e:	f04f 0300 	mov.w	r3, #0
 8004d82:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 8004d86:	4629      	mov	r1, r5
 8004d88:	024b      	lsls	r3, r1, #9
 8004d8a:	4621      	mov	r1, r4
 8004d8c:	ea43 53d1 	orr.w	r3, r3, r1, lsr #23
 8004d90:	4621      	mov	r1, r4
 8004d92:	024a      	lsls	r2, r1, #9
 8004d94:	4610      	mov	r0, r2
 8004d96:	4619      	mov	r1, r3
 8004d98:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8004d9a:	2200      	movs	r2, #0
 8004d9c:	62bb      	str	r3, [r7, #40]	@ 0x28
 8004d9e:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8004da0:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8004da4:	f7fb fa7c 	bl	80002a0 <__aeabi_uldivmod>
 8004da8:	4602      	mov	r2, r0
 8004daa:	460b      	mov	r3, r1
 8004dac:	4613      	mov	r3, r2
 8004dae:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8004db0:	e058      	b.n	8004e64 <HAL_RCC_GetSysClockFreq+0x1d0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004db2:	4b38      	ldr	r3, [pc, #224]	@ (8004e94 <HAL_RCC_GetSysClockFreq+0x200>)
 8004db4:	685b      	ldr	r3, [r3, #4]
 8004db6:	099b      	lsrs	r3, r3, #6
 8004db8:	2200      	movs	r2, #0
 8004dba:	4618      	mov	r0, r3
 8004dbc:	4611      	mov	r1, r2
 8004dbe:	f3c0 0308 	ubfx	r3, r0, #0, #9
 8004dc2:	623b      	str	r3, [r7, #32]
 8004dc4:	2300      	movs	r3, #0
 8004dc6:	627b      	str	r3, [r7, #36]	@ 0x24
 8004dc8:	e9d7 8908 	ldrd	r8, r9, [r7, #32]
 8004dcc:	4642      	mov	r2, r8
 8004dce:	464b      	mov	r3, r9
 8004dd0:	f04f 0000 	mov.w	r0, #0
 8004dd4:	f04f 0100 	mov.w	r1, #0
 8004dd8:	0159      	lsls	r1, r3, #5
 8004dda:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8004dde:	0150      	lsls	r0, r2, #5
 8004de0:	4602      	mov	r2, r0
 8004de2:	460b      	mov	r3, r1
 8004de4:	4641      	mov	r1, r8
 8004de6:	ebb2 0a01 	subs.w	sl, r2, r1
 8004dea:	4649      	mov	r1, r9
 8004dec:	eb63 0b01 	sbc.w	fp, r3, r1
 8004df0:	f04f 0200 	mov.w	r2, #0
 8004df4:	f04f 0300 	mov.w	r3, #0
 8004df8:	ea4f 138b 	mov.w	r3, fp, lsl #6
 8004dfc:	ea43 639a 	orr.w	r3, r3, sl, lsr #26
 8004e00:	ea4f 128a 	mov.w	r2, sl, lsl #6
 8004e04:	ebb2 040a 	subs.w	r4, r2, sl
 8004e08:	eb63 050b 	sbc.w	r5, r3, fp
 8004e0c:	f04f 0200 	mov.w	r2, #0
 8004e10:	f04f 0300 	mov.w	r3, #0
 8004e14:	00eb      	lsls	r3, r5, #3
 8004e16:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8004e1a:	00e2      	lsls	r2, r4, #3
 8004e1c:	4614      	mov	r4, r2
 8004e1e:	461d      	mov	r5, r3
 8004e20:	4643      	mov	r3, r8
 8004e22:	18e3      	adds	r3, r4, r3
 8004e24:	603b      	str	r3, [r7, #0]
 8004e26:	464b      	mov	r3, r9
 8004e28:	eb45 0303 	adc.w	r3, r5, r3
 8004e2c:	607b      	str	r3, [r7, #4]
 8004e2e:	f04f 0200 	mov.w	r2, #0
 8004e32:	f04f 0300 	mov.w	r3, #0
 8004e36:	e9d7 4500 	ldrd	r4, r5, [r7]
 8004e3a:	4629      	mov	r1, r5
 8004e3c:	028b      	lsls	r3, r1, #10
 8004e3e:	4621      	mov	r1, r4
 8004e40:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 8004e44:	4621      	mov	r1, r4
 8004e46:	028a      	lsls	r2, r1, #10
 8004e48:	4610      	mov	r0, r2
 8004e4a:	4619      	mov	r1, r3
 8004e4c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8004e4e:	2200      	movs	r2, #0
 8004e50:	61bb      	str	r3, [r7, #24]
 8004e52:	61fa      	str	r2, [r7, #28]
 8004e54:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8004e58:	f7fb fa22 	bl	80002a0 <__aeabi_uldivmod>
 8004e5c:	4602      	mov	r2, r0
 8004e5e:	460b      	mov	r3, r1
 8004e60:	4613      	mov	r3, r2
 8004e62:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 8004e64:	4b0b      	ldr	r3, [pc, #44]	@ (8004e94 <HAL_RCC_GetSysClockFreq+0x200>)
 8004e66:	685b      	ldr	r3, [r3, #4]
 8004e68:	0c1b      	lsrs	r3, r3, #16
 8004e6a:	f003 0303 	and.w	r3, r3, #3
 8004e6e:	3301      	adds	r3, #1
 8004e70:	005b      	lsls	r3, r3, #1
 8004e72:	643b      	str	r3, [r7, #64]	@ 0x40

      sysclockfreq = pllvco / pllp;
 8004e74:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8004e76:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8004e78:	fbb2 f3f3 	udiv	r3, r2, r3
 8004e7c:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004e7e:	e002      	b.n	8004e86 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 8004e80:	4b05      	ldr	r3, [pc, #20]	@ (8004e98 <HAL_RCC_GetSysClockFreq+0x204>)
 8004e82:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004e84:	bf00      	nop
    }
  }
  return sysclockfreq;
 8004e86:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
}
 8004e88:	4618      	mov	r0, r3
 8004e8a:	3750      	adds	r7, #80	@ 0x50
 8004e8c:	46bd      	mov	sp, r7
 8004e8e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8004e92:	bf00      	nop
 8004e94:	40023800 	.word	0x40023800
 8004e98:	00f42400 	.word	0x00f42400
 8004e9c:	007a1200 	.word	0x007a1200

08004ea0 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8004ea0:	b480      	push	{r7}
 8004ea2:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8004ea4:	4b03      	ldr	r3, [pc, #12]	@ (8004eb4 <HAL_RCC_GetHCLKFreq+0x14>)
 8004ea6:	681b      	ldr	r3, [r3, #0]
}
 8004ea8:	4618      	mov	r0, r3
 8004eaa:	46bd      	mov	sp, r7
 8004eac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004eb0:	4770      	bx	lr
 8004eb2:	bf00      	nop
 8004eb4:	20000018 	.word	0x20000018

08004eb8 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8004eb8:	b580      	push	{r7, lr}
 8004eba:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8004ebc:	f7ff fff0 	bl	8004ea0 <HAL_RCC_GetHCLKFreq>
 8004ec0:	4602      	mov	r2, r0
 8004ec2:	4b05      	ldr	r3, [pc, #20]	@ (8004ed8 <HAL_RCC_GetPCLK1Freq+0x20>)
 8004ec4:	689b      	ldr	r3, [r3, #8]
 8004ec6:	0a9b      	lsrs	r3, r3, #10
 8004ec8:	f003 0307 	and.w	r3, r3, #7
 8004ecc:	4903      	ldr	r1, [pc, #12]	@ (8004edc <HAL_RCC_GetPCLK1Freq+0x24>)
 8004ece:	5ccb      	ldrb	r3, [r1, r3]
 8004ed0:	fa22 f303 	lsr.w	r3, r2, r3
}
 8004ed4:	4618      	mov	r0, r3
 8004ed6:	bd80      	pop	{r7, pc}
 8004ed8:	40023800 	.word	0x40023800
 8004edc:	08031ac4 	.word	0x08031ac4

08004ee0 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8004ee0:	b580      	push	{r7, lr}
 8004ee2:	b086      	sub	sp, #24
 8004ee4:	af00      	add	r7, sp, #0
 8004ee6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8004ee8:	2300      	movs	r3, #0
 8004eea:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg1 = 0U;
 8004eec:	2300      	movs	r3, #0
 8004eee:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8004ef0:	687b      	ldr	r3, [r7, #4]
 8004ef2:	681b      	ldr	r3, [r3, #0]
 8004ef4:	f003 0301 	and.w	r3, r3, #1
 8004ef8:	2b00      	cmp	r3, #0
 8004efa:	d105      	bne.n	8004f08 <HAL_RCCEx_PeriphCLKConfig+0x28>
      (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8004efc:	687b      	ldr	r3, [r7, #4]
 8004efe:	681b      	ldr	r3, [r3, #0]
 8004f00:	f003 0304 	and.w	r3, r3, #4
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8004f04:	2b00      	cmp	r3, #0
 8004f06:	d035      	beq.n	8004f74 <HAL_RCCEx_PeriphCLKConfig+0x94>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
#if defined(STM32F411xE)
    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
#endif /* STM32F411xE */
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8004f08:	4b62      	ldr	r3, [pc, #392]	@ (8005094 <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 8004f0a:	2200      	movs	r2, #0
 8004f0c:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8004f0e:	f7fc ffdd 	bl	8001ecc <HAL_GetTick>
 8004f12:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is disabled */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004f14:	e008      	b.n	8004f28 <HAL_RCCEx_PeriphCLKConfig+0x48>
    {
      if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8004f16:	f7fc ffd9 	bl	8001ecc <HAL_GetTick>
 8004f1a:	4602      	mov	r2, r0
 8004f1c:	697b      	ldr	r3, [r7, #20]
 8004f1e:	1ad3      	subs	r3, r2, r3
 8004f20:	2b02      	cmp	r3, #2
 8004f22:	d901      	bls.n	8004f28 <HAL_RCCEx_PeriphCLKConfig+0x48>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8004f24:	2303      	movs	r3, #3
 8004f26:	e0b0      	b.n	800508a <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004f28:	4b5b      	ldr	r3, [pc, #364]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f2a:	681b      	ldr	r3, [r3, #0]
 8004f2c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8004f30:	2b00      	cmp	r3, #0
 8004f32:	d1f0      	bne.n	8004f16 <HAL_RCCEx_PeriphCLKConfig+0x36>
                                   PeriphClkInit->PLLI2S.PLLI2SR);
#else
    /* Configure the PLLI2S division factors */
    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
 8004f34:	687b      	ldr	r3, [r7, #4]
 8004f36:	685b      	ldr	r3, [r3, #4]
 8004f38:	019a      	lsls	r2, r3, #6
 8004f3a:	687b      	ldr	r3, [r7, #4]
 8004f3c:	689b      	ldr	r3, [r3, #8]
 8004f3e:	071b      	lsls	r3, r3, #28
 8004f40:	4955      	ldr	r1, [pc, #340]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f42:	4313      	orrs	r3, r2
 8004f44:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
#endif /* STM32F411xE */

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 8004f48:	4b52      	ldr	r3, [pc, #328]	@ (8005094 <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 8004f4a:	2201      	movs	r2, #1
 8004f4c:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8004f4e:	f7fc ffbd 	bl	8001ecc <HAL_GetTick>
 8004f52:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8004f54:	e008      	b.n	8004f68 <HAL_RCCEx_PeriphCLKConfig+0x88>
    {
      if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8004f56:	f7fc ffb9 	bl	8001ecc <HAL_GetTick>
 8004f5a:	4602      	mov	r2, r0
 8004f5c:	697b      	ldr	r3, [r7, #20]
 8004f5e:	1ad3      	subs	r3, r2, r3
 8004f60:	2b02      	cmp	r3, #2
 8004f62:	d901      	bls.n	8004f68 <HAL_RCCEx_PeriphCLKConfig+0x88>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8004f64:	2303      	movs	r3, #3
 8004f66:	e090      	b.n	800508a <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8004f68:	4b4b      	ldr	r3, [pc, #300]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f6a:	681b      	ldr	r3, [r3, #0]
 8004f6c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8004f70:	2b00      	cmp	r3, #0
 8004f72:	d0f0      	beq.n	8004f56 <HAL_RCCEx_PeriphCLKConfig+0x76>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8004f74:	687b      	ldr	r3, [r7, #4]
 8004f76:	681b      	ldr	r3, [r3, #0]
 8004f78:	f003 0302 	and.w	r3, r3, #2
 8004f7c:	2b00      	cmp	r3, #0
 8004f7e:	f000 8083 	beq.w	8005088 <HAL_RCCEx_PeriphCLKConfig+0x1a8>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8004f82:	2300      	movs	r3, #0
 8004f84:	60fb      	str	r3, [r7, #12]
 8004f86:	4b44      	ldr	r3, [pc, #272]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f88:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004f8a:	4a43      	ldr	r2, [pc, #268]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f8c:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8004f90:	6413      	str	r3, [r2, #64]	@ 0x40
 8004f92:	4b41      	ldr	r3, [pc, #260]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f94:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004f96:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8004f9a:	60fb      	str	r3, [r7, #12]
 8004f9c:	68fb      	ldr	r3, [r7, #12]

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8004f9e:	4b3f      	ldr	r3, [pc, #252]	@ (800509c <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8004fa0:	681b      	ldr	r3, [r3, #0]
 8004fa2:	4a3e      	ldr	r2, [pc, #248]	@ (800509c <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8004fa4:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8004fa8:	6013      	str	r3, [r2, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 8004faa:	f7fc ff8f 	bl	8001ecc <HAL_GetTick>
 8004fae:	6178      	str	r0, [r7, #20]

    while ((PWR->CR & PWR_CR_DBP) == RESET)
 8004fb0:	e008      	b.n	8004fc4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004fb2:	f7fc ff8b 	bl	8001ecc <HAL_GetTick>
 8004fb6:	4602      	mov	r2, r0
 8004fb8:	697b      	ldr	r3, [r7, #20]
 8004fba:	1ad3      	subs	r3, r2, r3
 8004fbc:	2b02      	cmp	r3, #2
 8004fbe:	d901      	bls.n	8004fc4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
      {
        return HAL_TIMEOUT;
 8004fc0:	2303      	movs	r3, #3
 8004fc2:	e062      	b.n	800508a <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while ((PWR->CR & PWR_CR_DBP) == RESET)
 8004fc4:	4b35      	ldr	r3, [pc, #212]	@ (800509c <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8004fc6:	681b      	ldr	r3, [r3, #0]
 8004fc8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8004fcc:	2b00      	cmp	r3, #0
 8004fce:	d0f0      	beq.n	8004fb2 <HAL_RCCEx_PeriphCLKConfig+0xd2>
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8004fd0:	4b31      	ldr	r3, [pc, #196]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004fd2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004fd4:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004fd8:	613b      	str	r3, [r7, #16]
    if ((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8004fda:	693b      	ldr	r3, [r7, #16]
 8004fdc:	2b00      	cmp	r3, #0
 8004fde:	d02f      	beq.n	8005040 <HAL_RCCEx_PeriphCLKConfig+0x160>
 8004fe0:	687b      	ldr	r3, [r7, #4]
 8004fe2:	68db      	ldr	r3, [r3, #12]
 8004fe4:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004fe8:	693a      	ldr	r2, [r7, #16]
 8004fea:	429a      	cmp	r2, r3
 8004fec:	d028      	beq.n	8005040 <HAL_RCCEx_PeriphCLKConfig+0x160>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8004fee:	4b2a      	ldr	r3, [pc, #168]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004ff0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004ff2:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8004ff6:	613b      	str	r3, [r7, #16]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8004ff8:	4b29      	ldr	r3, [pc, #164]	@ (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x1c0>)
 8004ffa:	2201      	movs	r2, #1
 8004ffc:	601a      	str	r2, [r3, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8004ffe:	4b28      	ldr	r3, [pc, #160]	@ (80050a0 <HAL_RCCEx_PeriphCLKConfig+0x1c0>)
 8005000:	2200      	movs	r2, #0
 8005002:	601a      	str	r2, [r3, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg1;
 8005004:	4a24      	ldr	r2, [pc, #144]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8005006:	693b      	ldr	r3, [r7, #16]
 8005008:	6713      	str	r3, [r2, #112]	@ 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 800500a:	4b23      	ldr	r3, [pc, #140]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 800500c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800500e:	f003 0301 	and.w	r3, r3, #1
 8005012:	2b01      	cmp	r3, #1
 8005014:	d114      	bne.n	8005040 <HAL_RCCEx_PeriphCLKConfig+0x160>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 8005016:	f7fc ff59 	bl	8001ecc <HAL_GetTick>
 800501a:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800501c:	e00a      	b.n	8005034 <HAL_RCCEx_PeriphCLKConfig+0x154>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800501e:	f7fc ff55 	bl	8001ecc <HAL_GetTick>
 8005022:	4602      	mov	r2, r0
 8005024:	697b      	ldr	r3, [r7, #20]
 8005026:	1ad3      	subs	r3, r2, r3
 8005028:	f241 3288 	movw	r2, #5000	@ 0x1388
 800502c:	4293      	cmp	r3, r2
 800502e:	d901      	bls.n	8005034 <HAL_RCCEx_PeriphCLKConfig+0x154>
          {
            return HAL_TIMEOUT;
 8005030:	2303      	movs	r3, #3
 8005032:	e02a      	b.n	800508a <HAL_RCCEx_PeriphCLKConfig+0x1aa>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8005034:	4b18      	ldr	r3, [pc, #96]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8005036:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8005038:	f003 0302 	and.w	r3, r3, #2
 800503c:	2b00      	cmp	r3, #0
 800503e:	d0ee      	beq.n	800501e <HAL_RCCEx_PeriphCLKConfig+0x13e>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8005040:	687b      	ldr	r3, [r7, #4]
 8005042:	68db      	ldr	r3, [r3, #12]
 8005044:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8005048:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 800504c:	d10d      	bne.n	800506a <HAL_RCCEx_PeriphCLKConfig+0x18a>
 800504e:	4b12      	ldr	r3, [pc, #72]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8005050:	689b      	ldr	r3, [r3, #8]
 8005052:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 8005056:	687b      	ldr	r3, [r7, #4]
 8005058:	68db      	ldr	r3, [r3, #12]
 800505a:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 800505e:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8005062:	490d      	ldr	r1, [pc, #52]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8005064:	4313      	orrs	r3, r2
 8005066:	608b      	str	r3, [r1, #8]
 8005068:	e005      	b.n	8005076 <HAL_RCCEx_PeriphCLKConfig+0x196>
 800506a:	4b0b      	ldr	r3, [pc, #44]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 800506c:	689b      	ldr	r3, [r3, #8]
 800506e:	4a0a      	ldr	r2, [pc, #40]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8005070:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
 8005074:	6093      	str	r3, [r2, #8]
 8005076:	4b08      	ldr	r3, [pc, #32]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8005078:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 800507a:	687b      	ldr	r3, [r7, #4]
 800507c:	68db      	ldr	r3, [r3, #12]
 800507e:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8005082:	4905      	ldr	r1, [pc, #20]	@ (8005098 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8005084:	4313      	orrs	r3, r2
 8005086:	670b      	str	r3, [r1, #112]	@ 0x70
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 8005088:	2300      	movs	r3, #0
}
 800508a:	4618      	mov	r0, r3
 800508c:	3718      	adds	r7, #24
 800508e:	46bd      	mov	sp, r7
 8005090:	bd80      	pop	{r7, pc}
 8005092:	bf00      	nop
 8005094:	42470068 	.word	0x42470068
 8005098:	40023800 	.word	0x40023800
 800509c:	40007000 	.word	0x40007000
 80050a0:	42470e40 	.word	0x42470e40

080050a4 <HAL_RCCEx_GetPeriphCLKFreq>:
  *         This parameter can be one of the following values:
  *            @arg RCC_PERIPHCLK_I2S: I2S peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 80050a4:	b480      	push	{r7}
 80050a6:	b087      	sub	sp, #28
 80050a8:	af00      	add	r7, sp, #0
 80050aa:	6078      	str	r0, [r7, #4]
  /* This variable used to store the I2S clock frequency (value in Hz) */
  uint32_t frequency = 0U;
 80050ac:	2300      	movs	r3, #0
 80050ae:	617b      	str	r3, [r7, #20]
  /* This variable used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0U;
 80050b0:	2300      	movs	r3, #0
 80050b2:	613b      	str	r3, [r7, #16]
  uint32_t srcclk = 0U;
 80050b4:	2300      	movs	r3, #0
 80050b6:	60fb      	str	r3, [r7, #12]
  /* This variable used to store the VCO Output (value in Hz) */
  uint32_t vcooutput = 0U;
 80050b8:	2300      	movs	r3, #0
 80050ba:	60bb      	str	r3, [r7, #8]
  switch (PeriphClk)
 80050bc:	687b      	ldr	r3, [r7, #4]
 80050be:	2b01      	cmp	r3, #1
 80050c0:	d13f      	bne.n	8005142 <HAL_RCCEx_GetPeriphCLKFreq+0x9e>
  {
    case RCC_PERIPHCLK_I2S:
    {
      /* Get the current I2S source */
      srcclk = __HAL_RCC_GET_I2S_SOURCE();
 80050c2:	4b24      	ldr	r3, [pc, #144]	@ (8005154 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 80050c4:	689b      	ldr	r3, [r3, #8]
 80050c6:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 80050ca:	60fb      	str	r3, [r7, #12]
      switch (srcclk)
 80050cc:	68fb      	ldr	r3, [r7, #12]
 80050ce:	2b00      	cmp	r3, #0
 80050d0:	d006      	beq.n	80050e0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
 80050d2:	68fb      	ldr	r3, [r7, #12]
 80050d4:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 80050d8:	d12f      	bne.n	800513a <HAL_RCCEx_GetPeriphCLKFreq+0x96>
      {
        /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */
        case RCC_I2SCLKSOURCE_EXT:
        {
          /* Set the I2S clock to the external clock  value */
          frequency = EXTERNAL_CLOCK_VALUE;
 80050da:	4b1f      	ldr	r3, [pc, #124]	@ (8005158 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 80050dc:	617b      	str	r3, [r7, #20]
          break;
 80050de:	e02f      	b.n	8005140 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
          }
#else
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
          if ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 80050e0:	4b1c      	ldr	r3, [pc, #112]	@ (8005154 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 80050e2:	685b      	ldr	r3, [r3, #4]
 80050e4:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80050e8:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 80050ec:	d108      	bne.n	8005100 <HAL_RCCEx_GetPeriphCLKFreq+0x5c>
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 80050ee:	4b19      	ldr	r3, [pc, #100]	@ (8005154 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 80050f0:	685b      	ldr	r3, [r3, #4]
 80050f2:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 80050f6:	4a19      	ldr	r2, [pc, #100]	@ (800515c <HAL_RCCEx_GetPeriphCLKFreq+0xb8>)
 80050f8:	fbb2 f3f3 	udiv	r3, r2, r3
 80050fc:	613b      	str	r3, [r7, #16]
 80050fe:	e007      	b.n	8005110 <HAL_RCCEx_GetPeriphCLKFreq+0x6c>
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8005100:	4b14      	ldr	r3, [pc, #80]	@ (8005154 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8005102:	685b      	ldr	r3, [r3, #4]
 8005104:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8005108:	4a15      	ldr	r2, [pc, #84]	@ (8005160 <HAL_RCCEx_GetPeriphCLKFreq+0xbc>)
 800510a:	fbb2 f3f3 	udiv	r3, r2, r3
 800510e:	613b      	str	r3, [r7, #16]
          }
#endif /* STM32F411xE */
          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
 8005110:	4b10      	ldr	r3, [pc, #64]	@ (8005154 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8005112:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8005116:	099b      	lsrs	r3, r3, #6
 8005118:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800511c:	693b      	ldr	r3, [r7, #16]
 800511e:	fb02 f303 	mul.w	r3, r2, r3
 8005122:	60bb      	str	r3, [r7, #8]
          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
          frequency = (uint32_t)(vcooutput / (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
 8005124:	4b0b      	ldr	r3, [pc, #44]	@ (8005154 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8005126:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800512a:	0f1b      	lsrs	r3, r3, #28
 800512c:	f003 0307 	and.w	r3, r3, #7
 8005130:	68ba      	ldr	r2, [r7, #8]
 8005132:	fbb2 f3f3 	udiv	r3, r2, r3
 8005136:	617b      	str	r3, [r7, #20]
          break;
 8005138:	e002      	b.n	8005140 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
        }
        /* Clock not enabled for I2S*/
        default:
        {
          frequency = 0U;
 800513a:	2300      	movs	r3, #0
 800513c:	617b      	str	r3, [r7, #20]
          break;
 800513e:	bf00      	nop
        }
      }
      break;
 8005140:	e000      	b.n	8005144 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
    }
    default:
    {
      break;
 8005142:	bf00      	nop
    }
  }
  return frequency;
 8005144:	697b      	ldr	r3, [r7, #20]
}
 8005146:	4618      	mov	r0, r3
 8005148:	371c      	adds	r7, #28
 800514a:	46bd      	mov	sp, r7
 800514c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005150:	4770      	bx	lr
 8005152:	bf00      	nop
 8005154:	40023800 	.word	0x40023800
 8005158:	00bb8000 	.word	0x00bb8000
 800515c:	007a1200 	.word	0x007a1200
 8005160:	00f42400 	.word	0x00f42400

08005164 <HAL_RNG_Init>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
 8005164:	b580      	push	{r7, lr}
 8005166:	b082      	sub	sp, #8
 8005168:	af00      	add	r7, sp, #0
 800516a:	6078      	str	r0, [r7, #4]
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 800516c:	687b      	ldr	r3, [r7, #4]
 800516e:	2b00      	cmp	r3, #0
 8005170:	d101      	bne.n	8005176 <HAL_RNG_Init+0x12>
  {
    return HAL_ERROR;
 8005172:	2301      	movs	r3, #1
 8005174:	e01c      	b.n	80051b0 <HAL_RNG_Init+0x4c>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 8005176:	687b      	ldr	r3, [r7, #4]
 8005178:	795b      	ldrb	r3, [r3, #5]
 800517a:	b2db      	uxtb	r3, r3
 800517c:	2b00      	cmp	r3, #0
 800517e:	d105      	bne.n	800518c <HAL_RNG_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hrng->Lock = HAL_UNLOCKED;
 8005180:	687b      	ldr	r3, [r7, #4]
 8005182:	2200      	movs	r2, #0
 8005184:	711a      	strb	r2, [r3, #4]

    /* Init the low level hardware */
    HAL_RNG_MspInit(hrng);
 8005186:	6878      	ldr	r0, [r7, #4]
 8005188:	f7fc fc9c 	bl	8001ac4 <HAL_RNG_MspInit>
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 800518c:	687b      	ldr	r3, [r7, #4]
 800518e:	2202      	movs	r2, #2
 8005190:	715a      	strb	r2, [r3, #5]


  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 8005192:	687b      	ldr	r3, [r7, #4]
 8005194:	681b      	ldr	r3, [r3, #0]
 8005196:	681a      	ldr	r2, [r3, #0]
 8005198:	687b      	ldr	r3, [r7, #4]
 800519a:	681b      	ldr	r3, [r3, #0]
 800519c:	f042 0204 	orr.w	r2, r2, #4
 80051a0:	601a      	str	r2, [r3, #0]

  /* Initialize the RNG state */
  hrng->State = HAL_RNG_STATE_READY;
 80051a2:	687b      	ldr	r3, [r7, #4]
 80051a4:	2201      	movs	r2, #1
 80051a6:	715a      	strb	r2, [r3, #5]

  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 80051a8:	687b      	ldr	r3, [r7, #4]
 80051aa:	2200      	movs	r2, #0
 80051ac:	609a      	str	r2, [r3, #8]

  /* Return function status */
  return HAL_OK;
 80051ae:	2300      	movs	r3, #0
}
 80051b0:	4618      	mov	r0, r3
 80051b2:	3708      	adds	r7, #8
 80051b4:	46bd      	mov	sp, r7
 80051b6:	bd80      	pop	{r7, pc}

080051b8 <HAL_RNG_DeInit>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_DeInit(RNG_HandleTypeDef *hrng)
{
 80051b8:	b580      	push	{r7, lr}
 80051ba:	b082      	sub	sp, #8
 80051bc:	af00      	add	r7, sp, #0
 80051be:	6078      	str	r0, [r7, #4]
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 80051c0:	687b      	ldr	r3, [r7, #4]
 80051c2:	2b00      	cmp	r3, #0
 80051c4:	d101      	bne.n	80051ca <HAL_RNG_DeInit+0x12>
  {
    return HAL_ERROR;
 80051c6:	2301      	movs	r3, #1
 80051c8:	e01c      	b.n	8005204 <HAL_RNG_DeInit+0x4c>
  }

  /* Disable the RNG Peripheral */
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_IE | RNG_CR_RNGEN);
 80051ca:	687b      	ldr	r3, [r7, #4]
 80051cc:	681b      	ldr	r3, [r3, #0]
 80051ce:	681a      	ldr	r2, [r3, #0]
 80051d0:	687b      	ldr	r3, [r7, #4]
 80051d2:	681b      	ldr	r3, [r3, #0]
 80051d4:	f022 020c 	bic.w	r2, r2, #12
 80051d8:	601a      	str	r2, [r3, #0]

  /* Clear RNG interrupt status flags */
  CLEAR_BIT(hrng->Instance->SR, RNG_SR_CEIS | RNG_SR_SEIS);
 80051da:	687b      	ldr	r3, [r7, #4]
 80051dc:	681b      	ldr	r3, [r3, #0]
 80051de:	685a      	ldr	r2, [r3, #4]
 80051e0:	687b      	ldr	r3, [r7, #4]
 80051e2:	681b      	ldr	r3, [r3, #0]
 80051e4:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 80051e8:	605a      	str	r2, [r3, #4]

  /* DeInit the low level hardware */
  hrng->MspDeInitCallback(hrng);
#else
  /* DeInit the low level hardware */
  HAL_RNG_MspDeInit(hrng);
 80051ea:	6878      	ldr	r0, [r7, #4]
 80051ec:	f7fc fc8c 	bl	8001b08 <HAL_RNG_MspDeInit>
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Update the RNG state */
  hrng->State = HAL_RNG_STATE_RESET;
 80051f0:	687b      	ldr	r3, [r7, #4]
 80051f2:	2200      	movs	r2, #0
 80051f4:	715a      	strb	r2, [r3, #5]

  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 80051f6:	687b      	ldr	r3, [r7, #4]
 80051f8:	2200      	movs	r2, #0
 80051fa:	609a      	str	r2, [r3, #8]

  /* Release Lock */
  __HAL_UNLOCK(hrng);
 80051fc:	687b      	ldr	r3, [r7, #4]
 80051fe:	2200      	movs	r2, #0
 8005200:	711a      	strb	r2, [r3, #4]

  /* Return the function status */
  return HAL_OK;
 8005202:	2300      	movs	r3, #0
}
 8005204:	4618      	mov	r0, r3
 8005206:	3708      	adds	r7, #8
 8005208:	46bd      	mov	sp, r7
 800520a:	bd80      	pop	{r7, pc}

0800520c <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 800520c:	b580      	push	{r7, lr}
 800520e:	b084      	sub	sp, #16
 8005210:	af00      	add	r7, sp, #0
 8005212:	6078      	str	r0, [r7, #4]
 8005214:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 8005216:	2300      	movs	r3, #0
 8005218:	73fb      	strb	r3, [r7, #15]

  /* Process Locked */
  __HAL_LOCK(hrng);
 800521a:	687b      	ldr	r3, [r7, #4]
 800521c:	791b      	ldrb	r3, [r3, #4]
 800521e:	2b01      	cmp	r3, #1
 8005220:	d101      	bne.n	8005226 <HAL_RNG_GenerateRandomNumber+0x1a>
 8005222:	2302      	movs	r3, #2
 8005224:	e044      	b.n	80052b0 <HAL_RNG_GenerateRandomNumber+0xa4>
 8005226:	687b      	ldr	r3, [r7, #4]
 8005228:	2201      	movs	r2, #1
 800522a:	711a      	strb	r2, [r3, #4]

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
 800522c:	687b      	ldr	r3, [r7, #4]
 800522e:	795b      	ldrb	r3, [r3, #5]
 8005230:	b2db      	uxtb	r3, r3
 8005232:	2b01      	cmp	r3, #1
 8005234:	d133      	bne.n	800529e <HAL_RNG_GenerateRandomNumber+0x92>
  {
    /* Change RNG peripheral state */
    hrng->State = HAL_RNG_STATE_BUSY;
 8005236:	687b      	ldr	r3, [r7, #4]
 8005238:	2202      	movs	r2, #2
 800523a:	715a      	strb	r2, [r3, #5]

    /* Get tick */
    tickstart = HAL_GetTick();
 800523c:	f7fc fe46 	bl	8001ecc <HAL_GetTick>
 8005240:	60b8      	str	r0, [r7, #8]

    /* Check if data register contains valid random data */
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8005242:	e018      	b.n	8005276 <HAL_RNG_GenerateRandomNumber+0x6a>
    {
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 8005244:	f7fc fe42 	bl	8001ecc <HAL_GetTick>
 8005248:	4602      	mov	r2, r0
 800524a:	68bb      	ldr	r3, [r7, #8]
 800524c:	1ad3      	subs	r3, r2, r3
 800524e:	2b02      	cmp	r3, #2
 8005250:	d911      	bls.n	8005276 <HAL_RNG_GenerateRandomNumber+0x6a>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8005252:	687b      	ldr	r3, [r7, #4]
 8005254:	681b      	ldr	r3, [r3, #0]
 8005256:	685b      	ldr	r3, [r3, #4]
 8005258:	f003 0301 	and.w	r3, r3, #1
 800525c:	2b01      	cmp	r3, #1
 800525e:	d00a      	beq.n	8005276 <HAL_RNG_GenerateRandomNumber+0x6a>
        {
          hrng->State = HAL_RNG_STATE_READY;
 8005260:	687b      	ldr	r3, [r7, #4]
 8005262:	2201      	movs	r2, #1
 8005264:	715a      	strb	r2, [r3, #5]
          hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 8005266:	687b      	ldr	r3, [r7, #4]
 8005268:	2202      	movs	r2, #2
 800526a:	609a      	str	r2, [r3, #8]
          /* Process Unlocked */
          __HAL_UNLOCK(hrng);
 800526c:	687b      	ldr	r3, [r7, #4]
 800526e:	2200      	movs	r2, #0
 8005270:	711a      	strb	r2, [r3, #4]
          return HAL_ERROR;
 8005272:	2301      	movs	r3, #1
 8005274:	e01c      	b.n	80052b0 <HAL_RNG_GenerateRandomNumber+0xa4>
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8005276:	687b      	ldr	r3, [r7, #4]
 8005278:	681b      	ldr	r3, [r3, #0]
 800527a:	685b      	ldr	r3, [r3, #4]
 800527c:	f003 0301 	and.w	r3, r3, #1
 8005280:	2b01      	cmp	r3, #1
 8005282:	d1df      	bne.n	8005244 <HAL_RNG_GenerateRandomNumber+0x38>
        }
      }
    }

    /* Get a 32bit Random number */
    hrng->RandomNumber = hrng->Instance->DR;
 8005284:	687b      	ldr	r3, [r7, #4]
 8005286:	681b      	ldr	r3, [r3, #0]
 8005288:	689a      	ldr	r2, [r3, #8]
 800528a:	687b      	ldr	r3, [r7, #4]
 800528c:	60da      	str	r2, [r3, #12]
    *random32bit = hrng->RandomNumber;
 800528e:	687b      	ldr	r3, [r7, #4]
 8005290:	68da      	ldr	r2, [r3, #12]
 8005292:	683b      	ldr	r3, [r7, #0]
 8005294:	601a      	str	r2, [r3, #0]

    hrng->State = HAL_RNG_STATE_READY;
 8005296:	687b      	ldr	r3, [r7, #4]
 8005298:	2201      	movs	r2, #1
 800529a:	715a      	strb	r2, [r3, #5]
 800529c:	e004      	b.n	80052a8 <HAL_RNG_GenerateRandomNumber+0x9c>
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 800529e:	687b      	ldr	r3, [r7, #4]
 80052a0:	2204      	movs	r2, #4
 80052a2:	609a      	str	r2, [r3, #8]
    status = HAL_ERROR;
 80052a4:	2301      	movs	r3, #1
 80052a6:	73fb      	strb	r3, [r7, #15]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 80052a8:	687b      	ldr	r3, [r7, #4]
 80052aa:	2200      	movs	r2, #0
 80052ac:	711a      	strb	r2, [r3, #4]

  return status;
 80052ae:	7bfb      	ldrb	r3, [r7, #15]
}
 80052b0:	4618      	mov	r0, r3
 80052b2:	3710      	adds	r7, #16
 80052b4:	46bd      	mov	sp, r7
 80052b6:	bd80      	pop	{r7, pc}

080052b8 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80052b8:	b580      	push	{r7, lr}
 80052ba:	b082      	sub	sp, #8
 80052bc:	af00      	add	r7, sp, #0
 80052be:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80052c0:	687b      	ldr	r3, [r7, #4]
 80052c2:	2b00      	cmp	r3, #0
 80052c4:	d101      	bne.n	80052ca <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 80052c6:	2301      	movs	r3, #1
 80052c8:	e07b      	b.n	80053c2 <HAL_SPI_Init+0x10a>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80052ca:	687b      	ldr	r3, [r7, #4]
 80052cc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80052ce:	2b00      	cmp	r3, #0
 80052d0:	d108      	bne.n	80052e4 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 80052d2:	687b      	ldr	r3, [r7, #4]
 80052d4:	685b      	ldr	r3, [r3, #4]
 80052d6:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 80052da:	d009      	beq.n	80052f0 <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80052dc:	687b      	ldr	r3, [r7, #4]
 80052de:	2200      	movs	r2, #0
 80052e0:	61da      	str	r2, [r3, #28]
 80052e2:	e005      	b.n	80052f0 <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 80052e4:	687b      	ldr	r3, [r7, #4]
 80052e6:	2200      	movs	r2, #0
 80052e8:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 80052ea:	687b      	ldr	r3, [r7, #4]
 80052ec:	2200      	movs	r2, #0
 80052ee:	615a      	str	r2, [r3, #20]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80052f0:	687b      	ldr	r3, [r7, #4]
 80052f2:	2200      	movs	r2, #0
 80052f4:	629a      	str	r2, [r3, #40]	@ 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 80052f6:	687b      	ldr	r3, [r7, #4]
 80052f8:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 80052fc:	b2db      	uxtb	r3, r3
 80052fe:	2b00      	cmp	r3, #0
 8005300:	d106      	bne.n	8005310 <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8005302:	687b      	ldr	r3, [r7, #4]
 8005304:	2200      	movs	r2, #0
 8005306:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800530a:	6878      	ldr	r0, [r7, #4]
 800530c:	f7fc fc16 	bl	8001b3c <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8005310:	687b      	ldr	r3, [r7, #4]
 8005312:	2202      	movs	r2, #2
 8005314:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8005318:	687b      	ldr	r3, [r7, #4]
 800531a:	681b      	ldr	r3, [r3, #0]
 800531c:	681a      	ldr	r2, [r3, #0]
 800531e:	687b      	ldr	r3, [r7, #4]
 8005320:	681b      	ldr	r3, [r3, #0]
 8005322:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8005326:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8005328:	687b      	ldr	r3, [r7, #4]
 800532a:	685b      	ldr	r3, [r3, #4]
 800532c:	f403 7282 	and.w	r2, r3, #260	@ 0x104
 8005330:	687b      	ldr	r3, [r7, #4]
 8005332:	689b      	ldr	r3, [r3, #8]
 8005334:	f403 4304 	and.w	r3, r3, #33792	@ 0x8400
 8005338:	431a      	orrs	r2, r3
 800533a:	687b      	ldr	r3, [r7, #4]
 800533c:	68db      	ldr	r3, [r3, #12]
 800533e:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8005342:	431a      	orrs	r2, r3
 8005344:	687b      	ldr	r3, [r7, #4]
 8005346:	691b      	ldr	r3, [r3, #16]
 8005348:	f003 0302 	and.w	r3, r3, #2
 800534c:	431a      	orrs	r2, r3
 800534e:	687b      	ldr	r3, [r7, #4]
 8005350:	695b      	ldr	r3, [r3, #20]
 8005352:	f003 0301 	and.w	r3, r3, #1
 8005356:	431a      	orrs	r2, r3
 8005358:	687b      	ldr	r3, [r7, #4]
 800535a:	699b      	ldr	r3, [r3, #24]
 800535c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8005360:	431a      	orrs	r2, r3
 8005362:	687b      	ldr	r3, [r7, #4]
 8005364:	69db      	ldr	r3, [r3, #28]
 8005366:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 800536a:	431a      	orrs	r2, r3
 800536c:	687b      	ldr	r3, [r7, #4]
 800536e:	6a1b      	ldr	r3, [r3, #32]
 8005370:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8005374:	ea42 0103 	orr.w	r1, r2, r3
 8005378:	687b      	ldr	r3, [r7, #4]
 800537a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800537c:	f403 5200 	and.w	r2, r3, #8192	@ 0x2000
 8005380:	687b      	ldr	r3, [r7, #4]
 8005382:	681b      	ldr	r3, [r3, #0]
 8005384:	430a      	orrs	r2, r1
 8005386:	601a      	str	r2, [r3, #0]
                                  (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
                                  (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
                                  (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 8005388:	687b      	ldr	r3, [r7, #4]
 800538a:	699b      	ldr	r3, [r3, #24]
 800538c:	0c1b      	lsrs	r3, r3, #16
 800538e:	f003 0104 	and.w	r1, r3, #4
 8005392:	687b      	ldr	r3, [r7, #4]
 8005394:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8005396:	f003 0210 	and.w	r2, r3, #16
 800539a:	687b      	ldr	r3, [r7, #4]
 800539c:	681b      	ldr	r3, [r3, #0]
 800539e:	430a      	orrs	r2, r1
 80053a0:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80053a2:	687b      	ldr	r3, [r7, #4]
 80053a4:	681b      	ldr	r3, [r3, #0]
 80053a6:	69da      	ldr	r2, [r3, #28]
 80053a8:	687b      	ldr	r3, [r7, #4]
 80053aa:	681b      	ldr	r3, [r3, #0]
 80053ac:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 80053b0:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80053b2:	687b      	ldr	r3, [r7, #4]
 80053b4:	2200      	movs	r2, #0
 80053b6:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 80053b8:	687b      	ldr	r3, [r7, #4]
 80053ba:	2201      	movs	r2, #1
 80053bc:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  return HAL_OK;
 80053c0:	2300      	movs	r3, #0
}
 80053c2:	4618      	mov	r0, r3
 80053c4:	3708      	adds	r7, #8
 80053c6:	46bd      	mov	sp, r7
 80053c8:	bd80      	pop	{r7, pc}

080053ca <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80053ca:	b084      	sub	sp, #16
 80053cc:	b580      	push	{r7, lr}
 80053ce:	b084      	sub	sp, #16
 80053d0:	af00      	add	r7, sp, #0
 80053d2:	6078      	str	r0, [r7, #4]
 80053d4:	f107 001c 	add.w	r0, r7, #28
 80053d8:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80053dc:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 80053e0:	2b01      	cmp	r3, #1
 80053e2:	d123      	bne.n	800542c <USB_CoreInit+0x62>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80053e4:	687b      	ldr	r3, [r7, #4]
 80053e6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80053e8:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 80053ec:	687b      	ldr	r3, [r7, #4]
 80053ee:	639a      	str	r2, [r3, #56]	@ 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80053f0:	687b      	ldr	r3, [r7, #4]
 80053f2:	68db      	ldr	r3, [r3, #12]
 80053f4:	f423 0384 	bic.w	r3, r3, #4325376	@ 0x420000
 80053f8:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80053fc:	687a      	ldr	r2, [r7, #4]
 80053fe:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8005400:	687b      	ldr	r3, [r7, #4]
 8005402:	68db      	ldr	r3, [r3, #12]
 8005404:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 8005408:	687b      	ldr	r3, [r7, #4]
 800540a:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 800540c:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8005410:	2b01      	cmp	r3, #1
 8005412:	d105      	bne.n	8005420 <USB_CoreInit+0x56>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8005414:	687b      	ldr	r3, [r7, #4]
 8005416:	68db      	ldr	r3, [r3, #12]
 8005418:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
 800541c:	687b      	ldr	r3, [r7, #4]
 800541e:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8005420:	6878      	ldr	r0, [r7, #4]
 8005422:	f001 fae9 	bl	80069f8 <USB_CoreReset>
 8005426:	4603      	mov	r3, r0
 8005428:	73fb      	strb	r3, [r7, #15]
 800542a:	e01b      	b.n	8005464 <USB_CoreInit+0x9a>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 800542c:	687b      	ldr	r3, [r7, #4]
 800542e:	68db      	ldr	r3, [r3, #12]
 8005430:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 8005434:	687b      	ldr	r3, [r7, #4]
 8005436:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8005438:	6878      	ldr	r0, [r7, #4]
 800543a:	f001 fadd 	bl	80069f8 <USB_CoreReset>
 800543e:	4603      	mov	r3, r0
 8005440:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 8005442:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 8005446:	2b00      	cmp	r3, #0
 8005448:	d106      	bne.n	8005458 <USB_CoreInit+0x8e>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800544a:	687b      	ldr	r3, [r7, #4]
 800544c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800544e:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 8005452:	687b      	ldr	r3, [r7, #4]
 8005454:	639a      	str	r2, [r3, #56]	@ 0x38
 8005456:	e005      	b.n	8005464 <USB_CoreInit+0x9a>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8005458:	687b      	ldr	r3, [r7, #4]
 800545a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800545c:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 8005460:	687b      	ldr	r3, [r7, #4]
 8005462:	639a      	str	r2, [r3, #56]	@ 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 8005464:	7fbb      	ldrb	r3, [r7, #30]
 8005466:	2b01      	cmp	r3, #1
 8005468:	d10b      	bne.n	8005482 <USB_CoreInit+0xb8>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 800546a:	687b      	ldr	r3, [r7, #4]
 800546c:	689b      	ldr	r3, [r3, #8]
 800546e:	f043 0206 	orr.w	r2, r3, #6
 8005472:	687b      	ldr	r3, [r7, #4]
 8005474:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8005476:	687b      	ldr	r3, [r7, #4]
 8005478:	689b      	ldr	r3, [r3, #8]
 800547a:	f043 0220 	orr.w	r2, r3, #32
 800547e:	687b      	ldr	r3, [r7, #4]
 8005480:	609a      	str	r2, [r3, #8]
  }

  return ret;
 8005482:	7bfb      	ldrb	r3, [r7, #15]
}
 8005484:	4618      	mov	r0, r3
 8005486:	3710      	adds	r7, #16
 8005488:	46bd      	mov	sp, r7
 800548a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800548e:	b004      	add	sp, #16
 8005490:	4770      	bx	lr
	...

08005494 <USB_SetTurnaroundTime>:
  * @param  hclk: AHB clock frequency
  * @retval USB turnaround time In PHY Clocks number
  */
HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
                                        uint32_t hclk, uint8_t speed)
{
 8005494:	b480      	push	{r7}
 8005496:	b087      	sub	sp, #28
 8005498:	af00      	add	r7, sp, #0
 800549a:	60f8      	str	r0, [r7, #12]
 800549c:	60b9      	str	r1, [r7, #8]
 800549e:	4613      	mov	r3, r2
 80054a0:	71fb      	strb	r3, [r7, #7]

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
 80054a2:	79fb      	ldrb	r3, [r7, #7]
 80054a4:	2b02      	cmp	r3, #2
 80054a6:	d165      	bne.n	8005574 <USB_SetTurnaroundTime+0xe0>
  {
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 80054a8:	68bb      	ldr	r3, [r7, #8]
 80054aa:	4a41      	ldr	r2, [pc, #260]	@ (80055b0 <USB_SetTurnaroundTime+0x11c>)
 80054ac:	4293      	cmp	r3, r2
 80054ae:	d906      	bls.n	80054be <USB_SetTurnaroundTime+0x2a>
 80054b0:	68bb      	ldr	r3, [r7, #8]
 80054b2:	4a40      	ldr	r2, [pc, #256]	@ (80055b4 <USB_SetTurnaroundTime+0x120>)
 80054b4:	4293      	cmp	r3, r2
 80054b6:	d202      	bcs.n	80054be <USB_SetTurnaroundTime+0x2a>
    {
      /* hclk Clock Range between 14.2-15 MHz */
      UsbTrd = 0xFU;
 80054b8:	230f      	movs	r3, #15
 80054ba:	617b      	str	r3, [r7, #20]
 80054bc:	e062      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 80054be:	68bb      	ldr	r3, [r7, #8]
 80054c0:	4a3c      	ldr	r2, [pc, #240]	@ (80055b4 <USB_SetTurnaroundTime+0x120>)
 80054c2:	4293      	cmp	r3, r2
 80054c4:	d306      	bcc.n	80054d4 <USB_SetTurnaroundTime+0x40>
 80054c6:	68bb      	ldr	r3, [r7, #8]
 80054c8:	4a3b      	ldr	r2, [pc, #236]	@ (80055b8 <USB_SetTurnaroundTime+0x124>)
 80054ca:	4293      	cmp	r3, r2
 80054cc:	d202      	bcs.n	80054d4 <USB_SetTurnaroundTime+0x40>
    {
      /* hclk Clock Range between 15-16 MHz */
      UsbTrd = 0xEU;
 80054ce:	230e      	movs	r3, #14
 80054d0:	617b      	str	r3, [r7, #20]
 80054d2:	e057      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 80054d4:	68bb      	ldr	r3, [r7, #8]
 80054d6:	4a38      	ldr	r2, [pc, #224]	@ (80055b8 <USB_SetTurnaroundTime+0x124>)
 80054d8:	4293      	cmp	r3, r2
 80054da:	d306      	bcc.n	80054ea <USB_SetTurnaroundTime+0x56>
 80054dc:	68bb      	ldr	r3, [r7, #8]
 80054de:	4a37      	ldr	r2, [pc, #220]	@ (80055bc <USB_SetTurnaroundTime+0x128>)
 80054e0:	4293      	cmp	r3, r2
 80054e2:	d202      	bcs.n	80054ea <USB_SetTurnaroundTime+0x56>
    {
      /* hclk Clock Range between 16-17.2 MHz */
      UsbTrd = 0xDU;
 80054e4:	230d      	movs	r3, #13
 80054e6:	617b      	str	r3, [r7, #20]
 80054e8:	e04c      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 80054ea:	68bb      	ldr	r3, [r7, #8]
 80054ec:	4a33      	ldr	r2, [pc, #204]	@ (80055bc <USB_SetTurnaroundTime+0x128>)
 80054ee:	4293      	cmp	r3, r2
 80054f0:	d306      	bcc.n	8005500 <USB_SetTurnaroundTime+0x6c>
 80054f2:	68bb      	ldr	r3, [r7, #8]
 80054f4:	4a32      	ldr	r2, [pc, #200]	@ (80055c0 <USB_SetTurnaroundTime+0x12c>)
 80054f6:	4293      	cmp	r3, r2
 80054f8:	d802      	bhi.n	8005500 <USB_SetTurnaroundTime+0x6c>
    {
      /* hclk Clock Range between 17.2-18.5 MHz */
      UsbTrd = 0xCU;
 80054fa:	230c      	movs	r3, #12
 80054fc:	617b      	str	r3, [r7, #20]
 80054fe:	e041      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 8005500:	68bb      	ldr	r3, [r7, #8]
 8005502:	4a2f      	ldr	r2, [pc, #188]	@ (80055c0 <USB_SetTurnaroundTime+0x12c>)
 8005504:	4293      	cmp	r3, r2
 8005506:	d906      	bls.n	8005516 <USB_SetTurnaroundTime+0x82>
 8005508:	68bb      	ldr	r3, [r7, #8]
 800550a:	4a2e      	ldr	r2, [pc, #184]	@ (80055c4 <USB_SetTurnaroundTime+0x130>)
 800550c:	4293      	cmp	r3, r2
 800550e:	d802      	bhi.n	8005516 <USB_SetTurnaroundTime+0x82>
    {
      /* hclk Clock Range between 18.5-20 MHz */
      UsbTrd = 0xBU;
 8005510:	230b      	movs	r3, #11
 8005512:	617b      	str	r3, [r7, #20]
 8005514:	e036      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 8005516:	68bb      	ldr	r3, [r7, #8]
 8005518:	4a2a      	ldr	r2, [pc, #168]	@ (80055c4 <USB_SetTurnaroundTime+0x130>)
 800551a:	4293      	cmp	r3, r2
 800551c:	d906      	bls.n	800552c <USB_SetTurnaroundTime+0x98>
 800551e:	68bb      	ldr	r3, [r7, #8]
 8005520:	4a29      	ldr	r2, [pc, #164]	@ (80055c8 <USB_SetTurnaroundTime+0x134>)
 8005522:	4293      	cmp	r3, r2
 8005524:	d802      	bhi.n	800552c <USB_SetTurnaroundTime+0x98>
    {
      /* hclk Clock Range between 20-21.8 MHz */
      UsbTrd = 0xAU;
 8005526:	230a      	movs	r3, #10
 8005528:	617b      	str	r3, [r7, #20]
 800552a:	e02b      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 800552c:	68bb      	ldr	r3, [r7, #8]
 800552e:	4a26      	ldr	r2, [pc, #152]	@ (80055c8 <USB_SetTurnaroundTime+0x134>)
 8005530:	4293      	cmp	r3, r2
 8005532:	d906      	bls.n	8005542 <USB_SetTurnaroundTime+0xae>
 8005534:	68bb      	ldr	r3, [r7, #8]
 8005536:	4a25      	ldr	r2, [pc, #148]	@ (80055cc <USB_SetTurnaroundTime+0x138>)
 8005538:	4293      	cmp	r3, r2
 800553a:	d202      	bcs.n	8005542 <USB_SetTurnaroundTime+0xae>
    {
      /* hclk Clock Range between 21.8-24 MHz */
      UsbTrd = 0x9U;
 800553c:	2309      	movs	r3, #9
 800553e:	617b      	str	r3, [r7, #20]
 8005540:	e020      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 8005542:	68bb      	ldr	r3, [r7, #8]
 8005544:	4a21      	ldr	r2, [pc, #132]	@ (80055cc <USB_SetTurnaroundTime+0x138>)
 8005546:	4293      	cmp	r3, r2
 8005548:	d306      	bcc.n	8005558 <USB_SetTurnaroundTime+0xc4>
 800554a:	68bb      	ldr	r3, [r7, #8]
 800554c:	4a20      	ldr	r2, [pc, #128]	@ (80055d0 <USB_SetTurnaroundTime+0x13c>)
 800554e:	4293      	cmp	r3, r2
 8005550:	d802      	bhi.n	8005558 <USB_SetTurnaroundTime+0xc4>
    {
      /* hclk Clock Range between 24-27.7 MHz */
      UsbTrd = 0x8U;
 8005552:	2308      	movs	r3, #8
 8005554:	617b      	str	r3, [r7, #20]
 8005556:	e015      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8005558:	68bb      	ldr	r3, [r7, #8]
 800555a:	4a1d      	ldr	r2, [pc, #116]	@ (80055d0 <USB_SetTurnaroundTime+0x13c>)
 800555c:	4293      	cmp	r3, r2
 800555e:	d906      	bls.n	800556e <USB_SetTurnaroundTime+0xda>
 8005560:	68bb      	ldr	r3, [r7, #8]
 8005562:	4a1c      	ldr	r2, [pc, #112]	@ (80055d4 <USB_SetTurnaroundTime+0x140>)
 8005564:	4293      	cmp	r3, r2
 8005566:	d202      	bcs.n	800556e <USB_SetTurnaroundTime+0xda>
    {
      /* hclk Clock Range between 27.7-32 MHz */
      UsbTrd = 0x7U;
 8005568:	2307      	movs	r3, #7
 800556a:	617b      	str	r3, [r7, #20]
 800556c:	e00a      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
    }
    else /* if(hclk >= 32000000) */
    {
      /* hclk Clock Range between 32-200 MHz */
      UsbTrd = 0x6U;
 800556e:	2306      	movs	r3, #6
 8005570:	617b      	str	r3, [r7, #20]
 8005572:	e007      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
    }
  }
  else if (speed == USBD_HS_SPEED)
 8005574:	79fb      	ldrb	r3, [r7, #7]
 8005576:	2b00      	cmp	r3, #0
 8005578:	d102      	bne.n	8005580 <USB_SetTurnaroundTime+0xec>
  {
    UsbTrd = USBD_HS_TRDT_VALUE;
 800557a:	2309      	movs	r3, #9
 800557c:	617b      	str	r3, [r7, #20]
 800557e:	e001      	b.n	8005584 <USB_SetTurnaroundTime+0xf0>
  }
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
 8005580:	2309      	movs	r3, #9
 8005582:	617b      	str	r3, [r7, #20]
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8005584:	68fb      	ldr	r3, [r7, #12]
 8005586:	68db      	ldr	r3, [r3, #12]
 8005588:	f423 5270 	bic.w	r2, r3, #15360	@ 0x3c00
 800558c:	68fb      	ldr	r3, [r7, #12]
 800558e:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 8005590:	68fb      	ldr	r3, [r7, #12]
 8005592:	68da      	ldr	r2, [r3, #12]
 8005594:	697b      	ldr	r3, [r7, #20]
 8005596:	029b      	lsls	r3, r3, #10
 8005598:	f403 5370 	and.w	r3, r3, #15360	@ 0x3c00
 800559c:	431a      	orrs	r2, r3
 800559e:	68fb      	ldr	r3, [r7, #12]
 80055a0:	60da      	str	r2, [r3, #12]

  return HAL_OK;
 80055a2:	2300      	movs	r3, #0
}
 80055a4:	4618      	mov	r0, r3
 80055a6:	371c      	adds	r7, #28
 80055a8:	46bd      	mov	sp, r7
 80055aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80055ae:	4770      	bx	lr
 80055b0:	00d8acbf 	.word	0x00d8acbf
 80055b4:	00e4e1c0 	.word	0x00e4e1c0
 80055b8:	00f42400 	.word	0x00f42400
 80055bc:	01067380 	.word	0x01067380
 80055c0:	011a499f 	.word	0x011a499f
 80055c4:	01312cff 	.word	0x01312cff
 80055c8:	014ca43f 	.word	0x014ca43f
 80055cc:	016e3600 	.word	0x016e3600
 80055d0:	01a6ab1f 	.word	0x01a6ab1f
 80055d4:	01e84800 	.word	0x01e84800

080055d8 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 80055d8:	b480      	push	{r7}
 80055da:	b083      	sub	sp, #12
 80055dc:	af00      	add	r7, sp, #0
 80055de:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 80055e0:	687b      	ldr	r3, [r7, #4]
 80055e2:	689b      	ldr	r3, [r3, #8]
 80055e4:	f043 0201 	orr.w	r2, r3, #1
 80055e8:	687b      	ldr	r3, [r7, #4]
 80055ea:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 80055ec:	2300      	movs	r3, #0
}
 80055ee:	4618      	mov	r0, r3
 80055f0:	370c      	adds	r7, #12
 80055f2:	46bd      	mov	sp, r7
 80055f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80055f8:	4770      	bx	lr

080055fa <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 80055fa:	b480      	push	{r7}
 80055fc:	b083      	sub	sp, #12
 80055fe:	af00      	add	r7, sp, #0
 8005600:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8005602:	687b      	ldr	r3, [r7, #4]
 8005604:	689b      	ldr	r3, [r3, #8]
 8005606:	f023 0201 	bic.w	r2, r3, #1
 800560a:	687b      	ldr	r3, [r7, #4]
 800560c:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 800560e:	2300      	movs	r3, #0
}
 8005610:	4618      	mov	r0, r3
 8005612:	370c      	adds	r7, #12
 8005614:	46bd      	mov	sp, r7
 8005616:	f85d 7b04 	ldr.w	r7, [sp], #4
 800561a:	4770      	bx	lr

0800561c <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 800561c:	b580      	push	{r7, lr}
 800561e:	b084      	sub	sp, #16
 8005620:	af00      	add	r7, sp, #0
 8005622:	6078      	str	r0, [r7, #4]
 8005624:	460b      	mov	r3, r1
 8005626:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
 8005628:	2300      	movs	r3, #0
 800562a:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 800562c:	687b      	ldr	r3, [r7, #4]
 800562e:	68db      	ldr	r3, [r3, #12]
 8005630:	f023 42c0 	bic.w	r2, r3, #1610612736	@ 0x60000000
 8005634:	687b      	ldr	r3, [r7, #4]
 8005636:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 8005638:	78fb      	ldrb	r3, [r7, #3]
 800563a:	2b01      	cmp	r3, #1
 800563c:	d115      	bne.n	800566a <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 800563e:	687b      	ldr	r3, [r7, #4]
 8005640:	68db      	ldr	r3, [r3, #12]
 8005642:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
 8005646:	687b      	ldr	r3, [r7, #4]
 8005648:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 800564a:	200a      	movs	r0, #10
 800564c:	f7fc fc4a 	bl	8001ee4 <HAL_Delay>
      ms += 10U;
 8005650:	68fb      	ldr	r3, [r7, #12]
 8005652:	330a      	adds	r3, #10
 8005654:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8005656:	6878      	ldr	r0, [r7, #4]
 8005658:	f001 f93f 	bl	80068da <USB_GetMode>
 800565c:	4603      	mov	r3, r0
 800565e:	2b01      	cmp	r3, #1
 8005660:	d01e      	beq.n	80056a0 <USB_SetCurrentMode+0x84>
 8005662:	68fb      	ldr	r3, [r7, #12]
 8005664:	2bc7      	cmp	r3, #199	@ 0xc7
 8005666:	d9f0      	bls.n	800564a <USB_SetCurrentMode+0x2e>
 8005668:	e01a      	b.n	80056a0 <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
 800566a:	78fb      	ldrb	r3, [r7, #3]
 800566c:	2b00      	cmp	r3, #0
 800566e:	d115      	bne.n	800569c <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8005670:	687b      	ldr	r3, [r7, #4]
 8005672:	68db      	ldr	r3, [r3, #12]
 8005674:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 8005678:	687b      	ldr	r3, [r7, #4]
 800567a:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 800567c:	200a      	movs	r0, #10
 800567e:	f7fc fc31 	bl	8001ee4 <HAL_Delay>
      ms += 10U;
 8005682:	68fb      	ldr	r3, [r7, #12]
 8005684:	330a      	adds	r3, #10
 8005686:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8005688:	6878      	ldr	r0, [r7, #4]
 800568a:	f001 f926 	bl	80068da <USB_GetMode>
 800568e:	4603      	mov	r3, r0
 8005690:	2b00      	cmp	r3, #0
 8005692:	d005      	beq.n	80056a0 <USB_SetCurrentMode+0x84>
 8005694:	68fb      	ldr	r3, [r7, #12]
 8005696:	2bc7      	cmp	r3, #199	@ 0xc7
 8005698:	d9f0      	bls.n	800567c <USB_SetCurrentMode+0x60>
 800569a:	e001      	b.n	80056a0 <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
 800569c:	2301      	movs	r3, #1
 800569e:	e005      	b.n	80056ac <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 80056a0:	68fb      	ldr	r3, [r7, #12]
 80056a2:	2bc8      	cmp	r3, #200	@ 0xc8
 80056a4:	d101      	bne.n	80056aa <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
 80056a6:	2301      	movs	r3, #1
 80056a8:	e000      	b.n	80056ac <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
 80056aa:	2300      	movs	r3, #0
}
 80056ac:	4618      	mov	r0, r3
 80056ae:	3710      	adds	r7, #16
 80056b0:	46bd      	mov	sp, r7
 80056b2:	bd80      	pop	{r7, pc}

080056b4 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80056b4:	b084      	sub	sp, #16
 80056b6:	b580      	push	{r7, lr}
 80056b8:	b086      	sub	sp, #24
 80056ba:	af00      	add	r7, sp, #0
 80056bc:	6078      	str	r0, [r7, #4]
 80056be:	f107 0024 	add.w	r0, r7, #36	@ 0x24
 80056c2:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
 80056c6:	2300      	movs	r3, #0
 80056c8:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80056ca:	687b      	ldr	r3, [r7, #4]
 80056cc:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  for (i = 0U; i < 15U; i++)
 80056ce:	2300      	movs	r3, #0
 80056d0:	613b      	str	r3, [r7, #16]
 80056d2:	e009      	b.n	80056e8 <USB_DevInit+0x34>
  {
    USBx->DIEPTXF[i] = 0U;
 80056d4:	687a      	ldr	r2, [r7, #4]
 80056d6:	693b      	ldr	r3, [r7, #16]
 80056d8:	3340      	adds	r3, #64	@ 0x40
 80056da:	009b      	lsls	r3, r3, #2
 80056dc:	4413      	add	r3, r2
 80056de:	2200      	movs	r2, #0
 80056e0:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < 15U; i++)
 80056e2:	693b      	ldr	r3, [r7, #16]
 80056e4:	3301      	adds	r3, #1
 80056e6:	613b      	str	r3, [r7, #16]
 80056e8:	693b      	ldr	r3, [r7, #16]
 80056ea:	2b0e      	cmp	r3, #14
 80056ec:	d9f2      	bls.n	80056d4 <USB_DevInit+0x20>
    /* Enable HW VBUS sensing */
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
  }
#else
  /* VBUS Sensing setup */
  if (cfg.vbus_sensing_enable == 0U)
 80056ee:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 80056f2:	2b00      	cmp	r3, #0
 80056f4:	d11c      	bne.n	8005730 <USB_DevInit+0x7c>
  {
    /*
     * Disable HW VBUS sensing. VBUS is internally considered to be always
     * at VBUS-Valid level (5V).
     */
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 80056f6:	68fb      	ldr	r3, [r7, #12]
 80056f8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80056fc:	685b      	ldr	r3, [r3, #4]
 80056fe:	68fa      	ldr	r2, [r7, #12]
 8005700:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8005704:	f043 0302 	orr.w	r3, r3, #2
 8005708:	6053      	str	r3, [r2, #4]
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 800570a:	687b      	ldr	r3, [r7, #4]
 800570c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800570e:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 8005712:	687b      	ldr	r3, [r7, #4]
 8005714:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 8005716:	687b      	ldr	r3, [r7, #4]
 8005718:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800571a:	f423 2200 	bic.w	r2, r3, #524288	@ 0x80000
 800571e:	687b      	ldr	r3, [r7, #4]
 8005720:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 8005722:	687b      	ldr	r3, [r7, #4]
 8005724:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8005726:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
 800572a:	687b      	ldr	r3, [r7, #4]
 800572c:	639a      	str	r2, [r3, #56]	@ 0x38
 800572e:	e00b      	b.n	8005748 <USB_DevInit+0x94>
  }
  else
  {
    /* Enable HW VBUS sensing */
    USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
 8005730:	687b      	ldr	r3, [r7, #4]
 8005732:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8005734:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
 8005738:	687b      	ldr	r3, [r7, #4]
 800573a:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 800573c:	687b      	ldr	r3, [r7, #4]
 800573e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8005740:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
 8005744:	687b      	ldr	r3, [r7, #4]
 8005746:	639a      	str	r2, [r3, #56]	@ 0x38
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8005748:	68fb      	ldr	r3, [r7, #12]
 800574a:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 800574e:	461a      	mov	r2, r3
 8005750:	2300      	movs	r3, #0
 8005752:	6013      	str	r3, [r2, #0]

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8005754:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 8005758:	2b01      	cmp	r3, #1
 800575a:	d10d      	bne.n	8005778 <USB_DevInit+0xc4>
  {
    if (cfg.speed == USBD_HS_SPEED)
 800575c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8005760:	2b00      	cmp	r3, #0
 8005762:	d104      	bne.n	800576e <USB_DevInit+0xba>
    {
      /* Set Core speed to High speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 8005764:	2100      	movs	r1, #0
 8005766:	6878      	ldr	r0, [r7, #4]
 8005768:	f000 f968 	bl	8005a3c <USB_SetDevSpeed>
 800576c:	e008      	b.n	8005780 <USB_DevInit+0xcc>
    }
    else
    {
      /* Set Core speed to Full speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 800576e:	2101      	movs	r1, #1
 8005770:	6878      	ldr	r0, [r7, #4]
 8005772:	f000 f963 	bl	8005a3c <USB_SetDevSpeed>
 8005776:	e003      	b.n	8005780 <USB_DevInit+0xcc>
    }
  }
  else
  {
    /* Set Core speed to Full speed mode */
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 8005778:	2103      	movs	r1, #3
 800577a:	6878      	ldr	r0, [r7, #4]
 800577c:	f000 f95e 	bl	8005a3c <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 8005780:	2110      	movs	r1, #16
 8005782:	6878      	ldr	r0, [r7, #4]
 8005784:	f000 f8fa 	bl	800597c <USB_FlushTxFifo>
 8005788:	4603      	mov	r3, r0
 800578a:	2b00      	cmp	r3, #0
 800578c:	d001      	beq.n	8005792 <USB_DevInit+0xde>
  {
    ret = HAL_ERROR;
 800578e:	2301      	movs	r3, #1
 8005790:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8005792:	6878      	ldr	r0, [r7, #4]
 8005794:	f000 f924 	bl	80059e0 <USB_FlushRxFifo>
 8005798:	4603      	mov	r3, r0
 800579a:	2b00      	cmp	r3, #0
 800579c:	d001      	beq.n	80057a2 <USB_DevInit+0xee>
  {
    ret = HAL_ERROR;
 800579e:	2301      	movs	r3, #1
 80057a0:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 80057a2:	68fb      	ldr	r3, [r7, #12]
 80057a4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80057a8:	461a      	mov	r2, r3
 80057aa:	2300      	movs	r3, #0
 80057ac:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 80057ae:	68fb      	ldr	r3, [r7, #12]
 80057b0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80057b4:	461a      	mov	r2, r3
 80057b6:	2300      	movs	r3, #0
 80057b8:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 80057ba:	68fb      	ldr	r3, [r7, #12]
 80057bc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80057c0:	461a      	mov	r2, r3
 80057c2:	2300      	movs	r3, #0
 80057c4:	61d3      	str	r3, [r2, #28]

  for (i = 0U; i < cfg.dev_endpoints; i++)
 80057c6:	2300      	movs	r3, #0
 80057c8:	613b      	str	r3, [r7, #16]
 80057ca:	e043      	b.n	8005854 <USB_DevInit+0x1a0>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 80057cc:	693b      	ldr	r3, [r7, #16]
 80057ce:	015a      	lsls	r2, r3, #5
 80057d0:	68fb      	ldr	r3, [r7, #12]
 80057d2:	4413      	add	r3, r2
 80057d4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80057d8:	681b      	ldr	r3, [r3, #0]
 80057da:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80057de:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80057e2:	d118      	bne.n	8005816 <USB_DevInit+0x162>
    {
      if (i == 0U)
 80057e4:	693b      	ldr	r3, [r7, #16]
 80057e6:	2b00      	cmp	r3, #0
 80057e8:	d10a      	bne.n	8005800 <USB_DevInit+0x14c>
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 80057ea:	693b      	ldr	r3, [r7, #16]
 80057ec:	015a      	lsls	r2, r3, #5
 80057ee:	68fb      	ldr	r3, [r7, #12]
 80057f0:	4413      	add	r3, r2
 80057f2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80057f6:	461a      	mov	r2, r3
 80057f8:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 80057fc:	6013      	str	r3, [r2, #0]
 80057fe:	e013      	b.n	8005828 <USB_DevInit+0x174>
      }
      else
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8005800:	693b      	ldr	r3, [r7, #16]
 8005802:	015a      	lsls	r2, r3, #5
 8005804:	68fb      	ldr	r3, [r7, #12]
 8005806:	4413      	add	r3, r2
 8005808:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800580c:	461a      	mov	r2, r3
 800580e:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8005812:	6013      	str	r3, [r2, #0]
 8005814:	e008      	b.n	8005828 <USB_DevInit+0x174>
      }
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8005816:	693b      	ldr	r3, [r7, #16]
 8005818:	015a      	lsls	r2, r3, #5
 800581a:	68fb      	ldr	r3, [r7, #12]
 800581c:	4413      	add	r3, r2
 800581e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005822:	461a      	mov	r2, r3
 8005824:	2300      	movs	r3, #0
 8005826:	6013      	str	r3, [r2, #0]
    }

    USBx_INEP(i)->DIEPTSIZ = 0U;
 8005828:	693b      	ldr	r3, [r7, #16]
 800582a:	015a      	lsls	r2, r3, #5
 800582c:	68fb      	ldr	r3, [r7, #12]
 800582e:	4413      	add	r3, r2
 8005830:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005834:	461a      	mov	r2, r3
 8005836:	2300      	movs	r3, #0
 8005838:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 800583a:	693b      	ldr	r3, [r7, #16]
 800583c:	015a      	lsls	r2, r3, #5
 800583e:	68fb      	ldr	r3, [r7, #12]
 8005840:	4413      	add	r3, r2
 8005842:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005846:	461a      	mov	r2, r3
 8005848:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 800584c:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800584e:	693b      	ldr	r3, [r7, #16]
 8005850:	3301      	adds	r3, #1
 8005852:	613b      	str	r3, [r7, #16]
 8005854:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 8005858:	461a      	mov	r2, r3
 800585a:	693b      	ldr	r3, [r7, #16]
 800585c:	4293      	cmp	r3, r2
 800585e:	d3b5      	bcc.n	80057cc <USB_DevInit+0x118>
  }

  for (i = 0U; i < cfg.dev_endpoints; i++)
 8005860:	2300      	movs	r3, #0
 8005862:	613b      	str	r3, [r7, #16]
 8005864:	e043      	b.n	80058ee <USB_DevInit+0x23a>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8005866:	693b      	ldr	r3, [r7, #16]
 8005868:	015a      	lsls	r2, r3, #5
 800586a:	68fb      	ldr	r3, [r7, #12]
 800586c:	4413      	add	r3, r2
 800586e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005872:	681b      	ldr	r3, [r3, #0]
 8005874:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8005878:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800587c:	d118      	bne.n	80058b0 <USB_DevInit+0x1fc>
    {
      if (i == 0U)
 800587e:	693b      	ldr	r3, [r7, #16]
 8005880:	2b00      	cmp	r3, #0
 8005882:	d10a      	bne.n	800589a <USB_DevInit+0x1e6>
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8005884:	693b      	ldr	r3, [r7, #16]
 8005886:	015a      	lsls	r2, r3, #5
 8005888:	68fb      	ldr	r3, [r7, #12]
 800588a:	4413      	add	r3, r2
 800588c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005890:	461a      	mov	r2, r3
 8005892:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8005896:	6013      	str	r3, [r2, #0]
 8005898:	e013      	b.n	80058c2 <USB_DevInit+0x20e>
      }
      else
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 800589a:	693b      	ldr	r3, [r7, #16]
 800589c:	015a      	lsls	r2, r3, #5
 800589e:	68fb      	ldr	r3, [r7, #12]
 80058a0:	4413      	add	r3, r2
 80058a2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80058a6:	461a      	mov	r2, r3
 80058a8:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 80058ac:	6013      	str	r3, [r2, #0]
 80058ae:	e008      	b.n	80058c2 <USB_DevInit+0x20e>
      }
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 80058b0:	693b      	ldr	r3, [r7, #16]
 80058b2:	015a      	lsls	r2, r3, #5
 80058b4:	68fb      	ldr	r3, [r7, #12]
 80058b6:	4413      	add	r3, r2
 80058b8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80058bc:	461a      	mov	r2, r3
 80058be:	2300      	movs	r3, #0
 80058c0:	6013      	str	r3, [r2, #0]
    }

    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 80058c2:	693b      	ldr	r3, [r7, #16]
 80058c4:	015a      	lsls	r2, r3, #5
 80058c6:	68fb      	ldr	r3, [r7, #12]
 80058c8:	4413      	add	r3, r2
 80058ca:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80058ce:	461a      	mov	r2, r3
 80058d0:	2300      	movs	r3, #0
 80058d2:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 80058d4:	693b      	ldr	r3, [r7, #16]
 80058d6:	015a      	lsls	r2, r3, #5
 80058d8:	68fb      	ldr	r3, [r7, #12]
 80058da:	4413      	add	r3, r2
 80058dc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80058e0:	461a      	mov	r2, r3
 80058e2:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 80058e6:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80058e8:	693b      	ldr	r3, [r7, #16]
 80058ea:	3301      	adds	r3, #1
 80058ec:	613b      	str	r3, [r7, #16]
 80058ee:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 80058f2:	461a      	mov	r2, r3
 80058f4:	693b      	ldr	r3, [r7, #16]
 80058f6:	4293      	cmp	r3, r2
 80058f8:	d3b5      	bcc.n	8005866 <USB_DevInit+0x1b2>
  }

  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 80058fa:	68fb      	ldr	r3, [r7, #12]
 80058fc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005900:	691b      	ldr	r3, [r3, #16]
 8005902:	68fa      	ldr	r2, [r7, #12]
 8005904:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8005908:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 800590c:	6113      	str	r3, [r2, #16]

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 800590e:	687b      	ldr	r3, [r7, #4]
 8005910:	2200      	movs	r2, #0
 8005912:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 8005914:	687b      	ldr	r3, [r7, #4]
 8005916:	f06f 4280 	mvn.w	r2, #1073741824	@ 0x40000000
 800591a:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 800591c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8005920:	2b00      	cmp	r3, #0
 8005922:	d105      	bne.n	8005930 <USB_DevInit+0x27c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8005924:	687b      	ldr	r3, [r7, #4]
 8005926:	699b      	ldr	r3, [r3, #24]
 8005928:	f043 0210 	orr.w	r2, r3, #16
 800592c:	687b      	ldr	r3, [r7, #4]
 800592e:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8005930:	687b      	ldr	r3, [r7, #4]
 8005932:	699a      	ldr	r2, [r3, #24]
 8005934:	4b10      	ldr	r3, [pc, #64]	@ (8005978 <USB_DevInit+0x2c4>)
 8005936:	4313      	orrs	r3, r2
 8005938:	687a      	ldr	r2, [r7, #4]
 800593a:	6193      	str	r3, [r2, #24]
                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;

  if (cfg.Sof_enable != 0U)
 800593c:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 8005940:	2b00      	cmp	r3, #0
 8005942:	d005      	beq.n	8005950 <USB_DevInit+0x29c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8005944:	687b      	ldr	r3, [r7, #4]
 8005946:	699b      	ldr	r3, [r3, #24]
 8005948:	f043 0208 	orr.w	r2, r3, #8
 800594c:	687b      	ldr	r3, [r7, #4]
 800594e:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == 1U)
 8005950:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8005954:	2b01      	cmp	r3, #1
 8005956:	d107      	bne.n	8005968 <USB_DevInit+0x2b4>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 8005958:	687b      	ldr	r3, [r7, #4]
 800595a:	699b      	ldr	r3, [r3, #24]
 800595c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8005960:	f043 0304 	orr.w	r3, r3, #4
 8005964:	687a      	ldr	r2, [r7, #4]
 8005966:	6193      	str	r3, [r2, #24]
  }

  return ret;
 8005968:	7dfb      	ldrb	r3, [r7, #23]
}
 800596a:	4618      	mov	r0, r3
 800596c:	3718      	adds	r7, #24
 800596e:	46bd      	mov	sp, r7
 8005970:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8005974:	b004      	add	sp, #16
 8005976:	4770      	bx	lr
 8005978:	803c3800 	.word	0x803c3800

0800597c <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 800597c:	b480      	push	{r7}
 800597e:	b085      	sub	sp, #20
 8005980:	af00      	add	r7, sp, #0
 8005982:	6078      	str	r0, [r7, #4]
 8005984:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 8005986:	2300      	movs	r3, #0
 8005988:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 800598a:	68fb      	ldr	r3, [r7, #12]
 800598c:	3301      	adds	r3, #1
 800598e:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8005990:	68fb      	ldr	r3, [r7, #12]
 8005992:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8005996:	d901      	bls.n	800599c <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
 8005998:	2303      	movs	r3, #3
 800599a:	e01b      	b.n	80059d4 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800599c:	687b      	ldr	r3, [r7, #4]
 800599e:	691b      	ldr	r3, [r3, #16]
 80059a0:	2b00      	cmp	r3, #0
 80059a2:	daf2      	bge.n	800598a <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
 80059a4:	2300      	movs	r3, #0
 80059a6:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 80059a8:	683b      	ldr	r3, [r7, #0]
 80059aa:	019b      	lsls	r3, r3, #6
 80059ac:	f043 0220 	orr.w	r2, r3, #32
 80059b0:	687b      	ldr	r3, [r7, #4]
 80059b2:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 80059b4:	68fb      	ldr	r3, [r7, #12]
 80059b6:	3301      	adds	r3, #1
 80059b8:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 80059ba:	68fb      	ldr	r3, [r7, #12]
 80059bc:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80059c0:	d901      	bls.n	80059c6 <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
 80059c2:	2303      	movs	r3, #3
 80059c4:	e006      	b.n	80059d4 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 80059c6:	687b      	ldr	r3, [r7, #4]
 80059c8:	691b      	ldr	r3, [r3, #16]
 80059ca:	f003 0320 	and.w	r3, r3, #32
 80059ce:	2b20      	cmp	r3, #32
 80059d0:	d0f0      	beq.n	80059b4 <USB_FlushTxFifo+0x38>

  return HAL_OK;
 80059d2:	2300      	movs	r3, #0
}
 80059d4:	4618      	mov	r0, r3
 80059d6:	3714      	adds	r7, #20
 80059d8:	46bd      	mov	sp, r7
 80059da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80059de:	4770      	bx	lr

080059e0 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 80059e0:	b480      	push	{r7}
 80059e2:	b085      	sub	sp, #20
 80059e4:	af00      	add	r7, sp, #0
 80059e6:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 80059e8:	2300      	movs	r3, #0
 80059ea:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 80059ec:	68fb      	ldr	r3, [r7, #12]
 80059ee:	3301      	adds	r3, #1
 80059f0:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 80059f2:	68fb      	ldr	r3, [r7, #12]
 80059f4:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80059f8:	d901      	bls.n	80059fe <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
 80059fa:	2303      	movs	r3, #3
 80059fc:	e018      	b.n	8005a30 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80059fe:	687b      	ldr	r3, [r7, #4]
 8005a00:	691b      	ldr	r3, [r3, #16]
 8005a02:	2b00      	cmp	r3, #0
 8005a04:	daf2      	bge.n	80059ec <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
 8005a06:	2300      	movs	r3, #0
 8005a08:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8005a0a:	687b      	ldr	r3, [r7, #4]
 8005a0c:	2210      	movs	r2, #16
 8005a0e:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8005a10:	68fb      	ldr	r3, [r7, #12]
 8005a12:	3301      	adds	r3, #1
 8005a14:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8005a16:	68fb      	ldr	r3, [r7, #12]
 8005a18:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8005a1c:	d901      	bls.n	8005a22 <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
 8005a1e:	2303      	movs	r3, #3
 8005a20:	e006      	b.n	8005a30 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8005a22:	687b      	ldr	r3, [r7, #4]
 8005a24:	691b      	ldr	r3, [r3, #16]
 8005a26:	f003 0310 	and.w	r3, r3, #16
 8005a2a:	2b10      	cmp	r3, #16
 8005a2c:	d0f0      	beq.n	8005a10 <USB_FlushRxFifo+0x30>

  return HAL_OK;
 8005a2e:	2300      	movs	r3, #0
}
 8005a30:	4618      	mov	r0, r3
 8005a32:	3714      	adds	r7, #20
 8005a34:	46bd      	mov	sp, r7
 8005a36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a3a:	4770      	bx	lr

08005a3c <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(const USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
{
 8005a3c:	b480      	push	{r7}
 8005a3e:	b085      	sub	sp, #20
 8005a40:	af00      	add	r7, sp, #0
 8005a42:	6078      	str	r0, [r7, #4]
 8005a44:	460b      	mov	r3, r1
 8005a46:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005a48:	687b      	ldr	r3, [r7, #4]
 8005a4a:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG |= speed;
 8005a4c:	68fb      	ldr	r3, [r7, #12]
 8005a4e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005a52:	681a      	ldr	r2, [r3, #0]
 8005a54:	78fb      	ldrb	r3, [r7, #3]
 8005a56:	68f9      	ldr	r1, [r7, #12]
 8005a58:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005a5c:	4313      	orrs	r3, r2
 8005a5e:	600b      	str	r3, [r1, #0]
  return HAL_OK;
 8005a60:	2300      	movs	r3, #0
}
 8005a62:	4618      	mov	r0, r3
 8005a64:	3714      	adds	r7, #20
 8005a66:	46bd      	mov	sp, r7
 8005a68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a6c:	4770      	bx	lr

08005a6e <USB_GetDevSpeed>:
  *          This parameter can be one of these values:
  *            @arg USBD_HS_SPEED: High speed mode
  *            @arg USBD_FS_SPEED: Full speed mode
  */
uint8_t USB_GetDevSpeed(const USB_OTG_GlobalTypeDef *USBx)
{
 8005a6e:	b480      	push	{r7}
 8005a70:	b087      	sub	sp, #28
 8005a72:	af00      	add	r7, sp, #0
 8005a74:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005a76:	687b      	ldr	r3, [r7, #4]
 8005a78:	613b      	str	r3, [r7, #16]
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 8005a7a:	693b      	ldr	r3, [r7, #16]
 8005a7c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005a80:	689b      	ldr	r3, [r3, #8]
 8005a82:	f003 0306 	and.w	r3, r3, #6
 8005a86:	60fb      	str	r3, [r7, #12]

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8005a88:	68fb      	ldr	r3, [r7, #12]
 8005a8a:	2b00      	cmp	r3, #0
 8005a8c:	d102      	bne.n	8005a94 <USB_GetDevSpeed+0x26>
  {
    speed = USBD_HS_SPEED;
 8005a8e:	2300      	movs	r3, #0
 8005a90:	75fb      	strb	r3, [r7, #23]
 8005a92:	e00a      	b.n	8005aaa <USB_GetDevSpeed+0x3c>
  }
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 8005a94:	68fb      	ldr	r3, [r7, #12]
 8005a96:	2b02      	cmp	r3, #2
 8005a98:	d002      	beq.n	8005aa0 <USB_GetDevSpeed+0x32>
 8005a9a:	68fb      	ldr	r3, [r7, #12]
 8005a9c:	2b06      	cmp	r3, #6
 8005a9e:	d102      	bne.n	8005aa6 <USB_GetDevSpeed+0x38>
           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USBD_FS_SPEED;
 8005aa0:	2302      	movs	r3, #2
 8005aa2:	75fb      	strb	r3, [r7, #23]
 8005aa4:	e001      	b.n	8005aaa <USB_GetDevSpeed+0x3c>
  }
  else
  {
    speed = 0xFU;
 8005aa6:	230f      	movs	r3, #15
 8005aa8:	75fb      	strb	r3, [r7, #23]
  }

  return speed;
 8005aaa:	7dfb      	ldrb	r3, [r7, #23]
}
 8005aac:	4618      	mov	r0, r3
 8005aae:	371c      	adds	r7, #28
 8005ab0:	46bd      	mov	sp, r7
 8005ab2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ab6:	4770      	bx	lr

08005ab8 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8005ab8:	b480      	push	{r7}
 8005aba:	b085      	sub	sp, #20
 8005abc:	af00      	add	r7, sp, #0
 8005abe:	6078      	str	r0, [r7, #4]
 8005ac0:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005ac2:	687b      	ldr	r3, [r7, #4]
 8005ac4:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8005ac6:	683b      	ldr	r3, [r7, #0]
 8005ac8:	781b      	ldrb	r3, [r3, #0]
 8005aca:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8005acc:	683b      	ldr	r3, [r7, #0]
 8005ace:	785b      	ldrb	r3, [r3, #1]
 8005ad0:	2b01      	cmp	r3, #1
 8005ad2:	d13a      	bne.n	8005b4a <USB_ActivateEndpoint+0x92>
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8005ad4:	68fb      	ldr	r3, [r7, #12]
 8005ad6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005ada:	69da      	ldr	r2, [r3, #28]
 8005adc:	683b      	ldr	r3, [r7, #0]
 8005ade:	781b      	ldrb	r3, [r3, #0]
 8005ae0:	f003 030f 	and.w	r3, r3, #15
 8005ae4:	2101      	movs	r1, #1
 8005ae6:	fa01 f303 	lsl.w	r3, r1, r3
 8005aea:	b29b      	uxth	r3, r3
 8005aec:	68f9      	ldr	r1, [r7, #12]
 8005aee:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005af2:	4313      	orrs	r3, r2
 8005af4:	61cb      	str	r3, [r1, #28]

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8005af6:	68bb      	ldr	r3, [r7, #8]
 8005af8:	015a      	lsls	r2, r3, #5
 8005afa:	68fb      	ldr	r3, [r7, #12]
 8005afc:	4413      	add	r3, r2
 8005afe:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005b02:	681b      	ldr	r3, [r3, #0]
 8005b04:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8005b08:	2b00      	cmp	r3, #0
 8005b0a:	d155      	bne.n	8005bb8 <USB_ActivateEndpoint+0x100>
    {
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8005b0c:	68bb      	ldr	r3, [r7, #8]
 8005b0e:	015a      	lsls	r2, r3, #5
 8005b10:	68fb      	ldr	r3, [r7, #12]
 8005b12:	4413      	add	r3, r2
 8005b14:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005b18:	681a      	ldr	r2, [r3, #0]
 8005b1a:	683b      	ldr	r3, [r7, #0]
 8005b1c:	689b      	ldr	r3, [r3, #8]
 8005b1e:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 8005b22:	683b      	ldr	r3, [r7, #0]
 8005b24:	791b      	ldrb	r3, [r3, #4]
 8005b26:	049b      	lsls	r3, r3, #18
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8005b28:	4319      	orrs	r1, r3
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 8005b2a:	68bb      	ldr	r3, [r7, #8]
 8005b2c:	059b      	lsls	r3, r3, #22
 8005b2e:	430b      	orrs	r3, r1
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8005b30:	4313      	orrs	r3, r2
 8005b32:	68ba      	ldr	r2, [r7, #8]
 8005b34:	0151      	lsls	r1, r2, #5
 8005b36:	68fa      	ldr	r2, [r7, #12]
 8005b38:	440a      	add	r2, r1
 8005b3a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005b3e:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8005b42:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8005b46:	6013      	str	r3, [r2, #0]
 8005b48:	e036      	b.n	8005bb8 <USB_ActivateEndpoint+0x100>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 8005b4a:	68fb      	ldr	r3, [r7, #12]
 8005b4c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005b50:	69da      	ldr	r2, [r3, #28]
 8005b52:	683b      	ldr	r3, [r7, #0]
 8005b54:	781b      	ldrb	r3, [r3, #0]
 8005b56:	f003 030f 	and.w	r3, r3, #15
 8005b5a:	2101      	movs	r1, #1
 8005b5c:	fa01 f303 	lsl.w	r3, r1, r3
 8005b60:	041b      	lsls	r3, r3, #16
 8005b62:	68f9      	ldr	r1, [r7, #12]
 8005b64:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005b68:	4313      	orrs	r3, r2
 8005b6a:	61cb      	str	r3, [r1, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8005b6c:	68bb      	ldr	r3, [r7, #8]
 8005b6e:	015a      	lsls	r2, r3, #5
 8005b70:	68fb      	ldr	r3, [r7, #12]
 8005b72:	4413      	add	r3, r2
 8005b74:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005b78:	681b      	ldr	r3, [r3, #0]
 8005b7a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8005b7e:	2b00      	cmp	r3, #0
 8005b80:	d11a      	bne.n	8005bb8 <USB_ActivateEndpoint+0x100>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8005b82:	68bb      	ldr	r3, [r7, #8]
 8005b84:	015a      	lsls	r2, r3, #5
 8005b86:	68fb      	ldr	r3, [r7, #12]
 8005b88:	4413      	add	r3, r2
 8005b8a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005b8e:	681a      	ldr	r2, [r3, #0]
 8005b90:	683b      	ldr	r3, [r7, #0]
 8005b92:	689b      	ldr	r3, [r3, #8]
 8005b94:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 8005b98:	683b      	ldr	r3, [r7, #0]
 8005b9a:	791b      	ldrb	r3, [r3, #4]
 8005b9c:	049b      	lsls	r3, r3, #18
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8005b9e:	430b      	orrs	r3, r1
 8005ba0:	4313      	orrs	r3, r2
 8005ba2:	68ba      	ldr	r2, [r7, #8]
 8005ba4:	0151      	lsls	r1, r2, #5
 8005ba6:	68fa      	ldr	r2, [r7, #12]
 8005ba8:	440a      	add	r2, r1
 8005baa:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005bae:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8005bb2:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8005bb6:	6013      	str	r3, [r2, #0]
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
 8005bb8:	2300      	movs	r3, #0
}
 8005bba:	4618      	mov	r0, r3
 8005bbc:	3714      	adds	r7, #20
 8005bbe:	46bd      	mov	sp, r7
 8005bc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005bc4:	4770      	bx	lr
	...

08005bc8 <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8005bc8:	b480      	push	{r7}
 8005bca:	b085      	sub	sp, #20
 8005bcc:	af00      	add	r7, sp, #0
 8005bce:	6078      	str	r0, [r7, #4]
 8005bd0:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005bd2:	687b      	ldr	r3, [r7, #4]
 8005bd4:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8005bd6:	683b      	ldr	r3, [r7, #0]
 8005bd8:	781b      	ldrb	r3, [r3, #0]
 8005bda:	60bb      	str	r3, [r7, #8]

  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 8005bdc:	683b      	ldr	r3, [r7, #0]
 8005bde:	785b      	ldrb	r3, [r3, #1]
 8005be0:	2b01      	cmp	r3, #1
 8005be2:	d161      	bne.n	8005ca8 <USB_DeactivateEndpoint+0xe0>
  {
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8005be4:	68bb      	ldr	r3, [r7, #8]
 8005be6:	015a      	lsls	r2, r3, #5
 8005be8:	68fb      	ldr	r3, [r7, #12]
 8005bea:	4413      	add	r3, r2
 8005bec:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005bf0:	681b      	ldr	r3, [r3, #0]
 8005bf2:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8005bf6:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8005bfa:	d11f      	bne.n	8005c3c <USB_DeactivateEndpoint+0x74>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 8005bfc:	68bb      	ldr	r3, [r7, #8]
 8005bfe:	015a      	lsls	r2, r3, #5
 8005c00:	68fb      	ldr	r3, [r7, #12]
 8005c02:	4413      	add	r3, r2
 8005c04:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005c08:	681b      	ldr	r3, [r3, #0]
 8005c0a:	68ba      	ldr	r2, [r7, #8]
 8005c0c:	0151      	lsls	r1, r2, #5
 8005c0e:	68fa      	ldr	r2, [r7, #12]
 8005c10:	440a      	add	r2, r1
 8005c12:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005c16:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8005c1a:	6013      	str	r3, [r2, #0]
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 8005c1c:	68bb      	ldr	r3, [r7, #8]
 8005c1e:	015a      	lsls	r2, r3, #5
 8005c20:	68fb      	ldr	r3, [r7, #12]
 8005c22:	4413      	add	r3, r2
 8005c24:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005c28:	681b      	ldr	r3, [r3, #0]
 8005c2a:	68ba      	ldr	r2, [r7, #8]
 8005c2c:	0151      	lsls	r1, r2, #5
 8005c2e:	68fa      	ldr	r2, [r7, #12]
 8005c30:	440a      	add	r2, r1
 8005c32:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005c36:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8005c3a:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8005c3c:	68fb      	ldr	r3, [r7, #12]
 8005c3e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005c42:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005c44:	683b      	ldr	r3, [r7, #0]
 8005c46:	781b      	ldrb	r3, [r3, #0]
 8005c48:	f003 030f 	and.w	r3, r3, #15
 8005c4c:	2101      	movs	r1, #1
 8005c4e:	fa01 f303 	lsl.w	r3, r1, r3
 8005c52:	b29b      	uxth	r3, r3
 8005c54:	43db      	mvns	r3, r3
 8005c56:	68f9      	ldr	r1, [r7, #12]
 8005c58:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005c5c:	4013      	ands	r3, r2
 8005c5e:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8005c60:	68fb      	ldr	r3, [r7, #12]
 8005c62:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005c66:	69da      	ldr	r2, [r3, #28]
 8005c68:	683b      	ldr	r3, [r7, #0]
 8005c6a:	781b      	ldrb	r3, [r3, #0]
 8005c6c:	f003 030f 	and.w	r3, r3, #15
 8005c70:	2101      	movs	r1, #1
 8005c72:	fa01 f303 	lsl.w	r3, r1, r3
 8005c76:	b29b      	uxth	r3, r3
 8005c78:	43db      	mvns	r3, r3
 8005c7a:	68f9      	ldr	r1, [r7, #12]
 8005c7c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005c80:	4013      	ands	r3, r2
 8005c82:	61cb      	str	r3, [r1, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8005c84:	68bb      	ldr	r3, [r7, #8]
 8005c86:	015a      	lsls	r2, r3, #5
 8005c88:	68fb      	ldr	r3, [r7, #12]
 8005c8a:	4413      	add	r3, r2
 8005c8c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005c90:	681a      	ldr	r2, [r3, #0]
 8005c92:	68bb      	ldr	r3, [r7, #8]
 8005c94:	0159      	lsls	r1, r3, #5
 8005c96:	68fb      	ldr	r3, [r7, #12]
 8005c98:	440b      	add	r3, r1
 8005c9a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005c9e:	4619      	mov	r1, r3
 8005ca0:	4b35      	ldr	r3, [pc, #212]	@ (8005d78 <USB_DeactivateEndpoint+0x1b0>)
 8005ca2:	4013      	ands	r3, r2
 8005ca4:	600b      	str	r3, [r1, #0]
 8005ca6:	e060      	b.n	8005d6a <USB_DeactivateEndpoint+0x1a2>
                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                   USB_OTG_DIEPCTL_EPTYP);
  }
  else
  {
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8005ca8:	68bb      	ldr	r3, [r7, #8]
 8005caa:	015a      	lsls	r2, r3, #5
 8005cac:	68fb      	ldr	r3, [r7, #12]
 8005cae:	4413      	add	r3, r2
 8005cb0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005cb4:	681b      	ldr	r3, [r3, #0]
 8005cb6:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8005cba:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8005cbe:	d11f      	bne.n	8005d00 <USB_DeactivateEndpoint+0x138>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8005cc0:	68bb      	ldr	r3, [r7, #8]
 8005cc2:	015a      	lsls	r2, r3, #5
 8005cc4:	68fb      	ldr	r3, [r7, #12]
 8005cc6:	4413      	add	r3, r2
 8005cc8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005ccc:	681b      	ldr	r3, [r3, #0]
 8005cce:	68ba      	ldr	r2, [r7, #8]
 8005cd0:	0151      	lsls	r1, r2, #5
 8005cd2:	68fa      	ldr	r2, [r7, #12]
 8005cd4:	440a      	add	r2, r1
 8005cd6:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005cda:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8005cde:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 8005ce0:	68bb      	ldr	r3, [r7, #8]
 8005ce2:	015a      	lsls	r2, r3, #5
 8005ce4:	68fb      	ldr	r3, [r7, #12]
 8005ce6:	4413      	add	r3, r2
 8005ce8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005cec:	681b      	ldr	r3, [r3, #0]
 8005cee:	68ba      	ldr	r2, [r7, #8]
 8005cf0:	0151      	lsls	r1, r2, #5
 8005cf2:	68fa      	ldr	r2, [r7, #12]
 8005cf4:	440a      	add	r2, r1
 8005cf6:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005cfa:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8005cfe:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8005d00:	68fb      	ldr	r3, [r7, #12]
 8005d02:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005d06:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005d08:	683b      	ldr	r3, [r7, #0]
 8005d0a:	781b      	ldrb	r3, [r3, #0]
 8005d0c:	f003 030f 	and.w	r3, r3, #15
 8005d10:	2101      	movs	r1, #1
 8005d12:	fa01 f303 	lsl.w	r3, r1, r3
 8005d16:	041b      	lsls	r3, r3, #16
 8005d18:	43db      	mvns	r3, r3
 8005d1a:	68f9      	ldr	r1, [r7, #12]
 8005d1c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005d20:	4013      	ands	r3, r2
 8005d22:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8005d24:	68fb      	ldr	r3, [r7, #12]
 8005d26:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005d2a:	69da      	ldr	r2, [r3, #28]
 8005d2c:	683b      	ldr	r3, [r7, #0]
 8005d2e:	781b      	ldrb	r3, [r3, #0]
 8005d30:	f003 030f 	and.w	r3, r3, #15
 8005d34:	2101      	movs	r1, #1
 8005d36:	fa01 f303 	lsl.w	r3, r1, r3
 8005d3a:	041b      	lsls	r3, r3, #16
 8005d3c:	43db      	mvns	r3, r3
 8005d3e:	68f9      	ldr	r1, [r7, #12]
 8005d40:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005d44:	4013      	ands	r3, r2
 8005d46:	61cb      	str	r3, [r1, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8005d48:	68bb      	ldr	r3, [r7, #8]
 8005d4a:	015a      	lsls	r2, r3, #5
 8005d4c:	68fb      	ldr	r3, [r7, #12]
 8005d4e:	4413      	add	r3, r2
 8005d50:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005d54:	681a      	ldr	r2, [r3, #0]
 8005d56:	68bb      	ldr	r3, [r7, #8]
 8005d58:	0159      	lsls	r1, r3, #5
 8005d5a:	68fb      	ldr	r3, [r7, #12]
 8005d5c:	440b      	add	r3, r1
 8005d5e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005d62:	4619      	mov	r1, r3
 8005d64:	4b05      	ldr	r3, [pc, #20]	@ (8005d7c <USB_DeactivateEndpoint+0x1b4>)
 8005d66:	4013      	ands	r3, r2
 8005d68:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DOEPCTL_MPSIZ |
                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_EPTYP);
  }

  return HAL_OK;
 8005d6a:	2300      	movs	r3, #0
}
 8005d6c:	4618      	mov	r0, r3
 8005d6e:	3714      	adds	r7, #20
 8005d70:	46bd      	mov	sp, r7
 8005d72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d76:	4770      	bx	lr
 8005d78:	ec337800 	.word	0xec337800
 8005d7c:	eff37800 	.word	0xeff37800

08005d80 <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8005d80:	b580      	push	{r7, lr}
 8005d82:	b08a      	sub	sp, #40	@ 0x28
 8005d84:	af02      	add	r7, sp, #8
 8005d86:	60f8      	str	r0, [r7, #12]
 8005d88:	60b9      	str	r1, [r7, #8]
 8005d8a:	4613      	mov	r3, r2
 8005d8c:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005d8e:	68fb      	ldr	r3, [r7, #12]
 8005d90:	61fb      	str	r3, [r7, #28]
  uint32_t epnum = (uint32_t)ep->num;
 8005d92:	68bb      	ldr	r3, [r7, #8]
 8005d94:	781b      	ldrb	r3, [r3, #0]
 8005d96:	61bb      	str	r3, [r7, #24]
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
 8005d98:	68bb      	ldr	r3, [r7, #8]
 8005d9a:	785b      	ldrb	r3, [r3, #1]
 8005d9c:	2b01      	cmp	r3, #1
 8005d9e:	f040 817f 	bne.w	80060a0 <USB_EPStartXfer+0x320>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8005da2:	68bb      	ldr	r3, [r7, #8]
 8005da4:	691b      	ldr	r3, [r3, #16]
 8005da6:	2b00      	cmp	r3, #0
 8005da8:	d132      	bne.n	8005e10 <USB_EPStartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005daa:	69bb      	ldr	r3, [r7, #24]
 8005dac:	015a      	lsls	r2, r3, #5
 8005dae:	69fb      	ldr	r3, [r7, #28]
 8005db0:	4413      	add	r3, r2
 8005db2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005db6:	691b      	ldr	r3, [r3, #16]
 8005db8:	69ba      	ldr	r2, [r7, #24]
 8005dba:	0151      	lsls	r1, r2, #5
 8005dbc:	69fa      	ldr	r2, [r7, #28]
 8005dbe:	440a      	add	r2, r1
 8005dc0:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005dc4:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 8005dc8:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 8005dcc:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005dce:	69bb      	ldr	r3, [r7, #24]
 8005dd0:	015a      	lsls	r2, r3, #5
 8005dd2:	69fb      	ldr	r3, [r7, #28]
 8005dd4:	4413      	add	r3, r2
 8005dd6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005dda:	691b      	ldr	r3, [r3, #16]
 8005ddc:	69ba      	ldr	r2, [r7, #24]
 8005dde:	0151      	lsls	r1, r2, #5
 8005de0:	69fa      	ldr	r2, [r7, #28]
 8005de2:	440a      	add	r2, r1
 8005de4:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005de8:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005dec:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005dee:	69bb      	ldr	r3, [r7, #24]
 8005df0:	015a      	lsls	r2, r3, #5
 8005df2:	69fb      	ldr	r3, [r7, #28]
 8005df4:	4413      	add	r3, r2
 8005df6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005dfa:	691b      	ldr	r3, [r3, #16]
 8005dfc:	69ba      	ldr	r2, [r7, #24]
 8005dfe:	0151      	lsls	r1, r2, #5
 8005e00:	69fa      	ldr	r2, [r7, #28]
 8005e02:	440a      	add	r2, r1
 8005e04:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e08:	0cdb      	lsrs	r3, r3, #19
 8005e0a:	04db      	lsls	r3, r3, #19
 8005e0c:	6113      	str	r3, [r2, #16]
 8005e0e:	e097      	b.n	8005f40 <USB_EPStartXfer+0x1c0>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005e10:	69bb      	ldr	r3, [r7, #24]
 8005e12:	015a      	lsls	r2, r3, #5
 8005e14:	69fb      	ldr	r3, [r7, #28]
 8005e16:	4413      	add	r3, r2
 8005e18:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e1c:	691b      	ldr	r3, [r3, #16]
 8005e1e:	69ba      	ldr	r2, [r7, #24]
 8005e20:	0151      	lsls	r1, r2, #5
 8005e22:	69fa      	ldr	r2, [r7, #28]
 8005e24:	440a      	add	r2, r1
 8005e26:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e2a:	0cdb      	lsrs	r3, r3, #19
 8005e2c:	04db      	lsls	r3, r3, #19
 8005e2e:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005e30:	69bb      	ldr	r3, [r7, #24]
 8005e32:	015a      	lsls	r2, r3, #5
 8005e34:	69fb      	ldr	r3, [r7, #28]
 8005e36:	4413      	add	r3, r2
 8005e38:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e3c:	691b      	ldr	r3, [r3, #16]
 8005e3e:	69ba      	ldr	r2, [r7, #24]
 8005e40:	0151      	lsls	r1, r2, #5
 8005e42:	69fa      	ldr	r2, [r7, #28]
 8005e44:	440a      	add	r2, r1
 8005e46:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e4a:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 8005e4e:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 8005e52:	6113      	str	r3, [r2, #16]

      if (epnum == 0U)
 8005e54:	69bb      	ldr	r3, [r7, #24]
 8005e56:	2b00      	cmp	r3, #0
 8005e58:	d11a      	bne.n	8005e90 <USB_EPStartXfer+0x110>
      {
        if (ep->xfer_len > ep->maxpacket)
 8005e5a:	68bb      	ldr	r3, [r7, #8]
 8005e5c:	691a      	ldr	r2, [r3, #16]
 8005e5e:	68bb      	ldr	r3, [r7, #8]
 8005e60:	689b      	ldr	r3, [r3, #8]
 8005e62:	429a      	cmp	r2, r3
 8005e64:	d903      	bls.n	8005e6e <USB_EPStartXfer+0xee>
        {
          ep->xfer_len = ep->maxpacket;
 8005e66:	68bb      	ldr	r3, [r7, #8]
 8005e68:	689a      	ldr	r2, [r3, #8]
 8005e6a:	68bb      	ldr	r3, [r7, #8]
 8005e6c:	611a      	str	r2, [r3, #16]
        }

        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005e6e:	69bb      	ldr	r3, [r7, #24]
 8005e70:	015a      	lsls	r2, r3, #5
 8005e72:	69fb      	ldr	r3, [r7, #28]
 8005e74:	4413      	add	r3, r2
 8005e76:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e7a:	691b      	ldr	r3, [r3, #16]
 8005e7c:	69ba      	ldr	r2, [r7, #24]
 8005e7e:	0151      	lsls	r1, r2, #5
 8005e80:	69fa      	ldr	r2, [r7, #28]
 8005e82:	440a      	add	r2, r1
 8005e84:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e88:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005e8c:	6113      	str	r3, [r2, #16]
 8005e8e:	e044      	b.n	8005f1a <USB_EPStartXfer+0x19a>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8005e90:	68bb      	ldr	r3, [r7, #8]
 8005e92:	691a      	ldr	r2, [r3, #16]
 8005e94:	68bb      	ldr	r3, [r7, #8]
 8005e96:	689b      	ldr	r3, [r3, #8]
 8005e98:	4413      	add	r3, r2
 8005e9a:	1e5a      	subs	r2, r3, #1
 8005e9c:	68bb      	ldr	r3, [r7, #8]
 8005e9e:	689b      	ldr	r3, [r3, #8]
 8005ea0:	fbb2 f3f3 	udiv	r3, r2, r3
 8005ea4:	82fb      	strh	r3, [r7, #22]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (pktcnt << 19));
 8005ea6:	69bb      	ldr	r3, [r7, #24]
 8005ea8:	015a      	lsls	r2, r3, #5
 8005eaa:	69fb      	ldr	r3, [r7, #28]
 8005eac:	4413      	add	r3, r2
 8005eae:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005eb2:	691a      	ldr	r2, [r3, #16]
 8005eb4:	8afb      	ldrh	r3, [r7, #22]
 8005eb6:	04d9      	lsls	r1, r3, #19
 8005eb8:	4ba4      	ldr	r3, [pc, #656]	@ (800614c <USB_EPStartXfer+0x3cc>)
 8005eba:	400b      	ands	r3, r1
 8005ebc:	69b9      	ldr	r1, [r7, #24]
 8005ebe:	0148      	lsls	r0, r1, #5
 8005ec0:	69f9      	ldr	r1, [r7, #28]
 8005ec2:	4401      	add	r1, r0
 8005ec4:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8005ec8:	4313      	orrs	r3, r2
 8005eca:	610b      	str	r3, [r1, #16]

        if (ep->type == EP_TYPE_ISOC)
 8005ecc:	68bb      	ldr	r3, [r7, #8]
 8005ece:	791b      	ldrb	r3, [r3, #4]
 8005ed0:	2b01      	cmp	r3, #1
 8005ed2:	d122      	bne.n	8005f1a <USB_EPStartXfer+0x19a>
        {
          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8005ed4:	69bb      	ldr	r3, [r7, #24]
 8005ed6:	015a      	lsls	r2, r3, #5
 8005ed8:	69fb      	ldr	r3, [r7, #28]
 8005eda:	4413      	add	r3, r2
 8005edc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005ee0:	691b      	ldr	r3, [r3, #16]
 8005ee2:	69ba      	ldr	r2, [r7, #24]
 8005ee4:	0151      	lsls	r1, r2, #5
 8005ee6:	69fa      	ldr	r2, [r7, #28]
 8005ee8:	440a      	add	r2, r1
 8005eea:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005eee:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005ef2:	6113      	str	r3, [r2, #16]
          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (pktcnt << 29));
 8005ef4:	69bb      	ldr	r3, [r7, #24]
 8005ef6:	015a      	lsls	r2, r3, #5
 8005ef8:	69fb      	ldr	r3, [r7, #28]
 8005efa:	4413      	add	r3, r2
 8005efc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005f00:	691a      	ldr	r2, [r3, #16]
 8005f02:	8afb      	ldrh	r3, [r7, #22]
 8005f04:	075b      	lsls	r3, r3, #29
 8005f06:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8005f0a:	69b9      	ldr	r1, [r7, #24]
 8005f0c:	0148      	lsls	r0, r1, #5
 8005f0e:	69f9      	ldr	r1, [r7, #28]
 8005f10:	4401      	add	r1, r0
 8005f12:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8005f16:	4313      	orrs	r3, r2
 8005f18:	610b      	str	r3, [r1, #16]
        }
      }

      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8005f1a:	69bb      	ldr	r3, [r7, #24]
 8005f1c:	015a      	lsls	r2, r3, #5
 8005f1e:	69fb      	ldr	r3, [r7, #28]
 8005f20:	4413      	add	r3, r2
 8005f22:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005f26:	691a      	ldr	r2, [r3, #16]
 8005f28:	68bb      	ldr	r3, [r7, #8]
 8005f2a:	691b      	ldr	r3, [r3, #16]
 8005f2c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8005f30:	69b9      	ldr	r1, [r7, #24]
 8005f32:	0148      	lsls	r0, r1, #5
 8005f34:	69f9      	ldr	r1, [r7, #28]
 8005f36:	4401      	add	r1, r0
 8005f38:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8005f3c:	4313      	orrs	r3, r2
 8005f3e:	610b      	str	r3, [r1, #16]
    }

    if (dma == 1U)
 8005f40:	79fb      	ldrb	r3, [r7, #7]
 8005f42:	2b01      	cmp	r3, #1
 8005f44:	d14b      	bne.n	8005fde <USB_EPStartXfer+0x25e>
    {
      if ((uint32_t)ep->dma_addr != 0U)
 8005f46:	68bb      	ldr	r3, [r7, #8]
 8005f48:	69db      	ldr	r3, [r3, #28]
 8005f4a:	2b00      	cmp	r3, #0
 8005f4c:	d009      	beq.n	8005f62 <USB_EPStartXfer+0x1e2>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8005f4e:	69bb      	ldr	r3, [r7, #24]
 8005f50:	015a      	lsls	r2, r3, #5
 8005f52:	69fb      	ldr	r3, [r7, #28]
 8005f54:	4413      	add	r3, r2
 8005f56:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005f5a:	461a      	mov	r2, r3
 8005f5c:	68bb      	ldr	r3, [r7, #8]
 8005f5e:	69db      	ldr	r3, [r3, #28]
 8005f60:	6153      	str	r3, [r2, #20]
      }

      if (ep->type == EP_TYPE_ISOC)
 8005f62:	68bb      	ldr	r3, [r7, #8]
 8005f64:	791b      	ldrb	r3, [r3, #4]
 8005f66:	2b01      	cmp	r3, #1
 8005f68:	d128      	bne.n	8005fbc <USB_EPStartXfer+0x23c>
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8005f6a:	69fb      	ldr	r3, [r7, #28]
 8005f6c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005f70:	689b      	ldr	r3, [r3, #8]
 8005f72:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8005f76:	2b00      	cmp	r3, #0
 8005f78:	d110      	bne.n	8005f9c <USB_EPStartXfer+0x21c>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8005f7a:	69bb      	ldr	r3, [r7, #24]
 8005f7c:	015a      	lsls	r2, r3, #5
 8005f7e:	69fb      	ldr	r3, [r7, #28]
 8005f80:	4413      	add	r3, r2
 8005f82:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005f86:	681b      	ldr	r3, [r3, #0]
 8005f88:	69ba      	ldr	r2, [r7, #24]
 8005f8a:	0151      	lsls	r1, r2, #5
 8005f8c:	69fa      	ldr	r2, [r7, #28]
 8005f8e:	440a      	add	r2, r1
 8005f90:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005f94:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8005f98:	6013      	str	r3, [r2, #0]
 8005f9a:	e00f      	b.n	8005fbc <USB_EPStartXfer+0x23c>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8005f9c:	69bb      	ldr	r3, [r7, #24]
 8005f9e:	015a      	lsls	r2, r3, #5
 8005fa0:	69fb      	ldr	r3, [r7, #28]
 8005fa2:	4413      	add	r3, r2
 8005fa4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005fa8:	681b      	ldr	r3, [r3, #0]
 8005faa:	69ba      	ldr	r2, [r7, #24]
 8005fac:	0151      	lsls	r1, r2, #5
 8005fae:	69fa      	ldr	r2, [r7, #28]
 8005fb0:	440a      	add	r2, r1
 8005fb2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005fb6:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8005fba:	6013      	str	r3, [r2, #0]
        }
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8005fbc:	69bb      	ldr	r3, [r7, #24]
 8005fbe:	015a      	lsls	r2, r3, #5
 8005fc0:	69fb      	ldr	r3, [r7, #28]
 8005fc2:	4413      	add	r3, r2
 8005fc4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005fc8:	681b      	ldr	r3, [r3, #0]
 8005fca:	69ba      	ldr	r2, [r7, #24]
 8005fcc:	0151      	lsls	r1, r2, #5
 8005fce:	69fa      	ldr	r2, [r7, #28]
 8005fd0:	440a      	add	r2, r1
 8005fd2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005fd6:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 8005fda:	6013      	str	r3, [r2, #0]
 8005fdc:	e166      	b.n	80062ac <USB_EPStartXfer+0x52c>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8005fde:	69bb      	ldr	r3, [r7, #24]
 8005fe0:	015a      	lsls	r2, r3, #5
 8005fe2:	69fb      	ldr	r3, [r7, #28]
 8005fe4:	4413      	add	r3, r2
 8005fe6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005fea:	681b      	ldr	r3, [r3, #0]
 8005fec:	69ba      	ldr	r2, [r7, #24]
 8005fee:	0151      	lsls	r1, r2, #5
 8005ff0:	69fa      	ldr	r2, [r7, #28]
 8005ff2:	440a      	add	r2, r1
 8005ff4:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005ff8:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 8005ffc:	6013      	str	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 8005ffe:	68bb      	ldr	r3, [r7, #8]
 8006000:	791b      	ldrb	r3, [r3, #4]
 8006002:	2b01      	cmp	r3, #1
 8006004:	d015      	beq.n	8006032 <USB_EPStartXfer+0x2b2>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 8006006:	68bb      	ldr	r3, [r7, #8]
 8006008:	691b      	ldr	r3, [r3, #16]
 800600a:	2b00      	cmp	r3, #0
 800600c:	f000 814e 	beq.w	80062ac <USB_EPStartXfer+0x52c>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8006010:	69fb      	ldr	r3, [r7, #28]
 8006012:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006016:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8006018:	68bb      	ldr	r3, [r7, #8]
 800601a:	781b      	ldrb	r3, [r3, #0]
 800601c:	f003 030f 	and.w	r3, r3, #15
 8006020:	2101      	movs	r1, #1
 8006022:	fa01 f303 	lsl.w	r3, r1, r3
 8006026:	69f9      	ldr	r1, [r7, #28]
 8006028:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800602c:	4313      	orrs	r3, r2
 800602e:	634b      	str	r3, [r1, #52]	@ 0x34
 8006030:	e13c      	b.n	80062ac <USB_EPStartXfer+0x52c>
        }
      }
      else
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8006032:	69fb      	ldr	r3, [r7, #28]
 8006034:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006038:	689b      	ldr	r3, [r3, #8]
 800603a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800603e:	2b00      	cmp	r3, #0
 8006040:	d110      	bne.n	8006064 <USB_EPStartXfer+0x2e4>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8006042:	69bb      	ldr	r3, [r7, #24]
 8006044:	015a      	lsls	r2, r3, #5
 8006046:	69fb      	ldr	r3, [r7, #28]
 8006048:	4413      	add	r3, r2
 800604a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800604e:	681b      	ldr	r3, [r3, #0]
 8006050:	69ba      	ldr	r2, [r7, #24]
 8006052:	0151      	lsls	r1, r2, #5
 8006054:	69fa      	ldr	r2, [r7, #28]
 8006056:	440a      	add	r2, r1
 8006058:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800605c:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8006060:	6013      	str	r3, [r2, #0]
 8006062:	e00f      	b.n	8006084 <USB_EPStartXfer+0x304>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8006064:	69bb      	ldr	r3, [r7, #24]
 8006066:	015a      	lsls	r2, r3, #5
 8006068:	69fb      	ldr	r3, [r7, #28]
 800606a:	4413      	add	r3, r2
 800606c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006070:	681b      	ldr	r3, [r3, #0]
 8006072:	69ba      	ldr	r2, [r7, #24]
 8006074:	0151      	lsls	r1, r2, #5
 8006076:	69fa      	ldr	r2, [r7, #28]
 8006078:	440a      	add	r2, r1
 800607a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800607e:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8006082:	6013      	str	r3, [r2, #0]
        }

        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 8006084:	68bb      	ldr	r3, [r7, #8]
 8006086:	68d9      	ldr	r1, [r3, #12]
 8006088:	68bb      	ldr	r3, [r7, #8]
 800608a:	781a      	ldrb	r2, [r3, #0]
 800608c:	68bb      	ldr	r3, [r7, #8]
 800608e:	691b      	ldr	r3, [r3, #16]
 8006090:	b298      	uxth	r0, r3
 8006092:	79fb      	ldrb	r3, [r7, #7]
 8006094:	9300      	str	r3, [sp, #0]
 8006096:	4603      	mov	r3, r0
 8006098:	68f8      	ldr	r0, [r7, #12]
 800609a:	f000 f9b9 	bl	8006410 <USB_WritePacket>
 800609e:	e105      	b.n	80062ac <USB_EPStartXfer+0x52c>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 80060a0:	69bb      	ldr	r3, [r7, #24]
 80060a2:	015a      	lsls	r2, r3, #5
 80060a4:	69fb      	ldr	r3, [r7, #28]
 80060a6:	4413      	add	r3, r2
 80060a8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80060ac:	691b      	ldr	r3, [r3, #16]
 80060ae:	69ba      	ldr	r2, [r7, #24]
 80060b0:	0151      	lsls	r1, r2, #5
 80060b2:	69fa      	ldr	r2, [r7, #28]
 80060b4:	440a      	add	r2, r1
 80060b6:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80060ba:	0cdb      	lsrs	r3, r3, #19
 80060bc:	04db      	lsls	r3, r3, #19
 80060be:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 80060c0:	69bb      	ldr	r3, [r7, #24]
 80060c2:	015a      	lsls	r2, r3, #5
 80060c4:	69fb      	ldr	r3, [r7, #28]
 80060c6:	4413      	add	r3, r2
 80060c8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80060cc:	691b      	ldr	r3, [r3, #16]
 80060ce:	69ba      	ldr	r2, [r7, #24]
 80060d0:	0151      	lsls	r1, r2, #5
 80060d2:	69fa      	ldr	r2, [r7, #28]
 80060d4:	440a      	add	r2, r1
 80060d6:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80060da:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 80060de:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 80060e2:	6113      	str	r3, [r2, #16]

    if (epnum == 0U)
 80060e4:	69bb      	ldr	r3, [r7, #24]
 80060e6:	2b00      	cmp	r3, #0
 80060e8:	d132      	bne.n	8006150 <USB_EPStartXfer+0x3d0>
    {
      if (ep->xfer_len > 0U)
 80060ea:	68bb      	ldr	r3, [r7, #8]
 80060ec:	691b      	ldr	r3, [r3, #16]
 80060ee:	2b00      	cmp	r3, #0
 80060f0:	d003      	beq.n	80060fa <USB_EPStartXfer+0x37a>
      {
        ep->xfer_len = ep->maxpacket;
 80060f2:	68bb      	ldr	r3, [r7, #8]
 80060f4:	689a      	ldr	r2, [r3, #8]
 80060f6:	68bb      	ldr	r3, [r7, #8]
 80060f8:	611a      	str	r2, [r3, #16]
      }

      /* Store transfer size, for EP0 this is equal to endpoint max packet size */
      ep->xfer_size = ep->maxpacket;
 80060fa:	68bb      	ldr	r3, [r7, #8]
 80060fc:	689a      	ldr	r2, [r3, #8]
 80060fe:	68bb      	ldr	r3, [r7, #8]
 8006100:	621a      	str	r2, [r3, #32]

      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 8006102:	69bb      	ldr	r3, [r7, #24]
 8006104:	015a      	lsls	r2, r3, #5
 8006106:	69fb      	ldr	r3, [r7, #28]
 8006108:	4413      	add	r3, r2
 800610a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800610e:	691a      	ldr	r2, [r3, #16]
 8006110:	68bb      	ldr	r3, [r7, #8]
 8006112:	6a1b      	ldr	r3, [r3, #32]
 8006114:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8006118:	69b9      	ldr	r1, [r7, #24]
 800611a:	0148      	lsls	r0, r1, #5
 800611c:	69f9      	ldr	r1, [r7, #28]
 800611e:	4401      	add	r1, r0
 8006120:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 8006124:	4313      	orrs	r3, r2
 8006126:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8006128:	69bb      	ldr	r3, [r7, #24]
 800612a:	015a      	lsls	r2, r3, #5
 800612c:	69fb      	ldr	r3, [r7, #28]
 800612e:	4413      	add	r3, r2
 8006130:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006134:	691b      	ldr	r3, [r3, #16]
 8006136:	69ba      	ldr	r2, [r7, #24]
 8006138:	0151      	lsls	r1, r2, #5
 800613a:	69fa      	ldr	r2, [r7, #28]
 800613c:	440a      	add	r2, r1
 800613e:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006142:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8006146:	6113      	str	r3, [r2, #16]
 8006148:	e062      	b.n	8006210 <USB_EPStartXfer+0x490>
 800614a:	bf00      	nop
 800614c:	1ff80000 	.word	0x1ff80000
    }
    else
    {
      if (ep->xfer_len == 0U)
 8006150:	68bb      	ldr	r3, [r7, #8]
 8006152:	691b      	ldr	r3, [r3, #16]
 8006154:	2b00      	cmp	r3, #0
 8006156:	d123      	bne.n	80061a0 <USB_EPStartXfer+0x420>
      {
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8006158:	69bb      	ldr	r3, [r7, #24]
 800615a:	015a      	lsls	r2, r3, #5
 800615c:	69fb      	ldr	r3, [r7, #28]
 800615e:	4413      	add	r3, r2
 8006160:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006164:	691a      	ldr	r2, [r3, #16]
 8006166:	68bb      	ldr	r3, [r7, #8]
 8006168:	689b      	ldr	r3, [r3, #8]
 800616a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800616e:	69b9      	ldr	r1, [r7, #24]
 8006170:	0148      	lsls	r0, r1, #5
 8006172:	69f9      	ldr	r1, [r7, #28]
 8006174:	4401      	add	r1, r0
 8006176:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 800617a:	4313      	orrs	r3, r2
 800617c:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800617e:	69bb      	ldr	r3, [r7, #24]
 8006180:	015a      	lsls	r2, r3, #5
 8006182:	69fb      	ldr	r3, [r7, #28]
 8006184:	4413      	add	r3, r2
 8006186:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800618a:	691b      	ldr	r3, [r3, #16]
 800618c:	69ba      	ldr	r2, [r7, #24]
 800618e:	0151      	lsls	r1, r2, #5
 8006190:	69fa      	ldr	r2, [r7, #28]
 8006192:	440a      	add	r2, r1
 8006194:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006198:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800619c:	6113      	str	r3, [r2, #16]
 800619e:	e037      	b.n	8006210 <USB_EPStartXfer+0x490>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 80061a0:	68bb      	ldr	r3, [r7, #8]
 80061a2:	691a      	ldr	r2, [r3, #16]
 80061a4:	68bb      	ldr	r3, [r7, #8]
 80061a6:	689b      	ldr	r3, [r3, #8]
 80061a8:	4413      	add	r3, r2
 80061aa:	1e5a      	subs	r2, r3, #1
 80061ac:	68bb      	ldr	r3, [r7, #8]
 80061ae:	689b      	ldr	r3, [r3, #8]
 80061b0:	fbb2 f3f3 	udiv	r3, r2, r3
 80061b4:	82fb      	strh	r3, [r7, #22]
        ep->xfer_size = ep->maxpacket * pktcnt;
 80061b6:	68bb      	ldr	r3, [r7, #8]
 80061b8:	689b      	ldr	r3, [r3, #8]
 80061ba:	8afa      	ldrh	r2, [r7, #22]
 80061bc:	fb03 f202 	mul.w	r2, r3, r2
 80061c0:	68bb      	ldr	r3, [r7, #8]
 80061c2:	621a      	str	r2, [r3, #32]

        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 80061c4:	69bb      	ldr	r3, [r7, #24]
 80061c6:	015a      	lsls	r2, r3, #5
 80061c8:	69fb      	ldr	r3, [r7, #28]
 80061ca:	4413      	add	r3, r2
 80061cc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80061d0:	691a      	ldr	r2, [r3, #16]
 80061d2:	8afb      	ldrh	r3, [r7, #22]
 80061d4:	04d9      	lsls	r1, r3, #19
 80061d6:	4b38      	ldr	r3, [pc, #224]	@ (80062b8 <USB_EPStartXfer+0x538>)
 80061d8:	400b      	ands	r3, r1
 80061da:	69b9      	ldr	r1, [r7, #24]
 80061dc:	0148      	lsls	r0, r1, #5
 80061de:	69f9      	ldr	r1, [r7, #28]
 80061e0:	4401      	add	r1, r0
 80061e2:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 80061e6:	4313      	orrs	r3, r2
 80061e8:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 80061ea:	69bb      	ldr	r3, [r7, #24]
 80061ec:	015a      	lsls	r2, r3, #5
 80061ee:	69fb      	ldr	r3, [r7, #28]
 80061f0:	4413      	add	r3, r2
 80061f2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80061f6:	691a      	ldr	r2, [r3, #16]
 80061f8:	68bb      	ldr	r3, [r7, #8]
 80061fa:	6a1b      	ldr	r3, [r3, #32]
 80061fc:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8006200:	69b9      	ldr	r1, [r7, #24]
 8006202:	0148      	lsls	r0, r1, #5
 8006204:	69f9      	ldr	r1, [r7, #28]
 8006206:	4401      	add	r1, r0
 8006208:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 800620c:	4313      	orrs	r3, r2
 800620e:	610b      	str	r3, [r1, #16]
      }
    }

    if (dma == 1U)
 8006210:	79fb      	ldrb	r3, [r7, #7]
 8006212:	2b01      	cmp	r3, #1
 8006214:	d10d      	bne.n	8006232 <USB_EPStartXfer+0x4b2>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
 8006216:	68bb      	ldr	r3, [r7, #8]
 8006218:	68db      	ldr	r3, [r3, #12]
 800621a:	2b00      	cmp	r3, #0
 800621c:	d009      	beq.n	8006232 <USB_EPStartXfer+0x4b2>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 800621e:	68bb      	ldr	r3, [r7, #8]
 8006220:	68d9      	ldr	r1, [r3, #12]
 8006222:	69bb      	ldr	r3, [r7, #24]
 8006224:	015a      	lsls	r2, r3, #5
 8006226:	69fb      	ldr	r3, [r7, #28]
 8006228:	4413      	add	r3, r2
 800622a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800622e:	460a      	mov	r2, r1
 8006230:	615a      	str	r2, [r3, #20]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 8006232:	68bb      	ldr	r3, [r7, #8]
 8006234:	791b      	ldrb	r3, [r3, #4]
 8006236:	2b01      	cmp	r3, #1
 8006238:	d128      	bne.n	800628c <USB_EPStartXfer+0x50c>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800623a:	69fb      	ldr	r3, [r7, #28]
 800623c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006240:	689b      	ldr	r3, [r3, #8]
 8006242:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8006246:	2b00      	cmp	r3, #0
 8006248:	d110      	bne.n	800626c <USB_EPStartXfer+0x4ec>
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 800624a:	69bb      	ldr	r3, [r7, #24]
 800624c:	015a      	lsls	r2, r3, #5
 800624e:	69fb      	ldr	r3, [r7, #28]
 8006250:	4413      	add	r3, r2
 8006252:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006256:	681b      	ldr	r3, [r3, #0]
 8006258:	69ba      	ldr	r2, [r7, #24]
 800625a:	0151      	lsls	r1, r2, #5
 800625c:	69fa      	ldr	r2, [r7, #28]
 800625e:	440a      	add	r2, r1
 8006260:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006264:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8006268:	6013      	str	r3, [r2, #0]
 800626a:	e00f      	b.n	800628c <USB_EPStartXfer+0x50c>
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 800626c:	69bb      	ldr	r3, [r7, #24]
 800626e:	015a      	lsls	r2, r3, #5
 8006270:	69fb      	ldr	r3, [r7, #28]
 8006272:	4413      	add	r3, r2
 8006274:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006278:	681b      	ldr	r3, [r3, #0]
 800627a:	69ba      	ldr	r2, [r7, #24]
 800627c:	0151      	lsls	r1, r2, #5
 800627e:	69fa      	ldr	r2, [r7, #28]
 8006280:	440a      	add	r2, r1
 8006282:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006286:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800628a:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800628c:	69bb      	ldr	r3, [r7, #24]
 800628e:	015a      	lsls	r2, r3, #5
 8006290:	69fb      	ldr	r3, [r7, #28]
 8006292:	4413      	add	r3, r2
 8006294:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006298:	681b      	ldr	r3, [r3, #0]
 800629a:	69ba      	ldr	r2, [r7, #24]
 800629c:	0151      	lsls	r1, r2, #5
 800629e:	69fa      	ldr	r2, [r7, #28]
 80062a0:	440a      	add	r2, r1
 80062a2:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80062a6:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 80062aa:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 80062ac:	2300      	movs	r3, #0
}
 80062ae:	4618      	mov	r0, r3
 80062b0:	3720      	adds	r7, #32
 80062b2:	46bd      	mov	sp, r7
 80062b4:	bd80      	pop	{r7, pc}
 80062b6:	bf00      	nop
 80062b8:	1ff80000 	.word	0x1ff80000

080062bc <USB_EPStopXfer>:
   * @param  USBx  usb device instance
   * @param  ep pointer to endpoint structure
   * @retval HAL status
   */
HAL_StatusTypeDef USB_EPStopXfer(const USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 80062bc:	b480      	push	{r7}
 80062be:	b087      	sub	sp, #28
 80062c0:	af00      	add	r7, sp, #0
 80062c2:	6078      	str	r0, [r7, #4]
 80062c4:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 80062c6:	2300      	movs	r3, #0
 80062c8:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 80062ca:	2300      	movs	r3, #0
 80062cc:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80062ce:	687b      	ldr	r3, [r7, #4]
 80062d0:	613b      	str	r3, [r7, #16]

  /* IN endpoint */
  if (ep->is_in == 1U)
 80062d2:	683b      	ldr	r3, [r7, #0]
 80062d4:	785b      	ldrb	r3, [r3, #1]
 80062d6:	2b01      	cmp	r3, #1
 80062d8:	d14a      	bne.n	8006370 <USB_EPStopXfer+0xb4>
  {
    /* EP enable, IN data in FIFO */
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 80062da:	683b      	ldr	r3, [r7, #0]
 80062dc:	781b      	ldrb	r3, [r3, #0]
 80062de:	015a      	lsls	r2, r3, #5
 80062e0:	693b      	ldr	r3, [r7, #16]
 80062e2:	4413      	add	r3, r2
 80062e4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80062e8:	681b      	ldr	r3, [r3, #0]
 80062ea:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80062ee:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80062f2:	f040 8086 	bne.w	8006402 <USB_EPStopXfer+0x146>
    {
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 80062f6:	683b      	ldr	r3, [r7, #0]
 80062f8:	781b      	ldrb	r3, [r3, #0]
 80062fa:	015a      	lsls	r2, r3, #5
 80062fc:	693b      	ldr	r3, [r7, #16]
 80062fe:	4413      	add	r3, r2
 8006300:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006304:	681b      	ldr	r3, [r3, #0]
 8006306:	683a      	ldr	r2, [r7, #0]
 8006308:	7812      	ldrb	r2, [r2, #0]
 800630a:	0151      	lsls	r1, r2, #5
 800630c:	693a      	ldr	r2, [r7, #16]
 800630e:	440a      	add	r2, r1
 8006310:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8006314:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8006318:	6013      	str	r3, [r2, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 800631a:	683b      	ldr	r3, [r7, #0]
 800631c:	781b      	ldrb	r3, [r3, #0]
 800631e:	015a      	lsls	r2, r3, #5
 8006320:	693b      	ldr	r3, [r7, #16]
 8006322:	4413      	add	r3, r2
 8006324:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006328:	681b      	ldr	r3, [r3, #0]
 800632a:	683a      	ldr	r2, [r7, #0]
 800632c:	7812      	ldrb	r2, [r2, #0]
 800632e:	0151      	lsls	r1, r2, #5
 8006330:	693a      	ldr	r2, [r7, #16]
 8006332:	440a      	add	r2, r1
 8006334:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8006338:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800633c:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 800633e:	68fb      	ldr	r3, [r7, #12]
 8006340:	3301      	adds	r3, #1
 8006342:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 8006344:	68fb      	ldr	r3, [r7, #12]
 8006346:	f242 7210 	movw	r2, #10000	@ 0x2710
 800634a:	4293      	cmp	r3, r2
 800634c:	d902      	bls.n	8006354 <USB_EPStopXfer+0x98>
        {
          ret = HAL_ERROR;
 800634e:	2301      	movs	r3, #1
 8006350:	75fb      	strb	r3, [r7, #23]
          break;
 8006352:	e056      	b.n	8006402 <USB_EPStopXfer+0x146>
        }
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 8006354:	683b      	ldr	r3, [r7, #0]
 8006356:	781b      	ldrb	r3, [r3, #0]
 8006358:	015a      	lsls	r2, r3, #5
 800635a:	693b      	ldr	r3, [r7, #16]
 800635c:	4413      	add	r3, r2
 800635e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006362:	681b      	ldr	r3, [r3, #0]
 8006364:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8006368:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800636c:	d0e7      	beq.n	800633e <USB_EPStopXfer+0x82>
 800636e:	e048      	b.n	8006402 <USB_EPStopXfer+0x146>
    }
  }
  else /* OUT endpoint */
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8006370:	683b      	ldr	r3, [r7, #0]
 8006372:	781b      	ldrb	r3, [r3, #0]
 8006374:	015a      	lsls	r2, r3, #5
 8006376:	693b      	ldr	r3, [r7, #16]
 8006378:	4413      	add	r3, r2
 800637a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800637e:	681b      	ldr	r3, [r3, #0]
 8006380:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8006384:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8006388:	d13b      	bne.n	8006402 <USB_EPStopXfer+0x146>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 800638a:	683b      	ldr	r3, [r7, #0]
 800638c:	781b      	ldrb	r3, [r3, #0]
 800638e:	015a      	lsls	r2, r3, #5
 8006390:	693b      	ldr	r3, [r7, #16]
 8006392:	4413      	add	r3, r2
 8006394:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006398:	681b      	ldr	r3, [r3, #0]
 800639a:	683a      	ldr	r2, [r7, #0]
 800639c:	7812      	ldrb	r2, [r2, #0]
 800639e:	0151      	lsls	r1, r2, #5
 80063a0:	693a      	ldr	r2, [r7, #16]
 80063a2:	440a      	add	r2, r1
 80063a4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80063a8:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 80063ac:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 80063ae:	683b      	ldr	r3, [r7, #0]
 80063b0:	781b      	ldrb	r3, [r3, #0]
 80063b2:	015a      	lsls	r2, r3, #5
 80063b4:	693b      	ldr	r3, [r7, #16]
 80063b6:	4413      	add	r3, r2
 80063b8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80063bc:	681b      	ldr	r3, [r3, #0]
 80063be:	683a      	ldr	r2, [r7, #0]
 80063c0:	7812      	ldrb	r2, [r2, #0]
 80063c2:	0151      	lsls	r1, r2, #5
 80063c4:	693a      	ldr	r2, [r7, #16]
 80063c6:	440a      	add	r2, r1
 80063c8:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80063cc:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 80063d0:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 80063d2:	68fb      	ldr	r3, [r7, #12]
 80063d4:	3301      	adds	r3, #1
 80063d6:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 80063d8:	68fb      	ldr	r3, [r7, #12]
 80063da:	f242 7210 	movw	r2, #10000	@ 0x2710
 80063de:	4293      	cmp	r3, r2
 80063e0:	d902      	bls.n	80063e8 <USB_EPStopXfer+0x12c>
        {
          ret = HAL_ERROR;
 80063e2:	2301      	movs	r3, #1
 80063e4:	75fb      	strb	r3, [r7, #23]
          break;
 80063e6:	e00c      	b.n	8006402 <USB_EPStopXfer+0x146>
        }
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 80063e8:	683b      	ldr	r3, [r7, #0]
 80063ea:	781b      	ldrb	r3, [r3, #0]
 80063ec:	015a      	lsls	r2, r3, #5
 80063ee:	693b      	ldr	r3, [r7, #16]
 80063f0:	4413      	add	r3, r2
 80063f2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80063f6:	681b      	ldr	r3, [r3, #0]
 80063f8:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80063fc:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8006400:	d0e7      	beq.n	80063d2 <USB_EPStopXfer+0x116>
    }
  }

  return ret;
 8006402:	7dfb      	ldrb	r3, [r7, #23]
}
 8006404:	4618      	mov	r0, r3
 8006406:	371c      	adds	r7, #28
 8006408:	46bd      	mov	sp, r7
 800640a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800640e:	4770      	bx	lr

08006410 <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 8006410:	b480      	push	{r7}
 8006412:	b089      	sub	sp, #36	@ 0x24
 8006414:	af00      	add	r7, sp, #0
 8006416:	60f8      	str	r0, [r7, #12]
 8006418:	60b9      	str	r1, [r7, #8]
 800641a:	4611      	mov	r1, r2
 800641c:	461a      	mov	r2, r3
 800641e:	460b      	mov	r3, r1
 8006420:	71fb      	strb	r3, [r7, #7]
 8006422:	4613      	mov	r3, r2
 8006424:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006426:	68fb      	ldr	r3, [r7, #12]
 8006428:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
 800642a:	68bb      	ldr	r3, [r7, #8]
 800642c:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 800642e:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8006432:	2b00      	cmp	r3, #0
 8006434:	d123      	bne.n	800647e <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 8006436:	88bb      	ldrh	r3, [r7, #4]
 8006438:	3303      	adds	r3, #3
 800643a:	089b      	lsrs	r3, r3, #2
 800643c:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 800643e:	2300      	movs	r3, #0
 8006440:	61bb      	str	r3, [r7, #24]
 8006442:	e018      	b.n	8006476 <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8006444:	79fb      	ldrb	r3, [r7, #7]
 8006446:	031a      	lsls	r2, r3, #12
 8006448:	697b      	ldr	r3, [r7, #20]
 800644a:	4413      	add	r3, r2
 800644c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8006450:	461a      	mov	r2, r3
 8006452:	69fb      	ldr	r3, [r7, #28]
 8006454:	681b      	ldr	r3, [r3, #0]
 8006456:	6013      	str	r3, [r2, #0]
      pSrc++;
 8006458:	69fb      	ldr	r3, [r7, #28]
 800645a:	3301      	adds	r3, #1
 800645c:	61fb      	str	r3, [r7, #28]
      pSrc++;
 800645e:	69fb      	ldr	r3, [r7, #28]
 8006460:	3301      	adds	r3, #1
 8006462:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8006464:	69fb      	ldr	r3, [r7, #28]
 8006466:	3301      	adds	r3, #1
 8006468:	61fb      	str	r3, [r7, #28]
      pSrc++;
 800646a:	69fb      	ldr	r3, [r7, #28]
 800646c:	3301      	adds	r3, #1
 800646e:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 8006470:	69bb      	ldr	r3, [r7, #24]
 8006472:	3301      	adds	r3, #1
 8006474:	61bb      	str	r3, [r7, #24]
 8006476:	69ba      	ldr	r2, [r7, #24]
 8006478:	693b      	ldr	r3, [r7, #16]
 800647a:	429a      	cmp	r2, r3
 800647c:	d3e2      	bcc.n	8006444 <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 800647e:	2300      	movs	r3, #0
}
 8006480:	4618      	mov	r0, r3
 8006482:	3724      	adds	r7, #36	@ 0x24
 8006484:	46bd      	mov	sp, r7
 8006486:	f85d 7b04 	ldr.w	r7, [sp], #4
 800648a:	4770      	bx	lr

0800648c <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 800648c:	b480      	push	{r7}
 800648e:	b08b      	sub	sp, #44	@ 0x2c
 8006490:	af00      	add	r7, sp, #0
 8006492:	60f8      	str	r0, [r7, #12]
 8006494:	60b9      	str	r1, [r7, #8]
 8006496:	4613      	mov	r3, r2
 8006498:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800649a:	68fb      	ldr	r3, [r7, #12]
 800649c:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
 800649e:	68bb      	ldr	r3, [r7, #8]
 80064a0:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
 80064a2:	88fb      	ldrh	r3, [r7, #6]
 80064a4:	089b      	lsrs	r3, r3, #2
 80064a6:	b29b      	uxth	r3, r3
 80064a8:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
 80064aa:	88fb      	ldrh	r3, [r7, #6]
 80064ac:	f003 0303 	and.w	r3, r3, #3
 80064b0:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
 80064b2:	2300      	movs	r3, #0
 80064b4:	623b      	str	r3, [r7, #32]
 80064b6:	e014      	b.n	80064e2 <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 80064b8:	69bb      	ldr	r3, [r7, #24]
 80064ba:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80064be:	681a      	ldr	r2, [r3, #0]
 80064c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80064c2:	601a      	str	r2, [r3, #0]
    pDest++;
 80064c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80064c6:	3301      	adds	r3, #1
 80064c8:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 80064ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80064cc:	3301      	adds	r3, #1
 80064ce:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 80064d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80064d2:	3301      	adds	r3, #1
 80064d4:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 80064d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80064d8:	3301      	adds	r3, #1
 80064da:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0U; i < count32b; i++)
 80064dc:	6a3b      	ldr	r3, [r7, #32]
 80064de:	3301      	adds	r3, #1
 80064e0:	623b      	str	r3, [r7, #32]
 80064e2:	6a3a      	ldr	r2, [r7, #32]
 80064e4:	697b      	ldr	r3, [r7, #20]
 80064e6:	429a      	cmp	r2, r3
 80064e8:	d3e6      	bcc.n	80064b8 <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
 80064ea:	8bfb      	ldrh	r3, [r7, #30]
 80064ec:	2b00      	cmp	r3, #0
 80064ee:	d01e      	beq.n	800652e <USB_ReadPacket+0xa2>
  {
    i = 0U;
 80064f0:	2300      	movs	r3, #0
 80064f2:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 80064f4:	69bb      	ldr	r3, [r7, #24]
 80064f6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80064fa:	461a      	mov	r2, r3
 80064fc:	f107 0310 	add.w	r3, r7, #16
 8006500:	6812      	ldr	r2, [r2, #0]
 8006502:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8006504:	693a      	ldr	r2, [r7, #16]
 8006506:	6a3b      	ldr	r3, [r7, #32]
 8006508:	b2db      	uxtb	r3, r3
 800650a:	00db      	lsls	r3, r3, #3
 800650c:	fa22 f303 	lsr.w	r3, r2, r3
 8006510:	b2da      	uxtb	r2, r3
 8006512:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006514:	701a      	strb	r2, [r3, #0]
      i++;
 8006516:	6a3b      	ldr	r3, [r7, #32]
 8006518:	3301      	adds	r3, #1
 800651a:	623b      	str	r3, [r7, #32]
      pDest++;
 800651c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800651e:	3301      	adds	r3, #1
 8006520:	627b      	str	r3, [r7, #36]	@ 0x24
      remaining_bytes--;
 8006522:	8bfb      	ldrh	r3, [r7, #30]
 8006524:	3b01      	subs	r3, #1
 8006526:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
 8006528:	8bfb      	ldrh	r3, [r7, #30]
 800652a:	2b00      	cmp	r3, #0
 800652c:	d1ea      	bne.n	8006504 <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
 800652e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8006530:	4618      	mov	r0, r3
 8006532:	372c      	adds	r7, #44	@ 0x2c
 8006534:	46bd      	mov	sp, r7
 8006536:	f85d 7b04 	ldr.w	r7, [sp], #4
 800653a:	4770      	bx	lr

0800653c <USB_EPSetStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 800653c:	b480      	push	{r7}
 800653e:	b085      	sub	sp, #20
 8006540:	af00      	add	r7, sp, #0
 8006542:	6078      	str	r0, [r7, #4]
 8006544:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006546:	687b      	ldr	r3, [r7, #4]
 8006548:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 800654a:	683b      	ldr	r3, [r7, #0]
 800654c:	781b      	ldrb	r3, [r3, #0]
 800654e:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8006550:	683b      	ldr	r3, [r7, #0]
 8006552:	785b      	ldrb	r3, [r3, #1]
 8006554:	2b01      	cmp	r3, #1
 8006556:	d12c      	bne.n	80065b2 <USB_EPSetStall+0x76>
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8006558:	68bb      	ldr	r3, [r7, #8]
 800655a:	015a      	lsls	r2, r3, #5
 800655c:	68fb      	ldr	r3, [r7, #12]
 800655e:	4413      	add	r3, r2
 8006560:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006564:	681b      	ldr	r3, [r3, #0]
 8006566:	2b00      	cmp	r3, #0
 8006568:	db12      	blt.n	8006590 <USB_EPSetStall+0x54>
 800656a:	68bb      	ldr	r3, [r7, #8]
 800656c:	2b00      	cmp	r3, #0
 800656e:	d00f      	beq.n	8006590 <USB_EPSetStall+0x54>
    {
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8006570:	68bb      	ldr	r3, [r7, #8]
 8006572:	015a      	lsls	r2, r3, #5
 8006574:	68fb      	ldr	r3, [r7, #12]
 8006576:	4413      	add	r3, r2
 8006578:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800657c:	681b      	ldr	r3, [r3, #0]
 800657e:	68ba      	ldr	r2, [r7, #8]
 8006580:	0151      	lsls	r1, r2, #5
 8006582:	68fa      	ldr	r2, [r7, #12]
 8006584:	440a      	add	r2, r1
 8006586:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800658a:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 800658e:	6013      	str	r3, [r2, #0]
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8006590:	68bb      	ldr	r3, [r7, #8]
 8006592:	015a      	lsls	r2, r3, #5
 8006594:	68fb      	ldr	r3, [r7, #12]
 8006596:	4413      	add	r3, r2
 8006598:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800659c:	681b      	ldr	r3, [r3, #0]
 800659e:	68ba      	ldr	r2, [r7, #8]
 80065a0:	0151      	lsls	r1, r2, #5
 80065a2:	68fa      	ldr	r2, [r7, #12]
 80065a4:	440a      	add	r2, r1
 80065a6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80065aa:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 80065ae:	6013      	str	r3, [r2, #0]
 80065b0:	e02b      	b.n	800660a <USB_EPSetStall+0xce>
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 80065b2:	68bb      	ldr	r3, [r7, #8]
 80065b4:	015a      	lsls	r2, r3, #5
 80065b6:	68fb      	ldr	r3, [r7, #12]
 80065b8:	4413      	add	r3, r2
 80065ba:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80065be:	681b      	ldr	r3, [r3, #0]
 80065c0:	2b00      	cmp	r3, #0
 80065c2:	db12      	blt.n	80065ea <USB_EPSetStall+0xae>
 80065c4:	68bb      	ldr	r3, [r7, #8]
 80065c6:	2b00      	cmp	r3, #0
 80065c8:	d00f      	beq.n	80065ea <USB_EPSetStall+0xae>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 80065ca:	68bb      	ldr	r3, [r7, #8]
 80065cc:	015a      	lsls	r2, r3, #5
 80065ce:	68fb      	ldr	r3, [r7, #12]
 80065d0:	4413      	add	r3, r2
 80065d2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80065d6:	681b      	ldr	r3, [r3, #0]
 80065d8:	68ba      	ldr	r2, [r7, #8]
 80065da:	0151      	lsls	r1, r2, #5
 80065dc:	68fa      	ldr	r2, [r7, #12]
 80065de:	440a      	add	r2, r1
 80065e0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80065e4:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 80065e8:	6013      	str	r3, [r2, #0]
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 80065ea:	68bb      	ldr	r3, [r7, #8]
 80065ec:	015a      	lsls	r2, r3, #5
 80065ee:	68fb      	ldr	r3, [r7, #12]
 80065f0:	4413      	add	r3, r2
 80065f2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80065f6:	681b      	ldr	r3, [r3, #0]
 80065f8:	68ba      	ldr	r2, [r7, #8]
 80065fa:	0151      	lsls	r1, r2, #5
 80065fc:	68fa      	ldr	r2, [r7, #12]
 80065fe:	440a      	add	r2, r1
 8006600:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006604:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8006608:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 800660a:	2300      	movs	r3, #0
}
 800660c:	4618      	mov	r0, r3
 800660e:	3714      	adds	r7, #20
 8006610:	46bd      	mov	sp, r7
 8006612:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006616:	4770      	bx	lr

08006618 <USB_EPClearStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8006618:	b480      	push	{r7}
 800661a:	b085      	sub	sp, #20
 800661c:	af00      	add	r7, sp, #0
 800661e:	6078      	str	r0, [r7, #4]
 8006620:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006622:	687b      	ldr	r3, [r7, #4]
 8006624:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8006626:	683b      	ldr	r3, [r7, #0]
 8006628:	781b      	ldrb	r3, [r3, #0]
 800662a:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 800662c:	683b      	ldr	r3, [r7, #0]
 800662e:	785b      	ldrb	r3, [r3, #1]
 8006630:	2b01      	cmp	r3, #1
 8006632:	d128      	bne.n	8006686 <USB_EPClearStall+0x6e>
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8006634:	68bb      	ldr	r3, [r7, #8]
 8006636:	015a      	lsls	r2, r3, #5
 8006638:	68fb      	ldr	r3, [r7, #12]
 800663a:	4413      	add	r3, r2
 800663c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006640:	681b      	ldr	r3, [r3, #0]
 8006642:	68ba      	ldr	r2, [r7, #8]
 8006644:	0151      	lsls	r1, r2, #5
 8006646:	68fa      	ldr	r2, [r7, #12]
 8006648:	440a      	add	r2, r1
 800664a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800664e:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8006652:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8006654:	683b      	ldr	r3, [r7, #0]
 8006656:	791b      	ldrb	r3, [r3, #4]
 8006658:	2b03      	cmp	r3, #3
 800665a:	d003      	beq.n	8006664 <USB_EPClearStall+0x4c>
 800665c:	683b      	ldr	r3, [r7, #0]
 800665e:	791b      	ldrb	r3, [r3, #4]
 8006660:	2b02      	cmp	r3, #2
 8006662:	d138      	bne.n	80066d6 <USB_EPClearStall+0xbe>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8006664:	68bb      	ldr	r3, [r7, #8]
 8006666:	015a      	lsls	r2, r3, #5
 8006668:	68fb      	ldr	r3, [r7, #12]
 800666a:	4413      	add	r3, r2
 800666c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006670:	681b      	ldr	r3, [r3, #0]
 8006672:	68ba      	ldr	r2, [r7, #8]
 8006674:	0151      	lsls	r1, r2, #5
 8006676:	68fa      	ldr	r2, [r7, #12]
 8006678:	440a      	add	r2, r1
 800667a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800667e:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8006682:	6013      	str	r3, [r2, #0]
 8006684:	e027      	b.n	80066d6 <USB_EPClearStall+0xbe>
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8006686:	68bb      	ldr	r3, [r7, #8]
 8006688:	015a      	lsls	r2, r3, #5
 800668a:	68fb      	ldr	r3, [r7, #12]
 800668c:	4413      	add	r3, r2
 800668e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006692:	681b      	ldr	r3, [r3, #0]
 8006694:	68ba      	ldr	r2, [r7, #8]
 8006696:	0151      	lsls	r1, r2, #5
 8006698:	68fa      	ldr	r2, [r7, #12]
 800669a:	440a      	add	r2, r1
 800669c:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80066a0:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 80066a4:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 80066a6:	683b      	ldr	r3, [r7, #0]
 80066a8:	791b      	ldrb	r3, [r3, #4]
 80066aa:	2b03      	cmp	r3, #3
 80066ac:	d003      	beq.n	80066b6 <USB_EPClearStall+0x9e>
 80066ae:	683b      	ldr	r3, [r7, #0]
 80066b0:	791b      	ldrb	r3, [r3, #4]
 80066b2:	2b02      	cmp	r3, #2
 80066b4:	d10f      	bne.n	80066d6 <USB_EPClearStall+0xbe>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80066b6:	68bb      	ldr	r3, [r7, #8]
 80066b8:	015a      	lsls	r2, r3, #5
 80066ba:	68fb      	ldr	r3, [r7, #12]
 80066bc:	4413      	add	r3, r2
 80066be:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80066c2:	681b      	ldr	r3, [r3, #0]
 80066c4:	68ba      	ldr	r2, [r7, #8]
 80066c6:	0151      	lsls	r1, r2, #5
 80066c8:	68fa      	ldr	r2, [r7, #12]
 80066ca:	440a      	add	r2, r1
 80066cc:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80066d0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80066d4:	6013      	str	r3, [r2, #0]
    }
  }
  return HAL_OK;
 80066d6:	2300      	movs	r3, #0
}
 80066d8:	4618      	mov	r0, r3
 80066da:	3714      	adds	r7, #20
 80066dc:	46bd      	mov	sp, r7
 80066de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066e2:	4770      	bx	lr

080066e4 <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetDevAddress(const USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
 80066e4:	b480      	push	{r7}
 80066e6:	b085      	sub	sp, #20
 80066e8:	af00      	add	r7, sp, #0
 80066ea:	6078      	str	r0, [r7, #4]
 80066ec:	460b      	mov	r3, r1
 80066ee:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80066f0:	687b      	ldr	r3, [r7, #4]
 80066f2:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 80066f4:	68fb      	ldr	r3, [r7, #12]
 80066f6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80066fa:	681b      	ldr	r3, [r3, #0]
 80066fc:	68fa      	ldr	r2, [r7, #12]
 80066fe:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8006702:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 8006706:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8006708:	68fb      	ldr	r3, [r7, #12]
 800670a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800670e:	681a      	ldr	r2, [r3, #0]
 8006710:	78fb      	ldrb	r3, [r7, #3]
 8006712:	011b      	lsls	r3, r3, #4
 8006714:	f403 63fe 	and.w	r3, r3, #2032	@ 0x7f0
 8006718:	68f9      	ldr	r1, [r7, #12]
 800671a:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800671e:	4313      	orrs	r3, r2
 8006720:	600b      	str	r3, [r1, #0]

  return HAL_OK;
 8006722:	2300      	movs	r3, #0
}
 8006724:	4618      	mov	r0, r3
 8006726:	3714      	adds	r7, #20
 8006728:	46bd      	mov	sp, r7
 800672a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800672e:	4770      	bx	lr

08006730 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevConnect(const USB_OTG_GlobalTypeDef *USBx)
{
 8006730:	b480      	push	{r7}
 8006732:	b085      	sub	sp, #20
 8006734:	af00      	add	r7, sp, #0
 8006736:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006738:	687b      	ldr	r3, [r7, #4]
 800673a:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 800673c:	68fb      	ldr	r3, [r7, #12]
 800673e:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8006742:	681b      	ldr	r3, [r3, #0]
 8006744:	68fa      	ldr	r2, [r7, #12]
 8006746:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 800674a:	f023 0303 	bic.w	r3, r3, #3
 800674e:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 8006750:	68fb      	ldr	r3, [r7, #12]
 8006752:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006756:	685b      	ldr	r3, [r3, #4]
 8006758:	68fa      	ldr	r2, [r7, #12]
 800675a:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800675e:	f023 0302 	bic.w	r3, r3, #2
 8006762:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 8006764:	2300      	movs	r3, #0
}
 8006766:	4618      	mov	r0, r3
 8006768:	3714      	adds	r7, #20
 800676a:	46bd      	mov	sp, r7
 800676c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006770:	4770      	bx	lr

08006772 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevDisconnect(const USB_OTG_GlobalTypeDef *USBx)
{
 8006772:	b480      	push	{r7}
 8006774:	b085      	sub	sp, #20
 8006776:	af00      	add	r7, sp, #0
 8006778:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800677a:	687b      	ldr	r3, [r7, #4]
 800677c:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 800677e:	68fb      	ldr	r3, [r7, #12]
 8006780:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8006784:	681b      	ldr	r3, [r3, #0]
 8006786:	68fa      	ldr	r2, [r7, #12]
 8006788:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 800678c:	f023 0303 	bic.w	r3, r3, #3
 8006790:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8006792:	68fb      	ldr	r3, [r7, #12]
 8006794:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006798:	685b      	ldr	r3, [r3, #4]
 800679a:	68fa      	ldr	r2, [r7, #12]
 800679c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80067a0:	f043 0302 	orr.w	r3, r3, #2
 80067a4:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 80067a6:	2300      	movs	r3, #0
}
 80067a8:	4618      	mov	r0, r3
 80067aa:	3714      	adds	r7, #20
 80067ac:	46bd      	mov	sp, r7
 80067ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067b2:	4770      	bx	lr

080067b4 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
 80067b4:	b480      	push	{r7}
 80067b6:	b085      	sub	sp, #20
 80067b8:	af00      	add	r7, sp, #0
 80067ba:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 80067bc:	687b      	ldr	r3, [r7, #4]
 80067be:	695b      	ldr	r3, [r3, #20]
 80067c0:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 80067c2:	687b      	ldr	r3, [r7, #4]
 80067c4:	699b      	ldr	r3, [r3, #24]
 80067c6:	68fa      	ldr	r2, [r7, #12]
 80067c8:	4013      	ands	r3, r2
 80067ca:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 80067cc:	68fb      	ldr	r3, [r7, #12]
}
 80067ce:	4618      	mov	r0, r3
 80067d0:	3714      	adds	r7, #20
 80067d2:	46bd      	mov	sp, r7
 80067d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067d8:	4770      	bx	lr

080067da <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device OUT EP interrupt status
  */
uint32_t USB_ReadDevAllOutEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 80067da:	b480      	push	{r7}
 80067dc:	b085      	sub	sp, #20
 80067de:	af00      	add	r7, sp, #0
 80067e0:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80067e2:	687b      	ldr	r3, [r7, #4]
 80067e4:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 80067e6:	68fb      	ldr	r3, [r7, #12]
 80067e8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80067ec:	699b      	ldr	r3, [r3, #24]
 80067ee:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 80067f0:	68fb      	ldr	r3, [r7, #12]
 80067f2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80067f6:	69db      	ldr	r3, [r3, #28]
 80067f8:	68ba      	ldr	r2, [r7, #8]
 80067fa:	4013      	ands	r3, r2
 80067fc:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xffff0000U) >> 16);
 80067fe:	68bb      	ldr	r3, [r7, #8]
 8006800:	0c1b      	lsrs	r3, r3, #16
}
 8006802:	4618      	mov	r0, r3
 8006804:	3714      	adds	r7, #20
 8006806:	46bd      	mov	sp, r7
 8006808:	f85d 7b04 	ldr.w	r7, [sp], #4
 800680c:	4770      	bx	lr

0800680e <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device IN EP interrupt status
  */
uint32_t USB_ReadDevAllInEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 800680e:	b480      	push	{r7}
 8006810:	b085      	sub	sp, #20
 8006812:	af00      	add	r7, sp, #0
 8006814:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006816:	687b      	ldr	r3, [r7, #4]
 8006818:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 800681a:	68fb      	ldr	r3, [r7, #12]
 800681c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006820:	699b      	ldr	r3, [r3, #24]
 8006822:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8006824:	68fb      	ldr	r3, [r7, #12]
 8006826:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800682a:	69db      	ldr	r3, [r3, #28]
 800682c:	68ba      	ldr	r2, [r7, #8]
 800682e:	4013      	ands	r3, r2
 8006830:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xFFFFU));
 8006832:	68bb      	ldr	r3, [r7, #8]
 8006834:	b29b      	uxth	r3, r3
}
 8006836:	4618      	mov	r0, r3
 8006838:	3714      	adds	r7, #20
 800683a:	46bd      	mov	sp, r7
 800683c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006840:	4770      	bx	lr

08006842 <USB_ReadDevOutEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 8006842:	b480      	push	{r7}
 8006844:	b085      	sub	sp, #20
 8006846:	af00      	add	r7, sp, #0
 8006848:	6078      	str	r0, [r7, #4]
 800684a:	460b      	mov	r3, r1
 800684c:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800684e:	687b      	ldr	r3, [r7, #4]
 8006850:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8006852:	78fb      	ldrb	r3, [r7, #3]
 8006854:	015a      	lsls	r2, r3, #5
 8006856:	68fb      	ldr	r3, [r7, #12]
 8006858:	4413      	add	r3, r2
 800685a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800685e:	689b      	ldr	r3, [r3, #8]
 8006860:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8006862:	68fb      	ldr	r3, [r7, #12]
 8006864:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006868:	695b      	ldr	r3, [r3, #20]
 800686a:	68ba      	ldr	r2, [r7, #8]
 800686c:	4013      	ands	r3, r2
 800686e:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 8006870:	68bb      	ldr	r3, [r7, #8]
}
 8006872:	4618      	mov	r0, r3
 8006874:	3714      	adds	r7, #20
 8006876:	46bd      	mov	sp, r7
 8006878:	f85d 7b04 	ldr.w	r7, [sp], #4
 800687c:	4770      	bx	lr

0800687e <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 800687e:	b480      	push	{r7}
 8006880:	b087      	sub	sp, #28
 8006882:	af00      	add	r7, sp, #0
 8006884:	6078      	str	r0, [r7, #4]
 8006886:	460b      	mov	r3, r1
 8006888:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800688a:	687b      	ldr	r3, [r7, #4]
 800688c:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg;
  uint32_t msk;
  uint32_t emp;

  msk = USBx_DEVICE->DIEPMSK;
 800688e:	697b      	ldr	r3, [r7, #20]
 8006890:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006894:	691b      	ldr	r3, [r3, #16]
 8006896:	613b      	str	r3, [r7, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
 8006898:	697b      	ldr	r3, [r7, #20]
 800689a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800689e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80068a0:	60fb      	str	r3, [r7, #12]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 80068a2:	78fb      	ldrb	r3, [r7, #3]
 80068a4:	f003 030f 	and.w	r3, r3, #15
 80068a8:	68fa      	ldr	r2, [r7, #12]
 80068aa:	fa22 f303 	lsr.w	r3, r2, r3
 80068ae:	01db      	lsls	r3, r3, #7
 80068b0:	b2db      	uxtb	r3, r3
 80068b2:	693a      	ldr	r2, [r7, #16]
 80068b4:	4313      	orrs	r3, r2
 80068b6:	613b      	str	r3, [r7, #16]
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 80068b8:	78fb      	ldrb	r3, [r7, #3]
 80068ba:	015a      	lsls	r2, r3, #5
 80068bc:	697b      	ldr	r3, [r7, #20]
 80068be:	4413      	add	r3, r2
 80068c0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80068c4:	689b      	ldr	r3, [r3, #8]
 80068c6:	693a      	ldr	r2, [r7, #16]
 80068c8:	4013      	ands	r3, r2
 80068ca:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 80068cc:	68bb      	ldr	r3, [r7, #8]
}
 80068ce:	4618      	mov	r0, r3
 80068d0:	371c      	adds	r7, #28
 80068d2:	46bd      	mov	sp, r7
 80068d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80068d8:	4770      	bx	lr

080068da <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
 80068da:	b480      	push	{r7}
 80068dc:	b083      	sub	sp, #12
 80068de:	af00      	add	r7, sp, #0
 80068e0:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 80068e2:	687b      	ldr	r3, [r7, #4]
 80068e4:	695b      	ldr	r3, [r3, #20]
 80068e6:	f003 0301 	and.w	r3, r3, #1
}
 80068ea:	4618      	mov	r0, r3
 80068ec:	370c      	adds	r7, #12
 80068ee:	46bd      	mov	sp, r7
 80068f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80068f4:	4770      	bx	lr

080068f6 <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateSetup(const USB_OTG_GlobalTypeDef *USBx)
{
 80068f6:	b480      	push	{r7}
 80068f8:	b085      	sub	sp, #20
 80068fa:	af00      	add	r7, sp, #0
 80068fc:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80068fe:	687b      	ldr	r3, [r7, #4]
 8006900:	60fb      	str	r3, [r7, #12]

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8006902:	68fb      	ldr	r3, [r7, #12]
 8006904:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006908:	681b      	ldr	r3, [r3, #0]
 800690a:	68fa      	ldr	r2, [r7, #12]
 800690c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8006910:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 8006914:	f023 0307 	bic.w	r3, r3, #7
 8006918:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 800691a:	68fb      	ldr	r3, [r7, #12]
 800691c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006920:	685b      	ldr	r3, [r3, #4]
 8006922:	68fa      	ldr	r2, [r7, #12]
 8006924:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8006928:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800692c:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 800692e:	2300      	movs	r3, #0
}
 8006930:	4618      	mov	r0, r3
 8006932:	3714      	adds	r7, #20
 8006934:	46bd      	mov	sp, r7
 8006936:	f85d 7b04 	ldr.w	r7, [sp], #4
 800693a:	4770      	bx	lr

0800693c <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(const USB_OTG_GlobalTypeDef *USBx, uint8_t dma, const uint8_t *psetup)
{
 800693c:	b480      	push	{r7}
 800693e:	b087      	sub	sp, #28
 8006940:	af00      	add	r7, sp, #0
 8006942:	60f8      	str	r0, [r7, #12]
 8006944:	460b      	mov	r3, r1
 8006946:	607a      	str	r2, [r7, #4]
 8006948:	72fb      	strb	r3, [r7, #11]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800694a:	68fb      	ldr	r3, [r7, #12]
 800694c:	617b      	str	r3, [r7, #20]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 800694e:	68fb      	ldr	r3, [r7, #12]
 8006950:	333c      	adds	r3, #60	@ 0x3c
 8006952:	3304      	adds	r3, #4
 8006954:	681b      	ldr	r3, [r3, #0]
 8006956:	613b      	str	r3, [r7, #16]

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8006958:	693b      	ldr	r3, [r7, #16]
 800695a:	4a26      	ldr	r2, [pc, #152]	@ (80069f4 <USB_EP0_OutStart+0xb8>)
 800695c:	4293      	cmp	r3, r2
 800695e:	d90a      	bls.n	8006976 <USB_EP0_OutStart+0x3a>
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8006960:	697b      	ldr	r3, [r7, #20]
 8006962:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006966:	681b      	ldr	r3, [r3, #0]
 8006968:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800696c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8006970:	d101      	bne.n	8006976 <USB_EP0_OutStart+0x3a>
    {
      return HAL_OK;
 8006972:	2300      	movs	r3, #0
 8006974:	e037      	b.n	80069e6 <USB_EP0_OutStart+0xaa>
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8006976:	697b      	ldr	r3, [r7, #20]
 8006978:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800697c:	461a      	mov	r2, r3
 800697e:	2300      	movs	r3, #0
 8006980:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8006982:	697b      	ldr	r3, [r7, #20]
 8006984:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006988:	691b      	ldr	r3, [r3, #16]
 800698a:	697a      	ldr	r2, [r7, #20]
 800698c:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006990:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8006994:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8006996:	697b      	ldr	r3, [r7, #20]
 8006998:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800699c:	691b      	ldr	r3, [r3, #16]
 800699e:	697a      	ldr	r2, [r7, #20]
 80069a0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80069a4:	f043 0318 	orr.w	r3, r3, #24
 80069a8:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 80069aa:	697b      	ldr	r3, [r7, #20]
 80069ac:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80069b0:	691b      	ldr	r3, [r3, #16]
 80069b2:	697a      	ldr	r2, [r7, #20]
 80069b4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80069b8:	f043 43c0 	orr.w	r3, r3, #1610612736	@ 0x60000000
 80069bc:	6113      	str	r3, [r2, #16]

  if (dma == 1U)
 80069be:	7afb      	ldrb	r3, [r7, #11]
 80069c0:	2b01      	cmp	r3, #1
 80069c2:	d10f      	bne.n	80069e4 <USB_EP0_OutStart+0xa8>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 80069c4:	697b      	ldr	r3, [r7, #20]
 80069c6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80069ca:	461a      	mov	r2, r3
 80069cc:	687b      	ldr	r3, [r7, #4]
 80069ce:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 80069d0:	697b      	ldr	r3, [r7, #20]
 80069d2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80069d6:	681b      	ldr	r3, [r3, #0]
 80069d8:	697a      	ldr	r2, [r7, #20]
 80069da:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80069de:	f043 2380 	orr.w	r3, r3, #2147516416	@ 0x80008000
 80069e2:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 80069e4:	2300      	movs	r3, #0
}
 80069e6:	4618      	mov	r0, r3
 80069e8:	371c      	adds	r7, #28
 80069ea:	46bd      	mov	sp, r7
 80069ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80069f0:	4770      	bx	lr
 80069f2:	bf00      	nop
 80069f4:	4f54300a 	.word	0x4f54300a

080069f8 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 80069f8:	b480      	push	{r7}
 80069fa:	b085      	sub	sp, #20
 80069fc:	af00      	add	r7, sp, #0
 80069fe:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8006a00:	2300      	movs	r3, #0
 8006a02:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8006a04:	68fb      	ldr	r3, [r7, #12]
 8006a06:	3301      	adds	r3, #1
 8006a08:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006a0a:	68fb      	ldr	r3, [r7, #12]
 8006a0c:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006a10:	d901      	bls.n	8006a16 <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 8006a12:	2303      	movs	r3, #3
 8006a14:	e01b      	b.n	8006a4e <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8006a16:	687b      	ldr	r3, [r7, #4]
 8006a18:	691b      	ldr	r3, [r3, #16]
 8006a1a:	2b00      	cmp	r3, #0
 8006a1c:	daf2      	bge.n	8006a04 <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 8006a1e:	2300      	movs	r3, #0
 8006a20:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8006a22:	687b      	ldr	r3, [r7, #4]
 8006a24:	691b      	ldr	r3, [r3, #16]
 8006a26:	f043 0201 	orr.w	r2, r3, #1
 8006a2a:	687b      	ldr	r3, [r7, #4]
 8006a2c:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8006a2e:	68fb      	ldr	r3, [r7, #12]
 8006a30:	3301      	adds	r3, #1
 8006a32:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8006a34:	68fb      	ldr	r3, [r7, #12]
 8006a36:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8006a3a:	d901      	bls.n	8006a40 <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 8006a3c:	2303      	movs	r3, #3
 8006a3e:	e006      	b.n	8006a4e <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8006a40:	687b      	ldr	r3, [r7, #4]
 8006a42:	691b      	ldr	r3, [r3, #16]
 8006a44:	f003 0301 	and.w	r3, r3, #1
 8006a48:	2b01      	cmp	r3, #1
 8006a4a:	d0f0      	beq.n	8006a2e <USB_CoreReset+0x36>

  return HAL_OK;
 8006a4c:	2300      	movs	r3, #0
}
 8006a4e:	4618      	mov	r0, r3
 8006a50:	3714      	adds	r7, #20
 8006a52:	46bd      	mov	sp, r7
 8006a54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a58:	4770      	bx	lr
	...

08006a5c <USBD_CDC_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8006a5c:	b580      	push	{r7, lr}
 8006a5e:	b084      	sub	sp, #16
 8006a60:	af00      	add	r7, sp, #0
 8006a62:	6078      	str	r0, [r7, #4]
 8006a64:	460b      	mov	r3, r1
 8006a66:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  USBD_CDC_HandleTypeDef *hcdc;

  hcdc = (USBD_CDC_HandleTypeDef *)USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 8006a68:	f44f 7007 	mov.w	r0, #540	@ 0x21c
 8006a6c:	f021 fd40 	bl	80284f0 <USBD_static_malloc>
 8006a70:	60f8      	str	r0, [r7, #12]

  if (hcdc == NULL)
 8006a72:	68fb      	ldr	r3, [r7, #12]
 8006a74:	2b00      	cmp	r3, #0
 8006a76:	d109      	bne.n	8006a8c <USBD_CDC_Init+0x30>
  {
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8006a78:	687b      	ldr	r3, [r7, #4]
 8006a7a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006a7e:	687b      	ldr	r3, [r7, #4]
 8006a80:	32b0      	adds	r2, #176	@ 0xb0
 8006a82:	2100      	movs	r1, #0
 8006a84:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    return (uint8_t)USBD_EMEM;
 8006a88:	2302      	movs	r3, #2
 8006a8a:	e0d4      	b.n	8006c36 <USBD_CDC_Init+0x1da>
  }

  (void)USBD_memset(hcdc, 0, sizeof(USBD_CDC_HandleTypeDef));
 8006a8c:	f44f 7207 	mov.w	r2, #540	@ 0x21c
 8006a90:	2100      	movs	r1, #0
 8006a92:	68f8      	ldr	r0, [r7, #12]
 8006a94:	f022 f8c6 	bl	8028c24 <memset>

  pdev->pClassDataCmsit[pdev->classId] = (void *)hcdc;
 8006a98:	687b      	ldr	r3, [r7, #4]
 8006a9a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006a9e:	687b      	ldr	r3, [r7, #4]
 8006aa0:	32b0      	adds	r2, #176	@ 0xb0
 8006aa2:	68f9      	ldr	r1, [r7, #12]
 8006aa4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 8006aa8:	687b      	ldr	r3, [r7, #4]
 8006aaa:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006aae:	687b      	ldr	r3, [r7, #4]
 8006ab0:	32b0      	adds	r2, #176	@ 0xb0
 8006ab2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8006ab6:	687b      	ldr	r3, [r7, #4]
 8006ab8:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8006abc:	687b      	ldr	r3, [r7, #4]
 8006abe:	7c1b      	ldrb	r3, [r3, #16]
 8006ac0:	2b00      	cmp	r3, #0
 8006ac2:	d138      	bne.n	8006b36 <USBD_CDC_Init+0xda>
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 8006ac4:	4b5e      	ldr	r3, [pc, #376]	@ (8006c40 <USBD_CDC_Init+0x1e4>)
 8006ac6:	7819      	ldrb	r1, [r3, #0]
 8006ac8:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8006acc:	2202      	movs	r2, #2
 8006ace:	6878      	ldr	r0, [r7, #4]
 8006ad0:	f021 fbeb 	bl	80282aa <USBD_LL_OpenEP>
                         CDC_DATA_HS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 8006ad4:	4b5a      	ldr	r3, [pc, #360]	@ (8006c40 <USBD_CDC_Init+0x1e4>)
 8006ad6:	781b      	ldrb	r3, [r3, #0]
 8006ad8:	f003 020f 	and.w	r2, r3, #15
 8006adc:	6879      	ldr	r1, [r7, #4]
 8006ade:	4613      	mov	r3, r2
 8006ae0:	009b      	lsls	r3, r3, #2
 8006ae2:	4413      	add	r3, r2
 8006ae4:	009b      	lsls	r3, r3, #2
 8006ae6:	440b      	add	r3, r1
 8006ae8:	3324      	adds	r3, #36	@ 0x24
 8006aea:	2201      	movs	r2, #1
 8006aec:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 8006aee:	4b55      	ldr	r3, [pc, #340]	@ (8006c44 <USBD_CDC_Init+0x1e8>)
 8006af0:	7819      	ldrb	r1, [r3, #0]
 8006af2:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8006af6:	2202      	movs	r2, #2
 8006af8:	6878      	ldr	r0, [r7, #4]
 8006afa:	f021 fbd6 	bl	80282aa <USBD_LL_OpenEP>
                         CDC_DATA_HS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 8006afe:	4b51      	ldr	r3, [pc, #324]	@ (8006c44 <USBD_CDC_Init+0x1e8>)
 8006b00:	781b      	ldrb	r3, [r3, #0]
 8006b02:	f003 020f 	and.w	r2, r3, #15
 8006b06:	6879      	ldr	r1, [r7, #4]
 8006b08:	4613      	mov	r3, r2
 8006b0a:	009b      	lsls	r3, r3, #2
 8006b0c:	4413      	add	r3, r2
 8006b0e:	009b      	lsls	r3, r3, #2
 8006b10:	440b      	add	r3, r1
 8006b12:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8006b16:	2201      	movs	r2, #1
 8006b18:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CDC CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 8006b1a:	4b4b      	ldr	r3, [pc, #300]	@ (8006c48 <USBD_CDC_Init+0x1ec>)
 8006b1c:	781b      	ldrb	r3, [r3, #0]
 8006b1e:	f003 020f 	and.w	r2, r3, #15
 8006b22:	6879      	ldr	r1, [r7, #4]
 8006b24:	4613      	mov	r3, r2
 8006b26:	009b      	lsls	r3, r3, #2
 8006b28:	4413      	add	r3, r2
 8006b2a:	009b      	lsls	r3, r3, #2
 8006b2c:	440b      	add	r3, r1
 8006b2e:	3326      	adds	r3, #38	@ 0x26
 8006b30:	2210      	movs	r2, #16
 8006b32:	801a      	strh	r2, [r3, #0]
 8006b34:	e035      	b.n	8006ba2 <USBD_CDC_Init+0x146>
  }
  else
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 8006b36:	4b42      	ldr	r3, [pc, #264]	@ (8006c40 <USBD_CDC_Init+0x1e4>)
 8006b38:	7819      	ldrb	r1, [r3, #0]
 8006b3a:	2340      	movs	r3, #64	@ 0x40
 8006b3c:	2202      	movs	r2, #2
 8006b3e:	6878      	ldr	r0, [r7, #4]
 8006b40:	f021 fbb3 	bl	80282aa <USBD_LL_OpenEP>
                         CDC_DATA_FS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 8006b44:	4b3e      	ldr	r3, [pc, #248]	@ (8006c40 <USBD_CDC_Init+0x1e4>)
 8006b46:	781b      	ldrb	r3, [r3, #0]
 8006b48:	f003 020f 	and.w	r2, r3, #15
 8006b4c:	6879      	ldr	r1, [r7, #4]
 8006b4e:	4613      	mov	r3, r2
 8006b50:	009b      	lsls	r3, r3, #2
 8006b52:	4413      	add	r3, r2
 8006b54:	009b      	lsls	r3, r3, #2
 8006b56:	440b      	add	r3, r1
 8006b58:	3324      	adds	r3, #36	@ 0x24
 8006b5a:	2201      	movs	r2, #1
 8006b5c:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 8006b5e:	4b39      	ldr	r3, [pc, #228]	@ (8006c44 <USBD_CDC_Init+0x1e8>)
 8006b60:	7819      	ldrb	r1, [r3, #0]
 8006b62:	2340      	movs	r3, #64	@ 0x40
 8006b64:	2202      	movs	r2, #2
 8006b66:	6878      	ldr	r0, [r7, #4]
 8006b68:	f021 fb9f 	bl	80282aa <USBD_LL_OpenEP>
                         CDC_DATA_FS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 8006b6c:	4b35      	ldr	r3, [pc, #212]	@ (8006c44 <USBD_CDC_Init+0x1e8>)
 8006b6e:	781b      	ldrb	r3, [r3, #0]
 8006b70:	f003 020f 	and.w	r2, r3, #15
 8006b74:	6879      	ldr	r1, [r7, #4]
 8006b76:	4613      	mov	r3, r2
 8006b78:	009b      	lsls	r3, r3, #2
 8006b7a:	4413      	add	r3, r2
 8006b7c:	009b      	lsls	r3, r3, #2
 8006b7e:	440b      	add	r3, r1
 8006b80:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8006b84:	2201      	movs	r2, #1
 8006b86:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_FS_BINTERVAL;
 8006b88:	4b2f      	ldr	r3, [pc, #188]	@ (8006c48 <USBD_CDC_Init+0x1ec>)
 8006b8a:	781b      	ldrb	r3, [r3, #0]
 8006b8c:	f003 020f 	and.w	r2, r3, #15
 8006b90:	6879      	ldr	r1, [r7, #4]
 8006b92:	4613      	mov	r3, r2
 8006b94:	009b      	lsls	r3, r3, #2
 8006b96:	4413      	add	r3, r2
 8006b98:	009b      	lsls	r3, r3, #2
 8006b9a:	440b      	add	r3, r1
 8006b9c:	3326      	adds	r3, #38	@ 0x26
 8006b9e:	2210      	movs	r2, #16
 8006ba0:	801a      	strh	r2, [r3, #0]
  }

  /* Open Command IN EP */
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8006ba2:	4b29      	ldr	r3, [pc, #164]	@ (8006c48 <USBD_CDC_Init+0x1ec>)
 8006ba4:	7819      	ldrb	r1, [r3, #0]
 8006ba6:	2308      	movs	r3, #8
 8006ba8:	2203      	movs	r2, #3
 8006baa:	6878      	ldr	r0, [r7, #4]
 8006bac:	f021 fb7d 	bl	80282aa <USBD_LL_OpenEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 1U;
 8006bb0:	4b25      	ldr	r3, [pc, #148]	@ (8006c48 <USBD_CDC_Init+0x1ec>)
 8006bb2:	781b      	ldrb	r3, [r3, #0]
 8006bb4:	f003 020f 	and.w	r2, r3, #15
 8006bb8:	6879      	ldr	r1, [r7, #4]
 8006bba:	4613      	mov	r3, r2
 8006bbc:	009b      	lsls	r3, r3, #2
 8006bbe:	4413      	add	r3, r2
 8006bc0:	009b      	lsls	r3, r3, #2
 8006bc2:	440b      	add	r3, r1
 8006bc4:	3324      	adds	r3, #36	@ 0x24
 8006bc6:	2201      	movs	r2, #1
 8006bc8:	801a      	strh	r2, [r3, #0]

  hcdc->RxBuffer = NULL;
 8006bca:	68fb      	ldr	r3, [r7, #12]
 8006bcc:	2200      	movs	r2, #0
 8006bce:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204

  /* Init  physical Interface components */
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8006bd2:	687b      	ldr	r3, [r7, #4]
 8006bd4:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006bd8:	687a      	ldr	r2, [r7, #4]
 8006bda:	33b0      	adds	r3, #176	@ 0xb0
 8006bdc:	009b      	lsls	r3, r3, #2
 8006bde:	4413      	add	r3, r2
 8006be0:	685b      	ldr	r3, [r3, #4]
 8006be2:	681b      	ldr	r3, [r3, #0]
 8006be4:	4798      	blx	r3

  /* Init Xfer states */
  hcdc->TxState = 0U;
 8006be6:	68fb      	ldr	r3, [r7, #12]
 8006be8:	2200      	movs	r2, #0
 8006bea:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214
  hcdc->RxState = 0U;
 8006bee:	68fb      	ldr	r3, [r7, #12]
 8006bf0:	2200      	movs	r2, #0
 8006bf2:	f8c3 2218 	str.w	r2, [r3, #536]	@ 0x218

  if (hcdc->RxBuffer == NULL)
 8006bf6:	68fb      	ldr	r3, [r7, #12]
 8006bf8:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
 8006bfc:	2b00      	cmp	r3, #0
 8006bfe:	d101      	bne.n	8006c04 <USBD_CDC_Init+0x1a8>
  {
    return (uint8_t)USBD_EMEM;
 8006c00:	2302      	movs	r3, #2
 8006c02:	e018      	b.n	8006c36 <USBD_CDC_Init+0x1da>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8006c04:	687b      	ldr	r3, [r7, #4]
 8006c06:	7c1b      	ldrb	r3, [r3, #16]
 8006c08:	2b00      	cmp	r3, #0
 8006c0a:	d10a      	bne.n	8006c22 <USBD_CDC_Init+0x1c6>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8006c0c:	4b0d      	ldr	r3, [pc, #52]	@ (8006c44 <USBD_CDC_Init+0x1e8>)
 8006c0e:	7819      	ldrb	r1, [r3, #0]
 8006c10:	68fb      	ldr	r3, [r7, #12]
 8006c12:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8006c16:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8006c1a:	6878      	ldr	r0, [r7, #4]
 8006c1c:	f021 fc34 	bl	8028488 <USBD_LL_PrepareReceive>
 8006c20:	e008      	b.n	8006c34 <USBD_CDC_Init+0x1d8>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8006c22:	4b08      	ldr	r3, [pc, #32]	@ (8006c44 <USBD_CDC_Init+0x1e8>)
 8006c24:	7819      	ldrb	r1, [r3, #0]
 8006c26:	68fb      	ldr	r3, [r7, #12]
 8006c28:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8006c2c:	2340      	movs	r3, #64	@ 0x40
 8006c2e:	6878      	ldr	r0, [r7, #4]
 8006c30:	f021 fc2a 	bl	8028488 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 8006c34:	2300      	movs	r3, #0
}
 8006c36:	4618      	mov	r0, r3
 8006c38:	3710      	adds	r7, #16
 8006c3a:	46bd      	mov	sp, r7
 8006c3c:	bd80      	pop	{r7, pc}
 8006c3e:	bf00      	nop
 8006c40:	200000ab 	.word	0x200000ab
 8006c44:	200000ac 	.word	0x200000ac
 8006c48:	200000ad 	.word	0x200000ad

08006c4c <USBD_CDC_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8006c4c:	b580      	push	{r7, lr}
 8006c4e:	b082      	sub	sp, #8
 8006c50:	af00      	add	r7, sp, #0
 8006c52:	6078      	str	r0, [r7, #4]
 8006c54:	460b      	mov	r3, r1
 8006c56:	70fb      	strb	r3, [r7, #3]
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  /* Close EP IN */
  (void)USBD_LL_CloseEP(pdev, CDCInEpAdd);
 8006c58:	4b3a      	ldr	r3, [pc, #232]	@ (8006d44 <USBD_CDC_DeInit+0xf8>)
 8006c5a:	781b      	ldrb	r3, [r3, #0]
 8006c5c:	4619      	mov	r1, r3
 8006c5e:	6878      	ldr	r0, [r7, #4]
 8006c60:	f021 fb49 	bl	80282f6 <USBD_LL_CloseEP>
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 8006c64:	4b37      	ldr	r3, [pc, #220]	@ (8006d44 <USBD_CDC_DeInit+0xf8>)
 8006c66:	781b      	ldrb	r3, [r3, #0]
 8006c68:	f003 020f 	and.w	r2, r3, #15
 8006c6c:	6879      	ldr	r1, [r7, #4]
 8006c6e:	4613      	mov	r3, r2
 8006c70:	009b      	lsls	r3, r3, #2
 8006c72:	4413      	add	r3, r2
 8006c74:	009b      	lsls	r3, r3, #2
 8006c76:	440b      	add	r3, r1
 8006c78:	3324      	adds	r3, #36	@ 0x24
 8006c7a:	2200      	movs	r2, #0
 8006c7c:	801a      	strh	r2, [r3, #0]

  /* Close EP OUT */
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 8006c7e:	4b32      	ldr	r3, [pc, #200]	@ (8006d48 <USBD_CDC_DeInit+0xfc>)
 8006c80:	781b      	ldrb	r3, [r3, #0]
 8006c82:	4619      	mov	r1, r3
 8006c84:	6878      	ldr	r0, [r7, #4]
 8006c86:	f021 fb36 	bl	80282f6 <USBD_LL_CloseEP>
  pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 0U;
 8006c8a:	4b2f      	ldr	r3, [pc, #188]	@ (8006d48 <USBD_CDC_DeInit+0xfc>)
 8006c8c:	781b      	ldrb	r3, [r3, #0]
 8006c8e:	f003 020f 	and.w	r2, r3, #15
 8006c92:	6879      	ldr	r1, [r7, #4]
 8006c94:	4613      	mov	r3, r2
 8006c96:	009b      	lsls	r3, r3, #2
 8006c98:	4413      	add	r3, r2
 8006c9a:	009b      	lsls	r3, r3, #2
 8006c9c:	440b      	add	r3, r1
 8006c9e:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8006ca2:	2200      	movs	r2, #0
 8006ca4:	801a      	strh	r2, [r3, #0]

  /* Close Command IN EP */
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 8006ca6:	4b29      	ldr	r3, [pc, #164]	@ (8006d4c <USBD_CDC_DeInit+0x100>)
 8006ca8:	781b      	ldrb	r3, [r3, #0]
 8006caa:	4619      	mov	r1, r3
 8006cac:	6878      	ldr	r0, [r7, #4]
 8006cae:	f021 fb22 	bl	80282f6 <USBD_LL_CloseEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 0U;
 8006cb2:	4b26      	ldr	r3, [pc, #152]	@ (8006d4c <USBD_CDC_DeInit+0x100>)
 8006cb4:	781b      	ldrb	r3, [r3, #0]
 8006cb6:	f003 020f 	and.w	r2, r3, #15
 8006cba:	6879      	ldr	r1, [r7, #4]
 8006cbc:	4613      	mov	r3, r2
 8006cbe:	009b      	lsls	r3, r3, #2
 8006cc0:	4413      	add	r3, r2
 8006cc2:	009b      	lsls	r3, r3, #2
 8006cc4:	440b      	add	r3, r1
 8006cc6:	3324      	adds	r3, #36	@ 0x24
 8006cc8:	2200      	movs	r2, #0
 8006cca:	801a      	strh	r2, [r3, #0]
  pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = 0U;
 8006ccc:	4b1f      	ldr	r3, [pc, #124]	@ (8006d4c <USBD_CDC_DeInit+0x100>)
 8006cce:	781b      	ldrb	r3, [r3, #0]
 8006cd0:	f003 020f 	and.w	r2, r3, #15
 8006cd4:	6879      	ldr	r1, [r7, #4]
 8006cd6:	4613      	mov	r3, r2
 8006cd8:	009b      	lsls	r3, r3, #2
 8006cda:	4413      	add	r3, r2
 8006cdc:	009b      	lsls	r3, r3, #2
 8006cde:	440b      	add	r3, r1
 8006ce0:	3326      	adds	r3, #38	@ 0x26
 8006ce2:	2200      	movs	r2, #0
 8006ce4:	801a      	strh	r2, [r3, #0]

  /* DeInit  physical Interface components */
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 8006ce6:	687b      	ldr	r3, [r7, #4]
 8006ce8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006cec:	687b      	ldr	r3, [r7, #4]
 8006cee:	32b0      	adds	r2, #176	@ 0xb0
 8006cf0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006cf4:	2b00      	cmp	r3, #0
 8006cf6:	d01f      	beq.n	8006d38 <USBD_CDC_DeInit+0xec>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit();
 8006cf8:	687b      	ldr	r3, [r7, #4]
 8006cfa:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006cfe:	687a      	ldr	r2, [r7, #4]
 8006d00:	33b0      	adds	r3, #176	@ 0xb0
 8006d02:	009b      	lsls	r3, r3, #2
 8006d04:	4413      	add	r3, r2
 8006d06:	685b      	ldr	r3, [r3, #4]
 8006d08:	685b      	ldr	r3, [r3, #4]
 8006d0a:	4798      	blx	r3
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 8006d0c:	687b      	ldr	r3, [r7, #4]
 8006d0e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006d12:	687b      	ldr	r3, [r7, #4]
 8006d14:	32b0      	adds	r2, #176	@ 0xb0
 8006d16:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006d1a:	4618      	mov	r0, r3
 8006d1c:	f021 fbf6 	bl	802850c <USBD_static_free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8006d20:	687b      	ldr	r3, [r7, #4]
 8006d22:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006d26:	687b      	ldr	r3, [r7, #4]
 8006d28:	32b0      	adds	r2, #176	@ 0xb0
 8006d2a:	2100      	movs	r1, #0
 8006d2c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    pdev->pClassData = NULL;
 8006d30:	687b      	ldr	r3, [r7, #4]
 8006d32:	2200      	movs	r2, #0
 8006d34:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  }

  return (uint8_t)USBD_OK;
 8006d38:	2300      	movs	r3, #0
}
 8006d3a:	4618      	mov	r0, r3
 8006d3c:	3708      	adds	r7, #8
 8006d3e:	46bd      	mov	sp, r7
 8006d40:	bd80      	pop	{r7, pc}
 8006d42:	bf00      	nop
 8006d44:	200000ab 	.word	0x200000ab
 8006d48:	200000ac 	.word	0x200000ac
 8006d4c:	200000ad 	.word	0x200000ad

08006d50 <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t USBD_CDC_Setup(USBD_HandleTypeDef *pdev,
                              USBD_SetupReqTypedef *req)
{
 8006d50:	b580      	push	{r7, lr}
 8006d52:	b086      	sub	sp, #24
 8006d54:	af00      	add	r7, sp, #0
 8006d56:	6078      	str	r0, [r7, #4]
 8006d58:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8006d5a:	687b      	ldr	r3, [r7, #4]
 8006d5c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006d60:	687b      	ldr	r3, [r7, #4]
 8006d62:	32b0      	adds	r2, #176	@ 0xb0
 8006d64:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006d68:	613b      	str	r3, [r7, #16]
  uint16_t len;
  uint8_t ifalt = 0U;
 8006d6a:	2300      	movs	r3, #0
 8006d6c:	737b      	strb	r3, [r7, #13]
  uint16_t status_info = 0U;
 8006d6e:	2300      	movs	r3, #0
 8006d70:	817b      	strh	r3, [r7, #10]
  USBD_StatusTypeDef ret = USBD_OK;
 8006d72:	2300      	movs	r3, #0
 8006d74:	75fb      	strb	r3, [r7, #23]

  if (hcdc == NULL)
 8006d76:	693b      	ldr	r3, [r7, #16]
 8006d78:	2b00      	cmp	r3, #0
 8006d7a:	d101      	bne.n	8006d80 <USBD_CDC_Setup+0x30>
  {
    return (uint8_t)USBD_FAIL;
 8006d7c:	2303      	movs	r3, #3
 8006d7e:	e0bf      	b.n	8006f00 <USBD_CDC_Setup+0x1b0>
  }

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006d80:	683b      	ldr	r3, [r7, #0]
 8006d82:	781b      	ldrb	r3, [r3, #0]
 8006d84:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8006d88:	2b00      	cmp	r3, #0
 8006d8a:	d050      	beq.n	8006e2e <USBD_CDC_Setup+0xde>
 8006d8c:	2b20      	cmp	r3, #32
 8006d8e:	f040 80af 	bne.w	8006ef0 <USBD_CDC_Setup+0x1a0>
  {
    case USB_REQ_TYPE_CLASS:
      if (req->wLength != 0U)
 8006d92:	683b      	ldr	r3, [r7, #0]
 8006d94:	88db      	ldrh	r3, [r3, #6]
 8006d96:	2b00      	cmp	r3, #0
 8006d98:	d03a      	beq.n	8006e10 <USBD_CDC_Setup+0xc0>
      {
        if ((req->bmRequest & 0x80U) != 0U)
 8006d9a:	683b      	ldr	r3, [r7, #0]
 8006d9c:	781b      	ldrb	r3, [r3, #0]
 8006d9e:	b25b      	sxtb	r3, r3
 8006da0:	2b00      	cmp	r3, #0
 8006da2:	da1b      	bge.n	8006ddc <USBD_CDC_Setup+0x8c>
        {
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8006da4:	687b      	ldr	r3, [r7, #4]
 8006da6:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006daa:	687a      	ldr	r2, [r7, #4]
 8006dac:	33b0      	adds	r3, #176	@ 0xb0
 8006dae:	009b      	lsls	r3, r3, #2
 8006db0:	4413      	add	r3, r2
 8006db2:	685b      	ldr	r3, [r3, #4]
 8006db4:	689b      	ldr	r3, [r3, #8]
 8006db6:	683a      	ldr	r2, [r7, #0]
 8006db8:	7850      	ldrb	r0, [r2, #1]
                                                                           (uint8_t *)hcdc->data,
 8006dba:	6939      	ldr	r1, [r7, #16]
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8006dbc:	683a      	ldr	r2, [r7, #0]
 8006dbe:	88d2      	ldrh	r2, [r2, #6]
 8006dc0:	4798      	blx	r3
                                                                           req->wLength);

          len = MIN(CDC_REQ_MAX_DATA_SIZE, req->wLength);
 8006dc2:	683b      	ldr	r3, [r7, #0]
 8006dc4:	88db      	ldrh	r3, [r3, #6]
 8006dc6:	2b07      	cmp	r3, #7
 8006dc8:	bf28      	it	cs
 8006dca:	2307      	movcs	r3, #7
 8006dcc:	81fb      	strh	r3, [r7, #14]
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, len);
 8006dce:	693b      	ldr	r3, [r7, #16]
 8006dd0:	89fa      	ldrh	r2, [r7, #14]
 8006dd2:	4619      	mov	r1, r3
 8006dd4:	6878      	ldr	r0, [r7, #4]
 8006dd6:	f001 fd93 	bl	8008900 <USBD_CtlSendData>
      else
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
                                                                         (uint8_t *)req, 0U);
      }
      break;
 8006dda:	e090      	b.n	8006efe <USBD_CDC_Setup+0x1ae>
          hcdc->CmdOpCode = req->bRequest;
 8006ddc:	683b      	ldr	r3, [r7, #0]
 8006dde:	785a      	ldrb	r2, [r3, #1]
 8006de0:	693b      	ldr	r3, [r7, #16]
 8006de2:	f883 2200 	strb.w	r2, [r3, #512]	@ 0x200
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 8006de6:	683b      	ldr	r3, [r7, #0]
 8006de8:	88db      	ldrh	r3, [r3, #6]
 8006dea:	2b3f      	cmp	r3, #63	@ 0x3f
 8006dec:	d803      	bhi.n	8006df6 <USBD_CDC_Setup+0xa6>
 8006dee:	683b      	ldr	r3, [r7, #0]
 8006df0:	88db      	ldrh	r3, [r3, #6]
 8006df2:	b2da      	uxtb	r2, r3
 8006df4:	e000      	b.n	8006df8 <USBD_CDC_Setup+0xa8>
 8006df6:	2240      	movs	r2, #64	@ 0x40
 8006df8:	693b      	ldr	r3, [r7, #16]
 8006dfa:	f883 2201 	strb.w	r2, [r3, #513]	@ 0x201
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 8006dfe:	6939      	ldr	r1, [r7, #16]
 8006e00:	693b      	ldr	r3, [r7, #16]
 8006e02:	f893 3201 	ldrb.w	r3, [r3, #513]	@ 0x201
 8006e06:	461a      	mov	r2, r3
 8006e08:	6878      	ldr	r0, [r7, #4]
 8006e0a:	f001 fda5 	bl	8008958 <USBD_CtlPrepareRx>
      break;
 8006e0e:	e076      	b.n	8006efe <USBD_CDC_Setup+0x1ae>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8006e10:	687b      	ldr	r3, [r7, #4]
 8006e12:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006e16:	687a      	ldr	r2, [r7, #4]
 8006e18:	33b0      	adds	r3, #176	@ 0xb0
 8006e1a:	009b      	lsls	r3, r3, #2
 8006e1c:	4413      	add	r3, r2
 8006e1e:	685b      	ldr	r3, [r3, #4]
 8006e20:	689b      	ldr	r3, [r3, #8]
 8006e22:	683a      	ldr	r2, [r7, #0]
 8006e24:	7850      	ldrb	r0, [r2, #1]
 8006e26:	2200      	movs	r2, #0
 8006e28:	6839      	ldr	r1, [r7, #0]
 8006e2a:	4798      	blx	r3
      break;
 8006e2c:	e067      	b.n	8006efe <USBD_CDC_Setup+0x1ae>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8006e2e:	683b      	ldr	r3, [r7, #0]
 8006e30:	785b      	ldrb	r3, [r3, #1]
 8006e32:	2b0b      	cmp	r3, #11
 8006e34:	d851      	bhi.n	8006eda <USBD_CDC_Setup+0x18a>
 8006e36:	a201      	add	r2, pc, #4	@ (adr r2, 8006e3c <USBD_CDC_Setup+0xec>)
 8006e38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006e3c:	08006e6d 	.word	0x08006e6d
 8006e40:	08006ee9 	.word	0x08006ee9
 8006e44:	08006edb 	.word	0x08006edb
 8006e48:	08006edb 	.word	0x08006edb
 8006e4c:	08006edb 	.word	0x08006edb
 8006e50:	08006edb 	.word	0x08006edb
 8006e54:	08006edb 	.word	0x08006edb
 8006e58:	08006edb 	.word	0x08006edb
 8006e5c:	08006edb 	.word	0x08006edb
 8006e60:	08006edb 	.word	0x08006edb
 8006e64:	08006e97 	.word	0x08006e97
 8006e68:	08006ec1 	.word	0x08006ec1
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006e6c:	687b      	ldr	r3, [r7, #4]
 8006e6e:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8006e72:	b2db      	uxtb	r3, r3
 8006e74:	2b03      	cmp	r3, #3
 8006e76:	d107      	bne.n	8006e88 <USBD_CDC_Setup+0x138>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8006e78:	f107 030a 	add.w	r3, r7, #10
 8006e7c:	2202      	movs	r2, #2
 8006e7e:	4619      	mov	r1, r3
 8006e80:	6878      	ldr	r0, [r7, #4]
 8006e82:	f001 fd3d 	bl	8008900 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8006e86:	e032      	b.n	8006eee <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8006e88:	6839      	ldr	r1, [r7, #0]
 8006e8a:	6878      	ldr	r0, [r7, #4]
 8006e8c:	f001 fcbb 	bl	8008806 <USBD_CtlError>
            ret = USBD_FAIL;
 8006e90:	2303      	movs	r3, #3
 8006e92:	75fb      	strb	r3, [r7, #23]
          break;
 8006e94:	e02b      	b.n	8006eee <USBD_CDC_Setup+0x19e>

        case USB_REQ_GET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006e96:	687b      	ldr	r3, [r7, #4]
 8006e98:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8006e9c:	b2db      	uxtb	r3, r3
 8006e9e:	2b03      	cmp	r3, #3
 8006ea0:	d107      	bne.n	8006eb2 <USBD_CDC_Setup+0x162>
          {
            (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 8006ea2:	f107 030d 	add.w	r3, r7, #13
 8006ea6:	2201      	movs	r2, #1
 8006ea8:	4619      	mov	r1, r3
 8006eaa:	6878      	ldr	r0, [r7, #4]
 8006eac:	f001 fd28 	bl	8008900 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8006eb0:	e01d      	b.n	8006eee <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8006eb2:	6839      	ldr	r1, [r7, #0]
 8006eb4:	6878      	ldr	r0, [r7, #4]
 8006eb6:	f001 fca6 	bl	8008806 <USBD_CtlError>
            ret = USBD_FAIL;
 8006eba:	2303      	movs	r3, #3
 8006ebc:	75fb      	strb	r3, [r7, #23]
          break;
 8006ebe:	e016      	b.n	8006eee <USBD_CDC_Setup+0x19e>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8006ec0:	687b      	ldr	r3, [r7, #4]
 8006ec2:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8006ec6:	b2db      	uxtb	r3, r3
 8006ec8:	2b03      	cmp	r3, #3
 8006eca:	d00f      	beq.n	8006eec <USBD_CDC_Setup+0x19c>
          {
            USBD_CtlError(pdev, req);
 8006ecc:	6839      	ldr	r1, [r7, #0]
 8006ece:	6878      	ldr	r0, [r7, #4]
 8006ed0:	f001 fc99 	bl	8008806 <USBD_CtlError>
            ret = USBD_FAIL;
 8006ed4:	2303      	movs	r3, #3
 8006ed6:	75fb      	strb	r3, [r7, #23]
          }
          break;
 8006ed8:	e008      	b.n	8006eec <USBD_CDC_Setup+0x19c>

        case USB_REQ_CLEAR_FEATURE:
          break;

        default:
          USBD_CtlError(pdev, req);
 8006eda:	6839      	ldr	r1, [r7, #0]
 8006edc:	6878      	ldr	r0, [r7, #4]
 8006ede:	f001 fc92 	bl	8008806 <USBD_CtlError>
          ret = USBD_FAIL;
 8006ee2:	2303      	movs	r3, #3
 8006ee4:	75fb      	strb	r3, [r7, #23]
          break;
 8006ee6:	e002      	b.n	8006eee <USBD_CDC_Setup+0x19e>
          break;
 8006ee8:	bf00      	nop
 8006eea:	e008      	b.n	8006efe <USBD_CDC_Setup+0x1ae>
          break;
 8006eec:	bf00      	nop
      }
      break;
 8006eee:	e006      	b.n	8006efe <USBD_CDC_Setup+0x1ae>

    default:
      USBD_CtlError(pdev, req);
 8006ef0:	6839      	ldr	r1, [r7, #0]
 8006ef2:	6878      	ldr	r0, [r7, #4]
 8006ef4:	f001 fc87 	bl	8008806 <USBD_CtlError>
      ret = USBD_FAIL;
 8006ef8:	2303      	movs	r3, #3
 8006efa:	75fb      	strb	r3, [r7, #23]
      break;
 8006efc:	bf00      	nop
  }

  return (uint8_t)ret;
 8006efe:	7dfb      	ldrb	r3, [r7, #23]
}
 8006f00:	4618      	mov	r0, r3
 8006f02:	3718      	adds	r7, #24
 8006f04:	46bd      	mov	sp, r7
 8006f06:	bd80      	pop	{r7, pc}

08006f08 <USBD_CDC_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8006f08:	b580      	push	{r7, lr}
 8006f0a:	b084      	sub	sp, #16
 8006f0c:	af00      	add	r7, sp, #0
 8006f0e:	6078      	str	r0, [r7, #4]
 8006f10:	460b      	mov	r3, r1
 8006f12:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc;
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef *)pdev->pData;
 8006f14:	687b      	ldr	r3, [r7, #4]
 8006f16:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8006f1a:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8006f1c:	687b      	ldr	r3, [r7, #4]
 8006f1e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006f22:	687b      	ldr	r3, [r7, #4]
 8006f24:	32b0      	adds	r2, #176	@ 0xb0
 8006f26:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006f2a:	2b00      	cmp	r3, #0
 8006f2c:	d101      	bne.n	8006f32 <USBD_CDC_DataIn+0x2a>
  {
    return (uint8_t)USBD_FAIL;
 8006f2e:	2303      	movs	r3, #3
 8006f30:	e065      	b.n	8006ffe <USBD_CDC_DataIn+0xf6>
  }

  hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8006f32:	687b      	ldr	r3, [r7, #4]
 8006f34:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006f38:	687b      	ldr	r3, [r7, #4]
 8006f3a:	32b0      	adds	r2, #176	@ 0xb0
 8006f3c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006f40:	60bb      	str	r3, [r7, #8]

  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8006f42:	78fb      	ldrb	r3, [r7, #3]
 8006f44:	f003 020f 	and.w	r2, r3, #15
 8006f48:	6879      	ldr	r1, [r7, #4]
 8006f4a:	4613      	mov	r3, r2
 8006f4c:	009b      	lsls	r3, r3, #2
 8006f4e:	4413      	add	r3, r2
 8006f50:	009b      	lsls	r3, r3, #2
 8006f52:	440b      	add	r3, r1
 8006f54:	3318      	adds	r3, #24
 8006f56:	681b      	ldr	r3, [r3, #0]
 8006f58:	2b00      	cmp	r3, #0
 8006f5a:	d02f      	beq.n	8006fbc <USBD_CDC_DataIn+0xb4>
      ((pdev->ep_in[epnum & 0xFU].total_length % hpcd->IN_ep[epnum & 0xFU].maxpacket) == 0U))
 8006f5c:	78fb      	ldrb	r3, [r7, #3]
 8006f5e:	f003 020f 	and.w	r2, r3, #15
 8006f62:	6879      	ldr	r1, [r7, #4]
 8006f64:	4613      	mov	r3, r2
 8006f66:	009b      	lsls	r3, r3, #2
 8006f68:	4413      	add	r3, r2
 8006f6a:	009b      	lsls	r3, r3, #2
 8006f6c:	440b      	add	r3, r1
 8006f6e:	3318      	adds	r3, #24
 8006f70:	681a      	ldr	r2, [r3, #0]
 8006f72:	78fb      	ldrb	r3, [r7, #3]
 8006f74:	f003 010f 	and.w	r1, r3, #15
 8006f78:	68f8      	ldr	r0, [r7, #12]
 8006f7a:	460b      	mov	r3, r1
 8006f7c:	00db      	lsls	r3, r3, #3
 8006f7e:	440b      	add	r3, r1
 8006f80:	009b      	lsls	r3, r3, #2
 8006f82:	4403      	add	r3, r0
 8006f84:	331c      	adds	r3, #28
 8006f86:	681b      	ldr	r3, [r3, #0]
 8006f88:	fbb2 f1f3 	udiv	r1, r2, r3
 8006f8c:	fb01 f303 	mul.w	r3, r1, r3
 8006f90:	1ad3      	subs	r3, r2, r3
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8006f92:	2b00      	cmp	r3, #0
 8006f94:	d112      	bne.n	8006fbc <USBD_CDC_DataIn+0xb4>
  {
    /* Update the packet total length */
    pdev->ep_in[epnum & 0xFU].total_length = 0U;
 8006f96:	78fb      	ldrb	r3, [r7, #3]
 8006f98:	f003 020f 	and.w	r2, r3, #15
 8006f9c:	6879      	ldr	r1, [r7, #4]
 8006f9e:	4613      	mov	r3, r2
 8006fa0:	009b      	lsls	r3, r3, #2
 8006fa2:	4413      	add	r3, r2
 8006fa4:	009b      	lsls	r3, r3, #2
 8006fa6:	440b      	add	r3, r1
 8006fa8:	3318      	adds	r3, #24
 8006faa:	2200      	movs	r2, #0
 8006fac:	601a      	str	r2, [r3, #0]

    /* Send ZLP */
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 8006fae:	78f9      	ldrb	r1, [r7, #3]
 8006fb0:	2300      	movs	r3, #0
 8006fb2:	2200      	movs	r2, #0
 8006fb4:	6878      	ldr	r0, [r7, #4]
 8006fb6:	f021 fa46 	bl	8028446 <USBD_LL_Transmit>
 8006fba:	e01f      	b.n	8006ffc <USBD_CDC_DataIn+0xf4>
  }
  else
  {
    hcdc->TxState = 0U;
 8006fbc:	68bb      	ldr	r3, [r7, #8]
 8006fbe:	2200      	movs	r2, #0
 8006fc0:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214

    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 8006fc4:	687b      	ldr	r3, [r7, #4]
 8006fc6:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006fca:	687a      	ldr	r2, [r7, #4]
 8006fcc:	33b0      	adds	r3, #176	@ 0xb0
 8006fce:	009b      	lsls	r3, r3, #2
 8006fd0:	4413      	add	r3, r2
 8006fd2:	685b      	ldr	r3, [r3, #4]
 8006fd4:	691b      	ldr	r3, [r3, #16]
 8006fd6:	2b00      	cmp	r3, #0
 8006fd8:	d010      	beq.n	8006ffc <USBD_CDC_DataIn+0xf4>
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 8006fda:	687b      	ldr	r3, [r7, #4]
 8006fdc:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006fe0:	687a      	ldr	r2, [r7, #4]
 8006fe2:	33b0      	adds	r3, #176	@ 0xb0
 8006fe4:	009b      	lsls	r3, r3, #2
 8006fe6:	4413      	add	r3, r2
 8006fe8:	685b      	ldr	r3, [r3, #4]
 8006fea:	691b      	ldr	r3, [r3, #16]
 8006fec:	68ba      	ldr	r2, [r7, #8]
 8006fee:	f8d2 0208 	ldr.w	r0, [r2, #520]	@ 0x208
 8006ff2:	68ba      	ldr	r2, [r7, #8]
 8006ff4:	f502 7104 	add.w	r1, r2, #528	@ 0x210
 8006ff8:	78fa      	ldrb	r2, [r7, #3]
 8006ffa:	4798      	blx	r3
    }
  }

  return (uint8_t)USBD_OK;
 8006ffc:	2300      	movs	r3, #0
}
 8006ffe:	4618      	mov	r0, r3
 8007000:	3710      	adds	r7, #16
 8007002:	46bd      	mov	sp, r7
 8007004:	bd80      	pop	{r7, pc}

08007006 <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8007006:	b580      	push	{r7, lr}
 8007008:	b084      	sub	sp, #16
 800700a:	af00      	add	r7, sp, #0
 800700c:	6078      	str	r0, [r7, #4]
 800700e:	460b      	mov	r3, r1
 8007010:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8007012:	687b      	ldr	r3, [r7, #4]
 8007014:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007018:	687b      	ldr	r3, [r7, #4]
 800701a:	32b0      	adds	r2, #176	@ 0xb0
 800701c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007020:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8007022:	687b      	ldr	r3, [r7, #4]
 8007024:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007028:	687b      	ldr	r3, [r7, #4]
 800702a:	32b0      	adds	r2, #176	@ 0xb0
 800702c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007030:	2b00      	cmp	r3, #0
 8007032:	d101      	bne.n	8007038 <USBD_CDC_DataOut+0x32>
  {
    return (uint8_t)USBD_FAIL;
 8007034:	2303      	movs	r3, #3
 8007036:	e01a      	b.n	800706e <USBD_CDC_DataOut+0x68>
  }

  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8007038:	78fb      	ldrb	r3, [r7, #3]
 800703a:	4619      	mov	r1, r3
 800703c:	6878      	ldr	r0, [r7, #4]
 800703e:	f021 fa44 	bl	80284ca <USBD_LL_GetRxDataSize>
 8007042:	4602      	mov	r2, r0
 8007044:	68fb      	ldr	r3, [r7, #12]
 8007046:	f8c3 220c 	str.w	r2, [r3, #524]	@ 0x20c

  /* USB data will be immediately processed, this allow next USB traffic being
  NAKed till the end of the application Xfer */

  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 800704a:	687b      	ldr	r3, [r7, #4]
 800704c:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8007050:	687a      	ldr	r2, [r7, #4]
 8007052:	33b0      	adds	r3, #176	@ 0xb0
 8007054:	009b      	lsls	r3, r3, #2
 8007056:	4413      	add	r3, r2
 8007058:	685b      	ldr	r3, [r3, #4]
 800705a:	68db      	ldr	r3, [r3, #12]
 800705c:	68fa      	ldr	r2, [r7, #12]
 800705e:	f8d2 0204 	ldr.w	r0, [r2, #516]	@ 0x204
 8007062:	68fa      	ldr	r2, [r7, #12]
 8007064:	f502 7203 	add.w	r2, r2, #524	@ 0x20c
 8007068:	4611      	mov	r1, r2
 800706a:	4798      	blx	r3

  return (uint8_t)USBD_OK;
 800706c:	2300      	movs	r3, #0
}
 800706e:	4618      	mov	r0, r3
 8007070:	3710      	adds	r7, #16
 8007072:	46bd      	mov	sp, r7
 8007074:	bd80      	pop	{r7, pc}

08007076 <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 8007076:	b580      	push	{r7, lr}
 8007078:	b084      	sub	sp, #16
 800707a:	af00      	add	r7, sp, #0
 800707c:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 800707e:	687b      	ldr	r3, [r7, #4]
 8007080:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007084:	687b      	ldr	r3, [r7, #4]
 8007086:	32b0      	adds	r2, #176	@ 0xb0
 8007088:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800708c:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 800708e:	68fb      	ldr	r3, [r7, #12]
 8007090:	2b00      	cmp	r3, #0
 8007092:	d101      	bne.n	8007098 <USBD_CDC_EP0_RxReady+0x22>
  {
    return (uint8_t)USBD_FAIL;
 8007094:	2303      	movs	r3, #3
 8007096:	e024      	b.n	80070e2 <USBD_CDC_EP0_RxReady+0x6c>
  }

  if ((pdev->pUserData[pdev->classId] != NULL) && (hcdc->CmdOpCode != 0xFFU))
 8007098:	687b      	ldr	r3, [r7, #4]
 800709a:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 800709e:	687a      	ldr	r2, [r7, #4]
 80070a0:	33b0      	adds	r3, #176	@ 0xb0
 80070a2:	009b      	lsls	r3, r3, #2
 80070a4:	4413      	add	r3, r2
 80070a6:	685b      	ldr	r3, [r3, #4]
 80070a8:	2b00      	cmp	r3, #0
 80070aa:	d019      	beq.n	80070e0 <USBD_CDC_EP0_RxReady+0x6a>
 80070ac:	68fb      	ldr	r3, [r7, #12]
 80070ae:	f893 3200 	ldrb.w	r3, [r3, #512]	@ 0x200
 80070b2:	2bff      	cmp	r3, #255	@ 0xff
 80070b4:	d014      	beq.n	80070e0 <USBD_CDC_EP0_RxReady+0x6a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 80070b6:	687b      	ldr	r3, [r7, #4]
 80070b8:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 80070bc:	687a      	ldr	r2, [r7, #4]
 80070be:	33b0      	adds	r3, #176	@ 0xb0
 80070c0:	009b      	lsls	r3, r3, #2
 80070c2:	4413      	add	r3, r2
 80070c4:	685b      	ldr	r3, [r3, #4]
 80070c6:	689b      	ldr	r3, [r3, #8]
 80070c8:	68fa      	ldr	r2, [r7, #12]
 80070ca:	f892 0200 	ldrb.w	r0, [r2, #512]	@ 0x200
                                                                     (uint8_t *)hcdc->data,
 80070ce:	68f9      	ldr	r1, [r7, #12]
                                                                     (uint16_t)hcdc->CmdLength);
 80070d0:	68fa      	ldr	r2, [r7, #12]
 80070d2:	f892 2201 	ldrb.w	r2, [r2, #513]	@ 0x201
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 80070d6:	4798      	blx	r3
    hcdc->CmdOpCode = 0xFFU;
 80070d8:	68fb      	ldr	r3, [r7, #12]
 80070da:	22ff      	movs	r2, #255	@ 0xff
 80070dc:	f883 2200 	strb.w	r2, [r3, #512]	@ 0x200
  }

  return (uint8_t)USBD_OK;
 80070e0:	2300      	movs	r3, #0
}
 80070e2:	4618      	mov	r0, r3
 80070e4:	3710      	adds	r7, #16
 80070e6:	46bd      	mov	sp, r7
 80070e8:	bd80      	pop	{r7, pc}
	...

080070ec <USBD_CDC_GetFSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
 80070ec:	b580      	push	{r7, lr}
 80070ee:	b086      	sub	sp, #24
 80070f0:	af00      	add	r7, sp, #0
 80070f2:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 80070f4:	2182      	movs	r1, #130	@ 0x82
 80070f6:	4818      	ldr	r0, [pc, #96]	@ (8007158 <USBD_CDC_GetFSCfgDesc+0x6c>)
 80070f8:	f000 fd4f 	bl	8007b9a <USBD_GetEpDesc>
 80070fc:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 80070fe:	2101      	movs	r1, #1
 8007100:	4815      	ldr	r0, [pc, #84]	@ (8007158 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8007102:	f000 fd4a 	bl	8007b9a <USBD_GetEpDesc>
 8007106:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8007108:	2181      	movs	r1, #129	@ 0x81
 800710a:	4813      	ldr	r0, [pc, #76]	@ (8007158 <USBD_CDC_GetFSCfgDesc+0x6c>)
 800710c:	f000 fd45 	bl	8007b9a <USBD_GetEpDesc>
 8007110:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8007112:	697b      	ldr	r3, [r7, #20]
 8007114:	2b00      	cmp	r3, #0
 8007116:	d002      	beq.n	800711e <USBD_CDC_GetFSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8007118:	697b      	ldr	r3, [r7, #20]
 800711a:	2210      	movs	r2, #16
 800711c:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 800711e:	693b      	ldr	r3, [r7, #16]
 8007120:	2b00      	cmp	r3, #0
 8007122:	d006      	beq.n	8007132 <USBD_CDC_GetFSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8007124:	693b      	ldr	r3, [r7, #16]
 8007126:	2200      	movs	r2, #0
 8007128:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800712c:	711a      	strb	r2, [r3, #4]
 800712e:	2200      	movs	r2, #0
 8007130:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8007132:	68fb      	ldr	r3, [r7, #12]
 8007134:	2b00      	cmp	r3, #0
 8007136:	d006      	beq.n	8007146 <USBD_CDC_GetFSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8007138:	68fb      	ldr	r3, [r7, #12]
 800713a:	2200      	movs	r2, #0
 800713c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8007140:	711a      	strb	r2, [r3, #4]
 8007142:	2200      	movs	r2, #0
 8007144:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8007146:	687b      	ldr	r3, [r7, #4]
 8007148:	2243      	movs	r2, #67	@ 0x43
 800714a:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 800714c:	4b02      	ldr	r3, [pc, #8]	@ (8007158 <USBD_CDC_GetFSCfgDesc+0x6c>)
}
 800714e:	4618      	mov	r0, r3
 8007150:	3718      	adds	r7, #24
 8007152:	46bd      	mov	sp, r7
 8007154:	bd80      	pop	{r7, pc}
 8007156:	bf00      	nop
 8007158:	20000068 	.word	0x20000068

0800715c <USBD_CDC_GetHSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
 800715c:	b580      	push	{r7, lr}
 800715e:	b086      	sub	sp, #24
 8007160:	af00      	add	r7, sp, #0
 8007162:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8007164:	2182      	movs	r1, #130	@ 0x82
 8007166:	4818      	ldr	r0, [pc, #96]	@ (80071c8 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8007168:	f000 fd17 	bl	8007b9a <USBD_GetEpDesc>
 800716c:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 800716e:	2101      	movs	r1, #1
 8007170:	4815      	ldr	r0, [pc, #84]	@ (80071c8 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8007172:	f000 fd12 	bl	8007b9a <USBD_GetEpDesc>
 8007176:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8007178:	2181      	movs	r1, #129	@ 0x81
 800717a:	4813      	ldr	r0, [pc, #76]	@ (80071c8 <USBD_CDC_GetHSCfgDesc+0x6c>)
 800717c:	f000 fd0d 	bl	8007b9a <USBD_GetEpDesc>
 8007180:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8007182:	697b      	ldr	r3, [r7, #20]
 8007184:	2b00      	cmp	r3, #0
 8007186:	d002      	beq.n	800718e <USBD_CDC_GetHSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_HS_BINTERVAL;
 8007188:	697b      	ldr	r3, [r7, #20]
 800718a:	2210      	movs	r2, #16
 800718c:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 800718e:	693b      	ldr	r3, [r7, #16]
 8007190:	2b00      	cmp	r3, #0
 8007192:	d006      	beq.n	80071a2 <USBD_CDC_GetHSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8007194:	693b      	ldr	r3, [r7, #16]
 8007196:	2200      	movs	r2, #0
 8007198:	711a      	strb	r2, [r3, #4]
 800719a:	2200      	movs	r2, #0
 800719c:	f042 0202 	orr.w	r2, r2, #2
 80071a0:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 80071a2:	68fb      	ldr	r3, [r7, #12]
 80071a4:	2b00      	cmp	r3, #0
 80071a6:	d006      	beq.n	80071b6 <USBD_CDC_GetHSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 80071a8:	68fb      	ldr	r3, [r7, #12]
 80071aa:	2200      	movs	r2, #0
 80071ac:	711a      	strb	r2, [r3, #4]
 80071ae:	2200      	movs	r2, #0
 80071b0:	f042 0202 	orr.w	r2, r2, #2
 80071b4:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 80071b6:	687b      	ldr	r3, [r7, #4]
 80071b8:	2243      	movs	r2, #67	@ 0x43
 80071ba:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 80071bc:	4b02      	ldr	r3, [pc, #8]	@ (80071c8 <USBD_CDC_GetHSCfgDesc+0x6c>)
}
 80071be:	4618      	mov	r0, r3
 80071c0:	3718      	adds	r7, #24
 80071c2:	46bd      	mov	sp, r7
 80071c4:	bd80      	pop	{r7, pc}
 80071c6:	bf00      	nop
 80071c8:	20000068 	.word	0x20000068

080071cc <USBD_CDC_GetOtherSpeedCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
 80071cc:	b580      	push	{r7, lr}
 80071ce:	b086      	sub	sp, #24
 80071d0:	af00      	add	r7, sp, #0
 80071d2:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 80071d4:	2182      	movs	r1, #130	@ 0x82
 80071d6:	4818      	ldr	r0, [pc, #96]	@ (8007238 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 80071d8:	f000 fcdf 	bl	8007b9a <USBD_GetEpDesc>
 80071dc:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 80071de:	2101      	movs	r1, #1
 80071e0:	4815      	ldr	r0, [pc, #84]	@ (8007238 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 80071e2:	f000 fcda 	bl	8007b9a <USBD_GetEpDesc>
 80071e6:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 80071e8:	2181      	movs	r1, #129	@ 0x81
 80071ea:	4813      	ldr	r0, [pc, #76]	@ (8007238 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 80071ec:	f000 fcd5 	bl	8007b9a <USBD_GetEpDesc>
 80071f0:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 80071f2:	697b      	ldr	r3, [r7, #20]
 80071f4:	2b00      	cmp	r3, #0
 80071f6:	d002      	beq.n	80071fe <USBD_CDC_GetOtherSpeedCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 80071f8:	697b      	ldr	r3, [r7, #20]
 80071fa:	2210      	movs	r2, #16
 80071fc:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 80071fe:	693b      	ldr	r3, [r7, #16]
 8007200:	2b00      	cmp	r3, #0
 8007202:	d006      	beq.n	8007212 <USBD_CDC_GetOtherSpeedCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8007204:	693b      	ldr	r3, [r7, #16]
 8007206:	2200      	movs	r2, #0
 8007208:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800720c:	711a      	strb	r2, [r3, #4]
 800720e:	2200      	movs	r2, #0
 8007210:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8007212:	68fb      	ldr	r3, [r7, #12]
 8007214:	2b00      	cmp	r3, #0
 8007216:	d006      	beq.n	8007226 <USBD_CDC_GetOtherSpeedCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8007218:	68fb      	ldr	r3, [r7, #12]
 800721a:	2200      	movs	r2, #0
 800721c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8007220:	711a      	strb	r2, [r3, #4]
 8007222:	2200      	movs	r2, #0
 8007224:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8007226:	687b      	ldr	r3, [r7, #4]
 8007228:	2243      	movs	r2, #67	@ 0x43
 800722a:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 800722c:	4b02      	ldr	r3, [pc, #8]	@ (8007238 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
}
 800722e:	4618      	mov	r0, r3
 8007230:	3718      	adds	r7, #24
 8007232:	46bd      	mov	sp, r7
 8007234:	bd80      	pop	{r7, pc}
 8007236:	bf00      	nop
 8007238:	20000068 	.word	0x20000068

0800723c <USBD_CDC_GetDeviceQualifierDescriptor>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 800723c:	b480      	push	{r7}
 800723e:	b083      	sub	sp, #12
 8007240:	af00      	add	r7, sp, #0
 8007242:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 8007244:	687b      	ldr	r3, [r7, #4]
 8007246:	220a      	movs	r2, #10
 8007248:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_DeviceQualifierDesc;
 800724a:	4b03      	ldr	r3, [pc, #12]	@ (8007258 <USBD_CDC_GetDeviceQualifierDescriptor+0x1c>)
}
 800724c:	4618      	mov	r0, r3
 800724e:	370c      	adds	r7, #12
 8007250:	46bd      	mov	sp, r7
 8007252:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007256:	4770      	bx	lr
 8007258:	20000024 	.word	0x20000024

0800725c <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
 800725c:	b480      	push	{r7}
 800725e:	b083      	sub	sp, #12
 8007260:	af00      	add	r7, sp, #0
 8007262:	6078      	str	r0, [r7, #4]
 8007264:	6039      	str	r1, [r7, #0]
  if (fops == NULL)
 8007266:	683b      	ldr	r3, [r7, #0]
 8007268:	2b00      	cmp	r3, #0
 800726a:	d101      	bne.n	8007270 <USBD_CDC_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
 800726c:	2303      	movs	r3, #3
 800726e:	e009      	b.n	8007284 <USBD_CDC_RegisterInterface+0x28>
  }

  pdev->pUserData[pdev->classId] = fops;
 8007270:	687b      	ldr	r3, [r7, #4]
 8007272:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8007276:	687a      	ldr	r2, [r7, #4]
 8007278:	33b0      	adds	r3, #176	@ 0xb0
 800727a:	009b      	lsls	r3, r3, #2
 800727c:	4413      	add	r3, r2
 800727e:	683a      	ldr	r2, [r7, #0]
 8007280:	605a      	str	r2, [r3, #4]

  return (uint8_t)USBD_OK;
 8007282:	2300      	movs	r3, #0
}
 8007284:	4618      	mov	r0, r3
 8007286:	370c      	adds	r7, #12
 8007288:	46bd      	mov	sp, r7
 800728a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800728e:	4770      	bx	lr

08007290 <USBD_CDC_SetTxBuffer>:
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
 8007290:	b480      	push	{r7}
 8007292:	b087      	sub	sp, #28
 8007294:	af00      	add	r7, sp, #0
 8007296:	60f8      	str	r0, [r7, #12]
 8007298:	60b9      	str	r1, [r7, #8]
 800729a:	607a      	str	r2, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 800729c:	68fb      	ldr	r3, [r7, #12]
 800729e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80072a2:	68fb      	ldr	r3, [r7, #12]
 80072a4:	32b0      	adds	r2, #176	@ 0xb0
 80072a6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80072aa:	617b      	str	r3, [r7, #20]
#endif /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 80072ac:	697b      	ldr	r3, [r7, #20]
 80072ae:	2b00      	cmp	r3, #0
 80072b0:	d101      	bne.n	80072b6 <USBD_CDC_SetTxBuffer+0x26>
  {
    return (uint8_t)USBD_FAIL;
 80072b2:	2303      	movs	r3, #3
 80072b4:	e008      	b.n	80072c8 <USBD_CDC_SetTxBuffer+0x38>
  }

  hcdc->TxBuffer = pbuff;
 80072b6:	697b      	ldr	r3, [r7, #20]
 80072b8:	68ba      	ldr	r2, [r7, #8]
 80072ba:	f8c3 2208 	str.w	r2, [r3, #520]	@ 0x208
  hcdc->TxLength = length;
 80072be:	697b      	ldr	r3, [r7, #20]
 80072c0:	687a      	ldr	r2, [r7, #4]
 80072c2:	f8c3 2210 	str.w	r2, [r3, #528]	@ 0x210

  return (uint8_t)USBD_OK;
 80072c6:	2300      	movs	r3, #0
}
 80072c8:	4618      	mov	r0, r3
 80072ca:	371c      	adds	r7, #28
 80072cc:	46bd      	mov	sp, r7
 80072ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80072d2:	4770      	bx	lr

080072d4 <USBD_CDC_SetRxBuffer>:
  * @param  pdev: device instance
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
 80072d4:	b480      	push	{r7}
 80072d6:	b085      	sub	sp, #20
 80072d8:	af00      	add	r7, sp, #0
 80072da:	6078      	str	r0, [r7, #4]
 80072dc:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 80072de:	687b      	ldr	r3, [r7, #4]
 80072e0:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80072e4:	687b      	ldr	r3, [r7, #4]
 80072e6:	32b0      	adds	r2, #176	@ 0xb0
 80072e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80072ec:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 80072ee:	68fb      	ldr	r3, [r7, #12]
 80072f0:	2b00      	cmp	r3, #0
 80072f2:	d101      	bne.n	80072f8 <USBD_CDC_SetRxBuffer+0x24>
  {
    return (uint8_t)USBD_FAIL;
 80072f4:	2303      	movs	r3, #3
 80072f6:	e004      	b.n	8007302 <USBD_CDC_SetRxBuffer+0x2e>
  }

  hcdc->RxBuffer = pbuff;
 80072f8:	68fb      	ldr	r3, [r7, #12]
 80072fa:	683a      	ldr	r2, [r7, #0]
 80072fc:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204

  return (uint8_t)USBD_OK;
 8007300:	2300      	movs	r3, #0
}
 8007302:	4618      	mov	r0, r3
 8007304:	3714      	adds	r7, #20
 8007306:	46bd      	mov	sp, r7
 8007308:	f85d 7b04 	ldr.w	r7, [sp], #4
 800730c:	4770      	bx	lr
	...

08007310 <USBD_CDC_TransmitPacket>:
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev, uint8_t ClassId)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
 8007310:	b580      	push	{r7, lr}
 8007312:	b084      	sub	sp, #16
 8007314:	af00      	add	r7, sp, #0
 8007316:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8007318:	687b      	ldr	r3, [r7, #4]
 800731a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800731e:	687b      	ldr	r3, [r7, #4]
 8007320:	32b0      	adds	r2, #176	@ 0xb0
 8007322:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007326:	60bb      	str	r3, [r7, #8]
#endif  /* USE_USBD_COMPOSITE */

  USBD_StatusTypeDef ret = USBD_BUSY;
 8007328:	2301      	movs	r3, #1
 800732a:	73fb      	strb	r3, [r7, #15]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, ClassId);
#endif  /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 800732c:	68bb      	ldr	r3, [r7, #8]
 800732e:	2b00      	cmp	r3, #0
 8007330:	d101      	bne.n	8007336 <USBD_CDC_TransmitPacket+0x26>
  {
    return (uint8_t)USBD_FAIL;
 8007332:	2303      	movs	r3, #3
 8007334:	e025      	b.n	8007382 <USBD_CDC_TransmitPacket+0x72>
  }

  if (hcdc->TxState == 0U)
 8007336:	68bb      	ldr	r3, [r7, #8]
 8007338:	f8d3 3214 	ldr.w	r3, [r3, #532]	@ 0x214
 800733c:	2b00      	cmp	r3, #0
 800733e:	d11f      	bne.n	8007380 <USBD_CDC_TransmitPacket+0x70>
  {
    /* Tx Transfer in progress */
    hcdc->TxState = 1U;
 8007340:	68bb      	ldr	r3, [r7, #8]
 8007342:	2201      	movs	r2, #1
 8007344:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214

    /* Update the packet total length */
    pdev->ep_in[CDCInEpAdd & 0xFU].total_length = hcdc->TxLength;
 8007348:	4b10      	ldr	r3, [pc, #64]	@ (800738c <USBD_CDC_TransmitPacket+0x7c>)
 800734a:	781b      	ldrb	r3, [r3, #0]
 800734c:	f003 020f 	and.w	r2, r3, #15
 8007350:	68bb      	ldr	r3, [r7, #8]
 8007352:	f8d3 1210 	ldr.w	r1, [r3, #528]	@ 0x210
 8007356:	6878      	ldr	r0, [r7, #4]
 8007358:	4613      	mov	r3, r2
 800735a:	009b      	lsls	r3, r3, #2
 800735c:	4413      	add	r3, r2
 800735e:	009b      	lsls	r3, r3, #2
 8007360:	4403      	add	r3, r0
 8007362:	3318      	adds	r3, #24
 8007364:	6019      	str	r1, [r3, #0]

    /* Transmit next packet */
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 8007366:	4b09      	ldr	r3, [pc, #36]	@ (800738c <USBD_CDC_TransmitPacket+0x7c>)
 8007368:	7819      	ldrb	r1, [r3, #0]
 800736a:	68bb      	ldr	r3, [r7, #8]
 800736c:	f8d3 2208 	ldr.w	r2, [r3, #520]	@ 0x208
 8007370:	68bb      	ldr	r3, [r7, #8]
 8007372:	f8d3 3210 	ldr.w	r3, [r3, #528]	@ 0x210
 8007376:	6878      	ldr	r0, [r7, #4]
 8007378:	f021 f865 	bl	8028446 <USBD_LL_Transmit>

    ret = USBD_OK;
 800737c:	2300      	movs	r3, #0
 800737e:	73fb      	strb	r3, [r7, #15]
  }

  return (uint8_t)ret;
 8007380:	7bfb      	ldrb	r3, [r7, #15]
}
 8007382:	4618      	mov	r0, r3
 8007384:	3710      	adds	r7, #16
 8007386:	46bd      	mov	sp, r7
 8007388:	bd80      	pop	{r7, pc}
 800738a:	bf00      	nop
 800738c:	200000ab 	.word	0x200000ab

08007390 <USBD_CDC_ReceivePacket>:
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
 8007390:	b580      	push	{r7, lr}
 8007392:	b084      	sub	sp, #16
 8007394:	af00      	add	r7, sp, #0
 8007396:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8007398:	687b      	ldr	r3, [r7, #4]
 800739a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800739e:	687b      	ldr	r3, [r7, #4]
 80073a0:	32b0      	adds	r2, #176	@ 0xb0
 80073a2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80073a6:	60fb      	str	r3, [r7, #12]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 80073a8:	687b      	ldr	r3, [r7, #4]
 80073aa:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80073ae:	687b      	ldr	r3, [r7, #4]
 80073b0:	32b0      	adds	r2, #176	@ 0xb0
 80073b2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80073b6:	2b00      	cmp	r3, #0
 80073b8:	d101      	bne.n	80073be <USBD_CDC_ReceivePacket+0x2e>
  {
    return (uint8_t)USBD_FAIL;
 80073ba:	2303      	movs	r3, #3
 80073bc:	e018      	b.n	80073f0 <USBD_CDC_ReceivePacket+0x60>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 80073be:	687b      	ldr	r3, [r7, #4]
 80073c0:	7c1b      	ldrb	r3, [r3, #16]
 80073c2:	2b00      	cmp	r3, #0
 80073c4:	d10a      	bne.n	80073dc <USBD_CDC_ReceivePacket+0x4c>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 80073c6:	4b0c      	ldr	r3, [pc, #48]	@ (80073f8 <USBD_CDC_ReceivePacket+0x68>)
 80073c8:	7819      	ldrb	r1, [r3, #0]
 80073ca:	68fb      	ldr	r3, [r7, #12]
 80073cc:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 80073d0:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80073d4:	6878      	ldr	r0, [r7, #4]
 80073d6:	f021 f857 	bl	8028488 <USBD_LL_PrepareReceive>
 80073da:	e008      	b.n	80073ee <USBD_CDC_ReceivePacket+0x5e>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 80073dc:	4b06      	ldr	r3, [pc, #24]	@ (80073f8 <USBD_CDC_ReceivePacket+0x68>)
 80073de:	7819      	ldrb	r1, [r3, #0]
 80073e0:	68fb      	ldr	r3, [r7, #12]
 80073e2:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 80073e6:	2340      	movs	r3, #64	@ 0x40
 80073e8:	6878      	ldr	r0, [r7, #4]
 80073ea:	f021 f84d 	bl	8028488 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 80073ee:	2300      	movs	r3, #0
}
 80073f0:	4618      	mov	r0, r3
 80073f2:	3710      	adds	r7, #16
 80073f4:	46bd      	mov	sp, r7
 80073f6:	bd80      	pop	{r7, pc}
 80073f8:	200000ac 	.word	0x200000ac

080073fc <USBD_Init>:
  * @param  id: Low level core index
  * @retval status: USBD Status
  */
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 80073fc:	b580      	push	{r7, lr}
 80073fe:	b086      	sub	sp, #24
 8007400:	af00      	add	r7, sp, #0
 8007402:	60f8      	str	r0, [r7, #12]
 8007404:	60b9      	str	r1, [r7, #8]
 8007406:	4613      	mov	r3, r2
 8007408:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 800740a:	68fb      	ldr	r3, [r7, #12]
 800740c:	2b00      	cmp	r3, #0
 800740e:	d101      	bne.n	8007414 <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 8007410:	2303      	movs	r3, #3
 8007412:	e01f      	b.n	8007454 <USBD_Init+0x58>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 8007414:	68fb      	ldr	r3, [r7, #12]
 8007416:	2200      	movs	r2, #0
 8007418:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  pdev->pUserData[0] = NULL;
 800741c:	68fb      	ldr	r3, [r7, #12]
 800741e:	2200      	movs	r2, #0
 8007420:	f8c3 22c4 	str.w	r2, [r3, #708]	@ 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 8007424:	68fb      	ldr	r3, [r7, #12]
 8007426:	2200      	movs	r2, #0
 8007428:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 800742c:	68bb      	ldr	r3, [r7, #8]
 800742e:	2b00      	cmp	r3, #0
 8007430:	d003      	beq.n	800743a <USBD_Init+0x3e>
  {
    pdev->pDesc = pdesc;
 8007432:	68fb      	ldr	r3, [r7, #12]
 8007434:	68ba      	ldr	r2, [r7, #8]
 8007436:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800743a:	68fb      	ldr	r3, [r7, #12]
 800743c:	2201      	movs	r2, #1
 800743e:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->id = id;
 8007442:	68fb      	ldr	r3, [r7, #12]
 8007444:	79fa      	ldrb	r2, [r7, #7]
 8007446:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 8007448:	68f8      	ldr	r0, [r7, #12]
 800744a:	f020 fec7 	bl	80281dc <USBD_LL_Init>
 800744e:	4603      	mov	r3, r0
 8007450:	75fb      	strb	r3, [r7, #23]

  return ret;
 8007452:	7dfb      	ldrb	r3, [r7, #23]
}
 8007454:	4618      	mov	r0, r3
 8007456:	3718      	adds	r7, #24
 8007458:	46bd      	mov	sp, r7
 800745a:	bd80      	pop	{r7, pc}

0800745c <USBD_RegisterClass>:
  * @param  pdev: Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 800745c:	b580      	push	{r7, lr}
 800745e:	b084      	sub	sp, #16
 8007460:	af00      	add	r7, sp, #0
 8007462:	6078      	str	r0, [r7, #4]
 8007464:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8007466:	2300      	movs	r3, #0
 8007468:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
 800746a:	683b      	ldr	r3, [r7, #0]
 800746c:	2b00      	cmp	r3, #0
 800746e:	d101      	bne.n	8007474 <USBD_RegisterClass+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 8007470:	2303      	movs	r3, #3
 8007472:	e025      	b.n	80074c0 <USBD_RegisterClass+0x64>
  }

  /* link the class to the USB Device handle */
  pdev->pClass[0] = pclass;
 8007474:	687b      	ldr	r3, [r7, #4]
 8007476:	683a      	ldr	r2, [r7, #0]
 8007478:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 800747c:	687b      	ldr	r3, [r7, #4]
 800747e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007482:	687b      	ldr	r3, [r7, #4]
 8007484:	32ae      	adds	r2, #174	@ 0xae
 8007486:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800748a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800748c:	2b00      	cmp	r3, #0
 800748e:	d00f      	beq.n	80074b0 <USBD_RegisterClass+0x54>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 8007490:	687b      	ldr	r3, [r7, #4]
 8007492:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007496:	687b      	ldr	r3, [r7, #4]
 8007498:	32ae      	adds	r2, #174	@ 0xae
 800749a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800749e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80074a0:	f107 020e 	add.w	r2, r7, #14
 80074a4:	4610      	mov	r0, r2
 80074a6:	4798      	blx	r3
 80074a8:	4602      	mov	r2, r0
 80074aa:	687b      	ldr	r3, [r7, #4]
 80074ac:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses++;
 80074b0:	687b      	ldr	r3, [r7, #4]
 80074b2:	f8d3 32d8 	ldr.w	r3, [r3, #728]	@ 0x2d8
 80074b6:	1c5a      	adds	r2, r3, #1
 80074b8:	687b      	ldr	r3, [r7, #4]
 80074ba:	f8c3 22d8 	str.w	r2, [r3, #728]	@ 0x2d8

  return USBD_OK;
 80074be:	2300      	movs	r3, #0
}
 80074c0:	4618      	mov	r0, r3
 80074c2:	3710      	adds	r7, #16
 80074c4:	46bd      	mov	sp, r7
 80074c6:	bd80      	pop	{r7, pc}

080074c8 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 80074c8:	b580      	push	{r7, lr}
 80074ca:	b082      	sub	sp, #8
 80074cc:	af00      	add	r7, sp, #0
 80074ce:	6078      	str	r0, [r7, #4]
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 80074d0:	6878      	ldr	r0, [r7, #4]
 80074d2:	f020 fecf 	bl	8028274 <USBD_LL_Start>
 80074d6:	4603      	mov	r3, r0
}
 80074d8:	4618      	mov	r0, r3
 80074da:	3708      	adds	r7, #8
 80074dc:	46bd      	mov	sp, r7
 80074de:	bd80      	pop	{r7, pc}

080074e0 <USBD_RunTestMode>:
  *         Launch test mode process
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef *pdev)
{
 80074e0:	b480      	push	{r7}
 80074e2:	b083      	sub	sp, #12
 80074e4:	af00      	add	r7, sp, #0
 80074e6:	6078      	str	r0, [r7, #4]
  return ret;
#else
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 80074e8:	2300      	movs	r3, #0
#endif /* USBD_HS_TESTMODE_ENABLE */
}
 80074ea:	4618      	mov	r0, r3
 80074ec:	370c      	adds	r7, #12
 80074ee:	46bd      	mov	sp, r7
 80074f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80074f4:	4770      	bx	lr

080074f6 <USBD_SetClassConfig>:
  * @param  cfgidx: configuration index
  * @retval status
  */

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80074f6:	b580      	push	{r7, lr}
 80074f8:	b084      	sub	sp, #16
 80074fa:	af00      	add	r7, sp, #0
 80074fc:	6078      	str	r0, [r7, #4]
 80074fe:	460b      	mov	r3, r1
 8007500:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 8007502:	2300      	movs	r3, #0
 8007504:	73fb      	strb	r3, [r7, #15]
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 8007506:	687b      	ldr	r3, [r7, #4]
 8007508:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 800750c:	2b00      	cmp	r3, #0
 800750e:	d009      	beq.n	8007524 <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 8007510:	687b      	ldr	r3, [r7, #4]
 8007512:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007516:	681b      	ldr	r3, [r3, #0]
 8007518:	78fa      	ldrb	r2, [r7, #3]
 800751a:	4611      	mov	r1, r2
 800751c:	6878      	ldr	r0, [r7, #4]
 800751e:	4798      	blx	r3
 8007520:	4603      	mov	r3, r0
 8007522:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 8007524:	7bfb      	ldrb	r3, [r7, #15]
}
 8007526:	4618      	mov	r0, r3
 8007528:	3710      	adds	r7, #16
 800752a:	46bd      	mov	sp, r7
 800752c:	bd80      	pop	{r7, pc}

0800752e <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 800752e:	b580      	push	{r7, lr}
 8007530:	b084      	sub	sp, #16
 8007532:	af00      	add	r7, sp, #0
 8007534:	6078      	str	r0, [r7, #4]
 8007536:	460b      	mov	r3, r1
 8007538:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 800753a:	2300      	movs	r3, #0
 800753c:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 800753e:	687b      	ldr	r3, [r7, #4]
 8007540:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007544:	685b      	ldr	r3, [r3, #4]
 8007546:	78fa      	ldrb	r2, [r7, #3]
 8007548:	4611      	mov	r1, r2
 800754a:	6878      	ldr	r0, [r7, #4]
 800754c:	4798      	blx	r3
 800754e:	4603      	mov	r3, r0
 8007550:	2b00      	cmp	r3, #0
 8007552:	d001      	beq.n	8007558 <USBD_ClrClassConfig+0x2a>
  {
    ret = USBD_FAIL;
 8007554:	2303      	movs	r3, #3
 8007556:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 8007558:	7bfb      	ldrb	r3, [r7, #15]
}
 800755a:	4618      	mov	r0, r3
 800755c:	3710      	adds	r7, #16
 800755e:	46bd      	mov	sp, r7
 8007560:	bd80      	pop	{r7, pc}

08007562 <USBD_LL_SetupStage>:
  * @param  pdev: device instance
  * @param  psetup: setup packet buffer pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8007562:	b580      	push	{r7, lr}
 8007564:	b084      	sub	sp, #16
 8007566:	af00      	add	r7, sp, #0
 8007568:	6078      	str	r0, [r7, #4]
 800756a:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 800756c:	687b      	ldr	r3, [r7, #4]
 800756e:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 8007572:	6839      	ldr	r1, [r7, #0]
 8007574:	4618      	mov	r0, r3
 8007576:	f001 f90c 	bl	8008792 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 800757a:	687b      	ldr	r3, [r7, #4]
 800757c:	2201      	movs	r2, #1
 800757e:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 8007582:	687b      	ldr	r3, [r7, #4]
 8007584:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	@ 0x2b0
 8007588:	461a      	mov	r2, r3
 800758a:	687b      	ldr	r3, [r7, #4]
 800758c:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 8007590:	687b      	ldr	r3, [r7, #4]
 8007592:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 8007596:	f003 031f 	and.w	r3, r3, #31
 800759a:	2b02      	cmp	r3, #2
 800759c:	d01a      	beq.n	80075d4 <USBD_LL_SetupStage+0x72>
 800759e:	2b02      	cmp	r3, #2
 80075a0:	d822      	bhi.n	80075e8 <USBD_LL_SetupStage+0x86>
 80075a2:	2b00      	cmp	r3, #0
 80075a4:	d002      	beq.n	80075ac <USBD_LL_SetupStage+0x4a>
 80075a6:	2b01      	cmp	r3, #1
 80075a8:	d00a      	beq.n	80075c0 <USBD_LL_SetupStage+0x5e>
 80075aa:	e01d      	b.n	80075e8 <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 80075ac:	687b      	ldr	r3, [r7, #4]
 80075ae:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 80075b2:	4619      	mov	r1, r3
 80075b4:	6878      	ldr	r0, [r7, #4]
 80075b6:	f000 fb63 	bl	8007c80 <USBD_StdDevReq>
 80075ba:	4603      	mov	r3, r0
 80075bc:	73fb      	strb	r3, [r7, #15]
      break;
 80075be:	e020      	b.n	8007602 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
 80075c0:	687b      	ldr	r3, [r7, #4]
 80075c2:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 80075c6:	4619      	mov	r1, r3
 80075c8:	6878      	ldr	r0, [r7, #4]
 80075ca:	f000 fbcb 	bl	8007d64 <USBD_StdItfReq>
 80075ce:	4603      	mov	r3, r0
 80075d0:	73fb      	strb	r3, [r7, #15]
      break;
 80075d2:	e016      	b.n	8007602 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
 80075d4:	687b      	ldr	r3, [r7, #4]
 80075d6:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 80075da:	4619      	mov	r1, r3
 80075dc:	6878      	ldr	r0, [r7, #4]
 80075de:	f000 fc2d 	bl	8007e3c <USBD_StdEPReq>
 80075e2:	4603      	mov	r3, r0
 80075e4:	73fb      	strb	r3, [r7, #15]
      break;
 80075e6:	e00c      	b.n	8007602 <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 80075e8:	687b      	ldr	r3, [r7, #4]
 80075ea:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 80075ee:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 80075f2:	b2db      	uxtb	r3, r3
 80075f4:	4619      	mov	r1, r3
 80075f6:	6878      	ldr	r0, [r7, #4]
 80075f8:	f020 fe9c 	bl	8028334 <USBD_LL_StallEP>
 80075fc:	4603      	mov	r3, r0
 80075fe:	73fb      	strb	r3, [r7, #15]
      break;
 8007600:	bf00      	nop
  }

  return ret;
 8007602:	7bfb      	ldrb	r3, [r7, #15]
}
 8007604:	4618      	mov	r0, r3
 8007606:	3710      	adds	r7, #16
 8007608:	46bd      	mov	sp, r7
 800760a:	bd80      	pop	{r7, pc}

0800760c <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 800760c:	b580      	push	{r7, lr}
 800760e:	b086      	sub	sp, #24
 8007610:	af00      	add	r7, sp, #0
 8007612:	60f8      	str	r0, [r7, #12]
 8007614:	460b      	mov	r3, r1
 8007616:	607a      	str	r2, [r7, #4]
 8007618:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
 800761a:	2300      	movs	r3, #0
 800761c:	75fb      	strb	r3, [r7, #23]
  uint8_t idx;

  if (epnum == 0U)
 800761e:	7afb      	ldrb	r3, [r7, #11]
 8007620:	2b00      	cmp	r3, #0
 8007622:	d16e      	bne.n	8007702 <USBD_LL_DataOutStage+0xf6>
  {
    pep = &pdev->ep_out[0];
 8007624:	68fb      	ldr	r3, [r7, #12]
 8007626:	f503 73aa 	add.w	r3, r3, #340	@ 0x154
 800762a:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 800762c:	68fb      	ldr	r3, [r7, #12]
 800762e:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 8007632:	2b03      	cmp	r3, #3
 8007634:	f040 8098 	bne.w	8007768 <USBD_LL_DataOutStage+0x15c>
    {
      if (pep->rem_length > pep->maxpacket)
 8007638:	693b      	ldr	r3, [r7, #16]
 800763a:	689a      	ldr	r2, [r3, #8]
 800763c:	693b      	ldr	r3, [r7, #16]
 800763e:	68db      	ldr	r3, [r3, #12]
 8007640:	429a      	cmp	r2, r3
 8007642:	d913      	bls.n	800766c <USBD_LL_DataOutStage+0x60>
      {
        pep->rem_length -= pep->maxpacket;
 8007644:	693b      	ldr	r3, [r7, #16]
 8007646:	689a      	ldr	r2, [r3, #8]
 8007648:	693b      	ldr	r3, [r7, #16]
 800764a:	68db      	ldr	r3, [r3, #12]
 800764c:	1ad2      	subs	r2, r2, r3
 800764e:	693b      	ldr	r3, [r7, #16]
 8007650:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 8007652:	693b      	ldr	r3, [r7, #16]
 8007654:	68da      	ldr	r2, [r3, #12]
 8007656:	693b      	ldr	r3, [r7, #16]
 8007658:	689b      	ldr	r3, [r3, #8]
 800765a:	4293      	cmp	r3, r2
 800765c:	bf28      	it	cs
 800765e:	4613      	movcs	r3, r2
 8007660:	461a      	mov	r2, r3
 8007662:	6879      	ldr	r1, [r7, #4]
 8007664:	68f8      	ldr	r0, [r7, #12]
 8007666:	f001 f994 	bl	8008992 <USBD_CtlContinueRx>
 800766a:	e07d      	b.n	8007768 <USBD_LL_DataOutStage+0x15c>
      }
      else
      {
        /* Find the class ID relative to the current request */
        switch (pdev->request.bmRequest & 0x1FU)
 800766c:	68fb      	ldr	r3, [r7, #12]
 800766e:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 8007672:	f003 031f 	and.w	r3, r3, #31
 8007676:	2b02      	cmp	r3, #2
 8007678:	d014      	beq.n	80076a4 <USBD_LL_DataOutStage+0x98>
 800767a:	2b02      	cmp	r3, #2
 800767c:	d81d      	bhi.n	80076ba <USBD_LL_DataOutStage+0xae>
 800767e:	2b00      	cmp	r3, #0
 8007680:	d002      	beq.n	8007688 <USBD_LL_DataOutStage+0x7c>
 8007682:	2b01      	cmp	r3, #1
 8007684:	d003      	beq.n	800768e <USBD_LL_DataOutStage+0x82>
 8007686:	e018      	b.n	80076ba <USBD_LL_DataOutStage+0xae>
        {
          case USB_REQ_RECIPIENT_DEVICE:
            /* Device requests must be managed by the first instantiated class
               (or duplicated by all classes for simplicity) */
            idx = 0U;
 8007688:	2300      	movs	r3, #0
 800768a:	75bb      	strb	r3, [r7, #22]
            break;
 800768c:	e018      	b.n	80076c0 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_INTERFACE:
            idx = USBD_CoreFindIF(pdev, LOBYTE(pdev->request.wIndex));
 800768e:	68fb      	ldr	r3, [r7, #12]
 8007690:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 8007694:	b2db      	uxtb	r3, r3
 8007696:	4619      	mov	r1, r3
 8007698:	68f8      	ldr	r0, [r7, #12]
 800769a:	f000 fa64 	bl	8007b66 <USBD_CoreFindIF>
 800769e:	4603      	mov	r3, r0
 80076a0:	75bb      	strb	r3, [r7, #22]
            break;
 80076a2:	e00d      	b.n	80076c0 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_ENDPOINT:
            idx = USBD_CoreFindEP(pdev, LOBYTE(pdev->request.wIndex));
 80076a4:	68fb      	ldr	r3, [r7, #12]
 80076a6:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 80076aa:	b2db      	uxtb	r3, r3
 80076ac:	4619      	mov	r1, r3
 80076ae:	68f8      	ldr	r0, [r7, #12]
 80076b0:	f000 fa66 	bl	8007b80 <USBD_CoreFindEP>
 80076b4:	4603      	mov	r3, r0
 80076b6:	75bb      	strb	r3, [r7, #22]
            break;
 80076b8:	e002      	b.n	80076c0 <USBD_LL_DataOutStage+0xb4>

          default:
            /* Back to the first class in case of doubt */
            idx = 0U;
 80076ba:	2300      	movs	r3, #0
 80076bc:	75bb      	strb	r3, [r7, #22]
            break;
 80076be:	bf00      	nop
        }

        if (idx < USBD_MAX_SUPPORTED_CLASS)
 80076c0:	7dbb      	ldrb	r3, [r7, #22]
 80076c2:	2b00      	cmp	r3, #0
 80076c4:	d119      	bne.n	80076fa <USBD_LL_DataOutStage+0xee>
        {
          /* Setup the class ID and route the request to the relative class function */
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80076c6:	68fb      	ldr	r3, [r7, #12]
 80076c8:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80076cc:	b2db      	uxtb	r3, r3
 80076ce:	2b03      	cmp	r3, #3
 80076d0:	d113      	bne.n	80076fa <USBD_LL_DataOutStage+0xee>
          {
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 80076d2:	7dba      	ldrb	r2, [r7, #22]
 80076d4:	68fb      	ldr	r3, [r7, #12]
 80076d6:	32ae      	adds	r2, #174	@ 0xae
 80076d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80076dc:	691b      	ldr	r3, [r3, #16]
 80076de:	2b00      	cmp	r3, #0
 80076e0:	d00b      	beq.n	80076fa <USBD_LL_DataOutStage+0xee>
            {
              pdev->classId = idx;
 80076e2:	7dba      	ldrb	r2, [r7, #22]
 80076e4:	68fb      	ldr	r3, [r7, #12]
 80076e6:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 80076ea:	7dba      	ldrb	r2, [r7, #22]
 80076ec:	68fb      	ldr	r3, [r7, #12]
 80076ee:	32ae      	adds	r2, #174	@ 0xae
 80076f0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80076f4:	691b      	ldr	r3, [r3, #16]
 80076f6:	68f8      	ldr	r0, [r7, #12]
 80076f8:	4798      	blx	r3
            }
          }
        }

        (void)USBD_CtlSendStatus(pdev);
 80076fa:	68f8      	ldr	r0, [r7, #12]
 80076fc:	f001 f95a 	bl	80089b4 <USBD_CtlSendStatus>
 8007700:	e032      	b.n	8007768 <USBD_LL_DataOutStage+0x15c>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, (epnum & 0x7FU));
 8007702:	7afb      	ldrb	r3, [r7, #11]
 8007704:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8007708:	b2db      	uxtb	r3, r3
 800770a:	4619      	mov	r1, r3
 800770c:	68f8      	ldr	r0, [r7, #12]
 800770e:	f000 fa37 	bl	8007b80 <USBD_CoreFindEP>
 8007712:	4603      	mov	r3, r0
 8007714:	75bb      	strb	r3, [r7, #22]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007716:	7dbb      	ldrb	r3, [r7, #22]
 8007718:	2bff      	cmp	r3, #255	@ 0xff
 800771a:	d025      	beq.n	8007768 <USBD_LL_DataOutStage+0x15c>
 800771c:	7dbb      	ldrb	r3, [r7, #22]
 800771e:	2b00      	cmp	r3, #0
 8007720:	d122      	bne.n	8007768 <USBD_LL_DataOutStage+0x15c>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007722:	68fb      	ldr	r3, [r7, #12]
 8007724:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007728:	b2db      	uxtb	r3, r3
 800772a:	2b03      	cmp	r3, #3
 800772c:	d117      	bne.n	800775e <USBD_LL_DataOutStage+0x152>
      {
        if (pdev->pClass[idx]->DataOut != NULL)
 800772e:	7dba      	ldrb	r2, [r7, #22]
 8007730:	68fb      	ldr	r3, [r7, #12]
 8007732:	32ae      	adds	r2, #174	@ 0xae
 8007734:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007738:	699b      	ldr	r3, [r3, #24]
 800773a:	2b00      	cmp	r3, #0
 800773c:	d00f      	beq.n	800775e <USBD_LL_DataOutStage+0x152>
        {
          pdev->classId = idx;
 800773e:	7dba      	ldrb	r2, [r7, #22]
 8007740:	68fb      	ldr	r3, [r7, #12]
 8007742:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 8007746:	7dba      	ldrb	r2, [r7, #22]
 8007748:	68fb      	ldr	r3, [r7, #12]
 800774a:	32ae      	adds	r2, #174	@ 0xae
 800774c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007750:	699b      	ldr	r3, [r3, #24]
 8007752:	7afa      	ldrb	r2, [r7, #11]
 8007754:	4611      	mov	r1, r2
 8007756:	68f8      	ldr	r0, [r7, #12]
 8007758:	4798      	blx	r3
 800775a:	4603      	mov	r3, r0
 800775c:	75fb      	strb	r3, [r7, #23]
        }
      }
      if (ret != USBD_OK)
 800775e:	7dfb      	ldrb	r3, [r7, #23]
 8007760:	2b00      	cmp	r3, #0
 8007762:	d001      	beq.n	8007768 <USBD_LL_DataOutStage+0x15c>
      {
        return ret;
 8007764:	7dfb      	ldrb	r3, [r7, #23]
 8007766:	e000      	b.n	800776a <USBD_LL_DataOutStage+0x15e>
      }
    }
  }

  return USBD_OK;
 8007768:	2300      	movs	r3, #0
}
 800776a:	4618      	mov	r0, r3
 800776c:	3718      	adds	r7, #24
 800776e:	46bd      	mov	sp, r7
 8007770:	bd80      	pop	{r7, pc}

08007772 <USBD_LL_DataInStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 8007772:	b580      	push	{r7, lr}
 8007774:	b086      	sub	sp, #24
 8007776:	af00      	add	r7, sp, #0
 8007778:	60f8      	str	r0, [r7, #12]
 800777a:	460b      	mov	r3, r1
 800777c:	607a      	str	r2, [r7, #4]
 800777e:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 8007780:	7afb      	ldrb	r3, [r7, #11]
 8007782:	2b00      	cmp	r3, #0
 8007784:	d16f      	bne.n	8007866 <USBD_LL_DataInStage+0xf4>
  {
    pep = &pdev->ep_in[0];
 8007786:	68fb      	ldr	r3, [r7, #12]
 8007788:	3314      	adds	r3, #20
 800778a:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 800778c:	68fb      	ldr	r3, [r7, #12]
 800778e:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 8007792:	2b02      	cmp	r3, #2
 8007794:	d15a      	bne.n	800784c <USBD_LL_DataInStage+0xda>
    {
      if (pep->rem_length > pep->maxpacket)
 8007796:	693b      	ldr	r3, [r7, #16]
 8007798:	689a      	ldr	r2, [r3, #8]
 800779a:	693b      	ldr	r3, [r7, #16]
 800779c:	68db      	ldr	r3, [r3, #12]
 800779e:	429a      	cmp	r2, r3
 80077a0:	d914      	bls.n	80077cc <USBD_LL_DataInStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 80077a2:	693b      	ldr	r3, [r7, #16]
 80077a4:	689a      	ldr	r2, [r3, #8]
 80077a6:	693b      	ldr	r3, [r7, #16]
 80077a8:	68db      	ldr	r3, [r3, #12]
 80077aa:	1ad2      	subs	r2, r2, r3
 80077ac:	693b      	ldr	r3, [r7, #16]
 80077ae:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 80077b0:	693b      	ldr	r3, [r7, #16]
 80077b2:	689b      	ldr	r3, [r3, #8]
 80077b4:	461a      	mov	r2, r3
 80077b6:	6879      	ldr	r1, [r7, #4]
 80077b8:	68f8      	ldr	r0, [r7, #12]
 80077ba:	f001 f8bc 	bl	8008936 <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80077be:	2300      	movs	r3, #0
 80077c0:	2200      	movs	r2, #0
 80077c2:	2100      	movs	r1, #0
 80077c4:	68f8      	ldr	r0, [r7, #12]
 80077c6:	f020 fe5f 	bl	8028488 <USBD_LL_PrepareReceive>
 80077ca:	e03f      	b.n	800784c <USBD_LL_DataInStage+0xda>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
 80077cc:	693b      	ldr	r3, [r7, #16]
 80077ce:	68da      	ldr	r2, [r3, #12]
 80077d0:	693b      	ldr	r3, [r7, #16]
 80077d2:	689b      	ldr	r3, [r3, #8]
 80077d4:	429a      	cmp	r2, r3
 80077d6:	d11c      	bne.n	8007812 <USBD_LL_DataInStage+0xa0>
            (pep->total_length >= pep->maxpacket) &&
 80077d8:	693b      	ldr	r3, [r7, #16]
 80077da:	685a      	ldr	r2, [r3, #4]
 80077dc:	693b      	ldr	r3, [r7, #16]
 80077de:	68db      	ldr	r3, [r3, #12]
        if ((pep->maxpacket == pep->rem_length) &&
 80077e0:	429a      	cmp	r2, r3
 80077e2:	d316      	bcc.n	8007812 <USBD_LL_DataInStage+0xa0>
            (pep->total_length < pdev->ep0_data_len))
 80077e4:	693b      	ldr	r3, [r7, #16]
 80077e6:	685a      	ldr	r2, [r3, #4]
 80077e8:	68fb      	ldr	r3, [r7, #12]
 80077ea:	f8d3 3298 	ldr.w	r3, [r3, #664]	@ 0x298
            (pep->total_length >= pep->maxpacket) &&
 80077ee:	429a      	cmp	r2, r3
 80077f0:	d20f      	bcs.n	8007812 <USBD_LL_DataInStage+0xa0>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 80077f2:	2200      	movs	r2, #0
 80077f4:	2100      	movs	r1, #0
 80077f6:	68f8      	ldr	r0, [r7, #12]
 80077f8:	f001 f89d 	bl	8008936 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 80077fc:	68fb      	ldr	r3, [r7, #12]
 80077fe:	2200      	movs	r2, #0
 8007800:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8007804:	2300      	movs	r3, #0
 8007806:	2200      	movs	r2, #0
 8007808:	2100      	movs	r1, #0
 800780a:	68f8      	ldr	r0, [r7, #12]
 800780c:	f020 fe3c 	bl	8028488 <USBD_LL_PrepareReceive>
 8007810:	e01c      	b.n	800784c <USBD_LL_DataInStage+0xda>
        }
        else
        {
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007812:	68fb      	ldr	r3, [r7, #12]
 8007814:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007818:	b2db      	uxtb	r3, r3
 800781a:	2b03      	cmp	r3, #3
 800781c:	d10f      	bne.n	800783e <USBD_LL_DataInStage+0xcc>
          {
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 800781e:	68fb      	ldr	r3, [r7, #12]
 8007820:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007824:	68db      	ldr	r3, [r3, #12]
 8007826:	2b00      	cmp	r3, #0
 8007828:	d009      	beq.n	800783e <USBD_LL_DataInStage+0xcc>
            {
              pdev->classId = 0U;
 800782a:	68fb      	ldr	r3, [r7, #12]
 800782c:	2200      	movs	r2, #0
 800782e:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 8007832:	68fb      	ldr	r3, [r7, #12]
 8007834:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007838:	68db      	ldr	r3, [r3, #12]
 800783a:	68f8      	ldr	r0, [r7, #12]
 800783c:	4798      	blx	r3
            }
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
 800783e:	2180      	movs	r1, #128	@ 0x80
 8007840:	68f8      	ldr	r0, [r7, #12]
 8007842:	f020 fd77 	bl	8028334 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 8007846:	68f8      	ldr	r0, [r7, #12]
 8007848:	f001 f8c7 	bl	80089da <USBD_CtlReceiveStatus>
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
 800784c:	68fb      	ldr	r3, [r7, #12]
 800784e:	f893 32a0 	ldrb.w	r3, [r3, #672]	@ 0x2a0
 8007852:	2b00      	cmp	r3, #0
 8007854:	d03a      	beq.n	80078cc <USBD_LL_DataInStage+0x15a>
    {
      (void)USBD_RunTestMode(pdev);
 8007856:	68f8      	ldr	r0, [r7, #12]
 8007858:	f7ff fe42 	bl	80074e0 <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 800785c:	68fb      	ldr	r3, [r7, #12]
 800785e:	2200      	movs	r2, #0
 8007860:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
 8007864:	e032      	b.n	80078cc <USBD_LL_DataInStage+0x15a>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, ((uint8_t)epnum | 0x80U));
 8007866:	7afb      	ldrb	r3, [r7, #11]
 8007868:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 800786c:	b2db      	uxtb	r3, r3
 800786e:	4619      	mov	r1, r3
 8007870:	68f8      	ldr	r0, [r7, #12]
 8007872:	f000 f985 	bl	8007b80 <USBD_CoreFindEP>
 8007876:	4603      	mov	r3, r0
 8007878:	75fb      	strb	r3, [r7, #23]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 800787a:	7dfb      	ldrb	r3, [r7, #23]
 800787c:	2bff      	cmp	r3, #255	@ 0xff
 800787e:	d025      	beq.n	80078cc <USBD_LL_DataInStage+0x15a>
 8007880:	7dfb      	ldrb	r3, [r7, #23]
 8007882:	2b00      	cmp	r3, #0
 8007884:	d122      	bne.n	80078cc <USBD_LL_DataInStage+0x15a>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007886:	68fb      	ldr	r3, [r7, #12]
 8007888:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 800788c:	b2db      	uxtb	r3, r3
 800788e:	2b03      	cmp	r3, #3
 8007890:	d11c      	bne.n	80078cc <USBD_LL_DataInStage+0x15a>
      {
        if (pdev->pClass[idx]->DataIn != NULL)
 8007892:	7dfa      	ldrb	r2, [r7, #23]
 8007894:	68fb      	ldr	r3, [r7, #12]
 8007896:	32ae      	adds	r2, #174	@ 0xae
 8007898:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800789c:	695b      	ldr	r3, [r3, #20]
 800789e:	2b00      	cmp	r3, #0
 80078a0:	d014      	beq.n	80078cc <USBD_LL_DataInStage+0x15a>
        {
          pdev->classId = idx;
 80078a2:	7dfa      	ldrb	r2, [r7, #23]
 80078a4:	68fb      	ldr	r3, [r7, #12]
 80078a6:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 80078aa:	7dfa      	ldrb	r2, [r7, #23]
 80078ac:	68fb      	ldr	r3, [r7, #12]
 80078ae:	32ae      	adds	r2, #174	@ 0xae
 80078b0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80078b4:	695b      	ldr	r3, [r3, #20]
 80078b6:	7afa      	ldrb	r2, [r7, #11]
 80078b8:	4611      	mov	r1, r2
 80078ba:	68f8      	ldr	r0, [r7, #12]
 80078bc:	4798      	blx	r3
 80078be:	4603      	mov	r3, r0
 80078c0:	75bb      	strb	r3, [r7, #22]

          if (ret != USBD_OK)
 80078c2:	7dbb      	ldrb	r3, [r7, #22]
 80078c4:	2b00      	cmp	r3, #0
 80078c6:	d001      	beq.n	80078cc <USBD_LL_DataInStage+0x15a>
          {
            return ret;
 80078c8:	7dbb      	ldrb	r3, [r7, #22]
 80078ca:	e000      	b.n	80078ce <USBD_LL_DataInStage+0x15c>
        }
      }
    }
  }

  return USBD_OK;
 80078cc:	2300      	movs	r3, #0
}
 80078ce:	4618      	mov	r0, r3
 80078d0:	3718      	adds	r7, #24
 80078d2:	46bd      	mov	sp, r7
 80078d4:	bd80      	pop	{r7, pc}

080078d6 <USBD_LL_Reset>:
  *         Handle Reset event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 80078d6:	b580      	push	{r7, lr}
 80078d8:	b084      	sub	sp, #16
 80078da:	af00      	add	r7, sp, #0
 80078dc:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef ret = USBD_OK;
 80078de:	2300      	movs	r3, #0
 80078e0:	73fb      	strb	r3, [r7, #15]

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80078e2:	687b      	ldr	r3, [r7, #4]
 80078e4:	2201      	movs	r2, #1
 80078e6:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 80078ea:	687b      	ldr	r3, [r7, #4]
 80078ec:	2200      	movs	r2, #0
 80078ee:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->dev_config = 0U;
 80078f2:	687b      	ldr	r3, [r7, #4]
 80078f4:	2200      	movs	r2, #0
 80078f6:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 80078f8:	687b      	ldr	r3, [r7, #4]
 80078fa:	2200      	movs	r2, #0
 80078fc:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
  pdev->dev_test_mode = 0U;
 8007900:	687b      	ldr	r3, [r7, #4]
 8007902:	2200      	movs	r2, #0
 8007904:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 8007908:	687b      	ldr	r3, [r7, #4]
 800790a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 800790e:	2b00      	cmp	r3, #0
 8007910:	d014      	beq.n	800793c <USBD_LL_Reset+0x66>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 8007912:	687b      	ldr	r3, [r7, #4]
 8007914:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007918:	685b      	ldr	r3, [r3, #4]
 800791a:	2b00      	cmp	r3, #0
 800791c:	d00e      	beq.n	800793c <USBD_LL_Reset+0x66>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 800791e:	687b      	ldr	r3, [r7, #4]
 8007920:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007924:	685b      	ldr	r3, [r3, #4]
 8007926:	687a      	ldr	r2, [r7, #4]
 8007928:	6852      	ldr	r2, [r2, #4]
 800792a:	b2d2      	uxtb	r2, r2
 800792c:	4611      	mov	r1, r2
 800792e:	6878      	ldr	r0, [r7, #4]
 8007930:	4798      	blx	r3
 8007932:	4603      	mov	r3, r0
 8007934:	2b00      	cmp	r3, #0
 8007936:	d001      	beq.n	800793c <USBD_LL_Reset+0x66>
      {
        ret = USBD_FAIL;
 8007938:	2303      	movs	r3, #3
 800793a:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800793c:	2340      	movs	r3, #64	@ 0x40
 800793e:	2200      	movs	r2, #0
 8007940:	2100      	movs	r1, #0
 8007942:	6878      	ldr	r0, [r7, #4]
 8007944:	f020 fcb1 	bl	80282aa <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8007948:	687b      	ldr	r3, [r7, #4]
 800794a:	2201      	movs	r2, #1
 800794c:	f8a3 2164 	strh.w	r2, [r3, #356]	@ 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8007950:	687b      	ldr	r3, [r7, #4]
 8007952:	2240      	movs	r2, #64	@ 0x40
 8007954:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8007958:	2340      	movs	r3, #64	@ 0x40
 800795a:	2200      	movs	r2, #0
 800795c:	2180      	movs	r1, #128	@ 0x80
 800795e:	6878      	ldr	r0, [r7, #4]
 8007960:	f020 fca3 	bl	80282aa <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8007964:	687b      	ldr	r3, [r7, #4]
 8007966:	2201      	movs	r2, #1
 8007968:	849a      	strh	r2, [r3, #36]	@ 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 800796a:	687b      	ldr	r3, [r7, #4]
 800796c:	2240      	movs	r2, #64	@ 0x40
 800796e:	621a      	str	r2, [r3, #32]

  return ret;
 8007970:	7bfb      	ldrb	r3, [r7, #15]
}
 8007972:	4618      	mov	r0, r3
 8007974:	3710      	adds	r7, #16
 8007976:	46bd      	mov	sp, r7
 8007978:	bd80      	pop	{r7, pc}

0800797a <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 800797a:	b480      	push	{r7}
 800797c:	b083      	sub	sp, #12
 800797e:	af00      	add	r7, sp, #0
 8007980:	6078      	str	r0, [r7, #4]
 8007982:	460b      	mov	r3, r1
 8007984:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 8007986:	687b      	ldr	r3, [r7, #4]
 8007988:	78fa      	ldrb	r2, [r7, #3]
 800798a:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 800798c:	2300      	movs	r3, #0
}
 800798e:	4618      	mov	r0, r3
 8007990:	370c      	adds	r7, #12
 8007992:	46bd      	mov	sp, r7
 8007994:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007998:	4770      	bx	lr

0800799a <USBD_LL_Suspend>:
  *         Handle Suspend event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 800799a:	b480      	push	{r7}
 800799c:	b083      	sub	sp, #12
 800799e:	af00      	add	r7, sp, #0
 80079a0:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 80079a2:	687b      	ldr	r3, [r7, #4]
 80079a4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80079a8:	b2db      	uxtb	r3, r3
 80079aa:	2b04      	cmp	r3, #4
 80079ac:	d006      	beq.n	80079bc <USBD_LL_Suspend+0x22>
  {
    pdev->dev_old_state = pdev->dev_state;
 80079ae:	687b      	ldr	r3, [r7, #4]
 80079b0:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80079b4:	b2da      	uxtb	r2, r3
 80079b6:	687b      	ldr	r3, [r7, #4]
 80079b8:	f883 229d 	strb.w	r2, [r3, #669]	@ 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
 80079bc:	687b      	ldr	r3, [r7, #4]
 80079be:	2204      	movs	r2, #4
 80079c0:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c

  return USBD_OK;
 80079c4:	2300      	movs	r3, #0
}
 80079c6:	4618      	mov	r0, r3
 80079c8:	370c      	adds	r7, #12
 80079ca:	46bd      	mov	sp, r7
 80079cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079d0:	4770      	bx	lr

080079d2 <USBD_LL_Resume>:
  *         Handle Resume event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 80079d2:	b480      	push	{r7}
 80079d4:	b083      	sub	sp, #12
 80079d6:	af00      	add	r7, sp, #0
 80079d8:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 80079da:	687b      	ldr	r3, [r7, #4]
 80079dc:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80079e0:	b2db      	uxtb	r3, r3
 80079e2:	2b04      	cmp	r3, #4
 80079e4:	d106      	bne.n	80079f4 <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
 80079e6:	687b      	ldr	r3, [r7, #4]
 80079e8:	f893 329d 	ldrb.w	r3, [r3, #669]	@ 0x29d
 80079ec:	b2da      	uxtb	r2, r3
 80079ee:	687b      	ldr	r3, [r7, #4]
 80079f0:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  }

  return USBD_OK;
 80079f4:	2300      	movs	r3, #0
}
 80079f6:	4618      	mov	r0, r3
 80079f8:	370c      	adds	r7, #12
 80079fa:	46bd      	mov	sp, r7
 80079fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a00:	4770      	bx	lr

08007a02 <USBD_LL_SOF>:
  *         Handle SOF event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 8007a02:	b580      	push	{r7, lr}
 8007a04:	b082      	sub	sp, #8
 8007a06:	af00      	add	r7, sp, #0
 8007a08:	6078      	str	r0, [r7, #4]
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007a0a:	687b      	ldr	r3, [r7, #4]
 8007a0c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007a10:	b2db      	uxtb	r3, r3
 8007a12:	2b03      	cmp	r3, #3
 8007a14:	d110      	bne.n	8007a38 <USBD_LL_SOF+0x36>
          }
        }
      }
    }
#else
    if (pdev->pClass[0] != NULL)
 8007a16:	687b      	ldr	r3, [r7, #4]
 8007a18:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007a1c:	2b00      	cmp	r3, #0
 8007a1e:	d00b      	beq.n	8007a38 <USBD_LL_SOF+0x36>
    {
      if (pdev->pClass[0]->SOF != NULL)
 8007a20:	687b      	ldr	r3, [r7, #4]
 8007a22:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007a26:	69db      	ldr	r3, [r3, #28]
 8007a28:	2b00      	cmp	r3, #0
 8007a2a:	d005      	beq.n	8007a38 <USBD_LL_SOF+0x36>
      {
        (void)pdev->pClass[0]->SOF(pdev);
 8007a2c:	687b      	ldr	r3, [r7, #4]
 8007a2e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007a32:	69db      	ldr	r3, [r3, #28]
 8007a34:	6878      	ldr	r0, [r7, #4]
 8007a36:	4798      	blx	r3
      }
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
 8007a38:	2300      	movs	r3, #0
}
 8007a3a:	4618      	mov	r0, r3
 8007a3c:	3708      	adds	r7, #8
 8007a3e:	46bd      	mov	sp, r7
 8007a40:	bd80      	pop	{r7, pc}

08007a42 <USBD_LL_IsoINIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
 8007a42:	b580      	push	{r7, lr}
 8007a44:	b082      	sub	sp, #8
 8007a46:	af00      	add	r7, sp, #0
 8007a48:	6078      	str	r0, [r7, #4]
 8007a4a:	460b      	mov	r3, r1
 8007a4c:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 8007a4e:	687b      	ldr	r3, [r7, #4]
 8007a50:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007a54:	687b      	ldr	r3, [r7, #4]
 8007a56:	32ae      	adds	r2, #174	@ 0xae
 8007a58:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007a5c:	2b00      	cmp	r3, #0
 8007a5e:	d101      	bne.n	8007a64 <USBD_LL_IsoINIncomplete+0x22>
  {
    return USBD_FAIL;
 8007a60:	2303      	movs	r3, #3
 8007a62:	e01c      	b.n	8007a9e <USBD_LL_IsoINIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007a64:	687b      	ldr	r3, [r7, #4]
 8007a66:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007a6a:	b2db      	uxtb	r3, r3
 8007a6c:	2b03      	cmp	r3, #3
 8007a6e:	d115      	bne.n	8007a9c <USBD_LL_IsoINIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 8007a70:	687b      	ldr	r3, [r7, #4]
 8007a72:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007a76:	687b      	ldr	r3, [r7, #4]
 8007a78:	32ae      	adds	r2, #174	@ 0xae
 8007a7a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007a7e:	6a1b      	ldr	r3, [r3, #32]
 8007a80:	2b00      	cmp	r3, #0
 8007a82:	d00b      	beq.n	8007a9c <USBD_LL_IsoINIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 8007a84:	687b      	ldr	r3, [r7, #4]
 8007a86:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007a8a:	687b      	ldr	r3, [r7, #4]
 8007a8c:	32ae      	adds	r2, #174	@ 0xae
 8007a8e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007a92:	6a1b      	ldr	r3, [r3, #32]
 8007a94:	78fa      	ldrb	r2, [r7, #3]
 8007a96:	4611      	mov	r1, r2
 8007a98:	6878      	ldr	r0, [r7, #4]
 8007a9a:	4798      	blx	r3
    }
  }

  return USBD_OK;
 8007a9c:	2300      	movs	r3, #0
}
 8007a9e:	4618      	mov	r0, r3
 8007aa0:	3708      	adds	r7, #8
 8007aa2:	46bd      	mov	sp, r7
 8007aa4:	bd80      	pop	{r7, pc}

08007aa6 <USBD_LL_IsoOUTIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
 8007aa6:	b580      	push	{r7, lr}
 8007aa8:	b082      	sub	sp, #8
 8007aaa:	af00      	add	r7, sp, #0
 8007aac:	6078      	str	r0, [r7, #4]
 8007aae:	460b      	mov	r3, r1
 8007ab0:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 8007ab2:	687b      	ldr	r3, [r7, #4]
 8007ab4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007ab8:	687b      	ldr	r3, [r7, #4]
 8007aba:	32ae      	adds	r2, #174	@ 0xae
 8007abc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007ac0:	2b00      	cmp	r3, #0
 8007ac2:	d101      	bne.n	8007ac8 <USBD_LL_IsoOUTIncomplete+0x22>
  {
    return USBD_FAIL;
 8007ac4:	2303      	movs	r3, #3
 8007ac6:	e01c      	b.n	8007b02 <USBD_LL_IsoOUTIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007ac8:	687b      	ldr	r3, [r7, #4]
 8007aca:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007ace:	b2db      	uxtb	r3, r3
 8007ad0:	2b03      	cmp	r3, #3
 8007ad2:	d115      	bne.n	8007b00 <USBD_LL_IsoOUTIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 8007ad4:	687b      	ldr	r3, [r7, #4]
 8007ad6:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007ada:	687b      	ldr	r3, [r7, #4]
 8007adc:	32ae      	adds	r2, #174	@ 0xae
 8007ade:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007ae2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8007ae4:	2b00      	cmp	r3, #0
 8007ae6:	d00b      	beq.n	8007b00 <USBD_LL_IsoOUTIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 8007ae8:	687b      	ldr	r3, [r7, #4]
 8007aea:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007aee:	687b      	ldr	r3, [r7, #4]
 8007af0:	32ae      	adds	r2, #174	@ 0xae
 8007af2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007af6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8007af8:	78fa      	ldrb	r2, [r7, #3]
 8007afa:	4611      	mov	r1, r2
 8007afc:	6878      	ldr	r0, [r7, #4]
 8007afe:	4798      	blx	r3
    }
  }

  return USBD_OK;
 8007b00:	2300      	movs	r3, #0
}
 8007b02:	4618      	mov	r0, r3
 8007b04:	3708      	adds	r7, #8
 8007b06:	46bd      	mov	sp, r7
 8007b08:	bd80      	pop	{r7, pc}

08007b0a <USBD_LL_DevConnected>:
  *         Handle device connection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
{
 8007b0a:	b480      	push	{r7}
 8007b0c:	b083      	sub	sp, #12
 8007b0e:	af00      	add	r7, sp, #0
 8007b10:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 8007b12:	2300      	movs	r3, #0
}
 8007b14:	4618      	mov	r0, r3
 8007b16:	370c      	adds	r7, #12
 8007b18:	46bd      	mov	sp, r7
 8007b1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b1e:	4770      	bx	lr

08007b20 <USBD_LL_DevDisconnected>:
  *         Handle device disconnection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
 8007b20:	b580      	push	{r7, lr}
 8007b22:	b084      	sub	sp, #16
 8007b24:	af00      	add	r7, sp, #0
 8007b26:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef   ret = USBD_OK;
 8007b28:	2300      	movs	r3, #0
 8007b2a:	73fb      	strb	r3, [r7, #15]

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8007b2c:	687b      	ldr	r3, [r7, #4]
 8007b2e:	2201      	movs	r2, #1
 8007b30:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 8007b34:	687b      	ldr	r3, [r7, #4]
 8007b36:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007b3a:	2b00      	cmp	r3, #0
 8007b3c:	d00e      	beq.n	8007b5c <USBD_LL_DevDisconnected+0x3c>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 8007b3e:	687b      	ldr	r3, [r7, #4]
 8007b40:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8007b44:	685b      	ldr	r3, [r3, #4]
 8007b46:	687a      	ldr	r2, [r7, #4]
 8007b48:	6852      	ldr	r2, [r2, #4]
 8007b4a:	b2d2      	uxtb	r2, r2
 8007b4c:	4611      	mov	r1, r2
 8007b4e:	6878      	ldr	r0, [r7, #4]
 8007b50:	4798      	blx	r3
 8007b52:	4603      	mov	r3, r0
 8007b54:	2b00      	cmp	r3, #0
 8007b56:	d001      	beq.n	8007b5c <USBD_LL_DevDisconnected+0x3c>
    {
      ret = USBD_FAIL;
 8007b58:	2303      	movs	r3, #3
 8007b5a:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 8007b5c:	7bfb      	ldrb	r3, [r7, #15]
}
 8007b5e:	4618      	mov	r0, r3
 8007b60:	3710      	adds	r7, #16
 8007b62:	46bd      	mov	sp, r7
 8007b64:	bd80      	pop	{r7, pc}

08007b66 <USBD_CoreFindIF>:
  * @param  pdev: device instance
  * @param  index : selected interface number
  * @retval index of the class using the selected interface number. OxFF if no class found.
  */
uint8_t USBD_CoreFindIF(USBD_HandleTypeDef *pdev, uint8_t index)
{
 8007b66:	b480      	push	{r7}
 8007b68:	b083      	sub	sp, #12
 8007b6a:	af00      	add	r7, sp, #0
 8007b6c:	6078      	str	r0, [r7, #4]
 8007b6e:	460b      	mov	r3, r1
 8007b70:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 8007b72:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 8007b74:	4618      	mov	r0, r3
 8007b76:	370c      	adds	r7, #12
 8007b78:	46bd      	mov	sp, r7
 8007b7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b7e:	4770      	bx	lr

08007b80 <USBD_CoreFindEP>:
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
{
 8007b80:	b480      	push	{r7}
 8007b82:	b083      	sub	sp, #12
 8007b84:	af00      	add	r7, sp, #0
 8007b86:	6078      	str	r0, [r7, #4]
 8007b88:	460b      	mov	r3, r1
 8007b8a:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 8007b8c:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 8007b8e:	4618      	mov	r0, r3
 8007b90:	370c      	adds	r7, #12
 8007b92:	46bd      	mov	sp, r7
 8007b94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b98:	4770      	bx	lr

08007b9a <USBD_GetEpDesc>:
  * @param  pConfDesc:  pointer to Bos descriptor
  * @param  EpAddr:  endpoint address
  * @retval pointer to video endpoint descriptor
  */
void *USBD_GetEpDesc(uint8_t *pConfDesc, uint8_t EpAddr)
{
 8007b9a:	b580      	push	{r7, lr}
 8007b9c:	b086      	sub	sp, #24
 8007b9e:	af00      	add	r7, sp, #0
 8007ba0:	6078      	str	r0, [r7, #4]
 8007ba2:	460b      	mov	r3, r1
 8007ba4:	70fb      	strb	r3, [r7, #3]
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
 8007ba6:	687b      	ldr	r3, [r7, #4]
 8007ba8:	617b      	str	r3, [r7, #20]
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
 8007baa:	687b      	ldr	r3, [r7, #4]
 8007bac:	60fb      	str	r3, [r7, #12]
  USBD_EpDescTypeDef *pEpDesc = NULL;
 8007bae:	2300      	movs	r3, #0
 8007bb0:	613b      	str	r3, [r7, #16]
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 8007bb2:	68fb      	ldr	r3, [r7, #12]
 8007bb4:	885b      	ldrh	r3, [r3, #2]
 8007bb6:	b29b      	uxth	r3, r3
 8007bb8:	68fa      	ldr	r2, [r7, #12]
 8007bba:	7812      	ldrb	r2, [r2, #0]
 8007bbc:	4293      	cmp	r3, r2
 8007bbe:	d91f      	bls.n	8007c00 <USBD_GetEpDesc+0x66>
  {
    ptr = desc->bLength;
 8007bc0:	68fb      	ldr	r3, [r7, #12]
 8007bc2:	781b      	ldrb	r3, [r3, #0]
 8007bc4:	817b      	strh	r3, [r7, #10]

    while (ptr < desc->wTotalLength)
 8007bc6:	e013      	b.n	8007bf0 <USBD_GetEpDesc+0x56>
    {
      pdesc = USBD_GetNextDesc((uint8_t *)pdesc, &ptr);
 8007bc8:	f107 030a 	add.w	r3, r7, #10
 8007bcc:	4619      	mov	r1, r3
 8007bce:	6978      	ldr	r0, [r7, #20]
 8007bd0:	f000 f81b 	bl	8007c0a <USBD_GetNextDesc>
 8007bd4:	6178      	str	r0, [r7, #20]

      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 8007bd6:	697b      	ldr	r3, [r7, #20]
 8007bd8:	785b      	ldrb	r3, [r3, #1]
 8007bda:	2b05      	cmp	r3, #5
 8007bdc:	d108      	bne.n	8007bf0 <USBD_GetEpDesc+0x56>
      {
        pEpDesc = (USBD_EpDescTypeDef *)(void *)pdesc;
 8007bde:	697b      	ldr	r3, [r7, #20]
 8007be0:	613b      	str	r3, [r7, #16]

        if (pEpDesc->bEndpointAddress == EpAddr)
 8007be2:	693b      	ldr	r3, [r7, #16]
 8007be4:	789b      	ldrb	r3, [r3, #2]
 8007be6:	78fa      	ldrb	r2, [r7, #3]
 8007be8:	429a      	cmp	r2, r3
 8007bea:	d008      	beq.n	8007bfe <USBD_GetEpDesc+0x64>
        {
          break;
        }
        else
        {
          pEpDesc = NULL;
 8007bec:	2300      	movs	r3, #0
 8007bee:	613b      	str	r3, [r7, #16]
    while (ptr < desc->wTotalLength)
 8007bf0:	68fb      	ldr	r3, [r7, #12]
 8007bf2:	885b      	ldrh	r3, [r3, #2]
 8007bf4:	b29a      	uxth	r2, r3
 8007bf6:	897b      	ldrh	r3, [r7, #10]
 8007bf8:	429a      	cmp	r2, r3
 8007bfa:	d8e5      	bhi.n	8007bc8 <USBD_GetEpDesc+0x2e>
 8007bfc:	e000      	b.n	8007c00 <USBD_GetEpDesc+0x66>
          break;
 8007bfe:	bf00      	nop
        }
      }
    }
  }

  return (void *)pEpDesc;
 8007c00:	693b      	ldr	r3, [r7, #16]
}
 8007c02:	4618      	mov	r0, r3
 8007c04:	3718      	adds	r7, #24
 8007c06:	46bd      	mov	sp, r7
 8007c08:	bd80      	pop	{r7, pc}

08007c0a <USBD_GetNextDesc>:
  * @param  buf: Buffer where the descriptor is available
  * @param  ptr: data pointer inside the descriptor
  * @retval next header
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
 8007c0a:	b480      	push	{r7}
 8007c0c:	b085      	sub	sp, #20
 8007c0e:	af00      	add	r7, sp, #0
 8007c10:	6078      	str	r0, [r7, #4]
 8007c12:	6039      	str	r1, [r7, #0]
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;
 8007c14:	687b      	ldr	r3, [r7, #4]
 8007c16:	60fb      	str	r3, [r7, #12]

  *ptr += pnext->bLength;
 8007c18:	683b      	ldr	r3, [r7, #0]
 8007c1a:	881b      	ldrh	r3, [r3, #0]
 8007c1c:	68fa      	ldr	r2, [r7, #12]
 8007c1e:	7812      	ldrb	r2, [r2, #0]
 8007c20:	4413      	add	r3, r2
 8007c22:	b29a      	uxth	r2, r3
 8007c24:	683b      	ldr	r3, [r7, #0]
 8007c26:	801a      	strh	r2, [r3, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 8007c28:	68fb      	ldr	r3, [r7, #12]
 8007c2a:	781b      	ldrb	r3, [r3, #0]
 8007c2c:	461a      	mov	r2, r3
 8007c2e:	687b      	ldr	r3, [r7, #4]
 8007c30:	4413      	add	r3, r2
 8007c32:	60fb      	str	r3, [r7, #12]

  return (pnext);
 8007c34:	68fb      	ldr	r3, [r7, #12]
}
 8007c36:	4618      	mov	r0, r3
 8007c38:	3714      	adds	r7, #20
 8007c3a:	46bd      	mov	sp, r7
 8007c3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c40:	4770      	bx	lr

08007c42 <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
 8007c42:	b480      	push	{r7}
 8007c44:	b087      	sub	sp, #28
 8007c46:	af00      	add	r7, sp, #0
 8007c48:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal;
  uint16_t _Byte1;
  uint16_t _Byte2;
  uint8_t *_pbuff = addr;
 8007c4a:	687b      	ldr	r3, [r7, #4]
 8007c4c:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
 8007c4e:	697b      	ldr	r3, [r7, #20]
 8007c50:	781b      	ldrb	r3, [r3, #0]
 8007c52:	827b      	strh	r3, [r7, #18]
  _pbuff++;
 8007c54:	697b      	ldr	r3, [r7, #20]
 8007c56:	3301      	adds	r3, #1
 8007c58:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
 8007c5a:	697b      	ldr	r3, [r7, #20]
 8007c5c:	781b      	ldrb	r3, [r3, #0]
 8007c5e:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 8007c60:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8007c64:	021b      	lsls	r3, r3, #8
 8007c66:	b21a      	sxth	r2, r3
 8007c68:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8007c6c:	4313      	orrs	r3, r2
 8007c6e:	b21b      	sxth	r3, r3
 8007c70:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
 8007c72:	89fb      	ldrh	r3, [r7, #14]
}
 8007c74:	4618      	mov	r0, r3
 8007c76:	371c      	adds	r7, #28
 8007c78:	46bd      	mov	sp, r7
 8007c7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c7e:	4770      	bx	lr

08007c80 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007c80:	b580      	push	{r7, lr}
 8007c82:	b084      	sub	sp, #16
 8007c84:	af00      	add	r7, sp, #0
 8007c86:	6078      	str	r0, [r7, #4]
 8007c88:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8007c8a:	2300      	movs	r3, #0
 8007c8c:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8007c8e:	683b      	ldr	r3, [r7, #0]
 8007c90:	781b      	ldrb	r3, [r3, #0]
 8007c92:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8007c96:	2b40      	cmp	r3, #64	@ 0x40
 8007c98:	d005      	beq.n	8007ca6 <USBD_StdDevReq+0x26>
 8007c9a:	2b40      	cmp	r3, #64	@ 0x40
 8007c9c:	d857      	bhi.n	8007d4e <USBD_StdDevReq+0xce>
 8007c9e:	2b00      	cmp	r3, #0
 8007ca0:	d00f      	beq.n	8007cc2 <USBD_StdDevReq+0x42>
 8007ca2:	2b20      	cmp	r3, #32
 8007ca4:	d153      	bne.n	8007d4e <USBD_StdDevReq+0xce>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 8007ca6:	687b      	ldr	r3, [r7, #4]
 8007ca8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007cac:	687b      	ldr	r3, [r7, #4]
 8007cae:	32ae      	adds	r2, #174	@ 0xae
 8007cb0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007cb4:	689b      	ldr	r3, [r3, #8]
 8007cb6:	6839      	ldr	r1, [r7, #0]
 8007cb8:	6878      	ldr	r0, [r7, #4]
 8007cba:	4798      	blx	r3
 8007cbc:	4603      	mov	r3, r0
 8007cbe:	73fb      	strb	r3, [r7, #15]
      break;
 8007cc0:	e04a      	b.n	8007d58 <USBD_StdDevReq+0xd8>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8007cc2:	683b      	ldr	r3, [r7, #0]
 8007cc4:	785b      	ldrb	r3, [r3, #1]
 8007cc6:	2b09      	cmp	r3, #9
 8007cc8:	d83b      	bhi.n	8007d42 <USBD_StdDevReq+0xc2>
 8007cca:	a201      	add	r2, pc, #4	@ (adr r2, 8007cd0 <USBD_StdDevReq+0x50>)
 8007ccc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007cd0:	08007d25 	.word	0x08007d25
 8007cd4:	08007d39 	.word	0x08007d39
 8007cd8:	08007d43 	.word	0x08007d43
 8007cdc:	08007d2f 	.word	0x08007d2f
 8007ce0:	08007d43 	.word	0x08007d43
 8007ce4:	08007d03 	.word	0x08007d03
 8007ce8:	08007cf9 	.word	0x08007cf9
 8007cec:	08007d43 	.word	0x08007d43
 8007cf0:	08007d1b 	.word	0x08007d1b
 8007cf4:	08007d0d 	.word	0x08007d0d
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
 8007cf8:	6839      	ldr	r1, [r7, #0]
 8007cfa:	6878      	ldr	r0, [r7, #4]
 8007cfc:	f000 fa3c 	bl	8008178 <USBD_GetDescriptor>
          break;
 8007d00:	e024      	b.n	8007d4c <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
 8007d02:	6839      	ldr	r1, [r7, #0]
 8007d04:	6878      	ldr	r0, [r7, #4]
 8007d06:	f000 fba1 	bl	800844c <USBD_SetAddress>
          break;
 8007d0a:	e01f      	b.n	8007d4c <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_CONFIGURATION:
          ret = USBD_SetConfig(pdev, req);
 8007d0c:	6839      	ldr	r1, [r7, #0]
 8007d0e:	6878      	ldr	r0, [r7, #4]
 8007d10:	f000 fbe0 	bl	80084d4 <USBD_SetConfig>
 8007d14:	4603      	mov	r3, r0
 8007d16:	73fb      	strb	r3, [r7, #15]
          break;
 8007d18:	e018      	b.n	8007d4c <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
 8007d1a:	6839      	ldr	r1, [r7, #0]
 8007d1c:	6878      	ldr	r0, [r7, #4]
 8007d1e:	f000 fc83 	bl	8008628 <USBD_GetConfig>
          break;
 8007d22:	e013      	b.n	8007d4c <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
 8007d24:	6839      	ldr	r1, [r7, #0]
 8007d26:	6878      	ldr	r0, [r7, #4]
 8007d28:	f000 fcb4 	bl	8008694 <USBD_GetStatus>
          break;
 8007d2c:	e00e      	b.n	8007d4c <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
 8007d2e:	6839      	ldr	r1, [r7, #0]
 8007d30:	6878      	ldr	r0, [r7, #4]
 8007d32:	f000 fce3 	bl	80086fc <USBD_SetFeature>
          break;
 8007d36:	e009      	b.n	8007d4c <USBD_StdDevReq+0xcc>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
 8007d38:	6839      	ldr	r1, [r7, #0]
 8007d3a:	6878      	ldr	r0, [r7, #4]
 8007d3c:	f000 fd07 	bl	800874e <USBD_ClrFeature>
          break;
 8007d40:	e004      	b.n	8007d4c <USBD_StdDevReq+0xcc>

        default:
          USBD_CtlError(pdev, req);
 8007d42:	6839      	ldr	r1, [r7, #0]
 8007d44:	6878      	ldr	r0, [r7, #4]
 8007d46:	f000 fd5e 	bl	8008806 <USBD_CtlError>
          break;
 8007d4a:	bf00      	nop
      }
      break;
 8007d4c:	e004      	b.n	8007d58 <USBD_StdDevReq+0xd8>

    default:
      USBD_CtlError(pdev, req);
 8007d4e:	6839      	ldr	r1, [r7, #0]
 8007d50:	6878      	ldr	r0, [r7, #4]
 8007d52:	f000 fd58 	bl	8008806 <USBD_CtlError>
      break;
 8007d56:	bf00      	nop
  }

  return ret;
 8007d58:	7bfb      	ldrb	r3, [r7, #15]
}
 8007d5a:	4618      	mov	r0, r3
 8007d5c:	3710      	adds	r7, #16
 8007d5e:	46bd      	mov	sp, r7
 8007d60:	bd80      	pop	{r7, pc}
 8007d62:	bf00      	nop

08007d64 <USBD_StdItfReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007d64:	b580      	push	{r7, lr}
 8007d66:	b084      	sub	sp, #16
 8007d68:	af00      	add	r7, sp, #0
 8007d6a:	6078      	str	r0, [r7, #4]
 8007d6c:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8007d6e:	2300      	movs	r3, #0
 8007d70:	73fb      	strb	r3, [r7, #15]
  uint8_t idx;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8007d72:	683b      	ldr	r3, [r7, #0]
 8007d74:	781b      	ldrb	r3, [r3, #0]
 8007d76:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8007d7a:	2b40      	cmp	r3, #64	@ 0x40
 8007d7c:	d005      	beq.n	8007d8a <USBD_StdItfReq+0x26>
 8007d7e:	2b40      	cmp	r3, #64	@ 0x40
 8007d80:	d852      	bhi.n	8007e28 <USBD_StdItfReq+0xc4>
 8007d82:	2b00      	cmp	r3, #0
 8007d84:	d001      	beq.n	8007d8a <USBD_StdItfReq+0x26>
 8007d86:	2b20      	cmp	r3, #32
 8007d88:	d14e      	bne.n	8007e28 <USBD_StdItfReq+0xc4>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
 8007d8a:	687b      	ldr	r3, [r7, #4]
 8007d8c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007d90:	b2db      	uxtb	r3, r3
 8007d92:	3b01      	subs	r3, #1
 8007d94:	2b02      	cmp	r3, #2
 8007d96:	d840      	bhi.n	8007e1a <USBD_StdItfReq+0xb6>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8007d98:	683b      	ldr	r3, [r7, #0]
 8007d9a:	889b      	ldrh	r3, [r3, #4]
 8007d9c:	b2db      	uxtb	r3, r3
 8007d9e:	2b01      	cmp	r3, #1
 8007da0:	d836      	bhi.n	8007e10 <USBD_StdItfReq+0xac>
          {
            /* Get the class index relative to this interface */
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 8007da2:	683b      	ldr	r3, [r7, #0]
 8007da4:	889b      	ldrh	r3, [r3, #4]
 8007da6:	b2db      	uxtb	r3, r3
 8007da8:	4619      	mov	r1, r3
 8007daa:	6878      	ldr	r0, [r7, #4]
 8007dac:	f7ff fedb 	bl	8007b66 <USBD_CoreFindIF>
 8007db0:	4603      	mov	r3, r0
 8007db2:	73bb      	strb	r3, [r7, #14]
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007db4:	7bbb      	ldrb	r3, [r7, #14]
 8007db6:	2bff      	cmp	r3, #255	@ 0xff
 8007db8:	d01d      	beq.n	8007df6 <USBD_StdItfReq+0x92>
 8007dba:	7bbb      	ldrb	r3, [r7, #14]
 8007dbc:	2b00      	cmp	r3, #0
 8007dbe:	d11a      	bne.n	8007df6 <USBD_StdItfReq+0x92>
            {
              /* Call the class data out function to manage the request */
              if (pdev->pClass[idx]->Setup != NULL)
 8007dc0:	7bba      	ldrb	r2, [r7, #14]
 8007dc2:	687b      	ldr	r3, [r7, #4]
 8007dc4:	32ae      	adds	r2, #174	@ 0xae
 8007dc6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007dca:	689b      	ldr	r3, [r3, #8]
 8007dcc:	2b00      	cmp	r3, #0
 8007dce:	d00f      	beq.n	8007df0 <USBD_StdItfReq+0x8c>
              {
                pdev->classId = idx;
 8007dd0:	7bba      	ldrb	r2, [r7, #14]
 8007dd2:	687b      	ldr	r3, [r7, #4]
 8007dd4:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8007dd8:	7bba      	ldrb	r2, [r7, #14]
 8007dda:	687b      	ldr	r3, [r7, #4]
 8007ddc:	32ae      	adds	r2, #174	@ 0xae
 8007dde:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007de2:	689b      	ldr	r3, [r3, #8]
 8007de4:	6839      	ldr	r1, [r7, #0]
 8007de6:	6878      	ldr	r0, [r7, #4]
 8007de8:	4798      	blx	r3
 8007dea:	4603      	mov	r3, r0
 8007dec:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 8007dee:	e004      	b.n	8007dfa <USBD_StdItfReq+0x96>
              }
              else
              {
                /* should never reach this condition */
                ret = USBD_FAIL;
 8007df0:	2303      	movs	r3, #3
 8007df2:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 8007df4:	e001      	b.n	8007dfa <USBD_StdItfReq+0x96>
              }
            }
            else
            {
              /* No relative interface found */
              ret = USBD_FAIL;
 8007df6:	2303      	movs	r3, #3
 8007df8:	73fb      	strb	r3, [r7, #15]
            }

            if ((req->wLength == 0U) && (ret == USBD_OK))
 8007dfa:	683b      	ldr	r3, [r7, #0]
 8007dfc:	88db      	ldrh	r3, [r3, #6]
 8007dfe:	2b00      	cmp	r3, #0
 8007e00:	d110      	bne.n	8007e24 <USBD_StdItfReq+0xc0>
 8007e02:	7bfb      	ldrb	r3, [r7, #15]
 8007e04:	2b00      	cmp	r3, #0
 8007e06:	d10d      	bne.n	8007e24 <USBD_StdItfReq+0xc0>
            {
              (void)USBD_CtlSendStatus(pdev);
 8007e08:	6878      	ldr	r0, [r7, #4]
 8007e0a:	f000 fdd3 	bl	80089b4 <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
 8007e0e:	e009      	b.n	8007e24 <USBD_StdItfReq+0xc0>
            USBD_CtlError(pdev, req);
 8007e10:	6839      	ldr	r1, [r7, #0]
 8007e12:	6878      	ldr	r0, [r7, #4]
 8007e14:	f000 fcf7 	bl	8008806 <USBD_CtlError>
          break;
 8007e18:	e004      	b.n	8007e24 <USBD_StdItfReq+0xc0>

        default:
          USBD_CtlError(pdev, req);
 8007e1a:	6839      	ldr	r1, [r7, #0]
 8007e1c:	6878      	ldr	r0, [r7, #4]
 8007e1e:	f000 fcf2 	bl	8008806 <USBD_CtlError>
          break;
 8007e22:	e000      	b.n	8007e26 <USBD_StdItfReq+0xc2>
          break;
 8007e24:	bf00      	nop
      }
      break;
 8007e26:	e004      	b.n	8007e32 <USBD_StdItfReq+0xce>

    default:
      USBD_CtlError(pdev, req);
 8007e28:	6839      	ldr	r1, [r7, #0]
 8007e2a:	6878      	ldr	r0, [r7, #4]
 8007e2c:	f000 fceb 	bl	8008806 <USBD_CtlError>
      break;
 8007e30:	bf00      	nop
  }

  return ret;
 8007e32:	7bfb      	ldrb	r3, [r7, #15]
}
 8007e34:	4618      	mov	r0, r3
 8007e36:	3710      	adds	r7, #16
 8007e38:	46bd      	mov	sp, r7
 8007e3a:	bd80      	pop	{r7, pc}

08007e3c <USBD_StdEPReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007e3c:	b580      	push	{r7, lr}
 8007e3e:	b084      	sub	sp, #16
 8007e40:	af00      	add	r7, sp, #0
 8007e42:	6078      	str	r0, [r7, #4]
 8007e44:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  uint8_t idx;
  USBD_StatusTypeDef ret = USBD_OK;
 8007e46:	2300      	movs	r3, #0
 8007e48:	73fb      	strb	r3, [r7, #15]

  ep_addr = LOBYTE(req->wIndex);
 8007e4a:	683b      	ldr	r3, [r7, #0]
 8007e4c:	889b      	ldrh	r3, [r3, #4]
 8007e4e:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8007e50:	683b      	ldr	r3, [r7, #0]
 8007e52:	781b      	ldrb	r3, [r3, #0]
 8007e54:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8007e58:	2b40      	cmp	r3, #64	@ 0x40
 8007e5a:	d007      	beq.n	8007e6c <USBD_StdEPReq+0x30>
 8007e5c:	2b40      	cmp	r3, #64	@ 0x40
 8007e5e:	f200 817f 	bhi.w	8008160 <USBD_StdEPReq+0x324>
 8007e62:	2b00      	cmp	r3, #0
 8007e64:	d02a      	beq.n	8007ebc <USBD_StdEPReq+0x80>
 8007e66:	2b20      	cmp	r3, #32
 8007e68:	f040 817a 	bne.w	8008160 <USBD_StdEPReq+0x324>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      /* Get the class index relative to this endpoint */
      idx = USBD_CoreFindEP(pdev, ep_addr);
 8007e6c:	7bbb      	ldrb	r3, [r7, #14]
 8007e6e:	4619      	mov	r1, r3
 8007e70:	6878      	ldr	r0, [r7, #4]
 8007e72:	f7ff fe85 	bl	8007b80 <USBD_CoreFindEP>
 8007e76:	4603      	mov	r3, r0
 8007e78:	737b      	strb	r3, [r7, #13]
      if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007e7a:	7b7b      	ldrb	r3, [r7, #13]
 8007e7c:	2bff      	cmp	r3, #255	@ 0xff
 8007e7e:	f000 8174 	beq.w	800816a <USBD_StdEPReq+0x32e>
 8007e82:	7b7b      	ldrb	r3, [r7, #13]
 8007e84:	2b00      	cmp	r3, #0
 8007e86:	f040 8170 	bne.w	800816a <USBD_StdEPReq+0x32e>
      {
        pdev->classId = idx;
 8007e8a:	7b7a      	ldrb	r2, [r7, #13]
 8007e8c:	687b      	ldr	r3, [r7, #4]
 8007e8e:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
        /* Call the class data out function to manage the request */
        if (pdev->pClass[idx]->Setup != NULL)
 8007e92:	7b7a      	ldrb	r2, [r7, #13]
 8007e94:	687b      	ldr	r3, [r7, #4]
 8007e96:	32ae      	adds	r2, #174	@ 0xae
 8007e98:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007e9c:	689b      	ldr	r3, [r3, #8]
 8007e9e:	2b00      	cmp	r3, #0
 8007ea0:	f000 8163 	beq.w	800816a <USBD_StdEPReq+0x32e>
        {
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->Setup(pdev, req);
 8007ea4:	7b7a      	ldrb	r2, [r7, #13]
 8007ea6:	687b      	ldr	r3, [r7, #4]
 8007ea8:	32ae      	adds	r2, #174	@ 0xae
 8007eaa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007eae:	689b      	ldr	r3, [r3, #8]
 8007eb0:	6839      	ldr	r1, [r7, #0]
 8007eb2:	6878      	ldr	r0, [r7, #4]
 8007eb4:	4798      	blx	r3
 8007eb6:	4603      	mov	r3, r0
 8007eb8:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 8007eba:	e156      	b.n	800816a <USBD_StdEPReq+0x32e>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8007ebc:	683b      	ldr	r3, [r7, #0]
 8007ebe:	785b      	ldrb	r3, [r3, #1]
 8007ec0:	2b03      	cmp	r3, #3
 8007ec2:	d008      	beq.n	8007ed6 <USBD_StdEPReq+0x9a>
 8007ec4:	2b03      	cmp	r3, #3
 8007ec6:	f300 8145 	bgt.w	8008154 <USBD_StdEPReq+0x318>
 8007eca:	2b00      	cmp	r3, #0
 8007ecc:	f000 809b 	beq.w	8008006 <USBD_StdEPReq+0x1ca>
 8007ed0:	2b01      	cmp	r3, #1
 8007ed2:	d03c      	beq.n	8007f4e <USBD_StdEPReq+0x112>
 8007ed4:	e13e      	b.n	8008154 <USBD_StdEPReq+0x318>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
 8007ed6:	687b      	ldr	r3, [r7, #4]
 8007ed8:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007edc:	b2db      	uxtb	r3, r3
 8007ede:	2b02      	cmp	r3, #2
 8007ee0:	d002      	beq.n	8007ee8 <USBD_StdEPReq+0xac>
 8007ee2:	2b03      	cmp	r3, #3
 8007ee4:	d016      	beq.n	8007f14 <USBD_StdEPReq+0xd8>
 8007ee6:	e02c      	b.n	8007f42 <USBD_StdEPReq+0x106>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8007ee8:	7bbb      	ldrb	r3, [r7, #14]
 8007eea:	2b00      	cmp	r3, #0
 8007eec:	d00d      	beq.n	8007f0a <USBD_StdEPReq+0xce>
 8007eee:	7bbb      	ldrb	r3, [r7, #14]
 8007ef0:	2b80      	cmp	r3, #128	@ 0x80
 8007ef2:	d00a      	beq.n	8007f0a <USBD_StdEPReq+0xce>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8007ef4:	7bbb      	ldrb	r3, [r7, #14]
 8007ef6:	4619      	mov	r1, r3
 8007ef8:	6878      	ldr	r0, [r7, #4]
 8007efa:	f020 fa1b 	bl	8028334 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8007efe:	2180      	movs	r1, #128	@ 0x80
 8007f00:	6878      	ldr	r0, [r7, #4]
 8007f02:	f020 fa17 	bl	8028334 <USBD_LL_StallEP>
 8007f06:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8007f08:	e020      	b.n	8007f4c <USBD_StdEPReq+0x110>
                USBD_CtlError(pdev, req);
 8007f0a:	6839      	ldr	r1, [r7, #0]
 8007f0c:	6878      	ldr	r0, [r7, #4]
 8007f0e:	f000 fc7a 	bl	8008806 <USBD_CtlError>
              break;
 8007f12:	e01b      	b.n	8007f4c <USBD_StdEPReq+0x110>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8007f14:	683b      	ldr	r3, [r7, #0]
 8007f16:	885b      	ldrh	r3, [r3, #2]
 8007f18:	2b00      	cmp	r3, #0
 8007f1a:	d10e      	bne.n	8007f3a <USBD_StdEPReq+0xfe>
              {
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8007f1c:	7bbb      	ldrb	r3, [r7, #14]
 8007f1e:	2b00      	cmp	r3, #0
 8007f20:	d00b      	beq.n	8007f3a <USBD_StdEPReq+0xfe>
 8007f22:	7bbb      	ldrb	r3, [r7, #14]
 8007f24:	2b80      	cmp	r3, #128	@ 0x80
 8007f26:	d008      	beq.n	8007f3a <USBD_StdEPReq+0xfe>
 8007f28:	683b      	ldr	r3, [r7, #0]
 8007f2a:	88db      	ldrh	r3, [r3, #6]
 8007f2c:	2b00      	cmp	r3, #0
 8007f2e:	d104      	bne.n	8007f3a <USBD_StdEPReq+0xfe>
                {
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 8007f30:	7bbb      	ldrb	r3, [r7, #14]
 8007f32:	4619      	mov	r1, r3
 8007f34:	6878      	ldr	r0, [r7, #4]
 8007f36:	f020 f9fd 	bl	8028334 <USBD_LL_StallEP>
                }
              }
              (void)USBD_CtlSendStatus(pdev);
 8007f3a:	6878      	ldr	r0, [r7, #4]
 8007f3c:	f000 fd3a 	bl	80089b4 <USBD_CtlSendStatus>

              break;
 8007f40:	e004      	b.n	8007f4c <USBD_StdEPReq+0x110>

            default:
              USBD_CtlError(pdev, req);
 8007f42:	6839      	ldr	r1, [r7, #0]
 8007f44:	6878      	ldr	r0, [r7, #4]
 8007f46:	f000 fc5e 	bl	8008806 <USBD_CtlError>
              break;
 8007f4a:	bf00      	nop
          }
          break;
 8007f4c:	e107      	b.n	800815e <USBD_StdEPReq+0x322>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
 8007f4e:	687b      	ldr	r3, [r7, #4]
 8007f50:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007f54:	b2db      	uxtb	r3, r3
 8007f56:	2b02      	cmp	r3, #2
 8007f58:	d002      	beq.n	8007f60 <USBD_StdEPReq+0x124>
 8007f5a:	2b03      	cmp	r3, #3
 8007f5c:	d016      	beq.n	8007f8c <USBD_StdEPReq+0x150>
 8007f5e:	e04b      	b.n	8007ff8 <USBD_StdEPReq+0x1bc>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8007f60:	7bbb      	ldrb	r3, [r7, #14]
 8007f62:	2b00      	cmp	r3, #0
 8007f64:	d00d      	beq.n	8007f82 <USBD_StdEPReq+0x146>
 8007f66:	7bbb      	ldrb	r3, [r7, #14]
 8007f68:	2b80      	cmp	r3, #128	@ 0x80
 8007f6a:	d00a      	beq.n	8007f82 <USBD_StdEPReq+0x146>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8007f6c:	7bbb      	ldrb	r3, [r7, #14]
 8007f6e:	4619      	mov	r1, r3
 8007f70:	6878      	ldr	r0, [r7, #4]
 8007f72:	f020 f9df 	bl	8028334 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8007f76:	2180      	movs	r1, #128	@ 0x80
 8007f78:	6878      	ldr	r0, [r7, #4]
 8007f7a:	f020 f9db 	bl	8028334 <USBD_LL_StallEP>
 8007f7e:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8007f80:	e040      	b.n	8008004 <USBD_StdEPReq+0x1c8>
                USBD_CtlError(pdev, req);
 8007f82:	6839      	ldr	r1, [r7, #0]
 8007f84:	6878      	ldr	r0, [r7, #4]
 8007f86:	f000 fc3e 	bl	8008806 <USBD_CtlError>
              break;
 8007f8a:	e03b      	b.n	8008004 <USBD_StdEPReq+0x1c8>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8007f8c:	683b      	ldr	r3, [r7, #0]
 8007f8e:	885b      	ldrh	r3, [r3, #2]
 8007f90:	2b00      	cmp	r3, #0
 8007f92:	d136      	bne.n	8008002 <USBD_StdEPReq+0x1c6>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
 8007f94:	7bbb      	ldrb	r3, [r7, #14]
 8007f96:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8007f9a:	2b00      	cmp	r3, #0
 8007f9c:	d004      	beq.n	8007fa8 <USBD_StdEPReq+0x16c>
                {
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 8007f9e:	7bbb      	ldrb	r3, [r7, #14]
 8007fa0:	4619      	mov	r1, r3
 8007fa2:	6878      	ldr	r0, [r7, #4]
 8007fa4:	f020 f9e5 	bl	8028372 <USBD_LL_ClearStallEP>
                }
                (void)USBD_CtlSendStatus(pdev);
 8007fa8:	6878      	ldr	r0, [r7, #4]
 8007faa:	f000 fd03 	bl	80089b4 <USBD_CtlSendStatus>

                /* Get the class index relative to this interface */
                idx = USBD_CoreFindEP(pdev, ep_addr);
 8007fae:	7bbb      	ldrb	r3, [r7, #14]
 8007fb0:	4619      	mov	r1, r3
 8007fb2:	6878      	ldr	r0, [r7, #4]
 8007fb4:	f7ff fde4 	bl	8007b80 <USBD_CoreFindEP>
 8007fb8:	4603      	mov	r3, r0
 8007fba:	737b      	strb	r3, [r7, #13]
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007fbc:	7b7b      	ldrb	r3, [r7, #13]
 8007fbe:	2bff      	cmp	r3, #255	@ 0xff
 8007fc0:	d01f      	beq.n	8008002 <USBD_StdEPReq+0x1c6>
 8007fc2:	7b7b      	ldrb	r3, [r7, #13]
 8007fc4:	2b00      	cmp	r3, #0
 8007fc6:	d11c      	bne.n	8008002 <USBD_StdEPReq+0x1c6>
                {
                  pdev->classId = idx;
 8007fc8:	7b7a      	ldrb	r2, [r7, #13]
 8007fca:	687b      	ldr	r3, [r7, #4]
 8007fcc:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                  /* Call the class data out function to manage the request */
                  if (pdev->pClass[idx]->Setup != NULL)
 8007fd0:	7b7a      	ldrb	r2, [r7, #13]
 8007fd2:	687b      	ldr	r3, [r7, #4]
 8007fd4:	32ae      	adds	r2, #174	@ 0xae
 8007fd6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007fda:	689b      	ldr	r3, [r3, #8]
 8007fdc:	2b00      	cmp	r3, #0
 8007fde:	d010      	beq.n	8008002 <USBD_StdEPReq+0x1c6>
                  {
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8007fe0:	7b7a      	ldrb	r2, [r7, #13]
 8007fe2:	687b      	ldr	r3, [r7, #4]
 8007fe4:	32ae      	adds	r2, #174	@ 0xae
 8007fe6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007fea:	689b      	ldr	r3, [r3, #8]
 8007fec:	6839      	ldr	r1, [r7, #0]
 8007fee:	6878      	ldr	r0, [r7, #4]
 8007ff0:	4798      	blx	r3
 8007ff2:	4603      	mov	r3, r0
 8007ff4:	73fb      	strb	r3, [r7, #15]
                  }
                }
              }
              break;
 8007ff6:	e004      	b.n	8008002 <USBD_StdEPReq+0x1c6>

            default:
              USBD_CtlError(pdev, req);
 8007ff8:	6839      	ldr	r1, [r7, #0]
 8007ffa:	6878      	ldr	r0, [r7, #4]
 8007ffc:	f000 fc03 	bl	8008806 <USBD_CtlError>
              break;
 8008000:	e000      	b.n	8008004 <USBD_StdEPReq+0x1c8>
              break;
 8008002:	bf00      	nop
          }
          break;
 8008004:	e0ab      	b.n	800815e <USBD_StdEPReq+0x322>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
 8008006:	687b      	ldr	r3, [r7, #4]
 8008008:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 800800c:	b2db      	uxtb	r3, r3
 800800e:	2b02      	cmp	r3, #2
 8008010:	d002      	beq.n	8008018 <USBD_StdEPReq+0x1dc>
 8008012:	2b03      	cmp	r3, #3
 8008014:	d032      	beq.n	800807c <USBD_StdEPReq+0x240>
 8008016:	e097      	b.n	8008148 <USBD_StdEPReq+0x30c>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8008018:	7bbb      	ldrb	r3, [r7, #14]
 800801a:	2b00      	cmp	r3, #0
 800801c:	d007      	beq.n	800802e <USBD_StdEPReq+0x1f2>
 800801e:	7bbb      	ldrb	r3, [r7, #14]
 8008020:	2b80      	cmp	r3, #128	@ 0x80
 8008022:	d004      	beq.n	800802e <USBD_StdEPReq+0x1f2>
              {
                USBD_CtlError(pdev, req);
 8008024:	6839      	ldr	r1, [r7, #0]
 8008026:	6878      	ldr	r0, [r7, #4]
 8008028:	f000 fbed 	bl	8008806 <USBD_CtlError>
                break;
 800802c:	e091      	b.n	8008152 <USBD_StdEPReq+0x316>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800802e:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8008032:	2b00      	cmp	r3, #0
 8008034:	da0b      	bge.n	800804e <USBD_StdEPReq+0x212>
 8008036:	7bbb      	ldrb	r3, [r7, #14]
 8008038:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800803c:	4613      	mov	r3, r2
 800803e:	009b      	lsls	r3, r3, #2
 8008040:	4413      	add	r3, r2
 8008042:	009b      	lsls	r3, r3, #2
 8008044:	3310      	adds	r3, #16
 8008046:	687a      	ldr	r2, [r7, #4]
 8008048:	4413      	add	r3, r2
 800804a:	3304      	adds	r3, #4
 800804c:	e00b      	b.n	8008066 <USBD_StdEPReq+0x22a>
                    &pdev->ep_out[ep_addr & 0x7FU];
 800804e:	7bbb      	ldrb	r3, [r7, #14]
 8008050:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8008054:	4613      	mov	r3, r2
 8008056:	009b      	lsls	r3, r3, #2
 8008058:	4413      	add	r3, r2
 800805a:	009b      	lsls	r3, r3, #2
 800805c:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8008060:	687a      	ldr	r2, [r7, #4]
 8008062:	4413      	add	r3, r2
 8008064:	3304      	adds	r3, #4
 8008066:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
 8008068:	68bb      	ldr	r3, [r7, #8]
 800806a:	2200      	movs	r2, #0
 800806c:	601a      	str	r2, [r3, #0]

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 800806e:	68bb      	ldr	r3, [r7, #8]
 8008070:	2202      	movs	r2, #2
 8008072:	4619      	mov	r1, r3
 8008074:	6878      	ldr	r0, [r7, #4]
 8008076:	f000 fc43 	bl	8008900 <USBD_CtlSendData>
              break;
 800807a:	e06a      	b.n	8008152 <USBD_StdEPReq+0x316>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
 800807c:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8008080:	2b00      	cmp	r3, #0
 8008082:	da11      	bge.n	80080a8 <USBD_StdEPReq+0x26c>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8008084:	7bbb      	ldrb	r3, [r7, #14]
 8008086:	f003 020f 	and.w	r2, r3, #15
 800808a:	6879      	ldr	r1, [r7, #4]
 800808c:	4613      	mov	r3, r2
 800808e:	009b      	lsls	r3, r3, #2
 8008090:	4413      	add	r3, r2
 8008092:	009b      	lsls	r3, r3, #2
 8008094:	440b      	add	r3, r1
 8008096:	3324      	adds	r3, #36	@ 0x24
 8008098:	881b      	ldrh	r3, [r3, #0]
 800809a:	2b00      	cmp	r3, #0
 800809c:	d117      	bne.n	80080ce <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 800809e:	6839      	ldr	r1, [r7, #0]
 80080a0:	6878      	ldr	r0, [r7, #4]
 80080a2:	f000 fbb0 	bl	8008806 <USBD_CtlError>
                  break;
 80080a6:	e054      	b.n	8008152 <USBD_StdEPReq+0x316>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 80080a8:	7bbb      	ldrb	r3, [r7, #14]
 80080aa:	f003 020f 	and.w	r2, r3, #15
 80080ae:	6879      	ldr	r1, [r7, #4]
 80080b0:	4613      	mov	r3, r2
 80080b2:	009b      	lsls	r3, r3, #2
 80080b4:	4413      	add	r3, r2
 80080b6:	009b      	lsls	r3, r3, #2
 80080b8:	440b      	add	r3, r1
 80080ba:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 80080be:	881b      	ldrh	r3, [r3, #0]
 80080c0:	2b00      	cmp	r3, #0
 80080c2:	d104      	bne.n	80080ce <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 80080c4:	6839      	ldr	r1, [r7, #0]
 80080c6:	6878      	ldr	r0, [r7, #4]
 80080c8:	f000 fb9d 	bl	8008806 <USBD_CtlError>
                  break;
 80080cc:	e041      	b.n	8008152 <USBD_StdEPReq+0x316>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80080ce:	f997 300e 	ldrsb.w	r3, [r7, #14]
 80080d2:	2b00      	cmp	r3, #0
 80080d4:	da0b      	bge.n	80080ee <USBD_StdEPReq+0x2b2>
 80080d6:	7bbb      	ldrb	r3, [r7, #14]
 80080d8:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 80080dc:	4613      	mov	r3, r2
 80080de:	009b      	lsls	r3, r3, #2
 80080e0:	4413      	add	r3, r2
 80080e2:	009b      	lsls	r3, r3, #2
 80080e4:	3310      	adds	r3, #16
 80080e6:	687a      	ldr	r2, [r7, #4]
 80080e8:	4413      	add	r3, r2
 80080ea:	3304      	adds	r3, #4
 80080ec:	e00b      	b.n	8008106 <USBD_StdEPReq+0x2ca>
                    &pdev->ep_out[ep_addr & 0x7FU];
 80080ee:	7bbb      	ldrb	r3, [r7, #14]
 80080f0:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80080f4:	4613      	mov	r3, r2
 80080f6:	009b      	lsls	r3, r3, #2
 80080f8:	4413      	add	r3, r2
 80080fa:	009b      	lsls	r3, r3, #2
 80080fc:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8008100:	687a      	ldr	r2, [r7, #4]
 8008102:	4413      	add	r3, r2
 8008104:	3304      	adds	r3, #4
 8008106:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8008108:	7bbb      	ldrb	r3, [r7, #14]
 800810a:	2b00      	cmp	r3, #0
 800810c:	d002      	beq.n	8008114 <USBD_StdEPReq+0x2d8>
 800810e:	7bbb      	ldrb	r3, [r7, #14]
 8008110:	2b80      	cmp	r3, #128	@ 0x80
 8008112:	d103      	bne.n	800811c <USBD_StdEPReq+0x2e0>
              {
                pep->status = 0x0000U;
 8008114:	68bb      	ldr	r3, [r7, #8]
 8008116:	2200      	movs	r2, #0
 8008118:	601a      	str	r2, [r3, #0]
 800811a:	e00e      	b.n	800813a <USBD_StdEPReq+0x2fe>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 800811c:	7bbb      	ldrb	r3, [r7, #14]
 800811e:	4619      	mov	r1, r3
 8008120:	6878      	ldr	r0, [r7, #4]
 8008122:	f020 f945 	bl	80283b0 <USBD_LL_IsStallEP>
 8008126:	4603      	mov	r3, r0
 8008128:	2b00      	cmp	r3, #0
 800812a:	d003      	beq.n	8008134 <USBD_StdEPReq+0x2f8>
              {
                pep->status = 0x0001U;
 800812c:	68bb      	ldr	r3, [r7, #8]
 800812e:	2201      	movs	r2, #1
 8008130:	601a      	str	r2, [r3, #0]
 8008132:	e002      	b.n	800813a <USBD_StdEPReq+0x2fe>
              }
              else
              {
                pep->status = 0x0000U;
 8008134:	68bb      	ldr	r3, [r7, #8]
 8008136:	2200      	movs	r2, #0
 8008138:	601a      	str	r2, [r3, #0]
              }

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 800813a:	68bb      	ldr	r3, [r7, #8]
 800813c:	2202      	movs	r2, #2
 800813e:	4619      	mov	r1, r3
 8008140:	6878      	ldr	r0, [r7, #4]
 8008142:	f000 fbdd 	bl	8008900 <USBD_CtlSendData>
              break;
 8008146:	e004      	b.n	8008152 <USBD_StdEPReq+0x316>

            default:
              USBD_CtlError(pdev, req);
 8008148:	6839      	ldr	r1, [r7, #0]
 800814a:	6878      	ldr	r0, [r7, #4]
 800814c:	f000 fb5b 	bl	8008806 <USBD_CtlError>
              break;
 8008150:	bf00      	nop
          }
          break;
 8008152:	e004      	b.n	800815e <USBD_StdEPReq+0x322>

        default:
          USBD_CtlError(pdev, req);
 8008154:	6839      	ldr	r1, [r7, #0]
 8008156:	6878      	ldr	r0, [r7, #4]
 8008158:	f000 fb55 	bl	8008806 <USBD_CtlError>
          break;
 800815c:	bf00      	nop
      }
      break;
 800815e:	e005      	b.n	800816c <USBD_StdEPReq+0x330>

    default:
      USBD_CtlError(pdev, req);
 8008160:	6839      	ldr	r1, [r7, #0]
 8008162:	6878      	ldr	r0, [r7, #4]
 8008164:	f000 fb4f 	bl	8008806 <USBD_CtlError>
      break;
 8008168:	e000      	b.n	800816c <USBD_StdEPReq+0x330>
      break;
 800816a:	bf00      	nop
  }

  return ret;
 800816c:	7bfb      	ldrb	r3, [r7, #15]
}
 800816e:	4618      	mov	r0, r3
 8008170:	3710      	adds	r7, #16
 8008172:	46bd      	mov	sp, r7
 8008174:	bd80      	pop	{r7, pc}
	...

08008178 <USBD_GetDescriptor>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008178:	b580      	push	{r7, lr}
 800817a:	b084      	sub	sp, #16
 800817c:	af00      	add	r7, sp, #0
 800817e:	6078      	str	r0, [r7, #4]
 8008180:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8008182:	2300      	movs	r3, #0
 8008184:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
 8008186:	2300      	movs	r3, #0
 8008188:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 800818a:	2300      	movs	r3, #0
 800818c:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
 800818e:	683b      	ldr	r3, [r7, #0]
 8008190:	885b      	ldrh	r3, [r3, #2]
 8008192:	0a1b      	lsrs	r3, r3, #8
 8008194:	b29b      	uxth	r3, r3
 8008196:	3b01      	subs	r3, #1
 8008198:	2b06      	cmp	r3, #6
 800819a:	f200 8128 	bhi.w	80083ee <USBD_GetDescriptor+0x276>
 800819e:	a201      	add	r2, pc, #4	@ (adr r2, 80081a4 <USBD_GetDescriptor+0x2c>)
 80081a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80081a4:	080081c1 	.word	0x080081c1
 80081a8:	080081d9 	.word	0x080081d9
 80081ac:	08008219 	.word	0x08008219
 80081b0:	080083ef 	.word	0x080083ef
 80081b4:	080083ef 	.word	0x080083ef
 80081b8:	0800838f 	.word	0x0800838f
 80081bc:	080083bb 	.word	0x080083bb
        err++;
      }
      break;
#endif /* (USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U) */
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 80081c0:	687b      	ldr	r3, [r7, #4]
 80081c2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80081c6:	681b      	ldr	r3, [r3, #0]
 80081c8:	687a      	ldr	r2, [r7, #4]
 80081ca:	7c12      	ldrb	r2, [r2, #16]
 80081cc:	f107 0108 	add.w	r1, r7, #8
 80081d0:	4610      	mov	r0, r2
 80081d2:	4798      	blx	r3
 80081d4:	60f8      	str	r0, [r7, #12]
      break;
 80081d6:	e112      	b.n	80083fe <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 80081d8:	687b      	ldr	r3, [r7, #4]
 80081da:	7c1b      	ldrb	r3, [r3, #16]
 80081dc:	2b00      	cmp	r3, #0
 80081de:	d10d      	bne.n	80081fc <USBD_GetDescriptor+0x84>
          pbuf = (uint8_t *)USBD_CMPSIT.GetHSConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 80081e0:	687b      	ldr	r3, [r7, #4]
 80081e2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80081e6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80081e8:	f107 0208 	add.w	r2, r7, #8
 80081ec:	4610      	mov	r0, r2
 80081ee:	4798      	blx	r3
 80081f0:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80081f2:	68fb      	ldr	r3, [r7, #12]
 80081f4:	3301      	adds	r3, #1
 80081f6:	2202      	movs	r2, #2
 80081f8:	701a      	strb	r2, [r3, #0]
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
 80081fa:	e100      	b.n	80083fe <USBD_GetDescriptor+0x286>
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 80081fc:	687b      	ldr	r3, [r7, #4]
 80081fe:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8008202:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008204:	f107 0208 	add.w	r2, r7, #8
 8008208:	4610      	mov	r0, r2
 800820a:	4798      	blx	r3
 800820c:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800820e:	68fb      	ldr	r3, [r7, #12]
 8008210:	3301      	adds	r3, #1
 8008212:	2202      	movs	r2, #2
 8008214:	701a      	strb	r2, [r3, #0]
      break;
 8008216:	e0f2      	b.n	80083fe <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
 8008218:	683b      	ldr	r3, [r7, #0]
 800821a:	885b      	ldrh	r3, [r3, #2]
 800821c:	b2db      	uxtb	r3, r3
 800821e:	2b05      	cmp	r3, #5
 8008220:	f200 80ac 	bhi.w	800837c <USBD_GetDescriptor+0x204>
 8008224:	a201      	add	r2, pc, #4	@ (adr r2, 800822c <USBD_GetDescriptor+0xb4>)
 8008226:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800822a:	bf00      	nop
 800822c:	08008245 	.word	0x08008245
 8008230:	08008279 	.word	0x08008279
 8008234:	080082ad 	.word	0x080082ad
 8008238:	080082e1 	.word	0x080082e1
 800823c:	08008315 	.word	0x08008315
 8008240:	08008349 	.word	0x08008349
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8008244:	687b      	ldr	r3, [r7, #4]
 8008246:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800824a:	685b      	ldr	r3, [r3, #4]
 800824c:	2b00      	cmp	r3, #0
 800824e:	d00b      	beq.n	8008268 <USBD_GetDescriptor+0xf0>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 8008250:	687b      	ldr	r3, [r7, #4]
 8008252:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8008256:	685b      	ldr	r3, [r3, #4]
 8008258:	687a      	ldr	r2, [r7, #4]
 800825a:	7c12      	ldrb	r2, [r2, #16]
 800825c:	f107 0108 	add.w	r1, r7, #8
 8008260:	4610      	mov	r0, r2
 8008262:	4798      	blx	r3
 8008264:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8008266:	e091      	b.n	800838c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8008268:	6839      	ldr	r1, [r7, #0]
 800826a:	6878      	ldr	r0, [r7, #4]
 800826c:	f000 facb 	bl	8008806 <USBD_CtlError>
            err++;
 8008270:	7afb      	ldrb	r3, [r7, #11]
 8008272:	3301      	adds	r3, #1
 8008274:	72fb      	strb	r3, [r7, #11]
          break;
 8008276:	e089      	b.n	800838c <USBD_GetDescriptor+0x214>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8008278:	687b      	ldr	r3, [r7, #4]
 800827a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800827e:	689b      	ldr	r3, [r3, #8]
 8008280:	2b00      	cmp	r3, #0
 8008282:	d00b      	beq.n	800829c <USBD_GetDescriptor+0x124>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8008284:	687b      	ldr	r3, [r7, #4]
 8008286:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800828a:	689b      	ldr	r3, [r3, #8]
 800828c:	687a      	ldr	r2, [r7, #4]
 800828e:	7c12      	ldrb	r2, [r2, #16]
 8008290:	f107 0108 	add.w	r1, r7, #8
 8008294:	4610      	mov	r0, r2
 8008296:	4798      	blx	r3
 8008298:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 800829a:	e077      	b.n	800838c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 800829c:	6839      	ldr	r1, [r7, #0]
 800829e:	6878      	ldr	r0, [r7, #4]
 80082a0:	f000 fab1 	bl	8008806 <USBD_CtlError>
            err++;
 80082a4:	7afb      	ldrb	r3, [r7, #11]
 80082a6:	3301      	adds	r3, #1
 80082a8:	72fb      	strb	r3, [r7, #11]
          break;
 80082aa:	e06f      	b.n	800838c <USBD_GetDescriptor+0x214>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 80082ac:	687b      	ldr	r3, [r7, #4]
 80082ae:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80082b2:	68db      	ldr	r3, [r3, #12]
 80082b4:	2b00      	cmp	r3, #0
 80082b6:	d00b      	beq.n	80082d0 <USBD_GetDescriptor+0x158>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 80082b8:	687b      	ldr	r3, [r7, #4]
 80082ba:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80082be:	68db      	ldr	r3, [r3, #12]
 80082c0:	687a      	ldr	r2, [r7, #4]
 80082c2:	7c12      	ldrb	r2, [r2, #16]
 80082c4:	f107 0108 	add.w	r1, r7, #8
 80082c8:	4610      	mov	r0, r2
 80082ca:	4798      	blx	r3
 80082cc:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 80082ce:	e05d      	b.n	800838c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 80082d0:	6839      	ldr	r1, [r7, #0]
 80082d2:	6878      	ldr	r0, [r7, #4]
 80082d4:	f000 fa97 	bl	8008806 <USBD_CtlError>
            err++;
 80082d8:	7afb      	ldrb	r3, [r7, #11]
 80082da:	3301      	adds	r3, #1
 80082dc:	72fb      	strb	r3, [r7, #11]
          break;
 80082de:	e055      	b.n	800838c <USBD_GetDescriptor+0x214>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 80082e0:	687b      	ldr	r3, [r7, #4]
 80082e2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80082e6:	691b      	ldr	r3, [r3, #16]
 80082e8:	2b00      	cmp	r3, #0
 80082ea:	d00b      	beq.n	8008304 <USBD_GetDescriptor+0x18c>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 80082ec:	687b      	ldr	r3, [r7, #4]
 80082ee:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80082f2:	691b      	ldr	r3, [r3, #16]
 80082f4:	687a      	ldr	r2, [r7, #4]
 80082f6:	7c12      	ldrb	r2, [r2, #16]
 80082f8:	f107 0108 	add.w	r1, r7, #8
 80082fc:	4610      	mov	r0, r2
 80082fe:	4798      	blx	r3
 8008300:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8008302:	e043      	b.n	800838c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8008304:	6839      	ldr	r1, [r7, #0]
 8008306:	6878      	ldr	r0, [r7, #4]
 8008308:	f000 fa7d 	bl	8008806 <USBD_CtlError>
            err++;
 800830c:	7afb      	ldrb	r3, [r7, #11]
 800830e:	3301      	adds	r3, #1
 8008310:	72fb      	strb	r3, [r7, #11]
          break;
 8008312:	e03b      	b.n	800838c <USBD_GetDescriptor+0x214>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 8008314:	687b      	ldr	r3, [r7, #4]
 8008316:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800831a:	695b      	ldr	r3, [r3, #20]
 800831c:	2b00      	cmp	r3, #0
 800831e:	d00b      	beq.n	8008338 <USBD_GetDescriptor+0x1c0>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8008320:	687b      	ldr	r3, [r7, #4]
 8008322:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8008326:	695b      	ldr	r3, [r3, #20]
 8008328:	687a      	ldr	r2, [r7, #4]
 800832a:	7c12      	ldrb	r2, [r2, #16]
 800832c:	f107 0108 	add.w	r1, r7, #8
 8008330:	4610      	mov	r0, r2
 8008332:	4798      	blx	r3
 8008334:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8008336:	e029      	b.n	800838c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8008338:	6839      	ldr	r1, [r7, #0]
 800833a:	6878      	ldr	r0, [r7, #4]
 800833c:	f000 fa63 	bl	8008806 <USBD_CtlError>
            err++;
 8008340:	7afb      	ldrb	r3, [r7, #11]
 8008342:	3301      	adds	r3, #1
 8008344:	72fb      	strb	r3, [r7, #11]
          break;
 8008346:	e021      	b.n	800838c <USBD_GetDescriptor+0x214>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 8008348:	687b      	ldr	r3, [r7, #4]
 800834a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800834e:	699b      	ldr	r3, [r3, #24]
 8008350:	2b00      	cmp	r3, #0
 8008352:	d00b      	beq.n	800836c <USBD_GetDescriptor+0x1f4>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8008354:	687b      	ldr	r3, [r7, #4]
 8008356:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800835a:	699b      	ldr	r3, [r3, #24]
 800835c:	687a      	ldr	r2, [r7, #4]
 800835e:	7c12      	ldrb	r2, [r2, #16]
 8008360:	f107 0108 	add.w	r1, r7, #8
 8008364:	4610      	mov	r0, r2
 8008366:	4798      	blx	r3
 8008368:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 800836a:	e00f      	b.n	800838c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 800836c:	6839      	ldr	r1, [r7, #0]
 800836e:	6878      	ldr	r0, [r7, #4]
 8008370:	f000 fa49 	bl	8008806 <USBD_CtlError>
            err++;
 8008374:	7afb      	ldrb	r3, [r7, #11]
 8008376:	3301      	adds	r3, #1
 8008378:	72fb      	strb	r3, [r7, #11]
          break;
 800837a:	e007      	b.n	800838c <USBD_GetDescriptor+0x214>
            err++;
          }
#endif /* USBD_SUPPORT_USER_STRING_DESC  */

#if ((USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U))
          USBD_CtlError(pdev, req);
 800837c:	6839      	ldr	r1, [r7, #0]
 800837e:	6878      	ldr	r0, [r7, #4]
 8008380:	f000 fa41 	bl	8008806 <USBD_CtlError>
          err++;
 8008384:	7afb      	ldrb	r3, [r7, #11]
 8008386:	3301      	adds	r3, #1
 8008388:	72fb      	strb	r3, [r7, #11]
#endif /* (USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U) */
          break;
 800838a:	bf00      	nop
      }
      break;
 800838c:	e037      	b.n	80083fe <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800838e:	687b      	ldr	r3, [r7, #4]
 8008390:	7c1b      	ldrb	r3, [r3, #16]
 8008392:	2b00      	cmp	r3, #0
 8008394:	d109      	bne.n	80083aa <USBD_GetDescriptor+0x232>
          pbuf = (uint8_t *)USBD_CMPSIT.GetDeviceQualifierDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 8008396:	687b      	ldr	r3, [r7, #4]
 8008398:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 800839c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800839e:	f107 0208 	add.w	r2, r7, #8
 80083a2:	4610      	mov	r0, r2
 80083a4:	4798      	blx	r3
 80083a6:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 80083a8:	e029      	b.n	80083fe <USBD_GetDescriptor+0x286>
        USBD_CtlError(pdev, req);
 80083aa:	6839      	ldr	r1, [r7, #0]
 80083ac:	6878      	ldr	r0, [r7, #4]
 80083ae:	f000 fa2a 	bl	8008806 <USBD_CtlError>
        err++;
 80083b2:	7afb      	ldrb	r3, [r7, #11]
 80083b4:	3301      	adds	r3, #1
 80083b6:	72fb      	strb	r3, [r7, #11]
      break;
 80083b8:	e021      	b.n	80083fe <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 80083ba:	687b      	ldr	r3, [r7, #4]
 80083bc:	7c1b      	ldrb	r3, [r3, #16]
 80083be:	2b00      	cmp	r3, #0
 80083c0:	d10d      	bne.n	80083de <USBD_GetDescriptor+0x266>
          pbuf = (uint8_t *)USBD_CMPSIT.GetOtherSpeedConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 80083c2:	687b      	ldr	r3, [r7, #4]
 80083c4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80083c8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80083ca:	f107 0208 	add.w	r2, r7, #8
 80083ce:	4610      	mov	r0, r2
 80083d0:	4798      	blx	r3
 80083d2:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 80083d4:	68fb      	ldr	r3, [r7, #12]
 80083d6:	3301      	adds	r3, #1
 80083d8:	2207      	movs	r2, #7
 80083da:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 80083dc:	e00f      	b.n	80083fe <USBD_GetDescriptor+0x286>
        USBD_CtlError(pdev, req);
 80083de:	6839      	ldr	r1, [r7, #0]
 80083e0:	6878      	ldr	r0, [r7, #4]
 80083e2:	f000 fa10 	bl	8008806 <USBD_CtlError>
        err++;
 80083e6:	7afb      	ldrb	r3, [r7, #11]
 80083e8:	3301      	adds	r3, #1
 80083ea:	72fb      	strb	r3, [r7, #11]
      break;
 80083ec:	e007      	b.n	80083fe <USBD_GetDescriptor+0x286>

    default:
      USBD_CtlError(pdev, req);
 80083ee:	6839      	ldr	r1, [r7, #0]
 80083f0:	6878      	ldr	r0, [r7, #4]
 80083f2:	f000 fa08 	bl	8008806 <USBD_CtlError>
      err++;
 80083f6:	7afb      	ldrb	r3, [r7, #11]
 80083f8:	3301      	adds	r3, #1
 80083fa:	72fb      	strb	r3, [r7, #11]
      break;
 80083fc:	bf00      	nop
  }

  if (err != 0U)
 80083fe:	7afb      	ldrb	r3, [r7, #11]
 8008400:	2b00      	cmp	r3, #0
 8008402:	d11e      	bne.n	8008442 <USBD_GetDescriptor+0x2ca>
  {
    return;
  }

  if (req->wLength != 0U)
 8008404:	683b      	ldr	r3, [r7, #0]
 8008406:	88db      	ldrh	r3, [r3, #6]
 8008408:	2b00      	cmp	r3, #0
 800840a:	d016      	beq.n	800843a <USBD_GetDescriptor+0x2c2>
  {
    if (len != 0U)
 800840c:	893b      	ldrh	r3, [r7, #8]
 800840e:	2b00      	cmp	r3, #0
 8008410:	d00e      	beq.n	8008430 <USBD_GetDescriptor+0x2b8>
    {
      len = MIN(len, req->wLength);
 8008412:	683b      	ldr	r3, [r7, #0]
 8008414:	88da      	ldrh	r2, [r3, #6]
 8008416:	893b      	ldrh	r3, [r7, #8]
 8008418:	4293      	cmp	r3, r2
 800841a:	bf28      	it	cs
 800841c:	4613      	movcs	r3, r2
 800841e:	b29b      	uxth	r3, r3
 8008420:	813b      	strh	r3, [r7, #8]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 8008422:	893b      	ldrh	r3, [r7, #8]
 8008424:	461a      	mov	r2, r3
 8008426:	68f9      	ldr	r1, [r7, #12]
 8008428:	6878      	ldr	r0, [r7, #4]
 800842a:	f000 fa69 	bl	8008900 <USBD_CtlSendData>
 800842e:	e009      	b.n	8008444 <USBD_GetDescriptor+0x2cc>
    }
    else
    {
      USBD_CtlError(pdev, req);
 8008430:	6839      	ldr	r1, [r7, #0]
 8008432:	6878      	ldr	r0, [r7, #4]
 8008434:	f000 f9e7 	bl	8008806 <USBD_CtlError>
 8008438:	e004      	b.n	8008444 <USBD_GetDescriptor+0x2cc>
    }
  }
  else
  {
    (void)USBD_CtlSendStatus(pdev);
 800843a:	6878      	ldr	r0, [r7, #4]
 800843c:	f000 faba 	bl	80089b4 <USBD_CtlSendStatus>
 8008440:	e000      	b.n	8008444 <USBD_GetDescriptor+0x2cc>
    return;
 8008442:	bf00      	nop
  }
}
 8008444:	3710      	adds	r7, #16
 8008446:	46bd      	mov	sp, r7
 8008448:	bd80      	pop	{r7, pc}
 800844a:	bf00      	nop

0800844c <USBD_SetAddress>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 800844c:	b580      	push	{r7, lr}
 800844e:	b084      	sub	sp, #16
 8008450:	af00      	add	r7, sp, #0
 8008452:	6078      	str	r0, [r7, #4]
 8008454:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 8008456:	683b      	ldr	r3, [r7, #0]
 8008458:	889b      	ldrh	r3, [r3, #4]
 800845a:	2b00      	cmp	r3, #0
 800845c:	d131      	bne.n	80084c2 <USBD_SetAddress+0x76>
 800845e:	683b      	ldr	r3, [r7, #0]
 8008460:	88db      	ldrh	r3, [r3, #6]
 8008462:	2b00      	cmp	r3, #0
 8008464:	d12d      	bne.n	80084c2 <USBD_SetAddress+0x76>
 8008466:	683b      	ldr	r3, [r7, #0]
 8008468:	885b      	ldrh	r3, [r3, #2]
 800846a:	2b7f      	cmp	r3, #127	@ 0x7f
 800846c:	d829      	bhi.n	80084c2 <USBD_SetAddress+0x76>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 800846e:	683b      	ldr	r3, [r7, #0]
 8008470:	885b      	ldrh	r3, [r3, #2]
 8008472:	b2db      	uxtb	r3, r3
 8008474:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8008478:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800847a:	687b      	ldr	r3, [r7, #4]
 800847c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8008480:	b2db      	uxtb	r3, r3
 8008482:	2b03      	cmp	r3, #3
 8008484:	d104      	bne.n	8008490 <USBD_SetAddress+0x44>
    {
      USBD_CtlError(pdev, req);
 8008486:	6839      	ldr	r1, [r7, #0]
 8008488:	6878      	ldr	r0, [r7, #4]
 800848a:	f000 f9bc 	bl	8008806 <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800848e:	e01d      	b.n	80084cc <USBD_SetAddress+0x80>
    }
    else
    {
      pdev->dev_address = dev_addr;
 8008490:	687b      	ldr	r3, [r7, #4]
 8008492:	7bfa      	ldrb	r2, [r7, #15]
 8008494:	f883 229e 	strb.w	r2, [r3, #670]	@ 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 8008498:	7bfb      	ldrb	r3, [r7, #15]
 800849a:	4619      	mov	r1, r3
 800849c:	6878      	ldr	r0, [r7, #4]
 800849e:	f01f ffb3 	bl	8028408 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 80084a2:	6878      	ldr	r0, [r7, #4]
 80084a4:	f000 fa86 	bl	80089b4 <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 80084a8:	7bfb      	ldrb	r3, [r7, #15]
 80084aa:	2b00      	cmp	r3, #0
 80084ac:	d004      	beq.n	80084b8 <USBD_SetAddress+0x6c>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80084ae:	687b      	ldr	r3, [r7, #4]
 80084b0:	2202      	movs	r2, #2
 80084b2:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80084b6:	e009      	b.n	80084cc <USBD_SetAddress+0x80>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 80084b8:	687b      	ldr	r3, [r7, #4]
 80084ba:	2201      	movs	r2, #1
 80084bc:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80084c0:	e004      	b.n	80084cc <USBD_SetAddress+0x80>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 80084c2:	6839      	ldr	r1, [r7, #0]
 80084c4:	6878      	ldr	r0, [r7, #4]
 80084c6:	f000 f99e 	bl	8008806 <USBD_CtlError>
  }
}
 80084ca:	bf00      	nop
 80084cc:	bf00      	nop
 80084ce:	3710      	adds	r7, #16
 80084d0:	46bd      	mov	sp, r7
 80084d2:	bd80      	pop	{r7, pc}

080084d4 <USBD_SetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80084d4:	b580      	push	{r7, lr}
 80084d6:	b084      	sub	sp, #16
 80084d8:	af00      	add	r7, sp, #0
 80084da:	6078      	str	r0, [r7, #4]
 80084dc:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 80084de:	2300      	movs	r3, #0
 80084e0:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 80084e2:	683b      	ldr	r3, [r7, #0]
 80084e4:	885b      	ldrh	r3, [r3, #2]
 80084e6:	b2da      	uxtb	r2, r3
 80084e8:	4b4e      	ldr	r3, [pc, #312]	@ (8008624 <USBD_SetConfig+0x150>)
 80084ea:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 80084ec:	4b4d      	ldr	r3, [pc, #308]	@ (8008624 <USBD_SetConfig+0x150>)
 80084ee:	781b      	ldrb	r3, [r3, #0]
 80084f0:	2b01      	cmp	r3, #1
 80084f2:	d905      	bls.n	8008500 <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
 80084f4:	6839      	ldr	r1, [r7, #0]
 80084f6:	6878      	ldr	r0, [r7, #4]
 80084f8:	f000 f985 	bl	8008806 <USBD_CtlError>
    return USBD_FAIL;
 80084fc:	2303      	movs	r3, #3
 80084fe:	e08c      	b.n	800861a <USBD_SetConfig+0x146>
  }

  switch (pdev->dev_state)
 8008500:	687b      	ldr	r3, [r7, #4]
 8008502:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8008506:	b2db      	uxtb	r3, r3
 8008508:	2b02      	cmp	r3, #2
 800850a:	d002      	beq.n	8008512 <USBD_SetConfig+0x3e>
 800850c:	2b03      	cmp	r3, #3
 800850e:	d029      	beq.n	8008564 <USBD_SetConfig+0x90>
 8008510:	e075      	b.n	80085fe <USBD_SetConfig+0x12a>
  {
    case USBD_STATE_ADDRESSED:
      if (cfgidx != 0U)
 8008512:	4b44      	ldr	r3, [pc, #272]	@ (8008624 <USBD_SetConfig+0x150>)
 8008514:	781b      	ldrb	r3, [r3, #0]
 8008516:	2b00      	cmp	r3, #0
 8008518:	d020      	beq.n	800855c <USBD_SetConfig+0x88>
      {
        pdev->dev_config = cfgidx;
 800851a:	4b42      	ldr	r3, [pc, #264]	@ (8008624 <USBD_SetConfig+0x150>)
 800851c:	781b      	ldrb	r3, [r3, #0]
 800851e:	461a      	mov	r2, r3
 8008520:	687b      	ldr	r3, [r7, #4]
 8008522:	605a      	str	r2, [r3, #4]

        ret = USBD_SetClassConfig(pdev, cfgidx);
 8008524:	4b3f      	ldr	r3, [pc, #252]	@ (8008624 <USBD_SetConfig+0x150>)
 8008526:	781b      	ldrb	r3, [r3, #0]
 8008528:	4619      	mov	r1, r3
 800852a:	6878      	ldr	r0, [r7, #4]
 800852c:	f7fe ffe3 	bl	80074f6 <USBD_SetClassConfig>
 8008530:	4603      	mov	r3, r0
 8008532:	73fb      	strb	r3, [r7, #15]

        if (ret != USBD_OK)
 8008534:	7bfb      	ldrb	r3, [r7, #15]
 8008536:	2b00      	cmp	r3, #0
 8008538:	d008      	beq.n	800854c <USBD_SetConfig+0x78>
        {
          USBD_CtlError(pdev, req);
 800853a:	6839      	ldr	r1, [r7, #0]
 800853c:	6878      	ldr	r0, [r7, #4]
 800853e:	f000 f962 	bl	8008806 <USBD_CtlError>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8008542:	687b      	ldr	r3, [r7, #4]
 8008544:	2202      	movs	r2, #2
 8008546:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 800854a:	e065      	b.n	8008618 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 800854c:	6878      	ldr	r0, [r7, #4]
 800854e:	f000 fa31 	bl	80089b4 <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 8008552:	687b      	ldr	r3, [r7, #4]
 8008554:	2203      	movs	r2, #3
 8008556:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 800855a:	e05d      	b.n	8008618 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 800855c:	6878      	ldr	r0, [r7, #4]
 800855e:	f000 fa29 	bl	80089b4 <USBD_CtlSendStatus>
      break;
 8008562:	e059      	b.n	8008618 <USBD_SetConfig+0x144>

    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0U)
 8008564:	4b2f      	ldr	r3, [pc, #188]	@ (8008624 <USBD_SetConfig+0x150>)
 8008566:	781b      	ldrb	r3, [r3, #0]
 8008568:	2b00      	cmp	r3, #0
 800856a:	d112      	bne.n	8008592 <USBD_SetConfig+0xbe>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800856c:	687b      	ldr	r3, [r7, #4]
 800856e:	2202      	movs	r2, #2
 8008570:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        pdev->dev_config = cfgidx;
 8008574:	4b2b      	ldr	r3, [pc, #172]	@ (8008624 <USBD_SetConfig+0x150>)
 8008576:	781b      	ldrb	r3, [r3, #0]
 8008578:	461a      	mov	r2, r3
 800857a:	687b      	ldr	r3, [r7, #4]
 800857c:	605a      	str	r2, [r3, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 800857e:	4b29      	ldr	r3, [pc, #164]	@ (8008624 <USBD_SetConfig+0x150>)
 8008580:	781b      	ldrb	r3, [r3, #0]
 8008582:	4619      	mov	r1, r3
 8008584:	6878      	ldr	r0, [r7, #4]
 8008586:	f7fe ffd2 	bl	800752e <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 800858a:	6878      	ldr	r0, [r7, #4]
 800858c:	f000 fa12 	bl	80089b4 <USBD_CtlSendStatus>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 8008590:	e042      	b.n	8008618 <USBD_SetConfig+0x144>
      else if (cfgidx != pdev->dev_config)
 8008592:	4b24      	ldr	r3, [pc, #144]	@ (8008624 <USBD_SetConfig+0x150>)
 8008594:	781b      	ldrb	r3, [r3, #0]
 8008596:	461a      	mov	r2, r3
 8008598:	687b      	ldr	r3, [r7, #4]
 800859a:	685b      	ldr	r3, [r3, #4]
 800859c:	429a      	cmp	r2, r3
 800859e:	d02a      	beq.n	80085f6 <USBD_SetConfig+0x122>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80085a0:	687b      	ldr	r3, [r7, #4]
 80085a2:	685b      	ldr	r3, [r3, #4]
 80085a4:	b2db      	uxtb	r3, r3
 80085a6:	4619      	mov	r1, r3
 80085a8:	6878      	ldr	r0, [r7, #4]
 80085aa:	f7fe ffc0 	bl	800752e <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 80085ae:	4b1d      	ldr	r3, [pc, #116]	@ (8008624 <USBD_SetConfig+0x150>)
 80085b0:	781b      	ldrb	r3, [r3, #0]
 80085b2:	461a      	mov	r2, r3
 80085b4:	687b      	ldr	r3, [r7, #4]
 80085b6:	605a      	str	r2, [r3, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 80085b8:	4b1a      	ldr	r3, [pc, #104]	@ (8008624 <USBD_SetConfig+0x150>)
 80085ba:	781b      	ldrb	r3, [r3, #0]
 80085bc:	4619      	mov	r1, r3
 80085be:	6878      	ldr	r0, [r7, #4]
 80085c0:	f7fe ff99 	bl	80074f6 <USBD_SetClassConfig>
 80085c4:	4603      	mov	r3, r0
 80085c6:	73fb      	strb	r3, [r7, #15]
        if (ret != USBD_OK)
 80085c8:	7bfb      	ldrb	r3, [r7, #15]
 80085ca:	2b00      	cmp	r3, #0
 80085cc:	d00f      	beq.n	80085ee <USBD_SetConfig+0x11a>
          USBD_CtlError(pdev, req);
 80085ce:	6839      	ldr	r1, [r7, #0]
 80085d0:	6878      	ldr	r0, [r7, #4]
 80085d2:	f000 f918 	bl	8008806 <USBD_CtlError>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80085d6:	687b      	ldr	r3, [r7, #4]
 80085d8:	685b      	ldr	r3, [r3, #4]
 80085da:	b2db      	uxtb	r3, r3
 80085dc:	4619      	mov	r1, r3
 80085de:	6878      	ldr	r0, [r7, #4]
 80085e0:	f7fe ffa5 	bl	800752e <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 80085e4:	687b      	ldr	r3, [r7, #4]
 80085e6:	2202      	movs	r2, #2
 80085e8:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 80085ec:	e014      	b.n	8008618 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 80085ee:	6878      	ldr	r0, [r7, #4]
 80085f0:	f000 f9e0 	bl	80089b4 <USBD_CtlSendStatus>
      break;
 80085f4:	e010      	b.n	8008618 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 80085f6:	6878      	ldr	r0, [r7, #4]
 80085f8:	f000 f9dc 	bl	80089b4 <USBD_CtlSendStatus>
      break;
 80085fc:	e00c      	b.n	8008618 <USBD_SetConfig+0x144>

    default:
      USBD_CtlError(pdev, req);
 80085fe:	6839      	ldr	r1, [r7, #0]
 8008600:	6878      	ldr	r0, [r7, #4]
 8008602:	f000 f900 	bl	8008806 <USBD_CtlError>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 8008606:	4b07      	ldr	r3, [pc, #28]	@ (8008624 <USBD_SetConfig+0x150>)
 8008608:	781b      	ldrb	r3, [r3, #0]
 800860a:	4619      	mov	r1, r3
 800860c:	6878      	ldr	r0, [r7, #4]
 800860e:	f7fe ff8e 	bl	800752e <USBD_ClrClassConfig>
      ret = USBD_FAIL;
 8008612:	2303      	movs	r3, #3
 8008614:	73fb      	strb	r3, [r7, #15]
      break;
 8008616:	bf00      	nop
  }

  return ret;
 8008618:	7bfb      	ldrb	r3, [r7, #15]
}
 800861a:	4618      	mov	r0, r3
 800861c:	3710      	adds	r7, #16
 800861e:	46bd      	mov	sp, r7
 8008620:	bd80      	pop	{r7, pc}
 8008622:	bf00      	nop
 8008624:	20001bec 	.word	0x20001bec

08008628 <USBD_GetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008628:	b580      	push	{r7, lr}
 800862a:	b082      	sub	sp, #8
 800862c:	af00      	add	r7, sp, #0
 800862e:	6078      	str	r0, [r7, #4]
 8008630:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 8008632:	683b      	ldr	r3, [r7, #0]
 8008634:	88db      	ldrh	r3, [r3, #6]
 8008636:	2b01      	cmp	r3, #1
 8008638:	d004      	beq.n	8008644 <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
 800863a:	6839      	ldr	r1, [r7, #0]
 800863c:	6878      	ldr	r0, [r7, #4]
 800863e:	f000 f8e2 	bl	8008806 <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
 8008642:	e023      	b.n	800868c <USBD_GetConfig+0x64>
    switch (pdev->dev_state)
 8008644:	687b      	ldr	r3, [r7, #4]
 8008646:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 800864a:	b2db      	uxtb	r3, r3
 800864c:	2b02      	cmp	r3, #2
 800864e:	dc02      	bgt.n	8008656 <USBD_GetConfig+0x2e>
 8008650:	2b00      	cmp	r3, #0
 8008652:	dc03      	bgt.n	800865c <USBD_GetConfig+0x34>
 8008654:	e015      	b.n	8008682 <USBD_GetConfig+0x5a>
 8008656:	2b03      	cmp	r3, #3
 8008658:	d00b      	beq.n	8008672 <USBD_GetConfig+0x4a>
 800865a:	e012      	b.n	8008682 <USBD_GetConfig+0x5a>
        pdev->dev_default_config = 0U;
 800865c:	687b      	ldr	r3, [r7, #4]
 800865e:	2200      	movs	r2, #0
 8008660:	609a      	str	r2, [r3, #8]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 8008662:	687b      	ldr	r3, [r7, #4]
 8008664:	3308      	adds	r3, #8
 8008666:	2201      	movs	r2, #1
 8008668:	4619      	mov	r1, r3
 800866a:	6878      	ldr	r0, [r7, #4]
 800866c:	f000 f948 	bl	8008900 <USBD_CtlSendData>
        break;
 8008670:	e00c      	b.n	800868c <USBD_GetConfig+0x64>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 8008672:	687b      	ldr	r3, [r7, #4]
 8008674:	3304      	adds	r3, #4
 8008676:	2201      	movs	r2, #1
 8008678:	4619      	mov	r1, r3
 800867a:	6878      	ldr	r0, [r7, #4]
 800867c:	f000 f940 	bl	8008900 <USBD_CtlSendData>
        break;
 8008680:	e004      	b.n	800868c <USBD_GetConfig+0x64>
        USBD_CtlError(pdev, req);
 8008682:	6839      	ldr	r1, [r7, #0]
 8008684:	6878      	ldr	r0, [r7, #4]
 8008686:	f000 f8be 	bl	8008806 <USBD_CtlError>
        break;
 800868a:	bf00      	nop
}
 800868c:	bf00      	nop
 800868e:	3708      	adds	r7, #8
 8008690:	46bd      	mov	sp, r7
 8008692:	bd80      	pop	{r7, pc}

08008694 <USBD_GetStatus>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008694:	b580      	push	{r7, lr}
 8008696:	b082      	sub	sp, #8
 8008698:	af00      	add	r7, sp, #0
 800869a:	6078      	str	r0, [r7, #4]
 800869c:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 800869e:	687b      	ldr	r3, [r7, #4]
 80086a0:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80086a4:	b2db      	uxtb	r3, r3
 80086a6:	3b01      	subs	r3, #1
 80086a8:	2b02      	cmp	r3, #2
 80086aa:	d81e      	bhi.n	80086ea <USBD_GetStatus+0x56>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
 80086ac:	683b      	ldr	r3, [r7, #0]
 80086ae:	88db      	ldrh	r3, [r3, #6]
 80086b0:	2b02      	cmp	r3, #2
 80086b2:	d004      	beq.n	80086be <USBD_GetStatus+0x2a>
      {
        USBD_CtlError(pdev, req);
 80086b4:	6839      	ldr	r1, [r7, #0]
 80086b6:	6878      	ldr	r0, [r7, #4]
 80086b8:	f000 f8a5 	bl	8008806 <USBD_CtlError>
        break;
 80086bc:	e01a      	b.n	80086f4 <USBD_GetStatus+0x60>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80086be:	687b      	ldr	r3, [r7, #4]
 80086c0:	2201      	movs	r2, #1
 80086c2:	60da      	str	r2, [r3, #12]
#else
      pdev->dev_config_status = 0U;
#endif /* USBD_SELF_POWERED */

      if (pdev->dev_remote_wakeup != 0U)
 80086c4:	687b      	ldr	r3, [r7, #4]
 80086c6:	f8d3 32a4 	ldr.w	r3, [r3, #676]	@ 0x2a4
 80086ca:	2b00      	cmp	r3, #0
 80086cc:	d005      	beq.n	80086da <USBD_GetStatus+0x46>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 80086ce:	687b      	ldr	r3, [r7, #4]
 80086d0:	68db      	ldr	r3, [r3, #12]
 80086d2:	f043 0202 	orr.w	r2, r3, #2
 80086d6:	687b      	ldr	r3, [r7, #4]
 80086d8:	60da      	str	r2, [r3, #12]
      }

      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 80086da:	687b      	ldr	r3, [r7, #4]
 80086dc:	330c      	adds	r3, #12
 80086de:	2202      	movs	r2, #2
 80086e0:	4619      	mov	r1, r3
 80086e2:	6878      	ldr	r0, [r7, #4]
 80086e4:	f000 f90c 	bl	8008900 <USBD_CtlSendData>
      break;
 80086e8:	e004      	b.n	80086f4 <USBD_GetStatus+0x60>

    default:
      USBD_CtlError(pdev, req);
 80086ea:	6839      	ldr	r1, [r7, #0]
 80086ec:	6878      	ldr	r0, [r7, #4]
 80086ee:	f000 f88a 	bl	8008806 <USBD_CtlError>
      break;
 80086f2:	bf00      	nop
  }
}
 80086f4:	bf00      	nop
 80086f6:	3708      	adds	r7, #8
 80086f8:	46bd      	mov	sp, r7
 80086fa:	bd80      	pop	{r7, pc}

080086fc <USBD_SetFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80086fc:	b580      	push	{r7, lr}
 80086fe:	b082      	sub	sp, #8
 8008700:	af00      	add	r7, sp, #0
 8008702:	6078      	str	r0, [r7, #4]
 8008704:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8008706:	683b      	ldr	r3, [r7, #0]
 8008708:	885b      	ldrh	r3, [r3, #2]
 800870a:	2b01      	cmp	r3, #1
 800870c:	d107      	bne.n	800871e <USBD_SetFeature+0x22>
  {
    pdev->dev_remote_wakeup = 1U;
 800870e:	687b      	ldr	r3, [r7, #4]
 8008710:	2201      	movs	r2, #1
 8008712:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 8008716:	6878      	ldr	r0, [r7, #4]
 8008718:	f000 f94c 	bl	80089b4 <USBD_CtlSendStatus>
  }
  else
  {
    USBD_CtlError(pdev, req);
  }
}
 800871c:	e013      	b.n	8008746 <USBD_SetFeature+0x4a>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 800871e:	683b      	ldr	r3, [r7, #0]
 8008720:	885b      	ldrh	r3, [r3, #2]
 8008722:	2b02      	cmp	r3, #2
 8008724:	d10b      	bne.n	800873e <USBD_SetFeature+0x42>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
 8008726:	683b      	ldr	r3, [r7, #0]
 8008728:	889b      	ldrh	r3, [r3, #4]
 800872a:	0a1b      	lsrs	r3, r3, #8
 800872c:	b29b      	uxth	r3, r3
 800872e:	b2da      	uxtb	r2, r3
 8008730:	687b      	ldr	r3, [r7, #4]
 8008732:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 8008736:	6878      	ldr	r0, [r7, #4]
 8008738:	f000 f93c 	bl	80089b4 <USBD_CtlSendStatus>
}
 800873c:	e003      	b.n	8008746 <USBD_SetFeature+0x4a>
    USBD_CtlError(pdev, req);
 800873e:	6839      	ldr	r1, [r7, #0]
 8008740:	6878      	ldr	r0, [r7, #4]
 8008742:	f000 f860 	bl	8008806 <USBD_CtlError>
}
 8008746:	bf00      	nop
 8008748:	3708      	adds	r7, #8
 800874a:	46bd      	mov	sp, r7
 800874c:	bd80      	pop	{r7, pc}

0800874e <USBD_ClrFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 800874e:	b580      	push	{r7, lr}
 8008750:	b082      	sub	sp, #8
 8008752:	af00      	add	r7, sp, #0
 8008754:	6078      	str	r0, [r7, #4]
 8008756:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 8008758:	687b      	ldr	r3, [r7, #4]
 800875a:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 800875e:	b2db      	uxtb	r3, r3
 8008760:	3b01      	subs	r3, #1
 8008762:	2b02      	cmp	r3, #2
 8008764:	d80b      	bhi.n	800877e <USBD_ClrFeature+0x30>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8008766:	683b      	ldr	r3, [r7, #0]
 8008768:	885b      	ldrh	r3, [r3, #2]
 800876a:	2b01      	cmp	r3, #1
 800876c:	d10c      	bne.n	8008788 <USBD_ClrFeature+0x3a>
      {
        pdev->dev_remote_wakeup = 0U;
 800876e:	687b      	ldr	r3, [r7, #4]
 8008770:	2200      	movs	r2, #0
 8008772:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 8008776:	6878      	ldr	r0, [r7, #4]
 8008778:	f000 f91c 	bl	80089b4 <USBD_CtlSendStatus>
      }
      break;
 800877c:	e004      	b.n	8008788 <USBD_ClrFeature+0x3a>

    default:
      USBD_CtlError(pdev, req);
 800877e:	6839      	ldr	r1, [r7, #0]
 8008780:	6878      	ldr	r0, [r7, #4]
 8008782:	f000 f840 	bl	8008806 <USBD_CtlError>
      break;
 8008786:	e000      	b.n	800878a <USBD_ClrFeature+0x3c>
      break;
 8008788:	bf00      	nop
  }
}
 800878a:	bf00      	nop
 800878c:	3708      	adds	r7, #8
 800878e:	46bd      	mov	sp, r7
 8008790:	bd80      	pop	{r7, pc}

08008792 <USBD_ParseSetupRequest>:
  * @param  req: usb request
  * @param  pdata: setup data pointer
  * @retval None
  */
void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 8008792:	b580      	push	{r7, lr}
 8008794:	b084      	sub	sp, #16
 8008796:	af00      	add	r7, sp, #0
 8008798:	6078      	str	r0, [r7, #4]
 800879a:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
 800879c:	683b      	ldr	r3, [r7, #0]
 800879e:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
 80087a0:	68fb      	ldr	r3, [r7, #12]
 80087a2:	781a      	ldrb	r2, [r3, #0]
 80087a4:	687b      	ldr	r3, [r7, #4]
 80087a6:	701a      	strb	r2, [r3, #0]

  pbuff++;
 80087a8:	68fb      	ldr	r3, [r7, #12]
 80087aa:	3301      	adds	r3, #1
 80087ac:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
 80087ae:	68fb      	ldr	r3, [r7, #12]
 80087b0:	781a      	ldrb	r2, [r3, #0]
 80087b2:	687b      	ldr	r3, [r7, #4]
 80087b4:	705a      	strb	r2, [r3, #1]

  pbuff++;
 80087b6:	68fb      	ldr	r3, [r7, #12]
 80087b8:	3301      	adds	r3, #1
 80087ba:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
 80087bc:	68f8      	ldr	r0, [r7, #12]
 80087be:	f7ff fa40 	bl	8007c42 <SWAPBYTE>
 80087c2:	4603      	mov	r3, r0
 80087c4:	461a      	mov	r2, r3
 80087c6:	687b      	ldr	r3, [r7, #4]
 80087c8:	805a      	strh	r2, [r3, #2]

  pbuff++;
 80087ca:	68fb      	ldr	r3, [r7, #12]
 80087cc:	3301      	adds	r3, #1
 80087ce:	60fb      	str	r3, [r7, #12]
  pbuff++;
 80087d0:	68fb      	ldr	r3, [r7, #12]
 80087d2:	3301      	adds	r3, #1
 80087d4:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
 80087d6:	68f8      	ldr	r0, [r7, #12]
 80087d8:	f7ff fa33 	bl	8007c42 <SWAPBYTE>
 80087dc:	4603      	mov	r3, r0
 80087de:	461a      	mov	r2, r3
 80087e0:	687b      	ldr	r3, [r7, #4]
 80087e2:	809a      	strh	r2, [r3, #4]

  pbuff++;
 80087e4:	68fb      	ldr	r3, [r7, #12]
 80087e6:	3301      	adds	r3, #1
 80087e8:	60fb      	str	r3, [r7, #12]
  pbuff++;
 80087ea:	68fb      	ldr	r3, [r7, #12]
 80087ec:	3301      	adds	r3, #1
 80087ee:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
 80087f0:	68f8      	ldr	r0, [r7, #12]
 80087f2:	f7ff fa26 	bl	8007c42 <SWAPBYTE>
 80087f6:	4603      	mov	r3, r0
 80087f8:	461a      	mov	r2, r3
 80087fa:	687b      	ldr	r3, [r7, #4]
 80087fc:	80da      	strh	r2, [r3, #6]
}
 80087fe:	bf00      	nop
 8008800:	3710      	adds	r7, #16
 8008802:	46bd      	mov	sp, r7
 8008804:	bd80      	pop	{r7, pc}

08008806 <USBD_CtlError>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008806:	b580      	push	{r7, lr}
 8008808:	b082      	sub	sp, #8
 800880a:	af00      	add	r7, sp, #0
 800880c:	6078      	str	r0, [r7, #4]
 800880e:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 8008810:	2180      	movs	r1, #128	@ 0x80
 8008812:	6878      	ldr	r0, [r7, #4]
 8008814:	f01f fd8e 	bl	8028334 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8008818:	2100      	movs	r1, #0
 800881a:	6878      	ldr	r0, [r7, #4]
 800881c:	f01f fd8a 	bl	8028334 <USBD_LL_StallEP>
}
 8008820:	bf00      	nop
 8008822:	3708      	adds	r7, #8
 8008824:	46bd      	mov	sp, r7
 8008826:	bd80      	pop	{r7, pc}

08008828 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8008828:	b580      	push	{r7, lr}
 800882a:	b086      	sub	sp, #24
 800882c:	af00      	add	r7, sp, #0
 800882e:	60f8      	str	r0, [r7, #12]
 8008830:	60b9      	str	r1, [r7, #8]
 8008832:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 8008834:	2300      	movs	r3, #0
 8008836:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 8008838:	68fb      	ldr	r3, [r7, #12]
 800883a:	2b00      	cmp	r3, #0
 800883c:	d042      	beq.n	80088c4 <USBD_GetString+0x9c>
  {
    return;
  }

  pdesc = desc;
 800883e:	68fb      	ldr	r3, [r7, #12]
 8008840:	613b      	str	r3, [r7, #16]
  *len = MIN(USBD_MAX_STR_DESC_SIZ, ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U);
 8008842:	6938      	ldr	r0, [r7, #16]
 8008844:	f000 f842 	bl	80088cc <USBD_GetLen>
 8008848:	4603      	mov	r3, r0
 800884a:	3301      	adds	r3, #1
 800884c:	005b      	lsls	r3, r3, #1
 800884e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8008852:	d808      	bhi.n	8008866 <USBD_GetString+0x3e>
 8008854:	6938      	ldr	r0, [r7, #16]
 8008856:	f000 f839 	bl	80088cc <USBD_GetLen>
 800885a:	4603      	mov	r3, r0
 800885c:	3301      	adds	r3, #1
 800885e:	b29b      	uxth	r3, r3
 8008860:	005b      	lsls	r3, r3, #1
 8008862:	b29a      	uxth	r2, r3
 8008864:	e001      	b.n	800886a <USBD_GetString+0x42>
 8008866:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800886a:	687b      	ldr	r3, [r7, #4]
 800886c:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
 800886e:	7dfb      	ldrb	r3, [r7, #23]
 8008870:	68ba      	ldr	r2, [r7, #8]
 8008872:	4413      	add	r3, r2
 8008874:	687a      	ldr	r2, [r7, #4]
 8008876:	7812      	ldrb	r2, [r2, #0]
 8008878:	701a      	strb	r2, [r3, #0]
  idx++;
 800887a:	7dfb      	ldrb	r3, [r7, #23]
 800887c:	3301      	adds	r3, #1
 800887e:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
 8008880:	7dfb      	ldrb	r3, [r7, #23]
 8008882:	68ba      	ldr	r2, [r7, #8]
 8008884:	4413      	add	r3, r2
 8008886:	2203      	movs	r2, #3
 8008888:	701a      	strb	r2, [r3, #0]
  idx++;
 800888a:	7dfb      	ldrb	r3, [r7, #23]
 800888c:	3301      	adds	r3, #1
 800888e:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
 8008890:	e013      	b.n	80088ba <USBD_GetString+0x92>
  {
    unicode[idx] = *pdesc;
 8008892:	7dfb      	ldrb	r3, [r7, #23]
 8008894:	68ba      	ldr	r2, [r7, #8]
 8008896:	4413      	add	r3, r2
 8008898:	693a      	ldr	r2, [r7, #16]
 800889a:	7812      	ldrb	r2, [r2, #0]
 800889c:	701a      	strb	r2, [r3, #0]
    pdesc++;
 800889e:	693b      	ldr	r3, [r7, #16]
 80088a0:	3301      	adds	r3, #1
 80088a2:	613b      	str	r3, [r7, #16]
    idx++;
 80088a4:	7dfb      	ldrb	r3, [r7, #23]
 80088a6:	3301      	adds	r3, #1
 80088a8:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
 80088aa:	7dfb      	ldrb	r3, [r7, #23]
 80088ac:	68ba      	ldr	r2, [r7, #8]
 80088ae:	4413      	add	r3, r2
 80088b0:	2200      	movs	r2, #0
 80088b2:	701a      	strb	r2, [r3, #0]
    idx++;
 80088b4:	7dfb      	ldrb	r3, [r7, #23]
 80088b6:	3301      	adds	r3, #1
 80088b8:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
 80088ba:	693b      	ldr	r3, [r7, #16]
 80088bc:	781b      	ldrb	r3, [r3, #0]
 80088be:	2b00      	cmp	r3, #0
 80088c0:	d1e7      	bne.n	8008892 <USBD_GetString+0x6a>
 80088c2:	e000      	b.n	80088c6 <USBD_GetString+0x9e>
    return;
 80088c4:	bf00      	nop
  }
}
 80088c6:	3718      	adds	r7, #24
 80088c8:	46bd      	mov	sp, r7
 80088ca:	bd80      	pop	{r7, pc}

080088cc <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 80088cc:	b480      	push	{r7}
 80088ce:	b085      	sub	sp, #20
 80088d0:	af00      	add	r7, sp, #0
 80088d2:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 80088d4:	2300      	movs	r3, #0
 80088d6:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 80088d8:	687b      	ldr	r3, [r7, #4]
 80088da:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 80088dc:	e005      	b.n	80088ea <USBD_GetLen+0x1e>
  {
    len++;
 80088de:	7bfb      	ldrb	r3, [r7, #15]
 80088e0:	3301      	adds	r3, #1
 80088e2:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 80088e4:	68bb      	ldr	r3, [r7, #8]
 80088e6:	3301      	adds	r3, #1
 80088e8:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 80088ea:	68bb      	ldr	r3, [r7, #8]
 80088ec:	781b      	ldrb	r3, [r3, #0]
 80088ee:	2b00      	cmp	r3, #0
 80088f0:	d1f5      	bne.n	80088de <USBD_GetLen+0x12>
  }

  return len;
 80088f2:	7bfb      	ldrb	r3, [r7, #15]
}
 80088f4:	4618      	mov	r0, r3
 80088f6:	3714      	adds	r7, #20
 80088f8:	46bd      	mov	sp, r7
 80088fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088fe:	4770      	bx	lr

08008900 <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 8008900:	b580      	push	{r7, lr}
 8008902:	b084      	sub	sp, #16
 8008904:	af00      	add	r7, sp, #0
 8008906:	60f8      	str	r0, [r7, #12]
 8008908:	60b9      	str	r1, [r7, #8]
 800890a:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 800890c:	68fb      	ldr	r3, [r7, #12]
 800890e:	2202      	movs	r2, #2
 8008910:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_in[0].total_length = len;
 8008914:	68fb      	ldr	r3, [r7, #12]
 8008916:	687a      	ldr	r2, [r7, #4]
 8008918:	619a      	str	r2, [r3, #24]

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 800891a:	68fb      	ldr	r3, [r7, #12]
 800891c:	687a      	ldr	r2, [r7, #4]
 800891e:	61da      	str	r2, [r3, #28]
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8008920:	687b      	ldr	r3, [r7, #4]
 8008922:	68ba      	ldr	r2, [r7, #8]
 8008924:	2100      	movs	r1, #0
 8008926:	68f8      	ldr	r0, [r7, #12]
 8008928:	f01f fd8d 	bl	8028446 <USBD_LL_Transmit>

  return USBD_OK;
 800892c:	2300      	movs	r3, #0
}
 800892e:	4618      	mov	r0, r3
 8008930:	3710      	adds	r7, #16
 8008932:	46bd      	mov	sp, r7
 8008934:	bd80      	pop	{r7, pc}

08008936 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 8008936:	b580      	push	{r7, lr}
 8008938:	b084      	sub	sp, #16
 800893a:	af00      	add	r7, sp, #0
 800893c:	60f8      	str	r0, [r7, #12]
 800893e:	60b9      	str	r1, [r7, #8]
 8008940:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8008942:	687b      	ldr	r3, [r7, #4]
 8008944:	68ba      	ldr	r2, [r7, #8]
 8008946:	2100      	movs	r1, #0
 8008948:	68f8      	ldr	r0, [r7, #12]
 800894a:	f01f fd7c 	bl	8028446 <USBD_LL_Transmit>

  return USBD_OK;
 800894e:	2300      	movs	r3, #0
}
 8008950:	4618      	mov	r0, r3
 8008952:	3710      	adds	r7, #16
 8008954:	46bd      	mov	sp, r7
 8008956:	bd80      	pop	{r7, pc}

08008958 <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 8008958:	b580      	push	{r7, lr}
 800895a:	b084      	sub	sp, #16
 800895c:	af00      	add	r7, sp, #0
 800895e:	60f8      	str	r0, [r7, #12]
 8008960:	60b9      	str	r1, [r7, #8]
 8008962:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8008964:	68fb      	ldr	r3, [r7, #12]
 8008966:	2203      	movs	r2, #3
 8008968:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_out[0].total_length = len;
 800896c:	68fb      	ldr	r3, [r7, #12]
 800896e:	687a      	ldr	r2, [r7, #4]
 8008970:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_out[0].rem_length = 0U;
#else
  pdev->ep_out[0].rem_length = len;
 8008974:	68fb      	ldr	r3, [r7, #12]
 8008976:	687a      	ldr	r2, [r7, #4]
 8008978:	f8c3 215c 	str.w	r2, [r3, #348]	@ 0x15c
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800897c:	687b      	ldr	r3, [r7, #4]
 800897e:	68ba      	ldr	r2, [r7, #8]
 8008980:	2100      	movs	r1, #0
 8008982:	68f8      	ldr	r0, [r7, #12]
 8008984:	f01f fd80 	bl	8028488 <USBD_LL_PrepareReceive>

  return USBD_OK;
 8008988:	2300      	movs	r3, #0
}
 800898a:	4618      	mov	r0, r3
 800898c:	3710      	adds	r7, #16
 800898e:	46bd      	mov	sp, r7
 8008990:	bd80      	pop	{r7, pc}

08008992 <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 8008992:	b580      	push	{r7, lr}
 8008994:	b084      	sub	sp, #16
 8008996:	af00      	add	r7, sp, #0
 8008998:	60f8      	str	r0, [r7, #12]
 800899a:	60b9      	str	r1, [r7, #8]
 800899c:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800899e:	687b      	ldr	r3, [r7, #4]
 80089a0:	68ba      	ldr	r2, [r7, #8]
 80089a2:	2100      	movs	r1, #0
 80089a4:	68f8      	ldr	r0, [r7, #12]
 80089a6:	f01f fd6f 	bl	8028488 <USBD_LL_PrepareReceive>

  return USBD_OK;
 80089aa:	2300      	movs	r3, #0
}
 80089ac:	4618      	mov	r0, r3
 80089ae:	3710      	adds	r7, #16
 80089b0:	46bd      	mov	sp, r7
 80089b2:	bd80      	pop	{r7, pc}

080089b4 <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 80089b4:	b580      	push	{r7, lr}
 80089b6:	b082      	sub	sp, #8
 80089b8:	af00      	add	r7, sp, #0
 80089ba:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 80089bc:	687b      	ldr	r3, [r7, #4]
 80089be:	2204      	movs	r2, #4
 80089c0:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 80089c4:	2300      	movs	r3, #0
 80089c6:	2200      	movs	r2, #0
 80089c8:	2100      	movs	r1, #0
 80089ca:	6878      	ldr	r0, [r7, #4]
 80089cc:	f01f fd3b 	bl	8028446 <USBD_LL_Transmit>

  return USBD_OK;
 80089d0:	2300      	movs	r3, #0
}
 80089d2:	4618      	mov	r0, r3
 80089d4:	3708      	adds	r7, #8
 80089d6:	46bd      	mov	sp, r7
 80089d8:	bd80      	pop	{r7, pc}

080089da <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 80089da:	b580      	push	{r7, lr}
 80089dc:	b082      	sub	sp, #8
 80089de:	af00      	add	r7, sp, #0
 80089e0:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 80089e2:	687b      	ldr	r3, [r7, #4]
 80089e4:	2205      	movs	r2, #5
 80089e6:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80089ea:	2300      	movs	r3, #0
 80089ec:	2200      	movs	r2, #0
 80089ee:	2100      	movs	r1, #0
 80089f0:	6878      	ldr	r0, [r7, #4]
 80089f2:	f01f fd49 	bl	8028488 <USBD_LL_PrepareReceive>

  return USBD_OK;
 80089f6:	2300      	movs	r3, #0
}
 80089f8:	4618      	mov	r0, r3
 80089fa:	3708      	adds	r7, #8
 80089fc:	46bd      	mov	sp, r7
 80089fe:	bd80      	pop	{r7, pc}

08008a00 <wolfSSL_Atomic_Int_FetchSub>:
    static WC_INLINE int wolfSSL_Atomic_Int_FetchAdd(int *c, int i) {
        int ret = *c;
        *c += i;
        return ret;
    }
    static WC_INLINE int wolfSSL_Atomic_Int_FetchSub(int *c, int i) {
 8008a00:	b480      	push	{r7}
 8008a02:	b085      	sub	sp, #20
 8008a04:	af00      	add	r7, sp, #0
 8008a06:	6078      	str	r0, [r7, #4]
 8008a08:	6039      	str	r1, [r7, #0]
        int ret = *c;
 8008a0a:	687b      	ldr	r3, [r7, #4]
 8008a0c:	681b      	ldr	r3, [r3, #0]
 8008a0e:	60fb      	str	r3, [r7, #12]
        *c -= i;
 8008a10:	687b      	ldr	r3, [r7, #4]
 8008a12:	681a      	ldr	r2, [r3, #0]
 8008a14:	683b      	ldr	r3, [r7, #0]
 8008a16:	1ad2      	subs	r2, r2, r3
 8008a18:	687b      	ldr	r3, [r7, #4]
 8008a1a:	601a      	str	r2, [r3, #0]
        return ret;
 8008a1c:	68fb      	ldr	r3, [r7, #12]
    }
 8008a1e:	4618      	mov	r0, r3
 8008a20:	3714      	adds	r7, #20
 8008a22:	46bd      	mov	sp, r7
 8008a24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a28:	4770      	bx	lr

08008a2a <ForceZero>:

#ifndef WOLFSSL_NO_FORCE_ZERO
/* This routine fills the first len bytes of the memory area pointed by mem
   with zeros. It ensures compiler optimizations doesn't skip it  */
WC_MISC_STATIC WC_INLINE void ForceZero(void* mem, word32 len)
{
 8008a2a:	b480      	push	{r7}
 8008a2c:	b085      	sub	sp, #20
 8008a2e:	af00      	add	r7, sp, #0
 8008a30:	6078      	str	r0, [r7, #4]
 8008a32:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 8008a34:	687b      	ldr	r3, [r7, #4]
 8008a36:	60fb      	str	r3, [r7, #12]
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
 8008a38:	e004      	b.n	8008a44 <ForceZero+0x1a>
 8008a3a:	68fb      	ldr	r3, [r7, #12]
 8008a3c:	1c5a      	adds	r2, r3, #1
 8008a3e:	60fa      	str	r2, [r7, #12]
 8008a40:	2200      	movs	r2, #0
 8008a42:	701a      	strb	r2, [r3, #0]
 8008a44:	683b      	ldr	r3, [r7, #0]
 8008a46:	1e5a      	subs	r2, r3, #1
 8008a48:	603a      	str	r2, [r7, #0]
 8008a4a:	2b00      	cmp	r3, #0
 8008a4c:	d1f5      	bne.n	8008a3a <ForceZero+0x10>
}
 8008a4e:	bf00      	nop
 8008a50:	bf00      	nop
 8008a52:	3714      	adds	r7, #20
 8008a54:	46bd      	mov	sp, r7
 8008a56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a5a:	4770      	bx	lr

08008a5c <min>:
    #if defined(HAVE_FIPS) && !defined(min) /* so ifdef check passes */
        #define min min
    #endif
    /* returns the smaller of a and b */
    WC_MISC_STATIC WC_INLINE word32 min(word32 a, word32 b)
    {
 8008a5c:	b480      	push	{r7}
 8008a5e:	b083      	sub	sp, #12
 8008a60:	af00      	add	r7, sp, #0
 8008a62:	6078      	str	r0, [r7, #4]
 8008a64:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 8008a66:	687a      	ldr	r2, [r7, #4]
 8008a68:	683b      	ldr	r3, [r7, #0]
 8008a6a:	4293      	cmp	r3, r2
 8008a6c:	bf28      	it	cs
 8008a6e:	4613      	movcs	r3, r2
    }
 8008a70:	4618      	mov	r0, r3
 8008a72:	370c      	adds	r7, #12
 8008a74:	46bd      	mov	sp, r7
 8008a76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a7a:	4770      	bx	lr

08008a7c <IsAtLeastTLSv1_3>:

    return 0;
}

int IsAtLeastTLSv1_3(const ProtocolVersion pv)
{
 8008a7c:	b480      	push	{r7}
 8008a7e:	b085      	sub	sp, #20
 8008a80:	af00      	add	r7, sp, #0
 8008a82:	80b8      	strh	r0, [r7, #4]
    int ret;
    ret = (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR);
 8008a84:	793b      	ldrb	r3, [r7, #4]
 8008a86:	2b03      	cmp	r3, #3
 8008a88:	d104      	bne.n	8008a94 <IsAtLeastTLSv1_3+0x18>
 8008a8a:	797b      	ldrb	r3, [r7, #5]
 8008a8c:	2b03      	cmp	r3, #3
 8008a8e:	d901      	bls.n	8008a94 <IsAtLeastTLSv1_3+0x18>
 8008a90:	2301      	movs	r3, #1
 8008a92:	e000      	b.n	8008a96 <IsAtLeastTLSv1_3+0x1a>
 8008a94:	2300      	movs	r3, #0
 8008a96:	60fb      	str	r3, [r7, #12]
#ifdef WOLFSSL_DTLS13
    if (ret == 0 && pv.major == DTLS_MAJOR && pv.minor <= DTLSv1_3_MINOR)
        return 1;
#endif

    return ret;
 8008a98:	68fb      	ldr	r3, [r7, #12]
}
 8008a9a:	4618      	mov	r0, r3
 8008a9c:	3714      	adds	r7, #20
 8008a9e:	46bd      	mov	sp, r7
 8008aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008aa4:	4770      	bx	lr

08008aa6 <InitSSL_Method>:
}
#endif /* WOLFSSL_SESSION_EXPORT */


void InitSSL_Method(WOLFSSL_METHOD* method, ProtocolVersion pv)
{
 8008aa6:	b480      	push	{r7}
 8008aa8:	b083      	sub	sp, #12
 8008aaa:	af00      	add	r7, sp, #0
 8008aac:	6078      	str	r0, [r7, #4]
 8008aae:	8039      	strh	r1, [r7, #0]
    method->version    = pv;
 8008ab0:	687b      	ldr	r3, [r7, #4]
 8008ab2:	461a      	mov	r2, r3
 8008ab4:	463b      	mov	r3, r7
 8008ab6:	881b      	ldrh	r3, [r3, #0]
 8008ab8:	8013      	strh	r3, [r2, #0]
    method->side       = WOLFSSL_CLIENT_END;
 8008aba:	687b      	ldr	r3, [r7, #4]
 8008abc:	2201      	movs	r2, #1
 8008abe:	709a      	strb	r2, [r3, #2]
    method->downgrade  = 0;
 8008ac0:	687b      	ldr	r3, [r7, #4]
 8008ac2:	2200      	movs	r2, #0
 8008ac4:	70da      	strb	r2, [r3, #3]
}
 8008ac6:	bf00      	nop
 8008ac8:	370c      	adds	r7, #12
 8008aca:	46bd      	mov	sp, r7
 8008acc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ad0:	4770      	bx	lr

08008ad2 <InitSSL_Ctx>:
}
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

/* Initialize SSL context, return 0 on success */
int InitSSL_Ctx(WOLFSSL_CTX* ctx, WOLFSSL_METHOD* method, void* heap)
{
 8008ad2:	b580      	push	{r7, lr}
 8008ad4:	b086      	sub	sp, #24
 8008ad6:	af00      	add	r7, sp, #0
 8008ad8:	60f8      	str	r0, [r7, #12]
 8008ada:	60b9      	str	r1, [r7, #8]
 8008adc:	607a      	str	r2, [r7, #4]
    int ret = 0;
 8008ade:	2300      	movs	r3, #0
 8008ae0:	617b      	str	r3, [r7, #20]

    XMEMSET(ctx, 0, sizeof(WOLFSSL_CTX));
 8008ae2:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 8008ae6:	2100      	movs	r1, #0
 8008ae8:	68f8      	ldr	r0, [r7, #12]
 8008aea:	f020 f89b 	bl	8028c24 <memset>

    ctx->method   = method;
 8008aee:	68fb      	ldr	r3, [r7, #12]
 8008af0:	68ba      	ldr	r2, [r7, #8]
 8008af2:	601a      	str	r2, [r3, #0]
    if (heap == NULL) {
 8008af4:	687b      	ldr	r3, [r7, #4]
 8008af6:	2b00      	cmp	r3, #0
 8008af8:	d103      	bne.n	8008b02 <InitSSL_Ctx+0x30>
        ctx->heap = ctx;  /* defaults to self */
 8008afa:	68fb      	ldr	r3, [r7, #12]
 8008afc:	68fa      	ldr	r2, [r7, #12]
 8008afe:	659a      	str	r2, [r3, #88]	@ 0x58
 8008b00:	e002      	b.n	8008b08 <InitSSL_Ctx+0x36>
    }
    else {
        ctx->heap = heap; /* wolfSSL_CTX_load_static_memory sets */
 8008b02:	68fb      	ldr	r3, [r7, #12]
 8008b04:	687a      	ldr	r2, [r7, #4]
 8008b06:	659a      	str	r2, [r3, #88]	@ 0x58
    }
    ctx->timeout  = WOLFSSL_SESSION_TIMEOUT;
 8008b08:	68fb      	ldr	r3, [r7, #12]
 8008b0a:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
 8008b0e:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4
    }
    else
#endif /* WOLFSSL_DTLS */
    {
        /* current default: TLSv1_MINOR */
        ctx->minDowngrade = WOLFSSL_MIN_DOWNGRADE;
 8008b12:	68fb      	ldr	r3, [r7, #12]
 8008b14:	2203      	movs	r2, #3
 8008b16:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
    }

    wolfSSL_RefWithMutexInit(&ctx->ref, &ret);
 8008b1a:	68fb      	ldr	r3, [r7, #12]
 8008b1c:	2201      	movs	r2, #1
 8008b1e:	609a      	str	r2, [r3, #8]
 8008b20:	2300      	movs	r3, #0
 8008b22:	617b      	str	r3, [r7, #20]
#else
    (void)ret;
#endif

#ifndef NO_CERTS
    ctx->privateKeyDevId = INVALID_DEVID;
 8008b24:	68fb      	ldr	r3, [r7, #12]
 8008b26:	f06f 0201 	mvn.w	r2, #1
 8008b2a:	64da      	str	r2, [r3, #76]	@ 0x4c
    ctx->altPrivateKeyDevId = INVALID_DEVID;
#endif
#endif

#ifndef NO_DH
    ctx->minDhKeySz  = MIN_DHKEY_SZ;
 8008b2c:	68fb      	ldr	r3, [r7, #12]
 8008b2e:	2280      	movs	r2, #128	@ 0x80
 8008b30:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
    ctx->maxDhKeySz  = MAX_DHKEY_SZ;
 8008b34:	68fb      	ldr	r3, [r7, #12]
 8008b36:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8008b3a:	f8a3 2064 	strh.w	r2, [r3, #100]	@ 0x64
#endif
#ifndef NO_RSA
    ctx->minRsaKeySz = MIN_RSAKEY_SZ;
 8008b3e:	68fb      	ldr	r3, [r7, #12]
 8008b40:	2280      	movs	r2, #128	@ 0x80
 8008b42:	f8a3 2066 	strh.w	r2, [r3, #102]	@ 0x66
#endif

#ifdef HAVE_ECC
    ctx->minEccKeySz  = MIN_ECCKEY_SZ;
 8008b46:	68fb      	ldr	r3, [r7, #12]
 8008b48:	221c      	movs	r2, #28
 8008b4a:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
    ctx->eccTempKeySz = ECDHE_SIZE;
 8008b4e:	68fb      	ldr	r3, [r7, #12]
 8008b50:	2220      	movs	r2, #32
 8008b52:	f8a3 20cc 	strh.w	r2, [r3, #204]	@ 0xcc
    ctx->minFalconKeySz = MIN_FALCONKEY_SZ;
#endif /* HAVE_FALCON */
#ifdef HAVE_DILITHIUM
    ctx->minDilithiumKeySz = MIN_DILITHIUMKEY_SZ;
#endif /* HAVE_DILITHIUM */
    ctx->verifyDepth = MAX_CHAIN_DEPTH;
 8008b56:	68fb      	ldr	r3, [r7, #12]
 8008b58:	2209      	movs	r2, #9
 8008b5a:	f883 205c 	strb.w	r2, [r3, #92]	@ 0x5c
#ifdef OPENSSL_EXTRA
    ctx->cbioFlag = WOLFSSL_CBIO_NONE;
 8008b5e:	68fb      	ldr	r3, [r7, #12]
 8008b60:	2200      	movs	r2, #0
 8008b62:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0
    if (method->side == WOLFSSL_CLIENT_END)
        ctx->haveDilithiumSig = 1;     /* always on client side */
                                       /* server can turn on by loading key */
#endif /* HAVE_DILITHIUM */
#ifdef HAVE_ECC
    if (method->side == WOLFSSL_CLIENT_END) {
 8008b66:	68bb      	ldr	r3, [r7, #8]
 8008b68:	789b      	ldrb	r3, [r3, #2]
 8008b6a:	2b01      	cmp	r3, #1
 8008b6c:	d114      	bne.n	8008b98 <InitSSL_Ctx+0xc6>
        ctx->haveECDSAsig  = 1;        /* always on client side */
 8008b6e:	68fa      	ldr	r2, [r7, #12]
 8008b70:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 8008b74:	f043 0320 	orr.w	r3, r3, #32
 8008b78:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
        ctx->haveECC  = 1;             /* server turns on with ECC key cert */
 8008b7c:	68fa      	ldr	r2, [r7, #12]
 8008b7e:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 8008b82:	f043 0308 	orr.w	r3, r3, #8
 8008b86:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
        ctx->haveStaticECC = 1;        /* server can turn on by loading key */
 8008b8a:	68fa      	ldr	r2, [r7, #12]
 8008b8c:	f892 305f 	ldrb.w	r3, [r2, #95]	@ 0x5f
 8008b90:	f043 0301 	orr.w	r3, r3, #1
 8008b94:	f882 305f 	strb.w	r3, [r2, #95]	@ 0x5f
    /* default to try using CAAM when built */
    ctx->devId = WOLFSSL_CAAM_DEVID;
#elif defined(HAVE_ARIA) && defined(WOLF_CRYPTO_CB)
    ctx->devId = WOLFSSL_ARIA_DEVID;
#else
    ctx->devId = INVALID_DEVID;
 8008b98:	68fb      	ldr	r3, [r7, #12]
 8008b9a:	f06f 0201 	mvn.w	r2, #1
 8008b9e:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
        ctx->dtlsMtuSz = MAX_MTU;
    #endif
#endif

#ifndef NO_CERTS
    ctx->cm = wolfSSL_CertManagerNew_ex(heap);
 8008ba2:	6878      	ldr	r0, [r7, #4]
 8008ba4:	f002 fd88 	bl	800b6b8 <wolfSSL_CertManagerNew_ex>
 8008ba8:	4602      	mov	r2, r0
 8008baa:	68fb      	ldr	r3, [r7, #12]
 8008bac:	651a      	str	r2, [r3, #80]	@ 0x50
    if (ctx->cm == NULL) {
 8008bae:	68fb      	ldr	r3, [r7, #12]
 8008bb0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008bb2:	2b00      	cmp	r3, #0
 8008bb4:	d102      	bne.n	8008bbc <InitSSL_Ctx+0xea>
        WOLFSSL_MSG("Bad Cert Manager New");
        WOLFSSL_ERROR_VERBOSE(BAD_CERT_MANAGER_ERROR);
        return BAD_CERT_MANAGER_ERROR;
 8008bb6:	f46f 73b3 	mvn.w	r3, #358	@ 0x166
 8008bba:	e076      	b.n	8008caa <InitSSL_Ctx+0x1d8>
    }
    #ifdef OPENSSL_EXTRA
    /* setup WOLFSSL_X509_STORE */
    ctx->x509_store.cm = ctx->cm;
 8008bbc:	68fb      	ldr	r3, [r7, #12]
 8008bbe:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8008bc0:	68fb      	ldr	r3, [r7, #12]
 8008bc2:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
    /* set pointer back to x509 store */
    ctx->cm->x509_store_p = &ctx->x509_store;
 8008bc6:	68fb      	ldr	r3, [r7, #12]
 8008bc8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008bca:	68fa      	ldr	r2, [r7, #12]
 8008bcc:	32f4      	adds	r2, #244	@ 0xf4
 8008bce:	669a      	str	r2, [r3, #104]	@ 0x68

    /* WOLFSSL_X509_VERIFY_PARAM */
    if ((ctx->param = (WOLFSSL_X509_VERIFY_PARAM*)XMALLOC(
 8008bd0:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 8008bd4:	f016 f852 	bl	801ec7c <wolfSSL_Malloc>
 8008bd8:	4602      	mov	r2, r0
 8008bda:	68fb      	ldr	r3, [r7, #12]
 8008bdc:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
 8008be0:	68fb      	ldr	r3, [r7, #12]
 8008be2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8008be6:	2b00      	cmp	r3, #0
 8008be8:	d102      	bne.n	8008bf0 <InitSSL_Ctx+0x11e>
                           sizeof(WOLFSSL_X509_VERIFY_PARAM),
                           heap, DYNAMIC_TYPE_OPENSSL)) == NULL) {
        WOLFSSL_MSG("ctx->param memory error");
        return MEMORY_E;
 8008bea:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8008bee:	e05c      	b.n	8008caa <InitSSL_Ctx+0x1d8>
    }
    XMEMSET(ctx->param, 0, sizeof(WOLFSSL_X509_VERIFY_PARAM));
 8008bf0:	68fb      	ldr	r3, [r7, #12]
 8008bf2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8008bf6:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 8008bfa:	2100      	movs	r1, #0
 8008bfc:	4618      	mov	r0, r3
 8008bfe:	f020 f811 	bl	8028c24 <memset>

    /* WOLFSSL_X509_LOOKUP */
    if ((ctx->x509_store.lookup.dirs = (WOLFSSL_BY_DIR*)XMALLOC(
 8008c02:	2008      	movs	r0, #8
 8008c04:	f016 f83a 	bl	801ec7c <wolfSSL_Malloc>
 8008c08:	4602      	mov	r2, r0
 8008c0a:	68fb      	ldr	r3, [r7, #12]
 8008c0c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
 8008c10:	68fb      	ldr	r3, [r7, #12]
 8008c12:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008c16:	2b00      	cmp	r3, #0
 8008c18:	d102      	bne.n	8008c20 <InitSSL_Ctx+0x14e>
                           sizeof(WOLFSSL_BY_DIR),
                           heap, DYNAMIC_TYPE_OPENSSL)) == NULL) {
        WOLFSSL_MSG("ctx->x509_store.lookup.dirs: allocation error");
        return MEMORY_E;
 8008c1a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8008c1e:	e044      	b.n	8008caa <InitSSL_Ctx+0x1d8>
    }
    XMEMSET(ctx->x509_store.lookup.dirs, 0, sizeof(WOLFSSL_BY_DIR));
 8008c20:	68fb      	ldr	r3, [r7, #12]
 8008c22:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008c26:	2208      	movs	r2, #8
 8008c28:	2100      	movs	r1, #0
 8008c2a:	4618      	mov	r0, r3
 8008c2c:	f01f fffa 	bl	8028c24 <memset>

    /* param */
    if ((ctx->x509_store.param = (WOLFSSL_X509_VERIFY_PARAM*)XMALLOC(
 8008c30:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 8008c34:	f016 f822 	bl	801ec7c <wolfSSL_Malloc>
 8008c38:	4602      	mov	r2, r0
 8008c3a:	68fb      	ldr	r3, [r7, #12]
 8008c3c:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
 8008c40:	68fb      	ldr	r3, [r7, #12]
 8008c42:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008c46:	2b00      	cmp	r3, #0
 8008c48:	d102      	bne.n	8008c50 <InitSSL_Ctx+0x17e>
                           sizeof(WOLFSSL_X509_VERIFY_PARAM),
                           heap, DYNAMIC_TYPE_OPENSSL)) == NULL) {
        WOLFSSL_MSG("ctx->x509_store.param: allocation error");
        return MEMORY_E;
 8008c4a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8008c4e:	e02c      	b.n	8008caa <InitSSL_Ctx+0x1d8>
    }
    XMEMSET(ctx->x509_store.param, 0, sizeof(WOLFSSL_X509_VERIFY_PARAM));
 8008c50:	68fb      	ldr	r3, [r7, #12]
 8008c52:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008c56:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 8008c5a:	2100      	movs	r1, #0
 8008c5c:	4618      	mov	r0, r3
 8008c5e:	f01f ffe1 	bl	8028c24 <memset>

    if (wc_InitMutex(&ctx->x509_store.lookup.dirs->lock) != 0) {
 8008c62:	68fb      	ldr	r3, [r7, #12]
 8008c64:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008c68:	3304      	adds	r3, #4
 8008c6a:	4618      	mov	r0, r3
 8008c6c:	f01e fd2a 	bl	80276c4 <wc_InitMutex>
 8008c70:	4603      	mov	r3, r0
 8008c72:	2b00      	cmp	r3, #0
 8008c74:	d002      	beq.n	8008c7c <InitSSL_Ctx+0x1aa>
        WOLFSSL_MSG("Bad mutex init");
        WOLFSSL_ERROR_VERBOSE(BAD_MUTEX_E);
        return BAD_MUTEX_E;
 8008c76:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 8008c7a:	e016      	b.n	8008caa <InitSSL_Ctx+0x1d8>
    }
    #endif
#endif

#if defined(HAVE_EXTENDED_MASTER) && !defined(NO_WOLFSSL_CLIENT)
    if (method->side == WOLFSSL_CLIENT_END) {
 8008c7c:	68bb      	ldr	r3, [r7, #8]
 8008c7e:	789b      	ldrb	r3, [r3, #2]
 8008c80:	2b01      	cmp	r3, #1
 8008c82:	d10e      	bne.n	8008ca2 <InitSSL_Ctx+0x1d0>
        if ((method->version.major == SSLv3_MAJOR) &&
 8008c84:	68bb      	ldr	r3, [r7, #8]
 8008c86:	781b      	ldrb	r3, [r3, #0]
 8008c88:	2b03      	cmp	r3, #3
 8008c8a:	d10a      	bne.n	8008ca2 <InitSSL_Ctx+0x1d0>
             (method->version.minor >= TLSv1_MINOR)) {
 8008c8c:	68bb      	ldr	r3, [r7, #8]
 8008c8e:	785b      	ldrb	r3, [r3, #1]
        if ((method->version.major == SSLv3_MAJOR) &&
 8008c90:	2b00      	cmp	r3, #0
 8008c92:	d006      	beq.n	8008ca2 <InitSSL_Ctx+0x1d0>

            ctx->haveEMS = 1;
 8008c94:	68fa      	ldr	r2, [r7, #12]
 8008c96:	f892 3061 	ldrb.w	r3, [r2, #97]	@ 0x61
 8008c9a:	f043 0301 	orr.w	r3, r3, #1
 8008c9e:	f882 3061 	strb.w	r3, [r2, #97]	@ 0x61
     * Qt doesn't allow to use a cipher if it is not in the supported list.
     * Therefore, we need to enable PSK cipher at the beginning.
     */
    ctx->havePSK = 1;
#endif
    ctx->heap = heap; /* wolfSSL_CTX_load_static_memory sets */
 8008ca2:	68fb      	ldr	r3, [r7, #12]
 8008ca4:	687a      	ldr	r2, [r7, #4]
 8008ca6:	659a      	str	r2, [r3, #88]	@ 0x58
        WOLFSSL_MSG_EX("crypto_policy_init_ctx returned %d", ret);
        return ret;
    }
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

    return ret;
 8008ca8:	697b      	ldr	r3, [r7, #20]
}
 8008caa:	4618      	mov	r0, r3
 8008cac:	3718      	adds	r7, #24
 8008cae:	46bd      	mov	sp, r7
 8008cb0:	bd80      	pop	{r7, pc}

08008cb2 <SSL_CtxResourceFree>:
 * logic. A WOLFSSL_CTX can be assigned a static memory heap hint using
 * wolfSSL_CTX_load_static_memory after CTX creation, which means variables
 * allocated in InitSSL_Ctx were allocated from heap and should be free'd with
 * a NULL heap hint. */
void SSL_CtxResourceFree(WOLFSSL_CTX* ctx)
{
 8008cb2:	b580      	push	{r7, lr}
 8008cb4:	b08c      	sub	sp, #48	@ 0x30
 8008cb6:	af00      	add	r7, sp, #0
 8008cb8:	6078      	str	r0, [r7, #4]
#if defined(HAVE_CERTIFICATE_STATUS_REQUEST_V2) && \
                     defined(HAVE_TLS_EXTENSIONS) && !defined(NO_WOLFSSL_SERVER)
    int i;
#endif
    void* heapAtCTXInit = ctx->heap;
 8008cba:	687b      	ldr	r3, [r7, #4]
 8008cbc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008cbe:	62fb      	str	r3, [r7, #44]	@ 0x2c
#ifdef HAVE_WOLF_EVENT
    wolfEventQueue_Free(&ctx->event_queue);
#endif /* HAVE_WOLF_EVENT */

#ifndef NO_TLS /* its a static global see ssl.c "gNoTlsMethod" */
    XFREE(ctx->method, heapAtCTXInit, DYNAMIC_TYPE_METHOD);
 8008cc0:	687b      	ldr	r3, [r7, #4]
 8008cc2:	681b      	ldr	r3, [r3, #0]
 8008cc4:	62bb      	str	r3, [r7, #40]	@ 0x28
 8008cc6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8008cc8:	2b00      	cmp	r3, #0
 8008cca:	d002      	beq.n	8008cd2 <SSL_CtxResourceFree+0x20>
 8008ccc:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8008cce:	f015 fff1 	bl	801ecb4 <wolfSSL_Free>
#endif
    ctx->method = NULL;
 8008cd2:	687b      	ldr	r3, [r7, #4]
 8008cd4:	2200      	movs	r2, #0
 8008cd6:	601a      	str	r2, [r3, #0]

    XFREE(ctx->suites, ctx->heap, DYNAMIC_TYPE_SUITES);
 8008cd8:	687b      	ldr	r3, [r7, #4]
 8008cda:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008cdc:	627b      	str	r3, [r7, #36]	@ 0x24
 8008cde:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008ce0:	2b00      	cmp	r3, #0
 8008ce2:	d002      	beq.n	8008cea <SSL_CtxResourceFree+0x38>
 8008ce4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8008ce6:	f015 ffe5 	bl	801ecb4 <wolfSSL_Free>
    ctx->suites = NULL;
 8008cea:	687b      	ldr	r3, [r7, #4]
 8008cec:	2200      	movs	r2, #0
 8008cee:	655a      	str	r2, [r3, #84]	@ 0x54

#ifndef NO_DH
    XFREE(ctx->serverDH_G.buffer, ctx->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8008cf0:	687b      	ldr	r3, [r7, #4]
 8008cf2:	699b      	ldr	r3, [r3, #24]
 8008cf4:	623b      	str	r3, [r7, #32]
 8008cf6:	6a3b      	ldr	r3, [r7, #32]
 8008cf8:	2b00      	cmp	r3, #0
 8008cfa:	d002      	beq.n	8008d02 <SSL_CtxResourceFree+0x50>
 8008cfc:	6a38      	ldr	r0, [r7, #32]
 8008cfe:	f015 ffd9 	bl	801ecb4 <wolfSSL_Free>
    ctx->serverDH_G.buffer = NULL;
 8008d02:	687b      	ldr	r3, [r7, #4]
 8008d04:	2200      	movs	r2, #0
 8008d06:	619a      	str	r2, [r3, #24]
    XFREE(ctx->serverDH_P.buffer, ctx->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8008d08:	687b      	ldr	r3, [r7, #4]
 8008d0a:	691b      	ldr	r3, [r3, #16]
 8008d0c:	61fb      	str	r3, [r7, #28]
 8008d0e:	69fb      	ldr	r3, [r7, #28]
 8008d10:	2b00      	cmp	r3, #0
 8008d12:	d002      	beq.n	8008d1a <SSL_CtxResourceFree+0x68>
 8008d14:	69f8      	ldr	r0, [r7, #28]
 8008d16:	f015 ffcd 	bl	801ecb4 <wolfSSL_Free>
    ctx->serverDH_P.buffer = NULL;
 8008d1a:	687b      	ldr	r3, [r7, #4]
 8008d1c:	2200      	movs	r2, #0
 8008d1e:	611a      	str	r2, [r3, #16]
#endif /* !NO_DH */

#ifdef SINGLE_THREADED
    if (ctx->rng) {
 8008d20:	687b      	ldr	r3, [r7, #4]
 8008d22:	685b      	ldr	r3, [r3, #4]
 8008d24:	2b00      	cmp	r3, #0
 8008d26:	d010      	beq.n	8008d4a <SSL_CtxResourceFree+0x98>
        wc_FreeRng(ctx->rng);
 8008d28:	687b      	ldr	r3, [r7, #4]
 8008d2a:	685b      	ldr	r3, [r3, #4]
 8008d2c:	4618      	mov	r0, r3
 8008d2e:	f016 fdcd 	bl	801f8cc <wc_FreeRng>
        XFREE(ctx->rng, ctx->heap, DYNAMIC_TYPE_RNG);
 8008d32:	687b      	ldr	r3, [r7, #4]
 8008d34:	685b      	ldr	r3, [r3, #4]
 8008d36:	61bb      	str	r3, [r7, #24]
 8008d38:	69bb      	ldr	r3, [r7, #24]
 8008d3a:	2b00      	cmp	r3, #0
 8008d3c:	d002      	beq.n	8008d44 <SSL_CtxResourceFree+0x92>
 8008d3e:	69b8      	ldr	r0, [r7, #24]
 8008d40:	f015 ffb8 	bl	801ecb4 <wolfSSL_Free>
        ctx->rng = NULL;
 8008d44:	687b      	ldr	r3, [r7, #4]
 8008d46:	2200      	movs	r2, #0
 8008d48:	605a      	str	r2, [r3, #4]
    }
#endif /* SINGLE_THREADED */

#ifndef NO_CERTS
    if (ctx->privateKey != NULL && ctx->privateKey->buffer != NULL) {
 8008d4a:	687b      	ldr	r3, [r7, #4]
 8008d4c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008d4e:	2b00      	cmp	r3, #0
 8008d50:	d00e      	beq.n	8008d70 <SSL_CtxResourceFree+0xbe>
 8008d52:	687b      	ldr	r3, [r7, #4]
 8008d54:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008d56:	681b      	ldr	r3, [r3, #0]
 8008d58:	2b00      	cmp	r3, #0
 8008d5a:	d009      	beq.n	8008d70 <SSL_CtxResourceFree+0xbe>
        ForceZero(ctx->privateKey->buffer, ctx->privateKey->length);
 8008d5c:	687b      	ldr	r3, [r7, #4]
 8008d5e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008d60:	681a      	ldr	r2, [r3, #0]
 8008d62:	687b      	ldr	r3, [r7, #4]
 8008d64:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008d66:	689b      	ldr	r3, [r3, #8]
 8008d68:	4619      	mov	r1, r3
 8008d6a:	4610      	mov	r0, r2
 8008d6c:	f7ff fe5d 	bl	8008a2a <ForceZero>
    }
    FreeDer(&ctx->privateKey);
 8008d70:	687b      	ldr	r3, [r7, #4]
 8008d72:	3340      	adds	r3, #64	@ 0x40
 8008d74:	4618      	mov	r0, r3
 8008d76:	f010 f9b9 	bl	80190ec <FreeDer>
#endif
#endif /* WOLFSSL_DUAL_ALG_CERTS */
#ifdef OPENSSL_ALL
    wolfSSL_EVP_PKEY_free(ctx->privateKeyPKey);
#endif
    FreeDer(&ctx->certificate);
 8008d7a:	687b      	ldr	r3, [r7, #4]
 8008d7c:	3320      	adds	r3, #32
 8008d7e:	4618      	mov	r0, r3
 8008d80:	f010 f9b4 	bl	80190ec <FreeDer>
        if (ctx->ourCert && ctx->ownOurCert) {
            wolfSSL_X509_free(ctx->ourCert);
            ctx->ourCert = NULL;
        }
    #endif /* KEEP_OUR_CERT */
    FreeDer(&ctx->certChain);
 8008d84:	687b      	ldr	r3, [r7, #4]
 8008d86:	3324      	adds	r3, #36	@ 0x24
 8008d88:	4618      	mov	r0, r3
 8008d8a:	f010 f9af 	bl	80190ec <FreeDer>
    wolfSSL_CertManagerFree(ctx->cm);
 8008d8e:	687b      	ldr	r3, [r7, #4]
 8008d90:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008d92:	4618      	mov	r0, r3
 8008d94:	f002 fcd7 	bl	800b746 <wolfSSL_CertManagerFree>
    ctx->cm = NULL;
 8008d98:	687b      	ldr	r3, [r7, #4]
 8008d9a:	2200      	movs	r2, #0
 8008d9c:	651a      	str	r2, [r3, #80]	@ 0x50
            ctx->x509_store.objs = NULL;
        }
    #endif
    #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \
        defined(WOLFSSL_WPAS_SMALL)
        wolfSSL_X509_STORE_free(ctx->x509_store_pt);
 8008d9e:	687b      	ldr	r3, [r7, #4]
 8008da0:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8008da4:	4618      	mov	r0, r3
 8008da6:	f006 fa3c 	bl	800f222 <wolfSSL_X509_STORE_free>
    #endif
    #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA) || defined(HAVE_LIGHTY)
        wolfSSL_sk_X509_NAME_pop_free(ctx->client_ca_names, NULL);
 8008daa:	687b      	ldr	r3, [r7, #4]
 8008dac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8008dae:	2100      	movs	r1, #0
 8008db0:	4618      	mov	r0, r3
 8008db2:	f005 ff97 	bl	800ece4 <wolfSSL_sk_X509_NAME_pop_free>
        ctx->client_ca_names = NULL;
 8008db6:	687b      	ldr	r3, [r7, #4]
 8008db8:	2200      	movs	r2, #0
 8008dba:	629a      	str	r2, [r3, #40]	@ 0x28
    #endif
    #ifdef OPENSSL_EXTRA
        if (ctx->x509Chain) {
 8008dbc:	687b      	ldr	r3, [r7, #4]
 8008dbe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008dc0:	2b00      	cmp	r3, #0
 8008dc2:	d008      	beq.n	8008dd6 <SSL_CtxResourceFree+0x124>
            wolfSSL_sk_X509_pop_free(ctx->x509Chain, NULL);
 8008dc4:	687b      	ldr	r3, [r7, #4]
 8008dc6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008dc8:	2100      	movs	r1, #0
 8008dca:	4618      	mov	r0, r3
 8008dcc:	f005 fb7e 	bl	800e4cc <wolfSSL_sk_X509_pop_free>
            ctx->x509Chain = NULL;
 8008dd0:	687b      	ldr	r3, [r7, #4]
 8008dd2:	2200      	movs	r2, #0
 8008dd4:	62da      	str	r2, [r3, #44]	@ 0x2c
    #endif
#endif /* !NO_CERTS */

#ifdef HAVE_TLS_EXTENSIONS
#if !defined(NO_TLS)
    TLSX_FreeAll(ctx->extensions, ctx->heap);
 8008dd6:	687b      	ldr	r3, [r7, #4]
 8008dd8:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
 8008ddc:	687b      	ldr	r3, [r7, #4]
 8008dde:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008de0:	4619      	mov	r1, r3
 8008de2:	4610      	mov	r0, r2
 8008de4:	f006 fbcc 	bl	800f580 <TLSX_FreeAll>
#endif /* HAVE_CERTIFICATE_STATUS_REQUEST_V2 */
#endif /* !NO_WOLFSSL_SERVER */

#endif /* HAVE_TLS_EXTENSIONS */
#ifdef OPENSSL_EXTRA
    if (ctx->alpn_cli_protos) {
 8008de8:	687b      	ldr	r3, [r7, #4]
 8008dea:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008dee:	2b00      	cmp	r3, #0
 8008df0:	d00d      	beq.n	8008e0e <SSL_CtxResourceFree+0x15c>
        XFREE((void*)ctx->alpn_cli_protos, ctx->heap, DYNAMIC_TYPE_OPENSSL);
 8008df2:	687b      	ldr	r3, [r7, #4]
 8008df4:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008df8:	617b      	str	r3, [r7, #20]
 8008dfa:	697b      	ldr	r3, [r7, #20]
 8008dfc:	2b00      	cmp	r3, #0
 8008dfe:	d002      	beq.n	8008e06 <SSL_CtxResourceFree+0x154>
 8008e00:	6978      	ldr	r0, [r7, #20]
 8008e02:	f015 ff57 	bl	801ecb4 <wolfSSL_Free>
        ctx->alpn_cli_protos = NULL;
 8008e06:	687b      	ldr	r3, [r7, #4]
 8008e08:	2200      	movs	r2, #0
 8008e0a:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
    }
    XFREE(ctx->param, heapAtCTXInit, DYNAMIC_TYPE_OPENSSL);
 8008e0e:	687b      	ldr	r3, [r7, #4]
 8008e10:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8008e14:	613b      	str	r3, [r7, #16]
 8008e16:	693b      	ldr	r3, [r7, #16]
 8008e18:	2b00      	cmp	r3, #0
 8008e1a:	d002      	beq.n	8008e22 <SSL_CtxResourceFree+0x170>
 8008e1c:	6938      	ldr	r0, [r7, #16]
 8008e1e:	f015 ff49 	bl	801ecb4 <wolfSSL_Free>
    ctx->param = NULL;
 8008e22:	687b      	ldr	r3, [r7, #4]
 8008e24:	2200      	movs	r2, #0
 8008e26:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8

    if (ctx->x509_store.param) {
 8008e2a:	687b      	ldr	r3, [r7, #4]
 8008e2c:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008e30:	2b00      	cmp	r3, #0
 8008e32:	d00d      	beq.n	8008e50 <SSL_CtxResourceFree+0x19e>
        XFREE(ctx->x509_store.param, heapAtCTXInit, DYNAMIC_TYPE_OPENSSL);
 8008e34:	687b      	ldr	r3, [r7, #4]
 8008e36:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008e3a:	60fb      	str	r3, [r7, #12]
 8008e3c:	68fb      	ldr	r3, [r7, #12]
 8008e3e:	2b00      	cmp	r3, #0
 8008e40:	d002      	beq.n	8008e48 <SSL_CtxResourceFree+0x196>
 8008e42:	68f8      	ldr	r0, [r7, #12]
 8008e44:	f015 ff36 	bl	801ecb4 <wolfSSL_Free>
        ctx->x509_store.param = NULL;
 8008e48:	687b      	ldr	r3, [r7, #4]
 8008e4a:	2200      	movs	r2, #0
 8008e4c:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
    }

    if (ctx->x509_store.lookup.dirs) {
 8008e50:	687b      	ldr	r3, [r7, #4]
 8008e52:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008e56:	2b00      	cmp	r3, #0
 8008e58:	d010      	beq.n	8008e7c <SSL_CtxResourceFree+0x1ca>
        if (ctx->x509_store.lookup.dirs->dir_entry) {
            wolfSSL_sk_BY_DIR_entry_free(ctx->x509_store.lookup.dirs->dir_entry);
        }

#endif
        wc_FreeMutex(&ctx->x509_store.lookup.dirs->lock);
 8008e5a:	687b      	ldr	r3, [r7, #4]
 8008e5c:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008e60:	3304      	adds	r3, #4
 8008e62:	4618      	mov	r0, r3
 8008e64:	f01e fc39 	bl	80276da <wc_FreeMutex>
        XFREE(ctx->x509_store.lookup.dirs, heapAtCTXInit, DYNAMIC_TYPE_OPENSSL);
 8008e68:	687b      	ldr	r3, [r7, #4]
 8008e6a:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008e6e:	60bb      	str	r3, [r7, #8]
 8008e70:	68bb      	ldr	r3, [r7, #8]
 8008e72:	2b00      	cmp	r3, #0
 8008e74:	d002      	beq.n	8008e7c <SSL_CtxResourceFree+0x1ca>
 8008e76:	68b8      	ldr	r0, [r7, #8]
 8008e78:	f015 ff1c 	bl	801ecb4 <wolfSSL_Free>
#if defined(WOLFSSL_TLS13) && defined(HAVE_ECH)
    FreeEchConfigs(ctx->echConfigs, ctx->heap);
    ctx->echConfigs = NULL;
#endif
    (void)heapAtCTXInit;
}
 8008e7c:	bf00      	nop
 8008e7e:	3730      	adds	r7, #48	@ 0x30
 8008e80:	46bd      	mov	sp, r7
 8008e82:	bd80      	pop	{r7, pc}

08008e84 <FreeSSL_Ctx>:


void FreeSSL_Ctx(WOLFSSL_CTX* ctx)
{
 8008e84:	b580      	push	{r7, lr}
 8008e86:	b088      	sub	sp, #32
 8008e88:	af00      	add	r7, sp, #0
 8008e8a:	6078      	str	r0, [r7, #4]
    int isZero;
    int ret;
    void* heap = ctx->heap;
 8008e8c:	687b      	ldr	r3, [r7, #4]
 8008e8e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008e90:	61fb      	str	r3, [r7, #28]
        heap = NULL;
    }
#endif

    /* decrement CTX reference count */
    wolfSSL_RefWithMutexDec(&ctx->ref, &isZero, &ret);
 8008e92:	687b      	ldr	r3, [r7, #4]
 8008e94:	3308      	adds	r3, #8
 8008e96:	2101      	movs	r1, #1
 8008e98:	4618      	mov	r0, r3
 8008e9a:	f7ff fdb1 	bl	8008a00 <wolfSSL_Atomic_Int_FetchSub>
 8008e9e:	61b8      	str	r0, [r7, #24]
 8008ea0:	69bb      	ldr	r3, [r7, #24]
 8008ea2:	2b01      	cmp	r3, #1
 8008ea4:	bf0c      	ite	eq
 8008ea6:	2301      	moveq	r3, #1
 8008ea8:	2300      	movne	r3, #0
 8008eaa:	b2db      	uxtb	r3, r3
 8008eac:	613b      	str	r3, [r7, #16]
 8008eae:	2300      	movs	r3, #0
 8008eb0:	60fb      	str	r3, [r7, #12]
    }
#else
    (void)ret;
#endif

    if (isZero) {
 8008eb2:	693b      	ldr	r3, [r7, #16]
 8008eb4:	2b00      	cmp	r3, #0
 8008eb6:	d00a      	beq.n	8008ece <FreeSSL_Ctx+0x4a>
        WOLFSSL_MSG("CTX ref count down to 0, doing full free");

        SSL_CtxResourceFree(ctx);
 8008eb8:	6878      	ldr	r0, [r7, #4]
 8008eba:	f7ff fefa 	bl	8008cb2 <SSL_CtxResourceFree>
#if defined(HAVE_SESSION_TICKET) && !defined(NO_WOLFSSL_SERVER) && \
    !defined(WOLFSSL_NO_DEF_TICKET_ENC_CB) && !defined(NO_TLS)
        TicketEncCbCtx_Free(&ctx->ticketKeyCtx);
#endif
        wolfSSL_RefFree(&ctx->ref);
        XFREE(ctx, heap, DYNAMIC_TYPE_CTX);
 8008ebe:	687b      	ldr	r3, [r7, #4]
 8008ec0:	617b      	str	r3, [r7, #20]
 8008ec2:	697b      	ldr	r3, [r7, #20]
 8008ec4:	2b00      	cmp	r3, #0
 8008ec6:	d002      	beq.n	8008ece <FreeSSL_Ctx+0x4a>
 8008ec8:	6978      	ldr	r0, [r7, #20]
 8008eca:	f015 fef3 	bl	801ecb4 <wolfSSL_Free>
    }
    else {
        WOLFSSL_MSG("CTX ref count not 0 yet, no free");
    }
    (void)heap; /* not used in some builds */
}
 8008ece:	bf00      	nop
 8008ed0:	3720      	adds	r7, #32
 8008ed2:	46bd      	mov	sp, r7
 8008ed4:	bd80      	pop	{r7, pc}

08008ed6 <FreeCiphersSide>:
#endif /* WOLFSSL_DTLS13 */

}

static void FreeCiphersSide(Ciphers *cipher, void* heap)
{
 8008ed6:	b580      	push	{r7, lr}
 8008ed8:	b086      	sub	sp, #24
 8008eda:	af00      	add	r7, sp, #0
 8008edc:	6078      	str	r0, [r7, #4]
 8008ede:	6039      	str	r1, [r7, #0]
    cipher->des3 = NULL;
#endif
#if defined(BUILD_AES) || defined(BUILD_AESGCM) || defined(HAVE_ARIA)
    /* See: InitKeys() in keys.c on addition of BUILD_AESGCM check (enc->aes,
     * dec->aes) */
    wc_AesFree(cipher->aes);
 8008ee0:	687b      	ldr	r3, [r7, #4]
 8008ee2:	681b      	ldr	r3, [r3, #0]
 8008ee4:	4618      	mov	r0, r3
 8008ee6:	f009 fc7b 	bl	80127e0 <wc_AesFree>
    XFREE(cipher->aes, heap, DYNAMIC_TYPE_CIPHER);
 8008eea:	687b      	ldr	r3, [r7, #4]
 8008eec:	681b      	ldr	r3, [r3, #0]
 8008eee:	617b      	str	r3, [r7, #20]
 8008ef0:	697b      	ldr	r3, [r7, #20]
 8008ef2:	2b00      	cmp	r3, #0
 8008ef4:	d002      	beq.n	8008efc <FreeCiphersSide+0x26>
 8008ef6:	6978      	ldr	r0, [r7, #20]
 8008ef8:	f015 fedc 	bl	801ecb4 <wolfSSL_Free>
    cipher->aes = NULL;
 8008efc:	687b      	ldr	r3, [r7, #4]
 8008efe:	2200      	movs	r2, #0
 8008f00:	601a      	str	r2, [r3, #0]
    XFREE(cipher->sm4, heap, DYNAMIC_TYPE_CIPHER);
    cipher->sm4 = NULL;
#endif
#if (defined(BUILD_AESGCM) || defined(BUILD_AESCCM) || defined(HAVE_ARIA)) && \
    !defined(WOLFSSL_NO_TLS12)
    XFREE(cipher->additional, heap, DYNAMIC_TYPE_CIPHER);
 8008f02:	687b      	ldr	r3, [r7, #4]
 8008f04:	685b      	ldr	r3, [r3, #4]
 8008f06:	613b      	str	r3, [r7, #16]
 8008f08:	693b      	ldr	r3, [r7, #16]
 8008f0a:	2b00      	cmp	r3, #0
 8008f0c:	d002      	beq.n	8008f14 <FreeCiphersSide+0x3e>
 8008f0e:	6938      	ldr	r0, [r7, #16]
 8008f10:	f015 fed0 	bl	801ecb4 <wolfSSL_Free>
    cipher->additional = NULL;
 8008f14:	687b      	ldr	r3, [r7, #4]
 8008f16:	2200      	movs	r2, #0
 8008f18:	605a      	str	r2, [r3, #4]
#endif
#ifdef CIPHER_NONCE
    XFREE(cipher->nonce, heap, DYNAMIC_TYPE_CIPHER);
 8008f1a:	687b      	ldr	r3, [r7, #4]
 8008f1c:	689b      	ldr	r3, [r3, #8]
 8008f1e:	60fb      	str	r3, [r7, #12]
 8008f20:	68fb      	ldr	r3, [r7, #12]
 8008f22:	2b00      	cmp	r3, #0
 8008f24:	d002      	beq.n	8008f2c <FreeCiphersSide+0x56>
 8008f26:	68f8      	ldr	r0, [r7, #12]
 8008f28:	f015 fec4 	bl	801ecb4 <wolfSSL_Free>
    cipher->nonce = NULL;
 8008f2c:	687b      	ldr	r3, [r7, #4]
 8008f2e:	2200      	movs	r2, #0
 8008f30:	609a      	str	r2, [r3, #8]
#ifdef HAVE_CAMELLIA
    XFREE(cipher->cam, heap, DYNAMIC_TYPE_CIPHER);
    cipher->cam = NULL;
#endif
#ifdef HAVE_CHACHA
    if (cipher->chacha)
 8008f32:	687b      	ldr	r3, [r7, #4]
 8008f34:	68db      	ldr	r3, [r3, #12]
 8008f36:	2b00      	cmp	r3, #0
 8008f38:	d005      	beq.n	8008f46 <FreeCiphersSide+0x70>
        ForceZero(cipher->chacha, sizeof(ChaCha));
 8008f3a:	687b      	ldr	r3, [r7, #4]
 8008f3c:	68db      	ldr	r3, [r3, #12]
 8008f3e:	2144      	movs	r1, #68	@ 0x44
 8008f40:	4618      	mov	r0, r3
 8008f42:	f7ff fd72 	bl	8008a2a <ForceZero>
    XFREE(cipher->chacha, heap, DYNAMIC_TYPE_CIPHER);
 8008f46:	687b      	ldr	r3, [r7, #4]
 8008f48:	68db      	ldr	r3, [r3, #12]
 8008f4a:	60bb      	str	r3, [r7, #8]
 8008f4c:	68bb      	ldr	r3, [r7, #8]
 8008f4e:	2b00      	cmp	r3, #0
 8008f50:	d002      	beq.n	8008f58 <FreeCiphersSide+0x82>
 8008f52:	68b8      	ldr	r0, [r7, #8]
 8008f54:	f015 feae 	bl	801ecb4 <wolfSSL_Free>
    cipher->chacha = NULL;
 8008f58:	687b      	ldr	r3, [r7, #4]
 8008f5a:	2200      	movs	r2, #0
 8008f5c:	60da      	str	r2, [r3, #12]
#if defined(WOLFSSL_TLS13) && defined(HAVE_NULL_CIPHER)
    wc_HmacFree(cipher->hmac);
    XFREE(cipher->hmac, heap, DYNAMIC_TYPE_CIPHER);
    cipher->hmac = NULL;
#endif
}
 8008f5e:	bf00      	nop
 8008f60:	3718      	adds	r7, #24
 8008f62:	46bd      	mov	sp, r7
 8008f64:	bd80      	pop	{r7, pc}

08008f66 <FreeCiphers>:

/* Free ciphers */
void FreeCiphers(WOLFSSL* ssl)
{
 8008f66:	b580      	push	{r7, lr}
 8008f68:	b084      	sub	sp, #16
 8008f6a:	af00      	add	r7, sp, #0
 8008f6c:	6078      	str	r0, [r7, #4]
    FreeCiphersSide(&ssl->encrypt, ssl->heap);
 8008f6e:	687b      	ldr	r3, [r7, #4]
 8008f70:	f103 02bc 	add.w	r2, r3, #188	@ 0xbc
 8008f74:	687b      	ldr	r3, [r7, #4]
 8008f76:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8008f7a:	4619      	mov	r1, r3
 8008f7c:	4610      	mov	r0, r2
 8008f7e:	f7ff ffaa 	bl	8008ed6 <FreeCiphersSide>
    FreeCiphersSide(&ssl->decrypt, ssl->heap);
 8008f82:	687b      	ldr	r3, [r7, #4]
 8008f84:	f103 02d0 	add.w	r2, r3, #208	@ 0xd0
 8008f88:	687b      	ldr	r3, [r7, #4]
 8008f8a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8008f8e:	4619      	mov	r1, r3
 8008f90:	4610      	mov	r0, r2
 8008f92:	f7ff ffa0 	bl	8008ed6 <FreeCiphersSide>

#if defined(HAVE_POLY1305) && defined(HAVE_ONE_TIME_AUTH)
    if (ssl->auth.poly1305)
 8008f96:	687b      	ldr	r3, [r7, #4]
 8008f98:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008f9c:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008fa0:	2b00      	cmp	r3, #0
 8008fa2:	d008      	beq.n	8008fb6 <FreeCiphers+0x50>
        ForceZero(ssl->auth.poly1305, sizeof(Poly1305));
 8008fa4:	687b      	ldr	r3, [r7, #4]
 8008fa6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008faa:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008fae:	2150      	movs	r1, #80	@ 0x50
 8008fb0:	4618      	mov	r0, r3
 8008fb2:	f7ff fd3a 	bl	8008a2a <ForceZero>
    XFREE(ssl->auth.poly1305, ssl->heap, DYNAMIC_TYPE_CIPHER);
 8008fb6:	687b      	ldr	r3, [r7, #4]
 8008fb8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008fbc:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008fc0:	60fb      	str	r3, [r7, #12]
 8008fc2:	68fb      	ldr	r3, [r7, #12]
 8008fc4:	2b00      	cmp	r3, #0
 8008fc6:	d002      	beq.n	8008fce <FreeCiphers+0x68>
 8008fc8:	68f8      	ldr	r0, [r7, #12]
 8008fca:	f015 fe73 	bl	801ecb4 <wolfSSL_Free>
    ssl->auth.poly1305 = NULL;
 8008fce:	687b      	ldr	r3, [r7, #4]
 8008fd0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008fd4:	461a      	mov	r2, r3
 8008fd6:	2300      	movs	r3, #0
 8008fd8:	f8c2 3098 	str.w	r3, [r2, #152]	@ 0x98
    XFREE(ssl->dtlsRecordNumberDecrypt.chacha, ssl->heap, DYNAMIC_TYPE_CIPHER);
    ssl->dtlsRecordNumberEncrypt.chacha = NULL;
    ssl->dtlsRecordNumberDecrypt.chacha = NULL;
#endif /* HAVE_CHACHA */
#endif /* WOLFSSL_DTLS13 */
}
 8008fdc:	bf00      	nop
 8008fde:	3710      	adds	r7, #16
 8008fe0:	46bd      	mov	sp, r7
 8008fe2:	bd80      	pop	{r7, pc}

08008fe4 <AddSuiteHashSigAlgo>:
        *(inOutIdx) += 2;                               \
    } while (0)

static WC_INLINE void AddSuiteHashSigAlgo(byte* hashSigAlgo, byte macAlgo,
    byte sigAlgo, int keySz, word16* inOutIdx)
{
 8008fe4:	b480      	push	{r7}
 8008fe6:	b087      	sub	sp, #28
 8008fe8:	af00      	add	r7, sp, #0
 8008fea:	60f8      	str	r0, [r7, #12]
 8008fec:	607b      	str	r3, [r7, #4]
 8008fee:	460b      	mov	r3, r1
 8008ff0:	72fb      	strb	r3, [r7, #11]
 8008ff2:	4613      	mov	r3, r2
 8008ff4:	72bb      	strb	r3, [r7, #10]
    int addSigAlgo = 1;
 8008ff6:	2301      	movs	r3, #1
 8008ff8:	617b      	str	r3, [r7, #20]
    }
#else
    (void)keySz;
#endif /* USE_ECDSA_KEYSZ_HASH_ALGO */

    if (addSigAlgo) {
 8008ffa:	697b      	ldr	r3, [r7, #20]
 8008ffc:	2b00      	cmp	r3, #0
 8008ffe:	d04a      	beq.n	8009096 <AddSuiteHashSigAlgo+0xb2>
                DILITHIUM_LEVEL5_SA_MAJOR, DILITHIUM_LEVEL5_SA_MINOR);
        }
        else
    #endif /* HAVE_DILITHIUM */
#ifdef WC_RSA_PSS
        if (sigAlgo == rsa_pss_sa_algo) {
 8009000:	7abb      	ldrb	r3, [r7, #10]
 8009002:	2b08      	cmp	r3, #8
 8009004:	d130      	bne.n	8009068 <AddSuiteHashSigAlgo+0x84>
            /* RSA PSS is sig then mac */
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, sigAlgo, macAlgo);
 8009006:	68fb      	ldr	r3, [r7, #12]
 8009008:	2b00      	cmp	r3, #0
 800900a:	d00d      	beq.n	8009028 <AddSuiteHashSigAlgo+0x44>
 800900c:	6a3b      	ldr	r3, [r7, #32]
 800900e:	881b      	ldrh	r3, [r3, #0]
 8009010:	461a      	mov	r2, r3
 8009012:	68fb      	ldr	r3, [r7, #12]
 8009014:	4413      	add	r3, r2
 8009016:	7aba      	ldrb	r2, [r7, #10]
 8009018:	701a      	strb	r2, [r3, #0]
 800901a:	6a3b      	ldr	r3, [r7, #32]
 800901c:	881b      	ldrh	r3, [r3, #0]
 800901e:	3301      	adds	r3, #1
 8009020:	68fa      	ldr	r2, [r7, #12]
 8009022:	4413      	add	r3, r2
 8009024:	7afa      	ldrb	r2, [r7, #11]
 8009026:	701a      	strb	r2, [r3, #0]
 8009028:	6a3b      	ldr	r3, [r7, #32]
 800902a:	881b      	ldrh	r3, [r3, #0]
 800902c:	3302      	adds	r3, #2
 800902e:	b29a      	uxth	r2, r3
 8009030:	6a3b      	ldr	r3, [r7, #32]
 8009032:	801a      	strh	r2, [r3, #0]
    #ifdef WOLFSSL_TLS13
            /* Add the certificate algorithm as well */
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, sigAlgo,
 8009034:	68fb      	ldr	r3, [r7, #12]
 8009036:	2b00      	cmp	r3, #0
 8009038:	d00f      	beq.n	800905a <AddSuiteHashSigAlgo+0x76>
 800903a:	6a3b      	ldr	r3, [r7, #32]
 800903c:	881b      	ldrh	r3, [r3, #0]
 800903e:	461a      	mov	r2, r3
 8009040:	68fb      	ldr	r3, [r7, #12]
 8009042:	4413      	add	r3, r2
 8009044:	7aba      	ldrb	r2, [r7, #10]
 8009046:	701a      	strb	r2, [r3, #0]
 8009048:	6a3b      	ldr	r3, [r7, #32]
 800904a:	881b      	ldrh	r3, [r3, #0]
 800904c:	3301      	adds	r3, #1
 800904e:	68fa      	ldr	r2, [r7, #12]
 8009050:	4413      	add	r3, r2
 8009052:	7afa      	ldrb	r2, [r7, #11]
 8009054:	3205      	adds	r2, #5
 8009056:	b2d2      	uxtb	r2, r2
 8009058:	701a      	strb	r2, [r3, #0]
 800905a:	6a3b      	ldr	r3, [r7, #32]
 800905c:	881b      	ldrh	r3, [r3, #0]
 800905e:	3302      	adds	r3, #2
 8009060:	b29a      	uxth	r2, r3
 8009062:	6a3b      	ldr	r3, [r7, #32]
 8009064:	801a      	strh	r2, [r3, #0]
#endif
        {
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, macAlgo, sigAlgo);
        }
    }
}
 8009066:	e016      	b.n	8009096 <AddSuiteHashSigAlgo+0xb2>
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, macAlgo, sigAlgo);
 8009068:	68fb      	ldr	r3, [r7, #12]
 800906a:	2b00      	cmp	r3, #0
 800906c:	d00d      	beq.n	800908a <AddSuiteHashSigAlgo+0xa6>
 800906e:	6a3b      	ldr	r3, [r7, #32]
 8009070:	881b      	ldrh	r3, [r3, #0]
 8009072:	461a      	mov	r2, r3
 8009074:	68fb      	ldr	r3, [r7, #12]
 8009076:	4413      	add	r3, r2
 8009078:	7afa      	ldrb	r2, [r7, #11]
 800907a:	701a      	strb	r2, [r3, #0]
 800907c:	6a3b      	ldr	r3, [r7, #32]
 800907e:	881b      	ldrh	r3, [r3, #0]
 8009080:	3301      	adds	r3, #1
 8009082:	68fa      	ldr	r2, [r7, #12]
 8009084:	4413      	add	r3, r2
 8009086:	7aba      	ldrb	r2, [r7, #10]
 8009088:	701a      	strb	r2, [r3, #0]
 800908a:	6a3b      	ldr	r3, [r7, #32]
 800908c:	881b      	ldrh	r3, [r3, #0]
 800908e:	3302      	adds	r3, #2
 8009090:	b29a      	uxth	r2, r3
 8009092:	6a3b      	ldr	r3, [r7, #32]
 8009094:	801a      	strh	r2, [r3, #0]
}
 8009096:	bf00      	nop
 8009098:	371c      	adds	r7, #28
 800909a:	46bd      	mov	sp, r7
 800909c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80090a0:	4770      	bx	lr

080090a2 <InitSuitesHashSigAlgo>:

void InitSuitesHashSigAlgo(byte* hashSigAlgo, int haveSig, int tls1_2,
    int keySz, word16* len)
{
 80090a2:	b580      	push	{r7, lr}
 80090a4:	b088      	sub	sp, #32
 80090a6:	af02      	add	r7, sp, #8
 80090a8:	60f8      	str	r0, [r7, #12]
 80090aa:	60b9      	str	r1, [r7, #8]
 80090ac:	607a      	str	r2, [r7, #4]
 80090ae:	603b      	str	r3, [r7, #0]
    word16 idx = 0;
 80090b0:	2300      	movs	r3, #0
 80090b2:	82fb      	strh	r3, [r7, #22]

    (void)tls1_2;
    (void)keySz;

#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    if (haveSig & SIG_ECDSA) {
 80090b4:	68bb      	ldr	r3, [r7, #8]
 80090b6:	f003 0301 	and.w	r3, r3, #1
 80090ba:	2b00      	cmp	r3, #0
 80090bc:	d008      	beq.n	80090d0 <InitSuitesHashSigAlgo+0x2e>
    #ifdef WOLFSSL_SHA384
        AddSuiteHashSigAlgo(hashSigAlgo, sha384_mac, ecc_dsa_sa_algo, keySz,
            &idx);
    #endif
    #ifndef NO_SHA256
        AddSuiteHashSigAlgo(hashSigAlgo, sha256_mac, ecc_dsa_sa_algo, keySz,
 80090be:	f107 0316 	add.w	r3, r7, #22
 80090c2:	9300      	str	r3, [sp, #0]
 80090c4:	683b      	ldr	r3, [r7, #0]
 80090c6:	2203      	movs	r2, #3
 80090c8:	2104      	movs	r1, #4
 80090ca:	68f8      	ldr	r0, [r7, #12]
 80090cc:	f7ff ff8a 	bl	8008fe4 <AddSuiteHashSigAlgo>
            keySz, &idx);
        AddSuiteHashSigAlgo(hashSigAlgo, no_mac, dilithium_level5_sa_algo,
            keySz, &idx);
    }
#endif /* HAVE_DILITHIUM */
    if (haveSig & SIG_RSA) {
 80090d0:	68bb      	ldr	r3, [r7, #8]
 80090d2:	f003 0302 	and.w	r3, r3, #2
 80090d6:	2b00      	cmp	r3, #0
 80090d8:	d014      	beq.n	8009104 <InitSuitesHashSigAlgo+0x62>
    #ifdef WC_RSA_PSS
        if (tls1_2) {
 80090da:	687b      	ldr	r3, [r7, #4]
 80090dc:	2b00      	cmp	r3, #0
 80090de:	d008      	beq.n	80090f2 <InitSuitesHashSigAlgo+0x50>
        #ifdef WOLFSSL_SHA384
            AddSuiteHashSigAlgo(hashSigAlgo, sha384_mac, rsa_pss_sa_algo, keySz,
                &idx);
        #endif
        #ifndef NO_SHA256
            AddSuiteHashSigAlgo(hashSigAlgo, sha256_mac, rsa_pss_sa_algo, keySz,
 80090e0:	f107 0316 	add.w	r3, r7, #22
 80090e4:	9300      	str	r3, [sp, #0]
 80090e6:	683b      	ldr	r3, [r7, #0]
 80090e8:	2208      	movs	r2, #8
 80090ea:	2104      	movs	r1, #4
 80090ec:	68f8      	ldr	r0, [r7, #12]
 80090ee:	f7ff ff79 	bl	8008fe4 <AddSuiteHashSigAlgo>
    #endif
    #ifdef WOLFSSL_SHA384
        AddSuiteHashSigAlgo(hashSigAlgo, sha384_mac, rsa_sa_algo, keySz, &idx);
    #endif
    #ifndef NO_SHA256
        AddSuiteHashSigAlgo(hashSigAlgo, sha256_mac, rsa_sa_algo, keySz, &idx);
 80090f2:	f107 0316 	add.w	r3, r7, #22
 80090f6:	9300      	str	r3, [sp, #0]
 80090f8:	683b      	ldr	r3, [r7, #0]
 80090fa:	2201      	movs	r2, #1
 80090fc:	2104      	movs	r1, #4
 80090fe:	68f8      	ldr	r0, [r7, #12]
 8009100:	f7ff ff70 	bl	8008fe4 <AddSuiteHashSigAlgo>
        AddSuiteHashSigAlgo(hashSigAlgo, sha_mac, anonymous_sa_algo, keySz,
            &idx);
    }
#endif

    *len = idx;
 8009104:	8afa      	ldrh	r2, [r7, #22]
 8009106:	6a3b      	ldr	r3, [r7, #32]
 8009108:	801a      	strh	r2, [r3, #0]
}
 800910a:	bf00      	nop
 800910c:	3718      	adds	r7, #24
 800910e:	46bd      	mov	sp, r7
 8009110:	bd80      	pop	{r7, pc}

08009112 <AllocateCtxSuites>:

int AllocateCtxSuites(WOLFSSL_CTX* ctx)
{
 8009112:	b580      	push	{r7, lr}
 8009114:	b082      	sub	sp, #8
 8009116:	af00      	add	r7, sp, #0
 8009118:	6078      	str	r0, [r7, #4]
    if (ctx->suites == NULL) {
 800911a:	687b      	ldr	r3, [r7, #4]
 800911c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800911e:	2b00      	cmp	r3, #0
 8009120:	d115      	bne.n	800914e <AllocateCtxSuites+0x3c>
        ctx->suites = (Suites*)XMALLOC(sizeof(Suites), ctx->heap,
 8009122:	f44f 70ac 	mov.w	r0, #344	@ 0x158
 8009126:	f015 fda9 	bl	801ec7c <wolfSSL_Malloc>
 800912a:	4602      	mov	r2, r0
 800912c:	687b      	ldr	r3, [r7, #4]
 800912e:	655a      	str	r2, [r3, #84]	@ 0x54
                                       DYNAMIC_TYPE_SUITES);
        if (ctx->suites == NULL) {
 8009130:	687b      	ldr	r3, [r7, #4]
 8009132:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8009134:	2b00      	cmp	r3, #0
 8009136:	d102      	bne.n	800913e <AllocateCtxSuites+0x2c>
            WOLFSSL_MSG("Memory alloc for Suites failed");
            return MEMORY_ERROR;
 8009138:	f46f 7397 	mvn.w	r3, #302	@ 0x12e
 800913c:	e008      	b.n	8009150 <AllocateCtxSuites+0x3e>
        }
        XMEMSET(ctx->suites, 0, sizeof(Suites));
 800913e:	687b      	ldr	r3, [r7, #4]
 8009140:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8009142:	f44f 72ac 	mov.w	r2, #344	@ 0x158
 8009146:	2100      	movs	r1, #0
 8009148:	4618      	mov	r0, r3
 800914a:	f01f fd6b 	bl	8028c24 <memset>
    }
    return 0;
 800914e:	2300      	movs	r3, #0
}
 8009150:	4618      	mov	r0, r3
 8009152:	3708      	adds	r7, #8
 8009154:	46bd      	mov	sp, r7
 8009156:	bd80      	pop	{r7, pc}

08009158 <AllocateSuites>:

/* Call this when the ssl object needs to have its own ssl->suites object */
int AllocateSuites(WOLFSSL* ssl)
{
 8009158:	b580      	push	{r7, lr}
 800915a:	b082      	sub	sp, #8
 800915c:	af00      	add	r7, sp, #0
 800915e:	6078      	str	r0, [r7, #4]
    if (ssl->suites == NULL) {
 8009160:	687b      	ldr	r3, [r7, #4]
 8009162:	685b      	ldr	r3, [r3, #4]
 8009164:	2b00      	cmp	r3, #0
 8009166:	d129      	bne.n	80091bc <AllocateSuites+0x64>
        ssl->suites = (Suites*)XMALLOC(sizeof(Suites), ssl->heap,
 8009168:	f44f 70ac 	mov.w	r0, #344	@ 0x158
 800916c:	f015 fd86 	bl	801ec7c <wolfSSL_Malloc>
 8009170:	4602      	mov	r2, r0
 8009172:	687b      	ldr	r3, [r7, #4]
 8009174:	605a      	str	r2, [r3, #4]
                                       DYNAMIC_TYPE_SUITES);
        if (ssl->suites == NULL) {
 8009176:	687b      	ldr	r3, [r7, #4]
 8009178:	685b      	ldr	r3, [r3, #4]
 800917a:	2b00      	cmp	r3, #0
 800917c:	d102      	bne.n	8009184 <AllocateSuites+0x2c>
            WOLFSSL_MSG("Suites Memory error");
            return MEMORY_ERROR;
 800917e:	f46f 7397 	mvn.w	r3, #302	@ 0x12e
 8009182:	e01c      	b.n	80091be <AllocateSuites+0x66>
        }
        if (ssl->ctx != NULL && ssl->ctx->suites != NULL)
 8009184:	687b      	ldr	r3, [r7, #4]
 8009186:	681b      	ldr	r3, [r3, #0]
 8009188:	2b00      	cmp	r3, #0
 800918a:	d00f      	beq.n	80091ac <AllocateSuites+0x54>
 800918c:	687b      	ldr	r3, [r7, #4]
 800918e:	681b      	ldr	r3, [r3, #0]
 8009190:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8009192:	2b00      	cmp	r3, #0
 8009194:	d00a      	beq.n	80091ac <AllocateSuites+0x54>
            XMEMCPY(ssl->suites, ssl->ctx->suites, sizeof(Suites));
 8009196:	687b      	ldr	r3, [r7, #4]
 8009198:	6858      	ldr	r0, [r3, #4]
 800919a:	687b      	ldr	r3, [r7, #4]
 800919c:	681b      	ldr	r3, [r3, #0]
 800919e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80091a0:	f44f 72ac 	mov.w	r2, #344	@ 0x158
 80091a4:	4619      	mov	r1, r3
 80091a6:	f01f fdee 	bl	8028d86 <memcpy>
 80091aa:	e007      	b.n	80091bc <AllocateSuites+0x64>
        else
            XMEMSET(ssl->suites, 0, sizeof(Suites));
 80091ac:	687b      	ldr	r3, [r7, #4]
 80091ae:	685b      	ldr	r3, [r3, #4]
 80091b0:	f44f 72ac 	mov.w	r2, #344	@ 0x158
 80091b4:	2100      	movs	r1, #0
 80091b6:	4618      	mov	r0, r3
 80091b8:	f01f fd34 	bl	8028c24 <memset>
    }
    return 0;
 80091bc:	2300      	movs	r3, #0
}
 80091be:	4618      	mov	r0, r3
 80091c0:	3708      	adds	r7, #8
 80091c2:	46bd      	mov	sp, r7
 80091c4:	bd80      	pop	{r7, pc}

080091c6 <InitSuites>:
void InitSuites(Suites* suites, ProtocolVersion pv, int keySz, word16 haveRSA,
                word16 havePSK, word16 haveDH, word16 haveECDSAsig,
                word16 haveECC, word16 haveStaticRSA, word16 haveStaticECC,
                word16 haveAnon, word16 haveNull, word16 haveAES128,
                word16 haveSHA1, word16 haveRC4, int side)
{
 80091c6:	b580      	push	{r7, lr}
 80091c8:	b08c      	sub	sp, #48	@ 0x30
 80091ca:	af02      	add	r7, sp, #8
 80091cc:	60f8      	str	r0, [r7, #12]
 80091ce:	8139      	strh	r1, [r7, #8]
 80091d0:	607a      	str	r2, [r7, #4]
 80091d2:	807b      	strh	r3, [r7, #2]
    word16 idx = 0;
 80091d4:	2300      	movs	r3, #0
 80091d6:	84fb      	strh	r3, [r7, #38]	@ 0x26
    int    tls    = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_MINOR;
 80091d8:	7a3b      	ldrb	r3, [r7, #8]
 80091da:	2b03      	cmp	r3, #3
 80091dc:	d104      	bne.n	80091e8 <InitSuites+0x22>
 80091de:	7a7b      	ldrb	r3, [r7, #9]
 80091e0:	2b00      	cmp	r3, #0
 80091e2:	d001      	beq.n	80091e8 <InitSuites+0x22>
 80091e4:	2301      	movs	r3, #1
 80091e6:	e000      	b.n	80091ea <InitSuites+0x24>
 80091e8:	2300      	movs	r3, #0
 80091ea:	623b      	str	r3, [r7, #32]
    int    tls1_2 = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_2_MINOR;
 80091ec:	7a3b      	ldrb	r3, [r7, #8]
 80091ee:	2b03      	cmp	r3, #3
 80091f0:	d104      	bne.n	80091fc <InitSuites+0x36>
 80091f2:	7a7b      	ldrb	r3, [r7, #9]
 80091f4:	2b02      	cmp	r3, #2
 80091f6:	d901      	bls.n	80091fc <InitSuites+0x36>
 80091f8:	2301      	movs	r3, #1
 80091fa:	e000      	b.n	80091fe <InitSuites+0x38>
 80091fc:	2300      	movs	r3, #0
 80091fe:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_TLS13
    int    tls1_3 = IsAtLeastTLSv1_3(pv);
 8009200:	68b8      	ldr	r0, [r7, #8]
 8009202:	f7ff fc3b 	bl	8008a7c <IsAtLeastTLSv1_3>
 8009206:	61b8      	str	r0, [r7, #24]
#endif
    int    dtls   = 0;
 8009208:	2300      	movs	r3, #0
 800920a:	617b      	str	r3, [r7, #20]
    int    haveRSAsig = 1;
 800920c:	2301      	movs	r3, #1
 800920e:	613b      	str	r3, [r7, #16]
    (void)haveNull;
    (void)haveAES128;
    (void)haveSHA1;
    (void)haveRC4;

    if (suites == NULL) {
 8009210:	68fb      	ldr	r3, [r7, #12]
 8009212:	2b00      	cmp	r3, #0
 8009214:	f000 81bc 	beq.w	8009590 <InitSuites+0x3ca>
        WOLFSSL_MSG("InitSuites pointer error");
        return;
    }

    if (suites->setSuites)
 8009218:	68fb      	ldr	r3, [r7, #12]
 800921a:	f893 3156 	ldrb.w	r3, [r3, #342]	@ 0x156
 800921e:	f003 0301 	and.w	r3, r3, #1
 8009222:	b2db      	uxtb	r3, r3
 8009224:	2b00      	cmp	r3, #0
 8009226:	f040 81b5 	bne.w	8009594 <InitSuites+0x3ce>
        suites->suites[idx++] = TLS_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_AES_128_GCM_SHA256
    if (tls1_3 && haveAES128) {
 800922a:	69bb      	ldr	r3, [r7, #24]
 800922c:	2b00      	cmp	r3, #0
 800922e:	d013      	beq.n	8009258 <InitSuites+0x92>
 8009230:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 8009234:	2b00      	cmp	r3, #0
 8009236:	d00f      	beq.n	8009258 <InitSuites+0x92>
        suites->suites[idx++] = TLS13_BYTE;
 8009238:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800923a:	1c5a      	adds	r2, r3, #1
 800923c:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800923e:	461a      	mov	r2, r3
 8009240:	68fb      	ldr	r3, [r7, #12]
 8009242:	4413      	add	r3, r2
 8009244:	2213      	movs	r2, #19
 8009246:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_AES_128_GCM_SHA256;
 8009248:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800924a:	1c5a      	adds	r2, r3, #1
 800924c:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800924e:	461a      	mov	r2, r3
 8009250:	68fb      	ldr	r3, [r7, #12]
 8009252:	4413      	add	r3, r2
 8009254:	2201      	movs	r2, #1
 8009256:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_CHACHA20_POLY1305_SHA256
    if (tls1_3) {
 8009258:	69bb      	ldr	r3, [r7, #24]
 800925a:	2b00      	cmp	r3, #0
 800925c:	d00f      	beq.n	800927e <InitSuites+0xb8>
        suites->suites[idx++] = TLS13_BYTE;
 800925e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009260:	1c5a      	adds	r2, r3, #1
 8009262:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009264:	461a      	mov	r2, r3
 8009266:	68fb      	ldr	r3, [r7, #12]
 8009268:	4413      	add	r3, r2
 800926a:	2213      	movs	r2, #19
 800926c:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_CHACHA20_POLY1305_SHA256;
 800926e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009270:	1c5a      	adds	r2, r3, #1
 8009272:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009274:	461a      	mov	r2, r3
 8009276:	68fb      	ldr	r3, [r7, #12]
 8009278:	4413      	add	r3, r2
 800927a:	2203      	movs	r2, #3
 800927c:	711a      	strb	r2, [r3, #4]
#endif /* WOLFSSL_TLS13 */

#ifndef WOLFSSL_NO_TLS12

#if !defined(NO_WOLFSSL_SERVER) && !defined(NO_RSA)
    if (side == WOLFSSL_SERVER_END && haveStaticECC) {
 800927e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8009280:	2b00      	cmp	r3, #0
 8009282:	d105      	bne.n	8009290 <InitSuites+0xca>
 8009284:	f8b7 3044 	ldrh.w	r3, [r7, #68]	@ 0x44
 8009288:	2b00      	cmp	r3, #0
 800928a:	d001      	beq.n	8009290 <InitSuites+0xca>
        haveRSA = 0;   /* can't do RSA with ECDSA key */
 800928c:	2300      	movs	r3, #0
 800928e:	807b      	strh	r3, [r7, #2]
    }

    if (side == WOLFSSL_SERVER_END && haveECDSAsig) {
 8009290:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8009292:	2b00      	cmp	r3, #0
 8009294:	d104      	bne.n	80092a0 <InitSuites+0xda>
 8009296:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 8009298:	2b00      	cmp	r3, #0
 800929a:	d001      	beq.n	80092a0 <InitSuites+0xda>
        haveRSAsig = 0;     /* can't have RSA sig if signed by ECDSA */
 800929c:	2300      	movs	r3, #0
 800929e:	613b      	str	r3, [r7, #16]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
    if (tls1_2 && haveECC && haveAES128) {
 80092a0:	69fb      	ldr	r3, [r7, #28]
 80092a2:	2b00      	cmp	r3, #0
 80092a4:	d016      	beq.n	80092d4 <InitSuites+0x10e>
 80092a6:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 80092a8:	2b00      	cmp	r3, #0
 80092aa:	d013      	beq.n	80092d4 <InitSuites+0x10e>
 80092ac:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80092b0:	2b00      	cmp	r3, #0
 80092b2:	d00f      	beq.n	80092d4 <InitSuites+0x10e>
        suites->suites[idx++] = ECC_BYTE;
 80092b4:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092b6:	1c5a      	adds	r2, r3, #1
 80092b8:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80092ba:	461a      	mov	r2, r3
 80092bc:	68fb      	ldr	r3, [r7, #12]
 80092be:	4413      	add	r3, r2
 80092c0:	22c0      	movs	r2, #192	@ 0xc0
 80092c2:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
 80092c4:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092c6:	1c5a      	adds	r2, r3, #1
 80092c8:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80092ca:	461a      	mov	r2, r3
 80092cc:	68fb      	ldr	r3, [r7, #12]
 80092ce:	4413      	add	r3, r2
 80092d0:	222b      	movs	r2, #43	@ 0x2b
 80092d2:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA && haveAES128) ||
 80092d4:	69fb      	ldr	r3, [r7, #28]
 80092d6:	2b00      	cmp	r3, #0
 80092d8:	d006      	beq.n	80092e8 <InitSuites+0x122>
 80092da:	887b      	ldrh	r3, [r7, #2]
 80092dc:	2b00      	cmp	r3, #0
 80092de:	d003      	beq.n	80092e8 <InitSuites+0x122>
 80092e0:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80092e4:	2b00      	cmp	r3, #0
 80092e6:	d109      	bne.n	80092fc <InitSuites+0x136>
 80092e8:	69fb      	ldr	r3, [r7, #28]
 80092ea:	2b00      	cmp	r3, #0
 80092ec:	d016      	beq.n	800931c <InitSuites+0x156>
        (tls1_2 && haveECDSAsig && haveAES128)) {
 80092ee:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 80092f0:	2b00      	cmp	r3, #0
 80092f2:	d013      	beq.n	800931c <InitSuites+0x156>
 80092f4:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80092f8:	2b00      	cmp	r3, #0
 80092fa:	d00f      	beq.n	800931c <InitSuites+0x156>
    #else
    if (tls1_2 && haveRSA && haveAES128) {
    #endif
        suites->suites[idx++] = ECC_BYTE;
 80092fc:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092fe:	1c5a      	adds	r2, r3, #1
 8009300:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009302:	461a      	mov	r2, r3
 8009304:	68fb      	ldr	r3, [r7, #12]
 8009306:	4413      	add	r3, r2
 8009308:	22c0      	movs	r2, #192	@ 0xc0
 800930a:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
 800930c:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800930e:	1c5a      	adds	r2, r3, #1
 8009310:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009312:	461a      	mov	r2, r3
 8009314:	68fb      	ldr	r3, [r7, #12]
 8009316:	4413      	add	r3, r2
 8009318:	222f      	movs	r2, #47	@ 0x2f
 800931a:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
    if (tls1_2 && haveDH && haveRSA && haveAES128) {
 800931c:	69fb      	ldr	r3, [r7, #28]
 800931e:	2b00      	cmp	r3, #0
 8009320:	d019      	beq.n	8009356 <InitSuites+0x190>
 8009322:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 8009324:	2b00      	cmp	r3, #0
 8009326:	d016      	beq.n	8009356 <InitSuites+0x190>
 8009328:	887b      	ldrh	r3, [r7, #2]
 800932a:	2b00      	cmp	r3, #0
 800932c:	d013      	beq.n	8009356 <InitSuites+0x190>
 800932e:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 8009332:	2b00      	cmp	r3, #0
 8009334:	d00f      	beq.n	8009356 <InitSuites+0x190>
        suites->suites[idx++] = CIPHER_BYTE;
 8009336:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009338:	1c5a      	adds	r2, r3, #1
 800933a:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800933c:	461a      	mov	r2, r3
 800933e:	68fb      	ldr	r3, [r7, #12]
 8009340:	4413      	add	r3, r2
 8009342:	2200      	movs	r2, #0
 8009344:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_128_GCM_SHA256;
 8009346:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009348:	1c5a      	adds	r2, r3, #1
 800934a:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800934c:	461a      	mov	r2, r3
 800934e:	68fb      	ldr	r3, [r7, #12]
 8009350:	4413      	add	r3, r2
 8009352:	229e      	movs	r2, #158	@ 0x9e
 8009354:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_PSK_WITH_AES_128_GCM_SHA256;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
    if (tls1_2 && haveECC) {
 8009356:	69fb      	ldr	r3, [r7, #28]
 8009358:	2b00      	cmp	r3, #0
 800935a:	d012      	beq.n	8009382 <InitSuites+0x1bc>
 800935c:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 800935e:	2b00      	cmp	r3, #0
 8009360:	d00f      	beq.n	8009382 <InitSuites+0x1bc>
        suites->suites[idx++] = CHACHA_BYTE;
 8009362:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009364:	1c5a      	adds	r2, r3, #1
 8009366:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009368:	461a      	mov	r2, r3
 800936a:	68fb      	ldr	r3, [r7, #12]
 800936c:	4413      	add	r3, r2
 800936e:	22cc      	movs	r2, #204	@ 0xcc
 8009370:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256;
 8009372:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009374:	1c5a      	adds	r2, r3, #1
 8009376:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009378:	461a      	mov	r2, r3
 800937a:	68fb      	ldr	r3, [r7, #12]
 800937c:	4413      	add	r3, r2
 800937e:	22a9      	movs	r2, #169	@ 0xa9
 8009380:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA) || (tls1_2 && haveECDSAsig)) {
 8009382:	69fb      	ldr	r3, [r7, #28]
 8009384:	2b00      	cmp	r3, #0
 8009386:	d002      	beq.n	800938e <InitSuites+0x1c8>
 8009388:	887b      	ldrh	r3, [r7, #2]
 800938a:	2b00      	cmp	r3, #0
 800938c:	d105      	bne.n	800939a <InitSuites+0x1d4>
 800938e:	69fb      	ldr	r3, [r7, #28]
 8009390:	2b00      	cmp	r3, #0
 8009392:	d012      	beq.n	80093ba <InitSuites+0x1f4>
 8009394:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 8009396:	2b00      	cmp	r3, #0
 8009398:	d00f      	beq.n	80093ba <InitSuites+0x1f4>
    #else
    if (tls1_2 && haveRSA) {
    #endif
        suites->suites[idx++] = CHACHA_BYTE;
 800939a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800939c:	1c5a      	adds	r2, r3, #1
 800939e:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093a0:	461a      	mov	r2, r3
 80093a2:	68fb      	ldr	r3, [r7, #12]
 80093a4:	4413      	add	r3, r2
 80093a6:	22cc      	movs	r2, #204	@ 0xcc
 80093a8:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
 80093aa:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093ac:	1c5a      	adds	r2, r3, #1
 80093ae:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093b0:	461a      	mov	r2, r3
 80093b2:	68fb      	ldr	r3, [r7, #12]
 80093b4:	4413      	add	r3, r2
 80093b6:	22a8      	movs	r2, #168	@ 0xa8
 80093b8:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    if (tls1_2 && haveRSA) {
 80093ba:	69fb      	ldr	r3, [r7, #28]
 80093bc:	2b00      	cmp	r3, #0
 80093be:	d012      	beq.n	80093e6 <InitSuites+0x220>
 80093c0:	887b      	ldrh	r3, [r7, #2]
 80093c2:	2b00      	cmp	r3, #0
 80093c4:	d00f      	beq.n	80093e6 <InitSuites+0x220>
        suites->suites[idx++] = CHACHA_BYTE;
 80093c6:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093c8:	1c5a      	adds	r2, r3, #1
 80093ca:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093cc:	461a      	mov	r2, r3
 80093ce:	68fb      	ldr	r3, [r7, #12]
 80093d0:	4413      	add	r3, r2
 80093d2:	22cc      	movs	r2, #204	@ 0xcc
 80093d4:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
 80093d6:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093d8:	1c5a      	adds	r2, r3, #1
 80093da:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093dc:	461a      	mov	r2, r3
 80093de:	68fb      	ldr	r3, [r7, #12]
 80093e0:	4413      	add	r3, r2
 80093e2:	22aa      	movs	r2, #170	@ 0xaa
 80093e4:	711a      	strb	r2, [r3, #4]
#endif
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA && haveAES128) ||
 80093e6:	69fb      	ldr	r3, [r7, #28]
 80093e8:	2b00      	cmp	r3, #0
 80093ea:	d006      	beq.n	80093fa <InitSuites+0x234>
 80093ec:	887b      	ldrh	r3, [r7, #2]
 80093ee:	2b00      	cmp	r3, #0
 80093f0:	d003      	beq.n	80093fa <InitSuites+0x234>
 80093f2:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80093f6:	2b00      	cmp	r3, #0
 80093f8:	d109      	bne.n	800940e <InitSuites+0x248>
 80093fa:	69fb      	ldr	r3, [r7, #28]
 80093fc:	2b00      	cmp	r3, #0
 80093fe:	d016      	beq.n	800942e <InitSuites+0x268>
        (tls1_2 && haveECDSAsig && haveAES128)) {
 8009400:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 8009402:	2b00      	cmp	r3, #0
 8009404:	d013      	beq.n	800942e <InitSuites+0x268>
 8009406:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 800940a:	2b00      	cmp	r3, #0
 800940c:	d00f      	beq.n	800942e <InitSuites+0x268>
    #else
    if (tls1_2 && haveRSA && haveAES128) {
    #endif
        suites->suites[idx++] = ECC_BYTE;
 800940e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009410:	1c5a      	adds	r2, r3, #1
 8009412:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009414:	461a      	mov	r2, r3
 8009416:	68fb      	ldr	r3, [r7, #12]
 8009418:	4413      	add	r3, r2
 800941a:	22c0      	movs	r2, #192	@ 0xc0
 800941c:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
 800941e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009420:	1c5a      	adds	r2, r3, #1
 8009422:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009424:	461a      	mov	r2, r3
 8009426:	68fb      	ldr	r3, [r7, #12]
 8009428:	4413      	add	r3, r2
 800942a:	2227      	movs	r2, #39	@ 0x27
 800942c:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
    if (tls1_2 && haveECC && haveAES128) {
 800942e:	69fb      	ldr	r3, [r7, #28]
 8009430:	2b00      	cmp	r3, #0
 8009432:	d016      	beq.n	8009462 <InitSuites+0x29c>
 8009434:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 8009436:	2b00      	cmp	r3, #0
 8009438:	d013      	beq.n	8009462 <InitSuites+0x29c>
 800943a:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 800943e:	2b00      	cmp	r3, #0
 8009440:	d00f      	beq.n	8009462 <InitSuites+0x29c>
        suites->suites[idx++] = ECC_BYTE;
 8009442:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009444:	1c5a      	adds	r2, r3, #1
 8009446:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009448:	461a      	mov	r2, r3
 800944a:	68fb      	ldr	r3, [r7, #12]
 800944c:	4413      	add	r3, r2
 800944e:	22c0      	movs	r2, #192	@ 0xc0
 8009450:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
 8009452:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009454:	1c5a      	adds	r2, r3, #1
 8009456:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009458:	461a      	mov	r2, r3
 800945a:	68fb      	ldr	r3, [r7, #12]
 800945c:	4413      	add	r3, r2
 800945e:	2223      	movs	r2, #35	@ 0x23
 8009460:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
#ifndef WOLFSSL_OLDTLS_SHA2_CIPHERSUITES
    if (tls1_2 && haveDH && haveRSA)
 8009462:	69fb      	ldr	r3, [r7, #28]
 8009464:	2b00      	cmp	r3, #0
 8009466:	d015      	beq.n	8009494 <InitSuites+0x2ce>
 8009468:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 800946a:	2b00      	cmp	r3, #0
 800946c:	d012      	beq.n	8009494 <InitSuites+0x2ce>
 800946e:	887b      	ldrh	r3, [r7, #2]
 8009470:	2b00      	cmp	r3, #0
 8009472:	d00f      	beq.n	8009494 <InitSuites+0x2ce>
#else
    if (tls && haveDH && haveRSA)
#endif
    {
        suites->suites[idx++] = CIPHER_BYTE;
 8009474:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009476:	1c5a      	adds	r2, r3, #1
 8009478:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800947a:	461a      	mov	r2, r3
 800947c:	68fb      	ldr	r3, [r7, #12]
 800947e:	4413      	add	r3, r2
 8009480:	2200      	movs	r2, #0
 8009482:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_256_CBC_SHA256;
 8009484:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009486:	1c5a      	adds	r2, r3, #1
 8009488:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800948a:	461a      	mov	r2, r3
 800948c:	68fb      	ldr	r3, [r7, #12]
 800948e:	4413      	add	r3, r2
 8009490:	226b      	movs	r2, #107	@ 0x6b
 8009492:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
#ifndef WOLFSSL_OLDTLS_SHA2_CIPHERSUITES
    if (tls1_2 && haveDH && haveRSA && haveAES128)
 8009494:	69fb      	ldr	r3, [r7, #28]
 8009496:	2b00      	cmp	r3, #0
 8009498:	d019      	beq.n	80094ce <InitSuites+0x308>
 800949a:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 800949c:	2b00      	cmp	r3, #0
 800949e:	d016      	beq.n	80094ce <InitSuites+0x308>
 80094a0:	887b      	ldrh	r3, [r7, #2]
 80094a2:	2b00      	cmp	r3, #0
 80094a4:	d013      	beq.n	80094ce <InitSuites+0x308>
 80094a6:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80094aa:	2b00      	cmp	r3, #0
 80094ac:	d00f      	beq.n	80094ce <InitSuites+0x308>
#else
    if (tls && haveDH && haveRSA && haveAES128)
#endif
    {
        suites->suites[idx++] = CIPHER_BYTE;
 80094ae:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80094b0:	1c5a      	adds	r2, r3, #1
 80094b2:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80094b4:	461a      	mov	r2, r3
 80094b6:	68fb      	ldr	r3, [r7, #12]
 80094b8:	4413      	add	r3, r2
 80094ba:	2200      	movs	r2, #0
 80094bc:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_128_CBC_SHA256;
 80094be:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80094c0:	1c5a      	adds	r2, r3, #1
 80094c2:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80094c4:	461a      	mov	r2, r3
 80094c6:	68fb      	ldr	r3, [r7, #12]
 80094c8:	4413      	add	r3, r2
 80094ca:	2267      	movs	r2, #103	@ 0x67
 80094cc:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_RSA_WITH_AES_128_CBC_SHA;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    if (tls1_2 && haveECC) {
 80094ce:	69fb      	ldr	r3, [r7, #28]
 80094d0:	2b00      	cmp	r3, #0
 80094d2:	d012      	beq.n	80094fa <InitSuites+0x334>
 80094d4:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 80094d6:	2b00      	cmp	r3, #0
 80094d8:	d00f      	beq.n	80094fa <InitSuites+0x334>
        suites->suites[idx++] = CHACHA_BYTE;
 80094da:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80094dc:	1c5a      	adds	r2, r3, #1
 80094de:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80094e0:	461a      	mov	r2, r3
 80094e2:	68fb      	ldr	r3, [r7, #12]
 80094e4:	4413      	add	r3, r2
 80094e6:	22cc      	movs	r2, #204	@ 0xcc
 80094e8:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] =
 80094ea:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80094ec:	1c5a      	adds	r2, r3, #1
 80094ee:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80094f0:	461a      	mov	r2, r3
 80094f2:	68fb      	ldr	r3, [r7, #12]
 80094f4:	4413      	add	r3, r2
 80094f6:	2214      	movs	r2, #20
 80094f8:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA) || (tls1_2 && haveECDSAsig)) {
 80094fa:	69fb      	ldr	r3, [r7, #28]
 80094fc:	2b00      	cmp	r3, #0
 80094fe:	d002      	beq.n	8009506 <InitSuites+0x340>
 8009500:	887b      	ldrh	r3, [r7, #2]
 8009502:	2b00      	cmp	r3, #0
 8009504:	d105      	bne.n	8009512 <InitSuites+0x34c>
 8009506:	69fb      	ldr	r3, [r7, #28]
 8009508:	2b00      	cmp	r3, #0
 800950a:	d012      	beq.n	8009532 <InitSuites+0x36c>
 800950c:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 800950e:	2b00      	cmp	r3, #0
 8009510:	d00f      	beq.n	8009532 <InitSuites+0x36c>
    #else
    if (tls1_2 && haveRSA) {
    #endif
        suites->suites[idx++] = CHACHA_BYTE;
 8009512:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009514:	1c5a      	adds	r2, r3, #1
 8009516:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009518:	461a      	mov	r2, r3
 800951a:	68fb      	ldr	r3, [r7, #12]
 800951c:	4413      	add	r3, r2
 800951e:	22cc      	movs	r2, #204	@ 0xcc
 8009520:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256;
 8009522:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009524:	1c5a      	adds	r2, r3, #1
 8009526:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009528:	461a      	mov	r2, r3
 800952a:	68fb      	ldr	r3, [r7, #12]
 800952c:	4413      	add	r3, r2
 800952e:	2213      	movs	r2, #19
 8009530:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA) || (tls1_2 && haveECDSAsig)) {
 8009532:	69fb      	ldr	r3, [r7, #28]
 8009534:	2b00      	cmp	r3, #0
 8009536:	d002      	beq.n	800953e <InitSuites+0x378>
 8009538:	887b      	ldrh	r3, [r7, #2]
 800953a:	2b00      	cmp	r3, #0
 800953c:	d105      	bne.n	800954a <InitSuites+0x384>
 800953e:	69fb      	ldr	r3, [r7, #28]
 8009540:	2b00      	cmp	r3, #0
 8009542:	d012      	beq.n	800956a <InitSuites+0x3a4>
 8009544:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 8009546:	2b00      	cmp	r3, #0
 8009548:	d00f      	beq.n	800956a <InitSuites+0x3a4>
    #else
    if (tls1_2 && haveRSA) {
    #endif
        suites->suites[idx++] = CHACHA_BYTE;
 800954a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800954c:	1c5a      	adds	r2, r3, #1
 800954e:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009550:	461a      	mov	r2, r3
 8009552:	68fb      	ldr	r3, [r7, #12]
 8009554:	4413      	add	r3, r2
 8009556:	22cc      	movs	r2, #204	@ 0xcc
 8009558:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256;
 800955a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800955c:	1c5a      	adds	r2, r3, #1
 800955e:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009560:	461a      	mov	r2, r3
 8009562:	68fb      	ldr	r3, [r7, #12]
 8009564:	4413      	add	r3, r2
 8009566:	2215      	movs	r2, #21
 8009568:	711a      	strb	r2, [r3, #4]
    }
#endif

#endif /* !WOLFSSL_NO_TLS12 */

    suites->suiteSz = idx;
 800956a:	68fb      	ldr	r3, [r7, #12]
 800956c:	8cfa      	ldrh	r2, [r7, #38]	@ 0x26
 800956e:	801a      	strh	r2, [r3, #0]

    if (suites->hashSigAlgoSz == 0) {
 8009570:	68fb      	ldr	r3, [r7, #12]
 8009572:	885b      	ldrh	r3, [r3, #2]
 8009574:	2b00      	cmp	r3, #0
 8009576:	d10e      	bne.n	8009596 <InitSuites+0x3d0>
        InitSuitesHashSigAlgo(suites->hashSigAlgo, SIG_ALL, tls1_2, keySz,
 8009578:	68fb      	ldr	r3, [r7, #12]
 800957a:	f503 7098 	add.w	r0, r3, #304	@ 0x130
 800957e:	68fb      	ldr	r3, [r7, #12]
 8009580:	3302      	adds	r3, #2
 8009582:	9300      	str	r3, [sp, #0]
 8009584:	687b      	ldr	r3, [r7, #4]
 8009586:	69fa      	ldr	r2, [r7, #28]
 8009588:	211f      	movs	r1, #31
 800958a:	f7ff fd8a 	bl	80090a2 <InitSuitesHashSigAlgo>
 800958e:	e002      	b.n	8009596 <InitSuites+0x3d0>
        return;
 8009590:	bf00      	nop
 8009592:	e000      	b.n	8009596 <InitSuites+0x3d0>
        return;      /* trust user settings, don't override */
 8009594:	bf00      	nop
    (void)side;
    (void)haveRSA;    /* some builds won't read */
    (void)haveRSAsig; /* non ecc builds won't read */
    (void)haveAnon;   /* anon ciphers optional */
    (void)haveNull;
}
 8009596:	3728      	adds	r7, #40	@ 0x28
 8009598:	46bd      	mov	sp, r7
 800959a:	bd80      	pop	{r7, pc}

0800959c <InitX509Name>:
#endif /* !WOLFSSL_NO_TLS12 */

#ifndef NO_CERTS

void InitX509Name(WOLFSSL_X509_NAME* name, int dynamicFlag, void* heap)
{
 800959c:	b580      	push	{r7, lr}
 800959e:	b084      	sub	sp, #16
 80095a0:	af00      	add	r7, sp, #0
 80095a2:	60f8      	str	r0, [r7, #12]
 80095a4:	60b9      	str	r1, [r7, #8]
 80095a6:	607a      	str	r2, [r7, #4]
    (void)dynamicFlag;

    if (name != NULL) {
 80095a8:	68fb      	ldr	r3, [r7, #12]
 80095aa:	2b00      	cmp	r3, #0
 80095ac:	d011      	beq.n	80095d2 <InitX509Name+0x36>
        XMEMSET(name, 0, sizeof(WOLFSSL_X509_NAME));
 80095ae:	f240 520c 	movw	r2, #1292	@ 0x50c
 80095b2:	2100      	movs	r1, #0
 80095b4:	68f8      	ldr	r0, [r7, #12]
 80095b6:	f01f fb35 	bl	8028c24 <memset>
        name->name        = name->staticName;
 80095ba:	68fb      	ldr	r3, [r7, #12]
 80095bc:	f103 020c 	add.w	r2, r3, #12
 80095c0:	68fb      	ldr	r3, [r7, #12]
 80095c2:	601a      	str	r2, [r3, #0]
        name->heap = heap;
 80095c4:	68fb      	ldr	r3, [r7, #12]
 80095c6:	687a      	ldr	r2, [r7, #4]
 80095c8:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
        name->dynamicName = 0;
 80095cc:	68fb      	ldr	r3, [r7, #12]
 80095ce:	2200      	movs	r2, #0
 80095d0:	605a      	str	r2, [r3, #4]
    }
}
 80095d2:	bf00      	nop
 80095d4:	3710      	adds	r7, #16
 80095d6:	46bd      	mov	sp, r7
 80095d8:	bd80      	pop	{r7, pc}

080095da <FreeX509Name>:


void FreeX509Name(WOLFSSL_X509_NAME* name)
{
 80095da:	b580      	push	{r7, lr}
 80095dc:	b084      	sub	sp, #16
 80095de:	af00      	add	r7, sp, #0
 80095e0:	6078      	str	r0, [r7, #4]
    if (name != NULL) {
 80095e2:	687b      	ldr	r3, [r7, #4]
 80095e4:	2b00      	cmp	r3, #0
 80095e6:	d059      	beq.n	800969c <FreeX509Name+0xc2>
        if (name->dynamicName) {
 80095e8:	687b      	ldr	r3, [r7, #4]
 80095ea:	685b      	ldr	r3, [r3, #4]
 80095ec:	2b00      	cmp	r3, #0
 80095ee:	d00b      	beq.n	8009608 <FreeX509Name+0x2e>
            XFREE(name->name, name->heap, DYNAMIC_TYPE_SUBJECT_CN);
 80095f0:	687b      	ldr	r3, [r7, #4]
 80095f2:	681b      	ldr	r3, [r3, #0]
 80095f4:	60bb      	str	r3, [r7, #8]
 80095f6:	68bb      	ldr	r3, [r7, #8]
 80095f8:	2b00      	cmp	r3, #0
 80095fa:	d002      	beq.n	8009602 <FreeX509Name+0x28>
 80095fc:	68b8      	ldr	r0, [r7, #8]
 80095fe:	f015 fb59 	bl	801ecb4 <wolfSSL_Free>
            name->name = NULL;
 8009602:	687b      	ldr	r3, [r7, #4]
 8009604:	2200      	movs	r2, #0
 8009606:	601a      	str	r2, [r3, #0]
        }
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        {
            int i;
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 8009608:	2300      	movs	r3, #0
 800960a:	60fb      	str	r3, [r7, #12]
 800960c:	e043      	b.n	8009696 <FreeX509Name+0xbc>
                if (name->entry[i].object != NULL)
 800960e:	6879      	ldr	r1, [r7, #4]
 8009610:	68fa      	ldr	r2, [r7, #12]
 8009612:	4613      	mov	r3, r2
 8009614:	009b      	lsls	r3, r3, #2
 8009616:	4413      	add	r3, r2
 8009618:	009b      	lsls	r3, r3, #2
 800961a:	440b      	add	r3, r1
 800961c:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 8009620:	681b      	ldr	r3, [r3, #0]
 8009622:	2b00      	cmp	r3, #0
 8009624:	d00c      	beq.n	8009640 <FreeX509Name+0x66>
                    wolfSSL_ASN1_OBJECT_free(name->entry[i].object);
 8009626:	6879      	ldr	r1, [r7, #4]
 8009628:	68fa      	ldr	r2, [r7, #12]
 800962a:	4613      	mov	r3, r2
 800962c:	009b      	lsls	r3, r3, #2
 800962e:	4413      	add	r3, r2
 8009630:	009b      	lsls	r3, r3, #2
 8009632:	440b      	add	r3, r1
 8009634:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 8009638:	681b      	ldr	r3, [r3, #0]
 800963a:	4618      	mov	r0, r3
 800963c:	f002 fa87 	bl	800bb4e <wolfSSL_ASN1_OBJECT_free>
                if (name->entry[i].value != NULL)
 8009640:	6879      	ldr	r1, [r7, #4]
 8009642:	68fa      	ldr	r2, [r7, #12]
 8009644:	4613      	mov	r3, r2
 8009646:	009b      	lsls	r3, r3, #2
 8009648:	4413      	add	r3, r2
 800964a:	009b      	lsls	r3, r3, #2
 800964c:	440b      	add	r3, r1
 800964e:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 8009652:	681b      	ldr	r3, [r3, #0]
 8009654:	2b00      	cmp	r3, #0
 8009656:	d00c      	beq.n	8009672 <FreeX509Name+0x98>
                    wolfSSL_ASN1_STRING_free(name->entry[i].value);
 8009658:	6879      	ldr	r1, [r7, #4]
 800965a:	68fa      	ldr	r2, [r7, #12]
 800965c:	4613      	mov	r3, r2
 800965e:	009b      	lsls	r3, r3, #2
 8009660:	4413      	add	r3, r2
 8009662:	009b      	lsls	r3, r3, #2
 8009664:	440b      	add	r3, r1
 8009666:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 800966a:	681b      	ldr	r3, [r3, #0]
 800966c:	4618      	mov	r0, r3
 800966e:	f002 facd 	bl	800bc0c <wolfSSL_ASN1_STRING_free>
                XMEMSET(&name->entry[i], 0, sizeof(WOLFSSL_X509_NAME_ENTRY));
 8009672:	68fa      	ldr	r2, [r7, #12]
 8009674:	4613      	mov	r3, r2
 8009676:	009b      	lsls	r3, r3, #2
 8009678:	4413      	add	r3, r2
 800967a:	009b      	lsls	r3, r3, #2
 800967c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8009680:	687a      	ldr	r2, [r7, #4]
 8009682:	4413      	add	r3, r2
 8009684:	3304      	adds	r3, #4
 8009686:	2214      	movs	r2, #20
 8009688:	2100      	movs	r1, #0
 800968a:	4618      	mov	r0, r3
 800968c:	f01f faca 	bl	8028c24 <memset>
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 8009690:	68fb      	ldr	r3, [r7, #12]
 8009692:	3301      	adds	r3, #1
 8009694:	60fb      	str	r3, [r7, #12]
 8009696:	68fb      	ldr	r3, [r7, #12]
 8009698:	2b0f      	cmp	r3, #15
 800969a:	ddb8      	ble.n	800960e <FreeX509Name+0x34>
            wolfSSL_sk_X509_NAME_ENTRY_free(name->entries);
            name->entries = NULL;
        }
#endif
    }
}
 800969c:	bf00      	nop
 800969e:	3710      	adds	r7, #16
 80096a0:	46bd      	mov	sp, r7
 80096a2:	bd80      	pop	{r7, pc}

080096a4 <InitX509>:


/* Initialize wolfSSL X509 type */
void InitX509(WOLFSSL_X509* x509, int dynamicFlag, void* heap)
{
 80096a4:	b580      	push	{r7, lr}
 80096a6:	b086      	sub	sp, #24
 80096a8:	af00      	add	r7, sp, #0
 80096aa:	60f8      	str	r0, [r7, #12]
 80096ac:	60b9      	str	r1, [r7, #8]
 80096ae:	607a      	str	r2, [r7, #4]
    if (x509 == NULL) {
 80096b0:	68fb      	ldr	r3, [r7, #12]
 80096b2:	2b00      	cmp	r3, #0
 80096b4:	d025      	beq.n	8009702 <InitX509+0x5e>
        WOLFSSL_MSG("Null parameter passed in!");
        return;
    }

    XMEMSET(x509, 0, sizeof(WOLFSSL_X509));
 80096b6:	f640 42d4 	movw	r2, #3284	@ 0xcd4
 80096ba:	2100      	movs	r1, #0
 80096bc:	68f8      	ldr	r0, [r7, #12]
 80096be:	f01f fab1 	bl	8028c24 <memset>

    x509->heap = heap;
 80096c2:	68fb      	ldr	r3, [r7, #12]
 80096c4:	687a      	ldr	r2, [r7, #4]
 80096c6:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    InitX509Name(&x509->issuer, 0, heap);
 80096ca:	68fb      	ldr	r3, [r7, #12]
 80096cc:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 80096d0:	687a      	ldr	r2, [r7, #4]
 80096d2:	2100      	movs	r1, #0
 80096d4:	4618      	mov	r0, r3
 80096d6:	f7ff ff61 	bl	800959c <InitX509Name>
    InitX509Name(&x509->subject, 0, heap);
 80096da:	68fb      	ldr	r3, [r7, #12]
 80096dc:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 80096e0:	687a      	ldr	r2, [r7, #4]
 80096e2:	2100      	movs	r1, #0
 80096e4:	4618      	mov	r0, r3
 80096e6:	f7ff ff59 	bl	800959c <InitX509Name>
    x509->dynamicMemory  = (byte)dynamicFlag;
 80096ea:	68bb      	ldr	r3, [r7, #8]
 80096ec:	b2da      	uxtb	r2, r3
 80096ee:	68fb      	ldr	r3, [r7, #12]
 80096f0:	f883 2094 	strb.w	r2, [r3, #148]	@ 0x94
#if defined(OPENSSL_EXTRA_X509_SMALL) || defined(OPENSSL_EXTRA)
    {
        int ret;
        wolfSSL_RefInit(&x509->ref, &ret);
 80096f4:	68fb      	ldr	r3, [r7, #12]
 80096f6:	2201      	movs	r2, #1
 80096f8:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
 80096fc:	2300      	movs	r3, #0
 80096fe:	617b      	str	r3, [r7, #20]
 8009700:	e000      	b.n	8009704 <InitX509+0x60>
        return;
 8009702:	bf00      	nop
        (void)ret;
    }
#endif
}
 8009704:	3718      	adds	r7, #24
 8009706:	46bd      	mov	sp, r7
 8009708:	bd80      	pop	{r7, pc}

0800970a <FreeX509>:


/* Free wolfSSL X509 type */
void FreeX509(WOLFSSL_X509* x509)
{
 800970a:	b580      	push	{r7, lr}
 800970c:	b08c      	sub	sp, #48	@ 0x30
 800970e:	af00      	add	r7, sp, #0
 8009710:	6078      	str	r0, [r7, #4]
    #if defined(WOLFSSL_CERT_REQ) && defined(OPENSSL_ALL) \
    &&  defined( WOLFSSL_CUSTOM_OID)
    int idx;
    #endif /* WOLFSSL_CERT_REQ && OPENSSL_ALL && WOLFSSL_CUSTOM_OID */
    if (x509 == NULL)
 8009712:	687b      	ldr	r3, [r7, #4]
 8009714:	2b00      	cmp	r3, #0
 8009716:	f000 80dc 	beq.w	80098d2 <FreeX509+0x1c8>
        return;

    FreeX509Name(&x509->issuer);
 800971a:	687b      	ldr	r3, [r7, #4]
 800971c:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 8009720:	4618      	mov	r0, r3
 8009722:	f7ff ff5a 	bl	80095da <FreeX509Name>
    FreeX509Name(&x509->subject);
 8009726:	687b      	ldr	r3, [r7, #4]
 8009728:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800972c:	4618      	mov	r0, r3
 800972e:	f7ff ff54 	bl	80095da <FreeX509Name>
    if (x509->pubKey.buffer) {
 8009732:	687b      	ldr	r3, [r7, #4]
 8009734:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8009736:	2b00      	cmp	r3, #0
 8009738:	d00b      	beq.n	8009752 <FreeX509+0x48>
        XFREE(x509->pubKey.buffer, x509->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800973a:	687b      	ldr	r3, [r7, #4]
 800973c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800973e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8009740:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8009742:	2b00      	cmp	r3, #0
 8009744:	d002      	beq.n	800974c <FreeX509+0x42>
 8009746:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8009748:	f015 fab4 	bl	801ecb4 <wolfSSL_Free>
        x509->pubKey.buffer = NULL;
 800974c:	687b      	ldr	r3, [r7, #4]
 800974e:	2200      	movs	r2, #0
 8009750:	679a      	str	r2, [r3, #120]	@ 0x78
    }
    FreeDer(&x509->derCert);
 8009752:	687b      	ldr	r3, [r7, #4]
 8009754:	338c      	adds	r3, #140	@ 0x8c
 8009756:	4618      	mov	r0, r3
 8009758:	f00f fcc8 	bl	80190ec <FreeDer>
    XFREE(x509->sig.buffer, x509->heap, DYNAMIC_TYPE_SIGNATURE);
 800975c:	687b      	ldr	r3, [r7, #4]
 800975e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8009760:	62bb      	str	r3, [r7, #40]	@ 0x28
 8009762:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009764:	2b00      	cmp	r3, #0
 8009766:	d002      	beq.n	800976e <FreeX509+0x64>
 8009768:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800976a:	f015 faa3 	bl	801ecb4 <wolfSSL_Free>
    x509->sig.buffer = NULL;
 800976e:	687b      	ldr	r3, [r7, #4]
 8009770:	2200      	movs	r2, #0
 8009772:	669a      	str	r2, [r3, #104]	@ 0x68
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        if (x509->authKeyIdSrc != NULL) {
 8009774:	687b      	ldr	r3, [r7, #4]
 8009776:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 800977a:	2b00      	cmp	r3, #0
 800977c:	d00a      	beq.n	8009794 <FreeX509+0x8a>
            XFREE(x509->authKeyIdSrc, x509->heap, DYNAMIC_TYPE_X509_EXT);
 800977e:	687b      	ldr	r3, [r7, #4]
 8009780:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8009784:	623b      	str	r3, [r7, #32]
 8009786:	6a3b      	ldr	r3, [r7, #32]
 8009788:	2b00      	cmp	r3, #0
 800978a:	d00d      	beq.n	80097a8 <FreeX509+0x9e>
 800978c:	6a38      	ldr	r0, [r7, #32]
 800978e:	f015 fa91 	bl	801ecb4 <wolfSSL_Free>
 8009792:	e009      	b.n	80097a8 <FreeX509+0x9e>
        }
        else {
            XFREE(x509->authKeyId, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009794:	687b      	ldr	r3, [r7, #4]
 8009796:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 800979a:	627b      	str	r3, [r7, #36]	@ 0x24
 800979c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800979e:	2b00      	cmp	r3, #0
 80097a0:	d002      	beq.n	80097a8 <FreeX509+0x9e>
 80097a2:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 80097a4:	f015 fa86 	bl	801ecb4 <wolfSSL_Free>
        }
        x509->authKeyIdSrc = NULL;
 80097a8:	687b      	ldr	r3, [r7, #4]
 80097aa:	2200      	movs	r2, #0
 80097ac:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
        x509->authKeyId = NULL;
 80097b0:	687b      	ldr	r3, [r7, #4]
 80097b2:	2200      	movs	r2, #0
 80097b4:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
        XFREE(x509->subjKeyId, x509->heap, DYNAMIC_TYPE_X509_EXT);
 80097b8:	687b      	ldr	r3, [r7, #4]
 80097ba:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 80097be:	61fb      	str	r3, [r7, #28]
 80097c0:	69fb      	ldr	r3, [r7, #28]
 80097c2:	2b00      	cmp	r3, #0
 80097c4:	d002      	beq.n	80097cc <FreeX509+0xc2>
 80097c6:	69f8      	ldr	r0, [r7, #28]
 80097c8:	f015 fa74 	bl	801ecb4 <wolfSSL_Free>
        x509->subjKeyId = NULL;
 80097cc:	687b      	ldr	r3, [r7, #4]
 80097ce:	2200      	movs	r2, #0
 80097d0:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
        wolfSSL_ASN1_STRING_free(x509->subjKeyIdStr);
 80097d4:	687b      	ldr	r3, [r7, #4]
 80097d6:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 80097da:	4618      	mov	r0, r3
 80097dc:	f002 fa16 	bl	800bc0c <wolfSSL_ASN1_STRING_free>
        x509->subjKeyIdStr = NULL;
 80097e0:	687b      	ldr	r3, [r7, #4]
 80097e2:	2200      	movs	r2, #0
 80097e4:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
        XFREE(x509->authInfo, x509->heap, DYNAMIC_TYPE_X509_EXT);
 80097e8:	687b      	ldr	r3, [r7, #4]
 80097ea:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 80097ee:	61bb      	str	r3, [r7, #24]
 80097f0:	69bb      	ldr	r3, [r7, #24]
 80097f2:	2b00      	cmp	r3, #0
 80097f4:	d002      	beq.n	80097fc <FreeX509+0xf2>
 80097f6:	69b8      	ldr	r0, [r7, #24]
 80097f8:	f015 fa5c 	bl	801ecb4 <wolfSSL_Free>
        x509->authInfo = NULL;
 80097fc:	687b      	ldr	r3, [r7, #4]
 80097fe:	2200      	movs	r2, #0
 8009800:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8
        XFREE(x509->rawCRLInfo, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009804:	687b      	ldr	r3, [r7, #4]
 8009806:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 800980a:	617b      	str	r3, [r7, #20]
 800980c:	697b      	ldr	r3, [r7, #20]
 800980e:	2b00      	cmp	r3, #0
 8009810:	d002      	beq.n	8009818 <FreeX509+0x10e>
 8009812:	6978      	ldr	r0, [r7, #20]
 8009814:	f015 fa4e 	bl	801ecb4 <wolfSSL_Free>
        x509->rawCRLInfo = NULL;
 8009818:	687b      	ldr	r3, [r7, #4]
 800981a:	2200      	movs	r2, #0
 800981c:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
        XFREE(x509->CRLInfo, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009820:	687b      	ldr	r3, [r7, #4]
 8009822:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8009826:	613b      	str	r3, [r7, #16]
 8009828:	693b      	ldr	r3, [r7, #16]
 800982a:	2b00      	cmp	r3, #0
 800982c:	d002      	beq.n	8009834 <FreeX509+0x12a>
 800982e:	6938      	ldr	r0, [r7, #16]
 8009830:	f015 fa40 	bl	801ecb4 <wolfSSL_Free>
        x509->CRLInfo = NULL;
 8009834:	687b      	ldr	r3, [r7, #4]
 8009836:	2200      	movs	r2, #0
 8009838:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4
        #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA) || \
            defined(WOLFSSL_QT)
        XFREE(x509->authInfoCaIssuer, x509->heap, DYNAMIC_TYPE_X509_EXT);
 800983c:	687b      	ldr	r3, [r7, #4]
 800983e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 8009842:	60fb      	str	r3, [r7, #12]
 8009844:	68fb      	ldr	r3, [r7, #12]
 8009846:	2b00      	cmp	r3, #0
 8009848:	d002      	beq.n	8009850 <FreeX509+0x146>
 800984a:	68f8      	ldr	r0, [r7, #12]
 800984c:	f015 fa32 	bl	801ecb4 <wolfSSL_Free>
        if (x509->ext_sk != NULL) {
 8009850:	687b      	ldr	r3, [r7, #4]
 8009852:	689b      	ldr	r3, [r3, #8]
 8009854:	2b00      	cmp	r3, #0
 8009856:	d005      	beq.n	8009864 <FreeX509+0x15a>
            wolfSSL_sk_X509_EXTENSION_pop_free(x509->ext_sk, NULL);
 8009858:	687b      	ldr	r3, [r7, #4]
 800985a:	689b      	ldr	r3, [r3, #8]
 800985c:	2100      	movs	r1, #0
 800985e:	4618      	mov	r0, r3
 8009860:	f004 ff1e 	bl	800e6a0 <wolfSSL_sk_X509_EXTENSION_pop_free>
        }
        if (x509->ext_sk_full != NULL) {
 8009864:	687b      	ldr	r3, [r7, #4]
 8009866:	68db      	ldr	r3, [r3, #12]
 8009868:	2b00      	cmp	r3, #0
 800986a:	d005      	beq.n	8009878 <FreeX509+0x16e>
            wolfSSL_sk_X509_EXTENSION_pop_free(x509->ext_sk_full, NULL);
 800986c:	687b      	ldr	r3, [r7, #4]
 800986e:	68db      	ldr	r3, [r3, #12]
 8009870:	2100      	movs	r1, #0
 8009872:	4618      	mov	r0, r3
 8009874:	f004 ff14 	bl	800e6a0 <wolfSSL_sk_X509_EXTENSION_pop_free>
        }
        #endif /* OPENSSL_ALL || WOLFSSL_QT */
        #ifdef OPENSSL_EXTRA
        /* Free serialNumber that was set by wolfSSL_X509_get_serialNumber */
        if (x509->serialNumber != NULL) {
 8009878:	687b      	ldr	r3, [r7, #4]
 800987a:	695b      	ldr	r3, [r3, #20]
 800987c:	2b00      	cmp	r3, #0
 800987e:	d004      	beq.n	800988a <FreeX509+0x180>
            wolfSSL_ASN1_INTEGER_free(x509->serialNumber);
 8009880:	687b      	ldr	r3, [r7, #4]
 8009882:	695b      	ldr	r3, [r3, #20]
 8009884:	4618      	mov	r0, r3
 8009886:	f002 f91b 	bl	800bac0 <wolfSSL_ASN1_INTEGER_free>
        }
        #endif
        if (x509->extKeyUsageSrc != NULL) {
 800988a:	687b      	ldr	r3, [r7, #4]
 800988c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8009890:	2b00      	cmp	r3, #0
 8009892:	d00d      	beq.n	80098b0 <FreeX509+0x1a6>
            XFREE(x509->extKeyUsageSrc, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009894:	687b      	ldr	r3, [r7, #4]
 8009896:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 800989a:	60bb      	str	r3, [r7, #8]
 800989c:	68bb      	ldr	r3, [r7, #8]
 800989e:	2b00      	cmp	r3, #0
 80098a0:	d002      	beq.n	80098a8 <FreeX509+0x19e>
 80098a2:	68b8      	ldr	r0, [r7, #8]
 80098a4:	f015 fa06 	bl	801ecb4 <wolfSSL_Free>
            x509->extKeyUsageSrc= NULL;
 80098a8:	687b      	ldr	r3, [r7, #4]
 80098aa:	2200      	movs	r2, #0
 80098ac:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
            XFREE(x509->custom_exts[idx].val, x509->heap,
                  DYNAMIC_TYPE_X509_EXT);
        }
    #endif /* WOLFSSL_CUSTOM_OID */
    #endif /* WOLFSSL_CERT_REQ && OPENSSL_ALL */
    if (x509->altNames) {
 80098b0:	687b      	ldr	r3, [r7, #4]
 80098b2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80098b4:	2b00      	cmp	r3, #0
 80098b6:	d00d      	beq.n	80098d4 <FreeX509+0x1ca>
        FreeAltNames(x509->altNames, x509->heap);
 80098b8:	687b      	ldr	r3, [r7, #4]
 80098ba:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 80098bc:	687b      	ldr	r3, [r7, #4]
 80098be:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 80098c2:	4619      	mov	r1, r3
 80098c4:	4610      	mov	r0, r2
 80098c6:	f00b fd10 	bl	80152ea <FreeAltNames>
        x509->altNames = NULL;
 80098ca:	687b      	ldr	r3, [r7, #4]
 80098cc:	2200      	movs	r2, #0
 80098ce:	675a      	str	r2, [r3, #116]	@ 0x74
 80098d0:	e000      	b.n	80098d4 <FreeX509+0x1ca>
        return;
 80098d2:	bf00      	nop
    #endif /* WOLFSSL_DUAL_ALG_CERTS */

    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_ALL)
        wolfSSL_RefFree(&x509->ref);
    #endif
}
 80098d4:	3730      	adds	r7, #48	@ 0x30
 80098d6:	46bd      	mov	sp, r7
 80098d8:	bd80      	pop	{r7, pc}

080098da <FreeHandshakeHashes>:

    return ret;
}

void FreeHandshakeHashes(WOLFSSL* ssl)
{
 80098da:	b580      	push	{r7, lr}
 80098dc:	b084      	sub	sp, #16
 80098de:	af00      	add	r7, sp, #0
 80098e0:	6078      	str	r0, [r7, #4]
    if (ssl->hsHashes) {
 80098e2:	687b      	ldr	r3, [r7, #4]
 80098e4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80098e6:	2b00      	cmp	r3, #0
 80098e8:	d011      	beq.n	800990e <FreeHandshakeHashes+0x34>
    #if !defined(NO_SHA) && (!defined(NO_OLD_TLS) || \
                              defined(WOLFSSL_ALLOW_TLS_SHA1))
        wc_ShaFree(&ssl->hsHashes->hashSha);
    #endif
    #ifndef NO_SHA256
        wc_Sha256Free(&ssl->hsHashes->hashSha256);
 80098ea:	687b      	ldr	r3, [r7, #4]
 80098ec:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80098ee:	3340      	adds	r3, #64	@ 0x40
 80098f0:	4618      	mov	r0, r3
 80098f2:	f018 fc84 	bl	80221fe <wc_Sha256Free>
            XFREE(ssl->hsHashes->messages, ssl->heap, DYNAMIC_TYPE_HASHES);
            ssl->hsHashes->messages = NULL;
         }
    #endif

        XFREE(ssl->hsHashes, ssl->heap, DYNAMIC_TYPE_HASHES);
 80098f6:	687b      	ldr	r3, [r7, #4]
 80098f8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80098fa:	60fb      	str	r3, [r7, #12]
 80098fc:	68fb      	ldr	r3, [r7, #12]
 80098fe:	2b00      	cmp	r3, #0
 8009900:	d002      	beq.n	8009908 <FreeHandshakeHashes+0x2e>
 8009902:	68f8      	ldr	r0, [r7, #12]
 8009904:	f015 f9d6 	bl	801ecb4 <wolfSSL_Free>
        ssl->hsHashes = NULL;
 8009908:	687b      	ldr	r3, [r7, #4]
 800990a:	2200      	movs	r2, #0
 800990c:	675a      	str	r2, [r3, #116]	@ 0x74
    }
}
 800990e:	bf00      	nop
 8009910:	3710      	adds	r7, #16
 8009912:	46bd      	mov	sp, r7
 8009914:	bd80      	pop	{r7, pc}

08009916 <FreeArrays>:
}


/* free use of temporary arrays */
void FreeArrays(WOLFSSL* ssl, int keep)
{
 8009916:	b580      	push	{r7, lr}
 8009918:	b086      	sub	sp, #24
 800991a:	af00      	add	r7, sp, #0
 800991c:	6078      	str	r0, [r7, #4]
 800991e:	6039      	str	r1, [r7, #0]
    if (ssl->arrays) {
 8009920:	687b      	ldr	r3, [r7, #4]
 8009922:	691b      	ldr	r3, [r3, #16]
 8009924:	2b00      	cmp	r3, #0
 8009926:	d052      	beq.n	80099ce <FreeArrays+0xb8>
        if (keep && !IsAtLeastTLSv1_3(ssl->version)) {
 8009928:	683b      	ldr	r3, [r7, #0]
 800992a:	2b00      	cmp	r3, #0
 800992c:	d020      	beq.n	8009970 <FreeArrays+0x5a>
 800992e:	687b      	ldr	r3, [r7, #4]
 8009930:	f8b3 21da 	ldrh.w	r2, [r3, #474]	@ 0x1da
 8009934:	2300      	movs	r3, #0
 8009936:	f362 030f 	bfi	r3, r2, #0, #16
 800993a:	4618      	mov	r0, r3
 800993c:	f7ff f89e 	bl	8008a7c <IsAtLeastTLSv1_3>
 8009940:	4603      	mov	r3, r0
 8009942:	2b00      	cmp	r3, #0
 8009944:	d114      	bne.n	8009970 <FreeArrays+0x5a>
            /* keeps session id for user retrieval */
            XMEMCPY(ssl->session->sessionID, ssl->arrays->sessionID, ID_LEN);
 8009946:	687b      	ldr	r3, [r7, #4]
 8009948:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 800994c:	f103 0040 	add.w	r0, r3, #64	@ 0x40
 8009950:	687b      	ldr	r3, [r7, #4]
 8009952:	691b      	ldr	r3, [r3, #16]
 8009954:	3354      	adds	r3, #84	@ 0x54
 8009956:	2220      	movs	r2, #32
 8009958:	4619      	mov	r1, r3
 800995a:	f01f fa14 	bl	8028d86 <memcpy>
            ssl->session->sessionIDSz = ssl->arrays->sessionIDSz;
 800995e:	687b      	ldr	r3, [r7, #4]
 8009960:	691a      	ldr	r2, [r3, #16]
 8009962:	687b      	ldr	r3, [r7, #4]
 8009964:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 8009968:	f892 2074 	ldrb.w	r2, [r2, #116]	@ 0x74
 800996c:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
        }
        if (ssl->arrays->preMasterSecret) {
 8009970:	687b      	ldr	r3, [r7, #4]
 8009972:	691b      	ldr	r3, [r3, #16]
 8009974:	685b      	ldr	r3, [r3, #4]
 8009976:	2b00      	cmp	r3, #0
 8009978:	d015      	beq.n	80099a6 <FreeArrays+0x90>
            ForceZero(ssl->arrays->preMasterSecret, ENCRYPT_LEN);
 800997a:	687b      	ldr	r3, [r7, #4]
 800997c:	691b      	ldr	r3, [r3, #16]
 800997e:	685b      	ldr	r3, [r3, #4]
 8009980:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8009984:	4618      	mov	r0, r3
 8009986:	f7ff f850 	bl	8008a2a <ForceZero>
            XFREE(ssl->arrays->preMasterSecret, ssl->heap, DYNAMIC_TYPE_SECRET);
 800998a:	687b      	ldr	r3, [r7, #4]
 800998c:	691b      	ldr	r3, [r3, #16]
 800998e:	685b      	ldr	r3, [r3, #4]
 8009990:	617b      	str	r3, [r7, #20]
 8009992:	697b      	ldr	r3, [r7, #20]
 8009994:	2b00      	cmp	r3, #0
 8009996:	d002      	beq.n	800999e <FreeArrays+0x88>
 8009998:	6978      	ldr	r0, [r7, #20]
 800999a:	f015 f98b 	bl	801ecb4 <wolfSSL_Free>
            ssl->arrays->preMasterSecret = NULL;
 800999e:	687b      	ldr	r3, [r7, #4]
 80099a0:	691b      	ldr	r3, [r3, #16]
 80099a2:	2200      	movs	r2, #0
 80099a4:	605a      	str	r2, [r3, #4]
        }
        XFREE(ssl->arrays->pendingMsg, ssl->heap, DYNAMIC_TYPE_ARRAYS);
 80099a6:	687b      	ldr	r3, [r7, #4]
 80099a8:	691b      	ldr	r3, [r3, #16]
 80099aa:	681b      	ldr	r3, [r3, #0]
 80099ac:	613b      	str	r3, [r7, #16]
 80099ae:	693b      	ldr	r3, [r7, #16]
 80099b0:	2b00      	cmp	r3, #0
 80099b2:	d002      	beq.n	80099ba <FreeArrays+0xa4>
 80099b4:	6938      	ldr	r0, [r7, #16]
 80099b6:	f015 f97d 	bl	801ecb4 <wolfSSL_Free>
        ssl->arrays->pendingMsg = NULL;
 80099ba:	687b      	ldr	r3, [r7, #4]
 80099bc:	691b      	ldr	r3, [r3, #16]
 80099be:	2200      	movs	r2, #0
 80099c0:	601a      	str	r2, [r3, #0]
        ForceZero(ssl->arrays, sizeof(Arrays)); /* clear arrays struct */
 80099c2:	687b      	ldr	r3, [r7, #4]
 80099c4:	691b      	ldr	r3, [r3, #16]
 80099c6:	21d8      	movs	r1, #216	@ 0xd8
 80099c8:	4618      	mov	r0, r3
 80099ca:	f7ff f82e 	bl	8008a2a <ForceZero>
    }
    XFREE(ssl->arrays, ssl->heap, DYNAMIC_TYPE_ARRAYS);
 80099ce:	687b      	ldr	r3, [r7, #4]
 80099d0:	691b      	ldr	r3, [r3, #16]
 80099d2:	60fb      	str	r3, [r7, #12]
 80099d4:	68fb      	ldr	r3, [r7, #12]
 80099d6:	2b00      	cmp	r3, #0
 80099d8:	d002      	beq.n	80099e0 <FreeArrays+0xca>
 80099da:	68f8      	ldr	r0, [r7, #12]
 80099dc:	f015 f96a 	bl	801ecb4 <wolfSSL_Free>
    ssl->arrays = NULL;
 80099e0:	687b      	ldr	r3, [r7, #4]
 80099e2:	2200      	movs	r2, #0
 80099e4:	611a      	str	r2, [r3, #16]
}
 80099e6:	bf00      	nop
 80099e8:	3718      	adds	r7, #24
 80099ea:	46bd      	mov	sp, r7
 80099ec:	bd80      	pop	{r7, pc}

080099ee <FreeKey>:

void FreeKey(WOLFSSL* ssl, int type, void** pKey)
{
 80099ee:	b580      	push	{r7, lr}
 80099f0:	b086      	sub	sp, #24
 80099f2:	af00      	add	r7, sp, #0
 80099f4:	60f8      	str	r0, [r7, #12]
 80099f6:	60b9      	str	r1, [r7, #8]
 80099f8:	607a      	str	r2, [r7, #4]
    if (ssl && pKey && *pKey) {
 80099fa:	68fb      	ldr	r3, [r7, #12]
 80099fc:	2b00      	cmp	r3, #0
 80099fe:	d032      	beq.n	8009a66 <FreeKey+0x78>
 8009a00:	687b      	ldr	r3, [r7, #4]
 8009a02:	2b00      	cmp	r3, #0
 8009a04:	d02f      	beq.n	8009a66 <FreeKey+0x78>
 8009a06:	687b      	ldr	r3, [r7, #4]
 8009a08:	681b      	ldr	r3, [r3, #0]
 8009a0a:	2b00      	cmp	r3, #0
 8009a0c:	d02b      	beq.n	8009a66 <FreeKey+0x78>
        switch (type) {
 8009a0e:	68bb      	ldr	r3, [r7, #8]
 8009a10:	2b25      	cmp	r3, #37	@ 0x25
 8009a12:	d00f      	beq.n	8009a34 <FreeKey+0x46>
 8009a14:	68bb      	ldr	r3, [r7, #8]
 8009a16:	2b25      	cmp	r3, #37	@ 0x25
 8009a18:	dc18      	bgt.n	8009a4c <FreeKey+0x5e>
 8009a1a:	68bb      	ldr	r3, [r7, #8]
 8009a1c:	2b0a      	cmp	r3, #10
 8009a1e:	d003      	beq.n	8009a28 <FreeKey+0x3a>
 8009a20:	68bb      	ldr	r3, [r7, #8]
 8009a22:	2b0f      	cmp	r3, #15
 8009a24:	d00c      	beq.n	8009a40 <FreeKey+0x52>
            case DYNAMIC_TYPE_DH:
                wc_FreeDhKey((DhKey*)*pKey);
                break;
        #endif /* !NO_DH */
            default:
                break;
 8009a26:	e011      	b.n	8009a4c <FreeKey+0x5e>
                wc_FreeRsaKey((RsaKey*)*pKey);
 8009a28:	687b      	ldr	r3, [r7, #4]
 8009a2a:	681b      	ldr	r3, [r3, #0]
 8009a2c:	4618      	mov	r0, r3
 8009a2e:	f016 fba9 	bl	8020184 <wc_FreeRsaKey>
                break;
 8009a32:	e00c      	b.n	8009a4e <FreeKey+0x60>
                wc_ecc_free((ecc_key*)*pKey);
 8009a34:	687b      	ldr	r3, [r7, #4]
 8009a36:	681b      	ldr	r3, [r3, #0]
 8009a38:	4618      	mov	r0, r3
 8009a3a:	f013 fb26 	bl	801d08a <wc_ecc_free>
                break;
 8009a3e:	e006      	b.n	8009a4e <FreeKey+0x60>
                wc_FreeDhKey((DhKey*)*pKey);
 8009a40:	687b      	ldr	r3, [r7, #4]
 8009a42:	681b      	ldr	r3, [r3, #0]
 8009a44:	4618      	mov	r0, r3
 8009a46:	f010 ff35 	bl	801a8b4 <wc_FreeDhKey>
                break;
 8009a4a:	e000      	b.n	8009a4e <FreeKey+0x60>
                break;
 8009a4c:	bf00      	nop
        }
        XFREE(*pKey, ssl->heap, type);
 8009a4e:	687b      	ldr	r3, [r7, #4]
 8009a50:	681b      	ldr	r3, [r3, #0]
 8009a52:	617b      	str	r3, [r7, #20]
 8009a54:	697b      	ldr	r3, [r7, #20]
 8009a56:	2b00      	cmp	r3, #0
 8009a58:	d002      	beq.n	8009a60 <FreeKey+0x72>
 8009a5a:	6978      	ldr	r0, [r7, #20]
 8009a5c:	f015 f92a 	bl	801ecb4 <wolfSSL_Free>

        /* Reset pointer */
        *pKey = NULL;
 8009a60:	687b      	ldr	r3, [r7, #4]
 8009a62:	2200      	movs	r2, #0
 8009a64:	601a      	str	r2, [r3, #0]
    }
}
 8009a66:	bf00      	nop
 8009a68:	3718      	adds	r7, #24
 8009a6a:	46bd      	mov	sp, r7
 8009a6c:	bd80      	pop	{r7, pc}

08009a6e <FreeAsyncCtx>:
}
#endif

#ifdef WOLFSSL_ASYNC_IO
void FreeAsyncCtx(WOLFSSL* ssl, byte freeAsync)
{
 8009a6e:	b580      	push	{r7, lr}
 8009a70:	b084      	sub	sp, #16
 8009a72:	af00      	add	r7, sp, #0
 8009a74:	6078      	str	r0, [r7, #4]
 8009a76:	460b      	mov	r3, r1
 8009a78:	70fb      	strb	r3, [r7, #3]
    if (ssl->async != NULL) {
 8009a7a:	687b      	ldr	r3, [r7, #4]
 8009a7c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009a80:	2b00      	cmp	r3, #0
 8009a82:	d026      	beq.n	8009ad2 <FreeAsyncCtx+0x64>
        if (ssl->async->freeArgs != NULL) {
 8009a84:	687b      	ldr	r3, [r7, #4]
 8009a86:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009a8a:	681b      	ldr	r3, [r3, #0]
 8009a8c:	2b00      	cmp	r3, #0
 8009a8e:	d00f      	beq.n	8009ab0 <FreeAsyncCtx+0x42>
            ssl->async->freeArgs(ssl, ssl->async->args);
 8009a90:	687b      	ldr	r3, [r7, #4]
 8009a92:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009a96:	681b      	ldr	r3, [r3, #0]
 8009a98:	687a      	ldr	r2, [r7, #4]
 8009a9a:	f8d2 20a4 	ldr.w	r2, [r2, #164]	@ 0xa4
 8009a9e:	3204      	adds	r2, #4
 8009aa0:	4611      	mov	r1, r2
 8009aa2:	6878      	ldr	r0, [r7, #4]
 8009aa4:	4798      	blx	r3
            ssl->async->freeArgs = NULL;
 8009aa6:	687b      	ldr	r3, [r7, #4]
 8009aa8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009aac:	2200      	movs	r2, #0
 8009aae:	601a      	str	r2, [r3, #0]
        if (ssl->options.buildArgsSet) {
            FreeBuildMsgArgs(ssl, &ssl->async->buildArgs);
            ssl->options.buildArgsSet = 0;
        }
#endif
        if (freeAsync) {
 8009ab0:	78fb      	ldrb	r3, [r7, #3]
 8009ab2:	2b00      	cmp	r3, #0
 8009ab4:	d00d      	beq.n	8009ad2 <FreeAsyncCtx+0x64>
            XFREE(ssl->async, ssl->heap, DYNAMIC_TYPE_ASYNC);
 8009ab6:	687b      	ldr	r3, [r7, #4]
 8009ab8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009abc:	60fb      	str	r3, [r7, #12]
 8009abe:	68fb      	ldr	r3, [r7, #12]
 8009ac0:	2b00      	cmp	r3, #0
 8009ac2:	d002      	beq.n	8009aca <FreeAsyncCtx+0x5c>
 8009ac4:	68f8      	ldr	r0, [r7, #12]
 8009ac6:	f015 f8f5 	bl	801ecb4 <wolfSSL_Free>
            ssl->async = NULL;
 8009aca:	687b      	ldr	r3, [r7, #4]
 8009acc:	2200      	movs	r2, #0
 8009ace:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
        }
    }
}
 8009ad2:	bf00      	nop
 8009ad4:	3710      	adds	r7, #16
 8009ad6:	46bd      	mov	sp, r7
 8009ad8:	bd80      	pop	{r7, pc}

08009ada <FreeKeyExchange>:
#endif

void FreeKeyExchange(WOLFSSL* ssl)
{
 8009ada:	b580      	push	{r7, lr}
 8009adc:	b084      	sub	sp, #16
 8009ade:	af00      	add	r7, sp, #0
 8009ae0:	6078      	str	r0, [r7, #4]
    /* Cleanup signature buffer */
    if (ssl->buffers.sig.buffer) {
 8009ae2:	687b      	ldr	r3, [r7, #4]
 8009ae4:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
 8009ae8:	2b00      	cmp	r3, #0
 8009aea:	d011      	beq.n	8009b10 <FreeKeyExchange+0x36>
        XFREE(ssl->buffers.sig.buffer, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
 8009aec:	687b      	ldr	r3, [r7, #4]
 8009aee:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
 8009af2:	60fb      	str	r3, [r7, #12]
 8009af4:	68fb      	ldr	r3, [r7, #12]
 8009af6:	2b00      	cmp	r3, #0
 8009af8:	d002      	beq.n	8009b00 <FreeKeyExchange+0x26>
 8009afa:	68f8      	ldr	r0, [r7, #12]
 8009afc:	f015 f8da 	bl	801ecb4 <wolfSSL_Free>
        ssl->buffers.sig.buffer = NULL;
 8009b00:	687b      	ldr	r3, [r7, #4]
 8009b02:	2200      	movs	r2, #0
 8009b04:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
        ssl->buffers.sig.length = 0;
 8009b08:	687b      	ldr	r3, [r7, #4]
 8009b0a:	2200      	movs	r2, #0
 8009b0c:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130
    }

    /* Cleanup digest buffer */
    if (ssl->buffers.digest.buffer) {
 8009b10:	687b      	ldr	r3, [r7, #4]
 8009b12:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
 8009b16:	2b00      	cmp	r3, #0
 8009b18:	d020      	beq.n	8009b5c <FreeKeyExchange+0x82>
        /* Only free if digest buffer was not set using SetDigest */
        if (!ssl->options.dontFreeDigest) {
 8009b1a:	687b      	ldr	r3, [r7, #4]
 8009b1c:	f893 32d5 	ldrb.w	r3, [r3, #725]	@ 0x2d5
 8009b20:	f003 0310 	and.w	r3, r3, #16
 8009b24:	b2db      	uxtb	r3, r3
 8009b26:	2b00      	cmp	r3, #0
 8009b28:	d109      	bne.n	8009b3e <FreeKeyExchange+0x64>
            XFREE(ssl->buffers.digest.buffer, ssl->heap, DYNAMIC_TYPE_DIGEST);
 8009b2a:	687b      	ldr	r3, [r7, #4]
 8009b2c:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
 8009b30:	60bb      	str	r3, [r7, #8]
 8009b32:	68bb      	ldr	r3, [r7, #8]
 8009b34:	2b00      	cmp	r3, #0
 8009b36:	d002      	beq.n	8009b3e <FreeKeyExchange+0x64>
 8009b38:	68b8      	ldr	r0, [r7, #8]
 8009b3a:	f015 f8bb 	bl	801ecb4 <wolfSSL_Free>
        }
        ssl->buffers.digest.buffer = NULL;
 8009b3e:	687b      	ldr	r3, [r7, #4]
 8009b40:	2200      	movs	r2, #0
 8009b42:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
        ssl->buffers.digest.length = 0;
 8009b46:	687b      	ldr	r3, [r7, #4]
 8009b48:	2200      	movs	r2, #0
 8009b4a:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
        ssl->options.dontFreeDigest = 0;
 8009b4e:	687a      	ldr	r2, [r7, #4]
 8009b50:	f892 32d5 	ldrb.w	r3, [r2, #725]	@ 0x2d5
 8009b54:	f023 0310 	bic.w	r3, r3, #16
 8009b58:	f882 32d5 	strb.w	r3, [r2, #725]	@ 0x2d5
    }

    /* Free handshake key */
    FreeKey(ssl, (int)ssl->hsType, &ssl->hsKey);
 8009b5c:	687b      	ldr	r3, [r7, #4]
 8009b5e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8009b62:	4619      	mov	r1, r3
 8009b64:	687b      	ldr	r3, [r7, #4]
 8009b66:	33a8      	adds	r3, #168	@ 0xa8
 8009b68:	461a      	mov	r2, r3
 8009b6a:	6878      	ldr	r0, [r7, #4]
 8009b6c:	f7ff ff3f 	bl	80099ee <FreeKey>
    FreeKey(ssl, ssl->hsAltType, &ssl->hsAltKey);
#endif /* WOLFSSL_DUAL_ALG_CERTS */

#ifndef NO_DH
    /* Free temp DH key */
    FreeKey(ssl, DYNAMIC_TYPE_DH, (void**)&ssl->buffers.serverDH_Key);
 8009b70:	687b      	ldr	r3, [r7, #4]
 8009b72:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8009b76:	461a      	mov	r2, r3
 8009b78:	210f      	movs	r1, #15
 8009b7a:	6878      	ldr	r0, [r7, #4]
 8009b7c:	f7ff ff37 	bl	80099ee <FreeKey>
#endif
}
 8009b80:	bf00      	nop
 8009b82:	3710      	adds	r7, #16
 8009b84:	46bd      	mov	sp, r7
 8009b86:	bd80      	pop	{r7, pc}

08009b88 <FreeSuites>:


/* Free up all memory used by Suites structure from WOLFSSL */
void FreeSuites(WOLFSSL* ssl)
{
 8009b88:	b580      	push	{r7, lr}
 8009b8a:	b084      	sub	sp, #16
 8009b8c:	af00      	add	r7, sp, #0
 8009b8e:	6078      	str	r0, [r7, #4]
         * isn't allocated separately. */
        wolfSSL_sk_SSL_CIPHER_free(ssl->suitesStack);
        ssl->suitesStack = NULL;
    }
#endif
    XFREE(ssl->suites, ssl->heap, DYNAMIC_TYPE_SUITES);
 8009b90:	687b      	ldr	r3, [r7, #4]
 8009b92:	685b      	ldr	r3, [r3, #4]
 8009b94:	60fb      	str	r3, [r7, #12]
 8009b96:	68fb      	ldr	r3, [r7, #12]
 8009b98:	2b00      	cmp	r3, #0
 8009b9a:	d002      	beq.n	8009ba2 <FreeSuites+0x1a>
 8009b9c:	68f8      	ldr	r0, [r7, #12]
 8009b9e:	f015 f889 	bl	801ecb4 <wolfSSL_Free>
    ssl->suites = NULL;
 8009ba2:	687b      	ldr	r3, [r7, #4]
 8009ba4:	2200      	movs	r2, #0
 8009ba6:	605a      	str	r2, [r3, #4]
}
 8009ba8:	bf00      	nop
 8009baa:	3710      	adds	r7, #16
 8009bac:	46bd      	mov	sp, r7
 8009bae:	bd80      	pop	{r7, pc}

08009bb0 <wolfSSL_ResourceFree>:


/* In case holding SSL object in array and don't want to free actual ssl */
void wolfSSL_ResourceFree(WOLFSSL* ssl)
{
 8009bb0:	b580      	push	{r7, lr}
 8009bb2:	b08a      	sub	sp, #40	@ 0x28
 8009bb4:	af00      	add	r7, sp, #0
 8009bb6:	6078      	str	r0, [r7, #4]

#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
    wolfSSL_CRYPTO_cleanup_ex_data(&ssl->ex_data);
#endif

    FreeCiphers(ssl);
 8009bb8:	6878      	ldr	r0, [r7, #4]
 8009bba:	f7ff f9d4 	bl	8008f66 <FreeCiphers>
    FreeArrays(ssl, 0);
 8009bbe:	2100      	movs	r1, #0
 8009bc0:	6878      	ldr	r0, [r7, #4]
 8009bc2:	f7ff fea8 	bl	8009916 <FreeArrays>
    FreeKeyExchange(ssl);
 8009bc6:	6878      	ldr	r0, [r7, #4]
 8009bc8:	f7ff ff87 	bl	8009ada <FreeKeyExchange>
#ifdef WOLFSSL_ASYNC_IO
    /* Cleanup async */
    FreeAsyncCtx(ssl, 1);
 8009bcc:	2101      	movs	r1, #1
 8009bce:	6878      	ldr	r0, [r7, #4]
 8009bd0:	f7ff ff4d 	bl	8009a6e <FreeAsyncCtx>
#endif
    if (ssl->options.weOwnRng) {
 8009bd4:	687b      	ldr	r3, [r7, #4]
 8009bd6:	f893 32d5 	ldrb.w	r3, [r3, #725]	@ 0x2d5
 8009bda:	f003 0308 	and.w	r3, r3, #8
 8009bde:	b2db      	uxtb	r3, r3
 8009be0:	2b00      	cmp	r3, #0
 8009be2:	d01a      	beq.n	8009c1a <wolfSSL_ResourceFree+0x6a>
        wc_FreeRng(ssl->rng);
 8009be4:	687b      	ldr	r3, [r7, #4]
 8009be6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8009bea:	4618      	mov	r0, r3
 8009bec:	f015 fe6e 	bl	801f8cc <wc_FreeRng>
        XFREE(ssl->rng, ssl->heap, DYNAMIC_TYPE_RNG);
 8009bf0:	687b      	ldr	r3, [r7, #4]
 8009bf2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8009bf6:	627b      	str	r3, [r7, #36]	@ 0x24
 8009bf8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009bfa:	2b00      	cmp	r3, #0
 8009bfc:	d002      	beq.n	8009c04 <wolfSSL_ResourceFree+0x54>
 8009bfe:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8009c00:	f015 f858 	bl	801ecb4 <wolfSSL_Free>
        ssl->rng = NULL;
 8009c04:	687b      	ldr	r3, [r7, #4]
 8009c06:	2200      	movs	r2, #0
 8009c08:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
        ssl->options.weOwnRng = 0;
 8009c0c:	687a      	ldr	r2, [r7, #4]
 8009c0e:	f892 32d5 	ldrb.w	r3, [r2, #725]	@ 0x2d5
 8009c12:	f023 0308 	bic.w	r3, r3, #8
 8009c16:	f882 32d5 	strb.w	r3, [r2, #725]	@ 0x2d5
    }
    FreeSuites(ssl);
 8009c1a:	6878      	ldr	r0, [r7, #4]
 8009c1c:	f7ff ffb4 	bl	8009b88 <FreeSuites>
    FreeHandshakeHashes(ssl);
 8009c20:	6878      	ldr	r0, [r7, #4]
 8009c22:	f7ff fe5a 	bl	80098da <FreeHandshakeHashes>
    XFREE(ssl->buffers.domainName.buffer, ssl->heap, DYNAMIC_TYPE_DOMAIN);
 8009c26:	687b      	ldr	r3, [r7, #4]
 8009c28:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8009c2c:	623b      	str	r3, [r7, #32]
 8009c2e:	6a3b      	ldr	r3, [r7, #32]
 8009c30:	2b00      	cmp	r3, #0
 8009c32:	d002      	beq.n	8009c3a <wolfSSL_ResourceFree+0x8a>
 8009c34:	6a38      	ldr	r0, [r7, #32]
 8009c36:	f015 f83d 	bl	801ecb4 <wolfSSL_Free>

    /* clear keys struct after session */
    ForceZero(&ssl->keys, sizeof(Keys));
 8009c3a:	687b      	ldr	r3, [r7, #4]
 8009c3c:	f503 73f8 	add.w	r3, r3, #496	@ 0x1f0
 8009c40:	21dc      	movs	r1, #220	@ 0xdc
 8009c42:	4618      	mov	r0, r3
 8009c44:	f7fe fef1 	bl	8008a2a <ForceZero>

#ifdef WOLFSSL_TLS13
    ForceZero(&ssl->clientSecret, sizeof(ssl->clientSecret));
 8009c48:	687b      	ldr	r3, [r7, #4]
 8009c4a:	3314      	adds	r3, #20
 8009c4c:	2130      	movs	r1, #48	@ 0x30
 8009c4e:	4618      	mov	r0, r3
 8009c50:	f7fe feeb 	bl	8008a2a <ForceZero>
    ForceZero(&ssl->serverSecret, sizeof(ssl->serverSecret));
 8009c54:	687b      	ldr	r3, [r7, #4]
 8009c56:	3344      	adds	r3, #68	@ 0x44
 8009c58:	2130      	movs	r1, #48	@ 0x30
 8009c5a:	4618      	mov	r0, r3
 8009c5c:	f7fe fee5 	bl	8008a2a <ForceZero>
    ForceZero(&ssl->serverFinished, TLS_FINISHED_SZ_MAX);
    ssl->serverFinished_len = 0;
    ssl->clientFinished_len = 0;
#endif
#ifndef NO_DH
    if (ssl->buffers.serverDH_Priv.buffer != NULL) {
 8009c60:	687b      	ldr	r3, [r7, #4]
 8009c62:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8009c66:	2b00      	cmp	r3, #0
 8009c68:	d009      	beq.n	8009c7e <wolfSSL_ResourceFree+0xce>
        ForceZero(ssl->buffers.serverDH_Priv.buffer,
 8009c6a:	687b      	ldr	r3, [r7, #4]
 8009c6c:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
 8009c70:	687b      	ldr	r3, [r7, #4]
 8009c72:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8009c76:	4619      	mov	r1, r3
 8009c78:	4610      	mov	r0, r2
 8009c7a:	f7fe fed6 	bl	8008a2a <ForceZero>
                                             ssl->buffers.serverDH_Priv.length);
    }
    XFREE(ssl->buffers.serverDH_Priv.buffer, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
 8009c7e:	687b      	ldr	r3, [r7, #4]
 8009c80:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8009c84:	61fb      	str	r3, [r7, #28]
 8009c86:	69fb      	ldr	r3, [r7, #28]
 8009c88:	2b00      	cmp	r3, #0
 8009c8a:	d002      	beq.n	8009c92 <wolfSSL_ResourceFree+0xe2>
 8009c8c:	69f8      	ldr	r0, [r7, #28]
 8009c8e:	f015 f811 	bl	801ecb4 <wolfSSL_Free>
    XFREE(ssl->buffers.serverDH_Pub.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8009c92:	687b      	ldr	r3, [r7, #4]
 8009c94:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
 8009c98:	61bb      	str	r3, [r7, #24]
 8009c9a:	69bb      	ldr	r3, [r7, #24]
 8009c9c:	2b00      	cmp	r3, #0
 8009c9e:	d002      	beq.n	8009ca6 <wolfSSL_ResourceFree+0xf6>
 8009ca0:	69b8      	ldr	r0, [r7, #24]
 8009ca2:	f015 f807 	bl	801ecb4 <wolfSSL_Free>
    /* parameters (p,g) may be owned by ctx */
    if (ssl->buffers.weOwnDH) {
 8009ca6:	687b      	ldr	r3, [r7, #4]
 8009ca8:	f893 3147 	ldrb.w	r3, [r3, #327]	@ 0x147
 8009cac:	2b00      	cmp	r3, #0
 8009cae:	d013      	beq.n	8009cd8 <wolfSSL_ResourceFree+0x128>
        XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8009cb0:	687b      	ldr	r3, [r7, #4]
 8009cb2:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8009cb6:	617b      	str	r3, [r7, #20]
 8009cb8:	697b      	ldr	r3, [r7, #20]
 8009cba:	2b00      	cmp	r3, #0
 8009cbc:	d002      	beq.n	8009cc4 <wolfSSL_ResourceFree+0x114>
 8009cbe:	6978      	ldr	r0, [r7, #20]
 8009cc0:	f014 fff8 	bl	801ecb4 <wolfSSL_Free>
        XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8009cc4:	687b      	ldr	r3, [r7, #4]
 8009cc6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8009cca:	613b      	str	r3, [r7, #16]
 8009ccc:	693b      	ldr	r3, [r7, #16]
 8009cce:	2b00      	cmp	r3, #0
 8009cd0:	d002      	beq.n	8009cd8 <wolfSSL_ResourceFree+0x128>
 8009cd2:	6938      	ldr	r0, [r7, #16]
 8009cd4:	f014 ffee 	bl	801ecb4 <wolfSSL_Free>
    }
#endif /* !NO_DH */
#ifndef NO_CERTS
    ssl->keepCert = 0; /* make sure certificate is free'd */
 8009cd8:	687b      	ldr	r3, [r7, #4]
 8009cda:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009cde:	2200      	movs	r2, #0
 8009ce0:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90
    wolfSSL_UnloadCertsKeys(ssl);
 8009ce4:	6878      	ldr	r0, [r7, #4]
 8009ce6:	f003 ff73 	bl	800dbd0 <wolfSSL_UnloadCertsKeys>
#endif
#ifndef NO_RSA
    FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);
 8009cea:	687b      	ldr	r3, [r7, #4]
 8009cec:	f503 7351 	add.w	r3, r3, #836	@ 0x344
 8009cf0:	461a      	mov	r2, r3
 8009cf2:	210a      	movs	r1, #10
 8009cf4:	6878      	ldr	r0, [r7, #4]
 8009cf6:	f7ff fe7a 	bl	80099ee <FreeKey>
    ssl->peerRsaKeyPresent = 0;
 8009cfa:	687b      	ldr	r3, [r7, #4]
 8009cfc:	2200      	movs	r2, #0
 8009cfe:	f883 2348 	strb.w	r2, [r3, #840]	@ 0x348
#if defined(WOLFSSL_RENESAS_TSIP_TLS) || defined(WOLFSSL_RENESAS_FSPSM_TLS)
    XFREE(ssl->peerSceTsipEncRsaKeyIndex, ssl->heap, DYNAMIC_TYPE_RSA);
    Renesas_cmn_Cleanup(ssl);
#endif
#ifndef NO_TLS
    if (ssl->buffers.inputBuffer.dynamicFlag)
 8009d02:	687b      	ldr	r3, [r7, #4]
 8009d04:	f893 30fc 	ldrb.w	r3, [r3, #252]	@ 0xfc
 8009d08:	2b00      	cmp	r3, #0
 8009d0a:	d003      	beq.n	8009d14 <wolfSSL_ResourceFree+0x164>
        ShrinkInputBuffer(ssl, FORCED_FREE);
 8009d0c:	2101      	movs	r1, #1
 8009d0e:	6878      	ldr	r0, [r7, #4]
 8009d10:	f000 f902 	bl	8009f18 <ShrinkInputBuffer>
    if (ssl->buffers.outputBuffer.dynamicFlag)
 8009d14:	687b      	ldr	r3, [r7, #4]
 8009d16:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
 8009d1a:	2b00      	cmp	r3, #0
 8009d1c:	d002      	beq.n	8009d24 <wolfSSL_ResourceFree+0x174>
        ShrinkOutputBuffer(ssl);
 8009d1e:	6878      	ldr	r0, [r7, #4]
 8009d20:	f000 f8d1 	bl	8009ec6 <ShrinkOutputBuffer>
#ifdef OPENSSL_EXTRA
#ifndef NO_BIO
    /* Don't free if there was/is a previous element in the chain.
     * This means that this BIO was part of a chain that will be
     * free'd separately. */
    if (ssl->biord != ssl->biowr)        /* only free write if different */
 8009d24:	687b      	ldr	r3, [r7, #4]
 8009d26:	f8d3 232c 	ldr.w	r2, [r3, #812]	@ 0x32c
 8009d2a:	687b      	ldr	r3, [r7, #4]
 8009d2c:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009d30:	429a      	cmp	r2, r3
 8009d32:	d010      	beq.n	8009d56 <wolfSSL_ResourceFree+0x1a6>
        if (ssl->biowr != NULL && ssl->biowr->prev == NULL)
 8009d34:	687b      	ldr	r3, [r7, #4]
 8009d36:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009d3a:	2b00      	cmp	r3, #0
 8009d3c:	d00b      	beq.n	8009d56 <wolfSSL_ResourceFree+0x1a6>
 8009d3e:	687b      	ldr	r3, [r7, #4]
 8009d40:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009d44:	689b      	ldr	r3, [r3, #8]
 8009d46:	2b00      	cmp	r3, #0
 8009d48:	d105      	bne.n	8009d56 <wolfSSL_ResourceFree+0x1a6>
            wolfSSL_BIO_free(ssl->biowr);
 8009d4a:	687b      	ldr	r3, [r7, #4]
 8009d4c:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009d50:	4618      	mov	r0, r3
 8009d52:	f004 fa61 	bl	800e218 <wolfSSL_BIO_free>
    if (ssl->biord != NULL && ssl->biord->prev == NULL)
 8009d56:	687b      	ldr	r3, [r7, #4]
 8009d58:	f8d3 332c 	ldr.w	r3, [r3, #812]	@ 0x32c
 8009d5c:	2b00      	cmp	r3, #0
 8009d5e:	d00b      	beq.n	8009d78 <wolfSSL_ResourceFree+0x1c8>
 8009d60:	687b      	ldr	r3, [r7, #4]
 8009d62:	f8d3 332c 	ldr.w	r3, [r3, #812]	@ 0x32c
 8009d66:	689b      	ldr	r3, [r3, #8]
 8009d68:	2b00      	cmp	r3, #0
 8009d6a:	d105      	bne.n	8009d78 <wolfSSL_ResourceFree+0x1c8>
        wolfSSL_BIO_free(ssl->biord);
 8009d6c:	687b      	ldr	r3, [r7, #4]
 8009d6e:	f8d3 332c 	ldr.w	r3, [r3, #812]	@ 0x32c
 8009d72:	4618      	mov	r0, r3
 8009d74:	f004 fa50 	bl	800e218 <wolfSSL_BIO_free>
    ssl->biowr = NULL;
 8009d78:	687b      	ldr	r3, [r7, #4]
 8009d7a:	2200      	movs	r2, #0
 8009d7c:	f8c3 2330 	str.w	r2, [r3, #816]	@ 0x330
    ssl->biord = NULL;
 8009d80:	687b      	ldr	r3, [r7, #4]
 8009d82:	2200      	movs	r2, #0
 8009d84:	f8c3 232c 	str.w	r2, [r3, #812]	@ 0x32c
#endif
#ifdef HAVE_LIBZ
    FreeStreams(ssl);
#endif
#ifdef HAVE_ECC
    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccKey);
 8009d88:	687b      	ldr	r3, [r7, #4]
 8009d8a:	f503 7367 	add.w	r3, r3, #924	@ 0x39c
 8009d8e:	461a      	mov	r2, r3
 8009d90:	2125      	movs	r1, #37	@ 0x25
 8009d92:	6878      	ldr	r0, [r7, #4]
 8009d94:	f7ff fe2b 	bl	80099ee <FreeKey>
    ssl->peerEccKeyPresent = 0;
 8009d98:	687b      	ldr	r3, [r7, #4]
 8009d9a:	2200      	movs	r2, #0
 8009d9c:	f883 2399 	strb.w	r2, [r3, #921]	@ 0x399
    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);
 8009da0:	687b      	ldr	r3, [r7, #4]
 8009da2:	f503 7368 	add.w	r3, r3, #928	@ 0x3a0
 8009da6:	461a      	mov	r2, r3
 8009da8:	2125      	movs	r1, #37	@ 0x25
 8009daa:	6878      	ldr	r0, [r7, #4]
 8009dac:	f7ff fe1f 	bl	80099ee <FreeKey>
    ssl->peerEccDsaKeyPresent = 0;
 8009db0:	687b      	ldr	r3, [r7, #4]
 8009db2:	2200      	movs	r2, #0
 8009db4:	f883 23a6 	strb.w	r2, [r3, #934]	@ 0x3a6
#endif
#if defined(HAVE_ECC) || defined(HAVE_CURVE25519) ||defined(HAVE_CURVE448)
    {
        int dtype = 0;
 8009db8:	2300      	movs	r3, #0
 8009dba:	60fb      	str	r3, [r7, #12]
    #ifdef HAVE_ECC
        dtype = DYNAMIC_TYPE_ECC;
 8009dbc:	2325      	movs	r3, #37	@ 0x25
 8009dbe:	60fb      	str	r3, [r7, #12]
           )
        {
            dtype = DYNAMIC_TYPE_CURVE448;
        }
    #endif /* HAVE_CURVE448 */
        FreeKey(ssl, dtype, (void**)&ssl->eccTempKey);
 8009dc0:	687b      	ldr	r3, [r7, #4]
 8009dc2:	f503 7365 	add.w	r3, r3, #916	@ 0x394
 8009dc6:	461a      	mov	r2, r3
 8009dc8:	68f9      	ldr	r1, [r7, #12]
 8009dca:	6878      	ldr	r0, [r7, #4]
 8009dcc:	f7ff fe0f 	bl	80099ee <FreeKey>
        ssl->eccTempKeyPresent = 0;
 8009dd0:	687b      	ldr	r3, [r7, #4]
 8009dd2:	2200      	movs	r2, #0
 8009dd4:	f883 2398 	strb.w	r2, [r3, #920]	@ 0x398
        XFREE(ssl->buffers.peerRsaKey.buffer, ssl->heap, DYNAMIC_TYPE_RSA);
    #endif /* NO_RSA */
#endif /* HAVE_PK_CALLBACKS */
#ifdef HAVE_TLS_EXTENSIONS
#if !defined(NO_TLS)
    TLSX_FreeAll(ssl->extensions, ssl->heap);
 8009dd8:	687b      	ldr	r3, [r7, #4]
 8009dda:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009dde:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 8009de2:	687b      	ldr	r3, [r7, #4]
 8009de4:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8009de8:	4619      	mov	r1, r3
 8009dea:	4610      	mov	r0, r2
 8009dec:	f005 fbc8 	bl	800f580 <TLSX_FreeAll>
#ifdef HAVE_NETX
    if (ssl->nxCtx.nxPacket)
        nx_packet_release(ssl->nxCtx.nxPacket);
#endif
#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
    if (ssl->x509_store_pt)
 8009df0:	687b      	ldr	r3, [r7, #4]
 8009df2:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 8009df6:	2b00      	cmp	r3, #0
 8009df8:	d005      	beq.n	8009e06 <wolfSSL_ResourceFree+0x256>
        wolfSSL_X509_STORE_free(ssl->x509_store_pt);
 8009dfa:	687b      	ldr	r3, [r7, #4]
 8009dfc:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 8009e00:	4618      	mov	r0, r3
 8009e02:	f005 fa0e 	bl	800f222 <wolfSSL_X509_STORE_free>
#endif
#ifdef KEEP_PEER_CERT
    FreeX509(&ssl->peerCert);
 8009e06:	687b      	ldr	r3, [r7, #4]
 8009e08:	f503 736f 	add.w	r3, r3, #956	@ 0x3bc
 8009e0c:	4618      	mov	r0, r3
 8009e0e:	f7ff fc7c 	bl	800970a <FreeX509>
#endif

    if (ssl->session != NULL)
 8009e12:	687b      	ldr	r3, [r7, #4]
 8009e14:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 8009e18:	2b00      	cmp	r3, #0
 8009e1a:	d008      	beq.n	8009e2e <wolfSSL_ResourceFree+0x27e>
        wolfSSL_FreeSession(ssl->ctx, ssl->session);
 8009e1c:	687b      	ldr	r3, [r7, #4]
 8009e1e:	681a      	ldr	r2, [r3, #0]
 8009e20:	687b      	ldr	r3, [r7, #4]
 8009e22:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 8009e26:	4619      	mov	r1, r3
 8009e28:	4610      	mov	r0, r2
 8009e2a:	f001 fdae 	bl	800b98a <wolfSSL_FreeSession>
    if (ssl->dupWrite) {
        FreeWriteDup(ssl);
    }
#endif
#ifdef OPENSSL_EXTRA
    XFREE(ssl->param, ssl->heap, DYNAMIC_TYPE_OPENSSL);
 8009e2e:	687b      	ldr	r3, [r7, #4]
 8009e30:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 8009e34:	60bb      	str	r3, [r7, #8]
 8009e36:	68bb      	ldr	r3, [r7, #8]
 8009e38:	2b00      	cmp	r3, #0
 8009e3a:	d002      	beq.n	8009e42 <wolfSSL_ResourceFree+0x292>
 8009e3c:	68b8      	ldr	r0, [r7, #8]
 8009e3e:	f014 ff39 	bl	801ecb4 <wolfSSL_Free>
    }
#endif /* WOLFSSL_STATIC_MEMORY */
#ifdef OPENSSL_EXTRA
    /* Enough to free stack structure since WOLFSSL_CIPHER
     * isn't allocated separately. */
    wolfSSL_sk_CIPHER_free(ssl->supportedCiphers);
 8009e42:	687b      	ldr	r3, [r7, #4]
 8009e44:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009e48:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009e4c:	4618      	mov	r0, r3
 8009e4e:	f003 ff99 	bl	800dd84 <wolfSSL_sk_CIPHER_free>
    wolfSSL_sk_X509_pop_free(ssl->peerCertChain, NULL);
 8009e52:	687b      	ldr	r3, [r7, #4]
 8009e54:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009e58:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8009e5c:	2100      	movs	r1, #0
 8009e5e:	4618      	mov	r0, r3
 8009e60:	f004 fb34 	bl	800e4cc <wolfSSL_sk_X509_pop_free>
    #ifdef KEEP_OUR_CERT
    wolfSSL_sk_X509_pop_free(ssl->ourCertChain, NULL);
    #endif
#endif
#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA) || defined(HAVE_LIGHTY)
    wolfSSL_sk_X509_NAME_pop_free(ssl->client_ca_names, NULL);
 8009e64:	687b      	ldr	r3, [r7, #4]
 8009e66:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009e6a:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8009e6e:	2100      	movs	r1, #0
 8009e70:	4618      	mov	r0, r3
 8009e72:	f004 ff37 	bl	800ece4 <wolfSSL_sk_X509_NAME_pop_free>
    ssl->client_ca_names = NULL;
 8009e76:	687b      	ldr	r3, [r7, #4]
 8009e78:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009e7c:	461a      	mov	r2, r3
 8009e7e:	2300      	movs	r3, #0
 8009e80:	f8c2 30ac 	str.w	r3, [r2, #172]	@ 0xac
    ssl->initial_ctx = NULL;
#endif
#ifdef WOLFSSL_DUAL_ALG_CERTS
    XFREE(ssl->peerSigSpec, ssl->heap, DYNAMIC_TYPE_TLSX);
#endif
}
 8009e84:	bf00      	nop
 8009e86:	3728      	adds	r7, #40	@ 0x28
 8009e88:	46bd      	mov	sp, r7
 8009e8a:	bd80      	pop	{r7, pc}

08009e8c <FreeSSL>:
}


/* heap argument is the heap hint used when creating SSL */
void FreeSSL(WOLFSSL* ssl, void* heap)
{
 8009e8c:	b580      	push	{r7, lr}
 8009e8e:	b084      	sub	sp, #16
 8009e90:	af00      	add	r7, sp, #0
 8009e92:	6078      	str	r0, [r7, #4]
 8009e94:	6039      	str	r1, [r7, #0]
    WOLFSSL_CTX* ctx = ssl->ctx;
 8009e96:	687b      	ldr	r3, [r7, #4]
 8009e98:	681b      	ldr	r3, [r3, #0]
 8009e9a:	60fb      	str	r3, [r7, #12]
    wolfSSL_ResourceFree(ssl);
 8009e9c:	6878      	ldr	r0, [r7, #4]
 8009e9e:	f7ff fe87 	bl	8009bb0 <wolfSSL_ResourceFree>
    XFREE(ssl, heap, DYNAMIC_TYPE_SSL);
 8009ea2:	687b      	ldr	r3, [r7, #4]
 8009ea4:	60bb      	str	r3, [r7, #8]
 8009ea6:	68bb      	ldr	r3, [r7, #8]
 8009ea8:	2b00      	cmp	r3, #0
 8009eaa:	d002      	beq.n	8009eb2 <FreeSSL+0x26>
 8009eac:	68b8      	ldr	r0, [r7, #8]
 8009eae:	f014 ff01 	bl	801ecb4 <wolfSSL_Free>
    if (ctx)
 8009eb2:	68fb      	ldr	r3, [r7, #12]
 8009eb4:	2b00      	cmp	r3, #0
 8009eb6:	d002      	beq.n	8009ebe <FreeSSL+0x32>
        FreeSSL_Ctx(ctx); /* will decrement and free underlying CTX if 0 */
 8009eb8:	68f8      	ldr	r0, [r7, #12]
 8009eba:	f7fe ffe3 	bl	8008e84 <FreeSSL_Ctx>
    (void)heap;
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(ssl, sizeof(*ssl));
#endif
}
 8009ebe:	bf00      	nop
 8009ec0:	3710      	adds	r7, #16
 8009ec2:	46bd      	mov	sp, r7
 8009ec4:	bd80      	pop	{r7, pc}

08009ec6 <ShrinkOutputBuffer>:
}


/* Switch dynamic output buffer back to static, buffer is assumed clear */
void ShrinkOutputBuffer(WOLFSSL* ssl)
{
 8009ec6:	b580      	push	{r7, lr}
 8009ec8:	b084      	sub	sp, #16
 8009eca:	af00      	add	r7, sp, #0
 8009ecc:	6078      	str	r0, [r7, #4]
    WOLFSSL_MSG("Shrinking output buffer");
    XFREE(ssl->buffers.outputBuffer.buffer - ssl->buffers.outputBuffer.offset,
 8009ece:	687b      	ldr	r3, [r7, #4]
 8009ed0:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8009ed4:	687b      	ldr	r3, [r7, #4]
 8009ed6:	f893 3119 	ldrb.w	r3, [r3, #281]	@ 0x119
 8009eda:	425b      	negs	r3, r3
 8009edc:	4413      	add	r3, r2
 8009ede:	60fb      	str	r3, [r7, #12]
 8009ee0:	68fb      	ldr	r3, [r7, #12]
 8009ee2:	2b00      	cmp	r3, #0
 8009ee4:	d002      	beq.n	8009eec <ShrinkOutputBuffer+0x26>
 8009ee6:	68f8      	ldr	r0, [r7, #12]
 8009ee8:	f014 fee4 	bl	801ecb4 <wolfSSL_Free>
          ssl->heap, DYNAMIC_TYPE_OUT_BUFFER);
    ssl->buffers.outputBuffer.buffer = ssl->buffers.outputBuffer.staticBuffer;
 8009eec:	687b      	ldr	r3, [r7, #4]
 8009eee:	f503 7280 	add.w	r2, r3, #256	@ 0x100
 8009ef2:	687b      	ldr	r3, [r7, #4]
 8009ef4:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    ssl->buffers.outputBuffer.bufferSize  = STATIC_BUFFER_LEN;
 8009ef8:	687b      	ldr	r3, [r7, #4]
 8009efa:	2205      	movs	r2, #5
 8009efc:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
    ssl->buffers.outputBuffer.dynamicFlag = 0;
 8009f00:	687b      	ldr	r3, [r7, #4]
 8009f02:	2200      	movs	r2, #0
 8009f04:	f883 2118 	strb.w	r2, [r3, #280]	@ 0x118
    ssl->buffers.outputBuffer.offset      = 0;
 8009f08:	687b      	ldr	r3, [r7, #4]
 8009f0a:	2200      	movs	r2, #0
 8009f0c:	f883 2119 	strb.w	r2, [r3, #281]	@ 0x119
    /* idx and length are assumed to be 0. */
}
 8009f10:	bf00      	nop
 8009f12:	3710      	adds	r7, #16
 8009f14:	46bd      	mov	sp, r7
 8009f16:	bd80      	pop	{r7, pc}

08009f18 <ShrinkInputBuffer>:
/* forced free means cleaning up */
/* Be *CAREFUL* where this function is called. ProcessReply relies on
 * inputBuffer.idx *NOT* changing inside the ProcessReply function. ProcessReply
 * calls ShrinkInputBuffer itself when it is safe to do so. Don't overuse it. */
void ShrinkInputBuffer(WOLFSSL* ssl, int forcedFree)
{
 8009f18:	b580      	push	{r7, lr}
 8009f1a:	b084      	sub	sp, #16
 8009f1c:	af00      	add	r7, sp, #0
 8009f1e:	6078      	str	r0, [r7, #4]
 8009f20:	6039      	str	r1, [r7, #0]
    int usedLength = (int)(ssl->buffers.inputBuffer.length -
 8009f22:	687b      	ldr	r3, [r7, #4]
 8009f24:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
                     ssl->buffers.inputBuffer.idx);
 8009f28:	687b      	ldr	r3, [r7, #4]
 8009f2a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
    int usedLength = (int)(ssl->buffers.inputBuffer.length -
 8009f2e:	1ad3      	subs	r3, r2, r3
 8009f30:	60fb      	str	r3, [r7, #12]
    if (!forcedFree && (usedLength > STATIC_BUFFER_LEN ||
 8009f32:	683b      	ldr	r3, [r7, #0]
 8009f34:	2b00      	cmp	r3, #0
 8009f36:	d107      	bne.n	8009f48 <ShrinkInputBuffer+0x30>
 8009f38:	68fb      	ldr	r3, [r7, #12]
 8009f3a:	2b05      	cmp	r3, #5
 8009f3c:	dc4c      	bgt.n	8009fd8 <ShrinkInputBuffer+0xc0>
            ssl->buffers.clearOutputBuffer.length > 0))
 8009f3e:	687b      	ldr	r3, [r7, #4]
 8009f40:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
    if (!forcedFree && (usedLength > STATIC_BUFFER_LEN ||
 8009f44:	2b00      	cmp	r3, #0
 8009f46:	d147      	bne.n	8009fd8 <ShrinkInputBuffer+0xc0>
        return;

    WOLFSSL_MSG("Shrinking input buffer");

    if (!forcedFree && usedLength > 0) {
 8009f48:	683b      	ldr	r3, [r7, #0]
 8009f4a:	2b00      	cmp	r3, #0
 8009f4c:	d110      	bne.n	8009f70 <ShrinkInputBuffer+0x58>
 8009f4e:	68fb      	ldr	r3, [r7, #12]
 8009f50:	2b00      	cmp	r3, #0
 8009f52:	dd0d      	ble.n	8009f70 <ShrinkInputBuffer+0x58>
        XMEMCPY(ssl->buffers.inputBuffer.staticBuffer,
 8009f54:	687b      	ldr	r3, [r7, #4]
 8009f56:	f103 00e4 	add.w	r0, r3, #228	@ 0xe4
 8009f5a:	687b      	ldr	r3, [r7, #4]
 8009f5c:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
 8009f60:	687b      	ldr	r3, [r7, #4]
 8009f62:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8009f66:	4413      	add	r3, r2
 8009f68:	68fa      	ldr	r2, [r7, #12]
 8009f6a:	4619      	mov	r1, r3
 8009f6c:	f01e ff0b 	bl	8028d86 <memcpy>
               ssl->buffers.inputBuffer.buffer + ssl->buffers.inputBuffer.idx,
               usedLength);
    }

    ForceZero(ssl->buffers.inputBuffer.buffer,
 8009f70:	687b      	ldr	r3, [r7, #4]
 8009f72:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
 8009f76:	687b      	ldr	r3, [r7, #4]
 8009f78:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8009f7c:	4619      	mov	r1, r3
 8009f7e:	4610      	mov	r0, r2
 8009f80:	f7fe fd53 	bl	8008a2a <ForceZero>
        ssl->buffers.inputBuffer.length);
    XFREE(ssl->buffers.inputBuffer.buffer - ssl->buffers.inputBuffer.offset,
 8009f84:	687b      	ldr	r3, [r7, #4]
 8009f86:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
 8009f8a:	687b      	ldr	r3, [r7, #4]
 8009f8c:	f893 30fd 	ldrb.w	r3, [r3, #253]	@ 0xfd
 8009f90:	425b      	negs	r3, r3
 8009f92:	4413      	add	r3, r2
 8009f94:	60bb      	str	r3, [r7, #8]
 8009f96:	68bb      	ldr	r3, [r7, #8]
 8009f98:	2b00      	cmp	r3, #0
 8009f9a:	d002      	beq.n	8009fa2 <ShrinkInputBuffer+0x8a>
 8009f9c:	68b8      	ldr	r0, [r7, #8]
 8009f9e:	f014 fe89 	bl	801ecb4 <wolfSSL_Free>
          ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
    ssl->buffers.inputBuffer.buffer = ssl->buffers.inputBuffer.staticBuffer;
 8009fa2:	687b      	ldr	r3, [r7, #4]
 8009fa4:	f103 02e4 	add.w	r2, r3, #228	@ 0xe4
 8009fa8:	687b      	ldr	r3, [r7, #4]
 8009faa:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
    ssl->buffers.inputBuffer.bufferSize  = STATIC_BUFFER_LEN;
 8009fae:	687b      	ldr	r3, [r7, #4]
 8009fb0:	2205      	movs	r2, #5
 8009fb2:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
    ssl->buffers.inputBuffer.dynamicFlag = 0;
 8009fb6:	687b      	ldr	r3, [r7, #4]
 8009fb8:	2200      	movs	r2, #0
 8009fba:	f883 20fc 	strb.w	r2, [r3, #252]	@ 0xfc
    ssl->buffers.inputBuffer.offset      = 0;
 8009fbe:	687b      	ldr	r3, [r7, #4]
 8009fc0:	2200      	movs	r2, #0
 8009fc2:	f883 20fd 	strb.w	r2, [r3, #253]	@ 0xfd
    ssl->buffers.inputBuffer.idx = 0;
 8009fc6:	687b      	ldr	r3, [r7, #4]
 8009fc8:	2200      	movs	r2, #0
 8009fca:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
    ssl->buffers.inputBuffer.length = (word32)usedLength;
 8009fce:	68fa      	ldr	r2, [r7, #12]
 8009fd0:	687b      	ldr	r3, [r7, #4]
 8009fd2:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
 8009fd6:	e000      	b.n	8009fda <ShrinkInputBuffer+0xc2>
        return;
 8009fd8:	bf00      	nop
}
 8009fda:	3710      	adds	r7, #16
 8009fdc:	46bd      	mov	sp, r7
 8009fde:	bd80      	pop	{r7, pc}

08009fe0 <MatchDomainName>:
   to left-most name component, compatible with RFC 2830 identity checking.

   return 1 on success */
int MatchDomainName(const char* pattern, int patternLen, const char* str,
                    word32 strLen, unsigned int flags)
{
 8009fe0:	b480      	push	{r7}
 8009fe2:	b089      	sub	sp, #36	@ 0x24
 8009fe4:	af00      	add	r7, sp, #0
 8009fe6:	60f8      	str	r0, [r7, #12]
 8009fe8:	60b9      	str	r1, [r7, #8]
 8009fea:	607a      	str	r2, [r7, #4]
 8009fec:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8009fee:	2300      	movs	r3, #0
 8009ff0:	61fb      	str	r3, [r7, #28]
    byte wildcardEligible = 1;
 8009ff2:	2301      	movs	r3, #1
 8009ff4:	76fb      	strb	r3, [r7, #27]
    byte leftWildcardOnly = flags & WOLFSSL_LEFT_MOST_WILDCARD_ONLY;
 8009ff6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009ff8:	b2db      	uxtb	r3, r3
 8009ffa:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8009ffe:	767b      	strb	r3, [r7, #25]

    if (pattern == NULL || str == NULL || patternLen <= 0 || strLen == 0)
 800a000:	68fb      	ldr	r3, [r7, #12]
 800a002:	2b00      	cmp	r3, #0
 800a004:	d009      	beq.n	800a01a <MatchDomainName+0x3a>
 800a006:	687b      	ldr	r3, [r7, #4]
 800a008:	2b00      	cmp	r3, #0
 800a00a:	d006      	beq.n	800a01a <MatchDomainName+0x3a>
 800a00c:	68bb      	ldr	r3, [r7, #8]
 800a00e:	2b00      	cmp	r3, #0
 800a010:	dd03      	ble.n	800a01a <MatchDomainName+0x3a>
 800a012:	683b      	ldr	r3, [r7, #0]
 800a014:	2b00      	cmp	r3, #0
 800a016:	f040 80b0 	bne.w	800a17a <MatchDomainName+0x19a>
        return 0;
 800a01a:	2300      	movs	r3, #0
 800a01c:	e0bc      	b.n	800a198 <MatchDomainName+0x1b8>

    while (patternLen > 0) {
        /* Get the next pattern char to evaluate */
        char p = (char)XTOLOWER((unsigned char)*pattern);
 800a01e:	68fb      	ldr	r3, [r7, #12]
 800a020:	781b      	ldrb	r3, [r3, #0]
 800a022:	763b      	strb	r3, [r7, #24]
 800a024:	7e3b      	ldrb	r3, [r7, #24]
 800a026:	3301      	adds	r3, #1
 800a028:	4a5e      	ldr	r2, [pc, #376]	@ (800a1a4 <MatchDomainName+0x1c4>)
 800a02a:	4413      	add	r3, r2
 800a02c:	781b      	ldrb	r3, [r3, #0]
 800a02e:	f003 0303 	and.w	r3, r3, #3
 800a032:	2b01      	cmp	r3, #1
 800a034:	d102      	bne.n	800a03c <MatchDomainName+0x5c>
 800a036:	7e3b      	ldrb	r3, [r7, #24]
 800a038:	3320      	adds	r3, #32
 800a03a:	e000      	b.n	800a03e <MatchDomainName+0x5e>
 800a03c:	7e3b      	ldrb	r3, [r7, #24]
 800a03e:	76bb      	strb	r3, [r7, #26]
        if (p == '\0')
 800a040:	7ebb      	ldrb	r3, [r7, #26]
 800a042:	2b00      	cmp	r3, #0
 800a044:	f000 809e 	beq.w	800a184 <MatchDomainName+0x1a4>
            break;

        pattern++;
 800a048:	68fb      	ldr	r3, [r7, #12]
 800a04a:	3301      	adds	r3, #1
 800a04c:	60fb      	str	r3, [r7, #12]

        if ((p == '*') && wildcardEligible) {
 800a04e:	7ebb      	ldrb	r3, [r7, #26]
 800a050:	2b2a      	cmp	r3, #42	@ 0x2a
 800a052:	d16b      	bne.n	800a12c <MatchDomainName+0x14c>
 800a054:	7efb      	ldrb	r3, [r7, #27]
 800a056:	2b00      	cmp	r3, #0
 800a058:	d068      	beq.n	800a12c <MatchDomainName+0x14c>
            char s;
            /* We will always match '*' */
            patternLen--;
 800a05a:	68bb      	ldr	r3, [r7, #8]
 800a05c:	3b01      	subs	r3, #1
 800a05e:	60bb      	str	r3, [r7, #8]

            /* Only single wildcard allowed with strict left only */
            if (leftWildcardOnly) {
 800a060:	7e7b      	ldrb	r3, [r7, #25]
 800a062:	2b00      	cmp	r3, #0
 800a064:	d02c      	beq.n	800a0c0 <MatchDomainName+0xe0>
                wildcardEligible = 0;
 800a066:	2300      	movs	r3, #0
 800a068:	76fb      	strb	r3, [r7, #27]
            }

            /* Consume any extra '*' chars until the next non '*' char. */
            while (patternLen > 0) {
 800a06a:	e029      	b.n	800a0c0 <MatchDomainName+0xe0>
                p = (char)XTOLOWER((unsigned char)*pattern);
 800a06c:	68fb      	ldr	r3, [r7, #12]
 800a06e:	781b      	ldrb	r3, [r3, #0]
 800a070:	75fb      	strb	r3, [r7, #23]
 800a072:	7dfb      	ldrb	r3, [r7, #23]
 800a074:	3301      	adds	r3, #1
 800a076:	4a4b      	ldr	r2, [pc, #300]	@ (800a1a4 <MatchDomainName+0x1c4>)
 800a078:	4413      	add	r3, r2
 800a07a:	781b      	ldrb	r3, [r3, #0]
 800a07c:	f003 0303 	and.w	r3, r3, #3
 800a080:	2b01      	cmp	r3, #1
 800a082:	d102      	bne.n	800a08a <MatchDomainName+0xaa>
 800a084:	7dfb      	ldrb	r3, [r7, #23]
 800a086:	3320      	adds	r3, #32
 800a088:	e000      	b.n	800a08c <MatchDomainName+0xac>
 800a08a:	7dfb      	ldrb	r3, [r7, #23]
 800a08c:	76bb      	strb	r3, [r7, #26]
                pattern++;
 800a08e:	68fb      	ldr	r3, [r7, #12]
 800a090:	3301      	adds	r3, #1
 800a092:	60fb      	str	r3, [r7, #12]
                if (p == '\0' && patternLen > 0)
 800a094:	7ebb      	ldrb	r3, [r7, #26]
 800a096:	2b00      	cmp	r3, #0
 800a098:	d104      	bne.n	800a0a4 <MatchDomainName+0xc4>
 800a09a:	68bb      	ldr	r3, [r7, #8]
 800a09c:	2b00      	cmp	r3, #0
 800a09e:	dd01      	ble.n	800a0a4 <MatchDomainName+0xc4>
                    return 0;
 800a0a0:	2300      	movs	r3, #0
 800a0a2:	e079      	b.n	800a198 <MatchDomainName+0x1b8>
                if (p != '*')
 800a0a4:	7ebb      	ldrb	r3, [r7, #26]
 800a0a6:	2b2a      	cmp	r3, #42	@ 0x2a
 800a0a8:	d10e      	bne.n	800a0c8 <MatchDomainName+0xe8>
                    break;
                if (leftWildcardOnly && (p == '*')) {
 800a0aa:	7e7b      	ldrb	r3, [r7, #25]
 800a0ac:	2b00      	cmp	r3, #0
 800a0ae:	d004      	beq.n	800a0ba <MatchDomainName+0xda>
 800a0b0:	7ebb      	ldrb	r3, [r7, #26]
 800a0b2:	2b2a      	cmp	r3, #42	@ 0x2a
 800a0b4:	d101      	bne.n	800a0ba <MatchDomainName+0xda>
                    /* RFC2830 only allows single left-most wildcard */
                    return 0;
 800a0b6:	2300      	movs	r3, #0
 800a0b8:	e06e      	b.n	800a198 <MatchDomainName+0x1b8>
                }

                patternLen--;
 800a0ba:	68bb      	ldr	r3, [r7, #8]
 800a0bc:	3b01      	subs	r3, #1
 800a0be:	60bb      	str	r3, [r7, #8]
            while (patternLen > 0) {
 800a0c0:	68bb      	ldr	r3, [r7, #8]
 800a0c2:	2b00      	cmp	r3, #0
 800a0c4:	dcd2      	bgt.n	800a06c <MatchDomainName+0x8c>
 800a0c6:	e02b      	b.n	800a120 <MatchDomainName+0x140>
                    break;
 800a0c8:	bf00      	nop
            }

            /* Consume str until we reach next char in pattern after '*' or
             * end of string */
            while (strLen > 0) {
 800a0ca:	e029      	b.n	800a120 <MatchDomainName+0x140>
                s = (char)XTOLOWER((unsigned char) *str);
 800a0cc:	687b      	ldr	r3, [r7, #4]
 800a0ce:	781b      	ldrb	r3, [r3, #0]
 800a0d0:	75bb      	strb	r3, [r7, #22]
 800a0d2:	7dbb      	ldrb	r3, [r7, #22]
 800a0d4:	3301      	adds	r3, #1
 800a0d6:	4a33      	ldr	r2, [pc, #204]	@ (800a1a4 <MatchDomainName+0x1c4>)
 800a0d8:	4413      	add	r3, r2
 800a0da:	781b      	ldrb	r3, [r3, #0]
 800a0dc:	f003 0303 	and.w	r3, r3, #3
 800a0e0:	2b01      	cmp	r3, #1
 800a0e2:	d102      	bne.n	800a0ea <MatchDomainName+0x10a>
 800a0e4:	7dbb      	ldrb	r3, [r7, #22]
 800a0e6:	3320      	adds	r3, #32
 800a0e8:	e000      	b.n	800a0ec <MatchDomainName+0x10c>
 800a0ea:	7dbb      	ldrb	r3, [r7, #22]
 800a0ec:	757b      	strb	r3, [r7, #21]
                str++;
 800a0ee:	687b      	ldr	r3, [r7, #4]
 800a0f0:	3301      	adds	r3, #1
 800a0f2:	607b      	str	r3, [r7, #4]
                strLen--;
 800a0f4:	683b      	ldr	r3, [r7, #0]
 800a0f6:	3b01      	subs	r3, #1
 800a0f8:	603b      	str	r3, [r7, #0]

                /* p is next char in pattern after '*', or '*' if '*' is the
                 * last char in the pattern (in which case patternLen is 1) */
                if ( ((s == p) && (patternLen > 0))) {
 800a0fa:	7d7a      	ldrb	r2, [r7, #21]
 800a0fc:	7ebb      	ldrb	r3, [r7, #26]
 800a0fe:	429a      	cmp	r2, r3
 800a100:	d106      	bne.n	800a110 <MatchDomainName+0x130>
 800a102:	68bb      	ldr	r3, [r7, #8]
 800a104:	2b00      	cmp	r3, #0
 800a106:	dd03      	ble.n	800a110 <MatchDomainName+0x130>
                    /* We had already counted the '*' as matched, this means
                     * we also matched the next non '*' char in pattern */
                    patternLen--;
 800a108:	68bb      	ldr	r3, [r7, #8]
 800a10a:	3b01      	subs	r3, #1
 800a10c:	60bb      	str	r3, [r7, #8]
                    break;
 800a10e:	e00c      	b.n	800a12a <MatchDomainName+0x14a>
                }

                /* If strlen is 0, we have consumed the entire string. Count that
                 * as a match of '*' */
                if (strLen == 0) {
 800a110:	683b      	ldr	r3, [r7, #0]
 800a112:	2b00      	cmp	r3, #0
 800a114:	d008      	beq.n	800a128 <MatchDomainName+0x148>
                    break;
                }

                if (s == '.')
 800a116:	7d7b      	ldrb	r3, [r7, #21]
 800a118:	2b2e      	cmp	r3, #46	@ 0x2e
 800a11a:	d101      	bne.n	800a120 <MatchDomainName+0x140>
                    return 0;
 800a11c:	2300      	movs	r3, #0
 800a11e:	e03b      	b.n	800a198 <MatchDomainName+0x1b8>
            while (strLen > 0) {
 800a120:	683b      	ldr	r3, [r7, #0]
 800a122:	2b00      	cmp	r3, #0
 800a124:	d1d2      	bne.n	800a0cc <MatchDomainName+0xec>
        if ((p == '*') && wildcardEligible) {
 800a126:	e028      	b.n	800a17a <MatchDomainName+0x19a>
                    break;
 800a128:	bf00      	nop
        if ((p == '*') && wildcardEligible) {
 800a12a:	e026      	b.n	800a17a <MatchDomainName+0x19a>
            }
        }
        else {
            /* Past left-most wildcard location, not eligible if flag set*/
            if (leftWildcardOnly && wildcardEligible) {
 800a12c:	7e7b      	ldrb	r3, [r7, #25]
 800a12e:	2b00      	cmp	r3, #0
 800a130:	d004      	beq.n	800a13c <MatchDomainName+0x15c>
 800a132:	7efb      	ldrb	r3, [r7, #27]
 800a134:	2b00      	cmp	r3, #0
 800a136:	d001      	beq.n	800a13c <MatchDomainName+0x15c>
                wildcardEligible = 0;
 800a138:	2300      	movs	r3, #0
 800a13a:	76fb      	strb	r3, [r7, #27]
            }

            /* Simple case, pattern match exactly */
            if (p != (char)XTOLOWER((unsigned char) *str))
 800a13c:	687b      	ldr	r3, [r7, #4]
 800a13e:	781b      	ldrb	r3, [r3, #0]
 800a140:	753b      	strb	r3, [r7, #20]
 800a142:	7d3b      	ldrb	r3, [r7, #20]
 800a144:	3301      	adds	r3, #1
 800a146:	4a17      	ldr	r2, [pc, #92]	@ (800a1a4 <MatchDomainName+0x1c4>)
 800a148:	4413      	add	r3, r2
 800a14a:	781b      	ldrb	r3, [r3, #0]
 800a14c:	f003 0303 	and.w	r3, r3, #3
 800a150:	2b01      	cmp	r3, #1
 800a152:	d102      	bne.n	800a15a <MatchDomainName+0x17a>
 800a154:	7d3b      	ldrb	r3, [r7, #20]
 800a156:	3320      	adds	r3, #32
 800a158:	e000      	b.n	800a15c <MatchDomainName+0x17c>
 800a15a:	7d3b      	ldrb	r3, [r7, #20]
 800a15c:	b2db      	uxtb	r3, r3
 800a15e:	7eba      	ldrb	r2, [r7, #26]
 800a160:	429a      	cmp	r2, r3
 800a162:	d001      	beq.n	800a168 <MatchDomainName+0x188>
                return 0;
 800a164:	2300      	movs	r3, #0
 800a166:	e017      	b.n	800a198 <MatchDomainName+0x1b8>

            str++;
 800a168:	687b      	ldr	r3, [r7, #4]
 800a16a:	3301      	adds	r3, #1
 800a16c:	607b      	str	r3, [r7, #4]
            strLen--;
 800a16e:	683b      	ldr	r3, [r7, #0]
 800a170:	3b01      	subs	r3, #1
 800a172:	603b      	str	r3, [r7, #0]
            patternLen--;
 800a174:	68bb      	ldr	r3, [r7, #8]
 800a176:	3b01      	subs	r3, #1
 800a178:	60bb      	str	r3, [r7, #8]
    while (patternLen > 0) {
 800a17a:	68bb      	ldr	r3, [r7, #8]
 800a17c:	2b00      	cmp	r3, #0
 800a17e:	f73f af4e 	bgt.w	800a01e <MatchDomainName+0x3e>
 800a182:	e000      	b.n	800a186 <MatchDomainName+0x1a6>
            break;
 800a184:	bf00      	nop
        }
    }

    if (strLen == 0 && patternLen == 0) {
 800a186:	683b      	ldr	r3, [r7, #0]
 800a188:	2b00      	cmp	r3, #0
 800a18a:	d104      	bne.n	800a196 <MatchDomainName+0x1b6>
 800a18c:	68bb      	ldr	r3, [r7, #8]
 800a18e:	2b00      	cmp	r3, #0
 800a190:	d101      	bne.n	800a196 <MatchDomainName+0x1b6>
        ret = 1; /* success */
 800a192:	2301      	movs	r3, #1
 800a194:	61fb      	str	r3, [r7, #28]
    }

    return ret;
 800a196:	69fb      	ldr	r3, [r7, #28]
}
 800a198:	4618      	mov	r0, r3
 800a19a:	3724      	adds	r7, #36	@ 0x24
 800a19c:	46bd      	mov	sp, r7
 800a19e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a1a2:	4770      	bx	lr
 800a1a4:	08034bf8 	.word	0x08034bf8

0800a1a8 <CheckForAltNames>:
 *           0 : no match found.
 *          -1 : No matches and wild pattern match failed.
 */
int CheckForAltNames(DecodedCert* dCert, const char* domain, word32 domainLen,
                     int* checkCN, unsigned int flags)
{
 800a1a8:	b580      	push	{r7, lr}
 800a1aa:	b08a      	sub	sp, #40	@ 0x28
 800a1ac:	af02      	add	r7, sp, #8
 800a1ae:	60f8      	str	r0, [r7, #12]
 800a1b0:	60b9      	str	r1, [r7, #8]
 800a1b2:	607a      	str	r2, [r7, #4]
 800a1b4:	603b      	str	r3, [r7, #0]
    int match = 0;
 800a1b6:	2300      	movs	r3, #0
 800a1b8:	61fb      	str	r3, [r7, #28]
    DNS_entry* altName = NULL;
 800a1ba:	2300      	movs	r3, #0
 800a1bc:	61bb      	str	r3, [r7, #24]
    char *buf;
    word32 len;

    WOLFSSL_MSG("Checking AltNames");

    if (dCert)
 800a1be:	68fb      	ldr	r3, [r7, #12]
 800a1c0:	2b00      	cmp	r3, #0
 800a1c2:	d002      	beq.n	800a1ca <CheckForAltNames+0x22>
        altName = dCert->altNames;
 800a1c4:	68fb      	ldr	r3, [r7, #12]
 800a1c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a1c8:	61bb      	str	r3, [r7, #24]

    if (checkCN != NULL) {
 800a1ca:	683b      	ldr	r3, [r7, #0]
 800a1cc:	2b00      	cmp	r3, #0
 800a1ce:	d033      	beq.n	800a238 <CheckForAltNames+0x90>
        *checkCN = (altName == NULL) ? 1 : 0;
 800a1d0:	69bb      	ldr	r3, [r7, #24]
 800a1d2:	2b00      	cmp	r3, #0
 800a1d4:	bf0c      	ite	eq
 800a1d6:	2301      	moveq	r3, #1
 800a1d8:	2300      	movne	r3, #0
 800a1da:	b2db      	uxtb	r3, r3
 800a1dc:	461a      	mov	r2, r3
 800a1de:	683b      	ldr	r3, [r7, #0]
 800a1e0:	601a      	str	r2, [r3, #0]
    }

    while (altName) {
 800a1e2:	e029      	b.n	800a238 <CheckForAltNames+0x90>
            len = (word32)XSTRLEN(buf);
        }
        else
#endif /* WOLFSSL_IP_ALT_NAME */
        {
            buf = altName->name;
 800a1e4:	69bb      	ldr	r3, [r7, #24]
 800a1e6:	68db      	ldr	r3, [r3, #12]
 800a1e8:	617b      	str	r3, [r7, #20]
            len = (word32)altName->len;
 800a1ea:	69bb      	ldr	r3, [r7, #24]
 800a1ec:	689b      	ldr	r3, [r3, #8]
 800a1ee:	613b      	str	r3, [r7, #16]
        }

        if (MatchDomainName(buf, (int)len, domain, domainLen, flags)) {
 800a1f0:	6939      	ldr	r1, [r7, #16]
 800a1f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a1f4:	9300      	str	r3, [sp, #0]
 800a1f6:	687b      	ldr	r3, [r7, #4]
 800a1f8:	68ba      	ldr	r2, [r7, #8]
 800a1fa:	6978      	ldr	r0, [r7, #20]
 800a1fc:	f7ff fef0 	bl	8009fe0 <MatchDomainName>
 800a200:	4603      	mov	r3, r0
 800a202:	2b00      	cmp	r3, #0
 800a204:	d008      	beq.n	800a218 <CheckForAltNames+0x70>
            match = 1;
 800a206:	2301      	movs	r3, #1
 800a208:	61fb      	str	r3, [r7, #28]
            if (checkCN != NULL) {
 800a20a:	683b      	ldr	r3, [r7, #0]
 800a20c:	2b00      	cmp	r3, #0
 800a20e:	d017      	beq.n	800a240 <CheckForAltNames+0x98>
                *checkCN = 0;
 800a210:	683b      	ldr	r3, [r7, #0]
 800a212:	2200      	movs	r2, #0
 800a214:	601a      	str	r2, [r3, #0]
            }
            WOLFSSL_MSG("\tmatch found");
            break;
 800a216:	e013      	b.n	800a240 <CheckForAltNames+0x98>
        }
        /* No matches and wild pattern match failed. */
        else if (buf && (len >=1) && (buf[0] == '*')) {
 800a218:	697b      	ldr	r3, [r7, #20]
 800a21a:	2b00      	cmp	r3, #0
 800a21c:	d009      	beq.n	800a232 <CheckForAltNames+0x8a>
 800a21e:	693b      	ldr	r3, [r7, #16]
 800a220:	2b00      	cmp	r3, #0
 800a222:	d006      	beq.n	800a232 <CheckForAltNames+0x8a>
 800a224:	697b      	ldr	r3, [r7, #20]
 800a226:	781b      	ldrb	r3, [r3, #0]
 800a228:	2b2a      	cmp	r3, #42	@ 0x2a
 800a22a:	d102      	bne.n	800a232 <CheckForAltNames+0x8a>
            match = -1;
 800a22c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a230:	61fb      	str	r3, [r7, #28]
            WOLFSSL_MSG("\twildcard match failed");
        }

        altName = altName->next;
 800a232:	69bb      	ldr	r3, [r7, #24]
 800a234:	681b      	ldr	r3, [r3, #0]
 800a236:	61bb      	str	r3, [r7, #24]
    while (altName) {
 800a238:	69bb      	ldr	r3, [r7, #24]
 800a23a:	2b00      	cmp	r3, #0
 800a23c:	d1d2      	bne.n	800a1e4 <CheckForAltNames+0x3c>
 800a23e:	e000      	b.n	800a242 <CheckForAltNames+0x9a>
            break;
 800a240:	bf00      	nop
    }

    return match;
 800a242:	69fb      	ldr	r3, [r7, #28]
}
 800a244:	4618      	mov	r0, r3
 800a246:	3720      	adds	r7, #32
 800a248:	46bd      	mov	sp, r7
 800a24a:	bd80      	pop	{r7, pc}

0800a24c <CheckHostName>:
 * domainNameLen  The length of the domain name.
 * returns DOMAIN_NAME_MISMATCH when no match found and 0 on success.
 */
int CheckHostName(DecodedCert* dCert, const char *domainName,
                  size_t domainNameLen, unsigned int flags)
{
 800a24c:	b580      	push	{r7, lr}
 800a24e:	b088      	sub	sp, #32
 800a250:	af02      	add	r7, sp, #8
 800a252:	60f8      	str	r0, [r7, #12]
 800a254:	60b9      	str	r1, [r7, #8]
 800a256:	607a      	str	r2, [r7, #4]
 800a258:	603b      	str	r3, [r7, #0]
    int checkCN;
    int ret = WC_NO_ERR_TRACE(DOMAIN_NAME_MISMATCH);
 800a25a:	4b18      	ldr	r3, [pc, #96]	@ (800a2bc <CheckHostName+0x70>)
 800a25c:	617b      	str	r3, [r7, #20]

    if (CheckForAltNames(dCert, domainName, (word32)domainNameLen,
 800a25e:	f107 0210 	add.w	r2, r7, #16
 800a262:	683b      	ldr	r3, [r7, #0]
 800a264:	9300      	str	r3, [sp, #0]
 800a266:	4613      	mov	r3, r2
 800a268:	687a      	ldr	r2, [r7, #4]
 800a26a:	68b9      	ldr	r1, [r7, #8]
 800a26c:	68f8      	ldr	r0, [r7, #12]
 800a26e:	f7ff ff9b 	bl	800a1a8 <CheckForAltNames>
 800a272:	4603      	mov	r3, r0
 800a274:	2b01      	cmp	r3, #1
 800a276:	d002      	beq.n	800a27e <CheckHostName+0x32>
                                            &checkCN, flags) != 1) {
        ret = DOMAIN_NAME_MISMATCH;
 800a278:	4b10      	ldr	r3, [pc, #64]	@ (800a2bc <CheckHostName+0x70>)
 800a27a:	617b      	str	r3, [r7, #20]
 800a27c:	e001      	b.n	800a282 <CheckHostName+0x36>
        WOLFSSL_MSG("DomainName match on alt names failed");
    }
    else {
        ret = 0;
 800a27e:	2300      	movs	r3, #0
 800a280:	617b      	str	r3, [r7, #20]
    }

#ifndef WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY
    if (checkCN == 1) {
 800a282:	693b      	ldr	r3, [r7, #16]
 800a284:	2b01      	cmp	r3, #1
 800a286:	d113      	bne.n	800a2b0 <CheckHostName+0x64>
        if (MatchDomainName(dCert->subjectCN, dCert->subjectCNLen,
 800a288:	68fb      	ldr	r3, [r7, #12]
 800a28a:	f8d3 0084 	ldr.w	r0, [r3, #132]	@ 0x84
 800a28e:	68fb      	ldr	r3, [r7, #12]
 800a290:	f8d3 1088 	ldr.w	r1, [r3, #136]	@ 0x88
 800a294:	683b      	ldr	r3, [r7, #0]
 800a296:	9300      	str	r3, [sp, #0]
 800a298:	687b      	ldr	r3, [r7, #4]
 800a29a:	68ba      	ldr	r2, [r7, #8]
 800a29c:	f7ff fea0 	bl	8009fe0 <MatchDomainName>
 800a2a0:	4603      	mov	r3, r0
 800a2a2:	2b01      	cmp	r3, #1
 800a2a4:	d102      	bne.n	800a2ac <CheckHostName+0x60>
                            domainName, (word32)domainNameLen, flags) == 1) {
            ret = 0;
 800a2a6:	2300      	movs	r3, #0
 800a2a8:	617b      	str	r3, [r7, #20]
 800a2aa:	e001      	b.n	800a2b0 <CheckHostName+0x64>
        }
        else {
            ret = DOMAIN_NAME_MISMATCH;
 800a2ac:	4b03      	ldr	r3, [pc, #12]	@ (800a2bc <CheckHostName+0x70>)
 800a2ae:	617b      	str	r3, [r7, #20]
            WOLFSSL_MSG("DomainName match on common name failed");
        }
    }
#endif /* !WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY */

    return ret;
 800a2b0:	697b      	ldr	r3, [r7, #20]
}
 800a2b2:	4618      	mov	r0, r3
 800a2b4:	3718      	adds	r7, #24
 800a2b6:	46bd      	mov	sp, r7
 800a2b8:	bd80      	pop	{r7, pc}
 800a2ba:	bf00      	nop
 800a2bc:	fffffebe 	.word	0xfffffebe

0800a2c0 <CheckIPAddr>:

int CheckIPAddr(DecodedCert* dCert, const char* ipasc)
{
 800a2c0:	b580      	push	{r7, lr}
 800a2c2:	b082      	sub	sp, #8
 800a2c4:	af00      	add	r7, sp, #0
 800a2c6:	6078      	str	r0, [r7, #4]
 800a2c8:	6039      	str	r1, [r7, #0]
    WOLFSSL_MSG("Checking IPAddr");

    return CheckHostName(dCert, ipasc, (size_t)XSTRLEN(ipasc), 0);
 800a2ca:	6838      	ldr	r0, [r7, #0]
 800a2cc:	f7f5 ff8a 	bl	80001e4 <strlen>
 800a2d0:	4602      	mov	r2, r0
 800a2d2:	2300      	movs	r3, #0
 800a2d4:	6839      	ldr	r1, [r7, #0]
 800a2d6:	6878      	ldr	r0, [r7, #4]
 800a2d8:	f7ff ffb8 	bl	800a24c <CheckHostName>
 800a2dc:	4603      	mov	r3, r0
}
 800a2de:	4618      	mov	r0, r3
 800a2e0:	3708      	adds	r7, #8
 800a2e2:	46bd      	mov	sp, r7
 800a2e4:	bd80      	pop	{r7, pc}

0800a2e6 <CopyAltNames>:

#if defined(KEEP_PEER_CERT) || defined(SESSION_CERTS) || \
    defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL) || \
    defined(WOLFSSL_ACERT)
    static int CopyAltNames(DNS_entry** to, DNS_entry* from, int type, void* heap)
{
 800a2e6:	b580      	push	{r7, lr}
 800a2e8:	b088      	sub	sp, #32
 800a2ea:	af00      	add	r7, sp, #0
 800a2ec:	60f8      	str	r0, [r7, #12]
 800a2ee:	60b9      	str	r1, [r7, #8]
 800a2f0:	607a      	str	r2, [r7, #4]
 800a2f2:	603b      	str	r3, [r7, #0]
    /* Copy from to the beginning of to */
    DNS_entry** prev_next = to;
 800a2f4:	68fb      	ldr	r3, [r7, #12]
 800a2f6:	61fb      	str	r3, [r7, #28]
    DNS_entry* next;

    if (to == NULL) {
 800a2f8:	68fb      	ldr	r3, [r7, #12]
 800a2fa:	2b00      	cmp	r3, #0
 800a2fc:	d102      	bne.n	800a304 <CopyAltNames+0x1e>
        return BAD_FUNC_ARG;
 800a2fe:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800a302:	e028      	b.n	800a356 <CopyAltNames+0x70>
    }

    next = *to;
 800a304:	68fb      	ldr	r3, [r7, #12]
 800a306:	681b      	ldr	r3, [r3, #0]
 800a308:	61bb      	str	r3, [r7, #24]

    for (; from != NULL; from = from->next) {
 800a30a:	e020      	b.n	800a34e <CopyAltNames+0x68>
        DNS_entry* dnsEntry;

        if (type != -1 && from->type != type)
 800a30c:	687b      	ldr	r3, [r7, #4]
 800a30e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 800a312:	d004      	beq.n	800a31e <CopyAltNames+0x38>
 800a314:	68bb      	ldr	r3, [r7, #8]
 800a316:	685b      	ldr	r3, [r3, #4]
 800a318:	687a      	ldr	r2, [r7, #4]
 800a31a:	429a      	cmp	r2, r3
 800a31c:	d113      	bne.n	800a346 <CopyAltNames+0x60>
            continue;

        dnsEntry = AltNameDup(from, heap);
 800a31e:	6839      	ldr	r1, [r7, #0]
 800a320:	68b8      	ldr	r0, [r7, #8]
 800a322:	f00b f81b 	bl	801535c <AltNameDup>
 800a326:	6178      	str	r0, [r7, #20]
        if (dnsEntry == NULL) {
 800a328:	697b      	ldr	r3, [r7, #20]
 800a32a:	2b00      	cmp	r3, #0
 800a32c:	d102      	bne.n	800a334 <CopyAltNames+0x4e>
            WOLFSSL_MSG("\tOut of Memory");
            return MEMORY_E;
 800a32e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a332:	e010      	b.n	800a356 <CopyAltNames+0x70>
        }

        dnsEntry->next = next;
 800a334:	697b      	ldr	r3, [r7, #20]
 800a336:	69ba      	ldr	r2, [r7, #24]
 800a338:	601a      	str	r2, [r3, #0]
        *prev_next = dnsEntry;
 800a33a:	69fb      	ldr	r3, [r7, #28]
 800a33c:	697a      	ldr	r2, [r7, #20]
 800a33e:	601a      	str	r2, [r3, #0]
        prev_next = &dnsEntry->next;
 800a340:	697b      	ldr	r3, [r7, #20]
 800a342:	61fb      	str	r3, [r7, #28]
 800a344:	e000      	b.n	800a348 <CopyAltNames+0x62>
            continue;
 800a346:	bf00      	nop
    for (; from != NULL; from = from->next) {
 800a348:	68bb      	ldr	r3, [r7, #8]
 800a34a:	681b      	ldr	r3, [r3, #0]
 800a34c:	60bb      	str	r3, [r7, #8]
 800a34e:	68bb      	ldr	r3, [r7, #8]
 800a350:	2b00      	cmp	r3, #0
 800a352:	d1db      	bne.n	800a30c <CopyAltNames+0x26>
    }

    return 0;
 800a354:	2300      	movs	r3, #0
}
 800a356:	4618      	mov	r0, r3
 800a358:	3720      	adds	r7, #32
 800a35a:	46bd      	mov	sp, r7
 800a35c:	bd80      	pop	{r7, pc}

0800a35e <CopyDecodedName>:


#if defined(KEEP_PEER_CERT) || defined(SESSION_CERTS) || \
    defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
void CopyDecodedName(WOLFSSL_X509_NAME* name, DecodedCert* dCert, int nameType)
{
 800a35e:	b580      	push	{r7, lr}
 800a360:	b086      	sub	sp, #24
 800a362:	af00      	add	r7, sp, #0
 800a364:	60f8      	str	r0, [r7, #12]
 800a366:	60b9      	str	r1, [r7, #8]
 800a368:	607a      	str	r2, [r7, #4]
    if (name->dynamicName) {
 800a36a:	68fb      	ldr	r3, [r7, #12]
 800a36c:	685b      	ldr	r3, [r3, #4]
 800a36e:	2b00      	cmp	r3, #0
 800a370:	d010      	beq.n	800a394 <CopyDecodedName+0x36>
        XFREE(name->name, name->heap, DYNAMIC_TYPE_X509);
 800a372:	68fb      	ldr	r3, [r7, #12]
 800a374:	681b      	ldr	r3, [r3, #0]
 800a376:	617b      	str	r3, [r7, #20]
 800a378:	697b      	ldr	r3, [r7, #20]
 800a37a:	2b00      	cmp	r3, #0
 800a37c:	d002      	beq.n	800a384 <CopyDecodedName+0x26>
 800a37e:	6978      	ldr	r0, [r7, #20]
 800a380:	f014 fc98 	bl	801ecb4 <wolfSSL_Free>
        name->name = name->staticName;
 800a384:	68fb      	ldr	r3, [r7, #12]
 800a386:	f103 020c 	add.w	r2, r3, #12
 800a38a:	68fb      	ldr	r3, [r7, #12]
 800a38c:	601a      	str	r2, [r3, #0]
        name->dynamicName = 0;
 800a38e:	68fb      	ldr	r3, [r7, #12]
 800a390:	2200      	movs	r2, #0
 800a392:	605a      	str	r2, [r3, #4]
    }

    if (nameType == ASN_SUBJECT) {
 800a394:	687b      	ldr	r3, [r7, #4]
 800a396:	2b01      	cmp	r3, #1
 800a398:	d119      	bne.n	800a3ce <CopyDecodedName+0x70>
        XSTRNCPY(name->name, dCert->subject, ASN_NAME_MAX);
 800a39a:	68fb      	ldr	r3, [r7, #12]
 800a39c:	6818      	ldr	r0, [r3, #0]
 800a39e:	68bb      	ldr	r3, [r7, #8]
 800a3a0:	f203 13f5 	addw	r3, r3, #501	@ 0x1f5
 800a3a4:	f44f 72b4 	mov.w	r2, #360	@ 0x168
 800a3a8:	4619      	mov	r1, r3
 800a3aa:	f01e fc55 	bl	8028c58 <strncpy>
        name->name[ASN_NAME_MAX - 1] = '\0';
 800a3ae:	68fb      	ldr	r3, [r7, #12]
 800a3b0:	681b      	ldr	r3, [r3, #0]
 800a3b2:	f203 1367 	addw	r3, r3, #359	@ 0x167
 800a3b6:	2200      	movs	r2, #0
 800a3b8:	701a      	strb	r2, [r3, #0]
        name->sz = (int)XSTRLEN(name->name) + 1;
 800a3ba:	68fb      	ldr	r3, [r7, #12]
 800a3bc:	681b      	ldr	r3, [r3, #0]
 800a3be:	4618      	mov	r0, r3
 800a3c0:	f7f5 ff10 	bl	80001e4 <strlen>
 800a3c4:	4603      	mov	r3, r0
 800a3c6:	1c5a      	adds	r2, r3, #1
 800a3c8:	68fb      	ldr	r3, [r7, #12]
 800a3ca:	609a      	str	r2, [r3, #8]
        if (name->rawLen > 0) {
            XMEMCPY(name->raw, dCert->issuerRaw, name->rawLen);
        }
#endif
    }
}
 800a3cc:	e017      	b.n	800a3fe <CopyDecodedName+0xa0>
        XSTRNCPY(name->name, dCert->issuer, ASN_NAME_MAX);
 800a3ce:	68fb      	ldr	r3, [r7, #12]
 800a3d0:	6818      	ldr	r0, [r3, #0]
 800a3d2:	68bb      	ldr	r3, [r7, #8]
 800a3d4:	338d      	adds	r3, #141	@ 0x8d
 800a3d6:	f44f 72b4 	mov.w	r2, #360	@ 0x168
 800a3da:	4619      	mov	r1, r3
 800a3dc:	f01e fc3c 	bl	8028c58 <strncpy>
        name->name[ASN_NAME_MAX - 1] = '\0';
 800a3e0:	68fb      	ldr	r3, [r7, #12]
 800a3e2:	681b      	ldr	r3, [r3, #0]
 800a3e4:	f203 1367 	addw	r3, r3, #359	@ 0x167
 800a3e8:	2200      	movs	r2, #0
 800a3ea:	701a      	strb	r2, [r3, #0]
        name->sz = (int)XSTRLEN(name->name) + 1;
 800a3ec:	68fb      	ldr	r3, [r7, #12]
 800a3ee:	681b      	ldr	r3, [r3, #0]
 800a3f0:	4618      	mov	r0, r3
 800a3f2:	f7f5 fef7 	bl	80001e4 <strlen>
 800a3f6:	4603      	mov	r3, r0
 800a3f8:	1c5a      	adds	r2, r3, #1
 800a3fa:	68fb      	ldr	r3, [r7, #12]
 800a3fc:	609a      	str	r2, [r3, #8]
}
 800a3fe:	bf00      	nop
 800a400:	3718      	adds	r7, #24
 800a402:	46bd      	mov	sp, r7
 800a404:	bd80      	pop	{r7, pc}

0800a406 <CopyDecodedToX509>:
}
#endif /* WOLFSSL_CERT_REQ */

/* Copy parts X509 needs from Decoded cert, 0 on success */
int CopyDecodedToX509(WOLFSSL_X509* x509, DecodedCert* dCert)
{
 800a406:	b580      	push	{r7, lr}
 800a408:	b084      	sub	sp, #16
 800a40a:	af00      	add	r7, sp, #0
 800a40c:	6078      	str	r0, [r7, #4]
 800a40e:	6039      	str	r1, [r7, #0]
    int ret = 0;
 800a410:	2300      	movs	r3, #0
 800a412:	60fb      	str	r3, [r7, #12]
    int minSz;

    if (x509 == NULL || dCert == NULL ||
 800a414:	687b      	ldr	r3, [r7, #4]
 800a416:	2b00      	cmp	r3, #0
 800a418:	d007      	beq.n	800a42a <CopyDecodedToX509+0x24>
 800a41a:	683b      	ldr	r3, [r7, #0]
 800a41c:	2b00      	cmp	r3, #0
 800a41e:	d004      	beq.n	800a42a <CopyDecodedToX509+0x24>
        dCert->subjectCNLen < 0)
 800a420:	683b      	ldr	r3, [r7, #0]
 800a422:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
    if (x509 == NULL || dCert == NULL ||
 800a426:	2b00      	cmp	r3, #0
 800a428:	da03      	bge.n	800a432 <CopyDecodedToX509+0x2c>
        return BAD_FUNC_ARG;
 800a42a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800a42e:	f000 bc03 	b.w	800ac38 <CopyDecodedToX509+0x832>

    if (x509->issuer.name == NULL || x509->subject.name == NULL) {
 800a432:	687b      	ldr	r3, [r7, #4]
 800a434:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
 800a438:	2b00      	cmp	r3, #0
 800a43a:	d004      	beq.n	800a446 <CopyDecodedToX509+0x40>
 800a43c:	687b      	ldr	r3, [r7, #4]
 800a43e:	f8d3 3788 	ldr.w	r3, [r3, #1928]	@ 0x788
 800a442:	2b00      	cmp	r3, #0
 800a444:	d102      	bne.n	800a44c <CopyDecodedToX509+0x46>
        WOLFSSL_MSG("Either init was not called on X509 or programming error");
        WOLFSSL_ERROR_VERBOSE(BAD_FUNC_ARG);
        return BAD_FUNC_ARG;
 800a446:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800a44a:	e3f5      	b.n	800ac38 <CopyDecodedToX509+0x832>
    }

    x509->version = dCert->version + 1;
 800a44c:	683b      	ldr	r3, [r7, #0]
 800a44e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a450:	1c5a      	adds	r2, r3, #1
 800a452:	687b      	ldr	r3, [r7, #4]
 800a454:	601a      	str	r2, [r3, #0]

    CopyDecodedName(&x509->issuer, dCert, ASN_ISSUER);
 800a456:	687b      	ldr	r3, [r7, #4]
 800a458:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800a45c:	2200      	movs	r2, #0
 800a45e:	6839      	ldr	r1, [r7, #0]
 800a460:	4618      	mov	r0, r3
 800a462:	f7ff ff7c 	bl	800a35e <CopyDecodedName>
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (dCert->issuerName != NULL) {
 800a466:	683b      	ldr	r3, [r7, #0]
 800a468:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
 800a46c:	2b00      	cmp	r3, #0
 800a46e:	d00a      	beq.n	800a486 <CopyDecodedToX509+0x80>
        wolfSSL_X509_set_issuer_name(x509,
                (WOLFSSL_X509_NAME*)dCert->issuerName);
 800a470:	683b      	ldr	r3, [r7, #0]
 800a472:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
        wolfSSL_X509_set_issuer_name(x509,
 800a476:	4619      	mov	r1, r3
 800a478:	6878      	ldr	r0, [r7, #4]
 800a47a:	f004 fce6 	bl	800ee4a <wolfSSL_X509_set_issuer_name>
        x509->issuer.x509 = x509;
 800a47e:	687b      	ldr	r3, [r7, #4]
 800a480:	687a      	ldr	r2, [r7, #4]
 800a482:	f8c3 2610 	str.w	r2, [r3, #1552]	@ 0x610
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */
    CopyDecodedName(&x509->subject, dCert, ASN_SUBJECT);
 800a486:	687b      	ldr	r3, [r7, #4]
 800a488:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800a48c:	2201      	movs	r2, #1
 800a48e:	6839      	ldr	r1, [r7, #0]
 800a490:	4618      	mov	r0, r3
 800a492:	f7ff ff64 	bl	800a35e <CopyDecodedName>
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (dCert->subjectName != NULL) {
 800a496:	683b      	ldr	r3, [r7, #0]
 800a498:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
 800a49c:	2b00      	cmp	r3, #0
 800a49e:	d00a      	beq.n	800a4b6 <CopyDecodedToX509+0xb0>
        wolfSSL_X509_set_subject_name(x509,
                (WOLFSSL_X509_NAME*)dCert->subjectName);
 800a4a0:	683b      	ldr	r3, [r7, #0]
 800a4a2:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
        wolfSSL_X509_set_subject_name(x509,
 800a4a6:	4619      	mov	r1, r3
 800a4a8:	6878      	ldr	r0, [r7, #4]
 800a4aa:	f004 fc96 	bl	800edda <wolfSSL_X509_set_subject_name>
        x509->subject.x509 = x509;
 800a4ae:	687b      	ldr	r3, [r7, #4]
 800a4b0:	687a      	ldr	r2, [r7, #4]
 800a4b2:	f8c3 2b1c 	str.w	r2, [r3, #2844]	@ 0xb1c
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */

    XMEMCPY(x509->serial, dCert->serial, EXTERNAL_SERIAL_SIZE);
 800a4b6:	687b      	ldr	r3, [r7, #4]
 800a4b8:	f103 00f4 	add.w	r0, r3, #244	@ 0xf4
 800a4bc:	683b      	ldr	r3, [r7, #0]
 800a4be:	f503 735d 	add.w	r3, r3, #884	@ 0x374
 800a4c2:	2220      	movs	r2, #32
 800a4c4:	4619      	mov	r1, r3
 800a4c6:	f01e fc5e 	bl	8028d86 <memcpy>
    x509->serialSz = dCert->serialSz;
 800a4ca:	683b      	ldr	r3, [r7, #0]
 800a4cc:	f8d3 2394 	ldr.w	r2, [r3, #916]	@ 0x394
 800a4d0:	687b      	ldr	r3, [r7, #4]
 800a4d2:	605a      	str	r2, [r3, #4]
    if (dCert->subjectCN && dCert->subjectCNLen < ASN_NAME_MAX) {
 800a4d4:	683b      	ldr	r3, [r7, #0]
 800a4d6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800a4da:	2b00      	cmp	r3, #0
 800a4dc:	d01a      	beq.n	800a514 <CopyDecodedToX509+0x10e>
 800a4de:	683b      	ldr	r3, [r7, #0]
 800a4e0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800a4e4:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 800a4e8:	da14      	bge.n	800a514 <CopyDecodedToX509+0x10e>
        XMEMCPY(x509->subjectCN, dCert->subjectCN, dCert->subjectCNLen);
 800a4ea:	687b      	ldr	r3, [r7, #4]
 800a4ec:	f503 708a 	add.w	r0, r3, #276	@ 0x114
 800a4f0:	683b      	ldr	r3, [r7, #0]
 800a4f2:	f8d3 1084 	ldr.w	r1, [r3, #132]	@ 0x84
 800a4f6:	683b      	ldr	r3, [r7, #0]
 800a4f8:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800a4fc:	461a      	mov	r2, r3
 800a4fe:	f01e fc42 	bl	8028d86 <memcpy>
        x509->subjectCN[dCert->subjectCNLen] = '\0';
 800a502:	683b      	ldr	r3, [r7, #0]
 800a504:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800a508:	687a      	ldr	r2, [r7, #4]
 800a50a:	4413      	add	r3, r2
 800a50c:	2200      	movs	r2, #0
 800a50e:	f883 2114 	strb.w	r2, [r3, #276]	@ 0x114
 800a512:	e003      	b.n	800a51c <CopyDecodedToX509+0x116>
    }
    else
        x509->subjectCN[0] = '\0';
 800a514:	687b      	ldr	r3, [r7, #4]
 800a516:	2200      	movs	r2, #0
 800a518:	f883 2114 	strb.w	r2, [r3, #276]	@ 0x114
    }
    else
        x509->hwSerialNumSz = 0;
#endif /* WOLFSSL_SEP */

    if (dCert->beforeDateLen > 0) {
 800a51c:	683b      	ldr	r3, [r7, #0]
 800a51e:	f8d3 3448 	ldr.w	r3, [r3, #1096]	@ 0x448
 800a522:	2b00      	cmp	r3, #0
 800a524:	dd20      	ble.n	800a568 <CopyDecodedToX509+0x162>
        minSz = (int)min(dCert->beforeDate[1], MAX_DATE_SZ);
 800a526:	683b      	ldr	r3, [r7, #0]
 800a528:	f8d3 3444 	ldr.w	r3, [r3, #1092]	@ 0x444
 800a52c:	3301      	adds	r3, #1
 800a52e:	781b      	ldrb	r3, [r3, #0]
 800a530:	2120      	movs	r1, #32
 800a532:	4618      	mov	r0, r3
 800a534:	f7fe fa92 	bl	8008a5c <min>
 800a538:	4603      	mov	r3, r0
 800a53a:	60bb      	str	r3, [r7, #8]
        x509->notBefore.type = dCert->beforeDate[0];
 800a53c:	683b      	ldr	r3, [r7, #0]
 800a53e:	f8d3 3444 	ldr.w	r3, [r3, #1092]	@ 0x444
 800a542:	781b      	ldrb	r3, [r3, #0]
 800a544:	461a      	mov	r2, r3
 800a546:	687b      	ldr	r3, [r7, #4]
 800a548:	63da      	str	r2, [r3, #60]	@ 0x3c
        x509->notBefore.length = minSz;
 800a54a:	687b      	ldr	r3, [r7, #4]
 800a54c:	68ba      	ldr	r2, [r7, #8]
 800a54e:	639a      	str	r2, [r3, #56]	@ 0x38
        XMEMCPY(x509->notBefore.data, &dCert->beforeDate[2], minSz);
 800a550:	687b      	ldr	r3, [r7, #4]
 800a552:	f103 0018 	add.w	r0, r3, #24
 800a556:	683b      	ldr	r3, [r7, #0]
 800a558:	f8d3 3444 	ldr.w	r3, [r3, #1092]	@ 0x444
 800a55c:	3302      	adds	r3, #2
 800a55e:	68ba      	ldr	r2, [r7, #8]
 800a560:	4619      	mov	r1, r3
 800a562:	f01e fc10 	bl	8028d86 <memcpy>
 800a566:	e002      	b.n	800a56e <CopyDecodedToX509+0x168>
    }
    else
        x509->notBefore.length = 0;
 800a568:	687b      	ldr	r3, [r7, #4]
 800a56a:	2200      	movs	r2, #0
 800a56c:	639a      	str	r2, [r3, #56]	@ 0x38
    if (dCert->afterDateLen > 0) {
 800a56e:	683b      	ldr	r3, [r7, #0]
 800a570:	f8d3 3450 	ldr.w	r3, [r3, #1104]	@ 0x450
 800a574:	2b00      	cmp	r3, #0
 800a576:	dd20      	ble.n	800a5ba <CopyDecodedToX509+0x1b4>
        minSz = (int)min(dCert->afterDate[1], MAX_DATE_SZ);
 800a578:	683b      	ldr	r3, [r7, #0]
 800a57a:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
 800a57e:	3301      	adds	r3, #1
 800a580:	781b      	ldrb	r3, [r3, #0]
 800a582:	2120      	movs	r1, #32
 800a584:	4618      	mov	r0, r3
 800a586:	f7fe fa69 	bl	8008a5c <min>
 800a58a:	4603      	mov	r3, r0
 800a58c:	60bb      	str	r3, [r7, #8]
        x509->notAfter.type = dCert->afterDate[0];
 800a58e:	683b      	ldr	r3, [r7, #0]
 800a590:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
 800a594:	781b      	ldrb	r3, [r3, #0]
 800a596:	461a      	mov	r2, r3
 800a598:	687b      	ldr	r3, [r7, #4]
 800a59a:	665a      	str	r2, [r3, #100]	@ 0x64
        x509->notAfter.length = minSz;
 800a59c:	687b      	ldr	r3, [r7, #4]
 800a59e:	68ba      	ldr	r2, [r7, #8]
 800a5a0:	661a      	str	r2, [r3, #96]	@ 0x60
        XMEMCPY(x509->notAfter.data, &dCert->afterDate[2], minSz);
 800a5a2:	687b      	ldr	r3, [r7, #4]
 800a5a4:	f103 0040 	add.w	r0, r3, #64	@ 0x40
 800a5a8:	683b      	ldr	r3, [r7, #0]
 800a5aa:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
 800a5ae:	3302      	adds	r3, #2
 800a5b0:	68ba      	ldr	r2, [r7, #8]
 800a5b2:	4619      	mov	r1, r3
 800a5b4:	f01e fbe7 	bl	8028d86 <memcpy>
 800a5b8:	e002      	b.n	800a5c0 <CopyDecodedToX509+0x1ba>
    }
    else
        x509->notAfter.length = 0;
 800a5ba:	687b      	ldr	r3, [r7, #4]
 800a5bc:	2200      	movs	r2, #0
 800a5be:	661a      	str	r2, [r3, #96]	@ 0x60

    if (dCert->publicKey != NULL && dCert->pubKeySize != 0) {
 800a5c0:	683b      	ldr	r3, [r7, #0]
 800a5c2:	681b      	ldr	r3, [r3, #0]
 800a5c4:	2b00      	cmp	r3, #0
 800a5c6:	d026      	beq.n	800a616 <CopyDecodedToX509+0x210>
 800a5c8:	683b      	ldr	r3, [r7, #0]
 800a5ca:	685b      	ldr	r3, [r3, #4]
 800a5cc:	2b00      	cmp	r3, #0
 800a5ce:	d022      	beq.n	800a616 <CopyDecodedToX509+0x210>
        x509->pubKey.buffer = (byte*)XMALLOC(
 800a5d0:	683b      	ldr	r3, [r7, #0]
 800a5d2:	685b      	ldr	r3, [r3, #4]
 800a5d4:	4618      	mov	r0, r3
 800a5d6:	f014 fb51 	bl	801ec7c <wolfSSL_Malloc>
 800a5da:	4602      	mov	r2, r0
 800a5dc:	687b      	ldr	r3, [r7, #4]
 800a5de:	679a      	str	r2, [r3, #120]	@ 0x78
                        dCert->pubKeySize, x509->heap, DYNAMIC_TYPE_PUBLIC_KEY);
        if (x509->pubKey.buffer != NULL) {
 800a5e0:	687b      	ldr	r3, [r7, #4]
 800a5e2:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800a5e4:	2b00      	cmp	r3, #0
 800a5e6:	d013      	beq.n	800a610 <CopyDecodedToX509+0x20a>
            x509->pubKeyOID = (int)dCert->keyOID;
 800a5e8:	683b      	ldr	r3, [r7, #0]
 800a5ea:	69db      	ldr	r3, [r3, #28]
 800a5ec:	461a      	mov	r2, r3
 800a5ee:	687b      	ldr	r3, [r7, #4]
 800a5f0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
            x509->pubKey.length = dCert->pubKeySize;
 800a5f4:	683b      	ldr	r3, [r7, #0]
 800a5f6:	685a      	ldr	r2, [r3, #4]
 800a5f8:	687b      	ldr	r3, [r7, #4]
 800a5fa:	67da      	str	r2, [r3, #124]	@ 0x7c
            XMEMCPY(x509->pubKey.buffer, dCert->publicKey, dCert->pubKeySize);
 800a5fc:	687b      	ldr	r3, [r7, #4]
 800a5fe:	6f98      	ldr	r0, [r3, #120]	@ 0x78
 800a600:	683b      	ldr	r3, [r7, #0]
 800a602:	6819      	ldr	r1, [r3, #0]
 800a604:	683b      	ldr	r3, [r7, #0]
 800a606:	685b      	ldr	r3, [r3, #4]
 800a608:	461a      	mov	r2, r3
 800a60a:	f01e fbbc 	bl	8028d86 <memcpy>
 800a60e:	e002      	b.n	800a616 <CopyDecodedToX509+0x210>
        }
        else
            ret = MEMORY_E;
 800a610:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a614:	60fb      	str	r3, [r7, #12]
            }
        }
#endif
    }

    if (dCert->signature != NULL && dCert->sigLength != 0 &&
 800a616:	683b      	ldr	r3, [r7, #0]
 800a618:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800a61c:	2b00      	cmp	r3, #0
 800a61e:	d02b      	beq.n	800a678 <CopyDecodedToX509+0x272>
 800a620:	683b      	ldr	r3, [r7, #0]
 800a622:	695b      	ldr	r3, [r3, #20]
 800a624:	2b00      	cmp	r3, #0
 800a626:	d027      	beq.n	800a678 <CopyDecodedToX509+0x272>
            dCert->sigLength <= MAX_ENCODED_SIG_SZ) {
 800a628:	683b      	ldr	r3, [r7, #0]
 800a62a:	695b      	ldr	r3, [r3, #20]
    if (dCert->signature != NULL && dCert->sigLength != 0 &&
 800a62c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800a630:	d822      	bhi.n	800a678 <CopyDecodedToX509+0x272>
        x509->sig.buffer = (byte*)XMALLOC(
 800a632:	683b      	ldr	r3, [r7, #0]
 800a634:	695b      	ldr	r3, [r3, #20]
 800a636:	4618      	mov	r0, r3
 800a638:	f014 fb20 	bl	801ec7c <wolfSSL_Malloc>
 800a63c:	4602      	mov	r2, r0
 800a63e:	687b      	ldr	r3, [r7, #4]
 800a640:	669a      	str	r2, [r3, #104]	@ 0x68
                          dCert->sigLength, x509->heap, DYNAMIC_TYPE_SIGNATURE);
        if (x509->sig.buffer == NULL) {
 800a642:	687b      	ldr	r3, [r7, #4]
 800a644:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800a646:	2b00      	cmp	r3, #0
 800a648:	d103      	bne.n	800a652 <CopyDecodedToX509+0x24c>
            ret = MEMORY_E;
 800a64a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a64e:	60fb      	str	r3, [r7, #12]
 800a650:	e012      	b.n	800a678 <CopyDecodedToX509+0x272>
        }
        else {
            XMEMCPY(x509->sig.buffer, dCert->signature, dCert->sigLength);
 800a652:	687b      	ldr	r3, [r7, #4]
 800a654:	6e98      	ldr	r0, [r3, #104]	@ 0x68
 800a656:	683b      	ldr	r3, [r7, #0]
 800a658:	f8d3 1080 	ldr.w	r1, [r3, #128]	@ 0x80
 800a65c:	683b      	ldr	r3, [r7, #0]
 800a65e:	695b      	ldr	r3, [r3, #20]
 800a660:	461a      	mov	r2, r3
 800a662:	f01e fb90 	bl	8028d86 <memcpy>
            x509->sig.length = dCert->sigLength;
 800a666:	683b      	ldr	r3, [r7, #0]
 800a668:	695a      	ldr	r2, [r3, #20]
 800a66a:	687b      	ldr	r3, [r7, #4]
 800a66c:	66da      	str	r2, [r3, #108]	@ 0x6c
            x509->sigOID = (int)dCert->signatureOID;
 800a66e:	683b      	ldr	r3, [r7, #0]
 800a670:	699b      	ldr	r3, [r3, #24]
 800a672:	461a      	mov	r2, r3
 800a674:	687b      	ldr	r3, [r7, #4]
 800a676:	671a      	str	r2, [r3, #112]	@ 0x70
#endif
    }

    /* if der contains original source buffer then store for potential
     * retrieval */
    if (dCert->source != NULL && dCert->maxIdx > 0) {
 800a678:	683b      	ldr	r3, [r7, #0]
 800a67a:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 800a67e:	2b00      	cmp	r3, #0
 800a680:	d024      	beq.n	800a6cc <CopyDecodedToX509+0x2c6>
 800a682:	683b      	ldr	r3, [r7, #0]
 800a684:	f8d3 336c 	ldr.w	r3, [r3, #876]	@ 0x36c
 800a688:	2b00      	cmp	r3, #0
 800a68a:	d01f      	beq.n	800a6cc <CopyDecodedToX509+0x2c6>
        if (AllocDer(&x509->derCert, dCert->maxIdx, CERT_TYPE, x509->heap)
 800a68c:	687b      	ldr	r3, [r7, #4]
 800a68e:	f103 008c 	add.w	r0, r3, #140	@ 0x8c
 800a692:	683b      	ldr	r3, [r7, #0]
 800a694:	f8d3 136c 	ldr.w	r1, [r3, #876]	@ 0x36c
 800a698:	687b      	ldr	r3, [r7, #4]
 800a69a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a69e:	2200      	movs	r2, #0
 800a6a0:	f00e fc4e 	bl	8018f40 <AllocDer>
 800a6a4:	4603      	mov	r3, r0
 800a6a6:	2b00      	cmp	r3, #0
 800a6a8:	d10d      	bne.n	800a6c6 <CopyDecodedToX509+0x2c0>
                                                                         == 0) {
            XMEMCPY(x509->derCert->buffer, dCert->source, dCert->maxIdx);
 800a6aa:	687b      	ldr	r3, [r7, #4]
 800a6ac:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800a6b0:	6818      	ldr	r0, [r3, #0]
 800a6b2:	683b      	ldr	r3, [r7, #0]
 800a6b4:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 800a6b8:	683b      	ldr	r3, [r7, #0]
 800a6ba:	f8d3 336c 	ldr.w	r3, [r3, #876]	@ 0x36c
 800a6be:	461a      	mov	r2, r3
 800a6c0:	f01e fb61 	bl	8028d86 <memcpy>
 800a6c4:	e002      	b.n	800a6cc <CopyDecodedToX509+0x2c6>
        }
        else {
            ret = MEMORY_E;
 800a6c6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a6ca:	60fb      	str	r3, [r7, #12]
        }
    }

    /* add alt names from dCert to X509 */
    if (CopyAltNames(&x509->altNames, dCert->altNames, -1, x509->heap) != 0) {
 800a6cc:	687b      	ldr	r3, [r7, #4]
 800a6ce:	f103 0074 	add.w	r0, r3, #116	@ 0x74
 800a6d2:	683b      	ldr	r3, [r7, #0]
 800a6d4:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 800a6d6:	687b      	ldr	r3, [r7, #4]
 800a6d8:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a6dc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800a6e0:	f7ff fe01 	bl	800a2e6 <CopyAltNames>
 800a6e4:	4603      	mov	r3, r0
 800a6e6:	2b00      	cmp	r3, #0
 800a6e8:	d002      	beq.n	800a6f0 <CopyDecodedToX509+0x2ea>
        return MEMORY_E;
 800a6ea:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a6ee:	e2a3      	b.n	800ac38 <CopyDecodedToX509+0x832>
    }
#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \
    !defined(IGNORE_NAME_CONSTRAINTS)
    /* add copies of email names from dCert to X509 */
    if (CopyAltNames(&x509->altNames, dCert->altEmailNames,
 800a6f0:	687b      	ldr	r3, [r7, #4]
 800a6f2:	f103 0074 	add.w	r0, r3, #116	@ 0x74
 800a6f6:	683b      	ldr	r3, [r7, #0]
 800a6f8:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 800a6fa:	687b      	ldr	r3, [r7, #4]
 800a6fc:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a700:	2201      	movs	r2, #1
 800a702:	f7ff fdf0 	bl	800a2e6 <CopyAltNames>
 800a706:	4603      	mov	r3, r0
 800a708:	2b00      	cmp	r3, #0
 800a70a:	d002      	beq.n	800a712 <CopyDecodedToX509+0x30c>
                ASN_RFC822_TYPE, x509->heap) != 0) {
        return MEMORY_E;
 800a70c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a710:	e292      	b.n	800ac38 <CopyDecodedToX509+0x832>
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */
#if defined(OPENSSL_EXTRA) && !defined(IGNORE_NAME_CONSTRAINTS)
    /* add copies of alternate directory names from dCert to X509 */
    if (CopyAltNames(&x509->altNames, dCert->altDirNames,
 800a712:	687b      	ldr	r3, [r7, #4]
 800a714:	f103 0074 	add.w	r0, r3, #116	@ 0x74
 800a718:	683b      	ldr	r3, [r7, #0]
 800a71a:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 800a71c:	687b      	ldr	r3, [r7, #4]
 800a71e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a722:	2204      	movs	r2, #4
 800a724:	f7ff fddf 	bl	800a2e6 <CopyAltNames>
 800a728:	4603      	mov	r3, r0
 800a72a:	2b00      	cmp	r3, #0
 800a72c:	d002      	beq.n	800a734 <CopyDecodedToX509+0x32e>
                ASN_DIR_TYPE, x509->heap) != 0) {
        return MEMORY_E;
 800a72e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a732:	e281      	b.n	800ac38 <CopyDecodedToX509+0x832>
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */
    x509->altNamesNext   = x509->altNames;  /* index hint */
 800a734:	687b      	ldr	r3, [r7, #4]
 800a736:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 800a738:	687b      	ldr	r3, [r7, #4]
 800a73a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

    x509->isCa = dCert->isCA;
 800a73e:	683b      	ldr	r3, [r7, #0]
 800a740:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a744:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800a748:	b2d9      	uxtb	r1, r3
 800a74a:	687a      	ldr	r2, [r7, #4]
 800a74c:	f892 3095 	ldrb.w	r3, [r2, #149]	@ 0x95
 800a750:	f361 0300 	bfi	r3, r1, #0, #1
 800a754:	f882 3095 	strb.w	r3, [r2, #149]	@ 0x95
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    x509->pathLength = dCert->pathLength;
 800a758:	683b      	ldr	r3, [r7, #0]
 800a75a:	f893 341c 	ldrb.w	r3, [r3, #1052]	@ 0x41c
 800a75e:	461a      	mov	r2, r3
 800a760:	687b      	ldr	r3, [r7, #4]
 800a762:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4
    x509->keyUsage = dCert->extKeyUsage;
 800a766:	683b      	ldr	r3, [r7, #0]
 800a768:	f8b3 2420 	ldrh.w	r2, [r3, #1056]	@ 0x420
 800a76c:	687b      	ldr	r3, [r7, #4]
 800a76e:	f8a3 20c8 	strh.w	r2, [r3, #200]	@ 0xc8

    x509->CRLdistSet = dCert->extCRLdistSet;
 800a772:	683b      	ldr	r3, [r7, #0]
 800a774:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a778:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800a77c:	b2d9      	uxtb	r1, r3
 800a77e:	687a      	ldr	r2, [r7, #4]
 800a780:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a784:	f361 0300 	bfi	r3, r1, #0, #1
 800a788:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->CRLdistCrit = dCert->extCRLdistCrit;
 800a78c:	683b      	ldr	r3, [r7, #0]
 800a78e:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a792:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800a796:	b2d9      	uxtb	r1, r3
 800a798:	687a      	ldr	r2, [r7, #4]
 800a79a:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a79e:	f361 0341 	bfi	r3, r1, #1, #1
 800a7a2:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    if (dCert->extCrlInfoRaw != NULL && dCert->extCrlInfoRawSz > 0) {
 800a7a6:	683b      	ldr	r3, [r7, #0]
 800a7a8:	f8d3 33b4 	ldr.w	r3, [r3, #948]	@ 0x3b4
 800a7ac:	2b00      	cmp	r3, #0
 800a7ae:	d029      	beq.n	800a804 <CopyDecodedToX509+0x3fe>
 800a7b0:	683b      	ldr	r3, [r7, #0]
 800a7b2:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800a7b6:	2b00      	cmp	r3, #0
 800a7b8:	dd24      	ble.n	800a804 <CopyDecodedToX509+0x3fe>
        x509->rawCRLInfo = (byte*)XMALLOC(dCert->extCrlInfoRawSz, x509->heap,
 800a7ba:	683b      	ldr	r3, [r7, #0]
 800a7bc:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800a7c0:	4618      	mov	r0, r3
 800a7c2:	f014 fa5b 	bl	801ec7c <wolfSSL_Malloc>
 800a7c6:	4602      	mov	r2, r0
 800a7c8:	687b      	ldr	r3, [r7, #4]
 800a7ca:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
            DYNAMIC_TYPE_X509_EXT);
        if (x509->rawCRLInfo != NULL) {
 800a7ce:	687b      	ldr	r3, [r7, #4]
 800a7d0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 800a7d4:	2b00      	cmp	r3, #0
 800a7d6:	d012      	beq.n	800a7fe <CopyDecodedToX509+0x3f8>
            XMEMCPY(x509->rawCRLInfo, dCert->extCrlInfoRaw, dCert->extCrlInfoRawSz);
 800a7d8:	687b      	ldr	r3, [r7, #4]
 800a7da:	f8d3 00b0 	ldr.w	r0, [r3, #176]	@ 0xb0
 800a7de:	683b      	ldr	r3, [r7, #0]
 800a7e0:	f8d3 13b4 	ldr.w	r1, [r3, #948]	@ 0x3b4
 800a7e4:	683b      	ldr	r3, [r7, #0]
 800a7e6:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800a7ea:	461a      	mov	r2, r3
 800a7ec:	f01e facb 	bl	8028d86 <memcpy>
            x509->rawCRLInfoSz = dCert->extCrlInfoRawSz;
 800a7f0:	683b      	ldr	r3, [r7, #0]
 800a7f2:	f8d3 23b8 	ldr.w	r2, [r3, #952]	@ 0x3b8
 800a7f6:	687b      	ldr	r3, [r7, #4]
 800a7f8:	f8c3 20cc 	str.w	r2, [r3, #204]	@ 0xcc
 800a7fc:	e002      	b.n	800a804 <CopyDecodedToX509+0x3fe>
        }
        else {
            ret = MEMORY_E;
 800a7fe:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a802:	60fb      	str	r3, [r7, #12]
        }
    }
    if (dCert->extCrlInfo != NULL && dCert->extCrlInfoSz > 0) {
 800a804:	683b      	ldr	r3, [r7, #0]
 800a806:	f8d3 33bc 	ldr.w	r3, [r3, #956]	@ 0x3bc
 800a80a:	2b00      	cmp	r3, #0
 800a80c:	d029      	beq.n	800a862 <CopyDecodedToX509+0x45c>
 800a80e:	683b      	ldr	r3, [r7, #0]
 800a810:	f8d3 33c0 	ldr.w	r3, [r3, #960]	@ 0x3c0
 800a814:	2b00      	cmp	r3, #0
 800a816:	dd24      	ble.n	800a862 <CopyDecodedToX509+0x45c>
        x509->CRLInfo = (byte*)XMALLOC(dCert->extCrlInfoSz, x509->heap,
 800a818:	683b      	ldr	r3, [r7, #0]
 800a81a:	f8d3 33c0 	ldr.w	r3, [r3, #960]	@ 0x3c0
 800a81e:	4618      	mov	r0, r3
 800a820:	f014 fa2c 	bl	801ec7c <wolfSSL_Malloc>
 800a824:	4602      	mov	r2, r0
 800a826:	687b      	ldr	r3, [r7, #4]
 800a828:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4
            DYNAMIC_TYPE_X509_EXT);
        if (x509->CRLInfo != NULL) {
 800a82c:	687b      	ldr	r3, [r7, #4]
 800a82e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 800a832:	2b00      	cmp	r3, #0
 800a834:	d012      	beq.n	800a85c <CopyDecodedToX509+0x456>
            XMEMCPY(x509->CRLInfo, dCert->extCrlInfo, dCert->extCrlInfoSz);
 800a836:	687b      	ldr	r3, [r7, #4]
 800a838:	f8d3 00b4 	ldr.w	r0, [r3, #180]	@ 0xb4
 800a83c:	683b      	ldr	r3, [r7, #0]
 800a83e:	f8d3 13bc 	ldr.w	r1, [r3, #956]	@ 0x3bc
 800a842:	683b      	ldr	r3, [r7, #0]
 800a844:	f8d3 33c0 	ldr.w	r3, [r3, #960]	@ 0x3c0
 800a848:	461a      	mov	r2, r3
 800a84a:	f01e fa9c 	bl	8028d86 <memcpy>
            x509->CRLInfoSz = dCert->extCrlInfoSz;
 800a84e:	683b      	ldr	r3, [r7, #0]
 800a850:	f8d3 23c0 	ldr.w	r2, [r3, #960]	@ 0x3c0
 800a854:	687b      	ldr	r3, [r7, #4]
 800a856:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
 800a85a:	e002      	b.n	800a862 <CopyDecodedToX509+0x45c>
        }
        else {
            ret = MEMORY_E;
 800a85c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a860:	60fb      	str	r3, [r7, #12]
        }
    }
    x509->authInfoSet = dCert->extAuthInfoSet;
 800a862:	683b      	ldr	r3, [r7, #0]
 800a864:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a868:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800a86c:	b2d9      	uxtb	r1, r3
 800a86e:	687a      	ldr	r2, [r7, #4]
 800a870:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a874:	f361 0382 	bfi	r3, r1, #2, #1
 800a878:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->authInfoCrit = dCert->extAuthInfoCrit;
 800a87c:	683b      	ldr	r3, [r7, #0]
 800a87e:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a882:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800a886:	b2d9      	uxtb	r1, r3
 800a888:	687a      	ldr	r2, [r7, #4]
 800a88a:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a88e:	f361 03c3 	bfi	r3, r1, #3, #1
 800a892:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    if (dCert->extAuthInfo != NULL && dCert->extAuthInfoSz > 0) {
 800a896:	683b      	ldr	r3, [r7, #0]
 800a898:	f8d3 33a4 	ldr.w	r3, [r3, #932]	@ 0x3a4
 800a89c:	2b00      	cmp	r3, #0
 800a89e:	d029      	beq.n	800a8f4 <CopyDecodedToX509+0x4ee>
 800a8a0:	683b      	ldr	r3, [r7, #0]
 800a8a2:	f8d3 33a8 	ldr.w	r3, [r3, #936]	@ 0x3a8
 800a8a6:	2b00      	cmp	r3, #0
 800a8a8:	dd24      	ble.n	800a8f4 <CopyDecodedToX509+0x4ee>
        x509->authInfo = (byte*)XMALLOC(dCert->extAuthInfoSz, x509->heap,
 800a8aa:	683b      	ldr	r3, [r7, #0]
 800a8ac:	f8d3 33a8 	ldr.w	r3, [r3, #936]	@ 0x3a8
 800a8b0:	4618      	mov	r0, r3
 800a8b2:	f014 f9e3 	bl	801ec7c <wolfSSL_Malloc>
 800a8b6:	4602      	mov	r2, r0
 800a8b8:	687b      	ldr	r3, [r7, #4]
 800a8ba:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8
                DYNAMIC_TYPE_X509_EXT);
        if (x509->authInfo != NULL) {
 800a8be:	687b      	ldr	r3, [r7, #4]
 800a8c0:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 800a8c4:	2b00      	cmp	r3, #0
 800a8c6:	d012      	beq.n	800a8ee <CopyDecodedToX509+0x4e8>
            XMEMCPY(x509->authInfo, dCert->extAuthInfo, dCert->extAuthInfoSz);
 800a8c8:	687b      	ldr	r3, [r7, #4]
 800a8ca:	f8d3 00b8 	ldr.w	r0, [r3, #184]	@ 0xb8
 800a8ce:	683b      	ldr	r3, [r7, #0]
 800a8d0:	f8d3 13a4 	ldr.w	r1, [r3, #932]	@ 0x3a4
 800a8d4:	683b      	ldr	r3, [r7, #0]
 800a8d6:	f8d3 33a8 	ldr.w	r3, [r3, #936]	@ 0x3a8
 800a8da:	461a      	mov	r2, r3
 800a8dc:	f01e fa53 	bl	8028d86 <memcpy>
            x509->authInfoSz = dCert->extAuthInfoSz;
 800a8e0:	683b      	ldr	r3, [r7, #0]
 800a8e2:	f8d3 23a8 	ldr.w	r2, [r3, #936]	@ 0x3a8
 800a8e6:	687b      	ldr	r3, [r7, #4]
 800a8e8:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
 800a8ec:	e002      	b.n	800a8f4 <CopyDecodedToX509+0x4ee>
        }
        else {
            ret = MEMORY_E;
 800a8ee:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a8f2:	60fb      	str	r3, [r7, #12]
        }
    }
    #ifdef WOLFSSL_ASN_CA_ISSUER
    if (dCert->extAuthInfoCaIssuer != NULL && dCert->extAuthInfoCaIssuerSz > 0) {
 800a8f4:	683b      	ldr	r3, [r7, #0]
 800a8f6:	f8d3 33ac 	ldr.w	r3, [r3, #940]	@ 0x3ac
 800a8fa:	2b00      	cmp	r3, #0
 800a8fc:	d029      	beq.n	800a952 <CopyDecodedToX509+0x54c>
 800a8fe:	683b      	ldr	r3, [r7, #0]
 800a900:	f8d3 33b0 	ldr.w	r3, [r3, #944]	@ 0x3b0
 800a904:	2b00      	cmp	r3, #0
 800a906:	dd24      	ble.n	800a952 <CopyDecodedToX509+0x54c>
        x509->authInfoCaIssuer = (byte*)XMALLOC(dCert->extAuthInfoCaIssuerSz, x509->heap,
 800a908:	683b      	ldr	r3, [r7, #0]
 800a90a:	f8d3 33b0 	ldr.w	r3, [r3, #944]	@ 0x3b0
 800a90e:	4618      	mov	r0, r3
 800a910:	f014 f9b4 	bl	801ec7c <wolfSSL_Malloc>
 800a914:	4602      	mov	r2, r0
 800a916:	687b      	ldr	r3, [r7, #4]
 800a918:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
                DYNAMIC_TYPE_X509_EXT);
        if (x509->authInfoCaIssuer != NULL) {
 800a91c:	687b      	ldr	r3, [r7, #4]
 800a91e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800a922:	2b00      	cmp	r3, #0
 800a924:	d012      	beq.n	800a94c <CopyDecodedToX509+0x546>
            XMEMCPY(x509->authInfoCaIssuer, dCert->extAuthInfoCaIssuer, dCert->extAuthInfoCaIssuerSz);
 800a926:	687b      	ldr	r3, [r7, #4]
 800a928:	f8d3 00bc 	ldr.w	r0, [r3, #188]	@ 0xbc
 800a92c:	683b      	ldr	r3, [r7, #0]
 800a92e:	f8d3 13ac 	ldr.w	r1, [r3, #940]	@ 0x3ac
 800a932:	683b      	ldr	r3, [r7, #0]
 800a934:	f8d3 33b0 	ldr.w	r3, [r3, #944]	@ 0x3b0
 800a938:	461a      	mov	r2, r3
 800a93a:	f01e fa24 	bl	8028d86 <memcpy>
            x509->authInfoCaIssuerSz = dCert->extAuthInfoCaIssuerSz;
 800a93e:	683b      	ldr	r3, [r7, #0]
 800a940:	f8d3 23b0 	ldr.w	r2, [r3, #944]	@ 0x3b0
 800a944:	687b      	ldr	r3, [r7, #4]
 800a946:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
 800a94a:	e002      	b.n	800a952 <CopyDecodedToX509+0x54c>
        }
        else {
            ret = MEMORY_E;
 800a94c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a950:	60fb      	str	r3, [r7, #12]
        }
    }
    #endif
    x509->basicConstSet = dCert->extBasicConstSet;
 800a952:	683b      	ldr	r3, [r7, #0]
 800a954:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a958:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800a95c:	b2d9      	uxtb	r1, r3
 800a95e:	687a      	ldr	r2, [r7, #4]
 800a960:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a964:	f361 0341 	bfi	r3, r1, #1, #1
 800a968:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->basicConstCrit = dCert->extBasicConstCrit;
 800a96c:	683b      	ldr	r3, [r7, #0]
 800a96e:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a972:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800a976:	b2d9      	uxtb	r1, r3
 800a978:	687a      	ldr	r2, [r7, #4]
 800a97a:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a97e:	f361 0382 	bfi	r3, r1, #2, #1
 800a982:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->basicConstPlSet = dCert->pathLengthSet;
 800a986:	683b      	ldr	r3, [r7, #0]
 800a988:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a98c:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800a990:	b2d9      	uxtb	r1, r3
 800a992:	687a      	ldr	r2, [r7, #4]
 800a994:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a998:	f361 03c3 	bfi	r3, r1, #3, #1
 800a99c:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->subjAltNameSet = dCert->extSubjAltNameSet;
 800a9a0:	683b      	ldr	r3, [r7, #0]
 800a9a2:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a9a6:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800a9aa:	b2d9      	uxtb	r1, r3
 800a9ac:	687a      	ldr	r2, [r7, #4]
 800a9ae:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a9b2:	f361 1304 	bfi	r3, r1, #4, #1
 800a9b6:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->subjAltNameCrit = dCert->extSubjAltNameCrit;
 800a9ba:	683b      	ldr	r3, [r7, #0]
 800a9bc:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a9c0:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800a9c4:	b2d9      	uxtb	r1, r3
 800a9c6:	687a      	ldr	r2, [r7, #4]
 800a9c8:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a9cc:	f361 1345 	bfi	r3, r1, #5, #1
 800a9d0:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->authKeyIdSet = dCert->extAuthKeyIdSet;
 800a9d4:	683b      	ldr	r3, [r7, #0]
 800a9d6:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a9da:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800a9de:	b2d9      	uxtb	r1, r3
 800a9e0:	687a      	ldr	r2, [r7, #4]
 800a9e2:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a9e6:	f361 1386 	bfi	r3, r1, #6, #1
 800a9ea:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->authKeyIdCrit = dCert->extAuthKeyIdCrit;
 800a9ee:	683b      	ldr	r3, [r7, #0]
 800a9f0:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a9f4:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800a9f8:	b2d9      	uxtb	r1, r3
 800a9fa:	687a      	ldr	r2, [r7, #4]
 800a9fc:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800aa00:	f361 13c7 	bfi	r3, r1, #7, #1
 800aa04:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    if (dCert->extAuthKeyIdSrc != NULL && dCert->extAuthKeyIdSz != 0) {
 800aa08:	683b      	ldr	r3, [r7, #0]
 800aa0a:	f8d3 3438 	ldr.w	r3, [r3, #1080]	@ 0x438
 800aa0e:	2b00      	cmp	r3, #0
 800aa10:	d05a      	beq.n	800aac8 <CopyDecodedToX509+0x6c2>
 800aa12:	683b      	ldr	r3, [r7, #0]
 800aa14:	f8d3 3408 	ldr.w	r3, [r3, #1032]	@ 0x408
 800aa18:	2b00      	cmp	r3, #0
 800aa1a:	d055      	beq.n	800aac8 <CopyDecodedToX509+0x6c2>
    #ifdef WOLFSSL_AKID_NAME
        if (dCert->extRawAuthKeyIdSrc != NULL &&
 800aa1c:	683b      	ldr	r3, [r7, #0]
 800aa1e:	f8d3 3430 	ldr.w	r3, [r3, #1072]	@ 0x430
 800aa22:	2b00      	cmp	r3, #0
 800aa24:	d04d      	beq.n	800aac2 <CopyDecodedToX509+0x6bc>
                dCert->extAuthKeyIdSrc > dCert->extRawAuthKeyIdSrc &&
 800aa26:	683b      	ldr	r3, [r7, #0]
 800aa28:	f8d3 2438 	ldr.w	r2, [r3, #1080]	@ 0x438
 800aa2c:	683b      	ldr	r3, [r7, #0]
 800aa2e:	f8d3 3430 	ldr.w	r3, [r3, #1072]	@ 0x430
        if (dCert->extRawAuthKeyIdSrc != NULL &&
 800aa32:	429a      	cmp	r2, r3
 800aa34:	d945      	bls.n	800aac2 <CopyDecodedToX509+0x6bc>
                dCert->extAuthKeyIdSrc <
 800aa36:	683b      	ldr	r3, [r7, #0]
 800aa38:	f8d3 2438 	ldr.w	r2, [r3, #1080]	@ 0x438
                    (dCert->extRawAuthKeyIdSrc + dCert->extRawAuthKeyIdSz)) {
 800aa3c:	683b      	ldr	r3, [r7, #0]
 800aa3e:	f8d3 1430 	ldr.w	r1, [r3, #1072]	@ 0x430
 800aa42:	683b      	ldr	r3, [r7, #0]
 800aa44:	f8d3 3434 	ldr.w	r3, [r3, #1076]	@ 0x434
 800aa48:	440b      	add	r3, r1
                dCert->extAuthKeyIdSrc > dCert->extRawAuthKeyIdSrc &&
 800aa4a:	429a      	cmp	r2, r3
 800aa4c:	d239      	bcs.n	800aac2 <CopyDecodedToX509+0x6bc>
            /* Confirmed: extAuthKeyIdSrc points inside extRawAuthKeyIdSrc */
            x509->authKeyIdSrc = (byte*)XMALLOC(dCert->extRawAuthKeyIdSz,
 800aa4e:	683b      	ldr	r3, [r7, #0]
 800aa50:	f8d3 3434 	ldr.w	r3, [r3, #1076]	@ 0x434
 800aa54:	4618      	mov	r0, r3
 800aa56:	f014 f911 	bl	801ec7c <wolfSSL_Malloc>
 800aa5a:	4602      	mov	r2, r0
 800aa5c:	687b      	ldr	r3, [r7, #4]
 800aa5e:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
                    x509->heap, DYNAMIC_TYPE_X509_EXT);
            if (x509->authKeyIdSrc != NULL) {
 800aa62:	687b      	ldr	r3, [r7, #4]
 800aa64:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 800aa68:	2b00      	cmp	r3, #0
 800aa6a:	d026      	beq.n	800aaba <CopyDecodedToX509+0x6b4>
                XMEMCPY(x509->authKeyIdSrc, dCert->extRawAuthKeyIdSrc,
 800aa6c:	687b      	ldr	r3, [r7, #4]
 800aa6e:	f8d3 00a0 	ldr.w	r0, [r3, #160]	@ 0xa0
 800aa72:	683b      	ldr	r3, [r7, #0]
 800aa74:	f8d3 1430 	ldr.w	r1, [r3, #1072]	@ 0x430
 800aa78:	683b      	ldr	r3, [r7, #0]
 800aa7a:	f8d3 3434 	ldr.w	r3, [r3, #1076]	@ 0x434
 800aa7e:	461a      	mov	r2, r3
 800aa80:	f01e f981 	bl	8028d86 <memcpy>
                        dCert->extRawAuthKeyIdSz);
                x509->authKeyIdSrcSz = dCert->extRawAuthKeyIdSz;
 800aa84:	683b      	ldr	r3, [r7, #0]
 800aa86:	f8d3 2434 	ldr.w	r2, [r3, #1076]	@ 0x434
 800aa8a:	687b      	ldr	r3, [r7, #4]
 800aa8c:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
                /* Set authKeyId to same offset inside authKeyIdSrc */
                x509->authKeyId = x509->authKeyIdSrc +
 800aa90:	687b      	ldr	r3, [r7, #4]
 800aa92:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
                        (dCert->extAuthKeyIdSrc - dCert->extRawAuthKeyIdSrc);
 800aa96:	683a      	ldr	r2, [r7, #0]
 800aa98:	f8d2 1438 	ldr.w	r1, [r2, #1080]	@ 0x438
 800aa9c:	683a      	ldr	r2, [r7, #0]
 800aa9e:	f8d2 2430 	ldr.w	r2, [r2, #1072]	@ 0x430
 800aaa2:	1a8a      	subs	r2, r1, r2
                x509->authKeyId = x509->authKeyIdSrc +
 800aaa4:	441a      	add	r2, r3
 800aaa6:	687b      	ldr	r3, [r7, #4]
 800aaa8:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
                x509->authKeyIdSz = dCert->extAuthKeyIdSz;
 800aaac:	683b      	ldr	r3, [r7, #0]
 800aaae:	f8d3 2408 	ldr.w	r2, [r3, #1032]	@ 0x408
 800aab2:	687b      	ldr	r3, [r7, #4]
 800aab4:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
            if (x509->authKeyIdSrc != NULL) {
 800aab8:	e006      	b.n	800aac8 <CopyDecodedToX509+0x6c2>
            }
            else
                ret = MEMORY_E;
 800aaba:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800aabe:	60fb      	str	r3, [r7, #12]
            if (x509->authKeyIdSrc != NULL) {
 800aac0:	e002      	b.n	800aac8 <CopyDecodedToX509+0x6c2>
                                 dCert->extAuthKeyIdSrc, dCert->extAuthKeyIdSz);
            x509->authKeyIdSz = dCert->extAuthKeyIdSz;
        }
    #endif
        else
            ret = MEMORY_E;
 800aac2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800aac6:	60fb      	str	r3, [r7, #12]
    }
    x509->subjKeyIdSet = dCert->extSubjKeyIdSet;
 800aac8:	683b      	ldr	r3, [r7, #0]
 800aaca:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800aace:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800aad2:	b2d9      	uxtb	r1, r3
 800aad4:	687a      	ldr	r2, [r7, #4]
 800aad6:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800aada:	f361 13c7 	bfi	r3, r1, #7, #1
 800aade:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->subjKeyIdCrit = dCert->extSubjKeyIdCrit;
 800aae2:	683b      	ldr	r3, [r7, #0]
 800aae4:	f893 34b7 	ldrb.w	r3, [r3, #1207]	@ 0x4b7
 800aae8:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800aaec:	b2d9      	uxtb	r1, r3
 800aaee:	687a      	ldr	r2, [r7, #4]
 800aaf0:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800aaf4:	f361 0300 	bfi	r3, r1, #0, #1
 800aaf8:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    if (dCert->extSubjKeyIdSrc != NULL && dCert->extSubjKeyIdSz != 0) {
 800aafc:	683b      	ldr	r3, [r7, #0]
 800aafe:	f8d3 343c 	ldr.w	r3, [r3, #1084]	@ 0x43c
 800ab02:	2b00      	cmp	r3, #0
 800ab04:	d029      	beq.n	800ab5a <CopyDecodedToX509+0x754>
 800ab06:	683b      	ldr	r3, [r7, #0]
 800ab08:	f8d3 33e4 	ldr.w	r3, [r3, #996]	@ 0x3e4
 800ab0c:	2b00      	cmp	r3, #0
 800ab0e:	d024      	beq.n	800ab5a <CopyDecodedToX509+0x754>
        x509->subjKeyId = (byte*)XMALLOC(dCert->extSubjKeyIdSz, x509->heap,
 800ab10:	683b      	ldr	r3, [r7, #0]
 800ab12:	f8d3 33e4 	ldr.w	r3, [r3, #996]	@ 0x3e4
 800ab16:	4618      	mov	r0, r3
 800ab18:	f014 f8b0 	bl	801ec7c <wolfSSL_Malloc>
 800ab1c:	4602      	mov	r2, r0
 800ab1e:	687b      	ldr	r3, [r7, #4]
 800ab20:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
                                         DYNAMIC_TYPE_X509_EXT);
        if (x509->subjKeyId != NULL) {
 800ab24:	687b      	ldr	r3, [r7, #4]
 800ab26:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800ab2a:	2b00      	cmp	r3, #0
 800ab2c:	d012      	beq.n	800ab54 <CopyDecodedToX509+0x74e>
            XMEMCPY(x509->subjKeyId,
 800ab2e:	687b      	ldr	r3, [r7, #4]
 800ab30:	f8d3 00a4 	ldr.w	r0, [r3, #164]	@ 0xa4
 800ab34:	683b      	ldr	r3, [r7, #0]
 800ab36:	f8d3 143c 	ldr.w	r1, [r3, #1084]	@ 0x43c
 800ab3a:	683b      	ldr	r3, [r7, #0]
 800ab3c:	f8d3 33e4 	ldr.w	r3, [r3, #996]	@ 0x3e4
 800ab40:	461a      	mov	r2, r3
 800ab42:	f01e f920 	bl	8028d86 <memcpy>
                                 dCert->extSubjKeyIdSrc, dCert->extSubjKeyIdSz);
            x509->subjKeyIdSz = dCert->extSubjKeyIdSz;
 800ab46:	683b      	ldr	r3, [r7, #0]
 800ab48:	f8d3 23e4 	ldr.w	r2, [r3, #996]	@ 0x3e4
 800ab4c:	687b      	ldr	r3, [r7, #4]
 800ab4e:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800ab52:	e002      	b.n	800ab5a <CopyDecodedToX509+0x754>
        }
        else
            ret = MEMORY_E;
 800ab54:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800ab58:	60fb      	str	r3, [r7, #12]
    }
    x509->keyUsageSet = dCert->extKeyUsageSet;
 800ab5a:	683b      	ldr	r3, [r7, #0]
 800ab5c:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800ab60:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800ab64:	b2d9      	uxtb	r1, r3
 800ab66:	687a      	ldr	r2, [r7, #4]
 800ab68:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800ab6c:	f361 1304 	bfi	r3, r1, #4, #1
 800ab70:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->keyUsageCrit = dCert->extKeyUsageCrit;
 800ab74:	683b      	ldr	r3, [r7, #0]
 800ab76:	f893 34b7 	ldrb.w	r3, [r3, #1207]	@ 0x4b7
 800ab7a:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800ab7e:	b2d9      	uxtb	r1, r3
 800ab80:	687a      	ldr	r2, [r7, #4]
 800ab82:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800ab86:	f361 1345 	bfi	r3, r1, #5, #1
 800ab8a:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    if (dCert->extExtKeyUsageSrc != NULL && dCert->extExtKeyUsageSz > 0) {
 800ab8e:	683b      	ldr	r3, [r7, #0]
 800ab90:	f8d3 3424 	ldr.w	r3, [r3, #1060]	@ 0x424
 800ab94:	2b00      	cmp	r3, #0
 800ab96:	d042      	beq.n	800ac1e <CopyDecodedToX509+0x818>
 800ab98:	683b      	ldr	r3, [r7, #0]
 800ab9a:	f8d3 3428 	ldr.w	r3, [r3, #1064]	@ 0x428
 800ab9e:	2b00      	cmp	r3, #0
 800aba0:	d03d      	beq.n	800ac1e <CopyDecodedToX509+0x818>
        x509->extKeyUsageSrc = (byte*)XMALLOC(dCert->extExtKeyUsageSz,
 800aba2:	683b      	ldr	r3, [r7, #0]
 800aba4:	f8d3 3428 	ldr.w	r3, [r3, #1064]	@ 0x428
 800aba8:	4618      	mov	r0, r3
 800abaa:	f014 f867 	bl	801ec7c <wolfSSL_Malloc>
 800abae:	4602      	mov	r2, r0
 800abb0:	687b      	ldr	r3, [r7, #4]
 800abb2:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
                x509->heap, DYNAMIC_TYPE_X509_EXT);
        if (x509->extKeyUsageSrc != NULL) {
 800abb6:	687b      	ldr	r3, [r7, #4]
 800abb8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 800abbc:	2b00      	cmp	r3, #0
 800abbe:	d02b      	beq.n	800ac18 <CopyDecodedToX509+0x812>
            XMEMCPY(x509->extKeyUsageSrc, dCert->extExtKeyUsageSrc,
 800abc0:	687b      	ldr	r3, [r7, #4]
 800abc2:	f8d3 00ac 	ldr.w	r0, [r3, #172]	@ 0xac
 800abc6:	683b      	ldr	r3, [r7, #0]
 800abc8:	f8d3 1424 	ldr.w	r1, [r3, #1060]	@ 0x424
 800abcc:	683b      	ldr	r3, [r7, #0]
 800abce:	f8d3 3428 	ldr.w	r3, [r3, #1064]	@ 0x428
 800abd2:	461a      	mov	r2, r3
 800abd4:	f01e f8d7 	bl	8028d86 <memcpy>
                                                       dCert->extExtKeyUsageSz);
            x509->extKeyUsage      = dCert->extExtKeyUsage;
 800abd8:	683b      	ldr	r3, [r7, #0]
 800abda:	f893 2422 	ldrb.w	r2, [r3, #1058]	@ 0x422
 800abde:	687b      	ldr	r3, [r7, #4]
 800abe0:	f883 20e4 	strb.w	r2, [r3, #228]	@ 0xe4
            x509->extKeyUsageSz    = dCert->extExtKeyUsageSz;
 800abe4:	683b      	ldr	r3, [r7, #0]
 800abe6:	f8d3 2428 	ldr.w	r2, [r3, #1064]	@ 0x428
 800abea:	687b      	ldr	r3, [r7, #4]
 800abec:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
            x509->extKeyUsageCrit  = dCert->extExtKeyUsageCrit;
 800abf0:	683b      	ldr	r3, [r7, #0]
 800abf2:	f893 34b7 	ldrb.w	r3, [r3, #1207]	@ 0x4b7
 800abf6:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800abfa:	b2d9      	uxtb	r1, r3
 800abfc:	687a      	ldr	r2, [r7, #4]
 800abfe:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800ac02:	f361 1386 	bfi	r3, r1, #6, #1
 800ac06:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
            x509->extKeyUsageCount = dCert->extExtKeyUsageCount;
 800ac0a:	683b      	ldr	r3, [r7, #0]
 800ac0c:	f8d3 242c 	ldr.w	r2, [r3, #1068]	@ 0x42c
 800ac10:	687b      	ldr	r3, [r7, #4]
 800ac12:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
 800ac16:	e002      	b.n	800ac1e <CopyDecodedToX509+0x818>
        }
        else {
            ret = MEMORY_E;
 800ac18:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800ac1c:	60fb      	str	r3, [r7, #12]
        }
    }
    #ifndef IGNORE_NETSCAPE_CERT_TYPE
    x509->nsCertType = dCert->nsCertType;
 800ac1e:	683b      	ldr	r3, [r7, #0]
 800ac20:	f893 246c 	ldrb.w	r2, [r3, #1132]	@ 0x46c
 800ac24:	687b      	ldr	r3, [r7, #4]
 800ac26:	f883 20f0 	strb.w	r2, [r3, #240]	@ 0xf0
        else
            ret = MEMORY_E;
    }
#endif
#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    x509->pkCurveOID = dCert->pkCurveOID;
 800ac2a:	683b      	ldr	r3, [r7, #0]
 800ac2c:	f8d3 2440 	ldr.w	r2, [r3, #1088]	@ 0x440
 800ac30:	687b      	ldr	r3, [r7, #4]
 800ac32:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
            ret = MEMORY_E;
        }
    }
#endif /* WOLFSSL_DUAL_ALG_CERTS */

    return ret;
 800ac36:	68fb      	ldr	r3, [r7, #12]
}
 800ac38:	4618      	mov	r0, r3
 800ac3a:	3710      	adds	r7, #16
 800ac3c:	46bd      	mov	sp, r7
 800ac3e:	bd80      	pop	{r7, pc}

0800ac40 <SetupStoreCtxCallback>:
}

int SetupStoreCtxCallback(WOLFSSL_X509_STORE_CTX** store_pt,
        WOLFSSL* ssl, WOLFSSL_CERT_MANAGER* cm, ProcPeerCertArgs* args,
        int cert_err, void* heap, int* x509Free)
{
 800ac40:	b580      	push	{r7, lr}
 800ac42:	b08a      	sub	sp, #40	@ 0x28
 800ac44:	af00      	add	r7, sp, #0
 800ac46:	60f8      	str	r0, [r7, #12]
 800ac48:	60b9      	str	r1, [r7, #8]
 800ac4a:	607a      	str	r2, [r7, #4]
 800ac4c:	603b      	str	r3, [r7, #0]
    WOLFSSL_X509_STORE_CTX* store = NULL;
 800ac4e:	2300      	movs	r3, #0
 800ac50:	61bb      	str	r3, [r7, #24]
    char* domain = NULL;
 800ac52:	2300      	movs	r3, #0
 800ac54:	627b      	str	r3, [r7, #36]	@ 0x24
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    WOLFSSL_X509* x509 = NULL;
 800ac56:	2300      	movs	r3, #0
 800ac58:	623b      	str	r3, [r7, #32]
#endif

    *x509Free = 0;
 800ac5a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800ac5c:	2200      	movs	r2, #0
 800ac5e:	601a      	str	r2, [r3, #0]

    store = wolfSSL_X509_STORE_CTX_new_ex(heap);
 800ac60:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 800ac62:	f004 fa19 	bl	800f098 <wolfSSL_X509_STORE_CTX_new_ex>
 800ac66:	61b8      	str	r0, [r7, #24]
    if (store == NULL)
 800ac68:	69bb      	ldr	r3, [r7, #24]
 800ac6a:	2b00      	cmp	r3, #0
 800ac6c:	f000 8177 	beq.w	800af5e <SetupStoreCtxCallback+0x31e>
        goto mem_error;
    domain = (char*)XMALLOC(ASN_NAME_MAX, heap, DYNAMIC_TYPE_STRING);
 800ac70:	f44f 70b4 	mov.w	r0, #360	@ 0x168
 800ac74:	f014 f802 	bl	801ec7c <wolfSSL_Malloc>
 800ac78:	6278      	str	r0, [r7, #36]	@ 0x24
    if (domain == NULL)
 800ac7a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ac7c:	2b00      	cmp	r3, #0
 800ac7e:	f000 8170 	beq.w	800af62 <SetupStoreCtxCallback+0x322>
        goto mem_error;

    domain[0] = '\0';
 800ac82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ac84:	2200      	movs	r2, #0
 800ac86:	701a      	strb	r2, [r3, #0]

    /* build subject CN as string to return in store */
    if (args->dCertInit && args->dCert && args->dCert->subjectCN) {
 800ac88:	683b      	ldr	r3, [r7, #0]
 800ac8a:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800ac8e:	f003 0304 	and.w	r3, r3, #4
 800ac92:	b2db      	uxtb	r3, r3
 800ac94:	2b00      	cmp	r3, #0
 800ac96:	d026      	beq.n	800ace6 <SetupStoreCtxCallback+0xa6>
 800ac98:	683b      	ldr	r3, [r7, #0]
 800ac9a:	689b      	ldr	r3, [r3, #8]
 800ac9c:	2b00      	cmp	r3, #0
 800ac9e:	d022      	beq.n	800ace6 <SetupStoreCtxCallback+0xa6>
 800aca0:	683b      	ldr	r3, [r7, #0]
 800aca2:	689b      	ldr	r3, [r3, #8]
 800aca4:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800aca8:	2b00      	cmp	r3, #0
 800acaa:	d01c      	beq.n	800ace6 <SetupStoreCtxCallback+0xa6>
        int subjectCNLen = args->dCert->subjectCNLen;
 800acac:	683b      	ldr	r3, [r7, #0]
 800acae:	689b      	ldr	r3, [r3, #8]
 800acb0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800acb4:	61fb      	str	r3, [r7, #28]
        if (subjectCNLen > ASN_NAME_MAX-1)
 800acb6:	69fb      	ldr	r3, [r7, #28]
 800acb8:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 800acbc:	db02      	blt.n	800acc4 <SetupStoreCtxCallback+0x84>
            subjectCNLen = ASN_NAME_MAX-1;
 800acbe:	f240 1367 	movw	r3, #359	@ 0x167
 800acc2:	61fb      	str	r3, [r7, #28]
        if (subjectCNLen > 0) {
 800acc4:	69fb      	ldr	r3, [r7, #28]
 800acc6:	2b00      	cmp	r3, #0
 800acc8:	dd0d      	ble.n	800ace6 <SetupStoreCtxCallback+0xa6>
            XMEMCPY(domain, args->dCert->subjectCN, subjectCNLen);
 800acca:	683b      	ldr	r3, [r7, #0]
 800accc:	689b      	ldr	r3, [r3, #8]
 800acce:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800acd2:	69fa      	ldr	r2, [r7, #28]
 800acd4:	4619      	mov	r1, r3
 800acd6:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800acd8:	f01e f855 	bl	8028d86 <memcpy>
            domain[subjectCNLen] = '\0';
 800acdc:	69fb      	ldr	r3, [r7, #28]
 800acde:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ace0:	4413      	add	r3, r2
 800ace2:	2200      	movs	r2, #0
 800ace4:	701a      	strb	r2, [r3, #0]
        }
    }

#ifndef OPENSSL_COMPATIBLE_DEFAULTS
    store->error = cert_err;
 800ace6:	69bb      	ldr	r3, [r7, #24]
 800ace8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800acea:	625a      	str	r2, [r3, #36]	@ 0x24
#else
    store->error = GetX509Error(cert_err);
#endif
    store->error_depth = args->certIdx;
 800acec:	683b      	ldr	r3, [r7, #0]
 800acee:	69da      	ldr	r2, [r3, #28]
 800acf0:	69bb      	ldr	r3, [r7, #24]
 800acf2:	629a      	str	r2, [r3, #40]	@ 0x28
    store->discardSessionCerts = 0;
 800acf4:	69bb      	ldr	r3, [r7, #24]
 800acf6:	2200      	movs	r2, #0
 800acf8:	62da      	str	r2, [r3, #44]	@ 0x2c
    store->domain = domain;
 800acfa:	69bb      	ldr	r3, [r7, #24]
 800acfc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800acfe:	619a      	str	r2, [r3, #24]
    if (ssl != NULL) {
 800ad00:	68bb      	ldr	r3, [r7, #8]
 800ad02:	2b00      	cmp	r3, #0
 800ad04:	d011      	beq.n	800ad2a <SetupStoreCtxCallback+0xea>
        if (ssl->verifyCbCtx != NULL) {
 800ad06:	68bb      	ldr	r3, [r7, #8]
 800ad08:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800ad0c:	2b00      	cmp	r3, #0
 800ad0e:	d005      	beq.n	800ad1c <SetupStoreCtxCallback+0xdc>
            /* Use the WOLFSSL user context if set */
            store->userCtx = ssl->verifyCbCtx;
 800ad10:	68bb      	ldr	r3, [r7, #8]
 800ad12:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 800ad16:	69bb      	ldr	r3, [r7, #24]
 800ad18:	621a      	str	r2, [r3, #32]
 800ad1a:	e009      	b.n	800ad30 <SetupStoreCtxCallback+0xf0>
        }
        else {
            /* Else use the WOLFSSL_CTX user context */
            store->userCtx = ssl->ctx->verifyCbCtx;
 800ad1c:	68bb      	ldr	r3, [r7, #8]
 800ad1e:	681b      	ldr	r3, [r3, #0]
 800ad20:	f8d3 20b8 	ldr.w	r2, [r3, #184]	@ 0xb8
 800ad24:	69bb      	ldr	r3, [r7, #24]
 800ad26:	621a      	str	r2, [r3, #32]
 800ad28:	e002      	b.n	800ad30 <SetupStoreCtxCallback+0xf0>
        }
    }
    else {
        store->userCtx = cm;
 800ad2a:	69bb      	ldr	r3, [r7, #24]
 800ad2c:	687a      	ldr	r2, [r7, #4]
 800ad2e:	621a      	str	r2, [r3, #32]
    }
    store->certs = args->certs;
 800ad30:	683b      	ldr	r3, [r7, #0]
 800ad32:	681a      	ldr	r2, [r3, #0]
 800ad34:	69bb      	ldr	r3, [r7, #24]
 800ad36:	635a      	str	r2, [r3, #52]	@ 0x34
    store->totalCerts = args->totalCerts;
 800ad38:	683b      	ldr	r3, [r7, #0]
 800ad3a:	695a      	ldr	r2, [r3, #20]
 800ad3c:	69bb      	ldr	r3, [r7, #24]
 800ad3e:	631a      	str	r2, [r3, #48]	@ 0x30
            != WOLFSSL_SUCCESS) {
        WOLFSSL_MSG("Failed to store ssl context in WOLFSSL_X509_STORE_CTX");
    }
#endif

    if (ssl != NULL) {
 800ad40:	68bb      	ldr	r3, [r7, #8]
 800ad42:	2b00      	cmp	r3, #0
 800ad44:	f000 8106 	beq.w	800af54 <SetupStoreCtxCallback+0x314>
#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER)
        store->store = SSL_STORE(ssl);
 800ad48:	68bb      	ldr	r3, [r7, #8]
 800ad4a:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ad4e:	2b00      	cmp	r3, #0
 800ad50:	d003      	beq.n	800ad5a <SetupStoreCtxCallback+0x11a>
 800ad52:	68bb      	ldr	r3, [r7, #8]
 800ad54:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ad58:	e00d      	b.n	800ad76 <SetupStoreCtxCallback+0x136>
 800ad5a:	68bb      	ldr	r3, [r7, #8]
 800ad5c:	681b      	ldr	r3, [r3, #0]
 800ad5e:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ad62:	2b00      	cmp	r3, #0
 800ad64:	d004      	beq.n	800ad70 <SetupStoreCtxCallback+0x130>
 800ad66:	68bb      	ldr	r3, [r7, #8]
 800ad68:	681b      	ldr	r3, [r3, #0]
 800ad6a:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ad6e:	e002      	b.n	800ad76 <SetupStoreCtxCallback+0x136>
 800ad70:	68bb      	ldr	r3, [r7, #8]
 800ad72:	681b      	ldr	r3, [r3, #0]
 800ad74:	33f4      	adds	r3, #244	@ 0xf4
 800ad76:	69ba      	ldr	r2, [r7, #24]
 800ad78:	6013      	str	r3, [r2, #0]
#if defined(OPENSSL_EXTRA)
        store->depth = args->count;
 800ad7a:	683b      	ldr	r3, [r7, #0]
 800ad7c:	699a      	ldr	r2, [r3, #24]
 800ad7e:	69bb      	ldr	r3, [r7, #24]
 800ad80:	61da      	str	r2, [r3, #28]
        /* Overwrite with non-default param values in SSL */
        if (ssl->param) {
 800ad82:	68bb      	ldr	r3, [r7, #8]
 800ad84:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ad88:	2b00      	cmp	r3, #0
 800ad8a:	f000 80aa 	beq.w	800aee2 <SetupStoreCtxCallback+0x2a2>
            if (ssl->param->check_time)
 800ad8e:	68bb      	ldr	r3, [r7, #8]
 800ad90:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ad94:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ad98:	4313      	orrs	r3, r2
 800ad9a:	d008      	beq.n	800adae <SetupStoreCtxCallback+0x16e>
                store->param->check_time = ssl->param->check_time;
 800ad9c:	68bb      	ldr	r3, [r7, #8]
 800ad9e:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ada2:	69ba      	ldr	r2, [r7, #24]
 800ada4:	6951      	ldr	r1, [r2, #20]
 800ada6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800adaa:	e9c1 2302 	strd	r2, r3, [r1, #8]

            if (ssl->param->flags)
 800adae:	68bb      	ldr	r3, [r7, #8]
 800adb0:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800adb4:	695b      	ldr	r3, [r3, #20]
 800adb6:	2b00      	cmp	r3, #0
 800adb8:	d007      	beq.n	800adca <SetupStoreCtxCallback+0x18a>
                store->param->flags = ssl->param->flags;
 800adba:	68bb      	ldr	r3, [r7, #8]
 800adbc:	f8d3 2334 	ldr.w	r2, [r3, #820]	@ 0x334
 800adc0:	69bb      	ldr	r3, [r7, #24]
 800adc2:	695b      	ldr	r3, [r3, #20]
 800adc4:	6952      	ldr	r2, [r2, #20]
 800adc6:	615a      	str	r2, [r3, #20]
 800adc8:	e078      	b.n	800aebc <SetupStoreCtxCallback+0x27c>
#ifdef WOLFSSL_LOCAL_X509_STORE
            else if (SSL_STORE(ssl) && SSL_STORE(ssl)->param &&
 800adca:	68bb      	ldr	r3, [r7, #8]
 800adcc:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800add0:	2b00      	cmp	r3, #0
 800add2:	d008      	beq.n	800ade6 <SetupStoreCtxCallback+0x1a6>
 800add4:	68bb      	ldr	r3, [r7, #8]
 800add6:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800adda:	2b00      	cmp	r3, #0
 800addc:	bf14      	ite	ne
 800adde:	2301      	movne	r3, #1
 800ade0:	2300      	moveq	r3, #0
 800ade2:	b2db      	uxtb	r3, r3
 800ade4:	e017      	b.n	800ae16 <SetupStoreCtxCallback+0x1d6>
 800ade6:	68bb      	ldr	r3, [r7, #8]
 800ade8:	681b      	ldr	r3, [r3, #0]
 800adea:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800adee:	2b00      	cmp	r3, #0
 800adf0:	d009      	beq.n	800ae06 <SetupStoreCtxCallback+0x1c6>
 800adf2:	68bb      	ldr	r3, [r7, #8]
 800adf4:	681b      	ldr	r3, [r3, #0]
 800adf6:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800adfa:	2b00      	cmp	r3, #0
 800adfc:	bf14      	ite	ne
 800adfe:	2301      	movne	r3, #1
 800ae00:	2300      	moveq	r3, #0
 800ae02:	b2db      	uxtb	r3, r3
 800ae04:	e007      	b.n	800ae16 <SetupStoreCtxCallback+0x1d6>
 800ae06:	68bb      	ldr	r3, [r7, #8]
 800ae08:	681b      	ldr	r3, [r3, #0]
 800ae0a:	33f4      	adds	r3, #244	@ 0xf4
 800ae0c:	2b00      	cmp	r3, #0
 800ae0e:	bf14      	ite	ne
 800ae10:	2301      	movne	r3, #1
 800ae12:	2300      	moveq	r3, #0
 800ae14:	b2db      	uxtb	r3, r3
 800ae16:	2b00      	cmp	r3, #0
 800ae18:	d050      	beq.n	800aebc <SetupStoreCtxCallback+0x27c>
 800ae1a:	68bb      	ldr	r3, [r7, #8]
 800ae1c:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ae20:	2b00      	cmp	r3, #0
 800ae22:	d003      	beq.n	800ae2c <SetupStoreCtxCallback+0x1ec>
 800ae24:	68bb      	ldr	r3, [r7, #8]
 800ae26:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ae2a:	e00d      	b.n	800ae48 <SetupStoreCtxCallback+0x208>
 800ae2c:	68bb      	ldr	r3, [r7, #8]
 800ae2e:	681b      	ldr	r3, [r3, #0]
 800ae30:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ae34:	2b00      	cmp	r3, #0
 800ae36:	d004      	beq.n	800ae42 <SetupStoreCtxCallback+0x202>
 800ae38:	68bb      	ldr	r3, [r7, #8]
 800ae3a:	681b      	ldr	r3, [r3, #0]
 800ae3c:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ae40:	e002      	b.n	800ae48 <SetupStoreCtxCallback+0x208>
 800ae42:	68bb      	ldr	r3, [r7, #8]
 800ae44:	681b      	ldr	r3, [r3, #0]
 800ae46:	33f4      	adds	r3, #244	@ 0xf4
 800ae48:	699b      	ldr	r3, [r3, #24]
 800ae4a:	2b00      	cmp	r3, #0
 800ae4c:	d036      	beq.n	800aebc <SetupStoreCtxCallback+0x27c>
                    SSL_STORE(ssl)->param->flags)
 800ae4e:	68bb      	ldr	r3, [r7, #8]
 800ae50:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ae54:	2b00      	cmp	r3, #0
 800ae56:	d003      	beq.n	800ae60 <SetupStoreCtxCallback+0x220>
 800ae58:	68bb      	ldr	r3, [r7, #8]
 800ae5a:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ae5e:	e00d      	b.n	800ae7c <SetupStoreCtxCallback+0x23c>
 800ae60:	68bb      	ldr	r3, [r7, #8]
 800ae62:	681b      	ldr	r3, [r3, #0]
 800ae64:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ae68:	2b00      	cmp	r3, #0
 800ae6a:	d004      	beq.n	800ae76 <SetupStoreCtxCallback+0x236>
 800ae6c:	68bb      	ldr	r3, [r7, #8]
 800ae6e:	681b      	ldr	r3, [r3, #0]
 800ae70:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ae74:	e002      	b.n	800ae7c <SetupStoreCtxCallback+0x23c>
 800ae76:	68bb      	ldr	r3, [r7, #8]
 800ae78:	681b      	ldr	r3, [r3, #0]
 800ae7a:	33f4      	adds	r3, #244	@ 0xf4
 800ae7c:	699b      	ldr	r3, [r3, #24]
 800ae7e:	695b      	ldr	r3, [r3, #20]
            else if (SSL_STORE(ssl) && SSL_STORE(ssl)->param &&
 800ae80:	2b00      	cmp	r3, #0
 800ae82:	d01b      	beq.n	800aebc <SetupStoreCtxCallback+0x27c>
                store->param->flags = SSL_STORE(ssl)->param->flags;
 800ae84:	68bb      	ldr	r3, [r7, #8]
 800ae86:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ae8a:	2b00      	cmp	r3, #0
 800ae8c:	d003      	beq.n	800ae96 <SetupStoreCtxCallback+0x256>
 800ae8e:	68bb      	ldr	r3, [r7, #8]
 800ae90:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ae94:	e00d      	b.n	800aeb2 <SetupStoreCtxCallback+0x272>
 800ae96:	68bb      	ldr	r3, [r7, #8]
 800ae98:	681b      	ldr	r3, [r3, #0]
 800ae9a:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ae9e:	2b00      	cmp	r3, #0
 800aea0:	d004      	beq.n	800aeac <SetupStoreCtxCallback+0x26c>
 800aea2:	68bb      	ldr	r3, [r7, #8]
 800aea4:	681b      	ldr	r3, [r3, #0]
 800aea6:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800aeaa:	e002      	b.n	800aeb2 <SetupStoreCtxCallback+0x272>
 800aeac:	68bb      	ldr	r3, [r7, #8]
 800aeae:	681b      	ldr	r3, [r3, #0]
 800aeb0:	33f4      	adds	r3, #244	@ 0xf4
 800aeb2:	699a      	ldr	r2, [r3, #24]
 800aeb4:	69bb      	ldr	r3, [r7, #24]
 800aeb6:	695b      	ldr	r3, [r3, #20]
 800aeb8:	6952      	ldr	r2, [r2, #20]
 800aeba:	615a      	str	r2, [r3, #20]
#endif


            if (ssl->param->hostName[0])
 800aebc:	68bb      	ldr	r3, [r7, #8]
 800aebe:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800aec2:	7e1b      	ldrb	r3, [r3, #24]
 800aec4:	2b00      	cmp	r3, #0
 800aec6:	d00c      	beq.n	800aee2 <SetupStoreCtxCallback+0x2a2>
                XMEMCPY(store->param->hostName, ssl->param->hostName,
 800aec8:	69bb      	ldr	r3, [r7, #24]
 800aeca:	695b      	ldr	r3, [r3, #20]
 800aecc:	f103 0018 	add.w	r0, r3, #24
 800aed0:	68bb      	ldr	r3, [r7, #8]
 800aed2:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800aed6:	3318      	adds	r3, #24
 800aed8:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800aedc:	4619      	mov	r1, r3
 800aede:	f01d ff52 	bl	8028d86 <memcpy>
        }
#endif /* defined(OPENSSL_EXTRA) */
#endif /* defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER)*/
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    #ifdef KEEP_PEER_CERT
        if (args->certIdx == 0) {
 800aee2:	683b      	ldr	r3, [r7, #0]
 800aee4:	69db      	ldr	r3, [r3, #28]
 800aee6:	2b00      	cmp	r3, #0
 800aee8:	d11e      	bne.n	800af28 <SetupStoreCtxCallback+0x2e8>
            FreeX509(&ssl->peerCert);
 800aeea:	68bb      	ldr	r3, [r7, #8]
 800aeec:	f503 736f 	add.w	r3, r3, #956	@ 0x3bc
 800aef0:	4618      	mov	r0, r3
 800aef2:	f7fe fc0a 	bl	800970a <FreeX509>
            InitX509(&ssl->peerCert, 0, ssl->heap);
 800aef6:	68bb      	ldr	r3, [r7, #8]
 800aef8:	f503 706f 	add.w	r0, r3, #956	@ 0x3bc
 800aefc:	68bb      	ldr	r3, [r7, #8]
 800aefe:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800af02:	461a      	mov	r2, r3
 800af04:	2100      	movs	r1, #0
 800af06:	f7fe fbcd 	bl	80096a4 <InitX509>
            if (CopyDecodedToX509(&ssl->peerCert, args->dCert) == 0)
 800af0a:	68bb      	ldr	r3, [r7, #8]
 800af0c:	f503 726f 	add.w	r2, r3, #956	@ 0x3bc
 800af10:	683b      	ldr	r3, [r7, #0]
 800af12:	689b      	ldr	r3, [r3, #8]
 800af14:	4619      	mov	r1, r3
 800af16:	4610      	mov	r0, r2
 800af18:	f7ff fa75 	bl	800a406 <CopyDecodedToX509>
                WOLFSSL_MSG("Unable to copy to ssl->peerCert");
            store->current_cert = &ssl->peerCert; /* use existing X509 */
 800af1c:	68bb      	ldr	r3, [r7, #8]
 800af1e:	f503 726f 	add.w	r2, r3, #956	@ 0x3bc
 800af22:	69bb      	ldr	r3, [r7, #24]
 800af24:	605a      	str	r2, [r3, #4]
 800af26:	e015      	b.n	800af54 <SetupStoreCtxCallback+0x314>
        }
        else
    #endif
        {
            x509 = wolfSSL_X509_new_ex(heap);
 800af28:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 800af2a:	f003 fbc6 	bl	800e6ba <wolfSSL_X509_new_ex>
 800af2e:	6238      	str	r0, [r7, #32]
            if (x509 == NULL)
 800af30:	6a3b      	ldr	r3, [r7, #32]
 800af32:	2b00      	cmp	r3, #0
 800af34:	d017      	beq.n	800af66 <SetupStoreCtxCallback+0x326>
                goto mem_error;
            if (CopyDecodedToX509(x509, args->dCert) == 0) {
 800af36:	683b      	ldr	r3, [r7, #0]
 800af38:	689b      	ldr	r3, [r3, #8]
 800af3a:	4619      	mov	r1, r3
 800af3c:	6a38      	ldr	r0, [r7, #32]
 800af3e:	f7ff fa62 	bl	800a406 <CopyDecodedToX509>
 800af42:	4603      	mov	r3, r0
 800af44:	2b00      	cmp	r3, #0
 800af46:	d110      	bne.n	800af6a <SetupStoreCtxCallback+0x32a>
                store->current_cert = x509;
 800af48:	69bb      	ldr	r3, [r7, #24]
 800af4a:	6a3a      	ldr	r2, [r7, #32]
 800af4c:	605a      	str	r2, [r3, #4]
                *x509Free = 1;
 800af4e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800af50:	2201      	movs	r2, #1
 800af52:	601a      	str	r2, [r3, #0]
#endif
#ifdef SESSION_CERTS
        store->sesChain = &ssl->session->chain;
#endif
    }
    *store_pt = store;
 800af54:	68fb      	ldr	r3, [r7, #12]
 800af56:	69ba      	ldr	r2, [r7, #24]
 800af58:	601a      	str	r2, [r3, #0]
    return 0;
 800af5a:	2300      	movs	r3, #0
 800af5c:	e01c      	b.n	800af98 <SetupStoreCtxCallback+0x358>
        goto mem_error;
 800af5e:	bf00      	nop
 800af60:	e004      	b.n	800af6c <SetupStoreCtxCallback+0x32c>
        goto mem_error;
 800af62:	bf00      	nop
 800af64:	e002      	b.n	800af6c <SetupStoreCtxCallback+0x32c>
                goto mem_error;
 800af66:	bf00      	nop
 800af68:	e000      	b.n	800af6c <SetupStoreCtxCallback+0x32c>
                goto mem_error;
 800af6a:	bf00      	nop
mem_error:
    if (store != NULL)
 800af6c:	69bb      	ldr	r3, [r7, #24]
 800af6e:	2b00      	cmp	r3, #0
 800af70:	d002      	beq.n	800af78 <SetupStoreCtxCallback+0x338>
        wolfSSL_X509_STORE_CTX_free(store);
 800af72:	69b8      	ldr	r0, [r7, #24]
 800af74:	f004 f8cc 	bl	800f110 <wolfSSL_X509_STORE_CTX_free>
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (x509 != NULL)
 800af78:	6a3b      	ldr	r3, [r7, #32]
 800af7a:	2b00      	cmp	r3, #0
 800af7c:	d002      	beq.n	800af84 <SetupStoreCtxCallback+0x344>
        wolfSSL_X509_free(x509);
 800af7e:	6a38      	ldr	r0, [r7, #32]
 800af80:	f003 fa99 	bl	800e4b6 <wolfSSL_X509_free>
#endif
    XFREE(domain, heap, DYNAMIC_TYPE_STRING);
 800af84:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800af86:	617b      	str	r3, [r7, #20]
 800af88:	697b      	ldr	r3, [r7, #20]
 800af8a:	2b00      	cmp	r3, #0
 800af8c:	d002      	beq.n	800af94 <SetupStoreCtxCallback+0x354>
 800af8e:	6978      	ldr	r0, [r7, #20]
 800af90:	f013 fe90 	bl	801ecb4 <wolfSSL_Free>
    return MEMORY_E;
 800af94:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
}
 800af98:	4618      	mov	r0, r3
 800af9a:	3728      	adds	r7, #40	@ 0x28
 800af9c:	46bd      	mov	sp, r7
 800af9e:	bd80      	pop	{r7, pc}

0800afa0 <CleanupStoreCtxCallback>:

void CleanupStoreCtxCallback(WOLFSSL_X509_STORE_CTX* store,
        WOLFSSL* ssl, void* heap, int x509Free)
{
 800afa0:	b580      	push	{r7, lr}
 800afa2:	b086      	sub	sp, #24
 800afa4:	af00      	add	r7, sp, #0
 800afa6:	60f8      	str	r0, [r7, #12]
 800afa8:	60b9      	str	r1, [r7, #8]
 800afaa:	607a      	str	r2, [r7, #4]
 800afac:	603b      	str	r3, [r7, #0]
    #ifdef WOLFSSL_ALT_CERT_CHAINS
        ssl->session->altChain.count = 0;
    #endif
    }
#endif /* SESSION_CERTS */
    XFREE(store->domain, heap, DYNAMIC_TYPE_STRING);
 800afae:	68fb      	ldr	r3, [r7, #12]
 800afb0:	699b      	ldr	r3, [r3, #24]
 800afb2:	617b      	str	r3, [r7, #20]
 800afb4:	697b      	ldr	r3, [r7, #20]
 800afb6:	2b00      	cmp	r3, #0
 800afb8:	d002      	beq.n	800afc0 <CleanupStoreCtxCallback+0x20>
 800afba:	6978      	ldr	r0, [r7, #20]
 800afbc:	f013 fe7a 	bl	801ecb4 <wolfSSL_Free>
    store->domain = NULL;
 800afc0:	68fb      	ldr	r3, [r7, #12]
 800afc2:	2200      	movs	r2, #0
 800afc4:	619a      	str	r2, [r3, #24]
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (x509Free)
 800afc6:	683b      	ldr	r3, [r7, #0]
 800afc8:	2b00      	cmp	r3, #0
 800afca:	d004      	beq.n	800afd6 <CleanupStoreCtxCallback+0x36>
        wolfSSL_X509_free(store->current_cert);
 800afcc:	68fb      	ldr	r3, [r7, #12]
 800afce:	685b      	ldr	r3, [r3, #4]
 800afd0:	4618      	mov	r0, r3
 800afd2:	f003 fa70 	bl	800e4b6 <wolfSSL_X509_free>
    store->current_cert = NULL;
 800afd6:	68fb      	ldr	r3, [r7, #12]
 800afd8:	2200      	movs	r2, #0
 800afda:	605a      	str	r2, [r3, #4]
#endif
    wolfSSL_X509_STORE_CTX_free(store);
 800afdc:	68f8      	ldr	r0, [r7, #12]
 800afde:	f004 f897 	bl	800f110 <wolfSSL_X509_STORE_CTX_free>
}
 800afe2:	bf00      	nop
 800afe4:	3718      	adds	r7, #24
 800afe6:	46bd      	mov	sp, r7
 800afe8:	bd80      	pop	{r7, pc}
	...

0800afec <DoVerifyCallback>:
 * store->error_depth member to determine index (0=peer, >1 intermediates)
 */

int DoVerifyCallback(WOLFSSL_CERT_MANAGER* cm, WOLFSSL* ssl, int cert_err,
                                                        ProcPeerCertArgs* args)
{
 800afec:	b5f0      	push	{r4, r5, r6, r7, lr}
 800afee:	b091      	sub	sp, #68	@ 0x44
 800aff0:	af04      	add	r7, sp, #16
 800aff2:	60f8      	str	r0, [r7, #12]
 800aff4:	60b9      	str	r1, [r7, #8]
 800aff6:	607a      	str	r2, [r7, #4]
 800aff8:	603b      	str	r3, [r7, #0]
    int verify_ok = 0, use_cb = 0, ret = cert_err;
 800affa:	2300      	movs	r3, #0
 800affc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800affe:	2300      	movs	r3, #0
 800b000:	62bb      	str	r3, [r7, #40]	@ 0x28
 800b002:	687b      	ldr	r3, [r7, #4]
 800b004:	627b      	str	r3, [r7, #36]	@ 0x24
    void *heap;

    if (cm == NULL) {
 800b006:	68fb      	ldr	r3, [r7, #12]
 800b008:	2b00      	cmp	r3, #0
 800b00a:	d102      	bne.n	800b012 <DoVerifyCallback+0x26>
        return BAD_FUNC_ARG;
 800b00c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800b010:	e139      	b.n	800b286 <DoVerifyCallback+0x29a>
    }

    heap = (ssl != NULL) ? ssl->heap : cm->heap;
 800b012:	68bb      	ldr	r3, [r7, #8]
 800b014:	2b00      	cmp	r3, #0
 800b016:	d003      	beq.n	800b020 <DoVerifyCallback+0x34>
 800b018:	68bb      	ldr	r3, [r7, #8]
 800b01a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800b01e:	e001      	b.n	800b024 <DoVerifyCallback+0x38>
 800b020:	68fb      	ldr	r3, [r7, #12]
 800b022:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b024:	61fb      	str	r3, [r7, #28]

    /* Determine if verify was okay */
    if (cert_err == 0) {
 800b026:	687b      	ldr	r3, [r7, #4]
 800b028:	2b00      	cmp	r3, #0
 800b02a:	d101      	bne.n	800b030 <DoVerifyCallback+0x44>
        verify_ok = 1;
 800b02c:	2301      	movs	r3, #1
 800b02e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    }

    /* Determine if verify callback should be used */
    if (cert_err != 0) {
 800b030:	687b      	ldr	r3, [r7, #4]
 800b032:	2b00      	cmp	r3, #0
 800b034:	d00c      	beq.n	800b050 <DoVerifyCallback+0x64>
        if ((ssl != NULL) && (!ssl->options.verifyNone)) {
 800b036:	68bb      	ldr	r3, [r7, #8]
 800b038:	2b00      	cmp	r3, #0
 800b03a:	d009      	beq.n	800b050 <DoVerifyCallback+0x64>
 800b03c:	68bb      	ldr	r3, [r7, #8]
 800b03e:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800b042:	f003 0308 	and.w	r3, r3, #8
 800b046:	b2db      	uxtb	r3, r3
 800b048:	2b00      	cmp	r3, #0
 800b04a:	d101      	bne.n	800b050 <DoVerifyCallback+0x64>
            use_cb = 1; /* always report errors */
 800b04c:	2301      	movs	r3, #1
 800b04e:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
#ifdef WOLFSSL_ALWAYS_VERIFY_CB
    /* always use verify callback on peer leaf cert */
    if (args->certIdx == 0) {
 800b050:	683b      	ldr	r3, [r7, #0]
 800b052:	69db      	ldr	r3, [r3, #28]
 800b054:	2b00      	cmp	r3, #0
 800b056:	d101      	bne.n	800b05c <DoVerifyCallback+0x70>
        use_cb = 1;
 800b058:	2301      	movs	r3, #1
 800b05a:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
#endif
#ifdef WOLFSSL_VERIFY_CB_ALL_CERTS
    /* perform verify callback on other intermediate certs (not just peer) */
    if (args->certIdx > 0) {
 800b05c:	683b      	ldr	r3, [r7, #0]
 800b05e:	69db      	ldr	r3, [r3, #28]
 800b060:	2b00      	cmp	r3, #0
 800b062:	dd01      	ble.n	800b068 <DoVerifyCallback+0x7c>
        use_cb = 1;
 800b064:	2301      	movs	r3, #1
 800b066:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
#endif
#if defined(OPENSSL_EXTRA)
    /* Perform domain and IP check only for the leaf certificate */
    if (args->certIdx == 0) {
 800b068:	683b      	ldr	r3, [r7, #0]
 800b06a:	69db      	ldr	r3, [r3, #28]
 800b06c:	2b00      	cmp	r3, #0
 800b06e:	f040 8098 	bne.w	800b1a2 <DoVerifyCallback+0x1b6>
        /* perform domain name check on the peer certificate */
        if (args->dCertInit && args->dCert && (ssl != NULL) &&
 800b072:	683b      	ldr	r3, [r7, #0]
 800b074:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800b078:	f003 0304 	and.w	r3, r3, #4
 800b07c:	b2db      	uxtb	r3, r3
 800b07e:	2b00      	cmp	r3, #0
 800b080:	d05f      	beq.n	800b142 <DoVerifyCallback+0x156>
 800b082:	683b      	ldr	r3, [r7, #0]
 800b084:	689b      	ldr	r3, [r3, #8]
 800b086:	2b00      	cmp	r3, #0
 800b088:	d05b      	beq.n	800b142 <DoVerifyCallback+0x156>
 800b08a:	68bb      	ldr	r3, [r7, #8]
 800b08c:	2b00      	cmp	r3, #0
 800b08e:	d058      	beq.n	800b142 <DoVerifyCallback+0x156>
                ssl->param && ssl->param->hostName[0]) {
 800b090:	68bb      	ldr	r3, [r7, #8]
 800b092:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
        if (args->dCertInit && args->dCert && (ssl != NULL) &&
 800b096:	2b00      	cmp	r3, #0
 800b098:	d053      	beq.n	800b142 <DoVerifyCallback+0x156>
                ssl->param && ssl->param->hostName[0]) {
 800b09a:	68bb      	ldr	r3, [r7, #8]
 800b09c:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b0a0:	7e1b      	ldrb	r3, [r3, #24]
 800b0a2:	2b00      	cmp	r3, #0
 800b0a4:	d04d      	beq.n	800b142 <DoVerifyCallback+0x156>
            /* If altNames names is present, then subject common name is ignored */
            if (args->dCert->altNames != NULL) {
 800b0a6:	683b      	ldr	r3, [r7, #0]
 800b0a8:	689b      	ldr	r3, [r3, #8]
 800b0aa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b0ac:	2b00      	cmp	r3, #0
 800b0ae:	d01e      	beq.n	800b0ee <DoVerifyCallback+0x102>
                if (CheckForAltNames(args->dCert, ssl->param->hostName,
 800b0b0:	683b      	ldr	r3, [r7, #0]
 800b0b2:	689c      	ldr	r4, [r3, #8]
 800b0b4:	68bb      	ldr	r3, [r7, #8]
 800b0b6:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b0ba:	f103 0518 	add.w	r5, r3, #24
                    (word32)XSTRLEN(ssl->param->hostName), NULL, 0) != 1) {
 800b0be:	68bb      	ldr	r3, [r7, #8]
 800b0c0:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b0c4:	3318      	adds	r3, #24
 800b0c6:	4618      	mov	r0, r3
 800b0c8:	f7f5 f88c 	bl	80001e4 <strlen>
 800b0cc:	4602      	mov	r2, r0
                if (CheckForAltNames(args->dCert, ssl->param->hostName,
 800b0ce:	2300      	movs	r3, #0
 800b0d0:	9300      	str	r3, [sp, #0]
 800b0d2:	2300      	movs	r3, #0
 800b0d4:	4629      	mov	r1, r5
 800b0d6:	4620      	mov	r0, r4
 800b0d8:	f7ff f866 	bl	800a1a8 <CheckForAltNames>
 800b0dc:	4603      	mov	r3, r0
 800b0de:	2b01      	cmp	r3, #1
 800b0e0:	d02f      	beq.n	800b142 <DoVerifyCallback+0x156>
                    if (cert_err == 0) {
 800b0e2:	687b      	ldr	r3, [r7, #4]
 800b0e4:	2b00      	cmp	r3, #0
 800b0e6:	d12c      	bne.n	800b142 <DoVerifyCallback+0x156>
                        ret = DOMAIN_NAME_MISMATCH;
 800b0e8:	4b69      	ldr	r3, [pc, #420]	@ (800b290 <DoVerifyCallback+0x2a4>)
 800b0ea:	627b      	str	r3, [r7, #36]	@ 0x24
 800b0ec:	e029      	b.n	800b142 <DoVerifyCallback+0x156>
                    }
                }
            }
        #ifndef WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY
            else {
                if (args->dCert->subjectCN) {
 800b0ee:	683b      	ldr	r3, [r7, #0]
 800b0f0:	689b      	ldr	r3, [r3, #8]
 800b0f2:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800b0f6:	2b00      	cmp	r3, #0
 800b0f8:	d023      	beq.n	800b142 <DoVerifyCallback+0x156>
                    if (MatchDomainName(
                            args->dCert->subjectCN,
 800b0fa:	683b      	ldr	r3, [r7, #0]
 800b0fc:	689b      	ldr	r3, [r3, #8]
 800b0fe:	f8d3 4084 	ldr.w	r4, [r3, #132]	@ 0x84
                            args->dCert->subjectCNLen,
 800b102:	683b      	ldr	r3, [r7, #0]
 800b104:	689b      	ldr	r3, [r3, #8]
                    if (MatchDomainName(
 800b106:	f8d3 5088 	ldr.w	r5, [r3, #136]	@ 0x88
                            ssl->param->hostName,
 800b10a:	68bb      	ldr	r3, [r7, #8]
 800b10c:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b110:	f103 0618 	add.w	r6, r3, #24
                            (word32)XSTRLEN(ssl->param->hostName), 0) == 0) {
 800b114:	68bb      	ldr	r3, [r7, #8]
 800b116:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b11a:	3318      	adds	r3, #24
 800b11c:	4618      	mov	r0, r3
 800b11e:	f7f5 f861 	bl	80001e4 <strlen>
 800b122:	4603      	mov	r3, r0
                    if (MatchDomainName(
 800b124:	2200      	movs	r2, #0
 800b126:	9200      	str	r2, [sp, #0]
 800b128:	4632      	mov	r2, r6
 800b12a:	4629      	mov	r1, r5
 800b12c:	4620      	mov	r0, r4
 800b12e:	f7fe ff57 	bl	8009fe0 <MatchDomainName>
 800b132:	4603      	mov	r3, r0
 800b134:	2b00      	cmp	r3, #0
 800b136:	d104      	bne.n	800b142 <DoVerifyCallback+0x156>
                        if (cert_err == 0) {
 800b138:	687b      	ldr	r3, [r7, #4]
 800b13a:	2b00      	cmp	r3, #0
 800b13c:	d101      	bne.n	800b142 <DoVerifyCallback+0x156>
                            ret = DOMAIN_NAME_MISMATCH;
 800b13e:	4b54      	ldr	r3, [pc, #336]	@ (800b290 <DoVerifyCallback+0x2a4>)
 800b140:	627b      	str	r3, [r7, #36]	@ 0x24
            }
        #endif /* !WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY */
        }

        /* perform IP address check on the peer certificate */
        if ((args->dCertInit != 0) && (args->dCert != NULL) && (ssl != NULL) &&
 800b142:	683b      	ldr	r3, [r7, #0]
 800b144:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800b148:	f003 0304 	and.w	r3, r3, #4
 800b14c:	b2db      	uxtb	r3, r3
 800b14e:	2b00      	cmp	r3, #0
 800b150:	d027      	beq.n	800b1a2 <DoVerifyCallback+0x1b6>
 800b152:	683b      	ldr	r3, [r7, #0]
 800b154:	689b      	ldr	r3, [r3, #8]
 800b156:	2b00      	cmp	r3, #0
 800b158:	d023      	beq.n	800b1a2 <DoVerifyCallback+0x1b6>
 800b15a:	68bb      	ldr	r3, [r7, #8]
 800b15c:	2b00      	cmp	r3, #0
 800b15e:	d020      	beq.n	800b1a2 <DoVerifyCallback+0x1b6>
            (ssl->param != NULL) && (XSTRLEN(ssl->param->ipasc) > 0)) {
 800b160:	68bb      	ldr	r3, [r7, #8]
 800b162:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
        if ((args->dCertInit != 0) && (args->dCert != NULL) && (ssl != NULL) &&
 800b166:	2b00      	cmp	r3, #0
 800b168:	d01b      	beq.n	800b1a2 <DoVerifyCallback+0x1b6>
            (ssl->param != NULL) && (XSTRLEN(ssl->param->ipasc) > 0)) {
 800b16a:	68bb      	ldr	r3, [r7, #8]
 800b16c:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b170:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800b174:	781b      	ldrb	r3, [r3, #0]
 800b176:	2b00      	cmp	r3, #0
 800b178:	d013      	beq.n	800b1a2 <DoVerifyCallback+0x1b6>
            if (CheckIPAddr(args->dCert, ssl->param->ipasc) != 0) {
 800b17a:	683b      	ldr	r3, [r7, #0]
 800b17c:	689a      	ldr	r2, [r3, #8]
 800b17e:	68bb      	ldr	r3, [r7, #8]
 800b180:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b184:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800b188:	4619      	mov	r1, r3
 800b18a:	4610      	mov	r0, r2
 800b18c:	f7ff f898 	bl	800a2c0 <CheckIPAddr>
 800b190:	4603      	mov	r3, r0
 800b192:	2b00      	cmp	r3, #0
 800b194:	d005      	beq.n	800b1a2 <DoVerifyCallback+0x1b6>
                if (cert_err == 0) {
 800b196:	687b      	ldr	r3, [r7, #4]
 800b198:	2b00      	cmp	r3, #0
 800b19a:	d102      	bne.n	800b1a2 <DoVerifyCallback+0x1b6>
                    ret = IPADDR_MISMATCH;
 800b19c:	f46f 73a2 	mvn.w	r3, #324	@ 0x144
 800b1a0:	627b      	str	r3, [r7, #36]	@ 0x24
            }
        }
    }
#endif
    /* if verify callback has been set */
    if ((use_cb && (ssl != NULL) && ((ssl->verifyCallback != NULL)
 800b1a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b1a4:	2b00      	cmp	r3, #0
 800b1a6:	d007      	beq.n	800b1b8 <DoVerifyCallback+0x1cc>
 800b1a8:	68bb      	ldr	r3, [r7, #8]
 800b1aa:	2b00      	cmp	r3, #0
 800b1ac:	d004      	beq.n	800b1b8 <DoVerifyCallback+0x1cc>
 800b1ae:	68bb      	ldr	r3, [r7, #8]
 800b1b0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b1b4:	2b00      	cmp	r3, #0
 800b1b6:	d103      	bne.n	800b1c0 <DoVerifyCallback+0x1d4>
        (defined(OPENSSL_ALL) || defined(WOLFSSL_QT))
        || (SSL_STORE(ssl) != NULL && SSL_STORE(ssl)->verify_cb != NULL)
    #endif
        ))
    #ifndef NO_WOLFSSL_CM_VERIFY
        || (cm->verifyCallback != NULL)
 800b1b8:	68fb      	ldr	r3, [r7, #12]
 800b1ba:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b1bc:	2b00      	cmp	r3, #0
 800b1be:	d061      	beq.n	800b284 <DoVerifyCallback+0x298>
    #endif
        ) {
        int verifyFail = 0;
 800b1c0:	2300      	movs	r3, #0
 800b1c2:	623b      	str	r3, [r7, #32]
        WOLFSSL_X509_STORE_CTX* store = NULL;
 800b1c4:	2300      	movs	r3, #0
 800b1c6:	617b      	str	r3, [r7, #20]
        int x509Free = 0;
 800b1c8:	2300      	movs	r3, #0
 800b1ca:	613b      	str	r3, [r7, #16]
        int setupRet = SetupStoreCtxCallback(&store, ssl, cm, args, cert_err,
 800b1cc:	f107 0014 	add.w	r0, r7, #20
 800b1d0:	f107 0310 	add.w	r3, r7, #16
 800b1d4:	9302      	str	r3, [sp, #8]
 800b1d6:	69fb      	ldr	r3, [r7, #28]
 800b1d8:	9301      	str	r3, [sp, #4]
 800b1da:	687b      	ldr	r3, [r7, #4]
 800b1dc:	9300      	str	r3, [sp, #0]
 800b1de:	683b      	ldr	r3, [r7, #0]
 800b1e0:	68fa      	ldr	r2, [r7, #12]
 800b1e2:	68b9      	ldr	r1, [r7, #8]
 800b1e4:	f7ff fd2c 	bl	800ac40 <SetupStoreCtxCallback>
 800b1e8:	61b8      	str	r0, [r7, #24]
                heap, &x509Free);

        if (setupRet != 0)
 800b1ea:	69bb      	ldr	r3, [r7, #24]
 800b1ec:	2b00      	cmp	r3, #0
 800b1ee:	d001      	beq.n	800b1f4 <DoVerifyCallback+0x208>
            return setupRet;
 800b1f0:	69bb      	ldr	r3, [r7, #24]
 800b1f2:	e048      	b.n	800b286 <DoVerifyCallback+0x29a>

    #ifndef NO_WOLFSSL_CM_VERIFY
        /* non-zero return code indicates failure override */
        if (cm->verifyCallback != NULL) {
 800b1f4:	68fb      	ldr	r3, [r7, #12]
 800b1f6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b1f8:	2b00      	cmp	r3, #0
 800b1fa:	d013      	beq.n	800b224 <DoVerifyCallback+0x238>
            store->userCtx = cm;
 800b1fc:	697b      	ldr	r3, [r7, #20]
 800b1fe:	68fa      	ldr	r2, [r7, #12]
 800b200:	621a      	str	r2, [r3, #32]
            if (cm->verifyCallback(verify_ok, store)) {
 800b202:	68fb      	ldr	r3, [r7, #12]
 800b204:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b206:	697a      	ldr	r2, [r7, #20]
 800b208:	4611      	mov	r1, r2
 800b20a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b20c:	4798      	blx	r3
 800b20e:	4603      	mov	r3, r0
 800b210:	2b00      	cmp	r3, #0
 800b212:	d005      	beq.n	800b220 <DoVerifyCallback+0x234>
                if (cert_err != 0) {
 800b214:	687b      	ldr	r3, [r7, #4]
 800b216:	2b00      	cmp	r3, #0
 800b218:	d004      	beq.n	800b224 <DoVerifyCallback+0x238>
                    WOLFSSL_MSG("Verify CM callback overriding error!");
                    ret = 0;
 800b21a:	2300      	movs	r3, #0
 800b21c:	627b      	str	r3, [r7, #36]	@ 0x24
 800b21e:	e001      	b.n	800b224 <DoVerifyCallback+0x238>
                }
            }
            else {
                verifyFail = 1;
 800b220:	2301      	movs	r3, #1
 800b222:	623b      	str	r3, [r7, #32]
            }
        }
    #endif

        if (ssl != NULL) {
 800b224:	68bb      	ldr	r3, [r7, #8]
 800b226:	2b00      	cmp	r3, #0
 800b228:	d016      	beq.n	800b258 <DoVerifyCallback+0x26c>
                    verifyFail = 1;
                }
            }
    #endif
            /* non-zero return code indicates failure override */
            if (ssl->verifyCallback) {
 800b22a:	68bb      	ldr	r3, [r7, #8]
 800b22c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b230:	2b00      	cmp	r3, #0
 800b232:	d011      	beq.n	800b258 <DoVerifyCallback+0x26c>
                if (ssl->verifyCallback(verify_ok, store)) {
 800b234:	68bb      	ldr	r3, [r7, #8]
 800b236:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b23a:	697a      	ldr	r2, [r7, #20]
 800b23c:	4611      	mov	r1, r2
 800b23e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b240:	4798      	blx	r3
 800b242:	4603      	mov	r3, r0
 800b244:	2b00      	cmp	r3, #0
 800b246:	d005      	beq.n	800b254 <DoVerifyCallback+0x268>
                    if (cert_err != 0) {
 800b248:	687b      	ldr	r3, [r7, #4]
 800b24a:	2b00      	cmp	r3, #0
 800b24c:	d004      	beq.n	800b258 <DoVerifyCallback+0x26c>
                        WOLFSSL_MSG("Verify callback overriding error!");
                        ret = 0;
 800b24e:	2300      	movs	r3, #0
 800b250:	627b      	str	r3, [r7, #36]	@ 0x24
 800b252:	e001      	b.n	800b258 <DoVerifyCallback+0x26c>
                    }
                }
                else {
                    verifyFail = 1;
 800b254:	2301      	movs	r3, #1
 800b256:	623b      	str	r3, [r7, #32]
                }
            }
#endif
        }

        if (verifyFail) {
 800b258:	6a3b      	ldr	r3, [r7, #32]
 800b25a:	2b00      	cmp	r3, #0
 800b25c:	d00c      	beq.n	800b278 <DoVerifyCallback+0x28c>
            /* induce error if one not present */
            if (cert_err == 0) {
 800b25e:	687b      	ldr	r3, [r7, #4]
 800b260:	2b00      	cmp	r3, #0
 800b262:	d102      	bne.n	800b26a <DoVerifyCallback+0x27e>
                ret = VERIFY_CERT_ERROR;
 800b264:	f46f 73a4 	mvn.w	r3, #328	@ 0x148
 800b268:	627b      	str	r3, [r7, #36]	@ 0x24
                WOLFSSL_ERROR_VERBOSE(ret);
            }

            /* mark as verify error */
            args->verifyErr = 1;
 800b26a:	683a      	ldr	r2, [r7, #0]
 800b26c:	f892 3026 	ldrb.w	r3, [r2, #38]	@ 0x26
 800b270:	f043 0302 	orr.w	r3, r3, #2
 800b274:	f882 3026 	strb.w	r3, [r2, #38]	@ 0x26
        }
        CleanupStoreCtxCallback(store, ssl, heap, x509Free);
 800b278:	6978      	ldr	r0, [r7, #20]
 800b27a:	693b      	ldr	r3, [r7, #16]
 800b27c:	69fa      	ldr	r2, [r7, #28]
 800b27e:	68b9      	ldr	r1, [r7, #8]
 800b280:	f7ff fe8e 	bl	800afa0 <CleanupStoreCtxCallback>
    }

    (void)heap;

    return ret;
 800b284:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800b286:	4618      	mov	r0, r3
 800b288:	3734      	adds	r7, #52	@ 0x34
 800b28a:	46bd      	mov	sp, r7
 800b28c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b28e:	bf00      	nop
 800b290:	fffffebe 	.word	0xfffffebe

0800b294 <wolfSSL_Atomic_Int_FetchSub>:
    static WC_INLINE int wolfSSL_Atomic_Int_FetchSub(int *c, int i) {
 800b294:	b480      	push	{r7}
 800b296:	b085      	sub	sp, #20
 800b298:	af00      	add	r7, sp, #0
 800b29a:	6078      	str	r0, [r7, #4]
 800b29c:	6039      	str	r1, [r7, #0]
        int ret = *c;
 800b29e:	687b      	ldr	r3, [r7, #4]
 800b2a0:	681b      	ldr	r3, [r3, #0]
 800b2a2:	60fb      	str	r3, [r7, #12]
        *c -= i;
 800b2a4:	687b      	ldr	r3, [r7, #4]
 800b2a6:	681a      	ldr	r2, [r3, #0]
 800b2a8:	683b      	ldr	r3, [r7, #0]
 800b2aa:	1ad2      	subs	r2, r2, r3
 800b2ac:	687b      	ldr	r3, [r7, #4]
 800b2ae:	601a      	str	r2, [r3, #0]
        return ret;
 800b2b0:	68fb      	ldr	r3, [r7, #12]
    }
 800b2b2:	4618      	mov	r0, r3
 800b2b4:	3714      	adds	r7, #20
 800b2b6:	46bd      	mov	sp, r7
 800b2b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2bc:	4770      	bx	lr

0800b2be <ForceZero>:
{
 800b2be:	b480      	push	{r7}
 800b2c0:	b085      	sub	sp, #20
 800b2c2:	af00      	add	r7, sp, #0
 800b2c4:	6078      	str	r0, [r7, #4]
 800b2c6:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 800b2c8:	687b      	ldr	r3, [r7, #4]
 800b2ca:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 800b2cc:	e004      	b.n	800b2d8 <ForceZero+0x1a>
 800b2ce:	68fb      	ldr	r3, [r7, #12]
 800b2d0:	1c5a      	adds	r2, r3, #1
 800b2d2:	60fa      	str	r2, [r7, #12]
 800b2d4:	2200      	movs	r2, #0
 800b2d6:	701a      	strb	r2, [r3, #0]
 800b2d8:	683b      	ldr	r3, [r7, #0]
 800b2da:	1e5a      	subs	r2, r3, #1
 800b2dc:	603a      	str	r2, [r7, #0]
 800b2de:	2b00      	cmp	r3, #0
 800b2e0:	d1f5      	bne.n	800b2ce <ForceZero+0x10>
}
 800b2e2:	bf00      	nop
 800b2e4:	bf00      	nop
 800b2e6:	3714      	adds	r7, #20
 800b2e8:	46bd      	mov	sp, r7
 800b2ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2ee:	4770      	bx	lr

0800b2f0 <c32to24>:
#endif /* !WOLFSSL_HAVE_MAX */

#ifndef WOLFSSL_NO_INT_ENCODE
/* converts a 32 bit integer to 24 bit */
WC_MISC_STATIC WC_INLINE void c32to24(word32 in, word24 out)
{
 800b2f0:	b480      	push	{r7}
 800b2f2:	b083      	sub	sp, #12
 800b2f4:	af00      	add	r7, sp, #0
 800b2f6:	6078      	str	r0, [r7, #4]
 800b2f8:	6039      	str	r1, [r7, #0]
    out[0] = (byte)((in >> 16) & 0xff);
 800b2fa:	687b      	ldr	r3, [r7, #4]
 800b2fc:	0c1b      	lsrs	r3, r3, #16
 800b2fe:	b2da      	uxtb	r2, r3
 800b300:	683b      	ldr	r3, [r7, #0]
 800b302:	701a      	strb	r2, [r3, #0]
    out[1] = (byte)((in >>  8) & 0xff);
 800b304:	687b      	ldr	r3, [r7, #4]
 800b306:	0a1a      	lsrs	r2, r3, #8
 800b308:	683b      	ldr	r3, [r7, #0]
 800b30a:	3301      	adds	r3, #1
 800b30c:	b2d2      	uxtb	r2, r2
 800b30e:	701a      	strb	r2, [r3, #0]
    out[2] =  (byte)(in        & 0xff);
 800b310:	683b      	ldr	r3, [r7, #0]
 800b312:	3302      	adds	r3, #2
 800b314:	687a      	ldr	r2, [r7, #4]
 800b316:	b2d2      	uxtb	r2, r2
 800b318:	701a      	strb	r2, [r3, #0]
}
 800b31a:	bf00      	nop
 800b31c:	370c      	adds	r7, #12
 800b31e:	46bd      	mov	sp, r7
 800b320:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b324:	4770      	bx	lr

0800b326 <MakeWordFromHash>:

#if defined(HAVE_SESSION_TICKET) || !defined(NO_CERTS) || \
    !defined(NO_SESSION_CACHE)
/* Make a word from the front of random hash */
WC_MISC_STATIC WC_INLINE word32 MakeWordFromHash(const byte* hashID)
{
 800b326:	b480      	push	{r7}
 800b328:	b083      	sub	sp, #12
 800b32a:	af00      	add	r7, sp, #0
 800b32c:	6078      	str	r0, [r7, #4]
    return ((word32)hashID[0] << 24) | ((word32)hashID[1] << 16) |
 800b32e:	687b      	ldr	r3, [r7, #4]
 800b330:	781b      	ldrb	r3, [r3, #0]
 800b332:	061a      	lsls	r2, r3, #24
 800b334:	687b      	ldr	r3, [r7, #4]
 800b336:	3301      	adds	r3, #1
 800b338:	781b      	ldrb	r3, [r3, #0]
 800b33a:	041b      	lsls	r3, r3, #16
 800b33c:	431a      	orrs	r2, r3
           ((word32)hashID[2] <<  8) |  (word32)hashID[3];
 800b33e:	687b      	ldr	r3, [r7, #4]
 800b340:	3302      	adds	r3, #2
 800b342:	781b      	ldrb	r3, [r3, #0]
 800b344:	021b      	lsls	r3, r3, #8
    return ((word32)hashID[0] << 24) | ((word32)hashID[1] << 16) |
 800b346:	4313      	orrs	r3, r2
           ((word32)hashID[2] <<  8) |  (word32)hashID[3];
 800b348:	687a      	ldr	r2, [r7, #4]
 800b34a:	3203      	adds	r2, #3
 800b34c:	7812      	ldrb	r2, [r2, #0]
 800b34e:	4313      	orrs	r3, r2
}
 800b350:	4618      	mov	r0, r3
 800b352:	370c      	adds	r7, #12
 800b354:	46bd      	mov	sp, r7
 800b356:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b35a:	4770      	bx	lr

0800b35c <static_buffer_init>:
/* Initialize static buffer.
 *
 * @param [in, out] sb  Static buffer.
 */
static void static_buffer_init(StaticBuffer* sb)
{
 800b35c:	b480      	push	{r7}
 800b35e:	b083      	sub	sp, #12
 800b360:	af00      	add	r7, sp, #0
 800b362:	6078      	str	r0, [r7, #4]
    sb->buffer = NULL;
 800b364:	687b      	ldr	r3, [r7, #4]
 800b366:	2200      	movs	r2, #0
 800b368:	601a      	str	r2, [r3, #0]
    sb->sz = 0;
 800b36a:	687b      	ldr	r3, [r7, #4]
 800b36c:	2200      	movs	r2, #0
 800b36e:	605a      	str	r2, [r3, #4]
}
 800b370:	bf00      	nop
 800b372:	370c      	adds	r7, #12
 800b374:	46bd      	mov	sp, r7
 800b376:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b37a:	4770      	bx	lr

0800b37c <static_buffer_set_size>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int static_buffer_set_size(StaticBuffer* sb, word32 len, void* heap,
    int type)
{
 800b37c:	b580      	push	{r7, lr}
 800b37e:	b086      	sub	sp, #24
 800b380:	af00      	add	r7, sp, #0
 800b382:	60f8      	str	r0, [r7, #12]
 800b384:	60b9      	str	r1, [r7, #8]
 800b386:	607a      	str	r2, [r7, #4]
 800b388:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800b38a:	2300      	movs	r3, #0
 800b38c:	617b      	str	r3, [r7, #20]

    (void)heap;
    (void)type;

    sb->buffer = (byte*)XMALLOC(len, heap, type);
 800b38e:	68b8      	ldr	r0, [r7, #8]
 800b390:	f013 fc74 	bl	801ec7c <wolfSSL_Malloc>
 800b394:	4602      	mov	r2, r0
 800b396:	68fb      	ldr	r3, [r7, #12]
 800b398:	601a      	str	r2, [r3, #0]
    if (sb->buffer == NULL) {
 800b39a:	68fb      	ldr	r3, [r7, #12]
 800b39c:	681b      	ldr	r3, [r3, #0]
 800b39e:	2b00      	cmp	r3, #0
 800b3a0:	d103      	bne.n	800b3aa <static_buffer_set_size+0x2e>
        ret = MEMORY_E;
 800b3a2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800b3a6:	617b      	str	r3, [r7, #20]
 800b3a8:	e002      	b.n	800b3b0 <static_buffer_set_size+0x34>
    }
    else {
        sb->sz = len;
 800b3aa:	68fb      	ldr	r3, [r7, #12]
 800b3ac:	68ba      	ldr	r2, [r7, #8]
 800b3ae:	605a      	str	r2, [r3, #4]
    }

    return ret;
 800b3b0:	697b      	ldr	r3, [r7, #20]
}
 800b3b2:	4618      	mov	r0, r3
 800b3b4:	3718      	adds	r7, #24
 800b3b6:	46bd      	mov	sp, r7
 800b3b8:	bd80      	pop	{r7, pc}

0800b3ba <static_buffer_free>:
 * @param [in] sb    Static buffer.
 * @param [in] heap  Dynamic memory allocation hint.
 * @param [in] type  Type of dynamic memory.
 */
static void static_buffer_free(StaticBuffer* sb, void* heap, int type)
{
 800b3ba:	b580      	push	{r7, lr}
 800b3bc:	b086      	sub	sp, #24
 800b3be:	af00      	add	r7, sp, #0
 800b3c0:	60f8      	str	r0, [r7, #12]
 800b3c2:	60b9      	str	r1, [r7, #8]
 800b3c4:	607a      	str	r2, [r7, #4]
    (void)heap;
    (void)type;
    XFREE(sb->buffer, heap, type);
 800b3c6:	68fb      	ldr	r3, [r7, #12]
 800b3c8:	681b      	ldr	r3, [r3, #0]
 800b3ca:	617b      	str	r3, [r7, #20]
 800b3cc:	697b      	ldr	r3, [r7, #20]
 800b3ce:	2b00      	cmp	r3, #0
 800b3d0:	d002      	beq.n	800b3d8 <static_buffer_free+0x1e>
 800b3d2:	6978      	ldr	r0, [r7, #20]
 800b3d4:	f013 fc6e 	bl	801ecb4 <wolfSSL_Free>
}
 800b3d8:	bf00      	nop
 800b3da:	3718      	adds	r7, #24
 800b3dc:	46bd      	mov	sp, r7
 800b3de:	bd80      	pop	{r7, pc}

0800b3e0 <wolfSSL_EVP_PKEY_CTX_free>:
#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x10100000L
void wolfSSL_EVP_PKEY_CTX_free(WOLFSSL_EVP_PKEY_CTX *ctx)
#else
int wolfSSL_EVP_PKEY_CTX_free(WOLFSSL_EVP_PKEY_CTX *ctx)
#endif
{
 800b3e0:	b580      	push	{r7, lr}
 800b3e2:	b084      	sub	sp, #16
 800b3e4:	af00      	add	r7, sp, #0
 800b3e6:	6078      	str	r0, [r7, #4]
    if (ctx == NULL)
 800b3e8:	687b      	ldr	r3, [r7, #4]
 800b3ea:	2b00      	cmp	r3, #0
 800b3ec:	d101      	bne.n	800b3f2 <wolfSSL_EVP_PKEY_CTX_free+0x12>
#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x10100000L
        return;
#else
        return 0;
 800b3ee:	2300      	movs	r3, #0
 800b3f0:	e01a      	b.n	800b428 <wolfSSL_EVP_PKEY_CTX_free+0x48>
#endif
    WOLFSSL_ENTER("wolfSSL_EVP_PKEY_CTX_free");
    if (ctx->pkey != NULL)
 800b3f2:	687b      	ldr	r3, [r7, #4]
 800b3f4:	681b      	ldr	r3, [r3, #0]
 800b3f6:	2b00      	cmp	r3, #0
 800b3f8:	d004      	beq.n	800b404 <wolfSSL_EVP_PKEY_CTX_free+0x24>
        wolfSSL_EVP_PKEY_free(ctx->pkey);
 800b3fa:	687b      	ldr	r3, [r7, #4]
 800b3fc:	681b      	ldr	r3, [r3, #0]
 800b3fe:	4618      	mov	r0, r3
 800b400:	f000 f894 	bl	800b52c <wolfSSL_EVP_PKEY_free>
    if (ctx->peerKey != NULL)
 800b404:	687b      	ldr	r3, [r7, #4]
 800b406:	685b      	ldr	r3, [r3, #4]
 800b408:	2b00      	cmp	r3, #0
 800b40a:	d004      	beq.n	800b416 <wolfSSL_EVP_PKEY_CTX_free+0x36>
        wolfSSL_EVP_PKEY_free(ctx->peerKey);
 800b40c:	687b      	ldr	r3, [r7, #4]
 800b40e:	685b      	ldr	r3, [r3, #4]
 800b410:	4618      	mov	r0, r3
 800b412:	f000 f88b 	bl	800b52c <wolfSSL_EVP_PKEY_free>
    XFREE(ctx, NULL, DYNAMIC_TYPE_PUBLIC_KEY);
 800b416:	687b      	ldr	r3, [r7, #4]
 800b418:	60fb      	str	r3, [r7, #12]
 800b41a:	68fb      	ldr	r3, [r7, #12]
 800b41c:	2b00      	cmp	r3, #0
 800b41e:	d002      	beq.n	800b426 <wolfSSL_EVP_PKEY_CTX_free+0x46>
 800b420:	68f8      	ldr	r0, [r7, #12]
 800b422:	f013 fc47 	bl	801ecb4 <wolfSSL_Free>
#if !defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER < 0x10100000L
    return WOLFSSL_SUCCESS;
 800b426:	2301      	movs	r3, #1
#endif
}
 800b428:	4618      	mov	r0, r3
 800b42a:	3710      	adds	r7, #16
 800b42c:	46bd      	mov	sp, r7
 800b42e:	bd80      	pop	{r7, pc}

0800b430 <wolfSSL_EVP_init>:

    return NULL;
}

void wolfSSL_EVP_init(void)
{
 800b430:	b480      	push	{r7}
 800b432:	af00      	add	r7, sp, #0
    /* Does nothing. */
}
 800b434:	bf00      	nop
 800b436:	46bd      	mov	sp, r7
 800b438:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b43c:	4770      	bx	lr

0800b43e <wolfSSL_EVP_MD_CTX_free>:
        }
        return ctx;
    }

    void wolfSSL_EVP_MD_CTX_free(WOLFSSL_EVP_MD_CTX *ctx)
    {
 800b43e:	b580      	push	{r7, lr}
 800b440:	b084      	sub	sp, #16
 800b442:	af00      	add	r7, sp, #0
 800b444:	6078      	str	r0, [r7, #4]
        if (ctx) {
 800b446:	687b      	ldr	r3, [r7, #4]
 800b448:	2b00      	cmp	r3, #0
 800b44a:	d00a      	beq.n	800b462 <wolfSSL_EVP_MD_CTX_free+0x24>
            WOLFSSL_ENTER("EVP_MD_CTX_free");
            wolfSSL_EVP_MD_CTX_cleanup(ctx);
 800b44c:	6878      	ldr	r0, [r7, #4]
 800b44e:	f000 f80d 	bl	800b46c <wolfSSL_EVP_MD_CTX_cleanup>
            XFREE(ctx, NULL, DYNAMIC_TYPE_OPENSSL);
 800b452:	687b      	ldr	r3, [r7, #4]
 800b454:	60fb      	str	r3, [r7, #12]
 800b456:	68fb      	ldr	r3, [r7, #12]
 800b458:	2b00      	cmp	r3, #0
 800b45a:	d002      	beq.n	800b462 <wolfSSL_EVP_MD_CTX_free+0x24>
 800b45c:	68f8      	ldr	r0, [r7, #12]
 800b45e:	f013 fc29 	bl	801ecb4 <wolfSSL_Free>
        }
    }
 800b462:	bf00      	nop
 800b464:	3710      	adds	r7, #16
 800b466:	46bd      	mov	sp, r7
 800b468:	bd80      	pop	{r7, pc}
	...

0800b46c <wolfSSL_EVP_MD_CTX_cleanup>:
                break;
        }
    }

    int wolfSSL_EVP_MD_CTX_cleanup(WOLFSSL_EVP_MD_CTX* ctx)
    {
 800b46c:	b580      	push	{r7, lr}
 800b46e:	b084      	sub	sp, #16
 800b470:	af00      	add	r7, sp, #0
 800b472:	6078      	str	r0, [r7, #4]
        int ret = WOLFSSL_SUCCESS;
 800b474:	2301      	movs	r3, #1
 800b476:	60fb      	str	r3, [r7, #12]
        WOLFSSL_ENTER("wolfSSL_EVP_MD_CTX_cleanup");
    #ifdef OPENSSL_EXTRA
        if (ctx->pctx != NULL)
 800b478:	687b      	ldr	r3, [r7, #4]
 800b47a:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 800b47e:	2b00      	cmp	r3, #0
 800b480:	d005      	beq.n	800b48e <wolfSSL_EVP_MD_CTX_cleanup+0x22>
            wolfSSL_EVP_PKEY_CTX_free(ctx->pctx);
 800b482:	687b      	ldr	r3, [r7, #4]
 800b484:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 800b488:	4618      	mov	r0, r3
 800b48a:	f7ff ffa9 	bl	800b3e0 <wolfSSL_EVP_PKEY_CTX_free>
    #endif

        if (ctx->isHMAC) {
 800b48e:	687b      	ldr	r3, [r7, #4]
 800b490:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 800b494:	2b00      	cmp	r3, #0
 800b496:	d004      	beq.n	800b4a2 <wolfSSL_EVP_MD_CTX_cleanup+0x36>
            wc_HmacFree(&ctx->hash.hmac);
 800b498:	687b      	ldr	r3, [r7, #4]
 800b49a:	4618      	mov	r0, r3
 800b49c:	f013 f977 	bl	801e78e <wc_HmacFree>
 800b4a0:	e035      	b.n	800b50e <wolfSSL_EVP_MD_CTX_cleanup+0xa2>
        }
        else {
            switch (ctx->macType) {
 800b4a2:	687b      	ldr	r3, [r7, #4]
 800b4a4:	f893 31a8 	ldrb.w	r3, [r3, #424]	@ 0x1a8
 800b4a8:	2b11      	cmp	r3, #17
 800b4aa:	d82c      	bhi.n	800b506 <wolfSSL_EVP_MD_CTX_cleanup+0x9a>
 800b4ac:	a201      	add	r2, pc, #4	@ (adr r2, 800b4b4 <wolfSSL_EVP_MD_CTX_cleanup+0x48>)
 800b4ae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b4b2:	bf00      	nop
 800b4b4:	0800b50d 	.word	0x0800b50d
 800b4b8:	0800b507 	.word	0x0800b507
 800b4bc:	0800b507 	.word	0x0800b507
 800b4c0:	0800b50d 	.word	0x0800b50d
 800b4c4:	0800b50d 	.word	0x0800b50d
 800b4c8:	0800b50d 	.word	0x0800b50d
 800b4cc:	0800b4fd 	.word	0x0800b4fd
 800b4d0:	0800b50d 	.word	0x0800b50d
 800b4d4:	0800b50d 	.word	0x0800b50d
 800b4d8:	0800b507 	.word	0x0800b507
 800b4dc:	0800b50d 	.word	0x0800b50d
 800b4e0:	0800b50d 	.word	0x0800b50d
 800b4e4:	0800b50d 	.word	0x0800b50d
 800b4e8:	0800b50d 	.word	0x0800b50d
 800b4ec:	0800b507 	.word	0x0800b507
 800b4f0:	0800b507 	.word	0x0800b507
 800b4f4:	0800b50d 	.word	0x0800b50d
 800b4f8:	0800b50d 	.word	0x0800b50d
                    wc_Sha224Free((wc_Sha224*)&ctx->hash.digest);
            #endif /* WOLFSSL_SHA224 */
                    break;
                case WC_HASH_TYPE_SHA256:
            #ifndef NO_SHA256
                    wc_Sha256Free((wc_Sha256*)&ctx->hash.digest);
 800b4fc:	687b      	ldr	r3, [r7, #4]
 800b4fe:	4618      	mov	r0, r3
 800b500:	f016 fe7d 	bl	80221fe <wc_Sha256Free>
            #endif /* !NO_SHA256 */
                    break;
 800b504:	e003      	b.n	800b50e <wolfSSL_EVP_MD_CTX_cleanup+0xa2>
            #endif
            #if defined(WOLFSSL_SHA3) && defined(WOLFSSL_SHAKE256)
                case WC_HASH_TYPE_SHAKE256:
            #endif
                default:
                    ret = WOLFSSL_FAILURE;
 800b506:	2300      	movs	r3, #0
 800b508:	60fb      	str	r3, [r7, #12]
                    break;
 800b50a:	e000      	b.n	800b50e <wolfSSL_EVP_MD_CTX_cleanup+0xa2>
                    break;
 800b50c:	bf00      	nop
            }
        }
        ForceZero(ctx, sizeof(*ctx));
 800b50e:	f44f 71da 	mov.w	r1, #436	@ 0x1b4
 800b512:	6878      	ldr	r0, [r7, #4]
 800b514:	f7ff fed3 	bl	800b2be <ForceZero>
        ctx->macType = WC_HASH_TYPE_NONE;
 800b518:	687b      	ldr	r3, [r7, #4]
 800b51a:	2200      	movs	r2, #0
 800b51c:	f883 21a8 	strb.w	r2, [r3, #424]	@ 0x1a8
        return ret;
 800b520:	68fb      	ldr	r3, [r7, #12]
    }
 800b522:	4618      	mov	r0, r3
 800b524:	3710      	adds	r7, #16
 800b526:	46bd      	mov	sp, r7
 800b528:	bd80      	pop	{r7, pc}
 800b52a:	bf00      	nop

0800b52c <wolfSSL_EVP_PKEY_free>:

    return pkey;
}

void wolfSSL_EVP_PKEY_free(WOLFSSL_EVP_PKEY* key)
{
 800b52c:	b580      	push	{r7, lr}
 800b52e:	b08a      	sub	sp, #40	@ 0x28
 800b530:	af00      	add	r7, sp, #0
 800b532:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800b534:	2300      	movs	r3, #0
 800b536:	60fb      	str	r3, [r7, #12]
    WOLFSSL_ENTER("wolfSSL_EVP_PKEY_free");
    if (key != NULL) {
 800b538:	687b      	ldr	r3, [r7, #4]
 800b53a:	2b00      	cmp	r3, #0
 800b53c:	f000 80b8 	beq.w	800b6b0 <wolfSSL_EVP_PKEY_free+0x184>
        int ret;
        wolfSSL_RefDec(&key->ref, &doFree, &ret);
 800b540:	687b      	ldr	r3, [r7, #4]
 800b542:	3310      	adds	r3, #16
 800b544:	2101      	movs	r1, #1
 800b546:	4618      	mov	r0, r3
 800b548:	f7ff fea4 	bl	800b294 <wolfSSL_Atomic_Int_FetchSub>
 800b54c:	6278      	str	r0, [r7, #36]	@ 0x24
 800b54e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b550:	2b01      	cmp	r3, #1
 800b552:	bf0c      	ite	eq
 800b554:	2301      	moveq	r3, #1
 800b556:	2300      	movne	r3, #0
 800b558:	b2db      	uxtb	r3, r3
 800b55a:	60fb      	str	r3, [r7, #12]
 800b55c:	2300      	movs	r3, #0
 800b55e:	60bb      	str	r3, [r7, #8]
        }
    #else
        (void)ret;
    #endif

        if (doFree) {
 800b560:	68fb      	ldr	r3, [r7, #12]
 800b562:	2b00      	cmp	r3, #0
 800b564:	f000 80a4 	beq.w	800b6b0 <wolfSSL_EVP_PKEY_free+0x184>
            wc_FreeRng(&key->rng);
 800b568:	687b      	ldr	r3, [r7, #4]
 800b56a:	3324      	adds	r3, #36	@ 0x24
 800b56c:	4618      	mov	r0, r3
 800b56e:	f014 f9ad 	bl	801f8cc <wc_FreeRng>

            if (key->pkey.ptr != NULL) {
 800b572:	687b      	ldr	r3, [r7, #4]
 800b574:	695b      	ldr	r3, [r3, #20]
 800b576:	2b00      	cmp	r3, #0
 800b578:	d00b      	beq.n	800b592 <wolfSSL_EVP_PKEY_free+0x66>
                XFREE(key->pkey.ptr, key->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800b57a:	687b      	ldr	r3, [r7, #4]
 800b57c:	695b      	ldr	r3, [r3, #20]
 800b57e:	623b      	str	r3, [r7, #32]
 800b580:	6a3b      	ldr	r3, [r7, #32]
 800b582:	2b00      	cmp	r3, #0
 800b584:	d002      	beq.n	800b58c <wolfSSL_EVP_PKEY_free+0x60>
 800b586:	6a38      	ldr	r0, [r7, #32]
 800b588:	f013 fb94 	bl	801ecb4 <wolfSSL_Free>
                key->pkey.ptr = NULL;
 800b58c:	687b      	ldr	r3, [r7, #4]
 800b58e:	2200      	movs	r2, #0
 800b590:	615a      	str	r2, [r3, #20]
            }
            switch(key->type)
 800b592:	687b      	ldr	r3, [r7, #4]
 800b594:	685b      	ldr	r3, [r3, #4]
 800b596:	f240 420c 	movw	r2, #1036	@ 0x40c
 800b59a:	4293      	cmp	r3, r2
 800b59c:	d04b      	beq.n	800b636 <wolfSSL_EVP_PKEY_free+0x10a>
 800b59e:	f240 420c 	movw	r2, #1036	@ 0x40c
 800b5a2:	4293      	cmp	r3, r2
 800b5a4:	dc75      	bgt.n	800b692 <wolfSSL_EVP_PKEY_free+0x166>
 800b5a6:	2b1c      	cmp	r3, #28
 800b5a8:	d030      	beq.n	800b60c <wolfSSL_EVP_PKEY_free+0xe0>
 800b5aa:	2b1c      	cmp	r3, #28
 800b5ac:	dc71      	bgt.n	800b692 <wolfSSL_EVP_PKEY_free+0x166>
 800b5ae:	2b10      	cmp	r3, #16
 800b5b0:	d002      	beq.n	800b5b8 <wolfSSL_EVP_PKEY_free+0x8c>
 800b5b2:	2b12      	cmp	r3, #18
 800b5b4:	d015      	beq.n	800b5e2 <wolfSSL_EVP_PKEY_free+0xb6>
                    }
                    break;
                #endif /* defined(WOLFSSL_CMAC) ... */

                default:
                    break;
 800b5b6:	e06c      	b.n	800b692 <wolfSSL_EVP_PKEY_free+0x166>
                    if (key->rsa != NULL && key->ownRsa == 1) {
 800b5b8:	687b      	ldr	r3, [r7, #4]
 800b5ba:	699b      	ldr	r3, [r3, #24]
 800b5bc:	2b00      	cmp	r3, #0
 800b5be:	d06a      	beq.n	800b696 <wolfSSL_EVP_PKEY_free+0x16a>
 800b5c0:	687b      	ldr	r3, [r7, #4]
 800b5c2:	f893 305a 	ldrb.w	r3, [r3, #90]	@ 0x5a
 800b5c6:	f003 0308 	and.w	r3, r3, #8
 800b5ca:	b2db      	uxtb	r3, r3
 800b5cc:	2b00      	cmp	r3, #0
 800b5ce:	d062      	beq.n	800b696 <wolfSSL_EVP_PKEY_free+0x16a>
                        wolfSSL_RSA_free(key->rsa);
 800b5d0:	687b      	ldr	r3, [r7, #4]
 800b5d2:	699b      	ldr	r3, [r3, #24]
 800b5d4:	4618      	mov	r0, r3
 800b5d6:	f000 fc9d 	bl	800bf14 <wolfSSL_RSA_free>
                        key->rsa = NULL;
 800b5da:	687b      	ldr	r3, [r7, #4]
 800b5dc:	2200      	movs	r2, #0
 800b5de:	619a      	str	r2, [r3, #24]
                    break;
 800b5e0:	e059      	b.n	800b696 <wolfSSL_EVP_PKEY_free+0x16a>
                    if (key->ecc != NULL && key->ownEcc == 1) {
 800b5e2:	687b      	ldr	r3, [r7, #4]
 800b5e4:	69db      	ldr	r3, [r3, #28]
 800b5e6:	2b00      	cmp	r3, #0
 800b5e8:	d057      	beq.n	800b69a <wolfSSL_EVP_PKEY_free+0x16e>
 800b5ea:	687b      	ldr	r3, [r7, #4]
 800b5ec:	f893 305a 	ldrb.w	r3, [r3, #90]	@ 0x5a
 800b5f0:	f003 0302 	and.w	r3, r3, #2
 800b5f4:	b2db      	uxtb	r3, r3
 800b5f6:	2b00      	cmp	r3, #0
 800b5f8:	d04f      	beq.n	800b69a <wolfSSL_EVP_PKEY_free+0x16e>
                        wolfSSL_EC_KEY_free(key->ecc);
 800b5fa:	687b      	ldr	r3, [r7, #4]
 800b5fc:	69db      	ldr	r3, [r3, #28]
 800b5fe:	4618      	mov	r0, r3
 800b600:	f000 fdca 	bl	800c198 <wolfSSL_EC_KEY_free>
                        key->ecc = NULL;
 800b604:	687b      	ldr	r3, [r7, #4]
 800b606:	2200      	movs	r2, #0
 800b608:	61da      	str	r2, [r3, #28]
                    break;
 800b60a:	e046      	b.n	800b69a <wolfSSL_EVP_PKEY_free+0x16e>
                    if (key->dh != NULL && key->ownDh == 1) {
 800b60c:	687b      	ldr	r3, [r7, #4]
 800b60e:	6a1b      	ldr	r3, [r3, #32]
 800b610:	2b00      	cmp	r3, #0
 800b612:	d044      	beq.n	800b69e <wolfSSL_EVP_PKEY_free+0x172>
 800b614:	687b      	ldr	r3, [r7, #4]
 800b616:	f893 305a 	ldrb.w	r3, [r3, #90]	@ 0x5a
 800b61a:	f003 0301 	and.w	r3, r3, #1
 800b61e:	b2db      	uxtb	r3, r3
 800b620:	2b00      	cmp	r3, #0
 800b622:	d03c      	beq.n	800b69e <wolfSSL_EVP_PKEY_free+0x172>
                        wolfSSL_DH_free(key->dh);
 800b624:	687b      	ldr	r3, [r7, #4]
 800b626:	6a1b      	ldr	r3, [r3, #32]
 800b628:	4618      	mov	r0, r3
 800b62a:	f000 fd0d 	bl	800c048 <wolfSSL_DH_free>
                        key->dh = NULL;
 800b62e:	687b      	ldr	r3, [r7, #4]
 800b630:	2200      	movs	r2, #0
 800b632:	621a      	str	r2, [r3, #32]
                    break;
 800b634:	e033      	b.n	800b69e <wolfSSL_EVP_PKEY_free+0x172>
                    XFREE(key->hkdfSalt, NULL, DYNAMIC_TYPE_SALT);
 800b636:	687b      	ldr	r3, [r7, #4]
 800b638:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800b63a:	61fb      	str	r3, [r7, #28]
 800b63c:	69fb      	ldr	r3, [r7, #28]
 800b63e:	2b00      	cmp	r3, #0
 800b640:	d002      	beq.n	800b648 <wolfSSL_EVP_PKEY_free+0x11c>
 800b642:	69f8      	ldr	r0, [r7, #28]
 800b644:	f013 fb36 	bl	801ecb4 <wolfSSL_Free>
                    key->hkdfSalt = NULL;
 800b648:	687b      	ldr	r3, [r7, #4]
 800b64a:	2200      	movs	r2, #0
 800b64c:	639a      	str	r2, [r3, #56]	@ 0x38
                    XFREE(key->hkdfKey, NULL, DYNAMIC_TYPE_KEY);
 800b64e:	687b      	ldr	r3, [r7, #4]
 800b650:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b652:	61bb      	str	r3, [r7, #24]
 800b654:	69bb      	ldr	r3, [r7, #24]
 800b656:	2b00      	cmp	r3, #0
 800b658:	d002      	beq.n	800b660 <wolfSSL_EVP_PKEY_free+0x134>
 800b65a:	69b8      	ldr	r0, [r7, #24]
 800b65c:	f013 fb2a 	bl	801ecb4 <wolfSSL_Free>
                    key->hkdfKey = NULL;
 800b660:	687b      	ldr	r3, [r7, #4]
 800b662:	2200      	movs	r2, #0
 800b664:	641a      	str	r2, [r3, #64]	@ 0x40
                    XFREE(key->hkdfInfo, NULL, DYNAMIC_TYPE_INFO);
 800b666:	687b      	ldr	r3, [r7, #4]
 800b668:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b66a:	617b      	str	r3, [r7, #20]
 800b66c:	697b      	ldr	r3, [r7, #20]
 800b66e:	2b00      	cmp	r3, #0
 800b670:	d002      	beq.n	800b678 <wolfSSL_EVP_PKEY_free+0x14c>
 800b672:	6978      	ldr	r0, [r7, #20]
 800b674:	f013 fb1e 	bl	801ecb4 <wolfSSL_Free>
                    key->hkdfInfo = NULL;
 800b678:	687b      	ldr	r3, [r7, #4]
 800b67a:	2200      	movs	r2, #0
 800b67c:	649a      	str	r2, [r3, #72]	@ 0x48
                    key->hkdfSaltSz = 0;
 800b67e:	687b      	ldr	r3, [r7, #4]
 800b680:	2200      	movs	r2, #0
 800b682:	63da      	str	r2, [r3, #60]	@ 0x3c
                    key->hkdfKeySz = 0;
 800b684:	687b      	ldr	r3, [r7, #4]
 800b686:	2200      	movs	r2, #0
 800b688:	645a      	str	r2, [r3, #68]	@ 0x44
                    key->hkdfInfoSz = 0;
 800b68a:	687b      	ldr	r3, [r7, #4]
 800b68c:	2200      	movs	r2, #0
 800b68e:	64da      	str	r2, [r3, #76]	@ 0x4c
                    break;
 800b690:	e006      	b.n	800b6a0 <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b692:	bf00      	nop
 800b694:	e004      	b.n	800b6a0 <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b696:	bf00      	nop
 800b698:	e002      	b.n	800b6a0 <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b69a:	bf00      	nop
 800b69c:	e000      	b.n	800b6a0 <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b69e:	bf00      	nop
            }

            wolfSSL_RefFree(&key->ref);
            XFREE(key, key->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800b6a0:	687b      	ldr	r3, [r7, #4]
 800b6a2:	613b      	str	r3, [r7, #16]
 800b6a4:	693b      	ldr	r3, [r7, #16]
 800b6a6:	2b00      	cmp	r3, #0
 800b6a8:	d002      	beq.n	800b6b0 <wolfSSL_EVP_PKEY_free+0x184>
 800b6aa:	6938      	ldr	r0, [r7, #16]
 800b6ac:	f013 fb02 	bl	801ecb4 <wolfSSL_Free>
        }
    }
}
 800b6b0:	bf00      	nop
 800b6b2:	3728      	adds	r7, #40	@ 0x28
 800b6b4:	46bd      	mov	sp, r7
 800b6b6:	bd80      	pop	{r7, pc}

0800b6b8 <wolfSSL_CertManagerNew_ex>:
 * @param [in] heap  Heap hint.
 * @return  Certificate manager object on success.
 * @return  NULL on failure.
 */
WOLFSSL_CERT_MANAGER* wolfSSL_CertManagerNew_ex(void* heap)
{
 800b6b8:	b580      	push	{r7, lr}
 800b6ba:	b084      	sub	sp, #16
 800b6bc:	af00      	add	r7, sp, #0
 800b6be:	6078      	str	r0, [r7, #4]
    int err = 0;
 800b6c0:	2300      	movs	r3, #0
 800b6c2:	60bb      	str	r3, [r7, #8]
    }
    WOLFSSL_MSG_EX("DYNAMIC_TYPE_CERT_MANAGER Allocating = %d bytes",
                    (word32)sizeof(WOLFSSL_CERT_MANAGER));

    /* Allocate memory for certificate manager. */
    cm = (WOLFSSL_CERT_MANAGER*)XMALLOC(sizeof(WOLFSSL_CERT_MANAGER), heap,
 800b6c4:	2070      	movs	r0, #112	@ 0x70
 800b6c6:	f013 fad9 	bl	801ec7c <wolfSSL_Malloc>
 800b6ca:	60f8      	str	r0, [r7, #12]
        DYNAMIC_TYPE_CERT_MANAGER);
    if (cm == NULL) {
 800b6cc:	68fb      	ldr	r3, [r7, #12]
 800b6ce:	2b00      	cmp	r3, #0
 800b6d0:	d101      	bne.n	800b6d6 <wolfSSL_CertManagerNew_ex+0x1e>
        WOLFSSL_MSG_EX("XMALLOC failed to allocate WOLFSSL_CERT_MANAGER %d "
                    "bytes.", (int)sizeof(WOLFSSL_CERT_MANAGER));
        err = 1;
 800b6d2:	2301      	movs	r3, #1
 800b6d4:	60bb      	str	r3, [r7, #8]
    }
    if (!err) {
 800b6d6:	68bb      	ldr	r3, [r7, #8]
 800b6d8:	2b00      	cmp	r3, #0
 800b6da:	d10e      	bne.n	800b6fa <wolfSSL_CertManagerNew_ex+0x42>
        /* Reset all fields. */
        XMEMSET(cm, 0, sizeof(WOLFSSL_CERT_MANAGER));
 800b6dc:	2270      	movs	r2, #112	@ 0x70
 800b6de:	2100      	movs	r1, #0
 800b6e0:	68f8      	ldr	r0, [r7, #12]
 800b6e2:	f01d fa9f 	bl	8028c24 <memset>

        /* Create a mutex for use when modify table of stored CAs. */
        if (wc_InitMutex(&cm->caLock) != 0) {
 800b6e6:	68fb      	ldr	r3, [r7, #12]
 800b6e8:	335c      	adds	r3, #92	@ 0x5c
 800b6ea:	4618      	mov	r0, r3
 800b6ec:	f01b ffea 	bl	80276c4 <wc_InitMutex>
 800b6f0:	4603      	mov	r3, r0
 800b6f2:	2b00      	cmp	r3, #0
 800b6f4:	d001      	beq.n	800b6fa <wolfSSL_CertManagerNew_ex+0x42>
            WOLFSSL_MSG("Bad mutex init");
            err = 1;
 800b6f6:	2301      	movs	r3, #1
 800b6f8:	60bb      	str	r3, [r7, #8]
        }
    }
    if (!err) {
 800b6fa:	68bb      	ldr	r3, [r7, #8]
 800b6fc:	2b00      	cmp	r3, #0
 800b6fe:	d104      	bne.n	800b70a <wolfSSL_CertManagerNew_ex+0x52>
        /* Initialize reference count. */
        wolfSSL_RefInit(&cm->ref, &err);
 800b700:	68fb      	ldr	r3, [r7, #12]
 800b702:	2201      	movs	r2, #1
 800b704:	66da      	str	r2, [r3, #108]	@ 0x6c
 800b706:	2300      	movs	r3, #0
 800b708:	60bb      	str	r3, [r7, #8]
    if ((!err) && (wc_InitMutex(&cm->tpLock) != 0)) {
        WOLFSSL_MSG("Bad mutex init");
        err = 1;
    }
#endif
    if (!err) {
 800b70a:	68bb      	ldr	r3, [r7, #8]
 800b70c:	2b00      	cmp	r3, #0
 800b70e:	d10a      	bne.n	800b726 <wolfSSL_CertManagerNew_ex+0x6e>
        /* Set default minimum key sizes allowed. */
    #ifndef NO_RSA
        cm->minRsaKeySz = MIN_RSAKEY_SZ;
 800b710:	68fb      	ldr	r3, [r7, #12]
 800b712:	2280      	movs	r2, #128	@ 0x80
 800b714:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
    #endif
    #ifdef HAVE_ECC
        cm->minEccKeySz = MIN_ECCKEY_SZ;
 800b718:	68fb      	ldr	r3, [r7, #12]
 800b71a:	221c      	movs	r2, #28
 800b71c:	f8a3 2064 	strh.w	r2, [r3, #100]	@ 0x64
    #ifdef HAVE_DILITHIUM
        cm->minDilithiumKeySz = MIN_DILITHIUMKEY_SZ;
    #endif /* HAVE_DILITHIUM */

        /* Set heap hint to use in certificate manager operations. */
        cm->heap = heap;
 800b720:	68fb      	ldr	r3, [r7, #12]
 800b722:	687a      	ldr	r2, [r7, #4]
 800b724:	62da      	str	r2, [r3, #44]	@ 0x2c
    }

    /* Dispose of certificate manager on error. */
    if (err && (cm != NULL)) {
 800b726:	68bb      	ldr	r3, [r7, #8]
 800b728:	2b00      	cmp	r3, #0
 800b72a:	d007      	beq.n	800b73c <wolfSSL_CertManagerNew_ex+0x84>
 800b72c:	68fb      	ldr	r3, [r7, #12]
 800b72e:	2b00      	cmp	r3, #0
 800b730:	d004      	beq.n	800b73c <wolfSSL_CertManagerNew_ex+0x84>
        wolfSSL_CertManagerFree(cm);
 800b732:	68f8      	ldr	r0, [r7, #12]
 800b734:	f000 f807 	bl	800b746 <wolfSSL_CertManagerFree>
        cm = NULL;
 800b738:	2300      	movs	r3, #0
 800b73a:	60fb      	str	r3, [r7, #12]
    }
    return cm;
 800b73c:	68fb      	ldr	r3, [r7, #12]
}
 800b73e:	4618      	mov	r0, r3
 800b740:	3710      	adds	r7, #16
 800b742:	46bd      	mov	sp, r7
 800b744:	bd80      	pop	{r7, pc}

0800b746 <wolfSSL_CertManagerFree>:
/* Dispose of certificate manager.
 *
 * @param [in, out] cm  Certificate manager.
 */
void wolfSSL_CertManagerFree(WOLFSSL_CERT_MANAGER* cm)
{
 800b746:	b580      	push	{r7, lr}
 800b748:	b086      	sub	sp, #24
 800b74a:	af00      	add	r7, sp, #0
 800b74c:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_CertManagerFree");

    /* Validate parameter. */
    if (cm != NULL) {
 800b74e:	687b      	ldr	r3, [r7, #4]
 800b750:	2b00      	cmp	r3, #0
 800b752:	d028      	beq.n	800b7a6 <wolfSSL_CertManagerFree+0x60>
        int doFree = 0;
 800b754:	2300      	movs	r3, #0
 800b756:	60fb      	str	r3, [r7, #12]
        int ret;

        /* Decrement reference count and check if value is 0. */
        wolfSSL_RefDec(&cm->ref, &doFree, &ret);
 800b758:	687b      	ldr	r3, [r7, #4]
 800b75a:	336c      	adds	r3, #108	@ 0x6c
 800b75c:	2101      	movs	r1, #1
 800b75e:	4618      	mov	r0, r3
 800b760:	f7ff fd98 	bl	800b294 <wolfSSL_Atomic_Int_FetchSub>
 800b764:	6178      	str	r0, [r7, #20]
 800b766:	697b      	ldr	r3, [r7, #20]
 800b768:	2b01      	cmp	r3, #1
 800b76a:	bf0c      	ite	eq
 800b76c:	2301      	moveq	r3, #1
 800b76e:	2300      	movne	r3, #0
 800b770:	b2db      	uxtb	r3, r3
 800b772:	60fb      	str	r3, [r7, #12]
 800b774:	2300      	movs	r3, #0
 800b776:	60bb      	str	r3, [r7, #8]
            WOLFSSL_MSG("Couldn't lock cm mutex");
        }
    #else
        (void)ret;
    #endif
        if (doFree) {
 800b778:	68fb      	ldr	r3, [r7, #12]
 800b77a:	2b00      	cmp	r3, #0
 800b77c:	d013      	beq.n	800b7a6 <wolfSSL_CertManagerFree+0x60>
            }
        #endif
    #endif /* HAVE_OCSP */

            /* Dispose of CA table and mutex. */
            FreeSignerTable(cm->caTable, CA_TABLE_SIZE, cm->heap);
 800b77e:	6878      	ldr	r0, [r7, #4]
 800b780:	687b      	ldr	r3, [r7, #4]
 800b782:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b784:	461a      	mov	r2, r3
 800b786:	210b      	movs	r1, #11
 800b788:	f00d fbaa 	bl	8018ee0 <FreeSignerTable>
            wc_FreeMutex(&cm->caLock);
 800b78c:	687b      	ldr	r3, [r7, #4]
 800b78e:	335c      	adds	r3, #92	@ 0x5c
 800b790:	4618      	mov	r0, r3
 800b792:	f01b ffa2 	bl	80276da <wc_FreeMutex>
        #endif

            /* Dispose of reference count. */
            wolfSSL_RefFree(&cm->ref);
            /* Dispose of certificate manager memory. */
            XFREE(cm, cm->heap, DYNAMIC_TYPE_CERT_MANAGER);
 800b796:	687b      	ldr	r3, [r7, #4]
 800b798:	613b      	str	r3, [r7, #16]
 800b79a:	693b      	ldr	r3, [r7, #16]
 800b79c:	2b00      	cmp	r3, #0
 800b79e:	d002      	beq.n	800b7a6 <wolfSSL_CertManagerFree+0x60>
 800b7a0:	6938      	ldr	r0, [r7, #16]
 800b7a2:	f013 fa87 	bl	801ecb4 <wolfSSL_Free>
        }
    }
}
 800b7a6:	bf00      	nop
 800b7a8:	3718      	adds	r7, #24
 800b7aa:	46bd      	mov	sp, r7
 800b7ac:	bd80      	pop	{r7, pc}

0800b7ae <CM_VerifyBuffer_ex>:
 * @return  NOT_COMPILED_IN when converting from PEM to DER is not a feature of
 *          the wolfSSL build.
 */
int CM_VerifyBuffer_ex(WOLFSSL_CERT_MANAGER* cm, const unsigned char* buff,
    long sz, int format, int prev_err)
{
 800b7ae:	b580      	push	{r7, lr}
 800b7b0:	b092      	sub	sp, #72	@ 0x48
 800b7b2:	af04      	add	r7, sp, #16
 800b7b4:	60f8      	str	r0, [r7, #12]
 800b7b6:	60b9      	str	r1, [r7, #8]
 800b7b8:	607a      	str	r2, [r7, #4]
 800b7ba:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800b7bc:	2300      	movs	r3, #0
 800b7be:	637b      	str	r3, [r7, #52]	@ 0x34
    int fatal = 0;
 800b7c0:	2300      	movs	r3, #0
 800b7c2:	633b      	str	r3, [r7, #48]	@ 0x30
    DerBuffer* der = NULL;
 800b7c4:	2300      	movs	r3, #0
 800b7c6:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_SMALL_STACK
    DecodedCert* cert = NULL;
 800b7c8:	2300      	movs	r3, #0
 800b7ca:	62fb      	str	r3, [r7, #44]	@ 0x2c

    (void)prev_err;

#ifdef WOLFSSL_SMALL_STACK
    /* Allocate memory for decoded certificate. */
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), cm->heap,
 800b7cc:	f44f 6097 	mov.w	r0, #1208	@ 0x4b8
 800b7d0:	f013 fa54 	bl	801ec7c <wolfSSL_Malloc>
 800b7d4:	62f8      	str	r0, [r7, #44]	@ 0x2c
         DYNAMIC_TYPE_DCERT);
    if (cert == NULL) {
 800b7d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800b7d8:	2b00      	cmp	r3, #0
 800b7da:	d104      	bne.n	800b7e6 <CM_VerifyBuffer_ex+0x38>
        ret = MEMORY_E;
 800b7dc:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800b7e0:	637b      	str	r3, [r7, #52]	@ 0x34
        fatal = 1;
 800b7e2:	2301      	movs	r3, #1
 800b7e4:	633b      	str	r3, [r7, #48]	@ 0x30
    }
    if (ret == 0)
 800b7e6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b7e8:	2b00      	cmp	r3, #0
 800b7ea:	d124      	bne.n	800b836 <CM_VerifyBuffer_ex+0x88>
#endif
    {
        /* Reset fields of decoded certificate. */
        XMEMSET(cert, 0, sizeof(DecodedCert));
 800b7ec:	f44f 6297 	mov.w	r2, #1208	@ 0x4b8
 800b7f0:	2100      	movs	r1, #0
 800b7f2:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b7f4:	f01d fa16 	bl	8028c24 <memset>

        if (format == WOLFSSL_FILETYPE_PEM) {
 800b7f8:	683b      	ldr	r3, [r7, #0]
 800b7fa:	2b01      	cmp	r3, #1
 800b7fc:	d11b      	bne.n	800b836 <CM_VerifyBuffer_ex+0x88>
        #ifndef WOLFSSL_PEM_TO_DER
            ret = NOT_COMPILED_IN;
            fatal = 1;
        #else
            /* Convert to DER from PEM. */
            ret = PemToDer(buff, sz, CERT_TYPE, &der, cm->heap, NULL, NULL);
 800b7fe:	68fb      	ldr	r3, [r7, #12]
 800b800:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b802:	f107 021c 	add.w	r2, r7, #28
 800b806:	2100      	movs	r1, #0
 800b808:	9102      	str	r1, [sp, #8]
 800b80a:	2100      	movs	r1, #0
 800b80c:	9101      	str	r1, [sp, #4]
 800b80e:	9300      	str	r3, [sp, #0]
 800b810:	4613      	mov	r3, r2
 800b812:	2200      	movs	r2, #0
 800b814:	6879      	ldr	r1, [r7, #4]
 800b816:	68b8      	ldr	r0, [r7, #8]
 800b818:	f00d ff88 	bl	801972c <PemToDer>
 800b81c:	6378      	str	r0, [r7, #52]	@ 0x34
            if (ret != 0) {
 800b81e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b820:	2b00      	cmp	r3, #0
 800b822:	d002      	beq.n	800b82a <CM_VerifyBuffer_ex+0x7c>
                fatal = 1;
 800b824:	2301      	movs	r3, #1
 800b826:	633b      	str	r3, [r7, #48]	@ 0x30
 800b828:	e005      	b.n	800b836 <CM_VerifyBuffer_ex+0x88>
            }
            else {
                /* Replace buffer pointer and size with DER buffer. */
                buff = der->buffer;
 800b82a:	69fb      	ldr	r3, [r7, #28]
 800b82c:	681b      	ldr	r3, [r3, #0]
 800b82e:	60bb      	str	r3, [r7, #8]
                sz = (long)der->length;
 800b830:	69fb      	ldr	r3, [r7, #28]
 800b832:	689b      	ldr	r3, [r3, #8]
 800b834:	607b      	str	r3, [r7, #4]
            }
        #endif
        }
    }
    if (ret == 0) {
 800b836:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b838:	2b00      	cmp	r3, #0
 800b83a:	d10f      	bne.n	800b85c <CM_VerifyBuffer_ex+0xae>
        /* Create a decoded certificate with DER buffer. */
        InitDecodedCert(cert, buff, (word32)sz, cm->heap);
 800b83c:	687a      	ldr	r2, [r7, #4]
 800b83e:	68fb      	ldr	r3, [r7, #12]
 800b840:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b842:	68b9      	ldr	r1, [r7, #8]
 800b844:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b846:	f009 fd04 	bl	8015252 <InitDecodedCert>
            wc_SetUnknownExtCallback(cert, cm->unknownExtCallback);
#endif

        /* Parse DER into decoded certificate fields and verify signature
         * against a known CA. */
        ret = ParseCertRelative(cert, CERT_TYPE, VERIFY, cm, NULL);
 800b84a:	2300      	movs	r3, #0
 800b84c:	9300      	str	r3, [sp, #0]
 800b84e:	68fb      	ldr	r3, [r7, #12]
 800b850:	2201      	movs	r2, #1
 800b852:	2100      	movs	r1, #0
 800b854:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b856:	f00d f83c 	bl	80188d2 <ParseCertRelative>
 800b85a:	6378      	str	r0, [r7, #52]	@ 0x34

    (void)fatal;

#ifndef NO_WOLFSSL_CM_VERIFY
    /* Use callback to perform verification too if available. */
    if ((!fatal) && cm->verifyCallback) {
 800b85c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800b85e:	2b00      	cmp	r3, #0
 800b860:	d140      	bne.n	800b8e4 <CM_VerifyBuffer_ex+0x136>
 800b862:	68fb      	ldr	r3, [r7, #12]
 800b864:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b866:	2b00      	cmp	r3, #0
 800b868:	d03c      	beq.n	800b8e4 <CM_VerifyBuffer_ex+0x136>
    #endif
        buffer certBuf;

    #ifdef WOLFSSL_SMALL_STACK
        /* Allocate memory for object to hold arguments for callback. */
        args = (ProcPeerCertArgs*)XMALLOC(sizeof(ProcPeerCertArgs), cm->heap,
 800b86a:	2028      	movs	r0, #40	@ 0x28
 800b86c:	f013 fa06 	bl	801ec7c <wolfSSL_Malloc>
 800b870:	62b8      	str	r0, [r7, #40]	@ 0x28
            DYNAMIC_TYPE_TMP_BUFFER);
        if (args == NULL) {
 800b872:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b874:	2b00      	cmp	r3, #0
 800b876:	d104      	bne.n	800b882 <CM_VerifyBuffer_ex+0xd4>
            ret = MEMORY_E;
 800b878:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800b87c:	637b      	str	r3, [r7, #52]	@ 0x34
            fatal = 1;
 800b87e:	2301      	movs	r3, #1
 800b880:	633b      	str	r3, [r7, #48]	@ 0x30
        }
        if (!fatal)
 800b882:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800b884:	2b00      	cmp	r3, #0
 800b886:	d125      	bne.n	800b8d4 <CM_VerifyBuffer_ex+0x126>
    #endif
        {
            XMEMSET(args, 0, sizeof(ProcPeerCertArgs));
 800b888:	2228      	movs	r2, #40	@ 0x28
 800b88a:	2100      	movs	r1, #0
 800b88c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800b88e:	f01d f9c9 	bl	8028c24 <memset>

            /* DER encoding. */
            certBuf.buffer = (byte*)buff;
 800b892:	68bb      	ldr	r3, [r7, #8]
 800b894:	617b      	str	r3, [r7, #20]
            certBuf.length = (unsigned int)sz;
 800b896:	687b      	ldr	r3, [r7, #4]
 800b898:	61bb      	str	r3, [r7, #24]

            /* One certificate available. */
            args->totalCerts = 1;
 800b89a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b89c:	2201      	movs	r2, #1
 800b89e:	615a      	str	r2, [r3, #20]
            args->certs = &certBuf;
 800b8a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b8a2:	f107 0214 	add.w	r2, r7, #20
 800b8a6:	601a      	str	r2, [r3, #0]
            args->dCert = cert;
 800b8a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b8aa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800b8ac:	609a      	str	r2, [r3, #8]
            args->dCertInit = 1;
 800b8ae:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800b8b0:	f892 3026 	ldrb.w	r3, [r2, #38]	@ 0x26
 800b8b4:	f043 0304 	orr.w	r3, r3, #4
 800b8b8:	f882 3026 	strb.w	r3, [r2, #38]	@ 0x26

            /* Replace value in ret with an error value passed in. */
            if (prev_err != 0) {
 800b8bc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b8be:	2b00      	cmp	r3, #0
 800b8c0:	d001      	beq.n	800b8c6 <CM_VerifyBuffer_ex+0x118>
                ret = prev_err;
 800b8c2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b8c4:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            /* Use callback to verify certificate. */
            ret = DoVerifyCallback(cm, NULL, ret, args);
 800b8c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b8c8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800b8ca:	2100      	movs	r1, #0
 800b8cc:	68f8      	ldr	r0, [r7, #12]
 800b8ce:	f7ff fb8d 	bl	800afec <DoVerifyCallback>
 800b8d2:	6378      	str	r0, [r7, #52]	@ 0x34
        }
    #ifdef WOLFSSL_SMALL_STACK
        /* Dispose of allocated callback args. */
        XFREE(args, cm->heap, DYNAMIC_TYPE_TMP_BUFFER);
 800b8d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b8d6:	627b      	str	r3, [r7, #36]	@ 0x24
 800b8d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b8da:	2b00      	cmp	r3, #0
 800b8dc:	d002      	beq.n	800b8e4 <CM_VerifyBuffer_ex+0x136>
 800b8de:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800b8e0:	f013 f9e8 	bl	801ecb4 <wolfSSL_Free>
    #endif
    }
#endif

    /* Dispose of allocated memory. */
    FreeDecodedCert(cert);
 800b8e4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b8e6:	f009 fd8d 	bl	8015404 <FreeDecodedCert>
    FreeDer(&der);
 800b8ea:	f107 031c 	add.w	r3, r7, #28
 800b8ee:	4618      	mov	r0, r3
 800b8f0:	f00d fbfc 	bl	80190ec <FreeDer>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(cert, cm->heap, DYNAMIC_TYPE_DCERT);
 800b8f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800b8f6:	623b      	str	r3, [r7, #32]
 800b8f8:	6a3b      	ldr	r3, [r7, #32]
 800b8fa:	2b00      	cmp	r3, #0
 800b8fc:	d002      	beq.n	800b904 <CM_VerifyBuffer_ex+0x156>
 800b8fe:	6a38      	ldr	r0, [r7, #32]
 800b900:	f013 f9d8 	bl	801ecb4 <wolfSSL_Free>
#endif

    /* Convert the ret value to a return value. */
    return (ret == 0) ? WOLFSSL_SUCCESS : ret;
 800b904:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b906:	2b00      	cmp	r3, #0
 800b908:	d001      	beq.n	800b90e <CM_VerifyBuffer_ex+0x160>
 800b90a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b90c:	e000      	b.n	800b910 <CM_VerifyBuffer_ex+0x162>
 800b90e:	2301      	movs	r3, #1
}
 800b910:	4618      	mov	r0, r3
 800b912:	3738      	adds	r7, #56	@ 0x38
 800b914:	46bd      	mov	sp, r7
 800b916:	bd80      	pop	{r7, pc}

0800b918 <wolfSSL_CertManagerVerifyBuffer>:
 * @return  NOT_COMPILED_IN when converting from PEM to DER is not a feature of
 *          the wolfSSL build.
 */
int wolfSSL_CertManagerVerifyBuffer(WOLFSSL_CERT_MANAGER* cm,
    const unsigned char* buff, long sz, int format)
{
 800b918:	b580      	push	{r7, lr}
 800b91a:	b088      	sub	sp, #32
 800b91c:	af02      	add	r7, sp, #8
 800b91e:	60f8      	str	r0, [r7, #12]
 800b920:	60b9      	str	r1, [r7, #8]
 800b922:	607a      	str	r2, [r7, #4]
 800b924:	603b      	str	r3, [r7, #0]
    int ret;

    WOLFSSL_ENTER("wolfSSL_CertManagerVerifyBuffer");

    /* Validate parameters. */
    if ((cm == NULL) || (buff == NULL) || (sz <= 0)) {
 800b926:	68fb      	ldr	r3, [r7, #12]
 800b928:	2b00      	cmp	r3, #0
 800b92a:	d005      	beq.n	800b938 <wolfSSL_CertManagerVerifyBuffer+0x20>
 800b92c:	68bb      	ldr	r3, [r7, #8]
 800b92e:	2b00      	cmp	r3, #0
 800b930:	d002      	beq.n	800b938 <wolfSSL_CertManagerVerifyBuffer+0x20>
 800b932:	687b      	ldr	r3, [r7, #4]
 800b934:	2b00      	cmp	r3, #0
 800b936:	dc03      	bgt.n	800b940 <wolfSSL_CertManagerVerifyBuffer+0x28>
        ret = BAD_FUNC_ARG;
 800b938:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800b93c:	617b      	str	r3, [r7, #20]
 800b93e:	e011      	b.n	800b964 <wolfSSL_CertManagerVerifyBuffer+0x4c>
    }
    else if ((format != WOLFSSL_FILETYPE_ASN1) &&
 800b940:	683b      	ldr	r3, [r7, #0]
 800b942:	2b02      	cmp	r3, #2
 800b944:	d005      	beq.n	800b952 <wolfSSL_CertManagerVerifyBuffer+0x3a>
 800b946:	683b      	ldr	r3, [r7, #0]
 800b948:	2b01      	cmp	r3, #1
 800b94a:	d002      	beq.n	800b952 <wolfSSL_CertManagerVerifyBuffer+0x3a>
             (format != WOLFSSL_FILETYPE_PEM)) {
        ret = WOLFSSL_BAD_FILETYPE;
 800b94c:	4b08      	ldr	r3, [pc, #32]	@ (800b970 <wolfSSL_CertManagerVerifyBuffer+0x58>)
 800b94e:	617b      	str	r3, [r7, #20]
 800b950:	e008      	b.n	800b964 <wolfSSL_CertManagerVerifyBuffer+0x4c>
    }
    else {
        /* No previous error. */
        ret = CM_VerifyBuffer_ex(cm, buff, sz, format, 0);
 800b952:	2300      	movs	r3, #0
 800b954:	9300      	str	r3, [sp, #0]
 800b956:	683b      	ldr	r3, [r7, #0]
 800b958:	687a      	ldr	r2, [r7, #4]
 800b95a:	68b9      	ldr	r1, [r7, #8]
 800b95c:	68f8      	ldr	r0, [r7, #12]
 800b95e:	f7ff ff26 	bl	800b7ae <CM_VerifyBuffer_ex>
 800b962:	6178      	str	r0, [r7, #20]
    }

    return ret;
 800b964:	697b      	ldr	r3, [r7, #20]
}
 800b966:	4618      	mov	r0, r3
 800b968:	3718      	adds	r7, #24
 800b96a:	46bd      	mov	sp, r7
 800b96c:	bd80      	pop	{r7, pc}
 800b96e:	bf00      	nop
 800b970:	fffffe32 	.word	0xfffffe32

0800b974 <ClientSessionToSession>:
    #endif /* SESSION_STATS */

#else  /* NO_SESSION_CACHE */

WOLFSSL_SESSION* ClientSessionToSession(const WOLFSSL_SESSION* session)
{
 800b974:	b480      	push	{r7}
 800b976:	b083      	sub	sp, #12
 800b978:	af00      	add	r7, sp, #0
 800b97a:	6078      	str	r0, [r7, #4]
    return (WOLFSSL_SESSION*)session;
 800b97c:	687b      	ldr	r3, [r7, #4]
}
 800b97e:	4618      	mov	r0, r3
 800b980:	370c      	adds	r7, #12
 800b982:	46bd      	mov	sp, r7
 800b984:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b988:	4770      	bx	lr

0800b98a <wolfSSL_FreeSession>:
    }
    return copy;
}

void wolfSSL_FreeSession(WOLFSSL_CTX* ctx, WOLFSSL_SESSION* session)
{
 800b98a:	b580      	push	{r7, lr}
 800b98c:	b086      	sub	sp, #24
 800b98e:	af00      	add	r7, sp, #0
 800b990:	6078      	str	r0, [r7, #4]
 800b992:	6039      	str	r1, [r7, #0]
    session = ClientSessionToSession(session);
 800b994:	6838      	ldr	r0, [r7, #0]
 800b996:	f7ff ffed 	bl	800b974 <ClientSessionToSession>
 800b99a:	6038      	str	r0, [r7, #0]
    if (session == NULL)
 800b99c:	683b      	ldr	r3, [r7, #0]
 800b99e:	2b00      	cmp	r3, #0
 800b9a0:	d02f      	beq.n	800ba02 <wolfSSL_FreeSession+0x78>

    (void)ctx;

    WOLFSSL_ENTER("wolfSSL_FreeSession");

    if (session->ref.count > 0) {
 800b9a2:	683b      	ldr	r3, [r7, #0]
 800b9a4:	685b      	ldr	r3, [r3, #4]
 800b9a6:	2b00      	cmp	r3, #0
 800b9a8:	dd12      	ble.n	800b9d0 <wolfSSL_FreeSession+0x46>
        int ret;
        int isZero;
        wolfSSL_RefDec(&session->ref, &isZero, &ret);
 800b9aa:	683b      	ldr	r3, [r7, #0]
 800b9ac:	3304      	adds	r3, #4
 800b9ae:	2101      	movs	r1, #1
 800b9b0:	4618      	mov	r0, r3
 800b9b2:	f7ff fc6f 	bl	800b294 <wolfSSL_Atomic_Int_FetchSub>
 800b9b6:	6178      	str	r0, [r7, #20]
 800b9b8:	697b      	ldr	r3, [r7, #20]
 800b9ba:	2b01      	cmp	r3, #1
 800b9bc:	bf0c      	ite	eq
 800b9be:	2301      	moveq	r3, #1
 800b9c0:	2300      	movne	r3, #0
 800b9c2:	b2db      	uxtb	r3, r3
 800b9c4:	60bb      	str	r3, [r7, #8]
 800b9c6:	2300      	movs	r3, #0
 800b9c8:	60fb      	str	r3, [r7, #12]
        (void)ret;
        if (!isZero) {
 800b9ca:	68bb      	ldr	r3, [r7, #8]
 800b9cc:	2b00      	cmp	r3, #0
 800b9ce:	d01a      	beq.n	800ba06 <wolfSSL_FreeSession+0x7c>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
    wolfSSL_CRYPTO_cleanup_ex_data(&session->ex_data);
#endif

    /* Make sure masterSecret is zeroed. */
    ForceZero(session->masterSecret, SECRET_LEN);
 800b9d0:	683b      	ldr	r3, [r7, #0]
 800b9d2:	3361      	adds	r3, #97	@ 0x61
 800b9d4:	2130      	movs	r1, #48	@ 0x30
 800b9d6:	4618      	mov	r0, r3
 800b9d8:	f7ff fc71 	bl	800b2be <ForceZero>
    /* Session ID is sensitive information too. */
    ForceZero(session->sessionID, ID_LEN);
 800b9dc:	683b      	ldr	r3, [r7, #0]
 800b9de:	3340      	adds	r3, #64	@ 0x40
 800b9e0:	2120      	movs	r1, #32
 800b9e2:	4618      	mov	r0, r3
 800b9e4:	f7ff fc6b 	bl	800b2be <ForceZero>

    if (session->type == WOLFSSL_SESSION_TYPE_HEAP) {
 800b9e8:	683b      	ldr	r3, [r7, #0]
 800b9ea:	781b      	ldrb	r3, [r3, #0]
 800b9ec:	2b03      	cmp	r3, #3
 800b9ee:	d10b      	bne.n	800ba08 <wolfSSL_FreeSession+0x7e>
        XFREE(session, session->heap, DYNAMIC_TYPE_SESSION);
 800b9f0:	683b      	ldr	r3, [r7, #0]
 800b9f2:	613b      	str	r3, [r7, #16]
 800b9f4:	693b      	ldr	r3, [r7, #16]
 800b9f6:	2b00      	cmp	r3, #0
 800b9f8:	d006      	beq.n	800ba08 <wolfSSL_FreeSession+0x7e>
 800b9fa:	6938      	ldr	r0, [r7, #16]
 800b9fc:	f013 f95a 	bl	801ecb4 <wolfSSL_Free>
 800ba00:	e002      	b.n	800ba08 <wolfSSL_FreeSession+0x7e>
        return;
 800ba02:	bf00      	nop
 800ba04:	e000      	b.n	800ba08 <wolfSSL_FreeSession+0x7e>
            return;
 800ba06:	bf00      	nop
    }
}
 800ba08:	3718      	adds	r7, #24
 800ba0a:	46bd      	mov	sp, r7
 800ba0c:	bd80      	pop	{r7, pc}
	...

0800ba10 <wolfssl_get_global_rng>:
#if defined(OPENSSL_EXTRA) && defined(HAVE_HASHDRBG)
static WOLFSSL_DRBG_CTX* gDrbgDefCtx = NULL;
#endif

WC_RNG* wolfssl_get_global_rng(void)
{
 800ba10:	b480      	push	{r7}
 800ba12:	b083      	sub	sp, #12
 800ba14:	af00      	add	r7, sp, #0
    WC_RNG* ret = NULL;
 800ba16:	2300      	movs	r3, #0
 800ba18:	607b      	str	r3, [r7, #4]

    if (initGlobalRNG == 0)
 800ba1a:	4b06      	ldr	r3, [pc, #24]	@ (800ba34 <wolfssl_get_global_rng+0x24>)
 800ba1c:	681b      	ldr	r3, [r3, #0]
 800ba1e:	2b00      	cmp	r3, #0
 800ba20:	d001      	beq.n	800ba26 <wolfssl_get_global_rng+0x16>
        WOLFSSL_MSG("Global RNG no Init");
    else
        ret = &globalRNG;
 800ba22:	4b05      	ldr	r3, [pc, #20]	@ (800ba38 <wolfssl_get_global_rng+0x28>)
 800ba24:	607b      	str	r3, [r7, #4]

    return ret;
 800ba26:	687b      	ldr	r3, [r7, #4]
}
 800ba28:	4618      	mov	r0, r3
 800ba2a:	370c      	adds	r7, #12
 800ba2c:	46bd      	mov	sp, r7
 800ba2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba32:	4770      	bx	lr
 800ba34:	20001c00 	.word	0x20001c00
 800ba38:	20001bf0 	.word	0x20001bf0

0800ba3c <wolfSSL_BN_free>:
 * bn is unusable after this call.
 *
 * @param [in, out] bn  Big number to free.
 */
void wolfSSL_BN_free(WOLFSSL_BIGNUM* bn)
{
 800ba3c:	b580      	push	{r7, lr}
 800ba3e:	b084      	sub	sp, #16
 800ba40:	af00      	add	r7, sp, #0
 800ba42:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_BN_free");
#endif

    /* Validate parameter. */
    if (bn != NULL) {
 800ba44:	687b      	ldr	r3, [r7, #4]
 800ba46:	2b00      	cmp	r3, #0
 800ba48:	d010      	beq.n	800ba6c <wolfSSL_BN_free+0x30>
        /* Cleanup any internal representation. */
        if (bn->internal != NULL) {
 800ba4a:	687b      	ldr	r3, [r7, #4]
 800ba4c:	685b      	ldr	r3, [r3, #4]
 800ba4e:	2b00      	cmp	r3, #0
 800ba50:	d004      	beq.n	800ba5c <wolfSSL_BN_free+0x20>
            /* Free MP integer. */
            mp_free(&bn->mpi);
 800ba52:	687b      	ldr	r3, [r7, #4]
 800ba54:	3308      	adds	r3, #8
 800ba56:	4618      	mov	r0, r3
 800ba58:	f01b f858 	bl	8026b0c <mp_free>
        }
        /* Dispose of big number object. */
        XFREE(bn, NULL, DYNAMIC_TYPE_BIGINT);
 800ba5c:	687b      	ldr	r3, [r7, #4]
 800ba5e:	60fb      	str	r3, [r7, #12]
 800ba60:	68fb      	ldr	r3, [r7, #12]
 800ba62:	2b00      	cmp	r3, #0
 800ba64:	d002      	beq.n	800ba6c <wolfSSL_BN_free+0x30>
 800ba66:	68f8      	ldr	r0, [r7, #12]
 800ba68:	f013 f924 	bl	801ecb4 <wolfSSL_Free>
        /* bn = NULL, don't try to access or double free it */
    }
}
 800ba6c:	bf00      	nop
 800ba6e:	3710      	adds	r7, #16
 800ba70:	46bd      	mov	sp, r7
 800ba72:	bd80      	pop	{r7, pc}

0800ba74 <wolfSSL_BN_clear_free>:
 * bn is unusable after this call.
 *
 * @param [in, out] bn  Big number to clear and free.
 */
void wolfSSL_BN_clear_free(WOLFSSL_BIGNUM* bn)
{
 800ba74:	b580      	push	{r7, lr}
 800ba76:	b082      	sub	sp, #8
 800ba78:	af00      	add	r7, sp, #0
 800ba7a:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_BN_clear_free");
#endif

    /* Validate parameter. */
    if (bn != NULL) {
 800ba7c:	687b      	ldr	r3, [r7, #4]
 800ba7e:	2b00      	cmp	r3, #0
 800ba80:	d00b      	beq.n	800ba9a <wolfSSL_BN_clear_free+0x26>
        /* Check for internal representation. */
        if (bn->internal != NULL) {
 800ba82:	687b      	ldr	r3, [r7, #4]
 800ba84:	685b      	ldr	r3, [r3, #4]
 800ba86:	2b00      	cmp	r3, #0
 800ba88:	d004      	beq.n	800ba94 <wolfSSL_BN_clear_free+0x20>
            /* Zeroize MP integer. */
            mp_forcezero((mp_int*)bn->internal);
 800ba8a:	687b      	ldr	r3, [r7, #4]
 800ba8c:	685b      	ldr	r3, [r3, #4]
 800ba8e:	4618      	mov	r0, r3
 800ba90:	f01b f818 	bl	8026ac4 <mp_forcezero>
        }
        /* Dispose of big number. */
        wolfSSL_BN_free(bn);
 800ba94:	6878      	ldr	r0, [r7, #4]
 800ba96:	f7ff ffd1 	bl	800ba3c <wolfSSL_BN_free>
    }
}
 800ba9a:	bf00      	nop
 800ba9c:	3708      	adds	r7, #8
 800ba9e:	46bd      	mov	sp, r7
 800baa0:	bd80      	pop	{r7, pc}
	...

0800baa4 <wolfSSL_BN_free_one>:
    }

    return one;
}

static void wolfSSL_BN_free_one(void) {
 800baa4:	b580      	push	{r7, lr}
 800baa6:	af00      	add	r7, sp, #0
    wolfSSL_BN_free(bn_one);
 800baa8:	4b04      	ldr	r3, [pc, #16]	@ (800babc <wolfSSL_BN_free_one+0x18>)
 800baaa:	681b      	ldr	r3, [r3, #0]
 800baac:	4618      	mov	r0, r3
 800baae:	f7ff ffc5 	bl	800ba3c <wolfSSL_BN_free>
    bn_one = NULL;
 800bab2:	4b02      	ldr	r3, [pc, #8]	@ (800babc <wolfSSL_BN_free_one+0x18>)
 800bab4:	2200      	movs	r2, #0
 800bab6:	601a      	str	r2, [r3, #0]
}
 800bab8:	bf00      	nop
 800baba:	bd80      	pop	{r7, pc}
 800babc:	20001c1c 	.word	0x20001c1c

0800bac0 <wolfSSL_ASN1_INTEGER_free>:
/* Free the ASN.1 INTEGER object and any dynamically allocated data.
 *
 * @param [in, out] in  ASN.1 INTEGER object.
 */
void wolfSSL_ASN1_INTEGER_free(WOLFSSL_ASN1_INTEGER* in)
{
 800bac0:	b580      	push	{r7, lr}
 800bac2:	b084      	sub	sp, #16
 800bac4:	af00      	add	r7, sp, #0
 800bac6:	6078      	str	r0, [r7, #4]
    if ((in != NULL) && (in->isDynamic)) {
 800bac8:	687b      	ldr	r3, [r7, #4]
 800baca:	2b00      	cmp	r3, #0
 800bacc:	d010      	beq.n	800baf0 <wolfSSL_ASN1_INTEGER_free+0x30>
 800bace:	687b      	ldr	r3, [r7, #4]
 800bad0:	f893 3020 	ldrb.w	r3, [r3, #32]
 800bad4:	f003 0301 	and.w	r3, r3, #1
 800bad8:	b2db      	uxtb	r3, r3
 800bada:	2b00      	cmp	r3, #0
 800badc:	d008      	beq.n	800baf0 <wolfSSL_ASN1_INTEGER_free+0x30>
        /* Dispose of any data allocated in INTEGER. */
        XFREE(in->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800bade:	687b      	ldr	r3, [r7, #4]
 800bae0:	699b      	ldr	r3, [r3, #24]
 800bae2:	60fb      	str	r3, [r7, #12]
 800bae4:	68fb      	ldr	r3, [r7, #12]
 800bae6:	2b00      	cmp	r3, #0
 800bae8:	d002      	beq.n	800baf0 <wolfSSL_ASN1_INTEGER_free+0x30>
 800baea:	68f8      	ldr	r0, [r7, #12]
 800baec:	f013 f8e2 	bl	801ecb4 <wolfSSL_Free>
    }
    /* Dispose of the ASN.1 INTEGER object. */
    XFREE(in, NULL, DYNAMIC_TYPE_OPENSSL);
 800baf0:	687b      	ldr	r3, [r7, #4]
 800baf2:	60bb      	str	r3, [r7, #8]
 800baf4:	68bb      	ldr	r3, [r7, #8]
 800baf6:	2b00      	cmp	r3, #0
 800baf8:	d002      	beq.n	800bb00 <wolfSSL_ASN1_INTEGER_free+0x40>
 800bafa:	68b8      	ldr	r0, [r7, #8]
 800bafc:	f013 f8da 	bl	801ecb4 <wolfSSL_Free>
}
 800bb00:	bf00      	nop
 800bb02:	3710      	adds	r7, #16
 800bb04:	46bd      	mov	sp, r7
 800bb06:	bd80      	pop	{r7, pc}

0800bb08 <wolfSSL_ASN1_OBJECT_new>:
 *
 * @return  ASN.1 OBJECT_ID object on success.
 * @return  NULL when dynamic memory allocation fails.
 */
WOLFSSL_ASN1_OBJECT* wolfSSL_ASN1_OBJECT_new(void)
{
 800bb08:	b580      	push	{r7, lr}
 800bb0a:	b082      	sub	sp, #8
 800bb0c:	af00      	add	r7, sp, #0
    WOLFSSL_ASN1_OBJECT* obj;

    /* Allocate memory for new ASN.1 OBJECT. */
    obj = (WOLFSSL_ASN1_OBJECT*)XMALLOC(sizeof(WOLFSSL_ASN1_OBJECT), NULL,
 800bb0e:	20b0      	movs	r0, #176	@ 0xb0
 800bb10:	f013 f8b4 	bl	801ec7c <wolfSSL_Malloc>
 800bb14:	6078      	str	r0, [r7, #4]
        DYNAMIC_TYPE_ASN1);
    if (obj != NULL) {
 800bb16:	687b      	ldr	r3, [r7, #4]
 800bb18:	2b00      	cmp	r3, #0
 800bb1a:	d013      	beq.n	800bb44 <wolfSSL_ASN1_OBJECT_new+0x3c>
        XMEMSET(obj, 0, sizeof(WOLFSSL_ASN1_OBJECT));
 800bb1c:	22b0      	movs	r2, #176	@ 0xb0
 800bb1e:	2100      	movs	r1, #0
 800bb20:	6878      	ldr	r0, [r7, #4]
 800bb22:	f01d f87f 	bl	8028c24 <memset>
        /* Setup pointers. */
        obj->d.ia5 = &(obj->d.ia5_internal);
 800bb26:	687b      	ldr	r3, [r7, #4]
 800bb28:	f103 0250 	add.w	r2, r3, #80	@ 0x50
 800bb2c:	687b      	ldr	r3, [r7, #4]
 800bb2e:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
    #if defined(OPENSSL_ALL)
        obj->d.iPAddress = &(obj->d.iPAddress_internal);
    #endif
        /* Object was allocated. */
        obj->dynamic |= WOLFSSL_ASN1_DYNAMIC;
 800bb32:	687b      	ldr	r3, [r7, #4]
 800bb34:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800bb38:	f043 0301 	orr.w	r3, r3, #1
 800bb3c:	b2da      	uxtb	r2, r3
 800bb3e:	687b      	ldr	r3, [r7, #4]
 800bb40:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
    }

    return obj;
 800bb44:	687b      	ldr	r3, [r7, #4]
}
 800bb46:	4618      	mov	r0, r3
 800bb48:	3708      	adds	r7, #8
 800bb4a:	46bd      	mov	sp, r7
 800bb4c:	bd80      	pop	{r7, pc}

0800bb4e <wolfSSL_ASN1_OBJECT_free>:
 * Do not use obj after calling this function.
 *
 * @param [in, out] obj  ASN.1 OBJECT_ID object.
 */
void wolfSSL_ASN1_OBJECT_free(WOLFSSL_ASN1_OBJECT* obj)
{
 800bb4e:	b580      	push	{r7, lr}
 800bb50:	b084      	sub	sp, #16
 800bb52:	af00      	add	r7, sp, #0
 800bb54:	6078      	str	r0, [r7, #4]
    if (obj != NULL) {
 800bb56:	687b      	ldr	r3, [r7, #4]
 800bb58:	2b00      	cmp	r3, #0
 800bb5a:	d02d      	beq.n	800bbb8 <wolfSSL_ASN1_OBJECT_free+0x6a>
        /* Check for dynamically allocated copy of encoded data. */
        if ((obj->dynamic & WOLFSSL_ASN1_DYNAMIC_DATA) != 0) {
 800bb5c:	687b      	ldr	r3, [r7, #4]
 800bb5e:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800bb62:	f003 0302 	and.w	r3, r3, #2
 800bb66:	2b00      	cmp	r3, #0
 800bb68:	d00b      	beq.n	800bb82 <wolfSSL_ASN1_OBJECT_free+0x34>
        #ifdef WOLFSSL_DEBUG_OPENSSL
            WOLFSSL_MSG("Freeing ASN1 data");
        #endif
            XFREE((void*)obj->obj, obj->heap, DYNAMIC_TYPE_ASN1);
 800bb6a:	687b      	ldr	r3, [r7, #4]
 800bb6c:	685b      	ldr	r3, [r3, #4]
 800bb6e:	60fb      	str	r3, [r7, #12]
 800bb70:	68fb      	ldr	r3, [r7, #12]
 800bb72:	2b00      	cmp	r3, #0
 800bb74:	d002      	beq.n	800bb7c <wolfSSL_ASN1_OBJECT_free+0x2e>
 800bb76:	68f8      	ldr	r0, [r7, #12]
 800bb78:	f013 f89c 	bl	801ecb4 <wolfSSL_Free>
            obj->obj = NULL;
 800bb7c:	687b      	ldr	r3, [r7, #4]
 800bb7e:	2200      	movs	r2, #0
 800bb80:	605a      	str	r2, [r3, #4]
        }
    #if defined(OPENSSL_EXTRA)
        /* Check for path length ASN.1 INTEGER - X.509 extension. */
        if (obj->pathlen != NULL) {
 800bb82:	687b      	ldr	r3, [r7, #4]
 800bb84:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bb86:	2b00      	cmp	r3, #0
 800bb88:	d007      	beq.n	800bb9a <wolfSSL_ASN1_OBJECT_free+0x4c>
            wolfSSL_ASN1_INTEGER_free(obj->pathlen);
 800bb8a:	687b      	ldr	r3, [r7, #4]
 800bb8c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bb8e:	4618      	mov	r0, r3
 800bb90:	f7ff ff96 	bl	800bac0 <wolfSSL_ASN1_INTEGER_free>
            obj->pathlen = NULL;
 800bb94:	687b      	ldr	r3, [r7, #4]
 800bb96:	2200      	movs	r2, #0
 800bb98:	645a      	str	r2, [r3, #68]	@ 0x44
        }
    #endif
        /* Check whether object was dynamically allocated. */
        if ((obj->dynamic & WOLFSSL_ASN1_DYNAMIC) != 0) {
 800bb9a:	687b      	ldr	r3, [r7, #4]
 800bb9c:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800bba0:	f003 0301 	and.w	r3, r3, #1
 800bba4:	2b00      	cmp	r3, #0
 800bba6:	d007      	beq.n	800bbb8 <wolfSSL_ASN1_OBJECT_free+0x6a>
    #ifdef WOLFSSL_DEBUG_OPENSSL
            WOLFSSL_MSG("Freeing ASN1 OBJECT");
    #endif
            XFREE(obj, NULL, DYNAMIC_TYPE_ASN1);
 800bba8:	687b      	ldr	r3, [r7, #4]
 800bbaa:	60bb      	str	r3, [r7, #8]
 800bbac:	68bb      	ldr	r3, [r7, #8]
 800bbae:	2b00      	cmp	r3, #0
 800bbb0:	d002      	beq.n	800bbb8 <wolfSSL_ASN1_OBJECT_free+0x6a>
 800bbb2:	68b8      	ldr	r0, [r7, #8]
 800bbb4:	f013 f87e 	bl	801ecb4 <wolfSSL_Free>
        }
    }
}
 800bbb8:	bf00      	nop
 800bbba:	3710      	adds	r7, #16
 800bbbc:	46bd      	mov	sp, r7
 800bbbe:	bd80      	pop	{r7, pc}

0800bbc0 <wolfSSL_ASN1_STRING_new>:
 *
 * @return  New ASN.1 STRING object on success.
 * @return  NULL when dynamic memory allocation fails.
 */
WOLFSSL_ASN1_STRING* wolfSSL_ASN1_STRING_new(void)
{
 800bbc0:	b580      	push	{r7, lr}
 800bbc2:	b082      	sub	sp, #8
 800bbc4:	af00      	add	r7, sp, #0

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_new");
#endif

    asn1 = (WOLFSSL_ASN1_STRING*)XMALLOC(sizeof(WOLFSSL_ASN1_STRING), NULL,
 800bbc6:	2058      	movs	r0, #88	@ 0x58
 800bbc8:	f013 f858 	bl	801ec7c <wolfSSL_Malloc>
 800bbcc:	6078      	str	r0, [r7, #4]
        DYNAMIC_TYPE_OPENSSL);
    if (asn1 != NULL) {
 800bbce:	687b      	ldr	r3, [r7, #4]
 800bbd0:	2b00      	cmp	r3, #0
 800bbd2:	d004      	beq.n	800bbde <wolfSSL_ASN1_STRING_new+0x1e>
        XMEMSET(asn1, 0, sizeof(WOLFSSL_ASN1_STRING));
 800bbd4:	2258      	movs	r2, #88	@ 0x58
 800bbd6:	2100      	movs	r1, #0
 800bbd8:	6878      	ldr	r0, [r7, #4]
 800bbda:	f01d f823 	bl	8028c24 <memset>
    }

    return asn1;
 800bbde:	687b      	ldr	r3, [r7, #4]
}
 800bbe0:	4618      	mov	r0, r3
 800bbe2:	3708      	adds	r7, #8
 800bbe4:	46bd      	mov	sp, r7
 800bbe6:	bd80      	pop	{r7, pc}

0800bbe8 <wolfSSL_ASN1_STRING_type_new>:
 * @param [in] type  Encoding type.
 * @return  New ASN.1 STRING object on success.
 * @return  NULL when dynamic memory allocation fails.
 */
WOLFSSL_ASN1_STRING* wolfSSL_ASN1_STRING_type_new(int type)
{
 800bbe8:	b580      	push	{r7, lr}
 800bbea:	b084      	sub	sp, #16
 800bbec:	af00      	add	r7, sp, #0
 800bbee:	6078      	str	r0, [r7, #4]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_type_new");
#endif

    asn1 = wolfSSL_ASN1_STRING_new();
 800bbf0:	f7ff ffe6 	bl	800bbc0 <wolfSSL_ASN1_STRING_new>
 800bbf4:	60f8      	str	r0, [r7, #12]
    if (asn1 != NULL) {
 800bbf6:	68fb      	ldr	r3, [r7, #12]
 800bbf8:	2b00      	cmp	r3, #0
 800bbfa:	d002      	beq.n	800bc02 <wolfSSL_ASN1_STRING_type_new+0x1a>
        asn1->type = type;
 800bbfc:	68fb      	ldr	r3, [r7, #12]
 800bbfe:	687a      	ldr	r2, [r7, #4]
 800bc00:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    return asn1;
 800bc02:	68fb      	ldr	r3, [r7, #12]
}
 800bc04:	4618      	mov	r0, r3
 800bc06:	3710      	adds	r7, #16
 800bc08:	46bd      	mov	sp, r7
 800bc0a:	bd80      	pop	{r7, pc}

0800bc0c <wolfSSL_ASN1_STRING_free>:
/* Dispose of ASN.1 STRING object.
 *
 * @param [in, out] asn1  ASN.1 STRING object.
 */
void wolfSSL_ASN1_STRING_free(WOLFSSL_ASN1_STRING* asn1)
{
 800bc0c:	b580      	push	{r7, lr}
 800bc0e:	b084      	sub	sp, #16
 800bc10:	af00      	add	r7, sp, #0
 800bc12:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_free");
#endif

    /* Check we have an object to free. */
    if (asn1 != NULL) {
 800bc14:	687b      	ldr	r3, [r7, #4]
 800bc16:	2b00      	cmp	r3, #0
 800bc18:	d014      	beq.n	800bc44 <wolfSSL_ASN1_STRING_free+0x38>
        /* Dispose of dynamic data. */
        if ((asn1->length > 0) && asn1->isDynamic) {
 800bc1a:	687b      	ldr	r3, [r7, #4]
 800bc1c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800bc1e:	2b00      	cmp	r3, #0
 800bc20:	dd10      	ble.n	800bc44 <wolfSSL_ASN1_STRING_free+0x38>
 800bc22:	687b      	ldr	r3, [r7, #4]
 800bc24:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800bc28:	f003 0301 	and.w	r3, r3, #1
 800bc2c:	b2db      	uxtb	r3, r3
 800bc2e:	2b00      	cmp	r3, #0
 800bc30:	d008      	beq.n	800bc44 <wolfSSL_ASN1_STRING_free+0x38>
            XFREE(asn1->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800bc32:	687b      	ldr	r3, [r7, #4]
 800bc34:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bc36:	60fb      	str	r3, [r7, #12]
 800bc38:	68fb      	ldr	r3, [r7, #12]
 800bc3a:	2b00      	cmp	r3, #0
 800bc3c:	d002      	beq.n	800bc44 <wolfSSL_ASN1_STRING_free+0x38>
 800bc3e:	68f8      	ldr	r0, [r7, #12]
 800bc40:	f013 f838 	bl	801ecb4 <wolfSSL_Free>
        }
    }
    /* Dispose of ASN.1 STRING object. */
    XFREE(asn1, NULL, DYNAMIC_TYPE_OPENSSL);
 800bc44:	687b      	ldr	r3, [r7, #4]
 800bc46:	60bb      	str	r3, [r7, #8]
 800bc48:	68bb      	ldr	r3, [r7, #8]
 800bc4a:	2b00      	cmp	r3, #0
 800bc4c:	d002      	beq.n	800bc54 <wolfSSL_ASN1_STRING_free+0x48>
 800bc4e:	68b8      	ldr	r0, [r7, #8]
 800bc50:	f013 f830 	bl	801ecb4 <wolfSSL_Free>
}
 800bc54:	bf00      	nop
 800bc56:	3710      	adds	r7, #16
 800bc58:	46bd      	mov	sp, r7
 800bc5a:	bd80      	pop	{r7, pc}

0800bc5c <wolfSSL_ASN1_STRING_type>:
 * @param [in] asn1  ASN.1 STRING object.
 * @return  Encoding type on success.
 * @return  0 when asn1 is NULL or no encoding set.
 */
int wolfSSL_ASN1_STRING_type(const WOLFSSL_ASN1_STRING* asn1)
{
 800bc5c:	b480      	push	{r7}
 800bc5e:	b085      	sub	sp, #20
 800bc60:	af00      	add	r7, sp, #0
 800bc62:	6078      	str	r0, [r7, #4]
    int type = 0;
 800bc64:	2300      	movs	r3, #0
 800bc66:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_type");
#endif

    if (asn1 != NULL) {
 800bc68:	687b      	ldr	r3, [r7, #4]
 800bc6a:	2b00      	cmp	r3, #0
 800bc6c:	d002      	beq.n	800bc74 <wolfSSL_ASN1_STRING_type+0x18>
        type = asn1->type;
 800bc6e:	687b      	ldr	r3, [r7, #4]
 800bc70:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bc72:	60fb      	str	r3, [r7, #12]
    }

    return type;
 800bc74:	68fb      	ldr	r3, [r7, #12]
}
 800bc76:	4618      	mov	r0, r3
 800bc78:	3714      	adds	r7, #20
 800bc7a:	46bd      	mov	sp, r7
 800bc7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc80:	4770      	bx	lr

0800bc82 <wolfSSL_ASN1_STRING_data>:
 * @param [in] asn  ASN.1 STRING object.
 * @return  Buffer with string on success.
 * @return  NULL when asn is NULL or no data set.
 */
unsigned char* wolfSSL_ASN1_STRING_data(WOLFSSL_ASN1_STRING* asn)
{
 800bc82:	b480      	push	{r7}
 800bc84:	b085      	sub	sp, #20
 800bc86:	af00      	add	r7, sp, #0
 800bc88:	6078      	str	r0, [r7, #4]
    char* data = NULL;
 800bc8a:	2300      	movs	r3, #0
 800bc8c:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_data");
#endif

    if (asn != NULL) {
 800bc8e:	687b      	ldr	r3, [r7, #4]
 800bc90:	2b00      	cmp	r3, #0
 800bc92:	d002      	beq.n	800bc9a <wolfSSL_ASN1_STRING_data+0x18>
        data = asn->data;
 800bc94:	687b      	ldr	r3, [r7, #4]
 800bc96:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bc98:	60fb      	str	r3, [r7, #12]
    }

    return (unsigned char*)data;
 800bc9a:	68fb      	ldr	r3, [r7, #12]
}
 800bc9c:	4618      	mov	r0, r3
 800bc9e:	3714      	adds	r7, #20
 800bca0:	46bd      	mov	sp, r7
 800bca2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bca6:	4770      	bx	lr

0800bca8 <wolfSSL_ASN1_STRING_length>:
 * @param [in] asn  ASN.1 STRING object.
 * @return  String length on success.
 * @return  0 when asn is NULL or no data set.
 */
int wolfSSL_ASN1_STRING_length(const WOLFSSL_ASN1_STRING* asn)
{
 800bca8:	b480      	push	{r7}
 800bcaa:	b085      	sub	sp, #20
 800bcac:	af00      	add	r7, sp, #0
 800bcae:	6078      	str	r0, [r7, #4]
    int len = 0;
 800bcb0:	2300      	movs	r3, #0
 800bcb2:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_length");
#endif

    if (asn) {
 800bcb4:	687b      	ldr	r3, [r7, #4]
 800bcb6:	2b00      	cmp	r3, #0
 800bcb8:	d002      	beq.n	800bcc0 <wolfSSL_ASN1_STRING_length+0x18>
        len = asn->length;
 800bcba:	687b      	ldr	r3, [r7, #4]
 800bcbc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800bcbe:	60fb      	str	r3, [r7, #12]
    }

    return len;
 800bcc0:	68fb      	ldr	r3, [r7, #12]
}
 800bcc2:	4618      	mov	r0, r3
 800bcc4:	3714      	adds	r7, #20
 800bcc6:	46bd      	mov	sp, r7
 800bcc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bccc:	4770      	bx	lr

0800bcce <wolfSSL_ASN1_STRING_set>:
 * @return  1 on success.
 * @return  0 when asn1 is NULL or data is NULL and sz is not zero.
 * @return  0 when dynamic memory allocation fails.
 */
int wolfSSL_ASN1_STRING_set(WOLFSSL_ASN1_STRING* asn1, const void* data, int sz)
{
 800bcce:	b580      	push	{r7, lr}
 800bcd0:	b086      	sub	sp, #24
 800bcd2:	af00      	add	r7, sp, #0
 800bcd4:	60f8      	str	r0, [r7, #12]
 800bcd6:	60b9      	str	r1, [r7, #8]
 800bcd8:	607a      	str	r2, [r7, #4]
    int ret = 1;
 800bcda:	2301      	movs	r3, #1
 800bcdc:	617b      	str	r3, [r7, #20]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_set");
#endif

    /* Validate parameters. */
    if ((asn1 == NULL) || ((data == NULL) && (sz != 0))) {
 800bcde:	68fb      	ldr	r3, [r7, #12]
 800bce0:	2b00      	cmp	r3, #0
 800bce2:	d005      	beq.n	800bcf0 <wolfSSL_ASN1_STRING_set+0x22>
 800bce4:	68bb      	ldr	r3, [r7, #8]
 800bce6:	2b00      	cmp	r3, #0
 800bce8:	d104      	bne.n	800bcf4 <wolfSSL_ASN1_STRING_set+0x26>
 800bcea:	687b      	ldr	r3, [r7, #4]
 800bcec:	2b00      	cmp	r3, #0
 800bcee:	d001      	beq.n	800bcf4 <wolfSSL_ASN1_STRING_set+0x26>
        ret = 0;
 800bcf0:	2300      	movs	r3, #0
 800bcf2:	617b      	str	r3, [r7, #20]
    }

    /* Calculate size from data if not passed in. */
    if ((ret == 1) && (sz < 0)) {
 800bcf4:	697b      	ldr	r3, [r7, #20]
 800bcf6:	2b01      	cmp	r3, #1
 800bcf8:	d10c      	bne.n	800bd14 <wolfSSL_ASN1_STRING_set+0x46>
 800bcfa:	687b      	ldr	r3, [r7, #4]
 800bcfc:	2b00      	cmp	r3, #0
 800bcfe:	da09      	bge.n	800bd14 <wolfSSL_ASN1_STRING_set+0x46>
        sz = (int)XSTRLEN((const char*)data);
 800bd00:	68b8      	ldr	r0, [r7, #8]
 800bd02:	f7f4 fa6f 	bl	80001e4 <strlen>
 800bd06:	4603      	mov	r3, r0
 800bd08:	607b      	str	r3, [r7, #4]
        if (sz < 0) {
 800bd0a:	687b      	ldr	r3, [r7, #4]
 800bd0c:	2b00      	cmp	r3, #0
 800bd0e:	da01      	bge.n	800bd14 <wolfSSL_ASN1_STRING_set+0x46>
            ret = 0;
 800bd10:	2300      	movs	r3, #0
 800bd12:	617b      	str	r3, [r7, #20]
        }
    }

    if (ret == 1) {
 800bd14:	697b      	ldr	r3, [r7, #20]
 800bd16:	2b01      	cmp	r3, #1
 800bd18:	d13d      	bne.n	800bd96 <wolfSSL_ASN1_STRING_set+0xc8>
        /* Dispose of any existing dynamic data. */
        if (asn1->isDynamic) {
 800bd1a:	68fb      	ldr	r3, [r7, #12]
 800bd1c:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800bd20:	f003 0301 	and.w	r3, r3, #1
 800bd24:	b2db      	uxtb	r3, r3
 800bd26:	2b00      	cmp	r3, #0
 800bd28:	d00b      	beq.n	800bd42 <wolfSSL_ASN1_STRING_set+0x74>
            XFREE(asn1->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800bd2a:	68fb      	ldr	r3, [r7, #12]
 800bd2c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bd2e:	613b      	str	r3, [r7, #16]
 800bd30:	693b      	ldr	r3, [r7, #16]
 800bd32:	2b00      	cmp	r3, #0
 800bd34:	d002      	beq.n	800bd3c <wolfSSL_ASN1_STRING_set+0x6e>
 800bd36:	6938      	ldr	r0, [r7, #16]
 800bd38:	f012 ffbc 	bl	801ecb4 <wolfSSL_Free>
            asn1->data = NULL;
 800bd3c:	68fb      	ldr	r3, [r7, #12]
 800bd3e:	2200      	movs	r2, #0
 800bd40:	64da      	str	r2, [r3, #76]	@ 0x4c
        }

        /* Check string will fit - including NUL. */
        if (sz + 1 > CTC_NAME_SIZE) {
 800bd42:	687b      	ldr	r3, [r7, #4]
 800bd44:	2b3f      	cmp	r3, #63	@ 0x3f
 800bd46:	dd16      	ble.n	800bd76 <wolfSSL_ASN1_STRING_set+0xa8>
            /* Allocate new buffer. */
            asn1->data = (char*)XMALLOC((size_t)(sz + 1), NULL,
 800bd48:	687b      	ldr	r3, [r7, #4]
 800bd4a:	3301      	adds	r3, #1
 800bd4c:	4618      	mov	r0, r3
 800bd4e:	f012 ff95 	bl	801ec7c <wolfSSL_Malloc>
 800bd52:	4602      	mov	r2, r0
 800bd54:	68fb      	ldr	r3, [r7, #12]
 800bd56:	64da      	str	r2, [r3, #76]	@ 0x4c
                DYNAMIC_TYPE_OPENSSL);
            if (asn1->data == NULL) {
 800bd58:	68fb      	ldr	r3, [r7, #12]
 800bd5a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bd5c:	2b00      	cmp	r3, #0
 800bd5e:	d102      	bne.n	800bd66 <wolfSSL_ASN1_STRING_set+0x98>
                ret = 0;
 800bd60:	2300      	movs	r3, #0
 800bd62:	617b      	str	r3, [r7, #20]
 800bd64:	e017      	b.n	800bd96 <wolfSSL_ASN1_STRING_set+0xc8>
            }
            else {
                /* Ensure buffer will be freed. */
                asn1->isDynamic = 1;
 800bd66:	68fa      	ldr	r2, [r7, #12]
 800bd68:	f892 3054 	ldrb.w	r3, [r2, #84]	@ 0x54
 800bd6c:	f043 0301 	orr.w	r3, r3, #1
 800bd70:	f882 3054 	strb.w	r3, [r2, #84]	@ 0x54
 800bd74:	e00f      	b.n	800bd96 <wolfSSL_ASN1_STRING_set+0xc8>
            }
        }
        else {
            /* Clear out fixed array and use it for data. */
            XMEMSET(asn1->strData, 0, CTC_NAME_SIZE);
 800bd76:	68fb      	ldr	r3, [r7, #12]
 800bd78:	2240      	movs	r2, #64	@ 0x40
 800bd7a:	2100      	movs	r1, #0
 800bd7c:	4618      	mov	r0, r3
 800bd7e:	f01c ff51 	bl	8028c24 <memset>
            asn1->data = asn1->strData;
 800bd82:	68fa      	ldr	r2, [r7, #12]
 800bd84:	68fb      	ldr	r3, [r7, #12]
 800bd86:	64da      	str	r2, [r3, #76]	@ 0x4c
            asn1->isDynamic = 0;
 800bd88:	68fa      	ldr	r2, [r7, #12]
 800bd8a:	f892 3054 	ldrb.w	r3, [r2, #84]	@ 0x54
 800bd8e:	f023 0301 	bic.w	r3, r3, #1
 800bd92:	f882 3054 	strb.w	r3, [r2, #84]	@ 0x54
        }
    }
    if (ret == 1) {
 800bd96:	697b      	ldr	r3, [r7, #20]
 800bd98:	2b01      	cmp	r3, #1
 800bd9a:	d112      	bne.n	800bdc2 <wolfSSL_ASN1_STRING_set+0xf4>
        /* Check if there is a string to copy. */
        if (data != NULL) {
 800bd9c:	68bb      	ldr	r3, [r7, #8]
 800bd9e:	2b00      	cmp	r3, #0
 800bda0:	d00c      	beq.n	800bdbc <wolfSSL_ASN1_STRING_set+0xee>
            /* Copy string and append NUL. */
            XMEMCPY(asn1->data, data, (size_t)sz);
 800bda2:	68fb      	ldr	r3, [r7, #12]
 800bda4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bda6:	687a      	ldr	r2, [r7, #4]
 800bda8:	68b9      	ldr	r1, [r7, #8]
 800bdaa:	4618      	mov	r0, r3
 800bdac:	f01c ffeb 	bl	8028d86 <memcpy>
            asn1->data[sz] = '\0';
 800bdb0:	68fb      	ldr	r3, [r7, #12]
 800bdb2:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800bdb4:	687b      	ldr	r3, [r7, #4]
 800bdb6:	4413      	add	r3, r2
 800bdb8:	2200      	movs	r2, #0
 800bdba:	701a      	strb	r2, [r3, #0]
        }
        /* Set size of string. */
        asn1->length = sz;
 800bdbc:	68fb      	ldr	r3, [r7, #12]
 800bdbe:	687a      	ldr	r2, [r7, #4]
 800bdc0:	641a      	str	r2, [r3, #64]	@ 0x40
    }

    return ret;
 800bdc2:	697b      	ldr	r3, [r7, #20]
}
 800bdc4:	4618      	mov	r0, r3
 800bdc6:	3718      	adds	r7, #24
 800bdc8:	46bd      	mov	sp, r7
 800bdca:	bd80      	pop	{r7, pc}

0800bdcc <wolfssl_asn1_type_free_value>:
/* Free the ASN.1 TYPE object's value field.
 *
 * @param [in, out] at  ASN.1 TYPE object.
 */
static void wolfssl_asn1_type_free_value(WOLFSSL_ASN1_TYPE* at)
{
 800bdcc:	b580      	push	{r7, lr}
 800bdce:	b082      	sub	sp, #8
 800bdd0:	af00      	add	r7, sp, #0
 800bdd2:	6078      	str	r0, [r7, #4]
    switch (at->type) {
 800bdd4:	687b      	ldr	r3, [r7, #4]
 800bdd6:	681b      	ldr	r3, [r3, #0]
 800bdd8:	2b1c      	cmp	r3, #28
 800bdda:	dc35      	bgt.n	800be48 <wolfssl_asn1_type_free_value+0x7c>
 800bddc:	2b0c      	cmp	r3, #12
 800bdde:	da08      	bge.n	800bdf2 <wolfssl_asn1_type_free_value+0x26>
 800bde0:	2b06      	cmp	r3, #6
 800bde2:	d025      	beq.n	800be30 <wolfssl_asn1_type_free_value+0x64>
 800bde4:	2b06      	cmp	r3, #6
 800bde6:	dc2f      	bgt.n	800be48 <wolfssl_asn1_type_free_value+0x7c>
 800bde8:	2b04      	cmp	r3, #4
 800bdea:	d027      	beq.n	800be3c <wolfssl_asn1_type_free_value+0x70>
 800bdec:	2b05      	cmp	r3, #5
 800bdee:	d02d      	beq.n	800be4c <wolfssl_asn1_type_free_value+0x80>
        case WOLFSSL_V_ASN1_UNIVERSALSTRING:
        case WOLFSSL_V_ASN1_SEQUENCE:
            wolfSSL_ASN1_STRING_free(at->value.asn1_string);
            break;
        default:
            break;
 800bdf0:	e02a      	b.n	800be48 <wolfssl_asn1_type_free_value+0x7c>
    switch (at->type) {
 800bdf2:	461a      	mov	r2, r3
 800bdf4:	2301      	movs	r3, #1
 800bdf6:	4093      	lsls	r3, r2
 800bdf8:	4a19      	ldr	r2, [pc, #100]	@ (800be60 <wolfssl_asn1_type_free_value+0x94>)
 800bdfa:	401a      	ands	r2, r3
 800bdfc:	2a00      	cmp	r2, #0
 800bdfe:	bf14      	ite	ne
 800be00:	2201      	movne	r2, #1
 800be02:	2200      	moveq	r2, #0
 800be04:	b2d2      	uxtb	r2, r2
 800be06:	2a00      	cmp	r2, #0
 800be08:	d118      	bne.n	800be3c <wolfssl_asn1_type_free_value+0x70>
 800be0a:	f003 7280 	and.w	r2, r3, #16777216	@ 0x1000000
 800be0e:	2a00      	cmp	r2, #0
 800be10:	bf14      	ite	ne
 800be12:	2201      	movne	r2, #1
 800be14:	2200      	moveq	r2, #0
 800be16:	b2d2      	uxtb	r2, r2
 800be18:	2a00      	cmp	r2, #0
 800be1a:	d119      	bne.n	800be50 <wolfssl_asn1_type_free_value+0x84>
 800be1c:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800be20:	2b00      	cmp	r3, #0
 800be22:	bf14      	ite	ne
 800be24:	2301      	movne	r3, #1
 800be26:	2300      	moveq	r3, #0
 800be28:	b2db      	uxtb	r3, r3
 800be2a:	2b00      	cmp	r3, #0
 800be2c:	d112      	bne.n	800be54 <wolfssl_asn1_type_free_value+0x88>
            break;
 800be2e:	e00b      	b.n	800be48 <wolfssl_asn1_type_free_value+0x7c>
            wolfSSL_ASN1_OBJECT_free(at->value.object);
 800be30:	687b      	ldr	r3, [r7, #4]
 800be32:	685b      	ldr	r3, [r3, #4]
 800be34:	4618      	mov	r0, r3
 800be36:	f7ff fe8a 	bl	800bb4e <wolfSSL_ASN1_OBJECT_free>
            break;
 800be3a:	e00c      	b.n	800be56 <wolfssl_asn1_type_free_value+0x8a>
            wolfSSL_ASN1_STRING_free(at->value.asn1_string);
 800be3c:	687b      	ldr	r3, [r7, #4]
 800be3e:	685b      	ldr	r3, [r3, #4]
 800be40:	4618      	mov	r0, r3
 800be42:	f7ff fee3 	bl	800bc0c <wolfSSL_ASN1_STRING_free>
            break;
 800be46:	e006      	b.n	800be56 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800be48:	bf00      	nop
 800be4a:	e004      	b.n	800be56 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800be4c:	bf00      	nop
 800be4e:	e002      	b.n	800be56 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800be50:	bf00      	nop
 800be52:	e000      	b.n	800be56 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800be54:	bf00      	nop
    }
}
 800be56:	bf00      	nop
 800be58:	3708      	adds	r7, #8
 800be5a:	46bd      	mov	sp, r7
 800be5c:	bd80      	pop	{r7, pc}
 800be5e:	bf00      	nop
 800be60:	10591000 	.word	0x10591000

0800be64 <wolfSSL_ASN1_TYPE_free>:
 * Free ASN.1 TYPE object and its value.
 *
 * @param [in, out] at  ASN.1 TYPE object.
 */
void wolfSSL_ASN1_TYPE_free(WOLFSSL_ASN1_TYPE* at)
{
 800be64:	b580      	push	{r7, lr}
 800be66:	b084      	sub	sp, #16
 800be68:	af00      	add	r7, sp, #0
 800be6a:	6078      	str	r0, [r7, #4]
    if (at != NULL) {
 800be6c:	687b      	ldr	r3, [r7, #4]
 800be6e:	2b00      	cmp	r3, #0
 800be70:	d002      	beq.n	800be78 <wolfSSL_ASN1_TYPE_free+0x14>
        /* Dispose of value in ASN.1 TYPE object. */
        wolfssl_asn1_type_free_value(at);
 800be72:	6878      	ldr	r0, [r7, #4]
 800be74:	f7ff ffaa 	bl	800bdcc <wolfssl_asn1_type_free_value>
    }
    /* Dispose of ASN.1 TYPE object. */
    XFREE(at, NULL, DYNAMIC_TYPE_OPENSSL);
 800be78:	687b      	ldr	r3, [r7, #4]
 800be7a:	60fb      	str	r3, [r7, #12]
 800be7c:	68fb      	ldr	r3, [r7, #12]
 800be7e:	2b00      	cmp	r3, #0
 800be80:	d002      	beq.n	800be88 <wolfSSL_ASN1_TYPE_free+0x24>
 800be82:	68f8      	ldr	r0, [r7, #12]
 800be84:	f012 ff16 	bl	801ecb4 <wolfSSL_Free>
}
 800be88:	bf00      	nop
 800be8a:	3710      	adds	r7, #16
 800be8c:	46bd      	mov	sp, r7
 800be8e:	bd80      	pop	{r7, pc}

0800be90 <wolfssl_der_length>:
 * @param [in] len  Length of data in buffer (may be larger than SEQ).
 * @return  Size of complete DER encoding on success.
 * @return  0 on failure.
 */
static int wolfssl_der_length(const unsigned char* seq, int len)
{
 800be90:	b580      	push	{r7, lr}
 800be92:	b086      	sub	sp, #24
 800be94:	af02      	add	r7, sp, #8
 800be96:	6078      	str	r0, [r7, #4]
 800be98:	6039      	str	r1, [r7, #0]
    int ret = 0;
 800be9a:	2300      	movs	r3, #0
 800be9c:	60fb      	str	r3, [r7, #12]
    word32 i = 0;
 800be9e:	2300      	movs	r3, #0
 800bea0:	60bb      	str	r3, [r7, #8]

    /* Check it is a SEQUENCE and get the length of the underlying data.
     * i is updated to be after SEQUENCE header bytes.
     */
    if (GetSequence_ex(seq, &i, &ret, (word32)len, 0) >= 0) {
 800bea2:	683b      	ldr	r3, [r7, #0]
 800bea4:	f107 020c 	add.w	r2, r7, #12
 800bea8:	f107 0108 	add.w	r1, r7, #8
 800beac:	2000      	movs	r0, #0
 800beae:	9000      	str	r0, [sp, #0]
 800beb0:	6878      	ldr	r0, [r7, #4]
 800beb2:	f008 f935 	bl	8014120 <GetSequence_ex>
 800beb6:	4603      	mov	r3, r0
 800beb8:	2b00      	cmp	r3, #0
 800beba:	db03      	blt.n	800bec4 <wolfssl_der_length+0x34>
        /* Add SEQUENCE header length to underlying data length. */
        ret += (int)i;
 800bebc:	68fb      	ldr	r3, [r7, #12]
 800bebe:	68ba      	ldr	r2, [r7, #8]
 800bec0:	4413      	add	r3, r2
 800bec2:	60fb      	str	r3, [r7, #12]
    }

    return ret;
 800bec4:	68fb      	ldr	r3, [r7, #12]
}
 800bec6:	4618      	mov	r0, r3
 800bec8:	3710      	adds	r7, #16
 800beca:	46bd      	mov	sp, r7
 800becc:	bd80      	pop	{r7, pc}

0800bece <wolfSSL_RSA_meth_free>:
/* Dispose of RSA method and allocated data.
 *
 * @param [in] meth  RSA method to free.
 */
void wolfSSL_RSA_meth_free(WOLFSSL_RSA_METHOD *meth)
{
 800bece:	b580      	push	{r7, lr}
 800bed0:	b084      	sub	sp, #16
 800bed2:	af00      	add	r7, sp, #0
 800bed4:	6078      	str	r0, [r7, #4]
    /* Free method if available and dynamically allocated. */
    if ((meth != NULL) && meth->dynamic) {
 800bed6:	687b      	ldr	r3, [r7, #4]
 800bed8:	2b00      	cmp	r3, #0
 800beda:	d017      	beq.n	800bf0c <wolfSSL_RSA_meth_free+0x3e>
 800bedc:	687b      	ldr	r3, [r7, #4]
 800bede:	7a1b      	ldrb	r3, [r3, #8]
 800bee0:	f003 0301 	and.w	r3, r3, #1
 800bee4:	b2db      	uxtb	r3, r3
 800bee6:	2b00      	cmp	r3, #0
 800bee8:	d010      	beq.n	800bf0c <wolfSSL_RSA_meth_free+0x3e>
        /* Name was duplicated and must be freed. */
        XFREE(meth->name, NULL, DYNAMIC_TYPE_OPENSSL);
 800beea:	687b      	ldr	r3, [r7, #4]
 800beec:	685b      	ldr	r3, [r3, #4]
 800beee:	60fb      	str	r3, [r7, #12]
 800bef0:	68fb      	ldr	r3, [r7, #12]
 800bef2:	2b00      	cmp	r3, #0
 800bef4:	d002      	beq.n	800befc <wolfSSL_RSA_meth_free+0x2e>
 800bef6:	68f8      	ldr	r0, [r7, #12]
 800bef8:	f012 fedc 	bl	801ecb4 <wolfSSL_Free>
        /* Dispose of RSA method. */
        XFREE(meth, NULL, DYNAMIC_TYPE_OPENSSL);
 800befc:	687b      	ldr	r3, [r7, #4]
 800befe:	60bb      	str	r3, [r7, #8]
 800bf00:	68bb      	ldr	r3, [r7, #8]
 800bf02:	2b00      	cmp	r3, #0
 800bf04:	d002      	beq.n	800bf0c <wolfSSL_RSA_meth_free+0x3e>
 800bf06:	68b8      	ldr	r0, [r7, #8]
 800bf08:	f012 fed4 	bl	801ecb4 <wolfSSL_Free>
    }
}
 800bf0c:	bf00      	nop
 800bf0e:	3710      	adds	r7, #16
 800bf10:	46bd      	mov	sp, r7
 800bf12:	bd80      	pop	{r7, pc}

0800bf14 <wolfSSL_RSA_free>:
 * Cannot use rsa after this call.
 *
 * @param [in] rsa  RSA key to free.
 */
void wolfSSL_RSA_free(WOLFSSL_RSA* rsa)
{
 800bf14:	b580      	push	{r7, lr}
 800bf16:	b08a      	sub	sp, #40	@ 0x28
 800bf18:	af00      	add	r7, sp, #0
 800bf1a:	6078      	str	r0, [r7, #4]
    int doFree = 1;
 800bf1c:	2301      	movs	r3, #1
 800bf1e:	60fb      	str	r3, [r7, #12]

    WOLFSSL_ENTER("wolfSSL_RSA_free");

    /* Validate parameter. */
    if (rsa == NULL) {
 800bf20:	687b      	ldr	r3, [r7, #4]
 800bf22:	2b00      	cmp	r3, #0
 800bf24:	d101      	bne.n	800bf2a <wolfSSL_RSA_free+0x16>
        doFree = 0;
 800bf26:	2300      	movs	r3, #0
 800bf28:	60fb      	str	r3, [r7, #12]
    }
    if (doFree) {
 800bf2a:	68fb      	ldr	r3, [r7, #12]
 800bf2c:	2b00      	cmp	r3, #0
 800bf2e:	d00f      	beq.n	800bf50 <wolfSSL_RSA_free+0x3c>
        int err;

        /* Decrement reference count. */
        wolfSSL_RefDec(&rsa->ref, &doFree, &err);
 800bf30:	687b      	ldr	r3, [r7, #4]
 800bf32:	332c      	adds	r3, #44	@ 0x2c
 800bf34:	2101      	movs	r1, #1
 800bf36:	4618      	mov	r0, r3
 800bf38:	f7ff f9ac 	bl	800b294 <wolfSSL_Atomic_Int_FetchSub>
 800bf3c:	6278      	str	r0, [r7, #36]	@ 0x24
 800bf3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800bf40:	2b01      	cmp	r3, #1
 800bf42:	bf0c      	ite	eq
 800bf44:	2301      	moveq	r3, #1
 800bf46:	2300      	movne	r3, #0
 800bf48:	b2db      	uxtb	r3, r3
 800bf4a:	60fb      	str	r3, [r7, #12]
 800bf4c:	2300      	movs	r3, #0
 800bf4e:	60bb      	str	r3, [r7, #8]
    #ifndef WOLFSSL_REFCNT_ERROR_RETURN
        (void)err;
    #endif
    }
    if (doFree) {
 800bf50:	68fb      	ldr	r3, [r7, #12]
 800bf52:	2b00      	cmp	r3, #0
 800bf54:	d074      	beq.n	800c040 <wolfSSL_RSA_free+0x12c>
        void* heap = rsa->heap;
 800bf56:	687b      	ldr	r3, [r7, #4]
 800bf58:	6a1b      	ldr	r3, [r3, #32]
 800bf5a:	623b      	str	r3, [r7, #32]

    #ifdef HAVE_EX_DATA_CLEANUP_HOOKS
        wolfSSL_CRYPTO_cleanup_ex_data(&rsa->ex_data);
    #endif

        if (rsa->internal != NULL) {
 800bf5c:	687b      	ldr	r3, [r7, #4]
 800bf5e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bf60:	2b00      	cmp	r3, #0
 800bf62:	d030      	beq.n	800bfc6 <wolfSSL_RSA_free+0xb2>
        #if !defined(HAVE_FIPS) && defined(WC_RSA_BLINDING)
            /* Check if RNG is owned before freeing it. */
            if (rsa->ownRng) {
 800bf64:	687b      	ldr	r3, [r7, #4]
 800bf66:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 800bf6a:	f003 0304 	and.w	r3, r3, #4
 800bf6e:	b2db      	uxtb	r3, r3
 800bf70:	2b00      	cmp	r3, #0
 800bf72:	d01a      	beq.n	800bfaa <wolfSSL_RSA_free+0x96>
                WC_RNG* rng = ((RsaKey*)(rsa->internal))->rng;
 800bf74:	687b      	ldr	r3, [r7, #4]
 800bf76:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bf78:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800bf7c:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 800bf80:	61fb      	str	r3, [r7, #28]
                if ((rng != NULL) && (rng != wolfssl_get_global_rng())) {
 800bf82:	69fb      	ldr	r3, [r7, #28]
 800bf84:	2b00      	cmp	r3, #0
 800bf86:	d010      	beq.n	800bfaa <wolfSSL_RSA_free+0x96>
 800bf88:	f7ff fd42 	bl	800ba10 <wolfssl_get_global_rng>
 800bf8c:	4602      	mov	r2, r0
 800bf8e:	69fb      	ldr	r3, [r7, #28]
 800bf90:	4293      	cmp	r3, r2
 800bf92:	d00a      	beq.n	800bfaa <wolfSSL_RSA_free+0x96>
                    wc_FreeRng(rng);
 800bf94:	69f8      	ldr	r0, [r7, #28]
 800bf96:	f013 fc99 	bl	801f8cc <wc_FreeRng>
                    XFREE(rng, heap, DYNAMIC_TYPE_RNG);
 800bf9a:	69fb      	ldr	r3, [r7, #28]
 800bf9c:	61bb      	str	r3, [r7, #24]
 800bf9e:	69bb      	ldr	r3, [r7, #24]
 800bfa0:	2b00      	cmp	r3, #0
 800bfa2:	d002      	beq.n	800bfaa <wolfSSL_RSA_free+0x96>
 800bfa4:	69b8      	ldr	r0, [r7, #24]
 800bfa6:	f012 fe85 	bl	801ecb4 <wolfSSL_Free>
                }
                /* RNG isn't freed by wolfCrypt RSA free. */
            }
        #endif
            /* Dispose of allocated data in wolfCrypt RSA key. */
            wc_FreeRsaKey((RsaKey*)rsa->internal);
 800bfaa:	687b      	ldr	r3, [r7, #4]
 800bfac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bfae:	4618      	mov	r0, r3
 800bfb0:	f014 f8e8 	bl	8020184 <wc_FreeRsaKey>
            /* Dispose of memory for wolfCrypt RSA key. */
            XFREE(rsa->internal, heap, DYNAMIC_TYPE_RSA);
 800bfb4:	687b      	ldr	r3, [r7, #4]
 800bfb6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bfb8:	617b      	str	r3, [r7, #20]
 800bfba:	697b      	ldr	r3, [r7, #20]
 800bfbc:	2b00      	cmp	r3, #0
 800bfbe:	d002      	beq.n	800bfc6 <wolfSSL_RSA_free+0xb2>
 800bfc0:	6978      	ldr	r0, [r7, #20]
 800bfc2:	f012 fe77 	bl	801ecb4 <wolfSSL_Free>
        }

        /* Dispose of external representation of RSA values. */
        wolfSSL_BN_clear_free(rsa->iqmp);
 800bfc6:	687b      	ldr	r3, [r7, #4]
 800bfc8:	69db      	ldr	r3, [r3, #28]
 800bfca:	4618      	mov	r0, r3
 800bfcc:	f7ff fd52 	bl	800ba74 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->dmq1);
 800bfd0:	687b      	ldr	r3, [r7, #4]
 800bfd2:	699b      	ldr	r3, [r3, #24]
 800bfd4:	4618      	mov	r0, r3
 800bfd6:	f7ff fd4d 	bl	800ba74 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->dmp1);
 800bfda:	687b      	ldr	r3, [r7, #4]
 800bfdc:	695b      	ldr	r3, [r3, #20]
 800bfde:	4618      	mov	r0, r3
 800bfe0:	f7ff fd48 	bl	800ba74 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->q);
 800bfe4:	687b      	ldr	r3, [r7, #4]
 800bfe6:	691b      	ldr	r3, [r3, #16]
 800bfe8:	4618      	mov	r0, r3
 800bfea:	f7ff fd43 	bl	800ba74 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->p);
 800bfee:	687b      	ldr	r3, [r7, #4]
 800bff0:	68db      	ldr	r3, [r3, #12]
 800bff2:	4618      	mov	r0, r3
 800bff4:	f7ff fd3e 	bl	800ba74 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->d);
 800bff8:	687b      	ldr	r3, [r7, #4]
 800bffa:	689b      	ldr	r3, [r3, #8]
 800bffc:	4618      	mov	r0, r3
 800bffe:	f7ff fd39 	bl	800ba74 <wolfSSL_BN_clear_free>
        wolfSSL_BN_free(rsa->e);
 800c002:	687b      	ldr	r3, [r7, #4]
 800c004:	685b      	ldr	r3, [r3, #4]
 800c006:	4618      	mov	r0, r3
 800c008:	f7ff fd18 	bl	800ba3c <wolfSSL_BN_free>
        wolfSSL_BN_free(rsa->n);
 800c00c:	687b      	ldr	r3, [r7, #4]
 800c00e:	681b      	ldr	r3, [r3, #0]
 800c010:	4618      	mov	r0, r3
 800c012:	f7ff fd13 	bl	800ba3c <wolfSSL_BN_free>

    #if defined(OPENSSL_EXTRA)
        if (rsa->meth) {
 800c016:	687b      	ldr	r3, [r7, #4]
 800c018:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c01a:	2b00      	cmp	r3, #0
 800c01c:	d004      	beq.n	800c028 <wolfSSL_RSA_free+0x114>
            wolfSSL_RSA_meth_free((WOLFSSL_RSA_METHOD*)rsa->meth);
 800c01e:	687b      	ldr	r3, [r7, #4]
 800c020:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c022:	4618      	mov	r0, r3
 800c024:	f7ff ff53 	bl	800bece <wolfSSL_RSA_meth_free>
        }
    #endif

        /* Set back to NULLs for safety. */
        ForceZero(rsa, sizeof(*rsa));
 800c028:	213c      	movs	r1, #60	@ 0x3c
 800c02a:	6878      	ldr	r0, [r7, #4]
 800c02c:	f7ff f947 	bl	800b2be <ForceZero>

        XFREE(rsa, heap, DYNAMIC_TYPE_RSA);
 800c030:	687b      	ldr	r3, [r7, #4]
 800c032:	613b      	str	r3, [r7, #16]
 800c034:	693b      	ldr	r3, [r7, #16]
 800c036:	2b00      	cmp	r3, #0
 800c038:	d002      	beq.n	800c040 <wolfSSL_RSA_free+0x12c>
 800c03a:	6938      	ldr	r0, [r7, #16]
 800c03c:	f012 fe3a 	bl	801ecb4 <wolfSSL_Free>
        (void)heap;
    }
}
 800c040:	bf00      	nop
 800c042:	3728      	adds	r7, #40	@ 0x28
 800c044:	46bd      	mov	sp, r7
 800c046:	bd80      	pop	{r7, pc}

0800c048 <wolfSSL_DH_free>:
 * Cannot use dh after this call.
 *
 * @param [in] dh  DH key to free.
 */
void wolfSSL_DH_free(WOLFSSL_DH* dh)
{
 800c048:	b580      	push	{r7, lr}
 800c04a:	b088      	sub	sp, #32
 800c04c:	af00      	add	r7, sp, #0
 800c04e:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800c050:	2300      	movs	r3, #0
 800c052:	613b      	str	r3, [r7, #16]

    WOLFSSL_ENTER("wolfSSL_DH_free");

    if (dh != NULL) {
 800c054:	687b      	ldr	r3, [r7, #4]
 800c056:	2b00      	cmp	r3, #0
 800c058:	d00f      	beq.n	800c07a <wolfSSL_DH_free+0x32>
        int err;

        /* Only free if all references to it are done */
        wolfSSL_RefDec(&dh->ref, &doFree, &err);
 800c05a:	687b      	ldr	r3, [r7, #4]
 800c05c:	3320      	adds	r3, #32
 800c05e:	2101      	movs	r1, #1
 800c060:	4618      	mov	r0, r3
 800c062:	f7ff f917 	bl	800b294 <wolfSSL_Atomic_Int_FetchSub>
 800c066:	61f8      	str	r0, [r7, #28]
 800c068:	69fb      	ldr	r3, [r7, #28]
 800c06a:	2b01      	cmp	r3, #1
 800c06c:	bf0c      	ite	eq
 800c06e:	2301      	moveq	r3, #1
 800c070:	2300      	movne	r3, #0
 800c072:	b2db      	uxtb	r3, r3
 800c074:	613b      	str	r3, [r7, #16]
 800c076:	2300      	movs	r3, #0
 800c078:	60fb      	str	r3, [r7, #12]
        /* Ignore errors - doFree will be 0 on error. */
        (void)err;
    }
    if (doFree) {
 800c07a:	693b      	ldr	r3, [r7, #16]
 800c07c:	2b00      	cmp	r3, #0
 800c07e:	d03a      	beq.n	800c0f6 <wolfSSL_DH_free+0xae>
        /* Dispose of allocated reference counting data. */
        wolfSSL_RefFree(&dh->ref);

        /* Dispose of wolfSSL DH key. */
        if (dh->internal) {
 800c080:	687b      	ldr	r3, [r7, #4]
 800c082:	695b      	ldr	r3, [r3, #20]
 800c084:	2b00      	cmp	r3, #0
 800c086:	d010      	beq.n	800c0aa <wolfSSL_DH_free+0x62>
            wc_FreeDhKey((DhKey*)dh->internal);
 800c088:	687b      	ldr	r3, [r7, #4]
 800c08a:	695b      	ldr	r3, [r3, #20]
 800c08c:	4618      	mov	r0, r3
 800c08e:	f00e fc11 	bl	801a8b4 <wc_FreeDhKey>
            XFREE(dh->internal, NULL, DYNAMIC_TYPE_DH);
 800c092:	687b      	ldr	r3, [r7, #4]
 800c094:	695b      	ldr	r3, [r3, #20]
 800c096:	61bb      	str	r3, [r7, #24]
 800c098:	69bb      	ldr	r3, [r7, #24]
 800c09a:	2b00      	cmp	r3, #0
 800c09c:	d002      	beq.n	800c0a4 <wolfSSL_DH_free+0x5c>
 800c09e:	69b8      	ldr	r0, [r7, #24]
 800c0a0:	f012 fe08 	bl	801ecb4 <wolfSSL_Free>
            dh->internal = NULL;
 800c0a4:	687b      	ldr	r3, [r7, #4]
 800c0a6:	2200      	movs	r2, #0
 800c0a8:	615a      	str	r2, [r3, #20]
        }

        /* Dispose of any allocated BNs. */
        wolfSSL_BN_free(dh->priv_key);
 800c0aa:	687b      	ldr	r3, [r7, #4]
 800c0ac:	691b      	ldr	r3, [r3, #16]
 800c0ae:	4618      	mov	r0, r3
 800c0b0:	f7ff fcc4 	bl	800ba3c <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->pub_key);
 800c0b4:	687b      	ldr	r3, [r7, #4]
 800c0b6:	68db      	ldr	r3, [r3, #12]
 800c0b8:	4618      	mov	r0, r3
 800c0ba:	f7ff fcbf 	bl	800ba3c <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->g);
 800c0be:	687b      	ldr	r3, [r7, #4]
 800c0c0:	685b      	ldr	r3, [r3, #4]
 800c0c2:	4618      	mov	r0, r3
 800c0c4:	f7ff fcba 	bl	800ba3c <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->p);
 800c0c8:	687b      	ldr	r3, [r7, #4]
 800c0ca:	681b      	ldr	r3, [r3, #0]
 800c0cc:	4618      	mov	r0, r3
 800c0ce:	f7ff fcb5 	bl	800ba3c <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->q);
 800c0d2:	687b      	ldr	r3, [r7, #4]
 800c0d4:	689b      	ldr	r3, [r3, #8]
 800c0d6:	4618      	mov	r0, r3
 800c0d8:	f7ff fcb0 	bl	800ba3c <wolfSSL_BN_free>
        /* Set back to NULLs for safety. */
        XMEMSET(dh, 0, sizeof(WOLFSSL_DH));
 800c0dc:	2224      	movs	r2, #36	@ 0x24
 800c0de:	2100      	movs	r1, #0
 800c0e0:	6878      	ldr	r0, [r7, #4]
 800c0e2:	f01c fd9f 	bl	8028c24 <memset>

        XFREE(dh, NULL, DYNAMIC_TYPE_DH);
 800c0e6:	687b      	ldr	r3, [r7, #4]
 800c0e8:	617b      	str	r3, [r7, #20]
 800c0ea:	697b      	ldr	r3, [r7, #20]
 800c0ec:	2b00      	cmp	r3, #0
 800c0ee:	d002      	beq.n	800c0f6 <wolfSSL_DH_free+0xae>
 800c0f0:	6978      	ldr	r0, [r7, #20]
 800c0f2:	f012 fddf 	bl	801ecb4 <wolfSSL_Free>
    }
}
 800c0f6:	bf00      	nop
 800c0f8:	3720      	adds	r7, #32
 800c0fa:	46bd      	mov	sp, r7
 800c0fc:	bd80      	pop	{r7, pc}

0800c0fe <wolfSSL_EC_GROUP_free>:
 * Cannot use group after this call.
 *
 * @param [in] group  EC group to free.
 */
void wolfSSL_EC_GROUP_free(WOLFSSL_EC_GROUP *group)
{
 800c0fe:	b580      	push	{r7, lr}
 800c100:	b084      	sub	sp, #16
 800c102:	af00      	add	r7, sp, #0
 800c104:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_EC_GROUP_free");

    /* Dispose of EC group. */
    XFREE(group, NULL, DYNAMIC_TYPE_ECC);
 800c106:	687b      	ldr	r3, [r7, #4]
 800c108:	60fb      	str	r3, [r7, #12]
 800c10a:	68fb      	ldr	r3, [r7, #12]
 800c10c:	2b00      	cmp	r3, #0
 800c10e:	d002      	beq.n	800c116 <wolfSSL_EC_GROUP_free+0x18>
 800c110:	68f8      	ldr	r0, [r7, #12]
 800c112:	f012 fdcf 	bl	801ecb4 <wolfSSL_Free>
}
 800c116:	bf00      	nop
 800c118:	3710      	adds	r7, #16
 800c11a:	46bd      	mov	sp, r7
 800c11c:	bd80      	pop	{r7, pc}

0800c11e <wolfSSL_EC_POINT_free>:
 * Cannot use point after this call.
 *
 * @param [in, out] point  EC point to free.
 */
void wolfSSL_EC_POINT_free(WOLFSSL_EC_POINT *point)
{
 800c11e:	b580      	push	{r7, lr}
 800c120:	b084      	sub	sp, #16
 800c122:	af00      	add	r7, sp, #0
 800c124:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_EC_POINT_free");

    if (point != NULL) {
 800c126:	687b      	ldr	r3, [r7, #4]
 800c128:	2b00      	cmp	r3, #0
 800c12a:	d031      	beq.n	800c190 <wolfSSL_EC_POINT_free+0x72>
        if (point->internal != NULL) {
 800c12c:	687b      	ldr	r3, [r7, #4]
 800c12e:	68db      	ldr	r3, [r3, #12]
 800c130:	2b00      	cmp	r3, #0
 800c132:	d007      	beq.n	800c144 <wolfSSL_EC_POINT_free+0x26>
            wc_ecc_del_point((ecc_point*)point->internal);
 800c134:	687b      	ldr	r3, [r7, #4]
 800c136:	68db      	ldr	r3, [r3, #12]
 800c138:	4618      	mov	r0, r3
 800c13a:	f010 fd00 	bl	801cb3e <wc_ecc_del_point>
            point->internal = NULL;
 800c13e:	687b      	ldr	r3, [r7, #4]
 800c140:	2200      	movs	r2, #0
 800c142:	60da      	str	r2, [r3, #12]
        }

        /* Free ordinates. */
        wolfSSL_BN_free(point->X);
 800c144:	687b      	ldr	r3, [r7, #4]
 800c146:	681b      	ldr	r3, [r3, #0]
 800c148:	4618      	mov	r0, r3
 800c14a:	f7ff fc77 	bl	800ba3c <wolfSSL_BN_free>
        wolfSSL_BN_free(point->Y);
 800c14e:	687b      	ldr	r3, [r7, #4]
 800c150:	685b      	ldr	r3, [r3, #4]
 800c152:	4618      	mov	r0, r3
 800c154:	f7ff fc72 	bl	800ba3c <wolfSSL_BN_free>
        wolfSSL_BN_free(point->Z);
 800c158:	687b      	ldr	r3, [r7, #4]
 800c15a:	689b      	ldr	r3, [r3, #8]
 800c15c:	4618      	mov	r0, r3
 800c15e:	f7ff fc6d 	bl	800ba3c <wolfSSL_BN_free>
        /* Clear fields. */
        point->X = NULL;
 800c162:	687b      	ldr	r3, [r7, #4]
 800c164:	2200      	movs	r2, #0
 800c166:	601a      	str	r2, [r3, #0]
        point->Y = NULL;
 800c168:	687b      	ldr	r3, [r7, #4]
 800c16a:	2200      	movs	r2, #0
 800c16c:	605a      	str	r2, [r3, #4]
        point->Z = NULL;
 800c16e:	687b      	ldr	r3, [r7, #4]
 800c170:	2200      	movs	r2, #0
 800c172:	609a      	str	r2, [r3, #8]
        point->inSet = 0;
 800c174:	687b      	ldr	r3, [r7, #4]
 800c176:	2200      	movs	r2, #0
 800c178:	741a      	strb	r2, [r3, #16]
        point->exSet = 0;
 800c17a:	687b      	ldr	r3, [r7, #4]
 800c17c:	2200      	movs	r2, #0
 800c17e:	745a      	strb	r2, [r3, #17]

        /* Dispose of EC point. */
        XFREE(point, NULL, DYNAMIC_TYPE_ECC);
 800c180:	687b      	ldr	r3, [r7, #4]
 800c182:	60fb      	str	r3, [r7, #12]
 800c184:	68fb      	ldr	r3, [r7, #12]
 800c186:	2b00      	cmp	r3, #0
 800c188:	d002      	beq.n	800c190 <wolfSSL_EC_POINT_free+0x72>
 800c18a:	68f8      	ldr	r0, [r7, #12]
 800c18c:	f012 fd92 	bl	801ecb4 <wolfSSL_Free>
    }
}
 800c190:	bf00      	nop
 800c192:	3710      	adds	r7, #16
 800c194:	46bd      	mov	sp, r7
 800c196:	bd80      	pop	{r7, pc}

0800c198 <wolfSSL_EC_KEY_free>:
 * Cannot use key after this call.
 *
 * @param [in] key  EC key to free.
 */
void wolfSSL_EC_KEY_free(WOLFSSL_EC_KEY *key)
{
 800c198:	b580      	push	{r7, lr}
 800c19a:	b088      	sub	sp, #32
 800c19c:	af00      	add	r7, sp, #0
 800c19e:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800c1a0:	2300      	movs	r3, #0
 800c1a2:	60fb      	str	r3, [r7, #12]

    (void)err;

    WOLFSSL_ENTER("wolfSSL_EC_KEY_free");

    if (key != NULL) {
 800c1a4:	687b      	ldr	r3, [r7, #4]
 800c1a6:	2b00      	cmp	r3, #0
 800c1a8:	d042      	beq.n	800c230 <wolfSSL_EC_KEY_free+0x98>
        void* heap = key->heap;
 800c1aa:	687b      	ldr	r3, [r7, #4]
 800c1ac:	691b      	ldr	r3, [r3, #16]
 800c1ae:	61fb      	str	r3, [r7, #28]

        /* Decrement reference count. */
        wolfSSL_RefDec(&key->ref, &doFree, &err);
 800c1b0:	687b      	ldr	r3, [r7, #4]
 800c1b2:	331c      	adds	r3, #28
 800c1b4:	2101      	movs	r1, #1
 800c1b6:	4618      	mov	r0, r3
 800c1b8:	f7ff f86c 	bl	800b294 <wolfSSL_Atomic_Int_FetchSub>
 800c1bc:	61b8      	str	r0, [r7, #24]
 800c1be:	69bb      	ldr	r3, [r7, #24]
 800c1c0:	2b01      	cmp	r3, #1
 800c1c2:	bf0c      	ite	eq
 800c1c4:	2301      	moveq	r3, #1
 800c1c6:	2300      	movne	r3, #0
 800c1c8:	b2db      	uxtb	r3, r3
 800c1ca:	60fb      	str	r3, [r7, #12]
 800c1cc:	2300      	movs	r3, #0
 800c1ce:	60bb      	str	r3, [r7, #8]
        if (doFree) {
 800c1d0:	68fb      	ldr	r3, [r7, #12]
 800c1d2:	2b00      	cmp	r3, #0
 800c1d4:	d02c      	beq.n	800c230 <wolfSSL_EC_KEY_free+0x98>
            /* Dispose of allocated reference counting data. */
            wolfSSL_RefFree(&key->ref);

            /* Dispose of private key. */
            wolfSSL_BN_free(key->priv_key);
 800c1d6:	687b      	ldr	r3, [r7, #4]
 800c1d8:	689b      	ldr	r3, [r3, #8]
 800c1da:	4618      	mov	r0, r3
 800c1dc:	f7ff fc2e 	bl	800ba3c <wolfSSL_BN_free>
            wolfSSL_EC_POINT_free(key->pub_key);
 800c1e0:	687b      	ldr	r3, [r7, #4]
 800c1e2:	685b      	ldr	r3, [r3, #4]
 800c1e4:	4618      	mov	r0, r3
 800c1e6:	f7ff ff9a 	bl	800c11e <wolfSSL_EC_POINT_free>
            wolfSSL_EC_GROUP_free(key->group);
 800c1ea:	687b      	ldr	r3, [r7, #4]
 800c1ec:	681b      	ldr	r3, [r3, #0]
 800c1ee:	4618      	mov	r0, r3
 800c1f0:	f7ff ff85 	bl	800c0fe <wolfSSL_EC_GROUP_free>
            if (key->internal != NULL) {
 800c1f4:	687b      	ldr	r3, [r7, #4]
 800c1f6:	68db      	ldr	r3, [r3, #12]
 800c1f8:	2b00      	cmp	r3, #0
 800c1fa:	d00d      	beq.n	800c218 <wolfSSL_EC_KEY_free+0x80>
                /* Dispose of wolfCrypt representation of EC key. */
                wc_ecc_free((ecc_key*)key->internal);
 800c1fc:	687b      	ldr	r3, [r7, #4]
 800c1fe:	68db      	ldr	r3, [r3, #12]
 800c200:	4618      	mov	r0, r3
 800c202:	f010 ff42 	bl	801d08a <wc_ecc_free>
                XFREE(key->internal, heap, DYNAMIC_TYPE_ECC);
 800c206:	687b      	ldr	r3, [r7, #4]
 800c208:	68db      	ldr	r3, [r3, #12]
 800c20a:	617b      	str	r3, [r7, #20]
 800c20c:	697b      	ldr	r3, [r7, #20]
 800c20e:	2b00      	cmp	r3, #0
 800c210:	d002      	beq.n	800c218 <wolfSSL_EC_KEY_free+0x80>
 800c212:	6978      	ldr	r0, [r7, #20]
 800c214:	f012 fd4e 	bl	801ecb4 <wolfSSL_Free>
            }

            /* Set back to NULLs for safety. */
            ForceZero(key, sizeof(*key));
 800c218:	2120      	movs	r1, #32
 800c21a:	6878      	ldr	r0, [r7, #4]
 800c21c:	f7ff f84f 	bl	800b2be <ForceZero>

            /* Dispose of the memory associated with the EC key. */
            XFREE(key, heap, DYNAMIC_TYPE_ECC);
 800c220:	687b      	ldr	r3, [r7, #4]
 800c222:	613b      	str	r3, [r7, #16]
 800c224:	693b      	ldr	r3, [r7, #16]
 800c226:	2b00      	cmp	r3, #0
 800c228:	d002      	beq.n	800c230 <wolfSSL_EC_KEY_free+0x98>
 800c22a:	6938      	ldr	r0, [r7, #16]
 800c22c:	f012 fd42 	bl	801ecb4 <wolfSSL_Free>
            (void)heap;
        }
    }
}
 800c230:	bf00      	nop
 800c232:	3720      	adds	r7, #32
 800c234:	46bd      	mov	sp, r7
 800c236:	bd80      	pop	{r7, pc}

0800c238 <wolfSSL_CTX_new_ex>:
   WOLFSSL_METHOD pointer passed in is given to ctx to manage.
   This function frees the passed in WOLFSSL_METHOD struct on failure and on
   success is freed when ctx is freed.
 */
WOLFSSL_CTX* wolfSSL_CTX_new_ex(WOLFSSL_METHOD* method, void* heap)
{
 800c238:	b580      	push	{r7, lr}
 800c23a:	b088      	sub	sp, #32
 800c23c:	af00      	add	r7, sp, #0
 800c23e:	6078      	str	r0, [r7, #4]
 800c240:	6039      	str	r1, [r7, #0]
    WOLFSSL_CTX* ctx = NULL;
 800c242:	2300      	movs	r3, #0
 800c244:	61fb      	str	r3, [r7, #28]

    WOLFSSL_ENTER("wolfSSL_CTX_new_ex");

    if (initRefCount == 0) {
 800c246:	4b1e      	ldr	r3, [pc, #120]	@ (800c2c0 <wolfSSL_CTX_new_ex+0x88>)
 800c248:	681b      	ldr	r3, [r3, #0]
 800c24a:	2b00      	cmp	r3, #0
 800c24c:	d10f      	bne.n	800c26e <wolfSSL_CTX_new_ex+0x36>
        /* user no longer forced to call Init themselves */
        int ret = wolfSSL_Init();
 800c24e:	f000 fb2f 	bl	800c8b0 <wolfSSL_Init>
 800c252:	61b8      	str	r0, [r7, #24]
        if (ret != WOLFSSL_SUCCESS) {
 800c254:	69bb      	ldr	r3, [r7, #24]
 800c256:	2b01      	cmp	r3, #1
 800c258:	d009      	beq.n	800c26e <wolfSSL_CTX_new_ex+0x36>
            WOLFSSL_MSG("wolfSSL_Init failed");
            WOLFSSL_LEAVE("wolfSSL_CTX_new_ex", 0);
            XFREE(method, heap, DYNAMIC_TYPE_METHOD);
 800c25a:	687b      	ldr	r3, [r7, #4]
 800c25c:	617b      	str	r3, [r7, #20]
 800c25e:	697b      	ldr	r3, [r7, #20]
 800c260:	2b00      	cmp	r3, #0
 800c262:	d002      	beq.n	800c26a <wolfSSL_CTX_new_ex+0x32>
 800c264:	6978      	ldr	r0, [r7, #20]
 800c266:	f012 fd25 	bl	801ecb4 <wolfSSL_Free>
            return NULL;
 800c26a:	2300      	movs	r3, #0
 800c26c:	e024      	b.n	800c2b8 <wolfSSL_CTX_new_ex+0x80>
        }
    }

#ifndef NO_TLS
    if (method == NULL)
 800c26e:	687b      	ldr	r3, [r7, #4]
 800c270:	2b00      	cmp	r3, #0
 800c272:	d101      	bne.n	800c278 <wolfSSL_CTX_new_ex+0x40>
        return ctx;
 800c274:	69fb      	ldr	r3, [r7, #28]
 800c276:	e01f      	b.n	800c2b8 <wolfSSL_CTX_new_ex+0x80>
#else
    /* a blank TLS method */
    method = (WOLFSSL_METHOD*)&gNoTlsMethod;
#endif

    ctx = (WOLFSSL_CTX*)XMALLOC(sizeof(WOLFSSL_CTX), heap, DYNAMIC_TYPE_CTX);
 800c278:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 800c27c:	f012 fcfe 	bl	801ec7c <wolfSSL_Malloc>
 800c280:	61f8      	str	r0, [r7, #28]
    if (ctx) {
 800c282:	69fb      	ldr	r3, [r7, #28]
 800c284:	2b00      	cmp	r3, #0
 800c286:	d00e      	beq.n	800c2a6 <wolfSSL_CTX_new_ex+0x6e>
        int ret;

        ret = InitSSL_Ctx(ctx, method, heap);
 800c288:	683a      	ldr	r2, [r7, #0]
 800c28a:	6879      	ldr	r1, [r7, #4]
 800c28c:	69f8      	ldr	r0, [r7, #28]
 800c28e:	f7fc fc20 	bl	8008ad2 <InitSSL_Ctx>
 800c292:	60f8      	str	r0, [r7, #12]
    #ifdef WOLFSSL_STATIC_MEMORY
        if (heap != NULL) {
            ctx->onHeapHint = 1; /* free the memory back to heap when done */
        }
    #endif
        if (ret < 0) {
 800c294:	68fb      	ldr	r3, [r7, #12]
 800c296:	2b00      	cmp	r3, #0
 800c298:	da0d      	bge.n	800c2b6 <wolfSSL_CTX_new_ex+0x7e>
            WOLFSSL_MSG("Init CTX failed");
            wolfSSL_CTX_free(ctx);
 800c29a:	69f8      	ldr	r0, [r7, #28]
 800c29c:	f000 f81f 	bl	800c2de <wolfSSL_CTX_free>
            ctx = NULL;
 800c2a0:	2300      	movs	r3, #0
 800c2a2:	61fb      	str	r3, [r7, #28]
 800c2a4:	e007      	b.n	800c2b6 <wolfSSL_CTX_new_ex+0x7e>
        }
#endif
    }
    else {
        WOLFSSL_MSG("Alloc CTX failed, method freed");
        XFREE(method, heap, DYNAMIC_TYPE_METHOD);
 800c2a6:	687b      	ldr	r3, [r7, #4]
 800c2a8:	613b      	str	r3, [r7, #16]
 800c2aa:	693b      	ldr	r3, [r7, #16]
 800c2ac:	2b00      	cmp	r3, #0
 800c2ae:	d002      	beq.n	800c2b6 <wolfSSL_CTX_new_ex+0x7e>
 800c2b0:	6938      	ldr	r0, [r7, #16]
 800c2b2:	f012 fcff 	bl	801ecb4 <wolfSSL_Free>
        }
    }
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

    WOLFSSL_LEAVE("wolfSSL_CTX_new_ex", 0);
    return ctx;
 800c2b6:	69fb      	ldr	r3, [r7, #28]
}
 800c2b8:	4618      	mov	r0, r3
 800c2ba:	3720      	adds	r7, #32
 800c2bc:	46bd      	mov	sp, r7
 800c2be:	bd80      	pop	{r7, pc}
 800c2c0:	20001c20 	.word	0x20001c20

0800c2c4 <wolfSSL_CTX_new>:


WOLFSSL_ABI
WOLFSSL_CTX* wolfSSL_CTX_new(WOLFSSL_METHOD* method)
{
 800c2c4:	b580      	push	{r7, lr}
 800c2c6:	b082      	sub	sp, #8
 800c2c8:	af00      	add	r7, sp, #0
 800c2ca:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_HEAP_TEST
    /* if testing the heap hint then set top level CTX to have test value */
    return wolfSSL_CTX_new_ex(method, (void*)WOLFSSL_HEAP_TEST);
#else
    return wolfSSL_CTX_new_ex(method, NULL);
 800c2cc:	2100      	movs	r1, #0
 800c2ce:	6878      	ldr	r0, [r7, #4]
 800c2d0:	f7ff ffb2 	bl	800c238 <wolfSSL_CTX_new_ex>
 800c2d4:	4603      	mov	r3, r0
#endif
}
 800c2d6:	4618      	mov	r0, r3
 800c2d8:	3708      	adds	r7, #8
 800c2da:	46bd      	mov	sp, r7
 800c2dc:	bd80      	pop	{r7, pc}

0800c2de <wolfSSL_CTX_free>:
#endif
}

WOLFSSL_ABI
void wolfSSL_CTX_free(WOLFSSL_CTX* ctx)
{
 800c2de:	b580      	push	{r7, lr}
 800c2e0:	b082      	sub	sp, #8
 800c2e2:	af00      	add	r7, sp, #0
 800c2e4:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_CTX_free");
    if (ctx) {
 800c2e6:	687b      	ldr	r3, [r7, #4]
 800c2e8:	2b00      	cmp	r3, #0
 800c2ea:	d002      	beq.n	800c2f2 <wolfSSL_CTX_free+0x14>
            wc_SrpTerm(ctx->srp);
            XFREE(ctx->srp, ctx->heap, DYNAMIC_TYPE_SRP);
            ctx->srp = NULL;
        }
#endif
        FreeSSL_Ctx(ctx);
 800c2ec:	6878      	ldr	r0, [r7, #4]
 800c2ee:	f7fc fdc9 	bl	8008e84 <FreeSSL_Ctx>
    }

    WOLFSSL_LEAVE("wolfSSL_CTX_free", 0);
}
 800c2f2:	bf00      	nop
 800c2f4:	3708      	adds	r7, #8
 800c2f6:	46bd      	mov	sp, r7
 800c2f8:	bd80      	pop	{r7, pc}

0800c2fa <wolfSSL_free>:
}


WOLFSSL_ABI
void wolfSSL_free(WOLFSSL* ssl)
{
 800c2fa:	b580      	push	{r7, lr}
 800c2fc:	b082      	sub	sp, #8
 800c2fe:	af00      	add	r7, sp, #0
 800c300:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_free");

    if (ssl) {
 800c302:	687b      	ldr	r3, [r7, #4]
 800c304:	2b00      	cmp	r3, #0
 800c306:	d006      	beq.n	800c316 <wolfSSL_free+0x1c>
        WOLFSSL_MSG_EX("Free SSL: %p", (wc_ptr_t)ssl);
        FreeSSL(ssl, ssl->ctx->heap);
 800c308:	687b      	ldr	r3, [r7, #4]
 800c30a:	681b      	ldr	r3, [r3, #0]
 800c30c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800c30e:	4619      	mov	r1, r3
 800c310:	6878      	ldr	r0, [r7, #4]
 800c312:	f7fd fdbb 	bl	8009e8c <FreeSSL>
    }
    else {
        WOLFSSL_MSG("Free SSL: wolfSSL_free already null");
    }
    WOLFSSL_LEAVE("wolfSSL_free", 0);
}
 800c316:	bf00      	nop
 800c318:	3708      	adds	r7, #8
 800c31a:	46bd      	mov	sp, r7
 800c31c:	bd80      	pop	{r7, pc}

0800c31e <wolfSSL_CTX_GetDevId>:
}

/* helpers to get device id and heap */
WOLFSSL_ABI
int wolfSSL_CTX_GetDevId(WOLFSSL_CTX* ctx, WOLFSSL* ssl)
{
 800c31e:	b480      	push	{r7}
 800c320:	b085      	sub	sp, #20
 800c322:	af00      	add	r7, sp, #0
 800c324:	6078      	str	r0, [r7, #4]
 800c326:	6039      	str	r1, [r7, #0]
    int devId = INVALID_DEVID;
 800c328:	f06f 0301 	mvn.w	r3, #1
 800c32c:	60fb      	str	r3, [r7, #12]
    if (ssl != NULL)
 800c32e:	683b      	ldr	r3, [r7, #0]
 800c330:	2b00      	cmp	r3, #0
 800c332:	d005      	beq.n	800c340 <wolfSSL_CTX_GetDevId+0x22>
        devId = ssl->devId;
 800c334:	683b      	ldr	r3, [r7, #0]
 800c336:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800c33a:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800c33e:	60fb      	str	r3, [r7, #12]
    if (ctx != NULL && devId == INVALID_DEVID)
 800c340:	687b      	ldr	r3, [r7, #4]
 800c342:	2b00      	cmp	r3, #0
 800c344:	d007      	beq.n	800c356 <wolfSSL_CTX_GetDevId+0x38>
 800c346:	68fb      	ldr	r3, [r7, #12]
 800c348:	f113 0f02 	cmn.w	r3, #2
 800c34c:	d103      	bne.n	800c356 <wolfSSL_CTX_GetDevId+0x38>
        devId = ctx->devId;
 800c34e:	687b      	ldr	r3, [r7, #4]
 800c350:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 800c354:	60fb      	str	r3, [r7, #12]
    return devId;
 800c356:	68fb      	ldr	r3, [r7, #12]
}
 800c358:	4618      	mov	r0, r3
 800c35a:	3714      	adds	r7, #20
 800c35c:	46bd      	mov	sp, r7
 800c35e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c362:	4770      	bx	lr

0800c364 <wolfSSL_CTX_GetCertManager>:

#endif /* ATOMIC_USER */

#ifndef NO_CERTS
WOLFSSL_CERT_MANAGER* wolfSSL_CTX_GetCertManager(WOLFSSL_CTX* ctx)
{
 800c364:	b480      	push	{r7}
 800c366:	b085      	sub	sp, #20
 800c368:	af00      	add	r7, sp, #0
 800c36a:	6078      	str	r0, [r7, #4]
    WOLFSSL_CERT_MANAGER* cm = NULL;
 800c36c:	2300      	movs	r3, #0
 800c36e:	60fb      	str	r3, [r7, #12]
    if (ctx)
 800c370:	687b      	ldr	r3, [r7, #4]
 800c372:	2b00      	cmp	r3, #0
 800c374:	d002      	beq.n	800c37c <wolfSSL_CTX_GetCertManager+0x18>
        cm = ctx->cm;
 800c376:	687b      	ldr	r3, [r7, #4]
 800c378:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c37a:	60fb      	str	r3, [r7, #12]
    return cm;
 800c37c:	68fb      	ldr	r3, [r7, #12]
}
 800c37e:	4618      	mov	r0, r3
 800c380:	3714      	adds	r7, #20
 800c382:	46bd      	mov	sp, r7
 800c384:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c388:	4770      	bx	lr
	...

0800c38c <HashSigner>:

#ifndef NO_CERTS

/* hash is the SHA digest of name, just use first 32 bits as hash */
static WC_INLINE word32 HashSigner(const byte* hash)
{
 800c38c:	b580      	push	{r7, lr}
 800c38e:	b082      	sub	sp, #8
 800c390:	af00      	add	r7, sp, #0
 800c392:	6078      	str	r0, [r7, #4]
    return MakeWordFromHash(hash) % CA_TABLE_SIZE;
 800c394:	6878      	ldr	r0, [r7, #4]
 800c396:	f7fe ffc6 	bl	800b326 <MakeWordFromHash>
 800c39a:	4601      	mov	r1, r0
 800c39c:	4b07      	ldr	r3, [pc, #28]	@ (800c3bc <HashSigner+0x30>)
 800c39e:	fba3 2301 	umull	r2, r3, r3, r1
 800c3a2:	08da      	lsrs	r2, r3, #3
 800c3a4:	4613      	mov	r3, r2
 800c3a6:	009b      	lsls	r3, r3, #2
 800c3a8:	4413      	add	r3, r2
 800c3aa:	005b      	lsls	r3, r3, #1
 800c3ac:	4413      	add	r3, r2
 800c3ae:	1aca      	subs	r2, r1, r3
 800c3b0:	4613      	mov	r3, r2
}
 800c3b2:	4618      	mov	r0, r3
 800c3b4:	3708      	adds	r7, #8
 800c3b6:	46bd      	mov	sp, r7
 800c3b8:	bd80      	pop	{r7, pc}
 800c3ba:	bf00      	nop
 800c3bc:	ba2e8ba3 	.word	0xba2e8ba3

0800c3c0 <AlreadySigner>:


/* does CA already exist on signer list */
int AlreadySigner(WOLFSSL_CERT_MANAGER* cm, byte* hash)
{
 800c3c0:	b580      	push	{r7, lr}
 800c3c2:	b086      	sub	sp, #24
 800c3c4:	af00      	add	r7, sp, #0
 800c3c6:	6078      	str	r0, [r7, #4]
 800c3c8:	6039      	str	r1, [r7, #0]
    Signer* signers;
    int     ret = 0;
 800c3ca:	2300      	movs	r3, #0
 800c3cc:	613b      	str	r3, [r7, #16]
    word32  row;

    if (cm == NULL || hash == NULL) {
 800c3ce:	687b      	ldr	r3, [r7, #4]
 800c3d0:	2b00      	cmp	r3, #0
 800c3d2:	d002      	beq.n	800c3da <AlreadySigner+0x1a>
 800c3d4:	683b      	ldr	r3, [r7, #0]
 800c3d6:	2b00      	cmp	r3, #0
 800c3d8:	d101      	bne.n	800c3de <AlreadySigner+0x1e>
        return ret;
 800c3da:	693b      	ldr	r3, [r7, #16]
 800c3dc:	e02e      	b.n	800c43c <AlreadySigner+0x7c>
    }

    row = HashSigner(hash);
 800c3de:	6838      	ldr	r0, [r7, #0]
 800c3e0:	f7ff ffd4 	bl	800c38c <HashSigner>
 800c3e4:	60f8      	str	r0, [r7, #12]

    if (wc_LockMutex(&cm->caLock) != 0) {
 800c3e6:	687b      	ldr	r3, [r7, #4]
 800c3e8:	335c      	adds	r3, #92	@ 0x5c
 800c3ea:	4618      	mov	r0, r3
 800c3ec:	f01b f980 	bl	80276f0 <wc_LockMutex>
 800c3f0:	4603      	mov	r3, r0
 800c3f2:	2b00      	cmp	r3, #0
 800c3f4:	d001      	beq.n	800c3fa <AlreadySigner+0x3a>
        return ret;
 800c3f6:	693b      	ldr	r3, [r7, #16]
 800c3f8:	e020      	b.n	800c43c <AlreadySigner+0x7c>
    }
    signers = cm->caTable[row];
 800c3fa:	687b      	ldr	r3, [r7, #4]
 800c3fc:	68fa      	ldr	r2, [r7, #12]
 800c3fe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c402:	617b      	str	r3, [r7, #20]
    while (signers) {
 800c404:	e011      	b.n	800c42a <AlreadySigner+0x6a>
        byte* subjectHash;

    #ifndef NO_SKID
        subjectHash = signers->subjectKeyIdHash;
 800c406:	697b      	ldr	r3, [r7, #20]
 800c408:	3340      	adds	r3, #64	@ 0x40
 800c40a:	60bb      	str	r3, [r7, #8]
    #else
        subjectHash = signers->subjectNameHash;
    #endif

        if (XMEMCMP(hash, subjectHash, SIGNER_DIGEST_SIZE) == 0) {
 800c40c:	2220      	movs	r2, #32
 800c40e:	68b9      	ldr	r1, [r7, #8]
 800c410:	6838      	ldr	r0, [r7, #0]
 800c412:	f01c fbdd 	bl	8028bd0 <memcmp>
 800c416:	4603      	mov	r3, r0
 800c418:	2b00      	cmp	r3, #0
 800c41a:	d102      	bne.n	800c422 <AlreadySigner+0x62>
            ret = 1; /* success */
 800c41c:	2301      	movs	r3, #1
 800c41e:	613b      	str	r3, [r7, #16]
            break;
 800c420:	e006      	b.n	800c430 <AlreadySigner+0x70>
        }
        signers = signers->next;
 800c422:	697b      	ldr	r3, [r7, #20]
 800c424:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c428:	617b      	str	r3, [r7, #20]
    while (signers) {
 800c42a:	697b      	ldr	r3, [r7, #20]
 800c42c:	2b00      	cmp	r3, #0
 800c42e:	d1ea      	bne.n	800c406 <AlreadySigner+0x46>
    }
    wc_UnLockMutex(&cm->caLock);
 800c430:	687b      	ldr	r3, [r7, #4]
 800c432:	335c      	adds	r3, #92	@ 0x5c
 800c434:	4618      	mov	r0, r3
 800c436:	f01b f966 	bl	8027706 <wc_UnLockMutex>

    return ret;
 800c43a:	693b      	ldr	r3, [r7, #16]
}
 800c43c:	4618      	mov	r0, r3
 800c43e:	3718      	adds	r7, #24
 800c440:	46bd      	mov	sp, r7
 800c442:	bd80      	pop	{r7, pc}

0800c444 <GetCA>:
#endif /* WOLFSSL_TRUST_PEER_CERT */


/* return CA if found, otherwise NULL */
Signer* GetCA(void* vp, byte* hash)
{
 800c444:	b580      	push	{r7, lr}
 800c446:	b088      	sub	sp, #32
 800c448:	af00      	add	r7, sp, #0
 800c44a:	6078      	str	r0, [r7, #4]
 800c44c:	6039      	str	r1, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 800c44e:	687b      	ldr	r3, [r7, #4]
 800c450:	617b      	str	r3, [r7, #20]
    Signer* ret = NULL;
 800c452:	2300      	movs	r3, #0
 800c454:	61fb      	str	r3, [r7, #28]
    Signer* signers;
    word32  row = 0;
 800c456:	2300      	movs	r3, #0
 800c458:	613b      	str	r3, [r7, #16]

    if (cm == NULL || hash == NULL)
 800c45a:	697b      	ldr	r3, [r7, #20]
 800c45c:	2b00      	cmp	r3, #0
 800c45e:	d002      	beq.n	800c466 <GetCA+0x22>
 800c460:	683b      	ldr	r3, [r7, #0]
 800c462:	2b00      	cmp	r3, #0
 800c464:	d101      	bne.n	800c46a <GetCA+0x26>
        return NULL;
 800c466:	2300      	movs	r3, #0
 800c468:	e02e      	b.n	800c4c8 <GetCA+0x84>

    row = HashSigner(hash);
 800c46a:	6838      	ldr	r0, [r7, #0]
 800c46c:	f7ff ff8e 	bl	800c38c <HashSigner>
 800c470:	6138      	str	r0, [r7, #16]

    if (wc_LockMutex(&cm->caLock) != 0)
 800c472:	697b      	ldr	r3, [r7, #20]
 800c474:	335c      	adds	r3, #92	@ 0x5c
 800c476:	4618      	mov	r0, r3
 800c478:	f01b f93a 	bl	80276f0 <wc_LockMutex>
 800c47c:	4603      	mov	r3, r0
 800c47e:	2b00      	cmp	r3, #0
 800c480:	d001      	beq.n	800c486 <GetCA+0x42>
        return ret;
 800c482:	69fb      	ldr	r3, [r7, #28]
 800c484:	e020      	b.n	800c4c8 <GetCA+0x84>

    signers = cm->caTable[row];
 800c486:	697b      	ldr	r3, [r7, #20]
 800c488:	693a      	ldr	r2, [r7, #16]
 800c48a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c48e:	61bb      	str	r3, [r7, #24]
    while (signers) {
 800c490:	e011      	b.n	800c4b6 <GetCA+0x72>
        byte* subjectHash;
        #ifndef NO_SKID
            subjectHash = signers->subjectKeyIdHash;
 800c492:	69bb      	ldr	r3, [r7, #24]
 800c494:	3340      	adds	r3, #64	@ 0x40
 800c496:	60fb      	str	r3, [r7, #12]
        #else
            subjectHash = signers->subjectNameHash;
        #endif
        if (XMEMCMP(hash, subjectHash, SIGNER_DIGEST_SIZE) == 0) {
 800c498:	2220      	movs	r2, #32
 800c49a:	68f9      	ldr	r1, [r7, #12]
 800c49c:	6838      	ldr	r0, [r7, #0]
 800c49e:	f01c fb97 	bl	8028bd0 <memcmp>
 800c4a2:	4603      	mov	r3, r0
 800c4a4:	2b00      	cmp	r3, #0
 800c4a6:	d102      	bne.n	800c4ae <GetCA+0x6a>
            ret = signers;
 800c4a8:	69bb      	ldr	r3, [r7, #24]
 800c4aa:	61fb      	str	r3, [r7, #28]
            break;
 800c4ac:	e006      	b.n	800c4bc <GetCA+0x78>
        }
        signers = signers->next;
 800c4ae:	69bb      	ldr	r3, [r7, #24]
 800c4b0:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c4b4:	61bb      	str	r3, [r7, #24]
    while (signers) {
 800c4b6:	69bb      	ldr	r3, [r7, #24]
 800c4b8:	2b00      	cmp	r3, #0
 800c4ba:	d1ea      	bne.n	800c492 <GetCA+0x4e>
    }
    wc_UnLockMutex(&cm->caLock);
 800c4bc:	697b      	ldr	r3, [r7, #20]
 800c4be:	335c      	adds	r3, #92	@ 0x5c
 800c4c0:	4618      	mov	r0, r3
 800c4c2:	f01b f920 	bl	8027706 <wc_UnLockMutex>

    return ret;
 800c4c6:	69fb      	ldr	r3, [r7, #28]
}
 800c4c8:	4618      	mov	r0, r3
 800c4ca:	3720      	adds	r7, #32
 800c4cc:	46bd      	mov	sp, r7
 800c4ce:	bd80      	pop	{r7, pc}

0800c4d0 <GetCAByAKID>:
}
#endif
#ifdef WOLFSSL_AKID_NAME
Signer* GetCAByAKID(void* vp, const byte* issuer, word32 issuerSz,
        const byte* serial, word32 serialSz)
{
 800c4d0:	b580      	push	{r7, lr}
 800c4d2:	b098      	sub	sp, #96	@ 0x60
 800c4d4:	af00      	add	r7, sp, #0
 800c4d6:	60f8      	str	r0, [r7, #12]
 800c4d8:	60b9      	str	r1, [r7, #8]
 800c4da:	607a      	str	r2, [r7, #4]
 800c4dc:	603b      	str	r3, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 800c4de:	68fb      	ldr	r3, [r7, #12]
 800c4e0:	653b      	str	r3, [r7, #80]	@ 0x50
    Signer* ret = NULL;
 800c4e2:	2300      	movs	r3, #0
 800c4e4:	65fb      	str	r3, [r7, #92]	@ 0x5c
    Signer* signers;
    byte nameHash[SIGNER_DIGEST_SIZE];
    byte serialHash[SIGNER_DIGEST_SIZE];
    word32 row;

    if (cm == NULL || issuer == NULL || issuerSz == 0 ||
 800c4e6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c4e8:	2b00      	cmp	r3, #0
 800c4ea:	d00b      	beq.n	800c504 <GetCAByAKID+0x34>
 800c4ec:	68bb      	ldr	r3, [r7, #8]
 800c4ee:	2b00      	cmp	r3, #0
 800c4f0:	d008      	beq.n	800c504 <GetCAByAKID+0x34>
 800c4f2:	687b      	ldr	r3, [r7, #4]
 800c4f4:	2b00      	cmp	r3, #0
 800c4f6:	d005      	beq.n	800c504 <GetCAByAKID+0x34>
 800c4f8:	683b      	ldr	r3, [r7, #0]
 800c4fa:	2b00      	cmp	r3, #0
 800c4fc:	d002      	beq.n	800c504 <GetCAByAKID+0x34>
            serial == NULL || serialSz == 0)
 800c4fe:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800c500:	2b00      	cmp	r3, #0
 800c502:	d101      	bne.n	800c508 <GetCAByAKID+0x38>
        return NULL;
 800c504:	2300      	movs	r3, #0
 800c506:	e057      	b.n	800c5b8 <GetCAByAKID+0xe8>

    if (CalcHashId(issuer, issuerSz, nameHash) != 0 ||
 800c508:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 800c50c:	461a      	mov	r2, r3
 800c50e:	6879      	ldr	r1, [r7, #4]
 800c510:	68b8      	ldr	r0, [r7, #8]
 800c512:	f009 f9ac 	bl	801586e <CalcHashId>
 800c516:	4603      	mov	r3, r0
 800c518:	2b00      	cmp	r3, #0
 800c51a:	d109      	bne.n	800c530 <GetCAByAKID+0x60>
            CalcHashId(serial, serialSz, serialHash) != 0)
 800c51c:	f107 0310 	add.w	r3, r7, #16
 800c520:	461a      	mov	r2, r3
 800c522:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 800c524:	6838      	ldr	r0, [r7, #0]
 800c526:	f009 f9a2 	bl	801586e <CalcHashId>
 800c52a:	4603      	mov	r3, r0
    if (CalcHashId(issuer, issuerSz, nameHash) != 0 ||
 800c52c:	2b00      	cmp	r3, #0
 800c52e:	d001      	beq.n	800c534 <GetCAByAKID+0x64>
        return NULL;
 800c530:	2300      	movs	r3, #0
 800c532:	e041      	b.n	800c5b8 <GetCAByAKID+0xe8>

    if (wc_LockMutex(&cm->caLock) != 0)
 800c534:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c536:	335c      	adds	r3, #92	@ 0x5c
 800c538:	4618      	mov	r0, r3
 800c53a:	f01b f8d9 	bl	80276f0 <wc_LockMutex>
 800c53e:	4603      	mov	r3, r0
 800c540:	2b00      	cmp	r3, #0
 800c542:	d001      	beq.n	800c548 <GetCAByAKID+0x78>
        return ret;
 800c544:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800c546:	e037      	b.n	800c5b8 <GetCAByAKID+0xe8>

    /* Unfortunately we need to look through the entire table */
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c548:	2300      	movs	r3, #0
 800c54a:	657b      	str	r3, [r7, #84]	@ 0x54
 800c54c:	e028      	b.n	800c5a0 <GetCAByAKID+0xd0>
        for (signers = cm->caTable[row]; signers != NULL;
 800c54e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c550:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800c552:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c556:	65bb      	str	r3, [r7, #88]	@ 0x58
 800c558:	e01c      	b.n	800c594 <GetCAByAKID+0xc4>
                signers = signers->next) {
            if (XMEMCMP(signers->subjectNameHash, nameHash, SIGNER_DIGEST_SIZE)
 800c55a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c55c:	3320      	adds	r3, #32
 800c55e:	f107 0130 	add.w	r1, r7, #48	@ 0x30
 800c562:	2220      	movs	r2, #32
 800c564:	4618      	mov	r0, r3
 800c566:	f01c fb33 	bl	8028bd0 <memcmp>
 800c56a:	4603      	mov	r3, r0
 800c56c:	2b00      	cmp	r3, #0
 800c56e:	d10d      	bne.n	800c58c <GetCAByAKID+0xbc>
                    == 0 && XMEMCMP(signers->serialHash, serialHash,
 800c570:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c572:	3360      	adds	r3, #96	@ 0x60
 800c574:	f107 0110 	add.w	r1, r7, #16
 800c578:	2220      	movs	r2, #32
 800c57a:	4618      	mov	r0, r3
 800c57c:	f01c fb28 	bl	8028bd0 <memcmp>
 800c580:	4603      	mov	r3, r0
 800c582:	2b00      	cmp	r3, #0
 800c584:	d102      	bne.n	800c58c <GetCAByAKID+0xbc>
                                    SIGNER_DIGEST_SIZE) == 0) {
                ret = signers;
 800c586:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c588:	65fb      	str	r3, [r7, #92]	@ 0x5c
                break;
 800c58a:	e006      	b.n	800c59a <GetCAByAKID+0xca>
                signers = signers->next) {
 800c58c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c58e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c592:	65bb      	str	r3, [r7, #88]	@ 0x58
        for (signers = cm->caTable[row]; signers != NULL;
 800c594:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c596:	2b00      	cmp	r3, #0
 800c598:	d1df      	bne.n	800c55a <GetCAByAKID+0x8a>
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c59a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800c59c:	3301      	adds	r3, #1
 800c59e:	657b      	str	r3, [r7, #84]	@ 0x54
 800c5a0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800c5a2:	2b0a      	cmp	r3, #10
 800c5a4:	d802      	bhi.n	800c5ac <GetCAByAKID+0xdc>
 800c5a6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800c5a8:	2b00      	cmp	r3, #0
 800c5aa:	d0d0      	beq.n	800c54e <GetCAByAKID+0x7e>
            }
        }
    }

    wc_UnLockMutex(&cm->caLock);
 800c5ac:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c5ae:	335c      	adds	r3, #92	@ 0x5c
 800c5b0:	4618      	mov	r0, r3
 800c5b2:	f01b f8a8 	bl	8027706 <wc_UnLockMutex>

    return ret;
 800c5b6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
}
 800c5b8:	4618      	mov	r0, r3
 800c5ba:	3760      	adds	r7, #96	@ 0x60
 800c5bc:	46bd      	mov	sp, r7
 800c5be:	bd80      	pop	{r7, pc}

0800c5c0 <GetCAByName>:
#endif

#ifndef NO_SKID
/* return CA if found, otherwise NULL. Walk through hash table. */
Signer* GetCAByName(void* vp, byte* hash)
{
 800c5c0:	b580      	push	{r7, lr}
 800c5c2:	b086      	sub	sp, #24
 800c5c4:	af00      	add	r7, sp, #0
 800c5c6:	6078      	str	r0, [r7, #4]
 800c5c8:	6039      	str	r1, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 800c5ca:	687b      	ldr	r3, [r7, #4]
 800c5cc:	60bb      	str	r3, [r7, #8]
    Signer* ret = NULL;
 800c5ce:	2300      	movs	r3, #0
 800c5d0:	617b      	str	r3, [r7, #20]
    Signer* signers;
    word32  row;

    if (cm == NULL)
 800c5d2:	68bb      	ldr	r3, [r7, #8]
 800c5d4:	2b00      	cmp	r3, #0
 800c5d6:	d101      	bne.n	800c5dc <GetCAByName+0x1c>
        return NULL;
 800c5d8:	2300      	movs	r3, #0
 800c5da:	e037      	b.n	800c64c <GetCAByName+0x8c>

    if (wc_LockMutex(&cm->caLock) != 0)
 800c5dc:	68bb      	ldr	r3, [r7, #8]
 800c5de:	335c      	adds	r3, #92	@ 0x5c
 800c5e0:	4618      	mov	r0, r3
 800c5e2:	f01b f885 	bl	80276f0 <wc_LockMutex>
 800c5e6:	4603      	mov	r3, r0
 800c5e8:	2b00      	cmp	r3, #0
 800c5ea:	d001      	beq.n	800c5f0 <GetCAByName+0x30>
        return ret;
 800c5ec:	697b      	ldr	r3, [r7, #20]
 800c5ee:	e02d      	b.n	800c64c <GetCAByName+0x8c>

    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c5f0:	2300      	movs	r3, #0
 800c5f2:	60fb      	str	r3, [r7, #12]
 800c5f4:	e01e      	b.n	800c634 <GetCAByName+0x74>
        signers = cm->caTable[row];
 800c5f6:	68bb      	ldr	r3, [r7, #8]
 800c5f8:	68fa      	ldr	r2, [r7, #12]
 800c5fa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c5fe:	613b      	str	r3, [r7, #16]
        while (signers && ret == NULL) {
 800c600:	e00f      	b.n	800c622 <GetCAByName+0x62>
            if (XMEMCMP(hash, signers->subjectNameHash,
 800c602:	693b      	ldr	r3, [r7, #16]
 800c604:	3320      	adds	r3, #32
 800c606:	2220      	movs	r2, #32
 800c608:	4619      	mov	r1, r3
 800c60a:	6838      	ldr	r0, [r7, #0]
 800c60c:	f01c fae0 	bl	8028bd0 <memcmp>
 800c610:	4603      	mov	r3, r0
 800c612:	2b00      	cmp	r3, #0
 800c614:	d101      	bne.n	800c61a <GetCAByName+0x5a>
                        SIGNER_DIGEST_SIZE) == 0) {
                ret = signers;
 800c616:	693b      	ldr	r3, [r7, #16]
 800c618:	617b      	str	r3, [r7, #20]
            }
            signers = signers->next;
 800c61a:	693b      	ldr	r3, [r7, #16]
 800c61c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c620:	613b      	str	r3, [r7, #16]
        while (signers && ret == NULL) {
 800c622:	693b      	ldr	r3, [r7, #16]
 800c624:	2b00      	cmp	r3, #0
 800c626:	d002      	beq.n	800c62e <GetCAByName+0x6e>
 800c628:	697b      	ldr	r3, [r7, #20]
 800c62a:	2b00      	cmp	r3, #0
 800c62c:	d0e9      	beq.n	800c602 <GetCAByName+0x42>
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c62e:	68fb      	ldr	r3, [r7, #12]
 800c630:	3301      	adds	r3, #1
 800c632:	60fb      	str	r3, [r7, #12]
 800c634:	68fb      	ldr	r3, [r7, #12]
 800c636:	2b0a      	cmp	r3, #10
 800c638:	d802      	bhi.n	800c640 <GetCAByName+0x80>
 800c63a:	697b      	ldr	r3, [r7, #20]
 800c63c:	2b00      	cmp	r3, #0
 800c63e:	d0da      	beq.n	800c5f6 <GetCAByName+0x36>
        }
    }
    wc_UnLockMutex(&cm->caLock);
 800c640:	68bb      	ldr	r3, [r7, #8]
 800c642:	335c      	adds	r3, #92	@ 0x5c
 800c644:	4618      	mov	r0, r3
 800c646:	f01b f85e 	bl	8027706 <wc_UnLockMutex>

    return ret;
 800c64a:	697b      	ldr	r3, [r7, #20]
}
 800c64c:	4618      	mov	r0, r3
 800c64e:	3718      	adds	r7, #24
 800c650:	46bd      	mov	sp, r7
 800c652:	bd80      	pop	{r7, pc}

0800c654 <AddCA>:

/* owns der, internal now uses too */
/* type flag ids from user or from chain received during verify
   don't allow chain ones to be added w/o isCA extension */
int AddCA(WOLFSSL_CERT_MANAGER* cm, DerBuffer** pDer, int type, int verify)
{
 800c654:	b580      	push	{r7, lr}
 800c656:	b08c      	sub	sp, #48	@ 0x30
 800c658:	af00      	add	r7, sp, #0
 800c65a:	60f8      	str	r0, [r7, #12]
 800c65c:	60b9      	str	r1, [r7, #8]
 800c65e:	607a      	str	r2, [r7, #4]
 800c660:	603b      	str	r3, [r7, #0]
    int         ret;
    Signer*     signer = NULL;
 800c662:	2300      	movs	r3, #0
 800c664:	62bb      	str	r3, [r7, #40]	@ 0x28
    word32      row;
    byte*       subjectHash;
#ifdef WOLFSSL_SMALL_STACK
    DecodedCert* cert = NULL;
 800c666:	2300      	movs	r3, #0
 800c668:	627b      	str	r3, [r7, #36]	@ 0x24
#else
    DecodedCert  cert[1];
#endif
    DerBuffer*   der = *pDer;
 800c66a:	68bb      	ldr	r3, [r7, #8]
 800c66c:	681b      	ldr	r3, [r3, #0]
 800c66e:	623b      	str	r3, [r7, #32]

    WOLFSSL_MSG("Adding a CA");

    if (cm == NULL) {
 800c670:	68fb      	ldr	r3, [r7, #12]
 800c672:	2b00      	cmp	r3, #0
 800c674:	d105      	bne.n	800c682 <AddCA+0x2e>
        FreeDer(pDer);
 800c676:	68b8      	ldr	r0, [r7, #8]
 800c678:	f00c fd38 	bl	80190ec <FreeDer>
        return BAD_FUNC_ARG;
 800c67c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800c680:	e110      	b.n	800c8a4 <AddCA+0x250>
    }

#ifdef WOLFSSL_SMALL_STACK
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), NULL,
 800c682:	f44f 6097 	mov.w	r0, #1208	@ 0x4b8
 800c686:	f012 faf9 	bl	801ec7c <wolfSSL_Malloc>
 800c68a:	6278      	str	r0, [r7, #36]	@ 0x24
                                 DYNAMIC_TYPE_DCERT);
    if (cert == NULL) {
 800c68c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c68e:	2b00      	cmp	r3, #0
 800c690:	d105      	bne.n	800c69e <AddCA+0x4a>
        FreeDer(pDer);
 800c692:	68b8      	ldr	r0, [r7, #8]
 800c694:	f00c fd2a 	bl	80190ec <FreeDer>
        return MEMORY_E;
 800c698:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800c69c:	e102      	b.n	800c8a4 <AddCA+0x250>
    }
#endif

    InitDecodedCert(cert, der->buffer, der->length, cm->heap);
 800c69e:	6a3b      	ldr	r3, [r7, #32]
 800c6a0:	6819      	ldr	r1, [r3, #0]
 800c6a2:	6a3b      	ldr	r3, [r7, #32]
 800c6a4:	689a      	ldr	r2, [r3, #8]
 800c6a6:	68fb      	ldr	r3, [r7, #12]
 800c6a8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c6aa:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800c6ac:	f008 fdd1 	bl	8015252 <InitDecodedCert>
    if (cm->unknownExtCallback != NULL) {
        wc_SetUnknownExtCallback(cert, cm->unknownExtCallback);
    }
#endif

    ret = ParseCert(cert, CA_TYPE, verify, cm);
 800c6b0:	68fb      	ldr	r3, [r7, #12]
 800c6b2:	683a      	ldr	r2, [r7, #0]
 800c6b4:	2106      	movs	r1, #6
 800c6b6:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800c6b8:	f00c f893 	bl	80187e2 <ParseCert>
 800c6bc:	62f8      	str	r0, [r7, #44]	@ 0x2c
    WOLFSSL_MSG("\tParsed new CA");

#ifndef NO_SKID
    subjectHash = cert->extSubjKeyId;
 800c6be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c6c0:	f503 7371 	add.w	r3, r3, #964	@ 0x3c4
 800c6c4:	61fb      	str	r3, [r7, #28]
#else
    subjectHash = cert->subjectHash;
#endif

    /* check CA key size */
    if (verify) {
 800c6c6:	683b      	ldr	r3, [r7, #0]
 800c6c8:	2b00      	cmp	r3, #0
 800c6ca:	d037      	beq.n	800c73c <AddCA+0xe8>
        switch (cert->keyOID) {
 800c6cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c6ce:	69db      	ldr	r3, [r3, #28]
 800c6d0:	f240 228e 	movw	r2, #654	@ 0x28e
 800c6d4:	4293      	cmp	r3, r2
 800c6d6:	d00b      	beq.n	800c6f0 <AddCA+0x9c>
 800c6d8:	f240 228e 	movw	r2, #654	@ 0x28e
 800c6dc:	4293      	cmp	r3, r2
 800c6de:	d828      	bhi.n	800c732 <AddCA+0xde>
 800c6e0:	f240 2206 	movw	r2, #518	@ 0x206
 800c6e4:	4293      	cmp	r3, r2
 800c6e6:	d014      	beq.n	800c712 <AddCA+0xbe>
 800c6e8:	f240 2285 	movw	r2, #645	@ 0x285
 800c6ec:	4293      	cmp	r3, r2
 800c6ee:	d120      	bne.n	800c732 <AddCA+0xde>
        #ifndef NO_RSA
            #ifdef WC_RSA_PSS
            case RSAPSSk:
            #endif
            case RSAk:
                if (cm->minRsaKeySz < 0 ||
 800c6f0:	68fb      	ldr	r3, [r7, #12]
 800c6f2:	f9b3 3062 	ldrsh.w	r3, [r3, #98]	@ 0x62
 800c6f6:	2b00      	cmp	r3, #0
 800c6f8:	db07      	blt.n	800c70a <AddCA+0xb6>
                                   cert->pubKeySize < (word16)cm->minRsaKeySz) {
 800c6fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c6fc:	685b      	ldr	r3, [r3, #4]
 800c6fe:	68fa      	ldr	r2, [r7, #12]
 800c700:	f9b2 2062 	ldrsh.w	r2, [r2, #98]	@ 0x62
 800c704:	b292      	uxth	r2, r2
                if (cm->minRsaKeySz < 0 ||
 800c706:	4293      	cmp	r3, r2
 800c708:	d215      	bcs.n	800c736 <AddCA+0xe2>
                    ret = RSA_KEY_SIZE_E;
 800c70a:	f46f 73cc 	mvn.w	r3, #408	@ 0x198
 800c70e:	62fb      	str	r3, [r7, #44]	@ 0x2c
                    WOLFSSL_MSG("\tCA RSA key size error");
                }
                break;
 800c710:	e011      	b.n	800c736 <AddCA+0xe2>
        #endif /* !NO_RSA */
            #ifdef HAVE_ECC
            case ECDSAk:
                if (cm->minEccKeySz < 0 ||
 800c712:	68fb      	ldr	r3, [r7, #12]
 800c714:	f9b3 3064 	ldrsh.w	r3, [r3, #100]	@ 0x64
 800c718:	2b00      	cmp	r3, #0
 800c71a:	db07      	blt.n	800c72c <AddCA+0xd8>
                                   cert->pubKeySize < (word16)cm->minEccKeySz) {
 800c71c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c71e:	685b      	ldr	r3, [r3, #4]
 800c720:	68fa      	ldr	r2, [r7, #12]
 800c722:	f9b2 2064 	ldrsh.w	r2, [r2, #100]	@ 0x64
 800c726:	b292      	uxth	r2, r2
                if (cm->minEccKeySz < 0 ||
 800c728:	4293      	cmp	r3, r2
 800c72a:	d206      	bcs.n	800c73a <AddCA+0xe6>
                    ret = ECC_KEY_SIZE_E;
 800c72c:	4b5f      	ldr	r3, [pc, #380]	@ (800c8ac <AddCA+0x258>)
 800c72e:	62fb      	str	r3, [r7, #44]	@ 0x2c
                    WOLFSSL_MSG("\tCA ECC key size error");
                }
                break;
 800c730:	e003      	b.n	800c73a <AddCA+0xe6>
                break;
            #endif /* HAVE_DILITHIUM */

            default:
                WOLFSSL_MSG("\tNo key size check done on CA");
                break; /* no size check if key type is not in switch */
 800c732:	bf00      	nop
 800c734:	e002      	b.n	800c73c <AddCA+0xe8>
                break;
 800c736:	bf00      	nop
 800c738:	e000      	b.n	800c73c <AddCA+0xe8>
                break;
 800c73a:	bf00      	nop
        }
    }

    if (ret == 0 && cert->isCA == 0 && type != WOLFSSL_USER_CA &&
 800c73c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c73e:	2b00      	cmp	r3, #0
 800c740:	d111      	bne.n	800c766 <AddCA+0x112>
 800c742:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c744:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800c748:	f003 0310 	and.w	r3, r3, #16
 800c74c:	b2db      	uxtb	r3, r3
 800c74e:	2b00      	cmp	r3, #0
 800c750:	d109      	bne.n	800c766 <AddCA+0x112>
 800c752:	687b      	ldr	r3, [r7, #4]
 800c754:	2b01      	cmp	r3, #1
 800c756:	d006      	beq.n	800c766 <AddCA+0x112>
 800c758:	687b      	ldr	r3, [r7, #4]
 800c75a:	2b03      	cmp	r3, #3
 800c75c:	d003      	beq.n	800c766 <AddCA+0x112>
        type != WOLFSSL_TEMP_CA) {
        WOLFSSL_MSG("\tCan't add as CA if not actually one");
        ret = NOT_CA_ERROR;
 800c75e:	f46f 73b2 	mvn.w	r3, #356	@ 0x164
 800c762:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800c764:	e03e      	b.n	800c7e4 <AddCA+0x190>
    }
#ifndef ALLOW_INVALID_CERTSIGN
    else if (ret == 0 && cert->isCA == 1 && type != WOLFSSL_USER_CA &&
 800c766:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c768:	2b00      	cmp	r3, #0
 800c76a:	d120      	bne.n	800c7ae <AddCA+0x15a>
 800c76c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c76e:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800c772:	f003 0310 	and.w	r3, r3, #16
 800c776:	b2db      	uxtb	r3, r3
 800c778:	2b00      	cmp	r3, #0
 800c77a:	d018      	beq.n	800c7ae <AddCA+0x15a>
 800c77c:	687b      	ldr	r3, [r7, #4]
 800c77e:	2b01      	cmp	r3, #1
 800c780:	d015      	beq.n	800c7ae <AddCA+0x15a>
 800c782:	687b      	ldr	r3, [r7, #4]
 800c784:	2b03      	cmp	r3, #3
 800c786:	d012      	beq.n	800c7ae <AddCA+0x15a>
        type != WOLFSSL_TEMP_CA && !cert->selfSigned &&
 800c788:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c78a:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800c78e:	f003 0302 	and.w	r3, r3, #2
 800c792:	b2db      	uxtb	r3, r3
 800c794:	2b00      	cmp	r3, #0
 800c796:	d10a      	bne.n	800c7ae <AddCA+0x15a>
        (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) == 0) {
 800c798:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c79a:	f8b3 3420 	ldrh.w	r3, [r3, #1056]	@ 0x420
 800c79e:	f003 0304 	and.w	r3, r3, #4
        type != WOLFSSL_TEMP_CA && !cert->selfSigned &&
 800c7a2:	2b00      	cmp	r3, #0
 800c7a4:	d103      	bne.n	800c7ae <AddCA+0x15a>
        /* Intermediate CA certs are required to have the keyCertSign
        * extension set. User loaded root certs are not. */
        WOLFSSL_MSG("\tDoesn't have key usage certificate signing");
        ret = NOT_CA_ERROR;
 800c7a6:	f46f 73b2 	mvn.w	r3, #356	@ 0x164
 800c7aa:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800c7ac:	e01a      	b.n	800c7e4 <AddCA+0x190>
    }
#endif
    else if (ret == 0 && AlreadySigner(cm, subjectHash)) {
 800c7ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c7b0:	2b00      	cmp	r3, #0
 800c7b2:	d106      	bne.n	800c7c2 <AddCA+0x16e>
 800c7b4:	69f9      	ldr	r1, [r7, #28]
 800c7b6:	68f8      	ldr	r0, [r7, #12]
 800c7b8:	f7ff fe02 	bl	800c3c0 <AlreadySigner>
 800c7bc:	4603      	mov	r3, r0
 800c7be:	2b00      	cmp	r3, #0
 800c7c0:	d10f      	bne.n	800c7e2 <AddCA+0x18e>
        WOLFSSL_MSG("\tAlready have this CA, not adding again");
        (void)ret;
    }
    else if (ret == 0) {
 800c7c2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c7c4:	2b00      	cmp	r3, #0
 800c7c6:	d10d      	bne.n	800c7e4 <AddCA+0x190>
        /* take over signer parts */
        signer = MakeSigner(cm->heap);
 800c7c8:	68fb      	ldr	r3, [r7, #12]
 800c7ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c7cc:	4618      	mov	r0, r3
 800c7ce:	f00c fb3b 	bl	8018e48 <MakeSigner>
 800c7d2:	62b8      	str	r0, [r7, #40]	@ 0x28
        if (!signer)
 800c7d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c7d6:	2b00      	cmp	r3, #0
 800c7d8:	d104      	bne.n	800c7e4 <AddCA+0x190>
            ret = MEMORY_ERROR;
 800c7da:	f46f 7397 	mvn.w	r3, #302	@ 0x12e
 800c7de:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800c7e0:	e000      	b.n	800c7e4 <AddCA+0x190>
        (void)ret;
 800c7e2:	bf00      	nop
    }
    if (ret == 0 && signer != NULL) {
 800c7e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c7e6:	2b00      	cmp	r3, #0
 800c7e8:	d13c      	bne.n	800c864 <AddCA+0x210>
 800c7ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c7ec:	2b00      	cmp	r3, #0
 800c7ee:	d039      	beq.n	800c864 <AddCA+0x210>
        ret = FillSigner(signer, cert, type, der);
 800c7f0:	6a3b      	ldr	r3, [r7, #32]
 800c7f2:	687a      	ldr	r2, [r7, #4]
 800c7f4:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800c7f6:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c7f8:	f00c fa83 	bl	8018d02 <FillSigner>
 800c7fc:	62f8      	str	r0, [r7, #44]	@ 0x2c

    #ifndef NO_SKID
        row = HashSigner(signer->subjectKeyIdHash);
 800c7fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c800:	3340      	adds	r3, #64	@ 0x40
 800c802:	4618      	mov	r0, r3
 800c804:	f7ff fdc2 	bl	800c38c <HashSigner>
 800c808:	61b8      	str	r0, [r7, #24]
                    WOLFSSL_MSG("Renesas_RootCertVerify() succeed or skipped");
            }
        }
    #endif /* TSIP or SCE */

        if (ret == 0 && wc_LockMutex(&cm->caLock) == 0) {
 800c80a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c80c:	2b00      	cmp	r3, #0
 800c80e:	d126      	bne.n	800c85e <AddCA+0x20a>
 800c810:	68fb      	ldr	r3, [r7, #12]
 800c812:	335c      	adds	r3, #92	@ 0x5c
 800c814:	4618      	mov	r0, r3
 800c816:	f01a ff6b 	bl	80276f0 <wc_LockMutex>
 800c81a:	4603      	mov	r3, r0
 800c81c:	2b00      	cmp	r3, #0
 800c81e:	d11e      	bne.n	800c85e <AddCA+0x20a>
            signer->next = cm->caTable[row];
 800c820:	68fb      	ldr	r3, [r7, #12]
 800c822:	69ba      	ldr	r2, [r7, #24]
 800c824:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c828:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c82a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
            cm->caTable[row] = signer;   /* takes ownership */
 800c82e:	68fb      	ldr	r3, [r7, #12]
 800c830:	69ba      	ldr	r2, [r7, #24]
 800c832:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800c834:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            wc_UnLockMutex(&cm->caLock);
 800c838:	68fb      	ldr	r3, [r7, #12]
 800c83a:	335c      	adds	r3, #92	@ 0x5c
 800c83c:	4618      	mov	r0, r3
 800c83e:	f01a ff62 	bl	8027706 <wc_UnLockMutex>
            if (cm->caCacheCallback)
 800c842:	68fb      	ldr	r3, [r7, #12]
 800c844:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800c846:	2b00      	cmp	r3, #0
 800c848:	d00c      	beq.n	800c864 <AddCA+0x210>
                cm->caCacheCallback(der->buffer, (int)der->length, type);
 800c84a:	68fb      	ldr	r3, [r7, #12]
 800c84c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800c84e:	6a3a      	ldr	r2, [r7, #32]
 800c850:	6810      	ldr	r0, [r2, #0]
 800c852:	6a3a      	ldr	r2, [r7, #32]
 800c854:	6892      	ldr	r2, [r2, #8]
 800c856:	4611      	mov	r1, r2
 800c858:	687a      	ldr	r2, [r7, #4]
 800c85a:	4798      	blx	r3
            if (cm->caCacheCallback)
 800c85c:	e002      	b.n	800c864 <AddCA+0x210>
        }
        else {
            WOLFSSL_MSG("\tCA Mutex Lock failed");
            ret = BAD_MUTEX_E;
 800c85e:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c862:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }
    }

    WOLFSSL_MSG("\tFreeing Parsed CA");
    FreeDecodedCert(cert);
 800c864:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800c866:	f008 fdcd 	bl	8015404 <FreeDecodedCert>
    if (ret != 0 && signer != NULL)
 800c86a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c86c:	2b00      	cmp	r3, #0
 800c86e:	d008      	beq.n	800c882 <AddCA+0x22e>
 800c870:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c872:	2b00      	cmp	r3, #0
 800c874:	d005      	beq.n	800c882 <AddCA+0x22e>
        FreeSigner(signer, cm->heap);
 800c876:	68fb      	ldr	r3, [r7, #12]
 800c878:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c87a:	4619      	mov	r1, r3
 800c87c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c87e:	f00c faf8 	bl	8018e72 <FreeSigner>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(cert, NULL, DYNAMIC_TYPE_DCERT);
 800c882:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c884:	617b      	str	r3, [r7, #20]
 800c886:	697b      	ldr	r3, [r7, #20]
 800c888:	2b00      	cmp	r3, #0
 800c88a:	d002      	beq.n	800c892 <AddCA+0x23e>
 800c88c:	6978      	ldr	r0, [r7, #20]
 800c88e:	f012 fa11 	bl	801ecb4 <wolfSSL_Free>
#endif
    WOLFSSL_MSG("\tFreeing der CA");
    FreeDer(pDer);
 800c892:	68b8      	ldr	r0, [r7, #8]
 800c894:	f00c fc2a 	bl	80190ec <FreeDer>
    WOLFSSL_MSG("\t\tOK Freeing der CA");

    WOLFSSL_LEAVE("AddCA", ret);

    return ret == 0 ? WOLFSSL_SUCCESS : ret;
 800c898:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c89a:	2b00      	cmp	r3, #0
 800c89c:	d001      	beq.n	800c8a2 <AddCA+0x24e>
 800c89e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c8a0:	e000      	b.n	800c8a4 <AddCA+0x250>
 800c8a2:	2301      	movs	r3, #1
}
 800c8a4:	4618      	mov	r0, r3
 800c8a6:	3730      	adds	r7, #48	@ 0x30
 800c8a8:	46bd      	mov	sp, r7
 800c8aa:	bd80      	pop	{r7, pc}
 800c8ac:	fffffe66 	.word	0xfffffe66

0800c8b0 <wolfSSL_Init>:
}
#endif

WOLFSSL_ABI
int wolfSSL_Init(void)
{
 800c8b0:	b580      	push	{r7, lr}
 800c8b2:	b082      	sub	sp, #8
 800c8b4:	af00      	add	r7, sp, #0
    int ret = WOLFSSL_SUCCESS;
 800c8b6:	2301      	movs	r3, #1
 800c8b8:	607b      	str	r3, [r7, #4]
#endif

    WOLFSSL_ENTER("wolfSSL_Init");

#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (inits_count_mutex_valid == 0) {
 800c8ba:	4b34      	ldr	r3, [pc, #208]	@ (800c98c <wolfSSL_Init+0xdc>)
 800c8bc:	681b      	ldr	r3, [r3, #0]
 800c8be:	2b00      	cmp	r3, #0
 800c8c0:	d10b      	bne.n	800c8da <wolfSSL_Init+0x2a>
            (void)wolfSSL_Atomic_Int_FetchSub(
                &inits_count_mutex_atomic_initing_flag, 1);
            return DEADLOCK_AVERTED_E;
        }
    #endif /* WOLFSSL_CLEANUP_THREADSAFE_BY_ATOMIC_OPS */
        if (wc_InitMutex(&inits_count_mutex) != 0) {
 800c8c2:	4833      	ldr	r0, [pc, #204]	@ (800c990 <wolfSSL_Init+0xe0>)
 800c8c4:	f01a fefe 	bl	80276c4 <wc_InitMutex>
 800c8c8:	4603      	mov	r3, r0
 800c8ca:	2b00      	cmp	r3, #0
 800c8cc:	d002      	beq.n	800c8d4 <wolfSSL_Init+0x24>
            WOLFSSL_MSG("Bad Init Mutex count");
    #if WOLFSSL_CLEANUP_THREADSAFE_BY_ATOMIC_OPS
            (void)wolfSSL_Atomic_Int_FetchSub(
                &inits_count_mutex_atomic_initing_flag, 1);
    #endif
            return BAD_MUTEX_E;
 800c8ce:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c8d2:	e057      	b.n	800c984 <wolfSSL_Init+0xd4>
        }
        else {
            inits_count_mutex_valid = 1;
 800c8d4:	4b2d      	ldr	r3, [pc, #180]	@ (800c98c <wolfSSL_Init+0xdc>)
 800c8d6:	2201      	movs	r2, #1
 800c8d8:	601a      	str	r2, [r3, #0]
        }
    }
#endif /* !WOLFSSL_MUTEX_INITIALIZER */

    if (wc_LockMutex(&inits_count_mutex) != 0) {
 800c8da:	482d      	ldr	r0, [pc, #180]	@ (800c990 <wolfSSL_Init+0xe0>)
 800c8dc:	f01a ff08 	bl	80276f0 <wc_LockMutex>
 800c8e0:	4603      	mov	r3, r0
 800c8e2:	2b00      	cmp	r3, #0
 800c8e4:	d002      	beq.n	800c8ec <wolfSSL_Init+0x3c>
        WOLFSSL_MSG("Bad Lock Mutex count");
        return BAD_MUTEX_E;
 800c8e6:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c8ea:	e04b      	b.n	800c984 <wolfSSL_Init+0xd4>
        if (ret == 0)
            ret = WOLFSSL_SUCCESS;
    }
#endif

    if ((ret == WOLFSSL_SUCCESS) && (initRefCount == 0)) {
 800c8ec:	687b      	ldr	r3, [r7, #4]
 800c8ee:	2b01      	cmp	r3, #1
 800c8f0:	d133      	bne.n	800c95a <wolfSSL_Init+0xaa>
 800c8f2:	4b28      	ldr	r3, [pc, #160]	@ (800c994 <wolfSSL_Init+0xe4>)
 800c8f4:	681b      	ldr	r3, [r3, #0]
 800c8f6:	2b00      	cmp	r3, #0
 800c8f8:	d12f      	bne.n	800c95a <wolfSSL_Init+0xaa>
        /* Initialize crypto for use with TLS connection */

        if (wolfCrypt_Init() != 0) {
 800c8fa:	f01a fe57 	bl	80275ac <wolfCrypt_Init>
 800c8fe:	4603      	mov	r3, r0
 800c900:	2b00      	cmp	r3, #0
 800c902:	d002      	beq.n	800c90a <wolfSSL_Init+0x5a>
            WOLFSSL_MSG("Bad wolfCrypt Init");
            ret = WC_INIT_E;
 800c904:	f06f 03e3 	mvn.w	r3, #227	@ 0xe3
 800c908:	607b      	str	r3, [r7, #4]
        }

#if defined(HAVE_GLOBAL_RNG) && !defined(WOLFSSL_MUTEX_INITIALIZER)
        if (ret == WOLFSSL_SUCCESS) {
 800c90a:	687b      	ldr	r3, [r7, #4]
 800c90c:	2b01      	cmp	r3, #1
 800c90e:	d10c      	bne.n	800c92a <wolfSSL_Init+0x7a>
            if (wc_InitMutex(&globalRNGMutex) != 0) {
 800c910:	4821      	ldr	r0, [pc, #132]	@ (800c998 <wolfSSL_Init+0xe8>)
 800c912:	f01a fed7 	bl	80276c4 <wc_InitMutex>
 800c916:	4603      	mov	r3, r0
 800c918:	2b00      	cmp	r3, #0
 800c91a:	d003      	beq.n	800c924 <wolfSSL_Init+0x74>
                WOLFSSL_MSG("Bad Init Mutex rng");
                ret = BAD_MUTEX_E;
 800c91c:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c920:	607b      	str	r3, [r7, #4]
 800c922:	e002      	b.n	800c92a <wolfSSL_Init+0x7a>
            }
            else {
                globalRNGMutex_valid = 1;
 800c924:	4b1d      	ldr	r3, [pc, #116]	@ (800c99c <wolfSSL_Init+0xec>)
 800c926:	2201      	movs	r2, #1
 800c928:	601a      	str	r2, [r3, #0]
        wc_SetSeed_Cb(wc_GenerateSeed);
    #endif

#ifdef OPENSSL_EXTRA
    #ifndef WOLFSSL_NO_OPENSSL_RAND_CB
        if ((ret == WOLFSSL_SUCCESS) && (wolfSSL_RAND_InitMutex() != 0)) {
 800c92a:	687b      	ldr	r3, [r7, #4]
 800c92c:	2b01      	cmp	r3, #1
 800c92e:	d107      	bne.n	800c940 <wolfSSL_Init+0x90>
 800c930:	f002 faf0 	bl	800ef14 <wolfSSL_RAND_InitMutex>
 800c934:	4603      	mov	r3, r0
 800c936:	2b00      	cmp	r3, #0
 800c938:	d002      	beq.n	800c940 <wolfSSL_Init+0x90>
            ret = BAD_MUTEX_E;
 800c93a:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c93e:	607b      	str	r3, [r7, #4]
        }
    #endif
        if ((ret == WOLFSSL_SUCCESS) &&
 800c940:	687b      	ldr	r3, [r7, #4]
 800c942:	2b01      	cmp	r3, #1
 800c944:	d109      	bne.n	800c95a <wolfSSL_Init+0xaa>
            (wolfSSL_RAND_seed(NULL, 0) != WOLFSSL_SUCCESS)) {
 800c946:	2100      	movs	r1, #0
 800c948:	2000      	movs	r0, #0
 800c94a:	f002 fb29 	bl	800efa0 <wolfSSL_RAND_seed>
 800c94e:	4603      	mov	r3, r0
        if ((ret == WOLFSSL_SUCCESS) &&
 800c950:	2b01      	cmp	r3, #1
 800c952:	d002      	beq.n	800c95a <wolfSSL_Init+0xaa>
            WOLFSSL_MSG("wolfSSL_RAND_seed failed");
            ret = WC_INIT_E;
 800c954:	f06f 03e3 	mvn.w	r3, #227	@ 0xe3
 800c958:	607b      	str	r3, [r7, #4]
#if defined(WOLFSSL_SYS_CRYPTO_POLICY)
    /* System wide crypto policy disabled by default. */
    XMEMSET(&crypto_policy, 0, sizeof(crypto_policy));
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

    if (ret == WOLFSSL_SUCCESS) {
 800c95a:	687b      	ldr	r3, [r7, #4]
 800c95c:	2b01      	cmp	r3, #1
 800c95e:	d105      	bne.n	800c96c <wolfSSL_Init+0xbc>
        initRefCount++;
 800c960:	4b0c      	ldr	r3, [pc, #48]	@ (800c994 <wolfSSL_Init+0xe4>)
 800c962:	681b      	ldr	r3, [r3, #0]
 800c964:	3301      	adds	r3, #1
 800c966:	4a0b      	ldr	r2, [pc, #44]	@ (800c994 <wolfSSL_Init+0xe4>)
 800c968:	6013      	str	r3, [r2, #0]
 800c96a:	e002      	b.n	800c972 <wolfSSL_Init+0xc2>
    }
    else {
        initRefCount = 1; /* Force cleanup */
 800c96c:	4b09      	ldr	r3, [pc, #36]	@ (800c994 <wolfSSL_Init+0xe4>)
 800c96e:	2201      	movs	r2, #1
 800c970:	601a      	str	r2, [r3, #0]
    }

    wc_UnLockMutex(&inits_count_mutex);
 800c972:	4807      	ldr	r0, [pc, #28]	@ (800c990 <wolfSSL_Init+0xe0>)
 800c974:	f01a fec7 	bl	8027706 <wc_UnLockMutex>

    if (ret != WOLFSSL_SUCCESS) {
 800c978:	687b      	ldr	r3, [r7, #4]
 800c97a:	2b01      	cmp	r3, #1
 800c97c:	d001      	beq.n	800c982 <wolfSSL_Init+0xd2>
        (void)wolfSSL_Cleanup(); /* Ignore any error from cleanup */
 800c97e:	f001 f8a9 	bl	800dad4 <wolfSSL_Cleanup>
    }

    return ret;
 800c982:	687b      	ldr	r3, [r7, #4]
}
 800c984:	4618      	mov	r0, r3
 800c986:	3708      	adds	r7, #8
 800c988:	46bd      	mov	sp, r7
 800c98a:	bd80      	pop	{r7, pc}
 800c98c:	20001c28 	.word	0x20001c28
 800c990:	20001c24 	.word	0x20001c24
 800c994:	20001c20 	.word	0x20001c20
 800c998:	20001c04 	.word	0x20001c04
 800c99c:	20001c08 	.word	0x20001c08

0800c9a0 <DataToDerBuffer>:
 * @return  ASN_PARSE_E when format is ASN.1 and invalid DER encoding.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int DataToDerBuffer(const unsigned char* buff, word32 len, int format,
    int type, EncryptedInfo* info, void* heap, DerBuffer** der, int* algId)
{
 800c9a0:	b580      	push	{r7, lr}
 800c9a2:	b08a      	sub	sp, #40	@ 0x28
 800c9a4:	af04      	add	r7, sp, #16
 800c9a6:	60f8      	str	r0, [r7, #12]
 800c9a8:	60b9      	str	r1, [r7, #8]
 800c9aa:	607a      	str	r2, [r7, #4]
 800c9ac:	603b      	str	r3, [r7, #0]
    int ret;

    info->consumed = 0;
 800c9ae:	6a3b      	ldr	r3, [r7, #32]
 800c9b0:	2200      	movs	r2, #0
 800c9b2:	601a      	str	r2, [r3, #0]

    /* Data in buffer has PEM format - extract DER data. */
    if (format == WOLFSSL_FILETYPE_PEM) {
 800c9b4:	687b      	ldr	r3, [r7, #4]
 800c9b6:	2b01      	cmp	r3, #1
 800c9b8:	d113      	bne.n	800c9e2 <DataToDerBuffer+0x42>
    #ifdef WOLFSSL_PEM_TO_DER
        ret = PemToDer(buff, len, type, der, heap, info, algId);
 800c9ba:	68b9      	ldr	r1, [r7, #8]
 800c9bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c9be:	9302      	str	r3, [sp, #8]
 800c9c0:	6a3b      	ldr	r3, [r7, #32]
 800c9c2:	9301      	str	r3, [sp, #4]
 800c9c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c9c6:	9300      	str	r3, [sp, #0]
 800c9c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c9ca:	683a      	ldr	r2, [r7, #0]
 800c9cc:	68f8      	ldr	r0, [r7, #12]
 800c9ce:	f00c fead 	bl	801972c <PemToDer>
 800c9d2:	6178      	str	r0, [r7, #20]
        if (ret != 0) {
 800c9d4:	697b      	ldr	r3, [r7, #20]
 800c9d6:	2b00      	cmp	r3, #0
 800c9d8:	d02b      	beq.n	800ca32 <DataToDerBuffer+0x92>
            FreeDer(der);
 800c9da:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c9dc:	f00c fb86 	bl	80190ec <FreeDer>
 800c9e0:	e027      	b.n	800ca32 <DataToDerBuffer+0x92>
    #endif
    }
    /* Data in buffer is ASN.1 format - get first SEQ or OCT into der. */
    else {
        /* Get length of SEQ including header. */
        if ((info->consumed = wolfssl_der_length(buff, (int)len)) > 0) {
 800c9e2:	68bb      	ldr	r3, [r7, #8]
 800c9e4:	4619      	mov	r1, r3
 800c9e6:	68f8      	ldr	r0, [r7, #12]
 800c9e8:	f7ff fa52 	bl	800be90 <wolfssl_der_length>
 800c9ec:	4602      	mov	r2, r0
 800c9ee:	6a3b      	ldr	r3, [r7, #32]
 800c9f0:	601a      	str	r2, [r3, #0]
 800c9f2:	6a3b      	ldr	r3, [r7, #32]
 800c9f4:	681b      	ldr	r3, [r3, #0]
 800c9f6:	2b00      	cmp	r3, #0
 800c9f8:	dd02      	ble.n	800ca00 <DataToDerBuffer+0x60>
            ret = 0;
 800c9fa:	2300      	movs	r3, #0
 800c9fc:	617b      	str	r3, [r7, #20]
 800c9fe:	e002      	b.n	800ca06 <DataToDerBuffer+0x66>
        }
        else {
            ret = ASN_PARSE_E;
 800ca00:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 800ca04:	617b      	str	r3, [r7, #20]
        }

        if (info->consumed > (int)len) {
 800ca06:	6a3b      	ldr	r3, [r7, #32]
 800ca08:	681a      	ldr	r2, [r3, #0]
 800ca0a:	68bb      	ldr	r3, [r7, #8]
 800ca0c:	429a      	cmp	r2, r3
 800ca0e:	dd02      	ble.n	800ca16 <DataToDerBuffer+0x76>
            ret = ASN_PARSE_E;
 800ca10:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 800ca14:	617b      	str	r3, [r7, #20]
        }
        if (ret == 0) {
 800ca16:	697b      	ldr	r3, [r7, #20]
 800ca18:	2b00      	cmp	r3, #0
 800ca1a:	d10a      	bne.n	800ca32 <DataToDerBuffer+0x92>
            ret = AllocCopyDer(der, buff, (word32)info->consumed, type, heap);
 800ca1c:	6a3b      	ldr	r3, [r7, #32]
 800ca1e:	681b      	ldr	r3, [r3, #0]
 800ca20:	461a      	mov	r2, r3
 800ca22:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ca24:	9300      	str	r3, [sp, #0]
 800ca26:	683b      	ldr	r3, [r7, #0]
 800ca28:	68f9      	ldr	r1, [r7, #12]
 800ca2a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800ca2c:	f00c fb40 	bl	80190b0 <AllocCopyDer>
 800ca30:	6178      	str	r0, [r7, #20]
        }
    }

    return ret;
 800ca32:	697b      	ldr	r3, [r7, #20]
}
 800ca34:	4618      	mov	r0, r3
 800ca36:	3718      	adds	r7, #24
 800ca38:	46bd      	mov	sp, r7
 800ca3a:	bd80      	pop	{r7, pc}

0800ca3c <ProcessUserCert>:
 * @return  0 on success.
 * @return  BUFFER_E if chain buffer not big enough to hold certificate.
 */
static int ProcessUserCert(WOLFSSL_CERT_MANAGER* cm, DerBuffer** pDer,
    int type, int verify, byte* chainBuffer, word32* pIdx, word32 bufferSz)
{
 800ca3c:	b580      	push	{r7, lr}
 800ca3e:	b088      	sub	sp, #32
 800ca40:	af00      	add	r7, sp, #0
 800ca42:	60f8      	str	r0, [r7, #12]
 800ca44:	60b9      	str	r1, [r7, #8]
 800ca46:	607a      	str	r2, [r7, #4]
 800ca48:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800ca4a:	2300      	movs	r3, #0
 800ca4c:	61fb      	str	r3, [r7, #28]
    word32 idx = *pIdx;
 800ca4e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ca50:	681b      	ldr	r3, [r3, #0]
 800ca52:	61bb      	str	r3, [r7, #24]
    DerBuffer* der = *pDer;
 800ca54:	68bb      	ldr	r3, [r7, #8]
 800ca56:	681b      	ldr	r3, [r3, #0]
 800ca58:	617b      	str	r3, [r7, #20]

    /* Check there is space for certificate in chainBuffer. */
    if ((ret == 0) && ((idx + der->length + CERT_HEADER_SZ) > bufferSz)) {
 800ca5a:	69fb      	ldr	r3, [r7, #28]
 800ca5c:	2b00      	cmp	r3, #0
 800ca5e:	d10a      	bne.n	800ca76 <ProcessUserCert+0x3a>
 800ca60:	697b      	ldr	r3, [r7, #20]
 800ca62:	689a      	ldr	r2, [r3, #8]
 800ca64:	69bb      	ldr	r3, [r7, #24]
 800ca66:	4413      	add	r3, r2
 800ca68:	3303      	adds	r3, #3
 800ca6a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800ca6c:	429a      	cmp	r2, r3
 800ca6e:	d202      	bcs.n	800ca76 <ProcessUserCert+0x3a>
        WOLFSSL_MSG("   Cert Chain bigger than buffer. "
                    "Consider increasing MAX_CHAIN_DEPTH");
        ret = BUFFER_E;
 800ca70:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 800ca74:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 800ca76:	69fb      	ldr	r3, [r7, #28]
 800ca78:	2b00      	cmp	r3, #0
 800ca7a:	d128      	bne.n	800cace <ProcessUserCert+0x92>
        /* 3-byte length. */
        c32to24(der->length, &chainBuffer[idx]);
 800ca7c:	697b      	ldr	r3, [r7, #20]
 800ca7e:	6898      	ldr	r0, [r3, #8]
 800ca80:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800ca82:	69bb      	ldr	r3, [r7, #24]
 800ca84:	4413      	add	r3, r2
 800ca86:	4619      	mov	r1, r3
 800ca88:	f7fe fc32 	bl	800b2f0 <c32to24>
        idx += CERT_HEADER_SZ;
 800ca8c:	69bb      	ldr	r3, [r7, #24]
 800ca8e:	3303      	adds	r3, #3
 800ca90:	61bb      	str	r3, [r7, #24]
        /* Add complete DER encoded certificate. */
        XMEMCPY(&chainBuffer[idx], der->buffer, der->length);
 800ca92:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800ca94:	69bb      	ldr	r3, [r7, #24]
 800ca96:	18d0      	adds	r0, r2, r3
 800ca98:	697b      	ldr	r3, [r7, #20]
 800ca9a:	6819      	ldr	r1, [r3, #0]
 800ca9c:	697b      	ldr	r3, [r7, #20]
 800ca9e:	689b      	ldr	r3, [r3, #8]
 800caa0:	461a      	mov	r2, r3
 800caa2:	f01c f970 	bl	8028d86 <memcpy>
        idx += der->length;
 800caa6:	697b      	ldr	r3, [r7, #20]
 800caa8:	689b      	ldr	r3, [r3, #8]
 800caaa:	69ba      	ldr	r2, [r7, #24]
 800caac:	4413      	add	r3, r2
 800caae:	61bb      	str	r3, [r7, #24]

        if (type == CA_TYPE) {
 800cab0:	687b      	ldr	r3, [r7, #4]
 800cab2:	2b06      	cmp	r3, #6
 800cab4:	d10b      	bne.n	800cace <ProcessUserCert+0x92>
            /* Add CA to certificate manager */
            ret = AddCA(cm, pDer, WOLFSSL_USER_CA, verify);
 800cab6:	683b      	ldr	r3, [r7, #0]
 800cab8:	2201      	movs	r2, #1
 800caba:	68b9      	ldr	r1, [r7, #8]
 800cabc:	68f8      	ldr	r0, [r7, #12]
 800cabe:	f7ff fdc9 	bl	800c654 <AddCA>
 800cac2:	61f8      	str	r0, [r7, #28]
            if (ret == 1) {
 800cac4:	69fb      	ldr	r3, [r7, #28]
 800cac6:	2b01      	cmp	r3, #1
 800cac8:	d101      	bne.n	800cace <ProcessUserCert+0x92>
                ret = 0;
 800caca:	2300      	movs	r3, #0
 800cacc:	61fb      	str	r3, [r7, #28]
            }
        }
    }

    /* Update the index into chainBuffer. */
    *pIdx = idx;
 800cace:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cad0:	69ba      	ldr	r2, [r7, #24]
 800cad2:	601a      	str	r2, [r3, #0]
    return ret;
 800cad4:	69fb      	ldr	r3, [r7, #28]
}
 800cad6:	4618      	mov	r0, r3
 800cad8:	3720      	adds	r7, #32
 800cada:	46bd      	mov	sp, r7
 800cadc:	bd80      	pop	{r7, pc}

0800cade <ProcessUserChainRetain>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int ProcessUserChainRetain(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const byte* chainBuffer, word32 len, int cnt, int type, void* heap)
{
 800cade:	b580      	push	{r7, lr}
 800cae0:	b088      	sub	sp, #32
 800cae2:	af02      	add	r7, sp, #8
 800cae4:	60f8      	str	r0, [r7, #12]
 800cae6:	60b9      	str	r1, [r7, #8]
 800cae8:	607a      	str	r2, [r7, #4]
 800caea:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800caec:	2300      	movs	r3, #0
 800caee:	617b      	str	r3, [r7, #20]

    (void)cnt;

    /* Store in SSL object if available. */
    if (ssl != NULL) {
 800caf0:	68bb      	ldr	r3, [r7, #8]
 800caf2:	2b00      	cmp	r3, #0
 800caf4:	d024      	beq.n	800cb40 <ProcessUserChainRetain+0x62>
        /* Dispose of old chain if not reference to context's. */
        if (ssl->buffers.weOwnCertChain) {
 800caf6:	68bb      	ldr	r3, [r7, #8]
 800caf8:	f893 3145 	ldrb.w	r3, [r3, #325]	@ 0x145
 800cafc:	2b00      	cmp	r3, #0
 800cafe:	d005      	beq.n	800cb0c <ProcessUserChainRetain+0x2e>
            FreeDer(&ssl->buffers.certChain);
 800cb00:	68bb      	ldr	r3, [r7, #8]
 800cb02:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 800cb06:	4618      	mov	r0, r3
 800cb08:	f00c faf0 	bl	80190ec <FreeDer>
        }
        /* Allocate and copy the buffer into SSL object. */
        ret = AllocCopyDer(&ssl->buffers.certChain, chainBuffer, len, type,
 800cb0c:	68bb      	ldr	r3, [r7, #8]
 800cb0e:	f503 70c0 	add.w	r0, r3, #384	@ 0x180
 800cb12:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cb14:	9300      	str	r3, [sp, #0]
 800cb16:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cb18:	683a      	ldr	r2, [r7, #0]
 800cb1a:	6879      	ldr	r1, [r7, #4]
 800cb1c:	f00c fac8 	bl	80190b0 <AllocCopyDer>
 800cb20:	6178      	str	r0, [r7, #20]
            heap);
        ssl->buffers.weOwnCertChain = (ret == 0);
 800cb22:	697b      	ldr	r3, [r7, #20]
 800cb24:	2b00      	cmp	r3, #0
 800cb26:	bf0c      	ite	eq
 800cb28:	2301      	moveq	r3, #1
 800cb2a:	2300      	movne	r3, #0
 800cb2c:	b2db      	uxtb	r3, r3
 800cb2e:	461a      	mov	r2, r3
 800cb30:	68bb      	ldr	r3, [r7, #8]
 800cb32:	f883 2145 	strb.w	r2, [r3, #325]	@ 0x145
    #ifdef WOLFSSL_TLS13
        /* Update count of certificates in chain. */
        ssl->buffers.certChainCnt = cnt;
 800cb36:	68bb      	ldr	r3, [r7, #8]
 800cb38:	6a3a      	ldr	r2, [r7, #32]
 800cb3a:	f8c3 2184 	str.w	r2, [r3, #388]	@ 0x184
 800cb3e:	e015      	b.n	800cb6c <ProcessUserChainRetain+0x8e>
    #endif
    }
    /* Store in SSL context object if available. */
    else if (ctx != NULL) {
 800cb40:	68fb      	ldr	r3, [r7, #12]
 800cb42:	2b00      	cmp	r3, #0
 800cb44:	d012      	beq.n	800cb6c <ProcessUserChainRetain+0x8e>
        /* Dispose of old chain and allocate and copy in new chain. */
        FreeDer(&ctx->certChain);
 800cb46:	68fb      	ldr	r3, [r7, #12]
 800cb48:	3324      	adds	r3, #36	@ 0x24
 800cb4a:	4618      	mov	r0, r3
 800cb4c:	f00c face 	bl	80190ec <FreeDer>
        /* Allocate and copy the buffer into SSL context object. */
        ret = AllocCopyDer(&ctx->certChain, chainBuffer, len, type, heap);
 800cb50:	68fb      	ldr	r3, [r7, #12]
 800cb52:	f103 0024 	add.w	r0, r3, #36	@ 0x24
 800cb56:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cb58:	9300      	str	r3, [sp, #0]
 800cb5a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cb5c:	683a      	ldr	r2, [r7, #0]
 800cb5e:	6879      	ldr	r1, [r7, #4]
 800cb60:	f00c faa6 	bl	80190b0 <AllocCopyDer>
 800cb64:	6178      	str	r0, [r7, #20]
    #ifdef WOLFSSL_TLS13
        /* Update count of certificates in chain. */
        ctx->certChainCnt = cnt;
 800cb66:	68fb      	ldr	r3, [r7, #12]
 800cb68:	6a3a      	ldr	r2, [r7, #32]
 800cb6a:	63da      	str	r2, [r3, #60]	@ 0x3c
    #endif
    }

    return ret;
 800cb6c:	697b      	ldr	r3, [r7, #20]
}
 800cb6e:	4618      	mov	r0, r3
 800cb70:	3718      	adds	r7, #24
 800cb72:	46bd      	mov	sp, r7
 800cb74:	bd80      	pop	{r7, pc}

0800cb76 <ProcessUserChain>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int ProcessUserChain(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const unsigned char* buff, long sz, int format, int type, long* used,
    EncryptedInfo* info, int verify)
{
 800cb76:	b580      	push	{r7, lr}
 800cb78:	b092      	sub	sp, #72	@ 0x48
 800cb7a:	af04      	add	r7, sp, #16
 800cb7c:	60f8      	str	r0, [r7, #12]
 800cb7e:	60b9      	str	r1, [r7, #8]
 800cb80:	607a      	str	r2, [r7, #4]
 800cb82:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800cb84:	2300      	movs	r3, #0
 800cb86:	637b      	str	r3, [r7, #52]	@ 0x34
    void* heap = WOLFSSL_HEAP(ctx, ssl);
 800cb88:	68fb      	ldr	r3, [r7, #12]
 800cb8a:	2b00      	cmp	r3, #0
 800cb8c:	d002      	beq.n	800cb94 <ProcessUserChain+0x1e>
 800cb8e:	68fb      	ldr	r3, [r7, #12]
 800cb90:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800cb92:	e007      	b.n	800cba4 <ProcessUserChain+0x2e>
 800cb94:	68bb      	ldr	r3, [r7, #8]
 800cb96:	2b00      	cmp	r3, #0
 800cb98:	d003      	beq.n	800cba2 <ProcessUserChain+0x2c>
 800cb9a:	68bb      	ldr	r3, [r7, #8]
 800cb9c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800cba0:	e000      	b.n	800cba4 <ProcessUserChain+0x2e>
 800cba2:	2300      	movs	r3, #0
 800cba4:	627b      	str	r3, [r7, #36]	@ 0x24

    WOLFSSL_ENTER("ProcessUserChain");

    /* Check we haven't consumed all the data. */
    if (info->consumed >= sz) {
 800cba6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800cba8:	681b      	ldr	r3, [r3, #0]
 800cbaa:	683a      	ldr	r2, [r7, #0]
 800cbac:	429a      	cmp	r2, r3
 800cbae:	f340 8092 	ble.w	800ccd6 <ProcessUserChain+0x160>
    else {
    #ifndef WOLFSSL_SMALL_STACK
        byte stackBuffer[FILE_BUFFER_SIZE];
    #endif
        StaticBuffer chain;
        long   consumed = info->consumed;
 800cbb2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800cbb4:	681b      	ldr	r3, [r3, #0]
 800cbb6:	633b      	str	r3, [r7, #48]	@ 0x30
        word32 idx = 0;
 800cbb8:	2300      	movs	r3, #0
 800cbba:	617b      	str	r3, [r7, #20]
        int    gotOne = 0;
 800cbbc:	2300      	movs	r3, #0
 800cbbe:	62fb      	str	r3, [r7, #44]	@ 0x2c
        int    cnt = 0;
 800cbc0:	2300      	movs	r3, #0
 800cbc2:	62bb      	str	r3, [r7, #40]	@ 0x28
        /* Calculate max possible size, including max headers */
        long   maxSz = (sz - consumed) + (CERT_HEADER_SZ * MAX_CHAIN_DEPTH);
 800cbc4:	683a      	ldr	r2, [r7, #0]
 800cbc6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800cbc8:	1ad3      	subs	r3, r2, r3
 800cbca:	331b      	adds	r3, #27
 800cbcc:	623b      	str	r3, [r7, #32]

        /* Setup buffer to hold chain. */
    #ifdef WOLFSSL_SMALL_STACK
        static_buffer_init(&chain);
 800cbce:	f107 0318 	add.w	r3, r7, #24
 800cbd2:	4618      	mov	r0, r3
 800cbd4:	f7fe fbc2 	bl	800b35c <static_buffer_init>
    #else
        static_buffer_init(&chain, stackBuffer, FILE_BUFFER_SIZE);
    #endif
        /* Make buffer big enough to support maximum size. */
        ret = static_buffer_set_size(&chain, (word32)maxSz, heap,
 800cbd8:	6a39      	ldr	r1, [r7, #32]
 800cbda:	f107 0018 	add.w	r0, r7, #24
 800cbde:	2304      	movs	r3, #4
 800cbe0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800cbe2:	f7fe fbcb 	bl	800b37c <static_buffer_set_size>
 800cbe6:	6378      	str	r0, [r7, #52]	@ 0x34
            DYNAMIC_TYPE_FILE);

        WOLFSSL_MSG("Processing Cert Chain");
        /* Keep parsing certificates will data available. */
        while ((ret == 0) && (consumed < sz)) {
 800cbe8:	e04d      	b.n	800cc86 <ProcessUserChain+0x110>
            DerBuffer* part = NULL;
 800cbea:	2300      	movs	r3, #0
 800cbec:	613b      	str	r3, [r7, #16]

            /* Get a certificate as DER. */
            ret = DataToDerBuffer(buff + consumed, (word32)(sz - consumed),
 800cbee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800cbf0:	687a      	ldr	r2, [r7, #4]
 800cbf2:	18d0      	adds	r0, r2, r3
 800cbf4:	683a      	ldr	r2, [r7, #0]
 800cbf6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800cbf8:	1ad3      	subs	r3, r2, r3
 800cbfa:	4619      	mov	r1, r3
 800cbfc:	2300      	movs	r3, #0
 800cbfe:	9303      	str	r3, [sp, #12]
 800cc00:	f107 0310 	add.w	r3, r7, #16
 800cc04:	9302      	str	r3, [sp, #8]
 800cc06:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cc08:	9301      	str	r3, [sp, #4]
 800cc0a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800cc0c:	9300      	str	r3, [sp, #0]
 800cc0e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800cc10:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800cc12:	f7ff fec5 	bl	800c9a0 <DataToDerBuffer>
 800cc16:	6378      	str	r0, [r7, #52]	@ 0x34
                format, type, info, heap, &part, NULL);
            if (ret == 0) {
 800cc18:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cc1a:	2b00      	cmp	r3, #0
 800cc1c:	d10f      	bne.n	800cc3e <ProcessUserChain+0xc8>
                /* Process the user certificate. */
                ret = ProcessUserCert(ctx->cm, &part, type, verify,
 800cc1e:	68fb      	ldr	r3, [r7, #12]
 800cc20:	6d18      	ldr	r0, [r3, #80]	@ 0x50
 800cc22:	69bb      	ldr	r3, [r7, #24]
 800cc24:	6a3a      	ldr	r2, [r7, #32]
 800cc26:	f107 0110 	add.w	r1, r7, #16
 800cc2a:	9202      	str	r2, [sp, #8]
 800cc2c:	f107 0214 	add.w	r2, r7, #20
 800cc30:	9201      	str	r2, [sp, #4]
 800cc32:	9300      	str	r3, [sp, #0]
 800cc34:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800cc36:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800cc38:	f7ff ff00 	bl	800ca3c <ProcessUserCert>
 800cc3c:	6378      	str	r0, [r7, #52]	@ 0x34
                   chain.buffer, &idx, (word32)maxSz);
            }
            /* PEM may have trailing data that can be ignored. */
            if ((ret == WC_NO_ERR_TRACE(ASN_NO_PEM_HEADER)) && gotOne) {
 800cc3e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cc40:	f113 0fa2 	cmn.w	r3, #162	@ 0xa2
 800cc44:	d105      	bne.n	800cc52 <ProcessUserChain+0xdc>
 800cc46:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cc48:	2b00      	cmp	r3, #0
 800cc4a:	d002      	beq.n	800cc52 <ProcessUserChain+0xdc>
                WOLFSSL_MSG("We got one good cert, so stuff at end ok");
                ret = 0;
 800cc4c:	2300      	movs	r3, #0
 800cc4e:	637b      	str	r3, [r7, #52]	@ 0x34
 800cc50:	e020      	b.n	800cc94 <ProcessUserChain+0x11e>
                break;
            }
            /* Certificate data handled. */
            FreeDer(&part);
 800cc52:	f107 0310 	add.w	r3, r7, #16
 800cc56:	4618      	mov	r0, r3
 800cc58:	f00c fa48 	bl	80190ec <FreeDer>

            if (ret == 0) {
 800cc5c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cc5e:	2b00      	cmp	r3, #0
 800cc60:	d111      	bne.n	800cc86 <ProcessUserChain+0x110>
                /* Update consumed length. */
                consumed += info->consumed;
 800cc62:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800cc64:	681b      	ldr	r3, [r3, #0]
 800cc66:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800cc68:	4413      	add	r3, r2
 800cc6a:	633b      	str	r3, [r7, #48]	@ 0x30
                WOLFSSL_MSG("   Consumed another Cert in Chain");
                /* Update whether we got a user certificate. */
                gotOne |= (type != CA_TYPE);
 800cc6c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800cc6e:	2b06      	cmp	r3, #6
 800cc70:	bf14      	ite	ne
 800cc72:	2301      	movne	r3, #1
 800cc74:	2300      	moveq	r3, #0
 800cc76:	b2db      	uxtb	r3, r3
 800cc78:	461a      	mov	r2, r3
 800cc7a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cc7c:	4313      	orrs	r3, r2
 800cc7e:	62fb      	str	r3, [r7, #44]	@ 0x2c
                /* Update count of certificates added to chain. */
                cnt++;
 800cc80:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cc82:	3301      	adds	r3, #1
 800cc84:	62bb      	str	r3, [r7, #40]	@ 0x28
        while ((ret == 0) && (consumed < sz)) {
 800cc86:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cc88:	2b00      	cmp	r3, #0
 800cc8a:	d103      	bne.n	800cc94 <ProcessUserChain+0x11e>
 800cc8c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800cc8e:	683b      	ldr	r3, [r7, #0]
 800cc90:	429a      	cmp	r2, r3
 800cc92:	dbaa      	blt.n	800cbea <ProcessUserChain+0x74>
            }
        }
        if (used != NULL) {
 800cc94:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800cc96:	2b00      	cmp	r3, #0
 800cc98:	d002      	beq.n	800cca0 <ProcessUserChain+0x12a>
            /* Return the total consumed length. */
            *used = consumed;
 800cc9a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800cc9c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800cc9e:	601a      	str	r2, [r3, #0]
        }

        /* Check whether there is data in the chain buffer. */
        if ((ret == 0) && (idx > 0)) {
 800cca0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cca2:	2b00      	cmp	r3, #0
 800cca4:	d110      	bne.n	800ccc8 <ProcessUserChain+0x152>
 800cca6:	697b      	ldr	r3, [r7, #20]
 800cca8:	2b00      	cmp	r3, #0
 800ccaa:	d00d      	beq.n	800ccc8 <ProcessUserChain+0x152>
            /* Put the chain buffer against the SSL or SSL context object. */
            ret = ProcessUserChainRetain(ctx, ssl, chain.buffer, idx, cnt, type,
 800ccac:	69ba      	ldr	r2, [r7, #24]
 800ccae:	6979      	ldr	r1, [r7, #20]
 800ccb0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ccb2:	9302      	str	r3, [sp, #8]
 800ccb4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800ccb6:	9301      	str	r3, [sp, #4]
 800ccb8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ccba:	9300      	str	r3, [sp, #0]
 800ccbc:	460b      	mov	r3, r1
 800ccbe:	68b9      	ldr	r1, [r7, #8]
 800ccc0:	68f8      	ldr	r0, [r7, #12]
 800ccc2:	f7ff ff0c 	bl	800cade <ProcessUserChainRetain>
 800ccc6:	6378      	str	r0, [r7, #52]	@ 0x34
                heap);
        }

        /* Dispose of chain buffer. */
        static_buffer_free(&chain, heap, DYNAMIC_TYPE_FILE);
 800ccc8:	f107 0318 	add.w	r3, r7, #24
 800cccc:	2204      	movs	r2, #4
 800ccce:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800ccd0:	4618      	mov	r0, r3
 800ccd2:	f7fe fb72 	bl	800b3ba <static_buffer_free>
    }

    WOLFSSL_LEAVE("ProcessUserChain", ret);
    return ret;
 800ccd6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 800ccd8:	4618      	mov	r0, r3
 800ccda:	3738      	adds	r7, #56	@ 0x38
 800ccdc:	46bd      	mov	sp, r7
 800ccde:	bd80      	pop	{r7, pc}

0800cce0 <ProcessBufferTryDecodeRsa>:
 * @return  0 on success or not an RSA key and format unknown.
 * @return  RSA_KEY_SIZE_E when key size doesn't meet minimum required.
 */
static int ProcessBufferTryDecodeRsa(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int* keyFormat, int devId, byte* keyType, int* keySize)
{
 800cce0:	b580      	push	{r7, lr}
 800cce2:	b088      	sub	sp, #32
 800cce4:	af00      	add	r7, sp, #0
 800cce6:	60f8      	str	r0, [r7, #12]
 800cce8:	60b9      	str	r1, [r7, #8]
 800ccea:	607a      	str	r2, [r7, #4]
 800ccec:	603b      	str	r3, [r7, #0]
    int ret;
    word32 idx;
    int keySz = 0;
 800ccee:	2300      	movs	r3, #0
 800ccf0:	613b      	str	r3, [r7, #16]

    (void)devId;

    /* Validate we have an RSA private key and get key size. */
    idx = 0;
 800ccf2:	2300      	movs	r3, #0
 800ccf4:	617b      	str	r3, [r7, #20]
    ret = wc_RsaPrivateKeyValidate(der->buffer, &idx, &keySz, der->length);
 800ccf6:	687b      	ldr	r3, [r7, #4]
 800ccf8:	6818      	ldr	r0, [r3, #0]
 800ccfa:	687b      	ldr	r3, [r7, #4]
 800ccfc:	689b      	ldr	r3, [r3, #8]
 800ccfe:	f107 0210 	add.w	r2, r7, #16
 800cd02:	f107 0114 	add.w	r1, r7, #20
 800cd06:	f008 f84f 	bl	8014da8 <wc_RsaPrivateKeyValidate>
 800cd0a:	61f8      	str	r0, [r7, #28]
        if (ret == 0) {
            keySz = (int)nSz;
        }
    }
#endif
    if (ret == 0) {
 800cd0c:	69fb      	ldr	r3, [r7, #28]
 800cd0e:	2b00      	cmp	r3, #0
 800cd10:	d12e      	bne.n	800cd70 <ProcessBufferTryDecodeRsa+0x90>
        /* Get the minimum RSA key size from SSL or SSL context object. */
        int minRsaSz = ssl ? ssl->options.minRsaKeySz : ctx->minRsaKeySz;
 800cd12:	68bb      	ldr	r3, [r7, #8]
 800cd14:	2b00      	cmp	r3, #0
 800cd16:	d003      	beq.n	800cd20 <ProcessBufferTryDecodeRsa+0x40>
 800cd18:	68bb      	ldr	r3, [r7, #8]
 800cd1a:	f9b3 32f4 	ldrsh.w	r3, [r3, #756]	@ 0x2f4
 800cd1e:	e002      	b.n	800cd26 <ProcessBufferTryDecodeRsa+0x46>
 800cd20:	68fb      	ldr	r3, [r7, #12]
 800cd22:	f9b3 3066 	ldrsh.w	r3, [r3, #102]	@ 0x66
 800cd26:	61bb      	str	r3, [r7, #24]

        /* Format, type and size are known. */
        *keyFormat = RSAk;
 800cd28:	683b      	ldr	r3, [r7, #0]
 800cd2a:	f240 2285 	movw	r2, #645	@ 0x285
 800cd2e:	601a      	str	r2, [r3, #0]
        *keyType = rsa_sa_algo;
 800cd30:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cd32:	2201      	movs	r2, #1
 800cd34:	701a      	strb	r2, [r3, #0]
        *keySize = keySz;
 800cd36:	693a      	ldr	r2, [r7, #16]
 800cd38:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800cd3a:	601a      	str	r2, [r3, #0]

        /* Check that the size of the RSA key is enough. */
        if (keySz < minRsaSz) {
 800cd3c:	693b      	ldr	r3, [r7, #16]
 800cd3e:	69ba      	ldr	r2, [r7, #24]
 800cd40:	429a      	cmp	r2, r3
 800cd42:	dd02      	ble.n	800cd4a <ProcessBufferTryDecodeRsa+0x6a>
            WOLFSSL_MSG("Private Key size too small");
            ret = RSA_KEY_SIZE_E;
 800cd44:	f46f 73cc 	mvn.w	r3, #408	@ 0x198
 800cd48:	61fb      	str	r3, [r7, #28]
        }
         /* No static ECC key possible. */
        if ((ssl != NULL) && (ssl->options.side == WOLFSSL_SERVER_END)) {
 800cd4a:	68bb      	ldr	r3, [r7, #8]
 800cd4c:	2b00      	cmp	r3, #0
 800cd4e:	d015      	beq.n	800cd7c <ProcessBufferTryDecodeRsa+0x9c>
 800cd50:	68bb      	ldr	r3, [r7, #8]
 800cd52:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800cd56:	f003 0303 	and.w	r3, r3, #3
 800cd5a:	b2db      	uxtb	r3, r3
 800cd5c:	2b00      	cmp	r3, #0
 800cd5e:	d10d      	bne.n	800cd7c <ProcessBufferTryDecodeRsa+0x9c>
             ssl->options.haveStaticECC = 0;
 800cd60:	68ba      	ldr	r2, [r7, #8]
 800cd62:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800cd66:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800cd6a:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
 800cd6e:	e005      	b.n	800cd7c <ProcessBufferTryDecodeRsa+0x9c>
        }
    }
    /* Not an RSA key but check whether we know what it is. */
    else if (*keyFormat == 0) {
 800cd70:	683b      	ldr	r3, [r7, #0]
 800cd72:	681b      	ldr	r3, [r3, #0]
 800cd74:	2b00      	cmp	r3, #0
 800cd76:	d101      	bne.n	800cd7c <ProcessBufferTryDecodeRsa+0x9c>
        WOLFSSL_MSG("Not an RSA key");
        /* Format unknown so keep trying. */
        ret = 0;
 800cd78:	2300      	movs	r3, #0
 800cd7a:	61fb      	str	r3, [r7, #28]
    }

    return ret;
 800cd7c:	69fb      	ldr	r3, [r7, #28]
}
 800cd7e:	4618      	mov	r0, r3
 800cd80:	3720      	adds	r7, #32
 800cd82:	46bd      	mov	sp, r7
 800cd84:	bd80      	pop	{r7, pc}
	...

0800cd88 <ProcessBufferTryDecodeEcc>:
 * @return  ECC_KEY_SIZE_E when ECC key size doesn't meet minimum required.
 */
static int ProcessBufferTryDecodeEcc(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int* keyFormat, void* heap, int devId, byte* keyType,
    int* keySize)
{
 800cd88:	b580      	push	{r7, lr}
 800cd8a:	b08a      	sub	sp, #40	@ 0x28
 800cd8c:	af00      	add	r7, sp, #0
 800cd8e:	60f8      	str	r0, [r7, #12]
 800cd90:	60b9      	str	r1, [r7, #8]
 800cd92:	607a      	str	r2, [r7, #4]
 800cd94:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800cd96:	2300      	movs	r3, #0
 800cd98:	627b      	str	r3, [r7, #36]	@ 0x24
    ecc_key  key[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    /* Allocate an ECC key to parse into. */
    key = (ecc_key*)XMALLOC(sizeof(ecc_key), heap, DYNAMIC_TYPE_ECC);
 800cd9a:	f44f 70b8 	mov.w	r0, #368	@ 0x170
 800cd9e:	f011 ff6d 	bl	801ec7c <wolfSSL_Malloc>
 800cda2:	6238      	str	r0, [r7, #32]
    if (key == NULL)
 800cda4:	6a3b      	ldr	r3, [r7, #32]
 800cda6:	2b00      	cmp	r3, #0
 800cda8:	d102      	bne.n	800cdb0 <ProcessBufferTryDecodeEcc+0x28>
        return MEMORY_E;
 800cdaa:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800cdae:	e05a      	b.n	800ce66 <ProcessBufferTryDecodeEcc+0xde>
#endif

    /* Initialize ECC key. */
    if (wc_ecc_init_ex(key, heap, devId) == 0) {
 800cdb0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800cdb2:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 800cdb4:	6a38      	ldr	r0, [r7, #32]
 800cdb6:	f010 f8cd 	bl	801cf54 <wc_ecc_init_ex>
 800cdba:	4603      	mov	r3, r0
 800cdbc:	2b00      	cmp	r3, #0
 800cdbe:	d149      	bne.n	800ce54 <ProcessBufferTryDecodeEcc+0xcc>
        /* Decode as an ECC private key. */
        idx = 0;
 800cdc0:	2300      	movs	r3, #0
 800cdc2:	613b      	str	r3, [r7, #16]
        ret = wc_EccPrivateKeyDecode(der->buffer, &idx, key, der->length);
 800cdc4:	687b      	ldr	r3, [r7, #4]
 800cdc6:	6818      	ldr	r0, [r3, #0]
 800cdc8:	687b      	ldr	r3, [r7, #4]
 800cdca:	689b      	ldr	r3, [r3, #8]
 800cdcc:	f107 0110 	add.w	r1, r7, #16
 800cdd0:	6a3a      	ldr	r2, [r7, #32]
 800cdd2:	f00d f8b5 	bl	8019f40 <wc_EccPrivateKeyDecode>
 800cdd6:	6278      	str	r0, [r7, #36]	@ 0x24
        if (*keyFormat == SM2k) {
            ret = wc_ecc_set_curve(key, WOLFSSL_SM2_KEY_BITS / 8,
                ECC_SM2P256V1);
        }
    #endif
        if (ret == 0) {
 800cdd8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cdda:	2b00      	cmp	r3, #0
 800cddc:	d131      	bne.n	800ce42 <ProcessBufferTryDecodeEcc+0xba>
            /* Get the minimum ECC key size from SSL or SSL context object. */
            int minKeySz = ssl ? ssl->options.minEccKeySz : ctx->minEccKeySz;
 800cdde:	68bb      	ldr	r3, [r7, #8]
 800cde0:	2b00      	cmp	r3, #0
 800cde2:	d003      	beq.n	800cdec <ProcessBufferTryDecodeEcc+0x64>
 800cde4:	68bb      	ldr	r3, [r7, #8]
 800cde6:	f9b3 32f6 	ldrsh.w	r3, [r3, #758]	@ 0x2f6
 800cdea:	e002      	b.n	800cdf2 <ProcessBufferTryDecodeEcc+0x6a>
 800cdec:	68fb      	ldr	r3, [r7, #12]
 800cdee:	f9b3 3068 	ldrsh.w	r3, [r3, #104]	@ 0x68
 800cdf2:	61fb      	str	r3, [r7, #28]
            int keySz = wc_ecc_size(key);
 800cdf4:	6a38      	ldr	r0, [r7, #32]
 800cdf6:	f011 fac7 	bl	801e388 <wc_ecc_size>
 800cdfa:	61b8      	str	r0, [r7, #24]

            /* Format is known. */
            *keyFormat = ECDSAk;
 800cdfc:	683b      	ldr	r3, [r7, #0]
 800cdfe:	f240 2206 	movw	r2, #518	@ 0x206
 800ce02:	601a      	str	r2, [r3, #0]
                *keyType = sm2_sa_algo;
            }
            else
        #endif
            {
                *keyType = ecc_dsa_sa_algo;
 800ce04:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800ce06:	2203      	movs	r2, #3
 800ce08:	701a      	strb	r2, [r3, #0]
            }
            *keySize = keySz;
 800ce0a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ce0c:	69ba      	ldr	r2, [r7, #24]
 800ce0e:	601a      	str	r2, [r3, #0]

            /* Check that the size of the ECC key is enough. */
            if (keySz < minKeySz) {
 800ce10:	69ba      	ldr	r2, [r7, #24]
 800ce12:	69fb      	ldr	r3, [r7, #28]
 800ce14:	429a      	cmp	r2, r3
 800ce16:	da01      	bge.n	800ce1c <ProcessBufferTryDecodeEcc+0x94>
                WOLFSSL_MSG("ECC private key too small");
                ret = ECC_KEY_SIZE_E;
 800ce18:	4b15      	ldr	r3, [pc, #84]	@ (800ce70 <ProcessBufferTryDecodeEcc+0xe8>)
 800ce1a:	627b      	str	r3, [r7, #36]	@ 0x24
            }
            /* Static ECC key possible. */
            if (ssl) {
 800ce1c:	68bb      	ldr	r3, [r7, #8]
 800ce1e:	2b00      	cmp	r3, #0
 800ce20:	d007      	beq.n	800ce32 <ProcessBufferTryDecodeEcc+0xaa>
                ssl->options.haveStaticECC = 1;
 800ce22:	68ba      	ldr	r2, [r7, #8]
 800ce24:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800ce28:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800ce2c:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
 800ce30:	e00d      	b.n	800ce4e <ProcessBufferTryDecodeEcc+0xc6>
            }
            else {
                ctx->haveStaticECC = 1;
 800ce32:	68fa      	ldr	r2, [r7, #12]
 800ce34:	f892 305f 	ldrb.w	r3, [r2, #95]	@ 0x5f
 800ce38:	f043 0301 	orr.w	r3, r3, #1
 800ce3c:	f882 305f 	strb.w	r3, [r2, #95]	@ 0x5f
 800ce40:	e005      	b.n	800ce4e <ProcessBufferTryDecodeEcc+0xc6>
            }
        }
        /* Not an ECC key but check whether we know what it is. */
        else if (*keyFormat == 0) {
 800ce42:	683b      	ldr	r3, [r7, #0]
 800ce44:	681b      	ldr	r3, [r3, #0]
 800ce46:	2b00      	cmp	r3, #0
 800ce48:	d101      	bne.n	800ce4e <ProcessBufferTryDecodeEcc+0xc6>
            WOLFSSL_MSG("Not an ECC key");
            /* Format unknown so keep trying. */
            ret = 0;
 800ce4a:	2300      	movs	r3, #0
 800ce4c:	627b      	str	r3, [r7, #36]	@ 0x24
        }

        /* Free dynamically allocated data in key. */
        wc_ecc_free(key);
 800ce4e:	6a38      	ldr	r0, [r7, #32]
 800ce50:	f010 f91b 	bl	801d08a <wc_ecc_free>
    }

#ifdef WOLFSSL_SMALL_STACK
    /* Dispose of allocated key. */
    XFREE(key, heap, DYNAMIC_TYPE_ECC);
 800ce54:	6a3b      	ldr	r3, [r7, #32]
 800ce56:	617b      	str	r3, [r7, #20]
 800ce58:	697b      	ldr	r3, [r7, #20]
 800ce5a:	2b00      	cmp	r3, #0
 800ce5c:	d002      	beq.n	800ce64 <ProcessBufferTryDecodeEcc+0xdc>
 800ce5e:	6978      	ldr	r0, [r7, #20]
 800ce60:	f011 ff28 	bl	801ecb4 <wolfSSL_Free>
#endif
    return ret;
 800ce64:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800ce66:	4618      	mov	r0, r3
 800ce68:	3728      	adds	r7, #40	@ 0x28
 800ce6a:	46bd      	mov	sp, r7
 800ce6c:	bd80      	pop	{r7, pc}
 800ce6e:	bf00      	nop
 800ce70:	fffffe66 	.word	0xfffffe66

0800ce74 <ProcessBufferTryDecode>:
 * @return  BAD_FUNC_ARG when ctx and ssl are NULL.
 * @return  WOLFSSL_BAD_FILE when unable to identify the key format.
 */
static int ProcessBufferTryDecode(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int* keyFormat, void* heap, int type)
{
 800ce74:	b580      	push	{r7, lr}
 800ce76:	b08c      	sub	sp, #48	@ 0x30
 800ce78:	af04      	add	r7, sp, #16
 800ce7a:	60f8      	str	r0, [r7, #12]
 800ce7c:	60b9      	str	r1, [r7, #8]
 800ce7e:	607a      	str	r2, [r7, #4]
 800ce80:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800ce82:	2300      	movs	r3, #0
 800ce84:	61fb      	str	r3, [r7, #28]
    int devId = wolfSSL_CTX_GetDevId(ctx, ssl);
 800ce86:	68b9      	ldr	r1, [r7, #8]
 800ce88:	68f8      	ldr	r0, [r7, #12]
 800ce8a:	f7ff fa48 	bl	800c31e <wolfSSL_CTX_GetDevId>
 800ce8e:	6138      	str	r0, [r7, #16]
    byte* keyType = NULL;
 800ce90:	2300      	movs	r3, #0
 800ce92:	61bb      	str	r3, [r7, #24]
    int* keySz = NULL;
 800ce94:	2300      	movs	r3, #0
 800ce96:	617b      	str	r3, [r7, #20]
    (void)heap;
    (void)devId;
    (void)type;

    /* Validate parameters. */
    if ((der == NULL) || (keyFormat == NULL)) {
 800ce98:	687b      	ldr	r3, [r7, #4]
 800ce9a:	2b00      	cmp	r3, #0
 800ce9c:	d002      	beq.n	800cea4 <ProcessBufferTryDecode+0x30>
 800ce9e:	683b      	ldr	r3, [r7, #0]
 800cea0:	2b00      	cmp	r3, #0
 800cea2:	d102      	bne.n	800ceaa <ProcessBufferTryDecode+0x36>
        ret = BAD_FUNC_ARG;
 800cea4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800cea8:	61fb      	str	r3, [r7, #28]
    }
    /* Must have an SSL context or SSL object to use. */
    if ((ret == 0) && (ctx == NULL) && (ssl == NULL)) {
 800ceaa:	69fb      	ldr	r3, [r7, #28]
 800ceac:	2b00      	cmp	r3, #0
 800ceae:	d108      	bne.n	800cec2 <ProcessBufferTryDecode+0x4e>
 800ceb0:	68fb      	ldr	r3, [r7, #12]
 800ceb2:	2b00      	cmp	r3, #0
 800ceb4:	d105      	bne.n	800cec2 <ProcessBufferTryDecode+0x4e>
 800ceb6:	68bb      	ldr	r3, [r7, #8]
 800ceb8:	2b00      	cmp	r3, #0
 800ceba:	d102      	bne.n	800cec2 <ProcessBufferTryDecode+0x4e>
        ret = BAD_FUNC_ARG;
 800cebc:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800cec0:	61fb      	str	r3, [r7, #28]
    }

    if (ret == 0) {
 800cec2:	69fb      	ldr	r3, [r7, #28]
 800cec4:	2b00      	cmp	r3, #0
 800cec6:	d111      	bne.n	800ceec <ProcessBufferTryDecode+0x78>
            }
        }
        else
    #endif
        /* Type is PRIVATEKEY_TYPE. */
        if (ssl != NULL) {
 800cec8:	68bb      	ldr	r3, [r7, #8]
 800ceca:	2b00      	cmp	r3, #0
 800cecc:	d008      	beq.n	800cee0 <ProcessBufferTryDecode+0x6c>
            keyType = &ssl->buffers.keyType;
 800cece:	68bb      	ldr	r3, [r7, #8]
 800ced0:	f503 73ba 	add.w	r3, r3, #372	@ 0x174
 800ced4:	61bb      	str	r3, [r7, #24]
            keySz = &ssl->buffers.keySz;
 800ced6:	68bb      	ldr	r3, [r7, #8]
 800ced8:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 800cedc:	617b      	str	r3, [r7, #20]
 800cede:	e005      	b.n	800ceec <ProcessBufferTryDecode+0x78>
        }
        else {
            keyType = &ctx->privateKeyType;
 800cee0:	68fb      	ldr	r3, [r7, #12]
 800cee2:	3344      	adds	r3, #68	@ 0x44
 800cee4:	61bb      	str	r3, [r7, #24]
            keySz = &ctx->privateKeySz;
 800cee6:	68fb      	ldr	r3, [r7, #12]
 800cee8:	3348      	adds	r3, #72	@ 0x48
 800ceea:	617b      	str	r3, [r7, #20]
        }
    }

#ifndef NO_RSA
    /* Try RSA if key format is RSA or yet unknown. */
    if ((ret == 0) && ((*keyFormat == 0) || (*keyFormat == RSAk))) {
 800ceec:	69fb      	ldr	r3, [r7, #28]
 800ceee:	2b00      	cmp	r3, #0
 800cef0:	d116      	bne.n	800cf20 <ProcessBufferTryDecode+0xac>
 800cef2:	683b      	ldr	r3, [r7, #0]
 800cef4:	681b      	ldr	r3, [r3, #0]
 800cef6:	2b00      	cmp	r3, #0
 800cef8:	d005      	beq.n	800cf06 <ProcessBufferTryDecode+0x92>
 800cefa:	683b      	ldr	r3, [r7, #0]
 800cefc:	681b      	ldr	r3, [r3, #0]
 800cefe:	f240 2285 	movw	r2, #645	@ 0x285
 800cf02:	4293      	cmp	r3, r2
 800cf04:	d10c      	bne.n	800cf20 <ProcessBufferTryDecode+0xac>
#if !defined(HAVE_FIPS) || (defined(HAVE_FIPS_VERSION) && \
    (HAVE_FIPS_VERSION > 2))
        ret = ProcessBufferTryDecodeRsa(ctx, ssl, der, keyFormat, devId,
 800cf06:	697b      	ldr	r3, [r7, #20]
 800cf08:	9302      	str	r3, [sp, #8]
 800cf0a:	69bb      	ldr	r3, [r7, #24]
 800cf0c:	9301      	str	r3, [sp, #4]
 800cf0e:	693b      	ldr	r3, [r7, #16]
 800cf10:	9300      	str	r3, [sp, #0]
 800cf12:	683b      	ldr	r3, [r7, #0]
 800cf14:	687a      	ldr	r2, [r7, #4]
 800cf16:	68b9      	ldr	r1, [r7, #8]
 800cf18:	68f8      	ldr	r0, [r7, #12]
 800cf1a:	f7ff fee1 	bl	800cce0 <ProcessBufferTryDecodeRsa>
 800cf1e:	61f8      	str	r0, [r7, #28]
#endif
    }
#endif
#ifdef HAVE_ECC
    /* Try ECC if key format is ECDSA or SM2, or yet unknown. */
    if ((ret == 0) && ((*keyFormat == 0) || (*keyFormat == ECDSAk)
 800cf20:	69fb      	ldr	r3, [r7, #28]
 800cf22:	2b00      	cmp	r3, #0
 800cf24:	d118      	bne.n	800cf58 <ProcessBufferTryDecode+0xe4>
 800cf26:	683b      	ldr	r3, [r7, #0]
 800cf28:	681b      	ldr	r3, [r3, #0]
 800cf2a:	2b00      	cmp	r3, #0
 800cf2c:	d005      	beq.n	800cf3a <ProcessBufferTryDecode+0xc6>
 800cf2e:	683b      	ldr	r3, [r7, #0]
 800cf30:	681b      	ldr	r3, [r3, #0]
 800cf32:	f240 2206 	movw	r2, #518	@ 0x206
 800cf36:	4293      	cmp	r3, r2
 800cf38:	d10e      	bne.n	800cf58 <ProcessBufferTryDecode+0xe4>
    #ifdef WOLFSSL_SM2
        || (*keyFormat == SM2k)
    #endif
        )) {
        ret = ProcessBufferTryDecodeEcc(ctx, ssl, der, keyFormat, heap, devId,
 800cf3a:	697b      	ldr	r3, [r7, #20]
 800cf3c:	9303      	str	r3, [sp, #12]
 800cf3e:	69bb      	ldr	r3, [r7, #24]
 800cf40:	9302      	str	r3, [sp, #8]
 800cf42:	693b      	ldr	r3, [r7, #16]
 800cf44:	9301      	str	r3, [sp, #4]
 800cf46:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cf48:	9300      	str	r3, [sp, #0]
 800cf4a:	683b      	ldr	r3, [r7, #0]
 800cf4c:	687a      	ldr	r2, [r7, #4]
 800cf4e:	68b9      	ldr	r1, [r7, #8]
 800cf50:	68f8      	ldr	r0, [r7, #12]
 800cf52:	f7ff ff19 	bl	800cd88 <ProcessBufferTryDecodeEcc>
 800cf56:	61f8      	str	r0, [r7, #28]
            keyType, keySz);
    }
#endif /* HAVE_DILITHIUM */

    /* Check we know the format. */
    if ((ret == 0) && (*keyFormat == 0)) {
 800cf58:	69fb      	ldr	r3, [r7, #28]
 800cf5a:	2b00      	cmp	r3, #0
 800cf5c:	d106      	bne.n	800cf6c <ProcessBufferTryDecode+0xf8>
 800cf5e:	683b      	ldr	r3, [r7, #0]
 800cf60:	681b      	ldr	r3, [r3, #0]
 800cf62:	2b00      	cmp	r3, #0
 800cf64:	d102      	bne.n	800cf6c <ProcessBufferTryDecode+0xf8>
        WOLFSSL_MSG("Not a supported key type");
        /* Not supported key format. */
        ret = WOLFSSL_BAD_FILE;
 800cf66:	f46f 73e7 	mvn.w	r3, #462	@ 0x1ce
 800cf6a:	61fb      	str	r3, [r7, #28]
    }

    return ret;
 800cf6c:	69fb      	ldr	r3, [r7, #28]
}
 800cf6e:	4618      	mov	r0, r3
 800cf70:	3720      	adds	r7, #32
 800cf72:	46bd      	mov	sp, r7
 800cf74:	bd80      	pop	{r7, pc}

0800cf76 <ProcessBufferPrivKeyHandleDer>:
 * @param [in]      der  DER encoding.
 * @return  0 on success.
 */
static int ProcessBufferPrivKeyHandleDer(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer** der, int type)
{
 800cf76:	b580      	push	{r7, lr}
 800cf78:	b086      	sub	sp, #24
 800cf7a:	af00      	add	r7, sp, #0
 800cf7c:	60f8      	str	r0, [r7, #12]
 800cf7e:	60b9      	str	r1, [r7, #8]
 800cf80:	607a      	str	r2, [r7, #4]
 800cf82:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800cf84:	2300      	movs	r3, #0
 800cf86:	617b      	str	r3, [r7, #20]
        #endif
        }
    }
    else
#endif /* WOLFSSL_DUAL_ALG_CERTS */
    if (ssl != NULL) {
 800cf88:	68bb      	ldr	r3, [r7, #8]
 800cf8a:	2b00      	cmp	r3, #0
 800cf8c:	d027      	beq.n	800cfde <ProcessBufferPrivKeyHandleDer+0x68>
        /* Dispose of previous key if not context's. */
        if (ssl->buffers.weOwnKey) {
 800cf8e:	68bb      	ldr	r3, [r7, #8]
 800cf90:	f893 3146 	ldrb.w	r3, [r3, #326]	@ 0x146
 800cf94:	2b00      	cmp	r3, #0
 800cf96:	d005      	beq.n	800cfa4 <ProcessBufferPrivKeyHandleDer+0x2e>
            FreeDer(&ssl->buffers.key);
 800cf98:	68bb      	ldr	r3, [r7, #8]
 800cf9a:	f503 73b8 	add.w	r3, r3, #368	@ 0x170
 800cf9e:	4618      	mov	r0, r3
 800cfa0:	f00c f8a4 	bl	80190ec <FreeDer>
        #ifdef WOLFSSL_BLIND_PRIVATE_KEY
            FreeDer(&ssl->buffers.keyMask);
        #endif
        }
        ssl->buffers.keyId = 0;
 800cfa4:	68ba      	ldr	r2, [r7, #8]
 800cfa6:	f892 3175 	ldrb.w	r3, [r2, #373]	@ 0x175
 800cfaa:	f023 0301 	bic.w	r3, r3, #1
 800cfae:	f882 3175 	strb.w	r3, [r2, #373]	@ 0x175
        ssl->buffers.keyLabel = 0;
 800cfb2:	68ba      	ldr	r2, [r7, #8]
 800cfb4:	f892 3175 	ldrb.w	r3, [r2, #373]	@ 0x175
 800cfb8:	f023 0302 	bic.w	r3, r3, #2
 800cfbc:	f882 3175 	strb.w	r3, [r2, #373]	@ 0x175
        ssl->buffers.keyDevId = INVALID_DEVID;
 800cfc0:	68bb      	ldr	r3, [r7, #8]
 800cfc2:	f06f 0201 	mvn.w	r2, #1
 800cfc6:	f8c3 217c 	str.w	r2, [r3, #380]	@ 0x17c
        /* Store key by reference and own it. */
        ssl->buffers.key = *der;
 800cfca:	687b      	ldr	r3, [r7, #4]
 800cfcc:	681a      	ldr	r2, [r3, #0]
 800cfce:	68bb      	ldr	r3, [r7, #8]
 800cfd0:	f8c3 2170 	str.w	r2, [r3, #368]	@ 0x170
    #ifdef WOLFSSL_CHECK_MEM_ZERO
        wc_MemZero_Add("SSL Buffers key", (*der)->buffer, (*der)->length);
    #endif
        ssl->buffers.weOwnKey = 1;
 800cfd4:	68bb      	ldr	r3, [r7, #8]
 800cfd6:	2201      	movs	r2, #1
 800cfd8:	f883 2146 	strb.w	r2, [r3, #326]	@ 0x146
 800cfdc:	e01d      	b.n	800d01a <ProcessBufferPrivKeyHandleDer+0xa4>
    }
    else if (ctx != NULL) {
 800cfde:	68fb      	ldr	r3, [r7, #12]
 800cfe0:	2b00      	cmp	r3, #0
 800cfe2:	d01a      	beq.n	800d01a <ProcessBufferPrivKeyHandleDer+0xa4>
        /* Dispose of previous key. */
        FreeDer(&ctx->privateKey);
 800cfe4:	68fb      	ldr	r3, [r7, #12]
 800cfe6:	3340      	adds	r3, #64	@ 0x40
 800cfe8:	4618      	mov	r0, r3
 800cfea:	f00c f87f 	bl	80190ec <FreeDer>
        ctx->privateKeyId = 0;
 800cfee:	68fa      	ldr	r2, [r7, #12]
 800cff0:	f892 3045 	ldrb.w	r3, [r2, #69]	@ 0x45
 800cff4:	f023 0301 	bic.w	r3, r3, #1
 800cff8:	f882 3045 	strb.w	r3, [r2, #69]	@ 0x45
        ctx->privateKeyLabel = 0;
 800cffc:	68fa      	ldr	r2, [r7, #12]
 800cffe:	f892 3045 	ldrb.w	r3, [r2, #69]	@ 0x45
 800d002:	f023 0302 	bic.w	r3, r3, #2
 800d006:	f882 3045 	strb.w	r3, [r2, #69]	@ 0x45
        ctx->privateKeyDevId = INVALID_DEVID;
 800d00a:	68fb      	ldr	r3, [r7, #12]
 800d00c:	f06f 0201 	mvn.w	r2, #1
 800d010:	64da      	str	r2, [r3, #76]	@ 0x4c
        /* Store key by reference. */
        ctx->privateKey = *der;
 800d012:	687b      	ldr	r3, [r7, #4]
 800d014:	681a      	ldr	r2, [r3, #0]
 800d016:	68fb      	ldr	r3, [r7, #12]
 800d018:	641a      	str	r2, [r3, #64]	@ 0x40
    #ifdef WOLFSSL_CHECK_MEM_ZERO
        wc_MemZero_Add("CTX private key", (*der)->buffer, (*der)->length);
    #endif
    }

    return ret;
 800d01a:	697b      	ldr	r3, [r7, #20]
}
 800d01c:	4618      	mov	r0, r3
 800d01e:	3718      	adds	r7, #24
 800d020:	46bd      	mov	sp, r7
 800d022:	bd80      	pop	{r7, pc}

0800d024 <ProcessBufferPrivateKey>:
 * @return  WOLFSSL_BAD_FILE when not able to decode.
 */
static int ProcessBufferPrivateKey(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int format, EncryptedInfo* info, void* heap, int type,
    int algId)
{
 800d024:	b580      	push	{r7, lr}
 800d026:	b088      	sub	sp, #32
 800d028:	af02      	add	r7, sp, #8
 800d02a:	60f8      	str	r0, [r7, #12]
 800d02c:	60b9      	str	r1, [r7, #8]
 800d02e:	607a      	str	r2, [r7, #4]
 800d030:	603b      	str	r3, [r7, #0]

    (void)info;
    (void)format;

    /* Put the data into the SSL or SSL context object. */
    ret = ProcessBufferPrivKeyHandleDer(ctx, ssl, &der, type);
 800d032:	1d3a      	adds	r2, r7, #4
 800d034:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d036:	68b9      	ldr	r1, [r7, #8]
 800d038:	68f8      	ldr	r0, [r7, #12]
 800d03a:	f7ff ff9c 	bl	800cf76 <ProcessBufferPrivKeyHandleDer>
 800d03e:	6178      	str	r0, [r7, #20]
    if (ret == 0) {
 800d040:	697b      	ldr	r3, [r7, #20]
 800d042:	2b00      	cmp	r3, #0
 800d044:	d10c      	bne.n	800d060 <ProcessBufferPrivateKey+0x3c>
        /* Try to decode the DER data. */
        ret = ProcessBufferTryDecode(ctx, ssl, der, &algId, heap, type);
 800d046:	687a      	ldr	r2, [r7, #4]
 800d048:	f107 012c 	add.w	r1, r7, #44	@ 0x2c
 800d04c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d04e:	9301      	str	r3, [sp, #4]
 800d050:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d052:	9300      	str	r3, [sp, #0]
 800d054:	460b      	mov	r3, r1
 800d056:	68b9      	ldr	r1, [r7, #8]
 800d058:	68f8      	ldr	r0, [r7, #12]
 800d05a:	f7ff ff0b 	bl	800ce74 <ProcessBufferTryDecode>
 800d05e:	6178      	str	r0, [r7, #20]
            &ctx->privateKeyMask);
    }
#endif

    /* Check if we were able to determine algorithm id. */
    if ((ret == 0) && (algId == 0)) {
 800d060:	697b      	ldr	r3, [r7, #20]
 800d062:	2b00      	cmp	r3, #0
 800d064:	d11d      	bne.n	800d0a2 <ProcessBufferPrivateKey+0x7e>
 800d066:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d068:	2b00      	cmp	r3, #0
 800d06a:	d11a      	bne.n	800d0a2 <ProcessBufferPrivateKey+0x7e>
    #ifdef OPENSSL_EXTRA
        /* Decryption password is probably wrong. */
        if (info->passwd_cb) {
 800d06c:	6a3b      	ldr	r3, [r7, #32]
 800d06e:	685b      	ldr	r3, [r3, #4]
 800d070:	2b00      	cmp	r3, #0
 800d072:	d009      	beq.n	800d088 <ProcessBufferPrivateKey+0x64>
            WOLFSSL_EVPerr(0, -WOLFSSL_EVP_R_BAD_DECRYPT_E);
 800d074:	f44f 63af 	mov.w	r3, #1400	@ 0x578
 800d078:	9300      	str	r3, [sp, #0]
 800d07a:	4b0c      	ldr	r3, [pc, #48]	@ (800d0ac <ProcessBufferPrivateKey+0x88>)
 800d07c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800d080:	2100      	movs	r1, #0
 800d082:	200b      	movs	r0, #11
 800d084:	f000 fe68 	bl	800dd58 <wolfSSL_ERR_put_error>
        }
    #endif
        WOLFSSL_ERROR(WOLFSSL_BAD_FILE);
 800d088:	2300      	movs	r3, #0
 800d08a:	9300      	str	r3, [sp, #0]
 800d08c:	4b07      	ldr	r3, [pc, #28]	@ (800d0ac <ProcessBufferPrivateKey+0x88>)
 800d08e:	f240 527b 	movw	r2, #1403	@ 0x57b
 800d092:	4907      	ldr	r1, [pc, #28]	@ (800d0b0 <ProcessBufferPrivateKey+0x8c>)
 800d094:	f46f 70e7 	mvn.w	r0, #462	@ 0x1ce
 800d098:	f011 fda4 	bl	801ebe4 <WOLFSSL_ERROR_LINE>
        /* Unable to decode DER data. */
        ret = WOLFSSL_BAD_FILE;
 800d09c:	f46f 73e7 	mvn.w	r3, #462	@ 0x1ce
 800d0a0:	617b      	str	r3, [r7, #20]
    }

    return ret;
 800d0a2:	697b      	ldr	r3, [r7, #20]
}
 800d0a4:	4618      	mov	r0, r3
 800d0a6:	3718      	adds	r7, #24
 800d0a8:	46bd      	mov	sp, r7
 800d0aa:	bd80      	pop	{r7, pc}
 800d0ac:	0802ad1c 	.word	0x0802ad1c
 800d0b0:	08032230 	.word	0x08032230

0800d0b4 <wolfssl_set_have_from_key_oid>:
 * @param [in, out] ssl     SSL object.
 * @param [in]      keyOID  OID for public/private key.
 */
static void wolfssl_set_have_from_key_oid(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    int keyOID)
{
 800d0b4:	b480      	push	{r7}
 800d0b6:	b085      	sub	sp, #20
 800d0b8:	af00      	add	r7, sp, #0
 800d0ba:	60f8      	str	r0, [r7, #12]
 800d0bc:	60b9      	str	r1, [r7, #8]
 800d0be:	607a      	str	r2, [r7, #4]
    /* Set which private key algorithm available based on key OID. */
    switch (keyOID) {
 800d0c0:	687b      	ldr	r3, [r7, #4]
 800d0c2:	f240 228e 	movw	r2, #654	@ 0x28e
 800d0c6:	4293      	cmp	r3, r2
 800d0c8:	d022      	beq.n	800d110 <wolfssl_set_have_from_key_oid+0x5c>
 800d0ca:	687b      	ldr	r3, [r7, #4]
 800d0cc:	f240 228e 	movw	r2, #654	@ 0x28e
 800d0d0:	4293      	cmp	r3, r2
 800d0d2:	dc30      	bgt.n	800d136 <wolfssl_set_have_from_key_oid+0x82>
 800d0d4:	687b      	ldr	r3, [r7, #4]
 800d0d6:	f240 2206 	movw	r2, #518	@ 0x206
 800d0da:	4293      	cmp	r3, r2
 800d0dc:	d005      	beq.n	800d0ea <wolfssl_set_have_from_key_oid+0x36>
 800d0de:	687b      	ldr	r3, [r7, #4]
 800d0e0:	f240 2285 	movw	r2, #645	@ 0x285
 800d0e4:	4293      	cmp	r3, r2
 800d0e6:	d013      	beq.n	800d110 <wolfssl_set_have_from_key_oid+0x5c>
            }
            break;
    #endif /* HAVE_DILITHIUM */
        default:
            WOLFSSL_MSG("Cert key not supported");
            break;
 800d0e8:	e025      	b.n	800d136 <wolfssl_set_have_from_key_oid+0x82>
            if (ssl != NULL) {
 800d0ea:	68bb      	ldr	r3, [r7, #8]
 800d0ec:	2b00      	cmp	r3, #0
 800d0ee:	d007      	beq.n	800d100 <wolfssl_set_have_from_key_oid+0x4c>
                ssl->options.haveECC = 1;
 800d0f0:	68ba      	ldr	r2, [r7, #8]
 800d0f2:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800d0f6:	f043 0310 	orr.w	r3, r3, #16
 800d0fa:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
            break;
 800d0fe:	e01b      	b.n	800d138 <wolfssl_set_have_from_key_oid+0x84>
                ctx->haveECC = 1;
 800d100:	68fa      	ldr	r2, [r7, #12]
 800d102:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 800d106:	f043 0308 	orr.w	r3, r3, #8
 800d10a:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
            break;
 800d10e:	e013      	b.n	800d138 <wolfssl_set_have_from_key_oid+0x84>
            if (ssl != NULL) {
 800d110:	68bb      	ldr	r3, [r7, #8]
 800d112:	2b00      	cmp	r3, #0
 800d114:	d007      	beq.n	800d126 <wolfssl_set_have_from_key_oid+0x72>
                ssl->options.haveRSA = 1;
 800d116:	68ba      	ldr	r2, [r7, #8]
 800d118:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800d11c:	f043 0308 	orr.w	r3, r3, #8
 800d120:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
            break;
 800d124:	e008      	b.n	800d138 <wolfssl_set_have_from_key_oid+0x84>
                ctx->haveRSA = 1;
 800d126:	68fa      	ldr	r2, [r7, #12]
 800d128:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 800d12c:	f043 0304 	orr.w	r3, r3, #4
 800d130:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
            break;
 800d134:	e000      	b.n	800d138 <wolfssl_set_have_from_key_oid+0x84>
            break;
 800d136:	bf00      	nop
        }
}
 800d138:	bf00      	nop
 800d13a:	3714      	adds	r7, #20
 800d13c:	46bd      	mov	sp, r7
 800d13e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d142:	4770      	bx	lr

0800d144 <ProcessBufferCertSetHave>:
 * @param [in, out] ssl     SSL object.
 * @param [in]      cert    Decode certificate.
 */
static void ProcessBufferCertSetHave(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DecodedCert* cert)
{
 800d144:	b580      	push	{r7, lr}
 800d146:	b084      	sub	sp, #16
 800d148:	af00      	add	r7, sp, #0
 800d14a:	60f8      	str	r0, [r7, #12]
 800d14c:	60b9      	str	r1, [r7, #8]
 800d14e:	607a      	str	r2, [r7, #4]
    if (ssl != NULL) {
 800d150:	68bb      	ldr	r3, [r7, #8]
 800d152:	2b00      	cmp	r3, #0
 800d154:	d014      	beq.n	800d180 <ProcessBufferCertSetHave+0x3c>
        /* Reset signatures we have in SSL. */
        ssl->options.haveECDSAsig = 0;
 800d156:	68ba      	ldr	r2, [r7, #8]
 800d158:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800d15c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800d160:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
        ssl->options.haveFalconSig = 0;
 800d164:	68ba      	ldr	r2, [r7, #8]
 800d166:	f892 32d4 	ldrb.w	r3, [r2, #724]	@ 0x2d4
 800d16a:	f023 0301 	bic.w	r3, r3, #1
 800d16e:	f882 32d4 	strb.w	r3, [r2, #724]	@ 0x2d4
        ssl->options.haveDilithiumSig = 0;
 800d172:	68ba      	ldr	r2, [r7, #8]
 800d174:	f892 32d4 	ldrb.w	r3, [r2, #724]	@ 0x2d4
 800d178:	f023 0302 	bic.w	r3, r3, #2
 800d17c:	f882 32d4 	strb.w	r3, [r2, #724]	@ 0x2d4
    }

    /* Set which signature we have based on the type in the cert. */
    switch (cert->signatureOID) {
 800d180:	687b      	ldr	r3, [r7, #4]
 800d182:	699b      	ldr	r3, [r3, #24]
 800d184:	f5b3 7f02 	cmp.w	r3, #520	@ 0x208
 800d188:	d006      	beq.n	800d198 <ProcessBufferCertSetHave+0x54>
 800d18a:	f5b3 7f02 	cmp.w	r3, #520	@ 0x208
 800d18e:	d319      	bcc.n	800d1c4 <ProcessBufferCertSetHave+0x80>
 800d190:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 800d194:	2b02      	cmp	r3, #2
 800d196:	d815      	bhi.n	800d1c4 <ProcessBufferCertSetHave+0x80>
    #endif
    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        case CTC_SM3wSM2:
    #endif
            WOLFSSL_MSG("ECDSA/ED25519/ED448 cert signature");
            if (ssl) {
 800d198:	68bb      	ldr	r3, [r7, #8]
 800d19a:	2b00      	cmp	r3, #0
 800d19c:	d007      	beq.n	800d1ae <ProcessBufferCertSetHave+0x6a>
                ssl->options.haveECDSAsig = 1;
 800d19e:	68ba      	ldr	r2, [r7, #8]
 800d1a0:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800d1a4:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800d1a8:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
            }
            else if (ctx) {
                ctx->haveECDSAsig = 1;
            }
            break;
 800d1ac:	e00c      	b.n	800d1c8 <ProcessBufferCertSetHave+0x84>
            else if (ctx) {
 800d1ae:	68fb      	ldr	r3, [r7, #12]
 800d1b0:	2b00      	cmp	r3, #0
 800d1b2:	d009      	beq.n	800d1c8 <ProcessBufferCertSetHave+0x84>
                ctx->haveECDSAsig = 1;
 800d1b4:	68fa      	ldr	r2, [r7, #12]
 800d1b6:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 800d1ba:	f043 0320 	orr.w	r3, r3, #32
 800d1be:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
            break;
 800d1c2:	e001      	b.n	800d1c8 <ProcessBufferCertSetHave+0x84>
            }
            break;
    #endif
        default:
            WOLFSSL_MSG("Cert signature not supported");
            break;
 800d1c4:	bf00      	nop
 800d1c6:	e000      	b.n	800d1ca <ProcessBufferCertSetHave+0x86>
            break;
 800d1c8:	bf00      	nop

#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
    defined(HAVE_FALCON) || defined(HAVE_DILITHIUM) || !defined(NO_RSA)
    #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    /* Set the private key curve OID. */
    if (ssl != NULL) {
 800d1ca:	68bb      	ldr	r3, [r7, #8]
 800d1cc:	2b00      	cmp	r3, #0
 800d1ce:	d006      	beq.n	800d1de <ProcessBufferCertSetHave+0x9a>
        ssl->pkCurveOID = cert->pkCurveOID;
 800d1d0:	687b      	ldr	r3, [r7, #4]
 800d1d2:	f8d3 2440 	ldr.w	r2, [r3, #1088]	@ 0x440
 800d1d6:	68bb      	ldr	r3, [r7, #8]
 800d1d8:	f8c3 23a8 	str.w	r2, [r3, #936]	@ 0x3a8
 800d1dc:	e008      	b.n	800d1f0 <ProcessBufferCertSetHave+0xac>
    }
    else if (ctx) {
 800d1de:	68fb      	ldr	r3, [r7, #12]
 800d1e0:	2b00      	cmp	r3, #0
 800d1e2:	d005      	beq.n	800d1f0 <ProcessBufferCertSetHave+0xac>
        ctx->pkCurveOID = cert->pkCurveOID;
 800d1e4:	687b      	ldr	r3, [r7, #4]
 800d1e6:	f8d3 2440 	ldr.w	r2, [r3, #1088]	@ 0x440
 800d1ea:	68fb      	ldr	r3, [r7, #12]
 800d1ec:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
    }
    #endif
#ifndef WC_STRICT_SIG
    if ((ctx != NULL) || (ssl != NULL)) {
 800d1f0:	68fb      	ldr	r3, [r7, #12]
 800d1f2:	2b00      	cmp	r3, #0
 800d1f4:	d102      	bne.n	800d1fc <ProcessBufferCertSetHave+0xb8>
 800d1f6:	68bb      	ldr	r3, [r7, #8]
 800d1f8:	2b00      	cmp	r3, #0
 800d1fa:	d006      	beq.n	800d20a <ProcessBufferCertSetHave+0xc6>
        wolfssl_set_have_from_key_oid(ctx, ssl, (int)cert->keyOID);
 800d1fc:	687b      	ldr	r3, [r7, #4]
 800d1fe:	69db      	ldr	r3, [r3, #28]
 800d200:	461a      	mov	r2, r3
 800d202:	68b9      	ldr	r1, [r7, #8]
 800d204:	68f8      	ldr	r0, [r7, #12]
 800d206:	f7ff ff55 	bl	800d0b4 <wolfssl_set_have_from_key_oid>
    else if (ctx) {
        ctx->haveECC = ctx->haveECDSAsig;
    }
#endif /* !WC_STRICT_SIG */
#endif
}
 800d20a:	bf00      	nop
 800d20c:	3710      	adds	r7, #16
 800d20e:	46bd      	mov	sp, r7
 800d210:	bd80      	pop	{r7, pc}
	...

0800d214 <ProcessBufferCertPublicKey>:
 * @return  0 on success.
 * @return  Non-zero when an error occurred.
 */
static int ProcessBufferCertPublicKey(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DecodedCert* cert, int checkKeySz)
{
 800d214:	b580      	push	{r7, lr}
 800d216:	b08c      	sub	sp, #48	@ 0x30
 800d218:	af04      	add	r7, sp, #16
 800d21a:	60f8      	str	r0, [r7, #12]
 800d21c:	60b9      	str	r1, [r7, #8]
 800d21e:	607a      	str	r2, [r7, #4]
 800d220:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800d222:	2300      	movs	r3, #0
 800d224:	61fb      	str	r3, [r7, #28]
    byte keyType = 0;
 800d226:	2300      	movs	r3, #0
 800d228:	76fb      	strb	r3, [r7, #27]
    int keySz = 0;
 800d22a:	2300      	movs	r3, #0
 800d22c:	617b      	str	r3, [r7, #20]
#ifndef NO_RSA
    word32 idx;
#endif

    /* Get key size and check unless not verifying. */
    switch (cert->keyOID) {
 800d22e:	687b      	ldr	r3, [r7, #4]
 800d230:	69db      	ldr	r3, [r3, #28]
 800d232:	f240 228e 	movw	r2, #654	@ 0x28e
 800d236:	4293      	cmp	r3, r2
 800d238:	d00c      	beq.n	800d254 <ProcessBufferCertPublicKey+0x40>
 800d23a:	f240 228e 	movw	r2, #654	@ 0x28e
 800d23e:	4293      	cmp	r3, r2
 800d240:	f200 8082 	bhi.w	800d348 <ProcessBufferCertPublicKey+0x134>
 800d244:	f240 2206 	movw	r2, #518	@ 0x206
 800d248:	4293      	cmp	r3, r2
 800d24a:	d045      	beq.n	800d2d8 <ProcessBufferCertPublicKey+0xc4>
 800d24c:	f240 2285 	movw	r2, #645	@ 0x285
 800d250:	4293      	cmp	r3, r2
 800d252:	d179      	bne.n	800d348 <ProcessBufferCertPublicKey+0x134>
#ifndef NO_RSA
    #ifdef WC_RSA_PSS
        case RSAPSSk:
    #endif
        case RSAk:
            keyType = rsa_sa_algo;
 800d254:	2301      	movs	r3, #1
 800d256:	76fb      	strb	r3, [r7, #27]
            /* Determine RSA key size by parsing public key */
            idx = 0;
 800d258:	2300      	movs	r3, #0
 800d25a:	613b      	str	r3, [r7, #16]
            ret = wc_RsaPublicKeyDecode_ex(cert->publicKey, &idx,
 800d25c:	687b      	ldr	r3, [r7, #4]
 800d25e:	6818      	ldr	r0, [r3, #0]
 800d260:	687b      	ldr	r3, [r7, #4]
 800d262:	685a      	ldr	r2, [r3, #4]
 800d264:	f107 0110 	add.w	r1, r7, #16
 800d268:	2300      	movs	r3, #0
 800d26a:	9302      	str	r3, [sp, #8]
 800d26c:	2300      	movs	r3, #0
 800d26e:	9301      	str	r3, [sp, #4]
 800d270:	f107 0314 	add.w	r3, r7, #20
 800d274:	9300      	str	r3, [sp, #0]
 800d276:	2300      	movs	r3, #0
 800d278:	f007 fed0 	bl	801501c <wc_RsaPublicKeyDecode_ex>
 800d27c:	61f8      	str	r0, [r7, #28]
                cert->pubKeySize, NULL, (word32*)&keySz, NULL, NULL);
            if ((ret == 0) && checkKeySz) {
 800d27e:	69fb      	ldr	r3, [r7, #28]
 800d280:	2b00      	cmp	r3, #0
 800d282:	d163      	bne.n	800d34c <ProcessBufferCertPublicKey+0x138>
 800d284:	683b      	ldr	r3, [r7, #0]
 800d286:	2b00      	cmp	r3, #0
 800d288:	d060      	beq.n	800d34c <ProcessBufferCertPublicKey+0x138>
                ret = CHECK_KEY_SZ(ssl ? ssl->options.minRsaKeySz :
 800d28a:	68bb      	ldr	r3, [r7, #8]
 800d28c:	2b00      	cmp	r3, #0
 800d28e:	d005      	beq.n	800d29c <ProcessBufferCertPublicKey+0x88>
 800d290:	68bb      	ldr	r3, [r7, #8]
 800d292:	f9b3 32f4 	ldrsh.w	r3, [r3, #756]	@ 0x2f4
 800d296:	2b00      	cmp	r3, #0
 800d298:	db18      	blt.n	800d2cc <ProcessBufferCertPublicKey+0xb8>
 800d29a:	e004      	b.n	800d2a6 <ProcessBufferCertPublicKey+0x92>
 800d29c:	68fb      	ldr	r3, [r7, #12]
 800d29e:	f9b3 3066 	ldrsh.w	r3, [r3, #102]	@ 0x66
 800d2a2:	2b00      	cmp	r3, #0
 800d2a4:	db12      	blt.n	800d2cc <ProcessBufferCertPublicKey+0xb8>
 800d2a6:	68bb      	ldr	r3, [r7, #8]
 800d2a8:	2b00      	cmp	r3, #0
 800d2aa:	d004      	beq.n	800d2b6 <ProcessBufferCertPublicKey+0xa2>
 800d2ac:	68bb      	ldr	r3, [r7, #8]
 800d2ae:	f9b3 32f4 	ldrsh.w	r3, [r3, #756]	@ 0x2f4
 800d2b2:	461a      	mov	r2, r3
 800d2b4:	e003      	b.n	800d2be <ProcessBufferCertPublicKey+0xaa>
 800d2b6:	68fb      	ldr	r3, [r7, #12]
 800d2b8:	f9b3 3066 	ldrsh.w	r3, [r3, #102]	@ 0x66
 800d2bc:	461a      	mov	r2, r3
 800d2be:	697b      	ldr	r3, [r7, #20]
 800d2c0:	429a      	cmp	r2, r3
 800d2c2:	dc03      	bgt.n	800d2cc <ProcessBufferCertPublicKey+0xb8>
 800d2c4:	697b      	ldr	r3, [r7, #20]
 800d2c6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800d2ca:	dd02      	ble.n	800d2d2 <ProcessBufferCertPublicKey+0xbe>
 800d2cc:	f46f 73cc 	mvn.w	r3, #408	@ 0x198
 800d2d0:	e000      	b.n	800d2d4 <ProcessBufferCertPublicKey+0xc0>
 800d2d2:	2300      	movs	r3, #0
 800d2d4:	61fb      	str	r3, [r7, #28]
                    ctx->minRsaKeySz, RSA_MAX_SIZE / 8, keySz, RSA_KEY_SIZE_E);
            }
            break;
 800d2d6:	e039      	b.n	800d34c <ProcessBufferCertPublicKey+0x138>
#endif /* !NO_RSA */
    #ifdef HAVE_ECC
        case ECDSAk:
            keyType = ecc_dsa_sa_algo;
 800d2d8:	2303      	movs	r3, #3
 800d2da:	76fb      	strb	r3, [r7, #27]
                keySz = cert->pkCurveSize;
            }
            else
        #endif
            {
                keySz = wc_ecc_get_curve_size_from_id(wc_ecc_get_oid(
 800d2dc:	687b      	ldr	r3, [r7, #4]
 800d2de:	f8d3 3440 	ldr.w	r3, [r3, #1088]	@ 0x440
 800d2e2:	2200      	movs	r2, #0
 800d2e4:	2100      	movs	r1, #0
 800d2e6:	4618      	mov	r0, r3
 800d2e8:	f011 f89e 	bl	801e428 <wc_ecc_get_oid>
 800d2ec:	4603      	mov	r3, r0
 800d2ee:	4618      	mov	r0, r3
 800d2f0:	f00f fcd0 	bl	801cc94 <wc_ecc_get_curve_size_from_id>
 800d2f4:	4603      	mov	r3, r0
 800d2f6:	617b      	str	r3, [r7, #20]
                    cert->pkCurveOID, NULL, NULL));
            }

            if (checkKeySz) {
 800d2f8:	683b      	ldr	r3, [r7, #0]
 800d2fa:	2b00      	cmp	r3, #0
 800d2fc:	d028      	beq.n	800d350 <ProcessBufferCertPublicKey+0x13c>
                ret = CHECK_KEY_SZ(ssl ? ssl->options.minEccKeySz :
 800d2fe:	68bb      	ldr	r3, [r7, #8]
 800d300:	2b00      	cmp	r3, #0
 800d302:	d005      	beq.n	800d310 <ProcessBufferCertPublicKey+0xfc>
 800d304:	68bb      	ldr	r3, [r7, #8]
 800d306:	f9b3 32f6 	ldrsh.w	r3, [r3, #758]	@ 0x2f6
 800d30a:	2b00      	cmp	r3, #0
 800d30c:	db17      	blt.n	800d33e <ProcessBufferCertPublicKey+0x12a>
 800d30e:	e004      	b.n	800d31a <ProcessBufferCertPublicKey+0x106>
 800d310:	68fb      	ldr	r3, [r7, #12]
 800d312:	f9b3 3068 	ldrsh.w	r3, [r3, #104]	@ 0x68
 800d316:	2b00      	cmp	r3, #0
 800d318:	db11      	blt.n	800d33e <ProcessBufferCertPublicKey+0x12a>
 800d31a:	68bb      	ldr	r3, [r7, #8]
 800d31c:	2b00      	cmp	r3, #0
 800d31e:	d004      	beq.n	800d32a <ProcessBufferCertPublicKey+0x116>
 800d320:	68bb      	ldr	r3, [r7, #8]
 800d322:	f9b3 32f6 	ldrsh.w	r3, [r3, #758]	@ 0x2f6
 800d326:	461a      	mov	r2, r3
 800d328:	e003      	b.n	800d332 <ProcessBufferCertPublicKey+0x11e>
 800d32a:	68fb      	ldr	r3, [r7, #12]
 800d32c:	f9b3 3068 	ldrsh.w	r3, [r3, #104]	@ 0x68
 800d330:	461a      	mov	r2, r3
 800d332:	697b      	ldr	r3, [r7, #20]
 800d334:	429a      	cmp	r2, r3
 800d336:	dc02      	bgt.n	800d33e <ProcessBufferCertPublicKey+0x12a>
 800d338:	697b      	ldr	r3, [r7, #20]
 800d33a:	2b20      	cmp	r3, #32
 800d33c:	dd01      	ble.n	800d342 <ProcessBufferCertPublicKey+0x12e>
 800d33e:	4b11      	ldr	r3, [pc, #68]	@ (800d384 <ProcessBufferCertPublicKey+0x170>)
 800d340:	e000      	b.n	800d344 <ProcessBufferCertPublicKey+0x130>
 800d342:	2300      	movs	r3, #0
 800d344:	61fb      	str	r3, [r7, #28]
                     ctx->minEccKeySz, (MAX_ECC_BITS + 7) / 8, keySz,
                     ECC_KEY_SIZE_E);
            }
            break;
 800d346:	e003      	b.n	800d350 <ProcessBufferCertPublicKey+0x13c>
            break;
    #endif /* HAVE_DILITHIUM */

        default:
            WOLFSSL_MSG("No key size check done on public key in certificate");
            break;
 800d348:	bf00      	nop
 800d34a:	e002      	b.n	800d352 <ProcessBufferCertPublicKey+0x13e>
            break;
 800d34c:	bf00      	nop
 800d34e:	e000      	b.n	800d352 <ProcessBufferCertPublicKey+0x13e>
            break;
 800d350:	bf00      	nop
    }

    /* Store the type and key size as there may not be a private key set. */
    if (ssl != NULL) {
 800d352:	68bb      	ldr	r3, [r7, #8]
 800d354:	2b00      	cmp	r3, #0
 800d356:	d008      	beq.n	800d36a <ProcessBufferCertPublicKey+0x156>
        ssl->buffers.keyType = keyType;
 800d358:	68bb      	ldr	r3, [r7, #8]
 800d35a:	7efa      	ldrb	r2, [r7, #27]
 800d35c:	f883 2174 	strb.w	r2, [r3, #372]	@ 0x174
        ssl->buffers.keySz = keySz;
 800d360:	697a      	ldr	r2, [r7, #20]
 800d362:	68bb      	ldr	r3, [r7, #8]
 800d364:	f8c3 2178 	str.w	r2, [r3, #376]	@ 0x178
 800d368:	e006      	b.n	800d378 <ProcessBufferCertPublicKey+0x164>
    }
    else {
        ctx->privateKeyType = keyType;
 800d36a:	68fb      	ldr	r3, [r7, #12]
 800d36c:	7efa      	ldrb	r2, [r7, #27]
 800d36e:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
        ctx->privateKeySz = keySz;
 800d372:	697a      	ldr	r2, [r7, #20]
 800d374:	68fb      	ldr	r3, [r7, #12]
 800d376:	649a      	str	r2, [r3, #72]	@ 0x48
    }

    return ret;
 800d378:	69fb      	ldr	r3, [r7, #28]
}
 800d37a:	4618      	mov	r0, r3
 800d37c:	3720      	adds	r7, #32
 800d37e:	46bd      	mov	sp, r7
 800d380:	bd80      	pop	{r7, pc}
 800d382:	bf00      	nop
 800d384:	fffffe66 	.word	0xfffffe66

0800d388 <ProcessBufferCert>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  WOLFSSL_BAD_FILE when decoding certificate fails.
 */
static int ProcessBufferCert(WOLFSSL_CTX* ctx, WOLFSSL* ssl, DerBuffer* der)
{
 800d388:	b580      	push	{r7, lr}
 800d38a:	b08c      	sub	sp, #48	@ 0x30
 800d38c:	af02      	add	r7, sp, #8
 800d38e:	60f8      	str	r0, [r7, #12]
 800d390:	60b9      	str	r1, [r7, #8]
 800d392:	607a      	str	r2, [r7, #4]
    int ret = 0;
 800d394:	2300      	movs	r3, #0
 800d396:	627b      	str	r3, [r7, #36]	@ 0x24
    void* heap = WOLFSSL_HEAP(ctx, ssl);
 800d398:	68fb      	ldr	r3, [r7, #12]
 800d39a:	2b00      	cmp	r3, #0
 800d39c:	d002      	beq.n	800d3a4 <ProcessBufferCert+0x1c>
 800d39e:	68fb      	ldr	r3, [r7, #12]
 800d3a0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800d3a2:	e007      	b.n	800d3b4 <ProcessBufferCert+0x2c>
 800d3a4:	68bb      	ldr	r3, [r7, #8]
 800d3a6:	2b00      	cmp	r3, #0
 800d3a8:	d003      	beq.n	800d3b2 <ProcessBufferCert+0x2a>
 800d3aa:	68bb      	ldr	r3, [r7, #8]
 800d3ac:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d3b0:	e000      	b.n	800d3b4 <ProcessBufferCert+0x2c>
 800d3b2:	2300      	movs	r3, #0
 800d3b4:	61fb      	str	r3, [r7, #28]
    DecodedCert  cert[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    /* Allocate memory for certificate to be decoded into. */
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), heap, DYNAMIC_TYPE_DCERT);
 800d3b6:	f44f 6097 	mov.w	r0, #1208	@ 0x4b8
 800d3ba:	f011 fc5f 	bl	801ec7c <wolfSSL_Malloc>
 800d3be:	61b8      	str	r0, [r7, #24]
    if (cert == NULL) {
 800d3c0:	69bb      	ldr	r3, [r7, #24]
 800d3c2:	2b00      	cmp	r3, #0
 800d3c4:	d102      	bne.n	800d3cc <ProcessBufferCert+0x44>
        ret = MEMORY_E;
 800d3c6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800d3ca:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    if (ret == 0)
 800d3cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d3ce:	2b00      	cmp	r3, #0
 800d3d0:	d144      	bne.n	800d45c <ProcessBufferCert+0xd4>
#endif
    {
        /* Get device id from SSL context or SSL object. */
        int devId = wolfSSL_CTX_GetDevId(ctx, ssl);
 800d3d2:	68b9      	ldr	r1, [r7, #8]
 800d3d4:	68f8      	ldr	r0, [r7, #12]
 800d3d6:	f7fe ffa2 	bl	800c31e <wolfSSL_CTX_GetDevId>
 800d3da:	6178      	str	r0, [r7, #20]

        WOLFSSL_MSG("Checking cert signature type");
        /* Initialize certificate object. */
        InitDecodedCert_ex(cert, der->buffer, der->length, heap, devId);
 800d3dc:	687b      	ldr	r3, [r7, #4]
 800d3de:	6819      	ldr	r1, [r3, #0]
 800d3e0:	687b      	ldr	r3, [r7, #4]
 800d3e2:	689a      	ldr	r2, [r3, #8]
 800d3e4:	697b      	ldr	r3, [r7, #20]
 800d3e6:	9300      	str	r3, [sp, #0]
 800d3e8:	69fb      	ldr	r3, [r7, #28]
 800d3ea:	69b8      	ldr	r0, [r7, #24]
 800d3ec:	f007 ff45 	bl	801527a <InitDecodedCert_ex>

        /* Decode up to and including public key. */
        if (DecodeToKey(cert, 0) < 0) {
 800d3f0:	2100      	movs	r1, #0
 800d3f2:	69b8      	ldr	r0, [r7, #24]
 800d3f4:	f008 fddc 	bl	8015fb0 <DecodeToKey>
 800d3f8:	4603      	mov	r3, r0
 800d3fa:	2b00      	cmp	r3, #0
 800d3fc:	da02      	bge.n	800d404 <ProcessBufferCert+0x7c>
            WOLFSSL_MSG("Decode to key failed");
            ret = WOLFSSL_BAD_FILE;
 800d3fe:	f46f 73e7 	mvn.w	r3, #462	@ 0x1ce
 800d402:	627b      	str	r3, [r7, #36]	@ 0x24
        }
        if (ret == 0) {
 800d404:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d406:	2b00      	cmp	r3, #0
 800d408:	d128      	bne.n	800d45c <ProcessBufferCert+0xd4>
            int checkKeySz = 1;
 800d40a:	2301      	movs	r3, #1
 800d40c:	623b      	str	r3, [r7, #32]
            /* Store whether the crtificate is a raw public key. */
            rpkState->isRPKLoaded = cert->isRPK;
        #endif /* HAVE_RPK */

            /* Set which private key algorithm we have. */
            ProcessBufferCertSetHave(ctx, ssl, cert);
 800d40e:	69ba      	ldr	r2, [r7, #24]
 800d410:	68b9      	ldr	r1, [r7, #8]
 800d412:	68f8      	ldr	r0, [r7, #12]
 800d414:	f7ff fe96 	bl	800d144 <ProcessBufferCertSetHave>

            /* Don't check if verification is disabled for SSL. */
            if ((ssl != NULL) && ssl->options.verifyNone) {
 800d418:	68bb      	ldr	r3, [r7, #8]
 800d41a:	2b00      	cmp	r3, #0
 800d41c:	d00a      	beq.n	800d434 <ProcessBufferCert+0xac>
 800d41e:	68bb      	ldr	r3, [r7, #8]
 800d420:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800d424:	f003 0308 	and.w	r3, r3, #8
 800d428:	b2db      	uxtb	r3, r3
 800d42a:	2b00      	cmp	r3, #0
 800d42c:	d002      	beq.n	800d434 <ProcessBufferCert+0xac>
                checkKeySz = 0;
 800d42e:	2300      	movs	r3, #0
 800d430:	623b      	str	r3, [r7, #32]
 800d432:	e00c      	b.n	800d44e <ProcessBufferCert+0xc6>
            }
            /* Don't check if no SSL object verification is disabled for SSL
             * context. */
            else if ((ssl == NULL) && ctx->verifyNone) {
 800d434:	68bb      	ldr	r3, [r7, #8]
 800d436:	2b00      	cmp	r3, #0
 800d438:	d109      	bne.n	800d44e <ProcessBufferCert+0xc6>
 800d43a:	68fb      	ldr	r3, [r7, #12]
 800d43c:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
 800d440:	f003 0302 	and.w	r3, r3, #2
 800d444:	b2db      	uxtb	r3, r3
 800d446:	2b00      	cmp	r3, #0
 800d448:	d001      	beq.n	800d44e <ProcessBufferCert+0xc6>
                checkKeySz = 0;
 800d44a:	2300      	movs	r3, #0
 800d44c:	623b      	str	r3, [r7, #32]
            }

            /* Check public key size. */
            ret = ProcessBufferCertPublicKey(ctx, ssl, cert, checkKeySz);
 800d44e:	6a3b      	ldr	r3, [r7, #32]
 800d450:	69ba      	ldr	r2, [r7, #24]
 800d452:	68b9      	ldr	r1, [r7, #8]
 800d454:	68f8      	ldr	r0, [r7, #12]
 800d456:	f7ff fedd 	bl	800d214 <ProcessBufferCertPublicKey>
 800d45a:	6278      	str	r0, [r7, #36]	@ 0x24
        #endif
        }
    }

    /* Dispose of dynamic memory in certificate object. */
    FreeDecodedCert(cert);
 800d45c:	69b8      	ldr	r0, [r7, #24]
 800d45e:	f007 ffd1 	bl	8015404 <FreeDecodedCert>
#ifdef WOLFSSL_SMALL_STACK
    /* Dispose of certificate object. */
    XFREE(cert, heap, DYNAMIC_TYPE_DCERT);
 800d462:	69bb      	ldr	r3, [r7, #24]
 800d464:	613b      	str	r3, [r7, #16]
 800d466:	693b      	ldr	r3, [r7, #16]
 800d468:	2b00      	cmp	r3, #0
 800d46a:	d002      	beq.n	800d472 <ProcessBufferCert+0xea>
 800d46c:	6938      	ldr	r0, [r7, #16]
 800d46e:	f011 fc21 	bl	801ecb4 <wolfSSL_Free>
#endif
    return ret;
 800d472:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800d474:	4618      	mov	r0, r3
 800d476:	3728      	adds	r7, #40	@ 0x28
 800d478:	46bd      	mov	sp, r7
 800d47a:	bd80      	pop	{r7, pc}

0800d47c <ProcessBufferCertHandleDer>:
 * @return  BAD_FUNC_ARG when type is CA_TYPE and ctx is NULL.
 * @return  WOLFSSL_BAD_CERTTYPE when data type is not supported.
 */
static int ProcessBufferCertHandleDer(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int type, int verify)
{
 800d47c:	b580      	push	{r7, lr}
 800d47e:	b086      	sub	sp, #24
 800d480:	af00      	add	r7, sp, #0
 800d482:	60f8      	str	r0, [r7, #12]
 800d484:	60b9      	str	r1, [r7, #8]
 800d486:	607a      	str	r2, [r7, #4]
 800d488:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800d48a:	2300      	movs	r3, #0
 800d48c:	617b      	str	r3, [r7, #20]

    /* CA certificate to verify with. */
    if (type == CA_TYPE) {
 800d48e:	683b      	ldr	r3, [r7, #0]
 800d490:	2b06      	cmp	r3, #6
 800d492:	d10d      	bne.n	800d4b0 <ProcessBufferCertHandleDer+0x34>
        /* verify CA unless user set to no verify */
        ret = AddCA(ctx->cm, &der, WOLFSSL_USER_CA, verify);
 800d494:	68fb      	ldr	r3, [r7, #12]
 800d496:	6d18      	ldr	r0, [r3, #80]	@ 0x50
 800d498:	1d39      	adds	r1, r7, #4
 800d49a:	6a3b      	ldr	r3, [r7, #32]
 800d49c:	2201      	movs	r2, #1
 800d49e:	f7ff f8d9 	bl	800c654 <AddCA>
 800d4a2:	6178      	str	r0, [r7, #20]
        if (ret == 1) {
 800d4a4:	697b      	ldr	r3, [r7, #20]
 800d4a6:	2b01      	cmp	r3, #1
 800d4a8:	d12f      	bne.n	800d50a <ProcessBufferCertHandleDer+0x8e>
            ret = 0;
 800d4aa:	2300      	movs	r3, #0
 800d4ac:	617b      	str	r3, [r7, #20]
 800d4ae:	e02c      	b.n	800d50a <ProcessBufferCertHandleDer+0x8e>
            WOLFSSL_MSG("Error adding trusted peer");
        }
    }
#endif /* WOLFSSL_TRUST_PEER_CERT */
    /* Leaf certificate - our certificate. */
    else if (type == CERT_TYPE) {
 800d4b0:	683b      	ldr	r3, [r7, #0]
 800d4b2:	2b00      	cmp	r3, #0
 800d4b4:	d122      	bne.n	800d4fc <ProcessBufferCertHandleDer+0x80>
        if (ssl != NULL) {
 800d4b6:	68bb      	ldr	r3, [r7, #8]
 800d4b8:	2b00      	cmp	r3, #0
 800d4ba:	d013      	beq.n	800d4e4 <ProcessBufferCertHandleDer+0x68>
            /* Free previous certificate if we own it. */
            if (ssl->buffers.weOwnCert) {
 800d4bc:	68bb      	ldr	r3, [r7, #8]
 800d4be:	f893 3144 	ldrb.w	r3, [r3, #324]	@ 0x144
 800d4c2:	2b00      	cmp	r3, #0
 800d4c4:	d005      	beq.n	800d4d2 <ProcessBufferCertHandleDer+0x56>
                FreeDer(&ssl->buffers.certificate);
 800d4c6:	68bb      	ldr	r3, [r7, #8]
 800d4c8:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 800d4cc:	4618      	mov	r0, r3
 800d4ce:	f00b fe0d 	bl	80190ec <FreeDer>
                wolfSSL_X509_free(ssl->ourCert);
                ssl->ourCert = NULL;
            #endif
            }
            /* Store certificate as ours. */
            ssl->buffers.certificate = der;
 800d4d2:	687a      	ldr	r2, [r7, #4]
 800d4d4:	68bb      	ldr	r3, [r7, #8]
 800d4d6:	f8c3 216c 	str.w	r2, [r3, #364]	@ 0x16c
        #ifdef KEEP_OUR_CERT
            ssl->keepCert = 1; /* hold cert for ssl lifetime */
        #endif
            /* We have to free the certificate buffer. */
            ssl->buffers.weOwnCert = 1;
 800d4da:	68bb      	ldr	r3, [r7, #8]
 800d4dc:	2201      	movs	r2, #1
 800d4de:	f883 2144 	strb.w	r2, [r3, #324]	@ 0x144
 800d4e2:	e012      	b.n	800d50a <ProcessBufferCertHandleDer+0x8e>
            /* ourCert is created on demand. */
        }
        else if (ctx != NULL) {
 800d4e4:	68fb      	ldr	r3, [r7, #12]
 800d4e6:	2b00      	cmp	r3, #0
 800d4e8:	d00f      	beq.n	800d50a <ProcessBufferCertHandleDer+0x8e>
            /* Free previous certificate. */
            FreeDer(&ctx->certificate); /* Make sure previous is free'd */
 800d4ea:	68fb      	ldr	r3, [r7, #12]
 800d4ec:	3320      	adds	r3, #32
 800d4ee:	4618      	mov	r0, r3
 800d4f0:	f00b fdfc 	bl	80190ec <FreeDer>
                wolfSSL_X509_free(ctx->ourCert);
            }
            ctx->ourCert = NULL;
        #endif
            /* Store certificate as ours. */
            ctx->certificate = der;
 800d4f4:	687a      	ldr	r2, [r7, #4]
 800d4f6:	68fb      	ldr	r3, [r7, #12]
 800d4f8:	621a      	str	r2, [r3, #32]
 800d4fa:	e006      	b.n	800d50a <ProcessBufferCertHandleDer+0x8e>
            /* ourCert is created on demand. */
        }
    }
    else {
        /* Dispose of DER buffer. */
        FreeDer(&der);
 800d4fc:	1d3b      	adds	r3, r7, #4
 800d4fe:	4618      	mov	r0, r3
 800d500:	f00b fdf4 	bl	80190ec <FreeDer>
        /* Not a certificate type supported. */
        ret = WOLFSSL_BAD_CERTTYPE;
 800d504:	f46f 73e5 	mvn.w	r3, #458	@ 0x1ca
 800d508:	617b      	str	r3, [r7, #20]
    }

    return ret;
 800d50a:	697b      	ldr	r3, [r7, #20]
}
 800d50c:	4618      	mov	r0, r3
 800d50e:	3718      	adds	r7, #24
 800d510:	46bd      	mov	sp, r7
 800d512:	bd80      	pop	{r7, pc}

0800d514 <ProcessBufferCertTypes>:
 * @return  WOLFSSL_FATAL_ERROR on failure.
 */
static int ProcessBufferCertTypes(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const unsigned char* buff, long sz, DerBuffer* der, int format, int type,
    int verify)
{
 800d514:	b580      	push	{r7, lr}
 800d516:	b088      	sub	sp, #32
 800d518:	af02      	add	r7, sp, #8
 800d51a:	60f8      	str	r0, [r7, #12]
 800d51c:	60b9      	str	r1, [r7, #8]
 800d51e:	607a      	str	r2, [r7, #4]
 800d520:	603b      	str	r3, [r7, #0]

    (void)buff;
    (void)sz;
    (void)format;

    ret = ProcessBufferCertHandleDer(ctx, ssl, der, type, verify);
 800d522:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d524:	9300      	str	r3, [sp, #0]
 800d526:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d528:	6a3a      	ldr	r2, [r7, #32]
 800d52a:	68b9      	ldr	r1, [r7, #8]
 800d52c:	68f8      	ldr	r0, [r7, #12]
 800d52e:	f7ff ffa5 	bl	800d47c <ProcessBufferCertHandleDer>
 800d532:	6178      	str	r0, [r7, #20]
    if ((ret == 0) && (type == CERT_TYPE)) {
 800d534:	697b      	ldr	r3, [r7, #20]
 800d536:	2b00      	cmp	r3, #0
 800d538:	d108      	bne.n	800d54c <ProcessBufferCertTypes+0x38>
 800d53a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d53c:	2b00      	cmp	r3, #0
 800d53e:	d105      	bne.n	800d54c <ProcessBufferCertTypes+0x38>
        /* Process leaf certificate. */
        ret = ProcessBufferCert(ctx, ssl, der);
 800d540:	6a3a      	ldr	r2, [r7, #32]
 800d542:	68b9      	ldr	r1, [r7, #8]
 800d544:	68f8      	ldr	r0, [r7, #12]
 800d546:	f7ff ff1f 	bl	800d388 <ProcessBufferCert>
 800d54a:	6178      	str	r0, [r7, #20]
    }
#if !defined(NO_WOLFSSL_CM_VERIFY) && (!defined(NO_WOLFSSL_CLIENT) || \
    !defined(WOLFSSL_NO_CLIENT_AUTH))
    /* Hand bad CA or user certificate to callback. */
    if ((ret < 0) && ((type == CA_TYPE) || (type == CERT_TYPE))) {
 800d54c:	697b      	ldr	r3, [r7, #20]
 800d54e:	2b00      	cmp	r3, #0
 800d550:	da26      	bge.n	800d5a0 <ProcessBufferCertTypes+0x8c>
 800d552:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d554:	2b06      	cmp	r3, #6
 800d556:	d002      	beq.n	800d55e <ProcessBufferCertTypes+0x4a>
 800d558:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d55a:	2b00      	cmp	r3, #0
 800d55c:	d120      	bne.n	800d5a0 <ProcessBufferCertTypes+0x8c>
        /* Check for verification callback that may override error. */
        if ((ctx != NULL) && (ctx->cm != NULL) &&
 800d55e:	68fb      	ldr	r3, [r7, #12]
 800d560:	2b00      	cmp	r3, #0
 800d562:	d01d      	beq.n	800d5a0 <ProcessBufferCertTypes+0x8c>
 800d564:	68fb      	ldr	r3, [r7, #12]
 800d566:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d568:	2b00      	cmp	r3, #0
 800d56a:	d019      	beq.n	800d5a0 <ProcessBufferCertTypes+0x8c>
                (ctx->cm->verifyCallback != NULL)) {
 800d56c:	68fb      	ldr	r3, [r7, #12]
 800d56e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d570:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
        if ((ctx != NULL) && (ctx->cm != NULL) &&
 800d572:	2b00      	cmp	r3, #0
 800d574:	d014      	beq.n	800d5a0 <ProcessBufferCertTypes+0x8c>
            /* Verify and use callback. */
            ret = CM_VerifyBuffer_ex(ctx->cm, buff, sz, format, ret);
 800d576:	68fb      	ldr	r3, [r7, #12]
 800d578:	6d18      	ldr	r0, [r3, #80]	@ 0x50
 800d57a:	697b      	ldr	r3, [r7, #20]
 800d57c:	9300      	str	r3, [sp, #0]
 800d57e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d580:	683a      	ldr	r2, [r7, #0]
 800d582:	6879      	ldr	r1, [r7, #4]
 800d584:	f7fe f913 	bl	800b7ae <CM_VerifyBuffer_ex>
 800d588:	6178      	str	r0, [r7, #20]
            /* Convert error. */
            if (ret == 0) {
 800d58a:	697b      	ldr	r3, [r7, #20]
 800d58c:	2b00      	cmp	r3, #0
 800d58e:	d102      	bne.n	800d596 <ProcessBufferCertTypes+0x82>
                ret = WOLFSSL_FATAL_ERROR;
 800d590:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d594:	617b      	str	r3, [r7, #20]
            }
            if (ret == 1) {
 800d596:	697b      	ldr	r3, [r7, #20]
 800d598:	2b01      	cmp	r3, #1
 800d59a:	d101      	bne.n	800d5a0 <ProcessBufferCertTypes+0x8c>
                ret = 0;
 800d59c:	2300      	movs	r3, #0
 800d59e:	617b      	str	r3, [r7, #20]
            }
        }
    }
#endif /* NO_WOLFSSL_CM_VERIFY */

    return ret;
 800d5a0:	697b      	ldr	r3, [r7, #20]
}
 800d5a2:	4618      	mov	r0, r3
 800d5a4:	3718      	adds	r7, #24
 800d5a6:	46bd      	mov	sp, r7
 800d5a8:	bd80      	pop	{r7, pc}

0800d5aa <ProcessBufferResetSuites>:
 * @param [in]      type    Type of certificate.
 * @return  0 on success.
 * @return  WOLFSSL_FATAL_ERROR when allocation fails.
 */
static int ProcessBufferResetSuites(WOLFSSL_CTX* ctx, WOLFSSL* ssl, int type)
{
 800d5aa:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d5ac:	b095      	sub	sp, #84	@ 0x54
 800d5ae:	af0c      	add	r7, sp, #48	@ 0x30
 800d5b0:	6178      	str	r0, [r7, #20]
 800d5b2:	6139      	str	r1, [r7, #16]
 800d5b4:	60fa      	str	r2, [r7, #12]
    int ret = 0;
 800d5b6:	2300      	movs	r3, #0
 800d5b8:	61fb      	str	r3, [r7, #28]

    /* Reset suites of SSL object. */
    if (ssl != NULL) {
 800d5ba:	693b      	ldr	r3, [r7, #16]
 800d5bc:	2b00      	cmp	r3, #0
 800d5be:	d05f      	beq.n	800d680 <ProcessBufferResetSuites+0xd6>
        if (ssl->options.side == WOLFSSL_SERVER_END) {
 800d5c0:	693b      	ldr	r3, [r7, #16]
 800d5c2:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800d5c6:	f003 0303 	and.w	r3, r3, #3
 800d5ca:	b2db      	uxtb	r3, r3
 800d5cc:	2b00      	cmp	r3, #0
 800d5ce:	f040 80ad 	bne.w	800d72c <ProcessBufferResetSuites+0x182>
            /* Allocate memory for suites. */
            if (AllocateSuites(ssl) != 0) {
 800d5d2:	6938      	ldr	r0, [r7, #16]
 800d5d4:	f7fb fdc0 	bl	8009158 <AllocateSuites>
 800d5d8:	4603      	mov	r3, r0
 800d5da:	2b00      	cmp	r3, #0
 800d5dc:	d003      	beq.n	800d5e6 <ProcessBufferResetSuites+0x3c>
                ret = WOLFSSL_FATAL_ERROR;
 800d5de:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d5e2:	61fb      	str	r3, [r7, #28]
 800d5e4:	e0a2      	b.n	800d72c <ProcessBufferResetSuites+0x182>
            }
            else {
                /* Determine cipher suites based on what we have. */
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d5e6:	693b      	ldr	r3, [r7, #16]
 800d5e8:	6858      	ldr	r0, [r3, #4]
 800d5ea:	693b      	ldr	r3, [r7, #16]
 800d5ec:	f8d3 2178 	ldr.w	r2, [r3, #376]	@ 0x178
                    WOLFSSL_HAVE_RSA, SSL_HAVE_PSK(ssl), ssl->options.haveDH,
 800d5f0:	693b      	ldr	r3, [r7, #16]
 800d5f2:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d5f6:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800d5fa:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d5fc:	461c      	mov	r4, r3
                    ssl->options.haveECDSAsig, ssl->options.haveECC, TRUE,
 800d5fe:	693b      	ldr	r3, [r7, #16]
 800d600:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d604:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800d608:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d60a:	461d      	mov	r5, r3
                    ssl->options.haveECDSAsig, ssl->options.haveECC, TRUE,
 800d60c:	693b      	ldr	r3, [r7, #16]
 800d60e:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d612:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800d616:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d618:	461e      	mov	r6, r3
                    ssl->options.haveStaticECC,
 800d61a:	693b      	ldr	r3, [r7, #16]
 800d61c:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d620:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d624:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d626:	60bb      	str	r3, [r7, #8]
                    ssl->options.useAnon, TRUE,
 800d628:	693b      	ldr	r3, [r7, #16]
 800d62a:	f893 32d5 	ldrb.w	r3, [r3, #725]	@ 0x2d5
 800d62e:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d632:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d634:	607b      	str	r3, [r7, #4]
                    TRUE, TRUE, TRUE, ssl->options.side);
 800d636:	693b      	ldr	r3, [r7, #16]
 800d638:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800d63c:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800d640:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d642:	4619      	mov	r1, r3
 800d644:	693b      	ldr	r3, [r7, #16]
 800d646:	910b      	str	r1, [sp, #44]	@ 0x2c
 800d648:	2101      	movs	r1, #1
 800d64a:	910a      	str	r1, [sp, #40]	@ 0x28
 800d64c:	2101      	movs	r1, #1
 800d64e:	9109      	str	r1, [sp, #36]	@ 0x24
 800d650:	2101      	movs	r1, #1
 800d652:	9108      	str	r1, [sp, #32]
 800d654:	2101      	movs	r1, #1
 800d656:	9107      	str	r1, [sp, #28]
 800d658:	6879      	ldr	r1, [r7, #4]
 800d65a:	9106      	str	r1, [sp, #24]
 800d65c:	68b9      	ldr	r1, [r7, #8]
 800d65e:	9105      	str	r1, [sp, #20]
 800d660:	2101      	movs	r1, #1
 800d662:	9104      	str	r1, [sp, #16]
 800d664:	9603      	str	r6, [sp, #12]
 800d666:	9502      	str	r5, [sp, #8]
 800d668:	9401      	str	r4, [sp, #4]
 800d66a:	2100      	movs	r1, #0
 800d66c:	9100      	str	r1, [sp, #0]
 800d66e:	f8b3 31da 	ldrh.w	r3, [r3, #474]	@ 0x1da
 800d672:	2100      	movs	r1, #0
 800d674:	f363 010f 	bfi	r1, r3, #0, #16
 800d678:	2301      	movs	r3, #1
 800d67a:	f7fb fda4 	bl	80091c6 <InitSuites>
 800d67e:	e055      	b.n	800d72c <ProcessBufferResetSuites+0x182>
            }
        }
    }
    /* Reset suites of SSL context object. */
    else if ((type == CERT_TYPE) && (ctx->method->side == WOLFSSL_SERVER_END)) {
 800d680:	68fb      	ldr	r3, [r7, #12]
 800d682:	2b00      	cmp	r3, #0
 800d684:	d152      	bne.n	800d72c <ProcessBufferResetSuites+0x182>
 800d686:	697b      	ldr	r3, [r7, #20]
 800d688:	681b      	ldr	r3, [r3, #0]
 800d68a:	789b      	ldrb	r3, [r3, #2]
 800d68c:	2b00      	cmp	r3, #0
 800d68e:	d14d      	bne.n	800d72c <ProcessBufferResetSuites+0x182>
        /* Allocate memory for suites. */
        if (AllocateCtxSuites(ctx) != 0) {
 800d690:	6978      	ldr	r0, [r7, #20]
 800d692:	f7fb fd3e 	bl	8009112 <AllocateCtxSuites>
 800d696:	4603      	mov	r3, r0
 800d698:	2b00      	cmp	r3, #0
 800d69a:	d003      	beq.n	800d6a4 <ProcessBufferResetSuites+0xfa>
            ret = WOLFSSL_FATAL_ERROR;
 800d69c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d6a0:	61fb      	str	r3, [r7, #28]
 800d6a2:	e043      	b.n	800d72c <ProcessBufferResetSuites+0x182>
        }
        else {
            /* Determine cipher suites based on what we have. */
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d6a4:	697b      	ldr	r3, [r7, #20]
 800d6a6:	6d58      	ldr	r0, [r3, #84]	@ 0x54
 800d6a8:	697b      	ldr	r3, [r7, #20]
 800d6aa:	681b      	ldr	r3, [r3, #0]
 800d6ac:	697a      	ldr	r2, [r7, #20]
 800d6ae:	6c94      	ldr	r4, [r2, #72]	@ 0x48
                WOLFSSL_HAVE_RSA, CTX_HAVE_PSK(ctx), ctx->haveDH,
 800d6b0:	697a      	ldr	r2, [r7, #20]
 800d6b2:	f892 205e 	ldrb.w	r2, [r2, #94]	@ 0x5e
 800d6b6:	f3c2 1200 	ubfx	r2, r2, #4, #1
 800d6ba:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d6bc:	4611      	mov	r1, r2
                ctx->haveECDSAsig, ctx->haveECC, TRUE, ctx->haveStaticECC,
 800d6be:	697a      	ldr	r2, [r7, #20]
 800d6c0:	f892 205e 	ldrb.w	r2, [r2, #94]	@ 0x5e
 800d6c4:	f3c2 1240 	ubfx	r2, r2, #5, #1
 800d6c8:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d6ca:	4615      	mov	r5, r2
                ctx->haveECDSAsig, ctx->haveECC, TRUE, ctx->haveStaticECC,
 800d6cc:	697a      	ldr	r2, [r7, #20]
 800d6ce:	f892 205e 	ldrb.w	r2, [r2, #94]	@ 0x5e
 800d6d2:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 800d6d6:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d6d8:	4616      	mov	r6, r2
                ctx->haveECDSAsig, ctx->haveECC, TRUE, ctx->haveStaticECC,
 800d6da:	697a      	ldr	r2, [r7, #20]
 800d6dc:	f892 205f 	ldrb.w	r2, [r2, #95]	@ 0x5f
 800d6e0:	f3c2 0200 	ubfx	r2, r2, #0, #1
 800d6e4:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d6e6:	60ba      	str	r2, [r7, #8]
                CTX_USE_ANON(ctx),
                TRUE, TRUE, TRUE, TRUE, ctx->method->side);
 800d6e8:	697a      	ldr	r2, [r7, #20]
 800d6ea:	6812      	ldr	r2, [r2, #0]
 800d6ec:	7892      	ldrb	r2, [r2, #2]
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d6ee:	920b      	str	r2, [sp, #44]	@ 0x2c
 800d6f0:	2201      	movs	r2, #1
 800d6f2:	920a      	str	r2, [sp, #40]	@ 0x28
 800d6f4:	2201      	movs	r2, #1
 800d6f6:	9209      	str	r2, [sp, #36]	@ 0x24
 800d6f8:	2201      	movs	r2, #1
 800d6fa:	9208      	str	r2, [sp, #32]
 800d6fc:	2201      	movs	r2, #1
 800d6fe:	9207      	str	r2, [sp, #28]
 800d700:	2200      	movs	r2, #0
 800d702:	9206      	str	r2, [sp, #24]
 800d704:	68ba      	ldr	r2, [r7, #8]
 800d706:	9205      	str	r2, [sp, #20]
 800d708:	2201      	movs	r2, #1
 800d70a:	9204      	str	r2, [sp, #16]
 800d70c:	9603      	str	r6, [sp, #12]
 800d70e:	9502      	str	r5, [sp, #8]
 800d710:	9101      	str	r1, [sp, #4]
 800d712:	2200      	movs	r2, #0
 800d714:	9200      	str	r2, [sp, #0]
 800d716:	781a      	ldrb	r2, [r3, #0]
 800d718:	785b      	ldrb	r3, [r3, #1]
 800d71a:	021b      	lsls	r3, r3, #8
 800d71c:	4313      	orrs	r3, r2
 800d71e:	2100      	movs	r1, #0
 800d720:	f363 010f 	bfi	r1, r3, #0, #16
 800d724:	2301      	movs	r3, #1
 800d726:	4622      	mov	r2, r4
 800d728:	f7fb fd4d 	bl	80091c6 <InitSuites>
        }
    }

    return ret;
 800d72c:	69fb      	ldr	r3, [r7, #28]
}
 800d72e:	4618      	mov	r0, r3
 800d730:	3724      	adds	r7, #36	@ 0x24
 800d732:	46bd      	mov	sp, r7
 800d734:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0800d738 <ProcessBuffer>:
 * @return  1 on success.
 * @return  Less than 1 on failure.
 */
int ProcessBuffer(WOLFSSL_CTX* ctx, const unsigned char* buff, long sz,
    int format, int type, WOLFSSL* ssl, long* used, int userChain, int verify)
{
 800d738:	b580      	push	{r7, lr}
 800d73a:	b094      	sub	sp, #80	@ 0x50
 800d73c:	af06      	add	r7, sp, #24
 800d73e:	60f8      	str	r0, [r7, #12]
 800d740:	60b9      	str	r1, [r7, #8]
 800d742:	607a      	str	r2, [r7, #4]
 800d744:	603b      	str	r3, [r7, #0]
    DerBuffer*    der = NULL;
 800d746:	2300      	movs	r3, #0
 800d748:	61bb      	str	r3, [r7, #24]
    int           ret = 0;
 800d74a:	2300      	movs	r3, #0
 800d74c:	637b      	str	r3, [r7, #52]	@ 0x34
    void*         heap = WOLFSSL_HEAP(ctx, ssl);
 800d74e:	68fb      	ldr	r3, [r7, #12]
 800d750:	2b00      	cmp	r3, #0
 800d752:	d002      	beq.n	800d75a <ProcessBuffer+0x22>
 800d754:	68fb      	ldr	r3, [r7, #12]
 800d756:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800d758:	e007      	b.n	800d76a <ProcessBuffer+0x32>
 800d75a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d75c:	2b00      	cmp	r3, #0
 800d75e:	d003      	beq.n	800d768 <ProcessBuffer+0x30>
 800d760:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d762:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d766:	e000      	b.n	800d76a <ProcessBuffer+0x32>
 800d768:	2300      	movs	r3, #0
 800d76a:	62fb      	str	r3, [r7, #44]	@ 0x2c
#ifdef WOLFSSL_SMALL_STACK
    EncryptedInfo* info = NULL;
 800d76c:	2300      	movs	r3, #0
 800d76e:	633b      	str	r3, [r7, #48]	@ 0x30
#else
    EncryptedInfo  info[1];
#endif
    int           algId = 0;
 800d770:	2300      	movs	r3, #0
 800d772:	617b      	str	r3, [r7, #20]

    WOLFSSL_ENTER("ProcessBuffer");

    /* Check data format is supported. */
    if ((format != WOLFSSL_FILETYPE_ASN1) && (format != WOLFSSL_FILETYPE_PEM)) {
 800d774:	683b      	ldr	r3, [r7, #0]
 800d776:	2b02      	cmp	r3, #2
 800d778:	d004      	beq.n	800d784 <ProcessBuffer+0x4c>
 800d77a:	683b      	ldr	r3, [r7, #0]
 800d77c:	2b01      	cmp	r3, #1
 800d77e:	d001      	beq.n	800d784 <ProcessBuffer+0x4c>
        ret = WOLFSSL_BAD_FILETYPE;
 800d780:	4b77      	ldr	r3, [pc, #476]	@ (800d960 <ProcessBuffer+0x228>)
 800d782:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Need an object to store certificate into. */
    if ((ret == 0) && (ctx == NULL) && (ssl == NULL)) {
 800d784:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d786:	2b00      	cmp	r3, #0
 800d788:	d108      	bne.n	800d79c <ProcessBuffer+0x64>
 800d78a:	68fb      	ldr	r3, [r7, #12]
 800d78c:	2b00      	cmp	r3, #0
 800d78e:	d105      	bne.n	800d79c <ProcessBuffer+0x64>
 800d790:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d792:	2b00      	cmp	r3, #0
 800d794:	d102      	bne.n	800d79c <ProcessBuffer+0x64>
        ret = BAD_FUNC_ARG;
 800d796:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800d79a:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* CA certificates go into the SSL context object. */
    if ((ret == 0) && (ctx == NULL) && (type == CA_TYPE)) {
 800d79c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d79e:	2b00      	cmp	r3, #0
 800d7a0:	d108      	bne.n	800d7b4 <ProcessBuffer+0x7c>
 800d7a2:	68fb      	ldr	r3, [r7, #12]
 800d7a4:	2b00      	cmp	r3, #0
 800d7a6:	d105      	bne.n	800d7b4 <ProcessBuffer+0x7c>
 800d7a8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d7aa:	2b06      	cmp	r3, #6
 800d7ac:	d102      	bne.n	800d7b4 <ProcessBuffer+0x7c>
        ret = BAD_FUNC_ARG;
 800d7ae:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800d7b2:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* This API does not handle CHAIN_CERT_TYPE */
    if ((ret == 0) && (type == CHAIN_CERT_TYPE)) {
 800d7b4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d7b6:	2b00      	cmp	r3, #0
 800d7b8:	d105      	bne.n	800d7c6 <ProcessBuffer+0x8e>
 800d7ba:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d7bc:	2b2a      	cmp	r3, #42	@ 0x2a
 800d7be:	d102      	bne.n	800d7c6 <ProcessBuffer+0x8e>
        ret = BAD_FUNC_ARG;
 800d7c0:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800d7c4:	637b      	str	r3, [r7, #52]	@ 0x34
    }

#ifdef WOLFSSL_SMALL_STACK
    if (ret == 0) {
 800d7c6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d7c8:	2b00      	cmp	r3, #0
 800d7ca:	d109      	bne.n	800d7e0 <ProcessBuffer+0xa8>
        /* Allocate memory for encryption information. */
        info = (EncryptedInfo*)XMALLOC(sizeof(EncryptedInfo), heap,
 800d7cc:	208c      	movs	r0, #140	@ 0x8c
 800d7ce:	f011 fa55 	bl	801ec7c <wolfSSL_Malloc>
 800d7d2:	6338      	str	r0, [r7, #48]	@ 0x30
            DYNAMIC_TYPE_ENCRYPTEDINFO);
        if (info == NULL) {
 800d7d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d7d6:	2b00      	cmp	r3, #0
 800d7d8:	d102      	bne.n	800d7e0 <ProcessBuffer+0xa8>
            ret = MEMORY_E;
 800d7da:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800d7de:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }
#endif
    if (ret == 0) {
 800d7e0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d7e2:	2b00      	cmp	r3, #0
 800d7e4:	d127      	bne.n	800d836 <ProcessBuffer+0xfe>
        /* Initialize encryption information. */
        XMEMSET(info, 0, sizeof(EncryptedInfo));
 800d7e6:	228c      	movs	r2, #140	@ 0x8c
 800d7e8:	2100      	movs	r1, #0
 800d7ea:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800d7ec:	f01b fa1a 	bl	8028c24 <memset>
            info->passwd_userdata = ctx->passwd_userdata;
        }
    #endif

        /* Get the DER data for a private key or certificate. */
        ret = DataToDerBuffer(buff, (word32)sz, format, type, info, heap, &der,
 800d7f0:	6879      	ldr	r1, [r7, #4]
 800d7f2:	f107 0314 	add.w	r3, r7, #20
 800d7f6:	9303      	str	r3, [sp, #12]
 800d7f8:	f107 0318 	add.w	r3, r7, #24
 800d7fc:	9302      	str	r3, [sp, #8]
 800d7fe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d800:	9301      	str	r3, [sp, #4]
 800d802:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d804:	9300      	str	r3, [sp, #0]
 800d806:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d808:	683a      	ldr	r2, [r7, #0]
 800d80a:	68b8      	ldr	r0, [r7, #8]
 800d80c:	f7ff f8c8 	bl	800c9a0 <DataToDerBuffer>
 800d810:	6378      	str	r0, [r7, #52]	@ 0x34
            &algId);
        if (used != NULL) {
 800d812:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800d814:	2b00      	cmp	r3, #0
 800d816:	d003      	beq.n	800d820 <ProcessBuffer+0xe8>
            /* Update to amount used/consumed. */
            *used = info->consumed;
 800d818:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d81a:	681a      	ldr	r2, [r3, #0]
 800d81c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800d81e:	601a      	str	r2, [r3, #0]
        }
    #ifdef WOLFSSL_SMALL_STACK
        if (ret != 0) {
 800d820:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d822:	2b00      	cmp	r3, #0
 800d824:	d007      	beq.n	800d836 <ProcessBuffer+0xfe>
             /* Info no longer needed as loading failed. */
             XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d826:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d828:	62bb      	str	r3, [r7, #40]	@ 0x28
 800d82a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d82c:	2b00      	cmp	r3, #0
 800d82e:	d002      	beq.n	800d836 <ProcessBuffer+0xfe>
 800d830:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800d832:	f011 fa3f 	bl	801ecb4 <wolfSSL_Free>
        }
    #endif
    }

    if ((ret == 0) && IS_PRIVKEY_TYPE(type)) {
 800d836:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d838:	2b00      	cmp	r3, #0
 800d83a:	d11a      	bne.n	800d872 <ProcessBuffer+0x13a>
 800d83c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d83e:	2b01      	cmp	r3, #1
 800d840:	d117      	bne.n	800d872 <ProcessBuffer+0x13a>
        /* Process the private key. */
        ret = ProcessBufferPrivateKey(ctx, ssl, der, format, info, heap, type,
 800d842:	69ba      	ldr	r2, [r7, #24]
 800d844:	697b      	ldr	r3, [r7, #20]
 800d846:	9303      	str	r3, [sp, #12]
 800d848:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d84a:	9302      	str	r3, [sp, #8]
 800d84c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d84e:	9301      	str	r3, [sp, #4]
 800d850:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d852:	9300      	str	r3, [sp, #0]
 800d854:	683b      	ldr	r3, [r7, #0]
 800d856:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d858:	68f8      	ldr	r0, [r7, #12]
 800d85a:	f7ff fbe3 	bl	800d024 <ProcessBufferPrivateKey>
 800d85e:	6378      	str	r0, [r7, #52]	@ 0x34
            algId);
    #ifdef WOLFSSL_SMALL_STACK
        /* Info no longer needed - keep max memory usage down. */
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d860:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d862:	627b      	str	r3, [r7, #36]	@ 0x24
 800d864:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d866:	2b00      	cmp	r3, #0
 800d868:	d058      	beq.n	800d91c <ProcessBuffer+0x1e4>
 800d86a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800d86c:	f011 fa22 	bl	801ecb4 <wolfSSL_Free>
 800d870:	e054      	b.n	800d91c <ProcessBuffer+0x1e4>
    #endif
    }
    else if (ret == 0) {
 800d872:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d874:	2b00      	cmp	r3, #0
 800d876:	d152      	bne.n	800d91e <ProcessBuffer+0x1e6>
        /* Processing a certificate. */
        if (userChain) {
 800d878:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d87a:	2b00      	cmp	r3, #0
 800d87c:	d02d      	beq.n	800d8da <ProcessBuffer+0x1a2>
            /* Take original buffer and add to user chain to send in TLS
             * handshake. */
            ret = ProcessUserChain(ctx, ssl, buff, sz, format, type, used, info,
 800d87e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800d880:	9304      	str	r3, [sp, #16]
 800d882:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d884:	9303      	str	r3, [sp, #12]
 800d886:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800d888:	9302      	str	r3, [sp, #8]
 800d88a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d88c:	9301      	str	r3, [sp, #4]
 800d88e:	683b      	ldr	r3, [r7, #0]
 800d890:	9300      	str	r3, [sp, #0]
 800d892:	687b      	ldr	r3, [r7, #4]
 800d894:	68ba      	ldr	r2, [r7, #8]
 800d896:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d898:	68f8      	ldr	r0, [r7, #12]
 800d89a:	f7ff f96c 	bl	800cb76 <ProcessUserChain>
 800d89e:	6378      	str	r0, [r7, #52]	@ 0x34
                verify);
            /* Additional chain is optional */
            if (ret == WC_NO_ERR_TRACE(ASN_NO_PEM_HEADER)) {
 800d8a0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d8a2:	f113 0fa2 	cmn.w	r3, #162	@ 0xa2
 800d8a6:	d118      	bne.n	800d8da <ProcessBuffer+0x1a2>
                unsigned long pemErr = 0;
 800d8a8:	2300      	movs	r3, #0
 800d8aa:	623b      	str	r3, [r7, #32]
                CLEAR_ASN_NO_PEM_HEADER_ERROR(pemErr);
 800d8ac:	f000 fc88 	bl	800e1c0 <wolfSSL_ERR_peek_last_error>
 800d8b0:	6238      	str	r0, [r7, #32]
 800d8b2:	6a38      	ldr	r0, [r7, #32]
 800d8b4:	f000 fa71 	bl	800dd9a <wolfSSL_ERR_GET_LIB>
 800d8b8:	4603      	mov	r3, r0
 800d8ba:	2b09      	cmp	r3, #9
 800d8bc:	d10b      	bne.n	800d8d6 <ProcessBuffer+0x19e>
 800d8be:	6a38      	ldr	r0, [r7, #32]
 800d8c0:	f000 faa2 	bl	800de08 <wolfSSL_ERR_GET_REASON>
 800d8c4:	4603      	mov	r3, r0
 800d8c6:	f240 12fb 	movw	r2, #507	@ 0x1fb
 800d8ca:	4293      	cmp	r3, r2
 800d8cc:	d103      	bne.n	800d8d6 <ProcessBuffer+0x19e>
 800d8ce:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 800d8d2:	f011 f92d 	bl	801eb30 <wc_RemoveErrorNode>
                ret = 0;
 800d8d6:	2300      	movs	r3, #0
 800d8d8:	637b      	str	r3, [r7, #52]	@ 0x34
            }
        }

    #ifdef WOLFSSL_SMALL_STACK
        /* Info no longer needed - keep max memory usage down. */
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d8da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d8dc:	61fb      	str	r3, [r7, #28]
 800d8de:	69fb      	ldr	r3, [r7, #28]
 800d8e0:	2b00      	cmp	r3, #0
 800d8e2:	d002      	beq.n	800d8ea <ProcessBuffer+0x1b2>
 800d8e4:	69f8      	ldr	r0, [r7, #28]
 800d8e6:	f011 f9e5 	bl	801ecb4 <wolfSSL_Free>
    #endif

        if (ret == 0) {
 800d8ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d8ec:	2b00      	cmp	r3, #0
 800d8ee:	d10f      	bne.n	800d910 <ProcessBuffer+0x1d8>
            /* Process the different types of certificates. */
            ret = ProcessBufferCertTypes(ctx, ssl, buff, sz, der, format, type,
 800d8f0:	69bb      	ldr	r3, [r7, #24]
 800d8f2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800d8f4:	9203      	str	r2, [sp, #12]
 800d8f6:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800d8f8:	9202      	str	r2, [sp, #8]
 800d8fa:	683a      	ldr	r2, [r7, #0]
 800d8fc:	9201      	str	r2, [sp, #4]
 800d8fe:	9300      	str	r3, [sp, #0]
 800d900:	687b      	ldr	r3, [r7, #4]
 800d902:	68ba      	ldr	r2, [r7, #8]
 800d904:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d906:	68f8      	ldr	r0, [r7, #12]
 800d908:	f7ff fe04 	bl	800d514 <ProcessBufferCertTypes>
 800d90c:	6378      	str	r0, [r7, #52]	@ 0x34
 800d90e:	e006      	b.n	800d91e <ProcessBuffer+0x1e6>
                verify);
        }
        else {
            FreeDer(&der);
 800d910:	f107 0318 	add.w	r3, r7, #24
 800d914:	4618      	mov	r0, r3
 800d916:	f00b fbe9 	bl	80190ec <FreeDer>
 800d91a:	e000      	b.n	800d91e <ProcessBuffer+0x1e6>
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d91c:	bf00      	nop
        }
    }

    /* Reset suites if this is a private key or user certificate. */
    if ((ret == 0) && ((type == PRIVATEKEY_TYPE) || (type == CERT_TYPE))) {
 800d91e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d920:	2b00      	cmp	r3, #0
 800d922:	d10b      	bne.n	800d93c <ProcessBuffer+0x204>
 800d924:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d926:	2b01      	cmp	r3, #1
 800d928:	d002      	beq.n	800d930 <ProcessBuffer+0x1f8>
 800d92a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d92c:	2b00      	cmp	r3, #0
 800d92e:	d105      	bne.n	800d93c <ProcessBuffer+0x204>
        ret = ProcessBufferResetSuites(ctx, ssl, type);
 800d930:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800d932:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d934:	68f8      	ldr	r0, [r7, #12]
 800d936:	f7ff fe38 	bl	800d5aa <ProcessBufferResetSuites>
 800d93a:	6378      	str	r0, [r7, #52]	@ 0x34
    }

    /* Convert return code. */
    if (ret == 0) {
 800d93c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d93e:	2b00      	cmp	r3, #0
 800d940:	d102      	bne.n	800d948 <ProcessBuffer+0x210>
        ret = 1;
 800d942:	2301      	movs	r3, #1
 800d944:	637b      	str	r3, [r7, #52]	@ 0x34
 800d946:	e005      	b.n	800d954 <ProcessBuffer+0x21c>
    }
    else if (ret == WC_NO_ERR_TRACE(WOLFSSL_FATAL_ERROR)) {
 800d948:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d94a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 800d94e:	d101      	bne.n	800d954 <ProcessBuffer+0x21c>
        ret = 0;
 800d950:	2300      	movs	r3, #0
 800d952:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    WOLFSSL_LEAVE("ProcessBuffer", ret);
    return ret;
 800d954:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 800d956:	4618      	mov	r0, r3
 800d958:	3738      	adds	r7, #56	@ 0x38
 800d95a:	46bd      	mov	sp, r7
 800d95c:	bd80      	pop	{r7, pc}
 800d95e:	bf00      	nop
 800d960:	fffffe32 	.word	0xfffffe32

0800d964 <ProcessChainBuffer>:
 * @return  0 on failure.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int ProcessChainBuffer(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const unsigned char* buff, long sz, int type, int verify)
{
 800d964:	b580      	push	{r7, lr}
 800d966:	b08e      	sub	sp, #56	@ 0x38
 800d968:	af06      	add	r7, sp, #24
 800d96a:	60f8      	str	r0, [r7, #12]
 800d96c:	60b9      	str	r1, [r7, #8]
 800d96e:	607a      	str	r2, [r7, #4]
 800d970:	603b      	str	r3, [r7, #0]
    int  ret    = 0;
 800d972:	2300      	movs	r3, #0
 800d974:	61fb      	str	r3, [r7, #28]
    long used   = 0;
 800d976:	2300      	movs	r3, #0
 800d978:	61bb      	str	r3, [r7, #24]
    int  gotOne = 0;
 800d97a:	2300      	movs	r3, #0
 800d97c:	617b      	str	r3, [r7, #20]

    WOLFSSL_MSG("Processing CA PEM file");
    /* Keep processing file while no errors and data to parse. */
    while ((ret >= 0) && (used < sz)) {
 800d97e:	e03c      	b.n	800d9fa <ProcessChainBuffer+0x96>
        long consumed = 0;
 800d980:	2300      	movs	r3, #0
 800d982:	613b      	str	r3, [r7, #16]

        /* Process the buffer. */
        ret = ProcessBuffer(ctx, buff + used, sz - used, WOLFSSL_FILETYPE_PEM,
 800d984:	69bb      	ldr	r3, [r7, #24]
 800d986:	687a      	ldr	r2, [r7, #4]
 800d988:	18d1      	adds	r1, r2, r3
 800d98a:	683a      	ldr	r2, [r7, #0]
 800d98c:	69bb      	ldr	r3, [r7, #24]
 800d98e:	1ad2      	subs	r2, r2, r3
 800d990:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d992:	9304      	str	r3, [sp, #16]
 800d994:	2300      	movs	r3, #0
 800d996:	9303      	str	r3, [sp, #12]
 800d998:	f107 0310 	add.w	r3, r7, #16
 800d99c:	9302      	str	r3, [sp, #8]
 800d99e:	68bb      	ldr	r3, [r7, #8]
 800d9a0:	9301      	str	r3, [sp, #4]
 800d9a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d9a4:	9300      	str	r3, [sp, #0]
 800d9a6:	2301      	movs	r3, #1
 800d9a8:	68f8      	ldr	r0, [r7, #12]
 800d9aa:	f7ff fec5 	bl	800d738 <ProcessBuffer>
 800d9ae:	61f8      	str	r0, [r7, #28]
            type, ssl, &consumed, 0, verify);
        /* Memory allocation failure is fatal. */
        if (ret == WC_NO_ERR_TRACE(MEMORY_E)) {
 800d9b0:	69fb      	ldr	r3, [r7, #28]
 800d9b2:	f113 0f7d 	cmn.w	r3, #125	@ 0x7d
 800d9b6:	d102      	bne.n	800d9be <ProcessChainBuffer+0x5a>
            gotOne = 0;
 800d9b8:	2300      	movs	r3, #0
 800d9ba:	617b      	str	r3, [r7, #20]
 800d9bc:	e019      	b.n	800d9f2 <ProcessChainBuffer+0x8e>
        }
        /* Other error parsing. */
        else if (ret < 0) {
 800d9be:	69fb      	ldr	r3, [r7, #28]
 800d9c0:	2b00      	cmp	r3, #0
 800d9c2:	da14      	bge.n	800d9ee <ProcessChainBuffer+0x8a>
                ret = 0;
            }
            else
#endif
            /* Check whether we made progress. */
            if (consumed > 0) {
 800d9c4:	693b      	ldr	r3, [r7, #16]
 800d9c6:	2b00      	cmp	r3, #0
 800d9c8:	dd13      	ble.n	800d9f2 <ProcessChainBuffer+0x8e>
                WOLFSSL_ERROR(ret);
 800d9ca:	2300      	movs	r3, #0
 800d9cc:	9300      	str	r3, [sp, #0]
 800d9ce:	4b13      	ldr	r3, [pc, #76]	@ (800da1c <ProcessChainBuffer+0xb8>)
 800d9d0:	f640 1295 	movw	r2, #2453	@ 0x995
 800d9d4:	4912      	ldr	r1, [pc, #72]	@ (800da20 <ProcessChainBuffer+0xbc>)
 800d9d6:	69f8      	ldr	r0, [r7, #28]
 800d9d8:	f011 f904 	bl	801ebe4 <WOLFSSL_ERROR_LINE>
                WOLFSSL_MSG("CA Parse failed, with progress in file.");
                WOLFSSL_MSG("Search for other certs in file");
                /* Check if we have more data to parse to recover. */
                if (used + consumed < sz) {
 800d9dc:	693a      	ldr	r2, [r7, #16]
 800d9de:	69bb      	ldr	r3, [r7, #24]
 800d9e0:	4413      	add	r3, r2
 800d9e2:	683a      	ldr	r2, [r7, #0]
 800d9e4:	429a      	cmp	r2, r3
 800d9e6:	dd04      	ble.n	800d9f2 <ProcessChainBuffer+0x8e>
                    ret = 0;
 800d9e8:	2300      	movs	r3, #0
 800d9ea:	61fb      	str	r3, [r7, #28]
 800d9ec:	e001      	b.n	800d9f2 <ProcessChainBuffer+0x8e>
            }
        }
        else {
            /* Got a certificate out. */
            WOLFSSL_MSG("   Processed a CA");
            gotOne = 1;
 800d9ee:	2301      	movs	r3, #1
 800d9f0:	617b      	str	r3, [r7, #20]
        }
        /* Update used count. */
        used += consumed;
 800d9f2:	693b      	ldr	r3, [r7, #16]
 800d9f4:	69ba      	ldr	r2, [r7, #24]
 800d9f6:	4413      	add	r3, r2
 800d9f8:	61bb      	str	r3, [r7, #24]
    while ((ret >= 0) && (used < sz)) {
 800d9fa:	69fb      	ldr	r3, [r7, #28]
 800d9fc:	2b00      	cmp	r3, #0
 800d9fe:	db03      	blt.n	800da08 <ProcessChainBuffer+0xa4>
 800da00:	69ba      	ldr	r2, [r7, #24]
 800da02:	683b      	ldr	r3, [r7, #0]
 800da04:	429a      	cmp	r2, r3
 800da06:	dbbb      	blt.n	800d980 <ProcessChainBuffer+0x1c>
    }

    /* May have other unparsable data but did we get a certificate? */
    if (gotOne) {
 800da08:	697b      	ldr	r3, [r7, #20]
 800da0a:	2b00      	cmp	r3, #0
 800da0c:	d001      	beq.n	800da12 <ProcessChainBuffer+0xae>
        WOLFSSL_MSG("Processed at least one valid CA. Other stuff OK");
        ret = 1;
 800da0e:	2301      	movs	r3, #1
 800da10:	61fb      	str	r3, [r7, #28]
    }
    return ret;
 800da12:	69fb      	ldr	r3, [r7, #28]
}
 800da14:	4618      	mov	r0, r3
 800da16:	3720      	adds	r7, #32
 800da18:	46bd      	mov	sp, r7
 800da1a:	bd80      	pop	{r7, pc}
 800da1c:	0802ad1c 	.word	0x0802ad1c
 800da20:	08032248 	.word	0x08032248

0800da24 <wolfSSL_CTX_load_verify_buffer_ex>:
 * @return  0 on failure.
 * @return  Negative on error.
 */
int wolfSSL_CTX_load_verify_buffer_ex(WOLFSSL_CTX* ctx, const unsigned char* in,
    long sz, int format, int userChain, word32 flags)
{
 800da24:	b580      	push	{r7, lr}
 800da26:	b08c      	sub	sp, #48	@ 0x30
 800da28:	af06      	add	r7, sp, #24
 800da2a:	60f8      	str	r0, [r7, #12]
 800da2c:	60b9      	str	r1, [r7, #8]
 800da2e:	607a      	str	r2, [r7, #4]
 800da30:	603b      	str	r3, [r7, #0]
    int verify;

    WOLFSSL_ENTER("wolfSSL_CTX_load_verify_buffer_ex");

    /* Get setting on how to verify certificates. */
    verify = GET_VERIFY_SETTING_CTX(ctx);
 800da32:	68fb      	ldr	r3, [r7, #12]
 800da34:	2b00      	cmp	r3, #0
 800da36:	d007      	beq.n	800da48 <wolfSSL_CTX_load_verify_buffer_ex+0x24>
 800da38:	68fb      	ldr	r3, [r7, #12]
 800da3a:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
 800da3e:	f003 0302 	and.w	r3, r3, #2
 800da42:	b2db      	uxtb	r3, r3
 800da44:	2b00      	cmp	r3, #0
 800da46:	d101      	bne.n	800da4c <wolfSSL_CTX_load_verify_buffer_ex+0x28>
 800da48:	2301      	movs	r3, #1
 800da4a:	e000      	b.n	800da4e <wolfSSL_CTX_load_verify_buffer_ex+0x2a>
 800da4c:	2300      	movs	r3, #0
 800da4e:	613b      	str	r3, [r7, #16]
    /* Overwrite setting when flag set. */
    if (flags & WOLFSSL_LOAD_FLAG_DATE_ERR_OKAY) {
 800da50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800da52:	f003 0302 	and.w	r3, r3, #2
 800da56:	2b00      	cmp	r3, #0
 800da58:	d001      	beq.n	800da5e <wolfSSL_CTX_load_verify_buffer_ex+0x3a>
        verify = VERIFY_SKIP_DATE;
 800da5a:	2305      	movs	r3, #5
 800da5c:	613b      	str	r3, [r7, #16]
    }

    /* When PEM, treat as certificate chain of CA certificates. */
    if (format == WOLFSSL_FILETYPE_PEM) {
 800da5e:	683b      	ldr	r3, [r7, #0]
 800da60:	2b01      	cmp	r3, #1
 800da62:	d10b      	bne.n	800da7c <wolfSSL_CTX_load_verify_buffer_ex+0x58>
        ret = ProcessChainBuffer(ctx, NULL, in, sz, CA_TYPE, verify);
 800da64:	693b      	ldr	r3, [r7, #16]
 800da66:	9301      	str	r3, [sp, #4]
 800da68:	2306      	movs	r3, #6
 800da6a:	9300      	str	r3, [sp, #0]
 800da6c:	687b      	ldr	r3, [r7, #4]
 800da6e:	68ba      	ldr	r2, [r7, #8]
 800da70:	2100      	movs	r1, #0
 800da72:	68f8      	ldr	r0, [r7, #12]
 800da74:	f7ff ff76 	bl	800d964 <ProcessChainBuffer>
 800da78:	6178      	str	r0, [r7, #20]
 800da7a:	e010      	b.n	800da9e <wolfSSL_CTX_load_verify_buffer_ex+0x7a>
    }
    /* When DER, load the CA certificate. */
    else {
        ret = ProcessBuffer(ctx, in, sz, format, CA_TYPE, NULL, NULL,
 800da7c:	693b      	ldr	r3, [r7, #16]
 800da7e:	9304      	str	r3, [sp, #16]
 800da80:	6a3b      	ldr	r3, [r7, #32]
 800da82:	9303      	str	r3, [sp, #12]
 800da84:	2300      	movs	r3, #0
 800da86:	9302      	str	r3, [sp, #8]
 800da88:	2300      	movs	r3, #0
 800da8a:	9301      	str	r3, [sp, #4]
 800da8c:	2306      	movs	r3, #6
 800da8e:	9300      	str	r3, [sp, #0]
 800da90:	683b      	ldr	r3, [r7, #0]
 800da92:	687a      	ldr	r2, [r7, #4]
 800da94:	68b9      	ldr	r1, [r7, #8]
 800da96:	68f8      	ldr	r0, [r7, #12]
 800da98:	f7ff fe4e 	bl	800d738 <ProcessBuffer>
 800da9c:	6178      	str	r0, [r7, #20]
        ret = wolfSSL_CTX_trust_peer_buffer(ctx, in, sz, format);
    }
#endif

    WOLFSSL_LEAVE("wolfSSL_CTX_load_verify_buffer_ex", ret);
    return ret;
 800da9e:	697b      	ldr	r3, [r7, #20]
}
 800daa0:	4618      	mov	r0, r3
 800daa2:	3718      	adds	r7, #24
 800daa4:	46bd      	mov	sp, r7
 800daa6:	bd80      	pop	{r7, pc}

0800daa8 <wolfSSL_CTX_load_verify_buffer>:
 * @return  0 on failure.
 * @return  Negative on error.
 */
int wolfSSL_CTX_load_verify_buffer(WOLFSSL_CTX* ctx, const unsigned char* in,
    long sz, int format)
{
 800daa8:	b580      	push	{r7, lr}
 800daaa:	b086      	sub	sp, #24
 800daac:	af02      	add	r7, sp, #8
 800daae:	60f8      	str	r0, [r7, #12]
 800dab0:	60b9      	str	r1, [r7, #8]
 800dab2:	607a      	str	r2, [r7, #4]
 800dab4:	603b      	str	r3, [r7, #0]
    return wolfSSL_CTX_load_verify_buffer_ex(ctx, in, sz, format, 0,
 800dab6:	2300      	movs	r3, #0
 800dab8:	9301      	str	r3, [sp, #4]
 800daba:	2300      	movs	r3, #0
 800dabc:	9300      	str	r3, [sp, #0]
 800dabe:	683b      	ldr	r3, [r7, #0]
 800dac0:	687a      	ldr	r2, [r7, #4]
 800dac2:	68b9      	ldr	r1, [r7, #8]
 800dac4:	68f8      	ldr	r0, [r7, #12]
 800dac6:	f7ff ffad 	bl	800da24 <wolfSSL_CTX_load_verify_buffer_ex>
 800daca:	4603      	mov	r3, r0
        WOLFSSL_LOAD_VERIFY_DEFAULT_FLAGS);
}
 800dacc:	4618      	mov	r0, r3
 800dace:	3710      	adds	r7, #16
 800dad0:	46bd      	mov	sp, r7
 800dad2:	bd80      	pop	{r7, pc}

0800dad4 <wolfSSL_Cleanup>:

#endif /* NO_HANDSHAKE_DONE_CB */

WOLFSSL_ABI
int wolfSSL_Cleanup(void)
{
 800dad4:	b580      	push	{r7, lr}
 800dad6:	b082      	sub	sp, #8
 800dad8:	af00      	add	r7, sp, #0
    int ret = WOLFSSL_SUCCESS; /* Only the first error will be returned */
 800dada:	2301      	movs	r3, #1
 800dadc:	607b      	str	r3, [r7, #4]
    int release = 0;
 800dade:	2300      	movs	r3, #0
 800dae0:	603b      	str	r3, [r7, #0]
#endif

    WOLFSSL_ENTER("wolfSSL_Cleanup");

#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (inits_count_mutex_valid == 1) {
 800dae2:	4b35      	ldr	r3, [pc, #212]	@ (800dbb8 <wolfSSL_Cleanup+0xe4>)
 800dae4:	681b      	ldr	r3, [r3, #0]
 800dae6:	2b01      	cmp	r3, #1
 800dae8:	d108      	bne.n	800dafc <wolfSSL_Cleanup+0x28>
#endif
        if (wc_LockMutex(&inits_count_mutex) != 0) {
 800daea:	4834      	ldr	r0, [pc, #208]	@ (800dbbc <wolfSSL_Cleanup+0xe8>)
 800daec:	f019 fe00 	bl	80276f0 <wc_LockMutex>
 800daf0:	4603      	mov	r3, r0
 800daf2:	2b00      	cmp	r3, #0
 800daf4:	d002      	beq.n	800dafc <wolfSSL_Cleanup+0x28>
            WOLFSSL_MSG("Bad Lock Mutex count");
            return BAD_MUTEX_E;
 800daf6:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800dafa:	e058      	b.n	800dbae <wolfSSL_Cleanup+0xda>
        }
#ifndef WOLFSSL_MUTEX_INITIALIZER
    }
#endif

    if (initRefCount > 0) {
 800dafc:	4b30      	ldr	r3, [pc, #192]	@ (800dbc0 <wolfSSL_Cleanup+0xec>)
 800dafe:	681b      	ldr	r3, [r3, #0]
 800db00:	2b00      	cmp	r3, #0
 800db02:	dd0a      	ble.n	800db1a <wolfSSL_Cleanup+0x46>
        --initRefCount;
 800db04:	4b2e      	ldr	r3, [pc, #184]	@ (800dbc0 <wolfSSL_Cleanup+0xec>)
 800db06:	681b      	ldr	r3, [r3, #0]
 800db08:	3b01      	subs	r3, #1
 800db0a:	4a2d      	ldr	r2, [pc, #180]	@ (800dbc0 <wolfSSL_Cleanup+0xec>)
 800db0c:	6013      	str	r3, [r2, #0]
        if (initRefCount == 0)
 800db0e:	4b2c      	ldr	r3, [pc, #176]	@ (800dbc0 <wolfSSL_Cleanup+0xec>)
 800db10:	681b      	ldr	r3, [r3, #0]
 800db12:	2b00      	cmp	r3, #0
 800db14:	d101      	bne.n	800db1a <wolfSSL_Cleanup+0x46>
            release = 1;
 800db16:	2301      	movs	r3, #1
 800db18:	603b      	str	r3, [r7, #0]
    }

#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (inits_count_mutex_valid == 1) {
 800db1a:	4b27      	ldr	r3, [pc, #156]	@ (800dbb8 <wolfSSL_Cleanup+0xe4>)
 800db1c:	681b      	ldr	r3, [r3, #0]
 800db1e:	2b01      	cmp	r3, #1
 800db20:	d102      	bne.n	800db28 <wolfSSL_Cleanup+0x54>
#endif
        wc_UnLockMutex(&inits_count_mutex);
 800db22:	4826      	ldr	r0, [pc, #152]	@ (800dbbc <wolfSSL_Cleanup+0xe8>)
 800db24:	f019 fdef 	bl	8027706 <wc_UnLockMutex>
#ifndef WOLFSSL_MUTEX_INITIALIZER
    }
#endif

    if (!release)
 800db28:	683b      	ldr	r3, [r7, #0]
 800db2a:	2b00      	cmp	r3, #0
 800db2c:	d101      	bne.n	800db32 <wolfSSL_Cleanup+0x5e>
        return ret;
 800db2e:	687b      	ldr	r3, [r7, #4]
 800db30:	e03d      	b.n	800dbae <wolfSSL_Cleanup+0xda>
#if defined(WOLFSSL_SYS_CRYPTO_POLICY)
    wolfSSL_crypto_policy_disable();
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

#ifdef OPENSSL_EXTRA
    wolfSSL_BN_free_one();
 800db32:	f7fd ffb7 	bl	800baa4 <wolfSSL_BN_free_one>
    #endif
#endif /* !NO_SESSION_CACHE */

#if !defined(WOLFSSL_MUTEX_INITIALIZER) && \
      !WOLFSSL_CLEANUP_THREADSAFE_BY_ATOMIC_OPS
    if ((inits_count_mutex_valid == 1) &&
 800db36:	4b20      	ldr	r3, [pc, #128]	@ (800dbb8 <wolfSSL_Cleanup+0xe4>)
 800db38:	681b      	ldr	r3, [r3, #0]
 800db3a:	2b01      	cmp	r3, #1
 800db3c:	d10b      	bne.n	800db56 <wolfSSL_Cleanup+0x82>
            (wc_FreeMutex(&inits_count_mutex) != 0)) {
 800db3e:	481f      	ldr	r0, [pc, #124]	@ (800dbbc <wolfSSL_Cleanup+0xe8>)
 800db40:	f019 fdcb 	bl	80276da <wc_FreeMutex>
 800db44:	4603      	mov	r3, r0
    if ((inits_count_mutex_valid == 1) &&
 800db46:	2b00      	cmp	r3, #0
 800db48:	d005      	beq.n	800db56 <wolfSSL_Cleanup+0x82>
        if (ret == WOLFSSL_SUCCESS)
 800db4a:	687b      	ldr	r3, [r7, #4]
 800db4c:	2b01      	cmp	r3, #1
 800db4e:	d102      	bne.n	800db56 <wolfSSL_Cleanup+0x82>
            ret = BAD_MUTEX_E;
 800db50:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800db54:	607b      	str	r3, [r7, #4]
    }
    inits_count_mutex_valid = 0;
 800db56:	4b18      	ldr	r3, [pc, #96]	@ (800dbb8 <wolfSSL_Cleanup+0xe4>)
 800db58:	2200      	movs	r2, #0
 800db5a:	601a      	str	r2, [r3, #0]
#endif

#ifdef OPENSSL_EXTRA
    wolfSSL_RAND_Cleanup();
 800db5c:	f001 fa54 	bl	800f008 <wolfSSL_RAND_Cleanup>
#endif

    if (wolfCrypt_Cleanup() != 0) {
 800db60:	f019 fd4c 	bl	80275fc <wolfCrypt_Cleanup>
 800db64:	4603      	mov	r3, r0
 800db66:	2b00      	cmp	r3, #0
 800db68:	d005      	beq.n	800db76 <wolfSSL_Cleanup+0xa2>
        WOLFSSL_MSG("Error with wolfCrypt_Cleanup call");
        if (ret == WOLFSSL_SUCCESS)
 800db6a:	687b      	ldr	r3, [r7, #4]
 800db6c:	2b01      	cmp	r3, #1
 800db6e:	d102      	bne.n	800db76 <wolfSSL_Cleanup+0xa2>
            ret = WC_CLEANUP_E;
 800db70:	f06f 03f0 	mvn.w	r3, #240	@ 0xf0
 800db74:	607b      	str	r3, [r7, #4]
    }
#endif

#ifdef HAVE_GLOBAL_RNG
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if ((globalRNGMutex_valid == 1) && (wc_FreeMutex(&globalRNGMutex) != 0)) {
 800db76:	4b13      	ldr	r3, [pc, #76]	@ (800dbc4 <wolfSSL_Cleanup+0xf0>)
 800db78:	681b      	ldr	r3, [r3, #0]
 800db7a:	2b01      	cmp	r3, #1
 800db7c:	d10b      	bne.n	800db96 <wolfSSL_Cleanup+0xc2>
 800db7e:	4812      	ldr	r0, [pc, #72]	@ (800dbc8 <wolfSSL_Cleanup+0xf4>)
 800db80:	f019 fdab 	bl	80276da <wc_FreeMutex>
 800db84:	4603      	mov	r3, r0
 800db86:	2b00      	cmp	r3, #0
 800db88:	d005      	beq.n	800db96 <wolfSSL_Cleanup+0xc2>
        if (ret == WOLFSSL_SUCCESS)
 800db8a:	687b      	ldr	r3, [r7, #4]
 800db8c:	2b01      	cmp	r3, #1
 800db8e:	d102      	bne.n	800db96 <wolfSSL_Cleanup+0xc2>
            ret = BAD_MUTEX_E;
 800db90:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800db94:	607b      	str	r3, [r7, #4]
    }
    globalRNGMutex_valid = 0;
 800db96:	4b0b      	ldr	r3, [pc, #44]	@ (800dbc4 <wolfSSL_Cleanup+0xf0>)
 800db98:	2200      	movs	r2, #0
 800db9a:	601a      	str	r2, [r3, #0]
#endif /* !WOLFSSL_MUTEX_INITIALIZER */

    #if defined(OPENSSL_EXTRA) && defined(HAVE_HASHDRBG)
    wolfSSL_FIPS_drbg_free(gDrbgDefCtx);
 800db9c:	4b0b      	ldr	r3, [pc, #44]	@ (800dbcc <wolfSSL_Cleanup+0xf8>)
 800db9e:	681b      	ldr	r3, [r3, #0]
 800dba0:	4618      	mov	r0, r3
 800dba2:	f001 fbdb 	bl	800f35c <wolfSSL_FIPS_drbg_free>
    gDrbgDefCtx = NULL;
 800dba6:	4b09      	ldr	r3, [pc, #36]	@ (800dbcc <wolfSSL_Cleanup+0xf8>)
 800dba8:	2200      	movs	r2, #0
 800dbaa:	601a      	str	r2, [r3, #0]

#ifdef WOLFSSL_MEM_FAIL_COUNT
    wc_MemFailCount_Free();
#endif

    return ret;
 800dbac:	687b      	ldr	r3, [r7, #4]
}
 800dbae:	4618      	mov	r0, r3
 800dbb0:	3708      	adds	r7, #8
 800dbb2:	46bd      	mov	sp, r7
 800dbb4:	bd80      	pop	{r7, pc}
 800dbb6:	bf00      	nop
 800dbb8:	20001c28 	.word	0x20001c28
 800dbbc:	20001c24 	.word	0x20001c24
 800dbc0:	20001c20 	.word	0x20001c20
 800dbc4:	20001c08 	.word	0x20001c08
 800dbc8:	20001c04 	.word	0x20001c04
 800dbcc:	20001c0c 	.word	0x20001c0c

0800dbd0 <wolfSSL_UnloadCertsKeys>:
#ifndef NO_CERTS

    /* unload any certs or keys that SSL owns, leave CTX as is
       WOLFSSL_SUCCESS on ok */
    int wolfSSL_UnloadCertsKeys(WOLFSSL* ssl)
    {
 800dbd0:	b580      	push	{r7, lr}
 800dbd2:	b082      	sub	sp, #8
 800dbd4:	af00      	add	r7, sp, #0
 800dbd6:	6078      	str	r0, [r7, #4]
        if (ssl == NULL) {
 800dbd8:	687b      	ldr	r3, [r7, #4]
 800dbda:	2b00      	cmp	r3, #0
 800dbdc:	d102      	bne.n	800dbe4 <wolfSSL_UnloadCertsKeys+0x14>
            WOLFSSL_MSG("Null function arg");
            return BAD_FUNC_ARG;
 800dbde:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800dbe2:	e040      	b.n	800dc66 <wolfSSL_UnloadCertsKeys+0x96>
        }

        if (ssl->buffers.weOwnCert && !ssl->keepCert) {
 800dbe4:	687b      	ldr	r3, [r7, #4]
 800dbe6:	f893 3144 	ldrb.w	r3, [r3, #324]	@ 0x144
 800dbea:	2b00      	cmp	r3, #0
 800dbec:	d010      	beq.n	800dc10 <wolfSSL_UnloadCertsKeys+0x40>
 800dbee:	687b      	ldr	r3, [r7, #4]
 800dbf0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800dbf4:	f893 3090 	ldrb.w	r3, [r3, #144]	@ 0x90
 800dbf8:	2b00      	cmp	r3, #0
 800dbfa:	d109      	bne.n	800dc10 <wolfSSL_UnloadCertsKeys+0x40>
            WOLFSSL_MSG("Unloading cert");
            FreeDer(&ssl->buffers.certificate);
 800dbfc:	687b      	ldr	r3, [r7, #4]
 800dbfe:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 800dc02:	4618      	mov	r0, r3
 800dc04:	f00b fa72 	bl	80190ec <FreeDer>
            #ifdef KEEP_OUR_CERT
            wolfSSL_X509_free(ssl->ourCert);
            ssl->ourCert = NULL;
            #endif
            ssl->buffers.weOwnCert = 0;
 800dc08:	687b      	ldr	r3, [r7, #4]
 800dc0a:	2200      	movs	r2, #0
 800dc0c:	f883 2144 	strb.w	r2, [r3, #324]	@ 0x144
        }

        if (ssl->buffers.weOwnCertChain) {
 800dc10:	687b      	ldr	r3, [r7, #4]
 800dc12:	f893 3145 	ldrb.w	r3, [r3, #325]	@ 0x145
 800dc16:	2b00      	cmp	r3, #0
 800dc18:	d009      	beq.n	800dc2e <wolfSSL_UnloadCertsKeys+0x5e>
            WOLFSSL_MSG("Unloading cert chain");
            FreeDer(&ssl->buffers.certChain);
 800dc1a:	687b      	ldr	r3, [r7, #4]
 800dc1c:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 800dc20:	4618      	mov	r0, r3
 800dc22:	f00b fa63 	bl	80190ec <FreeDer>
            ssl->buffers.weOwnCertChain = 0;
 800dc26:	687b      	ldr	r3, [r7, #4]
 800dc28:	2200      	movs	r2, #0
 800dc2a:	f883 2145 	strb.w	r2, [r3, #325]	@ 0x145
        }

        if (ssl->buffers.weOwnKey) {
 800dc2e:	687b      	ldr	r3, [r7, #4]
 800dc30:	f893 3146 	ldrb.w	r3, [r3, #326]	@ 0x146
 800dc34:	2b00      	cmp	r3, #0
 800dc36:	d015      	beq.n	800dc64 <wolfSSL_UnloadCertsKeys+0x94>
            WOLFSSL_MSG("Unloading key");
            ForceZero(ssl->buffers.key->buffer, ssl->buffers.key->length);
 800dc38:	687b      	ldr	r3, [r7, #4]
 800dc3a:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 800dc3e:	681a      	ldr	r2, [r3, #0]
 800dc40:	687b      	ldr	r3, [r7, #4]
 800dc42:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 800dc46:	689b      	ldr	r3, [r3, #8]
 800dc48:	4619      	mov	r1, r3
 800dc4a:	4610      	mov	r0, r2
 800dc4c:	f7fd fb37 	bl	800b2be <ForceZero>
            FreeDer(&ssl->buffers.key);
 800dc50:	687b      	ldr	r3, [r7, #4]
 800dc52:	f503 73b8 	add.w	r3, r3, #368	@ 0x170
 800dc56:	4618      	mov	r0, r3
 800dc58:	f00b fa48 	bl	80190ec <FreeDer>
        #ifdef WOLFSSL_BLIND_PRIVATE_KEY
            FreeDer(&ssl->buffers.keyMask);
        #endif
            ssl->buffers.weOwnKey = 0;
 800dc5c:	687b      	ldr	r3, [r7, #4]
 800dc5e:	2200      	movs	r2, #0
 800dc60:	f883 2146 	strb.w	r2, [r3, #326]	@ 0x146
        #endif
            ssl->buffers.weOwnAltKey = 0;
        }
#endif /* WOLFSSL_DUAL_ALG_CERTS */

        return WOLFSSL_SUCCESS;
 800dc64:	2301      	movs	r3, #1
    }
 800dc66:	4618      	mov	r0, r3
 800dc68:	3708      	adds	r7, #8
 800dc6a:	46bd      	mov	sp, r7
 800dc6c:	bd80      	pop	{r7, pc}
	...

0800dc70 <wolfSSL_ERR_sys_func>:
    static const char WOLFSSL_SYS_SETSOCKOPT_T[]    = "setsockopt";
    static const char WOLFSSL_SYS_SOCKET_T[]        = "socket";

    /* switch with int mapped to function name for compatibility */
    static const char* wolfSSL_ERR_sys_func(int fun)
    {
 800dc70:	b480      	push	{r7}
 800dc72:	b083      	sub	sp, #12
 800dc74:	af00      	add	r7, sp, #0
 800dc76:	6078      	str	r0, [r7, #4]
        switch (fun) {
 800dc78:	687b      	ldr	r3, [r7, #4]
 800dc7a:	2b0f      	cmp	r3, #15
 800dc7c:	d842      	bhi.n	800dd04 <wolfSSL_ERR_sys_func+0x94>
 800dc7e:	a201      	add	r2, pc, #4	@ (adr r2, 800dc84 <wolfSSL_ERR_sys_func+0x14>)
 800dc80:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800dc84:	0800dcc5 	.word	0x0800dcc5
 800dc88:	0800dcc9 	.word	0x0800dcc9
 800dc8c:	0800dccd 	.word	0x0800dccd
 800dc90:	0800dcd1 	.word	0x0800dcd1
 800dc94:	0800dcd5 	.word	0x0800dcd5
 800dc98:	0800dcd9 	.word	0x0800dcd9
 800dc9c:	0800dcdd 	.word	0x0800dcdd
 800dca0:	0800dce1 	.word	0x0800dce1
 800dca4:	0800dce5 	.word	0x0800dce5
 800dca8:	0800dce9 	.word	0x0800dce9
 800dcac:	0800dced 	.word	0x0800dced
 800dcb0:	0800dcf1 	.word	0x0800dcf1
 800dcb4:	0800dcf5 	.word	0x0800dcf5
 800dcb8:	0800dcf9 	.word	0x0800dcf9
 800dcbc:	0800dcfd 	.word	0x0800dcfd
 800dcc0:	0800dd01 	.word	0x0800dd01
            case WOLFSSL_SYS_ACCEPT:      return WOLFSSL_SYS_ACCEPT_T;
 800dcc4:	4b13      	ldr	r3, [pc, #76]	@ (800dd14 <wolfSSL_ERR_sys_func+0xa4>)
 800dcc6:	e01e      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_BIND:        return WOLFSSL_SYS_BIND_T;
 800dcc8:	4b13      	ldr	r3, [pc, #76]	@ (800dd18 <wolfSSL_ERR_sys_func+0xa8>)
 800dcca:	e01c      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_CONNECT:     return WOLFSSL_SYS_CONNECT_T;
 800dccc:	4b13      	ldr	r3, [pc, #76]	@ (800dd1c <wolfSSL_ERR_sys_func+0xac>)
 800dcce:	e01a      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_FOPEN:       return WOLFSSL_SYS_FOPEN_T;
 800dcd0:	4b13      	ldr	r3, [pc, #76]	@ (800dd20 <wolfSSL_ERR_sys_func+0xb0>)
 800dcd2:	e018      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_FREAD:       return WOLFSSL_SYS_FREAD_T;
 800dcd4:	4b13      	ldr	r3, [pc, #76]	@ (800dd24 <wolfSSL_ERR_sys_func+0xb4>)
 800dcd6:	e016      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETADDRINFO: return WOLFSSL_SYS_GETADDRINFO_T;
 800dcd8:	4b13      	ldr	r3, [pc, #76]	@ (800dd28 <wolfSSL_ERR_sys_func+0xb8>)
 800dcda:	e014      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETSOCKOPT:  return WOLFSSL_SYS_GETSOCKOPT_T;
 800dcdc:	4b13      	ldr	r3, [pc, #76]	@ (800dd2c <wolfSSL_ERR_sys_func+0xbc>)
 800dcde:	e012      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETSOCKNAME: return WOLFSSL_SYS_GETSOCKNAME_T;
 800dce0:	4b13      	ldr	r3, [pc, #76]	@ (800dd30 <wolfSSL_ERR_sys_func+0xc0>)
 800dce2:	e010      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETHOSTBYNAME: return WOLFSSL_SYS_GETHOSTBYNAME_T;
 800dce4:	4b13      	ldr	r3, [pc, #76]	@ (800dd34 <wolfSSL_ERR_sys_func+0xc4>)
 800dce6:	e00e      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETNAMEINFO: return WOLFSSL_SYS_GETNAMEINFO_T;
 800dce8:	4b13      	ldr	r3, [pc, #76]	@ (800dd38 <wolfSSL_ERR_sys_func+0xc8>)
 800dcea:	e00c      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETSERVBYNAME: return WOLFSSL_SYS_GETSERVBYNAME_T;
 800dcec:	4b13      	ldr	r3, [pc, #76]	@ (800dd3c <wolfSSL_ERR_sys_func+0xcc>)
 800dcee:	e00a      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_IOCTLSOCKET: return WOLFSSL_SYS_IOCTLSOCKET_T;
 800dcf0:	4b13      	ldr	r3, [pc, #76]	@ (800dd40 <wolfSSL_ERR_sys_func+0xd0>)
 800dcf2:	e008      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_LISTEN:      return WOLFSSL_SYS_LISTEN_T;
 800dcf4:	4b13      	ldr	r3, [pc, #76]	@ (800dd44 <wolfSSL_ERR_sys_func+0xd4>)
 800dcf6:	e006      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_OPENDIR:     return WOLFSSL_SYS_OPENDIR_T;
 800dcf8:	4b13      	ldr	r3, [pc, #76]	@ (800dd48 <wolfSSL_ERR_sys_func+0xd8>)
 800dcfa:	e004      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_SETSOCKOPT:  return WOLFSSL_SYS_SETSOCKOPT_T;
 800dcfc:	4b13      	ldr	r3, [pc, #76]	@ (800dd4c <wolfSSL_ERR_sys_func+0xdc>)
 800dcfe:	e002      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_SOCKET:      return WOLFSSL_SYS_SOCKET_T;
 800dd00:	4b13      	ldr	r3, [pc, #76]	@ (800dd50 <wolfSSL_ERR_sys_func+0xe0>)
 800dd02:	e000      	b.n	800dd06 <wolfSSL_ERR_sys_func+0x96>
            default:
                return "NULL";
 800dd04:	4b13      	ldr	r3, [pc, #76]	@ (800dd54 <wolfSSL_ERR_sys_func+0xe4>)
        }
    }
 800dd06:	4618      	mov	r0, r3
 800dd08:	370c      	adds	r7, #12
 800dd0a:	46bd      	mov	sp, r7
 800dd0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd10:	4770      	bx	lr
 800dd12:	bf00      	nop
 800dd14:	08031b34 	.word	0x08031b34
 800dd18:	08031b3c 	.word	0x08031b3c
 800dd1c:	08031b44 	.word	0x08031b44
 800dd20:	08031b4c 	.word	0x08031b4c
 800dd24:	08031b54 	.word	0x08031b54
 800dd28:	08031b5c 	.word	0x08031b5c
 800dd2c:	08031b68 	.word	0x08031b68
 800dd30:	08031b74 	.word	0x08031b74
 800dd34:	08031b80 	.word	0x08031b80
 800dd38:	08031b90 	.word	0x08031b90
 800dd3c:	08031b9c 	.word	0x08031b9c
 800dd40:	08031bac 	.word	0x08031bac
 800dd44:	08031bb8 	.word	0x08031bb8
 800dd48:	08031bc0 	.word	0x08031bc0
 800dd4c:	08031bc8 	.word	0x08031bc8
 800dd50:	08031bd4 	.word	0x08031bd4
 800dd54:	0802adac 	.word	0x0802adac

0800dd58 <wolfSSL_ERR_put_error>:
#endif /* DEBUG_WOLFSSL */


    void wolfSSL_ERR_put_error(int lib, int fun, int err, const char* file,
            int line)
    {
 800dd58:	b580      	push	{r7, lr}
 800dd5a:	b086      	sub	sp, #24
 800dd5c:	af02      	add	r7, sp, #8
 800dd5e:	60f8      	str	r0, [r7, #12]
 800dd60:	60b9      	str	r1, [r7, #8]
 800dd62:	607a      	str	r2, [r7, #4]
 800dd64:	603b      	str	r3, [r7, #0]
        (void)fun;
        (void)file;
        (void)line;
        WOLFSSL_ERROR(err);
        #else
        WOLFSSL_ERROR_LINE(err, wolfSSL_ERR_sys_func(fun), (unsigned int)line,
 800dd66:	68b8      	ldr	r0, [r7, #8]
 800dd68:	f7ff ff82 	bl	800dc70 <wolfSSL_ERR_sys_func>
 800dd6c:	4601      	mov	r1, r0
 800dd6e:	69ba      	ldr	r2, [r7, #24]
 800dd70:	2300      	movs	r3, #0
 800dd72:	9300      	str	r3, [sp, #0]
 800dd74:	683b      	ldr	r3, [r7, #0]
 800dd76:	6878      	ldr	r0, [r7, #4]
 800dd78:	f010 ff34 	bl	801ebe4 <WOLFSSL_ERROR_LINE>
            file, NULL);
        #endif
        (void)lib;
    }
 800dd7c:	bf00      	nop
 800dd7e:	3710      	adds	r7, #16
 800dd80:	46bd      	mov	sp, r7
 800dd82:	bd80      	pop	{r7, pc}

0800dd84 <wolfSSL_sk_CIPHER_free>:
/* Free the structure for WOLFSSL_CIPHER stack
 *
 * sk  stack to free nodes in
 */
void wolfSSL_sk_CIPHER_free(WOLF_STACK_OF(WOLFSSL_CIPHER)* sk)
{
 800dd84:	b580      	push	{r7, lr}
 800dd86:	b082      	sub	sp, #8
 800dd88:	af00      	add	r7, sp, #0
 800dd8a:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_sk_CIPHER_free");

    wolfSSL_sk_free(sk);
 800dd8c:	6878      	ldr	r0, [r7, #4]
 800dd8e:	f000 f867 	bl	800de60 <wolfSSL_sk_free>
}
 800dd92:	bf00      	nop
 800dd94:	3708      	adds	r7, #8
 800dd96:	46bd      	mov	sp, r7
 800dd98:	bd80      	pop	{r7, pc}

0800dd9a <wolfSSL_ERR_GET_LIB>:
#ifdef WOLFSSL_DEBUG_TRACE_ERROR_CODES_H
#include <wolfssl/debug-untrace-error-codes.h>
#endif

int wolfSSL_ERR_GET_LIB(unsigned long err)
{
 800dd9a:	b480      	push	{r7}
 800dd9c:	b085      	sub	sp, #20
 800dd9e:	af00      	add	r7, sp, #0
 800dda0:	6078      	str	r0, [r7, #4]
    unsigned long value;

    value = (err & 0xFFFFFFL);
 800dda2:	687b      	ldr	r3, [r7, #4]
 800dda4:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 800dda8:	60fb      	str	r3, [r7, #12]
    switch (value) {
 800ddaa:	68fb      	ldr	r3, [r7, #12]
 800ddac:	f5b3 7f01 	cmp.w	r3, #516	@ 0x204
 800ddb0:	d223      	bcs.n	800ddfa <wolfSSL_ERR_GET_LIB+0x60>
 800ddb2:	68fb      	ldr	r3, [r7, #12]
 800ddb4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800ddb8:	d21b      	bcs.n	800ddf2 <wolfSSL_ERR_GET_LIB+0x58>
 800ddba:	68fb      	ldr	r3, [r7, #12]
 800ddbc:	f240 12ff 	movw	r2, #511	@ 0x1ff
 800ddc0:	4293      	cmp	r3, r2
 800ddc2:	d018      	beq.n	800ddf6 <wolfSSL_ERR_GET_LIB+0x5c>
 800ddc4:	68fb      	ldr	r3, [r7, #12]
 800ddc6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800ddca:	d216      	bcs.n	800ddfa <wolfSSL_ERR_GET_LIB+0x60>
 800ddcc:	68fb      	ldr	r3, [r7, #12]
 800ddce:	f5b3 7fff 	cmp.w	r3, #510	@ 0x1fe
 800ddd2:	d812      	bhi.n	800ddfa <wolfSSL_ERR_GET_LIB+0x60>
 800ddd4:	68fb      	ldr	r3, [r7, #12]
 800ddd6:	f5b3 7ffd 	cmp.w	r3, #506	@ 0x1fa
 800ddda:	d808      	bhi.n	800ddee <wolfSSL_ERR_GET_LIB+0x54>
 800dddc:	68fb      	ldr	r3, [r7, #12]
 800ddde:	2ba2      	cmp	r3, #162	@ 0xa2
 800dde0:	d005      	beq.n	800ddee <wolfSSL_ERR_GET_LIB+0x54>
 800dde2:	68fb      	ldr	r3, [r7, #12]
 800dde4:	f5b3 7f99 	cmp.w	r3, #306	@ 0x132
 800dde8:	d107      	bne.n	800ddfa <wolfSSL_ERR_GET_LIB+0x60>
    case -PARSE_ERROR:
        return WOLFSSL_ERR_LIB_SSL;
 800ddea:	2314      	movs	r3, #20
 800ddec:	e006      	b.n	800ddfc <wolfSSL_ERR_GET_LIB+0x62>
    case -ASN_NO_PEM_HEADER:
    case -WOLFSSL_PEM_R_NO_START_LINE_E:
    case -WOLFSSL_PEM_R_PROBLEMS_GETTING_PASSWORD_E:
    case -WOLFSSL_PEM_R_BAD_PASSWORD_READ_E:
    case -WOLFSSL_PEM_R_BAD_DECRYPT_E:
        return WOLFSSL_ERR_LIB_PEM;
 800ddee:	2309      	movs	r3, #9
 800ddf0:	e004      	b.n	800ddfc <wolfSSL_ERR_GET_LIB+0x62>
    case -WOLFSSL_EVP_R_BAD_DECRYPT_E:
    case -WOLFSSL_EVP_R_BN_DECODE_ERROR:
    case -WOLFSSL_EVP_R_DECODE_ERROR:
    case -WOLFSSL_EVP_R_PRIVATE_KEY_DECODE_ERROR:
        return WOLFSSL_ERR_LIB_EVP;
 800ddf2:	230b      	movs	r3, #11
 800ddf4:	e002      	b.n	800ddfc <wolfSSL_ERR_GET_LIB+0x62>
    case -WOLFSSL_ASN1_R_HEADER_TOO_LONG_E:
        return WOLFSSL_ERR_LIB_ASN1;
 800ddf6:	230c      	movs	r3, #12
 800ddf8:	e000      	b.n	800ddfc <wolfSSL_ERR_GET_LIB+0x62>
    default:
        return 0;
 800ddfa:	2300      	movs	r3, #0
    }
}
 800ddfc:	4618      	mov	r0, r3
 800ddfe:	3714      	adds	r7, #20
 800de00:	46bd      	mov	sp, r7
 800de02:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de06:	4770      	bx	lr

0800de08 <wolfSSL_ERR_GET_REASON>:
 * error values are typically negative.
 *
 * Returns the error reason
 */
int wolfSSL_ERR_GET_REASON(unsigned long err)
{
 800de08:	b480      	push	{r7}
 800de0a:	b085      	sub	sp, #20
 800de0c:	af00      	add	r7, sp, #0
 800de0e:	6078      	str	r0, [r7, #4]
    int ret = (int)err;
 800de10:	687b      	ldr	r3, [r7, #4]
 800de12:	60fb      	str	r3, [r7, #12]
    if (err == ((ERR_LIB_ASN1 << 24) | ASN1_R_HEADER_TOO_LONG))
        return ASN1_R_HEADER_TOO_LONG;
#endif

    /* check if error value is in range of wolfCrypt or wolfSSL errors */
    ret = 0 - ret; /* setting as negative value */
 800de14:	68fb      	ldr	r3, [r7, #12]
 800de16:	425b      	negs	r3, r3
 800de18:	60fb      	str	r3, [r7, #12]

    if ((ret <= WC_SPAN1_FIRST_E && ret >= WC_SPAN1_LAST_E) ||
 800de1a:	68fb      	ldr	r3, [r7, #12]
 800de1c:	f113 0f60 	cmn.w	r3, #96	@ 0x60
 800de20:	da03      	bge.n	800de2a <wolfSSL_ERR_GET_REASON+0x22>
 800de22:	68fb      	ldr	r3, [r7, #12]
 800de24:	f513 7f96 	cmn.w	r3, #300	@ 0x12c
 800de28:	dc0f      	bgt.n	800de4a <wolfSSL_ERR_GET_REASON+0x42>
 800de2a:	68fb      	ldr	r3, [r7, #12]
 800de2c:	f513 7f7a 	cmn.w	r3, #1000	@ 0x3e8
 800de30:	dc03      	bgt.n	800de3a <wolfSSL_ERR_GET_REASON+0x32>
        (ret <= WC_SPAN2_FIRST_E && ret >= WC_SPAN2_LAST_E) ||
 800de32:	68fb      	ldr	r3, [r7, #12]
 800de34:	f513 7f7a 	cmn.w	r3, #1000	@ 0x3e8
 800de38:	da07      	bge.n	800de4a <wolfSSL_ERR_GET_REASON+0x42>
 800de3a:	68fb      	ldr	r3, [r7, #12]
 800de3c:	f513 7f96 	cmn.w	r3, #300	@ 0x12c
 800de40:	da05      	bge.n	800de4e <wolfSSL_ERR_GET_REASON+0x46>
        (ret <= WOLFSSL_FIRST_E && ret >= WOLFSSL_LAST_E))
 800de42:	68fb      	ldr	r3, [r7, #12]
 800de44:	f513 7f01 	cmn.w	r3, #516	@ 0x204
 800de48:	db01      	blt.n	800de4e <wolfSSL_ERR_GET_REASON+0x46>
    {
        return ret;
 800de4a:	68fb      	ldr	r3, [r7, #12]
 800de4c:	e002      	b.n	800de54 <wolfSSL_ERR_GET_REASON+0x4c>
    }
    else {
        WOLFSSL_MSG("Not in range of typical error values");
        ret = (int)err;
 800de4e:	687b      	ldr	r3, [r7, #4]
 800de50:	60fb      	str	r3, [r7, #12]
    }

    return ret;
 800de52:	68fb      	ldr	r3, [r7, #12]
}
 800de54:	4618      	mov	r0, r3
 800de56:	3714      	adds	r7, #20
 800de58:	46bd      	mov	sp, r7
 800de5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de5e:	4770      	bx	lr

0800de60 <wolfSSL_sk_free>:
    return NULL;
}

/* Free the just the stack structure */
void wolfSSL_sk_free(WOLFSSL_STACK* sk)
{
 800de60:	b580      	push	{r7, lr}
 800de62:	b084      	sub	sp, #16
 800de64:	af00      	add	r7, sp, #0
 800de66:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_sk_free");

    while (sk != NULL) {
 800de68:	e00c      	b.n	800de84 <wolfSSL_sk_free+0x24>
        WOLFSSL_STACK* next = sk->next;
 800de6a:	687b      	ldr	r3, [r7, #4]
 800de6c:	691b      	ldr	r3, [r3, #16]
 800de6e:	60fb      	str	r3, [r7, #12]
        XFREE(sk, NULL, DYNAMIC_TYPE_OPENSSL);
 800de70:	687b      	ldr	r3, [r7, #4]
 800de72:	60bb      	str	r3, [r7, #8]
 800de74:	68bb      	ldr	r3, [r7, #8]
 800de76:	2b00      	cmp	r3, #0
 800de78:	d002      	beq.n	800de80 <wolfSSL_sk_free+0x20>
 800de7a:	68b8      	ldr	r0, [r7, #8]
 800de7c:	f010 ff1a 	bl	801ecb4 <wolfSSL_Free>
        sk = next;
 800de80:	68fb      	ldr	r3, [r7, #12]
 800de82:	607b      	str	r3, [r7, #4]
    while (sk != NULL) {
 800de84:	687b      	ldr	r3, [r7, #4]
 800de86:	2b00      	cmp	r3, #0
 800de88:	d1ef      	bne.n	800de6a <wolfSSL_sk_free+0xa>
    }
}
 800de8a:	bf00      	nop
 800de8c:	bf00      	nop
 800de8e:	3710      	adds	r7, #16
 800de90:	46bd      	mov	sp, r7
 800de92:	bd80      	pop	{r7, pc}

0800de94 <wolfSSL_sk_pop_free>:
}

/* Free all nodes in a stack including the pushed objects */
void wolfSSL_sk_pop_free(WOLF_STACK_OF(WOLFSSL_ASN1_OBJECT)* sk,
                                                       wolfSSL_sk_freefunc func)
{
 800de94:	b580      	push	{r7, lr}
 800de96:	b084      	sub	sp, #16
 800de98:	af00      	add	r7, sp, #0
 800de9a:	6078      	str	r0, [r7, #4]
 800de9c:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_sk_pop_free");

    if (sk == NULL) {
 800de9e:	687b      	ldr	r3, [r7, #4]
 800dea0:	2b00      	cmp	r3, #0
 800dea2:	d069      	beq.n	800df78 <wolfSSL_sk_pop_free+0xe4>
    */
    if (sk->type == STACK_TYPE_ACCESS_DESCRIPTION) {
        func = (wolfSSL_sk_freefunc)wolfSSL_ACCESS_DESCRIPTION_free;
    }
    #endif
    if (func == NULL) {
 800dea4:	683b      	ldr	r3, [r7, #0]
 800dea6:	2b00      	cmp	r3, #0
 800dea8:	d162      	bne.n	800df70 <wolfSSL_sk_pop_free+0xdc>
        switch(sk->type) {
 800deaa:	687b      	ldr	r3, [r7, #4]
 800deac:	7d1b      	ldrb	r3, [r3, #20]
 800deae:	2b12      	cmp	r3, #18
 800deb0:	d843      	bhi.n	800df3a <wolfSSL_sk_pop_free+0xa6>
 800deb2:	a201      	add	r2, pc, #4	@ (adr r2, 800deb8 <wolfSSL_sk_pop_free+0x24>)
 800deb4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800deb8:	0800df05 	.word	0x0800df05
 800debc:	0800df17 	.word	0x0800df17
 800dec0:	0800df35 	.word	0x0800df35
 800dec4:	0800df0b 	.word	0x0800df0b
 800dec8:	0800df1d 	.word	0x0800df1d
 800decc:	0800df3b 	.word	0x0800df3b
 800ded0:	0800df3b 	.word	0x0800df3b
 800ded4:	0800df2f 	.word	0x0800df2f
 800ded8:	0800df3b 	.word	0x0800df3b
 800dedc:	0800df23 	.word	0x0800df23
 800dee0:	0800df3b 	.word	0x0800df3b
 800dee4:	0800df3b 	.word	0x0800df3b
 800dee8:	0800df3b 	.word	0x0800df3b
 800deec:	0800df3b 	.word	0x0800df3b
 800def0:	0800df3b 	.word	0x0800df3b
 800def4:	0800df11 	.word	0x0800df11
 800def8:	0800df3b 	.word	0x0800df3b
 800defc:	0800df29 	.word	0x0800df29
 800df00:	0800df3b 	.word	0x0800df3b
            #if defined(OPENSSL_ALL)
                func = (wolfSSL_sk_freefunc)wolfSSL_ACCESS_DESCRIPTION_free;
            #endif
                break;
            case STACK_TYPE_X509:
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_free;
 800df04:	4b1e      	ldr	r3, [pc, #120]	@ (800df80 <wolfSSL_sk_pop_free+0xec>)
 800df06:	603b      	str	r3, [r7, #0]
                break;
 800df08:	e018      	b.n	800df3c <wolfSSL_sk_pop_free+0xa8>
            #ifdef OPENSSL_ALL
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_OBJECT_free;
            #endif
                break;
            case STACK_TYPE_OBJ:
                func = (wolfSSL_sk_freefunc)wolfSSL_ASN1_OBJECT_free;
 800df0a:	4b1e      	ldr	r3, [pc, #120]	@ (800df84 <wolfSSL_sk_pop_free+0xf0>)
 800df0c:	603b      	str	r3, [r7, #0]
                break;
 800df0e:	e015      	b.n	800df3c <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_DIST_POINT:
            #ifdef OPENSSL_EXTRA
                func = (wolfSSL_sk_freefunc)wolfSSL_DIST_POINT_free;
 800df10:	4b1d      	ldr	r3, [pc, #116]	@ (800df88 <wolfSSL_sk_pop_free+0xf4>)
 800df12:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800df14:	e012      	b.n	800df3c <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_GEN_NAME:
                func = (wolfSSL_sk_freefunc)wolfSSL_GENERAL_NAME_free;
 800df16:	4b1d      	ldr	r3, [pc, #116]	@ (800df8c <wolfSSL_sk_pop_free+0xf8>)
 800df18:	603b      	str	r3, [r7, #0]
                break;
 800df1a:	e00f      	b.n	800df3c <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_STRING:
            #if defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY) || \
                defined(OPENSSL_EXTRA) || defined(OPENSSL_ALL)
                func = (wolfSSL_sk_freefunc)wolfSSL_WOLFSSL_STRING_free;
 800df1c:	4b1c      	ldr	r3, [pc, #112]	@ (800df90 <wolfSSL_sk_pop_free+0xfc>)
 800df1e:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800df20:	e00c      	b.n	800df3c <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_X509_NAME:
            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \
                && !defined(WOLFCRYPT_ONLY)
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_NAME_free;
 800df22:	4b1c      	ldr	r3, [pc, #112]	@ (800df94 <wolfSSL_sk_pop_free+0x100>)
 800df24:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800df26:	e009      	b.n	800df3c <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_X509_NAME_ENTRY:
            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \
                && !defined(WOLFCRYPT_ONLY)
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_NAME_ENTRY_free;
 800df28:	4b1b      	ldr	r3, [pc, #108]	@ (800df98 <wolfSSL_sk_pop_free+0x104>)
 800df2a:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800df2c:	e006      	b.n	800df3c <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_X509_EXT:
            #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA)
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_EXTENSION_free;
 800df2e:	4b1b      	ldr	r3, [pc, #108]	@ (800df9c <wolfSSL_sk_pop_free+0x108>)
 800df30:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800df32:	e003      	b.n	800df3c <wolfSSL_sk_pop_free+0xa8>
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_INFO_free;
            #endif
                break;
            case STACK_TYPE_BIO:
#if !defined(NO_BIO) && defined(OPENSSL_EXTRA)
                func = (wolfSSL_sk_freefunc)wolfSSL_BIO_vfree;
 800df34:	4b1a      	ldr	r3, [pc, #104]	@ (800dfa0 <wolfSSL_sk_pop_free+0x10c>)
 800df36:	603b      	str	r3, [r7, #0]
#endif
                break;
 800df38:	e000      	b.n	800df3c <wolfSSL_sk_pop_free+0xa8>
#endif
                break;
            case STACK_TYPE_CIPHER:
            case STACK_TYPE_NULL:
            default:
                break;
 800df3a:	bf00      	nop
        }
    }

    while (sk != NULL) {
 800df3c:	e018      	b.n	800df70 <wolfSSL_sk_pop_free+0xdc>
        WOLFSSL_STACK* next = sk->next;
 800df3e:	687b      	ldr	r3, [r7, #4]
 800df40:	691b      	ldr	r3, [r3, #16]
 800df42:	60fb      	str	r3, [r7, #12]

        if (func != NULL) {
 800df44:	683b      	ldr	r3, [r7, #0]
 800df46:	2b00      	cmp	r3, #0
 800df48:	d008      	beq.n	800df5c <wolfSSL_sk_pop_free+0xc8>
            if (sk->type != STACK_TYPE_CIPHER)
 800df4a:	687b      	ldr	r3, [r7, #4]
 800df4c:	7d1b      	ldrb	r3, [r3, #20]
 800df4e:	2b05      	cmp	r3, #5
 800df50:	d004      	beq.n	800df5c <wolfSSL_sk_pop_free+0xc8>
                func(sk->data.generic);
 800df52:	687b      	ldr	r3, [r7, #4]
 800df54:	685a      	ldr	r2, [r3, #4]
 800df56:	683b      	ldr	r3, [r7, #0]
 800df58:	4610      	mov	r0, r2
 800df5a:	4798      	blx	r3
        }
        XFREE(sk, NULL, DYNAMIC_TYPE_OPENSSL);
 800df5c:	687b      	ldr	r3, [r7, #4]
 800df5e:	60bb      	str	r3, [r7, #8]
 800df60:	68bb      	ldr	r3, [r7, #8]
 800df62:	2b00      	cmp	r3, #0
 800df64:	d002      	beq.n	800df6c <wolfSSL_sk_pop_free+0xd8>
 800df66:	68b8      	ldr	r0, [r7, #8]
 800df68:	f010 fea4 	bl	801ecb4 <wolfSSL_Free>
        sk = next;
 800df6c:	68fb      	ldr	r3, [r7, #12]
 800df6e:	607b      	str	r3, [r7, #4]
    while (sk != NULL) {
 800df70:	687b      	ldr	r3, [r7, #4]
 800df72:	2b00      	cmp	r3, #0
 800df74:	d1e3      	bne.n	800df3e <wolfSSL_sk_pop_free+0xaa>
 800df76:	e000      	b.n	800df7a <wolfSSL_sk_pop_free+0xe6>
        return;
 800df78:	bf00      	nop
    }
}
 800df7a:	3710      	adds	r7, #16
 800df7c:	46bd      	mov	sp, r7
 800df7e:	bd80      	pop	{r7, pc}
 800df80:	0800e4b7 	.word	0x0800e4b7
 800df84:	0800bb4f 	.word	0x0800bb4f
 800df88:	0800e537 	.word	0x0800e537
 800df8c:	0800e675 	.word	0x0800e675
 800df90:	0800e1f9 	.word	0x0800e1f9
 800df94:	0800e6e7 	.word	0x0800e6e7
 800df98:	0800e73f 	.word	0x0800e73f
 800df9c:	0800e405 	.word	0x0800e405
 800dfa0:	0800e3a5 	.word	0x0800e3a5

0800dfa4 <wolfSSL_OBJ_nid2obj_ex>:
    }


    WOLFSSL_LOCAL WOLFSSL_ASN1_OBJECT* wolfSSL_OBJ_nid2obj_ex(int id,
                                                WOLFSSL_ASN1_OBJECT* arg_obj)
    {
 800dfa4:	b590      	push	{r4, r7, lr}
 800dfa6:	b097      	sub	sp, #92	@ 0x5c
 800dfa8:	af00      	add	r7, sp, #0
 800dfaa:	6078      	str	r0, [r7, #4]
 800dfac:	6039      	str	r1, [r7, #0]
        word32 oidSz = 0;
 800dfae:	2300      	movs	r3, #0
 800dfb0:	63bb      	str	r3, [r7, #56]	@ 0x38
        int nid = 0;
 800dfb2:	2300      	movs	r3, #0
 800dfb4:	657b      	str	r3, [r7, #84]	@ 0x54
        const byte* oid;
        word32 type = 0;
 800dfb6:	2300      	movs	r3, #0
 800dfb8:	653b      	str	r3, [r7, #80]	@ 0x50
        WOLFSSL_ASN1_OBJECT* obj = arg_obj;
 800dfba:	683b      	ldr	r3, [r7, #0]
 800dfbc:	64fb      	str	r3, [r7, #76]	@ 0x4c
        byte objBuf[MAX_OID_SZ + MAX_LENGTH_SZ + 1]; /* +1 for object tag */
        word32 objSz = 0;
 800dfbe:	2300      	movs	r3, #0
 800dfc0:	64bb      	str	r3, [r7, #72]	@ 0x48
        const char* sName = NULL;
 800dfc2:	2300      	movs	r3, #0
 800dfc4:	647b      	str	r3, [r7, #68]	@ 0x44

#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_OBJ_nid2obj");
#endif

        for (i = 0; i < (int)WOLFSSL_OBJECT_INFO_SZ; i++) {
 800dfc6:	2300      	movs	r3, #0
 800dfc8:	643b      	str	r3, [r7, #64]	@ 0x40
 800dfca:	e02e      	b.n	800e02a <wolfSSL_OBJ_nid2obj_ex+0x86>
            if (wolfssl_object_info[i].nid == id) {
 800dfcc:	497b      	ldr	r1, [pc, #492]	@ (800e1bc <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800dfce:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800dfd0:	4613      	mov	r3, r2
 800dfd2:	009b      	lsls	r3, r3, #2
 800dfd4:	4413      	add	r3, r2
 800dfd6:	009b      	lsls	r3, r3, #2
 800dfd8:	440b      	add	r3, r1
 800dfda:	681b      	ldr	r3, [r3, #0]
 800dfdc:	687a      	ldr	r2, [r7, #4]
 800dfde:	429a      	cmp	r2, r3
 800dfe0:	d120      	bne.n	800e024 <wolfSSL_OBJ_nid2obj_ex+0x80>
                nid = id;
 800dfe2:	687b      	ldr	r3, [r7, #4]
 800dfe4:	657b      	str	r3, [r7, #84]	@ 0x54
                id = wolfssl_object_info[i].id;
 800dfe6:	4975      	ldr	r1, [pc, #468]	@ (800e1bc <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800dfe8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800dfea:	4613      	mov	r3, r2
 800dfec:	009b      	lsls	r3, r3, #2
 800dfee:	4413      	add	r3, r2
 800dff0:	009b      	lsls	r3, r3, #2
 800dff2:	440b      	add	r3, r1
 800dff4:	3304      	adds	r3, #4
 800dff6:	681b      	ldr	r3, [r3, #0]
 800dff8:	607b      	str	r3, [r7, #4]
                sName = wolfssl_object_info[i].sName;
 800dffa:	4970      	ldr	r1, [pc, #448]	@ (800e1bc <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800dffc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800dffe:	4613      	mov	r3, r2
 800e000:	009b      	lsls	r3, r3, #2
 800e002:	4413      	add	r3, r2
 800e004:	009b      	lsls	r3, r3, #2
 800e006:	440b      	add	r3, r1
 800e008:	330c      	adds	r3, #12
 800e00a:	681b      	ldr	r3, [r3, #0]
 800e00c:	647b      	str	r3, [r7, #68]	@ 0x44
                type = wolfssl_object_info[i].type;
 800e00e:	496b      	ldr	r1, [pc, #428]	@ (800e1bc <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800e010:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800e012:	4613      	mov	r3, r2
 800e014:	009b      	lsls	r3, r3, #2
 800e016:	4413      	add	r3, r2
 800e018:	009b      	lsls	r3, r3, #2
 800e01a:	440b      	add	r3, r1
 800e01c:	3308      	adds	r3, #8
 800e01e:	681b      	ldr	r3, [r3, #0]
 800e020:	653b      	str	r3, [r7, #80]	@ 0x50
                break;
 800e022:	e005      	b.n	800e030 <wolfSSL_OBJ_nid2obj_ex+0x8c>
        for (i = 0; i < (int)WOLFSSL_OBJECT_INFO_SZ; i++) {
 800e024:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800e026:	3301      	adds	r3, #1
 800e028:	643b      	str	r3, [r7, #64]	@ 0x40
 800e02a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800e02c:	2b50      	cmp	r3, #80	@ 0x50
 800e02e:	ddcd      	ble.n	800dfcc <wolfSSL_OBJ_nid2obj_ex+0x28>
            }
        }
        if (i == (int)WOLFSSL_OBJECT_INFO_SZ) {
 800e030:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800e032:	2b51      	cmp	r3, #81	@ 0x51
 800e034:	d101      	bne.n	800e03a <wolfSSL_OBJ_nid2obj_ex+0x96>
            WOLFSSL_MSG("NID not in table");
        #ifdef WOLFSSL_QT
            sName = NULL;
            type = (word32)id;
        #else
            return NULL;
 800e036:	2300      	movs	r3, #0
 800e038:	e0bc      	b.n	800e1b4 <wolfSSL_OBJ_nid2obj_ex+0x210>
        #endif
        }

    #ifdef HAVE_ECC
         if (type == 0 && wc_ecc_get_oid((word32)id, &oid, &oidSz) > 0) {
 800e03a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800e03c:	2b00      	cmp	r3, #0
 800e03e:	d10c      	bne.n	800e05a <wolfSSL_OBJ_nid2obj_ex+0xb6>
 800e040:	687b      	ldr	r3, [r7, #4]
 800e042:	f107 0238 	add.w	r2, r7, #56	@ 0x38
 800e046:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 800e04a:	4618      	mov	r0, r3
 800e04c:	f010 f9ec 	bl	801e428 <wc_ecc_get_oid>
 800e050:	4603      	mov	r3, r0
 800e052:	2b00      	cmp	r3, #0
 800e054:	dd01      	ble.n	800e05a <wolfSSL_OBJ_nid2obj_ex+0xb6>
             type = oidCurveType;
 800e056:	2303      	movs	r3, #3
 800e058:	653b      	str	r3, [r7, #80]	@ 0x50
         }
    #endif /* HAVE_ECC */

        if (sName != NULL) {
 800e05a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e05c:	2b00      	cmp	r3, #0
 800e05e:	d007      	beq.n	800e070 <wolfSSL_OBJ_nid2obj_ex+0xcc>
            if (XSTRLEN(sName) > WOLFSSL_MAX_SNAME - 1) {
 800e060:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800e062:	f7f2 f8bf 	bl	80001e4 <strlen>
 800e066:	4603      	mov	r3, r0
 800e068:	2b27      	cmp	r3, #39	@ 0x27
 800e06a:	d901      	bls.n	800e070 <wolfSSL_OBJ_nid2obj_ex+0xcc>
                WOLFSSL_MSG("Attempted short name is too large");
                return NULL;
 800e06c:	2300      	movs	r3, #0
 800e06e:	e0a1      	b.n	800e1b4 <wolfSSL_OBJ_nid2obj_ex+0x210>
            }
        }

        oid = OidFromId((word32)id, type, &oidSz);
 800e070:	687b      	ldr	r3, [r7, #4]
 800e072:	f107 0238 	add.w	r2, r7, #56	@ 0x38
 800e076:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 800e078:	4618      	mov	r0, r3
 800e07a:	f006 f8c1 	bl	8014200 <OidFromId>
 800e07e:	4603      	mov	r3, r0
 800e080:	637b      	str	r3, [r7, #52]	@ 0x34

        /* set object ID to buffer */
        if (obj == NULL){
 800e082:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e084:	2b00      	cmp	r3, #0
 800e086:	d107      	bne.n	800e098 <wolfSSL_OBJ_nid2obj_ex+0xf4>
            obj = wolfSSL_ASN1_OBJECT_new();
 800e088:	f7fd fd3e 	bl	800bb08 <wolfSSL_ASN1_OBJECT_new>
 800e08c:	64f8      	str	r0, [r7, #76]	@ 0x4c
            if (obj == NULL) {
 800e08e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e090:	2b00      	cmp	r3, #0
 800e092:	d101      	bne.n	800e098 <wolfSSL_OBJ_nid2obj_ex+0xf4>
                WOLFSSL_MSG("Issue creating WOLFSSL_ASN1_OBJECT struct");
                return NULL;
 800e094:	2300      	movs	r3, #0
 800e096:	e08d      	b.n	800e1b4 <wolfSSL_OBJ_nid2obj_ex+0x210>
            }
        }
        obj->nid     = nid;
 800e098:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e09a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800e09c:	639a      	str	r2, [r3, #56]	@ 0x38
        obj->type    = id;
 800e09e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e0a0:	687a      	ldr	r2, [r7, #4]
 800e0a2:	631a      	str	r2, [r3, #48]	@ 0x30
        obj->grp     = (int)type;
 800e0a4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800e0a6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e0a8:	635a      	str	r2, [r3, #52]	@ 0x34

        obj->sName[0] = '\0';
 800e0aa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e0ac:	2200      	movs	r2, #0
 800e0ae:	721a      	strb	r2, [r3, #8]
        if (sName != NULL) {
 800e0b0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e0b2:	2b00      	cmp	r3, #0
 800e0b4:	d00b      	beq.n	800e0ce <wolfSSL_OBJ_nid2obj_ex+0x12a>
            XMEMCPY(obj->sName, (char*)sName, XSTRLEN((char*)sName));
 800e0b6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e0b8:	f103 0408 	add.w	r4, r3, #8
 800e0bc:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800e0be:	f7f2 f891 	bl	80001e4 <strlen>
 800e0c2:	4603      	mov	r3, r0
 800e0c4:	461a      	mov	r2, r3
 800e0c6:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800e0c8:	4620      	mov	r0, r4
 800e0ca:	f01a fe5c 	bl	8028d86 <memcpy>
        }

        objBuf[0] = ASN_OBJECT_ID; objSz++;
 800e0ce:	2306      	movs	r3, #6
 800e0d0:	733b      	strb	r3, [r7, #12]
 800e0d2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800e0d4:	3301      	adds	r3, #1
 800e0d6:	64bb      	str	r3, [r7, #72]	@ 0x48
        objSz += SetLength(oidSz, objBuf + 1);
 800e0d8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800e0da:	f107 030c 	add.w	r3, r7, #12
 800e0de:	3301      	adds	r3, #1
 800e0e0:	4619      	mov	r1, r3
 800e0e2:	4610      	mov	r0, r2
 800e0e4:	f007 ff81 	bl	8015fea <SetLength>
 800e0e8:	4602      	mov	r2, r0
 800e0ea:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800e0ec:	4413      	add	r3, r2
 800e0ee:	64bb      	str	r3, [r7, #72]	@ 0x48
        if (oidSz) {
 800e0f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e0f2:	2b00      	cmp	r3, #0
 800e0f4:	d00c      	beq.n	800e110 <wolfSSL_OBJ_nid2obj_ex+0x16c>
            XMEMCPY(objBuf + objSz, oid, oidSz);
 800e0f6:	f107 020c 	add.w	r2, r7, #12
 800e0fa:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800e0fc:	4413      	add	r3, r2
 800e0fe:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800e100:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800e102:	4618      	mov	r0, r3
 800e104:	f01a fe3f 	bl	8028d86 <memcpy>
            objSz     += oidSz;
 800e108:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e10a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800e10c:	4413      	add	r3, r2
 800e10e:	64bb      	str	r3, [r7, #72]	@ 0x48
        }

        if (obj->objSz == 0 || objSz != obj->objSz) {
 800e110:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e112:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800e114:	2b00      	cmp	r3, #0
 800e116:	d004      	beq.n	800e122 <wolfSSL_OBJ_nid2obj_ex+0x17e>
 800e118:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e11a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800e11c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800e11e:	429a      	cmp	r2, r3
 800e120:	d03e      	beq.n	800e1a0 <wolfSSL_OBJ_nid2obj_ex+0x1fc>
            obj->objSz = objSz;
 800e122:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e124:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800e126:	63da      	str	r2, [r3, #60]	@ 0x3c
            if(((obj->dynamic & WOLFSSL_ASN1_DYNAMIC_DATA) != 0) ||
 800e128:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e12a:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800e12e:	f003 0302 	and.w	r3, r3, #2
 800e132:	2b00      	cmp	r3, #0
 800e134:	d103      	bne.n	800e13e <wolfSSL_OBJ_nid2obj_ex+0x19a>
                                                           (obj->obj == NULL)) {
 800e136:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e138:	685b      	ldr	r3, [r3, #4]
            if(((obj->dynamic & WOLFSSL_ASN1_DYNAMIC_DATA) != 0) ||
 800e13a:	2b00      	cmp	r3, #0
 800e13c:	d127      	bne.n	800e18e <wolfSSL_OBJ_nid2obj_ex+0x1ea>
                if (obj->obj != NULL)
 800e13e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e140:	685b      	ldr	r3, [r3, #4]
 800e142:	2b00      	cmp	r3, #0
 800e144:	d008      	beq.n	800e158 <wolfSSL_OBJ_nid2obj_ex+0x1b4>
                    XFREE((byte*)obj->obj, NULL, DYNAMIC_TYPE_ASN1);
 800e146:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e148:	685b      	ldr	r3, [r3, #4]
 800e14a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800e14c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800e14e:	2b00      	cmp	r3, #0
 800e150:	d002      	beq.n	800e158 <wolfSSL_OBJ_nid2obj_ex+0x1b4>
 800e152:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 800e154:	f010 fdae 	bl	801ecb4 <wolfSSL_Free>
                obj->obj = (byte*)XMALLOC(obj->objSz, NULL, DYNAMIC_TYPE_ASN1);
 800e158:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e15a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800e15c:	4618      	mov	r0, r3
 800e15e:	f010 fd8d 	bl	801ec7c <wolfSSL_Malloc>
 800e162:	4602      	mov	r2, r0
 800e164:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e166:	605a      	str	r2, [r3, #4]
                if (obj->obj == NULL) {
 800e168:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e16a:	685b      	ldr	r3, [r3, #4]
 800e16c:	2b00      	cmp	r3, #0
 800e16e:	d104      	bne.n	800e17a <wolfSSL_OBJ_nid2obj_ex+0x1d6>
                    wolfSSL_ASN1_OBJECT_free(obj);
 800e170:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800e172:	f7fd fcec 	bl	800bb4e <wolfSSL_ASN1_OBJECT_free>
                    return NULL;
 800e176:	2300      	movs	r3, #0
 800e178:	e01c      	b.n	800e1b4 <wolfSSL_OBJ_nid2obj_ex+0x210>
                }
                obj->dynamic |= WOLFSSL_ASN1_DYNAMIC_DATA;
 800e17a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e17c:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800e180:	f043 0302 	orr.w	r3, r3, #2
 800e184:	b2da      	uxtb	r2, r3
 800e186:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e188:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
 800e18c:	e008      	b.n	800e1a0 <wolfSSL_OBJ_nid2obj_ex+0x1fc>
            }
            else {
                obj->dynamic &= ~WOLFSSL_ASN1_DYNAMIC_DATA;
 800e18e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e190:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800e194:	f023 0302 	bic.w	r3, r3, #2
 800e198:	b2da      	uxtb	r2, r3
 800e19a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e19c:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
            }
        }
        XMEMCPY((byte*)obj->obj, objBuf, obj->objSz);
 800e1a0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e1a2:	6858      	ldr	r0, [r3, #4]
 800e1a4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e1a6:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800e1a8:	f107 030c 	add.w	r3, r7, #12
 800e1ac:	4619      	mov	r1, r3
 800e1ae:	f01a fdea 	bl	8028d86 <memcpy>

        (void)type;

        return obj;
 800e1b2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    }
 800e1b4:	4618      	mov	r0, r3
 800e1b6:	375c      	adds	r7, #92	@ 0x5c
 800e1b8:	46bd      	mov	sp, r7
 800e1ba:	bd90      	pop	{r4, r7, pc}
 800e1bc:	08031bdc 	.word	0x08031bdc

0800e1c0 <wolfSSL_ERR_peek_last_error>:
        return 0;
    return ConstantCompare((const byte*)a, (const byte*)b, (int)size);
}

unsigned long wolfSSL_ERR_peek_last_error(void)
{
 800e1c0:	b580      	push	{r7, lr}
 800e1c2:	b082      	sub	sp, #8
 800e1c4:	af00      	add	r7, sp, #0

#ifdef WOLFSSL_HAVE_ERROR_QUEUE
    {
        int ret;

        if ((ret = wc_PeekErrorNode(-1, NULL, NULL, NULL)) < 0) {
 800e1c6:	2300      	movs	r3, #0
 800e1c8:	2200      	movs	r2, #0
 800e1ca:	2100      	movs	r1, #0
 800e1cc:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 800e1d0:	f010 fb80 	bl	801e8d4 <wc_PeekErrorNode>
 800e1d4:	6078      	str	r0, [r7, #4]
 800e1d6:	687b      	ldr	r3, [r7, #4]
 800e1d8:	2b00      	cmp	r3, #0
 800e1da:	da01      	bge.n	800e1e0 <wolfSSL_ERR_peek_last_error+0x20>
            WOLFSSL_MSG("Issue peeking at error node in queue");
            return 0;
 800e1dc:	2300      	movs	r3, #0
 800e1de:	e005      	b.n	800e1ec <wolfSSL_ERR_peek_last_error+0x2c>
        }
        if (ret == -WC_NO_ERR_TRACE(ASN_NO_PEM_HEADER))
 800e1e0:	687b      	ldr	r3, [r7, #4]
 800e1e2:	2ba2      	cmp	r3, #162	@ 0xa2
 800e1e4:	d101      	bne.n	800e1ea <wolfSSL_ERR_peek_last_error+0x2a>
            return (WOLFSSL_ERR_LIB_PEM << 24) | -WC_NO_ERR_TRACE(WOLFSSL_PEM_R_NO_START_LINE_E);
 800e1e6:	4b03      	ldr	r3, [pc, #12]	@ (800e1f4 <wolfSSL_ERR_peek_last_error+0x34>)
 800e1e8:	e000      	b.n	800e1ec <wolfSSL_ERR_peek_last_error+0x2c>
    #if defined(WOLFSSL_PYTHON)
        if (ret == WC_NO_ERR_TRACE(ASN1_R_HEADER_TOO_LONG))
            return (WOLFSSL_ERR_LIB_ASN1 << 24) | -WC_NO_ERR_TRACE(WOLFSSL_ASN1_R_HEADER_TOO_LONG_E);
    #endif
        return (unsigned long)ret;
 800e1ea:	687b      	ldr	r3, [r7, #4]
    }
#else
    return (unsigned long)(0 - NOT_COMPILED_IN);
#endif
}
 800e1ec:	4618      	mov	r0, r3
 800e1ee:	3708      	adds	r7, #8
 800e1f0:	46bd      	mov	sp, r7
 800e1f2:	bd80      	pop	{r7, pc}
 800e1f4:	090001fb 	.word	0x090001fb

0800e1f8 <wolfSSL_WOLFSSL_STRING_free>:

    return ret;
}

void wolfSSL_WOLFSSL_STRING_free(WOLFSSL_STRING s)
{
 800e1f8:	b580      	push	{r7, lr}
 800e1fa:	b084      	sub	sp, #16
 800e1fc:	af00      	add	r7, sp, #0
 800e1fe:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_WOLFSSL_STRING_free");

    XFREE(s, NULL, DYNAMIC_TYPE_OPENSSL);
 800e200:	687b      	ldr	r3, [r7, #4]
 800e202:	60fb      	str	r3, [r7, #12]
 800e204:	68fb      	ldr	r3, [r7, #12]
 800e206:	2b00      	cmp	r3, #0
 800e208:	d002      	beq.n	800e210 <wolfSSL_WOLFSSL_STRING_free+0x18>
 800e20a:	68f8      	ldr	r0, [r7, #12]
 800e20c:	f010 fd52 	bl	801ecb4 <wolfSSL_Free>
}
 800e210:	bf00      	nop
 800e212:	3710      	adds	r7, #16
 800e214:	46bd      	mov	sp, r7
 800e216:	bd80      	pop	{r7, pc}

0800e218 <wolfSSL_BIO_free>:
     * Note : If the flag BIO_NOCLOSE is set then freeing memory buffers is up
     *        to the application.
     * Returns 1 on success, 0 on failure
     */
    int wolfSSL_BIO_free(WOLFSSL_BIO* bio)
    {
 800e218:	b590      	push	{r4, r7, lr}
 800e21a:	b08d      	sub	sp, #52	@ 0x34
 800e21c:	af02      	add	r7, sp, #8
 800e21e:	6078      	str	r0, [r7, #4]
        int ret;
    #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA)
        int doFree = 0;
 800e220:	2300      	movs	r3, #0
 800e222:	60fb      	str	r3, [r7, #12]
    #endif

        /* unchain?, doesn't matter in goahead since from free all */
        WOLFSSL_ENTER("wolfSSL_BIO_free");
        if (bio) {
 800e224:	687b      	ldr	r3, [r7, #4]
 800e226:	2b00      	cmp	r3, #0
 800e228:	f000 80b7 	beq.w	800e39a <wolfSSL_BIO_free+0x182>

            if (bio->infoCb) {
 800e22c:	687b      	ldr	r3, [r7, #4]
 800e22e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e230:	2b00      	cmp	r3, #0
 800e232:	d011      	beq.n	800e258 <wolfSSL_BIO_free+0x40>
                /* info callback is called before free */
                ret = (int)bio->infoCb(bio, WOLFSSL_BIO_CB_FREE, NULL, 0, 0, 1);
 800e234:	687b      	ldr	r3, [r7, #4]
 800e236:	6adc      	ldr	r4, [r3, #44]	@ 0x2c
 800e238:	2301      	movs	r3, #1
 800e23a:	9301      	str	r3, [sp, #4]
 800e23c:	2300      	movs	r3, #0
 800e23e:	9300      	str	r3, [sp, #0]
 800e240:	2300      	movs	r3, #0
 800e242:	2200      	movs	r2, #0
 800e244:	2101      	movs	r1, #1
 800e246:	6878      	ldr	r0, [r7, #4]
 800e248:	47a0      	blx	r4
 800e24a:	4603      	mov	r3, r0
 800e24c:	613b      	str	r3, [r7, #16]
                if (ret <= 0) {
 800e24e:	693b      	ldr	r3, [r7, #16]
 800e250:	2b00      	cmp	r3, #0
 800e252:	dc01      	bgt.n	800e258 <wolfSSL_BIO_free+0x40>
                    return ret;
 800e254:	693b      	ldr	r3, [r7, #16]
 800e256:	e0a1      	b.n	800e39c <wolfSSL_BIO_free+0x184>
                }
            }

    #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA)
            wolfSSL_RefDec(&bio->ref, &doFree, &ret);
 800e258:	687b      	ldr	r3, [r7, #4]
 800e25a:	3368      	adds	r3, #104	@ 0x68
 800e25c:	2101      	movs	r1, #1
 800e25e:	4618      	mov	r0, r3
 800e260:	f7fd f818 	bl	800b294 <wolfSSL_Atomic_Int_FetchSub>
 800e264:	6278      	str	r0, [r7, #36]	@ 0x24
 800e266:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e268:	2b01      	cmp	r3, #1
 800e26a:	bf0c      	ite	eq
 800e26c:	2301      	moveq	r3, #1
 800e26e:	2300      	movne	r3, #0
 800e270:	b2db      	uxtb	r3, r3
 800e272:	60fb      	str	r3, [r7, #12]
 800e274:	2300      	movs	r3, #0
 800e276:	613b      	str	r3, [r7, #16]

            if (!doFree) {
 800e278:	68fb      	ldr	r3, [r7, #12]
 800e27a:	2b00      	cmp	r3, #0
 800e27c:	d101      	bne.n	800e282 <wolfSSL_BIO_free+0x6a>
                /* return success if BIO ref count is not 1 yet */
            #ifdef WOLFSSL_REFCNT_ERROR_RETURN
                return (ret == 0) ? WOLFSSL_SUCCESS : WOLFSSL_FAILURE ;
            #else
                (void)ret;
                return WOLFSSL_SUCCESS;
 800e27e:	2301      	movs	r3, #1
 800e280:	e08c      	b.n	800e39c <wolfSSL_BIO_free+0x184>
        #ifdef HAVE_EX_DATA_CLEANUP_HOOKS
            wolfSSL_CRYPTO_cleanup_ex_data(&bio->ex_data);
        #endif

            /* call custom set free callback */
            if (bio->method && bio->method->freeCb) {
 800e282:	687b      	ldr	r3, [r7, #4]
 800e284:	685b      	ldr	r3, [r3, #4]
 800e286:	2b00      	cmp	r3, #0
 800e288:	d00b      	beq.n	800e2a2 <wolfSSL_BIO_free+0x8a>
 800e28a:	687b      	ldr	r3, [r7, #4]
 800e28c:	685b      	ldr	r3, [r3, #4]
 800e28e:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 800e292:	2b00      	cmp	r3, #0
 800e294:	d005      	beq.n	800e2a2 <wolfSSL_BIO_free+0x8a>
                bio->method->freeCb(bio);
 800e296:	687b      	ldr	r3, [r7, #4]
 800e298:	685b      	ldr	r3, [r3, #4]
 800e29a:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 800e29e:	6878      	ldr	r0, [r7, #4]
 800e2a0:	4798      	blx	r3
            }

            /* remove from pair by setting the paired bios pair to NULL */
            if (bio->pair != NULL) {
 800e2a2:	687b      	ldr	r3, [r7, #4]
 800e2a4:	691b      	ldr	r3, [r3, #16]
 800e2a6:	2b00      	cmp	r3, #0
 800e2a8:	d003      	beq.n	800e2b2 <wolfSSL_BIO_free+0x9a>
                bio->pair->pair = NULL;
 800e2aa:	687b      	ldr	r3, [r7, #4]
 800e2ac:	691b      	ldr	r3, [r3, #16]
 800e2ae:	2200      	movs	r2, #0
 800e2b0:	611a      	str	r2, [r3, #16]
            }

            XFREE(bio->ip, bio->heap, DYNAMIC_TYPE_OPENSSL);
 800e2b2:	687b      	ldr	r3, [r7, #4]
 800e2b4:	6a1b      	ldr	r3, [r3, #32]
 800e2b6:	623b      	str	r3, [r7, #32]
 800e2b8:	6a3b      	ldr	r3, [r7, #32]
 800e2ba:	2b00      	cmp	r3, #0
 800e2bc:	d002      	beq.n	800e2c4 <wolfSSL_BIO_free+0xac>
 800e2be:	6a38      	ldr	r0, [r7, #32]
 800e2c0:	f010 fcf8 	bl	801ecb4 <wolfSSL_Free>

            if (bio->shutdown) {
 800e2c4:	687b      	ldr	r3, [r7, #4]
 800e2c6:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 800e2ca:	f003 0302 	and.w	r3, r3, #2
 800e2ce:	b2db      	uxtb	r3, r3
 800e2d0:	2b00      	cmp	r3, #0
 800e2d2:	d00d      	beq.n	800e2f0 <wolfSSL_BIO_free+0xd8>
                if (bio->type == WOLFSSL_BIO_SSL && bio->ptr.ssl)
 800e2d4:	687b      	ldr	r3, [r7, #4]
 800e2d6:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800e2da:	2b03      	cmp	r3, #3
 800e2dc:	d108      	bne.n	800e2f0 <wolfSSL_BIO_free+0xd8>
 800e2de:	687b      	ldr	r3, [r7, #4]
 800e2e0:	699b      	ldr	r3, [r3, #24]
 800e2e2:	2b00      	cmp	r3, #0
 800e2e4:	d004      	beq.n	800e2f0 <wolfSSL_BIO_free+0xd8>
                    wolfSSL_free(bio->ptr.ssl);
 800e2e6:	687b      	ldr	r3, [r7, #4]
 800e2e8:	699b      	ldr	r3, [r3, #24]
 800e2ea:	4618      	mov	r0, r3
 800e2ec:	f7fe f805 	bl	800c2fa <wolfSSL_free>
                }
            #endif
            }
        #endif

            if (bio->shutdown != WOLFSSL_BIO_NOCLOSE) {
 800e2f0:	687b      	ldr	r3, [r7, #4]
 800e2f2:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 800e2f6:	f003 0302 	and.w	r3, r3, #2
 800e2fa:	b2db      	uxtb	r3, r3
 800e2fc:	2b00      	cmp	r3, #0
 800e2fe:	d038      	beq.n	800e372 <wolfSSL_BIO_free+0x15a>
                if (bio->type == WOLFSSL_BIO_MEMORY &&
 800e300:	687b      	ldr	r3, [r7, #4]
 800e302:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800e306:	2b04      	cmp	r3, #4
 800e308:	d127      	bne.n	800e35a <wolfSSL_BIO_free+0x142>
                    bio->ptr.mem_buf_data != NULL)
 800e30a:	687b      	ldr	r3, [r7, #4]
 800e30c:	699b      	ldr	r3, [r3, #24]
                if (bio->type == WOLFSSL_BIO_MEMORY &&
 800e30e:	2b00      	cmp	r3, #0
 800e310:	d023      	beq.n	800e35a <wolfSSL_BIO_free+0x142>
                {
                    if (bio->mem_buf != NULL) {
 800e312:	687b      	ldr	r3, [r7, #4]
 800e314:	681b      	ldr	r3, [r3, #0]
 800e316:	2b00      	cmp	r3, #0
 800e318:	d013      	beq.n	800e342 <wolfSSL_BIO_free+0x12a>
                        if ((byte *)bio->mem_buf->data != bio->ptr.mem_buf_data)
 800e31a:	687b      	ldr	r3, [r7, #4]
 800e31c:	681b      	ldr	r3, [r3, #0]
 800e31e:	681a      	ldr	r2, [r3, #0]
 800e320:	687b      	ldr	r3, [r7, #4]
 800e322:	699b      	ldr	r3, [r3, #24]
 800e324:	429a      	cmp	r2, r3
 800e326:	d018      	beq.n	800e35a <wolfSSL_BIO_free+0x142>
                        {
                            XFREE(bio->ptr.mem_buf_data, bio->heap,
 800e328:	687b      	ldr	r3, [r7, #4]
 800e32a:	699b      	ldr	r3, [r3, #24]
 800e32c:	61bb      	str	r3, [r7, #24]
 800e32e:	69bb      	ldr	r3, [r7, #24]
 800e330:	2b00      	cmp	r3, #0
 800e332:	d002      	beq.n	800e33a <wolfSSL_BIO_free+0x122>
 800e334:	69b8      	ldr	r0, [r7, #24]
 800e336:	f010 fcbd 	bl	801ecb4 <wolfSSL_Free>
                                  DYNAMIC_TYPE_OPENSSL);
                            bio->ptr.mem_buf_data = NULL;
 800e33a:	687b      	ldr	r3, [r7, #4]
 800e33c:	2200      	movs	r2, #0
 800e33e:	619a      	str	r2, [r3, #24]
 800e340:	e00b      	b.n	800e35a <wolfSSL_BIO_free+0x142>
                        }
                    }
                    else {
                        XFREE(bio->ptr.mem_buf_data, bio->heap,
 800e342:	687b      	ldr	r3, [r7, #4]
 800e344:	699b      	ldr	r3, [r3, #24]
 800e346:	61fb      	str	r3, [r7, #28]
 800e348:	69fb      	ldr	r3, [r7, #28]
 800e34a:	2b00      	cmp	r3, #0
 800e34c:	d002      	beq.n	800e354 <wolfSSL_BIO_free+0x13c>
 800e34e:	69f8      	ldr	r0, [r7, #28]
 800e350:	f010 fcb0 	bl	801ecb4 <wolfSSL_Free>
                              DYNAMIC_TYPE_OPENSSL);
                        bio->ptr.mem_buf_data = NULL;
 800e354:	687b      	ldr	r3, [r7, #4]
 800e356:	2200      	movs	r2, #0
 800e358:	619a      	str	r2, [r3, #24]
                    }
                }
                if (bio->mem_buf != NULL) {
 800e35a:	687b      	ldr	r3, [r7, #4]
 800e35c:	681b      	ldr	r3, [r3, #0]
 800e35e:	2b00      	cmp	r3, #0
 800e360:	d007      	beq.n	800e372 <wolfSSL_BIO_free+0x15a>
                    wolfSSL_BUF_MEM_free(bio->mem_buf);
 800e362:	687b      	ldr	r3, [r7, #4]
 800e364:	681b      	ldr	r3, [r3, #0]
 800e366:	4618      	mov	r0, r3
 800e368:	f000 fdae 	bl	800eec8 <wolfSSL_BUF_MEM_free>
                    bio->mem_buf = NULL;
 800e36c:	687b      	ldr	r3, [r7, #4]
 800e36e:	2200      	movs	r2, #0
 800e370:	601a      	str	r2, [r3, #0]
                }
            }

            if (bio->type == WOLFSSL_BIO_MD) {
 800e372:	687b      	ldr	r3, [r7, #4]
 800e374:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800e378:	2b08      	cmp	r3, #8
 800e37a:	d104      	bne.n	800e386 <wolfSSL_BIO_free+0x16e>
                wolfSSL_EVP_MD_CTX_free(bio->ptr.md_ctx);
 800e37c:	687b      	ldr	r3, [r7, #4]
 800e37e:	699b      	ldr	r3, [r3, #24]
 800e380:	4618      	mov	r0, r3
 800e382:	f7fd f85c 	bl	800b43e <wolfSSL_EVP_MD_CTX_free>
            }

            XFREE(bio, 0, DYNAMIC_TYPE_OPENSSL);
 800e386:	687b      	ldr	r3, [r7, #4]
 800e388:	617b      	str	r3, [r7, #20]
 800e38a:	697b      	ldr	r3, [r7, #20]
 800e38c:	2b00      	cmp	r3, #0
 800e38e:	d002      	beq.n	800e396 <wolfSSL_BIO_free+0x17e>
 800e390:	6978      	ldr	r0, [r7, #20]
 800e392:	f010 fc8f 	bl	801ecb4 <wolfSSL_Free>
            return WOLFSSL_SUCCESS;
 800e396:	2301      	movs	r3, #1
 800e398:	e000      	b.n	800e39c <wolfSSL_BIO_free+0x184>
        }
        return WOLFSSL_FAILURE;
 800e39a:	2300      	movs	r3, #0
    }
 800e39c:	4618      	mov	r0, r3
 800e39e:	372c      	adds	r7, #44	@ 0x2c
 800e3a0:	46bd      	mov	sp, r7
 800e3a2:	bd90      	pop	{r4, r7, pc}

0800e3a4 <wolfSSL_BIO_vfree>:

    /* like BIO_free, but no return value */
    void wolfSSL_BIO_vfree(WOLFSSL_BIO* bio)
    {
 800e3a4:	b580      	push	{r7, lr}
 800e3a6:	b082      	sub	sp, #8
 800e3a8:	af00      	add	r7, sp, #0
 800e3aa:	6078      	str	r0, [r7, #4]
        wolfSSL_BIO_free(bio);
 800e3ac:	6878      	ldr	r0, [r7, #4]
 800e3ae:	f7ff ff33 	bl	800e218 <wolfSSL_BIO_free>
    }
 800e3b2:	bf00      	nop
 800e3b4:	3708      	adds	r7, #8
 800e3b6:	46bd      	mov	sp, r7
 800e3b8:	bd80      	pop	{r7, pc}

0800e3ba <wolfSSL_ASN1_STRING_clear>:
/* Clear out and free internal pointers of ASN.1 STRING object.
 *
 * @param [in] asn1  ASN.1 STRING object.
 */
static void wolfSSL_ASN1_STRING_clear(WOLFSSL_ASN1_STRING* asn1)
{
 800e3ba:	b580      	push	{r7, lr}
 800e3bc:	b084      	sub	sp, #16
 800e3be:	af00      	add	r7, sp, #0
 800e3c0:	6078      	str	r0, [r7, #4]
    /* Check we have an object to free. */
    if (asn1 != NULL) {
 800e3c2:	687b      	ldr	r3, [r7, #4]
 800e3c4:	2b00      	cmp	r3, #0
 800e3c6:	d019      	beq.n	800e3fc <wolfSSL_ASN1_STRING_clear+0x42>
        /* Dispose of dynamic data. */
        if ((asn1->length > 0) && asn1->isDynamic) {
 800e3c8:	687b      	ldr	r3, [r7, #4]
 800e3ca:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800e3cc:	2b00      	cmp	r3, #0
 800e3ce:	dd10      	ble.n	800e3f2 <wolfSSL_ASN1_STRING_clear+0x38>
 800e3d0:	687b      	ldr	r3, [r7, #4]
 800e3d2:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800e3d6:	f003 0301 	and.w	r3, r3, #1
 800e3da:	b2db      	uxtb	r3, r3
 800e3dc:	2b00      	cmp	r3, #0
 800e3de:	d008      	beq.n	800e3f2 <wolfSSL_ASN1_STRING_clear+0x38>
            XFREE(asn1->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800e3e0:	687b      	ldr	r3, [r7, #4]
 800e3e2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800e3e4:	60fb      	str	r3, [r7, #12]
 800e3e6:	68fb      	ldr	r3, [r7, #12]
 800e3e8:	2b00      	cmp	r3, #0
 800e3ea:	d002      	beq.n	800e3f2 <wolfSSL_ASN1_STRING_clear+0x38>
 800e3ec:	68f8      	ldr	r0, [r7, #12]
 800e3ee:	f010 fc61 	bl	801ecb4 <wolfSSL_Free>
        }
        XMEMSET(asn1, 0, sizeof(WOLFSSL_ASN1_STRING));
 800e3f2:	2258      	movs	r2, #88	@ 0x58
 800e3f4:	2100      	movs	r1, #0
 800e3f6:	6878      	ldr	r0, [r7, #4]
 800e3f8:	f01a fc14 	bl	8028c24 <memset>
    }
}
 800e3fc:	bf00      	nop
 800e3fe:	3710      	adds	r7, #16
 800e400:	46bd      	mov	sp, r7
 800e402:	bd80      	pop	{r7, pc}

0800e404 <wolfSSL_X509_EXTENSION_free>:


void wolfSSL_X509_EXTENSION_free(WOLFSSL_X509_EXTENSION* x)
{
 800e404:	b580      	push	{r7, lr}
 800e406:	b084      	sub	sp, #16
 800e408:	af00      	add	r7, sp, #0
 800e40a:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_X509_EXTENSION_free");
    if (x == NULL)
 800e40c:	687b      	ldr	r3, [r7, #4]
 800e40e:	2b00      	cmp	r3, #0
 800e410:	d01d      	beq.n	800e44e <wolfSSL_X509_EXTENSION_free+0x4a>
        return;

    if (x->obj != NULL) {
 800e412:	687b      	ldr	r3, [r7, #4]
 800e414:	681b      	ldr	r3, [r3, #0]
 800e416:	2b00      	cmp	r3, #0
 800e418:	d004      	beq.n	800e424 <wolfSSL_X509_EXTENSION_free+0x20>
        wolfSSL_ASN1_OBJECT_free(x->obj);
 800e41a:	687b      	ldr	r3, [r7, #4]
 800e41c:	681b      	ldr	r3, [r3, #0]
 800e41e:	4618      	mov	r0, r3
 800e420:	f7fd fb95 	bl	800bb4e <wolfSSL_ASN1_OBJECT_free>
    }

    wolfSSL_ASN1_STRING_clear(&x->value);
 800e424:	687b      	ldr	r3, [r7, #4]
 800e426:	3308      	adds	r3, #8
 800e428:	4618      	mov	r0, r3
 800e42a:	f7ff ffc6 	bl	800e3ba <wolfSSL_ASN1_STRING_clear>
    wolfSSL_sk_pop_free(x->ext_sk, NULL);
 800e42e:	687b      	ldr	r3, [r7, #4]
 800e430:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800e434:	2100      	movs	r1, #0
 800e436:	4618      	mov	r0, r3
 800e438:	f7ff fd2c 	bl	800de94 <wolfSSL_sk_pop_free>

    XFREE(x, NULL, DYNAMIC_TYPE_X509_EXT);
 800e43c:	687b      	ldr	r3, [r7, #4]
 800e43e:	60fb      	str	r3, [r7, #12]
 800e440:	68fb      	ldr	r3, [r7, #12]
 800e442:	2b00      	cmp	r3, #0
 800e444:	d004      	beq.n	800e450 <wolfSSL_X509_EXTENSION_free+0x4c>
 800e446:	68f8      	ldr	r0, [r7, #12]
 800e448:	f010 fc34 	bl	801ecb4 <wolfSSL_Free>
 800e44c:	e000      	b.n	800e450 <wolfSSL_X509_EXTENSION_free+0x4c>
        return;
 800e44e:	bf00      	nop
}
 800e450:	3710      	adds	r7, #16
 800e452:	46bd      	mov	sp, r7
 800e454:	bd80      	pop	{r7, pc}

0800e456 <ExternalFreeX509>:
    defined(OPENSSL_EXTRA)  || defined(OPENSSL_EXTRA_X509_SMALL)

/* user externally called free X509, if dynamic go ahead with free, otherwise
 * don't */
static void ExternalFreeX509(WOLFSSL_X509* x509)
{
 800e456:	b580      	push	{r7, lr}
 800e458:	b086      	sub	sp, #24
 800e45a:	af00      	add	r7, sp, #0
 800e45c:	6078      	str	r0, [r7, #4]
#if defined(OPENSSL_EXTRA_X509_SMALL) || defined(OPENSSL_EXTRA)
    int doFree = 0;
 800e45e:	2300      	movs	r3, #0
 800e460:	60fb      	str	r3, [r7, #12]
#endif

    WOLFSSL_ENTER("ExternalFreeX509");
    if (x509) {
 800e462:	687b      	ldr	r3, [r7, #4]
 800e464:	2b00      	cmp	r3, #0
 800e466:	d022      	beq.n	800e4ae <ExternalFreeX509+0x58>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
        wolfSSL_CRYPTO_cleanup_ex_data(&x509->ex_data);
#endif
        if (x509->dynamicMemory) {
 800e468:	687b      	ldr	r3, [r7, #4]
 800e46a:	f893 3094 	ldrb.w	r3, [r3, #148]	@ 0x94
 800e46e:	2b00      	cmp	r3, #0
 800e470:	d01d      	beq.n	800e4ae <ExternalFreeX509+0x58>
        #if defined(OPENSSL_EXTRA_X509_SMALL) || defined(OPENSSL_EXTRA)
            int ret;
            wolfSSL_RefDec(&x509->ref, &doFree, &ret);
 800e472:	687b      	ldr	r3, [r7, #4]
 800e474:	3398      	adds	r3, #152	@ 0x98
 800e476:	2101      	movs	r1, #1
 800e478:	4618      	mov	r0, r3
 800e47a:	f7fc ff0b 	bl	800b294 <wolfSSL_Atomic_Int_FetchSub>
 800e47e:	6178      	str	r0, [r7, #20]
 800e480:	697b      	ldr	r3, [r7, #20]
 800e482:	2b01      	cmp	r3, #1
 800e484:	bf0c      	ite	eq
 800e486:	2301      	moveq	r3, #1
 800e488:	2300      	movne	r3, #0
 800e48a:	b2db      	uxtb	r3, r3
 800e48c:	60fb      	str	r3, [r7, #12]
 800e48e:	2300      	movs	r3, #0
 800e490:	60bb      	str	r3, [r7, #8]
            if (ret != 0) {
                WOLFSSL_MSG("Couldn't lock x509 mutex");
            }
            if (doFree)
 800e492:	68fb      	ldr	r3, [r7, #12]
 800e494:	2b00      	cmp	r3, #0
 800e496:	d00a      	beq.n	800e4ae <ExternalFreeX509+0x58>
        #endif /* OPENSSL_EXTRA_X509_SMALL || OPENSSL_EXTRA */
            {
                FreeX509(x509);
 800e498:	6878      	ldr	r0, [r7, #4]
 800e49a:	f7fb f936 	bl	800970a <FreeX509>
                XFREE(x509, x509->heap, DYNAMIC_TYPE_X509);
 800e49e:	687b      	ldr	r3, [r7, #4]
 800e4a0:	613b      	str	r3, [r7, #16]
 800e4a2:	693b      	ldr	r3, [r7, #16]
 800e4a4:	2b00      	cmp	r3, #0
 800e4a6:	d002      	beq.n	800e4ae <ExternalFreeX509+0x58>
 800e4a8:	6938      	ldr	r0, [r7, #16]
 800e4aa:	f010 fc03 	bl	801ecb4 <wolfSSL_Free>
        }
        else {
            WOLFSSL_MSG("free called on non dynamic object, not freeing");
        }
    }
}
 800e4ae:	bf00      	nop
 800e4b0:	3718      	adds	r7, #24
 800e4b2:	46bd      	mov	sp, r7
 800e4b4:	bd80      	pop	{r7, pc}

0800e4b6 <wolfSSL_X509_free>:

/* Frees an external WOLFSSL_X509 structure */
WOLFSSL_ABI
void wolfSSL_X509_free(WOLFSSL_X509* x509)
{
 800e4b6:	b580      	push	{r7, lr}
 800e4b8:	b082      	sub	sp, #8
 800e4ba:	af00      	add	r7, sp, #0
 800e4bc:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_X509_free");
    ExternalFreeX509(x509);
 800e4be:	6878      	ldr	r0, [r7, #4]
 800e4c0:	f7ff ffc9 	bl	800e456 <ExternalFreeX509>
}
 800e4c4:	bf00      	nop
 800e4c6:	3708      	adds	r7, #8
 800e4c8:	46bd      	mov	sp, r7
 800e4ca:	bd80      	pop	{r7, pc}

0800e4cc <wolfSSL_sk_X509_pop_free>:
 * sk  stack to free nodes in
 * f   X509 free function
 */
void wolfSSL_sk_X509_pop_free(WOLF_STACK_OF(WOLFSSL_X509)* sk,
    void (*f) (WOLFSSL_X509*))
{
 800e4cc:	b580      	push	{r7, lr}
 800e4ce:	b082      	sub	sp, #8
 800e4d0:	af00      	add	r7, sp, #0
 800e4d2:	6078      	str	r0, [r7, #4]
 800e4d4:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_sk_X509_pop_free");
    wolfSSL_sk_pop_free(sk, (wolfSSL_sk_freefunc)f);
 800e4d6:	6839      	ldr	r1, [r7, #0]
 800e4d8:	6878      	ldr	r0, [r7, #4]
 800e4da:	f7ff fcdb 	bl	800de94 <wolfSSL_sk_pop_free>
}
 800e4de:	bf00      	nop
 800e4e0:	3708      	adds	r7, #8
 800e4e2:	46bd      	mov	sp, r7
 800e4e4:	bd80      	pop	{r7, pc}

0800e4e6 <wolfSSL_sk_X509_free>:


/* free just the stack structure */
void wolfSSL_sk_X509_free(WOLF_STACK_OF(WOLFSSL_X509)* sk)
{
 800e4e6:	b580      	push	{r7, lr}
 800e4e8:	b082      	sub	sp, #8
 800e4ea:	af00      	add	r7, sp, #0
 800e4ec:	6078      	str	r0, [r7, #4]
    wolfSSL_sk_free(sk);
 800e4ee:	6878      	ldr	r0, [r7, #4]
 800e4f0:	f7ff fcb6 	bl	800de60 <wolfSSL_sk_free>
}
 800e4f4:	bf00      	nop
 800e4f6:	3708      	adds	r7, #8
 800e4f8:	46bd      	mov	sp, r7
 800e4fa:	bd80      	pop	{r7, pc}

0800e4fc <wolfSSL_DIST_POINT_NAME_free>:
}
#endif /* OPENSSL_EXTRA || WOLFSSL_WPAS_SMALL */

#ifdef OPENSSL_EXTRA
static void wolfSSL_DIST_POINT_NAME_free(WOLFSSL_DIST_POINT_NAME* dpn)
{
 800e4fc:	b580      	push	{r7, lr}
 800e4fe:	b084      	sub	sp, #16
 800e500:	af00      	add	r7, sp, #0
 800e502:	6078      	str	r0, [r7, #4]
    if (dpn != NULL) {
 800e504:	687b      	ldr	r3, [r7, #4]
 800e506:	2b00      	cmp	r3, #0
 800e508:	d011      	beq.n	800e52e <wolfSSL_DIST_POINT_NAME_free+0x32>
        if (dpn->name.fullname != NULL) {
 800e50a:	687b      	ldr	r3, [r7, #4]
 800e50c:	685b      	ldr	r3, [r3, #4]
 800e50e:	2b00      	cmp	r3, #0
 800e510:	d005      	beq.n	800e51e <wolfSSL_DIST_POINT_NAME_free+0x22>
            wolfSSL_sk_X509_pop_free(dpn->name.fullname, NULL);
 800e512:	687b      	ldr	r3, [r7, #4]
 800e514:	685b      	ldr	r3, [r3, #4]
 800e516:	2100      	movs	r1, #0
 800e518:	4618      	mov	r0, r3
 800e51a:	f7ff ffd7 	bl	800e4cc <wolfSSL_sk_X509_pop_free>
        }
        XFREE(dpn, NULL, DYNAMIC_TYPE_OPENSSL);
 800e51e:	687b      	ldr	r3, [r7, #4]
 800e520:	60fb      	str	r3, [r7, #12]
 800e522:	68fb      	ldr	r3, [r7, #12]
 800e524:	2b00      	cmp	r3, #0
 800e526:	d002      	beq.n	800e52e <wolfSSL_DIST_POINT_NAME_free+0x32>
 800e528:	68f8      	ldr	r0, [r7, #12]
 800e52a:	f010 fbc3 	bl	801ecb4 <wolfSSL_Free>
    }
}
 800e52e:	bf00      	nop
 800e530:	3710      	adds	r7, #16
 800e532:	46bd      	mov	sp, r7
 800e534:	bd80      	pop	{r7, pc}

0800e536 <wolfSSL_DIST_POINT_free>:


/* Frees DIST_POINT objects.
*/
void wolfSSL_DIST_POINT_free(WOLFSSL_DIST_POINT* dp)
{
 800e536:	b580      	push	{r7, lr}
 800e538:	b084      	sub	sp, #16
 800e53a:	af00      	add	r7, sp, #0
 800e53c:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_DIST_POINT_free");
    if (dp != NULL) {
 800e53e:	687b      	ldr	r3, [r7, #4]
 800e540:	2b00      	cmp	r3, #0
 800e542:	d00c      	beq.n	800e55e <wolfSSL_DIST_POINT_free+0x28>
        wolfSSL_DIST_POINT_NAME_free(dp->distpoint);
 800e544:	687b      	ldr	r3, [r7, #4]
 800e546:	681b      	ldr	r3, [r3, #0]
 800e548:	4618      	mov	r0, r3
 800e54a:	f7ff ffd7 	bl	800e4fc <wolfSSL_DIST_POINT_NAME_free>
        XFREE(dp, NULL, DYNAMIC_TYPE_OPENSSL);
 800e54e:	687b      	ldr	r3, [r7, #4]
 800e550:	60fb      	str	r3, [r7, #12]
 800e552:	68fb      	ldr	r3, [r7, #12]
 800e554:	2b00      	cmp	r3, #0
 800e556:	d002      	beq.n	800e55e <wolfSSL_DIST_POINT_free+0x28>
 800e558:	68f8      	ldr	r0, [r7, #12]
 800e55a:	f010 fbab 	bl	801ecb4 <wolfSSL_Free>
    }
}
 800e55e:	bf00      	nop
 800e560:	3710      	adds	r7, #16
 800e562:	46bd      	mov	sp, r7
 800e564:	bd80      	pop	{r7, pc}
	...

0800e568 <wolfSSL_GENERAL_NAME_type_free>:
#endif /* OPENSSL_EXTRA */

#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
/* free's the internal type for the general name */
static void wolfSSL_GENERAL_NAME_type_free(WOLFSSL_GENERAL_NAME* name)
{
 800e568:	b580      	push	{r7, lr}
 800e56a:	b084      	sub	sp, #16
 800e56c:	af00      	add	r7, sp, #0
 800e56e:	6078      	str	r0, [r7, #4]
    if (name != NULL) {
 800e570:	687b      	ldr	r3, [r7, #4]
 800e572:	2b00      	cmp	r3, #0
 800e574:	d079      	beq.n	800e66a <wolfSSL_GENERAL_NAME_type_free+0x102>
        switch (name->type) {
 800e576:	687b      	ldr	r3, [r7, #4]
 800e578:	681b      	ldr	r3, [r3, #0]
 800e57a:	2b09      	cmp	r3, #9
 800e57c:	d872      	bhi.n	800e664 <wolfSSL_GENERAL_NAME_type_free+0xfc>
 800e57e:	a201      	add	r2, pc, #4	@ (adr r2, 800e584 <wolfSSL_GENERAL_NAME_type_free+0x1c>)
 800e580:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e584:	0800e62b 	.word	0x0800e62b
 800e588:	0800e5bf 	.word	0x0800e5bf
 800e58c:	0800e5d1 	.word	0x0800e5d1
 800e590:	0800e665 	.word	0x0800e665
 800e594:	0800e5e3 	.word	0x0800e5e3
 800e598:	0800e665 	.word	0x0800e665
 800e59c:	0800e5f5 	.word	0x0800e5f5
 800e5a0:	0800e607 	.word	0x0800e607
 800e5a4:	0800e619 	.word	0x0800e619
 800e5a8:	0800e5ad 	.word	0x0800e5ad
        case WOLFSSL_GEN_IA5:
            wolfSSL_ASN1_STRING_free(name->d.ia5);
 800e5ac:	687b      	ldr	r3, [r7, #4]
 800e5ae:	685b      	ldr	r3, [r3, #4]
 800e5b0:	4618      	mov	r0, r3
 800e5b2:	f7fd fb2b 	bl	800bc0c <wolfSSL_ASN1_STRING_free>
            name->d.ia5 = NULL;
 800e5b6:	687b      	ldr	r3, [r7, #4]
 800e5b8:	2200      	movs	r2, #0
 800e5ba:	605a      	str	r2, [r3, #4]
            break;
 800e5bc:	e055      	b.n	800e66a <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_EMAIL:
            wolfSSL_ASN1_STRING_free(name->d.rfc822Name);
 800e5be:	687b      	ldr	r3, [r7, #4]
 800e5c0:	685b      	ldr	r3, [r3, #4]
 800e5c2:	4618      	mov	r0, r3
 800e5c4:	f7fd fb22 	bl	800bc0c <wolfSSL_ASN1_STRING_free>
            name->d.rfc822Name = NULL;
 800e5c8:	687b      	ldr	r3, [r7, #4]
 800e5ca:	2200      	movs	r2, #0
 800e5cc:	605a      	str	r2, [r3, #4]
            break;
 800e5ce:	e04c      	b.n	800e66a <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_DNS:
            wolfSSL_ASN1_STRING_free(name->d.dNSName);
 800e5d0:	687b      	ldr	r3, [r7, #4]
 800e5d2:	685b      	ldr	r3, [r3, #4]
 800e5d4:	4618      	mov	r0, r3
 800e5d6:	f7fd fb19 	bl	800bc0c <wolfSSL_ASN1_STRING_free>
            name->d.dNSName = NULL;
 800e5da:	687b      	ldr	r3, [r7, #4]
 800e5dc:	2200      	movs	r2, #0
 800e5de:	605a      	str	r2, [r3, #4]
            break;
 800e5e0:	e043      	b.n	800e66a <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_DIRNAME:
            wolfSSL_X509_NAME_free(name->d.dirn);
 800e5e2:	687b      	ldr	r3, [r7, #4]
 800e5e4:	685b      	ldr	r3, [r3, #4]
 800e5e6:	4618      	mov	r0, r3
 800e5e8:	f000 f87d 	bl	800e6e6 <wolfSSL_X509_NAME_free>
            name->d.dirn = NULL;
 800e5ec:	687b      	ldr	r3, [r7, #4]
 800e5ee:	2200      	movs	r2, #0
 800e5f0:	605a      	str	r2, [r3, #4]
            break;
 800e5f2:	e03a      	b.n	800e66a <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_URI:
            wolfSSL_ASN1_STRING_free(name->d.uniformResourceIdentifier);
 800e5f4:	687b      	ldr	r3, [r7, #4]
 800e5f6:	685b      	ldr	r3, [r3, #4]
 800e5f8:	4618      	mov	r0, r3
 800e5fa:	f7fd fb07 	bl	800bc0c <wolfSSL_ASN1_STRING_free>
            name->d.uniformResourceIdentifier = NULL;
 800e5fe:	687b      	ldr	r3, [r7, #4]
 800e600:	2200      	movs	r2, #0
 800e602:	605a      	str	r2, [r3, #4]
            break;
 800e604:	e031      	b.n	800e66a <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_IPADD:
            wolfSSL_ASN1_STRING_free(name->d.iPAddress);
 800e606:	687b      	ldr	r3, [r7, #4]
 800e608:	685b      	ldr	r3, [r3, #4]
 800e60a:	4618      	mov	r0, r3
 800e60c:	f7fd fafe 	bl	800bc0c <wolfSSL_ASN1_STRING_free>
            name->d.iPAddress = NULL;
 800e610:	687b      	ldr	r3, [r7, #4]
 800e612:	2200      	movs	r2, #0
 800e614:	605a      	str	r2, [r3, #4]
            break;
 800e616:	e028      	b.n	800e66a <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_RID:
            wolfSSL_ASN1_OBJECT_free(name->d.registeredID);
 800e618:	687b      	ldr	r3, [r7, #4]
 800e61a:	685b      	ldr	r3, [r3, #4]
 800e61c:	4618      	mov	r0, r3
 800e61e:	f7fd fa96 	bl	800bb4e <wolfSSL_ASN1_OBJECT_free>
            name->d.registeredID = NULL;
 800e622:	687b      	ldr	r3, [r7, #4]
 800e624:	2200      	movs	r2, #0
 800e626:	605a      	str	r2, [r3, #4]
            break;
 800e628:	e01f      	b.n	800e66a <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_OTHERNAME:
            if (name->d.otherName != NULL) {
 800e62a:	687b      	ldr	r3, [r7, #4]
 800e62c:	685b      	ldr	r3, [r3, #4]
 800e62e:	2b00      	cmp	r3, #0
 800e630:	d01a      	beq.n	800e668 <wolfSSL_GENERAL_NAME_type_free+0x100>
                wolfSSL_ASN1_OBJECT_free(name->d.otherName->type_id);
 800e632:	687b      	ldr	r3, [r7, #4]
 800e634:	685b      	ldr	r3, [r3, #4]
 800e636:	681b      	ldr	r3, [r3, #0]
 800e638:	4618      	mov	r0, r3
 800e63a:	f7fd fa88 	bl	800bb4e <wolfSSL_ASN1_OBJECT_free>
                wolfSSL_ASN1_TYPE_free(name->d.otherName->value);
 800e63e:	687b      	ldr	r3, [r7, #4]
 800e640:	685b      	ldr	r3, [r3, #4]
 800e642:	685b      	ldr	r3, [r3, #4]
 800e644:	4618      	mov	r0, r3
 800e646:	f7fd fc0d 	bl	800be64 <wolfSSL_ASN1_TYPE_free>
                XFREE(name->d.otherName, NULL, DYNAMIC_TYPE_ASN1);
 800e64a:	687b      	ldr	r3, [r7, #4]
 800e64c:	685b      	ldr	r3, [r3, #4]
 800e64e:	60fb      	str	r3, [r7, #12]
 800e650:	68fb      	ldr	r3, [r7, #12]
 800e652:	2b00      	cmp	r3, #0
 800e654:	d002      	beq.n	800e65c <wolfSSL_GENERAL_NAME_type_free+0xf4>
 800e656:	68f8      	ldr	r0, [r7, #12]
 800e658:	f010 fb2c 	bl	801ecb4 <wolfSSL_Free>
                name->d.otherName = NULL;
 800e65c:	687b      	ldr	r3, [r7, #4]
 800e65e:	2200      	movs	r2, #0
 800e660:	605a      	str	r2, [r3, #4]
            }
            break;
 800e662:	e001      	b.n	800e668 <wolfSSL_GENERAL_NAME_type_free+0x100>
            /* Unsupported: fall through */
        case WOLFSSL_GEN_EDIPARTY:
            /* Unsupported: fall through */
        default:
            WOLFSSL_MSG("wolfSSL_GENERAL_NAME_type_free: possible leak");
            break;
 800e664:	bf00      	nop
 800e666:	e000      	b.n	800e66a <wolfSSL_GENERAL_NAME_type_free+0x102>
            break;
 800e668:	bf00      	nop
        }
    }
}
 800e66a:	bf00      	nop
 800e66c:	3710      	adds	r7, #16
 800e66e:	46bd      	mov	sp, r7
 800e670:	bd80      	pop	{r7, pc}
 800e672:	bf00      	nop

0800e674 <wolfSSL_GENERAL_NAME_free>:
}

/* Frees GENERAL_NAME objects.
*/
void wolfSSL_GENERAL_NAME_free(WOLFSSL_GENERAL_NAME* name)
{
 800e674:	b580      	push	{r7, lr}
 800e676:	b084      	sub	sp, #16
 800e678:	af00      	add	r7, sp, #0
 800e67a:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_GENERAL_NAME_Free");
    if (name != NULL) {
 800e67c:	687b      	ldr	r3, [r7, #4]
 800e67e:	2b00      	cmp	r3, #0
 800e680:	d00a      	beq.n	800e698 <wolfSSL_GENERAL_NAME_free+0x24>
        wolfSSL_GENERAL_NAME_type_free(name);
 800e682:	6878      	ldr	r0, [r7, #4]
 800e684:	f7ff ff70 	bl	800e568 <wolfSSL_GENERAL_NAME_type_free>
        XFREE(name, NULL, DYNAMIC_TYPE_OPENSSL);
 800e688:	687b      	ldr	r3, [r7, #4]
 800e68a:	60fb      	str	r3, [r7, #12]
 800e68c:	68fb      	ldr	r3, [r7, #12]
 800e68e:	2b00      	cmp	r3, #0
 800e690:	d002      	beq.n	800e698 <wolfSSL_GENERAL_NAME_free+0x24>
 800e692:	68f8      	ldr	r0, [r7, #12]
 800e694:	f010 fb0e 	bl	801ecb4 <wolfSSL_Free>
    }
}
 800e698:	bf00      	nop
 800e69a:	3710      	adds	r7, #16
 800e69c:	46bd      	mov	sp, r7
 800e69e:	bd80      	pop	{r7, pc}

0800e6a0 <wolfSSL_sk_X509_EXTENSION_pop_free>:

/* frees all of the nodes and the values in stack */
void wolfSSL_sk_X509_EXTENSION_pop_free(
        WOLF_STACK_OF(WOLFSSL_X509_EXTENSION)* sk,
        void (*f) (WOLFSSL_X509_EXTENSION*))
{
 800e6a0:	b580      	push	{r7, lr}
 800e6a2:	b082      	sub	sp, #8
 800e6a4:	af00      	add	r7, sp, #0
 800e6a6:	6078      	str	r0, [r7, #4]
 800e6a8:	6039      	str	r1, [r7, #0]
    wolfSSL_sk_pop_free(sk, (wolfSSL_sk_freefunc)f);
 800e6aa:	6839      	ldr	r1, [r7, #0]
 800e6ac:	6878      	ldr	r0, [r7, #4]
 800e6ae:	f7ff fbf1 	bl	800de94 <wolfSSL_sk_pop_free>
}
 800e6b2:	bf00      	nop
 800e6b4:	3708      	adds	r7, #8
 800e6b6:	46bd      	mov	sp, r7
 800e6b8:	bd80      	pop	{r7, pc}

0800e6ba <wolfSSL_X509_new_ex>:

/* returns a pointer to a new WOLFSSL_X509 structure on success and NULL on
 * fail
 */
WOLFSSL_X509* wolfSSL_X509_new_ex(void* heap)
{
 800e6ba:	b580      	push	{r7, lr}
 800e6bc:	b084      	sub	sp, #16
 800e6be:	af00      	add	r7, sp, #0
 800e6c0:	6078      	str	r0, [r7, #4]
    WOLFSSL_X509* x509;

    x509 = (WOLFSSL_X509*)XMALLOC(sizeof(WOLFSSL_X509), heap,
 800e6c2:	f640 40d4 	movw	r0, #3284	@ 0xcd4
 800e6c6:	f010 fad9 	bl	801ec7c <wolfSSL_Malloc>
 800e6ca:	60f8      	str	r0, [r7, #12]
            DYNAMIC_TYPE_X509);
    if (x509 != NULL) {
 800e6cc:	68fb      	ldr	r3, [r7, #12]
 800e6ce:	2b00      	cmp	r3, #0
 800e6d0:	d004      	beq.n	800e6dc <wolfSSL_X509_new_ex+0x22>
        InitX509(x509, 1, heap);
 800e6d2:	687a      	ldr	r2, [r7, #4]
 800e6d4:	2101      	movs	r1, #1
 800e6d6:	68f8      	ldr	r0, [r7, #12]
 800e6d8:	f7fa ffe4 	bl	80096a4 <InitX509>
    }

    return x509;
 800e6dc:	68fb      	ldr	r3, [r7, #12]
}
 800e6de:	4618      	mov	r0, r3
 800e6e0:	3710      	adds	r7, #16
 800e6e2:	46bd      	mov	sp, r7
 800e6e4:	bd80      	pop	{r7, pc}

0800e6e6 <wolfSSL_X509_NAME_free>:
}
#endif

#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    void wolfSSL_X509_NAME_free(WOLFSSL_X509_NAME *name)
    {
 800e6e6:	b580      	push	{r7, lr}
 800e6e8:	b084      	sub	sp, #16
 800e6ea:	af00      	add	r7, sp, #0
 800e6ec:	6078      	str	r0, [r7, #4]
        WOLFSSL_ENTER("wolfSSL_X509_NAME_free");
        FreeX509Name(name);
 800e6ee:	6878      	ldr	r0, [r7, #4]
 800e6f0:	f7fa ff73 	bl	80095da <FreeX509Name>
        if (name != NULL) {
 800e6f4:	687b      	ldr	r3, [r7, #4]
 800e6f6:	2b00      	cmp	r3, #0
 800e6f8:	d007      	beq.n	800e70a <wolfSSL_X509_NAME_free+0x24>
            XFREE(name, name->heap, DYNAMIC_TYPE_X509);
 800e6fa:	687b      	ldr	r3, [r7, #4]
 800e6fc:	60fb      	str	r3, [r7, #12]
 800e6fe:	68fb      	ldr	r3, [r7, #12]
 800e700:	2b00      	cmp	r3, #0
 800e702:	d002      	beq.n	800e70a <wolfSSL_X509_NAME_free+0x24>
 800e704:	68f8      	ldr	r0, [r7, #12]
 800e706:	f010 fad5 	bl	801ecb4 <wolfSSL_Free>
        }
    }
 800e70a:	bf00      	nop
 800e70c:	3710      	adds	r7, #16
 800e70e:	46bd      	mov	sp, r7
 800e710:	bd80      	pop	{r7, pc}

0800e712 <wolfSSL_X509_NAME_new_ex>:
    /* Malloc's a new WOLFSSL_X509_NAME structure
     *
     * returns NULL on failure, otherwise returns a new structure.
     */
    WOLFSSL_X509_NAME* wolfSSL_X509_NAME_new_ex(void *heap)
    {
 800e712:	b580      	push	{r7, lr}
 800e714:	b084      	sub	sp, #16
 800e716:	af00      	add	r7, sp, #0
 800e718:	6078      	str	r0, [r7, #4]
        WOLFSSL_X509_NAME* name;

        WOLFSSL_ENTER("wolfSSL_X509_NAME_new_ex");

        name = (WOLFSSL_X509_NAME*)XMALLOC(sizeof(WOLFSSL_X509_NAME), heap,
 800e71a:	f240 500c 	movw	r0, #1292	@ 0x50c
 800e71e:	f010 faad 	bl	801ec7c <wolfSSL_Malloc>
 800e722:	60f8      	str	r0, [r7, #12]
                DYNAMIC_TYPE_X509);
        if (name != NULL) {
 800e724:	68fb      	ldr	r3, [r7, #12]
 800e726:	2b00      	cmp	r3, #0
 800e728:	d004      	beq.n	800e734 <wolfSSL_X509_NAME_new_ex+0x22>
            InitX509Name(name, 1, heap);
 800e72a:	687a      	ldr	r2, [r7, #4]
 800e72c:	2101      	movs	r1, #1
 800e72e:	68f8      	ldr	r0, [r7, #12]
 800e730:	f7fa ff34 	bl	800959c <InitX509Name>
        }
        return name;
 800e734:	68fb      	ldr	r3, [r7, #12]
    }
 800e736:	4618      	mov	r0, r3
 800e738:	3710      	adds	r7, #16
 800e73a:	46bd      	mov	sp, r7
 800e73c:	bd80      	pop	{r7, pc}

0800e73e <wolfSSL_X509_NAME_ENTRY_free>:
    }
#endif /* !NO_BIO */
#endif /* OPENSSL_ALL */

    void wolfSSL_X509_NAME_ENTRY_free(WOLFSSL_X509_NAME_ENTRY* ne)
    {
 800e73e:	b580      	push	{r7, lr}
 800e740:	b084      	sub	sp, #16
 800e742:	af00      	add	r7, sp, #0
 800e744:	6078      	str	r0, [r7, #4]
        WOLFSSL_ENTER("wolfSSL_X509_NAME_ENTRY_free");
        if (ne != NULL) {
 800e746:	687b      	ldr	r3, [r7, #4]
 800e748:	2b00      	cmp	r3, #0
 800e74a:	d015      	beq.n	800e778 <wolfSSL_X509_NAME_ENTRY_free+0x3a>
            wolfSSL_ASN1_OBJECT_free(ne->object);
 800e74c:	687b      	ldr	r3, [r7, #4]
 800e74e:	681b      	ldr	r3, [r3, #0]
 800e750:	4618      	mov	r0, r3
 800e752:	f7fd f9fc 	bl	800bb4e <wolfSSL_ASN1_OBJECT_free>
            if (ne->value != NULL) {
 800e756:	687b      	ldr	r3, [r7, #4]
 800e758:	685b      	ldr	r3, [r3, #4]
 800e75a:	2b00      	cmp	r3, #0
 800e75c:	d004      	beq.n	800e768 <wolfSSL_X509_NAME_ENTRY_free+0x2a>
                wolfSSL_ASN1_STRING_free(ne->value);
 800e75e:	687b      	ldr	r3, [r7, #4]
 800e760:	685b      	ldr	r3, [r3, #4]
 800e762:	4618      	mov	r0, r3
 800e764:	f7fd fa52 	bl	800bc0c <wolfSSL_ASN1_STRING_free>
            }
            XFREE(ne, NULL, DYNAMIC_TYPE_NAME_ENTRY);
 800e768:	687b      	ldr	r3, [r7, #4]
 800e76a:	60fb      	str	r3, [r7, #12]
 800e76c:	68fb      	ldr	r3, [r7, #12]
 800e76e:	2b00      	cmp	r3, #0
 800e770:	d002      	beq.n	800e778 <wolfSSL_X509_NAME_ENTRY_free+0x3a>
 800e772:	68f8      	ldr	r0, [r7, #12]
 800e774:	f010 fa9e 	bl	801ecb4 <wolfSSL_Free>
        }
    }
 800e778:	bf00      	nop
 800e77a:	3710      	adds	r7, #16
 800e77c:	46bd      	mov	sp, r7
 800e77e:	bd80      	pop	{r7, pc}

0800e780 <wolfSSL_X509_NAME_ENTRY_new>:


    WOLFSSL_X509_NAME_ENTRY* wolfSSL_X509_NAME_ENTRY_new(void)
    {
 800e780:	b580      	push	{r7, lr}
 800e782:	b082      	sub	sp, #8
 800e784:	af00      	add	r7, sp, #0
        WOLFSSL_X509_NAME_ENTRY* ne;

        ne = (WOLFSSL_X509_NAME_ENTRY*)XMALLOC(sizeof(WOLFSSL_X509_NAME_ENTRY),
 800e786:	2014      	movs	r0, #20
 800e788:	f010 fa78 	bl	801ec7c <wolfSSL_Malloc>
 800e78c:	6078      	str	r0, [r7, #4]
                NULL, DYNAMIC_TYPE_NAME_ENTRY);
        if (ne != NULL) {
 800e78e:	687b      	ldr	r3, [r7, #4]
 800e790:	2b00      	cmp	r3, #0
 800e792:	d004      	beq.n	800e79e <wolfSSL_X509_NAME_ENTRY_new+0x1e>
            XMEMSET(ne, 0, sizeof(WOLFSSL_X509_NAME_ENTRY));
 800e794:	2214      	movs	r2, #20
 800e796:	2100      	movs	r1, #0
 800e798:	6878      	ldr	r0, [r7, #4]
 800e79a:	f01a fa43 	bl	8028c24 <memset>
        }

        return ne;
 800e79e:	687b      	ldr	r3, [r7, #4]
    }
 800e7a0:	4618      	mov	r0, r3
 800e7a2:	3708      	adds	r7, #8
 800e7a4:	46bd      	mov	sp, r7
 800e7a6:	bd80      	pop	{r7, pc}

0800e7a8 <wolfssl_x509_name_entry_set>:

    static void wolfssl_x509_name_entry_set(WOLFSSL_X509_NAME_ENTRY* ne,
        int nid, int type, const unsigned char *data, int dataSz)
    {
 800e7a8:	b580      	push	{r7, lr}
 800e7aa:	b084      	sub	sp, #16
 800e7ac:	af00      	add	r7, sp, #0
 800e7ae:	60f8      	str	r0, [r7, #12]
 800e7b0:	60b9      	str	r1, [r7, #8]
 800e7b2:	607a      	str	r2, [r7, #4]
 800e7b4:	603b      	str	r3, [r7, #0]
        ne->nid = nid;
 800e7b6:	68fb      	ldr	r3, [r7, #12]
 800e7b8:	68ba      	ldr	r2, [r7, #8]
 800e7ba:	609a      	str	r2, [r3, #8]
        /* Reuse the object if already available. */
        ne->object = wolfSSL_OBJ_nid2obj_ex(nid, ne->object);
 800e7bc:	68fb      	ldr	r3, [r7, #12]
 800e7be:	681b      	ldr	r3, [r3, #0]
 800e7c0:	4619      	mov	r1, r3
 800e7c2:	68b8      	ldr	r0, [r7, #8]
 800e7c4:	f7ff fbee 	bl	800dfa4 <wolfSSL_OBJ_nid2obj_ex>
 800e7c8:	4602      	mov	r2, r0
 800e7ca:	68fb      	ldr	r3, [r7, #12]
 800e7cc:	601a      	str	r2, [r3, #0]
        if (ne->value == NULL) {
 800e7ce:	68fb      	ldr	r3, [r7, #12]
 800e7d0:	685b      	ldr	r3, [r3, #4]
 800e7d2:	2b00      	cmp	r3, #0
 800e7d4:	d105      	bne.n	800e7e2 <wolfssl_x509_name_entry_set+0x3a>
            ne->value = wolfSSL_ASN1_STRING_type_new(type);
 800e7d6:	6878      	ldr	r0, [r7, #4]
 800e7d8:	f7fd fa06 	bl	800bbe8 <wolfSSL_ASN1_STRING_type_new>
 800e7dc:	4602      	mov	r2, r0
 800e7de:	68fb      	ldr	r3, [r7, #12]
 800e7e0:	605a      	str	r2, [r3, #4]
        }
        if (ne->value != NULL) {
 800e7e2:	68fb      	ldr	r3, [r7, #12]
 800e7e4:	685b      	ldr	r3, [r3, #4]
 800e7e6:	2b00      	cmp	r3, #0
 800e7e8:	d015      	beq.n	800e816 <wolfssl_x509_name_entry_set+0x6e>
            if (wolfSSL_ASN1_STRING_set(ne->value, (const void*)data,
 800e7ea:	68fb      	ldr	r3, [r7, #12]
 800e7ec:	685b      	ldr	r3, [r3, #4]
 800e7ee:	69ba      	ldr	r2, [r7, #24]
 800e7f0:	6839      	ldr	r1, [r7, #0]
 800e7f2:	4618      	mov	r0, r3
 800e7f4:	f7fd fa6b 	bl	800bcce <wolfSSL_ASN1_STRING_set>
 800e7f8:	4603      	mov	r3, r0
 800e7fa:	2b01      	cmp	r3, #1
 800e7fc:	d103      	bne.n	800e806 <wolfssl_x509_name_entry_set+0x5e>
                                            dataSz) == WOLFSSL_SUCCESS) {
                ne->set = 1;
 800e7fe:	68fb      	ldr	r3, [r7, #12]
 800e800:	2201      	movs	r2, #1
 800e802:	60da      	str	r2, [r3, #12]
                /* Free the ASN1_STRING if it is not set. */
                wolfSSL_ASN1_STRING_free(ne->value);
                ne->value = NULL;
            }
        }
    }
 800e804:	e007      	b.n	800e816 <wolfssl_x509_name_entry_set+0x6e>
                wolfSSL_ASN1_STRING_free(ne->value);
 800e806:	68fb      	ldr	r3, [r7, #12]
 800e808:	685b      	ldr	r3, [r3, #4]
 800e80a:	4618      	mov	r0, r3
 800e80c:	f7fd f9fe 	bl	800bc0c <wolfSSL_ASN1_STRING_free>
                ne->value = NULL;
 800e810:	68fb      	ldr	r3, [r7, #12]
 800e812:	2200      	movs	r2, #0
 800e814:	605a      	str	r2, [r3, #4]
    }
 800e816:	bf00      	nop
 800e818:	3710      	adds	r7, #16
 800e81a:	46bd      	mov	sp, r7
 800e81c:	bd80      	pop	{r7, pc}

0800e81e <wolfSSL_X509_NAME_ENTRY_create_by_NID>:
     * returns a pointer to WOLFSSL_X509_NAME_ENTRY on success and NULL on fail
     */
    WOLFSSL_X509_NAME_ENTRY* wolfSSL_X509_NAME_ENTRY_create_by_NID(
            WOLFSSL_X509_NAME_ENTRY** out, int nid, int type,
            const unsigned char* data, int dataSz)
    {
 800e81e:	b580      	push	{r7, lr}
 800e820:	b088      	sub	sp, #32
 800e822:	af02      	add	r7, sp, #8
 800e824:	60f8      	str	r0, [r7, #12]
 800e826:	60b9      	str	r1, [r7, #8]
 800e828:	607a      	str	r2, [r7, #4]
 800e82a:	603b      	str	r3, [r7, #0]

#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_X509_NAME_ENTRY_create_by_NID");
#endif

        if (!data) {
 800e82c:	683b      	ldr	r3, [r7, #0]
 800e82e:	2b00      	cmp	r3, #0
 800e830:	d101      	bne.n	800e836 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x18>
            WOLFSSL_MSG("Bad parameter");
            return NULL;
 800e832:	2300      	movs	r3, #0
 800e834:	e021      	b.n	800e87a <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x5c>
        }

        if (out == NULL || *out == NULL) {
 800e836:	68fb      	ldr	r3, [r7, #12]
 800e838:	2b00      	cmp	r3, #0
 800e83a:	d003      	beq.n	800e844 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x26>
 800e83c:	68fb      	ldr	r3, [r7, #12]
 800e83e:	681b      	ldr	r3, [r3, #0]
 800e840:	2b00      	cmp	r3, #0
 800e842:	d10e      	bne.n	800e862 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x44>
            ne = wolfSSL_X509_NAME_ENTRY_new();
 800e844:	f7ff ff9c 	bl	800e780 <wolfSSL_X509_NAME_ENTRY_new>
 800e848:	6178      	str	r0, [r7, #20]
            if (ne == NULL) {
 800e84a:	697b      	ldr	r3, [r7, #20]
 800e84c:	2b00      	cmp	r3, #0
 800e84e:	d101      	bne.n	800e854 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x36>
                return NULL;
 800e850:	2300      	movs	r3, #0
 800e852:	e012      	b.n	800e87a <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x5c>
            }
            if (out != NULL) {
 800e854:	68fb      	ldr	r3, [r7, #12]
 800e856:	2b00      	cmp	r3, #0
 800e858:	d006      	beq.n	800e868 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x4a>
                *out = ne;
 800e85a:	68fb      	ldr	r3, [r7, #12]
 800e85c:	697a      	ldr	r2, [r7, #20]
 800e85e:	601a      	str	r2, [r3, #0]
            if (out != NULL) {
 800e860:	e002      	b.n	800e868 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x4a>
            }
        }
        else {
            ne = *out;
 800e862:	68fb      	ldr	r3, [r7, #12]
 800e864:	681b      	ldr	r3, [r3, #0]
 800e866:	617b      	str	r3, [r7, #20]
        }

        wolfssl_x509_name_entry_set(ne, nid, type, data, dataSz);
 800e868:	6a3b      	ldr	r3, [r7, #32]
 800e86a:	9300      	str	r3, [sp, #0]
 800e86c:	683b      	ldr	r3, [r7, #0]
 800e86e:	687a      	ldr	r2, [r7, #4]
 800e870:	68b9      	ldr	r1, [r7, #8]
 800e872:	6978      	ldr	r0, [r7, #20]
 800e874:	f7ff ff98 	bl	800e7a8 <wolfssl_x509_name_entry_set>

        return ne;
 800e878:	697b      	ldr	r3, [r7, #20]
    }
 800e87a:	4618      	mov	r0, r3
 800e87c:	3718      	adds	r7, #24
 800e87e:	46bd      	mov	sp, r7
 800e880:	bd80      	pop	{r7, pc}

0800e882 <wolfSSL_X509_NAME_ENTRY_get_object>:
    defined(HAVE_LIGHTY) || defined(WOLFSSL_MYSQL_COMPATIBLE) || \
    defined(HAVE_STUNNEL) || defined(WOLFSSL_NGINX) || \
    defined(HAVE_POCO_LIB) || defined(WOLFSSL_HAPROXY)
WOLFSSL_ASN1_OBJECT* wolfSSL_X509_NAME_ENTRY_get_object(
    WOLFSSL_X509_NAME_ENTRY *ne)
{
 800e882:	b580      	push	{r7, lr}
 800e884:	b084      	sub	sp, #16
 800e886:	af00      	add	r7, sp, #0
 800e888:	6078      	str	r0, [r7, #4]
    WOLFSSL_ASN1_OBJECT* object = NULL;
 800e88a:	2300      	movs	r3, #0
 800e88c:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_X509_NAME_ENTRY_get_object");
#endif

    if (ne != NULL) {
 800e88e:	687b      	ldr	r3, [r7, #4]
 800e890:	2b00      	cmp	r3, #0
 800e892:	d00e      	beq.n	800e8b2 <wolfSSL_X509_NAME_ENTRY_get_object+0x30>
        /* Create object from nid - reuse existing object if possible. */
        object = wolfSSL_OBJ_nid2obj_ex(ne->nid, ne->object);
 800e894:	687b      	ldr	r3, [r7, #4]
 800e896:	689a      	ldr	r2, [r3, #8]
 800e898:	687b      	ldr	r3, [r7, #4]
 800e89a:	681b      	ldr	r3, [r3, #0]
 800e89c:	4619      	mov	r1, r3
 800e89e:	4610      	mov	r0, r2
 800e8a0:	f7ff fb80 	bl	800dfa4 <wolfSSL_OBJ_nid2obj_ex>
 800e8a4:	60f8      	str	r0, [r7, #12]
        if (object != NULL) {
 800e8a6:	68fb      	ldr	r3, [r7, #12]
 800e8a8:	2b00      	cmp	r3, #0
 800e8aa:	d002      	beq.n	800e8b2 <wolfSSL_X509_NAME_ENTRY_get_object+0x30>
            /* Set the object when no error. */
            ne->object = object;
 800e8ac:	687b      	ldr	r3, [r7, #4]
 800e8ae:	68fa      	ldr	r2, [r7, #12]
 800e8b0:	601a      	str	r2, [r3, #0]
        }
    }

    return object;
 800e8b2:	68fb      	ldr	r3, [r7, #12]
}
 800e8b4:	4618      	mov	r0, r3
 800e8b6:	3710      	adds	r7, #16
 800e8b8:	46bd      	mov	sp, r7
 800e8ba:	bd80      	pop	{r7, pc}

0800e8bc <AddAllEntry>:
     * since number of entries is small, a brute force search is used here
     * returns the number of entries added
     */
    static int AddAllEntry(WOLFSSL_X509_NAME* name, char* fullName,
            int fullNameSz, int* idx)
    {
 800e8bc:	b580      	push	{r7, lr}
 800e8be:	b08a      	sub	sp, #40	@ 0x28
 800e8c0:	af00      	add	r7, sp, #0
 800e8c2:	60f8      	str	r0, [r7, #12]
 800e8c4:	60b9      	str	r1, [r7, #8]
 800e8c6:	607a      	str	r2, [r7, #4]
 800e8c8:	603b      	str	r3, [r7, #0]
        int i;
        int ret = 0;
 800e8ca:	2300      	movs	r3, #0
 800e8cc:	623b      	str	r3, [r7, #32]

        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e8ce:	2300      	movs	r3, #0
 800e8d0:	627b      	str	r3, [r7, #36]	@ 0x24
 800e8d2:	e07a      	b.n	800e9ca <AddAllEntry+0x10e>
            if (name->entry[i].set) {
 800e8d4:	68f9      	ldr	r1, [r7, #12]
 800e8d6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e8d8:	4613      	mov	r3, r2
 800e8da:	009b      	lsls	r3, r3, #2
 800e8dc:	4413      	add	r3, r2
 800e8de:	009b      	lsls	r3, r3, #2
 800e8e0:	440b      	add	r3, r1
 800e8e2:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800e8e6:	681b      	ldr	r3, [r3, #0]
 800e8e8:	2b00      	cmp	r3, #0
 800e8ea:	d06b      	beq.n	800e9c4 <AddAllEntry+0x108>
                WOLFSSL_ASN1_OBJECT* obj;

                int sz;
                unsigned char* data;

                e = &name->entry[i];
 800e8ec:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e8ee:	4613      	mov	r3, r2
 800e8f0:	009b      	lsls	r3, r3, #2
 800e8f2:	4413      	add	r3, r2
 800e8f4:	009b      	lsls	r3, r3, #2
 800e8f6:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800e8fa:	68fa      	ldr	r2, [r7, #12]
 800e8fc:	4413      	add	r3, r2
 800e8fe:	3304      	adds	r3, #4
 800e900:	61fb      	str	r3, [r7, #28]
                obj = wolfSSL_X509_NAME_ENTRY_get_object(e);
 800e902:	69f8      	ldr	r0, [r7, #28]
 800e904:	f7ff ffbd 	bl	800e882 <wolfSSL_X509_NAME_ENTRY_get_object>
 800e908:	61b8      	str	r0, [r7, #24]
                if (obj == NULL) {
 800e90a:	69bb      	ldr	r3, [r7, #24]
 800e90c:	2b00      	cmp	r3, #0
 800e90e:	d102      	bne.n	800e916 <AddAllEntry+0x5a>
                    return BAD_FUNC_ARG;
 800e910:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800e914:	e05d      	b.n	800e9d2 <AddAllEntry+0x116>
                }

                XMEMCPY(fullName + *idx, "/", 1); *idx = *idx + 1;
 800e916:	683b      	ldr	r3, [r7, #0]
 800e918:	681b      	ldr	r3, [r3, #0]
 800e91a:	461a      	mov	r2, r3
 800e91c:	68bb      	ldr	r3, [r7, #8]
 800e91e:	4413      	add	r3, r2
 800e920:	2201      	movs	r2, #1
 800e922:	492e      	ldr	r1, [pc, #184]	@ (800e9dc <AddAllEntry+0x120>)
 800e924:	4618      	mov	r0, r3
 800e926:	f01a fa2e 	bl	8028d86 <memcpy>
 800e92a:	683b      	ldr	r3, [r7, #0]
 800e92c:	681b      	ldr	r3, [r3, #0]
 800e92e:	1c5a      	adds	r2, r3, #1
 800e930:	683b      	ldr	r3, [r7, #0]
 800e932:	601a      	str	r2, [r3, #0]
                sz = (int)XSTRLEN(obj->sName);
 800e934:	69bb      	ldr	r3, [r7, #24]
 800e936:	3308      	adds	r3, #8
 800e938:	4618      	mov	r0, r3
 800e93a:	f7f1 fc53 	bl	80001e4 <strlen>
 800e93e:	4603      	mov	r3, r0
 800e940:	617b      	str	r3, [r7, #20]
                XMEMCPY(fullName + *idx, obj->sName, sz);
 800e942:	683b      	ldr	r3, [r7, #0]
 800e944:	681b      	ldr	r3, [r3, #0]
 800e946:	461a      	mov	r2, r3
 800e948:	68bb      	ldr	r3, [r7, #8]
 800e94a:	1898      	adds	r0, r3, r2
 800e94c:	69bb      	ldr	r3, [r7, #24]
 800e94e:	3308      	adds	r3, #8
 800e950:	697a      	ldr	r2, [r7, #20]
 800e952:	4619      	mov	r1, r3
 800e954:	f01a fa17 	bl	8028d86 <memcpy>
                *idx += sz;
 800e958:	683b      	ldr	r3, [r7, #0]
 800e95a:	681a      	ldr	r2, [r3, #0]
 800e95c:	697b      	ldr	r3, [r7, #20]
 800e95e:	441a      	add	r2, r3
 800e960:	683b      	ldr	r3, [r7, #0]
 800e962:	601a      	str	r2, [r3, #0]
                XMEMCPY(fullName + *idx, "=", 1); *idx = *idx + 1;
 800e964:	683b      	ldr	r3, [r7, #0]
 800e966:	681b      	ldr	r3, [r3, #0]
 800e968:	461a      	mov	r2, r3
 800e96a:	68bb      	ldr	r3, [r7, #8]
 800e96c:	4413      	add	r3, r2
 800e96e:	2201      	movs	r2, #1
 800e970:	491b      	ldr	r1, [pc, #108]	@ (800e9e0 <AddAllEntry+0x124>)
 800e972:	4618      	mov	r0, r3
 800e974:	f01a fa07 	bl	8028d86 <memcpy>
 800e978:	683b      	ldr	r3, [r7, #0]
 800e97a:	681b      	ldr	r3, [r3, #0]
 800e97c:	1c5a      	adds	r2, r3, #1
 800e97e:	683b      	ldr	r3, [r7, #0]
 800e980:	601a      	str	r2, [r3, #0]

                data = wolfSSL_ASN1_STRING_data(e->value);
 800e982:	69fb      	ldr	r3, [r7, #28]
 800e984:	685b      	ldr	r3, [r3, #4]
 800e986:	4618      	mov	r0, r3
 800e988:	f7fd f97b 	bl	800bc82 <wolfSSL_ASN1_STRING_data>
 800e98c:	6138      	str	r0, [r7, #16]
                if (data != NULL) {
 800e98e:	693b      	ldr	r3, [r7, #16]
 800e990:	2b00      	cmp	r3, #0
 800e992:	d014      	beq.n	800e9be <AddAllEntry+0x102>
                    sz = (int)XSTRLEN((const char*)data);
 800e994:	6938      	ldr	r0, [r7, #16]
 800e996:	f7f1 fc25 	bl	80001e4 <strlen>
 800e99a:	4603      	mov	r3, r0
 800e99c:	617b      	str	r3, [r7, #20]
                    XMEMCPY(fullName + *idx, data, sz);
 800e99e:	683b      	ldr	r3, [r7, #0]
 800e9a0:	681b      	ldr	r3, [r3, #0]
 800e9a2:	461a      	mov	r2, r3
 800e9a4:	68bb      	ldr	r3, [r7, #8]
 800e9a6:	4413      	add	r3, r2
 800e9a8:	697a      	ldr	r2, [r7, #20]
 800e9aa:	6939      	ldr	r1, [r7, #16]
 800e9ac:	4618      	mov	r0, r3
 800e9ae:	f01a f9ea 	bl	8028d86 <memcpy>
                    *idx += sz;
 800e9b2:	683b      	ldr	r3, [r7, #0]
 800e9b4:	681a      	ldr	r2, [r3, #0]
 800e9b6:	697b      	ldr	r3, [r7, #20]
 800e9b8:	441a      	add	r2, r3
 800e9ba:	683b      	ldr	r3, [r7, #0]
 800e9bc:	601a      	str	r2, [r3, #0]
                }

                ret++;
 800e9be:	6a3b      	ldr	r3, [r7, #32]
 800e9c0:	3301      	adds	r3, #1
 800e9c2:	623b      	str	r3, [r7, #32]
        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e9c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e9c6:	3301      	adds	r3, #1
 800e9c8:	627b      	str	r3, [r7, #36]	@ 0x24
 800e9ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e9cc:	2b0f      	cmp	r3, #15
 800e9ce:	dd81      	ble.n	800e8d4 <AddAllEntry+0x18>
            }
        }
        (void)fullNameSz;
        return ret;
 800e9d0:	6a3b      	ldr	r3, [r7, #32]
    }
 800e9d2:	4618      	mov	r0, r3
 800e9d4:	3728      	adds	r7, #40	@ 0x28
 800e9d6:	46bd      	mov	sp, r7
 800e9d8:	bd80      	pop	{r7, pc}
 800e9da:	bf00      	nop
 800e9dc:	0802aeec 	.word	0x0802aeec
 800e9e0:	0802bc18 	.word	0x0802bc18

0800e9e4 <RebuildFullName>:


    /* Converts a list of entries in WOLFSSL_X509_NAME struct into a string
     * returns 0 on success */
    static int RebuildFullName(WOLFSSL_X509_NAME* name)
    {
 800e9e4:	b580      	push	{r7, lr}
 800e9e6:	b08a      	sub	sp, #40	@ 0x28
 800e9e8:	af00      	add	r7, sp, #0
 800e9ea:	6078      	str	r0, [r7, #4]
        int totalLen = 0, i, idx, entryCount = 0;
 800e9ec:	2300      	movs	r3, #0
 800e9ee:	627b      	str	r3, [r7, #36]	@ 0x24
 800e9f0:	2300      	movs	r3, #0
 800e9f2:	61fb      	str	r3, [r7, #28]

        if (name == NULL)
 800e9f4:	687b      	ldr	r3, [r7, #4]
 800e9f6:	2b00      	cmp	r3, #0
 800e9f8:	d102      	bne.n	800ea00 <RebuildFullName+0x1c>
            return BAD_FUNC_ARG;
 800e9fa:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800e9fe:	e086      	b.n	800eb0e <RebuildFullName+0x12a>

        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800ea00:	2300      	movs	r3, #0
 800ea02:	623b      	str	r3, [r7, #32]
 800ea04:	e036      	b.n	800ea74 <RebuildFullName+0x90>
            if (name->entry[i].set) {
 800ea06:	6879      	ldr	r1, [r7, #4]
 800ea08:	6a3a      	ldr	r2, [r7, #32]
 800ea0a:	4613      	mov	r3, r2
 800ea0c:	009b      	lsls	r3, r3, #2
 800ea0e:	4413      	add	r3, r2
 800ea10:	009b      	lsls	r3, r3, #2
 800ea12:	440b      	add	r3, r1
 800ea14:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800ea18:	681b      	ldr	r3, [r3, #0]
 800ea1a:	2b00      	cmp	r3, #0
 800ea1c:	d027      	beq.n	800ea6e <RebuildFullName+0x8a>
                WOLFSSL_X509_NAME_ENTRY* e;
                WOLFSSL_ASN1_OBJECT* obj;

                e = &name->entry[i];
 800ea1e:	6a3a      	ldr	r2, [r7, #32]
 800ea20:	4613      	mov	r3, r2
 800ea22:	009b      	lsls	r3, r3, #2
 800ea24:	4413      	add	r3, r2
 800ea26:	009b      	lsls	r3, r3, #2
 800ea28:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800ea2c:	687a      	ldr	r2, [r7, #4]
 800ea2e:	4413      	add	r3, r2
 800ea30:	3304      	adds	r3, #4
 800ea32:	617b      	str	r3, [r7, #20]
                obj = wolfSSL_X509_NAME_ENTRY_get_object(e);
 800ea34:	6978      	ldr	r0, [r7, #20]
 800ea36:	f7ff ff24 	bl	800e882 <wolfSSL_X509_NAME_ENTRY_get_object>
 800ea3a:	6138      	str	r0, [r7, #16]
                if (obj == NULL)
 800ea3c:	693b      	ldr	r3, [r7, #16]
 800ea3e:	2b00      	cmp	r3, #0
 800ea40:	d102      	bne.n	800ea48 <RebuildFullName+0x64>
                    return BAD_FUNC_ARG;
 800ea42:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800ea46:	e062      	b.n	800eb0e <RebuildFullName+0x12a>

                totalLen += (int)XSTRLEN(obj->sName) + 2;/*+2 for '/' and '=' */
 800ea48:	693b      	ldr	r3, [r7, #16]
 800ea4a:	3308      	adds	r3, #8
 800ea4c:	4618      	mov	r0, r3
 800ea4e:	f7f1 fbc9 	bl	80001e4 <strlen>
 800ea52:	4603      	mov	r3, r0
 800ea54:	3302      	adds	r3, #2
 800ea56:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ea58:	4413      	add	r3, r2
 800ea5a:	627b      	str	r3, [r7, #36]	@ 0x24
                totalLen += wolfSSL_ASN1_STRING_length(e->value);
 800ea5c:	697b      	ldr	r3, [r7, #20]
 800ea5e:	685b      	ldr	r3, [r3, #4]
 800ea60:	4618      	mov	r0, r3
 800ea62:	f7fd f921 	bl	800bca8 <wolfSSL_ASN1_STRING_length>
 800ea66:	4602      	mov	r2, r0
 800ea68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ea6a:	4413      	add	r3, r2
 800ea6c:	627b      	str	r3, [r7, #36]	@ 0x24
        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800ea6e:	6a3b      	ldr	r3, [r7, #32]
 800ea70:	3301      	adds	r3, #1
 800ea72:	623b      	str	r3, [r7, #32]
 800ea74:	6a3b      	ldr	r3, [r7, #32]
 800ea76:	2b0f      	cmp	r3, #15
 800ea78:	ddc5      	ble.n	800ea06 <RebuildFullName+0x22>
            }
        }

        if (name->dynamicName) {
 800ea7a:	687b      	ldr	r3, [r7, #4]
 800ea7c:	685b      	ldr	r3, [r3, #4]
 800ea7e:	2b00      	cmp	r3, #0
 800ea80:	d010      	beq.n	800eaa4 <RebuildFullName+0xc0>
            XFREE(name->name, name->heap, DYNAMIC_TYPE_X509);
 800ea82:	687b      	ldr	r3, [r7, #4]
 800ea84:	681b      	ldr	r3, [r3, #0]
 800ea86:	61bb      	str	r3, [r7, #24]
 800ea88:	69bb      	ldr	r3, [r7, #24]
 800ea8a:	2b00      	cmp	r3, #0
 800ea8c:	d002      	beq.n	800ea94 <RebuildFullName+0xb0>
 800ea8e:	69b8      	ldr	r0, [r7, #24]
 800ea90:	f010 f910 	bl	801ecb4 <wolfSSL_Free>
            name->name = name->staticName;
 800ea94:	687b      	ldr	r3, [r7, #4]
 800ea96:	f103 020c 	add.w	r2, r3, #12
 800ea9a:	687b      	ldr	r3, [r7, #4]
 800ea9c:	601a      	str	r2, [r3, #0]
            name->dynamicName = 0;
 800ea9e:	687b      	ldr	r3, [r7, #4]
 800eaa0:	2200      	movs	r2, #0
 800eaa2:	605a      	str	r2, [r3, #4]
        }

        if (totalLen >= ASN_NAME_MAX) {
 800eaa4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800eaa6:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 800eaaa:	db11      	blt.n	800ead0 <RebuildFullName+0xec>
            name->name = (char*)XMALLOC(totalLen + 1, name->heap,
 800eaac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800eaae:	3301      	adds	r3, #1
 800eab0:	4618      	mov	r0, r3
 800eab2:	f010 f8e3 	bl	801ec7c <wolfSSL_Malloc>
 800eab6:	4602      	mov	r2, r0
 800eab8:	687b      	ldr	r3, [r7, #4]
 800eaba:	601a      	str	r2, [r3, #0]
                    DYNAMIC_TYPE_X509);
            if (name->name == NULL)
 800eabc:	687b      	ldr	r3, [r7, #4]
 800eabe:	681b      	ldr	r3, [r3, #0]
 800eac0:	2b00      	cmp	r3, #0
 800eac2:	d102      	bne.n	800eaca <RebuildFullName+0xe6>
                return MEMORY_E;
 800eac4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800eac8:	e021      	b.n	800eb0e <RebuildFullName+0x12a>
            name->dynamicName = 1;
 800eaca:	687b      	ldr	r3, [r7, #4]
 800eacc:	2201      	movs	r2, #1
 800eace:	605a      	str	r2, [r3, #4]
        }

        idx = 0;
 800ead0:	2300      	movs	r3, #0
 800ead2:	60fb      	str	r3, [r7, #12]
        entryCount = AddAllEntry(name, name->name, totalLen, &idx);
 800ead4:	687b      	ldr	r3, [r7, #4]
 800ead6:	6819      	ldr	r1, [r3, #0]
 800ead8:	f107 030c 	add.w	r3, r7, #12
 800eadc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800eade:	6878      	ldr	r0, [r7, #4]
 800eae0:	f7ff feec 	bl	800e8bc <AddAllEntry>
 800eae4:	61f8      	str	r0, [r7, #28]
        if (entryCount < 0)
 800eae6:	69fb      	ldr	r3, [r7, #28]
 800eae8:	2b00      	cmp	r3, #0
 800eaea:	da01      	bge.n	800eaf0 <RebuildFullName+0x10c>
            return entryCount;
 800eaec:	69fb      	ldr	r3, [r7, #28]
 800eaee:	e00e      	b.n	800eb0e <RebuildFullName+0x12a>

        name->name[idx] = '\0';
 800eaf0:	687b      	ldr	r3, [r7, #4]
 800eaf2:	681b      	ldr	r3, [r3, #0]
 800eaf4:	68fa      	ldr	r2, [r7, #12]
 800eaf6:	4413      	add	r3, r2
 800eaf8:	2200      	movs	r2, #0
 800eafa:	701a      	strb	r2, [r3, #0]
        name->sz = idx + 1; /* size includes null terminator */
 800eafc:	68fb      	ldr	r3, [r7, #12]
 800eafe:	1c5a      	adds	r2, r3, #1
 800eb00:	687b      	ldr	r3, [r7, #4]
 800eb02:	609a      	str	r2, [r3, #8]
        name->entrySz = entryCount;
 800eb04:	687b      	ldr	r3, [r7, #4]
 800eb06:	69fa      	ldr	r2, [r7, #28]
 800eb08:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250

        return 0;
 800eb0c:	2300      	movs	r3, #0
    }
 800eb0e:	4618      	mov	r0, r3
 800eb10:	3728      	adds	r7, #40	@ 0x28
 800eb12:	46bd      	mov	sp, r7
 800eb14:	bd80      	pop	{r7, pc}

0800eb16 <wolfSSL_X509_NAME_add_entry>:
    /* Copies entry into name. With it being copied freeing entry becomes the
     * callers responsibility.
     * returns 1 for success and 0 for error */
    int wolfSSL_X509_NAME_add_entry(WOLFSSL_X509_NAME* name,
            WOLFSSL_X509_NAME_ENTRY* entry, int idx, int set)
    {
 800eb16:	b5f0      	push	{r4, r5, r6, r7, lr}
 800eb18:	b08b      	sub	sp, #44	@ 0x2c
 800eb1a:	af02      	add	r7, sp, #8
 800eb1c:	60f8      	str	r0, [r7, #12]
 800eb1e:	60b9      	str	r1, [r7, #8]
 800eb20:	607a      	str	r2, [r7, #4]
 800eb22:	603b      	str	r3, [r7, #0]
        WOLFSSL_X509_NAME_ENTRY* current = NULL;
 800eb24:	2300      	movs	r3, #0
 800eb26:	617b      	str	r3, [r7, #20]

#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_X509_NAME_add_entry");
#endif

        if (name == NULL || entry == NULL || entry->value == NULL) {
 800eb28:	68fb      	ldr	r3, [r7, #12]
 800eb2a:	2b00      	cmp	r3, #0
 800eb2c:	d006      	beq.n	800eb3c <wolfSSL_X509_NAME_add_entry+0x26>
 800eb2e:	68bb      	ldr	r3, [r7, #8]
 800eb30:	2b00      	cmp	r3, #0
 800eb32:	d003      	beq.n	800eb3c <wolfSSL_X509_NAME_add_entry+0x26>
 800eb34:	68bb      	ldr	r3, [r7, #8]
 800eb36:	685b      	ldr	r3, [r3, #4]
 800eb38:	2b00      	cmp	r3, #0
 800eb3a:	d101      	bne.n	800eb40 <wolfSSL_X509_NAME_add_entry+0x2a>
            WOLFSSL_MSG("NULL argument passed in");
            return WOLFSSL_FAILURE;
 800eb3c:	2300      	movs	r3, #0
 800eb3e:	e079      	b.n	800ec34 <wolfSSL_X509_NAME_add_entry+0x11e>
        }

        if (idx >= 0) {
 800eb40:	687b      	ldr	r3, [r7, #4]
 800eb42:	2b00      	cmp	r3, #0
 800eb44:	db07      	blt.n	800eb56 <wolfSSL_X509_NAME_add_entry+0x40>
            /* place in specific index */

            if (idx >= MAX_NAME_ENTRIES) {
 800eb46:	687b      	ldr	r3, [r7, #4]
 800eb48:	2b0f      	cmp	r3, #15
 800eb4a:	dd01      	ble.n	800eb50 <wolfSSL_X509_NAME_add_entry+0x3a>
                WOLFSSL_MSG("Error index to insert entry is larger than array");
                return WOLFSSL_FAILURE;
 800eb4c:	2300      	movs	r3, #0
 800eb4e:	e071      	b.n	800ec34 <wolfSSL_X509_NAME_add_entry+0x11e>
            }
            i = idx;
 800eb50:	687b      	ldr	r3, [r7, #4]
 800eb52:	61bb      	str	r3, [r7, #24]
 800eb54:	e01b      	b.n	800eb8e <wolfSSL_X509_NAME_add_entry+0x78>
        }
        else {
            /* iterate through and find first open spot */
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800eb56:	2300      	movs	r3, #0
 800eb58:	61bb      	str	r3, [r7, #24]
 800eb5a:	e00e      	b.n	800eb7a <wolfSSL_X509_NAME_add_entry+0x64>
                if (name->entry[i].set != 1) { /* not set so overwritten */
 800eb5c:	68f9      	ldr	r1, [r7, #12]
 800eb5e:	69ba      	ldr	r2, [r7, #24]
 800eb60:	4613      	mov	r3, r2
 800eb62:	009b      	lsls	r3, r3, #2
 800eb64:	4413      	add	r3, r2
 800eb66:	009b      	lsls	r3, r3, #2
 800eb68:	440b      	add	r3, r1
 800eb6a:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800eb6e:	681b      	ldr	r3, [r3, #0]
 800eb70:	2b01      	cmp	r3, #1
 800eb72:	d106      	bne.n	800eb82 <wolfSSL_X509_NAME_add_entry+0x6c>
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800eb74:	69bb      	ldr	r3, [r7, #24]
 800eb76:	3301      	adds	r3, #1
 800eb78:	61bb      	str	r3, [r7, #24]
 800eb7a:	69bb      	ldr	r3, [r7, #24]
 800eb7c:	2b0f      	cmp	r3, #15
 800eb7e:	dded      	ble.n	800eb5c <wolfSSL_X509_NAME_add_entry+0x46>
 800eb80:	e000      	b.n	800eb84 <wolfSSL_X509_NAME_add_entry+0x6e>
                    WOLFSSL_MSG("Found place for name entry");
                    break;
 800eb82:	bf00      	nop
                }
            }

            if (i == MAX_NAME_ENTRIES) {
 800eb84:	69bb      	ldr	r3, [r7, #24]
 800eb86:	2b10      	cmp	r3, #16
 800eb88:	d101      	bne.n	800eb8e <wolfSSL_X509_NAME_add_entry+0x78>
                WOLFSSL_MSG("No spot found for name entry");
                return WOLFSSL_FAILURE;
 800eb8a:	2300      	movs	r3, #0
 800eb8c:	e052      	b.n	800ec34 <wolfSSL_X509_NAME_add_entry+0x11e>
            }
        }

        current = &name->entry[i];
 800eb8e:	69ba      	ldr	r2, [r7, #24]
 800eb90:	4613      	mov	r3, r2
 800eb92:	009b      	lsls	r3, r3, #2
 800eb94:	4413      	add	r3, r2
 800eb96:	009b      	lsls	r3, r3, #2
 800eb98:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800eb9c:	68fa      	ldr	r2, [r7, #12]
 800eb9e:	4413      	add	r3, r2
 800eba0:	3304      	adds	r3, #4
 800eba2:	617b      	str	r3, [r7, #20]
        if (current->set == 0)
 800eba4:	697b      	ldr	r3, [r7, #20]
 800eba6:	68db      	ldr	r3, [r3, #12]
 800eba8:	2b00      	cmp	r3, #0
 800ebaa:	d106      	bne.n	800ebba <wolfSSL_X509_NAME_add_entry+0xa4>
            name->entrySz++;
 800ebac:	68fb      	ldr	r3, [r7, #12]
 800ebae:	f8d3 3250 	ldr.w	r3, [r3, #592]	@ 0x250
 800ebb2:	1c5a      	adds	r2, r3, #1
 800ebb4:	68fb      	ldr	r3, [r7, #12]
 800ebb6:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250

        if (wolfSSL_X509_NAME_ENTRY_create_by_NID(&current,
 800ebba:	68bb      	ldr	r3, [r7, #8]
 800ebbc:	689c      	ldr	r4, [r3, #8]
                            entry->nid,
                            wolfSSL_ASN1_STRING_type(entry->value),
 800ebbe:	68bb      	ldr	r3, [r7, #8]
 800ebc0:	685b      	ldr	r3, [r3, #4]
        if (wolfSSL_X509_NAME_ENTRY_create_by_NID(&current,
 800ebc2:	4618      	mov	r0, r3
 800ebc4:	f7fd f84a 	bl	800bc5c <wolfSSL_ASN1_STRING_type>
 800ebc8:	4605      	mov	r5, r0
                            wolfSSL_ASN1_STRING_data(entry->value),
 800ebca:	68bb      	ldr	r3, [r7, #8]
 800ebcc:	685b      	ldr	r3, [r3, #4]
 800ebce:	4618      	mov	r0, r3
 800ebd0:	f7fd f857 	bl	800bc82 <wolfSSL_ASN1_STRING_data>
 800ebd4:	4606      	mov	r6, r0
                            wolfSSL_ASN1_STRING_length(entry->value)) != NULL)
 800ebd6:	68bb      	ldr	r3, [r7, #8]
 800ebd8:	685b      	ldr	r3, [r3, #4]
        if (wolfSSL_X509_NAME_ENTRY_create_by_NID(&current,
 800ebda:	4618      	mov	r0, r3
 800ebdc:	f7fd f864 	bl	800bca8 <wolfSSL_ASN1_STRING_length>
 800ebe0:	4603      	mov	r3, r0
 800ebe2:	f107 0014 	add.w	r0, r7, #20
 800ebe6:	9300      	str	r3, [sp, #0]
 800ebe8:	4633      	mov	r3, r6
 800ebea:	462a      	mov	r2, r5
 800ebec:	4621      	mov	r1, r4
 800ebee:	f7ff fe16 	bl	800e81e <wolfSSL_X509_NAME_ENTRY_create_by_NID>
 800ebf2:	4603      	mov	r3, r0
 800ebf4:	2b00      	cmp	r3, #0
 800ebf6:	d002      	beq.n	800ebfe <wolfSSL_X509_NAME_add_entry+0xe8>
        {
            ret = WOLFSSL_SUCCESS;
 800ebf8:	2301      	movs	r3, #1
 800ebfa:	61fb      	str	r3, [r7, #28]
 800ebfc:	e001      	b.n	800ec02 <wolfSSL_X509_NAME_add_entry+0xec>
                ret = WOLFSSL_FAILURE;
            }
        #endif
        }
        else {
            ret = WOLFSSL_FAILURE;
 800ebfe:	2300      	movs	r3, #0
 800ec00:	61fb      	str	r3, [r7, #28]
        }

        if (ret != WOLFSSL_SUCCESS) {
 800ec02:	69fb      	ldr	r3, [r7, #28]
 800ec04:	2b01      	cmp	r3, #1
 800ec06:	d00c      	beq.n	800ec22 <wolfSSL_X509_NAME_add_entry+0x10c>
            WOLFSSL_MSG("Error adding the name entry");
            if (current->set == 0)
 800ec08:	697b      	ldr	r3, [r7, #20]
 800ec0a:	68db      	ldr	r3, [r3, #12]
 800ec0c:	2b00      	cmp	r3, #0
 800ec0e:	d106      	bne.n	800ec1e <wolfSSL_X509_NAME_add_entry+0x108>
                name->entrySz--;
 800ec10:	68fb      	ldr	r3, [r7, #12]
 800ec12:	f8d3 3250 	ldr.w	r3, [r3, #592]	@ 0x250
 800ec16:	1e5a      	subs	r2, r3, #1
 800ec18:	68fb      	ldr	r3, [r7, #12]
 800ec1a:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
            return WOLFSSL_FAILURE;
 800ec1e:	2300      	movs	r3, #0
 800ec20:	e008      	b.n	800ec34 <wolfSSL_X509_NAME_add_entry+0x11e>
        }

        if (RebuildFullName(name) != 0)
 800ec22:	68f8      	ldr	r0, [r7, #12]
 800ec24:	f7ff fede 	bl	800e9e4 <RebuildFullName>
 800ec28:	4603      	mov	r3, r0
 800ec2a:	2b00      	cmp	r3, #0
 800ec2c:	d001      	beq.n	800ec32 <wolfSSL_X509_NAME_add_entry+0x11c>
            return WOLFSSL_FAILURE;
 800ec2e:	2300      	movs	r3, #0
 800ec30:	e000      	b.n	800ec34 <wolfSSL_X509_NAME_add_entry+0x11e>

        (void)set;
        return WOLFSSL_SUCCESS;
 800ec32:	2301      	movs	r3, #1
    }
 800ec34:	4618      	mov	r0, r3
 800ec36:	3724      	adds	r7, #36	@ 0x24
 800ec38:	46bd      	mov	sp, r7
 800ec3a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800ec3c <wolfSSL_X509_NAME_add_entry_by_NID>:
    }

    int wolfSSL_X509_NAME_add_entry_by_NID(WOLFSSL_X509_NAME *name, int nid,
                                           int type, const unsigned char *bytes,
                                           int len, int loc, int set)
    {
 800ec3c:	b580      	push	{r7, lr}
 800ec3e:	b088      	sub	sp, #32
 800ec40:	af02      	add	r7, sp, #8
 800ec42:	60f8      	str	r0, [r7, #12]
 800ec44:	60b9      	str	r1, [r7, #8]
 800ec46:	607a      	str	r2, [r7, #4]
 800ec48:	603b      	str	r3, [r7, #0]
        int ret;
        WOLFSSL_X509_NAME_ENTRY* entry;
        WOLFSSL_ENTER("wolfSSL_X509_NAME_add_entry_by_NID");
        entry = wolfSSL_X509_NAME_ENTRY_create_by_NID(NULL, nid, type, bytes,
 800ec4a:	6a3b      	ldr	r3, [r7, #32]
 800ec4c:	9300      	str	r3, [sp, #0]
 800ec4e:	683b      	ldr	r3, [r7, #0]
 800ec50:	687a      	ldr	r2, [r7, #4]
 800ec52:	68b9      	ldr	r1, [r7, #8]
 800ec54:	2000      	movs	r0, #0
 800ec56:	f7ff fde2 	bl	800e81e <wolfSSL_X509_NAME_ENTRY_create_by_NID>
 800ec5a:	6178      	str	r0, [r7, #20]
                len);
        if (entry == NULL)
 800ec5c:	697b      	ldr	r3, [r7, #20]
 800ec5e:	2b00      	cmp	r3, #0
 800ec60:	d101      	bne.n	800ec66 <wolfSSL_X509_NAME_add_entry_by_NID+0x2a>
            return WOLFSSL_FAILURE;
 800ec62:	2300      	movs	r3, #0
 800ec64:	e00a      	b.n	800ec7c <wolfSSL_X509_NAME_add_entry_by_NID+0x40>
        ret = wolfSSL_X509_NAME_add_entry(name, entry, loc, set);
 800ec66:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ec68:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ec6a:	6979      	ldr	r1, [r7, #20]
 800ec6c:	68f8      	ldr	r0, [r7, #12]
 800ec6e:	f7ff ff52 	bl	800eb16 <wolfSSL_X509_NAME_add_entry>
 800ec72:	6138      	str	r0, [r7, #16]
        wolfSSL_X509_NAME_ENTRY_free(entry);
 800ec74:	6978      	ldr	r0, [r7, #20]
 800ec76:	f7ff fd62 	bl	800e73e <wolfSSL_X509_NAME_ENTRY_free>
        return ret;
 800ec7a:	693b      	ldr	r3, [r7, #16]
    }
 800ec7c:	4618      	mov	r0, r3
 800ec7e:	3718      	adds	r7, #24
 800ec80:	46bd      	mov	sp, r7
 800ec82:	bd80      	pop	{r7, pc}

0800ec84 <wolfSSL_X509_NAME_get_entry>:

    /* returns a pointer to the internal entry at location 'loc' on success,
     * a null pointer is returned in fail cases */
    WOLFSSL_X509_NAME_ENTRY *wolfSSL_X509_NAME_get_entry(
                                             WOLFSSL_X509_NAME *name, int loc)
    {
 800ec84:	b480      	push	{r7}
 800ec86:	b083      	sub	sp, #12
 800ec88:	af00      	add	r7, sp, #0
 800ec8a:	6078      	str	r0, [r7, #4]
 800ec8c:	6039      	str	r1, [r7, #0]
#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_X509_NAME_get_entry");
#endif

        if (name == NULL) {
 800ec8e:	687b      	ldr	r3, [r7, #4]
 800ec90:	2b00      	cmp	r3, #0
 800ec92:	d101      	bne.n	800ec98 <wolfSSL_X509_NAME_get_entry+0x14>
            return NULL;
 800ec94:	2300      	movs	r3, #0
 800ec96:	e01f      	b.n	800ecd8 <wolfSSL_X509_NAME_get_entry+0x54>
        }

        if (loc < 0 || loc >= MAX_NAME_ENTRIES) {
 800ec98:	683b      	ldr	r3, [r7, #0]
 800ec9a:	2b00      	cmp	r3, #0
 800ec9c:	db02      	blt.n	800eca4 <wolfSSL_X509_NAME_get_entry+0x20>
 800ec9e:	683b      	ldr	r3, [r7, #0]
 800eca0:	2b0f      	cmp	r3, #15
 800eca2:	dd01      	ble.n	800eca8 <wolfSSL_X509_NAME_get_entry+0x24>
            WOLFSSL_MSG("Bad argument");
            return NULL;
 800eca4:	2300      	movs	r3, #0
 800eca6:	e017      	b.n	800ecd8 <wolfSSL_X509_NAME_get_entry+0x54>
        }

        if (name->entry[loc].set) {
 800eca8:	6879      	ldr	r1, [r7, #4]
 800ecaa:	683a      	ldr	r2, [r7, #0]
 800ecac:	4613      	mov	r3, r2
 800ecae:	009b      	lsls	r3, r3, #2
 800ecb0:	4413      	add	r3, r2
 800ecb2:	009b      	lsls	r3, r3, #2
 800ecb4:	440b      	add	r3, r1
 800ecb6:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800ecba:	681b      	ldr	r3, [r3, #0]
 800ecbc:	2b00      	cmp	r3, #0
 800ecbe:	d00a      	beq.n	800ecd6 <wolfSSL_X509_NAME_get_entry+0x52>
            *  updating "set" by position + 1. "plus 1" means to avoid "not set"
            *  zero.
            */
            name->entry[loc].set = loc + 1;
#endif
            return &name->entry[loc];
 800ecc0:	683a      	ldr	r2, [r7, #0]
 800ecc2:	4613      	mov	r3, r2
 800ecc4:	009b      	lsls	r3, r3, #2
 800ecc6:	4413      	add	r3, r2
 800ecc8:	009b      	lsls	r3, r3, #2
 800ecca:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800ecce:	687a      	ldr	r2, [r7, #4]
 800ecd0:	4413      	add	r3, r2
 800ecd2:	3304      	adds	r3, #4
 800ecd4:	e000      	b.n	800ecd8 <wolfSSL_X509_NAME_get_entry+0x54>
        }
        else {
            return NULL;
 800ecd6:	2300      	movs	r3, #0
        }
    }
 800ecd8:	4618      	mov	r0, r3
 800ecda:	370c      	adds	r7, #12
 800ecdc:	46bd      	mov	sp, r7
 800ecde:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ece2:	4770      	bx	lr

0800ece4 <wolfSSL_sk_X509_NAME_pop_free>:
    return name;
}

void wolfSSL_sk_X509_NAME_pop_free(WOLF_STACK_OF(WOLFSSL_X509_NAME)* sk,
    void (*f) (WOLFSSL_X509_NAME*))
{
 800ece4:	b580      	push	{r7, lr}
 800ece6:	b082      	sub	sp, #8
 800ece8:	af00      	add	r7, sp, #0
 800ecea:	6078      	str	r0, [r7, #4]
 800ecec:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_sk_X509_NAME_pop_free");
    wolfSSL_sk_pop_free(sk, (wolfSSL_sk_freefunc)f);
 800ecee:	6839      	ldr	r1, [r7, #0]
 800ecf0:	6878      	ldr	r0, [r7, #4]
 800ecf2:	f7ff f8cf 	bl	800de94 <wolfSSL_sk_pop_free>
}
 800ecf6:	bf00      	nop
 800ecf8:	3708      	adds	r7, #8
 800ecfa:	46bd      	mov	sp, r7
 800ecfc:	bd80      	pop	{r7, pc}

0800ecfe <wolfSSL_sk_X509_new_null>:
    (void)cb;
    return wolfSSL_sk_X509_new_null();
}

WOLFSSL_STACK* wolfSSL_sk_X509_new_null(void)
{
 800ecfe:	b580      	push	{r7, lr}
 800ed00:	b082      	sub	sp, #8
 800ed02:	af00      	add	r7, sp, #0
    WOLFSSL_STACK* s = (WOLFSSL_STACK*)XMALLOC(sizeof(WOLFSSL_STACK), NULL,
 800ed04:	2018      	movs	r0, #24
 800ed06:	f00f ffb9 	bl	801ec7c <wolfSSL_Malloc>
 800ed0a:	6078      	str	r0, [r7, #4]
            DYNAMIC_TYPE_OPENSSL);
    if (s != NULL) {
 800ed0c:	687b      	ldr	r3, [r7, #4]
 800ed0e:	2b00      	cmp	r3, #0
 800ed10:	d007      	beq.n	800ed22 <wolfSSL_sk_X509_new_null+0x24>
        XMEMSET(s, 0, sizeof(*s));
 800ed12:	2218      	movs	r2, #24
 800ed14:	2100      	movs	r1, #0
 800ed16:	6878      	ldr	r0, [r7, #4]
 800ed18:	f019 ff84 	bl	8028c24 <memset>
        s->type = STACK_TYPE_X509;
 800ed1c:	687b      	ldr	r3, [r7, #4]
 800ed1e:	2200      	movs	r2, #0
 800ed20:	751a      	strb	r2, [r3, #20]
    }

    return s;
 800ed22:	687b      	ldr	r3, [r7, #4]
}
 800ed24:	4618      	mov	r0, r3
 800ed26:	3708      	adds	r7, #8
 800ed28:	46bd      	mov	sp, r7
 800ed2a:	bd80      	pop	{r7, pc}

0800ed2c <wolfSSL_X509_NAME_copy>:
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
/* unlike wolfSSL_X509_NAME_dup this does not malloc a duplicate, only deep
 * copy. "to" is expected to be a fresh blank name, if not pointers could be
 * lost */
int wolfSSL_X509_NAME_copy(WOLFSSL_X509_NAME* from, WOLFSSL_X509_NAME* to)
{
 800ed2c:	b580      	push	{r7, lr}
 800ed2e:	b084      	sub	sp, #16
 800ed30:	af00      	add	r7, sp, #0
 800ed32:	6078      	str	r0, [r7, #4]
 800ed34:	6039      	str	r1, [r7, #0]
    int i;

    WOLFSSL_ENTER("wolfSSL_X509_NAME_copy");

    if (from == NULL || to == NULL) {
 800ed36:	687b      	ldr	r3, [r7, #4]
 800ed38:	2b00      	cmp	r3, #0
 800ed3a:	d002      	beq.n	800ed42 <wolfSSL_X509_NAME_copy+0x16>
 800ed3c:	683b      	ldr	r3, [r7, #0]
 800ed3e:	2b00      	cmp	r3, #0
 800ed40:	d102      	bne.n	800ed48 <wolfSSL_X509_NAME_copy+0x1c>
        WOLFSSL_MSG("NULL parameter");
        return BAD_FUNC_ARG;
 800ed42:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800ed46:	e044      	b.n	800edd2 <wolfSSL_X509_NAME_copy+0xa6>
        XMEMCPY(to->raw, from->raw, from->rawLen);
        to->rawLen = from->rawLen;
    }
#endif

    if (from->dynamicName) {
 800ed48:	687b      	ldr	r3, [r7, #4]
 800ed4a:	685b      	ldr	r3, [r3, #4]
 800ed4c:	2b00      	cmp	r3, #0
 800ed4e:	d010      	beq.n	800ed72 <wolfSSL_X509_NAME_copy+0x46>
        to->name = (char*)XMALLOC(from->sz, to->heap, DYNAMIC_TYPE_SUBJECT_CN);
 800ed50:	687b      	ldr	r3, [r7, #4]
 800ed52:	689b      	ldr	r3, [r3, #8]
 800ed54:	4618      	mov	r0, r3
 800ed56:	f00f ff91 	bl	801ec7c <wolfSSL_Malloc>
 800ed5a:	4602      	mov	r2, r0
 800ed5c:	683b      	ldr	r3, [r7, #0]
 800ed5e:	601a      	str	r2, [r3, #0]
        if (to->name == NULL)
 800ed60:	683b      	ldr	r3, [r7, #0]
 800ed62:	681b      	ldr	r3, [r3, #0]
 800ed64:	2b00      	cmp	r3, #0
 800ed66:	d101      	bne.n	800ed6c <wolfSSL_X509_NAME_copy+0x40>
            return WOLFSSL_FAILURE;
 800ed68:	2300      	movs	r3, #0
 800ed6a:	e032      	b.n	800edd2 <wolfSSL_X509_NAME_copy+0xa6>
        to->dynamicName = 1;
 800ed6c:	683b      	ldr	r3, [r7, #0]
 800ed6e:	2201      	movs	r2, #1
 800ed70:	605a      	str	r2, [r3, #4]
    }
    XMEMCPY(to->name, from->name, from->sz);
 800ed72:	683b      	ldr	r3, [r7, #0]
 800ed74:	6818      	ldr	r0, [r3, #0]
 800ed76:	687b      	ldr	r3, [r7, #4]
 800ed78:	6819      	ldr	r1, [r3, #0]
 800ed7a:	687b      	ldr	r3, [r7, #4]
 800ed7c:	689b      	ldr	r3, [r3, #8]
 800ed7e:	461a      	mov	r2, r3
 800ed80:	f01a f801 	bl	8028d86 <memcpy>
    to->sz = from->sz;
 800ed84:	687b      	ldr	r3, [r7, #4]
 800ed86:	689a      	ldr	r2, [r3, #8]
 800ed88:	683b      	ldr	r3, [r7, #0]
 800ed8a:	609a      	str	r2, [r3, #8]

    for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800ed8c:	2300      	movs	r3, #0
 800ed8e:	60fb      	str	r3, [r7, #12]
 800ed90:	e015      	b.n	800edbe <wolfSSL_X509_NAME_copy+0x92>
        WOLFSSL_X509_NAME_ENTRY* ne = wolfSSL_X509_NAME_get_entry(from, i);
 800ed92:	68f9      	ldr	r1, [r7, #12]
 800ed94:	6878      	ldr	r0, [r7, #4]
 800ed96:	f7ff ff75 	bl	800ec84 <wolfSSL_X509_NAME_get_entry>
 800ed9a:	60b8      	str	r0, [r7, #8]
        if (ne != NULL) {
 800ed9c:	68bb      	ldr	r3, [r7, #8]
 800ed9e:	2b00      	cmp	r3, #0
 800eda0:	d00a      	beq.n	800edb8 <wolfSSL_X509_NAME_copy+0x8c>
            if (wolfSSL_X509_NAME_add_entry(to, ne, i, 1) != WOLFSSL_SUCCESS) {
 800eda2:	2301      	movs	r3, #1
 800eda4:	68fa      	ldr	r2, [r7, #12]
 800eda6:	68b9      	ldr	r1, [r7, #8]
 800eda8:	6838      	ldr	r0, [r7, #0]
 800edaa:	f7ff feb4 	bl	800eb16 <wolfSSL_X509_NAME_add_entry>
 800edae:	4603      	mov	r3, r0
 800edb0:	2b01      	cmp	r3, #1
 800edb2:	d001      	beq.n	800edb8 <wolfSSL_X509_NAME_copy+0x8c>
                return WOLFSSL_FAILURE;
 800edb4:	2300      	movs	r3, #0
 800edb6:	e00c      	b.n	800edd2 <wolfSSL_X509_NAME_copy+0xa6>
    for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800edb8:	68fb      	ldr	r3, [r7, #12]
 800edba:	3301      	adds	r3, #1
 800edbc:	60fb      	str	r3, [r7, #12]
 800edbe:	68fb      	ldr	r3, [r7, #12]
 800edc0:	2b0f      	cmp	r3, #15
 800edc2:	dde6      	ble.n	800ed92 <wolfSSL_X509_NAME_copy+0x66>
            }
        }
    }
    to->entrySz = from->entrySz;
 800edc4:	687b      	ldr	r3, [r7, #4]
 800edc6:	f8d3 2250 	ldr.w	r2, [r3, #592]	@ 0x250
 800edca:	683b      	ldr	r3, [r7, #0]
 800edcc:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
    return WOLFSSL_SUCCESS;
 800edd0:	2301      	movs	r3, #1
}
 800edd2:	4618      	mov	r0, r3
 800edd4:	3710      	adds	r7, #16
 800edd6:	46bd      	mov	sp, r7
 800edd8:	bd80      	pop	{r7, pc}

0800edda <wolfSSL_X509_set_subject_name>:


/* copies over information from "name" to the "cert" subject name
 * returns WOLFSSL_SUCCESS on success */
int wolfSSL_X509_set_subject_name(WOLFSSL_X509 *cert, WOLFSSL_X509_NAME *name)
{
 800edda:	b580      	push	{r7, lr}
 800eddc:	b082      	sub	sp, #8
 800edde:	af00      	add	r7, sp, #0
 800ede0:	6078      	str	r0, [r7, #4]
 800ede2:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_X509_set_subject_name");
    if (cert == NULL || name == NULL)
 800ede4:	687b      	ldr	r3, [r7, #4]
 800ede6:	2b00      	cmp	r3, #0
 800ede8:	d002      	beq.n	800edf0 <wolfSSL_X509_set_subject_name+0x16>
 800edea:	683b      	ldr	r3, [r7, #0]
 800edec:	2b00      	cmp	r3, #0
 800edee:	d101      	bne.n	800edf4 <wolfSSL_X509_set_subject_name+0x1a>
        return WOLFSSL_FAILURE;
 800edf0:	2300      	movs	r3, #0
 800edf2:	e026      	b.n	800ee42 <wolfSSL_X509_set_subject_name+0x68>

    FreeX509Name(&cert->subject);
 800edf4:	687b      	ldr	r3, [r7, #4]
 800edf6:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800edfa:	4618      	mov	r0, r3
 800edfc:	f7fa fbed 	bl	80095da <FreeX509Name>
    InitX509Name(&cert->subject, 0, cert->heap);
 800ee00:	687b      	ldr	r3, [r7, #4]
 800ee02:	f503 60f1 	add.w	r0, r3, #1928	@ 0x788
 800ee06:	687b      	ldr	r3, [r7, #4]
 800ee08:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800ee0c:	461a      	mov	r2, r3
 800ee0e:	2100      	movs	r1, #0
 800ee10:	f7fa fbc4 	bl	800959c <InitX509Name>

    if (wolfSSL_X509_NAME_copy(name, &cert->subject) != WOLFSSL_SUCCESS) {
 800ee14:	687b      	ldr	r3, [r7, #4]
 800ee16:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800ee1a:	4619      	mov	r1, r3
 800ee1c:	6838      	ldr	r0, [r7, #0]
 800ee1e:	f7ff ff85 	bl	800ed2c <wolfSSL_X509_NAME_copy>
 800ee22:	4603      	mov	r3, r0
 800ee24:	2b01      	cmp	r3, #1
 800ee26:	d007      	beq.n	800ee38 <wolfSSL_X509_set_subject_name+0x5e>
        FreeX509Name(&cert->subject);
 800ee28:	687b      	ldr	r3, [r7, #4]
 800ee2a:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800ee2e:	4618      	mov	r0, r3
 800ee30:	f7fa fbd3 	bl	80095da <FreeX509Name>
        return WOLFSSL_FAILURE;
 800ee34:	2300      	movs	r3, #0
 800ee36:	e004      	b.n	800ee42 <wolfSSL_X509_set_subject_name+0x68>
    }

    cert->subject.x509 = cert;
 800ee38:	687b      	ldr	r3, [r7, #4]
 800ee3a:	687a      	ldr	r2, [r7, #4]
 800ee3c:	f8c3 2b1c 	str.w	r2, [r3, #2844]	@ 0xb1c
    return WOLFSSL_SUCCESS;
 800ee40:	2301      	movs	r3, #1
}
 800ee42:	4618      	mov	r0, r3
 800ee44:	3708      	adds	r7, #8
 800ee46:	46bd      	mov	sp, r7
 800ee48:	bd80      	pop	{r7, pc}

0800ee4a <wolfSSL_X509_set_issuer_name>:


/* copies over information from "name" to the "cert" issuer name
 * returns WOLFSSL_SUCCESS on success */
int wolfSSL_X509_set_issuer_name(WOLFSSL_X509 *cert, WOLFSSL_X509_NAME *name)
{
 800ee4a:	b580      	push	{r7, lr}
 800ee4c:	b082      	sub	sp, #8
 800ee4e:	af00      	add	r7, sp, #0
 800ee50:	6078      	str	r0, [r7, #4]
 800ee52:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_X509_set_issuer_name");
    if (cert == NULL || name == NULL)
 800ee54:	687b      	ldr	r3, [r7, #4]
 800ee56:	2b00      	cmp	r3, #0
 800ee58:	d002      	beq.n	800ee60 <wolfSSL_X509_set_issuer_name+0x16>
 800ee5a:	683b      	ldr	r3, [r7, #0]
 800ee5c:	2b00      	cmp	r3, #0
 800ee5e:	d101      	bne.n	800ee64 <wolfSSL_X509_set_issuer_name+0x1a>
        return WOLFSSL_FAILURE;
 800ee60:	2300      	movs	r3, #0
 800ee62:	e02d      	b.n	800eec0 <wolfSSL_X509_set_issuer_name+0x76>

    FreeX509Name(&cert->issuer);
 800ee64:	687b      	ldr	r3, [r7, #4]
 800ee66:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800ee6a:	4618      	mov	r0, r3
 800ee6c:	f7fa fbb5 	bl	80095da <FreeX509Name>
    InitX509Name(&cert->issuer, 0, cert->heap);
 800ee70:	687b      	ldr	r3, [r7, #4]
 800ee72:	f503 701f 	add.w	r0, r3, #636	@ 0x27c
 800ee76:	687b      	ldr	r3, [r7, #4]
 800ee78:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800ee7c:	461a      	mov	r2, r3
 800ee7e:	2100      	movs	r1, #0
 800ee80:	f7fa fb8c 	bl	800959c <InitX509Name>

    if (wolfSSL_X509_NAME_copy(name, &cert->issuer) != WOLFSSL_SUCCESS) {
 800ee84:	687b      	ldr	r3, [r7, #4]
 800ee86:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800ee8a:	4619      	mov	r1, r3
 800ee8c:	6838      	ldr	r0, [r7, #0]
 800ee8e:	f7ff ff4d 	bl	800ed2c <wolfSSL_X509_NAME_copy>
 800ee92:	4603      	mov	r3, r0
 800ee94:	2b01      	cmp	r3, #1
 800ee96:	d007      	beq.n	800eea8 <wolfSSL_X509_set_issuer_name+0x5e>
        FreeX509Name(&cert->issuer);
 800ee98:	687b      	ldr	r3, [r7, #4]
 800ee9a:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800ee9e:	4618      	mov	r0, r3
 800eea0:	f7fa fb9b 	bl	80095da <FreeX509Name>
        return WOLFSSL_FAILURE;
 800eea4:	2300      	movs	r3, #0
 800eea6:	e00b      	b.n	800eec0 <wolfSSL_X509_set_issuer_name+0x76>
    }

    cert->issuer.x509 = cert;
 800eea8:	687b      	ldr	r3, [r7, #4]
 800eeaa:	687a      	ldr	r2, [r7, #4]
 800eeac:	f8c3 2610 	str.w	r2, [r3, #1552]	@ 0x610
    cert->issuerSet = 1;
 800eeb0:	687a      	ldr	r2, [r7, #4]
 800eeb2:	f892 30f3 	ldrb.w	r3, [r2, #243]	@ 0xf3
 800eeb6:	f043 0301 	orr.w	r3, r3, #1
 800eeba:	f882 30f3 	strb.w	r3, [r2, #243]	@ 0xf3

    return WOLFSSL_SUCCESS;
 800eebe:	2301      	movs	r3, #1
}
 800eec0:	4618      	mov	r0, r3
 800eec2:	3708      	adds	r7, #8
 800eec4:	46bd      	mov	sp, r7
 800eec6:	bd80      	pop	{r7, pc}

0800eec8 <wolfSSL_BUF_MEM_free>:

    return (int)len;
}

void wolfSSL_BUF_MEM_free(WOLFSSL_BUF_MEM* buf)
{
 800eec8:	b580      	push	{r7, lr}
 800eeca:	b084      	sub	sp, #16
 800eecc:	af00      	add	r7, sp, #0
 800eece:	6078      	str	r0, [r7, #4]
    if (buf) {
 800eed0:	687b      	ldr	r3, [r7, #4]
 800eed2:	2b00      	cmp	r3, #0
 800eed4:	d019      	beq.n	800ef0a <wolfSSL_BUF_MEM_free+0x42>
        XFREE(buf->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800eed6:	687b      	ldr	r3, [r7, #4]
 800eed8:	681b      	ldr	r3, [r3, #0]
 800eeda:	60fb      	str	r3, [r7, #12]
 800eedc:	68fb      	ldr	r3, [r7, #12]
 800eede:	2b00      	cmp	r3, #0
 800eee0:	d002      	beq.n	800eee8 <wolfSSL_BUF_MEM_free+0x20>
 800eee2:	68f8      	ldr	r0, [r7, #12]
 800eee4:	f00f fee6 	bl	801ecb4 <wolfSSL_Free>
        buf->data = NULL;
 800eee8:	687b      	ldr	r3, [r7, #4]
 800eeea:	2200      	movs	r2, #0
 800eeec:	601a      	str	r2, [r3, #0]
        buf->max = 0;
 800eeee:	687b      	ldr	r3, [r7, #4]
 800eef0:	2200      	movs	r2, #0
 800eef2:	609a      	str	r2, [r3, #8]
        buf->length = 0;
 800eef4:	687b      	ldr	r3, [r7, #4]
 800eef6:	2200      	movs	r2, #0
 800eef8:	605a      	str	r2, [r3, #4]
        XFREE(buf, NULL, DYNAMIC_TYPE_OPENSSL);
 800eefa:	687b      	ldr	r3, [r7, #4]
 800eefc:	60bb      	str	r3, [r7, #8]
 800eefe:	68bb      	ldr	r3, [r7, #8]
 800ef00:	2b00      	cmp	r3, #0
 800ef02:	d002      	beq.n	800ef0a <wolfSSL_BUF_MEM_free+0x42>
 800ef04:	68b8      	ldr	r0, [r7, #8]
 800ef06:	f00f fed5 	bl	801ecb4 <wolfSSL_Free>
    }
}
 800ef0a:	bf00      	nop
 800ef0c:	3710      	adds	r7, #16
 800ef0e:	46bd      	mov	sp, r7
 800ef10:	bd80      	pop	{r7, pc}
	...

0800ef14 <wolfSSL_RAND_InitMutex>:
 * START OF RAND API
 ******************************************************************************/

#if defined(OPENSSL_EXTRA) && !defined(WOLFSSL_NO_OPENSSL_RAND_CB)
static int wolfSSL_RAND_InitMutex(void)
{
 800ef14:	b580      	push	{r7, lr}
 800ef16:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (gRandMethodsInit == 0) {
 800ef18:	4b09      	ldr	r3, [pc, #36]	@ (800ef40 <wolfSSL_RAND_InitMutex+0x2c>)
 800ef1a:	681b      	ldr	r3, [r3, #0]
 800ef1c:	2b00      	cmp	r3, #0
 800ef1e:	d10b      	bne.n	800ef38 <wolfSSL_RAND_InitMutex+0x24>
        if (wc_InitMutex(&gRandMethodMutex) != 0) {
 800ef20:	4808      	ldr	r0, [pc, #32]	@ (800ef44 <wolfSSL_RAND_InitMutex+0x30>)
 800ef22:	f018 fbcf 	bl	80276c4 <wc_InitMutex>
 800ef26:	4603      	mov	r3, r0
 800ef28:	2b00      	cmp	r3, #0
 800ef2a:	d002      	beq.n	800ef32 <wolfSSL_RAND_InitMutex+0x1e>
            WOLFSSL_MSG("Bad Init Mutex rand methods");
            return BAD_MUTEX_E;
 800ef2c:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800ef30:	e003      	b.n	800ef3a <wolfSSL_RAND_InitMutex+0x26>
        }
        gRandMethodsInit = 1;
 800ef32:	4b03      	ldr	r3, [pc, #12]	@ (800ef40 <wolfSSL_RAND_InitMutex+0x2c>)
 800ef34:	2201      	movs	r2, #1
 800ef36:	601a      	str	r2, [r3, #0]
    }
#endif
    return 0;
 800ef38:	2300      	movs	r3, #0
}
 800ef3a:	4618      	mov	r0, r3
 800ef3c:	bd80      	pop	{r7, pc}
 800ef3e:	bf00      	nop
 800ef40:	20001c18 	.word	0x20001c18
 800ef44:	20001c14 	.word	0x20001c14

0800ef48 <wolfSSL_RAND_Init>:
/* Checks if the global RNG has been created. If not then one is created.
 *
 * Returns WOLFSSL_SUCCESS when no error is encountered.
 */
int wolfSSL_RAND_Init(void)
{
 800ef48:	b580      	push	{r7, lr}
 800ef4a:	b082      	sub	sp, #8
 800ef4c:	af00      	add	r7, sp, #0
    int ret = WC_NO_ERR_TRACE(WOLFSSL_FAILURE);
 800ef4e:	2300      	movs	r3, #0
 800ef50:	607b      	str	r3, [r7, #4]
#ifdef HAVE_GLOBAL_RNG
    if (wc_LockMutex(&globalRNGMutex) == 0) {
 800ef52:	4810      	ldr	r0, [pc, #64]	@ (800ef94 <wolfSSL_RAND_Init+0x4c>)
 800ef54:	f018 fbcc 	bl	80276f0 <wc_LockMutex>
 800ef58:	4603      	mov	r3, r0
 800ef5a:	2b00      	cmp	r3, #0
 800ef5c:	d115      	bne.n	800ef8a <wolfSSL_RAND_Init+0x42>
        if (initGlobalRNG == 0) {
 800ef5e:	4b0e      	ldr	r3, [pc, #56]	@ (800ef98 <wolfSSL_RAND_Init+0x50>)
 800ef60:	681b      	ldr	r3, [r3, #0]
 800ef62:	2b00      	cmp	r3, #0
 800ef64:	d10c      	bne.n	800ef80 <wolfSSL_RAND_Init+0x38>
            ret = wc_InitRng(&globalRNG);
 800ef66:	480d      	ldr	r0, [pc, #52]	@ (800ef9c <wolfSSL_RAND_Init+0x54>)
 800ef68:	f010 fbfd 	bl	801f766 <wc_InitRng>
 800ef6c:	6078      	str	r0, [r7, #4]
            if (ret == 0) {
 800ef6e:	687b      	ldr	r3, [r7, #4]
 800ef70:	2b00      	cmp	r3, #0
 800ef72:	d107      	bne.n	800ef84 <wolfSSL_RAND_Init+0x3c>
                initGlobalRNG = 1;
 800ef74:	4b08      	ldr	r3, [pc, #32]	@ (800ef98 <wolfSSL_RAND_Init+0x50>)
 800ef76:	2201      	movs	r2, #1
 800ef78:	601a      	str	r2, [r3, #0]
                ret = WOLFSSL_SUCCESS;
 800ef7a:	2301      	movs	r3, #1
 800ef7c:	607b      	str	r3, [r7, #4]
 800ef7e:	e001      	b.n	800ef84 <wolfSSL_RAND_Init+0x3c>
            }
        }
        else {
            /* GlobalRNG is already initialized */
            ret = WOLFSSL_SUCCESS;
 800ef80:	2301      	movs	r3, #1
 800ef82:	607b      	str	r3, [r7, #4]
        }

        wc_UnLockMutex(&globalRNGMutex);
 800ef84:	4803      	ldr	r0, [pc, #12]	@ (800ef94 <wolfSSL_RAND_Init+0x4c>)
 800ef86:	f018 fbbe 	bl	8027706 <wc_UnLockMutex>
    }
#endif
    return ret;
 800ef8a:	687b      	ldr	r3, [r7, #4]
}
 800ef8c:	4618      	mov	r0, r3
 800ef8e:	3708      	adds	r7, #8
 800ef90:	46bd      	mov	sp, r7
 800ef92:	bd80      	pop	{r7, pc}
 800ef94:	20001c04 	.word	0x20001c04
 800ef98:	20001c00 	.word	0x20001c00
 800ef9c:	20001bf0 	.word	0x20001bf0

0800efa0 <wolfSSL_RAND_seed>:


/* WOLFSSL_SUCCESS on ok */
int wolfSSL_RAND_seed(const void* seed, int len)
{
 800efa0:	b580      	push	{r7, lr}
 800efa2:	b084      	sub	sp, #16
 800efa4:	af00      	add	r7, sp, #0
 800efa6:	6078      	str	r0, [r7, #4]
 800efa8:	6039      	str	r1, [r7, #0]
#ifndef WOLFSSL_NO_OPENSSL_RAND_CB
    if (wolfSSL_RAND_InitMutex() == 0 && wc_LockMutex(&gRandMethodMutex) == 0) {
 800efaa:	f7ff ffb3 	bl	800ef14 <wolfSSL_RAND_InitMutex>
 800efae:	4603      	mov	r3, r0
 800efb0:	2b00      	cmp	r3, #0
 800efb2:	d11d      	bne.n	800eff0 <wolfSSL_RAND_seed+0x50>
 800efb4:	4812      	ldr	r0, [pc, #72]	@ (800f000 <wolfSSL_RAND_seed+0x60>)
 800efb6:	f018 fb9b 	bl	80276f0 <wc_LockMutex>
 800efba:	4603      	mov	r3, r0
 800efbc:	2b00      	cmp	r3, #0
 800efbe:	d117      	bne.n	800eff0 <wolfSSL_RAND_seed+0x50>
        if (gRandMethods && gRandMethods->seed) {
 800efc0:	4b10      	ldr	r3, [pc, #64]	@ (800f004 <wolfSSL_RAND_seed+0x64>)
 800efc2:	681b      	ldr	r3, [r3, #0]
 800efc4:	2b00      	cmp	r3, #0
 800efc6:	d010      	beq.n	800efea <wolfSSL_RAND_seed+0x4a>
 800efc8:	4b0e      	ldr	r3, [pc, #56]	@ (800f004 <wolfSSL_RAND_seed+0x64>)
 800efca:	681b      	ldr	r3, [r3, #0]
 800efcc:	681b      	ldr	r3, [r3, #0]
 800efce:	2b00      	cmp	r3, #0
 800efd0:	d00b      	beq.n	800efea <wolfSSL_RAND_seed+0x4a>
            int ret = gRandMethods->seed(seed, len);
 800efd2:	4b0c      	ldr	r3, [pc, #48]	@ (800f004 <wolfSSL_RAND_seed+0x64>)
 800efd4:	681b      	ldr	r3, [r3, #0]
 800efd6:	681b      	ldr	r3, [r3, #0]
 800efd8:	6839      	ldr	r1, [r7, #0]
 800efda:	6878      	ldr	r0, [r7, #4]
 800efdc:	4798      	blx	r3
 800efde:	60f8      	str	r0, [r7, #12]
            wc_UnLockMutex(&gRandMethodMutex);
 800efe0:	4807      	ldr	r0, [pc, #28]	@ (800f000 <wolfSSL_RAND_seed+0x60>)
 800efe2:	f018 fb90 	bl	8027706 <wc_UnLockMutex>
            return ret;
 800efe6:	68fb      	ldr	r3, [r7, #12]
 800efe8:	e005      	b.n	800eff6 <wolfSSL_RAND_seed+0x56>
        }
        wc_UnLockMutex(&gRandMethodMutex);
 800efea:	4805      	ldr	r0, [pc, #20]	@ (800f000 <wolfSSL_RAND_seed+0x60>)
 800efec:	f018 fb8b 	bl	8027706 <wc_UnLockMutex>
    (void)seed;
    (void)len;
#endif

    /* Make sure global shared RNG (globalRNG) is initialized */
    return wolfSSL_RAND_Init();
 800eff0:	f7ff ffaa 	bl	800ef48 <wolfSSL_RAND_Init>
 800eff4:	4603      	mov	r3, r0
}
 800eff6:	4618      	mov	r0, r3
 800eff8:	3710      	adds	r7, #16
 800effa:	46bd      	mov	sp, r7
 800effc:	bd80      	pop	{r7, pc}
 800effe:	bf00      	nop
 800f000:	20001c14 	.word	0x20001c14
 800f004:	20001c10 	.word	0x20001c10

0800f008 <wolfSSL_RAND_Cleanup>:
}

#endif /* !FREERTOS_TCP */

void wolfSSL_RAND_Cleanup(void)
{
 800f008:	b580      	push	{r7, lr}
 800f00a:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_NO_OPENSSL_RAND_CB
    if (wolfSSL_RAND_InitMutex() == 0 && wc_LockMutex(&gRandMethodMutex) == 0) {
 800f00c:	f7ff ff82 	bl	800ef14 <wolfSSL_RAND_InitMutex>
 800f010:	4603      	mov	r3, r0
 800f012:	2b00      	cmp	r3, #0
 800f014:	d115      	bne.n	800f042 <wolfSSL_RAND_Cleanup+0x3a>
 800f016:	481a      	ldr	r0, [pc, #104]	@ (800f080 <wolfSSL_RAND_Cleanup+0x78>)
 800f018:	f018 fb6a 	bl	80276f0 <wc_LockMutex>
 800f01c:	4603      	mov	r3, r0
 800f01e:	2b00      	cmp	r3, #0
 800f020:	d10f      	bne.n	800f042 <wolfSSL_RAND_Cleanup+0x3a>
        if (gRandMethods && gRandMethods->cleanup)
 800f022:	4b18      	ldr	r3, [pc, #96]	@ (800f084 <wolfSSL_RAND_Cleanup+0x7c>)
 800f024:	681b      	ldr	r3, [r3, #0]
 800f026:	2b00      	cmp	r3, #0
 800f028:	d008      	beq.n	800f03c <wolfSSL_RAND_Cleanup+0x34>
 800f02a:	4b16      	ldr	r3, [pc, #88]	@ (800f084 <wolfSSL_RAND_Cleanup+0x7c>)
 800f02c:	681b      	ldr	r3, [r3, #0]
 800f02e:	689b      	ldr	r3, [r3, #8]
 800f030:	2b00      	cmp	r3, #0
 800f032:	d003      	beq.n	800f03c <wolfSSL_RAND_Cleanup+0x34>
            gRandMethods->cleanup();
 800f034:	4b13      	ldr	r3, [pc, #76]	@ (800f084 <wolfSSL_RAND_Cleanup+0x7c>)
 800f036:	681b      	ldr	r3, [r3, #0]
 800f038:	689b      	ldr	r3, [r3, #8]
 800f03a:	4798      	blx	r3
        wc_UnLockMutex(&gRandMethodMutex);
 800f03c:	4810      	ldr	r0, [pc, #64]	@ (800f080 <wolfSSL_RAND_Cleanup+0x78>)
 800f03e:	f018 fb62 	bl	8027706 <wc_UnLockMutex>
    }

    #ifndef WOLFSSL_MUTEX_INITIALIZER
    if (wc_FreeMutex(&gRandMethodMutex) == 0)
 800f042:	480f      	ldr	r0, [pc, #60]	@ (800f080 <wolfSSL_RAND_Cleanup+0x78>)
 800f044:	f018 fb49 	bl	80276da <wc_FreeMutex>
 800f048:	4603      	mov	r3, r0
 800f04a:	2b00      	cmp	r3, #0
 800f04c:	d102      	bne.n	800f054 <wolfSSL_RAND_Cleanup+0x4c>
        gRandMethodsInit = 0;
 800f04e:	4b0e      	ldr	r3, [pc, #56]	@ (800f088 <wolfSSL_RAND_Cleanup+0x80>)
 800f050:	2200      	movs	r2, #0
 800f052:	601a      	str	r2, [r3, #0]
    #endif
#endif
#ifdef HAVE_GLOBAL_RNG
    if (wc_LockMutex(&globalRNGMutex) == 0) {
 800f054:	480d      	ldr	r0, [pc, #52]	@ (800f08c <wolfSSL_RAND_Cleanup+0x84>)
 800f056:	f018 fb4b 	bl	80276f0 <wc_LockMutex>
 800f05a:	4603      	mov	r3, r0
 800f05c:	2b00      	cmp	r3, #0
 800f05e:	d10c      	bne.n	800f07a <wolfSSL_RAND_Cleanup+0x72>
        if (initGlobalRNG) {
 800f060:	4b0b      	ldr	r3, [pc, #44]	@ (800f090 <wolfSSL_RAND_Cleanup+0x88>)
 800f062:	681b      	ldr	r3, [r3, #0]
 800f064:	2b00      	cmp	r3, #0
 800f066:	d005      	beq.n	800f074 <wolfSSL_RAND_Cleanup+0x6c>
            wc_FreeRng(&globalRNG);
 800f068:	480a      	ldr	r0, [pc, #40]	@ (800f094 <wolfSSL_RAND_Cleanup+0x8c>)
 800f06a:	f010 fc2f 	bl	801f8cc <wc_FreeRng>
            initGlobalRNG = 0;
 800f06e:	4b08      	ldr	r3, [pc, #32]	@ (800f090 <wolfSSL_RAND_Cleanup+0x88>)
 800f070:	2200      	movs	r2, #0
 800f072:	601a      	str	r2, [r3, #0]
        }
        wc_UnLockMutex(&globalRNGMutex);
 800f074:	4805      	ldr	r0, [pc, #20]	@ (800f08c <wolfSSL_RAND_Cleanup+0x84>)
 800f076:	f018 fb46 	bl	8027706 <wc_UnLockMutex>
    }
#endif
}
 800f07a:	bf00      	nop
 800f07c:	bd80      	pop	{r7, pc}
 800f07e:	bf00      	nop
 800f080:	20001c14 	.word	0x20001c14
 800f084:	20001c10 	.word	0x20001c10
 800f088:	20001c18 	.word	0x20001c18
 800f08c:	20001c04 	.word	0x20001c04
 800f090:	20001c00 	.word	0x20001c00
 800f094:	20001bf0 	.word	0x20001bf0

0800f098 <wolfSSL_X509_STORE_CTX_new_ex>:
 *****************************************************************************/

/* This API is necessary outside of OPENSSL_EXTRA because it is used in
 * SetupStoreCtxCallback */
WOLFSSL_X509_STORE_CTX* wolfSSL_X509_STORE_CTX_new_ex(void* heap)
{
 800f098:	b580      	push	{r7, lr}
 800f09a:	b084      	sub	sp, #16
 800f09c:	af00      	add	r7, sp, #0
 800f09e:	6078      	str	r0, [r7, #4]
    WOLFSSL_X509_STORE_CTX* ctx;
    WOLFSSL_ENTER("wolfSSL_X509_STORE_CTX_new_ex");

    ctx = (WOLFSSL_X509_STORE_CTX*)XMALLOC(sizeof(WOLFSSL_X509_STORE_CTX), heap,
 800f0a0:	2050      	movs	r0, #80	@ 0x50
 800f0a2:	f00f fdeb 	bl	801ec7c <wolfSSL_Malloc>
 800f0a6:	60f8      	str	r0, [r7, #12]
                                    DYNAMIC_TYPE_X509_CTX);
    if (ctx != NULL) {
 800f0a8:	68fb      	ldr	r3, [r7, #12]
 800f0aa:	2b00      	cmp	r3, #0
 800f0ac:	d02b      	beq.n	800f106 <wolfSSL_X509_STORE_CTX_new_ex+0x6e>
        XMEMSET(ctx, 0, sizeof(WOLFSSL_X509_STORE_CTX));
 800f0ae:	2250      	movs	r2, #80	@ 0x50
 800f0b0:	2100      	movs	r1, #0
 800f0b2:	68f8      	ldr	r0, [r7, #12]
 800f0b4:	f019 fdb6 	bl	8028c24 <memset>
        ctx->heap = heap;
 800f0b8:	68fb      	ldr	r3, [r7, #12]
 800f0ba:	687a      	ldr	r2, [r7, #4]
 800f0bc:	63da      	str	r2, [r3, #60]	@ 0x3c
#ifdef OPENSSL_EXTRA
        if ((ctx->owned = wolfSSL_sk_X509_new_null()) == NULL) {
 800f0be:	f7ff fe1e 	bl	800ecfe <wolfSSL_sk_X509_new_null>
 800f0c2:	4602      	mov	r2, r0
 800f0c4:	68fb      	ldr	r3, [r7, #12]
 800f0c6:	645a      	str	r2, [r3, #68]	@ 0x44
 800f0c8:	68fb      	ldr	r3, [r7, #12]
 800f0ca:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f0cc:	2b00      	cmp	r3, #0
 800f0ce:	d109      	bne.n	800f0e4 <wolfSSL_X509_STORE_CTX_new_ex+0x4c>
            XFREE(ctx, heap, DYNAMIC_TYPE_X509_CTX);
 800f0d0:	68fb      	ldr	r3, [r7, #12]
 800f0d2:	60bb      	str	r3, [r7, #8]
 800f0d4:	68bb      	ldr	r3, [r7, #8]
 800f0d6:	2b00      	cmp	r3, #0
 800f0d8:	d002      	beq.n	800f0e0 <wolfSSL_X509_STORE_CTX_new_ex+0x48>
 800f0da:	68b8      	ldr	r0, [r7, #8]
 800f0dc:	f00f fdea 	bl	801ecb4 <wolfSSL_Free>
            ctx = NULL;
 800f0e0:	2300      	movs	r3, #0
 800f0e2:	60fb      	str	r3, [r7, #12]
        }
        if (ctx != NULL &&
 800f0e4:	68fb      	ldr	r3, [r7, #12]
 800f0e6:	2b00      	cmp	r3, #0
 800f0e8:	d00d      	beq.n	800f106 <wolfSSL_X509_STORE_CTX_new_ex+0x6e>
            wolfSSL_X509_STORE_CTX_init(ctx, NULL, NULL, NULL) !=
 800f0ea:	2300      	movs	r3, #0
 800f0ec:	2200      	movs	r2, #0
 800f0ee:	2100      	movs	r1, #0
 800f0f0:	68f8      	ldr	r0, [r7, #12]
 800f0f2:	f000 f848 	bl	800f186 <wolfSSL_X509_STORE_CTX_init>
 800f0f6:	4603      	mov	r3, r0
        if (ctx != NULL &&
 800f0f8:	2b01      	cmp	r3, #1
 800f0fa:	d004      	beq.n	800f106 <wolfSSL_X509_STORE_CTX_new_ex+0x6e>
                WOLFSSL_SUCCESS) {
            wolfSSL_X509_STORE_CTX_free(ctx);
 800f0fc:	68f8      	ldr	r0, [r7, #12]
 800f0fe:	f000 f807 	bl	800f110 <wolfSSL_X509_STORE_CTX_free>
            ctx = NULL;
 800f102:	2300      	movs	r3, #0
 800f104:	60fb      	str	r3, [r7, #12]
        }
#endif
    }

    return ctx;
 800f106:	68fb      	ldr	r3, [r7, #12]
}
 800f108:	4618      	mov	r0, r3
 800f10a:	3710      	adds	r7, #16
 800f10c:	46bd      	mov	sp, r7
 800f10e:	bd80      	pop	{r7, pc}

0800f110 <wolfSSL_X509_STORE_CTX_free>:

/* This API is necessary outside of OPENSSL_EXTRA because it is used in
 * SetupStoreCtxCallback */
/* free's extra data */
void wolfSSL_X509_STORE_CTX_free(WOLFSSL_X509_STORE_CTX* ctx)
{
 800f110:	b580      	push	{r7, lr}
 800f112:	b084      	sub	sp, #16
 800f114:	af00      	add	r7, sp, #0
 800f116:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_X509_STORE_CTX_free");
    if (ctx != NULL) {
 800f118:	687b      	ldr	r3, [r7, #4]
 800f11a:	2b00      	cmp	r3, #0
 800f11c:	d02f      	beq.n	800f17e <wolfSSL_X509_STORE_CTX_free+0x6e>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
        wolfSSL_CRYPTO_cleanup_ex_data(&ctx->ex_data);
#endif

#ifdef OPENSSL_EXTRA
        XFREE(ctx->param, ctx->heap, DYNAMIC_TYPE_OPENSSL);
 800f11e:	687b      	ldr	r3, [r7, #4]
 800f120:	695b      	ldr	r3, [r3, #20]
 800f122:	60fb      	str	r3, [r7, #12]
 800f124:	68fb      	ldr	r3, [r7, #12]
 800f126:	2b00      	cmp	r3, #0
 800f128:	d002      	beq.n	800f130 <wolfSSL_X509_STORE_CTX_free+0x20>
 800f12a:	68f8      	ldr	r0, [r7, #12]
 800f12c:	f00f fdc2 	bl	801ecb4 <wolfSSL_Free>
        ctx->param = NULL;
 800f130:	687b      	ldr	r3, [r7, #4]
 800f132:	2200      	movs	r2, #0
 800f134:	615a      	str	r2, [r3, #20]

        if (ctx->chain != NULL) {
 800f136:	687b      	ldr	r3, [r7, #4]
 800f138:	691b      	ldr	r3, [r3, #16]
 800f13a:	2b00      	cmp	r3, #0
 800f13c:	d004      	beq.n	800f148 <wolfSSL_X509_STORE_CTX_free+0x38>
            wolfSSL_sk_X509_free(ctx->chain);
 800f13e:	687b      	ldr	r3, [r7, #4]
 800f140:	691b      	ldr	r3, [r3, #16]
 800f142:	4618      	mov	r0, r3
 800f144:	f7ff f9cf 	bl	800e4e6 <wolfSSL_sk_X509_free>
        }
        if (ctx->owned != NULL) {
 800f148:	687b      	ldr	r3, [r7, #4]
 800f14a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f14c:	2b00      	cmp	r3, #0
 800f14e:	d005      	beq.n	800f15c <wolfSSL_X509_STORE_CTX_free+0x4c>
            wolfSSL_sk_X509_pop_free(ctx->owned, NULL);
 800f150:	687b      	ldr	r3, [r7, #4]
 800f152:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f154:	2100      	movs	r1, #0
 800f156:	4618      	mov	r0, r3
 800f158:	f7ff f9b8 	bl	800e4cc <wolfSSL_sk_X509_pop_free>
        }

        if (ctx->current_issuer != NULL) {
 800f15c:	687b      	ldr	r3, [r7, #4]
 800f15e:	689b      	ldr	r3, [r3, #8]
 800f160:	2b00      	cmp	r3, #0
 800f162:	d004      	beq.n	800f16e <wolfSSL_X509_STORE_CTX_free+0x5e>
            wolfSSL_X509_free(ctx->current_issuer);
 800f164:	687b      	ldr	r3, [r7, #4]
 800f166:	689b      	ldr	r3, [r3, #8]
 800f168:	4618      	mov	r0, r3
 800f16a:	f7ff f9a4 	bl	800e4b6 <wolfSSL_X509_free>
        }
#endif

        XFREE(ctx, ctx->heap, DYNAMIC_TYPE_X509_CTX);
 800f16e:	687b      	ldr	r3, [r7, #4]
 800f170:	60bb      	str	r3, [r7, #8]
 800f172:	68bb      	ldr	r3, [r7, #8]
 800f174:	2b00      	cmp	r3, #0
 800f176:	d002      	beq.n	800f17e <wolfSSL_X509_STORE_CTX_free+0x6e>
 800f178:	68b8      	ldr	r0, [r7, #8]
 800f17a:	f00f fd9b 	bl	801ecb4 <wolfSSL_Free>
    }
}
 800f17e:	bf00      	nop
 800f180:	3710      	adds	r7, #16
 800f182:	46bd      	mov	sp, r7
 800f184:	bd80      	pop	{r7, pc}

0800f186 <wolfSSL_X509_STORE_CTX_init>:
}

int wolfSSL_X509_STORE_CTX_init(WOLFSSL_X509_STORE_CTX* ctx,
     WOLFSSL_X509_STORE* store, WOLFSSL_X509* x509,
     WOLF_STACK_OF(WOLFSSL_X509)* sk)
{
 800f186:	b580      	push	{r7, lr}
 800f188:	b084      	sub	sp, #16
 800f18a:	af00      	add	r7, sp, #0
 800f18c:	60f8      	str	r0, [r7, #12]
 800f18e:	60b9      	str	r1, [r7, #8]
 800f190:	607a      	str	r2, [r7, #4]
 800f192:	603b      	str	r3, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_X509_STORE_CTX_init");

    if (ctx != NULL) {
 800f194:	68fb      	ldr	r3, [r7, #12]
 800f196:	2b00      	cmp	r3, #0
 800f198:	d03e      	beq.n	800f218 <wolfSSL_X509_STORE_CTX_init+0x92>
        ctx->store = store;
 800f19a:	68fb      	ldr	r3, [r7, #12]
 800f19c:	68ba      	ldr	r2, [r7, #8]
 800f19e:	601a      	str	r2, [r3, #0]
        #ifndef WOLFSSL_X509_STORE_CERTS
        ctx->current_cert = x509;
 800f1a0:	68fb      	ldr	r3, [r7, #12]
 800f1a2:	687a      	ldr	r2, [r7, #4]
 800f1a4:	605a      	str	r2, [r3, #4]
                return WOLFSSL_FAILURE;
        } else
            ctx->current_cert = NULL;
        #endif

        ctx->ctxIntermediates = sk;
 800f1a6:	68fb      	ldr	r3, [r7, #12]
 800f1a8:	683a      	ldr	r2, [r7, #0]
 800f1aa:	649a      	str	r2, [r3, #72]	@ 0x48
        if (ctx->chain != NULL) {
 800f1ac:	68fb      	ldr	r3, [r7, #12]
 800f1ae:	691b      	ldr	r3, [r3, #16]
 800f1b0:	2b00      	cmp	r3, #0
 800f1b2:	d007      	beq.n	800f1c4 <wolfSSL_X509_STORE_CTX_init+0x3e>
            wolfSSL_sk_X509_free(ctx->chain);
 800f1b4:	68fb      	ldr	r3, [r7, #12]
 800f1b6:	691b      	ldr	r3, [r3, #16]
 800f1b8:	4618      	mov	r0, r3
 800f1ba:	f7ff f994 	bl	800e4e6 <wolfSSL_sk_X509_free>
            ctx->chain = NULL;
 800f1be:	68fb      	ldr	r3, [r7, #12]
 800f1c0:	2200      	movs	r2, #0
 800f1c2:	611a      	str	r2, [r3, #16]
        }
#ifdef SESSION_CERTS
        ctx->sesChain = NULL;
#endif
        ctx->domain = NULL;
 800f1c4:	68fb      	ldr	r3, [r7, #12]
 800f1c6:	2200      	movs	r2, #0
 800f1c8:	619a      	str	r2, [r3, #24]
#ifdef HAVE_EX_DATA
        XMEMSET(&ctx->ex_data, 0, sizeof(ctx->ex_data));
#endif
        ctx->userCtx = NULL;
 800f1ca:	68fb      	ldr	r3, [r7, #12]
 800f1cc:	2200      	movs	r2, #0
 800f1ce:	621a      	str	r2, [r3, #32]
        ctx->error = 0;
 800f1d0:	68fb      	ldr	r3, [r7, #12]
 800f1d2:	2200      	movs	r2, #0
 800f1d4:	625a      	str	r2, [r3, #36]	@ 0x24
        ctx->error_depth = 0;
 800f1d6:	68fb      	ldr	r3, [r7, #12]
 800f1d8:	2200      	movs	r2, #0
 800f1da:	629a      	str	r2, [r3, #40]	@ 0x28
        ctx->discardSessionCerts = 0;
 800f1dc:	68fb      	ldr	r3, [r7, #12]
 800f1de:	2200      	movs	r2, #0
 800f1e0:	62da      	str	r2, [r3, #44]	@ 0x2c

        if (ctx->param == NULL) {
 800f1e2:	68fb      	ldr	r3, [r7, #12]
 800f1e4:	695b      	ldr	r3, [r3, #20]
 800f1e6:	2b00      	cmp	r3, #0
 800f1e8:	d114      	bne.n	800f214 <wolfSSL_X509_STORE_CTX_init+0x8e>
            ctx->param = (WOLFSSL_X509_VERIFY_PARAM*)XMALLOC(
 800f1ea:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 800f1ee:	f00f fd45 	bl	801ec7c <wolfSSL_Malloc>
 800f1f2:	4602      	mov	r2, r0
 800f1f4:	68fb      	ldr	r3, [r7, #12]
 800f1f6:	615a      	str	r2, [r3, #20]
                           sizeof(WOLFSSL_X509_VERIFY_PARAM),
                           ctx->heap, DYNAMIC_TYPE_OPENSSL);
            if (ctx->param == NULL){
 800f1f8:	68fb      	ldr	r3, [r7, #12]
 800f1fa:	695b      	ldr	r3, [r3, #20]
 800f1fc:	2b00      	cmp	r3, #0
 800f1fe:	d101      	bne.n	800f204 <wolfSSL_X509_STORE_CTX_init+0x7e>
                WOLFSSL_MSG("wolfSSL_X509_STORE_CTX_init failed");
                return WOLFSSL_FAILURE;
 800f200:	2300      	movs	r3, #0
 800f202:	e00a      	b.n	800f21a <wolfSSL_X509_STORE_CTX_init+0x94>
            }
            XMEMSET(ctx->param, 0, sizeof(*ctx->param));
 800f204:	68fb      	ldr	r3, [r7, #12]
 800f206:	695b      	ldr	r3, [r3, #20]
 800f208:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 800f20c:	2100      	movs	r1, #0
 800f20e:	4618      	mov	r0, r3
 800f210:	f019 fd08 	bl	8028c24 <memset>
        }

        return WOLFSSL_SUCCESS;
 800f214:	2301      	movs	r3, #1
 800f216:	e000      	b.n	800f21a <wolfSSL_X509_STORE_CTX_init+0x94>
    }
    return WOLFSSL_FAILURE;
 800f218:	2300      	movs	r3, #0
}
 800f21a:	4618      	mov	r0, r3
 800f21c:	3710      	adds	r7, #16
 800f21e:	46bd      	mov	sp, r7
 800f220:	bd80      	pop	{r7, pc}

0800f222 <wolfSSL_X509_STORE_free>:
    wolfSSL_sk_X509_OBJECT_pop_free(objs, NULL);
}
#endif

void wolfSSL_X509_STORE_free(WOLFSSL_X509_STORE* store)
{
 800f222:	b580      	push	{r7, lr}
 800f224:	b088      	sub	sp, #32
 800f226:	af00      	add	r7, sp, #0
 800f228:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800f22a:	2300      	movs	r3, #0
 800f22c:	60fb      	str	r3, [r7, #12]
    if (store != NULL && store->isDynamic) {
 800f22e:	687b      	ldr	r3, [r7, #4]
 800f230:	2b00      	cmp	r3, #0
 800f232:	d073      	beq.n	800f31c <wolfSSL_X509_STORE_free+0xfa>
 800f234:	687b      	ldr	r3, [r7, #4]
 800f236:	695b      	ldr	r3, [r3, #20]
 800f238:	2b00      	cmp	r3, #0
 800f23a:	d06f      	beq.n	800f31c <wolfSSL_X509_STORE_free+0xfa>
        int ret;
        wolfSSL_RefDec(&store->ref, &doFree, &ret);
 800f23c:	687b      	ldr	r3, [r7, #4]
 800f23e:	331c      	adds	r3, #28
 800f240:	2101      	movs	r1, #1
 800f242:	4618      	mov	r0, r3
 800f244:	f7fc f826 	bl	800b294 <wolfSSL_Atomic_Int_FetchSub>
 800f248:	61f8      	str	r0, [r7, #28]
 800f24a:	69fb      	ldr	r3, [r7, #28]
 800f24c:	2b01      	cmp	r3, #1
 800f24e:	bf0c      	ite	eq
 800f250:	2301      	moveq	r3, #1
 800f252:	2300      	movne	r3, #0
 800f254:	b2db      	uxtb	r3, r3
 800f256:	60fb      	str	r3, [r7, #12]
 800f258:	2300      	movs	r3, #0
 800f25a:	60bb      	str	r3, [r7, #8]
        }
    #else
        (void)ret;
    #endif

        if (doFree) {
 800f25c:	68fb      	ldr	r3, [r7, #12]
 800f25e:	2b00      	cmp	r3, #0
 800f260:	d05c      	beq.n	800f31c <wolfSSL_X509_STORE_free+0xfa>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
            wolfSSL_CRYPTO_cleanup_ex_data(&store->ex_data);
#endif
            if (store->cm != NULL) {
 800f262:	687b      	ldr	r3, [r7, #4]
 800f264:	685b      	ldr	r3, [r3, #4]
 800f266:	2b00      	cmp	r3, #0
 800f268:	d007      	beq.n	800f27a <wolfSSL_X509_STORE_free+0x58>
                wolfSSL_CertManagerFree(store->cm);
 800f26a:	687b      	ldr	r3, [r7, #4]
 800f26c:	685b      	ldr	r3, [r3, #4]
 800f26e:	4618      	mov	r0, r3
 800f270:	f7fc fa69 	bl	800b746 <wolfSSL_CertManagerFree>
                store->cm = NULL;
 800f274:	687b      	ldr	r3, [r7, #4]
 800f276:	2200      	movs	r2, #0
 800f278:	605a      	str	r2, [r3, #4]
            }
#if defined(OPENSSL_EXTRA)
            if (store->certs != NULL) {
 800f27a:	687b      	ldr	r3, [r7, #4]
 800f27c:	6a1b      	ldr	r3, [r3, #32]
 800f27e:	2b00      	cmp	r3, #0
 800f280:	d008      	beq.n	800f294 <wolfSSL_X509_STORE_free+0x72>
                wolfSSL_sk_X509_pop_free(store->certs, NULL);
 800f282:	687b      	ldr	r3, [r7, #4]
 800f284:	6a1b      	ldr	r3, [r3, #32]
 800f286:	2100      	movs	r1, #0
 800f288:	4618      	mov	r0, r3
 800f28a:	f7ff f91f 	bl	800e4cc <wolfSSL_sk_X509_pop_free>
                store->certs = NULL;
 800f28e:	687b      	ldr	r3, [r7, #4]
 800f290:	2200      	movs	r2, #0
 800f292:	621a      	str	r2, [r3, #32]
            }
            if (store->owned != NULL) {
 800f294:	687b      	ldr	r3, [r7, #4]
 800f296:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f298:	2b00      	cmp	r3, #0
 800f29a:	d008      	beq.n	800f2ae <wolfSSL_X509_STORE_free+0x8c>
                wolfSSL_sk_X509_pop_free(store->owned, NULL);
 800f29c:	687b      	ldr	r3, [r7, #4]
 800f29e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f2a0:	2100      	movs	r1, #0
 800f2a2:	4618      	mov	r0, r3
 800f2a4:	f7ff f912 	bl	800e4cc <wolfSSL_sk_X509_pop_free>
                store->owned = NULL;
 800f2a8:	687b      	ldr	r3, [r7, #4]
 800f2aa:	2200      	movs	r2, #0
 800f2ac:	629a      	str	r2, [r3, #40]	@ 0x28
            }
            if (store->trusted != NULL) {
 800f2ae:	687b      	ldr	r3, [r7, #4]
 800f2b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f2b2:	2b00      	cmp	r3, #0
 800f2b4:	d008      	beq.n	800f2c8 <wolfSSL_X509_STORE_free+0xa6>
                wolfSSL_sk_X509_pop_free(store->trusted, NULL);
 800f2b6:	687b      	ldr	r3, [r7, #4]
 800f2b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f2ba:	2100      	movs	r1, #0
 800f2bc:	4618      	mov	r0, r3
 800f2be:	f7ff f905 	bl	800e4cc <wolfSSL_sk_X509_pop_free>
                store->trusted = NULL;
 800f2c2:	687b      	ldr	r3, [r7, #4]
 800f2c4:	2200      	movs	r2, #0
 800f2c6:	625a      	str	r2, [r3, #36]	@ 0x24
            if (store->objs != NULL) {
                X509StoreFreeObjList(store, store->objs);
            }
#endif
#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
            XFREE(store->param, NULL, DYNAMIC_TYPE_OPENSSL);
 800f2c8:	687b      	ldr	r3, [r7, #4]
 800f2ca:	699b      	ldr	r3, [r3, #24]
 800f2cc:	61bb      	str	r3, [r7, #24]
 800f2ce:	69bb      	ldr	r3, [r7, #24]
 800f2d0:	2b00      	cmp	r3, #0
 800f2d2:	d002      	beq.n	800f2da <wolfSSL_X509_STORE_free+0xb8>
 800f2d4:	69b8      	ldr	r0, [r7, #24]
 800f2d6:	f00f fced 	bl	801ecb4 <wolfSSL_Free>
            store->param = NULL;
 800f2da:	687b      	ldr	r3, [r7, #4]
 800f2dc:	2200      	movs	r2, #0
 800f2de:	619a      	str	r2, [r3, #24]

            if (store->lookup.dirs != NULL) {
 800f2e0:	687b      	ldr	r3, [r7, #4]
 800f2e2:	691b      	ldr	r3, [r3, #16]
 800f2e4:	2b00      	cmp	r3, #0
 800f2e6:	d011      	beq.n	800f30c <wolfSSL_X509_STORE_free+0xea>
                if (store->lookup.dirs->dir_entry) {
                    wolfSSL_sk_BY_DIR_entry_free(
                        store->lookup.dirs->dir_entry);
                }
#endif
                wc_FreeMutex(&store->lookup.dirs->lock);
 800f2e8:	687b      	ldr	r3, [r7, #4]
 800f2ea:	691b      	ldr	r3, [r3, #16]
 800f2ec:	3304      	adds	r3, #4
 800f2ee:	4618      	mov	r0, r3
 800f2f0:	f018 f9f3 	bl	80276da <wc_FreeMutex>
                XFREE(store->lookup.dirs, NULL, DYNAMIC_TYPE_OPENSSL);
 800f2f4:	687b      	ldr	r3, [r7, #4]
 800f2f6:	691b      	ldr	r3, [r3, #16]
 800f2f8:	617b      	str	r3, [r7, #20]
 800f2fa:	697b      	ldr	r3, [r7, #20]
 800f2fc:	2b00      	cmp	r3, #0
 800f2fe:	d002      	beq.n	800f306 <wolfSSL_X509_STORE_free+0xe4>
 800f300:	6978      	ldr	r0, [r7, #20]
 800f302:	f00f fcd7 	bl	801ecb4 <wolfSSL_Free>
                store->lookup.dirs = NULL;
 800f306:	687b      	ldr	r3, [r7, #4]
 800f308:	2200      	movs	r2, #0
 800f30a:	611a      	str	r2, [r3, #16]
            }
#endif
            wolfSSL_RefFree(&store->ref);
            XFREE(store, NULL, DYNAMIC_TYPE_X509_STORE);
 800f30c:	687b      	ldr	r3, [r7, #4]
 800f30e:	613b      	str	r3, [r7, #16]
 800f310:	693b      	ldr	r3, [r7, #16]
 800f312:	2b00      	cmp	r3, #0
 800f314:	d002      	beq.n	800f31c <wolfSSL_X509_STORE_free+0xfa>
 800f316:	6938      	ldr	r0, [r7, #16]
 800f318:	f00f fccc 	bl	801ecb4 <wolfSSL_Free>
        }
    }
}
 800f31c:	bf00      	nop
 800f31e:	3720      	adds	r7, #32
 800f320:	46bd      	mov	sp, r7
 800f322:	bd80      	pop	{r7, pc}

0800f324 <wolfSSL_FIPS_drbg_uninstantiate>:
    (void)adin;
    (void)adinlen;
    return ret;
}
int wolfSSL_FIPS_drbg_uninstantiate(WOLFSSL_DRBG_CTX *ctx)
{
 800f324:	b580      	push	{r7, lr}
 800f326:	b082      	sub	sp, #8
 800f328:	af00      	add	r7, sp, #0
 800f32a:	6078      	str	r0, [r7, #4]
    if (ctx != NULL && ctx->rng != NULL) {
 800f32c:	687b      	ldr	r3, [r7, #4]
 800f32e:	2b00      	cmp	r3, #0
 800f330:	d00e      	beq.n	800f350 <wolfSSL_FIPS_drbg_uninstantiate+0x2c>
 800f332:	687b      	ldr	r3, [r7, #4]
 800f334:	681b      	ldr	r3, [r3, #0]
 800f336:	2b00      	cmp	r3, #0
 800f338:	d00a      	beq.n	800f350 <wolfSSL_FIPS_drbg_uninstantiate+0x2c>
    #if !defined(HAVE_SELFTEST) && (!defined(HAVE_FIPS) || \
        (defined(HAVE_FIPS) && FIPS_VERSION_GE(5,0)))
        wc_rng_free(ctx->rng);
 800f33a:	687b      	ldr	r3, [r7, #4]
 800f33c:	681b      	ldr	r3, [r3, #0]
 800f33e:	4618      	mov	r0, r3
 800f340:	f010 f9f4 	bl	801f72c <wc_rng_free>
    #else
        wc_FreeRng(ctx->rng);
        XFREE(ctx->rng, NULL, DYNAMIC_TYPE_RNG);
    #endif
        ctx->rng = NULL;
 800f344:	687b      	ldr	r3, [r7, #4]
 800f346:	2200      	movs	r2, #0
 800f348:	601a      	str	r2, [r3, #0]
        ctx->status = DRBG_STATUS_UNINITIALISED;
 800f34a:	687b      	ldr	r3, [r7, #4]
 800f34c:	2200      	movs	r2, #0
 800f34e:	61da      	str	r2, [r3, #28]
    }
    return WOLFSSL_SUCCESS;
 800f350:	2301      	movs	r3, #1
}
 800f352:	4618      	mov	r0, r3
 800f354:	3708      	adds	r7, #8
 800f356:	46bd      	mov	sp, r7
 800f358:	bd80      	pop	{r7, pc}
	...

0800f35c <wolfSSL_FIPS_drbg_free>:
void wolfSSL_FIPS_drbg_free(WOLFSSL_DRBG_CTX *ctx)
{
 800f35c:	b580      	push	{r7, lr}
 800f35e:	b084      	sub	sp, #16
 800f360:	af00      	add	r7, sp, #0
 800f362:	6078      	str	r0, [r7, #4]
    if (ctx != NULL) {
 800f364:	687b      	ldr	r3, [r7, #4]
 800f366:	2b00      	cmp	r3, #0
 800f368:	d012      	beq.n	800f390 <wolfSSL_FIPS_drbg_free+0x34>
        /* As safety check if free'ing the default drbg, then mark global NULL.
         * Technically the user should not call free on the default drbg. */
        if (ctx == gDrbgDefCtx) {
 800f36a:	4b0b      	ldr	r3, [pc, #44]	@ (800f398 <wolfSSL_FIPS_drbg_free+0x3c>)
 800f36c:	681b      	ldr	r3, [r3, #0]
 800f36e:	687a      	ldr	r2, [r7, #4]
 800f370:	429a      	cmp	r2, r3
 800f372:	d102      	bne.n	800f37a <wolfSSL_FIPS_drbg_free+0x1e>
            gDrbgDefCtx = NULL;
 800f374:	4b08      	ldr	r3, [pc, #32]	@ (800f398 <wolfSSL_FIPS_drbg_free+0x3c>)
 800f376:	2200      	movs	r2, #0
 800f378:	601a      	str	r2, [r3, #0]
        }
        wolfSSL_FIPS_drbg_uninstantiate(ctx);
 800f37a:	6878      	ldr	r0, [r7, #4]
 800f37c:	f7ff ffd2 	bl	800f324 <wolfSSL_FIPS_drbg_uninstantiate>
        XFREE(ctx, NULL, DYNAMIC_TYPE_OPENSSL);
 800f380:	687b      	ldr	r3, [r7, #4]
 800f382:	60fb      	str	r3, [r7, #12]
 800f384:	68fb      	ldr	r3, [r7, #12]
 800f386:	2b00      	cmp	r3, #0
 800f388:	d002      	beq.n	800f390 <wolfSSL_FIPS_drbg_free+0x34>
 800f38a:	68f8      	ldr	r0, [r7, #12]
 800f38c:	f00f fc92 	bl	801ecb4 <wolfSSL_Free>
    }
}
 800f390:	bf00      	nop
 800f392:	3710      	adds	r7, #16
 800f394:	46bd      	mov	sp, r7
 800f396:	bd80      	pop	{r7, pc}
 800f398:	20001c0c 	.word	0x20001c0c

0800f39c <MakeTLSv1_2>:


#ifndef WOLFSSL_NO_TLS12

ProtocolVersion MakeTLSv1_2(void)
{
 800f39c:	b480      	push	{r7}
 800f39e:	b083      	sub	sp, #12
 800f3a0:	af00      	add	r7, sp, #0
    ProtocolVersion pv;
    pv.major = SSLv3_MAJOR;
 800f3a2:	2303      	movs	r3, #3
 800f3a4:	703b      	strb	r3, [r7, #0]
    pv.minor = TLSv1_2_MINOR;
 800f3a6:	2303      	movs	r3, #3
 800f3a8:	707b      	strb	r3, [r7, #1]

    return pv;
 800f3aa:	883b      	ldrh	r3, [r7, #0]
 800f3ac:	80bb      	strh	r3, [r7, #4]
 800f3ae:	2300      	movs	r3, #0
 800f3b0:	793a      	ldrb	r2, [r7, #4]
 800f3b2:	f362 0307 	bfi	r3, r2, #0, #8
 800f3b6:	797a      	ldrb	r2, [r7, #5]
 800f3b8:	f362 230f 	bfi	r3, r2, #8, #8
}
 800f3bc:	4618      	mov	r0, r3
 800f3be:	370c      	adds	r7, #12
 800f3c0:	46bd      	mov	sp, r7
 800f3c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3c6:	4770      	bx	lr

0800f3c8 <TLSX_SNI_Free>:
    return sni;
}

/** Releases a SNI object. */
static void TLSX_SNI_Free(SNI* sni, void* heap)
{
 800f3c8:	b580      	push	{r7, lr}
 800f3ca:	b084      	sub	sp, #16
 800f3cc:	af00      	add	r7, sp, #0
 800f3ce:	6078      	str	r0, [r7, #4]
 800f3d0:	6039      	str	r1, [r7, #0]
    if (sni) {
 800f3d2:	687b      	ldr	r3, [r7, #4]
 800f3d4:	2b00      	cmp	r3, #0
 800f3d6:	d015      	beq.n	800f404 <TLSX_SNI_Free+0x3c>
        switch (sni->type) {
 800f3d8:	687b      	ldr	r3, [r7, #4]
 800f3da:	781b      	ldrb	r3, [r3, #0]
 800f3dc:	2b00      	cmp	r3, #0
 800f3de:	d109      	bne.n	800f3f4 <TLSX_SNI_Free+0x2c>
            case WOLFSSL_SNI_HOST_NAME:
                XFREE(sni->data.host_name, heap, DYNAMIC_TYPE_TLSX);
 800f3e0:	687b      	ldr	r3, [r7, #4]
 800f3e2:	685b      	ldr	r3, [r3, #4]
 800f3e4:	60fb      	str	r3, [r7, #12]
 800f3e6:	68fb      	ldr	r3, [r7, #12]
 800f3e8:	2b00      	cmp	r3, #0
 800f3ea:	d002      	beq.n	800f3f2 <TLSX_SNI_Free+0x2a>
 800f3ec:	68f8      	ldr	r0, [r7, #12]
 800f3ee:	f00f fc61 	bl	801ecb4 <wolfSSL_Free>
            break;
 800f3f2:	bf00      	nop
        }

        XFREE(sni, heap, DYNAMIC_TYPE_TLSX);
 800f3f4:	687b      	ldr	r3, [r7, #4]
 800f3f6:	60bb      	str	r3, [r7, #8]
 800f3f8:	68bb      	ldr	r3, [r7, #8]
 800f3fa:	2b00      	cmp	r3, #0
 800f3fc:	d002      	beq.n	800f404 <TLSX_SNI_Free+0x3c>
 800f3fe:	68b8      	ldr	r0, [r7, #8]
 800f400:	f00f fc58 	bl	801ecb4 <wolfSSL_Free>
    }
    (void)heap;
}
 800f404:	bf00      	nop
 800f406:	3710      	adds	r7, #16
 800f408:	46bd      	mov	sp, r7
 800f40a:	bd80      	pop	{r7, pc}

0800f40c <TLSX_SNI_FreeAll>:

/** Releases all SNI objects in the provided list. */
static void TLSX_SNI_FreeAll(SNI* list, void* heap)
{
 800f40c:	b580      	push	{r7, lr}
 800f40e:	b084      	sub	sp, #16
 800f410:	af00      	add	r7, sp, #0
 800f412:	6078      	str	r0, [r7, #4]
 800f414:	6039      	str	r1, [r7, #0]
    SNI* sni;

    while ((sni = list)) {
 800f416:	e006      	b.n	800f426 <TLSX_SNI_FreeAll+0x1a>
        list = sni->next;
 800f418:	68fb      	ldr	r3, [r7, #12]
 800f41a:	689b      	ldr	r3, [r3, #8]
 800f41c:	607b      	str	r3, [r7, #4]
        TLSX_SNI_Free(sni, heap);
 800f41e:	6839      	ldr	r1, [r7, #0]
 800f420:	68f8      	ldr	r0, [r7, #12]
 800f422:	f7ff ffd1 	bl	800f3c8 <TLSX_SNI_Free>
    while ((sni = list)) {
 800f426:	687b      	ldr	r3, [r7, #4]
 800f428:	60fb      	str	r3, [r7, #12]
 800f42a:	68fb      	ldr	r3, [r7, #12]
 800f42c:	2b00      	cmp	r3, #0
 800f42e:	d1f3      	bne.n	800f418 <TLSX_SNI_FreeAll+0xc>
    }
}
 800f430:	bf00      	nop
 800f432:	bf00      	nop
 800f434:	3710      	adds	r7, #16
 800f436:	46bd      	mov	sp, r7
 800f438:	bd80      	pop	{r7, pc}

0800f43a <TLSX_SupportedCurve_FreeAll>:

    return 0;
}

static void TLSX_SupportedCurve_FreeAll(SupportedCurve* list, void* heap)
{
 800f43a:	b580      	push	{r7, lr}
 800f43c:	b084      	sub	sp, #16
 800f43e:	af00      	add	r7, sp, #0
 800f440:	6078      	str	r0, [r7, #4]
 800f442:	6039      	str	r1, [r7, #0]
    SupportedCurve* curve;

    while ((curve = list)) {
 800f444:	e00a      	b.n	800f45c <TLSX_SupportedCurve_FreeAll+0x22>
        list = curve->next;
 800f446:	68fb      	ldr	r3, [r7, #12]
 800f448:	685b      	ldr	r3, [r3, #4]
 800f44a:	607b      	str	r3, [r7, #4]
        XFREE(curve, heap, DYNAMIC_TYPE_TLSX);
 800f44c:	68fb      	ldr	r3, [r7, #12]
 800f44e:	60bb      	str	r3, [r7, #8]
 800f450:	68bb      	ldr	r3, [r7, #8]
 800f452:	2b00      	cmp	r3, #0
 800f454:	d002      	beq.n	800f45c <TLSX_SupportedCurve_FreeAll+0x22>
 800f456:	68b8      	ldr	r0, [r7, #8]
 800f458:	f00f fc2c 	bl	801ecb4 <wolfSSL_Free>
    while ((curve = list)) {
 800f45c:	687b      	ldr	r3, [r7, #4]
 800f45e:	60fb      	str	r3, [r7, #12]
 800f460:	68fb      	ldr	r3, [r7, #12]
 800f462:	2b00      	cmp	r3, #0
 800f464:	d1ef      	bne.n	800f446 <TLSX_SupportedCurve_FreeAll+0xc>
    }
    (void)heap;
}
 800f466:	bf00      	nop
 800f468:	bf00      	nop
 800f46a:	3710      	adds	r7, #16
 800f46c:	46bd      	mov	sp, r7
 800f46e:	bd80      	pop	{r7, pc}

0800f470 <TLSX_PointFormat_FreeAll>:

static void TLSX_PointFormat_FreeAll(PointFormat* list, void* heap)
{
 800f470:	b580      	push	{r7, lr}
 800f472:	b084      	sub	sp, #16
 800f474:	af00      	add	r7, sp, #0
 800f476:	6078      	str	r0, [r7, #4]
 800f478:	6039      	str	r1, [r7, #0]
    PointFormat* point;

    while ((point = list)) {
 800f47a:	e00a      	b.n	800f492 <TLSX_PointFormat_FreeAll+0x22>
        list = point->next;
 800f47c:	68fb      	ldr	r3, [r7, #12]
 800f47e:	685b      	ldr	r3, [r3, #4]
 800f480:	607b      	str	r3, [r7, #4]
        XFREE(point, heap, DYNAMIC_TYPE_TLSX);
 800f482:	68fb      	ldr	r3, [r7, #12]
 800f484:	60bb      	str	r3, [r7, #8]
 800f486:	68bb      	ldr	r3, [r7, #8]
 800f488:	2b00      	cmp	r3, #0
 800f48a:	d002      	beq.n	800f492 <TLSX_PointFormat_FreeAll+0x22>
 800f48c:	68b8      	ldr	r0, [r7, #8]
 800f48e:	f00f fc11 	bl	801ecb4 <wolfSSL_Free>
    while ((point = list)) {
 800f492:	687b      	ldr	r3, [r7, #4]
 800f494:	60fb      	str	r3, [r7, #12]
 800f496:	68fb      	ldr	r3, [r7, #12]
 800f498:	2b00      	cmp	r3, #0
 800f49a:	d1ef      	bne.n	800f47c <TLSX_PointFormat_FreeAll+0xc>
    }
    (void)heap;
}
 800f49c:	bf00      	nop
 800f49e:	bf00      	nop
 800f4a0:	3710      	adds	r7, #16
 800f4a2:	46bd      	mov	sp, r7
 800f4a4:	bd80      	pop	{r7, pc}

0800f4a6 <TLSX_SignatureAlgorithms_FreeAll>:
    return sa;
}

void TLSX_SignatureAlgorithms_FreeAll(SignatureAlgorithms* sa,
                                             void* heap)
{
 800f4a6:	b580      	push	{r7, lr}
 800f4a8:	b084      	sub	sp, #16
 800f4aa:	af00      	add	r7, sp, #0
 800f4ac:	6078      	str	r0, [r7, #4]
 800f4ae:	6039      	str	r1, [r7, #0]
    XFREE(sa, heap, DYNAMIC_TYPE_TLSX);
 800f4b0:	687b      	ldr	r3, [r7, #4]
 800f4b2:	60fb      	str	r3, [r7, #12]
 800f4b4:	68fb      	ldr	r3, [r7, #12]
 800f4b6:	2b00      	cmp	r3, #0
 800f4b8:	d002      	beq.n	800f4c0 <TLSX_SignatureAlgorithms_FreeAll+0x1a>
 800f4ba:	68f8      	ldr	r0, [r7, #12]
 800f4bc:	f00f fbfa 	bl	801ecb4 <wolfSSL_Free>
    (void)heap;
}
 800f4c0:	bf00      	nop
 800f4c2:	3710      	adds	r7, #16
 800f4c4:	46bd      	mov	sp, r7
 800f4c6:	bd80      	pop	{r7, pc}

0800f4c8 <TLSX_KeyShare_FreeAll>:
 *
 * list  The linked list of key share entry objects.
 * heap  The heap used for allocation.
 */
static void TLSX_KeyShare_FreeAll(KeyShareEntry* list, void* heap)
{
 800f4c8:	b580      	push	{r7, lr}
 800f4ca:	b088      	sub	sp, #32
 800f4cc:	af00      	add	r7, sp, #0
 800f4ce:	6078      	str	r0, [r7, #4]
 800f4d0:	6039      	str	r1, [r7, #0]
    KeyShareEntry* current;

    while ((current = list) != NULL) {
 800f4d2:	e04a      	b.n	800f56a <TLSX_KeyShare_FreeAll+0xa2>
        list = current->next;
 800f4d4:	69fb      	ldr	r3, [r7, #28]
 800f4d6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f4d8:	607b      	str	r3, [r7, #4]
        if (WOLFSSL_NAMED_GROUP_IS_FFHDE(current->group)) {
 800f4da:	69fb      	ldr	r3, [r7, #28]
 800f4dc:	881b      	ldrh	r3, [r3, #0]
 800f4de:	2bff      	cmp	r3, #255	@ 0xff
 800f4e0:	d90a      	bls.n	800f4f8 <TLSX_KeyShare_FreeAll+0x30>
 800f4e2:	69fb      	ldr	r3, [r7, #28]
 800f4e4:	881b      	ldrh	r3, [r3, #0]
 800f4e6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800f4ea:	d205      	bcs.n	800f4f8 <TLSX_KeyShare_FreeAll+0x30>
#ifndef NO_DH
            wc_FreeDhKey((DhKey*)current->key);
 800f4ec:	69fb      	ldr	r3, [r7, #28]
 800f4ee:	68db      	ldr	r3, [r3, #12]
 800f4f0:	4618      	mov	r0, r3
 800f4f2:	f00b f9df 	bl	801a8b4 <wc_FreeDhKey>
 800f4f6:	e00c      	b.n	800f512 <TLSX_KeyShare_FreeAll+0x4a>
#endif
        }
        else if (current->group == WOLFSSL_ECC_X25519) {
 800f4f8:	69fb      	ldr	r3, [r7, #28]
 800f4fa:	881b      	ldrh	r3, [r3, #0]
 800f4fc:	2b1d      	cmp	r3, #29
 800f4fe:	d008      	beq.n	800f512 <TLSX_KeyShare_FreeAll+0x4a>
#ifdef HAVE_CURVE25519
            wc_curve25519_free((curve25519_key*)current->key);
#endif
        }
        else if (current->group == WOLFSSL_ECC_X448) {
 800f500:	69fb      	ldr	r3, [r7, #28]
 800f502:	881b      	ldrh	r3, [r3, #0]
 800f504:	2b1e      	cmp	r3, #30
 800f506:	d004      	beq.n	800f512 <TLSX_KeyShare_FreeAll+0x4a>
            }
        }
#endif
        else {
#ifdef HAVE_ECC
            wc_ecc_free((ecc_key*)current->key);
 800f508:	69fb      	ldr	r3, [r7, #28]
 800f50a:	68db      	ldr	r3, [r3, #12]
 800f50c:	4618      	mov	r0, r3
 800f50e:	f00d fdbc 	bl	801d08a <wc_ecc_free>
#endif
        }
        XFREE(current->key, heap, DYNAMIC_TYPE_PRIVATE_KEY);
 800f512:	69fb      	ldr	r3, [r7, #28]
 800f514:	68db      	ldr	r3, [r3, #12]
 800f516:	61bb      	str	r3, [r7, #24]
 800f518:	69bb      	ldr	r3, [r7, #24]
 800f51a:	2b00      	cmp	r3, #0
 800f51c:	d002      	beq.n	800f524 <TLSX_KeyShare_FreeAll+0x5c>
 800f51e:	69b8      	ldr	r0, [r7, #24]
 800f520:	f00f fbc8 	bl	801ecb4 <wolfSSL_Free>
    #if !defined(NO_DH) && (!defined(NO_CERTS) || !defined(NO_PSK))
        XFREE(current->privKey, heap, DYNAMIC_TYPE_PRIVATE_KEY);
 800f524:	69fb      	ldr	r3, [r7, #28]
 800f526:	69db      	ldr	r3, [r3, #28]
 800f528:	617b      	str	r3, [r7, #20]
 800f52a:	697b      	ldr	r3, [r7, #20]
 800f52c:	2b00      	cmp	r3, #0
 800f52e:	d002      	beq.n	800f536 <TLSX_KeyShare_FreeAll+0x6e>
 800f530:	6978      	ldr	r0, [r7, #20]
 800f532:	f00f fbbf 	bl	801ecb4 <wolfSSL_Free>
    #endif
        XFREE(current->pubKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800f536:	69fb      	ldr	r3, [r7, #28]
 800f538:	695b      	ldr	r3, [r3, #20]
 800f53a:	613b      	str	r3, [r7, #16]
 800f53c:	693b      	ldr	r3, [r7, #16]
 800f53e:	2b00      	cmp	r3, #0
 800f540:	d002      	beq.n	800f548 <TLSX_KeyShare_FreeAll+0x80>
 800f542:	6938      	ldr	r0, [r7, #16]
 800f544:	f00f fbb6 	bl	801ecb4 <wolfSSL_Free>
        XFREE(current->ke, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800f548:	69fb      	ldr	r3, [r7, #28]
 800f54a:	685b      	ldr	r3, [r3, #4]
 800f54c:	60fb      	str	r3, [r7, #12]
 800f54e:	68fb      	ldr	r3, [r7, #12]
 800f550:	2b00      	cmp	r3, #0
 800f552:	d002      	beq.n	800f55a <TLSX_KeyShare_FreeAll+0x92>
 800f554:	68f8      	ldr	r0, [r7, #12]
 800f556:	f00f fbad 	bl	801ecb4 <wolfSSL_Free>
        XFREE(current, heap, DYNAMIC_TYPE_TLSX);
 800f55a:	69fb      	ldr	r3, [r7, #28]
 800f55c:	60bb      	str	r3, [r7, #8]
 800f55e:	68bb      	ldr	r3, [r7, #8]
 800f560:	2b00      	cmp	r3, #0
 800f562:	d002      	beq.n	800f56a <TLSX_KeyShare_FreeAll+0xa2>
 800f564:	68b8      	ldr	r0, [r7, #8]
 800f566:	f00f fba5 	bl	801ecb4 <wolfSSL_Free>
    while ((current = list) != NULL) {
 800f56a:	687b      	ldr	r3, [r7, #4]
 800f56c:	61fb      	str	r3, [r7, #28]
 800f56e:	69fb      	ldr	r3, [r7, #28]
 800f570:	2b00      	cmp	r3, #0
 800f572:	d1af      	bne.n	800f4d4 <TLSX_KeyShare_FreeAll+0xc>
    }

    (void)heap;
}
 800f574:	bf00      	nop
 800f576:	bf00      	nop
 800f578:	3720      	adds	r7, #32
 800f57a:	46bd      	mov	sp, r7
 800f57c:	bd80      	pop	{r7, pc}
	...

0800f580 <TLSX_FreeAll>:

#endif

/** Releases all extensions in the provided list. */
void TLSX_FreeAll(TLSX* list, void* heap)
{
 800f580:	b580      	push	{r7, lr}
 800f582:	b084      	sub	sp, #16
 800f584:	af00      	add	r7, sp, #0
 800f586:	6078      	str	r0, [r7, #4]
 800f588:	6039      	str	r1, [r7, #0]
    TLSX* extension;

    while ((extension = list)) {
 800f58a:	e0aa      	b.n	800f6e2 <TLSX_FreeAll+0x162>
        list = extension->next;
 800f58c:	68fb      	ldr	r3, [r7, #12]
 800f58e:	691b      	ldr	r3, [r3, #16]
 800f590:	607b      	str	r3, [r7, #4]

        switch (extension->type) {
 800f592:	68fb      	ldr	r3, [r7, #12]
 800f594:	881b      	ldrh	r3, [r3, #0]
 800f596:	2b33      	cmp	r3, #51	@ 0x33
 800f598:	dc70      	bgt.n	800f67c <TLSX_FreeAll+0xfc>
 800f59a:	2b00      	cmp	r3, #0
 800f59c:	f2c0 8096 	blt.w	800f6cc <TLSX_FreeAll+0x14c>
 800f5a0:	2b33      	cmp	r3, #51	@ 0x33
 800f5a2:	f200 8093 	bhi.w	800f6cc <TLSX_FreeAll+0x14c>
 800f5a6:	a201      	add	r2, pc, #4	@ (adr r2, 800f5ac <TLSX_FreeAll+0x2c>)
 800f5a8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f5ac:	0800f687 	.word	0x0800f687
 800f5b0:	0800f6cd 	.word	0x0800f6cd
 800f5b4:	0800f6cd 	.word	0x0800f6cd
 800f5b8:	0800f6cd 	.word	0x0800f6cd
 800f5bc:	0800f6cd 	.word	0x0800f6cd
 800f5c0:	0800f6cd 	.word	0x0800f6cd
 800f5c4:	0800f6cd 	.word	0x0800f6cd
 800f5c8:	0800f6cd 	.word	0x0800f6cd
 800f5cc:	0800f6cd 	.word	0x0800f6cd
 800f5d0:	0800f6cd 	.word	0x0800f6cd
 800f5d4:	0800f695 	.word	0x0800f695
 800f5d8:	0800f6a3 	.word	0x0800f6a3
 800f5dc:	0800f6cd 	.word	0x0800f6cd
 800f5e0:	0800f6b1 	.word	0x0800f6b1
 800f5e4:	0800f6cd 	.word	0x0800f6cd
 800f5e8:	0800f6cd 	.word	0x0800f6cd
 800f5ec:	0800f6cd 	.word	0x0800f6cd
 800f5f0:	0800f6cd 	.word	0x0800f6cd
 800f5f4:	0800f6cd 	.word	0x0800f6cd
 800f5f8:	0800f6cd 	.word	0x0800f6cd
 800f5fc:	0800f6cd 	.word	0x0800f6cd
 800f600:	0800f6cd 	.word	0x0800f6cd
 800f604:	0800f6cd 	.word	0x0800f6cd
 800f608:	0800f6cd 	.word	0x0800f6cd
 800f60c:	0800f6cd 	.word	0x0800f6cd
 800f610:	0800f6cd 	.word	0x0800f6cd
 800f614:	0800f6cd 	.word	0x0800f6cd
 800f618:	0800f6cd 	.word	0x0800f6cd
 800f61c:	0800f6cd 	.word	0x0800f6cd
 800f620:	0800f6cd 	.word	0x0800f6cd
 800f624:	0800f6cd 	.word	0x0800f6cd
 800f628:	0800f6cd 	.word	0x0800f6cd
 800f62c:	0800f6cd 	.word	0x0800f6cd
 800f630:	0800f6cd 	.word	0x0800f6cd
 800f634:	0800f6cd 	.word	0x0800f6cd
 800f638:	0800f6cd 	.word	0x0800f6cd
 800f63c:	0800f6cd 	.word	0x0800f6cd
 800f640:	0800f6cd 	.word	0x0800f6cd
 800f644:	0800f6cd 	.word	0x0800f6cd
 800f648:	0800f6cd 	.word	0x0800f6cd
 800f64c:	0800f6cd 	.word	0x0800f6cd
 800f650:	0800f6cd 	.word	0x0800f6cd
 800f654:	0800f6cd 	.word	0x0800f6cd
 800f658:	0800f6cd 	.word	0x0800f6cd
 800f65c:	0800f6cd 	.word	0x0800f6cd
 800f660:	0800f6cd 	.word	0x0800f6cd
 800f664:	0800f6cd 	.word	0x0800f6cd
 800f668:	0800f6cd 	.word	0x0800f6cd
 800f66c:	0800f6cd 	.word	0x0800f6cd
 800f670:	0800f6cd 	.word	0x0800f6cd
 800f674:	0800f6cd 	.word	0x0800f6cd
 800f678:	0800f6bf 	.word	0x0800f6bf
 800f67c:	f64f 7201 	movw	r2, #65281	@ 0xff01
 800f680:	4293      	cmp	r3, r2
 800f682:	d025      	beq.n	800f6d0 <TLSX_FreeAll+0x150>
                WOLFSSL_MSG("CKS extension free");
                /* nothing to do */
                break;
#endif
            default:
                break;
 800f684:	e022      	b.n	800f6cc <TLSX_FreeAll+0x14c>
                SNI_FREE_ALL((SNI*)extension->data, heap);
 800f686:	68fb      	ldr	r3, [r7, #12]
 800f688:	685b      	ldr	r3, [r3, #4]
 800f68a:	6839      	ldr	r1, [r7, #0]
 800f68c:	4618      	mov	r0, r3
 800f68e:	f7ff febd 	bl	800f40c <TLSX_SNI_FreeAll>
                break;
 800f692:	e01e      	b.n	800f6d2 <TLSX_FreeAll+0x152>
                EC_FREE_ALL((SupportedCurve*)extension->data, heap);
 800f694:	68fb      	ldr	r3, [r7, #12]
 800f696:	685b      	ldr	r3, [r3, #4]
 800f698:	6839      	ldr	r1, [r7, #0]
 800f69a:	4618      	mov	r0, r3
 800f69c:	f7ff fecd 	bl	800f43a <TLSX_SupportedCurve_FreeAll>
                break;
 800f6a0:	e017      	b.n	800f6d2 <TLSX_FreeAll+0x152>
                PF_FREE_ALL((PointFormat*)extension->data, heap);
 800f6a2:	68fb      	ldr	r3, [r7, #12]
 800f6a4:	685b      	ldr	r3, [r3, #4]
 800f6a6:	6839      	ldr	r1, [r7, #0]
 800f6a8:	4618      	mov	r0, r3
 800f6aa:	f7ff fee1 	bl	800f470 <TLSX_PointFormat_FreeAll>
                break;
 800f6ae:	e010      	b.n	800f6d2 <TLSX_FreeAll+0x152>
                SA_FREE_ALL((SignatureAlgorithms*)extension->data, heap);
 800f6b0:	68fb      	ldr	r3, [r7, #12]
 800f6b2:	685b      	ldr	r3, [r3, #4]
 800f6b4:	6839      	ldr	r1, [r7, #0]
 800f6b6:	4618      	mov	r0, r3
 800f6b8:	f7ff fef5 	bl	800f4a6 <TLSX_SignatureAlgorithms_FreeAll>
                break;
 800f6bc:	e009      	b.n	800f6d2 <TLSX_FreeAll+0x152>
                KS_FREE_ALL((KeyShareEntry*)extension->data, heap);
 800f6be:	68fb      	ldr	r3, [r7, #12]
 800f6c0:	685b      	ldr	r3, [r3, #4]
 800f6c2:	6839      	ldr	r1, [r7, #0]
 800f6c4:	4618      	mov	r0, r3
 800f6c6:	f7ff feff 	bl	800f4c8 <TLSX_KeyShare_FreeAll>
                break;
 800f6ca:	e002      	b.n	800f6d2 <TLSX_FreeAll+0x152>
                break;
 800f6cc:	bf00      	nop
 800f6ce:	e000      	b.n	800f6d2 <TLSX_FreeAll+0x152>
                break;
 800f6d0:	bf00      	nop
        }

        XFREE(extension, heap, DYNAMIC_TYPE_TLSX);
 800f6d2:	68fb      	ldr	r3, [r7, #12]
 800f6d4:	60bb      	str	r3, [r7, #8]
 800f6d6:	68bb      	ldr	r3, [r7, #8]
 800f6d8:	2b00      	cmp	r3, #0
 800f6da:	d002      	beq.n	800f6e2 <TLSX_FreeAll+0x162>
 800f6dc:	68b8      	ldr	r0, [r7, #8]
 800f6de:	f00f fae9 	bl	801ecb4 <wolfSSL_Free>
    while ((extension = list)) {
 800f6e2:	687b      	ldr	r3, [r7, #4]
 800f6e4:	60fb      	str	r3, [r7, #12]
 800f6e6:	68fb      	ldr	r3, [r7, #12]
 800f6e8:	2b00      	cmp	r3, #0
 800f6ea:	f47f af4f 	bne.w	800f58c <TLSX_FreeAll+0xc>
    }

    (void)heap;
}
 800f6ee:	bf00      	nop
 800f6f0:	bf00      	nop
 800f6f2:	3710      	adds	r7, #16
 800f6f4:	46bd      	mov	sp, r7
 800f6f6:	bd80      	pop	{r7, pc}

0800f6f8 <wolfTLSv1_2_client_method>:
#endif /* !NO_OLD_TLS */

#ifndef WOLFSSL_NO_TLS12
    WOLFSSL_ABI
    WOLFSSL_METHOD* wolfTLSv1_2_client_method(void)
    {
 800f6f8:	b580      	push	{r7, lr}
 800f6fa:	af00      	add	r7, sp, #0
        return wolfTLSv1_2_client_method_ex(NULL);
 800f6fc:	2000      	movs	r0, #0
 800f6fe:	f000 f803 	bl	800f708 <wolfTLSv1_2_client_method_ex>
 800f702:	4603      	mov	r3, r0
    }
 800f704:	4618      	mov	r0, r3
 800f706:	bd80      	pop	{r7, pc}

0800f708 <wolfTLSv1_2_client_method_ex>:
    WOLFSSL_METHOD* wolfTLSv1_2_client_method_ex(void* heap)
    {
 800f708:	b580      	push	{r7, lr}
 800f70a:	b084      	sub	sp, #16
 800f70c:	af00      	add	r7, sp, #0
 800f70e:	6078      	str	r0, [r7, #4]
        WOLFSSL_METHOD* method =
                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
 800f710:	2004      	movs	r0, #4
 800f712:	f00f fab3 	bl	801ec7c <wolfSSL_Malloc>
 800f716:	60f8      	str	r0, [r7, #12]
                                                     heap, DYNAMIC_TYPE_METHOD);
        (void)heap;
        WOLFSSL_ENTER("TLSv1_2_client_method_ex");
        if (method)
 800f718:	68fb      	ldr	r3, [r7, #12]
 800f71a:	2b00      	cmp	r3, #0
 800f71c:	d007      	beq.n	800f72e <wolfTLSv1_2_client_method_ex+0x26>
            InitSSL_Method(method, MakeTLSv1_2());
 800f71e:	f7ff fe3d 	bl	800f39c <MakeTLSv1_2>
 800f722:	4603      	mov	r3, r0
 800f724:	813b      	strh	r3, [r7, #8]
 800f726:	68b9      	ldr	r1, [r7, #8]
 800f728:	68f8      	ldr	r0, [r7, #12]
 800f72a:	f7f9 f9bc 	bl	8008aa6 <InitSSL_Method>
        return method;
 800f72e:	68fb      	ldr	r3, [r7, #12]
    }
 800f730:	4618      	mov	r0, r3
 800f732:	3710      	adds	r7, #16
 800f734:	46bd      	mov	sp, r7
 800f736:	bd80      	pop	{r7, pc}

0800f738 <rotlFixed>:
    {
 800f738:	b480      	push	{r7}
 800f73a:	b083      	sub	sp, #12
 800f73c:	af00      	add	r7, sp, #0
 800f73e:	6078      	str	r0, [r7, #4]
 800f740:	6039      	str	r1, [r7, #0]
        return (x << y) | (x >> (sizeof(x) * 8 - y));
 800f742:	687a      	ldr	r2, [r7, #4]
 800f744:	683b      	ldr	r3, [r7, #0]
 800f746:	f1c3 0320 	rsb	r3, r3, #32
 800f74a:	fa62 f303 	ror.w	r3, r2, r3
    }
 800f74e:	4618      	mov	r0, r3
 800f750:	370c      	adds	r7, #12
 800f752:	46bd      	mov	sp, r7
 800f754:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f758:	4770      	bx	lr

0800f75a <ByteReverseWord32>:
{
 800f75a:	b580      	push	{r7, lr}
 800f75c:	b082      	sub	sp, #8
 800f75e:	af00      	add	r7, sp, #0
 800f760:	6078      	str	r0, [r7, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 800f762:	687b      	ldr	r3, [r7, #4]
 800f764:	0a1b      	lsrs	r3, r3, #8
 800f766:	f003 12ff 	and.w	r2, r3, #16711935	@ 0xff00ff
 800f76a:	687b      	ldr	r3, [r7, #4]
 800f76c:	021b      	lsls	r3, r3, #8
 800f76e:	f003 23ff 	and.w	r3, r3, #4278255360	@ 0xff00ff00
 800f772:	4313      	orrs	r3, r2
 800f774:	607b      	str	r3, [r7, #4]
    return rotlFixed(value, 16U);
 800f776:	2110      	movs	r1, #16
 800f778:	6878      	ldr	r0, [r7, #4]
 800f77a:	f7ff ffdd 	bl	800f738 <rotlFixed>
 800f77e:	4603      	mov	r3, r0
}
 800f780:	4618      	mov	r0, r3
 800f782:	3708      	adds	r7, #8
 800f784:	46bd      	mov	sp, r7
 800f786:	bd80      	pop	{r7, pc}

0800f788 <ByteReverseWords>:
{
 800f788:	b590      	push	{r4, r7, lr}
 800f78a:	b087      	sub	sp, #28
 800f78c:	af00      	add	r7, sp, #0
 800f78e:	60f8      	str	r0, [r7, #12]
 800f790:	60b9      	str	r1, [r7, #8]
 800f792:	607a      	str	r2, [r7, #4]
        word32 count = byteCount/(word32)sizeof(word32);
 800f794:	687b      	ldr	r3, [r7, #4]
 800f796:	089b      	lsrs	r3, r3, #2
 800f798:	613b      	str	r3, [r7, #16]
        for (i = 0; i < count; i++)
 800f79a:	2300      	movs	r3, #0
 800f79c:	617b      	str	r3, [r7, #20]
 800f79e:	e010      	b.n	800f7c2 <ByteReverseWords+0x3a>
            out[i] = ByteReverseWord32(in[i]);
 800f7a0:	697b      	ldr	r3, [r7, #20]
 800f7a2:	009b      	lsls	r3, r3, #2
 800f7a4:	68ba      	ldr	r2, [r7, #8]
 800f7a6:	4413      	add	r3, r2
 800f7a8:	6819      	ldr	r1, [r3, #0]
 800f7aa:	697b      	ldr	r3, [r7, #20]
 800f7ac:	009b      	lsls	r3, r3, #2
 800f7ae:	68fa      	ldr	r2, [r7, #12]
 800f7b0:	18d4      	adds	r4, r2, r3
 800f7b2:	4608      	mov	r0, r1
 800f7b4:	f7ff ffd1 	bl	800f75a <ByteReverseWord32>
 800f7b8:	4603      	mov	r3, r0
 800f7ba:	6023      	str	r3, [r4, #0]
        for (i = 0; i < count; i++)
 800f7bc:	697b      	ldr	r3, [r7, #20]
 800f7be:	3301      	adds	r3, #1
 800f7c0:	617b      	str	r3, [r7, #20]
 800f7c2:	697a      	ldr	r2, [r7, #20]
 800f7c4:	693b      	ldr	r3, [r7, #16]
 800f7c6:	429a      	cmp	r2, r3
 800f7c8:	d3ea      	bcc.n	800f7a0 <ByteReverseWords+0x18>
}
 800f7ca:	bf00      	nop
 800f7cc:	bf00      	nop
 800f7ce:	371c      	adds	r7, #28
 800f7d0:	46bd      	mov	sp, r7
 800f7d2:	bd90      	pop	{r4, r7, pc}

0800f7d4 <XorWords>:
{
 800f7d4:	b480      	push	{r7}
 800f7d6:	b087      	sub	sp, #28
 800f7d8:	af00      	add	r7, sp, #0
 800f7da:	60f8      	str	r0, [r7, #12]
 800f7dc:	60b9      	str	r1, [r7, #8]
 800f7de:	607a      	str	r2, [r7, #4]
    for (i = 0; i < n; i++)
 800f7e0:	2300      	movs	r3, #0
 800f7e2:	617b      	str	r3, [r7, #20]
 800f7e4:	e010      	b.n	800f808 <XorWords+0x34>
        *((*r)++) ^= *((*a)++);
 800f7e6:	68bb      	ldr	r3, [r7, #8]
 800f7e8:	681b      	ldr	r3, [r3, #0]
 800f7ea:	1d19      	adds	r1, r3, #4
 800f7ec:	68ba      	ldr	r2, [r7, #8]
 800f7ee:	6011      	str	r1, [r2, #0]
 800f7f0:	6819      	ldr	r1, [r3, #0]
 800f7f2:	68fb      	ldr	r3, [r7, #12]
 800f7f4:	681b      	ldr	r3, [r3, #0]
 800f7f6:	1d18      	adds	r0, r3, #4
 800f7f8:	68fa      	ldr	r2, [r7, #12]
 800f7fa:	6010      	str	r0, [r2, #0]
 800f7fc:	681a      	ldr	r2, [r3, #0]
 800f7fe:	404a      	eors	r2, r1
 800f800:	601a      	str	r2, [r3, #0]
    for (i = 0; i < n; i++)
 800f802:	697b      	ldr	r3, [r7, #20]
 800f804:	3301      	adds	r3, #1
 800f806:	617b      	str	r3, [r7, #20]
 800f808:	697a      	ldr	r2, [r7, #20]
 800f80a:	687b      	ldr	r3, [r7, #4]
 800f80c:	429a      	cmp	r2, r3
 800f80e:	d3ea      	bcc.n	800f7e6 <XorWords+0x12>
}
 800f810:	bf00      	nop
 800f812:	bf00      	nop
 800f814:	371c      	adds	r7, #28
 800f816:	46bd      	mov	sp, r7
 800f818:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f81c:	4770      	bx	lr

0800f81e <xorbuf>:
{
 800f81e:	b580      	push	{r7, lr}
 800f820:	b08a      	sub	sp, #40	@ 0x28
 800f822:	af00      	add	r7, sp, #0
 800f824:	60f8      	str	r0, [r7, #12]
 800f826:	60b9      	str	r1, [r7, #8]
 800f828:	607a      	str	r2, [r7, #4]
    b = (byte*)buf;
 800f82a:	68fb      	ldr	r3, [r7, #12]
 800f82c:	623b      	str	r3, [r7, #32]
    m = (const byte*)mask;
 800f82e:	68bb      	ldr	r3, [r7, #8]
 800f830:	61fb      	str	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 800f832:	6a3a      	ldr	r2, [r7, #32]
            ((wc_ptr_t)m) % WOLFSSL_WORD_SIZE) {
 800f834:	69fb      	ldr	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 800f836:	4053      	eors	r3, r2
 800f838:	f003 0303 	and.w	r3, r3, #3
 800f83c:	2b00      	cmp	r3, #0
 800f83e:	d12b      	bne.n	800f898 <xorbuf+0x7a>
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 800f840:	e00d      	b.n	800f85e <xorbuf+0x40>
            *(b++) ^= *(m++);
 800f842:	69fb      	ldr	r3, [r7, #28]
 800f844:	1c5a      	adds	r2, r3, #1
 800f846:	61fa      	str	r2, [r7, #28]
 800f848:	7819      	ldrb	r1, [r3, #0]
 800f84a:	6a3b      	ldr	r3, [r7, #32]
 800f84c:	1c5a      	adds	r2, r3, #1
 800f84e:	623a      	str	r2, [r7, #32]
 800f850:	781a      	ldrb	r2, [r3, #0]
 800f852:	404a      	eors	r2, r1
 800f854:	b2d2      	uxtb	r2, r2
 800f856:	701a      	strb	r2, [r3, #0]
            count--;
 800f858:	687b      	ldr	r3, [r7, #4]
 800f85a:	3b01      	subs	r3, #1
 800f85c:	607b      	str	r3, [r7, #4]
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 800f85e:	68fb      	ldr	r3, [r7, #12]
 800f860:	f003 0303 	and.w	r3, r3, #3
 800f864:	2b00      	cmp	r3, #0
 800f866:	d002      	beq.n	800f86e <xorbuf+0x50>
 800f868:	687b      	ldr	r3, [r7, #4]
 800f86a:	2b00      	cmp	r3, #0
 800f86c:	d1e9      	bne.n	800f842 <xorbuf+0x24>
        tpb.bp = b;
 800f86e:	6a3b      	ldr	r3, [r7, #32]
 800f870:	61bb      	str	r3, [r7, #24]
        tpm.bp = m;
 800f872:	69fb      	ldr	r3, [r7, #28]
 800f874:	617b      	str	r3, [r7, #20]
        XorWords( &tpb.wp, &tpm.wp, count / WOLFSSL_WORD_SIZE);
 800f876:	687b      	ldr	r3, [r7, #4]
 800f878:	089a      	lsrs	r2, r3, #2
 800f87a:	f107 0114 	add.w	r1, r7, #20
 800f87e:	f107 0318 	add.w	r3, r7, #24
 800f882:	4618      	mov	r0, r3
 800f884:	f7ff ffa6 	bl	800f7d4 <XorWords>
        b = tpb.bp;
 800f888:	69bb      	ldr	r3, [r7, #24]
 800f88a:	623b      	str	r3, [r7, #32]
        m = tpm.bp;
 800f88c:	697b      	ldr	r3, [r7, #20]
 800f88e:	61fb      	str	r3, [r7, #28]
        count %= WOLFSSL_WORD_SIZE;
 800f890:	687b      	ldr	r3, [r7, #4]
 800f892:	f003 0303 	and.w	r3, r3, #3
 800f896:	607b      	str	r3, [r7, #4]
    for (i = 0; i < count; i++)
 800f898:	2300      	movs	r3, #0
 800f89a:	627b      	str	r3, [r7, #36]	@ 0x24
 800f89c:	e010      	b.n	800f8c0 <xorbuf+0xa2>
        b[i] ^= m[i];
 800f89e:	6a3a      	ldr	r2, [r7, #32]
 800f8a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f8a2:	4413      	add	r3, r2
 800f8a4:	7819      	ldrb	r1, [r3, #0]
 800f8a6:	69fa      	ldr	r2, [r7, #28]
 800f8a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f8aa:	4413      	add	r3, r2
 800f8ac:	781a      	ldrb	r2, [r3, #0]
 800f8ae:	6a38      	ldr	r0, [r7, #32]
 800f8b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f8b2:	4403      	add	r3, r0
 800f8b4:	404a      	eors	r2, r1
 800f8b6:	b2d2      	uxtb	r2, r2
 800f8b8:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < count; i++)
 800f8ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f8bc:	3301      	adds	r3, #1
 800f8be:	627b      	str	r3, [r7, #36]	@ 0x24
 800f8c0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800f8c2:	687b      	ldr	r3, [r7, #4]
 800f8c4:	429a      	cmp	r2, r3
 800f8c6:	d3ea      	bcc.n	800f89e <xorbuf+0x80>
}
 800f8c8:	bf00      	nop
 800f8ca:	bf00      	nop
 800f8cc:	3728      	adds	r7, #40	@ 0x28
 800f8ce:	46bd      	mov	sp, r7
 800f8d0:	bd80      	pop	{r7, pc}

0800f8d2 <ForceZero>:
{
 800f8d2:	b480      	push	{r7}
 800f8d4:	b085      	sub	sp, #20
 800f8d6:	af00      	add	r7, sp, #0
 800f8d8:	6078      	str	r0, [r7, #4]
 800f8da:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 800f8dc:	687b      	ldr	r3, [r7, #4]
 800f8de:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 800f8e0:	e004      	b.n	800f8ec <ForceZero+0x1a>
 800f8e2:	68fb      	ldr	r3, [r7, #12]
 800f8e4:	1c5a      	adds	r2, r3, #1
 800f8e6:	60fa      	str	r2, [r7, #12]
 800f8e8:	2200      	movs	r2, #0
 800f8ea:	701a      	strb	r2, [r3, #0]
 800f8ec:	683b      	ldr	r3, [r7, #0]
 800f8ee:	1e5a      	subs	r2, r3, #1
 800f8f0:	603a      	str	r2, [r7, #0]
 800f8f2:	2b00      	cmp	r3, #0
 800f8f4:	d1f5      	bne.n	800f8e2 <ForceZero+0x10>
}
 800f8f6:	bf00      	nop
 800f8f8:	bf00      	nop
 800f8fa:	3714      	adds	r7, #20
 800f8fc:	46bd      	mov	sp, r7
 800f8fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f902:	4770      	bx	lr

0800f904 <PreFetchTe>:
#endif

#ifndef WOLFSSL_AES_SMALL_TABLES
/* load 4 Te Tables into cache by cache line stride */
static WARN_UNUSED_RESULT WC_INLINE word32 PreFetchTe(void)
{
 800f904:	b480      	push	{r7}
 800f906:	b085      	sub	sp, #20
 800f908:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_AES_TOUCH_LINES
    word32 x = 0;
 800f90a:	2300      	movs	r3, #0
 800f90c:	60fb      	str	r3, [r7, #12]
    int i,j;

    for (i = 0; i < 4; i++) {
 800f90e:	2300      	movs	r3, #0
 800f910:	60bb      	str	r3, [r7, #8]
 800f912:	e015      	b.n	800f940 <PreFetchTe+0x3c>
        /* 256 elements, each one is 4 bytes */
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 800f914:	2300      	movs	r3, #0
 800f916:	607b      	str	r3, [r7, #4]
 800f918:	e00c      	b.n	800f934 <PreFetchTe+0x30>
            x &= Te[i][j];
 800f91a:	490e      	ldr	r1, [pc, #56]	@ (800f954 <PreFetchTe+0x50>)
 800f91c:	68bb      	ldr	r3, [r7, #8]
 800f91e:	021a      	lsls	r2, r3, #8
 800f920:	687b      	ldr	r3, [r7, #4]
 800f922:	4413      	add	r3, r2
 800f924:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f928:	68fa      	ldr	r2, [r7, #12]
 800f92a:	4013      	ands	r3, r2
 800f92c:	60fb      	str	r3, [r7, #12]
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 800f92e:	687b      	ldr	r3, [r7, #4]
 800f930:	3308      	adds	r3, #8
 800f932:	607b      	str	r3, [r7, #4]
 800f934:	687b      	ldr	r3, [r7, #4]
 800f936:	2bff      	cmp	r3, #255	@ 0xff
 800f938:	ddef      	ble.n	800f91a <PreFetchTe+0x16>
    for (i = 0; i < 4; i++) {
 800f93a:	68bb      	ldr	r3, [r7, #8]
 800f93c:	3301      	adds	r3, #1
 800f93e:	60bb      	str	r3, [r7, #8]
 800f940:	68bb      	ldr	r3, [r7, #8]
 800f942:	2b03      	cmp	r3, #3
 800f944:	dde6      	ble.n	800f914 <PreFetchTe+0x10>
        }
    }
    return x;
 800f946:	68fb      	ldr	r3, [r7, #12]
#else
    return 0;
#endif
}
 800f948:	4618      	mov	r0, r3
 800f94a:	3714      	adds	r7, #20
 800f94c:	46bd      	mov	sp, r7
 800f94e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f952:	4770      	bx	lr
 800f954:	08032284 	.word	0x08032284

0800f958 <AesEncrypt_C>:
 * @param [out] outBlock  Encrypted block.
 * @param [in]  r         Rounds divided by 2.
 */
static void AesEncrypt_C(Aes* aes, const byte* inBlock, byte* outBlock,
        word32 r)
{
 800f958:	b580      	push	{r7, lr}
 800f95a:	b08e      	sub	sp, #56	@ 0x38
 800f95c:	af00      	add	r7, sp, #0
 800f95e:	60f8      	str	r0, [r7, #12]
 800f960:	60b9      	str	r1, [r7, #8]
 800f962:	607a      	str	r2, [r7, #4]
 800f964:	603b      	str	r3, [r7, #0]
    const word32* rk;

#ifdef WC_C_DYNAMIC_FALLBACK
    rk = aes->key_C_fallback;
#else
    rk = aes->key;
 800f966:	68fb      	ldr	r3, [r7, #12]
 800f968:	627b      	str	r3, [r7, #36]	@ 0x24

    /*
     * map byte array block to cipher state
     * and add initial round key:
     */
    XMEMCPY(&s0, inBlock,                  sizeof(s0));
 800f96a:	68bb      	ldr	r3, [r7, #8]
 800f96c:	681b      	ldr	r3, [r3, #0]
 800f96e:	623b      	str	r3, [r7, #32]
    XMEMCPY(&s1, inBlock +     sizeof(s0), sizeof(s1));
 800f970:	68bb      	ldr	r3, [r7, #8]
 800f972:	3304      	adds	r3, #4
 800f974:	681b      	ldr	r3, [r3, #0]
 800f976:	61fb      	str	r3, [r7, #28]
    XMEMCPY(&s2, inBlock + 2 * sizeof(s0), sizeof(s2));
 800f978:	68bb      	ldr	r3, [r7, #8]
 800f97a:	3308      	adds	r3, #8
 800f97c:	681b      	ldr	r3, [r3, #0]
 800f97e:	61bb      	str	r3, [r7, #24]
    XMEMCPY(&s3, inBlock + 3 * sizeof(s0), sizeof(s3));
 800f980:	68bb      	ldr	r3, [r7, #8]
 800f982:	330c      	adds	r3, #12
 800f984:	681b      	ldr	r3, [r3, #0]
 800f986:	617b      	str	r3, [r7, #20]

#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 800f988:	6a3b      	ldr	r3, [r7, #32]
 800f98a:	4618      	mov	r0, r3
 800f98c:	f7ff fee5 	bl	800f75a <ByteReverseWord32>
 800f990:	4603      	mov	r3, r0
 800f992:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 800f994:	69fb      	ldr	r3, [r7, #28]
 800f996:	4618      	mov	r0, r3
 800f998:	f7ff fedf 	bl	800f75a <ByteReverseWord32>
 800f99c:	4603      	mov	r3, r0
 800f99e:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 800f9a0:	69bb      	ldr	r3, [r7, #24]
 800f9a2:	4618      	mov	r0, r3
 800f9a4:	f7ff fed9 	bl	800f75a <ByteReverseWord32>
 800f9a8:	4603      	mov	r3, r0
 800f9aa:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 800f9ac:	697b      	ldr	r3, [r7, #20]
 800f9ae:	4618      	mov	r0, r3
 800f9b0:	f7ff fed3 	bl	800f75a <ByteReverseWord32>
 800f9b4:	4603      	mov	r3, r0
 800f9b6:	617b      	str	r3, [r7, #20]
#endif

    /* AddRoundKey */
    s0 ^= rk[0];
 800f9b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f9ba:	681a      	ldr	r2, [r3, #0]
 800f9bc:	6a3b      	ldr	r3, [r7, #32]
 800f9be:	4053      	eors	r3, r2
 800f9c0:	623b      	str	r3, [r7, #32]
    s1 ^= rk[1];
 800f9c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f9c4:	3304      	adds	r3, #4
 800f9c6:	681a      	ldr	r2, [r3, #0]
 800f9c8:	69fb      	ldr	r3, [r7, #28]
 800f9ca:	4053      	eors	r3, r2
 800f9cc:	61fb      	str	r3, [r7, #28]
    s2 ^= rk[2];
 800f9ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f9d0:	3308      	adds	r3, #8
 800f9d2:	681a      	ldr	r2, [r3, #0]
 800f9d4:	69bb      	ldr	r3, [r7, #24]
 800f9d6:	4053      	eors	r3, r2
 800f9d8:	61bb      	str	r3, [r7, #24]
    s3 ^= rk[3];
 800f9da:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f9dc:	330c      	adds	r3, #12
 800f9de:	681a      	ldr	r2, [r3, #0]
 800f9e0:	697b      	ldr	r3, [r7, #20]
 800f9e2:	4053      	eors	r3, r2
 800f9e4:	617b      	str	r3, [r7, #20]

#ifndef WOLFSSL_AES_SMALL_TABLES
#ifndef WC_NO_CACHE_RESISTANT
    s0 |= PreFetchTe();
 800f9e6:	f7ff ff8d 	bl	800f904 <PreFetchTe>
 800f9ea:	4602      	mov	r2, r0
 800f9ec:	6a3b      	ldr	r3, [r7, #32]
 800f9ee:	4313      	orrs	r3, r2
 800f9f0:	623b      	str	r3, [r7, #32]
    s0 ^= rk[(o)+0]; s1 ^= rk[(o)+1]; s2 ^= rk[(o)+2]; s3 ^= rk[(o)+3];
#endif

#ifndef WOLFSSL_AES_NO_UNROLL
/* Unroll the loop. */
                       ENC_ROUND_T_S( 0);
 800f9f2:	6a3b      	ldr	r3, [r7, #32]
 800f9f4:	0e1b      	lsrs	r3, r3, #24
 800f9f6:	b2db      	uxtb	r3, r3
 800f9f8:	461a      	mov	r2, r3
 800f9fa:	4bb6      	ldr	r3, [pc, #728]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800f9fc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fa00:	69fb      	ldr	r3, [r7, #28]
 800fa02:	0c1b      	lsrs	r3, r3, #16
 800fa04:	b2db      	uxtb	r3, r3
 800fa06:	49b3      	ldr	r1, [pc, #716]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fa08:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fa0c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa10:	405a      	eors	r2, r3
 800fa12:	69bb      	ldr	r3, [r7, #24]
 800fa14:	0a1b      	lsrs	r3, r3, #8
 800fa16:	b2db      	uxtb	r3, r3
 800fa18:	49ae      	ldr	r1, [pc, #696]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fa1a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fa1e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa22:	405a      	eors	r2, r3
 800fa24:	697b      	ldr	r3, [r7, #20]
 800fa26:	b2db      	uxtb	r3, r3
 800fa28:	49aa      	ldr	r1, [pc, #680]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fa2a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fa2e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa32:	405a      	eors	r2, r3
 800fa34:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fa36:	3310      	adds	r3, #16
 800fa38:	681b      	ldr	r3, [r3, #0]
 800fa3a:	4053      	eors	r3, r2
 800fa3c:	637b      	str	r3, [r7, #52]	@ 0x34
 800fa3e:	69fb      	ldr	r3, [r7, #28]
 800fa40:	0e1b      	lsrs	r3, r3, #24
 800fa42:	b2db      	uxtb	r3, r3
 800fa44:	461a      	mov	r2, r3
 800fa46:	4ba3      	ldr	r3, [pc, #652]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fa48:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fa4c:	69bb      	ldr	r3, [r7, #24]
 800fa4e:	0c1b      	lsrs	r3, r3, #16
 800fa50:	b2db      	uxtb	r3, r3
 800fa52:	49a0      	ldr	r1, [pc, #640]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fa54:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fa58:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa5c:	405a      	eors	r2, r3
 800fa5e:	697b      	ldr	r3, [r7, #20]
 800fa60:	0a1b      	lsrs	r3, r3, #8
 800fa62:	b2db      	uxtb	r3, r3
 800fa64:	499b      	ldr	r1, [pc, #620]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fa66:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fa6a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa6e:	405a      	eors	r2, r3
 800fa70:	6a3b      	ldr	r3, [r7, #32]
 800fa72:	b2db      	uxtb	r3, r3
 800fa74:	4997      	ldr	r1, [pc, #604]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fa76:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fa7a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa7e:	405a      	eors	r2, r3
 800fa80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fa82:	3314      	adds	r3, #20
 800fa84:	681b      	ldr	r3, [r3, #0]
 800fa86:	4053      	eors	r3, r2
 800fa88:	633b      	str	r3, [r7, #48]	@ 0x30
 800fa8a:	69bb      	ldr	r3, [r7, #24]
 800fa8c:	0e1b      	lsrs	r3, r3, #24
 800fa8e:	b2db      	uxtb	r3, r3
 800fa90:	461a      	mov	r2, r3
 800fa92:	4b90      	ldr	r3, [pc, #576]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fa94:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fa98:	697b      	ldr	r3, [r7, #20]
 800fa9a:	0c1b      	lsrs	r3, r3, #16
 800fa9c:	b2db      	uxtb	r3, r3
 800fa9e:	498d      	ldr	r1, [pc, #564]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800faa0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800faa4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800faa8:	405a      	eors	r2, r3
 800faaa:	6a3b      	ldr	r3, [r7, #32]
 800faac:	0a1b      	lsrs	r3, r3, #8
 800faae:	b2db      	uxtb	r3, r3
 800fab0:	4988      	ldr	r1, [pc, #544]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fab2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fab6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800faba:	405a      	eors	r2, r3
 800fabc:	69fb      	ldr	r3, [r7, #28]
 800fabe:	b2db      	uxtb	r3, r3
 800fac0:	4984      	ldr	r1, [pc, #528]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fac2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fac6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800faca:	405a      	eors	r2, r3
 800facc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800face:	3318      	adds	r3, #24
 800fad0:	681b      	ldr	r3, [r3, #0]
 800fad2:	4053      	eors	r3, r2
 800fad4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800fad6:	697b      	ldr	r3, [r7, #20]
 800fad8:	0e1b      	lsrs	r3, r3, #24
 800fada:	b2db      	uxtb	r3, r3
 800fadc:	461a      	mov	r2, r3
 800fade:	4b7d      	ldr	r3, [pc, #500]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fae0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fae4:	6a3b      	ldr	r3, [r7, #32]
 800fae6:	0c1b      	lsrs	r3, r3, #16
 800fae8:	b2db      	uxtb	r3, r3
 800faea:	497a      	ldr	r1, [pc, #488]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800faec:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800faf0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800faf4:	405a      	eors	r2, r3
 800faf6:	69fb      	ldr	r3, [r7, #28]
 800faf8:	0a1b      	lsrs	r3, r3, #8
 800fafa:	b2db      	uxtb	r3, r3
 800fafc:	4975      	ldr	r1, [pc, #468]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fafe:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fb02:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb06:	405a      	eors	r2, r3
 800fb08:	69bb      	ldr	r3, [r7, #24]
 800fb0a:	b2db      	uxtb	r3, r3
 800fb0c:	4971      	ldr	r1, [pc, #452]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fb0e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fb12:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb16:	405a      	eors	r2, r3
 800fb18:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fb1a:	331c      	adds	r3, #28
 800fb1c:	681b      	ldr	r3, [r3, #0]
 800fb1e:	4053      	eors	r3, r2
 800fb20:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T( 8); ENC_ROUND_T_S( 8);
 800fb22:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb24:	0e1b      	lsrs	r3, r3, #24
 800fb26:	b2db      	uxtb	r3, r3
 800fb28:	461a      	mov	r2, r3
 800fb2a:	4b6a      	ldr	r3, [pc, #424]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fb2c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fb30:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fb32:	0c1b      	lsrs	r3, r3, #16
 800fb34:	b2db      	uxtb	r3, r3
 800fb36:	4967      	ldr	r1, [pc, #412]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fb38:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fb3c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb40:	405a      	eors	r2, r3
 800fb42:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fb44:	0a1b      	lsrs	r3, r3, #8
 800fb46:	b2db      	uxtb	r3, r3
 800fb48:	4962      	ldr	r1, [pc, #392]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fb4a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fb4e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb52:	405a      	eors	r2, r3
 800fb54:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fb56:	b2db      	uxtb	r3, r3
 800fb58:	495e      	ldr	r1, [pc, #376]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fb5a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fb5e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb62:	405a      	eors	r2, r3
 800fb64:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fb66:	3320      	adds	r3, #32
 800fb68:	681b      	ldr	r3, [r3, #0]
 800fb6a:	4053      	eors	r3, r2
 800fb6c:	623b      	str	r3, [r7, #32]
 800fb6e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fb70:	0e1b      	lsrs	r3, r3, #24
 800fb72:	b2db      	uxtb	r3, r3
 800fb74:	461a      	mov	r2, r3
 800fb76:	4b57      	ldr	r3, [pc, #348]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fb78:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fb7c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fb7e:	0c1b      	lsrs	r3, r3, #16
 800fb80:	b2db      	uxtb	r3, r3
 800fb82:	4954      	ldr	r1, [pc, #336]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fb84:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fb88:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb8c:	405a      	eors	r2, r3
 800fb8e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fb90:	0a1b      	lsrs	r3, r3, #8
 800fb92:	b2db      	uxtb	r3, r3
 800fb94:	494f      	ldr	r1, [pc, #316]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fb96:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fb9a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb9e:	405a      	eors	r2, r3
 800fba0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fba2:	b2db      	uxtb	r3, r3
 800fba4:	494b      	ldr	r1, [pc, #300]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fba6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fbaa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbae:	405a      	eors	r2, r3
 800fbb0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fbb2:	3324      	adds	r3, #36	@ 0x24
 800fbb4:	681b      	ldr	r3, [r3, #0]
 800fbb6:	4053      	eors	r3, r2
 800fbb8:	61fb      	str	r3, [r7, #28]
 800fbba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fbbc:	0e1b      	lsrs	r3, r3, #24
 800fbbe:	b2db      	uxtb	r3, r3
 800fbc0:	461a      	mov	r2, r3
 800fbc2:	4b44      	ldr	r3, [pc, #272]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fbc4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fbc8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fbca:	0c1b      	lsrs	r3, r3, #16
 800fbcc:	b2db      	uxtb	r3, r3
 800fbce:	4941      	ldr	r1, [pc, #260]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fbd0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fbd4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbd8:	405a      	eors	r2, r3
 800fbda:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fbdc:	0a1b      	lsrs	r3, r3, #8
 800fbde:	b2db      	uxtb	r3, r3
 800fbe0:	493c      	ldr	r1, [pc, #240]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fbe2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fbe6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbea:	405a      	eors	r2, r3
 800fbec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fbee:	b2db      	uxtb	r3, r3
 800fbf0:	4938      	ldr	r1, [pc, #224]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fbf2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fbf6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbfa:	405a      	eors	r2, r3
 800fbfc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fbfe:	3328      	adds	r3, #40	@ 0x28
 800fc00:	681b      	ldr	r3, [r3, #0]
 800fc02:	4053      	eors	r3, r2
 800fc04:	61bb      	str	r3, [r7, #24]
 800fc06:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fc08:	0e1b      	lsrs	r3, r3, #24
 800fc0a:	b2db      	uxtb	r3, r3
 800fc0c:	461a      	mov	r2, r3
 800fc0e:	4b31      	ldr	r3, [pc, #196]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fc10:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fc14:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc16:	0c1b      	lsrs	r3, r3, #16
 800fc18:	b2db      	uxtb	r3, r3
 800fc1a:	492e      	ldr	r1, [pc, #184]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fc1c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fc20:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc24:	405a      	eors	r2, r3
 800fc26:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fc28:	0a1b      	lsrs	r3, r3, #8
 800fc2a:	b2db      	uxtb	r3, r3
 800fc2c:	4929      	ldr	r1, [pc, #164]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fc2e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fc32:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc36:	405a      	eors	r2, r3
 800fc38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fc3a:	b2db      	uxtb	r3, r3
 800fc3c:	4925      	ldr	r1, [pc, #148]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fc3e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fc42:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc46:	405a      	eors	r2, r3
 800fc48:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fc4a:	332c      	adds	r3, #44	@ 0x2c
 800fc4c:	681b      	ldr	r3, [r3, #0]
 800fc4e:	4053      	eors	r3, r2
 800fc50:	617b      	str	r3, [r7, #20]
 800fc52:	6a3b      	ldr	r3, [r7, #32]
 800fc54:	0e1b      	lsrs	r3, r3, #24
 800fc56:	b2db      	uxtb	r3, r3
 800fc58:	461a      	mov	r2, r3
 800fc5a:	4b1e      	ldr	r3, [pc, #120]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fc5c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fc60:	69fb      	ldr	r3, [r7, #28]
 800fc62:	0c1b      	lsrs	r3, r3, #16
 800fc64:	b2db      	uxtb	r3, r3
 800fc66:	491b      	ldr	r1, [pc, #108]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fc68:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fc6c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc70:	405a      	eors	r2, r3
 800fc72:	69bb      	ldr	r3, [r7, #24]
 800fc74:	0a1b      	lsrs	r3, r3, #8
 800fc76:	b2db      	uxtb	r3, r3
 800fc78:	4916      	ldr	r1, [pc, #88]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fc7a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fc7e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc82:	405a      	eors	r2, r3
 800fc84:	697b      	ldr	r3, [r7, #20]
 800fc86:	b2db      	uxtb	r3, r3
 800fc88:	4912      	ldr	r1, [pc, #72]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fc8a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fc8e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc92:	405a      	eors	r2, r3
 800fc94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fc96:	3330      	adds	r3, #48	@ 0x30
 800fc98:	681b      	ldr	r3, [r3, #0]
 800fc9a:	4053      	eors	r3, r2
 800fc9c:	637b      	str	r3, [r7, #52]	@ 0x34
 800fc9e:	69fb      	ldr	r3, [r7, #28]
 800fca0:	0e1b      	lsrs	r3, r3, #24
 800fca2:	b2db      	uxtb	r3, r3
 800fca4:	461a      	mov	r2, r3
 800fca6:	4b0b      	ldr	r3, [pc, #44]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fca8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fcac:	69bb      	ldr	r3, [r7, #24]
 800fcae:	0c1b      	lsrs	r3, r3, #16
 800fcb0:	b2db      	uxtb	r3, r3
 800fcb2:	4908      	ldr	r1, [pc, #32]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fcb4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fcb8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fcbc:	405a      	eors	r2, r3
 800fcbe:	697b      	ldr	r3, [r7, #20]
 800fcc0:	0a1b      	lsrs	r3, r3, #8
 800fcc2:	b2db      	uxtb	r3, r3
 800fcc4:	4903      	ldr	r1, [pc, #12]	@ (800fcd4 <AesEncrypt_C+0x37c>)
 800fcc6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fcca:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fcce:	405a      	eors	r2, r3
 800fcd0:	6a3b      	ldr	r3, [r7, #32]
 800fcd2:	e001      	b.n	800fcd8 <AesEncrypt_C+0x380>
 800fcd4:	08032284 	.word	0x08032284
 800fcd8:	b2db      	uxtb	r3, r3
 800fcda:	49b6      	ldr	r1, [pc, #728]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fcdc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fce0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fce4:	405a      	eors	r2, r3
 800fce6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fce8:	3334      	adds	r3, #52	@ 0x34
 800fcea:	681b      	ldr	r3, [r3, #0]
 800fcec:	4053      	eors	r3, r2
 800fcee:	633b      	str	r3, [r7, #48]	@ 0x30
 800fcf0:	69bb      	ldr	r3, [r7, #24]
 800fcf2:	0e1b      	lsrs	r3, r3, #24
 800fcf4:	b2db      	uxtb	r3, r3
 800fcf6:	461a      	mov	r2, r3
 800fcf8:	4bae      	ldr	r3, [pc, #696]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fcfa:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fcfe:	697b      	ldr	r3, [r7, #20]
 800fd00:	0c1b      	lsrs	r3, r3, #16
 800fd02:	b2db      	uxtb	r3, r3
 800fd04:	49ab      	ldr	r1, [pc, #684]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fd06:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fd0a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd0e:	405a      	eors	r2, r3
 800fd10:	6a3b      	ldr	r3, [r7, #32]
 800fd12:	0a1b      	lsrs	r3, r3, #8
 800fd14:	b2db      	uxtb	r3, r3
 800fd16:	49a7      	ldr	r1, [pc, #668]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fd18:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fd1c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd20:	405a      	eors	r2, r3
 800fd22:	69fb      	ldr	r3, [r7, #28]
 800fd24:	b2db      	uxtb	r3, r3
 800fd26:	49a3      	ldr	r1, [pc, #652]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fd28:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fd2c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd30:	405a      	eors	r2, r3
 800fd32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fd34:	3338      	adds	r3, #56	@ 0x38
 800fd36:	681b      	ldr	r3, [r3, #0]
 800fd38:	4053      	eors	r3, r2
 800fd3a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800fd3c:	697b      	ldr	r3, [r7, #20]
 800fd3e:	0e1b      	lsrs	r3, r3, #24
 800fd40:	b2db      	uxtb	r3, r3
 800fd42:	461a      	mov	r2, r3
 800fd44:	4b9b      	ldr	r3, [pc, #620]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fd46:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fd4a:	6a3b      	ldr	r3, [r7, #32]
 800fd4c:	0c1b      	lsrs	r3, r3, #16
 800fd4e:	b2db      	uxtb	r3, r3
 800fd50:	4998      	ldr	r1, [pc, #608]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fd52:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fd56:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd5a:	405a      	eors	r2, r3
 800fd5c:	69fb      	ldr	r3, [r7, #28]
 800fd5e:	0a1b      	lsrs	r3, r3, #8
 800fd60:	b2db      	uxtb	r3, r3
 800fd62:	4994      	ldr	r1, [pc, #592]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fd64:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fd68:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd6c:	405a      	eors	r2, r3
 800fd6e:	69bb      	ldr	r3, [r7, #24]
 800fd70:	b2db      	uxtb	r3, r3
 800fd72:	4990      	ldr	r1, [pc, #576]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fd74:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fd78:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd7c:	405a      	eors	r2, r3
 800fd7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fd80:	333c      	adds	r3, #60	@ 0x3c
 800fd82:	681b      	ldr	r3, [r3, #0]
 800fd84:	4053      	eors	r3, r2
 800fd86:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T(16); ENC_ROUND_T_S(16);
 800fd88:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fd8a:	0e1b      	lsrs	r3, r3, #24
 800fd8c:	b2db      	uxtb	r3, r3
 800fd8e:	461a      	mov	r2, r3
 800fd90:	4b88      	ldr	r3, [pc, #544]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fd92:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fd96:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fd98:	0c1b      	lsrs	r3, r3, #16
 800fd9a:	b2db      	uxtb	r3, r3
 800fd9c:	4985      	ldr	r1, [pc, #532]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fd9e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fda2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fda6:	405a      	eors	r2, r3
 800fda8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fdaa:	0a1b      	lsrs	r3, r3, #8
 800fdac:	b2db      	uxtb	r3, r3
 800fdae:	4981      	ldr	r1, [pc, #516]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fdb0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fdb4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fdb8:	405a      	eors	r2, r3
 800fdba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fdbc:	b2db      	uxtb	r3, r3
 800fdbe:	497d      	ldr	r1, [pc, #500]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fdc0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fdc4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fdc8:	405a      	eors	r2, r3
 800fdca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fdcc:	3340      	adds	r3, #64	@ 0x40
 800fdce:	681b      	ldr	r3, [r3, #0]
 800fdd0:	4053      	eors	r3, r2
 800fdd2:	623b      	str	r3, [r7, #32]
 800fdd4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fdd6:	0e1b      	lsrs	r3, r3, #24
 800fdd8:	b2db      	uxtb	r3, r3
 800fdda:	461a      	mov	r2, r3
 800fddc:	4b75      	ldr	r3, [pc, #468]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fdde:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fde2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fde4:	0c1b      	lsrs	r3, r3, #16
 800fde6:	b2db      	uxtb	r3, r3
 800fde8:	4972      	ldr	r1, [pc, #456]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fdea:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fdee:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fdf2:	405a      	eors	r2, r3
 800fdf4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fdf6:	0a1b      	lsrs	r3, r3, #8
 800fdf8:	b2db      	uxtb	r3, r3
 800fdfa:	496e      	ldr	r1, [pc, #440]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fdfc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fe00:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe04:	405a      	eors	r2, r3
 800fe06:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fe08:	b2db      	uxtb	r3, r3
 800fe0a:	496a      	ldr	r1, [pc, #424]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fe0c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fe10:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe14:	405a      	eors	r2, r3
 800fe16:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fe18:	3344      	adds	r3, #68	@ 0x44
 800fe1a:	681b      	ldr	r3, [r3, #0]
 800fe1c:	4053      	eors	r3, r2
 800fe1e:	61fb      	str	r3, [r7, #28]
 800fe20:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fe22:	0e1b      	lsrs	r3, r3, #24
 800fe24:	b2db      	uxtb	r3, r3
 800fe26:	461a      	mov	r2, r3
 800fe28:	4b62      	ldr	r3, [pc, #392]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fe2a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fe2e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fe30:	0c1b      	lsrs	r3, r3, #16
 800fe32:	b2db      	uxtb	r3, r3
 800fe34:	495f      	ldr	r1, [pc, #380]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fe36:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe3a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe3e:	405a      	eors	r2, r3
 800fe40:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fe42:	0a1b      	lsrs	r3, r3, #8
 800fe44:	b2db      	uxtb	r3, r3
 800fe46:	495b      	ldr	r1, [pc, #364]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fe48:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fe4c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe50:	405a      	eors	r2, r3
 800fe52:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fe54:	b2db      	uxtb	r3, r3
 800fe56:	4957      	ldr	r1, [pc, #348]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fe58:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fe5c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe60:	405a      	eors	r2, r3
 800fe62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fe64:	3348      	adds	r3, #72	@ 0x48
 800fe66:	681b      	ldr	r3, [r3, #0]
 800fe68:	4053      	eors	r3, r2
 800fe6a:	61bb      	str	r3, [r7, #24]
 800fe6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fe6e:	0e1b      	lsrs	r3, r3, #24
 800fe70:	b2db      	uxtb	r3, r3
 800fe72:	461a      	mov	r2, r3
 800fe74:	4b4f      	ldr	r3, [pc, #316]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fe76:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fe7a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fe7c:	0c1b      	lsrs	r3, r3, #16
 800fe7e:	b2db      	uxtb	r3, r3
 800fe80:	494c      	ldr	r1, [pc, #304]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fe82:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe86:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe8a:	405a      	eors	r2, r3
 800fe8c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fe8e:	0a1b      	lsrs	r3, r3, #8
 800fe90:	b2db      	uxtb	r3, r3
 800fe92:	4948      	ldr	r1, [pc, #288]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fe94:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fe98:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe9c:	405a      	eors	r2, r3
 800fe9e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fea0:	b2db      	uxtb	r3, r3
 800fea2:	4944      	ldr	r1, [pc, #272]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fea4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fea8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800feac:	405a      	eors	r2, r3
 800feae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800feb0:	334c      	adds	r3, #76	@ 0x4c
 800feb2:	681b      	ldr	r3, [r3, #0]
 800feb4:	4053      	eors	r3, r2
 800feb6:	617b      	str	r3, [r7, #20]
 800feb8:	6a3b      	ldr	r3, [r7, #32]
 800feba:	0e1b      	lsrs	r3, r3, #24
 800febc:	b2db      	uxtb	r3, r3
 800febe:	461a      	mov	r2, r3
 800fec0:	4b3c      	ldr	r3, [pc, #240]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fec2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fec6:	69fb      	ldr	r3, [r7, #28]
 800fec8:	0c1b      	lsrs	r3, r3, #16
 800feca:	b2db      	uxtb	r3, r3
 800fecc:	4939      	ldr	r1, [pc, #228]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fece:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fed2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fed6:	405a      	eors	r2, r3
 800fed8:	69bb      	ldr	r3, [r7, #24]
 800feda:	0a1b      	lsrs	r3, r3, #8
 800fedc:	b2db      	uxtb	r3, r3
 800fede:	4935      	ldr	r1, [pc, #212]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fee0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fee4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fee8:	405a      	eors	r2, r3
 800feea:	697b      	ldr	r3, [r7, #20]
 800feec:	b2db      	uxtb	r3, r3
 800feee:	4931      	ldr	r1, [pc, #196]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800fef0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fef4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fef8:	405a      	eors	r2, r3
 800fefa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fefc:	3350      	adds	r3, #80	@ 0x50
 800fefe:	681b      	ldr	r3, [r3, #0]
 800ff00:	4053      	eors	r3, r2
 800ff02:	637b      	str	r3, [r7, #52]	@ 0x34
 800ff04:	69fb      	ldr	r3, [r7, #28]
 800ff06:	0e1b      	lsrs	r3, r3, #24
 800ff08:	b2db      	uxtb	r3, r3
 800ff0a:	461a      	mov	r2, r3
 800ff0c:	4b29      	ldr	r3, [pc, #164]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800ff0e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ff12:	69bb      	ldr	r3, [r7, #24]
 800ff14:	0c1b      	lsrs	r3, r3, #16
 800ff16:	b2db      	uxtb	r3, r3
 800ff18:	4926      	ldr	r1, [pc, #152]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800ff1a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800ff1e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff22:	405a      	eors	r2, r3
 800ff24:	697b      	ldr	r3, [r7, #20]
 800ff26:	0a1b      	lsrs	r3, r3, #8
 800ff28:	b2db      	uxtb	r3, r3
 800ff2a:	4922      	ldr	r1, [pc, #136]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800ff2c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800ff30:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff34:	405a      	eors	r2, r3
 800ff36:	6a3b      	ldr	r3, [r7, #32]
 800ff38:	b2db      	uxtb	r3, r3
 800ff3a:	491e      	ldr	r1, [pc, #120]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800ff3c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800ff40:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff44:	405a      	eors	r2, r3
 800ff46:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ff48:	3354      	adds	r3, #84	@ 0x54
 800ff4a:	681b      	ldr	r3, [r3, #0]
 800ff4c:	4053      	eors	r3, r2
 800ff4e:	633b      	str	r3, [r7, #48]	@ 0x30
 800ff50:	69bb      	ldr	r3, [r7, #24]
 800ff52:	0e1b      	lsrs	r3, r3, #24
 800ff54:	b2db      	uxtb	r3, r3
 800ff56:	461a      	mov	r2, r3
 800ff58:	4b16      	ldr	r3, [pc, #88]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800ff5a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ff5e:	697b      	ldr	r3, [r7, #20]
 800ff60:	0c1b      	lsrs	r3, r3, #16
 800ff62:	b2db      	uxtb	r3, r3
 800ff64:	4913      	ldr	r1, [pc, #76]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800ff66:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800ff6a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff6e:	405a      	eors	r2, r3
 800ff70:	6a3b      	ldr	r3, [r7, #32]
 800ff72:	0a1b      	lsrs	r3, r3, #8
 800ff74:	b2db      	uxtb	r3, r3
 800ff76:	490f      	ldr	r1, [pc, #60]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800ff78:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800ff7c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff80:	405a      	eors	r2, r3
 800ff82:	69fb      	ldr	r3, [r7, #28]
 800ff84:	b2db      	uxtb	r3, r3
 800ff86:	490b      	ldr	r1, [pc, #44]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800ff88:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800ff8c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff90:	405a      	eors	r2, r3
 800ff92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ff94:	3358      	adds	r3, #88	@ 0x58
 800ff96:	681b      	ldr	r3, [r3, #0]
 800ff98:	4053      	eors	r3, r2
 800ff9a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800ff9c:	697b      	ldr	r3, [r7, #20]
 800ff9e:	0e1b      	lsrs	r3, r3, #24
 800ffa0:	b2db      	uxtb	r3, r3
 800ffa2:	461a      	mov	r2, r3
 800ffa4:	4b03      	ldr	r3, [pc, #12]	@ (800ffb4 <AesEncrypt_C+0x65c>)
 800ffa6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ffaa:	6a3b      	ldr	r3, [r7, #32]
 800ffac:	0c1b      	lsrs	r3, r3, #16
 800ffae:	b2db      	uxtb	r3, r3
 800ffb0:	e002      	b.n	800ffb8 <AesEncrypt_C+0x660>
 800ffb2:	bf00      	nop
 800ffb4:	08032284 	.word	0x08032284
 800ffb8:	49b6      	ldr	r1, [pc, #728]	@ (8010294 <AesEncrypt_C+0x93c>)
 800ffba:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800ffbe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ffc2:	405a      	eors	r2, r3
 800ffc4:	69fb      	ldr	r3, [r7, #28]
 800ffc6:	0a1b      	lsrs	r3, r3, #8
 800ffc8:	b2db      	uxtb	r3, r3
 800ffca:	49b2      	ldr	r1, [pc, #712]	@ (8010294 <AesEncrypt_C+0x93c>)
 800ffcc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800ffd0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ffd4:	405a      	eors	r2, r3
 800ffd6:	69bb      	ldr	r3, [r7, #24]
 800ffd8:	b2db      	uxtb	r3, r3
 800ffda:	49ae      	ldr	r1, [pc, #696]	@ (8010294 <AesEncrypt_C+0x93c>)
 800ffdc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800ffe0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ffe4:	405a      	eors	r2, r3
 800ffe6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ffe8:	335c      	adds	r3, #92	@ 0x5c
 800ffea:	681b      	ldr	r3, [r3, #0]
 800ffec:	4053      	eors	r3, r2
 800ffee:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T(24); ENC_ROUND_T_S(24);
 800fff0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fff2:	0e1b      	lsrs	r3, r3, #24
 800fff4:	b2db      	uxtb	r3, r3
 800fff6:	461a      	mov	r2, r3
 800fff8:	4ba6      	ldr	r3, [pc, #664]	@ (8010294 <AesEncrypt_C+0x93c>)
 800fffa:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fffe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010000:	0c1b      	lsrs	r3, r3, #16
 8010002:	b2db      	uxtb	r3, r3
 8010004:	49a3      	ldr	r1, [pc, #652]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010006:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801000a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801000e:	405a      	eors	r2, r3
 8010010:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010012:	0a1b      	lsrs	r3, r3, #8
 8010014:	b2db      	uxtb	r3, r3
 8010016:	499f      	ldr	r1, [pc, #636]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010018:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801001c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010020:	405a      	eors	r2, r3
 8010022:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010024:	b2db      	uxtb	r3, r3
 8010026:	499b      	ldr	r1, [pc, #620]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010028:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801002c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010030:	405a      	eors	r2, r3
 8010032:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010034:	3360      	adds	r3, #96	@ 0x60
 8010036:	681b      	ldr	r3, [r3, #0]
 8010038:	4053      	eors	r3, r2
 801003a:	623b      	str	r3, [r7, #32]
 801003c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801003e:	0e1b      	lsrs	r3, r3, #24
 8010040:	b2db      	uxtb	r3, r3
 8010042:	461a      	mov	r2, r3
 8010044:	4b93      	ldr	r3, [pc, #588]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010046:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801004a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801004c:	0c1b      	lsrs	r3, r3, #16
 801004e:	b2db      	uxtb	r3, r3
 8010050:	4990      	ldr	r1, [pc, #576]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010052:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010056:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801005a:	405a      	eors	r2, r3
 801005c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801005e:	0a1b      	lsrs	r3, r3, #8
 8010060:	b2db      	uxtb	r3, r3
 8010062:	498c      	ldr	r1, [pc, #560]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010064:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010068:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801006c:	405a      	eors	r2, r3
 801006e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010070:	b2db      	uxtb	r3, r3
 8010072:	4988      	ldr	r1, [pc, #544]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010074:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010078:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801007c:	405a      	eors	r2, r3
 801007e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010080:	3364      	adds	r3, #100	@ 0x64
 8010082:	681b      	ldr	r3, [r3, #0]
 8010084:	4053      	eors	r3, r2
 8010086:	61fb      	str	r3, [r7, #28]
 8010088:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801008a:	0e1b      	lsrs	r3, r3, #24
 801008c:	b2db      	uxtb	r3, r3
 801008e:	461a      	mov	r2, r3
 8010090:	4b80      	ldr	r3, [pc, #512]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010092:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010096:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010098:	0c1b      	lsrs	r3, r3, #16
 801009a:	b2db      	uxtb	r3, r3
 801009c:	497d      	ldr	r1, [pc, #500]	@ (8010294 <AesEncrypt_C+0x93c>)
 801009e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80100a2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100a6:	405a      	eors	r2, r3
 80100a8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80100aa:	0a1b      	lsrs	r3, r3, #8
 80100ac:	b2db      	uxtb	r3, r3
 80100ae:	4979      	ldr	r1, [pc, #484]	@ (8010294 <AesEncrypt_C+0x93c>)
 80100b0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80100b4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100b8:	405a      	eors	r2, r3
 80100ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80100bc:	b2db      	uxtb	r3, r3
 80100be:	4975      	ldr	r1, [pc, #468]	@ (8010294 <AesEncrypt_C+0x93c>)
 80100c0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80100c4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100c8:	405a      	eors	r2, r3
 80100ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80100cc:	3368      	adds	r3, #104	@ 0x68
 80100ce:	681b      	ldr	r3, [r3, #0]
 80100d0:	4053      	eors	r3, r2
 80100d2:	61bb      	str	r3, [r7, #24]
 80100d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80100d6:	0e1b      	lsrs	r3, r3, #24
 80100d8:	b2db      	uxtb	r3, r3
 80100da:	461a      	mov	r2, r3
 80100dc:	4b6d      	ldr	r3, [pc, #436]	@ (8010294 <AesEncrypt_C+0x93c>)
 80100de:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80100e2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80100e4:	0c1b      	lsrs	r3, r3, #16
 80100e6:	b2db      	uxtb	r3, r3
 80100e8:	496a      	ldr	r1, [pc, #424]	@ (8010294 <AesEncrypt_C+0x93c>)
 80100ea:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80100ee:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100f2:	405a      	eors	r2, r3
 80100f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80100f6:	0a1b      	lsrs	r3, r3, #8
 80100f8:	b2db      	uxtb	r3, r3
 80100fa:	4966      	ldr	r1, [pc, #408]	@ (8010294 <AesEncrypt_C+0x93c>)
 80100fc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010100:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010104:	405a      	eors	r2, r3
 8010106:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010108:	b2db      	uxtb	r3, r3
 801010a:	4962      	ldr	r1, [pc, #392]	@ (8010294 <AesEncrypt_C+0x93c>)
 801010c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010110:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010114:	405a      	eors	r2, r3
 8010116:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010118:	336c      	adds	r3, #108	@ 0x6c
 801011a:	681b      	ldr	r3, [r3, #0]
 801011c:	4053      	eors	r3, r2
 801011e:	617b      	str	r3, [r7, #20]
 8010120:	6a3b      	ldr	r3, [r7, #32]
 8010122:	0e1b      	lsrs	r3, r3, #24
 8010124:	b2db      	uxtb	r3, r3
 8010126:	461a      	mov	r2, r3
 8010128:	4b5a      	ldr	r3, [pc, #360]	@ (8010294 <AesEncrypt_C+0x93c>)
 801012a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801012e:	69fb      	ldr	r3, [r7, #28]
 8010130:	0c1b      	lsrs	r3, r3, #16
 8010132:	b2db      	uxtb	r3, r3
 8010134:	4957      	ldr	r1, [pc, #348]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010136:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801013a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801013e:	405a      	eors	r2, r3
 8010140:	69bb      	ldr	r3, [r7, #24]
 8010142:	0a1b      	lsrs	r3, r3, #8
 8010144:	b2db      	uxtb	r3, r3
 8010146:	4953      	ldr	r1, [pc, #332]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010148:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801014c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010150:	405a      	eors	r2, r3
 8010152:	697b      	ldr	r3, [r7, #20]
 8010154:	b2db      	uxtb	r3, r3
 8010156:	494f      	ldr	r1, [pc, #316]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010158:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801015c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010160:	405a      	eors	r2, r3
 8010162:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010164:	3370      	adds	r3, #112	@ 0x70
 8010166:	681b      	ldr	r3, [r3, #0]
 8010168:	4053      	eors	r3, r2
 801016a:	637b      	str	r3, [r7, #52]	@ 0x34
 801016c:	69fb      	ldr	r3, [r7, #28]
 801016e:	0e1b      	lsrs	r3, r3, #24
 8010170:	b2db      	uxtb	r3, r3
 8010172:	461a      	mov	r2, r3
 8010174:	4b47      	ldr	r3, [pc, #284]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010176:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801017a:	69bb      	ldr	r3, [r7, #24]
 801017c:	0c1b      	lsrs	r3, r3, #16
 801017e:	b2db      	uxtb	r3, r3
 8010180:	4944      	ldr	r1, [pc, #272]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010182:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010186:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801018a:	405a      	eors	r2, r3
 801018c:	697b      	ldr	r3, [r7, #20]
 801018e:	0a1b      	lsrs	r3, r3, #8
 8010190:	b2db      	uxtb	r3, r3
 8010192:	4940      	ldr	r1, [pc, #256]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010194:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010198:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801019c:	405a      	eors	r2, r3
 801019e:	6a3b      	ldr	r3, [r7, #32]
 80101a0:	b2db      	uxtb	r3, r3
 80101a2:	493c      	ldr	r1, [pc, #240]	@ (8010294 <AesEncrypt_C+0x93c>)
 80101a4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80101a8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101ac:	405a      	eors	r2, r3
 80101ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80101b0:	3374      	adds	r3, #116	@ 0x74
 80101b2:	681b      	ldr	r3, [r3, #0]
 80101b4:	4053      	eors	r3, r2
 80101b6:	633b      	str	r3, [r7, #48]	@ 0x30
 80101b8:	69bb      	ldr	r3, [r7, #24]
 80101ba:	0e1b      	lsrs	r3, r3, #24
 80101bc:	b2db      	uxtb	r3, r3
 80101be:	461a      	mov	r2, r3
 80101c0:	4b34      	ldr	r3, [pc, #208]	@ (8010294 <AesEncrypt_C+0x93c>)
 80101c2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80101c6:	697b      	ldr	r3, [r7, #20]
 80101c8:	0c1b      	lsrs	r3, r3, #16
 80101ca:	b2db      	uxtb	r3, r3
 80101cc:	4931      	ldr	r1, [pc, #196]	@ (8010294 <AesEncrypt_C+0x93c>)
 80101ce:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80101d2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101d6:	405a      	eors	r2, r3
 80101d8:	6a3b      	ldr	r3, [r7, #32]
 80101da:	0a1b      	lsrs	r3, r3, #8
 80101dc:	b2db      	uxtb	r3, r3
 80101de:	492d      	ldr	r1, [pc, #180]	@ (8010294 <AesEncrypt_C+0x93c>)
 80101e0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80101e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101e8:	405a      	eors	r2, r3
 80101ea:	69fb      	ldr	r3, [r7, #28]
 80101ec:	b2db      	uxtb	r3, r3
 80101ee:	4929      	ldr	r1, [pc, #164]	@ (8010294 <AesEncrypt_C+0x93c>)
 80101f0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80101f4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101f8:	405a      	eors	r2, r3
 80101fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80101fc:	3378      	adds	r3, #120	@ 0x78
 80101fe:	681b      	ldr	r3, [r3, #0]
 8010200:	4053      	eors	r3, r2
 8010202:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010204:	697b      	ldr	r3, [r7, #20]
 8010206:	0e1b      	lsrs	r3, r3, #24
 8010208:	b2db      	uxtb	r3, r3
 801020a:	461a      	mov	r2, r3
 801020c:	4b21      	ldr	r3, [pc, #132]	@ (8010294 <AesEncrypt_C+0x93c>)
 801020e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010212:	6a3b      	ldr	r3, [r7, #32]
 8010214:	0c1b      	lsrs	r3, r3, #16
 8010216:	b2db      	uxtb	r3, r3
 8010218:	491e      	ldr	r1, [pc, #120]	@ (8010294 <AesEncrypt_C+0x93c>)
 801021a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801021e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010222:	405a      	eors	r2, r3
 8010224:	69fb      	ldr	r3, [r7, #28]
 8010226:	0a1b      	lsrs	r3, r3, #8
 8010228:	b2db      	uxtb	r3, r3
 801022a:	491a      	ldr	r1, [pc, #104]	@ (8010294 <AesEncrypt_C+0x93c>)
 801022c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010230:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010234:	405a      	eors	r2, r3
 8010236:	69bb      	ldr	r3, [r7, #24]
 8010238:	b2db      	uxtb	r3, r3
 801023a:	4916      	ldr	r1, [pc, #88]	@ (8010294 <AesEncrypt_C+0x93c>)
 801023c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010240:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010244:	405a      	eors	r2, r3
 8010246:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010248:	337c      	adds	r3, #124	@ 0x7c
 801024a:	681b      	ldr	r3, [r3, #0]
 801024c:	4053      	eors	r3, r2
 801024e:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T(32); ENC_ROUND_T_S(32);
 8010250:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010252:	0e1b      	lsrs	r3, r3, #24
 8010254:	b2db      	uxtb	r3, r3
 8010256:	461a      	mov	r2, r3
 8010258:	4b0e      	ldr	r3, [pc, #56]	@ (8010294 <AesEncrypt_C+0x93c>)
 801025a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801025e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010260:	0c1b      	lsrs	r3, r3, #16
 8010262:	b2db      	uxtb	r3, r3
 8010264:	490b      	ldr	r1, [pc, #44]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010266:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801026a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801026e:	405a      	eors	r2, r3
 8010270:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010272:	0a1b      	lsrs	r3, r3, #8
 8010274:	b2db      	uxtb	r3, r3
 8010276:	4907      	ldr	r1, [pc, #28]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010278:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801027c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010280:	405a      	eors	r2, r3
 8010282:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010284:	b2db      	uxtb	r3, r3
 8010286:	4903      	ldr	r1, [pc, #12]	@ (8010294 <AesEncrypt_C+0x93c>)
 8010288:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801028c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010290:	405a      	eors	r2, r3
 8010292:	e001      	b.n	8010298 <AesEncrypt_C+0x940>
 8010294:	08032284 	.word	0x08032284
 8010298:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801029a:	3380      	adds	r3, #128	@ 0x80
 801029c:	681b      	ldr	r3, [r3, #0]
 801029e:	4053      	eors	r3, r2
 80102a0:	623b      	str	r3, [r7, #32]
 80102a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80102a4:	0e1b      	lsrs	r3, r3, #24
 80102a6:	b2db      	uxtb	r3, r3
 80102a8:	461a      	mov	r2, r3
 80102aa:	4bb6      	ldr	r3, [pc, #728]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80102ac:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80102b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80102b2:	0c1b      	lsrs	r3, r3, #16
 80102b4:	b2db      	uxtb	r3, r3
 80102b6:	49b3      	ldr	r1, [pc, #716]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80102b8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80102bc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102c0:	405a      	eors	r2, r3
 80102c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80102c4:	0a1b      	lsrs	r3, r3, #8
 80102c6:	b2db      	uxtb	r3, r3
 80102c8:	49ae      	ldr	r1, [pc, #696]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80102ca:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80102ce:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102d2:	405a      	eors	r2, r3
 80102d4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80102d6:	b2db      	uxtb	r3, r3
 80102d8:	49aa      	ldr	r1, [pc, #680]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80102da:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80102de:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102e2:	405a      	eors	r2, r3
 80102e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102e6:	3384      	adds	r3, #132	@ 0x84
 80102e8:	681b      	ldr	r3, [r3, #0]
 80102ea:	4053      	eors	r3, r2
 80102ec:	61fb      	str	r3, [r7, #28]
 80102ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80102f0:	0e1b      	lsrs	r3, r3, #24
 80102f2:	b2db      	uxtb	r3, r3
 80102f4:	461a      	mov	r2, r3
 80102f6:	4ba3      	ldr	r3, [pc, #652]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80102f8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80102fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80102fe:	0c1b      	lsrs	r3, r3, #16
 8010300:	b2db      	uxtb	r3, r3
 8010302:	49a0      	ldr	r1, [pc, #640]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010304:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010308:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801030c:	405a      	eors	r2, r3
 801030e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010310:	0a1b      	lsrs	r3, r3, #8
 8010312:	b2db      	uxtb	r3, r3
 8010314:	499b      	ldr	r1, [pc, #620]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010316:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801031a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801031e:	405a      	eors	r2, r3
 8010320:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010322:	b2db      	uxtb	r3, r3
 8010324:	4997      	ldr	r1, [pc, #604]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010326:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801032a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801032e:	405a      	eors	r2, r3
 8010330:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010332:	3388      	adds	r3, #136	@ 0x88
 8010334:	681b      	ldr	r3, [r3, #0]
 8010336:	4053      	eors	r3, r2
 8010338:	61bb      	str	r3, [r7, #24]
 801033a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801033c:	0e1b      	lsrs	r3, r3, #24
 801033e:	b2db      	uxtb	r3, r3
 8010340:	461a      	mov	r2, r3
 8010342:	4b90      	ldr	r3, [pc, #576]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010344:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010348:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801034a:	0c1b      	lsrs	r3, r3, #16
 801034c:	b2db      	uxtb	r3, r3
 801034e:	498d      	ldr	r1, [pc, #564]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010350:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010354:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010358:	405a      	eors	r2, r3
 801035a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801035c:	0a1b      	lsrs	r3, r3, #8
 801035e:	b2db      	uxtb	r3, r3
 8010360:	4988      	ldr	r1, [pc, #544]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010362:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010366:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801036a:	405a      	eors	r2, r3
 801036c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801036e:	b2db      	uxtb	r3, r3
 8010370:	4984      	ldr	r1, [pc, #528]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010372:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010376:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801037a:	405a      	eors	r2, r3
 801037c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801037e:	338c      	adds	r3, #140	@ 0x8c
 8010380:	681b      	ldr	r3, [r3, #0]
 8010382:	4053      	eors	r3, r2
 8010384:	617b      	str	r3, [r7, #20]
 8010386:	6a3b      	ldr	r3, [r7, #32]
 8010388:	0e1b      	lsrs	r3, r3, #24
 801038a:	b2db      	uxtb	r3, r3
 801038c:	461a      	mov	r2, r3
 801038e:	4b7d      	ldr	r3, [pc, #500]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010390:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010394:	69fb      	ldr	r3, [r7, #28]
 8010396:	0c1b      	lsrs	r3, r3, #16
 8010398:	b2db      	uxtb	r3, r3
 801039a:	497a      	ldr	r1, [pc, #488]	@ (8010584 <AesEncrypt_C+0xc2c>)
 801039c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80103a0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80103a4:	405a      	eors	r2, r3
 80103a6:	69bb      	ldr	r3, [r7, #24]
 80103a8:	0a1b      	lsrs	r3, r3, #8
 80103aa:	b2db      	uxtb	r3, r3
 80103ac:	4975      	ldr	r1, [pc, #468]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80103ae:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80103b2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80103b6:	405a      	eors	r2, r3
 80103b8:	697b      	ldr	r3, [r7, #20]
 80103ba:	b2db      	uxtb	r3, r3
 80103bc:	4971      	ldr	r1, [pc, #452]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80103be:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80103c2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80103c6:	405a      	eors	r2, r3
 80103c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80103ca:	3390      	adds	r3, #144	@ 0x90
 80103cc:	681b      	ldr	r3, [r3, #0]
 80103ce:	4053      	eors	r3, r2
 80103d0:	637b      	str	r3, [r7, #52]	@ 0x34
 80103d2:	69fb      	ldr	r3, [r7, #28]
 80103d4:	0e1b      	lsrs	r3, r3, #24
 80103d6:	b2db      	uxtb	r3, r3
 80103d8:	461a      	mov	r2, r3
 80103da:	4b6a      	ldr	r3, [pc, #424]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80103dc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80103e0:	69bb      	ldr	r3, [r7, #24]
 80103e2:	0c1b      	lsrs	r3, r3, #16
 80103e4:	b2db      	uxtb	r3, r3
 80103e6:	4967      	ldr	r1, [pc, #412]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80103e8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80103ec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80103f0:	405a      	eors	r2, r3
 80103f2:	697b      	ldr	r3, [r7, #20]
 80103f4:	0a1b      	lsrs	r3, r3, #8
 80103f6:	b2db      	uxtb	r3, r3
 80103f8:	4962      	ldr	r1, [pc, #392]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80103fa:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80103fe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010402:	405a      	eors	r2, r3
 8010404:	6a3b      	ldr	r3, [r7, #32]
 8010406:	b2db      	uxtb	r3, r3
 8010408:	495e      	ldr	r1, [pc, #376]	@ (8010584 <AesEncrypt_C+0xc2c>)
 801040a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801040e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010412:	405a      	eors	r2, r3
 8010414:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010416:	3394      	adds	r3, #148	@ 0x94
 8010418:	681b      	ldr	r3, [r3, #0]
 801041a:	4053      	eors	r3, r2
 801041c:	633b      	str	r3, [r7, #48]	@ 0x30
 801041e:	69bb      	ldr	r3, [r7, #24]
 8010420:	0e1b      	lsrs	r3, r3, #24
 8010422:	b2db      	uxtb	r3, r3
 8010424:	461a      	mov	r2, r3
 8010426:	4b57      	ldr	r3, [pc, #348]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010428:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801042c:	697b      	ldr	r3, [r7, #20]
 801042e:	0c1b      	lsrs	r3, r3, #16
 8010430:	b2db      	uxtb	r3, r3
 8010432:	4954      	ldr	r1, [pc, #336]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010434:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010438:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801043c:	405a      	eors	r2, r3
 801043e:	6a3b      	ldr	r3, [r7, #32]
 8010440:	0a1b      	lsrs	r3, r3, #8
 8010442:	b2db      	uxtb	r3, r3
 8010444:	494f      	ldr	r1, [pc, #316]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010446:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801044a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801044e:	405a      	eors	r2, r3
 8010450:	69fb      	ldr	r3, [r7, #28]
 8010452:	b2db      	uxtb	r3, r3
 8010454:	494b      	ldr	r1, [pc, #300]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010456:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801045a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801045e:	405a      	eors	r2, r3
 8010460:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010462:	3398      	adds	r3, #152	@ 0x98
 8010464:	681b      	ldr	r3, [r3, #0]
 8010466:	4053      	eors	r3, r2
 8010468:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801046a:	697b      	ldr	r3, [r7, #20]
 801046c:	0e1b      	lsrs	r3, r3, #24
 801046e:	b2db      	uxtb	r3, r3
 8010470:	461a      	mov	r2, r3
 8010472:	4b44      	ldr	r3, [pc, #272]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010474:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010478:	6a3b      	ldr	r3, [r7, #32]
 801047a:	0c1b      	lsrs	r3, r3, #16
 801047c:	b2db      	uxtb	r3, r3
 801047e:	4941      	ldr	r1, [pc, #260]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010480:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010484:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010488:	405a      	eors	r2, r3
 801048a:	69fb      	ldr	r3, [r7, #28]
 801048c:	0a1b      	lsrs	r3, r3, #8
 801048e:	b2db      	uxtb	r3, r3
 8010490:	493c      	ldr	r1, [pc, #240]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010492:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010496:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801049a:	405a      	eors	r2, r3
 801049c:	69bb      	ldr	r3, [r7, #24]
 801049e:	b2db      	uxtb	r3, r3
 80104a0:	4938      	ldr	r1, [pc, #224]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80104a2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80104a6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104aa:	405a      	eors	r2, r3
 80104ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80104ae:	339c      	adds	r3, #156	@ 0x9c
 80104b0:	681b      	ldr	r3, [r3, #0]
 80104b2:	4053      	eors	r3, r2
 80104b4:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (r > 5) {
 80104b6:	683b      	ldr	r3, [r7, #0]
 80104b8:	2b05      	cmp	r3, #5
 80104ba:	f240 826a 	bls.w	8010992 <AesEncrypt_C+0x103a>
        ENC_ROUND_S_T(40); ENC_ROUND_T_S(40);
 80104be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80104c0:	0e1b      	lsrs	r3, r3, #24
 80104c2:	b2db      	uxtb	r3, r3
 80104c4:	461a      	mov	r2, r3
 80104c6:	4b2f      	ldr	r3, [pc, #188]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80104c8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80104cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80104ce:	0c1b      	lsrs	r3, r3, #16
 80104d0:	b2db      	uxtb	r3, r3
 80104d2:	492c      	ldr	r1, [pc, #176]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80104d4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80104d8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104dc:	405a      	eors	r2, r3
 80104de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80104e0:	0a1b      	lsrs	r3, r3, #8
 80104e2:	b2db      	uxtb	r3, r3
 80104e4:	4927      	ldr	r1, [pc, #156]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80104e6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80104ea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104ee:	405a      	eors	r2, r3
 80104f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80104f2:	b2db      	uxtb	r3, r3
 80104f4:	4923      	ldr	r1, [pc, #140]	@ (8010584 <AesEncrypt_C+0xc2c>)
 80104f6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80104fa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104fe:	405a      	eors	r2, r3
 8010500:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010502:	33a0      	adds	r3, #160	@ 0xa0
 8010504:	681b      	ldr	r3, [r3, #0]
 8010506:	4053      	eors	r3, r2
 8010508:	623b      	str	r3, [r7, #32]
 801050a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801050c:	0e1b      	lsrs	r3, r3, #24
 801050e:	b2db      	uxtb	r3, r3
 8010510:	461a      	mov	r2, r3
 8010512:	4b1c      	ldr	r3, [pc, #112]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010514:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010518:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801051a:	0c1b      	lsrs	r3, r3, #16
 801051c:	b2db      	uxtb	r3, r3
 801051e:	4919      	ldr	r1, [pc, #100]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010520:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010524:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010528:	405a      	eors	r2, r3
 801052a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801052c:	0a1b      	lsrs	r3, r3, #8
 801052e:	b2db      	uxtb	r3, r3
 8010530:	4914      	ldr	r1, [pc, #80]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010532:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010536:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801053a:	405a      	eors	r2, r3
 801053c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801053e:	b2db      	uxtb	r3, r3
 8010540:	4910      	ldr	r1, [pc, #64]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010542:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010546:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801054a:	405a      	eors	r2, r3
 801054c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801054e:	33a4      	adds	r3, #164	@ 0xa4
 8010550:	681b      	ldr	r3, [r3, #0]
 8010552:	4053      	eors	r3, r2
 8010554:	61fb      	str	r3, [r7, #28]
 8010556:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010558:	0e1b      	lsrs	r3, r3, #24
 801055a:	b2db      	uxtb	r3, r3
 801055c:	461a      	mov	r2, r3
 801055e:	4b09      	ldr	r3, [pc, #36]	@ (8010584 <AesEncrypt_C+0xc2c>)
 8010560:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010564:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010566:	0c1b      	lsrs	r3, r3, #16
 8010568:	b2db      	uxtb	r3, r3
 801056a:	4906      	ldr	r1, [pc, #24]	@ (8010584 <AesEncrypt_C+0xc2c>)
 801056c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010570:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010574:	405a      	eors	r2, r3
 8010576:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010578:	0a1b      	lsrs	r3, r3, #8
 801057a:	b2db      	uxtb	r3, r3
 801057c:	4901      	ldr	r1, [pc, #4]	@ (8010584 <AesEncrypt_C+0xc2c>)
 801057e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010582:	e001      	b.n	8010588 <AesEncrypt_C+0xc30>
 8010584:	08032284 	.word	0x08032284
 8010588:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801058c:	405a      	eors	r2, r3
 801058e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010590:	b2db      	uxtb	r3, r3
 8010592:	49b6      	ldr	r1, [pc, #728]	@ (801086c <AesEncrypt_C+0xf14>)
 8010594:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010598:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801059c:	405a      	eors	r2, r3
 801059e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80105a0:	33a8      	adds	r3, #168	@ 0xa8
 80105a2:	681b      	ldr	r3, [r3, #0]
 80105a4:	4053      	eors	r3, r2
 80105a6:	61bb      	str	r3, [r7, #24]
 80105a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80105aa:	0e1b      	lsrs	r3, r3, #24
 80105ac:	b2db      	uxtb	r3, r3
 80105ae:	461a      	mov	r2, r3
 80105b0:	4bae      	ldr	r3, [pc, #696]	@ (801086c <AesEncrypt_C+0xf14>)
 80105b2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80105b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80105b8:	0c1b      	lsrs	r3, r3, #16
 80105ba:	b2db      	uxtb	r3, r3
 80105bc:	49ab      	ldr	r1, [pc, #684]	@ (801086c <AesEncrypt_C+0xf14>)
 80105be:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80105c2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105c6:	405a      	eors	r2, r3
 80105c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80105ca:	0a1b      	lsrs	r3, r3, #8
 80105cc:	b2db      	uxtb	r3, r3
 80105ce:	49a7      	ldr	r1, [pc, #668]	@ (801086c <AesEncrypt_C+0xf14>)
 80105d0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80105d4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105d8:	405a      	eors	r2, r3
 80105da:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80105dc:	b2db      	uxtb	r3, r3
 80105de:	49a3      	ldr	r1, [pc, #652]	@ (801086c <AesEncrypt_C+0xf14>)
 80105e0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80105e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105e8:	405a      	eors	r2, r3
 80105ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80105ec:	33ac      	adds	r3, #172	@ 0xac
 80105ee:	681b      	ldr	r3, [r3, #0]
 80105f0:	4053      	eors	r3, r2
 80105f2:	617b      	str	r3, [r7, #20]
 80105f4:	6a3b      	ldr	r3, [r7, #32]
 80105f6:	0e1b      	lsrs	r3, r3, #24
 80105f8:	b2db      	uxtb	r3, r3
 80105fa:	461a      	mov	r2, r3
 80105fc:	4b9b      	ldr	r3, [pc, #620]	@ (801086c <AesEncrypt_C+0xf14>)
 80105fe:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010602:	69fb      	ldr	r3, [r7, #28]
 8010604:	0c1b      	lsrs	r3, r3, #16
 8010606:	b2db      	uxtb	r3, r3
 8010608:	4998      	ldr	r1, [pc, #608]	@ (801086c <AesEncrypt_C+0xf14>)
 801060a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801060e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010612:	405a      	eors	r2, r3
 8010614:	69bb      	ldr	r3, [r7, #24]
 8010616:	0a1b      	lsrs	r3, r3, #8
 8010618:	b2db      	uxtb	r3, r3
 801061a:	4994      	ldr	r1, [pc, #592]	@ (801086c <AesEncrypt_C+0xf14>)
 801061c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010620:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010624:	405a      	eors	r2, r3
 8010626:	697b      	ldr	r3, [r7, #20]
 8010628:	b2db      	uxtb	r3, r3
 801062a:	4990      	ldr	r1, [pc, #576]	@ (801086c <AesEncrypt_C+0xf14>)
 801062c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010630:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010634:	405a      	eors	r2, r3
 8010636:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010638:	33b0      	adds	r3, #176	@ 0xb0
 801063a:	681b      	ldr	r3, [r3, #0]
 801063c:	4053      	eors	r3, r2
 801063e:	637b      	str	r3, [r7, #52]	@ 0x34
 8010640:	69fb      	ldr	r3, [r7, #28]
 8010642:	0e1b      	lsrs	r3, r3, #24
 8010644:	b2db      	uxtb	r3, r3
 8010646:	461a      	mov	r2, r3
 8010648:	4b88      	ldr	r3, [pc, #544]	@ (801086c <AesEncrypt_C+0xf14>)
 801064a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801064e:	69bb      	ldr	r3, [r7, #24]
 8010650:	0c1b      	lsrs	r3, r3, #16
 8010652:	b2db      	uxtb	r3, r3
 8010654:	4985      	ldr	r1, [pc, #532]	@ (801086c <AesEncrypt_C+0xf14>)
 8010656:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801065a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801065e:	405a      	eors	r2, r3
 8010660:	697b      	ldr	r3, [r7, #20]
 8010662:	0a1b      	lsrs	r3, r3, #8
 8010664:	b2db      	uxtb	r3, r3
 8010666:	4981      	ldr	r1, [pc, #516]	@ (801086c <AesEncrypt_C+0xf14>)
 8010668:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801066c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010670:	405a      	eors	r2, r3
 8010672:	6a3b      	ldr	r3, [r7, #32]
 8010674:	b2db      	uxtb	r3, r3
 8010676:	497d      	ldr	r1, [pc, #500]	@ (801086c <AesEncrypt_C+0xf14>)
 8010678:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801067c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010680:	405a      	eors	r2, r3
 8010682:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010684:	33b4      	adds	r3, #180	@ 0xb4
 8010686:	681b      	ldr	r3, [r3, #0]
 8010688:	4053      	eors	r3, r2
 801068a:	633b      	str	r3, [r7, #48]	@ 0x30
 801068c:	69bb      	ldr	r3, [r7, #24]
 801068e:	0e1b      	lsrs	r3, r3, #24
 8010690:	b2db      	uxtb	r3, r3
 8010692:	461a      	mov	r2, r3
 8010694:	4b75      	ldr	r3, [pc, #468]	@ (801086c <AesEncrypt_C+0xf14>)
 8010696:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801069a:	697b      	ldr	r3, [r7, #20]
 801069c:	0c1b      	lsrs	r3, r3, #16
 801069e:	b2db      	uxtb	r3, r3
 80106a0:	4972      	ldr	r1, [pc, #456]	@ (801086c <AesEncrypt_C+0xf14>)
 80106a2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80106a6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106aa:	405a      	eors	r2, r3
 80106ac:	6a3b      	ldr	r3, [r7, #32]
 80106ae:	0a1b      	lsrs	r3, r3, #8
 80106b0:	b2db      	uxtb	r3, r3
 80106b2:	496e      	ldr	r1, [pc, #440]	@ (801086c <AesEncrypt_C+0xf14>)
 80106b4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80106b8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106bc:	405a      	eors	r2, r3
 80106be:	69fb      	ldr	r3, [r7, #28]
 80106c0:	b2db      	uxtb	r3, r3
 80106c2:	496a      	ldr	r1, [pc, #424]	@ (801086c <AesEncrypt_C+0xf14>)
 80106c4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80106c8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106cc:	405a      	eors	r2, r3
 80106ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80106d0:	33b8      	adds	r3, #184	@ 0xb8
 80106d2:	681b      	ldr	r3, [r3, #0]
 80106d4:	4053      	eors	r3, r2
 80106d6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80106d8:	697b      	ldr	r3, [r7, #20]
 80106da:	0e1b      	lsrs	r3, r3, #24
 80106dc:	b2db      	uxtb	r3, r3
 80106de:	461a      	mov	r2, r3
 80106e0:	4b62      	ldr	r3, [pc, #392]	@ (801086c <AesEncrypt_C+0xf14>)
 80106e2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80106e6:	6a3b      	ldr	r3, [r7, #32]
 80106e8:	0c1b      	lsrs	r3, r3, #16
 80106ea:	b2db      	uxtb	r3, r3
 80106ec:	495f      	ldr	r1, [pc, #380]	@ (801086c <AesEncrypt_C+0xf14>)
 80106ee:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80106f2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106f6:	405a      	eors	r2, r3
 80106f8:	69fb      	ldr	r3, [r7, #28]
 80106fa:	0a1b      	lsrs	r3, r3, #8
 80106fc:	b2db      	uxtb	r3, r3
 80106fe:	495b      	ldr	r1, [pc, #364]	@ (801086c <AesEncrypt_C+0xf14>)
 8010700:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010704:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010708:	405a      	eors	r2, r3
 801070a:	69bb      	ldr	r3, [r7, #24]
 801070c:	b2db      	uxtb	r3, r3
 801070e:	4957      	ldr	r1, [pc, #348]	@ (801086c <AesEncrypt_C+0xf14>)
 8010710:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010714:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010718:	405a      	eors	r2, r3
 801071a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801071c:	33bc      	adds	r3, #188	@ 0xbc
 801071e:	681b      	ldr	r3, [r3, #0]
 8010720:	4053      	eors	r3, r2
 8010722:	62bb      	str	r3, [r7, #40]	@ 0x28
        if (r > 6) {
 8010724:	683b      	ldr	r3, [r7, #0]
 8010726:	2b06      	cmp	r3, #6
 8010728:	f240 8133 	bls.w	8010992 <AesEncrypt_C+0x103a>
            ENC_ROUND_S_T(48); ENC_ROUND_T_S(48);
 801072c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801072e:	0e1b      	lsrs	r3, r3, #24
 8010730:	b2db      	uxtb	r3, r3
 8010732:	461a      	mov	r2, r3
 8010734:	4b4d      	ldr	r3, [pc, #308]	@ (801086c <AesEncrypt_C+0xf14>)
 8010736:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801073a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801073c:	0c1b      	lsrs	r3, r3, #16
 801073e:	b2db      	uxtb	r3, r3
 8010740:	494a      	ldr	r1, [pc, #296]	@ (801086c <AesEncrypt_C+0xf14>)
 8010742:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010746:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801074a:	405a      	eors	r2, r3
 801074c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801074e:	0a1b      	lsrs	r3, r3, #8
 8010750:	b2db      	uxtb	r3, r3
 8010752:	4946      	ldr	r1, [pc, #280]	@ (801086c <AesEncrypt_C+0xf14>)
 8010754:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010758:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801075c:	405a      	eors	r2, r3
 801075e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010760:	b2db      	uxtb	r3, r3
 8010762:	4942      	ldr	r1, [pc, #264]	@ (801086c <AesEncrypt_C+0xf14>)
 8010764:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010768:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801076c:	405a      	eors	r2, r3
 801076e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010770:	33c0      	adds	r3, #192	@ 0xc0
 8010772:	681b      	ldr	r3, [r3, #0]
 8010774:	4053      	eors	r3, r2
 8010776:	623b      	str	r3, [r7, #32]
 8010778:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801077a:	0e1b      	lsrs	r3, r3, #24
 801077c:	b2db      	uxtb	r3, r3
 801077e:	461a      	mov	r2, r3
 8010780:	4b3a      	ldr	r3, [pc, #232]	@ (801086c <AesEncrypt_C+0xf14>)
 8010782:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010786:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010788:	0c1b      	lsrs	r3, r3, #16
 801078a:	b2db      	uxtb	r3, r3
 801078c:	4937      	ldr	r1, [pc, #220]	@ (801086c <AesEncrypt_C+0xf14>)
 801078e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010792:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010796:	405a      	eors	r2, r3
 8010798:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801079a:	0a1b      	lsrs	r3, r3, #8
 801079c:	b2db      	uxtb	r3, r3
 801079e:	4933      	ldr	r1, [pc, #204]	@ (801086c <AesEncrypt_C+0xf14>)
 80107a0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80107a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107a8:	405a      	eors	r2, r3
 80107aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80107ac:	b2db      	uxtb	r3, r3
 80107ae:	492f      	ldr	r1, [pc, #188]	@ (801086c <AesEncrypt_C+0xf14>)
 80107b0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80107b4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107b8:	405a      	eors	r2, r3
 80107ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80107bc:	33c4      	adds	r3, #196	@ 0xc4
 80107be:	681b      	ldr	r3, [r3, #0]
 80107c0:	4053      	eors	r3, r2
 80107c2:	61fb      	str	r3, [r7, #28]
 80107c4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80107c6:	0e1b      	lsrs	r3, r3, #24
 80107c8:	b2db      	uxtb	r3, r3
 80107ca:	461a      	mov	r2, r3
 80107cc:	4b27      	ldr	r3, [pc, #156]	@ (801086c <AesEncrypt_C+0xf14>)
 80107ce:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80107d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80107d4:	0c1b      	lsrs	r3, r3, #16
 80107d6:	b2db      	uxtb	r3, r3
 80107d8:	4924      	ldr	r1, [pc, #144]	@ (801086c <AesEncrypt_C+0xf14>)
 80107da:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80107de:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107e2:	405a      	eors	r2, r3
 80107e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80107e6:	0a1b      	lsrs	r3, r3, #8
 80107e8:	b2db      	uxtb	r3, r3
 80107ea:	4920      	ldr	r1, [pc, #128]	@ (801086c <AesEncrypt_C+0xf14>)
 80107ec:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80107f0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107f4:	405a      	eors	r2, r3
 80107f6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80107f8:	b2db      	uxtb	r3, r3
 80107fa:	491c      	ldr	r1, [pc, #112]	@ (801086c <AesEncrypt_C+0xf14>)
 80107fc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010800:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010804:	405a      	eors	r2, r3
 8010806:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010808:	33c8      	adds	r3, #200	@ 0xc8
 801080a:	681b      	ldr	r3, [r3, #0]
 801080c:	4053      	eors	r3, r2
 801080e:	61bb      	str	r3, [r7, #24]
 8010810:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010812:	0e1b      	lsrs	r3, r3, #24
 8010814:	b2db      	uxtb	r3, r3
 8010816:	461a      	mov	r2, r3
 8010818:	4b14      	ldr	r3, [pc, #80]	@ (801086c <AesEncrypt_C+0xf14>)
 801081a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801081e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010820:	0c1b      	lsrs	r3, r3, #16
 8010822:	b2db      	uxtb	r3, r3
 8010824:	4911      	ldr	r1, [pc, #68]	@ (801086c <AesEncrypt_C+0xf14>)
 8010826:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801082a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801082e:	405a      	eors	r2, r3
 8010830:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010832:	0a1b      	lsrs	r3, r3, #8
 8010834:	b2db      	uxtb	r3, r3
 8010836:	490d      	ldr	r1, [pc, #52]	@ (801086c <AesEncrypt_C+0xf14>)
 8010838:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801083c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010840:	405a      	eors	r2, r3
 8010842:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010844:	b2db      	uxtb	r3, r3
 8010846:	4909      	ldr	r1, [pc, #36]	@ (801086c <AesEncrypt_C+0xf14>)
 8010848:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801084c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010850:	405a      	eors	r2, r3
 8010852:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010854:	33cc      	adds	r3, #204	@ 0xcc
 8010856:	681b      	ldr	r3, [r3, #0]
 8010858:	4053      	eors	r3, r2
 801085a:	617b      	str	r3, [r7, #20]
 801085c:	6a3b      	ldr	r3, [r7, #32]
 801085e:	0e1b      	lsrs	r3, r3, #24
 8010860:	b2db      	uxtb	r3, r3
 8010862:	461a      	mov	r2, r3
 8010864:	4b01      	ldr	r3, [pc, #4]	@ (801086c <AesEncrypt_C+0xf14>)
 8010866:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801086a:	e001      	b.n	8010870 <AesEncrypt_C+0xf18>
 801086c:	08032284 	.word	0x08032284
 8010870:	69fb      	ldr	r3, [r7, #28]
 8010872:	0c1b      	lsrs	r3, r3, #16
 8010874:	b2db      	uxtb	r3, r3
 8010876:	49b8      	ldr	r1, [pc, #736]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010878:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801087c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010880:	405a      	eors	r2, r3
 8010882:	69bb      	ldr	r3, [r7, #24]
 8010884:	0a1b      	lsrs	r3, r3, #8
 8010886:	b2db      	uxtb	r3, r3
 8010888:	49b3      	ldr	r1, [pc, #716]	@ (8010b58 <AesEncrypt_C+0x1200>)
 801088a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801088e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010892:	405a      	eors	r2, r3
 8010894:	697b      	ldr	r3, [r7, #20]
 8010896:	b2db      	uxtb	r3, r3
 8010898:	49af      	ldr	r1, [pc, #700]	@ (8010b58 <AesEncrypt_C+0x1200>)
 801089a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801089e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80108a2:	405a      	eors	r2, r3
 80108a4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80108a6:	33d0      	adds	r3, #208	@ 0xd0
 80108a8:	681b      	ldr	r3, [r3, #0]
 80108aa:	4053      	eors	r3, r2
 80108ac:	637b      	str	r3, [r7, #52]	@ 0x34
 80108ae:	69fb      	ldr	r3, [r7, #28]
 80108b0:	0e1b      	lsrs	r3, r3, #24
 80108b2:	b2db      	uxtb	r3, r3
 80108b4:	461a      	mov	r2, r3
 80108b6:	4ba8      	ldr	r3, [pc, #672]	@ (8010b58 <AesEncrypt_C+0x1200>)
 80108b8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80108bc:	69bb      	ldr	r3, [r7, #24]
 80108be:	0c1b      	lsrs	r3, r3, #16
 80108c0:	b2db      	uxtb	r3, r3
 80108c2:	49a5      	ldr	r1, [pc, #660]	@ (8010b58 <AesEncrypt_C+0x1200>)
 80108c4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80108c8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80108cc:	405a      	eors	r2, r3
 80108ce:	697b      	ldr	r3, [r7, #20]
 80108d0:	0a1b      	lsrs	r3, r3, #8
 80108d2:	b2db      	uxtb	r3, r3
 80108d4:	49a0      	ldr	r1, [pc, #640]	@ (8010b58 <AesEncrypt_C+0x1200>)
 80108d6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80108da:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80108de:	405a      	eors	r2, r3
 80108e0:	6a3b      	ldr	r3, [r7, #32]
 80108e2:	b2db      	uxtb	r3, r3
 80108e4:	499c      	ldr	r1, [pc, #624]	@ (8010b58 <AesEncrypt_C+0x1200>)
 80108e6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80108ea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80108ee:	405a      	eors	r2, r3
 80108f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80108f2:	33d4      	adds	r3, #212	@ 0xd4
 80108f4:	681b      	ldr	r3, [r3, #0]
 80108f6:	4053      	eors	r3, r2
 80108f8:	633b      	str	r3, [r7, #48]	@ 0x30
 80108fa:	69bb      	ldr	r3, [r7, #24]
 80108fc:	0e1b      	lsrs	r3, r3, #24
 80108fe:	b2db      	uxtb	r3, r3
 8010900:	461a      	mov	r2, r3
 8010902:	4b95      	ldr	r3, [pc, #596]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010904:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010908:	697b      	ldr	r3, [r7, #20]
 801090a:	0c1b      	lsrs	r3, r3, #16
 801090c:	b2db      	uxtb	r3, r3
 801090e:	4992      	ldr	r1, [pc, #584]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010910:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010914:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010918:	405a      	eors	r2, r3
 801091a:	6a3b      	ldr	r3, [r7, #32]
 801091c:	0a1b      	lsrs	r3, r3, #8
 801091e:	b2db      	uxtb	r3, r3
 8010920:	498d      	ldr	r1, [pc, #564]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010922:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010926:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801092a:	405a      	eors	r2, r3
 801092c:	69fb      	ldr	r3, [r7, #28]
 801092e:	b2db      	uxtb	r3, r3
 8010930:	4989      	ldr	r1, [pc, #548]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010932:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010936:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801093a:	405a      	eors	r2, r3
 801093c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801093e:	33d8      	adds	r3, #216	@ 0xd8
 8010940:	681b      	ldr	r3, [r3, #0]
 8010942:	4053      	eors	r3, r2
 8010944:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010946:	697b      	ldr	r3, [r7, #20]
 8010948:	0e1b      	lsrs	r3, r3, #24
 801094a:	b2db      	uxtb	r3, r3
 801094c:	461a      	mov	r2, r3
 801094e:	4b82      	ldr	r3, [pc, #520]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010950:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010954:	6a3b      	ldr	r3, [r7, #32]
 8010956:	0c1b      	lsrs	r3, r3, #16
 8010958:	b2db      	uxtb	r3, r3
 801095a:	497f      	ldr	r1, [pc, #508]	@ (8010b58 <AesEncrypt_C+0x1200>)
 801095c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010960:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010964:	405a      	eors	r2, r3
 8010966:	69fb      	ldr	r3, [r7, #28]
 8010968:	0a1b      	lsrs	r3, r3, #8
 801096a:	b2db      	uxtb	r3, r3
 801096c:	497a      	ldr	r1, [pc, #488]	@ (8010b58 <AesEncrypt_C+0x1200>)
 801096e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010972:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010976:	405a      	eors	r2, r3
 8010978:	69bb      	ldr	r3, [r7, #24]
 801097a:	b2db      	uxtb	r3, r3
 801097c:	4976      	ldr	r1, [pc, #472]	@ (8010b58 <AesEncrypt_C+0x1200>)
 801097e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010982:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010986:	405a      	eors	r2, r3
 8010988:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801098a:	33dc      	adds	r3, #220	@ 0xdc
 801098c:	681b      	ldr	r3, [r3, #0]
 801098e:	4053      	eors	r3, r2
 8010990:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
    rk += r * 8;
 8010992:	683b      	ldr	r3, [r7, #0]
 8010994:	015b      	lsls	r3, r3, #5
 8010996:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8010998:	4413      	add	r3, r2
 801099a:	627b      	str	r3, [r7, #36]	@ 0x24
     * map cipher state to byte array block:
     */

#ifndef WOLFSSL_AES_TOUCH_LINES
    s0 =
        (GetTable(Te[2], GETBYTE(t0, 3)) & 0xff000000) ^
 801099c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801099e:	0e1b      	lsrs	r3, r3, #24
 80109a0:	b2db      	uxtb	r3, r3
 80109a2:	4a6d      	ldr	r2, [pc, #436]	@ (8010b58 <AesEncrypt_C+0x1200>)
 80109a4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80109a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80109ac:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t1, 2)) & 0x00ff0000) ^
 80109b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80109b2:	0c1b      	lsrs	r3, r3, #16
 80109b4:	b2db      	uxtb	r3, r3
 80109b6:	4968      	ldr	r1, [pc, #416]	@ (8010b58 <AesEncrypt_C+0x1200>)
 80109b8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80109bc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80109c0:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t0, 3)) & 0xff000000) ^
 80109c4:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t2, 1)) & 0x0000ff00) ^
 80109c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80109c8:	0a1b      	lsrs	r3, r3, #8
 80109ca:	b2db      	uxtb	r3, r3
 80109cc:	4619      	mov	r1, r3
 80109ce:	4b62      	ldr	r3, [pc, #392]	@ (8010b58 <AesEncrypt_C+0x1200>)
 80109d0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80109d4:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t1, 2)) & 0x00ff0000) ^
 80109d8:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 80109da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80109dc:	b2db      	uxtb	r3, r3
 80109de:	495e      	ldr	r1, [pc, #376]	@ (8010b58 <AesEncrypt_C+0x1200>)
 80109e0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80109e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80109e8:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t2, 1)) & 0x0000ff00) ^
 80109ea:	405a      	eors	r2, r3
        rk[0];
 80109ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80109ee:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 80109f0:	4053      	eors	r3, r2
    s0 =
 80109f2:	623b      	str	r3, [r7, #32]
    s1 =
        (GetTable(Te[2], GETBYTE(t1, 3)) & 0xff000000) ^
 80109f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80109f6:	0e1b      	lsrs	r3, r3, #24
 80109f8:	b2db      	uxtb	r3, r3
 80109fa:	4a57      	ldr	r2, [pc, #348]	@ (8010b58 <AesEncrypt_C+0x1200>)
 80109fc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010a00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010a04:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t2, 2)) & 0x00ff0000) ^
 8010a08:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010a0a:	0c1b      	lsrs	r3, r3, #16
 8010a0c:	b2db      	uxtb	r3, r3
 8010a0e:	4952      	ldr	r1, [pc, #328]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010a10:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010a14:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010a18:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t1, 3)) & 0xff000000) ^
 8010a1c:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t3, 1)) & 0x0000ff00) ^
 8010a1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010a20:	0a1b      	lsrs	r3, r3, #8
 8010a22:	b2db      	uxtb	r3, r3
 8010a24:	4619      	mov	r1, r3
 8010a26:	4b4c      	ldr	r3, [pc, #304]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010a28:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8010a2c:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t2, 2)) & 0x00ff0000) ^
 8010a30:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 8010a32:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010a34:	b2db      	uxtb	r3, r3
 8010a36:	4948      	ldr	r1, [pc, #288]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010a38:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010a3c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010a40:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t3, 1)) & 0x0000ff00) ^
 8010a42:	405a      	eors	r2, r3
        rk[1];
 8010a44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010a46:	3304      	adds	r3, #4
 8010a48:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 8010a4a:	4053      	eors	r3, r2
    s1 =
 8010a4c:	61fb      	str	r3, [r7, #28]
    s2 =
        (GetTable(Te[2], GETBYTE(t2, 3)) & 0xff000000) ^
 8010a4e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010a50:	0e1b      	lsrs	r3, r3, #24
 8010a52:	b2db      	uxtb	r3, r3
 8010a54:	4a40      	ldr	r2, [pc, #256]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010a56:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010a5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010a5e:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t3, 2)) & 0x00ff0000) ^
 8010a62:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010a64:	0c1b      	lsrs	r3, r3, #16
 8010a66:	b2db      	uxtb	r3, r3
 8010a68:	493b      	ldr	r1, [pc, #236]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010a6a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010a6e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010a72:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t2, 3)) & 0xff000000) ^
 8010a76:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t0, 1)) & 0x0000ff00) ^
 8010a78:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010a7a:	0a1b      	lsrs	r3, r3, #8
 8010a7c:	b2db      	uxtb	r3, r3
 8010a7e:	4619      	mov	r1, r3
 8010a80:	4b35      	ldr	r3, [pc, #212]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010a82:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8010a86:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t3, 2)) & 0x00ff0000) ^
 8010a8a:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t1, 0)) & 0x000000ff) ^
 8010a8c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010a8e:	b2db      	uxtb	r3, r3
 8010a90:	4931      	ldr	r1, [pc, #196]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010a92:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010a96:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010a9a:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t0, 1)) & 0x0000ff00) ^
 8010a9c:	405a      	eors	r2, r3
        rk[2];
 8010a9e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010aa0:	3308      	adds	r3, #8
 8010aa2:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t1, 0)) & 0x000000ff) ^
 8010aa4:	4053      	eors	r3, r2
    s2 =
 8010aa6:	61bb      	str	r3, [r7, #24]
    s3 =
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 8010aa8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010aaa:	0e1b      	lsrs	r3, r3, #24
 8010aac:	b2db      	uxtb	r3, r3
 8010aae:	4a2a      	ldr	r2, [pc, #168]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010ab0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010ab4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010ab8:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t0, 2)) & 0x00ff0000) ^
 8010abc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010abe:	0c1b      	lsrs	r3, r3, #16
 8010ac0:	b2db      	uxtb	r3, r3
 8010ac2:	4925      	ldr	r1, [pc, #148]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010ac4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010ac8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010acc:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 8010ad0:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t1, 1)) & 0x0000ff00) ^
 8010ad2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010ad4:	0a1b      	lsrs	r3, r3, #8
 8010ad6:	b2db      	uxtb	r3, r3
 8010ad8:	4619      	mov	r1, r3
 8010ada:	4b1f      	ldr	r3, [pc, #124]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010adc:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8010ae0:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t0, 2)) & 0x00ff0000) ^
 8010ae4:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 8010ae6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010ae8:	b2db      	uxtb	r3, r3
 8010aea:	491b      	ldr	r1, [pc, #108]	@ (8010b58 <AesEncrypt_C+0x1200>)
 8010aec:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010af0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010af4:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t1, 1)) & 0x0000ff00) ^
 8010af6:	405a      	eors	r2, r3
        rk[3];
 8010af8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010afa:	330c      	adds	r3, #12
 8010afc:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 8010afe:	4053      	eors	r3, r2
    s3 =
 8010b00:	617b      	str	r3, [r7, #20]
    s3 = t3 ^ rk[3];
#endif

    /* write out */
#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 8010b02:	6a3b      	ldr	r3, [r7, #32]
 8010b04:	4618      	mov	r0, r3
 8010b06:	f7fe fe28 	bl	800f75a <ByteReverseWord32>
 8010b0a:	4603      	mov	r3, r0
 8010b0c:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 8010b0e:	69fb      	ldr	r3, [r7, #28]
 8010b10:	4618      	mov	r0, r3
 8010b12:	f7fe fe22 	bl	800f75a <ByteReverseWord32>
 8010b16:	4603      	mov	r3, r0
 8010b18:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 8010b1a:	69bb      	ldr	r3, [r7, #24]
 8010b1c:	4618      	mov	r0, r3
 8010b1e:	f7fe fe1c 	bl	800f75a <ByteReverseWord32>
 8010b22:	4603      	mov	r3, r0
 8010b24:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 8010b26:	697b      	ldr	r3, [r7, #20]
 8010b28:	4618      	mov	r0, r3
 8010b2a:	f7fe fe16 	bl	800f75a <ByteReverseWord32>
 8010b2e:	4603      	mov	r3, r0
 8010b30:	617b      	str	r3, [r7, #20]
#endif

    XMEMCPY(outBlock,                  &s0, sizeof(s0));
 8010b32:	6a3a      	ldr	r2, [r7, #32]
 8010b34:	687b      	ldr	r3, [r7, #4]
 8010b36:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock +     sizeof(s0), &s1, sizeof(s1));
 8010b38:	687b      	ldr	r3, [r7, #4]
 8010b3a:	3304      	adds	r3, #4
 8010b3c:	69fa      	ldr	r2, [r7, #28]
 8010b3e:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 2 * sizeof(s0), &s2, sizeof(s2));
 8010b40:	687b      	ldr	r3, [r7, #4]
 8010b42:	3308      	adds	r3, #8
 8010b44:	69ba      	ldr	r2, [r7, #24]
 8010b46:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 3 * sizeof(s0), &s3, sizeof(s3));
 8010b48:	687b      	ldr	r3, [r7, #4]
 8010b4a:	330c      	adds	r3, #12
 8010b4c:	697a      	ldr	r2, [r7, #20]
 8010b4e:	601a      	str	r2, [r3, #0]
}
 8010b50:	bf00      	nop
 8010b52:	3738      	adds	r7, #56	@ 0x38
 8010b54:	46bd      	mov	sp, r7
 8010b56:	bd80      	pop	{r7, pc}
 8010b58:	08032284 	.word	0x08032284

08010b5c <wc_AesEncrypt>:

/* this section disabled with NO_AES_192 */
/* calling this one when missing NO_AES_192  */
static WARN_UNUSED_RESULT int wc_AesEncrypt(
    Aes* aes, const byte* inBlock, byte* outBlock)
{
 8010b5c:	b580      	push	{r7, lr}
 8010b5e:	b086      	sub	sp, #24
 8010b60:	af00      	add	r7, sp, #0
 8010b62:	60f8      	str	r0, [r7, #12]
 8010b64:	60b9      	str	r1, [r7, #8]
 8010b66:	607a      	str	r2, [r7, #4]
#if defined(MAX3266X_CB)
    int ret_cb;
#endif
    word32 r;

    if (aes == NULL) {
 8010b68:	68fb      	ldr	r3, [r7, #12]
 8010b6a:	2b00      	cmp	r3, #0
 8010b6c:	d102      	bne.n	8010b74 <wc_AesEncrypt+0x18>
        return BAD_FUNC_ARG;
 8010b6e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8010b72:	e014      	b.n	8010b9e <wc_AesEncrypt+0x42>
        if (ret < 0)
            return ret;
    }
#endif

    r = aes->rounds >> 1;
 8010b74:	68fb      	ldr	r3, [r7, #12]
 8010b76:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8010b7a:	085b      	lsrs	r3, r3, #1
 8010b7c:	617b      	str	r3, [r7, #20]

    if (r > 7 || r == 0) {
 8010b7e:	697b      	ldr	r3, [r7, #20]
 8010b80:	2b07      	cmp	r3, #7
 8010b82:	d802      	bhi.n	8010b8a <wc_AesEncrypt+0x2e>
 8010b84:	697b      	ldr	r3, [r7, #20]
 8010b86:	2b00      	cmp	r3, #0
 8010b88:	d102      	bne.n	8010b90 <wc_AesEncrypt+0x34>
        WOLFSSL_ERROR_VERBOSE(KEYUSAGE_E);
        return KEYUSAGE_E;
 8010b8a:	f06f 03e1 	mvn.w	r3, #225	@ 0xe1
 8010b8e:	e006      	b.n	8010b9e <wc_AesEncrypt+0x42>
            return ret_cb;
        /* fall-through when unavailable */
    }
#endif

    AesEncrypt_C(aes, inBlock, outBlock, r);
 8010b90:	697b      	ldr	r3, [r7, #20]
 8010b92:	687a      	ldr	r2, [r7, #4]
 8010b94:	68b9      	ldr	r1, [r7, #8]
 8010b96:	68f8      	ldr	r0, [r7, #12]
 8010b98:	f7fe fede 	bl	800f958 <AesEncrypt_C>

    return 0;
 8010b9c:	2300      	movs	r3, #0
} /* wc_AesEncrypt */
 8010b9e:	4618      	mov	r0, r3
 8010ba0:	3718      	adds	r7, #24
 8010ba2:	46bd      	mov	sp, r7
 8010ba4:	bd80      	pop	{r7, pc}
	...

08010ba8 <PreFetchTd>:
#ifndef WC_AES_BITSLICED
#ifndef WC_NO_CACHE_RESISTANT
#ifndef WOLFSSL_AES_SMALL_TABLES
/* load 4 Td Tables into cache by cache line stride */
static WARN_UNUSED_RESULT WC_INLINE word32 PreFetchTd(void)
{
 8010ba8:	b480      	push	{r7}
 8010baa:	b085      	sub	sp, #20
 8010bac:	af00      	add	r7, sp, #0
    word32 x = 0;
 8010bae:	2300      	movs	r3, #0
 8010bb0:	60fb      	str	r3, [r7, #12]
    int i,j;

    for (i = 0; i < 4; i++) {
 8010bb2:	2300      	movs	r3, #0
 8010bb4:	60bb      	str	r3, [r7, #8]
 8010bb6:	e015      	b.n	8010be4 <PreFetchTd+0x3c>
        /* 256 elements, each one is 4 bytes */
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 8010bb8:	2300      	movs	r3, #0
 8010bba:	607b      	str	r3, [r7, #4]
 8010bbc:	e00c      	b.n	8010bd8 <PreFetchTd+0x30>
            x &= Td[i][j];
 8010bbe:	490e      	ldr	r1, [pc, #56]	@ (8010bf8 <PreFetchTd+0x50>)
 8010bc0:	68bb      	ldr	r3, [r7, #8]
 8010bc2:	021a      	lsls	r2, r3, #8
 8010bc4:	687b      	ldr	r3, [r7, #4]
 8010bc6:	4413      	add	r3, r2
 8010bc8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010bcc:	68fa      	ldr	r2, [r7, #12]
 8010bce:	4013      	ands	r3, r2
 8010bd0:	60fb      	str	r3, [r7, #12]
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 8010bd2:	687b      	ldr	r3, [r7, #4]
 8010bd4:	3308      	adds	r3, #8
 8010bd6:	607b      	str	r3, [r7, #4]
 8010bd8:	687b      	ldr	r3, [r7, #4]
 8010bda:	2bff      	cmp	r3, #255	@ 0xff
 8010bdc:	ddef      	ble.n	8010bbe <PreFetchTd+0x16>
    for (i = 0; i < 4; i++) {
 8010bde:	68bb      	ldr	r3, [r7, #8]
 8010be0:	3301      	adds	r3, #1
 8010be2:	60bb      	str	r3, [r7, #8]
 8010be4:	68bb      	ldr	r3, [r7, #8]
 8010be6:	2b03      	cmp	r3, #3
 8010be8:	dde6      	ble.n	8010bb8 <PreFetchTd+0x10>
        }
    }
    return x;
 8010bea:	68fb      	ldr	r3, [r7, #12]
}
 8010bec:	4618      	mov	r0, r3
 8010bee:	3714      	adds	r7, #20
 8010bf0:	46bd      	mov	sp, r7
 8010bf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010bf6:	4770      	bx	lr
 8010bf8:	08033284 	.word	0x08033284

08010bfc <PreFetchTd4>:
#endif /* !WOLFSSL_AES_SMALL_TABLES */

/* load Td Table4 into cache by cache line stride */
static WARN_UNUSED_RESULT WC_INLINE word32 PreFetchTd4(void)
{
 8010bfc:	b480      	push	{r7}
 8010bfe:	b083      	sub	sp, #12
 8010c00:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_AES_TOUCH_LINES
    word32 x = 0;
 8010c02:	2300      	movs	r3, #0
 8010c04:	607b      	str	r3, [r7, #4]
    int i;

    for (i = 0; i < 256; i += WC_CACHE_LINE_SZ) {
 8010c06:	2300      	movs	r3, #0
 8010c08:	603b      	str	r3, [r7, #0]
 8010c0a:	e00a      	b.n	8010c22 <PreFetchTd4+0x26>
        x &= (word32)Td4[i];
 8010c0c:	4a0a      	ldr	r2, [pc, #40]	@ (8010c38 <PreFetchTd4+0x3c>)
 8010c0e:	683b      	ldr	r3, [r7, #0]
 8010c10:	4413      	add	r3, r2
 8010c12:	781b      	ldrb	r3, [r3, #0]
 8010c14:	461a      	mov	r2, r3
 8010c16:	687b      	ldr	r3, [r7, #4]
 8010c18:	4013      	ands	r3, r2
 8010c1a:	607b      	str	r3, [r7, #4]
    for (i = 0; i < 256; i += WC_CACHE_LINE_SZ) {
 8010c1c:	683b      	ldr	r3, [r7, #0]
 8010c1e:	3320      	adds	r3, #32
 8010c20:	603b      	str	r3, [r7, #0]
 8010c22:	683b      	ldr	r3, [r7, #0]
 8010c24:	2bff      	cmp	r3, #255	@ 0xff
 8010c26:	ddf1      	ble.n	8010c0c <PreFetchTd4+0x10>
    }
    return x;
 8010c28:	687b      	ldr	r3, [r7, #4]
#else
    return 0;
#endif
}
 8010c2a:	4618      	mov	r0, r3
 8010c2c:	370c      	adds	r7, #12
 8010c2e:	46bd      	mov	sp, r7
 8010c30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010c34:	4770      	bx	lr
 8010c36:	bf00      	nop
 8010c38:	08034284 	.word	0x08034284

08010c3c <AesDecrypt_C>:
 * @param [out] outBlock  Encrypted block.
 * @param [in]  r         Rounds divided by 2.
 */
static void AesDecrypt_C(Aes* aes, const byte* inBlock, byte* outBlock,
    word32 r)
{
 8010c3c:	b580      	push	{r7, lr}
 8010c3e:	b08e      	sub	sp, #56	@ 0x38
 8010c40:	af00      	add	r7, sp, #0
 8010c42:	60f8      	str	r0, [r7, #12]
 8010c44:	60b9      	str	r1, [r7, #8]
 8010c46:	607a      	str	r2, [r7, #4]
 8010c48:	603b      	str	r3, [r7, #0]
    const word32* rk;

#ifdef WC_C_DYNAMIC_FALLBACK
    rk = aes->key_C_fallback;
#else
    rk = aes->key;
 8010c4a:	68fb      	ldr	r3, [r7, #12]
 8010c4c:	627b      	str	r3, [r7, #36]	@ 0x24

    /*
     * map byte array block to cipher state
     * and add initial round key:
     */
    XMEMCPY(&s0, inBlock,                  sizeof(s0));
 8010c4e:	68bb      	ldr	r3, [r7, #8]
 8010c50:	681b      	ldr	r3, [r3, #0]
 8010c52:	623b      	str	r3, [r7, #32]
    XMEMCPY(&s1, inBlock + sizeof(s0),     sizeof(s1));
 8010c54:	68bb      	ldr	r3, [r7, #8]
 8010c56:	3304      	adds	r3, #4
 8010c58:	681b      	ldr	r3, [r3, #0]
 8010c5a:	61fb      	str	r3, [r7, #28]
    XMEMCPY(&s2, inBlock + 2 * sizeof(s0), sizeof(s2));
 8010c5c:	68bb      	ldr	r3, [r7, #8]
 8010c5e:	3308      	adds	r3, #8
 8010c60:	681b      	ldr	r3, [r3, #0]
 8010c62:	61bb      	str	r3, [r7, #24]
    XMEMCPY(&s3, inBlock + 3 * sizeof(s0), sizeof(s3));
 8010c64:	68bb      	ldr	r3, [r7, #8]
 8010c66:	330c      	adds	r3, #12
 8010c68:	681b      	ldr	r3, [r3, #0]
 8010c6a:	617b      	str	r3, [r7, #20]

#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 8010c6c:	6a3b      	ldr	r3, [r7, #32]
 8010c6e:	4618      	mov	r0, r3
 8010c70:	f7fe fd73 	bl	800f75a <ByteReverseWord32>
 8010c74:	4603      	mov	r3, r0
 8010c76:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 8010c78:	69fb      	ldr	r3, [r7, #28]
 8010c7a:	4618      	mov	r0, r3
 8010c7c:	f7fe fd6d 	bl	800f75a <ByteReverseWord32>
 8010c80:	4603      	mov	r3, r0
 8010c82:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 8010c84:	69bb      	ldr	r3, [r7, #24]
 8010c86:	4618      	mov	r0, r3
 8010c88:	f7fe fd67 	bl	800f75a <ByteReverseWord32>
 8010c8c:	4603      	mov	r3, r0
 8010c8e:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 8010c90:	697b      	ldr	r3, [r7, #20]
 8010c92:	4618      	mov	r0, r3
 8010c94:	f7fe fd61 	bl	800f75a <ByteReverseWord32>
 8010c98:	4603      	mov	r3, r0
 8010c9a:	617b      	str	r3, [r7, #20]
#endif

    s0 ^= rk[0];
 8010c9c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010c9e:	681a      	ldr	r2, [r3, #0]
 8010ca0:	6a3b      	ldr	r3, [r7, #32]
 8010ca2:	4053      	eors	r3, r2
 8010ca4:	623b      	str	r3, [r7, #32]
    s1 ^= rk[1];
 8010ca6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010ca8:	3304      	adds	r3, #4
 8010caa:	681a      	ldr	r2, [r3, #0]
 8010cac:	69fb      	ldr	r3, [r7, #28]
 8010cae:	4053      	eors	r3, r2
 8010cb0:	61fb      	str	r3, [r7, #28]
    s2 ^= rk[2];
 8010cb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010cb4:	3308      	adds	r3, #8
 8010cb6:	681a      	ldr	r2, [r3, #0]
 8010cb8:	69bb      	ldr	r3, [r7, #24]
 8010cba:	4053      	eors	r3, r2
 8010cbc:	61bb      	str	r3, [r7, #24]
    s3 ^= rk[3];
 8010cbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010cc0:	330c      	adds	r3, #12
 8010cc2:	681a      	ldr	r2, [r3, #0]
 8010cc4:	697b      	ldr	r3, [r7, #20]
 8010cc6:	4053      	eors	r3, r2
 8010cc8:	617b      	str	r3, [r7, #20]

#ifndef WOLFSSL_AES_SMALL_TABLES
#ifndef WC_NO_CACHE_RESISTANT
    s0 |= PreFetchTd();
 8010cca:	f7ff ff6d 	bl	8010ba8 <PreFetchTd>
 8010cce:	4602      	mov	r2, r0
 8010cd0:	6a3b      	ldr	r3, [r7, #32]
 8010cd2:	4313      	orrs	r3, r2
 8010cd4:	623b      	str	r3, [r7, #32]
                          &s2, GETBYTE(t3, 0), &s3, GETBYTE(t0, 0));           \
    s0 ^= rk[(o)+0]; s1 ^= rk[(o)+1]; s2 ^= rk[(o)+2]; s3 ^= rk[(o)+3];
#endif

#ifndef WOLFSSL_AES_NO_UNROLL
                       DEC_ROUND_T_S( 0);
 8010cd6:	6a3b      	ldr	r3, [r7, #32]
 8010cd8:	0e1b      	lsrs	r3, r3, #24
 8010cda:	b2db      	uxtb	r3, r3
 8010cdc:	461a      	mov	r2, r3
 8010cde:	4bb6      	ldr	r3, [pc, #728]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010ce0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010ce4:	697b      	ldr	r3, [r7, #20]
 8010ce6:	0c1b      	lsrs	r3, r3, #16
 8010ce8:	b2db      	uxtb	r3, r3
 8010cea:	49b3      	ldr	r1, [pc, #716]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010cec:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010cf0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010cf4:	405a      	eors	r2, r3
 8010cf6:	69bb      	ldr	r3, [r7, #24]
 8010cf8:	0a1b      	lsrs	r3, r3, #8
 8010cfa:	b2db      	uxtb	r3, r3
 8010cfc:	49ae      	ldr	r1, [pc, #696]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010cfe:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010d02:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d06:	405a      	eors	r2, r3
 8010d08:	69fb      	ldr	r3, [r7, #28]
 8010d0a:	b2db      	uxtb	r3, r3
 8010d0c:	49aa      	ldr	r1, [pc, #680]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010d0e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010d12:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d16:	405a      	eors	r2, r3
 8010d18:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010d1a:	3310      	adds	r3, #16
 8010d1c:	681b      	ldr	r3, [r3, #0]
 8010d1e:	4053      	eors	r3, r2
 8010d20:	637b      	str	r3, [r7, #52]	@ 0x34
 8010d22:	69fb      	ldr	r3, [r7, #28]
 8010d24:	0e1b      	lsrs	r3, r3, #24
 8010d26:	b2db      	uxtb	r3, r3
 8010d28:	461a      	mov	r2, r3
 8010d2a:	4ba3      	ldr	r3, [pc, #652]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010d2c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010d30:	6a3b      	ldr	r3, [r7, #32]
 8010d32:	0c1b      	lsrs	r3, r3, #16
 8010d34:	b2db      	uxtb	r3, r3
 8010d36:	49a0      	ldr	r1, [pc, #640]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010d38:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010d3c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d40:	405a      	eors	r2, r3
 8010d42:	697b      	ldr	r3, [r7, #20]
 8010d44:	0a1b      	lsrs	r3, r3, #8
 8010d46:	b2db      	uxtb	r3, r3
 8010d48:	499b      	ldr	r1, [pc, #620]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010d4a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010d4e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d52:	405a      	eors	r2, r3
 8010d54:	69bb      	ldr	r3, [r7, #24]
 8010d56:	b2db      	uxtb	r3, r3
 8010d58:	4997      	ldr	r1, [pc, #604]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010d5a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010d5e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d62:	405a      	eors	r2, r3
 8010d64:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010d66:	3314      	adds	r3, #20
 8010d68:	681b      	ldr	r3, [r3, #0]
 8010d6a:	4053      	eors	r3, r2
 8010d6c:	633b      	str	r3, [r7, #48]	@ 0x30
 8010d6e:	69bb      	ldr	r3, [r7, #24]
 8010d70:	0e1b      	lsrs	r3, r3, #24
 8010d72:	b2db      	uxtb	r3, r3
 8010d74:	461a      	mov	r2, r3
 8010d76:	4b90      	ldr	r3, [pc, #576]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010d78:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010d7c:	69fb      	ldr	r3, [r7, #28]
 8010d7e:	0c1b      	lsrs	r3, r3, #16
 8010d80:	b2db      	uxtb	r3, r3
 8010d82:	498d      	ldr	r1, [pc, #564]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010d84:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010d88:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d8c:	405a      	eors	r2, r3
 8010d8e:	6a3b      	ldr	r3, [r7, #32]
 8010d90:	0a1b      	lsrs	r3, r3, #8
 8010d92:	b2db      	uxtb	r3, r3
 8010d94:	4988      	ldr	r1, [pc, #544]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010d96:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010d9a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d9e:	405a      	eors	r2, r3
 8010da0:	697b      	ldr	r3, [r7, #20]
 8010da2:	b2db      	uxtb	r3, r3
 8010da4:	4984      	ldr	r1, [pc, #528]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010da6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010daa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010dae:	405a      	eors	r2, r3
 8010db0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010db2:	3318      	adds	r3, #24
 8010db4:	681b      	ldr	r3, [r3, #0]
 8010db6:	4053      	eors	r3, r2
 8010db8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010dba:	697b      	ldr	r3, [r7, #20]
 8010dbc:	0e1b      	lsrs	r3, r3, #24
 8010dbe:	b2db      	uxtb	r3, r3
 8010dc0:	461a      	mov	r2, r3
 8010dc2:	4b7d      	ldr	r3, [pc, #500]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010dc4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010dc8:	69bb      	ldr	r3, [r7, #24]
 8010dca:	0c1b      	lsrs	r3, r3, #16
 8010dcc:	b2db      	uxtb	r3, r3
 8010dce:	497a      	ldr	r1, [pc, #488]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010dd0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010dd4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010dd8:	405a      	eors	r2, r3
 8010dda:	69fb      	ldr	r3, [r7, #28]
 8010ddc:	0a1b      	lsrs	r3, r3, #8
 8010dde:	b2db      	uxtb	r3, r3
 8010de0:	4975      	ldr	r1, [pc, #468]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010de2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010de6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010dea:	405a      	eors	r2, r3
 8010dec:	6a3b      	ldr	r3, [r7, #32]
 8010dee:	b2db      	uxtb	r3, r3
 8010df0:	4971      	ldr	r1, [pc, #452]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010df2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010df6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010dfa:	405a      	eors	r2, r3
 8010dfc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010dfe:	331c      	adds	r3, #28
 8010e00:	681b      	ldr	r3, [r3, #0]
 8010e02:	4053      	eors	r3, r2
 8010e04:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T( 8); DEC_ROUND_T_S( 8);
 8010e06:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010e08:	0e1b      	lsrs	r3, r3, #24
 8010e0a:	b2db      	uxtb	r3, r3
 8010e0c:	461a      	mov	r2, r3
 8010e0e:	4b6a      	ldr	r3, [pc, #424]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010e10:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010e14:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010e16:	0c1b      	lsrs	r3, r3, #16
 8010e18:	b2db      	uxtb	r3, r3
 8010e1a:	4967      	ldr	r1, [pc, #412]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010e1c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010e20:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e24:	405a      	eors	r2, r3
 8010e26:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010e28:	0a1b      	lsrs	r3, r3, #8
 8010e2a:	b2db      	uxtb	r3, r3
 8010e2c:	4962      	ldr	r1, [pc, #392]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010e2e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010e32:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e36:	405a      	eors	r2, r3
 8010e38:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010e3a:	b2db      	uxtb	r3, r3
 8010e3c:	495e      	ldr	r1, [pc, #376]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010e3e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010e42:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e46:	405a      	eors	r2, r3
 8010e48:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010e4a:	3320      	adds	r3, #32
 8010e4c:	681b      	ldr	r3, [r3, #0]
 8010e4e:	4053      	eors	r3, r2
 8010e50:	623b      	str	r3, [r7, #32]
 8010e52:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010e54:	0e1b      	lsrs	r3, r3, #24
 8010e56:	b2db      	uxtb	r3, r3
 8010e58:	461a      	mov	r2, r3
 8010e5a:	4b57      	ldr	r3, [pc, #348]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010e5c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010e60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010e62:	0c1b      	lsrs	r3, r3, #16
 8010e64:	b2db      	uxtb	r3, r3
 8010e66:	4954      	ldr	r1, [pc, #336]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010e68:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010e6c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e70:	405a      	eors	r2, r3
 8010e72:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010e74:	0a1b      	lsrs	r3, r3, #8
 8010e76:	b2db      	uxtb	r3, r3
 8010e78:	494f      	ldr	r1, [pc, #316]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010e7a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010e7e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e82:	405a      	eors	r2, r3
 8010e84:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010e86:	b2db      	uxtb	r3, r3
 8010e88:	494b      	ldr	r1, [pc, #300]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010e8a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010e8e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e92:	405a      	eors	r2, r3
 8010e94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010e96:	3324      	adds	r3, #36	@ 0x24
 8010e98:	681b      	ldr	r3, [r3, #0]
 8010e9a:	4053      	eors	r3, r2
 8010e9c:	61fb      	str	r3, [r7, #28]
 8010e9e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010ea0:	0e1b      	lsrs	r3, r3, #24
 8010ea2:	b2db      	uxtb	r3, r3
 8010ea4:	461a      	mov	r2, r3
 8010ea6:	4b44      	ldr	r3, [pc, #272]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010ea8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010eac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010eae:	0c1b      	lsrs	r3, r3, #16
 8010eb0:	b2db      	uxtb	r3, r3
 8010eb2:	4941      	ldr	r1, [pc, #260]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010eb4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010eb8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ebc:	405a      	eors	r2, r3
 8010ebe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010ec0:	0a1b      	lsrs	r3, r3, #8
 8010ec2:	b2db      	uxtb	r3, r3
 8010ec4:	493c      	ldr	r1, [pc, #240]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010ec6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010eca:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ece:	405a      	eors	r2, r3
 8010ed0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010ed2:	b2db      	uxtb	r3, r3
 8010ed4:	4938      	ldr	r1, [pc, #224]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010ed6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010eda:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ede:	405a      	eors	r2, r3
 8010ee0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010ee2:	3328      	adds	r3, #40	@ 0x28
 8010ee4:	681b      	ldr	r3, [r3, #0]
 8010ee6:	4053      	eors	r3, r2
 8010ee8:	61bb      	str	r3, [r7, #24]
 8010eea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010eec:	0e1b      	lsrs	r3, r3, #24
 8010eee:	b2db      	uxtb	r3, r3
 8010ef0:	461a      	mov	r2, r3
 8010ef2:	4b31      	ldr	r3, [pc, #196]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010ef4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010ef8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010efa:	0c1b      	lsrs	r3, r3, #16
 8010efc:	b2db      	uxtb	r3, r3
 8010efe:	492e      	ldr	r1, [pc, #184]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010f00:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010f04:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f08:	405a      	eors	r2, r3
 8010f0a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f0c:	0a1b      	lsrs	r3, r3, #8
 8010f0e:	b2db      	uxtb	r3, r3
 8010f10:	4929      	ldr	r1, [pc, #164]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010f12:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010f16:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f1a:	405a      	eors	r2, r3
 8010f1c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010f1e:	b2db      	uxtb	r3, r3
 8010f20:	4925      	ldr	r1, [pc, #148]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010f22:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010f26:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f2a:	405a      	eors	r2, r3
 8010f2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010f2e:	332c      	adds	r3, #44	@ 0x2c
 8010f30:	681b      	ldr	r3, [r3, #0]
 8010f32:	4053      	eors	r3, r2
 8010f34:	617b      	str	r3, [r7, #20]
 8010f36:	6a3b      	ldr	r3, [r7, #32]
 8010f38:	0e1b      	lsrs	r3, r3, #24
 8010f3a:	b2db      	uxtb	r3, r3
 8010f3c:	461a      	mov	r2, r3
 8010f3e:	4b1e      	ldr	r3, [pc, #120]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010f40:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010f44:	697b      	ldr	r3, [r7, #20]
 8010f46:	0c1b      	lsrs	r3, r3, #16
 8010f48:	b2db      	uxtb	r3, r3
 8010f4a:	491b      	ldr	r1, [pc, #108]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010f4c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010f50:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f54:	405a      	eors	r2, r3
 8010f56:	69bb      	ldr	r3, [r7, #24]
 8010f58:	0a1b      	lsrs	r3, r3, #8
 8010f5a:	b2db      	uxtb	r3, r3
 8010f5c:	4916      	ldr	r1, [pc, #88]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010f5e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010f62:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f66:	405a      	eors	r2, r3
 8010f68:	69fb      	ldr	r3, [r7, #28]
 8010f6a:	b2db      	uxtb	r3, r3
 8010f6c:	4912      	ldr	r1, [pc, #72]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010f6e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010f72:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f76:	405a      	eors	r2, r3
 8010f78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010f7a:	3330      	adds	r3, #48	@ 0x30
 8010f7c:	681b      	ldr	r3, [r3, #0]
 8010f7e:	4053      	eors	r3, r2
 8010f80:	637b      	str	r3, [r7, #52]	@ 0x34
 8010f82:	69fb      	ldr	r3, [r7, #28]
 8010f84:	0e1b      	lsrs	r3, r3, #24
 8010f86:	b2db      	uxtb	r3, r3
 8010f88:	461a      	mov	r2, r3
 8010f8a:	4b0b      	ldr	r3, [pc, #44]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010f8c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010f90:	6a3b      	ldr	r3, [r7, #32]
 8010f92:	0c1b      	lsrs	r3, r3, #16
 8010f94:	b2db      	uxtb	r3, r3
 8010f96:	4908      	ldr	r1, [pc, #32]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010f98:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010f9c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010fa0:	405a      	eors	r2, r3
 8010fa2:	697b      	ldr	r3, [r7, #20]
 8010fa4:	0a1b      	lsrs	r3, r3, #8
 8010fa6:	b2db      	uxtb	r3, r3
 8010fa8:	4903      	ldr	r1, [pc, #12]	@ (8010fb8 <AesDecrypt_C+0x37c>)
 8010faa:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010fae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010fb2:	405a      	eors	r2, r3
 8010fb4:	69bb      	ldr	r3, [r7, #24]
 8010fb6:	e001      	b.n	8010fbc <AesDecrypt_C+0x380>
 8010fb8:	08033284 	.word	0x08033284
 8010fbc:	b2db      	uxtb	r3, r3
 8010fbe:	49b6      	ldr	r1, [pc, #728]	@ (8011298 <AesDecrypt_C+0x65c>)
 8010fc0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010fc4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010fc8:	405a      	eors	r2, r3
 8010fca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010fcc:	3334      	adds	r3, #52	@ 0x34
 8010fce:	681b      	ldr	r3, [r3, #0]
 8010fd0:	4053      	eors	r3, r2
 8010fd2:	633b      	str	r3, [r7, #48]	@ 0x30
 8010fd4:	69bb      	ldr	r3, [r7, #24]
 8010fd6:	0e1b      	lsrs	r3, r3, #24
 8010fd8:	b2db      	uxtb	r3, r3
 8010fda:	461a      	mov	r2, r3
 8010fdc:	4bae      	ldr	r3, [pc, #696]	@ (8011298 <AesDecrypt_C+0x65c>)
 8010fde:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010fe2:	69fb      	ldr	r3, [r7, #28]
 8010fe4:	0c1b      	lsrs	r3, r3, #16
 8010fe6:	b2db      	uxtb	r3, r3
 8010fe8:	49ab      	ldr	r1, [pc, #684]	@ (8011298 <AesDecrypt_C+0x65c>)
 8010fea:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010fee:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ff2:	405a      	eors	r2, r3
 8010ff4:	6a3b      	ldr	r3, [r7, #32]
 8010ff6:	0a1b      	lsrs	r3, r3, #8
 8010ff8:	b2db      	uxtb	r3, r3
 8010ffa:	49a7      	ldr	r1, [pc, #668]	@ (8011298 <AesDecrypt_C+0x65c>)
 8010ffc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011000:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011004:	405a      	eors	r2, r3
 8011006:	697b      	ldr	r3, [r7, #20]
 8011008:	b2db      	uxtb	r3, r3
 801100a:	49a3      	ldr	r1, [pc, #652]	@ (8011298 <AesDecrypt_C+0x65c>)
 801100c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011010:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011014:	405a      	eors	r2, r3
 8011016:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011018:	3338      	adds	r3, #56	@ 0x38
 801101a:	681b      	ldr	r3, [r3, #0]
 801101c:	4053      	eors	r3, r2
 801101e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011020:	697b      	ldr	r3, [r7, #20]
 8011022:	0e1b      	lsrs	r3, r3, #24
 8011024:	b2db      	uxtb	r3, r3
 8011026:	461a      	mov	r2, r3
 8011028:	4b9b      	ldr	r3, [pc, #620]	@ (8011298 <AesDecrypt_C+0x65c>)
 801102a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801102e:	69bb      	ldr	r3, [r7, #24]
 8011030:	0c1b      	lsrs	r3, r3, #16
 8011032:	b2db      	uxtb	r3, r3
 8011034:	4998      	ldr	r1, [pc, #608]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011036:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801103a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801103e:	405a      	eors	r2, r3
 8011040:	69fb      	ldr	r3, [r7, #28]
 8011042:	0a1b      	lsrs	r3, r3, #8
 8011044:	b2db      	uxtb	r3, r3
 8011046:	4994      	ldr	r1, [pc, #592]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011048:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801104c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011050:	405a      	eors	r2, r3
 8011052:	6a3b      	ldr	r3, [r7, #32]
 8011054:	b2db      	uxtb	r3, r3
 8011056:	4990      	ldr	r1, [pc, #576]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011058:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801105c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011060:	405a      	eors	r2, r3
 8011062:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011064:	333c      	adds	r3, #60	@ 0x3c
 8011066:	681b      	ldr	r3, [r3, #0]
 8011068:	4053      	eors	r3, r2
 801106a:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T(16); DEC_ROUND_T_S(16);
 801106c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801106e:	0e1b      	lsrs	r3, r3, #24
 8011070:	b2db      	uxtb	r3, r3
 8011072:	461a      	mov	r2, r3
 8011074:	4b88      	ldr	r3, [pc, #544]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011076:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801107a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801107c:	0c1b      	lsrs	r3, r3, #16
 801107e:	b2db      	uxtb	r3, r3
 8011080:	4985      	ldr	r1, [pc, #532]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011082:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011086:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801108a:	405a      	eors	r2, r3
 801108c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801108e:	0a1b      	lsrs	r3, r3, #8
 8011090:	b2db      	uxtb	r3, r3
 8011092:	4981      	ldr	r1, [pc, #516]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011094:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011098:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801109c:	405a      	eors	r2, r3
 801109e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80110a0:	b2db      	uxtb	r3, r3
 80110a2:	497d      	ldr	r1, [pc, #500]	@ (8011298 <AesDecrypt_C+0x65c>)
 80110a4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80110a8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110ac:	405a      	eors	r2, r3
 80110ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80110b0:	3340      	adds	r3, #64	@ 0x40
 80110b2:	681b      	ldr	r3, [r3, #0]
 80110b4:	4053      	eors	r3, r2
 80110b6:	623b      	str	r3, [r7, #32]
 80110b8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80110ba:	0e1b      	lsrs	r3, r3, #24
 80110bc:	b2db      	uxtb	r3, r3
 80110be:	461a      	mov	r2, r3
 80110c0:	4b75      	ldr	r3, [pc, #468]	@ (8011298 <AesDecrypt_C+0x65c>)
 80110c2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80110c6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80110c8:	0c1b      	lsrs	r3, r3, #16
 80110ca:	b2db      	uxtb	r3, r3
 80110cc:	4972      	ldr	r1, [pc, #456]	@ (8011298 <AesDecrypt_C+0x65c>)
 80110ce:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80110d2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110d6:	405a      	eors	r2, r3
 80110d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80110da:	0a1b      	lsrs	r3, r3, #8
 80110dc:	b2db      	uxtb	r3, r3
 80110de:	496e      	ldr	r1, [pc, #440]	@ (8011298 <AesDecrypt_C+0x65c>)
 80110e0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80110e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110e8:	405a      	eors	r2, r3
 80110ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80110ec:	b2db      	uxtb	r3, r3
 80110ee:	496a      	ldr	r1, [pc, #424]	@ (8011298 <AesDecrypt_C+0x65c>)
 80110f0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80110f4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110f8:	405a      	eors	r2, r3
 80110fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80110fc:	3344      	adds	r3, #68	@ 0x44
 80110fe:	681b      	ldr	r3, [r3, #0]
 8011100:	4053      	eors	r3, r2
 8011102:	61fb      	str	r3, [r7, #28]
 8011104:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011106:	0e1b      	lsrs	r3, r3, #24
 8011108:	b2db      	uxtb	r3, r3
 801110a:	461a      	mov	r2, r3
 801110c:	4b62      	ldr	r3, [pc, #392]	@ (8011298 <AesDecrypt_C+0x65c>)
 801110e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011112:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011114:	0c1b      	lsrs	r3, r3, #16
 8011116:	b2db      	uxtb	r3, r3
 8011118:	495f      	ldr	r1, [pc, #380]	@ (8011298 <AesDecrypt_C+0x65c>)
 801111a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801111e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011122:	405a      	eors	r2, r3
 8011124:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011126:	0a1b      	lsrs	r3, r3, #8
 8011128:	b2db      	uxtb	r3, r3
 801112a:	495b      	ldr	r1, [pc, #364]	@ (8011298 <AesDecrypt_C+0x65c>)
 801112c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011130:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011134:	405a      	eors	r2, r3
 8011136:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011138:	b2db      	uxtb	r3, r3
 801113a:	4957      	ldr	r1, [pc, #348]	@ (8011298 <AesDecrypt_C+0x65c>)
 801113c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011140:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011144:	405a      	eors	r2, r3
 8011146:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011148:	3348      	adds	r3, #72	@ 0x48
 801114a:	681b      	ldr	r3, [r3, #0]
 801114c:	4053      	eors	r3, r2
 801114e:	61bb      	str	r3, [r7, #24]
 8011150:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011152:	0e1b      	lsrs	r3, r3, #24
 8011154:	b2db      	uxtb	r3, r3
 8011156:	461a      	mov	r2, r3
 8011158:	4b4f      	ldr	r3, [pc, #316]	@ (8011298 <AesDecrypt_C+0x65c>)
 801115a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801115e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011160:	0c1b      	lsrs	r3, r3, #16
 8011162:	b2db      	uxtb	r3, r3
 8011164:	494c      	ldr	r1, [pc, #304]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011166:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801116a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801116e:	405a      	eors	r2, r3
 8011170:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011172:	0a1b      	lsrs	r3, r3, #8
 8011174:	b2db      	uxtb	r3, r3
 8011176:	4948      	ldr	r1, [pc, #288]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011178:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801117c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011180:	405a      	eors	r2, r3
 8011182:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011184:	b2db      	uxtb	r3, r3
 8011186:	4944      	ldr	r1, [pc, #272]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011188:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801118c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011190:	405a      	eors	r2, r3
 8011192:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011194:	334c      	adds	r3, #76	@ 0x4c
 8011196:	681b      	ldr	r3, [r3, #0]
 8011198:	4053      	eors	r3, r2
 801119a:	617b      	str	r3, [r7, #20]
 801119c:	6a3b      	ldr	r3, [r7, #32]
 801119e:	0e1b      	lsrs	r3, r3, #24
 80111a0:	b2db      	uxtb	r3, r3
 80111a2:	461a      	mov	r2, r3
 80111a4:	4b3c      	ldr	r3, [pc, #240]	@ (8011298 <AesDecrypt_C+0x65c>)
 80111a6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80111aa:	697b      	ldr	r3, [r7, #20]
 80111ac:	0c1b      	lsrs	r3, r3, #16
 80111ae:	b2db      	uxtb	r3, r3
 80111b0:	4939      	ldr	r1, [pc, #228]	@ (8011298 <AesDecrypt_C+0x65c>)
 80111b2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80111b6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111ba:	405a      	eors	r2, r3
 80111bc:	69bb      	ldr	r3, [r7, #24]
 80111be:	0a1b      	lsrs	r3, r3, #8
 80111c0:	b2db      	uxtb	r3, r3
 80111c2:	4935      	ldr	r1, [pc, #212]	@ (8011298 <AesDecrypt_C+0x65c>)
 80111c4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80111c8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111cc:	405a      	eors	r2, r3
 80111ce:	69fb      	ldr	r3, [r7, #28]
 80111d0:	b2db      	uxtb	r3, r3
 80111d2:	4931      	ldr	r1, [pc, #196]	@ (8011298 <AesDecrypt_C+0x65c>)
 80111d4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80111d8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111dc:	405a      	eors	r2, r3
 80111de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80111e0:	3350      	adds	r3, #80	@ 0x50
 80111e2:	681b      	ldr	r3, [r3, #0]
 80111e4:	4053      	eors	r3, r2
 80111e6:	637b      	str	r3, [r7, #52]	@ 0x34
 80111e8:	69fb      	ldr	r3, [r7, #28]
 80111ea:	0e1b      	lsrs	r3, r3, #24
 80111ec:	b2db      	uxtb	r3, r3
 80111ee:	461a      	mov	r2, r3
 80111f0:	4b29      	ldr	r3, [pc, #164]	@ (8011298 <AesDecrypt_C+0x65c>)
 80111f2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80111f6:	6a3b      	ldr	r3, [r7, #32]
 80111f8:	0c1b      	lsrs	r3, r3, #16
 80111fa:	b2db      	uxtb	r3, r3
 80111fc:	4926      	ldr	r1, [pc, #152]	@ (8011298 <AesDecrypt_C+0x65c>)
 80111fe:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011202:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011206:	405a      	eors	r2, r3
 8011208:	697b      	ldr	r3, [r7, #20]
 801120a:	0a1b      	lsrs	r3, r3, #8
 801120c:	b2db      	uxtb	r3, r3
 801120e:	4922      	ldr	r1, [pc, #136]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011210:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011214:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011218:	405a      	eors	r2, r3
 801121a:	69bb      	ldr	r3, [r7, #24]
 801121c:	b2db      	uxtb	r3, r3
 801121e:	491e      	ldr	r1, [pc, #120]	@ (8011298 <AesDecrypt_C+0x65c>)
 8011220:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011224:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011228:	405a      	eors	r2, r3
 801122a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801122c:	3354      	adds	r3, #84	@ 0x54
 801122e:	681b      	ldr	r3, [r3, #0]
 8011230:	4053      	eors	r3, r2
 8011232:	633b      	str	r3, [r7, #48]	@ 0x30
 8011234:	69bb      	ldr	r3, [r7, #24]
 8011236:	0e1b      	lsrs	r3, r3, #24
 8011238:	b2db      	uxtb	r3, r3
 801123a:	461a      	mov	r2, r3
 801123c:	4b16      	ldr	r3, [pc, #88]	@ (8011298 <AesDecrypt_C+0x65c>)
 801123e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011242:	69fb      	ldr	r3, [r7, #28]
 8011244:	0c1b      	lsrs	r3, r3, #16
 8011246:	b2db      	uxtb	r3, r3
 8011248:	4913      	ldr	r1, [pc, #76]	@ (8011298 <AesDecrypt_C+0x65c>)
 801124a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801124e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011252:	405a      	eors	r2, r3
 8011254:	6a3b      	ldr	r3, [r7, #32]
 8011256:	0a1b      	lsrs	r3, r3, #8
 8011258:	b2db      	uxtb	r3, r3
 801125a:	490f      	ldr	r1, [pc, #60]	@ (8011298 <AesDecrypt_C+0x65c>)
 801125c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011260:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011264:	405a      	eors	r2, r3
 8011266:	697b      	ldr	r3, [r7, #20]
 8011268:	b2db      	uxtb	r3, r3
 801126a:	490b      	ldr	r1, [pc, #44]	@ (8011298 <AesDecrypt_C+0x65c>)
 801126c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011270:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011274:	405a      	eors	r2, r3
 8011276:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011278:	3358      	adds	r3, #88	@ 0x58
 801127a:	681b      	ldr	r3, [r3, #0]
 801127c:	4053      	eors	r3, r2
 801127e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011280:	697b      	ldr	r3, [r7, #20]
 8011282:	0e1b      	lsrs	r3, r3, #24
 8011284:	b2db      	uxtb	r3, r3
 8011286:	461a      	mov	r2, r3
 8011288:	4b03      	ldr	r3, [pc, #12]	@ (8011298 <AesDecrypt_C+0x65c>)
 801128a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801128e:	69bb      	ldr	r3, [r7, #24]
 8011290:	0c1b      	lsrs	r3, r3, #16
 8011292:	b2db      	uxtb	r3, r3
 8011294:	e002      	b.n	801129c <AesDecrypt_C+0x660>
 8011296:	bf00      	nop
 8011298:	08033284 	.word	0x08033284
 801129c:	49b6      	ldr	r1, [pc, #728]	@ (8011578 <AesDecrypt_C+0x93c>)
 801129e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80112a2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112a6:	405a      	eors	r2, r3
 80112a8:	69fb      	ldr	r3, [r7, #28]
 80112aa:	0a1b      	lsrs	r3, r3, #8
 80112ac:	b2db      	uxtb	r3, r3
 80112ae:	49b2      	ldr	r1, [pc, #712]	@ (8011578 <AesDecrypt_C+0x93c>)
 80112b0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80112b4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112b8:	405a      	eors	r2, r3
 80112ba:	6a3b      	ldr	r3, [r7, #32]
 80112bc:	b2db      	uxtb	r3, r3
 80112be:	49ae      	ldr	r1, [pc, #696]	@ (8011578 <AesDecrypt_C+0x93c>)
 80112c0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80112c4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112c8:	405a      	eors	r2, r3
 80112ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80112cc:	335c      	adds	r3, #92	@ 0x5c
 80112ce:	681b      	ldr	r3, [r3, #0]
 80112d0:	4053      	eors	r3, r2
 80112d2:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T(24); DEC_ROUND_T_S(24);
 80112d4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80112d6:	0e1b      	lsrs	r3, r3, #24
 80112d8:	b2db      	uxtb	r3, r3
 80112da:	461a      	mov	r2, r3
 80112dc:	4ba6      	ldr	r3, [pc, #664]	@ (8011578 <AesDecrypt_C+0x93c>)
 80112de:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80112e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80112e4:	0c1b      	lsrs	r3, r3, #16
 80112e6:	b2db      	uxtb	r3, r3
 80112e8:	49a3      	ldr	r1, [pc, #652]	@ (8011578 <AesDecrypt_C+0x93c>)
 80112ea:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80112ee:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112f2:	405a      	eors	r2, r3
 80112f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80112f6:	0a1b      	lsrs	r3, r3, #8
 80112f8:	b2db      	uxtb	r3, r3
 80112fa:	499f      	ldr	r1, [pc, #636]	@ (8011578 <AesDecrypt_C+0x93c>)
 80112fc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011300:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011304:	405a      	eors	r2, r3
 8011306:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011308:	b2db      	uxtb	r3, r3
 801130a:	499b      	ldr	r1, [pc, #620]	@ (8011578 <AesDecrypt_C+0x93c>)
 801130c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011310:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011314:	405a      	eors	r2, r3
 8011316:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011318:	3360      	adds	r3, #96	@ 0x60
 801131a:	681b      	ldr	r3, [r3, #0]
 801131c:	4053      	eors	r3, r2
 801131e:	623b      	str	r3, [r7, #32]
 8011320:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011322:	0e1b      	lsrs	r3, r3, #24
 8011324:	b2db      	uxtb	r3, r3
 8011326:	461a      	mov	r2, r3
 8011328:	4b93      	ldr	r3, [pc, #588]	@ (8011578 <AesDecrypt_C+0x93c>)
 801132a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801132e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011330:	0c1b      	lsrs	r3, r3, #16
 8011332:	b2db      	uxtb	r3, r3
 8011334:	4990      	ldr	r1, [pc, #576]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011336:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801133a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801133e:	405a      	eors	r2, r3
 8011340:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011342:	0a1b      	lsrs	r3, r3, #8
 8011344:	b2db      	uxtb	r3, r3
 8011346:	498c      	ldr	r1, [pc, #560]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011348:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801134c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011350:	405a      	eors	r2, r3
 8011352:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011354:	b2db      	uxtb	r3, r3
 8011356:	4988      	ldr	r1, [pc, #544]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011358:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801135c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011360:	405a      	eors	r2, r3
 8011362:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011364:	3364      	adds	r3, #100	@ 0x64
 8011366:	681b      	ldr	r3, [r3, #0]
 8011368:	4053      	eors	r3, r2
 801136a:	61fb      	str	r3, [r7, #28]
 801136c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801136e:	0e1b      	lsrs	r3, r3, #24
 8011370:	b2db      	uxtb	r3, r3
 8011372:	461a      	mov	r2, r3
 8011374:	4b80      	ldr	r3, [pc, #512]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011376:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801137a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801137c:	0c1b      	lsrs	r3, r3, #16
 801137e:	b2db      	uxtb	r3, r3
 8011380:	497d      	ldr	r1, [pc, #500]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011382:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011386:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801138a:	405a      	eors	r2, r3
 801138c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801138e:	0a1b      	lsrs	r3, r3, #8
 8011390:	b2db      	uxtb	r3, r3
 8011392:	4979      	ldr	r1, [pc, #484]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011394:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011398:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801139c:	405a      	eors	r2, r3
 801139e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80113a0:	b2db      	uxtb	r3, r3
 80113a2:	4975      	ldr	r1, [pc, #468]	@ (8011578 <AesDecrypt_C+0x93c>)
 80113a4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80113a8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113ac:	405a      	eors	r2, r3
 80113ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80113b0:	3368      	adds	r3, #104	@ 0x68
 80113b2:	681b      	ldr	r3, [r3, #0]
 80113b4:	4053      	eors	r3, r2
 80113b6:	61bb      	str	r3, [r7, #24]
 80113b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80113ba:	0e1b      	lsrs	r3, r3, #24
 80113bc:	b2db      	uxtb	r3, r3
 80113be:	461a      	mov	r2, r3
 80113c0:	4b6d      	ldr	r3, [pc, #436]	@ (8011578 <AesDecrypt_C+0x93c>)
 80113c2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80113c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80113c8:	0c1b      	lsrs	r3, r3, #16
 80113ca:	b2db      	uxtb	r3, r3
 80113cc:	496a      	ldr	r1, [pc, #424]	@ (8011578 <AesDecrypt_C+0x93c>)
 80113ce:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80113d2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113d6:	405a      	eors	r2, r3
 80113d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80113da:	0a1b      	lsrs	r3, r3, #8
 80113dc:	b2db      	uxtb	r3, r3
 80113de:	4966      	ldr	r1, [pc, #408]	@ (8011578 <AesDecrypt_C+0x93c>)
 80113e0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80113e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113e8:	405a      	eors	r2, r3
 80113ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80113ec:	b2db      	uxtb	r3, r3
 80113ee:	4962      	ldr	r1, [pc, #392]	@ (8011578 <AesDecrypt_C+0x93c>)
 80113f0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80113f4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113f8:	405a      	eors	r2, r3
 80113fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80113fc:	336c      	adds	r3, #108	@ 0x6c
 80113fe:	681b      	ldr	r3, [r3, #0]
 8011400:	4053      	eors	r3, r2
 8011402:	617b      	str	r3, [r7, #20]
 8011404:	6a3b      	ldr	r3, [r7, #32]
 8011406:	0e1b      	lsrs	r3, r3, #24
 8011408:	b2db      	uxtb	r3, r3
 801140a:	461a      	mov	r2, r3
 801140c:	4b5a      	ldr	r3, [pc, #360]	@ (8011578 <AesDecrypt_C+0x93c>)
 801140e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011412:	697b      	ldr	r3, [r7, #20]
 8011414:	0c1b      	lsrs	r3, r3, #16
 8011416:	b2db      	uxtb	r3, r3
 8011418:	4957      	ldr	r1, [pc, #348]	@ (8011578 <AesDecrypt_C+0x93c>)
 801141a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801141e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011422:	405a      	eors	r2, r3
 8011424:	69bb      	ldr	r3, [r7, #24]
 8011426:	0a1b      	lsrs	r3, r3, #8
 8011428:	b2db      	uxtb	r3, r3
 801142a:	4953      	ldr	r1, [pc, #332]	@ (8011578 <AesDecrypt_C+0x93c>)
 801142c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011430:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011434:	405a      	eors	r2, r3
 8011436:	69fb      	ldr	r3, [r7, #28]
 8011438:	b2db      	uxtb	r3, r3
 801143a:	494f      	ldr	r1, [pc, #316]	@ (8011578 <AesDecrypt_C+0x93c>)
 801143c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011440:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011444:	405a      	eors	r2, r3
 8011446:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011448:	3370      	adds	r3, #112	@ 0x70
 801144a:	681b      	ldr	r3, [r3, #0]
 801144c:	4053      	eors	r3, r2
 801144e:	637b      	str	r3, [r7, #52]	@ 0x34
 8011450:	69fb      	ldr	r3, [r7, #28]
 8011452:	0e1b      	lsrs	r3, r3, #24
 8011454:	b2db      	uxtb	r3, r3
 8011456:	461a      	mov	r2, r3
 8011458:	4b47      	ldr	r3, [pc, #284]	@ (8011578 <AesDecrypt_C+0x93c>)
 801145a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801145e:	6a3b      	ldr	r3, [r7, #32]
 8011460:	0c1b      	lsrs	r3, r3, #16
 8011462:	b2db      	uxtb	r3, r3
 8011464:	4944      	ldr	r1, [pc, #272]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011466:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801146a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801146e:	405a      	eors	r2, r3
 8011470:	697b      	ldr	r3, [r7, #20]
 8011472:	0a1b      	lsrs	r3, r3, #8
 8011474:	b2db      	uxtb	r3, r3
 8011476:	4940      	ldr	r1, [pc, #256]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011478:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801147c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011480:	405a      	eors	r2, r3
 8011482:	69bb      	ldr	r3, [r7, #24]
 8011484:	b2db      	uxtb	r3, r3
 8011486:	493c      	ldr	r1, [pc, #240]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011488:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801148c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011490:	405a      	eors	r2, r3
 8011492:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011494:	3374      	adds	r3, #116	@ 0x74
 8011496:	681b      	ldr	r3, [r3, #0]
 8011498:	4053      	eors	r3, r2
 801149a:	633b      	str	r3, [r7, #48]	@ 0x30
 801149c:	69bb      	ldr	r3, [r7, #24]
 801149e:	0e1b      	lsrs	r3, r3, #24
 80114a0:	b2db      	uxtb	r3, r3
 80114a2:	461a      	mov	r2, r3
 80114a4:	4b34      	ldr	r3, [pc, #208]	@ (8011578 <AesDecrypt_C+0x93c>)
 80114a6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80114aa:	69fb      	ldr	r3, [r7, #28]
 80114ac:	0c1b      	lsrs	r3, r3, #16
 80114ae:	b2db      	uxtb	r3, r3
 80114b0:	4931      	ldr	r1, [pc, #196]	@ (8011578 <AesDecrypt_C+0x93c>)
 80114b2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80114b6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114ba:	405a      	eors	r2, r3
 80114bc:	6a3b      	ldr	r3, [r7, #32]
 80114be:	0a1b      	lsrs	r3, r3, #8
 80114c0:	b2db      	uxtb	r3, r3
 80114c2:	492d      	ldr	r1, [pc, #180]	@ (8011578 <AesDecrypt_C+0x93c>)
 80114c4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80114c8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114cc:	405a      	eors	r2, r3
 80114ce:	697b      	ldr	r3, [r7, #20]
 80114d0:	b2db      	uxtb	r3, r3
 80114d2:	4929      	ldr	r1, [pc, #164]	@ (8011578 <AesDecrypt_C+0x93c>)
 80114d4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80114d8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114dc:	405a      	eors	r2, r3
 80114de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80114e0:	3378      	adds	r3, #120	@ 0x78
 80114e2:	681b      	ldr	r3, [r3, #0]
 80114e4:	4053      	eors	r3, r2
 80114e6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80114e8:	697b      	ldr	r3, [r7, #20]
 80114ea:	0e1b      	lsrs	r3, r3, #24
 80114ec:	b2db      	uxtb	r3, r3
 80114ee:	461a      	mov	r2, r3
 80114f0:	4b21      	ldr	r3, [pc, #132]	@ (8011578 <AesDecrypt_C+0x93c>)
 80114f2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80114f6:	69bb      	ldr	r3, [r7, #24]
 80114f8:	0c1b      	lsrs	r3, r3, #16
 80114fa:	b2db      	uxtb	r3, r3
 80114fc:	491e      	ldr	r1, [pc, #120]	@ (8011578 <AesDecrypt_C+0x93c>)
 80114fe:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011502:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011506:	405a      	eors	r2, r3
 8011508:	69fb      	ldr	r3, [r7, #28]
 801150a:	0a1b      	lsrs	r3, r3, #8
 801150c:	b2db      	uxtb	r3, r3
 801150e:	491a      	ldr	r1, [pc, #104]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011510:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011514:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011518:	405a      	eors	r2, r3
 801151a:	6a3b      	ldr	r3, [r7, #32]
 801151c:	b2db      	uxtb	r3, r3
 801151e:	4916      	ldr	r1, [pc, #88]	@ (8011578 <AesDecrypt_C+0x93c>)
 8011520:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011524:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011528:	405a      	eors	r2, r3
 801152a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801152c:	337c      	adds	r3, #124	@ 0x7c
 801152e:	681b      	ldr	r3, [r3, #0]
 8011530:	4053      	eors	r3, r2
 8011532:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T(32); DEC_ROUND_T_S(32);
 8011534:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011536:	0e1b      	lsrs	r3, r3, #24
 8011538:	b2db      	uxtb	r3, r3
 801153a:	461a      	mov	r2, r3
 801153c:	4b0e      	ldr	r3, [pc, #56]	@ (8011578 <AesDecrypt_C+0x93c>)
 801153e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011542:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011544:	0c1b      	lsrs	r3, r3, #16
 8011546:	b2db      	uxtb	r3, r3
 8011548:	490b      	ldr	r1, [pc, #44]	@ (8011578 <AesDecrypt_C+0x93c>)
 801154a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801154e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011552:	405a      	eors	r2, r3
 8011554:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011556:	0a1b      	lsrs	r3, r3, #8
 8011558:	b2db      	uxtb	r3, r3
 801155a:	4907      	ldr	r1, [pc, #28]	@ (8011578 <AesDecrypt_C+0x93c>)
 801155c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011560:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011564:	405a      	eors	r2, r3
 8011566:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011568:	b2db      	uxtb	r3, r3
 801156a:	4903      	ldr	r1, [pc, #12]	@ (8011578 <AesDecrypt_C+0x93c>)
 801156c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011570:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011574:	405a      	eors	r2, r3
 8011576:	e001      	b.n	801157c <AesDecrypt_C+0x940>
 8011578:	08033284 	.word	0x08033284
 801157c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801157e:	3380      	adds	r3, #128	@ 0x80
 8011580:	681b      	ldr	r3, [r3, #0]
 8011582:	4053      	eors	r3, r2
 8011584:	623b      	str	r3, [r7, #32]
 8011586:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011588:	0e1b      	lsrs	r3, r3, #24
 801158a:	b2db      	uxtb	r3, r3
 801158c:	461a      	mov	r2, r3
 801158e:	4bb6      	ldr	r3, [pc, #728]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011590:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011594:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011596:	0c1b      	lsrs	r3, r3, #16
 8011598:	b2db      	uxtb	r3, r3
 801159a:	49b3      	ldr	r1, [pc, #716]	@ (8011868 <AesDecrypt_C+0xc2c>)
 801159c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80115a0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115a4:	405a      	eors	r2, r3
 80115a6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80115a8:	0a1b      	lsrs	r3, r3, #8
 80115aa:	b2db      	uxtb	r3, r3
 80115ac:	49ae      	ldr	r1, [pc, #696]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80115ae:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80115b2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115b6:	405a      	eors	r2, r3
 80115b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80115ba:	b2db      	uxtb	r3, r3
 80115bc:	49aa      	ldr	r1, [pc, #680]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80115be:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80115c2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115c6:	405a      	eors	r2, r3
 80115c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80115ca:	3384      	adds	r3, #132	@ 0x84
 80115cc:	681b      	ldr	r3, [r3, #0]
 80115ce:	4053      	eors	r3, r2
 80115d0:	61fb      	str	r3, [r7, #28]
 80115d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80115d4:	0e1b      	lsrs	r3, r3, #24
 80115d6:	b2db      	uxtb	r3, r3
 80115d8:	461a      	mov	r2, r3
 80115da:	4ba3      	ldr	r3, [pc, #652]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80115dc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80115e0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80115e2:	0c1b      	lsrs	r3, r3, #16
 80115e4:	b2db      	uxtb	r3, r3
 80115e6:	49a0      	ldr	r1, [pc, #640]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80115e8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80115ec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115f0:	405a      	eors	r2, r3
 80115f2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80115f4:	0a1b      	lsrs	r3, r3, #8
 80115f6:	b2db      	uxtb	r3, r3
 80115f8:	499b      	ldr	r1, [pc, #620]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80115fa:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80115fe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011602:	405a      	eors	r2, r3
 8011604:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011606:	b2db      	uxtb	r3, r3
 8011608:	4997      	ldr	r1, [pc, #604]	@ (8011868 <AesDecrypt_C+0xc2c>)
 801160a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801160e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011612:	405a      	eors	r2, r3
 8011614:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011616:	3388      	adds	r3, #136	@ 0x88
 8011618:	681b      	ldr	r3, [r3, #0]
 801161a:	4053      	eors	r3, r2
 801161c:	61bb      	str	r3, [r7, #24]
 801161e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011620:	0e1b      	lsrs	r3, r3, #24
 8011622:	b2db      	uxtb	r3, r3
 8011624:	461a      	mov	r2, r3
 8011626:	4b90      	ldr	r3, [pc, #576]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011628:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801162c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801162e:	0c1b      	lsrs	r3, r3, #16
 8011630:	b2db      	uxtb	r3, r3
 8011632:	498d      	ldr	r1, [pc, #564]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011634:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011638:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801163c:	405a      	eors	r2, r3
 801163e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011640:	0a1b      	lsrs	r3, r3, #8
 8011642:	b2db      	uxtb	r3, r3
 8011644:	4988      	ldr	r1, [pc, #544]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011646:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801164a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801164e:	405a      	eors	r2, r3
 8011650:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011652:	b2db      	uxtb	r3, r3
 8011654:	4984      	ldr	r1, [pc, #528]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011656:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801165a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801165e:	405a      	eors	r2, r3
 8011660:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011662:	338c      	adds	r3, #140	@ 0x8c
 8011664:	681b      	ldr	r3, [r3, #0]
 8011666:	4053      	eors	r3, r2
 8011668:	617b      	str	r3, [r7, #20]
 801166a:	6a3b      	ldr	r3, [r7, #32]
 801166c:	0e1b      	lsrs	r3, r3, #24
 801166e:	b2db      	uxtb	r3, r3
 8011670:	461a      	mov	r2, r3
 8011672:	4b7d      	ldr	r3, [pc, #500]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011674:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011678:	697b      	ldr	r3, [r7, #20]
 801167a:	0c1b      	lsrs	r3, r3, #16
 801167c:	b2db      	uxtb	r3, r3
 801167e:	497a      	ldr	r1, [pc, #488]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011680:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011684:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011688:	405a      	eors	r2, r3
 801168a:	69bb      	ldr	r3, [r7, #24]
 801168c:	0a1b      	lsrs	r3, r3, #8
 801168e:	b2db      	uxtb	r3, r3
 8011690:	4975      	ldr	r1, [pc, #468]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011692:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011696:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801169a:	405a      	eors	r2, r3
 801169c:	69fb      	ldr	r3, [r7, #28]
 801169e:	b2db      	uxtb	r3, r3
 80116a0:	4971      	ldr	r1, [pc, #452]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80116a2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80116a6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116aa:	405a      	eors	r2, r3
 80116ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80116ae:	3390      	adds	r3, #144	@ 0x90
 80116b0:	681b      	ldr	r3, [r3, #0]
 80116b2:	4053      	eors	r3, r2
 80116b4:	637b      	str	r3, [r7, #52]	@ 0x34
 80116b6:	69fb      	ldr	r3, [r7, #28]
 80116b8:	0e1b      	lsrs	r3, r3, #24
 80116ba:	b2db      	uxtb	r3, r3
 80116bc:	461a      	mov	r2, r3
 80116be:	4b6a      	ldr	r3, [pc, #424]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80116c0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80116c4:	6a3b      	ldr	r3, [r7, #32]
 80116c6:	0c1b      	lsrs	r3, r3, #16
 80116c8:	b2db      	uxtb	r3, r3
 80116ca:	4967      	ldr	r1, [pc, #412]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80116cc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80116d0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116d4:	405a      	eors	r2, r3
 80116d6:	697b      	ldr	r3, [r7, #20]
 80116d8:	0a1b      	lsrs	r3, r3, #8
 80116da:	b2db      	uxtb	r3, r3
 80116dc:	4962      	ldr	r1, [pc, #392]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80116de:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80116e2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116e6:	405a      	eors	r2, r3
 80116e8:	69bb      	ldr	r3, [r7, #24]
 80116ea:	b2db      	uxtb	r3, r3
 80116ec:	495e      	ldr	r1, [pc, #376]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80116ee:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80116f2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116f6:	405a      	eors	r2, r3
 80116f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80116fa:	3394      	adds	r3, #148	@ 0x94
 80116fc:	681b      	ldr	r3, [r3, #0]
 80116fe:	4053      	eors	r3, r2
 8011700:	633b      	str	r3, [r7, #48]	@ 0x30
 8011702:	69bb      	ldr	r3, [r7, #24]
 8011704:	0e1b      	lsrs	r3, r3, #24
 8011706:	b2db      	uxtb	r3, r3
 8011708:	461a      	mov	r2, r3
 801170a:	4b57      	ldr	r3, [pc, #348]	@ (8011868 <AesDecrypt_C+0xc2c>)
 801170c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011710:	69fb      	ldr	r3, [r7, #28]
 8011712:	0c1b      	lsrs	r3, r3, #16
 8011714:	b2db      	uxtb	r3, r3
 8011716:	4954      	ldr	r1, [pc, #336]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011718:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801171c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011720:	405a      	eors	r2, r3
 8011722:	6a3b      	ldr	r3, [r7, #32]
 8011724:	0a1b      	lsrs	r3, r3, #8
 8011726:	b2db      	uxtb	r3, r3
 8011728:	494f      	ldr	r1, [pc, #316]	@ (8011868 <AesDecrypt_C+0xc2c>)
 801172a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801172e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011732:	405a      	eors	r2, r3
 8011734:	697b      	ldr	r3, [r7, #20]
 8011736:	b2db      	uxtb	r3, r3
 8011738:	494b      	ldr	r1, [pc, #300]	@ (8011868 <AesDecrypt_C+0xc2c>)
 801173a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801173e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011742:	405a      	eors	r2, r3
 8011744:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011746:	3398      	adds	r3, #152	@ 0x98
 8011748:	681b      	ldr	r3, [r3, #0]
 801174a:	4053      	eors	r3, r2
 801174c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801174e:	697b      	ldr	r3, [r7, #20]
 8011750:	0e1b      	lsrs	r3, r3, #24
 8011752:	b2db      	uxtb	r3, r3
 8011754:	461a      	mov	r2, r3
 8011756:	4b44      	ldr	r3, [pc, #272]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011758:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801175c:	69bb      	ldr	r3, [r7, #24]
 801175e:	0c1b      	lsrs	r3, r3, #16
 8011760:	b2db      	uxtb	r3, r3
 8011762:	4941      	ldr	r1, [pc, #260]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011764:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011768:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801176c:	405a      	eors	r2, r3
 801176e:	69fb      	ldr	r3, [r7, #28]
 8011770:	0a1b      	lsrs	r3, r3, #8
 8011772:	b2db      	uxtb	r3, r3
 8011774:	493c      	ldr	r1, [pc, #240]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011776:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801177a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801177e:	405a      	eors	r2, r3
 8011780:	6a3b      	ldr	r3, [r7, #32]
 8011782:	b2db      	uxtb	r3, r3
 8011784:	4938      	ldr	r1, [pc, #224]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011786:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801178a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801178e:	405a      	eors	r2, r3
 8011790:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011792:	339c      	adds	r3, #156	@ 0x9c
 8011794:	681b      	ldr	r3, [r3, #0]
 8011796:	4053      	eors	r3, r2
 8011798:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (r > 5) {
 801179a:	683b      	ldr	r3, [r7, #0]
 801179c:	2b05      	cmp	r3, #5
 801179e:	f240 826a 	bls.w	8011c76 <AesDecrypt_C+0x103a>
        DEC_ROUND_S_T(40); DEC_ROUND_T_S(40);
 80117a2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80117a4:	0e1b      	lsrs	r3, r3, #24
 80117a6:	b2db      	uxtb	r3, r3
 80117a8:	461a      	mov	r2, r3
 80117aa:	4b2f      	ldr	r3, [pc, #188]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80117ac:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80117b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80117b2:	0c1b      	lsrs	r3, r3, #16
 80117b4:	b2db      	uxtb	r3, r3
 80117b6:	492c      	ldr	r1, [pc, #176]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80117b8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80117bc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117c0:	405a      	eors	r2, r3
 80117c2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80117c4:	0a1b      	lsrs	r3, r3, #8
 80117c6:	b2db      	uxtb	r3, r3
 80117c8:	4927      	ldr	r1, [pc, #156]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80117ca:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80117ce:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117d2:	405a      	eors	r2, r3
 80117d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80117d6:	b2db      	uxtb	r3, r3
 80117d8:	4923      	ldr	r1, [pc, #140]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80117da:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80117de:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117e2:	405a      	eors	r2, r3
 80117e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80117e6:	33a0      	adds	r3, #160	@ 0xa0
 80117e8:	681b      	ldr	r3, [r3, #0]
 80117ea:	4053      	eors	r3, r2
 80117ec:	623b      	str	r3, [r7, #32]
 80117ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80117f0:	0e1b      	lsrs	r3, r3, #24
 80117f2:	b2db      	uxtb	r3, r3
 80117f4:	461a      	mov	r2, r3
 80117f6:	4b1c      	ldr	r3, [pc, #112]	@ (8011868 <AesDecrypt_C+0xc2c>)
 80117f8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80117fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80117fe:	0c1b      	lsrs	r3, r3, #16
 8011800:	b2db      	uxtb	r3, r3
 8011802:	4919      	ldr	r1, [pc, #100]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011804:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011808:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801180c:	405a      	eors	r2, r3
 801180e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011810:	0a1b      	lsrs	r3, r3, #8
 8011812:	b2db      	uxtb	r3, r3
 8011814:	4914      	ldr	r1, [pc, #80]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011816:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801181a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801181e:	405a      	eors	r2, r3
 8011820:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011822:	b2db      	uxtb	r3, r3
 8011824:	4910      	ldr	r1, [pc, #64]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011826:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801182a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801182e:	405a      	eors	r2, r3
 8011830:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011832:	33a4      	adds	r3, #164	@ 0xa4
 8011834:	681b      	ldr	r3, [r3, #0]
 8011836:	4053      	eors	r3, r2
 8011838:	61fb      	str	r3, [r7, #28]
 801183a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801183c:	0e1b      	lsrs	r3, r3, #24
 801183e:	b2db      	uxtb	r3, r3
 8011840:	461a      	mov	r2, r3
 8011842:	4b09      	ldr	r3, [pc, #36]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011844:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011848:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801184a:	0c1b      	lsrs	r3, r3, #16
 801184c:	b2db      	uxtb	r3, r3
 801184e:	4906      	ldr	r1, [pc, #24]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011850:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011854:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011858:	405a      	eors	r2, r3
 801185a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801185c:	0a1b      	lsrs	r3, r3, #8
 801185e:	b2db      	uxtb	r3, r3
 8011860:	4901      	ldr	r1, [pc, #4]	@ (8011868 <AesDecrypt_C+0xc2c>)
 8011862:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011866:	e001      	b.n	801186c <AesDecrypt_C+0xc30>
 8011868:	08033284 	.word	0x08033284
 801186c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011870:	405a      	eors	r2, r3
 8011872:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011874:	b2db      	uxtb	r3, r3
 8011876:	49b6      	ldr	r1, [pc, #728]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011878:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801187c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011880:	405a      	eors	r2, r3
 8011882:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011884:	33a8      	adds	r3, #168	@ 0xa8
 8011886:	681b      	ldr	r3, [r3, #0]
 8011888:	4053      	eors	r3, r2
 801188a:	61bb      	str	r3, [r7, #24]
 801188c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801188e:	0e1b      	lsrs	r3, r3, #24
 8011890:	b2db      	uxtb	r3, r3
 8011892:	461a      	mov	r2, r3
 8011894:	4bae      	ldr	r3, [pc, #696]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011896:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801189a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801189c:	0c1b      	lsrs	r3, r3, #16
 801189e:	b2db      	uxtb	r3, r3
 80118a0:	49ab      	ldr	r1, [pc, #684]	@ (8011b50 <AesDecrypt_C+0xf14>)
 80118a2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80118a6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80118aa:	405a      	eors	r2, r3
 80118ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80118ae:	0a1b      	lsrs	r3, r3, #8
 80118b0:	b2db      	uxtb	r3, r3
 80118b2:	49a7      	ldr	r1, [pc, #668]	@ (8011b50 <AesDecrypt_C+0xf14>)
 80118b4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80118b8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80118bc:	405a      	eors	r2, r3
 80118be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80118c0:	b2db      	uxtb	r3, r3
 80118c2:	49a3      	ldr	r1, [pc, #652]	@ (8011b50 <AesDecrypt_C+0xf14>)
 80118c4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80118c8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80118cc:	405a      	eors	r2, r3
 80118ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80118d0:	33ac      	adds	r3, #172	@ 0xac
 80118d2:	681b      	ldr	r3, [r3, #0]
 80118d4:	4053      	eors	r3, r2
 80118d6:	617b      	str	r3, [r7, #20]
 80118d8:	6a3b      	ldr	r3, [r7, #32]
 80118da:	0e1b      	lsrs	r3, r3, #24
 80118dc:	b2db      	uxtb	r3, r3
 80118de:	461a      	mov	r2, r3
 80118e0:	4b9b      	ldr	r3, [pc, #620]	@ (8011b50 <AesDecrypt_C+0xf14>)
 80118e2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80118e6:	697b      	ldr	r3, [r7, #20]
 80118e8:	0c1b      	lsrs	r3, r3, #16
 80118ea:	b2db      	uxtb	r3, r3
 80118ec:	4998      	ldr	r1, [pc, #608]	@ (8011b50 <AesDecrypt_C+0xf14>)
 80118ee:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80118f2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80118f6:	405a      	eors	r2, r3
 80118f8:	69bb      	ldr	r3, [r7, #24]
 80118fa:	0a1b      	lsrs	r3, r3, #8
 80118fc:	b2db      	uxtb	r3, r3
 80118fe:	4994      	ldr	r1, [pc, #592]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011900:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011904:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011908:	405a      	eors	r2, r3
 801190a:	69fb      	ldr	r3, [r7, #28]
 801190c:	b2db      	uxtb	r3, r3
 801190e:	4990      	ldr	r1, [pc, #576]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011910:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011914:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011918:	405a      	eors	r2, r3
 801191a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801191c:	33b0      	adds	r3, #176	@ 0xb0
 801191e:	681b      	ldr	r3, [r3, #0]
 8011920:	4053      	eors	r3, r2
 8011922:	637b      	str	r3, [r7, #52]	@ 0x34
 8011924:	69fb      	ldr	r3, [r7, #28]
 8011926:	0e1b      	lsrs	r3, r3, #24
 8011928:	b2db      	uxtb	r3, r3
 801192a:	461a      	mov	r2, r3
 801192c:	4b88      	ldr	r3, [pc, #544]	@ (8011b50 <AesDecrypt_C+0xf14>)
 801192e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011932:	6a3b      	ldr	r3, [r7, #32]
 8011934:	0c1b      	lsrs	r3, r3, #16
 8011936:	b2db      	uxtb	r3, r3
 8011938:	4985      	ldr	r1, [pc, #532]	@ (8011b50 <AesDecrypt_C+0xf14>)
 801193a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801193e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011942:	405a      	eors	r2, r3
 8011944:	697b      	ldr	r3, [r7, #20]
 8011946:	0a1b      	lsrs	r3, r3, #8
 8011948:	b2db      	uxtb	r3, r3
 801194a:	4981      	ldr	r1, [pc, #516]	@ (8011b50 <AesDecrypt_C+0xf14>)
 801194c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011950:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011954:	405a      	eors	r2, r3
 8011956:	69bb      	ldr	r3, [r7, #24]
 8011958:	b2db      	uxtb	r3, r3
 801195a:	497d      	ldr	r1, [pc, #500]	@ (8011b50 <AesDecrypt_C+0xf14>)
 801195c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011960:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011964:	405a      	eors	r2, r3
 8011966:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011968:	33b4      	adds	r3, #180	@ 0xb4
 801196a:	681b      	ldr	r3, [r3, #0]
 801196c:	4053      	eors	r3, r2
 801196e:	633b      	str	r3, [r7, #48]	@ 0x30
 8011970:	69bb      	ldr	r3, [r7, #24]
 8011972:	0e1b      	lsrs	r3, r3, #24
 8011974:	b2db      	uxtb	r3, r3
 8011976:	461a      	mov	r2, r3
 8011978:	4b75      	ldr	r3, [pc, #468]	@ (8011b50 <AesDecrypt_C+0xf14>)
 801197a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801197e:	69fb      	ldr	r3, [r7, #28]
 8011980:	0c1b      	lsrs	r3, r3, #16
 8011982:	b2db      	uxtb	r3, r3
 8011984:	4972      	ldr	r1, [pc, #456]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011986:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801198a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801198e:	405a      	eors	r2, r3
 8011990:	6a3b      	ldr	r3, [r7, #32]
 8011992:	0a1b      	lsrs	r3, r3, #8
 8011994:	b2db      	uxtb	r3, r3
 8011996:	496e      	ldr	r1, [pc, #440]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011998:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801199c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119a0:	405a      	eors	r2, r3
 80119a2:	697b      	ldr	r3, [r7, #20]
 80119a4:	b2db      	uxtb	r3, r3
 80119a6:	496a      	ldr	r1, [pc, #424]	@ (8011b50 <AesDecrypt_C+0xf14>)
 80119a8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80119ac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119b0:	405a      	eors	r2, r3
 80119b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80119b4:	33b8      	adds	r3, #184	@ 0xb8
 80119b6:	681b      	ldr	r3, [r3, #0]
 80119b8:	4053      	eors	r3, r2
 80119ba:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80119bc:	697b      	ldr	r3, [r7, #20]
 80119be:	0e1b      	lsrs	r3, r3, #24
 80119c0:	b2db      	uxtb	r3, r3
 80119c2:	461a      	mov	r2, r3
 80119c4:	4b62      	ldr	r3, [pc, #392]	@ (8011b50 <AesDecrypt_C+0xf14>)
 80119c6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80119ca:	69bb      	ldr	r3, [r7, #24]
 80119cc:	0c1b      	lsrs	r3, r3, #16
 80119ce:	b2db      	uxtb	r3, r3
 80119d0:	495f      	ldr	r1, [pc, #380]	@ (8011b50 <AesDecrypt_C+0xf14>)
 80119d2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80119d6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119da:	405a      	eors	r2, r3
 80119dc:	69fb      	ldr	r3, [r7, #28]
 80119de:	0a1b      	lsrs	r3, r3, #8
 80119e0:	b2db      	uxtb	r3, r3
 80119e2:	495b      	ldr	r1, [pc, #364]	@ (8011b50 <AesDecrypt_C+0xf14>)
 80119e4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80119e8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119ec:	405a      	eors	r2, r3
 80119ee:	6a3b      	ldr	r3, [r7, #32]
 80119f0:	b2db      	uxtb	r3, r3
 80119f2:	4957      	ldr	r1, [pc, #348]	@ (8011b50 <AesDecrypt_C+0xf14>)
 80119f4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80119f8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119fc:	405a      	eors	r2, r3
 80119fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011a00:	33bc      	adds	r3, #188	@ 0xbc
 8011a02:	681b      	ldr	r3, [r3, #0]
 8011a04:	4053      	eors	r3, r2
 8011a06:	62bb      	str	r3, [r7, #40]	@ 0x28
        if (r > 6) {
 8011a08:	683b      	ldr	r3, [r7, #0]
 8011a0a:	2b06      	cmp	r3, #6
 8011a0c:	f240 8133 	bls.w	8011c76 <AesDecrypt_C+0x103a>
            DEC_ROUND_S_T(48); DEC_ROUND_T_S(48);
 8011a10:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011a12:	0e1b      	lsrs	r3, r3, #24
 8011a14:	b2db      	uxtb	r3, r3
 8011a16:	461a      	mov	r2, r3
 8011a18:	4b4d      	ldr	r3, [pc, #308]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011a1a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011a1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011a20:	0c1b      	lsrs	r3, r3, #16
 8011a22:	b2db      	uxtb	r3, r3
 8011a24:	494a      	ldr	r1, [pc, #296]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011a26:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011a2a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a2e:	405a      	eors	r2, r3
 8011a30:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011a32:	0a1b      	lsrs	r3, r3, #8
 8011a34:	b2db      	uxtb	r3, r3
 8011a36:	4946      	ldr	r1, [pc, #280]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011a38:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011a3c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a40:	405a      	eors	r2, r3
 8011a42:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011a44:	b2db      	uxtb	r3, r3
 8011a46:	4942      	ldr	r1, [pc, #264]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011a48:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011a4c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a50:	405a      	eors	r2, r3
 8011a52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011a54:	33c0      	adds	r3, #192	@ 0xc0
 8011a56:	681b      	ldr	r3, [r3, #0]
 8011a58:	4053      	eors	r3, r2
 8011a5a:	623b      	str	r3, [r7, #32]
 8011a5c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011a5e:	0e1b      	lsrs	r3, r3, #24
 8011a60:	b2db      	uxtb	r3, r3
 8011a62:	461a      	mov	r2, r3
 8011a64:	4b3a      	ldr	r3, [pc, #232]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011a66:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011a6a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011a6c:	0c1b      	lsrs	r3, r3, #16
 8011a6e:	b2db      	uxtb	r3, r3
 8011a70:	4937      	ldr	r1, [pc, #220]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011a72:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011a76:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a7a:	405a      	eors	r2, r3
 8011a7c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011a7e:	0a1b      	lsrs	r3, r3, #8
 8011a80:	b2db      	uxtb	r3, r3
 8011a82:	4933      	ldr	r1, [pc, #204]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011a84:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011a88:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a8c:	405a      	eors	r2, r3
 8011a8e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011a90:	b2db      	uxtb	r3, r3
 8011a92:	492f      	ldr	r1, [pc, #188]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011a94:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011a98:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a9c:	405a      	eors	r2, r3
 8011a9e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011aa0:	33c4      	adds	r3, #196	@ 0xc4
 8011aa2:	681b      	ldr	r3, [r3, #0]
 8011aa4:	4053      	eors	r3, r2
 8011aa6:	61fb      	str	r3, [r7, #28]
 8011aa8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011aaa:	0e1b      	lsrs	r3, r3, #24
 8011aac:	b2db      	uxtb	r3, r3
 8011aae:	461a      	mov	r2, r3
 8011ab0:	4b27      	ldr	r3, [pc, #156]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011ab2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011ab6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011ab8:	0c1b      	lsrs	r3, r3, #16
 8011aba:	b2db      	uxtb	r3, r3
 8011abc:	4924      	ldr	r1, [pc, #144]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011abe:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011ac2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011ac6:	405a      	eors	r2, r3
 8011ac8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011aca:	0a1b      	lsrs	r3, r3, #8
 8011acc:	b2db      	uxtb	r3, r3
 8011ace:	4920      	ldr	r1, [pc, #128]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011ad0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011ad4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011ad8:	405a      	eors	r2, r3
 8011ada:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011adc:	b2db      	uxtb	r3, r3
 8011ade:	491c      	ldr	r1, [pc, #112]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011ae0:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011ae4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011ae8:	405a      	eors	r2, r3
 8011aea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011aec:	33c8      	adds	r3, #200	@ 0xc8
 8011aee:	681b      	ldr	r3, [r3, #0]
 8011af0:	4053      	eors	r3, r2
 8011af2:	61bb      	str	r3, [r7, #24]
 8011af4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011af6:	0e1b      	lsrs	r3, r3, #24
 8011af8:	b2db      	uxtb	r3, r3
 8011afa:	461a      	mov	r2, r3
 8011afc:	4b14      	ldr	r3, [pc, #80]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011afe:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011b02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011b04:	0c1b      	lsrs	r3, r3, #16
 8011b06:	b2db      	uxtb	r3, r3
 8011b08:	4911      	ldr	r1, [pc, #68]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011b0a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011b0e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011b12:	405a      	eors	r2, r3
 8011b14:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011b16:	0a1b      	lsrs	r3, r3, #8
 8011b18:	b2db      	uxtb	r3, r3
 8011b1a:	490d      	ldr	r1, [pc, #52]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011b1c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011b20:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011b24:	405a      	eors	r2, r3
 8011b26:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011b28:	b2db      	uxtb	r3, r3
 8011b2a:	4909      	ldr	r1, [pc, #36]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011b2c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011b30:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011b34:	405a      	eors	r2, r3
 8011b36:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b38:	33cc      	adds	r3, #204	@ 0xcc
 8011b3a:	681b      	ldr	r3, [r3, #0]
 8011b3c:	4053      	eors	r3, r2
 8011b3e:	617b      	str	r3, [r7, #20]
 8011b40:	6a3b      	ldr	r3, [r7, #32]
 8011b42:	0e1b      	lsrs	r3, r3, #24
 8011b44:	b2db      	uxtb	r3, r3
 8011b46:	461a      	mov	r2, r3
 8011b48:	4b01      	ldr	r3, [pc, #4]	@ (8011b50 <AesDecrypt_C+0xf14>)
 8011b4a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011b4e:	e001      	b.n	8011b54 <AesDecrypt_C+0xf18>
 8011b50:	08033284 	.word	0x08033284
 8011b54:	697b      	ldr	r3, [r7, #20]
 8011b56:	0c1b      	lsrs	r3, r3, #16
 8011b58:	b2db      	uxtb	r3, r3
 8011b5a:	49a5      	ldr	r1, [pc, #660]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011b5c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011b60:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011b64:	405a      	eors	r2, r3
 8011b66:	69bb      	ldr	r3, [r7, #24]
 8011b68:	0a1b      	lsrs	r3, r3, #8
 8011b6a:	b2db      	uxtb	r3, r3
 8011b6c:	49a0      	ldr	r1, [pc, #640]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011b6e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011b72:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011b76:	405a      	eors	r2, r3
 8011b78:	69fb      	ldr	r3, [r7, #28]
 8011b7a:	b2db      	uxtb	r3, r3
 8011b7c:	499c      	ldr	r1, [pc, #624]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011b7e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011b82:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011b86:	405a      	eors	r2, r3
 8011b88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b8a:	33d0      	adds	r3, #208	@ 0xd0
 8011b8c:	681b      	ldr	r3, [r3, #0]
 8011b8e:	4053      	eors	r3, r2
 8011b90:	637b      	str	r3, [r7, #52]	@ 0x34
 8011b92:	69fb      	ldr	r3, [r7, #28]
 8011b94:	0e1b      	lsrs	r3, r3, #24
 8011b96:	b2db      	uxtb	r3, r3
 8011b98:	461a      	mov	r2, r3
 8011b9a:	4b95      	ldr	r3, [pc, #596]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011b9c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011ba0:	6a3b      	ldr	r3, [r7, #32]
 8011ba2:	0c1b      	lsrs	r3, r3, #16
 8011ba4:	b2db      	uxtb	r3, r3
 8011ba6:	4992      	ldr	r1, [pc, #584]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011ba8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011bac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011bb0:	405a      	eors	r2, r3
 8011bb2:	697b      	ldr	r3, [r7, #20]
 8011bb4:	0a1b      	lsrs	r3, r3, #8
 8011bb6:	b2db      	uxtb	r3, r3
 8011bb8:	498d      	ldr	r1, [pc, #564]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011bba:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011bbe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011bc2:	405a      	eors	r2, r3
 8011bc4:	69bb      	ldr	r3, [r7, #24]
 8011bc6:	b2db      	uxtb	r3, r3
 8011bc8:	4989      	ldr	r1, [pc, #548]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011bca:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011bce:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011bd2:	405a      	eors	r2, r3
 8011bd4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011bd6:	33d4      	adds	r3, #212	@ 0xd4
 8011bd8:	681b      	ldr	r3, [r3, #0]
 8011bda:	4053      	eors	r3, r2
 8011bdc:	633b      	str	r3, [r7, #48]	@ 0x30
 8011bde:	69bb      	ldr	r3, [r7, #24]
 8011be0:	0e1b      	lsrs	r3, r3, #24
 8011be2:	b2db      	uxtb	r3, r3
 8011be4:	461a      	mov	r2, r3
 8011be6:	4b82      	ldr	r3, [pc, #520]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011be8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011bec:	69fb      	ldr	r3, [r7, #28]
 8011bee:	0c1b      	lsrs	r3, r3, #16
 8011bf0:	b2db      	uxtb	r3, r3
 8011bf2:	497f      	ldr	r1, [pc, #508]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011bf4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011bf8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011bfc:	405a      	eors	r2, r3
 8011bfe:	6a3b      	ldr	r3, [r7, #32]
 8011c00:	0a1b      	lsrs	r3, r3, #8
 8011c02:	b2db      	uxtb	r3, r3
 8011c04:	497a      	ldr	r1, [pc, #488]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011c06:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011c0a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011c0e:	405a      	eors	r2, r3
 8011c10:	697b      	ldr	r3, [r7, #20]
 8011c12:	b2db      	uxtb	r3, r3
 8011c14:	4976      	ldr	r1, [pc, #472]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011c16:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011c1a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011c1e:	405a      	eors	r2, r3
 8011c20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011c22:	33d8      	adds	r3, #216	@ 0xd8
 8011c24:	681b      	ldr	r3, [r3, #0]
 8011c26:	4053      	eors	r3, r2
 8011c28:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011c2a:	697b      	ldr	r3, [r7, #20]
 8011c2c:	0e1b      	lsrs	r3, r3, #24
 8011c2e:	b2db      	uxtb	r3, r3
 8011c30:	461a      	mov	r2, r3
 8011c32:	4b6f      	ldr	r3, [pc, #444]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011c34:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011c38:	69bb      	ldr	r3, [r7, #24]
 8011c3a:	0c1b      	lsrs	r3, r3, #16
 8011c3c:	b2db      	uxtb	r3, r3
 8011c3e:	496c      	ldr	r1, [pc, #432]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011c40:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011c44:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011c48:	405a      	eors	r2, r3
 8011c4a:	69fb      	ldr	r3, [r7, #28]
 8011c4c:	0a1b      	lsrs	r3, r3, #8
 8011c4e:	b2db      	uxtb	r3, r3
 8011c50:	4967      	ldr	r1, [pc, #412]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011c52:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011c56:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011c5a:	405a      	eors	r2, r3
 8011c5c:	6a3b      	ldr	r3, [r7, #32]
 8011c5e:	b2db      	uxtb	r3, r3
 8011c60:	4963      	ldr	r1, [pc, #396]	@ (8011df0 <AesDecrypt_C+0x11b4>)
 8011c62:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011c66:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011c6a:	405a      	eors	r2, r3
 8011c6c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011c6e:	33dc      	adds	r3, #220	@ 0xdc
 8011c70:	681b      	ldr	r3, [r3, #0]
 8011c72:	4053      	eors	r3, r2
 8011c74:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
    rk += r * 8;
 8011c76:	683b      	ldr	r3, [r7, #0]
 8011c78:	015b      	lsls	r3, r3, #5
 8011c7a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011c7c:	4413      	add	r3, r2
 8011c7e:	627b      	str	r3, [r7, #36]	@ 0x24
     * apply last round and
     * map cipher state to byte array block:
     */

#ifndef WC_NO_CACHE_RESISTANT
    t0 |= PreFetchTd4();
 8011c80:	f7fe ffbc 	bl	8010bfc <PreFetchTd4>
 8011c84:	4602      	mov	r2, r0
 8011c86:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011c88:	4313      	orrs	r3, r2
 8011c8a:	637b      	str	r3, [r7, #52]	@ 0x34
#endif

    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 8011c8c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011c8e:	0e1b      	lsrs	r3, r3, #24
 8011c90:	b2db      	uxtb	r3, r3
 8011c92:	461a      	mov	r2, r3
 8011c94:	4b57      	ldr	r3, [pc, #348]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011c96:	5c9b      	ldrb	r3, [r3, r2]
 8011c98:	061a      	lsls	r2, r3, #24
 8011c9a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011c9c:	0c1b      	lsrs	r3, r3, #16
 8011c9e:	b2db      	uxtb	r3, r3
 8011ca0:	4619      	mov	r1, r3
 8011ca2:	4b54      	ldr	r3, [pc, #336]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011ca4:	5c5b      	ldrb	r3, [r3, r1]
 8011ca6:	041b      	lsls	r3, r3, #16
 8011ca8:	431a      	orrs	r2, r3
 8011caa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011cac:	0a1b      	lsrs	r3, r3, #8
 8011cae:	b2db      	uxtb	r3, r3
 8011cb0:	4619      	mov	r1, r3
 8011cb2:	4b50      	ldr	r3, [pc, #320]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011cb4:	5c5b      	ldrb	r3, [r3, r1]
 8011cb6:	021b      	lsls	r3, r3, #8
 8011cb8:	4313      	orrs	r3, r2
 8011cba:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011cbc:	b2d2      	uxtb	r2, r2
 8011cbe:	4611      	mov	r1, r2
 8011cc0:	4a4c      	ldr	r2, [pc, #304]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011cc2:	5c52      	ldrb	r2, [r2, r1]
 8011cc4:	431a      	orrs	r2, r3
                          GETBYTE(t2, 1), GETBYTE(t1, 0)) ^ rk[0];
 8011cc6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011cc8:	681b      	ldr	r3, [r3, #0]
 8011cca:	4053      	eors	r3, r2
    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 8011ccc:	623b      	str	r3, [r7, #32]
    s1 = GetTable8_4(Td4, GETBYTE(t1, 3), GETBYTE(t0, 2),
 8011cce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011cd0:	0e1b      	lsrs	r3, r3, #24
 8011cd2:	b2db      	uxtb	r3, r3
 8011cd4:	461a      	mov	r2, r3
 8011cd6:	4b47      	ldr	r3, [pc, #284]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011cd8:	5c9b      	ldrb	r3, [r3, r2]
 8011cda:	061a      	lsls	r2, r3, #24
 8011cdc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011cde:	0c1b      	lsrs	r3, r3, #16
 8011ce0:	b2db      	uxtb	r3, r3
 8011ce2:	4619      	mov	r1, r3
 8011ce4:	4b43      	ldr	r3, [pc, #268]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011ce6:	5c5b      	ldrb	r3, [r3, r1]
 8011ce8:	041b      	lsls	r3, r3, #16
 8011cea:	431a      	orrs	r2, r3
 8011cec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011cee:	0a1b      	lsrs	r3, r3, #8
 8011cf0:	b2db      	uxtb	r3, r3
 8011cf2:	4619      	mov	r1, r3
 8011cf4:	4b3f      	ldr	r3, [pc, #252]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011cf6:	5c5b      	ldrb	r3, [r3, r1]
 8011cf8:	021b      	lsls	r3, r3, #8
 8011cfa:	4313      	orrs	r3, r2
 8011cfc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011cfe:	b2d2      	uxtb	r2, r2
 8011d00:	4611      	mov	r1, r2
 8011d02:	4a3c      	ldr	r2, [pc, #240]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011d04:	5c52      	ldrb	r2, [r2, r1]
 8011d06:	431a      	orrs	r2, r3
                          GETBYTE(t3, 1), GETBYTE(t2, 0)) ^ rk[1];
 8011d08:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011d0a:	3304      	adds	r3, #4
 8011d0c:	681b      	ldr	r3, [r3, #0]
 8011d0e:	4053      	eors	r3, r2
    s1 = GetTable8_4(Td4, GETBYTE(t1, 3), GETBYTE(t0, 2),
 8011d10:	61fb      	str	r3, [r7, #28]
    s2 = GetTable8_4(Td4, GETBYTE(t2, 3), GETBYTE(t1, 2),
 8011d12:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011d14:	0e1b      	lsrs	r3, r3, #24
 8011d16:	b2db      	uxtb	r3, r3
 8011d18:	461a      	mov	r2, r3
 8011d1a:	4b36      	ldr	r3, [pc, #216]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011d1c:	5c9b      	ldrb	r3, [r3, r2]
 8011d1e:	061a      	lsls	r2, r3, #24
 8011d20:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011d22:	0c1b      	lsrs	r3, r3, #16
 8011d24:	b2db      	uxtb	r3, r3
 8011d26:	4619      	mov	r1, r3
 8011d28:	4b32      	ldr	r3, [pc, #200]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011d2a:	5c5b      	ldrb	r3, [r3, r1]
 8011d2c:	041b      	lsls	r3, r3, #16
 8011d2e:	431a      	orrs	r2, r3
 8011d30:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011d32:	0a1b      	lsrs	r3, r3, #8
 8011d34:	b2db      	uxtb	r3, r3
 8011d36:	4619      	mov	r1, r3
 8011d38:	4b2e      	ldr	r3, [pc, #184]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011d3a:	5c5b      	ldrb	r3, [r3, r1]
 8011d3c:	021b      	lsls	r3, r3, #8
 8011d3e:	4313      	orrs	r3, r2
 8011d40:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011d42:	b2d2      	uxtb	r2, r2
 8011d44:	4611      	mov	r1, r2
 8011d46:	4a2b      	ldr	r2, [pc, #172]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011d48:	5c52      	ldrb	r2, [r2, r1]
 8011d4a:	431a      	orrs	r2, r3
                          GETBYTE(t0, 1), GETBYTE(t3, 0)) ^ rk[2];
 8011d4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011d4e:	3308      	adds	r3, #8
 8011d50:	681b      	ldr	r3, [r3, #0]
 8011d52:	4053      	eors	r3, r2
    s2 = GetTable8_4(Td4, GETBYTE(t2, 3), GETBYTE(t1, 2),
 8011d54:	61bb      	str	r3, [r7, #24]
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 8011d56:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011d58:	0e1b      	lsrs	r3, r3, #24
 8011d5a:	b2db      	uxtb	r3, r3
 8011d5c:	461a      	mov	r2, r3
 8011d5e:	4b25      	ldr	r3, [pc, #148]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011d60:	5c9b      	ldrb	r3, [r3, r2]
 8011d62:	061a      	lsls	r2, r3, #24
 8011d64:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011d66:	0c1b      	lsrs	r3, r3, #16
 8011d68:	b2db      	uxtb	r3, r3
 8011d6a:	4619      	mov	r1, r3
 8011d6c:	4b21      	ldr	r3, [pc, #132]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011d6e:	5c5b      	ldrb	r3, [r3, r1]
 8011d70:	041b      	lsls	r3, r3, #16
 8011d72:	431a      	orrs	r2, r3
 8011d74:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011d76:	0a1b      	lsrs	r3, r3, #8
 8011d78:	b2db      	uxtb	r3, r3
 8011d7a:	4619      	mov	r1, r3
 8011d7c:	4b1d      	ldr	r3, [pc, #116]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011d7e:	5c5b      	ldrb	r3, [r3, r1]
 8011d80:	021b      	lsls	r3, r3, #8
 8011d82:	4313      	orrs	r3, r2
 8011d84:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011d86:	b2d2      	uxtb	r2, r2
 8011d88:	4611      	mov	r1, r2
 8011d8a:	4a1a      	ldr	r2, [pc, #104]	@ (8011df4 <AesDecrypt_C+0x11b8>)
 8011d8c:	5c52      	ldrb	r2, [r2, r1]
 8011d8e:	431a      	orrs	r2, r3
                          GETBYTE(t1, 1), GETBYTE(t0, 0)) ^ rk[3];
 8011d90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011d92:	330c      	adds	r3, #12
 8011d94:	681b      	ldr	r3, [r3, #0]
 8011d96:	4053      	eors	r3, r2
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 8011d98:	617b      	str	r3, [r7, #20]
    s3 = t3 ^ rk[3];
#endif

    /* write out */
#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 8011d9a:	6a3b      	ldr	r3, [r7, #32]
 8011d9c:	4618      	mov	r0, r3
 8011d9e:	f7fd fcdc 	bl	800f75a <ByteReverseWord32>
 8011da2:	4603      	mov	r3, r0
 8011da4:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 8011da6:	69fb      	ldr	r3, [r7, #28]
 8011da8:	4618      	mov	r0, r3
 8011daa:	f7fd fcd6 	bl	800f75a <ByteReverseWord32>
 8011dae:	4603      	mov	r3, r0
 8011db0:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 8011db2:	69bb      	ldr	r3, [r7, #24]
 8011db4:	4618      	mov	r0, r3
 8011db6:	f7fd fcd0 	bl	800f75a <ByteReverseWord32>
 8011dba:	4603      	mov	r3, r0
 8011dbc:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 8011dbe:	697b      	ldr	r3, [r7, #20]
 8011dc0:	4618      	mov	r0, r3
 8011dc2:	f7fd fcca 	bl	800f75a <ByteReverseWord32>
 8011dc6:	4603      	mov	r3, r0
 8011dc8:	617b      	str	r3, [r7, #20]
#endif

    XMEMCPY(outBlock,                  &s0, sizeof(s0));
 8011dca:	6a3a      	ldr	r2, [r7, #32]
 8011dcc:	687b      	ldr	r3, [r7, #4]
 8011dce:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + sizeof(s0),     &s1, sizeof(s1));
 8011dd0:	687b      	ldr	r3, [r7, #4]
 8011dd2:	3304      	adds	r3, #4
 8011dd4:	69fa      	ldr	r2, [r7, #28]
 8011dd6:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 2 * sizeof(s0), &s2, sizeof(s2));
 8011dd8:	687b      	ldr	r3, [r7, #4]
 8011dda:	3308      	adds	r3, #8
 8011ddc:	69ba      	ldr	r2, [r7, #24]
 8011dde:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 3 * sizeof(s0), &s3, sizeof(s3));
 8011de0:	687b      	ldr	r3, [r7, #4]
 8011de2:	330c      	adds	r3, #12
 8011de4:	697a      	ldr	r2, [r7, #20]
 8011de6:	601a      	str	r2, [r3, #0]

}
 8011de8:	bf00      	nop
 8011dea:	3738      	adds	r7, #56	@ 0x38
 8011dec:	46bd      	mov	sp, r7
 8011dee:	bd80      	pop	{r7, pc}
 8011df0:	08033284 	.word	0x08033284
 8011df4:	08034284 	.word	0x08034284

08011df8 <wc_AesDecrypt>:

#if !defined(WC_AES_BITSLICED) || defined(WOLFSSL_AES_DIRECT)
/* Software AES - ECB Decrypt */
static WARN_UNUSED_RESULT int wc_AesDecrypt(
    Aes* aes, const byte* inBlock, byte* outBlock)
{
 8011df8:	b580      	push	{r7, lr}
 8011dfa:	b086      	sub	sp, #24
 8011dfc:	af00      	add	r7, sp, #0
 8011dfe:	60f8      	str	r0, [r7, #12]
 8011e00:	60b9      	str	r1, [r7, #8]
 8011e02:	607a      	str	r2, [r7, #4]
#if defined(MAX3266X_CB)
    int ret_cb;
#endif
    word32 r;

    if (aes == NULL) {
 8011e04:	68fb      	ldr	r3, [r7, #12]
 8011e06:	2b00      	cmp	r3, #0
 8011e08:	d102      	bne.n	8011e10 <wc_AesDecrypt+0x18>
        return BAD_FUNC_ARG;
 8011e0a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8011e0e:	e014      	b.n	8011e3a <wc_AesDecrypt+0x42>
        if (ret < 0)
            return ret;
    }
#endif

    r = aes->rounds >> 1;
 8011e10:	68fb      	ldr	r3, [r7, #12]
 8011e12:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011e16:	085b      	lsrs	r3, r3, #1
 8011e18:	617b      	str	r3, [r7, #20]

    if (r > 7 || r == 0) {
 8011e1a:	697b      	ldr	r3, [r7, #20]
 8011e1c:	2b07      	cmp	r3, #7
 8011e1e:	d802      	bhi.n	8011e26 <wc_AesDecrypt+0x2e>
 8011e20:	697b      	ldr	r3, [r7, #20]
 8011e22:	2b00      	cmp	r3, #0
 8011e24:	d102      	bne.n	8011e2c <wc_AesDecrypt+0x34>
        WOLFSSL_ERROR_VERBOSE(KEYUSAGE_E);
        return KEYUSAGE_E;
 8011e26:	f06f 03e1 	mvn.w	r3, #225	@ 0xe1
 8011e2a:	e006      	b.n	8011e3a <wc_AesDecrypt+0x42>
            return ret_cb;
        /* fall-through when unavailable */
    }
#endif

    AesDecrypt_C(aes, inBlock, outBlock, r);
 8011e2c:	697b      	ldr	r3, [r7, #20]
 8011e2e:	687a      	ldr	r2, [r7, #4]
 8011e30:	68b9      	ldr	r1, [r7, #8]
 8011e32:	68f8      	ldr	r0, [r7, #12]
 8011e34:	f7fe ff02 	bl	8010c3c <AesDecrypt_C>

    return 0;
 8011e38:	2300      	movs	r3, #0
} /* wc_AesDecrypt[_SW]() */
 8011e3a:	4618      	mov	r0, r3
 8011e3c:	3718      	adds	r7, #24
 8011e3e:	46bd      	mov	sp, r7
 8011e40:	bd80      	pop	{r7, pc}
	...

08011e44 <AesSetKey_C>:
 * @param [in]  key    Block to encrypt.
 * @param [in]  keySz  Number of bytes in key.
 * @param [in]  dir    Direction of crypt: AES_ENCRYPTION or AES_DECRYPTION.
 */
static void AesSetKey_C(Aes* aes, const byte* key, word32 keySz, int dir)
{
 8011e44:	b580      	push	{r7, lr}
 8011e46:	b088      	sub	sp, #32
 8011e48:	af00      	add	r7, sp, #0
 8011e4a:	60f8      	str	r0, [r7, #12]
 8011e4c:	60b9      	str	r1, [r7, #8]
 8011e4e:	607a      	str	r2, [r7, #4]
 8011e50:	603b      	str	r3, [r7, #0]
#ifdef WC_C_DYNAMIC_FALLBACK
    word32* rk = aes->key_C_fallback;
#else
    word32* rk = aes->key;
 8011e52:	68fb      	ldr	r3, [r7, #12]
 8011e54:	61fb      	str	r3, [r7, #28]
#endif
    word32 temp;
    unsigned int i = 0;
 8011e56:	2300      	movs	r3, #0
 8011e58:	61bb      	str	r3, [r7, #24]

    XMEMCPY(rk, key, keySz);
 8011e5a:	687a      	ldr	r2, [r7, #4]
 8011e5c:	68b9      	ldr	r1, [r7, #8]
 8011e5e:	69f8      	ldr	r0, [r7, #28]
 8011e60:	f016 ff91 	bl	8028d86 <memcpy>
#if defined(LITTLE_ENDIAN_ORDER) && !defined(WOLFSSL_PIC32MZ_CRYPT) && \
    (!defined(WOLFSSL_ESP32_CRYPT) || defined(NO_WOLFSSL_ESP32_CRYPT_AES)) && \
    !defined(MAX3266X_AES)
    /* Always reverse words when using only SW */
    {
        ByteReverseWords(rk, rk, keySz);
 8011e64:	687a      	ldr	r2, [r7, #4]
 8011e66:	69f9      	ldr	r1, [r7, #28]
 8011e68:	69f8      	ldr	r0, [r7, #28]
 8011e6a:	f7fd fc8d 	bl	800f788 <ByteReverseWords>
            /* If we don't need SW fallback, don't need to reverse words. */
        #endif /* NEED_AES_HW_FALLBACK */
    #endif /* WOLFSSL_ESPIDF */
#endif /* LITTLE_ENDIAN_ORDER, etc */

    switch (keySz) {
 8011e6e:	687b      	ldr	r3, [r7, #4]
 8011e70:	2b20      	cmp	r3, #32
 8011e72:	f000 80e5 	beq.w	8012040 <AesSetKey_C+0x1fc>
 8011e76:	687b      	ldr	r3, [r7, #4]
 8011e78:	2b20      	cmp	r3, #32
 8011e7a:	f200 8193 	bhi.w	80121a4 <AesSetKey_C+0x360>
 8011e7e:	687b      	ldr	r3, [r7, #4]
 8011e80:	2b10      	cmp	r3, #16
 8011e82:	d003      	beq.n	8011e8c <AesSetKey_C+0x48>
 8011e84:	687b      	ldr	r3, [r7, #4]
 8011e86:	2b18      	cmp	r3, #24
 8011e88:	d061      	beq.n	8011f4e <AesSetKey_C+0x10a>
 8011e8a:	e18b      	b.n	80121a4 <AesSetKey_C+0x360>
        temp = (word32)-1;
        wc_MemZero_Add("wc_AesSetKeyLocal temp", &temp, sizeof(temp));
    #endif
        while (1)
        {
            temp  = rk[3];
 8011e8c:	69fb      	ldr	r3, [r7, #28]
 8011e8e:	68db      	ldr	r3, [r3, #12]
 8011e90:	613b      	str	r3, [r7, #16]
            rk[4] = rk[0] ^
 8011e92:	69fb      	ldr	r3, [r7, #28]
 8011e94:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011e96:	693b      	ldr	r3, [r7, #16]
 8011e98:	0c1b      	lsrs	r3, r3, #16
 8011e9a:	b2db      	uxtb	r3, r3
 8011e9c:	4966      	ldr	r1, [pc, #408]	@ (8012038 <AesSetKey_C+0x1f4>)
 8011e9e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011ea2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011ea6:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[4] = rk[0] ^
 8011eaa:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011eac:	693b      	ldr	r3, [r7, #16]
 8011eae:	0a1b      	lsrs	r3, r3, #8
 8011eb0:	b2db      	uxtb	r3, r3
 8011eb2:	4961      	ldr	r1, [pc, #388]	@ (8012038 <AesSetKey_C+0x1f4>)
 8011eb4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011eb8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011ebc:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011ec0:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011ec2:	693b      	ldr	r3, [r7, #16]
 8011ec4:	b2db      	uxtb	r3, r3
 8011ec6:	4619      	mov	r1, r3
 8011ec8:	4b5b      	ldr	r3, [pc, #364]	@ (8012038 <AesSetKey_C+0x1f4>)
 8011eca:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8011ece:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011ed2:	405a      	eors	r2, r3
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011ed4:	693b      	ldr	r3, [r7, #16]
 8011ed6:	0e1b      	lsrs	r3, r3, #24
 8011ed8:	b2db      	uxtb	r3, r3
 8011eda:	4957      	ldr	r1, [pc, #348]	@ (8012038 <AesSetKey_C+0x1f4>)
 8011edc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011ee0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011ee4:	b2db      	uxtb	r3, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011ee6:	ea82 0103 	eor.w	r1, r2, r3
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3))) ^
        #endif
                rcon[i];
 8011eea:	4a54      	ldr	r2, [pc, #336]	@ (801203c <AesSetKey_C+0x1f8>)
 8011eec:	69bb      	ldr	r3, [r7, #24]
 8011eee:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[4] = rk[0] ^
 8011ef2:	69fb      	ldr	r3, [r7, #28]
 8011ef4:	3310      	adds	r3, #16
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011ef6:	404a      	eors	r2, r1
            rk[4] = rk[0] ^
 8011ef8:	601a      	str	r2, [r3, #0]
            rk[5] = rk[1] ^ rk[4];
 8011efa:	69fb      	ldr	r3, [r7, #28]
 8011efc:	3304      	adds	r3, #4
 8011efe:	6819      	ldr	r1, [r3, #0]
 8011f00:	69fb      	ldr	r3, [r7, #28]
 8011f02:	3310      	adds	r3, #16
 8011f04:	681a      	ldr	r2, [r3, #0]
 8011f06:	69fb      	ldr	r3, [r7, #28]
 8011f08:	3314      	adds	r3, #20
 8011f0a:	404a      	eors	r2, r1
 8011f0c:	601a      	str	r2, [r3, #0]
            rk[6] = rk[2] ^ rk[5];
 8011f0e:	69fb      	ldr	r3, [r7, #28]
 8011f10:	3308      	adds	r3, #8
 8011f12:	6819      	ldr	r1, [r3, #0]
 8011f14:	69fb      	ldr	r3, [r7, #28]
 8011f16:	3314      	adds	r3, #20
 8011f18:	681a      	ldr	r2, [r3, #0]
 8011f1a:	69fb      	ldr	r3, [r7, #28]
 8011f1c:	3318      	adds	r3, #24
 8011f1e:	404a      	eors	r2, r1
 8011f20:	601a      	str	r2, [r3, #0]
            rk[7] = rk[3] ^ rk[6];
 8011f22:	69fb      	ldr	r3, [r7, #28]
 8011f24:	330c      	adds	r3, #12
 8011f26:	6819      	ldr	r1, [r3, #0]
 8011f28:	69fb      	ldr	r3, [r7, #28]
 8011f2a:	3318      	adds	r3, #24
 8011f2c:	681a      	ldr	r2, [r3, #0]
 8011f2e:	69fb      	ldr	r3, [r7, #28]
 8011f30:	331c      	adds	r3, #28
 8011f32:	404a      	eors	r2, r1
 8011f34:	601a      	str	r2, [r3, #0]
            if (++i == 10)
 8011f36:	69bb      	ldr	r3, [r7, #24]
 8011f38:	3301      	adds	r3, #1
 8011f3a:	61bb      	str	r3, [r7, #24]
 8011f3c:	69bb      	ldr	r3, [r7, #24]
 8011f3e:	2b0a      	cmp	r3, #10
 8011f40:	d003      	beq.n	8011f4a <AesSetKey_C+0x106>
                break;
            rk += 4;
 8011f42:	69fb      	ldr	r3, [r7, #28]
 8011f44:	3310      	adds	r3, #16
 8011f46:	61fb      	str	r3, [r7, #28]
            temp  = rk[3];
 8011f48:	e7a0      	b.n	8011e8c <AesSetKey_C+0x48>
                break;
 8011f4a:	bf00      	nop
        }
        break;
 8011f4c:	e12a      	b.n	80121a4 <AesSetKey_C+0x360>
        wc_MemZero_Add("wc_AesSetKeyLocal temp", &temp, sizeof(temp));
    #endif
        /* for (;;) here triggers a bug in VC60 SP4 w/ Pro Pack */
        while (1)
        {
            temp = rk[ 5];
 8011f4e:	69fb      	ldr	r3, [r7, #28]
 8011f50:	695b      	ldr	r3, [r3, #20]
 8011f52:	613b      	str	r3, [r7, #16]
            rk[ 6] = rk[ 0] ^
 8011f54:	69fb      	ldr	r3, [r7, #28]
 8011f56:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011f58:	693b      	ldr	r3, [r7, #16]
 8011f5a:	0c1b      	lsrs	r3, r3, #16
 8011f5c:	b2db      	uxtb	r3, r3
 8011f5e:	4936      	ldr	r1, [pc, #216]	@ (8012038 <AesSetKey_C+0x1f4>)
 8011f60:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011f64:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011f68:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[ 6] = rk[ 0] ^
 8011f6c:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011f6e:	693b      	ldr	r3, [r7, #16]
 8011f70:	0a1b      	lsrs	r3, r3, #8
 8011f72:	b2db      	uxtb	r3, r3
 8011f74:	4930      	ldr	r1, [pc, #192]	@ (8012038 <AesSetKey_C+0x1f4>)
 8011f76:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011f7a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011f7e:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011f82:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011f84:	693b      	ldr	r3, [r7, #16]
 8011f86:	b2db      	uxtb	r3, r3
 8011f88:	4619      	mov	r1, r3
 8011f8a:	4b2b      	ldr	r3, [pc, #172]	@ (8012038 <AesSetKey_C+0x1f4>)
 8011f8c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8011f90:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011f94:	405a      	eors	r2, r3
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011f96:	693b      	ldr	r3, [r7, #16]
 8011f98:	0e1b      	lsrs	r3, r3, #24
 8011f9a:	b2db      	uxtb	r3, r3
 8011f9c:	4926      	ldr	r1, [pc, #152]	@ (8012038 <AesSetKey_C+0x1f4>)
 8011f9e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011fa2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011fa6:	b2db      	uxtb	r3, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011fa8:	ea82 0103 	eor.w	r1, r2, r3
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3))) ^
        #endif
                rcon[i];
 8011fac:	4a23      	ldr	r2, [pc, #140]	@ (801203c <AesSetKey_C+0x1f8>)
 8011fae:	69bb      	ldr	r3, [r7, #24]
 8011fb0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[ 6] = rk[ 0] ^
 8011fb4:	69fb      	ldr	r3, [r7, #28]
 8011fb6:	3318      	adds	r3, #24
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011fb8:	404a      	eors	r2, r1
            rk[ 6] = rk[ 0] ^
 8011fba:	601a      	str	r2, [r3, #0]
            rk[ 7] = rk[ 1] ^ rk[ 6];
 8011fbc:	69fb      	ldr	r3, [r7, #28]
 8011fbe:	3304      	adds	r3, #4
 8011fc0:	6819      	ldr	r1, [r3, #0]
 8011fc2:	69fb      	ldr	r3, [r7, #28]
 8011fc4:	3318      	adds	r3, #24
 8011fc6:	681a      	ldr	r2, [r3, #0]
 8011fc8:	69fb      	ldr	r3, [r7, #28]
 8011fca:	331c      	adds	r3, #28
 8011fcc:	404a      	eors	r2, r1
 8011fce:	601a      	str	r2, [r3, #0]
            rk[ 8] = rk[ 2] ^ rk[ 7];
 8011fd0:	69fb      	ldr	r3, [r7, #28]
 8011fd2:	3308      	adds	r3, #8
 8011fd4:	6819      	ldr	r1, [r3, #0]
 8011fd6:	69fb      	ldr	r3, [r7, #28]
 8011fd8:	331c      	adds	r3, #28
 8011fda:	681a      	ldr	r2, [r3, #0]
 8011fdc:	69fb      	ldr	r3, [r7, #28]
 8011fde:	3320      	adds	r3, #32
 8011fe0:	404a      	eors	r2, r1
 8011fe2:	601a      	str	r2, [r3, #0]
            rk[ 9] = rk[ 3] ^ rk[ 8];
 8011fe4:	69fb      	ldr	r3, [r7, #28]
 8011fe6:	330c      	adds	r3, #12
 8011fe8:	6819      	ldr	r1, [r3, #0]
 8011fea:	69fb      	ldr	r3, [r7, #28]
 8011fec:	3320      	adds	r3, #32
 8011fee:	681a      	ldr	r2, [r3, #0]
 8011ff0:	69fb      	ldr	r3, [r7, #28]
 8011ff2:	3324      	adds	r3, #36	@ 0x24
 8011ff4:	404a      	eors	r2, r1
 8011ff6:	601a      	str	r2, [r3, #0]
            if (++i == 8)
 8011ff8:	69bb      	ldr	r3, [r7, #24]
 8011ffa:	3301      	adds	r3, #1
 8011ffc:	61bb      	str	r3, [r7, #24]
 8011ffe:	69bb      	ldr	r3, [r7, #24]
 8012000:	2b08      	cmp	r3, #8
 8012002:	d017      	beq.n	8012034 <AesSetKey_C+0x1f0>
                break;
            rk[10] = rk[ 4] ^ rk[ 9];
 8012004:	69fb      	ldr	r3, [r7, #28]
 8012006:	3310      	adds	r3, #16
 8012008:	6819      	ldr	r1, [r3, #0]
 801200a:	69fb      	ldr	r3, [r7, #28]
 801200c:	3324      	adds	r3, #36	@ 0x24
 801200e:	681a      	ldr	r2, [r3, #0]
 8012010:	69fb      	ldr	r3, [r7, #28]
 8012012:	3328      	adds	r3, #40	@ 0x28
 8012014:	404a      	eors	r2, r1
 8012016:	601a      	str	r2, [r3, #0]
            rk[11] = rk[ 5] ^ rk[10];
 8012018:	69fb      	ldr	r3, [r7, #28]
 801201a:	3314      	adds	r3, #20
 801201c:	6819      	ldr	r1, [r3, #0]
 801201e:	69fb      	ldr	r3, [r7, #28]
 8012020:	3328      	adds	r3, #40	@ 0x28
 8012022:	681a      	ldr	r2, [r3, #0]
 8012024:	69fb      	ldr	r3, [r7, #28]
 8012026:	332c      	adds	r3, #44	@ 0x2c
 8012028:	404a      	eors	r2, r1
 801202a:	601a      	str	r2, [r3, #0]
            rk += 6;
 801202c:	69fb      	ldr	r3, [r7, #28]
 801202e:	3318      	adds	r3, #24
 8012030:	61fb      	str	r3, [r7, #28]
            temp = rk[ 5];
 8012032:	e78c      	b.n	8011f4e <AesSetKey_C+0x10a>
                break;
 8012034:	bf00      	nop
        }
        break;
 8012036:	e0b5      	b.n	80121a4 <AesSetKey_C+0x360>
 8012038:	08032284 	.word	0x08032284
 801203c:	0803225c 	.word	0x0803225c
        temp = (word32)-1;
        wc_MemZero_Add("wc_AesSetKeyLocal temp", &temp, sizeof(temp));
    #endif
        while (1)
        {
            temp = rk[ 7];
 8012040:	69fb      	ldr	r3, [r7, #28]
 8012042:	69db      	ldr	r3, [r3, #28]
 8012044:	613b      	str	r3, [r7, #16]
            rk[ 8] = rk[ 0] ^
 8012046:	69fb      	ldr	r3, [r7, #28]
 8012048:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 801204a:	693b      	ldr	r3, [r7, #16]
 801204c:	0c1b      	lsrs	r3, r3, #16
 801204e:	b2db      	uxtb	r3, r3
 8012050:	499a      	ldr	r1, [pc, #616]	@ (80122bc <AesSetKey_C+0x478>)
 8012052:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8012056:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801205a:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[ 8] = rk[ 0] ^
 801205e:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8012060:	693b      	ldr	r3, [r7, #16]
 8012062:	0a1b      	lsrs	r3, r3, #8
 8012064:	b2db      	uxtb	r3, r3
 8012066:	4995      	ldr	r1, [pc, #596]	@ (80122bc <AesSetKey_C+0x478>)
 8012068:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801206c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012070:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8012074:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8012076:	693b      	ldr	r3, [r7, #16]
 8012078:	b2db      	uxtb	r3, r3
 801207a:	4619      	mov	r1, r3
 801207c:	4b8f      	ldr	r3, [pc, #572]	@ (80122bc <AesSetKey_C+0x478>)
 801207e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8012082:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8012086:	405a      	eors	r2, r3
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8012088:	693b      	ldr	r3, [r7, #16]
 801208a:	0e1b      	lsrs	r3, r3, #24
 801208c:	b2db      	uxtb	r3, r3
 801208e:	498b      	ldr	r1, [pc, #556]	@ (80122bc <AesSetKey_C+0x478>)
 8012090:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012094:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012098:	b2db      	uxtb	r3, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 801209a:	ea82 0103 	eor.w	r1, r2, r3
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3))) ^
        #endif
                rcon[i];
 801209e:	4a88      	ldr	r2, [pc, #544]	@ (80122c0 <AesSetKey_C+0x47c>)
 80120a0:	69bb      	ldr	r3, [r7, #24]
 80120a2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[ 8] = rk[ 0] ^
 80120a6:	69fb      	ldr	r3, [r7, #28]
 80120a8:	3320      	adds	r3, #32
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 80120aa:	404a      	eors	r2, r1
            rk[ 8] = rk[ 0] ^
 80120ac:	601a      	str	r2, [r3, #0]
            rk[ 9] = rk[ 1] ^ rk[ 8];
 80120ae:	69fb      	ldr	r3, [r7, #28]
 80120b0:	3304      	adds	r3, #4
 80120b2:	6819      	ldr	r1, [r3, #0]
 80120b4:	69fb      	ldr	r3, [r7, #28]
 80120b6:	3320      	adds	r3, #32
 80120b8:	681a      	ldr	r2, [r3, #0]
 80120ba:	69fb      	ldr	r3, [r7, #28]
 80120bc:	3324      	adds	r3, #36	@ 0x24
 80120be:	404a      	eors	r2, r1
 80120c0:	601a      	str	r2, [r3, #0]
            rk[10] = rk[ 2] ^ rk[ 9];
 80120c2:	69fb      	ldr	r3, [r7, #28]
 80120c4:	3308      	adds	r3, #8
 80120c6:	6819      	ldr	r1, [r3, #0]
 80120c8:	69fb      	ldr	r3, [r7, #28]
 80120ca:	3324      	adds	r3, #36	@ 0x24
 80120cc:	681a      	ldr	r2, [r3, #0]
 80120ce:	69fb      	ldr	r3, [r7, #28]
 80120d0:	3328      	adds	r3, #40	@ 0x28
 80120d2:	404a      	eors	r2, r1
 80120d4:	601a      	str	r2, [r3, #0]
            rk[11] = rk[ 3] ^ rk[10];
 80120d6:	69fb      	ldr	r3, [r7, #28]
 80120d8:	330c      	adds	r3, #12
 80120da:	6819      	ldr	r1, [r3, #0]
 80120dc:	69fb      	ldr	r3, [r7, #28]
 80120de:	3328      	adds	r3, #40	@ 0x28
 80120e0:	681a      	ldr	r2, [r3, #0]
 80120e2:	69fb      	ldr	r3, [r7, #28]
 80120e4:	332c      	adds	r3, #44	@ 0x2c
 80120e6:	404a      	eors	r2, r1
 80120e8:	601a      	str	r2, [r3, #0]
            if (++i == 7)
 80120ea:	69bb      	ldr	r3, [r7, #24]
 80120ec:	3301      	adds	r3, #1
 80120ee:	61bb      	str	r3, [r7, #24]
 80120f0:	69bb      	ldr	r3, [r7, #24]
 80120f2:	2b07      	cmp	r3, #7
 80120f4:	d054      	beq.n	80121a0 <AesSetKey_C+0x35c>
                break;
            temp = rk[11];
 80120f6:	69fb      	ldr	r3, [r7, #28]
 80120f8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80120fa:	613b      	str	r3, [r7, #16]
            rk[12] = rk[ 4] ^
 80120fc:	69fb      	ldr	r3, [r7, #28]
 80120fe:	3310      	adds	r3, #16
 8012100:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 3)) & 0xff000000) ^
 8012102:	693b      	ldr	r3, [r7, #16]
 8012104:	0e1b      	lsrs	r3, r3, #24
 8012106:	b2db      	uxtb	r3, r3
 8012108:	496c      	ldr	r1, [pc, #432]	@ (80122bc <AesSetKey_C+0x478>)
 801210a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801210e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012112:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[12] = rk[ 4] ^
 8012116:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 2)) & 0x00ff0000) ^
 8012118:	693b      	ldr	r3, [r7, #16]
 801211a:	0c1b      	lsrs	r3, r3, #16
 801211c:	b2db      	uxtb	r3, r3
 801211e:	4967      	ldr	r1, [pc, #412]	@ (80122bc <AesSetKey_C+0x478>)
 8012120:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8012124:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012128:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 3)) & 0xff000000) ^
 801212c:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 1)) & 0x0000ff00) ^
 801212e:	693b      	ldr	r3, [r7, #16]
 8012130:	0a1b      	lsrs	r3, r3, #8
 8012132:	b2db      	uxtb	r3, r3
 8012134:	4619      	mov	r1, r3
 8012136:	4b61      	ldr	r3, [pc, #388]	@ (80122bc <AesSetKey_C+0x478>)
 8012138:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 801213c:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 2)) & 0x00ff0000) ^
 8012140:	ea82 0103 	eor.w	r1, r2, r3
                (GetTable(Te[1], GETBYTE(temp, 0)) & 0x000000ff);
 8012144:	693b      	ldr	r3, [r7, #16]
 8012146:	b2db      	uxtb	r3, r3
 8012148:	4a5c      	ldr	r2, [pc, #368]	@ (80122bc <AesSetKey_C+0x478>)
 801214a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801214e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012152:	b2da      	uxtb	r2, r3
            rk[12] = rk[ 4] ^
 8012154:	69fb      	ldr	r3, [r7, #28]
 8012156:	3330      	adds	r3, #48	@ 0x30
                (GetTable(Te[0], GETBYTE(temp, 1)) & 0x0000ff00) ^
 8012158:	404a      	eors	r2, r1
            rk[12] = rk[ 4] ^
 801215a:	601a      	str	r2, [r3, #0]
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)));
        #endif
            rk[13] = rk[ 5] ^ rk[12];
 801215c:	69fb      	ldr	r3, [r7, #28]
 801215e:	3314      	adds	r3, #20
 8012160:	6819      	ldr	r1, [r3, #0]
 8012162:	69fb      	ldr	r3, [r7, #28]
 8012164:	3330      	adds	r3, #48	@ 0x30
 8012166:	681a      	ldr	r2, [r3, #0]
 8012168:	69fb      	ldr	r3, [r7, #28]
 801216a:	3334      	adds	r3, #52	@ 0x34
 801216c:	404a      	eors	r2, r1
 801216e:	601a      	str	r2, [r3, #0]
            rk[14] = rk[ 6] ^ rk[13];
 8012170:	69fb      	ldr	r3, [r7, #28]
 8012172:	3318      	adds	r3, #24
 8012174:	6819      	ldr	r1, [r3, #0]
 8012176:	69fb      	ldr	r3, [r7, #28]
 8012178:	3334      	adds	r3, #52	@ 0x34
 801217a:	681a      	ldr	r2, [r3, #0]
 801217c:	69fb      	ldr	r3, [r7, #28]
 801217e:	3338      	adds	r3, #56	@ 0x38
 8012180:	404a      	eors	r2, r1
 8012182:	601a      	str	r2, [r3, #0]
            rk[15] = rk[ 7] ^ rk[14];
 8012184:	69fb      	ldr	r3, [r7, #28]
 8012186:	331c      	adds	r3, #28
 8012188:	6819      	ldr	r1, [r3, #0]
 801218a:	69fb      	ldr	r3, [r7, #28]
 801218c:	3338      	adds	r3, #56	@ 0x38
 801218e:	681a      	ldr	r2, [r3, #0]
 8012190:	69fb      	ldr	r3, [r7, #28]
 8012192:	333c      	adds	r3, #60	@ 0x3c
 8012194:	404a      	eors	r2, r1
 8012196:	601a      	str	r2, [r3, #0]

            rk += 8;
 8012198:	69fb      	ldr	r3, [r7, #28]
 801219a:	3320      	adds	r3, #32
 801219c:	61fb      	str	r3, [r7, #28]
            temp = rk[ 7];
 801219e:	e74f      	b.n	8012040 <AesSetKey_C+0x1fc>
                break;
 80121a0:	bf00      	nop
        }
        break;
 80121a2:	bf00      	nop
#endif /* 256 */
    } /* switch */
    ForceZero(&temp, sizeof(temp));
 80121a4:	f107 0310 	add.w	r3, r7, #16
 80121a8:	2104      	movs	r1, #4
 80121aa:	4618      	mov	r0, r3
 80121ac:	f7fd fb91 	bl	800f8d2 <ForceZero>

#if defined(HAVE_AES_DECRYPT) && !defined(MAX3266X_AES)
    if (dir == AES_DECRYPTION) {
 80121b0:	683b      	ldr	r3, [r7, #0]
 80121b2:	2b01      	cmp	r3, #1
 80121b4:	f040 819d 	bne.w	80124f2 <AesSetKey_C+0x6ae>
        unsigned int j;

#ifdef WC_C_DYNAMIC_FALLBACK
        rk = aes->key_C_fallback;
#else
        rk = aes->key;
 80121b8:	68fb      	ldr	r3, [r7, #12]
 80121ba:	61fb      	str	r3, [r7, #28]
#endif

        /* invert the order of the round keys: */
        for (i = 0, j = 4* aes->rounds; i < j; i += 4, j -= 4) {
 80121bc:	2300      	movs	r3, #0
 80121be:	61bb      	str	r3, [r7, #24]
 80121c0:	68fb      	ldr	r3, [r7, #12]
 80121c2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80121c6:	009b      	lsls	r3, r3, #2
 80121c8:	617b      	str	r3, [r7, #20]
 80121ca:	e069      	b.n	80122a0 <AesSetKey_C+0x45c>
            temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;
 80121cc:	69bb      	ldr	r3, [r7, #24]
 80121ce:	009b      	lsls	r3, r3, #2
 80121d0:	69fa      	ldr	r2, [r7, #28]
 80121d2:	4413      	add	r3, r2
 80121d4:	681b      	ldr	r3, [r3, #0]
 80121d6:	613b      	str	r3, [r7, #16]
 80121d8:	697b      	ldr	r3, [r7, #20]
 80121da:	009b      	lsls	r3, r3, #2
 80121dc:	69fa      	ldr	r2, [r7, #28]
 80121de:	441a      	add	r2, r3
 80121e0:	69bb      	ldr	r3, [r7, #24]
 80121e2:	009b      	lsls	r3, r3, #2
 80121e4:	69f9      	ldr	r1, [r7, #28]
 80121e6:	440b      	add	r3, r1
 80121e8:	6812      	ldr	r2, [r2, #0]
 80121ea:	601a      	str	r2, [r3, #0]
 80121ec:	697b      	ldr	r3, [r7, #20]
 80121ee:	009b      	lsls	r3, r3, #2
 80121f0:	69fa      	ldr	r2, [r7, #28]
 80121f2:	4413      	add	r3, r2
 80121f4:	693a      	ldr	r2, [r7, #16]
 80121f6:	601a      	str	r2, [r3, #0]
            temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;
 80121f8:	69bb      	ldr	r3, [r7, #24]
 80121fa:	3301      	adds	r3, #1
 80121fc:	009b      	lsls	r3, r3, #2
 80121fe:	69fa      	ldr	r2, [r7, #28]
 8012200:	4413      	add	r3, r2
 8012202:	681b      	ldr	r3, [r3, #0]
 8012204:	613b      	str	r3, [r7, #16]
 8012206:	697b      	ldr	r3, [r7, #20]
 8012208:	3301      	adds	r3, #1
 801220a:	009b      	lsls	r3, r3, #2
 801220c:	69fa      	ldr	r2, [r7, #28]
 801220e:	441a      	add	r2, r3
 8012210:	69bb      	ldr	r3, [r7, #24]
 8012212:	3301      	adds	r3, #1
 8012214:	009b      	lsls	r3, r3, #2
 8012216:	69f9      	ldr	r1, [r7, #28]
 8012218:	440b      	add	r3, r1
 801221a:	6812      	ldr	r2, [r2, #0]
 801221c:	601a      	str	r2, [r3, #0]
 801221e:	697b      	ldr	r3, [r7, #20]
 8012220:	3301      	adds	r3, #1
 8012222:	009b      	lsls	r3, r3, #2
 8012224:	69fa      	ldr	r2, [r7, #28]
 8012226:	4413      	add	r3, r2
 8012228:	693a      	ldr	r2, [r7, #16]
 801222a:	601a      	str	r2, [r3, #0]
            temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;
 801222c:	69bb      	ldr	r3, [r7, #24]
 801222e:	3302      	adds	r3, #2
 8012230:	009b      	lsls	r3, r3, #2
 8012232:	69fa      	ldr	r2, [r7, #28]
 8012234:	4413      	add	r3, r2
 8012236:	681b      	ldr	r3, [r3, #0]
 8012238:	613b      	str	r3, [r7, #16]
 801223a:	697b      	ldr	r3, [r7, #20]
 801223c:	3302      	adds	r3, #2
 801223e:	009b      	lsls	r3, r3, #2
 8012240:	69fa      	ldr	r2, [r7, #28]
 8012242:	441a      	add	r2, r3
 8012244:	69bb      	ldr	r3, [r7, #24]
 8012246:	3302      	adds	r3, #2
 8012248:	009b      	lsls	r3, r3, #2
 801224a:	69f9      	ldr	r1, [r7, #28]
 801224c:	440b      	add	r3, r1
 801224e:	6812      	ldr	r2, [r2, #0]
 8012250:	601a      	str	r2, [r3, #0]
 8012252:	697b      	ldr	r3, [r7, #20]
 8012254:	3302      	adds	r3, #2
 8012256:	009b      	lsls	r3, r3, #2
 8012258:	69fa      	ldr	r2, [r7, #28]
 801225a:	4413      	add	r3, r2
 801225c:	693a      	ldr	r2, [r7, #16]
 801225e:	601a      	str	r2, [r3, #0]
            temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
 8012260:	69bb      	ldr	r3, [r7, #24]
 8012262:	3303      	adds	r3, #3
 8012264:	009b      	lsls	r3, r3, #2
 8012266:	69fa      	ldr	r2, [r7, #28]
 8012268:	4413      	add	r3, r2
 801226a:	681b      	ldr	r3, [r3, #0]
 801226c:	613b      	str	r3, [r7, #16]
 801226e:	697b      	ldr	r3, [r7, #20]
 8012270:	3303      	adds	r3, #3
 8012272:	009b      	lsls	r3, r3, #2
 8012274:	69fa      	ldr	r2, [r7, #28]
 8012276:	441a      	add	r2, r3
 8012278:	69bb      	ldr	r3, [r7, #24]
 801227a:	3303      	adds	r3, #3
 801227c:	009b      	lsls	r3, r3, #2
 801227e:	69f9      	ldr	r1, [r7, #28]
 8012280:	440b      	add	r3, r1
 8012282:	6812      	ldr	r2, [r2, #0]
 8012284:	601a      	str	r2, [r3, #0]
 8012286:	697b      	ldr	r3, [r7, #20]
 8012288:	3303      	adds	r3, #3
 801228a:	009b      	lsls	r3, r3, #2
 801228c:	69fa      	ldr	r2, [r7, #28]
 801228e:	4413      	add	r3, r2
 8012290:	693a      	ldr	r2, [r7, #16]
 8012292:	601a      	str	r2, [r3, #0]
        for (i = 0, j = 4* aes->rounds; i < j; i += 4, j -= 4) {
 8012294:	69bb      	ldr	r3, [r7, #24]
 8012296:	3304      	adds	r3, #4
 8012298:	61bb      	str	r3, [r7, #24]
 801229a:	697b      	ldr	r3, [r7, #20]
 801229c:	3b04      	subs	r3, #4
 801229e:	617b      	str	r3, [r7, #20]
 80122a0:	69ba      	ldr	r2, [r7, #24]
 80122a2:	697b      	ldr	r3, [r7, #20]
 80122a4:	429a      	cmp	r2, r3
 80122a6:	d391      	bcc.n	80121cc <AesSetKey_C+0x388>
        }
        ForceZero(&temp, sizeof(temp));
 80122a8:	f107 0310 	add.w	r3, r7, #16
 80122ac:	2104      	movs	r1, #4
 80122ae:	4618      	mov	r0, r3
 80122b0:	f7fd fb0f 	bl	800f8d2 <ForceZero>
    #if !defined(WOLFSSL_AES_SMALL_TABLES)
        /* apply the inverse MixColumn transform to all round keys but the
           first and the last: */
        for (i = 1; i < aes->rounds; i++) {
 80122b4:	2301      	movs	r3, #1
 80122b6:	61bb      	str	r3, [r7, #24]
 80122b8:	e114      	b.n	80124e4 <AesSetKey_C+0x6a0>
 80122ba:	bf00      	nop
 80122bc:	08032284 	.word	0x08032284
 80122c0:	0803225c 	.word	0x0803225c
            rk += 4;
 80122c4:	69fb      	ldr	r3, [r7, #28]
 80122c6:	3310      	adds	r3, #16
 80122c8:	61fb      	str	r3, [r7, #28]
            rk[0] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[0], 3)) & 0xff) ^
 80122ca:	69fb      	ldr	r3, [r7, #28]
 80122cc:	681b      	ldr	r3, [r3, #0]
 80122ce:	0e1b      	lsrs	r3, r3, #24
 80122d0:	b2db      	uxtb	r3, r3
 80122d2:	4a8a      	ldr	r2, [pc, #552]	@ (80124fc <AesSetKey_C+0x6b8>)
 80122d4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80122d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80122dc:	b2db      	uxtb	r3, r3
 80122de:	4a88      	ldr	r2, [pc, #544]	@ (8012500 <AesSetKey_C+0x6bc>)
 80122e0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[0], 2)) & 0xff) ^
 80122e4:	69fb      	ldr	r3, [r7, #28]
 80122e6:	681b      	ldr	r3, [r3, #0]
 80122e8:	0c1b      	lsrs	r3, r3, #16
 80122ea:	b2db      	uxtb	r3, r3
 80122ec:	4983      	ldr	r1, [pc, #524]	@ (80124fc <AesSetKey_C+0x6b8>)
 80122ee:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80122f2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80122f6:	b2db      	uxtb	r3, r3
 80122f8:	4981      	ldr	r1, [pc, #516]	@ (8012500 <AesSetKey_C+0x6bc>)
 80122fa:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80122fe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[0], 3)) & 0xff) ^
 8012302:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 8012304:	69fb      	ldr	r3, [r7, #28]
 8012306:	681b      	ldr	r3, [r3, #0]
 8012308:	0a1b      	lsrs	r3, r3, #8
 801230a:	b2db      	uxtb	r3, r3
 801230c:	497b      	ldr	r1, [pc, #492]	@ (80124fc <AesSetKey_C+0x6b8>)
 801230e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012312:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012316:	b2db      	uxtb	r3, r3
 8012318:	4979      	ldr	r1, [pc, #484]	@ (8012500 <AesSetKey_C+0x6bc>)
 801231a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801231e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[0], 2)) & 0xff) ^
 8012322:	405a      	eors	r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[0], 0)) & 0xff);
 8012324:	69fb      	ldr	r3, [r7, #28]
 8012326:	681b      	ldr	r3, [r3, #0]
 8012328:	b2db      	uxtb	r3, r3
 801232a:	4974      	ldr	r1, [pc, #464]	@ (80124fc <AesSetKey_C+0x6b8>)
 801232c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012330:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012334:	b2db      	uxtb	r3, r3
 8012336:	4972      	ldr	r1, [pc, #456]	@ (8012500 <AesSetKey_C+0x6bc>)
 8012338:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801233c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 8012340:	405a      	eors	r2, r3
            rk[0] =
 8012342:	69fb      	ldr	r3, [r7, #28]
 8012344:	601a      	str	r2, [r3, #0]
            rk[1] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[1], 3)) & 0xff) ^
 8012346:	69fb      	ldr	r3, [r7, #28]
 8012348:	3304      	adds	r3, #4
 801234a:	681b      	ldr	r3, [r3, #0]
 801234c:	0e1b      	lsrs	r3, r3, #24
 801234e:	b2db      	uxtb	r3, r3
 8012350:	4a6a      	ldr	r2, [pc, #424]	@ (80124fc <AesSetKey_C+0x6b8>)
 8012352:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012356:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801235a:	b2db      	uxtb	r3, r3
 801235c:	4a68      	ldr	r2, [pc, #416]	@ (8012500 <AesSetKey_C+0x6bc>)
 801235e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[1], 2)) & 0xff) ^
 8012362:	69fb      	ldr	r3, [r7, #28]
 8012364:	3304      	adds	r3, #4
 8012366:	681b      	ldr	r3, [r3, #0]
 8012368:	0c1b      	lsrs	r3, r3, #16
 801236a:	b2db      	uxtb	r3, r3
 801236c:	4963      	ldr	r1, [pc, #396]	@ (80124fc <AesSetKey_C+0x6b8>)
 801236e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012372:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012376:	b2db      	uxtb	r3, r3
 8012378:	4961      	ldr	r1, [pc, #388]	@ (8012500 <AesSetKey_C+0x6bc>)
 801237a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801237e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[1], 3)) & 0xff) ^
 8012382:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 8012384:	69fb      	ldr	r3, [r7, #28]
 8012386:	3304      	adds	r3, #4
 8012388:	681b      	ldr	r3, [r3, #0]
 801238a:	0a1b      	lsrs	r3, r3, #8
 801238c:	b2db      	uxtb	r3, r3
 801238e:	495b      	ldr	r1, [pc, #364]	@ (80124fc <AesSetKey_C+0x6b8>)
 8012390:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012394:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012398:	b2db      	uxtb	r3, r3
 801239a:	4959      	ldr	r1, [pc, #356]	@ (8012500 <AesSetKey_C+0x6bc>)
 801239c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80123a0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[1], 2)) & 0xff) ^
 80123a4:	ea82 0103 	eor.w	r1, r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[1], 0)) & 0xff);
 80123a8:	69fb      	ldr	r3, [r7, #28]
 80123aa:	3304      	adds	r3, #4
 80123ac:	681b      	ldr	r3, [r3, #0]
 80123ae:	b2db      	uxtb	r3, r3
 80123b0:	4a52      	ldr	r2, [pc, #328]	@ (80124fc <AesSetKey_C+0x6b8>)
 80123b2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80123b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80123ba:	b2db      	uxtb	r3, r3
 80123bc:	4a50      	ldr	r2, [pc, #320]	@ (8012500 <AesSetKey_C+0x6bc>)
 80123be:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80123c2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[1] =
 80123c6:	69fb      	ldr	r3, [r7, #28]
 80123c8:	3304      	adds	r3, #4
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 80123ca:	404a      	eors	r2, r1
            rk[1] =
 80123cc:	601a      	str	r2, [r3, #0]
            rk[2] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[2], 3)) & 0xff) ^
 80123ce:	69fb      	ldr	r3, [r7, #28]
 80123d0:	3308      	adds	r3, #8
 80123d2:	681b      	ldr	r3, [r3, #0]
 80123d4:	0e1b      	lsrs	r3, r3, #24
 80123d6:	b2db      	uxtb	r3, r3
 80123d8:	4a48      	ldr	r2, [pc, #288]	@ (80124fc <AesSetKey_C+0x6b8>)
 80123da:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80123de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80123e2:	b2db      	uxtb	r3, r3
 80123e4:	4a46      	ldr	r2, [pc, #280]	@ (8012500 <AesSetKey_C+0x6bc>)
 80123e6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[2], 2)) & 0xff) ^
 80123ea:	69fb      	ldr	r3, [r7, #28]
 80123ec:	3308      	adds	r3, #8
 80123ee:	681b      	ldr	r3, [r3, #0]
 80123f0:	0c1b      	lsrs	r3, r3, #16
 80123f2:	b2db      	uxtb	r3, r3
 80123f4:	4941      	ldr	r1, [pc, #260]	@ (80124fc <AesSetKey_C+0x6b8>)
 80123f6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80123fa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80123fe:	b2db      	uxtb	r3, r3
 8012400:	493f      	ldr	r1, [pc, #252]	@ (8012500 <AesSetKey_C+0x6bc>)
 8012402:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012406:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[2], 3)) & 0xff) ^
 801240a:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 801240c:	69fb      	ldr	r3, [r7, #28]
 801240e:	3308      	adds	r3, #8
 8012410:	681b      	ldr	r3, [r3, #0]
 8012412:	0a1b      	lsrs	r3, r3, #8
 8012414:	b2db      	uxtb	r3, r3
 8012416:	4939      	ldr	r1, [pc, #228]	@ (80124fc <AesSetKey_C+0x6b8>)
 8012418:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801241c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012420:	b2db      	uxtb	r3, r3
 8012422:	4937      	ldr	r1, [pc, #220]	@ (8012500 <AesSetKey_C+0x6bc>)
 8012424:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8012428:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[2], 2)) & 0xff) ^
 801242c:	ea82 0103 	eor.w	r1, r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[2], 0)) & 0xff);
 8012430:	69fb      	ldr	r3, [r7, #28]
 8012432:	3308      	adds	r3, #8
 8012434:	681b      	ldr	r3, [r3, #0]
 8012436:	b2db      	uxtb	r3, r3
 8012438:	4a30      	ldr	r2, [pc, #192]	@ (80124fc <AesSetKey_C+0x6b8>)
 801243a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801243e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012442:	b2db      	uxtb	r3, r3
 8012444:	4a2e      	ldr	r2, [pc, #184]	@ (8012500 <AesSetKey_C+0x6bc>)
 8012446:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801244a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[2] =
 801244e:	69fb      	ldr	r3, [r7, #28]
 8012450:	3308      	adds	r3, #8
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 8012452:	404a      	eors	r2, r1
            rk[2] =
 8012454:	601a      	str	r2, [r3, #0]
            rk[3] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[3], 3)) & 0xff) ^
 8012456:	69fb      	ldr	r3, [r7, #28]
 8012458:	330c      	adds	r3, #12
 801245a:	681b      	ldr	r3, [r3, #0]
 801245c:	0e1b      	lsrs	r3, r3, #24
 801245e:	b2db      	uxtb	r3, r3
 8012460:	4a26      	ldr	r2, [pc, #152]	@ (80124fc <AesSetKey_C+0x6b8>)
 8012462:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012466:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801246a:	b2db      	uxtb	r3, r3
 801246c:	4a24      	ldr	r2, [pc, #144]	@ (8012500 <AesSetKey_C+0x6bc>)
 801246e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[3], 2)) & 0xff) ^
 8012472:	69fb      	ldr	r3, [r7, #28]
 8012474:	330c      	adds	r3, #12
 8012476:	681b      	ldr	r3, [r3, #0]
 8012478:	0c1b      	lsrs	r3, r3, #16
 801247a:	b2db      	uxtb	r3, r3
 801247c:	491f      	ldr	r1, [pc, #124]	@ (80124fc <AesSetKey_C+0x6b8>)
 801247e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012482:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012486:	b2db      	uxtb	r3, r3
 8012488:	491d      	ldr	r1, [pc, #116]	@ (8012500 <AesSetKey_C+0x6bc>)
 801248a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801248e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[3], 3)) & 0xff) ^
 8012492:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 8012494:	69fb      	ldr	r3, [r7, #28]
 8012496:	330c      	adds	r3, #12
 8012498:	681b      	ldr	r3, [r3, #0]
 801249a:	0a1b      	lsrs	r3, r3, #8
 801249c:	b2db      	uxtb	r3, r3
 801249e:	4917      	ldr	r1, [pc, #92]	@ (80124fc <AesSetKey_C+0x6b8>)
 80124a0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80124a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80124a8:	b2db      	uxtb	r3, r3
 80124aa:	4915      	ldr	r1, [pc, #84]	@ (8012500 <AesSetKey_C+0x6bc>)
 80124ac:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80124b0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[3], 2)) & 0xff) ^
 80124b4:	ea82 0103 	eor.w	r1, r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[3], 0)) & 0xff);
 80124b8:	69fb      	ldr	r3, [r7, #28]
 80124ba:	330c      	adds	r3, #12
 80124bc:	681b      	ldr	r3, [r3, #0]
 80124be:	b2db      	uxtb	r3, r3
 80124c0:	4a0e      	ldr	r2, [pc, #56]	@ (80124fc <AesSetKey_C+0x6b8>)
 80124c2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80124c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80124ca:	b2db      	uxtb	r3, r3
 80124cc:	4a0c      	ldr	r2, [pc, #48]	@ (8012500 <AesSetKey_C+0x6bc>)
 80124ce:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80124d2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[3] =
 80124d6:	69fb      	ldr	r3, [r7, #28]
 80124d8:	330c      	adds	r3, #12
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 80124da:	404a      	eors	r2, r1
            rk[3] =
 80124dc:	601a      	str	r2, [r3, #0]
        for (i = 1; i < aes->rounds; i++) {
 80124de:	69bb      	ldr	r3, [r7, #24]
 80124e0:	3301      	adds	r3, #1
 80124e2:	61bb      	str	r3, [r7, #24]
 80124e4:	68fb      	ldr	r3, [r7, #12]
 80124e6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80124ea:	69ba      	ldr	r2, [r7, #24]
 80124ec:	429a      	cmp	r2, r3
 80124ee:	f4ff aee9 	bcc.w	80122c4 <AesSetKey_C+0x480>
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(&temp, sizeof(temp));
#else
    (void)temp;
#endif
}
 80124f2:	bf00      	nop
 80124f4:	3720      	adds	r7, #32
 80124f6:	46bd      	mov	sp, r7
 80124f8:	bd80      	pop	{r7, pc}
 80124fa:	bf00      	nop
 80124fc:	08032284 	.word	0x08032284
 8012500:	08033284 	.word	0x08033284

08012504 <wc_AesSetKeyLocal>:
#ifndef WOLFSSL_RISCV_ASM
    /* Software AES - SetKey */
    static WARN_UNUSED_RESULT int wc_AesSetKeyLocal(
        Aes* aes, const byte* userKey, word32 keylen, const byte* iv, int dir,
        int checkKeyLen)
    {
 8012504:	b580      	push	{r7, lr}
 8012506:	b086      	sub	sp, #24
 8012508:	af00      	add	r7, sp, #0
 801250a:	60f8      	str	r0, [r7, #12]
 801250c:	60b9      	str	r1, [r7, #8]
 801250e:	607a      	str	r2, [r7, #4]
 8012510:	603b      	str	r3, [r7, #0]
    #ifdef WOLFSSL_IMX6_CAAM_BLOB
        byte   local[32];
        word32 localSz = 32;
    #endif

        if (aes == NULL)
 8012512:	68fb      	ldr	r3, [r7, #12]
 8012514:	2b00      	cmp	r3, #0
 8012516:	d102      	bne.n	801251e <wc_AesSetKeyLocal+0x1a>
            return BAD_FUNC_ARG;
 8012518:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801251c:	e054      	b.n	80125c8 <wc_AesSetKeyLocal+0xc4>
        ret = wc_debug_CipherLifecycleCheck(aes->CipherLifecycleTag, 0);
        if (ret < 0)
            return ret;
#endif

        switch (keylen) {
 801251e:	687b      	ldr	r3, [r7, #4]
 8012520:	3b10      	subs	r3, #16
 8012522:	2b10      	cmp	r3, #16
 8012524:	bf8c      	ite	hi
 8012526:	2201      	movhi	r2, #1
 8012528:	2200      	movls	r2, #0
 801252a:	b2d2      	uxtb	r2, r2
 801252c:	2a00      	cmp	r2, #0
 801252e:	d10b      	bne.n	8012548 <wc_AesSetKeyLocal+0x44>
 8012530:	4a27      	ldr	r2, [pc, #156]	@ (80125d0 <wc_AesSetKeyLocal+0xcc>)
 8012532:	fa22 f303 	lsr.w	r3, r2, r3
 8012536:	f003 0301 	and.w	r3, r3, #1
 801253a:	2b00      	cmp	r3, #0
 801253c:	bf14      	ite	ne
 801253e:	2301      	movne	r3, #1
 8012540:	2300      	moveq	r3, #0
 8012542:	b2db      	uxtb	r3, r3
 8012544:	2b00      	cmp	r3, #0
 8012546:	d102      	bne.n	801254e <wc_AesSetKeyLocal+0x4a>
        defined(WOLFSSL_AES_256)
        case 32:
    #endif
            break;
        default:
            return BAD_FUNC_ARG;
 8012548:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801254c:	e03c      	b.n	80125c8 <wc_AesSetKeyLocal+0xc4>
            break;
 801254e:	bf00      	nop
            }
            XMEMCPY(aes->devKey, userKey, keylen);
        }
    #endif

        if (checkKeyLen) {
 8012550:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012552:	2b00      	cmp	r3, #0
 8012554:	d00b      	beq.n	801256e <wc_AesSetKeyLocal+0x6a>
            if (keylen != 16 && keylen != 24 && keylen != 32) {
 8012556:	687b      	ldr	r3, [r7, #4]
 8012558:	2b10      	cmp	r3, #16
 801255a:	d008      	beq.n	801256e <wc_AesSetKeyLocal+0x6a>
 801255c:	687b      	ldr	r3, [r7, #4]
 801255e:	2b18      	cmp	r3, #24
 8012560:	d005      	beq.n	801256e <wc_AesSetKeyLocal+0x6a>
 8012562:	687b      	ldr	r3, [r7, #4]
 8012564:	2b20      	cmp	r3, #32
 8012566:	d002      	beq.n	801256e <wc_AesSetKeyLocal+0x6a>
                return BAD_FUNC_ARG;
 8012568:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801256c:	e02c      	b.n	80125c8 <wc_AesSetKeyLocal+0xc4>
    #if defined(WOLFSSL_AES_COUNTER) || defined(WOLFSSL_AES_CFB) || \
        defined(WOLFSSL_AES_OFB) || defined(WOLFSSL_AES_XTS)
        aes->left = 0;
    #endif

        aes->keylen = (int)keylen;
 801256e:	687a      	ldr	r2, [r7, #4]
 8012570:	68fb      	ldr	r3, [r7, #12]
 8012572:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
        aes->rounds = (keylen/4) + 6;
 8012576:	687b      	ldr	r3, [r7, #4]
 8012578:	089b      	lsrs	r3, r3, #2
 801257a:	1d9a      	adds	r2, r3, #6
 801257c:	68fb      	ldr	r3, [r7, #12]
 801257e:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
        ret = wc_AesSetIV(aes, iv);
 8012582:	6839      	ldr	r1, [r7, #0]
 8012584:	68f8      	ldr	r0, [r7, #12]
 8012586:	f000 f847 	bl	8012618 <wc_AesSetIV>
 801258a:	6178      	str	r0, [r7, #20]
        if (ret != 0)
 801258c:	697b      	ldr	r3, [r7, #20]
 801258e:	2b00      	cmp	r3, #0
 8012590:	d001      	beq.n	8012596 <wc_AesSetKeyLocal+0x92>
            return ret;
 8012592:	697b      	ldr	r3, [r7, #20]
 8012594:	e018      	b.n	80125c8 <wc_AesSetKeyLocal+0xc4>
            aes->init = 0;
        }
        (void)dir;
    #endif

        if (keylen > sizeof(aes->key)) {
 8012596:	687b      	ldr	r3, [r7, #4]
 8012598:	2bf0      	cmp	r3, #240	@ 0xf0
 801259a:	d902      	bls.n	80125a2 <wc_AesSetKeyLocal+0x9e>
            return BAD_FUNC_ARG;
 801259c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80125a0:	e012      	b.n	80125c8 <wc_AesSetKeyLocal+0xc4>
            }
            return ret;
        }
#endif

        XMEMCPY(aes->key, userKey, keylen);
 80125a2:	68fb      	ldr	r3, [r7, #12]
 80125a4:	687a      	ldr	r2, [r7, #4]
 80125a6:	68b9      	ldr	r1, [r7, #8]
 80125a8:	4618      	mov	r0, r3
 80125aa:	f016 fbec 	bl	8028d86 <memcpy>
    #if defined(LITTLE_ENDIAN_ORDER) && !defined(WOLFSSL_PIC32MZ_CRYPT) && \
        (!defined(WOLFSSL_ESP32_CRYPT) || defined(NO_WOLFSSL_ESP32_CRYPT_AES)) \
        && !defined(MAX3266X_AES)

        /* software */
        ByteReverseWords(aes->key, aes->key, keylen);
 80125ae:	68fb      	ldr	r3, [r7, #12]
 80125b0:	68f9      	ldr	r1, [r7, #12]
 80125b2:	687a      	ldr	r2, [r7, #4]
 80125b4:	4618      	mov	r0, r3
 80125b6:	f7fd f8e7 	bl	800f788 <ByteReverseWords>
        }
    #endif
#endif /* !WC_AES_BITSLICED */

#ifdef NEED_AES_TABLES
        AesSetKey_C(aes, userKey, keylen, dir);
 80125ba:	6a3b      	ldr	r3, [r7, #32]
 80125bc:	687a      	ldr	r2, [r7, #4]
 80125be:	68b9      	ldr	r1, [r7, #8]
 80125c0:	68f8      	ldr	r0, [r7, #12]
 80125c2:	f7ff fc3f 	bl	8011e44 <AesSetKey_C>
        aes->ctx.cfd = -1;
    #endif
    #ifdef WOLFSSL_IMX6_CAAM_BLOB
        ForceZero(local, sizeof(local));
    #endif
        return ret;
 80125c6:	697b      	ldr	r3, [r7, #20]
    } /* wc_AesSetKeyLocal */
 80125c8:	4618      	mov	r0, r3
 80125ca:	3718      	adds	r7, #24
 80125cc:	46bd      	mov	sp, r7
 80125ce:	bd80      	pop	{r7, pc}
 80125d0:	00010101 	.word	0x00010101

080125d4 <wc_AesSetKey>:

    int wc_AesSetKey(Aes* aes, const byte* userKey, word32 keylen,
            const byte* iv, int dir)
    {
 80125d4:	b580      	push	{r7, lr}
 80125d6:	b086      	sub	sp, #24
 80125d8:	af02      	add	r7, sp, #8
 80125da:	60f8      	str	r0, [r7, #12]
 80125dc:	60b9      	str	r1, [r7, #8]
 80125de:	607a      	str	r2, [r7, #4]
 80125e0:	603b      	str	r3, [r7, #0]
        if (aes == NULL) {
 80125e2:	68fb      	ldr	r3, [r7, #12]
 80125e4:	2b00      	cmp	r3, #0
 80125e6:	d102      	bne.n	80125ee <wc_AesSetKey+0x1a>
            return BAD_FUNC_ARG;
 80125e8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80125ec:	e010      	b.n	8012610 <wc_AesSetKey+0x3c>
        }
        if (keylen > sizeof(aes->key)) {
 80125ee:	687b      	ldr	r3, [r7, #4]
 80125f0:	2bf0      	cmp	r3, #240	@ 0xf0
 80125f2:	d902      	bls.n	80125fa <wc_AesSetKey+0x26>
            return BAD_FUNC_ARG;
 80125f4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80125f8:	e00a      	b.n	8012610 <wc_AesSetKey+0x3c>
                           keylen);
        #endif
        }
    #endif /* WOLFSSL_ESPIDF && NEED_AES_HW_FALLBACK */

        return wc_AesSetKeyLocal(aes, userKey, keylen, iv, dir, 1);
 80125fa:	2301      	movs	r3, #1
 80125fc:	9301      	str	r3, [sp, #4]
 80125fe:	69bb      	ldr	r3, [r7, #24]
 8012600:	9300      	str	r3, [sp, #0]
 8012602:	683b      	ldr	r3, [r7, #0]
 8012604:	687a      	ldr	r2, [r7, #4]
 8012606:	68b9      	ldr	r1, [r7, #8]
 8012608:	68f8      	ldr	r0, [r7, #12]
 801260a:	f7ff ff7b 	bl	8012504 <wc_AesSetKeyLocal>
 801260e:	4603      	mov	r3, r0

    } /* wc_AesSetKey() */
 8012610:	4618      	mov	r0, r3
 8012612:	3710      	adds	r7, #16
 8012614:	46bd      	mov	sp, r7
 8012616:	bd80      	pop	{r7, pc}

08012618 <wc_AesSetIV>:
#endif /* wc_AesSetKey block */


/* wc_AesSetIV is shared between software and hardware */
int wc_AesSetIV(Aes* aes, const byte* iv)
{
 8012618:	b580      	push	{r7, lr}
 801261a:	b082      	sub	sp, #8
 801261c:	af00      	add	r7, sp, #0
 801261e:	6078      	str	r0, [r7, #4]
 8012620:	6039      	str	r1, [r7, #0]
    if (aes == NULL)
 8012622:	687b      	ldr	r3, [r7, #4]
 8012624:	2b00      	cmp	r3, #0
 8012626:	d102      	bne.n	801262e <wc_AesSetIV+0x16>
        return BAD_FUNC_ARG;
 8012628:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801262c:	e012      	b.n	8012654 <wc_AesSetIV+0x3c>
        if (ret < 0)
            return ret;
    }
#endif

    if (iv)
 801262e:	683b      	ldr	r3, [r7, #0]
 8012630:	2b00      	cmp	r3, #0
 8012632:	d007      	beq.n	8012644 <wc_AesSetIV+0x2c>
        XMEMCPY(aes->reg, iv, WC_AES_BLOCK_SIZE);
 8012634:	687b      	ldr	r3, [r7, #4]
 8012636:	33f8      	adds	r3, #248	@ 0xf8
 8012638:	2210      	movs	r2, #16
 801263a:	6839      	ldr	r1, [r7, #0]
 801263c:	4618      	mov	r0, r3
 801263e:	f016 fba2 	bl	8028d86 <memcpy>
 8012642:	e006      	b.n	8012652 <wc_AesSetIV+0x3a>
    else
        XMEMSET(aes->reg,  0, WC_AES_BLOCK_SIZE);
 8012644:	687b      	ldr	r3, [r7, #4]
 8012646:	33f8      	adds	r3, #248	@ 0xf8
 8012648:	2210      	movs	r2, #16
 801264a:	2100      	movs	r1, #0
 801264c:	4618      	mov	r0, r3
 801264e:	f016 fae9 	bl	8028c24 <memset>
    defined(WOLFSSL_AES_OFB) || defined(WOLFSSL_AES_XTS)
    /* Clear any unused bytes from last cipher op. */
    aes->left = 0;
#endif

    return 0;
 8012652:	2300      	movs	r3, #0
}
 8012654:	4618      	mov	r0, r3
 8012656:	3708      	adds	r7, #8
 8012658:	46bd      	mov	sp, r7
 801265a:	bd80      	pop	{r7, pc}

0801265c <wc_AesCbcEncrypt>:

#ifdef NEED_SW_AESCBC
    /* Software AES - CBC Encrypt */

int wc_AesCbcEncrypt(Aes* aes, byte* out, const byte* in, word32 sz)
    {
 801265c:	b580      	push	{r7, lr}
 801265e:	b086      	sub	sp, #24
 8012660:	af00      	add	r7, sp, #0
 8012662:	60f8      	str	r0, [r7, #12]
 8012664:	60b9      	str	r1, [r7, #8]
 8012666:	607a      	str	r2, [r7, #4]
 8012668:	603b      	str	r3, [r7, #0]
        word32 blocks;
        int ret;

        if (aes == NULL || out == NULL || in == NULL) {
 801266a:	68fb      	ldr	r3, [r7, #12]
 801266c:	2b00      	cmp	r3, #0
 801266e:	d005      	beq.n	801267c <wc_AesCbcEncrypt+0x20>
 8012670:	68bb      	ldr	r3, [r7, #8]
 8012672:	2b00      	cmp	r3, #0
 8012674:	d002      	beq.n	801267c <wc_AesCbcEncrypt+0x20>
 8012676:	687b      	ldr	r3, [r7, #4]
 8012678:	2b00      	cmp	r3, #0
 801267a:	d102      	bne.n	8012682 <wc_AesCbcEncrypt+0x26>
            return BAD_FUNC_ARG;
 801267c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8012680:	e033      	b.n	80126ea <wc_AesCbcEncrypt+0x8e>
        }

        if (sz == 0) {
 8012682:	683b      	ldr	r3, [r7, #0]
 8012684:	2b00      	cmp	r3, #0
 8012686:	d101      	bne.n	801268c <wc_AesCbcEncrypt+0x30>
            return 0;
 8012688:	2300      	movs	r3, #0
 801268a:	e02e      	b.n	80126ea <wc_AesCbcEncrypt+0x8e>
        }

        blocks = sz / WC_AES_BLOCK_SIZE;
 801268c:	683b      	ldr	r3, [r7, #0]
 801268e:	091b      	lsrs	r3, r3, #4
 8012690:	617b      	str	r3, [r7, #20]
            ret = 0;
        }
        else
    #endif
        {
            ret = 0;
 8012692:	2300      	movs	r3, #0
 8012694:	613b      	str	r3, [r7, #16]
            while (blocks--) {
 8012696:	e020      	b.n	80126da <wc_AesCbcEncrypt+0x7e>
                xorbuf((byte*)aes->reg, in, WC_AES_BLOCK_SIZE);
 8012698:	68fb      	ldr	r3, [r7, #12]
 801269a:	33f8      	adds	r3, #248	@ 0xf8
 801269c:	2210      	movs	r2, #16
 801269e:	6879      	ldr	r1, [r7, #4]
 80126a0:	4618      	mov	r0, r3
 80126a2:	f7fd f8bc 	bl	800f81e <xorbuf>
                ret = wc_AesEncrypt(aes, (byte*)aes->reg, (byte*)aes->reg);
 80126a6:	68fb      	ldr	r3, [r7, #12]
 80126a8:	f103 01f8 	add.w	r1, r3, #248	@ 0xf8
 80126ac:	68fb      	ldr	r3, [r7, #12]
 80126ae:	33f8      	adds	r3, #248	@ 0xf8
 80126b0:	461a      	mov	r2, r3
 80126b2:	68f8      	ldr	r0, [r7, #12]
 80126b4:	f7fe fa52 	bl	8010b5c <wc_AesEncrypt>
 80126b8:	6138      	str	r0, [r7, #16]
                if (ret != 0)
 80126ba:	693b      	ldr	r3, [r7, #16]
 80126bc:	2b00      	cmp	r3, #0
 80126be:	d112      	bne.n	80126e6 <wc_AesCbcEncrypt+0x8a>
                    break;
                XMEMCPY(out, aes->reg, WC_AES_BLOCK_SIZE);
 80126c0:	68fb      	ldr	r3, [r7, #12]
 80126c2:	33f8      	adds	r3, #248	@ 0xf8
 80126c4:	2210      	movs	r2, #16
 80126c6:	4619      	mov	r1, r3
 80126c8:	68b8      	ldr	r0, [r7, #8]
 80126ca:	f016 fb5c 	bl	8028d86 <memcpy>

                out += WC_AES_BLOCK_SIZE;
 80126ce:	68bb      	ldr	r3, [r7, #8]
 80126d0:	3310      	adds	r3, #16
 80126d2:	60bb      	str	r3, [r7, #8]
                in  += WC_AES_BLOCK_SIZE;
 80126d4:	687b      	ldr	r3, [r7, #4]
 80126d6:	3310      	adds	r3, #16
 80126d8:	607b      	str	r3, [r7, #4]
            while (blocks--) {
 80126da:	697b      	ldr	r3, [r7, #20]
 80126dc:	1e5a      	subs	r2, r3, #1
 80126de:	617a      	str	r2, [r7, #20]
 80126e0:	2b00      	cmp	r3, #0
 80126e2:	d1d9      	bne.n	8012698 <wc_AesCbcEncrypt+0x3c>
 80126e4:	e000      	b.n	80126e8 <wc_AesCbcEncrypt+0x8c>
                    break;
 80126e6:	bf00      	nop

    #ifdef WOLFSSL_AESNI
        VECTOR_REGISTERS_POP;
    #endif

        return ret;
 80126e8:	693b      	ldr	r3, [r7, #16]
    } /* wc_AesCbcEncrypt */
 80126ea:	4618      	mov	r0, r3
 80126ec:	3718      	adds	r7, #24
 80126ee:	46bd      	mov	sp, r7
 80126f0:	bd80      	pop	{r7, pc}

080126f2 <wc_AesCbcDecrypt>:

#ifdef HAVE_AES_DECRYPT
    /* Software AES - CBC Decrypt */
    int wc_AesCbcDecrypt(Aes* aes, byte* out, const byte* in, word32 sz)
    {
 80126f2:	b580      	push	{r7, lr}
 80126f4:	b086      	sub	sp, #24
 80126f6:	af00      	add	r7, sp, #0
 80126f8:	60f8      	str	r0, [r7, #12]
 80126fa:	60b9      	str	r1, [r7, #8]
 80126fc:	607a      	str	r2, [r7, #4]
 80126fe:	603b      	str	r3, [r7, #0]
        word32 blocks;
        int ret;

        if (aes == NULL || out == NULL || in == NULL) {
 8012700:	68fb      	ldr	r3, [r7, #12]
 8012702:	2b00      	cmp	r3, #0
 8012704:	d005      	beq.n	8012712 <wc_AesCbcDecrypt+0x20>
 8012706:	68bb      	ldr	r3, [r7, #8]
 8012708:	2b00      	cmp	r3, #0
 801270a:	d002      	beq.n	8012712 <wc_AesCbcDecrypt+0x20>
 801270c:	687b      	ldr	r3, [r7, #4]
 801270e:	2b00      	cmp	r3, #0
 8012710:	d102      	bne.n	8012718 <wc_AesCbcDecrypt+0x26>
            return BAD_FUNC_ARG;
 8012712:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8012716:	e042      	b.n	801279e <wc_AesCbcDecrypt+0xac>
        }

        if (sz == 0) {
 8012718:	683b      	ldr	r3, [r7, #0]
 801271a:	2b00      	cmp	r3, #0
 801271c:	d101      	bne.n	8012722 <wc_AesCbcDecrypt+0x30>
            return 0;
 801271e:	2300      	movs	r3, #0
 8012720:	e03d      	b.n	801279e <wc_AesCbcDecrypt+0xac>
                          "unsupported keylen = %d", aes->keylen);
        #endif
        }
    #endif

        blocks = sz / WC_AES_BLOCK_SIZE;
 8012722:	683b      	ldr	r3, [r7, #0]
 8012724:	091b      	lsrs	r3, r3, #4
 8012726:	617b      	str	r3, [r7, #20]
        if (sz % WC_AES_BLOCK_SIZE) {
 8012728:	683b      	ldr	r3, [r7, #0]
 801272a:	f003 030f 	and.w	r3, r3, #15
 801272e:	2b00      	cmp	r3, #0
 8012730:	d002      	beq.n	8012738 <wc_AesCbcDecrypt+0x46>
#ifdef WOLFSSL_AES_CBC_LENGTH_CHECKS
            return BAD_LENGTH_E;
#else
            return BAD_FUNC_ARG;
 8012732:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8012736:	e032      	b.n	801279e <wc_AesCbcDecrypt+0xac>
            ret = 0;
        }
        else
    #endif
        {
            ret = 0;
 8012738:	2300      	movs	r3, #0
 801273a:	613b      	str	r3, [r7, #16]

                    blocks = 0;
                }
            }
#else
            while (blocks--) {
 801273c:	e029      	b.n	8012792 <wc_AesCbcDecrypt+0xa0>
                XMEMCPY(aes->tmp, in, WC_AES_BLOCK_SIZE);
 801273e:	68fb      	ldr	r3, [r7, #12]
 8012740:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 8012744:	2210      	movs	r2, #16
 8012746:	6879      	ldr	r1, [r7, #4]
 8012748:	4618      	mov	r0, r3
 801274a:	f016 fb1c 	bl	8028d86 <memcpy>
                ret = wc_AesDecrypt(aes, in, out);
 801274e:	68ba      	ldr	r2, [r7, #8]
 8012750:	6879      	ldr	r1, [r7, #4]
 8012752:	68f8      	ldr	r0, [r7, #12]
 8012754:	f7ff fb50 	bl	8011df8 <wc_AesDecrypt>
 8012758:	6138      	str	r0, [r7, #16]
                if (ret != 0)
 801275a:	693b      	ldr	r3, [r7, #16]
 801275c:	2b00      	cmp	r3, #0
 801275e:	d001      	beq.n	8012764 <wc_AesCbcDecrypt+0x72>
                    return ret;
 8012760:	693b      	ldr	r3, [r7, #16]
 8012762:	e01c      	b.n	801279e <wc_AesCbcDecrypt+0xac>
                xorbuf(out, (byte*)aes->reg, WC_AES_BLOCK_SIZE);
 8012764:	68fb      	ldr	r3, [r7, #12]
 8012766:	33f8      	adds	r3, #248	@ 0xf8
 8012768:	2210      	movs	r2, #16
 801276a:	4619      	mov	r1, r3
 801276c:	68b8      	ldr	r0, [r7, #8]
 801276e:	f7fd f856 	bl	800f81e <xorbuf>
                /* store iv for next call */
                XMEMCPY(aes->reg, aes->tmp, WC_AES_BLOCK_SIZE);
 8012772:	68fb      	ldr	r3, [r7, #12]
 8012774:	f103 00f8 	add.w	r0, r3, #248	@ 0xf8
 8012778:	68fb      	ldr	r3, [r7, #12]
 801277a:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 801277e:	2210      	movs	r2, #16
 8012780:	4619      	mov	r1, r3
 8012782:	f016 fb00 	bl	8028d86 <memcpy>

                out += WC_AES_BLOCK_SIZE;
 8012786:	68bb      	ldr	r3, [r7, #8]
 8012788:	3310      	adds	r3, #16
 801278a:	60bb      	str	r3, [r7, #8]
                in  += WC_AES_BLOCK_SIZE;
 801278c:	687b      	ldr	r3, [r7, #4]
 801278e:	3310      	adds	r3, #16
 8012790:	607b      	str	r3, [r7, #4]
            while (blocks--) {
 8012792:	697b      	ldr	r3, [r7, #20]
 8012794:	1e5a      	subs	r2, r3, #1
 8012796:	617a      	str	r2, [r7, #20]
 8012798:	2b00      	cmp	r3, #0
 801279a:	d1d0      	bne.n	801273e <wc_AesCbcDecrypt+0x4c>
#endif
        }

        VECTOR_REGISTERS_POP;

        return ret;
 801279c:	693b      	ldr	r3, [r7, #16]
    }
 801279e:	4618      	mov	r0, r3
 80127a0:	3718      	adds	r7, #24
 80127a2:	46bd      	mov	sp, r7
 80127a4:	bd80      	pop	{r7, pc}

080127a6 <wc_AesInit>:
}
#endif /* !WC_NO_CONSTRUCTORS */

/* Initialize Aes */
int wc_AesInit(Aes* aes, void* heap, int devId)
{
 80127a6:	b580      	push	{r7, lr}
 80127a8:	b086      	sub	sp, #24
 80127aa:	af00      	add	r7, sp, #0
 80127ac:	60f8      	str	r0, [r7, #12]
 80127ae:	60b9      	str	r1, [r7, #8]
 80127b0:	607a      	str	r2, [r7, #4]
    int ret = 0;
 80127b2:	2300      	movs	r3, #0
 80127b4:	617b      	str	r3, [r7, #20]

    if (aes == NULL)
 80127b6:	68fb      	ldr	r3, [r7, #12]
 80127b8:	2b00      	cmp	r3, #0
 80127ba:	d102      	bne.n	80127c2 <wc_AesInit+0x1c>
        return BAD_FUNC_ARG;
 80127bc:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80127c0:	e00a      	b.n	80127d8 <wc_AesInit+0x32>

    XMEMSET(aes, 0, sizeof(*aes));
 80127c2:	f44f 72a6 	mov.w	r2, #332	@ 0x14c
 80127c6:	2100      	movs	r1, #0
 80127c8:	68f8      	ldr	r0, [r7, #12]
 80127ca:	f016 fa2b 	bl	8028c24 <memset>

    aes->heap = heap;
 80127ce:	68fb      	ldr	r3, [r7, #12]
 80127d0:	68ba      	ldr	r2, [r7, #8]
 80127d2:	f8c3 2148 	str.w	r2, [r3, #328]	@ 0x148
#ifdef WC_DEBUG_CIPHER_LIFECYCLE
    if (ret == 0)
        ret = wc_debug_CipherLifecycleInit(&aes->CipherLifecycleTag, aes->heap);
#endif

    return ret;
 80127d6:	697b      	ldr	r3, [r7, #20]
}
 80127d8:	4618      	mov	r0, r3
 80127da:	3718      	adds	r7, #24
 80127dc:	46bd      	mov	sp, r7
 80127de:	bd80      	pop	{r7, pc}

080127e0 <wc_AesFree>:
}
#endif

/* Free Aes resources */
void wc_AesFree(Aes* aes)
{
 80127e0:	b580      	push	{r7, lr}
 80127e2:	b082      	sub	sp, #8
 80127e4:	af00      	add	r7, sp, #0
 80127e6:	6078      	str	r0, [r7, #4]
    if (aes == NULL) {
 80127e8:	687b      	ldr	r3, [r7, #4]
 80127ea:	2b00      	cmp	r3, #0
 80127ec:	d005      	beq.n	80127fa <wc_AesFree+0x1a>
    defined(WOLFSSL_RENESAS_FSPSM_CRYPTONLY)) && \
    !defined(NO_WOLFSSL_RENESAS_FSPSM_AES))
    wc_fspsm_Aesfree(aes);
#endif

    ForceZero(aes, sizeof(Aes));
 80127ee:	f44f 71a6 	mov.w	r1, #332	@ 0x14c
 80127f2:	6878      	ldr	r0, [r7, #4]
 80127f4:	f7fd f86d 	bl	800f8d2 <ForceZero>
 80127f8:	e000      	b.n	80127fc <wc_AesFree+0x1c>
        return;
 80127fa:	bf00      	nop

#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(aes, sizeof(Aes));
#endif
}
 80127fc:	3708      	adds	r7, #8
 80127fe:	46bd      	mov	sp, r7
 8012800:	bd80      	pop	{r7, pc}

08012802 <ForceZero>:
{
 8012802:	b480      	push	{r7}
 8012804:	b085      	sub	sp, #20
 8012806:	af00      	add	r7, sp, #0
 8012808:	6078      	str	r0, [r7, #4]
 801280a:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801280c:	687b      	ldr	r3, [r7, #4]
 801280e:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 8012810:	e004      	b.n	801281c <ForceZero+0x1a>
 8012812:	68fb      	ldr	r3, [r7, #12]
 8012814:	1c5a      	adds	r2, r3, #1
 8012816:	60fa      	str	r2, [r7, #12]
 8012818:	2200      	movs	r2, #0
 801281a:	701a      	strb	r2, [r3, #0]
 801281c:	683b      	ldr	r3, [r7, #0]
 801281e:	1e5a      	subs	r2, r3, #1
 8012820:	603a      	str	r2, [r7, #0]
 8012822:	2b00      	cmp	r3, #0
 8012824:	d1f5      	bne.n	8012812 <ForceZero+0x10>
}
 8012826:	bf00      	nop
 8012828:	bf00      	nop
 801282a:	3714      	adds	r7, #20
 801282c:	46bd      	mov	sp, r7
 801282e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012832:	4770      	bx	lr

08012834 <min>:
    {
 8012834:	b480      	push	{r7}
 8012836:	b083      	sub	sp, #12
 8012838:	af00      	add	r7, sp, #0
 801283a:	6078      	str	r0, [r7, #4]
 801283c:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 801283e:	687a      	ldr	r2, [r7, #4]
 8012840:	683b      	ldr	r3, [r7, #0]
 8012842:	4293      	cmp	r3, r2
 8012844:	bf28      	it	cs
 8012846:	4613      	movcs	r3, r2
    }
 8012848:	4618      	mov	r0, r3
 801284a:	370c      	adds	r7, #12
 801284c:	46bd      	mov	sp, r7
 801284e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012852:	4770      	bx	lr

08012854 <CopyString>:
}
#endif /* WOLFCRYPT_ONLY && !NO_HASH_WRAPPER &&
        * (!NO_SESSION_CACHE || HAVE_SESSION_TICKET) */

WC_MISC_STATIC WC_INLINE char* CopyString(const char* src, int srcLen,
        void* heap, int type) {
 8012854:	b580      	push	{r7, lr}
 8012856:	b086      	sub	sp, #24
 8012858:	af00      	add	r7, sp, #0
 801285a:	60f8      	str	r0, [r7, #12]
 801285c:	60b9      	str	r1, [r7, #8]
 801285e:	607a      	str	r2, [r7, #4]
 8012860:	603b      	str	r3, [r7, #0]
    char* dst = NULL;
 8012862:	2300      	movs	r3, #0
 8012864:	617b      	str	r3, [r7, #20]

    if (src == NULL)
 8012866:	68fb      	ldr	r3, [r7, #12]
 8012868:	2b00      	cmp	r3, #0
 801286a:	d101      	bne.n	8012870 <CopyString+0x1c>
        return NULL;
 801286c:	2300      	movs	r3, #0
 801286e:	e01c      	b.n	80128aa <CopyString+0x56>

    if (srcLen <= 0)
 8012870:	68bb      	ldr	r3, [r7, #8]
 8012872:	2b00      	cmp	r3, #0
 8012874:	dc04      	bgt.n	8012880 <CopyString+0x2c>
        srcLen = (int)XSTRLEN(src);
 8012876:	68f8      	ldr	r0, [r7, #12]
 8012878:	f7ed fcb4 	bl	80001e4 <strlen>
 801287c:	4603      	mov	r3, r0
 801287e:	60bb      	str	r3, [r7, #8]

    dst = (char*)XMALLOC((size_t)srcLen + 1, heap, type);
 8012880:	68bb      	ldr	r3, [r7, #8]
 8012882:	3301      	adds	r3, #1
 8012884:	4618      	mov	r0, r3
 8012886:	f00c f9f9 	bl	801ec7c <wolfSSL_Malloc>
 801288a:	6178      	str	r0, [r7, #20]
    if (dst != NULL) {
 801288c:	697b      	ldr	r3, [r7, #20]
 801288e:	2b00      	cmp	r3, #0
 8012890:	d00a      	beq.n	80128a8 <CopyString+0x54>
        XMEMCPY(dst, src, (size_t)srcLen);
 8012892:	68bb      	ldr	r3, [r7, #8]
 8012894:	461a      	mov	r2, r3
 8012896:	68f9      	ldr	r1, [r7, #12]
 8012898:	6978      	ldr	r0, [r7, #20]
 801289a:	f016 fa74 	bl	8028d86 <memcpy>
        dst[srcLen] = '\0';
 801289e:	68bb      	ldr	r3, [r7, #8]
 80128a0:	697a      	ldr	r2, [r7, #20]
 80128a2:	4413      	add	r3, r2
 80128a4:	2200      	movs	r2, #0
 80128a6:	701a      	strb	r2, [r3, #0]
    }

    return dst;
 80128a8:	697b      	ldr	r3, [r7, #20]
}
 80128aa:	4618      	mov	r0, r3
 80128ac:	3718      	adds	r7, #24
 80128ae:	46bd      	mov	sp, r7
 80128b0:	bd80      	pop	{r7, pc}

080128b2 <BytePrecision>:
 *
 * @param [in] value  Value to be encoded.
 * @return  Number of bytes to encode value.
 */
static word32 BytePrecision(word32 value)
{
 80128b2:	b480      	push	{r7}
 80128b4:	b085      	sub	sp, #20
 80128b6:	af00      	add	r7, sp, #0
 80128b8:	6078      	str	r0, [r7, #4]
    word32 i;
    for (i = (word32)sizeof(value); i; --i)
 80128ba:	2304      	movs	r3, #4
 80128bc:	60fb      	str	r3, [r7, #12]
 80128be:	e00a      	b.n	80128d6 <BytePrecision+0x24>
        if (value >> ((i - 1) * WOLFSSL_BIT_SIZE))
 80128c0:	68fb      	ldr	r3, [r7, #12]
 80128c2:	3b01      	subs	r3, #1
 80128c4:	00db      	lsls	r3, r3, #3
 80128c6:	687a      	ldr	r2, [r7, #4]
 80128c8:	fa22 f303 	lsr.w	r3, r2, r3
 80128cc:	2b00      	cmp	r3, #0
 80128ce:	d106      	bne.n	80128de <BytePrecision+0x2c>
    for (i = (word32)sizeof(value); i; --i)
 80128d0:	68fb      	ldr	r3, [r7, #12]
 80128d2:	3b01      	subs	r3, #1
 80128d4:	60fb      	str	r3, [r7, #12]
 80128d6:	68fb      	ldr	r3, [r7, #12]
 80128d8:	2b00      	cmp	r3, #0
 80128da:	d1f1      	bne.n	80128c0 <BytePrecision+0xe>
 80128dc:	e000      	b.n	80128e0 <BytePrecision+0x2e>
            break;
 80128de:	bf00      	nop

    return i;
 80128e0:	68fb      	ldr	r3, [r7, #12]
}
 80128e2:	4618      	mov	r0, r3
 80128e4:	3714      	adds	r7, #20
 80128e6:	46bd      	mov	sp, r7
 80128e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128ec:	4770      	bx	lr

080128ee <SetASNLength>:
 * @param [in]      length  Value to encode.
 * @param [in, out] output  Buffer to encode into.
 * @return  Number of bytes used in encoding.
 */
WOLFSSL_LOCAL word32 SetASNLength(word32 length, byte* output)
{
 80128ee:	b580      	push	{r7, lr}
 80128f0:	b084      	sub	sp, #16
 80128f2:	af00      	add	r7, sp, #0
 80128f4:	6078      	str	r0, [r7, #4]
 80128f6:	6039      	str	r1, [r7, #0]
    word32 i = 0;
 80128f8:	2300      	movs	r3, #0
 80128fa:	60fb      	str	r3, [r7, #12]

    if (length < ASN_LONG_LENGTH)
 80128fc:	687b      	ldr	r3, [r7, #4]
 80128fe:	2b7f      	cmp	r3, #127	@ 0x7f
 8012900:	d808      	bhi.n	8012914 <SetASNLength+0x26>
        output[i++] = (byte)length;
 8012902:	68fb      	ldr	r3, [r7, #12]
 8012904:	1c5a      	adds	r2, r3, #1
 8012906:	60fa      	str	r2, [r7, #12]
 8012908:	683a      	ldr	r2, [r7, #0]
 801290a:	4413      	add	r3, r2
 801290c:	687a      	ldr	r2, [r7, #4]
 801290e:	b2d2      	uxtb	r2, r2
 8012910:	701a      	strb	r2, [r3, #0]
 8012912:	e026      	b.n	8012962 <SetASNLength+0x74>
    else {
        word32 j;

        output[i++] = (byte)(BytePrecision(length) | ASN_LONG_LENGTH);
 8012914:	6878      	ldr	r0, [r7, #4]
 8012916:	f7ff ffcc 	bl	80128b2 <BytePrecision>
 801291a:	4603      	mov	r3, r0
 801291c:	b2da      	uxtb	r2, r3
 801291e:	68fb      	ldr	r3, [r7, #12]
 8012920:	1c59      	adds	r1, r3, #1
 8012922:	60f9      	str	r1, [r7, #12]
 8012924:	6839      	ldr	r1, [r7, #0]
 8012926:	440b      	add	r3, r1
 8012928:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 801292c:	b2d2      	uxtb	r2, r2
 801292e:	701a      	strb	r2, [r3, #0]

        for (j = BytePrecision(length); j; --j) {
 8012930:	6878      	ldr	r0, [r7, #4]
 8012932:	f7ff ffbe 	bl	80128b2 <BytePrecision>
 8012936:	60b8      	str	r0, [r7, #8]
 8012938:	e010      	b.n	801295c <SetASNLength+0x6e>
            output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));
 801293a:	68bb      	ldr	r3, [r7, #8]
 801293c:	3b01      	subs	r3, #1
 801293e:	00db      	lsls	r3, r3, #3
 8012940:	687a      	ldr	r2, [r7, #4]
 8012942:	fa22 f103 	lsr.w	r1, r2, r3
 8012946:	683a      	ldr	r2, [r7, #0]
 8012948:	68fb      	ldr	r3, [r7, #12]
 801294a:	4413      	add	r3, r2
 801294c:	b2ca      	uxtb	r2, r1
 801294e:	701a      	strb	r2, [r3, #0]
            i++;
 8012950:	68fb      	ldr	r3, [r7, #12]
 8012952:	3301      	adds	r3, #1
 8012954:	60fb      	str	r3, [r7, #12]
        for (j = BytePrecision(length); j; --j) {
 8012956:	68bb      	ldr	r3, [r7, #8]
 8012958:	3b01      	subs	r3, #1
 801295a:	60bb      	str	r3, [r7, #8]
 801295c:	68bb      	ldr	r3, [r7, #8]
 801295e:	2b00      	cmp	r3, #0
 8012960:	d1eb      	bne.n	801293a <SetASNLength+0x4c>
        }
    }

    return i;
 8012962:	68fb      	ldr	r3, [r7, #12]
}
 8012964:	4618      	mov	r0, r3
 8012966:	3710      	adds	r7, #16
 8012968:	46bd      	mov	sp, r7
 801296a:	bd80      	pop	{r7, pc}

0801296c <SizeASNLength>:
 *
 * @param [in] length  Value to encode.
 * @return  Number of bytes required to encode.
 */
static word32 SizeASNLength(word32 length)
{
 801296c:	b580      	push	{r7, lr}
 801296e:	b082      	sub	sp, #8
 8012970:	af00      	add	r7, sp, #0
 8012972:	6078      	str	r0, [r7, #4]
    return 1 + ((length >= ASN_LONG_LENGTH) ? BytePrecision(length) : 0);
 8012974:	687b      	ldr	r3, [r7, #4]
 8012976:	2b7f      	cmp	r3, #127	@ 0x7f
 8012978:	d905      	bls.n	8012986 <SizeASNLength+0x1a>
 801297a:	6878      	ldr	r0, [r7, #4]
 801297c:	f7ff ff99 	bl	80128b2 <BytePrecision>
 8012980:	4603      	mov	r3, r0
 8012982:	3301      	adds	r3, #1
 8012984:	e000      	b.n	8012988 <SizeASNLength+0x1c>
 8012986:	2301      	movs	r3, #1
}
 8012988:	4618      	mov	r0, r3
 801298a:	3708      	adds	r7, #8
 801298c:	46bd      	mov	sp, r7
 801298e:	bd80      	pop	{r7, pc}

08012990 <SizeASN_Num>:
 * @param [in] bits  Maximum number of bits to encode.
 * @param [in] tag   BER tag e.g. INTEGER, BIT_STRING, etc.
 * @return  Number of bytes to the ASN.1 item.
 */
static word32 SizeASN_Num(word32 n, int bits, byte tag)
{
 8012990:	b480      	push	{r7}
 8012992:	b087      	sub	sp, #28
 8012994:	af00      	add	r7, sp, #0
 8012996:	60f8      	str	r0, [r7, #12]
 8012998:	60b9      	str	r1, [r7, #8]
 801299a:	4613      	mov	r3, r2
 801299c:	71fb      	strb	r3, [r7, #7]
    int    j;
    word32 len;

    len = 1 + 1 + (word32)bits / 8;
 801299e:	68bb      	ldr	r3, [r7, #8]
 80129a0:	08db      	lsrs	r3, r3, #3
 80129a2:	3302      	adds	r3, #2
 80129a4:	613b      	str	r3, [r7, #16]
    /* Discover actual size by checking for high zeros. */
    for (j = bits - 8; j > 0; j -= 8) {
 80129a6:	68bb      	ldr	r3, [r7, #8]
 80129a8:	3b08      	subs	r3, #8
 80129aa:	617b      	str	r3, [r7, #20]
 80129ac:	e00b      	b.n	80129c6 <SizeASN_Num+0x36>
        if (n >> j)
 80129ae:	68fa      	ldr	r2, [r7, #12]
 80129b0:	697b      	ldr	r3, [r7, #20]
 80129b2:	fa22 f303 	lsr.w	r3, r2, r3
 80129b6:	2b00      	cmp	r3, #0
 80129b8:	d109      	bne.n	80129ce <SizeASN_Num+0x3e>
            break;
        len--;
 80129ba:	693b      	ldr	r3, [r7, #16]
 80129bc:	3b01      	subs	r3, #1
 80129be:	613b      	str	r3, [r7, #16]
    for (j = bits - 8; j > 0; j -= 8) {
 80129c0:	697b      	ldr	r3, [r7, #20]
 80129c2:	3b08      	subs	r3, #8
 80129c4:	617b      	str	r3, [r7, #20]
 80129c6:	697b      	ldr	r3, [r7, #20]
 80129c8:	2b00      	cmp	r3, #0
 80129ca:	dcf0      	bgt.n	80129ae <SizeASN_Num+0x1e>
 80129cc:	e000      	b.n	80129d0 <SizeASN_Num+0x40>
            break;
 80129ce:	bf00      	nop
    }
    if (tag == ASN_BIT_STRING)
 80129d0:	79fb      	ldrb	r3, [r7, #7]
 80129d2:	2b03      	cmp	r3, #3
 80129d4:	d103      	bne.n	80129de <SizeASN_Num+0x4e>
        len++;
 80129d6:	693b      	ldr	r3, [r7, #16]
 80129d8:	3301      	adds	r3, #1
 80129da:	613b      	str	r3, [r7, #16]
 80129dc:	e00d      	b.n	80129fa <SizeASN_Num+0x6a>
    else if ((tag == ASN_INTEGER) && (((n >> j) & 0x80) == 0x80))
 80129de:	79fb      	ldrb	r3, [r7, #7]
 80129e0:	2b02      	cmp	r3, #2
 80129e2:	d10a      	bne.n	80129fa <SizeASN_Num+0x6a>
 80129e4:	68fa      	ldr	r2, [r7, #12]
 80129e6:	697b      	ldr	r3, [r7, #20]
 80129e8:	fa22 f303 	lsr.w	r3, r2, r3
 80129ec:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80129f0:	2b00      	cmp	r3, #0
 80129f2:	d002      	beq.n	80129fa <SizeASN_Num+0x6a>
        len++;
 80129f4:	693b      	ldr	r3, [r7, #16]
 80129f6:	3301      	adds	r3, #1
 80129f8:	613b      	str	r3, [r7, #16]

    return len;
 80129fa:	693b      	ldr	r3, [r7, #16]
}
 80129fc:	4618      	mov	r0, r3
 80129fe:	371c      	adds	r7, #28
 8012a00:	46bd      	mov	sp, r7
 8012a02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012a06:	4770      	bx	lr

08012a08 <SizeASN_CalcDataLength>:
 *                         known.
 * @param [in]      idx    Index of item working on.
 */
static void SizeASN_CalcDataLength(const ASNItem* asn, ASNSetData *data,
                                   int idx, int maxIdx)
{
 8012a08:	b480      	push	{r7}
 8012a0a:	b087      	sub	sp, #28
 8012a0c:	af00      	add	r7, sp, #0
 8012a0e:	60f8      	str	r0, [r7, #12]
 8012a10:	60b9      	str	r1, [r7, #8]
 8012a12:	607a      	str	r2, [r7, #4]
 8012a14:	603b      	str	r3, [r7, #0]
    int j;

    data[idx].data.buffer.length = 0;
 8012a16:	687a      	ldr	r2, [r7, #4]
 8012a18:	4613      	mov	r3, r2
 8012a1a:	009b      	lsls	r3, r3, #2
 8012a1c:	4413      	add	r3, r2
 8012a1e:	009b      	lsls	r3, r3, #2
 8012a20:	461a      	mov	r2, r3
 8012a22:	68bb      	ldr	r3, [r7, #8]
 8012a24:	4413      	add	r3, r2
 8012a26:	2200      	movs	r2, #0
 8012a28:	60da      	str	r2, [r3, #12]
    /* Sum the item length of all items underneath. */
    for (j = idx + 1; j < maxIdx; j++) {
 8012a2a:	687b      	ldr	r3, [r7, #4]
 8012a2c:	3301      	adds	r3, #1
 8012a2e:	617b      	str	r3, [r7, #20]
 8012a30:	e073      	b.n	8012b1a <SizeASN_CalcDataLength+0x112>
        /* Stop looking if the next ASN.1 is same level or higher. */
        if (asn[j].depth <= asn[idx].depth)
 8012a32:	697b      	ldr	r3, [r7, #20]
 8012a34:	009b      	lsls	r3, r3, #2
 8012a36:	68fa      	ldr	r2, [r7, #12]
 8012a38:	4413      	add	r3, r2
 8012a3a:	781a      	ldrb	r2, [r3, #0]
 8012a3c:	687b      	ldr	r3, [r7, #4]
 8012a3e:	009b      	lsls	r3, r3, #2
 8012a40:	68f9      	ldr	r1, [r7, #12]
 8012a42:	440b      	add	r3, r1
 8012a44:	781b      	ldrb	r3, [r3, #0]
 8012a46:	429a      	cmp	r2, r3
 8012a48:	d96c      	bls.n	8012b24 <SizeASN_CalcDataLength+0x11c>
            break;
        /* Only add in length if it is one level below. */
        if (asn[j].depth - 1 == asn[idx].depth) {
 8012a4a:	697b      	ldr	r3, [r7, #20]
 8012a4c:	009b      	lsls	r3, r3, #2
 8012a4e:	68fa      	ldr	r2, [r7, #12]
 8012a50:	4413      	add	r3, r2
 8012a52:	781b      	ldrb	r3, [r3, #0]
 8012a54:	3b01      	subs	r3, #1
 8012a56:	687a      	ldr	r2, [r7, #4]
 8012a58:	0092      	lsls	r2, r2, #2
 8012a5a:	68f9      	ldr	r1, [r7, #12]
 8012a5c:	440a      	add	r2, r1
 8012a5e:	7812      	ldrb	r2, [r2, #0]
 8012a60:	4293      	cmp	r3, r2
 8012a62:	d157      	bne.n	8012b14 <SizeASN_CalcDataLength+0x10c>
            data[idx].data.buffer.length += data[j].length;
 8012a64:	687a      	ldr	r2, [r7, #4]
 8012a66:	4613      	mov	r3, r2
 8012a68:	009b      	lsls	r3, r3, #2
 8012a6a:	4413      	add	r3, r2
 8012a6c:	009b      	lsls	r3, r3, #2
 8012a6e:	461a      	mov	r2, r3
 8012a70:	68bb      	ldr	r3, [r7, #8]
 8012a72:	4413      	add	r3, r2
 8012a74:	68d8      	ldr	r0, [r3, #12]
 8012a76:	697a      	ldr	r2, [r7, #20]
 8012a78:	4613      	mov	r3, r2
 8012a7a:	009b      	lsls	r3, r3, #2
 8012a7c:	4413      	add	r3, r2
 8012a7e:	009b      	lsls	r3, r3, #2
 8012a80:	461a      	mov	r2, r3
 8012a82:	68bb      	ldr	r3, [r7, #8]
 8012a84:	4413      	add	r3, r2
 8012a86:	6859      	ldr	r1, [r3, #4]
 8012a88:	687a      	ldr	r2, [r7, #4]
 8012a8a:	4613      	mov	r3, r2
 8012a8c:	009b      	lsls	r3, r3, #2
 8012a8e:	4413      	add	r3, r2
 8012a90:	009b      	lsls	r3, r3, #2
 8012a92:	461a      	mov	r2, r3
 8012a94:	68bb      	ldr	r3, [r7, #8]
 8012a96:	4413      	add	r3, r2
 8012a98:	1842      	adds	r2, r0, r1
 8012a9a:	60da      	str	r2, [r3, #12]
            /* The length of a header only item doesn't include the data unless
             * a replacement buffer is supplied.
             */
            if (asn[j].headerOnly && data[j].data.buffer.data == NULL &&
 8012a9c:	697b      	ldr	r3, [r7, #20]
 8012a9e:	009b      	lsls	r3, r3, #2
 8012aa0:	68fa      	ldr	r2, [r7, #12]
 8012aa2:	4413      	add	r3, r2
 8012aa4:	789b      	ldrb	r3, [r3, #2]
 8012aa6:	f003 0302 	and.w	r3, r3, #2
 8012aaa:	b2db      	uxtb	r3, r3
 8012aac:	2b00      	cmp	r3, #0
 8012aae:	d031      	beq.n	8012b14 <SizeASN_CalcDataLength+0x10c>
 8012ab0:	697a      	ldr	r2, [r7, #20]
 8012ab2:	4613      	mov	r3, r2
 8012ab4:	009b      	lsls	r3, r3, #2
 8012ab6:	4413      	add	r3, r2
 8012ab8:	009b      	lsls	r3, r3, #2
 8012aba:	461a      	mov	r2, r3
 8012abc:	68bb      	ldr	r3, [r7, #8]
 8012abe:	4413      	add	r3, r2
 8012ac0:	689b      	ldr	r3, [r3, #8]
 8012ac2:	2b00      	cmp	r3, #0
 8012ac4:	d126      	bne.n	8012b14 <SizeASN_CalcDataLength+0x10c>
                    data[j].dataType != ASN_DATA_TYPE_REPLACE_BUFFER) {
 8012ac6:	697a      	ldr	r2, [r7, #20]
 8012ac8:	4613      	mov	r3, r2
 8012aca:	009b      	lsls	r3, r3, #2
 8012acc:	4413      	add	r3, r2
 8012ace:	009b      	lsls	r3, r3, #2
 8012ad0:	461a      	mov	r2, r3
 8012ad2:	68bb      	ldr	r3, [r7, #8]
 8012ad4:	4413      	add	r3, r2
 8012ad6:	7c1b      	ldrb	r3, [r3, #16]
            if (asn[j].headerOnly && data[j].data.buffer.data == NULL &&
 8012ad8:	2b07      	cmp	r3, #7
 8012ada:	d01b      	beq.n	8012b14 <SizeASN_CalcDataLength+0x10c>
                data[idx].data.buffer.length += data[j].data.buffer.length;
 8012adc:	687a      	ldr	r2, [r7, #4]
 8012ade:	4613      	mov	r3, r2
 8012ae0:	009b      	lsls	r3, r3, #2
 8012ae2:	4413      	add	r3, r2
 8012ae4:	009b      	lsls	r3, r3, #2
 8012ae6:	461a      	mov	r2, r3
 8012ae8:	68bb      	ldr	r3, [r7, #8]
 8012aea:	4413      	add	r3, r2
 8012aec:	68d8      	ldr	r0, [r3, #12]
 8012aee:	697a      	ldr	r2, [r7, #20]
 8012af0:	4613      	mov	r3, r2
 8012af2:	009b      	lsls	r3, r3, #2
 8012af4:	4413      	add	r3, r2
 8012af6:	009b      	lsls	r3, r3, #2
 8012af8:	461a      	mov	r2, r3
 8012afa:	68bb      	ldr	r3, [r7, #8]
 8012afc:	4413      	add	r3, r2
 8012afe:	68d9      	ldr	r1, [r3, #12]
 8012b00:	687a      	ldr	r2, [r7, #4]
 8012b02:	4613      	mov	r3, r2
 8012b04:	009b      	lsls	r3, r3, #2
 8012b06:	4413      	add	r3, r2
 8012b08:	009b      	lsls	r3, r3, #2
 8012b0a:	461a      	mov	r2, r3
 8012b0c:	68bb      	ldr	r3, [r7, #8]
 8012b0e:	4413      	add	r3, r2
 8012b10:	1842      	adds	r2, r0, r1
 8012b12:	60da      	str	r2, [r3, #12]
    for (j = idx + 1; j < maxIdx; j++) {
 8012b14:	697b      	ldr	r3, [r7, #20]
 8012b16:	3301      	adds	r3, #1
 8012b18:	617b      	str	r3, [r7, #20]
 8012b1a:	697a      	ldr	r2, [r7, #20]
 8012b1c:	683b      	ldr	r3, [r7, #0]
 8012b1e:	429a      	cmp	r2, r3
 8012b20:	db87      	blt.n	8012a32 <SizeASN_CalcDataLength+0x2a>
            }
        }
    }
}
 8012b22:	e000      	b.n	8012b26 <SizeASN_CalcDataLength+0x11e>
            break;
 8012b24:	bf00      	nop
}
 8012b26:	bf00      	nop
 8012b28:	371c      	adds	r7, #28
 8012b2a:	46bd      	mov	sp, r7
 8012b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012b30:	4770      	bx	lr
	...

08012b34 <SizeASN_Items>:
 * @param [out]     encSz  Length of the DER encoding.
 * @return  0 on success.
 * @return  BAD_STATE_E when the data type is not supported.
 */
int SizeASN_Items(const ASNItem* asn, ASNSetData *data, int count, int* encSz)
{
 8012b34:	b580      	push	{r7, lr}
 8012b36:	b08a      	sub	sp, #40	@ 0x28
 8012b38:	af00      	add	r7, sp, #0
 8012b3a:	60f8      	str	r0, [r7, #12]
 8012b3c:	60b9      	str	r1, [r7, #8]
 8012b3e:	607a      	str	r2, [r7, #4]
 8012b40:	603b      	str	r3, [r7, #0]
    int    i;
    word32 sz = 0;
 8012b42:	2300      	movs	r3, #0
 8012b44:	623b      	str	r3, [r7, #32]

#ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
    WOLFSSL_ENTER("SizeASN_Items");
#endif

    for (i = count - 1; i >= 0; i--) {
 8012b46:	687b      	ldr	r3, [r7, #4]
 8012b48:	3b01      	subs	r3, #1
 8012b4a:	627b      	str	r3, [r7, #36]	@ 0x24
 8012b4c:	e16c      	b.n	8012e28 <SizeASN_Items+0x2f4>
        /* Skip this ASN.1 item when encoding. */
        if (data[i].noOut) {
 8012b4e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012b50:	4613      	mov	r3, r2
 8012b52:	009b      	lsls	r3, r3, #2
 8012b54:	4413      	add	r3, r2
 8012b56:	009b      	lsls	r3, r3, #2
 8012b58:	461a      	mov	r2, r3
 8012b5a:	68bb      	ldr	r3, [r7, #8]
 8012b5c:	4413      	add	r3, r2
 8012b5e:	7c5b      	ldrb	r3, [r3, #17]
 8012b60:	2b00      	cmp	r3, #0
 8012b62:	d00a      	beq.n	8012b7a <SizeASN_Items+0x46>
            /* Set the offset to the current size - used in writing DER. */
            data[i].offset = sz;
 8012b64:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012b66:	4613      	mov	r3, r2
 8012b68:	009b      	lsls	r3, r3, #2
 8012b6a:	4413      	add	r3, r2
 8012b6c:	009b      	lsls	r3, r3, #2
 8012b6e:	461a      	mov	r2, r3
 8012b70:	68bb      	ldr	r3, [r7, #8]
 8012b72:	4413      	add	r3, r2
 8012b74:	6a3a      	ldr	r2, [r7, #32]
 8012b76:	601a      	str	r2, [r3, #0]
            continue;
 8012b78:	e153      	b.n	8012e22 <SizeASN_Items+0x2ee>
        }

        len = 0;
 8012b7a:	2300      	movs	r3, #0
 8012b7c:	61fb      	str	r3, [r7, #28]
        switch (data[i].dataType) {
 8012b7e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012b80:	4613      	mov	r3, r2
 8012b82:	009b      	lsls	r3, r3, #2
 8012b84:	4413      	add	r3, r2
 8012b86:	009b      	lsls	r3, r3, #2
 8012b88:	461a      	mov	r2, r3
 8012b8a:	68bb      	ldr	r3, [r7, #8]
 8012b8c:	4413      	add	r3, r2
 8012b8e:	7c1b      	ldrb	r3, [r3, #16]
 8012b90:	2b08      	cmp	r3, #8
 8012b92:	f200 812e 	bhi.w	8012df2 <SizeASN_Items+0x2be>
 8012b96:	a201      	add	r2, pc, #4	@ (adr r2, 8012b9c <SizeASN_Items+0x68>)
 8012b98:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012b9c:	08012c85 	.word	0x08012c85
 8012ba0:	08012bc1 	.word	0x08012bc1
 8012ba4:	08012beb 	.word	0x08012beb
 8012ba8:	08012df3 	.word	0x08012df3
 8012bac:	08012df3 	.word	0x08012df3
 8012bb0:	08012df3 	.word	0x08012df3
 8012bb4:	08012df3 	.word	0x08012df3
 8012bb8:	08012c6f 	.word	0x08012c6f
 8012bbc:	08012c15 	.word	0x08012c15
            /* Calculate the size of the number of different sizes. */
            case ASN_DATA_TYPE_WORD8:
                len = SizeASN_Num(data[i].data.u8, 8, asn[i].tag);
 8012bc0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012bc2:	4613      	mov	r3, r2
 8012bc4:	009b      	lsls	r3, r3, #2
 8012bc6:	4413      	add	r3, r2
 8012bc8:	009b      	lsls	r3, r3, #2
 8012bca:	461a      	mov	r2, r3
 8012bcc:	68bb      	ldr	r3, [r7, #8]
 8012bce:	4413      	add	r3, r2
 8012bd0:	7a1b      	ldrb	r3, [r3, #8]
 8012bd2:	4618      	mov	r0, r3
 8012bd4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012bd6:	009b      	lsls	r3, r3, #2
 8012bd8:	68fa      	ldr	r2, [r7, #12]
 8012bda:	4413      	add	r3, r2
 8012bdc:	785b      	ldrb	r3, [r3, #1]
 8012bde:	461a      	mov	r2, r3
 8012be0:	2108      	movs	r1, #8
 8012be2:	f7ff fed5 	bl	8012990 <SizeASN_Num>
 8012be6:	61f8      	str	r0, [r7, #28]
                break;
 8012be8:	e103      	b.n	8012df2 <SizeASN_Items+0x2be>
            case ASN_DATA_TYPE_WORD16:
                len = SizeASN_Num(data[i].data.u16, 16, asn[i].tag);
 8012bea:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012bec:	4613      	mov	r3, r2
 8012bee:	009b      	lsls	r3, r3, #2
 8012bf0:	4413      	add	r3, r2
 8012bf2:	009b      	lsls	r3, r3, #2
 8012bf4:	461a      	mov	r2, r3
 8012bf6:	68bb      	ldr	r3, [r7, #8]
 8012bf8:	4413      	add	r3, r2
 8012bfa:	891b      	ldrh	r3, [r3, #8]
 8012bfc:	4618      	mov	r0, r3
 8012bfe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012c00:	009b      	lsls	r3, r3, #2
 8012c02:	68fa      	ldr	r2, [r7, #12]
 8012c04:	4413      	add	r3, r2
 8012c06:	785b      	ldrb	r3, [r3, #1]
 8012c08:	461a      	mov	r2, r3
 8012c0a:	2110      	movs	r1, #16
 8012c0c:	f7ff fec0 	bl	8012990 <SizeASN_Num>
 8012c10:	61f8      	str	r0, [r7, #28]
                break;
 8012c12:	e0ee      	b.n	8012df2 <SizeASN_Items+0x2be>
                break;
        #endif

            case ASN_DATA_TYPE_MP:
                /* Calculate the size of the MP integer data. */
                length = mp_unsigned_bin_size(data[i].data.mp);
 8012c14:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c16:	4613      	mov	r3, r2
 8012c18:	009b      	lsls	r3, r3, #2
 8012c1a:	4413      	add	r3, r2
 8012c1c:	009b      	lsls	r3, r3, #2
 8012c1e:	461a      	mov	r2, r3
 8012c20:	68bb      	ldr	r3, [r7, #8]
 8012c22:	4413      	add	r3, r2
 8012c24:	689b      	ldr	r3, [r3, #8]
 8012c26:	4618      	mov	r0, r3
 8012c28:	f014 f886 	bl	8026d38 <mp_unsigned_bin_size>
 8012c2c:	6138      	str	r0, [r7, #16]
                length += mp_leading_bit(data[i].data.mp) ? 1 : 0;
 8012c2e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c30:	4613      	mov	r3, r2
 8012c32:	009b      	lsls	r3, r3, #2
 8012c34:	4413      	add	r3, r2
 8012c36:	009b      	lsls	r3, r3, #2
 8012c38:	461a      	mov	r2, r3
 8012c3a:	68bb      	ldr	r3, [r7, #8]
 8012c3c:	4413      	add	r3, r2
 8012c3e:	689b      	ldr	r3, [r3, #8]
 8012c40:	4618      	mov	r0, r3
 8012c42:	f014 f941 	bl	8026ec8 <mp_leading_bit>
 8012c46:	4603      	mov	r3, r0
 8012c48:	2b00      	cmp	r3, #0
 8012c4a:	bf14      	ite	ne
 8012c4c:	2301      	movne	r3, #1
 8012c4e:	2300      	moveq	r3, #0
 8012c50:	b2db      	uxtb	r3, r3
 8012c52:	461a      	mov	r2, r3
 8012c54:	693b      	ldr	r3, [r7, #16]
 8012c56:	4413      	add	r3, r2
 8012c58:	613b      	str	r3, [r7, #16]
                len = (word32)SizeASNHeader((word32)length) + (word32)length;
 8012c5a:	693b      	ldr	r3, [r7, #16]
 8012c5c:	4618      	mov	r0, r3
 8012c5e:	f7ff fe85 	bl	801296c <SizeASNLength>
 8012c62:	4602      	mov	r2, r0
 8012c64:	693b      	ldr	r3, [r7, #16]
 8012c66:	4413      	add	r3, r2
 8012c68:	3301      	adds	r3, #1
 8012c6a:	61fb      	str	r3, [r7, #28]
                break;
 8012c6c:	e0c1      	b.n	8012df2 <SizeASN_Items+0x2be>

            case ASN_DATA_TYPE_REPLACE_BUFFER:
                /* Buffer is put in directly - use the length. */
                len = data[i].data.buffer.length;
 8012c6e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c70:	4613      	mov	r3, r2
 8012c72:	009b      	lsls	r3, r3, #2
 8012c74:	4413      	add	r3, r2
 8012c76:	009b      	lsls	r3, r3, #2
 8012c78:	461a      	mov	r2, r3
 8012c7a:	68bb      	ldr	r3, [r7, #8]
 8012c7c:	4413      	add	r3, r2
 8012c7e:	68db      	ldr	r3, [r3, #12]
 8012c80:	61fb      	str	r3, [r7, #28]
                break;
 8012c82:	e0b6      	b.n	8012df2 <SizeASN_Items+0x2be>

            case ASN_DATA_TYPE_NONE:
                /* Calculate the size based on the data to be included.
                 * Mostly used for constructed items.
                 */
                if (asn[i].headerOnly) {
 8012c84:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012c86:	009b      	lsls	r3, r3, #2
 8012c88:	68fa      	ldr	r2, [r7, #12]
 8012c8a:	4413      	add	r3, r2
 8012c8c:	789b      	ldrb	r3, [r3, #2]
 8012c8e:	f003 0302 	and.w	r3, r3, #2
 8012c92:	b2db      	uxtb	r3, r3
 8012c94:	2b00      	cmp	r3, #0
 8012c96:	d040      	beq.n	8012d1a <SizeASN_Items+0x1e6>
                    if (data[i].data.buffer.data != NULL) {
 8012c98:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c9a:	4613      	mov	r3, r2
 8012c9c:	009b      	lsls	r3, r3, #2
 8012c9e:	4413      	add	r3, r2
 8012ca0:	009b      	lsls	r3, r3, #2
 8012ca2:	461a      	mov	r2, r3
 8012ca4:	68bb      	ldr	r3, [r7, #8]
 8012ca6:	4413      	add	r3, r2
 8012ca8:	689b      	ldr	r3, [r3, #8]
 8012caa:	2b00      	cmp	r3, #0
 8012cac:	d02d      	beq.n	8012d0a <SizeASN_Items+0x1d6>
                        /* Force all child nodes to be ignored. Buffer
                         * overwrites children. */
                        {
                            int ii;
                            for (ii = i + 1; ii < count; ii++) {
 8012cae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012cb0:	3301      	adds	r3, #1
 8012cb2:	617b      	str	r3, [r7, #20]
 8012cb4:	e024      	b.n	8012d00 <SizeASN_Items+0x1cc>
                                if (asn[ii].depth <= asn[i].depth)
 8012cb6:	697b      	ldr	r3, [r7, #20]
 8012cb8:	009b      	lsls	r3, r3, #2
 8012cba:	68fa      	ldr	r2, [r7, #12]
 8012cbc:	4413      	add	r3, r2
 8012cbe:	781a      	ldrb	r2, [r3, #0]
 8012cc0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012cc2:	009b      	lsls	r3, r3, #2
 8012cc4:	68f9      	ldr	r1, [r7, #12]
 8012cc6:	440b      	add	r3, r1
 8012cc8:	781b      	ldrb	r3, [r3, #0]
 8012cca:	429a      	cmp	r2, r3
 8012ccc:	d924      	bls.n	8012d18 <SizeASN_Items+0x1e4>
                                    break;
                                sz -= data[ii].length;
 8012cce:	697a      	ldr	r2, [r7, #20]
 8012cd0:	4613      	mov	r3, r2
 8012cd2:	009b      	lsls	r3, r3, #2
 8012cd4:	4413      	add	r3, r2
 8012cd6:	009b      	lsls	r3, r3, #2
 8012cd8:	461a      	mov	r2, r3
 8012cda:	68bb      	ldr	r3, [r7, #8]
 8012cdc:	4413      	add	r3, r2
 8012cde:	685b      	ldr	r3, [r3, #4]
 8012ce0:	6a3a      	ldr	r2, [r7, #32]
 8012ce2:	1ad3      	subs	r3, r2, r3
 8012ce4:	623b      	str	r3, [r7, #32]
                                data[ii].noOut = 1;
 8012ce6:	697a      	ldr	r2, [r7, #20]
 8012ce8:	4613      	mov	r3, r2
 8012cea:	009b      	lsls	r3, r3, #2
 8012cec:	4413      	add	r3, r2
 8012cee:	009b      	lsls	r3, r3, #2
 8012cf0:	461a      	mov	r2, r3
 8012cf2:	68bb      	ldr	r3, [r7, #8]
 8012cf4:	4413      	add	r3, r2
 8012cf6:	2201      	movs	r2, #1
 8012cf8:	745a      	strb	r2, [r3, #17]
                            for (ii = i + 1; ii < count; ii++) {
 8012cfa:	697b      	ldr	r3, [r7, #20]
 8012cfc:	3301      	adds	r3, #1
 8012cfe:	617b      	str	r3, [r7, #20]
 8012d00:	697a      	ldr	r2, [r7, #20]
 8012d02:	687b      	ldr	r3, [r7, #4]
 8012d04:	429a      	cmp	r2, r3
 8012d06:	dbd6      	blt.n	8012cb6 <SizeASN_Items+0x182>
 8012d08:	e007      	b.n	8012d1a <SizeASN_Items+0x1e6>
                        }
                    }
                    else {
                        /* Calculate data length from items below if no buffer
                         * supplied. */
                        SizeASN_CalcDataLength(asn, data, i, count);
 8012d0a:	687b      	ldr	r3, [r7, #4]
 8012d0c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012d0e:	68b9      	ldr	r1, [r7, #8]
 8012d10:	68f8      	ldr	r0, [r7, #12]
 8012d12:	f7ff fe79 	bl	8012a08 <SizeASN_CalcDataLength>
 8012d16:	e000      	b.n	8012d1a <SizeASN_Items+0x1e6>
                                    break;
 8012d18:	bf00      	nop
                    }
                }
                if (asn[i].tag == ASN_BOOLEAN) {
 8012d1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012d1c:	009b      	lsls	r3, r3, #2
 8012d1e:	68fa      	ldr	r2, [r7, #12]
 8012d20:	4413      	add	r3, r2
 8012d22:	785b      	ldrb	r3, [r3, #1]
 8012d24:	2b01      	cmp	r3, #1
 8012d26:	d102      	bne.n	8012d2e <SizeASN_Items+0x1fa>
                    dataLen = 1;
 8012d28:	2301      	movs	r3, #1
 8012d2a:	61bb      	str	r3, [r7, #24]
 8012d2c:	e009      	b.n	8012d42 <SizeASN_Items+0x20e>
                }
                else {
                    dataLen = data[i].data.buffer.length;
 8012d2e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012d30:	4613      	mov	r3, r2
 8012d32:	009b      	lsls	r3, r3, #2
 8012d34:	4413      	add	r3, r2
 8012d36:	009b      	lsls	r3, r3, #2
 8012d38:	461a      	mov	r2, r3
 8012d3a:	68bb      	ldr	r3, [r7, #8]
 8012d3c:	4413      	add	r3, r2
 8012d3e:	68db      	ldr	r3, [r3, #12]
 8012d40:	61bb      	str	r3, [r7, #24]
                }
                /* BIT_STRING and INTEGER have one byte prepended. */
                if ((asn[i].tag == ASN_BIT_STRING) ||
 8012d42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012d44:	009b      	lsls	r3, r3, #2
 8012d46:	68fa      	ldr	r2, [r7, #12]
 8012d48:	4413      	add	r3, r2
 8012d4a:	785b      	ldrb	r3, [r3, #1]
 8012d4c:	2b03      	cmp	r3, #3
 8012d4e:	d01e      	beq.n	8012d8e <SizeASN_Items+0x25a>
                                                   ASNIntMSBSet(asn, data, i)) {
 8012d50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012d52:	009b      	lsls	r3, r3, #2
 8012d54:	68fa      	ldr	r2, [r7, #12]
 8012d56:	4413      	add	r3, r2
 8012d58:	785b      	ldrb	r3, [r3, #1]
                if ((asn[i].tag == ASN_BIT_STRING) ||
 8012d5a:	2b02      	cmp	r3, #2
 8012d5c:	d127      	bne.n	8012dae <SizeASN_Items+0x27a>
                                                   ASNIntMSBSet(asn, data, i)) {
 8012d5e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012d60:	4613      	mov	r3, r2
 8012d62:	009b      	lsls	r3, r3, #2
 8012d64:	4413      	add	r3, r2
 8012d66:	009b      	lsls	r3, r3, #2
 8012d68:	461a      	mov	r2, r3
 8012d6a:	68bb      	ldr	r3, [r7, #8]
 8012d6c:	4413      	add	r3, r2
 8012d6e:	689b      	ldr	r3, [r3, #8]
 8012d70:	2b00      	cmp	r3, #0
 8012d72:	d01c      	beq.n	8012dae <SizeASN_Items+0x27a>
 8012d74:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012d76:	4613      	mov	r3, r2
 8012d78:	009b      	lsls	r3, r3, #2
 8012d7a:	4413      	add	r3, r2
 8012d7c:	009b      	lsls	r3, r3, #2
 8012d7e:	461a      	mov	r2, r3
 8012d80:	68bb      	ldr	r3, [r7, #8]
 8012d82:	4413      	add	r3, r2
 8012d84:	689b      	ldr	r3, [r3, #8]
 8012d86:	781b      	ldrb	r3, [r3, #0]
 8012d88:	b25b      	sxtb	r3, r3
 8012d8a:	2b00      	cmp	r3, #0
 8012d8c:	da0f      	bge.n	8012dae <SizeASN_Items+0x27a>
                    dataLen++;
 8012d8e:	69bb      	ldr	r3, [r7, #24]
 8012d90:	3301      	adds	r3, #1
 8012d92:	61bb      	str	r3, [r7, #24]
                    /* ASN.1 items are below and cannot include extra byte. */
                    if (asn[i].headerOnly) {
 8012d94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012d96:	009b      	lsls	r3, r3, #2
 8012d98:	68fa      	ldr	r2, [r7, #12]
 8012d9a:	4413      	add	r3, r2
 8012d9c:	789b      	ldrb	r3, [r3, #2]
 8012d9e:	f003 0302 	and.w	r3, r3, #2
 8012da2:	b2db      	uxtb	r3, r3
 8012da4:	2b00      	cmp	r3, #0
 8012da6:	d002      	beq.n	8012dae <SizeASN_Items+0x27a>
                        len++;
 8012da8:	69fb      	ldr	r3, [r7, #28]
 8012daa:	3301      	adds	r3, #1
 8012dac:	61fb      	str	r3, [r7, #28]
                    }
                }
                /* Add in the size of tag and length. */
                len += SizeASNHeader(dataLen);
 8012dae:	69b8      	ldr	r0, [r7, #24]
 8012db0:	f7ff fddc 	bl	801296c <SizeASNLength>
 8012db4:	4603      	mov	r3, r0
 8012db6:	3301      	adds	r3, #1
 8012db8:	69fa      	ldr	r2, [r7, #28]
 8012dba:	4413      	add	r3, r2
 8012dbc:	61fb      	str	r3, [r7, #28]
                /* Include data in length if not header only or if
                 * buffer supplied. */
                if (!asn[i].headerOnly || data[i].data.buffer.data != NULL) {
 8012dbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012dc0:	009b      	lsls	r3, r3, #2
 8012dc2:	68fa      	ldr	r2, [r7, #12]
 8012dc4:	4413      	add	r3, r2
 8012dc6:	789b      	ldrb	r3, [r3, #2]
 8012dc8:	f003 0302 	and.w	r3, r3, #2
 8012dcc:	b2db      	uxtb	r3, r3
 8012dce:	2b00      	cmp	r3, #0
 8012dd0:	d00a      	beq.n	8012de8 <SizeASN_Items+0x2b4>
 8012dd2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012dd4:	4613      	mov	r3, r2
 8012dd6:	009b      	lsls	r3, r3, #2
 8012dd8:	4413      	add	r3, r2
 8012dda:	009b      	lsls	r3, r3, #2
 8012ddc:	461a      	mov	r2, r3
 8012dde:	68bb      	ldr	r3, [r7, #8]
 8012de0:	4413      	add	r3, r2
 8012de2:	689b      	ldr	r3, [r3, #8]
 8012de4:	2b00      	cmp	r3, #0
 8012de6:	d003      	beq.n	8012df0 <SizeASN_Items+0x2bc>
                    len += dataLen;
 8012de8:	69fa      	ldr	r2, [r7, #28]
 8012dea:	69bb      	ldr	r3, [r7, #24]
 8012dec:	4413      	add	r3, r2
 8012dee:	61fb      	str	r3, [r7, #28]
                }
                break;
 8012df0:	bf00      	nop
                return BAD_STATE_E;
        #endif
        }

        /* Set the total length of the item. */
        data[i].length = len;
 8012df2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012df4:	4613      	mov	r3, r2
 8012df6:	009b      	lsls	r3, r3, #2
 8012df8:	4413      	add	r3, r2
 8012dfa:	009b      	lsls	r3, r3, #2
 8012dfc:	461a      	mov	r2, r3
 8012dfe:	68bb      	ldr	r3, [r7, #8]
 8012e00:	4413      	add	r3, r2
 8012e02:	69fa      	ldr	r2, [r7, #28]
 8012e04:	605a      	str	r2, [r3, #4]
        /* Add length to total size. */
        sz += len;
 8012e06:	6a3a      	ldr	r2, [r7, #32]
 8012e08:	69fb      	ldr	r3, [r7, #28]
 8012e0a:	4413      	add	r3, r2
 8012e0c:	623b      	str	r3, [r7, #32]
        /* Set the offset to the current size - used in writing DER. */
        data[i].offset = sz;
 8012e0e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012e10:	4613      	mov	r3, r2
 8012e12:	009b      	lsls	r3, r3, #2
 8012e14:	4413      	add	r3, r2
 8012e16:	009b      	lsls	r3, r3, #2
 8012e18:	461a      	mov	r2, r3
 8012e1a:	68bb      	ldr	r3, [r7, #8]
 8012e1c:	4413      	add	r3, r2
 8012e1e:	6a3a      	ldr	r2, [r7, #32]
 8012e20:	601a      	str	r2, [r3, #0]
    for (i = count - 1; i >= 0; i--) {
 8012e22:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012e24:	3b01      	subs	r3, #1
 8012e26:	627b      	str	r3, [r7, #36]	@ 0x24
 8012e28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012e2a:	2b00      	cmp	r3, #0
 8012e2c:	f6bf ae8f 	bge.w	8012b4e <SizeASN_Items+0x1a>
                data[i].offset, data[i].length, asn[i].constructed ? '+' : ' ',
                asn[i].depth, "", TagString(asn[i].tag));
    #endif
    }

    *encSz = (int)sz;
 8012e30:	6a3a      	ldr	r2, [r7, #32]
 8012e32:	683b      	ldr	r3, [r7, #0]
 8012e34:	601a      	str	r2, [r3, #0]
    return 0;
 8012e36:	2300      	movs	r3, #0
}
 8012e38:	4618      	mov	r0, r3
 8012e3a:	3728      	adds	r7, #40	@ 0x28
 8012e3c:	46bd      	mov	sp, r7
 8012e3e:	bd80      	pop	{r7, pc}

08012e40 <SetASN_Num>:
 * @param [in] n     Number to be encoded.
 * @param [in] bits  Maximum number of bits to encode.
 * @param [in] tag   DER tag e.g. INTEGER, BIT_STRING, etc.
 */
static void SetASN_Num(word32 n, int bits, byte* out, byte tag)
{
 8012e40:	b480      	push	{r7}
 8012e42:	b089      	sub	sp, #36	@ 0x24
 8012e44:	af00      	add	r7, sp, #0
 8012e46:	60f8      	str	r0, [r7, #12]
 8012e48:	60b9      	str	r1, [r7, #8]
 8012e4a:	607a      	str	r2, [r7, #4]
 8012e4c:	70fb      	strb	r3, [r7, #3]
    byte   len;

    /* Encoding: Tag (1 byte) | Length (1 byte) | Data (number) */

    /* Data will start at index 2 unless BIT_STRING or INTEGER */
    idx = 2;
 8012e4e:	2302      	movs	r3, #2
 8012e50:	61bb      	str	r3, [r7, #24]

    /* Set the length of the number based on maximum bit length. */
    len = (byte)(bits / 8);
 8012e52:	68bb      	ldr	r3, [r7, #8]
 8012e54:	2b00      	cmp	r3, #0
 8012e56:	da00      	bge.n	8012e5a <SetASN_Num+0x1a>
 8012e58:	3307      	adds	r3, #7
 8012e5a:	10db      	asrs	r3, r3, #3
 8012e5c:	75fb      	strb	r3, [r7, #23]
    /* Discover actual size by checking for leading zero bytes. */
    for (j = bits - 8; j > 0; j -= 8) {
 8012e5e:	68bb      	ldr	r3, [r7, #8]
 8012e60:	3b08      	subs	r3, #8
 8012e62:	61fb      	str	r3, [r7, #28]
 8012e64:	e00b      	b.n	8012e7e <SetASN_Num+0x3e>
        if ((n >> j) != 0) {
 8012e66:	68fa      	ldr	r2, [r7, #12]
 8012e68:	69fb      	ldr	r3, [r7, #28]
 8012e6a:	fa22 f303 	lsr.w	r3, r2, r3
 8012e6e:	2b00      	cmp	r3, #0
 8012e70:	d109      	bne.n	8012e86 <SetASN_Num+0x46>
            break;
        }
        len--;
 8012e72:	7dfb      	ldrb	r3, [r7, #23]
 8012e74:	3b01      	subs	r3, #1
 8012e76:	75fb      	strb	r3, [r7, #23]
    for (j = bits - 8; j > 0; j -= 8) {
 8012e78:	69fb      	ldr	r3, [r7, #28]
 8012e7a:	3b08      	subs	r3, #8
 8012e7c:	61fb      	str	r3, [r7, #28]
 8012e7e:	69fb      	ldr	r3, [r7, #28]
 8012e80:	2b00      	cmp	r3, #0
 8012e82:	dcf0      	bgt.n	8012e66 <SetASN_Num+0x26>
 8012e84:	e000      	b.n	8012e88 <SetASN_Num+0x48>
            break;
 8012e86:	bf00      	nop
    /* Keep j, index of first non-zero byte, for writing out. */

    /* A BIT_STRING has the number of unused bits in last byte prepended to
     * data.
     */
    if (tag == ASN_BIT_STRING) {
 8012e88:	78fb      	ldrb	r3, [r7, #3]
 8012e8a:	2b03      	cmp	r3, #3
 8012e8c:	d124      	bne.n	8012ed8 <SetASN_Num+0x98>
        byte unusedBits = 0;
 8012e8e:	2300      	movs	r3, #0
 8012e90:	75bb      	strb	r3, [r7, #22]
        byte lastByte = (byte)(n >> j);
 8012e92:	68fa      	ldr	r2, [r7, #12]
 8012e94:	69fb      	ldr	r3, [r7, #28]
 8012e96:	fa22 f303 	lsr.w	r3, r2, r3
 8012e9a:	757b      	strb	r3, [r7, #21]

        /* Quick check last bit. */
        if ((lastByte & 0x01) == 0x00) {
 8012e9c:	7d7b      	ldrb	r3, [r7, #21]
 8012e9e:	f003 0301 	and.w	r3, r3, #1
 8012ea2:	2b00      	cmp	r3, #0
 8012ea4:	d10e      	bne.n	8012ec4 <SetASN_Num+0x84>
            unusedBits++;
 8012ea6:	7dbb      	ldrb	r3, [r7, #22]
 8012ea8:	3301      	adds	r3, #1
 8012eaa:	75bb      	strb	r3, [r7, #22]
            /* Check each bit for first least significant bit set. */
            while (((lastByte >> unusedBits) & 0x01) == 0x00)
 8012eac:	e002      	b.n	8012eb4 <SetASN_Num+0x74>
                unusedBits++;
 8012eae:	7dbb      	ldrb	r3, [r7, #22]
 8012eb0:	3301      	adds	r3, #1
 8012eb2:	75bb      	strb	r3, [r7, #22]
            while (((lastByte >> unusedBits) & 0x01) == 0x00)
 8012eb4:	7d7a      	ldrb	r2, [r7, #21]
 8012eb6:	7dbb      	ldrb	r3, [r7, #22]
 8012eb8:	fa42 f303 	asr.w	r3, r2, r3
 8012ebc:	f003 0301 	and.w	r3, r3, #1
 8012ec0:	2b00      	cmp	r3, #0
 8012ec2:	d0f4      	beq.n	8012eae <SetASN_Num+0x6e>
        }
        /* Add unused bits byte. */
        len++;
 8012ec4:	7dfb      	ldrb	r3, [r7, #23]
 8012ec6:	3301      	adds	r3, #1
 8012ec8:	75fb      	strb	r3, [r7, #23]
        out[idx++] = unusedBits;
 8012eca:	69bb      	ldr	r3, [r7, #24]
 8012ecc:	1c5a      	adds	r2, r3, #1
 8012ece:	61ba      	str	r2, [r7, #24]
 8012ed0:	687a      	ldr	r2, [r7, #4]
 8012ed2:	4413      	add	r3, r2
 8012ed4:	7dba      	ldrb	r2, [r7, #22]
 8012ed6:	701a      	strb	r2, [r3, #0]
    }

    /* An INTEGER has a prepended byte if MSB of number is 1 - makes encoded
     * value positive. */
    if ((tag == ASN_INTEGER) && (((n >> j) & 0x80) == 0x80)) {
 8012ed8:	78fb      	ldrb	r3, [r7, #3]
 8012eda:	2b02      	cmp	r3, #2
 8012edc:	d111      	bne.n	8012f02 <SetASN_Num+0xc2>
 8012ede:	68fa      	ldr	r2, [r7, #12]
 8012ee0:	69fb      	ldr	r3, [r7, #28]
 8012ee2:	fa22 f303 	lsr.w	r3, r2, r3
 8012ee6:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8012eea:	2b00      	cmp	r3, #0
 8012eec:	d009      	beq.n	8012f02 <SetASN_Num+0xc2>
        len++;
 8012eee:	7dfb      	ldrb	r3, [r7, #23]
 8012ef0:	3301      	adds	r3, #1
 8012ef2:	75fb      	strb	r3, [r7, #23]
        out[idx++] = 0;
 8012ef4:	69bb      	ldr	r3, [r7, #24]
 8012ef6:	1c5a      	adds	r2, r3, #1
 8012ef8:	61ba      	str	r2, [r7, #24]
 8012efa:	687a      	ldr	r2, [r7, #4]
 8012efc:	4413      	add	r3, r2
 8012efe:	2200      	movs	r2, #0
 8012f00:	701a      	strb	r2, [r3, #0]
    }

    /* Go back and put in length. */
    out[1] = len;
 8012f02:	687b      	ldr	r3, [r7, #4]
 8012f04:	3301      	adds	r3, #1
 8012f06:	7dfa      	ldrb	r2, [r7, #23]
 8012f08:	701a      	strb	r2, [r3, #0]
    /* Place in the required bytes of the number. */
    for (; j >= 0; j -= 8)
 8012f0a:	e00d      	b.n	8012f28 <SetASN_Num+0xe8>
        out[idx++] = (byte)(n >> j);
 8012f0c:	68fa      	ldr	r2, [r7, #12]
 8012f0e:	69fb      	ldr	r3, [r7, #28]
 8012f10:	fa22 f103 	lsr.w	r1, r2, r3
 8012f14:	69bb      	ldr	r3, [r7, #24]
 8012f16:	1c5a      	adds	r2, r3, #1
 8012f18:	61ba      	str	r2, [r7, #24]
 8012f1a:	687a      	ldr	r2, [r7, #4]
 8012f1c:	4413      	add	r3, r2
 8012f1e:	b2ca      	uxtb	r2, r1
 8012f20:	701a      	strb	r2, [r3, #0]
    for (; j >= 0; j -= 8)
 8012f22:	69fb      	ldr	r3, [r7, #28]
 8012f24:	3b08      	subs	r3, #8
 8012f26:	61fb      	str	r3, [r7, #28]
 8012f28:	69fb      	ldr	r3, [r7, #28]
 8012f2a:	2b00      	cmp	r3, #0
 8012f2c:	daee      	bge.n	8012f0c <SetASN_Num+0xcc>
}
 8012f2e:	bf00      	nop
 8012f30:	bf00      	nop
 8012f32:	3724      	adds	r7, #36	@ 0x24
 8012f34:	46bd      	mov	sp, r7
 8012f36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012f3a:	4770      	bx	lr

08012f3c <SetASN_Items>:
 * @param [in]      count   Count of items to encode.
 * @param [in, out] output  Buffer to write encoding into.
 * @return  Size of the DER encoding in bytes.
 */
int SetASN_Items(const ASNItem* asn, ASNSetData *data, int count, byte* output)
{
 8012f3c:	b580      	push	{r7, lr}
 8012f3e:	b08c      	sub	sp, #48	@ 0x30
 8012f40:	af00      	add	r7, sp, #0
 8012f42:	60f8      	str	r0, [r7, #12]
 8012f44:	60b9      	str	r1, [r7, #8]
 8012f46:	607a      	str	r2, [r7, #4]
 8012f48:	603b      	str	r3, [r7, #0]
    WOLFSSL_ENTER("SetASN_Items");
#endif

    /* Offset of first item is the total length.
     * SizeASN_Items() calculated this. */
    sz = data[0].offset;
 8012f4a:	68bb      	ldr	r3, [r7, #8]
 8012f4c:	681b      	ldr	r3, [r3, #0]
 8012f4e:	623b      	str	r3, [r7, #32]

    /* Write out each item. */
    for (i = 0; i < count; i++) {
 8012f50:	2300      	movs	r3, #0
 8012f52:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012f54:	e1fe      	b.n	8013354 <SetASN_Items+0x418>
        /* Skip items not writing out. */
        if (data[i].noOut)
 8012f56:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012f58:	4613      	mov	r3, r2
 8012f5a:	009b      	lsls	r3, r3, #2
 8012f5c:	4413      	add	r3, r2
 8012f5e:	009b      	lsls	r3, r3, #2
 8012f60:	461a      	mov	r2, r3
 8012f62:	68bb      	ldr	r3, [r7, #8]
 8012f64:	4413      	add	r3, r2
 8012f66:	7c5b      	ldrb	r3, [r3, #17]
 8012f68:	2b00      	cmp	r3, #0
 8012f6a:	f040 81eb 	bne.w	8013344 <SetASN_Items+0x408>
            continue;

        /* Start position to write item based on reverse offsets. */
        out = output + sz - data[i].offset;
 8012f6e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012f70:	4613      	mov	r3, r2
 8012f72:	009b      	lsls	r3, r3, #2
 8012f74:	4413      	add	r3, r2
 8012f76:	009b      	lsls	r3, r3, #2
 8012f78:	461a      	mov	r2, r3
 8012f7a:	68bb      	ldr	r3, [r7, #8]
 8012f7c:	4413      	add	r3, r2
 8012f7e:	681b      	ldr	r3, [r3, #0]
 8012f80:	6a3a      	ldr	r2, [r7, #32]
 8012f82:	1ad3      	subs	r3, r2, r3
 8012f84:	683a      	ldr	r2, [r7, #0]
 8012f86:	4413      	add	r3, r2
 8012f88:	61fb      	str	r3, [r7, #28]
        /* Index from start of item out. */
        idx = 0;
 8012f8a:	2300      	movs	r3, #0
 8012f8c:	62bb      	str	r3, [r7, #40]	@ 0x28

        if (data[i].dataType != ASN_DATA_TYPE_REPLACE_BUFFER) {
 8012f8e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012f90:	4613      	mov	r3, r2
 8012f92:	009b      	lsls	r3, r3, #2
 8012f94:	4413      	add	r3, r2
 8012f96:	009b      	lsls	r3, r3, #2
 8012f98:	461a      	mov	r2, r3
 8012f9a:	68bb      	ldr	r3, [r7, #8]
 8012f9c:	4413      	add	r3, r2
 8012f9e:	7c1b      	ldrb	r3, [r3, #16]
 8012fa0:	2b07      	cmp	r3, #7
 8012fa2:	d019      	beq.n	8012fd8 <SetASN_Items+0x9c>
            /* Put in the tag - not dumping in DER from buffer. */
            out[idx++] = asn[i].tag |
 8012fa4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012fa6:	009b      	lsls	r3, r3, #2
 8012fa8:	68fa      	ldr	r2, [r7, #12]
 8012faa:	4413      	add	r3, r2
 8012fac:	785b      	ldrb	r3, [r3, #1]
 8012fae:	b25a      	sxtb	r2, r3
                         (asn[i].constructed ? ASN_CONSTRUCTED : 0);
 8012fb0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012fb2:	009b      	lsls	r3, r3, #2
 8012fb4:	68f9      	ldr	r1, [r7, #12]
 8012fb6:	440b      	add	r3, r1
 8012fb8:	789b      	ldrb	r3, [r3, #2]
 8012fba:	b25b      	sxtb	r3, r3
 8012fbc:	015b      	lsls	r3, r3, #5
 8012fbe:	b25b      	sxtb	r3, r3
 8012fc0:	f003 0320 	and.w	r3, r3, #32
 8012fc4:	b25b      	sxtb	r3, r3
            out[idx++] = asn[i].tag |
 8012fc6:	4313      	orrs	r3, r2
 8012fc8:	b259      	sxtb	r1, r3
 8012fca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012fcc:	1c5a      	adds	r2, r3, #1
 8012fce:	62ba      	str	r2, [r7, #40]	@ 0x28
 8012fd0:	69fa      	ldr	r2, [r7, #28]
 8012fd2:	4413      	add	r3, r2
 8012fd4:	b2ca      	uxtb	r2, r1
 8012fd6:	701a      	strb	r2, [r3, #0]
                sz - data[i].offset,
                data[i].length, asn[i].constructed ? '+' : ' ', asn[i].depth,
                "", TagString(asn[i].tag));
    #endif

        switch (data[i].dataType) {
 8012fd8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012fda:	4613      	mov	r3, r2
 8012fdc:	009b      	lsls	r3, r3, #2
 8012fde:	4413      	add	r3, r2
 8012fe0:	009b      	lsls	r3, r3, #2
 8012fe2:	461a      	mov	r2, r3
 8012fe4:	68bb      	ldr	r3, [r7, #8]
 8012fe6:	4413      	add	r3, r2
 8012fe8:	7c1b      	ldrb	r3, [r3, #16]
 8012fea:	2b08      	cmp	r3, #8
 8012fec:	f200 81af 	bhi.w	801334e <SetASN_Items+0x412>
 8012ff0:	a201      	add	r2, pc, #4	@ (adr r2, 8012ff8 <SetASN_Items+0xbc>)
 8012ff2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012ff6:	bf00      	nop
 8012ff8:	08013185 	.word	0x08013185
 8012ffc:	0801301d 	.word	0x0801301d
 8013000:	08013045 	.word	0x08013045
 8013004:	0801334f 	.word	0x0801334f
 8013008:	0801334f 	.word	0x0801334f
 801300c:	0801334f 	.word	0x0801334f
 8013010:	0801334f 	.word	0x0801334f
 8013014:	08013123 	.word	0x08013123
 8013018:	0801306d 	.word	0x0801306d
            /* Write out the length and data of a number. */
            case ASN_DATA_TYPE_WORD8:
                SetASN_Num(data[i].data.u8, 8, out, asn[i].tag);
 801301c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801301e:	4613      	mov	r3, r2
 8013020:	009b      	lsls	r3, r3, #2
 8013022:	4413      	add	r3, r2
 8013024:	009b      	lsls	r3, r3, #2
 8013026:	461a      	mov	r2, r3
 8013028:	68bb      	ldr	r3, [r7, #8]
 801302a:	4413      	add	r3, r2
 801302c:	7a1b      	ldrb	r3, [r3, #8]
 801302e:	4618      	mov	r0, r3
 8013030:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013032:	009b      	lsls	r3, r3, #2
 8013034:	68fa      	ldr	r2, [r7, #12]
 8013036:	4413      	add	r3, r2
 8013038:	785b      	ldrb	r3, [r3, #1]
 801303a:	69fa      	ldr	r2, [r7, #28]
 801303c:	2108      	movs	r1, #8
 801303e:	f7ff feff 	bl	8012e40 <SetASN_Num>
                break;
 8013042:	e184      	b.n	801334e <SetASN_Items+0x412>
            case ASN_DATA_TYPE_WORD16:
                SetASN_Num(data[i].data.u16, 16, out, asn[i].tag);
 8013044:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013046:	4613      	mov	r3, r2
 8013048:	009b      	lsls	r3, r3, #2
 801304a:	4413      	add	r3, r2
 801304c:	009b      	lsls	r3, r3, #2
 801304e:	461a      	mov	r2, r3
 8013050:	68bb      	ldr	r3, [r7, #8]
 8013052:	4413      	add	r3, r2
 8013054:	891b      	ldrh	r3, [r3, #8]
 8013056:	4618      	mov	r0, r3
 8013058:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801305a:	009b      	lsls	r3, r3, #2
 801305c:	68fa      	ldr	r2, [r7, #12]
 801305e:	4413      	add	r3, r2
 8013060:	785b      	ldrb	r3, [r3, #1]
 8013062:	69fa      	ldr	r2, [r7, #28]
 8013064:	2110      	movs	r1, #16
 8013066:	f7ff feeb 	bl	8012e40 <SetASN_Num>
                break;
 801306a:	e170      	b.n	801334e <SetASN_Items+0x412>
        #endif

            /* Write out the length and data of a multi-precision number. */
            case ASN_DATA_TYPE_MP:
                /* Get length in bytes. */
                length = mp_unsigned_bin_size(data[i].data.mp);
 801306c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801306e:	4613      	mov	r3, r2
 8013070:	009b      	lsls	r3, r3, #2
 8013072:	4413      	add	r3, r2
 8013074:	009b      	lsls	r3, r3, #2
 8013076:	461a      	mov	r2, r3
 8013078:	68bb      	ldr	r3, [r7, #8]
 801307a:	4413      	add	r3, r2
 801307c:	689b      	ldr	r3, [r3, #8]
 801307e:	4618      	mov	r0, r3
 8013080:	f013 fe5a 	bl	8026d38 <mp_unsigned_bin_size>
 8013084:	61b8      	str	r0, [r7, #24]
                /* Add one for leading zero to make encoding a positive num. */
                length += mp_leading_bit(data[i].data.mp) ? 1 : 0;
 8013086:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013088:	4613      	mov	r3, r2
 801308a:	009b      	lsls	r3, r3, #2
 801308c:	4413      	add	r3, r2
 801308e:	009b      	lsls	r3, r3, #2
 8013090:	461a      	mov	r2, r3
 8013092:	68bb      	ldr	r3, [r7, #8]
 8013094:	4413      	add	r3, r2
 8013096:	689b      	ldr	r3, [r3, #8]
 8013098:	4618      	mov	r0, r3
 801309a:	f013 ff15 	bl	8026ec8 <mp_leading_bit>
 801309e:	4603      	mov	r3, r0
 80130a0:	2b00      	cmp	r3, #0
 80130a2:	bf14      	ite	ne
 80130a4:	2301      	movne	r3, #1
 80130a6:	2300      	moveq	r3, #0
 80130a8:	b2db      	uxtb	r3, r3
 80130aa:	461a      	mov	r2, r3
 80130ac:	69bb      	ldr	r3, [r7, #24]
 80130ae:	4413      	add	r3, r2
 80130b0:	61bb      	str	r3, [r7, #24]
                /* Write out length. */
                idx += SetASNLength((word32)length, out + idx);
 80130b2:	69b8      	ldr	r0, [r7, #24]
 80130b4:	69fa      	ldr	r2, [r7, #28]
 80130b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80130b8:	4413      	add	r3, r2
 80130ba:	4619      	mov	r1, r3
 80130bc:	f7ff fc17 	bl	80128ee <SetASNLength>
 80130c0:	4602      	mov	r2, r0
 80130c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80130c4:	4413      	add	r3, r2
 80130c6:	62bb      	str	r3, [r7, #40]	@ 0x28
                /* Write out leading zero to make positive. */
                if (mp_leading_bit(data[i].data.mp)) {
 80130c8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80130ca:	4613      	mov	r3, r2
 80130cc:	009b      	lsls	r3, r3, #2
 80130ce:	4413      	add	r3, r2
 80130d0:	009b      	lsls	r3, r3, #2
 80130d2:	461a      	mov	r2, r3
 80130d4:	68bb      	ldr	r3, [r7, #8]
 80130d6:	4413      	add	r3, r2
 80130d8:	689b      	ldr	r3, [r3, #8]
 80130da:	4618      	mov	r0, r3
 80130dc:	f013 fef4 	bl	8026ec8 <mp_leading_bit>
 80130e0:	4603      	mov	r3, r0
 80130e2:	2b00      	cmp	r3, #0
 80130e4:	d006      	beq.n	80130f4 <SetASN_Items+0x1b8>
                    out[idx++] = 0;
 80130e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80130e8:	1c5a      	adds	r2, r3, #1
 80130ea:	62ba      	str	r2, [r7, #40]	@ 0x28
 80130ec:	69fa      	ldr	r2, [r7, #28]
 80130ee:	4413      	add	r3, r2
 80130f0:	2200      	movs	r2, #0
 80130f2:	701a      	strb	r2, [r3, #0]
                }
                /* Encode number in big-endian byte array. */
                err = mp_to_unsigned_bin(data[i].data.mp, out + idx);
 80130f4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80130f6:	4613      	mov	r3, r2
 80130f8:	009b      	lsls	r3, r3, #2
 80130fa:	4413      	add	r3, r2
 80130fc:	009b      	lsls	r3, r3, #2
 80130fe:	461a      	mov	r2, r3
 8013100:	68bb      	ldr	r3, [r7, #8]
 8013102:	4413      	add	r3, r2
 8013104:	6898      	ldr	r0, [r3, #8]
 8013106:	69fa      	ldr	r2, [r7, #28]
 8013108:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801310a:	4413      	add	r3, r2
 801310c:	4619      	mov	r1, r3
 801310e:	f013 fe1f 	bl	8026d50 <mp_to_unsigned_bin>
 8013112:	6178      	str	r0, [r7, #20]
                if (err != MP_OKAY) {
 8013114:	697b      	ldr	r3, [r7, #20]
 8013116:	2b00      	cmp	r3, #0
 8013118:	f000 8116 	beq.w	8013348 <SetASN_Items+0x40c>
                    WOLFSSL_MSG("SetASN_Items: Failed to write mp_int");
                    return MP_TO_E;
 801311c:	f06f 0370 	mvn.w	r3, #112	@ 0x70
 8013120:	e11e      	b.n	8013360 <SetASN_Items+0x424>
                }
                break;

            case ASN_DATA_TYPE_REPLACE_BUFFER:
                if (data[i].data.buffer.data == NULL) {
 8013122:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013124:	4613      	mov	r3, r2
 8013126:	009b      	lsls	r3, r3, #2
 8013128:	4413      	add	r3, r2
 801312a:	009b      	lsls	r3, r3, #2
 801312c:	461a      	mov	r2, r3
 801312e:	68bb      	ldr	r3, [r7, #8]
 8013130:	4413      	add	r3, r2
 8013132:	689b      	ldr	r3, [r3, #8]
 8013134:	2b00      	cmp	r3, #0
 8013136:	d10c      	bne.n	8013152 <SetASN_Items+0x216>
                    /* Return pointer for caller to use. */
                    data[i].data.buffer.data = out + idx;
 8013138:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801313a:	4613      	mov	r3, r2
 801313c:	009b      	lsls	r3, r3, #2
 801313e:	4413      	add	r3, r2
 8013140:	009b      	lsls	r3, r3, #2
 8013142:	461a      	mov	r2, r3
 8013144:	68bb      	ldr	r3, [r7, #8]
 8013146:	4413      	add	r3, r2
 8013148:	69f9      	ldr	r1, [r7, #28]
 801314a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801314c:	440a      	add	r2, r1
 801314e:	609a      	str	r2, [r3, #8]
                else {
                    /* Dump in the DER encoded data. */
                    XMEMCPY(out + idx, data[i].data.buffer.data,
                            data[i].data.buffer.length);
                }
                break;
 8013150:	e0fd      	b.n	801334e <SetASN_Items+0x412>
                    XMEMCPY(out + idx, data[i].data.buffer.data,
 8013152:	69fa      	ldr	r2, [r7, #28]
 8013154:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013156:	18d0      	adds	r0, r2, r3
 8013158:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801315a:	4613      	mov	r3, r2
 801315c:	009b      	lsls	r3, r3, #2
 801315e:	4413      	add	r3, r2
 8013160:	009b      	lsls	r3, r3, #2
 8013162:	461a      	mov	r2, r3
 8013164:	68bb      	ldr	r3, [r7, #8]
 8013166:	4413      	add	r3, r2
 8013168:	6899      	ldr	r1, [r3, #8]
 801316a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801316c:	4613      	mov	r3, r2
 801316e:	009b      	lsls	r3, r3, #2
 8013170:	4413      	add	r3, r2
 8013172:	009b      	lsls	r3, r3, #2
 8013174:	461a      	mov	r2, r3
 8013176:	68bb      	ldr	r3, [r7, #8]
 8013178:	4413      	add	r3, r2
 801317a:	68db      	ldr	r3, [r3, #12]
 801317c:	461a      	mov	r2, r3
 801317e:	f015 fe02 	bl	8028d86 <memcpy>
                break;
 8013182:	e0e4      	b.n	801334e <SetASN_Items+0x412>

            case ASN_DATA_TYPE_NONE:
                if (asn[i].tag == ASN_BOOLEAN) {
 8013184:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013186:	009b      	lsls	r3, r3, #2
 8013188:	68fa      	ldr	r2, [r7, #12]
 801318a:	4413      	add	r3, r2
 801318c:	785b      	ldrb	r3, [r3, #1]
 801318e:	2b01      	cmp	r3, #1
 8013190:	d11a      	bne.n	80131c8 <SetASN_Items+0x28c>
                    /* Always one byte of data. */
                    out[idx++] = 1;
 8013192:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013194:	1c5a      	adds	r2, r3, #1
 8013196:	62ba      	str	r2, [r7, #40]	@ 0x28
 8013198:	69fa      	ldr	r2, [r7, #28]
 801319a:	4413      	add	r3, r2
 801319c:	2201      	movs	r2, #1
 801319e:	701a      	strb	r2, [r3, #0]
                    /* TRUE = 0xff, FALSE = 0x00 */
                    out[idx] = data[i].data.u8 ? 0xffU : 0x00U;
 80131a0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80131a2:	4613      	mov	r3, r2
 80131a4:	009b      	lsls	r3, r3, #2
 80131a6:	4413      	add	r3, r2
 80131a8:	009b      	lsls	r3, r3, #2
 80131aa:	461a      	mov	r2, r3
 80131ac:	68bb      	ldr	r3, [r7, #8]
 80131ae:	4413      	add	r3, r2
 80131b0:	7a1b      	ldrb	r3, [r3, #8]
 80131b2:	2b00      	cmp	r3, #0
 80131b4:	d001      	beq.n	80131ba <SetASN_Items+0x27e>
 80131b6:	21ff      	movs	r1, #255	@ 0xff
 80131b8:	e000      	b.n	80131bc <SetASN_Items+0x280>
 80131ba:	2100      	movs	r1, #0
 80131bc:	69fa      	ldr	r2, [r7, #28]
 80131be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80131c0:	4413      	add	r3, r2
 80131c2:	460a      	mov	r2, r1
 80131c4:	701a      	strb	r2, [r3, #0]
                        /* Allow data to come from output buffer. */
                        XMEMMOVE(out + idx, data[i].data.buffer.data,
                                 data[i].data.buffer.length);
                    }
                }
                break;
 80131c6:	e0c1      	b.n	801334c <SetASN_Items+0x410>
                else if (asn[i].tag == ASN_TAG_NULL) {
 80131c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80131ca:	009b      	lsls	r3, r3, #2
 80131cc:	68fa      	ldr	r2, [r7, #12]
 80131ce:	4413      	add	r3, r2
 80131d0:	785b      	ldrb	r3, [r3, #1]
 80131d2:	2b05      	cmp	r3, #5
 80131d4:	d105      	bne.n	80131e2 <SetASN_Items+0x2a6>
                    out[idx] = 0;
 80131d6:	69fa      	ldr	r2, [r7, #28]
 80131d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80131da:	4413      	add	r3, r2
 80131dc:	2200      	movs	r2, #0
 80131de:	701a      	strb	r2, [r3, #0]
                break;
 80131e0:	e0b4      	b.n	801334c <SetASN_Items+0x410>
                    word32 dataLen = data[i].data.buffer.length;
 80131e2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80131e4:	4613      	mov	r3, r2
 80131e6:	009b      	lsls	r3, r3, #2
 80131e8:	4413      	add	r3, r2
 80131ea:	009b      	lsls	r3, r3, #2
 80131ec:	461a      	mov	r2, r3
 80131ee:	68bb      	ldr	r3, [r7, #8]
 80131f0:	4413      	add	r3, r2
 80131f2:	68db      	ldr	r3, [r3, #12]
 80131f4:	627b      	str	r3, [r7, #36]	@ 0x24
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 80131f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80131f8:	009b      	lsls	r3, r3, #2
 80131fa:	68fa      	ldr	r2, [r7, #12]
 80131fc:	4413      	add	r3, r2
 80131fe:	785b      	ldrb	r3, [r3, #1]
 8013200:	2b03      	cmp	r3, #3
 8013202:	d01e      	beq.n	8013242 <SetASN_Items+0x306>
                                                   ASNIntMSBSet(asn, data, i)) {
 8013204:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013206:	009b      	lsls	r3, r3, #2
 8013208:	68fa      	ldr	r2, [r7, #12]
 801320a:	4413      	add	r3, r2
 801320c:	785b      	ldrb	r3, [r3, #1]
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 801320e:	2b02      	cmp	r3, #2
 8013210:	d11a      	bne.n	8013248 <SetASN_Items+0x30c>
                                                   ASNIntMSBSet(asn, data, i)) {
 8013212:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013214:	4613      	mov	r3, r2
 8013216:	009b      	lsls	r3, r3, #2
 8013218:	4413      	add	r3, r2
 801321a:	009b      	lsls	r3, r3, #2
 801321c:	461a      	mov	r2, r3
 801321e:	68bb      	ldr	r3, [r7, #8]
 8013220:	4413      	add	r3, r2
 8013222:	689b      	ldr	r3, [r3, #8]
 8013224:	2b00      	cmp	r3, #0
 8013226:	d00f      	beq.n	8013248 <SetASN_Items+0x30c>
 8013228:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801322a:	4613      	mov	r3, r2
 801322c:	009b      	lsls	r3, r3, #2
 801322e:	4413      	add	r3, r2
 8013230:	009b      	lsls	r3, r3, #2
 8013232:	461a      	mov	r2, r3
 8013234:	68bb      	ldr	r3, [r7, #8]
 8013236:	4413      	add	r3, r2
 8013238:	689b      	ldr	r3, [r3, #8]
 801323a:	781b      	ldrb	r3, [r3, #0]
 801323c:	b25b      	sxtb	r3, r3
 801323e:	2b00      	cmp	r3, #0
 8013240:	da02      	bge.n	8013248 <SetASN_Items+0x30c>
                        dataLen++;
 8013242:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013244:	3301      	adds	r3, #1
 8013246:	627b      	str	r3, [r7, #36]	@ 0x24
                    idx += SetASNLength(dataLen, out + idx);
 8013248:	69fa      	ldr	r2, [r7, #28]
 801324a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801324c:	4413      	add	r3, r2
 801324e:	4619      	mov	r1, r3
 8013250:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8013252:	f7ff fb4c 	bl	80128ee <SetASNLength>
 8013256:	4602      	mov	r2, r0
 8013258:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801325a:	4413      	add	r3, r2
 801325c:	62bb      	str	r3, [r7, #40]	@ 0x28
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 801325e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013260:	009b      	lsls	r3, r3, #2
 8013262:	68fa      	ldr	r2, [r7, #12]
 8013264:	4413      	add	r3, r2
 8013266:	785b      	ldrb	r3, [r3, #1]
 8013268:	2b03      	cmp	r3, #3
 801326a:	d01e      	beq.n	80132aa <SetASN_Items+0x36e>
                                                   ASNIntMSBSet(asn, data, i)) {
 801326c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801326e:	009b      	lsls	r3, r3, #2
 8013270:	68fa      	ldr	r2, [r7, #12]
 8013272:	4413      	add	r3, r2
 8013274:	785b      	ldrb	r3, [r3, #1]
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 8013276:	2b02      	cmp	r3, #2
 8013278:	d11e      	bne.n	80132b8 <SetASN_Items+0x37c>
                                                   ASNIntMSBSet(asn, data, i)) {
 801327a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801327c:	4613      	mov	r3, r2
 801327e:	009b      	lsls	r3, r3, #2
 8013280:	4413      	add	r3, r2
 8013282:	009b      	lsls	r3, r3, #2
 8013284:	461a      	mov	r2, r3
 8013286:	68bb      	ldr	r3, [r7, #8]
 8013288:	4413      	add	r3, r2
 801328a:	689b      	ldr	r3, [r3, #8]
 801328c:	2b00      	cmp	r3, #0
 801328e:	d013      	beq.n	80132b8 <SetASN_Items+0x37c>
 8013290:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013292:	4613      	mov	r3, r2
 8013294:	009b      	lsls	r3, r3, #2
 8013296:	4413      	add	r3, r2
 8013298:	009b      	lsls	r3, r3, #2
 801329a:	461a      	mov	r2, r3
 801329c:	68bb      	ldr	r3, [r7, #8]
 801329e:	4413      	add	r3, r2
 80132a0:	689b      	ldr	r3, [r3, #8]
 80132a2:	781b      	ldrb	r3, [r3, #0]
 80132a4:	b25b      	sxtb	r3, r3
 80132a6:	2b00      	cmp	r3, #0
 80132a8:	da06      	bge.n	80132b8 <SetASN_Items+0x37c>
                        out[idx++] = 0x00;
 80132aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80132ac:	1c5a      	adds	r2, r3, #1
 80132ae:	62ba      	str	r2, [r7, #40]	@ 0x28
 80132b0:	69fa      	ldr	r2, [r7, #28]
 80132b2:	4413      	add	r3, r2
 80132b4:	2200      	movs	r2, #0
 80132b6:	701a      	strb	r2, [r3, #0]
                    if (data[i].data.buffer.data == NULL) {
 80132b8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80132ba:	4613      	mov	r3, r2
 80132bc:	009b      	lsls	r3, r3, #2
 80132be:	4413      	add	r3, r2
 80132c0:	009b      	lsls	r3, r3, #2
 80132c2:	461a      	mov	r2, r3
 80132c4:	68bb      	ldr	r3, [r7, #8]
 80132c6:	4413      	add	r3, r2
 80132c8:	689b      	ldr	r3, [r3, #8]
 80132ca:	2b00      	cmp	r3, #0
 80132cc:	d10c      	bne.n	80132e8 <SetASN_Items+0x3ac>
                        data[i].data.buffer.data = out + idx;
 80132ce:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80132d0:	4613      	mov	r3, r2
 80132d2:	009b      	lsls	r3, r3, #2
 80132d4:	4413      	add	r3, r2
 80132d6:	009b      	lsls	r3, r3, #2
 80132d8:	461a      	mov	r2, r3
 80132da:	68bb      	ldr	r3, [r7, #8]
 80132dc:	4413      	add	r3, r2
 80132de:	69f9      	ldr	r1, [r7, #28]
 80132e0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80132e2:	440a      	add	r2, r1
 80132e4:	609a      	str	r2, [r3, #8]
                break;
 80132e6:	e031      	b.n	801334c <SetASN_Items+0x410>
                    else if (!asn[i].headerOnly ||
 80132e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80132ea:	009b      	lsls	r3, r3, #2
 80132ec:	68fa      	ldr	r2, [r7, #12]
 80132ee:	4413      	add	r3, r2
 80132f0:	789b      	ldrb	r3, [r3, #2]
 80132f2:	f003 0302 	and.w	r3, r3, #2
 80132f6:	b2db      	uxtb	r3, r3
 80132f8:	2b00      	cmp	r3, #0
 80132fa:	d00a      	beq.n	8013312 <SetASN_Items+0x3d6>
                            data[i].data.buffer.data != NULL) {
 80132fc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80132fe:	4613      	mov	r3, r2
 8013300:	009b      	lsls	r3, r3, #2
 8013302:	4413      	add	r3, r2
 8013304:	009b      	lsls	r3, r3, #2
 8013306:	461a      	mov	r2, r3
 8013308:	68bb      	ldr	r3, [r7, #8]
 801330a:	4413      	add	r3, r2
 801330c:	689b      	ldr	r3, [r3, #8]
                    else if (!asn[i].headerOnly ||
 801330e:	2b00      	cmp	r3, #0
 8013310:	d01c      	beq.n	801334c <SetASN_Items+0x410>
                        XMEMMOVE(out + idx, data[i].data.buffer.data,
 8013312:	69fa      	ldr	r2, [r7, #28]
 8013314:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013316:	18d0      	adds	r0, r2, r3
 8013318:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801331a:	4613      	mov	r3, r2
 801331c:	009b      	lsls	r3, r3, #2
 801331e:	4413      	add	r3, r2
 8013320:	009b      	lsls	r3, r3, #2
 8013322:	461a      	mov	r2, r3
 8013324:	68bb      	ldr	r3, [r7, #8]
 8013326:	4413      	add	r3, r2
 8013328:	6899      	ldr	r1, [r3, #8]
 801332a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801332c:	4613      	mov	r3, r2
 801332e:	009b      	lsls	r3, r3, #2
 8013330:	4413      	add	r3, r2
 8013332:	009b      	lsls	r3, r3, #2
 8013334:	461a      	mov	r2, r3
 8013336:	68bb      	ldr	r3, [r7, #8]
 8013338:	4413      	add	r3, r2
 801333a:	68db      	ldr	r3, [r3, #12]
 801333c:	461a      	mov	r2, r3
 801333e:	f015 fc57 	bl	8028bf0 <memmove>
                break;
 8013342:	e003      	b.n	801334c <SetASN_Items+0x410>
            continue;
 8013344:	bf00      	nop
 8013346:	e002      	b.n	801334e <SetASN_Items+0x412>
                break;
 8013348:	bf00      	nop
 801334a:	e000      	b.n	801334e <SetASN_Items+0x412>
                break;
 801334c:	bf00      	nop
    for (i = 0; i < count; i++) {
 801334e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013350:	3301      	adds	r3, #1
 8013352:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8013354:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013356:	687b      	ldr	r3, [r7, #4]
 8013358:	429a      	cmp	r2, r3
 801335a:	f6ff adfc 	blt.w	8012f56 <SetASN_Items+0x1a>
                return BAD_STATE_E;
        #endif
        }
    }

    return (int)sz;
 801335e:	6a3b      	ldr	r3, [r7, #32]
}
 8013360:	4618      	mov	r0, r3
 8013362:	3730      	adds	r7, #48	@ 0x30
 8013364:	46bd      	mov	sp, r7
 8013366:	bd80      	pop	{r7, pc}

08013368 <GetASN_Integer>:
 * @return  ASN_PARSE_E when 0 is not required but seen.
 * @return  ASN_EXPECT_0_E when 0 is required and not seen.
 */
static int GetASN_Integer(const byte* input, word32 idx, int length,
                          int positive)
{
 8013368:	b480      	push	{r7}
 801336a:	b085      	sub	sp, #20
 801336c:	af00      	add	r7, sp, #0
 801336e:	60f8      	str	r0, [r7, #12]
 8013370:	60b9      	str	r1, [r7, #8]
 8013372:	607a      	str	r2, [r7, #4]
 8013374:	603b      	str	r3, [r7, #0]
#if !defined(HAVE_SELFTEST) && !defined(HAVE_FIPS) || \
    (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))
    /* Check contents consist of one or more octets. */
    if (length == 0) {
 8013376:	687b      	ldr	r3, [r7, #4]
 8013378:	2b00      	cmp	r3, #0
 801337a:	d102      	bne.n	8013382 <GetASN_Integer+0x1a>
        WOLFSSL_MSG("Zero length INTEGER not allowed");
        return ASN_PARSE_E;
 801337c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013380:	e035      	b.n	80133ee <GetASN_Integer+0x86>
    }
#endif
    if (input[idx] == 0) {
 8013382:	68fa      	ldr	r2, [r7, #12]
 8013384:	68bb      	ldr	r3, [r7, #8]
 8013386:	4413      	add	r3, r2
 8013388:	781b      	ldrb	r3, [r3, #0]
 801338a:	2b00      	cmp	r3, #0
 801338c:	d10d      	bne.n	80133aa <GetASN_Integer+0x42>
        /* Check leading zero byte required. */
        if ((length > 1) && ((input[idx + 1] & 0x80) == 0)) {
 801338e:	687b      	ldr	r3, [r7, #4]
 8013390:	2b01      	cmp	r3, #1
 8013392:	dd2b      	ble.n	80133ec <GetASN_Integer+0x84>
 8013394:	68bb      	ldr	r3, [r7, #8]
 8013396:	3301      	adds	r3, #1
 8013398:	68fa      	ldr	r2, [r7, #12]
 801339a:	4413      	add	r3, r2
 801339c:	781b      	ldrb	r3, [r3, #0]
 801339e:	b25b      	sxtb	r3, r3
 80133a0:	2b00      	cmp	r3, #0
 80133a2:	db23      	blt.n	80133ec <GetASN_Integer+0x84>
            WOLFSSL_MSG("Zero not required on INTEGER");
        #ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
            return ASN_PARSE_E;
 80133a4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80133a8:	e021      	b.n	80133ee <GetASN_Integer+0x86>
        }
    }
    /* check for invalid padding on negative integer.
     * c.f. X.690 (ISO/IEC 8825-2:2003 (E)) 10.4.6; RFC 5280 4.1
     */
    else if ((length > 1) && (input[idx] == 0xff) &&
 80133aa:	687b      	ldr	r3, [r7, #4]
 80133ac:	2b01      	cmp	r3, #1
 80133ae:	dd10      	ble.n	80133d2 <GetASN_Integer+0x6a>
 80133b0:	68fa      	ldr	r2, [r7, #12]
 80133b2:	68bb      	ldr	r3, [r7, #8]
 80133b4:	4413      	add	r3, r2
 80133b6:	781b      	ldrb	r3, [r3, #0]
 80133b8:	2bff      	cmp	r3, #255	@ 0xff
 80133ba:	d10a      	bne.n	80133d2 <GetASN_Integer+0x6a>
             ((input[idx + 1] & 0x80) != 0)) {
 80133bc:	68bb      	ldr	r3, [r7, #8]
 80133be:	3301      	adds	r3, #1
 80133c0:	68fa      	ldr	r2, [r7, #12]
 80133c2:	4413      	add	r3, r2
 80133c4:	781b      	ldrb	r3, [r3, #0]
 80133c6:	b25b      	sxtb	r3, r3
    else if ((length > 1) && (input[idx] == 0xff) &&
 80133c8:	2b00      	cmp	r3, #0
 80133ca:	da02      	bge.n	80133d2 <GetASN_Integer+0x6a>
        WOLFSSL_MSG("Bad INTEGER encoding of negative");
    #ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
        return ASN_EXPECT_0_E;
 80133cc:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 80133d0:	e00d      	b.n	80133ee <GetASN_Integer+0x86>
    #endif /* WOLFSSL_ASN_INT_LEAD_0_ANY */
    }
    /* Check whether a leading zero byte was required. */
    else if (positive && (input[idx] & 0x80)) {
 80133d2:	683b      	ldr	r3, [r7, #0]
 80133d4:	2b00      	cmp	r3, #0
 80133d6:	d009      	beq.n	80133ec <GetASN_Integer+0x84>
 80133d8:	68fa      	ldr	r2, [r7, #12]
 80133da:	68bb      	ldr	r3, [r7, #8]
 80133dc:	4413      	add	r3, r2
 80133de:	781b      	ldrb	r3, [r3, #0]
 80133e0:	b25b      	sxtb	r3, r3
 80133e2:	2b00      	cmp	r3, #0
 80133e4:	da02      	bge.n	80133ec <GetASN_Integer+0x84>
        WOLFSSL_MSG("INTEGER is negative");
    #ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
        return ASN_EXPECT_0_E;
 80133e6:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 80133ea:	e000      	b.n	80133ee <GetASN_Integer+0x86>
    #endif /* WOLFSSL_ASN_INT_LEAD_0_ANY */
    }

    return 0;
 80133ec:	2300      	movs	r3, #0
}
 80133ee:	4618      	mov	r0, r3
 80133f0:	3714      	adds	r7, #20
 80133f2:	46bd      	mov	sp, r7
 80133f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80133f8:	4770      	bx	lr

080133fa <GetASN_BitString>:
 * @param [in] length  Length of input data.
 * @return  0 on success.
 * @return  ASN_PARSE_E when unused bits is invalid.
 */
int GetASN_BitString(const byte* input, word32 idx, int length)
{
 80133fa:	b480      	push	{r7}
 80133fc:	b085      	sub	sp, #20
 80133fe:	af00      	add	r7, sp, #0
 8013400:	60f8      	str	r0, [r7, #12]
 8013402:	60b9      	str	r1, [r7, #8]
 8013404:	607a      	str	r2, [r7, #4]
#if !defined(HAVE_SELFTEST) && !defined(HAVE_FIPS) || \
    (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))
    /* Check contents consist of one or more octets. */
    if (length == 0) {
 8013406:	687b      	ldr	r3, [r7, #4]
 8013408:	2b00      	cmp	r3, #0
 801340a:	d102      	bne.n	8013412 <GetASN_BitString+0x18>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG("Zero length BIT STRING not allowed");
    #endif
        return ASN_PARSE_E;
 801340c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013410:	e01f      	b.n	8013452 <GetASN_BitString+0x58>
    }
#endif
    /* Ensure unused bits value is valid range. */
    if (input[idx] > 7) {
 8013412:	68fa      	ldr	r2, [r7, #12]
 8013414:	68bb      	ldr	r3, [r7, #8]
 8013416:	4413      	add	r3, r2
 8013418:	781b      	ldrb	r3, [r3, #0]
 801341a:	2b07      	cmp	r3, #7
 801341c:	d902      	bls.n	8013424 <GetASN_BitString+0x2a>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG_VSNPRINTF("BIT STRING unused bits too big: %d > 7",
                input[idx]);
    #endif
        return ASN_PARSE_E;
 801341e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013422:	e016      	b.n	8013452 <GetASN_BitString+0x58>
    }
    /* Ensure unused bits are zero. */
    if ((byte)(input[idx + (word32)length - 1] << (8 - input[idx])) != 0) {
 8013424:	687a      	ldr	r2, [r7, #4]
 8013426:	68bb      	ldr	r3, [r7, #8]
 8013428:	4413      	add	r3, r2
 801342a:	3b01      	subs	r3, #1
 801342c:	68fa      	ldr	r2, [r7, #12]
 801342e:	4413      	add	r3, r2
 8013430:	781b      	ldrb	r3, [r3, #0]
 8013432:	4619      	mov	r1, r3
 8013434:	68fa      	ldr	r2, [r7, #12]
 8013436:	68bb      	ldr	r3, [r7, #8]
 8013438:	4413      	add	r3, r2
 801343a:	781b      	ldrb	r3, [r3, #0]
 801343c:	f1c3 0308 	rsb	r3, r3, #8
 8013440:	fa01 f303 	lsl.w	r3, r1, r3
 8013444:	b2db      	uxtb	r3, r3
 8013446:	2b00      	cmp	r3, #0
 8013448:	d002      	beq.n	8013450 <GetASN_BitString+0x56>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG_VSNPRINTF("BIT STRING unused bits used: %d %02x",
                input[idx], input[idx + length - 1]);
    #endif
        return ASN_PARSE_E;
 801344a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801344e:	e000      	b.n	8013452 <GetASN_BitString+0x58>
    }

    return 0;
 8013450:	2300      	movs	r3, #0
}
 8013452:	4618      	mov	r0, r3
 8013454:	3714      	adds	r7, #20
 8013456:	46bd      	mov	sp, r7
 8013458:	f85d 7b04 	ldr.w	r7, [sp], #4
 801345c:	4770      	bx	lr

0801345e <GetASN_UTF8String>:
 * @param [in] length  Length of input data.
 * @return  0 on success.
 * @return  ASN_PARSE_E when data is invalid.
 */
static int GetASN_UTF8String(const byte* input, word32 idx, int length)
{
 801345e:	b480      	push	{r7}
 8013460:	b089      	sub	sp, #36	@ 0x24
 8013462:	af00      	add	r7, sp, #0
 8013464:	60f8      	str	r0, [r7, #12]
 8013466:	60b9      	str	r1, [r7, #8]
 8013468:	607a      	str	r2, [r7, #4]
    int ret = 0;
 801346a:	2300      	movs	r3, #0
 801346c:	61fb      	str	r3, [r7, #28]
    word32 i = 0;
 801346e:	2300      	movs	r3, #0
 8013470:	61bb      	str	r3, [r7, #24]

    while ((ret == 0) && ((int)i < length)) {
 8013472:	e058      	b.n	8013526 <GetASN_UTF8String+0xc8>
        int cnt;

        /* Check code points and get count of following bytes. */
        if ((input[idx + i] & 0x80) == 0x00) {
 8013474:	68ba      	ldr	r2, [r7, #8]
 8013476:	69bb      	ldr	r3, [r7, #24]
 8013478:	4413      	add	r3, r2
 801347a:	68fa      	ldr	r2, [r7, #12]
 801347c:	4413      	add	r3, r2
 801347e:	781b      	ldrb	r3, [r3, #0]
 8013480:	b25b      	sxtb	r3, r3
 8013482:	2b00      	cmp	r3, #0
 8013484:	db02      	blt.n	801348c <GetASN_UTF8String+0x2e>
            cnt = 0;
 8013486:	2300      	movs	r3, #0
 8013488:	617b      	str	r3, [r7, #20]
 801348a:	e02a      	b.n	80134e2 <GetASN_UTF8String+0x84>
        }
        else if ((input[idx + i] & 0xe0) == 0xc0) {
 801348c:	68ba      	ldr	r2, [r7, #8]
 801348e:	69bb      	ldr	r3, [r7, #24]
 8013490:	4413      	add	r3, r2
 8013492:	68fa      	ldr	r2, [r7, #12]
 8013494:	4413      	add	r3, r2
 8013496:	781b      	ldrb	r3, [r3, #0]
 8013498:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
 801349c:	2bc0      	cmp	r3, #192	@ 0xc0
 801349e:	d102      	bne.n	80134a6 <GetASN_UTF8String+0x48>
            cnt = 1;
 80134a0:	2301      	movs	r3, #1
 80134a2:	617b      	str	r3, [r7, #20]
 80134a4:	e01d      	b.n	80134e2 <GetASN_UTF8String+0x84>
        }
        else if ((input[idx + i] & 0xf0) == 0xe0) {
 80134a6:	68ba      	ldr	r2, [r7, #8]
 80134a8:	69bb      	ldr	r3, [r7, #24]
 80134aa:	4413      	add	r3, r2
 80134ac:	68fa      	ldr	r2, [r7, #12]
 80134ae:	4413      	add	r3, r2
 80134b0:	781b      	ldrb	r3, [r3, #0]
 80134b2:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 80134b6:	2be0      	cmp	r3, #224	@ 0xe0
 80134b8:	d102      	bne.n	80134c0 <GetASN_UTF8String+0x62>
            cnt = 2;
 80134ba:	2302      	movs	r3, #2
 80134bc:	617b      	str	r3, [r7, #20]
 80134be:	e010      	b.n	80134e2 <GetASN_UTF8String+0x84>
        }
        else if ((input[idx + i] & 0xf8) == 0xf0) {
 80134c0:	68ba      	ldr	r2, [r7, #8]
 80134c2:	69bb      	ldr	r3, [r7, #24]
 80134c4:	4413      	add	r3, r2
 80134c6:	68fa      	ldr	r2, [r7, #12]
 80134c8:	4413      	add	r3, r2
 80134ca:	781b      	ldrb	r3, [r3, #0]
 80134cc:	f003 03f8 	and.w	r3, r3, #248	@ 0xf8
 80134d0:	2bf0      	cmp	r3, #240	@ 0xf0
 80134d2:	d102      	bne.n	80134da <GetASN_UTF8String+0x7c>
            cnt = 3;
 80134d4:	2303      	movs	r3, #3
 80134d6:	617b      	str	r3, [r7, #20]
 80134d8:	e003      	b.n	80134e2 <GetASN_UTF8String+0x84>
        }
        else {
            WOLFSSL_MSG("Invalid character in UTF8STRING\n");
            ret = ASN_PARSE_E;
 80134da:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80134de:	61fb      	str	r3, [r7, #28]
            break;
 80134e0:	e028      	b.n	8013534 <GetASN_UTF8String+0xd6>
        }

        /* Have checked first byte. */
        i++;
 80134e2:	69bb      	ldr	r3, [r7, #24]
 80134e4:	3301      	adds	r3, #1
 80134e6:	61bb      	str	r3, [r7, #24]
        /* Check each following byte. */
        for (; cnt > 0; cnt--) {
 80134e8:	e01a      	b.n	8013520 <GetASN_UTF8String+0xc2>
            /* Check we have enough data. */
            if ((int)i == length) {
 80134ea:	69bb      	ldr	r3, [r7, #24]
 80134ec:	687a      	ldr	r2, [r7, #4]
 80134ee:	429a      	cmp	r2, r3
 80134f0:	d103      	bne.n	80134fa <GetASN_UTF8String+0x9c>
                WOLFSSL_MSG("Missing character in UTF8STRING\n");
                ret = ASN_PARSE_E;
 80134f2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80134f6:	61fb      	str	r3, [r7, #28]
                break;
 80134f8:	e015      	b.n	8013526 <GetASN_UTF8String+0xc8>
            }
            /* Check following byte has top bit set. */
            if ((input[idx + i] & 0x80) != 0x80) {
 80134fa:	68ba      	ldr	r2, [r7, #8]
 80134fc:	69bb      	ldr	r3, [r7, #24]
 80134fe:	4413      	add	r3, r2
 8013500:	68fa      	ldr	r2, [r7, #12]
 8013502:	4413      	add	r3, r2
 8013504:	781b      	ldrb	r3, [r3, #0]
 8013506:	b25b      	sxtb	r3, r3
 8013508:	2b00      	cmp	r3, #0
 801350a:	db03      	blt.n	8013514 <GetASN_UTF8String+0xb6>
                WOLFSSL_MSG("Invalid character in UTF8STRING\n");
                ret = ASN_PARSE_E;
 801350c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013510:	61fb      	str	r3, [r7, #28]
                break;
 8013512:	e008      	b.n	8013526 <GetASN_UTF8String+0xc8>
            }
            i++;
 8013514:	69bb      	ldr	r3, [r7, #24]
 8013516:	3301      	adds	r3, #1
 8013518:	61bb      	str	r3, [r7, #24]
        for (; cnt > 0; cnt--) {
 801351a:	697b      	ldr	r3, [r7, #20]
 801351c:	3b01      	subs	r3, #1
 801351e:	617b      	str	r3, [r7, #20]
 8013520:	697b      	ldr	r3, [r7, #20]
 8013522:	2b00      	cmp	r3, #0
 8013524:	dce1      	bgt.n	80134ea <GetASN_UTF8String+0x8c>
    while ((ret == 0) && ((int)i < length)) {
 8013526:	69fb      	ldr	r3, [r7, #28]
 8013528:	2b00      	cmp	r3, #0
 801352a:	d103      	bne.n	8013534 <GetASN_UTF8String+0xd6>
 801352c:	69bb      	ldr	r3, [r7, #24]
 801352e:	687a      	ldr	r2, [r7, #4]
 8013530:	429a      	cmp	r2, r3
 8013532:	dc9f      	bgt.n	8013474 <GetASN_UTF8String+0x16>
        }
    }

    return ret;
 8013534:	69fb      	ldr	r3, [r7, #28]
}
 8013536:	4618      	mov	r0, r3
 8013538:	3724      	adds	r7, #36	@ 0x24
 801353a:	46bd      	mov	sp, r7
 801353c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013540:	4770      	bx	lr

08013542 <GetASN_ObjectId>:
 * @param [in] length  Length of input data.
 * @return  0 on success.
 * @return  ASN_PARSE_E when data is invalid.
 */
static int GetASN_ObjectId(const byte* input, word32 idx, int length)
{
 8013542:	b480      	push	{r7}
 8013544:	b087      	sub	sp, #28
 8013546:	af00      	add	r7, sp, #0
 8013548:	60f8      	str	r0, [r7, #12]
 801354a:	60b9      	str	r1, [r7, #8]
 801354c:	607a      	str	r2, [r7, #4]
    int ret = 0;
 801354e:	2300      	movs	r3, #0
 8013550:	617b      	str	r3, [r7, #20]

    /* OID data must be at least 3 bytes. */
    if (length < 3) {
 8013552:	687b      	ldr	r3, [r7, #4]
 8013554:	2b02      	cmp	r3, #2
 8013556:	dc03      	bgt.n	8013560 <GetASN_ObjectId+0x1e>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG_VSNPRINTF("OID length must be 3 or more: %d", length);
    #else
        WOLFSSL_MSG("OID length less than 3");
    #endif
        ret = ASN_PARSE_E;
 8013558:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801355c:	617b      	str	r3, [r7, #20]
 801355e:	e00c      	b.n	801357a <GetASN_ObjectId+0x38>
    }
    /* Last octet of a sub-identifier has bit 8 clear. Last octet must be last
     * of a subidentifier. Ensure last octet hasn't got top bit set.
     */
    else if ((input[(int)idx + length - 1] & 0x80) == 0x80) {
 8013560:	68ba      	ldr	r2, [r7, #8]
 8013562:	687b      	ldr	r3, [r7, #4]
 8013564:	4413      	add	r3, r2
 8013566:	3b01      	subs	r3, #1
 8013568:	68fa      	ldr	r2, [r7, #12]
 801356a:	4413      	add	r3, r2
 801356c:	781b      	ldrb	r3, [r3, #0]
 801356e:	b25b      	sxtb	r3, r3
 8013570:	2b00      	cmp	r3, #0
 8013572:	da02      	bge.n	801357a <GetASN_ObjectId+0x38>
        WOLFSSL_MSG("OID last octet has top bit set");
        ret = ASN_PARSE_E;
 8013574:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013578:	617b      	str	r3, [r7, #20]
    }

    return ret;
 801357a:	697b      	ldr	r3, [r7, #20]
}
 801357c:	4618      	mov	r0, r3
 801357e:	371c      	adds	r7, #28
 8013580:	46bd      	mov	sp, r7
 8013582:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013586:	4770      	bx	lr

08013588 <GetASN_StoreData>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
static int GetASN_StoreData(const ASNItem* asn, ASNGetData* data,
                            const byte* input, word32 idx, int len,
                            int zeroPadded)
{
 8013588:	b590      	push	{r4, r7, lr}
 801358a:	b08b      	sub	sp, #44	@ 0x2c
 801358c:	af02      	add	r7, sp, #8
 801358e:	60f8      	str	r0, [r7, #12]
 8013590:	60b9      	str	r1, [r7, #8]
 8013592:	607a      	str	r2, [r7, #4]
 8013594:	603b      	str	r3, [r7, #0]
    int i;
    int err;

    /* Parse data based on data type to extract. */
    switch (data->dataType) {
 8013596:	68bb      	ldr	r3, [r7, #8]
 8013598:	7e1b      	ldrb	r3, [r3, #24]
 801359a:	2b0b      	cmp	r3, #11
 801359c:	f200 8162 	bhi.w	8013864 <GetASN_StoreData+0x2dc>
 80135a0:	a201      	add	r2, pc, #4	@ (adr r2, 80135a8 <GetASN_StoreData+0x20>)
 80135a2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80135a6:	bf00      	nop
 80135a8:	080137a7 	.word	0x080137a7
 80135ac:	080135d9 	.word	0x080135d9
 80135b0:	080135f5 	.word	0x080135f5
 80135b4:	08013865 	.word	0x08013865
 80135b8:	08013653 	.word	0x08013653
 80135bc:	080136ad 	.word	0x080136ad
 80135c0:	080136dd 	.word	0x080136dd
 80135c4:	08013865 	.word	0x08013865
 80135c8:	0801370f 	.word	0x0801370f
 80135cc:	08013725 	.word	0x08013725
 80135d0:	0801370f 	.word	0x0801370f
 80135d4:	08013751 	.word	0x08013751
        /* Parse a data into a number of specified bits. */
        case ASN_DATA_TYPE_WORD8:
            /* Check data is small enough to fit. */
            if (len != 1) {
 80135d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80135da:	2b01      	cmp	r3, #1
 80135dc:	d002      	beq.n	80135e4 <GetASN_StoreData+0x5c>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Expecting one byte: %d", len);
            #endif
                return ASN_PARSE_E;
 80135de:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80135e2:	e140      	b.n	8013866 <GetASN_StoreData+0x2de>
            }
            /* Fill number with all of data. */
            *data->data.u8 = input[idx];
 80135e4:	687a      	ldr	r2, [r7, #4]
 80135e6:	683b      	ldr	r3, [r7, #0]
 80135e8:	441a      	add	r2, r3
 80135ea:	68bb      	ldr	r3, [r7, #8]
 80135ec:	689b      	ldr	r3, [r3, #8]
 80135ee:	7812      	ldrb	r2, [r2, #0]
 80135f0:	701a      	strb	r2, [r3, #0]
            break;
 80135f2:	e137      	b.n	8013864 <GetASN_StoreData+0x2dc>
        case ASN_DATA_TYPE_WORD16:
            /* Check data is small enough to fit. */
            if (len == 0 || len > 2) {
 80135f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80135f6:	2b00      	cmp	r3, #0
 80135f8:	d002      	beq.n	8013600 <GetASN_StoreData+0x78>
 80135fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80135fc:	2b02      	cmp	r3, #2
 80135fe:	dd02      	ble.n	8013606 <GetASN_StoreData+0x7e>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Expecting 1 or 2 bytes: %d", len);
            #endif
                return ASN_PARSE_E;
 8013600:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013604:	e12f      	b.n	8013866 <GetASN_StoreData+0x2de>
            }
            /* Fill number with all of data. */
            *data->data.u16 = 0;
 8013606:	68bb      	ldr	r3, [r7, #8]
 8013608:	689b      	ldr	r3, [r3, #8]
 801360a:	2200      	movs	r2, #0
 801360c:	801a      	strh	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 801360e:	2300      	movs	r3, #0
 8013610:	61fb      	str	r3, [r7, #28]
 8013612:	e019      	b.n	8013648 <GetASN_StoreData+0xc0>
                *data->data.u16 = (word16)(*data->data.u16 << 8U);
 8013614:	68bb      	ldr	r3, [r7, #8]
 8013616:	689b      	ldr	r3, [r3, #8]
 8013618:	881a      	ldrh	r2, [r3, #0]
 801361a:	68bb      	ldr	r3, [r7, #8]
 801361c:	689b      	ldr	r3, [r3, #8]
 801361e:	0212      	lsls	r2, r2, #8
 8013620:	b292      	uxth	r2, r2
 8013622:	801a      	strh	r2, [r3, #0]
                *data->data.u16 = (word16)(*data->data.u16 | input[idx + (word32)i]);
 8013624:	68bb      	ldr	r3, [r7, #8]
 8013626:	689b      	ldr	r3, [r3, #8]
 8013628:	881a      	ldrh	r2, [r3, #0]
 801362a:	69f9      	ldr	r1, [r7, #28]
 801362c:	683b      	ldr	r3, [r7, #0]
 801362e:	440b      	add	r3, r1
 8013630:	6879      	ldr	r1, [r7, #4]
 8013632:	440b      	add	r3, r1
 8013634:	781b      	ldrb	r3, [r3, #0]
 8013636:	4619      	mov	r1, r3
 8013638:	68bb      	ldr	r3, [r7, #8]
 801363a:	689b      	ldr	r3, [r3, #8]
 801363c:	430a      	orrs	r2, r1
 801363e:	b292      	uxth	r2, r2
 8013640:	801a      	strh	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 8013642:	69fb      	ldr	r3, [r7, #28]
 8013644:	3301      	adds	r3, #1
 8013646:	61fb      	str	r3, [r7, #28]
 8013648:	69fa      	ldr	r2, [r7, #28]
 801364a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801364c:	429a      	cmp	r2, r3
 801364e:	dbe1      	blt.n	8013614 <GetASN_StoreData+0x8c>
            }
            break;
 8013650:	e108      	b.n	8013864 <GetASN_StoreData+0x2dc>
        case ASN_DATA_TYPE_WORD32:
            /* Check data is small enough to fit. */
            if (len == 0 || len > 4) {
 8013652:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013654:	2b00      	cmp	r3, #0
 8013656:	d002      	beq.n	801365e <GetASN_StoreData+0xd6>
 8013658:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801365a:	2b04      	cmp	r3, #4
 801365c:	dd02      	ble.n	8013664 <GetASN_StoreData+0xdc>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Expecting 1 to 4 bytes: %d", len);
            #endif
                return ASN_PARSE_E;
 801365e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013662:	e100      	b.n	8013866 <GetASN_StoreData+0x2de>
            }
            /* Fill number with all of data. */
            *data->data.u32 = 0;
 8013664:	68bb      	ldr	r3, [r7, #8]
 8013666:	689b      	ldr	r3, [r3, #8]
 8013668:	2200      	movs	r2, #0
 801366a:	601a      	str	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 801366c:	2300      	movs	r3, #0
 801366e:	61fb      	str	r3, [r7, #28]
 8013670:	e017      	b.n	80136a2 <GetASN_StoreData+0x11a>
                *data->data.u32 <<= 8;
 8013672:	68bb      	ldr	r3, [r7, #8]
 8013674:	689b      	ldr	r3, [r3, #8]
 8013676:	681a      	ldr	r2, [r3, #0]
 8013678:	68bb      	ldr	r3, [r7, #8]
 801367a:	689b      	ldr	r3, [r3, #8]
 801367c:	0212      	lsls	r2, r2, #8
 801367e:	601a      	str	r2, [r3, #0]
                *data->data.u32 |= input[idx + (word32)i] ;
 8013680:	68bb      	ldr	r3, [r7, #8]
 8013682:	689b      	ldr	r3, [r3, #8]
 8013684:	681a      	ldr	r2, [r3, #0]
 8013686:	69f9      	ldr	r1, [r7, #28]
 8013688:	683b      	ldr	r3, [r7, #0]
 801368a:	440b      	add	r3, r1
 801368c:	6879      	ldr	r1, [r7, #4]
 801368e:	440b      	add	r3, r1
 8013690:	781b      	ldrb	r3, [r3, #0]
 8013692:	4619      	mov	r1, r3
 8013694:	68bb      	ldr	r3, [r7, #8]
 8013696:	689b      	ldr	r3, [r3, #8]
 8013698:	430a      	orrs	r2, r1
 801369a:	601a      	str	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 801369c:	69fb      	ldr	r3, [r7, #28]
 801369e:	3301      	adds	r3, #1
 80136a0:	61fb      	str	r3, [r7, #28]
 80136a2:	69fa      	ldr	r2, [r7, #28]
 80136a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80136a6:	429a      	cmp	r2, r3
 80136a8:	dbe3      	blt.n	8013672 <GetASN_StoreData+0xea>
            }
            break;
 80136aa:	e0db      	b.n	8013864 <GetASN_StoreData+0x2dc>

        case ASN_DATA_TYPE_BUFFER:
            /* Check buffer is big enough to hold data. */
            if (len > (int)*data->data.buffer.length) {
 80136ac:	68bb      	ldr	r3, [r7, #8]
 80136ae:	68db      	ldr	r3, [r3, #12]
 80136b0:	681b      	ldr	r3, [r3, #0]
 80136b2:	461a      	mov	r2, r3
 80136b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80136b6:	4293      	cmp	r3, r2
 80136b8:	dd02      	ble.n	80136c0 <GetASN_StoreData+0x138>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Buffer too small for data: %d %d", len,
                        *data->data.buffer.length);
            #endif
                return ASN_PARSE_E;
 80136ba:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80136be:	e0d2      	b.n	8013866 <GetASN_StoreData+0x2de>
            }
            /* Copy in data and record actual length seen. */
            XMEMCPY(data->data.buffer.data, input + idx, (size_t)len);
 80136c0:	68bb      	ldr	r3, [r7, #8]
 80136c2:	6898      	ldr	r0, [r3, #8]
 80136c4:	687a      	ldr	r2, [r7, #4]
 80136c6:	683b      	ldr	r3, [r7, #0]
 80136c8:	4413      	add	r3, r2
 80136ca:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80136cc:	4619      	mov	r1, r3
 80136ce:	f015 fb5a 	bl	8028d86 <memcpy>
            *data->data.buffer.length = (word32)len;
 80136d2:	68bb      	ldr	r3, [r7, #8]
 80136d4:	68db      	ldr	r3, [r3, #12]
 80136d6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80136d8:	601a      	str	r2, [r3, #0]
            break;
 80136da:	e0c3      	b.n	8013864 <GetASN_StoreData+0x2dc>

        case ASN_DATA_TYPE_EXP_BUFFER:
            /* Check data is same size expected. */
            if (len != (int)data->data.ref.length) {
 80136dc:	68bb      	ldr	r3, [r7, #8]
 80136de:	68db      	ldr	r3, [r3, #12]
 80136e0:	461a      	mov	r2, r3
 80136e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80136e4:	4293      	cmp	r3, r2
 80136e6:	d002      	beq.n	80136ee <GetASN_StoreData+0x166>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Data not expected length: %d %d", len,
                        data->data.ref.length);
            #endif
                return ASN_PARSE_E;
 80136e8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80136ec:	e0bb      	b.n	8013866 <GetASN_StoreData+0x2de>
            }
            /* Check data is same as expected. */
            if (XMEMCMP(data->data.ref.data, input + idx, (size_t)len) != 0) {
 80136ee:	68bb      	ldr	r3, [r7, #8]
 80136f0:	6898      	ldr	r0, [r3, #8]
 80136f2:	687a      	ldr	r2, [r7, #4]
 80136f4:	683b      	ldr	r3, [r7, #0]
 80136f6:	4413      	add	r3, r2
 80136f8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80136fa:	4619      	mov	r1, r3
 80136fc:	f015 fa68 	bl	8028bd0 <memcmp>
 8013700:	4603      	mov	r3, r0
 8013702:	2b00      	cmp	r3, #0
 8013704:	f000 80a9 	beq.w	801385a <GetASN_StoreData+0x2d2>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Data not as expected");
            #endif
                return ASN_PARSE_E;
 8013708:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801370c:	e0ab      	b.n	8013866 <GetASN_StoreData+0x2de>
            break;

        case ASN_DATA_TYPE_MP:
        case ASN_DATA_TYPE_MP_POS_NEG:
            /* Initialize mp_int and read in big-endian byte array. */
            if (mp_init(data->data.mp) != MP_OKAY) {
 801370e:	68bb      	ldr	r3, [r7, #8]
 8013710:	689b      	ldr	r3, [r3, #8]
 8013712:	4618      	mov	r0, r3
 8013714:	f013 f961 	bl	80269da <mp_init>
 8013718:	4603      	mov	r3, r0
 801371a:	2b00      	cmp	r3, #0
 801371c:	d002      	beq.n	8013724 <GetASN_StoreData+0x19c>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Failed to init mp: %p", data->data.mp);
            #endif
                return MP_INIT_E;
 801371e:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8013722:	e0a0      	b.n	8013866 <GetASN_StoreData+0x2de>
            }
            FALL_THROUGH;
        case ASN_DATA_TYPE_MP_INITED:
            err = mp_read_unsigned_bin(data->data.mp, (byte*)input + idx,
 8013724:	68bb      	ldr	r3, [r7, #8]
 8013726:	6898      	ldr	r0, [r3, #8]
 8013728:	687a      	ldr	r2, [r7, #4]
 801372a:	683b      	ldr	r3, [r7, #0]
 801372c:	4413      	add	r3, r2
 801372e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013730:	4619      	mov	r1, r3
 8013732:	f013 fb2b 	bl	8026d8c <mp_read_unsigned_bin>
 8013736:	61b8      	str	r0, [r7, #24]
                                       (word32)len);
            if (err != 0) {
 8013738:	69bb      	ldr	r3, [r7, #24]
 801373a:	2b00      	cmp	r3, #0
 801373c:	f000 808f 	beq.w	801385e <GetASN_StoreData+0x2d6>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Failed to read mp: %d", err);
            #endif
                mp_clear(data->data.mp);
 8013740:	68bb      	ldr	r3, [r7, #8]
 8013742:	689b      	ldr	r3, [r3, #8]
 8013744:	4618      	mov	r0, r3
 8013746:	f013 f9d2 	bl	8026aee <mp_clear>
                return ASN_GETINT_E;
 801374a:	f06f 038d 	mvn.w	r3, #141	@ 0x8d
 801374e:	e08a      	b.n	8013866 <GetASN_StoreData+0x2de>
        #endif
            break;

        case ASN_DATA_TYPE_CHOICE:
            /* Check if tag matched any of the choices specified. */
            for (i = 0; data->data.choice[i] != 0; i++)
 8013750:	2300      	movs	r3, #0
 8013752:	61fb      	str	r3, [r7, #28]
 8013754:	e00b      	b.n	801376e <GetASN_StoreData+0x1e6>
                if (data->data.choice[i] == data->tag)
 8013756:	68bb      	ldr	r3, [r7, #8]
 8013758:	689a      	ldr	r2, [r3, #8]
 801375a:	69fb      	ldr	r3, [r7, #28]
 801375c:	4413      	add	r3, r2
 801375e:	781a      	ldrb	r2, [r3, #0]
 8013760:	68bb      	ldr	r3, [r7, #8]
 8013762:	7e5b      	ldrb	r3, [r3, #25]
 8013764:	429a      	cmp	r2, r3
 8013766:	d00a      	beq.n	801377e <GetASN_StoreData+0x1f6>
            for (i = 0; data->data.choice[i] != 0; i++)
 8013768:	69fb      	ldr	r3, [r7, #28]
 801376a:	3301      	adds	r3, #1
 801376c:	61fb      	str	r3, [r7, #28]
 801376e:	68bb      	ldr	r3, [r7, #8]
 8013770:	689a      	ldr	r2, [r3, #8]
 8013772:	69fb      	ldr	r3, [r7, #28]
 8013774:	4413      	add	r3, r2
 8013776:	781b      	ldrb	r3, [r3, #0]
 8013778:	2b00      	cmp	r3, #0
 801377a:	d1ec      	bne.n	8013756 <GetASN_StoreData+0x1ce>
 801377c:	e000      	b.n	8013780 <GetASN_StoreData+0x1f8>
                    break;
 801377e:	bf00      	nop
            if (data->data.choice[i] == 0) {
 8013780:	68bb      	ldr	r3, [r7, #8]
 8013782:	689a      	ldr	r2, [r3, #8]
 8013784:	69fb      	ldr	r3, [r7, #28]
 8013786:	4413      	add	r3, r2
 8013788:	781b      	ldrb	r3, [r3, #0]
 801378a:	2b00      	cmp	r3, #0
 801378c:	d102      	bne.n	8013794 <GetASN_StoreData+0x20c>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Tag didn't match a choice");
            #endif
                return ASN_PARSE_E;
 801378e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013792:	e068      	b.n	8013866 <GetASN_StoreData+0x2de>
            }

            /* Store data pointer and length for caller. */
            data->data.ref.data = input + idx;
 8013794:	687a      	ldr	r2, [r7, #4]
 8013796:	683b      	ldr	r3, [r7, #0]
 8013798:	441a      	add	r2, r3
 801379a:	68bb      	ldr	r3, [r7, #8]
 801379c:	609a      	str	r2, [r3, #8]
            data->data.ref.length = (word32)len;
 801379e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80137a0:	68bb      	ldr	r3, [r7, #8]
 80137a2:	60da      	str	r2, [r3, #12]
            break;
 80137a4:	e05e      	b.n	8013864 <GetASN_StoreData+0x2dc>

        case ASN_DATA_TYPE_NONE:
            /* Default behaviour based on tag. */
            if (asn->tag == ASN_BOOLEAN) {
 80137a6:	68fb      	ldr	r3, [r7, #12]
 80137a8:	785b      	ldrb	r3, [r3, #1]
 80137aa:	2b01      	cmp	r3, #1
 80137ac:	d119      	bne.n	80137e2 <GetASN_StoreData+0x25a>
                /* BOOLEAN has only one byte of data in BER. */
                if (len != 1) {
 80137ae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80137b0:	2b01      	cmp	r3, #1
 80137b2:	d002      	beq.n	80137ba <GetASN_StoreData+0x232>
                #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                    WOLFSSL_MSG_VSNPRINTF("BOOLEAN length too long: %d", len);
                #endif
                    return ASN_PARSE_E;
 80137b4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80137b8:	e055      	b.n	8013866 <GetASN_StoreData+0x2de>
                }
                if (data->data.u8 == NULL)
 80137ba:	68bb      	ldr	r3, [r7, #8]
 80137bc:	689b      	ldr	r3, [r3, #8]
 80137be:	2b00      	cmp	r3, #0
 80137c0:	d102      	bne.n	80137c8 <GetASN_StoreData+0x240>
                    return BAD_STATE_E;
 80137c2:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 80137c6:	e04e      	b.n	8013866 <GetASN_StoreData+0x2de>
                /* Store C boolean value. */
                *data->data.u8 = (input[idx] != 0);
 80137c8:	687a      	ldr	r2, [r7, #4]
 80137ca:	683b      	ldr	r3, [r7, #0]
 80137cc:	4413      	add	r3, r2
 80137ce:	781b      	ldrb	r3, [r3, #0]
 80137d0:	2b00      	cmp	r3, #0
 80137d2:	bf14      	ite	ne
 80137d4:	2301      	movne	r3, #1
 80137d6:	2300      	moveq	r3, #0
 80137d8:	b2da      	uxtb	r2, r3
 80137da:	68bb      	ldr	r3, [r7, #8]
 80137dc:	689b      	ldr	r3, [r3, #8]
 80137de:	701a      	strb	r2, [r3, #0]
                break;
 80137e0:	e040      	b.n	8013864 <GetASN_StoreData+0x2dc>
            }
            if (asn->tag == ASN_TAG_NULL) {
 80137e2:	68fb      	ldr	r3, [r7, #12]
 80137e4:	785b      	ldrb	r3, [r3, #1]
 80137e6:	2b05      	cmp	r3, #5
 80137e8:	d10b      	bne.n	8013802 <GetASN_StoreData+0x27a>
                /* NULL has no data in BER. */
                if (len != 0) {
 80137ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80137ec:	2b00      	cmp	r3, #0
 80137ee:	d002      	beq.n	80137f6 <GetASN_StoreData+0x26e>
                #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                    WOLFSSL_MSG_VSNPRINTF("NULL length too long: %d", len);
                #endif
                    return ASN_EXPECT_0_E;
 80137f0:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 80137f4:	e037      	b.n	8013866 <GetASN_StoreData+0x2de>
                }
                data->data.ref.data = input + idx;
 80137f6:	687a      	ldr	r2, [r7, #4]
 80137f8:	683b      	ldr	r3, [r7, #0]
 80137fa:	441a      	add	r2, r3
 80137fc:	68bb      	ldr	r3, [r7, #8]
 80137fe:	609a      	str	r2, [r3, #8]
                break;
 8013800:	e030      	b.n	8013864 <GetASN_StoreData+0x2dc>
            }
            if (asn->tag == ASN_OBJECT_ID) {
 8013802:	68fb      	ldr	r3, [r7, #12]
 8013804:	785b      	ldrb	r3, [r3, #1]
 8013806:	2b06      	cmp	r3, #6
 8013808:	d11e      	bne.n	8013848 <GetASN_StoreData+0x2c0>
                word32 oidIdx = 0;
 801380a:	2300      	movs	r3, #0
 801380c:	617b      	str	r3, [r7, #20]
                /* Store OID data pointer and length */
                data->data.oid.data = input + idx;
 801380e:	687a      	ldr	r2, [r7, #4]
 8013810:	683b      	ldr	r3, [r7, #0]
 8013812:	441a      	add	r2, r3
 8013814:	68bb      	ldr	r3, [r7, #8]
 8013816:	609a      	str	r2, [r3, #8]
                data->data.oid.length = (word32)len;
 8013818:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801381a:	68bb      	ldr	r3, [r7, #8]
 801381c:	60da      	str	r2, [r3, #12]
                /* Get the OID sum. */
                err = GetOID(input + idx, &oidIdx, &data->data.oid.sum,
 801381e:	687a      	ldr	r2, [r7, #4]
 8013820:	683b      	ldr	r3, [r7, #0]
 8013822:	18d0      	adds	r0, r2, r3
 8013824:	68bb      	ldr	r3, [r7, #8]
 8013826:	f103 0214 	add.w	r2, r3, #20
 801382a:	68bb      	ldr	r3, [r7, #8]
 801382c:	691c      	ldr	r4, [r3, #16]
 801382e:	f107 0114 	add.w	r1, r7, #20
 8013832:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013834:	9300      	str	r3, [sp, #0]
 8013836:	4623      	mov	r3, r4
 8013838:	f001 f812 	bl	8014860 <GetOID>
 801383c:	61b8      	str	r0, [r7, #24]
                        data->data.oid.type, len);
                if (err < 0) {
 801383e:	69bb      	ldr	r3, [r7, #24]
 8013840:	2b00      	cmp	r3, #0
 8013842:	da0e      	bge.n	8013862 <GetASN_StoreData+0x2da>
                #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                    WOLFSSL_MSG_VSNPRINTF("OID check failed: %d", err);
                #endif
                    return err;
 8013844:	69bb      	ldr	r3, [r7, #24]
 8013846:	e00e      	b.n	8013866 <GetASN_StoreData+0x2de>
                }
                break;
            }

            /* Otherwise store data pointer and length. */
            data->data.ref.data = input + idx;
 8013848:	687a      	ldr	r2, [r7, #4]
 801384a:	683b      	ldr	r3, [r7, #0]
 801384c:	441a      	add	r2, r3
 801384e:	68bb      	ldr	r3, [r7, #8]
 8013850:	609a      	str	r2, [r3, #8]
            data->data.ref.length = (word32)len;
 8013852:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013854:	68bb      	ldr	r3, [r7, #8]
 8013856:	60da      	str	r2, [r3, #12]
            break;
 8013858:	e004      	b.n	8013864 <GetASN_StoreData+0x2dc>
            break;
 801385a:	bf00      	nop
 801385c:	e002      	b.n	8013864 <GetASN_StoreData+0x2dc>
            break;
 801385e:	bf00      	nop
 8013860:	e000      	b.n	8013864 <GetASN_StoreData+0x2dc>
                break;
 8013862:	bf00      	nop
        #endif
            return BAD_STATE_E;
    #endif
    }

    return 0;
 8013864:	2300      	movs	r3, #0
}
 8013866:	4618      	mov	r0, r3
 8013868:	3724      	adds	r7, #36	@ 0x24
 801386a:	46bd      	mov	sp, r7
 801386c:	bd90      	pop	{r4, r7, pc}
 801386e:	bf00      	nop

08013870 <GetASN_Items>:
 * @return  BAD_STATE_E when the data type is not supported.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int GetASN_Items(const ASNItem* asn, ASNGetData *data, int count, int complete,
                 const byte* input, word32* inOutIdx, word32 length)
{
 8013870:	b590      	push	{r4, r7, lr}
 8013872:	b09b      	sub	sp, #108	@ 0x6c
 8013874:	af02      	add	r7, sp, #8
 8013876:	60f8      	str	r0, [r7, #12]
 8013878:	60b9      	str	r1, [r7, #8]
 801387a:	607a      	str	r2, [r7, #4]
 801387c:	603b      	str	r3, [r7, #0]
    int    i;
    int    j;
    int    err;
    int    len;
    /* Current index into buffer. */
    word32 idx = *inOutIdx;
 801387e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8013880:	681b      	ldr	r3, [r3, #0]
 8013882:	633b      	str	r3, [r7, #48]	@ 0x30
    /* Declare the end index array. */
    word32 endIdx[GET_ASN_MAX_DEPTH];
    /* Set choices to -1 to indicate they haven't been seen or found. */
    signed char   choiceMet[GET_ASN_MAX_CHOICES] = { -1, -1 };
 8013884:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8013888:	823b      	strh	r3, [r7, #16]
    /* Not matching a choice right now. */
    int    choice = 0;
 801388a:	2300      	movs	r3, #0
 801388c:	657b      	str	r3, [r7, #84]	@ 0x54
#ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
    WOLFSSL_ENTER("GetASN_Items");
#endif

    /* Set the end index at each depth to be the length. */
    for (i=0; i<GET_ASN_MAX_DEPTH; i++) {
 801388e:	2300      	movs	r3, #0
 8013890:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8013892:	e009      	b.n	80138a8 <GetASN_Items+0x38>
        endIdx[i] = length;
 8013894:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013896:	009b      	lsls	r3, r3, #2
 8013898:	3360      	adds	r3, #96	@ 0x60
 801389a:	443b      	add	r3, r7
 801389c:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801389e:	f843 2c4c 	str.w	r2, [r3, #-76]
    for (i=0; i<GET_ASN_MAX_DEPTH; i++) {
 80138a2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80138a4:	3301      	adds	r3, #1
 80138a6:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80138a8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80138aa:	2b06      	cmp	r3, #6
 80138ac:	ddf2      	ble.n	8013894 <GetASN_Items+0x24>
    }

    /* Start depth at first items depth. */
    minDepth = depth = asn[0].depth;
 80138ae:	68fb      	ldr	r3, [r7, #12]
 80138b0:	781b      	ldrb	r3, [r3, #0]
 80138b2:	653b      	str	r3, [r7, #80]	@ 0x50
 80138b4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80138b6:	64fb      	str	r3, [r7, #76]	@ 0x4c
    /* Check every ASN.1 item. */
    for (i = 0; i < count; i++) {
 80138b8:	2300      	movs	r3, #0
 80138ba:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80138bc:	e245      	b.n	8013d4a <GetASN_Items+0x4da>
        /* Store offset of ASN.1 item. */
        data[i].offset = idx;
 80138be:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80138c0:	4613      	mov	r3, r2
 80138c2:	00db      	lsls	r3, r3, #3
 80138c4:	1a9b      	subs	r3, r3, r2
 80138c6:	009b      	lsls	r3, r3, #2
 80138c8:	461a      	mov	r2, r3
 80138ca:	68bb      	ldr	r3, [r7, #8]
 80138cc:	4413      	add	r3, r2
 80138ce:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80138d0:	601a      	str	r2, [r3, #0]
        /* Length of data in ASN.1 item starts empty. */
        data[i].length = 0;
 80138d2:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80138d4:	4613      	mov	r3, r2
 80138d6:	00db      	lsls	r3, r3, #3
 80138d8:	1a9b      	subs	r3, r3, r2
 80138da:	009b      	lsls	r3, r3, #2
 80138dc:	461a      	mov	r2, r3
 80138de:	68bb      	ldr	r3, [r7, #8]
 80138e0:	4413      	add	r3, r2
 80138e2:	2200      	movs	r2, #0
 80138e4:	605a      	str	r2, [r3, #4]
        /* Get current item depth. */
        depth = asn[i].depth;
 80138e6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80138e8:	009b      	lsls	r3, r3, #2
 80138ea:	68fa      	ldr	r2, [r7, #12]
 80138ec:	4413      	add	r3, r2
 80138ee:	781b      	ldrb	r3, [r3, #0]
 80138f0:	653b      	str	r3, [r7, #80]	@ 0x50
            WOLFSSL_MSG("Depth in template too large");
            return ASN_PARSE_E;
        }
    #endif
        /* Keep track of minimum depth. */
        if (depth < minDepth) {
 80138f2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80138f4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80138f6:	429a      	cmp	r2, r3
 80138f8:	da01      	bge.n	80138fe <GetASN_Items+0x8e>
            minDepth = depth;
 80138fa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80138fc:	64fb      	str	r3, [r7, #76]	@ 0x4c
        }

        /* Reset choice if different from previous. */
        if (choice > 0 && asn[i].optional != choice) {
 80138fe:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8013900:	2b00      	cmp	r3, #0
 8013902:	dd0a      	ble.n	801391a <GetASN_Items+0xaa>
 8013904:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013906:	009b      	lsls	r3, r3, #2
 8013908:	68fa      	ldr	r2, [r7, #12]
 801390a:	4413      	add	r3, r2
 801390c:	78db      	ldrb	r3, [r3, #3]
 801390e:	461a      	mov	r2, r3
 8013910:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8013912:	4293      	cmp	r3, r2
 8013914:	d001      	beq.n	801391a <GetASN_Items+0xaa>
            choice = 0;
 8013916:	2300      	movs	r3, #0
 8013918:	657b      	str	r3, [r7, #84]	@ 0x54
        }
        /* Check if first of numbered choice. */
        if (choice == 0 && asn[i].optional > 1) {
 801391a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801391c:	2b00      	cmp	r3, #0
 801391e:	d122      	bne.n	8013966 <GetASN_Items+0xf6>
 8013920:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013922:	009b      	lsls	r3, r3, #2
 8013924:	68fa      	ldr	r2, [r7, #12]
 8013926:	4413      	add	r3, r2
 8013928:	78db      	ldrb	r3, [r3, #3]
 801392a:	2b01      	cmp	r3, #1
 801392c:	d91b      	bls.n	8013966 <GetASN_Items+0xf6>
            choice = asn[i].optional;
 801392e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013930:	009b      	lsls	r3, r3, #2
 8013932:	68fa      	ldr	r2, [r7, #12]
 8013934:	4413      	add	r3, r2
 8013936:	78db      	ldrb	r3, [r3, #3]
 8013938:	657b      	str	r3, [r7, #84]	@ 0x54
            tmpScharVal = choiceMet[choice - 2];
 801393a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801393c:	3b02      	subs	r3, #2
 801393e:	3360      	adds	r3, #96	@ 0x60
 8013940:	443b      	add	r3, r7
 8013942:	f813 3c50 	ldrb.w	r3, [r3, #-80]
 8013946:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
            XFENCE(); /* Prevent memory access */
 801394a:	f3bf 8f5b 	dmb	ish
            if (tmpScharVal == -1) {
 801394e:	f997 3047 	ldrsb.w	r3, [r7, #71]	@ 0x47
 8013952:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8013956:	d106      	bne.n	8013966 <GetASN_Items+0xf6>
                /* Choice seen but not found a match yet. */
                choiceMet[choice - 2] = 0;
 8013958:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801395a:	3b02      	subs	r3, #2
 801395c:	3360      	adds	r3, #96	@ 0x60
 801395e:	443b      	add	r3, r7
 8013960:	2200      	movs	r2, #0
 8013962:	f803 2c50 	strb.w	r2, [r3, #-80]
            }
        }

        /* Check for end of data or not a choice and tag not matching. */
        tmpW32Val = endIdx[depth];
 8013966:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013968:	009b      	lsls	r3, r3, #2
 801396a:	3360      	adds	r3, #96	@ 0x60
 801396c:	443b      	add	r3, r7
 801396e:	f853 3c4c 	ldr.w	r3, [r3, #-76]
 8013972:	643b      	str	r3, [r7, #64]	@ 0x40
        XFENCE(); /* Prevent memory access */
 8013974:	f3bf 8f5b 	dmb	ish
        if (idx == tmpW32Val || (data[i].dataType != ASN_DATA_TYPE_CHOICE &&
 8013978:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801397a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801397c:	429a      	cmp	r2, r3
 801397e:	d017      	beq.n	80139b0 <GetASN_Items+0x140>
 8013980:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013982:	4613      	mov	r3, r2
 8013984:	00db      	lsls	r3, r3, #3
 8013986:	1a9b      	subs	r3, r3, r2
 8013988:	009b      	lsls	r3, r3, #2
 801398a:	461a      	mov	r2, r3
 801398c:	68bb      	ldr	r3, [r7, #8]
 801398e:	4413      	add	r3, r2
 8013990:	7e1b      	ldrb	r3, [r3, #24]
 8013992:	2b0b      	cmp	r3, #11
 8013994:	d06e      	beq.n	8013a74 <GetASN_Items+0x204>
                              (input[idx] & ~ASN_CONSTRUCTED) != asn[i].tag)) {
 8013996:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013998:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801399a:	4413      	add	r3, r2
 801399c:	781b      	ldrb	r3, [r3, #0]
 801399e:	f023 0320 	bic.w	r3, r3, #32
 80139a2:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80139a4:	0092      	lsls	r2, r2, #2
 80139a6:	68f9      	ldr	r1, [r7, #12]
 80139a8:	440a      	add	r2, r1
 80139aa:	7852      	ldrb	r2, [r2, #1]
        if (idx == tmpW32Val || (data[i].dataType != ASN_DATA_TYPE_CHOICE &&
 80139ac:	4293      	cmp	r3, r2
 80139ae:	d061      	beq.n	8013a74 <GetASN_Items+0x204>
            if (asn[i].optional) {
 80139b0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80139b2:	009b      	lsls	r3, r3, #2
 80139b4:	68fa      	ldr	r2, [r7, #12]
 80139b6:	4413      	add	r3, r2
 80139b8:	78db      	ldrb	r3, [r3, #3]
 80139ba:	2b00      	cmp	r3, #0
 80139bc:	d030      	beq.n	8013a20 <GetASN_Items+0x1b0>
                /* Skip over ASN.1 items underneath this optional item. */
                for (j = i + 1; j < count; j++) {
 80139be:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80139c0:	3301      	adds	r3, #1
 80139c2:	65bb      	str	r3, [r7, #88]	@ 0x58
 80139c4:	e022      	b.n	8013a0c <GetASN_Items+0x19c>
                    if (asn[i].depth >= asn[j].depth)
 80139c6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80139c8:	009b      	lsls	r3, r3, #2
 80139ca:	68fa      	ldr	r2, [r7, #12]
 80139cc:	4413      	add	r3, r2
 80139ce:	781a      	ldrb	r2, [r3, #0]
 80139d0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80139d2:	009b      	lsls	r3, r3, #2
 80139d4:	68f9      	ldr	r1, [r7, #12]
 80139d6:	440b      	add	r3, r1
 80139d8:	781b      	ldrb	r3, [r3, #0]
 80139da:	429a      	cmp	r2, r3
 80139dc:	d21b      	bcs.n	8013a16 <GetASN_Items+0x1a6>
                        break;
                    data[j].offset = idx;
 80139de:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80139e0:	4613      	mov	r3, r2
 80139e2:	00db      	lsls	r3, r3, #3
 80139e4:	1a9b      	subs	r3, r3, r2
 80139e6:	009b      	lsls	r3, r3, #2
 80139e8:	461a      	mov	r2, r3
 80139ea:	68bb      	ldr	r3, [r7, #8]
 80139ec:	4413      	add	r3, r2
 80139ee:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80139f0:	601a      	str	r2, [r3, #0]
                    data[j].length = 0;
 80139f2:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80139f4:	4613      	mov	r3, r2
 80139f6:	00db      	lsls	r3, r3, #3
 80139f8:	1a9b      	subs	r3, r3, r2
 80139fa:	009b      	lsls	r3, r3, #2
 80139fc:	461a      	mov	r2, r3
 80139fe:	68bb      	ldr	r3, [r7, #8]
 8013a00:	4413      	add	r3, r2
 8013a02:	2200      	movs	r2, #0
 8013a04:	605a      	str	r2, [r3, #4]
                for (j = i + 1; j < count; j++) {
 8013a06:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013a08:	3301      	adds	r3, #1
 8013a0a:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013a0c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8013a0e:	687b      	ldr	r3, [r7, #4]
 8013a10:	429a      	cmp	r2, r3
 8013a12:	dbd8      	blt.n	80139c6 <GetASN_Items+0x156>
 8013a14:	e000      	b.n	8013a18 <GetASN_Items+0x1a8>
                        break;
 8013a16:	bf00      	nop
                }
                i = j - 1;
 8013a18:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013a1a:	3b01      	subs	r3, #1
 8013a1c:	65fb      	str	r3, [r7, #92]	@ 0x5c
                continue;
 8013a1e:	e191      	b.n	8013d44 <GetASN_Items+0x4d4>
            }

            /* Check for end of data. */
            if (idx == length) {
 8013a20:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a22:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8013a24:	429a      	cmp	r2, r3
 8013a26:	d102      	bne.n	8013a2e <GetASN_Items+0x1be>
                    asn[i].constructed ? '+' : ' ', asn[i].depth, "",
                    TagString(asn[i].tag), 6 - asn[i].depth, "");
                WOLFSSL_MSG_VSNPRINTF("Index past end of data: %d %d", idx,
                        length);
        #endif
                return BUFFER_E;
 8013a28:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013a2c:	e1c3      	b.n	8013db6 <GetASN_Items+0x546>
                asn[i].constructed ? '+' : ' ', asn[i].depth, "",
                TagString(asn[i].tag), 6 - asn[i].depth, "",
                input[idx], TagString(input[idx]));
        #endif
            /* Check for end of data at this depth. */
            if (idx == endIdx[depth]) {
 8013a2e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013a30:	009b      	lsls	r3, r3, #2
 8013a32:	3360      	adds	r3, #96	@ 0x60
 8013a34:	443b      	add	r3, r7
 8013a36:	f853 2c4c 	ldr.w	r2, [r3, #-76]
 8013a3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a3c:	429a      	cmp	r2, r3
 8013a3e:	d102      	bne.n	8013a46 <GetASN_Items+0x1d6>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Index past outer item: %d %d", idx,
                        endIdx[depth]);
            #endif
                return ASN_PARSE_E;
 8013a40:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013a44:	e1b7      	b.n	8013db6 <GetASN_Items+0x546>
            }

            /* Expecting an OBJECT_ID */
            if (asn[i].tag == ASN_OBJECT_ID) {
 8013a46:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013a48:	009b      	lsls	r3, r3, #2
 8013a4a:	68fa      	ldr	r2, [r7, #12]
 8013a4c:	4413      	add	r3, r2
 8013a4e:	785b      	ldrb	r3, [r3, #1]
 8013a50:	2b06      	cmp	r3, #6
 8013a52:	d102      	bne.n	8013a5a <GetASN_Items+0x1ea>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Expecting OBJECT ID");
            #endif
                return ASN_OBJECT_ID_E;
 8013a54:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8013a58:	e1ad      	b.n	8013db6 <GetASN_Items+0x546>
            }
            /* Expecting a BIT_STRING */
            if (asn[i].tag == ASN_BIT_STRING) {
 8013a5a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013a5c:	009b      	lsls	r3, r3, #2
 8013a5e:	68fa      	ldr	r2, [r7, #12]
 8013a60:	4413      	add	r3, r2
 8013a62:	785b      	ldrb	r3, [r3, #1]
 8013a64:	2b03      	cmp	r3, #3
 8013a66:	d102      	bne.n	8013a6e <GetASN_Items+0x1fe>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Expecting BIT STRING");
            #endif
                return ASN_BITSTR_E;
 8013a68:	f06f 0392 	mvn.w	r3, #146	@ 0x92
 8013a6c:	e1a3      	b.n	8013db6 <GetASN_Items+0x546>
            }
            /* Not the expected tag. */
        #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
            WOLFSSL_MSG("Bad tag");
        #endif
            return ASN_PARSE_E;
 8013a6e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013a72:	e1a0      	b.n	8013db6 <GetASN_Items+0x546>
        }

        /* Store found tag in data. */
        data[i].tag = input[idx];
 8013a74:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a76:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013a78:	18d1      	adds	r1, r2, r3
 8013a7a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013a7c:	4613      	mov	r3, r2
 8013a7e:	00db      	lsls	r3, r3, #3
 8013a80:	1a9b      	subs	r3, r3, r2
 8013a82:	009b      	lsls	r3, r3, #2
 8013a84:	461a      	mov	r2, r3
 8013a86:	68bb      	ldr	r3, [r7, #8]
 8013a88:	4413      	add	r3, r2
 8013a8a:	780a      	ldrb	r2, [r1, #0]
 8013a8c:	765a      	strb	r2, [r3, #25]
        XFENCE(); /* Prevent memory access */
 8013a8e:	f3bf 8f5b 	dmb	ish
        if (data[i].dataType != ASN_DATA_TYPE_CHOICE) {
 8013a92:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013a94:	4613      	mov	r3, r2
 8013a96:	00db      	lsls	r3, r3, #3
 8013a98:	1a9b      	subs	r3, r3, r2
 8013a9a:	009b      	lsls	r3, r3, #2
 8013a9c:	461a      	mov	r2, r3
 8013a9e:	68bb      	ldr	r3, [r7, #8]
 8013aa0:	4413      	add	r3, r2
 8013aa2:	7e1b      	ldrb	r3, [r3, #24]
 8013aa4:	2b0b      	cmp	r3, #11
 8013aa6:	d01a      	beq.n	8013ade <GetASN_Items+0x26e>
            int constructed = (input[idx] & ASN_CONSTRUCTED) == ASN_CONSTRUCTED;
 8013aa8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013aaa:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013aac:	4413      	add	r3, r2
 8013aae:	781b      	ldrb	r3, [r3, #0]
 8013ab0:	f003 0320 	and.w	r3, r3, #32
 8013ab4:	2b00      	cmp	r3, #0
 8013ab6:	bf14      	ite	ne
 8013ab8:	2301      	movne	r3, #1
 8013aba:	2300      	moveq	r3, #0
 8013abc:	b2db      	uxtb	r3, r3
 8013abe:	63fb      	str	r3, [r7, #60]	@ 0x3c
            /* Check constructed match expected for non-choice ASN.1 item. */
            if (asn[i].constructed != constructed) {
 8013ac0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013ac2:	009b      	lsls	r3, r3, #2
 8013ac4:	68fa      	ldr	r2, [r7, #12]
 8013ac6:	4413      	add	r3, r2
 8013ac8:	789b      	ldrb	r3, [r3, #2]
 8013aca:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8013ace:	b2db      	uxtb	r3, r3
 8013ad0:	461a      	mov	r2, r3
 8013ad2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8013ad4:	4293      	cmp	r3, r2
 8013ad6:	d002      	beq.n	8013ade <GetASN_Items+0x26e>
                }
                else {
                    WOLFSSL_MSG("Not expected to be constructed");
                }
            #endif
                return ASN_PARSE_E;
 8013ad8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013adc:	e16b      	b.n	8013db6 <GetASN_Items+0x546>
            }
        }
        /* Move index to start of length. */
        idx++;
 8013ade:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013ae0:	3301      	adds	r3, #1
 8013ae2:	633b      	str	r3, [r7, #48]	@ 0x30
        /* Get the encoded length. */
        if (GetASN_Length(input, &idx, &len, endIdx[depth], 1) < 0) {
 8013ae4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013ae6:	009b      	lsls	r3, r3, #2
 8013ae8:	3360      	adds	r3, #96	@ 0x60
 8013aea:	443b      	add	r3, r7
 8013aec:	f853 3c4c 	ldr.w	r3, [r3, #-76]
 8013af0:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 8013af4:	f107 0130 	add.w	r1, r7, #48	@ 0x30
 8013af8:	2001      	movs	r0, #1
 8013afa:	9000      	str	r0, [sp, #0]
 8013afc:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013afe:	f000 f9c2 	bl	8013e86 <GetLength_ex>
 8013b02:	4603      	mov	r3, r0
 8013b04:	2b00      	cmp	r3, #0
 8013b06:	da02      	bge.n	8013b0e <GetASN_Items+0x29e>
        #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
            WOLFSSL_MSG_VSNPRINTF("%2d: idx=%d len=%d end=%d", i, idx, len,
                    endIdx[depth]);
        #endif
            return ASN_PARSE_E;
 8013b08:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013b0c:	e153      	b.n	8013db6 <GetASN_Items+0x546>
        }
        /* Store length of data. */
        data[i].length = (word32)len;
 8013b0e:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8013b10:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013b12:	4613      	mov	r3, r2
 8013b14:	00db      	lsls	r3, r3, #3
 8013b16:	1a9b      	subs	r3, r3, r2
 8013b18:	009b      	lsls	r3, r3, #2
 8013b1a:	461a      	mov	r2, r3
 8013b1c:	68bb      	ldr	r3, [r7, #8]
 8013b1e:	4413      	add	r3, r2
 8013b20:	460a      	mov	r2, r1
 8013b22:	605a      	str	r2, [r3, #4]
        /* Note the max length of items under this one. */
        endIdx[depth + 1] = idx + (word32)len;
 8013b24:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013b26:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013b28:	4619      	mov	r1, r3
 8013b2a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013b2c:	3301      	adds	r3, #1
 8013b2e:	440a      	add	r2, r1
 8013b30:	009b      	lsls	r3, r3, #2
 8013b32:	3360      	adds	r3, #96	@ 0x60
 8013b34:	443b      	add	r3, r7
 8013b36:	f843 2c4c 	str.w	r2, [r3, #-76]
        if (choice > 1) {
 8013b3a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8013b3c:	2b01      	cmp	r3, #1
 8013b3e:	dd06      	ble.n	8013b4e <GetASN_Items+0x2de>
            /* Note we found a number choice. */
            choiceMet[choice - 2] = 1;
 8013b40:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8013b42:	3b02      	subs	r3, #2
 8013b44:	3360      	adds	r3, #96	@ 0x60
 8013b46:	443b      	add	r3, r7
 8013b48:	2201      	movs	r2, #1
 8013b4a:	f803 2c50 	strb.w	r2, [r3, #-80]
                data[i].offset, data[i].length, asn[i].constructed ? '+' : ' ',
                asn[i].depth, "", TagString(data[i].tag));
    #endif

        /* Assume no zero padding on INTEGER. */
        zeroPadded = 0;
 8013b4e:	2300      	movs	r3, #0
 8013b50:	64bb      	str	r3, [r7, #72]	@ 0x48
        /* Check data types that prepended a byte. */
        if (asn[i].tag == ASN_INTEGER) {
 8013b52:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013b54:	009b      	lsls	r3, r3, #2
 8013b56:	68fa      	ldr	r2, [r7, #12]
 8013b58:	4413      	add	r3, r2
 8013b5a:	785b      	ldrb	r3, [r3, #1]
 8013b5c:	2b02      	cmp	r3, #2
 8013b5e:	d136      	bne.n	8013bce <GetASN_Items+0x35e>
            /* Check validity of first byte. */
            err = GetASN_Integer(input, idx, len,
 8013b60:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8013b62:	6b78      	ldr	r0, [r7, #52]	@ 0x34
                    data[i].dataType == ASN_DATA_TYPE_MP ||
 8013b64:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013b66:	4613      	mov	r3, r2
 8013b68:	00db      	lsls	r3, r3, #3
 8013b6a:	1a9b      	subs	r3, r3, r2
 8013b6c:	009b      	lsls	r3, r3, #2
 8013b6e:	461a      	mov	r2, r3
 8013b70:	68bb      	ldr	r3, [r7, #8]
 8013b72:	4413      	add	r3, r2
 8013b74:	7e1b      	ldrb	r3, [r3, #24]
            err = GetASN_Integer(input, idx, len,
 8013b76:	2b08      	cmp	r3, #8
 8013b78:	d00a      	beq.n	8013b90 <GetASN_Items+0x320>
                    data[i].dataType == ASN_DATA_TYPE_MP_INITED);
 8013b7a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013b7c:	4613      	mov	r3, r2
 8013b7e:	00db      	lsls	r3, r3, #3
 8013b80:	1a9b      	subs	r3, r3, r2
 8013b82:	009b      	lsls	r3, r3, #2
 8013b84:	461a      	mov	r2, r3
 8013b86:	68bb      	ldr	r3, [r7, #8]
 8013b88:	4413      	add	r3, r2
 8013b8a:	7e1b      	ldrb	r3, [r3, #24]
            err = GetASN_Integer(input, idx, len,
 8013b8c:	2b09      	cmp	r3, #9
 8013b8e:	d101      	bne.n	8013b94 <GetASN_Items+0x324>
 8013b90:	2301      	movs	r3, #1
 8013b92:	e000      	b.n	8013b96 <GetASN_Items+0x326>
 8013b94:	2300      	movs	r3, #0
 8013b96:	4602      	mov	r2, r0
 8013b98:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013b9a:	f7ff fbe5 	bl	8013368 <GetASN_Integer>
 8013b9e:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013ba0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013ba2:	2b00      	cmp	r3, #0
 8013ba4:	d001      	beq.n	8013baa <GetASN_Items+0x33a>
                return err;
 8013ba6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013ba8:	e105      	b.n	8013db6 <GetASN_Items+0x546>
            if (len > 1 && input[idx] == 0) {
 8013baa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013bac:	2b01      	cmp	r3, #1
 8013bae:	dd59      	ble.n	8013c64 <GetASN_Items+0x3f4>
 8013bb0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013bb2:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013bb4:	4413      	add	r3, r2
 8013bb6:	781b      	ldrb	r3, [r3, #0]
 8013bb8:	2b00      	cmp	r3, #0
 8013bba:	d153      	bne.n	8013c64 <GetASN_Items+0x3f4>
                zeroPadded = 1;
 8013bbc:	2301      	movs	r3, #1
 8013bbe:	64bb      	str	r3, [r7, #72]	@ 0x48
                /* Move over prepended byte. */
                idx++;
 8013bc0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013bc2:	3301      	adds	r3, #1
 8013bc4:	633b      	str	r3, [r7, #48]	@ 0x30
                len--;
 8013bc6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013bc8:	3b01      	subs	r3, #1
 8013bca:	637b      	str	r3, [r7, #52]	@ 0x34
 8013bcc:	e04a      	b.n	8013c64 <GetASN_Items+0x3f4>
            }
        }
        else if (asn[i].tag == ASN_BIT_STRING) {
 8013bce:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013bd0:	009b      	lsls	r3, r3, #2
 8013bd2:	68fa      	ldr	r2, [r7, #12]
 8013bd4:	4413      	add	r3, r2
 8013bd6:	785b      	ldrb	r3, [r3, #1]
 8013bd8:	2b03      	cmp	r3, #3
 8013bda:	d112      	bne.n	8013c02 <GetASN_Items+0x392>
            /* Check prepended byte is correct. */
            err = GetASN_BitString(input, idx, len);
 8013bdc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013bde:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013be0:	4619      	mov	r1, r3
 8013be2:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013be4:	f7ff fc09 	bl	80133fa <GetASN_BitString>
 8013be8:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013bea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013bec:	2b00      	cmp	r3, #0
 8013bee:	d001      	beq.n	8013bf4 <GetASN_Items+0x384>
                return err;
 8013bf0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013bf2:	e0e0      	b.n	8013db6 <GetASN_Items+0x546>
            /* Move over prepended byte. */
            idx++;
 8013bf4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013bf6:	3301      	adds	r3, #1
 8013bf8:	633b      	str	r3, [r7, #48]	@ 0x30
            len--;
 8013bfa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013bfc:	3b01      	subs	r3, #1
 8013bfe:	637b      	str	r3, [r7, #52]	@ 0x34
 8013c00:	e030      	b.n	8013c64 <GetASN_Items+0x3f4>
        }
    #ifndef WOLFSSL_NO_ASN_STRICT
        else if ((asn[i].tag == ASN_UTF8STRING) ||
 8013c02:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013c04:	009b      	lsls	r3, r3, #2
 8013c06:	68fa      	ldr	r2, [r7, #12]
 8013c08:	4413      	add	r3, r2
 8013c0a:	785b      	ldrb	r3, [r3, #1]
 8013c0c:	2b0c      	cmp	r3, #12
 8013c0e:	d00a      	beq.n	8013c26 <GetASN_Items+0x3b6>
                 (data[i].tag == ASN_UTF8STRING)) {
 8013c10:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013c12:	4613      	mov	r3, r2
 8013c14:	00db      	lsls	r3, r3, #3
 8013c16:	1a9b      	subs	r3, r3, r2
 8013c18:	009b      	lsls	r3, r3, #2
 8013c1a:	461a      	mov	r2, r3
 8013c1c:	68bb      	ldr	r3, [r7, #8]
 8013c1e:	4413      	add	r3, r2
 8013c20:	7e5b      	ldrb	r3, [r3, #25]
        else if ((asn[i].tag == ASN_UTF8STRING) ||
 8013c22:	2b0c      	cmp	r3, #12
 8013c24:	d10b      	bne.n	8013c3e <GetASN_Items+0x3ce>
            /* Check validity of data. */
            err = GetASN_UTF8String(input, idx, len);
 8013c26:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013c28:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013c2a:	4619      	mov	r1, r3
 8013c2c:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013c2e:	f7ff fc16 	bl	801345e <GetASN_UTF8String>
 8013c32:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013c34:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013c36:	2b00      	cmp	r3, #0
 8013c38:	d014      	beq.n	8013c64 <GetASN_Items+0x3f4>
                return err;
 8013c3a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013c3c:	e0bb      	b.n	8013db6 <GetASN_Items+0x546>
        }
    #endif
        else if (asn[i].tag == ASN_OBJECT_ID) {
 8013c3e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013c40:	009b      	lsls	r3, r3, #2
 8013c42:	68fa      	ldr	r2, [r7, #12]
 8013c44:	4413      	add	r3, r2
 8013c46:	785b      	ldrb	r3, [r3, #1]
 8013c48:	2b06      	cmp	r3, #6
 8013c4a:	d10b      	bne.n	8013c64 <GetASN_Items+0x3f4>
            /* Check validity of data. */
            err = GetASN_ObjectId(input, idx, len);
 8013c4c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013c4e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013c50:	4619      	mov	r1, r3
 8013c52:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013c54:	f7ff fc75 	bl	8013542 <GetASN_ObjectId>
 8013c58:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013c5a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013c5c:	2b00      	cmp	r3, #0
 8013c5e:	d001      	beq.n	8013c64 <GetASN_Items+0x3f4>
                return err;
 8013c60:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013c62:	e0a8      	b.n	8013db6 <GetASN_Items+0x546>
        }

        /* Don't parse data if only header required. */
        if (asn[i].headerOnly) {
 8013c64:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013c66:	009b      	lsls	r3, r3, #2
 8013c68:	68fa      	ldr	r2, [r7, #12]
 8013c6a:	4413      	add	r3, r2
 8013c6c:	789b      	ldrb	r3, [r3, #2]
 8013c6e:	f003 0302 	and.w	r3, r3, #2
 8013c72:	b2db      	uxtb	r3, r3
 8013c74:	2b00      	cmp	r3, #0
 8013c76:	d017      	beq.n	8013ca8 <GetASN_Items+0x438>
            /* Store reference to data and length. */
            data[i].data.ref.data = input + idx;
 8013c78:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8013c7a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013c7c:	4613      	mov	r3, r2
 8013c7e:	00db      	lsls	r3, r3, #3
 8013c80:	1a9b      	subs	r3, r3, r2
 8013c82:	009b      	lsls	r3, r3, #2
 8013c84:	461a      	mov	r2, r3
 8013c86:	68bb      	ldr	r3, [r7, #8]
 8013c88:	4413      	add	r3, r2
 8013c8a:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013c8c:	440a      	add	r2, r1
 8013c8e:	609a      	str	r2, [r3, #8]
            data[i].data.ref.length = (word32)len;
 8013c90:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8013c92:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013c94:	4613      	mov	r3, r2
 8013c96:	00db      	lsls	r3, r3, #3
 8013c98:	1a9b      	subs	r3, r3, r2
 8013c9a:	009b      	lsls	r3, r3, #2
 8013c9c:	461a      	mov	r2, r3
 8013c9e:	68bb      	ldr	r3, [r7, #8]
 8013ca0:	4413      	add	r3, r2
 8013ca2:	460a      	mov	r2, r1
 8013ca4:	60da      	str	r2, [r3, #12]
            continue;
 8013ca6:	e04d      	b.n	8013d44 <GetASN_Items+0x4d4>
        }

        /* Store the data at idx in the ASN data item. */
        err = GetASN_StoreData(&asn[i], &data[i], input, idx, len, zeroPadded);
 8013ca8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013caa:	009b      	lsls	r3, r3, #2
 8013cac:	68fa      	ldr	r2, [r7, #12]
 8013cae:	18d0      	adds	r0, r2, r3
 8013cb0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013cb2:	4613      	mov	r3, r2
 8013cb4:	00db      	lsls	r3, r3, #3
 8013cb6:	1a9b      	subs	r3, r3, r2
 8013cb8:	009b      	lsls	r3, r3, #2
 8013cba:	461a      	mov	r2, r3
 8013cbc:	68bb      	ldr	r3, [r7, #8]
 8013cbe:	1899      	adds	r1, r3, r2
 8013cc0:	6b3c      	ldr	r4, [r7, #48]	@ 0x30
 8013cc2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013cc4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8013cc6:	9201      	str	r2, [sp, #4]
 8013cc8:	9300      	str	r3, [sp, #0]
 8013cca:	4623      	mov	r3, r4
 8013ccc:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013cce:	f7ff fc5b 	bl	8013588 <GetASN_StoreData>
 8013cd2:	63b8      	str	r0, [r7, #56]	@ 0x38
        if (err != 0) {
 8013cd4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013cd6:	2b00      	cmp	r3, #0
 8013cd8:	d001      	beq.n	8013cde <GetASN_Items+0x46e>
            return err;
 8013cda:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013cdc:	e06b      	b.n	8013db6 <GetASN_Items+0x546>
        }

        /* Move index to next item. */
        idx += (word32)len;
 8013cde:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013ce0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013ce2:	4413      	add	r3, r2
 8013ce4:	633b      	str	r3, [r7, #48]	@ 0x30

        /* When matched numbered choice ... */
        if (asn[i].optional > 1) {
 8013ce6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013ce8:	009b      	lsls	r3, r3, #2
 8013cea:	68fa      	ldr	r2, [r7, #12]
 8013cec:	4413      	add	r3, r2
 8013cee:	78db      	ldrb	r3, [r3, #3]
 8013cf0:	2b01      	cmp	r3, #1
 8013cf2:	d927      	bls.n	8013d44 <GetASN_Items+0x4d4>
            /* Skip over other ASN.1 items of the same number. */
            for (j = i + 1; j < count; j++) {
 8013cf4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013cf6:	3301      	adds	r3, #1
 8013cf8:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013cfa:	e01a      	b.n	8013d32 <GetASN_Items+0x4c2>
                if (asn[j].depth <= asn[i].depth &&
 8013cfc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013cfe:	009b      	lsls	r3, r3, #2
 8013d00:	68fa      	ldr	r2, [r7, #12]
 8013d02:	4413      	add	r3, r2
 8013d04:	781a      	ldrb	r2, [r3, #0]
 8013d06:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013d08:	009b      	lsls	r3, r3, #2
 8013d0a:	68f9      	ldr	r1, [r7, #12]
 8013d0c:	440b      	add	r3, r1
 8013d0e:	781b      	ldrb	r3, [r3, #0]
 8013d10:	429a      	cmp	r2, r3
 8013d12:	d80b      	bhi.n	8013d2c <GetASN_Items+0x4bc>
                                           asn[j].optional != asn[i].optional) {
 8013d14:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013d16:	009b      	lsls	r3, r3, #2
 8013d18:	68fa      	ldr	r2, [r7, #12]
 8013d1a:	4413      	add	r3, r2
 8013d1c:	78da      	ldrb	r2, [r3, #3]
 8013d1e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013d20:	009b      	lsls	r3, r3, #2
 8013d22:	68f9      	ldr	r1, [r7, #12]
 8013d24:	440b      	add	r3, r1
 8013d26:	78db      	ldrb	r3, [r3, #3]
                if (asn[j].depth <= asn[i].depth &&
 8013d28:	429a      	cmp	r2, r3
 8013d2a:	d107      	bne.n	8013d3c <GetASN_Items+0x4cc>
            for (j = i + 1; j < count; j++) {
 8013d2c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013d2e:	3301      	adds	r3, #1
 8013d30:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013d32:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8013d34:	687b      	ldr	r3, [r7, #4]
 8013d36:	429a      	cmp	r2, r3
 8013d38:	dbe0      	blt.n	8013cfc <GetASN_Items+0x48c>
 8013d3a:	e000      	b.n	8013d3e <GetASN_Items+0x4ce>
                   break;
 8013d3c:	bf00      	nop
                }
            }
            i = j - 1;
 8013d3e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013d40:	3b01      	subs	r3, #1
 8013d42:	65fb      	str	r3, [r7, #92]	@ 0x5c
    for (i = 0; i < count; i++) {
 8013d44:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013d46:	3301      	adds	r3, #1
 8013d48:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8013d4a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013d4c:	687b      	ldr	r3, [r7, #4]
 8013d4e:	429a      	cmp	r2, r3
 8013d50:	f6ff adb5 	blt.w	80138be <GetASN_Items+0x4e>
        }
    }

    if (complete) {
 8013d54:	683b      	ldr	r3, [r7, #0]
 8013d56:	2b00      	cmp	r3, #0
 8013d58:	d015      	beq.n	8013d86 <GetASN_Items+0x516>
        /* When expecting ASN.1 items to completely use data, check we did. */
        for (j = depth; j > minDepth; j--) {
 8013d5a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013d5c:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013d5e:	e00e      	b.n	8013d7e <GetASN_Items+0x50e>
            if (idx < endIdx[j]) {
 8013d60:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013d62:	009b      	lsls	r3, r3, #2
 8013d64:	3360      	adds	r3, #96	@ 0x60
 8013d66:	443b      	add	r3, r7
 8013d68:	f853 2c4c 	ldr.w	r2, [r3, #-76]
 8013d6c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013d6e:	429a      	cmp	r2, r3
 8013d70:	d902      	bls.n	8013d78 <GetASN_Items+0x508>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF(
                    "More data in constructed item at depth: %d", j - 1);
            #endif
                return ASN_PARSE_E;
 8013d72:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013d76:	e01e      	b.n	8013db6 <GetASN_Items+0x546>
        for (j = depth; j > minDepth; j--) {
 8013d78:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013d7a:	3b01      	subs	r3, #1
 8013d7c:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013d7e:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8013d80:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8013d82:	429a      	cmp	r2, r3
 8013d84:	dcec      	bgt.n	8013d60 <GetASN_Items+0x4f0>
            }
        }
    }

    /* Check all choices where met - found an item for them. */
    for (j = 0; j < GET_ASN_MAX_CHOICES; j++) {
 8013d86:	2300      	movs	r3, #0
 8013d88:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013d8a:	e00d      	b.n	8013da8 <GetASN_Items+0x538>
        if (choiceMet[j] == 0) {
 8013d8c:	f107 0210 	add.w	r2, r7, #16
 8013d90:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013d92:	4413      	add	r3, r2
 8013d94:	f993 3000 	ldrsb.w	r3, [r3]
 8013d98:	2b00      	cmp	r3, #0
 8013d9a:	d102      	bne.n	8013da2 <GetASN_Items+0x532>
        #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
            WOLFSSL_MSG_VSNPRINTF("No choice seen: %d", j + 2);
        #endif
            return ASN_PARSE_E;
 8013d9c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013da0:	e009      	b.n	8013db6 <GetASN_Items+0x546>
    for (j = 0; j < GET_ASN_MAX_CHOICES; j++) {
 8013da2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013da4:	3301      	adds	r3, #1
 8013da6:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013da8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013daa:	2b01      	cmp	r3, #1
 8013dac:	ddee      	ble.n	8013d8c <GetASN_Items+0x51c>
        }
    }

    /* Return index after ASN.1 data has been parsed. */
    *inOutIdx = idx;
 8013dae:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013db0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8013db2:	601a      	str	r2, [r3, #0]

    return 0;
 8013db4:	2300      	movs	r3, #0
}
 8013db6:	4618      	mov	r0, r3
 8013db8:	3764      	adds	r7, #100	@ 0x64
 8013dba:	46bd      	mov	sp, r7
 8013dbc:	bd90      	pop	{r4, r7, pc}

08013dbe <GetASN_Sequence>:
 * @return  BUFFER_E when not enough data to complete decode.
 * @return  ASN_PARSE when decoding failed.
 */
static int GetASN_Sequence(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx, int complete)
{
 8013dbe:	b580      	push	{r7, lr}
 8013dc0:	b088      	sub	sp, #32
 8013dc2:	af02      	add	r7, sp, #8
 8013dc4:	60f8      	str	r0, [r7, #12]
 8013dc6:	60b9      	str	r1, [r7, #8]
 8013dc8:	607a      	str	r2, [r7, #4]
 8013dca:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8013dcc:	2300      	movs	r3, #0
 8013dce:	617b      	str	r3, [r7, #20]
    word32 idx = *inOutIdx;
 8013dd0:	68bb      	ldr	r3, [r7, #8]
 8013dd2:	681b      	ldr	r3, [r3, #0]
 8013dd4:	613b      	str	r3, [r7, #16]

    /* Check buffer big enough for tag. */
    if (idx + 1 > maxIdx) {
 8013dd6:	693b      	ldr	r3, [r7, #16]
 8013dd8:	3301      	adds	r3, #1
 8013dda:	683a      	ldr	r2, [r7, #0]
 8013ddc:	429a      	cmp	r2, r3
 8013dde:	d202      	bcs.n	8013de6 <GetASN_Sequence+0x28>
        ret = BUFFER_E;
 8013de0:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013de4:	617b      	str	r3, [r7, #20]
    }
    /* Check it is a constructed SEQUENCE. */
    if ((ret == 0) && (input[idx++] != (ASN_SEQUENCE | ASN_CONSTRUCTED))) {
 8013de6:	697b      	ldr	r3, [r7, #20]
 8013de8:	2b00      	cmp	r3, #0
 8013dea:	d10a      	bne.n	8013e02 <GetASN_Sequence+0x44>
 8013dec:	693b      	ldr	r3, [r7, #16]
 8013dee:	1c5a      	adds	r2, r3, #1
 8013df0:	613a      	str	r2, [r7, #16]
 8013df2:	68fa      	ldr	r2, [r7, #12]
 8013df4:	4413      	add	r3, r2
 8013df6:	781b      	ldrb	r3, [r3, #0]
 8013df8:	2b30      	cmp	r3, #48	@ 0x30
 8013dfa:	d002      	beq.n	8013e02 <GetASN_Sequence+0x44>
        ret = ASN_PARSE_E;
 8013dfc:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013e00:	617b      	str	r3, [r7, #20]
    }
    /* Get the length. */
    if ((ret == 0) && (GetASN_Length(input, &idx, len, maxIdx, 1) < 0)) {
 8013e02:	697b      	ldr	r3, [r7, #20]
 8013e04:	2b00      	cmp	r3, #0
 8013e06:	d10e      	bne.n	8013e26 <GetASN_Sequence+0x68>
 8013e08:	f107 0110 	add.w	r1, r7, #16
 8013e0c:	2301      	movs	r3, #1
 8013e0e:	9300      	str	r3, [sp, #0]
 8013e10:	683b      	ldr	r3, [r7, #0]
 8013e12:	687a      	ldr	r2, [r7, #4]
 8013e14:	68f8      	ldr	r0, [r7, #12]
 8013e16:	f000 f836 	bl	8013e86 <GetLength_ex>
 8013e1a:	4603      	mov	r3, r0
 8013e1c:	2b00      	cmp	r3, #0
 8013e1e:	da02      	bge.n	8013e26 <GetASN_Sequence+0x68>
        ret = ASN_PARSE_E;
 8013e20:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013e24:	617b      	str	r3, [r7, #20]
    }
    /* Check all data used if complete set. */
    if ((ret == 0) && complete && (idx + (word32)*len != maxIdx)) {
 8013e26:	697b      	ldr	r3, [r7, #20]
 8013e28:	2b00      	cmp	r3, #0
 8013e2a:	d10d      	bne.n	8013e48 <GetASN_Sequence+0x8a>
 8013e2c:	6a3b      	ldr	r3, [r7, #32]
 8013e2e:	2b00      	cmp	r3, #0
 8013e30:	d00a      	beq.n	8013e48 <GetASN_Sequence+0x8a>
 8013e32:	687b      	ldr	r3, [r7, #4]
 8013e34:	681b      	ldr	r3, [r3, #0]
 8013e36:	461a      	mov	r2, r3
 8013e38:	693b      	ldr	r3, [r7, #16]
 8013e3a:	4413      	add	r3, r2
 8013e3c:	683a      	ldr	r2, [r7, #0]
 8013e3e:	429a      	cmp	r2, r3
 8013e40:	d002      	beq.n	8013e48 <GetASN_Sequence+0x8a>
        ret = ASN_PARSE_E;
 8013e42:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013e46:	617b      	str	r3, [r7, #20]
    }
    if (ret == 0) {
 8013e48:	697b      	ldr	r3, [r7, #20]
 8013e4a:	2b00      	cmp	r3, #0
 8013e4c:	d102      	bne.n	8013e54 <GetASN_Sequence+0x96>
        /* Return index of next byte of encoded data. */
        *inOutIdx = idx;
 8013e4e:	693a      	ldr	r2, [r7, #16]
 8013e50:	68bb      	ldr	r3, [r7, #8]
 8013e52:	601a      	str	r2, [r3, #0]
    }

    return ret;
 8013e54:	697b      	ldr	r3, [r7, #20]
}
 8013e56:	4618      	mov	r0, r3
 8013e58:	3718      	adds	r7, #24
 8013e5a:	46bd      	mov	sp, r7
 8013e5c:	bd80      	pop	{r7, pc}

08013e5e <GetLength>:
 * @return  Length on success.
 * @return  ASN_PARSE_E if the encoding is invalid.
 * @return  BUFFER_E when not enough data to complete decode.
 */
int GetLength(const byte* input, word32* inOutIdx, int* len, word32 maxIdx)
{
 8013e5e:	b580      	push	{r7, lr}
 8013e60:	b086      	sub	sp, #24
 8013e62:	af02      	add	r7, sp, #8
 8013e64:	60f8      	str	r0, [r7, #12]
 8013e66:	60b9      	str	r1, [r7, #8]
 8013e68:	607a      	str	r2, [r7, #4]
 8013e6a:	603b      	str	r3, [r7, #0]
    return GetLength_ex(input, inOutIdx, len, maxIdx, 1);
 8013e6c:	2301      	movs	r3, #1
 8013e6e:	9300      	str	r3, [sp, #0]
 8013e70:	683b      	ldr	r3, [r7, #0]
 8013e72:	687a      	ldr	r2, [r7, #4]
 8013e74:	68b9      	ldr	r1, [r7, #8]
 8013e76:	68f8      	ldr	r0, [r7, #12]
 8013e78:	f000 f805 	bl	8013e86 <GetLength_ex>
 8013e7c:	4603      	mov	r3, r0
}
 8013e7e:	4618      	mov	r0, r3
 8013e80:	3710      	adds	r7, #16
 8013e82:	46bd      	mov	sp, r7
 8013e84:	bd80      	pop	{r7, pc}

08013e86 <GetLength_ex>:
 * @return  ASN_PARSE_E if the encoding is invalid.
 * @return  BUFFER_E when not enough data to complete decode.
 */
int GetLength_ex(const byte* input, word32* inOutIdx, int* len, word32 maxIdx,
                 int check)
{
 8013e86:	b480      	push	{r7}
 8013e88:	b08b      	sub	sp, #44	@ 0x2c
 8013e8a:	af00      	add	r7, sp, #0
 8013e8c:	60f8      	str	r0, [r7, #12]
 8013e8e:	60b9      	str	r1, [r7, #8]
 8013e90:	607a      	str	r2, [r7, #4]
 8013e92:	603b      	str	r3, [r7, #0]
    int     length = 0;
 8013e94:	2300      	movs	r3, #0
 8013e96:	627b      	str	r3, [r7, #36]	@ 0x24
    word32  idx = (word32)*inOutIdx;
 8013e98:	68bb      	ldr	r3, [r7, #8]
 8013e9a:	681b      	ldr	r3, [r3, #0]
 8013e9c:	623b      	str	r3, [r7, #32]
    byte    b;

    /* Ensure zero return length on error. */
    *len = 0;
 8013e9e:	687b      	ldr	r3, [r7, #4]
 8013ea0:	2200      	movs	r2, #0
 8013ea2:	601a      	str	r2, [r3, #0]

    /* Check there is at least one byte available containing length information.
     */
    if ((idx + 1) > maxIdx) {
 8013ea4:	6a3b      	ldr	r3, [r7, #32]
 8013ea6:	3301      	adds	r3, #1
 8013ea8:	683a      	ldr	r2, [r7, #0]
 8013eaa:	429a      	cmp	r2, r3
 8013eac:	d202      	bcs.n	8013eb4 <GetLength_ex+0x2e>
        WOLFSSL_MSG("GetLength - bad index on input");
        return BUFFER_E;
 8013eae:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013eb2:	e066      	b.n	8013f82 <GetLength_ex+0xfc>
    }

    /* Get the first length byte. */
    b = input[idx++];
 8013eb4:	6a3b      	ldr	r3, [r7, #32]
 8013eb6:	1c5a      	adds	r2, r3, #1
 8013eb8:	623a      	str	r2, [r7, #32]
 8013eba:	68fa      	ldr	r2, [r7, #12]
 8013ebc:	4413      	add	r3, r2
 8013ebe:	781b      	ldrb	r3, [r3, #0]
 8013ec0:	75fb      	strb	r3, [r7, #23]
    /* Check if the first byte indicates the count of bytes. */
    if (b >= ASN_LONG_LENGTH) {
 8013ec2:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8013ec6:	2b00      	cmp	r3, #0
 8013ec8:	da43      	bge.n	8013f52 <GetLength_ex+0xcc>
        /* Bottom 7 bits are the number of bytes to calculate length with.
         * Note: 0 indicates indefinite length encoding *not* 0 bytes of length.
         */
        int bytes = (int)(b & 0x7F);
 8013eca:	7dfb      	ldrb	r3, [r7, #23]
 8013ecc:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8013ed0:	61fb      	str	r3, [r7, #28]
        int minLen;

        /* Calculate minimum length to be encoded with bytes. */
        if (b == ASN_INDEF_LENGTH) {
 8013ed2:	7dfb      	ldrb	r3, [r7, #23]
 8013ed4:	2b80      	cmp	r3, #128	@ 0x80
 8013ed6:	d102      	bne.n	8013ede <GetLength_ex+0x58>
            /* Indefinite length encoding - no length bytes. */
            minLen = 0;
 8013ed8:	2300      	movs	r3, #0
 8013eda:	61bb      	str	r3, [r7, #24]
 8013edc:	e012      	b.n	8013f04 <GetLength_ex+0x7e>
        }
        else if (bytes == 1) {
 8013ede:	69fb      	ldr	r3, [r7, #28]
 8013ee0:	2b01      	cmp	r3, #1
 8013ee2:	d102      	bne.n	8013eea <GetLength_ex+0x64>
            minLen = 0x80;
 8013ee4:	2380      	movs	r3, #128	@ 0x80
 8013ee6:	61bb      	str	r3, [r7, #24]
 8013ee8:	e00c      	b.n	8013f04 <GetLength_ex+0x7e>
        }
        /* Only support up to the number of bytes that fit into return var. */
        else if (bytes > (int)sizeof(length)) {
 8013eea:	69fb      	ldr	r3, [r7, #28]
 8013eec:	2b04      	cmp	r3, #4
 8013eee:	dd02      	ble.n	8013ef6 <GetLength_ex+0x70>
            WOLFSSL_MSG("GetLength - overlong data length spec");
            return ASN_PARSE_E;
 8013ef0:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013ef4:	e045      	b.n	8013f82 <GetLength_ex+0xfc>
        }
        else {
            minLen = 1 << ((bytes - 1) * 8);
 8013ef6:	69fb      	ldr	r3, [r7, #28]
 8013ef8:	3b01      	subs	r3, #1
 8013efa:	00db      	lsls	r3, r3, #3
 8013efc:	2201      	movs	r2, #1
 8013efe:	fa02 f303 	lsl.w	r3, r2, r3
 8013f02:	61bb      	str	r3, [r7, #24]
        }

        /* Check the number of bytes required are available. */
        if ((idx + (word32)bytes) > maxIdx) {
 8013f04:	69fa      	ldr	r2, [r7, #28]
 8013f06:	6a3b      	ldr	r3, [r7, #32]
 8013f08:	4413      	add	r3, r2
 8013f0a:	683a      	ldr	r2, [r7, #0]
 8013f0c:	429a      	cmp	r2, r3
 8013f0e:	d20e      	bcs.n	8013f2e <GetLength_ex+0xa8>
            WOLFSSL_MSG("GetLength - bad long length");
            return BUFFER_E;
 8013f10:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013f14:	e035      	b.n	8013f82 <GetLength_ex+0xfc>
        }

        /* Big-endian encoding of number. */
        while (bytes--) {
            b = input[idx++];
 8013f16:	6a3b      	ldr	r3, [r7, #32]
 8013f18:	1c5a      	adds	r2, r3, #1
 8013f1a:	623a      	str	r2, [r7, #32]
 8013f1c:	68fa      	ldr	r2, [r7, #12]
 8013f1e:	4413      	add	r3, r2
 8013f20:	781b      	ldrb	r3, [r3, #0]
 8013f22:	75fb      	strb	r3, [r7, #23]
            length = (length << 8) | b;
 8013f24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013f26:	021a      	lsls	r2, r3, #8
 8013f28:	7dfb      	ldrb	r3, [r7, #23]
 8013f2a:	4313      	orrs	r3, r2
 8013f2c:	627b      	str	r3, [r7, #36]	@ 0x24
        while (bytes--) {
 8013f2e:	69fb      	ldr	r3, [r7, #28]
 8013f30:	1e5a      	subs	r2, r3, #1
 8013f32:	61fa      	str	r2, [r7, #28]
 8013f34:	2b00      	cmp	r3, #0
 8013f36:	d1ee      	bne.n	8013f16 <GetLength_ex+0x90>
        }
        /* Negative value indicates we overflowed the signed int. */
        if (length < 0) {
 8013f38:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013f3a:	2b00      	cmp	r3, #0
 8013f3c:	da02      	bge.n	8013f44 <GetLength_ex+0xbe>
            return ASN_PARSE_E;
 8013f3e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013f42:	e01e      	b.n	8013f82 <GetLength_ex+0xfc>
        }
        /* Don't allow lengths that are longer than strictly required. */
        if (length < minLen) {
 8013f44:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013f46:	69bb      	ldr	r3, [r7, #24]
 8013f48:	429a      	cmp	r2, r3
 8013f4a:	da04      	bge.n	8013f56 <GetLength_ex+0xd0>
            return ASN_PARSE_E;
 8013f4c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013f50:	e017      	b.n	8013f82 <GetLength_ex+0xfc>
        }
    }
    else {
        /* Length in first byte. */
        length = b;
 8013f52:	7dfb      	ldrb	r3, [r7, #23]
 8013f54:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    /* When requested, check the buffer has at least length bytes left. */
    if (check && ((idx + (word32)length) > maxIdx)) {
 8013f56:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013f58:	2b00      	cmp	r3, #0
 8013f5a:	d008      	beq.n	8013f6e <GetLength_ex+0xe8>
 8013f5c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013f5e:	6a3b      	ldr	r3, [r7, #32]
 8013f60:	4413      	add	r3, r2
 8013f62:	683a      	ldr	r2, [r7, #0]
 8013f64:	429a      	cmp	r2, r3
 8013f66:	d202      	bcs.n	8013f6e <GetLength_ex+0xe8>
        WOLFSSL_MSG("GetLength - value exceeds buffer length");
        return BUFFER_E;
 8013f68:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013f6c:	e009      	b.n	8013f82 <GetLength_ex+0xfc>
    }

    /* Return index after length encoding. */
    *inOutIdx = idx;
 8013f6e:	68bb      	ldr	r3, [r7, #8]
 8013f70:	6a3a      	ldr	r2, [r7, #32]
 8013f72:	601a      	str	r2, [r3, #0]
    /* Return length if valid. */
    if (length > 0) {
 8013f74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013f76:	2b00      	cmp	r3, #0
 8013f78:	dd02      	ble.n	8013f80 <GetLength_ex+0xfa>
        *len = length;
 8013f7a:	687b      	ldr	r3, [r7, #4]
 8013f7c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013f7e:	601a      	str	r2, [r3, #0]
    }

    /* Return length calculated or error code. */
    return length;
 8013f80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8013f82:	4618      	mov	r0, r3
 8013f84:	372c      	adds	r7, #44	@ 0x2c
 8013f86:	46bd      	mov	sp, r7
 8013f88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f8c:	4770      	bx	lr

08013f8e <GetASNTag>:
 * return  0 on success
 * return  BAD_FUNC_ARG when tag, inOutIdx or input is NULL.
 * return  BUFFER_E when not enough space in buffer for tag.
 */
int GetASNTag(const byte* input, word32* inOutIdx, byte* tag, word32 maxIdx)
{
 8013f8e:	b480      	push	{r7}
 8013f90:	b087      	sub	sp, #28
 8013f92:	af00      	add	r7, sp, #0
 8013f94:	60f8      	str	r0, [r7, #12]
 8013f96:	60b9      	str	r1, [r7, #8]
 8013f98:	607a      	str	r2, [r7, #4]
 8013f9a:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8013f9c:	2300      	movs	r3, #0
 8013f9e:	617b      	str	r3, [r7, #20]
    word32 idx = 0;
 8013fa0:	2300      	movs	r3, #0
 8013fa2:	613b      	str	r3, [r7, #16]

    /* Check validity of parameters. */
    if ((tag == NULL) || (inOutIdx == NULL) || (input == NULL)) {
 8013fa4:	687b      	ldr	r3, [r7, #4]
 8013fa6:	2b00      	cmp	r3, #0
 8013fa8:	d005      	beq.n	8013fb6 <GetASNTag+0x28>
 8013faa:	68bb      	ldr	r3, [r7, #8]
 8013fac:	2b00      	cmp	r3, #0
 8013fae:	d002      	beq.n	8013fb6 <GetASNTag+0x28>
 8013fb0:	68fb      	ldr	r3, [r7, #12]
 8013fb2:	2b00      	cmp	r3, #0
 8013fb4:	d102      	bne.n	8013fbc <GetASNTag+0x2e>
        ret = BAD_FUNC_ARG;
 8013fb6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8013fba:	617b      	str	r3, [r7, #20]
    }
    if (ret == 0) {
 8013fbc:	697b      	ldr	r3, [r7, #20]
 8013fbe:	2b00      	cmp	r3, #0
 8013fc0:	d10a      	bne.n	8013fd8 <GetASNTag+0x4a>
        /* Get index and ensure space for tag. */
        idx = *inOutIdx;
 8013fc2:	68bb      	ldr	r3, [r7, #8]
 8013fc4:	681b      	ldr	r3, [r3, #0]
 8013fc6:	613b      	str	r3, [r7, #16]
        if (idx + ASN_TAG_SZ > maxIdx) {
 8013fc8:	693b      	ldr	r3, [r7, #16]
 8013fca:	3301      	adds	r3, #1
 8013fcc:	683a      	ldr	r2, [r7, #0]
 8013fce:	429a      	cmp	r2, r3
 8013fd0:	d202      	bcs.n	8013fd8 <GetASNTag+0x4a>
            WOLFSSL_MSG("Buffer too small for ASN tag");
            ret = BUFFER_E;
 8013fd2:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013fd6:	617b      	str	r3, [r7, #20]
        }
    }
    if (ret == 0) {
 8013fd8:	697b      	ldr	r3, [r7, #20]
 8013fda:	2b00      	cmp	r3, #0
 8013fdc:	d109      	bne.n	8013ff2 <GetASNTag+0x64>
        /* Return the tag and the index after tag. */
        *tag = input[idx];
 8013fde:	68fa      	ldr	r2, [r7, #12]
 8013fe0:	693b      	ldr	r3, [r7, #16]
 8013fe2:	4413      	add	r3, r2
 8013fe4:	781a      	ldrb	r2, [r3, #0]
 8013fe6:	687b      	ldr	r3, [r7, #4]
 8013fe8:	701a      	strb	r2, [r3, #0]
        *inOutIdx = idx + ASN_TAG_SZ;
 8013fea:	693b      	ldr	r3, [r7, #16]
 8013fec:	1c5a      	adds	r2, r3, #1
 8013fee:	68bb      	ldr	r3, [r7, #8]
 8013ff0:	601a      	str	r2, [r3, #0]
    }
    /* Return error code. */
    return ret;
 8013ff2:	697b      	ldr	r3, [r7, #20]
}
 8013ff4:	4618      	mov	r0, r3
 8013ff6:	371c      	adds	r7, #28
 8013ff8:	46bd      	mov	sp, r7
 8013ffa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013ffe:	4770      	bx	lr

08014000 <GetASNHeader_ex>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the expected tag is not found or length is invalid.
 */
static int GetASNHeader_ex(const byte* input, byte tag, word32* inOutIdx,
                           int* len, word32 maxIdx, int check)
{
 8014000:	b580      	push	{r7, lr}
 8014002:	b08a      	sub	sp, #40	@ 0x28
 8014004:	af02      	add	r7, sp, #8
 8014006:	60f8      	str	r0, [r7, #12]
 8014008:	607a      	str	r2, [r7, #4]
 801400a:	603b      	str	r3, [r7, #0]
 801400c:	460b      	mov	r3, r1
 801400e:	72fb      	strb	r3, [r7, #11]
    int    ret = 0;
 8014010:	2300      	movs	r3, #0
 8014012:	61fb      	str	r3, [r7, #28]
    word32 idx = *inOutIdx;
 8014014:	687b      	ldr	r3, [r7, #4]
 8014016:	681b      	ldr	r3, [r3, #0]
 8014018:	61bb      	str	r3, [r7, #24]
    byte   tagFound;
    int    length = 0;
 801401a:	2300      	movs	r3, #0
 801401c:	613b      	str	r3, [r7, #16]

    /* Get tag/type. */
    if (GetASNTag(input, &idx, &tagFound, maxIdx) != 0) {
 801401e:	f107 0217 	add.w	r2, r7, #23
 8014022:	f107 0118 	add.w	r1, r7, #24
 8014026:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014028:	68f8      	ldr	r0, [r7, #12]
 801402a:	f7ff ffb0 	bl	8013f8e <GetASNTag>
 801402e:	4603      	mov	r3, r0
 8014030:	2b00      	cmp	r3, #0
 8014032:	d002      	beq.n	801403a <GetASNHeader_ex+0x3a>
        ret = ASN_PARSE_E;
 8014034:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014038:	61fb      	str	r3, [r7, #28]
    }
    /* Ensure tag is the expected value. */
    if ((ret == 0) && (tagFound != tag)) {
 801403a:	69fb      	ldr	r3, [r7, #28]
 801403c:	2b00      	cmp	r3, #0
 801403e:	d106      	bne.n	801404e <GetASNHeader_ex+0x4e>
 8014040:	7dfb      	ldrb	r3, [r7, #23]
 8014042:	7afa      	ldrb	r2, [r7, #11]
 8014044:	429a      	cmp	r2, r3
 8014046:	d002      	beq.n	801404e <GetASNHeader_ex+0x4e>
        ret = ASN_PARSE_E;
 8014048:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801404c:	61fb      	str	r3, [r7, #28]
    }
    /* Get the encoded length. */
    if ((ret == 0) && (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)) {
 801404e:	69fb      	ldr	r3, [r7, #28]
 8014050:	2b00      	cmp	r3, #0
 8014052:	d10f      	bne.n	8014074 <GetASNHeader_ex+0x74>
 8014054:	f107 0210 	add.w	r2, r7, #16
 8014058:	f107 0118 	add.w	r1, r7, #24
 801405c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801405e:	9300      	str	r3, [sp, #0]
 8014060:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014062:	68f8      	ldr	r0, [r7, #12]
 8014064:	f7ff ff0f 	bl	8013e86 <GetLength_ex>
 8014068:	4603      	mov	r3, r0
 801406a:	2b00      	cmp	r3, #0
 801406c:	da02      	bge.n	8014074 <GetASNHeader_ex+0x74>
        ret = ASN_PARSE_E;
 801406e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014072:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0 && tag == ASN_OBJECT_ID) {
 8014074:	69fb      	ldr	r3, [r7, #28]
 8014076:	2b00      	cmp	r3, #0
 8014078:	d117      	bne.n	80140aa <GetASNHeader_ex+0xaa>
 801407a:	7afb      	ldrb	r3, [r7, #11]
 801407c:	2b06      	cmp	r3, #6
 801407e:	d114      	bne.n	80140aa <GetASNHeader_ex+0xaa>
        if (length < 3) {
 8014080:	693b      	ldr	r3, [r7, #16]
 8014082:	2b02      	cmp	r3, #2
 8014084:	dc03      	bgt.n	801408e <GetASNHeader_ex+0x8e>
            /* OID data must be at least 3 bytes. */
            WOLFSSL_MSG("OID length less than 3");
            ret = ASN_PARSE_E;
 8014086:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801408a:	61fb      	str	r3, [r7, #28]
 801408c:	e00d      	b.n	80140aa <GetASNHeader_ex+0xaa>
        }
        else if ((input[(int)idx + length - 1] & 0x80) == 0x80) {
 801408e:	69bb      	ldr	r3, [r7, #24]
 8014090:	461a      	mov	r2, r3
 8014092:	693b      	ldr	r3, [r7, #16]
 8014094:	4413      	add	r3, r2
 8014096:	3b01      	subs	r3, #1
 8014098:	68fa      	ldr	r2, [r7, #12]
 801409a:	4413      	add	r3, r2
 801409c:	781b      	ldrb	r3, [r3, #0]
 801409e:	b25b      	sxtb	r3, r3
 80140a0:	2b00      	cmp	r3, #0
 80140a2:	da02      	bge.n	80140aa <GetASNHeader_ex+0xaa>
            /* Last octet of a sub-identifier has bit 8 clear. Last octet must be
            * last of a subidentifier. Ensure last octet hasn't got top bit set. */
            WOLFSSL_MSG("OID last octet has top bit set");
            ret = ASN_PARSE_E;
 80140a4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80140a8:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 80140aa:	69fb      	ldr	r3, [r7, #28]
 80140ac:	2b00      	cmp	r3, #0
 80140ae:	d107      	bne.n	80140c0 <GetASNHeader_ex+0xc0>
        /* Return the length of data and index after header. */
        *len      = length;
 80140b0:	693a      	ldr	r2, [r7, #16]
 80140b2:	683b      	ldr	r3, [r7, #0]
 80140b4:	601a      	str	r2, [r3, #0]
        *inOutIdx = idx;
 80140b6:	69ba      	ldr	r2, [r7, #24]
 80140b8:	687b      	ldr	r3, [r7, #4]
 80140ba:	601a      	str	r2, [r3, #0]
        ret = length;
 80140bc:	693b      	ldr	r3, [r7, #16]
 80140be:	61fb      	str	r3, [r7, #28]
    }
    /* Return number of data bytes or error code. */
    return ret;
 80140c0:	69fb      	ldr	r3, [r7, #28]
}
 80140c2:	4618      	mov	r0, r3
 80140c4:	3720      	adds	r7, #32
 80140c6:	46bd      	mov	sp, r7
 80140c8:	bd80      	pop	{r7, pc}

080140ca <GetASNHeader>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the expected tag is not found or length is invalid.
 */
int GetASNHeader(const byte* input, byte tag, word32* inOutIdx, int* len,
                        word32 maxIdx)
{
 80140ca:	b580      	push	{r7, lr}
 80140cc:	b086      	sub	sp, #24
 80140ce:	af02      	add	r7, sp, #8
 80140d0:	60f8      	str	r0, [r7, #12]
 80140d2:	607a      	str	r2, [r7, #4]
 80140d4:	603b      	str	r3, [r7, #0]
 80140d6:	460b      	mov	r3, r1
 80140d8:	72fb      	strb	r3, [r7, #11]
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
 80140da:	7af9      	ldrb	r1, [r7, #11]
 80140dc:	2301      	movs	r3, #1
 80140de:	9301      	str	r3, [sp, #4]
 80140e0:	69bb      	ldr	r3, [r7, #24]
 80140e2:	9300      	str	r3, [sp, #0]
 80140e4:	683b      	ldr	r3, [r7, #0]
 80140e6:	687a      	ldr	r2, [r7, #4]
 80140e8:	68f8      	ldr	r0, [r7, #12]
 80140ea:	f7ff ff89 	bl	8014000 <GetASNHeader_ex>
 80140ee:	4603      	mov	r3, r0
}
 80140f0:	4618      	mov	r0, r3
 80140f2:	3710      	adds	r7, #16
 80140f4:	46bd      	mov	sp, r7
 80140f6:	bd80      	pop	{r7, pc}

080140f8 <GetSequence>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the tag is not a SEQUENCE or length is invalid.
 */
int GetSequence(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx)
{
 80140f8:	b580      	push	{r7, lr}
 80140fa:	b086      	sub	sp, #24
 80140fc:	af02      	add	r7, sp, #8
 80140fe:	60f8      	str	r0, [r7, #12]
 8014100:	60b9      	str	r1, [r7, #8]
 8014102:	607a      	str	r2, [r7, #4]
 8014104:	603b      	str	r3, [r7, #0]
    return GetASNHeader(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,
 8014106:	683b      	ldr	r3, [r7, #0]
 8014108:	9300      	str	r3, [sp, #0]
 801410a:	687b      	ldr	r3, [r7, #4]
 801410c:	68ba      	ldr	r2, [r7, #8]
 801410e:	2130      	movs	r1, #48	@ 0x30
 8014110:	68f8      	ldr	r0, [r7, #12]
 8014112:	f7ff ffda 	bl	80140ca <GetASNHeader>
 8014116:	4603      	mov	r3, r0
                        maxIdx);
}
 8014118:	4618      	mov	r0, r3
 801411a:	3710      	adds	r7, #16
 801411c:	46bd      	mov	sp, r7
 801411e:	bd80      	pop	{r7, pc}

08014120 <GetSequence_ex>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the tag is not a SEQUENCE or length is invalid.
 */
int GetSequence_ex(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx, int check)
{
 8014120:	b580      	push	{r7, lr}
 8014122:	b086      	sub	sp, #24
 8014124:	af02      	add	r7, sp, #8
 8014126:	60f8      	str	r0, [r7, #12]
 8014128:	60b9      	str	r1, [r7, #8]
 801412a:	607a      	str	r2, [r7, #4]
 801412c:	603b      	str	r3, [r7, #0]
    return GetASNHeader_ex(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,
 801412e:	69bb      	ldr	r3, [r7, #24]
 8014130:	9301      	str	r3, [sp, #4]
 8014132:	683b      	ldr	r3, [r7, #0]
 8014134:	9300      	str	r3, [sp, #0]
 8014136:	687b      	ldr	r3, [r7, #4]
 8014138:	68ba      	ldr	r2, [r7, #8]
 801413a:	2130      	movs	r1, #48	@ 0x30
 801413c:	68f8      	ldr	r0, [r7, #12]
 801413e:	f7ff ff5f 	bl	8014000 <GetASNHeader_ex>
 8014142:	4603      	mov	r3, r0
                        maxIdx, check);
}
 8014144:	4618      	mov	r0, r3
 8014146:	3710      	adds	r7, #16
 8014148:	46bd      	mov	sp, r7
 801414a:	bd80      	pop	{r7, pc}

0801414c <GetOctetString>:
 * @return  Number of bytes in the ASN.1 data on success.
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the tag is not a OCTET STRING or length is invalid.
 */
int GetOctetString(const byte* input, word32* inOutIdx, int* len, word32 maxIdx)
{
 801414c:	b580      	push	{r7, lr}
 801414e:	b086      	sub	sp, #24
 8014150:	af02      	add	r7, sp, #8
 8014152:	60f8      	str	r0, [r7, #12]
 8014154:	60b9      	str	r1, [r7, #8]
 8014156:	607a      	str	r2, [r7, #4]
 8014158:	603b      	str	r3, [r7, #0]
    return GetASNHeader(input, ASN_OCTET_STRING, inOutIdx, len, maxIdx);
 801415a:	683b      	ldr	r3, [r7, #0]
 801415c:	9300      	str	r3, [sp, #0]
 801415e:	687b      	ldr	r3, [r7, #4]
 8014160:	68ba      	ldr	r2, [r7, #8]
 8014162:	2104      	movs	r1, #4
 8014164:	68f8      	ldr	r0, [r7, #12]
 8014166:	f7ff ffb0 	bl	80140ca <GetASNHeader>
 801416a:	4603      	mov	r3, r0
}
 801416c:	4618      	mov	r0, r3
 801416e:	3710      	adds	r7, #16
 8014170:	46bd      	mov	sp, r7
 8014172:	bd80      	pop	{r7, pc}

08014174 <CheckBitString>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_EXPECT_0_E when unused bits is not zero when expected.
 */
int CheckBitString(const byte* input, word32* inOutIdx, int* len,
                          word32 maxIdx, int zeroBits, byte* unusedBits)
{
 8014174:	b580      	push	{r7, lr}
 8014176:	b092      	sub	sp, #72	@ 0x48
 8014178:	af04      	add	r7, sp, #16
 801417a:	60f8      	str	r0, [r7, #12]
 801417c:	60b9      	str	r1, [r7, #8]
 801417e:	607a      	str	r2, [r7, #4]
 8014180:	603b      	str	r3, [r7, #0]

    return 0;
#else
    ASNGetData dataASN[bitStringASN_Length];
    int ret;
    int bits = 0;
 8014182:	2300      	movs	r3, #0
 8014184:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Parse BIT_STRING and check validity of unused bits. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 8014186:	f107 0314 	add.w	r3, r7, #20
 801418a:	221c      	movs	r2, #28
 801418c:	2100      	movs	r1, #0
 801418e:	4618      	mov	r0, r3
 8014190:	f014 fd48 	bl	8028c24 <memset>
    /* Decode BIT_STRING. */
    ret = GetASN_Items(bitStringASN, dataASN, bitStringASN_Length, 0, input,
 8014194:	f107 0114 	add.w	r1, r7, #20
 8014198:	683b      	ldr	r3, [r7, #0]
 801419a:	9302      	str	r3, [sp, #8]
 801419c:	68bb      	ldr	r3, [r7, #8]
 801419e:	9301      	str	r3, [sp, #4]
 80141a0:	68fb      	ldr	r3, [r7, #12]
 80141a2:	9300      	str	r3, [sp, #0]
 80141a4:	2300      	movs	r3, #0
 80141a6:	2201      	movs	r2, #1
 80141a8:	4814      	ldr	r0, [pc, #80]	@ (80141fc <CheckBitString+0x88>)
 80141aa:	f7ff fb61 	bl	8013870 <GetASN_Items>
 80141ae:	6378      	str	r0, [r7, #52]	@ 0x34
            inOutIdx, maxIdx);
    if (ret == 0) {
 80141b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80141b2:	2b00      	cmp	r3, #0
 80141b4:	d10c      	bne.n	80141d0 <CheckBitString+0x5c>
        /* Get unused bits from dynamic ASN.1 data. */
        bits = GetASNItem_UnusedBits(dataASN[BITSTRINGASN_IDX_BIT_STR]);
 80141b6:	69fb      	ldr	r3, [r7, #28]
 80141b8:	3b01      	subs	r3, #1
 80141ba:	781b      	ldrb	r3, [r3, #0]
 80141bc:	633b      	str	r3, [r7, #48]	@ 0x30
        /* Check unused bits is 0 when expected. */
        if (zeroBits && (bits != 0)) {
 80141be:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80141c0:	2b00      	cmp	r3, #0
 80141c2:	d005      	beq.n	80141d0 <CheckBitString+0x5c>
 80141c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80141c6:	2b00      	cmp	r3, #0
 80141c8:	d002      	beq.n	80141d0 <CheckBitString+0x5c>
            ret = ASN_EXPECT_0_E;
 80141ca:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 80141ce:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }
    if (ret == 0) {
 80141d0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80141d2:	2b00      	cmp	r3, #0
 80141d4:	d10d      	bne.n	80141f2 <CheckBitString+0x7e>
        /* Return length of data and unused bits if required. */
        if (len != NULL) {
 80141d6:	687b      	ldr	r3, [r7, #4]
 80141d8:	2b00      	cmp	r3, #0
 80141da:	d003      	beq.n	80141e4 <CheckBitString+0x70>
            *len = (int)dataASN[BITSTRINGASN_IDX_BIT_STR].data.ref.length;
 80141dc:	6a3b      	ldr	r3, [r7, #32]
 80141de:	461a      	mov	r2, r3
 80141e0:	687b      	ldr	r3, [r7, #4]
 80141e2:	601a      	str	r2, [r3, #0]
        }
        if (unusedBits != NULL) {
 80141e4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80141e6:	2b00      	cmp	r3, #0
 80141e8:	d003      	beq.n	80141f2 <CheckBitString+0x7e>
            *unusedBits = (byte)bits;
 80141ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80141ec:	b2da      	uxtb	r2, r3
 80141ee:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80141f0:	701a      	strb	r2, [r3, #0]
        }
    }

    return ret;
 80141f2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
#endif
}
 80141f4:	4618      	mov	r0, r3
 80141f6:	3738      	adds	r7, #56	@ 0x38
 80141f8:	46bd      	mov	sp, r7
 80141fa:	bd80      	pop	{r7, pc}
 80141fc:	08034384 	.word	0x08034384

08014200 <OidFromId>:
 * @param [out] oidSz  Length of OID byte array returned.
 * @return  Array of bytes for the OID.
 * @return  NULL when ID/type not recognized.
 */
const byte* OidFromId(word32 id, word32 type, word32* oidSz)
{
 8014200:	b580      	push	{r7, lr}
 8014202:	b086      	sub	sp, #24
 8014204:	af00      	add	r7, sp, #0
 8014206:	60f8      	str	r0, [r7, #12]
 8014208:	60b9      	str	r1, [r7, #8]
 801420a:	607a      	str	r2, [r7, #4]
    const byte* oid = NULL;
 801420c:	2300      	movs	r3, #0
 801420e:	617b      	str	r3, [r7, #20]

    *oidSz = 0;
 8014210:	687b      	ldr	r3, [r7, #4]
 8014212:	2200      	movs	r2, #0
 8014214:	601a      	str	r2, [r3, #0]

    switch (type) {
 8014216:	68bb      	ldr	r3, [r7, #8]
 8014218:	2b13      	cmp	r3, #19
 801421a:	f200 82ca 	bhi.w	80147b2 <OidFromId+0x5b2>
 801421e:	a201      	add	r2, pc, #4	@ (adr r2, 8014224 <OidFromId+0x24>)
 8014220:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014224:	08014275 	.word	0x08014275
 8014228:	0801428d 	.word	0x0801428d
 801422c:	080142db 	.word	0x080142db
 8014230:	08014349 	.word	0x08014349
 8014234:	08014359 	.word	0x08014359
 8014238:	080147b3 	.word	0x080147b3
 801423c:	0801446d 	.word	0x0801446d
 8014240:	08014609 	.word	0x08014609
 8014244:	08014631 	.word	0x08014631
 8014248:	08014647 	.word	0x08014647
 801424c:	0801465d 	.word	0x0801465d
 8014250:	080146fb 	.word	0x080146fb
 8014254:	08014733 	.word	0x08014733
 8014258:	08014783 	.word	0x08014783
 801425c:	08014713 	.word	0x08014713
 8014260:	08014799 	.word	0x08014799
 8014264:	080147b3 	.word	0x080147b3
 8014268:	080147b3 	.word	0x080147b3
 801426c:	080147b3 	.word	0x080147b3
 8014270:	080147b3 	.word	0x080147b3

        case oidHashType:
            switch (id) {
 8014274:	68fb      	ldr	r3, [r7, #12]
 8014276:	f5b3 7fcf 	cmp.w	r3, #414	@ 0x19e
 801427a:	d105      	bne.n	8014288 <OidFromId+0x88>
                    *oidSz = sizeof(hashSha224hOid);
                    break;
            #endif
            #ifndef NO_SHA256
                case SHA256h:
                    oid = hashSha256hOid;
 801427c:	4bb6      	ldr	r3, [pc, #728]	@ (8014558 <OidFromId+0x358>)
 801427e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(hashSha256hOid);
 8014280:	687b      	ldr	r3, [r7, #4]
 8014282:	2209      	movs	r2, #9
 8014284:	601a      	str	r2, [r3, #0]
                    break;
 8014286:	e000      	b.n	801428a <OidFromId+0x8a>
                    *oidSz = sizeof(hashSha3_512hOid);
                    break;
            #endif /* WOLFSSL_NOSHA3_512 */
            #endif /* WOLFSSL_SHA3 */
                default:
                    break;
 8014288:	bf00      	nop
            }
            break;
 801428a:	e293      	b.n	80147b4 <OidFromId+0x5b4>

        case oidSigType:
            switch (id) {
 801428c:	68fb      	ldr	r3, [r7, #12]
 801428e:	f240 228f 	movw	r2, #655	@ 0x28f
 8014292:	4293      	cmp	r3, r2
 8014294:	d00d      	beq.n	80142b2 <OidFromId+0xb2>
 8014296:	68fb      	ldr	r3, [r7, #12]
 8014298:	f5b3 7f24 	cmp.w	r3, #656	@ 0x290
 801429c:	d21b      	bcs.n	80142d6 <OidFromId+0xd6>
 801429e:	68fb      	ldr	r3, [r7, #12]
 80142a0:	f5b3 7f03 	cmp.w	r3, #524	@ 0x20c
 80142a4:	d011      	beq.n	80142ca <OidFromId+0xca>
 80142a6:	68fb      	ldr	r3, [r7, #12]
 80142a8:	f240 228e 	movw	r2, #654	@ 0x28e
 80142ac:	4293      	cmp	r3, r2
 80142ae:	d006      	beq.n	80142be <OidFromId+0xbe>
                    oid = sigSphincsSmall_Level5Oid;
                    *oidSz = sizeof(sigSphincsSmall_Level5Oid);
                    break;
                #endif /* HAVE_SPHINCS */
                default:
                    break;
 80142b0:	e011      	b.n	80142d6 <OidFromId+0xd6>
                    oid = sigSha256wRsaOid;
 80142b2:	4baa      	ldr	r3, [pc, #680]	@ (801455c <OidFromId+0x35c>)
 80142b4:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigSha256wRsaOid);
 80142b6:	687b      	ldr	r3, [r7, #4]
 80142b8:	2209      	movs	r2, #9
 80142ba:	601a      	str	r2, [r3, #0]
                    break;
 80142bc:	e00c      	b.n	80142d8 <OidFromId+0xd8>
                    oid = sigRsaSsaPssOid;
 80142be:	4ba8      	ldr	r3, [pc, #672]	@ (8014560 <OidFromId+0x360>)
 80142c0:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigRsaSsaPssOid);
 80142c2:	687b      	ldr	r3, [r7, #4]
 80142c4:	2209      	movs	r2, #9
 80142c6:	601a      	str	r2, [r3, #0]
                    break;
 80142c8:	e006      	b.n	80142d8 <OidFromId+0xd8>
                    oid = sigSha256wEcdsaOid;
 80142ca:	4ba6      	ldr	r3, [pc, #664]	@ (8014564 <OidFromId+0x364>)
 80142cc:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigSha256wEcdsaOid);
 80142ce:	687b      	ldr	r3, [r7, #4]
 80142d0:	2208      	movs	r2, #8
 80142d2:	601a      	str	r2, [r3, #0]
                    break;
 80142d4:	e000      	b.n	80142d8 <OidFromId+0xd8>
                    break;
 80142d6:	bf00      	nop
            }
            break;
 80142d8:	e26c      	b.n	80147b4 <OidFromId+0x5b4>

        case oidKeyType:
            switch (id) {
 80142da:	68fb      	ldr	r3, [r7, #12]
 80142dc:	f240 228e 	movw	r2, #654	@ 0x28e
 80142e0:	4293      	cmp	r3, r2
 80142e2:	d01d      	beq.n	8014320 <OidFromId+0x120>
 80142e4:	68fb      	ldr	r3, [r7, #12]
 80142e6:	f240 228e 	movw	r2, #654	@ 0x28e
 80142ea:	4293      	cmp	r3, r2
 80142ec:	d82a      	bhi.n	8014344 <OidFromId+0x144>
 80142ee:	68fb      	ldr	r3, [r7, #12]
 80142f0:	f240 2287 	movw	r2, #647	@ 0x287
 80142f4:	4293      	cmp	r3, r2
 80142f6:	d01f      	beq.n	8014338 <OidFromId+0x138>
 80142f8:	68fb      	ldr	r3, [r7, #12]
 80142fa:	f5b3 7f22 	cmp.w	r3, #648	@ 0x288
 80142fe:	d221      	bcs.n	8014344 <OidFromId+0x144>
 8014300:	68fb      	ldr	r3, [r7, #12]
 8014302:	f240 2206 	movw	r2, #518	@ 0x206
 8014306:	4293      	cmp	r3, r2
 8014308:	d010      	beq.n	801432c <OidFromId+0x12c>
 801430a:	68fb      	ldr	r3, [r7, #12]
 801430c:	f240 2285 	movw	r2, #645	@ 0x285
 8014310:	4293      	cmp	r3, r2
 8014312:	d117      	bne.n	8014344 <OidFromId+0x144>
                    *oidSz = sizeof(keyDsaOid);
                    break;
                #endif /* NO_DSA */
            #ifndef NO_RSA
                case RSAk:
                    oid = keyRsaOid;
 8014314:	4b94      	ldr	r3, [pc, #592]	@ (8014568 <OidFromId+0x368>)
 8014316:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyRsaOid);
 8014318:	687b      	ldr	r3, [r7, #4]
 801431a:	2209      	movs	r2, #9
 801431c:	601a      	str	r2, [r3, #0]
                    break;
 801431e:	e012      	b.n	8014346 <OidFromId+0x146>
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                    oid = keyRsaPssOid;
 8014320:	4b92      	ldr	r3, [pc, #584]	@ (801456c <OidFromId+0x36c>)
 8014322:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyRsaPssOid);
 8014324:	687b      	ldr	r3, [r7, #4]
 8014326:	2209      	movs	r2, #9
 8014328:	601a      	str	r2, [r3, #0]
                    break;
 801432a:	e00c      	b.n	8014346 <OidFromId+0x146>
                #endif
            #endif /* NO_RSA */
                #ifdef HAVE_ECC
                case ECDSAk:
                    oid = keyEcdsaOid;
 801432c:	4b90      	ldr	r3, [pc, #576]	@ (8014570 <OidFromId+0x370>)
 801432e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyEcdsaOid);
 8014330:	687b      	ldr	r3, [r7, #4]
 8014332:	2207      	movs	r2, #7
 8014334:	601a      	str	r2, [r3, #0]
                    break;
 8014336:	e006      	b.n	8014346 <OidFromId+0x146>
                    *oidSz = sizeof(keyCurve448Oid);
                    break;
                #endif /* HAVE_CURVE448 */
                #ifndef NO_DH
                case DHk:
                    oid = keyDhOid;
 8014338:	4b8e      	ldr	r3, [pc, #568]	@ (8014574 <OidFromId+0x374>)
 801433a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyDhOid);
 801433c:	687b      	ldr	r3, [r7, #4]
 801433e:	2209      	movs	r2, #9
 8014340:	601a      	str	r2, [r3, #0]
                    break;
 8014342:	e000      	b.n	8014346 <OidFromId+0x146>
                    oid = keySphincsSmall_Level5Oid;
                    *oidSz = sizeof(keySphincsSmall_Level5Oid);
                    break;
                #endif /* HAVE_SPHINCS */
                default:
                    break;
 8014344:	bf00      	nop
            }
            break;
 8014346:	e235      	b.n	80147b4 <OidFromId+0x5b4>

        #ifdef HAVE_ECC
        case oidCurveType:
            if (wc_ecc_get_oid(id, &oid, oidSz) < 0) {
 8014348:	f107 0314 	add.w	r3, r7, #20
 801434c:	687a      	ldr	r2, [r7, #4]
 801434e:	4619      	mov	r1, r3
 8014350:	68f8      	ldr	r0, [r7, #12]
 8014352:	f00a f869 	bl	801e428 <wc_ecc_get_oid>
                WOLFSSL_MSG("ECC OID not found");
            }
            break;
 8014356:	e22d      	b.n	80147b4 <OidFromId+0x5b4>
        #endif /* HAVE_ECC */

        case oidBlkType:
            switch (id) {
 8014358:	68fb      	ldr	r3, [r7, #12]
 801435a:	f5a3 73cf 	sub.w	r3, r3, #414	@ 0x19e
 801435e:	2b2c      	cmp	r3, #44	@ 0x2c
 8014360:	f200 8082 	bhi.w	8014468 <OidFromId+0x268>
 8014364:	a201      	add	r2, pc, #4	@ (adr r2, 801436c <OidFromId+0x16c>)
 8014366:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801436a:	bf00      	nop
 801436c:	08014421 	.word	0x08014421
 8014370:	08014469 	.word	0x08014469
 8014374:	08014469 	.word	0x08014469
 8014378:	08014469 	.word	0x08014469
 801437c:	08014445 	.word	0x08014445
 8014380:	08014469 	.word	0x08014469
 8014384:	08014469 	.word	0x08014469
 8014388:	08014469 	.word	0x08014469
 801438c:	08014469 	.word	0x08014469
 8014390:	08014469 	.word	0x08014469
 8014394:	08014469 	.word	0x08014469
 8014398:	08014469 	.word	0x08014469
 801439c:	08014469 	.word	0x08014469
 80143a0:	08014469 	.word	0x08014469
 80143a4:	08014469 	.word	0x08014469
 80143a8:	08014469 	.word	0x08014469
 80143ac:	08014469 	.word	0x08014469
 80143b0:	08014469 	.word	0x08014469
 80143b4:	08014469 	.word	0x08014469
 80143b8:	08014469 	.word	0x08014469
 80143bc:	0801442d 	.word	0x0801442d
 80143c0:	08014469 	.word	0x08014469
 80143c4:	08014469 	.word	0x08014469
 80143c8:	08014469 	.word	0x08014469
 80143cc:	08014451 	.word	0x08014451
 80143d0:	08014469 	.word	0x08014469
 80143d4:	08014469 	.word	0x08014469
 80143d8:	08014469 	.word	0x08014469
 80143dc:	08014469 	.word	0x08014469
 80143e0:	08014469 	.word	0x08014469
 80143e4:	08014469 	.word	0x08014469
 80143e8:	08014469 	.word	0x08014469
 80143ec:	08014469 	.word	0x08014469
 80143f0:	08014469 	.word	0x08014469
 80143f4:	08014469 	.word	0x08014469
 80143f8:	08014469 	.word	0x08014469
 80143fc:	08014469 	.word	0x08014469
 8014400:	08014469 	.word	0x08014469
 8014404:	08014469 	.word	0x08014469
 8014408:	08014469 	.word	0x08014469
 801440c:	08014439 	.word	0x08014439
 8014410:	08014469 	.word	0x08014469
 8014414:	08014469 	.word	0x08014469
 8014418:	08014469 	.word	0x08014469
 801441c:	0801445d 	.word	0x0801445d
    #ifdef HAVE_AES_CBC
        #ifdef WOLFSSL_AES_128
                case AES128CBCb:
                    oid = blkAes128CbcOid;
 8014420:	4b55      	ldr	r3, [pc, #340]	@ (8014578 <OidFromId+0x378>)
 8014422:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes128CbcOid);
 8014424:	687b      	ldr	r3, [r7, #4]
 8014426:	2209      	movs	r2, #9
 8014428:	601a      	str	r2, [r3, #0]
                    break;
 801442a:	e01e      	b.n	801446a <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_192
                case AES192CBCb:
                    oid = blkAes192CbcOid;
 801442c:	4b53      	ldr	r3, [pc, #332]	@ (801457c <OidFromId+0x37c>)
 801442e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes192CbcOid);
 8014430:	687b      	ldr	r3, [r7, #4]
 8014432:	2209      	movs	r2, #9
 8014434:	601a      	str	r2, [r3, #0]
                    break;
 8014436:	e018      	b.n	801446a <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_256
                case AES256CBCb:
                    oid = blkAes256CbcOid;
 8014438:	4b51      	ldr	r3, [pc, #324]	@ (8014580 <OidFromId+0x380>)
 801443a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes256CbcOid);
 801443c:	687b      	ldr	r3, [r7, #4]
 801443e:	2209      	movs	r2, #9
 8014440:	601a      	str	r2, [r3, #0]
                    break;
 8014442:	e012      	b.n	801446a <OidFromId+0x26a>
        #endif
    #endif /* HAVE_AES_CBC */
    #ifdef HAVE_AESGCM
        #ifdef WOLFSSL_AES_128
                case AES128GCMb:
                    oid = blkAes128GcmOid;
 8014444:	4b4f      	ldr	r3, [pc, #316]	@ (8014584 <OidFromId+0x384>)
 8014446:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes128GcmOid);
 8014448:	687b      	ldr	r3, [r7, #4]
 801444a:	2209      	movs	r2, #9
 801444c:	601a      	str	r2, [r3, #0]
                    break;
 801444e:	e00c      	b.n	801446a <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_192
                case AES192GCMb:
                    oid = blkAes192GcmOid;
 8014450:	4b4d      	ldr	r3, [pc, #308]	@ (8014588 <OidFromId+0x388>)
 8014452:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes192GcmOid);
 8014454:	687b      	ldr	r3, [r7, #4]
 8014456:	2209      	movs	r2, #9
 8014458:	601a      	str	r2, [r3, #0]
                    break;
 801445a:	e006      	b.n	801446a <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_256
                case AES256GCMb:
                    oid = blkAes256GcmOid;
 801445c:	4b4b      	ldr	r3, [pc, #300]	@ (801458c <OidFromId+0x38c>)
 801445e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes256GcmOid);
 8014460:	687b      	ldr	r3, [r7, #4]
 8014462:	2209      	movs	r2, #9
 8014464:	601a      	str	r2, [r3, #0]
                    break;
 8014466:	e000      	b.n	801446a <OidFromId+0x26a>
                    oid = blkDes3CbcOid;
                    *oidSz = sizeof(blkDes3CbcOid);
                    break;
    #endif /* !NO_DES3 */
                default:
                    break;
 8014468:	bf00      	nop
            }
            break;
 801446a:	e1a3      	b.n	80147b4 <OidFromId+0x5b4>
            }
            break;
        #endif /* HAVE_OCSP */

        case oidCertExtType:
            switch (id) {
 801446c:	68fb      	ldr	r3, [r7, #12]
 801446e:	2b45      	cmp	r3, #69	@ 0x45
 8014470:	f000 8098 	beq.w	80145a4 <OidFromId+0x3a4>
 8014474:	68fb      	ldr	r3, [r7, #12]
 8014476:	2b45      	cmp	r3, #69	@ 0x45
 8014478:	f0c0 80c4 	bcc.w	8014604 <OidFromId+0x404>
 801447c:	68fb      	ldr	r3, [r7, #12]
 801447e:	2ba8      	cmp	r3, #168	@ 0xa8
 8014480:	f200 80c0 	bhi.w	8014604 <OidFromId+0x404>
 8014484:	68fb      	ldr	r3, [r7, #12]
 8014486:	2b80      	cmp	r3, #128	@ 0x80
 8014488:	f0c0 80bc 	bcc.w	8014604 <OidFromId+0x404>
 801448c:	68fb      	ldr	r3, [r7, #12]
 801448e:	3b80      	subs	r3, #128	@ 0x80
 8014490:	2b28      	cmp	r3, #40	@ 0x28
 8014492:	f200 80b7 	bhi.w	8014604 <OidFromId+0x404>
 8014496:	a201      	add	r2, pc, #4	@ (adr r2, 801449c <OidFromId+0x29c>)
 8014498:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801449c:	080145bd 	.word	0x080145bd
 80144a0:	080145d5 	.word	0x080145d5
 80144a4:	08014605 	.word	0x08014605
 80144a8:	0801454d 	.word	0x0801454d
 80144ac:	08014605 	.word	0x08014605
 80144b0:	08014541 	.word	0x08014541
 80144b4:	08014605 	.word	0x08014605
 80144b8:	08014605 	.word	0x08014605
 80144bc:	08014605 	.word	0x08014605
 80144c0:	08014605 	.word	0x08014605
 80144c4:	08014605 	.word	0x08014605
 80144c8:	08014605 	.word	0x08014605
 80144cc:	08014605 	.word	0x08014605
 80144d0:	08014605 	.word	0x08014605
 80144d4:	08014605 	.word	0x08014605
 80144d8:	08014605 	.word	0x08014605
 80144dc:	080145f9 	.word	0x080145f9
 80144e0:	08014599 	.word	0x08014599
 80144e4:	080145c9 	.word	0x080145c9
 80144e8:	08014605 	.word	0x08014605
 80144ec:	08014605 	.word	0x08014605
 80144f0:	080145b1 	.word	0x080145b1
 80144f4:	08014605 	.word	0x08014605
 80144f8:	080145ed 	.word	0x080145ed
 80144fc:	08014605 	.word	0x08014605
 8014500:	08014605 	.word	0x08014605
 8014504:	08014605 	.word	0x08014605
 8014508:	08014605 	.word	0x08014605
 801450c:	08014605 	.word	0x08014605
 8014510:	08014605 	.word	0x08014605
 8014514:	08014605 	.word	0x08014605
 8014518:	08014605 	.word	0x08014605
 801451c:	08014605 	.word	0x08014605
 8014520:	08014605 	.word	0x08014605
 8014524:	08014605 	.word	0x08014605
 8014528:	08014605 	.word	0x08014605
 801452c:	08014605 	.word	0x08014605
 8014530:	08014605 	.word	0x08014605
 8014534:	08014605 	.word	0x08014605
 8014538:	08014605 	.word	0x08014605
 801453c:	080145e1 	.word	0x080145e1
                case BASIC_CA_OID:
                    oid = extBasicCaOid;
 8014540:	4b13      	ldr	r3, [pc, #76]	@ (8014590 <OidFromId+0x390>)
 8014542:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extBasicCaOid);
 8014544:	687b      	ldr	r3, [r7, #4]
 8014546:	2203      	movs	r2, #3
 8014548:	601a      	str	r2, [r3, #0]
                    break;
 801454a:	e05c      	b.n	8014606 <OidFromId+0x406>
                case ALT_NAMES_OID:
                    oid = extAltNamesOid;
 801454c:	4b11      	ldr	r3, [pc, #68]	@ (8014594 <OidFromId+0x394>)
 801454e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAltNamesOid);
 8014550:	687b      	ldr	r3, [r7, #4]
 8014552:	2203      	movs	r2, #3
 8014554:	601a      	str	r2, [r3, #0]
                    break;
 8014556:	e056      	b.n	8014606 <OidFromId+0x406>
 8014558:	08034388 	.word	0x08034388
 801455c:	0803439c 	.word	0x0803439c
 8014560:	080343a8 	.word	0x080343a8
 8014564:	080343b4 	.word	0x080343b4
 8014568:	080343bc 	.word	0x080343bc
 801456c:	080343c8 	.word	0x080343c8
 8014570:	080343d4 	.word	0x080343d4
 8014574:	080343dc 	.word	0x080343dc
 8014578:	080343e8 	.word	0x080343e8
 801457c:	080343f4 	.word	0x080343f4
 8014580:	08034400 	.word	0x08034400
 8014584:	0803440c 	.word	0x0803440c
 8014588:	08034418 	.word	0x08034418
 801458c:	08034424 	.word	0x08034424
 8014590:	0803445c 	.word	0x0803445c
 8014594:	08034460 	.word	0x08034460
                case CRL_DIST_OID:
                    oid = extCrlDistOid;
 8014598:	4b89      	ldr	r3, [pc, #548]	@ (80147c0 <OidFromId+0x5c0>)
 801459a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCrlDistOid);
 801459c:	687b      	ldr	r3, [r7, #4]
 801459e:	2203      	movs	r2, #3
 80145a0:	601a      	str	r2, [r3, #0]
                    break;
 80145a2:	e030      	b.n	8014606 <OidFromId+0x406>
                case AUTH_INFO_OID:
                    oid = extAuthInfoOid;
 80145a4:	4b87      	ldr	r3, [pc, #540]	@ (80147c4 <OidFromId+0x5c4>)
 80145a6:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoOid);
 80145a8:	687b      	ldr	r3, [r7, #4]
 80145aa:	2208      	movs	r2, #8
 80145ac:	601a      	str	r2, [r3, #0]
                    break;
 80145ae:	e02a      	b.n	8014606 <OidFromId+0x406>
                case AUTH_KEY_OID:
                    oid = extAuthKeyOid;
 80145b0:	4b85      	ldr	r3, [pc, #532]	@ (80147c8 <OidFromId+0x5c8>)
 80145b2:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthKeyOid);
 80145b4:	687b      	ldr	r3, [r7, #4]
 80145b6:	2203      	movs	r2, #3
 80145b8:	601a      	str	r2, [r3, #0]
                    break;
 80145ba:	e024      	b.n	8014606 <OidFromId+0x406>
                case SUBJ_KEY_OID:
                    oid = extSubjKeyOid;
 80145bc:	4b83      	ldr	r3, [pc, #524]	@ (80147cc <OidFromId+0x5cc>)
 80145be:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extSubjKeyOid);
 80145c0:	687b      	ldr	r3, [r7, #4]
 80145c2:	2203      	movs	r2, #3
 80145c4:	601a      	str	r2, [r3, #0]
                    break;
 80145c6:	e01e      	b.n	8014606 <OidFromId+0x406>
                case CERT_POLICY_OID:
                    oid = extCertPolicyOid;
 80145c8:	4b81      	ldr	r3, [pc, #516]	@ (80147d0 <OidFromId+0x5d0>)
 80145ca:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCertPolicyOid);
 80145cc:	687b      	ldr	r3, [r7, #4]
 80145ce:	2203      	movs	r2, #3
 80145d0:	601a      	str	r2, [r3, #0]
                    break;
 80145d2:	e018      	b.n	8014606 <OidFromId+0x406>
                case KEY_USAGE_OID:
                    oid = extKeyUsageOid;
 80145d4:	4b7f      	ldr	r3, [pc, #508]	@ (80147d4 <OidFromId+0x5d4>)
 80145d6:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extKeyUsageOid);
 80145d8:	687b      	ldr	r3, [r7, #4]
 80145da:	2203      	movs	r2, #3
 80145dc:	601a      	str	r2, [r3, #0]
                    break;
 80145de:	e012      	b.n	8014606 <OidFromId+0x406>
                case INHIBIT_ANY_OID:
                    oid = extInhibitAnyOid;
 80145e0:	4b7d      	ldr	r3, [pc, #500]	@ (80147d8 <OidFromId+0x5d8>)
 80145e2:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extInhibitAnyOid);
 80145e4:	687b      	ldr	r3, [r7, #4]
 80145e6:	2203      	movs	r2, #3
 80145e8:	601a      	str	r2, [r3, #0]
                    break;
 80145ea:	e00c      	b.n	8014606 <OidFromId+0x406>
                case EXT_KEY_USAGE_OID:
                    oid = extExtKeyUsageOid;
 80145ec:	4b7b      	ldr	r3, [pc, #492]	@ (80147dc <OidFromId+0x5dc>)
 80145ee:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageOid);
 80145f0:	687b      	ldr	r3, [r7, #4]
 80145f2:	2203      	movs	r2, #3
 80145f4:	601a      	str	r2, [r3, #0]
                    break;
 80145f6:	e006      	b.n	8014606 <OidFromId+0x406>
            #ifndef IGNORE_NAME_CONSTRAINTS
                case NAME_CONS_OID:
                    oid = extNameConsOid;
 80145f8:	4b79      	ldr	r3, [pc, #484]	@ (80147e0 <OidFromId+0x5e0>)
 80145fa:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extNameConsOid);
 80145fc:	687b      	ldr	r3, [r7, #4]
 80145fe:	2203      	movs	r2, #3
 8014600:	601a      	str	r2, [r3, #0]
                    break;
 8014602:	e000      	b.n	8014606 <OidFromId+0x406>
                    oid = extSubjInfoAccessOid;
                    *oidSz = sizeof(extSubjInfoAccessOid);
                    break;
            #endif
                default:
                    break;
 8014604:	bf00      	nop
            }
            break;
 8014606:	e0d5      	b.n	80147b4 <OidFromId+0x5b4>
            }
            #endif
            break;

        case oidCertAuthInfoType:
            switch (id) {
 8014608:	68fb      	ldr	r3, [r7, #12]
 801460a:	2b74      	cmp	r3, #116	@ 0x74
 801460c:	d003      	beq.n	8014616 <OidFromId+0x416>
 801460e:	68fb      	ldr	r3, [r7, #12]
 8014610:	2b75      	cmp	r3, #117	@ 0x75
 8014612:	d006      	beq.n	8014622 <OidFromId+0x422>
                    oid = extAuthInfoCaRespOid;
                    *oidSz = sizeof(extAuthInfoCaRespOid);
                    break;
                #endif /* WOLFSSL_SUBJ_INFO_ACC */
                default:
                    break;
 8014614:	e00b      	b.n	801462e <OidFromId+0x42e>
                    oid = extAuthInfoOcspOid;
 8014616:	4b73      	ldr	r3, [pc, #460]	@ (80147e4 <OidFromId+0x5e4>)
 8014618:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoOcspOid);
 801461a:	687b      	ldr	r3, [r7, #4]
 801461c:	2208      	movs	r2, #8
 801461e:	601a      	str	r2, [r3, #0]
                    break;
 8014620:	e005      	b.n	801462e <OidFromId+0x42e>
                    oid = extAuthInfoCaIssuerOid;
 8014622:	4b71      	ldr	r3, [pc, #452]	@ (80147e8 <OidFromId+0x5e8>)
 8014624:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoCaIssuerOid);
 8014626:	687b      	ldr	r3, [r7, #4]
 8014628:	2208      	movs	r2, #8
 801462a:	601a      	str	r2, [r3, #0]
                    break;
 801462c:	bf00      	nop
            }
            break;
 801462e:	e0c1      	b.n	80147b4 <OidFromId+0x5b4>

        case oidCertPolicyType:
            switch (id) {
 8014630:	68fb      	ldr	r3, [r7, #12]
 8014632:	2b92      	cmp	r3, #146	@ 0x92
 8014634:	d105      	bne.n	8014642 <OidFromId+0x442>
                case CP_ANY_OID:
                    oid = extCertPolicyAnyOid;
 8014636:	4b6d      	ldr	r3, [pc, #436]	@ (80147ec <OidFromId+0x5ec>)
 8014638:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCertPolicyAnyOid);
 801463a:	687b      	ldr	r3, [r7, #4]
 801463c:	2204      	movs	r2, #4
 801463e:	601a      	str	r2, [r3, #0]
                    break;
 8014640:	e000      	b.n	8014644 <OidFromId+0x444>
                    oid = extCertPolicyFpkiPiviAuthOid;
                    *oidSz = sizeof(extCertPolicyFpkiPiviAuthOid);
                    break;
                #endif /* WOLFSSL_FPKI */
                default:
                    break;
 8014642:	bf00      	nop
            }
            break;
 8014644:	e0b6      	b.n	80147b4 <OidFromId+0x5b4>

        case oidCertAltNameType:
            switch (id) {
 8014646:	68fb      	ldr	r3, [r7, #12]
 8014648:	2b4f      	cmp	r3, #79	@ 0x4f
 801464a:	d105      	bne.n	8014658 <OidFromId+0x458>
                case HW_NAME_OID:
                    oid = extAltNamesHwNameOid;
 801464c:	4b68      	ldr	r3, [pc, #416]	@ (80147f0 <OidFromId+0x5f0>)
 801464e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAltNamesHwNameOid);
 8014650:	687b      	ldr	r3, [r7, #4]
 8014652:	2208      	movs	r2, #8
 8014654:	601a      	str	r2, [r3, #0]
                    break;
 8014656:	e000      	b.n	801465a <OidFromId+0x45a>
                default:
                    break;
 8014658:	bf00      	nop
            }
            break;
 801465a:	e0ab      	b.n	80147b4 <OidFromId+0x5b4>

        case oidCertKeyUseType:
            switch (id) {
 801465c:	68fb      	ldr	r3, [r7, #12]
 801465e:	2b4f      	cmp	r3, #79	@ 0x4f
 8014660:	d81c      	bhi.n	801469c <OidFromId+0x49c>
 8014662:	68fb      	ldr	r3, [r7, #12]
 8014664:	2b47      	cmp	r3, #71	@ 0x47
 8014666:	d346      	bcc.n	80146f6 <OidFromId+0x4f6>
 8014668:	68fb      	ldr	r3, [r7, #12]
 801466a:	3b47      	subs	r3, #71	@ 0x47
 801466c:	2b08      	cmp	r3, #8
 801466e:	d842      	bhi.n	80146f6 <OidFromId+0x4f6>
 8014670:	a201      	add	r2, pc, #4	@ (adr r2, 8014678 <OidFromId+0x478>)
 8014672:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014676:	bf00      	nop
 8014678:	080146af 	.word	0x080146af
 801467c:	080146bb 	.word	0x080146bb
 8014680:	080146c7 	.word	0x080146c7
 8014684:	080146d3 	.word	0x080146d3
 8014688:	080146f7 	.word	0x080146f7
 801468c:	080146f7 	.word	0x080146f7
 8014690:	080146f7 	.word	0x080146f7
 8014694:	080146df 	.word	0x080146df
 8014698:	080146eb 	.word	0x080146eb
 801469c:	68fb      	ldr	r3, [r7, #12]
 801469e:	2b97      	cmp	r3, #151	@ 0x97
 80146a0:	d129      	bne.n	80146f6 <OidFromId+0x4f6>
                case EKU_ANY_OID:
                    oid = extExtKeyUsageAnyOid;
 80146a2:	4b54      	ldr	r3, [pc, #336]	@ (80147f4 <OidFromId+0x5f4>)
 80146a4:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageAnyOid);
 80146a6:	687b      	ldr	r3, [r7, #4]
 80146a8:	2204      	movs	r2, #4
 80146aa:	601a      	str	r2, [r3, #0]
                    break;
 80146ac:	e024      	b.n	80146f8 <OidFromId+0x4f8>
                case EKU_SERVER_AUTH_OID:
                    oid = extExtKeyUsageServerAuthOid;
 80146ae:	4b52      	ldr	r3, [pc, #328]	@ (80147f8 <OidFromId+0x5f8>)
 80146b0:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageServerAuthOid);
 80146b2:	687b      	ldr	r3, [r7, #4]
 80146b4:	2208      	movs	r2, #8
 80146b6:	601a      	str	r2, [r3, #0]
                    break;
 80146b8:	e01e      	b.n	80146f8 <OidFromId+0x4f8>
                case EKU_CLIENT_AUTH_OID:
                    oid = extExtKeyUsageClientAuthOid;
 80146ba:	4b50      	ldr	r3, [pc, #320]	@ (80147fc <OidFromId+0x5fc>)
 80146bc:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageClientAuthOid);
 80146be:	687b      	ldr	r3, [r7, #4]
 80146c0:	2208      	movs	r2, #8
 80146c2:	601a      	str	r2, [r3, #0]
                    break;
 80146c4:	e018      	b.n	80146f8 <OidFromId+0x4f8>
                case EKU_CODESIGNING_OID:
                    oid = extExtKeyUsageCodeSigningOid;
 80146c6:	4b4e      	ldr	r3, [pc, #312]	@ (8014800 <OidFromId+0x600>)
 80146c8:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageCodeSigningOid);
 80146ca:	687b      	ldr	r3, [r7, #4]
 80146cc:	2208      	movs	r2, #8
 80146ce:	601a      	str	r2, [r3, #0]
                    break;
 80146d0:	e012      	b.n	80146f8 <OidFromId+0x4f8>
                case EKU_EMAILPROTECT_OID:
                    oid = extExtKeyUsageEmailProtectOid;
 80146d2:	4b4c      	ldr	r3, [pc, #304]	@ (8014804 <OidFromId+0x604>)
 80146d4:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageEmailProtectOid);
 80146d6:	687b      	ldr	r3, [r7, #4]
 80146d8:	2208      	movs	r2, #8
 80146da:	601a      	str	r2, [r3, #0]
                    break;
 80146dc:	e00c      	b.n	80146f8 <OidFromId+0x4f8>
                case EKU_TIMESTAMP_OID:
                    oid = extExtKeyUsageTimestampOid;
 80146de:	4b4a      	ldr	r3, [pc, #296]	@ (8014808 <OidFromId+0x608>)
 80146e0:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageTimestampOid);
 80146e2:	687b      	ldr	r3, [r7, #4]
 80146e4:	2208      	movs	r2, #8
 80146e6:	601a      	str	r2, [r3, #0]
                    break;
 80146e8:	e006      	b.n	80146f8 <OidFromId+0x4f8>
                case EKU_OCSP_SIGN_OID:
                    oid = extExtKeyUsageOcspSignOid;
 80146ea:	4b48      	ldr	r3, [pc, #288]	@ (801480c <OidFromId+0x60c>)
 80146ec:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageOcspSignOid);
 80146ee:	687b      	ldr	r3, [r7, #4]
 80146f0:	2208      	movs	r2, #8
 80146f2:	601a      	str	r2, [r3, #0]
                    break;
 80146f4:	e000      	b.n	80146f8 <OidFromId+0x4f8>
                    oid = extExtKeyUsageSshKpClientAuthOid;
                    *oidSz = sizeof(extExtKeyUsageSshKpClientAuthOid);
                    break;
                #endif /* WOLFSSL_WOLFSSH */
                default:
                    break;
 80146f6:	bf00      	nop
            }
            break;
 80146f8:	e05c      	b.n	80147b4 <OidFromId+0x5b4>

        case oidKdfType:
            switch (id) {
 80146fa:	68fb      	ldr	r3, [r7, #12]
 80146fc:	f5b3 7f25 	cmp.w	r3, #660	@ 0x294
 8014700:	d105      	bne.n	801470e <OidFromId+0x50e>
                case PBKDF2_OID:
                    oid = pbkdf2Oid;
 8014702:	4b43      	ldr	r3, [pc, #268]	@ (8014810 <OidFromId+0x610>)
 8014704:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(pbkdf2Oid);
 8014706:	687b      	ldr	r3, [r7, #4]
 8014708:	2209      	movs	r2, #9
 801470a:	601a      	str	r2, [r3, #0]
                    break;
 801470c:	e000      	b.n	8014710 <OidFromId+0x510>
                default:
                    break;
 801470e:	bf00      	nop
            }
            break;
 8014710:	e050      	b.n	80147b4 <OidFromId+0x5b4>

        case oidPBEType:
            switch (id) {
 8014712:	68fb      	ldr	r3, [r7, #12]
 8014714:	2b0d      	cmp	r3, #13
 8014716:	d004      	beq.n	8014722 <OidFromId+0x522>
 8014718:	68fb      	ldr	r3, [r7, #12]
 801471a:	f240 2295 	movw	r2, #661	@ 0x295
 801471e:	4293      	cmp	r3, r2
 8014720:	d105      	bne.n	801472e <OidFromId+0x52e>
                    *oidSz = sizeof(pbe40Rc2Cbc);
                    break;
        #endif
                case PBES2_SUM:
                case PBES2:
                    oid = pbes2;
 8014722:	4b3c      	ldr	r3, [pc, #240]	@ (8014814 <OidFromId+0x614>)
 8014724:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(pbes2);
 8014726:	687b      	ldr	r3, [r7, #4]
 8014728:	2209      	movs	r2, #9
 801472a:	601a      	str	r2, [r3, #0]
                    break;
 801472c:	e000      	b.n	8014730 <OidFromId+0x530>
                default:
                    break;
 801472e:	bf00      	nop
            }
            break;
 8014730:	e040      	b.n	80147b4 <OidFromId+0x5b4>

        case oidKeyWrapType:
            switch (id) {
 8014732:	68fb      	ldr	r3, [r7, #12]
 8014734:	f240 12c9 	movw	r2, #457	@ 0x1c9
 8014738:	4293      	cmp	r3, r2
 801473a:	d01a      	beq.n	8014772 <OidFromId+0x572>
 801473c:	68fb      	ldr	r3, [r7, #12]
 801473e:	f5b3 7fe5 	cmp.w	r3, #458	@ 0x1ca
 8014742:	d21c      	bcs.n	801477e <OidFromId+0x57e>
 8014744:	68fb      	ldr	r3, [r7, #12]
 8014746:	f240 12a1 	movw	r2, #417	@ 0x1a1
 801474a:	4293      	cmp	r3, r2
 801474c:	d005      	beq.n	801475a <OidFromId+0x55a>
 801474e:	68fb      	ldr	r3, [r7, #12]
 8014750:	f240 12b5 	movw	r2, #437	@ 0x1b5
 8014754:	4293      	cmp	r3, r2
 8014756:	d006      	beq.n	8014766 <OidFromId+0x566>
                    oid = wrapPwriKekOid;
                    *oidSz = sizeof(wrapPwriKekOid);
                    break;
            #endif
                default:
                    break;
 8014758:	e011      	b.n	801477e <OidFromId+0x57e>
                    oid = wrapAes128Oid;
 801475a:	4b2f      	ldr	r3, [pc, #188]	@ (8014818 <OidFromId+0x618>)
 801475c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes128Oid);
 801475e:	687b      	ldr	r3, [r7, #4]
 8014760:	2209      	movs	r2, #9
 8014762:	601a      	str	r2, [r3, #0]
                    break;
 8014764:	e00c      	b.n	8014780 <OidFromId+0x580>
                    oid = wrapAes192Oid;
 8014766:	4b2d      	ldr	r3, [pc, #180]	@ (801481c <OidFromId+0x61c>)
 8014768:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes192Oid);
 801476a:	687b      	ldr	r3, [r7, #4]
 801476c:	2209      	movs	r2, #9
 801476e:	601a      	str	r2, [r3, #0]
                    break;
 8014770:	e006      	b.n	8014780 <OidFromId+0x580>
                    oid = wrapAes256Oid;
 8014772:	4b2b      	ldr	r3, [pc, #172]	@ (8014820 <OidFromId+0x620>)
 8014774:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes256Oid);
 8014776:	687b      	ldr	r3, [r7, #4]
 8014778:	2209      	movs	r2, #9
 801477a:	601a      	str	r2, [r3, #0]
                    break;
 801477c:	e000      	b.n	8014780 <OidFromId+0x580>
                    break;
 801477e:	bf00      	nop
            }
            break;
 8014780:	e018      	b.n	80147b4 <OidFromId+0x5b4>

        case oidCmsKeyAgreeType:
            switch (id) {
 8014782:	68fb      	ldr	r3, [r7, #12]
 8014784:	2bbd      	cmp	r3, #189	@ 0xbd
 8014786:	d105      	bne.n	8014794 <OidFromId+0x594>
                    *oidSz = sizeof(dhSinglePass_stdDH_sha224kdf_Oid);
                    break;
            #endif
            #ifndef NO_SHA256
                case dhSinglePass_stdDH_sha256kdf_scheme:
                    oid = dhSinglePass_stdDH_sha256kdf_Oid;
 8014788:	4b26      	ldr	r3, [pc, #152]	@ (8014824 <OidFromId+0x624>)
 801478a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(dhSinglePass_stdDH_sha256kdf_Oid);
 801478c:	687b      	ldr	r3, [r7, #4]
 801478e:	2206      	movs	r2, #6
 8014790:	601a      	str	r2, [r3, #0]
                    break;
 8014792:	e000      	b.n	8014796 <OidFromId+0x596>
                    oid = dhSinglePass_stdDH_sha512kdf_Oid;
                    *oidSz = sizeof(dhSinglePass_stdDH_sha512kdf_Oid);
                    break;
            #endif
                default:
                    break;
 8014794:	bf00      	nop
            }
            break;
 8014796:	e00d      	b.n	80147b4 <OidFromId+0x5b4>

#ifndef NO_HMAC
        case oidHmacType:
            switch (id) {
 8014798:	68fb      	ldr	r3, [r7, #12]
 801479a:	f240 228d 	movw	r2, #653	@ 0x28d
 801479e:	4293      	cmp	r3, r2
 80147a0:	d105      	bne.n	80147ae <OidFromId+0x5ae>
                    *oidSz = sizeof(hmacSha224Oid);
                    break;
        #endif
        #ifndef NO_SHA256
                case HMAC_SHA256_OID:
                    oid = hmacSha256Oid;
 80147a2:	4b21      	ldr	r3, [pc, #132]	@ (8014828 <OidFromId+0x628>)
 80147a4:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(hmacSha256Oid);
 80147a6:	687b      	ldr	r3, [r7, #4]
 80147a8:	2208      	movs	r2, #8
 80147aa:	601a      	str	r2, [r3, #0]
                    break;
 80147ac:	e000      	b.n	80147b0 <OidFromId+0x5b0>
                    oid = hmacSha512Oid;
                    *oidSz = sizeof(hmacSha512Oid);
                    break;
        #endif
                default:
                    break;
 80147ae:	bf00      	nop
            }
            break;
 80147b0:	e000      	b.n	80147b4 <OidFromId+0x5b4>
            }
            break;
#endif /* WOLFSSL_SUBJ_DIR_ATTR */
        case oidIgnoreType:
        default:
            break;
 80147b2:	bf00      	nop
    }

    return oid;
 80147b4:	697b      	ldr	r3, [r7, #20]
}
 80147b6:	4618      	mov	r0, r3
 80147b8:	3718      	adds	r7, #24
 80147ba:	46bd      	mov	sp, r7
 80147bc:	bd80      	pop	{r7, pc}
 80147be:	bf00      	nop
 80147c0:	08034464 	.word	0x08034464
 80147c4:	08034468 	.word	0x08034468
 80147c8:	08034470 	.word	0x08034470
 80147cc:	08034474 	.word	0x08034474
 80147d0:	08034478 	.word	0x08034478
 80147d4:	0803447c 	.word	0x0803447c
 80147d8:	08034480 	.word	0x08034480
 80147dc:	08034484 	.word	0x08034484
 80147e0:	08034488 	.word	0x08034488
 80147e4:	0803448c 	.word	0x0803448c
 80147e8:	08034494 	.word	0x08034494
 80147ec:	0803449c 	.word	0x0803449c
 80147f0:	080344a0 	.word	0x080344a0
 80147f4:	080344a8 	.word	0x080344a8
 80147f8:	080344ac 	.word	0x080344ac
 80147fc:	080344b4 	.word	0x080344b4
 8014800:	080344bc 	.word	0x080344bc
 8014804:	080344c4 	.word	0x080344c4
 8014808:	080344cc 	.word	0x080344cc
 801480c:	080344d4 	.word	0x080344d4
 8014810:	080344e8 	.word	0x080344e8
 8014814:	080344f4 	.word	0x080344f4
 8014818:	08034430 	.word	0x08034430
 801481c:	0803443c 	.word	0x0803443c
 8014820:	08034448 	.word	0x08034448
 8014824:	08034454 	.word	0x08034454
 8014828:	08034394 	.word	0x08034394

0801482c <CheckCurve>:
 * @param [in]  oid  OID id.
 * @return  ECC set id on success.
 * @return  ECC_CURVE_OID_E when OID id is 0 or not supported.
 */
static int CheckCurve(word32 oid)
{
 801482c:	b580      	push	{r7, lr}
 801482e:	b084      	sub	sp, #16
 8014830:	af00      	add	r7, sp, #0
 8014832:	6078      	str	r0, [r7, #4]
    int ret;
    word32 oidSz;

    /* Lookup OID id. */
    ret = wc_ecc_get_oid(oid, NULL, &oidSz);
 8014834:	f107 0308 	add.w	r3, r7, #8
 8014838:	461a      	mov	r2, r3
 801483a:	2100      	movs	r1, #0
 801483c:	6878      	ldr	r0, [r7, #4]
 801483e:	f009 fdf3 	bl	801e428 <wc_ecc_get_oid>
 8014842:	60f8      	str	r0, [r7, #12]
    /* Check for error or zero length OID size (can't get OID for encoding). */
    if ((ret < 0) || (oidSz == 0)) {
 8014844:	68fb      	ldr	r3, [r7, #12]
 8014846:	2b00      	cmp	r3, #0
 8014848:	db02      	blt.n	8014850 <CheckCurve+0x24>
 801484a:	68bb      	ldr	r3, [r7, #8]
 801484c:	2b00      	cmp	r3, #0
 801484e:	d102      	bne.n	8014856 <CheckCurve+0x2a>
        WOLFSSL_MSG("CheckCurve not found");
        WOLFSSL_ERROR_VERBOSE(ECC_CURVE_OID_E);
        ret = ECC_CURVE_OID_E;
 8014850:	f06f 03ab 	mvn.w	r3, #171	@ 0xab
 8014854:	60fb      	str	r3, [r7, #12]
    }

    /* Return ECC set id or error code. */
    return ret;
 8014856:	68fb      	ldr	r3, [r7, #12]
}
 8014858:	4618      	mov	r0, r3
 801485a:	3710      	adds	r7, #16
 801485c:	46bd      	mov	sp, r7
 801485e:	bd80      	pop	{r7, pc}

08014860 <GetOID>:
 * @return  BUFFER_E when not enough bytes for proper decode. (ASN_DUMP_OID and
 *          HAVE_OID_DECODING)
 */
static int GetOID(const byte* input, word32* inOutIdx, word32* oid,
                  word32 oidType, int length)
{
 8014860:	b580      	push	{r7, lr}
 8014862:	b08a      	sub	sp, #40	@ 0x28
 8014864:	af00      	add	r7, sp, #0
 8014866:	60f8      	str	r0, [r7, #12]
 8014868:	60b9      	str	r1, [r7, #8]
 801486a:	607a      	str	r2, [r7, #4]
 801486c:	603b      	str	r3, [r7, #0]
    int    ret = 0;
 801486e:	2300      	movs	r3, #0
 8014870:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 idx = *inOutIdx;
 8014872:	68bb      	ldr	r3, [r7, #8]
 8014874:	681b      	ldr	r3, [r3, #0]
 8014876:	623b      	str	r3, [r7, #32]
#ifndef NO_VERIFY_OID
    word32 actualOidSz;
    const byte* actualOid;
    const byte* checkOid = NULL;
 8014878:	2300      	movs	r3, #0
 801487a:	61fb      	str	r3, [r7, #28]
#endif /* NO_VERIFY_OID */
#if defined(HAVE_SPHINCS)
    word32 found_collision = 0;
#endif
    (void)oidType;
    *oid = 0;
 801487c:	687b      	ldr	r3, [r7, #4]
 801487e:	2200      	movs	r2, #0
 8014880:	601a      	str	r2, [r3, #0]

#ifndef NO_VERIFY_OID
    /* Keep references to OID data and length for check. */
    actualOid = &input[idx];
 8014882:	68fa      	ldr	r2, [r7, #12]
 8014884:	6a3b      	ldr	r3, [r7, #32]
 8014886:	4413      	add	r3, r2
 8014888:	61bb      	str	r3, [r7, #24]
    actualOidSz = (word32)length;
 801488a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801488c:	617b      	str	r3, [r7, #20]
        found_collision = SPHINCS_FAST_LEVEL3k;
    }
#endif /* HAVE_SPHINCS */

    /* Sum it up for now. */
    while (length--) {
 801488e:	e00b      	b.n	80148a8 <GetOID+0x48>
        /* odd HC08 compiler behavior here when input[idx++] */
        *oid += (word32)input[idx];
 8014890:	687b      	ldr	r3, [r7, #4]
 8014892:	681b      	ldr	r3, [r3, #0]
 8014894:	68f9      	ldr	r1, [r7, #12]
 8014896:	6a3a      	ldr	r2, [r7, #32]
 8014898:	440a      	add	r2, r1
 801489a:	7812      	ldrb	r2, [r2, #0]
 801489c:	441a      	add	r2, r3
 801489e:	687b      	ldr	r3, [r7, #4]
 80148a0:	601a      	str	r2, [r3, #0]
        idx++;
 80148a2:	6a3b      	ldr	r3, [r7, #32]
 80148a4:	3301      	adds	r3, #1
 80148a6:	623b      	str	r3, [r7, #32]
    while (length--) {
 80148a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80148aa:	1e5a      	subs	r2, r3, #1
 80148ac:	633a      	str	r2, [r7, #48]	@ 0x30
 80148ae:	2b00      	cmp	r3, #0
 80148b0:	d1ee      	bne.n	8014890 <GetOID+0x30>
        *oid = found_collision;
    }
#endif /* HAVE_SPHINCS */

    /* Return the index after the OID data. */
    *inOutIdx = idx;
 80148b2:	68bb      	ldr	r3, [r7, #8]
 80148b4:	6a3a      	ldr	r2, [r7, #32]
 80148b6:	601a      	str	r2, [r3, #0]

#ifndef NO_VERIFY_OID
    /* 'Ignore' type means we don't care which OID it is. */
    if (oidType != oidIgnoreType) {
 80148b8:	683b      	ldr	r3, [r7, #0]
 80148ba:	2b15      	cmp	r3, #21
 80148bc:	d01e      	beq.n	80148fc <GetOID+0x9c>
        /* Get the OID data for the id-type. */
        checkOid = OidFromId(*oid, oidType, &checkOidSz);
 80148be:	687b      	ldr	r3, [r7, #4]
 80148c0:	681b      	ldr	r3, [r3, #0]
 80148c2:	f107 0210 	add.w	r2, r7, #16
 80148c6:	6839      	ldr	r1, [r7, #0]
 80148c8:	4618      	mov	r0, r3
 80148ca:	f7ff fc99 	bl	8014200 <OidFromId>
 80148ce:	61f8      	str	r0, [r7, #28]
        /* TODO: Want to fail when checkOid is NULL.
         * Can't as too many situations where unknown OID is to be
         * supported. Extra parameter for must not be NULL?
         */
        /* Check that the OID data matches what we found for the OID id. */
        if ((ret == 0) && (checkOid != NULL) && ((checkOidSz != actualOidSz) ||
 80148d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80148d2:	2b00      	cmp	r3, #0
 80148d4:	d112      	bne.n	80148fc <GetOID+0x9c>
 80148d6:	69fb      	ldr	r3, [r7, #28]
 80148d8:	2b00      	cmp	r3, #0
 80148da:	d00f      	beq.n	80148fc <GetOID+0x9c>
 80148dc:	693b      	ldr	r3, [r7, #16]
 80148de:	697a      	ldr	r2, [r7, #20]
 80148e0:	429a      	cmp	r2, r3
 80148e2:	d108      	bne.n	80148f6 <GetOID+0x96>
                (XMEMCMP(actualOid, checkOid, checkOidSz) != 0))) {
 80148e4:	693b      	ldr	r3, [r7, #16]
 80148e6:	461a      	mov	r2, r3
 80148e8:	69f9      	ldr	r1, [r7, #28]
 80148ea:	69b8      	ldr	r0, [r7, #24]
 80148ec:	f014 f970 	bl	8028bd0 <memcmp>
 80148f0:	4603      	mov	r3, r0
        if ((ret == 0) && (checkOid != NULL) && ((checkOidSz != actualOidSz) ||
 80148f2:	2b00      	cmp	r3, #0
 80148f4:	d002      	beq.n	80148fc <GetOID+0x9c>
            WOLFSSL_MSG("OID Check Failed");
            WOLFSSL_ERROR_VERBOSE(ASN_UNKNOWN_OID_E);
            ret = ASN_UNKNOWN_OID_E;
 80148f6:	f06f 0393 	mvn.w	r3, #147	@ 0x93
 80148fa:	627b      	str	r3, [r7, #36]	@ 0x24
        }
    }
#endif /* NO_VERIFY_OID */

    return ret;
 80148fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 80148fe:	4618      	mov	r0, r3
 8014900:	3728      	adds	r7, #40	@ 0x28
 8014902:	46bd      	mov	sp, r7
 8014904:	bd80      	pop	{r7, pc}
	...

08014908 <GetAlgoIdImpl>:
#define algoIdASN_Length (sizeof(algoIdASN) / sizeof(ASNItem))
#endif

static int GetAlgoIdImpl(const byte* input, word32* inOutIdx, word32* oid,
                     word32 oidType, word32 maxIdx, byte *absentParams)
{
 8014908:	b580      	push	{r7, lr}
 801490a:	b08c      	sub	sp, #48	@ 0x30
 801490c:	af04      	add	r7, sp, #16
 801490e:	60f8      	str	r0, [r7, #12]
 8014910:	60b9      	str	r1, [r7, #8]
 8014912:	607a      	str	r2, [r7, #4]
 8014914:	603b      	str	r3, [r7, #0]

    *inOutIdx = idx;

    return 0;
#else
    DECL_ASNGETDATA(dataASN, algoIdASN_Length);
 8014916:	2300      	movs	r3, #0
 8014918:	61fb      	str	r3, [r7, #28]
    int ret = 0;
 801491a:	2300      	movs	r3, #0
 801491c:	61bb      	str	r3, [r7, #24]

    WOLFSSL_ENTER("GetAlgoId");

    CALLOC_ASNGETDATA(dataASN, algoIdASN_Length, ret, NULL);
 801491e:	69bb      	ldr	r3, [r7, #24]
 8014920:	2b00      	cmp	r3, #0
 8014922:	d109      	bne.n	8014938 <GetAlgoIdImpl+0x30>
 8014924:	2054      	movs	r0, #84	@ 0x54
 8014926:	f00a f9a9 	bl	801ec7c <wolfSSL_Malloc>
 801492a:	61f8      	str	r0, [r7, #28]
 801492c:	69fb      	ldr	r3, [r7, #28]
 801492e:	2b00      	cmp	r3, #0
 8014930:	d102      	bne.n	8014938 <GetAlgoIdImpl+0x30>
 8014932:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014936:	61bb      	str	r3, [r7, #24]
 8014938:	69bb      	ldr	r3, [r7, #24]
 801493a:	2b00      	cmp	r3, #0
 801493c:	d104      	bne.n	8014948 <GetAlgoIdImpl+0x40>
 801493e:	2254      	movs	r2, #84	@ 0x54
 8014940:	2100      	movs	r1, #0
 8014942:	69f8      	ldr	r0, [r7, #28]
 8014944:	f014 f96e 	bl	8028c24 <memset>
    if (ret == 0) {
 8014948:	69bb      	ldr	r3, [r7, #24]
 801494a:	2b00      	cmp	r3, #0
 801494c:	d110      	bne.n	8014970 <GetAlgoIdImpl+0x68>
        /* Set OID type expected. */
        GetASN_OID(&dataASN[ALGOIDASN_IDX_OID], oidType);
 801494e:	69fb      	ldr	r3, [r7, #28]
 8014950:	331c      	adds	r3, #28
 8014952:	683a      	ldr	r2, [r7, #0]
 8014954:	611a      	str	r2, [r3, #16]
        /* Decode the algorithm identifier. */
        ret = GetASN_Items(algoIdASN, dataASN, algoIdASN_Length, 0, input,
 8014956:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014958:	9302      	str	r3, [sp, #8]
 801495a:	68bb      	ldr	r3, [r7, #8]
 801495c:	9301      	str	r3, [sp, #4]
 801495e:	68fb      	ldr	r3, [r7, #12]
 8014960:	9300      	str	r3, [sp, #0]
 8014962:	2300      	movs	r3, #0
 8014964:	2203      	movs	r2, #3
 8014966:	69f9      	ldr	r1, [r7, #28]
 8014968:	4813      	ldr	r0, [pc, #76]	@ (80149b8 <GetAlgoIdImpl+0xb0>)
 801496a:	f7fe ff81 	bl	8013870 <GetASN_Items>
 801496e:	61b8      	str	r0, [r7, #24]
            inOutIdx, maxIdx);
    }
    if (ret == 0) {
 8014970:	69bb      	ldr	r3, [r7, #24]
 8014972:	2b00      	cmp	r3, #0
 8014974:	d10f      	bne.n	8014996 <GetAlgoIdImpl+0x8e>
        /* Return the OID id/sum. */
        *oid = dataASN[ALGOIDASN_IDX_OID].data.oid.sum;
 8014976:	69fb      	ldr	r3, [r7, #28]
 8014978:	331c      	adds	r3, #28
 801497a:	695a      	ldr	r2, [r3, #20]
 801497c:	687b      	ldr	r3, [r7, #4]
 801497e:	601a      	str	r2, [r3, #0]

        if ((absentParams != NULL) &&
 8014980:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014982:	2b00      	cmp	r3, #0
 8014984:	d007      	beq.n	8014996 <GetAlgoIdImpl+0x8e>
            (dataASN[ALGOIDASN_IDX_NULL].tag == ASN_TAG_NULL)) {
 8014986:	69fb      	ldr	r3, [r7, #28]
 8014988:	3338      	adds	r3, #56	@ 0x38
 801498a:	7e5b      	ldrb	r3, [r3, #25]
        if ((absentParams != NULL) &&
 801498c:	2b05      	cmp	r3, #5
 801498e:	d102      	bne.n	8014996 <GetAlgoIdImpl+0x8e>
            *absentParams = FALSE;
 8014990:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014992:	2200      	movs	r2, #0
 8014994:	701a      	strb	r2, [r3, #0]
        }
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8014996:	69fb      	ldr	r3, [r7, #28]
 8014998:	2b00      	cmp	r3, #0
 801499a:	d007      	beq.n	80149ac <GetAlgoIdImpl+0xa4>
 801499c:	69fb      	ldr	r3, [r7, #28]
 801499e:	617b      	str	r3, [r7, #20]
 80149a0:	697b      	ldr	r3, [r7, #20]
 80149a2:	2b00      	cmp	r3, #0
 80149a4:	d002      	beq.n	80149ac <GetAlgoIdImpl+0xa4>
 80149a6:	6978      	ldr	r0, [r7, #20]
 80149a8:	f00a f984 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 80149ac:	69bb      	ldr	r3, [r7, #24]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 80149ae:	4618      	mov	r0, r3
 80149b0:	3720      	adds	r7, #32
 80149b2:	46bd      	mov	sp, r7
 80149b4:	bd80      	pop	{r7, pc}
 80149b6:	bf00      	nop
 80149b8:	08034530 	.word	0x08034530

080149bc <GetAlgoId>:
 * @return  ASN_PARSE_E when encoding is invalid.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int GetAlgoId(const byte* input, word32* inOutIdx, word32* oid,
                     word32 oidType, word32 maxIdx)
{
 80149bc:	b580      	push	{r7, lr}
 80149be:	b086      	sub	sp, #24
 80149c0:	af02      	add	r7, sp, #8
 80149c2:	60f8      	str	r0, [r7, #12]
 80149c4:	60b9      	str	r1, [r7, #8]
 80149c6:	607a      	str	r2, [r7, #4]
 80149c8:	603b      	str	r3, [r7, #0]
    return GetAlgoIdImpl(input, inOutIdx, oid, oidType, maxIdx, NULL);
 80149ca:	2300      	movs	r3, #0
 80149cc:	9301      	str	r3, [sp, #4]
 80149ce:	69bb      	ldr	r3, [r7, #24]
 80149d0:	9300      	str	r3, [sp, #0]
 80149d2:	683b      	ldr	r3, [r7, #0]
 80149d4:	687a      	ldr	r2, [r7, #4]
 80149d6:	68b9      	ldr	r1, [r7, #8]
 80149d8:	68f8      	ldr	r0, [r7, #12]
 80149da:	f7ff ff95 	bl	8014908 <GetAlgoIdImpl>
 80149de:	4603      	mov	r3, r0
}
 80149e0:	4618      	mov	r0, r3
 80149e2:	3710      	adds	r7, #16
 80149e4:	46bd      	mov	sp, r7
 80149e6:	bd80      	pop	{r7, pc}

080149e8 <RsaPssHashOidToType>:
 * @param  [out]  type  Hash type.
 * @return  0 on success.
 * @return  ASN_PARSE_E when hash OID not supported for RSA PSS.
 */
static int RsaPssHashOidToType(word32 oid, enum wc_HashType* type)
{
 80149e8:	b480      	push	{r7}
 80149ea:	b085      	sub	sp, #20
 80149ec:	af00      	add	r7, sp, #0
 80149ee:	6078      	str	r0, [r7, #4]
 80149f0:	6039      	str	r1, [r7, #0]
    int ret = 0;
 80149f2:	2300      	movs	r3, #0
 80149f4:	60fb      	str	r3, [r7, #12]

    switch (oid) {
 80149f6:	687b      	ldr	r3, [r7, #4]
 80149f8:	f5b3 7fcf 	cmp.w	r3, #414	@ 0x19e
 80149fc:	d103      	bne.n	8014a06 <RsaPssHashOidToType+0x1e>
        *type = WC_HASH_TYPE_SHA224;
        break;
#endif
#ifndef NO_SHA256
    case SHA256h:
        *type = WC_HASH_TYPE_SHA256;
 80149fe:	683b      	ldr	r3, [r7, #0]
 8014a00:	2206      	movs	r2, #6
 8014a02:	701a      	strb	r2, [r3, #0]
        break;
 8014a04:	e003      	b.n	8014a0e <RsaPssHashOidToType+0x26>
        break;
    /* TODO: SHA512_224h */
    /* TODO: SHA512_256h */
#endif
    default:
        ret = ASN_PARSE_E;
 8014a06:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014a0a:	60fb      	str	r3, [r7, #12]
        break;
 8014a0c:	bf00      	nop
    }

    return ret;
 8014a0e:	68fb      	ldr	r3, [r7, #12]
}
 8014a10:	4618      	mov	r0, r3
 8014a12:	3714      	adds	r7, #20
 8014a14:	46bd      	mov	sp, r7
 8014a16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a1a:	4770      	bx	lr

08014a1c <RsaPssHashOidToMgf1>:
 * @param  [out]  mgf   MGF type.
 * @return  0 on success.
 * @return  ASN_PARSE_E when hash OID not supported for RSA PSS.
 */
static int RsaPssHashOidToMgf1(word32 oid, int* mgf)
{
 8014a1c:	b480      	push	{r7}
 8014a1e:	b085      	sub	sp, #20
 8014a20:	af00      	add	r7, sp, #0
 8014a22:	6078      	str	r0, [r7, #4]
 8014a24:	6039      	str	r1, [r7, #0]
    int ret = 0;
 8014a26:	2300      	movs	r3, #0
 8014a28:	60fb      	str	r3, [r7, #12]

    switch (oid) {
 8014a2a:	687b      	ldr	r3, [r7, #4]
 8014a2c:	f5b3 7fcf 	cmp.w	r3, #414	@ 0x19e
 8014a30:	d103      	bne.n	8014a3a <RsaPssHashOidToMgf1+0x1e>
        *mgf = WC_MGF1SHA224;
        break;
#endif
#ifndef NO_SHA256
    case SHA256h:
        *mgf = WC_MGF1SHA256;
 8014a32:	683b      	ldr	r3, [r7, #0]
 8014a34:	2201      	movs	r2, #1
 8014a36:	601a      	str	r2, [r3, #0]
        break;
 8014a38:	e003      	b.n	8014a42 <RsaPssHashOidToMgf1+0x26>
        break;
    /* TODO: SHA512_224h */
    /* TODO: SHA512_256h */
#endif
    default:
        ret = ASN_PARSE_E;
 8014a3a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014a3e:	60fb      	str	r3, [r7, #12]
        break;
 8014a40:	bf00      	nop
    }

    return ret;
 8014a42:	68fb      	ldr	r3, [r7, #12]
}
 8014a44:	4618      	mov	r0, r3
 8014a46:	3714      	adds	r7, #20
 8014a48:	46bd      	mov	sp, r7
 8014a4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a4e:	4770      	bx	lr

08014a50 <RsaPssHashOidToSigOid>:
 * @param  [out]  sigOid  Signature OID to pass wto HashForSignature().
 * @return  0 on success.
 * @return  ASN_PARSE_E when hash OID not supported for RSA PSS.
 */
static int RsaPssHashOidToSigOid(word32 oid, word32* sigOid)
{
 8014a50:	b480      	push	{r7}
 8014a52:	b085      	sub	sp, #20
 8014a54:	af00      	add	r7, sp, #0
 8014a56:	6078      	str	r0, [r7, #4]
 8014a58:	6039      	str	r1, [r7, #0]
    int ret = 0;
 8014a5a:	2300      	movs	r3, #0
 8014a5c:	60fb      	str	r3, [r7, #12]

    switch (oid) {
 8014a5e:	687b      	ldr	r3, [r7, #4]
 8014a60:	2b06      	cmp	r3, #6
 8014a62:	d104      	bne.n	8014a6e <RsaPssHashOidToSigOid+0x1e>
        *sigOid = CTC_SHA224wRSA;
        break;
#endif
#ifndef NO_SHA256
    case WC_HASH_TYPE_SHA256:
        *sigOid = CTC_SHA256wRSA;
 8014a64:	683b      	ldr	r3, [r7, #0]
 8014a66:	f240 228f 	movw	r2, #655	@ 0x28f
 8014a6a:	601a      	str	r2, [r3, #0]
        break;
 8014a6c:	e003      	b.n	8014a76 <RsaPssHashOidToSigOid+0x26>
#endif
    /* TODO: SHA512_224h */
    /* TODO: SHA512_256h */
    /* Not supported by HashForSignature() */
    default:
        ret = ASN_PARSE_E;
 8014a6e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014a72:	60fb      	str	r3, [r7, #12]
        break;
 8014a74:	bf00      	nop
    }

    return ret;
 8014a76:	68fb      	ldr	r3, [r7, #12]
}
 8014a78:	4618      	mov	r0, r3
 8014a7a:	3714      	adds	r7, #20
 8014a7c:	46bd      	mov	sp, r7
 8014a7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a82:	4770      	bx	lr

08014a84 <DecodeRsaPssParams>:
 * @return  ASN_PARSE_E when the decoding fails.
 * @return  0 on success.
 */
static int DecodeRsaPssParams(const byte* params, word32 sz,
    enum wc_HashType* hash, int* mgf, int* saltLen)
{
 8014a84:	b580      	push	{r7, lr}
 8014a86:	b090      	sub	sp, #64	@ 0x40
 8014a88:	af04      	add	r7, sp, #16
 8014a8a:	60f8      	str	r0, [r7, #12]
 8014a8c:	60b9      	str	r1, [r7, #8]
 8014a8e:	607a      	str	r2, [r7, #4]
 8014a90:	603b      	str	r3, [r7, #0]
        ret = ASN_PARSE_E;
    }

    return ret;
#else
    DECL_ASNGETDATA(dataASN, rsaPssParamsASN_Length);
 8014a92:	2300      	movs	r3, #0
 8014a94:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int ret = 0;
 8014a96:	2300      	movs	r3, #0
 8014a98:	62bb      	str	r3, [r7, #40]	@ 0x28
    word16 sLen = 20;
 8014a9a:	2314      	movs	r3, #20
 8014a9c:	837b      	strh	r3, [r7, #26]

    if (params == NULL) {
 8014a9e:	68fb      	ldr	r3, [r7, #12]
 8014aa0:	2b00      	cmp	r3, #0
 8014aa2:	d102      	bne.n	8014aaa <DecodeRsaPssParams+0x26>
        ret = BAD_FUNC_ARG;
 8014aa4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014aa8:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    CALLOC_ASNGETDATA(dataASN, rsaPssParamsASN_Length, ret, NULL);
 8014aaa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014aac:	2b00      	cmp	r3, #0
 8014aae:	d10a      	bne.n	8014ac6 <DecodeRsaPssParams+0x42>
 8014ab0:	f44f 70d2 	mov.w	r0, #420	@ 0x1a4
 8014ab4:	f00a f8e2 	bl	801ec7c <wolfSSL_Malloc>
 8014ab8:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8014aba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014abc:	2b00      	cmp	r3, #0
 8014abe:	d102      	bne.n	8014ac6 <DecodeRsaPssParams+0x42>
 8014ac0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014ac4:	62bb      	str	r3, [r7, #40]	@ 0x28
 8014ac6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014ac8:	2b00      	cmp	r3, #0
 8014aca:	d105      	bne.n	8014ad8 <DecodeRsaPssParams+0x54>
 8014acc:	f44f 72d2 	mov.w	r2, #420	@ 0x1a4
 8014ad0:	2100      	movs	r1, #0
 8014ad2:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8014ad4:	f014 f8a6 	bl	8028c24 <memset>
    if (ret == 0) {
 8014ad8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014ada:	2b00      	cmp	r3, #0
 8014adc:	d128      	bne.n	8014b30 <DecodeRsaPssParams+0xac>
        word32 inOutIdx = 0;
 8014ade:	2300      	movs	r3, #0
 8014ae0:	617b      	str	r3, [r7, #20]
        /* Default values. */
        *hash = WC_HASH_TYPE_SHA;
 8014ae2:	687b      	ldr	r3, [r7, #4]
 8014ae4:	2204      	movs	r2, #4
 8014ae6:	701a      	strb	r2, [r3, #0]
        *mgf = WC_MGF1SHA1;
 8014ae8:	683b      	ldr	r3, [r7, #0]
 8014aea:	221a      	movs	r2, #26
 8014aec:	601a      	str	r2, [r3, #0]

        /* Set OID type expected. */
        GetASN_OID(&dataASN[RSAPSSPARAMSASN_IDX_HASHOID], oidHashType);
 8014aee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014af0:	3354      	adds	r3, #84	@ 0x54
 8014af2:	2200      	movs	r2, #0
 8014af4:	611a      	str	r2, [r3, #16]
        GetASN_OID(&dataASN[RSAPSSPARAMSASN_IDX_MGFHOID], oidHashType);
 8014af6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014af8:	33fc      	adds	r3, #252	@ 0xfc
 8014afa:	2200      	movs	r2, #0
 8014afc:	611a      	str	r2, [r3, #16]
        /* Place the salt length into 16-bit var sLen. */
        GetASN_Int16Bit(&dataASN[RSAPSSPARAMSASN_IDX_SALTLENINT], &sLen);
 8014afe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b00:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8014b04:	2202      	movs	r2, #2
 8014b06:	761a      	strb	r2, [r3, #24]
 8014b08:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b0a:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8014b0e:	f107 021a 	add.w	r2, r7, #26
 8014b12:	609a      	str	r2, [r3, #8]
        /* Decode the algorithm identifier. */
        ret = GetASN_Items(rsaPssParamsASN, dataASN, rsaPssParamsASN_Length, 1,
 8014b14:	68bb      	ldr	r3, [r7, #8]
 8014b16:	9302      	str	r3, [sp, #8]
 8014b18:	f107 0314 	add.w	r3, r7, #20
 8014b1c:	9301      	str	r3, [sp, #4]
 8014b1e:	68fb      	ldr	r3, [r7, #12]
 8014b20:	9300      	str	r3, [sp, #0]
 8014b22:	2301      	movs	r3, #1
 8014b24:	220f      	movs	r2, #15
 8014b26:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8014b28:	481e      	ldr	r0, [pc, #120]	@ (8014ba4 <DecodeRsaPssParams+0x120>)
 8014b2a:	f7fe fea1 	bl	8013870 <GetASN_Items>
 8014b2e:	62b8      	str	r0, [r7, #40]	@ 0x28
            params, &inOutIdx, sz);
    }
    if ((ret == 0) && (dataASN[RSAPSSPARAMSASN_IDX_HASHOID].tag != 0)) {
 8014b30:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014b32:	2b00      	cmp	r3, #0
 8014b34:	d10d      	bne.n	8014b52 <DecodeRsaPssParams+0xce>
 8014b36:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b38:	3354      	adds	r3, #84	@ 0x54
 8014b3a:	7e5b      	ldrb	r3, [r3, #25]
 8014b3c:	2b00      	cmp	r3, #0
 8014b3e:	d008      	beq.n	8014b52 <DecodeRsaPssParams+0xce>
        word32 oid = dataASN[RSAPSSPARAMSASN_IDX_HASHOID].data.oid.sum;
 8014b40:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b42:	3354      	adds	r3, #84	@ 0x54
 8014b44:	695b      	ldr	r3, [r3, #20]
 8014b46:	627b      	str	r3, [r7, #36]	@ 0x24
        ret = RsaPssHashOidToType(oid, hash);
 8014b48:	6879      	ldr	r1, [r7, #4]
 8014b4a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8014b4c:	f7ff ff4c 	bl	80149e8 <RsaPssHashOidToType>
 8014b50:	62b8      	str	r0, [r7, #40]	@ 0x28
    }
    if ((ret == 0) && (dataASN[RSAPSSPARAMSASN_IDX_MGFHOID].tag != 0)) {
 8014b52:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014b54:	2b00      	cmp	r3, #0
 8014b56:	d10d      	bne.n	8014b74 <DecodeRsaPssParams+0xf0>
 8014b58:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b5a:	33fc      	adds	r3, #252	@ 0xfc
 8014b5c:	7e5b      	ldrb	r3, [r3, #25]
 8014b5e:	2b00      	cmp	r3, #0
 8014b60:	d008      	beq.n	8014b74 <DecodeRsaPssParams+0xf0>
        word32 oid = dataASN[RSAPSSPARAMSASN_IDX_MGFHOID].data.oid.sum;
 8014b62:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b64:	33fc      	adds	r3, #252	@ 0xfc
 8014b66:	695b      	ldr	r3, [r3, #20]
 8014b68:	623b      	str	r3, [r7, #32]
        ret = RsaPssHashOidToMgf1(oid, mgf);
 8014b6a:	6839      	ldr	r1, [r7, #0]
 8014b6c:	6a38      	ldr	r0, [r7, #32]
 8014b6e:	f7ff ff55 	bl	8014a1c <RsaPssHashOidToMgf1>
 8014b72:	62b8      	str	r0, [r7, #40]	@ 0x28
    }
    if (ret == 0) {
 8014b74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014b76:	2b00      	cmp	r3, #0
 8014b78:	d103      	bne.n	8014b82 <DecodeRsaPssParams+0xfe>
        *saltLen = sLen;
 8014b7a:	8b7b      	ldrh	r3, [r7, #26]
 8014b7c:	461a      	mov	r2, r3
 8014b7e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014b80:	601a      	str	r2, [r3, #0]
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8014b82:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b84:	2b00      	cmp	r3, #0
 8014b86:	d007      	beq.n	8014b98 <DecodeRsaPssParams+0x114>
 8014b88:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b8a:	61fb      	str	r3, [r7, #28]
 8014b8c:	69fb      	ldr	r3, [r7, #28]
 8014b8e:	2b00      	cmp	r3, #0
 8014b90:	d002      	beq.n	8014b98 <DecodeRsaPssParams+0x114>
 8014b92:	69f8      	ldr	r0, [r7, #28]
 8014b94:	f00a f88e 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 8014b98:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8014b9a:	4618      	mov	r0, r3
 8014b9c:	3730      	adds	r7, #48	@ 0x30
 8014b9e:	46bd      	mov	sp, r7
 8014ba0:	bd80      	pop	{r7, pc}
 8014ba2:	bf00      	nop
 8014ba4:	0803453c 	.word	0x0803453c

08014ba8 <GetRsaInt>:
 * @param [in] idx  Index of number.
 * @return  A pointer to an mp_int when valid index.
 * @return  NULL when invalid index.
 */
static mp_int* GetRsaInt(RsaKey* key, int idx)
{
 8014ba8:	b480      	push	{r7}
 8014baa:	b083      	sub	sp, #12
 8014bac:	af00      	add	r7, sp, #0
 8014bae:	6078      	str	r0, [r7, #4]
 8014bb0:	6039      	str	r1, [r7, #0]
    /* Cast key to byte array to and use offset to get to mp_int field. */
    return (mp_int*)(((byte*)key) + rsaIntOffset[idx]);
 8014bb2:	4a06      	ldr	r2, [pc, #24]	@ (8014bcc <GetRsaInt+0x24>)
 8014bb4:	683b      	ldr	r3, [r7, #0]
 8014bb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014bba:	687a      	ldr	r2, [r7, #4]
 8014bbc:	4413      	add	r3, r2
}
 8014bbe:	4618      	mov	r0, r3
 8014bc0:	370c      	adds	r7, #12
 8014bc2:	46bd      	mov	sp, r7
 8014bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014bc8:	4770      	bx	lr
 8014bca:	bf00      	nop
 8014bcc:	200000b0 	.word	0x200000b0

08014bd0 <_RsaPrivateKeyDecode>:
 * @return  MP_INIT_E when the unable to initialize an mp_int.
 * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
 */
static int _RsaPrivateKeyDecode(const byte* input, word32* inOutIdx,
    RsaKey* key, int* keySz, word32 inSz)
{
 8014bd0:	b590      	push	{r4, r7, lr}
 8014bd2:	b091      	sub	sp, #68	@ 0x44
 8014bd4:	af04      	add	r7, sp, #16
 8014bd6:	60f8      	str	r0, [r7, #12]
 8014bd8:	60b9      	str	r1, [r7, #8]
 8014bda:	607a      	str	r2, [r7, #4]
 8014bdc:	603b      	str	r3, [r7, #0]
    #endif
    }

    return 0;
#else
    DECL_ASNGETDATA(dataASN, rsaKeyASN_Length);
 8014bde:	2300      	movs	r3, #0
 8014be0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int        ret = 0;
 8014be2:	2300      	movs	r3, #0
 8014be4:	62bb      	str	r3, [r7, #40]	@ 0x28
    byte       version = (byte)-1;
 8014be6:	23ff      	movs	r3, #255	@ 0xff
 8014be8:	76fb      	strb	r3, [r7, #27]
#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)
    word32 algId = 0;
 8014bea:	2300      	movs	r3, #0
 8014bec:	617b      	str	r3, [r7, #20]
#endif
    void*      heap = NULL;
 8014bee:	2300      	movs	r3, #0
 8014bf0:	623b      	str	r3, [r7, #32]

    /* Check validity of parameters. */
    if ((inOutIdx == NULL) || (input == NULL) || ((key == NULL) &&
 8014bf2:	68bb      	ldr	r3, [r7, #8]
 8014bf4:	2b00      	cmp	r3, #0
 8014bf6:	d008      	beq.n	8014c0a <_RsaPrivateKeyDecode+0x3a>
 8014bf8:	68fb      	ldr	r3, [r7, #12]
 8014bfa:	2b00      	cmp	r3, #0
 8014bfc:	d005      	beq.n	8014c0a <_RsaPrivateKeyDecode+0x3a>
 8014bfe:	687b      	ldr	r3, [r7, #4]
 8014c00:	2b00      	cmp	r3, #0
 8014c02:	d105      	bne.n	8014c10 <_RsaPrivateKeyDecode+0x40>
 8014c04:	683b      	ldr	r3, [r7, #0]
 8014c06:	2b00      	cmp	r3, #0
 8014c08:	d102      	bne.n	8014c10 <_RsaPrivateKeyDecode+0x40>
            (keySz == NULL))) {
        ret = BAD_FUNC_ARG;
 8014c0a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014c0e:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    if ((ret == 0) && (key != NULL)) {
 8014c10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014c12:	2b00      	cmp	r3, #0
 8014c14:	d108      	bne.n	8014c28 <_RsaPrivateKeyDecode+0x58>
 8014c16:	687b      	ldr	r3, [r7, #4]
 8014c18:	2b00      	cmp	r3, #0
 8014c1a:	d005      	beq.n	8014c28 <_RsaPrivateKeyDecode+0x58>
        heap = key->heap;
 8014c1c:	687b      	ldr	r3, [r7, #4]
 8014c1e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8014c22:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8014c26:	623b      	str	r3, [r7, #32]
    }

#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)
    if (ret == 0) {
 8014c28:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014c2a:	2b00      	cmp	r3, #0
 8014c2c:	d106      	bne.n	8014c3c <_RsaPrivateKeyDecode+0x6c>
        /* if has pkcs8 header skip it */
        if (ToTraditionalInline_ex(input, inOutIdx, inSz, &algId) < 0) {
 8014c2e:	f107 0314 	add.w	r3, r7, #20
 8014c32:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8014c34:	68b9      	ldr	r1, [r7, #8]
 8014c36:	68f8      	ldr	r0, [r7, #12]
 8014c38:	f000 f9dc 	bl	8014ff4 <ToTraditionalInline_ex>
        }
    }
#endif

    (void)heap;
    CALLOC_ASNGETDATA(dataASN, rsaKeyASN_Length, ret, heap);
 8014c3c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014c3e:	2b00      	cmp	r3, #0
 8014c40:	d10a      	bne.n	8014c58 <_RsaPrivateKeyDecode+0x88>
 8014c42:	f44f 708c 	mov.w	r0, #280	@ 0x118
 8014c46:	f00a f819 	bl	801ec7c <wolfSSL_Malloc>
 8014c4a:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8014c4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014c4e:	2b00      	cmp	r3, #0
 8014c50:	d102      	bne.n	8014c58 <_RsaPrivateKeyDecode+0x88>
 8014c52:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014c56:	62bb      	str	r3, [r7, #40]	@ 0x28
 8014c58:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014c5a:	2b00      	cmp	r3, #0
 8014c5c:	d105      	bne.n	8014c6a <_RsaPrivateKeyDecode+0x9a>
 8014c5e:	f44f 728c 	mov.w	r2, #280	@ 0x118
 8014c62:	2100      	movs	r1, #0
 8014c64:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8014c66:	f013 ffdd 	bl	8028c24 <memset>

    if (ret == 0) {
 8014c6a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014c6c:	2b00      	cmp	r3, #0
 8014c6e:	d13d      	bne.n	8014cec <_RsaPrivateKeyDecode+0x11c>
        /* Register variable to hold version field. */
        GetASN_Int8Bit(&dataASN[RSAKEYASN_IDX_VER], &version);
 8014c70:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014c72:	331c      	adds	r3, #28
 8014c74:	2201      	movs	r2, #1
 8014c76:	761a      	strb	r2, [r3, #24]
 8014c78:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014c7a:	331c      	adds	r3, #28
 8014c7c:	f107 021b 	add.w	r2, r7, #27
 8014c80:	609a      	str	r2, [r3, #8]
    #else
        #define RSA_ASN_INTS        RSA_INTS
        /* Extracting all data from BER encoding. */
        #define RSA_ASN_COMPLETE    1
    #endif
        if (key != NULL) {
 8014c82:	687b      	ldr	r3, [r7, #4]
 8014c84:	2b00      	cmp	r3, #0
 8014c86:	d024      	beq.n	8014cd2 <_RsaPrivateKeyDecode+0x102>
            int i;
            /* Extract all public fields. */
            for (i = 0; i < RSA_ASN_INTS; i++) {
 8014c88:	2300      	movs	r3, #0
 8014c8a:	627b      	str	r3, [r7, #36]	@ 0x24
 8014c8c:	e01e      	b.n	8014ccc <_RsaPrivateKeyDecode+0xfc>
                GetASN_MP(&dataASN[(byte)RSAKEYASN_IDX_N + i],
 8014c8e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014c90:	3302      	adds	r3, #2
 8014c92:	461a      	mov	r2, r3
 8014c94:	4613      	mov	r3, r2
 8014c96:	00db      	lsls	r3, r3, #3
 8014c98:	1a9b      	subs	r3, r3, r2
 8014c9a:	009b      	lsls	r3, r3, #2
 8014c9c:	461a      	mov	r2, r3
 8014c9e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014ca0:	4413      	add	r3, r2
 8014ca2:	2208      	movs	r2, #8
 8014ca4:	761a      	strb	r2, [r3, #24]
 8014ca6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014ca8:	3302      	adds	r3, #2
 8014caa:	461a      	mov	r2, r3
 8014cac:	4613      	mov	r3, r2
 8014cae:	00db      	lsls	r3, r3, #3
 8014cb0:	1a9b      	subs	r3, r3, r2
 8014cb2:	009b      	lsls	r3, r3, #2
 8014cb4:	461a      	mov	r2, r3
 8014cb6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014cb8:	189c      	adds	r4, r3, r2
 8014cba:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8014cbc:	6878      	ldr	r0, [r7, #4]
 8014cbe:	f7ff ff73 	bl	8014ba8 <GetRsaInt>
 8014cc2:	4603      	mov	r3, r0
 8014cc4:	60a3      	str	r3, [r4, #8]
            for (i = 0; i < RSA_ASN_INTS; i++) {
 8014cc6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014cc8:	3301      	adds	r3, #1
 8014cca:	627b      	str	r3, [r7, #36]	@ 0x24
 8014ccc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014cce:	2b07      	cmp	r3, #7
 8014cd0:	dddd      	ble.n	8014c8e <_RsaPrivateKeyDecode+0xbe>
                    GetRsaInt(key, i));
            }
        }
        /* Parse BER encoding for RSA private key. */
        ret = GetASN_Items(rsaKeyASN, dataASN, rsaKeyASN_Length,
 8014cd2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014cd4:	9302      	str	r3, [sp, #8]
 8014cd6:	68bb      	ldr	r3, [r7, #8]
 8014cd8:	9301      	str	r3, [sp, #4]
 8014cda:	68fb      	ldr	r3, [r7, #12]
 8014cdc:	9300      	str	r3, [sp, #0]
 8014cde:	2301      	movs	r3, #1
 8014ce0:	220a      	movs	r2, #10
 8014ce2:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8014ce4:	4822      	ldr	r0, [pc, #136]	@ (8014d70 <_RsaPrivateKeyDecode+0x1a0>)
 8014ce6:	f7fe fdc3 	bl	8013870 <GetASN_Items>
 8014cea:	62b8      	str	r0, [r7, #40]	@ 0x28
    }
    /* Check version: 0 - two prime, 1 - multi-prime
     * Multi-prime has optional sequence after coefficient for extra primes.
     * If extra primes, parsing will fail as not all the buffer was used.
     */
    if ((ret == 0) && (version > PKCS1v1)) {
 8014cec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014cee:	2b00      	cmp	r3, #0
 8014cf0:	d105      	bne.n	8014cfe <_RsaPrivateKeyDecode+0x12e>
 8014cf2:	7efb      	ldrb	r3, [r7, #27]
 8014cf4:	2b01      	cmp	r3, #1
 8014cf6:	d902      	bls.n	8014cfe <_RsaPrivateKeyDecode+0x12e>
        ret = ASN_PARSE_E;
 8014cf8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014cfc:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
    if ((ret == 0) && (key != NULL)) {
 8014cfe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014d00:	2b00      	cmp	r3, #0
 8014d02:	d10a      	bne.n	8014d1a <_RsaPrivateKeyDecode+0x14a>
 8014d04:	687b      	ldr	r3, [r7, #4]
 8014d06:	2b00      	cmp	r3, #0
 8014d08:	d007      	beq.n	8014d1a <_RsaPrivateKeyDecode+0x14a>
    #if !defined(WOLFSSL_RSA_PUBLIC_ONLY)
        /* RSA key object has all private key values. */
        key->type = RSA_PRIVATE;
 8014d0a:	687b      	ldr	r3, [r7, #4]
 8014d0c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8014d10:	461a      	mov	r2, r3
 8014d12:	2301      	movs	r3, #1
 8014d14:	f8c2 3168 	str.w	r3, [r2, #360]	@ 0x168
 8014d18:	e01a      	b.n	8014d50 <_RsaPrivateKeyDecode+0x180>
    #ifdef WOLFSSL_XILINX_CRYPT
        if (wc_InitRsaHw(key) != 0)
            ret = BAD_STATE_E;
    #endif
    }
    else if (ret == 0) {
 8014d1a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014d1c:	2b00      	cmp	r3, #0
 8014d1e:	d117      	bne.n	8014d50 <_RsaPrivateKeyDecode+0x180>
        /* Not filling in key but do want key size. */
        *keySz = (int)dataASN[(byte)RSAKEYASN_IDX_N].length;
 8014d20:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014d22:	3338      	adds	r3, #56	@ 0x38
 8014d24:	685b      	ldr	r3, [r3, #4]
 8014d26:	461a      	mov	r2, r3
 8014d28:	683b      	ldr	r3, [r7, #0]
 8014d2a:	601a      	str	r2, [r3, #0]
        /* Check whether first byte of data is 0x00 and drop it. */
        if (input[(int)dataASN[RSAKEYASN_IDX_E].offset - *keySz] == 0) {
 8014d2c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014d2e:	3354      	adds	r3, #84	@ 0x54
 8014d30:	681b      	ldr	r3, [r3, #0]
 8014d32:	461a      	mov	r2, r3
 8014d34:	683b      	ldr	r3, [r7, #0]
 8014d36:	681b      	ldr	r3, [r3, #0]
 8014d38:	1ad3      	subs	r3, r2, r3
 8014d3a:	461a      	mov	r2, r3
 8014d3c:	68fb      	ldr	r3, [r7, #12]
 8014d3e:	4413      	add	r3, r2
 8014d40:	781b      	ldrb	r3, [r3, #0]
 8014d42:	2b00      	cmp	r3, #0
 8014d44:	d104      	bne.n	8014d50 <_RsaPrivateKeyDecode+0x180>
            (*keySz)--;
 8014d46:	683b      	ldr	r3, [r7, #0]
 8014d48:	681b      	ldr	r3, [r3, #0]
 8014d4a:	1e5a      	subs	r2, r3, #1
 8014d4c:	683b      	ldr	r3, [r7, #0]
 8014d4e:	601a      	str	r2, [r3, #0]
        }
    }

    FREE_ASNGETDATA(dataASN, heap);
 8014d50:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014d52:	2b00      	cmp	r3, #0
 8014d54:	d007      	beq.n	8014d66 <_RsaPrivateKeyDecode+0x196>
 8014d56:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014d58:	61fb      	str	r3, [r7, #28]
 8014d5a:	69fb      	ldr	r3, [r7, #28]
 8014d5c:	2b00      	cmp	r3, #0
 8014d5e:	d002      	beq.n	8014d66 <_RsaPrivateKeyDecode+0x196>
 8014d60:	69f8      	ldr	r0, [r7, #28]
 8014d62:	f009 ffa7 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 8014d66:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8014d68:	4618      	mov	r0, r3
 8014d6a:	3734      	adds	r7, #52	@ 0x34
 8014d6c:	46bd      	mov	sp, r7
 8014d6e:	bd90      	pop	{r4, r7, pc}
 8014d70:	08034578 	.word	0x08034578

08014d74 <wc_RsaPrivateKeyDecode>:
 * @return  MP_INIT_E when the unable to initialize an mp_int.
 * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
 */
int wc_RsaPrivateKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,
    word32 inSz)
{
 8014d74:	b580      	push	{r7, lr}
 8014d76:	b086      	sub	sp, #24
 8014d78:	af02      	add	r7, sp, #8
 8014d7a:	60f8      	str	r0, [r7, #12]
 8014d7c:	60b9      	str	r1, [r7, #8]
 8014d7e:	607a      	str	r2, [r7, #4]
 8014d80:	603b      	str	r3, [r7, #0]
    if (key == NULL) {
 8014d82:	687b      	ldr	r3, [r7, #4]
 8014d84:	2b00      	cmp	r3, #0
 8014d86:	d102      	bne.n	8014d8e <wc_RsaPrivateKeyDecode+0x1a>
        return BAD_FUNC_ARG;
 8014d88:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014d8c:	e008      	b.n	8014da0 <wc_RsaPrivateKeyDecode+0x2c>
    }
    return _RsaPrivateKeyDecode(input, inOutIdx, key, NULL, inSz);
 8014d8e:	683b      	ldr	r3, [r7, #0]
 8014d90:	9300      	str	r3, [sp, #0]
 8014d92:	2300      	movs	r3, #0
 8014d94:	687a      	ldr	r2, [r7, #4]
 8014d96:	68b9      	ldr	r1, [r7, #8]
 8014d98:	68f8      	ldr	r0, [r7, #12]
 8014d9a:	f7ff ff19 	bl	8014bd0 <_RsaPrivateKeyDecode>
 8014d9e:	4603      	mov	r3, r0
}
 8014da0:	4618      	mov	r0, r3
 8014da2:	3710      	adds	r7, #16
 8014da4:	46bd      	mov	sp, r7
 8014da6:	bd80      	pop	{r7, pc}

08014da8 <wc_RsaPrivateKeyValidate>:
 * @return  MP_INIT_E when the unable to initialize an mp_int.
 * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
 */
int wc_RsaPrivateKeyValidate(const byte* input, word32* inOutIdx, int* keySz,
     word32 inSz)
{
 8014da8:	b580      	push	{r7, lr}
 8014daa:	b086      	sub	sp, #24
 8014dac:	af02      	add	r7, sp, #8
 8014dae:	60f8      	str	r0, [r7, #12]
 8014db0:	60b9      	str	r1, [r7, #8]
 8014db2:	607a      	str	r2, [r7, #4]
 8014db4:	603b      	str	r3, [r7, #0]
    return _RsaPrivateKeyDecode(input, inOutIdx, NULL, keySz, inSz);
 8014db6:	683b      	ldr	r3, [r7, #0]
 8014db8:	9300      	str	r3, [sp, #0]
 8014dba:	687b      	ldr	r3, [r7, #4]
 8014dbc:	2200      	movs	r2, #0
 8014dbe:	68b9      	ldr	r1, [r7, #8]
 8014dc0:	68f8      	ldr	r0, [r7, #12]
 8014dc2:	f7ff ff05 	bl	8014bd0 <_RsaPrivateKeyDecode>
 8014dc6:	4603      	mov	r3, r0
}
 8014dc8:	4618      	mov	r0, r3
 8014dca:	3710      	adds	r7, #16
 8014dcc:	46bd      	mov	sp, r7
 8014dce:	bd80      	pop	{r7, pc}

08014dd0 <ToTraditionalInline_ex2>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
int ToTraditionalInline_ex2(const byte* input, word32* inOutIdx, word32 sz,
                            word32* algId, word32* eccOid)
{
 8014dd0:	b580      	push	{r7, lr}
 8014dd2:	b094      	sub	sp, #80	@ 0x50
 8014dd4:	af04      	add	r7, sp, #16
 8014dd6:	60f8      	str	r0, [r7, #12]
 8014dd8:	60b9      	str	r1, [r7, #8]
 8014dda:	607a      	str	r2, [r7, #4]
 8014ddc:	603b      	str	r3, [r7, #0]

    *inOutIdx = idx;

    return length;
#else
    DECL_ASNGETDATA(dataASN, pkcs8KeyASN_Length);
 8014dde:	2300      	movs	r3, #0
 8014de0:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ret = 0;
 8014de2:	2300      	movs	r3, #0
 8014de4:	63bb      	str	r3, [r7, #56]	@ 0x38
    word32 oid = 9;
 8014de6:	2309      	movs	r3, #9
 8014de8:	637b      	str	r3, [r7, #52]	@ 0x34
    byte version = 0;
 8014dea:	2300      	movs	r3, #0
 8014dec:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
    word32 idx;

    (void)eccOid;

    /* Check validity of parameters. */
    if (input == NULL || inOutIdx == NULL) {
 8014df0:	68fb      	ldr	r3, [r7, #12]
 8014df2:	2b00      	cmp	r3, #0
 8014df4:	d002      	beq.n	8014dfc <ToTraditionalInline_ex2+0x2c>
 8014df6:	68bb      	ldr	r3, [r7, #8]
 8014df8:	2b00      	cmp	r3, #0
 8014dfa:	d102      	bne.n	8014e02 <ToTraditionalInline_ex2+0x32>
        return BAD_FUNC_ARG;
 8014dfc:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014e00:	e0f2      	b.n	8014fe8 <ToTraditionalInline_ex2+0x218>
    }

    idx = *inOutIdx;
 8014e02:	68bb      	ldr	r3, [r7, #8]
 8014e04:	681b      	ldr	r3, [r3, #0]
 8014e06:	61fb      	str	r3, [r7, #28]

    CALLOC_ASNGETDATA(dataASN, pkcs8KeyASN_Length, ret, NULL);
 8014e08:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014e0a:	2b00      	cmp	r3, #0
 8014e0c:	d109      	bne.n	8014e22 <ToTraditionalInline_ex2+0x52>
 8014e0e:	20fc      	movs	r0, #252	@ 0xfc
 8014e10:	f009 ff34 	bl	801ec7c <wolfSSL_Malloc>
 8014e14:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8014e16:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e18:	2b00      	cmp	r3, #0
 8014e1a:	d102      	bne.n	8014e22 <ToTraditionalInline_ex2+0x52>
 8014e1c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014e20:	63bb      	str	r3, [r7, #56]	@ 0x38
 8014e22:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014e24:	2b00      	cmp	r3, #0
 8014e26:	d104      	bne.n	8014e32 <ToTraditionalInline_ex2+0x62>
 8014e28:	22fc      	movs	r2, #252	@ 0xfc
 8014e2a:	2100      	movs	r1, #0
 8014e2c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8014e2e:	f013 fef9 	bl	8028c24 <memset>

    if (ret == 0) {
 8014e32:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014e34:	2b00      	cmp	r3, #0
 8014e36:	d11e      	bne.n	8014e76 <ToTraditionalInline_ex2+0xa6>
        /* Get version, check key type and curve type. */
        GetASN_Int8Bit(&dataASN[PKCS8KEYASN_IDX_VER], &version);
 8014e38:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e3a:	331c      	adds	r3, #28
 8014e3c:	2201      	movs	r2, #1
 8014e3e:	761a      	strb	r2, [r3, #24]
 8014e40:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e42:	331c      	adds	r3, #28
 8014e44:	f107 0223 	add.w	r2, r7, #35	@ 0x23
 8014e48:	609a      	str	r2, [r3, #8]
        GetASN_OID(&dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_KEY], oidKeyType);
 8014e4a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e4c:	3354      	adds	r3, #84	@ 0x54
 8014e4e:	2202      	movs	r2, #2
 8014e50:	611a      	str	r2, [r3, #16]
        GetASN_OID(&dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE], oidCurveType);
 8014e52:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e54:	3370      	adds	r3, #112	@ 0x70
 8014e56:	2203      	movs	r2, #3
 8014e58:	611a      	str	r2, [r3, #16]
        /* Parse data. */
        ret = GetASN_Items(pkcs8KeyASN, dataASN, pkcs8KeyASN_Length, 1, input,
 8014e5a:	687b      	ldr	r3, [r7, #4]
 8014e5c:	9302      	str	r3, [sp, #8]
 8014e5e:	f107 031c 	add.w	r3, r7, #28
 8014e62:	9301      	str	r3, [sp, #4]
 8014e64:	68fb      	ldr	r3, [r7, #12]
 8014e66:	9300      	str	r3, [sp, #0]
 8014e68:	2301      	movs	r3, #1
 8014e6a:	2209      	movs	r2, #9
 8014e6c:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8014e6e:	4860      	ldr	r0, [pc, #384]	@ (8014ff0 <ToTraditionalInline_ex2+0x220>)
 8014e70:	f7fe fcfe 	bl	8013870 <GetASN_Items>
 8014e74:	63b8      	str	r0, [r7, #56]	@ 0x38
                           &idx, sz);
    }

    if (ret == 0) {
 8014e76:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014e78:	2b00      	cmp	r3, #0
 8014e7a:	d10a      	bne.n	8014e92 <ToTraditionalInline_ex2+0xc2>
        /* Key type OID. */
        oid = dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_KEY].data.oid.sum;
 8014e7c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e7e:	3354      	adds	r3, #84	@ 0x54
 8014e80:	695b      	ldr	r3, [r3, #20]
 8014e82:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Version 1 includes an optional public key.
         * If public key is included then the parsing will fail as it did not
         * use all the data.
         */
        if (version > PKCS8v1) {
 8014e84:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8014e88:	2b01      	cmp	r3, #1
 8014e8a:	d902      	bls.n	8014e92 <ToTraditionalInline_ex2+0xc2>
            ret = ASN_PARSE_E;
 8014e8c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014e90:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
    }
    if (ret == 0) {
 8014e92:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014e94:	2b00      	cmp	r3, #0
 8014e96:	f040 8089 	bne.w	8014fac <ToTraditionalInline_ex2+0x1dc>
        switch (oid) {
 8014e9a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014e9c:	f240 228e 	movw	r2, #654	@ 0x28e
 8014ea0:	4293      	cmp	r3, r2
 8014ea2:	d025      	beq.n	8014ef0 <ToTraditionalInline_ex2+0x120>
 8014ea4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014ea6:	f240 228e 	movw	r2, #654	@ 0x28e
 8014eaa:	4293      	cmp	r3, r2
 8014eac:	d875      	bhi.n	8014f9a <ToTraditionalInline_ex2+0x1ca>
 8014eae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014eb0:	f240 2287 	movw	r2, #647	@ 0x287
 8014eb4:	4293      	cmp	r3, r2
 8014eb6:	d062      	beq.n	8014f7e <ToTraditionalInline_ex2+0x1ae>
 8014eb8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014eba:	f5b3 7f22 	cmp.w	r3, #648	@ 0x288
 8014ebe:	d26c      	bcs.n	8014f9a <ToTraditionalInline_ex2+0x1ca>
 8014ec0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014ec2:	f240 2206 	movw	r2, #518	@ 0x206
 8014ec6:	4293      	cmp	r3, r2
 8014ec8:	d046      	beq.n	8014f58 <ToTraditionalInline_ex2+0x188>
 8014eca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014ecc:	f240 2285 	movw	r2, #645	@ 0x285
 8014ed0:	4293      	cmp	r3, r2
 8014ed2:	d162      	bne.n	8014f9a <ToTraditionalInline_ex2+0x1ca>
    #ifndef NO_RSA
            case RSAk:
                /* Must have NULL item but not OBJECT_ID item. */
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag == 0) ||
 8014ed4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014ed6:	338c      	adds	r3, #140	@ 0x8c
 8014ed8:	7e5b      	ldrb	r3, [r3, #25]
 8014eda:	2b00      	cmp	r3, #0
 8014edc:	d004      	beq.n	8014ee8 <ToTraditionalInline_ex2+0x118>
                    (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE].tag != 0)) {
 8014ede:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014ee0:	3370      	adds	r3, #112	@ 0x70
 8014ee2:	7e5b      	ldrb	r3, [r3, #25]
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag == 0) ||
 8014ee4:	2b00      	cmp	r3, #0
 8014ee6:	d05a      	beq.n	8014f9e <ToTraditionalInline_ex2+0x1ce>
                    ret = ASN_PARSE_E;
 8014ee8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014eec:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                break;
 8014eee:	e056      	b.n	8014f9e <ToTraditionalInline_ex2+0x1ce>
        #ifdef WC_RSA_PSS
            case RSAPSSk:
                /* Must not have NULL item. */
                if (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) {
 8014ef0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014ef2:	338c      	adds	r3, #140	@ 0x8c
 8014ef4:	7e5b      	ldrb	r3, [r3, #25]
 8014ef6:	2b00      	cmp	r3, #0
 8014ef8:	d002      	beq.n	8014f00 <ToTraditionalInline_ex2+0x130>
                    ret = ASN_PARSE_E;
 8014efa:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014efe:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                if (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_PARAM_SEQ].tag != 0) {
 8014f00:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014f02:	33a8      	adds	r3, #168	@ 0xa8
 8014f04:	7e5b      	ldrb	r3, [r3, #25]
 8014f06:	2b00      	cmp	r3, #0
 8014f08:	d04b      	beq.n	8014fa2 <ToTraditionalInline_ex2+0x1d2>
                    enum wc_HashType hash;
                    int mgf;
                    int saltLen;
                    const byte* params = GetASNItem_Addr(
 8014f0a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014f0c:	33a8      	adds	r3, #168	@ 0xa8
 8014f0e:	681b      	ldr	r3, [r3, #0]
 8014f10:	68fa      	ldr	r2, [r7, #12]
 8014f12:	4413      	add	r3, r2
 8014f14:	633b      	str	r3, [r7, #48]	@ 0x30
                        dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_PARAM_SEQ], input);
                    word32 paramsSz = GetASNItem_Length(
 8014f16:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014f18:	33a8      	adds	r3, #168	@ 0xa8
 8014f1a:	685b      	ldr	r3, [r3, #4]
 8014f1c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014f1e:	32a8      	adds	r2, #168	@ 0xa8
 8014f20:	6891      	ldr	r1, [r2, #8]
 8014f22:	68fa      	ldr	r2, [r7, #12]
 8014f24:	1a8a      	subs	r2, r1, r2
 8014f26:	441a      	add	r2, r3
 8014f28:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014f2a:	33a8      	adds	r3, #168	@ 0xa8
 8014f2c:	681b      	ldr	r3, [r3, #0]
 8014f2e:	1ad3      	subs	r3, r2, r3
 8014f30:	62fb      	str	r3, [r7, #44]	@ 0x2c
                        dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_PARAM_SEQ], input);

                    /* Validate the private key parameters. */
                    ret = DecodeRsaPssParams(params, paramsSz, &hash, &mgf,
 8014f32:	f107 0114 	add.w	r1, r7, #20
 8014f36:	f107 021b 	add.w	r2, r7, #27
 8014f3a:	f107 0310 	add.w	r3, r7, #16
 8014f3e:	9300      	str	r3, [sp, #0]
 8014f40:	460b      	mov	r3, r1
 8014f42:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8014f44:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8014f46:	f7ff fd9d 	bl	8014a84 <DecodeRsaPssParams>
 8014f4a:	63b8      	str	r0, [r7, #56]	@ 0x38
                        &saltLen);
                    if (ret != 0) {
 8014f4c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014f4e:	2b00      	cmp	r3, #0
 8014f50:	d027      	beq.n	8014fa2 <ToTraditionalInline_ex2+0x1d2>
                        return ASN_PARSE_E;
 8014f52:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014f56:	e047      	b.n	8014fe8 <ToTraditionalInline_ex2+0x218>
        #endif
    #endif
        #ifdef HAVE_ECC
            case ECDSAk:
                /* Must not have NULL item. */
                if (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) {
 8014f58:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014f5a:	338c      	adds	r3, #140	@ 0x8c
 8014f5c:	7e5b      	ldrb	r3, [r3, #25]
 8014f5e:	2b00      	cmp	r3, #0
 8014f60:	d002      	beq.n	8014f68 <ToTraditionalInline_ex2+0x198>
                    ret = ASN_PARSE_E;
 8014f62:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014f66:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                if (eccOid != NULL) {
 8014f68:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8014f6a:	2b00      	cmp	r3, #0
 8014f6c:	d01b      	beq.n	8014fa6 <ToTraditionalInline_ex2+0x1d6>
                    ASNGetData* oidCurve =
 8014f6e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014f70:	3370      	adds	r3, #112	@ 0x70
 8014f72:	62bb      	str	r3, [r7, #40]	@ 0x28
                        &dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE];
                    *eccOid = oidCurve->data.oid.sum;
 8014f74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014f76:	695a      	ldr	r2, [r3, #20]
 8014f78:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8014f7a:	601a      	str	r2, [r3, #0]
                }
                break;
 8014f7c:	e013      	b.n	8014fa6 <ToTraditionalInline_ex2+0x1d6>
                break;
        #endif
        #ifndef NO_DH
            case DHk:
                /* Neither NULL item nor OBJECT_ID item allowed. */
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) ||
 8014f7e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014f80:	338c      	adds	r3, #140	@ 0x8c
 8014f82:	7e5b      	ldrb	r3, [r3, #25]
 8014f84:	2b00      	cmp	r3, #0
 8014f86:	d104      	bne.n	8014f92 <ToTraditionalInline_ex2+0x1c2>
                    (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE].tag != 0)) {
 8014f88:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014f8a:	3370      	adds	r3, #112	@ 0x70
 8014f8c:	7e5b      	ldrb	r3, [r3, #25]
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) ||
 8014f8e:	2b00      	cmp	r3, #0
 8014f90:	d00b      	beq.n	8014faa <ToTraditionalInline_ex2+0x1da>
                    ret = ASN_PARSE_E;
 8014f92:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014f96:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                break;
 8014f98:	e007      	b.n	8014faa <ToTraditionalInline_ex2+0x1da>
        #endif
            /* DSAk not supported. */
            /* Falcon, Dilithium and Sphincs not supported. */
            /* Ignore OID lookup failures. */
            default:
                break;
 8014f9a:	bf00      	nop
 8014f9c:	e006      	b.n	8014fac <ToTraditionalInline_ex2+0x1dc>
                break;
 8014f9e:	bf00      	nop
 8014fa0:	e004      	b.n	8014fac <ToTraditionalInline_ex2+0x1dc>
                break;
 8014fa2:	bf00      	nop
 8014fa4:	e002      	b.n	8014fac <ToTraditionalInline_ex2+0x1dc>
                break;
 8014fa6:	bf00      	nop
 8014fa8:	e000      	b.n	8014fac <ToTraditionalInline_ex2+0x1dc>
                break;
 8014faa:	bf00      	nop
        }
    }
    if (ret == 0) {
 8014fac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014fae:	2b00      	cmp	r3, #0
 8014fb0:	d10e      	bne.n	8014fd0 <ToTraditionalInline_ex2+0x200>
        /* Return algorithm id of internal key. */
        *algId = oid;
 8014fb2:	683b      	ldr	r3, [r7, #0]
 8014fb4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8014fb6:	601a      	str	r2, [r3, #0]
        /* Return index to start of internal key. */
        *inOutIdx = GetASNItem_DataIdx(dataASN[PKCS8KEYASN_IDX_PKEY_DATA], input);
 8014fb8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014fba:	33c4      	adds	r3, #196	@ 0xc4
 8014fbc:	689a      	ldr	r2, [r3, #8]
 8014fbe:	68fb      	ldr	r3, [r7, #12]
 8014fc0:	1ad3      	subs	r3, r2, r3
 8014fc2:	461a      	mov	r2, r3
 8014fc4:	68bb      	ldr	r3, [r7, #8]
 8014fc6:	601a      	str	r2, [r3, #0]
        /* Return value is length of internal key. */
        ret = (int)dataASN[PKCS8KEYASN_IDX_PKEY_DATA].data.ref.length;
 8014fc8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014fca:	33c4      	adds	r3, #196	@ 0xc4
 8014fcc:	68db      	ldr	r3, [r3, #12]
 8014fce:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8014fd0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014fd2:	2b00      	cmp	r3, #0
 8014fd4:	d007      	beq.n	8014fe6 <ToTraditionalInline_ex2+0x216>
 8014fd6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014fd8:	627b      	str	r3, [r7, #36]	@ 0x24
 8014fda:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014fdc:	2b00      	cmp	r3, #0
 8014fde:	d002      	beq.n	8014fe6 <ToTraditionalInline_ex2+0x216>
 8014fe0:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8014fe2:	f009 fe67 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 8014fe6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif
}
 8014fe8:	4618      	mov	r0, r3
 8014fea:	3740      	adds	r7, #64	@ 0x40
 8014fec:	46bd      	mov	sp, r7
 8014fee:	bd80      	pop	{r7, pc}
 8014ff0:	080345a0 	.word	0x080345a0

08014ff4 <ToTraditionalInline_ex>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
int ToTraditionalInline_ex(const byte* input, word32* inOutIdx, word32 sz,
                           word32* algId)
{
 8014ff4:	b580      	push	{r7, lr}
 8014ff6:	b086      	sub	sp, #24
 8014ff8:	af02      	add	r7, sp, #8
 8014ffa:	60f8      	str	r0, [r7, #12]
 8014ffc:	60b9      	str	r1, [r7, #8]
 8014ffe:	607a      	str	r2, [r7, #4]
 8015000:	603b      	str	r3, [r7, #0]
    return ToTraditionalInline_ex2(input, inOutIdx, sz, algId, NULL);
 8015002:	2300      	movs	r3, #0
 8015004:	9300      	str	r3, [sp, #0]
 8015006:	683b      	ldr	r3, [r7, #0]
 8015008:	687a      	ldr	r2, [r7, #4]
 801500a:	68b9      	ldr	r1, [r7, #8]
 801500c:	68f8      	ldr	r0, [r7, #12]
 801500e:	f7ff fedf 	bl	8014dd0 <ToTraditionalInline_ex2>
 8015012:	4603      	mov	r3, r0
}
 8015014:	4618      	mov	r0, r3
 8015016:	3710      	adds	r7, #16
 8015018:	46bd      	mov	sp, r7
 801501a:	bd80      	pop	{r7, pc}

0801501c <wc_RsaPublicKeyDecode_ex>:
 * @return  ASN_BITSTR_E when the expected BIT_STRING tag is not found.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int wc_RsaPublicKeyDecode_ex(const byte* input, word32* inOutIdx, word32 inSz,
    const byte** n, word32* nSz, const byte** e, word32* eSz)
{
 801501c:	b580      	push	{r7, lr}
 801501e:	b092      	sub	sp, #72	@ 0x48
 8015020:	af04      	add	r7, sp, #16
 8015022:	60f8      	str	r0, [r7, #12]
 8015024:	60b9      	str	r1, [r7, #8]
 8015026:	607a      	str	r2, [r7, #4]
 8015028:	603b      	str	r3, [r7, #0]
        *e = &input[*inOutIdx];
    *inOutIdx += (word32)length;

    return ret;
#else
    DECL_ASNGETDATA(dataASN, rsaPublicKeyASN_Length);
 801502a:	2300      	movs	r3, #0
 801502c:	637b      	str	r3, [r7, #52]	@ 0x34
    int ret = 0;
 801502e:	2300      	movs	r3, #0
 8015030:	633b      	str	r3, [r7, #48]	@ 0x30
#ifdef WC_RSA_PSS
    word32 oid = RSAk;
 8015032:	f240 2385 	movw	r3, #645	@ 0x285
 8015036:	62fb      	str	r3, [r7, #44]	@ 0x2c
#endif

    /* Check validity of parameters. */
    if (input == NULL || inOutIdx == NULL) {
 8015038:	68fb      	ldr	r3, [r7, #12]
 801503a:	2b00      	cmp	r3, #0
 801503c:	d002      	beq.n	8015044 <wc_RsaPublicKeyDecode_ex+0x28>
 801503e:	68bb      	ldr	r3, [r7, #8]
 8015040:	2b00      	cmp	r3, #0
 8015042:	d102      	bne.n	801504a <wc_RsaPublicKeyDecode_ex+0x2e>
        ret = BAD_FUNC_ARG;
 8015044:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8015048:	633b      	str	r3, [r7, #48]	@ 0x30
    }

    CALLOC_ASNGETDATA(dataASN, rsaPublicKeyASN_Length, ret, NULL);
 801504a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801504c:	2b00      	cmp	r3, #0
 801504e:	d109      	bne.n	8015064 <wc_RsaPublicKeyDecode_ex+0x48>
 8015050:	20fc      	movs	r0, #252	@ 0xfc
 8015052:	f009 fe13 	bl	801ec7c <wolfSSL_Malloc>
 8015056:	6378      	str	r0, [r7, #52]	@ 0x34
 8015058:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801505a:	2b00      	cmp	r3, #0
 801505c:	d102      	bne.n	8015064 <wc_RsaPublicKeyDecode_ex+0x48>
 801505e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015062:	633b      	str	r3, [r7, #48]	@ 0x30
 8015064:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015066:	2b00      	cmp	r3, #0
 8015068:	d104      	bne.n	8015074 <wc_RsaPublicKeyDecode_ex+0x58>
 801506a:	22fc      	movs	r2, #252	@ 0xfc
 801506c:	2100      	movs	r1, #0
 801506e:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8015070:	f013 fdd8 	bl	8028c24 <memset>

    if (ret == 0) {
 8015074:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015076:	2b00      	cmp	r3, #0
 8015078:	d122      	bne.n	80150c0 <wc_RsaPublicKeyDecode_ex+0xa4>
        /* Try decoding PKCS #1 public key by ignoring rest of ASN.1. */
        ret = GetASN_Items(&rsaPublicKeyASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_SEQ],
 801507a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801507c:	f103 01a8 	add.w	r1, r3, #168	@ 0xa8
 8015080:	687b      	ldr	r3, [r7, #4]
 8015082:	9302      	str	r3, [sp, #8]
 8015084:	68bb      	ldr	r3, [r7, #8]
 8015086:	9301      	str	r3, [sp, #4]
 8015088:	68fb      	ldr	r3, [r7, #12]
 801508a:	9300      	str	r3, [sp, #0]
 801508c:	2300      	movs	r3, #0
 801508e:	2203      	movs	r2, #3
 8015090:	4851      	ldr	r0, [pc, #324]	@ (80151d8 <wc_RsaPublicKeyDecode_ex+0x1bc>)
 8015092:	f7fe fbed 	bl	8013870 <GetASN_Items>
 8015096:	6338      	str	r0, [r7, #48]	@ 0x30
           &dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_SEQ],
           (int)(rsaPublicKeyASN_Length - RSAPUBLICKEYASN_IDX_PUBKEY_RSA_SEQ),
           0, input, inOutIdx, inSz);
        if (ret != 0) {
 8015098:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801509a:	2b00      	cmp	r3, #0
 801509c:	d010      	beq.n	80150c0 <wc_RsaPublicKeyDecode_ex+0xa4>
            /* Didn't work - try whole SubjectKeyInfo instead. */
        #ifdef WC_RSA_PSS
            /* Could be RSA or RSA PSS key. */
            GetASN_OID(&dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID], oidKeyType);
 801509e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80150a0:	3338      	adds	r3, #56	@ 0x38
 80150a2:	2202      	movs	r2, #2
 80150a4:	611a      	str	r2, [r3, #16]
            /* Set the OID to expect. */
            GetASN_ExpBuffer(&dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID],
                    keyRsaOid, sizeof(keyRsaOid));
        #endif
            /* Decode SubjectKeyInfo. */
            ret = GetASN_Items(rsaPublicKeyASN, dataASN,
 80150a6:	687b      	ldr	r3, [r7, #4]
 80150a8:	9302      	str	r3, [sp, #8]
 80150aa:	68bb      	ldr	r3, [r7, #8]
 80150ac:	9301      	str	r3, [sp, #4]
 80150ae:	68fb      	ldr	r3, [r7, #12]
 80150b0:	9300      	str	r3, [sp, #0]
 80150b2:	2301      	movs	r3, #1
 80150b4:	2209      	movs	r2, #9
 80150b6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80150b8:	4848      	ldr	r0, [pc, #288]	@ (80151dc <wc_RsaPublicKeyDecode_ex+0x1c0>)
 80150ba:	f7fe fbd9 	bl	8013870 <GetASN_Items>
 80150be:	6338      	str	r0, [r7, #48]	@ 0x30
                               rsaPublicKeyASN_Length, 1, input, inOutIdx,
                               inSz);
        }
    }
#ifdef WC_RSA_PSS
    if ((ret == 0) && (dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID].tag != 0)) {
 80150c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80150c2:	2b00      	cmp	r3, #0
 80150c4:	d115      	bne.n	80150f2 <wc_RsaPublicKeyDecode_ex+0xd6>
 80150c6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80150c8:	3338      	adds	r3, #56	@ 0x38
 80150ca:	7e5b      	ldrb	r3, [r3, #25]
 80150cc:	2b00      	cmp	r3, #0
 80150ce:	d010      	beq.n	80150f2 <wc_RsaPublicKeyDecode_ex+0xd6>
        /* Two possible OIDs supported - RSA and RSA PSS. */
        oid = dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID].data.oid.sum;
 80150d0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80150d2:	3338      	adds	r3, #56	@ 0x38
 80150d4:	695b      	ldr	r3, [r3, #20]
 80150d6:	62fb      	str	r3, [r7, #44]	@ 0x2c
        if ((oid != RSAk) && (oid != RSAPSSk)) {
 80150d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80150da:	f240 2285 	movw	r2, #645	@ 0x285
 80150de:	4293      	cmp	r3, r2
 80150e0:	d007      	beq.n	80150f2 <wc_RsaPublicKeyDecode_ex+0xd6>
 80150e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80150e4:	f240 228e 	movw	r2, #654	@ 0x28e
 80150e8:	4293      	cmp	r3, r2
 80150ea:	d002      	beq.n	80150f2 <wc_RsaPublicKeyDecode_ex+0xd6>
            ret = ASN_PARSE_E;
 80150ec:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80150f0:	633b      	str	r3, [r7, #48]	@ 0x30
        }
    }
    if ((ret == 0) && (dataASN[RSAPUBLICKEYASN_IDX_ALGOID_P_SEQ].tag != 0)) {
 80150f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80150f4:	2b00      	cmp	r3, #0
 80150f6:	d13b      	bne.n	8015170 <wc_RsaPublicKeyDecode_ex+0x154>
 80150f8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80150fa:	3370      	adds	r3, #112	@ 0x70
 80150fc:	7e5b      	ldrb	r3, [r3, #25]
 80150fe:	2b00      	cmp	r3, #0
 8015100:	d036      	beq.n	8015170 <wc_RsaPublicKeyDecode_ex+0x154>
        /* Can't have NULL and SEQ. */
        if (dataASN[RSAPUBLICKEYASN_IDX_ALGOID_NULL].tag != 0) {
 8015102:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015104:	3354      	adds	r3, #84	@ 0x54
 8015106:	7e5b      	ldrb	r3, [r3, #25]
 8015108:	2b00      	cmp	r3, #0
 801510a:	d002      	beq.n	8015112 <wc_RsaPublicKeyDecode_ex+0xf6>
            ret = ASN_PARSE_E;
 801510c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015110:	633b      	str	r3, [r7, #48]	@ 0x30
        }
        /* SEQ present only with RSA PSS. */
        if ((ret == 0) && (oid != RSAPSSk)) {
 8015112:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015114:	2b00      	cmp	r3, #0
 8015116:	d107      	bne.n	8015128 <wc_RsaPublicKeyDecode_ex+0x10c>
 8015118:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801511a:	f240 228e 	movw	r2, #654	@ 0x28e
 801511e:	4293      	cmp	r3, r2
 8015120:	d002      	beq.n	8015128 <wc_RsaPublicKeyDecode_ex+0x10c>
            ret = ASN_PARSE_E;
 8015122:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015126:	633b      	str	r3, [r7, #48]	@ 0x30
        }
        if (ret == 0) {
 8015128:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801512a:	2b00      	cmp	r3, #0
 801512c:	d120      	bne.n	8015170 <wc_RsaPublicKeyDecode_ex+0x154>
            enum wc_HashType hash;
            int mgf;
            int saltLen;
            const byte* params = GetASNItem_Addr(
 801512e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015130:	3370      	adds	r3, #112	@ 0x70
 8015132:	681b      	ldr	r3, [r3, #0]
 8015134:	68fa      	ldr	r2, [r7, #12]
 8015136:	4413      	add	r3, r2
 8015138:	62bb      	str	r3, [r7, #40]	@ 0x28
                dataASN[RSAPUBLICKEYASN_IDX_ALGOID_P_SEQ], input);
            word32 paramsSz = GetASNItem_Length(
 801513a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801513c:	3370      	adds	r3, #112	@ 0x70
 801513e:	685b      	ldr	r3, [r3, #4]
 8015140:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8015142:	3270      	adds	r2, #112	@ 0x70
 8015144:	6891      	ldr	r1, [r2, #8]
 8015146:	68fa      	ldr	r2, [r7, #12]
 8015148:	1a8a      	subs	r2, r1, r2
 801514a:	441a      	add	r2, r3
 801514c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801514e:	3370      	adds	r3, #112	@ 0x70
 8015150:	681b      	ldr	r3, [r3, #0]
 8015152:	1ad3      	subs	r3, r2, r3
 8015154:	627b      	str	r3, [r7, #36]	@ 0x24
                dataASN[RSAPUBLICKEYASN_IDX_ALGOID_P_SEQ], input);

            /* Validate the private key parameters. */
            ret = DecodeRsaPssParams(params, paramsSz, &hash, &mgf, &saltLen);
 8015156:	f107 0118 	add.w	r1, r7, #24
 801515a:	f107 021f 	add.w	r2, r7, #31
 801515e:	f107 0314 	add.w	r3, r7, #20
 8015162:	9300      	str	r3, [sp, #0]
 8015164:	460b      	mov	r3, r1
 8015166:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8015168:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801516a:	f7ff fc8b 	bl	8014a84 <DecodeRsaPssParams>
 801516e:	6338      	str	r0, [r7, #48]	@ 0x30
            /* TODO: store parameters so that usage can be checked. */
        }
    }
#endif
    if (ret == 0) {
 8015170:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015172:	2b00      	cmp	r3, #0
 8015174:	d11f      	bne.n	80151b6 <wc_RsaPublicKeyDecode_ex+0x19a>
        /* Return the buffers and lengths asked for. */
        if (n != NULL) {
 8015176:	683b      	ldr	r3, [r7, #0]
 8015178:	2b00      	cmp	r3, #0
 801517a:	d004      	beq.n	8015186 <wc_RsaPublicKeyDecode_ex+0x16a>
            *n   = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_N].data.ref.data;
 801517c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801517e:	33c4      	adds	r3, #196	@ 0xc4
 8015180:	689a      	ldr	r2, [r3, #8]
 8015182:	683b      	ldr	r3, [r7, #0]
 8015184:	601a      	str	r2, [r3, #0]
        }
        if (nSz != NULL) {
 8015186:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015188:	2b00      	cmp	r3, #0
 801518a:	d004      	beq.n	8015196 <wc_RsaPublicKeyDecode_ex+0x17a>
            *nSz = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_N].data.ref.length;
 801518c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801518e:	33c4      	adds	r3, #196	@ 0xc4
 8015190:	68da      	ldr	r2, [r3, #12]
 8015192:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015194:	601a      	str	r2, [r3, #0]
        }
        if (e != NULL) {
 8015196:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015198:	2b00      	cmp	r3, #0
 801519a:	d004      	beq.n	80151a6 <wc_RsaPublicKeyDecode_ex+0x18a>
            *e   = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_E].data.ref.data;
 801519c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801519e:	33e0      	adds	r3, #224	@ 0xe0
 80151a0:	689a      	ldr	r2, [r3, #8]
 80151a2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80151a4:	601a      	str	r2, [r3, #0]
        }
        if (eSz != NULL) {
 80151a6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80151a8:	2b00      	cmp	r3, #0
 80151aa:	d004      	beq.n	80151b6 <wc_RsaPublicKeyDecode_ex+0x19a>
            *eSz = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_E].data.ref.length;
 80151ac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80151ae:	33e0      	adds	r3, #224	@ 0xe0
 80151b0:	68da      	ldr	r2, [r3, #12]
 80151b2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80151b4:	601a      	str	r2, [r3, #0]
        }
    }

    FREE_ASNGETDATA(dataASN, NULL);
 80151b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80151b8:	2b00      	cmp	r3, #0
 80151ba:	d007      	beq.n	80151cc <wc_RsaPublicKeyDecode_ex+0x1b0>
 80151bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80151be:	623b      	str	r3, [r7, #32]
 80151c0:	6a3b      	ldr	r3, [r7, #32]
 80151c2:	2b00      	cmp	r3, #0
 80151c4:	d002      	beq.n	80151cc <wc_RsaPublicKeyDecode_ex+0x1b0>
 80151c6:	6a38      	ldr	r0, [r7, #32]
 80151c8:	f009 fd74 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 80151cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 80151ce:	4618      	mov	r0, r3
 80151d0:	3738      	adds	r7, #56	@ 0x38
 80151d2:	46bd      	mov	sp, r7
 80151d4:	bd80      	pop	{r7, pc}
 80151d6:	bf00      	nop
 80151d8:	080345dc 	.word	0x080345dc
 80151dc:	080345c4 	.word	0x080345c4

080151e0 <wc_RsaPublicKeyDecode>:
 * @return  ASN_BITSTR_E when the expected BIT_STRING tag is not found.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int wc_RsaPublicKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,
                       word32 inSz)
{
 80151e0:	b590      	push	{r4, r7, lr}
 80151e2:	b08f      	sub	sp, #60	@ 0x3c
 80151e4:	af04      	add	r7, sp, #16
 80151e6:	60f8      	str	r0, [r7, #12]
 80151e8:	60b9      	str	r1, [r7, #8]
 80151ea:	607a      	str	r2, [r7, #4]
 80151ec:	603b      	str	r3, [r7, #0]
    int ret;
    const byte *n = NULL, *e = NULL;
 80151ee:	2300      	movs	r3, #0
 80151f0:	623b      	str	r3, [r7, #32]
 80151f2:	2300      	movs	r3, #0
 80151f4:	61fb      	str	r3, [r7, #28]
    word32 nSz = 0, eSz = 0;
 80151f6:	2300      	movs	r3, #0
 80151f8:	61bb      	str	r3, [r7, #24]
 80151fa:	2300      	movs	r3, #0
 80151fc:	617b      	str	r3, [r7, #20]

    if (key == NULL)
 80151fe:	687b      	ldr	r3, [r7, #4]
 8015200:	2b00      	cmp	r3, #0
 8015202:	d102      	bne.n	801520a <wc_RsaPublicKeyDecode+0x2a>
        return BAD_FUNC_ARG;
 8015204:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8015208:	e01f      	b.n	801524a <wc_RsaPublicKeyDecode+0x6a>

    ret = wc_RsaPublicKeyDecode_ex(input, inOutIdx, inSz, &n, &nSz, &e, &eSz);
 801520a:	f107 0220 	add.w	r2, r7, #32
 801520e:	f107 0314 	add.w	r3, r7, #20
 8015212:	9302      	str	r3, [sp, #8]
 8015214:	f107 031c 	add.w	r3, r7, #28
 8015218:	9301      	str	r3, [sp, #4]
 801521a:	f107 0318 	add.w	r3, r7, #24
 801521e:	9300      	str	r3, [sp, #0]
 8015220:	4613      	mov	r3, r2
 8015222:	683a      	ldr	r2, [r7, #0]
 8015224:	68b9      	ldr	r1, [r7, #8]
 8015226:	68f8      	ldr	r0, [r7, #12]
 8015228:	f7ff fef8 	bl	801501c <wc_RsaPublicKeyDecode_ex>
 801522c:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret == 0) {
 801522e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015230:	2b00      	cmp	r3, #0
 8015232:	d109      	bne.n	8015248 <wc_RsaPublicKeyDecode+0x68>
        ret = wc_RsaPublicKeyDecodeRaw(n, nSz, e, eSz, key);
 8015234:	6a38      	ldr	r0, [r7, #32]
 8015236:	69b9      	ldr	r1, [r7, #24]
 8015238:	69fa      	ldr	r2, [r7, #28]
 801523a:	697c      	ldr	r4, [r7, #20]
 801523c:	687b      	ldr	r3, [r7, #4]
 801523e:	9300      	str	r3, [sp, #0]
 8015240:	4623      	mov	r3, r4
 8015242:	f005 f813 	bl	801a26c <wc_RsaPublicKeyDecodeRaw>
 8015246:	6278      	str	r0, [r7, #36]	@ 0x24
    }

    return ret;
 8015248:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 801524a:	4618      	mov	r0, r3
 801524c:	372c      	adds	r7, #44	@ 0x2c
 801524e:	46bd      	mov	sp, r7
 8015250:	bd90      	pop	{r4, r7, pc}

08015252 <InitDecodedCert>:
 * @param [in]      inSz    Size of DER data in buffer in bytes.
 * @param [in]      heap    Dynamic memory hint.
 */
void InitDecodedCert(DecodedCert* cert,
                     const byte* source, word32 inSz, void* heap)
{
 8015252:	b580      	push	{r7, lr}
 8015254:	b086      	sub	sp, #24
 8015256:	af02      	add	r7, sp, #8
 8015258:	60f8      	str	r0, [r7, #12]
 801525a:	60b9      	str	r1, [r7, #8]
 801525c:	607a      	str	r2, [r7, #4]
 801525e:	603b      	str	r3, [r7, #0]
    InitDecodedCert_ex(cert, source, inSz, heap, INVALID_DEVID);
 8015260:	f06f 0301 	mvn.w	r3, #1
 8015264:	9300      	str	r3, [sp, #0]
 8015266:	683b      	ldr	r3, [r7, #0]
 8015268:	687a      	ldr	r2, [r7, #4]
 801526a:	68b9      	ldr	r1, [r7, #8]
 801526c:	68f8      	ldr	r0, [r7, #12]
 801526e:	f000 f804 	bl	801527a <InitDecodedCert_ex>
}
 8015272:	bf00      	nop
 8015274:	3710      	adds	r7, #16
 8015276:	46bd      	mov	sp, r7
 8015278:	bd80      	pop	{r7, pc}

0801527a <InitDecodedCert_ex>:
 * @param [in]      heap    Dynamic memory hint.
 * @param [in]      devId   Crypto callback ID to use.
 */
void InitDecodedCert_ex(DecodedCert* cert,
                     const byte* source, word32 inSz, void* heap, int devId)
{
 801527a:	b580      	push	{r7, lr}
 801527c:	b084      	sub	sp, #16
 801527e:	af00      	add	r7, sp, #0
 8015280:	60f8      	str	r0, [r7, #12]
 8015282:	60b9      	str	r1, [r7, #8]
 8015284:	607a      	str	r2, [r7, #4]
 8015286:	603b      	str	r3, [r7, #0]
    if (cert != NULL) {
 8015288:	68fb      	ldr	r3, [r7, #12]
 801528a:	2b00      	cmp	r3, #0
 801528c:	d029      	beq.n	80152e2 <InitDecodedCert_ex+0x68>
        XMEMSET(cert, 0, sizeof(DecodedCert));
 801528e:	f44f 6297 	mov.w	r2, #1208	@ 0x4b8
 8015292:	2100      	movs	r1, #0
 8015294:	68f8      	ldr	r0, [r7, #12]
 8015296:	f013 fcc5 	bl	8028c24 <memset>

        cert->subjectCNEnc    = CTC_UTF8;
 801529a:	68fb      	ldr	r3, [r7, #12]
 801529c:	220c      	movs	r2, #12
 801529e:	f883 208c 	strb.w	r2, [r3, #140]	@ 0x8c
        cert->issuer[0]       = '\0';
 80152a2:	68fb      	ldr	r3, [r7, #12]
 80152a4:	2200      	movs	r2, #0
 80152a6:	f883 208d 	strb.w	r2, [r3, #141]	@ 0x8d
        cert->subject[0]      = '\0';
 80152aa:	68fb      	ldr	r3, [r7, #12]
 80152ac:	2200      	movs	r2, #0
 80152ae:	f883 21f5 	strb.w	r2, [r3, #501]	@ 0x1f5
        cert->source          = source;  /* don't own */
 80152b2:	68fb      	ldr	r3, [r7, #12]
 80152b4:	68ba      	ldr	r2, [r7, #8]
 80152b6:	f8c3 2364 	str.w	r2, [r3, #868]	@ 0x364
        cert->maxIdx          = inSz;    /* can't go over this index */
 80152ba:	68fb      	ldr	r3, [r7, #12]
 80152bc:	687a      	ldr	r2, [r7, #4]
 80152be:	f8c3 236c 	str.w	r2, [r3, #876]	@ 0x36c
        cert->heap            = heap;
 80152c2:	68fb      	ldr	r3, [r7, #12]
 80152c4:	683a      	ldr	r2, [r7, #0]
 80152c6:	f8c3 2370 	str.w	r2, [r3, #880]	@ 0x370
        cert->maxPathLen      = WOLFSSL_MAX_PATH_LEN;
 80152ca:	68fb      	ldr	r3, [r7, #12]
 80152cc:	227f      	movs	r2, #127	@ 0x7f
 80152ce:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d
        cert->issuerOEnc     = CTC_UTF8;
        cert->issuerOUEnc    = CTC_UTF8;
    #endif /* WOLFSSL_HAVE_ISSUER_NAMES */
    #endif /* WOLFSSL_CERT_GEN || WOLFSSL_CERT_EXT */

        InitSignatureCtx(&cert->sigCtx, heap, devId);
 80152d2:	68fb      	ldr	r3, [r7, #12]
 80152d4:	f203 4374 	addw	r3, r3, #1140	@ 0x474
 80152d8:	69ba      	ldr	r2, [r7, #24]
 80152da:	6839      	ldr	r1, [r7, #0]
 80152dc:	4618      	mov	r0, r3
 80152de:	f000 ff6b 	bl	80161b8 <InitSignatureCtx>
    }
}
 80152e2:	bf00      	nop
 80152e4:	3710      	adds	r7, #16
 80152e6:	46bd      	mov	sp, r7
 80152e8:	bd80      	pop	{r7, pc}

080152ea <FreeAltNames>:
 *
 * @param [in, out] altNames  Alternative names.
 * @param [in]      heap      Dynamic memory hint.
 */
void FreeAltNames(DNS_entry* altNames, void* heap)
{
 80152ea:	b580      	push	{r7, lr}
 80152ec:	b086      	sub	sp, #24
 80152ee:	af00      	add	r7, sp, #0
 80152f0:	6078      	str	r0, [r7, #4]
 80152f2:	6039      	str	r1, [r7, #0]
    (void)heap;

    while (altNames) {
 80152f4:	e015      	b.n	8015322 <FreeAltNames+0x38>
        DNS_entry* tmp = altNames->next;
 80152f6:	687b      	ldr	r3, [r7, #4]
 80152f8:	681b      	ldr	r3, [r3, #0]
 80152fa:	617b      	str	r3, [r7, #20]

        XFREE(altNames->name, heap, DYNAMIC_TYPE_ALTNAME);
 80152fc:	687b      	ldr	r3, [r7, #4]
 80152fe:	68db      	ldr	r3, [r3, #12]
 8015300:	613b      	str	r3, [r7, #16]
 8015302:	693b      	ldr	r3, [r7, #16]
 8015304:	2b00      	cmp	r3, #0
 8015306:	d002      	beq.n	801530e <FreeAltNames+0x24>
 8015308:	6938      	ldr	r0, [r7, #16]
 801530a:	f009 fcd3 	bl	801ecb4 <wolfSSL_Free>
        XFREE(altNames->ipString, heap, DYNAMIC_TYPE_ALTNAME);
    #endif
    #ifdef WOLFSSL_RID_ALT_NAME
        XFREE(altNames->ridString, heap, DYNAMIC_TYPE_ALTNAME);
    #endif
        XFREE(altNames,       heap, DYNAMIC_TYPE_ALTNAME);
 801530e:	687b      	ldr	r3, [r7, #4]
 8015310:	60fb      	str	r3, [r7, #12]
 8015312:	68fb      	ldr	r3, [r7, #12]
 8015314:	2b00      	cmp	r3, #0
 8015316:	d002      	beq.n	801531e <FreeAltNames+0x34>
 8015318:	68f8      	ldr	r0, [r7, #12]
 801531a:	f009 fccb 	bl	801ecb4 <wolfSSL_Free>
        altNames = tmp;
 801531e:	697b      	ldr	r3, [r7, #20]
 8015320:	607b      	str	r3, [r7, #4]
    while (altNames) {
 8015322:	687b      	ldr	r3, [r7, #4]
 8015324:	2b00      	cmp	r3, #0
 8015326:	d1e6      	bne.n	80152f6 <FreeAltNames+0xc>
    }
}
 8015328:	bf00      	nop
 801532a:	bf00      	nop
 801532c:	3718      	adds	r7, #24
 801532e:	46bd      	mov	sp, r7
 8015330:	bd80      	pop	{r7, pc}

08015332 <AltNameNew>:

/* malloc and initialize a new alt name structure */
DNS_entry* AltNameNew(void* heap)
{
 8015332:	b580      	push	{r7, lr}
 8015334:	b084      	sub	sp, #16
 8015336:	af00      	add	r7, sp, #0
 8015338:	6078      	str	r0, [r7, #4]
    DNS_entry* ret;
    ret = (DNS_entry*)XMALLOC(sizeof(DNS_entry), heap, DYNAMIC_TYPE_ALTNAME);
 801533a:	2010      	movs	r0, #16
 801533c:	f009 fc9e 	bl	801ec7c <wolfSSL_Malloc>
 8015340:	60f8      	str	r0, [r7, #12]
    if (ret != NULL) {
 8015342:	68fb      	ldr	r3, [r7, #12]
 8015344:	2b00      	cmp	r3, #0
 8015346:	d004      	beq.n	8015352 <AltNameNew+0x20>
        XMEMSET(ret, 0, sizeof(DNS_entry));
 8015348:	2210      	movs	r2, #16
 801534a:	2100      	movs	r1, #0
 801534c:	68f8      	ldr	r0, [r7, #12]
 801534e:	f013 fc69 	bl	8028c24 <memset>
    }
    (void)heap;
    return ret;
 8015352:	68fb      	ldr	r3, [r7, #12]
}
 8015354:	4618      	mov	r0, r3
 8015356:	3710      	adds	r7, #16
 8015358:	46bd      	mov	sp, r7
 801535a:	bd80      	pop	{r7, pc}

0801535c <AltNameDup>:

DNS_entry* AltNameDup(DNS_entry* from, void* heap)
{
 801535c:	b580      	push	{r7, lr}
 801535e:	b084      	sub	sp, #16
 8015360:	af00      	add	r7, sp, #0
 8015362:	6078      	str	r0, [r7, #4]
 8015364:	6039      	str	r1, [r7, #0]
    DNS_entry* ret;

    ret = AltNameNew(heap);
 8015366:	6838      	ldr	r0, [r7, #0]
 8015368:	f7ff ffe3 	bl	8015332 <AltNameNew>
 801536c:	60f8      	str	r0, [r7, #12]
    if (ret == NULL) {
 801536e:	68fb      	ldr	r3, [r7, #12]
 8015370:	2b00      	cmp	r3, #0
 8015372:	d101      	bne.n	8015378 <AltNameDup+0x1c>
        WOLFSSL_MSG("\tOut of Memory");
        return NULL;
 8015374:	2300      	movs	r3, #0
 8015376:	e01d      	b.n	80153b4 <AltNameDup+0x58>
    }

    ret->type = from->type;
 8015378:	687b      	ldr	r3, [r7, #4]
 801537a:	685a      	ldr	r2, [r3, #4]
 801537c:	68fb      	ldr	r3, [r7, #12]
 801537e:	605a      	str	r2, [r3, #4]
    ret->len = from->len;
 8015380:	687b      	ldr	r3, [r7, #4]
 8015382:	689a      	ldr	r2, [r3, #8]
 8015384:	68fb      	ldr	r3, [r7, #12]
 8015386:	609a      	str	r2, [r3, #8]


    ret->name = CopyString(from->name, from->len, heap, DYNAMIC_TYPE_ALTNAME);
 8015388:	687b      	ldr	r3, [r7, #4]
 801538a:	68d8      	ldr	r0, [r3, #12]
 801538c:	687b      	ldr	r3, [r7, #4]
 801538e:	6899      	ldr	r1, [r3, #8]
 8015390:	231d      	movs	r3, #29
 8015392:	683a      	ldr	r2, [r7, #0]
 8015394:	f7fd fa5e 	bl	8012854 <CopyString>
 8015398:	4602      	mov	r2, r0
 801539a:	68fb      	ldr	r3, [r7, #12]
 801539c:	60da      	str	r2, [r3, #12]
    ret->ipString = CopyString(from->ipString, 0, heap, DYNAMIC_TYPE_ALTNAME);
#endif
#ifdef WOLFSSL_RID_ALT_NAME
    ret->ridString = CopyString(from->ridString, 0, heap, DYNAMIC_TYPE_ALTNAME);
#endif
    if (ret->name == NULL
 801539e:	68fb      	ldr	r3, [r7, #12]
 80153a0:	68db      	ldr	r3, [r3, #12]
 80153a2:	2b00      	cmp	r3, #0
 80153a4:	d105      	bne.n	80153b2 <AltNameDup+0x56>
#ifdef WOLFSSL_RID_ALT_NAME
            || (from->ridString != NULL && ret->ridString == NULL)
#endif
            ) {
        WOLFSSL_MSG("\tOut of Memory");
        FreeAltNames(ret, heap);
 80153a6:	6839      	ldr	r1, [r7, #0]
 80153a8:	68f8      	ldr	r0, [r7, #12]
 80153aa:	f7ff ff9e 	bl	80152ea <FreeAltNames>
        return NULL;
 80153ae:	2300      	movs	r3, #0
 80153b0:	e000      	b.n	80153b4 <AltNameDup+0x58>

#ifdef WOLFSSL_FPKI
    ret->oidSum = from->oidSum;
#endif

    return ret;
 80153b2:	68fb      	ldr	r3, [r7, #12]
}
 80153b4:	4618      	mov	r0, r3
 80153b6:	3710      	adds	r7, #16
 80153b8:	46bd      	mov	sp, r7
 80153ba:	bd80      	pop	{r7, pc}

080153bc <FreeNameSubtrees>:
 *
 * @param [in, out] names  Subtree names.
 * @param [in]      heap   Dynamic memory hint.
 */
void FreeNameSubtrees(Base_entry* names, void* heap)
{
 80153bc:	b580      	push	{r7, lr}
 80153be:	b086      	sub	sp, #24
 80153c0:	af00      	add	r7, sp, #0
 80153c2:	6078      	str	r0, [r7, #4]
 80153c4:	6039      	str	r1, [r7, #0]
    (void)heap;

    while (names) {
 80153c6:	e015      	b.n	80153f4 <FreeNameSubtrees+0x38>
        Base_entry* tmp = names->next;
 80153c8:	687b      	ldr	r3, [r7, #4]
 80153ca:	681b      	ldr	r3, [r3, #0]
 80153cc:	617b      	str	r3, [r7, #20]

        XFREE(names->name, heap, DYNAMIC_TYPE_ALTNAME);
 80153ce:	687b      	ldr	r3, [r7, #4]
 80153d0:	685b      	ldr	r3, [r3, #4]
 80153d2:	613b      	str	r3, [r7, #16]
 80153d4:	693b      	ldr	r3, [r7, #16]
 80153d6:	2b00      	cmp	r3, #0
 80153d8:	d002      	beq.n	80153e0 <FreeNameSubtrees+0x24>
 80153da:	6938      	ldr	r0, [r7, #16]
 80153dc:	f009 fc6a 	bl	801ecb4 <wolfSSL_Free>
        XFREE(names,       heap, DYNAMIC_TYPE_ALTNAME);
 80153e0:	687b      	ldr	r3, [r7, #4]
 80153e2:	60fb      	str	r3, [r7, #12]
 80153e4:	68fb      	ldr	r3, [r7, #12]
 80153e6:	2b00      	cmp	r3, #0
 80153e8:	d002      	beq.n	80153f0 <FreeNameSubtrees+0x34>
 80153ea:	68f8      	ldr	r0, [r7, #12]
 80153ec:	f009 fc62 	bl	801ecb4 <wolfSSL_Free>
        names = tmp;
 80153f0:	697b      	ldr	r3, [r7, #20]
 80153f2:	607b      	str	r3, [r7, #4]
    while (names) {
 80153f4:	687b      	ldr	r3, [r7, #4]
 80153f6:	2b00      	cmp	r3, #0
 80153f8:	d1e6      	bne.n	80153c8 <FreeNameSubtrees+0xc>
    }
}
 80153fa:	bf00      	nop
 80153fc:	bf00      	nop
 80153fe:	3718      	adds	r7, #24
 8015400:	46bd      	mov	sp, r7
 8015402:	bd80      	pop	{r7, pc}

08015404 <FreeDecodedCert>:
/* Free the decoded cert object's dynamic data.
 *
 * @param [in, out] cert  Decoded certificate object.
 */
void FreeDecodedCert(DecodedCert* cert)
{
 8015404:	b580      	push	{r7, lr}
 8015406:	b084      	sub	sp, #16
 8015408:	af00      	add	r7, sp, #0
 801540a:	6078      	str	r0, [r7, #4]
    if (cert == NULL)
 801540c:	687b      	ldr	r3, [r7, #4]
 801540e:	2b00      	cmp	r3, #0
 8015410:	f000 8085 	beq.w	801551e <FreeDecodedCert+0x11a>
        return;
    if (cert->subjectCNStored == 1) {
 8015414:	687b      	ldr	r3, [r7, #4]
 8015416:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 801541a:	f003 0301 	and.w	r3, r3, #1
 801541e:	b2db      	uxtb	r3, r3
 8015420:	2b00      	cmp	r3, #0
 8015422:	d009      	beq.n	8015438 <FreeDecodedCert+0x34>
        XFREE(cert->subjectCN, cert->heap, DYNAMIC_TYPE_SUBJECT_CN);
 8015424:	687b      	ldr	r3, [r7, #4]
 8015426:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 801542a:	60fb      	str	r3, [r7, #12]
 801542c:	68fb      	ldr	r3, [r7, #12]
 801542e:	2b00      	cmp	r3, #0
 8015430:	d002      	beq.n	8015438 <FreeDecodedCert+0x34>
 8015432:	68f8      	ldr	r0, [r7, #12]
 8015434:	f009 fc3e 	bl	801ecb4 <wolfSSL_Free>
    }
    if (cert->pubKeyStored == 1) {
 8015438:	687b      	ldr	r3, [r7, #4]
 801543a:	689b      	ldr	r3, [r3, #8]
 801543c:	2b01      	cmp	r3, #1
 801543e:	d108      	bne.n	8015452 <FreeDecodedCert+0x4e>
        XFREE((void*)cert->publicKey, cert->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8015440:	687b      	ldr	r3, [r7, #4]
 8015442:	681b      	ldr	r3, [r3, #0]
 8015444:	60bb      	str	r3, [r7, #8]
 8015446:	68bb      	ldr	r3, [r7, #8]
 8015448:	2b00      	cmp	r3, #0
 801544a:	d002      	beq.n	8015452 <FreeDecodedCert+0x4e>
 801544c:	68b8      	ldr	r0, [r7, #8]
 801544e:	f009 fc31 	bl	801ecb4 <wolfSSL_Free>
    }
    if (cert->weOwnAltNames && cert->altNames)
 8015452:	687b      	ldr	r3, [r7, #4]
 8015454:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8015458:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801545c:	b2db      	uxtb	r3, r3
 801545e:	2b00      	cmp	r3, #0
 8015460:	d00c      	beq.n	801547c <FreeDecodedCert+0x78>
 8015462:	687b      	ldr	r3, [r7, #4]
 8015464:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8015466:	2b00      	cmp	r3, #0
 8015468:	d008      	beq.n	801547c <FreeDecodedCert+0x78>
        FreeAltNames(cert->altNames, cert->heap);
 801546a:	687b      	ldr	r3, [r7, #4]
 801546c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 801546e:	687b      	ldr	r3, [r7, #4]
 8015470:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8015474:	4619      	mov	r1, r3
 8015476:	4610      	mov	r0, r2
 8015478:	f7ff ff37 	bl	80152ea <FreeAltNames>
#ifndef IGNORE_NAME_CONSTRAINTS
    if (cert->altEmailNames)
 801547c:	687b      	ldr	r3, [r7, #4]
 801547e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8015480:	2b00      	cmp	r3, #0
 8015482:	d008      	beq.n	8015496 <FreeDecodedCert+0x92>
        FreeAltNames(cert->altEmailNames, cert->heap);
 8015484:	687b      	ldr	r3, [r7, #4]
 8015486:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8015488:	687b      	ldr	r3, [r7, #4]
 801548a:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 801548e:	4619      	mov	r1, r3
 8015490:	4610      	mov	r0, r2
 8015492:	f7ff ff2a 	bl	80152ea <FreeAltNames>
    if (cert->altDirNames)
 8015496:	687b      	ldr	r3, [r7, #4]
 8015498:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801549a:	2b00      	cmp	r3, #0
 801549c:	d008      	beq.n	80154b0 <FreeDecodedCert+0xac>
        FreeAltNames(cert->altDirNames, cert->heap);
 801549e:	687b      	ldr	r3, [r7, #4]
 80154a0:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80154a2:	687b      	ldr	r3, [r7, #4]
 80154a4:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 80154a8:	4619      	mov	r1, r3
 80154aa:	4610      	mov	r0, r2
 80154ac:	f7ff ff1d 	bl	80152ea <FreeAltNames>
    if (cert->permittedNames)
 80154b0:	687b      	ldr	r3, [r7, #4]
 80154b2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80154b4:	2b00      	cmp	r3, #0
 80154b6:	d008      	beq.n	80154ca <FreeDecodedCert+0xc6>
        FreeNameSubtrees(cert->permittedNames, cert->heap);
 80154b8:	687b      	ldr	r3, [r7, #4]
 80154ba:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 80154bc:	687b      	ldr	r3, [r7, #4]
 80154be:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 80154c2:	4619      	mov	r1, r3
 80154c4:	4610      	mov	r0, r2
 80154c6:	f7ff ff79 	bl	80153bc <FreeNameSubtrees>
    if (cert->excludedNames)
 80154ca:	687b      	ldr	r3, [r7, #4]
 80154cc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80154ce:	2b00      	cmp	r3, #0
 80154d0:	d008      	beq.n	80154e4 <FreeDecodedCert+0xe0>
        FreeNameSubtrees(cert->excludedNames, cert->heap);
 80154d2:	687b      	ldr	r3, [r7, #4]
 80154d4:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 80154d6:	687b      	ldr	r3, [r7, #4]
 80154d8:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 80154dc:	4619      	mov	r1, r3
 80154de:	4610      	mov	r0, r2
 80154e0:	f7ff ff6c 	bl	80153bc <FreeNameSubtrees>
    XFREE(cert->deviceType, cert->heap, DYNAMIC_TYPE_X509_EXT);
    XFREE(cert->hwType, cert->heap, DYNAMIC_TYPE_X509_EXT);
    XFREE(cert->hwSerialNum, cert->heap, DYNAMIC_TYPE_X509_EXT);
#endif /* WOLFSSL_SEP */
#ifdef WOLFSSL_X509_NAME_AVAILABLE
    if (cert->issuerName != NULL)
 80154e4:	687b      	ldr	r3, [r7, #4]
 80154e6:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
 80154ea:	2b00      	cmp	r3, #0
 80154ec:	d005      	beq.n	80154fa <FreeDecodedCert+0xf6>
        wolfSSL_X509_NAME_free((WOLFSSL_X509_NAME*)cert->issuerName);
 80154ee:	687b      	ldr	r3, [r7, #4]
 80154f0:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
 80154f4:	4618      	mov	r0, r3
 80154f6:	f7f9 f8f6 	bl	800e6e6 <wolfSSL_X509_NAME_free>
    if (cert->subjectName != NULL)
 80154fa:	687b      	ldr	r3, [r7, #4]
 80154fc:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
 8015500:	2b00      	cmp	r3, #0
 8015502:	d005      	beq.n	8015510 <FreeDecodedCert+0x10c>
        wolfSSL_X509_NAME_free((WOLFSSL_X509_NAME*)cert->subjectName);
 8015504:	687b      	ldr	r3, [r7, #4]
 8015506:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
 801550a:	4618      	mov	r0, r3
 801550c:	f7f9 f8eb 	bl	800e6e6 <wolfSSL_X509_NAME_free>
#endif /* WOLFSSL_X509_NAME_AVAILABLE */
#if defined(WOLFSSL_RENESAS_TSIP_TLS) || defined(WOLFSSL_RENESAS_FSPSM_TLS)
    XFREE(cert->sce_tsip_encRsaKeyIdx, cert->heap, DYNAMIC_TYPE_RSA);
#endif
    FreeSignatureCtx(&cert->sigCtx);
 8015510:	687b      	ldr	r3, [r7, #4]
 8015512:	f203 4374 	addw	r3, r3, #1140	@ 0x474
 8015516:	4618      	mov	r0, r3
 8015518:	f000 fe66 	bl	80161e8 <FreeSignatureCtx>
 801551c:	e000      	b.n	8015520 <FreeDecodedCert+0x11c>
        return;
 801551e:	bf00      	nop
}
 8015520:	3710      	adds	r7, #16
 8015522:	46bd      	mov	sp, r7
 8015524:	bd80      	pop	{r7, pc}
	...

08015528 <StoreRsaKey>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
static int StoreRsaKey(DecodedCert* cert, const byte* source, word32* srcIdx,
                       word32 maxIdx)
{
 8015528:	b580      	push	{r7, lr}
 801552a:	b098      	sub	sp, #96	@ 0x60
 801552c:	af04      	add	r7, sp, #16
 801552e:	60f8      	str	r0, [r7, #12]
 8015530:	60b9      	str	r1, [r7, #8]
 8015532:	607a      	str	r2, [r7, #4]
 8015534:	603b      	str	r3, [r7, #0]
#else
    ASNGetData dataASN[rsaCertKeyASN_Length];
    int ret;

    /* No dynamic data. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 8015536:	f107 0314 	add.w	r3, r7, #20
 801553a:	2238      	movs	r2, #56	@ 0x38
 801553c:	2100      	movs	r1, #0
 801553e:	4618      	mov	r0, r3
 8015540:	f013 fb70 	bl	8028c24 <memset>
    /* Decode the header before the key data. */
    ret = GetASN_Items(rsaCertKeyASN, dataASN, rsaCertKeyASN_Length, 1, source,
 8015544:	f107 0114 	add.w	r1, r7, #20
 8015548:	683b      	ldr	r3, [r7, #0]
 801554a:	9302      	str	r3, [sp, #8]
 801554c:	687b      	ldr	r3, [r7, #4]
 801554e:	9301      	str	r3, [sp, #4]
 8015550:	68bb      	ldr	r3, [r7, #8]
 8015552:	9300      	str	r3, [sp, #0]
 8015554:	2301      	movs	r3, #1
 8015556:	2202      	movs	r2, #2
 8015558:	4808      	ldr	r0, [pc, #32]	@ (801557c <StoreRsaKey+0x54>)
 801555a:	f7fe f989 	bl	8013870 <GetASN_Items>
 801555e:	64f8      	str	r0, [r7, #76]	@ 0x4c
                       srcIdx, maxIdx);
    if (ret == 0) {
 8015560:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8015562:	2b00      	cmp	r3, #0
 8015564:	d105      	bne.n	8015572 <StoreRsaKey+0x4a>
        /* Store the pointer and length in certificate object starting at
         * SEQUENCE. */
        GetASN_GetConstRef(&dataASN[RSACERTKEYASN_IDX_STR],
 8015566:	69fa      	ldr	r2, [r7, #28]
 8015568:	68fb      	ldr	r3, [r7, #12]
 801556a:	601a      	str	r2, [r3, #0]
 801556c:	6a3a      	ldr	r2, [r7, #32]
 801556e:	68fb      	ldr	r3, [r7, #12]
 8015570:	605a      	str	r2, [r3, #4]
        ret = CalcHashId_ex(cert->publicKey, cert->pubKeySize,
                         cert->subjectKeyHash, HashIdAlg(cert->signatureOID));
    #endif
    }

    return ret;
 8015572:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015574:	4618      	mov	r0, r3
 8015576:	3750      	adds	r7, #80	@ 0x50
 8015578:	46bd      	mov	sp, r7
 801557a:	bd80      	pop	{r7, pc}
 801557c:	08034600 	.word	0x08034600

08015580 <StoreEccKey>:
 *          non-zero length.
 * @return  ASN_OBJECT_ID_E when the expected OBJECT_ID tag is not found.
 */
static int StoreEccKey(DecodedCert* cert, const byte* source, word32* srcIdx,
                       word32 maxIdx, const byte* pubKey, word32 pubKeyLen)
{
 8015580:	b580      	push	{r7, lr}
 8015582:	b08c      	sub	sp, #48	@ 0x30
 8015584:	af04      	add	r7, sp, #16
 8015586:	60f8      	str	r0, [r7, #12]
 8015588:	60b9      	str	r1, [r7, #8]
 801558a:	607a      	str	r2, [r7, #4]
 801558c:	603b      	str	r3, [r7, #0]
    cert->pubKeyStored = 1;
    cert->pubKeySize   = pubKeyLen;

    return 0;
#else
    int ret = 0;
 801558e:	2300      	movs	r3, #0
 8015590:	61fb      	str	r3, [r7, #28]
    DECL_ASNGETDATA(dataASN, eccCertKeyASN_Length);
 8015592:	2300      	movs	r3, #0
 8015594:	61bb      	str	r3, [r7, #24]
    byte* publicKey;

    /* Validate parameters. */
    if (pubKey == NULL) {
 8015596:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015598:	2b00      	cmp	r3, #0
 801559a:	d102      	bne.n	80155a2 <StoreEccKey+0x22>
        ret = BAD_FUNC_ARG;
 801559c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80155a0:	61fb      	str	r3, [r7, #28]
    }

    /* Clear dynamic data and check OID is a curve. */
    CALLOC_ASNGETDATA(dataASN, eccCertKeyASN_Length, ret, cert->heap);
 80155a2:	69fb      	ldr	r3, [r7, #28]
 80155a4:	2b00      	cmp	r3, #0
 80155a6:	d109      	bne.n	80155bc <StoreEccKey+0x3c>
 80155a8:	2054      	movs	r0, #84	@ 0x54
 80155aa:	f009 fb67 	bl	801ec7c <wolfSSL_Malloc>
 80155ae:	61b8      	str	r0, [r7, #24]
 80155b0:	69bb      	ldr	r3, [r7, #24]
 80155b2:	2b00      	cmp	r3, #0
 80155b4:	d102      	bne.n	80155bc <StoreEccKey+0x3c>
 80155b6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80155ba:	61fb      	str	r3, [r7, #28]
 80155bc:	69fb      	ldr	r3, [r7, #28]
 80155be:	2b00      	cmp	r3, #0
 80155c0:	d104      	bne.n	80155cc <StoreEccKey+0x4c>
 80155c2:	2254      	movs	r2, #84	@ 0x54
 80155c4:	2100      	movs	r1, #0
 80155c6:	69b8      	ldr	r0, [r7, #24]
 80155c8:	f013 fb2c 	bl	8028c24 <memset>
    if (ret == 0) {
 80155cc:	69fb      	ldr	r3, [r7, #28]
 80155ce:	2b00      	cmp	r3, #0
 80155d0:	d10f      	bne.n	80155f2 <StoreEccKey+0x72>
        GetASN_OID(&dataASN[ECCCERTKEYASN_IDX_OID], oidCurveType);
 80155d2:	69bb      	ldr	r3, [r7, #24]
 80155d4:	2203      	movs	r2, #3
 80155d6:	611a      	str	r2, [r3, #16]
        /* Parse ECC public key header. */
        ret = GetASN_Items(eccCertKeyASN, dataASN, eccCertKeyASN_Length, 1,
 80155d8:	683b      	ldr	r3, [r7, #0]
 80155da:	9302      	str	r3, [sp, #8]
 80155dc:	687b      	ldr	r3, [r7, #4]
 80155de:	9301      	str	r3, [sp, #4]
 80155e0:	68bb      	ldr	r3, [r7, #8]
 80155e2:	9300      	str	r3, [sp, #0]
 80155e4:	2301      	movs	r3, #1
 80155e6:	2203      	movs	r2, #3
 80155e8:	69b9      	ldr	r1, [r7, #24]
 80155ea:	4820      	ldr	r0, [pc, #128]	@ (801566c <StoreEccKey+0xec>)
 80155ec:	f7fe f940 	bl	8013870 <GetASN_Items>
 80155f0:	61f8      	str	r0, [r7, #28]
                source, srcIdx, maxIdx);
    }
    if (ret == 0) {
 80155f2:	69fb      	ldr	r3, [r7, #28]
 80155f4:	2b00      	cmp	r3, #0
 80155f6:	d129      	bne.n	801564c <StoreEccKey+0xcc>
        if (dataASN[ECCCERTKEYASN_IDX_OID].tag != 0) {
 80155f8:	69bb      	ldr	r3, [r7, #24]
 80155fa:	7e5b      	ldrb	r3, [r3, #25]
 80155fc:	2b00      	cmp	r3, #0
 80155fe:	d005      	beq.n	801560c <StoreEccKey+0x8c>
            /* Store curve OID. */
            cert->pkCurveOID = dataASN[ECCCERTKEYASN_IDX_OID].data.oid.sum;
 8015600:	69bb      	ldr	r3, [r7, #24]
 8015602:	695a      	ldr	r2, [r3, #20]
 8015604:	68fb      	ldr	r3, [r7, #12]
 8015606:	f8c3 2440 	str.w	r2, [r3, #1088]	@ 0x440
 801560a:	e002      	b.n	8015612 <StoreEccKey+0x92>
                    dataASN[ECCCERTKEYASN_IDX_PARAMS].data.ref.data,
                    dataASN[ECCCERTKEYASN_IDX_PARAMS].data.ref.length, NULL,
                    NULL, &cert->pkCurveSize);
    #else
            /* Explicit parameters not supported in build configuration. */
            ret = ASN_PARSE_E;
 801560c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015610:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
    #endif
        /* Store public key data length. */
        cert->pubKeySize = pubKeyLen;
 8015612:	68fb      	ldr	r3, [r7, #12]
 8015614:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8015616:	605a      	str	r2, [r3, #4]
        /* Must allocated space for key.
         * Don't memcpy into constant pointer so use temp. */
        publicKey = (byte*)XMALLOC(cert->pubKeySize, cert->heap,
 8015618:	68fb      	ldr	r3, [r7, #12]
 801561a:	685b      	ldr	r3, [r3, #4]
 801561c:	4618      	mov	r0, r3
 801561e:	f009 fb2d 	bl	801ec7c <wolfSSL_Malloc>
 8015622:	6178      	str	r0, [r7, #20]
                                   DYNAMIC_TYPE_PUBLIC_KEY);
        if (publicKey == NULL) {
 8015624:	697b      	ldr	r3, [r7, #20]
 8015626:	2b00      	cmp	r3, #0
 8015628:	d103      	bne.n	8015632 <StoreEccKey+0xb2>
            ret = MEMORY_E;
 801562a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801562e:	61fb      	str	r3, [r7, #28]
 8015630:	e00c      	b.n	801564c <StoreEccKey+0xcc>
        }
        else {
            /* Copy in whole public key and store pointer. */
            XMEMCPY(publicKey, pubKey, cert->pubKeySize);
 8015632:	68fb      	ldr	r3, [r7, #12]
 8015634:	685b      	ldr	r3, [r3, #4]
 8015636:	461a      	mov	r2, r3
 8015638:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801563a:	6978      	ldr	r0, [r7, #20]
 801563c:	f013 fba3 	bl	8028d86 <memcpy>
            cert->publicKey = publicKey;
 8015640:	68fb      	ldr	r3, [r7, #12]
 8015642:	697a      	ldr	r2, [r7, #20]
 8015644:	601a      	str	r2, [r3, #0]
            /* Indicate publicKey needs to be freed. */
            cert->pubKeyStored = 1;
 8015646:	68fb      	ldr	r3, [r7, #12]
 8015648:	2201      	movs	r2, #1
 801564a:	609a      	str	r2, [r3, #8]
        }
    }
    FREE_ASNGETDATA(dataASN, cert->heap);
 801564c:	69bb      	ldr	r3, [r7, #24]
 801564e:	2b00      	cmp	r3, #0
 8015650:	d007      	beq.n	8015662 <StoreEccKey+0xe2>
 8015652:	69bb      	ldr	r3, [r7, #24]
 8015654:	613b      	str	r3, [r7, #16]
 8015656:	693b      	ldr	r3, [r7, #16]
 8015658:	2b00      	cmp	r3, #0
 801565a:	d002      	beq.n	8015662 <StoreEccKey+0xe2>
 801565c:	6938      	ldr	r0, [r7, #16]
 801565e:	f009 fb29 	bl	801ecb4 <wolfSSL_Free>

    return ret;
 8015662:	69fb      	ldr	r3, [r7, #28]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015664:	4618      	mov	r0, r3
 8015666:	3720      	adds	r7, #32
 8015668:	46bd      	mov	sp, r7
 801566a:	bd80      	pop	{r7, pc}
 801566c:	08034608 	.word	0x08034608

08015670 <GetCertKey>:
 *          is invalid.
 * @return  BUFFER_E when data in buffer is too small.
 */
static int GetCertKey(DecodedCert* cert, const byte* source, word32* inOutIdx,
                      word32 maxIdx)
{
 8015670:	b590      	push	{r4, r7, lr}
 8015672:	b095      	sub	sp, #84	@ 0x54
 8015674:	af02      	add	r7, sp, #8
 8015676:	60f8      	str	r0, [r7, #12]
 8015678:	60b9      	str	r1, [r7, #8]
 801567a:	607a      	str	r2, [r7, #4]
 801567c:	603b      	str	r3, [r7, #0]
    word32 srcIdx = *inOutIdx;
 801567e:	687b      	ldr	r3, [r7, #4]
 8015680:	681b      	ldr	r3, [r3, #0]
 8015682:	637b      	str	r3, [r7, #52]	@ 0x34
#if defined(HAVE_ECC) || !defined(NO_DSA)
    int pubLen;
#endif
#if defined(HAVE_ECC) || !defined(NO_DSA)
    int pubIdx = (int)srcIdx;
 8015684:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015686:	643b      	str	r3, [r7, #64]	@ 0x40
#endif
    int ret = 0;
 8015688:	2300      	movs	r3, #0
 801568a:	647b      	str	r3, [r7, #68]	@ 0x44
    int length;

    /* Validate parameters. */
    if (source == NULL) {
 801568c:	68bb      	ldr	r3, [r7, #8]
 801568e:	2b00      	cmp	r3, #0
 8015690:	d102      	bne.n	8015698 <GetCertKey+0x28>
        return ASN_PARSE_E;
 8015692:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015696:	e0db      	b.n	8015850 <GetCertKey+0x1e0>

#ifndef WOLFSSL_ASN_TEMPLATE
    if (GetSequence(source, &srcIdx, &length, maxIdx) < 0)
#else
    /* Get SEQUENCE and expect all data to be accounted for. */
    if (GetASN_Sequence(source, &srcIdx, &length, maxIdx, 1) != 0)
 8015698:	f107 0230 	add.w	r2, r7, #48	@ 0x30
 801569c:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 80156a0:	2301      	movs	r3, #1
 80156a2:	9300      	str	r3, [sp, #0]
 80156a4:	683b      	ldr	r3, [r7, #0]
 80156a6:	68b8      	ldr	r0, [r7, #8]
 80156a8:	f7fe fb89 	bl	8013dbe <GetASN_Sequence>
 80156ac:	4603      	mov	r3, r0
 80156ae:	2b00      	cmp	r3, #0
 80156b0:	d002      	beq.n	80156b8 <GetCertKey+0x48>
#endif
    {
        return ASN_PARSE_E;
 80156b2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80156b6:	e0cb      	b.n	8015850 <GetCertKey+0x1e0>
    }

#if defined(HAVE_ECC) || !defined(NO_DSA)
    pubLen = (int)srcIdx - pubIdx + length;
 80156b8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80156ba:	461a      	mov	r2, r3
 80156bc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80156be:	1ad2      	subs	r2, r2, r3
 80156c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80156c2:	4413      	add	r3, r2
 80156c4:	63fb      	str	r3, [r7, #60]	@ 0x3c
#endif
    maxIdx = srcIdx + (word32)length;
 80156c6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80156c8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80156ca:	4413      	add	r3, r2
 80156cc:	603b      	str	r3, [r7, #0]

    /* Decode the algorithm identifier for the key. */
    if (GetAlgoId(source, &srcIdx, &cert->keyOID, oidKeyType, maxIdx) < 0) {
 80156ce:	68fb      	ldr	r3, [r7, #12]
 80156d0:	f103 021c 	add.w	r2, r3, #28
 80156d4:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 80156d8:	683b      	ldr	r3, [r7, #0]
 80156da:	9300      	str	r3, [sp, #0]
 80156dc:	2302      	movs	r3, #2
 80156de:	68b8      	ldr	r0, [r7, #8]
 80156e0:	f7ff f96c 	bl	80149bc <GetAlgoId>
 80156e4:	4603      	mov	r3, r0
 80156e6:	2b00      	cmp	r3, #0
 80156e8:	da02      	bge.n	80156f0 <GetCertKey+0x80>
        return ASN_PARSE_E;
 80156ea:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80156ee:	e0af      	b.n	8015850 <GetCertKey+0x1e0>
    }

    (void)length;

    /* Parse each type of public key. */
    switch (cert->keyOID) {
 80156f0:	68fb      	ldr	r3, [r7, #12]
 80156f2:	69db      	ldr	r3, [r3, #28]
 80156f4:	f240 228e 	movw	r2, #654	@ 0x28e
 80156f8:	4293      	cmp	r3, r2
 80156fa:	d00e      	beq.n	801571a <GetCertKey+0xaa>
 80156fc:	f240 228e 	movw	r2, #654	@ 0x28e
 8015700:	4293      	cmp	r3, r2
 8015702:	f200 809e 	bhi.w	8015842 <GetCertKey+0x1d2>
 8015706:	f240 2206 	movw	r2, #518	@ 0x206
 801570a:	4293      	cmp	r3, r2
 801570c:	f000 8089 	beq.w	8015822 <GetCertKey+0x1b2>
 8015710:	f240 2285 	movw	r2, #645	@ 0x285
 8015714:	4293      	cmp	r3, r2
 8015716:	d07b      	beq.n	8015810 <GetCertKey+0x1a0>
 8015718:	e093      	b.n	8015842 <GetCertKey+0x1d2>
#ifndef NO_RSA
    #ifdef WC_RSA_PSS
        case RSAPSSk:
            if (srcIdx != maxIdx &&
 801571a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801571c:	683a      	ldr	r2, [r7, #0]
 801571e:	429a      	cmp	r2, r3
 8015720:	d076      	beq.n	8015810 <GetCertKey+0x1a0>
                          source[srcIdx] == (ASN_SEQUENCE | ASN_CONSTRUCTED)) {
 8015722:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015724:	68ba      	ldr	r2, [r7, #8]
 8015726:	4413      	add	r3, r2
 8015728:	781b      	ldrb	r3, [r3, #0]
            if (srcIdx != maxIdx &&
 801572a:	2b30      	cmp	r3, #48	@ 0x30
 801572c:	d170      	bne.n	8015810 <GetCertKey+0x1a0>
                word32 seqIdx = srcIdx;
 801572e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015730:	63bb      	str	r3, [r7, #56]	@ 0x38
                int seqLen;
                /* Not set when -1. */
                enum wc_HashType hash = WC_HASH_TYPE_NONE;
 8015732:	2300      	movs	r3, #0
 8015734:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
                int mgf = -1;
 8015738:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801573c:	627b      	str	r3, [r7, #36]	@ 0x24
                int saltLen = 0;
 801573e:	2300      	movs	r3, #0
 8015740:	623b      	str	r3, [r7, #32]
                /* Defaults for sig algorithm parameters. */
                enum wc_HashType sigHash = WC_HASH_TYPE_SHA;
 8015742:	2304      	movs	r3, #4
 8015744:	77fb      	strb	r3, [r7, #31]
                int sigMgf = WC_MGF1SHA1;
 8015746:	231a      	movs	r3, #26
 8015748:	61bb      	str	r3, [r7, #24]
                int sigSaltLen = 20;
 801574a:	2314      	movs	r3, #20
 801574c:	617b      	str	r3, [r7, #20]

                if (GetSequence(source, &srcIdx, &seqLen, maxIdx) < 0) {
 801574e:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 8015752:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8015756:	683b      	ldr	r3, [r7, #0]
 8015758:	68b8      	ldr	r0, [r7, #8]
 801575a:	f7fe fccd 	bl	80140f8 <GetSequence>
 801575e:	4603      	mov	r3, r0
 8015760:	2b00      	cmp	r3, #0
 8015762:	da02      	bge.n	801576a <GetCertKey+0xfa>
                    return ASN_PARSE_E;
 8015764:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015768:	e072      	b.n	8015850 <GetCertKey+0x1e0>
                }
                /* Get the pubic key parameters. */
                ret = DecodeRsaPssParams(source + seqIdx,
 801576a:	68ba      	ldr	r2, [r7, #8]
 801576c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801576e:	18d0      	adds	r0, r2, r3
                    (word32)seqLen + srcIdx - seqIdx, &hash, &mgf, &saltLen);
 8015770:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015772:	461a      	mov	r2, r3
 8015774:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015776:	441a      	add	r2, r3
                ret = DecodeRsaPssParams(source + seqIdx,
 8015778:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801577a:	1ad1      	subs	r1, r2, r3
 801577c:	f107 0424 	add.w	r4, r7, #36	@ 0x24
 8015780:	f107 022b 	add.w	r2, r7, #43	@ 0x2b
 8015784:	f107 0320 	add.w	r3, r7, #32
 8015788:	9300      	str	r3, [sp, #0]
 801578a:	4623      	mov	r3, r4
 801578c:	f7ff f97a 	bl	8014a84 <DecodeRsaPssParams>
 8015790:	6478      	str	r0, [r7, #68]	@ 0x44
                if (ret != 0) {
 8015792:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015794:	2b00      	cmp	r3, #0
 8015796:	d002      	beq.n	801579e <GetCertKey+0x12e>
                    return ASN_PARSE_E;
 8015798:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801579c:	e058      	b.n	8015850 <GetCertKey+0x1e0>
                }
                /* Get the signature parameters. */
                ret = DecodeRsaPssParams(source + cert->sigParamsIndex,
 801579e:	68fb      	ldr	r3, [r7, #12]
 80157a0:	6a1b      	ldr	r3, [r3, #32]
 80157a2:	68ba      	ldr	r2, [r7, #8]
 80157a4:	18d0      	adds	r0, r2, r3
 80157a6:	68fb      	ldr	r3, [r7, #12]
 80157a8:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 80157aa:	f107 0418 	add.w	r4, r7, #24
 80157ae:	f107 021f 	add.w	r2, r7, #31
 80157b2:	f107 0314 	add.w	r3, r7, #20
 80157b6:	9300      	str	r3, [sp, #0]
 80157b8:	4623      	mov	r3, r4
 80157ba:	f7ff f963 	bl	8014a84 <DecodeRsaPssParams>
 80157be:	6478      	str	r0, [r7, #68]	@ 0x44
                    cert->sigParamsLength, &sigHash, &sigMgf, &sigSaltLen);
                if (ret != 0) {
 80157c0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80157c2:	2b00      	cmp	r3, #0
 80157c4:	d002      	beq.n	80157cc <GetCertKey+0x15c>
                    return ASN_PARSE_E;
 80157c6:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80157ca:	e041      	b.n	8015850 <GetCertKey+0x1e0>
                }
                /* Validated signature params match public key params. */
                if (hash != WC_HASH_TYPE_NONE && hash != sigHash) {
 80157cc:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 80157d0:	2b00      	cmp	r3, #0
 80157d2:	d007      	beq.n	80157e4 <GetCertKey+0x174>
 80157d4:	f897 202b 	ldrb.w	r2, [r7, #43]	@ 0x2b
 80157d8:	7ffb      	ldrb	r3, [r7, #31]
 80157da:	429a      	cmp	r2, r3
 80157dc:	d002      	beq.n	80157e4 <GetCertKey+0x174>
                    WOLFSSL_MSG("RSA PSS: hash not matching signature hash");
                    return ASN_PARSE_E;
 80157de:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80157e2:	e035      	b.n	8015850 <GetCertKey+0x1e0>
                }
                if (mgf != -1 && mgf != sigMgf) {
 80157e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80157e6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80157ea:	d006      	beq.n	80157fa <GetCertKey+0x18a>
 80157ec:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80157ee:	69bb      	ldr	r3, [r7, #24]
 80157f0:	429a      	cmp	r2, r3
 80157f2:	d002      	beq.n	80157fa <GetCertKey+0x18a>
                    WOLFSSL_MSG("RSA PSS: MGF not matching signature MGF");
                    return ASN_PARSE_E;
 80157f4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80157f8:	e02a      	b.n	8015850 <GetCertKey+0x1e0>
                }
                if (saltLen > sigSaltLen) {
 80157fa:	6a3a      	ldr	r2, [r7, #32]
 80157fc:	697b      	ldr	r3, [r7, #20]
 80157fe:	429a      	cmp	r2, r3
 8015800:	dd02      	ble.n	8015808 <GetCertKey+0x198>
                    WOLFSSL_MSG("RSA PSS: sig salt length too small");
                    return ASN_PARSE_E;
 8015802:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015806:	e023      	b.n	8015850 <GetCertKey+0x1e0>
                }
                srcIdx += (word32)seqLen;
 8015808:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801580a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801580c:	4413      	add	r3, r2
 801580e:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            FALL_THROUGH;
    #endif /* WC_RSA_PSS */
        case RSAk:
            ret = StoreRsaKey(cert, source, &srcIdx, maxIdx);
 8015810:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 8015814:	683b      	ldr	r3, [r7, #0]
 8015816:	68b9      	ldr	r1, [r7, #8]
 8015818:	68f8      	ldr	r0, [r7, #12]
 801581a:	f7ff fe85 	bl	8015528 <StoreRsaKey>
 801581e:	6478      	str	r0, [r7, #68]	@ 0x44
            break;
 8015820:	e012      	b.n	8015848 <GetCertKey+0x1d8>
    #ifdef HAVE_ECC
    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        case SM2k:
    #endif
        case ECDSAk:
            ret = StoreEccKey(cert, source, &srcIdx, maxIdx, source + pubIdx,
 8015822:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015824:	68ba      	ldr	r2, [r7, #8]
 8015826:	4413      	add	r3, r2
 8015828:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801582a:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 801582e:	9201      	str	r2, [sp, #4]
 8015830:	9300      	str	r3, [sp, #0]
 8015832:	683b      	ldr	r3, [r7, #0]
 8015834:	460a      	mov	r2, r1
 8015836:	68b9      	ldr	r1, [r7, #8]
 8015838:	68f8      	ldr	r0, [r7, #12]
 801583a:	f7ff fea1 	bl	8015580 <StoreEccKey>
 801583e:	6478      	str	r0, [r7, #68]	@ 0x44
                              (word32)pubLen);
            break;
 8015840:	e002      	b.n	8015848 <GetCertKey+0x1d8>
            break;
    #endif /* NO_DSA */
        default:
            WOLFSSL_MSG("Unknown or not compiled in key OID");
            WOLFSSL_ERROR_VERBOSE(ASN_UNKNOWN_OID_E);
            ret = ASN_UNKNOWN_OID_E;
 8015842:	f06f 0393 	mvn.w	r3, #147	@ 0x93
 8015846:	647b      	str	r3, [r7, #68]	@ 0x44
    }

    /* Return index after public key. */
    *inOutIdx = srcIdx;
 8015848:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801584a:	687b      	ldr	r3, [r7, #4]
 801584c:	601a      	str	r2, [r3, #0]

    /* Return error code. */
    return ret;
 801584e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 8015850:	4618      	mov	r0, r3
 8015852:	374c      	adds	r7, #76	@ 0x4c
 8015854:	46bd      	mov	sp, r7
 8015856:	bd90      	pop	{r4, r7, pc}

08015858 <HashIdAlg>:
 *
 * @param [in] oidSum  Signature id.
 * @return  Hash algorithm id.
 */
int HashIdAlg(word32 oidSum)
{
 8015858:	b480      	push	{r7}
 801585a:	b083      	sub	sp, #12
 801585c:	af00      	add	r7, sp, #0
 801585e:	6078      	str	r0, [r7, #4]
    if (oidSum == SM2k) {
        return WC_SM3;
    }
#endif
#if defined(NO_SHA) || (!defined(NO_SHA256) && defined(WC_ASN_HASH_SHA256))
    return WC_SHA256;
 8015860:	2306      	movs	r3, #6
#else
    return WC_SHA;
#endif
}
 8015862:	4618      	mov	r0, r3
 8015864:	370c      	adds	r7, #12
 8015866:	46bd      	mov	sp, r7
 8015868:	f85d 7b04 	ldr.w	r7, [sp], #4
 801586c:	4770      	bx	lr

0801586e <CalcHashId>:
 * @param [out] hash  Buffer to hold hash.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
int CalcHashId(const byte* data, word32 len, byte* hash)
{
 801586e:	b580      	push	{r7, lr}
 8015870:	b084      	sub	sp, #16
 8015872:	af00      	add	r7, sp, #0
 8015874:	60f8      	str	r0, [r7, #12]
 8015876:	60b9      	str	r1, [r7, #8]
 8015878:	607a      	str	r2, [r7, #4]
    /* Use default hash algorithm. */
    return CalcHashId_ex(data, len, hash,
 801587a:	2306      	movs	r3, #6
 801587c:	687a      	ldr	r2, [r7, #4]
 801587e:	68b9      	ldr	r1, [r7, #8]
 8015880:	68f8      	ldr	r0, [r7, #12]
 8015882:	f000 f805 	bl	8015890 <CalcHashId_ex>
 8015886:	4603      	mov	r3, r0
        WC_SHA256
#else
        WC_SHA
#endif
        );
}
 8015888:	4618      	mov	r0, r3
 801588a:	3710      	adds	r7, #16
 801588c:	46bd      	mov	sp, r7
 801588e:	bd80      	pop	{r7, pc}

08015890 <CalcHashId_ex>:
 * @param [out] hash  Buffer to hold hash.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
int CalcHashId_ex(const byte* data, word32 len, byte* hash, int hashAlg)
{
 8015890:	b580      	push	{r7, lr}
 8015892:	b086      	sub	sp, #24
 8015894:	af00      	add	r7, sp, #0
 8015896:	60f8      	str	r0, [r7, #12]
 8015898:	60b9      	str	r1, [r7, #8]
 801589a:	607a      	str	r2, [r7, #4]
 801589c:	603b      	str	r3, [r7, #0]
        ret = wc_Sm3Hash(data, len, hash);
    }
    else
#endif
#if defined(NO_SHA) || (!defined(NO_SHA256) && defined(WC_ASN_HASH_SHA256))
    if (hashAlg == WC_SHA256) {
 801589e:	683b      	ldr	r3, [r7, #0]
 80158a0:	2b06      	cmp	r3, #6
 80158a2:	d106      	bne.n	80158b2 <CalcHashId_ex+0x22>
        ret = wc_Sha256Hash(data, len, hash);
 80158a4:	687a      	ldr	r2, [r7, #4]
 80158a6:	68b9      	ldr	r1, [r7, #8]
 80158a8:	68f8      	ldr	r0, [r7, #12]
 80158aa:	f008 ff41 	bl	801e730 <wc_Sha256Hash>
 80158ae:	6178      	str	r0, [r7, #20]
 80158b0:	e002      	b.n	80158b8 <CalcHashId_ex+0x28>
    (void)data;
    (void)len;
    (void)hash;
#endif
    {
        ret = NOT_COMPILED_IN;
 80158b2:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 80158b6:	617b      	str	r3, [r7, #20]
    }

    return ret;
 80158b8:	697b      	ldr	r3, [r7, #20]
}
 80158ba:	4618      	mov	r0, r3
 80158bc:	3718      	adds	r7, #24
 80158be:	46bd      	mov	sp, r7
 80158c0:	bd80      	pop	{r7, pc}

080158c2 <GetHashId>:
 * @param [out] hash  Buffer to hold hash.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int GetHashId(const byte* id, int length, byte* hash, int hashAlg)
{
 80158c2:	b580      	push	{r7, lr}
 80158c4:	b086      	sub	sp, #24
 80158c6:	af00      	add	r7, sp, #0
 80158c8:	60f8      	str	r0, [r7, #12]
 80158ca:	60b9      	str	r1, [r7, #8]
 80158cc:	607a      	str	r2, [r7, #4]
 80158ce:	603b      	str	r3, [r7, #0]
    int ret;

#if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
    if (length == wc_HashGetDigestSize(wc_HashTypeConvert(hashAlg)))
#else
    if (length == KEYID_SIZE)
 80158d0:	68bb      	ldr	r3, [r7, #8]
 80158d2:	2b20      	cmp	r3, #32
 80158d4:	d108      	bne.n	80158e8 <GetHashId+0x26>
#endif
    {
    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        XMEMSET(hash + length, 0, KEYID_SIZE - length);
    #endif
        XMEMCPY(hash, id, (size_t)length);
 80158d6:	68bb      	ldr	r3, [r7, #8]
 80158d8:	461a      	mov	r2, r3
 80158da:	68f9      	ldr	r1, [r7, #12]
 80158dc:	6878      	ldr	r0, [r7, #4]
 80158de:	f013 fa52 	bl	8028d86 <memcpy>
        ret = 0;
 80158e2:	2300      	movs	r3, #0
 80158e4:	617b      	str	r3, [r7, #20]
 80158e6:	e006      	b.n	80158f6 <GetHashId+0x34>
    }
    else {
        ret = CalcHashId_ex(id, (word32)length, hash, hashAlg);
 80158e8:	68b9      	ldr	r1, [r7, #8]
 80158ea:	683b      	ldr	r3, [r7, #0]
 80158ec:	687a      	ldr	r2, [r7, #4]
 80158ee:	68f8      	ldr	r0, [r7, #12]
 80158f0:	f7ff ffce 	bl	8015890 <CalcHashId_ex>
 80158f4:	6178      	str	r0, [r7, #20]
    }

    return ret;
 80158f6:	697b      	ldr	r3, [r7, #20]
}
 80158f8:	4618      	mov	r0, r3
 80158fa:	3718      	adds	r7, #24
 80158fc:	46bd      	mov	sp, r7
 80158fe:	bd80      	pop	{r7, pc}

08015900 <AddDNSEntryToList>:
 * @param [in, out] lst      Linked list of DNS name entries.
 * @param [in]      entry    Entry to add to the list
 * @return  0 on success.
 */
static int AddDNSEntryToList(DNS_entry** lst, DNS_entry* entry)
{
 8015900:	b480      	push	{r7}
 8015902:	b085      	sub	sp, #20
 8015904:	af00      	add	r7, sp, #0
 8015906:	6078      	str	r0, [r7, #4]
 8015908:	6039      	str	r1, [r7, #0]
#if defined(OPENSSL_EXTRA) && !defined(WOLFSSL_ALT_NAMES_NO_REV)
    entry->next = NULL;
 801590a:	683b      	ldr	r3, [r7, #0]
 801590c:	2200      	movs	r2, #0
 801590e:	601a      	str	r2, [r3, #0]
    if (*lst == NULL) {
 8015910:	687b      	ldr	r3, [r7, #4]
 8015912:	681b      	ldr	r3, [r3, #0]
 8015914:	2b00      	cmp	r3, #0
 8015916:	d103      	bne.n	8015920 <AddDNSEntryToList+0x20>
        /* First on list */
        *lst = entry;
 8015918:	687b      	ldr	r3, [r7, #4]
 801591a:	683a      	ldr	r2, [r7, #0]
 801591c:	601a      	str	r2, [r3, #0]
 801591e:	e00d      	b.n	801593c <AddDNSEntryToList+0x3c>
    }
    else {
        DNS_entry* temp = *lst;
 8015920:	687b      	ldr	r3, [r7, #4]
 8015922:	681b      	ldr	r3, [r3, #0]
 8015924:	60fb      	str	r3, [r7, #12]

        /* Find end */
        for (; (temp->next != NULL); temp = temp->next);
 8015926:	e002      	b.n	801592e <AddDNSEntryToList+0x2e>
 8015928:	68fb      	ldr	r3, [r7, #12]
 801592a:	681b      	ldr	r3, [r3, #0]
 801592c:	60fb      	str	r3, [r7, #12]
 801592e:	68fb      	ldr	r3, [r7, #12]
 8015930:	681b      	ldr	r3, [r3, #0]
 8015932:	2b00      	cmp	r3, #0
 8015934:	d1f8      	bne.n	8015928 <AddDNSEntryToList+0x28>

        /* Add to end */
        temp->next = entry;
 8015936:	68fb      	ldr	r3, [r7, #12]
 8015938:	683a      	ldr	r2, [r7, #0]
 801593a:	601a      	str	r2, [r3, #0]
    /* Prepend entry to linked list. */
    entry->next = *lst;
    *lst = entry;
#endif

    return 0;
 801593c:	2300      	movs	r3, #0
}
 801593e:	4618      	mov	r0, r3
 8015940:	3714      	adds	r7, #20
 8015942:	46bd      	mov	sp, r7
 8015944:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015948:	4770      	bx	lr

0801594a <SetDNSEntry>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int SetDNSEntry(void* heap, const char* str, int strLen,
                       int type, DNS_entry** entries)
{
 801594a:	b580      	push	{r7, lr}
 801594c:	b088      	sub	sp, #32
 801594e:	af00      	add	r7, sp, #0
 8015950:	60f8      	str	r0, [r7, #12]
 8015952:	60b9      	str	r1, [r7, #8]
 8015954:	607a      	str	r2, [r7, #4]
 8015956:	603b      	str	r3, [r7, #0]
    DNS_entry* dnsEntry;
    int ret = 0;
 8015958:	2300      	movs	r3, #0
 801595a:	61fb      	str	r3, [r7, #28]

    /* TODO: consider one malloc. */
    /* Allocate DNS Entry object. */
    dnsEntry = AltNameNew(heap);
 801595c:	68f8      	ldr	r0, [r7, #12]
 801595e:	f7ff fce8 	bl	8015332 <AltNameNew>
 8015962:	61b8      	str	r0, [r7, #24]
    if (dnsEntry == NULL) {
 8015964:	69bb      	ldr	r3, [r7, #24]
 8015966:	2b00      	cmp	r3, #0
 8015968:	d102      	bne.n	8015970 <SetDNSEntry+0x26>
        ret = MEMORY_E;
 801596a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801596e:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8015970:	69fb      	ldr	r3, [r7, #28]
 8015972:	2b00      	cmp	r3, #0
 8015974:	d10e      	bne.n	8015994 <SetDNSEntry+0x4a>
        /* Allocate DNS Entry name - length of string plus 1 for NUL. */
        dnsEntry->name = (char*)XMALLOC((size_t)strLen + 1, heap,
 8015976:	687b      	ldr	r3, [r7, #4]
 8015978:	3301      	adds	r3, #1
 801597a:	4618      	mov	r0, r3
 801597c:	f009 f97e 	bl	801ec7c <wolfSSL_Malloc>
 8015980:	4602      	mov	r2, r0
 8015982:	69bb      	ldr	r3, [r7, #24]
 8015984:	60da      	str	r2, [r3, #12]
                                                          DYNAMIC_TYPE_ALTNAME);
        if (dnsEntry->name == NULL) {
 8015986:	69bb      	ldr	r3, [r7, #24]
 8015988:	68db      	ldr	r3, [r3, #12]
 801598a:	2b00      	cmp	r3, #0
 801598c:	d102      	bne.n	8015994 <SetDNSEntry+0x4a>
            ret = MEMORY_E;
 801598e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015992:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 8015994:	69fb      	ldr	r3, [r7, #28]
 8015996:	2b00      	cmp	r3, #0
 8015998:	d112      	bne.n	80159c0 <SetDNSEntry+0x76>
        /* Set tag type, name length, name and NUL terminate name. */
        dnsEntry->type = type;
 801599a:	69bb      	ldr	r3, [r7, #24]
 801599c:	683a      	ldr	r2, [r7, #0]
 801599e:	605a      	str	r2, [r3, #4]
        dnsEntry->len = strLen;
 80159a0:	69bb      	ldr	r3, [r7, #24]
 80159a2:	687a      	ldr	r2, [r7, #4]
 80159a4:	609a      	str	r2, [r3, #8]
        XMEMCPY(dnsEntry->name, str, (size_t)strLen);
 80159a6:	69bb      	ldr	r3, [r7, #24]
 80159a8:	68db      	ldr	r3, [r3, #12]
 80159aa:	687a      	ldr	r2, [r7, #4]
 80159ac:	68b9      	ldr	r1, [r7, #8]
 80159ae:	4618      	mov	r0, r3
 80159b0:	f013 f9e9 	bl	8028d86 <memcpy>
        dnsEntry->name[strLen] = '\0';
 80159b4:	69bb      	ldr	r3, [r7, #24]
 80159b6:	68da      	ldr	r2, [r3, #12]
 80159b8:	687b      	ldr	r3, [r7, #4]
 80159ba:	4413      	add	r3, r2
 80159bc:	2200      	movs	r2, #0
 80159be:	701a      	strb	r2, [r3, #0]
#ifdef WOLFSSL_IP_ALT_NAME
    /* store IP addresses as a string */
    if (ret == 0 && type == ASN_IP_TYPE)
        ret = GenerateDNSEntryIPString(dnsEntry, heap);
#endif
    if (ret == 0) {
 80159c0:	69fb      	ldr	r3, [r7, #28]
 80159c2:	2b00      	cmp	r3, #0
 80159c4:	d104      	bne.n	80159d0 <SetDNSEntry+0x86>
        ret = AddDNSEntryToList(entries, dnsEntry);
 80159c6:	69b9      	ldr	r1, [r7, #24]
 80159c8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80159ca:	f7ff ff99 	bl	8015900 <AddDNSEntryToList>
 80159ce:	61f8      	str	r0, [r7, #28]
    }

    /* failure cleanup */
    if (ret != 0 && dnsEntry != NULL) {
 80159d0:	69fb      	ldr	r3, [r7, #28]
 80159d2:	2b00      	cmp	r3, #0
 80159d4:	d013      	beq.n	80159fe <SetDNSEntry+0xb4>
 80159d6:	69bb      	ldr	r3, [r7, #24]
 80159d8:	2b00      	cmp	r3, #0
 80159da:	d010      	beq.n	80159fe <SetDNSEntry+0xb4>
        XFREE(dnsEntry->name, heap, DYNAMIC_TYPE_ALTNAME);
 80159dc:	69bb      	ldr	r3, [r7, #24]
 80159de:	68db      	ldr	r3, [r3, #12]
 80159e0:	617b      	str	r3, [r7, #20]
 80159e2:	697b      	ldr	r3, [r7, #20]
 80159e4:	2b00      	cmp	r3, #0
 80159e6:	d002      	beq.n	80159ee <SetDNSEntry+0xa4>
 80159e8:	6978      	ldr	r0, [r7, #20]
 80159ea:	f009 f963 	bl	801ecb4 <wolfSSL_Free>
        XFREE(dnsEntry, heap, DYNAMIC_TYPE_ALTNAME);
 80159ee:	69bb      	ldr	r3, [r7, #24]
 80159f0:	613b      	str	r3, [r7, #16]
 80159f2:	693b      	ldr	r3, [r7, #16]
 80159f4:	2b00      	cmp	r3, #0
 80159f6:	d002      	beq.n	80159fe <SetDNSEntry+0xb4>
 80159f8:	6938      	ldr	r0, [r7, #16]
 80159fa:	f009 f95b 	bl	801ecb4 <wolfSSL_Free>
    }

    return ret;
 80159fe:	69fb      	ldr	r3, [r7, #28]
}
 8015a00:	4618      	mov	r0, r3
 8015a02:	3720      	adds	r7, #32
 8015a04:	46bd      	mov	sp, r7
 8015a06:	bd80      	pop	{r7, pc}

08015a08 <SetSubject>:
 * @param [in]      tag     BER tag representing encoding of string.
 * @return  0 on success, negative values on failure.
 */
static int SetSubject(DecodedCert* cert, int id, byte* str, int strLen,
                      byte tag)
{
 8015a08:	b480      	push	{r7}
 8015a0a:	b087      	sub	sp, #28
 8015a0c:	af00      	add	r7, sp, #0
 8015a0e:	60f8      	str	r0, [r7, #12]
 8015a10:	60b9      	str	r1, [r7, #8]
 8015a12:	607a      	str	r2, [r7, #4]
 8015a14:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8015a16:	2300      	movs	r3, #0
 8015a18:	617b      	str	r3, [r7, #20]

    /* Put string and encoding into certificate. */
    if (id == ASN_COMMON_NAME) {
 8015a1a:	68bb      	ldr	r3, [r7, #8]
 8015a1c:	2b03      	cmp	r3, #3
 8015a1e:	d10d      	bne.n	8015a3c <SetSubject+0x34>
        cert->subjectCN = (char *)str;
 8015a20:	68fb      	ldr	r3, [r7, #12]
 8015a22:	687a      	ldr	r2, [r7, #4]
 8015a24:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        cert->subjectCNLen = (int)strLen;
 8015a28:	68fb      	ldr	r3, [r7, #12]
 8015a2a:	683a      	ldr	r2, [r7, #0]
 8015a2c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        cert->subjectCNEnc = (char)tag;
 8015a30:	68fb      	ldr	r3, [r7, #12]
 8015a32:	f897 2020 	ldrb.w	r2, [r7, #32]
 8015a36:	f883 208c 	strb.w	r2, [r3, #140]	@ 0x8c
 8015a3a:	e00b      	b.n	8015a54 <SetSubject+0x4c>
        SetCertNameSubjectEnc(cert, id, tag);
    }
#endif
#if !defined(IGNORE_NAME_CONSTRAINTS) || \
     defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_CERT_EXT)
    else if (id == ASN_EMAIL) {
 8015a3c:	68bb      	ldr	r3, [r7, #8]
 8015a3e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8015a42:	d107      	bne.n	8015a54 <SetSubject+0x4c>
        cert->subjectEmail = (char*)str;
 8015a44:	68fb      	ldr	r3, [r7, #12]
 8015a46:	687a      	ldr	r2, [r7, #4]
 8015a48:	f8c3 245c 	str.w	r2, [r3, #1116]	@ 0x45c
        cert->subjectEmailLen = strLen;
 8015a4c:	68fb      	ldr	r3, [r7, #12]
 8015a4e:	683a      	ldr	r2, [r7, #0]
 8015a50:	f8c3 2460 	str.w	r2, [r3, #1120]	@ 0x460
        cert->subjectJSLen = strLen;
        cert->subjectJSEnc = (char)tag;
    }
#endif

    return ret;
 8015a54:	697b      	ldr	r3, [r7, #20]
}
 8015a56:	4618      	mov	r0, r3
 8015a58:	371c      	adds	r7, #28
 8015a5a:	46bd      	mov	sp, r7
 8015a5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015a60:	4770      	bx	lr
	...

08015a64 <GetRDN>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  ASN_PARSE_E when type not supported.
 */
static int GetRDN(DecodedCert* cert, char* full, word32* idx, int* nid,
                  int isSubject, ASNGetData* dataASN)
{
 8015a64:	b580      	push	{r7, lr}
 8015a66:	b090      	sub	sp, #64	@ 0x40
 8015a68:	af02      	add	r7, sp, #8
 8015a6a:	60f8      	str	r0, [r7, #12]
 8015a6c:	60b9      	str	r1, [r7, #8]
 8015a6e:	607a      	str	r2, [r7, #4]
 8015a70:	603b      	str	r3, [r7, #0]
    int         ret = 0;
 8015a72:	2300      	movs	r3, #0
 8015a74:	637b      	str	r3, [r7, #52]	@ 0x34
    const char* typeStr = NULL;
 8015a76:	2300      	movs	r3, #0
 8015a78:	633b      	str	r3, [r7, #48]	@ 0x30
    byte        typeStrLen = 0;
 8015a7a:	2300      	movs	r3, #0
 8015a7c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    byte*       oid;
    word32      oidSz;
    int         id = 0;
 8015a80:	2300      	movs	r3, #0
 8015a82:	62bb      	str	r3, [r7, #40]	@ 0x28

    (void)nid;

    /* Get name type OID from data items. */
    GetASN_OIDData(&dataASN[RDNASN_IDX_ATTR_TYPE], &oid, &oidSz);
 8015a84:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015a86:	3338      	adds	r3, #56	@ 0x38
 8015a88:	689b      	ldr	r3, [r3, #8]
 8015a8a:	623b      	str	r3, [r7, #32]
 8015a8c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015a8e:	3338      	adds	r3, #56	@ 0x38
 8015a90:	68db      	ldr	r3, [r3, #12]
 8015a92:	61fb      	str	r3, [r7, #28]

    /* v1 name types */
    if ((oidSz == 3) && (oid[0] == 0x55) && (oid[1] == 0x04)) {
 8015a94:	69fb      	ldr	r3, [r7, #28]
 8015a96:	2b03      	cmp	r3, #3
 8015a98:	d146      	bne.n	8015b28 <GetRDN+0xc4>
 8015a9a:	6a3b      	ldr	r3, [r7, #32]
 8015a9c:	781b      	ldrb	r3, [r3, #0]
 8015a9e:	2b55      	cmp	r3, #85	@ 0x55
 8015aa0:	d142      	bne.n	8015b28 <GetRDN+0xc4>
 8015aa2:	6a3b      	ldr	r3, [r7, #32]
 8015aa4:	3301      	adds	r3, #1
 8015aa6:	781b      	ldrb	r3, [r3, #0]
 8015aa8:	2b04      	cmp	r3, #4
 8015aaa:	d13d      	bne.n	8015b28 <GetRDN+0xc4>
        id = oid[2];
 8015aac:	6a3b      	ldr	r3, [r7, #32]
 8015aae:	3302      	adds	r3, #2
 8015ab0:	781b      	ldrb	r3, [r3, #0]
 8015ab2:	62bb      	str	r3, [r7, #40]	@ 0x28
        /* Check range of supported ids in table. */
        if (ValidCertNameSubject(id)) {
 8015ab4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015ab6:	2b02      	cmp	r3, #2
 8015ab8:	f340 80ed 	ble.w	8015c96 <GetRDN+0x232>
 8015abc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015abe:	3b02      	subs	r3, #2
 8015ac0:	2210      	movs	r2, #16
 8015ac2:	4293      	cmp	r3, r2
 8015ac4:	f300 80e7 	bgt.w	8015c96 <GetRDN+0x232>
 8015ac8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015aca:	1eda      	subs	r2, r3, #3
 8015acc:	499c      	ldr	r1, [pc, #624]	@ (8015d40 <GetRDN+0x2dc>)
 8015ace:	4613      	mov	r3, r2
 8015ad0:	005b      	lsls	r3, r3, #1
 8015ad2:	4413      	add	r3, r2
 8015ad4:	009b      	lsls	r3, r3, #2
 8015ad6:	440b      	add	r3, r1
 8015ad8:	3304      	adds	r3, #4
 8015ada:	781b      	ldrb	r3, [r3, #0]
 8015adc:	2b00      	cmp	r3, #0
 8015ade:	f000 80da 	beq.w	8015c96 <GetRDN+0x232>
            /* Get the type string, length and NID from table. */
            typeStr = GetCertNameSubjectStr(id);
 8015ae2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015ae4:	1eda      	subs	r2, r3, #3
 8015ae6:	4996      	ldr	r1, [pc, #600]	@ (8015d40 <GetRDN+0x2dc>)
 8015ae8:	4613      	mov	r3, r2
 8015aea:	005b      	lsls	r3, r3, #1
 8015aec:	4413      	add	r3, r2
 8015aee:	009b      	lsls	r3, r3, #2
 8015af0:	440b      	add	r3, r1
 8015af2:	681b      	ldr	r3, [r3, #0]
 8015af4:	633b      	str	r3, [r7, #48]	@ 0x30
            typeStrLen = GetCertNameSubjectStrLen(id);
 8015af6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015af8:	1eda      	subs	r2, r3, #3
 8015afa:	4991      	ldr	r1, [pc, #580]	@ (8015d40 <GetRDN+0x2dc>)
 8015afc:	4613      	mov	r3, r2
 8015afe:	005b      	lsls	r3, r3, #1
 8015b00:	4413      	add	r3, r2
 8015b02:	009b      	lsls	r3, r3, #2
 8015b04:	440b      	add	r3, r1
 8015b06:	3304      	adds	r3, #4
 8015b08:	781b      	ldrb	r3, [r3, #0]
 8015b0a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            *nid = GetCertNameSubjectNID(id);
 8015b0e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015b10:	1eda      	subs	r2, r3, #3
 8015b12:	498b      	ldr	r1, [pc, #556]	@ (8015d40 <GetRDN+0x2dc>)
 8015b14:	4613      	mov	r3, r2
 8015b16:	005b      	lsls	r3, r3, #1
 8015b18:	4413      	add	r3, r2
 8015b1a:	009b      	lsls	r3, r3, #2
 8015b1c:	440b      	add	r3, r1
 8015b1e:	3308      	adds	r3, #8
 8015b20:	681a      	ldr	r2, [r3, #0]
 8015b22:	683b      	ldr	r3, [r7, #0]
 8015b24:	601a      	str	r2, [r3, #0]
        if (ValidCertNameSubject(id)) {
 8015b26:	e0b6      	b.n	8015c96 <GetRDN+0x232>
        #endif
        }
    }
    else if (oidSz == sizeof(attrEmailOid) && XMEMCMP(oid, attrEmailOid, oidSz) == 0) {
 8015b28:	69fb      	ldr	r3, [r7, #28]
 8015b2a:	2b09      	cmp	r3, #9
 8015b2c:	d114      	bne.n	8015b58 <GetRDN+0xf4>
 8015b2e:	6a3b      	ldr	r3, [r7, #32]
 8015b30:	69fa      	ldr	r2, [r7, #28]
 8015b32:	4984      	ldr	r1, [pc, #528]	@ (8015d44 <GetRDN+0x2e0>)
 8015b34:	4618      	mov	r0, r3
 8015b36:	f013 f84b 	bl	8028bd0 <memcmp>
 8015b3a:	4603      	mov	r3, r0
 8015b3c:	2b00      	cmp	r3, #0
 8015b3e:	d10b      	bne.n	8015b58 <GetRDN+0xf4>
        /* Set the email id, type string, length and NID. */
        id = ASN_EMAIL;
 8015b40:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8015b44:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr =  WOLFSSL_EMAIL_ADDR;
 8015b46:	4b80      	ldr	r3, [pc, #512]	@ (8015d48 <GetRDN+0x2e4>)
 8015b48:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_EMAIL_ADDR) - 1;
 8015b4a:	230e      	movs	r3, #14
 8015b4c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_emailAddress;
 8015b50:	683b      	ldr	r3, [r7, #0]
 8015b52:	2230      	movs	r2, #48	@ 0x30
 8015b54:	601a      	str	r2, [r3, #0]
 8015b56:	e09f      	b.n	8015c98 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(uidOid) && XMEMCMP(oid, uidOid, oidSz) == 0) {
 8015b58:	69fb      	ldr	r3, [r7, #28]
 8015b5a:	2b0a      	cmp	r3, #10
 8015b5c:	d114      	bne.n	8015b88 <GetRDN+0x124>
 8015b5e:	6a3b      	ldr	r3, [r7, #32]
 8015b60:	69fa      	ldr	r2, [r7, #28]
 8015b62:	497a      	ldr	r1, [pc, #488]	@ (8015d4c <GetRDN+0x2e8>)
 8015b64:	4618      	mov	r0, r3
 8015b66:	f013 f833 	bl	8028bd0 <memcmp>
 8015b6a:	4603      	mov	r3, r0
 8015b6c:	2b00      	cmp	r3, #0
 8015b6e:	d10b      	bne.n	8015b88 <GetRDN+0x124>
        /* Set the user id, type string, length and NID. */
        id = ASN_USER_ID;
 8015b70:	2312      	movs	r3, #18
 8015b72:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_USER_ID;
 8015b74:	4b76      	ldr	r3, [pc, #472]	@ (8015d50 <GetRDN+0x2ec>)
 8015b76:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_USER_ID) - 1;
 8015b78:	2305      	movs	r3, #5
 8015b7a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_userId;
 8015b7e:	683b      	ldr	r3, [r7, #0]
 8015b80:	f44f 72e5 	mov.w	r2, #458	@ 0x1ca
 8015b84:	601a      	str	r2, [r3, #0]
 8015b86:	e087      	b.n	8015c98 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(dcOid) && XMEMCMP(oid, dcOid, oidSz) == 0) {
 8015b88:	69fb      	ldr	r3, [r7, #28]
 8015b8a:	2b0a      	cmp	r3, #10
 8015b8c:	d114      	bne.n	8015bb8 <GetRDN+0x154>
 8015b8e:	6a3b      	ldr	r3, [r7, #32]
 8015b90:	69fa      	ldr	r2, [r7, #28]
 8015b92:	4970      	ldr	r1, [pc, #448]	@ (8015d54 <GetRDN+0x2f0>)
 8015b94:	4618      	mov	r0, r3
 8015b96:	f013 f81b 	bl	8028bd0 <memcmp>
 8015b9a:	4603      	mov	r3, r0
 8015b9c:	2b00      	cmp	r3, #0
 8015b9e:	d10b      	bne.n	8015bb8 <GetRDN+0x154>
        /* Set the domain component, type string, length and NID. */
        id = ASN_DC;
 8015ba0:	f44f 7381 	mov.w	r3, #258	@ 0x102
 8015ba4:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_DOMAIN_COMPONENT;
 8015ba6:	4b6c      	ldr	r3, [pc, #432]	@ (8015d58 <GetRDN+0x2f4>)
 8015ba8:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_DOMAIN_COMPONENT) - 1;
 8015baa:	2304      	movs	r3, #4
 8015bac:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_domainComponent;
 8015bb0:	683b      	ldr	r3, [r7, #0]
 8015bb2:	2219      	movs	r2, #25
 8015bb4:	601a      	str	r2, [r3, #0]
 8015bb6:	e06f      	b.n	8015c98 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(rfc822Mlbx) && XMEMCMP(oid, rfc822Mlbx, oidSz) == 0) {
 8015bb8:	69fb      	ldr	r3, [r7, #28]
 8015bba:	2b0a      	cmp	r3, #10
 8015bbc:	d114      	bne.n	8015be8 <GetRDN+0x184>
 8015bbe:	6a3b      	ldr	r3, [r7, #32]
 8015bc0:	69fa      	ldr	r2, [r7, #28]
 8015bc2:	4966      	ldr	r1, [pc, #408]	@ (8015d5c <GetRDN+0x2f8>)
 8015bc4:	4618      	mov	r0, r3
 8015bc6:	f013 f803 	bl	8028bd0 <memcmp>
 8015bca:	4603      	mov	r3, r0
 8015bcc:	2b00      	cmp	r3, #0
 8015bce:	d10b      	bne.n	8015be8 <GetRDN+0x184>
        /* Set the RFC822 mailbox, type string, length and NID. */
        id = ASN_RFC822_MAILBOX;
 8015bd0:	2314      	movs	r3, #20
 8015bd2:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_RFC822_MAILBOX;
 8015bd4:	4b62      	ldr	r3, [pc, #392]	@ (8015d60 <GetRDN+0x2fc>)
 8015bd6:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_RFC822_MAILBOX) - 1;
 8015bd8:	230f      	movs	r3, #15
 8015bda:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_rfc822Mailbox;
 8015bde:	683b      	ldr	r3, [r7, #0]
 8015be0:	f44f 72e6 	mov.w	r2, #460	@ 0x1cc
 8015be4:	601a      	str	r2, [r3, #0]
 8015be6:	e057      	b.n	8015c98 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(fvrtDrk) && XMEMCMP(oid, fvrtDrk, oidSz) == 0) {
 8015be8:	69fb      	ldr	r3, [r7, #28]
 8015bea:	2b0a      	cmp	r3, #10
 8015bec:	d114      	bne.n	8015c18 <GetRDN+0x1b4>
 8015bee:	6a3b      	ldr	r3, [r7, #32]
 8015bf0:	69fa      	ldr	r2, [r7, #28]
 8015bf2:	495c      	ldr	r1, [pc, #368]	@ (8015d64 <GetRDN+0x300>)
 8015bf4:	4618      	mov	r0, r3
 8015bf6:	f012 ffeb 	bl	8028bd0 <memcmp>
 8015bfa:	4603      	mov	r3, r0
 8015bfc:	2b00      	cmp	r3, #0
 8015bfe:	d10b      	bne.n	8015c18 <GetRDN+0x1b4>
        /* Set the favourite drink, type string, length and NID. */
        id = ASN_FAVOURITE_DRINK;
 8015c00:	2313      	movs	r3, #19
 8015c02:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_FAVOURITE_DRINK;
 8015c04:	4b58      	ldr	r3, [pc, #352]	@ (8015d68 <GetRDN+0x304>)
 8015c06:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_FAVOURITE_DRINK) - 1;
 8015c08:	2310      	movs	r3, #16
 8015c0a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_favouriteDrink;
 8015c0e:	683b      	ldr	r3, [r7, #0]
 8015c10:	f44f 72e7 	mov.w	r2, #462	@ 0x1ce
 8015c14:	601a      	str	r2, [r3, #0]
 8015c16:	e03f      	b.n	8015c98 <GetRDN+0x234>
        *nid = WC_NID_pkcs9_contentType;
    #endif
    }
#endif
    /* Other OIDs that start with the same values. */
    else if (oidSz == sizeof(dcOid) && XMEMCMP(oid, dcOid, oidSz-1) == 0) {
 8015c18:	69fb      	ldr	r3, [r7, #28]
 8015c1a:	2b0a      	cmp	r3, #10
 8015c1c:	d10d      	bne.n	8015c3a <GetRDN+0x1d6>
 8015c1e:	6a38      	ldr	r0, [r7, #32]
 8015c20:	69fb      	ldr	r3, [r7, #28]
 8015c22:	3b01      	subs	r3, #1
 8015c24:	461a      	mov	r2, r3
 8015c26:	494b      	ldr	r1, [pc, #300]	@ (8015d54 <GetRDN+0x2f0>)
 8015c28:	f012 ffd2 	bl	8028bd0 <memcmp>
 8015c2c:	4603      	mov	r3, r0
 8015c2e:	2b00      	cmp	r3, #0
 8015c30:	d103      	bne.n	8015c3a <GetRDN+0x1d6>
        WOLFSSL_MSG("Unknown pilot attribute type");
        WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
        ret = ASN_PARSE_E;
 8015c32:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015c36:	637b      	str	r3, [r7, #52]	@ 0x34
 8015c38:	e02e      	b.n	8015c98 <GetRDN+0x234>
    }
    else if (oidSz == ASN_JOI_PREFIX_SZ + 1 &&
 8015c3a:	69fb      	ldr	r3, [r7, #28]
 8015c3c:	2b0b      	cmp	r3, #11
 8015c3e:	d12b      	bne.n	8015c98 <GetRDN+0x234>
                         XMEMCMP(oid, ASN_JOI_PREFIX, ASN_JOI_PREFIX_SZ) == 0) {
 8015c40:	6a3b      	ldr	r3, [r7, #32]
 8015c42:	220a      	movs	r2, #10
 8015c44:	4949      	ldr	r1, [pc, #292]	@ (8015d6c <GetRDN+0x308>)
 8015c46:	4618      	mov	r0, r3
 8015c48:	f012 ffc2 	bl	8028bd0 <memcmp>
 8015c4c:	4603      	mov	r3, r0
    else if (oidSz == ASN_JOI_PREFIX_SZ + 1 &&
 8015c4e:	2b00      	cmp	r3, #0
 8015c50:	d122      	bne.n	8015c98 <GetRDN+0x234>
        /* Set the jurisdiction id. */
        id = 0x200 + oid[ASN_JOI_PREFIX_SZ];
 8015c52:	6a3b      	ldr	r3, [r7, #32]
 8015c54:	330a      	adds	r3, #10
 8015c56:	781b      	ldrb	r3, [r3, #0]
 8015c58:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8015c5c:	62bb      	str	r3, [r7, #40]	@ 0x28

        /* Set the jurisdiction type string, length and NID if known. */
        if (oid[ASN_JOI_PREFIX_SZ] == ASN_JOI_C) {
 8015c5e:	6a3b      	ldr	r3, [r7, #32]
 8015c60:	330a      	adds	r3, #10
 8015c62:	781b      	ldrb	r3, [r3, #0]
 8015c64:	2b03      	cmp	r3, #3
 8015c66:	d108      	bne.n	8015c7a <GetRDN+0x216>
            typeStr = WOLFSSL_JOI_C;
 8015c68:	4b41      	ldr	r3, [pc, #260]	@ (8015d70 <GetRDN+0x30c>)
 8015c6a:	633b      	str	r3, [r7, #48]	@ 0x30
            typeStrLen = sizeof(WOLFSSL_JOI_C) - 1;
 8015c6c:	230f      	movs	r3, #15
 8015c6e:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            *nid = WC_NID_jurisdictionCountryName;
 8015c72:	683b      	ldr	r3, [r7, #0]
 8015c74:	220c      	movs	r2, #12
 8015c76:	601a      	str	r2, [r3, #0]
 8015c78:	e00e      	b.n	8015c98 <GetRDN+0x234>
        #endif /* WOLFSSL_X509_NAME_AVAILABLE */
        }
        else if (oid[ASN_JOI_PREFIX_SZ] == ASN_JOI_ST) {
 8015c7a:	6a3b      	ldr	r3, [r7, #32]
 8015c7c:	330a      	adds	r3, #10
 8015c7e:	781b      	ldrb	r3, [r3, #0]
 8015c80:	2b02      	cmp	r3, #2
 8015c82:	d109      	bne.n	8015c98 <GetRDN+0x234>
            typeStr = WOLFSSL_JOI_ST;
 8015c84:	4b3b      	ldr	r3, [pc, #236]	@ (8015d74 <GetRDN+0x310>)
 8015c86:	633b      	str	r3, [r7, #48]	@ 0x30
            typeStrLen = sizeof(WOLFSSL_JOI_ST) - 1;
 8015c88:	2310      	movs	r3, #16
 8015c8a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            *nid = WC_NID_jurisdictionStateOrProvinceName;
 8015c8e:	683b      	ldr	r3, [r7, #0]
 8015c90:	220d      	movs	r2, #13
 8015c92:	601a      	str	r2, [r3, #0]
 8015c94:	e000      	b.n	8015c98 <GetRDN+0x234>
        if (ValidCertNameSubject(id)) {
 8015c96:	bf00      	nop
        else {
            WOLFSSL_MSG("Unknown Jurisdiction, skipping");
        }
    }

    if ((ret == 0) && (typeStr != NULL)) {
 8015c98:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015c9a:	2b00      	cmp	r3, #0
 8015c9c:	d14b      	bne.n	8015d36 <GetRDN+0x2d2>
 8015c9e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015ca0:	2b00      	cmp	r3, #0
 8015ca2:	d048      	beq.n	8015d36 <GetRDN+0x2d2>
        /* OID type to store for subject name and add to full string. */
        byte*  str;
        word32 strLen;
        byte   tag = dataASN[RDNASN_IDX_ATTR_VAL].tag;
 8015ca4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015ca6:	3354      	adds	r3, #84	@ 0x54
 8015ca8:	7e5b      	ldrb	r3, [r3, #25]
 8015caa:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        /* Get the string reference and length. */
        GetASN_GetRef(&dataASN[RDNASN_IDX_ATTR_VAL], &str, &strLen);
 8015cae:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015cb0:	3354      	adds	r3, #84	@ 0x54
 8015cb2:	689b      	ldr	r3, [r3, #8]
 8015cb4:	61bb      	str	r3, [r7, #24]
 8015cb6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015cb8:	3354      	adds	r3, #84	@ 0x54
 8015cba:	68db      	ldr	r3, [r3, #12]
 8015cbc:	617b      	str	r3, [r7, #20]

        if (isSubject) {
 8015cbe:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015cc0:	2b00      	cmp	r3, #0
 8015cc2:	d00b      	beq.n	8015cdc <GetRDN+0x278>
            /* Store subject field components. */
            ret = SetSubject(cert, id, str, (int)strLen, tag);
 8015cc4:	69ba      	ldr	r2, [r7, #24]
 8015cc6:	697b      	ldr	r3, [r7, #20]
 8015cc8:	4619      	mov	r1, r3
 8015cca:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8015cce:	9300      	str	r3, [sp, #0]
 8015cd0:	460b      	mov	r3, r1
 8015cd2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8015cd4:	68f8      	ldr	r0, [r7, #12]
 8015cd6:	f7ff fe97 	bl	8015a08 <SetSubject>
 8015cda:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Put issuer common name string and encoding into certificate. */
        else {
            ret = SetIssuer(cert, id, str, (int)strLen, tag);
        }
    #endif
        if (ret == 0) {
 8015cdc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015cde:	2b00      	cmp	r3, #0
 8015ce0:	d129      	bne.n	8015d36 <GetRDN+0x2d2>
            /* Check there is space for this in the full name string and
             * terminating NUL character. */
            if ((typeStrLen + strLen) < (word32)(WC_ASN_NAME_MAX - *idx))
 8015ce2:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
 8015ce6:	697b      	ldr	r3, [r7, #20]
 8015ce8:	441a      	add	r2, r3
 8015cea:	687b      	ldr	r3, [r7, #4]
 8015cec:	681b      	ldr	r3, [r3, #0]
 8015cee:	f5c3 73b4 	rsb	r3, r3, #360	@ 0x168
 8015cf2:	429a      	cmp	r2, r3
 8015cf4:	d21f      	bcs.n	8015d36 <GetRDN+0x2d2>
            {
                /* Add RDN to full string. */
                XMEMCPY(&full[*idx], typeStr, typeStrLen);
 8015cf6:	687b      	ldr	r3, [r7, #4]
 8015cf8:	681b      	ldr	r3, [r3, #0]
 8015cfa:	68ba      	ldr	r2, [r7, #8]
 8015cfc:	4413      	add	r3, r2
 8015cfe:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
 8015d02:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8015d04:	4618      	mov	r0, r3
 8015d06:	f013 f83e 	bl	8028d86 <memcpy>
                *idx += typeStrLen;
 8015d0a:	687b      	ldr	r3, [r7, #4]
 8015d0c:	681a      	ldr	r2, [r3, #0]
 8015d0e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8015d12:	441a      	add	r2, r3
 8015d14:	687b      	ldr	r3, [r7, #4]
 8015d16:	601a      	str	r2, [r3, #0]
                XMEMCPY(&full[*idx], str, strLen);
 8015d18:	687b      	ldr	r3, [r7, #4]
 8015d1a:	681b      	ldr	r3, [r3, #0]
 8015d1c:	68ba      	ldr	r2, [r7, #8]
 8015d1e:	4413      	add	r3, r2
 8015d20:	69b9      	ldr	r1, [r7, #24]
 8015d22:	697a      	ldr	r2, [r7, #20]
 8015d24:	4618      	mov	r0, r3
 8015d26:	f013 f82e 	bl	8028d86 <memcpy>
                *idx += strLen;
 8015d2a:	687b      	ldr	r3, [r7, #4]
 8015d2c:	681a      	ldr	r2, [r3, #0]
 8015d2e:	697b      	ldr	r3, [r7, #20]
 8015d30:	441a      	add	r2, r3
 8015d32:	687b      	ldr	r3, [r7, #4]
 8015d34:	601a      	str	r2, [r3, #0]
                WOLFSSL_MSG("ASN Name too big, skipping");
            }
        }
    }

    return ret;
 8015d36:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8015d38:	4618      	mov	r0, r3
 8015d3a:	3738      	adds	r7, #56	@ 0x38
 8015d3c:	46bd      	mov	sp, r7
 8015d3e:	bd80      	pop	{r7, pc}
 8015d40:	08034614 	.word	0x08034614
 8015d44:	080344dc 	.word	0x080344dc
 8015d48:	080305e4 	.word	0x080305e4
 8015d4c:	08034500 	.word	0x08034500
 8015d50:	080305f4 	.word	0x080305f4
 8015d54:	08034524 	.word	0x08034524
 8015d58:	080305fc 	.word	0x080305fc
 8015d5c:	0803450c 	.word	0x0803450c
 8015d60:	08030604 	.word	0x08030604
 8015d64:	08034518 	.word	0x08034518
 8015d68:	08030614 	.word	0x08030614
 8015d6c:	08030628 	.word	0x08030628
 8015d70:	08030634 	.word	0x08030634
 8015d74:	08030644 	.word	0x08030644

08015d78 <GetCertName>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int GetCertName(DecodedCert* cert, char* full, byte* hash, int nameType,
                       const byte* input, word32* inOutIdx, word32 maxIdx)
{
 8015d78:	b5b0      	push	{r4, r5, r7, lr}
 8015d7a:	b094      	sub	sp, #80	@ 0x50
 8015d7c:	af04      	add	r7, sp, #16
 8015d7e:	60f8      	str	r0, [r7, #12]
 8015d80:	60b9      	str	r1, [r7, #8]
 8015d82:	607a      	str	r2, [r7, #4]
 8015d84:	603b      	str	r3, [r7, #0]

    *inOutIdx = srcIdx;

    return 0;
#else
    DECL_ASNGETDATA(dataASN, rdnASN_Length);
 8015d86:	2300      	movs	r3, #0
 8015d88:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int    ret = 0;
 8015d8a:	2300      	movs	r3, #0
 8015d8c:	63bb      	str	r3, [r7, #56]	@ 0x38
    word32 idx = 0;
 8015d8e:	2300      	movs	r3, #0
 8015d90:	627b      	str	r3, [r7, #36]	@ 0x24
    int    len = 0;
 8015d92:	2300      	movs	r3, #0
 8015d94:	623b      	str	r3, [r7, #32]
    word32 srcIdx = *inOutIdx;
 8015d96:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8015d98:	681b      	ldr	r3, [r3, #0]
 8015d9a:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_X509_NAME_AVAILABLE
    WOLFSSL_X509_NAME* dName = NULL;
 8015d9c:	2300      	movs	r3, #0
 8015d9e:	637b      	str	r3, [r7, #52]	@ 0x34
    WOLFSSL_MSG("Getting Cert Name");

    /* For OCSP, RFC2560 section 4.1.1 states the issuer hash should be
     * calculated over the entire DER encoding of the Name field, including
     * the tag and length. */
    if (CalcHashId_ex(input + srcIdx, maxIdx - srcIdx, hash,
 8015da0:	69fb      	ldr	r3, [r7, #28]
 8015da2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8015da4:	18d4      	adds	r4, r2, r3
 8015da6:	69fb      	ldr	r3, [r7, #28]
 8015da8:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8015daa:	1ad5      	subs	r5, r2, r3
 8015dac:	68fb      	ldr	r3, [r7, #12]
 8015dae:	699b      	ldr	r3, [r3, #24]
 8015db0:	4618      	mov	r0, r3
 8015db2:	f7ff fd51 	bl	8015858 <HashIdAlg>
 8015db6:	4603      	mov	r3, r0
 8015db8:	687a      	ldr	r2, [r7, #4]
 8015dba:	4629      	mov	r1, r5
 8015dbc:	4620      	mov	r0, r4
 8015dbe:	f7ff fd67 	bl	8015890 <CalcHashId_ex>
 8015dc2:	4603      	mov	r3, r0
 8015dc4:	2b00      	cmp	r3, #0
 8015dc6:	d002      	beq.n	8015dce <GetCertName+0x56>
            HashIdAlg(cert->signatureOID)) != 0) {
        ret = ASN_PARSE_E;
 8015dc8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015dcc:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    CALLOC_ASNGETDATA(dataASN, rdnASN_Length, ret, cert->heap);
 8015dce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015dd0:	2b00      	cmp	r3, #0
 8015dd2:	d109      	bne.n	8015de8 <GetCertName+0x70>
 8015dd4:	2070      	movs	r0, #112	@ 0x70
 8015dd6:	f008 ff51 	bl	801ec7c <wolfSSL_Malloc>
 8015dda:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8015ddc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015dde:	2b00      	cmp	r3, #0
 8015de0:	d102      	bne.n	8015de8 <GetCertName+0x70>
 8015de2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015de6:	63bb      	str	r3, [r7, #56]	@ 0x38
 8015de8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015dea:	2b00      	cmp	r3, #0
 8015dec:	d104      	bne.n	8015df8 <GetCertName+0x80>
 8015dee:	2270      	movs	r2, #112	@ 0x70
 8015df0:	2100      	movs	r1, #0
 8015df2:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8015df4:	f012 ff16 	bl	8028c24 <memset>

#ifdef WOLFSSL_X509_NAME_AVAILABLE
    if (ret == 0) {
 8015df8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015dfa:	2b00      	cmp	r3, #0
 8015dfc:	d10c      	bne.n	8015e18 <GetCertName+0xa0>
        /* Create an X509_NAME to hold data for OpenSSL compatibility APIs. */
        dName = wolfSSL_X509_NAME_new_ex(cert->heap);
 8015dfe:	68fb      	ldr	r3, [r7, #12]
 8015e00:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8015e04:	4618      	mov	r0, r3
 8015e06:	f7f8 fc84 	bl	800e712 <wolfSSL_X509_NAME_new_ex>
 8015e0a:	6378      	str	r0, [r7, #52]	@ 0x34
        if (dName == NULL) {
 8015e0c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015e0e:	2b00      	cmp	r3, #0
 8015e10:	d102      	bne.n	8015e18 <GetCertName+0xa0>
            ret = MEMORY_E;
 8015e12:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015e16:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
    }
#endif /* WOLFSSL_X509_NAME_AVAILABLE */

    if (ret == 0) {
 8015e18:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015e1a:	2b00      	cmp	r3, #0
 8015e1c:	d10a      	bne.n	8015e34 <GetCertName+0xbc>
        /* Expecting a SEQUENCE using up all data. */
        ret = GetASN_Sequence(input, &srcIdx, &len, maxIdx, 1);
 8015e1e:	f107 0220 	add.w	r2, r7, #32
 8015e22:	f107 011c 	add.w	r1, r7, #28
 8015e26:	2301      	movs	r3, #1
 8015e28:	9300      	str	r3, [sp, #0]
 8015e2a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8015e2c:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8015e2e:	f7fd ffc6 	bl	8013dbe <GetASN_Sequence>
 8015e32:	63b8      	str	r0, [r7, #56]	@ 0x38
    }
    if (ret == 0) {
 8015e34:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015e36:	2b00      	cmp	r3, #0
 8015e38:	f040 808a 	bne.w	8015f50 <GetCertName+0x1d8>
            cert->issuerRawLen = len;
        }
    #endif
    #if !defined(IGNORE_NAME_CONSTRAINTS) || defined(WOLFSSL_CERT_EXT)
        /* Store pointer and length to raw subject. */
        if (nameType == ASN_SUBJECT) {
 8015e3c:	683b      	ldr	r3, [r7, #0]
 8015e3e:	2b01      	cmp	r3, #1
 8015e40:	d17f      	bne.n	8015f42 <GetCertName+0x1ca>
            cert->subjectRaw = &input[srcIdx];
 8015e42:	69fb      	ldr	r3, [r7, #28]
 8015e44:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8015e46:	441a      	add	r2, r3
 8015e48:	68fb      	ldr	r3, [r7, #12]
 8015e4a:	f8c3 2454 	str.w	r2, [r3, #1108]	@ 0x454
            cert->subjectRawLen = len;
 8015e4e:	6a3a      	ldr	r2, [r7, #32]
 8015e50:	68fb      	ldr	r3, [r7, #12]
 8015e52:	f8c3 2458 	str.w	r2, [r3, #1112]	@ 0x458
        }
    #endif

        /* Process all RDNs in name. */
        while ((ret == 0) && (srcIdx < maxIdx)) {
 8015e56:	e074      	b.n	8015f42 <GetCertName+0x1ca>
            int nid = 0;
 8015e58:	2300      	movs	r3, #0
 8015e5a:	61bb      	str	r3, [r7, #24]

            /* Initialize for data and setup RDN choice. */
            GetASN_Choice(&dataASN[RDNASN_IDX_ATTR_VAL], rdnChoice);
 8015e5c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015e5e:	3354      	adds	r3, #84	@ 0x54
 8015e60:	220b      	movs	r2, #11
 8015e62:	761a      	strb	r2, [r3, #24]
 8015e64:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015e66:	3354      	adds	r3, #84	@ 0x54
 8015e68:	4a4f      	ldr	r2, [pc, #316]	@ (8015fa8 <GetCertName+0x230>)
 8015e6a:	609a      	str	r2, [r3, #8]
            /* Ignore type OID as too many to store in table. */
            GetASN_OID(&dataASN[RDNASN_IDX_ATTR_TYPE], oidIgnoreType);
 8015e6c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015e6e:	3338      	adds	r3, #56	@ 0x38
 8015e70:	2215      	movs	r2, #21
 8015e72:	611a      	str	r2, [r3, #16]
            /* Parse RDN. */
            ret = GetASN_Items(rdnASN, dataASN, rdnASN_Length, 1, input,
 8015e74:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8015e76:	9302      	str	r3, [sp, #8]
 8015e78:	f107 031c 	add.w	r3, r7, #28
 8015e7c:	9301      	str	r3, [sp, #4]
 8015e7e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8015e80:	9300      	str	r3, [sp, #0]
 8015e82:	2301      	movs	r3, #1
 8015e84:	2204      	movs	r2, #4
 8015e86:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8015e88:	4848      	ldr	r0, [pc, #288]	@ (8015fac <GetCertName+0x234>)
 8015e8a:	f7fd fcf1 	bl	8013870 <GetASN_Items>
 8015e8e:	63b8      	str	r0, [r7, #56]	@ 0x38
                               &srcIdx, maxIdx);
            if (ret == 0) {
 8015e90:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015e92:	2b00      	cmp	r3, #0
 8015e94:	d113      	bne.n	8015ebe <GetCertName+0x146>
                /* Put RDN data into certificate. */
                ret = GetRDN(cert, full, &idx, &nid, nameType == ASN_SUBJECT,
 8015e96:	683b      	ldr	r3, [r7, #0]
 8015e98:	2b01      	cmp	r3, #1
 8015e9a:	bf0c      	ite	eq
 8015e9c:	2301      	moveq	r3, #1
 8015e9e:	2300      	movne	r3, #0
 8015ea0:	b2db      	uxtb	r3, r3
 8015ea2:	4618      	mov	r0, r3
 8015ea4:	f107 0118 	add.w	r1, r7, #24
 8015ea8:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 8015eac:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015eae:	9301      	str	r3, [sp, #4]
 8015eb0:	9000      	str	r0, [sp, #0]
 8015eb2:	460b      	mov	r3, r1
 8015eb4:	68b9      	ldr	r1, [r7, #8]
 8015eb6:	68f8      	ldr	r0, [r7, #12]
 8015eb8:	f7ff fdd4 	bl	8015a64 <GetRDN>
 8015ebc:	63b8      	str	r0, [r7, #56]	@ 0x38
                             dataASN);
            }
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            /* TODO: push this back up to ssl.c
             * (do parsing for WOLFSSL_X509_NAME on demand) */
            if (ret == 0) {
 8015ebe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015ec0:	2b00      	cmp	r3, #0
 8015ec2:	d13e      	bne.n	8015f42 <GetCertName+0x1ca>
                int enc;
                byte*  str;
                word32 strLen;
                byte   tag = dataASN[RDNASN_IDX_ATTR_VAL].tag;
 8015ec4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015ec6:	3354      	adds	r3, #84	@ 0x54
 8015ec8:	7e5b      	ldrb	r3, [r3, #25]
 8015eca:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

                /* Get string reference. */
                GetASN_GetRef(&dataASN[RDNASN_IDX_ATTR_VAL], &str, &strLen);
 8015ece:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015ed0:	3354      	adds	r3, #84	@ 0x54
 8015ed2:	689b      	ldr	r3, [r3, #8]
 8015ed4:	617b      	str	r3, [r7, #20]
 8015ed6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015ed8:	3354      	adds	r3, #84	@ 0x54
 8015eda:	68db      	ldr	r3, [r3, #12]
 8015edc:	613b      	str	r3, [r7, #16]

            #ifndef WOLFSSL_NO_ASN_STRICT
                /* RFC 5280 section 4.1.2.4 lists a DirectoryString as being
                 * 1..MAX in length */
                if (ret == 0 && strLen < 1) {
 8015ede:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015ee0:	2b00      	cmp	r3, #0
 8015ee2:	d105      	bne.n	8015ef0 <GetCertName+0x178>
 8015ee4:	693b      	ldr	r3, [r7, #16]
 8015ee6:	2b00      	cmp	r3, #0
 8015ee8:	d102      	bne.n	8015ef0 <GetCertName+0x178>
                    WOLFSSL_MSG("Non conforming DirectoryString of length 0 was"
                                " found");
                    WOLFSSL_MSG("Use WOLFSSL_NO_ASN_STRICT if wanting to allow"
                                " empty DirectoryString's");
                    ret = ASN_PARSE_E;
 8015eea:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015eee:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
            #endif

                /* Convert BER tag to a OpenSSL type. */
                switch (tag) {
 8015ef0:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8015ef4:	2b0c      	cmp	r3, #12
 8015ef6:	d002      	beq.n	8015efe <GetCertName+0x186>
 8015ef8:	2b13      	cmp	r3, #19
 8015efa:	d004      	beq.n	8015f06 <GetCertName+0x18e>
 8015efc:	e006      	b.n	8015f0c <GetCertName+0x194>
                    case CTC_UTF8:
                        enc = WOLFSSL_MBSTRING_UTF8;
 8015efe:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8015f02:	633b      	str	r3, [r7, #48]	@ 0x30
                        break;
 8015f04:	e005      	b.n	8015f12 <GetCertName+0x19a>
                    case CTC_PRINTABLE:
                        enc = WOLFSSL_V_ASN1_PRINTABLESTRING;
 8015f06:	2313      	movs	r3, #19
 8015f08:	633b      	str	r3, [r7, #48]	@ 0x30
                        break;
 8015f0a:	e002      	b.n	8015f12 <GetCertName+0x19a>
                    default:
                        WOLFSSL_MSG("Unknown encoding type, default UTF8");
                        enc = WOLFSSL_MBSTRING_UTF8;
 8015f0c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8015f10:	633b      	str	r3, [r7, #48]	@ 0x30
                }
                if (nid != 0) {
 8015f12:	69bb      	ldr	r3, [r7, #24]
 8015f14:	2b00      	cmp	r3, #0
 8015f16:	d014      	beq.n	8015f42 <GetCertName+0x1ca>
                    /* Add an entry to the X509_NAME. */
                    if (wolfSSL_X509_NAME_add_entry_by_NID(dName, nid, enc, str,
 8015f18:	69b9      	ldr	r1, [r7, #24]
 8015f1a:	697b      	ldr	r3, [r7, #20]
 8015f1c:	693a      	ldr	r2, [r7, #16]
 8015f1e:	4610      	mov	r0, r2
 8015f20:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8015f24:	9202      	str	r2, [sp, #8]
 8015f26:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8015f2a:	9201      	str	r2, [sp, #4]
 8015f2c:	9000      	str	r0, [sp, #0]
 8015f2e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8015f30:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8015f32:	f7f8 fe83 	bl	800ec3c <wolfSSL_X509_NAME_add_entry_by_NID>
 8015f36:	4603      	mov	r3, r0
 8015f38:	2b01      	cmp	r3, #1
 8015f3a:	d002      	beq.n	8015f42 <GetCertName+0x1ca>
                            (int)strLen, -1, -1) != WOLFSSL_SUCCESS) {
                        ret = ASN_PARSE_E;
 8015f3c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015f40:	63bb      	str	r3, [r7, #56]	@ 0x38
        while ((ret == 0) && (srcIdx < maxIdx)) {
 8015f42:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015f44:	2b00      	cmp	r3, #0
 8015f46:	d103      	bne.n	8015f50 <GetCertName+0x1d8>
 8015f48:	69fb      	ldr	r3, [r7, #28]
 8015f4a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8015f4c:	429a      	cmp	r2, r3
 8015f4e:	d883      	bhi.n	8015e58 <GetCertName+0xe0>
                }
            }
        #endif
        }
    }
    if (ret == 0) {
 8015f50:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015f52:	2b00      	cmp	r3, #0
 8015f54:	d114      	bne.n	8015f80 <GetCertName+0x208>
        /* Terminate string. */
        full[idx] = 0;
 8015f56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015f58:	68ba      	ldr	r2, [r7, #8]
 8015f5a:	4413      	add	r3, r2
 8015f5c:	2200      	movs	r2, #0
 8015f5e:	701a      	strb	r2, [r3, #0]
        /* Return index into encoding after name. */
        *inOutIdx = srcIdx;
 8015f60:	69fa      	ldr	r2, [r7, #28]
 8015f62:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8015f64:	601a      	str	r2, [r3, #0]

#ifdef WOLFSSL_X509_NAME_AVAILABLE
        /* Store X509_NAME in certificate. */
        if (nameType == ASN_ISSUER) {
 8015f66:	683b      	ldr	r3, [r7, #0]
 8015f68:	2b00      	cmp	r3, #0
 8015f6a:	d104      	bne.n	8015f76 <GetCertName+0x1fe>
            (defined(HAVE_PKCS7) || defined(WOLFSSL_CERT_EXT))
            dName->rawLen = (int)min((word32)cert->issuerRawLen,
                WC_ASN_NAME_MAX);
            XMEMCPY(dName->raw, cert->issuerRaw, (size_t)dName->rawLen);
        #endif
            cert->issuerName = dName;
 8015f6c:	68fb      	ldr	r3, [r7, #12]
 8015f6e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8015f70:	f8c3 2464 	str.w	r2, [r3, #1124]	@ 0x464
 8015f74:	e007      	b.n	8015f86 <GetCertName+0x20e>
        #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX)
            dName->rawLen = (int)min((word32)cert->subjectRawLen,
                WC_ASN_NAME_MAX);
            XMEMCPY(dName->raw, cert->subjectRaw, (size_t)dName->rawLen);
        #endif
            cert->subjectName = dName;
 8015f76:	68fb      	ldr	r3, [r7, #12]
 8015f78:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8015f7a:	f8c3 2468 	str.w	r2, [r3, #1128]	@ 0x468
 8015f7e:	e002      	b.n	8015f86 <GetCertName+0x20e>
        }
    }
    else {
        /* Dispose of unused X509_NAME. */
        wolfSSL_X509_NAME_free(dName);
 8015f80:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8015f82:	f7f8 fbb0 	bl	800e6e6 <wolfSSL_X509_NAME_free>
#endif
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8015f86:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015f88:	2b00      	cmp	r3, #0
 8015f8a:	d007      	beq.n	8015f9c <GetCertName+0x224>
 8015f8c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015f8e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8015f90:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015f92:	2b00      	cmp	r3, #0
 8015f94:	d002      	beq.n	8015f9c <GetCertName+0x224>
 8015f96:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8015f98:	f008 fe8c 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 8015f9c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015f9e:	4618      	mov	r0, r3
 8015fa0:	3740      	adds	r7, #64	@ 0x40
 8015fa2:	46bd      	mov	sp, r7
 8015fa4:	bdb0      	pop	{r4, r5, r7, pc}
 8015fa6:	bf00      	nop
 8015fa8:	080346e4 	.word	0x080346e4
 8015fac:	080346d4 	.word	0x080346d4

08015fb0 <DecodeToKey>:
 * @return  ASN_OBJECT_ID_E when the expected OBJECT_ID tag is not found.
 * @return  ASN_BITSTR_E when the expected BIT_STRING tag is not found.
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set.
 */
int DecodeToKey(DecodedCert* cert, int verify)
{
 8015fb0:	b580      	push	{r7, lr}
 8015fb2:	b086      	sub	sp, #24
 8015fb4:	af02      	add	r7, sp, #8
 8015fb6:	6078      	str	r0, [r7, #4]
 8015fb8:	6039      	str	r1, [r7, #0]
        return badDate;

    return ret;
#else
    int ret;
    int badDate = 0;
 8015fba:	2300      	movs	r3, #0
 8015fbc:	60bb      	str	r3, [r7, #8]
     * This is required to parse a potential alternative public key in the
     * SubjectAlternativeKey extension. */
    ret = DecodeCertInternal(cert, verify, NULL, &badDate, 0, 0);
#else
    /* Call internal version and stop after public key. */
    ret = DecodeCertInternal(cert, verify, NULL, &badDate, 0, 1);
 8015fbe:	f107 0308 	add.w	r3, r7, #8
 8015fc2:	2201      	movs	r2, #1
 8015fc4:	9201      	str	r2, [sp, #4]
 8015fc6:	2200      	movs	r2, #0
 8015fc8:	9200      	str	r2, [sp, #0]
 8015fca:	2200      	movs	r2, #0
 8015fcc:	6839      	ldr	r1, [r7, #0]
 8015fce:	6878      	ldr	r0, [r7, #4]
 8015fd0:	f002 f8ae 	bl	8018130 <DecodeCertInternal>
 8015fd4:	60f8      	str	r0, [r7, #12]
#endif
    /* Always return date errors. */
    if (ret == 0) {
 8015fd6:	68fb      	ldr	r3, [r7, #12]
 8015fd8:	2b00      	cmp	r3, #0
 8015fda:	d101      	bne.n	8015fe0 <DecodeToKey+0x30>
        ret = badDate;
 8015fdc:	68bb      	ldr	r3, [r7, #8]
 8015fde:	60fb      	str	r3, [r7, #12]
    }
    return ret;
 8015fe0:	68fb      	ldr	r3, [r7, #12]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015fe2:	4618      	mov	r0, r3
 8015fe4:	3710      	adds	r7, #16
 8015fe6:	46bd      	mov	sp, r7
 8015fe8:	bd80      	pop	{r7, pc}

08015fea <SetLength>:
 * @param [in]  length  Value to encode.
 * @param [out] output  Buffer to encode into.
 * @return  Number of bytes encoded.
 */
word32 SetLength(word32 length, byte* output)
{
 8015fea:	b580      	push	{r7, lr}
 8015fec:	b084      	sub	sp, #16
 8015fee:	af00      	add	r7, sp, #0
 8015ff0:	6078      	str	r0, [r7, #4]
 8015ff2:	6039      	str	r1, [r7, #0]
    /* Start encoding at start of buffer. */
    word32 i = 0;
 8015ff4:	2300      	movs	r3, #0
 8015ff6:	60fb      	str	r3, [r7, #12]

    if (length < ASN_LONG_LENGTH) {
 8015ff8:	687b      	ldr	r3, [r7, #4]
 8015ffa:	2b7f      	cmp	r3, #127	@ 0x7f
 8015ffc:	d80c      	bhi.n	8016018 <SetLength+0x2e>
        /* Only one byte needed to encode. */
        if (output) {
 8015ffe:	683b      	ldr	r3, [r7, #0]
 8016000:	2b00      	cmp	r3, #0
 8016002:	d005      	beq.n	8016010 <SetLength+0x26>
            /* Write out length value. */
            output[i] = (byte)length;
 8016004:	683a      	ldr	r2, [r7, #0]
 8016006:	68fb      	ldr	r3, [r7, #12]
 8016008:	4413      	add	r3, r2
 801600a:	687a      	ldr	r2, [r7, #4]
 801600c:	b2d2      	uxtb	r2, r2
 801600e:	701a      	strb	r2, [r3, #0]
        }
        /* Skip over length. */
        i++;
 8016010:	68fb      	ldr	r3, [r7, #12]
 8016012:	3301      	adds	r3, #1
 8016014:	60fb      	str	r3, [r7, #12]
 8016016:	e02a      	b.n	801606e <SetLength+0x84>
    }
    else {
        /* Calculate the number of bytes required to encode value. */
        byte j = (byte)BytePrecision(length);
 8016018:	6878      	ldr	r0, [r7, #4]
 801601a:	f7fc fc4a 	bl	80128b2 <BytePrecision>
 801601e:	4603      	mov	r3, r0
 8016020:	72fb      	strb	r3, [r7, #11]

        if (output) {
 8016022:	683b      	ldr	r3, [r7, #0]
 8016024:	2b00      	cmp	r3, #0
 8016026:	d007      	beq.n	8016038 <SetLength+0x4e>
            /* Encode count byte. */
            output[i] = (byte)(j | ASN_LONG_LENGTH);
 8016028:	683a      	ldr	r2, [r7, #0]
 801602a:	68fb      	ldr	r3, [r7, #12]
 801602c:	4413      	add	r3, r2
 801602e:	7afa      	ldrb	r2, [r7, #11]
 8016030:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 8016034:	b2d2      	uxtb	r2, r2
 8016036:	701a      	strb	r2, [r3, #0]
        }
        /* Skip over count byte. */
        i++;
 8016038:	68fb      	ldr	r3, [r7, #12]
 801603a:	3301      	adds	r3, #1
 801603c:	60fb      	str	r3, [r7, #12]

        /* Encode value as a big-endian byte array. */
        for (; j > 0; --j) {
 801603e:	e013      	b.n	8016068 <SetLength+0x7e>
            if (output) {
 8016040:	683b      	ldr	r3, [r7, #0]
 8016042:	2b00      	cmp	r3, #0
 8016044:	d00a      	beq.n	801605c <SetLength+0x72>
                /* Encode next most-significant byte. */
                output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));
 8016046:	7afb      	ldrb	r3, [r7, #11]
 8016048:	3b01      	subs	r3, #1
 801604a:	00db      	lsls	r3, r3, #3
 801604c:	687a      	ldr	r2, [r7, #4]
 801604e:	fa22 f103 	lsr.w	r1, r2, r3
 8016052:	683a      	ldr	r2, [r7, #0]
 8016054:	68fb      	ldr	r3, [r7, #12]
 8016056:	4413      	add	r3, r2
 8016058:	b2ca      	uxtb	r2, r1
 801605a:	701a      	strb	r2, [r3, #0]
            }
            /* Skip over byte. */
            i++;
 801605c:	68fb      	ldr	r3, [r7, #12]
 801605e:	3301      	adds	r3, #1
 8016060:	60fb      	str	r3, [r7, #12]
        for (; j > 0; --j) {
 8016062:	7afb      	ldrb	r3, [r7, #11]
 8016064:	3b01      	subs	r3, #1
 8016066:	72fb      	strb	r3, [r7, #11]
 8016068:	7afb      	ldrb	r3, [r7, #11]
 801606a:	2b00      	cmp	r3, #0
 801606c:	d1e8      	bne.n	8016040 <SetLength+0x56>
        }
    }

    /* Return number of bytes in encoded length. */
    return i;
 801606e:	68fb      	ldr	r3, [r7, #12]
}
 8016070:	4618      	mov	r0, r3
 8016072:	3710      	adds	r7, #16
 8016074:	46bd      	mov	sp, r7
 8016076:	bd80      	pop	{r7, pc}

08016078 <IsSigAlgoECDSA>:
 * @param [in] algoOID  Signature algorithm identifier.
 * @return  1 when algorithm is using ECDSA.
 * @return  0 otherwise.
 */
static WC_INLINE int IsSigAlgoECDSA(word32 algoOID)
{
 8016078:	b480      	push	{r7}
 801607a:	b083      	sub	sp, #12
 801607c:	af00      	add	r7, sp, #0
 801607e:	6078      	str	r0, [r7, #4]
    /* ECDSA sigAlgo must not have ASN1 NULL parameters */
    if (algoOID == CTC_SHAwECDSA || algoOID == CTC_SHA256wECDSA ||
 8016080:	687b      	ldr	r3, [r7, #4]
 8016082:	f5b3 7f02 	cmp.w	r3, #520	@ 0x208
 8016086:	d00d      	beq.n	80160a4 <IsSigAlgoECDSA+0x2c>
 8016088:	687b      	ldr	r3, [r7, #4]
 801608a:	f5b3 7f03 	cmp.w	r3, #524	@ 0x20c
 801608e:	d009      	beq.n	80160a4 <IsSigAlgoECDSA+0x2c>
 8016090:	687b      	ldr	r3, [r7, #4]
 8016092:	f240 220d 	movw	r2, #525	@ 0x20d
 8016096:	4293      	cmp	r3, r2
 8016098:	d004      	beq.n	80160a4 <IsSigAlgoECDSA+0x2c>
        algoOID == CTC_SHA384wECDSA || algoOID == CTC_SHA512wECDSA) {
 801609a:	687b      	ldr	r3, [r7, #4]
 801609c:	f240 220e 	movw	r2, #526	@ 0x20e
 80160a0:	4293      	cmp	r3, r2
 80160a2:	d101      	bne.n	80160a8 <IsSigAlgoECDSA+0x30>
        return 1;
 80160a4:	2301      	movs	r3, #1
 80160a6:	e000      	b.n	80160aa <IsSigAlgoECDSA+0x32>
    }

    return 0;
 80160a8:	2300      	movs	r3, #0
}
 80160aa:	4618      	mov	r0, r3
 80160ac:	370c      	adds	r7, #12
 80160ae:	46bd      	mov	sp, r7
 80160b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80160b4:	4770      	bx	lr

080160b6 <IsSigAlgoECC>:
 * @param [in] algoOID  Algorithm OID.
 * @return  1 when is EC signing algorithm.
 * @return  0 otherwise.
 */
static WC_INLINE int IsSigAlgoECC(word32 algoOID)
{
 80160b6:	b580      	push	{r7, lr}
 80160b8:	b082      	sub	sp, #8
 80160ba:	af00      	add	r7, sp, #0
 80160bc:	6078      	str	r0, [r7, #4]
    (void)algoOID;

    return (0
        #ifdef HAVE_ECC
              || IsSigAlgoECDSA(algoOID)
 80160be:	6878      	ldr	r0, [r7, #4]
 80160c0:	f7ff ffda 	bl	8016078 <IsSigAlgoECDSA>
 80160c4:	4603      	mov	r3, r0
 80160c6:	2b00      	cmp	r3, #0
 80160c8:	bf14      	ite	ne
 80160ca:	2301      	movne	r3, #1
 80160cc:	2300      	moveq	r3, #0
 80160ce:	b2db      	uxtb	r3, r3
              || (algoOID == SPHINCS_SMALL_LEVEL1k)
              || (algoOID == SPHINCS_SMALL_LEVEL3k)
              || (algoOID == SPHINCS_SMALL_LEVEL5k)
        #endif
    );
}
 80160d0:	4618      	mov	r0, r3
 80160d2:	3708      	adds	r7, #8
 80160d4:	46bd      	mov	sp, r7
 80160d6:	bd80      	pop	{r7, pc}

080160d8 <wc_EncodeSignature>:
 * @return  Encoded data size on success.
 * @return  0 when dynamic memory allocation fails.
 */
word32 wc_EncodeSignature(byte* out, const byte* digest, word32 digSz,
                          int hashOID)
{
 80160d8:	b590      	push	{r4, r7, lr}
 80160da:	b091      	sub	sp, #68	@ 0x44
 80160dc:	af00      	add	r7, sp, #0
 80160de:	60f8      	str	r0, [r7, #12]
 80160e0:	60b9      	str	r1, [r7, #8]
 80160e2:	607a      	str	r2, [r7, #4]
 80160e4:	603b      	str	r3, [r7, #0]
    XMEMCPY(out + seqSz, algoArray, algoSz);
    XMEMCPY(out + seqSz + algoSz, digArray, encDigSz);

    return encDigSz + algoSz + seqSz;
#else
    DECL_ASNSETDATA(dataASN, digestInfoASN_Length);
 80160e6:	2300      	movs	r3, #0
 80160e8:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ret = 0;
 80160ea:	2300      	movs	r3, #0
 80160ec:	63bb      	str	r3, [r7, #56]	@ 0x38
    int sz = 0;
 80160ee:	2300      	movs	r3, #0
 80160f0:	633b      	str	r3, [r7, #48]	@ 0x30
    unsigned char dgst[WC_MAX_DIGEST_SIZE];

    CALLOC_ASNSETDATA(dataASN, digestInfoASN_Length, ret, NULL);
 80160f2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80160f4:	2b00      	cmp	r3, #0
 80160f6:	d109      	bne.n	801610c <wc_EncodeSignature+0x34>
 80160f8:	208c      	movs	r0, #140	@ 0x8c
 80160fa:	f008 fdbf 	bl	801ec7c <wolfSSL_Malloc>
 80160fe:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8016100:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016102:	2b00      	cmp	r3, #0
 8016104:	d102      	bne.n	801610c <wc_EncodeSignature+0x34>
 8016106:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801610a:	63bb      	str	r3, [r7, #56]	@ 0x38
 801610c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801610e:	2b00      	cmp	r3, #0
 8016110:	d104      	bne.n	801611c <wc_EncodeSignature+0x44>
 8016112:	2264      	movs	r2, #100	@ 0x64
 8016114:	2100      	movs	r1, #0
 8016116:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8016118:	f012 fd84 	bl	8028c24 <memset>

    if (ret == 0) {
 801611c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801611e:	2b00      	cmp	r3, #0
 8016120:	d12a      	bne.n	8016178 <wc_EncodeSignature+0xa0>
        /* Set hash OID and type. */
        SetASN_OID(&dataASN[DIGESTINFOASN_IDX_DIGALGO_OID], (word32)hashOID,
 8016122:	6838      	ldr	r0, [r7, #0]
 8016124:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016126:	3328      	adds	r3, #40	@ 0x28
 8016128:	f103 020c 	add.w	r2, r3, #12
 801612c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801612e:	f103 0428 	add.w	r4, r3, #40	@ 0x28
 8016132:	2100      	movs	r1, #0
 8016134:	f7fe f864 	bl	8014200 <OidFromId>
 8016138:	4603      	mov	r3, r0
 801613a:	60a3      	str	r3, [r4, #8]
                   oidHashType);
        /* Set digest. */
        if (digest == out) {
 801613c:	68ba      	ldr	r2, [r7, #8]
 801613e:	68fb      	ldr	r3, [r7, #12]
 8016140:	429a      	cmp	r2, r3
 8016142:	d109      	bne.n	8016158 <wc_EncodeSignature+0x80>
            XMEMCPY(dgst, digest, digSz);
 8016144:	f107 0310 	add.w	r3, r7, #16
 8016148:	687a      	ldr	r2, [r7, #4]
 801614a:	68b9      	ldr	r1, [r7, #8]
 801614c:	4618      	mov	r0, r3
 801614e:	f012 fe1a 	bl	8028d86 <memcpy>
            digest = dgst;
 8016152:	f107 0310 	add.w	r3, r7, #16
 8016156:	60bb      	str	r3, [r7, #8]
        }
        SetASN_Buffer(&dataASN[DIGESTINFOASN_IDX_DIGEST], digest, digSz);
 8016158:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801615a:	3350      	adds	r3, #80	@ 0x50
 801615c:	68ba      	ldr	r2, [r7, #8]
 801615e:	609a      	str	r2, [r3, #8]
 8016160:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016162:	3350      	adds	r3, #80	@ 0x50
 8016164:	687a      	ldr	r2, [r7, #4]
 8016166:	60da      	str	r2, [r3, #12]

        /* Calculate size of encoding. */
        ret = SizeASN_Items(digestInfoASN, dataASN, digestInfoASN_Length, &sz);
 8016168:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 801616c:	2205      	movs	r2, #5
 801616e:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8016170:	4810      	ldr	r0, [pc, #64]	@ (80161b4 <wc_EncodeSignature+0xdc>)
 8016172:	f7fc fcdf 	bl	8012b34 <SizeASN_Items>
 8016176:	63b8      	str	r0, [r7, #56]	@ 0x38
    }
    if (ret == 0) {
 8016178:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801617a:	2b00      	cmp	r3, #0
 801617c:	d108      	bne.n	8016190 <wc_EncodeSignature+0xb8>
        /* Encode PKCS#1 v1.5 RSA signature. */
        SetASN_Items(digestInfoASN, dataASN, digestInfoASN_Length, out);
 801617e:	68fb      	ldr	r3, [r7, #12]
 8016180:	2205      	movs	r2, #5
 8016182:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8016184:	480b      	ldr	r0, [pc, #44]	@ (80161b4 <wc_EncodeSignature+0xdc>)
 8016186:	f7fc fed9 	bl	8012f3c <SetASN_Items>
        ret = sz;
 801618a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801618c:	63bb      	str	r3, [r7, #56]	@ 0x38
 801618e:	e001      	b.n	8016194 <wc_EncodeSignature+0xbc>
    }
    else {
        /* Unsigned return type so 0 indicates error. */
        ret = 0;
 8016190:	2300      	movs	r3, #0
 8016192:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    FREE_ASNSETDATA(dataASN, NULL);
 8016194:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016196:	2b00      	cmp	r3, #0
 8016198:	d007      	beq.n	80161aa <wc_EncodeSignature+0xd2>
 801619a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801619c:	637b      	str	r3, [r7, #52]	@ 0x34
 801619e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80161a0:	2b00      	cmp	r3, #0
 80161a2:	d002      	beq.n	80161aa <wc_EncodeSignature+0xd2>
 80161a4:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80161a6:	f008 fd85 	bl	801ecb4 <wolfSSL_Free>
    return (word32)ret;
 80161aa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif
}
 80161ac:	4618      	mov	r0, r3
 80161ae:	3744      	adds	r7, #68	@ 0x44
 80161b0:	46bd      	mov	sp, r7
 80161b2:	bd90      	pop	{r4, r7, pc}
 80161b4:	080346ec 	.word	0x080346ec

080161b8 <InitSignatureCtx>:
 * @param [in, out] sigCtx  Signature context object.
 * @param [in]      heap    Dynamic memory hint.
 * @param [in]      devId   Hardware device identifier.
 */
void InitSignatureCtx(SignatureCtx* sigCtx, void* heap, int devId)
{
 80161b8:	b580      	push	{r7, lr}
 80161ba:	b084      	sub	sp, #16
 80161bc:	af00      	add	r7, sp, #0
 80161be:	60f8      	str	r0, [r7, #12]
 80161c0:	60b9      	str	r1, [r7, #8]
 80161c2:	607a      	str	r2, [r7, #4]
    if (sigCtx) {
 80161c4:	68fb      	ldr	r3, [r7, #12]
 80161c6:	2b00      	cmp	r3, #0
 80161c8:	d00a      	beq.n	80161e0 <InitSignatureCtx+0x28>
        XMEMSET(sigCtx, 0, sizeof(SignatureCtx));
 80161ca:	2238      	movs	r2, #56	@ 0x38
 80161cc:	2100      	movs	r1, #0
 80161ce:	68f8      	ldr	r0, [r7, #12]
 80161d0:	f012 fd28 	bl	8028c24 <memset>
        sigCtx->devId = devId;
 80161d4:	68fb      	ldr	r3, [r7, #12]
 80161d6:	687a      	ldr	r2, [r7, #4]
 80161d8:	619a      	str	r2, [r3, #24]
        sigCtx->heap = heap;
 80161da:	68fb      	ldr	r3, [r7, #12]
 80161dc:	68ba      	ldr	r2, [r7, #8]
 80161de:	601a      	str	r2, [r3, #0]
    }
}
 80161e0:	bf00      	nop
 80161e2:	3710      	adds	r7, #16
 80161e4:	46bd      	mov	sp, r7
 80161e6:	bd80      	pop	{r7, pc}

080161e8 <FreeSignatureCtx>:
/* Free dynamic data in a signature context object.
 *
 * @param [in, out] sigCtx  Signature context object.
 */
void FreeSignatureCtx(SignatureCtx* sigCtx)
{
 80161e8:	b580      	push	{r7, lr}
 80161ea:	b086      	sub	sp, #24
 80161ec:	af00      	add	r7, sp, #0
 80161ee:	6078      	str	r0, [r7, #4]
    if (sigCtx == NULL)
 80161f0:	687b      	ldr	r3, [r7, #4]
 80161f2:	2b00      	cmp	r3, #0
 80161f4:	d059      	beq.n	80162aa <FreeSignatureCtx+0xc2>
        return;

    XFREE(sigCtx->digest, sigCtx->heap, DYNAMIC_TYPE_DIGEST);
 80161f6:	687b      	ldr	r3, [r7, #4]
 80161f8:	685b      	ldr	r3, [r3, #4]
 80161fa:	617b      	str	r3, [r7, #20]
 80161fc:	697b      	ldr	r3, [r7, #20]
 80161fe:	2b00      	cmp	r3, #0
 8016200:	d002      	beq.n	8016208 <FreeSignatureCtx+0x20>
 8016202:	6978      	ldr	r0, [r7, #20]
 8016204:	f008 fd56 	bl	801ecb4 <wolfSSL_Free>
    sigCtx->digest = NULL;
 8016208:	687b      	ldr	r3, [r7, #4]
 801620a:	2200      	movs	r2, #0
 801620c:	605a      	str	r2, [r3, #4]
#if !(defined(NO_RSA) && defined(NO_DSA))
    XFREE(sigCtx->sigCpy, sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);
 801620e:	687b      	ldr	r3, [r7, #4]
 8016210:	68db      	ldr	r3, [r3, #12]
 8016212:	613b      	str	r3, [r7, #16]
 8016214:	693b      	ldr	r3, [r7, #16]
 8016216:	2b00      	cmp	r3, #0
 8016218:	d002      	beq.n	8016220 <FreeSignatureCtx+0x38>
 801621a:	6938      	ldr	r0, [r7, #16]
 801621c:	f008 fd4a 	bl	801ecb4 <wolfSSL_Free>
    sigCtx->sigCpy = NULL;
 8016220:	687b      	ldr	r3, [r7, #4]
 8016222:	2200      	movs	r2, #0
 8016224:	60da      	str	r2, [r3, #12]
#endif
#ifndef NO_ASN_CRYPT
    if (sigCtx->key.ptr) {
 8016226:	687b      	ldr	r3, [r7, #4]
 8016228:	695b      	ldr	r3, [r3, #20]
 801622a:	2b00      	cmp	r3, #0
 801622c:	d039      	beq.n	80162a2 <FreeSignatureCtx+0xba>
        switch (sigCtx->keyOID) {
 801622e:	687b      	ldr	r3, [r7, #4]
 8016230:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8016232:	f240 228e 	movw	r2, #654	@ 0x28e
 8016236:	4293      	cmp	r3, r2
 8016238:	d00b      	beq.n	8016252 <FreeSignatureCtx+0x6a>
 801623a:	f240 228e 	movw	r2, #654	@ 0x28e
 801623e:	4293      	cmp	r3, r2
 8016240:	d82b      	bhi.n	801629a <FreeSignatureCtx+0xb2>
 8016242:	f240 2206 	movw	r2, #518	@ 0x206
 8016246:	4293      	cmp	r3, r2
 8016248:	d015      	beq.n	8016276 <FreeSignatureCtx+0x8e>
 801624a:	f240 2285 	movw	r2, #645	@ 0x285
 801624e:	4293      	cmp	r3, r2
 8016250:	d123      	bne.n	801629a <FreeSignatureCtx+0xb2>
        #ifndef NO_RSA
            #ifdef WC_RSA_PSS
            case RSAPSSk:
            #endif
            case RSAk:
                wc_FreeRsaKey(sigCtx->key.rsa);
 8016252:	687b      	ldr	r3, [r7, #4]
 8016254:	695b      	ldr	r3, [r3, #20]
 8016256:	4618      	mov	r0, r3
 8016258:	f009 ff94 	bl	8020184 <wc_FreeRsaKey>
                XFREE(sigCtx->key.rsa, sigCtx->heap, DYNAMIC_TYPE_RSA);
 801625c:	687b      	ldr	r3, [r7, #4]
 801625e:	695b      	ldr	r3, [r3, #20]
 8016260:	60fb      	str	r3, [r7, #12]
 8016262:	68fb      	ldr	r3, [r7, #12]
 8016264:	2b00      	cmp	r3, #0
 8016266:	d002      	beq.n	801626e <FreeSignatureCtx+0x86>
 8016268:	68f8      	ldr	r0, [r7, #12]
 801626a:	f008 fd23 	bl	801ecb4 <wolfSSL_Free>
                sigCtx->key.rsa = NULL;
 801626e:	687b      	ldr	r3, [r7, #4]
 8016270:	2200      	movs	r2, #0
 8016272:	615a      	str	r2, [r3, #20]
                break;
 8016274:	e012      	b.n	801629c <FreeSignatureCtx+0xb4>
                    XFREE(sigCtx->key.ecc->nb_ctx, sigCtx->heap,
                          DYNAMIC_TYPE_TMP_BUFFER);
                }
            #endif /* WC_ECC_NONBLOCK && WOLFSSL_ASYNC_CRYPT_SW &&
                      WC_ASYNC_ENABLE_ECC */
                wc_ecc_free(sigCtx->key.ecc);
 8016276:	687b      	ldr	r3, [r7, #4]
 8016278:	695b      	ldr	r3, [r3, #20]
 801627a:	4618      	mov	r0, r3
 801627c:	f006 ff05 	bl	801d08a <wc_ecc_free>
                XFREE(sigCtx->key.ecc, sigCtx->heap, DYNAMIC_TYPE_ECC);
 8016280:	687b      	ldr	r3, [r7, #4]
 8016282:	695b      	ldr	r3, [r3, #20]
 8016284:	60bb      	str	r3, [r7, #8]
 8016286:	68bb      	ldr	r3, [r7, #8]
 8016288:	2b00      	cmp	r3, #0
 801628a:	d002      	beq.n	8016292 <FreeSignatureCtx+0xaa>
 801628c:	68b8      	ldr	r0, [r7, #8]
 801628e:	f008 fd11 	bl	801ecb4 <wolfSSL_Free>
                sigCtx->key.ecc = NULL;
 8016292:	687b      	ldr	r3, [r7, #4]
 8016294:	2200      	movs	r2, #0
 8016296:	615a      	str	r2, [r3, #20]
                break;
 8016298:	e000      	b.n	801629c <FreeSignatureCtx+0xb4>
                      DYNAMIC_TYPE_SPHINCS);
                sigCtx->key.sphincs = NULL;
                break;
        #endif /* HAVE_SPHINCS */
            default:
                break;
 801629a:	bf00      	nop
        } /* switch (keyOID) */
        sigCtx->key.ptr = NULL;
 801629c:	687b      	ldr	r3, [r7, #4]
 801629e:	2200      	movs	r2, #0
 80162a0:	615a      	str	r2, [r3, #20]
    }
#endif

    /* reset state, we are done */
    sigCtx->state = SIG_STATE_BEGIN;
 80162a2:	687b      	ldr	r3, [r7, #4]
 80162a4:	2200      	movs	r2, #0
 80162a6:	61da      	str	r2, [r3, #28]
 80162a8:	e000      	b.n	80162ac <FreeSignatureCtx+0xc4>
        return;
 80162aa:	bf00      	nop
}
 80162ac:	3718      	adds	r7, #24
 80162ae:	46bd      	mov	sp, r7
 80162b0:	bd80      	pop	{r7, pc}

080162b2 <HashForSignature>:

#if !defined(NO_ASN_CRYPT) && !defined(NO_HASH_WRAPPER)
static int HashForSignature(const byte* buf, word32 bufSz, word32 sigOID,
                            byte* digest, int* typeH, int* digestSz, int verify)
{
 80162b2:	b580      	push	{r7, lr}
 80162b4:	b086      	sub	sp, #24
 80162b6:	af00      	add	r7, sp, #0
 80162b8:	60f8      	str	r0, [r7, #12]
 80162ba:	60b9      	str	r1, [r7, #8]
 80162bc:	607a      	str	r2, [r7, #4]
 80162be:	603b      	str	r3, [r7, #0]
    int ret = 0;
 80162c0:	2300      	movs	r3, #0
 80162c2:	617b      	str	r3, [r7, #20]

    switch (sigOID) {
 80162c4:	687b      	ldr	r3, [r7, #4]
 80162c6:	f240 228f 	movw	r2, #655	@ 0x28f
 80162ca:	4293      	cmp	r3, r2
 80162cc:	d00b      	beq.n	80162e6 <HashForSignature+0x34>
 80162ce:	687b      	ldr	r3, [r7, #4]
 80162d0:	f5b3 7f24 	cmp.w	r3, #656	@ 0x290
 80162d4:	d218      	bcs.n	8016308 <HashForSignature+0x56>
 80162d6:	687b      	ldr	r3, [r7, #4]
 80162d8:	f5b3 7fd0 	cmp.w	r3, #416	@ 0x1a0
 80162dc:	d003      	beq.n	80162e6 <HashForSignature+0x34>
 80162de:	687b      	ldr	r3, [r7, #4]
 80162e0:	f5b3 7f03 	cmp.w	r3, #524	@ 0x20c
 80162e4:	d110      	bne.n	8016308 <HashForSignature+0x56>
    #endif
    #ifndef NO_SHA256
        case CTC_SHA256wRSA:
        case CTC_SHA256wECDSA:
        case CTC_SHA256wDSA:
            if ((ret = wc_Sha256Hash(buf, bufSz, digest)) == 0) {
 80162e6:	683a      	ldr	r2, [r7, #0]
 80162e8:	68b9      	ldr	r1, [r7, #8]
 80162ea:	68f8      	ldr	r0, [r7, #12]
 80162ec:	f008 fa20 	bl	801e730 <wc_Sha256Hash>
 80162f0:	6178      	str	r0, [r7, #20]
 80162f2:	697b      	ldr	r3, [r7, #20]
 80162f4:	2b00      	cmp	r3, #0
 80162f6:	d10b      	bne.n	8016310 <HashForSignature+0x5e>
                *typeH    = SHA256h;
 80162f8:	6a3b      	ldr	r3, [r7, #32]
 80162fa:	f44f 72cf 	mov.w	r2, #414	@ 0x19e
 80162fe:	601a      	str	r2, [r3, #0]
                *digestSz = WC_SHA256_DIGEST_SIZE;
 8016300:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016302:	2220      	movs	r2, #32
 8016304:	601a      	str	r2, [r3, #0]
            }
            break;
 8016306:	e003      	b.n	8016310 <HashForSignature+0x5e>
            /* Hashes done in signing operation. */
            break;
    #endif

        default:
            ret = HASH_TYPE_E;
 8016308:	f06f 03e7 	mvn.w	r3, #231	@ 0xe7
 801630c:	617b      	str	r3, [r7, #20]
 801630e:	e000      	b.n	8016312 <HashForSignature+0x60>
            break;
 8016310:	bf00      	nop
    (void)digest;
    (void)digestSz;
    (void)typeH;
    (void)verify;

    return ret;
 8016312:	697b      	ldr	r3, [r7, #20]
}
 8016314:	4618      	mov	r0, r3
 8016316:	3718      	adds	r7, #24
 8016318:	46bd      	mov	sp, r7
 801631a:	bd80      	pop	{r7, pc}

0801631c <ConfirmSignature>:
    const byte* buf, word32 bufSz,
    const byte* key, word32 keySz, word32 keyOID,
    const byte* sig, word32 sigSz, word32 sigOID,
    const byte* sigParams, word32 sigParamsSz,
    byte* rsaKeyIdx)
{
 801631c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016320:	b092      	sub	sp, #72	@ 0x48
 8016322:	af04      	add	r7, sp, #16
 8016324:	6178      	str	r0, [r7, #20]
 8016326:	6139      	str	r1, [r7, #16]
 8016328:	60fa      	str	r2, [r7, #12]
 801632a:	60bb      	str	r3, [r7, #8]
    int ret = WC_NO_ERR_TRACE(ASN_SIG_CONFIRM_E); /* default to failure */
 801632c:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 8016330:	637b      	str	r3, [r7, #52]	@ 0x34
#if defined(WOLFSSL_RENESAS_TSIP_TLS) || defined(WOLFSSL_RENESAS_FSPSM_TLS)
    CertAttribute* certatt = NULL;
#endif

    if (sigCtx == NULL || buf == NULL || bufSz == 0 || key == NULL ||
 8016332:	697b      	ldr	r3, [r7, #20]
 8016334:	2b00      	cmp	r3, #0
 8016336:	d011      	beq.n	801635c <ConfirmSignature+0x40>
 8016338:	693b      	ldr	r3, [r7, #16]
 801633a:	2b00      	cmp	r3, #0
 801633c:	d00e      	beq.n	801635c <ConfirmSignature+0x40>
 801633e:	68fb      	ldr	r3, [r7, #12]
 8016340:	2b00      	cmp	r3, #0
 8016342:	d00b      	beq.n	801635c <ConfirmSignature+0x40>
 8016344:	68bb      	ldr	r3, [r7, #8]
 8016346:	2b00      	cmp	r3, #0
 8016348:	d008      	beq.n	801635c <ConfirmSignature+0x40>
 801634a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801634c:	2b00      	cmp	r3, #0
 801634e:	d005      	beq.n	801635c <ConfirmSignature+0x40>
        keySz == 0 || sig == NULL || sigSz == 0) {
 8016350:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8016352:	2b00      	cmp	r3, #0
 8016354:	d002      	beq.n	801635c <ConfirmSignature+0x40>
 8016356:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8016358:	2b00      	cmp	r3, #0
 801635a:	d102      	bne.n	8016362 <ConfirmSignature+0x46>
        return BAD_FUNC_ARG;
 801635c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8016360:	e219      	b.n	8016796 <ConfirmSignature+0x47a>
        certatt->certSz = bufSz;
    }
#endif

#ifndef NO_ASN_CRYPT
    switch (sigCtx->state) {
 8016362:	697b      	ldr	r3, [r7, #20]
 8016364:	69db      	ldr	r3, [r3, #28]
 8016366:	2b04      	cmp	r3, #4
 8016368:	f200 8202 	bhi.w	8016770 <ConfirmSignature+0x454>
 801636c:	a201      	add	r2, pc, #4	@ (adr r2, 8016374 <ConfirmSignature+0x58>)
 801636e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8016372:	bf00      	nop
 8016374:	08016389 	.word	0x08016389
 8016378:	080163c5 	.word	0x080163c5
 801637c:	08016473 	.word	0x08016473
 8016380:	080165ad 	.word	0x080165ad
 8016384:	08016663 	.word	0x08016663
        case SIG_STATE_BEGIN:
        {
            sigCtx->keyOID = keyOID; /* must set early for cleanup */
 8016388:	697b      	ldr	r3, [r7, #20]
 801638a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801638c:	629a      	str	r2, [r3, #40]	@ 0x28

            sigCtx->digest = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, sigCtx->heap,
 801638e:	2020      	movs	r0, #32
 8016390:	f008 fc74 	bl	801ec7c <wolfSSL_Malloc>
 8016394:	4602      	mov	r2, r0
 8016396:	697b      	ldr	r3, [r7, #20]
 8016398:	605a      	str	r2, [r3, #4]
                                                    DYNAMIC_TYPE_DIGEST);
            if (sigCtx->digest == NULL) {
 801639a:	697b      	ldr	r3, [r7, #20]
 801639c:	685b      	ldr	r3, [r3, #4]
 801639e:	2b00      	cmp	r3, #0
 80163a0:	d103      	bne.n	80163aa <ConfirmSignature+0x8e>
                ERROR_OUT(MEMORY_E, exit_cs);
 80163a2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80163a6:	637b      	str	r3, [r7, #52]	@ 0x34
 80163a8:	e1f1      	b.n	801678e <ConfirmSignature+0x472>
            }

        #if !defined(NO_RSA) && defined(WC_RSA_PSS)
            /* RSA PSS Defaults */
            sigCtx->hash = WC_HASH_TYPE_SHA;
 80163aa:	697b      	ldr	r3, [r7, #20]
 80163ac:	2204      	movs	r2, #4
 80163ae:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c
            sigCtx->mgf = WC_MGF1SHA1;
 80163b2:	697b      	ldr	r3, [r7, #20]
 80163b4:	221a      	movs	r2, #26
 80163b6:	631a      	str	r2, [r3, #48]	@ 0x30
            sigCtx->saltLen = 20;
 80163b8:	697b      	ldr	r3, [r7, #20]
 80163ba:	2214      	movs	r2, #20
 80163bc:	635a      	str	r2, [r3, #52]	@ 0x34
        #endif

            sigCtx->state = SIG_STATE_HASH;
 80163be:	697b      	ldr	r3, [r7, #20]
 80163c0:	2201      	movs	r2, #1
 80163c2:	61da      	str	r2, [r3, #28]
        FALL_THROUGH;

        case SIG_STATE_HASH:
        {
        #if !defined(NO_RSA) && defined(WC_RSA_PSS)
            if (sigOID == RSAPSSk) {
 80163c4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80163c6:	f240 228e 	movw	r2, #654	@ 0x28e
 80163ca:	4293      	cmp	r3, r2
 80163cc:	d139      	bne.n	8016442 <ConfirmSignature+0x126>
                word32 fakeSigOID = 0;
 80163ce:	2300      	movs	r3, #0
 80163d0:	623b      	str	r3, [r7, #32]
                ret = DecodeRsaPssParams(sigParams, sigParamsSz, &sigCtx->hash,
 80163d2:	697b      	ldr	r3, [r7, #20]
 80163d4:	f103 022c 	add.w	r2, r3, #44	@ 0x2c
 80163d8:	697b      	ldr	r3, [r7, #20]
 80163da:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 80163de:	697b      	ldr	r3, [r7, #20]
 80163e0:	3334      	adds	r3, #52	@ 0x34
 80163e2:	9300      	str	r3, [sp, #0]
 80163e4:	460b      	mov	r3, r1
 80163e6:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 80163e8:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80163ea:	f7fe fb4b 	bl	8014a84 <DecodeRsaPssParams>
 80163ee:	6378      	str	r0, [r7, #52]	@ 0x34
                    &sigCtx->mgf, &sigCtx->saltLen);
                if (ret != 0) {
 80163f0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80163f2:	2b00      	cmp	r3, #0
 80163f4:	f040 81be 	bne.w	8016774 <ConfirmSignature+0x458>
                    goto exit_cs;
                }
                ret = RsaPssHashOidToSigOid(sigCtx->hash, &fakeSigOID);
 80163f8:	697b      	ldr	r3, [r7, #20]
 80163fa:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
 80163fe:	461a      	mov	r2, r3
 8016400:	f107 0320 	add.w	r3, r7, #32
 8016404:	4619      	mov	r1, r3
 8016406:	4610      	mov	r0, r2
 8016408:	f7fe fb22 	bl	8014a50 <RsaPssHashOidToSigOid>
 801640c:	6378      	str	r0, [r7, #52]	@ 0x34
                if (ret != 0) {
 801640e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016410:	2b00      	cmp	r3, #0
 8016412:	f040 81b1 	bne.w	8016778 <ConfirmSignature+0x45c>
                    goto exit_cs;
                }
                /* Decode parameters. */
                ret = HashForSignature(buf, bufSz, fakeSigOID, sigCtx->digest,
 8016416:	6a39      	ldr	r1, [r7, #32]
 8016418:	697b      	ldr	r3, [r7, #20]
 801641a:	6858      	ldr	r0, [r3, #4]
 801641c:	697b      	ldr	r3, [r7, #20]
 801641e:	3320      	adds	r3, #32
 8016420:	697a      	ldr	r2, [r7, #20]
 8016422:	3224      	adds	r2, #36	@ 0x24
 8016424:	2401      	movs	r4, #1
 8016426:	9402      	str	r4, [sp, #8]
 8016428:	9201      	str	r2, [sp, #4]
 801642a:	9300      	str	r3, [sp, #0]
 801642c:	4603      	mov	r3, r0
 801642e:	460a      	mov	r2, r1
 8016430:	68f9      	ldr	r1, [r7, #12]
 8016432:	6938      	ldr	r0, [r7, #16]
 8016434:	f7ff ff3d 	bl	80162b2 <HashForSignature>
 8016438:	6378      	str	r0, [r7, #52]	@ 0x34
                    &sigCtx->typeH, &sigCtx->digestSz, 1);
                if (ret != 0) {
 801643a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801643c:	2b00      	cmp	r3, #0
 801643e:	d015      	beq.n	801646c <ConfirmSignature+0x150>
                    goto exit_cs;
 8016440:	e1a5      	b.n	801678e <ConfirmSignature+0x472>
                ; /* SM2 hash requires public key. Done later. */
            }
            else
        #endif
            {
                ret = HashForSignature(buf, bufSz, sigOID, sigCtx->digest,
 8016442:	697b      	ldr	r3, [r7, #20]
 8016444:	6859      	ldr	r1, [r3, #4]
 8016446:	697b      	ldr	r3, [r7, #20]
 8016448:	3320      	adds	r3, #32
 801644a:	697a      	ldr	r2, [r7, #20]
 801644c:	3224      	adds	r2, #36	@ 0x24
 801644e:	2001      	movs	r0, #1
 8016450:	9002      	str	r0, [sp, #8]
 8016452:	9201      	str	r2, [sp, #4]
 8016454:	9300      	str	r3, [sp, #0]
 8016456:	460b      	mov	r3, r1
 8016458:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 801645a:	68f9      	ldr	r1, [r7, #12]
 801645c:	6938      	ldr	r0, [r7, #16]
 801645e:	f7ff ff28 	bl	80162b2 <HashForSignature>
 8016462:	6378      	str	r0, [r7, #52]	@ 0x34
                                       &sigCtx->typeH, &sigCtx->digestSz, 1);
                if (ret != 0) {
 8016464:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016466:	2b00      	cmp	r3, #0
 8016468:	f040 8188 	bne.w	801677c <ConfirmSignature+0x460>
                    goto exit_cs;
                }
            }

            sigCtx->state = SIG_STATE_KEY;
 801646c:	697b      	ldr	r3, [r7, #20]
 801646e:	2202      	movs	r2, #2
 8016470:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_HASH */
        FALL_THROUGH;

        case SIG_STATE_KEY:
        {
            switch (keyOID) {
 8016472:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016474:	f240 228e 	movw	r2, #654	@ 0x28e
 8016478:	4293      	cmp	r3, r2
 801647a:	d00f      	beq.n	801649c <ConfirmSignature+0x180>
 801647c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801647e:	f240 228e 	movw	r2, #654	@ 0x28e
 8016482:	4293      	cmp	r3, r2
 8016484:	f200 8086 	bhi.w	8016594 <ConfirmSignature+0x278>
 8016488:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801648a:	f240 2206 	movw	r2, #518	@ 0x206
 801648e:	4293      	cmp	r3, r2
 8016490:	d051      	beq.n	8016536 <ConfirmSignature+0x21a>
 8016492:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016494:	f240 2285 	movw	r2, #645	@ 0x285
 8016498:	4293      	cmp	r3, r2
 801649a:	d17b      	bne.n	8016594 <ConfirmSignature+0x278>
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                #endif
                case RSAk:
                {
                    word32 idx = 0;
 801649c:	2300      	movs	r3, #0
 801649e:	61fb      	str	r3, [r7, #28]

                    sigCtx->key.rsa = (RsaKey*)XMALLOC(sizeof(RsaKey),
 80164a0:	f241 107c 	movw	r0, #4476	@ 0x117c
 80164a4:	f008 fbea 	bl	801ec7c <wolfSSL_Malloc>
 80164a8:	4602      	mov	r2, r0
 80164aa:	697b      	ldr	r3, [r7, #20]
 80164ac:	615a      	str	r2, [r3, #20]
                                                sigCtx->heap, DYNAMIC_TYPE_RSA);
                    if (sigCtx->key.rsa == NULL) {
 80164ae:	697b      	ldr	r3, [r7, #20]
 80164b0:	695b      	ldr	r3, [r3, #20]
 80164b2:	2b00      	cmp	r3, #0
 80164b4:	d103      	bne.n	80164be <ConfirmSignature+0x1a2>
                        ERROR_OUT(MEMORY_E, exit_cs);
 80164b6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80164ba:	637b      	str	r3, [r7, #52]	@ 0x34
 80164bc:	e167      	b.n	801678e <ConfirmSignature+0x472>
                    }
                    if ((ret = wc_InitRsaKey_ex(sigCtx->key.rsa, sigCtx->heap,
 80164be:	697b      	ldr	r3, [r7, #20]
 80164c0:	6958      	ldr	r0, [r3, #20]
 80164c2:	697b      	ldr	r3, [r7, #20]
 80164c4:	6819      	ldr	r1, [r3, #0]
 80164c6:	697b      	ldr	r3, [r7, #20]
 80164c8:	699b      	ldr	r3, [r3, #24]
 80164ca:	461a      	mov	r2, r3
 80164cc:	f009 fdc6 	bl	802005c <wc_InitRsaKey_ex>
 80164d0:	6378      	str	r0, [r7, #52]	@ 0x34
 80164d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80164d4:	2b00      	cmp	r3, #0
 80164d6:	f040 8153 	bne.w	8016780 <ConfirmSignature+0x464>
                                                        sigCtx->devId)) != 0) {
                        goto exit_cs;
                    }
                    sigCtx->sigCpy = (byte*)XMALLOC(sigSz, sigCtx->heap,
 80164da:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 80164dc:	f008 fbce 	bl	801ec7c <wolfSSL_Malloc>
 80164e0:	4602      	mov	r2, r0
 80164e2:	697b      	ldr	r3, [r7, #20]
 80164e4:	60da      	str	r2, [r3, #12]
                                                        DYNAMIC_TYPE_SIGNATURE);
                    if (sigCtx->sigCpy == NULL) {
 80164e6:	697b      	ldr	r3, [r7, #20]
 80164e8:	68db      	ldr	r3, [r3, #12]
 80164ea:	2b00      	cmp	r3, #0
 80164ec:	d103      	bne.n	80164f6 <ConfirmSignature+0x1da>
                        ERROR_OUT(MEMORY_E, exit_cs);
 80164ee:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80164f2:	637b      	str	r3, [r7, #52]	@ 0x34
 80164f4:	e14b      	b.n	801678e <ConfirmSignature+0x472>
                    }
                    if (sigSz > MAX_ENCODED_SIG_SZ) {
 80164f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80164f8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80164fc:	d903      	bls.n	8016506 <ConfirmSignature+0x1ea>
                        WOLFSSL_MSG("Verify Signature is too big");
                        ERROR_OUT(BUFFER_E, exit_cs);
 80164fe:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8016502:	637b      	str	r3, [r7, #52]	@ 0x34
 8016504:	e143      	b.n	801678e <ConfirmSignature+0x472>
                    }
                    if ((ret = wc_RsaPublicKeyDecode(key, &idx, sigCtx->key.rsa,
 8016506:	697b      	ldr	r3, [r7, #20]
 8016508:	695a      	ldr	r2, [r3, #20]
 801650a:	f107 011c 	add.w	r1, r7, #28
 801650e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8016510:	68b8      	ldr	r0, [r7, #8]
 8016512:	f7fe fe65 	bl	80151e0 <wc_RsaPublicKeyDecode>
 8016516:	6378      	str	r0, [r7, #52]	@ 0x34
 8016518:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801651a:	2b00      	cmp	r3, #0
 801651c:	f040 8132 	bne.w	8016784 <ConfirmSignature+0x468>
                                                                 keySz)) != 0) {
                        WOLFSSL_MSG("ASN Key decode error RSA");
                        WOLFSSL_ERROR_VERBOSE(ret);
                        goto exit_cs;
                    }
                    XMEMCPY(sigCtx->sigCpy, sig, sigSz);
 8016520:	697b      	ldr	r3, [r7, #20]
 8016522:	68db      	ldr	r3, [r3, #12]
 8016524:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8016526:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 8016528:	4618      	mov	r0, r3
 801652a:	f012 fc2c 	bl	8028d86 <memcpy>
                    sigCtx->out = NULL;
 801652e:	697b      	ldr	r3, [r7, #20]
 8016530:	2200      	movs	r2, #0
 8016532:	609a      	str	r2, [r3, #8]
 8016534:	e033      	b.n	801659e <ConfirmSignature+0x282>
            #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                case SM2k:
            #endif
                case ECDSAk:
                {
                    word32 idx = 0;
 8016536:	2300      	movs	r3, #0
 8016538:	61bb      	str	r3, [r7, #24]
                defined(WC_ASYNC_ENABLE_ECC)
                    ecc_nb_ctx_t* nbCtx;
            #endif /* WC_ECC_NONBLOCK && WOLFSSL_ASYNC_CRYPT_SW &&
                      WC_ASYNC_ENABLE_ECC */

                    sigCtx->verify = 0;
 801653a:	697b      	ldr	r3, [r7, #20]
 801653c:	2200      	movs	r2, #0
 801653e:	611a      	str	r2, [r3, #16]
                    sigCtx->key.ecc = (ecc_key*)XMALLOC(sizeof(ecc_key),
 8016540:	f44f 70b8 	mov.w	r0, #368	@ 0x170
 8016544:	f008 fb9a 	bl	801ec7c <wolfSSL_Malloc>
 8016548:	4602      	mov	r2, r0
 801654a:	697b      	ldr	r3, [r7, #20]
 801654c:	615a      	str	r2, [r3, #20]
                                                sigCtx->heap, DYNAMIC_TYPE_ECC);
                    if (sigCtx->key.ecc == NULL) {
 801654e:	697b      	ldr	r3, [r7, #20]
 8016550:	695b      	ldr	r3, [r3, #20]
 8016552:	2b00      	cmp	r3, #0
 8016554:	d103      	bne.n	801655e <ConfirmSignature+0x242>
                        ERROR_OUT(MEMORY_E, exit_cs);
 8016556:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801655a:	637b      	str	r3, [r7, #52]	@ 0x34
 801655c:	e117      	b.n	801678e <ConfirmSignature+0x472>
                    }
                    if ((ret = wc_ecc_init_ex(sigCtx->key.ecc, sigCtx->heap,
 801655e:	697b      	ldr	r3, [r7, #20]
 8016560:	6958      	ldr	r0, [r3, #20]
 8016562:	697b      	ldr	r3, [r7, #20]
 8016564:	6819      	ldr	r1, [r3, #0]
 8016566:	697b      	ldr	r3, [r7, #20]
 8016568:	699b      	ldr	r3, [r3, #24]
 801656a:	461a      	mov	r2, r3
 801656c:	f006 fcf2 	bl	801cf54 <wc_ecc_init_ex>
 8016570:	6378      	str	r0, [r7, #52]	@ 0x34
 8016572:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016574:	2b00      	cmp	r3, #0
 8016576:	f2c0 8107 	blt.w	8016788 <ConfirmSignature+0x46c>
                            goto exit_cs;
                        }
                    }
            #endif /* WC_ECC_NONBLOCK && WOLFSSL_ASYNC_CRYPT_SW &&
                      WC_ASYNC_ENABLE_ECC */
                    ret = wc_EccPublicKeyDecode(key, &idx, sigCtx->key.ecc,
 801657a:	697b      	ldr	r3, [r7, #20]
 801657c:	695a      	ldr	r2, [r3, #20]
 801657e:	f107 0118 	add.w	r1, r7, #24
 8016582:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8016584:	68b8      	ldr	r0, [r7, #8]
 8016586:	f003 fd95 	bl	801a0b4 <wc_EccPublicKeyDecode>
 801658a:	6378      	str	r0, [r7, #52]	@ 0x34
                                                                         keySz);
                    if (ret < 0) {
 801658c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801658e:	2b00      	cmp	r3, #0
 8016590:	da04      	bge.n	801659c <ConfirmSignature+0x280>
                        WOLFSSL_MSG("ASN Key import error ECC");
                        WOLFSSL_ERROR_VERBOSE(ret);
                        goto exit_cs;
 8016592:	e0fc      	b.n	801678e <ConfirmSignature+0x472>
                    break;
                }
            #endif /* HAVE_SPHINCS */
                default:
                    WOLFSSL_MSG("Verify Key type unknown");
                    ret = ASN_UNKNOWN_OID_E;
 8016594:	f06f 0393 	mvn.w	r3, #147	@ 0x93
 8016598:	637b      	str	r3, [r7, #52]	@ 0x34
                    WOLFSSL_ERROR_VERBOSE(ret);
                    break;
 801659a:	e000      	b.n	801659e <ConfirmSignature+0x282>
                    break;
 801659c:	bf00      	nop
            } /* switch (keyOID) */

            if (ret != 0) {
 801659e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80165a0:	2b00      	cmp	r3, #0
 80165a2:	f040 80f3 	bne.w	801678c <ConfirmSignature+0x470>
                goto exit_cs;
            }

            sigCtx->state = SIG_STATE_DO;
 80165a6:	697b      	ldr	r3, [r7, #20]
 80165a8:	2203      	movs	r2, #3
 80165aa:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_KEY */
        FALL_THROUGH;

        case SIG_STATE_DO:
        {
            switch (keyOID) {
 80165ac:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80165ae:	f240 228e 	movw	r2, #654	@ 0x28e
 80165b2:	4293      	cmp	r3, r2
 80165b4:	d00e      	beq.n	80165d4 <ConfirmSignature+0x2b8>
 80165b6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80165b8:	f240 228e 	movw	r2, #654	@ 0x28e
 80165bc:	4293      	cmp	r3, r2
 80165be:	d845      	bhi.n	801664c <ConfirmSignature+0x330>
 80165c0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80165c2:	f240 2206 	movw	r2, #518	@ 0x206
 80165c6:	4293      	cmp	r3, r2
 80165c8:	d02d      	beq.n	8016626 <ConfirmSignature+0x30a>
 80165ca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80165cc:	f240 2285 	movw	r2, #645	@ 0x285
 80165d0:	4293      	cmp	r3, r2
 80165d2:	d13b      	bne.n	801664c <ConfirmSignature+0x330>
            #ifndef NO_RSA
                case RSAk:
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                if (sigOID == RSAPSSk) {
 80165d4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80165d6:	f240 228e 	movw	r2, #654	@ 0x28e
 80165da:	4293      	cmp	r3, r2
 80165dc:	d117      	bne.n	801660e <ConfirmSignature+0x2f2>
                    /* TODO: pkCbRsaPss - RSA PSS callback. */
                    ret = wc_RsaPSS_VerifyInline_ex(sigCtx->sigCpy, sigSz,
 80165de:	697b      	ldr	r3, [r7, #20]
 80165e0:	68d8      	ldr	r0, [r3, #12]
 80165e2:	697b      	ldr	r3, [r7, #20]
 80165e4:	f103 0408 	add.w	r4, r3, #8
 80165e8:	697b      	ldr	r3, [r7, #20]
 80165ea:	f893 502c 	ldrb.w	r5, [r3, #44]	@ 0x2c
 80165ee:	697b      	ldr	r3, [r7, #20]
 80165f0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80165f2:	697a      	ldr	r2, [r7, #20]
 80165f4:	6b52      	ldr	r2, [r2, #52]	@ 0x34
                        &sigCtx->out, sigCtx->hash, sigCtx->mgf,
                        sigCtx->saltLen, sigCtx->key.rsa);
 80165f6:	6979      	ldr	r1, [r7, #20]
 80165f8:	6949      	ldr	r1, [r1, #20]
                    ret = wc_RsaPSS_VerifyInline_ex(sigCtx->sigCpy, sigSz,
 80165fa:	9102      	str	r1, [sp, #8]
 80165fc:	9201      	str	r2, [sp, #4]
 80165fe:	9300      	str	r3, [sp, #0]
 8016600:	462b      	mov	r3, r5
 8016602:	4622      	mov	r2, r4
 8016604:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8016606:	f00a ff21 	bl	802144c <wc_RsaPSS_VerifyInline_ex>
 801660a:	6378      	str	r0, [r7, #52]	@ 0x34
                    {
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
                                                 &sigCtx->out, sigCtx->key.rsa);
                    }
                }
                break;
 801660c:	e01f      	b.n	801664e <ConfirmSignature+0x332>
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
 801660e:	697b      	ldr	r3, [r7, #20]
 8016610:	68d8      	ldr	r0, [r3, #12]
 8016612:	697b      	ldr	r3, [r7, #20]
 8016614:	f103 0208 	add.w	r2, r3, #8
                                                 &sigCtx->out, sigCtx->key.rsa);
 8016618:	697b      	ldr	r3, [r7, #20]
 801661a:	695b      	ldr	r3, [r3, #20]
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
 801661c:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801661e:	f00a fee6 	bl	80213ee <wc_RsaSSL_VerifyInline>
 8016622:	6378      	str	r0, [r7, #52]	@ 0x34
                break;
 8016624:	e013      	b.n	801664e <ConfirmSignature+0x332>
                    if (!sigCtx->pkCbEcc ||
                        ret == WC_NO_ERR_TRACE(CRYPTOCB_UNAVAILABLE))
                #endif /* WOLFSSL_RENESAS_FSPSM_TLS */
                #endif /* HAVE_PK_CALLBACKS */
                    {
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 8016626:	697b      	ldr	r3, [r7, #20]
 8016628:	6859      	ldr	r1, [r3, #4]
                            (word32)sigCtx->digestSz, &sigCtx->verify,
 801662a:	697b      	ldr	r3, [r7, #20]
 801662c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 801662e:	4618      	mov	r0, r3
 8016630:	697b      	ldr	r3, [r7, #20]
 8016632:	3310      	adds	r3, #16
                            sigCtx->key.ecc);
 8016634:	697a      	ldr	r2, [r7, #20]
 8016636:	6952      	ldr	r2, [r2, #20]
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 8016638:	9201      	str	r2, [sp, #4]
 801663a:	9300      	str	r3, [sp, #0]
 801663c:	4603      	mov	r3, r0
 801663e:	460a      	mov	r2, r1
 8016640:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8016642:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8016644:	f007 f9b2 	bl	801d9ac <wc_ecc_verify_hash>
 8016648:	6378      	str	r0, [r7, #52]	@ 0x34
                    }
                    break;
 801664a:	e000      	b.n	801664e <ConfirmSignature+0x332>
                                                sigCtx->key.sphincs);
                    break;
                }
            #endif /* HAVE_SPHINCS */
                default:
                    break;
 801664c:	bf00      	nop
            if (ret == WC_NO_ERR_TRACE(WC_PENDING_E)) {
                goto exit_cs;
            }
        #endif

            if (ret < 0) {
 801664e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016650:	2b00      	cmp	r3, #0
 8016652:	da03      	bge.n	801665c <ConfirmSignature+0x340>
                /* treat all errors as ASN_SIG_CONFIRM_E */
                ret = ASN_SIG_CONFIRM_E;
 8016654:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 8016658:	637b      	str	r3, [r7, #52]	@ 0x34
                WOLFSSL_ERROR_VERBOSE(ret);
                goto exit_cs;
 801665a:	e098      	b.n	801678e <ConfirmSignature+0x472>
            }

            sigCtx->state = SIG_STATE_CHECK;
 801665c:	697b      	ldr	r3, [r7, #20]
 801665e:	2204      	movs	r2, #4
 8016660:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_DO */
        FALL_THROUGH;

        case SIG_STATE_CHECK:
        {
            switch (keyOID) {
 8016662:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016664:	f240 228e 	movw	r2, #654	@ 0x28e
 8016668:	4293      	cmp	r3, r2
 801666a:	d00e      	beq.n	801668a <ConfirmSignature+0x36e>
 801666c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801666e:	f240 228e 	movw	r2, #654	@ 0x28e
 8016672:	4293      	cmp	r3, r2
 8016674:	d878      	bhi.n	8016768 <ConfirmSignature+0x44c>
 8016676:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016678:	f240 2206 	movw	r2, #518	@ 0x206
 801667c:	4293      	cmp	r3, r2
 801667e:	d068      	beq.n	8016752 <ConfirmSignature+0x436>
 8016680:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016682:	f240 2285 	movw	r2, #645	@ 0x285
 8016686:	4293      	cmp	r3, r2
 8016688:	d16e      	bne.n	8016768 <ConfirmSignature+0x44c>
            #ifndef NO_RSA
                case RSAk:
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                if (sigOID == RSAPSSk) {
 801668a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801668c:	f240 228e 	movw	r2, #654	@ 0x28e
 8016690:	4293      	cmp	r3, r2
 8016692:	d123      	bne.n	80166dc <ConfirmSignature+0x3c0>
                       (HAVE_FIPS_VERSION == 2))
                    ret = wc_RsaPSS_CheckPadding_ex(sigCtx->digest,
                        sigCtx->digestSz, sigCtx->out, ret, sigCtx->hash,
                        sigCtx->saltLen, 0);
                #else
                    ret = wc_RsaPSS_CheckPadding_ex2(sigCtx->digest,
 8016694:	697b      	ldr	r3, [r7, #20]
 8016696:	685e      	ldr	r6, [r3, #4]
                        (word32)sigCtx->digestSz, sigCtx->out, (word32)ret, sigCtx->hash,
 8016698:	697b      	ldr	r3, [r7, #20]
 801669a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                    ret = wc_RsaPSS_CheckPadding_ex2(sigCtx->digest,
 801669c:	4698      	mov	r8, r3
 801669e:	697b      	ldr	r3, [r7, #20]
 80166a0:	689b      	ldr	r3, [r3, #8]
 80166a2:	607b      	str	r3, [r7, #4]
 80166a4:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80166a6:	6039      	str	r1, [r7, #0]
 80166a8:	697b      	ldr	r3, [r7, #20]
 80166aa:	f893 402c 	ldrb.w	r4, [r3, #44]	@ 0x2c
 80166ae:	697b      	ldr	r3, [r7, #20]
 80166b0:	6b5d      	ldr	r5, [r3, #52]	@ 0x34
                        sigCtx->saltLen, wc_RsaEncryptSize(sigCtx->key.rsa) * 8,
 80166b2:	697b      	ldr	r3, [r7, #20]
 80166b4:	695b      	ldr	r3, [r3, #20]
 80166b6:	4618      	mov	r0, r3
 80166b8:	f00a ff8e 	bl	80215d8 <wc_RsaEncryptSize>
 80166bc:	4603      	mov	r3, r0
                    ret = wc_RsaPSS_CheckPadding_ex2(sigCtx->digest,
 80166be:	00db      	lsls	r3, r3, #3
 80166c0:	697a      	ldr	r2, [r7, #20]
 80166c2:	6812      	ldr	r2, [r2, #0]
 80166c4:	9203      	str	r2, [sp, #12]
 80166c6:	9302      	str	r3, [sp, #8]
 80166c8:	9501      	str	r5, [sp, #4]
 80166ca:	9400      	str	r4, [sp, #0]
 80166cc:	683b      	ldr	r3, [r7, #0]
 80166ce:	687a      	ldr	r2, [r7, #4]
 80166d0:	4641      	mov	r1, r8
 80166d2:	4630      	mov	r0, r6
 80166d4:	f00a fee9 	bl	80214aa <wc_RsaPSS_CheckPadding_ex2>
 80166d8:	6378      	str	r0, [r7, #52]	@ 0x34
                        sigCtx->heap);
                #endif
                    break;
 80166da:	e048      	b.n	801676e <ConfirmSignature+0x452>
                #if defined(WOLFSSL_RENESAS_TSIP_TLS) || \
                                            defined(WOLFSSL_RENESAS_FSPSM_TLS)
                    if (sigCtx->CertAtt.verifyByTSIP_SCE == 1) break;
                #endif
                #ifdef WOLFSSL_SMALL_STACK
                    byte* encodedSig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,
 80166dc:	f44f 7000 	mov.w	r0, #512	@ 0x200
 80166e0:	f008 facc 	bl	801ec7c <wolfSSL_Malloc>
 80166e4:	6338      	str	r0, [r7, #48]	@ 0x30
                                        sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);
                    if (encodedSig == NULL) {
 80166e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80166e8:	2b00      	cmp	r3, #0
 80166ea:	d103      	bne.n	80166f4 <ConfirmSignature+0x3d8>
                        ERROR_OUT(MEMORY_E, exit_cs);
 80166ec:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80166f0:	637b      	str	r3, [r7, #52]	@ 0x34
 80166f2:	e04c      	b.n	801678e <ConfirmSignature+0x472>
                    }
                #else
                    byte encodedSig[MAX_ENCODED_SIG_SZ];
                #endif

                    verifySz = ret;
 80166f4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80166f6:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    /* make sure we're right justified */
                    encodedSigSz = (int)wc_EncodeSignature(encodedSig,
                            sigCtx->digest, (word32)sigCtx->digestSz,
 80166f8:	697b      	ldr	r3, [r7, #20]
 80166fa:	6859      	ldr	r1, [r3, #4]
 80166fc:	697b      	ldr	r3, [r7, #20]
 80166fe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                    encodedSigSz = (int)wc_EncodeSignature(encodedSig,
 8016700:	461a      	mov	r2, r3
 8016702:	697b      	ldr	r3, [r7, #20]
 8016704:	6a1b      	ldr	r3, [r3, #32]
 8016706:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8016708:	f7ff fce6 	bl	80160d8 <wc_EncodeSignature>
 801670c:	4603      	mov	r3, r0
 801670e:	62bb      	str	r3, [r7, #40]	@ 0x28
                            sigCtx->typeH);
                    if (encodedSigSz == verifySz && sigCtx->out != NULL &&
 8016710:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8016712:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016714:	429a      	cmp	r2, r3
 8016716:	d110      	bne.n	801673a <ConfirmSignature+0x41e>
 8016718:	697b      	ldr	r3, [r7, #20]
 801671a:	689b      	ldr	r3, [r3, #8]
 801671c:	2b00      	cmp	r3, #0
 801671e:	d00c      	beq.n	801673a <ConfirmSignature+0x41e>
                        XMEMCMP(sigCtx->out, encodedSig,
 8016720:	697b      	ldr	r3, [r7, #20]
 8016722:	689b      	ldr	r3, [r3, #8]
 8016724:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8016726:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8016728:	4618      	mov	r0, r3
 801672a:	f012 fa51 	bl	8028bd0 <memcmp>
 801672e:	4603      	mov	r3, r0
                    if (encodedSigSz == verifySz && sigCtx->out != NULL &&
 8016730:	2b00      	cmp	r3, #0
 8016732:	d102      	bne.n	801673a <ConfirmSignature+0x41e>
                            (size_t)encodedSigSz) == 0) {
                        ret = 0;
 8016734:	2300      	movs	r3, #0
 8016736:	637b      	str	r3, [r7, #52]	@ 0x34
 8016738:	e002      	b.n	8016740 <ConfirmSignature+0x424>
                    }
                    else {
                        WOLFSSL_MSG("RSA SSL verify match encode error");
                        ret = ASN_SIG_CONFIRM_E;
 801673a:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 801673e:	637b      	str	r3, [r7, #52]	@ 0x34
                        WOLFSSL_ERROR_VERBOSE(ret);
                    }

                #ifdef WOLFSSL_SMALL_STACK
                    XFREE(encodedSig, sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);
 8016740:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016742:	627b      	str	r3, [r7, #36]	@ 0x24
 8016744:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016746:	2b00      	cmp	r3, #0
 8016748:	d010      	beq.n	801676c <ConfirmSignature+0x450>
 801674a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801674c:	f008 fab2 	bl	801ecb4 <wolfSSL_Free>
                #endif
                    break;
 8016750:	e00c      	b.n	801676c <ConfirmSignature+0x450>
            #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                case SM2k:
            #endif
                case ECDSAk:
                {
                    if (sigCtx->verify == 1) {
 8016752:	697b      	ldr	r3, [r7, #20]
 8016754:	691b      	ldr	r3, [r3, #16]
 8016756:	2b01      	cmp	r3, #1
 8016758:	d102      	bne.n	8016760 <ConfirmSignature+0x444>
                        ret = 0;
 801675a:	2300      	movs	r3, #0
 801675c:	637b      	str	r3, [r7, #52]	@ 0x34
                    else {
                        WOLFSSL_MSG("ECC Verify didn't match");
                        ret = ASN_SIG_CONFIRM_E;
                        WOLFSSL_ERROR_VERBOSE(ret);
                    }
                    break;
 801675e:	e006      	b.n	801676e <ConfirmSignature+0x452>
                        ret = ASN_SIG_CONFIRM_E;
 8016760:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 8016764:	637b      	str	r3, [r7, #52]	@ 0x34
                    break;
 8016766:	e002      	b.n	801676e <ConfirmSignature+0x452>
                    }
                    break;
                }
            #endif /* HAVE_SPHINCS */
                default:
                    break;
 8016768:	bf00      	nop
 801676a:	e010      	b.n	801678e <ConfirmSignature+0x472>
                    break;
 801676c:	bf00      	nop
            }  /* switch (keyOID) */

            break;
 801676e:	e00e      	b.n	801678e <ConfirmSignature+0x472>
        } /* SIG_STATE_CHECK */

        default:
            break;
 8016770:	bf00      	nop
 8016772:	e00c      	b.n	801678e <ConfirmSignature+0x472>
                    goto exit_cs;
 8016774:	bf00      	nop
 8016776:	e00a      	b.n	801678e <ConfirmSignature+0x472>
                    goto exit_cs;
 8016778:	bf00      	nop
 801677a:	e008      	b.n	801678e <ConfirmSignature+0x472>
                    goto exit_cs;
 801677c:	bf00      	nop
 801677e:	e006      	b.n	801678e <ConfirmSignature+0x472>
                        goto exit_cs;
 8016780:	bf00      	nop
 8016782:	e004      	b.n	801678e <ConfirmSignature+0x472>
                        goto exit_cs;
 8016784:	bf00      	nop
 8016786:	e002      	b.n	801678e <ConfirmSignature+0x472>
                        goto exit_cs;
 8016788:	bf00      	nop
 801678a:	e000      	b.n	801678e <ConfirmSignature+0x472>
                goto exit_cs;
 801678c:	bf00      	nop
#ifdef WOLFSSL_ASYNC_CRYPT
    if (ret == WC_NO_ERR_TRACE(WC_PENDING_E))
        return ret;
#endif

    FreeSignatureCtx(sigCtx);
 801678e:	6978      	ldr	r0, [r7, #20]
 8016790:	f7ff fd2a 	bl	80161e8 <FreeSignatureCtx>

    return ret;
 8016794:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8016796:	4618      	mov	r0, r3
 8016798:	3738      	adds	r7, #56	@ 0x38
 801679a:	46bd      	mov	sp, r7
 801679c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080167a0 <MatchBaseName>:

#ifndef IGNORE_NAME_CONSTRAINTS

static int MatchBaseName(int type, const char* name, int nameSz,
                         const char* base, int baseSz)
{
 80167a0:	b580      	push	{r7, lr}
 80167a2:	b088      	sub	sp, #32
 80167a4:	af00      	add	r7, sp, #0
 80167a6:	60f8      	str	r0, [r7, #12]
 80167a8:	60b9      	str	r1, [r7, #8]
 80167aa:	607a      	str	r2, [r7, #4]
 80167ac:	603b      	str	r3, [r7, #0]
    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||
 80167ae:	683b      	ldr	r3, [r7, #0]
 80167b0:	2b00      	cmp	r3, #0
 80167b2:	d019      	beq.n	80167e8 <MatchBaseName+0x48>
 80167b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80167b6:	2b00      	cmp	r3, #0
 80167b8:	dd16      	ble.n	80167e8 <MatchBaseName+0x48>
 80167ba:	68bb      	ldr	r3, [r7, #8]
 80167bc:	2b00      	cmp	r3, #0
 80167be:	d013      	beq.n	80167e8 <MatchBaseName+0x48>
 80167c0:	687b      	ldr	r3, [r7, #4]
 80167c2:	2b00      	cmp	r3, #0
 80167c4:	dd10      	ble.n	80167e8 <MatchBaseName+0x48>
            name[0] == '.' || nameSz < baseSz ||
 80167c6:	68bb      	ldr	r3, [r7, #8]
 80167c8:	781b      	ldrb	r3, [r3, #0]
    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||
 80167ca:	2b2e      	cmp	r3, #46	@ 0x2e
 80167cc:	d00c      	beq.n	80167e8 <MatchBaseName+0x48>
            name[0] == '.' || nameSz < baseSz ||
 80167ce:	687a      	ldr	r2, [r7, #4]
 80167d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80167d2:	429a      	cmp	r2, r3
 80167d4:	db08      	blt.n	80167e8 <MatchBaseName+0x48>
 80167d6:	68fb      	ldr	r3, [r7, #12]
 80167d8:	2b01      	cmp	r3, #1
 80167da:	d007      	beq.n	80167ec <MatchBaseName+0x4c>
            (type != ASN_RFC822_TYPE && type != ASN_DNS_TYPE &&
 80167dc:	68fb      	ldr	r3, [r7, #12]
 80167de:	2b02      	cmp	r3, #2
 80167e0:	d004      	beq.n	80167ec <MatchBaseName+0x4c>
 80167e2:	68fb      	ldr	r3, [r7, #12]
 80167e4:	2b04      	cmp	r3, #4
 80167e6:	d001      	beq.n	80167ec <MatchBaseName+0x4c>
             type != ASN_DIR_TYPE)) {
        return 0;
 80167e8:	2300      	movs	r3, #0
 80167ea:	e0a2      	b.n	8016932 <MatchBaseName+0x192>
    }

    if (type == ASN_DIR_TYPE)
 80167ec:	68fb      	ldr	r3, [r7, #12]
 80167ee:	2b04      	cmp	r3, #4
 80167f0:	d10c      	bne.n	801680c <MatchBaseName+0x6c>
        return XMEMCMP(name, base, (size_t)baseSz) == 0;
 80167f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80167f4:	461a      	mov	r2, r3
 80167f6:	6839      	ldr	r1, [r7, #0]
 80167f8:	68b8      	ldr	r0, [r7, #8]
 80167fa:	f012 f9e9 	bl	8028bd0 <memcmp>
 80167fe:	4603      	mov	r3, r0
 8016800:	2b00      	cmp	r3, #0
 8016802:	bf0c      	ite	eq
 8016804:	2301      	moveq	r3, #1
 8016806:	2300      	movne	r3, #0
 8016808:	b2db      	uxtb	r3, r3
 801680a:	e092      	b.n	8016932 <MatchBaseName+0x192>

    /* If an email type, handle special cases where the base is only
     * a domain, or is an email address itself. */
    if (type == ASN_RFC822_TYPE) {
 801680c:	68fb      	ldr	r3, [r7, #12]
 801680e:	2b01      	cmp	r3, #1
 8016810:	d146      	bne.n	80168a0 <MatchBaseName+0x100>
        const char* p = NULL;
 8016812:	2300      	movs	r3, #0
 8016814:	61fb      	str	r3, [r7, #28]
        int count = 0;
 8016816:	2300      	movs	r3, #0
 8016818:	61bb      	str	r3, [r7, #24]

        if (base[0] != '.') {
 801681a:	683b      	ldr	r3, [r7, #0]
 801681c:	781b      	ldrb	r3, [r3, #0]
 801681e:	2b2e      	cmp	r3, #46	@ 0x2e
 8016820:	d018      	beq.n	8016854 <MatchBaseName+0xb4>
            p = base;
 8016822:	683b      	ldr	r3, [r7, #0]
 8016824:	61fb      	str	r3, [r7, #28]
            count = 0;
 8016826:	2300      	movs	r3, #0
 8016828:	61bb      	str	r3, [r7, #24]

            /* find the '@' in the base */
            while (*p != '@' && count < baseSz) {
 801682a:	e005      	b.n	8016838 <MatchBaseName+0x98>
                count++;
 801682c:	69bb      	ldr	r3, [r7, #24]
 801682e:	3301      	adds	r3, #1
 8016830:	61bb      	str	r3, [r7, #24]
                p++;
 8016832:	69fb      	ldr	r3, [r7, #28]
 8016834:	3301      	adds	r3, #1
 8016836:	61fb      	str	r3, [r7, #28]
            while (*p != '@' && count < baseSz) {
 8016838:	69fb      	ldr	r3, [r7, #28]
 801683a:	781b      	ldrb	r3, [r3, #0]
 801683c:	2b40      	cmp	r3, #64	@ 0x40
 801683e:	d003      	beq.n	8016848 <MatchBaseName+0xa8>
 8016840:	69ba      	ldr	r2, [r7, #24]
 8016842:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016844:	429a      	cmp	r2, r3
 8016846:	dbf1      	blt.n	801682c <MatchBaseName+0x8c>
            }

            /* No '@' in base, reset p to NULL */
            if (count >= baseSz)
 8016848:	69ba      	ldr	r2, [r7, #24]
 801684a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801684c:	429a      	cmp	r2, r3
 801684e:	db01      	blt.n	8016854 <MatchBaseName+0xb4>
                p = NULL;
 8016850:	2300      	movs	r3, #0
 8016852:	61fb      	str	r3, [r7, #28]
        }

        if (p == NULL) {
 8016854:	69fb      	ldr	r3, [r7, #28]
 8016856:	2b00      	cmp	r3, #0
 8016858:	d122      	bne.n	80168a0 <MatchBaseName+0x100>
            /* Base isn't an email address, it is a domain name,
             * wind the name forward one character past its '@'. */
            p = name;
 801685a:	68bb      	ldr	r3, [r7, #8]
 801685c:	61fb      	str	r3, [r7, #28]
            count = 0;
 801685e:	2300      	movs	r3, #0
 8016860:	61bb      	str	r3, [r7, #24]
            while (*p != '@' && count < baseSz) {
 8016862:	e005      	b.n	8016870 <MatchBaseName+0xd0>
                count++;
 8016864:	69bb      	ldr	r3, [r7, #24]
 8016866:	3301      	adds	r3, #1
 8016868:	61bb      	str	r3, [r7, #24]
                p++;
 801686a:	69fb      	ldr	r3, [r7, #28]
 801686c:	3301      	adds	r3, #1
 801686e:	61fb      	str	r3, [r7, #28]
            while (*p != '@' && count < baseSz) {
 8016870:	69fb      	ldr	r3, [r7, #28]
 8016872:	781b      	ldrb	r3, [r3, #0]
 8016874:	2b40      	cmp	r3, #64	@ 0x40
 8016876:	d003      	beq.n	8016880 <MatchBaseName+0xe0>
 8016878:	69ba      	ldr	r2, [r7, #24]
 801687a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801687c:	429a      	cmp	r2, r3
 801687e:	dbf1      	blt.n	8016864 <MatchBaseName+0xc4>
            }

            if (count < baseSz && *p == '@') {
 8016880:	69ba      	ldr	r2, [r7, #24]
 8016882:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016884:	429a      	cmp	r2, r3
 8016886:	da0b      	bge.n	80168a0 <MatchBaseName+0x100>
 8016888:	69fb      	ldr	r3, [r7, #28]
 801688a:	781b      	ldrb	r3, [r3, #0]
 801688c:	2b40      	cmp	r3, #64	@ 0x40
 801688e:	d107      	bne.n	80168a0 <MatchBaseName+0x100>
                name = p + 1;
 8016890:	69fb      	ldr	r3, [r7, #28]
 8016892:	3301      	adds	r3, #1
 8016894:	60bb      	str	r3, [r7, #8]
                nameSz -= count + 1;
 8016896:	69bb      	ldr	r3, [r7, #24]
 8016898:	3301      	adds	r3, #1
 801689a:	687a      	ldr	r2, [r7, #4]
 801689c:	1ad3      	subs	r3, r2, r3
 801689e:	607b      	str	r3, [r7, #4]
    /* RFC 5280 section 4.2.1.10
     * "...Any DNS name that can be constructed by simply adding zero or more
     *  labels to the left-hand side of the name satisfies the name constraint."
     * i.e www.host.example.com works for host.example.com name constraint and
     * host1.example.com does not. */
    if (type == ASN_DNS_TYPE || (type == ASN_RFC822_TYPE && base[0] == '.')) {
 80168a0:	68fb      	ldr	r3, [r7, #12]
 80168a2:	2b02      	cmp	r3, #2
 80168a4:	d006      	beq.n	80168b4 <MatchBaseName+0x114>
 80168a6:	68fb      	ldr	r3, [r7, #12]
 80168a8:	2b01      	cmp	r3, #1
 80168aa:	d13e      	bne.n	801692a <MatchBaseName+0x18a>
 80168ac:	683b      	ldr	r3, [r7, #0]
 80168ae:	781b      	ldrb	r3, [r3, #0]
 80168b0:	2b2e      	cmp	r3, #46	@ 0x2e
 80168b2:	d13a      	bne.n	801692a <MatchBaseName+0x18a>
        int szAdjust = nameSz - baseSz;
 80168b4:	687a      	ldr	r2, [r7, #4]
 80168b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80168b8:	1ad3      	subs	r3, r2, r3
 80168ba:	617b      	str	r3, [r7, #20]
        name += szAdjust;
 80168bc:	697b      	ldr	r3, [r7, #20]
 80168be:	68ba      	ldr	r2, [r7, #8]
 80168c0:	4413      	add	r3, r2
 80168c2:	60bb      	str	r3, [r7, #8]
        nameSz -= szAdjust;
 80168c4:	687a      	ldr	r2, [r7, #4]
 80168c6:	697b      	ldr	r3, [r7, #20]
 80168c8:	1ad3      	subs	r3, r2, r3
 80168ca:	607b      	str	r3, [r7, #4]
    }

    while (nameSz > 0) {
 80168cc:	e02d      	b.n	801692a <MatchBaseName+0x18a>
        if (XTOLOWER((unsigned char)*name) !=
 80168ce:	68bb      	ldr	r3, [r7, #8]
 80168d0:	781b      	ldrb	r3, [r3, #0]
 80168d2:	74fb      	strb	r3, [r7, #19]
 80168d4:	7cfb      	ldrb	r3, [r7, #19]
 80168d6:	3301      	adds	r3, #1
 80168d8:	4a18      	ldr	r2, [pc, #96]	@ (801693c <MatchBaseName+0x19c>)
 80168da:	4413      	add	r3, r2
 80168dc:	781b      	ldrb	r3, [r3, #0]
 80168de:	f003 0303 	and.w	r3, r3, #3
 80168e2:	2b01      	cmp	r3, #1
 80168e4:	d103      	bne.n	80168ee <MatchBaseName+0x14e>
 80168e6:	7cfb      	ldrb	r3, [r7, #19]
 80168e8:	f103 0220 	add.w	r2, r3, #32
 80168ec:	e000      	b.n	80168f0 <MatchBaseName+0x150>
 80168ee:	7cfa      	ldrb	r2, [r7, #19]
                                               XTOLOWER((unsigned char)*base))
 80168f0:	683b      	ldr	r3, [r7, #0]
 80168f2:	781b      	ldrb	r3, [r3, #0]
 80168f4:	74bb      	strb	r3, [r7, #18]
 80168f6:	7cbb      	ldrb	r3, [r7, #18]
 80168f8:	3301      	adds	r3, #1
 80168fa:	4910      	ldr	r1, [pc, #64]	@ (801693c <MatchBaseName+0x19c>)
 80168fc:	440b      	add	r3, r1
 80168fe:	781b      	ldrb	r3, [r3, #0]
 8016900:	f003 0303 	and.w	r3, r3, #3
 8016904:	2b01      	cmp	r3, #1
 8016906:	d102      	bne.n	801690e <MatchBaseName+0x16e>
 8016908:	7cbb      	ldrb	r3, [r7, #18]
 801690a:	3320      	adds	r3, #32
 801690c:	e000      	b.n	8016910 <MatchBaseName+0x170>
 801690e:	7cbb      	ldrb	r3, [r7, #18]
        if (XTOLOWER((unsigned char)*name) !=
 8016910:	429a      	cmp	r2, r3
 8016912:	d001      	beq.n	8016918 <MatchBaseName+0x178>
            return 0;
 8016914:	2300      	movs	r3, #0
 8016916:	e00c      	b.n	8016932 <MatchBaseName+0x192>
        name++;
 8016918:	68bb      	ldr	r3, [r7, #8]
 801691a:	3301      	adds	r3, #1
 801691c:	60bb      	str	r3, [r7, #8]
        base++;
 801691e:	683b      	ldr	r3, [r7, #0]
 8016920:	3301      	adds	r3, #1
 8016922:	603b      	str	r3, [r7, #0]
        nameSz--;
 8016924:	687b      	ldr	r3, [r7, #4]
 8016926:	3b01      	subs	r3, #1
 8016928:	607b      	str	r3, [r7, #4]
    while (nameSz > 0) {
 801692a:	687b      	ldr	r3, [r7, #4]
 801692c:	2b00      	cmp	r3, #0
 801692e:	dcce      	bgt.n	80168ce <MatchBaseName+0x12e>
    }

    return 1;
 8016930:	2301      	movs	r3, #1
}
 8016932:	4618      	mov	r0, r3
 8016934:	3720      	adds	r7, #32
 8016936:	46bd      	mov	sp, r7
 8016938:	bd80      	pop	{r7, pc}
 801693a:	bf00      	nop
 801693c:	08034bf8 	.word	0x08034bf8

08016940 <PermittedListOk>:
 * nameType Type of DNS name to currently searching
 * return 1 if found in list or if not needed
 * return 0 if not found in the list but is needed
 */
static int PermittedListOk(DNS_entry* name, Base_entry* dnsList, byte nameType)
{
 8016940:	b590      	push	{r4, r7, lr}
 8016942:	b08b      	sub	sp, #44	@ 0x2c
 8016944:	af02      	add	r7, sp, #8
 8016946:	60f8      	str	r0, [r7, #12]
 8016948:	60b9      	str	r1, [r7, #8]
 801694a:	4613      	mov	r3, r2
 801694c:	71fb      	strb	r3, [r7, #7]
    Base_entry* current = dnsList;
 801694e:	68bb      	ldr	r3, [r7, #8]
 8016950:	61fb      	str	r3, [r7, #28]
    int match = 0;
 8016952:	2300      	movs	r3, #0
 8016954:	61bb      	str	r3, [r7, #24]
    int need  = 0;
 8016956:	2300      	movs	r3, #0
 8016958:	617b      	str	r3, [r7, #20]
    int ret   = 1; /* is ok unless needed and no match found */
 801695a:	2301      	movs	r3, #1
 801695c:	613b      	str	r3, [r7, #16]

    while (current != NULL) {
 801695e:	e022      	b.n	80169a6 <PermittedListOk+0x66>
        if (current->type == nameType) {
 8016960:	69fb      	ldr	r3, [r7, #28]
 8016962:	7b1b      	ldrb	r3, [r3, #12]
 8016964:	79fa      	ldrb	r2, [r7, #7]
 8016966:	429a      	cmp	r2, r3
 8016968:	d11a      	bne.n	80169a0 <PermittedListOk+0x60>
            need = 1; /* restriction on permitted names is set for this type */
 801696a:	2301      	movs	r3, #1
 801696c:	617b      	str	r3, [r7, #20]
            if (name->len >= current->nameSz &&
 801696e:	68fb      	ldr	r3, [r7, #12]
 8016970:	689a      	ldr	r2, [r3, #8]
 8016972:	69fb      	ldr	r3, [r7, #28]
 8016974:	689b      	ldr	r3, [r3, #8]
 8016976:	429a      	cmp	r2, r3
 8016978:	db12      	blt.n	80169a0 <PermittedListOk+0x60>
                MatchBaseName(nameType, name->name, name->len,
 801697a:	79f8      	ldrb	r0, [r7, #7]
 801697c:	68fb      	ldr	r3, [r7, #12]
 801697e:	68d9      	ldr	r1, [r3, #12]
 8016980:	68fb      	ldr	r3, [r7, #12]
 8016982:	689a      	ldr	r2, [r3, #8]
                              current->name, current->nameSz)) {
 8016984:	69fb      	ldr	r3, [r7, #28]
 8016986:	685c      	ldr	r4, [r3, #4]
                MatchBaseName(nameType, name->name, name->len,
 8016988:	69fb      	ldr	r3, [r7, #28]
 801698a:	689b      	ldr	r3, [r3, #8]
 801698c:	9300      	str	r3, [sp, #0]
 801698e:	4623      	mov	r3, r4
 8016990:	f7ff ff06 	bl	80167a0 <MatchBaseName>
 8016994:	4603      	mov	r3, r0
            if (name->len >= current->nameSz &&
 8016996:	2b00      	cmp	r3, #0
 8016998:	d002      	beq.n	80169a0 <PermittedListOk+0x60>
                match = 1; /* found the current name in the permitted list*/
 801699a:	2301      	movs	r3, #1
 801699c:	61bb      	str	r3, [r7, #24]
                break;
 801699e:	e005      	b.n	80169ac <PermittedListOk+0x6c>
            }
        }
        current = current->next;
 80169a0:	69fb      	ldr	r3, [r7, #28]
 80169a2:	681b      	ldr	r3, [r3, #0]
 80169a4:	61fb      	str	r3, [r7, #28]
    while (current != NULL) {
 80169a6:	69fb      	ldr	r3, [r7, #28]
 80169a8:	2b00      	cmp	r3, #0
 80169aa:	d1d9      	bne.n	8016960 <PermittedListOk+0x20>
    }

    /* check if permitted name restriction was set and no matching name found */
    if (need && !match)
 80169ac:	697b      	ldr	r3, [r7, #20]
 80169ae:	2b00      	cmp	r3, #0
 80169b0:	d004      	beq.n	80169bc <PermittedListOk+0x7c>
 80169b2:	69bb      	ldr	r3, [r7, #24]
 80169b4:	2b00      	cmp	r3, #0
 80169b6:	d101      	bne.n	80169bc <PermittedListOk+0x7c>
        ret = 0;
 80169b8:	2300      	movs	r3, #0
 80169ba:	613b      	str	r3, [r7, #16]

    return ret;
 80169bc:	693b      	ldr	r3, [r7, #16]
}
 80169be:	4618      	mov	r0, r3
 80169c0:	3724      	adds	r7, #36	@ 0x24
 80169c2:	46bd      	mov	sp, r7
 80169c4:	bd90      	pop	{r4, r7, pc}

080169c6 <IsInExcludedList>:
 * dnsList  The list to search through
 * nameType Type of DNS name to currently searching
 * return 1 if found in list and 0 if not found in the list
 */
static int IsInExcludedList(DNS_entry* name, Base_entry* dnsList, byte nameType)
{
 80169c6:	b590      	push	{r4, r7, lr}
 80169c8:	b089      	sub	sp, #36	@ 0x24
 80169ca:	af02      	add	r7, sp, #8
 80169cc:	60f8      	str	r0, [r7, #12]
 80169ce:	60b9      	str	r1, [r7, #8]
 80169d0:	4613      	mov	r3, r2
 80169d2:	71fb      	strb	r3, [r7, #7]
    int ret = 0; /* default of not found in the list */
 80169d4:	2300      	movs	r3, #0
 80169d6:	617b      	str	r3, [r7, #20]
    Base_entry* current = dnsList;
 80169d8:	68bb      	ldr	r3, [r7, #8]
 80169da:	613b      	str	r3, [r7, #16]

    while (current != NULL) {
 80169dc:	e020      	b.n	8016a20 <IsInExcludedList+0x5a>
        if (current->type == nameType) {
 80169de:	693b      	ldr	r3, [r7, #16]
 80169e0:	7b1b      	ldrb	r3, [r3, #12]
 80169e2:	79fa      	ldrb	r2, [r7, #7]
 80169e4:	429a      	cmp	r2, r3
 80169e6:	d118      	bne.n	8016a1a <IsInExcludedList+0x54>
            if (name->len >= current->nameSz &&
 80169e8:	68fb      	ldr	r3, [r7, #12]
 80169ea:	689a      	ldr	r2, [r3, #8]
 80169ec:	693b      	ldr	r3, [r7, #16]
 80169ee:	689b      	ldr	r3, [r3, #8]
 80169f0:	429a      	cmp	r2, r3
 80169f2:	db12      	blt.n	8016a1a <IsInExcludedList+0x54>
                MatchBaseName(nameType, name->name, name->len,
 80169f4:	79f8      	ldrb	r0, [r7, #7]
 80169f6:	68fb      	ldr	r3, [r7, #12]
 80169f8:	68d9      	ldr	r1, [r3, #12]
 80169fa:	68fb      	ldr	r3, [r7, #12]
 80169fc:	689a      	ldr	r2, [r3, #8]
                              current->name, current->nameSz)) {
 80169fe:	693b      	ldr	r3, [r7, #16]
 8016a00:	685c      	ldr	r4, [r3, #4]
                MatchBaseName(nameType, name->name, name->len,
 8016a02:	693b      	ldr	r3, [r7, #16]
 8016a04:	689b      	ldr	r3, [r3, #8]
 8016a06:	9300      	str	r3, [sp, #0]
 8016a08:	4623      	mov	r3, r4
 8016a0a:	f7ff fec9 	bl	80167a0 <MatchBaseName>
 8016a0e:	4603      	mov	r3, r0
            if (name->len >= current->nameSz &&
 8016a10:	2b00      	cmp	r3, #0
 8016a12:	d002      	beq.n	8016a1a <IsInExcludedList+0x54>
                ret = 1;
 8016a14:	2301      	movs	r3, #1
 8016a16:	617b      	str	r3, [r7, #20]
                break;
 8016a18:	e005      	b.n	8016a26 <IsInExcludedList+0x60>
            }
        }
        current = current->next;
 8016a1a:	693b      	ldr	r3, [r7, #16]
 8016a1c:	681b      	ldr	r3, [r3, #0]
 8016a1e:	613b      	str	r3, [r7, #16]
    while (current != NULL) {
 8016a20:	693b      	ldr	r3, [r7, #16]
 8016a22:	2b00      	cmp	r3, #0
 8016a24:	d1db      	bne.n	80169de <IsInExcludedList+0x18>
    }

    return ret;
 8016a26:	697b      	ldr	r3, [r7, #20]
}
 8016a28:	4618      	mov	r0, r3
 8016a2a:	371c      	adds	r7, #28
 8016a2c:	46bd      	mov	sp, r7
 8016a2e:	bd90      	pop	{r4, r7, pc}

08016a30 <ConfirmNameConstraints>:


static int ConfirmNameConstraints(Signer* signer, DecodedCert* cert)
{
 8016a30:	b580      	push	{r7, lr}
 8016a32:	b08a      	sub	sp, #40	@ 0x28
 8016a34:	af00      	add	r7, sp, #0
 8016a36:	6078      	str	r0, [r7, #4]
 8016a38:	6039      	str	r1, [r7, #0]
    const byte nameTypes[] = {ASN_RFC822_TYPE, ASN_DNS_TYPE, ASN_DIR_TYPE};
 8016a3a:	4a5a      	ldr	r2, [pc, #360]	@ (8016ba4 <ConfirmNameConstraints+0x174>)
 8016a3c:	f107 031c 	add.w	r3, r7, #28
 8016a40:	6812      	ldr	r2, [r2, #0]
 8016a42:	4611      	mov	r1, r2
 8016a44:	8019      	strh	r1, [r3, #0]
 8016a46:	3302      	adds	r3, #2
 8016a48:	0c12      	lsrs	r2, r2, #16
 8016a4a:	701a      	strb	r2, [r3, #0]
    int i;

    if (signer == NULL || cert == NULL)
 8016a4c:	687b      	ldr	r3, [r7, #4]
 8016a4e:	2b00      	cmp	r3, #0
 8016a50:	d002      	beq.n	8016a58 <ConfirmNameConstraints+0x28>
 8016a52:	683b      	ldr	r3, [r7, #0]
 8016a54:	2b00      	cmp	r3, #0
 8016a56:	d101      	bne.n	8016a5c <ConfirmNameConstraints+0x2c>
        return 0;
 8016a58:	2300      	movs	r3, #0
 8016a5a:	e09e      	b.n	8016b9a <ConfirmNameConstraints+0x16a>

    if (signer->excludedNames == NULL && signer->permittedNames == NULL)
 8016a5c:	687b      	ldr	r3, [r7, #4]
 8016a5e:	69db      	ldr	r3, [r3, #28]
 8016a60:	2b00      	cmp	r3, #0
 8016a62:	d105      	bne.n	8016a70 <ConfirmNameConstraints+0x40>
 8016a64:	687b      	ldr	r3, [r7, #4]
 8016a66:	699b      	ldr	r3, [r3, #24]
 8016a68:	2b00      	cmp	r3, #0
 8016a6a:	d101      	bne.n	8016a70 <ConfirmNameConstraints+0x40>
        return 1;
 8016a6c:	2301      	movs	r3, #1
 8016a6e:	e094      	b.n	8016b9a <ConfirmNameConstraints+0x16a>

    for (i=0; i < (int)sizeof(nameTypes); i++) {
 8016a70:	2300      	movs	r3, #0
 8016a72:	627b      	str	r3, [r7, #36]	@ 0x24
 8016a74:	e08c      	b.n	8016b90 <ConfirmNameConstraints+0x160>
        byte nameType = nameTypes[i];
 8016a76:	f107 021c 	add.w	r2, r7, #28
 8016a7a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016a7c:	4413      	add	r3, r2
 8016a7e:	781b      	ldrb	r3, [r3, #0]
 8016a80:	77fb      	strb	r3, [r7, #31]
        DNS_entry* name = NULL;
 8016a82:	2300      	movs	r3, #0
 8016a84:	623b      	str	r3, [r7, #32]
        DNS_entry  subjectDnsName; /* temporary node used for subject name */

        XMEMSET(&subjectDnsName, 0, sizeof(DNS_entry));
 8016a86:	f107 030c 	add.w	r3, r7, #12
 8016a8a:	2210      	movs	r2, #16
 8016a8c:	2100      	movs	r1, #0
 8016a8e:	4618      	mov	r0, r3
 8016a90:	f012 f8c8 	bl	8028c24 <memset>
        switch (nameType) {
 8016a94:	7ffb      	ldrb	r3, [r7, #31]
 8016a96:	2b04      	cmp	r3, #4
 8016a98:	d01e      	beq.n	8016ad8 <ConfirmNameConstraints+0xa8>
 8016a9a:	2b04      	cmp	r3, #4
 8016a9c:	dc31      	bgt.n	8016b02 <ConfirmNameConstraints+0xd2>
 8016a9e:	2b01      	cmp	r3, #1
 8016aa0:	d005      	beq.n	8016aae <ConfirmNameConstraints+0x7e>
 8016aa2:	2b02      	cmp	r3, #2
 8016aa4:	d12d      	bne.n	8016b02 <ConfirmNameConstraints+0xd2>
            case ASN_DNS_TYPE:
                /* Should it also consider CN in subject? It could use
                 * subjectDnsName too */
                name = cert->altNames;
 8016aa6:	683b      	ldr	r3, [r7, #0]
 8016aa8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016aaa:	623b      	str	r3, [r7, #32]
                break;
 8016aac:	e02e      	b.n	8016b0c <ConfirmNameConstraints+0xdc>
            case ASN_RFC822_TYPE:
                /* Shouldn't it validate E= in subject as well? */
                name = cert->altEmailNames;
 8016aae:	683b      	ldr	r3, [r7, #0]
 8016ab0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8016ab2:	623b      	str	r3, [r7, #32]

                /* Add subject email for checking. */
                if (cert->subjectEmail != NULL) {
 8016ab4:	683b      	ldr	r3, [r7, #0]
 8016ab6:	f8d3 345c 	ldr.w	r3, [r3, #1116]	@ 0x45c
 8016aba:	2b00      	cmp	r3, #0
 8016abc:	d023      	beq.n	8016b06 <ConfirmNameConstraints+0xd6>
                     * "When constraints are imposed on the rfc822Name name
                     * form, but the certificate does not include a subject
                     * alternative name, the rfc822Name constraint MUST be
                     * applied to the attribute of type emailAddress in the
                     * subject distinguished name" */
                    subjectDnsName.next = NULL;
 8016abe:	2300      	movs	r3, #0
 8016ac0:	60fb      	str	r3, [r7, #12]
                    subjectDnsName.type = ASN_RFC822_TYPE;
 8016ac2:	2301      	movs	r3, #1
 8016ac4:	613b      	str	r3, [r7, #16]
                    subjectDnsName.len  = cert->subjectEmailLen;
 8016ac6:	683b      	ldr	r3, [r7, #0]
 8016ac8:	f8d3 3460 	ldr.w	r3, [r3, #1120]	@ 0x460
 8016acc:	617b      	str	r3, [r7, #20]
                    subjectDnsName.name = (char *)cert->subjectEmail;
 8016ace:	683b      	ldr	r3, [r7, #0]
 8016ad0:	f8d3 345c 	ldr.w	r3, [r3, #1116]	@ 0x45c
 8016ad4:	61bb      	str	r3, [r7, #24]
                }
                break;
 8016ad6:	e016      	b.n	8016b06 <ConfirmNameConstraints+0xd6>
            case ASN_DIR_TYPE:
            #ifndef WOLFSSL_NO_ASN_STRICT
                name = cert->altDirNames;
 8016ad8:	683b      	ldr	r3, [r7, #0]
 8016ada:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8016adc:	623b      	str	r3, [r7, #32]
                    "Restrictions of the form directoryName MUST be
                    applied to the subject field .... and to any names
                    of type directoryName in the subjectAltName
                    extension"
                */
                if (cert->subjectRaw != NULL) {
 8016ade:	683b      	ldr	r3, [r7, #0]
 8016ae0:	f8d3 3454 	ldr.w	r3, [r3, #1108]	@ 0x454
 8016ae4:	2b00      	cmp	r3, #0
 8016ae6:	d010      	beq.n	8016b0a <ConfirmNameConstraints+0xda>
                    subjectDnsName.next = NULL;
 8016ae8:	2300      	movs	r3, #0
 8016aea:	60fb      	str	r3, [r7, #12]
                    subjectDnsName.type = ASN_DIR_TYPE;
 8016aec:	2304      	movs	r3, #4
 8016aee:	613b      	str	r3, [r7, #16]
                    subjectDnsName.len = cert->subjectRawLen;
 8016af0:	683b      	ldr	r3, [r7, #0]
 8016af2:	f8d3 3458 	ldr.w	r3, [r3, #1112]	@ 0x458
 8016af6:	617b      	str	r3, [r7, #20]
                    subjectDnsName.name = (char *)cert->subjectRaw;
 8016af8:	683b      	ldr	r3, [r7, #0]
 8016afa:	f8d3 3454 	ldr.w	r3, [r3, #1108]	@ 0x454
 8016afe:	61bb      	str	r3, [r7, #24]
                }
                break;
 8016b00:	e003      	b.n	8016b0a <ConfirmNameConstraints+0xda>
            default:
                /* Other types of names are ignored for now.
                 * Shouldn't it be rejected if it there is a altNamesByType[nameType]
                 * and signer->extNameConstraintCrit is set? */
                return 0;
 8016b02:	2300      	movs	r3, #0
 8016b04:	e049      	b.n	8016b9a <ConfirmNameConstraints+0x16a>
                break;
 8016b06:	bf00      	nop
 8016b08:	e01c      	b.n	8016b44 <ConfirmNameConstraints+0x114>
                break;
 8016b0a:	bf00      	nop
        }

        while (name != NULL) {
 8016b0c:	e01a      	b.n	8016b44 <ConfirmNameConstraints+0x114>
            if (IsInExcludedList(name, signer->excludedNames, nameType) == 1) {
 8016b0e:	687b      	ldr	r3, [r7, #4]
 8016b10:	69db      	ldr	r3, [r3, #28]
 8016b12:	7ffa      	ldrb	r2, [r7, #31]
 8016b14:	4619      	mov	r1, r3
 8016b16:	6a38      	ldr	r0, [r7, #32]
 8016b18:	f7ff ff55 	bl	80169c6 <IsInExcludedList>
 8016b1c:	4603      	mov	r3, r0
 8016b1e:	2b01      	cmp	r3, #1
 8016b20:	d101      	bne.n	8016b26 <ConfirmNameConstraints+0xf6>
                WOLFSSL_MSG("Excluded name was found!");
                return 0;
 8016b22:	2300      	movs	r3, #0
 8016b24:	e039      	b.n	8016b9a <ConfirmNameConstraints+0x16a>
            }

            /* Check against the permitted list */
            if (PermittedListOk(name, signer->permittedNames, nameType) != 1) {
 8016b26:	687b      	ldr	r3, [r7, #4]
 8016b28:	699b      	ldr	r3, [r3, #24]
 8016b2a:	7ffa      	ldrb	r2, [r7, #31]
 8016b2c:	4619      	mov	r1, r3
 8016b2e:	6a38      	ldr	r0, [r7, #32]
 8016b30:	f7ff ff06 	bl	8016940 <PermittedListOk>
 8016b34:	4603      	mov	r3, r0
 8016b36:	2b01      	cmp	r3, #1
 8016b38:	d001      	beq.n	8016b3e <ConfirmNameConstraints+0x10e>
                WOLFSSL_MSG("Permitted name was not found!");
                return 0;
 8016b3a:	2300      	movs	r3, #0
 8016b3c:	e02d      	b.n	8016b9a <ConfirmNameConstraints+0x16a>
            }

            name = name->next;
 8016b3e:	6a3b      	ldr	r3, [r7, #32]
 8016b40:	681b      	ldr	r3, [r3, #0]
 8016b42:	623b      	str	r3, [r7, #32]
        while (name != NULL) {
 8016b44:	6a3b      	ldr	r3, [r7, #32]
 8016b46:	2b00      	cmp	r3, #0
 8016b48:	d1e1      	bne.n	8016b0e <ConfirmNameConstraints+0xde>
        }

        /* handle comparing against subject name too */
        if (subjectDnsName.len > 0 && subjectDnsName.name != NULL) {
 8016b4a:	697b      	ldr	r3, [r7, #20]
 8016b4c:	2b00      	cmp	r3, #0
 8016b4e:	dd1c      	ble.n	8016b8a <ConfirmNameConstraints+0x15a>
 8016b50:	69bb      	ldr	r3, [r7, #24]
 8016b52:	2b00      	cmp	r3, #0
 8016b54:	d019      	beq.n	8016b8a <ConfirmNameConstraints+0x15a>
            if (IsInExcludedList(&subjectDnsName, signer->excludedNames,
 8016b56:	687b      	ldr	r3, [r7, #4]
 8016b58:	69d9      	ldr	r1, [r3, #28]
 8016b5a:	7ffa      	ldrb	r2, [r7, #31]
 8016b5c:	f107 030c 	add.w	r3, r7, #12
 8016b60:	4618      	mov	r0, r3
 8016b62:	f7ff ff30 	bl	80169c6 <IsInExcludedList>
 8016b66:	4603      	mov	r3, r0
 8016b68:	2b01      	cmp	r3, #1
 8016b6a:	d101      	bne.n	8016b70 <ConfirmNameConstraints+0x140>
                        nameType) == 1) {
                WOLFSSL_MSG("Excluded name was found!");
                return 0;
 8016b6c:	2300      	movs	r3, #0
 8016b6e:	e014      	b.n	8016b9a <ConfirmNameConstraints+0x16a>
            }

            /* Check against the permitted list */
            if (PermittedListOk(&subjectDnsName, signer->permittedNames,
 8016b70:	687b      	ldr	r3, [r7, #4]
 8016b72:	6999      	ldr	r1, [r3, #24]
 8016b74:	7ffa      	ldrb	r2, [r7, #31]
 8016b76:	f107 030c 	add.w	r3, r7, #12
 8016b7a:	4618      	mov	r0, r3
 8016b7c:	f7ff fee0 	bl	8016940 <PermittedListOk>
 8016b80:	4603      	mov	r3, r0
 8016b82:	2b01      	cmp	r3, #1
 8016b84:	d001      	beq.n	8016b8a <ConfirmNameConstraints+0x15a>
                        nameType) != 1) {
                WOLFSSL_MSG("Permitted name was not found!");
                return 0;
 8016b86:	2300      	movs	r3, #0
 8016b88:	e007      	b.n	8016b9a <ConfirmNameConstraints+0x16a>
    for (i=0; i < (int)sizeof(nameTypes); i++) {
 8016b8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016b8c:	3301      	adds	r3, #1
 8016b8e:	627b      	str	r3, [r7, #36]	@ 0x24
 8016b90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016b92:	2b02      	cmp	r3, #2
 8016b94:	f77f af6f 	ble.w	8016a76 <ConfirmNameConstraints+0x46>
            }
        }
    }

    return 1;
 8016b98:	2301      	movs	r3, #1
}
 8016b9a:	4618      	mov	r0, r3
 8016b9c:	3728      	adds	r7, #40	@ 0x28
 8016b9e:	46bd      	mov	sp, r7
 8016ba0:	bd80      	pop	{r7, pc}
 8016ba2:	bf00      	nop
 8016ba4:	08030658 	.word	0x08030658

08016ba8 <DecodeGeneralName>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int DecodeGeneralName(const byte* input, word32* inOutIdx, byte tag,
                             int len, DecodedCert* cert)
{
 8016ba8:	b580      	push	{r7, lr}
 8016baa:	b08c      	sub	sp, #48	@ 0x30
 8016bac:	af02      	add	r7, sp, #8
 8016bae:	60f8      	str	r0, [r7, #12]
 8016bb0:	60b9      	str	r1, [r7, #8]
 8016bb2:	603b      	str	r3, [r7, #0]
 8016bb4:	4613      	mov	r3, r2
 8016bb6:	71fb      	strb	r3, [r7, #7]
    int ret = 0;
 8016bb8:	2300      	movs	r3, #0
 8016bba:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 idx = *inOutIdx;
 8016bbc:	68bb      	ldr	r3, [r7, #8]
 8016bbe:	681b      	ldr	r3, [r3, #0]
 8016bc0:	623b      	str	r3, [r7, #32]

    /* GeneralName choice: dnsName */
    if (tag == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE)) {
 8016bc2:	79fb      	ldrb	r3, [r7, #7]
 8016bc4:	2b82      	cmp	r3, #130	@ 0x82
 8016bc6:	d116      	bne.n	8016bf6 <DecodeGeneralName+0x4e>
        ret = SetDNSEntry(cert->heap, (const char*)(input + idx), len,
 8016bc8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016bca:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016bce:	68fa      	ldr	r2, [r7, #12]
 8016bd0:	6a3b      	ldr	r3, [r7, #32]
 8016bd2:	18d1      	adds	r1, r2, r3
 8016bd4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016bd6:	332c      	adds	r3, #44	@ 0x2c
 8016bd8:	9300      	str	r3, [sp, #0]
 8016bda:	2302      	movs	r3, #2
 8016bdc:	683a      	ldr	r2, [r7, #0]
 8016bde:	f7fe feb4 	bl	801594a <SetDNSEntry>
 8016be2:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_DNS_TYPE, &cert->altNames);
        if (ret == 0) {
 8016be4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016be6:	2b00      	cmp	r3, #0
 8016be8:	f040 809b 	bne.w	8016d22 <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016bec:	683b      	ldr	r3, [r7, #0]
 8016bee:	6a3a      	ldr	r2, [r7, #32]
 8016bf0:	4413      	add	r3, r2
 8016bf2:	623b      	str	r3, [r7, #32]
 8016bf4:	e095      	b.n	8016d22 <DecodeGeneralName+0x17a>
        }
    }
#ifndef IGNORE_NAME_CONSTRAINTS
    /* GeneralName choice: directoryName */
    else if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_DIR_TYPE)) {
 8016bf6:	79fb      	ldrb	r3, [r7, #7]
 8016bf8:	2ba4      	cmp	r3, #164	@ 0xa4
 8016bfa:	d129      	bne.n	8016c50 <DecodeGeneralName+0xa8>
        int strLen;
        word32 idxDir = idx;
 8016bfc:	6a3b      	ldr	r3, [r7, #32]
 8016bfe:	617b      	str	r3, [r7, #20]

        /* Expecting a SEQUENCE using up all data. */
        if (GetASN_Sequence(input, &idxDir, &strLen, idx + (word32)len, 1) < 0)
 8016c00:	683a      	ldr	r2, [r7, #0]
 8016c02:	6a3b      	ldr	r3, [r7, #32]
 8016c04:	4413      	add	r3, r2
 8016c06:	f107 0218 	add.w	r2, r7, #24
 8016c0a:	f107 0114 	add.w	r1, r7, #20
 8016c0e:	2001      	movs	r0, #1
 8016c10:	9000      	str	r0, [sp, #0]
 8016c12:	68f8      	ldr	r0, [r7, #12]
 8016c14:	f7fd f8d3 	bl	8013dbe <GetASN_Sequence>
 8016c18:	4603      	mov	r3, r0
 8016c1a:	2b00      	cmp	r3, #0
 8016c1c:	da02      	bge.n	8016c24 <DecodeGeneralName+0x7c>
        {
            WOLFSSL_MSG("\tfail: seq length");
            return ASN_PARSE_E;
 8016c1e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016c22:	e085      	b.n	8016d30 <DecodeGeneralName+0x188>
        }

        ret = SetDNSEntry(cert->heap, (const char*)(input + idxDir), strLen,
 8016c24:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016c26:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016c2a:	697b      	ldr	r3, [r7, #20]
 8016c2c:	68fa      	ldr	r2, [r7, #12]
 8016c2e:	18d1      	adds	r1, r2, r3
 8016c30:	69ba      	ldr	r2, [r7, #24]
 8016c32:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016c34:	3334      	adds	r3, #52	@ 0x34
 8016c36:	9300      	str	r3, [sp, #0]
 8016c38:	2304      	movs	r3, #4
 8016c3a:	f7fe fe86 	bl	801594a <SetDNSEntry>
 8016c3e:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_DIR_TYPE, &cert->altDirNames);
        if (ret == 0) {
 8016c40:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016c42:	2b00      	cmp	r3, #0
 8016c44:	d16d      	bne.n	8016d22 <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016c46:	683b      	ldr	r3, [r7, #0]
 8016c48:	6a3a      	ldr	r2, [r7, #32]
 8016c4a:	4413      	add	r3, r2
 8016c4c:	623b      	str	r3, [r7, #32]
 8016c4e:	e068      	b.n	8016d22 <DecodeGeneralName+0x17a>
        }
    }
    /* GeneralName choice: rfc822Name */
    else if (tag == (ASN_CONTEXT_SPECIFIC | ASN_RFC822_TYPE)) {
 8016c50:	79fb      	ldrb	r3, [r7, #7]
 8016c52:	2b81      	cmp	r3, #129	@ 0x81
 8016c54:	d115      	bne.n	8016c82 <DecodeGeneralName+0xda>
        ret = SetDNSEntry(cert->heap, (const char*)(input + idx), len,
 8016c56:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016c58:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016c5c:	68fa      	ldr	r2, [r7, #12]
 8016c5e:	6a3b      	ldr	r3, [r7, #32]
 8016c60:	18d1      	adds	r1, r2, r3
 8016c62:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016c64:	3330      	adds	r3, #48	@ 0x30
 8016c66:	9300      	str	r3, [sp, #0]
 8016c68:	2301      	movs	r3, #1
 8016c6a:	683a      	ldr	r2, [r7, #0]
 8016c6c:	f7fe fe6d 	bl	801594a <SetDNSEntry>
 8016c70:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_RFC822_TYPE, &cert->altEmailNames);
        if (ret == 0) {
 8016c72:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016c74:	2b00      	cmp	r3, #0
 8016c76:	d154      	bne.n	8016d22 <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016c78:	683b      	ldr	r3, [r7, #0]
 8016c7a:	6a3a      	ldr	r2, [r7, #32]
 8016c7c:	4413      	add	r3, r2
 8016c7e:	623b      	str	r3, [r7, #32]
 8016c80:	e04f      	b.n	8016d22 <DecodeGeneralName+0x17a>
        }
    }
    /* GeneralName choice: uniformResourceIdentifier */
    else if (tag == (ASN_CONTEXT_SPECIFIC | ASN_URI_TYPE)) {
 8016c82:	79fb      	ldrb	r3, [r7, #7]
 8016c84:	2b86      	cmp	r3, #134	@ 0x86
 8016c86:	d148      	bne.n	8016d1a <DecodeGeneralName+0x172>
            hier-part, it must come after the ':' (see RFC 3986 Sec 3). */
        {
            int i;

            /* skip past scheme (i.e http,ftp,...) finding first ':' char */
            for (i = 0; i < len; i++) {
 8016c88:	2300      	movs	r3, #0
 8016c8a:	61fb      	str	r3, [r7, #28]
 8016c8c:	e014      	b.n	8016cb8 <DecodeGeneralName+0x110>
                if (input[idx + (word32)i] == ':') {
 8016c8e:	69fa      	ldr	r2, [r7, #28]
 8016c90:	6a3b      	ldr	r3, [r7, #32]
 8016c92:	4413      	add	r3, r2
 8016c94:	68fa      	ldr	r2, [r7, #12]
 8016c96:	4413      	add	r3, r2
 8016c98:	781b      	ldrb	r3, [r3, #0]
 8016c9a:	2b3a      	cmp	r3, #58	@ 0x3a
 8016c9c:	d011      	beq.n	8016cc2 <DecodeGeneralName+0x11a>
                    break;
                }
                if (input[idx + (word32)i] == '/') {
 8016c9e:	69fa      	ldr	r2, [r7, #28]
 8016ca0:	6a3b      	ldr	r3, [r7, #32]
 8016ca2:	4413      	add	r3, r2
 8016ca4:	68fa      	ldr	r2, [r7, #12]
 8016ca6:	4413      	add	r3, r2
 8016ca8:	781b      	ldrb	r3, [r3, #0]
 8016caa:	2b2f      	cmp	r3, #47	@ 0x2f
 8016cac:	d101      	bne.n	8016cb2 <DecodeGeneralName+0x10a>
                    i = len; /* error, found relative path since '/' was
 8016cae:	683b      	ldr	r3, [r7, #0]
 8016cb0:	61fb      	str	r3, [r7, #28]
            for (i = 0; i < len; i++) {
 8016cb2:	69fb      	ldr	r3, [r7, #28]
 8016cb4:	3301      	adds	r3, #1
 8016cb6:	61fb      	str	r3, [r7, #28]
 8016cb8:	69fa      	ldr	r2, [r7, #28]
 8016cba:	683b      	ldr	r3, [r7, #0]
 8016cbc:	429a      	cmp	r2, r3
 8016cbe:	dbe6      	blt.n	8016c8e <DecodeGeneralName+0xe6>
 8016cc0:	e000      	b.n	8016cc4 <DecodeGeneralName+0x11c>
                    break;
 8016cc2:	bf00      	nop
                              * value in next if statement. */
                }
            }

            /* test hier-part is empty */
            if (i == 0 || i == len) {
 8016cc4:	69fb      	ldr	r3, [r7, #28]
 8016cc6:	2b00      	cmp	r3, #0
 8016cc8:	d003      	beq.n	8016cd2 <DecodeGeneralName+0x12a>
 8016cca:	69fa      	ldr	r2, [r7, #28]
 8016ccc:	683b      	ldr	r3, [r7, #0]
 8016cce:	429a      	cmp	r2, r3
 8016cd0:	d102      	bne.n	8016cd8 <DecodeGeneralName+0x130>
                WOLFSSL_MSG("\tEmpty or malformed URI");
                WOLFSSL_ERROR_VERBOSE(ASN_ALT_NAME_E);
                return ASN_ALT_NAME_E;
 8016cd2:	f06f 03a0 	mvn.w	r3, #160	@ 0xa0
 8016cd6:	e02b      	b.n	8016d30 <DecodeGeneralName+0x188>
            }

            /* test if scheme is missing  */
            if (input[idx + (word32)i] != ':') {
 8016cd8:	69fa      	ldr	r2, [r7, #28]
 8016cda:	6a3b      	ldr	r3, [r7, #32]
 8016cdc:	4413      	add	r3, r2
 8016cde:	68fa      	ldr	r2, [r7, #12]
 8016ce0:	4413      	add	r3, r2
 8016ce2:	781b      	ldrb	r3, [r3, #0]
 8016ce4:	2b3a      	cmp	r3, #58	@ 0x3a
 8016ce6:	d002      	beq.n	8016cee <DecodeGeneralName+0x146>
                WOLFSSL_MSG("\tAlt Name must be absolute URI");
                WOLFSSL_ERROR_VERBOSE(ASN_ALT_NAME_E);
                return ASN_ALT_NAME_E;
 8016ce8:	f06f 03a0 	mvn.w	r3, #160	@ 0xa0
 8016cec:	e020      	b.n	8016d30 <DecodeGeneralName+0x188>
            }
        }
    #endif

        ret = SetDNSEntry(cert->heap, (const char*)(input + idx), len,
 8016cee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016cf0:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016cf4:	68fa      	ldr	r2, [r7, #12]
 8016cf6:	6a3b      	ldr	r3, [r7, #32]
 8016cf8:	18d1      	adds	r1, r2, r3
 8016cfa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016cfc:	332c      	adds	r3, #44	@ 0x2c
 8016cfe:	9300      	str	r3, [sp, #0]
 8016d00:	2306      	movs	r3, #6
 8016d02:	683a      	ldr	r2, [r7, #0]
 8016d04:	f7fe fe21 	bl	801594a <SetDNSEntry>
 8016d08:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_URI_TYPE, &cert->altNames);
        if (ret == 0) {
 8016d0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d0c:	2b00      	cmp	r3, #0
 8016d0e:	d108      	bne.n	8016d22 <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016d10:	683b      	ldr	r3, [r7, #0]
 8016d12:	6a3a      	ldr	r2, [r7, #32]
 8016d14:	4413      	add	r3, r2
 8016d16:	623b      	str	r3, [r7, #32]
 8016d18:	e003      	b.n	8016d22 <DecodeGeneralName+0x17a>
    }
#endif
    /* GeneralName choice: dNSName, x400Address, ediPartyName */
    else {
        WOLFSSL_MSG("\tUnsupported name type, skipping");
        idx += (word32)len;
 8016d1a:	683b      	ldr	r3, [r7, #0]
 8016d1c:	6a3a      	ldr	r2, [r7, #32]
 8016d1e:	4413      	add	r3, r2
 8016d20:	623b      	str	r3, [r7, #32]
    }

    if (ret == 0) {
 8016d22:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d24:	2b00      	cmp	r3, #0
 8016d26:	d102      	bne.n	8016d2e <DecodeGeneralName+0x186>
        /* Return index of next encoded byte. */
        *inOutIdx = idx;
 8016d28:	68bb      	ldr	r3, [r7, #8]
 8016d2a:	6a3a      	ldr	r2, [r7, #32]
 8016d2c:	601a      	str	r2, [r3, #0]
    }
    return ret;
 8016d2e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8016d30:	4618      	mov	r0, r3
 8016d32:	3728      	adds	r7, #40	@ 0x28
 8016d34:	46bd      	mov	sp, r7
 8016d36:	bd80      	pop	{r7, pc}

08016d38 <DecodeAltNames>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int DecodeAltNames(const byte* input, word32 sz, DecodedCert* cert)
{
 8016d38:	b580      	push	{r7, lr}
 8016d3a:	b094      	sub	sp, #80	@ 0x50
 8016d3c:	af04      	add	r7, sp, #16
 8016d3e:	60f8      	str	r0, [r7, #12]
 8016d40:	60b9      	str	r1, [r7, #8]
 8016d42:	607a      	str	r2, [r7, #4]
        }
    }

    return 0;
#else
    word32 idx = 0;
 8016d44:	2300      	movs	r3, #0
 8016d46:	637b      	str	r3, [r7, #52]	@ 0x34
    int length = 0;
 8016d48:	2300      	movs	r3, #0
 8016d4a:	633b      	str	r3, [r7, #48]	@ 0x30
    int ret = 0;
 8016d4c:	2300      	movs	r3, #0
 8016d4e:	63fb      	str	r3, [r7, #60]	@ 0x3c
    word32 numNames = 0;
 8016d50:	2300      	movs	r3, #0
 8016d52:	63bb      	str	r3, [r7, #56]	@ 0x38

    WOLFSSL_ENTER("DecodeAltNames");

    /* Get SEQUENCE and expect all data to be accounted for. */
    if (GetASN_Sequence(input, &idx, &length, sz, 1) != 0) {
 8016d54:	f107 0230 	add.w	r2, r7, #48	@ 0x30
 8016d58:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8016d5c:	2301      	movs	r3, #1
 8016d5e:	9300      	str	r3, [sp, #0]
 8016d60:	68bb      	ldr	r3, [r7, #8]
 8016d62:	68f8      	ldr	r0, [r7, #12]
 8016d64:	f7fd f82b 	bl	8013dbe <GetASN_Sequence>
 8016d68:	4603      	mov	r3, r0
 8016d6a:	2b00      	cmp	r3, #0
 8016d6c:	d002      	beq.n	8016d74 <DecodeAltNames+0x3c>
        WOLFSSL_MSG("\tBad Sequence");
        ret = ASN_PARSE_E;
 8016d6e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016d72:	63fb      	str	r3, [r7, #60]	@ 0x3c
    }

    if ((ret == 0) && (length == 0)) {
 8016d74:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016d76:	2b00      	cmp	r3, #0
 8016d78:	d105      	bne.n	8016d86 <DecodeAltNames+0x4e>
 8016d7a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016d7c:	2b00      	cmp	r3, #0
 8016d7e:	d102      	bne.n	8016d86 <DecodeAltNames+0x4e>
        /* RFC 5280 4.2.1.6.  Subject Alternative Name
           If the subjectAltName extension is present, the sequence MUST
           contain at least one entry. */
        WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
        ret = ASN_PARSE_E;
 8016d80:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016d84:	63fb      	str	r3, [r7, #60]	@ 0x3c
    }
    if (ret == 0) {
 8016d86:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016d88:	2b00      	cmp	r3, #0
 8016d8a:	d147      	bne.n	8016e1c <DecodeAltNames+0xe4>
    #ifdef OPENSSL_ALL
        cert->extSubjAltNameSrc = input;
        cert->extSubjAltNameSz = sz;
    #endif

        cert->weOwnAltNames = 1;
 8016d8c:	687a      	ldr	r2, [r7, #4]
 8016d8e:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8016d92:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8016d96:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4

        if ((word32)length + idx != sz) {
 8016d9a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016d9c:	461a      	mov	r2, r3
 8016d9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016da0:	4413      	add	r3, r2
 8016da2:	68ba      	ldr	r2, [r7, #8]
 8016da4:	429a      	cmp	r2, r3
 8016da6:	d039      	beq.n	8016e1c <DecodeAltNames+0xe4>
            ret = ASN_PARSE_E;
 8016da8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016dac:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
    }

    while ((ret == 0) && (idx < sz)) {
 8016dae:	e035      	b.n	8016e1c <DecodeAltNames+0xe4>
        ASNGetData dataASN[altNameASN_Length];

        numNames++;
 8016db0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8016db2:	3301      	adds	r3, #1
 8016db4:	63bb      	str	r3, [r7, #56]	@ 0x38
        if (numNames > WOLFSSL_MAX_ALT_NAMES) {
 8016db6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8016db8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8016dbc:	d903      	bls.n	8016dc6 <DecodeAltNames+0x8e>
            WOLFSSL_MSG("\tToo many subject alternative names");
            ret = ASN_ALT_NAME_E;
 8016dbe:	f06f 03a0 	mvn.w	r3, #160	@ 0xa0
 8016dc2:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8016dc4:	e031      	b.n	8016e2a <DecodeAltNames+0xf2>
            break;
        }

        /* Clear dynamic data items. */
        XMEMSET(dataASN, 0, sizeof(dataASN));
 8016dc6:	f107 0314 	add.w	r3, r7, #20
 8016dca:	221c      	movs	r2, #28
 8016dcc:	2100      	movs	r1, #0
 8016dce:	4618      	mov	r0, r3
 8016dd0:	f011 ff28 	bl	8028c24 <memset>
        /* Parse GeneralName with the choices supported. */
        GetASN_Choice(&dataASN[ALTNAMEASN_IDX_GN], generalNameChoice);
 8016dd4:	230b      	movs	r3, #11
 8016dd6:	f887 302c 	strb.w	r3, [r7, #44]	@ 0x2c
 8016dda:	4b16      	ldr	r3, [pc, #88]	@ (8016e34 <DecodeAltNames+0xfc>)
 8016ddc:	61fb      	str	r3, [r7, #28]
        /* Decode a GeneralName choice. */
        ret = GetASN_Items(altNameASN, dataASN, altNameASN_Length, 0, input,
 8016dde:	f107 0114 	add.w	r1, r7, #20
 8016de2:	68bb      	ldr	r3, [r7, #8]
 8016de4:	9302      	str	r3, [sp, #8]
 8016de6:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8016dea:	9301      	str	r3, [sp, #4]
 8016dec:	68fb      	ldr	r3, [r7, #12]
 8016dee:	9300      	str	r3, [sp, #0]
 8016df0:	2300      	movs	r3, #0
 8016df2:	2201      	movs	r2, #1
 8016df4:	4810      	ldr	r0, [pc, #64]	@ (8016e38 <DecodeAltNames+0x100>)
 8016df6:	f7fc fd3b 	bl	8013870 <GetASN_Items>
 8016dfa:	63f8      	str	r0, [r7, #60]	@ 0x3c
                           &idx, sz);
        if (ret == 0) {
 8016dfc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016dfe:	2b00      	cmp	r3, #0
 8016e00:	d10c      	bne.n	8016e1c <DecodeAltNames+0xe4>
            ret = DecodeGeneralName(input, &idx, dataASN[ALTNAMEASN_IDX_GN].tag,
 8016e02:	f897 202d 	ldrb.w	r2, [r7, #45]	@ 0x2d
                                  (int)dataASN[ALTNAMEASN_IDX_GN].length, cert);
 8016e06:	69bb      	ldr	r3, [r7, #24]
            ret = DecodeGeneralName(input, &idx, dataASN[ALTNAMEASN_IDX_GN].tag,
 8016e08:	4618      	mov	r0, r3
 8016e0a:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8016e0e:	687b      	ldr	r3, [r7, #4]
 8016e10:	9300      	str	r3, [sp, #0]
 8016e12:	4603      	mov	r3, r0
 8016e14:	68f8      	ldr	r0, [r7, #12]
 8016e16:	f7ff fec7 	bl	8016ba8 <DecodeGeneralName>
 8016e1a:	63f8      	str	r0, [r7, #60]	@ 0x3c
    while ((ret == 0) && (idx < sz)) {
 8016e1c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016e1e:	2b00      	cmp	r3, #0
 8016e20:	d103      	bne.n	8016e2a <DecodeAltNames+0xf2>
 8016e22:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016e24:	68ba      	ldr	r2, [r7, #8]
 8016e26:	429a      	cmp	r2, r3
 8016e28:	d8c2      	bhi.n	8016db0 <DecodeAltNames+0x78>
        }
    }

    return ret;
 8016e2a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
#endif
}
 8016e2c:	4618      	mov	r0, r3
 8016e2e:	3740      	adds	r7, #64	@ 0x40
 8016e30:	46bd      	mov	sp, r7
 8016e32:	bd80      	pop	{r7, pc}
 8016e34:	08034700 	.word	0x08034700
 8016e38:	0803470c 	.word	0x0803470c

08016e3c <DecodeBasicCaConstraint>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
static int DecodeBasicCaConstraint(const byte* input, int sz, DecodedCert* cert)
{
 8016e3c:	b580      	push	{r7, lr}
 8016e3e:	b08e      	sub	sp, #56	@ 0x38
 8016e40:	af04      	add	r7, sp, #16
 8016e42:	60f8      	str	r0, [r7, #12]
 8016e44:	60b9      	str	r1, [r7, #8]
 8016e46:	607a      	str	r2, [r7, #4]
    cert->pathLength = (byte)ret;
    cert->pathLengthSet = 1;

    return 0;
#else
    DECL_ASNGETDATA(dataASN, basicConsASN_Length);
 8016e48:	2300      	movs	r3, #0
 8016e4a:	627b      	str	r3, [r7, #36]	@ 0x24
    int ret = 0;
 8016e4c:	2300      	movs	r3, #0
 8016e4e:	623b      	str	r3, [r7, #32]
    word32 idx = 0;
 8016e50:	2300      	movs	r3, #0
 8016e52:	61bb      	str	r3, [r7, #24]
    byte isCA = 0;
 8016e54:	2300      	movs	r3, #0
 8016e56:	75fb      	strb	r3, [r7, #23]

    WOLFSSL_ENTER("DecodeBasicCaConstraint");

    CALLOC_ASNGETDATA(dataASN, basicConsASN_Length, ret, cert->heap);
 8016e58:	6a3b      	ldr	r3, [r7, #32]
 8016e5a:	2b00      	cmp	r3, #0
 8016e5c:	d109      	bne.n	8016e72 <DecodeBasicCaConstraint+0x36>
 8016e5e:	2054      	movs	r0, #84	@ 0x54
 8016e60:	f007 ff0c 	bl	801ec7c <wolfSSL_Malloc>
 8016e64:	6278      	str	r0, [r7, #36]	@ 0x24
 8016e66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016e68:	2b00      	cmp	r3, #0
 8016e6a:	d102      	bne.n	8016e72 <DecodeBasicCaConstraint+0x36>
 8016e6c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8016e70:	623b      	str	r3, [r7, #32]
 8016e72:	6a3b      	ldr	r3, [r7, #32]
 8016e74:	2b00      	cmp	r3, #0
 8016e76:	d104      	bne.n	8016e82 <DecodeBasicCaConstraint+0x46>
 8016e78:	2254      	movs	r2, #84	@ 0x54
 8016e7a:	2100      	movs	r1, #0
 8016e7c:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8016e7e:	f011 fed1 	bl	8028c24 <memset>

    if (ret == 0) {
 8016e82:	6a3b      	ldr	r3, [r7, #32]
 8016e84:	2b00      	cmp	r3, #0
 8016e86:	d120      	bne.n	8016eca <DecodeBasicCaConstraint+0x8e>
        /* Get the CA boolean and path length when present. */
        GetASN_Boolean(&dataASN[BASICCONSASN_IDX_CA], &isCA);
 8016e88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016e8a:	331c      	adds	r3, #28
 8016e8c:	2200      	movs	r2, #0
 8016e8e:	761a      	strb	r2, [r3, #24]
 8016e90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016e92:	331c      	adds	r3, #28
 8016e94:	f107 0217 	add.w	r2, r7, #23
 8016e98:	609a      	str	r2, [r3, #8]
        GetASN_Int8Bit(&dataASN[BASICCONSASN_IDX_PLEN], &cert->pathLength);
 8016e9a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016e9c:	3338      	adds	r3, #56	@ 0x38
 8016e9e:	2201      	movs	r2, #1
 8016ea0:	761a      	strb	r2, [r3, #24]
 8016ea2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016ea4:	3338      	adds	r3, #56	@ 0x38
 8016ea6:	687a      	ldr	r2, [r7, #4]
 8016ea8:	f202 421c 	addw	r2, r2, #1052	@ 0x41c
 8016eac:	609a      	str	r2, [r3, #8]

        ret = GetASN_Items(basicConsASN, dataASN, basicConsASN_Length, 1, input,
 8016eae:	68bb      	ldr	r3, [r7, #8]
 8016eb0:	9302      	str	r3, [sp, #8]
 8016eb2:	f107 0318 	add.w	r3, r7, #24
 8016eb6:	9301      	str	r3, [sp, #4]
 8016eb8:	68fb      	ldr	r3, [r7, #12]
 8016eba:	9300      	str	r3, [sp, #0]
 8016ebc:	2301      	movs	r3, #1
 8016ebe:	2203      	movs	r2, #3
 8016ec0:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8016ec2:	482e      	ldr	r0, [pc, #184]	@ (8016f7c <DecodeBasicCaConstraint+0x140>)
 8016ec4:	f7fc fcd4 	bl	8013870 <GetASN_Items>
 8016ec8:	6238      	str	r0, [r7, #32]
                           &idx, (word32)sz);
    }

    /* Empty SEQUENCE is OK - nothing to store. */
    if ((ret == 0) && (dataASN[BASICCONSASN_IDX_SEQ].length != 0)) {
 8016eca:	6a3b      	ldr	r3, [r7, #32]
 8016ecc:	2b00      	cmp	r3, #0
 8016ece:	d145      	bne.n	8016f5c <DecodeBasicCaConstraint+0x120>
 8016ed0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016ed2:	685b      	ldr	r3, [r3, #4]
 8016ed4:	2b00      	cmp	r3, #0
 8016ed6:	d041      	beq.n	8016f5c <DecodeBasicCaConstraint+0x120>
        /* Bad encoding when CA Boolean is false
         * (default when not present). */
#if !defined(ASN_TEMPLATE_SKIP_ISCA_CHECK) && \
    !defined(WOLFSSL_ALLOW_ENCODING_CA_FALSE)
        if ((dataASN[BASICCONSASN_IDX_CA].length != 0) && (!isCA)) {
 8016ed8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016eda:	331c      	adds	r3, #28
 8016edc:	685b      	ldr	r3, [r3, #4]
 8016ede:	2b00      	cmp	r3, #0
 8016ee0:	d005      	beq.n	8016eee <DecodeBasicCaConstraint+0xb2>
 8016ee2:	7dfb      	ldrb	r3, [r7, #23]
 8016ee4:	2b00      	cmp	r3, #0
 8016ee6:	d102      	bne.n	8016eee <DecodeBasicCaConstraint+0xb2>
            WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
            ret = ASN_PARSE_E;
 8016ee8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016eec:	623b      	str	r3, [r7, #32]
        }
#endif
        /* Path length must be a 7-bit value. */
        if ((ret == 0) && (cert->pathLength >= (1 << 7))) {
 8016eee:	6a3b      	ldr	r3, [r7, #32]
 8016ef0:	2b00      	cmp	r3, #0
 8016ef2:	d108      	bne.n	8016f06 <DecodeBasicCaConstraint+0xca>
 8016ef4:	687b      	ldr	r3, [r7, #4]
 8016ef6:	f893 341c 	ldrb.w	r3, [r3, #1052]	@ 0x41c
 8016efa:	b25b      	sxtb	r3, r3
 8016efc:	2b00      	cmp	r3, #0
 8016efe:	da02      	bge.n	8016f06 <DecodeBasicCaConstraint+0xca>
            WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
            ret = ASN_PARSE_E;
 8016f00:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016f04:	623b      	str	r3, [r7, #32]
        }
        if ((ret == 0) && cert->pathLength > WOLFSSL_MAX_PATH_LEN) {
 8016f06:	6a3b      	ldr	r3, [r7, #32]
 8016f08:	2b00      	cmp	r3, #0
 8016f0a:	d108      	bne.n	8016f1e <DecodeBasicCaConstraint+0xe2>
 8016f0c:	687b      	ldr	r3, [r7, #4]
 8016f0e:	f893 341c 	ldrb.w	r3, [r3, #1052]	@ 0x41c
 8016f12:	b25b      	sxtb	r3, r3
 8016f14:	2b00      	cmp	r3, #0
 8016f16:	da02      	bge.n	8016f1e <DecodeBasicCaConstraint+0xe2>
            WOLFSSL_ERROR_VERBOSE(ASN_PATHLEN_SIZE_E);
            ret = ASN_PATHLEN_SIZE_E;
 8016f18:	f06f 03ec 	mvn.w	r3, #236	@ 0xec
 8016f1c:	623b      	str	r3, [r7, #32]
        }
        /* Store CA boolean and whether a path length was seen. */
        if (ret == 0) {
 8016f1e:	6a3b      	ldr	r3, [r7, #32]
 8016f20:	2b00      	cmp	r3, #0
 8016f22:	d11b      	bne.n	8016f5c <DecodeBasicCaConstraint+0x120>
            /* isCA in certificate is a 1 bit of a byte. */
            cert->isCA = isCA ? 1 : 0;
 8016f24:	7dfb      	ldrb	r3, [r7, #23]
 8016f26:	2b00      	cmp	r3, #0
 8016f28:	bf14      	ite	ne
 8016f2a:	2301      	movne	r3, #1
 8016f2c:	2300      	moveq	r3, #0
 8016f2e:	b2d9      	uxtb	r1, r3
 8016f30:	687a      	ldr	r2, [r7, #4]
 8016f32:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8016f36:	f361 1304 	bfi	r3, r1, #4, #1
 8016f3a:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->pathLengthSet = (dataASN[BASICCONSASN_IDX_PLEN].length > 0);
 8016f3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f40:	3338      	adds	r3, #56	@ 0x38
 8016f42:	685b      	ldr	r3, [r3, #4]
 8016f44:	2b00      	cmp	r3, #0
 8016f46:	bf14      	ite	ne
 8016f48:	2301      	movne	r3, #1
 8016f4a:	2300      	moveq	r3, #0
 8016f4c:	b2d9      	uxtb	r1, r3
 8016f4e:	687a      	ldr	r2, [r7, #4]
 8016f50:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8016f54:	f361 1345 	bfi	r3, r1, #5, #1
 8016f58:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
        }
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8016f5c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f5e:	2b00      	cmp	r3, #0
 8016f60:	d007      	beq.n	8016f72 <DecodeBasicCaConstraint+0x136>
 8016f62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f64:	61fb      	str	r3, [r7, #28]
 8016f66:	69fb      	ldr	r3, [r7, #28]
 8016f68:	2b00      	cmp	r3, #0
 8016f6a:	d002      	beq.n	8016f72 <DecodeBasicCaConstraint+0x136>
 8016f6c:	69f8      	ldr	r0, [r7, #28]
 8016f6e:	f007 fea1 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 8016f72:	6a3b      	ldr	r3, [r7, #32]
#endif
}
 8016f74:	4618      	mov	r0, r3
 8016f76:	3728      	adds	r7, #40	@ 0x28
 8016f78:	46bd      	mov	sp, r7
 8016f7a:	bd80      	pop	{r7, pc}
 8016f7c:	08034710 	.word	0x08034710

08016f80 <DecodePolicyConstraints>:


static int DecodePolicyConstraints(const byte* input, int sz, DecodedCert* cert)
{
 8016f80:	b580      	push	{r7, lr}
 8016f82:	b08a      	sub	sp, #40	@ 0x28
 8016f84:	af00      	add	r7, sp, #0
 8016f86:	60f8      	str	r0, [r7, #12]
 8016f88:	60b9      	str	r1, [r7, #8]
 8016f8a:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 8016f8c:	2300      	movs	r3, #0
 8016f8e:	623b      	str	r3, [r7, #32]
    int length = 0;
 8016f90:	2300      	movs	r3, #0
 8016f92:	61fb      	str	r3, [r7, #28]
    int skipLength = 0;
 8016f94:	2300      	movs	r3, #0
 8016f96:	61bb      	str	r3, [r7, #24]
    int ret;
    byte tag;

    WOLFSSL_ENTER("DecodePolicyConstraints");

    if (GetSequence(input, &idx, &length, (word32)sz) < 0) {
 8016f98:	68bb      	ldr	r3, [r7, #8]
 8016f9a:	f107 021c 	add.w	r2, r7, #28
 8016f9e:	f107 0120 	add.w	r1, r7, #32
 8016fa2:	68f8      	ldr	r0, [r7, #12]
 8016fa4:	f7fd f8a8 	bl	80140f8 <GetSequence>
 8016fa8:	4603      	mov	r3, r0
 8016faa:	2b00      	cmp	r3, #0
 8016fac:	da02      	bge.n	8016fb4 <DecodePolicyConstraints+0x34>
        WOLFSSL_MSG("\tfail: bad SEQUENCE");
        return ASN_PARSE_E;
 8016fae:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016fb2:	e04f      	b.n	8017054 <DecodePolicyConstraints+0xd4>
    }

    if (length == 0)
 8016fb4:	69fb      	ldr	r3, [r7, #28]
 8016fb6:	2b00      	cmp	r3, #0
 8016fb8:	d102      	bne.n	8016fc0 <DecodePolicyConstraints+0x40>
        return ASN_PARSE_E;
 8016fba:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016fbe:	e049      	b.n	8017054 <DecodePolicyConstraints+0xd4>

    if (GetASNTag(input, &idx, &tag, (word32)sz) < 0) {
 8016fc0:	68bb      	ldr	r3, [r7, #8]
 8016fc2:	f107 0217 	add.w	r2, r7, #23
 8016fc6:	f107 0120 	add.w	r1, r7, #32
 8016fca:	68f8      	ldr	r0, [r7, #12]
 8016fcc:	f7fc ffdf 	bl	8013f8e <GetASNTag>
 8016fd0:	4603      	mov	r3, r0
 8016fd2:	2b00      	cmp	r3, #0
 8016fd4:	da02      	bge.n	8016fdc <DecodePolicyConstraints+0x5c>
        WOLFSSL_MSG("\tfail: bad TAG");
        return ASN_PARSE_E;
 8016fd6:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016fda:	e03b      	b.n	8017054 <DecodePolicyConstraints+0xd4>
    }

    if (tag == (ASN_CONTEXT_SPECIFIC | 0)) {
 8016fdc:	7dfb      	ldrb	r3, [r7, #23]
 8016fde:	2b80      	cmp	r3, #128	@ 0x80
 8016fe0:	d107      	bne.n	8016ff2 <DecodePolicyConstraints+0x72>
        /* requireExplicitPolicy */
        cert->extPolicyConstRxpSet = 1;
 8016fe2:	687a      	ldr	r2, [r7, #4]
 8016fe4:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8016fe8:	f043 0320 	orr.w	r3, r3, #32
 8016fec:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
 8016ff0:	e00d      	b.n	801700e <DecodePolicyConstraints+0x8e>
    }
    else if (tag == (ASN_CONTEXT_SPECIFIC | 1)) {
 8016ff2:	7dfb      	ldrb	r3, [r7, #23]
 8016ff4:	2b81      	cmp	r3, #129	@ 0x81
 8016ff6:	d107      	bne.n	8017008 <DecodePolicyConstraints+0x88>
        /* inhibitPolicyMapping */
        cert->extPolicyConstIpmSet = 1;
 8016ff8:	687a      	ldr	r2, [r7, #4]
 8016ffa:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8016ffe:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8017002:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
 8017006:	e002      	b.n	801700e <DecodePolicyConstraints+0x8e>
    }
    else {
        WOLFSSL_MSG("\tfail: invalid TAG");
        return ASN_PARSE_E;
 8017008:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801700c:	e022      	b.n	8017054 <DecodePolicyConstraints+0xd4>
    }

    ret = GetLength(input, &idx, &skipLength, (word32)sz);
 801700e:	68bb      	ldr	r3, [r7, #8]
 8017010:	f107 0218 	add.w	r2, r7, #24
 8017014:	f107 0120 	add.w	r1, r7, #32
 8017018:	68f8      	ldr	r0, [r7, #12]
 801701a:	f7fc ff20 	bl	8013e5e <GetLength>
 801701e:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret < 0) {
 8017020:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017022:	2b00      	cmp	r3, #0
 8017024:	da01      	bge.n	801702a <DecodePolicyConstraints+0xaa>
        WOLFSSL_MSG("\tfail: invalid length");
        return ret;
 8017026:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017028:	e014      	b.n	8017054 <DecodePolicyConstraints+0xd4>
    }
    if (skipLength > 1) {
 801702a:	69bb      	ldr	r3, [r7, #24]
 801702c:	2b01      	cmp	r3, #1
 801702e:	dd02      	ble.n	8017036 <DecodePolicyConstraints+0xb6>
        WOLFSSL_MSG("\tfail: skip value too big");
        return BUFFER_E;
 8017030:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8017034:	e00e      	b.n	8017054 <DecodePolicyConstraints+0xd4>
    }
    if (idx >= (word32)sz) {
 8017036:	6a3a      	ldr	r2, [r7, #32]
 8017038:	68bb      	ldr	r3, [r7, #8]
 801703a:	429a      	cmp	r2, r3
 801703c:	d302      	bcc.n	8017044 <DecodePolicyConstraints+0xc4>
        WOLFSSL_MSG("\tfail: no policy const skip to read");
        return BUFFER_E;
 801703e:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8017042:	e007      	b.n	8017054 <DecodePolicyConstraints+0xd4>
    }
    cert->policyConstSkip = input[idx];
 8017044:	6a3b      	ldr	r3, [r7, #32]
 8017046:	68fa      	ldr	r2, [r7, #12]
 8017048:	4413      	add	r3, r2
 801704a:	781a      	ldrb	r2, [r3, #0]
 801704c:	687b      	ldr	r3, [r7, #4]
 801704e:	f883 241e 	strb.w	r2, [r3, #1054]	@ 0x41e

    return 0;
 8017052:	2300      	movs	r3, #0
}
 8017054:	4618      	mov	r0, r3
 8017056:	3728      	adds	r7, #40	@ 0x28
 8017058:	46bd      	mov	sp, r7
 801705a:	bd80      	pop	{r7, pc}

0801705c <DecodeCrlDist>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  BUFFER_E when data in buffer is too small.
 */
static int DecodeCrlDist(const byte* input, word32 sz, DecodedCert* cert)
{
 801705c:	b580      	push	{r7, lr}
 801705e:	b08e      	sub	sp, #56	@ 0x38
 8017060:	af04      	add	r7, sp, #16
 8017062:	60f8      	str	r0, [r7, #12]
 8017064:	60b9      	str	r1, [r7, #8]
 8017066:	607a      	str	r2, [r7, #4]
                   "but we only use the first one.");
    }

    return 0;
#else
    DECL_ASNGETDATA(dataASN, crlDistASN_Length);
 8017068:	2300      	movs	r3, #0
 801706a:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 idx = 0;
 801706c:	2300      	movs	r3, #0
 801706e:	61bb      	str	r3, [r7, #24]
    int ret = 0;
 8017070:	2300      	movs	r3, #0
 8017072:	623b      	str	r3, [r7, #32]
    word16 reason;
#endif

    WOLFSSL_ENTER("DecodeCrlDist");

    CALLOC_ASNGETDATA(dataASN, crlDistASN_Length, ret, cert->heap);
 8017074:	6a3b      	ldr	r3, [r7, #32]
 8017076:	2b00      	cmp	r3, #0
 8017078:	d109      	bne.n	801708e <DecodeCrlDist+0x32>
 801707a:	20e0      	movs	r0, #224	@ 0xe0
 801707c:	f007 fdfe 	bl	801ec7c <wolfSSL_Malloc>
 8017080:	6278      	str	r0, [r7, #36]	@ 0x24
 8017082:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017084:	2b00      	cmp	r3, #0
 8017086:	d102      	bne.n	801708e <DecodeCrlDist+0x32>
 8017088:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801708c:	623b      	str	r3, [r7, #32]
 801708e:	6a3b      	ldr	r3, [r7, #32]
 8017090:	2b00      	cmp	r3, #0
 8017092:	d104      	bne.n	801709e <DecodeCrlDist+0x42>
 8017094:	22e0      	movs	r2, #224	@ 0xe0
 8017096:	2100      	movs	r1, #0
 8017098:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801709a:	f011 fdc3 	bl	8028c24 <memset>

    cert->extCrlInfoRaw = input;
 801709e:	687b      	ldr	r3, [r7, #4]
 80170a0:	68fa      	ldr	r2, [r7, #12]
 80170a2:	f8c3 23b4 	str.w	r2, [r3, #948]	@ 0x3b4
    cert->extCrlInfoRawSz = (int)sz;
 80170a6:	68ba      	ldr	r2, [r7, #8]
 80170a8:	687b      	ldr	r3, [r7, #4]
 80170aa:	f8c3 23b8 	str.w	r2, [r3, #952]	@ 0x3b8

    if  (ret == 0) {
 80170ae:	6a3b      	ldr	r3, [r7, #32]
 80170b0:	2b00      	cmp	r3, #0
 80170b2:	d115      	bne.n	80170e0 <DecodeCrlDist+0x84>
        /* Get the GeneralName choice */
        GetASN_Choice(&dataASN[CRLDISTASN_IDX_DP_DISTPOINT_FN_GN], generalNameChoice);
 80170b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80170b6:	3370      	adds	r3, #112	@ 0x70
 80170b8:	220b      	movs	r2, #11
 80170ba:	761a      	strb	r2, [r3, #24]
 80170bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80170be:	3370      	adds	r3, #112	@ 0x70
 80170c0:	4a1c      	ldr	r2, [pc, #112]	@ (8017134 <DecodeCrlDist+0xd8>)
 80170c2:	609a      	str	r2, [r3, #8]
        /* Parse CRL distribution point. */
        ret = GetASN_Items(crlDistASN, dataASN, crlDistASN_Length, 0, input,
 80170c4:	68bb      	ldr	r3, [r7, #8]
 80170c6:	9302      	str	r3, [sp, #8]
 80170c8:	f107 0318 	add.w	r3, r7, #24
 80170cc:	9301      	str	r3, [sp, #4]
 80170ce:	68fb      	ldr	r3, [r7, #12]
 80170d0:	9300      	str	r3, [sp, #0]
 80170d2:	2300      	movs	r3, #0
 80170d4:	2208      	movs	r2, #8
 80170d6:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80170d8:	4817      	ldr	r0, [pc, #92]	@ (8017138 <DecodeCrlDist+0xdc>)
 80170da:	f7fc fbc9 	bl	8013870 <GetASN_Items>
 80170de:	6238      	str	r0, [r7, #32]
                           &idx, sz);
    }
    if (ret == 0) {
 80170e0:	6a3b      	ldr	r3, [r7, #32]
 80170e2:	2b00      	cmp	r3, #0
 80170e4:	d113      	bne.n	801710e <DecodeCrlDist+0xb2>
        /* If the choice was a URI, store it in certificate. */
        if (dataASN[CRLDISTASN_IDX_DP_DISTPOINT_FN_GN].tag == GENERALNAME_URI) {
 80170e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80170e8:	3370      	adds	r3, #112	@ 0x70
 80170ea:	7e5b      	ldrb	r3, [r3, #25]
 80170ec:	2b86      	cmp	r3, #134	@ 0x86
 80170ee:	d10e      	bne.n	801710e <DecodeCrlDist+0xb2>
            word32 sz32;
            GetASN_GetConstRef(&dataASN[CRLDISTASN_IDX_DP_DISTPOINT_FN_GN],
 80170f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80170f2:	3370      	adds	r3, #112	@ 0x70
 80170f4:	689a      	ldr	r2, [r3, #8]
 80170f6:	687b      	ldr	r3, [r7, #4]
 80170f8:	f8c3 23bc 	str.w	r2, [r3, #956]	@ 0x3bc
 80170fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80170fe:	3370      	adds	r3, #112	@ 0x70
 8017100:	68db      	ldr	r3, [r3, #12]
 8017102:	617b      	str	r3, [r7, #20]
                    &cert->extCrlInfo, &sz32);
            cert->extCrlInfoSz = (int)sz32;
 8017104:	697b      	ldr	r3, [r7, #20]
 8017106:	461a      	mov	r2, r3
 8017108:	687b      	ldr	r3, [r7, #4]
 801710a:	f8c3 23c0 	str.w	r2, [r3, #960]	@ 0x3c0
        }
    #endif
    }

    /* Only parsing the first one. */
    if (ret == 0 && idx < (word32)sz) {
 801710e:	6a3b      	ldr	r3, [r7, #32]
 8017110:	2b00      	cmp	r3, #0
        WOLFSSL_MSG("\tThere are more CRL Distribution Point records, "
                    "but we only use the first one.");
    }
    /* TODO: validate other points. */

    FREE_ASNGETDATA(dataASN, cert->heap);
 8017112:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017114:	2b00      	cmp	r3, #0
 8017116:	d007      	beq.n	8017128 <DecodeCrlDist+0xcc>
 8017118:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801711a:	61fb      	str	r3, [r7, #28]
 801711c:	69fb      	ldr	r3, [r7, #28]
 801711e:	2b00      	cmp	r3, #0
 8017120:	d002      	beq.n	8017128 <DecodeCrlDist+0xcc>
 8017122:	69f8      	ldr	r0, [r7, #28]
 8017124:	f007 fdc6 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 8017128:	6a3b      	ldr	r3, [r7, #32]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801712a:	4618      	mov	r0, r3
 801712c:	3728      	adds	r7, #40	@ 0x28
 801712e:	46bd      	mov	sp, r7
 8017130:	bd80      	pop	{r7, pc}
 8017132:	bf00      	nop
 8017134:	08034700 	.word	0x08034700
 8017138:	0803471c 	.word	0x0803471c

0801713c <DecodeAuthInfo>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_OBJECT_ID_E when the expected OBJECT_ID tag is not found.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
static int DecodeAuthInfo(const byte* input, word32 sz, DecodedCert* cert)
{
 801713c:	b580      	push	{r7, lr}
 801713e:	b0a2      	sub	sp, #136	@ 0x88
 8017140:	af04      	add	r7, sp, #16
 8017142:	60f8      	str	r0, [r7, #12]
 8017144:	60b9      	str	r1, [r7, #8]
 8017146:	607a      	str	r2, [r7, #4]
        idx += (word32)length;
    }

    return 0;
#else
    word32 idx = 0;
 8017148:	2300      	movs	r3, #0
 801714a:	673b      	str	r3, [r7, #112]	@ 0x70
    int length = 0;
 801714c:	2300      	movs	r3, #0
 801714e:	66fb      	str	r3, [r7, #108]	@ 0x6c
    int ret    = 0;
 8017150:	2300      	movs	r3, #0
 8017152:	677b      	str	r3, [r7, #116]	@ 0x74

    WOLFSSL_ENTER("DecodeAuthInfo");

    /* Unwrap the list of AIAs */
    if (GetASN_Sequence(input, &idx, &length, sz, 1) < 0) {
 8017154:	f107 026c 	add.w	r2, r7, #108	@ 0x6c
 8017158:	f107 0170 	add.w	r1, r7, #112	@ 0x70
 801715c:	2301      	movs	r3, #1
 801715e:	9300      	str	r3, [sp, #0]
 8017160:	68bb      	ldr	r3, [r7, #8]
 8017162:	68f8      	ldr	r0, [r7, #12]
 8017164:	f7fc fe2b 	bl	8013dbe <GetASN_Sequence>
 8017168:	4603      	mov	r3, r0
 801716a:	2b00      	cmp	r3, #0
 801716c:	da52      	bge.n	8017214 <DecodeAuthInfo+0xd8>
        ret = ASN_PARSE_E;
 801716e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017172:	677b      	str	r3, [r7, #116]	@ 0x74
    }

    while ((ret == 0) && (idx < (word32)sz)) {
 8017174:	e04e      	b.n	8017214 <DecodeAuthInfo+0xd8>
        ASNGetData dataASN[accessDescASN_Length];

        /* Clear dynamic data and retrieve OID and name. */
        XMEMSET(dataASN, 0, sizeof(dataASN));
 8017176:	f107 0314 	add.w	r3, r7, #20
 801717a:	2254      	movs	r2, #84	@ 0x54
 801717c:	2100      	movs	r1, #0
 801717e:	4618      	mov	r0, r3
 8017180:	f011 fd50 	bl	8028c24 <memset>
        GetASN_OID(&dataASN[ACCESSDESCASN_IDX_METH], oidCertAuthInfoType);
 8017184:	2307      	movs	r3, #7
 8017186:	643b      	str	r3, [r7, #64]	@ 0x40
        GetASN_Choice(&dataASN[ACCESSDESCASN_IDX_LOC], generalNameChoice);
 8017188:	230b      	movs	r3, #11
 801718a:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
 801718e:	4b27      	ldr	r3, [pc, #156]	@ (801722c <DecodeAuthInfo+0xf0>)
 8017190:	657b      	str	r3, [r7, #84]	@ 0x54
        /* Parse AccessDescription. */
        ret = GetASN_Items(accessDescASN, dataASN, accessDescASN_Length, 0,
 8017192:	f107 0114 	add.w	r1, r7, #20
 8017196:	68bb      	ldr	r3, [r7, #8]
 8017198:	9302      	str	r3, [sp, #8]
 801719a:	f107 0370 	add.w	r3, r7, #112	@ 0x70
 801719e:	9301      	str	r3, [sp, #4]
 80171a0:	68fb      	ldr	r3, [r7, #12]
 80171a2:	9300      	str	r3, [sp, #0]
 80171a4:	2300      	movs	r3, #0
 80171a6:	2203      	movs	r2, #3
 80171a8:	4821      	ldr	r0, [pc, #132]	@ (8017230 <DecodeAuthInfo+0xf4>)
 80171aa:	f7fc fb61 	bl	8013870 <GetASN_Items>
 80171ae:	6778      	str	r0, [r7, #116]	@ 0x74
                           input, &idx, sz);
        if (ret == 0) {
 80171b0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80171b2:	2b00      	cmp	r3, #0
 80171b4:	d12e      	bne.n	8017214 <DecodeAuthInfo+0xd8>
            word32 sz32;

            /* Check we have OCSP and URI. */
            if ((dataASN[ACCESSDESCASN_IDX_METH].data.oid.sum == AIA_OCSP_OID) &&
 80171b6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80171b8:	2b74      	cmp	r3, #116	@ 0x74
 80171ba:	d114      	bne.n	80171e6 <DecodeAuthInfo+0xaa>
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 80171bc:	f897 3065 	ldrb.w	r3, [r7, #101]	@ 0x65
            if ((dataASN[ACCESSDESCASN_IDX_METH].data.oid.sum == AIA_OCSP_OID) &&
 80171c0:	2b86      	cmp	r3, #134	@ 0x86
 80171c2:	d110      	bne.n	80171e6 <DecodeAuthInfo+0xaa>
                    (cert->extAuthInfo == NULL)) {
 80171c4:	687b      	ldr	r3, [r7, #4]
 80171c6:	f8d3 33a4 	ldr.w	r3, [r3, #932]	@ 0x3a4
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 80171ca:	2b00      	cmp	r3, #0
 80171cc:	d10b      	bne.n	80171e6 <DecodeAuthInfo+0xaa>
                /* Store URI for OCSP lookup. */
                GetASN_GetConstRef(&dataASN[ACCESSDESCASN_IDX_LOC],
 80171ce:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80171d0:	687b      	ldr	r3, [r7, #4]
 80171d2:	f8c3 23a4 	str.w	r2, [r3, #932]	@ 0x3a4
 80171d6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80171d8:	66bb      	str	r3, [r7, #104]	@ 0x68
                        &cert->extAuthInfo, &sz32);
                cert->extAuthInfoSz = (int)sz32;
 80171da:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80171dc:	461a      	mov	r2, r3
 80171de:	687b      	ldr	r3, [r7, #4]
 80171e0:	f8c3 23a8 	str.w	r2, [r3, #936]	@ 0x3a8
 80171e4:	e016      	b.n	8017214 <DecodeAuthInfo+0xd8>
            }
        #ifdef WOLFSSL_ASN_CA_ISSUER
            /* Check we have CA Issuer and URI. */
            else if ((dataASN[ACCESSDESCASN_IDX_METH].data.oid.sum ==
 80171e6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80171e8:	2b75      	cmp	r3, #117	@ 0x75
 80171ea:	d113      	bne.n	8017214 <DecodeAuthInfo+0xd8>
                        AIA_CA_ISSUER_OID) &&
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 80171ec:	f897 3065 	ldrb.w	r3, [r7, #101]	@ 0x65
                        AIA_CA_ISSUER_OID) &&
 80171f0:	2b86      	cmp	r3, #134	@ 0x86
 80171f2:	d10f      	bne.n	8017214 <DecodeAuthInfo+0xd8>
                    (cert->extAuthInfoCaIssuer == NULL)) {
 80171f4:	687b      	ldr	r3, [r7, #4]
 80171f6:	f8d3 33ac 	ldr.w	r3, [r3, #940]	@ 0x3ac
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 80171fa:	2b00      	cmp	r3, #0
 80171fc:	d10a      	bne.n	8017214 <DecodeAuthInfo+0xd8>
                /* Set CaIssuers entry */
                GetASN_GetConstRef(&dataASN[ACCESSDESCASN_IDX_LOC],
 80171fe:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8017200:	687b      	ldr	r3, [r7, #4]
 8017202:	f8c3 23ac 	str.w	r2, [r3, #940]	@ 0x3ac
 8017206:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017208:	66bb      	str	r3, [r7, #104]	@ 0x68
                        &cert->extAuthInfoCaIssuer, &sz32);
                cert->extAuthInfoCaIssuerSz = (int)sz32;
 801720a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801720c:	461a      	mov	r2, r3
 801720e:	687b      	ldr	r3, [r7, #4]
 8017210:	f8c3 23b0 	str.w	r2, [r3, #944]	@ 0x3b0
    while ((ret == 0) && (idx < (word32)sz)) {
 8017214:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8017216:	2b00      	cmp	r3, #0
 8017218:	d103      	bne.n	8017222 <DecodeAuthInfo+0xe6>
 801721a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801721c:	68ba      	ldr	r2, [r7, #8]
 801721e:	429a      	cmp	r2, r3
 8017220:	d8a9      	bhi.n	8017176 <DecodeAuthInfo+0x3a>
        #endif
            /* Otherwise skip. */
        }
    }

    return ret;
 8017222:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
#endif
}
 8017224:	4618      	mov	r0, r3
 8017226:	3778      	adds	r7, #120	@ 0x78
 8017228:	46bd      	mov	sp, r7
 801722a:	bd80      	pop	{r7, pc}
 801722c:	08034700 	.word	0x08034700
 8017230:	0803473c 	.word	0x0803473c

08017234 <DecodeAuthKeyId>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  BUFFER_E when data in buffer is too small.
 */
static int DecodeAuthKeyId(const byte* input, word32 sz, DecodedCert* cert)
{
 8017234:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017236:	b095      	sub	sp, #84	@ 0x54
 8017238:	af04      	add	r7, sp, #16
 801723a:	60f8      	str	r0, [r7, #12]
 801723c:	60b9      	str	r1, [r7, #8]
 801723e:	607a      	str	r2, [r7, #4]
#endif /* OPENSSL_EXTRA */

    return GetHashId(input + idx, length, cert->extAuthKeyId,
        HashIdAlg(cert->signatureOID));
#else
    DECL_ASNGETDATA(dataASN, authKeyIdASN_Length);
 8017240:	2300      	movs	r3, #0
 8017242:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ret = 0;
 8017244:	2300      	movs	r3, #0
 8017246:	63bb      	str	r3, [r7, #56]	@ 0x38

    WOLFSSL_ENTER("DecodeAuthKeyId");

    CALLOC_ASNGETDATA(dataASN, authKeyIdASN_Length, ret, cert->heap);
 8017248:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801724a:	2b00      	cmp	r3, #0
 801724c:	d109      	bne.n	8017262 <DecodeAuthKeyId+0x2e>
 801724e:	2070      	movs	r0, #112	@ 0x70
 8017250:	f007 fd14 	bl	801ec7c <wolfSSL_Malloc>
 8017254:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8017256:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017258:	2b00      	cmp	r3, #0
 801725a:	d102      	bne.n	8017262 <DecodeAuthKeyId+0x2e>
 801725c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8017260:	63bb      	str	r3, [r7, #56]	@ 0x38
 8017262:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017264:	2b00      	cmp	r3, #0
 8017266:	d104      	bne.n	8017272 <DecodeAuthKeyId+0x3e>
 8017268:	2270      	movs	r2, #112	@ 0x70
 801726a:	2100      	movs	r1, #0
 801726c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801726e:	f011 fcd9 	bl	8028c24 <memset>

    if (ret == 0) {
 8017272:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017274:	2b00      	cmp	r3, #0
 8017276:	d10f      	bne.n	8017298 <DecodeAuthKeyId+0x64>
        /* Parse an authority key identifier. */
        word32 idx = 0;
 8017278:	2300      	movs	r3, #0
 801727a:	633b      	str	r3, [r7, #48]	@ 0x30
        ret = GetASN_Items(authKeyIdASN, dataASN, authKeyIdASN_Length, 1, input,
 801727c:	68bb      	ldr	r3, [r7, #8]
 801727e:	9302      	str	r3, [sp, #8]
 8017280:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8017284:	9301      	str	r3, [sp, #4]
 8017286:	68fb      	ldr	r3, [r7, #12]
 8017288:	9300      	str	r3, [sp, #0]
 801728a:	2301      	movs	r3, #1
 801728c:	2204      	movs	r2, #4
 801728e:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8017290:	484d      	ldr	r0, [pc, #308]	@ (80173c8 <DecodeAuthKeyId+0x194>)
 8017292:	f7fc faed 	bl	8013870 <GetASN_Items>
 8017296:	63b8      	str	r0, [r7, #56]	@ 0x38
                           &idx, sz);
    }
    /* Each field is optional */
    if (ret == 0 && dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data != NULL) {
 8017298:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801729a:	2b00      	cmp	r3, #0
 801729c:	d126      	bne.n	80172ec <DecodeAuthKeyId+0xb8>
 801729e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80172a0:	331c      	adds	r3, #28
 80172a2:	689b      	ldr	r3, [r3, #8]
 80172a4:	2b00      	cmp	r3, #0
 80172a6:	d021      	beq.n	80172ec <DecodeAuthKeyId+0xb8>
#ifdef OPENSSL_EXTRA
        GetASN_GetConstRef(&dataASN[AUTHKEYIDASN_IDX_KEYID],
 80172a8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80172aa:	331c      	adds	r3, #28
 80172ac:	689a      	ldr	r2, [r3, #8]
 80172ae:	687b      	ldr	r3, [r7, #4]
 80172b0:	f8c3 2438 	str.w	r2, [r3, #1080]	@ 0x438
 80172b4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80172b6:	331c      	adds	r3, #28
 80172b8:	68da      	ldr	r2, [r3, #12]
 80172ba:	687b      	ldr	r3, [r7, #4]
 80172bc:	f8c3 2408 	str.w	r2, [r3, #1032]	@ 0x408
                &cert->extAuthKeyIdSrc, &cert->extAuthKeyIdSz);
#endif /* OPENSSL_EXTRA */
        /* Get the hash or hash of the hash if wrong size. */
        ret = GetHashId(dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data,
 80172c0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80172c2:	331c      	adds	r3, #28
 80172c4:	689c      	ldr	r4, [r3, #8]
                    (int)dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.length,
 80172c6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80172c8:	331c      	adds	r3, #28
 80172ca:	68db      	ldr	r3, [r3, #12]
        ret = GetHashId(dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data,
 80172cc:	461e      	mov	r6, r3
                    cert->extAuthKeyId, HashIdAlg(cert->signatureOID));
 80172ce:	687b      	ldr	r3, [r7, #4]
 80172d0:	f503 757a 	add.w	r5, r3, #1000	@ 0x3e8
        ret = GetHashId(dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data,
 80172d4:	687b      	ldr	r3, [r7, #4]
 80172d6:	699b      	ldr	r3, [r3, #24]
 80172d8:	4618      	mov	r0, r3
 80172da:	f7fe fabd 	bl	8015858 <HashIdAlg>
 80172de:	4603      	mov	r3, r0
 80172e0:	462a      	mov	r2, r5
 80172e2:	4631      	mov	r1, r6
 80172e4:	4620      	mov	r0, r4
 80172e6:	f7fe faec 	bl	80158c2 <GetHashId>
 80172ea:	63b8      	str	r0, [r7, #56]	@ 0x38
    }
#ifdef WOLFSSL_AKID_NAME
    if (ret == 0 && dataASN[AUTHKEYIDASN_IDX_ISSUER].data.ref.data != NULL) {
 80172ec:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80172ee:	2b00      	cmp	r3, #0
 80172f0:	d130      	bne.n	8017354 <DecodeAuthKeyId+0x120>
 80172f2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80172f4:	3338      	adds	r3, #56	@ 0x38
 80172f6:	689b      	ldr	r3, [r3, #8]
 80172f8:	2b00      	cmp	r3, #0
 80172fa:	d02b      	beq.n	8017354 <DecodeAuthKeyId+0x120>
        /* We only support using one (first) name. Parse the name to perform
         * a sanity check. */
        word32 idx = 0;
 80172fc:	2300      	movs	r3, #0
 80172fe:	62fb      	str	r3, [r7, #44]	@ 0x2c
        ASNGetData nameASN[altNameASN_Length];
        XMEMSET(nameASN, 0, sizeof(nameASN));
 8017300:	f107 0310 	add.w	r3, r7, #16
 8017304:	221c      	movs	r2, #28
 8017306:	2100      	movs	r1, #0
 8017308:	4618      	mov	r0, r3
 801730a:	f011 fc8b 	bl	8028c24 <memset>
        /* Parse GeneralName with the choices supported. */
        GetASN_Choice(&nameASN[ALTNAMEASN_IDX_GN], generalNameChoice);
 801730e:	230b      	movs	r3, #11
 8017310:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
 8017314:	4b2d      	ldr	r3, [pc, #180]	@ (80173cc <DecodeAuthKeyId+0x198>)
 8017316:	61bb      	str	r3, [r7, #24]
        /* Decode a GeneralName choice. */
        ret = GetASN_Items(altNameASN, nameASN, altNameASN_Length, 0,
                dataASN[AUTHKEYIDASN_IDX_ISSUER].data.ref.data, &idx,
 8017318:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801731a:	3338      	adds	r3, #56	@ 0x38
        ret = GetASN_Items(altNameASN, nameASN, altNameASN_Length, 0,
 801731c:	689b      	ldr	r3, [r3, #8]
                dataASN[AUTHKEYIDASN_IDX_ISSUER].data.ref.length);
 801731e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8017320:	3238      	adds	r2, #56	@ 0x38
        ret = GetASN_Items(altNameASN, nameASN, altNameASN_Length, 0,
 8017322:	68d2      	ldr	r2, [r2, #12]
 8017324:	f107 0110 	add.w	r1, r7, #16
 8017328:	9202      	str	r2, [sp, #8]
 801732a:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 801732e:	9201      	str	r2, [sp, #4]
 8017330:	9300      	str	r3, [sp, #0]
 8017332:	2300      	movs	r3, #0
 8017334:	2201      	movs	r2, #1
 8017336:	4826      	ldr	r0, [pc, #152]	@ (80173d0 <DecodeAuthKeyId+0x19c>)
 8017338:	f7fc fa9a 	bl	8013870 <GetASN_Items>
 801733c:	63b8      	str	r0, [r7, #56]	@ 0x38

        if (ret == 0) {
 801733e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017340:	2b00      	cmp	r3, #0
 8017342:	d107      	bne.n	8017354 <DecodeAuthKeyId+0x120>
            GetASN_GetConstRef(&nameASN[ALTNAMEASN_IDX_GN],
 8017344:	69ba      	ldr	r2, [r7, #24]
 8017346:	687b      	ldr	r3, [r7, #4]
 8017348:	f8c3 240c 	str.w	r2, [r3, #1036]	@ 0x40c
 801734c:	69fa      	ldr	r2, [r7, #28]
 801734e:	687b      	ldr	r3, [r7, #4]
 8017350:	f8c3 2410 	str.w	r2, [r3, #1040]	@ 0x410
                    &cert->extAuthKeyIdIssuer, &cert->extAuthKeyIdIssuerSz);
        }
    }
    if (ret == 0 && dataASN[AUTHKEYIDASN_IDX_SERIAL].data.ref.data != NULL) {
 8017354:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017356:	2b00      	cmp	r3, #0
 8017358:	d110      	bne.n	801737c <DecodeAuthKeyId+0x148>
 801735a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801735c:	3354      	adds	r3, #84	@ 0x54
 801735e:	689b      	ldr	r3, [r3, #8]
 8017360:	2b00      	cmp	r3, #0
 8017362:	d00b      	beq.n	801737c <DecodeAuthKeyId+0x148>
        GetASN_GetConstRef(&dataASN[AUTHKEYIDASN_IDX_SERIAL],
 8017364:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017366:	3354      	adds	r3, #84	@ 0x54
 8017368:	689a      	ldr	r2, [r3, #8]
 801736a:	687b      	ldr	r3, [r7, #4]
 801736c:	f8c3 2414 	str.w	r2, [r3, #1044]	@ 0x414
 8017370:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017372:	3354      	adds	r3, #84	@ 0x54
 8017374:	68da      	ldr	r2, [r3, #12]
 8017376:	687b      	ldr	r3, [r7, #4]
 8017378:	f8c3 2418 	str.w	r2, [r3, #1048]	@ 0x418
                &cert->extAuthKeyIdIssuerSN, &cert->extAuthKeyIdIssuerSNSz);
    }
    if (ret == 0) {
 801737c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801737e:	2b00      	cmp	r3, #0
 8017380:	d107      	bne.n	8017392 <DecodeAuthKeyId+0x15e>
        if ((cert->extAuthKeyIdIssuerSz > 0) ^
 8017382:	687b      	ldr	r3, [r7, #4]
 8017384:	f8d3 3410 	ldr.w	r3, [r3, #1040]	@ 0x410
 8017388:	2b00      	cmp	r3, #0
                (cert->extAuthKeyIdIssuerSNSz > 0)) {
 801738a:	687b      	ldr	r3, [r7, #4]
 801738c:	f8d3 3418 	ldr.w	r3, [r3, #1048]	@ 0x418
        if ((cert->extAuthKeyIdIssuerSz > 0) ^
 8017390:	2b00      	cmp	r3, #0
            WOLFSSL_MSG("authorityCertIssuer and authorityCertSerialNumber MUST"
                       " both be present or both be absent");
        }
    }
#endif /* WOLFSSL_AKID_NAME */
    if (ret == 0) {
 8017392:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017394:	2b00      	cmp	r3, #0
 8017396:	d107      	bne.n	80173a8 <DecodeAuthKeyId+0x174>
#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_AKID_NAME)
        /* Store the raw authority key id. */
        cert->extRawAuthKeyIdSrc = input;
 8017398:	687b      	ldr	r3, [r7, #4]
 801739a:	68fa      	ldr	r2, [r7, #12]
 801739c:	f8c3 2430 	str.w	r2, [r3, #1072]	@ 0x430
        cert->extRawAuthKeyIdSz = sz;
 80173a0:	687b      	ldr	r3, [r7, #4]
 80173a2:	68ba      	ldr	r2, [r7, #8]
 80173a4:	f8c3 2434 	str.w	r2, [r3, #1076]	@ 0x434
#endif /* OPENSSL_EXTRA */
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 80173a8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80173aa:	2b00      	cmp	r3, #0
 80173ac:	d007      	beq.n	80173be <DecodeAuthKeyId+0x18a>
 80173ae:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80173b0:	637b      	str	r3, [r7, #52]	@ 0x34
 80173b2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80173b4:	2b00      	cmp	r3, #0
 80173b6:	d002      	beq.n	80173be <DecodeAuthKeyId+0x18a>
 80173b8:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80173ba:	f007 fc7b 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 80173be:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 80173c0:	4618      	mov	r0, r3
 80173c2:	3744      	adds	r7, #68	@ 0x44
 80173c4:	46bd      	mov	sp, r7
 80173c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80173c8:	08034748 	.word	0x08034748
 80173cc:	08034700 	.word	0x08034700
 80173d0:	0803470c 	.word	0x0803470c

080173d4 <DecodeSubjKeyId>:
 * @return  ASN_PARSE_E when the OCTET_STRING tag is not found or length is
 *          invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeSubjKeyId(const byte* input, word32 sz, DecodedCert* cert)
{
 80173d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80173d6:	b089      	sub	sp, #36	@ 0x24
 80173d8:	af00      	add	r7, sp, #0
 80173da:	60f8      	str	r0, [r7, #12]
 80173dc:	60b9      	str	r1, [r7, #8]
 80173de:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 80173e0:	2300      	movs	r3, #0
 80173e2:	61bb      	str	r3, [r7, #24]
    int length = 0;
 80173e4:	2300      	movs	r3, #0
 80173e6:	617b      	str	r3, [r7, #20]
    int ret = 0;
 80173e8:	2300      	movs	r3, #0
 80173ea:	61fb      	str	r3, [r7, #28]

    WOLFSSL_ENTER("DecodeSubjKeyId");

    ret = GetOctetString(input, &idx, &length, sz);
 80173ec:	f107 0214 	add.w	r2, r7, #20
 80173f0:	f107 0118 	add.w	r1, r7, #24
 80173f4:	68bb      	ldr	r3, [r7, #8]
 80173f6:	68f8      	ldr	r0, [r7, #12]
 80173f8:	f7fc fea8 	bl	801414c <GetOctetString>
 80173fc:	61f8      	str	r0, [r7, #28]
    if (ret > 0) {
 80173fe:	69fb      	ldr	r3, [r7, #28]
 8017400:	2b00      	cmp	r3, #0
 8017402:	dd1d      	ble.n	8017440 <DecodeSubjKeyId+0x6c>
        cert->extSubjKeyIdSz = (word32)length;
 8017404:	697b      	ldr	r3, [r7, #20]
 8017406:	461a      	mov	r2, r3
 8017408:	687b      	ldr	r3, [r7, #4]
 801740a:	f8c3 23e4 	str.w	r2, [r3, #996]	@ 0x3e4
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        cert->extSubjKeyIdSrc = &input[idx];
 801740e:	69bb      	ldr	r3, [r7, #24]
 8017410:	68fa      	ldr	r2, [r7, #12]
 8017412:	441a      	add	r2, r3
 8017414:	687b      	ldr	r3, [r7, #4]
 8017416:	f8c3 243c 	str.w	r2, [r3, #1084]	@ 0x43c
    #endif /* OPENSSL_EXTRA */

        /* Get the hash or hash of the hash if wrong size. */
        ret = GetHashId(input + idx, length, cert->extSubjKeyId,
 801741a:	69bb      	ldr	r3, [r7, #24]
 801741c:	68fa      	ldr	r2, [r7, #12]
 801741e:	18d4      	adds	r4, r2, r3
 8017420:	697d      	ldr	r5, [r7, #20]
 8017422:	687b      	ldr	r3, [r7, #4]
 8017424:	f503 7671 	add.w	r6, r3, #964	@ 0x3c4
 8017428:	687b      	ldr	r3, [r7, #4]
 801742a:	699b      	ldr	r3, [r3, #24]
 801742c:	4618      	mov	r0, r3
 801742e:	f7fe fa13 	bl	8015858 <HashIdAlg>
 8017432:	4603      	mov	r3, r0
 8017434:	4632      	mov	r2, r6
 8017436:	4629      	mov	r1, r5
 8017438:	4620      	mov	r0, r4
 801743a:	f7fe fa42 	bl	80158c2 <GetHashId>
 801743e:	61f8      	str	r0, [r7, #28]
            HashIdAlg(cert->signatureOID));
    }

    return ret;
 8017440:	69fb      	ldr	r3, [r7, #28]
}
 8017442:	4618      	mov	r0, r3
 8017444:	3724      	adds	r7, #36	@ 0x24
 8017446:	46bd      	mov	sp, r7
 8017448:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0801744c <DecodeKeyUsage>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeKeyUsage(const byte* input, word32 sz, DecodedCert* cert)
{
 801744c:	b580      	push	{r7, lr}
 801744e:	b094      	sub	sp, #80	@ 0x50
 8017450:	af04      	add	r7, sp, #16
 8017452:	60f8      	str	r0, [r7, #12]
 8017454:	60b9      	str	r1, [r7, #8]
 8017456:	607a      	str	r2, [r7, #4]
        cert->extKeyUsage |= (word16)(input[idx+1] << 8);

    return 0;
#else
    ASNGetData dataASN[keyUsageASN_Length];
    word32 idx = 0;
 8017458:	2300      	movs	r3, #0
 801745a:	61fb      	str	r3, [r7, #28]
    byte keyUsage[2];
    word32 keyUsageSz = sizeof(keyUsage);
 801745c:	2302      	movs	r3, #2
 801745e:	617b      	str	r3, [r7, #20]
    int ret;
    WOLFSSL_ENTER("DecodeKeyUsage");

    /* Clear dynamic data and set where to store extended key usage. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 8017460:	f107 0320 	add.w	r3, r7, #32
 8017464:	221c      	movs	r2, #28
 8017466:	2100      	movs	r1, #0
 8017468:	4618      	mov	r0, r3
 801746a:	f011 fbdb 	bl	8028c24 <memset>
    XMEMSET(keyUsage, 0, sizeof(keyUsage));
 801746e:	f107 0318 	add.w	r3, r7, #24
 8017472:	2202      	movs	r2, #2
 8017474:	2100      	movs	r1, #0
 8017476:	4618      	mov	r0, r3
 8017478:	f011 fbd4 	bl	8028c24 <memset>
    GetASN_Buffer(&dataASN[KEYUSAGEASN_IDX_STR], keyUsage, &keyUsageSz);
 801747c:	2305      	movs	r3, #5
 801747e:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
 8017482:	f107 0318 	add.w	r3, r7, #24
 8017486:	62bb      	str	r3, [r7, #40]	@ 0x28
 8017488:	f107 0314 	add.w	r3, r7, #20
 801748c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    /* Parse key usage. */
    ret = GetASN_Items(keyUsageASN, dataASN, keyUsageASN_Length, 0, input,
 801748e:	f107 0120 	add.w	r1, r7, #32
 8017492:	68bb      	ldr	r3, [r7, #8]
 8017494:	9302      	str	r3, [sp, #8]
 8017496:	f107 031c 	add.w	r3, r7, #28
 801749a:	9301      	str	r3, [sp, #4]
 801749c:	68fb      	ldr	r3, [r7, #12]
 801749e:	9300      	str	r3, [sp, #0]
 80174a0:	2300      	movs	r3, #0
 80174a2:	2201      	movs	r2, #1
 80174a4:	480f      	ldr	r0, [pc, #60]	@ (80174e4 <DecodeKeyUsage+0x98>)
 80174a6:	f7fc f9e3 	bl	8013870 <GetASN_Items>
 80174aa:	63f8      	str	r0, [r7, #60]	@ 0x3c
                        &idx, sz);
    if (ret == 0) {
 80174ac:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80174ae:	2b00      	cmp	r3, #0
 80174b0:	d112      	bne.n	80174d8 <DecodeKeyUsage+0x8c>
        /* Decode the bit string number as LE */
        cert->extKeyUsage = (word16)(keyUsage[0]);
 80174b2:	7e3b      	ldrb	r3, [r7, #24]
 80174b4:	461a      	mov	r2, r3
 80174b6:	687b      	ldr	r3, [r7, #4]
 80174b8:	f8a3 2420 	strh.w	r2, [r3, #1056]	@ 0x420
        if (keyUsageSz == 2)
 80174bc:	697b      	ldr	r3, [r7, #20]
 80174be:	2b02      	cmp	r3, #2
 80174c0:	d10a      	bne.n	80174d8 <DecodeKeyUsage+0x8c>
            cert->extKeyUsage |= (word16)(keyUsage[1] << 8);
 80174c2:	687b      	ldr	r3, [r7, #4]
 80174c4:	f8b3 2420 	ldrh.w	r2, [r3, #1056]	@ 0x420
 80174c8:	7e7b      	ldrb	r3, [r7, #25]
 80174ca:	021b      	lsls	r3, r3, #8
 80174cc:	b29b      	uxth	r3, r3
 80174ce:	4313      	orrs	r3, r2
 80174d0:	b29a      	uxth	r2, r3
 80174d2:	687b      	ldr	r3, [r7, #4]
 80174d4:	f8a3 2420 	strh.w	r2, [r3, #1056]	@ 0x420
    }
    return ret;
 80174d8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 80174da:	4618      	mov	r0, r3
 80174dc:	3740      	adds	r7, #64	@ 0x40
 80174de:	46bd      	mov	sp, r7
 80174e0:	bd80      	pop	{r7, pc}
 80174e2:	bf00      	nop
 80174e4:	08034758 	.word	0x08034758

080174e8 <DecodeExtKeyUsage>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeExtKeyUsage(const byte* input, word32 sz, DecodedCert* cert)
{
 80174e8:	b580      	push	{r7, lr}
 80174ea:	b092      	sub	sp, #72	@ 0x48
 80174ec:	af04      	add	r7, sp, #16
 80174ee:	60f8      	str	r0, [r7, #12]
 80174f0:	60b9      	str	r1, [r7, #8]
 80174f2:	607a      	str	r2, [r7, #4]
    #endif
    }

    return 0;
#else
    word32 idx = 0;
 80174f4:	2300      	movs	r3, #0
 80174f6:	633b      	str	r3, [r7, #48]	@ 0x30
    int length;
    int ret = 0;
 80174f8:	2300      	movs	r3, #0
 80174fa:	637b      	str	r3, [r7, #52]	@ 0x34

    WOLFSSL_ENTER("DecodeExtKeyUsage");

    /* Strip SEQUENCE OF and expect to account for all the data. */
    if (GetASN_Sequence(input, &idx, &length, sz, 1) < 0) {
 80174fc:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 8017500:	f107 0130 	add.w	r1, r7, #48	@ 0x30
 8017504:	2301      	movs	r3, #1
 8017506:	9300      	str	r3, [sp, #0]
 8017508:	68bb      	ldr	r3, [r7, #8]
 801750a:	68f8      	ldr	r0, [r7, #12]
 801750c:	f7fc fc57 	bl	8013dbe <GetASN_Sequence>
 8017510:	4603      	mov	r3, r0
 8017512:	2b00      	cmp	r3, #0
 8017514:	da02      	bge.n	801751c <DecodeExtKeyUsage+0x34>
        WOLFSSL_MSG("\tfail: should be a SEQUENCE");
        ret = ASN_PARSE_E;
 8017516:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801751a:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    if (ret == 0) {
 801751c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801751e:	2b00      	cmp	r3, #0
 8017520:	f040 809b 	bne.w	801765a <DecodeExtKeyUsage+0x172>
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        /* Keep reference for WOLFSSL_X509. */
        cert->extExtKeyUsageSrc = input + idx;
 8017524:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8017526:	68fa      	ldr	r2, [r7, #12]
 8017528:	441a      	add	r2, r3
 801752a:	687b      	ldr	r3, [r7, #4]
 801752c:	f8c3 2424 	str.w	r2, [r3, #1060]	@ 0x424
        cert->extExtKeyUsageSz = (word32)length;
 8017530:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017532:	461a      	mov	r2, r3
 8017534:	687b      	ldr	r3, [r7, #4]
 8017536:	f8c3 2428 	str.w	r2, [r3, #1064]	@ 0x428
    #endif
    }

    /* Check all OIDs. */
    while ((ret == 0) && (idx < (word32)sz)) {
 801753a:	e08e      	b.n	801765a <DecodeExtKeyUsage+0x172>
        ASNGetData dataASN[keyPurposeIdASN_Length];

        /* Clear dynamic data items and set OID type expected. */
        XMEMSET(dataASN, 0, sizeof(dataASN));
 801753c:	f107 0310 	add.w	r3, r7, #16
 8017540:	221c      	movs	r2, #28
 8017542:	2100      	movs	r1, #0
 8017544:	4618      	mov	r0, r3
 8017546:	f011 fb6d 	bl	8028c24 <memset>
        GetASN_OID(&dataASN[KEYPURPOSEIDASN_IDX_OID], oidIgnoreType);
 801754a:	2315      	movs	r3, #21
 801754c:	623b      	str	r3, [r7, #32]
        /* Decode KeyPurposeId. */
        ret = GetASN_Items(keyPurposeIdASN, dataASN, keyPurposeIdASN_Length, 0,
 801754e:	f107 0110 	add.w	r1, r7, #16
 8017552:	68bb      	ldr	r3, [r7, #8]
 8017554:	9302      	str	r3, [sp, #8]
 8017556:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 801755a:	9301      	str	r3, [sp, #4]
 801755c:	68fb      	ldr	r3, [r7, #12]
 801755e:	9300      	str	r3, [sp, #0]
 8017560:	2300      	movs	r3, #0
 8017562:	2201      	movs	r2, #1
 8017564:	4843      	ldr	r0, [pc, #268]	@ (8017674 <DecodeExtKeyUsage+0x18c>)
 8017566:	f7fc f983 	bl	8013870 <GetASN_Items>
 801756a:	6378      	str	r0, [r7, #52]	@ 0x34
                           input, &idx, sz);
        /* Skip unknown OIDs. */
        if (ret == WC_NO_ERR_TRACE(ASN_UNKNOWN_OID_E)) {
 801756c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801756e:	f113 0f94 	cmn.w	r3, #148	@ 0x94
 8017572:	d102      	bne.n	801757a <DecodeExtKeyUsage+0x92>
            ret = 0;
 8017574:	2300      	movs	r3, #0
 8017576:	637b      	str	r3, [r7, #52]	@ 0x34
 8017578:	e06f      	b.n	801765a <DecodeExtKeyUsage+0x172>
        }
        else if (ret == 0) {
 801757a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801757c:	2b00      	cmp	r3, #0
 801757e:	d16c      	bne.n	801765a <DecodeExtKeyUsage+0x172>
            /* Store the bit for the OID. */
            switch (dataASN[KEYPURPOSEIDASN_IDX_OID].data.oid.sum) {
 8017580:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017582:	2b4f      	cmp	r3, #79	@ 0x4f
 8017584:	d81a      	bhi.n	80175bc <DecodeExtKeyUsage+0xd4>
 8017586:	2b47      	cmp	r3, #71	@ 0x47
 8017588:	d360      	bcc.n	801764c <DecodeExtKeyUsage+0x164>
 801758a:	3b47      	subs	r3, #71	@ 0x47
 801758c:	2b08      	cmp	r3, #8
 801758e:	d85d      	bhi.n	801764c <DecodeExtKeyUsage+0x164>
 8017590:	a201      	add	r2, pc, #4	@ (adr r2, 8017598 <DecodeExtKeyUsage+0xb0>)
 8017592:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017596:	bf00      	nop
 8017598:	080175d5 	.word	0x080175d5
 801759c:	080175e9 	.word	0x080175e9
 80175a0:	080175fd 	.word	0x080175fd
 80175a4:	08017611 	.word	0x08017611
 80175a8:	0801764d 	.word	0x0801764d
 80175ac:	0801764d 	.word	0x0801764d
 80175b0:	0801764d 	.word	0x0801764d
 80175b4:	08017625 	.word	0x08017625
 80175b8:	08017639 	.word	0x08017639
 80175bc:	2b97      	cmp	r3, #151	@ 0x97
 80175be:	d145      	bne.n	801764c <DecodeExtKeyUsage+0x164>
                case EKU_ANY_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_ANY;
 80175c0:	687b      	ldr	r3, [r7, #4]
 80175c2:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 80175c6:	f043 0301 	orr.w	r3, r3, #1
 80175ca:	b2da      	uxtb	r2, r3
 80175cc:	687b      	ldr	r3, [r7, #4]
 80175ce:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 80175d2:	e03b      	b.n	801764c <DecodeExtKeyUsage+0x164>
                case EKU_SERVER_AUTH_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_SERVER_AUTH;
 80175d4:	687b      	ldr	r3, [r7, #4]
 80175d6:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 80175da:	f043 0302 	orr.w	r3, r3, #2
 80175de:	b2da      	uxtb	r2, r3
 80175e0:	687b      	ldr	r3, [r7, #4]
 80175e2:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 80175e6:	e031      	b.n	801764c <DecodeExtKeyUsage+0x164>
                case EKU_CLIENT_AUTH_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_CLIENT_AUTH;
 80175e8:	687b      	ldr	r3, [r7, #4]
 80175ea:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 80175ee:	f043 0304 	orr.w	r3, r3, #4
 80175f2:	b2da      	uxtb	r2, r3
 80175f4:	687b      	ldr	r3, [r7, #4]
 80175f6:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 80175fa:	e027      	b.n	801764c <DecodeExtKeyUsage+0x164>
                case EKU_CODESIGNING_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_CODESIGN;
 80175fc:	687b      	ldr	r3, [r7, #4]
 80175fe:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 8017602:	f043 0308 	orr.w	r3, r3, #8
 8017606:	b2da      	uxtb	r2, r3
 8017608:	687b      	ldr	r3, [r7, #4]
 801760a:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 801760e:	e01d      	b.n	801764c <DecodeExtKeyUsage+0x164>
                case EKU_EMAILPROTECT_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_EMAILPROT;
 8017610:	687b      	ldr	r3, [r7, #4]
 8017612:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 8017616:	f043 0310 	orr.w	r3, r3, #16
 801761a:	b2da      	uxtb	r2, r3
 801761c:	687b      	ldr	r3, [r7, #4]
 801761e:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 8017622:	e013      	b.n	801764c <DecodeExtKeyUsage+0x164>
                case EKU_TIMESTAMP_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_TIMESTAMP;
 8017624:	687b      	ldr	r3, [r7, #4]
 8017626:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 801762a:	f043 0320 	orr.w	r3, r3, #32
 801762e:	b2da      	uxtb	r2, r3
 8017630:	687b      	ldr	r3, [r7, #4]
 8017632:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 8017636:	e009      	b.n	801764c <DecodeExtKeyUsage+0x164>
                case EKU_OCSP_SIGN_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_OCSP_SIGN;
 8017638:	687b      	ldr	r3, [r7, #4]
 801763a:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 801763e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8017642:	b2da      	uxtb	r2, r3
 8017644:	687b      	ldr	r3, [r7, #4]
 8017646:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 801764a:	bf00      	nop
            }

        #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
            /* Keep count for WOLFSSL_X509. */
            cert->extExtKeyUsageCount++;
 801764c:	687b      	ldr	r3, [r7, #4]
 801764e:	f8d3 342c 	ldr.w	r3, [r3, #1068]	@ 0x42c
 8017652:	1c5a      	adds	r2, r3, #1
 8017654:	687b      	ldr	r3, [r7, #4]
 8017656:	f8c3 242c 	str.w	r2, [r3, #1068]	@ 0x42c
    while ((ret == 0) && (idx < (word32)sz)) {
 801765a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801765c:	2b00      	cmp	r3, #0
 801765e:	d104      	bne.n	801766a <DecodeExtKeyUsage+0x182>
 8017660:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8017662:	68ba      	ldr	r2, [r7, #8]
 8017664:	429a      	cmp	r2, r3
 8017666:	f63f af69 	bhi.w	801753c <DecodeExtKeyUsage+0x54>
        #endif
        }
    }

    return ret;
 801766a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801766c:	4618      	mov	r0, r3
 801766e:	3738      	adds	r7, #56	@ 0x38
 8017670:	46bd      	mov	sp, r7
 8017672:	bd80      	pop	{r7, pc}
 8017674:	0803475c 	.word	0x0803475c

08017678 <DecodeNsCertType>:

#ifndef IGNORE_NETSCAPE_CERT_TYPE

static int DecodeNsCertType(const byte* input, int sz, DecodedCert* cert)
{
 8017678:	b580      	push	{r7, lr}
 801767a:	b088      	sub	sp, #32
 801767c:	af02      	add	r7, sp, #8
 801767e:	60f8      	str	r0, [r7, #12]
 8017680:	60b9      	str	r1, [r7, #8]
 8017682:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 8017684:	2300      	movs	r3, #0
 8017686:	617b      	str	r3, [r7, #20]
    int len = 0;
 8017688:	2300      	movs	r3, #0
 801768a:	613b      	str	r3, [r7, #16]

    WOLFSSL_ENTER("DecodeNsCertType");

    if (CheckBitString(input, &idx, &len, (word32)sz, 0, NULL) < 0)
 801768c:	68bb      	ldr	r3, [r7, #8]
 801768e:	f107 0210 	add.w	r2, r7, #16
 8017692:	f107 0114 	add.w	r1, r7, #20
 8017696:	2000      	movs	r0, #0
 8017698:	9001      	str	r0, [sp, #4]
 801769a:	2000      	movs	r0, #0
 801769c:	9000      	str	r0, [sp, #0]
 801769e:	68f8      	ldr	r0, [r7, #12]
 80176a0:	f7fc fd68 	bl	8014174 <CheckBitString>
 80176a4:	4603      	mov	r3, r0
 80176a6:	2b00      	cmp	r3, #0
 80176a8:	da02      	bge.n	80176b0 <DecodeNsCertType+0x38>
        return ASN_PARSE_E;
 80176aa:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80176ae:	e00e      	b.n	80176ce <DecodeNsCertType+0x56>

    /* Don't need to worry about unused bits as CheckBitString makes sure
     * they're zero. */
    if (idx < (word32)sz)
 80176b0:	697a      	ldr	r2, [r7, #20]
 80176b2:	68bb      	ldr	r3, [r7, #8]
 80176b4:	429a      	cmp	r2, r3
 80176b6:	d208      	bcs.n	80176ca <DecodeNsCertType+0x52>
        cert->nsCertType = input[idx];
 80176b8:	697b      	ldr	r3, [r7, #20]
 80176ba:	68fa      	ldr	r2, [r7, #12]
 80176bc:	4413      	add	r3, r2
 80176be:	781a      	ldrb	r2, [r3, #0]
 80176c0:	687b      	ldr	r3, [r7, #4]
 80176c2:	f883 246c 	strb.w	r2, [r3, #1132]	@ 0x46c
    else
        return ASN_PARSE_E;

    return 0;
 80176c6:	2300      	movs	r3, #0
 80176c8:	e001      	b.n	80176ce <DecodeNsCertType+0x56>
        return ASN_PARSE_E;
 80176ca:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
}
 80176ce:	4618      	mov	r0, r3
 80176d0:	3718      	adds	r7, #24
 80176d2:	46bd      	mov	sp, r7
 80176d4:	bd80      	pop	{r7, pc}

080176d6 <DecodeSubtreeGeneralName>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  ASN_PARSE_E when SEQUENCE is not found as expected.
 */
static int DecodeSubtreeGeneralName(const byte* input, word32 sz, byte tag,
                                    Base_entry** head, void* heap)
{
 80176d6:	b580      	push	{r7, lr}
 80176d8:	b08c      	sub	sp, #48	@ 0x30
 80176da:	af02      	add	r7, sp, #8
 80176dc:	60f8      	str	r0, [r7, #12]
 80176de:	60b9      	str	r1, [r7, #8]
 80176e0:	603b      	str	r3, [r7, #0]
 80176e2:	4613      	mov	r3, r2
 80176e4:	71fb      	strb	r3, [r7, #7]
    Base_entry* entry = NULL;
 80176e6:	2300      	movs	r3, #0
 80176e8:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 nameIdx = 0;
 80176ea:	2300      	movs	r3, #0
 80176ec:	617b      	str	r3, [r7, #20]
    word32 len = sz;
 80176ee:	68bb      	ldr	r3, [r7, #8]
 80176f0:	623b      	str	r3, [r7, #32]
    int strLen;
    int ret = 0;
 80176f2:	2300      	movs	r3, #0
 80176f4:	61fb      	str	r3, [r7, #28]

    (void)heap;

    /* if constructed has leading sequence */
    if ((tag & ASN_CONSTRUCTED) == ASN_CONSTRUCTED) {
 80176f6:	79fb      	ldrb	r3, [r7, #7]
 80176f8:	f003 0320 	and.w	r3, r3, #32
 80176fc:	2b00      	cmp	r3, #0
 80176fe:	d015      	beq.n	801772c <DecodeSubtreeGeneralName+0x56>
        ret = GetASN_Sequence(input, &nameIdx, &strLen, sz, 0);
 8017700:	f107 0210 	add.w	r2, r7, #16
 8017704:	f107 0114 	add.w	r1, r7, #20
 8017708:	2300      	movs	r3, #0
 801770a:	9300      	str	r3, [sp, #0]
 801770c:	68bb      	ldr	r3, [r7, #8]
 801770e:	68f8      	ldr	r0, [r7, #12]
 8017710:	f7fc fb55 	bl	8013dbe <GetASN_Sequence>
 8017714:	61f8      	str	r0, [r7, #28]
        if (ret < 0) {
 8017716:	69fb      	ldr	r3, [r7, #28]
 8017718:	2b00      	cmp	r3, #0
 801771a:	da03      	bge.n	8017724 <DecodeSubtreeGeneralName+0x4e>
            ret = ASN_PARSE_E;
 801771c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017720:	61fb      	str	r3, [r7, #28]
 8017722:	e003      	b.n	801772c <DecodeSubtreeGeneralName+0x56>
        }
        else {
            len = (word32)strLen;
 8017724:	693b      	ldr	r3, [r7, #16]
 8017726:	623b      	str	r3, [r7, #32]
            ret = 0;
 8017728:	2300      	movs	r3, #0
 801772a:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 801772c:	69fb      	ldr	r3, [r7, #28]
 801772e:	2b00      	cmp	r3, #0
 8017730:	d109      	bne.n	8017746 <DecodeSubtreeGeneralName+0x70>
        /* TODO: consider one malloc. */
        /* Allocate Base Entry object. */
        entry = (Base_entry*)XMALLOC(sizeof(Base_entry), heap,
 8017732:	2010      	movs	r0, #16
 8017734:	f007 faa2 	bl	801ec7c <wolfSSL_Malloc>
 8017738:	6278      	str	r0, [r7, #36]	@ 0x24
                                     DYNAMIC_TYPE_ALTNAME);
        if (entry == NULL) {
 801773a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801773c:	2b00      	cmp	r3, #0
 801773e:	d102      	bne.n	8017746 <DecodeSubtreeGeneralName+0x70>
            ret = MEMORY_E;
 8017740:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8017744:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 8017746:	69fb      	ldr	r3, [r7, #28]
 8017748:	2b00      	cmp	r3, #0
 801774a:	d116      	bne.n	801777a <DecodeSubtreeGeneralName+0xa4>
        /* Allocate name. */
        entry->name = (char*)XMALLOC(len + 1, heap, DYNAMIC_TYPE_ALTNAME);
 801774c:	6a3b      	ldr	r3, [r7, #32]
 801774e:	3301      	adds	r3, #1
 8017750:	4618      	mov	r0, r3
 8017752:	f007 fa93 	bl	801ec7c <wolfSSL_Malloc>
 8017756:	4602      	mov	r2, r0
 8017758:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801775a:	605a      	str	r2, [r3, #4]
        if (entry->name == NULL) {
 801775c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801775e:	685b      	ldr	r3, [r3, #4]
 8017760:	2b00      	cmp	r3, #0
 8017762:	d10a      	bne.n	801777a <DecodeSubtreeGeneralName+0xa4>
            XFREE(entry, heap, DYNAMIC_TYPE_ALTNAME);
 8017764:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017766:	61bb      	str	r3, [r7, #24]
 8017768:	69bb      	ldr	r3, [r7, #24]
 801776a:	2b00      	cmp	r3, #0
 801776c:	d002      	beq.n	8017774 <DecodeSubtreeGeneralName+0x9e>
 801776e:	69b8      	ldr	r0, [r7, #24]
 8017770:	f007 faa0 	bl	801ecb4 <wolfSSL_Free>
            ret = MEMORY_E;
 8017774:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8017778:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 801777a:	69fb      	ldr	r3, [r7, #28]
 801777c:	2b00      	cmp	r3, #0
 801777e:	d11e      	bne.n	80177be <DecodeSubtreeGeneralName+0xe8>
        /* Store name, size and tag in object. */
        XMEMCPY(entry->name, &input[nameIdx], len);
 8017780:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017782:	6858      	ldr	r0, [r3, #4]
 8017784:	697b      	ldr	r3, [r7, #20]
 8017786:	68fa      	ldr	r2, [r7, #12]
 8017788:	4413      	add	r3, r2
 801778a:	6a3a      	ldr	r2, [r7, #32]
 801778c:	4619      	mov	r1, r3
 801778e:	f011 fafa 	bl	8028d86 <memcpy>
        entry->name[len] = '\0';
 8017792:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017794:	685a      	ldr	r2, [r3, #4]
 8017796:	6a3b      	ldr	r3, [r7, #32]
 8017798:	4413      	add	r3, r2
 801779a:	2200      	movs	r2, #0
 801779c:	701a      	strb	r2, [r3, #0]
        entry->nameSz = (int)len;
 801779e:	6a3a      	ldr	r2, [r7, #32]
 80177a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80177a2:	609a      	str	r2, [r3, #8]
        entry->type = tag & ASN_TYPE_MASK;
 80177a4:	79fb      	ldrb	r3, [r7, #7]
 80177a6:	f003 031f 	and.w	r3, r3, #31
 80177aa:	b2da      	uxtb	r2, r3
 80177ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80177ae:	731a      	strb	r2, [r3, #12]

        /* Put entry at front of linked list. */
        entry->next = *head;
 80177b0:	683b      	ldr	r3, [r7, #0]
 80177b2:	681a      	ldr	r2, [r3, #0]
 80177b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80177b6:	601a      	str	r2, [r3, #0]
        *head = entry;
 80177b8:	683b      	ldr	r3, [r7, #0]
 80177ba:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80177bc:	601a      	str	r2, [r3, #0]
    }

    return ret;
 80177be:	69fb      	ldr	r3, [r7, #28]
}
 80177c0:	4618      	mov	r0, r3
 80177c2:	3728      	adds	r7, #40	@ 0x28
 80177c4:	46bd      	mov	sp, r7
 80177c6:	bd80      	pop	{r7, pc}

080177c8 <DecodeSubtree>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  ASN_PARSE_E when SEQUENCE is not found as expected.
 */
static int DecodeSubtree(const byte* input, word32 sz, Base_entry** head,
                         word32 limit, void* heap)
{
 80177c8:	b580      	push	{r7, lr}
 80177ca:	b090      	sub	sp, #64	@ 0x40
 80177cc:	af04      	add	r7, sp, #16
 80177ce:	60f8      	str	r0, [r7, #12]
 80177d0:	60b9      	str	r1, [r7, #8]
 80177d2:	607a      	str	r2, [r7, #4]
 80177d4:	603b      	str	r3, [r7, #0]
        idx += (word32)seqLength;
    }

    return ret;
#else
    DECL_ASNGETDATA(dataASN, subTreeASN_Length);
 80177d6:	2300      	movs	r3, #0
 80177d8:	62fb      	str	r3, [r7, #44]	@ 0x2c
    word32 idx = 0;
 80177da:	2300      	movs	r3, #0
 80177dc:	61bb      	str	r3, [r7, #24]
    int ret = 0;
 80177de:	2300      	movs	r3, #0
 80177e0:	62bb      	str	r3, [r7, #40]	@ 0x28
    word32 cnt = 0;
 80177e2:	2300      	movs	r3, #0
 80177e4:	627b      	str	r3, [r7, #36]	@ 0x24

    (void)heap;

    ALLOC_ASNGETDATA(dataASN, subTreeASN_Length, ret, heap);
 80177e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80177e8:	2b00      	cmp	r3, #0
 80177ea:	d16b      	bne.n	80178c4 <DecodeSubtree+0xfc>
 80177ec:	2070      	movs	r0, #112	@ 0x70
 80177ee:	f007 fa45 	bl	801ec7c <wolfSSL_Malloc>
 80177f2:	62f8      	str	r0, [r7, #44]	@ 0x2c
 80177f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80177f6:	2b00      	cmp	r3, #0
 80177f8:	d164      	bne.n	80178c4 <DecodeSubtree+0xfc>
 80177fa:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80177fe:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Process all subtrees. */
    while ((ret == 0) && (idx < (word32)sz)) {
 8017800:	e060      	b.n	80178c4 <DecodeSubtree+0xfc>
        byte minVal = 0;
 8017802:	2300      	movs	r3, #0
 8017804:	75fb      	strb	r3, [r7, #23]
        byte maxVal = 0;
 8017806:	2300      	movs	r3, #0
 8017808:	75bb      	strb	r3, [r7, #22]
        if (limit > 0) {
 801780a:	683b      	ldr	r3, [r7, #0]
 801780c:	2b00      	cmp	r3, #0
 801780e:	d00a      	beq.n	8017826 <DecodeSubtree+0x5e>
            cnt++;
 8017810:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017812:	3301      	adds	r3, #1
 8017814:	627b      	str	r3, [r7, #36]	@ 0x24
            if (cnt > limit) {
 8017816:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8017818:	683b      	ldr	r3, [r7, #0]
 801781a:	429a      	cmp	r2, r3
 801781c:	d903      	bls.n	8017826 <DecodeSubtree+0x5e>
                WOLFSSL_MSG("too many name constraints");
                ret = ASN_NAME_INVALID_E;
 801781e:	f06f 03c5 	mvn.w	r3, #197	@ 0xc5
 8017822:	62bb      	str	r3, [r7, #40]	@ 0x28
 8017824:	e055      	b.n	80178d2 <DecodeSubtree+0x10a>
        }

        /* Clear dynamic data and set choice for GeneralName and location to
         * store minimum and maximum.
         */
        XMEMSET(dataASN, 0, sizeof(*dataASN) * subTreeASN_Length);
 8017826:	2270      	movs	r2, #112	@ 0x70
 8017828:	2100      	movs	r1, #0
 801782a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801782c:	f011 f9fa 	bl	8028c24 <memset>
        GetASN_Choice(&dataASN[SUBTREEASN_IDX_BASE], generalNameChoice);
 8017830:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017832:	331c      	adds	r3, #28
 8017834:	220b      	movs	r2, #11
 8017836:	761a      	strb	r2, [r3, #24]
 8017838:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801783a:	331c      	adds	r3, #28
 801783c:	4a2d      	ldr	r2, [pc, #180]	@ (80178f4 <DecodeSubtree+0x12c>)
 801783e:	609a      	str	r2, [r3, #8]
        GetASN_Int8Bit(&dataASN[SUBTREEASN_IDX_MIN], &minVal);
 8017840:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017842:	3338      	adds	r3, #56	@ 0x38
 8017844:	2201      	movs	r2, #1
 8017846:	761a      	strb	r2, [r3, #24]
 8017848:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801784a:	3338      	adds	r3, #56	@ 0x38
 801784c:	f107 0217 	add.w	r2, r7, #23
 8017850:	609a      	str	r2, [r3, #8]
        GetASN_Int8Bit(&dataASN[SUBTREEASN_IDX_MAX], &maxVal);
 8017852:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017854:	3354      	adds	r3, #84	@ 0x54
 8017856:	2201      	movs	r2, #1
 8017858:	761a      	strb	r2, [r3, #24]
 801785a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801785c:	3354      	adds	r3, #84	@ 0x54
 801785e:	f107 0216 	add.w	r2, r7, #22
 8017862:	609a      	str	r2, [r3, #8]
        /* Parse GeneralSubtree. */
        ret = GetASN_Items(subTreeASN, dataASN, subTreeASN_Length, 0, input,
 8017864:	68bb      	ldr	r3, [r7, #8]
 8017866:	9302      	str	r3, [sp, #8]
 8017868:	f107 0318 	add.w	r3, r7, #24
 801786c:	9301      	str	r3, [sp, #4]
 801786e:	68fb      	ldr	r3, [r7, #12]
 8017870:	9300      	str	r3, [sp, #0]
 8017872:	2300      	movs	r3, #0
 8017874:	2204      	movs	r2, #4
 8017876:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8017878:	481f      	ldr	r0, [pc, #124]	@ (80178f8 <DecodeSubtree+0x130>)
 801787a:	f7fb fff9 	bl	8013870 <GetASN_Items>
 801787e:	62b8      	str	r0, [r7, #40]	@ 0x28
                           &idx, sz);
        if (ret == 0) {
 8017880:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017882:	2b00      	cmp	r3, #0
 8017884:	d11e      	bne.n	80178c4 <DecodeSubtree+0xfc>
            byte t = dataASN[SUBTREEASN_IDX_BASE].tag;
 8017886:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017888:	331c      	adds	r3, #28
 801788a:	7e5b      	ldrb	r3, [r3, #25]
 801788c:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23

            /* Check GeneralName tag is one of the types we can handle. */
            if (t == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE) ||
 8017890:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8017894:	2b82      	cmp	r3, #130	@ 0x82
 8017896:	d007      	beq.n	80178a8 <DecodeSubtree+0xe0>
 8017898:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 801789c:	2b81      	cmp	r3, #129	@ 0x81
 801789e:	d003      	beq.n	80178a8 <DecodeSubtree+0xe0>
                t == (ASN_CONTEXT_SPECIFIC | ASN_RFC822_TYPE) ||
 80178a0:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 80178a4:	2ba4      	cmp	r3, #164	@ 0xa4
 80178a6:	d10d      	bne.n	80178c4 <DecodeSubtree+0xfc>
                t == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_DIR_TYPE)) {
                /* Parse the general name and store a new entry. */
                ret = DecodeSubtreeGeneralName(input +
                    GetASNItem_DataIdx(dataASN[SUBTREEASN_IDX_BASE], input),
 80178a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80178aa:	331c      	adds	r3, #28
                ret = DecodeSubtreeGeneralName(input +
 80178ac:	6898      	ldr	r0, [r3, #8]
                    dataASN[SUBTREEASN_IDX_BASE].length, t, head, heap);
 80178ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80178b0:	331c      	adds	r3, #28
                ret = DecodeSubtreeGeneralName(input +
 80178b2:	6859      	ldr	r1, [r3, #4]
 80178b4:	f897 2023 	ldrb.w	r2, [r7, #35]	@ 0x23
 80178b8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80178ba:	9300      	str	r3, [sp, #0]
 80178bc:	687b      	ldr	r3, [r7, #4]
 80178be:	f7ff ff0a 	bl	80176d6 <DecodeSubtreeGeneralName>
 80178c2:	62b8      	str	r0, [r7, #40]	@ 0x28
    while ((ret == 0) && (idx < (word32)sz)) {
 80178c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80178c6:	2b00      	cmp	r3, #0
 80178c8:	d103      	bne.n	80178d2 <DecodeSubtree+0x10a>
 80178ca:	69bb      	ldr	r3, [r7, #24]
 80178cc:	68ba      	ldr	r2, [r7, #8]
 80178ce:	429a      	cmp	r2, r3
 80178d0:	d897      	bhi.n	8017802 <DecodeSubtree+0x3a>
            }
            /* Skip entry. */
        }
    }

    FREE_ASNGETDATA(dataASN, heap);
 80178d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80178d4:	2b00      	cmp	r3, #0
 80178d6:	d007      	beq.n	80178e8 <DecodeSubtree+0x120>
 80178d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80178da:	61fb      	str	r3, [r7, #28]
 80178dc:	69fb      	ldr	r3, [r7, #28]
 80178de:	2b00      	cmp	r3, #0
 80178e0:	d002      	beq.n	80178e8 <DecodeSubtree+0x120>
 80178e2:	69f8      	ldr	r0, [r7, #28]
 80178e4:	f007 f9e6 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 80178e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif
}
 80178ea:	4618      	mov	r0, r3
 80178ec:	3730      	adds	r7, #48	@ 0x30
 80178ee:	46bd      	mov	sp, r7
 80178f0:	bd80      	pop	{r7, pc}
 80178f2:	bf00      	nop
 80178f4:	08034700 	.word	0x08034700
 80178f8:	08034760 	.word	0x08034760

080178fc <DecodeNameConstraints>:
 *          is invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeNameConstraints(const byte* input, word32 sz,
    DecodedCert* cert)
{
 80178fc:	b580      	push	{r7, lr}
 80178fe:	b08c      	sub	sp, #48	@ 0x30
 8017900:	af04      	add	r7, sp, #16
 8017902:	60f8      	str	r0, [r7, #12]
 8017904:	60b9      	str	r1, [r7, #8]
 8017906:	607a      	str	r2, [r7, #4]
        idx += (word32)length;
    }

    return 0;
#else
    DECL_ASNGETDATA(dataASN, nameConstraintsASN_Length);
 8017908:	2300      	movs	r3, #0
 801790a:	61fb      	str	r3, [r7, #28]
    word32 idx = 0;
 801790c:	2300      	movs	r3, #0
 801790e:	613b      	str	r3, [r7, #16]
    int    ret = 0;
 8017910:	2300      	movs	r3, #0
 8017912:	61bb      	str	r3, [r7, #24]

    CALLOC_ASNGETDATA(dataASN, nameConstraintsASN_Length, ret, cert->heap);
 8017914:	69bb      	ldr	r3, [r7, #24]
 8017916:	2b00      	cmp	r3, #0
 8017918:	d109      	bne.n	801792e <DecodeNameConstraints+0x32>
 801791a:	2054      	movs	r0, #84	@ 0x54
 801791c:	f007 f9ae 	bl	801ec7c <wolfSSL_Malloc>
 8017920:	61f8      	str	r0, [r7, #28]
 8017922:	69fb      	ldr	r3, [r7, #28]
 8017924:	2b00      	cmp	r3, #0
 8017926:	d102      	bne.n	801792e <DecodeNameConstraints+0x32>
 8017928:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801792c:	61bb      	str	r3, [r7, #24]
 801792e:	69bb      	ldr	r3, [r7, #24]
 8017930:	2b00      	cmp	r3, #0
 8017932:	d104      	bne.n	801793e <DecodeNameConstraints+0x42>
 8017934:	2254      	movs	r2, #84	@ 0x54
 8017936:	2100      	movs	r1, #0
 8017938:	69f8      	ldr	r0, [r7, #28]
 801793a:	f011 f973 	bl	8028c24 <memset>

    if (ret == 0) {
 801793e:	69bb      	ldr	r3, [r7, #24]
 8017940:	2b00      	cmp	r3, #0
 8017942:	d10d      	bne.n	8017960 <DecodeNameConstraints+0x64>
        /* Parse NameConstraints. */
        ret = GetASN_Items(nameConstraintsASN, dataASN,
 8017944:	68bb      	ldr	r3, [r7, #8]
 8017946:	9302      	str	r3, [sp, #8]
 8017948:	f107 0310 	add.w	r3, r7, #16
 801794c:	9301      	str	r3, [sp, #4]
 801794e:	68fb      	ldr	r3, [r7, #12]
 8017950:	9300      	str	r3, [sp, #0]
 8017952:	2301      	movs	r3, #1
 8017954:	2203      	movs	r2, #3
 8017956:	69f9      	ldr	r1, [r7, #28]
 8017958:	4822      	ldr	r0, [pc, #136]	@ (80179e4 <DecodeNameConstraints+0xe8>)
 801795a:	f7fb ff89 	bl	8013870 <GetASN_Items>
 801795e:	61b8      	str	r0, [r7, #24]
                           nameConstraintsASN_Length, 1, input, &idx, sz);
    }
    if (ret == 0) {
 8017960:	69bb      	ldr	r3, [r7, #24]
 8017962:	2b00      	cmp	r3, #0
 8017964:	d115      	bne.n	8017992 <DecodeNameConstraints+0x96>
        /* If there was a permittedSubtrees then parse it. */
        if (dataASN[NAMECONSTRAINTSASN_IDX_PERMIT].data.ref.data != NULL) {
 8017966:	69fb      	ldr	r3, [r7, #28]
 8017968:	331c      	adds	r3, #28
 801796a:	689b      	ldr	r3, [r3, #8]
 801796c:	2b00      	cmp	r3, #0
 801796e:	d010      	beq.n	8017992 <DecodeNameConstraints+0x96>
            ret = DecodeSubtree(
                    dataASN[NAMECONSTRAINTSASN_IDX_PERMIT].data.ref.data,
 8017970:	69fb      	ldr	r3, [r7, #28]
 8017972:	331c      	adds	r3, #28
            ret = DecodeSubtree(
 8017974:	6898      	ldr	r0, [r3, #8]
                    dataASN[NAMECONSTRAINTSASN_IDX_PERMIT].data.ref.length,
 8017976:	69fb      	ldr	r3, [r7, #28]
 8017978:	331c      	adds	r3, #28
            ret = DecodeSubtree(
 801797a:	68d9      	ldr	r1, [r3, #12]
 801797c:	687b      	ldr	r3, [r7, #4]
 801797e:	f103 0238 	add.w	r2, r3, #56	@ 0x38
 8017982:	687b      	ldr	r3, [r7, #4]
 8017984:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8017988:	9300      	str	r3, [sp, #0]
 801798a:	2380      	movs	r3, #128	@ 0x80
 801798c:	f7ff ff1c 	bl	80177c8 <DecodeSubtree>
 8017990:	61b8      	str	r0, [r7, #24]
                    &cert->permittedNames, WOLFSSL_MAX_NAME_CONSTRAINTS,
                    cert->heap);
        }
    }
    if (ret == 0) {
 8017992:	69bb      	ldr	r3, [r7, #24]
 8017994:	2b00      	cmp	r3, #0
 8017996:	d115      	bne.n	80179c4 <DecodeNameConstraints+0xc8>
        /* If there was a excludedSubtrees then parse it. */
        if (dataASN[NAMECONSTRAINTSASN_IDX_EXCLUDE].data.ref.data != NULL) {
 8017998:	69fb      	ldr	r3, [r7, #28]
 801799a:	3338      	adds	r3, #56	@ 0x38
 801799c:	689b      	ldr	r3, [r3, #8]
 801799e:	2b00      	cmp	r3, #0
 80179a0:	d010      	beq.n	80179c4 <DecodeNameConstraints+0xc8>
            ret = DecodeSubtree(
                    dataASN[NAMECONSTRAINTSASN_IDX_EXCLUDE].data.ref.data,
 80179a2:	69fb      	ldr	r3, [r7, #28]
 80179a4:	3338      	adds	r3, #56	@ 0x38
            ret = DecodeSubtree(
 80179a6:	6898      	ldr	r0, [r3, #8]
                    dataASN[NAMECONSTRAINTSASN_IDX_EXCLUDE].data.ref.length,
 80179a8:	69fb      	ldr	r3, [r7, #28]
 80179aa:	3338      	adds	r3, #56	@ 0x38
            ret = DecodeSubtree(
 80179ac:	68d9      	ldr	r1, [r3, #12]
 80179ae:	687b      	ldr	r3, [r7, #4]
 80179b0:	f103 023c 	add.w	r2, r3, #60	@ 0x3c
 80179b4:	687b      	ldr	r3, [r7, #4]
 80179b6:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 80179ba:	9300      	str	r3, [sp, #0]
 80179bc:	2380      	movs	r3, #128	@ 0x80
 80179be:	f7ff ff03 	bl	80177c8 <DecodeSubtree>
 80179c2:	61b8      	str	r0, [r7, #24]
                    &cert->excludedNames, WOLFSSL_MAX_NAME_CONSTRAINTS,
                    cert->heap);
        }
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 80179c4:	69fb      	ldr	r3, [r7, #28]
 80179c6:	2b00      	cmp	r3, #0
 80179c8:	d007      	beq.n	80179da <DecodeNameConstraints+0xde>
 80179ca:	69fb      	ldr	r3, [r7, #28]
 80179cc:	617b      	str	r3, [r7, #20]
 80179ce:	697b      	ldr	r3, [r7, #20]
 80179d0:	2b00      	cmp	r3, #0
 80179d2:	d002      	beq.n	80179da <DecodeNameConstraints+0xde>
 80179d4:	6978      	ldr	r0, [r7, #20]
 80179d6:	f007 f96d 	bl	801ecb4 <wolfSSL_Free>

    return ret;
 80179da:	69bb      	ldr	r3, [r7, #24]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 80179dc:	4618      	mov	r0, r3
 80179de:	3720      	adds	r7, #32
 80179e0:	46bd      	mov	sp, r7
 80179e2:	bd80      	pop	{r7, pc}
 80179e4:	08034770 	.word	0x08034770

080179e8 <DecodeExtensionType>:
 * @return  Other negative values on error.
 */
static int DecodeExtensionType(const byte* input, word32 length, word32 oid,
                               byte critical, DecodedCert* cert,
                               int *isUnknownExt)
{
 80179e8:	b580      	push	{r7, lr}
 80179ea:	b086      	sub	sp, #24
 80179ec:	af00      	add	r7, sp, #0
 80179ee:	60f8      	str	r0, [r7, #12]
 80179f0:	60b9      	str	r1, [r7, #8]
 80179f2:	607a      	str	r2, [r7, #4]
 80179f4:	70fb      	strb	r3, [r7, #3]
    int ret = 0;
 80179f6:	2300      	movs	r3, #0
 80179f8:	617b      	str	r3, [r7, #20]
    word32 idx = 0;
 80179fa:	2300      	movs	r3, #0
 80179fc:	613b      	str	r3, [r7, #16]

    if (isUnknownExt != NULL)
 80179fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017a00:	2b00      	cmp	r3, #0
 8017a02:	d002      	beq.n	8017a0a <DecodeExtensionType+0x22>
        *isUnknownExt = 0;
 8017a04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017a06:	2200      	movs	r2, #0
 8017a08:	601a      	str	r2, [r3, #0]

    switch (oid) {
 8017a0a:	687b      	ldr	r3, [r7, #4]
 8017a0c:	f240 22f1 	movw	r2, #753	@ 0x2f1
 8017a10:	4293      	cmp	r3, r2
 8017a12:	f000 8243 	beq.w	8017e9c <DecodeExtensionType+0x4b4>
 8017a16:	687b      	ldr	r3, [r7, #4]
 8017a18:	f240 22f1 	movw	r2, #753	@ 0x2f1
 8017a1c:	4293      	cmp	r3, r2
 8017a1e:	f200 8278 	bhi.w	8017f12 <DecodeExtensionType+0x52a>
 8017a22:	687b      	ldr	r3, [r7, #4]
 8017a24:	2b45      	cmp	r3, #69	@ 0x45
 8017a26:	f000 80c2 	beq.w	8017bae <DecodeExtensionType+0x1c6>
 8017a2a:	687b      	ldr	r3, [r7, #4]
 8017a2c:	2b45      	cmp	r3, #69	@ 0x45
 8017a2e:	f0c0 8270 	bcc.w	8017f12 <DecodeExtensionType+0x52a>
 8017a32:	687b      	ldr	r3, [r7, #4]
 8017a34:	2ba8      	cmp	r3, #168	@ 0xa8
 8017a36:	f200 826c 	bhi.w	8017f12 <DecodeExtensionType+0x52a>
 8017a3a:	687b      	ldr	r3, [r7, #4]
 8017a3c:	2b80      	cmp	r3, #128	@ 0x80
 8017a3e:	f0c0 8268 	bcc.w	8017f12 <DecodeExtensionType+0x52a>
 8017a42:	687b      	ldr	r3, [r7, #4]
 8017a44:	3b80      	subs	r3, #128	@ 0x80
 8017a46:	2b28      	cmp	r3, #40	@ 0x28
 8017a48:	f200 8263 	bhi.w	8017f12 <DecodeExtensionType+0x52a>
 8017a4c:	a201      	add	r2, pc, #4	@ (adr r2, 8017a54 <DecodeExtensionType+0x6c>)
 8017a4e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017a52:	bf00      	nop
 8017a54:	08017cd7 	.word	0x08017cd7
 8017a58:	08017d55 	.word	0x08017d55
 8017a5c:	08017f13 	.word	0x08017f13
 8017a60:	08017c1d 	.word	0x08017c1d
 8017a64:	08017f13 	.word	0x08017f13
 8017a68:	08017af9 	.word	0x08017af9
 8017a6c:	08017f13 	.word	0x08017f13
 8017a70:	08017f13 	.word	0x08017f13
 8017a74:	08017f13 	.word	0x08017f13
 8017a78:	08017f13 	.word	0x08017f13
 8017a7c:	08017f13 	.word	0x08017f13
 8017a80:	08017f13 	.word	0x08017f13
 8017a84:	08017f13 	.word	0x08017f13
 8017a88:	08017f13 	.word	0x08017f13
 8017a8c:	08017f13 	.word	0x08017f13
 8017a90:	08017f13 	.word	0x08017f13
 8017a94:	08017e09 	.word	0x08017e09
 8017a98:	08017b55 	.word	0x08017b55
 8017a9c:	08017d45 	.word	0x08017d45
 8017aa0:	08017f13 	.word	0x08017f13
 8017aa4:	08017f13 	.word	0x08017f13
 8017aa8:	08017c69 	.word	0x08017c69
 8017aac:	08017eb7 	.word	0x08017eb7
 8017ab0:	08017daf 	.word	0x08017daf
 8017ab4:	08017f13 	.word	0x08017f13
 8017ab8:	08017f13 	.word	0x08017f13
 8017abc:	08017f13 	.word	0x08017f13
 8017ac0:	08017f13 	.word	0x08017f13
 8017ac4:	08017f13 	.word	0x08017f13
 8017ac8:	08017f13 	.word	0x08017f13
 8017acc:	08017f13 	.word	0x08017f13
 8017ad0:	08017f13 	.word	0x08017f13
 8017ad4:	08017f13 	.word	0x08017f13
 8017ad8:	08017f13 	.word	0x08017f13
 8017adc:	08017f13 	.word	0x08017f13
 8017ae0:	08017f13 	.word	0x08017f13
 8017ae4:	08017f13 	.word	0x08017f13
 8017ae8:	08017f13 	.word	0x08017f13
 8017aec:	08017f13 	.word	0x08017f13
 8017af0:	08017f13 	.word	0x08017f13
 8017af4:	08017e77 	.word	0x08017e77
        /* Basic Constraints. */
        case BASIC_CA_OID:
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
 8017af8:	6a3b      	ldr	r3, [r7, #32]
 8017afa:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017afe:	f003 0308 	and.w	r3, r3, #8
 8017b02:	b2db      	uxtb	r3, r3
 8017b04:	2b00      	cmp	r3, #0
 8017b06:	d11e      	bne.n	8017b46 <DecodeExtensionType+0x15e>
 8017b08:	6a3a      	ldr	r2, [r7, #32]
 8017b0a:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017b0e:	f043 0308 	orr.w	r3, r3, #8
 8017b12:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extBasicConstCrit = critical ? 1 : 0;
 8017b16:	78fb      	ldrb	r3, [r7, #3]
 8017b18:	2b00      	cmp	r3, #0
 8017b1a:	bf14      	ite	ne
 8017b1c:	2301      	movne	r3, #1
 8017b1e:	2300      	moveq	r3, #0
 8017b20:	b2d9      	uxtb	r1, r3
 8017b22:	6a3a      	ldr	r2, [r7, #32]
 8017b24:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017b28:	f361 1304 	bfi	r3, r1, #4, #1
 8017b2c:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            if (DecodeBasicCaConstraint(input, (int)length, cert) < 0) {
 8017b30:	68bb      	ldr	r3, [r7, #8]
 8017b32:	6a3a      	ldr	r2, [r7, #32]
 8017b34:	4619      	mov	r1, r3
 8017b36:	68f8      	ldr	r0, [r7, #12]
 8017b38:	f7ff f980 	bl	8016e3c <DecodeBasicCaConstraint>
 8017b3c:	4603      	mov	r3, r0
 8017b3e:	2b00      	cmp	r3, #0
 8017b40:	f280 81f4 	bge.w	8017f2c <DecodeExtensionType+0x544>
 8017b44:	e002      	b.n	8017b4c <DecodeExtensionType+0x164>
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
 8017b46:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017b4a:	e207      	b.n	8017f5c <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017b4c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017b50:	617b      	str	r3, [r7, #20]
            }
            break;
 8017b52:	e1eb      	b.n	8017f2c <DecodeExtensionType+0x544>

        /* CRL Distribution point. */
        case CRL_DIST_OID:
            VERIFY_AND_SET_OID(cert->extCRLdistSet);
 8017b54:	6a3b      	ldr	r3, [r7, #32]
 8017b56:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017b5a:	f003 0302 	and.w	r3, r3, #2
 8017b5e:	b2db      	uxtb	r3, r3
 8017b60:	2b00      	cmp	r3, #0
 8017b62:	d11d      	bne.n	8017ba0 <DecodeExtensionType+0x1b8>
 8017b64:	6a3a      	ldr	r2, [r7, #32]
 8017b66:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017b6a:	f043 0302 	orr.w	r3, r3, #2
 8017b6e:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extCRLdistCrit = critical ? 1 : 0;
 8017b72:	78fb      	ldrb	r3, [r7, #3]
 8017b74:	2b00      	cmp	r3, #0
 8017b76:	bf14      	ite	ne
 8017b78:	2301      	movne	r3, #1
 8017b7a:	2300      	moveq	r3, #0
 8017b7c:	b2d9      	uxtb	r1, r3
 8017b7e:	6a3a      	ldr	r2, [r7, #32]
 8017b80:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017b84:	f361 0382 	bfi	r3, r1, #2, #1
 8017b88:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            if (DecodeCrlDist(input, length, cert) < 0) {
 8017b8c:	6a3a      	ldr	r2, [r7, #32]
 8017b8e:	68b9      	ldr	r1, [r7, #8]
 8017b90:	68f8      	ldr	r0, [r7, #12]
 8017b92:	f7ff fa63 	bl	801705c <DecodeCrlDist>
 8017b96:	4603      	mov	r3, r0
 8017b98:	2b00      	cmp	r3, #0
 8017b9a:	f280 81c9 	bge.w	8017f30 <DecodeExtensionType+0x548>
 8017b9e:	e002      	b.n	8017ba6 <DecodeExtensionType+0x1be>
            VERIFY_AND_SET_OID(cert->extCRLdistSet);
 8017ba0:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017ba4:	e1da      	b.n	8017f5c <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017ba6:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017baa:	617b      	str	r3, [r7, #20]
            }
            break;
 8017bac:	e1c0      	b.n	8017f30 <DecodeExtensionType+0x548>

        /* Authority information access. */
        case AUTH_INFO_OID:
            VERIFY_AND_SET_OID(cert->extAuthInfoSet);
 8017bae:	6a3b      	ldr	r3, [r7, #32]
 8017bb0:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017bb4:	f003 0304 	and.w	r3, r3, #4
 8017bb8:	b2db      	uxtb	r3, r3
 8017bba:	2b00      	cmp	r3, #0
 8017bbc:	d117      	bne.n	8017bee <DecodeExtensionType+0x206>
 8017bbe:	6a3a      	ldr	r2, [r7, #32]
 8017bc0:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017bc4:	f043 0304 	orr.w	r3, r3, #4
 8017bc8:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extAuthInfoCrit = critical ? 1 : 0;
 8017bcc:	78fb      	ldrb	r3, [r7, #3]
 8017bce:	2b00      	cmp	r3, #0
 8017bd0:	bf14      	ite	ne
 8017bd2:	2301      	movne	r3, #1
 8017bd4:	2300      	moveq	r3, #0
 8017bd6:	b2d9      	uxtb	r1, r3
 8017bd8:	6a3a      	ldr	r2, [r7, #32]
 8017bda:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017bde:	f361 03c3 	bfi	r3, r1, #3, #1
 8017be2:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
        #ifndef WOLFSSL_ALLOW_CRIT_AIA
            /* This check is added due to RFC 5280 section 4.2.2.1
            * stating that conforming CA's must mark this extension
            * as non-critical. When parsing extensions check that
            * certificate was made in compliance with this. */
            if (critical) {
 8017be6:	78fb      	ldrb	r3, [r7, #3]
 8017be8:	2b00      	cmp	r3, #0
 8017bea:	d006      	beq.n	8017bfa <DecodeExtensionType+0x212>
 8017bec:	e002      	b.n	8017bf4 <DecodeExtensionType+0x20c>
            VERIFY_AND_SET_OID(cert->extAuthInfoSet);
 8017bee:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017bf2:	e1b3      	b.n	8017f5c <DecodeExtensionType+0x574>
                WOLFSSL_MSG("Critical Authority Information Access is not"
                            "allowed");
                WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_AIA if wanted");
                ret = ASN_CRIT_EXT_E;
 8017bf4:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017bf8:	617b      	str	r3, [r7, #20]
            }
        #endif
            if ((ret == 0) && (DecodeAuthInfo(input, length, cert) < 0)) {
 8017bfa:	697b      	ldr	r3, [r7, #20]
 8017bfc:	2b00      	cmp	r3, #0
 8017bfe:	f040 8199 	bne.w	8017f34 <DecodeExtensionType+0x54c>
 8017c02:	6a3a      	ldr	r2, [r7, #32]
 8017c04:	68b9      	ldr	r1, [r7, #8]
 8017c06:	68f8      	ldr	r0, [r7, #12]
 8017c08:	f7ff fa98 	bl	801713c <DecodeAuthInfo>
 8017c0c:	4603      	mov	r3, r0
 8017c0e:	2b00      	cmp	r3, #0
 8017c10:	f280 8190 	bge.w	8017f34 <DecodeExtensionType+0x54c>
                ret = ASN_PARSE_E;
 8017c14:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017c18:	617b      	str	r3, [r7, #20]
            }
            break;
 8017c1a:	e18b      	b.n	8017f34 <DecodeExtensionType+0x54c>

        /* Subject alternative name. */
        case ALT_NAMES_OID:
            VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
 8017c1c:	6a3b      	ldr	r3, [r7, #32]
 8017c1e:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017c22:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8017c26:	b2db      	uxtb	r3, r3
 8017c28:	2b00      	cmp	r3, #0
 8017c2a:	d11a      	bne.n	8017c62 <DecodeExtensionType+0x27a>
 8017c2c:	6a3a      	ldr	r2, [r7, #32]
 8017c2e:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017c32:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8017c36:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extSubjAltNameCrit = critical ? 1 : 0;
 8017c3a:	78fb      	ldrb	r3, [r7, #3]
 8017c3c:	2b00      	cmp	r3, #0
 8017c3e:	bf14      	ite	ne
 8017c40:	2301      	movne	r3, #1
 8017c42:	2300      	moveq	r3, #0
 8017c44:	b2d9      	uxtb	r1, r3
 8017c46:	6a3a      	ldr	r2, [r7, #32]
 8017c48:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017c4c:	f361 1386 	bfi	r3, r1, #6, #1
 8017c50:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            ret = DecodeAltNames(input, length, cert);
 8017c54:	6a3a      	ldr	r2, [r7, #32]
 8017c56:	68b9      	ldr	r1, [r7, #8]
 8017c58:	68f8      	ldr	r0, [r7, #12]
 8017c5a:	f7ff f86d 	bl	8016d38 <DecodeAltNames>
 8017c5e:	6178      	str	r0, [r7, #20]
            break;
 8017c60:	e17b      	b.n	8017f5a <DecodeExtensionType+0x572>
            VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
 8017c62:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017c66:	e179      	b.n	8017f5c <DecodeExtensionType+0x574>

        /* Authority Key Identifier. */
        case AUTH_KEY_OID:
            VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
 8017c68:	6a3b      	ldr	r3, [r7, #32]
 8017c6a:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017c6e:	f003 0304 	and.w	r3, r3, #4
 8017c72:	b2db      	uxtb	r3, r3
 8017c74:	2b00      	cmp	r3, #0
 8017c76:	d117      	bne.n	8017ca8 <DecodeExtensionType+0x2c0>
 8017c78:	6a3a      	ldr	r2, [r7, #32]
 8017c7a:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017c7e:	f043 0304 	orr.w	r3, r3, #4
 8017c82:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extAuthKeyIdCrit = critical ? 1 : 0;
 8017c86:	78fb      	ldrb	r3, [r7, #3]
 8017c88:	2b00      	cmp	r3, #0
 8017c8a:	bf14      	ite	ne
 8017c8c:	2301      	movne	r3, #1
 8017c8e:	2300      	moveq	r3, #0
 8017c90:	b2d9      	uxtb	r1, r3
 8017c92:	6a3a      	ldr	r2, [r7, #32]
 8017c94:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017c98:	f361 13c7 	bfi	r3, r1, #7, #1
 8017c9c:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
        #ifndef WOLFSSL_ALLOW_CRIT_AKID
            /* This check is added due to RFC 5280 section 4.2.1.1
             * stating that conforming CA's must mark this extension
             * as non-critical. When parsing extensions check that
             * certificate was made in compliance with this. */
            if (critical) {
 8017ca0:	78fb      	ldrb	r3, [r7, #3]
 8017ca2:	2b00      	cmp	r3, #0
 8017ca4:	d006      	beq.n	8017cb4 <DecodeExtensionType+0x2cc>
 8017ca6:	e002      	b.n	8017cae <DecodeExtensionType+0x2c6>
            VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
 8017ca8:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017cac:	e156      	b.n	8017f5c <DecodeExtensionType+0x574>
                WOLFSSL_MSG("Critical Auth Key ID is not allowed");
                WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_AKID if wanted");
                ret = ASN_CRIT_EXT_E;
 8017cae:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017cb2:	617b      	str	r3, [r7, #20]
            }
        #endif
            if ((ret == 0) && (DecodeAuthKeyId(input, length, cert) < 0)) {
 8017cb4:	697b      	ldr	r3, [r7, #20]
 8017cb6:	2b00      	cmp	r3, #0
 8017cb8:	f040 813e 	bne.w	8017f38 <DecodeExtensionType+0x550>
 8017cbc:	6a3a      	ldr	r2, [r7, #32]
 8017cbe:	68b9      	ldr	r1, [r7, #8]
 8017cc0:	68f8      	ldr	r0, [r7, #12]
 8017cc2:	f7ff fab7 	bl	8017234 <DecodeAuthKeyId>
 8017cc6:	4603      	mov	r3, r0
 8017cc8:	2b00      	cmp	r3, #0
 8017cca:	f280 8135 	bge.w	8017f38 <DecodeExtensionType+0x550>
                ret = ASN_PARSE_E;
 8017cce:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017cd2:	617b      	str	r3, [r7, #20]
            }
            break;
 8017cd4:	e130      	b.n	8017f38 <DecodeExtensionType+0x550>

        /* Subject Key Identifier. */
        case SUBJ_KEY_OID:
            VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
 8017cd6:	6a3b      	ldr	r3, [r7, #32]
 8017cd8:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017cdc:	f003 0302 	and.w	r3, r3, #2
 8017ce0:	b2db      	uxtb	r3, r3
 8017ce2:	2b00      	cmp	r3, #0
 8017ce4:	d117      	bne.n	8017d16 <DecodeExtensionType+0x32e>
 8017ce6:	6a3a      	ldr	r2, [r7, #32]
 8017ce8:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017cec:	f043 0302 	orr.w	r3, r3, #2
 8017cf0:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extSubjKeyIdCrit = critical ? 1 : 0;
 8017cf4:	78fb      	ldrb	r3, [r7, #3]
 8017cf6:	2b00      	cmp	r3, #0
 8017cf8:	bf14      	ite	ne
 8017cfa:	2301      	movne	r3, #1
 8017cfc:	2300      	moveq	r3, #0
 8017cfe:	b2d9      	uxtb	r1, r3
 8017d00:	6a3a      	ldr	r2, [r7, #32]
 8017d02:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017d06:	f361 0341 	bfi	r3, r1, #1, #1
 8017d0a:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
        #ifndef WOLFSSL_ALLOW_CRIT_SKID
            /* This check is added due to RFC 5280 section 4.2.1.2
             * stating that conforming CA's must mark this extension
             * as non-critical. When parsing extensions check that
             * certificate was made in compliance with this. */
            if (critical) {
 8017d0e:	78fb      	ldrb	r3, [r7, #3]
 8017d10:	2b00      	cmp	r3, #0
 8017d12:	d006      	beq.n	8017d22 <DecodeExtensionType+0x33a>
 8017d14:	e002      	b.n	8017d1c <DecodeExtensionType+0x334>
            VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
 8017d16:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017d1a:	e11f      	b.n	8017f5c <DecodeExtensionType+0x574>
                WOLFSSL_MSG("Critical Subject Key ID is not allowed");
                WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted");
                ret = ASN_CRIT_EXT_E;
 8017d1c:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017d20:	617b      	str	r3, [r7, #20]
            }
        #endif

            if ((ret == 0) && (DecodeSubjKeyId(input, length, cert) < 0)) {
 8017d22:	697b      	ldr	r3, [r7, #20]
 8017d24:	2b00      	cmp	r3, #0
 8017d26:	f040 8109 	bne.w	8017f3c <DecodeExtensionType+0x554>
 8017d2a:	6a3a      	ldr	r2, [r7, #32]
 8017d2c:	68b9      	ldr	r1, [r7, #8]
 8017d2e:	68f8      	ldr	r0, [r7, #12]
 8017d30:	f7ff fb50 	bl	80173d4 <DecodeSubjKeyId>
 8017d34:	4603      	mov	r3, r0
 8017d36:	2b00      	cmp	r3, #0
 8017d38:	f280 8100 	bge.w	8017f3c <DecodeExtensionType+0x554>
                ret = ASN_PARSE_E;
 8017d3c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017d40:	617b      	str	r3, [r7, #20]
            }
            break;
 8017d42:	e0fb      	b.n	8017f3c <DecodeExtensionType+0x554>
                ret = ASN_PARSE_E;
            }
        #else
            WOLFSSL_MSG("Certificate Policy extension not supported.");
            #ifndef WOLFSSL_NO_ASN_STRICT
            if (critical) {
 8017d44:	78fb      	ldrb	r3, [r7, #3]
 8017d46:	2b00      	cmp	r3, #0
 8017d48:	f000 80fa 	beq.w	8017f40 <DecodeExtensionType+0x558>
                WOLFSSL_ERROR_VERBOSE(ASN_CRIT_EXT_E);
                ret = ASN_CRIT_EXT_E;
 8017d4c:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017d50:	617b      	str	r3, [r7, #20]
            }
            #endif
        #endif
            break;
 8017d52:	e0f5      	b.n	8017f40 <DecodeExtensionType+0x558>

        /* Key usage. */
        case KEY_USAGE_OID:
            VERIFY_AND_SET_OID(cert->extKeyUsageSet);
 8017d54:	6a3b      	ldr	r3, [r7, #32]
 8017d56:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017d5a:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8017d5e:	b2db      	uxtb	r3, r3
 8017d60:	2b00      	cmp	r3, #0
 8017d62:	d11d      	bne.n	8017da0 <DecodeExtensionType+0x3b8>
 8017d64:	6a3a      	ldr	r2, [r7, #32]
 8017d66:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017d6a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8017d6e:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extKeyUsageCrit = critical ? 1 : 0;
 8017d72:	78fb      	ldrb	r3, [r7, #3]
 8017d74:	2b00      	cmp	r3, #0
 8017d76:	bf14      	ite	ne
 8017d78:	2301      	movne	r3, #1
 8017d7a:	2300      	moveq	r3, #0
 8017d7c:	b2d9      	uxtb	r1, r3
 8017d7e:	6a3a      	ldr	r2, [r7, #32]
 8017d80:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017d84:	f361 0382 	bfi	r3, r1, #2, #1
 8017d88:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
            if (DecodeKeyUsage(input, length, cert) < 0) {
 8017d8c:	6a3a      	ldr	r2, [r7, #32]
 8017d8e:	68b9      	ldr	r1, [r7, #8]
 8017d90:	68f8      	ldr	r0, [r7, #12]
 8017d92:	f7ff fb5b 	bl	801744c <DecodeKeyUsage>
 8017d96:	4603      	mov	r3, r0
 8017d98:	2b00      	cmp	r3, #0
 8017d9a:	f280 80d3 	bge.w	8017f44 <DecodeExtensionType+0x55c>
 8017d9e:	e002      	b.n	8017da6 <DecodeExtensionType+0x3be>
            VERIFY_AND_SET_OID(cert->extKeyUsageSet);
 8017da0:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017da4:	e0da      	b.n	8017f5c <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017da6:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017daa:	617b      	str	r3, [r7, #20]
            }
            break;
 8017dac:	e0ca      	b.n	8017f44 <DecodeExtensionType+0x55c>

        /* Extended key usage. */
        case EXT_KEY_USAGE_OID:
            VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
 8017dae:	6a3b      	ldr	r3, [r7, #32]
 8017db0:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017db4:	f003 0301 	and.w	r3, r3, #1
 8017db8:	b2db      	uxtb	r3, r3
 8017dba:	2b00      	cmp	r3, #0
 8017dbc:	d11d      	bne.n	8017dfa <DecodeExtensionType+0x412>
 8017dbe:	6a3a      	ldr	r2, [r7, #32]
 8017dc0:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017dc4:	f043 0301 	orr.w	r3, r3, #1
 8017dc8:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extExtKeyUsageCrit = critical ? 1 : 0;
 8017dcc:	78fb      	ldrb	r3, [r7, #3]
 8017dce:	2b00      	cmp	r3, #0
 8017dd0:	bf14      	ite	ne
 8017dd2:	2301      	movne	r3, #1
 8017dd4:	2300      	moveq	r3, #0
 8017dd6:	b2d9      	uxtb	r1, r3
 8017dd8:	6a3a      	ldr	r2, [r7, #32]
 8017dda:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017dde:	f361 03c3 	bfi	r3, r1, #3, #1
 8017de2:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
            if (DecodeExtKeyUsage(input, length, cert) < 0) {
 8017de6:	6a3a      	ldr	r2, [r7, #32]
 8017de8:	68b9      	ldr	r1, [r7, #8]
 8017dea:	68f8      	ldr	r0, [r7, #12]
 8017dec:	f7ff fb7c 	bl	80174e8 <DecodeExtKeyUsage>
 8017df0:	4603      	mov	r3, r0
 8017df2:	2b00      	cmp	r3, #0
 8017df4:	f280 80a8 	bge.w	8017f48 <DecodeExtensionType+0x560>
 8017df8:	e002      	b.n	8017e00 <DecodeExtensionType+0x418>
            VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
 8017dfa:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017dfe:	e0ad      	b.n	8017f5c <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017e00:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017e04:	617b      	str	r3, [r7, #20]
            }
            break;
 8017e06:	e09f      	b.n	8017f48 <DecodeExtensionType+0x560>
        case NAME_CONS_OID:
        #ifndef WOLFSSL_NO_ASN_STRICT
            /* Verify RFC 5280 Sec 4.2.1.10 rule:
                "The name constraints extension,
                which MUST be used only in a CA certificate" */
            if (!cert->isCA) {
 8017e08:	6a3b      	ldr	r3, [r7, #32]
 8017e0a:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017e0e:	f003 0310 	and.w	r3, r3, #16
 8017e12:	b2db      	uxtb	r3, r3
 8017e14:	2b00      	cmp	r3, #0
 8017e16:	d102      	bne.n	8017e1e <DecodeExtensionType+0x436>
                WOLFSSL_MSG("Name constraints allowed only for CA certs");
                WOLFSSL_ERROR_VERBOSE(ASN_NAME_INVALID_E);
                ret = ASN_NAME_INVALID_E;
 8017e18:	f06f 03c5 	mvn.w	r3, #197	@ 0xc5
 8017e1c:	617b      	str	r3, [r7, #20]
            }
        #endif
            VERIFY_AND_SET_OID(cert->extNameConstraintSet);
 8017e1e:	6a3b      	ldr	r3, [r7, #32]
 8017e20:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017e24:	f003 0308 	and.w	r3, r3, #8
 8017e28:	b2db      	uxtb	r3, r3
 8017e2a:	2b00      	cmp	r3, #0
 8017e2c:	d11c      	bne.n	8017e68 <DecodeExtensionType+0x480>
 8017e2e:	6a3a      	ldr	r2, [r7, #32]
 8017e30:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017e34:	f043 0308 	orr.w	r3, r3, #8
 8017e38:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extNameConstraintCrit = critical ? 1 : 0;
 8017e3c:	78fb      	ldrb	r3, [r7, #3]
 8017e3e:	2b00      	cmp	r3, #0
 8017e40:	bf14      	ite	ne
 8017e42:	2301      	movne	r3, #1
 8017e44:	2300      	moveq	r3, #0
 8017e46:	b2d9      	uxtb	r1, r3
 8017e48:	6a3a      	ldr	r2, [r7, #32]
 8017e4a:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017e4e:	f361 0300 	bfi	r3, r1, #0, #1
 8017e52:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
            if (DecodeNameConstraints(input, length, cert) < 0) {
 8017e56:	6a3a      	ldr	r2, [r7, #32]
 8017e58:	68b9      	ldr	r1, [r7, #8]
 8017e5a:	68f8      	ldr	r0, [r7, #12]
 8017e5c:	f7ff fd4e 	bl	80178fc <DecodeNameConstraints>
 8017e60:	4603      	mov	r3, r0
 8017e62:	2b00      	cmp	r3, #0
 8017e64:	da72      	bge.n	8017f4c <DecodeExtensionType+0x564>
 8017e66:	e002      	b.n	8017e6e <DecodeExtensionType+0x486>
            VERIFY_AND_SET_OID(cert->extNameConstraintSet);
 8017e68:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017e6c:	e076      	b.n	8017f5c <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017e6e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017e72:	617b      	str	r3, [r7, #20]
            }
            break;
 8017e74:	e06a      	b.n	8017f4c <DecodeExtensionType+0x564>
        #endif /* IGNORE_NAME_CONSTRAINTS */

        /* Inhibit anyPolicy. */
        case INHIBIT_ANY_OID:
            VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
 8017e76:	6a3b      	ldr	r3, [r7, #32]
 8017e78:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 8017e7c:	f003 0301 	and.w	r3, r3, #1
 8017e80:	b2db      	uxtb	r3, r3
 8017e82:	2b00      	cmp	r3, #0
 8017e84:	d107      	bne.n	8017e96 <DecodeExtensionType+0x4ae>
 8017e86:	6a3a      	ldr	r2, [r7, #32]
 8017e88:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017e8c:	f043 0301 	orr.w	r3, r3, #1
 8017e90:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            WOLFSSL_MSG("Inhibit anyPolicy extension not supported yet.");
            break;
 8017e94:	e061      	b.n	8017f5a <DecodeExtensionType+0x572>
            VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
 8017e96:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017e9a:	e05f      	b.n	8017f5c <DecodeExtensionType+0x574>

   #ifndef IGNORE_NETSCAPE_CERT_TYPE
        /* Netscape's certificate type. */
        case NETSCAPE_CT_OID:
            if (DecodeNsCertType(input, (int)length, cert) < 0)
 8017e9c:	68bb      	ldr	r3, [r7, #8]
 8017e9e:	6a3a      	ldr	r2, [r7, #32]
 8017ea0:	4619      	mov	r1, r3
 8017ea2:	68f8      	ldr	r0, [r7, #12]
 8017ea4:	f7ff fbe8 	bl	8017678 <DecodeNsCertType>
 8017ea8:	4603      	mov	r3, r0
 8017eaa:	2b00      	cmp	r3, #0
 8017eac:	da50      	bge.n	8017f50 <DecodeExtensionType+0x568>
                ret = ASN_PARSE_E;
 8017eae:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017eb2:	617b      	str	r3, [r7, #20]
            break;
 8017eb4:	e04c      	b.n	8017f50 <DecodeExtensionType+0x568>
                ret = ASN_PARSE_E;
            }
            break;
    #endif
        case POLICY_CONST_OID:
            VERIFY_AND_SET_OID(cert->extPolicyConstSet);
 8017eb6:	6a3b      	ldr	r3, [r7, #32]
 8017eb8:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017ebc:	f003 0310 	and.w	r3, r3, #16
 8017ec0:	b2db      	uxtb	r3, r3
 8017ec2:	2b00      	cmp	r3, #0
 8017ec4:	d11f      	bne.n	8017f06 <DecodeExtensionType+0x51e>
 8017ec6:	6a3a      	ldr	r2, [r7, #32]
 8017ec8:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017ecc:	f043 0310 	orr.w	r3, r3, #16
 8017ed0:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extPolicyConstCrit = critical ? 1 : 0;
 8017ed4:	78fb      	ldrb	r3, [r7, #3]
 8017ed6:	2b00      	cmp	r3, #0
 8017ed8:	bf14      	ite	ne
 8017eda:	2301      	movne	r3, #1
 8017edc:	2300      	moveq	r3, #0
 8017ede:	b2d9      	uxtb	r1, r3
 8017ee0:	6a3a      	ldr	r2, [r7, #32]
 8017ee2:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017ee6:	f361 1345 	bfi	r3, r1, #5, #1
 8017eea:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            if (DecodePolicyConstraints(&input[idx], (int)length, cert) < 0)
 8017eee:	68fa      	ldr	r2, [r7, #12]
 8017ef0:	693b      	ldr	r3, [r7, #16]
 8017ef2:	4413      	add	r3, r2
 8017ef4:	68b9      	ldr	r1, [r7, #8]
 8017ef6:	6a3a      	ldr	r2, [r7, #32]
 8017ef8:	4618      	mov	r0, r3
 8017efa:	f7ff f841 	bl	8016f80 <DecodePolicyConstraints>
 8017efe:	4603      	mov	r3, r0
 8017f00:	2b00      	cmp	r3, #0
 8017f02:	da27      	bge.n	8017f54 <DecodeExtensionType+0x56c>
 8017f04:	e002      	b.n	8017f0c <DecodeExtensionType+0x524>
            VERIFY_AND_SET_OID(cert->extPolicyConstSet);
 8017f06:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017f0a:	e027      	b.n	8017f5c <DecodeExtensionType+0x574>
                return ASN_PARSE_E;
 8017f0c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017f10:	e024      	b.n	8017f5c <DecodeExtensionType+0x574>
            if (DecodeAltSigVal(&input[idx], length, cert) < 0)
                return ASN_PARSE_E;
            break;
    #endif /* WOLFSSL_DUAL_ALG_CERTS */
        default:
            if (isUnknownExt != NULL)
 8017f12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017f14:	2b00      	cmp	r3, #0
 8017f16:	d002      	beq.n	8017f1e <DecodeExtensionType+0x536>
                *isUnknownExt = 1;
 8017f18:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017f1a:	2201      	movs	r2, #1
 8017f1c:	601a      	str	r2, [r3, #0]
        #ifndef WOLFSSL_NO_ASN_STRICT
            /* While it is a failure to not support critical extensions,
             * still parse the certificate ignoring the unsupported
             * extension to allow caller to accept it with the verify
             * callback. */
            if (critical) {
 8017f1e:	78fb      	ldrb	r3, [r7, #3]
 8017f20:	2b00      	cmp	r3, #0
 8017f22:	d019      	beq.n	8017f58 <DecodeExtensionType+0x570>
                WOLFSSL_ERROR_VERBOSE(ASN_CRIT_EXT_E);
                ret = ASN_CRIT_EXT_E;
 8017f24:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017f28:	617b      	str	r3, [r7, #20]
            }
        #endif
            break;
 8017f2a:	e015      	b.n	8017f58 <DecodeExtensionType+0x570>
            break;
 8017f2c:	bf00      	nop
 8017f2e:	e014      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f30:	bf00      	nop
 8017f32:	e012      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f34:	bf00      	nop
 8017f36:	e010      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f38:	bf00      	nop
 8017f3a:	e00e      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f3c:	bf00      	nop
 8017f3e:	e00c      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f40:	bf00      	nop
 8017f42:	e00a      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f44:	bf00      	nop
 8017f46:	e008      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f48:	bf00      	nop
 8017f4a:	e006      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f4c:	bf00      	nop
 8017f4e:	e004      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f50:	bf00      	nop
 8017f52:	e002      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f54:	bf00      	nop
 8017f56:	e000      	b.n	8017f5a <DecodeExtensionType+0x572>
            break;
 8017f58:	bf00      	nop
    }

    return ret;
 8017f5a:	697b      	ldr	r3, [r7, #20]
}
 8017f5c:	4618      	mov	r0, r3
 8017f5e:	3718      	adds	r7, #24
 8017f60:	46bd      	mov	sp, r7
 8017f62:	bd80      	pop	{r7, pc}

08017f64 <DecodeCertExtensions>:
/*
 *  Processing the Certificate Extensions. This does not modify the current
 *  index. It is works starting with the recorded extensions pointer.
 */
static int DecodeCertExtensions(DecodedCert* cert)
{
 8017f64:	b580      	push	{r7, lr}
 8017f66:	b0a0      	sub	sp, #128	@ 0x80
 8017f68:	af04      	add	r7, sp, #16
 8017f6a:	6078      	str	r0, [r7, #4]

    ret = criticalFail ? ASN_CRIT_EXT_E : 0;
end:
    return ret;
#else
    DECL_ASNGETDATA(dataASN, certExtASN_Length);
 8017f6c:	2300      	movs	r3, #0
 8017f6e:	66fb      	str	r3, [r7, #108]	@ 0x6c
    ASNGetData dataExtsASN[certExtHdrASN_Length];
    int ret = 0;
 8017f70:	2300      	movs	r3, #0
 8017f72:	66bb      	str	r3, [r7, #104]	@ 0x68
    const byte* input = cert->extensions;
 8017f74:	687b      	ldr	r3, [r7, #4]
 8017f76:	f8d3 3398 	ldr.w	r3, [r3, #920]	@ 0x398
 8017f7a:	663b      	str	r3, [r7, #96]	@ 0x60
    int sz = cert->extensionsSz;
 8017f7c:	687b      	ldr	r3, [r7, #4]
 8017f7e:	f8d3 339c 	ldr.w	r3, [r3, #924]	@ 0x39c
 8017f82:	65fb      	str	r3, [r7, #92]	@ 0x5c
    word32 idx = 0;
 8017f84:	2300      	movs	r3, #0
 8017f86:	613b      	str	r3, [r7, #16]
    int criticalRet = 0;
 8017f88:	2300      	movs	r3, #0
 8017f8a:	667b      	str	r3, [r7, #100]	@ 0x64
    int offset = 0;
 8017f8c:	2300      	movs	r3, #0
 8017f8e:	65bb      	str	r3, [r7, #88]	@ 0x58

    WOLFSSL_ENTER("DecodeCertExtensions");

    if (input == NULL || sz == 0)
 8017f90:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017f92:	2b00      	cmp	r3, #0
 8017f94:	d002      	beq.n	8017f9c <DecodeCertExtensions+0x38>
 8017f96:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017f98:	2b00      	cmp	r3, #0
 8017f9a:	d102      	bne.n	8017fa2 <DecodeCertExtensions+0x3e>
        ret = BAD_FUNC_ARG;
 8017f9c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8017fa0:	66bb      	str	r3, [r7, #104]	@ 0x68

    ALLOC_ASNGETDATA(dataASN, certExtASN_Length, ret, cert->heap);
 8017fa2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017fa4:	2b00      	cmp	r3, #0
 8017fa6:	d109      	bne.n	8017fbc <DecodeCertExtensions+0x58>
 8017fa8:	2070      	movs	r0, #112	@ 0x70
 8017faa:	f006 fe67 	bl	801ec7c <wolfSSL_Malloc>
 8017fae:	66f8      	str	r0, [r7, #108]	@ 0x6c
 8017fb0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017fb2:	2b00      	cmp	r3, #0
 8017fb4:	d102      	bne.n	8017fbc <DecodeCertExtensions+0x58>
 8017fb6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8017fba:	66bb      	str	r3, [r7, #104]	@ 0x68
#ifdef WOLFSSL_CERT_REQ
    if (cert->isCSR) {
        offset = CERTEXTHDRASN_IDX_EXTSEQ;
    }
#endif
    if (ret == 0) {
 8017fbc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017fbe:	2b00      	cmp	r3, #0
 8017fc0:	d16e      	bne.n	80180a0 <DecodeCertExtensions+0x13c>
        /* Clear dynamic data. */
        XMEMSET(dataExtsASN, 0, sizeof(dataExtsASN));
 8017fc2:	f107 0314 	add.w	r3, r7, #20
 8017fc6:	2238      	movs	r2, #56	@ 0x38
 8017fc8:	2100      	movs	r1, #0
 8017fca:	4618      	mov	r0, r3
 8017fcc:	f010 fe2a 	bl	8028c24 <memset>
        /* Parse extensions header. */
        ret = GetASN_Items(certExtHdrASN + offset, dataExtsASN + offset,
 8017fd0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017fd2:	009b      	lsls	r3, r3, #2
 8017fd4:	4a40      	ldr	r2, [pc, #256]	@ (80180d8 <DecodeCertExtensions+0x174>)
 8017fd6:	1898      	adds	r0, r3, r2
 8017fd8:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8017fda:	4613      	mov	r3, r2
 8017fdc:	00db      	lsls	r3, r3, #3
 8017fde:	1a9b      	subs	r3, r3, r2
 8017fe0:	009b      	lsls	r3, r3, #2
 8017fe2:	461a      	mov	r2, r3
 8017fe4:	f107 0314 	add.w	r3, r7, #20
 8017fe8:	1899      	adds	r1, r3, r2
                           (int)(certExtHdrASN_Length - (size_t)offset), 0,
 8017fea:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017fec:	f1c3 0302 	rsb	r3, r3, #2
        ret = GetASN_Items(certExtHdrASN + offset, dataExtsASN + offset,
 8017ff0:	461a      	mov	r2, r3
 8017ff2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017ff4:	9302      	str	r3, [sp, #8]
 8017ff6:	f107 0310 	add.w	r3, r7, #16
 8017ffa:	9301      	str	r3, [sp, #4]
 8017ffc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017ffe:	9300      	str	r3, [sp, #0]
 8018000:	2300      	movs	r3, #0
 8018002:	f7fb fc35 	bl	8013870 <GetASN_Items>
 8018006:	66b8      	str	r0, [r7, #104]	@ 0x68
                           input, &idx, (word32)sz);
    }
    /* Parse each extension. */
    while ((ret == 0) && (idx < (word32)sz)) {
 8018008:	e04a      	b.n	80180a0 <DecodeCertExtensions+0x13c>
        byte critical = 0;
 801800a:	2300      	movs	r3, #0
 801800c:	73fb      	strb	r3, [r7, #15]
        int isUnknownExt = 0;
 801800e:	2300      	movs	r3, #0
 8018010:	60bb      	str	r3, [r7, #8]

        /* Clear dynamic data. */
        XMEMSET(dataASN, 0, sizeof(*dataASN) * certExtASN_Length);
 8018012:	2270      	movs	r2, #112	@ 0x70
 8018014:	2100      	movs	r1, #0
 8018016:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8018018:	f010 fe04 	bl	8028c24 <memset>
        /* Ensure OID is an extension type. */
        GetASN_OID(&dataASN[CERTEXTASN_IDX_OID], oidCertExtType);
 801801c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801801e:	331c      	adds	r3, #28
 8018020:	2206      	movs	r2, #6
 8018022:	611a      	str	r2, [r3, #16]
        /* Set criticality variable. */
        GetASN_Int8Bit(&dataASN[CERTEXTASN_IDX_CRIT], &critical);
 8018024:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8018026:	3338      	adds	r3, #56	@ 0x38
 8018028:	2201      	movs	r2, #1
 801802a:	761a      	strb	r2, [r3, #24]
 801802c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801802e:	3338      	adds	r3, #56	@ 0x38
 8018030:	f107 020f 	add.w	r2, r7, #15
 8018034:	609a      	str	r2, [r3, #8]
        /* Parse extension wrapper. */
        ret = GetASN_Items(certExtASN, dataASN, certExtASN_Length, 0, input,
 8018036:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018038:	9302      	str	r3, [sp, #8]
 801803a:	f107 0310 	add.w	r3, r7, #16
 801803e:	9301      	str	r3, [sp, #4]
 8018040:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8018042:	9300      	str	r3, [sp, #0]
 8018044:	2300      	movs	r3, #0
 8018046:	2204      	movs	r2, #4
 8018048:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801804a:	4824      	ldr	r0, [pc, #144]	@ (80180dc <DecodeCertExtensions+0x178>)
 801804c:	f7fb fc10 	bl	8013870 <GetASN_Items>
 8018050:	66b8      	str	r0, [r7, #104]	@ 0x68
                           &idx, (word32)sz);
        if (ret == 0) {
 8018052:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8018054:	2b00      	cmp	r3, #0
 8018056:	d11a      	bne.n	801808e <DecodeCertExtensions+0x12a>
            word32 oid = dataASN[CERTEXTASN_IDX_OID].data.oid.sum;
 8018058:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801805a:	331c      	adds	r3, #28
 801805c:	695b      	ldr	r3, [r3, #20]
 801805e:	657b      	str	r3, [r7, #84]	@ 0x54
            word32 length = dataASN[CERTEXTASN_IDX_VAL].length;
 8018060:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8018062:	3354      	adds	r3, #84	@ 0x54
 8018064:	685b      	ldr	r3, [r3, #4]
 8018066:	653b      	str	r3, [r7, #80]	@ 0x50

            /* Decode the extension by type. */
            ret = DecodeExtensionType(input + idx, length, oid, critical, cert,
 8018068:	693b      	ldr	r3, [r7, #16]
 801806a:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 801806c:	18d0      	adds	r0, r2, r3
 801806e:	7bfa      	ldrb	r2, [r7, #15]
 8018070:	f107 0308 	add.w	r3, r7, #8
 8018074:	9301      	str	r3, [sp, #4]
 8018076:	687b      	ldr	r3, [r7, #4]
 8018078:	9300      	str	r3, [sp, #0]
 801807a:	4613      	mov	r3, r2
 801807c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801807e:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8018080:	f7ff fcb2 	bl	80179e8 <DecodeExtensionType>
 8018084:	66b8      	str	r0, [r7, #104]	@ 0x68
#else
            (void)isUnknownExt;
#endif

            /* Move index on to next extension. */
            idx += length;
 8018086:	693a      	ldr	r2, [r7, #16]
 8018088:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801808a:	4413      	add	r3, r2
 801808c:	613b      	str	r3, [r7, #16]
        }
        /* Don't fail criticality until all other extensions have been checked.
         */
        if (ret == WC_NO_ERR_TRACE(ASN_CRIT_EXT_E)) {
 801808e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8018090:	f113 0fa0 	cmn.w	r3, #160	@ 0xa0
 8018094:	d104      	bne.n	80180a0 <DecodeCertExtensions+0x13c>
            criticalRet = ASN_CRIT_EXT_E;
 8018096:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 801809a:	667b      	str	r3, [r7, #100]	@ 0x64
            ret = 0;
 801809c:	2300      	movs	r3, #0
 801809e:	66bb      	str	r3, [r7, #104]	@ 0x68
    while ((ret == 0) && (idx < (word32)sz)) {
 80180a0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80180a2:	2b00      	cmp	r3, #0
 80180a4:	d103      	bne.n	80180ae <DecodeCertExtensions+0x14a>
 80180a6:	693a      	ldr	r2, [r7, #16]
 80180a8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80180aa:	429a      	cmp	r2, r3
 80180ac:	d3ad      	bcc.n	801800a <DecodeCertExtensions+0xa6>
        }
    }

    if (ret == 0) {
 80180ae:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80180b0:	2b00      	cmp	r3, #0
 80180b2:	d101      	bne.n	80180b8 <DecodeCertExtensions+0x154>
        /* Use criticality return. */
        ret = criticalRet;
 80180b4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80180b6:	66bb      	str	r3, [r7, #104]	@ 0x68
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 80180b8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80180ba:	2b00      	cmp	r3, #0
 80180bc:	d007      	beq.n	80180ce <DecodeCertExtensions+0x16a>
 80180be:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80180c0:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80180c2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80180c4:	2b00      	cmp	r3, #0
 80180c6:	d002      	beq.n	80180ce <DecodeCertExtensions+0x16a>
 80180c8:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 80180ca:	f006 fdf3 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 80180ce:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
#endif
}
 80180d0:	4618      	mov	r0, r3
 80180d2:	3770      	adds	r7, #112	@ 0x70
 80180d4:	46bd      	mov	sp, r7
 80180d6:	bd80      	pop	{r7, pc}
 80180d8:	0803477c 	.word	0x0803477c
 80180dc:	08034784 	.word	0x08034784

080180e0 <CheckDate>:
 * @return  ASN_DATE_SZ_E when time data is not supported.
 * @return  ASN_BEFORE_DATE_E when ASN_BEFORE date is invalid.
 * @return  ASN_AFTER_DATE_E when ASN_AFTER date is invalid.
 */
static int CheckDate(ASNGetData *dataASN, int dateType)
{
 80180e0:	b480      	push	{r7}
 80180e2:	b085      	sub	sp, #20
 80180e4:	af00      	add	r7, sp, #0
 80180e6:	6078      	str	r0, [r7, #4]
 80180e8:	6039      	str	r1, [r7, #0]
    int ret = 0;
 80180ea:	2300      	movs	r3, #0
 80180ec:	60fb      	str	r3, [r7, #12]

    /* Check BER tag is valid. */
    if ((dataASN->tag != ASN_UTC_TIME) &&
 80180ee:	687b      	ldr	r3, [r7, #4]
 80180f0:	7e5b      	ldrb	r3, [r3, #25]
 80180f2:	2b17      	cmp	r3, #23
 80180f4:	d006      	beq.n	8018104 <CheckDate+0x24>
            (dataASN->tag != ASN_GENERALIZED_TIME)) {
 80180f6:	687b      	ldr	r3, [r7, #4]
 80180f8:	7e5b      	ldrb	r3, [r3, #25]
    if ((dataASN->tag != ASN_UTC_TIME) &&
 80180fa:	2b18      	cmp	r3, #24
 80180fc:	d002      	beq.n	8018104 <CheckDate+0x24>
        ret = ASN_TIME_E;
 80180fe:	f06f 0398 	mvn.w	r3, #152	@ 0x98
 8018102:	60fb      	str	r3, [r7, #12]
    }
    /* Check date length is valid. */
    if ((ret == 0) && ((dataASN->length > MAX_DATE_SIZE) ||
 8018104:	68fb      	ldr	r3, [r7, #12]
 8018106:	2b00      	cmp	r3, #0
 8018108:	d10a      	bne.n	8018120 <CheckDate+0x40>
 801810a:	687b      	ldr	r3, [r7, #4]
 801810c:	685b      	ldr	r3, [r3, #4]
 801810e:	2b20      	cmp	r3, #32
 8018110:	d803      	bhi.n	801811a <CheckDate+0x3a>
                       (dataASN->length < MIN_DATE_SIZE))) {
 8018112:	687b      	ldr	r3, [r7, #4]
 8018114:	685b      	ldr	r3, [r3, #4]
    if ((ret == 0) && ((dataASN->length > MAX_DATE_SIZE) ||
 8018116:	2b0b      	cmp	r3, #11
 8018118:	d802      	bhi.n	8018120 <CheckDate+0x40>
        ret = ASN_DATE_SZ_E;
 801811a:	f06f 0394 	mvn.w	r3, #148	@ 0x94
 801811e:	60fb      	str	r3, [r7, #12]
        }
    }
#endif
    (void)dateType;

    return ret;
 8018120:	68fb      	ldr	r3, [r7, #12]
}
 8018122:	4618      	mov	r0, r3
 8018124:	3714      	adds	r7, #20
 8018126:	46bd      	mov	sp, r7
 8018128:	f85d 7b04 	ldr.w	r7, [sp], #4
 801812c:	4770      	bx	lr
	...

08018130 <DecodeCertInternal>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
static int DecodeCertInternal(DecodedCert* cert, int verify, int* criticalExt,
                              int* badDateRet, int stopAtPubKey,
                              int stopAfterPubKey)
{
 8018130:	b580      	push	{r7, lr}
 8018132:	b09c      	sub	sp, #112	@ 0x70
 8018134:	af04      	add	r7, sp, #16
 8018136:	60f8      	str	r0, [r7, #12]
 8018138:	60b9      	str	r1, [r7, #8]
 801813a:	607a      	str	r2, [r7, #4]
 801813c:	603b      	str	r3, [r7, #0]
    DECL_ASNGETDATA(dataASN, x509CertASN_Length);
 801813e:	2300      	movs	r3, #0
 8018140:	65fb      	str	r3, [r7, #92]	@ 0x5c
    int ret = 0;
 8018142:	2300      	movs	r3, #0
 8018144:	65bb      	str	r3, [r7, #88]	@ 0x58
    int badDate = 0;
 8018146:	2300      	movs	r3, #0
 8018148:	657b      	str	r3, [r7, #84]	@ 0x54
    byte version = 0;
 801814a:	2300      	movs	r3, #0
 801814c:	76fb      	strb	r3, [r7, #27]
    word32 idx;
    word32 serialSz = 0;
 801814e:	2300      	movs	r3, #0
 8018150:	613b      	str	r3, [r7, #16]
    const unsigned char* issuer = NULL;
 8018152:	2300      	movs	r3, #0
 8018154:	653b      	str	r3, [r7, #80]	@ 0x50
    word32 issuerSz = 0;
 8018156:	2300      	movs	r3, #0
 8018158:	64fb      	str	r3, [r7, #76]	@ 0x4c
    const unsigned char* subject = NULL;
 801815a:	2300      	movs	r3, #0
 801815c:	64bb      	str	r3, [r7, #72]	@ 0x48
    word32 subjectSz = 0;
 801815e:	2300      	movs	r3, #0
 8018160:	647b      	str	r3, [r7, #68]	@ 0x44
    word32 pubKeyOffset = 0;
 8018162:	2300      	movs	r3, #0
 8018164:	643b      	str	r3, [r7, #64]	@ 0x40
    word32 pubKeyEnd = 0;
 8018166:	2300      	movs	r3, #0
 8018168:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int done = 0;
 801816a:	2300      	movs	r3, #0
 801816c:	63bb      	str	r3, [r7, #56]	@ 0x38
    else {
        ret = 0;    /* proceed to the original x509 parsing */
    }
#endif /* HAVE_RPK */

    CALLOC_ASNGETDATA(dataASN, x509CertASN_Length, ret, cert->heap);
 801816e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018170:	2b00      	cmp	r3, #0
 8018172:	d10a      	bne.n	801818a <DecodeCertInternal+0x5a>
 8018174:	f44f 7060 	mov.w	r0, #896	@ 0x380
 8018178:	f006 fd80 	bl	801ec7c <wolfSSL_Malloc>
 801817c:	65f8      	str	r0, [r7, #92]	@ 0x5c
 801817e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018180:	2b00      	cmp	r3, #0
 8018182:	d102      	bne.n	801818a <DecodeCertInternal+0x5a>
 8018184:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8018188:	65bb      	str	r3, [r7, #88]	@ 0x58
 801818a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801818c:	2b00      	cmp	r3, #0
 801818e:	d105      	bne.n	801819c <DecodeCertInternal+0x6c>
 8018190:	f44f 7260 	mov.w	r2, #896	@ 0x380
 8018194:	2100      	movs	r1, #0
 8018196:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8018198:	f010 fd44 	bl	8028c24 <memset>

    if (ret == 0) {
 801819c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801819e:	2b00      	cmp	r3, #0
 80181a0:	d141      	bne.n	8018226 <DecodeCertInternal+0xf6>
        version = 0;
 80181a2:	2300      	movs	r3, #0
 80181a4:	76fb      	strb	r3, [r7, #27]
        serialSz = EXTERNAL_SERIAL_SIZE;
 80181a6:	2320      	movs	r3, #32
 80181a8:	613b      	str	r3, [r7, #16]

        /* Get the version and put the serial number into the buffer. */
        GetASN_Int8Bit(&dataASN[X509CERTASN_IDX_TBS_VER_INT], &version);
 80181aa:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181ac:	3354      	adds	r3, #84	@ 0x54
 80181ae:	2201      	movs	r2, #1
 80181b0:	761a      	strb	r2, [r3, #24]
 80181b2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181b4:	3354      	adds	r3, #84	@ 0x54
 80181b6:	f107 021b 	add.w	r2, r7, #27
 80181ba:	609a      	str	r2, [r3, #8]
        GetASN_Buffer(&dataASN[X509CERTASN_IDX_TBS_SERIAL], cert->serial,
 80181bc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181be:	3370      	adds	r3, #112	@ 0x70
 80181c0:	2205      	movs	r2, #5
 80181c2:	761a      	strb	r2, [r3, #24]
 80181c4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181c6:	3370      	adds	r3, #112	@ 0x70
 80181c8:	68fa      	ldr	r2, [r7, #12]
 80181ca:	f502 725d 	add.w	r2, r2, #884	@ 0x374
 80181ce:	609a      	str	r2, [r3, #8]
 80181d0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181d2:	3370      	adds	r3, #112	@ 0x70
 80181d4:	f107 0210 	add.w	r2, r7, #16
 80181d8:	60da      	str	r2, [r3, #12]
                &serialSz);
        /* Check OID types for signature, algorithm, ECC curve and sigAlg. */
        GetASN_OID(&dataASN[X509CERTASN_IDX_TBS_ALGOID_OID], oidSigType);
 80181da:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181dc:	33a8      	adds	r3, #168	@ 0xa8
 80181de:	2201      	movs	r2, #1
 80181e0:	611a      	str	r2, [r3, #16]
        GetASN_OID(&dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_ALGO_OID],
 80181e2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181e4:	f503 73fc 	add.w	r3, r3, #504	@ 0x1f8
 80181e8:	2202      	movs	r2, #2
 80181ea:	611a      	str	r2, [r3, #16]
                oidKeyType);
        GetASN_OID(&dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_ALGO_CURVEID],
 80181ec:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181ee:	f503 730c 	add.w	r3, r3, #560	@ 0x230
 80181f2:	2203      	movs	r2, #3
 80181f4:	611a      	str	r2, [r3, #16]
                oidCurveType);
        GetASN_OID(&dataASN[X509CERTASN_IDX_SIGALGO_OID], oidSigType);
 80181f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181f8:	f503 7344 	add.w	r3, r3, #784	@ 0x310
 80181fc:	2201      	movs	r2, #1
 80181fe:	611a      	str	r2, [r3, #16]
        /* Parse the X509 certificate. */
        ret = GetASN_Items(x509CertASN, dataASN, x509CertASN_Length, 1,
 8018200:	68fb      	ldr	r3, [r7, #12]
 8018202:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 8018206:	68fa      	ldr	r2, [r7, #12]
 8018208:	f502 725a 	add.w	r2, r2, #872	@ 0x368
 801820c:	68f9      	ldr	r1, [r7, #12]
 801820e:	f8d1 136c 	ldr.w	r1, [r1, #876]	@ 0x36c
 8018212:	9102      	str	r1, [sp, #8]
 8018214:	9201      	str	r2, [sp, #4]
 8018216:	9300      	str	r3, [sp, #0]
 8018218:	2301      	movs	r3, #1
 801821a:	2220      	movs	r2, #32
 801821c:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801821e:	48a6      	ldr	r0, [pc, #664]	@ (80184b8 <DecodeCertInternal+0x388>)
 8018220:	f7fb fb26 	bl	8013870 <GetASN_Items>
 8018224:	65b8      	str	r0, [r7, #88]	@ 0x58
            ret = ASN_PARSE_E;
        }
#endif
    }
    /* Check version is valid/supported - can't be negative. */
    if ((ret == 0) && (version > MAX_X509_VERSION)) {
 8018226:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018228:	2b00      	cmp	r3, #0
 801822a:	d105      	bne.n	8018238 <DecodeCertInternal+0x108>
 801822c:	7efb      	ldrb	r3, [r7, #27]
 801822e:	2b03      	cmp	r3, #3
 8018230:	d902      	bls.n	8018238 <DecodeCertInternal+0x108>
        WOLFSSL_MSG("Unexpected certificate version");
        WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
        ret = ASN_PARSE_E;
 8018232:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8018236:	65bb      	str	r3, [r7, #88]	@ 0x58
    }
    if (ret == 0) {
 8018238:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801823a:	2b00      	cmp	r3, #0
 801823c:	f040 8107 	bne.w	801844e <DecodeCertInternal+0x31e>
        int i;

        pubKeyOffset = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_SEQ].offset;
 8018240:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018242:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 8018246:	681b      	ldr	r3, [r3, #0]
 8018248:	643b      	str	r3, [r7, #64]	@ 0x40
        /* Set fields extracted from data. */
        cert->version = version;
 801824a:	7efb      	ldrb	r3, [r7, #27]
 801824c:	461a      	mov	r2, r3
 801824e:	68fb      	ldr	r3, [r7, #12]
 8018250:	629a      	str	r2, [r3, #40]	@ 0x28
        cert->serialSz = (int)serialSz;
 8018252:	693b      	ldr	r3, [r7, #16]
 8018254:	461a      	mov	r2, r3
 8018256:	68fb      	ldr	r3, [r7, #12]
 8018258:	f8c3 2394 	str.w	r2, [r3, #916]	@ 0x394
        !defined(WOLFSSL_ASN_ALLOW_0_SERIAL)
        /* RFC 5280 section 4.1.2.2 states that non-conforming CAs may issue
         * a negative or zero serial number and should be handled gracefully.
         * Since it is a non-conforming CA that issues a serial of 0 then we
         * treat it as an error here. */
        if (cert->serialSz == 1 && cert->serial[0] == 0) {
 801825c:	68fb      	ldr	r3, [r7, #12]
 801825e:	f8d3 3394 	ldr.w	r3, [r3, #916]	@ 0x394
 8018262:	2b01      	cmp	r3, #1
 8018264:	d107      	bne.n	8018276 <DecodeCertInternal+0x146>
 8018266:	68fb      	ldr	r3, [r7, #12]
 8018268:	f893 3374 	ldrb.w	r3, [r3, #884]	@ 0x374
 801826c:	2b00      	cmp	r3, #0
 801826e:	d102      	bne.n	8018276 <DecodeCertInternal+0x146>
            WOLFSSL_MSG("Error serial number of 0, use WOLFSSL_NO_ASN_STRICT "
                "if wanted");
            ret = ASN_PARSE_E;
 8018270:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8018274:	65bb      	str	r3, [r7, #88]	@ 0x58
        }
    #endif
        if (cert->serialSz == 0) {
 8018276:	68fb      	ldr	r3, [r7, #12]
 8018278:	f8d3 3394 	ldr.w	r3, [r3, #916]	@ 0x394
 801827c:	2b00      	cmp	r3, #0
 801827e:	d102      	bne.n	8018286 <DecodeCertInternal+0x156>
            WOLFSSL_MSG("Error serial size is zero. Should be at least one "
                        "even with no serial number.");
            ret = ASN_PARSE_E;
 8018280:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8018284:	65bb      	str	r3, [r7, #88]	@ 0x58
        }

        cert->signatureOID = dataASN[X509CERTASN_IDX_TBS_ALGOID_OID].data.oid.sum;
 8018286:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018288:	33a8      	adds	r3, #168	@ 0xa8
 801828a:	695a      	ldr	r2, [r3, #20]
 801828c:	68fb      	ldr	r3, [r7, #12]
 801828e:	619a      	str	r2, [r3, #24]
        cert->keyOID = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_ALGO_OID].data.oid.sum;
 8018290:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018292:	f503 73fc 	add.w	r3, r3, #504	@ 0x1f8
 8018296:	695a      	ldr	r2, [r3, #20]
 8018298:	68fb      	ldr	r3, [r7, #12]
 801829a:	61da      	str	r2, [r3, #28]
        cert->certBegin = dataASN[X509CERTASN_IDX_TBS_SEQ].offset;
 801829c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801829e:	331c      	adds	r3, #28
 80182a0:	681a      	ldr	r2, [r3, #0]
 80182a2:	68fb      	ldr	r3, [r7, #12]
 80182a4:	60da      	str	r2, [r3, #12]

        /* No bad date error - don't always care. */
        badDate = 0;
 80182a6:	2300      	movs	r3, #0
 80182a8:	657b      	str	r3, [r7, #84]	@ 0x54
        /* Find the item with the ASN_BEFORE date and check it. */
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTB_UTC].tag != 0)
 80182aa:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182ac:	f503 739a 	add.w	r3, r3, #308	@ 0x134
 80182b0:	7e5b      	ldrb	r3, [r3, #25]
                ? X509CERTASN_IDX_TBS_VALIDITY_NOTB_UTC
                : X509CERTASN_IDX_TBS_VALIDITY_NOTB_GT;
 80182b2:	2b00      	cmp	r3, #0
 80182b4:	d001      	beq.n	80182ba <DecodeCertInternal+0x18a>
 80182b6:	230b      	movs	r3, #11
 80182b8:	e000      	b.n	80182bc <DecodeCertInternal+0x18c>
 80182ba:	230c      	movs	r3, #12
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTB_UTC].tag != 0)
 80182bc:	633b      	str	r3, [r7, #48]	@ 0x30
        if ((CheckDate(&dataASN[i], ASN_BEFORE) < 0) && (verify != NO_VERIFY) &&
 80182be:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80182c0:	4613      	mov	r3, r2
 80182c2:	00db      	lsls	r3, r3, #3
 80182c4:	1a9b      	subs	r3, r3, r2
 80182c6:	009b      	lsls	r3, r3, #2
 80182c8:	461a      	mov	r2, r3
 80182ca:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182cc:	4413      	add	r3, r2
 80182ce:	2100      	movs	r1, #0
 80182d0:	4618      	mov	r0, r3
 80182d2:	f7ff ff05 	bl	80180e0 <CheckDate>
 80182d6:	4603      	mov	r3, r0
 80182d8:	2b00      	cmp	r3, #0
 80182da:	da08      	bge.n	80182ee <DecodeCertInternal+0x1be>
 80182dc:	68bb      	ldr	r3, [r7, #8]
 80182de:	2b00      	cmp	r3, #0
 80182e0:	d005      	beq.n	80182ee <DecodeCertInternal+0x1be>
 80182e2:	68bb      	ldr	r3, [r7, #8]
 80182e4:	2b05      	cmp	r3, #5
 80182e6:	d002      	beq.n	80182ee <DecodeCertInternal+0x1be>
                (verify != VERIFY_SKIP_DATE)) {
            badDate = ASN_BEFORE_DATE_E;
 80182e8:	f06f 0395 	mvn.w	r3, #149	@ 0x95
 80182ec:	657b      	str	r3, [r7, #84]	@ 0x54
        }
        /* Store reference to ASN_BEFORE date. */
        cert->beforeDate = GetASNItem_Addr(dataASN[i], cert->source);
 80182ee:	68fb      	ldr	r3, [r7, #12]
 80182f0:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 80182f4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80182f6:	4613      	mov	r3, r2
 80182f8:	00db      	lsls	r3, r3, #3
 80182fa:	1a9b      	subs	r3, r3, r2
 80182fc:	009b      	lsls	r3, r3, #2
 80182fe:	461a      	mov	r2, r3
 8018300:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018302:	4413      	add	r3, r2
 8018304:	681b      	ldr	r3, [r3, #0]
 8018306:	18ca      	adds	r2, r1, r3
 8018308:	68fb      	ldr	r3, [r7, #12]
 801830a:	f8c3 2444 	str.w	r2, [r3, #1092]	@ 0x444
        cert->beforeDateLen = (int)GetASNItem_Length(dataASN[i], cert->source);
 801830e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018310:	4613      	mov	r3, r2
 8018312:	00db      	lsls	r3, r3, #3
 8018314:	1a9b      	subs	r3, r3, r2
 8018316:	009b      	lsls	r3, r3, #2
 8018318:	461a      	mov	r2, r3
 801831a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801831c:	4413      	add	r3, r2
 801831e:	6859      	ldr	r1, [r3, #4]
 8018320:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018322:	4613      	mov	r3, r2
 8018324:	00db      	lsls	r3, r3, #3
 8018326:	1a9b      	subs	r3, r3, r2
 8018328:	009b      	lsls	r3, r3, #2
 801832a:	461a      	mov	r2, r3
 801832c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801832e:	4413      	add	r3, r2
 8018330:	689a      	ldr	r2, [r3, #8]
 8018332:	68fb      	ldr	r3, [r7, #12]
 8018334:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 8018338:	1ad3      	subs	r3, r2, r3
 801833a:	4419      	add	r1, r3
 801833c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801833e:	4613      	mov	r3, r2
 8018340:	00db      	lsls	r3, r3, #3
 8018342:	1a9b      	subs	r3, r3, r2
 8018344:	009b      	lsls	r3, r3, #2
 8018346:	461a      	mov	r2, r3
 8018348:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801834a:	4413      	add	r3, r2
 801834c:	681b      	ldr	r3, [r3, #0]
 801834e:	1acb      	subs	r3, r1, r3
 8018350:	461a      	mov	r2, r3
 8018352:	68fb      	ldr	r3, [r7, #12]
 8018354:	f8c3 2448 	str.w	r2, [r3, #1096]	@ 0x448

        /* Find the item with the ASN_AFTER date and check it. */
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTA_UTC].tag != 0)
 8018358:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801835a:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 801835e:	7e5b      	ldrb	r3, [r3, #25]
                ? X509CERTASN_IDX_TBS_VALIDITY_NOTA_UTC
                : X509CERTASN_IDX_TBS_VALIDITY_NOTA_GT;
 8018360:	2b00      	cmp	r3, #0
 8018362:	d001      	beq.n	8018368 <DecodeCertInternal+0x238>
 8018364:	230d      	movs	r3, #13
 8018366:	e000      	b.n	801836a <DecodeCertInternal+0x23a>
 8018368:	230e      	movs	r3, #14
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTA_UTC].tag != 0)
 801836a:	633b      	str	r3, [r7, #48]	@ 0x30
        if ((CheckDate(&dataASN[i], ASN_AFTER) < 0) && (verify != NO_VERIFY) &&
 801836c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801836e:	4613      	mov	r3, r2
 8018370:	00db      	lsls	r3, r3, #3
 8018372:	1a9b      	subs	r3, r3, r2
 8018374:	009b      	lsls	r3, r3, #2
 8018376:	461a      	mov	r2, r3
 8018378:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801837a:	4413      	add	r3, r2
 801837c:	2101      	movs	r1, #1
 801837e:	4618      	mov	r0, r3
 8018380:	f7ff feae 	bl	80180e0 <CheckDate>
 8018384:	4603      	mov	r3, r0
 8018386:	2b00      	cmp	r3, #0
 8018388:	da08      	bge.n	801839c <DecodeCertInternal+0x26c>
 801838a:	68bb      	ldr	r3, [r7, #8]
 801838c:	2b00      	cmp	r3, #0
 801838e:	d005      	beq.n	801839c <DecodeCertInternal+0x26c>
 8018390:	68bb      	ldr	r3, [r7, #8]
 8018392:	2b05      	cmp	r3, #5
 8018394:	d002      	beq.n	801839c <DecodeCertInternal+0x26c>
                (verify != VERIFY_SKIP_DATE)) {
            badDate = ASN_AFTER_DATE_E;
 8018396:	f06f 0396 	mvn.w	r3, #150	@ 0x96
 801839a:	657b      	str	r3, [r7, #84]	@ 0x54
        }
        /* Store reference to ASN_AFTER date. */
        cert->afterDate = GetASNItem_Addr(dataASN[i], cert->source);
 801839c:	68fb      	ldr	r3, [r7, #12]
 801839e:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 80183a2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80183a4:	4613      	mov	r3, r2
 80183a6:	00db      	lsls	r3, r3, #3
 80183a8:	1a9b      	subs	r3, r3, r2
 80183aa:	009b      	lsls	r3, r3, #2
 80183ac:	461a      	mov	r2, r3
 80183ae:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183b0:	4413      	add	r3, r2
 80183b2:	681b      	ldr	r3, [r3, #0]
 80183b4:	18ca      	adds	r2, r1, r3
 80183b6:	68fb      	ldr	r3, [r7, #12]
 80183b8:	f8c3 244c 	str.w	r2, [r3, #1100]	@ 0x44c
        cert->afterDateLen = (int)GetASNItem_Length(dataASN[i], cert->source);
 80183bc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80183be:	4613      	mov	r3, r2
 80183c0:	00db      	lsls	r3, r3, #3
 80183c2:	1a9b      	subs	r3, r3, r2
 80183c4:	009b      	lsls	r3, r3, #2
 80183c6:	461a      	mov	r2, r3
 80183c8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183ca:	4413      	add	r3, r2
 80183cc:	6859      	ldr	r1, [r3, #4]
 80183ce:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80183d0:	4613      	mov	r3, r2
 80183d2:	00db      	lsls	r3, r3, #3
 80183d4:	1a9b      	subs	r3, r3, r2
 80183d6:	009b      	lsls	r3, r3, #2
 80183d8:	461a      	mov	r2, r3
 80183da:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183dc:	4413      	add	r3, r2
 80183de:	689a      	ldr	r2, [r3, #8]
 80183e0:	68fb      	ldr	r3, [r7, #12]
 80183e2:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 80183e6:	1ad3      	subs	r3, r2, r3
 80183e8:	4419      	add	r1, r3
 80183ea:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80183ec:	4613      	mov	r3, r2
 80183ee:	00db      	lsls	r3, r3, #3
 80183f0:	1a9b      	subs	r3, r3, r2
 80183f2:	009b      	lsls	r3, r3, #2
 80183f4:	461a      	mov	r2, r3
 80183f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183f8:	4413      	add	r3, r2
 80183fa:	681b      	ldr	r3, [r3, #0]
 80183fc:	1acb      	subs	r3, r1, r3
 80183fe:	461a      	mov	r2, r3
 8018400:	68fb      	ldr	r3, [r7, #12]
 8018402:	f8c3 2450 	str.w	r2, [r3, #1104]	@ 0x450

        /* Get the issuer name. */
        issuer = cert->source + dataASN[X509CERTASN_IDX_TBS_ISSUER_SEQ].offset;
 8018406:	68fb      	ldr	r3, [r7, #12]
 8018408:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 801840c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801840e:	33fc      	adds	r3, #252	@ 0xfc
 8018410:	681b      	ldr	r3, [r3, #0]
 8018412:	4413      	add	r3, r2
 8018414:	653b      	str	r3, [r7, #80]	@ 0x50
        issuerSz = dataASN[X509CERTASN_IDX_TBS_VALIDITY_SEQ].offset -
 8018416:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018418:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 801841c:	681a      	ldr	r2, [r3, #0]
            dataASN[X509CERTASN_IDX_TBS_ISSUER_SEQ].offset;
 801841e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018420:	33fc      	adds	r3, #252	@ 0xfc
 8018422:	681b      	ldr	r3, [r3, #0]
        issuerSz = dataASN[X509CERTASN_IDX_TBS_VALIDITY_SEQ].offset -
 8018424:	1ad3      	subs	r3, r2, r3
 8018426:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Get the subject name. */
        subject = cert->source +
 8018428:	68fb      	ldr	r3, [r7, #12]
 801842a:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
            dataASN[X509CERTASN_IDX_TBS_SUBJECT_SEQ].offset;
 801842e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018430:	f503 73d2 	add.w	r3, r3, #420	@ 0x1a4
 8018434:	681b      	ldr	r3, [r3, #0]
        subject = cert->source +
 8018436:	4413      	add	r3, r2
 8018438:	64bb      	str	r3, [r7, #72]	@ 0x48
        subjectSz = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_SEQ].offset -
 801843a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801843c:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 8018440:	681a      	ldr	r2, [r3, #0]
            dataASN[X509CERTASN_IDX_TBS_SUBJECT_SEQ].offset;
 8018442:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018444:	f503 73d2 	add.w	r3, r3, #420	@ 0x1a4
 8018448:	681b      	ldr	r3, [r3, #0]
        subjectSz = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_SEQ].offset -
 801844a:	1ad3      	subs	r3, r2, r3
 801844c:	647b      	str	r3, [r7, #68]	@ 0x44
    }
    if ((ret == 0) && stopAtPubKey) {
 801844e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018450:	2b00      	cmp	r3, #0
 8018452:	d10a      	bne.n	801846a <DecodeCertInternal+0x33a>
 8018454:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8018456:	2b00      	cmp	r3, #0
 8018458:	d007      	beq.n	801846a <DecodeCertInternal+0x33a>
        /* Return any bad date error through badDateRet and return offset of
         * subjectPublicKeyInfo.
         */
        if (badDateRet != NULL) {
 801845a:	683b      	ldr	r3, [r7, #0]
 801845c:	2b00      	cmp	r3, #0
 801845e:	d002      	beq.n	8018466 <DecodeCertInternal+0x336>
            *badDateRet = badDate;
 8018460:	683b      	ldr	r3, [r7, #0]
 8018462:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8018464:	601a      	str	r2, [r3, #0]
        }
        done = 1;
 8018466:	2301      	movs	r3, #1
 8018468:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    if ((ret == 0) && (!done)) {
 801846a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801846c:	2b00      	cmp	r3, #0
 801846e:	f040 80a7 	bne.w	80185c0 <DecodeCertInternal+0x490>
 8018472:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018474:	2b00      	cmp	r3, #0
 8018476:	f040 80a3 	bne.w	80185c0 <DecodeCertInternal+0x490>
        /* Store the signature information. */
        cert->sigIndex = dataASN[X509CERTASN_IDX_SIGALGO_SEQ].offset;
 801847a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801847c:	f503 733d 	add.w	r3, r3, #756	@ 0x2f4
 8018480:	681a      	ldr	r2, [r3, #0]
 8018482:	68fb      	ldr	r3, [r7, #12]
 8018484:	611a      	str	r2, [r3, #16]
        GetASN_GetConstRef(&dataASN[X509CERTASN_IDX_SIGNATURE],
 8018486:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018488:	f503 7359 	add.w	r3, r3, #868	@ 0x364
 801848c:	689a      	ldr	r2, [r3, #8]
 801848e:	68fb      	ldr	r3, [r7, #12]
 8018490:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
 8018494:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018496:	f503 7359 	add.w	r3, r3, #868	@ 0x364
 801849a:	68da      	ldr	r2, [r3, #12]
 801849c:	68fb      	ldr	r3, [r7, #12]
 801849e:	615a      	str	r2, [r3, #20]
                &cert->signature, &cert->sigLength);
        /* Make sure 'signature' and 'signatureAlgorithm' are the same. */
        if (dataASN[X509CERTASN_IDX_SIGALGO_OID].data.oid.sum
 80184a0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184a2:	f503 7344 	add.w	r3, r3, #784	@ 0x310
 80184a6:	695a      	ldr	r2, [r3, #20]
                != cert->signatureOID) {
 80184a8:	68fb      	ldr	r3, [r7, #12]
 80184aa:	699b      	ldr	r3, [r3, #24]
        if (dataASN[X509CERTASN_IDX_SIGALGO_OID].data.oid.sum
 80184ac:	429a      	cmp	r2, r3
 80184ae:	d005      	beq.n	80184bc <DecodeCertInternal+0x38c>
            WOLFSSL_ERROR_VERBOSE(ASN_SIG_OID_E);
            ret = ASN_SIG_OID_E;
 80184b0:	f06f 0397 	mvn.w	r3, #151	@ 0x97
 80184b4:	65bb      	str	r3, [r7, #88]	@ 0x58
 80184b6:	e083      	b.n	80185c0 <DecodeCertInternal+0x490>
 80184b8:	08034794 	.word	0x08034794
        }
        /* Parameters not allowed after ECDSA or EdDSA algorithm OID. */
        else if (IsSigAlgoECC(cert->signatureOID)) {
 80184bc:	68fb      	ldr	r3, [r7, #12]
 80184be:	699b      	ldr	r3, [r3, #24]
 80184c0:	4618      	mov	r0, r3
 80184c2:	f7fd fdf8 	bl	80160b6 <IsSigAlgoECC>
 80184c6:	4603      	mov	r3, r0
 80184c8:	2b00      	cmp	r3, #0
 80184ca:	d012      	beq.n	80184f2 <DecodeCertInternal+0x3c2>
        #ifndef WOLFSSL_ECC_SIGALG_PARAMS_NULL_ALLOWED
            if (dataASN[X509CERTASN_IDX_SIGALGO_PARAMS_NULL].tag != 0) {
 80184cc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184ce:	f503 734b 	add.w	r3, r3, #812	@ 0x32c
 80184d2:	7e5b      	ldrb	r3, [r3, #25]
 80184d4:	2b00      	cmp	r3, #0
 80184d6:	d002      	beq.n	80184de <DecodeCertInternal+0x3ae>
                WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                ret = ASN_PARSE_E;
 80184d8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80184dc:	65bb      	str	r3, [r7, #88]	@ 0x58
            }
        #endif
        #ifdef WC_RSA_PSS
            if (dataASN[X509CERTASN_IDX_SIGALGO_PARAMS].tag != 0) {
 80184de:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184e0:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 80184e4:	7e5b      	ldrb	r3, [r3, #25]
 80184e6:	2b00      	cmp	r3, #0
 80184e8:	d06a      	beq.n	80185c0 <DecodeCertInternal+0x490>
                WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                ret = ASN_PARSE_E;
 80184ea:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80184ee:	65bb      	str	r3, [r7, #88]	@ 0x58
 80184f0:	e066      	b.n	80185c0 <DecodeCertInternal+0x490>
            }
        #endif
        }
    #ifdef WC_RSA_PSS
        /* Check parameters starting with a SEQUENCE. */
        else if (dataASN[X509CERTASN_IDX_SIGALGO_PARAMS].tag != 0) {
 80184f2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184f4:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 80184f8:	7e5b      	ldrb	r3, [r3, #25]
 80184fa:	2b00      	cmp	r3, #0
 80184fc:	d060      	beq.n	80185c0 <DecodeCertInternal+0x490>
            word32 oid = dataASN[X509CERTASN_IDX_SIGALGO_OID].data.oid.sum;
 80184fe:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018500:	f503 7344 	add.w	r3, r3, #784	@ 0x310
 8018504:	695b      	ldr	r3, [r3, #20]
 8018506:	62fb      	str	r3, [r7, #44]	@ 0x2c
            word32 sigAlgParamsSz = 0;
 8018508:	2300      	movs	r3, #0
 801850a:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Parameters only with RSA PSS. */
            if (oid != CTC_RSASSAPSS) {
 801850c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801850e:	f240 228e 	movw	r2, #654	@ 0x28e
 8018512:	4293      	cmp	r3, r2
 8018514:	d002      	beq.n	801851c <DecodeCertInternal+0x3ec>
                WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                ret = ASN_PARSE_E;
 8018516:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801851a:	65bb      	str	r3, [r7, #88]	@ 0x58
            }
            if (ret == 0) {
 801851c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801851e:	2b00      	cmp	r3, #0
 8018520:	d142      	bne.n	80185a8 <DecodeCertInternal+0x478>
                word32 tbsParamsSz;
                const byte* sigAlgParams;

                /* Check RSA PSS parameters are the same. */
                tbsParams =
                    GetASNItem_Addr(dataASN[X509CERTASN_IDX_TBS_ALGOID_PARAMS],
 8018522:	68fb      	ldr	r3, [r7, #12]
 8018524:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 8018528:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801852a:	33e0      	adds	r3, #224	@ 0xe0
 801852c:	681b      	ldr	r3, [r3, #0]
                tbsParams =
 801852e:	4413      	add	r3, r2
 8018530:	62bb      	str	r3, [r7, #40]	@ 0x28
                        cert->source);
                tbsParamsSz =
                    GetASNItem_Length(dataASN[X509CERTASN_IDX_TBS_ALGOID_PARAMS],
 8018532:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018534:	33e0      	adds	r3, #224	@ 0xe0
 8018536:	685b      	ldr	r3, [r3, #4]
 8018538:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801853a:	32e0      	adds	r2, #224	@ 0xe0
 801853c:	6891      	ldr	r1, [r2, #8]
 801853e:	68fa      	ldr	r2, [r7, #12]
 8018540:	f8d2 2364 	ldr.w	r2, [r2, #868]	@ 0x364
 8018544:	1a8a      	subs	r2, r1, r2
 8018546:	441a      	add	r2, r3
 8018548:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801854a:	33e0      	adds	r3, #224	@ 0xe0
 801854c:	681b      	ldr	r3, [r3, #0]
                tbsParamsSz =
 801854e:	1ad3      	subs	r3, r2, r3
 8018550:	627b      	str	r3, [r7, #36]	@ 0x24
                        cert->source);
                sigAlgParams =
                    GetASNItem_Addr(dataASN[X509CERTASN_IDX_SIGALGO_PARAMS],
 8018552:	68fb      	ldr	r3, [r7, #12]
 8018554:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 8018558:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801855a:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 801855e:	681b      	ldr	r3, [r3, #0]
                sigAlgParams =
 8018560:	4413      	add	r3, r2
 8018562:	623b      	str	r3, [r7, #32]
                        cert->source);
                sigAlgParamsSz =
                    GetASNItem_Length(dataASN[X509CERTASN_IDX_SIGALGO_PARAMS],
 8018564:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018566:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 801856a:	685b      	ldr	r3, [r3, #4]
 801856c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801856e:	f502 7252 	add.w	r2, r2, #840	@ 0x348
 8018572:	6891      	ldr	r1, [r2, #8]
 8018574:	68fa      	ldr	r2, [r7, #12]
 8018576:	f8d2 2364 	ldr.w	r2, [r2, #868]	@ 0x364
 801857a:	1a8a      	subs	r2, r1, r2
 801857c:	441a      	add	r2, r3
 801857e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018580:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 8018584:	681b      	ldr	r3, [r3, #0]
                sigAlgParamsSz =
 8018586:	1ad3      	subs	r3, r2, r3
 8018588:	637b      	str	r3, [r7, #52]	@ 0x34
                        cert->source);
                if ((tbsParamsSz != sigAlgParamsSz) ||
 801858a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801858c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801858e:	429a      	cmp	r2, r3
 8018590:	d107      	bne.n	80185a2 <DecodeCertInternal+0x472>
                        (XMEMCMP(tbsParams, sigAlgParams, tbsParamsSz) != 0)) {
 8018592:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018594:	6a39      	ldr	r1, [r7, #32]
 8018596:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8018598:	f010 fb1a 	bl	8028bd0 <memcmp>
 801859c:	4603      	mov	r3, r0
                if ((tbsParamsSz != sigAlgParamsSz) ||
 801859e:	2b00      	cmp	r3, #0
 80185a0:	d002      	beq.n	80185a8 <DecodeCertInternal+0x478>
                    WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                    ret = ASN_PARSE_E;
 80185a2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80185a6:	65bb      	str	r3, [r7, #88]	@ 0x58
                }
            }
            if (ret == 0) {
 80185a8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80185aa:	2b00      	cmp	r3, #0
 80185ac:	d108      	bne.n	80185c0 <DecodeCertInternal+0x490>
                /* Store parameters for use in signature verification. */
                cert->sigParamsIndex =
                    dataASN[X509CERTASN_IDX_SIGALGO_PARAMS].offset;
 80185ae:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80185b0:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 80185b4:	681a      	ldr	r2, [r3, #0]
                cert->sigParamsIndex =
 80185b6:	68fb      	ldr	r3, [r7, #12]
 80185b8:	621a      	str	r2, [r3, #32]
                cert->sigParamsLength = sigAlgParamsSz;
 80185ba:	68fb      	ldr	r3, [r7, #12]
 80185bc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80185be:	625a      	str	r2, [r3, #36]	@ 0x24
            }
        }
    #endif
    }
    if ((ret == 0) && (!done)) {
 80185c0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80185c2:	2b00      	cmp	r3, #0
 80185c4:	d112      	bne.n	80185ec <DecodeCertInternal+0x4bc>
 80185c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80185c8:	2b00      	cmp	r3, #0
 80185ca:	d10f      	bne.n	80185ec <DecodeCertInternal+0x4bc>
        pubKeyEnd = dataASN[X509CERTASN_IDX_TBS_ISSUERUID].offset;
 80185cc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80185ce:	f503 7321 	add.w	r3, r3, #644	@ 0x284
 80185d2:	681b      	ldr	r3, [r3, #0]
 80185d4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if (stopAfterPubKey) {
 80185d6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80185d8:	2b00      	cmp	r3, #0
 80185da:	d007      	beq.n	80185ec <DecodeCertInternal+0x4bc>
            /* Return any bad date error through badDateRed and return offset
             * after subjectPublicKeyInfo.
             */
            if (badDateRet != NULL) {
 80185dc:	683b      	ldr	r3, [r7, #0]
 80185de:	2b00      	cmp	r3, #0
 80185e0:	d002      	beq.n	80185e8 <DecodeCertInternal+0x4b8>
                *badDateRet = badDate;
 80185e2:	683b      	ldr	r3, [r7, #0]
 80185e4:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80185e6:	601a      	str	r2, [r3, #0]
            }
            done = 1;
 80185e8:	2301      	movs	r3, #1
 80185ea:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
    }
    if ((ret == 0) && (!done) &&
 80185ec:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80185ee:	2b00      	cmp	r3, #0
 80185f0:	d141      	bne.n	8018676 <DecodeCertInternal+0x546>
 80185f2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80185f4:	2b00      	cmp	r3, #0
 80185f6:	d13e      	bne.n	8018676 <DecodeCertInternal+0x546>
            (dataASN[X509CERTASN_IDX_TBS_EXT_SEQ].data.ref.data != NULL)) {
 80185f8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80185fa:	f503 7336 	add.w	r3, r3, #728	@ 0x2d8
 80185fe:	689b      	ldr	r3, [r3, #8]
    if ((ret == 0) && (!done) &&
 8018600:	2b00      	cmp	r3, #0
 8018602:	d038      	beq.n	8018676 <DecodeCertInternal+0x546>
    #ifndef ALLOW_V1_EXTENSIONS
        /* Certificate extensions were only defined in version 2. */
        if (cert->version < 2) {
 8018604:	68fb      	ldr	r3, [r7, #12]
 8018606:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018608:	2b01      	cmp	r3, #1
 801860a:	dc02      	bgt.n	8018612 <DecodeCertInternal+0x4e2>
            WOLFSSL_MSG("\tv1 and v2 certs not allowed extensions");
            WOLFSSL_ERROR_VERBOSE(ASN_VERSION_E);
            ret = ASN_VERSION_E;
 801860c:	f06f 038c 	mvn.w	r3, #140	@ 0x8c
 8018610:	65bb      	str	r3, [r7, #88]	@ 0x58
        }
    #endif
        if (ret == 0) {
 8018612:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018614:	2b00      	cmp	r3, #0
 8018616:	d12e      	bne.n	8018676 <DecodeCertInternal+0x546>
            /* Save references to extension data. */
            cert->extensions    = GetASNItem_Addr(
 8018618:	68fb      	ldr	r3, [r7, #12]
 801861a:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 801861e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018620:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 8018624:	681b      	ldr	r3, [r3, #0]
 8018626:	441a      	add	r2, r3
 8018628:	68fb      	ldr	r3, [r7, #12]
 801862a:	f8c3 2398 	str.w	r2, [r3, #920]	@ 0x398
                    dataASN[X509CERTASN_IDX_TBS_EXT], cert->source);
            cert->extensionsSz  = (int)GetASNItem_Length(
 801862e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018630:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 8018634:	685b      	ldr	r3, [r3, #4]
 8018636:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8018638:	f502 722f 	add.w	r2, r2, #700	@ 0x2bc
 801863c:	6891      	ldr	r1, [r2, #8]
 801863e:	68fa      	ldr	r2, [r7, #12]
 8018640:	f8d2 2364 	ldr.w	r2, [r2, #868]	@ 0x364
 8018644:	1a8a      	subs	r2, r1, r2
 8018646:	441a      	add	r2, r3
 8018648:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801864a:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 801864e:	681b      	ldr	r3, [r3, #0]
 8018650:	1ad3      	subs	r3, r2, r3
 8018652:	461a      	mov	r2, r3
 8018654:	68fb      	ldr	r3, [r7, #12]
 8018656:	f8c3 239c 	str.w	r2, [r3, #924]	@ 0x39c
                    dataASN[X509CERTASN_IDX_TBS_EXT], cert->source);
            cert->extensionsIdx = dataASN[X509CERTASN_IDX_TBS_EXT].offset;
 801865a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801865c:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 8018660:	681a      	ldr	r2, [r3, #0]
 8018662:	68fb      	ldr	r3, [r7, #12]
 8018664:	f8c3 23a0 	str.w	r2, [r3, #928]	@ 0x3a0
            /* Advance past extensions. */
            cert->srcIdx = dataASN[X509CERTASN_IDX_SIGALGO_SEQ].offset;
 8018668:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801866a:	f503 733d 	add.w	r3, r3, #756	@ 0x2f4
 801866e:	681a      	ldr	r2, [r3, #0]
 8018670:	68fb      	ldr	r3, [r7, #12]
 8018672:	f8c3 2368 	str.w	r2, [r3, #872]	@ 0x368
        }
    }

    /* Dispose of memory before allocating for extension decoding. */
    FREE_ASNGETDATA(dataASN, cert->heap);
 8018676:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018678:	2b00      	cmp	r3, #0
 801867a:	d007      	beq.n	801868c <DecodeCertInternal+0x55c>
 801867c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801867e:	61fb      	str	r3, [r7, #28]
 8018680:	69fb      	ldr	r3, [r7, #28]
 8018682:	2b00      	cmp	r3, #0
 8018684:	d002      	beq.n	801868c <DecodeCertInternal+0x55c>
 8018686:	69f8      	ldr	r0, [r7, #28]
 8018688:	f006 fb14 	bl	801ecb4 <wolfSSL_Free>

    if ((ret == 0) && (issuer != NULL)) {
 801868c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801868e:	2b00      	cmp	r3, #0
 8018690:	d116      	bne.n	80186c0 <DecodeCertInternal+0x590>
 8018692:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018694:	2b00      	cmp	r3, #0
 8018696:	d013      	beq.n	80186c0 <DecodeCertInternal+0x590>
        idx = 0;
 8018698:	2300      	movs	r3, #0
 801869a:	617b      	str	r3, [r7, #20]
        /* Put issuer into cert and calculate hash. */
        ret = GetCertName(cert, cert->issuer, cert->issuerHash, ASN_ISSUER, issuer,
 801869c:	68fb      	ldr	r3, [r7, #12]
 801869e:	f103 018d 	add.w	r1, r3, #141	@ 0x8d
 80186a2:	68fb      	ldr	r3, [r7, #12]
 80186a4:	f103 0260 	add.w	r2, r3, #96	@ 0x60
 80186a8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80186aa:	9302      	str	r3, [sp, #8]
 80186ac:	f107 0314 	add.w	r3, r7, #20
 80186b0:	9301      	str	r3, [sp, #4]
 80186b2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80186b4:	9300      	str	r3, [sp, #0]
 80186b6:	2300      	movs	r3, #0
 80186b8:	68f8      	ldr	r0, [r7, #12]
 80186ba:	f7fd fb5d 	bl	8015d78 <GetCertName>
 80186be:	65b8      	str	r0, [r7, #88]	@ 0x58
            &idx, issuerSz);
    }
    if ((ret == 0) && (subject != NULL)) {
 80186c0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80186c2:	2b00      	cmp	r3, #0
 80186c4:	d116      	bne.n	80186f4 <DecodeCertInternal+0x5c4>
 80186c6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80186c8:	2b00      	cmp	r3, #0
 80186ca:	d013      	beq.n	80186f4 <DecodeCertInternal+0x5c4>
        idx = 0;
 80186cc:	2300      	movs	r3, #0
 80186ce:	617b      	str	r3, [r7, #20]
        /* Put subject into cert and calculate hash. */
        ret = GetCertName(cert, cert->subject, cert->subjectHash, ASN_SUBJECT,
 80186d0:	68fb      	ldr	r3, [r7, #12]
 80186d2:	f203 11f5 	addw	r1, r3, #501	@ 0x1f5
 80186d6:	68fb      	ldr	r3, [r7, #12]
 80186d8:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 80186dc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80186de:	9302      	str	r3, [sp, #8]
 80186e0:	f107 0314 	add.w	r3, r7, #20
 80186e4:	9301      	str	r3, [sp, #4]
 80186e6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80186e8:	9300      	str	r3, [sp, #0]
 80186ea:	2301      	movs	r3, #1
 80186ec:	68f8      	ldr	r0, [r7, #12]
 80186ee:	f7fd fb43 	bl	8015d78 <GetCertName>
 80186f2:	65b8      	str	r0, [r7, #88]	@ 0x58
            subject, &idx, subjectSz);
    }
    if (ret == 0) {
 80186f4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80186f6:	2b00      	cmp	r3, #0
 80186f8:	d11a      	bne.n	8018730 <DecodeCertInternal+0x600>
            cert->selfSigned = 1;
        }
        else
    #endif
        {
            cert->selfSigned = (XMEMCMP(cert->issuerHash, cert->subjectHash,
 80186fa:	68fb      	ldr	r3, [r7, #12]
 80186fc:	f103 0060 	add.w	r0, r3, #96	@ 0x60
 8018700:	68fb      	ldr	r3, [r7, #12]
 8018702:	3340      	adds	r3, #64	@ 0x40
 8018704:	2220      	movs	r2, #32
 8018706:	4619      	mov	r1, r3
 8018708:	f010 fa62 	bl	8028bd0 <memcmp>
 801870c:	4603      	mov	r3, r0
                                        KEYID_SIZE) == 0);
 801870e:	2b00      	cmp	r3, #0
 8018710:	bf0c      	ite	eq
 8018712:	2301      	moveq	r3, #1
 8018714:	2300      	movne	r3, #0
 8018716:	b2d9      	uxtb	r1, r3
            cert->selfSigned = (XMEMCMP(cert->issuerHash, cert->subjectHash,
 8018718:	68fa      	ldr	r2, [r7, #12]
 801871a:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 801871e:	f361 0341 	bfi	r3, r1, #1, #1
 8018722:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
        }
        if (stopAtPubKey) {
 8018726:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8018728:	2b00      	cmp	r3, #0
 801872a:	d001      	beq.n	8018730 <DecodeCertInternal+0x600>
            ret = (int)pubKeyOffset;
 801872c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801872e:	65bb      	str	r3, [r7, #88]	@ 0x58
        }
    }

    if ((ret == 0) && (!stopAtPubKey)) {
 8018730:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018732:	2b00      	cmp	r3, #0
 8018734:	d10e      	bne.n	8018754 <DecodeCertInternal+0x624>
 8018736:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8018738:	2b00      	cmp	r3, #0
 801873a:	d10b      	bne.n	8018754 <DecodeCertInternal+0x624>
        /* Parse the public key. */
        idx = pubKeyOffset;
 801873c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801873e:	617b      	str	r3, [r7, #20]
        ret = GetCertKey(cert, cert->source, &idx, pubKeyEnd);
 8018740:	68fb      	ldr	r3, [r7, #12]
 8018742:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 8018746:	f107 0214 	add.w	r2, r7, #20
 801874a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801874c:	68f8      	ldr	r0, [r7, #12]
 801874e:	f7fc ff8f 	bl	8015670 <GetCertKey>
 8018752:	65b8      	str	r0, [r7, #88]	@ 0x58
    }
    if ((ret == 0) && (!stopAtPubKey) && (!stopAfterPubKey) &&
 8018754:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018756:	2b00      	cmp	r3, #0
 8018758:	d11e      	bne.n	8018798 <DecodeCertInternal+0x668>
 801875a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801875c:	2b00      	cmp	r3, #0
 801875e:	d11b      	bne.n	8018798 <DecodeCertInternal+0x668>
 8018760:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8018762:	2b00      	cmp	r3, #0
 8018764:	d118      	bne.n	8018798 <DecodeCertInternal+0x668>
            (cert->extensions != NULL)) {
 8018766:	68fb      	ldr	r3, [r7, #12]
 8018768:	f8d3 3398 	ldr.w	r3, [r3, #920]	@ 0x398
    if ((ret == 0) && (!stopAtPubKey) && (!stopAfterPubKey) &&
 801876c:	2b00      	cmp	r3, #0
 801876e:	d013      	beq.n	8018798 <DecodeCertInternal+0x668>
        /* Decode the extension data starting at [3]. */
        ret = DecodeCertExtensions(cert);
 8018770:	68f8      	ldr	r0, [r7, #12]
 8018772:	f7ff fbf7 	bl	8017f64 <DecodeCertExtensions>
 8018776:	65b8      	str	r0, [r7, #88]	@ 0x58
        if (criticalExt != NULL) {
 8018778:	687b      	ldr	r3, [r7, #4]
 801877a:	2b00      	cmp	r3, #0
 801877c:	d00c      	beq.n	8018798 <DecodeCertInternal+0x668>
            if (ret == WC_NO_ERR_TRACE(ASN_CRIT_EXT_E)) {
 801877e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018780:	f113 0fa0 	cmn.w	r3, #160	@ 0xa0
 8018784:	d105      	bne.n	8018792 <DecodeCertInternal+0x662>
                /* Return critical extension not recognized. */
                *criticalExt = ret;
 8018786:	687b      	ldr	r3, [r7, #4]
 8018788:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801878a:	601a      	str	r2, [r3, #0]
                ret = 0;
 801878c:	2300      	movs	r3, #0
 801878e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8018790:	e002      	b.n	8018798 <DecodeCertInternal+0x668>
            }
            else {
                /* No critical extension error. */
                *criticalExt = 0;
 8018792:	687b      	ldr	r3, [r7, #4]
 8018794:	2200      	movs	r2, #0
 8018796:	601a      	str	r2, [r3, #0]
            }
        }
    }

    if ((ret == 0) && (!done) && (badDate != 0)) {
 8018798:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801879a:	2b00      	cmp	r3, #0
 801879c:	d107      	bne.n	80187ae <DecodeCertInternal+0x67e>
 801879e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80187a0:	2b00      	cmp	r3, #0
 80187a2:	d104      	bne.n	80187ae <DecodeCertInternal+0x67e>
 80187a4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80187a6:	2b00      	cmp	r3, #0
 80187a8:	d001      	beq.n	80187ae <DecodeCertInternal+0x67e>
        /* Parsed whole certificate fine but return any date errors. */
        ret = badDate;
 80187aa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80187ac:	65bb      	str	r3, [r7, #88]	@ 0x58
    }

    return ret;
 80187ae:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
}
 80187b0:	4618      	mov	r0, r3
 80187b2:	3760      	adds	r7, #96	@ 0x60
 80187b4:	46bd      	mov	sp, r7
 80187b6:	bd80      	pop	{r7, pc}

080187b8 <DecodeCert>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int DecodeCert(DecodedCert* cert, int verify, int* criticalExt)
{
 80187b8:	b580      	push	{r7, lr}
 80187ba:	b086      	sub	sp, #24
 80187bc:	af02      	add	r7, sp, #8
 80187be:	60f8      	str	r0, [r7, #12]
 80187c0:	60b9      	str	r1, [r7, #8]
 80187c2:	607a      	str	r2, [r7, #4]
    return DecodeCertInternal(cert, verify, criticalExt, NULL, 0, 0);
 80187c4:	2300      	movs	r3, #0
 80187c6:	9301      	str	r3, [sp, #4]
 80187c8:	2300      	movs	r3, #0
 80187ca:	9300      	str	r3, [sp, #0]
 80187cc:	2300      	movs	r3, #0
 80187ce:	687a      	ldr	r2, [r7, #4]
 80187d0:	68b9      	ldr	r1, [r7, #8]
 80187d2:	68f8      	ldr	r0, [r7, #12]
 80187d4:	f7ff fcac 	bl	8018130 <DecodeCertInternal>
 80187d8:	4603      	mov	r3, r0
}
 80187da:	4618      	mov	r0, r3
 80187dc:	3710      	adds	r7, #16
 80187de:	46bd      	mov	sp, r7
 80187e0:	bd80      	pop	{r7, pc}

080187e2 <ParseCert>:
#endif /* WOLFSSL_CERT_REQ */

#endif

int ParseCert(DecodedCert* cert, int type, int verify, void* cm)
{
 80187e2:	b580      	push	{r7, lr}
 80187e4:	b088      	sub	sp, #32
 80187e6:	af02      	add	r7, sp, #8
 80187e8:	60f8      	str	r0, [r7, #12]
 80187ea:	60b9      	str	r1, [r7, #8]
 80187ec:	607a      	str	r2, [r7, #4]
 80187ee:	603b      	str	r3, [r7, #0]
#if (!defined(WOLFSSL_NO_MALLOC) && !defined(NO_WOLFSSL_CM_VERIFY)) || \
    defined(WOLFSSL_DYN_CERT)
    char* ptr;
#endif

    ret = ParseCertRelative(cert, type, verify, cm, NULL);
 80187f0:	2300      	movs	r3, #0
 80187f2:	9300      	str	r3, [sp, #0]
 80187f4:	683b      	ldr	r3, [r7, #0]
 80187f6:	687a      	ldr	r2, [r7, #4]
 80187f8:	68b9      	ldr	r1, [r7, #8]
 80187fa:	68f8      	ldr	r0, [r7, #12]
 80187fc:	f000 f869 	bl	80188d2 <ParseCertRelative>
 8018800:	6178      	str	r0, [r7, #20]
    if (ret < 0)
 8018802:	697b      	ldr	r3, [r7, #20]
 8018804:	2b00      	cmp	r3, #0
 8018806:	da01      	bge.n	801880c <ParseCert+0x2a>
        return ret;
 8018808:	697b      	ldr	r3, [r7, #20]
 801880a:	e05e      	b.n	80188ca <ParseCert+0xe8>

#if (!defined(WOLFSSL_NO_MALLOC) && !defined(NO_WOLFSSL_CM_VERIFY)) || \
    defined(WOLFSSL_DYN_CERT)
    /* cert->subjectCN not stored as copy of WOLFSSL_NO_MALLOC defined */
    if (cert->subjectCNLen > 0) {
 801880c:	68fb      	ldr	r3, [r7, #12]
 801880e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8018812:	2b00      	cmp	r3, #0
 8018814:	dd2a      	ble.n	801886c <ParseCert+0x8a>
        ptr = (char*)XMALLOC((size_t)cert->subjectCNLen + 1, cert->heap,
 8018816:	68fb      	ldr	r3, [r7, #12]
 8018818:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 801881c:	3301      	adds	r3, #1
 801881e:	4618      	mov	r0, r3
 8018820:	f006 fa2c 	bl	801ec7c <wolfSSL_Malloc>
 8018824:	6138      	str	r0, [r7, #16]
                              DYNAMIC_TYPE_SUBJECT_CN);
        if (ptr == NULL)
 8018826:	693b      	ldr	r3, [r7, #16]
 8018828:	2b00      	cmp	r3, #0
 801882a:	d102      	bne.n	8018832 <ParseCert+0x50>
            return MEMORY_E;
 801882c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8018830:	e04b      	b.n	80188ca <ParseCert+0xe8>
        XMEMCPY(ptr, cert->subjectCN, (size_t)cert->subjectCNLen);
 8018832:	68fb      	ldr	r3, [r7, #12]
 8018834:	f8d3 1084 	ldr.w	r1, [r3, #132]	@ 0x84
 8018838:	68fb      	ldr	r3, [r7, #12]
 801883a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 801883e:	461a      	mov	r2, r3
 8018840:	6938      	ldr	r0, [r7, #16]
 8018842:	f010 faa0 	bl	8028d86 <memcpy>
        ptr[cert->subjectCNLen] = '\0';
 8018846:	68fb      	ldr	r3, [r7, #12]
 8018848:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 801884c:	461a      	mov	r2, r3
 801884e:	693b      	ldr	r3, [r7, #16]
 8018850:	4413      	add	r3, r2
 8018852:	2200      	movs	r2, #0
 8018854:	701a      	strb	r2, [r3, #0]
        cert->subjectCN = ptr;
 8018856:	68fb      	ldr	r3, [r7, #12]
 8018858:	693a      	ldr	r2, [r7, #16]
 801885a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        cert->subjectCNStored = 1;
 801885e:	68fa      	ldr	r2, [r7, #12]
 8018860:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8018864:	f043 0301 	orr.w	r3, r3, #1
 8018868:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
#endif

#if (!defined(WOLFSSL_NO_MALLOC) && !defined(NO_WOLFSSL_CM_VERIFY)) || \
    defined(WOLFSSL_DYN_CERT)
    /* cert->publicKey not stored as copy if WOLFSSL_NO_MALLOC defined */
    if ((cert->keyOID == RSAk
 801886c:	68fb      	ldr	r3, [r7, #12]
 801886e:	69db      	ldr	r3, [r3, #28]
 8018870:	f240 2285 	movw	r2, #645	@ 0x285
 8018874:	4293      	cmp	r3, r2
 8018876:	d005      	beq.n	8018884 <ParseCert+0xa2>
    #ifdef WC_RSA_PSS
         || cert->keyOID == RSAPSSk
 8018878:	68fb      	ldr	r3, [r7, #12]
 801887a:	69db      	ldr	r3, [r3, #28]
 801887c:	f240 228e 	movw	r2, #654	@ 0x28e
 8018880:	4293      	cmp	r3, r2
 8018882:	d121      	bne.n	80188c8 <ParseCert+0xe6>
    #endif
         ) && cert->publicKey != NULL && cert->pubKeySize > 0) {
 8018884:	68fb      	ldr	r3, [r7, #12]
 8018886:	681b      	ldr	r3, [r3, #0]
 8018888:	2b00      	cmp	r3, #0
 801888a:	d01d      	beq.n	80188c8 <ParseCert+0xe6>
 801888c:	68fb      	ldr	r3, [r7, #12]
 801888e:	685b      	ldr	r3, [r3, #4]
 8018890:	2b00      	cmp	r3, #0
 8018892:	d019      	beq.n	80188c8 <ParseCert+0xe6>
        ptr = (char*)XMALLOC(cert->pubKeySize, cert->heap,
 8018894:	68fb      	ldr	r3, [r7, #12]
 8018896:	685b      	ldr	r3, [r3, #4]
 8018898:	4618      	mov	r0, r3
 801889a:	f006 f9ef 	bl	801ec7c <wolfSSL_Malloc>
 801889e:	6138      	str	r0, [r7, #16]
                              DYNAMIC_TYPE_PUBLIC_KEY);
        if (ptr == NULL)
 80188a0:	693b      	ldr	r3, [r7, #16]
 80188a2:	2b00      	cmp	r3, #0
 80188a4:	d102      	bne.n	80188ac <ParseCert+0xca>
            return MEMORY_E;
 80188a6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80188aa:	e00e      	b.n	80188ca <ParseCert+0xe8>
        XMEMCPY(ptr, cert->publicKey, cert->pubKeySize);
 80188ac:	68fb      	ldr	r3, [r7, #12]
 80188ae:	6819      	ldr	r1, [r3, #0]
 80188b0:	68fb      	ldr	r3, [r7, #12]
 80188b2:	685b      	ldr	r3, [r3, #4]
 80188b4:	461a      	mov	r2, r3
 80188b6:	6938      	ldr	r0, [r7, #16]
 80188b8:	f010 fa65 	bl	8028d86 <memcpy>
        cert->publicKey = (byte *)ptr;
 80188bc:	68fb      	ldr	r3, [r7, #12]
 80188be:	693a      	ldr	r2, [r7, #16]
 80188c0:	601a      	str	r2, [r3, #0]
        cert->pubKeyStored = 1;
 80188c2:	68fb      	ldr	r3, [r7, #12]
 80188c4:	2201      	movs	r2, #1
 80188c6:	609a      	str	r2, [r3, #8]
    }
#endif

    return ret;
 80188c8:	697b      	ldr	r3, [r7, #20]
}
 80188ca:	4618      	mov	r0, r3
 80188cc:	3718      	adds	r7, #24
 80188ce:	46bd      	mov	sp, r7
 80188d0:	bd80      	pop	{r7, pc}

080188d2 <ParseCertRelative>:
    }
    return NULL;
}

int ParseCertRelative(DecodedCert* cert, int type, int verify, void* cm, Signer *extraCAList)
{
 80188d2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80188d6:	b092      	sub	sp, #72	@ 0x48
 80188d8:	af08      	add	r7, sp, #32
 80188da:	6178      	str	r0, [r7, #20]
 80188dc:	6139      	str	r1, [r7, #16]
 80188de:	60fa      	str	r2, [r7, #12]
 80188e0:	60bb      	str	r3, [r7, #8]
    int    ret = 0;
 80188e2:	2300      	movs	r3, #0
 80188e4:	627b      	str	r3, [r7, #36]	@ 0x24
    int    idx = 0;
#endif
    byte*  sce_tsip_encRsaKeyIdx;
    (void)extraCAList;

    if (cert == NULL) {
 80188e6:	697b      	ldr	r3, [r7, #20]
 80188e8:	2b00      	cmp	r3, #0
 80188ea:	d102      	bne.n	80188f2 <ParseCertRelative+0x20>
        return BAD_FUNC_ARG;
 80188ec:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80188f0:	e202      	b.n	8018cf8 <ParseCertRelative+0x426>
#ifdef WOLFSSL_CERT_REQ
    if (type == CERTREQ_TYPE)
        cert->isCSR = 1;
#endif

    if (cert->sigCtx.state == SIG_STATE_BEGIN) {
 80188f2:	697b      	ldr	r3, [r7, #20]
 80188f4:	f8d3 3490 	ldr.w	r3, [r3, #1168]	@ 0x490
 80188f8:	2b00      	cmp	r3, #0
 80188fa:	f040 816f 	bne.w	8018bdc <ParseCertRelative+0x30a>
            }
        }
        else
#endif
        {
            ret = DecodeCert(cert, verify, &cert->criticalExt);
 80188fe:	697b      	ldr	r3, [r7, #20]
 8018900:	f503 6396 	add.w	r3, r3, #1200	@ 0x4b0
 8018904:	461a      	mov	r2, r3
 8018906:	68f9      	ldr	r1, [r7, #12]
 8018908:	6978      	ldr	r0, [r7, #20]
 801890a:	f7ff ff55 	bl	80187b8 <DecodeCert>
 801890e:	6278      	str	r0, [r7, #36]	@ 0x24
            if (ret == WC_NO_ERR_TRACE(ASN_BEFORE_DATE_E) ||
 8018910:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018912:	f113 0f96 	cmn.w	r3, #150	@ 0x96
 8018916:	d003      	beq.n	8018920 <ParseCertRelative+0x4e>
 8018918:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801891a:	f113 0f97 	cmn.w	r3, #151	@ 0x97
 801891e:	d109      	bne.n	8018934 <ParseCertRelative+0x62>
                ret == WC_NO_ERR_TRACE(ASN_AFTER_DATE_E)) {
                cert->badDate = ret;
 8018920:	697b      	ldr	r3, [r7, #20]
 8018922:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018924:	f8c3 24ac 	str.w	r2, [r3, #1196]	@ 0x4ac
                if (verify == VERIFY_SKIP_DATE)
 8018928:	68fb      	ldr	r3, [r7, #12]
 801892a:	2b05      	cmp	r3, #5
 801892c:	d107      	bne.n	801893e <ParseCertRelative+0x6c>
                    ret = 0;
 801892e:	2300      	movs	r3, #0
 8018930:	627b      	str	r3, [r7, #36]	@ 0x24
                if (verify == VERIFY_SKIP_DATE)
 8018932:	e004      	b.n	801893e <ParseCertRelative+0x6c>
            }
            else if (ret < 0) {
 8018934:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018936:	2b00      	cmp	r3, #0
 8018938:	da01      	bge.n	801893e <ParseCertRelative+0x6c>
                WOLFSSL_ERROR_VERBOSE(ret);
                return ret;
 801893a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801893c:	e1dc      	b.n	8018cf8 <ParseCertRelative+0x426>

    #ifndef ALLOW_INVALID_CERTSIGN
        /* https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.9
         *   If the cA boolean is not asserted, then the keyCertSign bit in the
         *   key usage extension MUST NOT be asserted. */
        if (!cert->isCA && cert->extKeyUsageSet &&
 801893e:	697b      	ldr	r3, [r7, #20]
 8018940:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018944:	f003 0310 	and.w	r3, r3, #16
 8018948:	b2db      	uxtb	r3, r3
 801894a:	2b00      	cmp	r3, #0
 801894c:	d111      	bne.n	8018972 <ParseCertRelative+0xa0>
 801894e:	697b      	ldr	r3, [r7, #20]
 8018950:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018954:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8018958:	b2db      	uxtb	r3, r3
 801895a:	2b00      	cmp	r3, #0
 801895c:	d009      	beq.n	8018972 <ParseCertRelative+0xa0>
                (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0) {
 801895e:	697b      	ldr	r3, [r7, #20]
 8018960:	f8b3 3420 	ldrh.w	r3, [r3, #1056]	@ 0x420
 8018964:	f003 0304 	and.w	r3, r3, #4
        if (!cert->isCA && cert->extKeyUsageSet &&
 8018968:	2b00      	cmp	r3, #0
 801896a:	d002      	beq.n	8018972 <ParseCertRelative+0xa0>
            WOLFSSL_ERROR_VERBOSE(KEYUSAGE_E);
            return KEYUSAGE_E;
 801896c:	f06f 03e1 	mvn.w	r3, #225	@ 0xe1
 8018970:	e1c2      	b.n	8018cf8 <ParseCertRelative+0x426>
        }
    #endif

    #ifndef NO_SKID
        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
 8018972:	697b      	ldr	r3, [r7, #20]
 8018974:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018978:	f003 0302 	and.w	r3, r3, #2
 801897c:	b2db      	uxtb	r3, r3
 801897e:	2b00      	cmp	r3, #0
 8018980:	d13a      	bne.n	80189f8 <ParseCertRelative+0x126>
 8018982:	697b      	ldr	r3, [r7, #20]
 8018984:	681b      	ldr	r3, [r3, #0]
 8018986:	2b00      	cmp	r3, #0
 8018988:	d036      	beq.n	80189f8 <ParseCertRelative+0x126>
                                                         cert->pubKeySize > 0) {
 801898a:	697b      	ldr	r3, [r7, #20]
 801898c:	685b      	ldr	r3, [r3, #4]
        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
 801898e:	2b00      	cmp	r3, #0
 8018990:	d032      	beq.n	80189f8 <ParseCertRelative+0x126>
            if (cert->signatureOID == CTC_SM3wSM2) {
 8018992:	697b      	ldr	r3, [r7, #20]
 8018994:	699b      	ldr	r3, [r3, #24]
 8018996:	f5b3 7f39 	cmp.w	r3, #740	@ 0x2e4
 801899a:	d115      	bne.n	80189c8 <ParseCertRelative+0xf6>
                /* TODO: GmSSL creates IDs this way but whole public key info
                 * block should be hashed. */
                ret = CalcHashId_ex(cert->publicKey + cert->pubKeySize - 65, 65,
 801899c:	697b      	ldr	r3, [r7, #20]
 801899e:	681a      	ldr	r2, [r3, #0]
 80189a0:	697b      	ldr	r3, [r7, #20]
 80189a2:	685b      	ldr	r3, [r3, #4]
 80189a4:	3b41      	subs	r3, #65	@ 0x41
 80189a6:	18d4      	adds	r4, r2, r3
                    cert->extSubjKeyId, HashIdAlg(cert->signatureOID));
 80189a8:	697b      	ldr	r3, [r7, #20]
 80189aa:	f503 7571 	add.w	r5, r3, #964	@ 0x3c4
                ret = CalcHashId_ex(cert->publicKey + cert->pubKeySize - 65, 65,
 80189ae:	697b      	ldr	r3, [r7, #20]
 80189b0:	699b      	ldr	r3, [r3, #24]
 80189b2:	4618      	mov	r0, r3
 80189b4:	f7fc ff50 	bl	8015858 <HashIdAlg>
 80189b8:	4603      	mov	r3, r0
 80189ba:	462a      	mov	r2, r5
 80189bc:	2141      	movs	r1, #65	@ 0x41
 80189be:	4620      	mov	r0, r4
 80189c0:	f7fc ff66 	bl	8015890 <CalcHashId_ex>
 80189c4:	6278      	str	r0, [r7, #36]	@ 0x24
 80189c6:	e012      	b.n	80189ee <ParseCertRelative+0x11c>
            }
            else {
                ret = CalcHashId_ex(cert->publicKey, cert->pubKeySize,
 80189c8:	697b      	ldr	r3, [r7, #20]
 80189ca:	681c      	ldr	r4, [r3, #0]
 80189cc:	697b      	ldr	r3, [r7, #20]
 80189ce:	685d      	ldr	r5, [r3, #4]
                    cert->extSubjKeyId, HashIdAlg(cert->signatureOID));
 80189d0:	697b      	ldr	r3, [r7, #20]
 80189d2:	f503 7671 	add.w	r6, r3, #964	@ 0x3c4
                ret = CalcHashId_ex(cert->publicKey, cert->pubKeySize,
 80189d6:	697b      	ldr	r3, [r7, #20]
 80189d8:	699b      	ldr	r3, [r3, #24]
 80189da:	4618      	mov	r0, r3
 80189dc:	f7fc ff3c 	bl	8015858 <HashIdAlg>
 80189e0:	4603      	mov	r3, r0
 80189e2:	4632      	mov	r2, r6
 80189e4:	4629      	mov	r1, r5
 80189e6:	4620      	mov	r0, r4
 80189e8:	f7fc ff52 	bl	8015890 <CalcHashId_ex>
 80189ec:	6278      	str	r0, [r7, #36]	@ 0x24
            }
            if (ret != 0) {
 80189ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80189f0:	2b00      	cmp	r3, #0
 80189f2:	d001      	beq.n	80189f8 <ParseCertRelative+0x126>
                WOLFSSL_ERROR_VERBOSE(ret);
                return ret;
 80189f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80189f6:	e17f      	b.n	8018cf8 <ParseCertRelative+0x426>
            }
        }
    #endif /* !NO_SKID */

        if (!cert->selfSigned || (verify != NO_VERIFY && type != CA_TYPE &&
 80189f8:	697b      	ldr	r3, [r7, #20]
 80189fa:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 80189fe:	f003 0302 	and.w	r3, r3, #2
 8018a02:	b2db      	uxtb	r3, r3
 8018a04:	2b00      	cmp	r3, #0
 8018a06:	d00b      	beq.n	8018a20 <ParseCertRelative+0x14e>
 8018a08:	68fb      	ldr	r3, [r7, #12]
 8018a0a:	2b00      	cmp	r3, #0
 8018a0c:	f000 8090 	beq.w	8018b30 <ParseCertRelative+0x25e>
 8018a10:	693b      	ldr	r3, [r7, #16]
 8018a12:	2b06      	cmp	r3, #6
 8018a14:	f000 808c 	beq.w	8018b30 <ParseCertRelative+0x25e>
 8018a18:	693b      	ldr	r3, [r7, #16]
 8018a1a:	2b11      	cmp	r3, #17
 8018a1c:	f000 8088 	beq.w	8018b30 <ParseCertRelative+0x25e>
                                                   type != TRUSTED_PEER_TYPE)) {
            cert->ca = NULL;
 8018a20:	697b      	ldr	r3, [r7, #20]
 8018a22:	2200      	movs	r2, #0
 8018a24:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
        if (extraCAList != NULL) {
            cert->ca = findSignerByName(extraCAList, cert->issuerHash);
        }
#endif
    #ifndef NO_SKID
            if (cert->ca == NULL && cert->extAuthKeyIdSet) {
 8018a28:	697b      	ldr	r3, [r7, #20]
 8018a2a:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a2e:	2b00      	cmp	r3, #0
 8018a30:	d12c      	bne.n	8018a8c <ParseCertRelative+0x1ba>
 8018a32:	697b      	ldr	r3, [r7, #20]
 8018a34:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018a38:	f003 0304 	and.w	r3, r3, #4
 8018a3c:	b2db      	uxtb	r3, r3
 8018a3e:	2b00      	cmp	r3, #0
 8018a40:	d024      	beq.n	8018a8c <ParseCertRelative+0x1ba>
                cert->ca = GetCA(cm, cert->extAuthKeyId);
 8018a42:	697b      	ldr	r3, [r7, #20]
 8018a44:	f503 737a 	add.w	r3, r3, #1000	@ 0x3e8
 8018a48:	4619      	mov	r1, r3
 8018a4a:	68b8      	ldr	r0, [r7, #8]
 8018a4c:	f7f3 fcfa 	bl	800c444 <GetCA>
 8018a50:	4602      	mov	r2, r0
 8018a52:	697b      	ldr	r3, [r7, #20]
 8018a54:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
        #ifdef WOLFSSL_AKID_NAME
                if (cert->ca == NULL) {
 8018a58:	697b      	ldr	r3, [r7, #20]
 8018a5a:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a5e:	2b00      	cmp	r3, #0
 8018a60:	d114      	bne.n	8018a8c <ParseCertRelative+0x1ba>
                    cert->ca = GetCAByAKID(cm, cert->extAuthKeyIdIssuer,
 8018a62:	697b      	ldr	r3, [r7, #20]
 8018a64:	f8d3 140c 	ldr.w	r1, [r3, #1036]	@ 0x40c
 8018a68:	697b      	ldr	r3, [r7, #20]
 8018a6a:	f8d3 2410 	ldr.w	r2, [r3, #1040]	@ 0x410
 8018a6e:	697b      	ldr	r3, [r7, #20]
 8018a70:	f8d3 0414 	ldr.w	r0, [r3, #1044]	@ 0x414
 8018a74:	697b      	ldr	r3, [r7, #20]
 8018a76:	f8d3 3418 	ldr.w	r3, [r3, #1048]	@ 0x418
 8018a7a:	9300      	str	r3, [sp, #0]
 8018a7c:	4603      	mov	r3, r0
 8018a7e:	68b8      	ldr	r0, [r7, #8]
 8018a80:	f7f3 fd26 	bl	800c4d0 <GetCAByAKID>
 8018a84:	4602      	mov	r2, r0
 8018a86:	697b      	ldr	r3, [r7, #20]
 8018a88:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
                        cert->extAuthKeyIdIssuerSz, cert->extAuthKeyIdIssuerSN,
                        cert->extAuthKeyIdIssuerSNSz);
                }
        #endif
            }
            if (cert->ca == NULL && cert->extSubjKeyIdSet
 8018a8c:	697b      	ldr	r3, [r7, #20]
 8018a8e:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a92:	2b00      	cmp	r3, #0
 8018a94:	d115      	bne.n	8018ac2 <ParseCertRelative+0x1f0>
 8018a96:	697b      	ldr	r3, [r7, #20]
 8018a98:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018a9c:	f003 0302 	and.w	r3, r3, #2
 8018aa0:	b2db      	uxtb	r3, r3
 8018aa2:	2b00      	cmp	r3, #0
 8018aa4:	d00d      	beq.n	8018ac2 <ParseCertRelative+0x1f0>
                                 && verify != VERIFY_OCSP) {
 8018aa6:	68fb      	ldr	r3, [r7, #12]
 8018aa8:	2b03      	cmp	r3, #3
 8018aaa:	d00a      	beq.n	8018ac2 <ParseCertRelative+0x1f0>
                cert->ca = GetCA(cm, cert->extSubjKeyId);
 8018aac:	697b      	ldr	r3, [r7, #20]
 8018aae:	f503 7371 	add.w	r3, r3, #964	@ 0x3c4
 8018ab2:	4619      	mov	r1, r3
 8018ab4:	68b8      	ldr	r0, [r7, #8]
 8018ab6:	f7f3 fcc5 	bl	800c444 <GetCA>
 8018aba:	4602      	mov	r2, r0
 8018abc:	697b      	ldr	r3, [r7, #20]
 8018abe:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
            }
            if (cert->ca != NULL && XMEMCMP(cert->issuerHash,
 8018ac2:	697b      	ldr	r3, [r7, #20]
 8018ac4:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018ac8:	2b00      	cmp	r3, #0
 8018aca:	d011      	beq.n	8018af0 <ParseCertRelative+0x21e>
 8018acc:	697b      	ldr	r3, [r7, #20]
 8018ace:	f103 0060 	add.w	r0, r3, #96	@ 0x60
 8018ad2:	697b      	ldr	r3, [r7, #20]
 8018ad4:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018ad8:	3320      	adds	r3, #32
 8018ada:	2220      	movs	r2, #32
 8018adc:	4619      	mov	r1, r3
 8018ade:	f010 f877 	bl	8028bd0 <memcmp>
 8018ae2:	4603      	mov	r3, r0
 8018ae4:	2b00      	cmp	r3, #0
 8018ae6:	d003      	beq.n	8018af0 <ParseCertRelative+0x21e>
                    cert->ca->subjectNameHash, KEYID_SIZE) != 0) {
                cert->ca = NULL;
 8018ae8:	697b      	ldr	r3, [r7, #20]
 8018aea:	2200      	movs	r2, #0
 8018aec:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
            }
            if (cert->ca == NULL) {
 8018af0:	697b      	ldr	r3, [r7, #20]
 8018af2:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018af6:	2b00      	cmp	r3, #0
 8018af8:	d11a      	bne.n	8018b30 <ParseCertRelative+0x25e>
                cert->ca = GetCAByName(cm, cert->issuerHash);
 8018afa:	697b      	ldr	r3, [r7, #20]
 8018afc:	3360      	adds	r3, #96	@ 0x60
 8018afe:	4619      	mov	r1, r3
 8018b00:	68b8      	ldr	r0, [r7, #8]
 8018b02:	f7f3 fd5d 	bl	800c5c0 <GetCAByName>
 8018b06:	4602      	mov	r2, r0
 8018b08:	697b      	ldr	r3, [r7, #20]
 8018b0a:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
                /* If AKID is available then this CA doesn't have the public
                 * key required */
                if (cert->ca && cert->extAuthKeyIdSet) {
 8018b0e:	697b      	ldr	r3, [r7, #20]
 8018b10:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018b14:	2b00      	cmp	r3, #0
 8018b16:	d00b      	beq.n	8018b30 <ParseCertRelative+0x25e>
 8018b18:	697b      	ldr	r3, [r7, #20]
 8018b1a:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018b1e:	f003 0304 	and.w	r3, r3, #4
 8018b22:	b2db      	uxtb	r3, r3
 8018b24:	2b00      	cmp	r3, #0
 8018b26:	d003      	beq.n	8018b30 <ParseCertRelative+0x25e>
                    WOLFSSL_MSG("CA SKID doesn't match AKID");
                    cert->ca = NULL;
 8018b28:	697b      	ldr	r3, [r7, #20]
 8018b2a:	2200      	movs	r2, #0
 8018b2c:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
                WOLFSSL_MSG("CA found");
            }
        }

        /* Set to WOLFSSL_MAX_PATH_LEN by default in InitDecodedCert_ex */
        if (cert->pathLengthSet)
 8018b30:	697b      	ldr	r3, [r7, #20]
 8018b32:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018b36:	f003 0320 	and.w	r3, r3, #32
 8018b3a:	b2db      	uxtb	r3, r3
 8018b3c:	2b00      	cmp	r3, #0
 8018b3e:	d005      	beq.n	8018b4c <ParseCertRelative+0x27a>
            cert->maxPathLen = cert->pathLength;
 8018b40:	697b      	ldr	r3, [r7, #20]
 8018b42:	f893 241c 	ldrb.w	r2, [r3, #1052]	@ 0x41c
 8018b46:	697b      	ldr	r3, [r7, #20]
 8018b48:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d

        if (!cert->selfSigned) {
 8018b4c:	697b      	ldr	r3, [r7, #20]
 8018b4e:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 8018b52:	f003 0302 	and.w	r3, r3, #2
 8018b56:	b2db      	uxtb	r3, r3
 8018b58:	2b00      	cmp	r3, #0
 8018b5a:	d13f      	bne.n	8018bdc <ParseCertRelative+0x30a>
            /* Need to perform a pathlen check on anything that will be used
             * to sign certificates later on. Otherwise, pathLen doesn't
             * mean anything.
             * Nothing to check if we don't have the issuer of this cert. */
            if (type != CERT_TYPE && cert->isCA && cert->extKeyUsageSet &&
 8018b5c:	693b      	ldr	r3, [r7, #16]
 8018b5e:	2b00      	cmp	r3, #0
 8018b60:	d03c      	beq.n	8018bdc <ParseCertRelative+0x30a>
 8018b62:	697b      	ldr	r3, [r7, #20]
 8018b64:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018b68:	f003 0310 	and.w	r3, r3, #16
 8018b6c:	b2db      	uxtb	r3, r3
 8018b6e:	2b00      	cmp	r3, #0
 8018b70:	d034      	beq.n	8018bdc <ParseCertRelative+0x30a>
 8018b72:	697b      	ldr	r3, [r7, #20]
 8018b74:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018b78:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8018b7c:	b2db      	uxtb	r3, r3
 8018b7e:	2b00      	cmp	r3, #0
 8018b80:	d02c      	beq.n	8018bdc <ParseCertRelative+0x30a>
                (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0 && cert->ca) {
 8018b82:	697b      	ldr	r3, [r7, #20]
 8018b84:	f8b3 3420 	ldrh.w	r3, [r3, #1056]	@ 0x420
 8018b88:	f003 0304 	and.w	r3, r3, #4
            if (type != CERT_TYPE && cert->isCA && cert->extKeyUsageSet &&
 8018b8c:	2b00      	cmp	r3, #0
 8018b8e:	d025      	beq.n	8018bdc <ParseCertRelative+0x30a>
                (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0 && cert->ca) {
 8018b90:	697b      	ldr	r3, [r7, #20]
 8018b92:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018b96:	2b00      	cmp	r3, #0
 8018b98:	d020      	beq.n	8018bdc <ParseCertRelative+0x30a>
                if (cert->ca->maxPathLen == 0) {
 8018b9a:	697b      	ldr	r3, [r7, #20]
 8018b9c:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018ba0:	7a9b      	ldrb	r3, [r3, #10]
 8018ba2:	2b00      	cmp	r3, #0
 8018ba4:	d109      	bne.n	8018bba <ParseCertRelative+0x2e8>
                    /* This cert CAN NOT be used as an intermediate cert. The
                     * issuer does not allow it. */
                    cert->maxPathLen = 0;
 8018ba6:	697b      	ldr	r3, [r7, #20]
 8018ba8:	2200      	movs	r2, #0
 8018baa:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d
                    if (verify != NO_VERIFY) {
 8018bae:	68fb      	ldr	r3, [r7, #12]
 8018bb0:	2b00      	cmp	r3, #0
 8018bb2:	d013      	beq.n	8018bdc <ParseCertRelative+0x30a>
                        WOLFSSL_MSG("\tNon-entity cert, maxPathLen is 0");
                        WOLFSSL_MSG("\tmaxPathLen status: ERROR");
                        WOLFSSL_ERROR_VERBOSE(ASN_PATHLEN_INV_E);
                        return ASN_PATHLEN_INV_E;
 8018bb4:	f06f 03ed 	mvn.w	r3, #237	@ 0xed
 8018bb8:	e09e      	b.n	8018cf8 <ParseCertRelative+0x426>
                    }
                }
                else {
                    cert->maxPathLen = (byte)min(cert->ca->maxPathLen - 1U,
 8018bba:	697b      	ldr	r3, [r7, #20]
 8018bbc:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018bc0:	7a9b      	ldrb	r3, [r3, #10]
 8018bc2:	1e5a      	subs	r2, r3, #1
                                           cert->maxPathLen);
 8018bc4:	697b      	ldr	r3, [r7, #20]
 8018bc6:	f893 341d 	ldrb.w	r3, [r3, #1053]	@ 0x41d
                    cert->maxPathLen = (byte)min(cert->ca->maxPathLen - 1U,
 8018bca:	4619      	mov	r1, r3
 8018bcc:	4610      	mov	r0, r2
 8018bce:	f7f9 fe31 	bl	8012834 <min>
 8018bd2:	4603      	mov	r3, r0
 8018bd4:	b2da      	uxtb	r2, r3
 8018bd6:	697b      	ldr	r3, [r7, #20]
 8018bd8:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d
    }

    sce_tsip_encRsaKeyIdx = cert->sce_tsip_encRsaKeyIdx;

#else
    sce_tsip_encRsaKeyIdx = NULL;
 8018bdc:	2300      	movs	r3, #0
 8018bde:	623b      	str	r3, [r7, #32]
#endif

    if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {
 8018be0:	68fb      	ldr	r3, [r7, #12]
 8018be2:	2b00      	cmp	r3, #0
 8018be4:	d072      	beq.n	8018ccc <ParseCertRelative+0x3fa>
 8018be6:	693b      	ldr	r3, [r7, #16]
 8018be8:	2b06      	cmp	r3, #6
 8018bea:	d06f      	beq.n	8018ccc <ParseCertRelative+0x3fa>
 8018bec:	693b      	ldr	r3, [r7, #16]
 8018bee:	2b11      	cmp	r3, #17
 8018bf0:	d06c      	beq.n	8018ccc <ParseCertRelative+0x3fa>
        if (cert->ca) {
 8018bf2:	697b      	ldr	r3, [r7, #20]
 8018bf4:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018bf8:	2b00      	cmp	r3, #0
 8018bfa:	d064      	beq.n	8018cc6 <ParseCertRelative+0x3f4>
            if (verify == VERIFY || verify == VERIFY_OCSP ||
 8018bfc:	68fb      	ldr	r3, [r7, #12]
 8018bfe:	2b01      	cmp	r3, #1
 8018c00:	d005      	beq.n	8018c0e <ParseCertRelative+0x33c>
 8018c02:	68fb      	ldr	r3, [r7, #12]
 8018c04:	2b03      	cmp	r3, #3
 8018c06:	d002      	beq.n	8018c0e <ParseCertRelative+0x33c>
 8018c08:	68fb      	ldr	r3, [r7, #12]
 8018c0a:	2b05      	cmp	r3, #5
 8018c0c:	d142      	bne.n	8018c94 <ParseCertRelative+0x3c2>
                                                 verify == VERIFY_SKIP_DATE) {
                word32 keyOID = cert->ca->keyOID;
 8018c0e:	697b      	ldr	r3, [r7, #20]
 8018c10:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018c14:	685b      	ldr	r3, [r3, #4]
 8018c16:	61fb      	str	r3, [r7, #28]
                if (cert->selfSigned && (cert->signatureOID == CTC_SM3wSM2)) {
                    keyOID = SM2k;
                }
            #endif
                /* try to confirm/verify signature */
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018c18:	697b      	ldr	r3, [r7, #20]
 8018c1a:	f203 4c74 	addw	ip, r3, #1140	@ 0x474
                        cert->source + cert->certBegin,
 8018c1e:	697b      	ldr	r3, [r7, #20]
 8018c20:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 8018c24:	697b      	ldr	r3, [r7, #20]
 8018c26:	68db      	ldr	r3, [r3, #12]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018c28:	eb02 0e03 	add.w	lr, r2, r3
                        cert->sigIndex - cert->certBegin,
 8018c2c:	697b      	ldr	r3, [r7, #20]
 8018c2e:	691a      	ldr	r2, [r3, #16]
 8018c30:	697b      	ldr	r3, [r7, #20]
 8018c32:	68db      	ldr	r3, [r3, #12]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018c34:	eba2 0803 	sub.w	r8, r2, r3
                        cert->ca->publicKey, cert->ca->pubKeySize,
 8018c38:	697b      	ldr	r3, [r7, #20]
 8018c3a:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018c3e:	68db      	ldr	r3, [r3, #12]
 8018c40:	607b      	str	r3, [r7, #4]
                        cert->ca->publicKey, cert->ca->pubKeySize,
 8018c42:	697b      	ldr	r3, [r7, #20]
 8018c44:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018c48:	681b      	ldr	r3, [r3, #0]
 8018c4a:	697a      	ldr	r2, [r7, #20]
 8018c4c:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
 8018c50:	6979      	ldr	r1, [r7, #20]
 8018c52:	6949      	ldr	r1, [r1, #20]
 8018c54:	6978      	ldr	r0, [r7, #20]
 8018c56:	6980      	ldr	r0, [r0, #24]
                        keyOID, cert->signature, cert->sigLength,
                        cert->signatureOID,
                    #ifdef WC_RSA_PSS
                        cert->source + cert->sigParamsIndex,
 8018c58:	697c      	ldr	r4, [r7, #20]
 8018c5a:	f8d4 5364 	ldr.w	r5, [r4, #868]	@ 0x364
 8018c5e:	697c      	ldr	r4, [r7, #20]
 8018c60:	6a24      	ldr	r4, [r4, #32]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018c62:	442c      	add	r4, r5
 8018c64:	697d      	ldr	r5, [r7, #20]
 8018c66:	6a6d      	ldr	r5, [r5, #36]	@ 0x24
 8018c68:	6a3e      	ldr	r6, [r7, #32]
 8018c6a:	9607      	str	r6, [sp, #28]
 8018c6c:	9506      	str	r5, [sp, #24]
 8018c6e:	9405      	str	r4, [sp, #20]
 8018c70:	9004      	str	r0, [sp, #16]
 8018c72:	9103      	str	r1, [sp, #12]
 8018c74:	9202      	str	r2, [sp, #8]
 8018c76:	69fa      	ldr	r2, [r7, #28]
 8018c78:	9201      	str	r2, [sp, #4]
 8018c7a:	9300      	str	r3, [sp, #0]
 8018c7c:	687b      	ldr	r3, [r7, #4]
 8018c7e:	4642      	mov	r2, r8
 8018c80:	4671      	mov	r1, lr
 8018c82:	4660      	mov	r0, ip
 8018c84:	f7fd fb4a 	bl	801631c <ConfirmSignature>
 8018c88:	6278      	str	r0, [r7, #36]	@ 0x24
 8018c8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c8c:	2b00      	cmp	r3, #0
 8018c8e:	d001      	beq.n	8018c94 <ParseCertRelative+0x3c2>
                        sce_tsip_encRsaKeyIdx)) != 0) {
                    if (ret != WC_NO_ERR_TRACE(WC_PENDING_E)) {
                        WOLFSSL_MSG("Confirm signature failed");
                    }
                    WOLFSSL_ERROR_VERBOSE(ret);
                    return ret;
 8018c90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c92:	e031      	b.n	8018cf8 <ParseCertRelative+0x426>
                    }
                }
            #endif /* WOLFSSL_DUAL_ALG_CERTS */
            }
        #ifndef IGNORE_NAME_CONSTRAINTS
            if (verify == VERIFY || verify == VERIFY_OCSP ||
 8018c94:	68fb      	ldr	r3, [r7, #12]
 8018c96:	2b01      	cmp	r3, #1
 8018c98:	d008      	beq.n	8018cac <ParseCertRelative+0x3da>
 8018c9a:	68fb      	ldr	r3, [r7, #12]
 8018c9c:	2b03      	cmp	r3, #3
 8018c9e:	d005      	beq.n	8018cac <ParseCertRelative+0x3da>
 8018ca0:	68fb      	ldr	r3, [r7, #12]
 8018ca2:	2b04      	cmp	r3, #4
 8018ca4:	d002      	beq.n	8018cac <ParseCertRelative+0x3da>
                        verify == VERIFY_NAME || verify == VERIFY_SKIP_DATE) {
 8018ca6:	68fb      	ldr	r3, [r7, #12]
 8018ca8:	2b05      	cmp	r3, #5
 8018caa:	d10f      	bne.n	8018ccc <ParseCertRelative+0x3fa>
                /* check that this cert's name is permitted by the signer's
                 * name constraints */
                if (!ConfirmNameConstraints(cert->ca, cert)) {
 8018cac:	697b      	ldr	r3, [r7, #20]
 8018cae:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018cb2:	6979      	ldr	r1, [r7, #20]
 8018cb4:	4618      	mov	r0, r3
 8018cb6:	f7fd febb 	bl	8016a30 <ConfirmNameConstraints>
 8018cba:	4603      	mov	r3, r0
 8018cbc:	2b00      	cmp	r3, #0
 8018cbe:	d105      	bne.n	8018ccc <ParseCertRelative+0x3fa>
                    WOLFSSL_MSG("Confirm name constraint failed");
                    WOLFSSL_ERROR_VERBOSE(ASN_NAME_INVALID_E);
                    return ASN_NAME_INVALID_E;
 8018cc0:	f06f 03c5 	mvn.w	r3, #197	@ 0xc5
 8018cc4:	e018      	b.n	8018cf8 <ParseCertRelative+0x426>
            }
            else
#endif
            {
                WOLFSSL_ERROR_VERBOSE(ASN_NO_SIGNER_E);
                return ASN_NO_SIGNER_E;
 8018cc6:	f06f 03bb 	mvn.w	r3, #187	@ 0xbb
 8018cca:	e015      	b.n	8018cf8 <ParseCertRelative+0x426>

#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)
exit_pcr:
#endif

    if (cert->badDate != 0) {
 8018ccc:	697b      	ldr	r3, [r7, #20]
 8018cce:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	@ 0x4ac
 8018cd2:	2b00      	cmp	r3, #0
 8018cd4:	d006      	beq.n	8018ce4 <ParseCertRelative+0x412>
        if (verify != VERIFY_SKIP_DATE) {
 8018cd6:	68fb      	ldr	r3, [r7, #12]
 8018cd8:	2b05      	cmp	r3, #5
 8018cda:	d003      	beq.n	8018ce4 <ParseCertRelative+0x412>
            return cert->badDate;
 8018cdc:	697b      	ldr	r3, [r7, #20]
 8018cde:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	@ 0x4ac
 8018ce2:	e009      	b.n	8018cf8 <ParseCertRelative+0x426>
        }
        WOLFSSL_MSG("Date error: Verify option is skipping");
    }

    if (cert->criticalExt != 0)
 8018ce4:	697b      	ldr	r3, [r7, #20]
 8018ce6:	f8d3 34b0 	ldr.w	r3, [r3, #1200]	@ 0x4b0
 8018cea:	2b00      	cmp	r3, #0
 8018cec:	d003      	beq.n	8018cf6 <ParseCertRelative+0x424>
        return cert->criticalExt;
 8018cee:	697b      	ldr	r3, [r7, #20]
 8018cf0:	f8d3 34b0 	ldr.w	r3, [r3, #1200]	@ 0x4b0
 8018cf4:	e000      	b.n	8018cf8 <ParseCertRelative+0x426>

    return ret;
 8018cf6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8018cf8:	4618      	mov	r0, r3
 8018cfa:	3728      	adds	r7, #40	@ 0x28
 8018cfc:	46bd      	mov	sp, r7
 8018cfe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08018d02 <FillSigner>:

int FillSigner(Signer* signer, DecodedCert* cert, int type, DerBuffer *der)
{
 8018d02:	b580      	push	{r7, lr}
 8018d04:	b086      	sub	sp, #24
 8018d06:	af00      	add	r7, sp, #0
 8018d08:	60f8      	str	r0, [r7, #12]
 8018d0a:	60b9      	str	r1, [r7, #8]
 8018d0c:	607a      	str	r2, [r7, #4]
 8018d0e:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8018d10:	2300      	movs	r3, #0
 8018d12:	617b      	str	r3, [r7, #20]

    if (signer == NULL || cert == NULL)
 8018d14:	68fb      	ldr	r3, [r7, #12]
 8018d16:	2b00      	cmp	r3, #0
 8018d18:	d002      	beq.n	8018d20 <FillSigner+0x1e>
 8018d1a:	68bb      	ldr	r3, [r7, #8]
 8018d1c:	2b00      	cmp	r3, #0
 8018d1e:	d102      	bne.n	8018d26 <FillSigner+0x24>
        return BAD_FUNC_ARG;
 8018d20:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8018d24:	e08c      	b.n	8018e40 <FillSigner+0x13e>
        }
    }
#endif /* WOLFSSL_DUAL_ALG_CERTS */

#if defined(WOLFSSL_AKID_NAME) || defined(HAVE_CRL)
    if (ret == 0 && signer != NULL)
 8018d26:	697b      	ldr	r3, [r7, #20]
 8018d28:	2b00      	cmp	r3, #0
 8018d2a:	d10f      	bne.n	8018d4c <FillSigner+0x4a>
 8018d2c:	68fb      	ldr	r3, [r7, #12]
 8018d2e:	2b00      	cmp	r3, #0
 8018d30:	d00c      	beq.n	8018d4c <FillSigner+0x4a>
        ret = CalcHashId(cert->serial, (word32)cert->serialSz,
 8018d32:	68bb      	ldr	r3, [r7, #8]
 8018d34:	f503 705d 	add.w	r0, r3, #884	@ 0x374
 8018d38:	68bb      	ldr	r3, [r7, #8]
 8018d3a:	f8d3 3394 	ldr.w	r3, [r3, #916]	@ 0x394
 8018d3e:	4619      	mov	r1, r3
                         signer->serialHash);
 8018d40:	68fb      	ldr	r3, [r7, #12]
 8018d42:	3360      	adds	r3, #96	@ 0x60
        ret = CalcHashId(cert->serial, (word32)cert->serialSz,
 8018d44:	461a      	mov	r2, r3
 8018d46:	f7fc fd92 	bl	801586e <CalcHashId>
 8018d4a:	6178      	str	r0, [r7, #20]
#endif
    if (ret == 0 && signer != NULL) {
 8018d4c:	697b      	ldr	r3, [r7, #20]
 8018d4e:	2b00      	cmp	r3, #0
 8018d50:	d175      	bne.n	8018e3e <FillSigner+0x13c>
 8018d52:	68fb      	ldr	r3, [r7, #12]
 8018d54:	2b00      	cmp	r3, #0
 8018d56:	d072      	beq.n	8018e3e <FillSigner+0x13c>
    if (ret == 0 && signer != NULL) {
        XMEMCPY(signer->derCert->buffer, der->buffer, der->length);
    #else
    (void)der;
    #endif
        signer->keyOID         = cert->keyOID;
 8018d58:	68bb      	ldr	r3, [r7, #8]
 8018d5a:	69da      	ldr	r2, [r3, #28]
 8018d5c:	68fb      	ldr	r3, [r7, #12]
 8018d5e:	605a      	str	r2, [r3, #4]
        if (cert->pubKeyStored) {
 8018d60:	68bb      	ldr	r3, [r7, #8]
 8018d62:	689b      	ldr	r3, [r3, #8]
 8018d64:	2b00      	cmp	r3, #0
 8018d66:	d007      	beq.n	8018d78 <FillSigner+0x76>
            signer->publicKey      = cert->publicKey;
 8018d68:	68bb      	ldr	r3, [r7, #8]
 8018d6a:	681a      	ldr	r2, [r3, #0]
 8018d6c:	68fb      	ldr	r3, [r7, #12]
 8018d6e:	60da      	str	r2, [r3, #12]
            signer->pubKeySize     = cert->pubKeySize;
 8018d70:	68bb      	ldr	r3, [r7, #8]
 8018d72:	685a      	ldr	r2, [r3, #4]
 8018d74:	68fb      	ldr	r3, [r7, #12]
 8018d76:	601a      	str	r2, [r3, #0]
        }

        if (cert->subjectCNStored) {
 8018d78:	68bb      	ldr	r3, [r7, #8]
 8018d7a:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018d7e:	f003 0301 	and.w	r3, r3, #1
 8018d82:	b2db      	uxtb	r3, r3
 8018d84:	2b00      	cmp	r3, #0
 8018d86:	d009      	beq.n	8018d9c <FillSigner+0x9a>
            signer->nameLen        = cert->subjectCNLen;
 8018d88:	68bb      	ldr	r3, [r7, #8]
 8018d8a:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 8018d8e:	68fb      	ldr	r3, [r7, #12]
 8018d90:	611a      	str	r2, [r3, #16]
            signer->name           = cert->subjectCN;
 8018d92:	68bb      	ldr	r3, [r7, #8]
 8018d94:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 8018d98:	68fb      	ldr	r3, [r7, #12]
 8018d9a:	615a      	str	r2, [r3, #20]
        }
        signer->maxPathLen     = cert->maxPathLen;
 8018d9c:	68bb      	ldr	r3, [r7, #8]
 8018d9e:	f893 241d 	ldrb.w	r2, [r3, #1053]	@ 0x41d
 8018da2:	68fb      	ldr	r3, [r7, #12]
 8018da4:	729a      	strb	r2, [r3, #10]
        signer->selfSigned     = cert->selfSigned;
 8018da6:	68bb      	ldr	r3, [r7, #8]
 8018da8:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 8018dac:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8018db0:	b2d9      	uxtb	r1, r3
 8018db2:	68fa      	ldr	r2, [r7, #12]
 8018db4:	7ad3      	ldrb	r3, [r2, #11]
 8018db6:	f361 0300 	bfi	r3, r1, #0, #1
 8018dba:	72d3      	strb	r3, [r2, #11]
    #ifndef IGNORE_NAME_CONSTRAINTS
        signer->permittedNames = cert->permittedNames;
 8018dbc:	68bb      	ldr	r3, [r7, #8]
 8018dbe:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8018dc0:	68fb      	ldr	r3, [r7, #12]
 8018dc2:	619a      	str	r2, [r3, #24]
        signer->excludedNames  = cert->excludedNames;
 8018dc4:	68bb      	ldr	r3, [r7, #8]
 8018dc6:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8018dc8:	68fb      	ldr	r3, [r7, #12]
 8018dca:	61da      	str	r2, [r3, #28]
    #endif
    #ifndef NO_SKID
        XMEMCPY(signer->subjectKeyIdHash, cert->extSubjKeyId,
 8018dcc:	68fb      	ldr	r3, [r7, #12]
 8018dce:	f103 0040 	add.w	r0, r3, #64	@ 0x40
 8018dd2:	68bb      	ldr	r3, [r7, #8]
 8018dd4:	f503 7371 	add.w	r3, r3, #964	@ 0x3c4
 8018dd8:	2220      	movs	r2, #32
 8018dda:	4619      	mov	r1, r3
 8018ddc:	f00f ffd3 	bl	8028d86 <memcpy>
                SIGNER_DIGEST_SIZE);
    #endif
        XMEMCPY(signer->subjectNameHash, cert->subjectHash,
 8018de0:	68fb      	ldr	r3, [r7, #12]
 8018de2:	f103 0020 	add.w	r0, r3, #32
 8018de6:	68bb      	ldr	r3, [r7, #8]
 8018de8:	3340      	adds	r3, #64	@ 0x40
 8018dea:	2220      	movs	r2, #32
 8018dec:	4619      	mov	r1, r3
 8018dee:	f00f ffca 	bl	8028d86 <memcpy>
    #endif
    #ifdef HAVE_OCSP
        XMEMCPY(signer->subjectKeyHash, cert->subjectKeyHash,
                KEYID_SIZE);
    #endif
        signer->keyUsage = cert->extKeyUsageSet ? cert->extKeyUsage
 8018df2:	68bb      	ldr	r3, [r7, #8]
 8018df4:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018df8:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8018dfc:	b2db      	uxtb	r3, r3
 8018dfe:	2b00      	cmp	r3, #0
 8018e00:	d003      	beq.n	8018e0a <FillSigner+0x108>
 8018e02:	68bb      	ldr	r3, [r7, #8]
 8018e04:	f8b3 2420 	ldrh.w	r2, [r3, #1056]	@ 0x420
 8018e08:	e001      	b.n	8018e0e <FillSigner+0x10c>
 8018e0a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8018e0e:	68fb      	ldr	r3, [r7, #12]
 8018e10:	811a      	strh	r2, [r3, #8]
                                                : 0xFFFF;
        signer->next    = NULL; /* If Key Usage not set, all uses valid. */
 8018e12:	68fb      	ldr	r3, [r7, #12]
 8018e14:	2200      	movs	r2, #0
 8018e16:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        cert->publicKey = 0;    /* in case lock fails don't free here.   */
 8018e1a:	68bb      	ldr	r3, [r7, #8]
 8018e1c:	2200      	movs	r2, #0
 8018e1e:	601a      	str	r2, [r3, #0]
        cert->subjectCN = 0;
 8018e20:	68bb      	ldr	r3, [r7, #8]
 8018e22:	2200      	movs	r2, #0
 8018e24:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
    #ifndef IGNORE_NAME_CONSTRAINTS
        cert->permittedNames = NULL;
 8018e28:	68bb      	ldr	r3, [r7, #8]
 8018e2a:	2200      	movs	r2, #0
 8018e2c:	639a      	str	r2, [r3, #56]	@ 0x38
        cert->excludedNames = NULL;
 8018e2e:	68bb      	ldr	r3, [r7, #8]
 8018e30:	2200      	movs	r2, #0
 8018e32:	63da      	str	r2, [r3, #60]	@ 0x3c
    #endif
        signer->type = (byte)type;
 8018e34:	687b      	ldr	r3, [r7, #4]
 8018e36:	b2da      	uxtb	r2, r3
 8018e38:	68fb      	ldr	r3, [r7, #12]
 8018e3a:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80
    }
    return ret;
 8018e3e:	697b      	ldr	r3, [r7, #20]
}
 8018e40:	4618      	mov	r0, r3
 8018e42:	3718      	adds	r7, #24
 8018e44:	46bd      	mov	sp, r7
 8018e46:	bd80      	pop	{r7, pc}

08018e48 <MakeSigner>:

/* Create and init an new signer */
Signer* MakeSigner(void* heap)
{
 8018e48:	b580      	push	{r7, lr}
 8018e4a:	b084      	sub	sp, #16
 8018e4c:	af00      	add	r7, sp, #0
 8018e4e:	6078      	str	r0, [r7, #4]
    Signer* signer = (Signer*) XMALLOC(sizeof(Signer), heap,
 8018e50:	2088      	movs	r0, #136	@ 0x88
 8018e52:	f005 ff13 	bl	801ec7c <wolfSSL_Malloc>
 8018e56:	60f8      	str	r0, [r7, #12]
                                       DYNAMIC_TYPE_SIGNER);
    if (signer) {
 8018e58:	68fb      	ldr	r3, [r7, #12]
 8018e5a:	2b00      	cmp	r3, #0
 8018e5c:	d004      	beq.n	8018e68 <MakeSigner+0x20>
        XMEMSET(signer, 0, sizeof(Signer));
 8018e5e:	2288      	movs	r2, #136	@ 0x88
 8018e60:	2100      	movs	r1, #0
 8018e62:	68f8      	ldr	r0, [r7, #12]
 8018e64:	f00f fede 	bl	8028c24 <memset>
    }
    (void)heap;

    return signer;
 8018e68:	68fb      	ldr	r3, [r7, #12]
}
 8018e6a:	4618      	mov	r0, r3
 8018e6c:	3710      	adds	r7, #16
 8018e6e:	46bd      	mov	sp, r7
 8018e70:	bd80      	pop	{r7, pc}

08018e72 <FreeSigner>:
 * @param [in, out] signer  On in, signer object.
 *                          On out, pointer is no longer valid.
 * @param [in]      heap    Dynamic memory hint.
 */
void FreeSigner(Signer* signer, void* heap)
{
 8018e72:	b580      	push	{r7, lr}
 8018e74:	b086      	sub	sp, #24
 8018e76:	af00      	add	r7, sp, #0
 8018e78:	6078      	str	r0, [r7, #4]
 8018e7a:	6039      	str	r1, [r7, #0]
    (void)signer;
    (void)heap;
    XFREE(signer->name, heap, DYNAMIC_TYPE_SUBJECT_CN);
 8018e7c:	687b      	ldr	r3, [r7, #4]
 8018e7e:	695b      	ldr	r3, [r3, #20]
 8018e80:	617b      	str	r3, [r7, #20]
 8018e82:	697b      	ldr	r3, [r7, #20]
 8018e84:	2b00      	cmp	r3, #0
 8018e86:	d002      	beq.n	8018e8e <FreeSigner+0x1c>
 8018e88:	6978      	ldr	r0, [r7, #20]
 8018e8a:	f005 ff13 	bl	801ecb4 <wolfSSL_Free>
    XFREE((void*)signer->publicKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8018e8e:	687b      	ldr	r3, [r7, #4]
 8018e90:	68db      	ldr	r3, [r3, #12]
 8018e92:	613b      	str	r3, [r7, #16]
 8018e94:	693b      	ldr	r3, [r7, #16]
 8018e96:	2b00      	cmp	r3, #0
 8018e98:	d002      	beq.n	8018ea0 <FreeSigner+0x2e>
 8018e9a:	6938      	ldr	r0, [r7, #16]
 8018e9c:	f005 ff0a 	bl	801ecb4 <wolfSSL_Free>
#ifdef WOLFSSL_DUAL_ALG_CERTS
    XFREE(signer->sapkiDer, heap, DYNAMIC_TYPE_PUBLIC_KEY);
#endif
#ifndef IGNORE_NAME_CONSTRAINTS
    if (signer->permittedNames)
 8018ea0:	687b      	ldr	r3, [r7, #4]
 8018ea2:	699b      	ldr	r3, [r3, #24]
 8018ea4:	2b00      	cmp	r3, #0
 8018ea6:	d005      	beq.n	8018eb4 <FreeSigner+0x42>
        FreeNameSubtrees(signer->permittedNames, heap);
 8018ea8:	687b      	ldr	r3, [r7, #4]
 8018eaa:	699b      	ldr	r3, [r3, #24]
 8018eac:	6839      	ldr	r1, [r7, #0]
 8018eae:	4618      	mov	r0, r3
 8018eb0:	f7fc fa84 	bl	80153bc <FreeNameSubtrees>
    if (signer->excludedNames)
 8018eb4:	687b      	ldr	r3, [r7, #4]
 8018eb6:	69db      	ldr	r3, [r3, #28]
 8018eb8:	2b00      	cmp	r3, #0
 8018eba:	d005      	beq.n	8018ec8 <FreeSigner+0x56>
        FreeNameSubtrees(signer->excludedNames, heap);
 8018ebc:	687b      	ldr	r3, [r7, #4]
 8018ebe:	69db      	ldr	r3, [r3, #28]
 8018ec0:	6839      	ldr	r1, [r7, #0]
 8018ec2:	4618      	mov	r0, r3
 8018ec4:	f7fc fa7a 	bl	80153bc <FreeNameSubtrees>
#endif
#ifdef WOLFSSL_SIGNER_DER_CERT
    FreeDer(&signer->derCert);
#endif
    XFREE(signer, heap, DYNAMIC_TYPE_SIGNER);
 8018ec8:	687b      	ldr	r3, [r7, #4]
 8018eca:	60fb      	str	r3, [r7, #12]
 8018ecc:	68fb      	ldr	r3, [r7, #12]
 8018ece:	2b00      	cmp	r3, #0
 8018ed0:	d002      	beq.n	8018ed8 <FreeSigner+0x66>
 8018ed2:	68f8      	ldr	r0, [r7, #12]
 8018ed4:	f005 feee 	bl	801ecb4 <wolfSSL_Free>
}
 8018ed8:	bf00      	nop
 8018eda:	3718      	adds	r7, #24
 8018edc:	46bd      	mov	sp, r7
 8018ede:	bd80      	pop	{r7, pc}

08018ee0 <FreeSignerTable>:
 * @param [in, out] table   Array of signer objects.
 * @param [in]      rows    Number of entries in table.
 * @param [in]      heap    Dynamic memory hint.
 */
void FreeSignerTable(Signer** table, int rows, void* heap)
{
 8018ee0:	b580      	push	{r7, lr}
 8018ee2:	b088      	sub	sp, #32
 8018ee4:	af00      	add	r7, sp, #0
 8018ee6:	60f8      	str	r0, [r7, #12]
 8018ee8:	60b9      	str	r1, [r7, #8]
 8018eea:	607a      	str	r2, [r7, #4]
    int i;

    for (i = 0; i < rows; i++) {
 8018eec:	2300      	movs	r3, #0
 8018eee:	61fb      	str	r3, [r7, #28]
 8018ef0:	e01c      	b.n	8018f2c <FreeSignerTable+0x4c>
        Signer* signer = table[i];
 8018ef2:	69fb      	ldr	r3, [r7, #28]
 8018ef4:	009b      	lsls	r3, r3, #2
 8018ef6:	68fa      	ldr	r2, [r7, #12]
 8018ef8:	4413      	add	r3, r2
 8018efa:	681b      	ldr	r3, [r3, #0]
 8018efc:	61bb      	str	r3, [r7, #24]
        while (signer) {
 8018efe:	e009      	b.n	8018f14 <FreeSignerTable+0x34>
            Signer* next = signer->next;
 8018f00:	69bb      	ldr	r3, [r7, #24]
 8018f02:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8018f06:	617b      	str	r3, [r7, #20]
            FreeSigner(signer, heap);
 8018f08:	6879      	ldr	r1, [r7, #4]
 8018f0a:	69b8      	ldr	r0, [r7, #24]
 8018f0c:	f7ff ffb1 	bl	8018e72 <FreeSigner>
            signer = next;
 8018f10:	697b      	ldr	r3, [r7, #20]
 8018f12:	61bb      	str	r3, [r7, #24]
        while (signer) {
 8018f14:	69bb      	ldr	r3, [r7, #24]
 8018f16:	2b00      	cmp	r3, #0
 8018f18:	d1f2      	bne.n	8018f00 <FreeSignerTable+0x20>
        }
        table[i] = NULL;
 8018f1a:	69fb      	ldr	r3, [r7, #28]
 8018f1c:	009b      	lsls	r3, r3, #2
 8018f1e:	68fa      	ldr	r2, [r7, #12]
 8018f20:	4413      	add	r3, r2
 8018f22:	2200      	movs	r2, #0
 8018f24:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rows; i++) {
 8018f26:	69fb      	ldr	r3, [r7, #28]
 8018f28:	3301      	adds	r3, #1
 8018f2a:	61fb      	str	r3, [r7, #28]
 8018f2c:	69fa      	ldr	r2, [r7, #28]
 8018f2e:	68bb      	ldr	r3, [r7, #8]
 8018f30:	429a      	cmp	r2, r3
 8018f32:	dbde      	blt.n	8018ef2 <FreeSignerTable+0x12>
    }
}
 8018f34:	bf00      	nop
 8018f36:	bf00      	nop
 8018f38:	3720      	adds	r7, #32
 8018f3a:	46bd      	mov	sp, r7
 8018f3c:	bd80      	pop	{r7, pc}
	...

08018f40 <AllocDer>:
#ifndef NO_CERTS

/* TODO: consider moving PEM code out to a different file. */

int AllocDer(DerBuffer** pDer, word32 length, int type, void* heap)
{
 8018f40:	b580      	push	{r7, lr}
 8018f42:	b088      	sub	sp, #32
 8018f44:	af00      	add	r7, sp, #0
 8018f46:	60f8      	str	r0, [r7, #12]
 8018f48:	60b9      	str	r1, [r7, #8]
 8018f4a:	607a      	str	r2, [r7, #4]
 8018f4c:	603b      	str	r3, [r7, #0]
    int ret = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 8018f4e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8018f52:	61fb      	str	r3, [r7, #28]
    if (pDer) {
 8018f54:	68fb      	ldr	r3, [r7, #12]
 8018f56:	2b00      	cmp	r3, #0
 8018f58:	f000 80a1 	beq.w	801909e <AllocDer+0x15e>
        int dynType = 0;
 8018f5c:	2300      	movs	r3, #0
 8018f5e:	61bb      	str	r3, [r7, #24]
        DerBuffer* der;

        /* Determine dynamic type */
        switch (type) {
 8018f60:	687b      	ldr	r3, [r7, #4]
 8018f62:	2b2a      	cmp	r3, #42	@ 0x2a
 8018f64:	d86a      	bhi.n	801903c <AllocDer+0xfc>
 8018f66:	a201      	add	r2, pc, #4	@ (adr r2, 8018f6c <AllocDer+0x2c>)
 8018f68:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018f6c:	0801901f 	.word	0x0801901f
 8018f70:	0801903d 	.word	0x0801903d
 8018f74:	0801903d 	.word	0x0801903d
 8018f78:	0801903d 	.word	0x0801903d
 8018f7c:	0801903d 	.word	0x0801903d
 8018f80:	08019025 	.word	0x08019025
 8018f84:	08019019 	.word	0x08019019
 8018f88:	0801903d 	.word	0x0801903d
 8018f8c:	0801903d 	.word	0x0801903d
 8018f90:	0801903d 	.word	0x0801903d
 8018f94:	0801903d 	.word	0x0801903d
 8018f98:	0801902b 	.word	0x0801902b
 8018f9c:	08019031 	.word	0x08019031
 8018fa0:	08019037 	.word	0x08019037
 8018fa4:	0801903d 	.word	0x0801903d
 8018fa8:	0801903d 	.word	0x0801903d
 8018fac:	0801903d 	.word	0x0801903d
 8018fb0:	0801903d 	.word	0x0801903d
 8018fb4:	0801903d 	.word	0x0801903d
 8018fb8:	0801903d 	.word	0x0801903d
 8018fbc:	0801903d 	.word	0x0801903d
 8018fc0:	0801903d 	.word	0x0801903d
 8018fc4:	0801903d 	.word	0x0801903d
 8018fc8:	0801903d 	.word	0x0801903d
 8018fcc:	0801903d 	.word	0x0801903d
 8018fd0:	0801903d 	.word	0x0801903d
 8018fd4:	0801903d 	.word	0x0801903d
 8018fd8:	0801903d 	.word	0x0801903d
 8018fdc:	0801903d 	.word	0x0801903d
 8018fe0:	0801903d 	.word	0x0801903d
 8018fe4:	0801903d 	.word	0x0801903d
 8018fe8:	0801903d 	.word	0x0801903d
 8018fec:	0801903d 	.word	0x0801903d
 8018ff0:	0801903d 	.word	0x0801903d
 8018ff4:	0801903d 	.word	0x0801903d
 8018ff8:	0801903d 	.word	0x0801903d
 8018ffc:	0801903d 	.word	0x0801903d
 8019000:	0801903d 	.word	0x0801903d
 8019004:	0801903d 	.word	0x0801903d
 8019008:	0801903d 	.word	0x0801903d
 801900c:	0801903d 	.word	0x0801903d
 8019010:	0801903d 	.word	0x0801903d
 8019014:	0801901f 	.word	0x0801901f
            case CA_TYPE:   dynType = DYNAMIC_TYPE_CA;   break;
 8019018:	2301      	movs	r3, #1
 801901a:	61bb      	str	r3, [r7, #24]
 801901c:	e011      	b.n	8019042 <AllocDer+0x102>
            case CHAIN_CERT_TYPE:
            case CERT_TYPE: dynType = DYNAMIC_TYPE_CERT; break;
 801901e:	2302      	movs	r3, #2
 8019020:	61bb      	str	r3, [r7, #24]
 8019022:	e00e      	b.n	8019042 <AllocDer+0x102>
            case CRL_TYPE:  dynType = DYNAMIC_TYPE_CRL;  break;
 8019024:	2316      	movs	r3, #22
 8019026:	61bb      	str	r3, [r7, #24]
 8019028:	e00b      	b.n	8019042 <AllocDer+0x102>
            case DSA_TYPE:  dynType = DYNAMIC_TYPE_DSA;  break;
 801902a:	2315      	movs	r3, #21
 801902c:	61bb      	str	r3, [r7, #24]
 801902e:	e008      	b.n	8019042 <AllocDer+0x102>
            case ECC_TYPE:  dynType = DYNAMIC_TYPE_ECC;  break;
 8019030:	2325      	movs	r3, #37	@ 0x25
 8019032:	61bb      	str	r3, [r7, #24]
 8019034:	e005      	b.n	8019042 <AllocDer+0x102>
            case RSA_TYPE:  dynType = DYNAMIC_TYPE_RSA;  break;
 8019036:	230a      	movs	r3, #10
 8019038:	61bb      	str	r3, [r7, #24]
 801903a:	e002      	b.n	8019042 <AllocDer+0x102>
            default:        dynType = DYNAMIC_TYPE_KEY;  break;
 801903c:	2303      	movs	r3, #3
 801903e:	61bb      	str	r3, [r7, #24]
 8019040:	bf00      	nop
        }

        /* Setup new buffer */
        *pDer = (DerBuffer*)XMALLOC(sizeof(DerBuffer) + length, heap, dynType);
 8019042:	68bb      	ldr	r3, [r7, #8]
 8019044:	3314      	adds	r3, #20
 8019046:	4618      	mov	r0, r3
 8019048:	f005 fe18 	bl	801ec7c <wolfSSL_Malloc>
 801904c:	4602      	mov	r2, r0
 801904e:	68fb      	ldr	r3, [r7, #12]
 8019050:	601a      	str	r2, [r3, #0]
        if (*pDer == NULL) {
 8019052:	68fb      	ldr	r3, [r7, #12]
 8019054:	681b      	ldr	r3, [r3, #0]
 8019056:	2b00      	cmp	r3, #0
 8019058:	d102      	bne.n	8019060 <AllocDer+0x120>
            return MEMORY_E;
 801905a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801905e:	e022      	b.n	80190a6 <AllocDer+0x166>
        }
        XMEMSET(*pDer, 0, sizeof(DerBuffer) + length);
 8019060:	68fb      	ldr	r3, [r7, #12]
 8019062:	6818      	ldr	r0, [r3, #0]
 8019064:	68bb      	ldr	r3, [r7, #8]
 8019066:	3314      	adds	r3, #20
 8019068:	461a      	mov	r2, r3
 801906a:	2100      	movs	r1, #0
 801906c:	f00f fdda 	bl	8028c24 <memset>

        der = *pDer;
 8019070:	68fb      	ldr	r3, [r7, #12]
 8019072:	681b      	ldr	r3, [r3, #0]
 8019074:	617b      	str	r3, [r7, #20]
        der->type = type;
 8019076:	697b      	ldr	r3, [r7, #20]
 8019078:	687a      	ldr	r2, [r7, #4]
 801907a:	60da      	str	r2, [r3, #12]
        der->dynType = dynType; /* Cache this for FreeDer */
 801907c:	697b      	ldr	r3, [r7, #20]
 801907e:	69ba      	ldr	r2, [r7, #24]
 8019080:	611a      	str	r2, [r3, #16]
        der->heap = heap;
 8019082:	697b      	ldr	r3, [r7, #20]
 8019084:	683a      	ldr	r2, [r7, #0]
 8019086:	605a      	str	r2, [r3, #4]
        der->buffer = (byte*)der + sizeof(DerBuffer);
 8019088:	697b      	ldr	r3, [r7, #20]
 801908a:	f103 0214 	add.w	r2, r3, #20
 801908e:	697b      	ldr	r3, [r7, #20]
 8019090:	601a      	str	r2, [r3, #0]
        der->length = length;
 8019092:	697b      	ldr	r3, [r7, #20]
 8019094:	68ba      	ldr	r2, [r7, #8]
 8019096:	609a      	str	r2, [r3, #8]
        ret = 0; /* Success */
 8019098:	2300      	movs	r3, #0
 801909a:	61fb      	str	r3, [r7, #28]
 801909c:	e002      	b.n	80190a4 <AllocDer+0x164>
    } else {
        ret = BAD_FUNC_ARG;
 801909e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80190a2:	61fb      	str	r3, [r7, #28]
    }
    return ret;
 80190a4:	69fb      	ldr	r3, [r7, #28]
}
 80190a6:	4618      	mov	r0, r3
 80190a8:	3720      	adds	r7, #32
 80190aa:	46bd      	mov	sp, r7
 80190ac:	bd80      	pop	{r7, pc}
 80190ae:	bf00      	nop

080190b0 <AllocCopyDer>:

int AllocCopyDer(DerBuffer** pDer, const unsigned char* buff, word32 length,
    int type, void* heap)
{
 80190b0:	b580      	push	{r7, lr}
 80190b2:	b086      	sub	sp, #24
 80190b4:	af00      	add	r7, sp, #0
 80190b6:	60f8      	str	r0, [r7, #12]
 80190b8:	60b9      	str	r1, [r7, #8]
 80190ba:	607a      	str	r2, [r7, #4]
 80190bc:	603b      	str	r3, [r7, #0]
    int ret = AllocDer(pDer, length, type, heap);
 80190be:	6a3b      	ldr	r3, [r7, #32]
 80190c0:	683a      	ldr	r2, [r7, #0]
 80190c2:	6879      	ldr	r1, [r7, #4]
 80190c4:	68f8      	ldr	r0, [r7, #12]
 80190c6:	f7ff ff3b 	bl	8018f40 <AllocDer>
 80190ca:	6178      	str	r0, [r7, #20]
    if (ret == 0) {
 80190cc:	697b      	ldr	r3, [r7, #20]
 80190ce:	2b00      	cmp	r3, #0
 80190d0:	d107      	bne.n	80190e2 <AllocCopyDer+0x32>
        XMEMCPY((*pDer)->buffer, buff, length);
 80190d2:	68fb      	ldr	r3, [r7, #12]
 80190d4:	681b      	ldr	r3, [r3, #0]
 80190d6:	681b      	ldr	r3, [r3, #0]
 80190d8:	687a      	ldr	r2, [r7, #4]
 80190da:	68b9      	ldr	r1, [r7, #8]
 80190dc:	4618      	mov	r0, r3
 80190de:	f00f fe52 	bl	8028d86 <memcpy>
    }

    return ret;
 80190e2:	697b      	ldr	r3, [r7, #20]
}
 80190e4:	4618      	mov	r0, r3
 80190e6:	3718      	adds	r7, #24
 80190e8:	46bd      	mov	sp, r7
 80190ea:	bd80      	pop	{r7, pc}

080190ec <FreeDer>:

void FreeDer(DerBuffer** pDer)
{
 80190ec:	b580      	push	{r7, lr}
 80190ee:	b084      	sub	sp, #16
 80190f0:	af00      	add	r7, sp, #0
 80190f2:	6078      	str	r0, [r7, #4]
    if (pDer && *pDer) {
 80190f4:	687b      	ldr	r3, [r7, #4]
 80190f6:	2b00      	cmp	r3, #0
 80190f8:	d02b      	beq.n	8019152 <FreeDer+0x66>
 80190fa:	687b      	ldr	r3, [r7, #4]
 80190fc:	681b      	ldr	r3, [r3, #0]
 80190fe:	2b00      	cmp	r3, #0
 8019100:	d027      	beq.n	8019152 <FreeDer+0x66>
        DerBuffer* der = (DerBuffer*)*pDer;
 8019102:	687b      	ldr	r3, [r7, #4]
 8019104:	681b      	ldr	r3, [r3, #0]
 8019106:	60fb      	str	r3, [r7, #12]

        /* ForceZero private keys */
        if (((der->type == PRIVATEKEY_TYPE) ||
 8019108:	68fb      	ldr	r3, [r7, #12]
 801910a:	68db      	ldr	r3, [r3, #12]
 801910c:	2b01      	cmp	r3, #1
 801910e:	d003      	beq.n	8019118 <FreeDer+0x2c>
             (der->type == ALT_PRIVATEKEY_TYPE)) && der->buffer != NULL) {
 8019110:	68fb      	ldr	r3, [r7, #12]
 8019112:	68db      	ldr	r3, [r3, #12]
        if (((der->type == PRIVATEKEY_TYPE) ||
 8019114:	2b02      	cmp	r3, #2
 8019116:	d10b      	bne.n	8019130 <FreeDer+0x44>
             (der->type == ALT_PRIVATEKEY_TYPE)) && der->buffer != NULL) {
 8019118:	68fb      	ldr	r3, [r7, #12]
 801911a:	681b      	ldr	r3, [r3, #0]
 801911c:	2b00      	cmp	r3, #0
 801911e:	d007      	beq.n	8019130 <FreeDer+0x44>
            ForceZero(der->buffer, der->length);
 8019120:	68fb      	ldr	r3, [r7, #12]
 8019122:	681a      	ldr	r2, [r3, #0]
 8019124:	68fb      	ldr	r3, [r7, #12]
 8019126:	689b      	ldr	r3, [r3, #8]
 8019128:	4619      	mov	r1, r3
 801912a:	4610      	mov	r0, r2
 801912c:	f7f9 fb69 	bl	8012802 <ForceZero>
        }
        der->buffer = NULL;
 8019130:	68fb      	ldr	r3, [r7, #12]
 8019132:	2200      	movs	r2, #0
 8019134:	601a      	str	r2, [r3, #0]
        der->length = 0;
 8019136:	68fb      	ldr	r3, [r7, #12]
 8019138:	2200      	movs	r2, #0
 801913a:	609a      	str	r2, [r3, #8]
        XFREE(der, der->heap, der->dynType);
 801913c:	68fb      	ldr	r3, [r7, #12]
 801913e:	60bb      	str	r3, [r7, #8]
 8019140:	68bb      	ldr	r3, [r7, #8]
 8019142:	2b00      	cmp	r3, #0
 8019144:	d002      	beq.n	801914c <FreeDer+0x60>
 8019146:	68b8      	ldr	r0, [r7, #8]
 8019148:	f005 fdb4 	bl	801ecb4 <wolfSSL_Free>

        *pDer = NULL;
 801914c:	687b      	ldr	r3, [r7, #4]
 801914e:	2200      	movs	r2, #0
 8019150:	601a      	str	r2, [r3, #0]
    }
}
 8019152:	bf00      	nop
 8019154:	3710      	adds	r7, #16
 8019156:	46bd      	mov	sp, r7
 8019158:	bd80      	pop	{r7, pc}

0801915a <SkipEndOfLineChars>:
                                             "-----END X509 CRL-----");

#ifdef WOLFSSL_PEM_TO_DER
static WC_INLINE const char* SkipEndOfLineChars(const char* line,
                                                const char* endOfLine)
{
 801915a:	b480      	push	{r7}
 801915c:	b083      	sub	sp, #12
 801915e:	af00      	add	r7, sp, #0
 8019160:	6078      	str	r0, [r7, #4]
 8019162:	6039      	str	r1, [r7, #0]
    /* eat end of line characters */
    while (line < endOfLine &&
 8019164:	e002      	b.n	801916c <SkipEndOfLineChars+0x12>
              (line[0] == '\r' || line[0] == '\n')) {
        line++;
 8019166:	687b      	ldr	r3, [r7, #4]
 8019168:	3301      	adds	r3, #1
 801916a:	607b      	str	r3, [r7, #4]
    while (line < endOfLine &&
 801916c:	687a      	ldr	r2, [r7, #4]
 801916e:	683b      	ldr	r3, [r7, #0]
 8019170:	429a      	cmp	r2, r3
 8019172:	d207      	bcs.n	8019184 <SkipEndOfLineChars+0x2a>
              (line[0] == '\r' || line[0] == '\n')) {
 8019174:	687b      	ldr	r3, [r7, #4]
 8019176:	781b      	ldrb	r3, [r3, #0]
    while (line < endOfLine &&
 8019178:	2b0d      	cmp	r3, #13
 801917a:	d0f4      	beq.n	8019166 <SkipEndOfLineChars+0xc>
              (line[0] == '\r' || line[0] == '\n')) {
 801917c:	687b      	ldr	r3, [r7, #4]
 801917e:	781b      	ldrb	r3, [r3, #0]
 8019180:	2b0a      	cmp	r3, #10
 8019182:	d0f0      	beq.n	8019166 <SkipEndOfLineChars+0xc>
    }
    return line;
 8019184:	687b      	ldr	r3, [r7, #4]
}
 8019186:	4618      	mov	r0, r3
 8019188:	370c      	adds	r7, #12
 801918a:	46bd      	mov	sp, r7
 801918c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019190:	4770      	bx	lr
	...

08019194 <wc_PemGetHeaderFooter>:
#endif

int wc_PemGetHeaderFooter(int type, const char** header, const char** footer)
{
 8019194:	b480      	push	{r7}
 8019196:	b087      	sub	sp, #28
 8019198:	af00      	add	r7, sp, #0
 801919a:	60f8      	str	r0, [r7, #12]
 801919c:	60b9      	str	r1, [r7, #8]
 801919e:	607a      	str	r2, [r7, #4]
    int ret = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 80191a0:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80191a4:	617b      	str	r3, [r7, #20]

    switch (type) {
 80191a6:	68fb      	ldr	r3, [r7, #12]
 80191a8:	2b2a      	cmp	r3, #42	@ 0x2a
 80191aa:	f200 80fe 	bhi.w	80193aa <wc_PemGetHeaderFooter+0x216>
 80191ae:	a201      	add	r2, pc, #4	@ (adr r2, 80191b4 <wc_PemGetHeaderFooter+0x20>)
 80191b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80191b4:	08019261 	.word	0x08019261
 80191b8:	08019315 	.word	0x08019315
 80191bc:	080193ab 	.word	0x080193ab
 80191c0:	0801929d 	.word	0x0801929d
 80191c4:	080193ab 	.word	0x080193ab
 80191c8:	0801927f 	.word	0x0801927f
 80191cc:	08019261 	.word	0x08019261
 80191d0:	080192d9 	.word	0x080192d9
 80191d4:	080193ab 	.word	0x080193ab
 80191d8:	080193ab 	.word	0x080193ab
 80191dc:	080193ab 	.word	0x080193ab
 80191e0:	080193ab 	.word	0x080193ab
 80191e4:	080192d9 	.word	0x080192d9
 80191e8:	08019315 	.word	0x08019315
 80191ec:	08019333 	.word	0x08019333
 80191f0:	08019351 	.word	0x08019351
 80191f4:	08019333 	.word	0x08019333
 80191f8:	08019261 	.word	0x08019261
 80191fc:	080193ab 	.word	0x080193ab
 8019200:	080193ab 	.word	0x080193ab
 8019204:	080193ab 	.word	0x080193ab
 8019208:	080193ab 	.word	0x080193ab
 801920c:	0801936f 	.word	0x0801936f
 8019210:	0801938d 	.word	0x0801938d
 8019214:	080193ab 	.word	0x080193ab
 8019218:	0801936f 	.word	0x0801936f
 801921c:	080192bb 	.word	0x080192bb
 8019220:	080193ab 	.word	0x080193ab
 8019224:	080193ab 	.word	0x080193ab
 8019228:	080193ab 	.word	0x080193ab
 801922c:	080193ab 	.word	0x080193ab
 8019230:	080193ab 	.word	0x080193ab
 8019234:	080193ab 	.word	0x080193ab
 8019238:	080193ab 	.word	0x080193ab
 801923c:	080193ab 	.word	0x080193ab
 8019240:	080193ab 	.word	0x080193ab
 8019244:	080193ab 	.word	0x080193ab
 8019248:	080193ab 	.word	0x080193ab
 801924c:	080193ab 	.word	0x080193ab
 8019250:	080193ab 	.word	0x080193ab
 8019254:	080193ab 	.word	0x080193ab
 8019258:	080192f7 	.word	0x080192f7
 801925c:	08019261 	.word	0x08019261
        case CA_TYPE:       /* same as below */
        case TRUSTED_PEER_TYPE:
        case CHAIN_CERT_TYPE:
        case CERT_TYPE:
            if (header) *header = BEGIN_CERT;
 8019260:	68bb      	ldr	r3, [r7, #8]
 8019262:	2b00      	cmp	r3, #0
 8019264:	d002      	beq.n	801926c <wc_PemGetHeaderFooter+0xd8>
 8019266:	4a56      	ldr	r2, [pc, #344]	@ (80193c0 <wc_PemGetHeaderFooter+0x22c>)
 8019268:	68bb      	ldr	r3, [r7, #8]
 801926a:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_CERT;
 801926c:	687b      	ldr	r3, [r7, #4]
 801926e:	2b00      	cmp	r3, #0
 8019270:	d002      	beq.n	8019278 <wc_PemGetHeaderFooter+0xe4>
 8019272:	4a54      	ldr	r2, [pc, #336]	@ (80193c4 <wc_PemGetHeaderFooter+0x230>)
 8019274:	687b      	ldr	r3, [r7, #4]
 8019276:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019278:	2300      	movs	r3, #0
 801927a:	617b      	str	r3, [r7, #20]
            break;
 801927c:	e099      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>

        case CRL_TYPE:
            if (header) *header = BEGIN_X509_CRL;
 801927e:	68bb      	ldr	r3, [r7, #8]
 8019280:	2b00      	cmp	r3, #0
 8019282:	d002      	beq.n	801928a <wc_PemGetHeaderFooter+0xf6>
 8019284:	4a50      	ldr	r2, [pc, #320]	@ (80193c8 <wc_PemGetHeaderFooter+0x234>)
 8019286:	68bb      	ldr	r3, [r7, #8]
 8019288:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_X509_CRL;
 801928a:	687b      	ldr	r3, [r7, #4]
 801928c:	2b00      	cmp	r3, #0
 801928e:	d002      	beq.n	8019296 <wc_PemGetHeaderFooter+0x102>
 8019290:	4a4e      	ldr	r2, [pc, #312]	@ (80193cc <wc_PemGetHeaderFooter+0x238>)
 8019292:	687b      	ldr	r3, [r7, #4]
 8019294:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019296:	2300      	movs	r3, #0
 8019298:	617b      	str	r3, [r7, #20]
            break;
 801929a:	e08a      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>
    #ifndef NO_DH
        case DH_PARAM_TYPE:
            if (header) *header = BEGIN_DH_PARAM;
 801929c:	68bb      	ldr	r3, [r7, #8]
 801929e:	2b00      	cmp	r3, #0
 80192a0:	d002      	beq.n	80192a8 <wc_PemGetHeaderFooter+0x114>
 80192a2:	4a4b      	ldr	r2, [pc, #300]	@ (80193d0 <wc_PemGetHeaderFooter+0x23c>)
 80192a4:	68bb      	ldr	r3, [r7, #8]
 80192a6:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_DH_PARAM;
 80192a8:	687b      	ldr	r3, [r7, #4]
 80192aa:	2b00      	cmp	r3, #0
 80192ac:	d002      	beq.n	80192b4 <wc_PemGetHeaderFooter+0x120>
 80192ae:	4a49      	ldr	r2, [pc, #292]	@ (80193d4 <wc_PemGetHeaderFooter+0x240>)
 80192b0:	687b      	ldr	r3, [r7, #4]
 80192b2:	601a      	str	r2, [r3, #0]
            ret = 0;
 80192b4:	2300      	movs	r3, #0
 80192b6:	617b      	str	r3, [r7, #20]
            break;
 80192b8:	e07b      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>
        case X942_PARAM_TYPE:
            if (header) *header = BEGIN_X942_PARAM;
 80192ba:	68bb      	ldr	r3, [r7, #8]
 80192bc:	2b00      	cmp	r3, #0
 80192be:	d002      	beq.n	80192c6 <wc_PemGetHeaderFooter+0x132>
 80192c0:	4a45      	ldr	r2, [pc, #276]	@ (80193d8 <wc_PemGetHeaderFooter+0x244>)
 80192c2:	68bb      	ldr	r3, [r7, #8]
 80192c4:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_X942_PARAM;
 80192c6:	687b      	ldr	r3, [r7, #4]
 80192c8:	2b00      	cmp	r3, #0
 80192ca:	d002      	beq.n	80192d2 <wc_PemGetHeaderFooter+0x13e>
 80192cc:	4a43      	ldr	r2, [pc, #268]	@ (80193dc <wc_PemGetHeaderFooter+0x248>)
 80192ce:	687b      	ldr	r3, [r7, #4]
 80192d0:	601a      	str	r2, [r3, #0]
            ret = 0;
 80192d2:	2300      	movs	r3, #0
 80192d4:	617b      	str	r3, [r7, #20]
            break;
 80192d6:	e06c      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>
            break;
    #endif
    #ifdef HAVE_ECC
        case ECC_TYPE:
        case ECC_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_EC_PRIV;
 80192d8:	68bb      	ldr	r3, [r7, #8]
 80192da:	2b00      	cmp	r3, #0
 80192dc:	d002      	beq.n	80192e4 <wc_PemGetHeaderFooter+0x150>
 80192de:	4a40      	ldr	r2, [pc, #256]	@ (80193e0 <wc_PemGetHeaderFooter+0x24c>)
 80192e0:	68bb      	ldr	r3, [r7, #8]
 80192e2:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_EC_PRIV;
 80192e4:	687b      	ldr	r3, [r7, #4]
 80192e6:	2b00      	cmp	r3, #0
 80192e8:	d002      	beq.n	80192f0 <wc_PemGetHeaderFooter+0x15c>
 80192ea:	4a3e      	ldr	r2, [pc, #248]	@ (80193e4 <wc_PemGetHeaderFooter+0x250>)
 80192ec:	687b      	ldr	r3, [r7, #4]
 80192ee:	601a      	str	r2, [r3, #0]
            ret = 0;
 80192f0:	2300      	movs	r3, #0
 80192f2:	617b      	str	r3, [r7, #20]
            break;
 80192f4:	e05d      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>
    #ifdef OPENSSL_EXTRA
        case ECC_PARAM_TYPE:
            if (header) *header = BEGIN_EC_PARAM;
 80192f6:	68bb      	ldr	r3, [r7, #8]
 80192f8:	2b00      	cmp	r3, #0
 80192fa:	d002      	beq.n	8019302 <wc_PemGetHeaderFooter+0x16e>
 80192fc:	4a3a      	ldr	r2, [pc, #232]	@ (80193e8 <wc_PemGetHeaderFooter+0x254>)
 80192fe:	68bb      	ldr	r3, [r7, #8]
 8019300:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_EC_PARAM;
 8019302:	687b      	ldr	r3, [r7, #4]
 8019304:	2b00      	cmp	r3, #0
 8019306:	d002      	beq.n	801930e <wc_PemGetHeaderFooter+0x17a>
 8019308:	4a38      	ldr	r2, [pc, #224]	@ (80193ec <wc_PemGetHeaderFooter+0x258>)
 801930a:	687b      	ldr	r3, [r7, #4]
 801930c:	601a      	str	r2, [r3, #0]
            ret = 0;
 801930e:	2300      	movs	r3, #0
 8019310:	617b      	str	r3, [r7, #20]
            break;
 8019312:	e04e      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>
        case RSA_TYPE:
        case PRIVATEKEY_TYPE:
    #ifdef WOLFSSL_DUAL_ALG_CERTS
        case ALT_PRIVATEKEY_TYPE:
    #endif
            if (header) *header = BEGIN_RSA_PRIV;
 8019314:	68bb      	ldr	r3, [r7, #8]
 8019316:	2b00      	cmp	r3, #0
 8019318:	d002      	beq.n	8019320 <wc_PemGetHeaderFooter+0x18c>
 801931a:	4a35      	ldr	r2, [pc, #212]	@ (80193f0 <wc_PemGetHeaderFooter+0x25c>)
 801931c:	68bb      	ldr	r3, [r7, #8]
 801931e:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_RSA_PRIV;
 8019320:	687b      	ldr	r3, [r7, #4]
 8019322:	2b00      	cmp	r3, #0
 8019324:	d002      	beq.n	801932c <wc_PemGetHeaderFooter+0x198>
 8019326:	4a33      	ldr	r2, [pc, #204]	@ (80193f4 <wc_PemGetHeaderFooter+0x260>)
 8019328:	687b      	ldr	r3, [r7, #4]
 801932a:	601a      	str	r2, [r3, #0]
            ret = 0;
 801932c:	2300      	movs	r3, #0
 801932e:	617b      	str	r3, [r7, #20]
            break;
 8019330:	e03f      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>
            ret = 0;
            break;
#endif /* HAVE_SPHINCS */
        case PUBLICKEY_TYPE:
        case ECC_PUBLICKEY_TYPE:
            if (header) *header = BEGIN_PUB_KEY;
 8019332:	68bb      	ldr	r3, [r7, #8]
 8019334:	2b00      	cmp	r3, #0
 8019336:	d002      	beq.n	801933e <wc_PemGetHeaderFooter+0x1aa>
 8019338:	4a2f      	ldr	r2, [pc, #188]	@ (80193f8 <wc_PemGetHeaderFooter+0x264>)
 801933a:	68bb      	ldr	r3, [r7, #8]
 801933c:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_PUB_KEY;
 801933e:	687b      	ldr	r3, [r7, #4]
 8019340:	2b00      	cmp	r3, #0
 8019342:	d002      	beq.n	801934a <wc_PemGetHeaderFooter+0x1b6>
 8019344:	4a2d      	ldr	r2, [pc, #180]	@ (80193fc <wc_PemGetHeaderFooter+0x268>)
 8019346:	687b      	ldr	r3, [r7, #4]
 8019348:	601a      	str	r2, [r3, #0]
            ret = 0;
 801934a:	2300      	movs	r3, #0
 801934c:	617b      	str	r3, [r7, #20]
            break;
 801934e:	e030      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>
        case RSA_PUBLICKEY_TYPE:
            if (header) *header = BEGIN_RSA_PUB;
 8019350:	68bb      	ldr	r3, [r7, #8]
 8019352:	2b00      	cmp	r3, #0
 8019354:	d002      	beq.n	801935c <wc_PemGetHeaderFooter+0x1c8>
 8019356:	4a2a      	ldr	r2, [pc, #168]	@ (8019400 <wc_PemGetHeaderFooter+0x26c>)
 8019358:	68bb      	ldr	r3, [r7, #8]
 801935a:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_RSA_PUB;
 801935c:	687b      	ldr	r3, [r7, #4]
 801935e:	2b00      	cmp	r3, #0
 8019360:	d002      	beq.n	8019368 <wc_PemGetHeaderFooter+0x1d4>
 8019362:	4a28      	ldr	r2, [pc, #160]	@ (8019404 <wc_PemGetHeaderFooter+0x270>)
 8019364:	687b      	ldr	r3, [r7, #4]
 8019366:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019368:	2300      	movs	r3, #0
 801936a:	617b      	str	r3, [r7, #20]
            break;
 801936c:	e021      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>
    #ifndef NO_DH
        case DH_PRIVATEKEY_TYPE:
    #endif
        case PKCS8_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_PRIV_KEY;
 801936e:	68bb      	ldr	r3, [r7, #8]
 8019370:	2b00      	cmp	r3, #0
 8019372:	d002      	beq.n	801937a <wc_PemGetHeaderFooter+0x1e6>
 8019374:	4a24      	ldr	r2, [pc, #144]	@ (8019408 <wc_PemGetHeaderFooter+0x274>)
 8019376:	68bb      	ldr	r3, [r7, #8]
 8019378:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_PRIV_KEY;
 801937a:	687b      	ldr	r3, [r7, #4]
 801937c:	2b00      	cmp	r3, #0
 801937e:	d002      	beq.n	8019386 <wc_PemGetHeaderFooter+0x1f2>
 8019380:	4a22      	ldr	r2, [pc, #136]	@ (801940c <wc_PemGetHeaderFooter+0x278>)
 8019382:	687b      	ldr	r3, [r7, #4]
 8019384:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019386:	2300      	movs	r3, #0
 8019388:	617b      	str	r3, [r7, #20]
            break;
 801938a:	e012      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>
        case PKCS8_ENC_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_ENC_PRIV_KEY;
 801938c:	68bb      	ldr	r3, [r7, #8]
 801938e:	2b00      	cmp	r3, #0
 8019390:	d002      	beq.n	8019398 <wc_PemGetHeaderFooter+0x204>
 8019392:	4a1f      	ldr	r2, [pc, #124]	@ (8019410 <wc_PemGetHeaderFooter+0x27c>)
 8019394:	68bb      	ldr	r3, [r7, #8]
 8019396:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_ENC_PRIV_KEY;
 8019398:	687b      	ldr	r3, [r7, #4]
 801939a:	2b00      	cmp	r3, #0
 801939c:	d002      	beq.n	80193a4 <wc_PemGetHeaderFooter+0x210>
 801939e:	4a1d      	ldr	r2, [pc, #116]	@ (8019414 <wc_PemGetHeaderFooter+0x280>)
 80193a0:	687b      	ldr	r3, [r7, #4]
 80193a2:	601a      	str	r2, [r3, #0]
            ret = 0;
 80193a4:	2300      	movs	r3, #0
 80193a6:	617b      	str	r3, [r7, #20]
            break;
 80193a8:	e003      	b.n	80193b2 <wc_PemGetHeaderFooter+0x21e>
        default:
            ret = BAD_FUNC_ARG;
 80193aa:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80193ae:	617b      	str	r3, [r7, #20]
            break;
 80193b0:	bf00      	nop
    }
    return ret;
 80193b2:	697b      	ldr	r3, [r7, #20]
}
 80193b4:	4618      	mov	r0, r3
 80193b6:	371c      	adds	r7, #28
 80193b8:	46bd      	mov	sp, r7
 80193ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80193be:	4770      	bx	lr
 80193c0:	08030668 	.word	0x08030668
 80193c4:	08030684 	.word	0x08030684
 80193c8:	08030724 	.word	0x08030724
 80193cc:	08030740 	.word	0x08030740
 80193d0:	080306a0 	.word	0x080306a0
 80193d4:	080306c0 	.word	0x080306c0
 80193d8:	080306dc 	.word	0x080306dc
 80193dc:	08030700 	.word	0x08030700
 80193e0:	0803085c 	.word	0x0803085c
 80193e4:	0803087c 	.word	0x0803087c
 80193e8:	0803089c 	.word	0x0803089c
 80193ec:	080308bc 	.word	0x080308bc
 80193f0:	08030758 	.word	0x08030758
 80193f4:	08030778 	.word	0x08030778
 80193f8:	08030918 	.word	0x08030918
 80193fc:	08030934 	.word	0x08030934
 8019400:	08030798 	.word	0x08030798
 8019404:	080307b8 	.word	0x080307b8
 8019408:	080307d8 	.word	0x080307d8
 801940c:	080307f4 	.word	0x080307f4
 8019410:	08030810 	.word	0x08030810
 8019414:	08030838 	.word	0x08030838

08019418 <wc_EncryptedInfoGet>:
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_256)
    static wcchar kEncTypeAesCbc256 = "AES-256-CBC";
#endif

int wc_EncryptedInfoGet(EncryptedInfo* info, const char* cipherInfo)
{
 8019418:	b580      	push	{r7, lr}
 801941a:	b084      	sub	sp, #16
 801941c:	af00      	add	r7, sp, #0
 801941e:	6078      	str	r0, [r7, #4]
 8019420:	6039      	str	r1, [r7, #0]
    int ret = 0;
 8019422:	2300      	movs	r3, #0
 8019424:	60fb      	str	r3, [r7, #12]

    if (info == NULL || cipherInfo == NULL)
 8019426:	687b      	ldr	r3, [r7, #4]
 8019428:	2b00      	cmp	r3, #0
 801942a:	d002      	beq.n	8019432 <wc_EncryptedInfoGet+0x1a>
 801942c:	683b      	ldr	r3, [r7, #0]
 801942e:	2b00      	cmp	r3, #0
 8019430:	d102      	bne.n	8019438 <wc_EncryptedInfoGet+0x20>
        return BAD_FUNC_ARG;
 8019432:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8019436:	e045      	b.n	80194c4 <wc_EncryptedInfoGet+0xac>
#endif
    }
    else
#endif /* !NO_DES3 */
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_128)
    if (XSTRCMP(cipherInfo, kEncTypeAesCbc128) == 0) {
 8019438:	4b24      	ldr	r3, [pc, #144]	@ (80194cc <wc_EncryptedInfoGet+0xb4>)
 801943a:	4619      	mov	r1, r3
 801943c:	6838      	ldr	r0, [r7, #0]
 801943e:	f7e6 fec7 	bl	80001d0 <strcmp>
 8019442:	4603      	mov	r3, r0
 8019444:	2b00      	cmp	r3, #0
 8019446:	d10d      	bne.n	8019464 <wc_EncryptedInfoGet+0x4c>
        info->cipherType = WC_CIPHER_AES_CBC;
 8019448:	687b      	ldr	r3, [r7, #4]
 801944a:	2202      	movs	r2, #2
 801944c:	60da      	str	r2, [r3, #12]
        info->keySz = AES_128_KEY_SIZE;
 801944e:	687b      	ldr	r3, [r7, #4]
 8019450:	2210      	movs	r2, #16
 8019452:	611a      	str	r2, [r3, #16]
        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;
 8019454:	687b      	ldr	r3, [r7, #4]
 8019456:	695b      	ldr	r3, [r3, #20]
 8019458:	2b00      	cmp	r3, #0
 801945a:	d132      	bne.n	80194c2 <wc_EncryptedInfoGet+0xaa>
 801945c:	687b      	ldr	r3, [r7, #4]
 801945e:	2210      	movs	r2, #16
 8019460:	615a      	str	r2, [r3, #20]
 8019462:	e02e      	b.n	80194c2 <wc_EncryptedInfoGet+0xaa>
    }
    else
#endif
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_192)
    if (XSTRCMP(cipherInfo, kEncTypeAesCbc192) == 0) {
 8019464:	4b1a      	ldr	r3, [pc, #104]	@ (80194d0 <wc_EncryptedInfoGet+0xb8>)
 8019466:	4619      	mov	r1, r3
 8019468:	6838      	ldr	r0, [r7, #0]
 801946a:	f7e6 feb1 	bl	80001d0 <strcmp>
 801946e:	4603      	mov	r3, r0
 8019470:	2b00      	cmp	r3, #0
 8019472:	d10d      	bne.n	8019490 <wc_EncryptedInfoGet+0x78>
        info->cipherType = WC_CIPHER_AES_CBC;
 8019474:	687b      	ldr	r3, [r7, #4]
 8019476:	2202      	movs	r2, #2
 8019478:	60da      	str	r2, [r3, #12]
        info->keySz = AES_192_KEY_SIZE;
 801947a:	687b      	ldr	r3, [r7, #4]
 801947c:	2218      	movs	r2, #24
 801947e:	611a      	str	r2, [r3, #16]
        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;
 8019480:	687b      	ldr	r3, [r7, #4]
 8019482:	695b      	ldr	r3, [r3, #20]
 8019484:	2b00      	cmp	r3, #0
 8019486:	d11c      	bne.n	80194c2 <wc_EncryptedInfoGet+0xaa>
 8019488:	687b      	ldr	r3, [r7, #4]
 801948a:	2210      	movs	r2, #16
 801948c:	615a      	str	r2, [r3, #20]
 801948e:	e018      	b.n	80194c2 <wc_EncryptedInfoGet+0xaa>
    }
    else
#endif
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_256)
    if (XSTRCMP(cipherInfo, kEncTypeAesCbc256) == 0) {
 8019490:	4b10      	ldr	r3, [pc, #64]	@ (80194d4 <wc_EncryptedInfoGet+0xbc>)
 8019492:	4619      	mov	r1, r3
 8019494:	6838      	ldr	r0, [r7, #0]
 8019496:	f7e6 fe9b 	bl	80001d0 <strcmp>
 801949a:	4603      	mov	r3, r0
 801949c:	2b00      	cmp	r3, #0
 801949e:	d10d      	bne.n	80194bc <wc_EncryptedInfoGet+0xa4>
        info->cipherType = WC_CIPHER_AES_CBC;
 80194a0:	687b      	ldr	r3, [r7, #4]
 80194a2:	2202      	movs	r2, #2
 80194a4:	60da      	str	r2, [r3, #12]
        info->keySz = AES_256_KEY_SIZE;
 80194a6:	687b      	ldr	r3, [r7, #4]
 80194a8:	2220      	movs	r2, #32
 80194aa:	611a      	str	r2, [r3, #16]
        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;
 80194ac:	687b      	ldr	r3, [r7, #4]
 80194ae:	695b      	ldr	r3, [r3, #20]
 80194b0:	2b00      	cmp	r3, #0
 80194b2:	d106      	bne.n	80194c2 <wc_EncryptedInfoGet+0xaa>
 80194b4:	687b      	ldr	r3, [r7, #4]
 80194b6:	2210      	movs	r2, #16
 80194b8:	615a      	str	r2, [r3, #20]
 80194ba:	e002      	b.n	80194c2 <wc_EncryptedInfoGet+0xaa>
    }
    else
#endif
    {
        ret = NOT_COMPILED_IN;
 80194bc:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 80194c0:	60fb      	str	r3, [r7, #12]
    }
    return ret;
 80194c2:	68fb      	ldr	r3, [r7, #12]
}
 80194c4:	4618      	mov	r0, r3
 80194c6:	3710      	adds	r7, #16
 80194c8:	46bd      	mov	sp, r7
 80194ca:	bd80      	pop	{r7, pc}
 80194cc:	08030968 	.word	0x08030968
 80194d0:	08030974 	.word	0x08030974
 80194d4:	08030980 	.word	0x08030980

080194d8 <wc_EncryptedInfoParse>:

int wc_EncryptedInfoParse(EncryptedInfo* info, const char** pBuffer,
                          size_t bufSz)
{
 80194d8:	b590      	push	{r4, r7, lr}
 80194da:	b08f      	sub	sp, #60	@ 0x3c
 80194dc:	af00      	add	r7, sp, #0
 80194de:	60f8      	str	r0, [r7, #12]
 80194e0:	60b9      	str	r1, [r7, #8]
 80194e2:	607a      	str	r2, [r7, #4]
    int         err = 0;
 80194e4:	2300      	movs	r3, #0
 80194e6:	637b      	str	r3, [r7, #52]	@ 0x34
    const char* bufferStart;
    const char* bufferEnd;
    char*       line;

    if (info == NULL || pBuffer == NULL || bufSz == 0)
 80194e8:	68fb      	ldr	r3, [r7, #12]
 80194ea:	2b00      	cmp	r3, #0
 80194ec:	d005      	beq.n	80194fa <wc_EncryptedInfoParse+0x22>
 80194ee:	68bb      	ldr	r3, [r7, #8]
 80194f0:	2b00      	cmp	r3, #0
 80194f2:	d002      	beq.n	80194fa <wc_EncryptedInfoParse+0x22>
 80194f4:	687b      	ldr	r3, [r7, #4]
 80194f6:	2b00      	cmp	r3, #0
 80194f8:	d102      	bne.n	8019500 <wc_EncryptedInfoParse+0x28>
        return BAD_FUNC_ARG;
 80194fa:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80194fe:	e106      	b.n	801970e <wc_EncryptedInfoParse+0x236>

    bufferStart = *pBuffer;
 8019500:	68bb      	ldr	r3, [r7, #8]
 8019502:	681b      	ldr	r3, [r3, #0]
 8019504:	62bb      	str	r3, [r7, #40]	@ 0x28
    bufferEnd = bufferStart + bufSz;
 8019506:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8019508:	687b      	ldr	r3, [r7, #4]
 801950a:	4413      	add	r3, r2
 801950c:	627b      	str	r3, [r7, #36]	@ 0x24

    /* find encrypted info marker */
    line = XSTRNSTR(bufferStart, kProcTypeHeader,
 801950e:	4c82      	ldr	r4, [pc, #520]	@ (8019718 <wc_EncryptedInfoParse+0x240>)
 8019510:	214c      	movs	r1, #76	@ 0x4c
 8019512:	6878      	ldr	r0, [r7, #4]
 8019514:	f7f9 f98e 	bl	8012834 <min>
 8019518:	4603      	mov	r3, r0
 801951a:	461a      	mov	r2, r3
 801951c:	4621      	mov	r1, r4
 801951e:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8019520:	f00e f8fc 	bl	802771c <mystrnstr>
 8019524:	6238      	str	r0, [r7, #32]
                    min((word32)bufSz, PEM_LINE_LEN));
    if (line != NULL) {
 8019526:	6a3b      	ldr	r3, [r7, #32]
 8019528:	2b00      	cmp	r3, #0
 801952a:	f000 80ef 	beq.w	801970c <wc_EncryptedInfoParse+0x234>
        word32      lineSz;
        char*       finish;
        char*       start;
        word32      startSz;
        const char* newline = NULL;
 801952e:	2300      	movs	r3, #0
 8019530:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if (line >= bufferEnd) {
 8019532:	6a3a      	ldr	r2, [r7, #32]
 8019534:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019536:	429a      	cmp	r2, r3
 8019538:	d302      	bcc.n	8019540 <wc_EncryptedInfoParse+0x68>
            return BUFFER_E;
 801953a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801953e:	e0e6      	b.n	801970e <wc_EncryptedInfoParse+0x236>
        }

        lineSz = (word32)(bufferEnd - line);
 8019540:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8019542:	6a3b      	ldr	r3, [r7, #32]
 8019544:	1ad3      	subs	r3, r2, r3
 8019546:	61fb      	str	r3, [r7, #28]

        /* find DEC-Info marker */
        start = XSTRNSTR(line, kDecInfoHeader, min(lineSz, PEM_LINE_LEN));
 8019548:	4c74      	ldr	r4, [pc, #464]	@ (801971c <wc_EncryptedInfoParse+0x244>)
 801954a:	214c      	movs	r1, #76	@ 0x4c
 801954c:	69f8      	ldr	r0, [r7, #28]
 801954e:	f7f9 f971 	bl	8012834 <min>
 8019552:	4603      	mov	r3, r0
 8019554:	461a      	mov	r2, r3
 8019556:	4621      	mov	r1, r4
 8019558:	6a38      	ldr	r0, [r7, #32]
 801955a:	f00e f8df 	bl	802771c <mystrnstr>
 801955e:	6338      	str	r0, [r7, #48]	@ 0x30

        if (start == NULL)
 8019560:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019562:	2b00      	cmp	r3, #0
 8019564:	d102      	bne.n	801956c <wc_EncryptedInfoParse+0x94>
            return BUFFER_E;
 8019566:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801956a:	e0d0      	b.n	801970e <wc_EncryptedInfoParse+0x236>

        /* skip dec-info and ": " */
        start += XSTRLEN(kDecInfoHeader);
 801956c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801956e:	3308      	adds	r3, #8
 8019570:	633b      	str	r3, [r7, #48]	@ 0x30
        if (start >= bufferEnd)
 8019572:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8019574:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019576:	429a      	cmp	r2, r3
 8019578:	d302      	bcc.n	8019580 <wc_EncryptedInfoParse+0xa8>
            return BUFFER_E;
 801957a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801957e:	e0c6      	b.n	801970e <wc_EncryptedInfoParse+0x236>

        if (start[0] == ':') {
 8019580:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019582:	781b      	ldrb	r3, [r3, #0]
 8019584:	2b3a      	cmp	r3, #58	@ 0x3a
 8019586:	d109      	bne.n	801959c <wc_EncryptedInfoParse+0xc4>
            start++;
 8019588:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801958a:	3301      	adds	r3, #1
 801958c:	633b      	str	r3, [r7, #48]	@ 0x30
            if (start >= bufferEnd)
 801958e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8019590:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019592:	429a      	cmp	r2, r3
 8019594:	d302      	bcc.n	801959c <wc_EncryptedInfoParse+0xc4>
                return BUFFER_E;
 8019596:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801959a:	e0b8      	b.n	801970e <wc_EncryptedInfoParse+0x236>
        }
        if (start[0] == ' ')
 801959c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801959e:	781b      	ldrb	r3, [r3, #0]
 80195a0:	2b20      	cmp	r3, #32
 80195a2:	d102      	bne.n	80195aa <wc_EncryptedInfoParse+0xd2>
            start++;
 80195a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80195a6:	3301      	adds	r3, #1
 80195a8:	633b      	str	r3, [r7, #48]	@ 0x30

        startSz = (word32)(bufferEnd - start);
 80195aa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80195ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80195ae:	1ad3      	subs	r3, r2, r3
 80195b0:	61bb      	str	r3, [r7, #24]
        finish = XSTRNSTR(start, ",", min(startSz, PEM_LINE_LEN));
 80195b2:	214c      	movs	r1, #76	@ 0x4c
 80195b4:	69b8      	ldr	r0, [r7, #24]
 80195b6:	f7f9 f93d 	bl	8012834 <min>
 80195ba:	4603      	mov	r3, r0
 80195bc:	461a      	mov	r2, r3
 80195be:	4958      	ldr	r1, [pc, #352]	@ (8019720 <wc_EncryptedInfoParse+0x248>)
 80195c0:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80195c2:	f00e f8ab 	bl	802771c <mystrnstr>
 80195c6:	6178      	str	r0, [r7, #20]

        if ((start != NULL) && (finish != NULL) && (start < finish)) {
 80195c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80195ca:	2b00      	cmp	r3, #0
 80195cc:	f000 809b 	beq.w	8019706 <wc_EncryptedInfoParse+0x22e>
 80195d0:	697b      	ldr	r3, [r7, #20]
 80195d2:	2b00      	cmp	r3, #0
 80195d4:	f000 8097 	beq.w	8019706 <wc_EncryptedInfoParse+0x22e>
 80195d8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80195da:	697b      	ldr	r3, [r7, #20]
 80195dc:	429a      	cmp	r2, r3
 80195de:	f080 8092 	bcs.w	8019706 <wc_EncryptedInfoParse+0x22e>
            word32 finishSz;

            if (finish >= bufferEnd) {
 80195e2:	697a      	ldr	r2, [r7, #20]
 80195e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80195e6:	429a      	cmp	r2, r3
 80195e8:	d302      	bcc.n	80195f0 <wc_EncryptedInfoParse+0x118>
                return BUFFER_E;
 80195ea:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80195ee:	e08e      	b.n	801970e <wc_EncryptedInfoParse+0x236>
            }

            finishSz = (word32)(bufferEnd - finish);
 80195f0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80195f2:	697b      	ldr	r3, [r7, #20]
 80195f4:	1ad3      	subs	r3, r2, r3
 80195f6:	613b      	str	r3, [r7, #16]
            newline = XSTRNSTR(finish, "\r", min(finishSz, PEM_LINE_LEN));
 80195f8:	214c      	movs	r1, #76	@ 0x4c
 80195fa:	6938      	ldr	r0, [r7, #16]
 80195fc:	f7f9 f91a 	bl	8012834 <min>
 8019600:	4603      	mov	r3, r0
 8019602:	461a      	mov	r2, r3
 8019604:	4947      	ldr	r1, [pc, #284]	@ (8019724 <wc_EncryptedInfoParse+0x24c>)
 8019606:	6978      	ldr	r0, [r7, #20]
 8019608:	f00e f888 	bl	802771c <mystrnstr>
 801960c:	62f8      	str	r0, [r7, #44]	@ 0x2c

            /* get cipher name */
            if (NAME_SZ < (finish - start)) /* buffer size of info->name */
 801960e:	697a      	ldr	r2, [r7, #20]
 8019610:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019612:	1ad3      	subs	r3, r2, r3
 8019614:	2b50      	cmp	r3, #80	@ 0x50
 8019616:	dd02      	ble.n	801961e <wc_EncryptedInfoParse+0x146>
                return BUFFER_E;
 8019618:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801961c:	e077      	b.n	801970e <wc_EncryptedInfoParse+0x236>
            if (XMEMCPY(info->name, start, (size_t)(finish - start)) == NULL)
 801961e:	68fb      	ldr	r3, [r7, #12]
 8019620:	f103 0018 	add.w	r0, r3, #24
 8019624:	697a      	ldr	r2, [r7, #20]
 8019626:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019628:	1ad3      	subs	r3, r2, r3
 801962a:	461a      	mov	r2, r3
 801962c:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 801962e:	f00f fbaa 	bl	8028d86 <memcpy>
 8019632:	4603      	mov	r3, r0
 8019634:	2b00      	cmp	r3, #0
 8019636:	d102      	bne.n	801963e <wc_EncryptedInfoParse+0x166>
                return BUFFER_E;
 8019638:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801963c:	e067      	b.n	801970e <wc_EncryptedInfoParse+0x236>
            info->name[finish - start] = '\0'; /* null term */
 801963e:	697a      	ldr	r2, [r7, #20]
 8019640:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019642:	1ad3      	subs	r3, r2, r3
 8019644:	68fa      	ldr	r2, [r7, #12]
 8019646:	4413      	add	r3, r2
 8019648:	2200      	movs	r2, #0
 801964a:	761a      	strb	r2, [r3, #24]

            /* populate info */
            err = wc_EncryptedInfoGet(info, info->name);
 801964c:	68fb      	ldr	r3, [r7, #12]
 801964e:	3318      	adds	r3, #24
 8019650:	4619      	mov	r1, r3
 8019652:	68f8      	ldr	r0, [r7, #12]
 8019654:	f7ff fee0 	bl	8019418 <wc_EncryptedInfoGet>
 8019658:	6378      	str	r0, [r7, #52]	@ 0x34
            if (err != 0)
 801965a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801965c:	2b00      	cmp	r3, #0
 801965e:	d001      	beq.n	8019664 <wc_EncryptedInfoParse+0x18c>
                return err;
 8019660:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8019662:	e054      	b.n	801970e <wc_EncryptedInfoParse+0x236>

            /* get IV */
            if (finishSz < info->ivSz + 1)
 8019664:	68fb      	ldr	r3, [r7, #12]
 8019666:	695b      	ldr	r3, [r3, #20]
 8019668:	3301      	adds	r3, #1
 801966a:	693a      	ldr	r2, [r7, #16]
 801966c:	429a      	cmp	r2, r3
 801966e:	d202      	bcs.n	8019676 <wc_EncryptedInfoParse+0x19e>
                return BUFFER_E;
 8019670:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019674:	e04b      	b.n	801970e <wc_EncryptedInfoParse+0x236>

            if (newline == NULL) {
 8019676:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019678:	2b00      	cmp	r3, #0
 801967a:	d10a      	bne.n	8019692 <wc_EncryptedInfoParse+0x1ba>
                newline = XSTRNSTR(finish, "\n", min(finishSz,
 801967c:	214c      	movs	r1, #76	@ 0x4c
 801967e:	6938      	ldr	r0, [r7, #16]
 8019680:	f7f9 f8d8 	bl	8012834 <min>
 8019684:	4603      	mov	r3, r0
 8019686:	461a      	mov	r2, r3
 8019688:	4927      	ldr	r1, [pc, #156]	@ (8019728 <wc_EncryptedInfoParse+0x250>)
 801968a:	6978      	ldr	r0, [r7, #20]
 801968c:	f00e f846 	bl	802771c <mystrnstr>
 8019690:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                                     PEM_LINE_LEN));
            }
            if ((newline != NULL) && (newline > finish)) {
 8019692:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019694:	2b00      	cmp	r3, #0
 8019696:	d033      	beq.n	8019700 <wc_EncryptedInfoParse+0x228>
 8019698:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801969a:	697b      	ldr	r3, [r7, #20]
 801969c:	429a      	cmp	r2, r3
 801969e:	d92f      	bls.n	8019700 <wc_EncryptedInfoParse+0x228>
                finish++;
 80196a0:	697b      	ldr	r3, [r7, #20]
 80196a2:	3301      	adds	r3, #1
 80196a4:	617b      	str	r3, [r7, #20]
                info->ivSz = (word32)(newline - finish);
 80196a6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80196a8:	697b      	ldr	r3, [r7, #20]
 80196aa:	1ad3      	subs	r3, r2, r3
 80196ac:	461a      	mov	r2, r3
 80196ae:	68fb      	ldr	r3, [r7, #12]
 80196b0:	615a      	str	r2, [r3, #20]
                if (info->ivSz > IV_SZ)
 80196b2:	68fb      	ldr	r3, [r7, #12]
 80196b4:	695b      	ldr	r3, [r3, #20]
 80196b6:	2b20      	cmp	r3, #32
 80196b8:	d902      	bls.n	80196c0 <wc_EncryptedInfoParse+0x1e8>
                    return BUFFER_E;
 80196ba:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80196be:	e026      	b.n	801970e <wc_EncryptedInfoParse+0x236>
                if (XMEMCPY(info->iv, finish, info->ivSz) == NULL)
 80196c0:	68fb      	ldr	r3, [r7, #12]
 80196c2:	f103 0068 	add.w	r0, r3, #104	@ 0x68
 80196c6:	68fb      	ldr	r3, [r7, #12]
 80196c8:	695b      	ldr	r3, [r3, #20]
 80196ca:	461a      	mov	r2, r3
 80196cc:	6979      	ldr	r1, [r7, #20]
 80196ce:	f00f fb5a 	bl	8028d86 <memcpy>
 80196d2:	4603      	mov	r3, r0
 80196d4:	2b00      	cmp	r3, #0
 80196d6:	d102      	bne.n	80196de <wc_EncryptedInfoParse+0x206>
                    return BUFFER_E;
 80196d8:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80196dc:	e017      	b.n	801970e <wc_EncryptedInfoParse+0x236>
                info->set = 1;
 80196de:	68fa      	ldr	r2, [r7, #12]
 80196e0:	f892 3088 	ldrb.w	r3, [r2, #136]	@ 0x88
 80196e4:	f043 0301 	orr.w	r3, r3, #1
 80196e8:	f882 3088 	strb.w	r3, [r2, #136]	@ 0x88
        if ((start != NULL) && (finish != NULL) && (start < finish)) {
 80196ec:	bf00      	nop
        }
        else
            return BUFFER_E;

        /* eat end of line characters */
        newline = SkipEndOfLineChars(newline, bufferEnd);
 80196ee:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80196f0:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80196f2:	f7ff fd32 	bl	801915a <SkipEndOfLineChars>
 80196f6:	62f8      	str	r0, [r7, #44]	@ 0x2c

        /* return new headerEnd */

        *pBuffer = newline;
 80196f8:	68bb      	ldr	r3, [r7, #8]
 80196fa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80196fc:	601a      	str	r2, [r3, #0]
 80196fe:	e005      	b.n	801970c <wc_EncryptedInfoParse+0x234>
                return BUFFER_E;
 8019700:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019704:	e003      	b.n	801970e <wc_EncryptedInfoParse+0x236>
            return BUFFER_E;
 8019706:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801970a:	e000      	b.n	801970e <wc_EncryptedInfoParse+0x236>
    }

    return err;
 801970c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 801970e:	4618      	mov	r0, r3
 8019710:	373c      	adds	r7, #60	@ 0x3c
 8019712:	46bd      	mov	sp, r7
 8019714:	bd90      	pop	{r4, r7, pc}
 8019716:	bf00      	nop
 8019718:	08030950 	.word	0x08030950
 801971c:	0803095c 	.word	0x0803095c
 8019720:	0803098c 	.word	0x0803098c
 8019724:	08030990 	.word	0x08030990
 8019728:	08030994 	.word	0x08030994

0801972c <PemToDer>:

/* Remove PEM header/footer, convert to ASN1, store any encrypted data
   info->consumed tracks of PEM bytes consumed in case multiple parts */
int PemToDer(const unsigned char* buff, long longSz, int type,
              DerBuffer** pDer, void* heap, EncryptedInfo* info, int* keyFormat)
{
 801972c:	b590      	push	{r4, r7, lr}
 801972e:	b0c3      	sub	sp, #268	@ 0x10c
 8019730:	af02      	add	r7, sp, #8
 8019732:	60f8      	str	r0, [r7, #12]
 8019734:	60b9      	str	r1, [r7, #8]
 8019736:	607a      	str	r2, [r7, #4]
 8019738:	f507 7280 	add.w	r2, r7, #256	@ 0x100
 801973c:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 8019740:	6013      	str	r3, [r2, #0]
    const char* header      = NULL;
 8019742:	2300      	movs	r3, #0
 8019744:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    const char* footer      = NULL;
 8019748:	2300      	movs	r3, #0
 801974a:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    const char* headerEnd   = NULL;
 801974e:	2300      	movs	r3, #0
 8019750:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    const char* footerEnd   = NULL;
 8019754:	2300      	movs	r3, #0
 8019756:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    const char* consumedEnd = NULL;
 801975a:	2300      	movs	r3, #0
 801975c:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    const char* bufferEnd   = (const char*)(buff + longSz);
 8019760:	68bb      	ldr	r3, [r7, #8]
 8019762:	68fa      	ldr	r2, [r7, #12]
 8019764:	4413      	add	r3, r2
 8019766:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    long        neededSz;
    int         ret         = 0;
 801976a:	2300      	movs	r3, #0
 801976c:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    word32      sz          = (word32)longSz;
 8019770:	68bb      	ldr	r3, [r7, #8]
 8019772:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    int         encrypted_key = 0;
 8019776:	2300      	movs	r3, #0
 8019778:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    DerBuffer*  der;
    word32      algId = 0;
 801977c:	2300      	movs	r3, #0
 801977e:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
#endif

    WOLFSSL_ENTER("PemToDer");

    /* get PEM header and footer based on type */
    ret = wc_PemGetHeaderFooter(type, &header, &footer);
 8019782:	f107 02c0 	add.w	r2, r7, #192	@ 0xc0
 8019786:	f107 03c4 	add.w	r3, r7, #196	@ 0xc4
 801978a:	4619      	mov	r1, r3
 801978c:	6878      	ldr	r0, [r7, #4]
 801978e:	f7ff fd01 	bl	8019194 <wc_PemGetHeaderFooter>
 8019792:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
    if (ret != 0)
 8019796:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801979a:	2b00      	cmp	r3, #0
 801979c:	d002      	beq.n	80197a4 <PemToDer+0x78>
        return ret;
 801979e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80197a2:	e36c      	b.n	8019e7e <PemToDer+0x752>

    /* map header if not found for type */
    for (;;) {
        headerEnd = XSTRNSTR((char*)buff, header, sz);
 80197a4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80197a8:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 80197ac:	4619      	mov	r1, r3
 80197ae:	68f8      	ldr	r0, [r7, #12]
 80197b0:	f00d ffb4 	bl	802771c <mystrnstr>
 80197b4:	4603      	mov	r3, r0
 80197b6:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
        if (headerEnd) {
 80197ba:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80197be:	2b00      	cmp	r3, #0
 80197c0:	d150      	bne.n	8019864 <PemToDer+0x138>
            break;
        }

        if (type == PRIVATEKEY_TYPE
 80197c2:	687b      	ldr	r3, [r7, #4]
 80197c4:	2b01      	cmp	r3, #1
 80197c6:	d12f      	bne.n	8019828 <PemToDer+0xfc>
#ifdef WOLFSSL_DUAL_ALG_CERTS
            || type == ALT_PRIVATEKEY_TYPE
#endif
           ) {
            if (header == BEGIN_RSA_PRIV) {
 80197c8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80197cc:	4aa1      	ldr	r2, [pc, #644]	@ (8019a54 <PemToDer+0x328>)
 80197ce:	4293      	cmp	r3, r2
 80197d0:	d106      	bne.n	80197e0 <PemToDer+0xb4>
                header = BEGIN_PRIV_KEY;
 80197d2:	4ba1      	ldr	r3, [pc, #644]	@ (8019a58 <PemToDer+0x32c>)
 80197d4:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_PRIV_KEY;
 80197d8:	4ba0      	ldr	r3, [pc, #640]	@ (8019a5c <PemToDer+0x330>)
 80197da:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80197de:	e7e1      	b.n	80197a4 <PemToDer+0x78>
            }
            else if (header == BEGIN_PRIV_KEY) {
 80197e0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80197e4:	4a9c      	ldr	r2, [pc, #624]	@ (8019a58 <PemToDer+0x32c>)
 80197e6:	4293      	cmp	r3, r2
 80197e8:	d106      	bne.n	80197f8 <PemToDer+0xcc>
                header = BEGIN_ENC_PRIV_KEY;
 80197ea:	4b9d      	ldr	r3, [pc, #628]	@ (8019a60 <PemToDer+0x334>)
 80197ec:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_ENC_PRIV_KEY;
 80197f0:	4b9c      	ldr	r3, [pc, #624]	@ (8019a64 <PemToDer+0x338>)
 80197f2:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80197f6:	e7d5      	b.n	80197a4 <PemToDer+0x78>
            }
#ifdef HAVE_ECC
            else if (header == BEGIN_ENC_PRIV_KEY) {
 80197f8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80197fc:	4a98      	ldr	r2, [pc, #608]	@ (8019a60 <PemToDer+0x334>)
 80197fe:	4293      	cmp	r3, r2
 8019800:	d106      	bne.n	8019810 <PemToDer+0xe4>
                header = BEGIN_EC_PRIV;
 8019802:	4b99      	ldr	r3, [pc, #612]	@ (8019a68 <PemToDer+0x33c>)
 8019804:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_EC_PRIV;
 8019808:	4b98      	ldr	r3, [pc, #608]	@ (8019a6c <PemToDer+0x340>)
 801980a:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 801980e:	e7c9      	b.n	80197a4 <PemToDer+0x78>
            }
            else if (header == BEGIN_EC_PRIV) {
 8019810:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019814:	4a94      	ldr	r2, [pc, #592]	@ (8019a68 <PemToDer+0x33c>)
 8019816:	4293      	cmp	r3, r2
 8019818:	d126      	bne.n	8019868 <PemToDer+0x13c>
                header = BEGIN_DSA_PRIV;
 801981a:	4b95      	ldr	r3, [pc, #596]	@ (8019a70 <PemToDer+0x344>)
 801981c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_DSA_PRIV;
 8019820:	4b94      	ldr	r3, [pc, #592]	@ (8019a74 <PemToDer+0x348>)
 8019822:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8019826:	e7bd      	b.n	80197a4 <PemToDer+0x78>
            #else
                break;
            #endif
            }
        }
        else if (type == PUBLICKEY_TYPE) {
 8019828:	687b      	ldr	r3, [r7, #4]
 801982a:	2b0e      	cmp	r3, #14
 801982c:	d10b      	bne.n	8019846 <PemToDer+0x11a>
            if (header == BEGIN_PUB_KEY) {
 801982e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019832:	4a91      	ldr	r2, [pc, #580]	@ (8019a78 <PemToDer+0x34c>)
 8019834:	4293      	cmp	r3, r2
 8019836:	d119      	bne.n	801986c <PemToDer+0x140>
                header = BEGIN_RSA_PUB;
 8019838:	4b90      	ldr	r3, [pc, #576]	@ (8019a7c <PemToDer+0x350>)
 801983a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_RSA_PUB;
 801983e:	4b90      	ldr	r3, [pc, #576]	@ (8019a80 <PemToDer+0x354>)
 8019840:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8019844:	e7ae      	b.n	80197a4 <PemToDer+0x78>
            else {
                break;
            }
        }
#if defined(HAVE_ECC) && defined(OPENSSL_EXTRA)
        else if (type == ECC_PARAM_TYPE) {
 8019846:	687b      	ldr	r3, [r7, #4]
 8019848:	2b29      	cmp	r3, #41	@ 0x29
 801984a:	d111      	bne.n	8019870 <PemToDer+0x144>
            if (header == BEGIN_EC_PARAM) {
 801984c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019850:	4a8c      	ldr	r2, [pc, #560]	@ (8019a84 <PemToDer+0x358>)
 8019852:	4293      	cmp	r3, r2
 8019854:	d10e      	bne.n	8019874 <PemToDer+0x148>
                header = BEGIN_EC_PARAM;
 8019856:	4b8b      	ldr	r3, [pc, #556]	@ (8019a84 <PemToDer+0x358>)
 8019858:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_EC_PARAM;
 801985c:	4b8a      	ldr	r3, [pc, #552]	@ (8019a88 <PemToDer+0x35c>)
 801985e:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
        headerEnd = XSTRNSTR((char*)buff, header, sz);
 8019862:	e79f      	b.n	80197a4 <PemToDer+0x78>
            break;
 8019864:	bf00      	nop
 8019866:	e006      	b.n	8019876 <PemToDer+0x14a>
                break;
 8019868:	bf00      	nop
 801986a:	e004      	b.n	8019876 <PemToDer+0x14a>
                break;
 801986c:	bf00      	nop
 801986e:	e002      	b.n	8019876 <PemToDer+0x14a>
            header =  BEGIN_X509_CRL;
            footer = END_X509_CRL;
        }
#endif
        else {
            break;
 8019870:	bf00      	nop
 8019872:	e000      	b.n	8019876 <PemToDer+0x14a>
                break;
 8019874:	bf00      	nop
        }
    }

    if (!headerEnd) {
 8019876:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801987a:	2b00      	cmp	r3, #0
 801987c:	f040 8110 	bne.w	8019aa0 <PemToDer+0x374>
#ifdef OPENSSL_EXTRA
        if (type == PRIVATEKEY_TYPE
 8019880:	687b      	ldr	r3, [r7, #4]
 8019882:	2b01      	cmp	r3, #1
 8019884:	f040 80d4 	bne.w	8019a30 <PemToDer+0x304>
#ifdef WOLFSSL_DUAL_ALG_CERTS
            || type == ALT_PRIVATEKEY_TYPE
#endif
           ) {
            /* see if there is a -----BEGIN * PRIVATE KEY----- header */
            headerEnd = XSTRNSTR((char*)buff, PRIV_KEY_SUFFIX, sz);
 8019888:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 801988c:	497f      	ldr	r1, [pc, #508]	@ (8019a8c <PemToDer+0x360>)
 801988e:	68f8      	ldr	r0, [r7, #12]
 8019890:	f00d ff44 	bl	802771c <mystrnstr>
 8019894:	4603      	mov	r3, r0
 8019896:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
            if (headerEnd) {
 801989a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801989e:	2b00      	cmp	r3, #0
 80198a0:	f000 80c6 	beq.w	8019a30 <PemToDer+0x304>
                const char* beginEnd;
                unsigned int endLen;

                beginEnd = headerEnd + XSTR_SIZEOF(PRIV_KEY_SUFFIX);
 80198a4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80198a8:	3310      	adds	r3, #16
 80198aa:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
                if (beginEnd >= (char*)buff + sz) {
 80198ae:	68fa      	ldr	r2, [r7, #12]
 80198b0:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80198b4:	4413      	add	r3, r2
 80198b6:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80198ba:	429a      	cmp	r2, r3
 80198bc:	d307      	bcc.n	80198ce <PemToDer+0x1a2>
                    return BUFFER_E;
 80198be:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80198c2:	e2dc      	b.n	8019e7e <PemToDer+0x752>
                /* back up to BEGIN_PRIV_KEY_PREFIX */
                while (headerEnd > (char*)buff &&
                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,
                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&
                        *headerEnd != '\n') {
                    headerEnd--;
 80198c4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80198c8:	3b01      	subs	r3, #1
 80198ca:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
                while (headerEnd > (char*)buff &&
 80198ce:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&
 80198d2:	68fa      	ldr	r2, [r7, #12]
 80198d4:	429a      	cmp	r2, r3
 80198d6:	d20e      	bcs.n	80198f6 <PemToDer+0x1ca>
                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,
 80198d8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80198dc:	220a      	movs	r2, #10
 80198de:	496c      	ldr	r1, [pc, #432]	@ (8019a90 <PemToDer+0x364>)
 80198e0:	4618      	mov	r0, r3
 80198e2:	f00f f9a7 	bl	8028c34 <strncmp>
 80198e6:	4603      	mov	r3, r0
                while (headerEnd > (char*)buff &&
 80198e8:	2b00      	cmp	r3, #0
 80198ea:	d004      	beq.n	80198f6 <PemToDer+0x1ca>
                        *headerEnd != '\n') {
 80198ec:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80198f0:	781b      	ldrb	r3, [r3, #0]
                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&
 80198f2:	2b0a      	cmp	r3, #10
 80198f4:	d1e6      	bne.n	80198c4 <PemToDer+0x198>
                }
                if (headerEnd <= (char*)buff ||
 80198f6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80198fa:	68fa      	ldr	r2, [r7, #12]
 80198fc:	429a      	cmp	r2, r3
 80198fe:	d210      	bcs.n	8019922 <PemToDer+0x1f6>
                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,
 8019900:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019904:	220a      	movs	r2, #10
 8019906:	4962      	ldr	r1, [pc, #392]	@ (8019a90 <PemToDer+0x364>)
 8019908:	4618      	mov	r0, r3
 801990a:	f00f f993 	bl	8028c34 <strncmp>
 801990e:	4603      	mov	r3, r0
                if (headerEnd <= (char*)buff ||
 8019910:	2b00      	cmp	r3, #0
 8019912:	d106      	bne.n	8019922 <PemToDer+0x1f6>
                        XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 ||
                        beginEnd - headerEnd > PEM_LINE_LEN) {
 8019914:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019918:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801991c:	1ad3      	subs	r3, r2, r3
                        XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 ||
 801991e:	2b4c      	cmp	r3, #76	@ 0x4c
 8019920:	dd0c      	ble.n	801993c <PemToDer+0x210>
                    WOLFSSL_MSG("Couldn't find PEM header");
                    WOLFSSL_ERROR(ASN_NO_PEM_HEADER);
 8019922:	2300      	movs	r3, #0
 8019924:	9300      	str	r3, [sp, #0]
 8019926:	4b5b      	ldr	r3, [pc, #364]	@ (8019a94 <PemToDer+0x368>)
 8019928:	f246 32f1 	movw	r2, #25585	@ 0x63f1
 801992c:	495a      	ldr	r1, [pc, #360]	@ (8019a98 <PemToDer+0x36c>)
 801992e:	f06f 00a1 	mvn.w	r0, #161	@ 0xa1
 8019932:	f005 f957 	bl	801ebe4 <WOLFSSL_ERROR_LINE>
                    return ASN_NO_PEM_HEADER;
 8019936:	f06f 03a1 	mvn.w	r3, #161	@ 0xa1
 801993a:	e2a0      	b.n	8019e7e <PemToDer+0x752>
                }

                /* headerEnd now points to beginning of header */
                XMEMCPY(beginBuf, headerEnd, (size_t)(beginEnd - headerEnd));
 801993c:	f8d7 10bc 	ldr.w	r1, [r7, #188]	@ 0xbc
 8019940:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019944:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8019948:	1ad3      	subs	r3, r2, r3
 801994a:	461a      	mov	r2, r3
 801994c:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 8019950:	4618      	mov	r0, r3
 8019952:	f00f fa18 	bl	8028d86 <memcpy>
                beginBuf[beginEnd - headerEnd] = '\0';
 8019956:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801995a:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801995e:	1ad3      	subs	r3, r2, r3
 8019960:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8019964:	443b      	add	r3, r7
 8019966:	2200      	movs	r2, #0
 8019968:	f803 2c9c 	strb.w	r2, [r3, #-156]
                /* look for matching footer */
                footer = XSTRNSTR(beginEnd,
 801996c:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 8019970:	330a      	adds	r3, #10
 8019972:	68f9      	ldr	r1, [r7, #12]
 8019974:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8019978:	4411      	add	r1, r2
 801997a:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801997e:	1a8a      	subs	r2, r1, r2
 8019980:	4619      	mov	r1, r3
 8019982:	f8d7 00e4 	ldr.w	r0, [r7, #228]	@ 0xe4
 8019986:	f00d fec9 	bl	802771c <mystrnstr>
 801998a:	4603      	mov	r3, r0
 801998c:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
                                beginBuf + XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX),
                                (unsigned int)((char*)buff + sz - beginEnd));
                if (!footer) {
 8019990:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8019994:	2b00      	cmp	r3, #0
 8019996:	d10c      	bne.n	80199b2 <PemToDer+0x286>
                    WOLFSSL_MSG("Couldn't find PEM footer");
                    WOLFSSL_ERROR(ASN_NO_PEM_HEADER);
 8019998:	2300      	movs	r3, #0
 801999a:	9300      	str	r3, [sp, #0]
 801999c:	4b3d      	ldr	r3, [pc, #244]	@ (8019a94 <PemToDer+0x368>)
 801999e:	f246 32fe 	movw	r2, #25598	@ 0x63fe
 80199a2:	493d      	ldr	r1, [pc, #244]	@ (8019a98 <PemToDer+0x36c>)
 80199a4:	f06f 00a1 	mvn.w	r0, #161	@ 0xa1
 80199a8:	f005 f91c 	bl	801ebe4 <WOLFSSL_ERROR_LINE>
                    return ASN_NO_PEM_HEADER;
 80199ac:	f06f 03a1 	mvn.w	r3, #161	@ 0xa1
 80199b0:	e265      	b.n	8019e7e <PemToDer+0x752>
                }

                footer -= XSTR_SIZEOF(END_PRIV_KEY_PREFIX);
 80199b2:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80199b6:	3b08      	subs	r3, #8
 80199b8:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
                if (footer > (char*)buff + sz - XSTR_SIZEOF(END_PRIV_KEY_PREFIX)
 80199bc:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80199c0:	3b08      	subs	r3, #8
 80199c2:	68fa      	ldr	r2, [r7, #12]
 80199c4:	441a      	add	r2, r3
 80199c6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80199ca:	429a      	cmp	r2, r3
 80199cc:	d309      	bcc.n	80199e2 <PemToDer+0x2b6>
                        || XSTRNCMP(footer, END_PRIV_KEY_PREFIX,
 80199ce:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80199d2:	2208      	movs	r2, #8
 80199d4:	4931      	ldr	r1, [pc, #196]	@ (8019a9c <PemToDer+0x370>)
 80199d6:	4618      	mov	r0, r3
 80199d8:	f00f f92c 	bl	8028c34 <strncmp>
 80199dc:	4603      	mov	r3, r0
 80199de:	2b00      	cmp	r3, #0
 80199e0:	d002      	beq.n	80199e8 <PemToDer+0x2bc>
                            XSTR_SIZEOF(END_PRIV_KEY_PREFIX)) != 0) {
                    WOLFSSL_MSG("Unexpected footer for PEM");
                    return BUFFER_E;
 80199e2:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80199e6:	e24a      	b.n	8019e7e <PemToDer+0x752>
                }

                endLen = (unsigned int)((size_t)(beginEnd - headerEnd) -
 80199e8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80199ec:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80199f0:	1ad3      	subs	r3, r2, r3
 80199f2:	3b02      	subs	r3, #2
 80199f4:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
                            (XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX) -
                                    XSTR_SIZEOF(END_PRIV_KEY_PREFIX)));
                XMEMCPY(endBuf, footer, (size_t)endLen);
 80199f8:	f8d7 10c0 	ldr.w	r1, [r7, #192]	@ 0xc0
 80199fc:	f107 0314 	add.w	r3, r7, #20
 8019a00:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8019a04:	4618      	mov	r0, r3
 8019a06:	f00f f9be 	bl	8028d86 <memcpy>
                endBuf[endLen] = '\0';
 8019a0a:	f107 0214 	add.w	r2, r7, #20
 8019a0e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8019a12:	4413      	add	r3, r2
 8019a14:	2200      	movs	r2, #0
 8019a16:	701a      	strb	r2, [r3, #0]

                header = beginBuf;
 8019a18:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 8019a1c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = endBuf;
 8019a20:	f107 0314 	add.w	r3, r7, #20
 8019a24:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
                headerEnd = beginEnd;
 8019a28:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8019a2c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
            }
        }

        if (!headerEnd) {
 8019a30:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019a34:	2b00      	cmp	r3, #0
 8019a36:	d13e      	bne.n	8019ab6 <PemToDer+0x38a>
            WOLFSSL_MSG("Couldn't find PEM header");
            WOLFSSL_ERROR(ASN_NO_PEM_HEADER);
 8019a38:	2300      	movs	r3, #0
 8019a3a:	9300      	str	r3, [sp, #0]
 8019a3c:	4b15      	ldr	r3, [pc, #84]	@ (8019a94 <PemToDer+0x368>)
 8019a3e:	f246 4218 	movw	r2, #25624	@ 0x6418
 8019a42:	4915      	ldr	r1, [pc, #84]	@ (8019a98 <PemToDer+0x36c>)
 8019a44:	f06f 00a1 	mvn.w	r0, #161	@ 0xa1
 8019a48:	f005 f8cc 	bl	801ebe4 <WOLFSSL_ERROR_LINE>
            return ASN_NO_PEM_HEADER;
 8019a4c:	f06f 03a1 	mvn.w	r3, #161	@ 0xa1
 8019a50:	e215      	b.n	8019e7e <PemToDer+0x752>
 8019a52:	bf00      	nop
 8019a54:	08030758 	.word	0x08030758
 8019a58:	080307d8 	.word	0x080307d8
 8019a5c:	080307f4 	.word	0x080307f4
 8019a60:	08030810 	.word	0x08030810
 8019a64:	08030838 	.word	0x08030838
 8019a68:	0803085c 	.word	0x0803085c
 8019a6c:	0803087c 	.word	0x0803087c
 8019a70:	080308d8 	.word	0x080308d8
 8019a74:	080308f8 	.word	0x080308f8
 8019a78:	08030918 	.word	0x08030918
 8019a7c:	08030798 	.word	0x08030798
 8019a80:	080307b8 	.word	0x080307b8
 8019a84:	0803089c 	.word	0x0803089c
 8019a88:	080308bc 	.word	0x080308bc
 8019a8c:	08034820 	.word	0x08034820
 8019a90:	08034814 	.word	0x08034814
 8019a94:	080309b0 	.word	0x080309b0
 8019a98:	0803486c 	.word	0x0803486c
 8019a9c:	08034834 	.word	0x08034834
#else
        WOLFSSL_MSG("Couldn't find PEM header");
        return ASN_NO_PEM_HEADER;
#endif
    } else {
        headerEnd += XSTRLEN(header);
 8019aa0:	f8d7 40bc 	ldr.w	r4, [r7, #188]	@ 0xbc
 8019aa4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019aa8:	4618      	mov	r0, r3
 8019aaa:	f7e6 fb9b 	bl	80001e4 <strlen>
 8019aae:	4603      	mov	r3, r0
 8019ab0:	4423      	add	r3, r4
 8019ab2:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    }

    /* eat end of line characters */
    headerEnd = SkipEndOfLineChars(headerEnd, bufferEnd);
 8019ab6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019aba:	f8d7 10ec 	ldr.w	r1, [r7, #236]	@ 0xec
 8019abe:	4618      	mov	r0, r3
 8019ac0:	f7ff fb4b 	bl	801915a <SkipEndOfLineChars>
 8019ac4:	4603      	mov	r3, r0
 8019ac6:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc

    if (keyFormat) {
 8019aca:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019ace:	2b00      	cmp	r3, #0
 8019ad0:	d016      	beq.n	8019b00 <PemToDer+0x3d4>
        /* keyFormat is Key_Sum enum */
        if (type == PRIVATEKEY_TYPE
 8019ad2:	687b      	ldr	r3, [r7, #4]
 8019ad4:	2b01      	cmp	r3, #1
 8019ad6:	d113      	bne.n	8019b00 <PemToDer+0x3d4>
        #ifdef WOLFSSL_DUAL_ALG_CERTS
            || type == ALT_PRIVATEKEY_TYPE
        #endif
           ) {
        #ifndef NO_RSA
            if (header == BEGIN_RSA_PRIV)
 8019ad8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019adc:	4aaf      	ldr	r2, [pc, #700]	@ (8019d9c <PemToDer+0x670>)
 8019ade:	4293      	cmp	r3, r2
 8019ae0:	d104      	bne.n	8019aec <PemToDer+0x3c0>
                *keyFormat = RSAk;
 8019ae2:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019ae6:	f240 2285 	movw	r2, #645	@ 0x285
 8019aea:	601a      	str	r2, [r3, #0]
        #endif
        #ifdef HAVE_ECC
            if (header == BEGIN_EC_PRIV)
 8019aec:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019af0:	4aab      	ldr	r2, [pc, #684]	@ (8019da0 <PemToDer+0x674>)
 8019af2:	4293      	cmp	r3, r2
 8019af4:	d104      	bne.n	8019b00 <PemToDer+0x3d4>
                *keyFormat = ECDSAk;
 8019af6:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019afa:	f240 2206 	movw	r2, #518	@ 0x206
 8019afe:	601a      	str	r2, [r3, #0]
        }
    #endif
    }

#ifdef WOLFSSL_ENCRYPTED_KEYS
    if (info) {
 8019b00:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019b04:	2b00      	cmp	r3, #0
 8019b06:	d021      	beq.n	8019b4c <PemToDer+0x420>
        ret = wc_EncryptedInfoParse(info, &headerEnd,
                                    (size_t)(bufferEnd - headerEnd));
 8019b08:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019b0c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 8019b10:	1ad3      	subs	r3, r2, r3
        ret = wc_EncryptedInfoParse(info, &headerEnd,
 8019b12:	461a      	mov	r2, r3
 8019b14:	f107 03bc 	add.w	r3, r7, #188	@ 0xbc
 8019b18:	4619      	mov	r1, r3
 8019b1a:	f8d7 0114 	ldr.w	r0, [r7, #276]	@ 0x114
 8019b1e:	f7ff fcdb 	bl	80194d8 <wc_EncryptedInfoParse>
 8019b22:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
        if (ret < 0)
 8019b26:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019b2a:	2b00      	cmp	r3, #0
 8019b2c:	da02      	bge.n	8019b34 <PemToDer+0x408>
            return ret;
 8019b2e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019b32:	e1a4      	b.n	8019e7e <PemToDer+0x752>
        if (info->set)
 8019b34:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019b38:	f893 3088 	ldrb.w	r3, [r3, #136]	@ 0x88
 8019b3c:	f003 0301 	and.w	r3, r3, #1
 8019b40:	b2db      	uxtb	r3, r3
 8019b42:	2b00      	cmp	r3, #0
 8019b44:	d002      	beq.n	8019b4c <PemToDer+0x420>
            encrypted_key = 1;
 8019b46:	2301      	movs	r3, #1
 8019b48:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    }
#endif /* WOLFSSL_ENCRYPTED_KEYS */

    /* find footer */
    footerEnd = XSTRNSTR(headerEnd, footer, (unsigned int)((char*)buff +
 8019b4c:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8019b50:	f8d7 10c0 	ldr.w	r1, [r7, #192]	@ 0xc0
 8019b54:	68fa      	ldr	r2, [r7, #12]
 8019b56:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8019b5a:	441a      	add	r2, r3
 8019b5c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019b60:	1ad3      	subs	r3, r2, r3
 8019b62:	461a      	mov	r2, r3
 8019b64:	f00d fdda 	bl	802771c <mystrnstr>
 8019b68:	f8c7 00f0 	str.w	r0, [r7, #240]	@ 0xf0
        sz - headerEnd));
    if (!footerEnd) {
 8019b6c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8019b70:	2b00      	cmp	r3, #0
 8019b72:	d10a      	bne.n	8019b8a <PemToDer+0x45e>
        if (info)
 8019b74:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019b78:	2b00      	cmp	r3, #0
 8019b7a:	d003      	beq.n	8019b84 <PemToDer+0x458>
            info->consumed = longSz; /* No more certs if no footer */
 8019b7c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019b80:	68ba      	ldr	r2, [r7, #8]
 8019b82:	601a      	str	r2, [r3, #0]
        return BUFFER_E;
 8019b84:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019b88:	e179      	b.n	8019e7e <PemToDer+0x752>
    }

    consumedEnd = footerEnd + XSTRLEN(footer);
 8019b8a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8019b8e:	4618      	mov	r0, r3
 8019b90:	f7e6 fb28 	bl	80001e4 <strlen>
 8019b94:	4602      	mov	r2, r0
 8019b96:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8019b9a:	4413      	add	r3, r2
 8019b9c:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    if (consumedEnd < bufferEnd) { /* handle no end of line on last line */
 8019ba0:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8019ba4:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 8019ba8:	429a      	cmp	r2, r3
 8019baa:	d217      	bcs.n	8019bdc <PemToDer+0x4b0>
        /* eat end of line characters */
        consumedEnd = SkipEndOfLineChars(consumedEnd, bufferEnd);
 8019bac:	f8d7 10ec 	ldr.w	r1, [r7, #236]	@ 0xec
 8019bb0:	f8d7 00fc 	ldr.w	r0, [r7, #252]	@ 0xfc
 8019bb4:	f7ff fad1 	bl	801915a <SkipEndOfLineChars>
 8019bb8:	f8c7 00fc 	str.w	r0, [r7, #252]	@ 0xfc
        /* skip possible null term */
        if (consumedEnd < bufferEnd && consumedEnd[0] == '\0')
 8019bbc:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8019bc0:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 8019bc4:	429a      	cmp	r2, r3
 8019bc6:	d209      	bcs.n	8019bdc <PemToDer+0x4b0>
 8019bc8:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8019bcc:	781b      	ldrb	r3, [r3, #0]
 8019bce:	2b00      	cmp	r3, #0
 8019bd0:	d104      	bne.n	8019bdc <PemToDer+0x4b0>
            consumedEnd++;
 8019bd2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8019bd6:	3301      	adds	r3, #1
 8019bd8:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    }

    if (info)
 8019bdc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019be0:	2b00      	cmp	r3, #0
 8019be2:	d006      	beq.n	8019bf2 <PemToDer+0x4c6>
        info->consumed = (long)(consumedEnd - (const char*)buff);
 8019be4:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8019be8:	68fb      	ldr	r3, [r7, #12]
 8019bea:	1ad2      	subs	r2, r2, r3
 8019bec:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019bf0:	601a      	str	r2, [r3, #0]

    /* set up der buffer */
    neededSz = (long)(footerEnd - headerEnd);
 8019bf2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019bf6:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8019bfa:	1ad3      	subs	r3, r2, r3
 8019bfc:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    if (neededSz > (long)sz || neededSz <= 0)
 8019c00:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8019c04:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8019c08:	429a      	cmp	r2, r3
 8019c0a:	dc03      	bgt.n	8019c14 <PemToDer+0x4e8>
 8019c0c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8019c10:	2b00      	cmp	r3, #0
 8019c12:	dc02      	bgt.n	8019c1a <PemToDer+0x4ee>
        return BUFFER_E;
 8019c14:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019c18:	e131      	b.n	8019e7e <PemToDer+0x752>

    ret = AllocDer(pDer, (word32)neededSz, type, heap);
 8019c1a:	f8d7 10dc 	ldr.w	r1, [r7, #220]	@ 0xdc
 8019c1e:	f507 7380 	add.w	r3, r7, #256	@ 0x100
 8019c22:	f5a3 7080 	sub.w	r0, r3, #256	@ 0x100
 8019c26:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8019c2a:	687a      	ldr	r2, [r7, #4]
 8019c2c:	6800      	ldr	r0, [r0, #0]
 8019c2e:	f7ff f987 	bl	8018f40 <AllocDer>
 8019c32:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
    if (ret < 0) {
 8019c36:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019c3a:	2b00      	cmp	r3, #0
 8019c3c:	da02      	bge.n	8019c44 <PemToDer+0x518>
        return ret;
 8019c3e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019c42:	e11c      	b.n	8019e7e <PemToDer+0x752>
    }
    der = *pDer;
 8019c44:	f507 7380 	add.w	r3, r7, #256	@ 0x100
 8019c48:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 8019c4c:	681b      	ldr	r3, [r3, #0]
 8019c4e:	681b      	ldr	r3, [r3, #0]
 8019c50:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    if (Base64_Decode((byte*)headerEnd, (word32)neededSz,
 8019c54:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8019c58:	f8d7 10dc 	ldr.w	r1, [r7, #220]	@ 0xdc
 8019c5c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c60:	681a      	ldr	r2, [r3, #0]
 8019c62:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c66:	3308      	adds	r3, #8
 8019c68:	f000 fc14 	bl	801a494 <Base64_Decode>
 8019c6c:	4603      	mov	r3, r0
 8019c6e:	2b00      	cmp	r3, #0
 8019c70:	da0c      	bge.n	8019c8c <PemToDer+0x560>
                      der->buffer, &der->length) < 0) {
        WOLFSSL_ERROR(BUFFER_E);
 8019c72:	2300      	movs	r3, #0
 8019c74:	9300      	str	r3, [sp, #0]
 8019c76:	4b4b      	ldr	r3, [pc, #300]	@ (8019da4 <PemToDer+0x678>)
 8019c78:	f246 4272 	movw	r2, #25714	@ 0x6472
 8019c7c:	494a      	ldr	r1, [pc, #296]	@ (8019da8 <PemToDer+0x67c>)
 8019c7e:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 8019c82:	f004 ffaf 	bl	801ebe4 <WOLFSSL_ERROR_LINE>
        return BUFFER_E;
 8019c86:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019c8a:	e0f8      	b.n	8019e7e <PemToDer+0x752>
    }

    if ((header == BEGIN_PRIV_KEY
 8019c8c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019c90:	4a46      	ldr	r2, [pc, #280]	@ (8019dac <PemToDer+0x680>)
 8019c92:	4293      	cmp	r3, r2
 8019c94:	d00a      	beq.n	8019cac <PemToDer+0x580>
#ifdef OPENSSL_EXTRA
         || header == beginBuf
 8019c96:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8019c9a:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 8019c9e:	429a      	cmp	r2, r3
 8019ca0:	d004      	beq.n	8019cac <PemToDer+0x580>
#endif
#ifdef HAVE_ECC
         || header == BEGIN_EC_PRIV
 8019ca2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019ca6:	4a3e      	ldr	r2, [pc, #248]	@ (8019da0 <PemToDer+0x674>)
 8019ca8:	4293      	cmp	r3, r2
 8019caa:	d124      	bne.n	8019cf6 <PemToDer+0x5ca>
#endif
        ) && !encrypted_key)
 8019cac:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8019cb0:	2b00      	cmp	r3, #0
 8019cb2:	d120      	bne.n	8019cf6 <PemToDer+0x5ca>
    {
        /* detect pkcs8 key and get alg type */
        /* keep PKCS8 header */
        idx = 0;
 8019cb4:	2300      	movs	r3, #0
 8019cb6:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
        ret = ToTraditionalInline_ex(der->buffer, &idx, der->length, &algId);
 8019cba:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019cbe:	6818      	ldr	r0, [r3, #0]
 8019cc0:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019cc4:	689a      	ldr	r2, [r3, #8]
 8019cc6:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 8019cca:	f107 01b4 	add.w	r1, r7, #180	@ 0xb4
 8019cce:	f7fb f991 	bl	8014ff4 <ToTraditionalInline_ex>
 8019cd2:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
        if (ret > 0) {
 8019cd6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019cda:	2b00      	cmp	r3, #0
 8019cdc:	dd09      	ble.n	8019cf2 <PemToDer+0x5c6>
            if (keyFormat)
 8019cde:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019ce2:	2b00      	cmp	r3, #0
 8019ce4:	d005      	beq.n	8019cf2 <PemToDer+0x5c6>
                *keyFormat = (int)algId;
 8019ce6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8019cea:	461a      	mov	r2, r3
 8019cec:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019cf0:	601a      	str	r2, [r3, #0]
        }
        else {
            /* ignore failure here and assume key is not pkcs8 wrapped */
        }
        return 0;
 8019cf2:	2300      	movs	r3, #0
 8019cf4:	e0c3      	b.n	8019e7e <PemToDer+0x752>
    }

#ifdef WOLFSSL_ENCRYPTED_KEYS
    if (encrypted_key || header == BEGIN_ENC_PRIV_KEY) {
 8019cf6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8019cfa:	2b00      	cmp	r3, #0
 8019cfc:	d105      	bne.n	8019d0a <PemToDer+0x5de>
 8019cfe:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019d02:	4a2b      	ldr	r2, [pc, #172]	@ (8019db0 <PemToDer+0x684>)
 8019d04:	4293      	cmp	r3, r2
 8019d06:	f040 80b8 	bne.w	8019e7a <PemToDer+0x74e>
        int   passwordSz = NAME_SZ;
 8019d0a:	2350      	movs	r3, #80	@ 0x50
 8019d0c:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    #ifdef WOLFSSL_SMALL_STACK
        char* password = NULL;
 8019d10:	2300      	movs	r3, #0
 8019d12:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    #else
        char  password[NAME_SZ];
    #endif

        if (!info || !info->passwd_cb) {
 8019d16:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019d1a:	2b00      	cmp	r3, #0
 8019d1c:	d004      	beq.n	8019d28 <PemToDer+0x5fc>
 8019d1e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019d22:	685b      	ldr	r3, [r3, #4]
 8019d24:	2b00      	cmp	r3, #0
 8019d26:	d102      	bne.n	8019d2e <PemToDer+0x602>
            WOLFSSL_MSG("No password callback set");
            WOLFSSL_ERROR_VERBOSE(NO_PASSWORD);
            return NO_PASSWORD;
 8019d28:	f06f 03af 	mvn.w	r3, #175	@ 0xaf
 8019d2c:	e0a7      	b.n	8019e7e <PemToDer+0x752>
        }

    #ifdef WOLFSSL_SMALL_STACK
        password = (char*)XMALLOC(passwordSz, heap, DYNAMIC_TYPE_STRING);
 8019d2e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019d32:	4618      	mov	r0, r3
 8019d34:	f004 ffa2 	bl	801ec7c <wolfSSL_Malloc>
 8019d38:	f8c7 00d0 	str.w	r0, [r7, #208]	@ 0xd0
        if (password == NULL) {
 8019d3c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8019d40:	2b00      	cmp	r3, #0
 8019d42:	d102      	bne.n	8019d4a <PemToDer+0x61e>
            return MEMORY_E;
 8019d44:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8019d48:	e099      	b.n	8019e7e <PemToDer+0x752>
        }
    #endif

        /* get password */
        ret = info->passwd_cb(password, passwordSz, PEM_PASS_READ,
 8019d4a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019d4e:	685c      	ldr	r4, [r3, #4]
 8019d50:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019d54:	689b      	ldr	r3, [r3, #8]
 8019d56:	2200      	movs	r2, #0
 8019d58:	f8d7 10d4 	ldr.w	r1, [r7, #212]	@ 0xd4
 8019d5c:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 8019d60:	47a0      	blx	r4
 8019d62:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
            info->passwd_userdata);
        if (ret >= 0) {
 8019d66:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019d6a:	2b00      	cmp	r3, #0
 8019d6c:	db6f      	blt.n	8019e4e <PemToDer+0x722>
            passwordSz = ret;
 8019d6e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019d72:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
        #ifdef WOLFSSL_CHECK_MEM_ZERO
            wc_MemZero_Add("PEM password", password, passwordSz);
        #endif

            /* convert and adjust length */
            if (header == BEGIN_ENC_PRIV_KEY) {
 8019d76:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019d7a:	4a0d      	ldr	r2, [pc, #52]	@ (8019db0 <PemToDer+0x684>)
 8019d7c:	4293      	cmp	r3, r2
 8019d7e:	d104      	bne.n	8019d8a <PemToDer+0x65e>
                        ret = 0;
                    }
                }
            #else
                WOLFSSL_ERROR_VERBOSE(NOT_COMPILED_IN);
                ret = NOT_COMPILED_IN;
 8019d80:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 8019d84:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8019d88:	e04c      	b.n	8019e24 <PemToDer+0x6f8>
            #endif
            }
            /* decrypt the key */
            else {
                if (passwordSz == 0) {
 8019d8a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019d8e:	2b00      	cmp	r3, #0
 8019d90:	d110      	bne.n	8019db4 <PemToDer+0x688>
                    /* The key is encrypted but does not have a password */
                    WOLFSSL_MSG("No password for encrypted key");
                    WOLFSSL_ERROR_VERBOSE(NO_PASSWORD);
                    ret = NO_PASSWORD;
 8019d92:	f06f 03af 	mvn.w	r3, #175	@ 0xaf
 8019d96:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8019d9a:	e043      	b.n	8019e24 <PemToDer+0x6f8>
 8019d9c:	08030758 	.word	0x08030758
 8019da0:	0803085c 	.word	0x0803085c
 8019da4:	080309b0 	.word	0x080309b0
 8019da8:	0803486c 	.word	0x0803486c
 8019dac:	080307d8 	.word	0x080307d8
 8019db0:	08030810 	.word	0x08030810
                else {
                #if ((defined(WOLFSSL_ENCRYPTED_KEYS) && !defined(NO_DES3)) || \
                         (!defined(NO_AES) && defined(HAVE_AES_CBC) && \
                          defined(HAVE_AES_DECRYPT))) && \
                        !defined(NO_WOLFSSL_SKIP_TRAILING_PAD)
                    int     padVal = 0;
 8019db4:	2300      	movs	r3, #0
 8019db6:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
                #endif

                    ret = wc_BufferKeyDecrypt(info, der->buffer, der->length,
 8019dba:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019dbe:	6819      	ldr	r1, [r3, #0]
 8019dc0:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019dc4:	689a      	ldr	r2, [r3, #8]
 8019dc6:	2303      	movs	r3, #3
 8019dc8:	9301      	str	r3, [sp, #4]
 8019dca:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019dce:	9300      	str	r3, [sp, #0]
 8019dd0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8019dd4:	f8d7 0114 	ldr.w	r0, [r7, #276]	@ 0x114
 8019dd8:	f00d fb81 	bl	80274de <wc_BufferKeyDecrypt>
 8019ddc:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
                        }
                    }
                #endif /* !NO_DES3 */
                #if !defined(NO_AES) && defined(HAVE_AES_CBC) && \
                    defined(HAVE_AES_DECRYPT)
                    if (info->cipherType == WC_CIPHER_AES_CBC) {
 8019de0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019de4:	68db      	ldr	r3, [r3, #12]
 8019de6:	2b02      	cmp	r3, #2
 8019de8:	d11c      	bne.n	8019e24 <PemToDer+0x6f8>
                        if (der->length > WC_AES_BLOCK_SIZE) {
 8019dea:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019dee:	689b      	ldr	r3, [r3, #8]
 8019df0:	2b10      	cmp	r3, #16
 8019df2:	d917      	bls.n	8019e24 <PemToDer+0x6f8>
                            padVal = der->buffer[der->length-1];
 8019df4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019df8:	681a      	ldr	r2, [r3, #0]
 8019dfa:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019dfe:	689b      	ldr	r3, [r3, #8]
 8019e00:	3b01      	subs	r3, #1
 8019e02:	4413      	add	r3, r2
 8019e04:	781b      	ldrb	r3, [r3, #0]
 8019e06:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
                            if (padVal <= WC_AES_BLOCK_SIZE) {
 8019e0a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8019e0e:	2b10      	cmp	r3, #16
 8019e10:	dc08      	bgt.n	8019e24 <PemToDer+0x6f8>
                                der->length -= (word32)padVal;
 8019e12:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019e16:	689a      	ldr	r2, [r3, #8]
 8019e18:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8019e1c:	1ad2      	subs	r2, r2, r3
 8019e1e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019e22:	609a      	str	r2, [r3, #8]
                #endif
#endif /* !NO_WOLFSSL_SKIP_TRAILING_PAD */
                }
            }
#ifdef OPENSSL_EXTRA
            if (ret) {
 8019e24:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019e28:	2b00      	cmp	r3, #0
 8019e2a:	d008      	beq.n	8019e3e <PemToDer+0x712>
                WOLFSSL_PEMerr(0, WOLFSSL_PEM_R_BAD_DECRYPT_E);
 8019e2c:	f246 43fd 	movw	r3, #25853	@ 0x64fd
 8019e30:	9300      	str	r3, [sp, #0]
 8019e32:	4b15      	ldr	r3, [pc, #84]	@ (8019e88 <PemToDer+0x75c>)
 8019e34:	4a15      	ldr	r2, [pc, #84]	@ (8019e8c <PemToDer+0x760>)
 8019e36:	2100      	movs	r1, #0
 8019e38:	2009      	movs	r0, #9
 8019e3a:	f7f3 ff8d 	bl	800dd58 <wolfSSL_ERR_put_error>
            }
#endif
            ForceZero(password, (word32)passwordSz);
 8019e3e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019e42:	4619      	mov	r1, r3
 8019e44:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 8019e48:	f7f8 fcdb 	bl	8012802 <ForceZero>
 8019e4c:	e009      	b.n	8019e62 <PemToDer+0x736>
        }
#ifdef OPENSSL_EXTRA
        else {
            WOLFSSL_PEMerr(0, WOLFSSL_PEM_R_BAD_PASSWORD_READ_E);
 8019e4e:	f246 5304 	movw	r3, #25860	@ 0x6504
 8019e52:	9300      	str	r3, [sp, #0]
 8019e54:	4b0c      	ldr	r3, [pc, #48]	@ (8019e88 <PemToDer+0x75c>)
 8019e56:	f46f 72fe 	mvn.w	r2, #508	@ 0x1fc
 8019e5a:	2100      	movs	r1, #0
 8019e5c:	2009      	movs	r0, #9
 8019e5e:	f7f3 ff7b 	bl	800dd58 <wolfSSL_ERR_put_error>
        }
#endif

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(password, heap, DYNAMIC_TYPE_STRING);
 8019e62:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8019e66:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8019e6a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8019e6e:	2b00      	cmp	r3, #0
 8019e70:	d003      	beq.n	8019e7a <PemToDer+0x74e>
 8019e72:	f8d7 00c8 	ldr.w	r0, [r7, #200]	@ 0xc8
 8019e76:	f004 ff1d 	bl	801ecb4 <wolfSSL_Free>
        wc_MemZero_Check(password, NAME_SZ);
    #endif
    }
#endif /* WOLFSSL_ENCRYPTED_KEYS */

    return ret;
 8019e7a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
}
 8019e7e:	4618      	mov	r0, r3
 8019e80:	f507 7782 	add.w	r7, r7, #260	@ 0x104
 8019e84:	46bd      	mov	sp, r7
 8019e86:	bd90      	pop	{r4, r7, pc}
 8019e88:	080309b0 	.word	0x080309b0
 8019e8c:	fffffe02 	.word	0xfffffe02

08019e90 <DecodeECC_DSA_Sig_Ex>:
    return DecodeECC_DSA_Sig_Ex(sig, sigLen, r, s, 1);
}

int DecodeECC_DSA_Sig_Ex(const byte* sig, word32 sigLen, mp_int* r, mp_int* s,
    int init)
{
 8019e90:	b580      	push	{r7, lr}
 8019e92:	b0a0      	sub	sp, #128	@ 0x80
 8019e94:	af04      	add	r7, sp, #16
 8019e96:	60f8      	str	r0, [r7, #12]
 8019e98:	60b9      	str	r1, [r7, #8]
 8019e9a:	607a      	str	r2, [r7, #4]
 8019e9c:	603b      	str	r3, [r7, #0]
#endif

    return 0;
#else
    ASNGetData dataASN[dsaSigASN_Length];
    word32 idx = 0;
 8019e9e:	2300      	movs	r3, #0
 8019ea0:	617b      	str	r3, [r7, #20]
    int ret;

    /* Clear dynamic data and set mp_ints to put r and s into. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 8019ea2:	f107 0318 	add.w	r3, r7, #24
 8019ea6:	2254      	movs	r2, #84	@ 0x54
 8019ea8:	2100      	movs	r1, #0
 8019eaa:	4618      	mov	r0, r3
 8019eac:	f00e feba 	bl	8028c24 <memset>
    if (init) {
 8019eb0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8019eb2:	2b00      	cmp	r3, #0
 8019eb4:	d00a      	beq.n	8019ecc <DecodeECC_DSA_Sig_Ex+0x3c>
        GetASN_MP(&dataASN[DSASIGASN_IDX_R], r);
 8019eb6:	2308      	movs	r3, #8
 8019eb8:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
 8019ebc:	687b      	ldr	r3, [r7, #4]
 8019ebe:	63fb      	str	r3, [r7, #60]	@ 0x3c
        GetASN_MP(&dataASN[DSASIGASN_IDX_S], s);
 8019ec0:	2308      	movs	r3, #8
 8019ec2:	f887 3068 	strb.w	r3, [r7, #104]	@ 0x68
 8019ec6:	683b      	ldr	r3, [r7, #0]
 8019ec8:	65bb      	str	r3, [r7, #88]	@ 0x58
 8019eca:	e009      	b.n	8019ee0 <DecodeECC_DSA_Sig_Ex+0x50>
    }
    else {
        GetASN_MP_Inited(&dataASN[DSASIGASN_IDX_R], r);
 8019ecc:	2309      	movs	r3, #9
 8019ece:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
 8019ed2:	687b      	ldr	r3, [r7, #4]
 8019ed4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        GetASN_MP_Inited(&dataASN[DSASIGASN_IDX_S], s);
 8019ed6:	2309      	movs	r3, #9
 8019ed8:	f887 3068 	strb.w	r3, [r7, #104]	@ 0x68
 8019edc:	683b      	ldr	r3, [r7, #0]
 8019ede:	65bb      	str	r3, [r7, #88]	@ 0x58
    }

    /* Decode the DSA signature. */
    ret = GetASN_Items(dsaSigASN, dataASN, dsaSigASN_Length, 0, sig, &idx,
 8019ee0:	f107 0118 	add.w	r1, r7, #24
 8019ee4:	68bb      	ldr	r3, [r7, #8]
 8019ee6:	9302      	str	r3, [sp, #8]
 8019ee8:	f107 0314 	add.w	r3, r7, #20
 8019eec:	9301      	str	r3, [sp, #4]
 8019eee:	68fb      	ldr	r3, [r7, #12]
 8019ef0:	9300      	str	r3, [sp, #0]
 8019ef2:	2300      	movs	r3, #0
 8019ef4:	2203      	movs	r2, #3
 8019ef6:	4811      	ldr	r0, [pc, #68]	@ (8019f3c <DecodeECC_DSA_Sig_Ex+0xac>)
 8019ef8:	f7f9 fcba 	bl	8013870 <GetASN_Items>
 8019efc:	66f8      	str	r0, [r7, #108]	@ 0x6c
                       sigLen);

    if (ret != 0) {
 8019efe:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8019f00:	2b00      	cmp	r3, #0
 8019f02:	d002      	beq.n	8019f0a <DecodeECC_DSA_Sig_Ex+0x7a>
        ret = ASN_ECC_KEY_E;
 8019f04:	f06f 03aa 	mvn.w	r3, #170	@ 0xaa
 8019f08:	66fb      	str	r3, [r7, #108]	@ 0x6c
    }

#ifndef NO_STRICT_ECDSA_LEN
    /* sanity check that the index has been advanced all the way to the end of
     * the buffer */
    if ((ret == 0) && (idx != sigLen)) {
 8019f0a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8019f0c:	2b00      	cmp	r3, #0
 8019f0e:	d106      	bne.n	8019f1e <DecodeECC_DSA_Sig_Ex+0x8e>
 8019f10:	697b      	ldr	r3, [r7, #20]
 8019f12:	68ba      	ldr	r2, [r7, #8]
 8019f14:	429a      	cmp	r2, r3
 8019f16:	d002      	beq.n	8019f1e <DecodeECC_DSA_Sig_Ex+0x8e>
        ret = ASN_ECC_KEY_E;
 8019f18:	f06f 03aa 	mvn.w	r3, #170	@ 0xaa
 8019f1c:	66fb      	str	r3, [r7, #108]	@ 0x6c
    }
#endif
    if (ret != 0) {
 8019f1e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8019f20:	2b00      	cmp	r3, #0
 8019f22:	d005      	beq.n	8019f30 <DecodeECC_DSA_Sig_Ex+0xa0>
        mp_clear(r);
 8019f24:	6878      	ldr	r0, [r7, #4]
 8019f26:	f00c fde2 	bl	8026aee <mp_clear>
        mp_clear(s);
 8019f2a:	6838      	ldr	r0, [r7, #0]
 8019f2c:	f00c fddf 	bl	8026aee <mp_clear>
    }

    return ret;
 8019f30:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8019f32:	4618      	mov	r0, r3
 8019f34:	3770      	adds	r7, #112	@ 0x70
 8019f36:	46bd      	mov	sp, r7
 8019f38:	bd80      	pop	{r7, pc}
 8019f3a:	bf00      	nop
 8019f3c:	08034840 	.word	0x08034840

08019f40 <wc_EccPrivateKeyDecode>:
#endif

WOLFSSL_ABI
int wc_EccPrivateKeyDecode(const byte* input, word32* inOutIdx, ecc_key* key,
                        word32 inSz)
{
 8019f40:	b590      	push	{r4, r7, lr}
 8019f42:	b091      	sub	sp, #68	@ 0x44
 8019f44:	af04      	add	r7, sp, #16
 8019f46:	60f8      	str	r0, [r7, #12]
 8019f48:	60b9      	str	r1, [r7, #8]
 8019f4a:	607a      	str	r2, [r7, #4]
 8019f4c:	603b      	str	r3, [r7, #0]
    XFREE(pub,  key->heap, DYNAMIC_TYPE_TMP_BUFFER);
#endif

    return ret;
#else
    DECL_ASNGETDATA(dataASN, eccKeyASN_Length);
 8019f4e:	2300      	movs	r3, #0
 8019f50:	62fb      	str	r3, [r7, #44]	@ 0x2c
    byte version = 0;
 8019f52:	2300      	movs	r3, #0
 8019f54:	77fb      	strb	r3, [r7, #31]
    int ret = 0;
 8019f56:	2300      	movs	r3, #0
 8019f58:	62bb      	str	r3, [r7, #40]	@ 0x28
    int curve_id = ECC_CURVE_DEF;
 8019f5a:	2300      	movs	r3, #0
 8019f5c:	627b      	str	r3, [r7, #36]	@ 0x24
#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12) || defined(WOLFSSL_SM2)
    word32 algId = 0;
 8019f5e:	2300      	movs	r3, #0
 8019f60:	61bb      	str	r3, [r7, #24]
    word32 eccOid = 0;
 8019f62:	2300      	movs	r3, #0
 8019f64:	617b      	str	r3, [r7, #20]
#endif

    /* Validate parameters. */
    if ((input == NULL) || (inOutIdx == NULL) || (key == NULL) || (inSz == 0)) {
 8019f66:	68fb      	ldr	r3, [r7, #12]
 8019f68:	2b00      	cmp	r3, #0
 8019f6a:	d008      	beq.n	8019f7e <wc_EccPrivateKeyDecode+0x3e>
 8019f6c:	68bb      	ldr	r3, [r7, #8]
 8019f6e:	2b00      	cmp	r3, #0
 8019f70:	d005      	beq.n	8019f7e <wc_EccPrivateKeyDecode+0x3e>
 8019f72:	687b      	ldr	r3, [r7, #4]
 8019f74:	2b00      	cmp	r3, #0
 8019f76:	d002      	beq.n	8019f7e <wc_EccPrivateKeyDecode+0x3e>
 8019f78:	683b      	ldr	r3, [r7, #0]
 8019f7a:	2b00      	cmp	r3, #0
 8019f7c:	d102      	bne.n	8019f84 <wc_EccPrivateKeyDecode+0x44>
        ret = BAD_FUNC_ARG;
 8019f7e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8019f82:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12) || defined(WOLFSSL_SM2)
    /* if has pkcs8 header skip it */
    if (ToTraditionalInline_ex2(input, inOutIdx, inSz, &algId, &eccOid) < 0) {
 8019f84:	f107 0218 	add.w	r2, r7, #24
 8019f88:	f107 0314 	add.w	r3, r7, #20
 8019f8c:	9300      	str	r3, [sp, #0]
 8019f8e:	4613      	mov	r3, r2
 8019f90:	683a      	ldr	r2, [r7, #0]
 8019f92:	68b9      	ldr	r1, [r7, #8]
 8019f94:	68f8      	ldr	r0, [r7, #12]
 8019f96:	f7fa ff1b 	bl	8014dd0 <ToTraditionalInline_ex2>
 8019f9a:	4603      	mov	r3, r0
 8019f9c:	2b00      	cmp	r3, #0
 8019f9e:	db06      	blt.n	8019fae <wc_EccPrivateKeyDecode+0x6e>
        /* ignore error, did not have pkcs8 header */
    }
    else {
        curve_id = wc_ecc_get_oid(eccOid, NULL, NULL);
 8019fa0:	697b      	ldr	r3, [r7, #20]
 8019fa2:	2200      	movs	r2, #0
 8019fa4:	2100      	movs	r1, #0
 8019fa6:	4618      	mov	r0, r3
 8019fa8:	f004 fa3e 	bl	801e428 <wc_ecc_get_oid>
 8019fac:	6278      	str	r0, [r7, #36]	@ 0x24
    }
#endif

    CALLOC_ASNGETDATA(dataASN, eccKeyASN_Length, ret, key->heap);
 8019fae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019fb0:	2b00      	cmp	r3, #0
 8019fb2:	d109      	bne.n	8019fc8 <wc_EccPrivateKeyDecode+0x88>
 8019fb4:	20e0      	movs	r0, #224	@ 0xe0
 8019fb6:	f004 fe61 	bl	801ec7c <wolfSSL_Malloc>
 8019fba:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8019fbc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019fbe:	2b00      	cmp	r3, #0
 8019fc0:	d102      	bne.n	8019fc8 <wc_EccPrivateKeyDecode+0x88>
 8019fc2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8019fc6:	62bb      	str	r3, [r7, #40]	@ 0x28
 8019fc8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019fca:	2b00      	cmp	r3, #0
 8019fcc:	d104      	bne.n	8019fd8 <wc_EccPrivateKeyDecode+0x98>
 8019fce:	22e0      	movs	r2, #224	@ 0xe0
 8019fd0:	2100      	movs	r1, #0
 8019fd2:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8019fd4:	f00e fe26 	bl	8028c24 <memset>

    if (ret == 0) {
 8019fd8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019fda:	2b00      	cmp	r3, #0
 8019fdc:	d119      	bne.n	801a012 <wc_EccPrivateKeyDecode+0xd2>
        /* Get the version and set the expected OID type. */
        GetASN_Int8Bit(&dataASN[ECCKEYASN_IDX_VER], &version);
 8019fde:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019fe0:	331c      	adds	r3, #28
 8019fe2:	2201      	movs	r2, #1
 8019fe4:	761a      	strb	r2, [r3, #24]
 8019fe6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019fe8:	331c      	adds	r3, #28
 8019fea:	f107 021f 	add.w	r2, r7, #31
 8019fee:	609a      	str	r2, [r3, #8]
        GetASN_OID(&dataASN[ECCKEYASN_IDX_CURVEID], oidCurveType);
 8019ff0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019ff2:	3370      	adds	r3, #112	@ 0x70
 8019ff4:	2203      	movs	r2, #3
 8019ff6:	611a      	str	r2, [r3, #16]
        /* Decode the private ECC key. */
        ret = GetASN_Items(eccKeyASN, dataASN, eccKeyASN_Length, 1, input,
 8019ff8:	683b      	ldr	r3, [r7, #0]
 8019ffa:	9302      	str	r3, [sp, #8]
 8019ffc:	68bb      	ldr	r3, [r7, #8]
 8019ffe:	9301      	str	r3, [sp, #4]
 801a000:	68fb      	ldr	r3, [r7, #12]
 801a002:	9300      	str	r3, [sp, #0]
 801a004:	2301      	movs	r3, #1
 801a006:	2208      	movs	r2, #8
 801a008:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801a00a:	4829      	ldr	r0, [pc, #164]	@ (801a0b0 <wc_EccPrivateKeyDecode+0x170>)
 801a00c:	f7f9 fc30 	bl	8013870 <GetASN_Items>
 801a010:	62b8      	str	r0, [r7, #40]	@ 0x28
                           inOutIdx, inSz);
    }
    /* Only version 1 supported. */
    if (ret == 0) {
 801a012:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a014:	2b00      	cmp	r3, #0
 801a016:	d105      	bne.n	801a024 <wc_EccPrivateKeyDecode+0xe4>
        if (version != 1) {
 801a018:	7ffb      	ldrb	r3, [r7, #31]
 801a01a:	2b01      	cmp	r3, #1
 801a01c:	d002      	beq.n	801a024 <wc_EccPrivateKeyDecode+0xe4>
            ret = ASN_PARSE_E;
 801a01e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801a022:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
    /* Curve Parameters are optional. */
    if ((ret == 0) && (dataASN[ECCKEYASN_IDX_PARAMS].tag != 0)) {
 801a024:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a026:	2b00      	cmp	r3, #0
 801a028:	d11a      	bne.n	801a060 <wc_EccPrivateKeyDecode+0x120>
 801a02a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a02c:	3354      	adds	r3, #84	@ 0x54
 801a02e:	7e5b      	ldrb	r3, [r3, #25]
 801a030:	2b00      	cmp	r3, #0
 801a032:	d015      	beq.n	801a060 <wc_EccPrivateKeyDecode+0x120>
        if (dataASN[ECCKEYASN_IDX_CURVEID].tag != 0) {
 801a034:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a036:	3370      	adds	r3, #112	@ 0x70
 801a038:	7e5b      	ldrb	r3, [r3, #25]
 801a03a:	2b00      	cmp	r3, #0
 801a03c:	d00d      	beq.n	801a05a <wc_EccPrivateKeyDecode+0x11a>
            /* Named curve - check and get id. */
            curve_id = CheckCurve(dataASN[ECCKEYASN_IDX_CURVEID].data.oid.sum);
 801a03e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a040:	3370      	adds	r3, #112	@ 0x70
 801a042:	695b      	ldr	r3, [r3, #20]
 801a044:	4618      	mov	r0, r3
 801a046:	f7fa fbf1 	bl	801482c <CheckCurve>
 801a04a:	6278      	str	r0, [r7, #36]	@ 0x24
            if (curve_id < 0) {
 801a04c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a04e:	2b00      	cmp	r3, #0
 801a050:	da06      	bge.n	801a060 <wc_EccPrivateKeyDecode+0x120>
                ret = ECC_CURVE_OID_E;
 801a052:	f06f 03ab 	mvn.w	r3, #171	@ 0xab
 801a056:	62bb      	str	r3, [r7, #40]	@ 0x28
 801a058:	e002      	b.n	801a060 <wc_EccPrivateKeyDecode+0x120>
                    dataASN[ECCKEYASN_IDX_CURVEPARAMS].data.ref.data,
                    dataASN[ECCKEYASN_IDX_CURVEPARAMS].data.ref.length, key,
                    key->heap, NULL);
    #else
            /* Explicit parameters not supported in build configuration. */
            ret = ASN_PARSE_E;
 801a05a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801a05e:	62bb      	str	r3, [r7, #40]	@ 0x28
    #endif
        }
    }
    if (ret == 0) {
 801a060:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a062:	2b00      	cmp	r3, #0
 801a064:	d113      	bne.n	801a08e <wc_EccPrivateKeyDecode+0x14e>
        /* Import private key value and public point (may be NULL). */
        ret = wc_ecc_import_private_key_ex(
                dataASN[ECCKEYASN_IDX_PKEY].data.ref.data,
 801a066:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a068:	3338      	adds	r3, #56	@ 0x38
        ret = wc_ecc_import_private_key_ex(
 801a06a:	6898      	ldr	r0, [r3, #8]
                dataASN[ECCKEYASN_IDX_PKEY].data.ref.length,
 801a06c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a06e:	3338      	adds	r3, #56	@ 0x38
        ret = wc_ecc_import_private_key_ex(
 801a070:	68d9      	ldr	r1, [r3, #12]
                dataASN[ECCKEYASN_IDX_PUBKEY_VAL].data.ref.data,
 801a072:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a074:	33c4      	adds	r3, #196	@ 0xc4
        ret = wc_ecc_import_private_key_ex(
 801a076:	689a      	ldr	r2, [r3, #8]
                dataASN[ECCKEYASN_IDX_PUBKEY_VAL].data.ref.length,
 801a078:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a07a:	33c4      	adds	r3, #196	@ 0xc4
        ret = wc_ecc_import_private_key_ex(
 801a07c:	68dc      	ldr	r4, [r3, #12]
 801a07e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a080:	9301      	str	r3, [sp, #4]
 801a082:	687b      	ldr	r3, [r7, #4]
 801a084:	9300      	str	r3, [sp, #0]
 801a086:	4623      	mov	r3, r4
 801a088:	f004 f933 	bl	801e2f2 <wc_ecc_import_private_key_ex>
 801a08c:	62b8      	str	r0, [r7, #40]	@ 0x28
                key, curve_id);
    }

    FREE_ASNGETDATA(dataASN, key->heap);
 801a08e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a090:	2b00      	cmp	r3, #0
 801a092:	d007      	beq.n	801a0a4 <wc_EccPrivateKeyDecode+0x164>
 801a094:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a096:	623b      	str	r3, [r7, #32]
 801a098:	6a3b      	ldr	r3, [r7, #32]
 801a09a:	2b00      	cmp	r3, #0
 801a09c:	d002      	beq.n	801a0a4 <wc_EccPrivateKeyDecode+0x164>
 801a09e:	6a38      	ldr	r0, [r7, #32]
 801a0a0:	f004 fe08 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 801a0a4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif
}
 801a0a6:	4618      	mov	r0, r3
 801a0a8:	3734      	adds	r7, #52	@ 0x34
 801a0aa:	46bd      	mov	sp, r7
 801a0ac:	bd90      	pop	{r4, r7, pc}
 801a0ae:	bf00      	nop
 801a0b0:	0803484c 	.word	0x0803484c

0801a0b4 <wc_EccPublicKeyDecode>:
#endif /* WOLFSSL_CUSTOM_CURVES */

WOLFSSL_ABI
int wc_EccPublicKeyDecode(const byte* input, word32* inOutIdx,
                          ecc_key* key, word32 inSz)
{
 801a0b4:	b580      	push	{r7, lr}
 801a0b6:	b08e      	sub	sp, #56	@ 0x38
 801a0b8:	af04      	add	r7, sp, #16
 801a0ba:	60f8      	str	r0, [r7, #12]
 801a0bc:	60b9      	str	r1, [r7, #8]
 801a0be:	607a      	str	r2, [r7, #4]
 801a0c0:	603b      	str	r3, [r7, #0]
    *inOutIdx += (word32)length;

    return 0;
#else
    /* eccKeyASN is longer than eccPublicKeyASN. */
    DECL_ASNGETDATA(dataASN, eccKeyASN_Length);
 801a0c2:	2300      	movs	r3, #0
 801a0c4:	627b      	str	r3, [r7, #36]	@ 0x24
    int ret = 0;
 801a0c6:	2300      	movs	r3, #0
 801a0c8:	623b      	str	r3, [r7, #32]
    int curve_id = ECC_CURVE_DEF;
 801a0ca:	2300      	movs	r3, #0
 801a0cc:	61fb      	str	r3, [r7, #28]
    int oidIdx = ECCPUBLICKEYASN_IDX_ALGOID_CURVEID;
 801a0ce:	2303      	movs	r3, #3
 801a0d0:	61bb      	str	r3, [r7, #24]
#ifdef WOLFSSL_CUSTOM_CURVES
    int specIdx = ECCPUBLICKEYASN_IDX_ALGOID_PARAMS;
#endif
    int pubIdx = ECCPUBLICKEYASN_IDX_PUBKEY;
 801a0d2:	2305      	movs	r3, #5
 801a0d4:	617b      	str	r3, [r7, #20]

    if ((input == NULL) || (inOutIdx == NULL) || (key == NULL) || (inSz == 0)) {
 801a0d6:	68fb      	ldr	r3, [r7, #12]
 801a0d8:	2b00      	cmp	r3, #0
 801a0da:	d008      	beq.n	801a0ee <wc_EccPublicKeyDecode+0x3a>
 801a0dc:	68bb      	ldr	r3, [r7, #8]
 801a0de:	2b00      	cmp	r3, #0
 801a0e0:	d005      	beq.n	801a0ee <wc_EccPublicKeyDecode+0x3a>
 801a0e2:	687b      	ldr	r3, [r7, #4]
 801a0e4:	2b00      	cmp	r3, #0
 801a0e6:	d002      	beq.n	801a0ee <wc_EccPublicKeyDecode+0x3a>
 801a0e8:	683b      	ldr	r3, [r7, #0]
 801a0ea:	2b00      	cmp	r3, #0
 801a0ec:	d102      	bne.n	801a0f4 <wc_EccPublicKeyDecode+0x40>
        ret = BAD_FUNC_ARG;
 801a0ee:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a0f2:	623b      	str	r3, [r7, #32]
    }

    ALLOC_ASNGETDATA(dataASN, eccKeyASN_Length, ret, key->heap);
 801a0f4:	6a3b      	ldr	r3, [r7, #32]
 801a0f6:	2b00      	cmp	r3, #0
 801a0f8:	d109      	bne.n	801a10e <wc_EccPublicKeyDecode+0x5a>
 801a0fa:	20e0      	movs	r0, #224	@ 0xe0
 801a0fc:	f004 fdbe 	bl	801ec7c <wolfSSL_Malloc>
 801a100:	6278      	str	r0, [r7, #36]	@ 0x24
 801a102:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a104:	2b00      	cmp	r3, #0
 801a106:	d102      	bne.n	801a10e <wc_EccPublicKeyDecode+0x5a>
 801a108:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801a10c:	623b      	str	r3, [r7, #32]

    if (ret == 0) {
 801a10e:	6a3b      	ldr	r3, [r7, #32]
 801a110:	2b00      	cmp	r3, #0
 801a112:	d150      	bne.n	801a1b6 <wc_EccPublicKeyDecode+0x102>
        /* Clear dynamic data for ECC public key. */
        XMEMSET(dataASN, 0, sizeof(*dataASN) * eccPublicKeyASN_Length);
 801a114:	22a8      	movs	r2, #168	@ 0xa8
 801a116:	2100      	movs	r1, #0
 801a118:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801a11a:	f00e fd83 	bl	8028c24 <memset>
#if !defined(WOLFSSL_SM2) || !defined(WOLFSSL_SM3)
        /* Set required ECDSA OID and ignore the curve OID type. */
        GetASN_ExpBuffer(&dataASN[ECCPUBLICKEYASN_IDX_ALGOID_OID], keyEcdsaOid,
 801a11e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a120:	3338      	adds	r3, #56	@ 0x38
 801a122:	2206      	movs	r2, #6
 801a124:	761a      	strb	r2, [r3, #24]
 801a126:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a128:	3338      	adds	r3, #56	@ 0x38
 801a12a:	4a4d      	ldr	r2, [pc, #308]	@ (801a260 <wc_EccPublicKeyDecode+0x1ac>)
 801a12c:	609a      	str	r2, [r3, #8]
 801a12e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a130:	3338      	adds	r3, #56	@ 0x38
 801a132:	2207      	movs	r2, #7
 801a134:	60da      	str	r2, [r3, #12]
                sizeof(keyEcdsaOid));
#else
        GetASN_OID(&dataASN[ECCPUBLICKEYASN_IDX_ALGOID_OID], oidKeyType);
#endif
        GetASN_OID(&dataASN[oidIdx], oidCurveType);
 801a136:	69ba      	ldr	r2, [r7, #24]
 801a138:	4613      	mov	r3, r2
 801a13a:	00db      	lsls	r3, r3, #3
 801a13c:	1a9b      	subs	r3, r3, r2
 801a13e:	009b      	lsls	r3, r3, #2
 801a140:	461a      	mov	r2, r3
 801a142:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a144:	4413      	add	r3, r2
 801a146:	2203      	movs	r2, #3
 801a148:	611a      	str	r2, [r3, #16]
        /* Decode the public ECC key. */
        ret = GetASN_Items(eccPublicKeyASN, dataASN, eccPublicKeyASN_Length, 1,
 801a14a:	683b      	ldr	r3, [r7, #0]
 801a14c:	9302      	str	r3, [sp, #8]
 801a14e:	68bb      	ldr	r3, [r7, #8]
 801a150:	9301      	str	r3, [sp, #4]
 801a152:	68fb      	ldr	r3, [r7, #12]
 801a154:	9300      	str	r3, [sp, #0]
 801a156:	2301      	movs	r3, #1
 801a158:	2206      	movs	r2, #6
 801a15a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801a15c:	4841      	ldr	r0, [pc, #260]	@ (801a264 <wc_EccPublicKeyDecode+0x1b0>)
 801a15e:	f7f9 fb87 	bl	8013870 <GetASN_Items>
 801a162:	6238      	str	r0, [r7, #32]
                           input, inOutIdx, inSz);
        if (ret != 0) {
 801a164:	6a3b      	ldr	r3, [r7, #32]
 801a166:	2b00      	cmp	r3, #0
 801a168:	d025      	beq.n	801a1b6 <wc_EccPublicKeyDecode+0x102>
            oidIdx = ECCKEYASN_IDX_CURVEID;
 801a16a:	2304      	movs	r3, #4
 801a16c:	61bb      	str	r3, [r7, #24]
        #ifdef WOLFSSL_CUSTOM_CURVES
            specIdx = ECCKEYASN_IDX_CURVEPARAMS;
        #endif
            pubIdx = ECCKEYASN_IDX_PUBKEY_VAL;
 801a16e:	2307      	movs	r3, #7
 801a170:	617b      	str	r3, [r7, #20]

            /* Clear dynamic data for ECC private key. */
            XMEMSET(dataASN, 0, sizeof(*dataASN) * eccKeyASN_Length);
 801a172:	22e0      	movs	r2, #224	@ 0xe0
 801a174:	2100      	movs	r1, #0
 801a176:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801a178:	f00e fd54 	bl	8028c24 <memset>
            /* Check named curve OID type. */
            GetASN_OID(&dataASN[oidIdx], oidCurveType);
 801a17c:	69ba      	ldr	r2, [r7, #24]
 801a17e:	4613      	mov	r3, r2
 801a180:	00db      	lsls	r3, r3, #3
 801a182:	1a9b      	subs	r3, r3, r2
 801a184:	009b      	lsls	r3, r3, #2
 801a186:	461a      	mov	r2, r3
 801a188:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a18a:	4413      	add	r3, r2
 801a18c:	2203      	movs	r2, #3
 801a18e:	611a      	str	r2, [r3, #16]
            /* Try private key format .*/
            ret = GetASN_Items(eccKeyASN, dataASN, eccKeyASN_Length, 1, input,
 801a190:	683b      	ldr	r3, [r7, #0]
 801a192:	9302      	str	r3, [sp, #8]
 801a194:	68bb      	ldr	r3, [r7, #8]
 801a196:	9301      	str	r3, [sp, #4]
 801a198:	68fb      	ldr	r3, [r7, #12]
 801a19a:	9300      	str	r3, [sp, #0]
 801a19c:	2301      	movs	r3, #1
 801a19e:	2208      	movs	r2, #8
 801a1a0:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801a1a2:	4831      	ldr	r0, [pc, #196]	@ (801a268 <wc_EccPublicKeyDecode+0x1b4>)
 801a1a4:	f7f9 fb64 	bl	8013870 <GetASN_Items>
 801a1a8:	6238      	str	r0, [r7, #32]
                               inOutIdx, inSz);
            if (ret != 0) {
 801a1aa:	6a3b      	ldr	r3, [r7, #32]
 801a1ac:	2b00      	cmp	r3, #0
 801a1ae:	d002      	beq.n	801a1b6 <wc_EccPublicKeyDecode+0x102>
                ret = ASN_PARSE_E;
 801a1b0:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801a1b4:	623b      	str	r3, [r7, #32]
        if ((oidSum != ECDSAk) && (oidSum != SM2k)) {
            ret = ASN_PARSE_E;
        }
    }
#endif
    if (ret == 0) {
 801a1b6:	6a3b      	ldr	r3, [r7, #32]
 801a1b8:	2b00      	cmp	r3, #0
 801a1ba:	d121      	bne.n	801a200 <wc_EccPublicKeyDecode+0x14c>
        if (dataASN[oidIdx].tag != 0) {
 801a1bc:	69ba      	ldr	r2, [r7, #24]
 801a1be:	4613      	mov	r3, r2
 801a1c0:	00db      	lsls	r3, r3, #3
 801a1c2:	1a9b      	subs	r3, r3, r2
 801a1c4:	009b      	lsls	r3, r3, #2
 801a1c6:	461a      	mov	r2, r3
 801a1c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a1ca:	4413      	add	r3, r2
 801a1cc:	7e5b      	ldrb	r3, [r3, #25]
 801a1ce:	2b00      	cmp	r3, #0
 801a1d0:	d013      	beq.n	801a1fa <wc_EccPublicKeyDecode+0x146>
            /* Named curve - check and get id. */
            curve_id = CheckCurve(dataASN[oidIdx].data.oid.sum);
 801a1d2:	69ba      	ldr	r2, [r7, #24]
 801a1d4:	4613      	mov	r3, r2
 801a1d6:	00db      	lsls	r3, r3, #3
 801a1d8:	1a9b      	subs	r3, r3, r2
 801a1da:	009b      	lsls	r3, r3, #2
 801a1dc:	461a      	mov	r2, r3
 801a1de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a1e0:	4413      	add	r3, r2
 801a1e2:	695b      	ldr	r3, [r3, #20]
 801a1e4:	4618      	mov	r0, r3
 801a1e6:	f7fa fb21 	bl	801482c <CheckCurve>
 801a1ea:	61f8      	str	r0, [r7, #28]
            if (curve_id < 0) {
 801a1ec:	69fb      	ldr	r3, [r7, #28]
 801a1ee:	2b00      	cmp	r3, #0
 801a1f0:	da06      	bge.n	801a200 <wc_EccPublicKeyDecode+0x14c>
                ret = ASN_OBJECT_ID_E;
 801a1f2:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 801a1f6:	623b      	str	r3, [r7, #32]
 801a1f8:	e002      	b.n	801a200 <wc_EccPublicKeyDecode+0x14c>
            ret = EccSpecifiedECDomainDecode(dataASN[specIdx].data.ref.data,
                                         dataASN[specIdx].data.ref.length, key,
                                         key->heap, NULL);
        #else
            /* Explicit parameters not supported in build configuration. */
            ret = ASN_PARSE_E;
 801a1fa:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801a1fe:	623b      	str	r3, [r7, #32]
        #endif
        }
    }
    if (ret == 0) {
 801a200:	6a3b      	ldr	r3, [r7, #32]
 801a202:	2b00      	cmp	r3, #0
 801a204:	d11c      	bne.n	801a240 <wc_EccPublicKeyDecode+0x18c>
        /* Import public point. */
        ret = wc_ecc_import_x963_ex(dataASN[pubIdx].data.ref.data,
 801a206:	697a      	ldr	r2, [r7, #20]
 801a208:	4613      	mov	r3, r2
 801a20a:	00db      	lsls	r3, r3, #3
 801a20c:	1a9b      	subs	r3, r3, r2
 801a20e:	009b      	lsls	r3, r3, #2
 801a210:	461a      	mov	r2, r3
 801a212:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a214:	4413      	add	r3, r2
 801a216:	6898      	ldr	r0, [r3, #8]
                dataASN[pubIdx].data.ref.length, key, curve_id);
 801a218:	697a      	ldr	r2, [r7, #20]
 801a21a:	4613      	mov	r3, r2
 801a21c:	00db      	lsls	r3, r3, #3
 801a21e:	1a9b      	subs	r3, r3, r2
 801a220:	009b      	lsls	r3, r3, #2
 801a222:	461a      	mov	r2, r3
 801a224:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a226:	4413      	add	r3, r2
        ret = wc_ecc_import_x963_ex(dataASN[pubIdx].data.ref.data,
 801a228:	68d9      	ldr	r1, [r3, #12]
 801a22a:	69fb      	ldr	r3, [r7, #28]
 801a22c:	687a      	ldr	r2, [r7, #4]
 801a22e:	f003 ffa5 	bl	801e17c <wc_ecc_import_x963_ex>
 801a232:	6238      	str	r0, [r7, #32]
        if (ret != 0) {
 801a234:	6a3b      	ldr	r3, [r7, #32]
 801a236:	2b00      	cmp	r3, #0
 801a238:	d002      	beq.n	801a240 <wc_EccPublicKeyDecode+0x18c>
            ret = ASN_ECC_KEY_E;
 801a23a:	f06f 03aa 	mvn.w	r3, #170	@ 0xaa
 801a23e:	623b      	str	r3, [r7, #32]
        }
    }

    FREE_ASNGETDATA(dataASN, key->heap);
 801a240:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a242:	2b00      	cmp	r3, #0
 801a244:	d007      	beq.n	801a256 <wc_EccPublicKeyDecode+0x1a2>
 801a246:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a248:	613b      	str	r3, [r7, #16]
 801a24a:	693b      	ldr	r3, [r7, #16]
 801a24c:	2b00      	cmp	r3, #0
 801a24e:	d002      	beq.n	801a256 <wc_EccPublicKeyDecode+0x1a2>
 801a250:	6938      	ldr	r0, [r7, #16]
 801a252:	f004 fd2f 	bl	801ecb4 <wolfSSL_Free>
    return ret;
 801a256:	6a3b      	ldr	r3, [r7, #32]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801a258:	4618      	mov	r0, r3
 801a25a:	3728      	adds	r7, #40	@ 0x28
 801a25c:	46bd      	mov	sp, r7
 801a25e:	bd80      	pop	{r7, pc}
 801a260:	080343d4 	.word	0x080343d4
 801a264:	080345e8 	.word	0x080345e8
 801a268:	0803484c 	.word	0x0803484c

0801a26c <wc_RsaPublicKeyDecodeRaw>:
#if !defined(NO_RSA) && (!defined(NO_BIG_INT) || defined(WOLFSSL_SP_MATH))
/* import RSA public key elements (n, e) into RsaKey structure (key) */
/* this function does not use any ASN.1 parsing */
int wc_RsaPublicKeyDecodeRaw(const byte* n, word32 nSz, const byte* e,
                             word32 eSz, RsaKey* key)
{
 801a26c:	b580      	push	{r7, lr}
 801a26e:	b084      	sub	sp, #16
 801a270:	af00      	add	r7, sp, #0
 801a272:	60f8      	str	r0, [r7, #12]
 801a274:	60b9      	str	r1, [r7, #8]
 801a276:	607a      	str	r2, [r7, #4]
 801a278:	603b      	str	r3, [r7, #0]
    if (n == NULL || e == NULL || key == NULL)
 801a27a:	68fb      	ldr	r3, [r7, #12]
 801a27c:	2b00      	cmp	r3, #0
 801a27e:	d005      	beq.n	801a28c <wc_RsaPublicKeyDecodeRaw+0x20>
 801a280:	687b      	ldr	r3, [r7, #4]
 801a282:	2b00      	cmp	r3, #0
 801a284:	d002      	beq.n	801a28c <wc_RsaPublicKeyDecodeRaw+0x20>
 801a286:	69bb      	ldr	r3, [r7, #24]
 801a288:	2b00      	cmp	r3, #0
 801a28a:	d102      	bne.n	801a292 <wc_RsaPublicKeyDecodeRaw+0x26>
        return BAD_FUNC_ARG;
 801a28c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a290:	e049      	b.n	801a326 <wc_RsaPublicKeyDecodeRaw+0xba>

    key->type = RSA_PUBLIC;
 801a292:	69bb      	ldr	r3, [r7, #24]
 801a294:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801a298:	461a      	mov	r2, r3
 801a29a:	2300      	movs	r3, #0
 801a29c:	f8c2 3168 	str.w	r3, [r2, #360]	@ 0x168

    if (mp_init(&key->n) != MP_OKAY)
 801a2a0:	69bb      	ldr	r3, [r7, #24]
 801a2a2:	4618      	mov	r0, r3
 801a2a4:	f00c fb99 	bl	80269da <mp_init>
 801a2a8:	4603      	mov	r3, r0
 801a2aa:	2b00      	cmp	r3, #0
 801a2ac:	d002      	beq.n	801a2b4 <wc_RsaPublicKeyDecodeRaw+0x48>
        return MP_INIT_E;
 801a2ae:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 801a2b2:	e038      	b.n	801a326 <wc_RsaPublicKeyDecodeRaw+0xba>

    if (mp_read_unsigned_bin(&key->n, n, nSz) != 0) {
 801a2b4:	69bb      	ldr	r3, [r7, #24]
 801a2b6:	68ba      	ldr	r2, [r7, #8]
 801a2b8:	68f9      	ldr	r1, [r7, #12]
 801a2ba:	4618      	mov	r0, r3
 801a2bc:	f00c fd66 	bl	8026d8c <mp_read_unsigned_bin>
 801a2c0:	4603      	mov	r3, r0
 801a2c2:	2b00      	cmp	r3, #0
 801a2c4:	d006      	beq.n	801a2d4 <wc_RsaPublicKeyDecodeRaw+0x68>
        mp_clear(&key->n);
 801a2c6:	69bb      	ldr	r3, [r7, #24]
 801a2c8:	4618      	mov	r0, r3
 801a2ca:	f00c fc10 	bl	8026aee <mp_clear>
        return ASN_GETINT_E;
 801a2ce:	f06f 038d 	mvn.w	r3, #141	@ 0x8d
 801a2d2:	e028      	b.n	801a326 <wc_RsaPublicKeyDecodeRaw+0xba>
        mp_clear(&key->n);
        return ASN_GETINT_E;
    }
#endif /* HAVE_WOLF_BIGINT */

    if (mp_init(&key->e) != MP_OKAY) {
 801a2d4:	69bb      	ldr	r3, [r7, #24]
 801a2d6:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a2da:	4618      	mov	r0, r3
 801a2dc:	f00c fb7d 	bl	80269da <mp_init>
 801a2e0:	4603      	mov	r3, r0
 801a2e2:	2b00      	cmp	r3, #0
 801a2e4:	d006      	beq.n	801a2f4 <wc_RsaPublicKeyDecodeRaw+0x88>
        mp_clear(&key->n);
 801a2e6:	69bb      	ldr	r3, [r7, #24]
 801a2e8:	4618      	mov	r0, r3
 801a2ea:	f00c fc00 	bl	8026aee <mp_clear>
        return MP_INIT_E;
 801a2ee:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 801a2f2:	e018      	b.n	801a326 <wc_RsaPublicKeyDecodeRaw+0xba>
    }

    if (mp_read_unsigned_bin(&key->e, e, eSz) != 0) {
 801a2f4:	69bb      	ldr	r3, [r7, #24]
 801a2f6:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a2fa:	683a      	ldr	r2, [r7, #0]
 801a2fc:	6879      	ldr	r1, [r7, #4]
 801a2fe:	4618      	mov	r0, r3
 801a300:	f00c fd44 	bl	8026d8c <mp_read_unsigned_bin>
 801a304:	4603      	mov	r3, r0
 801a306:	2b00      	cmp	r3, #0
 801a308:	d00c      	beq.n	801a324 <wc_RsaPublicKeyDecodeRaw+0xb8>
        mp_clear(&key->n);
 801a30a:	69bb      	ldr	r3, [r7, #24]
 801a30c:	4618      	mov	r0, r3
 801a30e:	f00c fbee 	bl	8026aee <mp_clear>
        mp_clear(&key->e);
 801a312:	69bb      	ldr	r3, [r7, #24]
 801a314:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a318:	4618      	mov	r0, r3
 801a31a:	f00c fbe8 	bl	8026aee <mp_clear>
        return ASN_GETINT_E;
 801a31e:	f06f 038d 	mvn.w	r3, #141	@ 0x8d
 801a322:	e000      	b.n	801a326 <wc_RsaPublicKeyDecodeRaw+0xba>
    if (wc_InitRsaHw(key) != 0) {
        return BAD_STATE_E;
    }
#endif

    return 0;
 801a324:	2300      	movs	r3, #0
}
 801a326:	4618      	mov	r0, r3
 801a328:	3710      	adds	r7, #16
 801a32a:	46bd      	mov	sp, r7
 801a32c:	bd80      	pop	{r7, pc}
	...

0801a330 <Base64_Char2Val>:
/* 0x78: x y z           */    49,  50,  51
                            };
#define BASE64DECODE_SZ    (byte)(sizeof(base64Decode))

static WC_INLINE byte Base64_Char2Val(byte c)
{
 801a330:	b480      	push	{r7}
 801a332:	b085      	sub	sp, #20
 801a334:	af00      	add	r7, sp, #0
 801a336:	4603      	mov	r3, r0
 801a338:	71fb      	strb	r3, [r7, #7]
     * 64 bytes in a cache line - first line has 64, second has 16
     */
    byte v;
    byte mask;

    c = (byte)(c - BASE64_MIN);
 801a33a:	79fb      	ldrb	r3, [r7, #7]
 801a33c:	3b2b      	subs	r3, #43	@ 0x2b
 801a33e:	71fb      	strb	r3, [r7, #7]
    mask = (byte)((((byte)(0x3f - c)) >> 7) - 1);
 801a340:	79fb      	ldrb	r3, [r7, #7]
 801a342:	f1c3 033f 	rsb	r3, r3, #63	@ 0x3f
 801a346:	b2db      	uxtb	r3, r3
 801a348:	09db      	lsrs	r3, r3, #7
 801a34a:	b2db      	uxtb	r3, r3
 801a34c:	3b01      	subs	r3, #1
 801a34e:	73fb      	strb	r3, [r7, #15]
    /* Load a value from the first cache line and use when mask set. */
    v  = (byte)(base64Decode[ c & 0x3f        ] &   mask);
 801a350:	79fb      	ldrb	r3, [r7, #7]
 801a352:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801a356:	4a0f      	ldr	r2, [pc, #60]	@ (801a394 <Base64_Char2Val+0x64>)
 801a358:	5cd2      	ldrb	r2, [r2, r3]
 801a35a:	7bfb      	ldrb	r3, [r7, #15]
 801a35c:	4013      	ands	r3, r2
 801a35e:	73bb      	strb	r3, [r7, #14]
    /* Load a value from the second cache line and use when mask not set. */
    v |= (byte)(base64Decode[(c & 0x0f) | 0x40] & (~mask));
 801a360:	79fb      	ldrb	r3, [r7, #7]
 801a362:	f003 030f 	and.w	r3, r3, #15
 801a366:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801a36a:	4a0a      	ldr	r2, [pc, #40]	@ (801a394 <Base64_Char2Val+0x64>)
 801a36c:	5cd3      	ldrb	r3, [r2, r3]
 801a36e:	b25a      	sxtb	r2, r3
 801a370:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801a374:	43db      	mvns	r3, r3
 801a376:	b25b      	sxtb	r3, r3
 801a378:	4013      	ands	r3, r2
 801a37a:	b25b      	sxtb	r3, r3
 801a37c:	b2da      	uxtb	r2, r3
 801a37e:	7bbb      	ldrb	r3, [r7, #14]
 801a380:	4313      	orrs	r3, r2
 801a382:	73bb      	strb	r3, [r7, #14]

    return v;
 801a384:	7bbb      	ldrb	r3, [r7, #14]
#else
    return base64Decode[c - BASE64_MIN];
#endif
}
 801a386:	4618      	mov	r0, r3
 801a388:	3714      	adds	r7, #20
 801a38a:	46bd      	mov	sp, r7
 801a38c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a390:	4770      	bx	lr
 801a392:	bf00      	nop
 801a394:	08034878 	.word	0x08034878

0801a398 <Base64_SkipNewline>:
#endif

int Base64_SkipNewline(const byte* in, word32 *inLen,
  word32 *outJ)
{
 801a398:	b480      	push	{r7}
 801a39a:	b089      	sub	sp, #36	@ 0x24
 801a39c:	af00      	add	r7, sp, #0
 801a39e:	60f8      	str	r0, [r7, #12]
 801a3a0:	60b9      	str	r1, [r7, #8]
 801a3a2:	607a      	str	r2, [r7, #4]
    word32 len = *inLen;
 801a3a4:	68bb      	ldr	r3, [r7, #8]
 801a3a6:	681b      	ldr	r3, [r3, #0]
 801a3a8:	61fb      	str	r3, [r7, #28]
    word32 j = *outJ;
 801a3aa:	687b      	ldr	r3, [r7, #4]
 801a3ac:	681b      	ldr	r3, [r3, #0]
 801a3ae:	61bb      	str	r3, [r7, #24]
    byte curChar;

    if (len == 0) {
 801a3b0:	69fb      	ldr	r3, [r7, #28]
 801a3b2:	2b00      	cmp	r3, #0
 801a3b4:	d102      	bne.n	801a3bc <Base64_SkipNewline+0x24>
        return BUFFER_E;
 801a3b6:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801a3ba:	e065      	b.n	801a488 <Base64_SkipNewline+0xf0>
    }
    curChar = in[j];
 801a3bc:	68fa      	ldr	r2, [r7, #12]
 801a3be:	69bb      	ldr	r3, [r7, #24]
 801a3c0:	4413      	add	r3, r2
 801a3c2:	781b      	ldrb	r3, [r3, #0]
 801a3c4:	75fb      	strb	r3, [r7, #23]

    while (len > 1 && curChar == ' ') {
 801a3c6:	e00a      	b.n	801a3de <Base64_SkipNewline+0x46>
        /* skip whitespace in the middle or end of line */
        curChar = in[++j];
 801a3c8:	69bb      	ldr	r3, [r7, #24]
 801a3ca:	3301      	adds	r3, #1
 801a3cc:	61bb      	str	r3, [r7, #24]
 801a3ce:	68fa      	ldr	r2, [r7, #12]
 801a3d0:	69bb      	ldr	r3, [r7, #24]
 801a3d2:	4413      	add	r3, r2
 801a3d4:	781b      	ldrb	r3, [r3, #0]
 801a3d6:	75fb      	strb	r3, [r7, #23]
        len--;
 801a3d8:	69fb      	ldr	r3, [r7, #28]
 801a3da:	3b01      	subs	r3, #1
 801a3dc:	61fb      	str	r3, [r7, #28]
    while (len > 1 && curChar == ' ') {
 801a3de:	69fb      	ldr	r3, [r7, #28]
 801a3e0:	2b01      	cmp	r3, #1
 801a3e2:	d902      	bls.n	801a3ea <Base64_SkipNewline+0x52>
 801a3e4:	7dfb      	ldrb	r3, [r7, #23]
 801a3e6:	2b20      	cmp	r3, #32
 801a3e8:	d0ee      	beq.n	801a3c8 <Base64_SkipNewline+0x30>
    }
    if (len && (curChar == '\r' || curChar == '\n')) {
 801a3ea:	69fb      	ldr	r3, [r7, #28]
 801a3ec:	2b00      	cmp	r3, #0
 801a3ee:	d038      	beq.n	801a462 <Base64_SkipNewline+0xca>
 801a3f0:	7dfb      	ldrb	r3, [r7, #23]
 801a3f2:	2b0d      	cmp	r3, #13
 801a3f4:	d002      	beq.n	801a3fc <Base64_SkipNewline+0x64>
 801a3f6:	7dfb      	ldrb	r3, [r7, #23]
 801a3f8:	2b0a      	cmp	r3, #10
 801a3fa:	d132      	bne.n	801a462 <Base64_SkipNewline+0xca>
        j++;
 801a3fc:	69bb      	ldr	r3, [r7, #24]
 801a3fe:	3301      	adds	r3, #1
 801a400:	61bb      	str	r3, [r7, #24]
        len--;
 801a402:	69fb      	ldr	r3, [r7, #28]
 801a404:	3b01      	subs	r3, #1
 801a406:	61fb      	str	r3, [r7, #28]
        if (curChar == '\r') {
 801a408:	7dfb      	ldrb	r3, [r7, #23]
 801a40a:	2b0d      	cmp	r3, #13
 801a40c:	d10c      	bne.n	801a428 <Base64_SkipNewline+0x90>
            if (len) {
 801a40e:	69fb      	ldr	r3, [r7, #28]
 801a410:	2b00      	cmp	r3, #0
 801a412:	d009      	beq.n	801a428 <Base64_SkipNewline+0x90>
                curChar = in[j++];
 801a414:	69bb      	ldr	r3, [r7, #24]
 801a416:	1c5a      	adds	r2, r3, #1
 801a418:	61ba      	str	r2, [r7, #24]
 801a41a:	68fa      	ldr	r2, [r7, #12]
 801a41c:	4413      	add	r3, r2
 801a41e:	781b      	ldrb	r3, [r3, #0]
 801a420:	75fb      	strb	r3, [r7, #23]
                len--;
 801a422:	69fb      	ldr	r3, [r7, #28]
 801a424:	3b01      	subs	r3, #1
 801a426:	61fb      	str	r3, [r7, #28]
            }
        }
        if (curChar != '\n') {
 801a428:	7dfb      	ldrb	r3, [r7, #23]
 801a42a:	2b0a      	cmp	r3, #10
 801a42c:	d002      	beq.n	801a434 <Base64_SkipNewline+0x9c>
            WOLFSSL_MSG("Bad end of line in Base64 Decode");
            return ASN_INPUT_E;
 801a42e:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a432:	e029      	b.n	801a488 <Base64_SkipNewline+0xf0>
        }

        if (len) {
 801a434:	69fb      	ldr	r3, [r7, #28]
 801a436:	2b00      	cmp	r3, #0
 801a438:	d013      	beq.n	801a462 <Base64_SkipNewline+0xca>
            curChar = in[j];
 801a43a:	68fa      	ldr	r2, [r7, #12]
 801a43c:	69bb      	ldr	r3, [r7, #24]
 801a43e:	4413      	add	r3, r2
 801a440:	781b      	ldrb	r3, [r3, #0]
 801a442:	75fb      	strb	r3, [r7, #23]
        }
    }
    while (len && curChar == ' ') {
 801a444:	e00d      	b.n	801a462 <Base64_SkipNewline+0xca>
        if (--len > 0) {
 801a446:	69fb      	ldr	r3, [r7, #28]
 801a448:	3b01      	subs	r3, #1
 801a44a:	61fb      	str	r3, [r7, #28]
 801a44c:	69fb      	ldr	r3, [r7, #28]
 801a44e:	2b00      	cmp	r3, #0
 801a450:	d007      	beq.n	801a462 <Base64_SkipNewline+0xca>
            curChar = in[++j];
 801a452:	69bb      	ldr	r3, [r7, #24]
 801a454:	3301      	adds	r3, #1
 801a456:	61bb      	str	r3, [r7, #24]
 801a458:	68fa      	ldr	r2, [r7, #12]
 801a45a:	69bb      	ldr	r3, [r7, #24]
 801a45c:	4413      	add	r3, r2
 801a45e:	781b      	ldrb	r3, [r3, #0]
 801a460:	75fb      	strb	r3, [r7, #23]
    while (len && curChar == ' ') {
 801a462:	69fb      	ldr	r3, [r7, #28]
 801a464:	2b00      	cmp	r3, #0
 801a466:	d002      	beq.n	801a46e <Base64_SkipNewline+0xd6>
 801a468:	7dfb      	ldrb	r3, [r7, #23]
 801a46a:	2b20      	cmp	r3, #32
 801a46c:	d0eb      	beq.n	801a446 <Base64_SkipNewline+0xae>
        }
    }
    if (!len) {
 801a46e:	69fb      	ldr	r3, [r7, #28]
 801a470:	2b00      	cmp	r3, #0
 801a472:	d102      	bne.n	801a47a <Base64_SkipNewline+0xe2>
        return BUFFER_E;
 801a474:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801a478:	e006      	b.n	801a488 <Base64_SkipNewline+0xf0>
    }
    *inLen = len;
 801a47a:	68bb      	ldr	r3, [r7, #8]
 801a47c:	69fa      	ldr	r2, [r7, #28]
 801a47e:	601a      	str	r2, [r3, #0]
    *outJ = j;
 801a480:	687b      	ldr	r3, [r7, #4]
 801a482:	69ba      	ldr	r2, [r7, #24]
 801a484:	601a      	str	r2, [r3, #0]
    return 0;
 801a486:	2300      	movs	r3, #0
}
 801a488:	4618      	mov	r0, r3
 801a48a:	3724      	adds	r7, #36	@ 0x24
 801a48c:	46bd      	mov	sp, r7
 801a48e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a492:	4770      	bx	lr

0801a494 <Base64_Decode>:

int Base64_Decode(const byte* in, word32 inLen, byte* out, word32* outLen)
{
 801a494:	b580      	push	{r7, lr}
 801a496:	b08e      	sub	sp, #56	@ 0x38
 801a498:	af00      	add	r7, sp, #0
 801a49a:	60f8      	str	r0, [r7, #12]
 801a49c:	60b9      	str	r1, [r7, #8]
 801a49e:	607a      	str	r2, [r7, #4]
 801a4a0:	603b      	str	r3, [r7, #0]
    word32 i = 0;
 801a4a2:	2300      	movs	r3, #0
 801a4a4:	637b      	str	r3, [r7, #52]	@ 0x34
    word32 j = 0;
 801a4a6:	2300      	movs	r3, #0
 801a4a8:	617b      	str	r3, [r7, #20]
    word32 plainSz = inLen - ((inLen + (BASE64_LINE_SZ - 1)) / BASE64_LINE_SZ );
 801a4aa:	68ba      	ldr	r2, [r7, #8]
 801a4ac:	68bb      	ldr	r3, [r7, #8]
 801a4ae:	333f      	adds	r3, #63	@ 0x3f
 801a4b0:	099b      	lsrs	r3, r3, #6
 801a4b2:	1ad3      	subs	r3, r2, r3
 801a4b4:	62bb      	str	r3, [r7, #40]	@ 0x28
    int ret;
#ifndef BASE64_NO_TABLE
    const byte maxIdx = BASE64DECODE_SZ + BASE64_MIN - 1;
 801a4b6:	237a      	movs	r3, #122	@ 0x7a
 801a4b8:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
#endif

    plainSz = (plainSz * 3 + 3) / 4;
 801a4bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a4be:	1c5a      	adds	r2, r3, #1
 801a4c0:	4613      	mov	r3, r2
 801a4c2:	005b      	lsls	r3, r3, #1
 801a4c4:	4413      	add	r3, r2
 801a4c6:	089b      	lsrs	r3, r3, #2
 801a4c8:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (plainSz > *outLen) return BAD_FUNC_ARG;
 801a4ca:	683b      	ldr	r3, [r7, #0]
 801a4cc:	681b      	ldr	r3, [r3, #0]
 801a4ce:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801a4d0:	429a      	cmp	r2, r3
 801a4d2:	f240 812c 	bls.w	801a72e <Base64_Decode+0x29a>
 801a4d6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a4da:	e143      	b.n	801a764 <Base64_Decode+0x2d0>

    while (inLen > 3) {
        int pad3 = 0;
 801a4dc:	2300      	movs	r3, #0
 801a4de:	633b      	str	r3, [r7, #48]	@ 0x30
        int pad4 = 0;
 801a4e0:	2300      	movs	r3, #0
 801a4e2:	62fb      	str	r3, [r7, #44]	@ 0x2c
        byte b1, b2, b3;
        byte e1, e2, e3, e4;

        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a4e4:	f107 0214 	add.w	r2, r7, #20
 801a4e8:	f107 0308 	add.w	r3, r7, #8
 801a4ec:	4619      	mov	r1, r3
 801a4ee:	68f8      	ldr	r0, [r7, #12]
 801a4f0:	f7ff ff52 	bl	801a398 <Base64_SkipNewline>
 801a4f4:	6238      	str	r0, [r7, #32]
 801a4f6:	6a3b      	ldr	r3, [r7, #32]
 801a4f8:	2b00      	cmp	r3, #0
 801a4fa:	d006      	beq.n	801a50a <Base64_Decode+0x76>
            if (ret == WC_NO_ERR_TRACE(BUFFER_E)) {
 801a4fc:	6a3b      	ldr	r3, [r7, #32]
 801a4fe:	f113 0f84 	cmn.w	r3, #132	@ 0x84
 801a502:	f000 8119 	beq.w	801a738 <Base64_Decode+0x2a4>
                /* Running out of buffer here is not an error */
                break;
            }
            return ret;
 801a506:	6a3b      	ldr	r3, [r7, #32]
 801a508:	e12c      	b.n	801a764 <Base64_Decode+0x2d0>
        }
        e1 = in[j++];
 801a50a:	697b      	ldr	r3, [r7, #20]
 801a50c:	1c5a      	adds	r2, r3, #1
 801a50e:	617a      	str	r2, [r7, #20]
 801a510:	68fa      	ldr	r2, [r7, #12]
 801a512:	4413      	add	r3, r2
 801a514:	781b      	ldrb	r3, [r3, #0]
 801a516:	77fb      	strb	r3, [r7, #31]
        if (e1 == '\0') {
 801a518:	7ffb      	ldrb	r3, [r7, #31]
 801a51a:	2b00      	cmp	r3, #0
 801a51c:	f000 810e 	beq.w	801a73c <Base64_Decode+0x2a8>
            break;
        }
        inLen--;
 801a520:	68bb      	ldr	r3, [r7, #8]
 801a522:	3b01      	subs	r3, #1
 801a524:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a526:	f107 0214 	add.w	r2, r7, #20
 801a52a:	f107 0308 	add.w	r3, r7, #8
 801a52e:	4619      	mov	r1, r3
 801a530:	68f8      	ldr	r0, [r7, #12]
 801a532:	f7ff ff31 	bl	801a398 <Base64_SkipNewline>
 801a536:	6238      	str	r0, [r7, #32]
 801a538:	6a3b      	ldr	r3, [r7, #32]
 801a53a:	2b00      	cmp	r3, #0
 801a53c:	d001      	beq.n	801a542 <Base64_Decode+0xae>
            return ret;
 801a53e:	6a3b      	ldr	r3, [r7, #32]
 801a540:	e110      	b.n	801a764 <Base64_Decode+0x2d0>
        }
        e2 = in[j++];
 801a542:	697b      	ldr	r3, [r7, #20]
 801a544:	1c5a      	adds	r2, r3, #1
 801a546:	617a      	str	r2, [r7, #20]
 801a548:	68fa      	ldr	r2, [r7, #12]
 801a54a:	4413      	add	r3, r2
 801a54c:	781b      	ldrb	r3, [r3, #0]
 801a54e:	77bb      	strb	r3, [r7, #30]
        inLen--;
 801a550:	68bb      	ldr	r3, [r7, #8]
 801a552:	3b01      	subs	r3, #1
 801a554:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a556:	f107 0214 	add.w	r2, r7, #20
 801a55a:	f107 0308 	add.w	r3, r7, #8
 801a55e:	4619      	mov	r1, r3
 801a560:	68f8      	ldr	r0, [r7, #12]
 801a562:	f7ff ff19 	bl	801a398 <Base64_SkipNewline>
 801a566:	6238      	str	r0, [r7, #32]
 801a568:	6a3b      	ldr	r3, [r7, #32]
 801a56a:	2b00      	cmp	r3, #0
 801a56c:	d001      	beq.n	801a572 <Base64_Decode+0xde>
            return ret;
 801a56e:	6a3b      	ldr	r3, [r7, #32]
 801a570:	e0f8      	b.n	801a764 <Base64_Decode+0x2d0>
        }
        e3 = in[j++];
 801a572:	697b      	ldr	r3, [r7, #20]
 801a574:	1c5a      	adds	r2, r3, #1
 801a576:	617a      	str	r2, [r7, #20]
 801a578:	68fa      	ldr	r2, [r7, #12]
 801a57a:	4413      	add	r3, r2
 801a57c:	781b      	ldrb	r3, [r3, #0]
 801a57e:	777b      	strb	r3, [r7, #29]
        inLen--;
 801a580:	68bb      	ldr	r3, [r7, #8]
 801a582:	3b01      	subs	r3, #1
 801a584:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a586:	f107 0214 	add.w	r2, r7, #20
 801a58a:	f107 0308 	add.w	r3, r7, #8
 801a58e:	4619      	mov	r1, r3
 801a590:	68f8      	ldr	r0, [r7, #12]
 801a592:	f7ff ff01 	bl	801a398 <Base64_SkipNewline>
 801a596:	6238      	str	r0, [r7, #32]
 801a598:	6a3b      	ldr	r3, [r7, #32]
 801a59a:	2b00      	cmp	r3, #0
 801a59c:	d001      	beq.n	801a5a2 <Base64_Decode+0x10e>
            return ret;
 801a59e:	6a3b      	ldr	r3, [r7, #32]
 801a5a0:	e0e0      	b.n	801a764 <Base64_Decode+0x2d0>
        }
        e4 = in[j++];
 801a5a2:	697b      	ldr	r3, [r7, #20]
 801a5a4:	1c5a      	adds	r2, r3, #1
 801a5a6:	617a      	str	r2, [r7, #20]
 801a5a8:	68fa      	ldr	r2, [r7, #12]
 801a5aa:	4413      	add	r3, r2
 801a5ac:	781b      	ldrb	r3, [r3, #0]
 801a5ae:	773b      	strb	r3, [r7, #28]
        inLen--;
 801a5b0:	68bb      	ldr	r3, [r7, #8]
 801a5b2:	3b01      	subs	r3, #1
 801a5b4:	60bb      	str	r3, [r7, #8]

        if (e3 == PAD)
 801a5b6:	7f7b      	ldrb	r3, [r7, #29]
 801a5b8:	2b3d      	cmp	r3, #61	@ 0x3d
 801a5ba:	d101      	bne.n	801a5c0 <Base64_Decode+0x12c>
            pad3 = 1;
 801a5bc:	2301      	movs	r3, #1
 801a5be:	633b      	str	r3, [r7, #48]	@ 0x30
        if (e4 == PAD)
 801a5c0:	7f3b      	ldrb	r3, [r7, #28]
 801a5c2:	2b3d      	cmp	r3, #61	@ 0x3d
 801a5c4:	d101      	bne.n	801a5ca <Base64_Decode+0x136>
            pad4 = 1;
 801a5c6:	2301      	movs	r3, #1
 801a5c8:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if (pad3 && !pad4)
 801a5ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801a5cc:	2b00      	cmp	r3, #0
 801a5ce:	d005      	beq.n	801a5dc <Base64_Decode+0x148>
 801a5d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a5d2:	2b00      	cmp	r3, #0
 801a5d4:	d102      	bne.n	801a5dc <Base64_Decode+0x148>
            return ASN_INPUT_E;
 801a5d6:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a5da:	e0c3      	b.n	801a764 <Base64_Decode+0x2d0>

#ifndef BASE64_NO_TABLE
        if (e1 < BASE64_MIN || e2 < BASE64_MIN || e3 < BASE64_MIN ||
 801a5dc:	7ffb      	ldrb	r3, [r7, #31]
 801a5de:	2b2a      	cmp	r3, #42	@ 0x2a
 801a5e0:	d908      	bls.n	801a5f4 <Base64_Decode+0x160>
 801a5e2:	7fbb      	ldrb	r3, [r7, #30]
 801a5e4:	2b2a      	cmp	r3, #42	@ 0x2a
 801a5e6:	d905      	bls.n	801a5f4 <Base64_Decode+0x160>
 801a5e8:	7f7b      	ldrb	r3, [r7, #29]
 801a5ea:	2b2a      	cmp	r3, #42	@ 0x2a
 801a5ec:	d902      	bls.n	801a5f4 <Base64_Decode+0x160>
 801a5ee:	7f3b      	ldrb	r3, [r7, #28]
 801a5f0:	2b2a      	cmp	r3, #42	@ 0x2a
 801a5f2:	d802      	bhi.n	801a5fa <Base64_Decode+0x166>
                                                              e4 < BASE64_MIN) {
            WOLFSSL_MSG("Bad Base64 Decode data, too small");
            return ASN_INPUT_E;
 801a5f4:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a5f8:	e0b4      	b.n	801a764 <Base64_Decode+0x2d0>
        }

        if (e1 > maxIdx || e2 > maxIdx || e3 > maxIdx || e4 > maxIdx) {
 801a5fa:	7ffa      	ldrb	r2, [r7, #31]
 801a5fc:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a600:	429a      	cmp	r2, r3
 801a602:	d80e      	bhi.n	801a622 <Base64_Decode+0x18e>
 801a604:	7fba      	ldrb	r2, [r7, #30]
 801a606:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a60a:	429a      	cmp	r2, r3
 801a60c:	d809      	bhi.n	801a622 <Base64_Decode+0x18e>
 801a60e:	7f7a      	ldrb	r2, [r7, #29]
 801a610:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a614:	429a      	cmp	r2, r3
 801a616:	d804      	bhi.n	801a622 <Base64_Decode+0x18e>
 801a618:	7f3a      	ldrb	r2, [r7, #28]
 801a61a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a61e:	429a      	cmp	r2, r3
 801a620:	d902      	bls.n	801a628 <Base64_Decode+0x194>
            WOLFSSL_MSG("Bad Base64 Decode data, too big");
            return ASN_INPUT_E;
 801a622:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a626:	e09d      	b.n	801a764 <Base64_Decode+0x2d0>
        }
#endif

        if (i + 1 + !pad3 + !pad4 > *outLen) {
 801a628:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801a62a:	2b00      	cmp	r3, #0
 801a62c:	bf0c      	ite	eq
 801a62e:	2301      	moveq	r3, #1
 801a630:	2300      	movne	r3, #0
 801a632:	b2db      	uxtb	r3, r3
 801a634:	461a      	mov	r2, r3
 801a636:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a638:	4413      	add	r3, r2
 801a63a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801a63c:	2a00      	cmp	r2, #0
 801a63e:	bf0c      	ite	eq
 801a640:	2201      	moveq	r2, #1
 801a642:	2200      	movne	r2, #0
 801a644:	b2d2      	uxtb	r2, r2
 801a646:	4413      	add	r3, r2
 801a648:	1c5a      	adds	r2, r3, #1
 801a64a:	683b      	ldr	r3, [r7, #0]
 801a64c:	681b      	ldr	r3, [r3, #0]
 801a64e:	429a      	cmp	r2, r3
 801a650:	d902      	bls.n	801a658 <Base64_Decode+0x1c4>
            WOLFSSL_MSG("Bad Base64 Decode out buffer, too small");
            return BAD_FUNC_ARG;
 801a652:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a656:	e085      	b.n	801a764 <Base64_Decode+0x2d0>
        }

        e1 = Base64_Char2Val(e1);
 801a658:	7ffb      	ldrb	r3, [r7, #31]
 801a65a:	4618      	mov	r0, r3
 801a65c:	f7ff fe68 	bl	801a330 <Base64_Char2Val>
 801a660:	4603      	mov	r3, r0
 801a662:	77fb      	strb	r3, [r7, #31]
        e2 = Base64_Char2Val(e2);
 801a664:	7fbb      	ldrb	r3, [r7, #30]
 801a666:	4618      	mov	r0, r3
 801a668:	f7ff fe62 	bl	801a330 <Base64_Char2Val>
 801a66c:	4603      	mov	r3, r0
 801a66e:	77bb      	strb	r3, [r7, #30]
        e3 = (byte)((e3 == PAD) ? 0 : Base64_Char2Val(e3));
 801a670:	7f7b      	ldrb	r3, [r7, #29]
 801a672:	2b3d      	cmp	r3, #61	@ 0x3d
 801a674:	d005      	beq.n	801a682 <Base64_Decode+0x1ee>
 801a676:	7f7b      	ldrb	r3, [r7, #29]
 801a678:	4618      	mov	r0, r3
 801a67a:	f7ff fe59 	bl	801a330 <Base64_Char2Val>
 801a67e:	4603      	mov	r3, r0
 801a680:	e000      	b.n	801a684 <Base64_Decode+0x1f0>
 801a682:	2300      	movs	r3, #0
 801a684:	777b      	strb	r3, [r7, #29]
        e4 = (byte)((e4 == PAD) ? 0 : Base64_Char2Val(e4));
 801a686:	7f3b      	ldrb	r3, [r7, #28]
 801a688:	2b3d      	cmp	r3, #61	@ 0x3d
 801a68a:	d005      	beq.n	801a698 <Base64_Decode+0x204>
 801a68c:	7f3b      	ldrb	r3, [r7, #28]
 801a68e:	4618      	mov	r0, r3
 801a690:	f7ff fe4e 	bl	801a330 <Base64_Char2Val>
 801a694:	4603      	mov	r3, r0
 801a696:	e000      	b.n	801a69a <Base64_Decode+0x206>
 801a698:	2300      	movs	r3, #0
 801a69a:	773b      	strb	r3, [r7, #28]

        if (e1 == BAD || e2 == BAD || e3 == BAD || e4 == BAD) {
 801a69c:	7ffb      	ldrb	r3, [r7, #31]
 801a69e:	2bff      	cmp	r3, #255	@ 0xff
 801a6a0:	d008      	beq.n	801a6b4 <Base64_Decode+0x220>
 801a6a2:	7fbb      	ldrb	r3, [r7, #30]
 801a6a4:	2bff      	cmp	r3, #255	@ 0xff
 801a6a6:	d005      	beq.n	801a6b4 <Base64_Decode+0x220>
 801a6a8:	7f7b      	ldrb	r3, [r7, #29]
 801a6aa:	2bff      	cmp	r3, #255	@ 0xff
 801a6ac:	d002      	beq.n	801a6b4 <Base64_Decode+0x220>
 801a6ae:	7f3b      	ldrb	r3, [r7, #28]
 801a6b0:	2bff      	cmp	r3, #255	@ 0xff
 801a6b2:	d102      	bne.n	801a6ba <Base64_Decode+0x226>
            WOLFSSL_MSG("Bad Base64 Decode bad character");
            return ASN_INPUT_E;
 801a6b4:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a6b8:	e054      	b.n	801a764 <Base64_Decode+0x2d0>
        }

        b1 = (byte)((e1 << 2) | (e2 >> 4));
 801a6ba:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801a6be:	009b      	lsls	r3, r3, #2
 801a6c0:	b25a      	sxtb	r2, r3
 801a6c2:	7fbb      	ldrb	r3, [r7, #30]
 801a6c4:	091b      	lsrs	r3, r3, #4
 801a6c6:	b2db      	uxtb	r3, r3
 801a6c8:	b25b      	sxtb	r3, r3
 801a6ca:	4313      	orrs	r3, r2
 801a6cc:	b25b      	sxtb	r3, r3
 801a6ce:	76fb      	strb	r3, [r7, #27]
        b2 = (byte)(((e2 & 0xF) << 4) | (e3 >> 2));
 801a6d0:	f997 301e 	ldrsb.w	r3, [r7, #30]
 801a6d4:	011b      	lsls	r3, r3, #4
 801a6d6:	b25a      	sxtb	r2, r3
 801a6d8:	7f7b      	ldrb	r3, [r7, #29]
 801a6da:	089b      	lsrs	r3, r3, #2
 801a6dc:	b2db      	uxtb	r3, r3
 801a6de:	b25b      	sxtb	r3, r3
 801a6e0:	4313      	orrs	r3, r2
 801a6e2:	b25b      	sxtb	r3, r3
 801a6e4:	76bb      	strb	r3, [r7, #26]
        b3 = (byte)(((e3 & 0x3) << 6) | e4);
 801a6e6:	f997 301d 	ldrsb.w	r3, [r7, #29]
 801a6ea:	019b      	lsls	r3, r3, #6
 801a6ec:	b25a      	sxtb	r2, r3
 801a6ee:	f997 301c 	ldrsb.w	r3, [r7, #28]
 801a6f2:	4313      	orrs	r3, r2
 801a6f4:	b25b      	sxtb	r3, r3
 801a6f6:	767b      	strb	r3, [r7, #25]

        out[i++] = b1;
 801a6f8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a6fa:	1c5a      	adds	r2, r3, #1
 801a6fc:	637a      	str	r2, [r7, #52]	@ 0x34
 801a6fe:	687a      	ldr	r2, [r7, #4]
 801a700:	4413      	add	r3, r2
 801a702:	7efa      	ldrb	r2, [r7, #27]
 801a704:	701a      	strb	r2, [r3, #0]
        if (!pad3)
 801a706:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801a708:	2b00      	cmp	r3, #0
 801a70a:	d106      	bne.n	801a71a <Base64_Decode+0x286>
            out[i++] = b2;
 801a70c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a70e:	1c5a      	adds	r2, r3, #1
 801a710:	637a      	str	r2, [r7, #52]	@ 0x34
 801a712:	687a      	ldr	r2, [r7, #4]
 801a714:	4413      	add	r3, r2
 801a716:	7eba      	ldrb	r2, [r7, #26]
 801a718:	701a      	strb	r2, [r3, #0]
        if (!pad4)
 801a71a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a71c:	2b00      	cmp	r3, #0
 801a71e:	d10f      	bne.n	801a740 <Base64_Decode+0x2ac>
            out[i++] = b3;
 801a720:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a722:	1c5a      	adds	r2, r3, #1
 801a724:	637a      	str	r2, [r7, #52]	@ 0x34
 801a726:	687a      	ldr	r2, [r7, #4]
 801a728:	4413      	add	r3, r2
 801a72a:	7e7a      	ldrb	r2, [r7, #25]
 801a72c:	701a      	strb	r2, [r3, #0]
    while (inLen > 3) {
 801a72e:	68bb      	ldr	r3, [r7, #8]
 801a730:	2b03      	cmp	r3, #3
 801a732:	f63f aed3 	bhi.w	801a4dc <Base64_Decode+0x48>
 801a736:	e004      	b.n	801a742 <Base64_Decode+0x2ae>
                break;
 801a738:	bf00      	nop
 801a73a:	e002      	b.n	801a742 <Base64_Decode+0x2ae>
            break;
 801a73c:	bf00      	nop
 801a73e:	e000      	b.n	801a742 <Base64_Decode+0x2ae>
        else
            break;
 801a740:	bf00      	nop
    }
/* If the output buffer has a room for an extra byte, add a null terminator */
    if (out && *outLen > i)
 801a742:	687b      	ldr	r3, [r7, #4]
 801a744:	2b00      	cmp	r3, #0
 801a746:	d009      	beq.n	801a75c <Base64_Decode+0x2c8>
 801a748:	683b      	ldr	r3, [r7, #0]
 801a74a:	681b      	ldr	r3, [r3, #0]
 801a74c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801a74e:	429a      	cmp	r2, r3
 801a750:	d204      	bcs.n	801a75c <Base64_Decode+0x2c8>
        out[i]= '\0';
 801a752:	687a      	ldr	r2, [r7, #4]
 801a754:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a756:	4413      	add	r3, r2
 801a758:	2200      	movs	r2, #0
 801a75a:	701a      	strb	r2, [r3, #0]

    *outLen = i;
 801a75c:	683b      	ldr	r3, [r7, #0]
 801a75e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801a760:	601a      	str	r2, [r3, #0]

    return 0;
 801a762:	2300      	movs	r3, #0
}
 801a764:	4618      	mov	r0, r3
 801a766:	3738      	adds	r7, #56	@ 0x38
 801a768:	46bd      	mov	sp, r7
 801a76a:	bd80      	pop	{r7, pc}

0801a76c <Base16_Decode>:
                           BAD, BAD,  /* G - ` */
                           10, 11, 12, 13, 14, 15   /* lower case a-f */
                         };  /* A starts at 0x41 not 0x3A */

int Base16_Decode(const byte* in, word32 inLen, byte* out, word32* outLen)
{
 801a76c:	b480      	push	{r7}
 801a76e:	b089      	sub	sp, #36	@ 0x24
 801a770:	af00      	add	r7, sp, #0
 801a772:	60f8      	str	r0, [r7, #12]
 801a774:	60b9      	str	r1, [r7, #8]
 801a776:	607a      	str	r2, [r7, #4]
 801a778:	603b      	str	r3, [r7, #0]
    word32 inIdx  = 0;
 801a77a:	2300      	movs	r3, #0
 801a77c:	61fb      	str	r3, [r7, #28]
    word32 outIdx = 0;
 801a77e:	2300      	movs	r3, #0
 801a780:	61bb      	str	r3, [r7, #24]

    if (in == NULL || out == NULL || outLen == NULL)
 801a782:	68fb      	ldr	r3, [r7, #12]
 801a784:	2b00      	cmp	r3, #0
 801a786:	d005      	beq.n	801a794 <Base16_Decode+0x28>
 801a788:	687b      	ldr	r3, [r7, #4]
 801a78a:	2b00      	cmp	r3, #0
 801a78c:	d002      	beq.n	801a794 <Base16_Decode+0x28>
 801a78e:	683b      	ldr	r3, [r7, #0]
 801a790:	2b00      	cmp	r3, #0
 801a792:	d102      	bne.n	801a79a <Base16_Decode+0x2e>
        return BAD_FUNC_ARG;
 801a794:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a798:	e084      	b.n	801a8a4 <Base16_Decode+0x138>

    if (inLen == 1 && *outLen && in) {
 801a79a:	68bb      	ldr	r3, [r7, #8]
 801a79c:	2b01      	cmp	r3, #1
 801a79e:	d12a      	bne.n	801a7f6 <Base16_Decode+0x8a>
 801a7a0:	683b      	ldr	r3, [r7, #0]
 801a7a2:	681b      	ldr	r3, [r3, #0]
 801a7a4:	2b00      	cmp	r3, #0
 801a7a6:	d026      	beq.n	801a7f6 <Base16_Decode+0x8a>
 801a7a8:	68fb      	ldr	r3, [r7, #12]
 801a7aa:	2b00      	cmp	r3, #0
 801a7ac:	d023      	beq.n	801a7f6 <Base16_Decode+0x8a>
        byte b = (byte)(in[inIdx++] - BASE16_MIN);  /* 0 starts at 0x30 */
 801a7ae:	69fb      	ldr	r3, [r7, #28]
 801a7b0:	1c5a      	adds	r2, r3, #1
 801a7b2:	61fa      	str	r2, [r7, #28]
 801a7b4:	68fa      	ldr	r2, [r7, #12]
 801a7b6:	4413      	add	r3, r2
 801a7b8:	781b      	ldrb	r3, [r3, #0]
 801a7ba:	3b30      	subs	r3, #48	@ 0x30
 801a7bc:	75fb      	strb	r3, [r7, #23]

        /* sanity check */
        if (b >=  sizeof(hexDecode)/sizeof(hexDecode[0]))
 801a7be:	7dfb      	ldrb	r3, [r7, #23]
 801a7c0:	2b36      	cmp	r3, #54	@ 0x36
 801a7c2:	d902      	bls.n	801a7ca <Base16_Decode+0x5e>
            return ASN_INPUT_E;
 801a7c4:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a7c8:	e06c      	b.n	801a8a4 <Base16_Decode+0x138>

        b  = hexDecode[b];
 801a7ca:	7dfb      	ldrb	r3, [r7, #23]
 801a7cc:	4a38      	ldr	r2, [pc, #224]	@ (801a8b0 <Base16_Decode+0x144>)
 801a7ce:	5cd3      	ldrb	r3, [r2, r3]
 801a7d0:	75fb      	strb	r3, [r7, #23]

        if (b == BAD)
 801a7d2:	7dfb      	ldrb	r3, [r7, #23]
 801a7d4:	2bff      	cmp	r3, #255	@ 0xff
 801a7d6:	d102      	bne.n	801a7de <Base16_Decode+0x72>
            return ASN_INPUT_E;
 801a7d8:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a7dc:	e062      	b.n	801a8a4 <Base16_Decode+0x138>

        out[outIdx++] = b;
 801a7de:	69bb      	ldr	r3, [r7, #24]
 801a7e0:	1c5a      	adds	r2, r3, #1
 801a7e2:	61ba      	str	r2, [r7, #24]
 801a7e4:	687a      	ldr	r2, [r7, #4]
 801a7e6:	4413      	add	r3, r2
 801a7e8:	7dfa      	ldrb	r2, [r7, #23]
 801a7ea:	701a      	strb	r2, [r3, #0]

        *outLen = outIdx;
 801a7ec:	683b      	ldr	r3, [r7, #0]
 801a7ee:	69ba      	ldr	r2, [r7, #24]
 801a7f0:	601a      	str	r2, [r3, #0]
        return 0;
 801a7f2:	2300      	movs	r3, #0
 801a7f4:	e056      	b.n	801a8a4 <Base16_Decode+0x138>
    }

    if (inLen % 2)
 801a7f6:	68bb      	ldr	r3, [r7, #8]
 801a7f8:	f003 0301 	and.w	r3, r3, #1
 801a7fc:	2b00      	cmp	r3, #0
 801a7fe:	d002      	beq.n	801a806 <Base16_Decode+0x9a>
        return BAD_FUNC_ARG;
 801a800:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a804:	e04e      	b.n	801a8a4 <Base16_Decode+0x138>

    if (*outLen < (inLen / 2))
 801a806:	683b      	ldr	r3, [r7, #0]
 801a808:	681a      	ldr	r2, [r3, #0]
 801a80a:	68bb      	ldr	r3, [r7, #8]
 801a80c:	085b      	lsrs	r3, r3, #1
 801a80e:	429a      	cmp	r2, r3
 801a810:	d241      	bcs.n	801a896 <Base16_Decode+0x12a>
        return BAD_FUNC_ARG;
 801a812:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a816:	e045      	b.n	801a8a4 <Base16_Decode+0x138>

    while (inLen) {
        byte b  = (byte)(in[inIdx++] - BASE16_MIN);  /* 0 starts at 0x30 */
 801a818:	69fb      	ldr	r3, [r7, #28]
 801a81a:	1c5a      	adds	r2, r3, #1
 801a81c:	61fa      	str	r2, [r7, #28]
 801a81e:	68fa      	ldr	r2, [r7, #12]
 801a820:	4413      	add	r3, r2
 801a822:	781b      	ldrb	r3, [r3, #0]
 801a824:	3b30      	subs	r3, #48	@ 0x30
 801a826:	75bb      	strb	r3, [r7, #22]
        byte b2 = (byte)(in[inIdx++] - BASE16_MIN);
 801a828:	69fb      	ldr	r3, [r7, #28]
 801a82a:	1c5a      	adds	r2, r3, #1
 801a82c:	61fa      	str	r2, [r7, #28]
 801a82e:	68fa      	ldr	r2, [r7, #12]
 801a830:	4413      	add	r3, r2
 801a832:	781b      	ldrb	r3, [r3, #0]
 801a834:	3b30      	subs	r3, #48	@ 0x30
 801a836:	757b      	strb	r3, [r7, #21]

        /* sanity checks */
        if (b >=  sizeof(hexDecode)/sizeof(hexDecode[0]))
 801a838:	7dbb      	ldrb	r3, [r7, #22]
 801a83a:	2b36      	cmp	r3, #54	@ 0x36
 801a83c:	d902      	bls.n	801a844 <Base16_Decode+0xd8>
            return ASN_INPUT_E;
 801a83e:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a842:	e02f      	b.n	801a8a4 <Base16_Decode+0x138>
        if (b2 >= sizeof(hexDecode)/sizeof(hexDecode[0]))
 801a844:	7d7b      	ldrb	r3, [r7, #21]
 801a846:	2b36      	cmp	r3, #54	@ 0x36
 801a848:	d902      	bls.n	801a850 <Base16_Decode+0xe4>
            return ASN_INPUT_E;
 801a84a:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a84e:	e029      	b.n	801a8a4 <Base16_Decode+0x138>

        b  = hexDecode[b];
 801a850:	7dbb      	ldrb	r3, [r7, #22]
 801a852:	4a17      	ldr	r2, [pc, #92]	@ (801a8b0 <Base16_Decode+0x144>)
 801a854:	5cd3      	ldrb	r3, [r2, r3]
 801a856:	75bb      	strb	r3, [r7, #22]
        b2 = hexDecode[b2];
 801a858:	7d7b      	ldrb	r3, [r7, #21]
 801a85a:	4a15      	ldr	r2, [pc, #84]	@ (801a8b0 <Base16_Decode+0x144>)
 801a85c:	5cd3      	ldrb	r3, [r2, r3]
 801a85e:	757b      	strb	r3, [r7, #21]

        if (b == BAD || b2 == BAD)
 801a860:	7dbb      	ldrb	r3, [r7, #22]
 801a862:	2bff      	cmp	r3, #255	@ 0xff
 801a864:	d002      	beq.n	801a86c <Base16_Decode+0x100>
 801a866:	7d7b      	ldrb	r3, [r7, #21]
 801a868:	2bff      	cmp	r3, #255	@ 0xff
 801a86a:	d102      	bne.n	801a872 <Base16_Decode+0x106>
            return ASN_INPUT_E;
 801a86c:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a870:	e018      	b.n	801a8a4 <Base16_Decode+0x138>

        out[outIdx++] = (byte)((b << 4) | b2);
 801a872:	f997 3016 	ldrsb.w	r3, [r7, #22]
 801a876:	011b      	lsls	r3, r3, #4
 801a878:	b25a      	sxtb	r2, r3
 801a87a:	f997 3015 	ldrsb.w	r3, [r7, #21]
 801a87e:	4313      	orrs	r3, r2
 801a880:	b259      	sxtb	r1, r3
 801a882:	69bb      	ldr	r3, [r7, #24]
 801a884:	1c5a      	adds	r2, r3, #1
 801a886:	61ba      	str	r2, [r7, #24]
 801a888:	687a      	ldr	r2, [r7, #4]
 801a88a:	4413      	add	r3, r2
 801a88c:	b2ca      	uxtb	r2, r1
 801a88e:	701a      	strb	r2, [r3, #0]
        inLen -= 2;
 801a890:	68bb      	ldr	r3, [r7, #8]
 801a892:	3b02      	subs	r3, #2
 801a894:	60bb      	str	r3, [r7, #8]
    while (inLen) {
 801a896:	68bb      	ldr	r3, [r7, #8]
 801a898:	2b00      	cmp	r3, #0
 801a89a:	d1bd      	bne.n	801a818 <Base16_Decode+0xac>
    }

    *outLen = outIdx;
 801a89c:	683b      	ldr	r3, [r7, #0]
 801a89e:	69ba      	ldr	r2, [r7, #24]
 801a8a0:	601a      	str	r2, [r3, #0]
    return 0;
 801a8a2:	2300      	movs	r3, #0
}
 801a8a4:	4618      	mov	r0, r3
 801a8a6:	3724      	adds	r7, #36	@ 0x24
 801a8a8:	46bd      	mov	sp, r7
 801a8aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a8ae:	4770      	bx	lr
 801a8b0:	080348c8 	.word	0x080348c8

0801a8b4 <wc_FreeDhKey>:
    return wc_InitDhKey_ex(key, NULL, INVALID_DEVID);
}


int wc_FreeDhKey(DhKey* key)
{
 801a8b4:	b580      	push	{r7, lr}
 801a8b6:	b082      	sub	sp, #8
 801a8b8:	af00      	add	r7, sp, #0
 801a8ba:	6078      	str	r0, [r7, #4]
    if (key) {
 801a8bc:	687b      	ldr	r3, [r7, #4]
 801a8be:	2b00      	cmp	r3, #0
 801a8c0:	d00f      	beq.n	801a8e2 <wc_FreeDhKey+0x2e>
        mp_clear(&key->p);
 801a8c2:	687b      	ldr	r3, [r7, #4]
 801a8c4:	4618      	mov	r0, r3
 801a8c6:	f00c f912 	bl	8026aee <mp_clear>
        mp_clear(&key->g);
 801a8ca:	687b      	ldr	r3, [r7, #4]
 801a8cc:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a8d0:	4618      	mov	r0, r3
 801a8d2:	f00c f90c 	bl	8026aee <mp_clear>
        mp_clear(&key->q);
 801a8d6:	687b      	ldr	r3, [r7, #4]
 801a8d8:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 801a8dc:	4618      	mov	r0, r3
 801a8de:	f00c f906 	bl	8026aee <mp_clear>
    #endif
    #ifdef WOLFSSL_KCAPI_DH
        KcapiDh_Free(key);
    #endif
    }
    return 0;
 801a8e2:	2300      	movs	r3, #0
}
 801a8e4:	4618      	mov	r0, r3
 801a8e6:	3708      	adds	r7, #8
 801a8e8:	46bd      	mov	sp, r7
 801a8ea:	bd80      	pop	{r7, pc}

0801a8ec <ForceZero>:
{
 801a8ec:	b480      	push	{r7}
 801a8ee:	b085      	sub	sp, #20
 801a8f0:	af00      	add	r7, sp, #0
 801a8f2:	6078      	str	r0, [r7, #4]
 801a8f4:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801a8f6:	687b      	ldr	r3, [r7, #4]
 801a8f8:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801a8fa:	e004      	b.n	801a906 <ForceZero+0x1a>
 801a8fc:	68fb      	ldr	r3, [r7, #12]
 801a8fe:	1c5a      	adds	r2, r3, #1
 801a900:	60fa      	str	r2, [r7, #12]
 801a902:	2200      	movs	r2, #0
 801a904:	701a      	strb	r2, [r3, #0]
 801a906:	683b      	ldr	r3, [r7, #0]
 801a908:	1e5a      	subs	r2, r3, #1
 801a90a:	603a      	str	r2, [r7, #0]
 801a90c:	2b00      	cmp	r3, #0
 801a90e:	d1f5      	bne.n	801a8fc <ForceZero+0x10>
}
 801a910:	bf00      	nop
 801a912:	bf00      	nop
 801a914:	3714      	adds	r7, #20
 801a916:	46bd      	mov	sp, r7
 801a918:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a91c:	4770      	bx	lr

0801a91e <wc_ecc_curve_cache_free_spec_item>:
    #define FREE_CURVE_SPECS() WC_DO_NOTHING
#endif /* ECC_CACHE_CURVE */

static void wc_ecc_curve_cache_free_spec_item(ecc_curve_spec* curve, mp_int* item,
    byte mask)
{
 801a91e:	b580      	push	{r7, lr}
 801a920:	b084      	sub	sp, #16
 801a922:	af00      	add	r7, sp, #0
 801a924:	60f8      	str	r0, [r7, #12]
 801a926:	60b9      	str	r1, [r7, #8]
 801a928:	4613      	mov	r3, r2
 801a92a:	71fb      	strb	r3, [r7, #7]
    if (item) {
 801a92c:	68bb      	ldr	r3, [r7, #8]
 801a92e:	2b00      	cmp	r3, #0
 801a930:	d002      	beq.n	801a938 <wc_ecc_curve_cache_free_spec_item+0x1a>
    #ifdef HAVE_WOLF_BIGINT
        wc_bigint_free(&item->raw);
    #endif
        mp_clear(item);
 801a932:	68b8      	ldr	r0, [r7, #8]
 801a934:	f00c f8db 	bl	8026aee <mp_clear>
    }
    curve->load_mask = (byte)(curve->load_mask & ~mask);
 801a938:	68fb      	ldr	r3, [r7, #12]
 801a93a:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a93e:	b25a      	sxtb	r2, r3
 801a940:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801a944:	43db      	mvns	r3, r3
 801a946:	b25b      	sxtb	r3, r3
 801a948:	4013      	ands	r3, r2
 801a94a:	b25b      	sxtb	r3, r3
 801a94c:	b2da      	uxtb	r2, r3
 801a94e:	68fb      	ldr	r3, [r7, #12]
 801a950:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
}
 801a954:	bf00      	nop
 801a956:	3710      	adds	r7, #16
 801a958:	46bd      	mov	sp, r7
 801a95a:	bd80      	pop	{r7, pc}

0801a95c <wc_ecc_curve_cache_free_spec>:
static void wc_ecc_curve_cache_free_spec(ecc_curve_spec* curve)
{
 801a95c:	b580      	push	{r7, lr}
 801a95e:	b082      	sub	sp, #8
 801a960:	af00      	add	r7, sp, #0
 801a962:	6078      	str	r0, [r7, #4]
    if (curve == NULL) {
 801a964:	687b      	ldr	r3, [r7, #4]
 801a966:	2b00      	cmp	r3, #0
 801a968:	d058      	beq.n	801aa1c <wc_ecc_curve_cache_free_spec+0xc0>
        return;
    }

    if (curve->load_mask & ECC_CURVE_FIELD_PRIME)
 801a96a:	687b      	ldr	r3, [r7, #4]
 801a96c:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a970:	f003 0301 	and.w	r3, r3, #1
 801a974:	2b00      	cmp	r3, #0
 801a976:	d006      	beq.n	801a986 <wc_ecc_curve_cache_free_spec+0x2a>
        wc_ecc_curve_cache_free_spec_item(curve, curve->prime, ECC_CURVE_FIELD_PRIME);
 801a978:	687b      	ldr	r3, [r7, #4]
 801a97a:	685b      	ldr	r3, [r3, #4]
 801a97c:	2201      	movs	r2, #1
 801a97e:	4619      	mov	r1, r3
 801a980:	6878      	ldr	r0, [r7, #4]
 801a982:	f7ff ffcc 	bl	801a91e <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_AF)
 801a986:	687b      	ldr	r3, [r7, #4]
 801a988:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a98c:	f003 0302 	and.w	r3, r3, #2
 801a990:	2b00      	cmp	r3, #0
 801a992:	d006      	beq.n	801a9a2 <wc_ecc_curve_cache_free_spec+0x46>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Af, ECC_CURVE_FIELD_AF);
 801a994:	687b      	ldr	r3, [r7, #4]
 801a996:	689b      	ldr	r3, [r3, #8]
 801a998:	2202      	movs	r2, #2
 801a99a:	4619      	mov	r1, r3
 801a99c:	6878      	ldr	r0, [r7, #4]
 801a99e:	f7ff ffbe 	bl	801a91e <wc_ecc_curve_cache_free_spec_item>
#ifdef USE_ECC_B_PARAM
    if (curve->load_mask & ECC_CURVE_FIELD_BF)
 801a9a2:	687b      	ldr	r3, [r7, #4]
 801a9a4:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a9a8:	f003 0304 	and.w	r3, r3, #4
 801a9ac:	2b00      	cmp	r3, #0
 801a9ae:	d006      	beq.n	801a9be <wc_ecc_curve_cache_free_spec+0x62>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Bf, ECC_CURVE_FIELD_BF);
 801a9b0:	687b      	ldr	r3, [r7, #4]
 801a9b2:	68db      	ldr	r3, [r3, #12]
 801a9b4:	2204      	movs	r2, #4
 801a9b6:	4619      	mov	r1, r3
 801a9b8:	6878      	ldr	r0, [r7, #4]
 801a9ba:	f7ff ffb0 	bl	801a91e <wc_ecc_curve_cache_free_spec_item>
#endif
    if (curve->load_mask & ECC_CURVE_FIELD_ORDER)
 801a9be:	687b      	ldr	r3, [r7, #4]
 801a9c0:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a9c4:	f003 0308 	and.w	r3, r3, #8
 801a9c8:	2b00      	cmp	r3, #0
 801a9ca:	d006      	beq.n	801a9da <wc_ecc_curve_cache_free_spec+0x7e>
        wc_ecc_curve_cache_free_spec_item(curve, curve->order, ECC_CURVE_FIELD_ORDER);
 801a9cc:	687b      	ldr	r3, [r7, #4]
 801a9ce:	691b      	ldr	r3, [r3, #16]
 801a9d0:	2208      	movs	r2, #8
 801a9d2:	4619      	mov	r1, r3
 801a9d4:	6878      	ldr	r0, [r7, #4]
 801a9d6:	f7ff ffa2 	bl	801a91e <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_GX)
 801a9da:	687b      	ldr	r3, [r7, #4]
 801a9dc:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a9e0:	f003 0310 	and.w	r3, r3, #16
 801a9e4:	2b00      	cmp	r3, #0
 801a9e6:	d006      	beq.n	801a9f6 <wc_ecc_curve_cache_free_spec+0x9a>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Gx, ECC_CURVE_FIELD_GX);
 801a9e8:	687b      	ldr	r3, [r7, #4]
 801a9ea:	695b      	ldr	r3, [r3, #20]
 801a9ec:	2210      	movs	r2, #16
 801a9ee:	4619      	mov	r1, r3
 801a9f0:	6878      	ldr	r0, [r7, #4]
 801a9f2:	f7ff ff94 	bl	801a91e <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_GY)
 801a9f6:	687b      	ldr	r3, [r7, #4]
 801a9f8:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a9fc:	f003 0320 	and.w	r3, r3, #32
 801aa00:	2b00      	cmp	r3, #0
 801aa02:	d006      	beq.n	801aa12 <wc_ecc_curve_cache_free_spec+0xb6>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Gy, ECC_CURVE_FIELD_GY);
 801aa04:	687b      	ldr	r3, [r7, #4]
 801aa06:	699b      	ldr	r3, [r3, #24]
 801aa08:	2220      	movs	r2, #32
 801aa0a:	4619      	mov	r1, r3
 801aa0c:	6878      	ldr	r0, [r7, #4]
 801aa0e:	f7ff ff86 	bl	801a91e <wc_ecc_curve_cache_free_spec_item>

    curve->load_mask = 0;
 801aa12:	687b      	ldr	r3, [r7, #4]
 801aa14:	2200      	movs	r2, #0
 801aa16:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
 801aa1a:	e000      	b.n	801aa1e <wc_ecc_curve_cache_free_spec+0xc2>
        return;
 801aa1c:	bf00      	nop
}
 801aa1e:	3708      	adds	r7, #8
 801aa20:	46bd      	mov	sp, r7
 801aa22:	bd80      	pop	{r7, pc}

0801aa24 <wc_ecc_curve_free>:

static void wc_ecc_curve_free(ecc_curve_spec* curve)
{
 801aa24:	b580      	push	{r7, lr}
 801aa26:	b082      	sub	sp, #8
 801aa28:	af00      	add	r7, sp, #0
 801aa2a:	6078      	str	r0, [r7, #4]
    if (curve) {
 801aa2c:	687b      	ldr	r3, [r7, #4]
 801aa2e:	2b00      	cmp	r3, #0
 801aa30:	d002      	beq.n	801aa38 <wc_ecc_curve_free+0x14>
            wc_ecc_curve_cache_free_spec(curve);
            XFREE(curve, NULL, DYNAMIC_TYPE_ECC);
        }
        #endif
    #else
        wc_ecc_curve_cache_free_spec(curve);
 801aa32:	6878      	ldr	r0, [r7, #4]
 801aa34:	f7ff ff92 	bl	801a95c <wc_ecc_curve_cache_free_spec>
    #endif
    }
}
 801aa38:	bf00      	nop
 801aa3a:	3708      	adds	r7, #8
 801aa3c:	46bd      	mov	sp, r7
 801aa3e:	bd80      	pop	{r7, pc}

0801aa40 <wc_ecc_curve_cache_load_item>:

static int wc_ecc_curve_cache_load_item(ecc_curve_spec* curve, const char* src,
    mp_int** dst, byte mask)
{
 801aa40:	b580      	push	{r7, lr}
 801aa42:	b086      	sub	sp, #24
 801aa44:	af00      	add	r7, sp, #0
 801aa46:	60f8      	str	r0, [r7, #12]
 801aa48:	60b9      	str	r1, [r7, #8]
 801aa4a:	607a      	str	r2, [r7, #4]
 801aa4c:	70fb      	strb	r3, [r7, #3]
    int err;

#ifndef ECC_CACHE_CURVE
    /* get mp_int from temp */
    if (curve->spec_use >= curve->spec_count) {
 801aa4e:	68fb      	ldr	r3, [r7, #12]
 801aa50:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801aa52:	68fb      	ldr	r3, [r7, #12]
 801aa54:	6a1b      	ldr	r3, [r3, #32]
 801aa56:	429a      	cmp	r2, r3
 801aa58:	d302      	bcc.n	801aa60 <wc_ecc_curve_cache_load_item+0x20>
        WOLFSSL_MSG("Invalid DECLARE_CURVE_SPECS count");
        return ECC_BAD_ARG_E;
 801aa5a:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801aa5e:	e028      	b.n	801aab2 <wc_ecc_curve_cache_load_item+0x72>
    }
#ifdef WOLFSSL_SP_MATH_ALL
    *dst = (mp_int*)(curve->spec_ints + MP_INT_SIZEOF(MP_BITS_CNT(
        MAX_ECC_BITS_USE)) * curve->spec_use++);
#else
    *dst = &curve->spec_ints[curve->spec_use++];
 801aa60:	68fb      	ldr	r3, [r7, #12]
 801aa62:	69da      	ldr	r2, [r3, #28]
 801aa64:	68fb      	ldr	r3, [r7, #12]
 801aa66:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801aa68:	1c58      	adds	r0, r3, #1
 801aa6a:	68f9      	ldr	r1, [r7, #12]
 801aa6c:	6248      	str	r0, [r1, #36]	@ 0x24
 801aa6e:	f44f 710b 	mov.w	r1, #556	@ 0x22c
 801aa72:	fb01 f303 	mul.w	r3, r1, r3
 801aa76:	441a      	add	r2, r3
 801aa78:	687b      	ldr	r3, [r7, #4]
 801aa7a:	601a      	str	r2, [r3, #0]
#endif

#ifdef WOLFSSL_SP_MATH_ALL
    err = mp_init_size(*dst, MP_BITS_CNT(MAX_ECC_BITS_USE));
#else
    err = mp_init(*dst);
 801aa7c:	687b      	ldr	r3, [r7, #4]
 801aa7e:	681b      	ldr	r3, [r3, #0]
 801aa80:	4618      	mov	r0, r3
 801aa82:	f00b ffaa 	bl	80269da <mp_init>
 801aa86:	6178      	str	r0, [r7, #20]
#endif
    if (err == MP_OKAY) {
 801aa88:	697b      	ldr	r3, [r7, #20]
 801aa8a:	2b00      	cmp	r3, #0
 801aa8c:	d110      	bne.n	801aab0 <wc_ecc_curve_cache_load_item+0x70>
        curve->load_mask |= mask;
 801aa8e:	68fb      	ldr	r3, [r7, #12]
 801aa90:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
 801aa94:	78fb      	ldrb	r3, [r7, #3]
 801aa96:	4313      	orrs	r3, r2
 801aa98:	b2da      	uxtb	r2, r3
 801aa9a:	68fb      	ldr	r3, [r7, #12]
 801aa9c:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

        err = mp_read_radix(*dst, src, MP_RADIX_HEX);
 801aaa0:	687b      	ldr	r3, [r7, #4]
 801aaa2:	681b      	ldr	r3, [r3, #0]
 801aaa4:	2210      	movs	r2, #16
 801aaa6:	68b9      	ldr	r1, [r7, #8]
 801aaa8:	4618      	mov	r0, r3
 801aaaa:	f00c fc41 	bl	8027330 <mp_read_radix>
 801aaae:	6178      	str	r0, [r7, #20]
    #ifdef HAVE_WOLF_BIGINT
        if (err == MP_OKAY)
            err = wc_mp_to_bigint(*dst, &(*dst)->raw);
    #endif
    }
    return err;
 801aab0:	697b      	ldr	r3, [r7, #20]
}
 801aab2:	4618      	mov	r0, r3
 801aab4:	3718      	adds	r7, #24
 801aab6:	46bd      	mov	sp, r7
 801aab8:	bd80      	pop	{r7, pc}

0801aaba <wc_ecc_curve_load>:

static int wc_ecc_curve_load(const ecc_set_type* dp, ecc_curve_spec** pCurve,
    byte load_mask)
{
 801aaba:	b580      	push	{r7, lr}
 801aabc:	b088      	sub	sp, #32
 801aabe:	af00      	add	r7, sp, #0
 801aac0:	60f8      	str	r0, [r7, #12]
 801aac2:	60b9      	str	r1, [r7, #8]
 801aac4:	4613      	mov	r3, r2
 801aac6:	71fb      	strb	r3, [r7, #7]
    int ret = 0;
 801aac8:	2300      	movs	r3, #0
 801aaca:	61fb      	str	r3, [r7, #28]
    ecc_curve_spec* curve;
    byte load_items = 0; /* mask of items to load */
 801aacc:	2300      	movs	r3, #0
 801aace:	76fb      	strb	r3, [r7, #27]
#ifdef ECC_CACHE_CURVE
    int x;
#endif

    if (dp == NULL || pCurve == NULL)
 801aad0:	68fb      	ldr	r3, [r7, #12]
 801aad2:	2b00      	cmp	r3, #0
 801aad4:	d002      	beq.n	801aadc <wc_ecc_curve_load+0x22>
 801aad6:	68bb      	ldr	r3, [r7, #8]
 801aad8:	2b00      	cmp	r3, #0
 801aada:	d102      	bne.n	801aae2 <wc_ecc_curve_load+0x28>
        return BAD_FUNC_ARG;
 801aadc:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801aae0:	e094      	b.n	801ac0c <wc_ecc_curve_load+0x152>
#endif /* WOLFSSL_NO_MALLOC */

    /* return new or cached curve */
    *pCurve = curve;
#else
    curve = *pCurve;
 801aae2:	68bb      	ldr	r3, [r7, #8]
 801aae4:	681b      	ldr	r3, [r3, #0]
 801aae6:	617b      	str	r3, [r7, #20]
#endif /* ECC_CACHE_CURVE */

    /* make sure the curve is initialized */
    if (curve->dp != dp) {
 801aae8:	697b      	ldr	r3, [r7, #20]
 801aaea:	681b      	ldr	r3, [r3, #0]
 801aaec:	68fa      	ldr	r2, [r7, #12]
 801aaee:	429a      	cmp	r2, r3
 801aaf0:	d003      	beq.n	801aafa <wc_ecc_curve_load+0x40>
        curve->load_mask = 0;
 801aaf2:	697b      	ldr	r3, [r7, #20]
 801aaf4:	2200      	movs	r2, #0
 801aaf6:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
        curve->order = &curve->order_lcl;
        curve->Gx = &curve->Gx_lcl;
        curve->Gy = &curve->Gy_lcl;
    #endif
    }
    curve->dp = dp; /* set dp info */
 801aafa:	697b      	ldr	r3, [r7, #20]
 801aafc:	68fa      	ldr	r2, [r7, #12]
 801aafe:	601a      	str	r2, [r3, #0]

    /* determine items to load */
    load_items = (byte)(((byte)~(word32)curve->load_mask) & load_mask);
 801ab00:	697b      	ldr	r3, [r7, #20]
 801ab02:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801ab06:	43db      	mvns	r3, r3
 801ab08:	b2da      	uxtb	r2, r3
 801ab0a:	79fb      	ldrb	r3, [r7, #7]
 801ab0c:	4013      	ands	r3, r2
 801ab0e:	76fb      	strb	r3, [r7, #27]
    curve->load_mask |= load_items;
 801ab10:	697b      	ldr	r3, [r7, #20]
 801ab12:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
 801ab16:	7efb      	ldrb	r3, [r7, #27]
 801ab18:	4313      	orrs	r3, r2
 801ab1a:	b2da      	uxtb	r2, r3
 801ab1c:	697b      	ldr	r3, [r7, #20]
 801ab1e:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

    /* load items */
    if (load_items & ECC_CURVE_FIELD_PRIME)
 801ab22:	7efb      	ldrb	r3, [r7, #27]
 801ab24:	f003 0301 	and.w	r3, r3, #1
 801ab28:	2b00      	cmp	r3, #0
 801ab2a:	d00b      	beq.n	801ab44 <wc_ecc_curve_load+0x8a>
        ret += wc_ecc_curve_cache_load_item(curve, dp->prime, &curve->prime,
 801ab2c:	68fb      	ldr	r3, [r7, #12]
 801ab2e:	68d9      	ldr	r1, [r3, #12]
 801ab30:	697b      	ldr	r3, [r7, #20]
 801ab32:	1d1a      	adds	r2, r3, #4
 801ab34:	2301      	movs	r3, #1
 801ab36:	6978      	ldr	r0, [r7, #20]
 801ab38:	f7ff ff82 	bl	801aa40 <wc_ecc_curve_cache_load_item>
 801ab3c:	4602      	mov	r2, r0
 801ab3e:	69fb      	ldr	r3, [r7, #28]
 801ab40:	4413      	add	r3, r2
 801ab42:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_PRIME);
    if (load_items & ECC_CURVE_FIELD_AF)
 801ab44:	7efb      	ldrb	r3, [r7, #27]
 801ab46:	f003 0302 	and.w	r3, r3, #2
 801ab4a:	2b00      	cmp	r3, #0
 801ab4c:	d00c      	beq.n	801ab68 <wc_ecc_curve_load+0xae>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Af, &curve->Af,
 801ab4e:	68fb      	ldr	r3, [r7, #12]
 801ab50:	6919      	ldr	r1, [r3, #16]
 801ab52:	697b      	ldr	r3, [r7, #20]
 801ab54:	f103 0208 	add.w	r2, r3, #8
 801ab58:	2302      	movs	r3, #2
 801ab5a:	6978      	ldr	r0, [r7, #20]
 801ab5c:	f7ff ff70 	bl	801aa40 <wc_ecc_curve_cache_load_item>
 801ab60:	4602      	mov	r2, r0
 801ab62:	69fb      	ldr	r3, [r7, #28]
 801ab64:	4413      	add	r3, r2
 801ab66:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_AF);
#ifdef USE_ECC_B_PARAM
    if (load_items & ECC_CURVE_FIELD_BF)
 801ab68:	7efb      	ldrb	r3, [r7, #27]
 801ab6a:	f003 0304 	and.w	r3, r3, #4
 801ab6e:	2b00      	cmp	r3, #0
 801ab70:	d00c      	beq.n	801ab8c <wc_ecc_curve_load+0xd2>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Bf, &curve->Bf,
 801ab72:	68fb      	ldr	r3, [r7, #12]
 801ab74:	6959      	ldr	r1, [r3, #20]
 801ab76:	697b      	ldr	r3, [r7, #20]
 801ab78:	f103 020c 	add.w	r2, r3, #12
 801ab7c:	2304      	movs	r3, #4
 801ab7e:	6978      	ldr	r0, [r7, #20]
 801ab80:	f7ff ff5e 	bl	801aa40 <wc_ecc_curve_cache_load_item>
 801ab84:	4602      	mov	r2, r0
 801ab86:	69fb      	ldr	r3, [r7, #28]
 801ab88:	4413      	add	r3, r2
 801ab8a:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_BF);
#endif
    if (load_items & ECC_CURVE_FIELD_ORDER)
 801ab8c:	7efb      	ldrb	r3, [r7, #27]
 801ab8e:	f003 0308 	and.w	r3, r3, #8
 801ab92:	2b00      	cmp	r3, #0
 801ab94:	d00c      	beq.n	801abb0 <wc_ecc_curve_load+0xf6>
        ret += wc_ecc_curve_cache_load_item(curve, dp->order, &curve->order,
 801ab96:	68fb      	ldr	r3, [r7, #12]
 801ab98:	6999      	ldr	r1, [r3, #24]
 801ab9a:	697b      	ldr	r3, [r7, #20]
 801ab9c:	f103 0210 	add.w	r2, r3, #16
 801aba0:	2308      	movs	r3, #8
 801aba2:	6978      	ldr	r0, [r7, #20]
 801aba4:	f7ff ff4c 	bl	801aa40 <wc_ecc_curve_cache_load_item>
 801aba8:	4602      	mov	r2, r0
 801abaa:	69fb      	ldr	r3, [r7, #28]
 801abac:	4413      	add	r3, r2
 801abae:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_ORDER);
    if (load_items & ECC_CURVE_FIELD_GX)
 801abb0:	7efb      	ldrb	r3, [r7, #27]
 801abb2:	f003 0310 	and.w	r3, r3, #16
 801abb6:	2b00      	cmp	r3, #0
 801abb8:	d00c      	beq.n	801abd4 <wc_ecc_curve_load+0x11a>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Gx, &curve->Gx,
 801abba:	68fb      	ldr	r3, [r7, #12]
 801abbc:	69d9      	ldr	r1, [r3, #28]
 801abbe:	697b      	ldr	r3, [r7, #20]
 801abc0:	f103 0214 	add.w	r2, r3, #20
 801abc4:	2310      	movs	r3, #16
 801abc6:	6978      	ldr	r0, [r7, #20]
 801abc8:	f7ff ff3a 	bl	801aa40 <wc_ecc_curve_cache_load_item>
 801abcc:	4602      	mov	r2, r0
 801abce:	69fb      	ldr	r3, [r7, #28]
 801abd0:	4413      	add	r3, r2
 801abd2:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_GX);
    if (load_items & ECC_CURVE_FIELD_GY)
 801abd4:	7efb      	ldrb	r3, [r7, #27]
 801abd6:	f003 0320 	and.w	r3, r3, #32
 801abda:	2b00      	cmp	r3, #0
 801abdc:	d00c      	beq.n	801abf8 <wc_ecc_curve_load+0x13e>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Gy, &curve->Gy,
 801abde:	68fb      	ldr	r3, [r7, #12]
 801abe0:	6a19      	ldr	r1, [r3, #32]
 801abe2:	697b      	ldr	r3, [r7, #20]
 801abe4:	f103 0218 	add.w	r2, r3, #24
 801abe8:	2320      	movs	r3, #32
 801abea:	6978      	ldr	r0, [r7, #20]
 801abec:	f7ff ff28 	bl	801aa40 <wc_ecc_curve_cache_load_item>
 801abf0:	4602      	mov	r2, r0
 801abf2:	69fb      	ldr	r3, [r7, #28]
 801abf4:	4413      	add	r3, r2
 801abf6:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_GY);

    /* check for error */
    if (ret != 0) {
 801abf8:	69fb      	ldr	r3, [r7, #28]
 801abfa:	2b00      	cmp	r3, #0
 801abfc:	d005      	beq.n	801ac0a <wc_ecc_curve_load+0x150>
        wc_ecc_curve_free(curve);
 801abfe:	6978      	ldr	r0, [r7, #20]
 801ac00:	f7ff ff10 	bl	801aa24 <wc_ecc_curve_free>
        ret = MP_READ_E;
 801ac04:	f06f 036e 	mvn.w	r3, #110	@ 0x6e
 801ac08:	61fb      	str	r3, [r7, #28]

#if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)
    wc_UnLockMutex(&ecc_curve_cache_mutex);
#endif

    return ret;
 801ac0a:	69fb      	ldr	r3, [r7, #28]
}
 801ac0c:	4618      	mov	r0, r3
 801ac0e:	3720      	adds	r7, #32
 801ac10:	46bd      	mov	sp, r7
 801ac12:	bd80      	pop	{r7, pc}

0801ac14 <wc_ecc_set_curve>:
        return NULL;
    return ecc_sets[curve_idx].name;
}

int wc_ecc_set_curve(ecc_key* key, int keysize, int curve_id)
{
 801ac14:	b480      	push	{r7}
 801ac16:	b087      	sub	sp, #28
 801ac18:	af00      	add	r7, sp, #0
 801ac1a:	60f8      	str	r0, [r7, #12]
 801ac1c:	60b9      	str	r1, [r7, #8]
 801ac1e:	607a      	str	r2, [r7, #4]
    if (key == NULL || (keysize <= 0 && curve_id < 0)) {
 801ac20:	68fb      	ldr	r3, [r7, #12]
 801ac22:	2b00      	cmp	r3, #0
 801ac24:	d005      	beq.n	801ac32 <wc_ecc_set_curve+0x1e>
 801ac26:	68bb      	ldr	r3, [r7, #8]
 801ac28:	2b00      	cmp	r3, #0
 801ac2a:	dc05      	bgt.n	801ac38 <wc_ecc_set_curve+0x24>
 801ac2c:	687b      	ldr	r3, [r7, #4]
 801ac2e:	2b00      	cmp	r3, #0
 801ac30:	da02      	bge.n	801ac38 <wc_ecc_set_curve+0x24>
        return BAD_FUNC_ARG;
 801ac32:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801ac36:	e052      	b.n	801acde <wc_ecc_set_curve+0xca>
    }

    if (keysize > ECC_MAXSIZE) {
 801ac38:	68bb      	ldr	r3, [r7, #8]
 801ac3a:	2b42      	cmp	r3, #66	@ 0x42
 801ac3c:	dd02      	ble.n	801ac44 <wc_ecc_set_curve+0x30>
        return ECC_BAD_ARG_E;
 801ac3e:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801ac42:	e04c      	b.n	801acde <wc_ecc_set_curve+0xca>
    }

    /* handle custom case */
    if (key->idx != ECC_CUSTOM_IDX) {
 801ac44:	68fb      	ldr	r3, [r7, #12]
 801ac46:	685b      	ldr	r3, [r3, #4]
 801ac48:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801ac4c:	d046      	beq.n	801acdc <wc_ecc_set_curve+0xc8>
        int x;

        /* default values */
        key->idx = 0;
 801ac4e:	68fb      	ldr	r3, [r7, #12]
 801ac50:	2200      	movs	r2, #0
 801ac52:	605a      	str	r2, [r3, #4]
        key->dp = NULL;
 801ac54:	68fb      	ldr	r3, [r7, #12]
 801ac56:	2200      	movs	r2, #0
 801ac58:	611a      	str	r2, [r3, #16]

        /* find ecc_set based on curve_id or key size */
        for (x = 0; ecc_sets[x].size != 0; x++) {
 801ac5a:	2300      	movs	r3, #0
 801ac5c:	617b      	str	r3, [r7, #20]
 801ac5e:	e01b      	b.n	801ac98 <wc_ecc_set_curve+0x84>
            if (curve_id > ECC_CURVE_DEF) {
 801ac60:	687b      	ldr	r3, [r7, #4]
 801ac62:	2b00      	cmp	r3, #0
 801ac64:	dd0b      	ble.n	801ac7e <wc_ecc_set_curve+0x6a>
                if (curve_id == ecc_sets[x].id)
 801ac66:	4a21      	ldr	r2, [pc, #132]	@ (801acec <wc_ecc_set_curve+0xd8>)
 801ac68:	697b      	ldr	r3, [r7, #20]
 801ac6a:	2134      	movs	r1, #52	@ 0x34
 801ac6c:	fb01 f303 	mul.w	r3, r1, r3
 801ac70:	4413      	add	r3, r2
 801ac72:	3304      	adds	r3, #4
 801ac74:	681b      	ldr	r3, [r3, #0]
 801ac76:	687a      	ldr	r2, [r7, #4]
 801ac78:	429a      	cmp	r2, r3
 801ac7a:	d10a      	bne.n	801ac92 <wc_ecc_set_curve+0x7e>
                  break;
 801ac7c:	e017      	b.n	801acae <wc_ecc_set_curve+0x9a>
            }
            else if (keysize <= ecc_sets[x].size) {
 801ac7e:	4a1b      	ldr	r2, [pc, #108]	@ (801acec <wc_ecc_set_curve+0xd8>)
 801ac80:	697b      	ldr	r3, [r7, #20]
 801ac82:	2134      	movs	r1, #52	@ 0x34
 801ac84:	fb01 f303 	mul.w	r3, r1, r3
 801ac88:	4413      	add	r3, r2
 801ac8a:	681b      	ldr	r3, [r3, #0]
 801ac8c:	68ba      	ldr	r2, [r7, #8]
 801ac8e:	429a      	cmp	r2, r3
 801ac90:	dd0c      	ble.n	801acac <wc_ecc_set_curve+0x98>
        for (x = 0; ecc_sets[x].size != 0; x++) {
 801ac92:	697b      	ldr	r3, [r7, #20]
 801ac94:	3301      	adds	r3, #1
 801ac96:	617b      	str	r3, [r7, #20]
 801ac98:	4a14      	ldr	r2, [pc, #80]	@ (801acec <wc_ecc_set_curve+0xd8>)
 801ac9a:	697b      	ldr	r3, [r7, #20]
 801ac9c:	2134      	movs	r1, #52	@ 0x34
 801ac9e:	fb01 f303 	mul.w	r3, r1, r3
 801aca2:	4413      	add	r3, r2
 801aca4:	681b      	ldr	r3, [r3, #0]
 801aca6:	2b00      	cmp	r3, #0
 801aca8:	d1da      	bne.n	801ac60 <wc_ecc_set_curve+0x4c>
 801acaa:	e000      	b.n	801acae <wc_ecc_set_curve+0x9a>
                break;
 801acac:	bf00      	nop
            }
        }
        if (ecc_sets[x].size == 0) {
 801acae:	4a0f      	ldr	r2, [pc, #60]	@ (801acec <wc_ecc_set_curve+0xd8>)
 801acb0:	697b      	ldr	r3, [r7, #20]
 801acb2:	2134      	movs	r1, #52	@ 0x34
 801acb4:	fb01 f303 	mul.w	r3, r1, r3
 801acb8:	4413      	add	r3, r2
 801acba:	681b      	ldr	r3, [r3, #0]
 801acbc:	2b00      	cmp	r3, #0
 801acbe:	d102      	bne.n	801acc6 <wc_ecc_set_curve+0xb2>
            WOLFSSL_MSG("ECC Curve not found");
            return ECC_CURVE_OID_E;
 801acc0:	f06f 03ab 	mvn.w	r3, #171	@ 0xab
 801acc4:	e00b      	b.n	801acde <wc_ecc_set_curve+0xca>
        }

        key->idx = x;
 801acc6:	68fb      	ldr	r3, [r7, #12]
 801acc8:	697a      	ldr	r2, [r7, #20]
 801acca:	605a      	str	r2, [r3, #4]
        key->dp  = &ecc_sets[x];
 801accc:	697b      	ldr	r3, [r7, #20]
 801acce:	2234      	movs	r2, #52	@ 0x34
 801acd0:	fb02 f303 	mul.w	r3, r2, r3
 801acd4:	4a05      	ldr	r2, [pc, #20]	@ (801acec <wc_ecc_set_curve+0xd8>)
 801acd6:	441a      	add	r2, r3
 801acd8:	68fb      	ldr	r3, [r7, #12]
 801acda:	611a      	str	r2, [r3, #16]
    }

    return 0;
 801acdc:	2300      	movs	r3, #0
}
 801acde:	4618      	mov	r0, r3
 801ace0:	371c      	adds	r7, #28
 801ace2:	46bd      	mov	sp, r7
 801ace4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ace8:	4770      	bx	lr
 801acea:	bf00      	nop
 801acec:	08034908 	.word	0x08034908

0801acf0 <alt_fp_init>:


#ifdef ALT_ECC_SIZE
static void alt_fp_init(mp_int* a)
{
 801acf0:	b580      	push	{r7, lr}
 801acf2:	b082      	sub	sp, #8
 801acf4:	af00      	add	r7, sp, #0
 801acf6:	6078      	str	r0, [r7, #4]
    a->size = FP_SIZE_ECC;
 801acf8:	687b      	ldr	r3, [r7, #4]
 801acfa:	2211      	movs	r2, #17
 801acfc:	609a      	str	r2, [r3, #8]
    mp_zero(a);
 801acfe:	6878      	ldr	r0, [r7, #4]
 801ad00:	f00b fe88 	bl	8026a14 <fp_zero>
}
 801ad04:	bf00      	nop
 801ad06:	3708      	adds	r7, #8
 801ad08:	46bd      	mov	sp, r7
 801ad0a:	bd80      	pop	{r7, pc}

0801ad0c <_ecc_projective_add_point>:
   mp       The "b" value from montgomery_setup()
   return   MP_OKAY on success
*/
static int _ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,
                                     mp_int* a, mp_int* modulus, mp_digit mp)
{
 801ad0c:	b580      	push	{r7, lr}
 801ad0e:	b0a6      	sub	sp, #152	@ 0x98
 801ad10:	af02      	add	r7, sp, #8
 801ad12:	60f8      	str	r0, [r7, #12]
 801ad14:	60b9      	str	r1, [r7, #8]
 801ad16:	607a      	str	r2, [r7, #4]
 801ad18:	603b      	str	r3, [r7, #0]
#if !defined(WOLFSSL_SP_MATH)
   DECL_MP_INT_SIZE_DYN(t1, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801ad1a:	2300      	movs	r3, #0
 801ad1c:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
   DECL_MP_INT_SIZE_DYN(t2, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801ad20:	2300      	movs	r3, #0
 801ad22:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
#ifdef ALT_ECC_SIZE
   DECL_MP_INT_SIZE_DYN(rx, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801ad26:	2300      	movs	r3, #0
 801ad28:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
   DECL_MP_INT_SIZE_DYN(ry, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801ad2c:	2300      	movs	r3, #0
 801ad2e:	67fb      	str	r3, [r7, #124]	@ 0x7c
   DECL_MP_INT_SIZE_DYN(rz, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801ad30:	2300      	movs	r3, #0
 801ad32:	67bb      	str	r3, [r7, #120]	@ 0x78
#endif
   mp_int  *x, *y, *z;
   int     err;

   /* if Q == R then swap P and Q, so we don't require a local x,y,z */
   if (Q == R) {
 801ad34:	68ba      	ldr	r2, [r7, #8]
 801ad36:	687b      	ldr	r3, [r7, #4]
 801ad38:	429a      	cmp	r2, r3
 801ad3a:	d105      	bne.n	801ad48 <_ecc_projective_add_point+0x3c>
      ecc_point* tPt  = P;
 801ad3c:	68fb      	ldr	r3, [r7, #12]
 801ad3e:	677b      	str	r3, [r7, #116]	@ 0x74
      P = Q;
 801ad40:	68bb      	ldr	r3, [r7, #8]
 801ad42:	60fb      	str	r3, [r7, #12]
      Q = tPt;
 801ad44:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801ad46:	60bb      	str	r3, [r7, #8]
   }
   else
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#endif /* WOLFSSL_SMALL_STACK */
   {
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801ad48:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801ad4c:	f003 ff96 	bl	801ec7c <wolfSSL_Malloc>
 801ad50:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
 801ad54:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ad58:	2b00      	cmp	r3, #0
 801ad5a:	d006      	beq.n	801ad6a <_ecc_projective_add_point+0x5e>
 801ad5c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801ad60:	2100      	movs	r1, #0
 801ad62:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ad66:	f00d ff5d 	bl	8028c24 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801ad6a:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801ad6e:	f003 ff85 	bl	801ec7c <wolfSSL_Malloc>
 801ad72:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
 801ad76:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ad7a:	2b00      	cmp	r3, #0
 801ad7c:	d006      	beq.n	801ad8c <_ecc_projective_add_point+0x80>
 801ad7e:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801ad82:	2100      	movs	r1, #0
 801ad84:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ad88:	f00d ff4c 	bl	8028c24 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (t1 == NULL || t2 == NULL) {
 801ad8c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ad90:	2b00      	cmp	r3, #0
 801ad92:	d003      	beq.n	801ad9c <_ecc_projective_add_point+0x90>
 801ad94:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ad98:	2b00      	cmp	r3, #0
 801ad9a:	d115      	bne.n	801adc8 <_ecc_projective_add_point+0xbc>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801ad9c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ada0:	617b      	str	r3, [r7, #20]
 801ada2:	697b      	ldr	r3, [r7, #20]
 801ada4:	2b00      	cmp	r3, #0
 801ada6:	d002      	beq.n	801adae <_ecc_projective_add_point+0xa2>
 801ada8:	6978      	ldr	r0, [r7, #20]
 801adaa:	f003 ff83 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801adae:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801adb2:	613b      	str	r3, [r7, #16]
 801adb4:	693b      	ldr	r3, [r7, #16]
 801adb6:	2b00      	cmp	r3, #0
 801adb8:	d002      	beq.n	801adc0 <_ecc_projective_add_point+0xb4>
 801adba:	6938      	ldr	r0, [r7, #16]
 801adbc:	f003 ff7a 	bl	801ecb4 <wolfSSL_Free>
         return MEMORY_E;
 801adc0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801adc4:	f000 bc2d 	b.w	801b622 <_ecc_projective_add_point+0x916>
      }
   #endif
#ifdef ALT_ECC_SIZE
      NEW_MP_INT_SIZE(rx, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801adc8:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801adcc:	f003 ff56 	bl	801ec7c <wolfSSL_Malloc>
 801add0:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
 801add4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801add8:	2b00      	cmp	r3, #0
 801adda:	d006      	beq.n	801adea <_ecc_projective_add_point+0xde>
 801addc:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801ade0:	2100      	movs	r1, #0
 801ade2:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801ade6:	f00d ff1d 	bl	8028c24 <memset>
      NEW_MP_INT_SIZE(ry, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801adea:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801adee:	f003 ff45 	bl	801ec7c <wolfSSL_Malloc>
 801adf2:	67f8      	str	r0, [r7, #124]	@ 0x7c
 801adf4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801adf6:	2b00      	cmp	r3, #0
 801adf8:	d005      	beq.n	801ae06 <_ecc_projective_add_point+0xfa>
 801adfa:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801adfe:	2100      	movs	r1, #0
 801ae00:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801ae02:	f00d ff0f 	bl	8028c24 <memset>
      NEW_MP_INT_SIZE(rz, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801ae06:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801ae0a:	f003 ff37 	bl	801ec7c <wolfSSL_Malloc>
 801ae0e:	67b8      	str	r0, [r7, #120]	@ 0x78
 801ae10:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ae12:	2b00      	cmp	r3, #0
 801ae14:	d005      	beq.n	801ae22 <_ecc_projective_add_point+0x116>
 801ae16:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801ae1a:	2100      	movs	r1, #0
 801ae1c:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 801ae1e:	f00d ff01 	bl	8028c24 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (rx == NULL || ry == NULL || rz == NULL) {
 801ae22:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ae26:	2b00      	cmp	r3, #0
 801ae28:	d005      	beq.n	801ae36 <_ecc_projective_add_point+0x12a>
 801ae2a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ae2c:	2b00      	cmp	r3, #0
 801ae2e:	d002      	beq.n	801ae36 <_ecc_projective_add_point+0x12a>
 801ae30:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ae32:	2b00      	cmp	r3, #0
 801ae34:	d12d      	bne.n	801ae92 <_ecc_projective_add_point+0x186>
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801ae36:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ae38:	62bb      	str	r3, [r7, #40]	@ 0x28
 801ae3a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ae3c:	2b00      	cmp	r3, #0
 801ae3e:	d002      	beq.n	801ae46 <_ecc_projective_add_point+0x13a>
 801ae40:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801ae42:	f003 ff37 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801ae46:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ae48:	627b      	str	r3, [r7, #36]	@ 0x24
 801ae4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ae4c:	2b00      	cmp	r3, #0
 801ae4e:	d002      	beq.n	801ae56 <_ecc_projective_add_point+0x14a>
 801ae50:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801ae52:	f003 ff2f 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801ae56:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ae5a:	623b      	str	r3, [r7, #32]
 801ae5c:	6a3b      	ldr	r3, [r7, #32]
 801ae5e:	2b00      	cmp	r3, #0
 801ae60:	d002      	beq.n	801ae68 <_ecc_projective_add_point+0x15c>
 801ae62:	6a38      	ldr	r0, [r7, #32]
 801ae64:	f003 ff26 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801ae68:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ae6c:	61fb      	str	r3, [r7, #28]
 801ae6e:	69fb      	ldr	r3, [r7, #28]
 801ae70:	2b00      	cmp	r3, #0
 801ae72:	d002      	beq.n	801ae7a <_ecc_projective_add_point+0x16e>
 801ae74:	69f8      	ldr	r0, [r7, #28]
 801ae76:	f003 ff1d 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801ae7a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ae7e:	61bb      	str	r3, [r7, #24]
 801ae80:	69bb      	ldr	r3, [r7, #24]
 801ae82:	2b00      	cmp	r3, #0
 801ae84:	d002      	beq.n	801ae8c <_ecc_projective_add_point+0x180>
 801ae86:	69b8      	ldr	r0, [r7, #24]
 801ae88:	f003 ff14 	bl	801ecb4 <wolfSSL_Free>
         return MEMORY_E;
 801ae8c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801ae90:	e3c7      	b.n	801b622 <_ecc_projective_add_point+0x916>
      }
   #endif
#endif
   }

   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
 801ae92:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ae96:	f00b fda0 	bl	80269da <mp_init>
 801ae9a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801ae9e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801aea2:	2b00      	cmp	r3, #0
 801aea4:	d105      	bne.n	801aeb2 <_ecc_projective_add_point+0x1a6>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
 801aea6:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801aeaa:	f00b fd96 	bl	80269da <mp_init>
 801aeae:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801aeb2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801aeb6:	2b00      	cmp	r3, #0
 801aeb8:	d02d      	beq.n	801af16 <_ecc_projective_add_point+0x20a>
      if (R->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801aeba:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801aebc:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801aebe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801aec0:	2b00      	cmp	r3, #0
 801aec2:	d002      	beq.n	801aeca <_ecc_projective_add_point+0x1be>
 801aec4:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801aec6:	f003 fef5 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801aeca:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801aecc:	63bb      	str	r3, [r7, #56]	@ 0x38
 801aece:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801aed0:	2b00      	cmp	r3, #0
 801aed2:	d002      	beq.n	801aeda <_ecc_projective_add_point+0x1ce>
 801aed4:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801aed6:	f003 feed 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801aeda:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801aede:	637b      	str	r3, [r7, #52]	@ 0x34
 801aee0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801aee2:	2b00      	cmp	r3, #0
 801aee4:	d002      	beq.n	801aeec <_ecc_projective_add_point+0x1e0>
 801aee6:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801aee8:	f003 fee4 	bl	801ecb4 <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801aeec:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801aef0:	633b      	str	r3, [r7, #48]	@ 0x30
 801aef2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801aef4:	2b00      	cmp	r3, #0
 801aef6:	d002      	beq.n	801aefe <_ecc_projective_add_point+0x1f2>
 801aef8:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801aefa:	f003 fedb 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801aefe:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801af02:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801af04:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801af06:	2b00      	cmp	r3, #0
 801af08:	d002      	beq.n	801af10 <_ecc_projective_add_point+0x204>
 801af0a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801af0c:	f003 fed2 	bl	801ecb4 <wolfSSL_Free>
      }
      return err;
 801af10:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af14:	e385      	b.n	801b622 <_ecc_projective_add_point+0x916>
   }

   /* should we dbl instead? */
   if (err == MP_OKAY) {
 801af16:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af1a:	2b00      	cmp	r3, #0
 801af1c:	d10b      	bne.n	801af36 <_ecc_projective_add_point+0x22a>
#ifdef ECC_TIMING_RESISTANT
      err = mp_submod_ct(modulus, Q->y, modulus, t1);
 801af1e:	68bb      	ldr	r3, [r7, #8]
 801af20:	6859      	ldr	r1, [r3, #4]
 801af22:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801af26:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801af2a:	f8d7 0098 	ldr.w	r0, [r7, #152]	@ 0x98
 801af2e:	f00b fe6d 	bl	8026c0c <mp_submod_ct>
 801af32:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
#else
      err = mp_sub(modulus, Q->y, t1);
#endif
   }
   if (err == MP_OKAY) {
 801af36:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af3a:	2b00      	cmp	r3, #0
 801af3c:	d171      	bne.n	801b022 <_ecc_projective_add_point+0x316>
      if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&
 801af3e:	68fb      	ldr	r3, [r7, #12]
 801af40:	681a      	ldr	r2, [r3, #0]
 801af42:	68bb      	ldr	r3, [r7, #8]
 801af44:	681b      	ldr	r3, [r3, #0]
 801af46:	4619      	mov	r1, r3
 801af48:	4610      	mov	r0, r2
 801af4a:	f00b fed9 	bl	8026d00 <mp_cmp>
 801af4e:	4603      	mov	r3, r0
 801af50:	2b00      	cmp	r3, #0
 801af52:	d166      	bne.n	801b022 <_ecc_projective_add_point+0x316>
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 801af54:	68bb      	ldr	r3, [r7, #8]
 801af56:	689b      	ldr	r3, [r3, #8]
 801af58:	4618      	mov	r0, r3
 801af5a:	f00c fc42 	bl	80277e2 <get_digit_count>
 801af5e:	4603      	mov	r3, r0
      if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&
 801af60:	2b00      	cmp	r3, #0
 801af62:	d05e      	beq.n	801b022 <_ecc_projective_add_point+0x316>
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 801af64:	68fb      	ldr	r3, [r7, #12]
 801af66:	689a      	ldr	r2, [r3, #8]
 801af68:	68bb      	ldr	r3, [r7, #8]
 801af6a:	689b      	ldr	r3, [r3, #8]
 801af6c:	4619      	mov	r1, r3
 801af6e:	4610      	mov	r0, r2
 801af70:	f00b fec6 	bl	8026d00 <mp_cmp>
 801af74:	4603      	mov	r3, r0
 801af76:	2b00      	cmp	r3, #0
 801af78:	d153      	bne.n	801b022 <_ecc_projective_add_point+0x316>
           (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {
 801af7a:	68fb      	ldr	r3, [r7, #12]
 801af7c:	685a      	ldr	r2, [r3, #4]
 801af7e:	68bb      	ldr	r3, [r7, #8]
 801af80:	685b      	ldr	r3, [r3, #4]
 801af82:	4619      	mov	r1, r3
 801af84:	4610      	mov	r0, r2
 801af86:	f00b febb 	bl	8026d00 <mp_cmp>
 801af8a:	4603      	mov	r3, r0
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 801af8c:	2b00      	cmp	r3, #0
 801af8e:	d009      	beq.n	801afa4 <_ecc_projective_add_point+0x298>
           (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {
 801af90:	68fb      	ldr	r3, [r7, #12]
 801af92:	685b      	ldr	r3, [r3, #4]
 801af94:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801af98:	4618      	mov	r0, r3
 801af9a:	f00b feb1 	bl	8026d00 <mp_cmp>
 801af9e:	4603      	mov	r3, r0
 801afa0:	2b00      	cmp	r3, #0
 801afa2:	d13e      	bne.n	801b022 <_ecc_projective_add_point+0x316>
          mp_clear(t1);
 801afa4:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801afa8:	f00b fda1 	bl	8026aee <mp_clear>
          mp_clear(t2);
 801afac:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801afb0:	f00b fd9d 	bl	8026aee <mp_clear>
         if (R->key == NULL)
      #endif
   #endif
         {
         #ifdef ALT_ECC_SIZE
            FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801afb4:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801afb6:	673b      	str	r3, [r7, #112]	@ 0x70
 801afb8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801afba:	2b00      	cmp	r3, #0
 801afbc:	d002      	beq.n	801afc4 <_ecc_projective_add_point+0x2b8>
 801afbe:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801afc0:	f003 fe78 	bl	801ecb4 <wolfSSL_Free>
            FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801afc4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801afc6:	66fb      	str	r3, [r7, #108]	@ 0x6c
 801afc8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801afca:	2b00      	cmp	r3, #0
 801afcc:	d002      	beq.n	801afd4 <_ecc_projective_add_point+0x2c8>
 801afce:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801afd0:	f003 fe70 	bl	801ecb4 <wolfSSL_Free>
            FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801afd4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801afd8:	66bb      	str	r3, [r7, #104]	@ 0x68
 801afda:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801afdc:	2b00      	cmp	r3, #0
 801afde:	d002      	beq.n	801afe6 <_ecc_projective_add_point+0x2da>
 801afe0:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 801afe2:	f003 fe67 	bl	801ecb4 <wolfSSL_Free>
         #endif
            FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801afe6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801afea:	667b      	str	r3, [r7, #100]	@ 0x64
 801afec:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801afee:	2b00      	cmp	r3, #0
 801aff0:	d002      	beq.n	801aff8 <_ecc_projective_add_point+0x2ec>
 801aff2:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801aff4:	f003 fe5e 	bl	801ecb4 <wolfSSL_Free>
            FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801aff8:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801affc:	663b      	str	r3, [r7, #96]	@ 0x60
 801affe:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801b000:	2b00      	cmp	r3, #0
 801b002:	d002      	beq.n	801b00a <_ecc_projective_add_point+0x2fe>
 801b004:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 801b006:	f003 fe55 	bl	801ecb4 <wolfSSL_Free>
         }
         return _ecc_projective_dbl_point(P, R, a, modulus, mp);
 801b00a:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801b00e:	9300      	str	r3, [sp, #0]
 801b010:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801b014:	683a      	ldr	r2, [r7, #0]
 801b016:	6879      	ldr	r1, [r7, #4]
 801b018:	68f8      	ldr	r0, [r7, #12]
 801b01a:	f000 fb06 	bl	801b62a <_ecc_projective_dbl_point>
 801b01e:	4603      	mov	r3, r0
 801b020:	e2ff      	b.n	801b622 <_ecc_projective_add_point+0x916>
      }
   }

   if (err != MP_OKAY) {
 801b022:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b026:	2b00      	cmp	r3, #0
 801b028:	f040 82c1 	bne.w	801b5ae <_ecc_projective_add_point+0x8a2>

/* If use ALT_ECC_SIZE we need to use local stack variable since
   ecc_point x,y,z is reduced size */
#ifdef ALT_ECC_SIZE
   /* Use local stack variable */
   x = rx;
 801b02c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b030:	65fb      	str	r3, [r7, #92]	@ 0x5c
   y = ry;
 801b032:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b034:	65bb      	str	r3, [r7, #88]	@ 0x58
   z = rz;
 801b036:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b038:	657b      	str	r3, [r7, #84]	@ 0x54

   err = INIT_MP_INT_SIZE(x, mp_bitsused(modulus));
 801b03a:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b03c:	f00b fccd 	bl	80269da <mp_init>
 801b040:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801b044:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b048:	2b00      	cmp	r3, #0
 801b04a:	d104      	bne.n	801b056 <_ecc_projective_add_point+0x34a>
      err = INIT_MP_INT_SIZE(y, mp_bitsused(modulus));
 801b04c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b04e:	f00b fcc4 	bl	80269da <mp_init>
 801b052:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err == MP_OKAY) {
 801b056:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b05a:	2b00      	cmp	r3, #0
 801b05c:	d104      	bne.n	801b068 <_ecc_projective_add_point+0x35c>
      err = INIT_MP_INT_SIZE(z, mp_bitsused(modulus));
 801b05e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b060:	f00b fcbb 	bl	80269da <mp_init>
 801b064:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801b068:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b06c:	2b00      	cmp	r3, #0
 801b06e:	f040 82a0 	bne.w	801b5b2 <_ecc_projective_add_point+0x8a6>
   x = R->x;
   y = R->y;
   z = R->z;
#endif

   if (err == MP_OKAY)
 801b072:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b076:	2b00      	cmp	r3, #0
 801b078:	d107      	bne.n	801b08a <_ecc_projective_add_point+0x37e>
       err = mp_copy(P->x, x);
 801b07a:	68fb      	ldr	r3, [r7, #12]
 801b07c:	681b      	ldr	r3, [r3, #0]
 801b07e:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b080:	4618      	mov	r0, r3
 801b082:	f00b fef6 	bl	8026e72 <mp_copy>
 801b086:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b08a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b08e:	2b00      	cmp	r3, #0
 801b090:	d107      	bne.n	801b0a2 <_ecc_projective_add_point+0x396>
       err = mp_copy(P->y, y);
 801b092:	68fb      	ldr	r3, [r7, #12]
 801b094:	685b      	ldr	r3, [r3, #4]
 801b096:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801b098:	4618      	mov	r0, r3
 801b09a:	f00b feea 	bl	8026e72 <mp_copy>
 801b09e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b0a2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b0a6:	2b00      	cmp	r3, #0
 801b0a8:	d107      	bne.n	801b0ba <_ecc_projective_add_point+0x3ae>
       err = mp_copy(P->z, z);
 801b0aa:	68fb      	ldr	r3, [r7, #12]
 801b0ac:	689b      	ldr	r3, [r3, #8]
 801b0ae:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 801b0b0:	4618      	mov	r0, r3
 801b0b2:	f00b fede 	bl	8026e72 <mp_copy>
 801b0b6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* if Z is one then these are no-operations */
   if (err == MP_OKAY) {
 801b0ba:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b0be:	2b00      	cmp	r3, #0
 801b0c0:	d16d      	bne.n	801b19e <_ecc_projective_add_point+0x492>
       if (!mp_iszero(Q->z)) {
 801b0c2:	68bb      	ldr	r3, [r7, #8]
 801b0c4:	689b      	ldr	r3, [r3, #8]
 801b0c6:	4618      	mov	r0, r3
 801b0c8:	f00b fee1 	bl	8026e8e <mp_iszero>
 801b0cc:	4603      	mov	r3, r0
 801b0ce:	2b00      	cmp	r3, #0
 801b0d0:	d165      	bne.n	801b19e <_ecc_projective_add_point+0x492>
           /* T1 = Z' * Z' */
           err = mp_sqr(Q->z, t1);
 801b0d2:	68bb      	ldr	r3, [r7, #8]
 801b0d4:	689b      	ldr	r3, [r3, #8]
 801b0d6:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b0da:	4618      	mov	r0, r3
 801b0dc:	f00c f968 	bl	80273b0 <mp_sqr>
 801b0e0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801b0e4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b0e8:	2b00      	cmp	r3, #0
 801b0ea:	d109      	bne.n	801b100 <_ecc_projective_add_point+0x3f4>
               err = mp_montgomery_reduce(t1, modulus, mp);
 801b0ec:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b0f0:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b0f4:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b0f8:	f00c f92a 	bl	8027350 <mp_montgomery_reduce>
 801b0fc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

           /* X = X * T1 */
           if (err == MP_OKAY)
 801b100:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b104:	2b00      	cmp	r3, #0
 801b106:	d107      	bne.n	801b118 <_ecc_projective_add_point+0x40c>
               err = mp_mul(t1, x, x);
 801b108:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801b10a:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b10c:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b110:	f00b fd57 	bl	8026bc2 <mp_mul>
 801b114:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801b118:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b11c:	2b00      	cmp	r3, #0
 801b11e:	d108      	bne.n	801b132 <_ecc_projective_add_point+0x426>
               err = mp_montgomery_reduce(x, modulus, mp);
 801b120:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b124:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b128:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b12a:	f00c f911 	bl	8027350 <mp_montgomery_reduce>
 801b12e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

           /* T1 = Z' * T1 */
           if (err == MP_OKAY)
 801b132:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b136:	2b00      	cmp	r3, #0
 801b138:	d10a      	bne.n	801b150 <_ecc_projective_add_point+0x444>
               err = mp_mul(Q->z, t1, t1);
 801b13a:	68bb      	ldr	r3, [r7, #8]
 801b13c:	689b      	ldr	r3, [r3, #8]
 801b13e:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b142:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b146:	4618      	mov	r0, r3
 801b148:	f00b fd3b 	bl	8026bc2 <mp_mul>
 801b14c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801b150:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b154:	2b00      	cmp	r3, #0
 801b156:	d109      	bne.n	801b16c <_ecc_projective_add_point+0x460>
               err = mp_montgomery_reduce(t1, modulus, mp);
 801b158:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b15c:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b160:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b164:	f00c f8f4 	bl	8027350 <mp_montgomery_reduce>
 801b168:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

           /* Y = Y * T1 */
           if (err == MP_OKAY)
 801b16c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b170:	2b00      	cmp	r3, #0
 801b172:	d107      	bne.n	801b184 <_ecc_projective_add_point+0x478>
               err = mp_mul(t1, y, y);
 801b174:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801b176:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801b178:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b17c:	f00b fd21 	bl	8026bc2 <mp_mul>
 801b180:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801b184:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b188:	2b00      	cmp	r3, #0
 801b18a:	d108      	bne.n	801b19e <_ecc_projective_add_point+0x492>
               err = mp_montgomery_reduce(y, modulus, mp);
 801b18c:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b190:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b194:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b196:	f00c f8db 	bl	8027350 <mp_montgomery_reduce>
 801b19a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
       }
   }

   /* T1 = Z*Z */
   if (err == MP_OKAY)
 801b19e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b1a2:	2b00      	cmp	r3, #0
 801b1a4:	d106      	bne.n	801b1b4 <_ecc_projective_add_point+0x4a8>
       err = mp_sqr(z, t1);
 801b1a6:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b1aa:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b1ac:	f00c f900 	bl	80273b0 <mp_sqr>
 801b1b0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b1b4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b1b8:	2b00      	cmp	r3, #0
 801b1ba:	d109      	bne.n	801b1d0 <_ecc_projective_add_point+0x4c4>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b1bc:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b1c0:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b1c4:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b1c8:	f00c f8c2 	bl	8027350 <mp_montgomery_reduce>
 801b1cc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = X' * T1 */
   if (err == MP_OKAY)
 801b1d0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b1d4:	2b00      	cmp	r3, #0
 801b1d6:	d10a      	bne.n	801b1ee <_ecc_projective_add_point+0x4e2>
       err = mp_mul(Q->x, t1, t2);
 801b1d8:	68bb      	ldr	r3, [r7, #8]
 801b1da:	681b      	ldr	r3, [r3, #0]
 801b1dc:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b1e0:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b1e4:	4618      	mov	r0, r3
 801b1e6:	f00b fcec 	bl	8026bc2 <mp_mul>
 801b1ea:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b1ee:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b1f2:	2b00      	cmp	r3, #0
 801b1f4:	d109      	bne.n	801b20a <_ecc_projective_add_point+0x4fe>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b1f6:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b1fa:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b1fe:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b202:	f00c f8a5 	bl	8027350 <mp_montgomery_reduce>
 801b206:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = Z * T1 */
   if (err == MP_OKAY)
 801b20a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b20e:	2b00      	cmp	r3, #0
 801b210:	d108      	bne.n	801b224 <_ecc_projective_add_point+0x518>
       err = mp_mul(z, t1, t1);
 801b212:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b216:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b21a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b21c:	f00b fcd1 	bl	8026bc2 <mp_mul>
 801b220:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b224:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b228:	2b00      	cmp	r3, #0
 801b22a:	d109      	bne.n	801b240 <_ecc_projective_add_point+0x534>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b22c:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b230:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b234:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b238:	f00c f88a 	bl	8027350 <mp_montgomery_reduce>
 801b23c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = Y' * T1 */
   if (err == MP_OKAY)
 801b240:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b244:	2b00      	cmp	r3, #0
 801b246:	d10a      	bne.n	801b25e <_ecc_projective_add_point+0x552>
       err = mp_mul(Q->y, t1, t1);
 801b248:	68bb      	ldr	r3, [r7, #8]
 801b24a:	685b      	ldr	r3, [r3, #4]
 801b24c:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b250:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b254:	4618      	mov	r0, r3
 801b256:	f00b fcb4 	bl	8026bc2 <mp_mul>
 801b25a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b25e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b262:	2b00      	cmp	r3, #0
 801b264:	d109      	bne.n	801b27a <_ecc_projective_add_point+0x56e>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b266:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b26a:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b26e:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b272:	f00c f86d 	bl	8027350 <mp_montgomery_reduce>
 801b276:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y - T1 */
   if (err == MP_OKAY)
 801b27a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b27e:	2b00      	cmp	r3, #0
 801b280:	d109      	bne.n	801b296 <_ecc_projective_add_point+0x58a>
       err = mp_submod_ct(y, t1, modulus, y);
 801b282:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801b284:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b288:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b28c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b28e:	f00b fcbd 	bl	8026c0c <mp_submod_ct>
 801b292:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T1 = 2T1 */
   if (err == MP_OKAY)
 801b296:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b29a:	2b00      	cmp	r3, #0
 801b29c:	d10b      	bne.n	801b2b6 <_ecc_projective_add_point+0x5aa>
       err = mp_addmod_ct(t1, t1, modulus, t1);
 801b29e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b2a2:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b2a6:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b2aa:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b2ae:	f00b fcbf 	bl	8026c30 <mp_addmod_ct>
 801b2b2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T1 = Y + T1 */
   if (err == MP_OKAY)
 801b2b6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b2ba:	2b00      	cmp	r3, #0
 801b2bc:	d10a      	bne.n	801b2d4 <_ecc_projective_add_point+0x5c8>
       err = mp_addmod_ct(t1, y, modulus, t1);
 801b2be:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b2c2:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b2c6:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801b2c8:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b2cc:	f00b fcb0 	bl	8026c30 <mp_addmod_ct>
 801b2d0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* X = X - T2 */
   if (err == MP_OKAY)
 801b2d4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b2d8:	2b00      	cmp	r3, #0
 801b2da:	d109      	bne.n	801b2f0 <_ecc_projective_add_point+0x5e4>
       err = mp_submod_ct(x, t2, modulus, x);
 801b2dc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801b2de:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b2e2:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b2e6:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b2e8:	f00b fc90 	bl	8026c0c <mp_submod_ct>
 801b2ec:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = 2T2 */
   if (err == MP_OKAY)
 801b2f0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b2f4:	2b00      	cmp	r3, #0
 801b2f6:	d10b      	bne.n	801b310 <_ecc_projective_add_point+0x604>
       err = mp_addmod_ct(t2, t2, modulus, t2);
 801b2f8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b2fc:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b300:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b304:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b308:	f00b fc92 	bl	8026c30 <mp_addmod_ct>
 801b30c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = X + T2 */
   if (err == MP_OKAY)
 801b310:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b314:	2b00      	cmp	r3, #0
 801b316:	d10a      	bne.n	801b32e <_ecc_projective_add_point+0x622>
       err = mp_addmod_ct(t2, x, modulus, t2);
 801b318:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b31c:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b320:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b322:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b326:	f00b fc83 	bl	8026c30 <mp_addmod_ct>
 801b32a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   if (err == MP_OKAY) {
 801b32e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b332:	2b00      	cmp	r3, #0
 801b334:	d11d      	bne.n	801b372 <_ecc_projective_add_point+0x666>
       if (!mp_iszero(Q->z)) {
 801b336:	68bb      	ldr	r3, [r7, #8]
 801b338:	689b      	ldr	r3, [r3, #8]
 801b33a:	4618      	mov	r0, r3
 801b33c:	f00b fda7 	bl	8026e8e <mp_iszero>
 801b340:	4603      	mov	r3, r0
 801b342:	2b00      	cmp	r3, #0
 801b344:	d115      	bne.n	801b372 <_ecc_projective_add_point+0x666>
           /* Z = Z * Z' */
           err = mp_mul(z, Q->z, z);
 801b346:	68bb      	ldr	r3, [r7, #8]
 801b348:	689b      	ldr	r3, [r3, #8]
 801b34a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801b34c:	4619      	mov	r1, r3
 801b34e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b350:	f00b fc37 	bl	8026bc2 <mp_mul>
 801b354:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801b358:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b35c:	2b00      	cmp	r3, #0
 801b35e:	d108      	bne.n	801b372 <_ecc_projective_add_point+0x666>
               err = mp_montgomery_reduce(z, modulus, mp);
 801b360:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b364:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b368:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b36a:	f00b fff1 	bl	8027350 <mp_montgomery_reduce>
 801b36e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
       }
   }

   /* Z = Z * X */
   if (err == MP_OKAY)
 801b372:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b376:	2b00      	cmp	r3, #0
 801b378:	d106      	bne.n	801b388 <_ecc_projective_add_point+0x67c>
       err = mp_mul(z, x, z);
 801b37a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801b37c:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b37e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b380:	f00b fc1f 	bl	8026bc2 <mp_mul>
 801b384:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b388:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b38c:	2b00      	cmp	r3, #0
 801b38e:	d108      	bne.n	801b3a2 <_ecc_projective_add_point+0x696>
       err = mp_montgomery_reduce(z, modulus, mp);
 801b390:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b394:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b398:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b39a:	f00b ffd9 	bl	8027350 <mp_montgomery_reduce>
 801b39e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = T1 * X  */
   if (err == MP_OKAY)
 801b3a2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3a6:	2b00      	cmp	r3, #0
 801b3a8:	d108      	bne.n	801b3bc <_ecc_projective_add_point+0x6b0>
       err = mp_mul(t1, x, t1);
 801b3aa:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b3ae:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b3b0:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b3b4:	f00b fc05 	bl	8026bc2 <mp_mul>
 801b3b8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b3bc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3c0:	2b00      	cmp	r3, #0
 801b3c2:	d109      	bne.n	801b3d8 <_ecc_projective_add_point+0x6cc>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b3c4:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b3c8:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b3cc:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b3d0:	f00b ffbe 	bl	8027350 <mp_montgomery_reduce>
 801b3d4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = X * X */
   if (err == MP_OKAY)
 801b3d8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3dc:	2b00      	cmp	r3, #0
 801b3de:	d105      	bne.n	801b3ec <_ecc_projective_add_point+0x6e0>
       err = mp_sqr(x, x);
 801b3e0:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b3e2:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b3e4:	f00b ffe4 	bl	80273b0 <mp_sqr>
 801b3e8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b3ec:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3f0:	2b00      	cmp	r3, #0
 801b3f2:	d108      	bne.n	801b406 <_ecc_projective_add_point+0x6fa>
       err = mp_montgomery_reduce(x, modulus, mp);
 801b3f4:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b3f8:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b3fc:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b3fe:	f00b ffa7 	bl	8027350 <mp_montgomery_reduce>
 801b402:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = T2 * x */
   if (err == MP_OKAY)
 801b406:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b40a:	2b00      	cmp	r3, #0
 801b40c:	d108      	bne.n	801b420 <_ecc_projective_add_point+0x714>
       err = mp_mul(t2, x, t2);
 801b40e:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b412:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b414:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b418:	f00b fbd3 	bl	8026bc2 <mp_mul>
 801b41c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b420:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b424:	2b00      	cmp	r3, #0
 801b426:	d109      	bne.n	801b43c <_ecc_projective_add_point+0x730>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b428:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b42c:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b430:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b434:	f00b ff8c 	bl	8027350 <mp_montgomery_reduce>
 801b438:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = T1 * X  */
   if (err == MP_OKAY)
 801b43c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b440:	2b00      	cmp	r3, #0
 801b442:	d108      	bne.n	801b456 <_ecc_projective_add_point+0x74a>
       err = mp_mul(t1, x, t1);
 801b444:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b448:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b44a:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b44e:	f00b fbb8 	bl	8026bc2 <mp_mul>
 801b452:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b456:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b45a:	2b00      	cmp	r3, #0
 801b45c:	d109      	bne.n	801b472 <_ecc_projective_add_point+0x766>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b45e:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b462:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b466:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b46a:	f00b ff71 	bl	8027350 <mp_montgomery_reduce>
 801b46e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = Y*Y */
   if (err == MP_OKAY)
 801b472:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b476:	2b00      	cmp	r3, #0
 801b478:	d105      	bne.n	801b486 <_ecc_projective_add_point+0x77a>
       err = mp_sqr(y, x);
 801b47a:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b47c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b47e:	f00b ff97 	bl	80273b0 <mp_sqr>
 801b482:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b486:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b48a:	2b00      	cmp	r3, #0
 801b48c:	d108      	bne.n	801b4a0 <_ecc_projective_add_point+0x794>
       err = mp_montgomery_reduce(x, modulus, mp);
 801b48e:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b492:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b496:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b498:	f00b ff5a 	bl	8027350 <mp_montgomery_reduce>
 801b49c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = X - T2 */
   if (err == MP_OKAY)
 801b4a0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b4a4:	2b00      	cmp	r3, #0
 801b4a6:	d109      	bne.n	801b4bc <_ecc_projective_add_point+0x7b0>
       err = mp_submod_ct(x, t2, modulus, x);
 801b4a8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801b4aa:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b4ae:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b4b2:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b4b4:	f00b fbaa 	bl	8026c0c <mp_submod_ct>
 801b4b8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = T2 - X */
   if (err == MP_OKAY)
 801b4bc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b4c0:	2b00      	cmp	r3, #0
 801b4c2:	d10a      	bne.n	801b4da <_ecc_projective_add_point+0x7ce>
       err = mp_submod_ct(t2, x, modulus, t2);
 801b4c4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b4c8:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b4cc:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b4ce:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b4d2:	f00b fb9b 	bl	8026c0c <mp_submod_ct>
 801b4d6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = T2 - X */
   if (err == MP_OKAY)
 801b4da:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b4de:	2b00      	cmp	r3, #0
 801b4e0:	d10a      	bne.n	801b4f8 <_ecc_projective_add_point+0x7ec>
       err = mp_submod_ct(t2, x, modulus, t2);
 801b4e2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b4e6:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b4ea:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b4ec:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b4f0:	f00b fb8c 	bl	8026c0c <mp_submod_ct>
 801b4f4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = T2 * Y */
   if (err == MP_OKAY)
 801b4f8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b4fc:	2b00      	cmp	r3, #0
 801b4fe:	d108      	bne.n	801b512 <_ecc_projective_add_point+0x806>
       err = mp_mul(t2, y, t2);
 801b500:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b504:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801b506:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b50a:	f00b fb5a 	bl	8026bc2 <mp_mul>
 801b50e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b512:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b516:	2b00      	cmp	r3, #0
 801b518:	d109      	bne.n	801b52e <_ecc_projective_add_point+0x822>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b51a:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b51e:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b522:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b526:	f00b ff13 	bl	8027350 <mp_montgomery_reduce>
 801b52a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = T2 - T1 */
   if (err == MP_OKAY)
 801b52e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b532:	2b00      	cmp	r3, #0
 801b534:	d10a      	bne.n	801b54c <_ecc_projective_add_point+0x840>
       err = mp_submod_ct(t2, t1, modulus, y);
 801b536:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801b538:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b53c:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b540:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b544:	f00b fb62 	bl	8026c0c <mp_submod_ct>
 801b548:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* Y = Y/2 */
   if (err == MP_OKAY)
 801b54c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b550:	2b00      	cmp	r3, #0
 801b552:	d107      	bne.n	801b564 <_ecc_projective_add_point+0x858>
       err = mp_div_2_mod_ct(y, modulus, y);
 801b554:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801b556:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b55a:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b55c:	f00b ff36 	bl	80273cc <mp_div_2_mod_ct>
 801b560:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

#ifdef ALT_ECC_SIZE
   if (err == MP_OKAY)
 801b564:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b568:	2b00      	cmp	r3, #0
 801b56a:	d107      	bne.n	801b57c <_ecc_projective_add_point+0x870>
       err = mp_copy(x, R->x);
 801b56c:	687b      	ldr	r3, [r7, #4]
 801b56e:	681b      	ldr	r3, [r3, #0]
 801b570:	4619      	mov	r1, r3
 801b572:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b574:	f00b fc7d 	bl	8026e72 <mp_copy>
 801b578:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b57c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b580:	2b00      	cmp	r3, #0
 801b582:	d107      	bne.n	801b594 <_ecc_projective_add_point+0x888>
       err = mp_copy(y, R->y);
 801b584:	687b      	ldr	r3, [r7, #4]
 801b586:	685b      	ldr	r3, [r3, #4]
 801b588:	4619      	mov	r1, r3
 801b58a:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b58c:	f00b fc71 	bl	8026e72 <mp_copy>
 801b590:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b594:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b598:	2b00      	cmp	r3, #0
 801b59a:	d10c      	bne.n	801b5b6 <_ecc_projective_add_point+0x8aa>
       err = mp_copy(z, R->z);
 801b59c:	687b      	ldr	r3, [r7, #4]
 801b59e:	689b      	ldr	r3, [r3, #8]
 801b5a0:	4619      	mov	r1, r3
 801b5a2:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b5a4:	f00b fc65 	bl	8026e72 <mp_copy>
 801b5a8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
 801b5ac:	e004      	b.n	801b5b8 <_ecc_projective_add_point+0x8ac>
      goto done;
 801b5ae:	bf00      	nop
 801b5b0:	e002      	b.n	801b5b8 <_ecc_projective_add_point+0x8ac>
      goto done;
 801b5b2:	bf00      	nop
 801b5b4:	e000      	b.n	801b5b8 <_ecc_projective_add_point+0x8ac>
#endif

done:
 801b5b6:	bf00      	nop

   /* clean up */
   mp_clear(t1);
 801b5b8:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b5bc:	f00b fa97 	bl	8026aee <mp_clear>
   mp_clear(t2);
 801b5c0:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b5c4:	f00b fa93 	bl	8026aee <mp_clear>
   if (R->key == NULL)
#endif
#endif
   {
   #ifdef ALT_ECC_SIZE
      FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b5c8:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b5ca:	653b      	str	r3, [r7, #80]	@ 0x50
 801b5cc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b5ce:	2b00      	cmp	r3, #0
 801b5d0:	d002      	beq.n	801b5d8 <_ecc_projective_add_point+0x8cc>
 801b5d2:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801b5d4:	f003 fb6e 	bl	801ecb4 <wolfSSL_Free>
      FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b5d8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b5da:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801b5dc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b5de:	2b00      	cmp	r3, #0
 801b5e0:	d002      	beq.n	801b5e8 <_ecc_projective_add_point+0x8dc>
 801b5e2:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801b5e4:	f003 fb66 	bl	801ecb4 <wolfSSL_Free>
      FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b5e8:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b5ec:	64bb      	str	r3, [r7, #72]	@ 0x48
 801b5ee:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b5f0:	2b00      	cmp	r3, #0
 801b5f2:	d002      	beq.n	801b5fa <_ecc_projective_add_point+0x8ee>
 801b5f4:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801b5f6:	f003 fb5d 	bl	801ecb4 <wolfSSL_Free>
   #endif
      FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b5fa:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b5fe:	647b      	str	r3, [r7, #68]	@ 0x44
 801b600:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b602:	2b00      	cmp	r3, #0
 801b604:	d002      	beq.n	801b60c <_ecc_projective_add_point+0x900>
 801b606:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801b608:	f003 fb54 	bl	801ecb4 <wolfSSL_Free>
      FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b60c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b610:	643b      	str	r3, [r7, #64]	@ 0x40
 801b612:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b614:	2b00      	cmp	r3, #0
 801b616:	d002      	beq.n	801b61e <_ecc_projective_add_point+0x912>
 801b618:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801b61a:	f003 fb4b 	bl	801ecb4 <wolfSSL_Free>
   }

   return err;
 801b61e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
                                         R->x, R->y, R->z);
    }
#endif
    return ECC_BAD_ARG_E;
#endif
}
 801b622:	4618      	mov	r0, r3
 801b624:	3790      	adds	r7, #144	@ 0x90
 801b626:	46bd      	mov	sp, r7
 801b628:	bd80      	pop	{r7, pc}

0801b62a <_ecc_projective_dbl_point>:
   mp       The "b" value from montgomery_setup()
   return   MP_OKAY on success
*/
static int _ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,
                                     mp_int* modulus, mp_digit mp)
{
 801b62a:	b580      	push	{r7, lr}
 801b62c:	b0a4      	sub	sp, #144	@ 0x90
 801b62e:	af00      	add	r7, sp, #0
 801b630:	60f8      	str	r0, [r7, #12]
 801b632:	60b9      	str	r1, [r7, #8]
 801b634:	607a      	str	r2, [r7, #4]
 801b636:	603b      	str	r3, [r7, #0]
#if !defined(WOLFSSL_SP_MATH)
   DECL_MP_INT_SIZE_DYN(t1, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b638:	2300      	movs	r3, #0
 801b63a:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
   DECL_MP_INT_SIZE_DYN(t2, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b63e:	2300      	movs	r3, #0
 801b640:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
#ifdef ALT_ECC_SIZE
   DECL_MP_INT_SIZE_DYN(rx, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b644:	2300      	movs	r3, #0
 801b646:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
   DECL_MP_INT_SIZE_DYN(ry, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b64a:	2300      	movs	r3, #0
 801b64c:	67fb      	str	r3, [r7, #124]	@ 0x7c
   DECL_MP_INT_SIZE_DYN(rz, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b64e:	2300      	movs	r3, #0
 801b650:	67bb      	str	r3, [r7, #120]	@ 0x78
   }
   else
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#endif
   {
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b652:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b656:	f003 fb11 	bl	801ec7c <wolfSSL_Malloc>
 801b65a:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
 801b65e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b662:	2b00      	cmp	r3, #0
 801b664:	d006      	beq.n	801b674 <_ecc_projective_dbl_point+0x4a>
 801b666:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b66a:	2100      	movs	r1, #0
 801b66c:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b670:	f00d fad8 	bl	8028c24 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b674:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b678:	f003 fb00 	bl	801ec7c <wolfSSL_Malloc>
 801b67c:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
 801b680:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b684:	2b00      	cmp	r3, #0
 801b686:	d006      	beq.n	801b696 <_ecc_projective_dbl_point+0x6c>
 801b688:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b68c:	2100      	movs	r1, #0
 801b68e:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b692:	f00d fac7 	bl	8028c24 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (t1 == NULL || t2 == NULL) {
 801b696:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b69a:	2b00      	cmp	r3, #0
 801b69c:	d003      	beq.n	801b6a6 <_ecc_projective_dbl_point+0x7c>
 801b69e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b6a2:	2b00      	cmp	r3, #0
 801b6a4:	d114      	bne.n	801b6d0 <_ecc_projective_dbl_point+0xa6>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b6a6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b6aa:	61bb      	str	r3, [r7, #24]
 801b6ac:	69bb      	ldr	r3, [r7, #24]
 801b6ae:	2b00      	cmp	r3, #0
 801b6b0:	d002      	beq.n	801b6b8 <_ecc_projective_dbl_point+0x8e>
 801b6b2:	69b8      	ldr	r0, [r7, #24]
 801b6b4:	f003 fafe 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b6b8:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b6bc:	617b      	str	r3, [r7, #20]
 801b6be:	697b      	ldr	r3, [r7, #20]
 801b6c0:	2b00      	cmp	r3, #0
 801b6c2:	d002      	beq.n	801b6ca <_ecc_projective_dbl_point+0xa0>
 801b6c4:	6978      	ldr	r0, [r7, #20]
 801b6c6:	f003 faf5 	bl	801ecb4 <wolfSSL_Free>
         return MEMORY_E;
 801b6ca:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801b6ce:	e2c1      	b.n	801bc54 <_ecc_projective_dbl_point+0x62a>
      }
   #endif
   #ifdef ALT_ECC_SIZE
      NEW_MP_INT_SIZE(rx, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b6d0:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b6d4:	f003 fad2 	bl	801ec7c <wolfSSL_Malloc>
 801b6d8:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
 801b6dc:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b6e0:	2b00      	cmp	r3, #0
 801b6e2:	d006      	beq.n	801b6f2 <_ecc_projective_dbl_point+0xc8>
 801b6e4:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b6e8:	2100      	movs	r1, #0
 801b6ea:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801b6ee:	f00d fa99 	bl	8028c24 <memset>
      NEW_MP_INT_SIZE(ry, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b6f2:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b6f6:	f003 fac1 	bl	801ec7c <wolfSSL_Malloc>
 801b6fa:	67f8      	str	r0, [r7, #124]	@ 0x7c
 801b6fc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b6fe:	2b00      	cmp	r3, #0
 801b700:	d005      	beq.n	801b70e <_ecc_projective_dbl_point+0xe4>
 801b702:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b706:	2100      	movs	r1, #0
 801b708:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801b70a:	f00d fa8b 	bl	8028c24 <memset>
      NEW_MP_INT_SIZE(rz, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b70e:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b712:	f003 fab3 	bl	801ec7c <wolfSSL_Malloc>
 801b716:	67b8      	str	r0, [r7, #120]	@ 0x78
 801b718:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b71a:	2b00      	cmp	r3, #0
 801b71c:	d005      	beq.n	801b72a <_ecc_projective_dbl_point+0x100>
 801b71e:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b722:	2100      	movs	r1, #0
 801b724:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 801b726:	f00d fa7d 	bl	8028c24 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (rx == NULL || ry == NULL || rz == NULL) {
 801b72a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b72e:	2b00      	cmp	r3, #0
 801b730:	d005      	beq.n	801b73e <_ecc_projective_dbl_point+0x114>
 801b732:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b734:	2b00      	cmp	r3, #0
 801b736:	d002      	beq.n	801b73e <_ecc_projective_dbl_point+0x114>
 801b738:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b73a:	2b00      	cmp	r3, #0
 801b73c:	d12d      	bne.n	801b79a <_ecc_projective_dbl_point+0x170>
          FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b73e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b740:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801b742:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b744:	2b00      	cmp	r3, #0
 801b746:	d002      	beq.n	801b74e <_ecc_projective_dbl_point+0x124>
 801b748:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801b74a:	f003 fab3 	bl	801ecb4 <wolfSSL_Free>
          FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b74e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b750:	62bb      	str	r3, [r7, #40]	@ 0x28
 801b752:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801b754:	2b00      	cmp	r3, #0
 801b756:	d002      	beq.n	801b75e <_ecc_projective_dbl_point+0x134>
 801b758:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801b75a:	f003 faab 	bl	801ecb4 <wolfSSL_Free>
          FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b75e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b762:	627b      	str	r3, [r7, #36]	@ 0x24
 801b764:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801b766:	2b00      	cmp	r3, #0
 801b768:	d002      	beq.n	801b770 <_ecc_projective_dbl_point+0x146>
 801b76a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801b76c:	f003 faa2 	bl	801ecb4 <wolfSSL_Free>
          FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b770:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b774:	623b      	str	r3, [r7, #32]
 801b776:	6a3b      	ldr	r3, [r7, #32]
 801b778:	2b00      	cmp	r3, #0
 801b77a:	d002      	beq.n	801b782 <_ecc_projective_dbl_point+0x158>
 801b77c:	6a38      	ldr	r0, [r7, #32]
 801b77e:	f003 fa99 	bl	801ecb4 <wolfSSL_Free>
          FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b782:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b786:	61fb      	str	r3, [r7, #28]
 801b788:	69fb      	ldr	r3, [r7, #28]
 801b78a:	2b00      	cmp	r3, #0
 801b78c:	d002      	beq.n	801b794 <_ecc_projective_dbl_point+0x16a>
 801b78e:	69f8      	ldr	r0, [r7, #28]
 801b790:	f003 fa90 	bl	801ecb4 <wolfSSL_Free>
          return MEMORY_E;
 801b794:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801b798:	e25c      	b.n	801bc54 <_ecc_projective_dbl_point+0x62a>
      }
   #endif
   #endif
   }

   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
 801b79a:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b79e:	f00b f91c 	bl	80269da <mp_init>
 801b7a2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801b7a6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b7aa:	2b00      	cmp	r3, #0
 801b7ac:	d105      	bne.n	801b7ba <_ecc_projective_dbl_point+0x190>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
 801b7ae:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b7b2:	f00b f912 	bl	80269da <mp_init>
 801b7b6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801b7ba:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b7be:	2b00      	cmp	r3, #0
 801b7c0:	d02d      	beq.n	801b81e <_ecc_projective_dbl_point+0x1f4>
      if (R->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b7c2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b7c4:	643b      	str	r3, [r7, #64]	@ 0x40
 801b7c6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b7c8:	2b00      	cmp	r3, #0
 801b7ca:	d002      	beq.n	801b7d2 <_ecc_projective_dbl_point+0x1a8>
 801b7cc:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801b7ce:	f003 fa71 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b7d2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b7d4:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801b7d6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b7d8:	2b00      	cmp	r3, #0
 801b7da:	d002      	beq.n	801b7e2 <_ecc_projective_dbl_point+0x1b8>
 801b7dc:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801b7de:	f003 fa69 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b7e2:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b7e6:	63bb      	str	r3, [r7, #56]	@ 0x38
 801b7e8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b7ea:	2b00      	cmp	r3, #0
 801b7ec:	d002      	beq.n	801b7f4 <_ecc_projective_dbl_point+0x1ca>
 801b7ee:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801b7f0:	f003 fa60 	bl	801ecb4 <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b7f4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b7f8:	637b      	str	r3, [r7, #52]	@ 0x34
 801b7fa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b7fc:	2b00      	cmp	r3, #0
 801b7fe:	d002      	beq.n	801b806 <_ecc_projective_dbl_point+0x1dc>
 801b800:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801b802:	f003 fa57 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b806:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b80a:	633b      	str	r3, [r7, #48]	@ 0x30
 801b80c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b80e:	2b00      	cmp	r3, #0
 801b810:	d002      	beq.n	801b818 <_ecc_projective_dbl_point+0x1ee>
 801b812:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801b814:	f003 fa4e 	bl	801ecb4 <wolfSSL_Free>
      }
      return err;
 801b818:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b81c:	e21a      	b.n	801bc54 <_ecc_projective_dbl_point+0x62a>

/* If use ALT_ECC_SIZE we need to use local stack variable since
   ecc_point x,y,z is reduced size */
#ifdef ALT_ECC_SIZE
   /* Use local stack variable */
   x = rx;
 801b81e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b822:	677b      	str	r3, [r7, #116]	@ 0x74
   y = ry;
 801b824:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b826:	673b      	str	r3, [r7, #112]	@ 0x70
   z = rz;
 801b828:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b82a:	66fb      	str	r3, [r7, #108]	@ 0x6c

   err = INIT_MP_INT_SIZE(x, mp_bitsused(modulus));
 801b82c:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b82e:	f00b f8d4 	bl	80269da <mp_init>
 801b832:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801b836:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b83a:	2b00      	cmp	r3, #0
 801b83c:	d104      	bne.n	801b848 <_ecc_projective_dbl_point+0x21e>
      err = INIT_MP_INT_SIZE(y, mp_bitsused(modulus));
 801b83e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b840:	f00b f8cb 	bl	80269da <mp_init>
 801b844:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err == MP_OKAY) {
 801b848:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b84c:	2b00      	cmp	r3, #0
 801b84e:	d104      	bne.n	801b85a <_ecc_projective_dbl_point+0x230>
      err = INIT_MP_INT_SIZE(z, mp_bitsused(modulus));
 801b850:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b852:	f00b f8c2 	bl	80269da <mp_init>
 801b856:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801b85a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b85e:	2b00      	cmp	r3, #0
 801b860:	d02d      	beq.n	801b8be <_ecc_projective_dbl_point+0x294>
      if (R->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b862:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b864:	657b      	str	r3, [r7, #84]	@ 0x54
 801b866:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b868:	2b00      	cmp	r3, #0
 801b86a:	d002      	beq.n	801b872 <_ecc_projective_dbl_point+0x248>
 801b86c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b86e:	f003 fa21 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b872:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b874:	653b      	str	r3, [r7, #80]	@ 0x50
 801b876:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b878:	2b00      	cmp	r3, #0
 801b87a:	d002      	beq.n	801b882 <_ecc_projective_dbl_point+0x258>
 801b87c:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801b87e:	f003 fa19 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b882:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b886:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801b888:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b88a:	2b00      	cmp	r3, #0
 801b88c:	d002      	beq.n	801b894 <_ecc_projective_dbl_point+0x26a>
 801b88e:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801b890:	f003 fa10 	bl	801ecb4 <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b894:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b898:	64bb      	str	r3, [r7, #72]	@ 0x48
 801b89a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b89c:	2b00      	cmp	r3, #0
 801b89e:	d002      	beq.n	801b8a6 <_ecc_projective_dbl_point+0x27c>
 801b8a0:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801b8a2:	f003 fa07 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b8a6:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b8aa:	647b      	str	r3, [r7, #68]	@ 0x44
 801b8ac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b8ae:	2b00      	cmp	r3, #0
 801b8b0:	d002      	beq.n	801b8b8 <_ecc_projective_dbl_point+0x28e>
 801b8b2:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801b8b4:	f003 f9fe 	bl	801ecb4 <wolfSSL_Free>
      }
      return err;
 801b8b8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8bc:	e1ca      	b.n	801bc54 <_ecc_projective_dbl_point+0x62a>
   x = R->x;
   y = R->y;
   z = R->z;
#endif

   if (err == MP_OKAY)
 801b8be:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8c2:	2b00      	cmp	r3, #0
 801b8c4:	d107      	bne.n	801b8d6 <_ecc_projective_dbl_point+0x2ac>
       err = mp_copy(P->x, x);
 801b8c6:	68fb      	ldr	r3, [r7, #12]
 801b8c8:	681b      	ldr	r3, [r3, #0]
 801b8ca:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b8cc:	4618      	mov	r0, r3
 801b8ce:	f00b fad0 	bl	8026e72 <mp_copy>
 801b8d2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b8d6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8da:	2b00      	cmp	r3, #0
 801b8dc:	d107      	bne.n	801b8ee <_ecc_projective_dbl_point+0x2c4>
       err = mp_copy(P->y, y);
 801b8de:	68fb      	ldr	r3, [r7, #12]
 801b8e0:	685b      	ldr	r3, [r3, #4]
 801b8e2:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b8e4:	4618      	mov	r0, r3
 801b8e6:	f00b fac4 	bl	8026e72 <mp_copy>
 801b8ea:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b8ee:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8f2:	2b00      	cmp	r3, #0
 801b8f4:	d107      	bne.n	801b906 <_ecc_projective_dbl_point+0x2dc>
       err = mp_copy(P->z, z);
 801b8f6:	68fb      	ldr	r3, [r7, #12]
 801b8f8:	689b      	ldr	r3, [r3, #8]
 801b8fa:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801b8fc:	4618      	mov	r0, r3
 801b8fe:	f00b fab8 	bl	8026e72 <mp_copy>
 801b902:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = Z * Z */
   if (err == MP_OKAY)
 801b906:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b90a:	2b00      	cmp	r3, #0
 801b90c:	d106      	bne.n	801b91c <_ecc_projective_dbl_point+0x2f2>
       err = mp_sqr(z, t1);
 801b90e:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b912:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b914:	f00b fd4c 	bl	80273b0 <mp_sqr>
 801b918:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b91c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b920:	2b00      	cmp	r3, #0
 801b922:	d108      	bne.n	801b936 <_ecc_projective_dbl_point+0x30c>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b924:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b928:	6839      	ldr	r1, [r7, #0]
 801b92a:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b92e:	f00b fd0f 	bl	8027350 <mp_montgomery_reduce>
 801b932:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Z = Y * Z */
   if (err == MP_OKAY)
 801b936:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b93a:	2b00      	cmp	r3, #0
 801b93c:	d106      	bne.n	801b94c <_ecc_projective_dbl_point+0x322>
       err = mp_mul(z, y, z);
 801b93e:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801b940:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b942:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b944:	f00b f93d 	bl	8026bc2 <mp_mul>
 801b948:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b94c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b950:	2b00      	cmp	r3, #0
 801b952:	d107      	bne.n	801b964 <_ecc_projective_dbl_point+0x33a>
       err = mp_montgomery_reduce(z, modulus, mp);
 801b954:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b958:	6839      	ldr	r1, [r7, #0]
 801b95a:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b95c:	f00b fcf8 	bl	8027350 <mp_montgomery_reduce>
 801b960:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Z = 2Z */
   if (err == MP_OKAY)
 801b964:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b968:	2b00      	cmp	r3, #0
 801b96a:	d107      	bne.n	801b97c <_ecc_projective_dbl_point+0x352>
       err = mp_addmod_ct(z, z, modulus, z);
 801b96c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801b96e:	683a      	ldr	r2, [r7, #0]
 801b970:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801b972:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b974:	f00b f95c 	bl	8026c30 <mp_addmod_ct>
 801b978:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   {
      /* assumes "a" == 3 */
      (void)a;

      /* T2 = X - T1 */
      if (err == MP_OKAY)
 801b97c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b980:	2b00      	cmp	r3, #0
 801b982:	d109      	bne.n	801b998 <_ecc_projective_dbl_point+0x36e>
          err = mp_submod_ct(x, t1, modulus, t2);
 801b984:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b988:	683a      	ldr	r2, [r7, #0]
 801b98a:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b98e:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b990:	f00b f93c 	bl	8026c0c <mp_submod_ct>
 801b994:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      /* T1 = X + T1 */
      if (err == MP_OKAY)
 801b998:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b99c:	2b00      	cmp	r3, #0
 801b99e:	d109      	bne.n	801b9b4 <_ecc_projective_dbl_point+0x38a>
          err = mp_addmod_ct(t1, x, modulus, t1);
 801b9a0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b9a4:	683a      	ldr	r2, [r7, #0]
 801b9a6:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b9a8:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b9ac:	f00b f940 	bl	8026c30 <mp_addmod_ct>
 801b9b0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      /* T2 = T1 * T2 */
      if (err == MP_OKAY)
 801b9b4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9b8:	2b00      	cmp	r3, #0
 801b9ba:	d109      	bne.n	801b9d0 <_ecc_projective_dbl_point+0x3a6>
          err = mp_mul(t1, t2, t2);
 801b9bc:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b9c0:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b9c4:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b9c8:	f00b f8fb 	bl	8026bc2 <mp_mul>
 801b9cc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      if (err == MP_OKAY)
 801b9d0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9d4:	2b00      	cmp	r3, #0
 801b9d6:	d108      	bne.n	801b9ea <_ecc_projective_dbl_point+0x3c0>
          err = mp_montgomery_reduce(t2, modulus, mp);
 801b9d8:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b9dc:	6839      	ldr	r1, [r7, #0]
 801b9de:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b9e2:	f00b fcb5 	bl	8027350 <mp_montgomery_reduce>
 801b9e6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

      /* T1 = 2T2 */
      if (err == MP_OKAY)
 801b9ea:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9ee:	2b00      	cmp	r3, #0
 801b9f0:	d10a      	bne.n	801ba08 <_ecc_projective_dbl_point+0x3de>
          err = mp_addmod_ct(t2, t2, modulus, t1);
 801b9f2:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b9f6:	683a      	ldr	r2, [r7, #0]
 801b9f8:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b9fc:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ba00:	f00b f916 	bl	8026c30 <mp_addmod_ct>
 801ba04:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      /* T1 = T1 + T2 */
      if (err == MP_OKAY)
 801ba08:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba0c:	2b00      	cmp	r3, #0
 801ba0e:	d10a      	bne.n	801ba26 <_ecc_projective_dbl_point+0x3fc>
          err = mp_addmod_ct(t1, t2, modulus, t1);
 801ba10:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ba14:	683a      	ldr	r2, [r7, #0]
 801ba16:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801ba1a:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ba1e:	f00b f907 	bl	8026c30 <mp_addmod_ct>
 801ba22:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }

   /* Y = 2Y */
   if (err == MP_OKAY)
 801ba26:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba2a:	2b00      	cmp	r3, #0
 801ba2c:	d107      	bne.n	801ba3e <_ecc_projective_dbl_point+0x414>
       err = mp_addmod_ct(y, y, modulus, y);
 801ba2e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801ba30:	683a      	ldr	r2, [r7, #0]
 801ba32:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801ba34:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba36:	f00b f8fb 	bl	8026c30 <mp_addmod_ct>
 801ba3a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* Y = Y * Y */
   if (err == MP_OKAY)
 801ba3e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba42:	2b00      	cmp	r3, #0
 801ba44:	d105      	bne.n	801ba52 <_ecc_projective_dbl_point+0x428>
       err = mp_sqr(y, y);
 801ba46:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801ba48:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba4a:	f00b fcb1 	bl	80273b0 <mp_sqr>
 801ba4e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801ba52:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba56:	2b00      	cmp	r3, #0
 801ba58:	d107      	bne.n	801ba6a <_ecc_projective_dbl_point+0x440>
       err = mp_montgomery_reduce(y, modulus, mp);
 801ba5a:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801ba5e:	6839      	ldr	r1, [r7, #0]
 801ba60:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba62:	f00b fc75 	bl	8027350 <mp_montgomery_reduce>
 801ba66:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = Y * Y */
   if (err == MP_OKAY)
 801ba6a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba6e:	2b00      	cmp	r3, #0
 801ba70:	d106      	bne.n	801ba80 <_ecc_projective_dbl_point+0x456>
       err = mp_sqr(y, t2);
 801ba72:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801ba76:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba78:	f00b fc9a 	bl	80273b0 <mp_sqr>
 801ba7c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801ba80:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba84:	2b00      	cmp	r3, #0
 801ba86:	d108      	bne.n	801ba9a <_ecc_projective_dbl_point+0x470>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801ba88:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801ba8c:	6839      	ldr	r1, [r7, #0]
 801ba8e:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ba92:	f00b fc5d 	bl	8027350 <mp_montgomery_reduce>
 801ba96:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = T2/2 */
   if (err == MP_OKAY)
 801ba9a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba9e:	2b00      	cmp	r3, #0
 801baa0:	d108      	bne.n	801bab4 <_ecc_projective_dbl_point+0x48a>
       err = mp_div_2_mod_ct(t2, modulus, t2);
 801baa2:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801baa6:	6839      	ldr	r1, [r7, #0]
 801baa8:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801baac:	f00b fc8e 	bl	80273cc <mp_div_2_mod_ct>
 801bab0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y * X */
   if (err == MP_OKAY)
 801bab4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bab8:	2b00      	cmp	r3, #0
 801baba:	d106      	bne.n	801baca <_ecc_projective_dbl_point+0x4a0>
       err = mp_mul(y, x, y);
 801babc:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801babe:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801bac0:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bac2:	f00b f87e 	bl	8026bc2 <mp_mul>
 801bac6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801baca:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bace:	2b00      	cmp	r3, #0
 801bad0:	d107      	bne.n	801bae2 <_ecc_projective_dbl_point+0x4b8>
       err = mp_montgomery_reduce(y, modulus, mp);
 801bad2:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801bad6:	6839      	ldr	r1, [r7, #0]
 801bad8:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bada:	f00b fc39 	bl	8027350 <mp_montgomery_reduce>
 801bade:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = T1 * T1 */
   if (err == MP_OKAY)
 801bae2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bae6:	2b00      	cmp	r3, #0
 801bae8:	d106      	bne.n	801baf8 <_ecc_projective_dbl_point+0x4ce>
       err = mp_sqr(t1, x);
 801baea:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801baec:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801baf0:	f00b fc5e 	bl	80273b0 <mp_sqr>
 801baf4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801baf8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bafc:	2b00      	cmp	r3, #0
 801bafe:	d107      	bne.n	801bb10 <_ecc_projective_dbl_point+0x4e6>
       err = mp_montgomery_reduce(x, modulus, mp);
 801bb00:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801bb04:	6839      	ldr	r1, [r7, #0]
 801bb06:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801bb08:	f00b fc22 	bl	8027350 <mp_montgomery_reduce>
 801bb0c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = X - Y */
   if (err == MP_OKAY)
 801bb10:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bb14:	2b00      	cmp	r3, #0
 801bb16:	d107      	bne.n	801bb28 <_ecc_projective_dbl_point+0x4fe>
       err = mp_submod_ct(x, y, modulus, x);
 801bb18:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bb1a:	683a      	ldr	r2, [r7, #0]
 801bb1c:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801bb1e:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801bb20:	f00b f874 	bl	8026c0c <mp_submod_ct>
 801bb24:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* X = X - Y */
   if (err == MP_OKAY)
 801bb28:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bb2c:	2b00      	cmp	r3, #0
 801bb2e:	d107      	bne.n	801bb40 <_ecc_projective_dbl_point+0x516>
       err = mp_submod_ct(x, y, modulus, x);
 801bb30:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bb32:	683a      	ldr	r2, [r7, #0]
 801bb34:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801bb36:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801bb38:	f00b f868 	bl	8026c0c <mp_submod_ct>
 801bb3c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y - X */
   if (err == MP_OKAY)
 801bb40:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bb44:	2b00      	cmp	r3, #0
 801bb46:	d107      	bne.n	801bb58 <_ecc_projective_dbl_point+0x52e>
       err = mp_submod_ct(y, x, modulus, y);
 801bb48:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bb4a:	683a      	ldr	r2, [r7, #0]
 801bb4c:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801bb4e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bb50:	f00b f85c 	bl	8026c0c <mp_submod_ct>
 801bb54:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* Y = Y * T1 */
   if (err == MP_OKAY)
 801bb58:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bb5c:	2b00      	cmp	r3, #0
 801bb5e:	d107      	bne.n	801bb70 <_ecc_projective_dbl_point+0x546>
       err = mp_mul(y, t1, y);
 801bb60:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801bb62:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801bb66:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bb68:	f00b f82b 	bl	8026bc2 <mp_mul>
 801bb6c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801bb70:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bb74:	2b00      	cmp	r3, #0
 801bb76:	d107      	bne.n	801bb88 <_ecc_projective_dbl_point+0x55e>
       err = mp_montgomery_reduce(y, modulus, mp);
 801bb78:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801bb7c:	6839      	ldr	r1, [r7, #0]
 801bb7e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bb80:	f00b fbe6 	bl	8027350 <mp_montgomery_reduce>
 801bb84:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y - T2 */
   if (err == MP_OKAY)
 801bb88:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bb8c:	2b00      	cmp	r3, #0
 801bb8e:	d108      	bne.n	801bba2 <_ecc_projective_dbl_point+0x578>
       err = mp_submod_ct(y, t2, modulus, y);
 801bb90:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bb92:	683a      	ldr	r2, [r7, #0]
 801bb94:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801bb98:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bb9a:	f00b f837 	bl	8026c0c <mp_submod_ct>
 801bb9e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

#ifdef ALT_ECC_SIZE
   if (err == MP_OKAY)
 801bba2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bba6:	2b00      	cmp	r3, #0
 801bba8:	d107      	bne.n	801bbba <_ecc_projective_dbl_point+0x590>
       err = mp_copy(x, R->x);
 801bbaa:	68bb      	ldr	r3, [r7, #8]
 801bbac:	681b      	ldr	r3, [r3, #0]
 801bbae:	4619      	mov	r1, r3
 801bbb0:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801bbb2:	f00b f95e 	bl	8026e72 <mp_copy>
 801bbb6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801bbba:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bbbe:	2b00      	cmp	r3, #0
 801bbc0:	d107      	bne.n	801bbd2 <_ecc_projective_dbl_point+0x5a8>
       err = mp_copy(y, R->y);
 801bbc2:	68bb      	ldr	r3, [r7, #8]
 801bbc4:	685b      	ldr	r3, [r3, #4]
 801bbc6:	4619      	mov	r1, r3
 801bbc8:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bbca:	f00b f952 	bl	8026e72 <mp_copy>
 801bbce:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801bbd2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801bbd6:	2b00      	cmp	r3, #0
 801bbd8:	d107      	bne.n	801bbea <_ecc_projective_dbl_point+0x5c0>
       err = mp_copy(z, R->z);
 801bbda:	68bb      	ldr	r3, [r7, #8]
 801bbdc:	689b      	ldr	r3, [r3, #8]
 801bbde:	4619      	mov	r1, r3
 801bbe0:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801bbe2:	f00b f946 	bl	8026e72 <mp_copy>
 801bbe6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
#endif

   /* clean up */
   mp_clear(t1);
 801bbea:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801bbee:	f00a ff7e 	bl	8026aee <mp_clear>
   mp_clear(t2);
 801bbf2:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801bbf6:	f00a ff7a 	bl	8026aee <mp_clear>
   if (R->key == NULL)
#endif
#endif
   {
    #ifdef ALT_ECC_SIZE
       FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801bbfa:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801bbfc:	66bb      	str	r3, [r7, #104]	@ 0x68
 801bbfe:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bc00:	2b00      	cmp	r3, #0
 801bc02:	d002      	beq.n	801bc0a <_ecc_projective_dbl_point+0x5e0>
 801bc04:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 801bc06:	f003 f855 	bl	801ecb4 <wolfSSL_Free>
       FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801bc0a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801bc0c:	667b      	str	r3, [r7, #100]	@ 0x64
 801bc0e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bc10:	2b00      	cmp	r3, #0
 801bc12:	d002      	beq.n	801bc1a <_ecc_projective_dbl_point+0x5f0>
 801bc14:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801bc16:	f003 f84d 	bl	801ecb4 <wolfSSL_Free>
       FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801bc1a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801bc1e:	663b      	str	r3, [r7, #96]	@ 0x60
 801bc20:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bc22:	2b00      	cmp	r3, #0
 801bc24:	d002      	beq.n	801bc2c <_ecc_projective_dbl_point+0x602>
 801bc26:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 801bc28:	f003 f844 	bl	801ecb4 <wolfSSL_Free>
    #endif
       FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bc2c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801bc30:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801bc32:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801bc34:	2b00      	cmp	r3, #0
 801bc36:	d002      	beq.n	801bc3e <_ecc_projective_dbl_point+0x614>
 801bc38:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801bc3a:	f003 f83b 	bl	801ecb4 <wolfSSL_Free>
       FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bc3e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801bc42:	65bb      	str	r3, [r7, #88]	@ 0x58
 801bc44:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801bc46:	2b00      	cmp	r3, #0
 801bc48:	d002      	beq.n	801bc50 <_ecc_projective_dbl_point+0x626>
 801bc4a:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801bc4c:	f003 f832 	bl	801ecb4 <wolfSSL_Free>
    }

   return err;
 801bc50:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
        return sp_ecc_proj_dbl_point_521(P->x, P->y, P->z, R->x, R->y, R->z);
    }
#endif
    return ECC_BAD_ARG_E;
#endif
}
 801bc54:	4618      	mov	r0, r3
 801bc56:	3790      	adds	r7, #144	@ 0x90
 801bc58:	46bd      	mov	sp, r7
 801bc5a:	bd80      	pop	{r7, pc}

0801bc5c <ecc_map_ex>:
  mp       The "b" value from montgomery_setup()
  ct       Operation should be constant time.
  return   MP_OKAY on success
*/
int ecc_map_ex(ecc_point* P, mp_int* modulus, mp_digit mp, int ct)
{
 801bc5c:	b580      	push	{r7, lr}
 801bc5e:	b09e      	sub	sp, #120	@ 0x78
 801bc60:	af00      	add	r7, sp, #0
 801bc62:	60f8      	str	r0, [r7, #12]
 801bc64:	60b9      	str	r1, [r7, #8]
 801bc66:	607a      	str	r2, [r7, #4]
 801bc68:	603b      	str	r3, [r7, #0]
   int err = MP_OKAY;
 801bc6a:	2300      	movs	r3, #0
 801bc6c:	677b      	str	r3, [r7, #116]	@ 0x74
#if !defined(WOLFSSL_SP_MATH)
   DECL_MP_INT_SIZE_DYN(t1, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bc6e:	2300      	movs	r3, #0
 801bc70:	673b      	str	r3, [r7, #112]	@ 0x70
   DECL_MP_INT_SIZE_DYN(t2, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bc72:	2300      	movs	r3, #0
 801bc74:	66fb      	str	r3, [r7, #108]	@ 0x6c
#ifdef ALT_ECC_SIZE
   DECL_MP_INT_SIZE_DYN(rx, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bc76:	2300      	movs	r3, #0
 801bc78:	66bb      	str	r3, [r7, #104]	@ 0x68
   DECL_MP_INT_SIZE_DYN(ry, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bc7a:	2300      	movs	r3, #0
 801bc7c:	667b      	str	r3, [r7, #100]	@ 0x64
   DECL_MP_INT_SIZE_DYN(rz, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bc7e:	2300      	movs	r3, #0
 801bc80:	663b      	str	r3, [r7, #96]	@ 0x60
#endif
   mp_int *x, *y, *z;

   (void)ct;

   if (P == NULL || modulus == NULL)
 801bc82:	68fb      	ldr	r3, [r7, #12]
 801bc84:	2b00      	cmp	r3, #0
 801bc86:	d002      	beq.n	801bc8e <ecc_map_ex+0x32>
 801bc88:	68bb      	ldr	r3, [r7, #8]
 801bc8a:	2b00      	cmp	r3, #0
 801bc8c:	d102      	bne.n	801bc94 <ecc_map_ex+0x38>
       return ECC_BAD_ARG_E;
 801bc8e:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801bc92:	e1f7      	b.n	801c084 <ecc_map_ex+0x428>

   /* special case for point at infinity */
   if (mp_cmp_d(P->z, 0) == MP_EQ) {
 801bc94:	68fb      	ldr	r3, [r7, #12]
 801bc96:	689b      	ldr	r3, [r3, #8]
 801bc98:	2100      	movs	r1, #0
 801bc9a:	4618      	mov	r0, r3
 801bc9c:	f00b f83e 	bl	8026d1c <mp_cmp_d>
 801bca0:	4603      	mov	r3, r0
 801bca2:	2b00      	cmp	r3, #0
 801bca4:	d11c      	bne.n	801bce0 <ecc_map_ex+0x84>
       err = mp_set(P->x, 0);
 801bca6:	68fb      	ldr	r3, [r7, #12]
 801bca8:	681b      	ldr	r3, [r3, #0]
 801bcaa:	2100      	movs	r1, #0
 801bcac:	4618      	mov	r0, r3
 801bcae:	f00b fb9d 	bl	80273ec <mp_set>
 801bcb2:	6778      	str	r0, [r7, #116]	@ 0x74
       if (err == MP_OKAY)
 801bcb4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bcb6:	2b00      	cmp	r3, #0
 801bcb8:	d106      	bne.n	801bcc8 <ecc_map_ex+0x6c>
           err = mp_set(P->y, 0);
 801bcba:	68fb      	ldr	r3, [r7, #12]
 801bcbc:	685b      	ldr	r3, [r3, #4]
 801bcbe:	2100      	movs	r1, #0
 801bcc0:	4618      	mov	r0, r3
 801bcc2:	f00b fb93 	bl	80273ec <mp_set>
 801bcc6:	6778      	str	r0, [r7, #116]	@ 0x74
       if (err == MP_OKAY)
 801bcc8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bcca:	2b00      	cmp	r3, #0
 801bccc:	d106      	bne.n	801bcdc <ecc_map_ex+0x80>
           err = mp_set(P->z, 1);
 801bcce:	68fb      	ldr	r3, [r7, #12]
 801bcd0:	689b      	ldr	r3, [r3, #8]
 801bcd2:	2101      	movs	r1, #1
 801bcd4:	4618      	mov	r0, r3
 801bcd6:	f00b fb89 	bl	80273ec <mp_set>
 801bcda:	6778      	str	r0, [r7, #116]	@ 0x74
       return err;
 801bcdc:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bcde:	e1d1      	b.n	801c084 <ecc_map_ex+0x428>
   }
   else
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#endif
   {
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bce0:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bce4:	f002 ffca 	bl	801ec7c <wolfSSL_Malloc>
 801bce8:	6738      	str	r0, [r7, #112]	@ 0x70
 801bcea:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bcec:	2b00      	cmp	r3, #0
 801bcee:	d005      	beq.n	801bcfc <ecc_map_ex+0xa0>
 801bcf0:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bcf4:	2100      	movs	r1, #0
 801bcf6:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bcf8:	f00c ff94 	bl	8028c24 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bcfc:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bd00:	f002 ffbc 	bl	801ec7c <wolfSSL_Malloc>
 801bd04:	66f8      	str	r0, [r7, #108]	@ 0x6c
 801bd06:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bd08:	2b00      	cmp	r3, #0
 801bd0a:	d005      	beq.n	801bd18 <ecc_map_ex+0xbc>
 801bd0c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bd10:	2100      	movs	r1, #0
 801bd12:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801bd14:	f00c ff86 	bl	8028c24 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (t1 == NULL || t2 == NULL) {
 801bd18:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bd1a:	2b00      	cmp	r3, #0
 801bd1c:	d002      	beq.n	801bd24 <ecc_map_ex+0xc8>
 801bd1e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bd20:	2b00      	cmp	r3, #0
 801bd22:	d112      	bne.n	801bd4a <ecc_map_ex+0xee>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bd24:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bd26:	617b      	str	r3, [r7, #20]
 801bd28:	697b      	ldr	r3, [r7, #20]
 801bd2a:	2b00      	cmp	r3, #0
 801bd2c:	d002      	beq.n	801bd34 <ecc_map_ex+0xd8>
 801bd2e:	6978      	ldr	r0, [r7, #20]
 801bd30:	f002 ffc0 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bd34:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bd36:	613b      	str	r3, [r7, #16]
 801bd38:	693b      	ldr	r3, [r7, #16]
 801bd3a:	2b00      	cmp	r3, #0
 801bd3c:	d002      	beq.n	801bd44 <ecc_map_ex+0xe8>
 801bd3e:	6938      	ldr	r0, [r7, #16]
 801bd40:	f002 ffb8 	bl	801ecb4 <wolfSSL_Free>
         return MEMORY_E;
 801bd44:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801bd48:	e19c      	b.n	801c084 <ecc_map_ex+0x428>
      }
   #endif
   #ifdef ALT_ECC_SIZE
      NEW_MP_INT_SIZE(rx, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bd4a:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bd4e:	f002 ff95 	bl	801ec7c <wolfSSL_Malloc>
 801bd52:	66b8      	str	r0, [r7, #104]	@ 0x68
 801bd54:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bd56:	2b00      	cmp	r3, #0
 801bd58:	d005      	beq.n	801bd66 <ecc_map_ex+0x10a>
 801bd5a:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bd5e:	2100      	movs	r1, #0
 801bd60:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 801bd62:	f00c ff5f 	bl	8028c24 <memset>
      NEW_MP_INT_SIZE(ry, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bd66:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bd6a:	f002 ff87 	bl	801ec7c <wolfSSL_Malloc>
 801bd6e:	6678      	str	r0, [r7, #100]	@ 0x64
 801bd70:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bd72:	2b00      	cmp	r3, #0
 801bd74:	d005      	beq.n	801bd82 <ecc_map_ex+0x126>
 801bd76:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bd7a:	2100      	movs	r1, #0
 801bd7c:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801bd7e:	f00c ff51 	bl	8028c24 <memset>
      NEW_MP_INT_SIZE(rz, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bd82:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bd86:	f002 ff79 	bl	801ec7c <wolfSSL_Malloc>
 801bd8a:	6638      	str	r0, [r7, #96]	@ 0x60
 801bd8c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bd8e:	2b00      	cmp	r3, #0
 801bd90:	d005      	beq.n	801bd9e <ecc_map_ex+0x142>
 801bd92:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bd96:	2100      	movs	r1, #0
 801bd98:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 801bd9a:	f00c ff43 	bl	8028c24 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (rx == NULL || ry == NULL || rz == NULL) {
 801bd9e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bda0:	2b00      	cmp	r3, #0
 801bda2:	d005      	beq.n	801bdb0 <ecc_map_ex+0x154>
 801bda4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bda6:	2b00      	cmp	r3, #0
 801bda8:	d002      	beq.n	801bdb0 <ecc_map_ex+0x154>
 801bdaa:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bdac:	2b00      	cmp	r3, #0
 801bdae:	d12a      	bne.n	801be06 <ecc_map_ex+0x1aa>
          FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801bdb0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bdb2:	62bb      	str	r3, [r7, #40]	@ 0x28
 801bdb4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801bdb6:	2b00      	cmp	r3, #0
 801bdb8:	d002      	beq.n	801bdc0 <ecc_map_ex+0x164>
 801bdba:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bdbc:	f002 ff7a 	bl	801ecb4 <wolfSSL_Free>
          FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801bdc0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bdc2:	627b      	str	r3, [r7, #36]	@ 0x24
 801bdc4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801bdc6:	2b00      	cmp	r3, #0
 801bdc8:	d002      	beq.n	801bdd0 <ecc_map_ex+0x174>
 801bdca:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801bdcc:	f002 ff72 	bl	801ecb4 <wolfSSL_Free>
          FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801bdd0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bdd2:	623b      	str	r3, [r7, #32]
 801bdd4:	6a3b      	ldr	r3, [r7, #32]
 801bdd6:	2b00      	cmp	r3, #0
 801bdd8:	d002      	beq.n	801bde0 <ecc_map_ex+0x184>
 801bdda:	6a38      	ldr	r0, [r7, #32]
 801bddc:	f002 ff6a 	bl	801ecb4 <wolfSSL_Free>
          FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bde0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bde2:	61fb      	str	r3, [r7, #28]
 801bde4:	69fb      	ldr	r3, [r7, #28]
 801bde6:	2b00      	cmp	r3, #0
 801bde8:	d002      	beq.n	801bdf0 <ecc_map_ex+0x194>
 801bdea:	69f8      	ldr	r0, [r7, #28]
 801bdec:	f002 ff62 	bl	801ecb4 <wolfSSL_Free>
          FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bdf0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bdf2:	61bb      	str	r3, [r7, #24]
 801bdf4:	69bb      	ldr	r3, [r7, #24]
 801bdf6:	2b00      	cmp	r3, #0
 801bdf8:	d002      	beq.n	801be00 <ecc_map_ex+0x1a4>
 801bdfa:	69b8      	ldr	r0, [r7, #24]
 801bdfc:	f002 ff5a 	bl	801ecb4 <wolfSSL_Free>
          return MEMORY_E;
 801be00:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801be04:	e13e      	b.n	801c084 <ecc_map_ex+0x428>
      }
   #endif
   #endif
   }

   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
 801be06:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801be08:	f00a fde7 	bl	80269da <mp_init>
 801be0c:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY) {
 801be0e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be10:	2b00      	cmp	r3, #0
 801be12:	d103      	bne.n	801be1c <ecc_map_ex+0x1c0>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
 801be14:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801be16:	f00a fde0 	bl	80269da <mp_init>
 801be1a:	6778      	str	r0, [r7, #116]	@ 0x74
   }
   if (err != MP_OKAY) {
 801be1c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be1e:	2b00      	cmp	r3, #0
 801be20:	d02a      	beq.n	801be78 <ecc_map_ex+0x21c>
      if (P->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801be22:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801be24:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801be26:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801be28:	2b00      	cmp	r3, #0
 801be2a:	d002      	beq.n	801be32 <ecc_map_ex+0x1d6>
 801be2c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801be2e:	f002 ff41 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801be32:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801be34:	63bb      	str	r3, [r7, #56]	@ 0x38
 801be36:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801be38:	2b00      	cmp	r3, #0
 801be3a:	d002      	beq.n	801be42 <ecc_map_ex+0x1e6>
 801be3c:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801be3e:	f002 ff39 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801be42:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801be44:	637b      	str	r3, [r7, #52]	@ 0x34
 801be46:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801be48:	2b00      	cmp	r3, #0
 801be4a:	d002      	beq.n	801be52 <ecc_map_ex+0x1f6>
 801be4c:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801be4e:	f002 ff31 	bl	801ecb4 <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801be52:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801be54:	633b      	str	r3, [r7, #48]	@ 0x30
 801be56:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801be58:	2b00      	cmp	r3, #0
 801be5a:	d002      	beq.n	801be62 <ecc_map_ex+0x206>
 801be5c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801be5e:	f002 ff29 	bl	801ecb4 <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801be62:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801be64:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801be66:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801be68:	2b00      	cmp	r3, #0
 801be6a:	d002      	beq.n	801be72 <ecc_map_ex+0x216>
 801be6c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801be6e:	f002 ff21 	bl	801ecb4 <wolfSSL_Free>
      }
      return MEMORY_E;
 801be72:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801be76:	e105      	b.n	801c084 <ecc_map_ex+0x428>
   }

#ifdef ALT_ECC_SIZE
   /* Use local stack variable */
   x = rx;
 801be78:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801be7a:	65fb      	str	r3, [r7, #92]	@ 0x5c
   y = ry;
 801be7c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801be7e:	65bb      	str	r3, [r7, #88]	@ 0x58
   z = rz;
 801be80:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801be82:	657b      	str	r3, [r7, #84]	@ 0x54

   err = INIT_MP_INT_SIZE(x, mp_bitsused(modulus));
 801be84:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801be86:	f00a fda8 	bl	80269da <mp_init>
 801be8a:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY) {
 801be8c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be8e:	2b00      	cmp	r3, #0
 801be90:	d103      	bne.n	801be9a <ecc_map_ex+0x23e>
      err = INIT_MP_INT_SIZE(y, mp_bitsused(modulus));
 801be92:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801be94:	f00a fda1 	bl	80269da <mp_init>
 801be98:	6778      	str	r0, [r7, #116]	@ 0x74
   }
   if (err == MP_OKAY) {
 801be9a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be9c:	2b00      	cmp	r3, #0
 801be9e:	d103      	bne.n	801bea8 <ecc_map_ex+0x24c>
      err = INIT_MP_INT_SIZE(z, mp_bitsused(modulus));
 801bea0:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bea2:	f00a fd9a 	bl	80269da <mp_init>
 801bea6:	6778      	str	r0, [r7, #116]	@ 0x74
   }
   if (err != MP_OKAY) {
 801bea8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801beaa:	2b00      	cmp	r3, #0
 801beac:	f040 80b6 	bne.w	801c01c <ecc_map_ex+0x3c0>
      goto done;
   }

   if (err == MP_OKAY)
 801beb0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801beb2:	2b00      	cmp	r3, #0
 801beb4:	d106      	bne.n	801bec4 <ecc_map_ex+0x268>
      err = mp_copy(P->x, x);
 801beb6:	68fb      	ldr	r3, [r7, #12]
 801beb8:	681b      	ldr	r3, [r3, #0]
 801beba:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801bebc:	4618      	mov	r0, r3
 801bebe:	f00a ffd8 	bl	8026e72 <mp_copy>
 801bec2:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bec4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bec6:	2b00      	cmp	r3, #0
 801bec8:	d106      	bne.n	801bed8 <ecc_map_ex+0x27c>
      err = mp_copy(P->y, y);
 801beca:	68fb      	ldr	r3, [r7, #12]
 801becc:	685b      	ldr	r3, [r3, #4]
 801bece:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801bed0:	4618      	mov	r0, r3
 801bed2:	f00a ffce 	bl	8026e72 <mp_copy>
 801bed6:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bed8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801beda:	2b00      	cmp	r3, #0
 801bedc:	d106      	bne.n	801beec <ecc_map_ex+0x290>
      err = mp_copy(P->z, z);
 801bede:	68fb      	ldr	r3, [r7, #12]
 801bee0:	689b      	ldr	r3, [r3, #8]
 801bee2:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 801bee4:	4618      	mov	r0, r3
 801bee6:	f00a ffc4 	bl	8026e72 <mp_copy>
 801beea:	6778      	str	r0, [r7, #116]	@ 0x74

   if (err != MP_OKAY) {
 801beec:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801beee:	2b00      	cmp	r3, #0
 801bef0:	f040 8096 	bne.w	801c020 <ecc_map_ex+0x3c4>
   y = P->y;
   z = P->z;
#endif

   /* get 1/z */
   if (err == MP_OKAY) {
 801bef4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bef6:	2b00      	cmp	r3, #0
 801bef8:	d122      	bne.n	801bf40 <ecc_map_ex+0x2e4>
#if defined(ECC_TIMING_RESISTANT) && (defined(USE_FAST_MATH) || \
                       defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_SP_MATH_ALL))
       if (ct) {
 801befa:	683b      	ldr	r3, [r7, #0]
 801befc:	2b00      	cmp	r3, #0
 801befe:	d010      	beq.n	801bf22 <ecc_map_ex+0x2c6>
           err = mp_invmod_mont_ct(z, modulus, t1, mp);
 801bf00:	687b      	ldr	r3, [r7, #4]
 801bf02:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801bf04:	68b9      	ldr	r1, [r7, #8]
 801bf06:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bf08:	f00a fec4 	bl	8026c94 <mp_invmod_mont_ct>
 801bf0c:	6778      	str	r0, [r7, #116]	@ 0x74
           if (err == MP_OKAY)
 801bf0e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bf10:	2b00      	cmp	r3, #0
 801bf12:	d115      	bne.n	801bf40 <ecc_map_ex+0x2e4>
               err = mp_montgomery_reduce(t1, modulus, mp);
 801bf14:	687a      	ldr	r2, [r7, #4]
 801bf16:	68b9      	ldr	r1, [r7, #8]
 801bf18:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bf1a:	f00b fa19 	bl	8027350 <mp_montgomery_reduce>
 801bf1e:	6778      	str	r0, [r7, #116]	@ 0x74
 801bf20:	e00e      	b.n	801bf40 <ecc_map_ex+0x2e4>
       }
       else
#endif
       {
           /* first map z back to normal */
           err = mp_montgomery_reduce(z, modulus, mp);
 801bf22:	687a      	ldr	r2, [r7, #4]
 801bf24:	68b9      	ldr	r1, [r7, #8]
 801bf26:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bf28:	f00b fa12 	bl	8027350 <mp_montgomery_reduce>
 801bf2c:	6778      	str	r0, [r7, #116]	@ 0x74
           if (err == MP_OKAY)
 801bf2e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bf30:	2b00      	cmp	r3, #0
 801bf32:	d105      	bne.n	801bf40 <ecc_map_ex+0x2e4>
               err = mp_invmod(z, modulus, t1);
 801bf34:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801bf36:	68b9      	ldr	r1, [r7, #8]
 801bf38:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bf3a:	f00a fe9b 	bl	8026c74 <mp_invmod>
 801bf3e:	6778      	str	r0, [r7, #116]	@ 0x74
       }
   }

   /* get 1/z^2 and 1/z^3 */
   if (err == MP_OKAY)
 801bf40:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bf42:	2b00      	cmp	r3, #0
 801bf44:	d104      	bne.n	801bf50 <ecc_map_ex+0x2f4>
       err = mp_sqr(t1, t2);
 801bf46:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801bf48:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bf4a:	f00b fa31 	bl	80273b0 <mp_sqr>
 801bf4e:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bf50:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bf52:	2b00      	cmp	r3, #0
 801bf54:	d105      	bne.n	801bf62 <ecc_map_ex+0x306>
       err = mp_mod(t2, modulus, t2);
 801bf56:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801bf58:	68b9      	ldr	r1, [r7, #8]
 801bf5a:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801bf5c:	f00a fe7a 	bl	8026c54 <mp_mod>
 801bf60:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bf62:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bf64:	2b00      	cmp	r3, #0
 801bf66:	d105      	bne.n	801bf74 <ecc_map_ex+0x318>
       err = mp_mul(t1, t2, t1);
 801bf68:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801bf6a:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801bf6c:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bf6e:	f00a fe28 	bl	8026bc2 <mp_mul>
 801bf72:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bf74:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bf76:	2b00      	cmp	r3, #0
 801bf78:	d105      	bne.n	801bf86 <ecc_map_ex+0x32a>
       err = mp_mod(t1, modulus, t1);
 801bf7a:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801bf7c:	68b9      	ldr	r1, [r7, #8]
 801bf7e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bf80:	f00a fe68 	bl	8026c54 <mp_mod>
 801bf84:	6778      	str	r0, [r7, #116]	@ 0x74

   /* multiply against x/y */
   if (err == MP_OKAY)
 801bf86:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bf88:	2b00      	cmp	r3, #0
 801bf8a:	d105      	bne.n	801bf98 <ecc_map_ex+0x33c>
       err = mp_mul(x, t2, x);
 801bf8c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801bf8e:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801bf90:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801bf92:	f00a fe16 	bl	8026bc2 <mp_mul>
 801bf96:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bf98:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bf9a:	2b00      	cmp	r3, #0
 801bf9c:	d105      	bne.n	801bfaa <ecc_map_ex+0x34e>
       err = mp_montgomery_reduce(x, modulus, mp);
 801bf9e:	687a      	ldr	r2, [r7, #4]
 801bfa0:	68b9      	ldr	r1, [r7, #8]
 801bfa2:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801bfa4:	f00b f9d4 	bl	8027350 <mp_montgomery_reduce>
 801bfa8:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bfaa:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bfac:	2b00      	cmp	r3, #0
 801bfae:	d105      	bne.n	801bfbc <ecc_map_ex+0x360>
       err = mp_mul(y, t1, y);
 801bfb0:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801bfb2:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801bfb4:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801bfb6:	f00a fe04 	bl	8026bc2 <mp_mul>
 801bfba:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bfbc:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bfbe:	2b00      	cmp	r3, #0
 801bfc0:	d105      	bne.n	801bfce <ecc_map_ex+0x372>
       err = mp_montgomery_reduce(y, modulus, mp);
 801bfc2:	687a      	ldr	r2, [r7, #4]
 801bfc4:	68b9      	ldr	r1, [r7, #8]
 801bfc6:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801bfc8:	f00b f9c2 	bl	8027350 <mp_montgomery_reduce>
 801bfcc:	6778      	str	r0, [r7, #116]	@ 0x74

   if (err == MP_OKAY)
 801bfce:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bfd0:	2b00      	cmp	r3, #0
 801bfd2:	d104      	bne.n	801bfde <ecc_map_ex+0x382>
       err = mp_set(z, 1);
 801bfd4:	2101      	movs	r1, #1
 801bfd6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bfd8:	f00b fa08 	bl	80273ec <mp_set>
 801bfdc:	6778      	str	r0, [r7, #116]	@ 0x74

#ifdef ALT_ECC_SIZE
   /* return result */
   if (err == MP_OKAY)
 801bfde:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bfe0:	2b00      	cmp	r3, #0
 801bfe2:	d106      	bne.n	801bff2 <ecc_map_ex+0x396>
      err = mp_copy(x, P->x);
 801bfe4:	68fb      	ldr	r3, [r7, #12]
 801bfe6:	681b      	ldr	r3, [r3, #0]
 801bfe8:	4619      	mov	r1, r3
 801bfea:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801bfec:	f00a ff41 	bl	8026e72 <mp_copy>
 801bff0:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bff2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bff4:	2b00      	cmp	r3, #0
 801bff6:	d106      	bne.n	801c006 <ecc_map_ex+0x3aa>
      err = mp_copy(y, P->y);
 801bff8:	68fb      	ldr	r3, [r7, #12]
 801bffa:	685b      	ldr	r3, [r3, #4]
 801bffc:	4619      	mov	r1, r3
 801bffe:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801c000:	f00a ff37 	bl	8026e72 <mp_copy>
 801c004:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801c006:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801c008:	2b00      	cmp	r3, #0
 801c00a:	d10b      	bne.n	801c024 <ecc_map_ex+0x3c8>
      err = mp_copy(z, P->z);
 801c00c:	68fb      	ldr	r3, [r7, #12]
 801c00e:	689b      	ldr	r3, [r3, #8]
 801c010:	4619      	mov	r1, r3
 801c012:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801c014:	f00a ff2d 	bl	8026e72 <mp_copy>
 801c018:	6778      	str	r0, [r7, #116]	@ 0x74
 801c01a:	e004      	b.n	801c026 <ecc_map_ex+0x3ca>
      goto done;
 801c01c:	bf00      	nop
 801c01e:	e002      	b.n	801c026 <ecc_map_ex+0x3ca>
      goto done;
 801c020:	bf00      	nop
 801c022:	e000      	b.n	801c026 <ecc_map_ex+0x3ca>

done:
 801c024:	bf00      	nop
#endif

   /* clean up */
   mp_clear(t1);
 801c026:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801c028:	f00a fd61 	bl	8026aee <mp_clear>
   mp_clear(t2);
 801c02c:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801c02e:	f00a fd5e 	bl	8026aee <mp_clear>
   if (P->key == NULL)
#endif
#endif
   {
   #ifdef ALT_ECC_SIZE
      FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801c032:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c034:	653b      	str	r3, [r7, #80]	@ 0x50
 801c036:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801c038:	2b00      	cmp	r3, #0
 801c03a:	d002      	beq.n	801c042 <ecc_map_ex+0x3e6>
 801c03c:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801c03e:	f002 fe39 	bl	801ecb4 <wolfSSL_Free>
      FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801c042:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801c044:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801c046:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801c048:	2b00      	cmp	r3, #0
 801c04a:	d002      	beq.n	801c052 <ecc_map_ex+0x3f6>
 801c04c:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801c04e:	f002 fe31 	bl	801ecb4 <wolfSSL_Free>
      FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801c052:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801c054:	64bb      	str	r3, [r7, #72]	@ 0x48
 801c056:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801c058:	2b00      	cmp	r3, #0
 801c05a:	d002      	beq.n	801c062 <ecc_map_ex+0x406>
 801c05c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801c05e:	f002 fe29 	bl	801ecb4 <wolfSSL_Free>
   #endif
      FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801c062:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801c064:	647b      	str	r3, [r7, #68]	@ 0x44
 801c066:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c068:	2b00      	cmp	r3, #0
 801c06a:	d002      	beq.n	801c072 <ecc_map_ex+0x416>
 801c06c:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c06e:	f002 fe21 	bl	801ecb4 <wolfSSL_Free>
      FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801c072:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801c074:	643b      	str	r3, [r7, #64]	@ 0x40
 801c076:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c078:	2b00      	cmp	r3, #0
 801c07a:	d002      	beq.n	801c082 <ecc_map_ex+0x426>
 801c07c:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801c07e:	f002 fe19 	bl	801ecb4 <wolfSSL_Free>
   }

   return err;
 801c082:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
#endif

   WOLFSSL_LEAVE("ecc_map_ex (SP Math)", err);
   return err;
#endif /* WOLFSSL_SP_MATH */
}
 801c084:	4618      	mov	r0, r3
 801c086:	3778      	adds	r7, #120	@ 0x78
 801c088:	46bd      	mov	sp, r7
 801c08a:	bd80      	pop	{r7, pc}

0801c08c <ecc_map>:
#endif /* !FREESCALE_LTC_ECC && !WOLFSSL_STM32_PKA */

int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)
{
 801c08c:	b580      	push	{r7, lr}
 801c08e:	b084      	sub	sp, #16
 801c090:	af00      	add	r7, sp, #0
 801c092:	60f8      	str	r0, [r7, #12]
 801c094:	60b9      	str	r1, [r7, #8]
 801c096:	607a      	str	r2, [r7, #4]
    return ecc_map_ex(P, modulus, mp, 0);
 801c098:	2300      	movs	r3, #0
 801c09a:	687a      	ldr	r2, [r7, #4]
 801c09c:	68b9      	ldr	r1, [r7, #8]
 801c09e:	68f8      	ldr	r0, [r7, #12]
 801c0a0:	f7ff fddc 	bl	801bc5c <ecc_map_ex>
 801c0a4:	4603      	mov	r3, r0
}
 801c0a6:	4618      	mov	r0, r3
 801c0a8:	3710      	adds	r7, #16
 801c0aa:	46bd      	mov	sp, r7
 801c0ac:	bd80      	pop	{r7, pc}

0801c0ae <wc_ecc_gen_z>:

#else

static int wc_ecc_gen_z(WC_RNG* rng, int size, ecc_point* p, mp_int* modulus,
    mp_digit mp, mp_int* tx, mp_int* ty, mp_int* mu)
{
 801c0ae:	b580      	push	{r7, lr}
 801c0b0:	b086      	sub	sp, #24
 801c0b2:	af00      	add	r7, sp, #0
 801c0b4:	60f8      	str	r0, [r7, #12]
 801c0b6:	60b9      	str	r1, [r7, #8]
 801c0b8:	607a      	str	r2, [r7, #4]
 801c0ba:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801c0bc:	2300      	movs	r3, #0
 801c0be:	617b      	str	r3, [r7, #20]

    err = mp_montgomery_calc_normalization(mu, modulus);
 801c0c0:	6839      	ldr	r1, [r7, #0]
 801c0c2:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801c0c4:	f00a ff19 	bl	8026efa <mp_montgomery_calc_normalization>
 801c0c8:	6178      	str	r0, [r7, #20]
    /* Generate random value to multiply into p->z. */
    if (err == MP_OKAY)
 801c0ca:	697b      	ldr	r3, [r7, #20]
 801c0cc:	2b00      	cmp	r3, #0
 801c0ce:	d106      	bne.n	801c0de <wc_ecc_gen_z+0x30>
        err = wc_ecc_gen_k(rng, size, ty, modulus);
 801c0d0:	683b      	ldr	r3, [r7, #0]
 801c0d2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801c0d4:	68b9      	ldr	r1, [r7, #8]
 801c0d6:	68f8      	ldr	r0, [r7, #12]
 801c0d8:	f000 fdf8 	bl	801cccc <wc_ecc_gen_k>
 801c0dc:	6178      	str	r0, [r7, #20]
    /* Convert to montogmery form. */
    if (err == MP_OKAY)
 801c0de:	697b      	ldr	r3, [r7, #20]
 801c0e0:	2b00      	cmp	r3, #0
 801c0e2:	d106      	bne.n	801c0f2 <wc_ecc_gen_z+0x44>
        err = mp_mulmod(ty, mu, modulus, ty);
 801c0e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c0e6:	683a      	ldr	r2, [r7, #0]
 801c0e8:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801c0ea:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801c0ec:	f00a fd79 	bl	8026be2 <mp_mulmod>
 801c0f0:	6178      	str	r0, [r7, #20]
    /* Multiply random value into p->z. */
    if (err == MP_OKAY)
 801c0f2:	697b      	ldr	r3, [r7, #20]
 801c0f4:	2b00      	cmp	r3, #0
 801c0f6:	d108      	bne.n	801c10a <wc_ecc_gen_z+0x5c>
        err = mp_mul(p->z, ty, p->z);
 801c0f8:	687b      	ldr	r3, [r7, #4]
 801c0fa:	6898      	ldr	r0, [r3, #8]
 801c0fc:	687b      	ldr	r3, [r7, #4]
 801c0fe:	689b      	ldr	r3, [r3, #8]
 801c100:	461a      	mov	r2, r3
 801c102:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801c104:	f00a fd5d 	bl	8026bc2 <mp_mul>
 801c108:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801c10a:	697b      	ldr	r3, [r7, #20]
 801c10c:	2b00      	cmp	r3, #0
 801c10e:	d107      	bne.n	801c120 <wc_ecc_gen_z+0x72>
        err = mp_montgomery_reduce(p->z, modulus, mp);
 801c110:	687b      	ldr	r3, [r7, #4]
 801c112:	689b      	ldr	r3, [r3, #8]
 801c114:	6a3a      	ldr	r2, [r7, #32]
 801c116:	6839      	ldr	r1, [r7, #0]
 801c118:	4618      	mov	r0, r3
 801c11a:	f00b f919 	bl	8027350 <mp_montgomery_reduce>
 801c11e:	6178      	str	r0, [r7, #20]
    /* Square random value for X (X' = X / Z^2). */
    if (err == MP_OKAY)
 801c120:	697b      	ldr	r3, [r7, #20]
 801c122:	2b00      	cmp	r3, #0
 801c124:	d104      	bne.n	801c130 <wc_ecc_gen_z+0x82>
        err = mp_sqr(ty, tx);
 801c126:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c128:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801c12a:	f00b f941 	bl	80273b0 <mp_sqr>
 801c12e:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801c130:	697b      	ldr	r3, [r7, #20]
 801c132:	2b00      	cmp	r3, #0
 801c134:	d105      	bne.n	801c142 <wc_ecc_gen_z+0x94>
        err = mp_montgomery_reduce(tx, modulus, mp);
 801c136:	6a3a      	ldr	r2, [r7, #32]
 801c138:	6839      	ldr	r1, [r7, #0]
 801c13a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801c13c:	f00b f908 	bl	8027350 <mp_montgomery_reduce>
 801c140:	6178      	str	r0, [r7, #20]
    /* Multiply square of random by random value for Y. */
    if (err == MP_OKAY)
 801c142:	697b      	ldr	r3, [r7, #20]
 801c144:	2b00      	cmp	r3, #0
 801c146:	d105      	bne.n	801c154 <wc_ecc_gen_z+0xa6>
        err = mp_mul(ty, tx, ty);
 801c148:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801c14a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c14c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801c14e:	f00a fd38 	bl	8026bc2 <mp_mul>
 801c152:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801c154:	697b      	ldr	r3, [r7, #20]
 801c156:	2b00      	cmp	r3, #0
 801c158:	d105      	bne.n	801c166 <wc_ecc_gen_z+0xb8>
        err = mp_montgomery_reduce(ty, modulus, mp);
 801c15a:	6a3a      	ldr	r2, [r7, #32]
 801c15c:	6839      	ldr	r1, [r7, #0]
 801c15e:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801c160:	f00b f8f6 	bl	8027350 <mp_montgomery_reduce>
 801c164:	6178      	str	r0, [r7, #20]
    /* Multiply square into X. */
    if (err == MP_OKAY)
 801c166:	697b      	ldr	r3, [r7, #20]
 801c168:	2b00      	cmp	r3, #0
 801c16a:	d108      	bne.n	801c17e <wc_ecc_gen_z+0xd0>
        err = mp_mul(p->x, tx, p->x);
 801c16c:	687b      	ldr	r3, [r7, #4]
 801c16e:	6818      	ldr	r0, [r3, #0]
 801c170:	687b      	ldr	r3, [r7, #4]
 801c172:	681b      	ldr	r3, [r3, #0]
 801c174:	461a      	mov	r2, r3
 801c176:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c178:	f00a fd23 	bl	8026bc2 <mp_mul>
 801c17c:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801c17e:	697b      	ldr	r3, [r7, #20]
 801c180:	2b00      	cmp	r3, #0
 801c182:	d107      	bne.n	801c194 <wc_ecc_gen_z+0xe6>
        err = mp_montgomery_reduce(p->x, modulus, mp);
 801c184:	687b      	ldr	r3, [r7, #4]
 801c186:	681b      	ldr	r3, [r3, #0]
 801c188:	6a3a      	ldr	r2, [r7, #32]
 801c18a:	6839      	ldr	r1, [r7, #0]
 801c18c:	4618      	mov	r0, r3
 801c18e:	f00b f8df 	bl	8027350 <mp_montgomery_reduce>
 801c192:	6178      	str	r0, [r7, #20]
    /* Multiply cube into Y (Y' = Y / Z^3). */
    if (err == MP_OKAY)
 801c194:	697b      	ldr	r3, [r7, #20]
 801c196:	2b00      	cmp	r3, #0
 801c198:	d108      	bne.n	801c1ac <wc_ecc_gen_z+0xfe>
        err = mp_mul(p->y, ty, p->y);
 801c19a:	687b      	ldr	r3, [r7, #4]
 801c19c:	6858      	ldr	r0, [r3, #4]
 801c19e:	687b      	ldr	r3, [r7, #4]
 801c1a0:	685b      	ldr	r3, [r3, #4]
 801c1a2:	461a      	mov	r2, r3
 801c1a4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801c1a6:	f00a fd0c 	bl	8026bc2 <mp_mul>
 801c1aa:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801c1ac:	697b      	ldr	r3, [r7, #20]
 801c1ae:	2b00      	cmp	r3, #0
 801c1b0:	d107      	bne.n	801c1c2 <wc_ecc_gen_z+0x114>
        err = mp_montgomery_reduce(p->y, modulus, mp);
 801c1b2:	687b      	ldr	r3, [r7, #4]
 801c1b4:	685b      	ldr	r3, [r3, #4]
 801c1b6:	6a3a      	ldr	r2, [r7, #32]
 801c1b8:	6839      	ldr	r1, [r7, #0]
 801c1ba:	4618      	mov	r0, r3
 801c1bc:	f00b f8c8 	bl	8027350 <mp_montgomery_reduce>
 801c1c0:	6178      	str	r0, [r7, #20]

    return err;
 801c1c2:	697b      	ldr	r3, [r7, #20]
}
 801c1c4:	4618      	mov	r0, r3
 801c1c6:	3718      	adds	r7, #24
 801c1c8:	46bd      	mov	sp, r7
 801c1ca:	bd80      	pop	{r7, pc}

0801c1cc <ecc_mulmod>:
 *
 * Assumes: k < order.
 */
static int ecc_mulmod(const mp_int* k, ecc_point* P, ecc_point* Q,
    ecc_point** R, mp_int* a, mp_int* modulus, mp_digit mp, WC_RNG* rng)
{
 801c1cc:	b590      	push	{r4, r7, lr}
 801c1ce:	b097      	sub	sp, #92	@ 0x5c
 801c1d0:	af04      	add	r7, sp, #16
 801c1d2:	60f8      	str	r0, [r7, #12]
 801c1d4:	60b9      	str	r1, [r7, #8]
 801c1d6:	607a      	str	r2, [r7, #4]
 801c1d8:	603b      	str	r3, [r7, #0]
    int      err = MP_OKAY;
 801c1da:	2300      	movs	r3, #0
 801c1dc:	647b      	str	r3, [r7, #68]	@ 0x44
    int      bytes = (mp_count_bits(modulus) + 7) / 8;
 801c1de:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801c1e0:	f00a fe66 	bl	8026eb0 <mp_count_bits>
 801c1e4:	4603      	mov	r3, r0
 801c1e6:	3307      	adds	r3, #7
 801c1e8:	2b00      	cmp	r3, #0
 801c1ea:	da00      	bge.n	801c1ee <ecc_mulmod+0x22>
 801c1ec:	3307      	adds	r3, #7
 801c1ee:	10db      	asrs	r3, r3, #3
 801c1f0:	62bb      	str	r3, [r7, #40]	@ 0x28
    int      i;
    int      j = 1;
 801c1f2:	2301      	movs	r3, #1
 801c1f4:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int      cnt = DIGIT_BIT;
 801c1f6:	2320      	movs	r3, #32
 801c1f8:	63bb      	str	r3, [r7, #56]	@ 0x38
    int      t = 0;
 801c1fa:	2300      	movs	r3, #0
 801c1fc:	637b      	str	r3, [r7, #52]	@ 0x34
    mp_digit b;
    mp_digit v = 0;
 801c1fe:	2300      	movs	r3, #0
 801c200:	633b      	str	r3, [r7, #48]	@ 0x30
    mp_int*  kt = R[2]->x;
 801c202:	683b      	ldr	r3, [r7, #0]
 801c204:	3308      	adds	r3, #8
 801c206:	681b      	ldr	r3, [r3, #0]
 801c208:	681b      	ldr	r3, [r3, #0]
 801c20a:	627b      	str	r3, [r7, #36]	@ 0x24
#ifndef WC_NO_CACHE_RESISTANT
    /* First bit always 1 (fix at end) and swap equals first bit */
    int      swap = 1;
 801c20c:	2301      	movs	r3, #1
 801c20e:	62fb      	str	r3, [r7, #44]	@ 0x2c
#ifdef WOLFSSL_SMALL_STACK
    mp_int*  tmp = NULL;
 801c210:	2300      	movs	r3, #0
 801c212:	623b      	str	r3, [r7, #32]
#endif
    int      infinity;

#ifndef WC_NO_CACHE_RESISTANT
#ifdef WOLFSSL_SMALL_STACK
    tmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 801c214:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801c218:	f002 fd30 	bl	801ec7c <wolfSSL_Malloc>
 801c21c:	6238      	str	r0, [r7, #32]
    if (tmp == NULL) {
 801c21e:	6a3b      	ldr	r3, [r7, #32]
 801c220:	2b00      	cmp	r3, #0
 801c222:	d102      	bne.n	801c22a <ecc_mulmod+0x5e>
        err = MEMORY_E;
 801c224:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c228:	647b      	str	r3, [r7, #68]	@ 0x44
    }
#endif
    if (err == MP_OKAY)
 801c22a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c22c:	2b00      	cmp	r3, #0
 801c22e:	d103      	bne.n	801c238 <ecc_mulmod+0x6c>
        err = mp_init(tmp);
 801c230:	6a38      	ldr	r0, [r7, #32]
 801c232:	f00a fbd2 	bl	80269da <mp_init>
 801c236:	6478      	str	r0, [r7, #68]	@ 0x44
#endif

    /* Step 1: R[0] = P; R[1] = P */
    /* R[0] = P */
    if (err == MP_OKAY)
 801c238:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c23a:	2b00      	cmp	r3, #0
 801c23c:	d109      	bne.n	801c252 <ecc_mulmod+0x86>
        err = mp_copy(P->x, R[0]->x);
 801c23e:	68bb      	ldr	r3, [r7, #8]
 801c240:	681a      	ldr	r2, [r3, #0]
 801c242:	683b      	ldr	r3, [r7, #0]
 801c244:	681b      	ldr	r3, [r3, #0]
 801c246:	681b      	ldr	r3, [r3, #0]
 801c248:	4619      	mov	r1, r3
 801c24a:	4610      	mov	r0, r2
 801c24c:	f00a fe11 	bl	8026e72 <mp_copy>
 801c250:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c252:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c254:	2b00      	cmp	r3, #0
 801c256:	d109      	bne.n	801c26c <ecc_mulmod+0xa0>
        err = mp_copy(P->y, R[0]->y);
 801c258:	68bb      	ldr	r3, [r7, #8]
 801c25a:	685a      	ldr	r2, [r3, #4]
 801c25c:	683b      	ldr	r3, [r7, #0]
 801c25e:	681b      	ldr	r3, [r3, #0]
 801c260:	685b      	ldr	r3, [r3, #4]
 801c262:	4619      	mov	r1, r3
 801c264:	4610      	mov	r0, r2
 801c266:	f00a fe04 	bl	8026e72 <mp_copy>
 801c26a:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c26c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c26e:	2b00      	cmp	r3, #0
 801c270:	d109      	bne.n	801c286 <ecc_mulmod+0xba>
        err = mp_copy(P->z, R[0]->z);
 801c272:	68bb      	ldr	r3, [r7, #8]
 801c274:	689a      	ldr	r2, [r3, #8]
 801c276:	683b      	ldr	r3, [r7, #0]
 801c278:	681b      	ldr	r3, [r3, #0]
 801c27a:	689b      	ldr	r3, [r3, #8]
 801c27c:	4619      	mov	r1, r3
 801c27e:	4610      	mov	r0, r2
 801c280:	f00a fdf7 	bl	8026e72 <mp_copy>
 801c284:	6478      	str	r0, [r7, #68]	@ 0x44

    /* R[1] = P */
    if (err == MP_OKAY)
 801c286:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c288:	2b00      	cmp	r3, #0
 801c28a:	d10a      	bne.n	801c2a2 <ecc_mulmod+0xd6>
        err = mp_copy(P->x, R[1]->x);
 801c28c:	68bb      	ldr	r3, [r7, #8]
 801c28e:	681a      	ldr	r2, [r3, #0]
 801c290:	683b      	ldr	r3, [r7, #0]
 801c292:	3304      	adds	r3, #4
 801c294:	681b      	ldr	r3, [r3, #0]
 801c296:	681b      	ldr	r3, [r3, #0]
 801c298:	4619      	mov	r1, r3
 801c29a:	4610      	mov	r0, r2
 801c29c:	f00a fde9 	bl	8026e72 <mp_copy>
 801c2a0:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c2a2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c2a4:	2b00      	cmp	r3, #0
 801c2a6:	d10a      	bne.n	801c2be <ecc_mulmod+0xf2>
        err = mp_copy(P->y, R[1]->y);
 801c2a8:	68bb      	ldr	r3, [r7, #8]
 801c2aa:	685a      	ldr	r2, [r3, #4]
 801c2ac:	683b      	ldr	r3, [r7, #0]
 801c2ae:	3304      	adds	r3, #4
 801c2b0:	681b      	ldr	r3, [r3, #0]
 801c2b2:	685b      	ldr	r3, [r3, #4]
 801c2b4:	4619      	mov	r1, r3
 801c2b6:	4610      	mov	r0, r2
 801c2b8:	f00a fddb 	bl	8026e72 <mp_copy>
 801c2bc:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c2be:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c2c0:	2b00      	cmp	r3, #0
 801c2c2:	d10a      	bne.n	801c2da <ecc_mulmod+0x10e>
        err = mp_copy(P->z, R[1]->z);
 801c2c4:	68bb      	ldr	r3, [r7, #8]
 801c2c6:	689a      	ldr	r2, [r3, #8]
 801c2c8:	683b      	ldr	r3, [r7, #0]
 801c2ca:	3304      	adds	r3, #4
 801c2cc:	681b      	ldr	r3, [r3, #0]
 801c2ce:	689b      	ldr	r3, [r3, #8]
 801c2d0:	4619      	mov	r1, r3
 801c2d2:	4610      	mov	r0, r2
 801c2d4:	f00a fdcd 	bl	8026e72 <mp_copy>
 801c2d8:	6478      	str	r0, [r7, #68]	@ 0x44

    /* Randomize z ordinates to obfuscate timing. */
    if ((err == MP_OKAY) && (rng != NULL))
 801c2da:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c2dc:	2b00      	cmp	r3, #0
 801c2de:	d119      	bne.n	801c314 <ecc_mulmod+0x148>
 801c2e0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801c2e2:	2b00      	cmp	r3, #0
 801c2e4:	d016      	beq.n	801c314 <ecc_mulmod+0x148>
        err = wc_ecc_gen_z(rng, bytes, R[0], modulus, mp, R[2]->x, R[2]->y, kt);
 801c2e6:	683b      	ldr	r3, [r7, #0]
 801c2e8:	6818      	ldr	r0, [r3, #0]
 801c2ea:	683b      	ldr	r3, [r7, #0]
 801c2ec:	3308      	adds	r3, #8
 801c2ee:	681b      	ldr	r3, [r3, #0]
 801c2f0:	681b      	ldr	r3, [r3, #0]
 801c2f2:	683a      	ldr	r2, [r7, #0]
 801c2f4:	3208      	adds	r2, #8
 801c2f6:	6812      	ldr	r2, [r2, #0]
 801c2f8:	6852      	ldr	r2, [r2, #4]
 801c2fa:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c2fc:	9103      	str	r1, [sp, #12]
 801c2fe:	9202      	str	r2, [sp, #8]
 801c300:	9301      	str	r3, [sp, #4]
 801c302:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c304:	9300      	str	r3, [sp, #0]
 801c306:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c308:	4602      	mov	r2, r0
 801c30a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801c30c:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801c30e:	f7ff fece 	bl	801c0ae <wc_ecc_gen_z>
 801c312:	6478      	str	r0, [r7, #68]	@ 0x44
    if ((err == MP_OKAY) && (rng != NULL))
 801c314:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c316:	2b00      	cmp	r3, #0
 801c318:	d11a      	bne.n	801c350 <ecc_mulmod+0x184>
 801c31a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801c31c:	2b00      	cmp	r3, #0
 801c31e:	d017      	beq.n	801c350 <ecc_mulmod+0x184>
        err = wc_ecc_gen_z(rng, bytes, R[1], modulus, mp, R[2]->x, R[2]->y, kt);
 801c320:	683b      	ldr	r3, [r7, #0]
 801c322:	3304      	adds	r3, #4
 801c324:	6818      	ldr	r0, [r3, #0]
 801c326:	683b      	ldr	r3, [r7, #0]
 801c328:	3308      	adds	r3, #8
 801c32a:	681b      	ldr	r3, [r3, #0]
 801c32c:	681b      	ldr	r3, [r3, #0]
 801c32e:	683a      	ldr	r2, [r7, #0]
 801c330:	3208      	adds	r2, #8
 801c332:	6812      	ldr	r2, [r2, #0]
 801c334:	6852      	ldr	r2, [r2, #4]
 801c336:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c338:	9103      	str	r1, [sp, #12]
 801c33a:	9202      	str	r2, [sp, #8]
 801c33c:	9301      	str	r3, [sp, #4]
 801c33e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c340:	9300      	str	r3, [sp, #0]
 801c342:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c344:	4602      	mov	r2, r0
 801c346:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801c348:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801c34a:	f7ff feb0 	bl	801c0ae <wc_ecc_gen_z>
 801c34e:	6478      	str	r0, [r7, #68]	@ 0x44

    if (err == MP_OKAY) {
 801c350:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c352:	2b00      	cmp	r3, #0
 801c354:	d114      	bne.n	801c380 <ecc_mulmod+0x1b4>
        /* Order could be one greater than the size of the modulus. */
        t = mp_count_bits(modulus) + 1;
 801c356:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801c358:	f00a fdaa 	bl	8026eb0 <mp_count_bits>
 801c35c:	4603      	mov	r3, r0
 801c35e:	3301      	adds	r3, #1
 801c360:	637b      	str	r3, [r7, #52]	@ 0x34
        v = k->dp[0] >> 1;
 801c362:	68fb      	ldr	r3, [r7, #12]
 801c364:	68db      	ldr	r3, [r3, #12]
 801c366:	085b      	lsrs	r3, r3, #1
 801c368:	633b      	str	r3, [r7, #48]	@ 0x30
        if (cnt > t) {
 801c36a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c36c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c36e:	429a      	cmp	r2, r3
 801c370:	dd01      	ble.n	801c376 <ecc_mulmod+0x1aa>
            cnt = t;
 801c372:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c374:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
        err = mp_copy(k, kt);
 801c376:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c378:	68f8      	ldr	r0, [r7, #12]
 801c37a:	f00a fd7a 	bl	8026e72 <mp_copy>
 801c37e:	6478      	str	r0, [r7, #68]	@ 0x44
    }
    if (err == MP_OKAY) {
 801c380:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c382:	2b00      	cmp	r3, #0
 801c384:	d101      	bne.n	801c38a <ecc_mulmod+0x1be>
        err = mp_grow(kt, (int)modulus->used + 1);
 801c386:	2300      	movs	r3, #0
 801c388:	647b      	str	r3, [r7, #68]	@ 0x44
    }
    /* Step 2: for j = 1 to t-1 do */
    for (i = 1; (err == MP_OKAY) && (i < t); i++) {
 801c38a:	2301      	movs	r3, #1
 801c38c:	643b      	str	r3, [r7, #64]	@ 0x40
 801c38e:	e079      	b.n	801c484 <ecc_mulmod+0x2b8>
        if (--cnt == 0) {
 801c390:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801c392:	3b01      	subs	r3, #1
 801c394:	63bb      	str	r3, [r7, #56]	@ 0x38
 801c396:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801c398:	2b00      	cmp	r3, #0
 801c39a:	d10a      	bne.n	801c3b2 <ecc_mulmod+0x1e6>
            v = kt->dp[j++];
 801c39c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c39e:	1c5a      	adds	r2, r3, #1
 801c3a0:	63fa      	str	r2, [r7, #60]	@ 0x3c
 801c3a2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801c3a4:	3302      	adds	r3, #2
 801c3a6:	009b      	lsls	r3, r3, #2
 801c3a8:	4413      	add	r3, r2
 801c3aa:	685b      	ldr	r3, [r3, #4]
 801c3ac:	633b      	str	r3, [r7, #48]	@ 0x30
            cnt = DIGIT_BIT;
 801c3ae:	2320      	movs	r3, #32
 801c3b0:	63bb      	str	r3, [r7, #56]	@ 0x38
        }

        /* Step 3: b = 1 - k[j]; R[b] = 2*R[b] + R[k[j]] */
        b = v & 1;
 801c3b2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c3b4:	f003 0301 	and.w	r3, r3, #1
 801c3b8:	61fb      	str	r3, [r7, #28]
        v >>= 1;
 801c3ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c3bc:	085b      	lsrs	r3, r3, #1
 801c3be:	633b      	str	r3, [r7, #48]	@ 0x30
            err = ecc_projective_add_point_safe(R[b^1], R[b], R[b^1], a,
                                                        modulus, mp, &infinity);
        }
#else
        /* Swap R[0] and R[1] if other index is needed. */
        swap ^= (int)b;
 801c3c0:	69fb      	ldr	r3, [r7, #28]
 801c3c2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801c3c4:	4053      	eors	r3, r2
 801c3c6:	62fb      	str	r3, [r7, #44]	@ 0x2c
        if (err == MP_OKAY) {
 801c3c8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c3ca:	2b00      	cmp	r3, #0
 801c3cc:	d10e      	bne.n	801c3ec <ecc_mulmod+0x220>
            err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, swap,
 801c3ce:	683b      	ldr	r3, [r7, #0]
 801c3d0:	681b      	ldr	r3, [r3, #0]
 801c3d2:	6818      	ldr	r0, [r3, #0]
 801c3d4:	683b      	ldr	r3, [r7, #0]
 801c3d6:	3304      	adds	r3, #4
 801c3d8:	681b      	ldr	r3, [r3, #0]
 801c3da:	6819      	ldr	r1, [r3, #0]
 801c3dc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c3de:	681a      	ldr	r2, [r3, #0]
 801c3e0:	6a3b      	ldr	r3, [r7, #32]
 801c3e2:	9300      	str	r3, [sp, #0]
 801c3e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c3e6:	f00a fe19 	bl	802701c <mp_cond_swap_ct_ex>
 801c3ea:	6478      	str	r0, [r7, #68]	@ 0x44
                tmp);
        }
        if (err == MP_OKAY) {
 801c3ec:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c3ee:	2b00      	cmp	r3, #0
 801c3f0:	d10e      	bne.n	801c410 <ecc_mulmod+0x244>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used, swap,
 801c3f2:	683b      	ldr	r3, [r7, #0]
 801c3f4:	681b      	ldr	r3, [r3, #0]
 801c3f6:	6858      	ldr	r0, [r3, #4]
 801c3f8:	683b      	ldr	r3, [r7, #0]
 801c3fa:	3304      	adds	r3, #4
 801c3fc:	681b      	ldr	r3, [r3, #0]
 801c3fe:	6859      	ldr	r1, [r3, #4]
 801c400:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c402:	681a      	ldr	r2, [r3, #0]
 801c404:	6a3b      	ldr	r3, [r7, #32]
 801c406:	9300      	str	r3, [sp, #0]
 801c408:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c40a:	f00a fe07 	bl	802701c <mp_cond_swap_ct_ex>
 801c40e:	6478      	str	r0, [r7, #68]	@ 0x44
                tmp);
        }
        if (err == MP_OKAY) {
 801c410:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c412:	2b00      	cmp	r3, #0
 801c414:	d10e      	bne.n	801c434 <ecc_mulmod+0x268>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used, swap,
 801c416:	683b      	ldr	r3, [r7, #0]
 801c418:	681b      	ldr	r3, [r3, #0]
 801c41a:	6898      	ldr	r0, [r3, #8]
 801c41c:	683b      	ldr	r3, [r7, #0]
 801c41e:	3304      	adds	r3, #4
 801c420:	681b      	ldr	r3, [r3, #0]
 801c422:	6899      	ldr	r1, [r3, #8]
 801c424:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c426:	681a      	ldr	r2, [r3, #0]
 801c428:	6a3b      	ldr	r3, [r7, #32]
 801c42a:	9300      	str	r3, [sp, #0]
 801c42c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c42e:	f00a fdf5 	bl	802701c <mp_cond_swap_ct_ex>
 801c432:	6478      	str	r0, [r7, #68]	@ 0x44
                tmp);
        }
        swap = (int)b;
 801c434:	69fb      	ldr	r3, [r7, #28]
 801c436:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if (err == MP_OKAY)
 801c438:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c43a:	2b00      	cmp	r3, #0
 801c43c:	d10a      	bne.n	801c454 <ecc_mulmod+0x288>
            err = ecc_projective_dbl_point_safe(R[0], R[0], a, modulus, mp);
 801c43e:	683b      	ldr	r3, [r7, #0]
 801c440:	6818      	ldr	r0, [r3, #0]
 801c442:	683b      	ldr	r3, [r7, #0]
 801c444:	6819      	ldr	r1, [r3, #0]
 801c446:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c448:	9300      	str	r3, [sp, #0]
 801c44a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c44c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801c44e:	f000 ff48 	bl	801d2e2 <ecc_projective_dbl_point_safe>
 801c452:	6478      	str	r0, [r7, #68]	@ 0x44
        if (err == MP_OKAY) {
 801c454:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c456:	2b00      	cmp	r3, #0
 801c458:	d111      	bne.n	801c47e <ecc_mulmod+0x2b2>
            err = ecc_projective_add_point_safe(R[0], R[1], R[0], a, modulus,
 801c45a:	683b      	ldr	r3, [r7, #0]
 801c45c:	6818      	ldr	r0, [r3, #0]
 801c45e:	683b      	ldr	r3, [r7, #0]
 801c460:	3304      	adds	r3, #4
 801c462:	6819      	ldr	r1, [r3, #0]
 801c464:	683b      	ldr	r3, [r7, #0]
 801c466:	681a      	ldr	r2, [r3, #0]
 801c468:	f107 0314 	add.w	r3, r7, #20
 801c46c:	9302      	str	r3, [sp, #8]
 801c46e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c470:	9301      	str	r3, [sp, #4]
 801c472:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c474:	9300      	str	r3, [sp, #0]
 801c476:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801c478:	f000 fe2f 	bl	801d0da <ecc_projective_add_point_safe>
 801c47c:	6478      	str	r0, [r7, #68]	@ 0x44
    for (i = 1; (err == MP_OKAY) && (i < t); i++) {
 801c47e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c480:	3301      	adds	r3, #1
 801c482:	643b      	str	r3, [r7, #64]	@ 0x40
 801c484:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c486:	2b00      	cmp	r3, #0
 801c488:	d104      	bne.n	801c494 <ecc_mulmod+0x2c8>
 801c48a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801c48c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c48e:	429a      	cmp	r2, r3
 801c490:	f6ff af7e 	blt.w	801c390 <ecc_mulmod+0x1c4>
#endif /* WC_NO_CACHE_RESISTANT */
    }
    /* Step 4: end for */
#ifndef WC_NO_CACHE_RESISTANT
    /* Swap back if last bit is 0. */
    swap ^= 1;
 801c494:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c496:	f083 0301 	eor.w	r3, r3, #1
 801c49a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if (err == MP_OKAY) {
 801c49c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c49e:	2b00      	cmp	r3, #0
 801c4a0:	d10e      	bne.n	801c4c0 <ecc_mulmod+0x2f4>
        err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, swap,
 801c4a2:	683b      	ldr	r3, [r7, #0]
 801c4a4:	681b      	ldr	r3, [r3, #0]
 801c4a6:	6818      	ldr	r0, [r3, #0]
 801c4a8:	683b      	ldr	r3, [r7, #0]
 801c4aa:	3304      	adds	r3, #4
 801c4ac:	681b      	ldr	r3, [r3, #0]
 801c4ae:	6819      	ldr	r1, [r3, #0]
 801c4b0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c4b2:	681a      	ldr	r2, [r3, #0]
 801c4b4:	6a3b      	ldr	r3, [r7, #32]
 801c4b6:	9300      	str	r3, [sp, #0]
 801c4b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c4ba:	f00a fdaf 	bl	802701c <mp_cond_swap_ct_ex>
 801c4be:	6478      	str	r0, [r7, #68]	@ 0x44
            tmp);
    }
    if (err == MP_OKAY) {
 801c4c0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c4c2:	2b00      	cmp	r3, #0
 801c4c4:	d10e      	bne.n	801c4e4 <ecc_mulmod+0x318>
        err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used, swap,
 801c4c6:	683b      	ldr	r3, [r7, #0]
 801c4c8:	681b      	ldr	r3, [r3, #0]
 801c4ca:	6858      	ldr	r0, [r3, #4]
 801c4cc:	683b      	ldr	r3, [r7, #0]
 801c4ce:	3304      	adds	r3, #4
 801c4d0:	681b      	ldr	r3, [r3, #0]
 801c4d2:	6859      	ldr	r1, [r3, #4]
 801c4d4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c4d6:	681a      	ldr	r2, [r3, #0]
 801c4d8:	6a3b      	ldr	r3, [r7, #32]
 801c4da:	9300      	str	r3, [sp, #0]
 801c4dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c4de:	f00a fd9d 	bl	802701c <mp_cond_swap_ct_ex>
 801c4e2:	6478      	str	r0, [r7, #68]	@ 0x44
            tmp);
    }
    if (err == MP_OKAY) {
 801c4e4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c4e6:	2b00      	cmp	r3, #0
 801c4e8:	d10e      	bne.n	801c508 <ecc_mulmod+0x33c>
        err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used, swap,
 801c4ea:	683b      	ldr	r3, [r7, #0]
 801c4ec:	681b      	ldr	r3, [r3, #0]
 801c4ee:	6898      	ldr	r0, [r3, #8]
 801c4f0:	683b      	ldr	r3, [r7, #0]
 801c4f2:	3304      	adds	r3, #4
 801c4f4:	681b      	ldr	r3, [r3, #0]
 801c4f6:	6899      	ldr	r1, [r3, #8]
 801c4f8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c4fa:	681a      	ldr	r2, [r3, #0]
 801c4fc:	6a3b      	ldr	r3, [r7, #32]
 801c4fe:	9300      	str	r3, [sp, #0]
 801c500:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c502:	f00a fd8b 	bl	802701c <mp_cond_swap_ct_ex>
 801c506:	6478      	str	r0, [r7, #68]	@ 0x44
    }
#endif

    /* Step 5: b = k[0]; R[b] = R[b] - P */
    /* R[2] = -P */
    if (err == MP_OKAY)
 801c508:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c50a:	2b00      	cmp	r3, #0
 801c50c:	d10a      	bne.n	801c524 <ecc_mulmod+0x358>
        err = mp_copy(P->x, R[2]->x);
 801c50e:	68bb      	ldr	r3, [r7, #8]
 801c510:	681a      	ldr	r2, [r3, #0]
 801c512:	683b      	ldr	r3, [r7, #0]
 801c514:	3308      	adds	r3, #8
 801c516:	681b      	ldr	r3, [r3, #0]
 801c518:	681b      	ldr	r3, [r3, #0]
 801c51a:	4619      	mov	r1, r3
 801c51c:	4610      	mov	r0, r2
 801c51e:	f00a fca8 	bl	8026e72 <mp_copy>
 801c522:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c524:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c526:	2b00      	cmp	r3, #0
 801c528:	d10a      	bne.n	801c540 <ecc_mulmod+0x374>
        err = mp_sub(modulus, P->y, R[2]->y);
 801c52a:	68bb      	ldr	r3, [r7, #8]
 801c52c:	6859      	ldr	r1, [r3, #4]
 801c52e:	683b      	ldr	r3, [r7, #0]
 801c530:	3308      	adds	r3, #8
 801c532:	681b      	ldr	r3, [r3, #0]
 801c534:	685b      	ldr	r3, [r3, #4]
 801c536:	461a      	mov	r2, r3
 801c538:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801c53a:	f00a fb32 	bl	8026ba2 <mp_sub>
 801c53e:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c540:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c542:	2b00      	cmp	r3, #0
 801c544:	d10a      	bne.n	801c55c <ecc_mulmod+0x390>
        err = mp_copy(P->z, R[2]->z);
 801c546:	68bb      	ldr	r3, [r7, #8]
 801c548:	689a      	ldr	r2, [r3, #8]
 801c54a:	683b      	ldr	r3, [r7, #0]
 801c54c:	3308      	adds	r3, #8
 801c54e:	681b      	ldr	r3, [r3, #0]
 801c550:	689b      	ldr	r3, [r3, #8]
 801c552:	4619      	mov	r1, r3
 801c554:	4610      	mov	r0, r2
 801c556:	f00a fc8c 	bl	8026e72 <mp_copy>
 801c55a:	6478      	str	r0, [r7, #68]	@ 0x44
    /* Subtract point by adding negative. */
    if (err == MP_OKAY) {
 801c55c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c55e:	2b00      	cmp	r3, #0
 801c560:	f040 8089 	bne.w	801c676 <ecc_mulmod+0x4aa>
        b = k->dp[0] & 1;
 801c564:	68fb      	ldr	r3, [r7, #12]
 801c566:	68db      	ldr	r3, [r3, #12]
 801c568:	f003 0301 	and.w	r3, r3, #1
 801c56c:	61fb      	str	r3, [r7, #28]
#ifdef WC_NO_CACHE_RESISTANT
        err = ecc_projective_add_point_safe(R[b], R[2], R[b], a, modulus, mp,
                                                                     &infinity);
#else
        /* Swap R[0] and R[1], if necessary, to operate on the one we want. */
        err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, (int)b,
 801c56e:	683b      	ldr	r3, [r7, #0]
 801c570:	681b      	ldr	r3, [r3, #0]
 801c572:	6818      	ldr	r0, [r3, #0]
 801c574:	683b      	ldr	r3, [r7, #0]
 801c576:	3304      	adds	r3, #4
 801c578:	681b      	ldr	r3, [r3, #0]
 801c57a:	6819      	ldr	r1, [r3, #0]
 801c57c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c57e:	681a      	ldr	r2, [r3, #0]
 801c580:	69fc      	ldr	r4, [r7, #28]
 801c582:	6a3b      	ldr	r3, [r7, #32]
 801c584:	9300      	str	r3, [sp, #0]
 801c586:	4623      	mov	r3, r4
 801c588:	f00a fd48 	bl	802701c <mp_cond_swap_ct_ex>
 801c58c:	6478      	str	r0, [r7, #68]	@ 0x44
            tmp);
        if (err == MP_OKAY) {
 801c58e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c590:	2b00      	cmp	r3, #0
 801c592:	d10f      	bne.n	801c5b4 <ecc_mulmod+0x3e8>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used,
 801c594:	683b      	ldr	r3, [r7, #0]
 801c596:	681b      	ldr	r3, [r3, #0]
 801c598:	6858      	ldr	r0, [r3, #4]
 801c59a:	683b      	ldr	r3, [r7, #0]
 801c59c:	3304      	adds	r3, #4
 801c59e:	681b      	ldr	r3, [r3, #0]
 801c5a0:	6859      	ldr	r1, [r3, #4]
 801c5a2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c5a4:	681a      	ldr	r2, [r3, #0]
 801c5a6:	69fc      	ldr	r4, [r7, #28]
 801c5a8:	6a3b      	ldr	r3, [r7, #32]
 801c5aa:	9300      	str	r3, [sp, #0]
 801c5ac:	4623      	mov	r3, r4
 801c5ae:	f00a fd35 	bl	802701c <mp_cond_swap_ct_ex>
 801c5b2:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY) {
 801c5b4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c5b6:	2b00      	cmp	r3, #0
 801c5b8:	d10f      	bne.n	801c5da <ecc_mulmod+0x40e>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used,
 801c5ba:	683b      	ldr	r3, [r7, #0]
 801c5bc:	681b      	ldr	r3, [r3, #0]
 801c5be:	6898      	ldr	r0, [r3, #8]
 801c5c0:	683b      	ldr	r3, [r7, #0]
 801c5c2:	3304      	adds	r3, #4
 801c5c4:	681b      	ldr	r3, [r3, #0]
 801c5c6:	6899      	ldr	r1, [r3, #8]
 801c5c8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c5ca:	681a      	ldr	r2, [r3, #0]
 801c5cc:	69fc      	ldr	r4, [r7, #28]
 801c5ce:	6a3b      	ldr	r3, [r7, #32]
 801c5d0:	9300      	str	r3, [sp, #0]
 801c5d2:	4623      	mov	r3, r4
 801c5d4:	f00a fd22 	bl	802701c <mp_cond_swap_ct_ex>
 801c5d8:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY)
 801c5da:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c5dc:	2b00      	cmp	r3, #0
 801c5de:	d111      	bne.n	801c604 <ecc_mulmod+0x438>
            err = ecc_projective_add_point_safe(R[0], R[2], R[0], a, modulus,
 801c5e0:	683b      	ldr	r3, [r7, #0]
 801c5e2:	6818      	ldr	r0, [r3, #0]
 801c5e4:	683b      	ldr	r3, [r7, #0]
 801c5e6:	3308      	adds	r3, #8
 801c5e8:	6819      	ldr	r1, [r3, #0]
 801c5ea:	683b      	ldr	r3, [r7, #0]
 801c5ec:	681a      	ldr	r2, [r3, #0]
 801c5ee:	f107 0314 	add.w	r3, r7, #20
 801c5f2:	9302      	str	r3, [sp, #8]
 801c5f4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c5f6:	9301      	str	r3, [sp, #4]
 801c5f8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c5fa:	9300      	str	r3, [sp, #0]
 801c5fc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801c5fe:	f000 fd6c 	bl	801d0da <ecc_projective_add_point_safe>
 801c602:	6478      	str	r0, [r7, #68]	@ 0x44
                                                                 mp, &infinity);
        /* Swap back if necessary. */
        if (err == MP_OKAY) {
 801c604:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c606:	2b00      	cmp	r3, #0
 801c608:	d10f      	bne.n	801c62a <ecc_mulmod+0x45e>
            err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used,
 801c60a:	683b      	ldr	r3, [r7, #0]
 801c60c:	681b      	ldr	r3, [r3, #0]
 801c60e:	6818      	ldr	r0, [r3, #0]
 801c610:	683b      	ldr	r3, [r7, #0]
 801c612:	3304      	adds	r3, #4
 801c614:	681b      	ldr	r3, [r3, #0]
 801c616:	6819      	ldr	r1, [r3, #0]
 801c618:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c61a:	681a      	ldr	r2, [r3, #0]
 801c61c:	69fc      	ldr	r4, [r7, #28]
 801c61e:	6a3b      	ldr	r3, [r7, #32]
 801c620:	9300      	str	r3, [sp, #0]
 801c622:	4623      	mov	r3, r4
 801c624:	f00a fcfa 	bl	802701c <mp_cond_swap_ct_ex>
 801c628:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY) {
 801c62a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c62c:	2b00      	cmp	r3, #0
 801c62e:	d10f      	bne.n	801c650 <ecc_mulmod+0x484>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used,
 801c630:	683b      	ldr	r3, [r7, #0]
 801c632:	681b      	ldr	r3, [r3, #0]
 801c634:	6858      	ldr	r0, [r3, #4]
 801c636:	683b      	ldr	r3, [r7, #0]
 801c638:	3304      	adds	r3, #4
 801c63a:	681b      	ldr	r3, [r3, #0]
 801c63c:	6859      	ldr	r1, [r3, #4]
 801c63e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c640:	681a      	ldr	r2, [r3, #0]
 801c642:	69fc      	ldr	r4, [r7, #28]
 801c644:	6a3b      	ldr	r3, [r7, #32]
 801c646:	9300      	str	r3, [sp, #0]
 801c648:	4623      	mov	r3, r4
 801c64a:	f00a fce7 	bl	802701c <mp_cond_swap_ct_ex>
 801c64e:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY) {
 801c650:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c652:	2b00      	cmp	r3, #0
 801c654:	d10f      	bne.n	801c676 <ecc_mulmod+0x4aa>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used,
 801c656:	683b      	ldr	r3, [r7, #0]
 801c658:	681b      	ldr	r3, [r3, #0]
 801c65a:	6898      	ldr	r0, [r3, #8]
 801c65c:	683b      	ldr	r3, [r7, #0]
 801c65e:	3304      	adds	r3, #4
 801c660:	681b      	ldr	r3, [r3, #0]
 801c662:	6899      	ldr	r1, [r3, #8]
 801c664:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c666:	681a      	ldr	r2, [r3, #0]
 801c668:	69fc      	ldr	r4, [r7, #28]
 801c66a:	6a3b      	ldr	r3, [r7, #32]
 801c66c:	9300      	str	r3, [sp, #0]
 801c66e:	4623      	mov	r3, r4
 801c670:	f00a fcd4 	bl	802701c <mp_cond_swap_ct_ex>
 801c674:	6478      	str	r0, [r7, #68]	@ 0x44
        }
#endif
    }

    /* Step 6: return R[0] */
    if (err == MP_OKAY)
 801c676:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c678:	2b00      	cmp	r3, #0
 801c67a:	d109      	bne.n	801c690 <ecc_mulmod+0x4c4>
        err = mp_copy(R[0]->x, Q->x);
 801c67c:	683b      	ldr	r3, [r7, #0]
 801c67e:	681b      	ldr	r3, [r3, #0]
 801c680:	681a      	ldr	r2, [r3, #0]
 801c682:	687b      	ldr	r3, [r7, #4]
 801c684:	681b      	ldr	r3, [r3, #0]
 801c686:	4619      	mov	r1, r3
 801c688:	4610      	mov	r0, r2
 801c68a:	f00a fbf2 	bl	8026e72 <mp_copy>
 801c68e:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c690:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c692:	2b00      	cmp	r3, #0
 801c694:	d109      	bne.n	801c6aa <ecc_mulmod+0x4de>
        err = mp_copy(R[0]->y, Q->y);
 801c696:	683b      	ldr	r3, [r7, #0]
 801c698:	681b      	ldr	r3, [r3, #0]
 801c69a:	685a      	ldr	r2, [r3, #4]
 801c69c:	687b      	ldr	r3, [r7, #4]
 801c69e:	685b      	ldr	r3, [r3, #4]
 801c6a0:	4619      	mov	r1, r3
 801c6a2:	4610      	mov	r0, r2
 801c6a4:	f00a fbe5 	bl	8026e72 <mp_copy>
 801c6a8:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c6aa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c6ac:	2b00      	cmp	r3, #0
 801c6ae:	d109      	bne.n	801c6c4 <ecc_mulmod+0x4f8>
        err = mp_copy(R[0]->z, Q->z);
 801c6b0:	683b      	ldr	r3, [r7, #0]
 801c6b2:	681b      	ldr	r3, [r3, #0]
 801c6b4:	689a      	ldr	r2, [r3, #8]
 801c6b6:	687b      	ldr	r3, [r7, #4]
 801c6b8:	689b      	ldr	r3, [r3, #8]
 801c6ba:	4619      	mov	r1, r3
 801c6bc:	4610      	mov	r0, r2
 801c6be:	f00a fbd8 	bl	8026e72 <mp_copy>
 801c6c2:	6478      	str	r0, [r7, #68]	@ 0x44

#if defined(WOLFSSL_SMALL_STACK) && !defined(WC_NO_CACHE_RESISTANT)
    XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
 801c6c4:	6a3b      	ldr	r3, [r7, #32]
 801c6c6:	61bb      	str	r3, [r7, #24]
 801c6c8:	69bb      	ldr	r3, [r7, #24]
 801c6ca:	2b00      	cmp	r3, #0
 801c6cc:	d002      	beq.n	801c6d4 <ecc_mulmod+0x508>
 801c6ce:	69b8      	ldr	r0, [r7, #24]
 801c6d0:	f002 faf0 	bl	801ecb4 <wolfSSL_Free>
#endif

    return err;
 801c6d4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 801c6d6:	4618      	mov	r0, r3
 801c6d8:	374c      	adds	r7, #76	@ 0x4c
 801c6da:	46bd      	mov	sp, r7
 801c6dc:	bd90      	pop	{r4, r7, pc}

0801c6de <ecc_point_to_mont>:
 * @return  0 on success.
 * @return  -ve on failure.
 */
static int ecc_point_to_mont(ecc_point* p, ecc_point* r, mp_int* modulus,
                             void* heap)
{
 801c6de:	b580      	push	{r7, lr}
 801c6e0:	b088      	sub	sp, #32
 801c6e2:	af00      	add	r7, sp, #0
 801c6e4:	60f8      	str	r0, [r7, #12]
 801c6e6:	60b9      	str	r1, [r7, #8]
 801c6e8:	607a      	str	r2, [r7, #4]
 801c6ea:	603b      	str	r3, [r7, #0]
   int err = MP_OKAY;
 801c6ec:	2300      	movs	r3, #0
 801c6ee:	61fb      	str	r3, [r7, #28]
   DECL_MP_INT_SIZE_DYN(mu, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801c6f0:	2300      	movs	r3, #0
 801c6f2:	61bb      	str	r3, [r7, #24]

   (void)heap;

   NEW_MP_INT_SIZE(mu, mp_bitsused(modulus), heap, DYNAMIC_TYPE_ECC);
 801c6f4:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801c6f8:	f002 fac0 	bl	801ec7c <wolfSSL_Malloc>
 801c6fc:	61b8      	str	r0, [r7, #24]
 801c6fe:	69bb      	ldr	r3, [r7, #24]
 801c700:	2b00      	cmp	r3, #0
 801c702:	d005      	beq.n	801c710 <ecc_point_to_mont+0x32>
 801c704:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801c708:	2100      	movs	r1, #0
 801c70a:	69b8      	ldr	r0, [r7, #24]
 801c70c:	f00c fa8a 	bl	8028c24 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
   if (mu == NULL)
 801c710:	69bb      	ldr	r3, [r7, #24]
 801c712:	2b00      	cmp	r3, #0
 801c714:	d102      	bne.n	801c71c <ecc_point_to_mont+0x3e>
       err = MEMORY_E;
 801c716:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c71a:	61fb      	str	r3, [r7, #28]
#endif
   if (err == MP_OKAY)
 801c71c:	69fb      	ldr	r3, [r7, #28]
 801c71e:	2b00      	cmp	r3, #0
 801c720:	d103      	bne.n	801c72a <ecc_point_to_mont+0x4c>
       err = INIT_MP_INT_SIZE(mu, mp_bitsused(modulus));
 801c722:	69b8      	ldr	r0, [r7, #24]
 801c724:	f00a f959 	bl	80269da <mp_init>
 801c728:	61f8      	str	r0, [r7, #28]
   if (err == MP_OKAY) {
 801c72a:	69fb      	ldr	r3, [r7, #28]
 801c72c:	2b00      	cmp	r3, #0
 801c72e:	d154      	bne.n	801c7da <ecc_point_to_mont+0xfc>
       err = mp_montgomery_calc_normalization(mu, modulus);
 801c730:	6879      	ldr	r1, [r7, #4]
 801c732:	69b8      	ldr	r0, [r7, #24]
 801c734:	f00a fbe1 	bl	8026efa <mp_montgomery_calc_normalization>
 801c738:	61f8      	str	r0, [r7, #28]

       if (err == MP_OKAY) {
 801c73a:	69fb      	ldr	r3, [r7, #28]
 801c73c:	2b00      	cmp	r3, #0
 801c73e:	d149      	bne.n	801c7d4 <ecc_point_to_mont+0xf6>
           if (mp_cmp_d(mu, 1) == MP_EQ) {
 801c740:	2101      	movs	r1, #1
 801c742:	69b8      	ldr	r0, [r7, #24]
 801c744:	f00a faea 	bl	8026d1c <mp_cmp_d>
 801c748:	4603      	mov	r3, r0
 801c74a:	2b00      	cmp	r3, #0
 801c74c:	d121      	bne.n	801c792 <ecc_point_to_mont+0xb4>
               err = mp_copy(p->x, r->x);
 801c74e:	68fb      	ldr	r3, [r7, #12]
 801c750:	681a      	ldr	r2, [r3, #0]
 801c752:	68bb      	ldr	r3, [r7, #8]
 801c754:	681b      	ldr	r3, [r3, #0]
 801c756:	4619      	mov	r1, r3
 801c758:	4610      	mov	r0, r2
 801c75a:	f00a fb8a 	bl	8026e72 <mp_copy>
 801c75e:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c760:	69fb      	ldr	r3, [r7, #28]
 801c762:	2b00      	cmp	r3, #0
 801c764:	d108      	bne.n	801c778 <ecc_point_to_mont+0x9a>
                   err = mp_copy(p->y, r->y);
 801c766:	68fb      	ldr	r3, [r7, #12]
 801c768:	685a      	ldr	r2, [r3, #4]
 801c76a:	68bb      	ldr	r3, [r7, #8]
 801c76c:	685b      	ldr	r3, [r3, #4]
 801c76e:	4619      	mov	r1, r3
 801c770:	4610      	mov	r0, r2
 801c772:	f00a fb7e 	bl	8026e72 <mp_copy>
 801c776:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c778:	69fb      	ldr	r3, [r7, #28]
 801c77a:	2b00      	cmp	r3, #0
 801c77c:	d12a      	bne.n	801c7d4 <ecc_point_to_mont+0xf6>
                   err = mp_copy(p->z, r->z);
 801c77e:	68fb      	ldr	r3, [r7, #12]
 801c780:	689a      	ldr	r2, [r3, #8]
 801c782:	68bb      	ldr	r3, [r7, #8]
 801c784:	689b      	ldr	r3, [r3, #8]
 801c786:	4619      	mov	r1, r3
 801c788:	4610      	mov	r0, r2
 801c78a:	f00a fb72 	bl	8026e72 <mp_copy>
 801c78e:	61f8      	str	r0, [r7, #28]
 801c790:	e020      	b.n	801c7d4 <ecc_point_to_mont+0xf6>
           }
           else {
               err = mp_mulmod(p->x, mu, modulus, r->x);
 801c792:	68fb      	ldr	r3, [r7, #12]
 801c794:	6818      	ldr	r0, [r3, #0]
 801c796:	68bb      	ldr	r3, [r7, #8]
 801c798:	681b      	ldr	r3, [r3, #0]
 801c79a:	687a      	ldr	r2, [r7, #4]
 801c79c:	69b9      	ldr	r1, [r7, #24]
 801c79e:	f00a fa20 	bl	8026be2 <mp_mulmod>
 801c7a2:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c7a4:	69fb      	ldr	r3, [r7, #28]
 801c7a6:	2b00      	cmp	r3, #0
 801c7a8:	d108      	bne.n	801c7bc <ecc_point_to_mont+0xde>
                   err = mp_mulmod(p->y, mu, modulus, r->y);
 801c7aa:	68fb      	ldr	r3, [r7, #12]
 801c7ac:	6858      	ldr	r0, [r3, #4]
 801c7ae:	68bb      	ldr	r3, [r7, #8]
 801c7b0:	685b      	ldr	r3, [r3, #4]
 801c7b2:	687a      	ldr	r2, [r7, #4]
 801c7b4:	69b9      	ldr	r1, [r7, #24]
 801c7b6:	f00a fa14 	bl	8026be2 <mp_mulmod>
 801c7ba:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c7bc:	69fb      	ldr	r3, [r7, #28]
 801c7be:	2b00      	cmp	r3, #0
 801c7c0:	d108      	bne.n	801c7d4 <ecc_point_to_mont+0xf6>
                   err = mp_mulmod(p->z, mu, modulus, r->z);
 801c7c2:	68fb      	ldr	r3, [r7, #12]
 801c7c4:	6898      	ldr	r0, [r3, #8]
 801c7c6:	68bb      	ldr	r3, [r7, #8]
 801c7c8:	689b      	ldr	r3, [r3, #8]
 801c7ca:	687a      	ldr	r2, [r7, #4]
 801c7cc:	69b9      	ldr	r1, [r7, #24]
 801c7ce:	f00a fa08 	bl	8026be2 <mp_mulmod>
 801c7d2:	61f8      	str	r0, [r7, #28]
           }
       }

       mp_clear(mu);
 801c7d4:	69b8      	ldr	r0, [r7, #24]
 801c7d6:	f00a f98a 	bl	8026aee <mp_clear>
   }

   FREE_MP_INT_SIZE(mu, heap, DYNAMIC_TYPE_ECC);
 801c7da:	69bb      	ldr	r3, [r7, #24]
 801c7dc:	617b      	str	r3, [r7, #20]
 801c7de:	697b      	ldr	r3, [r7, #20]
 801c7e0:	2b00      	cmp	r3, #0
 801c7e2:	d002      	beq.n	801c7ea <ecc_point_to_mont+0x10c>
 801c7e4:	6978      	ldr	r0, [r7, #20]
 801c7e6:	f002 fa65 	bl	801ecb4 <wolfSSL_Free>
   return err;
 801c7ea:	69fb      	ldr	r3, [r7, #28]
}
 801c7ec:	4618      	mov	r0, r3
 801c7ee:	3720      	adds	r7, #32
 801c7f0:	46bd      	mov	sp, r7
 801c7f2:	bd80      	pop	{r7, pc}

0801c7f4 <ecc_check_order_minus_1>:
#ifndef FP_ECC
#if !defined(WOLFSSL_SP_MATH)
#ifdef ECC_TIMING_RESISTANT
static int ecc_check_order_minus_1(const mp_int* k, ecc_point* tG, ecc_point* R,
   mp_int* modulus, mp_int* order)
{
 801c7f4:	b580      	push	{r7, lr}
 801c7f6:	b088      	sub	sp, #32
 801c7f8:	af00      	add	r7, sp, #0
 801c7fa:	60f8      	str	r0, [r7, #12]
 801c7fc:	60b9      	str	r1, [r7, #8]
 801c7fe:	607a      	str	r2, [r7, #4]
 801c800:	603b      	str	r3, [r7, #0]
    int err;
    DECL_MP_INT_SIZE_DYN(t, mp_bitsused(order), MAX_ECC_BITS_USE);
 801c802:	2300      	movs	r3, #0
 801c804:	61bb      	str	r3, [r7, #24]

    NEW_MP_INT_SIZE(t, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801c806:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801c80a:	f002 fa37 	bl	801ec7c <wolfSSL_Malloc>
 801c80e:	61b8      	str	r0, [r7, #24]
 801c810:	69bb      	ldr	r3, [r7, #24]
 801c812:	2b00      	cmp	r3, #0
 801c814:	d005      	beq.n	801c822 <ecc_check_order_minus_1+0x2e>
 801c816:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801c81a:	2100      	movs	r1, #0
 801c81c:	69b8      	ldr	r0, [r7, #24]
 801c81e:	f00c fa01 	bl	8028c24 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (t == NULL) {
 801c822:	69bb      	ldr	r3, [r7, #24]
 801c824:	2b00      	cmp	r3, #0
 801c826:	d103      	bne.n	801c830 <ecc_check_order_minus_1+0x3c>
        err = MEMORY_E;
 801c828:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c82c:	61fb      	str	r3, [r7, #28]
 801c82e:	e003      	b.n	801c838 <ecc_check_order_minus_1+0x44>
    }
    else
#endif
    {
        err = INIT_MP_INT_SIZE(t, mp_bitsused(modulus));
 801c830:	69b8      	ldr	r0, [r7, #24]
 801c832:	f00a f8d2 	bl	80269da <mp_init>
 801c836:	61f8      	str	r0, [r7, #28]
    }
    if (err == MP_OKAY) {
 801c838:	69fb      	ldr	r3, [r7, #28]
 801c83a:	2b00      	cmp	r3, #0
 801c83c:	d141      	bne.n	801c8c2 <ecc_check_order_minus_1+0xce>
        /* Check for k == order - 1. Result will be 0 point which is not correct
         * Calculates order / 2 and adds order / 2 + 1 and gets infinity.
         * (with constant time implementation)
         */
        err = mp_sub_d(order, 1, t);
 801c83e:	69ba      	ldr	r2, [r7, #24]
 801c840:	2101      	movs	r1, #1
 801c842:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801c844:	f00a fab2 	bl	8026dac <mp_sub_d>
 801c848:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY) {
 801c84a:	69fb      	ldr	r3, [r7, #28]
 801c84c:	2b00      	cmp	r3, #0
 801c84e:	d135      	bne.n	801c8bc <ecc_check_order_minus_1+0xc8>
            int kIsMinusOne = (mp_cmp((mp_int*)k, t) == MP_EQ);
 801c850:	69b9      	ldr	r1, [r7, #24]
 801c852:	68f8      	ldr	r0, [r7, #12]
 801c854:	f00a fa54 	bl	8026d00 <mp_cmp>
 801c858:	4603      	mov	r3, r0
 801c85a:	2b00      	cmp	r3, #0
 801c85c:	bf0c      	ite	eq
 801c85e:	2301      	moveq	r3, #1
 801c860:	2300      	movne	r3, #0
 801c862:	b2db      	uxtb	r3, r3
 801c864:	617b      	str	r3, [r7, #20]
            err = mp_cond_copy(tG->x, kIsMinusOne, R->x);
 801c866:	68bb      	ldr	r3, [r7, #8]
 801c868:	6818      	ldr	r0, [r3, #0]
 801c86a:	687b      	ldr	r3, [r7, #4]
 801c86c:	681b      	ldr	r3, [r3, #0]
 801c86e:	461a      	mov	r2, r3
 801c870:	6979      	ldr	r1, [r7, #20]
 801c872:	f00a ffe8 	bl	8027846 <mp_cond_copy>
 801c876:	61f8      	str	r0, [r7, #28]
            if (err == MP_OKAY) {
 801c878:	69fb      	ldr	r3, [r7, #28]
 801c87a:	2b00      	cmp	r3, #0
 801c87c:	d107      	bne.n	801c88e <ecc_check_order_minus_1+0x9a>
                err = mp_sub(modulus, tG->y, t);
 801c87e:	68bb      	ldr	r3, [r7, #8]
 801c880:	685b      	ldr	r3, [r3, #4]
 801c882:	69ba      	ldr	r2, [r7, #24]
 801c884:	4619      	mov	r1, r3
 801c886:	6838      	ldr	r0, [r7, #0]
 801c888:	f00a f98b 	bl	8026ba2 <mp_sub>
 801c88c:	61f8      	str	r0, [r7, #28]
            }
            if (err == MP_OKAY) {
 801c88e:	69fb      	ldr	r3, [r7, #28]
 801c890:	2b00      	cmp	r3, #0
 801c892:	d107      	bne.n	801c8a4 <ecc_check_order_minus_1+0xb0>
                err = mp_cond_copy(t, kIsMinusOne, R->y);
 801c894:	687b      	ldr	r3, [r7, #4]
 801c896:	685b      	ldr	r3, [r3, #4]
 801c898:	461a      	mov	r2, r3
 801c89a:	6979      	ldr	r1, [r7, #20]
 801c89c:	69b8      	ldr	r0, [r7, #24]
 801c89e:	f00a ffd2 	bl	8027846 <mp_cond_copy>
 801c8a2:	61f8      	str	r0, [r7, #28]
            }
            if (err == MP_OKAY) {
 801c8a4:	69fb      	ldr	r3, [r7, #28]
 801c8a6:	2b00      	cmp	r3, #0
 801c8a8:	d108      	bne.n	801c8bc <ecc_check_order_minus_1+0xc8>
                err = mp_cond_copy(tG->z, kIsMinusOne, R->z);
 801c8aa:	68bb      	ldr	r3, [r7, #8]
 801c8ac:	6898      	ldr	r0, [r3, #8]
 801c8ae:	687b      	ldr	r3, [r7, #4]
 801c8b0:	689b      	ldr	r3, [r3, #8]
 801c8b2:	461a      	mov	r2, r3
 801c8b4:	6979      	ldr	r1, [r7, #20]
 801c8b6:	f00a ffc6 	bl	8027846 <mp_cond_copy>
 801c8ba:	61f8      	str	r0, [r7, #28]
            }
        }

        mp_free(t);
 801c8bc:	69b8      	ldr	r0, [r7, #24]
 801c8be:	f00a f925 	bl	8026b0c <mp_free>
    }

    FREE_MP_INT_SIZE(t, NULL, DYNAMIC_TYPE_ECC);
 801c8c2:	69bb      	ldr	r3, [r7, #24]
 801c8c4:	613b      	str	r3, [r7, #16]
 801c8c6:	693b      	ldr	r3, [r7, #16]
 801c8c8:	2b00      	cmp	r3, #0
 801c8ca:	d002      	beq.n	801c8d2 <ecc_check_order_minus_1+0xde>
 801c8cc:	6938      	ldr	r0, [r7, #16]
 801c8ce:	f002 f9f1 	bl	801ecb4 <wolfSSL_Free>
    return err;
 801c8d2:	69fb      	ldr	r3, [r7, #28]
}
 801c8d4:	4618      	mov	r0, r3
 801c8d6:	3720      	adds	r7, #32
 801c8d8:	46bd      	mov	sp, r7
 801c8da:	bd80      	pop	{r7, pc}

0801c8dc <wc_ecc_mulmod_ex2>:
*/
int wc_ecc_mulmod_ex2(const mp_int* k, ecc_point* G, ecc_point* R, mp_int* a,
                      mp_int* modulus, mp_int* order, WC_RNG* rng, int map,
                      void* heap)
#if !defined(WOLFSSL_SP_MATH)
{
 801c8dc:	b590      	push	{r4, r7, lr}
 801c8de:	b091      	sub	sp, #68	@ 0x44
 801c8e0:	af04      	add	r7, sp, #16
 801c8e2:	60f8      	str	r0, [r7, #12]
 801c8e4:	60b9      	str	r1, [r7, #8]
 801c8e6:	607a      	str	r2, [r7, #4]
 801c8e8:	603b      	str	r3, [r7, #0]
#ifdef WOLFSSL_SMALL_STACK_CACHE
   ecc_key       key;
#endif
   mp_digit      mp;

   if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
 801c8ea:	68fb      	ldr	r3, [r7, #12]
 801c8ec:	2b00      	cmp	r3, #0
 801c8ee:	d008      	beq.n	801c902 <wc_ecc_mulmod_ex2+0x26>
 801c8f0:	68bb      	ldr	r3, [r7, #8]
 801c8f2:	2b00      	cmp	r3, #0
 801c8f4:	d005      	beq.n	801c902 <wc_ecc_mulmod_ex2+0x26>
 801c8f6:	687b      	ldr	r3, [r7, #4]
 801c8f8:	2b00      	cmp	r3, #0
 801c8fa:	d002      	beq.n	801c902 <wc_ecc_mulmod_ex2+0x26>
 801c8fc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c8fe:	2b00      	cmp	r3, #0
 801c900:	d102      	bne.n	801c908 <wc_ecc_mulmod_ex2+0x2c>
      return ECC_BAD_ARG_E;
 801c902:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801c906:	e096      	b.n	801ca36 <wc_ecc_mulmod_ex2+0x15a>
      }
   }
   else
#endif
   /* k can't have more bits than order */
   if (mp_count_bits(k) > mp_count_bits(order)) {
 801c908:	68f8      	ldr	r0, [r7, #12]
 801c90a:	f00a fad1 	bl	8026eb0 <mp_count_bits>
 801c90e:	4604      	mov	r4, r0
 801c910:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c912:	f00a facd 	bl	8026eb0 <mp_count_bits>
 801c916:	4603      	mov	r3, r0
 801c918:	429c      	cmp	r4, r3
 801c91a:	dd02      	ble.n	801c922 <wc_ecc_mulmod_ex2+0x46>
      WOLFSSL_MSG("Private key length is greater than order in bits.");
      return ECC_OUT_OF_RANGE_E;
 801c91c:	f06f 03d8 	mvn.w	r3, #216	@ 0xd8
 801c920:	e089      	b.n	801ca36 <wc_ecc_mulmod_ex2+0x15a>
   }

   /* init variables */
   tG = NULL;
 801c922:	2300      	movs	r3, #0
 801c924:	627b      	str	r3, [r7, #36]	@ 0x24
   XMEMSET(M, 0, sizeof(M));
 801c926:	f107 0318 	add.w	r3, r7, #24
 801c92a:	220c      	movs	r2, #12
 801c92c:	2100      	movs	r1, #0
 801c92e:	4618      	mov	r0, r3
 801c930:	f00c f978 	bl	8028c24 <memset>
      goto exit;
   R->key = &key;
#endif /* WOLFSSL_SMALL_STACK_CACHE */

   /* alloc ram for window temps */
   for (i = 0; i < M_POINTS; i++) {
 801c934:	2300      	movs	r3, #0
 801c936:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c938:	e00f      	b.n	801c95a <wc_ecc_mulmod_ex2+0x7e>
   #ifdef WOLFSSL_NO_MALLOC
      M[i] = &lcl_M[i];
   #endif
      err = wc_ecc_new_point_ex(&M[i], heap);
 801c93a:	f107 0218 	add.w	r2, r7, #24
 801c93e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c940:	009b      	lsls	r3, r3, #2
 801c942:	4413      	add	r3, r2
 801c944:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801c946:	4618      	mov	r0, r3
 801c948:	f000 f879 	bl	801ca3e <wc_ecc_new_point_ex>
 801c94c:	62b8      	str	r0, [r7, #40]	@ 0x28
      if (err != MP_OKAY) {
 801c94e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c950:	2b00      	cmp	r3, #0
 801c952:	d14e      	bne.n	801c9f2 <wc_ecc_mulmod_ex2+0x116>
   for (i = 0; i < M_POINTS; i++) {
 801c954:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c956:	3301      	adds	r3, #1
 801c958:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c95a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c95c:	2b02      	cmp	r3, #2
 801c95e:	ddec      	ble.n	801c93a <wc_ecc_mulmod_ex2+0x5e>

   /* make a copy of G in case R==G */
#ifdef WOLFSSL_NO_MALLOC
   tG = &lcl_tG;
#endif
   err = wc_ecc_new_point_ex(&tG, heap);
 801c960:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 801c964:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801c966:	4618      	mov	r0, r3
 801c968:	f000 f869 	bl	801ca3e <wc_ecc_new_point_ex>
 801c96c:	62b8      	str	r0, [r7, #40]	@ 0x28
   if (err != MP_OKAY) {
 801c96e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c970:	2b00      	cmp	r3, #0
 801c972:	d140      	bne.n	801c9f6 <wc_ecc_mulmod_ex2+0x11a>
       goto exit;
   }
   if ((err = ecc_point_to_mont(G, tG, modulus, heap)) != MP_OKAY) {
 801c974:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c976:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801c978:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801c97a:	68b8      	ldr	r0, [r7, #8]
 801c97c:	f7ff feaf 	bl	801c6de <ecc_point_to_mont>
 801c980:	62b8      	str	r0, [r7, #40]	@ 0x28
 801c982:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c984:	2b00      	cmp	r3, #0
 801c986:	d138      	bne.n	801c9fa <wc_ecc_mulmod_ex2+0x11e>
       goto exit;
   }

   /* init montgomery reduction */
   if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {
 801c988:	f107 0314 	add.w	r3, r7, #20
 801c98c:	4619      	mov	r1, r3
 801c98e:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801c990:	f00a fd00 	bl	8027394 <mp_montgomery_setup>
 801c994:	62b8      	str	r0, [r7, #40]	@ 0x28
 801c996:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c998:	2b00      	cmp	r3, #0
 801c99a:	d130      	bne.n	801c9fe <wc_ecc_mulmod_ex2+0x122>
      goto exit;
   }

   err = ecc_mulmod(k, tG, R, M, a, modulus, mp, rng);
 801c99c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c99e:	697b      	ldr	r3, [r7, #20]
 801c9a0:	f107 0018 	add.w	r0, r7, #24
 801c9a4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801c9a6:	9203      	str	r2, [sp, #12]
 801c9a8:	9302      	str	r3, [sp, #8]
 801c9aa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c9ac:	9301      	str	r3, [sp, #4]
 801c9ae:	683b      	ldr	r3, [r7, #0]
 801c9b0:	9300      	str	r3, [sp, #0]
 801c9b2:	4603      	mov	r3, r0
 801c9b4:	687a      	ldr	r2, [r7, #4]
 801c9b6:	68f8      	ldr	r0, [r7, #12]
 801c9b8:	f7ff fc08 	bl	801c1cc <ecc_mulmod>
 801c9bc:	62b8      	str	r0, [r7, #40]	@ 0x28
#ifdef ECC_TIMING_RESISTANT
   if (err == MP_OKAY) {
 801c9be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c9c0:	2b00      	cmp	r3, #0
 801c9c2:	d108      	bne.n	801c9d6 <wc_ecc_mulmod_ex2+0xfa>
       err = ecc_check_order_minus_1(k, tG, R, modulus, order);
 801c9c4:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c9c6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c9c8:	9300      	str	r3, [sp, #0]
 801c9ca:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c9cc:	687a      	ldr	r2, [r7, #4]
 801c9ce:	68f8      	ldr	r0, [r7, #12]
 801c9d0:	f7ff ff10 	bl	801c7f4 <ecc_check_order_minus_1>
 801c9d4:	62b8      	str	r0, [r7, #40]	@ 0x28
   }
#else
   (void)order;
#endif
   /* map R back from projective space */
   if (err == MP_OKAY && map)
 801c9d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c9d8:	2b00      	cmp	r3, #0
 801c9da:	d112      	bne.n	801ca02 <wc_ecc_mulmod_ex2+0x126>
 801c9dc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801c9de:	2b00      	cmp	r3, #0
 801c9e0:	d00f      	beq.n	801ca02 <wc_ecc_mulmod_ex2+0x126>
      err = ecc_map(R, modulus, mp);
 801c9e2:	697b      	ldr	r3, [r7, #20]
 801c9e4:	461a      	mov	r2, r3
 801c9e6:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 801c9e8:	6878      	ldr	r0, [r7, #4]
 801c9ea:	f7ff fb4f 	bl	801c08c <ecc_map>
 801c9ee:	62b8      	str	r0, [r7, #40]	@ 0x28
 801c9f0:	e008      	b.n	801ca04 <wc_ecc_mulmod_ex2+0x128>
         goto exit;
 801c9f2:	bf00      	nop
 801c9f4:	e006      	b.n	801ca04 <wc_ecc_mulmod_ex2+0x128>
       goto exit;
 801c9f6:	bf00      	nop
 801c9f8:	e004      	b.n	801ca04 <wc_ecc_mulmod_ex2+0x128>
       goto exit;
 801c9fa:	bf00      	nop
 801c9fc:	e002      	b.n	801ca04 <wc_ecc_mulmod_ex2+0x128>
      goto exit;
 801c9fe:	bf00      	nop
 801ca00:	e000      	b.n	801ca04 <wc_ecc_mulmod_ex2+0x128>

exit:
 801ca02:	bf00      	nop

   /* done */
   wc_ecc_del_point_ex(tG, heap);
 801ca04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ca06:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801ca08:	4618      	mov	r0, r3
 801ca0a:	f000 f86d 	bl	801cae8 <wc_ecc_del_point_ex>
   for (i = 0; i < M_POINTS; i++) {
 801ca0e:	2300      	movs	r3, #0
 801ca10:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801ca12:	e00c      	b.n	801ca2e <wc_ecc_mulmod_ex2+0x152>
      wc_ecc_del_point_ex(M[i], heap);
 801ca14:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ca16:	009b      	lsls	r3, r3, #2
 801ca18:	3330      	adds	r3, #48	@ 0x30
 801ca1a:	443b      	add	r3, r7
 801ca1c:	f853 3c18 	ldr.w	r3, [r3, #-24]
 801ca20:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801ca22:	4618      	mov	r0, r3
 801ca24:	f000 f860 	bl	801cae8 <wc_ecc_del_point_ex>
   for (i = 0; i < M_POINTS; i++) {
 801ca28:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ca2a:	3301      	adds	r3, #1
 801ca2c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801ca2e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ca30:	2b02      	cmp	r3, #2
 801ca32:	ddef      	ble.n	801ca14 <wc_ecc_mulmod_ex2+0x138>
#ifdef WOLFSSL_SMALL_STACK_CACHE
   R->key = NULL;
   ecc_key_tmp_final(&key, heap);
#endif /* WOLFSSL_SMALL_STACK_CACHE */

   return err;
 801ca34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
}
 801ca36:	4618      	mov	r0, r3
 801ca38:	3734      	adds	r7, #52	@ 0x34
 801ca3a:	46bd      	mov	sp, r7
 801ca3c:	bd90      	pop	{r4, r7, pc}

0801ca3e <wc_ecc_new_point_ex>:
 * Allocate a new ECC point (if one not provided)
 * use a heap hint when creating new ecc_point
 * return an allocated point on success or NULL on failure
*/
static int wc_ecc_new_point_ex(ecc_point** point, void* heap)
{
 801ca3e:	b580      	push	{r7, lr}
 801ca40:	b084      	sub	sp, #16
 801ca42:	af00      	add	r7, sp, #0
 801ca44:	6078      	str	r0, [r7, #4]
 801ca46:	6039      	str	r1, [r7, #0]
   int err = MP_OKAY;
 801ca48:	2300      	movs	r3, #0
 801ca4a:	60bb      	str	r3, [r7, #8]
   ecc_point* p;

   if (point == NULL) {
 801ca4c:	687b      	ldr	r3, [r7, #4]
 801ca4e:	2b00      	cmp	r3, #0
 801ca50:	d102      	bne.n	801ca58 <wc_ecc_new_point_ex+0x1a>
       return BAD_FUNC_ARG;
 801ca52:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801ca56:	e043      	b.n	801cae0 <wc_ecc_new_point_ex+0xa2>
   }

   p = *point;
 801ca58:	687b      	ldr	r3, [r7, #4]
 801ca5a:	681b      	ldr	r3, [r3, #0]
 801ca5c:	60fb      	str	r3, [r7, #12]
   if (p == NULL) {
 801ca5e:	68fb      	ldr	r3, [r7, #12]
 801ca60:	2b00      	cmp	r3, #0
 801ca62:	d104      	bne.n	801ca6e <wc_ecc_new_point_ex+0x30>
      p = (ecc_point*)XMALLOC(sizeof(ecc_point), heap, DYNAMIC_TYPE_ECC);
 801ca64:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801ca68:	f002 f908 	bl	801ec7c <wolfSSL_Malloc>
 801ca6c:	60f8      	str	r0, [r7, #12]
   }
   if (p == NULL) {
 801ca6e:	68fb      	ldr	r3, [r7, #12]
 801ca70:	2b00      	cmp	r3, #0
 801ca72:	d102      	bne.n	801ca7a <wc_ecc_new_point_ex+0x3c>
      return MEMORY_E;
 801ca74:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801ca78:	e032      	b.n	801cae0 <wc_ecc_new_point_ex+0xa2>
   }
   XMEMSET(p, 0, sizeof(ecc_point));
 801ca7a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801ca7e:	2100      	movs	r1, #0
 801ca80:	68f8      	ldr	r0, [r7, #12]
 801ca82:	f00c f8cf 	bl	8028c24 <memset>

   if (*point == NULL)
 801ca86:	687b      	ldr	r3, [r7, #4]
 801ca88:	681b      	ldr	r3, [r3, #0]
 801ca8a:	2b00      	cmp	r3, #0
 801ca8c:	d106      	bne.n	801ca9c <wc_ecc_new_point_ex+0x5e>
       p->isAllocated = 1;
 801ca8e:	68fa      	ldr	r2, [r7, #12]
 801ca90:	f892 30fc 	ldrb.w	r3, [r2, #252]	@ 0xfc
 801ca94:	f043 0301 	orr.w	r3, r3, #1
 801ca98:	f882 30fc 	strb.w	r3, [r2, #252]	@ 0xfc
      if (p->isAllocated)
          XFREE(p, heap, DYNAMIC_TYPE_ECC);
      p = NULL;
   }
#else
   p->x = (mp_int*)&p->xyz[0];
 801ca9c:	68fb      	ldr	r3, [r7, #12]
 801ca9e:	f103 020c 	add.w	r2, r3, #12
 801caa2:	68fb      	ldr	r3, [r7, #12]
 801caa4:	601a      	str	r2, [r3, #0]
   p->y = (mp_int*)&p->xyz[1];
 801caa6:	68fb      	ldr	r3, [r7, #12]
 801caa8:	f103 025c 	add.w	r2, r3, #92	@ 0x5c
 801caac:	68fb      	ldr	r3, [r7, #12]
 801caae:	605a      	str	r2, [r3, #4]
   p->z = (mp_int*)&p->xyz[2];
 801cab0:	68fb      	ldr	r3, [r7, #12]
 801cab2:	f103 02ac 	add.w	r2, r3, #172	@ 0xac
 801cab6:	68fb      	ldr	r3, [r7, #12]
 801cab8:	609a      	str	r2, [r3, #8]
   alt_fp_init(p->x);
 801caba:	68fb      	ldr	r3, [r7, #12]
 801cabc:	681b      	ldr	r3, [r3, #0]
 801cabe:	4618      	mov	r0, r3
 801cac0:	f7fe f916 	bl	801acf0 <alt_fp_init>
   alt_fp_init(p->y);
 801cac4:	68fb      	ldr	r3, [r7, #12]
 801cac6:	685b      	ldr	r3, [r3, #4]
 801cac8:	4618      	mov	r0, r3
 801caca:	f7fe f911 	bl	801acf0 <alt_fp_init>
   alt_fp_init(p->z);
 801cace:	68fb      	ldr	r3, [r7, #12]
 801cad0:	689b      	ldr	r3, [r3, #8]
 801cad2:	4618      	mov	r0, r3
 801cad4:	f7fe f90c 	bl	801acf0 <alt_fp_init>
#endif

   *point = p;
 801cad8:	687b      	ldr	r3, [r7, #4]
 801cada:	68fa      	ldr	r2, [r7, #12]
 801cadc:	601a      	str	r2, [r3, #0]
   (void)heap;
   return err;
 801cade:	68bb      	ldr	r3, [r7, #8]
} /* wc_ecc_new_point_ex */
 801cae0:	4618      	mov	r0, r3
 801cae2:	3710      	adds	r7, #16
 801cae4:	46bd      	mov	sp, r7
 801cae6:	bd80      	pop	{r7, pc}

0801cae8 <wc_ecc_del_point_ex>:

/** Free an ECC point from memory
  p   The point to free
*/
static void wc_ecc_del_point_ex(ecc_point* p, void* heap)
{
 801cae8:	b580      	push	{r7, lr}
 801caea:	b084      	sub	sp, #16
 801caec:	af00      	add	r7, sp, #0
 801caee:	6078      	str	r0, [r7, #4]
 801caf0:	6039      	str	r1, [r7, #0]
   if (p != NULL) {
 801caf2:	687b      	ldr	r3, [r7, #4]
 801caf4:	2b00      	cmp	r3, #0
 801caf6:	d01e      	beq.n	801cb36 <wc_ecc_del_point_ex+0x4e>
      mp_clear(p->x);
 801caf8:	687b      	ldr	r3, [r7, #4]
 801cafa:	681b      	ldr	r3, [r3, #0]
 801cafc:	4618      	mov	r0, r3
 801cafe:	f009 fff6 	bl	8026aee <mp_clear>
      mp_clear(p->y);
 801cb02:	687b      	ldr	r3, [r7, #4]
 801cb04:	685b      	ldr	r3, [r3, #4]
 801cb06:	4618      	mov	r0, r3
 801cb08:	f009 fff1 	bl	8026aee <mp_clear>
      mp_clear(p->z);
 801cb0c:	687b      	ldr	r3, [r7, #4]
 801cb0e:	689b      	ldr	r3, [r3, #8]
 801cb10:	4618      	mov	r0, r3
 801cb12:	f009 ffec 	bl	8026aee <mp_clear>
      if (p->isAllocated)
 801cb16:	687b      	ldr	r3, [r7, #4]
 801cb18:	f893 30fc 	ldrb.w	r3, [r3, #252]	@ 0xfc
 801cb1c:	f003 0301 	and.w	r3, r3, #1
 801cb20:	b2db      	uxtb	r3, r3
 801cb22:	2b00      	cmp	r3, #0
 801cb24:	d007      	beq.n	801cb36 <wc_ecc_del_point_ex+0x4e>
          XFREE(p, heap, DYNAMIC_TYPE_ECC);
 801cb26:	687b      	ldr	r3, [r7, #4]
 801cb28:	60fb      	str	r3, [r7, #12]
 801cb2a:	68fb      	ldr	r3, [r7, #12]
 801cb2c:	2b00      	cmp	r3, #0
 801cb2e:	d002      	beq.n	801cb36 <wc_ecc_del_point_ex+0x4e>
 801cb30:	68f8      	ldr	r0, [r7, #12]
 801cb32:	f002 f8bf 	bl	801ecb4 <wolfSSL_Free>
   }
   (void)heap;
}
 801cb36:	bf00      	nop
 801cb38:	3710      	adds	r7, #16
 801cb3a:	46bd      	mov	sp, r7
 801cb3c:	bd80      	pop	{r7, pc}

0801cb3e <wc_ecc_del_point>:
void wc_ecc_del_point_h(ecc_point* p, void* heap)
{
   wc_ecc_del_point_ex(p, heap);
}
void wc_ecc_del_point(ecc_point* p)
{
 801cb3e:	b580      	push	{r7, lr}
 801cb40:	b082      	sub	sp, #8
 801cb42:	af00      	add	r7, sp, #0
 801cb44:	6078      	str	r0, [r7, #4]
    wc_ecc_del_point_ex(p, NULL);
 801cb46:	2100      	movs	r1, #0
 801cb48:	6878      	ldr	r0, [r7, #4]
 801cb4a:	f7ff ffcd 	bl	801cae8 <wc_ecc_del_point_ex>
}
 801cb4e:	bf00      	nop
 801cb50:	3708      	adds	r7, #8
 801cb52:	46bd      	mov	sp, r7
 801cb54:	bd80      	pop	{r7, pc}

0801cb56 <wc_ecc_copy_point>:
/** Copy the value of a point to an other one
  p    The point to copy
  r    The created point
*/
int wc_ecc_copy_point(const ecc_point* p, ecc_point *r)
{
 801cb56:	b580      	push	{r7, lr}
 801cb58:	b084      	sub	sp, #16
 801cb5a:	af00      	add	r7, sp, #0
 801cb5c:	6078      	str	r0, [r7, #4]
 801cb5e:	6039      	str	r1, [r7, #0]
    int ret;

    /* prevents null arguments */
    if (p == NULL || r == NULL)
 801cb60:	687b      	ldr	r3, [r7, #4]
 801cb62:	2b00      	cmp	r3, #0
 801cb64:	d002      	beq.n	801cb6c <wc_ecc_copy_point+0x16>
 801cb66:	683b      	ldr	r3, [r7, #0]
 801cb68:	2b00      	cmp	r3, #0
 801cb6a:	d102      	bne.n	801cb72 <wc_ecc_copy_point+0x1c>
        return ECC_BAD_ARG_E;
 801cb6c:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801cb70:	e02a      	b.n	801cbc8 <wc_ecc_copy_point+0x72>

    ret = mp_copy(p->x, r->x);
 801cb72:	687b      	ldr	r3, [r7, #4]
 801cb74:	681a      	ldr	r2, [r3, #0]
 801cb76:	683b      	ldr	r3, [r7, #0]
 801cb78:	681b      	ldr	r3, [r3, #0]
 801cb7a:	4619      	mov	r1, r3
 801cb7c:	4610      	mov	r0, r2
 801cb7e:	f00a f978 	bl	8026e72 <mp_copy>
 801cb82:	60f8      	str	r0, [r7, #12]
    if (ret != MP_OKAY)
 801cb84:	68fb      	ldr	r3, [r7, #12]
 801cb86:	2b00      	cmp	r3, #0
 801cb88:	d001      	beq.n	801cb8e <wc_ecc_copy_point+0x38>
        return ret;
 801cb8a:	68fb      	ldr	r3, [r7, #12]
 801cb8c:	e01c      	b.n	801cbc8 <wc_ecc_copy_point+0x72>
    ret = mp_copy(p->y, r->y);
 801cb8e:	687b      	ldr	r3, [r7, #4]
 801cb90:	685a      	ldr	r2, [r3, #4]
 801cb92:	683b      	ldr	r3, [r7, #0]
 801cb94:	685b      	ldr	r3, [r3, #4]
 801cb96:	4619      	mov	r1, r3
 801cb98:	4610      	mov	r0, r2
 801cb9a:	f00a f96a 	bl	8026e72 <mp_copy>
 801cb9e:	60f8      	str	r0, [r7, #12]
    if (ret != MP_OKAY)
 801cba0:	68fb      	ldr	r3, [r7, #12]
 801cba2:	2b00      	cmp	r3, #0
 801cba4:	d001      	beq.n	801cbaa <wc_ecc_copy_point+0x54>
        return ret;
 801cba6:	68fb      	ldr	r3, [r7, #12]
 801cba8:	e00e      	b.n	801cbc8 <wc_ecc_copy_point+0x72>
    ret = mp_copy(p->z, r->z);
 801cbaa:	687b      	ldr	r3, [r7, #4]
 801cbac:	689a      	ldr	r2, [r3, #8]
 801cbae:	683b      	ldr	r3, [r7, #0]
 801cbb0:	689b      	ldr	r3, [r3, #8]
 801cbb2:	4619      	mov	r1, r3
 801cbb4:	4610      	mov	r0, r2
 801cbb6:	f00a f95c 	bl	8026e72 <mp_copy>
 801cbba:	60f8      	str	r0, [r7, #12]
    if (ret != MP_OKAY)
 801cbbc:	68fb      	ldr	r3, [r7, #12]
 801cbbe:	2b00      	cmp	r3, #0
 801cbc0:	d001      	beq.n	801cbc6 <wc_ecc_copy_point+0x70>
        return ret;
 801cbc2:	68fb      	ldr	r3, [r7, #12]
 801cbc4:	e000      	b.n	801cbc8 <wc_ecc_copy_point+0x72>

    return MP_OKAY;
 801cbc6:	2300      	movs	r3, #0
}
 801cbc8:	4618      	mov	r0, r3
 801cbca:	3710      	adds	r7, #16
 801cbcc:	46bd      	mov	sp, r7
 801cbce:	bd80      	pop	{r7, pc}

0801cbd0 <wc_ecc_is_valid_idx>:
/** Returns whether an ECC idx is valid or not
  n      The idx number to check
  return 1 if valid, 0 if not
*/
int wc_ecc_is_valid_idx(int n)
{
 801cbd0:	b480      	push	{r7}
 801cbd2:	b085      	sub	sp, #20
 801cbd4:	af00      	add	r7, sp, #0
 801cbd6:	6078      	str	r0, [r7, #4]
   int x;

   if (n >= (int)ECC_SET_COUNT)
 801cbd8:	687b      	ldr	r3, [r7, #4]
 801cbda:	2b01      	cmp	r3, #1
 801cbdc:	dd01      	ble.n	801cbe2 <wc_ecc_is_valid_idx+0x12>
       return 0;
 801cbde:	2300      	movs	r3, #0
 801cbe0:	e019      	b.n	801cc16 <wc_ecc_is_valid_idx+0x46>

   for (x = 0; ecc_sets[x].size != 0; x++)
 801cbe2:	2300      	movs	r3, #0
 801cbe4:	60fb      	str	r3, [r7, #12]
 801cbe6:	e002      	b.n	801cbee <wc_ecc_is_valid_idx+0x1e>
 801cbe8:	68fb      	ldr	r3, [r7, #12]
 801cbea:	3301      	adds	r3, #1
 801cbec:	60fb      	str	r3, [r7, #12]
 801cbee:	4a0d      	ldr	r2, [pc, #52]	@ (801cc24 <wc_ecc_is_valid_idx+0x54>)
 801cbf0:	68fb      	ldr	r3, [r7, #12]
 801cbf2:	2134      	movs	r1, #52	@ 0x34
 801cbf4:	fb01 f303 	mul.w	r3, r1, r3
 801cbf8:	4413      	add	r3, r2
 801cbfa:	681b      	ldr	r3, [r3, #0]
 801cbfc:	2b00      	cmp	r3, #0
 801cbfe:	d1f3      	bne.n	801cbe8 <wc_ecc_is_valid_idx+0x18>
       ;
   /* -1 is a valid index --- indicating that the domain params
      were supplied by the user */
   if ((n >= ECC_CUSTOM_IDX) && (n < x)) {
 801cc00:	687b      	ldr	r3, [r7, #4]
 801cc02:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801cc06:	db05      	blt.n	801cc14 <wc_ecc_is_valid_idx+0x44>
 801cc08:	687a      	ldr	r2, [r7, #4]
 801cc0a:	68fb      	ldr	r3, [r7, #12]
 801cc0c:	429a      	cmp	r2, r3
 801cc0e:	da01      	bge.n	801cc14 <wc_ecc_is_valid_idx+0x44>
      return 1;
 801cc10:	2301      	movs	r3, #1
 801cc12:	e000      	b.n	801cc16 <wc_ecc_is_valid_idx+0x46>
   }

   return 0;
 801cc14:	2300      	movs	r3, #0
}
 801cc16:	4618      	mov	r0, r3
 801cc18:	3714      	adds	r7, #20
 801cc1a:	46bd      	mov	sp, r7
 801cc1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cc20:	4770      	bx	lr
 801cc22:	bf00      	nop
 801cc24:	08034908 	.word	0x08034908

0801cc28 <wc_ecc_get_curve_idx>:

int wc_ecc_get_curve_idx(int curve_id)
{
 801cc28:	b480      	push	{r7}
 801cc2a:	b085      	sub	sp, #20
 801cc2c:	af00      	add	r7, sp, #0
 801cc2e:	6078      	str	r0, [r7, #4]
    int curve_idx;
    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 801cc30:	2300      	movs	r3, #0
 801cc32:	60fb      	str	r3, [r7, #12]
 801cc34:	e00d      	b.n	801cc52 <wc_ecc_get_curve_idx+0x2a>
        if (curve_id == ecc_sets[curve_idx].id)
 801cc36:	4a16      	ldr	r2, [pc, #88]	@ (801cc90 <wc_ecc_get_curve_idx+0x68>)
 801cc38:	68fb      	ldr	r3, [r7, #12]
 801cc3a:	2134      	movs	r1, #52	@ 0x34
 801cc3c:	fb01 f303 	mul.w	r3, r1, r3
 801cc40:	4413      	add	r3, r2
 801cc42:	3304      	adds	r3, #4
 801cc44:	681b      	ldr	r3, [r3, #0]
 801cc46:	687a      	ldr	r2, [r7, #4]
 801cc48:	429a      	cmp	r2, r3
 801cc4a:	d00c      	beq.n	801cc66 <wc_ecc_get_curve_idx+0x3e>
    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 801cc4c:	68fb      	ldr	r3, [r7, #12]
 801cc4e:	3301      	adds	r3, #1
 801cc50:	60fb      	str	r3, [r7, #12]
 801cc52:	4a0f      	ldr	r2, [pc, #60]	@ (801cc90 <wc_ecc_get_curve_idx+0x68>)
 801cc54:	68fb      	ldr	r3, [r7, #12]
 801cc56:	2134      	movs	r1, #52	@ 0x34
 801cc58:	fb01 f303 	mul.w	r3, r1, r3
 801cc5c:	4413      	add	r3, r2
 801cc5e:	681b      	ldr	r3, [r3, #0]
 801cc60:	2b00      	cmp	r3, #0
 801cc62:	d1e8      	bne.n	801cc36 <wc_ecc_get_curve_idx+0xe>
 801cc64:	e000      	b.n	801cc68 <wc_ecc_get_curve_idx+0x40>
            break;
 801cc66:	bf00      	nop
    }
    if (ecc_sets[curve_idx].size == 0) {
 801cc68:	4a09      	ldr	r2, [pc, #36]	@ (801cc90 <wc_ecc_get_curve_idx+0x68>)
 801cc6a:	68fb      	ldr	r3, [r7, #12]
 801cc6c:	2134      	movs	r1, #52	@ 0x34
 801cc6e:	fb01 f303 	mul.w	r3, r1, r3
 801cc72:	4413      	add	r3, r2
 801cc74:	681b      	ldr	r3, [r3, #0]
 801cc76:	2b00      	cmp	r3, #0
 801cc78:	d102      	bne.n	801cc80 <wc_ecc_get_curve_idx+0x58>
        return ECC_CURVE_INVALID;
 801cc7a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801cc7e:	e000      	b.n	801cc82 <wc_ecc_get_curve_idx+0x5a>
    }
    return curve_idx;
 801cc80:	68fb      	ldr	r3, [r7, #12]
}
 801cc82:	4618      	mov	r0, r3
 801cc84:	3714      	adds	r7, #20
 801cc86:	46bd      	mov	sp, r7
 801cc88:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cc8c:	4770      	bx	lr
 801cc8e:	bf00      	nop
 801cc90:	08034908 	.word	0x08034908

0801cc94 <wc_ecc_get_curve_size_from_id>:
 *
 * id      curve id, from ecc_curve_id enum in ecc.h
 * return  curve size, from ecc_sets[] on success, negative on error
 */
int wc_ecc_get_curve_size_from_id(int curve_id)
{
 801cc94:	b580      	push	{r7, lr}
 801cc96:	b084      	sub	sp, #16
 801cc98:	af00      	add	r7, sp, #0
 801cc9a:	6078      	str	r0, [r7, #4]
    int curve_idx = wc_ecc_get_curve_idx(curve_id);
 801cc9c:	6878      	ldr	r0, [r7, #4]
 801cc9e:	f7ff ffc3 	bl	801cc28 <wc_ecc_get_curve_idx>
 801cca2:	60f8      	str	r0, [r7, #12]
    if (curve_idx == ECC_CURVE_INVALID)
 801cca4:	68fb      	ldr	r3, [r7, #12]
 801cca6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801ccaa:	d102      	bne.n	801ccb2 <wc_ecc_get_curve_size_from_id+0x1e>
        return ECC_BAD_ARG_E;
 801ccac:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801ccb0:	e006      	b.n	801ccc0 <wc_ecc_get_curve_size_from_id+0x2c>
    return ecc_sets[curve_idx].size;
 801ccb2:	4a05      	ldr	r2, [pc, #20]	@ (801ccc8 <wc_ecc_get_curve_size_from_id+0x34>)
 801ccb4:	68fb      	ldr	r3, [r7, #12]
 801ccb6:	2134      	movs	r1, #52	@ 0x34
 801ccb8:	fb01 f303 	mul.w	r3, r1, r3
 801ccbc:	4413      	add	r3, r2
 801ccbe:	681b      	ldr	r3, [r3, #0]
}
 801ccc0:	4618      	mov	r0, r3
 801ccc2:	3710      	adds	r7, #16
 801ccc4:	46bd      	mov	sp, r7
 801ccc6:	bd80      	pop	{r7, pc}
 801ccc8:	08034908 	.word	0x08034908

0801cccc <wc_ecc_gen_k>:
}
#endif

/* generate random and ensure its greater than 0 and less than order */
int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)
{
 801cccc:	b580      	push	{r7, lr}
 801ccce:	b098      	sub	sp, #96	@ 0x60
 801ccd0:	af00      	add	r7, sp, #0
 801ccd2:	60f8      	str	r0, [r7, #12]
 801ccd4:	60b9      	str	r1, [r7, #8]
 801ccd6:	607a      	str	r2, [r7, #4]
 801ccd8:	603b      	str	r3, [r7, #0]
#ifndef WC_NO_RNG
#ifndef WOLFSSL_ECC_GEN_REJECT_SAMPLING
    int err;
    byte buf[ECC_MAXSIZE_GEN];

    if (rng == NULL || size < 0 || size + 8 > ECC_MAXSIZE_GEN || k == NULL ||
 801ccda:	68fb      	ldr	r3, [r7, #12]
 801ccdc:	2b00      	cmp	r3, #0
 801ccde:	d00b      	beq.n	801ccf8 <wc_ecc_gen_k+0x2c>
 801cce0:	68bb      	ldr	r3, [r7, #8]
 801cce2:	2b00      	cmp	r3, #0
 801cce4:	db08      	blt.n	801ccf8 <wc_ecc_gen_k+0x2c>
 801cce6:	68bb      	ldr	r3, [r7, #8]
 801cce8:	2b42      	cmp	r3, #66	@ 0x42
 801ccea:	dc05      	bgt.n	801ccf8 <wc_ecc_gen_k+0x2c>
 801ccec:	687b      	ldr	r3, [r7, #4]
 801ccee:	2b00      	cmp	r3, #0
 801ccf0:	d002      	beq.n	801ccf8 <wc_ecc_gen_k+0x2c>
 801ccf2:	683b      	ldr	r3, [r7, #0]
 801ccf4:	2b00      	cmp	r3, #0
 801ccf6:	d102      	bne.n	801ccfe <wc_ecc_gen_k+0x32>
                                                                order == NULL) {
        return BAD_FUNC_ARG;
 801ccf8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801ccfc:	e039      	b.n	801cd72 <wc_ecc_gen_k+0xa6>
    }

    /* generate 8 extra bytes to mitigate bias from the modulo operation below */
    /* see section A.1.2 in 'Suite B Implementor's Guide to FIPS 186-3 (ECDSA)' */
    size += 8;
 801ccfe:	68bb      	ldr	r3, [r7, #8]
 801cd00:	3308      	adds	r3, #8
 801cd02:	60bb      	str	r3, [r7, #8]

    /* make up random string */
    err = wc_RNG_GenerateBlock(rng, buf, (word32)size);
 801cd04:	68ba      	ldr	r2, [r7, #8]
 801cd06:	f107 0310 	add.w	r3, r7, #16
 801cd0a:	4619      	mov	r1, r3
 801cd0c:	68f8      	ldr	r0, [r7, #12]
 801cd0e:	f002 fd3c 	bl	801f78a <wc_RNG_GenerateBlock>
 801cd12:	65f8      	str	r0, [r7, #92]	@ 0x5c
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Add("wc_ecc_gen_k buf", buf, size);
#endif

    /* load random buffer data into k */
    if (err == 0)
 801cd14:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801cd16:	2b00      	cmp	r3, #0
 801cd18:	d107      	bne.n	801cd2a <wc_ecc_gen_k+0x5e>
        err = mp_read_unsigned_bin(k, buf, (word32)size);
 801cd1a:	f107 0310 	add.w	r3, r7, #16
 801cd1e:	68ba      	ldr	r2, [r7, #8]
 801cd20:	4619      	mov	r1, r3
 801cd22:	6878      	ldr	r0, [r7, #4]
 801cd24:	f00a f832 	bl	8026d8c <mp_read_unsigned_bin>
 801cd28:	65f8      	str	r0, [r7, #92]	@ 0x5c

    /* the key should be smaller than the order of base point */
    if (err == MP_OKAY) {
 801cd2a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801cd2c:	2b00      	cmp	r3, #0
 801cd2e:	d10d      	bne.n	801cd4c <wc_ecc_gen_k+0x80>
        if (mp_cmp(k, order) != MP_LT) {
 801cd30:	6839      	ldr	r1, [r7, #0]
 801cd32:	6878      	ldr	r0, [r7, #4]
 801cd34:	f009 ffe4 	bl	8026d00 <mp_cmp>
 801cd38:	4603      	mov	r3, r0
 801cd3a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801cd3e:	d005      	beq.n	801cd4c <wc_ecc_gen_k+0x80>
            err = mp_mod(k, order, k);
 801cd40:	687a      	ldr	r2, [r7, #4]
 801cd42:	6839      	ldr	r1, [r7, #0]
 801cd44:	6878      	ldr	r0, [r7, #4]
 801cd46:	f009 ff85 	bl	8026c54 <mp_mod>
 801cd4a:	65f8      	str	r0, [r7, #92]	@ 0x5c
        }
    }

    /* quick sanity check to make sure we're not dealing with a 0 key */
    if (err == MP_OKAY) {
 801cd4c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801cd4e:	2b00      	cmp	r3, #0
 801cd50:	d108      	bne.n	801cd64 <wc_ecc_gen_k+0x98>
        if (mp_iszero(k) == MP_YES)
 801cd52:	6878      	ldr	r0, [r7, #4]
 801cd54:	f00a f89b 	bl	8026e8e <mp_iszero>
 801cd58:	4603      	mov	r3, r0
 801cd5a:	2b01      	cmp	r3, #1
 801cd5c:	d102      	bne.n	801cd64 <wc_ecc_gen_k+0x98>
          err = MP_ZERO_E;
 801cd5e:	f06f 0378 	mvn.w	r3, #120	@ 0x78
 801cd62:	65fb      	str	r3, [r7, #92]	@ 0x5c
    }

    ForceZero(buf, ECC_MAXSIZE_GEN);
 801cd64:	f107 0310 	add.w	r3, r7, #16
 801cd68:	214a      	movs	r1, #74	@ 0x4a
 801cd6a:	4618      	mov	r0, r3
 801cd6c:	f7fd fdbe 	bl	801a8ec <ForceZero>
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(buf, ECC_MAXSIZE_GEN);
#endif

    return err;
 801cd70:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    (void)size;
    (void)k;
    (void)order;
    return NOT_COMPILED_IN;
#endif /* !WC_NO_RNG */
}
 801cd72:	4618      	mov	r0, r3
 801cd74:	3760      	adds	r7, #96	@ 0x60
 801cd76:	46bd      	mov	sp, r7
 801cd78:	bd80      	pop	{r7, pc}

0801cd7a <wc_ecc_reset>:

static WC_INLINE void wc_ecc_reset(ecc_key* key)
{
 801cd7a:	b480      	push	{r7}
 801cd7c:	b083      	sub	sp, #12
 801cd7e:	af00      	add	r7, sp, #0
 801cd80:	6078      	str	r0, [r7, #4]
    /* make sure required key variables are reset */
    key->state = ECC_STATE_NONE;
 801cd82:	687b      	ldr	r3, [r7, #4]
 801cd84:	2200      	movs	r2, #0
 801cd86:	609a      	str	r2, [r3, #8]
}
 801cd88:	bf00      	nop
 801cd8a:	370c      	adds	r7, #12
 801cd8c:	46bd      	mov	sp, r7
 801cd8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cd92:	4770      	bx	lr

0801cd94 <ecc_make_pub_ex>:
 *
 * returns MP_OKAY on success
 */
static int ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curve,
        ecc_point* pubOut, WC_RNG* rng)
{
 801cd94:	b5b0      	push	{r4, r5, r7, lr}
 801cd96:	b08e      	sub	sp, #56	@ 0x38
 801cd98:	af06      	add	r7, sp, #24
 801cd9a:	60f8      	str	r0, [r7, #12]
 801cd9c:	60b9      	str	r1, [r7, #8]
 801cd9e:	607a      	str	r2, [r7, #4]
 801cda0:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801cda2:	2300      	movs	r3, #0
 801cda4:	61fb      	str	r3, [r7, #28]
    ecc_point* pub;
#endif /* HAVE_ECC_MAKE_PUB */

    (void)rng;

    if (key == NULL) {
 801cda6:	68fb      	ldr	r3, [r7, #12]
 801cda8:	2b00      	cmp	r3, #0
 801cdaa:	d102      	bne.n	801cdb2 <ecc_make_pub_ex+0x1e>
        return BAD_FUNC_ARG;
 801cdac:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801cdb0:	e0cc      	b.n	801cf4c <ecc_make_pub_ex+0x1b8>

    SAVE_VECTOR_REGISTERS(return _svr_ret;);

#ifdef HAVE_ECC_MAKE_PUB
    /* if ecc_point passed in then use it as output for public key point */
    if (pubOut != NULL) {
 801cdb2:	687b      	ldr	r3, [r7, #4]
 801cdb4:	2b00      	cmp	r3, #0
 801cdb6:	d002      	beq.n	801cdbe <ecc_make_pub_ex+0x2a>
        pub = pubOut;
 801cdb8:	687b      	ldr	r3, [r7, #4]
 801cdba:	61bb      	str	r3, [r7, #24]
 801cdbc:	e005      	b.n	801cdca <ecc_make_pub_ex+0x36>
    }
    else {
        /* caching public key making it a ECC_PRIVATEKEY instead of
           ECC_PRIVATEKEY_ONLY */
        pub = &key->pubkey;
 801cdbe:	68fb      	ldr	r3, [r7, #12]
 801cdc0:	3318      	adds	r3, #24
 801cdc2:	61bb      	str	r3, [r7, #24]
        key->type = ECC_PRIVATEKEY_ONLY;
 801cdc4:	68fb      	ldr	r3, [r7, #12]
 801cdc6:	2203      	movs	r2, #3
 801cdc8:	601a      	str	r2, [r3, #0]
    }

    if ((err == MP_OKAY) && (mp_iszero(ecc_get_k(key)) ||
 801cdca:	69fb      	ldr	r3, [r7, #28]
 801cdcc:	2b00      	cmp	r3, #0
 801cdce:	d11e      	bne.n	801ce0e <ecc_make_pub_ex+0x7a>
 801cdd0:	68fb      	ldr	r3, [r7, #12]
 801cdd2:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cdd6:	4618      	mov	r0, r3
 801cdd8:	f00a f859 	bl	8026e8e <mp_iszero>
 801cddc:	4603      	mov	r3, r0
 801cdde:	2b00      	cmp	r3, #0
 801cde0:	d112      	bne.n	801ce08 <ecc_make_pub_ex+0x74>
            mp_isneg(ecc_get_k(key)) ||
 801cde2:	68fb      	ldr	r3, [r7, #12]
 801cde4:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cde8:	685b      	ldr	r3, [r3, #4]
    if ((err == MP_OKAY) && (mp_iszero(ecc_get_k(key)) ||
 801cdea:	2b00      	cmp	r3, #0
 801cdec:	d10c      	bne.n	801ce08 <ecc_make_pub_ex+0x74>
            (mp_cmp(ecc_get_k(key), curve->order) != MP_LT))) {
 801cdee:	68fb      	ldr	r3, [r7, #12]
 801cdf0:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 801cdf4:	68bb      	ldr	r3, [r7, #8]
 801cdf6:	691b      	ldr	r3, [r3, #16]
 801cdf8:	4619      	mov	r1, r3
 801cdfa:	4610      	mov	r0, r2
 801cdfc:	f009 ff80 	bl	8026d00 <mp_cmp>
 801ce00:	4603      	mov	r3, r0
            mp_isneg(ecc_get_k(key)) ||
 801ce02:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801ce06:	d002      	beq.n	801ce0e <ecc_make_pub_ex+0x7a>
        err = ECC_PRIV_KEY_E;
 801ce08:	f06f 03d7 	mvn.w	r3, #215	@ 0xd7
 801ce0c:	61fb      	str	r3, [r7, #28]
    }

    if (err == MP_OKAY) {
 801ce0e:	69fb      	ldr	r3, [r7, #28]
 801ce10:	2b00      	cmp	r3, #0
 801ce12:	d11d      	bne.n	801ce50 <ecc_make_pub_ex+0xbc>
    #ifndef ALT_ECC_SIZE
        err = mp_init_multi(pub->x, pub->y, pub->z, NULL, NULL, NULL);
    #else
        pub->x = (mp_int*)&pub->xyz[0];
 801ce14:	69bb      	ldr	r3, [r7, #24]
 801ce16:	f103 020c 	add.w	r2, r3, #12
 801ce1a:	69bb      	ldr	r3, [r7, #24]
 801ce1c:	601a      	str	r2, [r3, #0]
        pub->y = (mp_int*)&pub->xyz[1];
 801ce1e:	69bb      	ldr	r3, [r7, #24]
 801ce20:	f103 025c 	add.w	r2, r3, #92	@ 0x5c
 801ce24:	69bb      	ldr	r3, [r7, #24]
 801ce26:	605a      	str	r2, [r3, #4]
        pub->z = (mp_int*)&pub->xyz[2];
 801ce28:	69bb      	ldr	r3, [r7, #24]
 801ce2a:	f103 02ac 	add.w	r2, r3, #172	@ 0xac
 801ce2e:	69bb      	ldr	r3, [r7, #24]
 801ce30:	609a      	str	r2, [r3, #8]
        alt_fp_init(pub->x);
 801ce32:	69bb      	ldr	r3, [r7, #24]
 801ce34:	681b      	ldr	r3, [r3, #0]
 801ce36:	4618      	mov	r0, r3
 801ce38:	f7fd ff5a 	bl	801acf0 <alt_fp_init>
        alt_fp_init(pub->y);
 801ce3c:	69bb      	ldr	r3, [r7, #24]
 801ce3e:	685b      	ldr	r3, [r3, #4]
 801ce40:	4618      	mov	r0, r3
 801ce42:	f7fd ff55 	bl	801acf0 <alt_fp_init>
        alt_fp_init(pub->z);
 801ce46:	69bb      	ldr	r3, [r7, #24]
 801ce48:	689b      	ldr	r3, [r3, #8]
 801ce4a:	4618      	mov	r0, r3
 801ce4c:	f7fd ff50 	bl	801acf0 <alt_fp_init>
#endif /* WOLFSSL_HAVE_SP_ECC */

#if defined(WOLFSSL_SP_MATH)
        err = WC_KEY_SIZE_E;
#else
    if (err == MP_OKAY) {
 801ce50:	69fb      	ldr	r3, [r7, #28]
 801ce52:	2b00      	cmp	r3, #0
 801ce54:	d16f      	bne.n	801cf36 <ecc_make_pub_ex+0x1a2>
        /* Multi-Precision Math: compute public curve */
        mp_digit mp = 0;
 801ce56:	2300      	movs	r3, #0
 801ce58:	617b      	str	r3, [r7, #20]
        ecc_point* base = NULL;
 801ce5a:	2300      	movs	r3, #0
 801ce5c:	613b      	str	r3, [r7, #16]
    #ifdef WOLFSSL_NO_MALLOC
        ecc_point  lcl_base;
        base = &lcl_base;
    #endif
        err = wc_ecc_new_point_ex(&base, key->heap);
 801ce5e:	68fb      	ldr	r3, [r7, #12]
 801ce60:	695a      	ldr	r2, [r3, #20]
 801ce62:	f107 0310 	add.w	r3, r7, #16
 801ce66:	4611      	mov	r1, r2
 801ce68:	4618      	mov	r0, r3
 801ce6a:	f7ff fde8 	bl	801ca3e <wc_ecc_new_point_ex>
 801ce6e:	61f8      	str	r0, [r7, #28]

        /* read in the x/y for this key */
        if (err == MP_OKAY)
 801ce70:	69fb      	ldr	r3, [r7, #28]
 801ce72:	2b00      	cmp	r3, #0
 801ce74:	d108      	bne.n	801ce88 <ecc_make_pub_ex+0xf4>
            err = mp_copy(curve->Gx, base->x);
 801ce76:	68bb      	ldr	r3, [r7, #8]
 801ce78:	695a      	ldr	r2, [r3, #20]
 801ce7a:	693b      	ldr	r3, [r7, #16]
 801ce7c:	681b      	ldr	r3, [r3, #0]
 801ce7e:	4619      	mov	r1, r3
 801ce80:	4610      	mov	r0, r2
 801ce82:	f009 fff6 	bl	8026e72 <mp_copy>
 801ce86:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801ce88:	69fb      	ldr	r3, [r7, #28]
 801ce8a:	2b00      	cmp	r3, #0
 801ce8c:	d108      	bne.n	801cea0 <ecc_make_pub_ex+0x10c>
            err = mp_copy(curve->Gy, base->y);
 801ce8e:	68bb      	ldr	r3, [r7, #8]
 801ce90:	699a      	ldr	r2, [r3, #24]
 801ce92:	693b      	ldr	r3, [r7, #16]
 801ce94:	685b      	ldr	r3, [r3, #4]
 801ce96:	4619      	mov	r1, r3
 801ce98:	4610      	mov	r0, r2
 801ce9a:	f009 ffea 	bl	8026e72 <mp_copy>
 801ce9e:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801cea0:	69fb      	ldr	r3, [r7, #28]
 801cea2:	2b00      	cmp	r3, #0
 801cea4:	d108      	bne.n	801ceb8 <ecc_make_pub_ex+0x124>
            err = mp_montgomery_setup(curve->prime, &mp);
 801cea6:	68bb      	ldr	r3, [r7, #8]
 801cea8:	685b      	ldr	r3, [r3, #4]
 801ceaa:	f107 0214 	add.w	r2, r7, #20
 801ceae:	4611      	mov	r1, r2
 801ceb0:	4618      	mov	r0, r3
 801ceb2:	f00a fa6f 	bl	8027394 <mp_montgomery_setup>
 801ceb6:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801ceb8:	69fb      	ldr	r3, [r7, #28]
 801ceba:	2b00      	cmp	r3, #0
 801cebc:	d106      	bne.n	801cecc <ecc_make_pub_ex+0x138>
            err = mp_set(base->z, 1);
 801cebe:	693b      	ldr	r3, [r7, #16]
 801cec0:	689b      	ldr	r3, [r3, #8]
 801cec2:	2101      	movs	r1, #1
 801cec4:	4618      	mov	r0, r3
 801cec6:	f00a fa91 	bl	80273ec <mp_set>
 801ceca:	61f8      	str	r0, [r7, #28]

        /* make the public key */
        if (err == MP_OKAY) {
 801cecc:	69fb      	ldr	r3, [r7, #28]
 801cece:	2b00      	cmp	r3, #0
 801ced0:	d11f      	bne.n	801cf12 <ecc_make_pub_ex+0x17e>
            /* Map in a separate call as this should be constant time */
            err = wc_ecc_mulmod_ex2(ecc_get_k(key), base, pub, curve->Af,
 801ced2:	68fb      	ldr	r3, [r7, #12]
 801ced4:	f8d3 0118 	ldr.w	r0, [r3, #280]	@ 0x118
 801ced8:	693c      	ldr	r4, [r7, #16]
 801ceda:	68bb      	ldr	r3, [r7, #8]
 801cedc:	689d      	ldr	r5, [r3, #8]
 801cede:	68bb      	ldr	r3, [r7, #8]
 801cee0:	685b      	ldr	r3, [r3, #4]
 801cee2:	68ba      	ldr	r2, [r7, #8]
 801cee4:	6912      	ldr	r2, [r2, #16]
 801cee6:	68f9      	ldr	r1, [r7, #12]
 801cee8:	6949      	ldr	r1, [r1, #20]
 801ceea:	9104      	str	r1, [sp, #16]
 801ceec:	2100      	movs	r1, #0
 801ceee:	9103      	str	r1, [sp, #12]
 801cef0:	6839      	ldr	r1, [r7, #0]
 801cef2:	9102      	str	r1, [sp, #8]
 801cef4:	9201      	str	r2, [sp, #4]
 801cef6:	9300      	str	r3, [sp, #0]
 801cef8:	462b      	mov	r3, r5
 801cefa:	69ba      	ldr	r2, [r7, #24]
 801cefc:	4621      	mov	r1, r4
 801cefe:	f7ff fced 	bl	801c8dc <wc_ecc_mulmod_ex2>
 801cf02:	61f8      	str	r0, [r7, #28]
                                 curve->prime, curve->order, rng, 0, key->heap);
            if (err == WC_NO_ERR_TRACE(MP_MEM)) {
 801cf04:	69fb      	ldr	r3, [r7, #28]
 801cf06:	f113 0f61 	cmn.w	r3, #97	@ 0x61
 801cf0a:	d102      	bne.n	801cf12 <ecc_make_pub_ex+0x17e>
               err = MEMORY_E;
 801cf0c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801cf10:	61fb      	str	r3, [r7, #28]
            }
        }
        if (err == MP_OKAY) {
 801cf12:	69fb      	ldr	r3, [r7, #28]
 801cf14:	2b00      	cmp	r3, #0
 801cf16:	d107      	bne.n	801cf28 <ecc_make_pub_ex+0x194>
            /* Use constant time map if compiled in */
            err = ecc_map_ex(pub, curve->prime, mp, 1);
 801cf18:	68bb      	ldr	r3, [r7, #8]
 801cf1a:	6859      	ldr	r1, [r3, #4]
 801cf1c:	697a      	ldr	r2, [r7, #20]
 801cf1e:	2301      	movs	r3, #1
 801cf20:	69b8      	ldr	r0, [r7, #24]
 801cf22:	f7fe fe9b 	bl	801bc5c <ecc_map_ex>
 801cf26:	61f8      	str	r0, [r7, #28]
        }

        wc_ecc_del_point_ex(base, key->heap);
 801cf28:	693a      	ldr	r2, [r7, #16]
 801cf2a:	68fb      	ldr	r3, [r7, #12]
 801cf2c:	695b      	ldr	r3, [r3, #20]
 801cf2e:	4619      	mov	r1, r3
 801cf30:	4610      	mov	r0, r2
 801cf32:	f7ff fdd9 	bl	801cae8 <wc_ecc_del_point_ex>
    (void)curve;
    err = NOT_COMPILED_IN;
#endif /* HAVE_ECC_MAKE_PUB */

    /* change key state if public part is cached */
    if (key->type == ECC_PRIVATEKEY_ONLY && pubOut == NULL) {
 801cf36:	68fb      	ldr	r3, [r7, #12]
 801cf38:	681b      	ldr	r3, [r3, #0]
 801cf3a:	2b03      	cmp	r3, #3
 801cf3c:	d105      	bne.n	801cf4a <ecc_make_pub_ex+0x1b6>
 801cf3e:	687b      	ldr	r3, [r7, #4]
 801cf40:	2b00      	cmp	r3, #0
 801cf42:	d102      	bne.n	801cf4a <ecc_make_pub_ex+0x1b6>
        key->type = ECC_PRIVATEKEY;
 801cf44:	68fb      	ldr	r3, [r7, #12]
 801cf46:	2202      	movs	r2, #2
 801cf48:	601a      	str	r2, [r3, #0]
    }

    RESTORE_VECTOR_REGISTERS();

    return err;
 801cf4a:	69fb      	ldr	r3, [r7, #28]
}
 801cf4c:	4618      	mov	r0, r3
 801cf4e:	3720      	adds	r7, #32
 801cf50:	46bd      	mov	sp, r7
 801cf52:	bdb0      	pop	{r4, r5, r7, pc}

0801cf54 <wc_ecc_init_ex>:
}

/* Setup dynamic pointers if using normal math for proper freeing */
WOLFSSL_ABI
int wc_ecc_init_ex(ecc_key* key, void* heap, int devId)
{
 801cf54:	b580      	push	{r7, lr}
 801cf56:	b086      	sub	sp, #24
 801cf58:	af00      	add	r7, sp, #0
 801cf5a:	60f8      	str	r0, [r7, #12]
 801cf5c:	60b9      	str	r1, [r7, #8]
 801cf5e:	607a      	str	r2, [r7, #4]
    int ret      = 0;
 801cf60:	2300      	movs	r3, #0
 801cf62:	617b      	str	r3, [r7, #20]

    if (key == NULL) {
 801cf64:	68fb      	ldr	r3, [r7, #12]
 801cf66:	2b00      	cmp	r3, #0
 801cf68:	d102      	bne.n	801cf70 <wc_ecc_init_ex+0x1c>
        return BAD_FUNC_ARG;
 801cf6a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801cf6e:	e036      	b.n	801cfde <wc_ecc_init_ex+0x8a>

#ifdef ECC_DUMP_OID
    wc_ecc_dump_oids();
#endif

    XMEMSET(key, 0, sizeof(ecc_key));
 801cf70:	f44f 72b8 	mov.w	r2, #368	@ 0x170
 801cf74:	2100      	movs	r1, #0
 801cf76:	68f8      	ldr	r0, [r7, #12]
 801cf78:	f00b fe54 	bl	8028c24 <memset>
    key->state = ECC_STATE_NONE;
 801cf7c:	68fb      	ldr	r3, [r7, #12]
 801cf7e:	2200      	movs	r2, #0
 801cf80:	609a      	str	r2, [r3, #8]
    key->slot = ATECC_INVALID_SLOT;
#elif defined(WOLFSSL_KCAPI_ECC)
    key->handle = NULL;
#else
#ifdef ALT_ECC_SIZE
    key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
 801cf82:	68fb      	ldr	r3, [r7, #12]
 801cf84:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 801cf88:	68fb      	ldr	r3, [r7, #12]
 801cf8a:	619a      	str	r2, [r3, #24]
    key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
 801cf8c:	68fb      	ldr	r3, [r7, #12]
 801cf8e:	f103 0274 	add.w	r2, r3, #116	@ 0x74
 801cf92:	68fb      	ldr	r3, [r7, #12]
 801cf94:	61da      	str	r2, [r3, #28]
    key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
 801cf96:	68fb      	ldr	r3, [r7, #12]
 801cf98:	f103 02c4 	add.w	r2, r3, #196	@ 0xc4
 801cf9c:	68fb      	ldr	r3, [r7, #12]
 801cf9e:	621a      	str	r2, [r3, #32]
    alt_fp_init(key->pubkey.x);
 801cfa0:	68fb      	ldr	r3, [r7, #12]
 801cfa2:	699b      	ldr	r3, [r3, #24]
 801cfa4:	4618      	mov	r0, r3
 801cfa6:	f7fd fea3 	bl	801acf0 <alt_fp_init>
    alt_fp_init(key->pubkey.y);
 801cfaa:	68fb      	ldr	r3, [r7, #12]
 801cfac:	69db      	ldr	r3, [r3, #28]
 801cfae:	4618      	mov	r0, r3
 801cfb0:	f7fd fe9e 	bl	801acf0 <alt_fp_init>
    alt_fp_init(key->pubkey.z);
 801cfb4:	68fb      	ldr	r3, [r7, #12]
 801cfb6:	6a1b      	ldr	r3, [r3, #32]
 801cfb8:	4618      	mov	r0, r3
 801cfba:	f7fd fe99 	bl	801acf0 <alt_fp_init>
    key->k = (mp_int*)key->ka;
 801cfbe:	68fb      	ldr	r3, [r7, #12]
 801cfc0:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
 801cfc4:	68fb      	ldr	r3, [r7, #12]
 801cfc6:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
    alt_fp_init(key->k);
 801cfca:	68fb      	ldr	r3, [r7, #12]
 801cfcc:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cfd0:	4618      	mov	r0, r3
 801cfd2:	f7fd fe8d 	bl	801acf0 <alt_fp_init>

#ifdef WOLFSSL_HEAP_TEST
    (void)heap;
    key->heap = (void*)WOLFSSL_HEAP_TEST;
#else
    key->heap = heap;
 801cfd6:	68fb      	ldr	r3, [r7, #12]
 801cfd8:	68ba      	ldr	r2, [r7, #8]
 801cfda:	615a      	str	r2, [r3, #20]
        WOLFSSL_MSG("Can't initialize Xsecure");
        return WC_HW_E;
    }
#endif

    return ret;
 801cfdc:	697b      	ldr	r3, [r7, #20]
}
 801cfde:	4618      	mov	r0, r3
 801cfe0:	3718      	adds	r7, #24
 801cfe2:	46bd      	mov	sp, r7
 801cfe4:	bd80      	pop	{r7, pc}

0801cfe6 <wc_ecc_get_curve_order_bit_count>:
    return 0;
}


static int wc_ecc_get_curve_order_bit_count(const ecc_set_type* dp)
{
 801cfe6:	b580      	push	{r7, lr}
 801cfe8:	b094      	sub	sp, #80	@ 0x50
 801cfea:	af00      	add	r7, sp, #0
 801cfec:	6078      	str	r0, [r7, #4]
    int err = MP_OKAY;
 801cfee:	2300      	movs	r3, #0
 801cff0:	64fb      	str	r3, [r7, #76]	@ 0x4c
    int orderBits;
    DECLARE_CURVE_SPECS(1);
 801cff2:	2300      	movs	r3, #0
 801cff4:	64bb      	str	r3, [r7, #72]	@ 0x48
 801cff6:	f107 0310 	add.w	r3, r7, #16
 801cffa:	60fb      	str	r3, [r7, #12]
 801cffc:	68fb      	ldr	r3, [r7, #12]
 801cffe:	222c      	movs	r2, #44	@ 0x2c
 801d000:	2100      	movs	r1, #0
 801d002:	4618      	mov	r0, r3
 801d004:	f00b fe0e 	bl	8028c24 <memset>
 801d008:	68fb      	ldr	r3, [r7, #12]
 801d00a:	2201      	movs	r2, #1
 801d00c:	621a      	str	r2, [r3, #32]

    ALLOC_CURVE_SPECS(1, err);
 801d00e:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801d012:	f001 fe33 	bl	801ec7c <wolfSSL_Malloc>
 801d016:	64b8      	str	r0, [r7, #72]	@ 0x48
 801d018:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d01a:	2b00      	cmp	r3, #0
 801d01c:	d103      	bne.n	801d026 <wc_ecc_get_curve_order_bit_count+0x40>
 801d01e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801d022:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801d024:	e002      	b.n	801d02c <wc_ecc_get_curve_order_bit_count+0x46>
 801d026:	68fb      	ldr	r3, [r7, #12]
 801d028:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801d02a:	61da      	str	r2, [r3, #28]
    if (err == MP_OKAY) {
 801d02c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d02e:	2b00      	cmp	r3, #0
 801d030:	d107      	bne.n	801d042 <wc_ecc_get_curve_order_bit_count+0x5c>
        err = wc_ecc_curve_load(dp, &curve, ECC_CURVE_FIELD_ORDER);
 801d032:	f107 030c 	add.w	r3, r7, #12
 801d036:	2208      	movs	r2, #8
 801d038:	4619      	mov	r1, r3
 801d03a:	6878      	ldr	r0, [r7, #4]
 801d03c:	f7fd fd3d 	bl	801aaba <wc_ecc_curve_load>
 801d040:	64f8      	str	r0, [r7, #76]	@ 0x4c
    }

    if (err != 0) {
 801d042:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d044:	2b00      	cmp	r3, #0
 801d046:	d009      	beq.n	801d05c <wc_ecc_get_curve_order_bit_count+0x76>
       FREE_CURVE_SPECS();
 801d048:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d04a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801d04c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d04e:	2b00      	cmp	r3, #0
 801d050:	d002      	beq.n	801d058 <wc_ecc_get_curve_order_bit_count+0x72>
 801d052:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801d054:	f001 fe2e 	bl	801ecb4 <wolfSSL_Free>
       return err;
 801d058:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d05a:	e012      	b.n	801d082 <wc_ecc_get_curve_order_bit_count+0x9c>
    }
    orderBits = mp_count_bits(curve->order);
 801d05c:	68fb      	ldr	r3, [r7, #12]
 801d05e:	691b      	ldr	r3, [r3, #16]
 801d060:	4618      	mov	r0, r3
 801d062:	f009 ff25 	bl	8026eb0 <mp_count_bits>
 801d066:	6478      	str	r0, [r7, #68]	@ 0x44

    wc_ecc_curve_free(curve);
 801d068:	68fb      	ldr	r3, [r7, #12]
 801d06a:	4618      	mov	r0, r3
 801d06c:	f7fd fcda 	bl	801aa24 <wc_ecc_curve_free>
    FREE_CURVE_SPECS();
 801d070:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d072:	643b      	str	r3, [r7, #64]	@ 0x40
 801d074:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801d076:	2b00      	cmp	r3, #0
 801d078:	d002      	beq.n	801d080 <wc_ecc_get_curve_order_bit_count+0x9a>
 801d07a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801d07c:	f001 fe1a 	bl	801ecb4 <wolfSSL_Free>
    return orderBits;
 801d080:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 801d082:	4618      	mov	r0, r3
 801d084:	3750      	adds	r7, #80	@ 0x50
 801d086:	46bd      	mov	sp, r7
 801d088:	bd80      	pop	{r7, pc}

0801d08a <wc_ecc_free>:
  Free an ECC key from memory
  key   The key you wish to free
*/
WOLFSSL_ABI
int wc_ecc_free(ecc_key* key)
{
 801d08a:	b580      	push	{r7, lr}
 801d08c:	b082      	sub	sp, #8
 801d08e:	af00      	add	r7, sp, #0
 801d090:	6078      	str	r0, [r7, #4]
    if (key == NULL) {
 801d092:	687b      	ldr	r3, [r7, #4]
 801d094:	2b00      	cmp	r3, #0
 801d096:	d101      	bne.n	801d09c <wc_ecc_free+0x12>
        return 0;
 801d098:	2300      	movs	r3, #0
 801d09a:	e01a      	b.n	801d0d2 <wc_ecc_free+0x48>

#ifdef WOLFSSL_MAXQ10XX_CRYPTO
    wc_MAXQ10XX_EccFree(key);
#endif

    mp_clear(key->pubkey.x);
 801d09c:	687b      	ldr	r3, [r7, #4]
 801d09e:	699b      	ldr	r3, [r3, #24]
 801d0a0:	4618      	mov	r0, r3
 801d0a2:	f009 fd24 	bl	8026aee <mp_clear>
    mp_clear(key->pubkey.y);
 801d0a6:	687b      	ldr	r3, [r7, #4]
 801d0a8:	69db      	ldr	r3, [r3, #28]
 801d0aa:	4618      	mov	r0, r3
 801d0ac:	f009 fd1f 	bl	8026aee <mp_clear>
    mp_clear(key->pubkey.z);
 801d0b0:	687b      	ldr	r3, [r7, #4]
 801d0b2:	6a1b      	ldr	r3, [r3, #32]
 801d0b4:	4618      	mov	r0, r3
 801d0b6:	f009 fd1a 	bl	8026aee <mp_clear>

#ifdef ALT_ECC_SIZE
    if (key->k)
 801d0ba:	687b      	ldr	r3, [r7, #4]
 801d0bc:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801d0c0:	2b00      	cmp	r3, #0
 801d0c2:	d005      	beq.n	801d0d0 <wc_ecc_free+0x46>
#endif
        mp_forcezero(key->k);
 801d0c4:	687b      	ldr	r3, [r7, #4]
 801d0c6:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801d0ca:	4618      	mov	r0, r3
 801d0cc:	f009 fcfa 	bl	8026ac4 <mp_forcezero>

#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(key, sizeof(ecc_key));
#endif

    return 0;
 801d0d0:	2300      	movs	r3, #0
}
 801d0d2:	4618      	mov	r0, r3
 801d0d4:	3708      	adds	r7, #8
 801d0d6:	46bd      	mov	sp, r7
 801d0d8:	bd80      	pop	{r7, pc}

0801d0da <ecc_projective_add_point_safe>:
 *           (Result was: z == 0, x and/or y not 0)
 *        -> Need to set result to infinity.
 */
int ecc_projective_add_point_safe(ecc_point* A, ecc_point* B, ecc_point* R,
    mp_int* a, mp_int* modulus, mp_digit mp, int* infinity)
{
 801d0da:	b580      	push	{r7, lr}
 801d0dc:	b088      	sub	sp, #32
 801d0de:	af02      	add	r7, sp, #8
 801d0e0:	60f8      	str	r0, [r7, #12]
 801d0e2:	60b9      	str	r1, [r7, #8]
 801d0e4:	607a      	str	r2, [r7, #4]
 801d0e6:	603b      	str	r3, [r7, #0]
    int err;

    if (mp_iszero(A->x) && mp_iszero(A->y)) {
 801d0e8:	68fb      	ldr	r3, [r7, #12]
 801d0ea:	681b      	ldr	r3, [r3, #0]
 801d0ec:	4618      	mov	r0, r3
 801d0ee:	f009 fece 	bl	8026e8e <mp_iszero>
 801d0f2:	4603      	mov	r3, r0
 801d0f4:	2b00      	cmp	r3, #0
 801d0f6:	d00d      	beq.n	801d114 <ecc_projective_add_point_safe+0x3a>
 801d0f8:	68fb      	ldr	r3, [r7, #12]
 801d0fa:	685b      	ldr	r3, [r3, #4]
 801d0fc:	4618      	mov	r0, r3
 801d0fe:	f009 fec6 	bl	8026e8e <mp_iszero>
 801d102:	4603      	mov	r3, r0
 801d104:	2b00      	cmp	r3, #0
 801d106:	d005      	beq.n	801d114 <ecc_projective_add_point_safe+0x3a>
        /* A is infinity. */
        err = wc_ecc_copy_point(B, R);
 801d108:	6879      	ldr	r1, [r7, #4]
 801d10a:	68b8      	ldr	r0, [r7, #8]
 801d10c:	f7ff fd23 	bl	801cb56 <wc_ecc_copy_point>
 801d110:	6178      	str	r0, [r7, #20]
 801d112:	e0e1      	b.n	801d2d8 <ecc_projective_add_point_safe+0x1fe>
    }
    else if (mp_iszero(B->x) && mp_iszero(B->y)) {
 801d114:	68bb      	ldr	r3, [r7, #8]
 801d116:	681b      	ldr	r3, [r3, #0]
 801d118:	4618      	mov	r0, r3
 801d11a:	f009 feb8 	bl	8026e8e <mp_iszero>
 801d11e:	4603      	mov	r3, r0
 801d120:	2b00      	cmp	r3, #0
 801d122:	d00d      	beq.n	801d140 <ecc_projective_add_point_safe+0x66>
 801d124:	68bb      	ldr	r3, [r7, #8]
 801d126:	685b      	ldr	r3, [r3, #4]
 801d128:	4618      	mov	r0, r3
 801d12a:	f009 feb0 	bl	8026e8e <mp_iszero>
 801d12e:	4603      	mov	r3, r0
 801d130:	2b00      	cmp	r3, #0
 801d132:	d005      	beq.n	801d140 <ecc_projective_add_point_safe+0x66>
        /* B is infinity. */
        err = wc_ecc_copy_point(A, R);
 801d134:	6879      	ldr	r1, [r7, #4]
 801d136:	68f8      	ldr	r0, [r7, #12]
 801d138:	f7ff fd0d 	bl	801cb56 <wc_ecc_copy_point>
 801d13c:	6178      	str	r0, [r7, #20]
 801d13e:	e0cb      	b.n	801d2d8 <ecc_projective_add_point_safe+0x1fe>
    }
    else if ((mp_cmp(A->x, B->x) == MP_EQ) && (mp_cmp(A->z, B->z) == MP_EQ)) {
 801d140:	68fb      	ldr	r3, [r7, #12]
 801d142:	681a      	ldr	r2, [r3, #0]
 801d144:	68bb      	ldr	r3, [r7, #8]
 801d146:	681b      	ldr	r3, [r3, #0]
 801d148:	4619      	mov	r1, r3
 801d14a:	4610      	mov	r0, r2
 801d14c:	f009 fdd8 	bl	8026d00 <mp_cmp>
 801d150:	4603      	mov	r3, r0
 801d152:	2b00      	cmp	r3, #0
 801d154:	d144      	bne.n	801d1e0 <ecc_projective_add_point_safe+0x106>
 801d156:	68fb      	ldr	r3, [r7, #12]
 801d158:	689a      	ldr	r2, [r3, #8]
 801d15a:	68bb      	ldr	r3, [r7, #8]
 801d15c:	689b      	ldr	r3, [r3, #8]
 801d15e:	4619      	mov	r1, r3
 801d160:	4610      	mov	r0, r2
 801d162:	f009 fdcd 	bl	8026d00 <mp_cmp>
 801d166:	4603      	mov	r3, r0
 801d168:	2b00      	cmp	r3, #0
 801d16a:	d139      	bne.n	801d1e0 <ecc_projective_add_point_safe+0x106>
        /* x ordinattes the same. */
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d16c:	68fb      	ldr	r3, [r7, #12]
 801d16e:	685a      	ldr	r2, [r3, #4]
 801d170:	68bb      	ldr	r3, [r7, #8]
 801d172:	685b      	ldr	r3, [r3, #4]
 801d174:	4619      	mov	r1, r3
 801d176:	4610      	mov	r0, r2
 801d178:	f009 fdc2 	bl	8026d00 <mp_cmp>
 801d17c:	4603      	mov	r3, r0
 801d17e:	2b00      	cmp	r3, #0
 801d180:	d109      	bne.n	801d196 <ecc_projective_add_point_safe+0xbc>
            /* A = B */
            err = _ecc_projective_dbl_point(B, R, a, modulus, mp);
 801d182:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d184:	9300      	str	r3, [sp, #0]
 801d186:	6a3b      	ldr	r3, [r7, #32]
 801d188:	683a      	ldr	r2, [r7, #0]
 801d18a:	6879      	ldr	r1, [r7, #4]
 801d18c:	68b8      	ldr	r0, [r7, #8]
 801d18e:	f7fe fa4c 	bl	801b62a <_ecc_projective_dbl_point>
 801d192:	6178      	str	r0, [r7, #20]
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d194:	e09d      	b.n	801d2d2 <ecc_projective_add_point_safe+0x1f8>
        }
        else {
            /* A = -B */
            err = mp_set(R->x, 0);
 801d196:	687b      	ldr	r3, [r7, #4]
 801d198:	681b      	ldr	r3, [r3, #0]
 801d19a:	2100      	movs	r1, #0
 801d19c:	4618      	mov	r0, r3
 801d19e:	f00a f925 	bl	80273ec <mp_set>
 801d1a2:	6178      	str	r0, [r7, #20]
            if (err == MP_OKAY)
 801d1a4:	697b      	ldr	r3, [r7, #20]
 801d1a6:	2b00      	cmp	r3, #0
 801d1a8:	d106      	bne.n	801d1b8 <ecc_projective_add_point_safe+0xde>
                err = mp_set(R->y, 0);
 801d1aa:	687b      	ldr	r3, [r7, #4]
 801d1ac:	685b      	ldr	r3, [r3, #4]
 801d1ae:	2100      	movs	r1, #0
 801d1b0:	4618      	mov	r0, r3
 801d1b2:	f00a f91b 	bl	80273ec <mp_set>
 801d1b6:	6178      	str	r0, [r7, #20]
            if (err == MP_OKAY)
 801d1b8:	697b      	ldr	r3, [r7, #20]
 801d1ba:	2b00      	cmp	r3, #0
 801d1bc:	d106      	bne.n	801d1cc <ecc_projective_add_point_safe+0xf2>
                err = mp_set(R->z, 1);
 801d1be:	687b      	ldr	r3, [r7, #4]
 801d1c0:	689b      	ldr	r3, [r3, #8]
 801d1c2:	2101      	movs	r1, #1
 801d1c4:	4618      	mov	r0, r3
 801d1c6:	f00a f911 	bl	80273ec <mp_set>
 801d1ca:	6178      	str	r0, [r7, #20]
            if ((err == MP_OKAY) && (infinity != NULL))
 801d1cc:	697b      	ldr	r3, [r7, #20]
 801d1ce:	2b00      	cmp	r3, #0
 801d1d0:	d17f      	bne.n	801d2d2 <ecc_projective_add_point_safe+0x1f8>
 801d1d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d1d4:	2b00      	cmp	r3, #0
 801d1d6:	d07c      	beq.n	801d2d2 <ecc_projective_add_point_safe+0x1f8>
                *infinity = 1;
 801d1d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d1da:	2201      	movs	r2, #1
 801d1dc:	601a      	str	r2, [r3, #0]
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d1de:	e078      	b.n	801d2d2 <ecc_projective_add_point_safe+0x1f8>
        }
    }
    else {
        err = _ecc_projective_add_point(A, B, R, a, modulus, mp);
 801d1e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d1e2:	9301      	str	r3, [sp, #4]
 801d1e4:	6a3b      	ldr	r3, [r7, #32]
 801d1e6:	9300      	str	r3, [sp, #0]
 801d1e8:	683b      	ldr	r3, [r7, #0]
 801d1ea:	687a      	ldr	r2, [r7, #4]
 801d1ec:	68b9      	ldr	r1, [r7, #8]
 801d1ee:	68f8      	ldr	r0, [r7, #12]
 801d1f0:	f7fd fd8c 	bl	801ad0c <_ecc_projective_add_point>
 801d1f4:	6178      	str	r0, [r7, #20]
        if ((err == MP_OKAY) && mp_iszero(R->z)) {
 801d1f6:	697b      	ldr	r3, [r7, #20]
 801d1f8:	2b00      	cmp	r3, #0
 801d1fa:	d16d      	bne.n	801d2d8 <ecc_projective_add_point_safe+0x1fe>
 801d1fc:	687b      	ldr	r3, [r7, #4]
 801d1fe:	689b      	ldr	r3, [r3, #8]
 801d200:	4618      	mov	r0, r3
 801d202:	f009 fe44 	bl	8026e8e <mp_iszero>
 801d206:	4603      	mov	r3, r0
 801d208:	2b00      	cmp	r3, #0
 801d20a:	d065      	beq.n	801d2d8 <ecc_projective_add_point_safe+0x1fe>
            /* When all zero then should have done a double */
            if (mp_iszero(R->x) && mp_iszero(R->y)) {
 801d20c:	687b      	ldr	r3, [r7, #4]
 801d20e:	681b      	ldr	r3, [r3, #0]
 801d210:	4618      	mov	r0, r3
 801d212:	f009 fe3c 	bl	8026e8e <mp_iszero>
 801d216:	4603      	mov	r3, r0
 801d218:	2b00      	cmp	r3, #0
 801d21a:	d035      	beq.n	801d288 <ecc_projective_add_point_safe+0x1ae>
 801d21c:	687b      	ldr	r3, [r7, #4]
 801d21e:	685b      	ldr	r3, [r3, #4]
 801d220:	4618      	mov	r0, r3
 801d222:	f009 fe34 	bl	8026e8e <mp_iszero>
 801d226:	4603      	mov	r3, r0
 801d228:	2b00      	cmp	r3, #0
 801d22a:	d02d      	beq.n	801d288 <ecc_projective_add_point_safe+0x1ae>
                if (mp_iszero(B->z)) {
 801d22c:	68bb      	ldr	r3, [r7, #8]
 801d22e:	689b      	ldr	r3, [r3, #8]
 801d230:	4618      	mov	r0, r3
 801d232:	f009 fe2c 	bl	8026e8e <mp_iszero>
 801d236:	4603      	mov	r3, r0
 801d238:	2b00      	cmp	r3, #0
 801d23a:	d01b      	beq.n	801d274 <ecc_projective_add_point_safe+0x19a>
                    err = wc_ecc_copy_point(B, R);
 801d23c:	6879      	ldr	r1, [r7, #4]
 801d23e:	68b8      	ldr	r0, [r7, #8]
 801d240:	f7ff fc89 	bl	801cb56 <wc_ecc_copy_point>
 801d244:	6178      	str	r0, [r7, #20]
                    if (err == MP_OKAY) {
 801d246:	697b      	ldr	r3, [r7, #20]
 801d248:	2b00      	cmp	r3, #0
 801d24a:	d106      	bne.n	801d25a <ecc_projective_add_point_safe+0x180>
                        err = mp_montgomery_calc_normalization(R->z, modulus);
 801d24c:	687b      	ldr	r3, [r7, #4]
 801d24e:	689b      	ldr	r3, [r3, #8]
 801d250:	6a39      	ldr	r1, [r7, #32]
 801d252:	4618      	mov	r0, r3
 801d254:	f009 fe51 	bl	8026efa <mp_montgomery_calc_normalization>
 801d258:	6178      	str	r0, [r7, #20]
                    }
                    if (err == MP_OKAY) {
 801d25a:	697b      	ldr	r3, [r7, #20]
 801d25c:	2b00      	cmp	r3, #0
 801d25e:	d13a      	bne.n	801d2d6 <ecc_projective_add_point_safe+0x1fc>
                        err = _ecc_projective_dbl_point(R, R, a, modulus, mp);
 801d260:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d262:	9300      	str	r3, [sp, #0]
 801d264:	6a3b      	ldr	r3, [r7, #32]
 801d266:	683a      	ldr	r2, [r7, #0]
 801d268:	6879      	ldr	r1, [r7, #4]
 801d26a:	6878      	ldr	r0, [r7, #4]
 801d26c:	f7fe f9dd 	bl	801b62a <_ecc_projective_dbl_point>
 801d270:	6178      	str	r0, [r7, #20]
                if (mp_iszero(B->z)) {
 801d272:	e030      	b.n	801d2d6 <ecc_projective_add_point_safe+0x1fc>
                    }
                }
                else {
                    err = _ecc_projective_dbl_point(B, R, a, modulus, mp);
 801d274:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d276:	9300      	str	r3, [sp, #0]
 801d278:	6a3b      	ldr	r3, [r7, #32]
 801d27a:	683a      	ldr	r2, [r7, #0]
 801d27c:	6879      	ldr	r1, [r7, #4]
 801d27e:	68b8      	ldr	r0, [r7, #8]
 801d280:	f7fe f9d3 	bl	801b62a <_ecc_projective_dbl_point>
 801d284:	6178      	str	r0, [r7, #20]
                if (mp_iszero(B->z)) {
 801d286:	e026      	b.n	801d2d6 <ecc_projective_add_point_safe+0x1fc>
                }
            }
            /* When only Z zero then result is infinity */
            else {
                err = mp_set(R->x, 0);
 801d288:	687b      	ldr	r3, [r7, #4]
 801d28a:	681b      	ldr	r3, [r3, #0]
 801d28c:	2100      	movs	r1, #0
 801d28e:	4618      	mov	r0, r3
 801d290:	f00a f8ac 	bl	80273ec <mp_set>
 801d294:	6178      	str	r0, [r7, #20]
                if (err == MP_OKAY)
 801d296:	697b      	ldr	r3, [r7, #20]
 801d298:	2b00      	cmp	r3, #0
 801d29a:	d106      	bne.n	801d2aa <ecc_projective_add_point_safe+0x1d0>
                    err = mp_set(R->y, 0);
 801d29c:	687b      	ldr	r3, [r7, #4]
 801d29e:	685b      	ldr	r3, [r3, #4]
 801d2a0:	2100      	movs	r1, #0
 801d2a2:	4618      	mov	r0, r3
 801d2a4:	f00a f8a2 	bl	80273ec <mp_set>
 801d2a8:	6178      	str	r0, [r7, #20]
                if (err == MP_OKAY)
 801d2aa:	697b      	ldr	r3, [r7, #20]
 801d2ac:	2b00      	cmp	r3, #0
 801d2ae:	d106      	bne.n	801d2be <ecc_projective_add_point_safe+0x1e4>
                    err = mp_set(R->z, 1);
 801d2b0:	687b      	ldr	r3, [r7, #4]
 801d2b2:	689b      	ldr	r3, [r3, #8]
 801d2b4:	2101      	movs	r1, #1
 801d2b6:	4618      	mov	r0, r3
 801d2b8:	f00a f898 	bl	80273ec <mp_set>
 801d2bc:	6178      	str	r0, [r7, #20]
                if ((err == MP_OKAY) && (infinity != NULL))
 801d2be:	697b      	ldr	r3, [r7, #20]
 801d2c0:	2b00      	cmp	r3, #0
 801d2c2:	d109      	bne.n	801d2d8 <ecc_projective_add_point_safe+0x1fe>
 801d2c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d2c6:	2b00      	cmp	r3, #0
 801d2c8:	d006      	beq.n	801d2d8 <ecc_projective_add_point_safe+0x1fe>
                    *infinity = 1;
 801d2ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d2cc:	2201      	movs	r2, #1
 801d2ce:	601a      	str	r2, [r3, #0]
 801d2d0:	e002      	b.n	801d2d8 <ecc_projective_add_point_safe+0x1fe>
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d2d2:	bf00      	nop
 801d2d4:	e000      	b.n	801d2d8 <ecc_projective_add_point_safe+0x1fe>
                if (mp_iszero(B->z)) {
 801d2d6:	bf00      	nop
            }
        }
    }

    return err;
 801d2d8:	697b      	ldr	r3, [r7, #20]
}
 801d2da:	4618      	mov	r0, r3
 801d2dc:	3718      	adds	r7, #24
 801d2de:	46bd      	mov	sp, r7
 801d2e0:	bd80      	pop	{r7, pc}

0801d2e2 <ecc_projective_dbl_point_safe>:
 * Double infinity -> infinity.
 * Otherwise do normal double - which can't lead to infinity as odd order.
 */
int ecc_projective_dbl_point_safe(ecc_point *P, ecc_point *R, mp_int* a,
                                  mp_int* modulus, mp_digit mp)
{
 801d2e2:	b580      	push	{r7, lr}
 801d2e4:	b088      	sub	sp, #32
 801d2e6:	af02      	add	r7, sp, #8
 801d2e8:	60f8      	str	r0, [r7, #12]
 801d2ea:	60b9      	str	r1, [r7, #8]
 801d2ec:	607a      	str	r2, [r7, #4]
 801d2ee:	603b      	str	r3, [r7, #0]
    int err;

    if (mp_iszero(P->x) && mp_iszero(P->y)) {
 801d2f0:	68fb      	ldr	r3, [r7, #12]
 801d2f2:	681b      	ldr	r3, [r3, #0]
 801d2f4:	4618      	mov	r0, r3
 801d2f6:	f009 fdca 	bl	8026e8e <mp_iszero>
 801d2fa:	4603      	mov	r3, r0
 801d2fc:	2b00      	cmp	r3, #0
 801d2fe:	d00d      	beq.n	801d31c <ecc_projective_dbl_point_safe+0x3a>
 801d300:	68fb      	ldr	r3, [r7, #12]
 801d302:	685b      	ldr	r3, [r3, #4]
 801d304:	4618      	mov	r0, r3
 801d306:	f009 fdc2 	bl	8026e8e <mp_iszero>
 801d30a:	4603      	mov	r3, r0
 801d30c:	2b00      	cmp	r3, #0
 801d30e:	d005      	beq.n	801d31c <ecc_projective_dbl_point_safe+0x3a>
        /* P is infinity. */
        err = wc_ecc_copy_point(P, R);
 801d310:	68b9      	ldr	r1, [r7, #8]
 801d312:	68f8      	ldr	r0, [r7, #12]
 801d314:	f7ff fc1f 	bl	801cb56 <wc_ecc_copy_point>
 801d318:	6178      	str	r0, [r7, #20]
 801d31a:	e02e      	b.n	801d37a <ecc_projective_dbl_point_safe+0x98>
    }
    else {
        err = _ecc_projective_dbl_point(P, R, a, modulus, mp);
 801d31c:	6a3b      	ldr	r3, [r7, #32]
 801d31e:	9300      	str	r3, [sp, #0]
 801d320:	683b      	ldr	r3, [r7, #0]
 801d322:	687a      	ldr	r2, [r7, #4]
 801d324:	68b9      	ldr	r1, [r7, #8]
 801d326:	68f8      	ldr	r0, [r7, #12]
 801d328:	f7fe f97f 	bl	801b62a <_ecc_projective_dbl_point>
 801d32c:	6178      	str	r0, [r7, #20]
        if ((err == MP_OKAY) && mp_iszero(R->z)) {
 801d32e:	697b      	ldr	r3, [r7, #20]
 801d330:	2b00      	cmp	r3, #0
 801d332:	d122      	bne.n	801d37a <ecc_projective_dbl_point_safe+0x98>
 801d334:	68bb      	ldr	r3, [r7, #8]
 801d336:	689b      	ldr	r3, [r3, #8]
 801d338:	4618      	mov	r0, r3
 801d33a:	f009 fda8 	bl	8026e8e <mp_iszero>
 801d33e:	4603      	mov	r3, r0
 801d340:	2b00      	cmp	r3, #0
 801d342:	d01a      	beq.n	801d37a <ecc_projective_dbl_point_safe+0x98>
           err = mp_set(R->x, 0);
 801d344:	68bb      	ldr	r3, [r7, #8]
 801d346:	681b      	ldr	r3, [r3, #0]
 801d348:	2100      	movs	r1, #0
 801d34a:	4618      	mov	r0, r3
 801d34c:	f00a f84e 	bl	80273ec <mp_set>
 801d350:	6178      	str	r0, [r7, #20]
           if (err == MP_OKAY)
 801d352:	697b      	ldr	r3, [r7, #20]
 801d354:	2b00      	cmp	r3, #0
 801d356:	d106      	bne.n	801d366 <ecc_projective_dbl_point_safe+0x84>
               err = mp_set(R->y, 0);
 801d358:	68bb      	ldr	r3, [r7, #8]
 801d35a:	685b      	ldr	r3, [r3, #4]
 801d35c:	2100      	movs	r1, #0
 801d35e:	4618      	mov	r0, r3
 801d360:	f00a f844 	bl	80273ec <mp_set>
 801d364:	6178      	str	r0, [r7, #20]
           if (err == MP_OKAY)
 801d366:	697b      	ldr	r3, [r7, #20]
 801d368:	2b00      	cmp	r3, #0
 801d36a:	d106      	bne.n	801d37a <ecc_projective_dbl_point_safe+0x98>
               err = mp_set(R->z, 1);
 801d36c:	68bb      	ldr	r3, [r7, #8]
 801d36e:	689b      	ldr	r3, [r3, #8]
 801d370:	2101      	movs	r1, #1
 801d372:	4618      	mov	r0, r3
 801d374:	f00a f83a 	bl	80273ec <mp_set>
 801d378:	6178      	str	r0, [r7, #20]
        }
    }

    return err;
 801d37a:	697b      	ldr	r3, [r7, #20]
}
 801d37c:	4618      	mov	r0, r3
 801d37e:	3718      	adds	r7, #24
 801d380:	46bd      	mov	sp, r7
 801d382:	bd80      	pop	{r7, pc}

0801d384 <ecc_mont_norm_points>:
    !defined(WOLFSSL_KCAPI_ECC) && !defined(WOLF_CRYPTO_CB_ONLY_ECC)
#ifdef ECC_SHAMIR

static int ecc_mont_norm_points(ecc_point* A, ecc_point* Am, ecc_point* B,
    ecc_point* Bm, mp_int* modulus, void* heap)
{
 801d384:	b580      	push	{r7, lr}
 801d386:	b088      	sub	sp, #32
 801d388:	af00      	add	r7, sp, #0
 801d38a:	60f8      	str	r0, [r7, #12]
 801d38c:	60b9      	str	r1, [r7, #8]
 801d38e:	607a      	str	r2, [r7, #4]
 801d390:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801d392:	2300      	movs	r3, #0
 801d394:	61fb      	str	r3, [r7, #28]
    DECL_MP_INT_SIZE_DYN(mu, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801d396:	2300      	movs	r3, #0
 801d398:	61bb      	str	r3, [r7, #24]

    (void)heap;

    NEW_MP_INT_SIZE(mu, mp_bitsused(modulus), heap, DYNAMIC_TYPE_ECC);
 801d39a:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801d39e:	f001 fc6d 	bl	801ec7c <wolfSSL_Malloc>
 801d3a2:	61b8      	str	r0, [r7, #24]
 801d3a4:	69bb      	ldr	r3, [r7, #24]
 801d3a6:	2b00      	cmp	r3, #0
 801d3a8:	d005      	beq.n	801d3b6 <ecc_mont_norm_points+0x32>
 801d3aa:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801d3ae:	2100      	movs	r1, #0
 801d3b0:	69b8      	ldr	r0, [r7, #24]
 801d3b2:	f00b fc37 	bl	8028c24 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (mu == NULL)
 801d3b6:	69bb      	ldr	r3, [r7, #24]
 801d3b8:	2b00      	cmp	r3, #0
 801d3ba:	d102      	bne.n	801d3c2 <ecc_mont_norm_points+0x3e>
       err = MEMORY_E;
 801d3bc:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801d3c0:	61fb      	str	r3, [r7, #28]
#endif
    if (err == MP_OKAY) {
 801d3c2:	69fb      	ldr	r3, [r7, #28]
 801d3c4:	2b00      	cmp	r3, #0
 801d3c6:	d103      	bne.n	801d3d0 <ecc_mont_norm_points+0x4c>
        err = INIT_MP_INT_SIZE(mu, mp_bitsused(modulus));
 801d3c8:	69b8      	ldr	r0, [r7, #24]
 801d3ca:	f009 fb06 	bl	80269da <mp_init>
 801d3ce:	61f8      	str	r0, [r7, #28]
    }
    if (err == MP_OKAY) {
 801d3d0:	69fb      	ldr	r3, [r7, #28]
 801d3d2:	2b00      	cmp	r3, #0
 801d3d4:	d14f      	bne.n	801d476 <ecc_mont_norm_points+0xf2>
        err = mp_montgomery_calc_normalization(mu, modulus);
 801d3d6:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801d3d8:	69b8      	ldr	r0, [r7, #24]
 801d3da:	f009 fd8e 	bl	8026efa <mp_montgomery_calc_normalization>
 801d3de:	61f8      	str	r0, [r7, #28]

        if (err == MP_OKAY) {
 801d3e0:	69fb      	ldr	r3, [r7, #28]
 801d3e2:	2b00      	cmp	r3, #0
 801d3e4:	d108      	bne.n	801d3f8 <ecc_mont_norm_points+0x74>
            /* copy ones ... */
            err = mp_mulmod(A->x, mu, modulus, Am->x);
 801d3e6:	68fb      	ldr	r3, [r7, #12]
 801d3e8:	6818      	ldr	r0, [r3, #0]
 801d3ea:	68bb      	ldr	r3, [r7, #8]
 801d3ec:	681b      	ldr	r3, [r3, #0]
 801d3ee:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d3f0:	69b9      	ldr	r1, [r7, #24]
 801d3f2:	f009 fbf6 	bl	8026be2 <mp_mulmod>
 801d3f6:	61f8      	str	r0, [r7, #28]
        }

        if (err == MP_OKAY)
 801d3f8:	69fb      	ldr	r3, [r7, #28]
 801d3fa:	2b00      	cmp	r3, #0
 801d3fc:	d108      	bne.n	801d410 <ecc_mont_norm_points+0x8c>
            err = mp_mulmod(A->y, mu, modulus, Am->y);
 801d3fe:	68fb      	ldr	r3, [r7, #12]
 801d400:	6858      	ldr	r0, [r3, #4]
 801d402:	68bb      	ldr	r3, [r7, #8]
 801d404:	685b      	ldr	r3, [r3, #4]
 801d406:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d408:	69b9      	ldr	r1, [r7, #24]
 801d40a:	f009 fbea 	bl	8026be2 <mp_mulmod>
 801d40e:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801d410:	69fb      	ldr	r3, [r7, #28]
 801d412:	2b00      	cmp	r3, #0
 801d414:	d108      	bne.n	801d428 <ecc_mont_norm_points+0xa4>
            err = mp_mulmod(A->z, mu, modulus, Am->z);
 801d416:	68fb      	ldr	r3, [r7, #12]
 801d418:	6898      	ldr	r0, [r3, #8]
 801d41a:	68bb      	ldr	r3, [r7, #8]
 801d41c:	689b      	ldr	r3, [r3, #8]
 801d41e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d420:	69b9      	ldr	r1, [r7, #24]
 801d422:	f009 fbde 	bl	8026be2 <mp_mulmod>
 801d426:	61f8      	str	r0, [r7, #28]

        if (err == MP_OKAY)
 801d428:	69fb      	ldr	r3, [r7, #28]
 801d42a:	2b00      	cmp	r3, #0
 801d42c:	d108      	bne.n	801d440 <ecc_mont_norm_points+0xbc>
            err = mp_mulmod(B->x, mu, modulus, Bm->x);
 801d42e:	687b      	ldr	r3, [r7, #4]
 801d430:	6818      	ldr	r0, [r3, #0]
 801d432:	683b      	ldr	r3, [r7, #0]
 801d434:	681b      	ldr	r3, [r3, #0]
 801d436:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d438:	69b9      	ldr	r1, [r7, #24]
 801d43a:	f009 fbd2 	bl	8026be2 <mp_mulmod>
 801d43e:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801d440:	69fb      	ldr	r3, [r7, #28]
 801d442:	2b00      	cmp	r3, #0
 801d444:	d108      	bne.n	801d458 <ecc_mont_norm_points+0xd4>
            err = mp_mulmod(B->y, mu, modulus, Bm->y);
 801d446:	687b      	ldr	r3, [r7, #4]
 801d448:	6858      	ldr	r0, [r3, #4]
 801d44a:	683b      	ldr	r3, [r7, #0]
 801d44c:	685b      	ldr	r3, [r3, #4]
 801d44e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d450:	69b9      	ldr	r1, [r7, #24]
 801d452:	f009 fbc6 	bl	8026be2 <mp_mulmod>
 801d456:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801d458:	69fb      	ldr	r3, [r7, #28]
 801d45a:	2b00      	cmp	r3, #0
 801d45c:	d108      	bne.n	801d470 <ecc_mont_norm_points+0xec>
            err = mp_mulmod(B->z, mu, modulus, Bm->z);
 801d45e:	687b      	ldr	r3, [r7, #4]
 801d460:	6898      	ldr	r0, [r3, #8]
 801d462:	683b      	ldr	r3, [r7, #0]
 801d464:	689b      	ldr	r3, [r3, #8]
 801d466:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d468:	69b9      	ldr	r1, [r7, #24]
 801d46a:	f009 fbba 	bl	8026be2 <mp_mulmod>
 801d46e:	61f8      	str	r0, [r7, #28]

        /* done with mu */
        mp_clear(mu);
 801d470:	69b8      	ldr	r0, [r7, #24]
 801d472:	f009 fb3c 	bl	8026aee <mp_clear>
    }

    FREE_MP_INT_SIZE(mu, heap, DYNAMIC_TYPE_ECC);
 801d476:	69bb      	ldr	r3, [r7, #24]
 801d478:	617b      	str	r3, [r7, #20]
 801d47a:	697b      	ldr	r3, [r7, #20]
 801d47c:	2b00      	cmp	r3, #0
 801d47e:	d002      	beq.n	801d486 <ecc_mont_norm_points+0x102>
 801d480:	6978      	ldr	r0, [r7, #20]
 801d482:	f001 fc17 	bl	801ecb4 <wolfSSL_Free>

    return err;
 801d486:	69fb      	ldr	r3, [r7, #28]
}
 801d488:	4618      	mov	r0, r3
 801d48a:	3720      	adds	r7, #32
 801d48c:	46bd      	mov	sp, r7
 801d48e:	bd80      	pop	{r7, pc}

0801d490 <ecc_mul2add>:
int ecc_mul2add(ecc_point* A, mp_int* kA,
                    ecc_point* B, mp_int* kB,
                    ecc_point* C, mp_int* a, mp_int* modulus,
                    void* heap)
#endif
{
 801d490:	b590      	push	{r4, r7, lr}
 801d492:	b0a1      	sub	sp, #132	@ 0x84
 801d494:	af04      	add	r7, sp, #16
 801d496:	60f8      	str	r0, [r7, #12]
 801d498:	60b9      	str	r1, [r7, #8]
 801d49a:	607a      	str	r2, [r7, #4]
 801d49c:	603b      	str	r3, [r7, #0]
#ifdef WOLFSSL_SMALL_STACK_CACHE
  ecc_key        *key = NULL;
#endif
#ifdef WOLFSSL_SMALL_STACK
  ecc_point**    precomp = NULL;
 801d49e:	2300      	movs	r3, #0
 801d4a0:	657b      	str	r3, [r7, #84]	@ 0x54
  unsigned int  bitbufA, bitbufB, lenA, lenB, len, nA, nB, nibble;
#ifdef WOLFSSL_NO_MALLOC
  unsigned char tA[ECC_BUFSIZE];
  unsigned char tB[ECC_BUFSIZE];
#else
  unsigned char* tA = NULL;
 801d4a2:	2300      	movs	r3, #0
 801d4a4:	653b      	str	r3, [r7, #80]	@ 0x50
  unsigned char* tB = NULL;
 801d4a6:	2300      	movs	r3, #0
 801d4a8:	64fb      	str	r3, [r7, #76]	@ 0x4c
#endif
  int            err = MP_OKAY, first, x, y;
 801d4aa:	2300      	movs	r3, #0
 801d4ac:	663b      	str	r3, [r7, #96]	@ 0x60
  mp_digit       mp = 0;
 801d4ae:	2300      	movs	r3, #0
 801d4b0:	617b      	str	r3, [r7, #20]

  /* argchks */
  if (A == NULL || kA == NULL || B == NULL || kB == NULL || C == NULL ||
 801d4b2:	68fb      	ldr	r3, [r7, #12]
 801d4b4:	2b00      	cmp	r3, #0
 801d4b6:	d010      	beq.n	801d4da <ecc_mul2add+0x4a>
 801d4b8:	68bb      	ldr	r3, [r7, #8]
 801d4ba:	2b00      	cmp	r3, #0
 801d4bc:	d00d      	beq.n	801d4da <ecc_mul2add+0x4a>
 801d4be:	687b      	ldr	r3, [r7, #4]
 801d4c0:	2b00      	cmp	r3, #0
 801d4c2:	d00a      	beq.n	801d4da <ecc_mul2add+0x4a>
 801d4c4:	683b      	ldr	r3, [r7, #0]
 801d4c6:	2b00      	cmp	r3, #0
 801d4c8:	d007      	beq.n	801d4da <ecc_mul2add+0x4a>
 801d4ca:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d4ce:	2b00      	cmp	r3, #0
 801d4d0:	d003      	beq.n	801d4da <ecc_mul2add+0x4a>
 801d4d2:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d4d6:	2b00      	cmp	r3, #0
 801d4d8:	d102      	bne.n	801d4e0 <ecc_mul2add+0x50>
                                                         modulus == NULL) {
     return ECC_BAD_ARG_E;
 801d4da:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801d4de:	e261      	b.n	801d9a4 <ecc_mul2add+0x514>
  }

#ifndef WOLFSSL_NO_MALLOC
  /* allocate memory */
  tA = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d4e0:	f240 1001 	movw	r0, #257	@ 0x101
 801d4e4:	f001 fbca 	bl	801ec7c <wolfSSL_Malloc>
 801d4e8:	6538      	str	r0, [r7, #80]	@ 0x50
  if (tA == NULL) {
 801d4ea:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d4ec:	2b00      	cmp	r3, #0
 801d4ee:	d102      	bne.n	801d4f6 <ecc_mul2add+0x66>
     return MP_MEM;
 801d4f0:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 801d4f4:	e256      	b.n	801d9a4 <ecc_mul2add+0x514>
  }
  tB = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d4f6:	f240 1001 	movw	r0, #257	@ 0x101
 801d4fa:	f001 fbbf 	bl	801ec7c <wolfSSL_Malloc>
 801d4fe:	64f8      	str	r0, [r7, #76]	@ 0x4c
  if (tB == NULL) {
 801d500:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d502:	2b00      	cmp	r3, #0
 801d504:	d10a      	bne.n	801d51c <ecc_mul2add+0x8c>
     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d506:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d508:	61fb      	str	r3, [r7, #28]
 801d50a:	69fb      	ldr	r3, [r7, #28]
 801d50c:	2b00      	cmp	r3, #0
 801d50e:	d002      	beq.n	801d516 <ecc_mul2add+0x86>
 801d510:	69f8      	ldr	r0, [r7, #28]
 801d512:	f001 fbcf 	bl	801ecb4 <wolfSSL_Free>
     return MP_MEM;
 801d516:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 801d51a:	e243      	b.n	801d9a4 <ecc_mul2add+0x514>
     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
     return MP_MEM;
  }
#endif
#ifdef WOLFSSL_SMALL_STACK
  precomp = (ecc_point**)XMALLOC(sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ, heap,
 801d51c:	2040      	movs	r0, #64	@ 0x40
 801d51e:	f001 fbad 	bl	801ec7c <wolfSSL_Malloc>
 801d522:	6578      	str	r0, [r7, #84]	@ 0x54
                                                       DYNAMIC_TYPE_ECC_BUFFER);
  if (precomp == NULL) {
 801d524:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d526:	2b00      	cmp	r3, #0
 801d528:	d112      	bne.n	801d550 <ecc_mul2add+0xc0>
     XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d52a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d52c:	627b      	str	r3, [r7, #36]	@ 0x24
 801d52e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d530:	2b00      	cmp	r3, #0
 801d532:	d002      	beq.n	801d53a <ecc_mul2add+0xaa>
 801d534:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801d536:	f001 fbbd 	bl	801ecb4 <wolfSSL_Free>
     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d53a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d53c:	623b      	str	r3, [r7, #32]
 801d53e:	6a3b      	ldr	r3, [r7, #32]
 801d540:	2b00      	cmp	r3, #0
 801d542:	d002      	beq.n	801d54a <ecc_mul2add+0xba>
 801d544:	6a38      	ldr	r0, [r7, #32]
 801d546:	f001 fbb5 	bl	801ecb4 <wolfSSL_Free>
  #ifdef WOLFSSL_SMALL_STACK_CACHE
     XFREE(key, heap, DYNAMIC_TYPE_ECC_BUFFER);
  #endif
     return MP_MEM;
 801d54a:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 801d54e:	e229      	b.n	801d9a4 <ecc_mul2add+0x514>
  }
  C->key = key;
#endif /* WOLFSSL_SMALL_STACK_CACHE */

  /* init variables */
  XMEMSET(tA, 0, ECC_BUFSIZE);
 801d550:	f240 1201 	movw	r2, #257	@ 0x101
 801d554:	2100      	movs	r1, #0
 801d556:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801d558:	f00b fb64 	bl	8028c24 <memset>
  XMEMSET(tB, 0, ECC_BUFSIZE);
 801d55c:	f240 1201 	movw	r2, #257	@ 0x101
 801d560:	2100      	movs	r1, #0
 801d562:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801d564:	f00b fb5e 	bl	8028c24 <memset>
#ifndef WOLFSSL_SMALL_STACK
  XMEMSET(precomp, 0, sizeof(precomp));
#else
  XMEMSET(precomp, 0, sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ);
 801d568:	2240      	movs	r2, #64	@ 0x40
 801d56a:	2100      	movs	r1, #0
 801d56c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801d56e:	f00b fb59 	bl	8028c24 <memset>
  wc_MemZero_Add("ecc_mul2add tA", tA, ECC_BUFSIZE);
  wc_MemZero_Add("ecc_mul2add tB", tB, ECC_BUFSIZE);
#endif

  /* get sizes */
  lenA = (unsigned int)mp_unsigned_bin_size(kA);
 801d572:	68b8      	ldr	r0, [r7, #8]
 801d574:	f009 fbe0 	bl	8026d38 <mp_unsigned_bin_size>
 801d578:	4603      	mov	r3, r0
 801d57a:	64bb      	str	r3, [r7, #72]	@ 0x48
  lenB = (unsigned int)mp_unsigned_bin_size(kB);
 801d57c:	6838      	ldr	r0, [r7, #0]
 801d57e:	f009 fbdb 	bl	8026d38 <mp_unsigned_bin_size>
 801d582:	4603      	mov	r3, r0
 801d584:	647b      	str	r3, [r7, #68]	@ 0x44
  len  = MAX(lenA, lenB);
 801d586:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801d588:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d58a:	4293      	cmp	r3, r2
 801d58c:	bf38      	it	cc
 801d58e:	4613      	movcc	r3, r2
 801d590:	643b      	str	r3, [r7, #64]	@ 0x40

  /* sanity check */
  if ((lenA > ECC_BUFSIZE) || (lenB > ECC_BUFSIZE)) {
 801d592:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d594:	f5b3 7f81 	cmp.w	r3, #258	@ 0x102
 801d598:	d203      	bcs.n	801d5a2 <ecc_mul2add+0x112>
 801d59a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d59c:	f5b3 7f81 	cmp.w	r3, #258	@ 0x102
 801d5a0:	d302      	bcc.n	801d5a8 <ecc_mul2add+0x118>
    err = BAD_FUNC_ARG;
 801d5a2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801d5a6:	663b      	str	r3, [r7, #96]	@ 0x60
  }

  if (err == MP_OKAY) {
 801d5a8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d5aa:	2b00      	cmp	r3, #0
 801d5ac:	d131      	bne.n	801d612 <ecc_mul2add+0x182>
    /* extract and justify kA */
    err = mp_to_unsigned_bin(kA, (len - lenA) + tA);
 801d5ae:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801d5b0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d5b2:	1ad3      	subs	r3, r2, r3
 801d5b4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801d5b6:	4413      	add	r3, r2
 801d5b8:	4619      	mov	r1, r3
 801d5ba:	68b8      	ldr	r0, [r7, #8]
 801d5bc:	f009 fbc8 	bl	8026d50 <mp_to_unsigned_bin>
 801d5c0:	6638      	str	r0, [r7, #96]	@ 0x60

    /* extract and justify kB */
    if (err == MP_OKAY)
 801d5c2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d5c4:	2b00      	cmp	r3, #0
 801d5c6:	d109      	bne.n	801d5dc <ecc_mul2add+0x14c>
        err = mp_to_unsigned_bin(kB, (len - lenB) + tB);
 801d5c8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801d5ca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d5cc:	1ad3      	subs	r3, r2, r3
 801d5ce:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801d5d0:	4413      	add	r3, r2
 801d5d2:	4619      	mov	r1, r3
 801d5d4:	6838      	ldr	r0, [r7, #0]
 801d5d6:	f009 fbbb 	bl	8026d50 <mp_to_unsigned_bin>
 801d5da:	6638      	str	r0, [r7, #96]	@ 0x60

    /* allocate the table */
    if (err == MP_OKAY) {
 801d5dc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d5de:	2b00      	cmp	r3, #0
 801d5e0:	d117      	bne.n	801d612 <ecc_mul2add+0x182>
        for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d5e2:	2300      	movs	r3, #0
 801d5e4:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d5e6:	e00f      	b.n	801d608 <ecc_mul2add+0x178>
        #ifdef WOLFSSL_NO_MALLOC
            precomp[x] = &lcl_precomp[x];
        #endif
            err = wc_ecc_new_point_ex(&precomp[x], heap);
 801d5e8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d5ea:	009b      	lsls	r3, r3, #2
 801d5ec:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d5ee:	4413      	add	r3, r2
 801d5f0:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 801d5f4:	4618      	mov	r0, r3
 801d5f6:	f7ff fa22 	bl	801ca3e <wc_ecc_new_point_ex>
 801d5fa:	6638      	str	r0, [r7, #96]	@ 0x60
            if (err != MP_OKAY)
 801d5fc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d5fe:	2b00      	cmp	r3, #0
 801d600:	d106      	bne.n	801d610 <ecc_mul2add+0x180>
        for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d602:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d604:	3301      	adds	r3, #1
 801d606:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d608:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d60a:	2b0f      	cmp	r3, #15
 801d60c:	ddec      	ble.n	801d5e8 <ecc_mul2add+0x158>
 801d60e:	e000      	b.n	801d612 <ecc_mul2add+0x182>
                break;
 801d610:	bf00      	nop
        #endif
        }
    }
  }

  if (err == MP_OKAY)
 801d612:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d614:	2b00      	cmp	r3, #0
 801d616:	d107      	bne.n	801d628 <ecc_mul2add+0x198>
    /* init montgomery reduction */
    err = mp_montgomery_setup(modulus, &mp);
 801d618:	f107 0314 	add.w	r3, r7, #20
 801d61c:	4619      	mov	r1, r3
 801d61e:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801d622:	f009 feb7 	bl	8027394 <mp_montgomery_setup>
 801d626:	6638      	str	r0, [r7, #96]	@ 0x60

  if (err == MP_OKAY) {
 801d628:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d62a:	2b00      	cmp	r3, #0
 801d62c:	d111      	bne.n	801d652 <ecc_mul2add+0x1c2>
    err = ecc_mont_norm_points(A, precomp[1], B, precomp[1<<2], modulus, heap);
 801d62e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d630:	3304      	adds	r3, #4
 801d632:	6819      	ldr	r1, [r3, #0]
 801d634:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d636:	3310      	adds	r3, #16
 801d638:	681a      	ldr	r2, [r3, #0]
 801d63a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801d63e:	9301      	str	r3, [sp, #4]
 801d640:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d644:	9300      	str	r3, [sp, #0]
 801d646:	4613      	mov	r3, r2
 801d648:	687a      	ldr	r2, [r7, #4]
 801d64a:	68f8      	ldr	r0, [r7, #12]
 801d64c:	f7ff fe9a 	bl	801d384 <ecc_mont_norm_points>
 801d650:	6638      	str	r0, [r7, #96]	@ 0x60
  }

  if (err == MP_OKAY) {
 801d652:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d654:	2b00      	cmp	r3, #0
 801d656:	d10e      	bne.n	801d676 <ecc_mul2add+0x1e6>
    /* precomp [i,0](A + B) table */
    err = ecc_projective_dbl_point_safe(precomp[1], precomp[2], a, modulus, mp);
 801d658:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d65a:	3304      	adds	r3, #4
 801d65c:	6818      	ldr	r0, [r3, #0]
 801d65e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d660:	3308      	adds	r3, #8
 801d662:	6819      	ldr	r1, [r3, #0]
 801d664:	697b      	ldr	r3, [r7, #20]
 801d666:	9300      	str	r3, [sp, #0]
 801d668:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d66c:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d670:	f7ff fe37 	bl	801d2e2 <ecc_projective_dbl_point_safe>
 801d674:	6638      	str	r0, [r7, #96]	@ 0x60
  }
  if (err == MP_OKAY) {
 801d676:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d678:	2b00      	cmp	r3, #0
 801d67a:	d114      	bne.n	801d6a6 <ecc_mul2add+0x216>
    err = ecc_projective_add_point_safe(precomp[1], precomp[2], precomp[3],
 801d67c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d67e:	3304      	adds	r3, #4
 801d680:	6818      	ldr	r0, [r3, #0]
 801d682:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d684:	3308      	adds	r3, #8
 801d686:	6819      	ldr	r1, [r3, #0]
 801d688:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d68a:	330c      	adds	r3, #12
 801d68c:	681a      	ldr	r2, [r3, #0]
 801d68e:	697b      	ldr	r3, [r7, #20]
 801d690:	2400      	movs	r4, #0
 801d692:	9402      	str	r4, [sp, #8]
 801d694:	9301      	str	r3, [sp, #4]
 801d696:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d69a:	9300      	str	r3, [sp, #0]
 801d69c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d6a0:	f7ff fd1b 	bl	801d0da <ecc_projective_add_point_safe>
 801d6a4:	6638      	str	r0, [r7, #96]	@ 0x60
                                                          a, modulus, mp, NULL);
  }

  if (err == MP_OKAY) {
 801d6a6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d6a8:	2b00      	cmp	r3, #0
 801d6aa:	d10e      	bne.n	801d6ca <ecc_mul2add+0x23a>
    /* precomp [0,i](A + B) table */
    err = ecc_projective_dbl_point_safe(precomp[4], precomp[8], a, modulus, mp);
 801d6ac:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d6ae:	3310      	adds	r3, #16
 801d6b0:	6818      	ldr	r0, [r3, #0]
 801d6b2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d6b4:	3320      	adds	r3, #32
 801d6b6:	6819      	ldr	r1, [r3, #0]
 801d6b8:	697b      	ldr	r3, [r7, #20]
 801d6ba:	9300      	str	r3, [sp, #0]
 801d6bc:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d6c0:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d6c4:	f7ff fe0d 	bl	801d2e2 <ecc_projective_dbl_point_safe>
 801d6c8:	6638      	str	r0, [r7, #96]	@ 0x60
  }
  if (err == MP_OKAY) {
 801d6ca:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d6cc:	2b00      	cmp	r3, #0
 801d6ce:	d114      	bne.n	801d6fa <ecc_mul2add+0x26a>
    err = ecc_projective_add_point_safe(precomp[4], precomp[8], precomp[12], a,
 801d6d0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d6d2:	3310      	adds	r3, #16
 801d6d4:	6818      	ldr	r0, [r3, #0]
 801d6d6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d6d8:	3320      	adds	r3, #32
 801d6da:	6819      	ldr	r1, [r3, #0]
 801d6dc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d6de:	3330      	adds	r3, #48	@ 0x30
 801d6e0:	681a      	ldr	r2, [r3, #0]
 801d6e2:	697b      	ldr	r3, [r7, #20]
 801d6e4:	2400      	movs	r4, #0
 801d6e6:	9402      	str	r4, [sp, #8]
 801d6e8:	9301      	str	r3, [sp, #4]
 801d6ea:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d6ee:	9300      	str	r3, [sp, #0]
 801d6f0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d6f4:	f7ff fcf1 	bl	801d0da <ecc_projective_add_point_safe>
 801d6f8:	6638      	str	r0, [r7, #96]	@ 0x60
                                                             modulus, mp, NULL);
  }

  if (err == MP_OKAY) {
 801d6fa:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d6fc:	2b00      	cmp	r3, #0
 801d6fe:	d132      	bne.n	801d766 <ecc_mul2add+0x2d6>
    /* precomp [i,j](A + B) table (i != 0, j != 0) */
    for (x = 1; x < 4; x++) {
 801d700:	2301      	movs	r3, #1
 801d702:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d704:	e02c      	b.n	801d760 <ecc_mul2add+0x2d0>
      for (y = 1; y < 4; y++) {
 801d706:	2301      	movs	r3, #1
 801d708:	65bb      	str	r3, [r7, #88]	@ 0x58
 801d70a:	e023      	b.n	801d754 <ecc_mul2add+0x2c4>
        if (err == MP_OKAY) {
 801d70c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d70e:	2b00      	cmp	r3, #0
 801d710:	d11d      	bne.n	801d74e <ecc_mul2add+0x2be>
          err = ecc_projective_add_point_safe(precomp[x], precomp[(y<<2)],
 801d712:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d714:	009b      	lsls	r3, r3, #2
 801d716:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d718:	4413      	add	r3, r2
 801d71a:	6818      	ldr	r0, [r3, #0]
 801d71c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d71e:	011b      	lsls	r3, r3, #4
 801d720:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d722:	4413      	add	r3, r2
 801d724:	6819      	ldr	r1, [r3, #0]
                                                  precomp[x+(y<<2)], a, modulus,
 801d726:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d728:	009a      	lsls	r2, r3, #2
 801d72a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d72c:	4413      	add	r3, r2
 801d72e:	009b      	lsls	r3, r3, #2
 801d730:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d732:	4413      	add	r3, r2
          err = ecc_projective_add_point_safe(precomp[x], precomp[(y<<2)],
 801d734:	681a      	ldr	r2, [r3, #0]
 801d736:	697b      	ldr	r3, [r7, #20]
 801d738:	2400      	movs	r4, #0
 801d73a:	9402      	str	r4, [sp, #8]
 801d73c:	9301      	str	r3, [sp, #4]
 801d73e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d742:	9300      	str	r3, [sp, #0]
 801d744:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d748:	f7ff fcc7 	bl	801d0da <ecc_projective_add_point_safe>
 801d74c:	6638      	str	r0, [r7, #96]	@ 0x60
      for (y = 1; y < 4; y++) {
 801d74e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d750:	3301      	adds	r3, #1
 801d752:	65bb      	str	r3, [r7, #88]	@ 0x58
 801d754:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d756:	2b03      	cmp	r3, #3
 801d758:	ddd8      	ble.n	801d70c <ecc_mul2add+0x27c>
    for (x = 1; x < 4; x++) {
 801d75a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d75c:	3301      	adds	r3, #1
 801d75e:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d760:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d762:	2b03      	cmp	r3, #3
 801d764:	ddcf      	ble.n	801d706 <ecc_mul2add+0x276>
        }
      }
    }
  }

  if (err == MP_OKAY) {
 801d766:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d768:	2b00      	cmp	r3, #0
 801d76a:	f040 80d9 	bne.w	801d920 <ecc_mul2add+0x490>
    nibble  = 3;
 801d76e:	2303      	movs	r3, #3
 801d770:	667b      	str	r3, [r7, #100]	@ 0x64
    first   = 1;
 801d772:	2301      	movs	r3, #1
 801d774:	61bb      	str	r3, [r7, #24]
    bitbufA = tA[0];
 801d776:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d778:	781b      	ldrb	r3, [r3, #0]
 801d77a:	66fb      	str	r3, [r7, #108]	@ 0x6c
    bitbufB = tB[0];
 801d77c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d77e:	781b      	ldrb	r3, [r3, #0]
 801d780:	66bb      	str	r3, [r7, #104]	@ 0x68

    /* for every byte of the multiplicands */
    for (x = 0; x < (int)len || nibble != 3; ) {
 801d782:	2300      	movs	r3, #0
 801d784:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d786:	e0ba      	b.n	801d8fe <ecc_mul2add+0x46e>
        /* grab a nibble */
        if (++nibble == 4) {
 801d788:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d78a:	3301      	adds	r3, #1
 801d78c:	667b      	str	r3, [r7, #100]	@ 0x64
 801d78e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d790:	2b04      	cmp	r3, #4
 801d792:	d113      	bne.n	801d7bc <ecc_mul2add+0x32c>
            if (x == (int)len) break;
 801d794:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801d796:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801d798:	429a      	cmp	r2, r3
 801d79a:	f000 80ba 	beq.w	801d912 <ecc_mul2add+0x482>
            bitbufA = tA[x];
 801d79e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d7a0:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801d7a2:	4413      	add	r3, r2
 801d7a4:	781b      	ldrb	r3, [r3, #0]
 801d7a6:	66fb      	str	r3, [r7, #108]	@ 0x6c
            bitbufB = tB[x];
 801d7a8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d7aa:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801d7ac:	4413      	add	r3, r2
 801d7ae:	781b      	ldrb	r3, [r3, #0]
 801d7b0:	66bb      	str	r3, [r7, #104]	@ 0x68
            nibble  = 0;
 801d7b2:	2300      	movs	r3, #0
 801d7b4:	667b      	str	r3, [r7, #100]	@ 0x64
            x++;
 801d7b6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d7b8:	3301      	adds	r3, #1
 801d7ba:	65fb      	str	r3, [r7, #92]	@ 0x5c
        }

        /* extract two bits from both, shift/update */
        nA = (bitbufA >> 6) & 0x03;
 801d7bc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801d7be:	099b      	lsrs	r3, r3, #6
 801d7c0:	f003 0303 	and.w	r3, r3, #3
 801d7c4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        nB = (bitbufB >> 6) & 0x03;
 801d7c6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801d7c8:	099b      	lsrs	r3, r3, #6
 801d7ca:	f003 0303 	and.w	r3, r3, #3
 801d7ce:	63bb      	str	r3, [r7, #56]	@ 0x38
        bitbufA = (bitbufA << 2) & 0xFF;
 801d7d0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801d7d2:	009b      	lsls	r3, r3, #2
 801d7d4:	b2db      	uxtb	r3, r3
 801d7d6:	66fb      	str	r3, [r7, #108]	@ 0x6c
        bitbufB = (bitbufB << 2) & 0xFF;
 801d7d8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801d7da:	009b      	lsls	r3, r3, #2
 801d7dc:	b2db      	uxtb	r3, r3
 801d7de:	66bb      	str	r3, [r7, #104]	@ 0x68

        /* if both zero, if first, continue */
        if ((nA == 0) && (nB == 0) && (first == 1)) {
 801d7e0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d7e2:	2b00      	cmp	r3, #0
 801d7e4:	d106      	bne.n	801d7f4 <ecc_mul2add+0x364>
 801d7e6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d7e8:	2b00      	cmp	r3, #0
 801d7ea:	d103      	bne.n	801d7f4 <ecc_mul2add+0x364>
 801d7ec:	69bb      	ldr	r3, [r7, #24]
 801d7ee:	2b01      	cmp	r3, #1
 801d7f0:	f000 8084 	beq.w	801d8fc <ecc_mul2add+0x46c>
            continue;
        }

        /* double twice, only if this isn't the first */
        if (first == 0) {
 801d7f4:	69bb      	ldr	r3, [r7, #24]
 801d7f6:	2b00      	cmp	r3, #0
 801d7f8:	d11f      	bne.n	801d83a <ecc_mul2add+0x3aa>
            /* double twice */
            if (err == MP_OKAY)
 801d7fa:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d7fc:	2b00      	cmp	r3, #0
 801d7fe:	d10c      	bne.n	801d81a <ecc_mul2add+0x38a>
                err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
 801d800:	697b      	ldr	r3, [r7, #20]
 801d802:	9300      	str	r3, [sp, #0]
 801d804:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d808:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d80c:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
 801d810:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d814:	f7ff fd65 	bl	801d2e2 <ecc_projective_dbl_point_safe>
 801d818:	6638      	str	r0, [r7, #96]	@ 0x60
            if (err == MP_OKAY)
 801d81a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d81c:	2b00      	cmp	r3, #0
 801d81e:	d17a      	bne.n	801d916 <ecc_mul2add+0x486>
                err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
 801d820:	697b      	ldr	r3, [r7, #20]
 801d822:	9300      	str	r3, [sp, #0]
 801d824:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d828:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d82c:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
 801d830:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d834:	f7ff fd55 	bl	801d2e2 <ecc_projective_dbl_point_safe>
 801d838:	6638      	str	r0, [r7, #96]	@ 0x60
            else
                break;
        }

        /* if not both zero */
        if ((nA != 0) || (nB != 0)) {
 801d83a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d83c:	2b00      	cmp	r3, #0
 801d83e:	d102      	bne.n	801d846 <ecc_mul2add+0x3b6>
 801d840:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d842:	2b00      	cmp	r3, #0
 801d844:	d05b      	beq.n	801d8fe <ecc_mul2add+0x46e>
            unsigned int i = nA + (nB<<2);
 801d846:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d848:	009b      	lsls	r3, r3, #2
 801d84a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801d84c:	4413      	add	r3, r2
 801d84e:	637b      	str	r3, [r7, #52]	@ 0x34
            if (first == 1) {
 801d850:	69bb      	ldr	r3, [r7, #24]
 801d852:	2b01      	cmp	r3, #1
 801d854:	d135      	bne.n	801d8c2 <ecc_mul2add+0x432>
                /* if first, copy from table */
                first = 0;
 801d856:	2300      	movs	r3, #0
 801d858:	61bb      	str	r3, [r7, #24]
                if (err == MP_OKAY)
 801d85a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d85c:	2b00      	cmp	r3, #0
 801d85e:	d10d      	bne.n	801d87c <ecc_mul2add+0x3ec>
                    err = mp_copy(precomp[i]->x, C->x);
 801d860:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d862:	009b      	lsls	r3, r3, #2
 801d864:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d866:	4413      	add	r3, r2
 801d868:	681b      	ldr	r3, [r3, #0]
 801d86a:	681a      	ldr	r2, [r3, #0]
 801d86c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d870:	681b      	ldr	r3, [r3, #0]
 801d872:	4619      	mov	r1, r3
 801d874:	4610      	mov	r0, r2
 801d876:	f009 fafc 	bl	8026e72 <mp_copy>
 801d87a:	6638      	str	r0, [r7, #96]	@ 0x60

                if (err == MP_OKAY)
 801d87c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d87e:	2b00      	cmp	r3, #0
 801d880:	d10d      	bne.n	801d89e <ecc_mul2add+0x40e>
                    err = mp_copy(precomp[i]->y, C->y);
 801d882:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d884:	009b      	lsls	r3, r3, #2
 801d886:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d888:	4413      	add	r3, r2
 801d88a:	681b      	ldr	r3, [r3, #0]
 801d88c:	685a      	ldr	r2, [r3, #4]
 801d88e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d892:	685b      	ldr	r3, [r3, #4]
 801d894:	4619      	mov	r1, r3
 801d896:	4610      	mov	r0, r2
 801d898:	f009 faeb 	bl	8026e72 <mp_copy>
 801d89c:	6638      	str	r0, [r7, #96]	@ 0x60

                if (err == MP_OKAY)
 801d89e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d8a0:	2b00      	cmp	r3, #0
 801d8a2:	d13a      	bne.n	801d91a <ecc_mul2add+0x48a>
                    err = mp_copy(precomp[i]->z, C->z);
 801d8a4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d8a6:	009b      	lsls	r3, r3, #2
 801d8a8:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d8aa:	4413      	add	r3, r2
 801d8ac:	681b      	ldr	r3, [r3, #0]
 801d8ae:	689a      	ldr	r2, [r3, #8]
 801d8b0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d8b4:	689b      	ldr	r3, [r3, #8]
 801d8b6:	4619      	mov	r1, r3
 801d8b8:	4610      	mov	r0, r2
 801d8ba:	f009 fada 	bl	8026e72 <mp_copy>
 801d8be:	6638      	str	r0, [r7, #96]	@ 0x60
 801d8c0:	e01d      	b.n	801d8fe <ecc_mul2add+0x46e>
                else
                    break;
            } else {
                /* if not first, add from table */
                if (err == MP_OKAY)
 801d8c2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d8c4:	2b00      	cmp	r3, #0
 801d8c6:	d115      	bne.n	801d8f4 <ecc_mul2add+0x464>
                    err = ecc_projective_add_point_safe(C, precomp[i],
 801d8c8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d8ca:	009b      	lsls	r3, r3, #2
 801d8cc:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d8ce:	4413      	add	r3, r2
 801d8d0:	6819      	ldr	r1, [r3, #0]
 801d8d2:	697b      	ldr	r3, [r7, #20]
 801d8d4:	f107 0218 	add.w	r2, r7, #24
 801d8d8:	9202      	str	r2, [sp, #8]
 801d8da:	9301      	str	r3, [sp, #4]
 801d8dc:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d8e0:	9300      	str	r3, [sp, #0]
 801d8e2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d8e6:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801d8ea:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d8ee:	f7ff fbf4 	bl	801d0da <ecc_projective_add_point_safe>
 801d8f2:	6638      	str	r0, [r7, #96]	@ 0x60
                                                        C, a, modulus, mp,
                                                        &first);
                if (err != MP_OKAY)
 801d8f4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d8f6:	2b00      	cmp	r3, #0
 801d8f8:	d111      	bne.n	801d91e <ecc_mul2add+0x48e>
 801d8fa:	e000      	b.n	801d8fe <ecc_mul2add+0x46e>
            continue;
 801d8fc:	bf00      	nop
    for (x = 0; x < (int)len || nibble != 3; ) {
 801d8fe:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801d900:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801d902:	429a      	cmp	r2, r3
 801d904:	f6ff af40 	blt.w	801d788 <ecc_mul2add+0x2f8>
 801d908:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d90a:	2b03      	cmp	r3, #3
 801d90c:	f47f af3c 	bne.w	801d788 <ecc_mul2add+0x2f8>
 801d910:	e006      	b.n	801d920 <ecc_mul2add+0x490>
            if (x == (int)len) break;
 801d912:	bf00      	nop
 801d914:	e004      	b.n	801d920 <ecc_mul2add+0x490>
                break;
 801d916:	bf00      	nop
 801d918:	e002      	b.n	801d920 <ecc_mul2add+0x490>
                    break;
 801d91a:	bf00      	nop
 801d91c:	e000      	b.n	801d920 <ecc_mul2add+0x490>
                    break;
 801d91e:	bf00      	nop
        }
    }
  }

  /* reduce to affine */
  if (err == MP_OKAY)
 801d920:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d922:	2b00      	cmp	r3, #0
 801d924:	d108      	bne.n	801d938 <ecc_mul2add+0x4a8>
    err = ecc_map(C, modulus, mp);
 801d926:	697b      	ldr	r3, [r7, #20]
 801d928:	461a      	mov	r2, r3
 801d92a:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801d92e:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d932:	f7fe fbab 	bl	801c08c <ecc_map>
 801d936:	6638      	str	r0, [r7, #96]	@ 0x60

  /* clean up */
  for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d938:	2300      	movs	r3, #0
 801d93a:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d93c:	e00c      	b.n	801d958 <ecc_mul2add+0x4c8>
     wc_ecc_del_point_ex(precomp[x], heap);
 801d93e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d940:	009b      	lsls	r3, r3, #2
 801d942:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d944:	4413      	add	r3, r2
 801d946:	681b      	ldr	r3, [r3, #0]
 801d948:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 801d94c:	4618      	mov	r0, r3
 801d94e:	f7ff f8cb 	bl	801cae8 <wc_ecc_del_point_ex>
  for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d952:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d954:	3301      	adds	r3, #1
 801d956:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d958:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d95a:	2b0f      	cmp	r3, #15
 801d95c:	ddef      	ble.n	801d93e <ecc_mul2add+0x4ae>
  }

  ForceZero(tA, ECC_BUFSIZE);
 801d95e:	f240 1101 	movw	r1, #257	@ 0x101
 801d962:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801d964:	f7fc ffc2 	bl	801a8ec <ForceZero>
  ForceZero(tB, ECC_BUFSIZE);
 801d968:	f240 1101 	movw	r1, #257	@ 0x101
 801d96c:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801d96e:	f7fc ffbd 	bl	801a8ec <ForceZero>
  XFREE(key->t1, heap, DYNAMIC_TYPE_ECC);
  XFREE(key, heap, DYNAMIC_TYPE_ECC_BUFFER);
  C->key = NULL;
#endif
#ifdef WOLFSSL_SMALL_STACK
  XFREE(precomp, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d972:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d974:	633b      	str	r3, [r7, #48]	@ 0x30
 801d976:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801d978:	2b00      	cmp	r3, #0
 801d97a:	d002      	beq.n	801d982 <ecc_mul2add+0x4f2>
 801d97c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801d97e:	f001 f999 	bl	801ecb4 <wolfSSL_Free>
#endif
#ifndef WOLFSSL_NO_MALLOC
  XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d982:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d984:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801d986:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801d988:	2b00      	cmp	r3, #0
 801d98a:	d002      	beq.n	801d992 <ecc_mul2add+0x502>
 801d98c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801d98e:	f001 f991 	bl	801ecb4 <wolfSSL_Free>
  XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d992:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d994:	62bb      	str	r3, [r7, #40]	@ 0x28
 801d996:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d998:	2b00      	cmp	r3, #0
 801d99a:	d002      	beq.n	801d9a2 <ecc_mul2add+0x512>
 801d99c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801d99e:	f001 f989 	bl	801ecb4 <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
  wc_MemZero_Check(tB, ECC_BUFSIZE);
  wc_MemZero_Check(tA, ECC_BUFSIZE);
#endif
  return err;
 801d9a2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
}
 801d9a4:	4618      	mov	r0, r3
 801d9a6:	3774      	adds	r7, #116	@ 0x74
 801d9a8:	46bd      	mov	sp, r7
 801d9aa:	bd90      	pop	{r4, r7, pc}

0801d9ac <wc_ecc_verify_hash>:
             is valid or invalid. Other negative values are returned on error.
 */
WOLFSSL_ABI
int wc_ecc_verify_hash(const byte* sig, word32 siglen, const byte* hash,
                       word32 hashlen, int* res, ecc_key* key)
{
 801d9ac:	b580      	push	{r7, lr}
 801d9ae:	b092      	sub	sp, #72	@ 0x48
 801d9b0:	af02      	add	r7, sp, #8
 801d9b2:	60f8      	str	r0, [r7, #12]
 801d9b4:	60b9      	str	r1, [r7, #8]
 801d9b6:	607a      	str	r2, [r7, #4]
 801d9b8:	603b      	str	r3, [r7, #0]
    int err;

#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
    mp_int *r = NULL, *s = NULL;
#else
    DECL_MP_INT_SIZE_DYN(r, ECC_KEY_MAX_BITS(key), MAX_ECC_BITS_USE);
 801d9ba:	2300      	movs	r3, #0
 801d9bc:	63bb      	str	r3, [r7, #56]	@ 0x38
    DECL_MP_INT_SIZE_DYN(s, ECC_KEY_MAX_BITS(key), MAX_ECC_BITS_USE);
 801d9be:	2300      	movs	r3, #0
 801d9c0:	637b      	str	r3, [r7, #52]	@ 0x34
#endif
#ifdef NO_ASN
    word32 keySz;
#endif

    if (sig == NULL || hash == NULL || res == NULL || key == NULL) {
 801d9c2:	68fb      	ldr	r3, [r7, #12]
 801d9c4:	2b00      	cmp	r3, #0
 801d9c6:	d008      	beq.n	801d9da <wc_ecc_verify_hash+0x2e>
 801d9c8:	687b      	ldr	r3, [r7, #4]
 801d9ca:	2b00      	cmp	r3, #0
 801d9cc:	d005      	beq.n	801d9da <wc_ecc_verify_hash+0x2e>
 801d9ce:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d9d0:	2b00      	cmp	r3, #0
 801d9d2:	d002      	beq.n	801d9da <wc_ecc_verify_hash+0x2e>
 801d9d4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d9d6:	2b00      	cmp	r3, #0
 801d9d8:	d102      	bne.n	801d9e0 <wc_ecc_verify_hash+0x34>
        return ECC_BAD_ARG_E;
 801d9da:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801d9de:	e0d7      	b.n	801db90 <wc_ecc_verify_hash+0x1e4>
    if (err != 0)
        return err;
    r = key->r;
    s = key->s;
#else
    NEW_MP_INT_SIZE(r, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap,
 801d9e0:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801d9e4:	f001 f94a 	bl	801ec7c <wolfSSL_Malloc>
 801d9e8:	63b8      	str	r0, [r7, #56]	@ 0x38
 801d9ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d9ec:	2b00      	cmp	r3, #0
 801d9ee:	d005      	beq.n	801d9fc <wc_ecc_verify_hash+0x50>
 801d9f0:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801d9f4:	2100      	movs	r1, #0
 801d9f6:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801d9f8:	f00b f914 	bl	8028c24 <memset>
        DYNAMIC_TYPE_ECC);
    #ifdef MP_INT_SIZE_CHECK_NULL
    if (r == NULL)
 801d9fc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d9fe:	2b00      	cmp	r3, #0
 801da00:	d102      	bne.n	801da08 <wc_ecc_verify_hash+0x5c>
        return MEMORY_E;
 801da02:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801da06:	e0c3      	b.n	801db90 <wc_ecc_verify_hash+0x1e4>
    #endif
    NEW_MP_INT_SIZE(s, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap,
 801da08:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801da0c:	f001 f936 	bl	801ec7c <wolfSSL_Malloc>
 801da10:	6378      	str	r0, [r7, #52]	@ 0x34
 801da12:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801da14:	2b00      	cmp	r3, #0
 801da16:	d005      	beq.n	801da24 <wc_ecc_verify_hash+0x78>
 801da18:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801da1c:	2100      	movs	r1, #0
 801da1e:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801da20:	f00b f900 	bl	8028c24 <memset>
        DYNAMIC_TYPE_ECC);
    #ifdef MP_INT_SIZE_CHECK_NULL
    if (s == NULL) {
 801da24:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801da26:	2b00      	cmp	r3, #0
 801da28:	d10a      	bne.n	801da40 <wc_ecc_verify_hash+0x94>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801da2a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801da2c:	613b      	str	r3, [r7, #16]
 801da2e:	693b      	ldr	r3, [r7, #16]
 801da30:	2b00      	cmp	r3, #0
 801da32:	d002      	beq.n	801da3a <wc_ecc_verify_hash+0x8e>
 801da34:	6938      	ldr	r0, [r7, #16]
 801da36:	f001 f93d 	bl	801ecb4 <wolfSSL_Free>
        return MEMORY_E;
 801da3a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801da3e:	e0a7      	b.n	801db90 <wc_ecc_verify_hash+0x1e4>
    }
    #endif
    err = INIT_MP_INT_SIZE(r, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801da40:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801da42:	f008 ffca 	bl	80269da <mp_init>
 801da46:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if (err != 0) {
 801da48:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801da4a:	2b00      	cmp	r3, #0
 801da4c:	d011      	beq.n	801da72 <wc_ecc_verify_hash+0xc6>
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801da4e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801da50:	61bb      	str	r3, [r7, #24]
 801da52:	69bb      	ldr	r3, [r7, #24]
 801da54:	2b00      	cmp	r3, #0
 801da56:	d002      	beq.n	801da5e <wc_ecc_verify_hash+0xb2>
 801da58:	69b8      	ldr	r0, [r7, #24]
 801da5a:	f001 f92b 	bl	801ecb4 <wolfSSL_Free>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801da5e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801da60:	617b      	str	r3, [r7, #20]
 801da62:	697b      	ldr	r3, [r7, #20]
 801da64:	2b00      	cmp	r3, #0
 801da66:	d002      	beq.n	801da6e <wc_ecc_verify_hash+0xc2>
 801da68:	6978      	ldr	r0, [r7, #20]
 801da6a:	f001 f923 	bl	801ecb4 <wolfSSL_Free>
        return err;
 801da6e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801da70:	e08e      	b.n	801db90 <wc_ecc_verify_hash+0x1e4>
    }
    err = INIT_MP_INT_SIZE(s, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801da72:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801da74:	f008 ffb1 	bl	80269da <mp_init>
 801da78:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if (err != 0) {
 801da7a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801da7c:	2b00      	cmp	r3, #0
 801da7e:	d011      	beq.n	801daa4 <wc_ecc_verify_hash+0xf8>
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801da80:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801da82:	623b      	str	r3, [r7, #32]
 801da84:	6a3b      	ldr	r3, [r7, #32]
 801da86:	2b00      	cmp	r3, #0
 801da88:	d002      	beq.n	801da90 <wc_ecc_verify_hash+0xe4>
 801da8a:	6a38      	ldr	r0, [r7, #32]
 801da8c:	f001 f912 	bl	801ecb4 <wolfSSL_Free>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801da90:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801da92:	61fb      	str	r3, [r7, #28]
 801da94:	69fb      	ldr	r3, [r7, #28]
 801da96:	2b00      	cmp	r3, #0
 801da98:	d002      	beq.n	801daa0 <wc_ecc_verify_hash+0xf4>
 801da9a:	69f8      	ldr	r0, [r7, #28]
 801da9c:	f001 f90a 	bl	801ecb4 <wolfSSL_Free>
        return err;
 801daa0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801daa2:	e075      	b.n	801db90 <wc_ecc_verify_hash+0x1e4>
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    switch (key->state) {
 801daa4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801daa6:	689b      	ldr	r3, [r3, #8]
 801daa8:	2b07      	cmp	r3, #7
 801daaa:	d856      	bhi.n	801db5a <wc_ecc_verify_hash+0x1ae>
 801daac:	a201      	add	r2, pc, #4	@ (adr r2, 801dab4 <wc_ecc_verify_hash+0x108>)
 801daae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801dab2:	bf00      	nop
 801dab4:	0801dad5 	.word	0x0801dad5
 801dab8:	0801db5b 	.word	0x0801db5b
 801dabc:	0801db5b 	.word	0x0801db5b
 801dac0:	0801db5b 	.word	0x0801db5b
 801dac4:	0801db5b 	.word	0x0801db5b
 801dac8:	0801dad5 	.word	0x0801dad5
 801dacc:	0801daf9 	.word	0x0801daf9
 801dad0:	0801db4f 	.word	0x0801db4f
        case ECC_STATE_NONE:
        case ECC_STATE_VERIFY_DECODE:
            key->state = ECC_STATE_VERIFY_DECODE;
 801dad4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dad6:	2205      	movs	r2, #5
 801dad8:	609a      	str	r2, [r3, #8]

            /* default to invalid signature */
            *res = 0;
 801dada:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801dadc:	2200      	movs	r2, #0
 801dade:	601a      	str	r2, [r3, #0]
             * the rest of this function will execute, and everything
             * gets cleaned up at the end. */
            err = DecodeECC_DSA_Sig(sig, siglen, r, s);
        #else
            /* r and s are initialized. */
            err = DecodeECC_DSA_Sig_Ex(sig, siglen, r, s, 0);
 801dae0:	2300      	movs	r3, #0
 801dae2:	9300      	str	r3, [sp, #0]
 801dae4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dae6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801dae8:	68b9      	ldr	r1, [r7, #8]
 801daea:	68f8      	ldr	r0, [r7, #12]
 801daec:	f7fc f9d0 	bl	8019e90 <DecodeECC_DSA_Sig_Ex>
 801daf0:	63f8      	str	r0, [r7, #60]	@ 0x3c
        #endif
            if (err < 0) {
 801daf2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801daf4:	2b00      	cmp	r3, #0
 801daf6:	db34      	blt.n	801db62 <wc_ecc_verify_hash+0x1b6>
            mp_read_unsigned_bin(s, sig + keySz, keySz);
    #endif /* !NO_ASN */
            FALL_THROUGH;

        case ECC_STATE_VERIFY_DO:
            key->state = ECC_STATE_VERIFY_DO;
 801daf8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dafa:	2206      	movs	r2, #6
 801dafc:	609a      	str	r2, [r3, #8]
        #ifdef WOLFSSL_ASYNC_CRYPT
            if (key->type == ECC_PRIVATEKEY_ONLY) {
                isPrivateKeyOnly = 1;
            }
        #endif
            err = wc_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
 801dafe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801db00:	9301      	str	r3, [sp, #4]
 801db02:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801db04:	9300      	str	r3, [sp, #0]
 801db06:	683b      	ldr	r3, [r7, #0]
 801db08:	687a      	ldr	r2, [r7, #4]
 801db0a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801db0c:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801db0e:	f000 fa34 	bl	801df7a <wc_ecc_verify_hash_ex>
 801db12:	63f8      	str	r0, [r7, #60]	@ 0x3c

        #ifndef WOLFSSL_ASYNC_CRYPT
            /* done with R/S */
            mp_clear(r);
 801db14:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801db16:	f008 ffea 	bl	8026aee <mp_clear>
            mp_clear(s);
 801db1a:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801db1c:	f008 ffe7 	bl	8026aee <mp_clear>
            FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801db20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801db22:	633b      	str	r3, [r7, #48]	@ 0x30
 801db24:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801db26:	2b00      	cmp	r3, #0
 801db28:	d002      	beq.n	801db30 <wc_ecc_verify_hash+0x184>
 801db2a:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801db2c:	f001 f8c2 	bl	801ecb4 <wolfSSL_Free>
            FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801db30:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801db32:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801db34:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801db36:	2b00      	cmp	r3, #0
 801db38:	d002      	beq.n	801db40 <wc_ecc_verify_hash+0x194>
 801db3a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801db3c:	f001 f8ba 	bl	801ecb4 <wolfSSL_Free>
        #ifdef MP_INT_SIZE_CHECK_NULL
            r = NULL;
 801db40:	2300      	movs	r3, #0
 801db42:	63bb      	str	r3, [r7, #56]	@ 0x38
            s = NULL;
 801db44:	2300      	movs	r3, #0
 801db46:	637b      	str	r3, [r7, #52]	@ 0x34
        #endif
        #endif

            if (err < 0) {
 801db48:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801db4a:	2b00      	cmp	r3, #0
 801db4c:	db0b      	blt.n	801db66 <wc_ecc_verify_hash+0x1ba>
                break;
            }
            FALL_THROUGH;

        case ECC_STATE_VERIFY_RES:
            key->state = ECC_STATE_VERIFY_RES;
 801db4e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801db50:	2207      	movs	r2, #7
 801db52:	609a      	str	r2, [r3, #8]
            err = 0;
 801db54:	2300      	movs	r3, #0
 801db56:	63fb      	str	r3, [r7, #60]	@ 0x3c
            break;
 801db58:	e006      	b.n	801db68 <wc_ecc_verify_hash+0x1bc>

        default:
            err = BAD_STATE_E;
 801db5a:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 801db5e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801db60:	e002      	b.n	801db68 <wc_ecc_verify_hash+0x1bc>
                break;
 801db62:	bf00      	nop
 801db64:	e000      	b.n	801db68 <wc_ecc_verify_hash+0x1bc>
                break;
 801db66:	bf00      	nop

    /* cleanup */
#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
    wc_ecc_free_async(key);
#else
    FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801db68:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801db6a:	62bb      	str	r3, [r7, #40]	@ 0x28
 801db6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801db6e:	2b00      	cmp	r3, #0
 801db70:	d002      	beq.n	801db78 <wc_ecc_verify_hash+0x1cc>
 801db72:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801db74:	f001 f89e 	bl	801ecb4 <wolfSSL_Free>
    FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801db78:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801db7a:	627b      	str	r3, [r7, #36]	@ 0x24
 801db7c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801db7e:	2b00      	cmp	r3, #0
 801db80:	d002      	beq.n	801db88 <wc_ecc_verify_hash+0x1dc>
 801db82:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801db84:	f001 f896 	bl	801ecb4 <wolfSSL_Free>
#endif

    /* make sure required variables are reset */
    wc_ecc_reset(key);
 801db88:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801db8a:	f7ff f8f6 	bl	801cd7a <wc_ecc_reset>
    return err;
 801db8e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
#endif /* !WOLF_CRYPTO_CB_ONLY_ECC */
}
 801db90:	4618      	mov	r0, r3
 801db92:	3740      	adds	r7, #64	@ 0x40
 801db94:	46bd      	mov	sp, r7
 801db96:	bd80      	pop	{r7, pc}

0801db98 <wc_ecc_check_r_s_range>:
#ifndef WOLF_CRYPTO_CB_ONLY_ECC

#if !defined(WOLFSSL_STM32_PKA) && !defined(WOLFSSL_PSOC6_CRYPTO) && \
    !defined(WOLF_CRYPTO_CB_ONLY_ECC)
static int wc_ecc_check_r_s_range(ecc_key* key, mp_int* r, mp_int* s)
{
 801db98:	b580      	push	{r7, lr}
 801db9a:	b094      	sub	sp, #80	@ 0x50
 801db9c:	af00      	add	r7, sp, #0
 801db9e:	60f8      	str	r0, [r7, #12]
 801dba0:	60b9      	str	r1, [r7, #8]
 801dba2:	607a      	str	r2, [r7, #4]
    int err = MP_OKAY;
 801dba4:	2300      	movs	r3, #0
 801dba6:	64fb      	str	r3, [r7, #76]	@ 0x4c
    DECLARE_CURVE_SPECS(1);
 801dba8:	2300      	movs	r3, #0
 801dbaa:	64bb      	str	r3, [r7, #72]	@ 0x48
 801dbac:	f107 0314 	add.w	r3, r7, #20
 801dbb0:	613b      	str	r3, [r7, #16]
 801dbb2:	693b      	ldr	r3, [r7, #16]
 801dbb4:	222c      	movs	r2, #44	@ 0x2c
 801dbb6:	2100      	movs	r1, #0
 801dbb8:	4618      	mov	r0, r3
 801dbba:	f00b f833 	bl	8028c24 <memset>
 801dbbe:	693b      	ldr	r3, [r7, #16]
 801dbc0:	2201      	movs	r2, #1
 801dbc2:	621a      	str	r2, [r3, #32]

    ALLOC_CURVE_SPECS(1, err);
 801dbc4:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801dbc8:	f001 f858 	bl	801ec7c <wolfSSL_Malloc>
 801dbcc:	64b8      	str	r0, [r7, #72]	@ 0x48
 801dbce:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801dbd0:	2b00      	cmp	r3, #0
 801dbd2:	d103      	bne.n	801dbdc <wc_ecc_check_r_s_range+0x44>
 801dbd4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801dbd8:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801dbda:	e002      	b.n	801dbe2 <wc_ecc_check_r_s_range+0x4a>
 801dbdc:	693b      	ldr	r3, [r7, #16]
 801dbde:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801dbe0:	61da      	str	r2, [r3, #28]
    if (err == MP_OKAY) {
 801dbe2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dbe4:	2b00      	cmp	r3, #0
 801dbe6:	d108      	bne.n	801dbfa <wc_ecc_check_r_s_range+0x62>
        err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
 801dbe8:	68fb      	ldr	r3, [r7, #12]
 801dbea:	691b      	ldr	r3, [r3, #16]
 801dbec:	f107 0110 	add.w	r1, r7, #16
 801dbf0:	2208      	movs	r2, #8
 801dbf2:	4618      	mov	r0, r3
 801dbf4:	f7fc ff61 	bl	801aaba <wc_ecc_curve_load>
 801dbf8:	64f8      	str	r0, [r7, #76]	@ 0x4c
    }
    if (err != 0) {
 801dbfa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dbfc:	2b00      	cmp	r3, #0
 801dbfe:	d009      	beq.n	801dc14 <wc_ecc_check_r_s_range+0x7c>
        FREE_CURVE_SPECS();
 801dc00:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801dc02:	643b      	str	r3, [r7, #64]	@ 0x40
 801dc04:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801dc06:	2b00      	cmp	r3, #0
 801dc08:	d002      	beq.n	801dc10 <wc_ecc_check_r_s_range+0x78>
 801dc0a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801dc0c:	f001 f852 	bl	801ecb4 <wolfSSL_Free>
        return err;
 801dc10:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dc12:	e03b      	b.n	801dc8c <wc_ecc_check_r_s_range+0xf4>
    }

    if (mp_iszero(r) || mp_iszero(s)) {
 801dc14:	68b8      	ldr	r0, [r7, #8]
 801dc16:	f009 f93a 	bl	8026e8e <mp_iszero>
 801dc1a:	4603      	mov	r3, r0
 801dc1c:	2b00      	cmp	r3, #0
 801dc1e:	d105      	bne.n	801dc2c <wc_ecc_check_r_s_range+0x94>
 801dc20:	6878      	ldr	r0, [r7, #4]
 801dc22:	f009 f934 	bl	8026e8e <mp_iszero>
 801dc26:	4603      	mov	r3, r0
 801dc28:	2b00      	cmp	r3, #0
 801dc2a:	d002      	beq.n	801dc32 <wc_ecc_check_r_s_range+0x9a>
        err = MP_ZERO_E;
 801dc2c:	f06f 0378 	mvn.w	r3, #120	@ 0x78
 801dc30:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
    if ((err == 0) && (mp_cmp(r, curve->order) != MP_LT)) {
 801dc32:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dc34:	2b00      	cmp	r3, #0
 801dc36:	d10c      	bne.n	801dc52 <wc_ecc_check_r_s_range+0xba>
 801dc38:	693b      	ldr	r3, [r7, #16]
 801dc3a:	691b      	ldr	r3, [r3, #16]
 801dc3c:	4619      	mov	r1, r3
 801dc3e:	68b8      	ldr	r0, [r7, #8]
 801dc40:	f009 f85e 	bl	8026d00 <mp_cmp>
 801dc44:	4603      	mov	r3, r0
 801dc46:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801dc4a:	d002      	beq.n	801dc52 <wc_ecc_check_r_s_range+0xba>
        err = MP_VAL;
 801dc4c:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 801dc50:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
    if ((err == 0) && (mp_cmp(s, curve->order) != MP_LT)) {
 801dc52:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dc54:	2b00      	cmp	r3, #0
 801dc56:	d10c      	bne.n	801dc72 <wc_ecc_check_r_s_range+0xda>
 801dc58:	693b      	ldr	r3, [r7, #16]
 801dc5a:	691b      	ldr	r3, [r3, #16]
 801dc5c:	4619      	mov	r1, r3
 801dc5e:	6878      	ldr	r0, [r7, #4]
 801dc60:	f009 f84e 	bl	8026d00 <mp_cmp>
 801dc64:	4603      	mov	r3, r0
 801dc66:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801dc6a:	d002      	beq.n	801dc72 <wc_ecc_check_r_s_range+0xda>
        err = MP_VAL;
 801dc6c:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 801dc70:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }

    wc_ecc_curve_free(curve);
 801dc72:	693b      	ldr	r3, [r7, #16]
 801dc74:	4618      	mov	r0, r3
 801dc76:	f7fc fed5 	bl	801aa24 <wc_ecc_curve_free>
    FREE_CURVE_SPECS();
 801dc7a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801dc7c:	647b      	str	r3, [r7, #68]	@ 0x44
 801dc7e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc80:	2b00      	cmp	r3, #0
 801dc82:	d002      	beq.n	801dc8a <wc_ecc_check_r_s_range+0xf2>
 801dc84:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801dc86:	f001 f815 	bl	801ecb4 <wolfSSL_Free>
    return err;
 801dc8a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 801dc8c:	4618      	mov	r0, r3
 801dc8e:	3750      	adds	r7, #80	@ 0x50
 801dc90:	46bd      	mov	sp, r7
 801dc92:	bd80      	pop	{r7, pc}

0801dc94 <ecc_verify_hash_sp>:
#endif /* !WOLFSSL_STM32_PKA && !WOLFSSL_PSOC6_CRYPTO */

#ifdef HAVE_ECC_VERIFY_HELPER
static int ecc_verify_hash_sp(mp_int *r, mp_int *s, const byte* hash,
    word32 hashlen, int* res, ecc_key* key)
{
 801dc94:	b480      	push	{r7}
 801dc96:	b085      	sub	sp, #20
 801dc98:	af00      	add	r7, sp, #0
 801dc9a:	60f8      	str	r0, [r7, #12]
 801dc9c:	60b9      	str	r1, [r7, #8]
 801dc9e:	607a      	str	r2, [r7, #4]
 801dca0:	603b      	str	r3, [r7, #0]
        }
    #endif
    }
#endif

    return NOT_COMPILED_IN;
 801dca2:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
}
 801dca6:	4618      	mov	r0, r3
 801dca8:	3714      	adds	r7, #20
 801dcaa:	46bd      	mov	sp, r7
 801dcac:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dcb0:	4770      	bx	lr

0801dcb2 <ecc_verify_hash>:

#if !defined(WOLFSSL_SP_MATH) || defined(FREESCALE_LTC_ECC)
static int ecc_verify_hash(mp_int *r, mp_int *s, const byte* hash,
    word32 hashlen, int* res, ecc_key* key, ecc_curve_spec* curve)
{
 801dcb2:	b5b0      	push	{r4, r5, r7, lr}
 801dcb4:	b096      	sub	sp, #88	@ 0x58
 801dcb6:	af04      	add	r7, sp, #16
 801dcb8:	60f8      	str	r0, [r7, #12]
 801dcba:	60b9      	str	r1, [r7, #8]
 801dcbc:	607a      	str	r2, [r7, #4]
 801dcbe:	603b      	str	r3, [r7, #0]
   int        err;
   ecc_point* mG = NULL;
 801dcc0:	2300      	movs	r3, #0
 801dcc2:	61bb      	str	r3, [r7, #24]
   ecc_point* mQ = NULL;
 801dcc4:	2300      	movs	r3, #0
 801dcc6:	617b      	str	r3, [r7, #20]
#ifdef WOLFSSL_NO_MALLOC
   ecc_point  lcl_mG;
   ecc_point  lcl_mQ;
#endif
   DECL_MP_INT_SIZE_DYN(w, ECC_KEY_MAX_BITS_NONULLCHECK(key), MAX_ECC_BITS_USE);
 801dcc8:	2300      	movs	r3, #0
 801dcca:	637b      	str	r3, [r7, #52]	@ 0x34
#if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
   DECL_MP_INT_SIZE_DYN(e_lcl, ECC_KEY_MAX_BITS_NONULLCHECK(key), MAX_ECC_BITS_USE);
 801dccc:	2300      	movs	r3, #0
 801dcce:	633b      	str	r3, [r7, #48]	@ 0x30
#endif
   mp_int*    e;
   mp_int*    v = NULL;      /* Will be w. */
 801dcd0:	2300      	movs	r3, #0
 801dcd2:	643b      	str	r3, [r7, #64]	@ 0x40
#if defined(WOLFSSL_CHECK_VER_FAULTS) && defined(WOLFSSL_NO_MALLOC)
   mp_int     u1tmp[1];
   mp_int     u2tmp[1];
#endif
   mp_int*    u1 = NULL;     /* Will be e. */
 801dcd4:	2300      	movs	r3, #0
 801dcd6:	63fb      	str	r3, [r7, #60]	@ 0x3c
   mp_int*    u2 = NULL;     /* Will be w. */
 801dcd8:	2300      	movs	r3, #0
 801dcda:	63bb      	str	r3, [r7, #56]	@ 0x38
   }
   e = key->e;

   err = mp_init(e);
#else
   NEW_MP_INT_SIZE(e_lcl, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap, DYNAMIC_TYPE_ECC);
 801dcdc:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801dce0:	f000 ffcc 	bl	801ec7c <wolfSSL_Malloc>
 801dce4:	6338      	str	r0, [r7, #48]	@ 0x30
 801dce6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801dce8:	2b00      	cmp	r3, #0
 801dcea:	d005      	beq.n	801dcf8 <ecc_verify_hash+0x46>
 801dcec:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801dcf0:	2100      	movs	r1, #0
 801dcf2:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801dcf4:	f00a ff96 	bl	8028c24 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
   if (e_lcl == NULL) {
 801dcf8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801dcfa:	2b00      	cmp	r3, #0
 801dcfc:	d102      	bne.n	801dd04 <ecc_verify_hash+0x52>
       return MEMORY_E;
 801dcfe:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801dd02:	e136      	b.n	801df72 <ecc_verify_hash+0x2c0>
   }
#endif
   e = e_lcl;
 801dd04:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801dd06:	62fb      	str	r3, [r7, #44]	@ 0x2c

   err = INIT_MP_INT_SIZE(e, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801dd08:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dd0a:	f008 fe66 	bl	80269da <mp_init>
 801dd0e:	6478      	str	r0, [r7, #68]	@ 0x44
#endif /* WOLFSSL_ASYNC_CRYPT && HAVE_CAVIUM_V */
   if (err != MP_OKAY) {
 801dd10:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd12:	2b00      	cmp	r3, #0
 801dd14:	d00a      	beq.n	801dd2c <ecc_verify_hash+0x7a>
#ifdef WOLFSSL_SMALL_STACK
   #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
      XFREE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
 801dd16:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801dd18:	61fb      	str	r3, [r7, #28]
 801dd1a:	69fb      	ldr	r3, [r7, #28]
 801dd1c:	2b00      	cmp	r3, #0
 801dd1e:	d002      	beq.n	801dd26 <ecc_verify_hash+0x74>
 801dd20:	69f8      	ldr	r0, [r7, #28]
 801dd22:	f000 ffc7 	bl	801ecb4 <wolfSSL_Free>
   #endif
#endif
      return MEMORY_E;
 801dd26:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801dd2a:	e122      	b.n	801df72 <ecc_verify_hash+0x2c0>
   }

   /* read hash */
   if (err == MP_OKAY) {
 801dd2c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd2e:	2b00      	cmp	r3, #0
 801dd30:	d127      	bne.n	801dd82 <ecc_verify_hash+0xd0>
       /* we may need to truncate if hash is longer than key size */
       unsigned int orderBits = (unsigned int)mp_count_bits(curve->order);
 801dd32:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dd34:	691b      	ldr	r3, [r3, #16]
 801dd36:	4618      	mov	r0, r3
 801dd38:	f009 f8ba 	bl	8026eb0 <mp_count_bits>
 801dd3c:	4603      	mov	r3, r0
 801dd3e:	62bb      	str	r3, [r7, #40]	@ 0x28

       /* truncate down to byte size, may be all that's needed */
       if ( (WOLFSSL_BIT_SIZE * hashlen) > orderBits)
 801dd40:	683b      	ldr	r3, [r7, #0]
 801dd42:	00db      	lsls	r3, r3, #3
 801dd44:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801dd46:	429a      	cmp	r2, r3
 801dd48:	d203      	bcs.n	801dd52 <ecc_verify_hash+0xa0>
           hashlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;
 801dd4a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801dd4c:	3307      	adds	r3, #7
 801dd4e:	08db      	lsrs	r3, r3, #3
 801dd50:	603b      	str	r3, [r7, #0]
       err = mp_read_unsigned_bin(e, hash, hashlen);
 801dd52:	683b      	ldr	r3, [r7, #0]
 801dd54:	461a      	mov	r2, r3
 801dd56:	6879      	ldr	r1, [r7, #4]
 801dd58:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dd5a:	f009 f817 	bl	8026d8c <mp_read_unsigned_bin>
 801dd5e:	6478      	str	r0, [r7, #68]	@ 0x44

       /* may still need bit truncation too */
       if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * hashlen) > orderBits)
 801dd60:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd62:	2b00      	cmp	r3, #0
 801dd64:	d10d      	bne.n	801dd82 <ecc_verify_hash+0xd0>
 801dd66:	683b      	ldr	r3, [r7, #0]
 801dd68:	00db      	lsls	r3, r3, #3
 801dd6a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801dd6c:	429a      	cmp	r2, r3
 801dd6e:	d208      	bcs.n	801dd82 <ecc_verify_hash+0xd0>
           mp_rshb(e, (int)(WOLFSSL_BIT_SIZE - (orderBits & 0x7)));
 801dd70:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801dd72:	f003 0307 	and.w	r3, r3, #7
 801dd76:	f1c3 0308 	rsb	r3, r3, #8
 801dd7a:	4619      	mov	r1, r3
 801dd7c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dd7e:	f009 f8af 	bl	8026ee0 <mp_rshb>
      }
   #endif /* HAVE_CAVIUM_V || HAVE_INTEL_QA */
   }
#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */

   NEW_MP_INT_SIZE(w, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap, DYNAMIC_TYPE_ECC);
 801dd82:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801dd86:	f000 ff79 	bl	801ec7c <wolfSSL_Malloc>
 801dd8a:	6378      	str	r0, [r7, #52]	@ 0x34
 801dd8c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dd8e:	2b00      	cmp	r3, #0
 801dd90:	d005      	beq.n	801dd9e <ecc_verify_hash+0xec>
 801dd92:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801dd96:	2100      	movs	r1, #0
 801dd98:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dd9a:	f00a ff43 	bl	8028c24 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
   if (w == NULL) {
 801dd9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dda0:	2b00      	cmp	r3, #0
 801dda2:	d102      	bne.n	801ddaa <ecc_verify_hash+0xf8>
       err = MEMORY_E;
 801dda4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801dda8:	647b      	str	r3, [r7, #68]	@ 0x44
   }
#endif

   if (err == MP_OKAY) {
 801ddaa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ddac:	2b00      	cmp	r3, #0
 801ddae:	d105      	bne.n	801ddbc <ecc_verify_hash+0x10a>
    #else
        u1 = u1tmp;
        u2 = u2tmp;
    #endif
#else
       u1 = e;
 801ddb0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ddb2:	63fb      	str	r3, [r7, #60]	@ 0x3c
       u2 = w;
 801ddb4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ddb6:	63bb      	str	r3, [r7, #56]	@ 0x38
#endif
       v = w;
 801ddb8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ddba:	643b      	str	r3, [r7, #64]	@ 0x40
   }
   if (err == MP_OKAY) {
 801ddbc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ddbe:	2b00      	cmp	r3, #0
 801ddc0:	d103      	bne.n	801ddca <ecc_verify_hash+0x118>
       err = INIT_MP_INT_SIZE(w, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801ddc2:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801ddc4:	f008 fe09 	bl	80269da <mp_init>
 801ddc8:	6478      	str	r0, [r7, #68]	@ 0x44
       err = INIT_MP_INT_SIZE(u2, ECC_KEY_MAX_BITS_NONULLCHECK(key));
   }
#endif

   /* allocate points */
   if (err == MP_OKAY) {
 801ddca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ddcc:	2b00      	cmp	r3, #0
 801ddce:	d108      	bne.n	801dde2 <ecc_verify_hash+0x130>
   #ifdef WOLFSSL_NO_MALLOC
       mG = &lcl_mG;
   #endif
       err = wc_ecc_new_point_ex(&mG, key->heap);
 801ddd0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ddd2:	695a      	ldr	r2, [r3, #20]
 801ddd4:	f107 0318 	add.w	r3, r7, #24
 801ddd8:	4611      	mov	r1, r2
 801ddda:	4618      	mov	r0, r3
 801dddc:	f7fe fe2f 	bl	801ca3e <wc_ecc_new_point_ex>
 801dde0:	6478      	str	r0, [r7, #68]	@ 0x44
   }
   if (err == MP_OKAY) {
 801dde2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dde4:	2b00      	cmp	r3, #0
 801dde6:	d108      	bne.n	801ddfa <ecc_verify_hash+0x148>
   #ifdef WOLFSSL_NO_MALLOC
       mQ = &lcl_mQ;
   #endif
       err = wc_ecc_new_point_ex(&mQ, key->heap);
 801dde8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ddea:	695a      	ldr	r2, [r3, #20]
 801ddec:	f107 0314 	add.w	r3, r7, #20
 801ddf0:	4611      	mov	r1, r2
 801ddf2:	4618      	mov	r0, r3
 801ddf4:	f7fe fe23 	bl	801ca3e <wc_ecc_new_point_ex>
 801ddf8:	6478      	str	r0, [r7, #68]	@ 0x44
   }

   /*  w  = s^-1 mod n */
   if (err == MP_OKAY)
 801ddfa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ddfc:	2b00      	cmp	r3, #0
 801ddfe:	d107      	bne.n	801de10 <ecc_verify_hash+0x15e>
       err = mp_invmod(s, curve->order, w);
 801de00:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801de02:	691b      	ldr	r3, [r3, #16]
 801de04:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801de06:	4619      	mov	r1, r3
 801de08:	68b8      	ldr	r0, [r7, #8]
 801de0a:	f008 ff33 	bl	8026c74 <mp_invmod>
 801de0e:	6478      	str	r0, [r7, #68]	@ 0x44

   /* u1 = ew */
   if (err == MP_OKAY)
 801de10:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801de12:	2b00      	cmp	r3, #0
 801de14:	d107      	bne.n	801de26 <ecc_verify_hash+0x174>
       err = mp_mulmod(e, w, curve->order, u1);
 801de16:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801de18:	691a      	ldr	r2, [r3, #16]
 801de1a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801de1c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801de1e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801de20:	f008 fedf 	bl	8026be2 <mp_mulmod>
 801de24:	6478      	str	r0, [r7, #68]	@ 0x44
        err = BAD_STATE_E;
    }
#endif

   /* u2 = rw */
   if (err == MP_OKAY)
 801de26:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801de28:	2b00      	cmp	r3, #0
 801de2a:	d107      	bne.n	801de3c <ecc_verify_hash+0x18a>
       err = mp_mulmod(r, w, curve->order, u2);
 801de2c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801de2e:	691a      	ldr	r2, [r3, #16]
 801de30:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801de32:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801de34:	68f8      	ldr	r0, [r7, #12]
 801de36:	f008 fed4 	bl	8026be2 <mp_mulmod>
 801de3a:	6478      	str	r0, [r7, #68]	@ 0x44
        err = BAD_STATE_E;
    }
#endif

   /* find mG and mQ */
   if (err == MP_OKAY)
 801de3c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801de3e:	2b00      	cmp	r3, #0
 801de40:	d108      	bne.n	801de54 <ecc_verify_hash+0x1a2>
       err = mp_copy(curve->Gx, mG->x);
 801de42:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801de44:	695a      	ldr	r2, [r3, #20]
 801de46:	69bb      	ldr	r3, [r7, #24]
 801de48:	681b      	ldr	r3, [r3, #0]
 801de4a:	4619      	mov	r1, r3
 801de4c:	4610      	mov	r0, r2
 801de4e:	f009 f810 	bl	8026e72 <mp_copy>
 801de52:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801de54:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801de56:	2b00      	cmp	r3, #0
 801de58:	d108      	bne.n	801de6c <ecc_verify_hash+0x1ba>
       err = mp_copy(curve->Gy, mG->y);
 801de5a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801de5c:	699a      	ldr	r2, [r3, #24]
 801de5e:	69bb      	ldr	r3, [r7, #24]
 801de60:	685b      	ldr	r3, [r3, #4]
 801de62:	4619      	mov	r1, r3
 801de64:	4610      	mov	r0, r2
 801de66:	f009 f804 	bl	8026e72 <mp_copy>
 801de6a:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801de6c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801de6e:	2b00      	cmp	r3, #0
 801de70:	d106      	bne.n	801de80 <ecc_verify_hash+0x1ce>
       err = mp_set(mG->z, 1);
 801de72:	69bb      	ldr	r3, [r7, #24]
 801de74:	689b      	ldr	r3, [r3, #8]
 801de76:	2101      	movs	r1, #1
 801de78:	4618      	mov	r0, r3
 801de7a:	f009 fab7 	bl	80273ec <mp_set>
 801de7e:	6478      	str	r0, [r7, #68]	@ 0x44

   if (err == MP_OKAY)
 801de80:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801de82:	2b00      	cmp	r3, #0
 801de84:	d108      	bne.n	801de98 <ecc_verify_hash+0x1e6>
       err = mp_copy(key->pubkey.x, mQ->x);
 801de86:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801de88:	699a      	ldr	r2, [r3, #24]
 801de8a:	697b      	ldr	r3, [r7, #20]
 801de8c:	681b      	ldr	r3, [r3, #0]
 801de8e:	4619      	mov	r1, r3
 801de90:	4610      	mov	r0, r2
 801de92:	f008 ffee 	bl	8026e72 <mp_copy>
 801de96:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801de98:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801de9a:	2b00      	cmp	r3, #0
 801de9c:	d108      	bne.n	801deb0 <ecc_verify_hash+0x1fe>
       err = mp_copy(key->pubkey.y, mQ->y);
 801de9e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dea0:	69da      	ldr	r2, [r3, #28]
 801dea2:	697b      	ldr	r3, [r7, #20]
 801dea4:	685b      	ldr	r3, [r3, #4]
 801dea6:	4619      	mov	r1, r3
 801dea8:	4610      	mov	r0, r2
 801deaa:	f008 ffe2 	bl	8026e72 <mp_copy>
 801deae:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801deb0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801deb2:	2b00      	cmp	r3, #0
 801deb4:	d108      	bne.n	801dec8 <ecc_verify_hash+0x216>
       err = mp_copy(key->pubkey.z, mQ->z);
 801deb6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801deb8:	6a1a      	ldr	r2, [r3, #32]
 801deba:	697b      	ldr	r3, [r7, #20]
 801debc:	689b      	ldr	r3, [r3, #8]
 801debe:	4619      	mov	r1, r3
 801dec0:	4610      	mov	r0, r2
 801dec2:	f008 ffd6 	bl	8026e72 <mp_copy>
 801dec6:	6478      	str	r0, [r7, #68]	@ 0x44
        if (err == MP_OKAY)
            err = ecc_map(mG, curve->prime, mp);
    }
#else
    /* use Shamir's trick to compute u1*mG + u2*mQ using half the doubles */
    if (err == MP_OKAY) {
 801dec8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801deca:	2b00      	cmp	r3, #0
 801decc:	d113      	bne.n	801def6 <ecc_verify_hash+0x244>
        err = ecc_mul2add(mG, u1, mQ, u2, mG, curve->Af, curve->prime,
 801dece:	69bc      	ldr	r4, [r7, #24]
 801ded0:	697d      	ldr	r5, [r7, #20]
 801ded2:	69bb      	ldr	r3, [r7, #24]
 801ded4:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 801ded6:	6892      	ldr	r2, [r2, #8]
 801ded8:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 801deda:	6849      	ldr	r1, [r1, #4]
 801dedc:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801dede:	6940      	ldr	r0, [r0, #20]
 801dee0:	9003      	str	r0, [sp, #12]
 801dee2:	9102      	str	r1, [sp, #8]
 801dee4:	9201      	str	r2, [sp, #4]
 801dee6:	9300      	str	r3, [sp, #0]
 801dee8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801deea:	462a      	mov	r2, r5
 801deec:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 801deee:	4620      	mov	r0, r4
 801def0:	f7ff face 	bl	801d490 <ecc_mul2add>
 801def4:	6478      	str	r0, [r7, #68]	@ 0x44
    }
#endif /* ECC_SHAMIR */
#endif /* FREESCALE_LTC_ECC */

   /* v = X_x1 mod n */
   if (err == MP_OKAY)
 801def6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801def8:	2b00      	cmp	r3, #0
 801defa:	d108      	bne.n	801df0e <ecc_verify_hash+0x25c>
       err = mp_mod(mG->x, curve->order, v);
 801defc:	69bb      	ldr	r3, [r7, #24]
 801defe:	6818      	ldr	r0, [r3, #0]
 801df00:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801df02:	691b      	ldr	r3, [r3, #16]
 801df04:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801df06:	4619      	mov	r1, r3
 801df08:	f008 fea4 	bl	8026c54 <mp_mod>
 801df0c:	6478      	str	r0, [r7, #68]	@ 0x44

   /* does v == r */
   if (err == MP_OKAY) {
 801df0e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801df10:	2b00      	cmp	r3, #0
 801df12:	d109      	bne.n	801df28 <ecc_verify_hash+0x276>
       if (mp_cmp(v, r) == MP_EQ)
 801df14:	68f9      	ldr	r1, [r7, #12]
 801df16:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801df18:	f008 fef2 	bl	8026d00 <mp_cmp>
 801df1c:	4603      	mov	r3, r0
 801df1e:	2b00      	cmp	r3, #0
 801df20:	d102      	bne.n	801df28 <ecc_verify_hash+0x276>
           *res = 1;
 801df22:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801df24:	2201      	movs	r2, #1
 801df26:	601a      	str	r2, [r3, #0]
           *res = 0;
#endif
   }

   /* cleanup */
   wc_ecc_del_point_ex(mG, key->heap);
 801df28:	69ba      	ldr	r2, [r7, #24]
 801df2a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801df2c:	695b      	ldr	r3, [r3, #20]
 801df2e:	4619      	mov	r1, r3
 801df30:	4610      	mov	r0, r2
 801df32:	f7fe fdd9 	bl	801cae8 <wc_ecc_del_point_ex>
   wc_ecc_del_point_ex(mQ, key->heap);
 801df36:	697a      	ldr	r2, [r7, #20]
 801df38:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801df3a:	695b      	ldr	r3, [r3, #20]
 801df3c:	4619      	mov	r1, r3
 801df3e:	4610      	mov	r0, r2
 801df40:	f7fe fdd2 	bl	801cae8 <wc_ecc_del_point_ex>

   mp_clear(e);
 801df44:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801df46:	f008 fdd2 	bl	8026aee <mp_clear>
   mp_clear(w);
 801df4a:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801df4c:	f008 fdcf 	bl	8026aee <mp_clear>
   FREE_MP_INT_SIZE(w, key->heap, DYNAMIC_TYPE_ECC);
 801df50:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801df52:	627b      	str	r3, [r7, #36]	@ 0x24
 801df54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801df56:	2b00      	cmp	r3, #0
 801df58:	d002      	beq.n	801df60 <ecc_verify_hash+0x2ae>
 801df5a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801df5c:	f000 feaa 	bl	801ecb4 <wolfSSL_Free>
   XFREE(u1, key->heap, DYNAMIC_TYPE_ECC);
   XFREE(u2, key->heap, DYNAMIC_TYPE_ECC);
#endif
#endif
#if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
   FREE_MP_INT_SIZE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
 801df60:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801df62:	623b      	str	r3, [r7, #32]
 801df64:	6a3b      	ldr	r3, [r7, #32]
 801df66:	2b00      	cmp	r3, #0
 801df68:	d002      	beq.n	801df70 <ecc_verify_hash+0x2be>
 801df6a:	6a38      	ldr	r0, [r7, #32]
 801df6c:	f000 fea2 	bl	801ecb4 <wolfSSL_Free>
#endif

   return err;
 801df70:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 801df72:	4618      	mov	r0, r3
 801df74:	3748      	adds	r7, #72	@ 0x48
 801df76:	46bd      	mov	sp, r7
 801df78:	bdb0      	pop	{r4, r5, r7, pc}

0801df7a <wc_ecc_verify_hash_ex>:
               Caller should check the *res value to determine if the signature
               is valid or invalid. Other negative values are returned on error.
*/
int wc_ecc_verify_hash_ex(mp_int *r, mp_int *s, const byte* hash,
                    word32 hashlen, int* res, ecc_key* key)
{
 801df7a:	b580      	push	{r7, lr}
 801df7c:	b09e      	sub	sp, #120	@ 0x78
 801df7e:	af04      	add	r7, sp, #16
 801df80:	60f8      	str	r0, [r7, #12]
 801df82:	60b9      	str	r1, [r7, #8]
 801df84:	607a      	str	r2, [r7, #4]
 801df86:	603b      	str	r3, [r7, #0]
    return stm32_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
#elif defined(WOLFSSL_PSOC6_CRYPTO)
    return psoc6_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
#else
   int           err;
   word32        keySz = 0;
 801df88:	2300      	movs	r3, #0
 801df8a:	65bb      	str	r3, [r7, #88]	@ 0x58
   byte sigRS[MAX_ECC_BYTES*2];
#elif defined(WOLFSSL_XILINX_CRYPT_VERSAL)
   byte sigRS[ECC_MAX_CRYPTO_HW_SIZE * 2];
   byte hashcopy[ECC_MAX_CRYPTO_HW_SIZE] = {0};
#else
   int curveLoaded = 0;
 801df8c:	2300      	movs	r3, #0
 801df8e:	663b      	str	r3, [r7, #96]	@ 0x60
   DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
 801df90:	2300      	movs	r3, #0
 801df92:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801df94:	f107 0318 	add.w	r3, r7, #24
 801df98:	617b      	str	r3, [r7, #20]
 801df9a:	697b      	ldr	r3, [r7, #20]
 801df9c:	222c      	movs	r2, #44	@ 0x2c
 801df9e:	2100      	movs	r1, #0
 801dfa0:	4618      	mov	r0, r3
 801dfa2:	f00a fe3f 	bl	8028c24 <memset>
 801dfa6:	697b      	ldr	r3, [r7, #20]
 801dfa8:	2206      	movs	r2, #6
 801dfaa:	621a      	str	r2, [r3, #32]
#endif

   if (r == NULL || s == NULL || hash == NULL || res == NULL || key == NULL)
 801dfac:	68fb      	ldr	r3, [r7, #12]
 801dfae:	2b00      	cmp	r3, #0
 801dfb0:	d00b      	beq.n	801dfca <wc_ecc_verify_hash_ex+0x50>
 801dfb2:	68bb      	ldr	r3, [r7, #8]
 801dfb4:	2b00      	cmp	r3, #0
 801dfb6:	d008      	beq.n	801dfca <wc_ecc_verify_hash_ex+0x50>
 801dfb8:	687b      	ldr	r3, [r7, #4]
 801dfba:	2b00      	cmp	r3, #0
 801dfbc:	d005      	beq.n	801dfca <wc_ecc_verify_hash_ex+0x50>
 801dfbe:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801dfc0:	2b00      	cmp	r3, #0
 801dfc2:	d002      	beq.n	801dfca <wc_ecc_verify_hash_ex+0x50>
 801dfc4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801dfc6:	2b00      	cmp	r3, #0
 801dfc8:	d102      	bne.n	801dfd0 <wc_ecc_verify_hash_ex+0x56>
       return ECC_BAD_ARG_E;
 801dfca:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801dfce:	e0d1      	b.n	801e174 <wc_ecc_verify_hash_ex+0x1fa>

   /* default to invalid signature */
   *res = 0;
 801dfd0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801dfd2:	2200      	movs	r2, #0
 801dfd4:	601a      	str	r2, [r3, #0]

   /* is the IDX valid ?  */
   if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {
 801dfd6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801dfd8:	685b      	ldr	r3, [r3, #4]
 801dfda:	4618      	mov	r0, r3
 801dfdc:	f7fe fdf8 	bl	801cbd0 <wc_ecc_is_valid_idx>
 801dfe0:	4603      	mov	r3, r0
 801dfe2:	2b00      	cmp	r3, #0
 801dfe4:	d003      	beq.n	801dfee <wc_ecc_verify_hash_ex+0x74>
 801dfe6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801dfe8:	691b      	ldr	r3, [r3, #16]
 801dfea:	2b00      	cmp	r3, #0
 801dfec:	d102      	bne.n	801dff4 <wc_ecc_verify_hash_ex+0x7a>
      return ECC_BAD_ARG_E;
 801dfee:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801dff2:	e0bf      	b.n	801e174 <wc_ecc_verify_hash_ex+0x1fa>
   }

   err = wc_ecc_check_r_s_range(key, r, s);
 801dff4:	68ba      	ldr	r2, [r7, #8]
 801dff6:	68f9      	ldr	r1, [r7, #12]
 801dff8:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801dffa:	f7ff fdcd 	bl	801db98 <wc_ecc_check_r_s_range>
 801dffe:	6678      	str	r0, [r7, #100]	@ 0x64
   if (err != MP_OKAY) {
 801e000:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e002:	2b00      	cmp	r3, #0
 801e004:	d001      	beq.n	801e00a <wc_ecc_verify_hash_ex+0x90>
      return err;
 801e006:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e008:	e0b4      	b.n	801e174 <wc_ecc_verify_hash_ex+0x1fa>
   }

   keySz = (word32)key->dp->size;
 801e00a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e00c:	691b      	ldr	r3, [r3, #16]
 801e00e:	681b      	ldr	r3, [r3, #0]
 801e010:	65bb      	str	r3, [r7, #88]	@ 0x58
    }
#endif

#else
  /* checking if private key with no public part */
  if (key->type == ECC_PRIVATEKEY_ONLY) {
 801e012:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e014:	681b      	ldr	r3, [r3, #0]
 801e016:	2b03      	cmp	r3, #3
 801e018:	d143      	bne.n	801e0a2 <wc_ecc_verify_hash_ex+0x128>
      WOLFSSL_MSG("Verify called with private key, generating public part");
      ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 801e01a:	f640 5008 	movw	r0, #3336	@ 0xd08
 801e01e:	f000 fe2d 	bl	801ec7c <wolfSSL_Malloc>
 801e022:	65f8      	str	r0, [r7, #92]	@ 0x5c
 801e024:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e026:	2b00      	cmp	r3, #0
 801e028:	d103      	bne.n	801e032 <wc_ecc_verify_hash_ex+0xb8>
 801e02a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e02e:	667b      	str	r3, [r7, #100]	@ 0x64
 801e030:	e002      	b.n	801e038 <wc_ecc_verify_hash_ex+0xbe>
 801e032:	697b      	ldr	r3, [r7, #20]
 801e034:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801e036:	61da      	str	r2, [r3, #28]
      if (err != MP_OKAY) {
 801e038:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e03a:	2b00      	cmp	r3, #0
 801e03c:	d001      	beq.n	801e042 <wc_ecc_verify_hash_ex+0xc8>
          return err;
 801e03e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e040:	e098      	b.n	801e174 <wc_ecc_verify_hash_ex+0x1fa>
      }
      err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 801e042:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e044:	691b      	ldr	r3, [r3, #16]
 801e046:	f107 0114 	add.w	r1, r7, #20
 801e04a:	223f      	movs	r2, #63	@ 0x3f
 801e04c:	4618      	mov	r0, r3
 801e04e:	f7fc fd34 	bl	801aaba <wc_ecc_curve_load>
 801e052:	6678      	str	r0, [r7, #100]	@ 0x64
      if (err != MP_OKAY) {
 801e054:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e056:	2b00      	cmp	r3, #0
 801e058:	d009      	beq.n	801e06e <wc_ecc_verify_hash_ex+0xf4>
          FREE_CURVE_SPECS();
 801e05a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e05c:	653b      	str	r3, [r7, #80]	@ 0x50
 801e05e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801e060:	2b00      	cmp	r3, #0
 801e062:	d002      	beq.n	801e06a <wc_ecc_verify_hash_ex+0xf0>
 801e064:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801e066:	f000 fe25 	bl	801ecb4 <wolfSSL_Free>
          return err;
 801e06a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e06c:	e082      	b.n	801e174 <wc_ecc_verify_hash_ex+0x1fa>
      }
      err = ecc_make_pub_ex(key, curve, NULL, NULL);
 801e06e:	6979      	ldr	r1, [r7, #20]
 801e070:	2300      	movs	r3, #0
 801e072:	2200      	movs	r2, #0
 801e074:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801e076:	f7fe fe8d 	bl	801cd94 <ecc_make_pub_ex>
 801e07a:	6678      	str	r0, [r7, #100]	@ 0x64
      if (err != MP_OKAY) {
 801e07c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e07e:	2b00      	cmp	r3, #0
 801e080:	d00d      	beq.n	801e09e <wc_ecc_verify_hash_ex+0x124>
           WOLFSSL_MSG("Unable to extract public key");
           wc_ecc_curve_free(curve);
 801e082:	697b      	ldr	r3, [r7, #20]
 801e084:	4618      	mov	r0, r3
 801e086:	f7fc fccd 	bl	801aa24 <wc_ecc_curve_free>
           FREE_CURVE_SPECS();
 801e08a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e08c:	657b      	str	r3, [r7, #84]	@ 0x54
 801e08e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801e090:	2b00      	cmp	r3, #0
 801e092:	d002      	beq.n	801e09a <wc_ecc_verify_hash_ex+0x120>
 801e094:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801e096:	f000 fe0d 	bl	801ecb4 <wolfSSL_Free>
           return err;
 801e09a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e09c:	e06a      	b.n	801e174 <wc_ecc_verify_hash_ex+0x1fa>
      }
      curveLoaded = 1;
 801e09e:	2301      	movs	r3, #1
 801e0a0:	663b      	str	r3, [r7, #96]	@ 0x60
  }

  err = ecc_verify_hash_sp(r, s, hash, hashlen, res, key);
 801e0a2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e0a4:	9301      	str	r3, [sp, #4]
 801e0a6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801e0a8:	9300      	str	r3, [sp, #0]
 801e0aa:	683b      	ldr	r3, [r7, #0]
 801e0ac:	687a      	ldr	r2, [r7, #4]
 801e0ae:	68b9      	ldr	r1, [r7, #8]
 801e0b0:	68f8      	ldr	r0, [r7, #12]
 801e0b2:	f7ff fdef 	bl	801dc94 <ecc_verify_hash_sp>
 801e0b6:	6678      	str	r0, [r7, #100]	@ 0x64
  if (err != WC_NO_ERR_TRACE(NOT_COMPILED_IN)) {
 801e0b8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e0ba:	f113 0fae 	cmn.w	r3, #174	@ 0xae
 801e0be:	d010      	beq.n	801e0e2 <wc_ecc_verify_hash_ex+0x168>
      if (curveLoaded) {
 801e0c0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801e0c2:	2b00      	cmp	r3, #0
 801e0c4:	d00b      	beq.n	801e0de <wc_ecc_verify_hash_ex+0x164>
           wc_ecc_curve_free(curve);
 801e0c6:	697b      	ldr	r3, [r7, #20]
 801e0c8:	4618      	mov	r0, r3
 801e0ca:	f7fc fcab 	bl	801aa24 <wc_ecc_curve_free>
           FREE_CURVE_SPECS();
 801e0ce:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e0d0:	647b      	str	r3, [r7, #68]	@ 0x44
 801e0d2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801e0d4:	2b00      	cmp	r3, #0
 801e0d6:	d002      	beq.n	801e0de <wc_ecc_verify_hash_ex+0x164>
 801e0d8:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801e0da:	f000 fdeb 	bl	801ecb4 <wolfSSL_Free>
      }
      return err;
 801e0de:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e0e0:	e048      	b.n	801e174 <wc_ecc_verify_hash_ex+0x1fa>
  }

#if !defined(WOLFSSL_SP_MATH) || defined(FREESCALE_LTC_ECC)
   if (!curveLoaded) {
 801e0e2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801e0e4:	2b00      	cmp	r3, #0
 801e0e6:	d12b      	bne.n	801e140 <wc_ecc_verify_hash_ex+0x1c6>
       err = 0; /* potential for NOT_COMPILED_IN error from SP attempt */
 801e0e8:	2300      	movs	r3, #0
 801e0ea:	667b      	str	r3, [r7, #100]	@ 0x64
       ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 801e0ec:	f640 5008 	movw	r0, #3336	@ 0xd08
 801e0f0:	f000 fdc4 	bl	801ec7c <wolfSSL_Malloc>
 801e0f4:	65f8      	str	r0, [r7, #92]	@ 0x5c
 801e0f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e0f8:	2b00      	cmp	r3, #0
 801e0fa:	d103      	bne.n	801e104 <wc_ecc_verify_hash_ex+0x18a>
 801e0fc:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e100:	667b      	str	r3, [r7, #100]	@ 0x64
 801e102:	e002      	b.n	801e10a <wc_ecc_verify_hash_ex+0x190>
 801e104:	697b      	ldr	r3, [r7, #20]
 801e106:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801e108:	61da      	str	r2, [r3, #28]
       if (err != 0) {
 801e10a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e10c:	2b00      	cmp	r3, #0
 801e10e:	d001      	beq.n	801e114 <wc_ecc_verify_hash_ex+0x19a>
          return err;
 801e110:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e112:	e02f      	b.n	801e174 <wc_ecc_verify_hash_ex+0x1fa>
       }
       /* read in the specs for this curve */
       err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 801e114:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e116:	691b      	ldr	r3, [r3, #16]
 801e118:	f107 0114 	add.w	r1, r7, #20
 801e11c:	223f      	movs	r2, #63	@ 0x3f
 801e11e:	4618      	mov	r0, r3
 801e120:	f7fc fccb 	bl	801aaba <wc_ecc_curve_load>
 801e124:	6678      	str	r0, [r7, #100]	@ 0x64
       if (err != 0) {
 801e126:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e128:	2b00      	cmp	r3, #0
 801e12a:	d009      	beq.n	801e140 <wc_ecc_verify_hash_ex+0x1c6>
          FREE_CURVE_SPECS();
 801e12c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e12e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801e130:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801e132:	2b00      	cmp	r3, #0
 801e134:	d002      	beq.n	801e13c <wc_ecc_verify_hash_ex+0x1c2>
 801e136:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801e138:	f000 fdbc 	bl	801ecb4 <wolfSSL_Free>
          return err;
 801e13c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e13e:	e019      	b.n	801e174 <wc_ecc_verify_hash_ex+0x1fa>
       }
   }

   err = ecc_verify_hash(r, s, hash, hashlen, res, key, curve);
 801e140:	697b      	ldr	r3, [r7, #20]
 801e142:	9302      	str	r3, [sp, #8]
 801e144:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e146:	9301      	str	r3, [sp, #4]
 801e148:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801e14a:	9300      	str	r3, [sp, #0]
 801e14c:	683b      	ldr	r3, [r7, #0]
 801e14e:	687a      	ldr	r2, [r7, #4]
 801e150:	68b9      	ldr	r1, [r7, #8]
 801e152:	68f8      	ldr	r0, [r7, #12]
 801e154:	f7ff fdad 	bl	801dcb2 <ecc_verify_hash>
 801e158:	6678      	str	r0, [r7, #100]	@ 0x64
#endif /* !WOLFSSL_SP_MATH || FREESCALE_LTC_ECC */

   (void)curveLoaded;
   wc_ecc_curve_free(curve);
 801e15a:	697b      	ldr	r3, [r7, #20]
 801e15c:	4618      	mov	r0, r3
 801e15e:	f7fc fc61 	bl	801aa24 <wc_ecc_curve_free>
   FREE_CURVE_SPECS();
 801e162:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e164:	64bb      	str	r3, [r7, #72]	@ 0x48
 801e166:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801e168:	2b00      	cmp	r3, #0
 801e16a:	d002      	beq.n	801e172 <wc_ecc_verify_hash_ex+0x1f8>
 801e16c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801e16e:	f000 fda1 	bl	801ecb4 <wolfSSL_Free>
#endif /* HAVE_ECC_VERIFY_HELPER */

   (void)keySz;
   (void)hashlen;

   return err;
 801e172:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
#endif /* WOLFSSL_STM32_PKA */
}
 801e174:	4618      	mov	r0, r3
 801e176:	3768      	adds	r7, #104	@ 0x68
 801e178:	46bd      	mov	sp, r7
 801e17a:	bd80      	pop	{r7, pc}

0801e17c <wc_ecc_import_x963_ex>:

#ifdef HAVE_ECC_KEY_IMPORT
/* import public ECC key in ANSI X9.63 format */
int wc_ecc_import_x963_ex(const byte* in, word32 inLen, ecc_key* key,
                          int curve_id)
{
 801e17c:	b580      	push	{r7, lr}
 801e17e:	b088      	sub	sp, #32
 801e180:	af00      	add	r7, sp, #0
 801e182:	60f8      	str	r0, [r7, #12]
 801e184:	60b9      	str	r1, [r7, #8]
 801e186:	607a      	str	r2, [r7, #4]
 801e188:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801e18a:	2300      	movs	r3, #0
 801e18c:	61fb      	str	r3, [r7, #28]
#ifdef HAVE_COMP_KEY
    int compressed = 0;
#endif
    int keysize = 0;
 801e18e:	2300      	movs	r3, #0
 801e190:	61bb      	str	r3, [r7, #24]
    byte pointType;
#ifdef WOLFSSL_CRYPTOCELL
    const CRYS_ECPKI_Domain_t* pDomain;
    CRYS_ECPKI_BUILD_TempData_t tempBuff;
#endif
    if (in == NULL || key == NULL)
 801e192:	68fb      	ldr	r3, [r7, #12]
 801e194:	2b00      	cmp	r3, #0
 801e196:	d002      	beq.n	801e19e <wc_ecc_import_x963_ex+0x22>
 801e198:	687b      	ldr	r3, [r7, #4]
 801e19a:	2b00      	cmp	r3, #0
 801e19c:	d102      	bne.n	801e1a4 <wc_ecc_import_x963_ex+0x28>
        return BAD_FUNC_ARG;
 801e19e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e1a2:	e0a2      	b.n	801e2ea <wc_ecc_import_x963_ex+0x16e>

    /* must be odd */
    if ((inLen & 1) == 0) {
 801e1a4:	68bb      	ldr	r3, [r7, #8]
 801e1a6:	f003 0301 	and.w	r3, r3, #1
 801e1aa:	2b00      	cmp	r3, #0
 801e1ac:	d102      	bne.n	801e1b4 <wc_ecc_import_x963_ex+0x38>
        return ECC_BAD_ARG_E;
 801e1ae:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801e1b2:	e09a      	b.n	801e2ea <wc_ecc_import_x963_ex+0x16e>
    }

    /* make sure required variables are reset */
    wc_ecc_reset(key);
 801e1b4:	6878      	ldr	r0, [r7, #4]
 801e1b6:	f7fe fde0 	bl	801cd7a <wc_ecc_reset>

    /* init key */
    #ifdef ALT_ECC_SIZE
        key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
 801e1ba:	687b      	ldr	r3, [r7, #4]
 801e1bc:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 801e1c0:	687b      	ldr	r3, [r7, #4]
 801e1c2:	619a      	str	r2, [r3, #24]
        key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
 801e1c4:	687b      	ldr	r3, [r7, #4]
 801e1c6:	f103 0274 	add.w	r2, r3, #116	@ 0x74
 801e1ca:	687b      	ldr	r3, [r7, #4]
 801e1cc:	61da      	str	r2, [r3, #28]
        key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
 801e1ce:	687b      	ldr	r3, [r7, #4]
 801e1d0:	f103 02c4 	add.w	r2, r3, #196	@ 0xc4
 801e1d4:	687b      	ldr	r3, [r7, #4]
 801e1d6:	621a      	str	r2, [r3, #32]
        alt_fp_init(key->pubkey.x);
 801e1d8:	687b      	ldr	r3, [r7, #4]
 801e1da:	699b      	ldr	r3, [r3, #24]
 801e1dc:	4618      	mov	r0, r3
 801e1de:	f7fc fd87 	bl	801acf0 <alt_fp_init>
        alt_fp_init(key->pubkey.y);
 801e1e2:	687b      	ldr	r3, [r7, #4]
 801e1e4:	69db      	ldr	r3, [r3, #28]
 801e1e6:	4618      	mov	r0, r3
 801e1e8:	f7fc fd82 	bl	801acf0 <alt_fp_init>
        alt_fp_init(key->pubkey.z);
 801e1ec:	687b      	ldr	r3, [r7, #4]
 801e1ee:	6a1b      	ldr	r3, [r3, #32]
 801e1f0:	4618      	mov	r0, r3
 801e1f2:	f7fc fd7d 	bl	801acf0 <alt_fp_init>
        key->k = (mp_int*)key->ka;
 801e1f6:	687b      	ldr	r3, [r7, #4]
 801e1f8:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
 801e1fc:	687b      	ldr	r3, [r7, #4]
 801e1fe:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
        alt_fp_init(key->k);
 801e202:	687b      	ldr	r3, [r7, #4]
 801e204:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801e208:	4618      	mov	r0, r3
 801e20a:	f7fc fd71 	bl	801acf0 <alt_fp_init>
    #else
                                                                key->kb, key->ku
    #endif
                            );
    #endif
    if (err != MP_OKAY)
 801e20e:	69fb      	ldr	r3, [r7, #28]
 801e210:	2b00      	cmp	r3, #0
 801e212:	d002      	beq.n	801e21a <wc_ecc_import_x963_ex+0x9e>
        return MEMORY_E;
 801e214:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e218:	e067      	b.n	801e2ea <wc_ecc_import_x963_ex+0x16e>
#endif

    SAVE_VECTOR_REGISTERS(return _svr_ret;);

    /* check for point type (4, 2, or 3) */
    pointType = in[0];
 801e21a:	68fb      	ldr	r3, [r7, #12]
 801e21c:	781b      	ldrb	r3, [r3, #0]
 801e21e:	75fb      	strb	r3, [r7, #23]
    if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&
 801e220:	7dfb      	ldrb	r3, [r7, #23]
 801e222:	2b04      	cmp	r3, #4
 801e224:	d008      	beq.n	801e238 <wc_ecc_import_x963_ex+0xbc>
 801e226:	7dfb      	ldrb	r3, [r7, #23]
 801e228:	2b02      	cmp	r3, #2
 801e22a:	d005      	beq.n	801e238 <wc_ecc_import_x963_ex+0xbc>
 801e22c:	7dfb      	ldrb	r3, [r7, #23]
 801e22e:	2b03      	cmp	r3, #3
 801e230:	d002      	beq.n	801e238 <wc_ecc_import_x963_ex+0xbc>
                                         pointType != ECC_POINT_COMP_ODD) {
        err = ASN_PARSE_E;
 801e232:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801e236:	61fb      	str	r3, [r7, #28]
    }

    if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {
 801e238:	7dfb      	ldrb	r3, [r7, #23]
 801e23a:	2b02      	cmp	r3, #2
 801e23c:	d002      	beq.n	801e244 <wc_ecc_import_x963_ex+0xc8>
 801e23e:	7dfb      	ldrb	r3, [r7, #23]
 801e240:	2b03      	cmp	r3, #3
 801e242:	d102      	bne.n	801e24a <wc_ecc_import_x963_ex+0xce>
    #ifdef HAVE_COMP_KEY
        compressed = 1;
    #else
        err = NOT_COMPILED_IN;
 801e244:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 801e248:	61fb      	str	r3, [r7, #28]
    #endif
    }

    /* adjust to skip first byte */
    inLen -= 1;
 801e24a:	68bb      	ldr	r3, [r7, #8]
 801e24c:	3b01      	subs	r3, #1
 801e24e:	60bb      	str	r3, [r7, #8]
    in += 1;
 801e250:	68fb      	ldr	r3, [r7, #12]
 801e252:	3301      	adds	r3, #1
 801e254:	60fb      	str	r3, [r7, #12]
    }
#elif defined(WOLFSSL_KCAPI_ECC)
    XMEMCPY(key->pubkey_raw, (byte*)in, inLen);
#endif

    if (err == MP_OKAY) {
 801e256:	69fb      	ldr	r3, [r7, #28]
 801e258:	2b00      	cmp	r3, #0
 801e25a:	d10b      	bne.n	801e274 <wc_ecc_import_x963_ex+0xf8>
        if (compressed)
            inLen = inLen*2 + 1;  /* used uncompressed len */
    #endif

        /* determine key size */
        keysize = (int)(inLen>>1);
 801e25c:	68bb      	ldr	r3, [r7, #8]
 801e25e:	085b      	lsrs	r3, r3, #1
 801e260:	61bb      	str	r3, [r7, #24]
        /* NOTE: FIPS v6.0.0 or greater, no restriction on imported keys, only
         *       on created keys or signatures */
        err = wc_ecc_set_curve(key, keysize, curve_id);
 801e262:	683a      	ldr	r2, [r7, #0]
 801e264:	69b9      	ldr	r1, [r7, #24]
 801e266:	6878      	ldr	r0, [r7, #4]
 801e268:	f7fc fcd4 	bl	801ac14 <wc_ecc_set_curve>
 801e26c:	61f8      	str	r0, [r7, #28]
        key->type = ECC_PUBLICKEY;
 801e26e:	687b      	ldr	r3, [r7, #4]
 801e270:	2201      	movs	r2, #1
 801e272:	601a      	str	r2, [r3, #0]
    }

    /* read data */
    if (err == MP_OKAY)
 801e274:	69fb      	ldr	r3, [r7, #28]
 801e276:	2b00      	cmp	r3, #0
 801e278:	d107      	bne.n	801e28a <wc_ecc_import_x963_ex+0x10e>
        err = mp_read_unsigned_bin(key->pubkey.x, in, (word32)keysize);
 801e27a:	687b      	ldr	r3, [r7, #4]
 801e27c:	699b      	ldr	r3, [r3, #24]
 801e27e:	69ba      	ldr	r2, [r7, #24]
 801e280:	68f9      	ldr	r1, [r7, #12]
 801e282:	4618      	mov	r0, r3
 801e284:	f008 fd82 	bl	8026d8c <mp_read_unsigned_bin>
 801e288:	61f8      	str	r0, [r7, #28]
        }
#endif
    }
#endif /* HAVE_COMP_KEY */

    if (err == MP_OKAY) {
 801e28a:	69fb      	ldr	r3, [r7, #28]
 801e28c:	2b00      	cmp	r3, #0
 801e28e:	d109      	bne.n	801e2a4 <wc_ecc_import_x963_ex+0x128>
    #ifdef HAVE_COMP_KEY
        if (compressed == 0)
    #endif
        {
            err = mp_read_unsigned_bin(key->pubkey.y, in + keysize,
 801e290:	687b      	ldr	r3, [r7, #4]
 801e292:	69d8      	ldr	r0, [r3, #28]
 801e294:	69bb      	ldr	r3, [r7, #24]
 801e296:	68fa      	ldr	r2, [r7, #12]
 801e298:	4413      	add	r3, r2
 801e29a:	69ba      	ldr	r2, [r7, #24]
 801e29c:	4619      	mov	r1, r3
 801e29e:	f008 fd75 	bl	8026d8c <mp_read_unsigned_bin>
 801e2a2:	61f8      	str	r0, [r7, #28]
                (word32)keysize);
        }
    }
    if (err == MP_OKAY)
 801e2a4:	69fb      	ldr	r3, [r7, #28]
 801e2a6:	2b00      	cmp	r3, #0
 801e2a8:	d106      	bne.n	801e2b8 <wc_ecc_import_x963_ex+0x13c>
        err = mp_set(key->pubkey.z, 1);
 801e2aa:	687b      	ldr	r3, [r7, #4]
 801e2ac:	6a1b      	ldr	r3, [r3, #32]
 801e2ae:	2101      	movs	r1, #1
 801e2b0:	4618      	mov	r0, r3
 801e2b2:	f009 f89b 	bl	80273ec <mp_set>
 801e2b6:	61f8      	str	r0, [r7, #28]
    if (err == MP_OKAY) {
        err = wc_MAXQ10XX_EccSetKey(key, keysize);
    }
#endif

    if (err != MP_OKAY) {
 801e2b8:	69fb      	ldr	r3, [r7, #28]
 801e2ba:	2b00      	cmp	r3, #0
 801e2bc:	d014      	beq.n	801e2e8 <wc_ecc_import_x963_ex+0x16c>
        mp_clear(key->pubkey.x);
 801e2be:	687b      	ldr	r3, [r7, #4]
 801e2c0:	699b      	ldr	r3, [r3, #24]
 801e2c2:	4618      	mov	r0, r3
 801e2c4:	f008 fc13 	bl	8026aee <mp_clear>
        mp_clear(key->pubkey.y);
 801e2c8:	687b      	ldr	r3, [r7, #4]
 801e2ca:	69db      	ldr	r3, [r3, #28]
 801e2cc:	4618      	mov	r0, r3
 801e2ce:	f008 fc0e 	bl	8026aee <mp_clear>
        mp_clear(key->pubkey.z);
 801e2d2:	687b      	ldr	r3, [r7, #4]
 801e2d4:	6a1b      	ldr	r3, [r3, #32]
 801e2d6:	4618      	mov	r0, r3
 801e2d8:	f008 fc09 	bl	8026aee <mp_clear>
        mp_clear(key->k);
 801e2dc:	687b      	ldr	r3, [r7, #4]
 801e2de:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801e2e2:	4618      	mov	r0, r3
 801e2e4:	f008 fc03 	bl	8026aee <mp_clear>
    }

    RESTORE_VECTOR_REGISTERS();

    return err;
 801e2e8:	69fb      	ldr	r3, [r7, #28]
}
 801e2ea:	4618      	mov	r0, r3
 801e2ec:	3720      	adds	r7, #32
 801e2ee:	46bd      	mov	sp, r7
 801e2f0:	bd80      	pop	{r7, pc}

0801e2f2 <wc_ecc_import_private_key_ex>:
#ifdef HAVE_ECC_KEY_IMPORT
/* import private key, public part optional if (pub) passed as NULL */
int wc_ecc_import_private_key_ex(const byte* priv, word32 privSz,
                                 const byte* pub, word32 pubSz, ecc_key* key,
                                 int curve_id)
{
 801e2f2:	b580      	push	{r7, lr}
 801e2f4:	b086      	sub	sp, #24
 801e2f6:	af00      	add	r7, sp, #0
 801e2f8:	60f8      	str	r0, [r7, #12]
 801e2fa:	60b9      	str	r1, [r7, #8]
 801e2fc:	607a      	str	r2, [r7, #4]
 801e2fe:	603b      	str	r3, [r7, #0]
    int ret;
#ifdef WOLFSSL_CRYPTOCELL
    const CRYS_ECPKI_Domain_t* pDomain;
#endif
    if (key == NULL || priv == NULL)
 801e300:	6a3b      	ldr	r3, [r7, #32]
 801e302:	2b00      	cmp	r3, #0
 801e304:	d002      	beq.n	801e30c <wc_ecc_import_private_key_ex+0x1a>
 801e306:	68fb      	ldr	r3, [r7, #12]
 801e308:	2b00      	cmp	r3, #0
 801e30a:	d102      	bne.n	801e312 <wc_ecc_import_private_key_ex+0x20>
        return BAD_FUNC_ARG;
 801e30c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e310:	e036      	b.n	801e380 <wc_ecc_import_private_key_ex+0x8e>

    /* public optional, NULL if only importing private */
    if (pub != NULL) {
 801e312:	687b      	ldr	r3, [r7, #4]
 801e314:	2b00      	cmp	r3, #0
 801e316:	d017      	beq.n	801e348 <wc_ecc_import_private_key_ex+0x56>
    #ifndef NO_ASN
        word32 idx = 0;
 801e318:	2300      	movs	r3, #0
 801e31a:	613b      	str	r3, [r7, #16]
        ret = wc_ecc_import_x963_ex(pub, pubSz, key, curve_id);
 801e31c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e31e:	6a3a      	ldr	r2, [r7, #32]
 801e320:	6839      	ldr	r1, [r7, #0]
 801e322:	6878      	ldr	r0, [r7, #4]
 801e324:	f7ff ff2a 	bl	801e17c <wc_ecc_import_x963_ex>
 801e328:	6178      	str	r0, [r7, #20]
        if (ret < 0)
 801e32a:	697b      	ldr	r3, [r7, #20]
 801e32c:	2b00      	cmp	r3, #0
 801e32e:	da07      	bge.n	801e340 <wc_ecc_import_private_key_ex+0x4e>
            ret = wc_EccPublicKeyDecode(pub, &idx, key, pubSz);
 801e330:	f107 0110 	add.w	r1, r7, #16
 801e334:	683b      	ldr	r3, [r7, #0]
 801e336:	6a3a      	ldr	r2, [r7, #32]
 801e338:	6878      	ldr	r0, [r7, #4]
 801e33a:	f7fb febb 	bl	801a0b4 <wc_EccPublicKeyDecode>
 801e33e:	6178      	str	r0, [r7, #20]
        key->type = ECC_PRIVATEKEY;
 801e340:	6a3b      	ldr	r3, [r7, #32]
 801e342:	2202      	movs	r2, #2
 801e344:	601a      	str	r2, [r3, #0]
 801e346:	e00c      	b.n	801e362 <wc_ecc_import_private_key_ex+0x70>
        ret = NOT_COMPILED_IN;
    #endif
    }
    else {
        /* make sure required variables are reset */
        wc_ecc_reset(key);
 801e348:	6a38      	ldr	r0, [r7, #32]
 801e34a:	f7fe fd16 	bl	801cd7a <wc_ecc_reset>

        /* set key size */
        /* NOTE: FIPS v6.0.0 or greater, no restriction on imported keys, only
         *       on created keys or signatures */
        ret = wc_ecc_set_curve(key, (int)privSz, curve_id);
 801e34e:	68bb      	ldr	r3, [r7, #8]
 801e350:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801e352:	4619      	mov	r1, r3
 801e354:	6a38      	ldr	r0, [r7, #32]
 801e356:	f7fc fc5d 	bl	801ac14 <wc_ecc_set_curve>
 801e35a:	6178      	str	r0, [r7, #20]
        key->type = ECC_PRIVATEKEY_ONLY;
 801e35c:	6a3b      	ldr	r3, [r7, #32]
 801e35e:	2203      	movs	r2, #3
 801e360:	601a      	str	r2, [r3, #0]
    }

    if (ret != 0)
 801e362:	697b      	ldr	r3, [r7, #20]
 801e364:	2b00      	cmp	r3, #0
 801e366:	d001      	beq.n	801e36c <wc_ecc_import_private_key_ex+0x7a>
        return ret;
 801e368:	697b      	ldr	r3, [r7, #20]
 801e36a:	e009      	b.n	801e380 <wc_ecc_import_private_key_ex+0x8e>

#ifdef WOLFSSL_VALIDATE_ECC_IMPORT
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
#endif

    ret = mp_read_unsigned_bin(key->k, priv, privSz);
 801e36c:	6a3b      	ldr	r3, [r7, #32]
 801e36e:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801e372:	68ba      	ldr	r2, [r7, #8]
 801e374:	68f9      	ldr	r1, [r7, #12]
 801e376:	4618      	mov	r0, r3
 801e378:	f008 fd08 	bl	8026d8c <mp_read_unsigned_bin>
 801e37c:	6178      	str	r0, [r7, #20]
    if (ret == 0) {
        ret = silabs_ecc_import(key, key->dp->size, (pub != NULL), 1);
    }
#endif

    return ret;
 801e37e:	697b      	ldr	r3, [r7, #20]
}
 801e380:	4618      	mov	r0, r3
 801e382:	3718      	adds	r7, #24
 801e384:	46bd      	mov	sp, r7
 801e386:	bd80      	pop	{r7, pc}

0801e388 <wc_ecc_size>:
#endif

/* key size in octets */
WOLFSSL_ABI
int wc_ecc_size(ecc_key* key)
{
 801e388:	b480      	push	{r7}
 801e38a:	b083      	sub	sp, #12
 801e38c:	af00      	add	r7, sp, #0
 801e38e:	6078      	str	r0, [r7, #4]
    if (key == NULL || key->dp == NULL)
 801e390:	687b      	ldr	r3, [r7, #4]
 801e392:	2b00      	cmp	r3, #0
 801e394:	d003      	beq.n	801e39e <wc_ecc_size+0x16>
 801e396:	687b      	ldr	r3, [r7, #4]
 801e398:	691b      	ldr	r3, [r3, #16]
 801e39a:	2b00      	cmp	r3, #0
 801e39c:	d101      	bne.n	801e3a2 <wc_ecc_size+0x1a>
        return 0;
 801e39e:	2300      	movs	r3, #0
 801e3a0:	e002      	b.n	801e3a8 <wc_ecc_size+0x20>

    return key->dp->size;
 801e3a2:	687b      	ldr	r3, [r7, #4]
 801e3a4:	691b      	ldr	r3, [r3, #16]
 801e3a6:	681b      	ldr	r3, [r3, #0]
}
 801e3a8:	4618      	mov	r0, r3
 801e3aa:	370c      	adds	r7, #12
 801e3ac:	46bd      	mov	sp, r7
 801e3ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e3b2:	4770      	bx	lr

0801e3b4 <wc_ecc_sig_size>:
}

/* maximum signature size based on actual key curve */
WOLFSSL_ABI
int wc_ecc_sig_size(const ecc_key* key)
{
 801e3b4:	b580      	push	{r7, lr}
 801e3b6:	b086      	sub	sp, #24
 801e3b8:	af00      	add	r7, sp, #0
 801e3ba:	6078      	str	r0, [r7, #4]
    int maxSigSz;
    int orderBits, keySz;

    if (key == NULL || key->dp == NULL)
 801e3bc:	687b      	ldr	r3, [r7, #4]
 801e3be:	2b00      	cmp	r3, #0
 801e3c0:	d003      	beq.n	801e3ca <wc_ecc_sig_size+0x16>
 801e3c2:	687b      	ldr	r3, [r7, #4]
 801e3c4:	691b      	ldr	r3, [r3, #16]
 801e3c6:	2b00      	cmp	r3, #0
 801e3c8:	d101      	bne.n	801e3ce <wc_ecc_sig_size+0x1a>
        return 0;
 801e3ca:	2300      	movs	r3, #0
 801e3cc:	e028      	b.n	801e420 <wc_ecc_sig_size+0x6c>

    /* the signature r and s will always be less than order */
    /* if the order MSB (top bit of byte) is set then ASN encoding needs
        extra byte for r and s, so add 2 */
    keySz = key->dp->size;
 801e3ce:	687b      	ldr	r3, [r7, #4]
 801e3d0:	691b      	ldr	r3, [r3, #16]
 801e3d2:	681b      	ldr	r3, [r3, #0]
 801e3d4:	613b      	str	r3, [r7, #16]
    orderBits = wc_ecc_get_curve_order_bit_count(key->dp);
 801e3d6:	687b      	ldr	r3, [r7, #4]
 801e3d8:	691b      	ldr	r3, [r3, #16]
 801e3da:	4618      	mov	r0, r3
 801e3dc:	f7fe fe03 	bl	801cfe6 <wc_ecc_get_curve_order_bit_count>
 801e3e0:	60f8      	str	r0, [r7, #12]
    if (orderBits > keySz * 8) {
 801e3e2:	693b      	ldr	r3, [r7, #16]
 801e3e4:	00db      	lsls	r3, r3, #3
 801e3e6:	68fa      	ldr	r2, [r7, #12]
 801e3e8:	429a      	cmp	r2, r3
 801e3ea:	dd06      	ble.n	801e3fa <wc_ecc_sig_size+0x46>
        keySz = (orderBits + 7) / 8;
 801e3ec:	68fb      	ldr	r3, [r7, #12]
 801e3ee:	3307      	adds	r3, #7
 801e3f0:	2b00      	cmp	r3, #0
 801e3f2:	da00      	bge.n	801e3f6 <wc_ecc_sig_size+0x42>
 801e3f4:	3307      	adds	r3, #7
 801e3f6:	10db      	asrs	r3, r3, #3
 801e3f8:	613b      	str	r3, [r7, #16]
    }
    /* maximum possible signature header size is 7 bytes */
    maxSigSz = (keySz * 2) + SIG_HEADER_SZ;
 801e3fa:	693b      	ldr	r3, [r7, #16]
 801e3fc:	005b      	lsls	r3, r3, #1
 801e3fe:	3307      	adds	r3, #7
 801e400:	617b      	str	r3, [r7, #20]
    if ((orderBits % 8) == 0) {
 801e402:	68fb      	ldr	r3, [r7, #12]
 801e404:	f003 0307 	and.w	r3, r3, #7
 801e408:	2b00      	cmp	r3, #0
 801e40a:	d102      	bne.n	801e412 <wc_ecc_sig_size+0x5e>
        /* MSB can be set, so add 2 */
        maxSigSz += ECC_MAX_PAD_SZ;
 801e40c:	697b      	ldr	r3, [r7, #20]
 801e40e:	3302      	adds	r3, #2
 801e410:	617b      	str	r3, [r7, #20]
    }
    /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */
    if (maxSigSz < (128 + 2)) {
 801e412:	697b      	ldr	r3, [r7, #20]
 801e414:	2b81      	cmp	r3, #129	@ 0x81
 801e416:	dc02      	bgt.n	801e41e <wc_ecc_sig_size+0x6a>
        maxSigSz -= 1;
 801e418:	697b      	ldr	r3, [r7, #20]
 801e41a:	3b01      	subs	r3, #1
 801e41c:	617b      	str	r3, [r7, #20]
    }

    return maxSigSz;
 801e41e:	697b      	ldr	r3, [r7, #20]
}
 801e420:	4618      	mov	r0, r3
 801e422:	3718      	adds	r7, #24
 801e424:	46bd      	mov	sp, r7
 801e426:	bd80      	pop	{r7, pc}

0801e428 <wc_ecc_get_oid>:
#endif
}
#endif /* HAVE_OID_ENCODING */

int wc_ecc_get_oid(word32 oidSum, const byte** oid, word32* oidSz)
{
 801e428:	b480      	push	{r7}
 801e42a:	b087      	sub	sp, #28
 801e42c:	af00      	add	r7, sp, #0
 801e42e:	60f8      	str	r0, [r7, #12]
 801e430:	60b9      	str	r1, [r7, #8]
 801e432:	607a      	str	r2, [r7, #4]
    int x;
    int ret = WC_NO_ERR_TRACE(NOT_COMPILED_IN);
 801e434:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 801e438:	613b      	str	r3, [r7, #16]
#ifdef HAVE_OID_ENCODING
    oid_cache_t* o = NULL;
#endif

    if (oidSum == 0) {
 801e43a:	68fb      	ldr	r3, [r7, #12]
 801e43c:	2b00      	cmp	r3, #0
 801e43e:	d102      	bne.n	801e446 <wc_ecc_get_oid+0x1e>
        return BAD_FUNC_ARG;
 801e440:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e444:	e03e      	b.n	801e4c4 <wc_ecc_get_oid+0x9c>
        return BAD_MUTEX_E;
    }
#endif

    /* find matching OID sum (based on encoded value) */
    for (x = 0; ecc_sets[x].size != 0; x++) {
 801e446:	2300      	movs	r3, #0
 801e448:	617b      	str	r3, [r7, #20]
 801e44a:	e031      	b.n	801e4b0 <wc_ecc_get_oid+0x88>
        if (ecc_sets[x].oidSum == oidSum) {
 801e44c:	4a20      	ldr	r2, [pc, #128]	@ (801e4d0 <wc_ecc_get_oid+0xa8>)
 801e44e:	697b      	ldr	r3, [r7, #20]
 801e450:	2134      	movs	r1, #52	@ 0x34
 801e452:	fb01 f303 	mul.w	r3, r1, r3
 801e456:	4413      	add	r3, r2
 801e458:	332c      	adds	r3, #44	@ 0x2c
 801e45a:	681b      	ldr	r3, [r3, #0]
 801e45c:	68fa      	ldr	r2, [r7, #12]
 801e45e:	429a      	cmp	r2, r3
 801e460:	d123      	bne.n	801e4aa <wc_ecc_get_oid+0x82>
            if (ret == 0) {
                ret = ecc_sets[x].id;
            }
            break;
        #else
            if (oidSz) {
 801e462:	687b      	ldr	r3, [r7, #4]
 801e464:	2b00      	cmp	r3, #0
 801e466:	d009      	beq.n	801e47c <wc_ecc_get_oid+0x54>
                *oidSz = ecc_sets[x].oidSz;
 801e468:	4a19      	ldr	r2, [pc, #100]	@ (801e4d0 <wc_ecc_get_oid+0xa8>)
 801e46a:	697b      	ldr	r3, [r7, #20]
 801e46c:	2134      	movs	r1, #52	@ 0x34
 801e46e:	fb01 f303 	mul.w	r3, r1, r3
 801e472:	4413      	add	r3, r2
 801e474:	3328      	adds	r3, #40	@ 0x28
 801e476:	681a      	ldr	r2, [r3, #0]
 801e478:	687b      	ldr	r3, [r7, #4]
 801e47a:	601a      	str	r2, [r3, #0]
            }
            if (oid) {
 801e47c:	68bb      	ldr	r3, [r7, #8]
 801e47e:	2b00      	cmp	r3, #0
 801e480:	d009      	beq.n	801e496 <wc_ecc_get_oid+0x6e>
                *oid = ecc_sets[x].oid;
 801e482:	4a13      	ldr	r2, [pc, #76]	@ (801e4d0 <wc_ecc_get_oid+0xa8>)
 801e484:	697b      	ldr	r3, [r7, #20]
 801e486:	2134      	movs	r1, #52	@ 0x34
 801e488:	fb01 f303 	mul.w	r3, r1, r3
 801e48c:	4413      	add	r3, r2
 801e48e:	3324      	adds	r3, #36	@ 0x24
 801e490:	681a      	ldr	r2, [r3, #0]
 801e492:	68bb      	ldr	r3, [r7, #8]
 801e494:	601a      	str	r2, [r3, #0]
            }
            ret = ecc_sets[x].id;
 801e496:	4a0e      	ldr	r2, [pc, #56]	@ (801e4d0 <wc_ecc_get_oid+0xa8>)
 801e498:	697b      	ldr	r3, [r7, #20]
 801e49a:	2134      	movs	r1, #52	@ 0x34
 801e49c:	fb01 f303 	mul.w	r3, r1, r3
 801e4a0:	4413      	add	r3, r2
 801e4a2:	3304      	adds	r3, #4
 801e4a4:	681b      	ldr	r3, [r3, #0]
 801e4a6:	613b      	str	r3, [r7, #16]
            break;
 801e4a8:	e00b      	b.n	801e4c2 <wc_ecc_get_oid+0x9a>
    for (x = 0; ecc_sets[x].size != 0; x++) {
 801e4aa:	697b      	ldr	r3, [r7, #20]
 801e4ac:	3301      	adds	r3, #1
 801e4ae:	617b      	str	r3, [r7, #20]
 801e4b0:	4a07      	ldr	r2, [pc, #28]	@ (801e4d0 <wc_ecc_get_oid+0xa8>)
 801e4b2:	697b      	ldr	r3, [r7, #20]
 801e4b4:	2134      	movs	r1, #52	@ 0x34
 801e4b6:	fb01 f303 	mul.w	r3, r1, r3
 801e4ba:	4413      	add	r3, r2
 801e4bc:	681b      	ldr	r3, [r3, #0]
 801e4be:	2b00      	cmp	r3, #0
 801e4c0:	d1c4      	bne.n	801e44c <wc_ecc_get_oid+0x24>

#ifdef HAVE_OID_ENCODING
    wc_UnLockMutex(&ecc_oid_cache_lock);
#endif

    return ret;
 801e4c2:	693b      	ldr	r3, [r7, #16]
}
 801e4c4:	4618      	mov	r0, r3
 801e4c6:	371c      	adds	r7, #28
 801e4c8:	46bd      	mov	sp, r7
 801e4ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e4ce:	4770      	bx	lr
 801e4d0:	08034908 	.word	0x08034908

0801e4d4 <wc_HashGetOID>:
#endif /* !NO_PWDBASED || !NO_ASN */

#if !defined(NO_ASN) || !defined(NO_DH) || defined(HAVE_ECC)

int wc_HashGetOID(enum wc_HashType hash_type)
{
 801e4d4:	b480      	push	{r7}
 801e4d6:	b085      	sub	sp, #20
 801e4d8:	af00      	add	r7, sp, #0
 801e4da:	4603      	mov	r3, r0
 801e4dc:	71fb      	strb	r3, [r7, #7]
    int oid = WC_NO_ERR_TRACE(HASH_TYPE_E); /* Default to hash type error */
 801e4de:	f06f 03e7 	mvn.w	r3, #231	@ 0xe7
 801e4e2:	60fb      	str	r3, [r7, #12]
    switch(hash_type)
 801e4e4:	79fb      	ldrb	r3, [r7, #7]
 801e4e6:	3b01      	subs	r3, #1
 801e4e8:	2b10      	cmp	r3, #16
 801e4ea:	d829      	bhi.n	801e540 <wc_HashGetOID+0x6c>
 801e4ec:	a201      	add	r2, pc, #4	@ (adr r2, 801e4f4 <wc_HashGetOID+0x20>)
 801e4ee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e4f2:	bf00      	nop
 801e4f4:	0801e549 	.word	0x0801e549
 801e4f8:	0801e541 	.word	0x0801e541
 801e4fc:	0801e549 	.word	0x0801e549
 801e500:	0801e549 	.word	0x0801e549
 801e504:	0801e549 	.word	0x0801e549
 801e508:	0801e539 	.word	0x0801e539
 801e50c:	0801e549 	.word	0x0801e549
 801e510:	0801e549 	.word	0x0801e549
 801e514:	0801e549 	.word	0x0801e549
 801e518:	0801e549 	.word	0x0801e549
 801e51c:	0801e549 	.word	0x0801e549
 801e520:	0801e549 	.word	0x0801e549
 801e524:	0801e549 	.word	0x0801e549
 801e528:	0801e541 	.word	0x0801e541
 801e52c:	0801e541 	.word	0x0801e541
 801e530:	0801e549 	.word	0x0801e549
 801e534:	0801e549 	.word	0x0801e549
            oid = SHA224h;
        #endif
            break;
        case WC_HASH_TYPE_SHA256:
        #ifndef NO_SHA256
            oid = SHA256h;
 801e538:	f44f 73cf 	mov.w	r3, #414	@ 0x19e
 801e53c:	60fb      	str	r3, [r7, #12]
        #endif
            break;
 801e53e:	e004      	b.n	801e54a <wc_HashGetOID+0x76>
        case WC_HASH_TYPE_MD4:
        case WC_HASH_TYPE_BLAKE2B:
        case WC_HASH_TYPE_BLAKE2S:
        case WC_HASH_TYPE_NONE:
        default:
            oid = BAD_FUNC_ARG;
 801e540:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e544:	60fb      	str	r3, [r7, #12]
            break;
 801e546:	e000      	b.n	801e54a <wc_HashGetOID+0x76>
            break;
 801e548:	bf00      	nop
    }
    return oid;
 801e54a:	68fb      	ldr	r3, [r7, #12]
}
 801e54c:	4618      	mov	r0, r3
 801e54e:	3714      	adds	r7, #20
 801e550:	46bd      	mov	sp, r7
 801e552:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e556:	4770      	bx	lr

0801e558 <wc_HashGetDigestSize>:

#ifndef NO_HASH_WRAPPER

/* Get Hash digest size */
int wc_HashGetDigestSize(enum wc_HashType hash_type)
{
 801e558:	b480      	push	{r7}
 801e55a:	b085      	sub	sp, #20
 801e55c:	af00      	add	r7, sp, #0
 801e55e:	4603      	mov	r3, r0
 801e560:	71fb      	strb	r3, [r7, #7]
    int dig_size = WC_NO_ERR_TRACE(HASH_TYPE_E);
 801e562:	f06f 03e7 	mvn.w	r3, #231	@ 0xe7
 801e566:	60fb      	str	r3, [r7, #12]
    switch(hash_type)
 801e568:	79fb      	ldrb	r3, [r7, #7]
 801e56a:	3b01      	subs	r3, #1
 801e56c:	2b10      	cmp	r3, #16
 801e56e:	d828      	bhi.n	801e5c2 <wc_HashGetDigestSize+0x6a>
 801e570:	a201      	add	r2, pc, #4	@ (adr r2, 801e578 <wc_HashGetDigestSize+0x20>)
 801e572:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e576:	bf00      	nop
 801e578:	0801e5cb 	.word	0x0801e5cb
 801e57c:	0801e5cb 	.word	0x0801e5cb
 801e580:	0801e5cb 	.word	0x0801e5cb
 801e584:	0801e5cb 	.word	0x0801e5cb
 801e588:	0801e5cb 	.word	0x0801e5cb
 801e58c:	0801e5bd 	.word	0x0801e5bd
 801e590:	0801e5cb 	.word	0x0801e5cb
 801e594:	0801e5cb 	.word	0x0801e5cb
 801e598:	0801e5cb 	.word	0x0801e5cb
 801e59c:	0801e5cb 	.word	0x0801e5cb
 801e5a0:	0801e5cb 	.word	0x0801e5cb
 801e5a4:	0801e5cb 	.word	0x0801e5cb
 801e5a8:	0801e5cb 	.word	0x0801e5cb
 801e5ac:	0801e5cb 	.word	0x0801e5cb
 801e5b0:	0801e5cb 	.word	0x0801e5cb
 801e5b4:	0801e5cb 	.word	0x0801e5cb
 801e5b8:	0801e5cb 	.word	0x0801e5cb
            dig_size = WC_SHA224_DIGEST_SIZE;
        #endif
            break;
        case WC_HASH_TYPE_SHA256:
        #ifndef NO_SHA256
            dig_size = WC_SHA256_DIGEST_SIZE;
 801e5bc:	2320      	movs	r3, #32
 801e5be:	60fb      	str	r3, [r7, #12]
        #endif
            break;
 801e5c0:	e004      	b.n	801e5cc <wc_HashGetDigestSize+0x74>
    #if defined(WOLFSSL_SHA3) && defined(WOLFSSL_SHAKE256)
        case WC_HASH_TYPE_SHAKE256:
    #endif
        case WC_HASH_TYPE_NONE:
        default:
            dig_size = BAD_FUNC_ARG;
 801e5c2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e5c6:	60fb      	str	r3, [r7, #12]
            break;
 801e5c8:	e000      	b.n	801e5cc <wc_HashGetDigestSize+0x74>
            break;
 801e5ca:	bf00      	nop
    }
    return dig_size;
 801e5cc:	68fb      	ldr	r3, [r7, #12]
}
 801e5ce:	4618      	mov	r0, r3
 801e5d0:	3714      	adds	r7, #20
 801e5d2:	46bd      	mov	sp, r7
 801e5d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e5d8:	4770      	bx	lr
 801e5da:	bf00      	nop

0801e5dc <wc_Hash_ex>:
}

/* Generic Hashing Wrapper */
int wc_Hash_ex(enum wc_HashType hash_type, const byte* data,
    word32 data_len, byte* hash, word32 hash_len, void* heap, int devId)
{
 801e5dc:	b580      	push	{r7, lr}
 801e5de:	b088      	sub	sp, #32
 801e5e0:	af02      	add	r7, sp, #8
 801e5e2:	60b9      	str	r1, [r7, #8]
 801e5e4:	607a      	str	r2, [r7, #4]
 801e5e6:	603b      	str	r3, [r7, #0]
 801e5e8:	4603      	mov	r3, r0
 801e5ea:	73fb      	strb	r3, [r7, #15]
    int ret = WC_NO_ERR_TRACE(HASH_TYPE_E); /* Default to hash type error */
 801e5ec:	f06f 03e7 	mvn.w	r3, #231	@ 0xe7
 801e5f0:	617b      	str	r3, [r7, #20]
    int dig_size;

    /* Validate hash buffer size */
    dig_size = wc_HashGetDigestSize(hash_type);
 801e5f2:	7bfb      	ldrb	r3, [r7, #15]
 801e5f4:	4618      	mov	r0, r3
 801e5f6:	f7ff ffaf 	bl	801e558 <wc_HashGetDigestSize>
 801e5fa:	6138      	str	r0, [r7, #16]
    if (dig_size < 0) {
 801e5fc:	693b      	ldr	r3, [r7, #16]
 801e5fe:	2b00      	cmp	r3, #0
 801e600:	da01      	bge.n	801e606 <wc_Hash_ex+0x2a>
        return dig_size;
 801e602:	693b      	ldr	r3, [r7, #16]
 801e604:	e03c      	b.n	801e680 <wc_Hash_ex+0xa4>
    }

    if (hash_len < (word32)dig_size) {
 801e606:	693b      	ldr	r3, [r7, #16]
 801e608:	6a3a      	ldr	r2, [r7, #32]
 801e60a:	429a      	cmp	r2, r3
 801e60c:	d202      	bcs.n	801e614 <wc_Hash_ex+0x38>
        return BUFFER_E;
 801e60e:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801e612:	e035      	b.n	801e680 <wc_Hash_ex+0xa4>
    (void)data;
    (void)data_len;
    (void)hash;
    (void)hash_len;

    switch(hash_type)
 801e614:	7bfb      	ldrb	r3, [r7, #15]
 801e616:	3b03      	subs	r3, #3
 801e618:	2b0e      	cmp	r3, #14
 801e61a:	d82b      	bhi.n	801e674 <wc_Hash_ex+0x98>
 801e61c:	a201      	add	r2, pc, #4	@ (adr r2, 801e624 <wc_Hash_ex+0x48>)
 801e61e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e622:	bf00      	nop
 801e624:	0801e67d 	.word	0x0801e67d
 801e628:	0801e67d 	.word	0x0801e67d
 801e62c:	0801e67d 	.word	0x0801e67d
 801e630:	0801e661 	.word	0x0801e661
 801e634:	0801e67d 	.word	0x0801e67d
 801e638:	0801e67d 	.word	0x0801e67d
 801e63c:	0801e67d 	.word	0x0801e67d
 801e640:	0801e67d 	.word	0x0801e67d
 801e644:	0801e67d 	.word	0x0801e67d
 801e648:	0801e67d 	.word	0x0801e67d
 801e64c:	0801e67d 	.word	0x0801e67d
 801e650:	0801e675 	.word	0x0801e675
 801e654:	0801e675 	.word	0x0801e675
 801e658:	0801e67d 	.word	0x0801e67d
 801e65c:	0801e67d 	.word	0x0801e67d
            ret = wc_Sha224Hash_ex(data, data_len, hash, heap, devId);
#endif
            break;
        case WC_HASH_TYPE_SHA256:
#ifndef NO_SHA256
            ret = wc_Sha256Hash_ex(data, data_len, hash, heap, devId);
 801e660:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e662:	9300      	str	r3, [sp, #0]
 801e664:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e666:	683a      	ldr	r2, [r7, #0]
 801e668:	6879      	ldr	r1, [r7, #4]
 801e66a:	68b8      	ldr	r0, [r7, #8]
 801e66c:	f000 f826 	bl	801e6bc <wc_Sha256Hash_ex>
 801e670:	6178      	str	r0, [r7, #20]
#endif
            break;
 801e672:	e004      	b.n	801e67e <wc_Hash_ex+0xa2>
    #if defined(WOLFSSL_SHA3) && defined(WOLFSSL_SHAKE256)
        case WC_HASH_TYPE_SHAKE256:
    #endif
        case WC_HASH_TYPE_NONE:
        default:
            ret = BAD_FUNC_ARG;
 801e674:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e678:	617b      	str	r3, [r7, #20]
            break;
 801e67a:	e000      	b.n	801e67e <wc_Hash_ex+0xa2>
            break;
 801e67c:	bf00      	nop
    }
    return ret;
 801e67e:	697b      	ldr	r3, [r7, #20]
}
 801e680:	4618      	mov	r0, r3
 801e682:	3718      	adds	r7, #24
 801e684:	46bd      	mov	sp, r7
 801e686:	bd80      	pop	{r7, pc}

0801e688 <wc_Hash>:
int wc_Hash(enum wc_HashType hash_type, const byte* data,
    word32 data_len, byte* hash, word32 hash_len)
{
 801e688:	b580      	push	{r7, lr}
 801e68a:	b088      	sub	sp, #32
 801e68c:	af04      	add	r7, sp, #16
 801e68e:	60b9      	str	r1, [r7, #8]
 801e690:	607a      	str	r2, [r7, #4]
 801e692:	603b      	str	r3, [r7, #0]
 801e694:	4603      	mov	r3, r0
 801e696:	73fb      	strb	r3, [r7, #15]
    return wc_Hash_ex(hash_type, data, data_len, hash, hash_len,
 801e698:	7bf8      	ldrb	r0, [r7, #15]
 801e69a:	f06f 0301 	mvn.w	r3, #1
 801e69e:	9302      	str	r3, [sp, #8]
 801e6a0:	2300      	movs	r3, #0
 801e6a2:	9301      	str	r3, [sp, #4]
 801e6a4:	69bb      	ldr	r3, [r7, #24]
 801e6a6:	9300      	str	r3, [sp, #0]
 801e6a8:	683b      	ldr	r3, [r7, #0]
 801e6aa:	687a      	ldr	r2, [r7, #4]
 801e6ac:	68b9      	ldr	r1, [r7, #8]
 801e6ae:	f7ff ff95 	bl	801e5dc <wc_Hash_ex>
 801e6b2:	4603      	mov	r3, r0
        NULL, INVALID_DEVID);
}
 801e6b4:	4618      	mov	r0, r3
 801e6b6:	3710      	adds	r7, #16
 801e6b8:	46bd      	mov	sp, r7
 801e6ba:	bd80      	pop	{r7, pc}

0801e6bc <wc_Sha256Hash_ex>:
#endif /* WOLFSSL_SHA224 */

#if !defined(NO_SHA256)
    int wc_Sha256Hash_ex(const byte* data, word32 len, byte* hash,
        void* heap, int devId)
    {
 801e6bc:	b580      	push	{r7, lr}
 801e6be:	b088      	sub	sp, #32
 801e6c0:	af00      	add	r7, sp, #0
 801e6c2:	60f8      	str	r0, [r7, #12]
 801e6c4:	60b9      	str	r1, [r7, #8]
 801e6c6:	607a      	str	r2, [r7, #4]
 801e6c8:	603b      	str	r3, [r7, #0]
        int ret = 0;
 801e6ca:	2300      	movs	r3, #0
 801e6cc:	61fb      	str	r3, [r7, #28]
    #else
        wc_Sha256 sha256[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        sha256 = (wc_Sha256*)XMALLOC(sizeof(wc_Sha256), NULL,
 801e6ce:	2070      	movs	r0, #112	@ 0x70
 801e6d0:	f000 fad4 	bl	801ec7c <wolfSSL_Malloc>
 801e6d4:	61b8      	str	r0, [r7, #24]
            DYNAMIC_TYPE_TMP_BUFFER);
        if (sha256 == NULL)
 801e6d6:	69bb      	ldr	r3, [r7, #24]
 801e6d8:	2b00      	cmp	r3, #0
 801e6da:	d102      	bne.n	801e6e2 <wc_Sha256Hash_ex+0x26>
            return MEMORY_E;
 801e6dc:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e6e0:	e022      	b.n	801e728 <wc_Sha256Hash_ex+0x6c>
    #endif

        if ((ret = wc_InitSha256_ex(sha256, heap, devId)) != 0) {
 801e6e2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801e6e4:	6839      	ldr	r1, [r7, #0]
 801e6e6:	69b8      	ldr	r0, [r7, #24]
 801e6e8:	f003 f86c 	bl	80217c4 <wc_InitSha256_ex>
 801e6ec:	61f8      	str	r0, [r7, #28]
 801e6ee:	69fb      	ldr	r3, [r7, #28]
 801e6f0:	2b00      	cmp	r3, #0
 801e6f2:	d110      	bne.n	801e716 <wc_Sha256Hash_ex+0x5a>
            WOLFSSL_MSG("InitSha256 failed");
        }
        else {
            if ((ret = wc_Sha256Update(sha256, data, len)) != 0) {
 801e6f4:	68ba      	ldr	r2, [r7, #8]
 801e6f6:	68f9      	ldr	r1, [r7, #12]
 801e6f8:	69b8      	ldr	r0, [r7, #24]
 801e6fa:	f003 fca6 	bl	802204a <wc_Sha256Update>
 801e6fe:	61f8      	str	r0, [r7, #28]
 801e700:	69fb      	ldr	r3, [r7, #28]
 801e702:	2b00      	cmp	r3, #0
 801e704:	d104      	bne.n	801e710 <wc_Sha256Hash_ex+0x54>
                WOLFSSL_MSG("Sha256Update failed");
            }
            else if ((ret = wc_Sha256Final(sha256, hash)) != 0) {
 801e706:	6879      	ldr	r1, [r7, #4]
 801e708:	69b8      	ldr	r0, [r7, #24]
 801e70a:	f003 fd3c 	bl	8022186 <wc_Sha256Final>
 801e70e:	61f8      	str	r0, [r7, #28]
                WOLFSSL_MSG("Sha256Final failed");
            }
            wc_Sha256Free(sha256);
 801e710:	69b8      	ldr	r0, [r7, #24]
 801e712:	f003 fd74 	bl	80221fe <wc_Sha256Free>
        }


    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha256, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 801e716:	69bb      	ldr	r3, [r7, #24]
 801e718:	617b      	str	r3, [r7, #20]
 801e71a:	697b      	ldr	r3, [r7, #20]
 801e71c:	2b00      	cmp	r3, #0
 801e71e:	d002      	beq.n	801e726 <wc_Sha256Hash_ex+0x6a>
 801e720:	6978      	ldr	r0, [r7, #20]
 801e722:	f000 fac7 	bl	801ecb4 <wolfSSL_Free>
    #endif

        return ret;
 801e726:	69fb      	ldr	r3, [r7, #28]
    }
 801e728:	4618      	mov	r0, r3
 801e72a:	3720      	adds	r7, #32
 801e72c:	46bd      	mov	sp, r7
 801e72e:	bd80      	pop	{r7, pc}

0801e730 <wc_Sha256Hash>:
    int wc_Sha256Hash(const byte* data, word32 len, byte* hash)
    {
 801e730:	b580      	push	{r7, lr}
 801e732:	b088      	sub	sp, #32
 801e734:	af02      	add	r7, sp, #8
 801e736:	60f8      	str	r0, [r7, #12]
 801e738:	60b9      	str	r1, [r7, #8]
 801e73a:	607a      	str	r2, [r7, #4]
        int devId = INVALID_DEVID;
 801e73c:	f06f 0301 	mvn.w	r3, #1
 801e740:	617b      	str	r3, [r7, #20]
        /* find devId if its not an empty hash */
        if (data != NULL && len > 0) {
            devId = wc_CryptoCb_DefaultDevID();
        }
    #endif
        return wc_Sha256Hash_ex(data, len, hash, NULL, devId);
 801e742:	697b      	ldr	r3, [r7, #20]
 801e744:	9300      	str	r3, [sp, #0]
 801e746:	2300      	movs	r3, #0
 801e748:	687a      	ldr	r2, [r7, #4]
 801e74a:	68b9      	ldr	r1, [r7, #8]
 801e74c:	68f8      	ldr	r0, [r7, #12]
 801e74e:	f7ff ffb5 	bl	801e6bc <wc_Sha256Hash_ex>
 801e752:	4603      	mov	r3, r0
    }
 801e754:	4618      	mov	r0, r3
 801e756:	3718      	adds	r7, #24
 801e758:	46bd      	mov	sp, r7
 801e75a:	bd80      	pop	{r7, pc}

0801e75c <ForceZero>:
{
 801e75c:	b480      	push	{r7}
 801e75e:	b085      	sub	sp, #20
 801e760:	af00      	add	r7, sp, #0
 801e762:	6078      	str	r0, [r7, #4]
 801e764:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801e766:	687b      	ldr	r3, [r7, #4]
 801e768:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801e76a:	e004      	b.n	801e776 <ForceZero+0x1a>
 801e76c:	68fb      	ldr	r3, [r7, #12]
 801e76e:	1c5a      	adds	r2, r3, #1
 801e770:	60fa      	str	r2, [r7, #12]
 801e772:	2200      	movs	r2, #0
 801e774:	701a      	strb	r2, [r3, #0]
 801e776:	683b      	ldr	r3, [r7, #0]
 801e778:	1e5a      	subs	r2, r3, #1
 801e77a:	603a      	str	r2, [r7, #0]
 801e77c:	2b00      	cmp	r3, #0
 801e77e:	d1f5      	bne.n	801e76c <ForceZero+0x10>
}
 801e780:	bf00      	nop
 801e782:	bf00      	nop
 801e784:	3714      	adds	r7, #20
 801e786:	46bd      	mov	sp, r7
 801e788:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e78c:	4770      	bx	lr

0801e78e <wc_HmacFree>:
}
#endif /* WOLF_PRIVATE_KEY_ID */

/* Free Hmac from use with async device */
void wc_HmacFree(Hmac* hmac)
{
 801e78e:	b580      	push	{r7, lr}
 801e790:	b082      	sub	sp, #8
 801e792:	af00      	add	r7, sp, #0
 801e794:	6078      	str	r0, [r7, #4]
    if (hmac == NULL)
 801e796:	687b      	ldr	r3, [r7, #4]
 801e798:	2b00      	cmp	r3, #0
 801e79a:	d010      	beq.n	801e7be <wc_HmacFree+0x30>

#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_HMAC)
    wolfAsync_DevCtxFree(&hmac->asyncDev, WOLFSSL_ASYNC_MARKER_HMAC);
#endif /* WOLFSSL_ASYNC_CRYPT */

    switch (hmac->macType) {
 801e79c:	687b      	ldr	r3, [r7, #4]
 801e79e:	f893 3114 	ldrb.w	r3, [r3, #276]	@ 0x114
 801e7a2:	2b06      	cmp	r3, #6
 801e7a4:	d104      	bne.n	801e7b0 <wc_HmacFree+0x22>
            wc_Sha224Free(&hmac->hash.sha224);
            break;
    #endif /* WOLFSSL_SHA224 */
    #ifndef NO_SHA256
        case WC_SHA256:
            wc_Sha256Free(&hmac->hash.sha256);
 801e7a6:	687b      	ldr	r3, [r7, #4]
 801e7a8:	4618      	mov	r0, r3
 801e7aa:	f003 fd28 	bl	80221fe <wc_Sha256Free>
            break;
 801e7ae:	e000      	b.n	801e7b2 <wc_HmacFree+0x24>
            wc_Sm3Free(&hmac->hash.sm3);
            break;
    #endif

        default:
            break;
 801e7b0:	bf00      	nop
    }

    ForceZero(hmac, sizeof(*hmac));
 801e7b2:	f44f 718c 	mov.w	r1, #280	@ 0x118
 801e7b6:	6878      	ldr	r0, [r7, #4]
 801e7b8:	f7ff ffd0 	bl	801e75c <ForceZero>
 801e7bc:	e000      	b.n	801e7c0 <wc_HmacFree+0x32>
        return;
 801e7be:	bf00      	nop
}
 801e7c0:	3708      	adds	r7, #8
 801e7c2:	46bd      	mov	sp, r7
 801e7c4:	bd80      	pop	{r7, pc}
	...

0801e7c8 <wc_LoggingInit>:
#define ERRQ_LOCK()            wc_LockMutex(&wc_error_mutex)
#define ERRQ_UNLOCK()          wc_UnLockMutex(&wc_error_mutex)

/* Internal function that is called by wolfCrypt_Init() */
int wc_LoggingInit(void)
{
 801e7c8:	b580      	push	{r7, lr}
 801e7ca:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (ERRQ_MUTEX_INIT() != 0) {
 801e7cc:	480b      	ldr	r0, [pc, #44]	@ (801e7fc <wc_LoggingInit+0x34>)
 801e7ce:	f008 ff79 	bl	80276c4 <wc_InitMutex>
 801e7d2:	4603      	mov	r3, r0
 801e7d4:	2b00      	cmp	r3, #0
 801e7d6:	d002      	beq.n	801e7de <wc_LoggingInit+0x16>
        WOLFSSL_MSG("Bad Init Mutex");
        return BAD_MUTEX_E;
 801e7d8:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 801e7dc:	e00c      	b.n	801e7f8 <wc_LoggingInit+0x30>
    }
#endif
    wc_errors_count = 0;
 801e7de:	4b08      	ldr	r3, [pc, #32]	@ (801e800 <wc_LoggingInit+0x38>)
 801e7e0:	2200      	movs	r2, #0
 801e7e2:	601a      	str	r2, [r3, #0]
    wc_errors          = NULL;
 801e7e4:	4b07      	ldr	r3, [pc, #28]	@ (801e804 <wc_LoggingInit+0x3c>)
 801e7e6:	2200      	movs	r2, #0
 801e7e8:	601a      	str	r2, [r3, #0]
    wc_current_node    = NULL;
 801e7ea:	4b07      	ldr	r3, [pc, #28]	@ (801e808 <wc_LoggingInit+0x40>)
 801e7ec:	2200      	movs	r2, #0
 801e7ee:	601a      	str	r2, [r3, #0]
    wc_last_node       = NULL;
 801e7f0:	4b06      	ldr	r3, [pc, #24]	@ (801e80c <wc_LoggingInit+0x44>)
 801e7f2:	2200      	movs	r2, #0
 801e7f4:	601a      	str	r2, [r3, #0]
    return 0;
 801e7f6:	2300      	movs	r3, #0
}
 801e7f8:	4618      	mov	r0, r3
 801e7fa:	bd80      	pop	{r7, pc}
 801e7fc:	20001c40 	.word	0x20001c40
 801e800:	20001c30 	.word	0x20001c30
 801e804:	20001c2c 	.word	0x20001c2c
 801e808:	20001c38 	.word	0x20001c38
 801e80c:	20001c34 	.word	0x20001c34

0801e810 <wc_LoggingCleanup>:


/* internal function that is called by wolfCrypt_Cleanup */
int wc_LoggingCleanup(void)
{
 801e810:	b580      	push	{r7, lr}
 801e812:	af00      	add	r7, sp, #0
    /* clear logging entries */
    wc_ClearErrorNodes();
 801e814:	f000 f9d4 	bl	801ebc0 <wc_ClearErrorNodes>
    /* free mutex */
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (ERRQ_MUTEX_FREE() != 0) {
 801e818:	4805      	ldr	r0, [pc, #20]	@ (801e830 <wc_LoggingCleanup+0x20>)
 801e81a:	f008 ff5e 	bl	80276da <wc_FreeMutex>
 801e81e:	4603      	mov	r3, r0
 801e820:	2b00      	cmp	r3, #0
 801e822:	d002      	beq.n	801e82a <wc_LoggingCleanup+0x1a>
        WOLFSSL_MSG("Bad Mutex free");
        return BAD_MUTEX_E;
 801e824:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 801e828:	e000      	b.n	801e82c <wc_LoggingCleanup+0x1c>
    }
#endif
    return 0;
 801e82a:	2300      	movs	r3, #0
}
 801e82c:	4618      	mov	r0, r3
 801e82e:	bd80      	pop	{r7, pc}
 801e830:	20001c40 	.word	0x20001c40

0801e834 <peekErrorNode>:

static int peekErrorNode(int idx, const char **file, const char **reason,
        int *line)
{
 801e834:	b480      	push	{r7}
 801e836:	b087      	sub	sp, #28
 801e838:	af00      	add	r7, sp, #0
 801e83a:	60f8      	str	r0, [r7, #12]
 801e83c:	60b9      	str	r1, [r7, #8]
 801e83e:	607a      	str	r2, [r7, #4]
 801e840:	603b      	str	r3, [r7, #0]
    struct wc_error_queue* err;

    if (idx < 0) {
 801e842:	68fb      	ldr	r3, [r7, #12]
 801e844:	2b00      	cmp	r3, #0
 801e846:	da03      	bge.n	801e850 <peekErrorNode+0x1c>
        err = wc_last_node;
 801e848:	4b20      	ldr	r3, [pc, #128]	@ (801e8cc <peekErrorNode+0x98>)
 801e84a:	681b      	ldr	r3, [r3, #0]
 801e84c:	617b      	str	r3, [r7, #20]
 801e84e:	e015      	b.n	801e87c <peekErrorNode+0x48>
    }
    else {
        int i;

        err = (struct wc_error_queue*)wc_errors;
 801e850:	4b1f      	ldr	r3, [pc, #124]	@ (801e8d0 <peekErrorNode+0x9c>)
 801e852:	681b      	ldr	r3, [r3, #0]
 801e854:	617b      	str	r3, [r7, #20]
        for (i = 0; i < idx; i++) {
 801e856:	2300      	movs	r3, #0
 801e858:	613b      	str	r3, [r7, #16]
 801e85a:	e00b      	b.n	801e874 <peekErrorNode+0x40>
            if (err == NULL) {
 801e85c:	697b      	ldr	r3, [r7, #20]
 801e85e:	2b00      	cmp	r3, #0
 801e860:	d102      	bne.n	801e868 <peekErrorNode+0x34>
                WOLFSSL_MSG("Error node not found. Bad index?");
                return BAD_FUNC_ARG;
 801e862:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e866:	e02a      	b.n	801e8be <peekErrorNode+0x8a>
            }
            err = err->next;
 801e868:	697b      	ldr	r3, [r7, #20]
 801e86a:	685b      	ldr	r3, [r3, #4]
 801e86c:	617b      	str	r3, [r7, #20]
        for (i = 0; i < idx; i++) {
 801e86e:	693b      	ldr	r3, [r7, #16]
 801e870:	3301      	adds	r3, #1
 801e872:	613b      	str	r3, [r7, #16]
 801e874:	693a      	ldr	r2, [r7, #16]
 801e876:	68fb      	ldr	r3, [r7, #12]
 801e878:	429a      	cmp	r2, r3
 801e87a:	dbef      	blt.n	801e85c <peekErrorNode+0x28>
        }
    }

    if (err == NULL) {
 801e87c:	697b      	ldr	r3, [r7, #20]
 801e87e:	2b00      	cmp	r3, #0
 801e880:	d102      	bne.n	801e888 <peekErrorNode+0x54>
        WOLFSSL_MSG("No Errors in queue");
        return BAD_STATE_E;
 801e882:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 801e886:	e01a      	b.n	801e8be <peekErrorNode+0x8a>
    }

    if (file != NULL) {
 801e888:	68bb      	ldr	r3, [r7, #8]
 801e88a:	2b00      	cmp	r3, #0
 801e88c:	d004      	beq.n	801e898 <peekErrorNode+0x64>
        *file = err->file;
 801e88e:	697b      	ldr	r3, [r7, #20]
 801e890:	f103 025c 	add.w	r2, r3, #92	@ 0x5c
 801e894:	68bb      	ldr	r3, [r7, #8]
 801e896:	601a      	str	r2, [r3, #0]
    }
    if (reason != NULL) {
 801e898:	687b      	ldr	r3, [r7, #4]
 801e89a:	2b00      	cmp	r3, #0
 801e89c:	d004      	beq.n	801e8a8 <peekErrorNode+0x74>
        *reason = err->error;
 801e89e:	697b      	ldr	r3, [r7, #20]
 801e8a0:	f103 020c 	add.w	r2, r3, #12
 801e8a4:	687b      	ldr	r3, [r7, #4]
 801e8a6:	601a      	str	r2, [r3, #0]
    }
    if (line != NULL) {
 801e8a8:	683b      	ldr	r3, [r7, #0]
 801e8aa:	2b00      	cmp	r3, #0
 801e8ac:	d004      	beq.n	801e8b8 <peekErrorNode+0x84>
        *line = err->line;
 801e8ae:	697b      	ldr	r3, [r7, #20]
 801e8b0:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
 801e8b4:	683b      	ldr	r3, [r7, #0]
 801e8b6:	601a      	str	r2, [r3, #0]
    }

    return err->value;
 801e8b8:	697b      	ldr	r3, [r7, #20]
 801e8ba:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
}
 801e8be:	4618      	mov	r0, r3
 801e8c0:	371c      	adds	r7, #28
 801e8c2:	46bd      	mov	sp, r7
 801e8c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e8c8:	4770      	bx	lr
 801e8ca:	bf00      	nop
 801e8cc:	20001c34 	.word	0x20001c34
 801e8d0:	20001c2c 	.word	0x20001c2c

0801e8d4 <wc_PeekErrorNode>:
 * Returns a negative value in error case, on success returns the nodes error
 * value which is positive (absolute value)
 */
int wc_PeekErrorNode(int idx, const char **file, const char **reason,
        int *line)
{
 801e8d4:	b580      	push	{r7, lr}
 801e8d6:	b086      	sub	sp, #24
 801e8d8:	af00      	add	r7, sp, #0
 801e8da:	60f8      	str	r0, [r7, #12]
 801e8dc:	60b9      	str	r1, [r7, #8]
 801e8de:	607a      	str	r2, [r7, #4]
 801e8e0:	603b      	str	r3, [r7, #0]
    int ret;

    if (ERRQ_LOCK() != 0) {
 801e8e2:	480c      	ldr	r0, [pc, #48]	@ (801e914 <wc_PeekErrorNode+0x40>)
 801e8e4:	f008 ff04 	bl	80276f0 <wc_LockMutex>
 801e8e8:	4603      	mov	r3, r0
 801e8ea:	2b00      	cmp	r3, #0
 801e8ec:	d002      	beq.n	801e8f4 <wc_PeekErrorNode+0x20>
        WOLFSSL_MSG("Lock debug mutex failed");
        return BAD_MUTEX_E;
 801e8ee:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 801e8f2:	e00a      	b.n	801e90a <wc_PeekErrorNode+0x36>
    }
    ret = peekErrorNode(idx, file, reason, line);
 801e8f4:	683b      	ldr	r3, [r7, #0]
 801e8f6:	687a      	ldr	r2, [r7, #4]
 801e8f8:	68b9      	ldr	r1, [r7, #8]
 801e8fa:	68f8      	ldr	r0, [r7, #12]
 801e8fc:	f7ff ff9a 	bl	801e834 <peekErrorNode>
 801e900:	6178      	str	r0, [r7, #20]
    ERRQ_UNLOCK();
 801e902:	4804      	ldr	r0, [pc, #16]	@ (801e914 <wc_PeekErrorNode+0x40>)
 801e904:	f008 feff 	bl	8027706 <wc_UnLockMutex>
    return ret;
 801e908:	697b      	ldr	r3, [r7, #20]
}
 801e90a:	4618      	mov	r0, r3
 801e90c:	3718      	adds	r7, #24
 801e90e:	46bd      	mov	sp, r7
 801e910:	bd80      	pop	{r7, pc}
 801e912:	bf00      	nop
 801e914:	20001c40 	.word	0x20001c40

0801e918 <wc_AddErrorNode>:

/* create new error node and add it to the queue
 * buffers are assumed to be of size WOLFSSL_MAX_ERROR_SZ for this internal
 * function. */
int wc_AddErrorNode(int error, int line, char* buf, char* file)
{
 801e918:	b580      	push	{r7, lr}
 801e91a:	b088      	sub	sp, #32
 801e91c:	af00      	add	r7, sp, #0
 801e91e:	60f8      	str	r0, [r7, #12]
 801e920:	60b9      	str	r1, [r7, #8]
 801e922:	607a      	str	r2, [r7, #4]
 801e924:	603b      	str	r3, [r7, #0]
    struct wc_error_queue* err;

    if (wc_errors_count >= ERROR_QUEUE_MAX) {
 801e926:	4b44      	ldr	r3, [pc, #272]	@ (801ea38 <wc_AddErrorNode+0x120>)
 801e928:	681b      	ldr	r3, [r3, #0]
 801e92a:	2b63      	cmp	r3, #99	@ 0x63
 801e92c:	dd02      	ble.n	801e934 <wc_AddErrorNode+0x1c>
        WOLFSSL_MSG("Error queue is full, at ERROR_QUEUE_MAX");
        return MEMORY_E;
 801e92e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e932:	e07d      	b.n	801ea30 <wc_AddErrorNode+0x118>
    }

    err = (struct wc_error_queue*)XMALLOC(
 801e934:	20b4      	movs	r0, #180	@ 0xb4
 801e936:	f000 f9a1 	bl	801ec7c <wolfSSL_Malloc>
 801e93a:	61b8      	str	r0, [r7, #24]
            sizeof(struct wc_error_queue), wc_error_heap, DYNAMIC_TYPE_LOG);
    if (err == NULL) {
 801e93c:	69bb      	ldr	r3, [r7, #24]
 801e93e:	2b00      	cmp	r3, #0
 801e940:	d102      	bne.n	801e948 <wc_AddErrorNode+0x30>
        WOLFSSL_MSG("Unable to create error node for log");
        return MEMORY_E;
 801e942:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e946:	e073      	b.n	801ea30 <wc_AddErrorNode+0x118>
    }
    else {
        int sz;

        XMEMSET(err, 0, sizeof(struct wc_error_queue));
 801e948:	22b4      	movs	r2, #180	@ 0xb4
 801e94a:	2100      	movs	r1, #0
 801e94c:	69b8      	ldr	r0, [r7, #24]
 801e94e:	f00a f969 	bl	8028c24 <memset>
        err->heap = wc_error_heap;
 801e952:	4b3a      	ldr	r3, [pc, #232]	@ (801ea3c <wc_AddErrorNode+0x124>)
 801e954:	681a      	ldr	r2, [r3, #0]
 801e956:	69bb      	ldr	r3, [r7, #24]
 801e958:	601a      	str	r2, [r3, #0]
        sz = (int)XSTRLEN(buf);
 801e95a:	6878      	ldr	r0, [r7, #4]
 801e95c:	f7e1 fc42 	bl	80001e4 <strlen>
 801e960:	4603      	mov	r3, r0
 801e962:	61fb      	str	r3, [r7, #28]
        if (sz > WOLFSSL_MAX_ERROR_SZ - 1) {
 801e964:	69fb      	ldr	r3, [r7, #28]
 801e966:	2b4f      	cmp	r3, #79	@ 0x4f
 801e968:	dd01      	ble.n	801e96e <wc_AddErrorNode+0x56>
            sz = WOLFSSL_MAX_ERROR_SZ - 1;
 801e96a:	234f      	movs	r3, #79	@ 0x4f
 801e96c:	61fb      	str	r3, [r7, #28]
        }
        if (sz > 0) {
 801e96e:	69fb      	ldr	r3, [r7, #28]
 801e970:	2b00      	cmp	r3, #0
 801e972:	dd06      	ble.n	801e982 <wc_AddErrorNode+0x6a>
            XMEMCPY(err->error, buf, sz);
 801e974:	69bb      	ldr	r3, [r7, #24]
 801e976:	330c      	adds	r3, #12
 801e978:	69fa      	ldr	r2, [r7, #28]
 801e97a:	6879      	ldr	r1, [r7, #4]
 801e97c:	4618      	mov	r0, r3
 801e97e:	f00a fa02 	bl	8028d86 <memcpy>
        }

        sz = (int)XSTRLEN(file);
 801e982:	6838      	ldr	r0, [r7, #0]
 801e984:	f7e1 fc2e 	bl	80001e4 <strlen>
 801e988:	4603      	mov	r3, r0
 801e98a:	61fb      	str	r3, [r7, #28]
        if (sz > WOLFSSL_MAX_ERROR_SZ - 1) {
 801e98c:	69fb      	ldr	r3, [r7, #28]
 801e98e:	2b4f      	cmp	r3, #79	@ 0x4f
 801e990:	dd01      	ble.n	801e996 <wc_AddErrorNode+0x7e>
            sz = WOLFSSL_MAX_ERROR_SZ - 1;
 801e992:	234f      	movs	r3, #79	@ 0x4f
 801e994:	61fb      	str	r3, [r7, #28]
        }
        if (sz > 0) {
 801e996:	69fb      	ldr	r3, [r7, #28]
 801e998:	2b00      	cmp	r3, #0
 801e99a:	dd06      	ble.n	801e9aa <wc_AddErrorNode+0x92>
            XMEMCPY(err->file, file, sz);
 801e99c:	69bb      	ldr	r3, [r7, #24]
 801e99e:	335c      	adds	r3, #92	@ 0x5c
 801e9a0:	69fa      	ldr	r2, [r7, #28]
 801e9a2:	6839      	ldr	r1, [r7, #0]
 801e9a4:	4618      	mov	r0, r3
 801e9a6:	f00a f9ee 	bl	8028d86 <memcpy>
        }

        err->value = error;
 801e9aa:	69bb      	ldr	r3, [r7, #24]
 801e9ac:	68fa      	ldr	r2, [r7, #12]
 801e9ae:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
        err->line  = line;
 801e9b2:	69bb      	ldr	r3, [r7, #24]
 801e9b4:	68ba      	ldr	r2, [r7, #8]
 801e9b6:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

        /* make sure is terminated */
        err->error[WOLFSSL_MAX_ERROR_SZ - 1] = '\0';
 801e9ba:	69bb      	ldr	r3, [r7, #24]
 801e9bc:	2200      	movs	r2, #0
 801e9be:	f883 205b 	strb.w	r2, [r3, #91]	@ 0x5b
        err->file[WOLFSSL_MAX_ERROR_SZ - 1]  = '\0';
 801e9c2:	69bb      	ldr	r3, [r7, #24]
 801e9c4:	2200      	movs	r2, #0
 801e9c6:	f883 20ab 	strb.w	r2, [r3, #171]	@ 0xab


        /* since is queue place new node at last of the list */
        if (wc_last_node == NULL) {
 801e9ca:	4b1d      	ldr	r3, [pc, #116]	@ (801ea40 <wc_AddErrorNode+0x128>)
 801e9cc:	681b      	ldr	r3, [r3, #0]
 801e9ce:	2b00      	cmp	r3, #0
 801e9d0:	d116      	bne.n	801ea00 <wc_AddErrorNode+0xe8>
            /* case of first node added to queue */
            if (wc_errors != NULL) {
 801e9d2:	4b1c      	ldr	r3, [pc, #112]	@ (801ea44 <wc_AddErrorNode+0x12c>)
 801e9d4:	681b      	ldr	r3, [r3, #0]
 801e9d6:	2b00      	cmp	r3, #0
 801e9d8:	d008      	beq.n	801e9ec <wc_AddErrorNode+0xd4>
                WOLFSSL_MSG("ERROR in adding new node to logging queue!!");
                /* In the event both wc_last_node and wc_errors are NULL, err
                 * goes unassigned to external wc_errors, wc_last_node. Free
                 * err in this instance since wc_ClearErrorNodes will not
                 */
                XFREE(err, wc_error_heap, DYNAMIC_TYPE_LOG);
 801e9da:	69bb      	ldr	r3, [r7, #24]
 801e9dc:	617b      	str	r3, [r7, #20]
 801e9de:	697b      	ldr	r3, [r7, #20]
 801e9e0:	2b00      	cmp	r3, #0
 801e9e2:	d01f      	beq.n	801ea24 <wc_AddErrorNode+0x10c>
 801e9e4:	6978      	ldr	r0, [r7, #20]
 801e9e6:	f000 f965 	bl	801ecb4 <wolfSSL_Free>
 801e9ea:	e01b      	b.n	801ea24 <wc_AddErrorNode+0x10c>
            }
            else {
                wc_errors    = err;
 801e9ec:	4a15      	ldr	r2, [pc, #84]	@ (801ea44 <wc_AddErrorNode+0x12c>)
 801e9ee:	69bb      	ldr	r3, [r7, #24]
 801e9f0:	6013      	str	r3, [r2, #0]
                wc_last_node = err;
 801e9f2:	4a13      	ldr	r2, [pc, #76]	@ (801ea40 <wc_AddErrorNode+0x128>)
 801e9f4:	69bb      	ldr	r3, [r7, #24]
 801e9f6:	6013      	str	r3, [r2, #0]
                wc_current_node = err;
 801e9f8:	4a13      	ldr	r2, [pc, #76]	@ (801ea48 <wc_AddErrorNode+0x130>)
 801e9fa:	69bb      	ldr	r3, [r7, #24]
 801e9fc:	6013      	str	r3, [r2, #0]
 801e9fe:	e011      	b.n	801ea24 <wc_AddErrorNode+0x10c>
            }
        }
        else {
            wc_last_node->next = err;
 801ea00:	4b0f      	ldr	r3, [pc, #60]	@ (801ea40 <wc_AddErrorNode+0x128>)
 801ea02:	681b      	ldr	r3, [r3, #0]
 801ea04:	69ba      	ldr	r2, [r7, #24]
 801ea06:	605a      	str	r2, [r3, #4]
            err->prev = wc_last_node;
 801ea08:	4b0d      	ldr	r3, [pc, #52]	@ (801ea40 <wc_AddErrorNode+0x128>)
 801ea0a:	681a      	ldr	r2, [r3, #0]
 801ea0c:	69bb      	ldr	r3, [r7, #24]
 801ea0e:	609a      	str	r2, [r3, #8]
            wc_last_node = err;
 801ea10:	4a0b      	ldr	r2, [pc, #44]	@ (801ea40 <wc_AddErrorNode+0x128>)
 801ea12:	69bb      	ldr	r3, [r7, #24]
 801ea14:	6013      	str	r3, [r2, #0]

            /* check the case where have read to the end of the queue and the
             * current node to read needs updated */
            if (wc_current_node == NULL) {
 801ea16:	4b0c      	ldr	r3, [pc, #48]	@ (801ea48 <wc_AddErrorNode+0x130>)
 801ea18:	681b      	ldr	r3, [r3, #0]
 801ea1a:	2b00      	cmp	r3, #0
 801ea1c:	d102      	bne.n	801ea24 <wc_AddErrorNode+0x10c>
                wc_current_node = err;
 801ea1e:	4a0a      	ldr	r2, [pc, #40]	@ (801ea48 <wc_AddErrorNode+0x130>)
 801ea20:	69bb      	ldr	r3, [r7, #24]
 801ea22:	6013      	str	r3, [r2, #0]
            }
        }
        wc_errors_count++;
 801ea24:	4b04      	ldr	r3, [pc, #16]	@ (801ea38 <wc_AddErrorNode+0x120>)
 801ea26:	681b      	ldr	r3, [r3, #0]
 801ea28:	3301      	adds	r3, #1
 801ea2a:	4a03      	ldr	r2, [pc, #12]	@ (801ea38 <wc_AddErrorNode+0x120>)
 801ea2c:	6013      	str	r3, [r2, #0]
    }
    return 0;
 801ea2e:	2300      	movs	r3, #0
}
 801ea30:	4618      	mov	r0, r3
 801ea32:	3720      	adds	r7, #32
 801ea34:	46bd      	mov	sp, r7
 801ea36:	bd80      	pop	{r7, pc}
 801ea38:	20001c30 	.word	0x20001c30
 801ea3c:	20001c3c 	.word	0x20001c3c
 801ea40:	20001c34 	.word	0x20001c34
 801ea44:	20001c2c 	.word	0x20001c2c
 801ea48:	20001c38 	.word	0x20001c38

0801ea4c <removeErrorNode>:
    }
    return ret;
}

static void removeErrorNode(int idx)
{
 801ea4c:	b580      	push	{r7, lr}
 801ea4e:	b084      	sub	sp, #16
 801ea50:	af00      	add	r7, sp, #0
 801ea52:	6078      	str	r0, [r7, #4]
    struct wc_error_queue* current;

    if (idx == -1) {
 801ea54:	687b      	ldr	r3, [r7, #4]
 801ea56:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801ea5a:	d103      	bne.n	801ea64 <removeErrorNode+0x18>
        current = wc_last_node;
 801ea5c:	4b30      	ldr	r3, [pc, #192]	@ (801eb20 <removeErrorNode+0xd4>)
 801ea5e:	681b      	ldr	r3, [r3, #0]
 801ea60:	60fb      	str	r3, [r7, #12]
 801ea62:	e00f      	b.n	801ea84 <removeErrorNode+0x38>
    }
    else {
        current = (struct wc_error_queue*)wc_errors;
 801ea64:	4b2f      	ldr	r3, [pc, #188]	@ (801eb24 <removeErrorNode+0xd8>)
 801ea66:	681b      	ldr	r3, [r3, #0]
 801ea68:	60fb      	str	r3, [r7, #12]
        for (; current != NULL && idx > 0; idx--)
 801ea6a:	e005      	b.n	801ea78 <removeErrorNode+0x2c>
             current = current->next;
 801ea6c:	68fb      	ldr	r3, [r7, #12]
 801ea6e:	685b      	ldr	r3, [r3, #4]
 801ea70:	60fb      	str	r3, [r7, #12]
        for (; current != NULL && idx > 0; idx--)
 801ea72:	687b      	ldr	r3, [r7, #4]
 801ea74:	3b01      	subs	r3, #1
 801ea76:	607b      	str	r3, [r7, #4]
 801ea78:	68fb      	ldr	r3, [r7, #12]
 801ea7a:	2b00      	cmp	r3, #0
 801ea7c:	d002      	beq.n	801ea84 <removeErrorNode+0x38>
 801ea7e:	687b      	ldr	r3, [r7, #4]
 801ea80:	2b00      	cmp	r3, #0
 801ea82:	dcf3      	bgt.n	801ea6c <removeErrorNode+0x20>
    }
    if (current != NULL) {
 801ea84:	68fb      	ldr	r3, [r7, #12]
 801ea86:	2b00      	cmp	r3, #0
 801ea88:	d046      	beq.n	801eb18 <removeErrorNode+0xcc>
        if (current->prev != NULL)
 801ea8a:	68fb      	ldr	r3, [r7, #12]
 801ea8c:	689b      	ldr	r3, [r3, #8]
 801ea8e:	2b00      	cmp	r3, #0
 801ea90:	d004      	beq.n	801ea9c <removeErrorNode+0x50>
            current->prev->next = current->next;
 801ea92:	68fb      	ldr	r3, [r7, #12]
 801ea94:	689b      	ldr	r3, [r3, #8]
 801ea96:	68fa      	ldr	r2, [r7, #12]
 801ea98:	6852      	ldr	r2, [r2, #4]
 801ea9a:	605a      	str	r2, [r3, #4]
        if (current->next != NULL)
 801ea9c:	68fb      	ldr	r3, [r7, #12]
 801ea9e:	685b      	ldr	r3, [r3, #4]
 801eaa0:	2b00      	cmp	r3, #0
 801eaa2:	d004      	beq.n	801eaae <removeErrorNode+0x62>
            current->next->prev = current->prev;
 801eaa4:	68fb      	ldr	r3, [r7, #12]
 801eaa6:	685b      	ldr	r3, [r3, #4]
 801eaa8:	68fa      	ldr	r2, [r7, #12]
 801eaaa:	6892      	ldr	r2, [r2, #8]
 801eaac:	609a      	str	r2, [r3, #8]
        if (wc_last_node == current)
 801eaae:	4b1c      	ldr	r3, [pc, #112]	@ (801eb20 <removeErrorNode+0xd4>)
 801eab0:	681b      	ldr	r3, [r3, #0]
 801eab2:	68fa      	ldr	r2, [r7, #12]
 801eab4:	429a      	cmp	r2, r3
 801eab6:	d103      	bne.n	801eac0 <removeErrorNode+0x74>
            wc_last_node = current->prev;
 801eab8:	68fb      	ldr	r3, [r7, #12]
 801eaba:	689b      	ldr	r3, [r3, #8]
 801eabc:	4a18      	ldr	r2, [pc, #96]	@ (801eb20 <removeErrorNode+0xd4>)
 801eabe:	6013      	str	r3, [r2, #0]
        if (wc_errors == current)
 801eac0:	4b18      	ldr	r3, [pc, #96]	@ (801eb24 <removeErrorNode+0xd8>)
 801eac2:	681b      	ldr	r3, [r3, #0]
 801eac4:	68fa      	ldr	r2, [r7, #12]
 801eac6:	429a      	cmp	r2, r3
 801eac8:	d103      	bne.n	801ead2 <removeErrorNode+0x86>
            wc_errors = current->next;
 801eaca:	68fb      	ldr	r3, [r7, #12]
 801eacc:	685b      	ldr	r3, [r3, #4]
 801eace:	4a15      	ldr	r2, [pc, #84]	@ (801eb24 <removeErrorNode+0xd8>)
 801ead0:	6013      	str	r3, [r2, #0]
        if (wc_current_node == current)
 801ead2:	4b15      	ldr	r3, [pc, #84]	@ (801eb28 <removeErrorNode+0xdc>)
 801ead4:	681b      	ldr	r3, [r3, #0]
 801ead6:	68fa      	ldr	r2, [r7, #12]
 801ead8:	429a      	cmp	r2, r3
 801eada:	d103      	bne.n	801eae4 <removeErrorNode+0x98>
            wc_current_node = current->next;
 801eadc:	68fb      	ldr	r3, [r7, #12]
 801eade:	685b      	ldr	r3, [r3, #4]
 801eae0:	4a11      	ldr	r2, [pc, #68]	@ (801eb28 <removeErrorNode+0xdc>)
 801eae2:	6013      	str	r3, [r2, #0]
        XFREE(current, current->heap, DYNAMIC_TYPE_LOG);
 801eae4:	68fb      	ldr	r3, [r7, #12]
 801eae6:	60bb      	str	r3, [r7, #8]
 801eae8:	68bb      	ldr	r3, [r7, #8]
 801eaea:	2b00      	cmp	r3, #0
 801eaec:	d002      	beq.n	801eaf4 <removeErrorNode+0xa8>
 801eaee:	68b8      	ldr	r0, [r7, #8]
 801eaf0:	f000 f8e0 	bl	801ecb4 <wolfSSL_Free>
        wc_errors_count--;
 801eaf4:	4b0d      	ldr	r3, [pc, #52]	@ (801eb2c <removeErrorNode+0xe0>)
 801eaf6:	681b      	ldr	r3, [r3, #0]
 801eaf8:	3b01      	subs	r3, #1
 801eafa:	4a0c      	ldr	r2, [pc, #48]	@ (801eb2c <removeErrorNode+0xe0>)
 801eafc:	6013      	str	r3, [r2, #0]

        /* last node left in list was free'd, reset list head */
        if (wc_errors_count == 0) {
 801eafe:	4b0b      	ldr	r3, [pc, #44]	@ (801eb2c <removeErrorNode+0xe0>)
 801eb00:	681b      	ldr	r3, [r3, #0]
 801eb02:	2b00      	cmp	r3, #0
 801eb04:	d108      	bne.n	801eb18 <removeErrorNode+0xcc>
            wc_errors       = NULL;
 801eb06:	4b07      	ldr	r3, [pc, #28]	@ (801eb24 <removeErrorNode+0xd8>)
 801eb08:	2200      	movs	r2, #0
 801eb0a:	601a      	str	r2, [r3, #0]
            wc_last_node    = NULL;
 801eb0c:	4b04      	ldr	r3, [pc, #16]	@ (801eb20 <removeErrorNode+0xd4>)
 801eb0e:	2200      	movs	r2, #0
 801eb10:	601a      	str	r2, [r3, #0]
            wc_current_node = NULL;
 801eb12:	4b05      	ldr	r3, [pc, #20]	@ (801eb28 <removeErrorNode+0xdc>)
 801eb14:	2200      	movs	r2, #0
 801eb16:	601a      	str	r2, [r3, #0]
        }
    }
}
 801eb18:	bf00      	nop
 801eb1a:	3710      	adds	r7, #16
 801eb1c:	46bd      	mov	sp, r7
 801eb1e:	bd80      	pop	{r7, pc}
 801eb20:	20001c34 	.word	0x20001c34
 801eb24:	20001c2c 	.word	0x20001c2c
 801eb28:	20001c38 	.word	0x20001c38
 801eb2c:	20001c30 	.word	0x20001c30

0801eb30 <wc_RemoveErrorNode>:
 * idx : if -1 then the most recent node is looked at,
 *       otherwise search through queue for node at the given index starting
 *          from the absolute head wc_errors
 */
void wc_RemoveErrorNode(int idx)
{
 801eb30:	b580      	push	{r7, lr}
 801eb32:	b082      	sub	sp, #8
 801eb34:	af00      	add	r7, sp, #0
 801eb36:	6078      	str	r0, [r7, #4]
    if (ERRQ_LOCK() != 0) {
 801eb38:	4808      	ldr	r0, [pc, #32]	@ (801eb5c <wc_RemoveErrorNode+0x2c>)
 801eb3a:	f008 fdd9 	bl	80276f0 <wc_LockMutex>
 801eb3e:	4603      	mov	r3, r0
 801eb40:	2b00      	cmp	r3, #0
 801eb42:	d106      	bne.n	801eb52 <wc_RemoveErrorNode+0x22>
        WOLFSSL_MSG("Lock debug mutex failed");
        return;
    }

    removeErrorNode(idx);
 801eb44:	6878      	ldr	r0, [r7, #4]
 801eb46:	f7ff ff81 	bl	801ea4c <removeErrorNode>

    ERRQ_UNLOCK();
 801eb4a:	4804      	ldr	r0, [pc, #16]	@ (801eb5c <wc_RemoveErrorNode+0x2c>)
 801eb4c:	f008 fddb 	bl	8027706 <wc_UnLockMutex>
 801eb50:	e000      	b.n	801eb54 <wc_RemoveErrorNode+0x24>
        return;
 801eb52:	bf00      	nop
}
 801eb54:	3708      	adds	r7, #8
 801eb56:	46bd      	mov	sp, r7
 801eb58:	bd80      	pop	{r7, pc}
 801eb5a:	bf00      	nop
 801eb5c:	20001c40 	.word	0x20001c40

0801eb60 <clearErrorNodes>:

static void clearErrorNodes(void)
{
 801eb60:	b580      	push	{r7, lr}
 801eb62:	b084      	sub	sp, #16
 801eb64:	af00      	add	r7, sp, #0
    struct wc_error_queue* current;
    struct wc_error_queue* next;
    /* free all nodes from error queue (even previously 'pulled' ones) starting
     * at the lists absolute head of wc_errors */

    current = (struct wc_error_queue*)wc_errors;
 801eb66:	4b12      	ldr	r3, [pc, #72]	@ (801ebb0 <clearErrorNodes+0x50>)
 801eb68:	681b      	ldr	r3, [r3, #0]
 801eb6a:	60fb      	str	r3, [r7, #12]
    while (current != NULL) {
 801eb6c:	e00c      	b.n	801eb88 <clearErrorNodes+0x28>
        next = current->next;
 801eb6e:	68fb      	ldr	r3, [r7, #12]
 801eb70:	685b      	ldr	r3, [r3, #4]
 801eb72:	60bb      	str	r3, [r7, #8]
        XFREE(current, current->heap, DYNAMIC_TYPE_LOG);
 801eb74:	68fb      	ldr	r3, [r7, #12]
 801eb76:	607b      	str	r3, [r7, #4]
 801eb78:	687b      	ldr	r3, [r7, #4]
 801eb7a:	2b00      	cmp	r3, #0
 801eb7c:	d002      	beq.n	801eb84 <clearErrorNodes+0x24>
 801eb7e:	6878      	ldr	r0, [r7, #4]
 801eb80:	f000 f898 	bl	801ecb4 <wolfSSL_Free>
        current = next;
 801eb84:	68bb      	ldr	r3, [r7, #8]
 801eb86:	60fb      	str	r3, [r7, #12]
    while (current != NULL) {
 801eb88:	68fb      	ldr	r3, [r7, #12]
 801eb8a:	2b00      	cmp	r3, #0
 801eb8c:	d1ef      	bne.n	801eb6e <clearErrorNodes+0xe>
    }

    wc_errors_count = 0;
 801eb8e:	4b09      	ldr	r3, [pc, #36]	@ (801ebb4 <clearErrorNodes+0x54>)
 801eb90:	2200      	movs	r2, #0
 801eb92:	601a      	str	r2, [r3, #0]
    wc_errors       = NULL;
 801eb94:	4b06      	ldr	r3, [pc, #24]	@ (801ebb0 <clearErrorNodes+0x50>)
 801eb96:	2200      	movs	r2, #0
 801eb98:	601a      	str	r2, [r3, #0]
    wc_last_node    = NULL;
 801eb9a:	4b07      	ldr	r3, [pc, #28]	@ (801ebb8 <clearErrorNodes+0x58>)
 801eb9c:	2200      	movs	r2, #0
 801eb9e:	601a      	str	r2, [r3, #0]
    wc_current_node = NULL;
 801eba0:	4b06      	ldr	r3, [pc, #24]	@ (801ebbc <clearErrorNodes+0x5c>)
 801eba2:	2200      	movs	r2, #0
 801eba4:	601a      	str	r2, [r3, #0]
}
 801eba6:	bf00      	nop
 801eba8:	3710      	adds	r7, #16
 801ebaa:	46bd      	mov	sp, r7
 801ebac:	bd80      	pop	{r7, pc}
 801ebae:	bf00      	nop
 801ebb0:	20001c2c 	.word	0x20001c2c
 801ebb4:	20001c30 	.word	0x20001c30
 801ebb8:	20001c34 	.word	0x20001c34
 801ebbc:	20001c38 	.word	0x20001c38

0801ebc0 <wc_ClearErrorNodes>:

/* Clears out the list of error nodes.
 */
void wc_ClearErrorNodes(void)
{
 801ebc0:	b580      	push	{r7, lr}
 801ebc2:	af00      	add	r7, sp, #0
    if (ERRQ_LOCK() != 0) {
 801ebc4:	4806      	ldr	r0, [pc, #24]	@ (801ebe0 <wc_ClearErrorNodes+0x20>)
 801ebc6:	f008 fd93 	bl	80276f0 <wc_LockMutex>
 801ebca:	4603      	mov	r3, r0
 801ebcc:	2b00      	cmp	r3, #0
 801ebce:	d105      	bne.n	801ebdc <wc_ClearErrorNodes+0x1c>
        WOLFSSL_MSG("Lock debug mutex failed");
        return;
    }

    clearErrorNodes();
 801ebd0:	f7ff ffc6 	bl	801eb60 <clearErrorNodes>

    ERRQ_UNLOCK();
 801ebd4:	4802      	ldr	r0, [pc, #8]	@ (801ebe0 <wc_ClearErrorNodes+0x20>)
 801ebd6:	f008 fd96 	bl	8027706 <wc_UnLockMutex>
 801ebda:	e000      	b.n	801ebde <wc_ClearErrorNodes+0x1e>
        return;
 801ebdc:	bf00      	nop
}
 801ebde:	bd80      	pop	{r7, pc}
 801ebe0:	20001c40 	.word	0x20001c40

0801ebe4 <WOLFSSL_ERROR_LINE>:
void WOLFSSL_ERROR_LINE(int error, const char* func, unsigned int line,
        const char* file, void* usrCtx)
#else
void WOLFSSL_ERROR(int error)
#endif
{
 801ebe4:	b580      	push	{r7, lr}
 801ebe6:	b09a      	sub	sp, #104	@ 0x68
 801ebe8:	af02      	add	r7, sp, #8
 801ebea:	60f8      	str	r0, [r7, #12]
 801ebec:	60b9      	str	r1, [r7, #8]
 801ebee:	607a      	str	r2, [r7, #4]
 801ebf0:	603b      	str	r3, [r7, #0]

    #ifdef WOLFSSL_HAVE_ERROR_QUEUE
        (void)usrCtx; /* a user ctx for future flexibility */
        (void)func;

        if (ERRQ_LOCK() != 0) {
 801ebf2:	481f      	ldr	r0, [pc, #124]	@ (801ec70 <WOLFSSL_ERROR_LINE+0x8c>)
 801ebf4:	f008 fd7c 	bl	80276f0 <wc_LockMutex>
 801ebf8:	4603      	mov	r3, r0
 801ebfa:	2b00      	cmp	r3, #0
 801ebfc:	d007      	beq.n	801ec0e <WOLFSSL_ERROR_LINE+0x2a>
            WOLFSSL_MSG("Lock debug mutex failed");
            (void)XSNPRINTF(buffer, sizeof(buffer),
 801ebfe:	f107 0010 	add.w	r0, r7, #16
 801ec02:	68fb      	ldr	r3, [r7, #12]
 801ec04:	4a1b      	ldr	r2, [pc, #108]	@ (801ec74 <WOLFSSL_ERROR_LINE+0x90>)
 801ec06:	2150      	movs	r1, #80	@ 0x50
 801ec08:	f009 fed4 	bl	80289b4 <sniprintf>
    #ifdef DEBUG_WOLFSSL
        if (loggingEnabled)
            wolfssl_log(ERROR_LOG, NULL, 0, buffer);
    #endif
    }
}
 801ec0c:	e02c      	b.n	801ec68 <WOLFSSL_ERROR_LINE+0x84>
            if (error != WC_NO_ERR_TRACE(WANT_READ) &&
 801ec0e:	68fb      	ldr	r3, [r7, #12]
 801ec10:	f46f 72a1 	mvn.w	r2, #322	@ 0x142
 801ec14:	4293      	cmp	r3, r2
 801ec16:	d01d      	beq.n	801ec54 <WOLFSSL_ERROR_LINE+0x70>
 801ec18:	68fb      	ldr	r3, [r7, #12]
 801ec1a:	f46f 72a3 	mvn.w	r2, #326	@ 0x146
 801ec1e:	4293      	cmp	r3, r2
 801ec20:	d018      	beq.n	801ec54 <WOLFSSL_ERROR_LINE+0x70>
            if (error < 0)
 801ec22:	68fb      	ldr	r3, [r7, #12]
 801ec24:	2b00      	cmp	r3, #0
 801ec26:	da02      	bge.n	801ec2e <WOLFSSL_ERROR_LINE+0x4a>
                error = error - (2 * error); /* get absolute value */
 801ec28:	68fb      	ldr	r3, [r7, #12]
 801ec2a:	425b      	negs	r3, r3
 801ec2c:	60fb      	str	r3, [r7, #12]
            (void)XSNPRINTF(buffer, sizeof(buffer),
 801ec2e:	f107 0010 	add.w	r0, r7, #16
 801ec32:	683b      	ldr	r3, [r7, #0]
 801ec34:	9301      	str	r3, [sp, #4]
 801ec36:	687b      	ldr	r3, [r7, #4]
 801ec38:	9300      	str	r3, [sp, #0]
 801ec3a:	68fb      	ldr	r3, [r7, #12]
 801ec3c:	4a0e      	ldr	r2, [pc, #56]	@ (801ec78 <WOLFSSL_ERROR_LINE+0x94>)
 801ec3e:	2150      	movs	r1, #80	@ 0x50
 801ec40:	f009 feb8 	bl	80289b4 <sniprintf>
            if (wc_AddErrorNode(error, (int)line, buffer, (char*)file) != 0) {
 801ec44:	6879      	ldr	r1, [r7, #4]
 801ec46:	f107 0210 	add.w	r2, r7, #16
 801ec4a:	683b      	ldr	r3, [r7, #0]
 801ec4c:	68f8      	ldr	r0, [r7, #12]
 801ec4e:	f7ff fe63 	bl	801e918 <wc_AddErrorNode>
 801ec52:	e006      	b.n	801ec62 <WOLFSSL_ERROR_LINE+0x7e>
                (void)XSNPRINTF(buffer, sizeof(buffer),
 801ec54:	f107 0010 	add.w	r0, r7, #16
 801ec58:	68fb      	ldr	r3, [r7, #12]
 801ec5a:	4a06      	ldr	r2, [pc, #24]	@ (801ec74 <WOLFSSL_ERROR_LINE+0x90>)
 801ec5c:	2150      	movs	r1, #80	@ 0x50
 801ec5e:	f009 fea9 	bl	80289b4 <sniprintf>
            ERRQ_UNLOCK();
 801ec62:	4803      	ldr	r0, [pc, #12]	@ (801ec70 <WOLFSSL_ERROR_LINE+0x8c>)
 801ec64:	f008 fd4f 	bl	8027706 <wc_UnLockMutex>
}
 801ec68:	bf00      	nop
 801ec6a:	3760      	adds	r7, #96	@ 0x60
 801ec6c:	46bd      	mov	sp, r7
 801ec6e:	bd80      	pop	{r7, pc}
 801ec70:	20001c40 	.word	0x20001c40
 801ec74:	08030ca4 	.word	0x08030ca4
 801ec78:	08030cc8 	.word	0x08030cc8

0801ec7c <wolfSSL_Malloc>:
#ifdef WOLFSSL_DEBUG_MEMORY
void* wolfSSL_Malloc(size_t size, const char* func, unsigned int line)
#else
void* wolfSSL_Malloc(size_t size)
#endif
{
 801ec7c:	b580      	push	{r7, lr}
 801ec7e:	b084      	sub	sp, #16
 801ec80:	af00      	add	r7, sp, #0
 801ec82:	6078      	str	r0, [r7, #4]
    void* res = 0;
 801ec84:	2300      	movs	r3, #0
 801ec86:	60fb      	str	r3, [r7, #12]
#ifdef WOLFSSL_CHECK_MEM_ZERO
    /* Space for requested size. */
    size += MEM_ALIGN;
#endif

    if (malloc_function) {
 801ec88:	4b09      	ldr	r3, [pc, #36]	@ (801ecb0 <wolfSSL_Malloc+0x34>)
 801ec8a:	681b      	ldr	r3, [r3, #0]
 801ec8c:	2b00      	cmp	r3, #0
 801ec8e:	d005      	beq.n	801ec9c <wolfSSL_Malloc+0x20>
    #ifdef WOLFSSL_DEBUG_MEMORY
        res = malloc_function(size, func, line);
    #else
        res = malloc_function(size);
 801ec90:	4b07      	ldr	r3, [pc, #28]	@ (801ecb0 <wolfSSL_Malloc+0x34>)
 801ec92:	681b      	ldr	r3, [r3, #0]
 801ec94:	6878      	ldr	r0, [r7, #4]
 801ec96:	4798      	blx	r3
 801ec98:	60f8      	str	r0, [r7, #12]
 801ec9a:	e004      	b.n	801eca6 <wolfSSL_Malloc+0x2a>
            WOLFSSL_MSG("Malloc too big!");
            return NULL;
        }
        #endif

        res = malloc(size); /* native heap */
 801ec9c:	6878      	ldr	r0, [r7, #4]
 801ec9e:	f009 fc6b 	bl	8028578 <malloc>
 801eca2:	4603      	mov	r3, r0
 801eca4:	60fb      	str	r3, [r7, #12]
        gMemFailCount = gMemFailCountSeed; /* reset */
        return NULL;
    }
#endif

    return res;
 801eca6:	68fb      	ldr	r3, [r7, #12]
}
 801eca8:	4618      	mov	r0, r3
 801ecaa:	3710      	adds	r7, #16
 801ecac:	46bd      	mov	sp, r7
 801ecae:	bd80      	pop	{r7, pc}
 801ecb0:	20001c44 	.word	0x20001c44

0801ecb4 <wolfSSL_Free>:
#ifdef WOLFSSL_DEBUG_MEMORY
void wolfSSL_Free(void *ptr, const char* func, unsigned int line)
#else
void wolfSSL_Free(void *ptr)
#endif
{
 801ecb4:	b580      	push	{r7, lr}
 801ecb6:	b082      	sub	sp, #8
 801ecb8:	af00      	add	r7, sp, #0
 801ecba:	6078      	str	r0, [r7, #4]
#endif
#ifdef WOLFSSL_MEM_FAIL_COUNT
    wc_MemFailCount_FreeMem();
#endif

    if (free_function) {
 801ecbc:	4b07      	ldr	r3, [pc, #28]	@ (801ecdc <wolfSSL_Free+0x28>)
 801ecbe:	681b      	ldr	r3, [r3, #0]
 801ecc0:	2b00      	cmp	r3, #0
 801ecc2:	d004      	beq.n	801ecce <wolfSSL_Free+0x1a>
    #ifdef WOLFSSL_DEBUG_MEMORY
        free_function(ptr, func, line);
    #else
        free_function(ptr);
 801ecc4:	4b05      	ldr	r3, [pc, #20]	@ (801ecdc <wolfSSL_Free+0x28>)
 801ecc6:	681b      	ldr	r3, [r3, #0]
 801ecc8:	6878      	ldr	r0, [r7, #4]
 801ecca:	4798      	blx	r3
        free(ptr); /* native heap */
    #else
        WOLFSSL_MSG("No free available");
    #endif
    }
}
 801eccc:	e002      	b.n	801ecd4 <wolfSSL_Free+0x20>
        free(ptr); /* native heap */
 801ecce:	6878      	ldr	r0, [r7, #4]
 801ecd0:	f009 fc5a 	bl	8028588 <free>
}
 801ecd4:	bf00      	nop
 801ecd6:	3708      	adds	r7, #8
 801ecd8:	46bd      	mov	sp, r7
 801ecda:	bd80      	pop	{r7, pc}
 801ecdc:	20001c48 	.word	0x20001c48

0801ece0 <rotlFixed>:
    {
 801ece0:	b480      	push	{r7}
 801ece2:	b083      	sub	sp, #12
 801ece4:	af00      	add	r7, sp, #0
 801ece6:	6078      	str	r0, [r7, #4]
 801ece8:	6039      	str	r1, [r7, #0]
        return (x << y) | (x >> (sizeof(x) * 8 - y));
 801ecea:	687a      	ldr	r2, [r7, #4]
 801ecec:	683b      	ldr	r3, [r7, #0]
 801ecee:	f1c3 0320 	rsb	r3, r3, #32
 801ecf2:	fa62 f303 	ror.w	r3, r2, r3
    }
 801ecf6:	4618      	mov	r0, r3
 801ecf8:	370c      	adds	r7, #12
 801ecfa:	46bd      	mov	sp, r7
 801ecfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ed00:	4770      	bx	lr

0801ed02 <ByteReverseWord32>:
{
 801ed02:	b580      	push	{r7, lr}
 801ed04:	b082      	sub	sp, #8
 801ed06:	af00      	add	r7, sp, #0
 801ed08:	6078      	str	r0, [r7, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 801ed0a:	687b      	ldr	r3, [r7, #4]
 801ed0c:	0a1b      	lsrs	r3, r3, #8
 801ed0e:	f003 12ff 	and.w	r2, r3, #16711935	@ 0xff00ff
 801ed12:	687b      	ldr	r3, [r7, #4]
 801ed14:	021b      	lsls	r3, r3, #8
 801ed16:	f003 23ff 	and.w	r3, r3, #4278255360	@ 0xff00ff00
 801ed1a:	4313      	orrs	r3, r2
 801ed1c:	607b      	str	r3, [r7, #4]
    return rotlFixed(value, 16U);
 801ed1e:	2110      	movs	r1, #16
 801ed20:	6878      	ldr	r0, [r7, #4]
 801ed22:	f7ff ffdd 	bl	801ece0 <rotlFixed>
 801ed26:	4603      	mov	r3, r0
}
 801ed28:	4618      	mov	r0, r3
 801ed2a:	3708      	adds	r7, #8
 801ed2c:	46bd      	mov	sp, r7
 801ed2e:	bd80      	pop	{r7, pc}

0801ed30 <ForceZero>:
{
 801ed30:	b480      	push	{r7}
 801ed32:	b085      	sub	sp, #20
 801ed34:	af00      	add	r7, sp, #0
 801ed36:	6078      	str	r0, [r7, #4]
 801ed38:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801ed3a:	687b      	ldr	r3, [r7, #4]
 801ed3c:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801ed3e:	e004      	b.n	801ed4a <ForceZero+0x1a>
 801ed40:	68fb      	ldr	r3, [r7, #12]
 801ed42:	1c5a      	adds	r2, r3, #1
 801ed44:	60fa      	str	r2, [r7, #12]
 801ed46:	2200      	movs	r2, #0
 801ed48:	701a      	strb	r2, [r3, #0]
 801ed4a:	683b      	ldr	r3, [r7, #0]
 801ed4c:	1e5a      	subs	r2, r3, #1
 801ed4e:	603a      	str	r2, [r7, #0]
 801ed50:	2b00      	cmp	r3, #0
 801ed52:	d1f5      	bne.n	801ed40 <ForceZero+0x10>
}
 801ed54:	bf00      	nop
 801ed56:	bf00      	nop
 801ed58:	3714      	adds	r7, #20
 801ed5a:	46bd      	mov	sp, r7
 801ed5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ed60:	4770      	bx	lr

0801ed62 <ConstantCompare>:
{
 801ed62:	b480      	push	{r7}
 801ed64:	b087      	sub	sp, #28
 801ed66:	af00      	add	r7, sp, #0
 801ed68:	60f8      	str	r0, [r7, #12]
 801ed6a:	60b9      	str	r1, [r7, #8]
 801ed6c:	607a      	str	r2, [r7, #4]
    int compareSum = 0;
 801ed6e:	2300      	movs	r3, #0
 801ed70:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801ed72:	2300      	movs	r3, #0
 801ed74:	617b      	str	r3, [r7, #20]
 801ed76:	e010      	b.n	801ed9a <ConstantCompare+0x38>
        compareSum |= a[i] ^ b[i];
 801ed78:	697b      	ldr	r3, [r7, #20]
 801ed7a:	68fa      	ldr	r2, [r7, #12]
 801ed7c:	4413      	add	r3, r2
 801ed7e:	781a      	ldrb	r2, [r3, #0]
 801ed80:	697b      	ldr	r3, [r7, #20]
 801ed82:	68b9      	ldr	r1, [r7, #8]
 801ed84:	440b      	add	r3, r1
 801ed86:	781b      	ldrb	r3, [r3, #0]
 801ed88:	4053      	eors	r3, r2
 801ed8a:	b2db      	uxtb	r3, r3
 801ed8c:	461a      	mov	r2, r3
 801ed8e:	693b      	ldr	r3, [r7, #16]
 801ed90:	4313      	orrs	r3, r2
 801ed92:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801ed94:	697b      	ldr	r3, [r7, #20]
 801ed96:	3301      	adds	r3, #1
 801ed98:	617b      	str	r3, [r7, #20]
 801ed9a:	697a      	ldr	r2, [r7, #20]
 801ed9c:	687b      	ldr	r3, [r7, #4]
 801ed9e:	429a      	cmp	r2, r3
 801eda0:	dbea      	blt.n	801ed78 <ConstantCompare+0x16>
    return compareSum;
 801eda2:	693b      	ldr	r3, [r7, #16]
}
 801eda4:	4618      	mov	r0, r3
 801eda6:	371c      	adds	r7, #28
 801eda8:	46bd      	mov	sp, r7
 801edaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801edae:	4770      	bx	lr

0801edb0 <min>:
    {
 801edb0:	b480      	push	{r7}
 801edb2:	b083      	sub	sp, #12
 801edb4:	af00      	add	r7, sp, #0
 801edb6:	6078      	str	r0, [r7, #4]
 801edb8:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 801edba:	687a      	ldr	r2, [r7, #4]
 801edbc:	683b      	ldr	r3, [r7, #0]
 801edbe:	4293      	cmp	r3, r2
 801edc0:	bf28      	it	cs
 801edc2:	4613      	movcs	r3, r2
    }
 801edc4:	4618      	mov	r0, r3
 801edc6:	370c      	adds	r7, #12
 801edc8:	46bd      	mov	sp, r7
 801edca:	f85d 7b04 	ldr.w	r7, [sp], #4
 801edce:	4770      	bx	lr

0801edd0 <Hash_df>:
/* Hash Derivation Function */
/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_df(DRBG_internal* drbg, byte* out, word32 outSz, byte type,
                                                  const byte* inA, word32 inASz,
                                                  const byte* inB, word32 inBSz)
{
 801edd0:	b580      	push	{r7, lr}
 801edd2:	b0a8      	sub	sp, #160	@ 0xa0
 801edd4:	af00      	add	r7, sp, #0
 801edd6:	60f8      	str	r0, [r7, #12]
 801edd8:	60b9      	str	r1, [r7, #8]
 801edda:	607a      	str	r2, [r7, #4]
 801eddc:	70fb      	strb	r3, [r7, #3]
    int ret = DRBG_FAILURE;
 801edde:	2301      	movs	r3, #1
 801ede0:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    byte ctr;
    word32 i;
    word32 len;
    word32 bits = (outSz * 8); /* reverse byte order */
 801ede4:	687b      	ldr	r3, [r7, #4]
 801ede6:	00db      	lsls	r3, r3, #3
 801ede8:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    byte* digest;
#else
    byte digest[WC_SHA256_DIGEST_SIZE];
#endif

    if (drbg == NULL) {
 801edec:	68fb      	ldr	r3, [r7, #12]
 801edee:	2b00      	cmp	r3, #0
 801edf0:	d101      	bne.n	801edf6 <Hash_df+0x26>
        return DRBG_FAILURE;
 801edf2:	2301      	movs	r3, #1
 801edf4:	e0d8      	b.n	801efa8 <Hash_df+0x1d8>
    }

#ifdef WOLFSSL_SMALL_STACK
    digest = (byte*)XMALLOC(WC_SHA256_DIGEST_SIZE, drbg->heap,
 801edf6:	2020      	movs	r0, #32
 801edf8:	f7ff ff40 	bl	801ec7c <wolfSSL_Malloc>
 801edfc:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
        DYNAMIC_TYPE_DIGEST);
    if (digest == NULL)
 801ee00:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801ee04:	2b00      	cmp	r3, #0
 801ee06:	d101      	bne.n	801ee0c <Hash_df+0x3c>
        return DRBG_FAILURE;
 801ee08:	2301      	movs	r3, #1
 801ee0a:	e0cd      	b.n	801efa8 <Hash_df+0x1d8>
#endif

#ifdef LITTLE_ENDIAN_ORDER
    bits = ByteReverseWord32(bits);
 801ee0c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ee10:	4618      	mov	r0, r3
 801ee12:	f7ff ff76 	bl	801ed02 <ByteReverseWord32>
 801ee16:	4603      	mov	r3, r0
 801ee18:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
#endif
    len = (outSz / OUTPUT_BLOCK_LEN)
 801ee1c:	687b      	ldr	r3, [r7, #4]
 801ee1e:	095b      	lsrs	r3, r3, #5
        + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 801ee20:	687a      	ldr	r2, [r7, #4]
 801ee22:	f002 021f 	and.w	r2, r2, #31
 801ee26:	2a00      	cmp	r2, #0
 801ee28:	d001      	beq.n	801ee2e <Hash_df+0x5e>
 801ee2a:	2201      	movs	r2, #1
 801ee2c:	e000      	b.n	801ee30 <Hash_df+0x60>
 801ee2e:	2200      	movs	r2, #0
    len = (outSz / OUTPUT_BLOCK_LEN)
 801ee30:	4413      	add	r3, r2
 801ee32:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90

    ctr = 1;
 801ee36:	2301      	movs	r3, #1
 801ee38:	f887 308b 	strb.w	r3, [r7, #139]	@ 0x8b
    for (i = 0; i < len; i++) {
 801ee3c:	2300      	movs	r3, #0
 801ee3e:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 801ee42:	e090      	b.n	801ef66 <Hash_df+0x196>
#ifndef WOLFSSL_SMALL_STACK_CACHE
    #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    #else
        ret = wc_InitSha256(sha);
 801ee44:	f107 0314 	add.w	r3, r7, #20
 801ee48:	4618      	mov	r0, r3
 801ee4a:	f003 f9c7 	bl	80221dc <wc_InitSha256>
 801ee4e:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
    #endif
        if (ret != 0)
 801ee52:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ee56:	2b00      	cmp	r3, #0
 801ee58:	f040 808d 	bne.w	801ef76 <Hash_df+0x1a6>
            break;
#endif
        ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));
 801ee5c:	f107 018b 	add.w	r1, r7, #139	@ 0x8b
 801ee60:	f107 0314 	add.w	r3, r7, #20
 801ee64:	2201      	movs	r2, #1
 801ee66:	4618      	mov	r0, r3
 801ee68:	f003 f8ef 	bl	802204a <wc_Sha256Update>
 801ee6c:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        if (ret == 0) {
 801ee70:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ee74:	2b00      	cmp	r3, #0
 801ee76:	d10f      	bne.n	801ee98 <Hash_df+0xc8>
            ctr++;
 801ee78:	f897 308b 	ldrb.w	r3, [r7, #139]	@ 0x8b
 801ee7c:	3301      	adds	r3, #1
 801ee7e:	b2db      	uxtb	r3, r3
 801ee80:	f887 308b 	strb.w	r3, [r7, #139]	@ 0x8b
            ret = wc_Sha256Update(sha, (byte*)&bits, sizeof(bits));
 801ee84:	f107 0184 	add.w	r1, r7, #132	@ 0x84
 801ee88:	f107 0314 	add.w	r3, r7, #20
 801ee8c:	2204      	movs	r2, #4
 801ee8e:	4618      	mov	r0, r3
 801ee90:	f003 f8db 	bl	802204a <wc_Sha256Update>
 801ee94:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        }

        if (ret == 0) {
 801ee98:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ee9c:	2b00      	cmp	r3, #0
 801ee9e:	d10b      	bne.n	801eeb8 <Hash_df+0xe8>
            /* churning V is the only string that doesn't have the type added */
            if (type != drbgInitV)
 801eea0:	78fb      	ldrb	r3, [r7, #3]
 801eea2:	2b04      	cmp	r3, #4
 801eea4:	d008      	beq.n	801eeb8 <Hash_df+0xe8>
                ret = wc_Sha256Update(sha, &type, sizeof(type));
 801eea6:	1cf9      	adds	r1, r7, #3
 801eea8:	f107 0314 	add.w	r3, r7, #20
 801eeac:	2201      	movs	r2, #1
 801eeae:	4618      	mov	r0, r3
 801eeb0:	f003 f8cb 	bl	802204a <wc_Sha256Update>
 801eeb4:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        }
        if (ret == 0)
 801eeb8:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801eebc:	2b00      	cmp	r3, #0
 801eebe:	d10a      	bne.n	801eed6 <Hash_df+0x106>
            ret = wc_Sha256Update(sha, inA, inASz);
 801eec0:	f107 0314 	add.w	r3, r7, #20
 801eec4:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801eec8:	f8d7 10a8 	ldr.w	r1, [r7, #168]	@ 0xa8
 801eecc:	4618      	mov	r0, r3
 801eece:	f003 f8bc 	bl	802204a <wc_Sha256Update>
 801eed2:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        if (ret == 0) {
 801eed6:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801eeda:	2b00      	cmp	r3, #0
 801eedc:	d112      	bne.n	801ef04 <Hash_df+0x134>
            if (inB != NULL && inBSz > 0)
 801eede:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801eee2:	2b00      	cmp	r3, #0
 801eee4:	d00e      	beq.n	801ef04 <Hash_df+0x134>
 801eee6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801eeea:	2b00      	cmp	r3, #0
 801eeec:	d00a      	beq.n	801ef04 <Hash_df+0x134>
                ret = wc_Sha256Update(sha, inB, inBSz);
 801eeee:	f107 0314 	add.w	r3, r7, #20
 801eef2:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 801eef6:	f8d7 10b0 	ldr.w	r1, [r7, #176]	@ 0xb0
 801eefa:	4618      	mov	r0, r3
 801eefc:	f003 f8a5 	bl	802204a <wc_Sha256Update>
 801ef00:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        }
        if (ret == 0)
 801ef04:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ef08:	2b00      	cmp	r3, #0
 801ef0a:	d108      	bne.n	801ef1e <Hash_df+0x14e>
            ret = wc_Sha256Final(sha, digest);
 801ef0c:	f107 0314 	add.w	r3, r7, #20
 801ef10:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 801ef14:	4618      	mov	r0, r3
 801ef16:	f003 f936 	bl	8022186 <wc_Sha256Final>
 801ef1a:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c

#ifndef WOLFSSL_SMALL_STACK_CACHE
        wc_Sha256Free(sha);
 801ef1e:	f107 0314 	add.w	r3, r7, #20
 801ef22:	4618      	mov	r0, r3
 801ef24:	f003 f96b 	bl	80221fe <wc_Sha256Free>
#endif
        if (ret == 0) {
 801ef28:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ef2c:	2b00      	cmp	r3, #0
 801ef2e:	d115      	bne.n	801ef5c <Hash_df+0x18c>
            if (outSz > OUTPUT_BLOCK_LEN) {
 801ef30:	687b      	ldr	r3, [r7, #4]
 801ef32:	2b20      	cmp	r3, #32
 801ef34:	d90c      	bls.n	801ef50 <Hash_df+0x180>
                XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
 801ef36:	2220      	movs	r2, #32
 801ef38:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 801ef3c:	68b8      	ldr	r0, [r7, #8]
 801ef3e:	f009 ff22 	bl	8028d86 <memcpy>
                outSz -= OUTPUT_BLOCK_LEN;
 801ef42:	687b      	ldr	r3, [r7, #4]
 801ef44:	3b20      	subs	r3, #32
 801ef46:	607b      	str	r3, [r7, #4]
                out += OUTPUT_BLOCK_LEN;
 801ef48:	68bb      	ldr	r3, [r7, #8]
 801ef4a:	3320      	adds	r3, #32
 801ef4c:	60bb      	str	r3, [r7, #8]
 801ef4e:	e005      	b.n	801ef5c <Hash_df+0x18c>
            }
            else {
                XMEMCPY(out, digest, outSz);
 801ef50:	687a      	ldr	r2, [r7, #4]
 801ef52:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 801ef56:	68b8      	ldr	r0, [r7, #8]
 801ef58:	f009 ff15 	bl	8028d86 <memcpy>
    for (i = 0; i < len; i++) {
 801ef5c:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ef60:	3301      	adds	r3, #1
 801ef62:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 801ef66:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801ef6a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801ef6e:	429a      	cmp	r2, r3
 801ef70:	f4ff af68 	bcc.w	801ee44 <Hash_df+0x74>
 801ef74:	e000      	b.n	801ef78 <Hash_df+0x1a8>
            break;
 801ef76:	bf00      	nop
            }
        }
    }

    ForceZero(digest, WC_SHA256_DIGEST_SIZE);
 801ef78:	2120      	movs	r1, #32
 801ef7a:	f8d7 0094 	ldr.w	r0, [r7, #148]	@ 0x94
 801ef7e:	f7ff fed7 	bl	801ed30 <ForceZero>

#ifdef WOLFSSL_SMALL_STACK
    XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801ef82:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801ef86:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801ef8a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ef8e:	2b00      	cmp	r3, #0
 801ef90:	d003      	beq.n	801ef9a <Hash_df+0x1ca>
 801ef92:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801ef96:	f7ff fe8d 	bl	801ecb4 <wolfSSL_Free>
#endif

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801ef9a:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ef9e:	2b00      	cmp	r3, #0
 801efa0:	bf14      	ite	ne
 801efa2:	2301      	movne	r3, #1
 801efa4:	2300      	moveq	r3, #0
 801efa6:	b2db      	uxtb	r3, r3
}
 801efa8:	4618      	mov	r0, r3
 801efaa:	37a0      	adds	r7, #160	@ 0xa0
 801efac:	46bd      	mov	sp, r7
 801efae:	bd80      	pop	{r7, pc}

0801efb0 <Hash_DRBG_Reseed>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Reseed(DRBG_internal* drbg, const byte* seed, word32 seedSz)
{
 801efb0:	b580      	push	{r7, lr}
 801efb2:	b08c      	sub	sp, #48	@ 0x30
 801efb4:	af04      	add	r7, sp, #16
 801efb6:	60f8      	str	r0, [r7, #12]
 801efb8:	60b9      	str	r1, [r7, #8]
 801efba:	607a      	str	r2, [r7, #4]
    byte* newV;
#else
    byte newV[DRBG_SEED_LEN];
#endif

    if (drbg == NULL) {
 801efbc:	68fb      	ldr	r3, [r7, #12]
 801efbe:	2b00      	cmp	r3, #0
 801efc0:	d101      	bne.n	801efc6 <Hash_DRBG_Reseed+0x16>
        return DRBG_FAILURE;
 801efc2:	2301      	movs	r3, #1
 801efc4:	e04d      	b.n	801f062 <Hash_DRBG_Reseed+0xb2>
    }

#ifdef WOLFSSL_SMALL_STACK
    newV = (byte*)XMALLOC(DRBG_SEED_LEN, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801efc6:	2037      	movs	r0, #55	@ 0x37
 801efc8:	f7ff fe58 	bl	801ec7c <wolfSSL_Malloc>
 801efcc:	61b8      	str	r0, [r7, #24]
    if (newV == NULL) {
 801efce:	69bb      	ldr	r3, [r7, #24]
 801efd0:	2b00      	cmp	r3, #0
 801efd2:	d102      	bne.n	801efda <Hash_DRBG_Reseed+0x2a>
        return MEMORY_E;
 801efd4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801efd8:	e043      	b.n	801f062 <Hash_DRBG_Reseed+0xb2>
    }
#endif
    XMEMSET(newV, 0, DRBG_SEED_LEN);
 801efda:	2237      	movs	r2, #55	@ 0x37
 801efdc:	2100      	movs	r1, #0
 801efde:	69b8      	ldr	r0, [r7, #24]
 801efe0:	f009 fe20 	bl	8028c24 <memset>

    ret = Hash_df(drbg, newV, DRBG_SEED_LEN, drbgReseed,
                drbg->V, sizeof(drbg->V), seed, seedSz);
 801efe4:	68fb      	ldr	r3, [r7, #12]
 801efe6:	3304      	adds	r3, #4
    ret = Hash_df(drbg, newV, DRBG_SEED_LEN, drbgReseed,
 801efe8:	687a      	ldr	r2, [r7, #4]
 801efea:	9203      	str	r2, [sp, #12]
 801efec:	68ba      	ldr	r2, [r7, #8]
 801efee:	9202      	str	r2, [sp, #8]
 801eff0:	2237      	movs	r2, #55	@ 0x37
 801eff2:	9201      	str	r2, [sp, #4]
 801eff4:	9300      	str	r3, [sp, #0]
 801eff6:	2301      	movs	r3, #1
 801eff8:	2237      	movs	r2, #55	@ 0x37
 801effa:	69b9      	ldr	r1, [r7, #24]
 801effc:	68f8      	ldr	r0, [r7, #12]
 801effe:	f7ff fee7 	bl	801edd0 <Hash_df>
 801f002:	61f8      	str	r0, [r7, #28]
    if (ret == DRBG_SUCCESS) {
 801f004:	69fb      	ldr	r3, [r7, #28]
 801f006:	2b00      	cmp	r3, #0
 801f008:	d11c      	bne.n	801f044 <Hash_DRBG_Reseed+0x94>
        XMEMCPY(drbg->V, newV, sizeof(drbg->V));
 801f00a:	68fb      	ldr	r3, [r7, #12]
 801f00c:	3304      	adds	r3, #4
 801f00e:	2237      	movs	r2, #55	@ 0x37
 801f010:	69b9      	ldr	r1, [r7, #24]
 801f012:	4618      	mov	r0, r3
 801f014:	f009 feb7 	bl	8028d86 <memcpy>
        ForceZero(newV, DRBG_SEED_LEN);
 801f018:	2137      	movs	r1, #55	@ 0x37
 801f01a:	69b8      	ldr	r0, [r7, #24]
 801f01c:	f7ff fe88 	bl	801ed30 <ForceZero>

        ret = Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
 801f020:	68fb      	ldr	r3, [r7, #12]
 801f022:	f103 013b 	add.w	r1, r3, #59	@ 0x3b
 801f026:	68fb      	ldr	r3, [r7, #12]
 801f028:	3304      	adds	r3, #4
 801f02a:	2200      	movs	r2, #0
 801f02c:	9203      	str	r2, [sp, #12]
 801f02e:	2200      	movs	r2, #0
 801f030:	9202      	str	r2, [sp, #8]
 801f032:	2237      	movs	r2, #55	@ 0x37
 801f034:	9201      	str	r2, [sp, #4]
 801f036:	9300      	str	r3, [sp, #0]
 801f038:	2300      	movs	r3, #0
 801f03a:	2237      	movs	r2, #55	@ 0x37
 801f03c:	68f8      	ldr	r0, [r7, #12]
 801f03e:	f7ff fec7 	bl	801edd0 <Hash_df>
 801f042:	61f8      	str	r0, [r7, #28]
                                    sizeof(drbg->V), NULL, 0);
    }
    if (ret == DRBG_SUCCESS) {
 801f044:	69fb      	ldr	r3, [r7, #28]
 801f046:	2b00      	cmp	r3, #0
 801f048:	d102      	bne.n	801f050 <Hash_DRBG_Reseed+0xa0>
        drbg->reseedCtr = 1;
 801f04a:	68fb      	ldr	r3, [r7, #12]
 801f04c:	2201      	movs	r2, #1
 801f04e:	601a      	str	r2, [r3, #0]
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(newV, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801f050:	69bb      	ldr	r3, [r7, #24]
 801f052:	617b      	str	r3, [r7, #20]
 801f054:	697b      	ldr	r3, [r7, #20]
 801f056:	2b00      	cmp	r3, #0
 801f058:	d002      	beq.n	801f060 <Hash_DRBG_Reseed+0xb0>
 801f05a:	6978      	ldr	r0, [r7, #20]
 801f05c:	f7ff fe2a 	bl	801ecb4 <wolfSSL_Free>
#endif
    return ret;
 801f060:	69fb      	ldr	r3, [r7, #28]
}
 801f062:	4618      	mov	r0, r3
 801f064:	3720      	adds	r7, #32
 801f066:	46bd      	mov	sp, r7
 801f068:	bd80      	pop	{r7, pc}

0801f06a <array_add_one>:

    return Hash_DRBG_Reseed((DRBG_internal *)rng->drbg, seed, seedSz);
}

static WC_INLINE void array_add_one(byte* data, word32 dataSz)
{
 801f06a:	b480      	push	{r7}
 801f06c:	b085      	sub	sp, #20
 801f06e:	af00      	add	r7, sp, #0
 801f070:	6078      	str	r0, [r7, #4]
 801f072:	6039      	str	r1, [r7, #0]
    int i;
    for (i = (int)dataSz - 1; i >= 0; i--) {
 801f074:	683b      	ldr	r3, [r7, #0]
 801f076:	3b01      	subs	r3, #1
 801f078:	60fb      	str	r3, [r7, #12]
 801f07a:	e00f      	b.n	801f09c <array_add_one+0x32>
        data[i]++;
 801f07c:	68fb      	ldr	r3, [r7, #12]
 801f07e:	687a      	ldr	r2, [r7, #4]
 801f080:	4413      	add	r3, r2
 801f082:	781a      	ldrb	r2, [r3, #0]
 801f084:	3201      	adds	r2, #1
 801f086:	b2d2      	uxtb	r2, r2
 801f088:	701a      	strb	r2, [r3, #0]
        if (data[i] != 0) break;
 801f08a:	68fb      	ldr	r3, [r7, #12]
 801f08c:	687a      	ldr	r2, [r7, #4]
 801f08e:	4413      	add	r3, r2
 801f090:	781b      	ldrb	r3, [r3, #0]
 801f092:	2b00      	cmp	r3, #0
 801f094:	d106      	bne.n	801f0a4 <array_add_one+0x3a>
    for (i = (int)dataSz - 1; i >= 0; i--) {
 801f096:	68fb      	ldr	r3, [r7, #12]
 801f098:	3b01      	subs	r3, #1
 801f09a:	60fb      	str	r3, [r7, #12]
 801f09c:	68fb      	ldr	r3, [r7, #12]
 801f09e:	2b00      	cmp	r3, #0
 801f0a0:	daec      	bge.n	801f07c <array_add_one+0x12>
    }
}
 801f0a2:	e000      	b.n	801f0a6 <array_add_one+0x3c>
        if (data[i] != 0) break;
 801f0a4:	bf00      	nop
}
 801f0a6:	bf00      	nop
 801f0a8:	3714      	adds	r7, #20
 801f0aa:	46bd      	mov	sp, r7
 801f0ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f0b0:	4770      	bx	lr

0801f0b2 <Hash_gen>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_gen(DRBG_internal* drbg, byte* out, word32 outSz, const byte* V)
{
 801f0b2:	b580      	push	{r7, lr}
 801f0b4:	b0aa      	sub	sp, #168	@ 0xa8
 801f0b6:	af00      	add	r7, sp, #0
 801f0b8:	60f8      	str	r0, [r7, #12]
 801f0ba:	60b9      	str	r1, [r7, #8]
 801f0bc:	607a      	str	r2, [r7, #4]
 801f0be:	603b      	str	r3, [r7, #0]
    int ret = DRBG_FAILURE;
 801f0c0:	2301      	movs	r3, #1
 801f0c2:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    wc_Sha256* sha = &drbg->sha256;
#else
    wc_Sha256 sha[1];
#endif

    if (drbg == NULL) {
 801f0c6:	68fb      	ldr	r3, [r7, #12]
 801f0c8:	2b00      	cmp	r3, #0
 801f0ca:	d101      	bne.n	801f0d0 <Hash_gen+0x1e>
        return DRBG_FAILURE;
 801f0cc:	2301      	movs	r3, #1
 801f0ce:	e0c6      	b.n	801f25e <Hash_gen+0x1ac>
    }

#ifdef WOLFSSL_SMALL_STACK
    data = (byte*)XMALLOC(DRBG_SEED_LEN, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801f0d0:	2037      	movs	r0, #55	@ 0x37
 801f0d2:	f7ff fdd3 	bl	801ec7c <wolfSSL_Malloc>
 801f0d6:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
    digest = (byte*)XMALLOC(WC_SHA256_DIGEST_SIZE, drbg->heap,
 801f0da:	2020      	movs	r0, #32
 801f0dc:	f7ff fdce 	bl	801ec7c <wolfSSL_Malloc>
 801f0e0:	f8c7 0098 	str.w	r0, [r7, #152]	@ 0x98
        DYNAMIC_TYPE_DIGEST);
    if (data == NULL || digest == NULL) {
 801f0e4:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801f0e8:	2b00      	cmp	r3, #0
 801f0ea:	d003      	beq.n	801f0f4 <Hash_gen+0x42>
 801f0ec:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801f0f0:	2b00      	cmp	r3, #0
 801f0f2:	d119      	bne.n	801f128 <Hash_gen+0x76>
        XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801f0f4:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801f0f8:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 801f0fc:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801f100:	2b00      	cmp	r3, #0
 801f102:	d003      	beq.n	801f10c <Hash_gen+0x5a>
 801f104:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801f108:	f7ff fdd4 	bl	801ecb4 <wolfSSL_Free>
        XFREE(data, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801f10c:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801f110:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 801f114:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801f118:	2b00      	cmp	r3, #0
 801f11a:	d003      	beq.n	801f124 <Hash_gen+0x72>
 801f11c:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801f120:	f7ff fdc8 	bl	801ecb4 <wolfSSL_Free>
        return DRBG_FAILURE;
 801f124:	2301      	movs	r3, #1
 801f126:	e09a      	b.n	801f25e <Hash_gen+0x1ac>
#endif

    /* Special case: outSz is 0 and out is NULL. wc_Generate a block to save for
     * the continuous test. */

    if (outSz == 0) {
 801f128:	687b      	ldr	r3, [r7, #4]
 801f12a:	2b00      	cmp	r3, #0
 801f12c:	d101      	bne.n	801f132 <Hash_gen+0x80>
        outSz = 1;
 801f12e:	2301      	movs	r3, #1
 801f130:	607b      	str	r3, [r7, #4]
    }

    len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 801f132:	687b      	ldr	r3, [r7, #4]
 801f134:	095b      	lsrs	r3, r3, #5
 801f136:	687a      	ldr	r2, [r7, #4]
 801f138:	f002 021f 	and.w	r2, r2, #31
 801f13c:	2a00      	cmp	r2, #0
 801f13e:	d001      	beq.n	801f144 <Hash_gen+0x92>
 801f140:	2201      	movs	r2, #1
 801f142:	e000      	b.n	801f146 <Hash_gen+0x94>
 801f144:	2200      	movs	r2, #0
 801f146:	4413      	add	r3, r2
 801f148:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    XMEMCPY(data, V, DRBG_SEED_LEN);
 801f14c:	2237      	movs	r2, #55	@ 0x37
 801f14e:	6839      	ldr	r1, [r7, #0]
 801f150:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801f154:	f009 fe17 	bl	8028d86 <memcpy>
    for (i = 0; i < len; i++) {
 801f158:	2300      	movs	r3, #0
 801f15a:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801f15e:	e052      	b.n	801f206 <Hash_gen+0x154>
#ifndef WOLFSSL_SMALL_STACK_CACHE
    #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    #else
        ret = wc_InitSha256(sha);
 801f160:	f107 0314 	add.w	r3, r7, #20
 801f164:	4618      	mov	r0, r3
 801f166:	f003 f839 	bl	80221dc <wc_InitSha256>
 801f16a:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
    #endif
        if (ret == 0)
 801f16e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801f172:	2b00      	cmp	r3, #0
 801f174:	d109      	bne.n	801f18a <Hash_gen+0xd8>
#endif
            ret = wc_Sha256Update(sha, data, DRBG_SEED_LEN);
 801f176:	f107 0314 	add.w	r3, r7, #20
 801f17a:	2237      	movs	r2, #55	@ 0x37
 801f17c:	f8d7 109c 	ldr.w	r1, [r7, #156]	@ 0x9c
 801f180:	4618      	mov	r0, r3
 801f182:	f002 ff62 	bl	802204a <wc_Sha256Update>
 801f186:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
        if (ret == 0)
 801f18a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801f18e:	2b00      	cmp	r3, #0
 801f190:	d108      	bne.n	801f1a4 <Hash_gen+0xf2>
            ret = wc_Sha256Final(sha, digest);
 801f192:	f107 0314 	add.w	r3, r7, #20
 801f196:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801f19a:	4618      	mov	r0, r3
 801f19c:	f002 fff3 	bl	8022186 <wc_Sha256Final>
 801f1a0:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
#ifndef WOLFSSL_SMALL_STACK_CACHE
        wc_Sha256Free(sha);
 801f1a4:	f107 0314 	add.w	r3, r7, #20
 801f1a8:	4618      	mov	r0, r3
 801f1aa:	f003 f828 	bl	80221fe <wc_Sha256Free>
#endif

        if (ret == 0) {
 801f1ae:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801f1b2:	2b00      	cmp	r3, #0
 801f1b4:	d12e      	bne.n	801f214 <Hash_gen+0x162>
            if (out != NULL && outSz != 0) {
 801f1b6:	68bb      	ldr	r3, [r7, #8]
 801f1b8:	2b00      	cmp	r3, #0
 801f1ba:	d01f      	beq.n	801f1fc <Hash_gen+0x14a>
 801f1bc:	687b      	ldr	r3, [r7, #4]
 801f1be:	2b00      	cmp	r3, #0
 801f1c0:	d01c      	beq.n	801f1fc <Hash_gen+0x14a>
                if (outSz >= OUTPUT_BLOCK_LEN) {
 801f1c2:	687b      	ldr	r3, [r7, #4]
 801f1c4:	2b1f      	cmp	r3, #31
 801f1c6:	d911      	bls.n	801f1ec <Hash_gen+0x13a>
                    XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
 801f1c8:	2220      	movs	r2, #32
 801f1ca:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801f1ce:	68b8      	ldr	r0, [r7, #8]
 801f1d0:	f009 fdd9 	bl	8028d86 <memcpy>
                    outSz -= OUTPUT_BLOCK_LEN;
 801f1d4:	687b      	ldr	r3, [r7, #4]
 801f1d6:	3b20      	subs	r3, #32
 801f1d8:	607b      	str	r3, [r7, #4]
                    out += OUTPUT_BLOCK_LEN;
 801f1da:	68bb      	ldr	r3, [r7, #8]
 801f1dc:	3320      	adds	r3, #32
 801f1de:	60bb      	str	r3, [r7, #8]
                    array_add_one(data, DRBG_SEED_LEN);
 801f1e0:	2137      	movs	r1, #55	@ 0x37
 801f1e2:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801f1e6:	f7ff ff40 	bl	801f06a <array_add_one>
 801f1ea:	e007      	b.n	801f1fc <Hash_gen+0x14a>
                }
                else {
                    XMEMCPY(out, digest, outSz);
 801f1ec:	687a      	ldr	r2, [r7, #4]
 801f1ee:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801f1f2:	68b8      	ldr	r0, [r7, #8]
 801f1f4:	f009 fdc7 	bl	8028d86 <memcpy>
                    outSz = 0;
 801f1f8:	2300      	movs	r3, #0
 801f1fa:	607b      	str	r3, [r7, #4]
    for (i = 0; i < len; i++) {
 801f1fc:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801f200:	3301      	adds	r3, #1
 801f202:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801f206:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 801f20a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f20e:	429a      	cmp	r2, r3
 801f210:	d3a6      	bcc.n	801f160 <Hash_gen+0xae>
 801f212:	e000      	b.n	801f216 <Hash_gen+0x164>
                }
            }
        }
        else {
            /* wc_Sha256Update or wc_Sha256Final returned error */
            break;
 801f214:	bf00      	nop
        }
    }
    ForceZero(data, DRBG_SEED_LEN);
 801f216:	2137      	movs	r1, #55	@ 0x37
 801f218:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801f21c:	f7ff fd88 	bl	801ed30 <ForceZero>

#ifdef WOLFSSL_SMALL_STACK
    XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801f220:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801f224:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 801f228:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801f22c:	2b00      	cmp	r3, #0
 801f22e:	d003      	beq.n	801f238 <Hash_gen+0x186>
 801f230:	f8d7 0090 	ldr.w	r0, [r7, #144]	@ 0x90
 801f234:	f7ff fd3e 	bl	801ecb4 <wolfSSL_Free>
    XFREE(data, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801f238:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801f23c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801f240:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801f244:	2b00      	cmp	r3, #0
 801f246:	d003      	beq.n	801f250 <Hash_gen+0x19e>
 801f248:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801f24c:	f7ff fd32 	bl	801ecb4 <wolfSSL_Free>
#endif

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801f250:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801f254:	2b00      	cmp	r3, #0
 801f256:	bf14      	ite	ne
 801f258:	2301      	movne	r3, #1
 801f25a:	2300      	moveq	r3, #0
 801f25c:	b2db      	uxtb	r3, r3
}
 801f25e:	4618      	mov	r0, r3
 801f260:	37a8      	adds	r7, #168	@ 0xa8
 801f262:	46bd      	mov	sp, r7
 801f264:	bd80      	pop	{r7, pc}

0801f266 <array_add>:

static WC_INLINE void array_add(byte* d, word32 dLen, const byte* s, word32 sLen)
{
 801f266:	b480      	push	{r7}
 801f268:	b089      	sub	sp, #36	@ 0x24
 801f26a:	af00      	add	r7, sp, #0
 801f26c:	60f8      	str	r0, [r7, #12]
 801f26e:	60b9      	str	r1, [r7, #8]
 801f270:	607a      	str	r2, [r7, #4]
 801f272:	603b      	str	r3, [r7, #0]
    if (dLen > 0 && sLen > 0 && dLen >= sLen) {
 801f274:	68bb      	ldr	r3, [r7, #8]
 801f276:	2b00      	cmp	r3, #0
 801f278:	d047      	beq.n	801f30a <array_add+0xa4>
 801f27a:	683b      	ldr	r3, [r7, #0]
 801f27c:	2b00      	cmp	r3, #0
 801f27e:	d044      	beq.n	801f30a <array_add+0xa4>
 801f280:	68ba      	ldr	r2, [r7, #8]
 801f282:	683b      	ldr	r3, [r7, #0]
 801f284:	429a      	cmp	r2, r3
 801f286:	d340      	bcc.n	801f30a <array_add+0xa4>
        int sIdx, dIdx;
        word16 carry = 0;
 801f288:	2300      	movs	r3, #0
 801f28a:	82fb      	strh	r3, [r7, #22]

        dIdx = (int)dLen - 1;
 801f28c:	68bb      	ldr	r3, [r7, #8]
 801f28e:	3b01      	subs	r3, #1
 801f290:	61bb      	str	r3, [r7, #24]
        for (sIdx = (int)sLen - 1; sIdx >= 0; sIdx--) {
 801f292:	683b      	ldr	r3, [r7, #0]
 801f294:	3b01      	subs	r3, #1
 801f296:	61fb      	str	r3, [r7, #28]
 801f298:	e01c      	b.n	801f2d4 <array_add+0x6e>
            carry = (word16)(carry + d[dIdx] + s[sIdx]);
 801f29a:	69bb      	ldr	r3, [r7, #24]
 801f29c:	68fa      	ldr	r2, [r7, #12]
 801f29e:	4413      	add	r3, r2
 801f2a0:	781b      	ldrb	r3, [r3, #0]
 801f2a2:	461a      	mov	r2, r3
 801f2a4:	8afb      	ldrh	r3, [r7, #22]
 801f2a6:	4413      	add	r3, r2
 801f2a8:	b29b      	uxth	r3, r3
 801f2aa:	69fa      	ldr	r2, [r7, #28]
 801f2ac:	6879      	ldr	r1, [r7, #4]
 801f2ae:	440a      	add	r2, r1
 801f2b0:	7812      	ldrb	r2, [r2, #0]
 801f2b2:	4413      	add	r3, r2
 801f2b4:	82fb      	strh	r3, [r7, #22]
            d[dIdx] = (byte)carry;
 801f2b6:	69bb      	ldr	r3, [r7, #24]
 801f2b8:	68fa      	ldr	r2, [r7, #12]
 801f2ba:	4413      	add	r3, r2
 801f2bc:	8afa      	ldrh	r2, [r7, #22]
 801f2be:	b2d2      	uxtb	r2, r2
 801f2c0:	701a      	strb	r2, [r3, #0]
            carry >>= 8;
 801f2c2:	8afb      	ldrh	r3, [r7, #22]
 801f2c4:	0a1b      	lsrs	r3, r3, #8
 801f2c6:	82fb      	strh	r3, [r7, #22]
            dIdx--;
 801f2c8:	69bb      	ldr	r3, [r7, #24]
 801f2ca:	3b01      	subs	r3, #1
 801f2cc:	61bb      	str	r3, [r7, #24]
        for (sIdx = (int)sLen - 1; sIdx >= 0; sIdx--) {
 801f2ce:	69fb      	ldr	r3, [r7, #28]
 801f2d0:	3b01      	subs	r3, #1
 801f2d2:	61fb      	str	r3, [r7, #28]
 801f2d4:	69fb      	ldr	r3, [r7, #28]
 801f2d6:	2b00      	cmp	r3, #0
 801f2d8:	dadf      	bge.n	801f29a <array_add+0x34>
        }

        for (; dIdx >= 0; dIdx--) {
 801f2da:	e013      	b.n	801f304 <array_add+0x9e>
            carry = (word16)(carry + d[dIdx]);
 801f2dc:	69bb      	ldr	r3, [r7, #24]
 801f2de:	68fa      	ldr	r2, [r7, #12]
 801f2e0:	4413      	add	r3, r2
 801f2e2:	781b      	ldrb	r3, [r3, #0]
 801f2e4:	461a      	mov	r2, r3
 801f2e6:	8afb      	ldrh	r3, [r7, #22]
 801f2e8:	4413      	add	r3, r2
 801f2ea:	82fb      	strh	r3, [r7, #22]
            d[dIdx] = (byte)carry;
 801f2ec:	69bb      	ldr	r3, [r7, #24]
 801f2ee:	68fa      	ldr	r2, [r7, #12]
 801f2f0:	4413      	add	r3, r2
 801f2f2:	8afa      	ldrh	r2, [r7, #22]
 801f2f4:	b2d2      	uxtb	r2, r2
 801f2f6:	701a      	strb	r2, [r3, #0]
            carry >>= 8;
 801f2f8:	8afb      	ldrh	r3, [r7, #22]
 801f2fa:	0a1b      	lsrs	r3, r3, #8
 801f2fc:	82fb      	strh	r3, [r7, #22]
        for (; dIdx >= 0; dIdx--) {
 801f2fe:	69bb      	ldr	r3, [r7, #24]
 801f300:	3b01      	subs	r3, #1
 801f302:	61bb      	str	r3, [r7, #24]
 801f304:	69bb      	ldr	r3, [r7, #24]
 801f306:	2b00      	cmp	r3, #0
 801f308:	dae8      	bge.n	801f2dc <array_add+0x76>
        }
    }
}
 801f30a:	bf00      	nop
 801f30c:	3724      	adds	r7, #36	@ 0x24
 801f30e:	46bd      	mov	sp, r7
 801f310:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f314:	4770      	bx	lr
	...

0801f318 <Hash_DRBG_Generate>:

/* Returns: DRBG_SUCCESS, DRBG_NEED_RESEED, or DRBG_FAILURE */
static int Hash_DRBG_Generate(DRBG_internal* drbg, byte* out, word32 outSz)
{
 801f318:	b580      	push	{r7, lr}
 801f31a:	b0a6      	sub	sp, #152	@ 0x98
 801f31c:	af00      	add	r7, sp, #0
 801f31e:	60f8      	str	r0, [r7, #12]
 801f320:	60b9      	str	r1, [r7, #8]
 801f322:	607a      	str	r2, [r7, #4]
    wc_Sha256 sha[1];
#endif
    byte type;
    word32 reseedCtr;

    if (drbg == NULL) {
 801f324:	68fb      	ldr	r3, [r7, #12]
 801f326:	2b00      	cmp	r3, #0
 801f328:	d101      	bne.n	801f32e <Hash_DRBG_Generate+0x16>
        return DRBG_FAILURE;
 801f32a:	2301      	movs	r3, #1
 801f32c:	e09b      	b.n	801f466 <Hash_DRBG_Generate+0x14e>
    }

    if (drbg->reseedCtr == RESEED_INTERVAL) {
 801f32e:	68fb      	ldr	r3, [r7, #12]
 801f330:	681b      	ldr	r3, [r3, #0]
 801f332:	4a4f      	ldr	r2, [pc, #316]	@ (801f470 <Hash_DRBG_Generate+0x158>)
 801f334:	4293      	cmp	r3, r2
 801f336:	d101      	bne.n	801f33c <Hash_DRBG_Generate+0x24>
#if FIPS_VERSION3_GE(6,0,0)
        printf("Reseed triggered\n");
#endif
        return DRBG_NEED_RESEED;
 801f338:	2302      	movs	r3, #2
 801f33a:	e094      	b.n	801f466 <Hash_DRBG_Generate+0x14e>
    }
    else {
    #ifndef WOLFSSL_SMALL_STACK
        byte digest[WC_SHA256_DIGEST_SIZE];
    #else
        byte* digest = (byte*)XMALLOC(WC_SHA256_DIGEST_SIZE, drbg->heap,
 801f33c:	2020      	movs	r0, #32
 801f33e:	f7ff fc9d 	bl	801ec7c <wolfSSL_Malloc>
 801f342:	f8c7 0090 	str.w	r0, [r7, #144]	@ 0x90
            DYNAMIC_TYPE_DIGEST);
        if (digest == NULL)
 801f346:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801f34a:	2b00      	cmp	r3, #0
 801f34c:	d101      	bne.n	801f352 <Hash_DRBG_Generate+0x3a>
            return DRBG_FAILURE;
 801f34e:	2301      	movs	r3, #1
 801f350:	e089      	b.n	801f466 <Hash_DRBG_Generate+0x14e>
    #endif

        type = drbgGenerateH;
 801f352:	2303      	movs	r3, #3
 801f354:	76fb      	strb	r3, [r7, #27]
        reseedCtr = drbg->reseedCtr;
 801f356:	68fb      	ldr	r3, [r7, #12]
 801f358:	681b      	ldr	r3, [r3, #0]
 801f35a:	617b      	str	r3, [r7, #20]

        ret = Hash_gen(drbg, out, outSz, drbg->V);
 801f35c:	68fb      	ldr	r3, [r7, #12]
 801f35e:	3304      	adds	r3, #4
 801f360:	687a      	ldr	r2, [r7, #4]
 801f362:	68b9      	ldr	r1, [r7, #8]
 801f364:	68f8      	ldr	r0, [r7, #12]
 801f366:	f7ff fea4 	bl	801f0b2 <Hash_gen>
 801f36a:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
        if (ret == DRBG_SUCCESS) {
 801f36e:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f372:	2b00      	cmp	r3, #0
 801f374:	d15f      	bne.n	801f436 <Hash_DRBG_Generate+0x11e>
#ifndef WOLFSSL_SMALL_STACK_CACHE
        #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
            ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
        #else
            ret = wc_InitSha256(sha);
 801f376:	f107 031c 	add.w	r3, r7, #28
 801f37a:	4618      	mov	r0, r3
 801f37c:	f002 ff2e 	bl	80221dc <wc_InitSha256>
 801f380:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
        #endif
            if (ret == 0)
 801f384:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f388:	2b00      	cmp	r3, #0
 801f38a:	d109      	bne.n	801f3a0 <Hash_DRBG_Generate+0x88>
#endif
                ret = wc_Sha256Update(sha, &type, sizeof(type));
 801f38c:	f107 011b 	add.w	r1, r7, #27
 801f390:	f107 031c 	add.w	r3, r7, #28
 801f394:	2201      	movs	r2, #1
 801f396:	4618      	mov	r0, r3
 801f398:	f002 fe57 	bl	802204a <wc_Sha256Update>
 801f39c:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
            if (ret == 0)
 801f3a0:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f3a4:	2b00      	cmp	r3, #0
 801f3a6:	d109      	bne.n	801f3bc <Hash_DRBG_Generate+0xa4>
                ret = wc_Sha256Update(sha, drbg->V, sizeof(drbg->V));
 801f3a8:	68fb      	ldr	r3, [r7, #12]
 801f3aa:	1d19      	adds	r1, r3, #4
 801f3ac:	f107 031c 	add.w	r3, r7, #28
 801f3b0:	2237      	movs	r2, #55	@ 0x37
 801f3b2:	4618      	mov	r0, r3
 801f3b4:	f002 fe49 	bl	802204a <wc_Sha256Update>
 801f3b8:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
            if (ret == 0)
 801f3bc:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f3c0:	2b00      	cmp	r3, #0
 801f3c2:	d108      	bne.n	801f3d6 <Hash_DRBG_Generate+0xbe>
                ret = wc_Sha256Final(sha, digest);
 801f3c4:	f107 031c 	add.w	r3, r7, #28
 801f3c8:	f8d7 1090 	ldr.w	r1, [r7, #144]	@ 0x90
 801f3cc:	4618      	mov	r0, r3
 801f3ce:	f002 feda 	bl	8022186 <wc_Sha256Final>
 801f3d2:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94

#ifndef WOLFSSL_SMALL_STACK_CACHE
            wc_Sha256Free(sha);
 801f3d6:	f107 031c 	add.w	r3, r7, #28
 801f3da:	4618      	mov	r0, r3
 801f3dc:	f002 ff0f 	bl	80221fe <wc_Sha256Free>
#endif

            if (ret == 0) {
 801f3e0:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f3e4:	2b00      	cmp	r3, #0
 801f3e6:	d121      	bne.n	801f42c <Hash_DRBG_Generate+0x114>
                array_add(drbg->V, sizeof(drbg->V), digest, WC_SHA256_DIGEST_SIZE);
 801f3e8:	68fb      	ldr	r3, [r7, #12]
 801f3ea:	1d18      	adds	r0, r3, #4
 801f3ec:	2320      	movs	r3, #32
 801f3ee:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 801f3f2:	2137      	movs	r1, #55	@ 0x37
 801f3f4:	f7ff ff37 	bl	801f266 <array_add>
                array_add(drbg->V, sizeof(drbg->V), drbg->C, sizeof(drbg->C));
 801f3f8:	68fb      	ldr	r3, [r7, #12]
 801f3fa:	1d18      	adds	r0, r3, #4
 801f3fc:	68fb      	ldr	r3, [r7, #12]
 801f3fe:	f103 023b 	add.w	r2, r3, #59	@ 0x3b
 801f402:	2337      	movs	r3, #55	@ 0x37
 801f404:	2137      	movs	r1, #55	@ 0x37
 801f406:	f7ff ff2e 	bl	801f266 <array_add>
            #ifdef LITTLE_ENDIAN_ORDER
                reseedCtr = ByteReverseWord32(reseedCtr);
 801f40a:	697b      	ldr	r3, [r7, #20]
 801f40c:	4618      	mov	r0, r3
 801f40e:	f7ff fc78 	bl	801ed02 <ByteReverseWord32>
 801f412:	4603      	mov	r3, r0
 801f414:	617b      	str	r3, [r7, #20]
            #endif
                array_add(drbg->V, sizeof(drbg->V),
 801f416:	68fb      	ldr	r3, [r7, #12]
 801f418:	1d18      	adds	r0, r3, #4
 801f41a:	f107 0214 	add.w	r2, r7, #20
 801f41e:	2304      	movs	r3, #4
 801f420:	2137      	movs	r1, #55	@ 0x37
 801f422:	f7ff ff20 	bl	801f266 <array_add>
                                          (byte*)&reseedCtr, sizeof(reseedCtr));
                ret = DRBG_SUCCESS;
 801f426:	2300      	movs	r3, #0
 801f428:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
            }
            drbg->reseedCtr++;
 801f42c:	68fb      	ldr	r3, [r7, #12]
 801f42e:	681b      	ldr	r3, [r3, #0]
 801f430:	1c5a      	adds	r2, r3, #1
 801f432:	68fb      	ldr	r3, [r7, #12]
 801f434:	601a      	str	r2, [r3, #0]
        }
        ForceZero(digest, WC_SHA256_DIGEST_SIZE);
 801f436:	2120      	movs	r1, #32
 801f438:	f8d7 0090 	ldr.w	r0, [r7, #144]	@ 0x90
 801f43c:	f7ff fc78 	bl	801ed30 <ForceZero>
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801f440:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801f444:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801f448:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801f44c:	2b00      	cmp	r3, #0
 801f44e:	d003      	beq.n	801f458 <Hash_DRBG_Generate+0x140>
 801f450:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801f454:	f7ff fc2e 	bl	801ecb4 <wolfSSL_Free>
    #endif
    }

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801f458:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f45c:	2b00      	cmp	r3, #0
 801f45e:	bf14      	ite	ne
 801f460:	2301      	movne	r3, #1
 801f462:	2300      	moveq	r3, #0
 801f464:	b2db      	uxtb	r3, r3
}
 801f466:	4618      	mov	r0, r3
 801f468:	3798      	adds	r7, #152	@ 0x98
 801f46a:	46bd      	mov	sp, r7
 801f46c:	bd80      	pop	{r7, pc}
 801f46e:	bf00      	nop
 801f470:	000f4240 	.word	0x000f4240

0801f474 <Hash_DRBG_Instantiate>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Instantiate(DRBG_internal* drbg, const byte* seed, word32 seedSz,
                                             const byte* nonce, word32 nonceSz,
                                             void* heap, int devId)
{
 801f474:	b580      	push	{r7, lr}
 801f476:	b08a      	sub	sp, #40	@ 0x28
 801f478:	af04      	add	r7, sp, #16
 801f47a:	60f8      	str	r0, [r7, #12]
 801f47c:	60b9      	str	r1, [r7, #8]
 801f47e:	607a      	str	r2, [r7, #4]
 801f480:	603b      	str	r3, [r7, #0]
    int ret = DRBG_FAILURE;
 801f482:	2301      	movs	r3, #1
 801f484:	617b      	str	r3, [r7, #20]

    XMEMSET(drbg, 0, sizeof(DRBG_internal));
 801f486:	2278      	movs	r2, #120	@ 0x78
 801f488:	2100      	movs	r1, #0
 801f48a:	68f8      	ldr	r0, [r7, #12]
 801f48c:	f009 fbca 	bl	8028c24 <memset>
    drbg->heap = heap;
 801f490:	68fb      	ldr	r3, [r7, #12]
 801f492:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801f494:	675a      	str	r2, [r3, #116]	@ 0x74
    #endif
    if (ret != 0)
        return ret;
#endif

    if (Hash_df(drbg, drbg->V, sizeof(drbg->V), drbgInitV, seed, seedSz,
 801f496:	68fb      	ldr	r3, [r7, #12]
 801f498:	1d19      	adds	r1, r3, #4
 801f49a:	6a3b      	ldr	r3, [r7, #32]
 801f49c:	9303      	str	r3, [sp, #12]
 801f49e:	683b      	ldr	r3, [r7, #0]
 801f4a0:	9302      	str	r3, [sp, #8]
 801f4a2:	687b      	ldr	r3, [r7, #4]
 801f4a4:	9301      	str	r3, [sp, #4]
 801f4a6:	68bb      	ldr	r3, [r7, #8]
 801f4a8:	9300      	str	r3, [sp, #0]
 801f4aa:	2304      	movs	r3, #4
 801f4ac:	2237      	movs	r2, #55	@ 0x37
 801f4ae:	68f8      	ldr	r0, [r7, #12]
 801f4b0:	f7ff fc8e 	bl	801edd0 <Hash_df>
 801f4b4:	4603      	mov	r3, r0
 801f4b6:	2b00      	cmp	r3, #0
 801f4b8:	d118      	bne.n	801f4ec <Hash_DRBG_Instantiate+0x78>
                                              nonce, nonceSz) == DRBG_SUCCESS &&
        Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
 801f4ba:	68fb      	ldr	r3, [r7, #12]
 801f4bc:	f103 013b 	add.w	r1, r3, #59	@ 0x3b
 801f4c0:	68fb      	ldr	r3, [r7, #12]
 801f4c2:	3304      	adds	r3, #4
 801f4c4:	2200      	movs	r2, #0
 801f4c6:	9203      	str	r2, [sp, #12]
 801f4c8:	2200      	movs	r2, #0
 801f4ca:	9202      	str	r2, [sp, #8]
 801f4cc:	2237      	movs	r2, #55	@ 0x37
 801f4ce:	9201      	str	r2, [sp, #4]
 801f4d0:	9300      	str	r3, [sp, #0]
 801f4d2:	2300      	movs	r3, #0
 801f4d4:	2237      	movs	r2, #55	@ 0x37
 801f4d6:	68f8      	ldr	r0, [r7, #12]
 801f4d8:	f7ff fc7a 	bl	801edd0 <Hash_df>
 801f4dc:	4603      	mov	r3, r0
                                              nonce, nonceSz) == DRBG_SUCCESS &&
 801f4de:	2b00      	cmp	r3, #0
 801f4e0:	d104      	bne.n	801f4ec <Hash_DRBG_Instantiate+0x78>
                                    sizeof(drbg->V), NULL, 0) == DRBG_SUCCESS) {

        drbg->reseedCtr = 1;
 801f4e2:	68fb      	ldr	r3, [r7, #12]
 801f4e4:	2201      	movs	r2, #1
 801f4e6:	601a      	str	r2, [r3, #0]
        ret = DRBG_SUCCESS;
 801f4e8:	2300      	movs	r3, #0
 801f4ea:	617b      	str	r3, [r7, #20]
    }

    return ret;
 801f4ec:	697b      	ldr	r3, [r7, #20]
}
 801f4ee:	4618      	mov	r0, r3
 801f4f0:	3718      	adds	r7, #24
 801f4f2:	46bd      	mov	sp, r7
 801f4f4:	bd80      	pop	{r7, pc}

0801f4f6 <Hash_DRBG_Uninstantiate>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Uninstantiate(DRBG_internal* drbg)
{
 801f4f6:	b580      	push	{r7, lr}
 801f4f8:	b086      	sub	sp, #24
 801f4fa:	af00      	add	r7, sp, #0
 801f4fc:	6078      	str	r0, [r7, #4]
    word32 i;
    int    compareSum = 0;
 801f4fe:	2300      	movs	r3, #0
 801f500:	613b      	str	r3, [r7, #16]
    byte*  compareDrbg = (byte*)drbg;
 801f502:	687b      	ldr	r3, [r7, #4]
 801f504:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_SMALL_STACK_CACHE
    wc_Sha256Free(&drbg->sha256);
#endif

    ForceZero(drbg, sizeof(DRBG_internal));
 801f506:	2178      	movs	r1, #120	@ 0x78
 801f508:	6878      	ldr	r0, [r7, #4]
 801f50a:	f7ff fc11 	bl	801ed30 <ForceZero>

    for (i = 0; i < sizeof(DRBG_internal); i++) {
 801f50e:	2300      	movs	r3, #0
 801f510:	617b      	str	r3, [r7, #20]
 801f512:	e00a      	b.n	801f52a <Hash_DRBG_Uninstantiate+0x34>
        compareSum |= compareDrbg[i] ^ 0;
 801f514:	68fa      	ldr	r2, [r7, #12]
 801f516:	697b      	ldr	r3, [r7, #20]
 801f518:	4413      	add	r3, r2
 801f51a:	781b      	ldrb	r3, [r3, #0]
 801f51c:	461a      	mov	r2, r3
 801f51e:	693b      	ldr	r3, [r7, #16]
 801f520:	4313      	orrs	r3, r2
 801f522:	613b      	str	r3, [r7, #16]
    for (i = 0; i < sizeof(DRBG_internal); i++) {
 801f524:	697b      	ldr	r3, [r7, #20]
 801f526:	3301      	adds	r3, #1
 801f528:	617b      	str	r3, [r7, #20]
 801f52a:	697b      	ldr	r3, [r7, #20]
 801f52c:	2b77      	cmp	r3, #119	@ 0x77
 801f52e:	d9f1      	bls.n	801f514 <Hash_DRBG_Uninstantiate+0x1e>
    }

    return (compareSum == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801f530:	693b      	ldr	r3, [r7, #16]
 801f532:	2b00      	cmp	r3, #0
 801f534:	bf14      	ite	ne
 801f536:	2301      	movne	r3, #1
 801f538:	2300      	moveq	r3, #0
 801f53a:	b2db      	uxtb	r3, r3
}
 801f53c:	4618      	mov	r0, r3
 801f53e:	3718      	adds	r7, #24
 801f540:	46bd      	mov	sp, r7
 801f542:	bd80      	pop	{r7, pc}

0801f544 <wc_RNG_TestSeed>:


int wc_RNG_TestSeed(const byte* seed, word32 seedSz)
{
 801f544:	b580      	push	{r7, lr}
 801f546:	b086      	sub	sp, #24
 801f548:	af00      	add	r7, sp, #0
 801f54a:	6078      	str	r0, [r7, #4]
 801f54c:	6039      	str	r1, [r7, #0]
    int ret = 0;
 801f54e:	2300      	movs	r3, #0
 801f550:	617b      	str	r3, [r7, #20]

    /* Check the seed for duplicate words. */
    word32 seedIdx = 0;
 801f552:	2300      	movs	r3, #0
 801f554:	613b      	str	r3, [r7, #16]
    word32 scratchSz = min(SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ);
 801f556:	683b      	ldr	r3, [r7, #0]
 801f558:	3b04      	subs	r3, #4
 801f55a:	4619      	mov	r1, r3
 801f55c:	2004      	movs	r0, #4
 801f55e:	f7ff fc27 	bl	801edb0 <min>
 801f562:	60f8      	str	r0, [r7, #12]

    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
 801f564:	e01b      	b.n	801f59e <wc_RNG_TestSeed+0x5a>
        if (ConstantCompare(seed + seedIdx,
 801f566:	687a      	ldr	r2, [r7, #4]
 801f568:	693b      	ldr	r3, [r7, #16]
 801f56a:	18d0      	adds	r0, r2, r3
                            seed + seedIdx + scratchSz,
 801f56c:	693a      	ldr	r2, [r7, #16]
 801f56e:	68fb      	ldr	r3, [r7, #12]
 801f570:	4413      	add	r3, r2
        if (ConstantCompare(seed + seedIdx,
 801f572:	687a      	ldr	r2, [r7, #4]
 801f574:	4413      	add	r3, r2
 801f576:	68fa      	ldr	r2, [r7, #12]
 801f578:	4619      	mov	r1, r3
 801f57a:	f7ff fbf2 	bl	801ed62 <ConstantCompare>
 801f57e:	4603      	mov	r3, r0
 801f580:	2b00      	cmp	r3, #0
 801f582:	d101      	bne.n	801f588 <wc_RNG_TestSeed+0x44>
                            (int)scratchSz) == 0) {

            ret = DRBG_CONT_FAILURE;
 801f584:	2303      	movs	r3, #3
 801f586:	617b      	str	r3, [r7, #20]
        }
        seedIdx += SEED_BLOCK_SZ;
 801f588:	693b      	ldr	r3, [r7, #16]
 801f58a:	3304      	adds	r3, #4
 801f58c:	613b      	str	r3, [r7, #16]
        scratchSz = min(SEED_BLOCK_SZ, (seedSz - seedIdx));
 801f58e:	683a      	ldr	r2, [r7, #0]
 801f590:	693b      	ldr	r3, [r7, #16]
 801f592:	1ad3      	subs	r3, r2, r3
 801f594:	4619      	mov	r1, r3
 801f596:	2004      	movs	r0, #4
 801f598:	f7ff fc0a 	bl	801edb0 <min>
 801f59c:	60f8      	str	r0, [r7, #12]
    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
 801f59e:	683b      	ldr	r3, [r7, #0]
 801f5a0:	3b04      	subs	r3, #4
 801f5a2:	693a      	ldr	r2, [r7, #16]
 801f5a4:	429a      	cmp	r2, r3
 801f5a6:	d3de      	bcc.n	801f566 <wc_RNG_TestSeed+0x22>
    }

    return ret;
 801f5a8:	697b      	ldr	r3, [r7, #20]
}
 801f5aa:	4618      	mov	r0, r3
 801f5ac:	3718      	adds	r7, #24
 801f5ae:	46bd      	mov	sp, r7
 801f5b0:	bd80      	pop	{r7, pc}

0801f5b2 <_InitRng>:

#endif /* HAVE_ENTROPY_MEMUSE */

static int _InitRng(WC_RNG* rng, byte* nonce, word32 nonceSz,
                    void* heap, int devId)
{
 801f5b2:	b590      	push	{r4, r7, lr}
 801f5b4:	b08f      	sub	sp, #60	@ 0x3c
 801f5b6:	af04      	add	r7, sp, #16
 801f5b8:	60f8      	str	r0, [r7, #12]
 801f5ba:	60b9      	str	r1, [r7, #8]
 801f5bc:	607a      	str	r2, [r7, #4]
 801f5be:	603b      	str	r3, [r7, #0]
    int ret = 0;
 801f5c0:	2300      	movs	r3, #0
 801f5c2:	627b      	str	r3, [r7, #36]	@ 0x24
#ifdef HAVE_HASHDRBG
    word32 seedSz = SEED_SZ + SEED_BLOCK_SZ;
 801f5c4:	2324      	movs	r3, #36	@ 0x24
 801f5c6:	623b      	str	r3, [r7, #32]
#endif

    (void)nonce;
    (void)nonceSz;

    if (rng == NULL)
 801f5c8:	68fb      	ldr	r3, [r7, #12]
 801f5ca:	2b00      	cmp	r3, #0
 801f5cc:	d102      	bne.n	801f5d4 <_InitRng+0x22>
        return BAD_FUNC_ARG;
 801f5ce:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f5d2:	e0a7      	b.n	801f724 <_InitRng+0x172>
    if (nonce == NULL && nonceSz != 0)
 801f5d4:	68bb      	ldr	r3, [r7, #8]
 801f5d6:	2b00      	cmp	r3, #0
 801f5d8:	d105      	bne.n	801f5e6 <_InitRng+0x34>
 801f5da:	687b      	ldr	r3, [r7, #4]
 801f5dc:	2b00      	cmp	r3, #0
 801f5de:	d002      	beq.n	801f5e6 <_InitRng+0x34>
        return BAD_FUNC_ARG;
 801f5e0:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f5e4:	e09e      	b.n	801f724 <_InitRng+0x172>

#ifdef WOLFSSL_HEAP_TEST
    rng->heap = (void*)WOLFSSL_HEAP_TEST;
    (void)heap;
#else
    rng->heap = heap;
 801f5e6:	68fb      	ldr	r3, [r7, #12]
 801f5e8:	683a      	ldr	r2, [r7, #0]
 801f5ea:	605a      	str	r2, [r3, #4]
    (void)devId;
#endif

#ifdef HAVE_HASHDRBG
    /* init the DBRG to known values */
    rng->drbg = NULL;
 801f5ec:	68fb      	ldr	r3, [r7, #12]
 801f5ee:	2200      	movs	r2, #0
 801f5f0:	609a      	str	r2, [r3, #8]
    rng->status = DRBG_NOT_INIT;
 801f5f2:	68fb      	ldr	r3, [r7, #12]
 801f5f4:	2200      	movs	r2, #0
 801f5f6:	731a      	strb	r2, [r3, #12]
    ret = 0; /* success */
#else

 /* not CUSTOM_RAND_GENERATE_BLOCK follows */
#ifdef HAVE_HASHDRBG
    if (nonceSz == 0) {
 801f5f8:	687b      	ldr	r3, [r7, #4]
 801f5fa:	2b00      	cmp	r3, #0
 801f5fc:	d101      	bne.n	801f602 <_InitRng+0x50>
        seedSz = MAX_SEED_SZ;
 801f5fe:	2334      	movs	r3, #52	@ 0x34
 801f600:	623b      	str	r3, [r7, #32]
    }

    ret = wc_RNG_HealthTestLocal(0, rng->heap, devId);
 801f602:	68fb      	ldr	r3, [r7, #12]
 801f604:	685b      	ldr	r3, [r3, #4]
 801f606:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f608:	4619      	mov	r1, r3
 801f60a:	2000      	movs	r0, #0
 801f60c:	f000 fa02 	bl	801fa14 <wc_RNG_HealthTestLocal>
 801f610:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret != 0) {
 801f612:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f614:	2b00      	cmp	r3, #0
 801f616:	d002      	beq.n	801f61e <_InitRng+0x6c>
        #if defined(DEBUG_WOLFSSL)
        WOLFSSL_MSG_EX("wc_RNG_HealthTestLocal failed err = %d", ret);
        #endif
        ret = DRBG_CONT_FAILURE;
 801f618:	2303      	movs	r3, #3
 801f61a:	627b      	str	r3, [r7, #36]	@ 0x24
 801f61c:	e061      	b.n	801f6e2 <_InitRng+0x130>
    }
    else {
    #ifndef WOLFSSL_SMALL_STACK
        byte seed[MAX_SEED_SZ];
    #else
        byte* seed = (byte*)XMALLOC(MAX_SEED_SZ, rng->heap,
 801f61e:	2034      	movs	r0, #52	@ 0x34
 801f620:	f7ff fb2c 	bl	801ec7c <wolfSSL_Malloc>
 801f624:	61f8      	str	r0, [r7, #28]
            DYNAMIC_TYPE_SEED);
        if (seed == NULL)
 801f626:	69fb      	ldr	r3, [r7, #28]
 801f628:	2b00      	cmp	r3, #0
 801f62a:	d102      	bne.n	801f632 <_InitRng+0x80>
            return MEMORY_E;
 801f62c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f630:	e078      	b.n	801f724 <_InitRng+0x172>
    #endif

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
        rng->drbg =
                (struct DRBG*)XMALLOC(sizeof(DRBG_internal), rng->heap,
 801f632:	2078      	movs	r0, #120	@ 0x78
 801f634:	f7ff fb22 	bl	801ec7c <wolfSSL_Malloc>
 801f638:	4602      	mov	r2, r0
        rng->drbg =
 801f63a:	68fb      	ldr	r3, [r7, #12]
 801f63c:	609a      	str	r2, [r3, #8]
                                                          DYNAMIC_TYPE_RNG);
        if (rng->drbg == NULL) {
 801f63e:	68fb      	ldr	r3, [r7, #12]
 801f640:	689b      	ldr	r3, [r3, #8]
 801f642:	2b00      	cmp	r3, #0
 801f644:	d105      	bne.n	801f652 <_InitRng+0xa0>
    #if defined(DEBUG_WOLFSSL)
            WOLFSSL_MSG_EX("_InitRng XMALLOC failed to allocate %d bytes",
                           sizeof(DRBG_internal));
    #endif
            ret = MEMORY_E;
 801f646:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f64a:	627b      	str	r3, [r7, #36]	@ 0x24
            rng->status = DRBG_FAILED;
 801f64c:	68fb      	ldr	r3, [r7, #12]
 801f64e:	2202      	movs	r2, #2
 801f650:	731a      	strb	r2, [r3, #12]
        }
#else
        rng->drbg = (struct DRBG*)&rng->drbg_data;
#endif /* WOLFSSL_NO_MALLOC or WOLFSSL_STATIC_MEMORY */

        if (ret != 0) {
 801f652:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f654:	2b00      	cmp	r3, #0
 801f656:	d138      	bne.n	801f6ca <_InitRng+0x118>
                if (ret != 0) {
                    ret = DRBG_FAILURE;
                }
            }
#else
            ret = wc_GenerateSeed(&rng->seed, seed, seedSz);
 801f658:	68fb      	ldr	r3, [r7, #12]
 801f65a:	6a3a      	ldr	r2, [r7, #32]
 801f65c:	69f9      	ldr	r1, [r7, #28]
 801f65e:	4618      	mov	r0, r3
 801f660:	f000 fa7e 	bl	801fb60 <wc_GenerateSeed>
 801f664:	6278      	str	r0, [r7, #36]	@ 0x24
#endif /* WC_RNG_SEED_CB */
            if (ret == 0)
 801f666:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f668:	2b00      	cmp	r3, #0
 801f66a:	d105      	bne.n	801f678 <_InitRng+0xc6>
                ret = wc_RNG_TestSeed(seed, seedSz);
 801f66c:	6a39      	ldr	r1, [r7, #32]
 801f66e:	69f8      	ldr	r0, [r7, #28]
 801f670:	f7ff ff68 	bl	801f544 <wc_RNG_TestSeed>
 801f674:	6278      	str	r0, [r7, #36]	@ 0x24
 801f676:	e004      	b.n	801f682 <_InitRng+0xd0>
            else {
    #if defined(DEBUG_WOLFSSL)
                WOLFSSL_MSG_EX("wc_RNG_TestSeed failed... %d", ret);
    #endif
                ret = DRBG_FAILURE;
 801f678:	2301      	movs	r3, #1
 801f67a:	627b      	str	r3, [r7, #36]	@ 0x24
                rng->status = DRBG_FAILED;
 801f67c:	68fb      	ldr	r3, [r7, #12]
 801f67e:	2202      	movs	r2, #2
 801f680:	731a      	strb	r2, [r3, #12]
            }

            if (ret == DRBG_SUCCESS)
 801f682:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f684:	2b00      	cmp	r3, #0
 801f686:	d111      	bne.n	801f6ac <_InitRng+0xfa>
                ret = Hash_DRBG_Instantiate((DRBG_internal *)rng->drbg,
 801f688:	68fb      	ldr	r3, [r7, #12]
 801f68a:	6898      	ldr	r0, [r3, #8]
                            seed + SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ,
 801f68c:	69fb      	ldr	r3, [r7, #28]
 801f68e:	1d19      	adds	r1, r3, #4
                ret = Hash_DRBG_Instantiate((DRBG_internal *)rng->drbg,
 801f690:	6a3b      	ldr	r3, [r7, #32]
 801f692:	1f1c      	subs	r4, r3, #4
 801f694:	68fb      	ldr	r3, [r7, #12]
 801f696:	685b      	ldr	r3, [r3, #4]
 801f698:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f69a:	9202      	str	r2, [sp, #8]
 801f69c:	9301      	str	r3, [sp, #4]
 801f69e:	687b      	ldr	r3, [r7, #4]
 801f6a0:	9300      	str	r3, [sp, #0]
 801f6a2:	68bb      	ldr	r3, [r7, #8]
 801f6a4:	4622      	mov	r2, r4
 801f6a6:	f7ff fee5 	bl	801f474 <Hash_DRBG_Instantiate>
 801f6aa:	6278      	str	r0, [r7, #36]	@ 0x24
                            nonce, nonceSz, rng->heap, devId);

            if (ret != DRBG_SUCCESS) {
 801f6ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f6ae:	2b00      	cmp	r3, #0
 801f6b0:	d00b      	beq.n	801f6ca <_InitRng+0x118>
            #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
                XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
 801f6b2:	68fb      	ldr	r3, [r7, #12]
 801f6b4:	689b      	ldr	r3, [r3, #8]
 801f6b6:	61bb      	str	r3, [r7, #24]
 801f6b8:	69bb      	ldr	r3, [r7, #24]
 801f6ba:	2b00      	cmp	r3, #0
 801f6bc:	d002      	beq.n	801f6c4 <_InitRng+0x112>
 801f6be:	69b8      	ldr	r0, [r7, #24]
 801f6c0:	f7ff faf8 	bl	801ecb4 <wolfSSL_Free>
            #endif
                rng->drbg = NULL;
 801f6c4:	68fb      	ldr	r3, [r7, #12]
 801f6c6:	2200      	movs	r2, #0
 801f6c8:	609a      	str	r2, [r3, #8]
            }
        } /* ret == 0 */

        ForceZero(seed, seedSz);
 801f6ca:	6a39      	ldr	r1, [r7, #32]
 801f6cc:	69f8      	ldr	r0, [r7, #28]
 801f6ce:	f7ff fb2f 	bl	801ed30 <ForceZero>
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(seed, rng->heap, DYNAMIC_TYPE_SEED);
 801f6d2:	69fb      	ldr	r3, [r7, #28]
 801f6d4:	617b      	str	r3, [r7, #20]
 801f6d6:	697b      	ldr	r3, [r7, #20]
 801f6d8:	2b00      	cmp	r3, #0
 801f6da:	d002      	beq.n	801f6e2 <_InitRng+0x130>
 801f6dc:	6978      	ldr	r0, [r7, #20]
 801f6de:	f7ff fae9 	bl	801ecb4 <wolfSSL_Free>
    #endif
    } /* else swc_RNG_HealthTestLocal was successful */

    if (ret == DRBG_SUCCESS) {
 801f6e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f6e4:	2b00      	cmp	r3, #0
 801f6e6:	d105      	bne.n	801f6f4 <_InitRng+0x142>
        wc_MemZero_Add("DRBG V", &drbg->V, sizeof(drbg->V));
        wc_MemZero_Add("DRBG C", &drbg->C, sizeof(drbg->C));
    #endif
#endif

        rng->status = DRBG_OK;
 801f6e8:	68fb      	ldr	r3, [r7, #12]
 801f6ea:	2201      	movs	r2, #1
 801f6ec:	731a      	strb	r2, [r3, #12]
        ret = 0;
 801f6ee:	2300      	movs	r3, #0
 801f6f0:	627b      	str	r3, [r7, #36]	@ 0x24
 801f6f2:	e016      	b.n	801f722 <_InitRng+0x170>
    }
    else if (ret == DRBG_CONT_FAILURE) {
 801f6f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f6f6:	2b03      	cmp	r3, #3
 801f6f8:	d106      	bne.n	801f708 <_InitRng+0x156>
        rng->status = DRBG_CONT_FAILED;
 801f6fa:	68fb      	ldr	r3, [r7, #12]
 801f6fc:	2203      	movs	r2, #3
 801f6fe:	731a      	strb	r2, [r3, #12]
        ret = DRBG_CONT_FIPS_E;
 801f700:	f06f 03d0 	mvn.w	r3, #208	@ 0xd0
 801f704:	627b      	str	r3, [r7, #36]	@ 0x24
 801f706:	e00c      	b.n	801f722 <_InitRng+0x170>
    }
    else if (ret == DRBG_FAILURE) {
 801f708:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f70a:	2b01      	cmp	r3, #1
 801f70c:	d106      	bne.n	801f71c <_InitRng+0x16a>
        rng->status = DRBG_FAILED;
 801f70e:	68fb      	ldr	r3, [r7, #12]
 801f710:	2202      	movs	r2, #2
 801f712:	731a      	strb	r2, [r3, #12]
        ret = RNG_FAILURE_E;
 801f714:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f718:	627b      	str	r3, [r7, #36]	@ 0x24
 801f71a:	e002      	b.n	801f722 <_InitRng+0x170>
    }
    else {
        rng->status = DRBG_FAILED;
 801f71c:	68fb      	ldr	r3, [r7, #12]
 801f71e:	2202      	movs	r2, #2
 801f720:	731a      	strb	r2, [r3, #12]
    }
#endif /* HAVE_HASHDRBG */
#endif /* CUSTOM_RAND_GENERATE_BLOCK */

    return ret;
 801f722:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 801f724:	4618      	mov	r0, r3
 801f726:	372c      	adds	r7, #44	@ 0x2c
 801f728:	46bd      	mov	sp, r7
 801f72a:	bd90      	pop	{r4, r7, pc}

0801f72c <wc_rng_free>:
}


WOLFSSL_ABI
void wc_rng_free(WC_RNG* rng)
{
 801f72c:	b580      	push	{r7, lr}
 801f72e:	b084      	sub	sp, #16
 801f730:	af00      	add	r7, sp, #0
 801f732:	6078      	str	r0, [r7, #4]
    if (rng) {
 801f734:	687b      	ldr	r3, [r7, #4]
 801f736:	2b00      	cmp	r3, #0
 801f738:	d011      	beq.n	801f75e <wc_rng_free+0x32>
        void* heap = rng->heap;
 801f73a:	687b      	ldr	r3, [r7, #4]
 801f73c:	685b      	ldr	r3, [r3, #4]
 801f73e:	60fb      	str	r3, [r7, #12]

        wc_FreeRng(rng);
 801f740:	6878      	ldr	r0, [r7, #4]
 801f742:	f000 f8c3 	bl	801f8cc <wc_FreeRng>
        ForceZero(rng, sizeof(WC_RNG));
 801f746:	2110      	movs	r1, #16
 801f748:	6878      	ldr	r0, [r7, #4]
 801f74a:	f7ff faf1 	bl	801ed30 <ForceZero>
        XFREE(rng, heap, DYNAMIC_TYPE_RNG);
 801f74e:	687b      	ldr	r3, [r7, #4]
 801f750:	60bb      	str	r3, [r7, #8]
 801f752:	68bb      	ldr	r3, [r7, #8]
 801f754:	2b00      	cmp	r3, #0
 801f756:	d002      	beq.n	801f75e <wc_rng_free+0x32>
 801f758:	68b8      	ldr	r0, [r7, #8]
 801f75a:	f7ff faab 	bl	801ecb4 <wolfSSL_Free>
        (void)heap;
    }
}
 801f75e:	bf00      	nop
 801f760:	3710      	adds	r7, #16
 801f762:	46bd      	mov	sp, r7
 801f764:	bd80      	pop	{r7, pc}

0801f766 <wc_InitRng>:

WOLFSSL_ABI
int wc_InitRng(WC_RNG* rng)
{
 801f766:	b580      	push	{r7, lr}
 801f768:	b084      	sub	sp, #16
 801f76a:	af02      	add	r7, sp, #8
 801f76c:	6078      	str	r0, [r7, #4]
    return _InitRng(rng, NULL, 0, NULL, INVALID_DEVID);
 801f76e:	f06f 0301 	mvn.w	r3, #1
 801f772:	9300      	str	r3, [sp, #0]
 801f774:	2300      	movs	r3, #0
 801f776:	2200      	movs	r2, #0
 801f778:	2100      	movs	r1, #0
 801f77a:	6878      	ldr	r0, [r7, #4]
 801f77c:	f7ff ff19 	bl	801f5b2 <_InitRng>
 801f780:	4603      	mov	r3, r0
}
 801f782:	4618      	mov	r0, r3
 801f784:	3708      	adds	r7, #8
 801f786:	46bd      	mov	sp, r7
 801f788:	bd80      	pop	{r7, pc}

0801f78a <wc_RNG_GenerateBlock>:


/* place a generated block in output */
WOLFSSL_ABI
int wc_RNG_GenerateBlock(WC_RNG* rng, byte* output, word32 sz)
{
 801f78a:	b580      	push	{r7, lr}
 801f78c:	b088      	sub	sp, #32
 801f78e:	af00      	add	r7, sp, #0
 801f790:	60f8      	str	r0, [r7, #12]
 801f792:	60b9      	str	r1, [r7, #8]
 801f794:	607a      	str	r2, [r7, #4]
    int ret;

    if (rng == NULL || output == NULL)
 801f796:	68fb      	ldr	r3, [r7, #12]
 801f798:	2b00      	cmp	r3, #0
 801f79a:	d002      	beq.n	801f7a2 <wc_RNG_GenerateBlock+0x18>
 801f79c:	68bb      	ldr	r3, [r7, #8]
 801f79e:	2b00      	cmp	r3, #0
 801f7a0:	d102      	bne.n	801f7a8 <wc_RNG_GenerateBlock+0x1e>
        return BAD_FUNC_ARG;
 801f7a2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f7a6:	e08d      	b.n	801f8c4 <wc_RNG_GenerateBlock+0x13a>

    if (sz == 0)
 801f7a8:	687b      	ldr	r3, [r7, #4]
 801f7aa:	2b00      	cmp	r3, #0
 801f7ac:	d101      	bne.n	801f7b2 <wc_RNG_GenerateBlock+0x28>
        return 0;
 801f7ae:	2300      	movs	r3, #0
 801f7b0:	e088      	b.n	801f8c4 <wc_RNG_GenerateBlock+0x13a>
    XMEMSET(output, 0, sz);
    ret = (int)CUSTOM_RAND_GENERATE_BLOCK(output, sz);
#else

#ifdef HAVE_HASHDRBG
    if (sz > RNG_MAX_BLOCK_LEN)
 801f7b2:	687b      	ldr	r3, [r7, #4]
 801f7b4:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 801f7b8:	d902      	bls.n	801f7c0 <wc_RNG_GenerateBlock+0x36>
        return BAD_FUNC_ARG;
 801f7ba:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f7be:	e081      	b.n	801f8c4 <wc_RNG_GenerateBlock+0x13a>

    if (rng->status != DRBG_OK)
 801f7c0:	68fb      	ldr	r3, [r7, #12]
 801f7c2:	7b1b      	ldrb	r3, [r3, #12]
 801f7c4:	2b01      	cmp	r3, #1
 801f7c6:	d002      	beq.n	801f7ce <wc_RNG_GenerateBlock+0x44>
        return RNG_FAILURE_E;
 801f7c8:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f7cc:	e07a      	b.n	801f8c4 <wc_RNG_GenerateBlock+0x13a>

    ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
 801f7ce:	68fb      	ldr	r3, [r7, #12]
 801f7d0:	689b      	ldr	r3, [r3, #8]
 801f7d2:	687a      	ldr	r2, [r7, #4]
 801f7d4:	68b9      	ldr	r1, [r7, #8]
 801f7d6:	4618      	mov	r0, r3
 801f7d8:	f7ff fd9e 	bl	801f318 <Hash_DRBG_Generate>
 801f7dc:	61f8      	str	r0, [r7, #28]
    if (ret == DRBG_NEED_RESEED) {
 801f7de:	69fb      	ldr	r3, [r7, #28]
 801f7e0:	2b02      	cmp	r3, #2
 801f7e2:	d158      	bne.n	801f896 <wc_RNG_GenerateBlock+0x10c>
        int devId = INVALID_DEVID;
 801f7e4:	f06f 0301 	mvn.w	r3, #1
 801f7e8:	61bb      	str	r3, [r7, #24]
    #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
        devId = rng->devId;
    #endif
        if (wc_RNG_HealthTestLocal(1, rng->heap, devId) == 0) {
 801f7ea:	68fb      	ldr	r3, [r7, #12]
 801f7ec:	685b      	ldr	r3, [r3, #4]
 801f7ee:	69ba      	ldr	r2, [r7, #24]
 801f7f0:	4619      	mov	r1, r3
 801f7f2:	2001      	movs	r0, #1
 801f7f4:	f000 f90e 	bl	801fa14 <wc_RNG_HealthTestLocal>
 801f7f8:	4603      	mov	r3, r0
 801f7fa:	2b00      	cmp	r3, #0
 801f7fc:	d149      	bne.n	801f892 <wc_RNG_GenerateBlock+0x108>
        #ifndef WOLFSSL_SMALL_STACK
            byte newSeed[SEED_SZ + SEED_BLOCK_SZ];
            ret = DRBG_SUCCESS;
        #else
            byte* newSeed = (byte*)XMALLOC(SEED_SZ + SEED_BLOCK_SZ, rng->heap,
 801f7fe:	2024      	movs	r0, #36	@ 0x24
 801f800:	f7ff fa3c 	bl	801ec7c <wolfSSL_Malloc>
 801f804:	6178      	str	r0, [r7, #20]
                DYNAMIC_TYPE_SEED);
            ret = (newSeed == NULL) ? MEMORY_E : DRBG_SUCCESS;
 801f806:	697b      	ldr	r3, [r7, #20]
 801f808:	2b00      	cmp	r3, #0
 801f80a:	d102      	bne.n	801f812 <wc_RNG_GenerateBlock+0x88>
 801f80c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f810:	e000      	b.n	801f814 <wc_RNG_GenerateBlock+0x8a>
 801f812:	2300      	movs	r3, #0
 801f814:	61fb      	str	r3, [r7, #28]
        #endif
            if (ret == DRBG_SUCCESS) {
 801f816:	69fb      	ldr	r3, [r7, #28]
 801f818:	2b00      	cmp	r3, #0
 801f81a:	d10b      	bne.n	801f834 <wc_RNG_GenerateBlock+0xaa>
                    if (ret != 0) {
                        ret = DRBG_FAILURE;
                    }
                }
            #else
                ret = wc_GenerateSeed(&rng->seed, newSeed,
 801f81c:	68fb      	ldr	r3, [r7, #12]
 801f81e:	2224      	movs	r2, #36	@ 0x24
 801f820:	6979      	ldr	r1, [r7, #20]
 801f822:	4618      	mov	r0, r3
 801f824:	f000 f99c 	bl	801fb60 <wc_GenerateSeed>
 801f828:	61f8      	str	r0, [r7, #28]
                                  SEED_SZ + SEED_BLOCK_SZ);
            #endif
                if (ret != 0)
 801f82a:	69fb      	ldr	r3, [r7, #28]
 801f82c:	2b00      	cmp	r3, #0
 801f82e:	d001      	beq.n	801f834 <wc_RNG_GenerateBlock+0xaa>
                    ret = DRBG_FAILURE;
 801f830:	2301      	movs	r3, #1
 801f832:	61fb      	str	r3, [r7, #28]
            }
            if (ret == DRBG_SUCCESS)
 801f834:	69fb      	ldr	r3, [r7, #28]
 801f836:	2b00      	cmp	r3, #0
 801f838:	d104      	bne.n	801f844 <wc_RNG_GenerateBlock+0xba>
                ret = wc_RNG_TestSeed(newSeed, SEED_SZ + SEED_BLOCK_SZ);
 801f83a:	2124      	movs	r1, #36	@ 0x24
 801f83c:	6978      	ldr	r0, [r7, #20]
 801f83e:	f7ff fe81 	bl	801f544 <wc_RNG_TestSeed>
 801f842:	61f8      	str	r0, [r7, #28]

            if (ret == DRBG_SUCCESS)
 801f844:	69fb      	ldr	r3, [r7, #28]
 801f846:	2b00      	cmp	r3, #0
 801f848:	d108      	bne.n	801f85c <wc_RNG_GenerateBlock+0xd2>
                ret = Hash_DRBG_Reseed((DRBG_internal *)rng->drbg,
 801f84a:	68fb      	ldr	r3, [r7, #12]
 801f84c:	6898      	ldr	r0, [r3, #8]
                                       newSeed + SEED_BLOCK_SZ, SEED_SZ);
 801f84e:	697b      	ldr	r3, [r7, #20]
 801f850:	3304      	adds	r3, #4
                ret = Hash_DRBG_Reseed((DRBG_internal *)rng->drbg,
 801f852:	2220      	movs	r2, #32
 801f854:	4619      	mov	r1, r3
 801f856:	f7ff fbab 	bl	801efb0 <Hash_DRBG_Reseed>
 801f85a:	61f8      	str	r0, [r7, #28]
            if (ret == DRBG_SUCCESS)
 801f85c:	69fb      	ldr	r3, [r7, #28]
 801f85e:	2b00      	cmp	r3, #0
 801f860:	d107      	bne.n	801f872 <wc_RNG_GenerateBlock+0xe8>
                ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
 801f862:	68fb      	ldr	r3, [r7, #12]
 801f864:	689b      	ldr	r3, [r3, #8]
 801f866:	687a      	ldr	r2, [r7, #4]
 801f868:	68b9      	ldr	r1, [r7, #8]
 801f86a:	4618      	mov	r0, r3
 801f86c:	f7ff fd54 	bl	801f318 <Hash_DRBG_Generate>
 801f870:	61f8      	str	r0, [r7, #28]

        #ifdef WOLFSSL_SMALL_STACK
            if (newSeed != NULL) {
 801f872:	697b      	ldr	r3, [r7, #20]
 801f874:	2b00      	cmp	r3, #0
 801f876:	d003      	beq.n	801f880 <wc_RNG_GenerateBlock+0xf6>
                ForceZero(newSeed, SEED_SZ + SEED_BLOCK_SZ);
 801f878:	2124      	movs	r1, #36	@ 0x24
 801f87a:	6978      	ldr	r0, [r7, #20]
 801f87c:	f7ff fa58 	bl	801ed30 <ForceZero>
            }
            XFREE(newSeed, rng->heap, DYNAMIC_TYPE_SEED);
 801f880:	697b      	ldr	r3, [r7, #20]
 801f882:	613b      	str	r3, [r7, #16]
 801f884:	693b      	ldr	r3, [r7, #16]
 801f886:	2b00      	cmp	r3, #0
 801f888:	d005      	beq.n	801f896 <wc_RNG_GenerateBlock+0x10c>
 801f88a:	6938      	ldr	r0, [r7, #16]
 801f88c:	f7ff fa12 	bl	801ecb4 <wolfSSL_Free>
 801f890:	e001      	b.n	801f896 <wc_RNG_GenerateBlock+0x10c>
        #else
            ForceZero(newSeed, sizeof(newSeed));
        #endif
        }
        else {
            ret = DRBG_CONT_FAILURE;
 801f892:	2303      	movs	r3, #3
 801f894:	61fb      	str	r3, [r7, #28]
        }
    }

    if (ret == DRBG_SUCCESS) {
 801f896:	69fb      	ldr	r3, [r7, #28]
 801f898:	2b00      	cmp	r3, #0
 801f89a:	d102      	bne.n	801f8a2 <wc_RNG_GenerateBlock+0x118>
        ret = 0;
 801f89c:	2300      	movs	r3, #0
 801f89e:	61fb      	str	r3, [r7, #28]
 801f8a0:	e00f      	b.n	801f8c2 <wc_RNG_GenerateBlock+0x138>
    }
    else if (ret == DRBG_CONT_FAILURE) {
 801f8a2:	69fb      	ldr	r3, [r7, #28]
 801f8a4:	2b03      	cmp	r3, #3
 801f8a6:	d106      	bne.n	801f8b6 <wc_RNG_GenerateBlock+0x12c>
        ret = DRBG_CONT_FIPS_E;
 801f8a8:	f06f 03d0 	mvn.w	r3, #208	@ 0xd0
 801f8ac:	61fb      	str	r3, [r7, #28]
        rng->status = DRBG_CONT_FAILED;
 801f8ae:	68fb      	ldr	r3, [r7, #12]
 801f8b0:	2203      	movs	r2, #3
 801f8b2:	731a      	strb	r2, [r3, #12]
 801f8b4:	e005      	b.n	801f8c2 <wc_RNG_GenerateBlock+0x138>
    }
    else {
        ret = RNG_FAILURE_E;
 801f8b6:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f8ba:	61fb      	str	r3, [r7, #28]
        rng->status = DRBG_FAILED;
 801f8bc:	68fb      	ldr	r3, [r7, #12]
 801f8be:	2202      	movs	r2, #2
 801f8c0:	731a      	strb	r2, [r3, #12]
    ret = RNG_FAILURE_E;

#endif /* HAVE_HASHDRBG */
#endif /* CUSTOM_RAND_GENERATE_BLOCK */

    return ret;
 801f8c2:	69fb      	ldr	r3, [r7, #28]
}
 801f8c4:	4618      	mov	r0, r3
 801f8c6:	3720      	adds	r7, #32
 801f8c8:	46bd      	mov	sp, r7
 801f8ca:	bd80      	pop	{r7, pc}

0801f8cc <wc_FreeRng>:
    return wc_RNG_GenerateBlock(rng, b, 1);
}


int wc_FreeRng(WC_RNG* rng)
{
 801f8cc:	b580      	push	{r7, lr}
 801f8ce:	b084      	sub	sp, #16
 801f8d0:	af00      	add	r7, sp, #0
 801f8d2:	6078      	str	r0, [r7, #4]
    int ret = 0;
 801f8d4:	2300      	movs	r3, #0
 801f8d6:	60fb      	str	r3, [r7, #12]

    if (rng == NULL)
 801f8d8:	687b      	ldr	r3, [r7, #4]
 801f8da:	2b00      	cmp	r3, #0
 801f8dc:	d102      	bne.n	801f8e4 <wc_FreeRng+0x18>
        return BAD_FUNC_ARG;
 801f8de:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f8e2:	e01e      	b.n	801f922 <wc_FreeRng+0x56>
#if defined(WOLFSSL_ASYNC_CRYPT)
    wolfAsync_DevCtxFree(&rng->asyncDev, WOLFSSL_ASYNC_MARKER_RNG);
#endif

#ifdef HAVE_HASHDRBG
    if (rng->drbg != NULL) {
 801f8e4:	687b      	ldr	r3, [r7, #4]
 801f8e6:	689b      	ldr	r3, [r3, #8]
 801f8e8:	2b00      	cmp	r3, #0
 801f8ea:	d016      	beq.n	801f91a <wc_FreeRng+0x4e>
      if (Hash_DRBG_Uninstantiate((DRBG_internal *)rng->drbg) != DRBG_SUCCESS)
 801f8ec:	687b      	ldr	r3, [r7, #4]
 801f8ee:	689b      	ldr	r3, [r3, #8]
 801f8f0:	4618      	mov	r0, r3
 801f8f2:	f7ff fe00 	bl	801f4f6 <Hash_DRBG_Uninstantiate>
 801f8f6:	4603      	mov	r3, r0
 801f8f8:	2b00      	cmp	r3, #0
 801f8fa:	d002      	beq.n	801f902 <wc_FreeRng+0x36>
            ret = RNG_FAILURE_E;
 801f8fc:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f900:	60fb      	str	r3, [r7, #12]

    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
        XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
 801f902:	687b      	ldr	r3, [r7, #4]
 801f904:	689b      	ldr	r3, [r3, #8]
 801f906:	60bb      	str	r3, [r7, #8]
 801f908:	68bb      	ldr	r3, [r7, #8]
 801f90a:	2b00      	cmp	r3, #0
 801f90c:	d002      	beq.n	801f914 <wc_FreeRng+0x48>
 801f90e:	68b8      	ldr	r0, [r7, #8]
 801f910:	f7ff f9d0 	bl	801ecb4 <wolfSSL_Free>
    #elif defined(WOLFSSL_CHECK_MEM_ZERO)
        wc_MemZero_Check(rng->drbg, sizeof(DRBG_internal));
    #endif
        rng->drbg = NULL;
 801f914:	687b      	ldr	r3, [r7, #4]
 801f916:	2200      	movs	r2, #0
 801f918:	609a      	str	r2, [r3, #8]
    }

    rng->status = DRBG_NOT_INIT;
 801f91a:	687b      	ldr	r3, [r7, #4]
 801f91c:	2200      	movs	r2, #0
 801f91e:	731a      	strb	r2, [r3, #12]
    /* don't overwrite previously set error */
    if (wc_VersalTrngReset() && !ret)
        ret = WC_HW_E;
#endif

    return ret;
 801f920:	68fb      	ldr	r3, [r7, #12]
}
 801f922:	4618      	mov	r0, r3
 801f924:	3710      	adds	r7, #16
 801f926:	46bd      	mov	sp, r7
 801f928:	bd80      	pop	{r7, pc}

0801f92a <wc_RNG_HealthTest_ex>:
int wc_RNG_HealthTest_ex(int reseed, const byte* nonce, word32 nonceSz,
                                  const byte* seedA, word32 seedASz,
                                  const byte* seedB, word32 seedBSz,
                                  byte* output, word32 outputSz,
                                  void* heap, int devId)
{
 801f92a:	b580      	push	{r7, lr}
 801f92c:	b08c      	sub	sp, #48	@ 0x30
 801f92e:	af04      	add	r7, sp, #16
 801f930:	60f8      	str	r0, [r7, #12]
 801f932:	60b9      	str	r1, [r7, #8]
 801f934:	607a      	str	r2, [r7, #4]
 801f936:	603b      	str	r3, [r7, #0]
    int ret = -1;
 801f938:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f93c:	61fb      	str	r3, [r7, #28]
    DRBG_internal* drbg;
#ifndef WOLFSSL_SMALL_STACK
    DRBG_internal  drbg_var;
#endif

    if (seedA == NULL || output == NULL) {
 801f93e:	683b      	ldr	r3, [r7, #0]
 801f940:	2b00      	cmp	r3, #0
 801f942:	d002      	beq.n	801f94a <wc_RNG_HealthTest_ex+0x20>
 801f944:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801f946:	2b00      	cmp	r3, #0
 801f948:	d102      	bne.n	801f950 <wc_RNG_HealthTest_ex+0x26>
        return BAD_FUNC_ARG;
 801f94a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f94e:	e05d      	b.n	801fa0c <wc_RNG_HealthTest_ex+0xe2>
    }

    if (reseed != 0 && seedB == NULL) {
 801f950:	68fb      	ldr	r3, [r7, #12]
 801f952:	2b00      	cmp	r3, #0
 801f954:	d005      	beq.n	801f962 <wc_RNG_HealthTest_ex+0x38>
 801f956:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f958:	2b00      	cmp	r3, #0
 801f95a:	d102      	bne.n	801f962 <wc_RNG_HealthTest_ex+0x38>
        return BAD_FUNC_ARG;
 801f95c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f960:	e054      	b.n	801fa0c <wc_RNG_HealthTest_ex+0xe2>
    }

    if (outputSz != RNG_HEALTH_TEST_CHECK_SIZE) {
 801f962:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801f964:	2b80      	cmp	r3, #128	@ 0x80
 801f966:	d001      	beq.n	801f96c <wc_RNG_HealthTest_ex+0x42>
        return ret;
 801f968:	69fb      	ldr	r3, [r7, #28]
 801f96a:	e04f      	b.n	801fa0c <wc_RNG_HealthTest_ex+0xe2>
    }

#ifdef WOLFSSL_SMALL_STACK
    drbg = (DRBG_internal*)XMALLOC(sizeof(DRBG_internal), heap,
 801f96c:	2078      	movs	r0, #120	@ 0x78
 801f96e:	f7ff f985 	bl	801ec7c <wolfSSL_Malloc>
 801f972:	61b8      	str	r0, [r7, #24]
        DYNAMIC_TYPE_RNG);
    if (drbg == NULL) {
 801f974:	69bb      	ldr	r3, [r7, #24]
 801f976:	2b00      	cmp	r3, #0
 801f978:	d102      	bne.n	801f980 <wc_RNG_HealthTest_ex+0x56>
        return MEMORY_E;
 801f97a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f97e:	e045      	b.n	801fa0c <wc_RNG_HealthTest_ex+0xe2>
    }
#else
    drbg = &drbg_var;
#endif

    if (Hash_DRBG_Instantiate(drbg, seedA, seedASz, nonce, nonceSz,
 801f980:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801f982:	9302      	str	r3, [sp, #8]
 801f984:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801f986:	9301      	str	r3, [sp, #4]
 801f988:	687b      	ldr	r3, [r7, #4]
 801f98a:	9300      	str	r3, [sp, #0]
 801f98c:	68bb      	ldr	r3, [r7, #8]
 801f98e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801f990:	6839      	ldr	r1, [r7, #0]
 801f992:	69b8      	ldr	r0, [r7, #24]
 801f994:	f7ff fd6e 	bl	801f474 <Hash_DRBG_Instantiate>
 801f998:	4603      	mov	r3, r0
 801f99a:	2b00      	cmp	r3, #0
 801f99c:	d11d      	bne.n	801f9da <wc_RNG_HealthTest_ex+0xb0>
                              heap, devId) != 0) {
        goto exit_rng_ht;
    }

    if (reseed) {
 801f99e:	68fb      	ldr	r3, [r7, #12]
 801f9a0:	2b00      	cmp	r3, #0
 801f9a2:	d007      	beq.n	801f9b4 <wc_RNG_HealthTest_ex+0x8a>
        if (Hash_DRBG_Reseed(drbg, seedB, seedBSz) != 0) {
 801f9a4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801f9a6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801f9a8:	69b8      	ldr	r0, [r7, #24]
 801f9aa:	f7ff fb01 	bl	801efb0 <Hash_DRBG_Reseed>
 801f9ae:	4603      	mov	r3, r0
 801f9b0:	2b00      	cmp	r3, #0
 801f9b2:	d114      	bne.n	801f9de <wc_RNG_HealthTest_ex+0xb4>
    /* This call to generate is prescribed by the NIST DRBGVS
     * procedure. The results are thrown away. The known
     * answer test checks the second block of DRBG out of
     * the generator to ensure the internal state is updated
     * as expected. */
    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
 801f9b4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f9b6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801f9b8:	69b8      	ldr	r0, [r7, #24]
 801f9ba:	f7ff fcad 	bl	801f318 <Hash_DRBG_Generate>
 801f9be:	4603      	mov	r3, r0
 801f9c0:	2b00      	cmp	r3, #0
 801f9c2:	d10e      	bne.n	801f9e2 <wc_RNG_HealthTest_ex+0xb8>
        goto exit_rng_ht;
    }

    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
 801f9c4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f9c6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801f9c8:	69b8      	ldr	r0, [r7, #24]
 801f9ca:	f7ff fca5 	bl	801f318 <Hash_DRBG_Generate>
 801f9ce:	4603      	mov	r3, r0
 801f9d0:	2b00      	cmp	r3, #0
 801f9d2:	d108      	bne.n	801f9e6 <wc_RNG_HealthTest_ex+0xbc>
        goto exit_rng_ht;
    }

    /* Mark success */
    ret = 0;
 801f9d4:	2300      	movs	r3, #0
 801f9d6:	61fb      	str	r3, [r7, #28]
 801f9d8:	e006      	b.n	801f9e8 <wc_RNG_HealthTest_ex+0xbe>
        goto exit_rng_ht;
 801f9da:	bf00      	nop
 801f9dc:	e004      	b.n	801f9e8 <wc_RNG_HealthTest_ex+0xbe>
            goto exit_rng_ht;
 801f9de:	bf00      	nop
 801f9e0:	e002      	b.n	801f9e8 <wc_RNG_HealthTest_ex+0xbe>
        goto exit_rng_ht;
 801f9e2:	bf00      	nop
 801f9e4:	e000      	b.n	801f9e8 <wc_RNG_HealthTest_ex+0xbe>
        goto exit_rng_ht;
 801f9e6:	bf00      	nop

exit_rng_ht:

    /* This is safe to call even if Hash_DRBG_Instantiate fails */
    if (Hash_DRBG_Uninstantiate(drbg) != 0) {
 801f9e8:	69b8      	ldr	r0, [r7, #24]
 801f9ea:	f7ff fd84 	bl	801f4f6 <Hash_DRBG_Uninstantiate>
 801f9ee:	4603      	mov	r3, r0
 801f9f0:	2b00      	cmp	r3, #0
 801f9f2:	d002      	beq.n	801f9fa <wc_RNG_HealthTest_ex+0xd0>
        ret = -1;
 801f9f4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f9f8:	61fb      	str	r3, [r7, #28]
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(drbg, heap, DYNAMIC_TYPE_RNG);
 801f9fa:	69bb      	ldr	r3, [r7, #24]
 801f9fc:	617b      	str	r3, [r7, #20]
 801f9fe:	697b      	ldr	r3, [r7, #20]
 801fa00:	2b00      	cmp	r3, #0
 801fa02:	d002      	beq.n	801fa0a <wc_RNG_HealthTest_ex+0xe0>
 801fa04:	6978      	ldr	r0, [r7, #20]
 801fa06:	f7ff f955 	bl	801ecb4 <wolfSSL_Free>
#endif

    return ret;
 801fa0a:	69fb      	ldr	r3, [r7, #28]
}
 801fa0c:	4618      	mov	r0, r3
 801fa0e:	3720      	adds	r7, #32
 801fa10:	46bd      	mov	sp, r7
 801fa12:	bd80      	pop	{r7, pc}

0801fa14 <wc_RNG_HealthTestLocal>:
    0xd4, 0x31, 0xf4, 0xc9, 0xf7, 0x04, 0x27, 0xdf
};


static int wc_RNG_HealthTestLocal(int reseed, void* heap, int devId)
{
 801fa14:	b580      	push	{r7, lr}
 801fa16:	b094      	sub	sp, #80	@ 0x50
 801fa18:	af08      	add	r7, sp, #32
 801fa1a:	60f8      	str	r0, [r7, #12]
 801fa1c:	60b9      	str	r1, [r7, #8]
 801fa1e:	607a      	str	r2, [r7, #4]
    int ret = 0;
 801fa20:	2300      	movs	r3, #0
 801fa22:	62fb      	str	r3, [r7, #44]	@ 0x2c
#else
    byte  check[RNG_HEALTH_TEST_CHECK_SIZE];
#endif

#ifdef WOLFSSL_SMALL_STACK
    check = (byte*)XMALLOC(RNG_HEALTH_TEST_CHECK_SIZE, NULL,
 801fa24:	2080      	movs	r0, #128	@ 0x80
 801fa26:	f7ff f929 	bl	801ec7c <wolfSSL_Malloc>
 801fa2a:	62b8      	str	r0, [r7, #40]	@ 0x28
                           DYNAMIC_TYPE_TMP_BUFFER);
    if (check == NULL) {
 801fa2c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801fa2e:	2b00      	cmp	r3, #0
 801fa30:	d102      	bne.n	801fa38 <wc_RNG_HealthTestLocal+0x24>
        return MEMORY_E;
 801fa32:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801fa36:	e085      	b.n	801fb44 <wc_RNG_HealthTestLocal+0x130>
    }
#endif

    if (reseed) {
 801fa38:	68fb      	ldr	r3, [r7, #12]
 801fa3a:	2b00      	cmp	r3, #0
 801fa3c:	d029      	beq.n	801fa92 <wc_RNG_HealthTestLocal+0x7e>
        else {
            XMEMCPY_P(seedA, seedA_data, sizeof(seedA_data));
            XMEMCPY_P(reseedSeedA, reseedSeedA_data, sizeof(reseedSeedA_data));
            XMEMCPY_P(outputA, outputA_data, sizeof(outputA_data));
#else
        const byte* seedA = seedA_data;
 801fa3e:	4b43      	ldr	r3, [pc, #268]	@ (801fb4c <wc_RNG_HealthTestLocal+0x138>)
 801fa40:	61fb      	str	r3, [r7, #28]
        const byte* reseedSeedA = reseedSeedA_data;
 801fa42:	4b43      	ldr	r3, [pc, #268]	@ (801fb50 <wc_RNG_HealthTestLocal+0x13c>)
 801fa44:	61bb      	str	r3, [r7, #24]
        const byte* outputA = outputA_data;
 801fa46:	4b43      	ldr	r3, [pc, #268]	@ (801fb54 <wc_RNG_HealthTestLocal+0x140>)
 801fa48:	617b      	str	r3, [r7, #20]
#endif
        ret = wc_RNG_HealthTest_ex(1, NULL, 0,
 801fa4a:	687b      	ldr	r3, [r7, #4]
 801fa4c:	9306      	str	r3, [sp, #24]
 801fa4e:	68bb      	ldr	r3, [r7, #8]
 801fa50:	9305      	str	r3, [sp, #20]
 801fa52:	2380      	movs	r3, #128	@ 0x80
 801fa54:	9304      	str	r3, [sp, #16]
 801fa56:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801fa58:	9303      	str	r3, [sp, #12]
 801fa5a:	2320      	movs	r3, #32
 801fa5c:	9302      	str	r3, [sp, #8]
 801fa5e:	69bb      	ldr	r3, [r7, #24]
 801fa60:	9301      	str	r3, [sp, #4]
 801fa62:	2330      	movs	r3, #48	@ 0x30
 801fa64:	9300      	str	r3, [sp, #0]
 801fa66:	69fb      	ldr	r3, [r7, #28]
 801fa68:	2200      	movs	r2, #0
 801fa6a:	2100      	movs	r1, #0
 801fa6c:	2001      	movs	r0, #1
 801fa6e:	f7ff ff5c 	bl	801f92a <wc_RNG_HealthTest_ex>
 801fa72:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                   seedA, sizeof(seedA_data),
                                   reseedSeedA, sizeof(reseedSeedA_data),
                                   check, RNG_HEALTH_TEST_CHECK_SIZE,
                                   heap, devId);
        if (ret == 0) {
 801fa74:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fa76:	2b00      	cmp	r3, #0
 801fa78:	d15b      	bne.n	801fb32 <wc_RNG_HealthTestLocal+0x11e>
            if (ConstantCompare(check, outputA,
 801fa7a:	2280      	movs	r2, #128	@ 0x80
 801fa7c:	6979      	ldr	r1, [r7, #20]
 801fa7e:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801fa80:	f7ff f96f 	bl	801ed62 <ConstantCompare>
 801fa84:	4603      	mov	r3, r0
 801fa86:	2b00      	cmp	r3, #0
 801fa88:	d053      	beq.n	801fb32 <wc_RNG_HealthTestLocal+0x11e>
                                RNG_HEALTH_TEST_CHECK_SIZE) != 0)
                ret = -1;
 801fa8a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801fa8e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801fa90:	e04f      	b.n	801fb32 <wc_RNG_HealthTestLocal+0x11e>
        }
        else {
            XMEMCPY_P(seedB, seedB_data, sizeof(seedB_data));
            XMEMCPY_P(outputB, outputB_data, sizeof(outputB_data));
#else
        const byte* seedB = seedB_data;
 801fa92:	4b31      	ldr	r3, [pc, #196]	@ (801fb58 <wc_RNG_HealthTestLocal+0x144>)
 801fa94:	627b      	str	r3, [r7, #36]	@ 0x24
        const byte* outputB = outputB_data;
 801fa96:	4b31      	ldr	r3, [pc, #196]	@ (801fb5c <wc_RNG_HealthTestLocal+0x148>)
 801fa98:	623b      	str	r3, [r7, #32]
        WOLFSSL_MSG_EX("RNG_HEALTH_TEST_CHECK_SIZE = %d",
                        RNG_HEALTH_TEST_CHECK_SIZE);
        WOLFSSL_MSG_EX("sizeof(seedB_data)         = %d",
                        (int)sizeof(outputB_data));
#endif
        ret = wc_RNG_HealthTest_ex(0, NULL, 0,
 801fa9a:	687b      	ldr	r3, [r7, #4]
 801fa9c:	9306      	str	r3, [sp, #24]
 801fa9e:	68bb      	ldr	r3, [r7, #8]
 801faa0:	9305      	str	r3, [sp, #20]
 801faa2:	2380      	movs	r3, #128	@ 0x80
 801faa4:	9304      	str	r3, [sp, #16]
 801faa6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801faa8:	9303      	str	r3, [sp, #12]
 801faaa:	2300      	movs	r3, #0
 801faac:	9302      	str	r3, [sp, #8]
 801faae:	2300      	movs	r3, #0
 801fab0:	9301      	str	r3, [sp, #4]
 801fab2:	2330      	movs	r3, #48	@ 0x30
 801fab4:	9300      	str	r3, [sp, #0]
 801fab6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fab8:	2200      	movs	r2, #0
 801faba:	2100      	movs	r1, #0
 801fabc:	2000      	movs	r0, #0
 801fabe:	f7ff ff34 	bl	801f92a <wc_RNG_HealthTest_ex>
 801fac2:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                   seedB, sizeof(seedB_data),
                                   NULL, 0,
                                   check, RNG_HEALTH_TEST_CHECK_SIZE,
                                   heap, devId);
        if (ret != 0) {
 801fac4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fac6:	2b00      	cmp	r3, #0
 801fac8:	d10b      	bne.n	801fae2 <wc_RNG_HealthTestLocal+0xce>
            #if defined(DEBUG_WOLFSSL)
            WOLFSSL_MSG_EX("RNG_HealthTest failed: err = %d", ret);
            #endif
        }
        else {
            ret = ConstantCompare(check, outputB,
 801faca:	2280      	movs	r2, #128	@ 0x80
 801facc:	6a39      	ldr	r1, [r7, #32]
 801face:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801fad0:	f7ff f947 	bl	801ed62 <ConstantCompare>
 801fad4:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                RNG_HEALTH_TEST_CHECK_SIZE);
            if (ret != 0) {
 801fad6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fad8:	2b00      	cmp	r3, #0
 801fada:	d002      	beq.n	801fae2 <wc_RNG_HealthTestLocal+0xce>
                #if defined(DEBUG_WOLFSSL)
                WOLFSSL_MSG_EX("Random ConstantCompare failed: err = %d", ret);
                #endif
                ret = -1;
 801fadc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801fae0:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* The previous test cases use a large seed instead of a seed and nonce.
         * seedB is actually from a test case with a seed and nonce, and
         * just concatenates them. The pivot point between seed and nonce is
         * byte 32, feed them into the health test separately. */
        if (ret == 0) {
 801fae2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fae4:	2b00      	cmp	r3, #0
 801fae6:	d124      	bne.n	801fb32 <wc_RNG_HealthTestLocal+0x11e>
            ret = wc_RNG_HealthTest_ex(0,
 801fae8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801faea:	f103 0120 	add.w	r1, r3, #32
 801faee:	687b      	ldr	r3, [r7, #4]
 801faf0:	9306      	str	r3, [sp, #24]
 801faf2:	68bb      	ldr	r3, [r7, #8]
 801faf4:	9305      	str	r3, [sp, #20]
 801faf6:	2380      	movs	r3, #128	@ 0x80
 801faf8:	9304      	str	r3, [sp, #16]
 801fafa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801fafc:	9303      	str	r3, [sp, #12]
 801fafe:	2300      	movs	r3, #0
 801fb00:	9302      	str	r3, [sp, #8]
 801fb02:	2300      	movs	r3, #0
 801fb04:	9301      	str	r3, [sp, #4]
 801fb06:	2320      	movs	r3, #32
 801fb08:	9300      	str	r3, [sp, #0]
 801fb0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fb0c:	2210      	movs	r2, #16
 801fb0e:	2000      	movs	r0, #0
 801fb10:	f7ff ff0b 	bl	801f92a <wc_RNG_HealthTest_ex>
 801fb14:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                       seedB + 32, sizeof(seedB_data) - 32,
                                       seedB, 32,
                                       NULL, 0,
                                       check, RNG_HEALTH_TEST_CHECK_SIZE,
                                       heap, devId);
            if (ret == 0) {
 801fb16:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fb18:	2b00      	cmp	r3, #0
 801fb1a:	d10a      	bne.n	801fb32 <wc_RNG_HealthTestLocal+0x11e>
                if (ConstantCompare(check, outputB, sizeof(outputB_data)) != 0)
 801fb1c:	2280      	movs	r2, #128	@ 0x80
 801fb1e:	6a39      	ldr	r1, [r7, #32]
 801fb20:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801fb22:	f7ff f91e 	bl	801ed62 <ConstantCompare>
 801fb26:	4603      	mov	r3, r0
 801fb28:	2b00      	cmp	r3, #0
 801fb2a:	d002      	beq.n	801fb32 <wc_RNG_HealthTestLocal+0x11e>
                    ret = -1;
 801fb2c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801fb30:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }
#endif
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(check, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 801fb32:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801fb34:	613b      	str	r3, [r7, #16]
 801fb36:	693b      	ldr	r3, [r7, #16]
 801fb38:	2b00      	cmp	r3, #0
 801fb3a:	d002      	beq.n	801fb42 <wc_RNG_HealthTestLocal+0x12e>
 801fb3c:	6938      	ldr	r0, [r7, #16]
 801fb3e:	f7ff f8b9 	bl	801ecb4 <wolfSSL_Free>
#endif

    return ret;
 801fb42:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
 801fb44:	4618      	mov	r0, r3
 801fb46:	3730      	adds	r7, #48	@ 0x30
 801fb48:	46bd      	mov	sp, r7
 801fb4a:	bd80      	pop	{r7, pc}
 801fb4c:	08034970 	.word	0x08034970
 801fb50:	080349a0 	.word	0x080349a0
 801fb54:	080349c0 	.word	0x080349c0
 801fb58:	08034a40 	.word	0x08034a40
 801fb5c:	08034a70 	.word	0x08034a70

0801fb60 <wc_GenerateSeed>:
     /* Generate a RNG seed using the hardware random number generator
      * on the STM32F2/F4/F7/L4. */

    #ifdef WOLFSSL_STM32_CUBEMX
    int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
    {
 801fb60:	b580      	push	{r7, lr}
 801fb62:	b08c      	sub	sp, #48	@ 0x30
 801fb64:	af00      	add	r7, sp, #0
 801fb66:	60f8      	str	r0, [r7, #12]
 801fb68:	60b9      	str	r1, [r7, #8]
 801fb6a:	607a      	str	r2, [r7, #4]
        int ret;
        RNG_HandleTypeDef hrng;
        word32 i = 0;
 801fb6c:	2300      	movs	r3, #0
 801fb6e:	62fb      	str	r3, [r7, #44]	@ 0x2c
        (void)os;

        ret = wolfSSL_CryptHwMutexLock();
 801fb70:	f007 fd80 	bl	8027674 <wolfSSL_CryptHwMutexLock>
 801fb74:	62b8      	str	r0, [r7, #40]	@ 0x28
        if (ret != 0) {
 801fb76:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801fb78:	2b00      	cmp	r3, #0
 801fb7a:	d001      	beq.n	801fb80 <wc_GenerateSeed+0x20>
            return ret;
 801fb7c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801fb7e:	e063      	b.n	801fc48 <wc_GenerateSeed+0xe8>
        }

        /* enable RNG clock source */
        __HAL_RCC_RNG_CLK_ENABLE();
 801fb80:	2300      	movs	r3, #0
 801fb82:	617b      	str	r3, [r7, #20]
 801fb84:	4b32      	ldr	r3, [pc, #200]	@ (801fc50 <wc_GenerateSeed+0xf0>)
 801fb86:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801fb88:	4a31      	ldr	r2, [pc, #196]	@ (801fc50 <wc_GenerateSeed+0xf0>)
 801fb8a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801fb8e:	6353      	str	r3, [r2, #52]	@ 0x34
 801fb90:	4b2f      	ldr	r3, [pc, #188]	@ (801fc50 <wc_GenerateSeed+0xf0>)
 801fb92:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801fb94:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801fb98:	617b      	str	r3, [r7, #20]
 801fb9a:	697b      	ldr	r3, [r7, #20]

        /* enable RNG peripheral */
        XMEMSET(&hrng, 0, sizeof(hrng));
 801fb9c:	f107 0318 	add.w	r3, r7, #24
 801fba0:	2210      	movs	r2, #16
 801fba2:	2100      	movs	r1, #0
 801fba4:	4618      	mov	r0, r3
 801fba6:	f009 f83d 	bl	8028c24 <memset>
        hrng.Instance = RNG;
 801fbaa:	4b2a      	ldr	r3, [pc, #168]	@ (801fc54 <wc_GenerateSeed+0xf4>)
 801fbac:	61bb      	str	r3, [r7, #24]
        HAL_RNG_Init(&hrng);
 801fbae:	f107 0318 	add.w	r3, r7, #24
 801fbb2:	4618      	mov	r0, r3
 801fbb4:	f7e5 fad6 	bl	8005164 <HAL_RNG_Init>

        while (i < sz) {
 801fbb8:	e03a      	b.n	801fc30 <wc_GenerateSeed+0xd0>
            /* If not aligned or there is odd/remainder */
            if( (i + sizeof(word32)) > sz ||
 801fbba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fbbc:	3304      	adds	r3, #4
 801fbbe:	687a      	ldr	r2, [r7, #4]
 801fbc0:	429a      	cmp	r2, r3
 801fbc2:	d306      	bcc.n	801fbd2 <wc_GenerateSeed+0x72>
                ((wc_ptr_t)&output[i] % sizeof(word32)) != 0
 801fbc4:	68ba      	ldr	r2, [r7, #8]
 801fbc6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fbc8:	4413      	add	r3, r2
 801fbca:	f003 0303 	and.w	r3, r3, #3
            if( (i + sizeof(word32)) > sz ||
 801fbce:	2b00      	cmp	r3, #0
 801fbd0:	d01a      	beq.n	801fc08 <wc_GenerateSeed+0xa8>
            ) {
                /* Single byte at a time */
                uint32_t tmpRng = 0;
 801fbd2:	2300      	movs	r3, #0
 801fbd4:	613b      	str	r3, [r7, #16]
                if (HAL_RNG_GenerateRandomNumber(&hrng, &tmpRng) != HAL_OK) {
 801fbd6:	f107 0210 	add.w	r2, r7, #16
 801fbda:	f107 0318 	add.w	r3, r7, #24
 801fbde:	4611      	mov	r1, r2
 801fbe0:	4618      	mov	r0, r3
 801fbe2:	f7e5 fb13 	bl	800520c <HAL_RNG_GenerateRandomNumber>
 801fbe6:	4603      	mov	r3, r0
 801fbe8:	2b00      	cmp	r3, #0
 801fbea:	d004      	beq.n	801fbf6 <wc_GenerateSeed+0x96>
                    wolfSSL_CryptHwMutexUnLock();
 801fbec:	f007 fd56 	bl	802769c <wolfSSL_CryptHwMutexUnLock>
                    return RAN_BLOCK_E;
 801fbf0:	f06f 0368 	mvn.w	r3, #104	@ 0x68
 801fbf4:	e028      	b.n	801fc48 <wc_GenerateSeed+0xe8>
                }
                output[i++] = (byte)tmpRng;
 801fbf6:	6939      	ldr	r1, [r7, #16]
 801fbf8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fbfa:	1c5a      	adds	r2, r3, #1
 801fbfc:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801fbfe:	68ba      	ldr	r2, [r7, #8]
 801fc00:	4413      	add	r3, r2
 801fc02:	b2ca      	uxtb	r2, r1
 801fc04:	701a      	strb	r2, [r3, #0]
            ) {
 801fc06:	e013      	b.n	801fc30 <wc_GenerateSeed+0xd0>
            }
            else {
                /* Use native 32 instruction */
                if (HAL_RNG_GenerateRandomNumber(&hrng, (uint32_t*)&output[i]) != HAL_OK) {
 801fc08:	68ba      	ldr	r2, [r7, #8]
 801fc0a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fc0c:	441a      	add	r2, r3
 801fc0e:	f107 0318 	add.w	r3, r7, #24
 801fc12:	4611      	mov	r1, r2
 801fc14:	4618      	mov	r0, r3
 801fc16:	f7e5 faf9 	bl	800520c <HAL_RNG_GenerateRandomNumber>
 801fc1a:	4603      	mov	r3, r0
 801fc1c:	2b00      	cmp	r3, #0
 801fc1e:	d004      	beq.n	801fc2a <wc_GenerateSeed+0xca>
                    wolfSSL_CryptHwMutexUnLock();
 801fc20:	f007 fd3c 	bl	802769c <wolfSSL_CryptHwMutexUnLock>
                    return RAN_BLOCK_E;
 801fc24:	f06f 0368 	mvn.w	r3, #104	@ 0x68
 801fc28:	e00e      	b.n	801fc48 <wc_GenerateSeed+0xe8>
                }
                i += sizeof(word32);
 801fc2a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fc2c:	3304      	adds	r3, #4
 801fc2e:	62fb      	str	r3, [r7, #44]	@ 0x2c
        while (i < sz) {
 801fc30:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801fc32:	687b      	ldr	r3, [r7, #4]
 801fc34:	429a      	cmp	r2, r3
 801fc36:	d3c0      	bcc.n	801fbba <wc_GenerateSeed+0x5a>
            }
        }

        HAL_RNG_DeInit(&hrng);
 801fc38:	f107 0318 	add.w	r3, r7, #24
 801fc3c:	4618      	mov	r0, r3
 801fc3e:	f7e5 fabb 	bl	80051b8 <HAL_RNG_DeInit>

        wolfSSL_CryptHwMutexUnLock();
 801fc42:	f007 fd2b 	bl	802769c <wolfSSL_CryptHwMutexUnLock>

        return 0;
 801fc46:	2300      	movs	r3, #0
    }
 801fc48:	4618      	mov	r0, r3
 801fc4a:	3730      	adds	r7, #48	@ 0x30
 801fc4c:	46bd      	mov	sp, r7
 801fc4e:	bd80      	pop	{r7, pc}
 801fc50:	40023800 	.word	0x40023800
 801fc54:	50060800 	.word	0x50060800

0801fc58 <XorWords>:
{
 801fc58:	b480      	push	{r7}
 801fc5a:	b087      	sub	sp, #28
 801fc5c:	af00      	add	r7, sp, #0
 801fc5e:	60f8      	str	r0, [r7, #12]
 801fc60:	60b9      	str	r1, [r7, #8]
 801fc62:	607a      	str	r2, [r7, #4]
    for (i = 0; i < n; i++)
 801fc64:	2300      	movs	r3, #0
 801fc66:	617b      	str	r3, [r7, #20]
 801fc68:	e010      	b.n	801fc8c <XorWords+0x34>
        *((*r)++) ^= *((*a)++);
 801fc6a:	68bb      	ldr	r3, [r7, #8]
 801fc6c:	681b      	ldr	r3, [r3, #0]
 801fc6e:	1d19      	adds	r1, r3, #4
 801fc70:	68ba      	ldr	r2, [r7, #8]
 801fc72:	6011      	str	r1, [r2, #0]
 801fc74:	6819      	ldr	r1, [r3, #0]
 801fc76:	68fb      	ldr	r3, [r7, #12]
 801fc78:	681b      	ldr	r3, [r3, #0]
 801fc7a:	1d18      	adds	r0, r3, #4
 801fc7c:	68fa      	ldr	r2, [r7, #12]
 801fc7e:	6010      	str	r0, [r2, #0]
 801fc80:	681a      	ldr	r2, [r3, #0]
 801fc82:	404a      	eors	r2, r1
 801fc84:	601a      	str	r2, [r3, #0]
    for (i = 0; i < n; i++)
 801fc86:	697b      	ldr	r3, [r7, #20]
 801fc88:	3301      	adds	r3, #1
 801fc8a:	617b      	str	r3, [r7, #20]
 801fc8c:	697a      	ldr	r2, [r7, #20]
 801fc8e:	687b      	ldr	r3, [r7, #4]
 801fc90:	429a      	cmp	r2, r3
 801fc92:	d3ea      	bcc.n	801fc6a <XorWords+0x12>
}
 801fc94:	bf00      	nop
 801fc96:	bf00      	nop
 801fc98:	371c      	adds	r7, #28
 801fc9a:	46bd      	mov	sp, r7
 801fc9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fca0:	4770      	bx	lr

0801fca2 <xorbuf>:
{
 801fca2:	b580      	push	{r7, lr}
 801fca4:	b08a      	sub	sp, #40	@ 0x28
 801fca6:	af00      	add	r7, sp, #0
 801fca8:	60f8      	str	r0, [r7, #12]
 801fcaa:	60b9      	str	r1, [r7, #8]
 801fcac:	607a      	str	r2, [r7, #4]
    b = (byte*)buf;
 801fcae:	68fb      	ldr	r3, [r7, #12]
 801fcb0:	623b      	str	r3, [r7, #32]
    m = (const byte*)mask;
 801fcb2:	68bb      	ldr	r3, [r7, #8]
 801fcb4:	61fb      	str	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 801fcb6:	6a3a      	ldr	r2, [r7, #32]
            ((wc_ptr_t)m) % WOLFSSL_WORD_SIZE) {
 801fcb8:	69fb      	ldr	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 801fcba:	4053      	eors	r3, r2
 801fcbc:	f003 0303 	and.w	r3, r3, #3
 801fcc0:	2b00      	cmp	r3, #0
 801fcc2:	d12b      	bne.n	801fd1c <xorbuf+0x7a>
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 801fcc4:	e00d      	b.n	801fce2 <xorbuf+0x40>
            *(b++) ^= *(m++);
 801fcc6:	69fb      	ldr	r3, [r7, #28]
 801fcc8:	1c5a      	adds	r2, r3, #1
 801fcca:	61fa      	str	r2, [r7, #28]
 801fccc:	7819      	ldrb	r1, [r3, #0]
 801fcce:	6a3b      	ldr	r3, [r7, #32]
 801fcd0:	1c5a      	adds	r2, r3, #1
 801fcd2:	623a      	str	r2, [r7, #32]
 801fcd4:	781a      	ldrb	r2, [r3, #0]
 801fcd6:	404a      	eors	r2, r1
 801fcd8:	b2d2      	uxtb	r2, r2
 801fcda:	701a      	strb	r2, [r3, #0]
            count--;
 801fcdc:	687b      	ldr	r3, [r7, #4]
 801fcde:	3b01      	subs	r3, #1
 801fce0:	607b      	str	r3, [r7, #4]
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 801fce2:	68fb      	ldr	r3, [r7, #12]
 801fce4:	f003 0303 	and.w	r3, r3, #3
 801fce8:	2b00      	cmp	r3, #0
 801fcea:	d002      	beq.n	801fcf2 <xorbuf+0x50>
 801fcec:	687b      	ldr	r3, [r7, #4]
 801fcee:	2b00      	cmp	r3, #0
 801fcf0:	d1e9      	bne.n	801fcc6 <xorbuf+0x24>
        tpb.bp = b;
 801fcf2:	6a3b      	ldr	r3, [r7, #32]
 801fcf4:	61bb      	str	r3, [r7, #24]
        tpm.bp = m;
 801fcf6:	69fb      	ldr	r3, [r7, #28]
 801fcf8:	617b      	str	r3, [r7, #20]
        XorWords( &tpb.wp, &tpm.wp, count / WOLFSSL_WORD_SIZE);
 801fcfa:	687b      	ldr	r3, [r7, #4]
 801fcfc:	089a      	lsrs	r2, r3, #2
 801fcfe:	f107 0114 	add.w	r1, r7, #20
 801fd02:	f107 0318 	add.w	r3, r7, #24
 801fd06:	4618      	mov	r0, r3
 801fd08:	f7ff ffa6 	bl	801fc58 <XorWords>
        b = tpb.bp;
 801fd0c:	69bb      	ldr	r3, [r7, #24]
 801fd0e:	623b      	str	r3, [r7, #32]
        m = tpm.bp;
 801fd10:	697b      	ldr	r3, [r7, #20]
 801fd12:	61fb      	str	r3, [r7, #28]
        count %= WOLFSSL_WORD_SIZE;
 801fd14:	687b      	ldr	r3, [r7, #4]
 801fd16:	f003 0303 	and.w	r3, r3, #3
 801fd1a:	607b      	str	r3, [r7, #4]
    for (i = 0; i < count; i++)
 801fd1c:	2300      	movs	r3, #0
 801fd1e:	627b      	str	r3, [r7, #36]	@ 0x24
 801fd20:	e010      	b.n	801fd44 <xorbuf+0xa2>
        b[i] ^= m[i];
 801fd22:	6a3a      	ldr	r2, [r7, #32]
 801fd24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fd26:	4413      	add	r3, r2
 801fd28:	7819      	ldrb	r1, [r3, #0]
 801fd2a:	69fa      	ldr	r2, [r7, #28]
 801fd2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fd2e:	4413      	add	r3, r2
 801fd30:	781a      	ldrb	r2, [r3, #0]
 801fd32:	6a38      	ldr	r0, [r7, #32]
 801fd34:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fd36:	4403      	add	r3, r0
 801fd38:	404a      	eors	r2, r1
 801fd3a:	b2d2      	uxtb	r2, r2
 801fd3c:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < count; i++)
 801fd3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fd40:	3301      	adds	r3, #1
 801fd42:	627b      	str	r3, [r7, #36]	@ 0x24
 801fd44:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801fd46:	687b      	ldr	r3, [r7, #4]
 801fd48:	429a      	cmp	r2, r3
 801fd4a:	d3ea      	bcc.n	801fd22 <xorbuf+0x80>
}
 801fd4c:	bf00      	nop
 801fd4e:	bf00      	nop
 801fd50:	3728      	adds	r7, #40	@ 0x28
 801fd52:	46bd      	mov	sp, r7
 801fd54:	bd80      	pop	{r7, pc}

0801fd56 <ForceZero>:
{
 801fd56:	b480      	push	{r7}
 801fd58:	b085      	sub	sp, #20
 801fd5a:	af00      	add	r7, sp, #0
 801fd5c:	6078      	str	r0, [r7, #4]
 801fd5e:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801fd60:	687b      	ldr	r3, [r7, #4]
 801fd62:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801fd64:	e004      	b.n	801fd70 <ForceZero+0x1a>
 801fd66:	68fb      	ldr	r3, [r7, #12]
 801fd68:	1c5a      	adds	r2, r3, #1
 801fd6a:	60fa      	str	r2, [r7, #12]
 801fd6c:	2200      	movs	r2, #0
 801fd6e:	701a      	strb	r2, [r3, #0]
 801fd70:	683b      	ldr	r3, [r7, #0]
 801fd72:	1e5a      	subs	r2, r3, #1
 801fd74:	603a      	str	r2, [r7, #0]
 801fd76:	2b00      	cmp	r3, #0
 801fd78:	d1f5      	bne.n	801fd66 <ForceZero+0x10>
}
 801fd7a:	bf00      	nop
 801fd7c:	bf00      	nop
 801fd7e:	3714      	adds	r7, #20
 801fd80:	46bd      	mov	sp, r7
 801fd82:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fd86:	4770      	bx	lr

0801fd88 <ConstantCompare>:
{
 801fd88:	b480      	push	{r7}
 801fd8a:	b087      	sub	sp, #28
 801fd8c:	af00      	add	r7, sp, #0
 801fd8e:	60f8      	str	r0, [r7, #12]
 801fd90:	60b9      	str	r1, [r7, #8]
 801fd92:	607a      	str	r2, [r7, #4]
    int compareSum = 0;
 801fd94:	2300      	movs	r3, #0
 801fd96:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801fd98:	2300      	movs	r3, #0
 801fd9a:	617b      	str	r3, [r7, #20]
 801fd9c:	e010      	b.n	801fdc0 <ConstantCompare+0x38>
        compareSum |= a[i] ^ b[i];
 801fd9e:	697b      	ldr	r3, [r7, #20]
 801fda0:	68fa      	ldr	r2, [r7, #12]
 801fda2:	4413      	add	r3, r2
 801fda4:	781a      	ldrb	r2, [r3, #0]
 801fda6:	697b      	ldr	r3, [r7, #20]
 801fda8:	68b9      	ldr	r1, [r7, #8]
 801fdaa:	440b      	add	r3, r1
 801fdac:	781b      	ldrb	r3, [r3, #0]
 801fdae:	4053      	eors	r3, r2
 801fdb0:	b2db      	uxtb	r3, r3
 801fdb2:	461a      	mov	r2, r3
 801fdb4:	693b      	ldr	r3, [r7, #16]
 801fdb6:	4313      	orrs	r3, r2
 801fdb8:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801fdba:	697b      	ldr	r3, [r7, #20]
 801fdbc:	3301      	adds	r3, #1
 801fdbe:	617b      	str	r3, [r7, #20]
 801fdc0:	697a      	ldr	r2, [r7, #20]
 801fdc2:	687b      	ldr	r3, [r7, #4]
 801fdc4:	429a      	cmp	r2, r3
 801fdc6:	dbea      	blt.n	801fd9e <ConstantCompare+0x16>
    return compareSum;
 801fdc8:	693b      	ldr	r3, [r7, #16]
}
 801fdca:	4618      	mov	r0, r3
 801fdcc:	371c      	adds	r7, #28
 801fdce:	46bd      	mov	sp, r7
 801fdd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fdd4:	4770      	bx	lr

0801fdd6 <ctMaskGT>:
{
 801fdd6:	b480      	push	{r7}
 801fdd8:	b083      	sub	sp, #12
 801fdda:	af00      	add	r7, sp, #0
 801fddc:	6078      	str	r0, [r7, #4]
 801fdde:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)a - (word32)b - 1) >> 31) - 1);
 801fde0:	687a      	ldr	r2, [r7, #4]
 801fde2:	683b      	ldr	r3, [r7, #0]
 801fde4:	1ad3      	subs	r3, r2, r3
 801fde6:	3b01      	subs	r3, #1
 801fde8:	0fdb      	lsrs	r3, r3, #31
 801fdea:	b2db      	uxtb	r3, r3
 801fdec:	3b01      	subs	r3, #1
 801fdee:	b2db      	uxtb	r3, r3
}
 801fdf0:	4618      	mov	r0, r3
 801fdf2:	370c      	adds	r7, #12
 801fdf4:	46bd      	mov	sp, r7
 801fdf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fdfa:	4770      	bx	lr

0801fdfc <ctMaskGTE>:
{
 801fdfc:	b480      	push	{r7}
 801fdfe:	b083      	sub	sp, #12
 801fe00:	af00      	add	r7, sp, #0
 801fe02:	6078      	str	r0, [r7, #4]
 801fe04:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)a - (word32)b) >> 31) - 1);
 801fe06:	687a      	ldr	r2, [r7, #4]
 801fe08:	683b      	ldr	r3, [r7, #0]
 801fe0a:	1ad3      	subs	r3, r2, r3
 801fe0c:	0fdb      	lsrs	r3, r3, #31
 801fe0e:	b2db      	uxtb	r3, r3
 801fe10:	3b01      	subs	r3, #1
 801fe12:	b2db      	uxtb	r3, r3
}
 801fe14:	4618      	mov	r0, r3
 801fe16:	370c      	adds	r7, #12
 801fe18:	46bd      	mov	sp, r7
 801fe1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fe1e:	4770      	bx	lr

0801fe20 <ctMaskLT>:
{
 801fe20:	b480      	push	{r7}
 801fe22:	b083      	sub	sp, #12
 801fe24:	af00      	add	r7, sp, #0
 801fe26:	6078      	str	r0, [r7, #4]
 801fe28:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)b - (word32)a - 1) >> 31) - 1);
 801fe2a:	683a      	ldr	r2, [r7, #0]
 801fe2c:	687b      	ldr	r3, [r7, #4]
 801fe2e:	1ad3      	subs	r3, r2, r3
 801fe30:	3b01      	subs	r3, #1
 801fe32:	0fdb      	lsrs	r3, r3, #31
 801fe34:	b2db      	uxtb	r3, r3
 801fe36:	3b01      	subs	r3, #1
 801fe38:	b2db      	uxtb	r3, r3
}
 801fe3a:	4618      	mov	r0, r3
 801fe3c:	370c      	adds	r7, #12
 801fe3e:	46bd      	mov	sp, r7
 801fe40:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fe44:	4770      	bx	lr

0801fe46 <ctMaskLTE>:
{
 801fe46:	b480      	push	{r7}
 801fe48:	b083      	sub	sp, #12
 801fe4a:	af00      	add	r7, sp, #0
 801fe4c:	6078      	str	r0, [r7, #4]
 801fe4e:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)b - (word32)a) >> 31) - 1);
 801fe50:	683a      	ldr	r2, [r7, #0]
 801fe52:	687b      	ldr	r3, [r7, #4]
 801fe54:	1ad3      	subs	r3, r2, r3
 801fe56:	0fdb      	lsrs	r3, r3, #31
 801fe58:	b2db      	uxtb	r3, r3
 801fe5a:	3b01      	subs	r3, #1
 801fe5c:	b2db      	uxtb	r3, r3
}
 801fe5e:	4618      	mov	r0, r3
 801fe60:	370c      	adds	r7, #12
 801fe62:	46bd      	mov	sp, r7
 801fe64:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fe68:	4770      	bx	lr

0801fe6a <ctMaskEq>:
{
 801fe6a:	b590      	push	{r4, r7, lr}
 801fe6c:	b083      	sub	sp, #12
 801fe6e:	af00      	add	r7, sp, #0
 801fe70:	6078      	str	r0, [r7, #4]
 801fe72:	6039      	str	r1, [r7, #0]
    return (byte)((byte)(~ctMaskGT(a, b)) & (byte)(~ctMaskLT(a, b)));
 801fe74:	6839      	ldr	r1, [r7, #0]
 801fe76:	6878      	ldr	r0, [r7, #4]
 801fe78:	f7ff ffad 	bl	801fdd6 <ctMaskGT>
 801fe7c:	4603      	mov	r3, r0
 801fe7e:	461c      	mov	r4, r3
 801fe80:	6839      	ldr	r1, [r7, #0]
 801fe82:	6878      	ldr	r0, [r7, #4]
 801fe84:	f7ff ffcc 	bl	801fe20 <ctMaskLT>
 801fe88:	4603      	mov	r3, r0
 801fe8a:	4323      	orrs	r3, r4
 801fe8c:	b2db      	uxtb	r3, r3
 801fe8e:	43db      	mvns	r3, r3
 801fe90:	b2db      	uxtb	r3, r3
}
 801fe92:	4618      	mov	r0, r3
 801fe94:	370c      	adds	r7, #12
 801fe96:	46bd      	mov	sp, r7
 801fe98:	bd90      	pop	{r4, r7, pc}

0801fe9a <ctMask16GT>:
{
 801fe9a:	b480      	push	{r7}
 801fe9c:	b083      	sub	sp, #12
 801fe9e:	af00      	add	r7, sp, #0
 801fea0:	6078      	str	r0, [r7, #4]
 801fea2:	6039      	str	r1, [r7, #0]
    return (word16)((((word32)a - (word32)b - 1) >> 31) - 1);
 801fea4:	687a      	ldr	r2, [r7, #4]
 801fea6:	683b      	ldr	r3, [r7, #0]
 801fea8:	1ad3      	subs	r3, r2, r3
 801feaa:	3b01      	subs	r3, #1
 801feac:	0fdb      	lsrs	r3, r3, #31
 801feae:	b29b      	uxth	r3, r3
 801feb0:	3b01      	subs	r3, #1
 801feb2:	b29b      	uxth	r3, r3
}
 801feb4:	4618      	mov	r0, r3
 801feb6:	370c      	adds	r7, #12
 801feb8:	46bd      	mov	sp, r7
 801feba:	f85d 7b04 	ldr.w	r7, [sp], #4
 801febe:	4770      	bx	lr

0801fec0 <ctMask16LT>:
{
 801fec0:	b480      	push	{r7}
 801fec2:	b083      	sub	sp, #12
 801fec4:	af00      	add	r7, sp, #0
 801fec6:	6078      	str	r0, [r7, #4]
 801fec8:	6039      	str	r1, [r7, #0]
    return (word16)((((word32)b - (word32)a - 1) >> 31) - 1);
 801feca:	683a      	ldr	r2, [r7, #0]
 801fecc:	687b      	ldr	r3, [r7, #4]
 801fece:	1ad3      	subs	r3, r2, r3
 801fed0:	3b01      	subs	r3, #1
 801fed2:	0fdb      	lsrs	r3, r3, #31
 801fed4:	b29b      	uxth	r3, r3
 801fed6:	3b01      	subs	r3, #1
 801fed8:	b29b      	uxth	r3, r3
}
 801feda:	4618      	mov	r0, r3
 801fedc:	370c      	adds	r7, #12
 801fede:	46bd      	mov	sp, r7
 801fee0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fee4:	4770      	bx	lr

0801fee6 <ctMask16Eq>:
{
 801fee6:	b590      	push	{r4, r7, lr}
 801fee8:	b083      	sub	sp, #12
 801feea:	af00      	add	r7, sp, #0
 801feec:	6078      	str	r0, [r7, #4]
 801feee:	6039      	str	r1, [r7, #0]
    return (word16)((word16)(~ctMask16GT(a, b)) & (word16)(~ctMask16LT(a, b)));
 801fef0:	6839      	ldr	r1, [r7, #0]
 801fef2:	6878      	ldr	r0, [r7, #4]
 801fef4:	f7ff ffd1 	bl	801fe9a <ctMask16GT>
 801fef8:	4603      	mov	r3, r0
 801fefa:	461c      	mov	r4, r3
 801fefc:	6839      	ldr	r1, [r7, #0]
 801fefe:	6878      	ldr	r0, [r7, #4]
 801ff00:	f7ff ffde 	bl	801fec0 <ctMask16LT>
 801ff04:	4603      	mov	r3, r0
 801ff06:	4323      	orrs	r3, r4
 801ff08:	b29b      	uxth	r3, r3
 801ff0a:	43db      	mvns	r3, r3
 801ff0c:	b29b      	uxth	r3, r3
}
 801ff0e:	4618      	mov	r0, r3
 801ff10:	370c      	adds	r7, #12
 801ff12:	46bd      	mov	sp, r7
 801ff14:	bd90      	pop	{r4, r7, pc}

0801ff16 <ctMaskNotEq>:
{
 801ff16:	b590      	push	{r4, r7, lr}
 801ff18:	b083      	sub	sp, #12
 801ff1a:	af00      	add	r7, sp, #0
 801ff1c:	6078      	str	r0, [r7, #4]
 801ff1e:	6039      	str	r1, [r7, #0]
    return (byte)((byte)ctMaskGT(a, b) | (byte)ctMaskLT(a, b));
 801ff20:	6839      	ldr	r1, [r7, #0]
 801ff22:	6878      	ldr	r0, [r7, #4]
 801ff24:	f7ff ff57 	bl	801fdd6 <ctMaskGT>
 801ff28:	4603      	mov	r3, r0
 801ff2a:	461c      	mov	r4, r3
 801ff2c:	6839      	ldr	r1, [r7, #0]
 801ff2e:	6878      	ldr	r0, [r7, #4]
 801ff30:	f7ff ff76 	bl	801fe20 <ctMaskLT>
 801ff34:	4603      	mov	r3, r0
 801ff36:	4323      	orrs	r3, r4
 801ff38:	b2db      	uxtb	r3, r3
}
 801ff3a:	4618      	mov	r0, r3
 801ff3c:	370c      	adds	r7, #12
 801ff3e:	46bd      	mov	sp, r7
 801ff40:	bd90      	pop	{r4, r7, pc}

0801ff42 <ctMaskSelInt>:
{
 801ff42:	b480      	push	{r7}
 801ff44:	b085      	sub	sp, #20
 801ff46:	af00      	add	r7, sp, #0
 801ff48:	4603      	mov	r3, r0
 801ff4a:	60b9      	str	r1, [r7, #8]
 801ff4c:	607a      	str	r2, [r7, #4]
 801ff4e:	73fb      	strb	r3, [r7, #15]
    return (b & (~(signed int)(signed char)m)) |
 801ff50:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801ff54:	43da      	mvns	r2, r3
 801ff56:	687b      	ldr	r3, [r7, #4]
 801ff58:	401a      	ands	r2, r3
           (a & ( (signed int)(signed char)m));
 801ff5a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801ff5e:	4619      	mov	r1, r3
 801ff60:	68bb      	ldr	r3, [r7, #8]
 801ff62:	400b      	ands	r3, r1
    return (b & (~(signed int)(signed char)m)) |
 801ff64:	4313      	orrs	r3, r2
}
 801ff66:	4618      	mov	r0, r3
 801ff68:	3714      	adds	r7, #20
 801ff6a:	46bd      	mov	sp, r7
 801ff6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ff70:	4770      	bx	lr

0801ff72 <ctMaskSelWord32>:
{
 801ff72:	b480      	push	{r7}
 801ff74:	b085      	sub	sp, #20
 801ff76:	af00      	add	r7, sp, #0
 801ff78:	4603      	mov	r3, r0
 801ff7a:	60b9      	str	r1, [r7, #8]
 801ff7c:	607a      	str	r2, [r7, #4]
 801ff7e:	73fb      	strb	r3, [r7, #15]
    return (((word32)b & (word32)(~(signed int)(signed char)m)) |
 801ff80:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801ff84:	43db      	mvns	r3, r3
 801ff86:	461a      	mov	r2, r3
 801ff88:	687b      	ldr	r3, [r7, #4]
 801ff8a:	401a      	ands	r2, r3
            ((word32)a & (word32)( (signed int)(signed char)m)));
 801ff8c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801ff90:	4619      	mov	r1, r3
 801ff92:	68bb      	ldr	r3, [r7, #8]
 801ff94:	400b      	ands	r3, r1
    return (((word32)b & (word32)(~(signed int)(signed char)m)) |
 801ff96:	4313      	orrs	r3, r2
}
 801ff98:	4618      	mov	r0, r3
 801ff9a:	3714      	adds	r7, #20
 801ff9c:	46bd      	mov	sp, r7
 801ff9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ffa2:	4770      	bx	lr

0801ffa4 <wc_RsaCleanup>:
    RSA_STATE_DECRYPT_UNPAD,
    RSA_STATE_DECRYPT_RES
};

static void wc_RsaCleanup(RsaKey* key)
{
 801ffa4:	b580      	push	{r7, lr}
 801ffa6:	b084      	sub	sp, #16
 801ffa8:	af00      	add	r7, sp, #0
 801ffaa:	6078      	str	r0, [r7, #4]
#if !defined(WOLFSSL_NO_MALLOC) && (defined(WOLFSSL_ASYNC_CRYPT) || \
    (!defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)))
    if (key != NULL) {
 801ffac:	687b      	ldr	r3, [r7, #4]
 801ffae:	2b00      	cmp	r3, #0
 801ffb0:	d050      	beq.n	8020054 <wc_RsaCleanup+0xb0>
    #ifndef WOLFSSL_RSA_PUBLIC_ONLY
        /* if private operation zero temp buffer */
        if ((key->data != NULL && key->dataLen > 0) &&
 801ffb2:	687b      	ldr	r3, [r7, #4]
 801ffb4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801ffb8:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 801ffbc:	2b00      	cmp	r3, #0
 801ffbe:	d022      	beq.n	8020006 <wc_RsaCleanup+0x62>
 801ffc0:	687b      	ldr	r3, [r7, #4]
 801ffc2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801ffc6:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 801ffca:	2b00      	cmp	r3, #0
 801ffcc:	d01b      	beq.n	8020006 <wc_RsaCleanup+0x62>
            (key->type == RSA_PRIVATE_DECRYPT ||
 801ffce:	687b      	ldr	r3, [r7, #4]
 801ffd0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801ffd4:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
        if ((key->data != NULL && key->dataLen > 0) &&
 801ffd8:	2b03      	cmp	r3, #3
 801ffda:	d006      	beq.n	801ffea <wc_RsaCleanup+0x46>
             key->type == RSA_PRIVATE_ENCRYPT)) {
 801ffdc:	687b      	ldr	r3, [r7, #4]
 801ffde:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801ffe2:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
            (key->type == RSA_PRIVATE_DECRYPT ||
 801ffe6:	2b02      	cmp	r3, #2
 801ffe8:	d10d      	bne.n	8020006 <wc_RsaCleanup+0x62>
            ForceZero(key->data, key->dataLen);
 801ffea:	687b      	ldr	r3, [r7, #4]
 801ffec:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fff0:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
 801fff4:	687b      	ldr	r3, [r7, #4]
 801fff6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fffa:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 801fffe:	4619      	mov	r1, r3
 8020000:	4610      	mov	r0, r2
 8020002:	f7ff fea8 	bl	801fd56 <ForceZero>
        }
    #endif
        /* make sure any allocated memory is free'd */
        if (key->dataIsAlloc) {
 8020006:	687b      	ldr	r3, [r7, #4]
 8020008:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802000c:	f893 3178 	ldrb.w	r3, [r3, #376]	@ 0x178
 8020010:	2b00      	cmp	r3, #0
 8020012:	d011      	beq.n	8020038 <wc_RsaCleanup+0x94>
            XFREE(key->data, key->heap, DYNAMIC_TYPE_WOLF_BIGINT);
 8020014:	687b      	ldr	r3, [r7, #4]
 8020016:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802001a:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 802001e:	60fb      	str	r3, [r7, #12]
 8020020:	68fb      	ldr	r3, [r7, #12]
 8020022:	2b00      	cmp	r3, #0
 8020024:	d002      	beq.n	802002c <wc_RsaCleanup+0x88>
 8020026:	68f8      	ldr	r0, [r7, #12]
 8020028:	f7fe fe44 	bl	801ecb4 <wolfSSL_Free>
            key->dataIsAlloc = 0;
 802002c:	687b      	ldr	r3, [r7, #4]
 802002e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020032:	2200      	movs	r2, #0
 8020034:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
        }

        key->data = NULL;
 8020038:	687b      	ldr	r3, [r7, #4]
 802003a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802003e:	461a      	mov	r2, r3
 8020040:	2300      	movs	r3, #0
 8020042:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
        key->dataLen = 0;
 8020046:	687b      	ldr	r3, [r7, #4]
 8020048:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802004c:	461a      	mov	r2, r3
 802004e:	2300      	movs	r3, #0
 8020050:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170
    }
#else
    (void)key;
#endif
}
 8020054:	bf00      	nop
 8020056:	3710      	adds	r7, #16
 8020058:	46bd      	mov	sp, r7
 802005a:	bd80      	pop	{r7, pc}

0802005c <wc_InitRsaKey_ex>:
    return 0;
}
#endif /* !WC_NO_CONSTRUCTORS */

int wc_InitRsaKey_ex(RsaKey* key, void* heap, int devId)
{
 802005c:	b5b0      	push	{r4, r5, r7, lr}
 802005e:	b088      	sub	sp, #32
 8020060:	af02      	add	r7, sp, #8
 8020062:	60f8      	str	r0, [r7, #12]
 8020064:	60b9      	str	r1, [r7, #8]
 8020066:	607a      	str	r2, [r7, #4]
    int ret = 0;
 8020068:	2300      	movs	r3, #0
 802006a:	617b      	str	r3, [r7, #20]

    if (key == NULL) {
 802006c:	68fb      	ldr	r3, [r7, #12]
 802006e:	2b00      	cmp	r3, #0
 8020070:	d102      	bne.n	8020078 <wc_InitRsaKey_ex+0x1c>
        return BAD_FUNC_ARG;
 8020072:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020076:	e071      	b.n	802015c <wc_InitRsaKey_ex+0x100>
    }

    XMEMSET(key, 0, sizeof(RsaKey));
 8020078:	f241 127c 	movw	r2, #4476	@ 0x117c
 802007c:	2100      	movs	r1, #0
 802007e:	68f8      	ldr	r0, [r7, #12]
 8020080:	f008 fdd0 	bl	8028c24 <memset>

    key->type = RSA_TYPE_UNKNOWN;
 8020084:	68fb      	ldr	r3, [r7, #12]
 8020086:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802008a:	461a      	mov	r2, r3
 802008c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8020090:	f8c2 3168 	str.w	r3, [r2, #360]	@ 0x168
    key->state = RSA_STATE_NONE;
 8020094:	68fb      	ldr	r3, [r7, #12]
 8020096:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802009a:	461a      	mov	r2, r3
 802009c:	2300      	movs	r3, #0
 802009e:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
    key->heap = heap;
 80200a2:	68fb      	ldr	r3, [r7, #12]
 80200a4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80200a8:	461a      	mov	r2, r3
 80200aa:	68bb      	ldr	r3, [r7, #8]
 80200ac:	f8c2 3160 	str.w	r3, [r2, #352]	@ 0x160
#if !defined(WOLFSSL_NO_MALLOC) && (defined(WOLFSSL_ASYNC_CRYPT) || \
    (!defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)))
    key->dataIsAlloc = 0;
 80200b0:	68fb      	ldr	r3, [r7, #12]
 80200b2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80200b6:	2200      	movs	r2, #0
 80200b8:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
#endif
    key->data = NULL;
 80200bc:	68fb      	ldr	r3, [r7, #12]
 80200be:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80200c2:	461a      	mov	r2, r3
 80200c4:	2300      	movs	r3, #0
 80200c6:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
    key->dataLen = 0;
 80200ca:	68fb      	ldr	r3, [r7, #12]
 80200cc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80200d0:	461a      	mov	r2, r3
 80200d2:	2300      	movs	r3, #0
 80200d4:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170
#ifdef WC_RSA_BLINDING
    key->rng = NULL;
 80200d8:	68fb      	ldr	r3, [r7, #12]
 80200da:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80200de:	461a      	mov	r2, r3
 80200e0:	2300      	movs	r3, #0
 80200e2:	f8c2 3174 	str.w	r3, [r2, #372]	@ 0x174
        }
    #endif /* WC_ASYNC_ENABLE_RSA */
#endif /* WOLFSSL_ASYNC_CRYPT */

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
    ret = mp_init_multi(&key->n, &key->e, NULL, NULL, NULL, NULL);
 80200e6:	68f8      	ldr	r0, [r7, #12]
 80200e8:	68fb      	ldr	r3, [r7, #12]
 80200ea:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 80200ee:	2300      	movs	r3, #0
 80200f0:	9301      	str	r3, [sp, #4]
 80200f2:	2300      	movs	r3, #0
 80200f4:	9300      	str	r3, [sp, #0]
 80200f6:	2300      	movs	r3, #0
 80200f8:	2200      	movs	r2, #0
 80200fa:	f006 fd12 	bl	8026b22 <mp_init_multi>
 80200fe:	6178      	str	r0, [r7, #20]
    if (ret != MP_OKAY)
 8020100:	697b      	ldr	r3, [r7, #20]
 8020102:	2b00      	cmp	r3, #0
 8020104:	d001      	beq.n	802010a <wc_InitRsaKey_ex+0xae>
        return ret;
 8020106:	697b      	ldr	r3, [r7, #20]
 8020108:	e028      	b.n	802015c <wc_InitRsaKey_ex+0x100>

#if !defined(WOLFSSL_KEY_GEN) && !defined(OPENSSL_EXTRA) && defined(RSA_LOW_MEM)
    ret = mp_init_multi(&key->d, &key->p, &key->q, NULL, NULL, NULL);
#else
    ret = mp_init_multi(&key->d, &key->p, &key->q, &key->dP, &key->dQ, &key->u);
 802010a:	68fb      	ldr	r3, [r7, #12]
 802010c:	f503 608b 	add.w	r0, r3, #1112	@ 0x458
 8020110:	68fb      	ldr	r3, [r7, #12]
 8020112:	f203 6184 	addw	r1, r3, #1668	@ 0x684
 8020116:	68fb      	ldr	r3, [r7, #12]
 8020118:	f503 640b 	add.w	r4, r3, #2224	@ 0x8b0
 802011c:	68fb      	ldr	r3, [r7, #12]
 802011e:	f603 25dc 	addw	r5, r3, #2780	@ 0xadc
 8020122:	68fb      	ldr	r3, [r7, #12]
 8020124:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 8020128:	68fa      	ldr	r2, [r7, #12]
 802012a:	f602 7234 	addw	r2, r2, #3892	@ 0xf34
 802012e:	9201      	str	r2, [sp, #4]
 8020130:	9300      	str	r3, [sp, #0]
 8020132:	462b      	mov	r3, r5
 8020134:	4622      	mov	r2, r4
 8020136:	f006 fcf4 	bl	8026b22 <mp_init_multi>
 802013a:	6178      	str	r0, [r7, #20]
#endif
    if (ret != MP_OKAY) {
 802013c:	697b      	ldr	r3, [r7, #20]
 802013e:	2b00      	cmp	r3, #0
 8020140:	d00b      	beq.n	802015a <wc_InitRsaKey_ex+0xfe>
        mp_clear(&key->n);
 8020142:	68fb      	ldr	r3, [r7, #12]
 8020144:	4618      	mov	r0, r3
 8020146:	f006 fcd2 	bl	8026aee <mp_clear>
        mp_clear(&key->e);
 802014a:	68fb      	ldr	r3, [r7, #12]
 802014c:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8020150:	4618      	mov	r0, r3
 8020152:	f006 fccc 	bl	8026aee <mp_clear>
        return ret;
 8020156:	697b      	ldr	r3, [r7, #20]
 8020158:	e000      	b.n	802015c <wc_InitRsaKey_ex+0x100>
    key->ctx.wrapped_pri2048_key = NULL;
    key->ctx.wrapped_pub2048_key = NULL;
    key->ctx.keySz = 0;
#endif

    return ret;
 802015a:	697b      	ldr	r3, [r7, #20]
}
 802015c:	4618      	mov	r0, r3
 802015e:	3718      	adds	r7, #24
 8020160:	46bd      	mov	sp, r7
 8020162:	bdb0      	pop	{r4, r5, r7, pc}

08020164 <wc_InitRsaKey>:

int wc_InitRsaKey(RsaKey* key, void* heap)
{
 8020164:	b580      	push	{r7, lr}
 8020166:	b082      	sub	sp, #8
 8020168:	af00      	add	r7, sp, #0
 802016a:	6078      	str	r0, [r7, #4]
 802016c:	6039      	str	r1, [r7, #0]
    return wc_InitRsaKey_ex(key, heap, INVALID_DEVID);
 802016e:	f06f 0201 	mvn.w	r2, #1
 8020172:	6839      	ldr	r1, [r7, #0]
 8020174:	6878      	ldr	r0, [r7, #4]
 8020176:	f7ff ff71 	bl	802005c <wc_InitRsaKey_ex>
 802017a:	4603      	mov	r3, r0
}
 802017c:	4618      	mov	r0, r3
 802017e:	3708      	adds	r7, #8
 8020180:	46bd      	mov	sp, r7
 8020182:	bd80      	pop	{r7, pc}

08020184 <wc_FreeRsaKey>:
    return se050_rsa_get_key_id(key, keyId);
}
#endif /* WOLFSSL_SE050 */

int wc_FreeRsaKey(RsaKey* key)
{
 8020184:	b580      	push	{r7, lr}
 8020186:	b084      	sub	sp, #16
 8020188:	af00      	add	r7, sp, #0
 802018a:	6078      	str	r0, [r7, #4]
    int ret = 0;
 802018c:	2300      	movs	r3, #0
 802018e:	60fb      	str	r3, [r7, #12]

    if (key == NULL) {
 8020190:	687b      	ldr	r3, [r7, #4]
 8020192:	2b00      	cmp	r3, #0
 8020194:	d102      	bne.n	802019c <wc_FreeRsaKey+0x18>
        return BAD_FUNC_ARG;
 8020196:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802019a:	e05d      	b.n	8020258 <wc_FreeRsaKey+0xd4>
    }

    wc_RsaCleanup(key);
 802019c:	6878      	ldr	r0, [r7, #4]
 802019e:	f7ff ff01 	bl	801ffa4 <wc_RsaCleanup>
#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA)
    wolfAsync_DevCtxFree(&key->asyncDev, WOLFSSL_ASYNC_MARKER_RSA);
#endif

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
    if (key->type == RSA_PRIVATE) {
 80201a2:	687b      	ldr	r3, [r7, #4]
 80201a4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80201a8:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
 80201ac:	2b01      	cmp	r3, #1
 80201ae:	d124      	bne.n	80201fa <wc_FreeRsaKey+0x76>
#if defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)
        mp_forcezero(&key->u);
 80201b0:	687b      	ldr	r3, [r7, #4]
 80201b2:	f603 7334 	addw	r3, r3, #3892	@ 0xf34
 80201b6:	4618      	mov	r0, r3
 80201b8:	f006 fc84 	bl	8026ac4 <mp_forcezero>
        mp_forcezero(&key->dQ);
 80201bc:	687b      	ldr	r3, [r7, #4]
 80201be:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 80201c2:	4618      	mov	r0, r3
 80201c4:	f006 fc7e 	bl	8026ac4 <mp_forcezero>
        mp_forcezero(&key->dP);
 80201c8:	687b      	ldr	r3, [r7, #4]
 80201ca:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 80201ce:	4618      	mov	r0, r3
 80201d0:	f006 fc78 	bl	8026ac4 <mp_forcezero>
#endif
        mp_forcezero(&key->q);
 80201d4:	687b      	ldr	r3, [r7, #4]
 80201d6:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 80201da:	4618      	mov	r0, r3
 80201dc:	f006 fc72 	bl	8026ac4 <mp_forcezero>
        mp_forcezero(&key->p);
 80201e0:	687b      	ldr	r3, [r7, #4]
 80201e2:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 80201e6:	4618      	mov	r0, r3
 80201e8:	f006 fc6c 	bl	8026ac4 <mp_forcezero>
        mp_forcezero(&key->d);
 80201ec:	687b      	ldr	r3, [r7, #4]
 80201ee:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 80201f2:	4618      	mov	r0, r3
 80201f4:	f006 fc66 	bl	8026ac4 <mp_forcezero>
 80201f8:	e023      	b.n	8020242 <wc_FreeRsaKey+0xbe>
    }
    else {
        /* private part */
#if defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)
        mp_clear(&key->u);
 80201fa:	687b      	ldr	r3, [r7, #4]
 80201fc:	f603 7334 	addw	r3, r3, #3892	@ 0xf34
 8020200:	4618      	mov	r0, r3
 8020202:	f006 fc74 	bl	8026aee <mp_clear>
        mp_clear(&key->dQ);
 8020206:	687b      	ldr	r3, [r7, #4]
 8020208:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 802020c:	4618      	mov	r0, r3
 802020e:	f006 fc6e 	bl	8026aee <mp_clear>
        mp_clear(&key->dP);
 8020212:	687b      	ldr	r3, [r7, #4]
 8020214:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 8020218:	4618      	mov	r0, r3
 802021a:	f006 fc68 	bl	8026aee <mp_clear>
#endif
        mp_clear(&key->q);
 802021e:	687b      	ldr	r3, [r7, #4]
 8020220:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8020224:	4618      	mov	r0, r3
 8020226:	f006 fc62 	bl	8026aee <mp_clear>
        mp_clear(&key->p);
 802022a:	687b      	ldr	r3, [r7, #4]
 802022c:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8020230:	4618      	mov	r0, r3
 8020232:	f006 fc5c 	bl	8026aee <mp_clear>
        mp_clear(&key->d);
 8020236:	687b      	ldr	r3, [r7, #4]
 8020238:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 802023c:	4618      	mov	r0, r3
 802023e:	f006 fc56 	bl	8026aee <mp_clear>
    }
#endif /* WOLFSSL_RSA_PUBLIC_ONLY */

    /* public part */
    mp_clear(&key->e);
 8020242:	687b      	ldr	r3, [r7, #4]
 8020244:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8020248:	4618      	mov	r0, r3
 802024a:	f006 fc50 	bl	8026aee <mp_clear>
    mp_clear(&key->n);
 802024e:	687b      	ldr	r3, [r7, #4]
 8020250:	4618      	mov	r0, r3
 8020252:	f006 fc4c 	bl	8026aee <mp_clear>

#if defined(WOLFSSL_RENESAS_FSPSM_CRYPTONLY)
    wc_fspsm_RsaKeyFree(key);
#endif

    return ret;
 8020256:	68fb      	ldr	r3, [r7, #12]
}
 8020258:	4618      	mov	r0, r3
 802025a:	3710      	adds	r7, #16
 802025c:	46bd      	mov	sp, r7
 802025e:	bd80      	pop	{r7, pc}

08020260 <RsaMGF1>:
   outSz: size of output buffer
 */
#if !defined(NO_SHA) || !defined(NO_SHA256) || defined(WOLFSSL_SHA384) || defined(WOLFSSL_SHA512)
static int RsaMGF1(enum wc_HashType hType, byte* seed, word32 seedSz,
                                        byte* out, word32 outSz, void* heap)
{
 8020260:	b580      	push	{r7, lr}
 8020262:	b09a      	sub	sp, #104	@ 0x68
 8020264:	af02      	add	r7, sp, #8
 8020266:	60b9      	str	r1, [r7, #8]
 8020268:	607a      	str	r2, [r7, #4]
 802026a:	603b      	str	r3, [r7, #0]
 802026c:	4603      	mov	r3, r0
 802026e:	73fb      	strb	r3, [r7, #15]
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    byte* tmp = NULL;
 8020270:	2300      	movs	r3, #0
 8020272:	65fb      	str	r3, [r7, #92]	@ 0x5c
    byte   tmpF = 0;     /* 1 if dynamic memory needs freed */
 8020274:	2300      	movs	r3, #0
 8020276:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
#else
    byte tmp[RSA_MAX_SIZE/8];
#endif
    /* needs to be large enough for seed size plus counter(4) */
    byte  tmpA[WC_MAX_DIGEST_SIZE + 4];
    word32 tmpSz = 0;
 802027a:	2300      	movs	r3, #0
 802027c:	657b      	str	r3, [r7, #84]	@ 0x54
    word32 counter;
    word32 idx;
#ifdef WOLFSSL_SMALL_STACK_CACHE
    wc_HashAlg *hash;
#endif
    hLen    = wc_HashGetDigestSize(hType);
 802027e:	7bfb      	ldrb	r3, [r7, #15]
 8020280:	4618      	mov	r0, r3
 8020282:	f7fe f969 	bl	801e558 <wc_HashGetDigestSize>
 8020286:	6478      	str	r0, [r7, #68]	@ 0x44
    counter = 0;
 8020288:	2300      	movs	r3, #0
 802028a:	653b      	str	r3, [r7, #80]	@ 0x50
    idx     = 0;
 802028c:	2300      	movs	r3, #0
 802028e:	64fb      	str	r3, [r7, #76]	@ 0x4c

    (void)heap;

    XMEMSET(tmpA, 0, sizeof(tmpA));
 8020290:	f107 0314 	add.w	r3, r7, #20
 8020294:	2224      	movs	r2, #36	@ 0x24
 8020296:	2100      	movs	r1, #0
 8020298:	4618      	mov	r0, r3
 802029a:	f008 fcc3 	bl	8028c24 <memset>
    /* check error return of wc_HashGetDigestSize */
    if (hLen < 0) {
 802029e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80202a0:	2b00      	cmp	r3, #0
 80202a2:	da01      	bge.n	80202a8 <RsaMGF1+0x48>
        return hLen;
 80202a4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80202a6:	e08f      	b.n	80203c8 <RsaMGF1+0x168>
    }

    /* if tmp is not large enough than use some dynamic memory */
    if ((seedSz + 4) > sizeof(tmpA) || (word32)hLen > sizeof(tmpA)) {
 80202a8:	687b      	ldr	r3, [r7, #4]
 80202aa:	3304      	adds	r3, #4
 80202ac:	2b24      	cmp	r3, #36	@ 0x24
 80202ae:	d802      	bhi.n	80202b6 <RsaMGF1+0x56>
 80202b0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80202b2:	2b24      	cmp	r3, #36	@ 0x24
 80202b4:	d914      	bls.n	80202e0 <RsaMGF1+0x80>
        /* find largest amount of memory needed which will be the max of
         * hLen and (seedSz + 4) since tmp is used to store the hash digest */
        tmpSz = ((seedSz + 4) > (word32)hLen)? seedSz + 4: (word32)hLen;
 80202b6:	687b      	ldr	r3, [r7, #4]
 80202b8:	1d1a      	adds	r2, r3, #4
 80202ba:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80202bc:	4293      	cmp	r3, r2
 80202be:	bf38      	it	cc
 80202c0:	4613      	movcc	r3, r2
 80202c2:	657b      	str	r3, [r7, #84]	@ 0x54
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
        tmp = (byte*)XMALLOC(tmpSz, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80202c4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80202c6:	f7fe fcd9 	bl	801ec7c <wolfSSL_Malloc>
 80202ca:	65f8      	str	r0, [r7, #92]	@ 0x5c
        if (tmp == NULL) {
 80202cc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80202ce:	2b00      	cmp	r3, #0
 80202d0:	d102      	bne.n	80202d8 <RsaMGF1+0x78>
            return MEMORY_E;
 80202d2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80202d6:	e077      	b.n	80203c8 <RsaMGF1+0x168>
        }
        tmpF = 1; /* make sure to free memory when done */
 80202d8:	2301      	movs	r3, #1
 80202da:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
 80202de:	e007      	b.n	80202f0 <RsaMGF1+0x90>
#endif
    }
    else {
        /* use array on the stack */
    #ifndef WOLFSSL_SMALL_STACK_CACHE
        tmpSz = sizeof(tmpA);
 80202e0:	2324      	movs	r3, #36	@ 0x24
 80202e2:	657b      	str	r3, [r7, #84]	@ 0x54
    #endif
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
        tmp  = tmpA;
 80202e4:	f107 0314 	add.w	r3, r7, #20
 80202e8:	65fb      	str	r3, [r7, #92]	@ 0x5c
        tmpF = 0; /* no need to free memory at end */
 80202ea:	2300      	movs	r3, #0
 80202ec:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
        return ret;
    }
#endif

    do {
        int i = 0;
 80202f0:	2300      	movs	r3, #0
 80202f2:	64bb      	str	r3, [r7, #72]	@ 0x48
        XMEMCPY(tmp, seed, seedSz);
 80202f4:	687a      	ldr	r2, [r7, #4]
 80202f6:	68b9      	ldr	r1, [r7, #8]
 80202f8:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 80202fa:	f008 fd44 	bl	8028d86 <memcpy>

        /* counter to byte array appended to tmp */
        tmp[seedSz]     = (byte)((counter >> 24) & 0xFF);
 80202fe:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020300:	0e19      	lsrs	r1, r3, #24
 8020302:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8020304:	687b      	ldr	r3, [r7, #4]
 8020306:	4413      	add	r3, r2
 8020308:	b2ca      	uxtb	r2, r1
 802030a:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 1] = (byte)((counter >> 16) & 0xFF);
 802030c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802030e:	0c19      	lsrs	r1, r3, #16
 8020310:	687b      	ldr	r3, [r7, #4]
 8020312:	3301      	adds	r3, #1
 8020314:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8020316:	4413      	add	r3, r2
 8020318:	b2ca      	uxtb	r2, r1
 802031a:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 2] = (byte)((counter >>  8) & 0xFF);
 802031c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802031e:	0a19      	lsrs	r1, r3, #8
 8020320:	687b      	ldr	r3, [r7, #4]
 8020322:	3302      	adds	r3, #2
 8020324:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8020326:	4413      	add	r3, r2
 8020328:	b2ca      	uxtb	r2, r1
 802032a:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 3] = (byte)((counter)       & 0xFF);
 802032c:	687b      	ldr	r3, [r7, #4]
 802032e:	3303      	adds	r3, #3
 8020330:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8020332:	4413      	add	r3, r2
 8020334:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8020336:	b2d2      	uxtb	r2, r2
 8020338:	701a      	strb	r2, [r3, #0]
        ret = wc_HashUpdate(hash, hType, tmp, (seedSz + 4));
        if (ret == 0) {
            ret = wc_HashFinal(hash, hType, tmp);
        }
#else
        ret = wc_Hash(hType, tmp, (seedSz + 4), tmp, tmpSz);
 802033a:	687b      	ldr	r3, [r7, #4]
 802033c:	1d1a      	adds	r2, r3, #4
 802033e:	7bf8      	ldrb	r0, [r7, #15]
 8020340:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8020342:	9300      	str	r3, [sp, #0]
 8020344:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8020346:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8020348:	f7fe f99e 	bl	801e688 <wc_Hash>
 802034c:	6438      	str	r0, [r7, #64]	@ 0x40
#endif
        if (ret != 0) {
 802034e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020350:	2b00      	cmp	r3, #0
 8020352:	d00d      	beq.n	8020370 <RsaMGF1+0x110>
            /* check for if dynamic memory was needed, then free */
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
            if (tmpF) {
 8020354:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 8020358:	2b00      	cmp	r3, #0
 802035a:	d007      	beq.n	802036c <RsaMGF1+0x10c>
                XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 802035c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802035e:	63bb      	str	r3, [r7, #56]	@ 0x38
 8020360:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8020362:	2b00      	cmp	r3, #0
 8020364:	d002      	beq.n	802036c <RsaMGF1+0x10c>
 8020366:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8020368:	f7fe fca4 	bl	801ecb4 <wolfSSL_Free>
            }
#endif
            return ret;
 802036c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802036e:	e02b      	b.n	80203c8 <RsaMGF1+0x168>
        }

        for (i = 0; i < hLen && idx < outSz; i++) {
 8020370:	2300      	movs	r3, #0
 8020372:	64bb      	str	r3, [r7, #72]	@ 0x48
 8020374:	e00c      	b.n	8020390 <RsaMGF1+0x130>
            out[idx++] = tmp[i];
 8020376:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020378:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802037a:	441a      	add	r2, r3
 802037c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802037e:	1c59      	adds	r1, r3, #1
 8020380:	64f9      	str	r1, [r7, #76]	@ 0x4c
 8020382:	6839      	ldr	r1, [r7, #0]
 8020384:	440b      	add	r3, r1
 8020386:	7812      	ldrb	r2, [r2, #0]
 8020388:	701a      	strb	r2, [r3, #0]
        for (i = 0; i < hLen && idx < outSz; i++) {
 802038a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802038c:	3301      	adds	r3, #1
 802038e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8020390:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8020392:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020394:	429a      	cmp	r2, r3
 8020396:	da03      	bge.n	80203a0 <RsaMGF1+0x140>
 8020398:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802039a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802039c:	429a      	cmp	r2, r3
 802039e:	d3ea      	bcc.n	8020376 <RsaMGF1+0x116>
        }
        counter++;
 80203a0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80203a2:	3301      	adds	r3, #1
 80203a4:	653b      	str	r3, [r7, #80]	@ 0x50
    } while (idx < outSz);
 80203a6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80203a8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80203aa:	429a      	cmp	r2, r3
 80203ac:	d3a0      	bcc.n	80202f0 <RsaMGF1+0x90>
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    /* check for if dynamic memory was needed, then free */
    if (tmpF) {
 80203ae:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 80203b2:	2b00      	cmp	r3, #0
 80203b4:	d007      	beq.n	80203c6 <RsaMGF1+0x166>
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80203b6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80203b8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80203ba:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80203bc:	2b00      	cmp	r3, #0
 80203be:	d002      	beq.n	80203c6 <RsaMGF1+0x166>
 80203c0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80203c2:	f7fe fc77 	bl	801ecb4 <wolfSSL_Free>
#ifdef WOLFSSL_SMALL_STACK_CACHE
    wc_HashFree(hash, hType);
    XFREE(hash, heap, DYNAMIC_TYPE_DIGEST);
#endif

    return 0;
 80203c6:	2300      	movs	r3, #0
}
 80203c8:	4618      	mov	r0, r3
 80203ca:	3760      	adds	r7, #96	@ 0x60
 80203cc:	46bd      	mov	sp, r7
 80203ce:	bd80      	pop	{r7, pc}

080203d0 <RsaMGF>:
/* helper function to direct which mask generation function is used
   switched on type input
 */
static int RsaMGF(int type, byte* seed, word32 seedSz, byte* out,
                                                    word32 outSz, void* heap)
{
 80203d0:	b580      	push	{r7, lr}
 80203d2:	b088      	sub	sp, #32
 80203d4:	af02      	add	r7, sp, #8
 80203d6:	60f8      	str	r0, [r7, #12]
 80203d8:	60b9      	str	r1, [r7, #8]
 80203da:	607a      	str	r2, [r7, #4]
 80203dc:	603b      	str	r3, [r7, #0]
    int ret;

    switch(type) {
 80203de:	68fb      	ldr	r3, [r7, #12]
 80203e0:	2b01      	cmp	r3, #1
 80203e2:	d10b      	bne.n	80203fc <RsaMGF+0x2c>
        case WC_MGF1SHA224:
            ret = RsaMGF1(WC_HASH_TYPE_SHA224, seed, seedSz, out, outSz, heap);
            break;
    #endif
        case WC_MGF1SHA256:
            ret = RsaMGF1(WC_HASH_TYPE_SHA256, seed, seedSz, out, outSz, heap);
 80203e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80203e6:	9301      	str	r3, [sp, #4]
 80203e8:	6a3b      	ldr	r3, [r7, #32]
 80203ea:	9300      	str	r3, [sp, #0]
 80203ec:	683b      	ldr	r3, [r7, #0]
 80203ee:	687a      	ldr	r2, [r7, #4]
 80203f0:	68b9      	ldr	r1, [r7, #8]
 80203f2:	2006      	movs	r0, #6
 80203f4:	f7ff ff34 	bl	8020260 <RsaMGF1>
 80203f8:	6178      	str	r0, [r7, #20]
            break;
 80203fa:	e002      	b.n	8020402 <RsaMGF+0x32>
            break;
        #endif
    #endif
        default:
            WOLFSSL_MSG("Unknown MGF type: check build options");
            ret = BAD_FUNC_ARG;
 80203fc:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020400:	617b      	str	r3, [r7, #20]
    (void)seedSz;
    (void)out;
    (void)outSz;
    (void)heap;

    return ret;
 8020402:	697b      	ldr	r3, [r7, #20]
}
 8020404:	4618      	mov	r0, r3
 8020406:	3718      	adds	r7, #24
 8020408:	46bd      	mov	sp, r7
 802040a:	bd80      	pop	{r7, pc}

0802040c <RsaUnPad_OAEP>:
/* UnPad plaintext, set start to *output, return length of plaintext,
 * < 0 on error */
static int RsaUnPad_OAEP(byte *pkcsBlock, unsigned int pkcsBlockLen,
                            byte **output, enum wc_HashType hType, int mgf,
                            byte* optLabel, word32 labelLen, void* heap)
{
 802040c:	b580      	push	{r7, lr}
 802040e:	b098      	sub	sp, #96	@ 0x60
 8020410:	af02      	add	r7, sp, #8
 8020412:	60f8      	str	r0, [r7, #12]
 8020414:	60b9      	str	r1, [r7, #8]
 8020416:	607a      	str	r2, [r7, #4]
 8020418:	70fb      	strb	r3, [r7, #3]
    word32 idx;
    word32 i;
    word32 inc;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    byte* tmp  = NULL;
 802041a:	2300      	movs	r3, #0
 802041c:	64bb      	str	r3, [r7, #72]	@ 0x48
#else
    byte tmp[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];
#endif

    /* no label is allowed, but catch if no label provided and length > 0 */
    if (optLabel == NULL && labelLen > 0) {
 802041e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8020420:	2b00      	cmp	r3, #0
 8020422:	d105      	bne.n	8020430 <RsaUnPad_OAEP+0x24>
 8020424:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8020426:	2b00      	cmp	r3, #0
 8020428:	d002      	beq.n	8020430 <RsaUnPad_OAEP+0x24>
        return BUFFER_E;
 802042a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 802042e:	e0e9      	b.n	8020604 <RsaUnPad_OAEP+0x1f8>
    }

    ret = wc_HashGetDigestSize(hType);
 8020430:	78fb      	ldrb	r3, [r7, #3]
 8020432:	4618      	mov	r0, r3
 8020434:	f7fe f890 	bl	801e558 <wc_HashGetDigestSize>
 8020438:	6478      	str	r0, [r7, #68]	@ 0x44
    if ((ret < 0) || (pkcsBlockLen < (2 * (word32)ret + 2))) {
 802043a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802043c:	2b00      	cmp	r3, #0
 802043e:	db05      	blt.n	802044c <RsaUnPad_OAEP+0x40>
 8020440:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020442:	3301      	adds	r3, #1
 8020444:	005b      	lsls	r3, r3, #1
 8020446:	68ba      	ldr	r2, [r7, #8]
 8020448:	429a      	cmp	r2, r3
 802044a:	d202      	bcs.n	8020452 <RsaUnPad_OAEP+0x46>
        return BAD_FUNC_ARG;
 802044c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020450:	e0d8      	b.n	8020604 <RsaUnPad_OAEP+0x1f8>
    }
    hLen = (word32)ret;
 8020452:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020454:	643b      	str	r3, [r7, #64]	@ 0x40

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    tmp = (byte*)XMALLOC(pkcsBlockLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8020456:	68b8      	ldr	r0, [r7, #8]
 8020458:	f7fe fc10 	bl	801ec7c <wolfSSL_Malloc>
 802045c:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (tmp == NULL) {
 802045e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020460:	2b00      	cmp	r3, #0
 8020462:	d102      	bne.n	802046a <RsaUnPad_OAEP+0x5e>
        return MEMORY_E;
 8020464:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020468:	e0cc      	b.n	8020604 <RsaUnPad_OAEP+0x1f8>
    }
#endif
    XMEMSET(tmp, 0, pkcsBlockLen);
 802046a:	68ba      	ldr	r2, [r7, #8]
 802046c:	2100      	movs	r1, #0
 802046e:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8020470:	f008 fbd8 	bl	8028c24 <memset>
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Add("OAEP UnPad temp", tmp, pkcsBlockLen);
#endif

    /* find seedMask value */
    if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 8020474:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020476:	3301      	adds	r3, #1
 8020478:	68fa      	ldr	r2, [r7, #12]
 802047a:	18d1      	adds	r1, r2, r3
                            pkcsBlockLen - hLen - 1, tmp, hLen, heap)) != 0) {
 802047c:	68ba      	ldr	r2, [r7, #8]
 802047e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020480:	1ad3      	subs	r3, r2, r3
    if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 8020482:	1e5a      	subs	r2, r3, #1
 8020484:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8020486:	9301      	str	r3, [sp, #4]
 8020488:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802048a:	9300      	str	r3, [sp, #0]
 802048c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802048e:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8020490:	f7ff ff9e 	bl	80203d0 <RsaMGF>
 8020494:	6478      	str	r0, [r7, #68]	@ 0x44
 8020496:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020498:	2b00      	cmp	r3, #0
 802049a:	d009      	beq.n	80204b0 <RsaUnPad_OAEP+0xa4>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 802049c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802049e:	637b      	str	r3, [r7, #52]	@ 0x34
 80204a0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80204a2:	2b00      	cmp	r3, #0
 80204a4:	d002      	beq.n	80204ac <RsaUnPad_OAEP+0xa0>
 80204a6:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80204a8:	f7fe fc04 	bl	801ecb4 <wolfSSL_Free>
#endif
        return ret;
 80204ac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80204ae:	e0a9      	b.n	8020604 <RsaUnPad_OAEP+0x1f8>
    }

    /* xor seedMask value with maskedSeed to get seed value */
    xorbuf(tmp, pkcsBlock + 1, hLen);
 80204b0:	68fb      	ldr	r3, [r7, #12]
 80204b2:	3301      	adds	r3, #1
 80204b4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80204b6:	4619      	mov	r1, r3
 80204b8:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80204ba:	f7ff fbf2 	bl	801fca2 <xorbuf>

    /* get dbMask value */
    if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 80204be:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80204c0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80204c2:	18d1      	adds	r1, r2, r3
                                       pkcsBlockLen - hLen - 1, heap)) != 0) {
 80204c4:	68ba      	ldr	r2, [r7, #8]
 80204c6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80204c8:	1ad3      	subs	r3, r2, r3
    if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 80204ca:	3b01      	subs	r3, #1
 80204cc:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80204ce:	9201      	str	r2, [sp, #4]
 80204d0:	9300      	str	r3, [sp, #0]
 80204d2:	460b      	mov	r3, r1
 80204d4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80204d6:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 80204d8:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80204da:	f7ff ff79 	bl	80203d0 <RsaMGF>
 80204de:	6478      	str	r0, [r7, #68]	@ 0x44
 80204e0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80204e2:	2b00      	cmp	r3, #0
 80204e4:	d00d      	beq.n	8020502 <RsaUnPad_OAEP+0xf6>
        ForceZero(tmp, hLen);
 80204e6:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 80204e8:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80204ea:	f7ff fc34 	bl	801fd56 <ForceZero>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(tmp, NULL, DYNAMIC_TYPE_RSA_BUFFER);
 80204ee:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80204f0:	63bb      	str	r3, [r7, #56]	@ 0x38
 80204f2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80204f4:	2b00      	cmp	r3, #0
 80204f6:	d002      	beq.n	80204fe <RsaUnPad_OAEP+0xf2>
 80204f8:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 80204fa:	f7fe fbdb 	bl	801ecb4 <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
        wc_MemZero_Check(tmp, hLen);
#endif
        return ret;
 80204fe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020500:	e080      	b.n	8020604 <RsaUnPad_OAEP+0x1f8>
    }

    /* get DB value by doing maskedDB xor dbMask */
    xorbuf(pkcsBlock + hLen + 1, tmp + hLen, pkcsBlockLen - hLen - 1);
 8020502:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020504:	3301      	adds	r3, #1
 8020506:	68fa      	ldr	r2, [r7, #12]
 8020508:	18d0      	adds	r0, r2, r3
 802050a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802050c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802050e:	18d1      	adds	r1, r2, r3
 8020510:	68ba      	ldr	r2, [r7, #8]
 8020512:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020514:	1ad3      	subs	r3, r2, r3
 8020516:	3b01      	subs	r3, #1
 8020518:	461a      	mov	r2, r3
 802051a:	f7ff fbc2 	bl	801fca2 <xorbuf>

    ForceZero(tmp, pkcsBlockLen);
 802051e:	68b9      	ldr	r1, [r7, #8]
 8020520:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8020522:	f7ff fc18 	bl	801fd56 <ForceZero>
#ifdef WOLFSSL_SMALL_STACK
    /* done with use of tmp buffer */
    XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8020526:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020528:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802052a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802052c:	2b00      	cmp	r3, #0
 802052e:	d002      	beq.n	8020536 <RsaUnPad_OAEP+0x12a>
 8020530:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8020532:	f7fe fbbf 	bl	801ecb4 <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
    wc_MemZero_Check(tmp, pkcsBlockLen);
#endif

    /* advance idx to index of PS and msg separator, account for PS size of 0*/
    idx = hLen + 1 + hLen;
 8020536:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020538:	005b      	lsls	r3, r3, #1
 802053a:	3301      	adds	r3, #1
 802053c:	657b      	str	r3, [r7, #84]	@ 0x54
    /* Don't reveal length of message: look at every byte. */
    inc = 1;
 802053e:	2301      	movs	r3, #1
 8020540:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (i = hLen + 1 + hLen; i < pkcsBlockLen - 1; i++) {
 8020542:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020544:	005b      	lsls	r3, r3, #1
 8020546:	3301      	adds	r3, #1
 8020548:	653b      	str	r3, [r7, #80]	@ 0x50
 802054a:	e010      	b.n	802056e <RsaUnPad_OAEP+0x162>
        /* Looking for non-zero byte. */
        inc &= 1 - (((word32)0 - pkcsBlock[i]) >> 31);
 802054c:	68fa      	ldr	r2, [r7, #12]
 802054e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020550:	4413      	add	r3, r2
 8020552:	781b      	ldrb	r3, [r3, #0]
 8020554:	425b      	negs	r3, r3
 8020556:	17db      	asrs	r3, r3, #31
 8020558:	3301      	adds	r3, #1
 802055a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802055c:	4013      	ands	r3, r2
 802055e:	64fb      	str	r3, [r7, #76]	@ 0x4c
        idx += inc;
 8020560:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8020562:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020564:	4413      	add	r3, r2
 8020566:	657b      	str	r3, [r7, #84]	@ 0x54
    for (i = hLen + 1 + hLen; i < pkcsBlockLen - 1; i++) {
 8020568:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802056a:	3301      	adds	r3, #1
 802056c:	653b      	str	r3, [r7, #80]	@ 0x50
 802056e:	68bb      	ldr	r3, [r7, #8]
 8020570:	3b01      	subs	r3, #1
 8020572:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8020574:	429a      	cmp	r2, r3
 8020576:	d3e9      	bcc.n	802054c <RsaUnPad_OAEP+0x140>
    }

    /* create hash of label for comparison with hash sent */
    if ((ret = wc_Hash(hType, optLabel, labelLen, h, hLen)) != 0) {
 8020578:	f107 0214 	add.w	r2, r7, #20
 802057c:	78f8      	ldrb	r0, [r7, #3]
 802057e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020580:	9300      	str	r3, [sp, #0]
 8020582:	4613      	mov	r3, r2
 8020584:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8020586:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8020588:	f7fe f87e 	bl	801e688 <wc_Hash>
 802058c:	6478      	str	r0, [r7, #68]	@ 0x44
 802058e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020590:	2b00      	cmp	r3, #0
 8020592:	d001      	beq.n	8020598 <RsaUnPad_OAEP+0x18c>
        return ret;
 8020594:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020596:	e035      	b.n	8020604 <RsaUnPad_OAEP+0x1f8>
       Comparison of lHash, Y, and separator value needs to all happen in
       constant time.
       Attackers should not be able to get error condition from the timing of
       these checks.
     */
    ret = 0;
 8020598:	2300      	movs	r3, #0
 802059a:	647b      	str	r3, [r7, #68]	@ 0x44
    ret |= ConstantCompare(pkcsBlock + hLen + 1, h, (int)hLen);
 802059c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802059e:	3301      	adds	r3, #1
 80205a0:	68fa      	ldr	r2, [r7, #12]
 80205a2:	4413      	add	r3, r2
 80205a4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80205a6:	f107 0114 	add.w	r1, r7, #20
 80205aa:	4618      	mov	r0, r3
 80205ac:	f7ff fbec 	bl	801fd88 <ConstantCompare>
 80205b0:	4602      	mov	r2, r0
 80205b2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80205b4:	4313      	orrs	r3, r2
 80205b6:	647b      	str	r3, [r7, #68]	@ 0x44
    ret += pkcsBlock[idx++] ^ 0x01; /* separator value is 0x01 */
 80205b8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80205ba:	1c5a      	adds	r2, r3, #1
 80205bc:	657a      	str	r2, [r7, #84]	@ 0x54
 80205be:	68fa      	ldr	r2, [r7, #12]
 80205c0:	4413      	add	r3, r2
 80205c2:	781b      	ldrb	r3, [r3, #0]
 80205c4:	f083 0301 	eor.w	r3, r3, #1
 80205c8:	b2db      	uxtb	r3, r3
 80205ca:	461a      	mov	r2, r3
 80205cc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80205ce:	4413      	add	r3, r2
 80205d0:	647b      	str	r3, [r7, #68]	@ 0x44
    ret += pkcsBlock[0]     ^ 0x00; /* Y, the first value, should be 0 */
 80205d2:	68fb      	ldr	r3, [r7, #12]
 80205d4:	781b      	ldrb	r3, [r3, #0]
 80205d6:	461a      	mov	r2, r3
 80205d8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80205da:	4413      	add	r3, r2
 80205dc:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Return 0 data length on error. */
    idx = ctMaskSelWord32(ctMaskEq(ret, 0), idx, pkcsBlockLen);
 80205de:	2100      	movs	r1, #0
 80205e0:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 80205e2:	f7ff fc42 	bl	801fe6a <ctMaskEq>
 80205e6:	4603      	mov	r3, r0
 80205e8:	68ba      	ldr	r2, [r7, #8]
 80205ea:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 80205ec:	4618      	mov	r0, r3
 80205ee:	f7ff fcc0 	bl	801ff72 <ctMaskSelWord32>
 80205f2:	6578      	str	r0, [r7, #84]	@ 0x54

    /* adjust pointer to correct location in array and return size of M */
    *output = (byte*)(pkcsBlock + idx);
 80205f4:	68fa      	ldr	r2, [r7, #12]
 80205f6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80205f8:	441a      	add	r2, r3
 80205fa:	687b      	ldr	r3, [r7, #4]
 80205fc:	601a      	str	r2, [r3, #0]
    return (int)(pkcsBlockLen - idx);
 80205fe:	68ba      	ldr	r2, [r7, #8]
 8020600:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8020602:	1ad3      	subs	r3, r2, r3
}
 8020604:	4618      	mov	r0, r3
 8020606:	3758      	adds	r7, #88	@ 0x58
 8020608:	46bd      	mov	sp, r7
 802060a:	bd80      	pop	{r7, pc}

0802060c <RsaUnPad_PSS>:
                 and other negative values on error.
 */
static int RsaUnPad_PSS(byte *pkcsBlock, unsigned int pkcsBlockLen,
                        byte **output, enum wc_HashType hType, int mgf,
                        int saltLen, int bits, void* heap)
{
 802060c:	b580      	push	{r7, lr}
 802060e:	b090      	sub	sp, #64	@ 0x40
 8020610:	af02      	add	r7, sp, #8
 8020612:	60f8      	str	r0, [r7, #12]
 8020614:	60b9      	str	r1, [r7, #8]
 8020616:	607a      	str	r2, [r7, #4]
 8020618:	70fb      	strb	r3, [r7, #3]
    if (pkcsBlockLen > RSA_MAX_SIZE/8) {
        return MEMORY_E;
    }
#endif

    hLen = wc_HashGetDigestSize(hType);
 802061a:	78fb      	ldrb	r3, [r7, #3]
 802061c:	4618      	mov	r0, r3
 802061e:	f7fd ff9b 	bl	801e558 <wc_HashGetDigestSize>
 8020622:	6338      	str	r0, [r7, #48]	@ 0x30
    if (hLen < 0)
 8020624:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020626:	2b00      	cmp	r3, #0
 8020628:	da01      	bge.n	802062e <RsaUnPad_PSS+0x22>
        return hLen;
 802062a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802062c:	e0e3      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
    bits = (bits - 1) & 0x7;
 802062e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020630:	3b01      	subs	r3, #1
 8020632:	f003 0307 	and.w	r3, r3, #7
 8020636:	64bb      	str	r3, [r7, #72]	@ 0x48
    if ((pkcsBlock[0] & (0xff << bits)) != 0) {
 8020638:	68fb      	ldr	r3, [r7, #12]
 802063a:	781b      	ldrb	r3, [r3, #0]
 802063c:	4619      	mov	r1, r3
 802063e:	22ff      	movs	r2, #255	@ 0xff
 8020640:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020642:	fa02 f303 	lsl.w	r3, r2, r3
 8020646:	400b      	ands	r3, r1
 8020648:	2b00      	cmp	r3, #0
 802064a:	d002      	beq.n	8020652 <RsaUnPad_PSS+0x46>
        return BAD_PADDING_E;
 802064c:	f06f 03c0 	mvn.w	r3, #192	@ 0xc0
 8020650:	e0d1      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
    }
    if (bits == 0) {
 8020652:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020654:	2b00      	cmp	r3, #0
 8020656:	d105      	bne.n	8020664 <RsaUnPad_PSS+0x58>
        pkcsBlock++;
 8020658:	68fb      	ldr	r3, [r7, #12]
 802065a:	3301      	adds	r3, #1
 802065c:	60fb      	str	r3, [r7, #12]
        pkcsBlockLen--;
 802065e:	68bb      	ldr	r3, [r7, #8]
 8020660:	3b01      	subs	r3, #1
 8020662:	60bb      	str	r3, [r7, #8]
    }
    maskLen = (int)pkcsBlockLen - 1 - hLen;
 8020664:	68bb      	ldr	r3, [r7, #8]
 8020666:	1e5a      	subs	r2, r3, #1
 8020668:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802066a:	1ad3      	subs	r3, r2, r3
 802066c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if (maskLen < 0) {
 802066e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020670:	2b00      	cmp	r3, #0
 8020672:	da02      	bge.n	802067a <RsaUnPad_PSS+0x6e>
        WOLFSSL_MSG("RsaUnPad_PSS: Hash too large");
        return WC_KEY_SIZE_E;
 8020674:	f06f 03e9 	mvn.w	r3, #233	@ 0xe9
 8020678:	e0bd      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
    }

    if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
 802067a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802067c:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8020680:	d102      	bne.n	8020688 <RsaUnPad_PSS+0x7c>
        saltLen = hLen;
 8020682:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020684:	647b      	str	r3, [r7, #68]	@ 0x44
 8020686:	e00d      	b.n	80206a4 <RsaUnPad_PSS+0x98>
            if (orig_bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE)
                saltLen = RSA_PSS_SALT_MAX_SZ;
        #endif
    }
#ifndef WOLFSSL_PSS_LONG_SALT
    else if (saltLen > hLen)
 8020688:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 802068a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802068c:	429a      	cmp	r2, r3
 802068e:	dd02      	ble.n	8020696 <RsaUnPad_PSS+0x8a>
        return PSS_SALTLEN_E;
 8020690:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8020694:	e0af      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
#endif
#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
    else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT)
 8020696:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020698:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 802069c:	da02      	bge.n	80206a4 <RsaUnPad_PSS+0x98>
        return PSS_SALTLEN_E;
 802069e:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80206a2:	e0a8      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
    if (maskLen < saltLen + 1) {
 80206a4:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80206a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80206a8:	429a      	cmp	r2, r3
 80206aa:	db02      	blt.n	80206b2 <RsaUnPad_PSS+0xa6>
        return PSS_SALTLEN_E;
 80206ac:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80206b0:	e0a1      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
    if (saltLen != RSA_PSS_SALT_LEN_DISCOVER && maskLen < saltLen + 1) {
        return WC_KEY_SIZE_E;
    }
#endif

    if (pkcsBlock[pkcsBlockLen - 1] != RSA_PSS_PAD_TERM) {
 80206b2:	68bb      	ldr	r3, [r7, #8]
 80206b4:	3b01      	subs	r3, #1
 80206b6:	68fa      	ldr	r2, [r7, #12]
 80206b8:	4413      	add	r3, r2
 80206ba:	781b      	ldrb	r3, [r3, #0]
 80206bc:	2bbc      	cmp	r3, #188	@ 0xbc
 80206be:	d002      	beq.n	80206c6 <RsaUnPad_PSS+0xba>
        WOLFSSL_MSG("RsaUnPad_PSS: Padding Term Error");
        return BAD_PADDING_E;
 80206c0:	f06f 03c0 	mvn.w	r3, #192	@ 0xc0
 80206c4:	e097      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
    }

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
    tmp = (byte*)XMALLOC((size_t)maskLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80206c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80206c8:	4618      	mov	r0, r3
 80206ca:	f7fe fad7 	bl	801ec7c <wolfSSL_Malloc>
 80206ce:	62b8      	str	r0, [r7, #40]	@ 0x28
    if (tmp == NULL) {
 80206d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80206d2:	2b00      	cmp	r3, #0
 80206d4:	d102      	bne.n	80206dc <RsaUnPad_PSS+0xd0>
        return MEMORY_E;
 80206d6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80206da:	e08c      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
    }
#endif

    if ((ret = RsaMGF(mgf, pkcsBlock + maskLen, (word32)hLen, tmp, (word32)maskLen,
 80206dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80206de:	68fa      	ldr	r2, [r7, #12]
 80206e0:	18d1      	adds	r1, r2, r3
 80206e2:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80206e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80206e6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80206e8:	9201      	str	r2, [sp, #4]
 80206ea:	9300      	str	r3, [sp, #0]
 80206ec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80206ee:	4602      	mov	r2, r0
 80206f0:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 80206f2:	f7ff fe6d 	bl	80203d0 <RsaMGF>
 80206f6:	6278      	str	r0, [r7, #36]	@ 0x24
 80206f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80206fa:	2b00      	cmp	r3, #0
 80206fc:	d009      	beq.n	8020712 <RsaUnPad_PSS+0x106>
                                                                  heap)) != 0) {
        #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80206fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020700:	617b      	str	r3, [r7, #20]
 8020702:	697b      	ldr	r3, [r7, #20]
 8020704:	2b00      	cmp	r3, #0
 8020706:	d002      	beq.n	802070e <RsaUnPad_PSS+0x102>
 8020708:	6978      	ldr	r0, [r7, #20]
 802070a:	f7fe fad3 	bl	801ecb4 <wolfSSL_Free>
        #endif
        return ret;
 802070e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020710:	e071      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
    }

    tmp[0] &= (byte)((1 << bits) - 1);
 8020712:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020714:	781a      	ldrb	r2, [r3, #0]
 8020716:	2101      	movs	r1, #1
 8020718:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802071a:	fa01 f303 	lsl.w	r3, r1, r3
 802071e:	b2db      	uxtb	r3, r3
 8020720:	3b01      	subs	r3, #1
 8020722:	b2db      	uxtb	r3, r3
 8020724:	4013      	ands	r3, r2
 8020726:	b2da      	uxtb	r2, r3
 8020728:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802072a:	701a      	strb	r2, [r3, #0]
    pkcsBlock[0] &= (byte)((1 << bits) - 1);
 802072c:	68fb      	ldr	r3, [r7, #12]
 802072e:	781a      	ldrb	r2, [r3, #0]
 8020730:	2101      	movs	r1, #1
 8020732:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020734:	fa01 f303 	lsl.w	r3, r1, r3
 8020738:	b2db      	uxtb	r3, r3
 802073a:	3b01      	subs	r3, #1
 802073c:	b2db      	uxtb	r3, r3
 802073e:	4013      	ands	r3, r2
 8020740:	b2da      	uxtb	r2, r3
 8020742:	68fb      	ldr	r3, [r7, #12]
 8020744:	701a      	strb	r2, [r3, #0]
        saltLen = maskLen - (i + 1);
    }
    else
#endif
    {
        for (i = 0; i < maskLen - 1 - saltLen; i++) {
 8020746:	2300      	movs	r3, #0
 8020748:	637b      	str	r3, [r7, #52]	@ 0x34
 802074a:	e017      	b.n	802077c <RsaUnPad_PSS+0x170>
            if (tmp[i] != pkcsBlock[i]) {
 802074c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802074e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8020750:	4413      	add	r3, r2
 8020752:	781a      	ldrb	r2, [r3, #0]
 8020754:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020756:	68f9      	ldr	r1, [r7, #12]
 8020758:	440b      	add	r3, r1
 802075a:	781b      	ldrb	r3, [r3, #0]
 802075c:	429a      	cmp	r2, r3
 802075e:	d00a      	beq.n	8020776 <RsaUnPad_PSS+0x16a>
                #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
                XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8020760:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020762:	61bb      	str	r3, [r7, #24]
 8020764:	69bb      	ldr	r3, [r7, #24]
 8020766:	2b00      	cmp	r3, #0
 8020768:	d002      	beq.n	8020770 <RsaUnPad_PSS+0x164>
 802076a:	69b8      	ldr	r0, [r7, #24]
 802076c:	f7fe faa2 	bl	801ecb4 <wolfSSL_Free>
                #endif
                WOLFSSL_MSG("RsaUnPad_PSS: Padding Error Match");
                return PSS_SALTLEN_E;
 8020770:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8020774:	e03f      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
        for (i = 0; i < maskLen - 1 - saltLen; i++) {
 8020776:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020778:	3301      	adds	r3, #1
 802077a:	637b      	str	r3, [r7, #52]	@ 0x34
 802077c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802077e:	1e5a      	subs	r2, r3, #1
 8020780:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020782:	1ad3      	subs	r3, r2, r3
 8020784:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8020786:	429a      	cmp	r2, r3
 8020788:	dbe0      	blt.n	802074c <RsaUnPad_PSS+0x140>
            }
        }
        if (tmp[i] != (pkcsBlock[i] ^ 0x01)) {
 802078a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802078c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802078e:	4413      	add	r3, r2
 8020790:	781a      	ldrb	r2, [r3, #0]
 8020792:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020794:	68f9      	ldr	r1, [r7, #12]
 8020796:	440b      	add	r3, r1
 8020798:	781b      	ldrb	r3, [r3, #0]
 802079a:	f083 0301 	eor.w	r3, r3, #1
 802079e:	b2db      	uxtb	r3, r3
 80207a0:	429a      	cmp	r2, r3
 80207a2:	d00a      	beq.n	80207ba <RsaUnPad_PSS+0x1ae>
            #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
            XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80207a4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80207a6:	61fb      	str	r3, [r7, #28]
 80207a8:	69fb      	ldr	r3, [r7, #28]
 80207aa:	2b00      	cmp	r3, #0
 80207ac:	d002      	beq.n	80207b4 <RsaUnPad_PSS+0x1a8>
 80207ae:	69f8      	ldr	r0, [r7, #28]
 80207b0:	f7fe fa80 	bl	801ecb4 <wolfSSL_Free>
            #endif
            WOLFSSL_MSG("RsaUnPad_PSS: Padding Error End");
            return PSS_SALTLEN_E;
 80207b4:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80207b8:	e01d      	b.n	80207f6 <RsaUnPad_PSS+0x1ea>
        }
    }
    xorbuf(pkcsBlock + i, tmp + i, (word32)(maskLen - i));
 80207ba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80207bc:	68fa      	ldr	r2, [r7, #12]
 80207be:	18d0      	adds	r0, r2, r3
 80207c0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80207c2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80207c4:	18d1      	adds	r1, r2, r3
 80207c6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80207c8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80207ca:	1ad3      	subs	r3, r2, r3
 80207cc:	461a      	mov	r2, r3
 80207ce:	f7ff fa68 	bl	801fca2 <xorbuf>

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
    XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80207d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80207d4:	623b      	str	r3, [r7, #32]
 80207d6:	6a3b      	ldr	r3, [r7, #32]
 80207d8:	2b00      	cmp	r3, #0
 80207da:	d002      	beq.n	80207e2 <RsaUnPad_PSS+0x1d6>
 80207dc:	6a38      	ldr	r0, [r7, #32]
 80207de:	f7fe fa69 	bl	801ecb4 <wolfSSL_Free>
#endif

    *output = pkcsBlock + maskLen - saltLen;
 80207e2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80207e4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80207e6:	1ad3      	subs	r3, r2, r3
 80207e8:	68fa      	ldr	r2, [r7, #12]
 80207ea:	441a      	add	r2, r3
 80207ec:	687b      	ldr	r3, [r7, #4]
 80207ee:	601a      	str	r2, [r3, #0]
    return saltLen + hLen;
 80207f0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80207f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80207f4:	4413      	add	r3, r2
}
 80207f6:	4618      	mov	r0, r3
 80207f8:	3738      	adds	r7, #56	@ 0x38
 80207fa:	46bd      	mov	sp, r7
 80207fc:	bd80      	pop	{r7, pc}

080207fe <RsaUnPad>:

/* UnPad plaintext, set start to *output, return length of plaintext,
 * < 0 on error */
static int RsaUnPad(const byte *pkcsBlock, unsigned int pkcsBlockLen,
                    byte **output, byte padValue)
{
 80207fe:	b590      	push	{r4, r7, lr}
 8020800:	b089      	sub	sp, #36	@ 0x24
 8020802:	af00      	add	r7, sp, #0
 8020804:	60f8      	str	r0, [r7, #12]
 8020806:	60b9      	str	r1, [r7, #8]
 8020808:	607a      	str	r2, [r7, #4]
 802080a:	70fb      	strb	r3, [r7, #3]
    int    ret = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 802080c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020810:	61fb      	str	r3, [r7, #28]
    word16 i;

    if (output == NULL || pkcsBlockLen < 2 || pkcsBlockLen > 0xFFFF) {
 8020812:	687b      	ldr	r3, [r7, #4]
 8020814:	2b00      	cmp	r3, #0
 8020816:	d006      	beq.n	8020826 <RsaUnPad+0x28>
 8020818:	68bb      	ldr	r3, [r7, #8]
 802081a:	2b01      	cmp	r3, #1
 802081c:	d903      	bls.n	8020826 <RsaUnPad+0x28>
 802081e:	68bb      	ldr	r3, [r7, #8]
 8020820:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8020824:	d302      	bcc.n	802082c <RsaUnPad+0x2e>
        return BAD_FUNC_ARG;
 8020826:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802082a:	e0a7      	b.n	802097c <RsaUnPad+0x17e>
    }

    if (padValue == RSA_BLOCK_TYPE_1) {
 802082c:	78fb      	ldrb	r3, [r7, #3]
 802082e:	2b01      	cmp	r3, #1
 8020830:	d134      	bne.n	802089c <RsaUnPad+0x9e>
        /* First byte must be 0x00 and Second byte, block type, 0x01 */
        if (pkcsBlock[0] != 0 || pkcsBlock[1] != RSA_BLOCK_TYPE_1) {
 8020832:	68fb      	ldr	r3, [r7, #12]
 8020834:	781b      	ldrb	r3, [r3, #0]
 8020836:	2b00      	cmp	r3, #0
 8020838:	d104      	bne.n	8020844 <RsaUnPad+0x46>
 802083a:	68fb      	ldr	r3, [r7, #12]
 802083c:	3301      	adds	r3, #1
 802083e:	781b      	ldrb	r3, [r3, #0]
 8020840:	2b01      	cmp	r3, #1
 8020842:	d002      	beq.n	802084a <RsaUnPad+0x4c>
            WOLFSSL_MSG("RsaUnPad error, invalid formatting");
            return RSA_PAD_E;
 8020844:	f06f 03c8 	mvn.w	r3, #200	@ 0xc8
 8020848:	e098      	b.n	802097c <RsaUnPad+0x17e>
        }

        /* check the padding until we find the separator */
        for (i = 2; i < pkcsBlockLen; ) {
 802084a:	2302      	movs	r3, #2
 802084c:	837b      	strh	r3, [r7, #26]
 802084e:	e008      	b.n	8020862 <RsaUnPad+0x64>
            if (pkcsBlock[i++] != 0xFF) {
 8020850:	8b7b      	ldrh	r3, [r7, #26]
 8020852:	1c5a      	adds	r2, r3, #1
 8020854:	837a      	strh	r2, [r7, #26]
 8020856:	461a      	mov	r2, r3
 8020858:	68fb      	ldr	r3, [r7, #12]
 802085a:	4413      	add	r3, r2
 802085c:	781b      	ldrb	r3, [r3, #0]
 802085e:	2bff      	cmp	r3, #255	@ 0xff
 8020860:	d104      	bne.n	802086c <RsaUnPad+0x6e>
        for (i = 2; i < pkcsBlockLen; ) {
 8020862:	8b7b      	ldrh	r3, [r7, #26]
 8020864:	68ba      	ldr	r2, [r7, #8]
 8020866:	429a      	cmp	r2, r3
 8020868:	d8f2      	bhi.n	8020850 <RsaUnPad+0x52>
 802086a:	e000      	b.n	802086e <RsaUnPad+0x70>
                break;
 802086c:	bf00      	nop
            }
        }

        /* Minimum of 11 bytes of pre-message data and must have separator. */
        if (i < RSA_MIN_PAD_SZ || pkcsBlock[i-1] != 0) {
 802086e:	8b7b      	ldrh	r3, [r7, #26]
 8020870:	2b0a      	cmp	r3, #10
 8020872:	d906      	bls.n	8020882 <RsaUnPad+0x84>
 8020874:	8b7b      	ldrh	r3, [r7, #26]
 8020876:	3b01      	subs	r3, #1
 8020878:	68fa      	ldr	r2, [r7, #12]
 802087a:	4413      	add	r3, r2
 802087c:	781b      	ldrb	r3, [r3, #0]
 802087e:	2b00      	cmp	r3, #0
 8020880:	d002      	beq.n	8020888 <RsaUnPad+0x8a>
            WOLFSSL_MSG("RsaUnPad error, bad formatting");
            return RSA_PAD_E;
 8020882:	f06f 03c8 	mvn.w	r3, #200	@ 0xc8
 8020886:	e079      	b.n	802097c <RsaUnPad+0x17e>
        }

        *output = (byte *)(pkcsBlock + i);
 8020888:	8b7b      	ldrh	r3, [r7, #26]
 802088a:	68fa      	ldr	r2, [r7, #12]
 802088c:	441a      	add	r2, r3
 802088e:	687b      	ldr	r3, [r7, #4]
 8020890:	601a      	str	r2, [r3, #0]
        ret = (int)pkcsBlockLen - i;
 8020892:	68ba      	ldr	r2, [r7, #8]
 8020894:	8b7b      	ldrh	r3, [r7, #26]
 8020896:	1ad3      	subs	r3, r2, r3
 8020898:	61fb      	str	r3, [r7, #28]
 802089a:	e06e      	b.n	802097a <RsaUnPad+0x17c>
    }
#ifndef WOLFSSL_RSA_VERIFY_ONLY
    else {
        unsigned int j;
        word16 pastSep = 0;
 802089c:	2300      	movs	r3, #0
 802089e:	827b      	strh	r3, [r7, #18]
        byte   invalid = 0;
 80208a0:	2300      	movs	r3, #0
 80208a2:	747b      	strb	r3, [r7, #17]

        i = 0;
 80208a4:	2300      	movs	r3, #0
 80208a6:	837b      	strh	r3, [r7, #26]
        /* Decrypted with private key - unpad must be constant time. */
        for (j = 2; j < pkcsBlockLen; j++) {
 80208a8:	2302      	movs	r3, #2
 80208aa:	617b      	str	r3, [r7, #20]
 80208ac:	e029      	b.n	8020902 <RsaUnPad+0x104>
           /* Update i if not passed the separator and at separator. */
            i |= (word16)(~pastSep) & ctMask16Eq(pkcsBlock[j], 0x00) &
 80208ae:	8a7b      	ldrh	r3, [r7, #18]
 80208b0:	43db      	mvns	r3, r3
 80208b2:	b29c      	uxth	r4, r3
 80208b4:	68fa      	ldr	r2, [r7, #12]
 80208b6:	697b      	ldr	r3, [r7, #20]
 80208b8:	4413      	add	r3, r2
 80208ba:	781b      	ldrb	r3, [r3, #0]
 80208bc:	2100      	movs	r1, #0
 80208be:	4618      	mov	r0, r3
 80208c0:	f7ff fb11 	bl	801fee6 <ctMask16Eq>
 80208c4:	4603      	mov	r3, r0
 80208c6:	4023      	ands	r3, r4
 80208c8:	b29a      	uxth	r2, r3
                (word16)(j + 1);
 80208ca:	697b      	ldr	r3, [r7, #20]
 80208cc:	b29b      	uxth	r3, r3
 80208ce:	3301      	adds	r3, #1
 80208d0:	b29b      	uxth	r3, r3
            i |= (word16)(~pastSep) & ctMask16Eq(pkcsBlock[j], 0x00) &
 80208d2:	4013      	ands	r3, r2
 80208d4:	b29b      	uxth	r3, r3
 80208d6:	b21a      	sxth	r2, r3
 80208d8:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80208dc:	4313      	orrs	r3, r2
 80208de:	b21b      	sxth	r3, r3
 80208e0:	837b      	strh	r3, [r7, #26]
            pastSep |= ctMask16Eq(pkcsBlock[j], 0x00);
 80208e2:	68fa      	ldr	r2, [r7, #12]
 80208e4:	697b      	ldr	r3, [r7, #20]
 80208e6:	4413      	add	r3, r2
 80208e8:	781b      	ldrb	r3, [r3, #0]
 80208ea:	2100      	movs	r1, #0
 80208ec:	4618      	mov	r0, r3
 80208ee:	f7ff fafa 	bl	801fee6 <ctMask16Eq>
 80208f2:	4603      	mov	r3, r0
 80208f4:	461a      	mov	r2, r3
 80208f6:	8a7b      	ldrh	r3, [r7, #18]
 80208f8:	4313      	orrs	r3, r2
 80208fa:	827b      	strh	r3, [r7, #18]
        for (j = 2; j < pkcsBlockLen; j++) {
 80208fc:	697b      	ldr	r3, [r7, #20]
 80208fe:	3301      	adds	r3, #1
 8020900:	617b      	str	r3, [r7, #20]
 8020902:	697a      	ldr	r2, [r7, #20]
 8020904:	68bb      	ldr	r3, [r7, #8]
 8020906:	429a      	cmp	r2, r3
 8020908:	d3d1      	bcc.n	80208ae <RsaUnPad+0xb0>
        }

        /* Minimum of 11 bytes of pre-message data - including leading 0x00. */
        invalid |= ctMaskLT(i, RSA_MIN_PAD_SZ);
 802090a:	8b7b      	ldrh	r3, [r7, #26]
 802090c:	210b      	movs	r1, #11
 802090e:	4618      	mov	r0, r3
 8020910:	f7ff fa86 	bl	801fe20 <ctMaskLT>
 8020914:	4603      	mov	r3, r0
 8020916:	461a      	mov	r2, r3
 8020918:	7c7b      	ldrb	r3, [r7, #17]
 802091a:	4313      	orrs	r3, r2
 802091c:	747b      	strb	r3, [r7, #17]
        /* Must have seen separator. */
        invalid |= (byte)~pastSep;
 802091e:	8a7b      	ldrh	r3, [r7, #18]
 8020920:	b2db      	uxtb	r3, r3
 8020922:	43db      	mvns	r3, r3
 8020924:	b2da      	uxtb	r2, r3
 8020926:	7c7b      	ldrb	r3, [r7, #17]
 8020928:	4313      	orrs	r3, r2
 802092a:	747b      	strb	r3, [r7, #17]
        /* First byte must be 0x00. */
        invalid |= ctMaskNotEq(pkcsBlock[0], 0x00);
 802092c:	68fb      	ldr	r3, [r7, #12]
 802092e:	781b      	ldrb	r3, [r3, #0]
 8020930:	2100      	movs	r1, #0
 8020932:	4618      	mov	r0, r3
 8020934:	f7ff faef 	bl	801ff16 <ctMaskNotEq>
 8020938:	4603      	mov	r3, r0
 802093a:	461a      	mov	r2, r3
 802093c:	7c7b      	ldrb	r3, [r7, #17]
 802093e:	4313      	orrs	r3, r2
 8020940:	747b      	strb	r3, [r7, #17]
        /* Check against expected block type: padValue */
        invalid |= ctMaskNotEq(pkcsBlock[1], padValue);
 8020942:	68fb      	ldr	r3, [r7, #12]
 8020944:	3301      	adds	r3, #1
 8020946:	781b      	ldrb	r3, [r3, #0]
 8020948:	461a      	mov	r2, r3
 802094a:	78fb      	ldrb	r3, [r7, #3]
 802094c:	4619      	mov	r1, r3
 802094e:	4610      	mov	r0, r2
 8020950:	f7ff fae1 	bl	801ff16 <ctMaskNotEq>
 8020954:	4603      	mov	r3, r0
 8020956:	461a      	mov	r2, r3
 8020958:	7c7b      	ldrb	r3, [r7, #17]
 802095a:	4313      	orrs	r3, r2
 802095c:	747b      	strb	r3, [r7, #17]

        *output = (byte *)(pkcsBlock + i);
 802095e:	8b7b      	ldrh	r3, [r7, #26]
 8020960:	68fa      	ldr	r2, [r7, #12]
 8020962:	441a      	add	r2, r3
 8020964:	687b      	ldr	r3, [r7, #4]
 8020966:	601a      	str	r2, [r3, #0]
        ret = ((int)-1 + (int)(invalid >> 7)) & ((int)pkcsBlockLen - i);
 8020968:	7c7b      	ldrb	r3, [r7, #17]
 802096a:	09db      	lsrs	r3, r3, #7
 802096c:	b2db      	uxtb	r3, r3
 802096e:	1e5a      	subs	r2, r3, #1
 8020970:	68b9      	ldr	r1, [r7, #8]
 8020972:	8b7b      	ldrh	r3, [r7, #26]
 8020974:	1acb      	subs	r3, r1, r3
 8020976:	4013      	ands	r3, r2
 8020978:	61fb      	str	r3, [r7, #28]
    }
#endif

    return ret;
 802097a:	69fb      	ldr	r3, [r7, #28]
}
 802097c:	4618      	mov	r0, r3
 802097e:	3724      	adds	r7, #36	@ 0x24
 8020980:	46bd      	mov	sp, r7
 8020982:	bd90      	pop	{r4, r7, pc}

08020984 <wc_RsaUnPad_ex>:
 */
int wc_RsaUnPad_ex(byte* pkcsBlock, word32 pkcsBlockLen, byte** out,
                   byte padValue, int padType, enum wc_HashType hType,
                   int mgf, byte* optLabel, word32 labelLen, int saltLen,
                   int bits, void* heap)
{
 8020984:	b580      	push	{r7, lr}
 8020986:	b08a      	sub	sp, #40	@ 0x28
 8020988:	af04      	add	r7, sp, #16
 802098a:	60f8      	str	r0, [r7, #12]
 802098c:	60b9      	str	r1, [r7, #8]
 802098e:	607a      	str	r2, [r7, #4]
 8020990:	70fb      	strb	r3, [r7, #3]
    int ret;

    switch (padType) {
 8020992:	6a3b      	ldr	r3, [r7, #32]
 8020994:	2b02      	cmp	r3, #2
 8020996:	d023      	beq.n	80209e0 <wc_RsaUnPad_ex+0x5c>
 8020998:	6a3b      	ldr	r3, [r7, #32]
 802099a:	2b02      	cmp	r3, #2
 802099c:	dc32      	bgt.n	8020a04 <wc_RsaUnPad_ex+0x80>
 802099e:	6a3b      	ldr	r3, [r7, #32]
 80209a0:	2b00      	cmp	r3, #0
 80209a2:	d003      	beq.n	80209ac <wc_RsaUnPad_ex+0x28>
 80209a4:	6a3b      	ldr	r3, [r7, #32]
 80209a6:	2b01      	cmp	r3, #1
 80209a8:	d008      	beq.n	80209bc <wc_RsaUnPad_ex+0x38>
 80209aa:	e02b      	b.n	8020a04 <wc_RsaUnPad_ex+0x80>
        case WC_RSA_PKCSV15_PAD:
            /*WOLFSSL_MSG("wolfSSL Using RSA PKCSV15 un-padding");*/
            ret = RsaUnPad(pkcsBlock, pkcsBlockLen, out, padValue);
 80209ac:	78fb      	ldrb	r3, [r7, #3]
 80209ae:	687a      	ldr	r2, [r7, #4]
 80209b0:	68b9      	ldr	r1, [r7, #8]
 80209b2:	68f8      	ldr	r0, [r7, #12]
 80209b4:	f7ff ff23 	bl	80207fe <RsaUnPad>
 80209b8:	6178      	str	r0, [r7, #20]
            break;
 80209ba:	e026      	b.n	8020a0a <wc_RsaUnPad_ex+0x86>

    #ifndef WC_NO_RSA_OAEP
        case WC_RSA_OAEP_PAD:
            WOLFSSL_MSG("wolfSSL Using RSA OAEP un-padding");
            ret = RsaUnPad_OAEP((byte*)pkcsBlock, pkcsBlockLen, out,
 80209bc:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
 80209c0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80209c2:	9303      	str	r3, [sp, #12]
 80209c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80209c6:	9302      	str	r3, [sp, #8]
 80209c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80209ca:	9301      	str	r3, [sp, #4]
 80209cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80209ce:	9300      	str	r3, [sp, #0]
 80209d0:	4613      	mov	r3, r2
 80209d2:	687a      	ldr	r2, [r7, #4]
 80209d4:	68b9      	ldr	r1, [r7, #8]
 80209d6:	68f8      	ldr	r0, [r7, #12]
 80209d8:	f7ff fd18 	bl	802040c <RsaUnPad_OAEP>
 80209dc:	6178      	str	r0, [r7, #20]
                                        hType, mgf, optLabel, labelLen, heap);
            break;
 80209de:	e014      	b.n	8020a0a <wc_RsaUnPad_ex+0x86>
    #endif

    #ifdef WC_RSA_PSS
        case WC_RSA_PSS_PAD:
            WOLFSSL_MSG("wolfSSL Using RSA PSS un-padding");
            ret = RsaUnPad_PSS((byte*)pkcsBlock, pkcsBlockLen, out, hType, mgf,
 80209e0:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
 80209e4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80209e6:	9303      	str	r3, [sp, #12]
 80209e8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80209ea:	9302      	str	r3, [sp, #8]
 80209ec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80209ee:	9301      	str	r3, [sp, #4]
 80209f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80209f2:	9300      	str	r3, [sp, #0]
 80209f4:	4613      	mov	r3, r2
 80209f6:	687a      	ldr	r2, [r7, #4]
 80209f8:	68b9      	ldr	r1, [r7, #8]
 80209fa:	68f8      	ldr	r0, [r7, #12]
 80209fc:	f7ff fe06 	bl	802060c <RsaUnPad_PSS>
 8020a00:	6178      	str	r0, [r7, #20]
                                                           saltLen, bits, heap);
            break;
 8020a02:	e002      	b.n	8020a0a <wc_RsaUnPad_ex+0x86>
            break;
    #endif /* WC_RSA_NO_PADDING */

        default:
            WOLFSSL_MSG("Unknown RSA UnPad Type");
            ret = RSA_PAD_E;
 8020a04:	f06f 03c8 	mvn.w	r3, #200	@ 0xc8
 8020a08:	617b      	str	r3, [r7, #20]
    (void)labelLen;
    (void)saltLen;
    (void)bits;
    (void)heap;

    return ret;
 8020a0a:	697b      	ldr	r3, [r7, #20]
}
 8020a0c:	4618      	mov	r0, r3
 8020a0e:	3718      	adds	r7, #24
 8020a10:	46bd      	mov	sp, r7
 8020a12:	bd80      	pop	{r7, pc}

08020a14 <RsaFunctionPrivate>:
#endif

#if !defined(WOLFSSL_SP_MATH)
#if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)
static int RsaFunctionPrivate(mp_int* tmp, RsaKey* key, WC_RNG* rng)
{
 8020a14:	b580      	push	{r7, lr}
 8020a16:	b08e      	sub	sp, #56	@ 0x38
 8020a18:	af00      	add	r7, sp, #0
 8020a1a:	60f8      	str	r0, [r7, #12]
 8020a1c:	60b9      	str	r1, [r7, #8]
 8020a1e:	607a      	str	r2, [r7, #4]
    int    ret = 0;
 8020a20:	2300      	movs	r3, #0
 8020a22:	637b      	str	r3, [r7, #52]	@ 0x34
#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
    mp_digit mp = 0;
 8020a24:	2300      	movs	r3, #0
 8020a26:	613b      	str	r3, [r7, #16]
    DECL_MP_INT_SIZE_DYN(rnd, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020a28:	2300      	movs	r3, #0
 8020a2a:	633b      	str	r3, [r7, #48]	@ 0x30
    DECL_MP_INT_SIZE_DYN(rndi, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020a2c:	2300      	movs	r3, #0
 8020a2e:	62fb      	str	r3, [r7, #44]	@ 0x2c
#endif /* WC_RSA_BLINDING && !WC_NO_RNG */

    (void)rng;

#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
    NEW_MP_INT_SIZE(rnd, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020a30:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8020a34:	f7fe f922 	bl	801ec7c <wolfSSL_Malloc>
 8020a38:	6338      	str	r0, [r7, #48]	@ 0x30
 8020a3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020a3c:	2b00      	cmp	r3, #0
 8020a3e:	d005      	beq.n	8020a4c <RsaFunctionPrivate+0x38>
 8020a40:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8020a44:	2100      	movs	r1, #0
 8020a46:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020a48:	f008 f8ec 	bl	8028c24 <memset>
    NEW_MP_INT_SIZE(rndi, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020a4c:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8020a50:	f7fe f914 	bl	801ec7c <wolfSSL_Malloc>
 8020a54:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8020a56:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020a58:	2b00      	cmp	r3, #0
 8020a5a:	d005      	beq.n	8020a68 <RsaFunctionPrivate+0x54>
 8020a5c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8020a60:	2100      	movs	r1, #0
 8020a62:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020a64:	f008 f8de 	bl	8028c24 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if ((rnd == NULL) || (rndi == NULL)) {
 8020a68:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020a6a:	2b00      	cmp	r3, #0
 8020a6c:	d002      	beq.n	8020a74 <RsaFunctionPrivate+0x60>
 8020a6e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020a70:	2b00      	cmp	r3, #0
 8020a72:	d112      	bne.n	8020a9a <RsaFunctionPrivate+0x86>
        FREE_MP_INT_SIZE(rnd, key->heap, DYNAMIC_TYPE_RSA);
 8020a74:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020a76:	61bb      	str	r3, [r7, #24]
 8020a78:	69bb      	ldr	r3, [r7, #24]
 8020a7a:	2b00      	cmp	r3, #0
 8020a7c:	d002      	beq.n	8020a84 <RsaFunctionPrivate+0x70>
 8020a7e:	69b8      	ldr	r0, [r7, #24]
 8020a80:	f7fe f918 	bl	801ecb4 <wolfSSL_Free>
        FREE_MP_INT_SIZE(rndi, key->heap, DYNAMIC_TYPE_RSA);
 8020a84:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020a86:	617b      	str	r3, [r7, #20]
 8020a88:	697b      	ldr	r3, [r7, #20]
 8020a8a:	2b00      	cmp	r3, #0
 8020a8c:	d002      	beq.n	8020a94 <RsaFunctionPrivate+0x80>
 8020a8e:	6978      	ldr	r0, [r7, #20]
 8020a90:	f7fe f910 	bl	801ecb4 <wolfSSL_Free>
        return MEMORY_E;
 8020a94:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020a98:	e15d      	b.n	8020d56 <RsaFunctionPrivate+0x342>
    }
#endif

    if ((INIT_MP_INT_SIZE(rnd, mp_bitsused(&key->n)) != MP_OKAY) ||
 8020a9a:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020a9c:	f005 ff9d 	bl	80269da <mp_init>
 8020aa0:	4603      	mov	r3, r0
 8020aa2:	2b00      	cmp	r3, #0
 8020aa4:	d105      	bne.n	8020ab2 <RsaFunctionPrivate+0x9e>
            (INIT_MP_INT_SIZE(rndi, mp_bitsused(&key->n)) != MP_OKAY)) {
 8020aa6:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020aa8:	f005 ff97 	bl	80269da <mp_init>
 8020aac:	4603      	mov	r3, r0
    if ((INIT_MP_INT_SIZE(rnd, mp_bitsused(&key->n)) != MP_OKAY) ||
 8020aae:	2b00      	cmp	r3, #0
 8020ab0:	d002      	beq.n	8020ab8 <RsaFunctionPrivate+0xa4>
        ret = MP_INIT_E;
 8020ab2:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8020ab6:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    if (ret == 0) {
 8020ab8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020aba:	2b00      	cmp	r3, #0
 8020abc:	d10a      	bne.n	8020ad4 <RsaFunctionPrivate+0xc0>
        /* blind */
        ret = mp_rand(rnd, get_digit_count(&key->n), rng);
 8020abe:	68bb      	ldr	r3, [r7, #8]
 8020ac0:	4618      	mov	r0, r3
 8020ac2:	f006 fe8e 	bl	80277e2 <get_digit_count>
 8020ac6:	4603      	mov	r3, r0
 8020ac8:	687a      	ldr	r2, [r7, #4]
 8020aca:	4619      	mov	r1, r3
 8020acc:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020ace:	f006 ff4c 	bl	802796a <mp_rand>
 8020ad2:	6378      	str	r0, [r7, #52]	@ 0x34
    }
    if (ret == 0) {
 8020ad4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020ad6:	2b00      	cmp	r3, #0
 8020ad8:	d10b      	bne.n	8020af2 <RsaFunctionPrivate+0xde>
        /* rndi = 1/rnd mod n */
        if (mp_invmod(rnd, &key->n, rndi) != MP_OKAY) {
 8020ada:	68bb      	ldr	r3, [r7, #8]
 8020adc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020ade:	4619      	mov	r1, r3
 8020ae0:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020ae2:	f006 f8c7 	bl	8026c74 <mp_invmod>
 8020ae6:	4603      	mov	r3, r0
 8020ae8:	2b00      	cmp	r3, #0
 8020aea:	d002      	beq.n	8020af2 <RsaFunctionPrivate+0xde>
            ret = MP_INVMOD_E;
 8020aec:	f06f 0376 	mvn.w	r3, #118	@ 0x76
 8020af0:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }
    if (ret == 0) {
 8020af2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020af4:	2b00      	cmp	r3, #0
 8020af6:	d10d      	bne.n	8020b14 <RsaFunctionPrivate+0x100>
        mp_memzero_add("RSA Private rndi", rndi);
    #endif

        /* rnd = rnd^e */
    #ifndef WOLFSSL_SP_MATH_ALL
        if (mp_exptmod(rnd, &key->e, &key->n, rnd) != MP_OKAY) {
 8020af8:	68bb      	ldr	r3, [r7, #8]
 8020afa:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 8020afe:	68ba      	ldr	r2, [r7, #8]
 8020b00:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020b02:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020b04:	f006 f8d8 	bl	8026cb8 <mp_exptmod>
 8020b08:	4603      	mov	r3, r0
 8020b0a:	2b00      	cmp	r3, #0
 8020b0c:	d002      	beq.n	8020b14 <RsaFunctionPrivate+0x100>
            ret = MP_EXPTMOD_E;
 8020b0e:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 8020b12:	637b      	str	r3, [r7, #52]	@ 0x34
            ret = MP_EXPTMOD_E;
        }
    #endif
    }

    if (ret == 0) {
 8020b14:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020b16:	2b00      	cmp	r3, #0
 8020b18:	d10b      	bne.n	8020b32 <RsaFunctionPrivate+0x11e>
        /* tmp = tmp*rnd mod n */
        if (mp_mulmod(tmp, rnd, &key->n, tmp) != MP_OKAY) {
 8020b1a:	68ba      	ldr	r2, [r7, #8]
 8020b1c:	68fb      	ldr	r3, [r7, #12]
 8020b1e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8020b20:	68f8      	ldr	r0, [r7, #12]
 8020b22:	f006 f85e 	bl	8026be2 <mp_mulmod>
 8020b26:	4603      	mov	r3, r0
 8020b28:	2b00      	cmp	r3, #0
 8020b2a:	d002      	beq.n	8020b32 <RsaFunctionPrivate+0x11e>
            ret = MP_MULMOD_E;
 8020b2c:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020b30:	637b      	str	r3, [r7, #52]	@ 0x34
        if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY) {
            ret = MP_EXPTMOD_E;
        }
    }
#else
    if (ret == 0 && (mp_iszero(&key->p) || mp_iszero(&key->q) ||
 8020b32:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020b34:	2b00      	cmp	r3, #0
 8020b36:	d132      	bne.n	8020b9e <RsaFunctionPrivate+0x18a>
 8020b38:	68bb      	ldr	r3, [r7, #8]
 8020b3a:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8020b3e:	4618      	mov	r0, r3
 8020b40:	f006 f9a5 	bl	8026e8e <mp_iszero>
 8020b44:	4603      	mov	r3, r0
 8020b46:	2b00      	cmp	r3, #0
 8020b48:	d11a      	bne.n	8020b80 <RsaFunctionPrivate+0x16c>
 8020b4a:	68bb      	ldr	r3, [r7, #8]
 8020b4c:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8020b50:	4618      	mov	r0, r3
 8020b52:	f006 f99c 	bl	8026e8e <mp_iszero>
 8020b56:	4603      	mov	r3, r0
 8020b58:	2b00      	cmp	r3, #0
 8020b5a:	d111      	bne.n	8020b80 <RsaFunctionPrivate+0x16c>
            mp_iszero(&key->dP) || mp_iszero(&key->dQ))) {
 8020b5c:	68bb      	ldr	r3, [r7, #8]
 8020b5e:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 8020b62:	4618      	mov	r0, r3
 8020b64:	f006 f993 	bl	8026e8e <mp_iszero>
 8020b68:	4603      	mov	r3, r0
    if (ret == 0 && (mp_iszero(&key->p) || mp_iszero(&key->q) ||
 8020b6a:	2b00      	cmp	r3, #0
 8020b6c:	d108      	bne.n	8020b80 <RsaFunctionPrivate+0x16c>
            mp_iszero(&key->dP) || mp_iszero(&key->dQ))) {
 8020b6e:	68bb      	ldr	r3, [r7, #8]
 8020b70:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 8020b74:	4618      	mov	r0, r3
 8020b76:	f006 f98a 	bl	8026e8e <mp_iszero>
 8020b7a:	4603      	mov	r3, r0
 8020b7c:	2b00      	cmp	r3, #0
 8020b7e:	d00e      	beq.n	8020b9e <RsaFunctionPrivate+0x18a>
        if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY) {
 8020b80:	68bb      	ldr	r3, [r7, #8]
 8020b82:	f503 618b 	add.w	r1, r3, #1112	@ 0x458
 8020b86:	68ba      	ldr	r2, [r7, #8]
 8020b88:	68fb      	ldr	r3, [r7, #12]
 8020b8a:	68f8      	ldr	r0, [r7, #12]
 8020b8c:	f006 f894 	bl	8026cb8 <mp_exptmod>
 8020b90:	4603      	mov	r3, r0
 8020b92:	2b00      	cmp	r3, #0
 8020b94:	d070      	beq.n	8020c78 <RsaFunctionPrivate+0x264>
            ret = MP_EXPTMOD_E;
 8020b96:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 8020b9a:	637b      	str	r3, [r7, #52]	@ 0x34
        if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY) {
 8020b9c:	e06c      	b.n	8020c78 <RsaFunctionPrivate+0x264>
        }
    }
    else if (ret == 0) {
 8020b9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020ba0:	2b00      	cmp	r3, #0
 8020ba2:	d169      	bne.n	8020c78 <RsaFunctionPrivate+0x264>
        mp_int* tmpa = tmp;
 8020ba4:	68fb      	ldr	r3, [r7, #12]
 8020ba6:	62bb      	str	r3, [r7, #40]	@ 0x28
#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
        mp_int* tmpb = rnd;
 8020ba8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020baa:	627b      	str	r3, [r7, #36]	@ 0x24
            mp_memzero_add("RSA Sync tmpb", tmpb);
        }
    #endif

        /* tmpb = tmp^dQ mod q */
        if (ret == 0 && mp_exptmod(tmp, &key->dQ, &key->q, tmpb) != MP_OKAY)
 8020bac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020bae:	2b00      	cmp	r3, #0
 8020bb0:	d10f      	bne.n	8020bd2 <RsaFunctionPrivate+0x1be>
 8020bb2:	68bb      	ldr	r3, [r7, #8]
 8020bb4:	f603 5108 	addw	r1, r3, #3336	@ 0xd08
 8020bb8:	68bb      	ldr	r3, [r7, #8]
 8020bba:	f503 620b 	add.w	r2, r3, #2224	@ 0x8b0
 8020bbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020bc0:	68f8      	ldr	r0, [r7, #12]
 8020bc2:	f006 f879 	bl	8026cb8 <mp_exptmod>
 8020bc6:	4603      	mov	r3, r0
 8020bc8:	2b00      	cmp	r3, #0
 8020bca:	d002      	beq.n	8020bd2 <RsaFunctionPrivate+0x1be>
            ret = MP_EXPTMOD_E;
 8020bcc:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 8020bd0:	637b      	str	r3, [r7, #52]	@ 0x34

        /* tmpa = tmp^dP mod p */
        if (ret == 0 && mp_exptmod(tmp, &key->dP, &key->p, tmpa) != MP_OKAY)
 8020bd2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020bd4:	2b00      	cmp	r3, #0
 8020bd6:	d10f      	bne.n	8020bf8 <RsaFunctionPrivate+0x1e4>
 8020bd8:	68bb      	ldr	r3, [r7, #8]
 8020bda:	f603 21dc 	addw	r1, r3, #2780	@ 0xadc
 8020bde:	68bb      	ldr	r3, [r7, #8]
 8020be0:	f203 6284 	addw	r2, r3, #1668	@ 0x684
 8020be4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020be6:	68f8      	ldr	r0, [r7, #12]
 8020be8:	f006 f866 	bl	8026cb8 <mp_exptmod>
 8020bec:	4603      	mov	r3, r0
 8020bee:	2b00      	cmp	r3, #0
 8020bf0:	d002      	beq.n	8020bf8 <RsaFunctionPrivate+0x1e4>
            ret = MP_EXPTMOD_E;
 8020bf2:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 8020bf6:	637b      	str	r3, [r7, #52]	@ 0x34
    #if (defined(WOLFSSL_SP_MATH) || (defined(WOLFSSL_SP_MATH_ALL)) && \
                                              !defined(WOLFSSL_SP_INT_NEGATIVE))
        if (ret == 0 && mp_submod(tmpa, tmpb, &key->p, tmp) != MP_OKAY)
            ret = MP_SUB_E;
    #else
        if (ret == 0 && mp_sub(tmpa, tmpb, tmp) != MP_OKAY)
 8020bf8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020bfa:	2b00      	cmp	r3, #0
 8020bfc:	d10a      	bne.n	8020c14 <RsaFunctionPrivate+0x200>
 8020bfe:	68fa      	ldr	r2, [r7, #12]
 8020c00:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8020c02:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8020c04:	f005 ffcd 	bl	8026ba2 <mp_sub>
 8020c08:	4603      	mov	r3, r0
 8020c0a:	2b00      	cmp	r3, #0
 8020c0c:	d002      	beq.n	8020c14 <RsaFunctionPrivate+0x200>
            ret = MP_SUB_E;
 8020c0e:	f06f 0371 	mvn.w	r3, #113	@ 0x71
 8020c12:	637b      	str	r3, [r7, #52]	@ 0x34
    #endif

        if (ret == 0 && mp_mulmod(tmp, &key->u, &key->p, tmp) != MP_OKAY)
 8020c14:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020c16:	2b00      	cmp	r3, #0
 8020c18:	d10f      	bne.n	8020c3a <RsaFunctionPrivate+0x226>
 8020c1a:	68bb      	ldr	r3, [r7, #8]
 8020c1c:	f603 7134 	addw	r1, r3, #3892	@ 0xf34
 8020c20:	68bb      	ldr	r3, [r7, #8]
 8020c22:	f203 6284 	addw	r2, r3, #1668	@ 0x684
 8020c26:	68fb      	ldr	r3, [r7, #12]
 8020c28:	68f8      	ldr	r0, [r7, #12]
 8020c2a:	f005 ffda 	bl	8026be2 <mp_mulmod>
 8020c2e:	4603      	mov	r3, r0
 8020c30:	2b00      	cmp	r3, #0
 8020c32:	d002      	beq.n	8020c3a <RsaFunctionPrivate+0x226>
            ret = MP_MULMOD_E;
 8020c34:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020c38:	637b      	str	r3, [r7, #52]	@ 0x34

        /* tmp = tmpb + q * tmp */
        if (ret == 0 && mp_mul(tmp, &key->q, tmp) != MP_OKAY)
 8020c3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020c3c:	2b00      	cmp	r3, #0
 8020c3e:	d10d      	bne.n	8020c5c <RsaFunctionPrivate+0x248>
 8020c40:	68bb      	ldr	r3, [r7, #8]
 8020c42:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8020c46:	68fa      	ldr	r2, [r7, #12]
 8020c48:	4619      	mov	r1, r3
 8020c4a:	68f8      	ldr	r0, [r7, #12]
 8020c4c:	f005 ffb9 	bl	8026bc2 <mp_mul>
 8020c50:	4603      	mov	r3, r0
 8020c52:	2b00      	cmp	r3, #0
 8020c54:	d002      	beq.n	8020c5c <RsaFunctionPrivate+0x248>
            ret = MP_MUL_E;
 8020c56:	f06f 0373 	mvn.w	r3, #115	@ 0x73
 8020c5a:	637b      	str	r3, [r7, #52]	@ 0x34

        if (ret == 0 && mp_add(tmp, tmpb, tmp) != MP_OKAY)
 8020c5c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020c5e:	2b00      	cmp	r3, #0
 8020c60:	d10a      	bne.n	8020c78 <RsaFunctionPrivate+0x264>
 8020c62:	68fa      	ldr	r2, [r7, #12]
 8020c64:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8020c66:	68f8      	ldr	r0, [r7, #12]
 8020c68:	f005 ff8b 	bl	8026b82 <mp_add>
 8020c6c:	4603      	mov	r3, r0
 8020c6e:	2b00      	cmp	r3, #0
 8020c70:	d002      	beq.n	8020c78 <RsaFunctionPrivate+0x264>
            ret = MP_ADD_E;
 8020c72:	f06f 0372 	mvn.w	r3, #114	@ 0x72
 8020c76:	637b      	str	r3, [r7, #52]	@ 0x34

#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
    /* Multiply result (tmp) by blinding invertor (rndi).
     * Use Montgomery form to make operation more constant time.
     */
    if ((ret == 0) && (mp_montgomery_setup(&key->n, &mp) != MP_OKAY)) {
 8020c78:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020c7a:	2b00      	cmp	r3, #0
 8020c7c:	d10c      	bne.n	8020c98 <RsaFunctionPrivate+0x284>
 8020c7e:	68bb      	ldr	r3, [r7, #8]
 8020c80:	f107 0210 	add.w	r2, r7, #16
 8020c84:	4611      	mov	r1, r2
 8020c86:	4618      	mov	r0, r3
 8020c88:	f006 fb84 	bl	8027394 <mp_montgomery_setup>
 8020c8c:	4603      	mov	r3, r0
 8020c8e:	2b00      	cmp	r3, #0
 8020c90:	d002      	beq.n	8020c98 <RsaFunctionPrivate+0x284>
        ret = MP_MULMOD_E;
 8020c92:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020c96:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    if ((ret == 0) && (mp_montgomery_calc_normalization(rnd, &key->n) !=
 8020c98:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020c9a:	2b00      	cmp	r3, #0
 8020c9c:	d10a      	bne.n	8020cb4 <RsaFunctionPrivate+0x2a0>
 8020c9e:	68bb      	ldr	r3, [r7, #8]
 8020ca0:	4619      	mov	r1, r3
 8020ca2:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020ca4:	f006 f929 	bl	8026efa <mp_montgomery_calc_normalization>
 8020ca8:	4603      	mov	r3, r0
 8020caa:	2b00      	cmp	r3, #0
 8020cac:	d002      	beq.n	8020cb4 <RsaFunctionPrivate+0x2a0>
            MP_OKAY)) {
        ret = MP_MULMOD_E;
 8020cae:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020cb2:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Convert blinding invert to Montgomery form. */
    if ((ret == 0) && (mp_mul(rndi, rnd, rndi) != MP_OKAY)) {
 8020cb4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020cb6:	2b00      	cmp	r3, #0
 8020cb8:	d10a      	bne.n	8020cd0 <RsaFunctionPrivate+0x2bc>
 8020cba:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020cbc:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8020cbe:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020cc0:	f005 ff7f 	bl	8026bc2 <mp_mul>
 8020cc4:	4603      	mov	r3, r0
 8020cc6:	2b00      	cmp	r3, #0
 8020cc8:	d002      	beq.n	8020cd0 <RsaFunctionPrivate+0x2bc>
        ret = MP_MULMOD_E;
 8020cca:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020cce:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    if ((ret == 0) && (mp_mod(rndi, &key->n, rndi) != MP_OKAY)) {
 8020cd0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020cd2:	2b00      	cmp	r3, #0
 8020cd4:	d10b      	bne.n	8020cee <RsaFunctionPrivate+0x2da>
 8020cd6:	68bb      	ldr	r3, [r7, #8]
 8020cd8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020cda:	4619      	mov	r1, r3
 8020cdc:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020cde:	f005 ffb9 	bl	8026c54 <mp_mod>
 8020ce2:	4603      	mov	r3, r0
 8020ce4:	2b00      	cmp	r3, #0
 8020ce6:	d002      	beq.n	8020cee <RsaFunctionPrivate+0x2da>
        ret = MP_MULMOD_E;
 8020ce8:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020cec:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Multiply result by blinding invert. */
    if ((ret == 0) && (mp_mul(tmp, rndi, tmp) != MP_OKAY)) {
 8020cee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020cf0:	2b00      	cmp	r3, #0
 8020cf2:	d10a      	bne.n	8020d0a <RsaFunctionPrivate+0x2f6>
 8020cf4:	68fa      	ldr	r2, [r7, #12]
 8020cf6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8020cf8:	68f8      	ldr	r0, [r7, #12]
 8020cfa:	f005 ff62 	bl	8026bc2 <mp_mul>
 8020cfe:	4603      	mov	r3, r0
 8020d00:	2b00      	cmp	r3, #0
 8020d02:	d002      	beq.n	8020d0a <RsaFunctionPrivate+0x2f6>
        ret = MP_MULMOD_E;
 8020d04:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020d08:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Reduce result. */
    if ((ret == 0) && (mp_montgomery_reduce_ct(tmp, &key->n, mp) != MP_OKAY)) {
 8020d0a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020d0c:	2b00      	cmp	r3, #0
 8020d0e:	d10b      	bne.n	8020d28 <RsaFunctionPrivate+0x314>
 8020d10:	68b9      	ldr	r1, [r7, #8]
 8020d12:	693a      	ldr	r2, [r7, #16]
 8020d14:	2301      	movs	r3, #1
 8020d16:	68f8      	ldr	r0, [r7, #12]
 8020d18:	f006 fb2a 	bl	8027370 <mp_montgomery_reduce_ex>
 8020d1c:	4603      	mov	r3, r0
 8020d1e:	2b00      	cmp	r3, #0
 8020d20:	d002      	beq.n	8020d28 <RsaFunctionPrivate+0x314>
        ret = MP_MULMOD_E;
 8020d22:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020d26:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    mp_forcezero(rndi);
 8020d28:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020d2a:	f005 fecb 	bl	8026ac4 <mp_forcezero>
    mp_forcezero(rnd);
 8020d2e:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020d30:	f005 fec8 	bl	8026ac4 <mp_forcezero>
    FREE_MP_INT_SIZE(rndi, key->heap, DYNAMIC_TYPE_RSA);
 8020d34:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020d36:	623b      	str	r3, [r7, #32]
 8020d38:	6a3b      	ldr	r3, [r7, #32]
 8020d3a:	2b00      	cmp	r3, #0
 8020d3c:	d002      	beq.n	8020d44 <RsaFunctionPrivate+0x330>
 8020d3e:	6a38      	ldr	r0, [r7, #32]
 8020d40:	f7fd ffb8 	bl	801ecb4 <wolfSSL_Free>
    FREE_MP_INT_SIZE(rnd, key->heap, DYNAMIC_TYPE_RSA);
 8020d44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020d46:	61fb      	str	r3, [r7, #28]
 8020d48:	69fb      	ldr	r3, [r7, #28]
 8020d4a:	2b00      	cmp	r3, #0
 8020d4c:	d002      	beq.n	8020d54 <RsaFunctionPrivate+0x340>
 8020d4e:	69f8      	ldr	r0, [r7, #28]
 8020d50:	f7fd ffb0 	bl	801ecb4 <wolfSSL_Free>
#if !defined(MP_INT_SIZE_CHECK_NULL) && defined(WOLFSSL_CHECK_MEM_ZERO)
    mp_memzero_check(rnd);
    mp_memzero_check(rndi);
#endif
#endif /* WC_RSA_BLINDING && !WC_NO_RNG */
    return ret;
 8020d54:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8020d56:	4618      	mov	r0, r3
 8020d58:	3738      	adds	r7, #56	@ 0x38
 8020d5a:	46bd      	mov	sp, r7
 8020d5c:	bd80      	pop	{r7, pc}

08020d5e <RsaFunctionSync>:
#endif

static int RsaFunctionSync(const byte* in, word32 inLen, byte* out,
    word32* outLen, int type, RsaKey* key, WC_RNG* rng)
{
 8020d5e:	b580      	push	{r7, lr}
 8020d60:	b088      	sub	sp, #32
 8020d62:	af00      	add	r7, sp, #0
 8020d64:	60f8      	str	r0, [r7, #12]
 8020d66:	60b9      	str	r1, [r7, #8]
 8020d68:	607a      	str	r2, [r7, #4]
 8020d6a:	603b      	str	r3, [r7, #0]
    DECL_MP_INT_SIZE_DYN(tmp, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020d6c:	2300      	movs	r3, #0
 8020d6e:	61bb      	str	r3, [r7, #24]
    int    ret = 0;
 8020d70:	2300      	movs	r3, #0
 8020d72:	61fb      	str	r3, [r7, #28]

    (void)rng;

    NEW_MP_INT_SIZE(tmp, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020d74:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8020d78:	f7fd ff80 	bl	801ec7c <wolfSSL_Malloc>
 8020d7c:	61b8      	str	r0, [r7, #24]
 8020d7e:	69bb      	ldr	r3, [r7, #24]
 8020d80:	2b00      	cmp	r3, #0
 8020d82:	d005      	beq.n	8020d90 <RsaFunctionSync+0x32>
 8020d84:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8020d88:	2100      	movs	r1, #0
 8020d8a:	69b8      	ldr	r0, [r7, #24]
 8020d8c:	f007 ff4a 	bl	8028c24 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (tmp == NULL) {
 8020d90:	69bb      	ldr	r3, [r7, #24]
 8020d92:	2b00      	cmp	r3, #0
 8020d94:	d102      	bne.n	8020d9c <RsaFunctionSync+0x3e>
        WOLFSSL_MSG("NEW_MP_INT_SIZE tmp is NULL, return MEMORY_E");
        return MEMORY_E;
 8020d96:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020d9a:	e05c      	b.n	8020e56 <RsaFunctionSync+0xf8>
    }
#endif

    if (INIT_MP_INT_SIZE(tmp, mp_bitsused(&key->n)) != MP_OKAY) {
 8020d9c:	69b8      	ldr	r0, [r7, #24]
 8020d9e:	f005 fe1c 	bl	80269da <mp_init>
 8020da2:	4603      	mov	r3, r0
 8020da4:	2b00      	cmp	r3, #0
 8020da6:	d002      	beq.n	8020dae <RsaFunctionSync+0x50>
        WOLFSSL_MSG("INIT_MP_INT_SIZE failed.");
        ret = MP_INIT_E;
 8020da8:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8020dac:	61fb      	str	r3, [r7, #28]
    }

#ifndef TEST_UNPAD_CONSTANT_TIME
    if (ret == 0 && mp_read_unsigned_bin(tmp, in, inLen) != MP_OKAY)
 8020dae:	69fb      	ldr	r3, [r7, #28]
 8020db0:	2b00      	cmp	r3, #0
 8020db2:	d10b      	bne.n	8020dcc <RsaFunctionSync+0x6e>
 8020db4:	68bb      	ldr	r3, [r7, #8]
 8020db6:	461a      	mov	r2, r3
 8020db8:	68f9      	ldr	r1, [r7, #12]
 8020dba:	69b8      	ldr	r0, [r7, #24]
 8020dbc:	f005 ffe6 	bl	8026d8c <mp_read_unsigned_bin>
 8020dc0:	4603      	mov	r3, r0
 8020dc2:	2b00      	cmp	r3, #0
 8020dc4:	d002      	beq.n	8020dcc <RsaFunctionSync+0x6e>
        ret = MP_READ_E;
 8020dc6:	f06f 036e 	mvn.w	r3, #110	@ 0x6e
 8020dca:	61fb      	str	r3, [r7, #28]
    if (ret == 0) {
        mp_memzero_add("RSA sync tmp", tmp);
    }
#endif

    if (ret == 0) {
 8020dcc:	69fb      	ldr	r3, [r7, #28]
 8020dce:	2b00      	cmp	r3, #0
 8020dd0:	d125      	bne.n	8020e1e <RsaFunctionSync+0xc0>
        switch(type) {
 8020dd2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020dd4:	2b01      	cmp	r3, #1
 8020dd6:	dc03      	bgt.n	8020de0 <RsaFunctionSync+0x82>
 8020dd8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020dda:	2b00      	cmp	r3, #0
 8020ddc:	da0b      	bge.n	8020df6 <RsaFunctionSync+0x98>
 8020dde:	e019      	b.n	8020e14 <RsaFunctionSync+0xb6>
 8020de0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020de2:	3b02      	subs	r3, #2
 8020de4:	2b01      	cmp	r3, #1
 8020de6:	d815      	bhi.n	8020e14 <RsaFunctionSync+0xb6>
    #if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)
        case RSA_PRIVATE_DECRYPT:
        case RSA_PRIVATE_ENCRYPT:
        {
            ret = RsaFunctionPrivate(tmp, key, rng);
 8020de8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8020dea:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8020dec:	69b8      	ldr	r0, [r7, #24]
 8020dee:	f7ff fe11 	bl	8020a14 <RsaFunctionPrivate>
 8020df2:	61f8      	str	r0, [r7, #28]
            break;
 8020df4:	e013      	b.n	8020e1e <RsaFunctionSync+0xc0>
        }
    #endif
        case RSA_PUBLIC_ENCRYPT:
        case RSA_PUBLIC_DECRYPT:
            if (mp_exptmod_nct(tmp, &key->e, &key->n, tmp) != MP_OKAY) {
 8020df6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020df8:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 8020dfc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020dfe:	69bb      	ldr	r3, [r7, #24]
 8020e00:	69b8      	ldr	r0, [r7, #24]
 8020e02:	f005 ff6b 	bl	8026cdc <mp_exptmod_nct>
 8020e06:	4603      	mov	r3, r0
 8020e08:	2b00      	cmp	r3, #0
 8020e0a:	d007      	beq.n	8020e1c <RsaFunctionSync+0xbe>
                WOLFSSL_MSG("mp_exptmod_nct failed");
                ret = MP_EXPTMOD_E;
 8020e0c:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 8020e10:	61fb      	str	r3, [r7, #28]
            }
            break;
 8020e12:	e003      	b.n	8020e1c <RsaFunctionSync+0xbe>
        default:
            ret = RSA_WRONG_TYPE_E;
 8020e14:	f06f 0381 	mvn.w	r3, #129	@ 0x81
 8020e18:	61fb      	str	r3, [r7, #28]
            break;
 8020e1a:	e000      	b.n	8020e1e <RsaFunctionSync+0xc0>
            break;
 8020e1c:	bf00      	nop
        }
    }

    if (ret == 0) {
 8020e1e:	69fb      	ldr	r3, [r7, #28]
 8020e20:	2b00      	cmp	r3, #0
 8020e22:	d10c      	bne.n	8020e3e <RsaFunctionSync+0xe0>
        WOLFSSL_MSG("mp_to_unsigned_bin_len_ct...");
        if (mp_to_unsigned_bin_len_ct(tmp, out, (int)*outLen) != MP_OKAY) {
 8020e24:	683b      	ldr	r3, [r7, #0]
 8020e26:	681b      	ldr	r3, [r3, #0]
 8020e28:	461a      	mov	r2, r3
 8020e2a:	6879      	ldr	r1, [r7, #4]
 8020e2c:	69b8      	ldr	r0, [r7, #24]
 8020e2e:	f005 ff9d 	bl	8026d6c <mp_to_unsigned_bin_len>
 8020e32:	4603      	mov	r3, r0
 8020e34:	2b00      	cmp	r3, #0
 8020e36:	d002      	beq.n	8020e3e <RsaFunctionSync+0xe0>
            WOLFSSL_MSG("mp_to_unsigned_bin_len_ct failed");
            ret = MP_TO_E;
 8020e38:	f06f 0370 	mvn.w	r3, #112	@ 0x70
 8020e3c:	61fb      	str	r3, [r7, #28]
    (void)type;
    (void)key;
    XMEMCPY(out, in, inLen);
#endif

    mp_forcezero(tmp);
 8020e3e:	69b8      	ldr	r0, [r7, #24]
 8020e40:	f005 fe40 	bl	8026ac4 <mp_forcezero>
    FREE_MP_INT_SIZE(tmp, key->heap, DYNAMIC_TYPE_RSA);
 8020e44:	69bb      	ldr	r3, [r7, #24]
 8020e46:	617b      	str	r3, [r7, #20]
 8020e48:	697b      	ldr	r3, [r7, #20]
 8020e4a:	2b00      	cmp	r3, #0
 8020e4c:	d002      	beq.n	8020e54 <RsaFunctionSync+0xf6>
 8020e4e:	6978      	ldr	r0, [r7, #20]
 8020e50:	f7fd ff30 	bl	801ecb4 <wolfSSL_Free>
#if !defined(MP_INT_SIZE_CHECK_NULL) && defined(WOLFSSL_CHECK_MEM_ZERO)
    mp_memzero_check(tmp);
#endif
    return ret;
 8020e54:	69fb      	ldr	r3, [r7, #28]
}
 8020e56:	4618      	mov	r0, r3
 8020e58:	3720      	adds	r7, #32
 8020e5a:	46bd      	mov	sp, r7
 8020e5c:	bd80      	pop	{r7, pc}

08020e5e <wc_RsaFunctionSync>:
#endif /* !WOLFSSL_SP_MATH */

static int wc_RsaFunctionSync(const byte* in, word32 inLen, byte* out,
                          word32* outLen, int type, RsaKey* key, WC_RNG* rng)
{
 8020e5e:	b580      	push	{r7, lr}
 8020e60:	b08a      	sub	sp, #40	@ 0x28
 8020e62:	af04      	add	r7, sp, #16
 8020e64:	60f8      	str	r0, [r7, #12]
 8020e66:	60b9      	str	r1, [r7, #8]
 8020e68:	607a      	str	r2, [r7, #4]
 8020e6a:	603b      	str	r3, [r7, #0]
    int ret;
    word32 keyLen;

    ret = wc_RsaEncryptSize(key);
 8020e6c:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8020e6e:	f000 fbb3 	bl	80215d8 <wc_RsaEncryptSize>
 8020e72:	6178      	str	r0, [r7, #20]
    if (ret < 0) {
 8020e74:	697b      	ldr	r3, [r7, #20]
 8020e76:	2b00      	cmp	r3, #0
 8020e78:	da01      	bge.n	8020e7e <wc_RsaFunctionSync+0x20>
#ifdef DEBUG_WOLFSSL
        WOLFSSL_MSG_EX("wc_RsaEncryptSize failed err = %d", ret);
#endif
        return ret;
 8020e7a:	697b      	ldr	r3, [r7, #20]
 8020e7c:	e02d      	b.n	8020eda <wc_RsaFunctionSync+0x7c>
    }
    keyLen = (word32)ret;
 8020e7e:	697b      	ldr	r3, [r7, #20]
 8020e80:	613b      	str	r3, [r7, #16]

    if (inLen > keyLen) {
 8020e82:	68ba      	ldr	r2, [r7, #8]
 8020e84:	693b      	ldr	r3, [r7, #16]
 8020e86:	429a      	cmp	r2, r3
 8020e88:	d902      	bls.n	8020e90 <wc_RsaFunctionSync+0x32>
        WOLFSSL_MSG("Expected that inLen be no longer RSA key length");
        return BAD_FUNC_ARG;
 8020e8a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020e8e:	e024      	b.n	8020eda <wc_RsaFunctionSync+0x7c>
    }
    if (keyLen > *outLen) {
 8020e90:	683b      	ldr	r3, [r7, #0]
 8020e92:	681b      	ldr	r3, [r3, #0]
 8020e94:	693a      	ldr	r2, [r7, #16]
 8020e96:	429a      	cmp	r2, r3
 8020e98:	d902      	bls.n	8020ea0 <wc_RsaFunctionSync+0x42>
        WOLFSSL_MSG("Expected that outLen be no shorter RSA key length");
        return RSA_BUFFER_E;
 8020e9a:	f06f 0382 	mvn.w	r3, #130	@ 0x82
 8020e9e:	e01c      	b.n	8020eda <wc_RsaFunctionSync+0x7c>
    }

    if (mp_iseven(&key->n)) {
 8020ea0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020ea2:	681b      	ldr	r3, [r3, #0]
 8020ea4:	2b00      	cmp	r3, #0
 8020ea6:	dd08      	ble.n	8020eba <wc_RsaFunctionSync+0x5c>
 8020ea8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020eaa:	68db      	ldr	r3, [r3, #12]
 8020eac:	f003 0301 	and.w	r3, r3, #1
 8020eb0:	2b00      	cmp	r3, #0
 8020eb2:	d102      	bne.n	8020eba <wc_RsaFunctionSync+0x5c>
        WOLFSSL_MSG("MP_VAL is even");
        return MP_VAL;
 8020eb4:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8020eb8:	e00f      	b.n	8020eda <wc_RsaFunctionSync+0x7c>
#else
    WOLFSSL_MSG("SP Key Size Error");
    return WC_KEY_SIZE_E;
#endif
#else
    *outLen = keyLen;
 8020eba:	683b      	ldr	r3, [r7, #0]
 8020ebc:	693a      	ldr	r2, [r7, #16]
 8020ebe:	601a      	str	r2, [r3, #0]
    return RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
 8020ec0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020ec2:	9302      	str	r3, [sp, #8]
 8020ec4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020ec6:	9301      	str	r3, [sp, #4]
 8020ec8:	6a3b      	ldr	r3, [r7, #32]
 8020eca:	9300      	str	r3, [sp, #0]
 8020ecc:	683b      	ldr	r3, [r7, #0]
 8020ece:	687a      	ldr	r2, [r7, #4]
 8020ed0:	68b9      	ldr	r1, [r7, #8]
 8020ed2:	68f8      	ldr	r0, [r7, #12]
 8020ed4:	f7ff ff43 	bl	8020d5e <RsaFunctionSync>
 8020ed8:	4603      	mov	r3, r0
#endif /* WOLFSSL_SP_MATH */
}
 8020eda:	4618      	mov	r0, r3
 8020edc:	3718      	adds	r7, #24
 8020ede:	46bd      	mov	sp, r7
 8020ee0:	bd80      	pop	{r7, pc}

08020ee2 <RsaFunctionCheckIn>:
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(TEST_UNPAD_CONSTANT_TIME) && \
    !defined(NO_RSA_BOUNDS_CHECK)
/* Check that 1 < in < n-1. (Requirement of 800-56B.) */
int RsaFunctionCheckIn(const byte* in, word32 inLen, RsaKey* key,
    int checkSmallCt)
{
 8020ee2:	b580      	push	{r7, lr}
 8020ee4:	b088      	sub	sp, #32
 8020ee6:	af00      	add	r7, sp, #0
 8020ee8:	60f8      	str	r0, [r7, #12]
 8020eea:	60b9      	str	r1, [r7, #8]
 8020eec:	607a      	str	r2, [r7, #4]
 8020eee:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8020ef0:	2300      	movs	r3, #0
 8020ef2:	61fb      	str	r3, [r7, #28]
    DECL_MP_INT_SIZE_DYN(c, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020ef4:	2300      	movs	r3, #0
 8020ef6:	61bb      	str	r3, [r7, #24]

    NEW_MP_INT_SIZE(c, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020ef8:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8020efc:	f7fd febe 	bl	801ec7c <wolfSSL_Malloc>
 8020f00:	61b8      	str	r0, [r7, #24]
 8020f02:	69bb      	ldr	r3, [r7, #24]
 8020f04:	2b00      	cmp	r3, #0
 8020f06:	d005      	beq.n	8020f14 <RsaFunctionCheckIn+0x32>
 8020f08:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8020f0c:	2100      	movs	r1, #0
 8020f0e:	69b8      	ldr	r0, [r7, #24]
 8020f10:	f007 fe88 	bl	8028c24 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (c == NULL)
 8020f14:	69bb      	ldr	r3, [r7, #24]
 8020f16:	2b00      	cmp	r3, #0
 8020f18:	d102      	bne.n	8020f20 <RsaFunctionCheckIn+0x3e>
        ret = MEMORY_E;
 8020f1a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020f1e:	61fb      	str	r3, [r7, #28]
#endif

    if (ret == 0 && INIT_MP_INT_SIZE(c, mp_bitsused(&key->n)) != MP_OKAY) {
 8020f20:	69fb      	ldr	r3, [r7, #28]
 8020f22:	2b00      	cmp	r3, #0
 8020f24:	d108      	bne.n	8020f38 <RsaFunctionCheckIn+0x56>
 8020f26:	69b8      	ldr	r0, [r7, #24]
 8020f28:	f005 fd57 	bl	80269da <mp_init>
 8020f2c:	4603      	mov	r3, r0
 8020f2e:	2b00      	cmp	r3, #0
 8020f30:	d002      	beq.n	8020f38 <RsaFunctionCheckIn+0x56>
        ret = MP_INIT_E;
 8020f32:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8020f36:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020f38:	69fb      	ldr	r3, [r7, #28]
 8020f3a:	2b00      	cmp	r3, #0
 8020f3c:	d10b      	bne.n	8020f56 <RsaFunctionCheckIn+0x74>
        if (mp_read_unsigned_bin(c, in, inLen) != 0)
 8020f3e:	68bb      	ldr	r3, [r7, #8]
 8020f40:	461a      	mov	r2, r3
 8020f42:	68f9      	ldr	r1, [r7, #12]
 8020f44:	69b8      	ldr	r0, [r7, #24]
 8020f46:	f005 ff21 	bl	8026d8c <mp_read_unsigned_bin>
 8020f4a:	4603      	mov	r3, r0
 8020f4c:	2b00      	cmp	r3, #0
 8020f4e:	d002      	beq.n	8020f56 <RsaFunctionCheckIn+0x74>
            ret = MP_READ_E;
 8020f50:	f06f 036e 	mvn.w	r3, #110	@ 0x6e
 8020f54:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020f56:	69fb      	ldr	r3, [r7, #28]
 8020f58:	2b00      	cmp	r3, #0
 8020f5a:	d10c      	bne.n	8020f76 <RsaFunctionCheckIn+0x94>
        /* check c > 1 */
        if (checkSmallCt && (mp_cmp_d(c, 1) != MP_GT))
 8020f5c:	683b      	ldr	r3, [r7, #0]
 8020f5e:	2b00      	cmp	r3, #0
 8020f60:	d009      	beq.n	8020f76 <RsaFunctionCheckIn+0x94>
 8020f62:	2101      	movs	r1, #1
 8020f64:	69b8      	ldr	r0, [r7, #24]
 8020f66:	f005 fed9 	bl	8026d1c <mp_cmp_d>
 8020f6a:	4603      	mov	r3, r0
 8020f6c:	2b01      	cmp	r3, #1
 8020f6e:	d002      	beq.n	8020f76 <RsaFunctionCheckIn+0x94>
            ret = RSA_OUT_OF_RANGE_E;
 8020f70:	f06f 03fc 	mvn.w	r3, #252	@ 0xfc
 8020f74:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020f76:	69fb      	ldr	r3, [r7, #28]
 8020f78:	2b00      	cmp	r3, #0
 8020f7a:	d10a      	bne.n	8020f92 <RsaFunctionCheckIn+0xb0>
        /* add c+1 */
        if (mp_add_d(c, 1, c) != MP_OKAY)
 8020f7c:	69ba      	ldr	r2, [r7, #24]
 8020f7e:	2101      	movs	r1, #1
 8020f80:	69b8      	ldr	r0, [r7, #24]
 8020f82:	f006 f88a 	bl	802709a <mp_add_d>
 8020f86:	4603      	mov	r3, r0
 8020f88:	2b00      	cmp	r3, #0
 8020f8a:	d002      	beq.n	8020f92 <RsaFunctionCheckIn+0xb0>
            ret = MP_ADD_E;
 8020f8c:	f06f 0372 	mvn.w	r3, #114	@ 0x72
 8020f90:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020f92:	69fb      	ldr	r3, [r7, #28]
 8020f94:	2b00      	cmp	r3, #0
 8020f96:	d10b      	bne.n	8020fb0 <RsaFunctionCheckIn+0xce>
        /* check c+1 < n */
        if (mp_cmp(c, &key->n) != MP_LT)
 8020f98:	687b      	ldr	r3, [r7, #4]
 8020f9a:	4619      	mov	r1, r3
 8020f9c:	69b8      	ldr	r0, [r7, #24]
 8020f9e:	f005 feaf 	bl	8026d00 <mp_cmp>
 8020fa2:	4603      	mov	r3, r0
 8020fa4:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8020fa8:	d002      	beq.n	8020fb0 <RsaFunctionCheckIn+0xce>
            ret = RSA_OUT_OF_RANGE_E;
 8020faa:	f06f 03fc 	mvn.w	r3, #252	@ 0xfc
 8020fae:	61fb      	str	r3, [r7, #28]
    }
    mp_clear(c);
 8020fb0:	69b8      	ldr	r0, [r7, #24]
 8020fb2:	f005 fd9c 	bl	8026aee <mp_clear>

    FREE_MP_INT_SIZE(c, key->heap, DYNAMIC_TYPE_RSA);
 8020fb6:	69bb      	ldr	r3, [r7, #24]
 8020fb8:	617b      	str	r3, [r7, #20]
 8020fba:	697b      	ldr	r3, [r7, #20]
 8020fbc:	2b00      	cmp	r3, #0
 8020fbe:	d002      	beq.n	8020fc6 <RsaFunctionCheckIn+0xe4>
 8020fc0:	6978      	ldr	r0, [r7, #20]
 8020fc2:	f7fd fe77 	bl	801ecb4 <wolfSSL_Free>

    return ret;
 8020fc6:	69fb      	ldr	r3, [r7, #28]
}
 8020fc8:	4618      	mov	r0, r3
 8020fca:	3720      	adds	r7, #32
 8020fcc:	46bd      	mov	sp, r7
 8020fce:	bd80      	pop	{r7, pc}

08020fd0 <wc_RsaFunction_ex>:
#endif /* WOLF_CRYPTO_CB_ONLY_RSA */

static int wc_RsaFunction_ex(const byte* in, word32 inLen, byte* out,
                             word32* outLen, int type, RsaKey* key, WC_RNG* rng,
                             int checkSmallCt)
{
 8020fd0:	b580      	push	{r7, lr}
 8020fd2:	b08a      	sub	sp, #40	@ 0x28
 8020fd4:	af04      	add	r7, sp, #16
 8020fd6:	60f8      	str	r0, [r7, #12]
 8020fd8:	60b9      	str	r1, [r7, #8]
 8020fda:	607a      	str	r2, [r7, #4]
 8020fdc:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8020fde:	2300      	movs	r3, #0
 8020fe0:	617b      	str	r3, [r7, #20]
    (void)checkSmallCt;
#if defined(WOLF_CRYPTO_CB) && defined(WOLF_CRYPTO_CB_RSA_PAD)
    RsaPadding padding;
#endif

    if (key == NULL || in == NULL || inLen == 0 || out == NULL ||
 8020fe2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020fe4:	2b00      	cmp	r3, #0
 8020fe6:	d013      	beq.n	8021010 <wc_RsaFunction_ex+0x40>
 8020fe8:	68fb      	ldr	r3, [r7, #12]
 8020fea:	2b00      	cmp	r3, #0
 8020fec:	d010      	beq.n	8021010 <wc_RsaFunction_ex+0x40>
 8020fee:	68bb      	ldr	r3, [r7, #8]
 8020ff0:	2b00      	cmp	r3, #0
 8020ff2:	d00d      	beq.n	8021010 <wc_RsaFunction_ex+0x40>
 8020ff4:	687b      	ldr	r3, [r7, #4]
 8020ff6:	2b00      	cmp	r3, #0
 8020ff8:	d00a      	beq.n	8021010 <wc_RsaFunction_ex+0x40>
 8020ffa:	683b      	ldr	r3, [r7, #0]
 8020ffc:	2b00      	cmp	r3, #0
 8020ffe:	d007      	beq.n	8021010 <wc_RsaFunction_ex+0x40>
            outLen == NULL || *outLen == 0 || type == RSA_TYPE_UNKNOWN) {
 8021000:	683b      	ldr	r3, [r7, #0]
 8021002:	681b      	ldr	r3, [r3, #0]
 8021004:	2b00      	cmp	r3, #0
 8021006:	d003      	beq.n	8021010 <wc_RsaFunction_ex+0x40>
 8021008:	6a3b      	ldr	r3, [r7, #32]
 802100a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 802100e:	d102      	bne.n	8021016 <wc_RsaFunction_ex+0x46>
        return BAD_FUNC_ARG;
 8021010:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8021014:	e034      	b.n	8021080 <wc_RsaFunction_ex+0xb0>
#else /* !WOLF_CRYPTO_CB_ONLY_RSA */
    SAVE_VECTOR_REGISTERS(return _svr_ret;);

#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(TEST_UNPAD_CONSTANT_TIME) && \
    !defined(NO_RSA_BOUNDS_CHECK)
    if (type == RSA_PRIVATE_DECRYPT &&
 8021016:	6a3b      	ldr	r3, [r7, #32]
 8021018:	2b03      	cmp	r3, #3
 802101a:	d112      	bne.n	8021042 <wc_RsaFunction_ex+0x72>
        key->state == RSA_STATE_DECRYPT_EXPTMOD) {
 802101c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802101e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021022:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
    if (type == RSA_PRIVATE_DECRYPT &&
 8021026:	2b04      	cmp	r3, #4
 8021028:	d10b      	bne.n	8021042 <wc_RsaFunction_ex+0x72>

        ret = RsaFunctionCheckIn(in, inLen, key, checkSmallCt);
 802102a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802102c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802102e:	68b9      	ldr	r1, [r7, #8]
 8021030:	68f8      	ldr	r0, [r7, #12]
 8021032:	f7ff ff56 	bl	8020ee2 <RsaFunctionCheckIn>
 8021036:	6178      	str	r0, [r7, #20]
        if (ret != 0) {
 8021038:	697b      	ldr	r3, [r7, #20]
 802103a:	2b00      	cmp	r3, #0
 802103c:	d001      	beq.n	8021042 <wc_RsaFunction_ex+0x72>
            RESTORE_VECTOR_REGISTERS();
            return ret;
 802103e:	697b      	ldr	r3, [r7, #20]
 8021040:	e01e      	b.n	8021080 <wc_RsaFunction_ex+0xb0>
        ret = wc_RsaFunctionNonBlock(in, inLen, out, outLen, type, key);
    }
    else
#endif
    {
        ret = wc_RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
 8021042:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021044:	9302      	str	r3, [sp, #8]
 8021046:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021048:	9301      	str	r3, [sp, #4]
 802104a:	6a3b      	ldr	r3, [r7, #32]
 802104c:	9300      	str	r3, [sp, #0]
 802104e:	683b      	ldr	r3, [r7, #0]
 8021050:	687a      	ldr	r2, [r7, #4]
 8021052:	68b9      	ldr	r1, [r7, #8]
 8021054:	68f8      	ldr	r0, [r7, #12]
 8021056:	f7ff ff02 	bl	8020e5e <wc_RsaFunctionSync>
 802105a:	6178      	str	r0, [r7, #20]
    }

    RESTORE_VECTOR_REGISTERS();

    /* handle error */
    if (ret < 0 && ret != WC_NO_ERR_TRACE(WC_PENDING_E)
 802105c:	697b      	ldr	r3, [r7, #20]
 802105e:	2b00      	cmp	r3, #0
 8021060:	da0d      	bge.n	802107e <wc_RsaFunction_ex+0xae>
 8021062:	697b      	ldr	r3, [r7, #20]
 8021064:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 8021068:	d009      	beq.n	802107e <wc_RsaFunction_ex+0xae>
        if (ret == WC_NO_ERR_TRACE(MP_EXPTMOD_E)) {
            /* This can happen due to incorrectly set FP_MAX_BITS or missing XREALLOC */
            WOLFSSL_MSG("RSA_FUNCTION MP_EXPTMOD_E: memory/config problem");
        }

        key->state = RSA_STATE_NONE;
 802106a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802106c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021070:	461a      	mov	r2, r3
 8021072:	2300      	movs	r3, #0
 8021074:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
        wc_RsaCleanup(key);
 8021078:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 802107a:	f7fe ff93 	bl	801ffa4 <wc_RsaCleanup>
    }
    return ret;
 802107e:	697b      	ldr	r3, [r7, #20]
#endif /* !WOLF_CRYPTO_CB_ONLY_RSA */
}
 8021080:	4618      	mov	r0, r3
 8021082:	3718      	adds	r7, #24
 8021084:	46bd      	mov	sp, r7
 8021086:	bd80      	pop	{r7, pc}

08021088 <RsaPrivateDecryptEx>:
                            word32 outLen, byte** outPtr, RsaKey* key,
                            int rsa_type, byte pad_value, int pad_type,
                            enum wc_HashType hash, int mgf,
                            byte* label, word32 labelSz, int saltLen,
                            WC_RNG* rng)
{
 8021088:	b5b0      	push	{r4, r5, r7, lr}
 802108a:	b092      	sub	sp, #72	@ 0x48
 802108c:	af08      	add	r7, sp, #32
 802108e:	60f8      	str	r0, [r7, #12]
 8021090:	60b9      	str	r1, [r7, #8]
 8021092:	607a      	str	r2, [r7, #4]
 8021094:	603b      	str	r3, [r7, #0]
    int ret = WC_NO_ERR_TRACE(RSA_WRONG_TYPE_E);
 8021096:	f06f 0381 	mvn.w	r3, #129	@ 0x81
 802109a:	627b      	str	r3, [r7, #36]	@ 0x24
    byte* pad = NULL;
 802109c:	2300      	movs	r3, #0
 802109e:	613b      	str	r3, [r7, #16]
#if defined(WOLF_CRYPTO_CB) && defined(WOLF_CRYPTO_CB_RSA_PAD)
    RsaPadding padding;
#endif

    if (in == NULL || inLen == 0 || out == NULL || key == NULL) {
 80210a0:	68fb      	ldr	r3, [r7, #12]
 80210a2:	2b00      	cmp	r3, #0
 80210a4:	d008      	beq.n	80210b8 <RsaPrivateDecryptEx+0x30>
 80210a6:	68bb      	ldr	r3, [r7, #8]
 80210a8:	2b00      	cmp	r3, #0
 80210aa:	d005      	beq.n	80210b8 <RsaPrivateDecryptEx+0x30>
 80210ac:	687b      	ldr	r3, [r7, #4]
 80210ae:	2b00      	cmp	r3, #0
 80210b0:	d002      	beq.n	80210b8 <RsaPrivateDecryptEx+0x30>
 80210b2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80210b4:	2b00      	cmp	r3, #0
 80210b6:	d102      	bne.n	80210be <RsaPrivateDecryptEx+0x36>
        return BAD_FUNC_ARG;
 80210b8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80210bc:	e164      	b.n	8021388 <RsaPrivateDecryptEx+0x300>
    }

    switch (key->state) {
 80210be:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80210c0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80210c4:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 80210c8:	2b06      	cmp	r3, #6
 80210ca:	f200 8145 	bhi.w	8021358 <RsaPrivateDecryptEx+0x2d0>
 80210ce:	a201      	add	r2, pc, #4	@ (adr r2, 80210d4 <RsaPrivateDecryptEx+0x4c>)
 80210d0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80210d4:	080210f1 	.word	0x080210f1
 80210d8:	08021359 	.word	0x08021359
 80210dc:	08021359 	.word	0x08021359
 80210e0:	08021359 	.word	0x08021359
 80210e4:	0802119b 	.word	0x0802119b
 80210e8:	080211ff 	.word	0x080211ff
 80210ec:	08021361 	.word	0x08021361
    case RSA_STATE_NONE:
        key->dataLen = inLen;
 80210f0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80210f2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80210f6:	461a      	mov	r2, r3
 80210f8:	68bb      	ldr	r3, [r7, #8]
 80210fa:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170


#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
        /* verify the tmp ptr is NULL, otherwise indicates bad state */
        if (key->data != NULL) {
 80210fe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021100:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021104:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8021108:	2b00      	cmp	r3, #0
 802110a:	d003      	beq.n	8021114 <RsaPrivateDecryptEx+0x8c>
            ret = BAD_STATE_E;
 802110c:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 8021110:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 8021112:	e128      	b.n	8021366 <RsaPrivateDecryptEx+0x2de>
        }

        /* if not doing this inline then allocate a buffer for it */
        if (outPtr == NULL) {
 8021114:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8021116:	2b00      	cmp	r3, #0
 8021118:	d12b      	bne.n	8021172 <RsaPrivateDecryptEx+0xea>
            key->data = (byte*)XMALLOC(inLen, key->heap,
 802111a:	68b8      	ldr	r0, [r7, #8]
 802111c:	f7fd fdae 	bl	801ec7c <wolfSSL_Malloc>
 8021120:	4602      	mov	r2, r0
 8021122:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021124:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021128:	f8c3 2164 	str.w	r2, [r3, #356]	@ 0x164
                                                      DYNAMIC_TYPE_WOLF_BIGINT);
            key->dataIsAlloc = 1;
 802112c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802112e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021132:	2201      	movs	r2, #1
 8021134:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
            if (key->data == NULL) {
 8021138:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802113a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802113e:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8021142:	2b00      	cmp	r3, #0
 8021144:	d103      	bne.n	802114e <RsaPrivateDecryptEx+0xc6>
                ret = MEMORY_E;
 8021146:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 802114a:	627b      	str	r3, [r7, #36]	@ 0x24
                break;
 802114c:	e10b      	b.n	8021366 <RsaPrivateDecryptEx+0x2de>
            }
            XMEMCPY(key->data, in, inLen);
 802114e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021150:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021154:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8021158:	68ba      	ldr	r2, [r7, #8]
 802115a:	68f9      	ldr	r1, [r7, #12]
 802115c:	4618      	mov	r0, r3
 802115e:	f007 fe12 	bl	8028d86 <memcpy>
            key->dataLen = inLen;
 8021162:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021164:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021168:	461a      	mov	r2, r3
 802116a:	68bb      	ldr	r3, [r7, #8]
 802116c:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170
 8021170:	e00c      	b.n	802118c <RsaPrivateDecryptEx+0x104>
        }
        else {
            key->dataIsAlloc = 0;
 8021172:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021174:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021178:	2200      	movs	r2, #0
 802117a:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
            key->data = out;
 802117e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021180:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021184:	461a      	mov	r2, r3
 8021186:	687b      	ldr	r3, [r7, #4]
 8021188:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
        }
#endif

        key->state = RSA_STATE_DECRYPT_EXPTMOD;
 802118c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802118e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021192:	461a      	mov	r2, r3
 8021194:	2304      	movs	r3, #4
 8021196:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
        }
    }
#endif
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
        ret = wc_RsaFunction_ex(key->data, inLen, key->data, &key->dataLen,
 802119a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802119c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80211a0:	f8d3 0164 	ldr.w	r0, [r3, #356]	@ 0x164
 80211a4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80211a6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80211aa:	f8d3 1164 	ldr.w	r1, [r3, #356]	@ 0x164
 80211ae:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80211b0:	f503 538b 	add.w	r3, r3, #4448	@ 0x1160
 80211b4:	3310      	adds	r3, #16
 80211b6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80211b8:	2a01      	cmp	r2, #1
 80211ba:	bf14      	ite	ne
 80211bc:	2201      	movne	r2, #1
 80211be:	2200      	moveq	r2, #0
 80211c0:	b2d2      	uxtb	r2, r2
 80211c2:	9203      	str	r2, [sp, #12]
 80211c4:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80211c6:	9202      	str	r2, [sp, #8]
 80211c8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80211ca:	9201      	str	r2, [sp, #4]
 80211cc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80211ce:	9200      	str	r2, [sp, #0]
 80211d0:	460a      	mov	r2, r1
 80211d2:	68b9      	ldr	r1, [r7, #8]
 80211d4:	f7ff fefc 	bl	8020fd0 <wc_RsaFunction_ex>
 80211d8:	6278      	str	r0, [r7, #36]	@ 0x24
#else
        ret = wc_RsaFunction_ex(in, inLen, out, &key->dataLen, rsa_type, key,
                                              rng, pad_type != WC_RSA_OAEP_PAD);
#endif

        if (ret >= 0 || ret == WC_NO_ERR_TRACE(WC_PENDING_E)) {
 80211da:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80211dc:	2b00      	cmp	r3, #0
 80211de:	da03      	bge.n	80211e8 <RsaPrivateDecryptEx+0x160>
 80211e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80211e2:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 80211e6:	d106      	bne.n	80211f6 <RsaPrivateDecryptEx+0x16e>
            key->state = RSA_STATE_DECRYPT_UNPAD;
 80211e8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80211ea:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80211ee:	461a      	mov	r2, r3
 80211f0:	2305      	movs	r3, #5
 80211f2:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
        }
        if (ret < 0) {
 80211f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80211f8:	2b00      	cmp	r3, #0
 80211fa:	f2c0 80b3 	blt.w	8021364 <RsaPrivateDecryptEx+0x2dc>
        FALL_THROUGH;

    case RSA_STATE_DECRYPT_UNPAD:
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
        ret = wc_RsaUnPad_ex(key->data,
 80211fe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021200:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021204:	f8d3 4164 	ldr.w	r4, [r3, #356]	@ 0x164
 8021208:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802120a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802120e:	f8d3 5170 	ldr.w	r5, [r3, #368]	@ 0x170
            key->dataLen, &pad, pad_value, pad_type, hash, mgf,
            label, labelSz, saltLen, mp_count_bits(&key->n), key->heap);
 8021212:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
        ret = wc_RsaUnPad_ex(key->data,
 8021214:	4618      	mov	r0, r3
 8021216:	f005 fe4b 	bl	8026eb0 <mp_count_bits>
 802121a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802121c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021220:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8021224:	f897 1044 	ldrb.w	r1, [r7, #68]	@ 0x44
 8021228:	f107 0210 	add.w	r2, r7, #16
 802122c:	9307      	str	r3, [sp, #28]
 802122e:	9006      	str	r0, [sp, #24]
 8021230:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8021232:	9305      	str	r3, [sp, #20]
 8021234:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8021236:	9304      	str	r3, [sp, #16]
 8021238:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802123a:	9303      	str	r3, [sp, #12]
 802123c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802123e:	9302      	str	r3, [sp, #8]
 8021240:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 8021244:	9301      	str	r3, [sp, #4]
 8021246:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8021248:	9300      	str	r3, [sp, #0]
 802124a:	460b      	mov	r3, r1
 802124c:	4629      	mov	r1, r5
 802124e:	4620      	mov	r0, r4
 8021250:	f7ff fb98 	bl	8020984 <wc_RsaUnPad_ex>
 8021254:	6278      	str	r0, [r7, #36]	@ 0x24
#else
        ret = wc_RsaUnPad_ex(out,
            key->dataLen, &pad, pad_value, pad_type, hash, mgf, label,
            labelSz, saltLen, mp_count_bits(&key->n), key->heap);
#endif
        if (rsa_type == RSA_PUBLIC_DECRYPT && ret > (int)outLen) {
 8021256:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8021258:	2b01      	cmp	r3, #1
 802125a:	d107      	bne.n	802126c <RsaPrivateDecryptEx+0x1e4>
 802125c:	683b      	ldr	r3, [r7, #0]
 802125e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8021260:	429a      	cmp	r2, r3
 8021262:	dd03      	ble.n	802126c <RsaPrivateDecryptEx+0x1e4>
            ret = RSA_BUFFER_E;
 8021264:	f06f 0382 	mvn.w	r3, #130	@ 0x82
 8021268:	627b      	str	r3, [r7, #36]	@ 0x24
 802126a:	e06d      	b.n	8021348 <RsaPrivateDecryptEx+0x2c0>
        }
        else if (ret >= 0 && pad != NULL) {
 802126c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802126e:	2b00      	cmp	r3, #0
 8021270:	db6a      	blt.n	8021348 <RsaPrivateDecryptEx+0x2c0>
 8021272:	693b      	ldr	r3, [r7, #16]
 8021274:	2b00      	cmp	r3, #0
 8021276:	d067      	beq.n	8021348 <RsaPrivateDecryptEx+0x2c0>
            /* only copy output if not inline */
            if (outPtr == NULL) {
 8021278:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802127a:	2b00      	cmp	r3, #0
 802127c:	d148      	bne.n	8021310 <RsaPrivateDecryptEx+0x288>
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
                if (rsa_type == RSA_PRIVATE_DECRYPT) {
 802127e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8021280:	2b03      	cmp	r3, #3
 8021282:	d13e      	bne.n	8021302 <RsaPrivateDecryptEx+0x27a>
                    word32 i = 0;
 8021284:	2300      	movs	r3, #0
 8021286:	623b      	str	r3, [r7, #32]
                    word32 j;
                    int start = (int)((size_t)pad - (size_t)key->data);
 8021288:	693b      	ldr	r3, [r7, #16]
 802128a:	461a      	mov	r2, r3
 802128c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802128e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021292:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8021296:	1ad3      	subs	r3, r2, r3
 8021298:	61bb      	str	r3, [r7, #24]

                    for (j = 0; j < key->dataLen; j++) {
 802129a:	2300      	movs	r3, #0
 802129c:	61fb      	str	r3, [r7, #28]
 802129e:	e027      	b.n	80212f0 <RsaPrivateDecryptEx+0x268>
                        signed char c;
                        out[i] = key->data[j];
 80212a0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80212a2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80212a6:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
 80212aa:	69fb      	ldr	r3, [r7, #28]
 80212ac:	441a      	add	r2, r3
 80212ae:	6879      	ldr	r1, [r7, #4]
 80212b0:	6a3b      	ldr	r3, [r7, #32]
 80212b2:	440b      	add	r3, r1
 80212b4:	7812      	ldrb	r2, [r2, #0]
 80212b6:	701a      	strb	r2, [r3, #0]
                        c  = (signed char)ctMaskGTE((int)j, start);
 80212b8:	69fb      	ldr	r3, [r7, #28]
 80212ba:	69b9      	ldr	r1, [r7, #24]
 80212bc:	4618      	mov	r0, r3
 80212be:	f7fe fd9d 	bl	801fdfc <ctMaskGTE>
 80212c2:	4603      	mov	r3, r0
 80212c4:	75fb      	strb	r3, [r7, #23]
                        c &= (signed char)ctMaskLT((int)i, (int)outLen);
 80212c6:	6a3b      	ldr	r3, [r7, #32]
 80212c8:	683a      	ldr	r2, [r7, #0]
 80212ca:	4611      	mov	r1, r2
 80212cc:	4618      	mov	r0, r3
 80212ce:	f7fe fda7 	bl	801fe20 <ctMaskLT>
 80212d2:	4603      	mov	r3, r0
 80212d4:	b25a      	sxtb	r2, r3
 80212d6:	7dfb      	ldrb	r3, [r7, #23]
 80212d8:	4013      	ands	r3, r2
 80212da:	75fb      	strb	r3, [r7, #23]
                        /* 0 - no add, -1 add */
                        i += (word32)((byte)(-c));
 80212dc:	7dfb      	ldrb	r3, [r7, #23]
 80212de:	425b      	negs	r3, r3
 80212e0:	b2db      	uxtb	r3, r3
 80212e2:	461a      	mov	r2, r3
 80212e4:	6a3b      	ldr	r3, [r7, #32]
 80212e6:	4413      	add	r3, r2
 80212e8:	623b      	str	r3, [r7, #32]
                    for (j = 0; j < key->dataLen; j++) {
 80212ea:	69fb      	ldr	r3, [r7, #28]
 80212ec:	3301      	adds	r3, #1
 80212ee:	61fb      	str	r3, [r7, #28]
 80212f0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80212f2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80212f6:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 80212fa:	69fa      	ldr	r2, [r7, #28]
 80212fc:	429a      	cmp	r2, r3
 80212fe:	d3cf      	bcc.n	80212a0 <RsaPrivateDecryptEx+0x218>
 8021300:	e009      	b.n	8021316 <RsaPrivateDecryptEx+0x28e>
                    }
                }
                else
#endif
                {
                    XMEMCPY(out, pad, (size_t)ret);
 8021302:	693b      	ldr	r3, [r7, #16]
 8021304:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8021306:	4619      	mov	r1, r3
 8021308:	6878      	ldr	r0, [r7, #4]
 802130a:	f007 fd3c 	bl	8028d86 <memcpy>
 802130e:	e002      	b.n	8021316 <RsaPrivateDecryptEx+0x28e>
                }
            }
            else {
                *outPtr = pad;
 8021310:	693a      	ldr	r2, [r7, #16]
 8021312:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8021314:	601a      	str	r2, [r3, #0]
            }

#if !defined(WOLFSSL_RSA_VERIFY_ONLY)
            ret = ctMaskSelInt(ctMaskLTE(ret, (int)outLen), ret,
 8021316:	683b      	ldr	r3, [r7, #0]
 8021318:	4619      	mov	r1, r3
 802131a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 802131c:	f7fe fd93 	bl	801fe46 <ctMaskLTE>
 8021320:	4603      	mov	r3, r0
 8021322:	f06f 0282 	mvn.w	r2, #130	@ 0x82
 8021326:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8021328:	4618      	mov	r0, r3
 802132a:	f7fe fe0a 	bl	801ff42 <ctMaskSelInt>
 802132e:	6278      	str	r0, [r7, #36]	@ 0x24
                               WC_NO_ERR_TRACE(RSA_BUFFER_E));
    #ifndef WOLFSSL_RSA_DECRYPT_TO_0_LEN
            ret = ctMaskSelInt(ctMaskNotEq(ret, 0), ret,
 8021330:	2100      	movs	r1, #0
 8021332:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021334:	f7fe fdef 	bl	801ff16 <ctMaskNotEq>
 8021338:	4603      	mov	r3, r0
 802133a:	f06f 0282 	mvn.w	r2, #130	@ 0x82
 802133e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8021340:	4618      	mov	r0, r3
 8021342:	f7fe fdfe 	bl	801ff42 <ctMaskSelInt>
 8021346:	6278      	str	r0, [r7, #36]	@ 0x24
            if (outLen < (word32)ret)
                ret = RSA_BUFFER_E;
#endif
        }

        key->state = RSA_STATE_DECRYPT_RES;
 8021348:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802134a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802134e:	461a      	mov	r2, r3
 8021350:	2306      	movs	r3, #6
 8021352:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
                if (outPtr)
                    *outPtr = in;
            }
        }
    #endif
        break;
 8021356:	e003      	b.n	8021360 <RsaPrivateDecryptEx+0x2d8>

    default:
        ret = BAD_STATE_E;
 8021358:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 802135c:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
 802135e:	e002      	b.n	8021366 <RsaPrivateDecryptEx+0x2de>
        break;
 8021360:	bf00      	nop
 8021362:	e000      	b.n	8021366 <RsaPrivateDecryptEx+0x2de>
            break;
 8021364:	bf00      	nop
    }

    /* if async pending then return and skip done cleanup below */
    if (ret == WC_NO_ERR_TRACE(WC_PENDING_E)
 8021366:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021368:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 802136c:	d101      	bne.n	8021372 <RsaPrivateDecryptEx+0x2ea>
    #ifdef WC_RSA_NONBLOCK
        || ret == FP_WOULDBLOCK
    #endif
    ) {
        return ret;
 802136e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021370:	e00a      	b.n	8021388 <RsaPrivateDecryptEx+0x300>
    }

    key->state = RSA_STATE_NONE;
 8021372:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021374:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021378:	461a      	mov	r2, r3
 802137a:	2300      	movs	r3, #0
 802137c:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
    wc_RsaCleanup(key);
 8021380:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8021382:	f7fe fe0f 	bl	801ffa4 <wc_RsaCleanup>

    return ret;
 8021386:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8021388:	4618      	mov	r0, r3
 802138a:	3728      	adds	r7, #40	@ 0x28
 802138c:	46bd      	mov	sp, r7
 802138e:	bdb0      	pop	{r4, r5, r7, pc}

08021390 <wc_RsaPrivateDecrypt>:
#endif /* WC_NO_RSA_OAEP */


int wc_RsaPrivateDecrypt(const byte* in, word32 inLen, byte* out,
                                                 word32 outLen, RsaKey* key)
{
 8021390:	b580      	push	{r7, lr}
 8021392:	b092      	sub	sp, #72	@ 0x48
 8021394:	af0c      	add	r7, sp, #48	@ 0x30
 8021396:	60f8      	str	r0, [r7, #12]
 8021398:	60b9      	str	r1, [r7, #8]
 802139a:	607a      	str	r2, [r7, #4]
 802139c:	603b      	str	r3, [r7, #0]
    WC_RNG* rng;
    int ret;
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 802139e:	6a3b      	ldr	r3, [r7, #32]
 80213a0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80213a4:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 80213a8:	617b      	str	r3, [r7, #20]
#else
    rng = NULL;
#endif
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
    ret = RsaPrivateDecryptEx(in, inLen, out, outLen, NULL, key,
 80213aa:	697b      	ldr	r3, [r7, #20]
 80213ac:	930a      	str	r3, [sp, #40]	@ 0x28
 80213ae:	2300      	movs	r3, #0
 80213b0:	9309      	str	r3, [sp, #36]	@ 0x24
 80213b2:	2300      	movs	r3, #0
 80213b4:	9308      	str	r3, [sp, #32]
 80213b6:	2300      	movs	r3, #0
 80213b8:	9307      	str	r3, [sp, #28]
 80213ba:	2300      	movs	r3, #0
 80213bc:	9306      	str	r3, [sp, #24]
 80213be:	2300      	movs	r3, #0
 80213c0:	9305      	str	r3, [sp, #20]
 80213c2:	2300      	movs	r3, #0
 80213c4:	9304      	str	r3, [sp, #16]
 80213c6:	2302      	movs	r3, #2
 80213c8:	9303      	str	r3, [sp, #12]
 80213ca:	2303      	movs	r3, #3
 80213cc:	9302      	str	r3, [sp, #8]
 80213ce:	6a3b      	ldr	r3, [r7, #32]
 80213d0:	9301      	str	r3, [sp, #4]
 80213d2:	2300      	movs	r3, #0
 80213d4:	9300      	str	r3, [sp, #0]
 80213d6:	683b      	ldr	r3, [r7, #0]
 80213d8:	687a      	ldr	r2, [r7, #4]
 80213da:	68b9      	ldr	r1, [r7, #8]
 80213dc:	68f8      	ldr	r0, [r7, #12]
 80213de:	f7ff fe53 	bl	8021088 <RsaPrivateDecryptEx>
 80213e2:	6138      	str	r0, [r7, #16]
        RSA_PRIVATE_DECRYPT, RSA_BLOCK_TYPE_2, WC_RSA_PKCSV15_PAD,
        WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
    RESTORE_VECTOR_REGISTERS();
    return ret;
 80213e4:	693b      	ldr	r3, [r7, #16]
}
 80213e6:	4618      	mov	r0, r3
 80213e8:	3718      	adds	r7, #24
 80213ea:	46bd      	mov	sp, r7
 80213ec:	bd80      	pop	{r7, pc}

080213ee <wc_RsaSSL_VerifyInline>:
#endif /* WC_NO_RSA_OAEP || WC_RSA_NO_PADDING */
#endif /* WOLFSSL_RSA_PUBLIC_ONLY */

#if !defined(WOLFSSL_CRYPTOCELL)
int wc_RsaSSL_VerifyInline(byte* in, word32 inLen, byte** out, RsaKey* key)
{
 80213ee:	b580      	push	{r7, lr}
 80213f0:	b092      	sub	sp, #72	@ 0x48
 80213f2:	af0c      	add	r7, sp, #48	@ 0x30
 80213f4:	60f8      	str	r0, [r7, #12]
 80213f6:	60b9      	str	r1, [r7, #8]
 80213f8:	607a      	str	r2, [r7, #4]
 80213fa:	603b      	str	r3, [r7, #0]
    WC_RNG* rng;
    int ret;
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 80213fc:	683b      	ldr	r3, [r7, #0]
 80213fe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021402:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 8021406:	617b      	str	r3, [r7, #20]
#else
    rng = NULL;
#endif
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
    ret = RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 8021408:	697b      	ldr	r3, [r7, #20]
 802140a:	930a      	str	r3, [sp, #40]	@ 0x28
 802140c:	2300      	movs	r3, #0
 802140e:	9309      	str	r3, [sp, #36]	@ 0x24
 8021410:	2300      	movs	r3, #0
 8021412:	9308      	str	r3, [sp, #32]
 8021414:	2300      	movs	r3, #0
 8021416:	9307      	str	r3, [sp, #28]
 8021418:	2300      	movs	r3, #0
 802141a:	9306      	str	r3, [sp, #24]
 802141c:	2300      	movs	r3, #0
 802141e:	9305      	str	r3, [sp, #20]
 8021420:	2300      	movs	r3, #0
 8021422:	9304      	str	r3, [sp, #16]
 8021424:	2301      	movs	r3, #1
 8021426:	9303      	str	r3, [sp, #12]
 8021428:	2301      	movs	r3, #1
 802142a:	9302      	str	r3, [sp, #8]
 802142c:	683b      	ldr	r3, [r7, #0]
 802142e:	9301      	str	r3, [sp, #4]
 8021430:	687b      	ldr	r3, [r7, #4]
 8021432:	9300      	str	r3, [sp, #0]
 8021434:	68bb      	ldr	r3, [r7, #8]
 8021436:	68fa      	ldr	r2, [r7, #12]
 8021438:	68b9      	ldr	r1, [r7, #8]
 802143a:	68f8      	ldr	r0, [r7, #12]
 802143c:	f7ff fe24 	bl	8021088 <RsaPrivateDecryptEx>
 8021440:	6138      	str	r0, [r7, #16]
        RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PKCSV15_PAD,
        WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
    RESTORE_VECTOR_REGISTERS();
    return ret;
 8021442:	693b      	ldr	r3, [r7, #16]
}
 8021444:	4618      	mov	r0, r3
 8021446:	3718      	adds	r7, #24
 8021448:	46bd      	mov	sp, r7
 802144a:	bd80      	pop	{r7, pc}

0802144c <wc_RsaPSS_VerifyInline_ex>:
 * returns the length of the PSS data on success and negative indicates failure.
 */
int wc_RsaPSS_VerifyInline_ex(byte* in, word32 inLen, byte** out,
                              enum wc_HashType hash, int mgf, int saltLen,
                              RsaKey* key)
{
 802144c:	b580      	push	{r7, lr}
 802144e:	b092      	sub	sp, #72	@ 0x48
 8021450:	af0c      	add	r7, sp, #48	@ 0x30
 8021452:	60f8      	str	r0, [r7, #12]
 8021454:	60b9      	str	r1, [r7, #8]
 8021456:	607a      	str	r2, [r7, #4]
 8021458:	70fb      	strb	r3, [r7, #3]
    WC_RNG* rng;
    int ret;
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 802145a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802145c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021460:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 8021464:	617b      	str	r3, [r7, #20]
#else
    rng = NULL;
#endif
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
    ret = RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 8021466:	697b      	ldr	r3, [r7, #20]
 8021468:	930a      	str	r3, [sp, #40]	@ 0x28
 802146a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802146c:	9309      	str	r3, [sp, #36]	@ 0x24
 802146e:	2300      	movs	r3, #0
 8021470:	9308      	str	r3, [sp, #32]
 8021472:	2300      	movs	r3, #0
 8021474:	9307      	str	r3, [sp, #28]
 8021476:	6a3b      	ldr	r3, [r7, #32]
 8021478:	9306      	str	r3, [sp, #24]
 802147a:	78fb      	ldrb	r3, [r7, #3]
 802147c:	9305      	str	r3, [sp, #20]
 802147e:	2302      	movs	r3, #2
 8021480:	9304      	str	r3, [sp, #16]
 8021482:	2301      	movs	r3, #1
 8021484:	9303      	str	r3, [sp, #12]
 8021486:	2301      	movs	r3, #1
 8021488:	9302      	str	r3, [sp, #8]
 802148a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802148c:	9301      	str	r3, [sp, #4]
 802148e:	687b      	ldr	r3, [r7, #4]
 8021490:	9300      	str	r3, [sp, #0]
 8021492:	68bb      	ldr	r3, [r7, #8]
 8021494:	68fa      	ldr	r2, [r7, #12]
 8021496:	68b9      	ldr	r1, [r7, #8]
 8021498:	68f8      	ldr	r0, [r7, #12]
 802149a:	f7ff fdf5 	bl	8021088 <RsaPrivateDecryptEx>
 802149e:	6138      	str	r0, [r7, #16]
        RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PSS_PAD,
        hash, mgf, NULL, 0, saltLen, rng);
    RESTORE_VECTOR_REGISTERS();
    return ret;
 80214a0:	693b      	ldr	r3, [r7, #16]
}
 80214a2:	4618      	mov	r0, r3
 80214a4:	3718      	adds	r7, #24
 80214a6:	46bd      	mov	sp, r7
 80214a8:	bd80      	pop	{r7, pc}

080214aa <wc_RsaPSS_CheckPadding_ex2>:
 * algorithm length and 0 on success.
 */
int wc_RsaPSS_CheckPadding_ex2(const byte* in, word32 inSz, byte* sig,
                               word32 sigSz, enum wc_HashType hashType,
                               int saltLen, int bits, void* heap)
{
 80214aa:	b580      	push	{r7, lr}
 80214ac:	b09c      	sub	sp, #112	@ 0x70
 80214ae:	af02      	add	r7, sp, #8
 80214b0:	60f8      	str	r0, [r7, #12]
 80214b2:	60b9      	str	r1, [r7, #8]
 80214b4:	607a      	str	r2, [r7, #4]
 80214b6:	603b      	str	r3, [r7, #0]
    int ret = 0;
 80214b8:	2300      	movs	r3, #0
 80214ba:	667b      	str	r3, [r7, #100]	@ 0x64
    byte sigCheckBuf[WC_MAX_DIGEST_SIZE*2 + RSA_PSS_PAD_SZ];
    byte *sigCheck = sigCheckBuf;
 80214bc:	f107 0314 	add.w	r3, r7, #20
 80214c0:	663b      	str	r3, [r7, #96]	@ 0x60

    (void)bits;

    if (in == NULL || sig == NULL ||
 80214c2:	68fb      	ldr	r3, [r7, #12]
 80214c4:	2b00      	cmp	r3, #0
 80214c6:	d00c      	beq.n	80214e2 <wc_RsaPSS_CheckPadding_ex2+0x38>
 80214c8:	687b      	ldr	r3, [r7, #4]
 80214ca:	2b00      	cmp	r3, #0
 80214cc:	d009      	beq.n	80214e2 <wc_RsaPSS_CheckPadding_ex2+0x38>
                               inSz != (word32)wc_HashGetDigestSize(hashType)) {
 80214ce:	f897 3070 	ldrb.w	r3, [r7, #112]	@ 0x70
 80214d2:	4618      	mov	r0, r3
 80214d4:	f7fd f840 	bl	801e558 <wc_HashGetDigestSize>
 80214d8:	4603      	mov	r3, r0
 80214da:	461a      	mov	r2, r3
    if (in == NULL || sig == NULL ||
 80214dc:	68bb      	ldr	r3, [r7, #8]
 80214de:	4293      	cmp	r3, r2
 80214e0:	d002      	beq.n	80214e8 <wc_RsaPSS_CheckPadding_ex2+0x3e>
        ret = BAD_FUNC_ARG;
 80214e2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80214e6:	667b      	str	r3, [r7, #100]	@ 0x64
    }

    if (ret == 0) {
 80214e8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80214ea:	2b00      	cmp	r3, #0
 80214ec:	d115      	bne.n	802151a <wc_RsaPSS_CheckPadding_ex2+0x70>
        if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
 80214ee:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80214f0:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80214f4:	d102      	bne.n	80214fc <wc_RsaPSS_CheckPadding_ex2+0x52>
            saltLen = (int)inSz;
 80214f6:	68bb      	ldr	r3, [r7, #8]
 80214f8:	677b      	str	r3, [r7, #116]	@ 0x74
 80214fa:	e00e      	b.n	802151a <wc_RsaPSS_CheckPadding_ex2+0x70>
                    saltLen = RSA_PSS_SALT_MAX_SZ;
                }
            #endif
        }
#ifndef WOLFSSL_PSS_LONG_SALT
        else if (saltLen > (int)inSz) {
 80214fc:	68bb      	ldr	r3, [r7, #8]
 80214fe:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8021500:	429a      	cmp	r2, r3
 8021502:	dd03      	ble.n	802150c <wc_RsaPSS_CheckPadding_ex2+0x62>
            ret = PSS_SALTLEN_E;
 8021504:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8021508:	667b      	str	r3, [r7, #100]	@ 0x64
 802150a:	e006      	b.n	802151a <wc_RsaPSS_CheckPadding_ex2+0x70>
        }
#endif
#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
        else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {
 802150c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802150e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8021512:	da02      	bge.n	802151a <wc_RsaPSS_CheckPadding_ex2+0x70>
            ret = PSS_SALTLEN_E;
 8021514:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8021518:	667b      	str	r3, [r7, #100]	@ 0x64
        }
#endif
    }

    /* Sig = Salt | Exp Hash */
    if (ret == 0) {
 802151a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802151c:	2b00      	cmp	r3, #0
 802151e:	d113      	bne.n	8021548 <wc_RsaPSS_CheckPadding_ex2+0x9e>
        word32 totalSz;
        if ((WC_SAFE_SUM_WORD32(inSz, (word32)saltLen, totalSz) == 0) ||
 8021520:	68bb      	ldr	r3, [r7, #8]
 8021522:	43da      	mvns	r2, r3
 8021524:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8021526:	429a      	cmp	r2, r3
 8021528:	d308      	bcc.n	802153c <wc_RsaPSS_CheckPadding_ex2+0x92>
 802152a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802152c:	68ba      	ldr	r2, [r7, #8]
 802152e:	4413      	add	r3, r2
 8021530:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8021532:	683a      	ldr	r2, [r7, #0]
 8021534:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8021536:	429a      	cmp	r2, r3
 8021538:	d006      	beq.n	8021548 <wc_RsaPSS_CheckPadding_ex2+0x9e>
 802153a:	e002      	b.n	8021542 <wc_RsaPSS_CheckPadding_ex2+0x98>
 802153c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8021540:	65fb      	str	r3, [r7, #92]	@ 0x5c
            (sigSz != totalSz))
        {
            ret = PSS_SALTLEN_E;
 8021542:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8021546:	667b      	str	r3, [r7, #100]	@ 0x64
        if (sigCheck == NULL) {
            ret = MEMORY_E;
        }
    }
#else
    if (ret == 0 && sizeof(sigCheckBuf) < (RSA_PSS_PAD_SZ + inSz + (word32)saltLen)) {
 8021548:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802154a:	2b00      	cmp	r3, #0
 802154c:	d108      	bne.n	8021560 <wc_RsaPSS_CheckPadding_ex2+0xb6>
 802154e:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8021550:	68bb      	ldr	r3, [r7, #8]
 8021552:	4413      	add	r3, r2
 8021554:	3308      	adds	r3, #8
 8021556:	2b48      	cmp	r3, #72	@ 0x48
 8021558:	d902      	bls.n	8021560 <wc_RsaPSS_CheckPadding_ex2+0xb6>
        ret = BUFFER_E;
 802155a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 802155e:	667b      	str	r3, [r7, #100]	@ 0x64
    }
#endif

    /* Exp Hash = HASH(8 * 0x00 | Message Hash | Salt) */
    if (ret == 0) {
 8021560:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8021562:	2b00      	cmp	r3, #0
 8021564:	d122      	bne.n	80215ac <wc_RsaPSS_CheckPadding_ex2+0x102>
        XMEMSET(sigCheck, 0, RSA_PSS_PAD_SZ);
 8021566:	2208      	movs	r2, #8
 8021568:	2100      	movs	r1, #0
 802156a:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 802156c:	f007 fb5a 	bl	8028c24 <memset>
        XMEMCPY(sigCheck + RSA_PSS_PAD_SZ, in, inSz);
 8021570:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8021572:	3308      	adds	r3, #8
 8021574:	68ba      	ldr	r2, [r7, #8]
 8021576:	68f9      	ldr	r1, [r7, #12]
 8021578:	4618      	mov	r0, r3
 802157a:	f007 fc04 	bl	8028d86 <memcpy>
        XMEMCPY(sigCheck + RSA_PSS_PAD_SZ + inSz, sig, (size_t)saltLen);
 802157e:	68bb      	ldr	r3, [r7, #8]
 8021580:	3308      	adds	r3, #8
 8021582:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8021584:	4413      	add	r3, r2
 8021586:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8021588:	6879      	ldr	r1, [r7, #4]
 802158a:	4618      	mov	r0, r3
 802158c:	f007 fbfb 	bl	8028d86 <memcpy>
        ret = wc_Hash(hashType, sigCheck, RSA_PSS_PAD_SZ + inSz + (word32)saltLen,
 8021590:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8021592:	68bb      	ldr	r3, [r7, #8]
 8021594:	4413      	add	r3, r2
 8021596:	f103 0208 	add.w	r2, r3, #8
 802159a:	f897 0070 	ldrb.w	r0, [r7, #112]	@ 0x70
 802159e:	68bb      	ldr	r3, [r7, #8]
 80215a0:	9300      	str	r3, [sp, #0]
 80215a2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80215a4:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80215a6:	f7fd f86f 	bl	801e688 <wc_Hash>
 80215aa:	6678      	str	r0, [r7, #100]	@ 0x64
                      sigCheck, inSz);
    }
    if (ret == 0) {
 80215ac:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80215ae:	2b00      	cmp	r3, #0
 80215b0:	d10d      	bne.n	80215ce <wc_RsaPSS_CheckPadding_ex2+0x124>
        if (XMEMCMP(sigCheck, sig + saltLen, inSz) != 0) {
 80215b2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80215b4:	687a      	ldr	r2, [r7, #4]
 80215b6:	4413      	add	r3, r2
 80215b8:	68ba      	ldr	r2, [r7, #8]
 80215ba:	4619      	mov	r1, r3
 80215bc:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80215be:	f007 fb07 	bl	8028bd0 <memcmp>
 80215c2:	4603      	mov	r3, r0
 80215c4:	2b00      	cmp	r3, #0
 80215c6:	d002      	beq.n	80215ce <wc_RsaPSS_CheckPadding_ex2+0x124>
            WOLFSSL_MSG("RsaPSS_CheckPadding: Padding Error");
            ret = BAD_PADDING_E;
 80215c8:	f06f 03c0 	mvn.w	r3, #192	@ 0xc0
 80215cc:	667b      	str	r3, [r7, #100]	@ 0x64
        XFREE(sigCheck, heap, DYNAMIC_TYPE_RSA_BUFFER);
    }
#endif

    (void)heap; /* unused if memory is disabled */
    return ret;
 80215ce:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
}
 80215d0:	4618      	mov	r0, r3
 80215d2:	3768      	adds	r7, #104	@ 0x68
 80215d4:	46bd      	mov	sp, r7
 80215d6:	bd80      	pop	{r7, pc}

080215d8 <wc_RsaEncryptSize>:
}
#endif
#endif

int wc_RsaEncryptSize(const RsaKey* key)
{
 80215d8:	b580      	push	{r7, lr}
 80215da:	b084      	sub	sp, #16
 80215dc:	af00      	add	r7, sp, #0
 80215de:	6078      	str	r0, [r7, #4]
    int ret;

    if (key == NULL) {
 80215e0:	687b      	ldr	r3, [r7, #4]
 80215e2:	2b00      	cmp	r3, #0
 80215e4:	d102      	bne.n	80215ec <wc_RsaEncryptSize+0x14>
        return BAD_FUNC_ARG;
 80215e6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80215ea:	e005      	b.n	80215f8 <wc_RsaEncryptSize+0x20>
    }

    ret = mp_unsigned_bin_size(&key->n);
 80215ec:	687b      	ldr	r3, [r7, #4]
 80215ee:	4618      	mov	r0, r3
 80215f0:	f005 fba2 	bl	8026d38 <mp_unsigned_bin_size>
 80215f4:	60f8      	str	r0, [r7, #12]
            ret = 2048/8; /* hardware handles, use 2048-bit as default */
        }
    }
#endif

    return ret;
 80215f6:	68fb      	ldr	r3, [r7, #12]
}
 80215f8:	4618      	mov	r0, r3
 80215fa:	3710      	adds	r7, #16
 80215fc:	46bd      	mov	sp, r7
 80215fe:	bd80      	pop	{r7, pc}

08021600 <wc_RsaSetRNG>:
#endif /* WOLFSSL_KEY_GEN */


#ifdef WC_RSA_BLINDING
int wc_RsaSetRNG(RsaKey* key, WC_RNG* rng)
{
 8021600:	b480      	push	{r7}
 8021602:	b083      	sub	sp, #12
 8021604:	af00      	add	r7, sp, #0
 8021606:	6078      	str	r0, [r7, #4]
 8021608:	6039      	str	r1, [r7, #0]
    if (key == NULL || rng == NULL)
 802160a:	687b      	ldr	r3, [r7, #4]
 802160c:	2b00      	cmp	r3, #0
 802160e:	d002      	beq.n	8021616 <wc_RsaSetRNG+0x16>
 8021610:	683b      	ldr	r3, [r7, #0]
 8021612:	2b00      	cmp	r3, #0
 8021614:	d102      	bne.n	802161c <wc_RsaSetRNG+0x1c>
        return BAD_FUNC_ARG;
 8021616:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802161a:	e007      	b.n	802162c <wc_RsaSetRNG+0x2c>

    key->rng = rng;
 802161c:	687b      	ldr	r3, [r7, #4]
 802161e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021622:	461a      	mov	r2, r3
 8021624:	683b      	ldr	r3, [r7, #0]
 8021626:	f8c2 3174 	str.w	r3, [r2, #372]	@ 0x174

    return 0;
 802162a:	2300      	movs	r3, #0
}
 802162c:	4618      	mov	r0, r3
 802162e:	370c      	adds	r7, #12
 8021630:	46bd      	mov	sp, r7
 8021632:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021636:	4770      	bx	lr

08021638 <rotlFixed>:
    {
 8021638:	b480      	push	{r7}
 802163a:	b083      	sub	sp, #12
 802163c:	af00      	add	r7, sp, #0
 802163e:	6078      	str	r0, [r7, #4]
 8021640:	6039      	str	r1, [r7, #0]
        return (x << y) | (x >> (sizeof(x) * 8 - y));
 8021642:	687a      	ldr	r2, [r7, #4]
 8021644:	683b      	ldr	r3, [r7, #0]
 8021646:	f1c3 0320 	rsb	r3, r3, #32
 802164a:	fa62 f303 	ror.w	r3, r2, r3
    }
 802164e:	4618      	mov	r0, r3
 8021650:	370c      	adds	r7, #12
 8021652:	46bd      	mov	sp, r7
 8021654:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021658:	4770      	bx	lr

0802165a <rotrFixed>:
    {
 802165a:	b480      	push	{r7}
 802165c:	b083      	sub	sp, #12
 802165e:	af00      	add	r7, sp, #0
 8021660:	6078      	str	r0, [r7, #4]
 8021662:	6039      	str	r1, [r7, #0]
        return (x >> y) | (x << (sizeof(x) * 8 - y));
 8021664:	687a      	ldr	r2, [r7, #4]
 8021666:	683b      	ldr	r3, [r7, #0]
 8021668:	fa62 f303 	ror.w	r3, r2, r3
    }
 802166c:	4618      	mov	r0, r3
 802166e:	370c      	adds	r7, #12
 8021670:	46bd      	mov	sp, r7
 8021672:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021676:	4770      	bx	lr

08021678 <ByteReverseWord32>:
{
 8021678:	b580      	push	{r7, lr}
 802167a:	b082      	sub	sp, #8
 802167c:	af00      	add	r7, sp, #0
 802167e:	6078      	str	r0, [r7, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 8021680:	687b      	ldr	r3, [r7, #4]
 8021682:	0a1b      	lsrs	r3, r3, #8
 8021684:	f003 12ff 	and.w	r2, r3, #16711935	@ 0xff00ff
 8021688:	687b      	ldr	r3, [r7, #4]
 802168a:	021b      	lsls	r3, r3, #8
 802168c:	f003 23ff 	and.w	r3, r3, #4278255360	@ 0xff00ff00
 8021690:	4313      	orrs	r3, r2
 8021692:	607b      	str	r3, [r7, #4]
    return rotlFixed(value, 16U);
 8021694:	2110      	movs	r1, #16
 8021696:	6878      	ldr	r0, [r7, #4]
 8021698:	f7ff ffce 	bl	8021638 <rotlFixed>
 802169c:	4603      	mov	r3, r0
}
 802169e:	4618      	mov	r0, r3
 80216a0:	3708      	adds	r7, #8
 80216a2:	46bd      	mov	sp, r7
 80216a4:	bd80      	pop	{r7, pc}

080216a6 <ByteReverseWords>:
{
 80216a6:	b590      	push	{r4, r7, lr}
 80216a8:	b087      	sub	sp, #28
 80216aa:	af00      	add	r7, sp, #0
 80216ac:	60f8      	str	r0, [r7, #12]
 80216ae:	60b9      	str	r1, [r7, #8]
 80216b0:	607a      	str	r2, [r7, #4]
        word32 count = byteCount/(word32)sizeof(word32);
 80216b2:	687b      	ldr	r3, [r7, #4]
 80216b4:	089b      	lsrs	r3, r3, #2
 80216b6:	613b      	str	r3, [r7, #16]
        for (i = 0; i < count; i++)
 80216b8:	2300      	movs	r3, #0
 80216ba:	617b      	str	r3, [r7, #20]
 80216bc:	e010      	b.n	80216e0 <ByteReverseWords+0x3a>
            out[i] = ByteReverseWord32(in[i]);
 80216be:	697b      	ldr	r3, [r7, #20]
 80216c0:	009b      	lsls	r3, r3, #2
 80216c2:	68ba      	ldr	r2, [r7, #8]
 80216c4:	4413      	add	r3, r2
 80216c6:	6819      	ldr	r1, [r3, #0]
 80216c8:	697b      	ldr	r3, [r7, #20]
 80216ca:	009b      	lsls	r3, r3, #2
 80216cc:	68fa      	ldr	r2, [r7, #12]
 80216ce:	18d4      	adds	r4, r2, r3
 80216d0:	4608      	mov	r0, r1
 80216d2:	f7ff ffd1 	bl	8021678 <ByteReverseWord32>
 80216d6:	4603      	mov	r3, r0
 80216d8:	6023      	str	r3, [r4, #0]
        for (i = 0; i < count; i++)
 80216da:	697b      	ldr	r3, [r7, #20]
 80216dc:	3301      	adds	r3, #1
 80216de:	617b      	str	r3, [r7, #20]
 80216e0:	697a      	ldr	r2, [r7, #20]
 80216e2:	693b      	ldr	r3, [r7, #16]
 80216e4:	429a      	cmp	r2, r3
 80216e6:	d3ea      	bcc.n	80216be <ByteReverseWords+0x18>
}
 80216e8:	bf00      	nop
 80216ea:	bf00      	nop
 80216ec:	371c      	adds	r7, #28
 80216ee:	46bd      	mov	sp, r7
 80216f0:	bd90      	pop	{r4, r7, pc}

080216f2 <ForceZero>:
{
 80216f2:	b480      	push	{r7}
 80216f4:	b085      	sub	sp, #20
 80216f6:	af00      	add	r7, sp, #0
 80216f8:	6078      	str	r0, [r7, #4]
 80216fa:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 80216fc:	687b      	ldr	r3, [r7, #4]
 80216fe:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 8021700:	e004      	b.n	802170c <ForceZero+0x1a>
 8021702:	68fb      	ldr	r3, [r7, #12]
 8021704:	1c5a      	adds	r2, r3, #1
 8021706:	60fa      	str	r2, [r7, #12]
 8021708:	2200      	movs	r2, #0
 802170a:	701a      	strb	r2, [r3, #0]
 802170c:	683b      	ldr	r3, [r7, #0]
 802170e:	1e5a      	subs	r2, r3, #1
 8021710:	603a      	str	r2, [r7, #0]
 8021712:	2b00      	cmp	r3, #0
 8021714:	d1f5      	bne.n	8021702 <ForceZero+0x10>
}
 8021716:	bf00      	nop
 8021718:	bf00      	nop
 802171a:	3714      	adds	r7, #20
 802171c:	46bd      	mov	sp, r7
 802171e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021722:	4770      	bx	lr

08021724 <min>:
    {
 8021724:	b480      	push	{r7}
 8021726:	b083      	sub	sp, #12
 8021728:	af00      	add	r7, sp, #0
 802172a:	6078      	str	r0, [r7, #4]
 802172c:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 802172e:	687a      	ldr	r2, [r7, #4]
 8021730:	683b      	ldr	r3, [r7, #0]
 8021732:	4293      	cmp	r3, r2
 8021734:	bf28      	it	cs
 8021736:	4613      	movcs	r3, r2
    }
 8021738:	4618      	mov	r0, r3
 802173a:	370c      	adds	r7, #12
 802173c:	46bd      	mov	sp, r7
 802173e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021742:	4770      	bx	lr

08021744 <InitSha256>:
#endif
static void Sha256_SetTransform(SHA256_SETTRANSFORM_ARGS);
#endif

static int InitSha256(wc_Sha256* sha256)
{
 8021744:	b580      	push	{r7, lr}
 8021746:	b082      	sub	sp, #8
 8021748:	af00      	add	r7, sp, #0
 802174a:	6078      	str	r0, [r7, #4]
    XMEMSET(sha256->digest, 0, sizeof(sha256->digest));
 802174c:	687b      	ldr	r3, [r7, #4]
 802174e:	2220      	movs	r2, #32
 8021750:	2100      	movs	r1, #0
 8021752:	4618      	mov	r0, r3
 8021754:	f007 fa66 	bl	8028c24 <memset>
    sha256->digest[0] = 0x6A09E667L;
 8021758:	687b      	ldr	r3, [r7, #4]
 802175a:	4a12      	ldr	r2, [pc, #72]	@ (80217a4 <InitSha256+0x60>)
 802175c:	601a      	str	r2, [r3, #0]
    sha256->digest[1] = 0xBB67AE85L;
 802175e:	687b      	ldr	r3, [r7, #4]
 8021760:	4a11      	ldr	r2, [pc, #68]	@ (80217a8 <InitSha256+0x64>)
 8021762:	605a      	str	r2, [r3, #4]
    sha256->digest[2] = 0x3C6EF372L;
 8021764:	687b      	ldr	r3, [r7, #4]
 8021766:	4a11      	ldr	r2, [pc, #68]	@ (80217ac <InitSha256+0x68>)
 8021768:	609a      	str	r2, [r3, #8]
    sha256->digest[3] = 0xA54FF53AL;
 802176a:	687b      	ldr	r3, [r7, #4]
 802176c:	4a10      	ldr	r2, [pc, #64]	@ (80217b0 <InitSha256+0x6c>)
 802176e:	60da      	str	r2, [r3, #12]
    sha256->digest[4] = 0x510E527FL;
 8021770:	687b      	ldr	r3, [r7, #4]
 8021772:	4a10      	ldr	r2, [pc, #64]	@ (80217b4 <InitSha256+0x70>)
 8021774:	611a      	str	r2, [r3, #16]
    sha256->digest[5] = 0x9B05688CL;
 8021776:	687b      	ldr	r3, [r7, #4]
 8021778:	4a0f      	ldr	r2, [pc, #60]	@ (80217b8 <InitSha256+0x74>)
 802177a:	615a      	str	r2, [r3, #20]
    sha256->digest[6] = 0x1F83D9ABL;
 802177c:	687b      	ldr	r3, [r7, #4]
 802177e:	4a0f      	ldr	r2, [pc, #60]	@ (80217bc <InitSha256+0x78>)
 8021780:	619a      	str	r2, [r3, #24]
    sha256->digest[7] = 0x5BE0CD19L;
 8021782:	687b      	ldr	r3, [r7, #4]
 8021784:	4a0e      	ldr	r2, [pc, #56]	@ (80217c0 <InitSha256+0x7c>)
 8021786:	61da      	str	r2, [r3, #28]

    sha256->buffLen = 0;
 8021788:	687b      	ldr	r3, [r7, #4]
 802178a:	2200      	movs	r2, #0
 802178c:	661a      	str	r2, [r3, #96]	@ 0x60
    sha256->loLen   = 0;
 802178e:	687b      	ldr	r3, [r7, #4]
 8021790:	2200      	movs	r2, #0
 8021792:	665a      	str	r2, [r3, #100]	@ 0x64
    sha256->hiLen   = 0;
 8021794:	687b      	ldr	r3, [r7, #4]
 8021796:	2200      	movs	r2, #0
 8021798:	669a      	str	r2, [r3, #104]	@ 0x68

#ifdef HAVE_ARIA
    sha256->hSession = NULL;
#endif

    return 0;
 802179a:	2300      	movs	r3, #0
}
 802179c:	4618      	mov	r0, r3
 802179e:	3708      	adds	r7, #8
 80217a0:	46bd      	mov	sp, r7
 80217a2:	bd80      	pop	{r7, pc}
 80217a4:	6a09e667 	.word	0x6a09e667
 80217a8:	bb67ae85 	.word	0xbb67ae85
 80217ac:	3c6ef372 	.word	0x3c6ef372
 80217b0:	a54ff53a 	.word	0xa54ff53a
 80217b4:	510e527f 	.word	0x510e527f
 80217b8:	9b05688c 	.word	0x9b05688c
 80217bc:	1f83d9ab 	.word	0x1f83d9ab
 80217c0:	5be0cd19 	.word	0x5be0cd19

080217c4 <wc_InitSha256_ex>:

#else
    #define NEED_SOFT_SHA256

    int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
    {
 80217c4:	b580      	push	{r7, lr}
 80217c6:	b086      	sub	sp, #24
 80217c8:	af00      	add	r7, sp, #0
 80217ca:	60f8      	str	r0, [r7, #12]
 80217cc:	60b9      	str	r1, [r7, #8]
 80217ce:	607a      	str	r2, [r7, #4]
        int ret = 0;
 80217d0:	2300      	movs	r3, #0
 80217d2:	617b      	str	r3, [r7, #20]
        if (sha256 == NULL)
 80217d4:	68fb      	ldr	r3, [r7, #12]
 80217d6:	2b00      	cmp	r3, #0
 80217d8:	d102      	bne.n	80217e0 <wc_InitSha256_ex+0x1c>
            return BAD_FUNC_ARG;
 80217da:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80217de:	e00c      	b.n	80217fa <wc_InitSha256_ex+0x36>
        ret = InitSha256(sha256);
 80217e0:	68f8      	ldr	r0, [r7, #12]
 80217e2:	f7ff ffaf 	bl	8021744 <InitSha256>
 80217e6:	6178      	str	r0, [r7, #20]
        if (ret != 0)
 80217e8:	697b      	ldr	r3, [r7, #20]
 80217ea:	2b00      	cmp	r3, #0
 80217ec:	d001      	beq.n	80217f2 <wc_InitSha256_ex+0x2e>
            return ret;
 80217ee:	697b      	ldr	r3, [r7, #20]
 80217f0:	e003      	b.n	80217fa <wc_InitSha256_ex+0x36>

        sha256->heap = heap;
 80217f2:	68fb      	ldr	r3, [r7, #12]
 80217f4:	68ba      	ldr	r2, [r7, #8]
 80217f6:	66da      	str	r2, [r3, #108]	@ 0x6c
    #endif /* WOLFSSL_ASYNC_CRYPT */
    #ifdef WOLFSSL_IMXRT1170_CAAM
         ret = wc_CAAM_HashInit(&sha256->hndl, &sha256->ctx, WC_HASH_TYPE_SHA256);
    #endif

        return ret;
 80217f8:	697b      	ldr	r3, [r7, #20]
    }
 80217fa:	4618      	mov	r0, r3
 80217fc:	3718      	adds	r7, #24
 80217fe:	46bd      	mov	sp, r7
 8021800:	bd80      	pop	{r7, pc}
	...

08021804 <Transform_Sha256>:
         t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
         d(j) += t0; \
         h(j)  = t0 + t1

    static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
    {
 8021804:	b5b0      	push	{r4, r5, r7, lr}
 8021806:	b090      	sub	sp, #64	@ 0x40
 8021808:	af00      	add	r7, sp, #0
 802180a:	6078      	str	r0, [r7, #4]
 802180c:	6039      	str	r1, [r7, #0]
                return MEMORY_E;
            sha256->W = W;
        }
    #elif defined(WOLFSSL_SMALL_STACK)
        word32* W;
        W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
 802180e:	f44f 7080 	mov.w	r0, #256	@ 0x100
 8021812:	f7fd fa33 	bl	801ec7c <wolfSSL_Malloc>
 8021816:	63b8      	str	r0, [r7, #56]	@ 0x38
                                                       DYNAMIC_TYPE_TMP_BUFFER);
        if (W == NULL)
 8021818:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802181a:	2b00      	cmp	r3, #0
 802181c:	d102      	bne.n	8021824 <Transform_Sha256+0x20>
            return MEMORY_E;
 802181e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8021822:	e364      	b.n	8021eee <Transform_Sha256+0x6ea>
    #else
        word32 W[WC_SHA256_BLOCK_SIZE];
    #endif

        /* Copy context->state[] to working vars */
        for (i = 0; i < 8; i++)
 8021824:	2300      	movs	r3, #0
 8021826:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021828:	e00c      	b.n	8021844 <Transform_Sha256+0x40>
            S[i] = sha256->digest[i];
 802182a:	687b      	ldr	r3, [r7, #4]
 802182c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802182e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8021832:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021834:	009b      	lsls	r3, r3, #2
 8021836:	3340      	adds	r3, #64	@ 0x40
 8021838:	443b      	add	r3, r7
 802183a:	f843 2c34 	str.w	r2, [r3, #-52]
        for (i = 0; i < 8; i++)
 802183e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021840:	3301      	adds	r3, #1
 8021842:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021844:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021846:	2b07      	cmp	r3, #7
 8021848:	ddef      	ble.n	802182a <Transform_Sha256+0x26>

        for (i = 0; i < 16; i++)
 802184a:	2300      	movs	r3, #0
 802184c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802184e:	e00d      	b.n	802186c <Transform_Sha256+0x68>
            W[i] = *((const word32*)&data[i*(int)sizeof(word32)]);
 8021850:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021852:	009b      	lsls	r3, r3, #2
 8021854:	461a      	mov	r2, r3
 8021856:	683b      	ldr	r3, [r7, #0]
 8021858:	441a      	add	r2, r3
 802185a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802185c:	009b      	lsls	r3, r3, #2
 802185e:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021860:	440b      	add	r3, r1
 8021862:	6812      	ldr	r2, [r2, #0]
 8021864:	601a      	str	r2, [r3, #0]
        for (i = 0; i < 16; i++)
 8021866:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021868:	3301      	adds	r3, #1
 802186a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802186c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802186e:	2b0f      	cmp	r3, #15
 8021870:	ddee      	ble.n	8021850 <Transform_Sha256+0x4c>

        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 8021872:	2310      	movs	r3, #16
 8021874:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021876:	e066      	b.n	8021946 <Transform_Sha256+0x142>
            W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
 8021878:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802187a:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 802187e:	3b02      	subs	r3, #2
 8021880:	009b      	lsls	r3, r3, #2
 8021882:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8021884:	4413      	add	r3, r2
 8021886:	681b      	ldr	r3, [r3, #0]
 8021888:	2111      	movs	r1, #17
 802188a:	4618      	mov	r0, r3
 802188c:	f7ff fee5 	bl	802165a <rotrFixed>
 8021890:	4604      	mov	r4, r0
 8021892:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021894:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8021898:	3b02      	subs	r3, #2
 802189a:	009b      	lsls	r3, r3, #2
 802189c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802189e:	4413      	add	r3, r2
 80218a0:	681b      	ldr	r3, [r3, #0]
 80218a2:	2113      	movs	r1, #19
 80218a4:	4618      	mov	r0, r3
 80218a6:	f7ff fed8 	bl	802165a <rotrFixed>
 80218aa:	4603      	mov	r3, r0
 80218ac:	ea84 0203 	eor.w	r2, r4, r3
 80218b0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80218b2:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80218b6:	3b02      	subs	r3, #2
 80218b8:	009b      	lsls	r3, r3, #2
 80218ba:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80218bc:	440b      	add	r3, r1
 80218be:	681b      	ldr	r3, [r3, #0]
 80218c0:	0a9b      	lsrs	r3, r3, #10
 80218c2:	405a      	eors	r2, r3
 80218c4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80218c6:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80218ca:	3b07      	subs	r3, #7
 80218cc:	009b      	lsls	r3, r3, #2
 80218ce:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80218d0:	440b      	add	r3, r1
 80218d2:	681b      	ldr	r3, [r3, #0]
 80218d4:	18d4      	adds	r4, r2, r3
 80218d6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80218d8:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80218dc:	3b0f      	subs	r3, #15
 80218de:	009b      	lsls	r3, r3, #2
 80218e0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80218e2:	4413      	add	r3, r2
 80218e4:	681b      	ldr	r3, [r3, #0]
 80218e6:	2107      	movs	r1, #7
 80218e8:	4618      	mov	r0, r3
 80218ea:	f7ff feb6 	bl	802165a <rotrFixed>
 80218ee:	4605      	mov	r5, r0
 80218f0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80218f2:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80218f6:	3b0f      	subs	r3, #15
 80218f8:	009b      	lsls	r3, r3, #2
 80218fa:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80218fc:	4413      	add	r3, r2
 80218fe:	681b      	ldr	r3, [r3, #0]
 8021900:	2112      	movs	r1, #18
 8021902:	4618      	mov	r0, r3
 8021904:	f7ff fea9 	bl	802165a <rotrFixed>
 8021908:	4603      	mov	r3, r0
 802190a:	ea85 0203 	eor.w	r2, r5, r3
 802190e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021910:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8021914:	3b0f      	subs	r3, #15
 8021916:	009b      	lsls	r3, r3, #2
 8021918:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 802191a:	440b      	add	r3, r1
 802191c:	681b      	ldr	r3, [r3, #0]
 802191e:	08db      	lsrs	r3, r3, #3
 8021920:	4053      	eors	r3, r2
 8021922:	18e1      	adds	r1, r4, r3
 8021924:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021926:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 802192a:	3b10      	subs	r3, #16
 802192c:	009b      	lsls	r3, r3, #2
 802192e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8021930:	4413      	add	r3, r2
 8021932:	681a      	ldr	r2, [r3, #0]
 8021934:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021936:	009b      	lsls	r3, r3, #2
 8021938:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 802193a:	4403      	add	r3, r0
 802193c:	440a      	add	r2, r1
 802193e:	601a      	str	r2, [r3, #0]
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 8021940:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021942:	3301      	adds	r3, #1
 8021944:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021946:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021948:	2b3f      	cmp	r3, #63	@ 0x3f
 802194a:	dd95      	ble.n	8021878 <Transform_Sha256+0x74>
                RND(j);
            }
        }
    #else
        /* partially loop unrolled */
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 802194c:	2300      	movs	r3, #0
 802194e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021950:	e2a3      	b.n	8021e9a <Transform_Sha256+0x696>
            RND(0); RND(1); RND(2); RND(3);
 8021952:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8021954:	69fb      	ldr	r3, [r7, #28]
 8021956:	2106      	movs	r1, #6
 8021958:	4618      	mov	r0, r3
 802195a:	f7ff fe7e 	bl	802165a <rotrFixed>
 802195e:	4605      	mov	r5, r0
 8021960:	69fb      	ldr	r3, [r7, #28]
 8021962:	210b      	movs	r1, #11
 8021964:	4618      	mov	r0, r3
 8021966:	f7ff fe78 	bl	802165a <rotrFixed>
 802196a:	4603      	mov	r3, r0
 802196c:	405d      	eors	r5, r3
 802196e:	69fb      	ldr	r3, [r7, #28]
 8021970:	2119      	movs	r1, #25
 8021972:	4618      	mov	r0, r3
 8021974:	f7ff fe71 	bl	802165a <rotrFixed>
 8021978:	4603      	mov	r3, r0
 802197a:	406b      	eors	r3, r5
 802197c:	18e2      	adds	r2, r4, r3
 802197e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8021980:	69f8      	ldr	r0, [r7, #28]
 8021982:	6a3c      	ldr	r4, [r7, #32]
 8021984:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021986:	4063      	eors	r3, r4
 8021988:	4003      	ands	r3, r0
 802198a:	404b      	eors	r3, r1
 802198c:	441a      	add	r2, r3
 802198e:	49bd      	ldr	r1, [pc, #756]	@ (8021c84 <Transform_Sha256+0x480>)
 8021990:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021992:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021996:	441a      	add	r2, r3
 8021998:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802199a:	009b      	lsls	r3, r3, #2
 802199c:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 802199e:	440b      	add	r3, r1
 80219a0:	681b      	ldr	r3, [r3, #0]
 80219a2:	4413      	add	r3, r2
 80219a4:	633b      	str	r3, [r7, #48]	@ 0x30
 80219a6:	68fb      	ldr	r3, [r7, #12]
 80219a8:	2102      	movs	r1, #2
 80219aa:	4618      	mov	r0, r3
 80219ac:	f7ff fe55 	bl	802165a <rotrFixed>
 80219b0:	4604      	mov	r4, r0
 80219b2:	68fb      	ldr	r3, [r7, #12]
 80219b4:	210d      	movs	r1, #13
 80219b6:	4618      	mov	r0, r3
 80219b8:	f7ff fe4f 	bl	802165a <rotrFixed>
 80219bc:	4603      	mov	r3, r0
 80219be:	405c      	eors	r4, r3
 80219c0:	68fb      	ldr	r3, [r7, #12]
 80219c2:	2116      	movs	r1, #22
 80219c4:	4618      	mov	r0, r3
 80219c6:	f7ff fe48 	bl	802165a <rotrFixed>
 80219ca:	4603      	mov	r3, r0
 80219cc:	ea84 0203 	eor.w	r2, r4, r3
 80219d0:	68f9      	ldr	r1, [r7, #12]
 80219d2:	693b      	ldr	r3, [r7, #16]
 80219d4:	4319      	orrs	r1, r3
 80219d6:	697b      	ldr	r3, [r7, #20]
 80219d8:	4019      	ands	r1, r3
 80219da:	68f8      	ldr	r0, [r7, #12]
 80219dc:	693b      	ldr	r3, [r7, #16]
 80219de:	4003      	ands	r3, r0
 80219e0:	430b      	orrs	r3, r1
 80219e2:	4413      	add	r3, r2
 80219e4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80219e6:	69ba      	ldr	r2, [r7, #24]
 80219e8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80219ea:	4413      	add	r3, r2
 80219ec:	61bb      	str	r3, [r7, #24]
 80219ee:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80219f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80219f2:	4413      	add	r3, r2
 80219f4:	62bb      	str	r3, [r7, #40]	@ 0x28
 80219f6:	6a7c      	ldr	r4, [r7, #36]	@ 0x24
 80219f8:	69bb      	ldr	r3, [r7, #24]
 80219fa:	2106      	movs	r1, #6
 80219fc:	4618      	mov	r0, r3
 80219fe:	f7ff fe2c 	bl	802165a <rotrFixed>
 8021a02:	4605      	mov	r5, r0
 8021a04:	69bb      	ldr	r3, [r7, #24]
 8021a06:	210b      	movs	r1, #11
 8021a08:	4618      	mov	r0, r3
 8021a0a:	f7ff fe26 	bl	802165a <rotrFixed>
 8021a0e:	4603      	mov	r3, r0
 8021a10:	405d      	eors	r5, r3
 8021a12:	69bb      	ldr	r3, [r7, #24]
 8021a14:	2119      	movs	r1, #25
 8021a16:	4618      	mov	r0, r3
 8021a18:	f7ff fe1f 	bl	802165a <rotrFixed>
 8021a1c:	4603      	mov	r3, r0
 8021a1e:	406b      	eors	r3, r5
 8021a20:	18e2      	adds	r2, r4, r3
 8021a22:	6a39      	ldr	r1, [r7, #32]
 8021a24:	69b8      	ldr	r0, [r7, #24]
 8021a26:	69fc      	ldr	r4, [r7, #28]
 8021a28:	6a3b      	ldr	r3, [r7, #32]
 8021a2a:	4063      	eors	r3, r4
 8021a2c:	4003      	ands	r3, r0
 8021a2e:	404b      	eors	r3, r1
 8021a30:	441a      	add	r2, r3
 8021a32:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021a34:	3301      	adds	r3, #1
 8021a36:	4993      	ldr	r1, [pc, #588]	@ (8021c84 <Transform_Sha256+0x480>)
 8021a38:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021a3c:	441a      	add	r2, r3
 8021a3e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021a40:	3301      	adds	r3, #1
 8021a42:	009b      	lsls	r3, r3, #2
 8021a44:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021a46:	440b      	add	r3, r1
 8021a48:	681b      	ldr	r3, [r3, #0]
 8021a4a:	4413      	add	r3, r2
 8021a4c:	633b      	str	r3, [r7, #48]	@ 0x30
 8021a4e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021a50:	2102      	movs	r1, #2
 8021a52:	4618      	mov	r0, r3
 8021a54:	f7ff fe01 	bl	802165a <rotrFixed>
 8021a58:	4604      	mov	r4, r0
 8021a5a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021a5c:	210d      	movs	r1, #13
 8021a5e:	4618      	mov	r0, r3
 8021a60:	f7ff fdfb 	bl	802165a <rotrFixed>
 8021a64:	4603      	mov	r3, r0
 8021a66:	405c      	eors	r4, r3
 8021a68:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021a6a:	2116      	movs	r1, #22
 8021a6c:	4618      	mov	r0, r3
 8021a6e:	f7ff fdf4 	bl	802165a <rotrFixed>
 8021a72:	4603      	mov	r3, r0
 8021a74:	ea84 0203 	eor.w	r2, r4, r3
 8021a78:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8021a7a:	68fb      	ldr	r3, [r7, #12]
 8021a7c:	4319      	orrs	r1, r3
 8021a7e:	693b      	ldr	r3, [r7, #16]
 8021a80:	4019      	ands	r1, r3
 8021a82:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8021a84:	68fb      	ldr	r3, [r7, #12]
 8021a86:	4003      	ands	r3, r0
 8021a88:	430b      	orrs	r3, r1
 8021a8a:	4413      	add	r3, r2
 8021a8c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021a8e:	697a      	ldr	r2, [r7, #20]
 8021a90:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021a92:	4413      	add	r3, r2
 8021a94:	617b      	str	r3, [r7, #20]
 8021a96:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021a98:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021a9a:	4413      	add	r3, r2
 8021a9c:	627b      	str	r3, [r7, #36]	@ 0x24
 8021a9e:	6a3c      	ldr	r4, [r7, #32]
 8021aa0:	697b      	ldr	r3, [r7, #20]
 8021aa2:	2106      	movs	r1, #6
 8021aa4:	4618      	mov	r0, r3
 8021aa6:	f7ff fdd8 	bl	802165a <rotrFixed>
 8021aaa:	4605      	mov	r5, r0
 8021aac:	697b      	ldr	r3, [r7, #20]
 8021aae:	210b      	movs	r1, #11
 8021ab0:	4618      	mov	r0, r3
 8021ab2:	f7ff fdd2 	bl	802165a <rotrFixed>
 8021ab6:	4603      	mov	r3, r0
 8021ab8:	405d      	eors	r5, r3
 8021aba:	697b      	ldr	r3, [r7, #20]
 8021abc:	2119      	movs	r1, #25
 8021abe:	4618      	mov	r0, r3
 8021ac0:	f7ff fdcb 	bl	802165a <rotrFixed>
 8021ac4:	4603      	mov	r3, r0
 8021ac6:	406b      	eors	r3, r5
 8021ac8:	18e2      	adds	r2, r4, r3
 8021aca:	69f9      	ldr	r1, [r7, #28]
 8021acc:	6978      	ldr	r0, [r7, #20]
 8021ace:	69bc      	ldr	r4, [r7, #24]
 8021ad0:	69fb      	ldr	r3, [r7, #28]
 8021ad2:	4063      	eors	r3, r4
 8021ad4:	4003      	ands	r3, r0
 8021ad6:	404b      	eors	r3, r1
 8021ad8:	441a      	add	r2, r3
 8021ada:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021adc:	3302      	adds	r3, #2
 8021ade:	4969      	ldr	r1, [pc, #420]	@ (8021c84 <Transform_Sha256+0x480>)
 8021ae0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021ae4:	441a      	add	r2, r3
 8021ae6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021ae8:	3302      	adds	r3, #2
 8021aea:	009b      	lsls	r3, r3, #2
 8021aec:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021aee:	440b      	add	r3, r1
 8021af0:	681b      	ldr	r3, [r3, #0]
 8021af2:	4413      	add	r3, r2
 8021af4:	633b      	str	r3, [r7, #48]	@ 0x30
 8021af6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021af8:	2102      	movs	r1, #2
 8021afa:	4618      	mov	r0, r3
 8021afc:	f7ff fdad 	bl	802165a <rotrFixed>
 8021b00:	4604      	mov	r4, r0
 8021b02:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021b04:	210d      	movs	r1, #13
 8021b06:	4618      	mov	r0, r3
 8021b08:	f7ff fda7 	bl	802165a <rotrFixed>
 8021b0c:	4603      	mov	r3, r0
 8021b0e:	405c      	eors	r4, r3
 8021b10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021b12:	2116      	movs	r1, #22
 8021b14:	4618      	mov	r0, r3
 8021b16:	f7ff fda0 	bl	802165a <rotrFixed>
 8021b1a:	4603      	mov	r3, r0
 8021b1c:	ea84 0203 	eor.w	r2, r4, r3
 8021b20:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8021b22:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021b24:	4319      	orrs	r1, r3
 8021b26:	68fb      	ldr	r3, [r7, #12]
 8021b28:	4019      	ands	r1, r3
 8021b2a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021b2c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021b2e:	4003      	ands	r3, r0
 8021b30:	430b      	orrs	r3, r1
 8021b32:	4413      	add	r3, r2
 8021b34:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021b36:	693a      	ldr	r2, [r7, #16]
 8021b38:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021b3a:	4413      	add	r3, r2
 8021b3c:	613b      	str	r3, [r7, #16]
 8021b3e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021b40:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021b42:	4413      	add	r3, r2
 8021b44:	623b      	str	r3, [r7, #32]
 8021b46:	69fc      	ldr	r4, [r7, #28]
 8021b48:	693b      	ldr	r3, [r7, #16]
 8021b4a:	2106      	movs	r1, #6
 8021b4c:	4618      	mov	r0, r3
 8021b4e:	f7ff fd84 	bl	802165a <rotrFixed>
 8021b52:	4605      	mov	r5, r0
 8021b54:	693b      	ldr	r3, [r7, #16]
 8021b56:	210b      	movs	r1, #11
 8021b58:	4618      	mov	r0, r3
 8021b5a:	f7ff fd7e 	bl	802165a <rotrFixed>
 8021b5e:	4603      	mov	r3, r0
 8021b60:	405d      	eors	r5, r3
 8021b62:	693b      	ldr	r3, [r7, #16]
 8021b64:	2119      	movs	r1, #25
 8021b66:	4618      	mov	r0, r3
 8021b68:	f7ff fd77 	bl	802165a <rotrFixed>
 8021b6c:	4603      	mov	r3, r0
 8021b6e:	406b      	eors	r3, r5
 8021b70:	18e2      	adds	r2, r4, r3
 8021b72:	69b9      	ldr	r1, [r7, #24]
 8021b74:	6938      	ldr	r0, [r7, #16]
 8021b76:	697c      	ldr	r4, [r7, #20]
 8021b78:	69bb      	ldr	r3, [r7, #24]
 8021b7a:	4063      	eors	r3, r4
 8021b7c:	4003      	ands	r3, r0
 8021b7e:	404b      	eors	r3, r1
 8021b80:	441a      	add	r2, r3
 8021b82:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021b84:	3303      	adds	r3, #3
 8021b86:	493f      	ldr	r1, [pc, #252]	@ (8021c84 <Transform_Sha256+0x480>)
 8021b88:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021b8c:	441a      	add	r2, r3
 8021b8e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021b90:	3303      	adds	r3, #3
 8021b92:	009b      	lsls	r3, r3, #2
 8021b94:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021b96:	440b      	add	r3, r1
 8021b98:	681b      	ldr	r3, [r3, #0]
 8021b9a:	4413      	add	r3, r2
 8021b9c:	633b      	str	r3, [r7, #48]	@ 0x30
 8021b9e:	6a3b      	ldr	r3, [r7, #32]
 8021ba0:	2102      	movs	r1, #2
 8021ba2:	4618      	mov	r0, r3
 8021ba4:	f7ff fd59 	bl	802165a <rotrFixed>
 8021ba8:	4604      	mov	r4, r0
 8021baa:	6a3b      	ldr	r3, [r7, #32]
 8021bac:	210d      	movs	r1, #13
 8021bae:	4618      	mov	r0, r3
 8021bb0:	f7ff fd53 	bl	802165a <rotrFixed>
 8021bb4:	4603      	mov	r3, r0
 8021bb6:	405c      	eors	r4, r3
 8021bb8:	6a3b      	ldr	r3, [r7, #32]
 8021bba:	2116      	movs	r1, #22
 8021bbc:	4618      	mov	r0, r3
 8021bbe:	f7ff fd4c 	bl	802165a <rotrFixed>
 8021bc2:	4603      	mov	r3, r0
 8021bc4:	ea84 0203 	eor.w	r2, r4, r3
 8021bc8:	6a39      	ldr	r1, [r7, #32]
 8021bca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021bcc:	4319      	orrs	r1, r3
 8021bce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021bd0:	4019      	ands	r1, r3
 8021bd2:	6a38      	ldr	r0, [r7, #32]
 8021bd4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021bd6:	4003      	ands	r3, r0
 8021bd8:	430b      	orrs	r3, r1
 8021bda:	4413      	add	r3, r2
 8021bdc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021bde:	68fa      	ldr	r2, [r7, #12]
 8021be0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021be2:	4413      	add	r3, r2
 8021be4:	60fb      	str	r3, [r7, #12]
 8021be6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021be8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021bea:	4413      	add	r3, r2
 8021bec:	61fb      	str	r3, [r7, #28]
            RND(4); RND(5); RND(6); RND(7);
 8021bee:	69bc      	ldr	r4, [r7, #24]
 8021bf0:	68fb      	ldr	r3, [r7, #12]
 8021bf2:	2106      	movs	r1, #6
 8021bf4:	4618      	mov	r0, r3
 8021bf6:	f7ff fd30 	bl	802165a <rotrFixed>
 8021bfa:	4605      	mov	r5, r0
 8021bfc:	68fb      	ldr	r3, [r7, #12]
 8021bfe:	210b      	movs	r1, #11
 8021c00:	4618      	mov	r0, r3
 8021c02:	f7ff fd2a 	bl	802165a <rotrFixed>
 8021c06:	4603      	mov	r3, r0
 8021c08:	405d      	eors	r5, r3
 8021c0a:	68fb      	ldr	r3, [r7, #12]
 8021c0c:	2119      	movs	r1, #25
 8021c0e:	4618      	mov	r0, r3
 8021c10:	f7ff fd23 	bl	802165a <rotrFixed>
 8021c14:	4603      	mov	r3, r0
 8021c16:	406b      	eors	r3, r5
 8021c18:	18e2      	adds	r2, r4, r3
 8021c1a:	6979      	ldr	r1, [r7, #20]
 8021c1c:	68f8      	ldr	r0, [r7, #12]
 8021c1e:	693c      	ldr	r4, [r7, #16]
 8021c20:	697b      	ldr	r3, [r7, #20]
 8021c22:	4063      	eors	r3, r4
 8021c24:	4003      	ands	r3, r0
 8021c26:	404b      	eors	r3, r1
 8021c28:	441a      	add	r2, r3
 8021c2a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021c2c:	3304      	adds	r3, #4
 8021c2e:	4915      	ldr	r1, [pc, #84]	@ (8021c84 <Transform_Sha256+0x480>)
 8021c30:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021c34:	441a      	add	r2, r3
 8021c36:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021c38:	3304      	adds	r3, #4
 8021c3a:	009b      	lsls	r3, r3, #2
 8021c3c:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021c3e:	440b      	add	r3, r1
 8021c40:	681b      	ldr	r3, [r3, #0]
 8021c42:	4413      	add	r3, r2
 8021c44:	633b      	str	r3, [r7, #48]	@ 0x30
 8021c46:	69fb      	ldr	r3, [r7, #28]
 8021c48:	2102      	movs	r1, #2
 8021c4a:	4618      	mov	r0, r3
 8021c4c:	f7ff fd05 	bl	802165a <rotrFixed>
 8021c50:	4604      	mov	r4, r0
 8021c52:	69fb      	ldr	r3, [r7, #28]
 8021c54:	210d      	movs	r1, #13
 8021c56:	4618      	mov	r0, r3
 8021c58:	f7ff fcff 	bl	802165a <rotrFixed>
 8021c5c:	4603      	mov	r3, r0
 8021c5e:	405c      	eors	r4, r3
 8021c60:	69fb      	ldr	r3, [r7, #28]
 8021c62:	2116      	movs	r1, #22
 8021c64:	4618      	mov	r0, r3
 8021c66:	f7ff fcf8 	bl	802165a <rotrFixed>
 8021c6a:	4603      	mov	r3, r0
 8021c6c:	ea84 0203 	eor.w	r2, r4, r3
 8021c70:	69f9      	ldr	r1, [r7, #28]
 8021c72:	6a3b      	ldr	r3, [r7, #32]
 8021c74:	4319      	orrs	r1, r3
 8021c76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021c78:	4019      	ands	r1, r3
 8021c7a:	69f8      	ldr	r0, [r7, #28]
 8021c7c:	6a3b      	ldr	r3, [r7, #32]
 8021c7e:	4003      	ands	r3, r0
 8021c80:	430b      	orrs	r3, r1
 8021c82:	e001      	b.n	8021c88 <Transform_Sha256+0x484>
 8021c84:	08034af0 	.word	0x08034af0
 8021c88:	4413      	add	r3, r2
 8021c8a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021c8c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8021c8e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021c90:	4413      	add	r3, r2
 8021c92:	62bb      	str	r3, [r7, #40]	@ 0x28
 8021c94:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021c96:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021c98:	4413      	add	r3, r2
 8021c9a:	61bb      	str	r3, [r7, #24]
 8021c9c:	697c      	ldr	r4, [r7, #20]
 8021c9e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021ca0:	2106      	movs	r1, #6
 8021ca2:	4618      	mov	r0, r3
 8021ca4:	f7ff fcd9 	bl	802165a <rotrFixed>
 8021ca8:	4605      	mov	r5, r0
 8021caa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021cac:	210b      	movs	r1, #11
 8021cae:	4618      	mov	r0, r3
 8021cb0:	f7ff fcd3 	bl	802165a <rotrFixed>
 8021cb4:	4603      	mov	r3, r0
 8021cb6:	405d      	eors	r5, r3
 8021cb8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021cba:	2119      	movs	r1, #25
 8021cbc:	4618      	mov	r0, r3
 8021cbe:	f7ff fccc 	bl	802165a <rotrFixed>
 8021cc2:	4603      	mov	r3, r0
 8021cc4:	406b      	eors	r3, r5
 8021cc6:	18e2      	adds	r2, r4, r3
 8021cc8:	6939      	ldr	r1, [r7, #16]
 8021cca:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8021ccc:	68fc      	ldr	r4, [r7, #12]
 8021cce:	693b      	ldr	r3, [r7, #16]
 8021cd0:	4063      	eors	r3, r4
 8021cd2:	4003      	ands	r3, r0
 8021cd4:	404b      	eors	r3, r1
 8021cd6:	441a      	add	r2, r3
 8021cd8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021cda:	3305      	adds	r3, #5
 8021cdc:	4986      	ldr	r1, [pc, #536]	@ (8021ef8 <Transform_Sha256+0x6f4>)
 8021cde:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021ce2:	441a      	add	r2, r3
 8021ce4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021ce6:	3305      	adds	r3, #5
 8021ce8:	009b      	lsls	r3, r3, #2
 8021cea:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021cec:	440b      	add	r3, r1
 8021cee:	681b      	ldr	r3, [r3, #0]
 8021cf0:	4413      	add	r3, r2
 8021cf2:	633b      	str	r3, [r7, #48]	@ 0x30
 8021cf4:	69bb      	ldr	r3, [r7, #24]
 8021cf6:	2102      	movs	r1, #2
 8021cf8:	4618      	mov	r0, r3
 8021cfa:	f7ff fcae 	bl	802165a <rotrFixed>
 8021cfe:	4604      	mov	r4, r0
 8021d00:	69bb      	ldr	r3, [r7, #24]
 8021d02:	210d      	movs	r1, #13
 8021d04:	4618      	mov	r0, r3
 8021d06:	f7ff fca8 	bl	802165a <rotrFixed>
 8021d0a:	4603      	mov	r3, r0
 8021d0c:	405c      	eors	r4, r3
 8021d0e:	69bb      	ldr	r3, [r7, #24]
 8021d10:	2116      	movs	r1, #22
 8021d12:	4618      	mov	r0, r3
 8021d14:	f7ff fca1 	bl	802165a <rotrFixed>
 8021d18:	4603      	mov	r3, r0
 8021d1a:	ea84 0203 	eor.w	r2, r4, r3
 8021d1e:	69b9      	ldr	r1, [r7, #24]
 8021d20:	69fb      	ldr	r3, [r7, #28]
 8021d22:	4319      	orrs	r1, r3
 8021d24:	6a3b      	ldr	r3, [r7, #32]
 8021d26:	4019      	ands	r1, r3
 8021d28:	69b8      	ldr	r0, [r7, #24]
 8021d2a:	69fb      	ldr	r3, [r7, #28]
 8021d2c:	4003      	ands	r3, r0
 8021d2e:	430b      	orrs	r3, r1
 8021d30:	4413      	add	r3, r2
 8021d32:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021d34:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8021d36:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021d38:	4413      	add	r3, r2
 8021d3a:	627b      	str	r3, [r7, #36]	@ 0x24
 8021d3c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021d3e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021d40:	4413      	add	r3, r2
 8021d42:	617b      	str	r3, [r7, #20]
 8021d44:	693c      	ldr	r4, [r7, #16]
 8021d46:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021d48:	2106      	movs	r1, #6
 8021d4a:	4618      	mov	r0, r3
 8021d4c:	f7ff fc85 	bl	802165a <rotrFixed>
 8021d50:	4605      	mov	r5, r0
 8021d52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021d54:	210b      	movs	r1, #11
 8021d56:	4618      	mov	r0, r3
 8021d58:	f7ff fc7f 	bl	802165a <rotrFixed>
 8021d5c:	4603      	mov	r3, r0
 8021d5e:	405d      	eors	r5, r3
 8021d60:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021d62:	2119      	movs	r1, #25
 8021d64:	4618      	mov	r0, r3
 8021d66:	f7ff fc78 	bl	802165a <rotrFixed>
 8021d6a:	4603      	mov	r3, r0
 8021d6c:	406b      	eors	r3, r5
 8021d6e:	18e2      	adds	r2, r4, r3
 8021d70:	68f9      	ldr	r1, [r7, #12]
 8021d72:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021d74:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8021d76:	68fb      	ldr	r3, [r7, #12]
 8021d78:	4063      	eors	r3, r4
 8021d7a:	4003      	ands	r3, r0
 8021d7c:	404b      	eors	r3, r1
 8021d7e:	441a      	add	r2, r3
 8021d80:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021d82:	3306      	adds	r3, #6
 8021d84:	495c      	ldr	r1, [pc, #368]	@ (8021ef8 <Transform_Sha256+0x6f4>)
 8021d86:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021d8a:	441a      	add	r2, r3
 8021d8c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021d8e:	3306      	adds	r3, #6
 8021d90:	009b      	lsls	r3, r3, #2
 8021d92:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021d94:	440b      	add	r3, r1
 8021d96:	681b      	ldr	r3, [r3, #0]
 8021d98:	4413      	add	r3, r2
 8021d9a:	633b      	str	r3, [r7, #48]	@ 0x30
 8021d9c:	697b      	ldr	r3, [r7, #20]
 8021d9e:	2102      	movs	r1, #2
 8021da0:	4618      	mov	r0, r3
 8021da2:	f7ff fc5a 	bl	802165a <rotrFixed>
 8021da6:	4604      	mov	r4, r0
 8021da8:	697b      	ldr	r3, [r7, #20]
 8021daa:	210d      	movs	r1, #13
 8021dac:	4618      	mov	r0, r3
 8021dae:	f7ff fc54 	bl	802165a <rotrFixed>
 8021db2:	4603      	mov	r3, r0
 8021db4:	405c      	eors	r4, r3
 8021db6:	697b      	ldr	r3, [r7, #20]
 8021db8:	2116      	movs	r1, #22
 8021dba:	4618      	mov	r0, r3
 8021dbc:	f7ff fc4d 	bl	802165a <rotrFixed>
 8021dc0:	4603      	mov	r3, r0
 8021dc2:	ea84 0203 	eor.w	r2, r4, r3
 8021dc6:	6979      	ldr	r1, [r7, #20]
 8021dc8:	69bb      	ldr	r3, [r7, #24]
 8021dca:	4319      	orrs	r1, r3
 8021dcc:	69fb      	ldr	r3, [r7, #28]
 8021dce:	4019      	ands	r1, r3
 8021dd0:	6978      	ldr	r0, [r7, #20]
 8021dd2:	69bb      	ldr	r3, [r7, #24]
 8021dd4:	4003      	ands	r3, r0
 8021dd6:	430b      	orrs	r3, r1
 8021dd8:	4413      	add	r3, r2
 8021dda:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021ddc:	6a3a      	ldr	r2, [r7, #32]
 8021dde:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021de0:	4413      	add	r3, r2
 8021de2:	623b      	str	r3, [r7, #32]
 8021de4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021de6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021de8:	4413      	add	r3, r2
 8021dea:	613b      	str	r3, [r7, #16]
 8021dec:	68fc      	ldr	r4, [r7, #12]
 8021dee:	6a3b      	ldr	r3, [r7, #32]
 8021df0:	2106      	movs	r1, #6
 8021df2:	4618      	mov	r0, r3
 8021df4:	f7ff fc31 	bl	802165a <rotrFixed>
 8021df8:	4605      	mov	r5, r0
 8021dfa:	6a3b      	ldr	r3, [r7, #32]
 8021dfc:	210b      	movs	r1, #11
 8021dfe:	4618      	mov	r0, r3
 8021e00:	f7ff fc2b 	bl	802165a <rotrFixed>
 8021e04:	4603      	mov	r3, r0
 8021e06:	405d      	eors	r5, r3
 8021e08:	6a3b      	ldr	r3, [r7, #32]
 8021e0a:	2119      	movs	r1, #25
 8021e0c:	4618      	mov	r0, r3
 8021e0e:	f7ff fc24 	bl	802165a <rotrFixed>
 8021e12:	4603      	mov	r3, r0
 8021e14:	406b      	eors	r3, r5
 8021e16:	18e2      	adds	r2, r4, r3
 8021e18:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8021e1a:	6a38      	ldr	r0, [r7, #32]
 8021e1c:	6a7c      	ldr	r4, [r7, #36]	@ 0x24
 8021e1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021e20:	4063      	eors	r3, r4
 8021e22:	4003      	ands	r3, r0
 8021e24:	404b      	eors	r3, r1
 8021e26:	441a      	add	r2, r3
 8021e28:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021e2a:	3307      	adds	r3, #7
 8021e2c:	4932      	ldr	r1, [pc, #200]	@ (8021ef8 <Transform_Sha256+0x6f4>)
 8021e2e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021e32:	441a      	add	r2, r3
 8021e34:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021e36:	3307      	adds	r3, #7
 8021e38:	009b      	lsls	r3, r3, #2
 8021e3a:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021e3c:	440b      	add	r3, r1
 8021e3e:	681b      	ldr	r3, [r3, #0]
 8021e40:	4413      	add	r3, r2
 8021e42:	633b      	str	r3, [r7, #48]	@ 0x30
 8021e44:	693b      	ldr	r3, [r7, #16]
 8021e46:	2102      	movs	r1, #2
 8021e48:	4618      	mov	r0, r3
 8021e4a:	f7ff fc06 	bl	802165a <rotrFixed>
 8021e4e:	4604      	mov	r4, r0
 8021e50:	693b      	ldr	r3, [r7, #16]
 8021e52:	210d      	movs	r1, #13
 8021e54:	4618      	mov	r0, r3
 8021e56:	f7ff fc00 	bl	802165a <rotrFixed>
 8021e5a:	4603      	mov	r3, r0
 8021e5c:	405c      	eors	r4, r3
 8021e5e:	693b      	ldr	r3, [r7, #16]
 8021e60:	2116      	movs	r1, #22
 8021e62:	4618      	mov	r0, r3
 8021e64:	f7ff fbf9 	bl	802165a <rotrFixed>
 8021e68:	4603      	mov	r3, r0
 8021e6a:	ea84 0203 	eor.w	r2, r4, r3
 8021e6e:	6939      	ldr	r1, [r7, #16]
 8021e70:	697b      	ldr	r3, [r7, #20]
 8021e72:	4319      	orrs	r1, r3
 8021e74:	69bb      	ldr	r3, [r7, #24]
 8021e76:	4019      	ands	r1, r3
 8021e78:	6938      	ldr	r0, [r7, #16]
 8021e7a:	697b      	ldr	r3, [r7, #20]
 8021e7c:	4003      	ands	r3, r0
 8021e7e:	430b      	orrs	r3, r1
 8021e80:	4413      	add	r3, r2
 8021e82:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021e84:	69fa      	ldr	r2, [r7, #28]
 8021e86:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021e88:	4413      	add	r3, r2
 8021e8a:	61fb      	str	r3, [r7, #28]
 8021e8c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021e8e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021e90:	4413      	add	r3, r2
 8021e92:	60fb      	str	r3, [r7, #12]
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 8021e94:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021e96:	3308      	adds	r3, #8
 8021e98:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021e9a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021e9c:	2b3f      	cmp	r3, #63	@ 0x3f
 8021e9e:	f77f ad58 	ble.w	8021952 <Transform_Sha256+0x14e>
        }
    #endif /* USE_SLOW_SHA256 */

        /* Add the working vars back into digest state[] */
        for (i = 0; i < 8; i++) {
 8021ea2:	2300      	movs	r3, #0
 8021ea4:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021ea6:	e011      	b.n	8021ecc <Transform_Sha256+0x6c8>
            sha256->digest[i] += S[i];
 8021ea8:	687b      	ldr	r3, [r7, #4]
 8021eaa:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8021eac:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8021eb0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021eb2:	009b      	lsls	r3, r3, #2
 8021eb4:	3340      	adds	r3, #64	@ 0x40
 8021eb6:	443b      	add	r3, r7
 8021eb8:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8021ebc:	18d1      	adds	r1, r2, r3
 8021ebe:	687b      	ldr	r3, [r7, #4]
 8021ec0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8021ec2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = 0; i < 8; i++) {
 8021ec6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021ec8:	3301      	adds	r3, #1
 8021eca:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021ecc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021ece:	2b07      	cmp	r3, #7
 8021ed0:	ddea      	ble.n	8021ea8 <Transform_Sha256+0x6a4>
        }

    #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_CACHE)
        ForceZero(W, sizeof(word32) * WC_SHA256_BLOCK_SIZE);
 8021ed2:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8021ed6:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8021ed8:	f7ff fc0b 	bl	80216f2 <ForceZero>
        XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8021edc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8021ede:	637b      	str	r3, [r7, #52]	@ 0x34
 8021ee0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8021ee2:	2b00      	cmp	r3, #0
 8021ee4:	d002      	beq.n	8021eec <Transform_Sha256+0x6e8>
 8021ee6:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8021ee8:	f7fc fee4 	bl	801ecb4 <wolfSSL_Free>
    #endif
        return 0;
 8021eec:	2300      	movs	r3, #0
    }
 8021eee:	4618      	mov	r0, r3
 8021ef0:	3740      	adds	r7, #64	@ 0x40
 8021ef2:	46bd      	mov	sp, r7
 8021ef4:	bdb0      	pop	{r4, r5, r7, pc}
 8021ef6:	bf00      	nop
 8021ef8:	08034af0 	.word	0x08034af0

08021efc <AddLength>:


#ifdef XTRANSFORM

    static WC_INLINE void AddLength(wc_Sha256* sha256, word32 len)
    {
 8021efc:	b480      	push	{r7}
 8021efe:	b085      	sub	sp, #20
 8021f00:	af00      	add	r7, sp, #0
 8021f02:	6078      	str	r0, [r7, #4]
 8021f04:	6039      	str	r1, [r7, #0]
        word32 tmp = sha256->loLen;
 8021f06:	687b      	ldr	r3, [r7, #4]
 8021f08:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021f0a:	60fb      	str	r3, [r7, #12]
        if ((sha256->loLen += len) < tmp) {
 8021f0c:	687b      	ldr	r3, [r7, #4]
 8021f0e:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 8021f10:	683b      	ldr	r3, [r7, #0]
 8021f12:	441a      	add	r2, r3
 8021f14:	687b      	ldr	r3, [r7, #4]
 8021f16:	665a      	str	r2, [r3, #100]	@ 0x64
 8021f18:	687b      	ldr	r3, [r7, #4]
 8021f1a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021f1c:	68fa      	ldr	r2, [r7, #12]
 8021f1e:	429a      	cmp	r2, r3
 8021f20:	d904      	bls.n	8021f2c <AddLength+0x30>
            sha256->hiLen++;                       /* carry low to high */
 8021f22:	687b      	ldr	r3, [r7, #4]
 8021f24:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8021f26:	1c5a      	adds	r2, r3, #1
 8021f28:	687b      	ldr	r3, [r7, #4]
 8021f2a:	669a      	str	r2, [r3, #104]	@ 0x68
        }
    }
 8021f2c:	bf00      	nop
 8021f2e:	3714      	adds	r7, #20
 8021f30:	46bd      	mov	sp, r7
 8021f32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021f36:	4770      	bx	lr

08021f38 <Sha256Update>:

    /* do block size increments/updates */
    static WC_INLINE int Sha256Update(wc_Sha256* sha256, const byte* data,
        word32 len)
    {
 8021f38:	b580      	push	{r7, lr}
 8021f3a:	b088      	sub	sp, #32
 8021f3c:	af00      	add	r7, sp, #0
 8021f3e:	60f8      	str	r0, [r7, #12]
 8021f40:	60b9      	str	r1, [r7, #8]
 8021f42:	607a      	str	r2, [r7, #4]
        int ret = 0;
 8021f44:	2300      	movs	r3, #0
 8021f46:	61fb      	str	r3, [r7, #28]
        word32 blocksLen;
        byte* local;

        /* check that internal buffLen is valid */
        if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE) {
 8021f48:	68fb      	ldr	r3, [r7, #12]
 8021f4a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021f4c:	2b3f      	cmp	r3, #63	@ 0x3f
 8021f4e:	d902      	bls.n	8021f56 <Sha256Update+0x1e>
            return BUFFER_E;
 8021f50:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8021f54:	e075      	b.n	8022042 <Sha256Update+0x10a>
        }

        /* add length for final */
        AddLength(sha256, len);
 8021f56:	6879      	ldr	r1, [r7, #4]
 8021f58:	68f8      	ldr	r0, [r7, #12]
 8021f5a:	f7ff ffcf 	bl	8021efc <AddLength>

        local = (byte*)sha256->buffer;
 8021f5e:	68fb      	ldr	r3, [r7, #12]
 8021f60:	3320      	adds	r3, #32
 8021f62:	61bb      	str	r3, [r7, #24]

        /* process any remainder from previous operation */
        if (sha256->buffLen > 0) {
 8021f64:	68fb      	ldr	r3, [r7, #12]
 8021f66:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021f68:	2b00      	cmp	r3, #0
 8021f6a:	d056      	beq.n	802201a <Sha256Update+0xe2>
            blocksLen = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
 8021f6c:	68fb      	ldr	r3, [r7, #12]
 8021f6e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021f70:	f1c3 0340 	rsb	r3, r3, #64	@ 0x40
 8021f74:	4619      	mov	r1, r3
 8021f76:	6878      	ldr	r0, [r7, #4]
 8021f78:	f7ff fbd4 	bl	8021724 <min>
 8021f7c:	6178      	str	r0, [r7, #20]
            XMEMCPY(&local[sha256->buffLen], data, blocksLen);
 8021f7e:	68fb      	ldr	r3, [r7, #12]
 8021f80:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021f82:	69ba      	ldr	r2, [r7, #24]
 8021f84:	4413      	add	r3, r2
 8021f86:	697a      	ldr	r2, [r7, #20]
 8021f88:	68b9      	ldr	r1, [r7, #8]
 8021f8a:	4618      	mov	r0, r3
 8021f8c:	f006 fefb 	bl	8028d86 <memcpy>

            sha256->buffLen += blocksLen;
 8021f90:	68fb      	ldr	r3, [r7, #12]
 8021f92:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8021f94:	697b      	ldr	r3, [r7, #20]
 8021f96:	441a      	add	r2, r3
 8021f98:	68fb      	ldr	r3, [r7, #12]
 8021f9a:	661a      	str	r2, [r3, #96]	@ 0x60
            data            += blocksLen;
 8021f9c:	68ba      	ldr	r2, [r7, #8]
 8021f9e:	697b      	ldr	r3, [r7, #20]
 8021fa0:	4413      	add	r3, r2
 8021fa2:	60bb      	str	r3, [r7, #8]
            len             -= blocksLen;
 8021fa4:	687a      	ldr	r2, [r7, #4]
 8021fa6:	697b      	ldr	r3, [r7, #20]
 8021fa8:	1ad3      	subs	r3, r2, r3
 8021faa:	607b      	str	r3, [r7, #4]

            if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
 8021fac:	68fb      	ldr	r3, [r7, #12]
 8021fae:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021fb0:	2b40      	cmp	r3, #64	@ 0x40
 8021fb2:	d132      	bne.n	802201a <Sha256Update+0xe2>
                    esp_sha_try_hw_lock(&sha256->ctx);
                }
            #endif

            if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
                ByteReverseWords(sha256->buffer, sha256->buffer,
 8021fb4:	68fb      	ldr	r3, [r7, #12]
 8021fb6:	f103 0020 	add.w	r0, r3, #32
 8021fba:	68fb      	ldr	r3, [r7, #12]
 8021fbc:	3320      	adds	r3, #32
 8021fbe:	2240      	movs	r2, #64	@ 0x40
 8021fc0:	4619      	mov	r1, r3
 8021fc2:	f7ff fb70 	bl	80216a6 <ByteReverseWords>
                    #endif
                    esp_sha256_process(sha256, (const byte*)local);
                }
            #else
                /* Always SW */
                ret = XTRANSFORM(sha256, (const byte*)local);
 8021fc6:	69b9      	ldr	r1, [r7, #24]
 8021fc8:	68f8      	ldr	r0, [r7, #12]
 8021fca:	f7ff fc1b 	bl	8021804 <Transform_Sha256>
 8021fce:	61f8      	str	r0, [r7, #28]
            #endif
                if (ret == 0)
 8021fd0:	69fb      	ldr	r3, [r7, #28]
 8021fd2:	2b00      	cmp	r3, #0
 8021fd4:	d103      	bne.n	8021fde <Sha256Update+0xa6>
                    sha256->buffLen = 0;
 8021fd6:	68fb      	ldr	r3, [r7, #12]
 8021fd8:	2200      	movs	r2, #0
 8021fda:	661a      	str	r2, [r3, #96]	@ 0x60
 8021fdc:	e01d      	b.n	802201a <Sha256Update+0xe2>
                else
                    len = 0; /* error */
 8021fde:	2300      	movs	r3, #0
 8021fe0:	607b      	str	r3, [r7, #4]
    #endif /* XTRANSFORM_LEN */
    #if !defined(XTRANSFORM_LEN) || \
        (defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
         (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)))
        {
            while (len >= WC_SHA256_BLOCK_SIZE) {
 8021fe2:	e01a      	b.n	802201a <Sha256Update+0xe2>
                word32* local32 = sha256->buffer;
 8021fe4:	68fb      	ldr	r3, [r7, #12]
 8021fe6:	3320      	adds	r3, #32
 8021fe8:	613b      	str	r3, [r7, #16]
                    local32 = (word32*)data;
                }
                else
            #endif
                {
                    XMEMCPY(local32, data, WC_SHA256_BLOCK_SIZE);
 8021fea:	2240      	movs	r2, #64	@ 0x40
 8021fec:	68b9      	ldr	r1, [r7, #8]
 8021fee:	6938      	ldr	r0, [r7, #16]
 8021ff0:	f006 fec9 	bl	8028d86 <memcpy>
                }

                data += WC_SHA256_BLOCK_SIZE;
 8021ff4:	68bb      	ldr	r3, [r7, #8]
 8021ff6:	3340      	adds	r3, #64	@ 0x40
 8021ff8:	60bb      	str	r3, [r7, #8]
                len  -= WC_SHA256_BLOCK_SIZE;
 8021ffa:	687b      	ldr	r3, [r7, #4]
 8021ffc:	3b40      	subs	r3, #64	@ 0x40
 8021ffe:	607b      	str	r3, [r7, #4]
                    esp_sha_try_hw_lock(&sha256->ctx);
                }
            #endif

            if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
                ByteReverseWords(local32, local32, WC_SHA256_BLOCK_SIZE);
 8022000:	2240      	movs	r2, #64	@ 0x40
 8022002:	6939      	ldr	r1, [r7, #16]
 8022004:	6938      	ldr	r0, [r7, #16]
 8022006:	f7ff fb4e 	bl	80216a6 <ByteReverseWords>
                else {
                    ESP_LOGV(TAG, "Sha256Update process hardware");
                    esp_sha256_process(sha256, (const byte*)local32);
                }
            #else
                ret = XTRANSFORM(sha256, (const byte*)local32);
 802200a:	6939      	ldr	r1, [r7, #16]
 802200c:	68f8      	ldr	r0, [r7, #12]
 802200e:	f7ff fbf9 	bl	8021804 <Transform_Sha256>
 8022012:	61f8      	str	r0, [r7, #28]
            #endif

                if (ret != 0)
 8022014:	69fb      	ldr	r3, [r7, #28]
 8022016:	2b00      	cmp	r3, #0
 8022018:	d103      	bne.n	8022022 <Sha256Update+0xea>
            while (len >= WC_SHA256_BLOCK_SIZE) {
 802201a:	687b      	ldr	r3, [r7, #4]
 802201c:	2b3f      	cmp	r3, #63	@ 0x3f
 802201e:	d8e1      	bhi.n	8021fe4 <Sha256Update+0xac>
 8022020:	e000      	b.n	8022024 <Sha256Update+0xec>
                    break;
 8022022:	bf00      	nop
            }
        }
    #endif

        /* save remainder */
        if (ret == 0 && len > 0) {
 8022024:	69fb      	ldr	r3, [r7, #28]
 8022026:	2b00      	cmp	r3, #0
 8022028:	d10a      	bne.n	8022040 <Sha256Update+0x108>
 802202a:	687b      	ldr	r3, [r7, #4]
 802202c:	2b00      	cmp	r3, #0
 802202e:	d007      	beq.n	8022040 <Sha256Update+0x108>
            XMEMCPY(local, data, len);
 8022030:	687a      	ldr	r2, [r7, #4]
 8022032:	68b9      	ldr	r1, [r7, #8]
 8022034:	69b8      	ldr	r0, [r7, #24]
 8022036:	f006 fea6 	bl	8028d86 <memcpy>
            sha256->buffLen = len;
 802203a:	68fb      	ldr	r3, [r7, #12]
 802203c:	687a      	ldr	r2, [r7, #4]
 802203e:	661a      	str	r2, [r3, #96]	@ 0x60
        }

        return ret;
 8022040:	69fb      	ldr	r3, [r7, #28]
    }
 8022042:	4618      	mov	r0, r3
 8022044:	3720      	adds	r7, #32
 8022046:	46bd      	mov	sp, r7
 8022048:	bd80      	pop	{r7, pc}

0802204a <wc_Sha256Update>:
#if defined(WOLFSSL_KCAPI_HASH)
    /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */

#else
    int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
    {
 802204a:	b580      	push	{r7, lr}
 802204c:	b084      	sub	sp, #16
 802204e:	af00      	add	r7, sp, #0
 8022050:	60f8      	str	r0, [r7, #12]
 8022052:	60b9      	str	r1, [r7, #8]
 8022054:	607a      	str	r2, [r7, #4]
        if (sha256 == NULL) {
 8022056:	68fb      	ldr	r3, [r7, #12]
 8022058:	2b00      	cmp	r3, #0
 802205a:	d102      	bne.n	8022062 <wc_Sha256Update+0x18>
            return BAD_FUNC_ARG;
 802205c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8022060:	e013      	b.n	802208a <wc_Sha256Update+0x40>
        }
        if (data == NULL && len == 0) {
 8022062:	68bb      	ldr	r3, [r7, #8]
 8022064:	2b00      	cmp	r3, #0
 8022066:	d104      	bne.n	8022072 <wc_Sha256Update+0x28>
 8022068:	687b      	ldr	r3, [r7, #4]
 802206a:	2b00      	cmp	r3, #0
 802206c:	d101      	bne.n	8022072 <wc_Sha256Update+0x28>
            /* valid, but do nothing */
            return 0;
 802206e:	2300      	movs	r3, #0
 8022070:	e00b      	b.n	802208a <wc_Sha256Update+0x40>
        }
        if (data == NULL) {
 8022072:	68bb      	ldr	r3, [r7, #8]
 8022074:	2b00      	cmp	r3, #0
 8022076:	d102      	bne.n	802207e <wc_Sha256Update+0x34>
            return BAD_FUNC_ARG;
 8022078:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802207c:	e005      	b.n	802208a <wc_Sha256Update+0x40>
            return IntelQaSymSha256(&sha256->asyncDev, NULL, data, len);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        return Sha256Update(sha256, data, len);
 802207e:	687a      	ldr	r2, [r7, #4]
 8022080:	68b9      	ldr	r1, [r7, #8]
 8022082:	68f8      	ldr	r0, [r7, #12]
 8022084:	f7ff ff58 	bl	8021f38 <Sha256Update>
 8022088:	4603      	mov	r3, r0
    }
 802208a:	4618      	mov	r0, r3
 802208c:	3710      	adds	r7, #16
 802208e:	46bd      	mov	sp, r7
 8022090:	bd80      	pop	{r7, pc}

08022092 <Sha256Final>:
#endif

    static WC_INLINE int Sha256Final(wc_Sha256* sha256)
    {
 8022092:	b580      	push	{r7, lr}
 8022094:	b084      	sub	sp, #16
 8022096:	af00      	add	r7, sp, #0
 8022098:	6078      	str	r0, [r7, #4]
        int ret;
        byte* local;

        /* we'll add a 0x80 byte at the end,
        ** so make sure we have appropriate buffer length. */
        if (sha256->buffLen > WC_SHA256_BLOCK_SIZE - 1) {
 802209a:	687b      	ldr	r3, [r7, #4]
 802209c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 802209e:	2b3f      	cmp	r3, #63	@ 0x3f
 80220a0:	d902      	bls.n	80220a8 <Sha256Final+0x16>
            /* exit with error code if there's a bad buffer size in buffLen */
            return BAD_STATE_E;
 80220a2:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 80220a6:	e06a      	b.n	802217e <Sha256Final+0xec>
        } /* buffLen check */

        local = (byte*)sha256->buffer;
 80220a8:	687b      	ldr	r3, [r7, #4]
 80220aa:	3320      	adds	r3, #32
 80220ac:	60fb      	str	r3, [r7, #12]
        local[sha256->buffLen++] = 0x80; /* add 1 */
 80220ae:	687b      	ldr	r3, [r7, #4]
 80220b0:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80220b2:	1c59      	adds	r1, r3, #1
 80220b4:	687a      	ldr	r2, [r7, #4]
 80220b6:	6611      	str	r1, [r2, #96]	@ 0x60
 80220b8:	68fa      	ldr	r2, [r7, #12]
 80220ba:	4413      	add	r3, r2
 80220bc:	2280      	movs	r2, #128	@ 0x80
 80220be:	701a      	strb	r2, [r3, #0]

        /* pad with zeros */
        if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
 80220c0:	687b      	ldr	r3, [r7, #4]
 80220c2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80220c4:	2b38      	cmp	r3, #56	@ 0x38
 80220c6:	d925      	bls.n	8022114 <Sha256Final+0x82>
            if (sha256->buffLen < WC_SHA256_BLOCK_SIZE) {
 80220c8:	687b      	ldr	r3, [r7, #4]
 80220ca:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80220cc:	2b3f      	cmp	r3, #63	@ 0x3f
 80220ce:	d80b      	bhi.n	80220e8 <Sha256Final+0x56>
                XMEMSET(&local[sha256->buffLen], 0,
 80220d0:	687b      	ldr	r3, [r7, #4]
 80220d2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80220d4:	68fa      	ldr	r2, [r7, #12]
 80220d6:	18d0      	adds	r0, r2, r3
 80220d8:	687b      	ldr	r3, [r7, #4]
 80220da:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80220dc:	f1c3 0340 	rsb	r3, r3, #64	@ 0x40
 80220e0:	461a      	mov	r2, r3
 80220e2:	2100      	movs	r1, #0
 80220e4:	f006 fd9e 	bl	8028c24 <memset>
                esp_sha_try_hw_lock(&sha256->ctx);
            }
        #endif

        if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
            ByteReverseWords(sha256->buffer, sha256->buffer,
 80220e8:	687b      	ldr	r3, [r7, #4]
 80220ea:	f103 0020 	add.w	r0, r3, #32
 80220ee:	687b      	ldr	r3, [r7, #4]
 80220f0:	3320      	adds	r3, #32
 80220f2:	2240      	movs	r2, #64	@ 0x40
 80220f4:	4619      	mov	r1, r3
 80220f6:	f7ff fad6 	bl	80216a6 <ByteReverseWords>
            }
            else {
                ret = esp_sha256_process(sha256, (const byte*)local);
            }
        #else
            ret = XTRANSFORM(sha256, (const byte*)local);
 80220fa:	68f9      	ldr	r1, [r7, #12]
 80220fc:	6878      	ldr	r0, [r7, #4]
 80220fe:	f7ff fb81 	bl	8021804 <Transform_Sha256>
 8022102:	60b8      	str	r0, [r7, #8]
        #endif
            if (ret != 0)
 8022104:	68bb      	ldr	r3, [r7, #8]
 8022106:	2b00      	cmp	r3, #0
 8022108:	d001      	beq.n	802210e <Sha256Final+0x7c>
                return ret;
 802210a:	68bb      	ldr	r3, [r7, #8]
 802210c:	e037      	b.n	802217e <Sha256Final+0xec>

            sha256->buffLen = 0;
 802210e:	687b      	ldr	r3, [r7, #4]
 8022110:	2200      	movs	r2, #0
 8022112:	661a      	str	r2, [r3, #96]	@ 0x60
        }
        XMEMSET(&local[sha256->buffLen], 0,
 8022114:	687b      	ldr	r3, [r7, #4]
 8022116:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8022118:	68fa      	ldr	r2, [r7, #12]
 802211a:	18d0      	adds	r0, r2, r3
 802211c:	687b      	ldr	r3, [r7, #4]
 802211e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8022120:	f1c3 0338 	rsb	r3, r3, #56	@ 0x38
 8022124:	461a      	mov	r2, r3
 8022126:	2100      	movs	r1, #0
 8022128:	f006 fd7c 	bl	8028c24 <memset>
            WC_SHA256_PAD_SIZE - sha256->buffLen);

        /* put 64 bit length in separate 32 bit parts */
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 802212c:	687b      	ldr	r3, [r7, #4]
 802212e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8022130:	0f5a      	lsrs	r2, r3, #29
                                                         (sha256->hiLen << 3);
 8022132:	687b      	ldr	r3, [r7, #4]
 8022134:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8022136:	00db      	lsls	r3, r3, #3
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 8022138:	441a      	add	r2, r3
 802213a:	687b      	ldr	r3, [r7, #4]
 802213c:	669a      	str	r2, [r3, #104]	@ 0x68
        sha256->loLen = sha256->loLen << 3;
 802213e:	687b      	ldr	r3, [r7, #4]
 8022140:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8022142:	00da      	lsls	r2, r3, #3
 8022144:	687b      	ldr	r3, [r7, #4]
 8022146:	665a      	str	r2, [r3, #100]	@ 0x64
        }
    #endif

        /* store lengths */
        if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
            ByteReverseWords(sha256->buffer, sha256->buffer,
 8022148:	687b      	ldr	r3, [r7, #4]
 802214a:	f103 0020 	add.w	r0, r3, #32
 802214e:	687b      	ldr	r3, [r7, #4]
 8022150:	3320      	adds	r3, #32
 8022152:	2238      	movs	r2, #56	@ 0x38
 8022154:	4619      	mov	r1, r3
 8022156:	f7ff faa6 	bl	80216a6 <ByteReverseWords>
                WC_SHA256_PAD_SIZE);
        }
        /* ! 64-bit length ordering dependent on digest endian type ! */
        XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
 802215a:	68fb      	ldr	r3, [r7, #12]
 802215c:	3338      	adds	r3, #56	@ 0x38
 802215e:	687a      	ldr	r2, [r7, #4]
 8022160:	3268      	adds	r2, #104	@ 0x68
 8022162:	6812      	ldr	r2, [r2, #0]
 8022164:	601a      	str	r2, [r3, #0]
        XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
 8022166:	68fb      	ldr	r3, [r7, #12]
 8022168:	333c      	adds	r3, #60	@ 0x3c
 802216a:	687a      	ldr	r2, [r7, #4]
 802216c:	3264      	adds	r2, #100	@ 0x64
 802216e:	6812      	ldr	r2, [r2, #0]
 8022170:	601a      	str	r2, [r3, #0]
        }
        else {
            ret = esp_sha256_digest_process(sha256, 1);
        }
    #else
        ret = XTRANSFORM(sha256, (const byte*)local);
 8022172:	68f9      	ldr	r1, [r7, #12]
 8022174:	6878      	ldr	r0, [r7, #4]
 8022176:	f7ff fb45 	bl	8021804 <Transform_Sha256>
 802217a:	60b8      	str	r0, [r7, #8]
    #endif

        return ret;
 802217c:	68bb      	ldr	r3, [r7, #8]
    }
 802217e:	4618      	mov	r0, r3
 8022180:	3710      	adds	r7, #16
 8022182:	46bd      	mov	sp, r7
 8022184:	bd80      	pop	{r7, pc}

08022186 <wc_Sha256Final>:

        return 0;
    }

    int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
    {
 8022186:	b580      	push	{r7, lr}
 8022188:	b084      	sub	sp, #16
 802218a:	af00      	add	r7, sp, #0
 802218c:	6078      	str	r0, [r7, #4]
 802218e:	6039      	str	r1, [r7, #0]
        int ret;

        if (sha256 == NULL || hash == NULL) {
 8022190:	687b      	ldr	r3, [r7, #4]
 8022192:	2b00      	cmp	r3, #0
 8022194:	d002      	beq.n	802219c <wc_Sha256Final+0x16>
 8022196:	683b      	ldr	r3, [r7, #0]
 8022198:	2b00      	cmp	r3, #0
 802219a:	d102      	bne.n	80221a2 <wc_Sha256Final+0x1c>
            return BAD_FUNC_ARG;
 802219c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80221a0:	e018      	b.n	80221d4 <wc_Sha256Final+0x4e>
                                            WC_SHA256_DIGEST_SIZE);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Final(sha256);
 80221a2:	6878      	ldr	r0, [r7, #4]
 80221a4:	f7ff ff75 	bl	8022092 <Sha256Final>
 80221a8:	60f8      	str	r0, [r7, #12]
        if (ret != 0) {
 80221aa:	68fb      	ldr	r3, [r7, #12]
 80221ac:	2b00      	cmp	r3, #0
 80221ae:	d001      	beq.n	80221b4 <wc_Sha256Final+0x2e>
            return ret;
 80221b0:	68fb      	ldr	r3, [r7, #12]
 80221b2:	e00f      	b.n	80221d4 <wc_Sha256Final+0x4e>
        }

    #if defined(LITTLE_ENDIAN_ORDER)
        if (SHA256_REV_BYTES(&sha256->ctx)) {
            ByteReverseWords(sha256->digest, sha256->digest,
 80221b4:	687b      	ldr	r3, [r7, #4]
 80221b6:	6879      	ldr	r1, [r7, #4]
 80221b8:	2220      	movs	r2, #32
 80221ba:	4618      	mov	r0, r3
 80221bc:	f7ff fa73 	bl	80216a6 <ByteReverseWords>
                WC_SHA256_DIGEST_SIZE);
        }
    #endif
        XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
 80221c0:	687b      	ldr	r3, [r7, #4]
 80221c2:	2220      	movs	r2, #32
 80221c4:	4619      	mov	r1, r3
 80221c6:	6838      	ldr	r0, [r7, #0]
 80221c8:	f006 fddd 	bl	8028d86 <memcpy>

        return InitSha256(sha256);  /* reset state */
 80221cc:	6878      	ldr	r0, [r7, #4]
 80221ce:	f7ff fab9 	bl	8021744 <InitSha256>
 80221d2:	4603      	mov	r3, r0
    }
 80221d4:	4618      	mov	r0, r3
 80221d6:	3710      	adds	r7, #16
 80221d8:	46bd      	mov	sp, r7
 80221da:	bd80      	pop	{r7, pc}

080221dc <wc_InitSha256>:
#endif /* !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH)  */
#endif /*  WOLFSSL_SHA224 */


int wc_InitSha256(wc_Sha256* sha256)
{
 80221dc:	b580      	push	{r7, lr}
 80221de:	b084      	sub	sp, #16
 80221e0:	af00      	add	r7, sp, #0
 80221e2:	6078      	str	r0, [r7, #4]
    int devId = INVALID_DEVID;
 80221e4:	f06f 0301 	mvn.w	r3, #1
 80221e8:	60fb      	str	r3, [r7, #12]

#ifdef WOLF_CRYPTO_CB
    devId = wc_CryptoCb_DefaultDevID();
#endif
    return wc_InitSha256_ex(sha256, NULL, devId);
 80221ea:	68fa      	ldr	r2, [r7, #12]
 80221ec:	2100      	movs	r1, #0
 80221ee:	6878      	ldr	r0, [r7, #4]
 80221f0:	f7ff fae8 	bl	80217c4 <wc_InitSha256_ex>
 80221f4:	4603      	mov	r3, r0
}
 80221f6:	4618      	mov	r0, r3
 80221f8:	3710      	adds	r7, #16
 80221fa:	46bd      	mov	sp, r7
 80221fc:	bd80      	pop	{r7, pc}

080221fe <wc_Sha256Free>:

#if !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH)
    /* implemented in wolfcrypt/src/port/psa/psa_hash.c */

void wc_Sha256Free(wc_Sha256* sha256)
{
 80221fe:	b580      	push	{r7, lr}
 8022200:	b082      	sub	sp, #8
 8022202:	af00      	add	r7, sp, #0
 8022204:	6078      	str	r0, [r7, #4]
    if (sha256 == NULL)
 8022206:	687b      	ldr	r3, [r7, #4]
 8022208:	2b00      	cmp	r3, #0
 802220a:	d004      	beq.n	8022216 <wc_Sha256Free+0x18>
    }
    else {
        ESP_LOGV(TAG, "Hardware unlock not needed in wc_Sha256Free.");
    }
#endif
    ForceZero(sha256, sizeof(*sha256));
 802220c:	2170      	movs	r1, #112	@ 0x70
 802220e:	6878      	ldr	r0, [r7, #4]
 8022210:	f7ff fa6f 	bl	80216f2 <ForceZero>
 8022214:	e000      	b.n	8022218 <wc_Sha256Free+0x1a>
        return;
 8022216:	bf00      	nop
} /* wc_Sha256Free */
 8022218:	3708      	adds	r7, #8
 802221a:	46bd      	mov	sp, r7
 802221c:	bd80      	pop	{r7, pc}

0802221e <wc_SignatureDerEncode>:
#endif

#if !defined(NO_RSA) && !defined(NO_ASN)
static int wc_SignatureDerEncode(enum wc_HashType hash_type, byte* hash_data,
    word32 hash_len, word32* hash_enc_len)
{
 802221e:	b580      	push	{r7, lr}
 8022220:	b086      	sub	sp, #24
 8022222:	af00      	add	r7, sp, #0
 8022224:	60b9      	str	r1, [r7, #8]
 8022226:	607a      	str	r2, [r7, #4]
 8022228:	603b      	str	r3, [r7, #0]
 802222a:	4603      	mov	r3, r0
 802222c:	73fb      	strb	r3, [r7, #15]
    int ret, oid;

    ret = wc_HashGetOID(hash_type);
 802222e:	7bfb      	ldrb	r3, [r7, #15]
 8022230:	4618      	mov	r0, r3
 8022232:	f7fc f94f 	bl	801e4d4 <wc_HashGetOID>
 8022236:	6178      	str	r0, [r7, #20]
    if (ret < 0) {
 8022238:	697b      	ldr	r3, [r7, #20]
 802223a:	2b00      	cmp	r3, #0
 802223c:	da01      	bge.n	8022242 <wc_SignatureDerEncode+0x24>
        return ret;
 802223e:	697b      	ldr	r3, [r7, #20]
 8022240:	e012      	b.n	8022268 <wc_SignatureDerEncode+0x4a>
    }
    oid = ret;
 8022242:	697b      	ldr	r3, [r7, #20]
 8022244:	613b      	str	r3, [r7, #16]

    ret = (int)wc_EncodeSignature(hash_data, hash_data, hash_len, oid);
 8022246:	693b      	ldr	r3, [r7, #16]
 8022248:	687a      	ldr	r2, [r7, #4]
 802224a:	68b9      	ldr	r1, [r7, #8]
 802224c:	68b8      	ldr	r0, [r7, #8]
 802224e:	f7f3 ff43 	bl	80160d8 <wc_EncodeSignature>
 8022252:	4603      	mov	r3, r0
 8022254:	617b      	str	r3, [r7, #20]
    if (ret > 0) {
 8022256:	697b      	ldr	r3, [r7, #20]
 8022258:	2b00      	cmp	r3, #0
 802225a:	dd04      	ble.n	8022266 <wc_SignatureDerEncode+0x48>
        *hash_enc_len = (word32)ret;
 802225c:	697a      	ldr	r2, [r7, #20]
 802225e:	683b      	ldr	r3, [r7, #0]
 8022260:	601a      	str	r2, [r3, #0]
        ret = 0;
 8022262:	2300      	movs	r3, #0
 8022264:	617b      	str	r3, [r7, #20]
    }

    return ret;
 8022266:	697b      	ldr	r3, [r7, #20]
}
 8022268:	4618      	mov	r0, r3
 802226a:	3718      	adds	r7, #24
 802226c:	46bd      	mov	sp, r7
 802226e:	bd80      	pop	{r7, pc}

08022270 <wc_SignatureGetSize>:
#endif /* !NO_RSA && !NO_ASN */

int wc_SignatureGetSize(enum wc_SignatureType sig_type,
    const void* key, word32 key_len)
{
 8022270:	b580      	push	{r7, lr}
 8022272:	b086      	sub	sp, #24
 8022274:	af00      	add	r7, sp, #0
 8022276:	4603      	mov	r3, r0
 8022278:	60b9      	str	r1, [r7, #8]
 802227a:	607a      	str	r2, [r7, #4]
 802227c:	73fb      	strb	r3, [r7, #15]
    int sig_len = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 802227e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8022282:	617b      	str	r3, [r7, #20]

    /* Suppress possible unused args if all signature types are disabled */
    (void)key;
    (void)key_len;

    switch(sig_type) {
 8022284:	7bfb      	ldrb	r3, [r7, #15]
 8022286:	2b01      	cmp	r3, #1
 8022288:	d005      	beq.n	8022296 <wc_SignatureGetSize+0x26>
 802228a:	2b00      	cmp	r3, #0
 802228c:	dd16      	ble.n	80222bc <wc_SignatureGetSize+0x4c>
 802228e:	3b02      	subs	r3, #2
 8022290:	2b01      	cmp	r3, #1
 8022292:	d813      	bhi.n	80222bc <wc_SignatureGetSize+0x4c>
 8022294:	e008      	b.n	80222a8 <wc_SignatureGetSize+0x38>
        case WC_SIGNATURE_TYPE_ECC:
#ifdef HAVE_ECC
            /* Sanity check that void* key is at least ecc_key in size */
            if (key_len >= sizeof(ecc_key)) {
 8022296:	687b      	ldr	r3, [r7, #4]
 8022298:	f5b3 7fb8 	cmp.w	r3, #368	@ 0x170
 802229c:	d312      	bcc.n	80222c4 <wc_SignatureGetSize+0x54>
                sig_len = wc_ecc_sig_size((ecc_key*)key);
 802229e:	68b8      	ldr	r0, [r7, #8]
 80222a0:	f7fc f888 	bl	801e3b4 <wc_ecc_sig_size>
 80222a4:	6178      	str	r0, [r7, #20]
                WOLFSSL_MSG("wc_SignatureGetSize: Invalid ECC key size");
            }
#else
            sig_len = SIG_TYPE_E;
#endif
            break;
 80222a6:	e00d      	b.n	80222c4 <wc_SignatureGetSize+0x54>

        case WC_SIGNATURE_TYPE_RSA_W_ENC:
        case WC_SIGNATURE_TYPE_RSA:
#ifndef NO_RSA
            /* Sanity check that void* key is at least RsaKey in size */
            if (key_len >= sizeof(RsaKey)) {
 80222a8:	687b      	ldr	r3, [r7, #4]
 80222aa:	f241 127b 	movw	r2, #4475	@ 0x117b
 80222ae:	4293      	cmp	r3, r2
 80222b0:	d90a      	bls.n	80222c8 <wc_SignatureGetSize+0x58>
                sig_len = wc_RsaEncryptSize((RsaKey*)key);
 80222b2:	68b8      	ldr	r0, [r7, #8]
 80222b4:	f7ff f990 	bl	80215d8 <wc_RsaEncryptSize>
 80222b8:	6178      	str	r0, [r7, #20]
                WOLFSSL_MSG("wc_SignatureGetSize: Invalid RsaKey key size");
            }
#else
            sig_len = SIG_TYPE_E;
#endif
            break;
 80222ba:	e005      	b.n	80222c8 <wc_SignatureGetSize+0x58>

        case WC_SIGNATURE_TYPE_NONE:
        default:
            sig_len = BAD_FUNC_ARG;
 80222bc:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80222c0:	617b      	str	r3, [r7, #20]
            break;
 80222c2:	e002      	b.n	80222ca <wc_SignatureGetSize+0x5a>
            break;
 80222c4:	bf00      	nop
 80222c6:	e000      	b.n	80222ca <wc_SignatureGetSize+0x5a>
            break;
 80222c8:	bf00      	nop
    }
    return sig_len;
 80222ca:	697b      	ldr	r3, [r7, #20]
}
 80222cc:	4618      	mov	r0, r3
 80222ce:	3718      	adds	r7, #24
 80222d0:	46bd      	mov	sp, r7
 80222d2:	bd80      	pop	{r7, pc}

080222d4 <wc_SignatureVerifyHash>:
int wc_SignatureVerifyHash(
    enum wc_HashType hash_type, enum wc_SignatureType sig_type,
    const byte* hash_data, word32 hash_len,
    const byte* sig, word32 sig_len,
    const void* key, word32 key_len)
{
 80222d4:	b580      	push	{r7, lr}
 80222d6:	b08c      	sub	sp, #48	@ 0x30
 80222d8:	af02      	add	r7, sp, #8
 80222da:	60ba      	str	r2, [r7, #8]
 80222dc:	607b      	str	r3, [r7, #4]
 80222de:	4603      	mov	r3, r0
 80222e0:	73fb      	strb	r3, [r7, #15]
 80222e2:	460b      	mov	r3, r1
 80222e4:	73bb      	strb	r3, [r7, #14]
    int ret;

    /* Check arguments */
    if (hash_data == NULL || hash_len == 0 ||
 80222e6:	68bb      	ldr	r3, [r7, #8]
 80222e8:	2b00      	cmp	r3, #0
 80222ea:	d00e      	beq.n	802230a <wc_SignatureVerifyHash+0x36>
 80222ec:	687b      	ldr	r3, [r7, #4]
 80222ee:	2b00      	cmp	r3, #0
 80222f0:	d00b      	beq.n	802230a <wc_SignatureVerifyHash+0x36>
 80222f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80222f4:	2b00      	cmp	r3, #0
 80222f6:	d008      	beq.n	802230a <wc_SignatureVerifyHash+0x36>
        sig == NULL || sig_len == 0 ||
 80222f8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80222fa:	2b00      	cmp	r3, #0
 80222fc:	d005      	beq.n	802230a <wc_SignatureVerifyHash+0x36>
 80222fe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022300:	2b00      	cmp	r3, #0
 8022302:	d002      	beq.n	802230a <wc_SignatureVerifyHash+0x36>
        key == NULL || key_len == 0) {
 8022304:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8022306:	2b00      	cmp	r3, #0
 8022308:	d102      	bne.n	8022310 <wc_SignatureVerifyHash+0x3c>
        return BAD_FUNC_ARG;
 802230a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802230e:	e098      	b.n	8022442 <wc_SignatureVerifyHash+0x16e>
    }

    /* Validate signature len (1 to max is okay) */
    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {
 8022310:	7bbb      	ldrb	r3, [r7, #14]
 8022312:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8022314:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8022316:	4618      	mov	r0, r3
 8022318:	f7ff ffaa 	bl	8022270 <wc_SignatureGetSize>
 802231c:	4602      	mov	r2, r0
 802231e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022320:	429a      	cmp	r2, r3
 8022322:	da02      	bge.n	802232a <wc_SignatureVerifyHash+0x56>
        WOLFSSL_MSG("wc_SignatureVerify: Invalid sig type/len");
        return BAD_FUNC_ARG;
 8022324:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8022328:	e08b      	b.n	8022442 <wc_SignatureVerifyHash+0x16e>
    }

    /* Validate hash size */
    ret = wc_HashGetDigestSize(hash_type);
 802232a:	7bfb      	ldrb	r3, [r7, #15]
 802232c:	4618      	mov	r0, r3
 802232e:	f7fc f913 	bl	801e558 <wc_HashGetDigestSize>
 8022332:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret < 0) {
 8022334:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022336:	2b00      	cmp	r3, #0
 8022338:	da01      	bge.n	802233e <wc_SignatureVerifyHash+0x6a>
        WOLFSSL_MSG("wc_SignatureVerify: Invalid hash type/len");
        return ret;
 802233a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802233c:	e081      	b.n	8022442 <wc_SignatureVerifyHash+0x16e>
    }
    ret = 0;
 802233e:	2300      	movs	r3, #0
 8022340:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Verify signature using hash */
    switch (sig_type) {
 8022342:	7bbb      	ldrb	r3, [r7, #14]
 8022344:	2b01      	cmp	r3, #1
 8022346:	d005      	beq.n	8022354 <wc_SignatureVerifyHash+0x80>
 8022348:	2b00      	cmp	r3, #0
 802234a:	dd72      	ble.n	8022432 <wc_SignatureVerifyHash+0x15e>
 802234c:	3b02      	subs	r3, #2
 802234e:	2b01      	cmp	r3, #1
 8022350:	d86f      	bhi.n	8022432 <wc_SignatureVerifyHash+0x15e>
 8022352:	e01e      	b.n	8022392 <wc_SignatureVerifyHash+0xbe>
        case WC_SIGNATURE_TYPE_ECC:
        {
#if defined(HAVE_ECC) && defined(HAVE_ECC_VERIFY)
            int is_valid_sig = 0;
 8022354:	2300      	movs	r3, #0
 8022356:	617b      	str	r3, [r7, #20]
            do {
            #ifdef WOLFSSL_ASYNC_CRYPT
                ret = wc_AsyncWait(ret, &((ecc_key*)key)->asyncDev,
                    WC_ASYNC_FLAG_CALL_AGAIN);
            #endif
            if (ret >= 0)
 8022358:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802235a:	2b00      	cmp	r3, #0
 802235c:	db0b      	blt.n	8022376 <wc_SignatureVerifyHash+0xa2>
                ret = wc_ecc_verify_hash(sig, sig_len, hash_data, hash_len,
 802235e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022360:	9301      	str	r3, [sp, #4]
 8022362:	f107 0314 	add.w	r3, r7, #20
 8022366:	9300      	str	r3, [sp, #0]
 8022368:	687b      	ldr	r3, [r7, #4]
 802236a:	68ba      	ldr	r2, [r7, #8]
 802236c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 802236e:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8022370:	f7fb fb1c 	bl	801d9ac <wc_ecc_verify_hash>
 8022374:	6278      	str	r0, [r7, #36]	@ 0x24
                    &is_valid_sig, (ecc_key*)key);
            } while (ret == WC_NO_ERR_TRACE(WC_PENDING_E));
 8022376:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022378:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 802237c:	d0ec      	beq.n	8022358 <wc_SignatureVerifyHash+0x84>
            if (ret != 0 || is_valid_sig != 1) {
 802237e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022380:	2b00      	cmp	r3, #0
 8022382:	d102      	bne.n	802238a <wc_SignatureVerifyHash+0xb6>
 8022384:	697b      	ldr	r3, [r7, #20]
 8022386:	2b01      	cmp	r3, #1
 8022388:	d057      	beq.n	802243a <wc_SignatureVerifyHash+0x166>
                ret = SIG_VERIFY_E;
 802238a:	f06f 03e4 	mvn.w	r3, #228	@ 0xe4
 802238e:	627b      	str	r3, [r7, #36]	@ 0x24
            }
#else
            ret = SIG_TYPE_E;
#endif
            break;
 8022390:	e053      	b.n	802243a <wc_SignatureVerifyHash+0x166>
        if (ret != 0) {
            ret = SIG_VERIFY_E;
        }
    #else

            word32 plain_len = hash_len;
 8022392:	687b      	ldr	r3, [r7, #4]
 8022394:	623b      	str	r3, [r7, #32]
        #else
            ALIGN64 byte plain_data[MAX_ENCODED_SIG_SZ];
        #endif

            /* Make sure the plain text output is at least key size */
            if (plain_len < sig_len) {
 8022396:	6a3a      	ldr	r2, [r7, #32]
 8022398:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802239a:	429a      	cmp	r2, r3
 802239c:	d201      	bcs.n	80223a2 <wc_SignatureVerifyHash+0xce>
                plain_len = sig_len;
 802239e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80223a0:	623b      	str	r3, [r7, #32]
            }
        #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
            plain_data = (byte*)XMALLOC(plain_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80223a2:	6a38      	ldr	r0, [r7, #32]
 80223a4:	f7fc fc6a 	bl	801ec7c <wolfSSL_Malloc>
 80223a8:	61f8      	str	r0, [r7, #28]
            if (plain_data)
 80223aa:	69fb      	ldr	r3, [r7, #28]
 80223ac:	2b00      	cmp	r3, #0
 80223ae:	d03c      	beq.n	802242a <wc_SignatureVerifyHash+0x156>
        #else
            if (plain_len <= sizeof(plain_data))
        #endif
            {
                byte* plain_ptr = NULL;
 80223b0:	2300      	movs	r3, #0
 80223b2:	613b      	str	r3, [r7, #16]
                XMEMSET(plain_data, 0, plain_len);
 80223b4:	6a3a      	ldr	r2, [r7, #32]
 80223b6:	2100      	movs	r1, #0
 80223b8:	69f8      	ldr	r0, [r7, #28]
 80223ba:	f006 fc33 	bl	8028c24 <memset>
                XMEMCPY(plain_data, sig, sig_len);
 80223be:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80223c0:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80223c2:	69f8      	ldr	r0, [r7, #28]
 80223c4:	f006 fcdf 	bl	8028d86 <memcpy>
                do {
                #ifdef WOLFSSL_ASYNC_CRYPT
                    ret = wc_AsyncWait(ret, &((RsaKey*)key)->asyncDev,
                        WC_ASYNC_FLAG_CALL_AGAIN);
                #endif
                if (ret >= 0)
 80223c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80223ca:	2b00      	cmp	r3, #0
 80223cc:	db07      	blt.n	80223de <wc_SignatureVerifyHash+0x10a>
                        ret = wc_RsaSSL_VerifyInline(plain_data, sig_len,
 80223ce:	f107 0210 	add.w	r2, r7, #16
 80223d2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80223d4:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80223d6:	69f8      	ldr	r0, [r7, #28]
 80223d8:	f7ff f809 	bl	80213ee <wc_RsaSSL_VerifyInline>
 80223dc:	6278      	str	r0, [r7, #36]	@ 0x24
                            &plain_ptr, (RsaKey*)key);
                } while (ret == WC_NO_ERR_TRACE(WC_PENDING_E));
 80223de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80223e0:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 80223e4:	d0f0      	beq.n	80223c8 <wc_SignatureVerifyHash+0xf4>
                if (ret >= 0 && plain_ptr) {
 80223e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80223e8:	2b00      	cmp	r3, #0
 80223ea:	db15      	blt.n	8022418 <wc_SignatureVerifyHash+0x144>
 80223ec:	693b      	ldr	r3, [r7, #16]
 80223ee:	2b00      	cmp	r3, #0
 80223f0:	d012      	beq.n	8022418 <wc_SignatureVerifyHash+0x144>
                    if ((word32)ret == hash_len &&
 80223f2:	687b      	ldr	r3, [r7, #4]
 80223f4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80223f6:	429a      	cmp	r2, r3
 80223f8:	d10b      	bne.n	8022412 <wc_SignatureVerifyHash+0x13e>
                            XMEMCMP(plain_ptr, hash_data, hash_len) == 0) {
 80223fa:	693b      	ldr	r3, [r7, #16]
 80223fc:	687a      	ldr	r2, [r7, #4]
 80223fe:	68b9      	ldr	r1, [r7, #8]
 8022400:	4618      	mov	r0, r3
 8022402:	f006 fbe5 	bl	8028bd0 <memcmp>
 8022406:	4603      	mov	r3, r0
                    if ((word32)ret == hash_len &&
 8022408:	2b00      	cmp	r3, #0
 802240a:	d102      	bne.n	8022412 <wc_SignatureVerifyHash+0x13e>
                        ret = 0; /* Success */
 802240c:	2300      	movs	r3, #0
 802240e:	627b      	str	r3, [r7, #36]	@ 0x24
 8022410:	e002      	b.n	8022418 <wc_SignatureVerifyHash+0x144>
                    }
                    else {
                        ret = SIG_VERIFY_E;
 8022412:	f06f 03e4 	mvn.w	r3, #228	@ 0xe4
 8022416:	627b      	str	r3, [r7, #36]	@ 0x24
                    }
                }
            #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
                XFREE(plain_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8022418:	69fb      	ldr	r3, [r7, #28]
 802241a:	61bb      	str	r3, [r7, #24]
 802241c:	69bb      	ldr	r3, [r7, #24]
 802241e:	2b00      	cmp	r3, #0
 8022420:	d00d      	beq.n	802243e <wc_SignatureVerifyHash+0x16a>
 8022422:	69b8      	ldr	r0, [r7, #24]
 8022424:	f7fc fc46 	bl	801ecb4 <wolfSSL_Free>
                WOLFSSL_MSG("RSA Signature Verify failed!");
            }
#else
            ret = SIG_TYPE_E;
#endif
            break;
 8022428:	e009      	b.n	802243e <wc_SignatureVerifyHash+0x16a>
                ret = MEMORY_E;
 802242a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 802242e:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 8022430:	e005      	b.n	802243e <wc_SignatureVerifyHash+0x16a>
        }

        case WC_SIGNATURE_TYPE_NONE:
        default:
            ret = BAD_FUNC_ARG;
 8022432:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8022436:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 8022438:	e002      	b.n	8022440 <wc_SignatureVerifyHash+0x16c>
            break;
 802243a:	bf00      	nop
 802243c:	e000      	b.n	8022440 <wc_SignatureVerifyHash+0x16c>
            break;
 802243e:	bf00      	nop
    }

    return ret;
 8022440:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8022442:	4618      	mov	r0, r3
 8022444:	3728      	adds	r7, #40	@ 0x28
 8022446:	46bd      	mov	sp, r7
 8022448:	bd80      	pop	{r7, pc}

0802244a <wc_SignatureVerify>:
int wc_SignatureVerify(
    enum wc_HashType hash_type, enum wc_SignatureType sig_type,
    const byte* data, word32 data_len,
    const byte* sig, word32 sig_len,
    const void* key, word32 key_len)
{
 802244a:	b580      	push	{r7, lr}
 802244c:	b08e      	sub	sp, #56	@ 0x38
 802244e:	af04      	add	r7, sp, #16
 8022450:	60ba      	str	r2, [r7, #8]
 8022452:	607b      	str	r3, [r7, #4]
 8022454:	4603      	mov	r3, r0
 8022456:	73fb      	strb	r3, [r7, #15]
 8022458:	460b      	mov	r3, r1
 802245a:	73bb      	strb	r3, [r7, #14]
#else
    byte hash_data[MAX_DER_DIGEST_SZ];
#endif

    /* Check arguments */
    if (data == NULL || data_len == 0 ||
 802245c:	68bb      	ldr	r3, [r7, #8]
 802245e:	2b00      	cmp	r3, #0
 8022460:	d00e      	beq.n	8022480 <wc_SignatureVerify+0x36>
 8022462:	687b      	ldr	r3, [r7, #4]
 8022464:	2b00      	cmp	r3, #0
 8022466:	d00b      	beq.n	8022480 <wc_SignatureVerify+0x36>
 8022468:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802246a:	2b00      	cmp	r3, #0
 802246c:	d008      	beq.n	8022480 <wc_SignatureVerify+0x36>
        sig == NULL || sig_len == 0 ||
 802246e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022470:	2b00      	cmp	r3, #0
 8022472:	d005      	beq.n	8022480 <wc_SignatureVerify+0x36>
 8022474:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022476:	2b00      	cmp	r3, #0
 8022478:	d002      	beq.n	8022480 <wc_SignatureVerify+0x36>
        key == NULL || key_len == 0) {
 802247a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802247c:	2b00      	cmp	r3, #0
 802247e:	d102      	bne.n	8022486 <wc_SignatureVerify+0x3c>
        return BAD_FUNC_ARG;
 8022480:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8022484:	e05e      	b.n	8022544 <wc_SignatureVerify+0xfa>
    }

    /* Validate signature len (1 to max is okay) */
    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {
 8022486:	7bbb      	ldrb	r3, [r7, #14]
 8022488:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802248a:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 802248c:	4618      	mov	r0, r3
 802248e:	f7ff feef 	bl	8022270 <wc_SignatureGetSize>
 8022492:	4602      	mov	r2, r0
 8022494:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022496:	429a      	cmp	r2, r3
 8022498:	da02      	bge.n	80224a0 <wc_SignatureVerify+0x56>
        WOLFSSL_MSG("wc_SignatureVerify: Invalid sig type/len");
        return BAD_FUNC_ARG;
 802249a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802249e:	e051      	b.n	8022544 <wc_SignatureVerify+0xfa>
    }

    /* Validate hash size */
    ret = wc_HashGetDigestSize(hash_type);
 80224a0:	7bfb      	ldrb	r3, [r7, #15]
 80224a2:	4618      	mov	r0, r3
 80224a4:	f7fc f858 	bl	801e558 <wc_HashGetDigestSize>
 80224a8:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret < 0) {
 80224aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80224ac:	2b00      	cmp	r3, #0
 80224ae:	da01      	bge.n	80224b4 <wc_SignatureVerify+0x6a>
        WOLFSSL_MSG("wc_SignatureVerify: Invalid hash type/len");
        return ret;
 80224b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80224b2:	e047      	b.n	8022544 <wc_SignatureVerify+0xfa>
    }
    hash_enc_len = hash_len = (word32)ret;
 80224b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80224b6:	623b      	str	r3, [r7, #32]
 80224b8:	6a3b      	ldr	r3, [r7, #32]
 80224ba:	617b      	str	r3, [r7, #20]

#ifndef NO_RSA
    if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {
 80224bc:	7bbb      	ldrb	r3, [r7, #14]
 80224be:	2b03      	cmp	r3, #3
 80224c0:	d102      	bne.n	80224c8 <wc_SignatureVerify+0x7e>
        /* For RSA with ASN.1 encoding include room */
        hash_enc_len += MAX_DER_DIGEST_ASN_SZ;
 80224c2:	697b      	ldr	r3, [r7, #20]
 80224c4:	3324      	adds	r3, #36	@ 0x24
 80224c6:	617b      	str	r3, [r7, #20]
    }
#endif

#if defined(WOLFSSL_SMALL_STACK) || defined(NO_ASN)
    /* Allocate temporary buffer for hash data */
    hash_data = (byte*)XMALLOC(hash_enc_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80224c8:	697b      	ldr	r3, [r7, #20]
 80224ca:	4618      	mov	r0, r3
 80224cc:	f7fc fbd6 	bl	801ec7c <wolfSSL_Malloc>
 80224d0:	61f8      	str	r0, [r7, #28]
    if (hash_data == NULL) {
 80224d2:	69fb      	ldr	r3, [r7, #28]
 80224d4:	2b00      	cmp	r3, #0
 80224d6:	d102      	bne.n	80224de <wc_SignatureVerify+0x94>
        return MEMORY_E;
 80224d8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80224dc:	e032      	b.n	8022544 <wc_SignatureVerify+0xfa>
    }
#endif

    /* Perform hash of data */
    ret = wc_Hash(hash_type, data, data_len, hash_data, hash_len);
 80224de:	7bf8      	ldrb	r0, [r7, #15]
 80224e0:	6a3b      	ldr	r3, [r7, #32]
 80224e2:	9300      	str	r3, [sp, #0]
 80224e4:	69fb      	ldr	r3, [r7, #28]
 80224e6:	687a      	ldr	r2, [r7, #4]
 80224e8:	68b9      	ldr	r1, [r7, #8]
 80224ea:	f7fc f8cd 	bl	801e688 <wc_Hash>
 80224ee:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret == 0) {
 80224f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80224f2:	2b00      	cmp	r3, #0
 80224f4:	d11d      	bne.n	8022532 <wc_SignatureVerify+0xe8>
        /* Handle RSA with DER encoding */
        if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {
 80224f6:	7bbb      	ldrb	r3, [r7, #14]
 80224f8:	2b03      	cmp	r3, #3
 80224fa:	d107      	bne.n	802250c <wc_SignatureVerify+0xc2>
        #if defined(NO_RSA) || defined(NO_ASN)
            ret = SIG_TYPE_E;
        #else
            ret = wc_SignatureDerEncode(hash_type, hash_data, hash_len,
 80224fc:	f107 0314 	add.w	r3, r7, #20
 8022500:	7bf8      	ldrb	r0, [r7, #15]
 8022502:	6a3a      	ldr	r2, [r7, #32]
 8022504:	69f9      	ldr	r1, [r7, #28]
 8022506:	f7ff fe8a 	bl	802221e <wc_SignatureDerEncode>
 802250a:	6278      	str	r0, [r7, #36]	@ 0x24
                &hash_enc_len);
        #endif
        }

        if (ret == 0) {
 802250c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802250e:	2b00      	cmp	r3, #0
 8022510:	d10f      	bne.n	8022532 <wc_SignatureVerify+0xe8>
            /* Verify signature using hash */
            ret = wc_SignatureVerifyHash(hash_type, sig_type,
 8022512:	697a      	ldr	r2, [r7, #20]
 8022514:	7bb9      	ldrb	r1, [r7, #14]
 8022516:	7bf8      	ldrb	r0, [r7, #15]
 8022518:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802251a:	9303      	str	r3, [sp, #12]
 802251c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802251e:	9302      	str	r3, [sp, #8]
 8022520:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022522:	9301      	str	r3, [sp, #4]
 8022524:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022526:	9300      	str	r3, [sp, #0]
 8022528:	4613      	mov	r3, r2
 802252a:	69fa      	ldr	r2, [r7, #28]
 802252c:	f7ff fed2 	bl	80222d4 <wc_SignatureVerifyHash>
 8022530:	6278      	str	r0, [r7, #36]	@ 0x24
                hash_data, hash_enc_len, sig, sig_len, key, key_len);
        }
    }

#if defined(WOLFSSL_SMALL_STACK) || defined(NO_ASN)
    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8022532:	69fb      	ldr	r3, [r7, #28]
 8022534:	61bb      	str	r3, [r7, #24]
 8022536:	69bb      	ldr	r3, [r7, #24]
 8022538:	2b00      	cmp	r3, #0
 802253a:	d002      	beq.n	8022542 <wc_SignatureVerify+0xf8>
 802253c:	69b8      	ldr	r0, [r7, #24]
 802253e:	f7fc fbb9 	bl	801ecb4 <wolfSSL_Free>
#endif

    return ret;
 8022542:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8022544:	4618      	mov	r0, r3
 8022546:	3728      	adds	r7, #40	@ 0x28
 8022548:	46bd      	mov	sp, r7
 802254a:	bd80      	pop	{r7, pc}

0802254c <ForceZero>:
{
 802254c:	b480      	push	{r7}
 802254e:	b085      	sub	sp, #20
 8022550:	af00      	add	r7, sp, #0
 8022552:	6078      	str	r0, [r7, #4]
 8022554:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 8022556:	687b      	ldr	r3, [r7, #4]
 8022558:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 802255a:	e004      	b.n	8022566 <ForceZero+0x1a>
 802255c:	68fb      	ldr	r3, [r7, #12]
 802255e:	1c5a      	adds	r2, r3, #1
 8022560:	60fa      	str	r2, [r7, #12]
 8022562:	2200      	movs	r2, #0
 8022564:	701a      	strb	r2, [r3, #0]
 8022566:	683b      	ldr	r3, [r7, #0]
 8022568:	1e5a      	subs	r2, r3, #1
 802256a:	603a      	str	r2, [r7, #0]
 802256c:	2b00      	cmp	r3, #0
 802256e:	d1f5      	bne.n	802255c <ForceZero+0x10>
}
 8022570:	bf00      	nop
 8022572:	bf00      	nop
 8022574:	3714      	adds	r7, #20
 8022576:	46bd      	mov	sp, r7
 8022578:	f85d 7b04 	ldr.w	r7, [sp], #4
 802257c:	4770      	bx	lr

0802257e <HexCharToByte>:
{
 802257e:	b480      	push	{r7}
 8022580:	b085      	sub	sp, #20
 8022582:	af00      	add	r7, sp, #0
 8022584:	4603      	mov	r3, r0
 8022586:	71fb      	strb	r3, [r7, #7]
    signed char ret = (signed char)ch;
 8022588:	79fb      	ldrb	r3, [r7, #7]
 802258a:	73fb      	strb	r3, [r7, #15]
    if (ret >= '0' && ret <= '9')
 802258c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8022590:	2b2f      	cmp	r3, #47	@ 0x2f
 8022592:	dd08      	ble.n	80225a6 <HexCharToByte+0x28>
 8022594:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8022598:	2b39      	cmp	r3, #57	@ 0x39
 802259a:	dc04      	bgt.n	80225a6 <HexCharToByte+0x28>
        ret = (signed char)(ret - '0');
 802259c:	7bfb      	ldrb	r3, [r7, #15]
 802259e:	3b30      	subs	r3, #48	@ 0x30
 80225a0:	b2db      	uxtb	r3, r3
 80225a2:	73fb      	strb	r3, [r7, #15]
 80225a4:	e01b      	b.n	80225de <HexCharToByte+0x60>
    else if (ret >= 'A' && ret <= 'F')
 80225a6:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80225aa:	2b40      	cmp	r3, #64	@ 0x40
 80225ac:	dd08      	ble.n	80225c0 <HexCharToByte+0x42>
 80225ae:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80225b2:	2b46      	cmp	r3, #70	@ 0x46
 80225b4:	dc04      	bgt.n	80225c0 <HexCharToByte+0x42>
        ret = (signed char)(ret - ('A' - 10));
 80225b6:	7bfb      	ldrb	r3, [r7, #15]
 80225b8:	3b37      	subs	r3, #55	@ 0x37
 80225ba:	b2db      	uxtb	r3, r3
 80225bc:	73fb      	strb	r3, [r7, #15]
 80225be:	e00e      	b.n	80225de <HexCharToByte+0x60>
    else if (ret >= 'a' && ret <= 'f')
 80225c0:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80225c4:	2b60      	cmp	r3, #96	@ 0x60
 80225c6:	dd08      	ble.n	80225da <HexCharToByte+0x5c>
 80225c8:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80225cc:	2b66      	cmp	r3, #102	@ 0x66
 80225ce:	dc04      	bgt.n	80225da <HexCharToByte+0x5c>
        ret = (signed char)(ret - ('a' - 10));
 80225d0:	7bfb      	ldrb	r3, [r7, #15]
 80225d2:	3b57      	subs	r3, #87	@ 0x57
 80225d4:	b2db      	uxtb	r3, r3
 80225d6:	73fb      	strb	r3, [r7, #15]
 80225d8:	e001      	b.n	80225de <HexCharToByte+0x60>
        ret = -1; /* error case - return code must be signed */
 80225da:	23ff      	movs	r3, #255	@ 0xff
 80225dc:	73fb      	strb	r3, [r7, #15]
    return ret;
 80225de:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 80225e2:	4618      	mov	r0, r3
 80225e4:	3714      	adds	r7, #20
 80225e6:	46bd      	mov	sp, r7
 80225e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80225ec:	4770      	bx	lr

080225ee <CharIsWhiteSpace>:
{
 80225ee:	b480      	push	{r7}
 80225f0:	b083      	sub	sp, #12
 80225f2:	af00      	add	r7, sp, #0
 80225f4:	4603      	mov	r3, r0
 80225f6:	71fb      	strb	r3, [r7, #7]
    switch (ch) {
 80225f8:	79fb      	ldrb	r3, [r7, #7]
 80225fa:	2b0a      	cmp	r3, #10
 80225fc:	dc02      	bgt.n	8022604 <CharIsWhiteSpace+0x16>
 80225fe:	2b09      	cmp	r3, #9
 8022600:	da02      	bge.n	8022608 <CharIsWhiteSpace+0x1a>
 8022602:	e003      	b.n	802260c <CharIsWhiteSpace+0x1e>
 8022604:	2b20      	cmp	r3, #32
 8022606:	d101      	bne.n	802260c <CharIsWhiteSpace+0x1e>
            return 1;
 8022608:	2301      	movs	r3, #1
 802260a:	e000      	b.n	802260e <CharIsWhiteSpace+0x20>
            return 0;
 802260c:	2300      	movs	r3, #0
}
 802260e:	4618      	mov	r0, r3
 8022610:	370c      	adds	r7, #12
 8022612:	46bd      	mov	sp, r7
 8022614:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022618:	4770      	bx	lr

0802261a <fp_add>:


/* Functions */

int fp_add(fp_int *a, fp_int *b, fp_int *c)
{
 802261a:	b580      	push	{r7, lr}
 802261c:	b088      	sub	sp, #32
 802261e:	af00      	add	r7, sp, #0
 8022620:	60f8      	str	r0, [r7, #12]
 8022622:	60b9      	str	r1, [r7, #8]
 8022624:	607a      	str	r2, [r7, #4]
  int sa, sb;
  int ret = FP_OKAY;
 8022626:	2300      	movs	r3, #0
 8022628:	61fb      	str	r3, [r7, #28]

  /* get sign of both inputs */
  sa = a->sign;
 802262a:	68fb      	ldr	r3, [r7, #12]
 802262c:	685b      	ldr	r3, [r3, #4]
 802262e:	61bb      	str	r3, [r7, #24]
  sb = b->sign;
 8022630:	68bb      	ldr	r3, [r7, #8]
 8022632:	685b      	ldr	r3, [r3, #4]
 8022634:	617b      	str	r3, [r7, #20]

  /* handle two cases, not four */
  if (sa == sb) {
 8022636:	69ba      	ldr	r2, [r7, #24]
 8022638:	697b      	ldr	r3, [r7, #20]
 802263a:	429a      	cmp	r2, r3
 802263c:	d109      	bne.n	8022652 <fp_add+0x38>
    /* both positive or both negative */
    /* add their magnitudes, copy the sign */
    c->sign = sa;
 802263e:	687b      	ldr	r3, [r7, #4]
 8022640:	69ba      	ldr	r2, [r7, #24]
 8022642:	605a      	str	r2, [r3, #4]
    ret = s_fp_add (a, b, c);
 8022644:	687a      	ldr	r2, [r7, #4]
 8022646:	68b9      	ldr	r1, [r7, #8]
 8022648:	68f8      	ldr	r0, [r7, #12]
 802264a:	f000 f820 	bl	802268e <s_fp_add>
 802264e:	61f8      	str	r0, [r7, #28]
 8022650:	e018      	b.n	8022684 <fp_add+0x6a>
  } else {
    /* one positive, the other negative */
    /* subtract the one with the greater magnitude from */
    /* the one of the lesser magnitude.  The result gets */
    /* the sign of the one with the greater magnitude. */
    if (fp_cmp_mag (a, b) == FP_LT) {
 8022652:	68b9      	ldr	r1, [r7, #8]
 8022654:	68f8      	ldr	r0, [r7, #12]
 8022656:	f003 fc1a 	bl	8025e8e <fp_cmp_mag>
 802265a:	4603      	mov	r3, r0
 802265c:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8022660:	d108      	bne.n	8022674 <fp_add+0x5a>
      c->sign = sb;
 8022662:	687b      	ldr	r3, [r7, #4]
 8022664:	697a      	ldr	r2, [r7, #20]
 8022666:	605a      	str	r2, [r3, #4]
      s_fp_sub (b, a, c);
 8022668:	687a      	ldr	r2, [r7, #4]
 802266a:	68f9      	ldr	r1, [r7, #12]
 802266c:	68b8      	ldr	r0, [r7, #8]
 802266e:	f000 f8f6 	bl	802285e <s_fp_sub>
 8022672:	e007      	b.n	8022684 <fp_add+0x6a>
    } else {
      c->sign = sa;
 8022674:	687b      	ldr	r3, [r7, #4]
 8022676:	69ba      	ldr	r2, [r7, #24]
 8022678:	605a      	str	r2, [r3, #4]
      s_fp_sub (a, b, c);
 802267a:	687a      	ldr	r2, [r7, #4]
 802267c:	68b9      	ldr	r1, [r7, #8]
 802267e:	68f8      	ldr	r0, [r7, #12]
 8022680:	f000 f8ed 	bl	802285e <s_fp_sub>
    }
  }

  return ret;
 8022684:	69fb      	ldr	r3, [r7, #28]
}
 8022686:	4618      	mov	r0, r3
 8022688:	3720      	adds	r7, #32
 802268a:	46bd      	mov	sp, r7
 802268c:	bd80      	pop	{r7, pc}

0802268e <s_fp_add>:

/* unsigned addition */
int s_fp_add(fp_int *a, fp_int *b, fp_int *c)
{
 802268e:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022692:	b08d      	sub	sp, #52	@ 0x34
 8022694:	af00      	add	r7, sp, #0
 8022696:	6178      	str	r0, [r7, #20]
 8022698:	6139      	str	r1, [r7, #16]
 802269a:	60fa      	str	r2, [r7, #12]
  int      x, y, oldused;
  fp_word  t;

  y       = MAX(a->used, b->used);
 802269c:	693b      	ldr	r3, [r7, #16]
 802269e:	681a      	ldr	r2, [r3, #0]
 80226a0:	697b      	ldr	r3, [r7, #20]
 80226a2:	681b      	ldr	r3, [r3, #0]
 80226a4:	4293      	cmp	r3, r2
 80226a6:	bfb8      	it	lt
 80226a8:	4613      	movlt	r3, r2
 80226aa:	61fb      	str	r3, [r7, #28]
  oldused = MIN(c->used, FP_SIZE);   /* help static analysis w/ largest size */
 80226ac:	68fb      	ldr	r3, [r7, #12]
 80226ae:	681b      	ldr	r3, [r3, #0]
 80226b0:	2b88      	cmp	r3, #136	@ 0x88
 80226b2:	bfa8      	it	ge
 80226b4:	2388      	movge	r3, #136	@ 0x88
 80226b6:	61bb      	str	r3, [r7, #24]
  c->used = y;
 80226b8:	68fb      	ldr	r3, [r7, #12]
 80226ba:	69fa      	ldr	r2, [r7, #28]
 80226bc:	601a      	str	r2, [r3, #0]

  t = 0;
 80226be:	f04f 0200 	mov.w	r2, #0
 80226c2:	f04f 0300 	mov.w	r3, #0
 80226c6:	e9c7 2308 	strd	r2, r3, [r7, #32]
      t        >>= DIGIT_BIT;
  }

#else
  /* the original code */
  for (x = 0; x < y; x++) {
 80226ca:	2300      	movs	r3, #0
 80226cc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80226ce:	e033      	b.n	8022738 <s_fp_add+0xaa>
      t         += ((fp_word)a->dp[x]) + ((fp_word)b->dp[x]);
 80226d0:	697a      	ldr	r2, [r7, #20]
 80226d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80226d4:	3302      	adds	r3, #2
 80226d6:	009b      	lsls	r3, r3, #2
 80226d8:	4413      	add	r3, r2
 80226da:	685b      	ldr	r3, [r3, #4]
 80226dc:	2200      	movs	r2, #0
 80226de:	4698      	mov	r8, r3
 80226e0:	4691      	mov	r9, r2
 80226e2:	693a      	ldr	r2, [r7, #16]
 80226e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80226e6:	3302      	adds	r3, #2
 80226e8:	009b      	lsls	r3, r3, #2
 80226ea:	4413      	add	r3, r2
 80226ec:	685b      	ldr	r3, [r3, #4]
 80226ee:	2200      	movs	r2, #0
 80226f0:	469a      	mov	sl, r3
 80226f2:	4693      	mov	fp, r2
 80226f4:	eb18 040a 	adds.w	r4, r8, sl
 80226f8:	eb49 050b 	adc.w	r5, r9, fp
 80226fc:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8022700:	1911      	adds	r1, r2, r4
 8022702:	6039      	str	r1, [r7, #0]
 8022704:	416b      	adcs	r3, r5
 8022706:	607b      	str	r3, [r7, #4]
 8022708:	e9d7 2300 	ldrd	r2, r3, [r7]
 802270c:	e9c7 2308 	strd	r2, r3, [r7, #32]
      c->dp[x]   = (fp_digit)t;
 8022710:	6a3a      	ldr	r2, [r7, #32]
 8022712:	68f9      	ldr	r1, [r7, #12]
 8022714:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022716:	3302      	adds	r3, #2
 8022718:	009b      	lsls	r3, r3, #2
 802271a:	440b      	add	r3, r1
 802271c:	605a      	str	r2, [r3, #4]
      t        >>= DIGIT_BIT;
 802271e:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8022722:	f04f 0200 	mov.w	r2, #0
 8022726:	f04f 0300 	mov.w	r3, #0
 802272a:	000a      	movs	r2, r1
 802272c:	2300      	movs	r3, #0
 802272e:	e9c7 2308 	strd	r2, r3, [r7, #32]
  for (x = 0; x < y; x++) {
 8022732:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022734:	3301      	adds	r3, #1
 8022736:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8022738:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802273a:	69fb      	ldr	r3, [r7, #28]
 802273c:	429a      	cmp	r2, r3
 802273e:	dbc7      	blt.n	80226d0 <s_fp_add+0x42>
  }
#endif /* HONOR_MATH_USED_LENGTH */

  if (t != 0) {
 8022740:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8022744:	4313      	orrs	r3, r2
 8022746:	d013      	beq.n	8022770 <s_fp_add+0xe2>
     if (x == FP_SIZE)
 8022748:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802274a:	2b88      	cmp	r3, #136	@ 0x88
 802274c:	d102      	bne.n	8022754 <s_fp_add+0xc6>
         return FP_VAL;
 802274e:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022752:	e03e      	b.n	80227d2 <s_fp_add+0x144>
     c->dp[c->used++] = (fp_digit)t;
 8022754:	68fb      	ldr	r3, [r7, #12]
 8022756:	681b      	ldr	r3, [r3, #0]
 8022758:	1c59      	adds	r1, r3, #1
 802275a:	68fa      	ldr	r2, [r7, #12]
 802275c:	6011      	str	r1, [r2, #0]
 802275e:	6a3a      	ldr	r2, [r7, #32]
 8022760:	68f9      	ldr	r1, [r7, #12]
 8022762:	3302      	adds	r3, #2
 8022764:	009b      	lsls	r3, r3, #2
 8022766:	440b      	add	r3, r1
 8022768:	605a      	str	r2, [r3, #4]
     ++x;
 802276a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802276c:	3301      	adds	r3, #1
 802276e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  }

  c->used = x;
 8022770:	68fb      	ldr	r3, [r7, #12]
 8022772:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8022774:	601a      	str	r2, [r3, #0]

  /* zero any excess digits on the destination that we didn't write to */
  for (; x < oldused; x++) {
 8022776:	e009      	b.n	802278c <s_fp_add+0xfe>
     c->dp[x] = 0;
 8022778:	68fa      	ldr	r2, [r7, #12]
 802277a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802277c:	3302      	adds	r3, #2
 802277e:	009b      	lsls	r3, r3, #2
 8022780:	4413      	add	r3, r2
 8022782:	2200      	movs	r2, #0
 8022784:	605a      	str	r2, [r3, #4]
  for (; x < oldused; x++) {
 8022786:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022788:	3301      	adds	r3, #1
 802278a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802278c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802278e:	69bb      	ldr	r3, [r7, #24]
 8022790:	429a      	cmp	r2, r3
 8022792:	dbf1      	blt.n	8022778 <s_fp_add+0xea>
  }
  fp_clamp(c);
 8022794:	e004      	b.n	80227a0 <s_fp_add+0x112>
 8022796:	68fb      	ldr	r3, [r7, #12]
 8022798:	681b      	ldr	r3, [r3, #0]
 802279a:	1e5a      	subs	r2, r3, #1
 802279c:	68fb      	ldr	r3, [r7, #12]
 802279e:	601a      	str	r2, [r3, #0]
 80227a0:	68fb      	ldr	r3, [r7, #12]
 80227a2:	681b      	ldr	r3, [r3, #0]
 80227a4:	2b00      	cmp	r3, #0
 80227a6:	d009      	beq.n	80227bc <s_fp_add+0x12e>
 80227a8:	68fb      	ldr	r3, [r7, #12]
 80227aa:	681b      	ldr	r3, [r3, #0]
 80227ac:	3b01      	subs	r3, #1
 80227ae:	68fa      	ldr	r2, [r7, #12]
 80227b0:	3302      	adds	r3, #2
 80227b2:	009b      	lsls	r3, r3, #2
 80227b4:	4413      	add	r3, r2
 80227b6:	685b      	ldr	r3, [r3, #4]
 80227b8:	2b00      	cmp	r3, #0
 80227ba:	d0ec      	beq.n	8022796 <s_fp_add+0x108>
 80227bc:	68fb      	ldr	r3, [r7, #12]
 80227be:	681b      	ldr	r3, [r3, #0]
 80227c0:	2b00      	cmp	r3, #0
 80227c2:	d002      	beq.n	80227ca <s_fp_add+0x13c>
 80227c4:	68fb      	ldr	r3, [r7, #12]
 80227c6:	685b      	ldr	r3, [r3, #4]
 80227c8:	e000      	b.n	80227cc <s_fp_add+0x13e>
 80227ca:	2300      	movs	r3, #0
 80227cc:	68fa      	ldr	r2, [r7, #12]
 80227ce:	6053      	str	r3, [r2, #4]
  return FP_OKAY;
 80227d0:	2300      	movs	r3, #0
}
 80227d2:	4618      	mov	r0, r3
 80227d4:	3734      	adds	r7, #52	@ 0x34
 80227d6:	46bd      	mov	sp, r7
 80227d8:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80227dc:	4770      	bx	lr

080227de <fp_sub>:

/* c = a - b */
int fp_sub(fp_int *a, fp_int *b, fp_int *c)
{
 80227de:	b580      	push	{r7, lr}
 80227e0:	b088      	sub	sp, #32
 80227e2:	af00      	add	r7, sp, #0
 80227e4:	60f8      	str	r0, [r7, #12]
 80227e6:	60b9      	str	r1, [r7, #8]
 80227e8:	607a      	str	r2, [r7, #4]
  int sa, sb;
  int ret = FP_OKAY;
 80227ea:	2300      	movs	r3, #0
 80227ec:	61fb      	str	r3, [r7, #28]

  sa = a->sign;
 80227ee:	68fb      	ldr	r3, [r7, #12]
 80227f0:	685b      	ldr	r3, [r3, #4]
 80227f2:	61bb      	str	r3, [r7, #24]
  sb = b->sign;
 80227f4:	68bb      	ldr	r3, [r7, #8]
 80227f6:	685b      	ldr	r3, [r3, #4]
 80227f8:	617b      	str	r3, [r7, #20]

  if (sa != sb) {
 80227fa:	69ba      	ldr	r2, [r7, #24]
 80227fc:	697b      	ldr	r3, [r7, #20]
 80227fe:	429a      	cmp	r2, r3
 8022800:	d009      	beq.n	8022816 <fp_sub+0x38>
    /* subtract a negative from a positive, OR */
    /* subtract a positive from a negative. */
    /* In either case, ADD their magnitudes, */
    /* and use the sign of the first number. */
    c->sign = sa;
 8022802:	687b      	ldr	r3, [r7, #4]
 8022804:	69ba      	ldr	r2, [r7, #24]
 8022806:	605a      	str	r2, [r3, #4]
    ret = s_fp_add (a, b, c);
 8022808:	687a      	ldr	r2, [r7, #4]
 802280a:	68b9      	ldr	r1, [r7, #8]
 802280c:	68f8      	ldr	r0, [r7, #12]
 802280e:	f7ff ff3e 	bl	802268e <s_fp_add>
 8022812:	61f8      	str	r0, [r7, #28]
 8022814:	e01e      	b.n	8022854 <fp_sub+0x76>
  } else {
    /* subtract a positive from a positive, OR */
    /* subtract a negative from a negative. */
    /* First, take the difference between their */
    /* magnitudes, then... */
    if (fp_cmp_mag (a, b) != FP_LT) {
 8022816:	68b9      	ldr	r1, [r7, #8]
 8022818:	68f8      	ldr	r0, [r7, #12]
 802281a:	f003 fb38 	bl	8025e8e <fp_cmp_mag>
 802281e:	4603      	mov	r3, r0
 8022820:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8022824:	d008      	beq.n	8022838 <fp_sub+0x5a>
      /* Copy the sign from the first */
      c->sign = sa;
 8022826:	687b      	ldr	r3, [r7, #4]
 8022828:	69ba      	ldr	r2, [r7, #24]
 802282a:	605a      	str	r2, [r3, #4]
      /* The first has a larger or equal magnitude */
      s_fp_sub (a, b, c);
 802282c:	687a      	ldr	r2, [r7, #4]
 802282e:	68b9      	ldr	r1, [r7, #8]
 8022830:	68f8      	ldr	r0, [r7, #12]
 8022832:	f000 f814 	bl	802285e <s_fp_sub>
 8022836:	e00d      	b.n	8022854 <fp_sub+0x76>
    } else {
      /* The result has the *opposite* sign from */
      /* the first number. */
      c->sign = (sa == FP_ZPOS) ? FP_NEG : FP_ZPOS;
 8022838:	69bb      	ldr	r3, [r7, #24]
 802283a:	2b00      	cmp	r3, #0
 802283c:	bf0c      	ite	eq
 802283e:	2301      	moveq	r3, #1
 8022840:	2300      	movne	r3, #0
 8022842:	b2db      	uxtb	r3, r3
 8022844:	461a      	mov	r2, r3
 8022846:	687b      	ldr	r3, [r7, #4]
 8022848:	605a      	str	r2, [r3, #4]
      /* The second has a larger magnitude */
      s_fp_sub (b, a, c);
 802284a:	687a      	ldr	r2, [r7, #4]
 802284c:	68f9      	ldr	r1, [r7, #12]
 802284e:	68b8      	ldr	r0, [r7, #8]
 8022850:	f000 f805 	bl	802285e <s_fp_sub>
    }
  }
  return ret;
 8022854:	69fb      	ldr	r3, [r7, #28]
}
 8022856:	4618      	mov	r0, r3
 8022858:	3720      	adds	r7, #32
 802285a:	46bd      	mov	sp, r7
 802285c:	bd80      	pop	{r7, pc}

0802285e <s_fp_sub>:

/* unsigned subtraction ||a|| >= ||b|| ALWAYS! */
void s_fp_sub(fp_int *a, fp_int *b, fp_int *c)
{
 802285e:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022862:	b095      	sub	sp, #84	@ 0x54
 8022864:	af00      	add	r7, sp, #0
 8022866:	6378      	str	r0, [r7, #52]	@ 0x34
 8022868:	6339      	str	r1, [r7, #48]	@ 0x30
 802286a:	62fa      	str	r2, [r7, #44]	@ 0x2c
  int      x, oldbused, oldused;
  fp_word  t;

  oldused  = c->used;
 802286c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802286e:	681b      	ldr	r3, [r3, #0]
 8022870:	63fb      	str	r3, [r7, #60]	@ 0x3c
  oldbused = b->used;
 8022872:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022874:	681b      	ldr	r3, [r3, #0]
 8022876:	63bb      	str	r3, [r7, #56]	@ 0x38
  c->used  = a->used;
 8022878:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802287a:	681a      	ldr	r2, [r3, #0]
 802287c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802287e:	601a      	str	r2, [r3, #0]
  t       = 0;
 8022880:	f04f 0200 	mov.w	r2, #0
 8022884:	f04f 0300 	mov.w	r3, #0
 8022888:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
  for (x = 0; x < oldbused; x++) {
 802288c:	2300      	movs	r3, #0
 802288e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8022890:	e040      	b.n	8022914 <s_fp_sub+0xb6>
     t         = ((fp_word)a->dp[x]) - (((fp_word)b->dp[x]) + t);
 8022892:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8022894:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022896:	3302      	adds	r3, #2
 8022898:	009b      	lsls	r3, r3, #2
 802289a:	4413      	add	r3, r2
 802289c:	685b      	ldr	r3, [r3, #4]
 802289e:	2200      	movs	r2, #0
 80228a0:	61bb      	str	r3, [r7, #24]
 80228a2:	61fa      	str	r2, [r7, #28]
 80228a4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80228a6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80228a8:	3302      	adds	r3, #2
 80228aa:	009b      	lsls	r3, r3, #2
 80228ac:	4413      	add	r3, r2
 80228ae:	685b      	ldr	r3, [r3, #4]
 80228b0:	2200      	movs	r2, #0
 80228b2:	623b      	str	r3, [r7, #32]
 80228b4:	627a      	str	r2, [r7, #36]	@ 0x24
 80228b6:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80228ba:	6a39      	ldr	r1, [r7, #32]
 80228bc:	188c      	adds	r4, r1, r2
 80228be:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80228c0:	eb41 0503 	adc.w	r5, r1, r3
 80228c4:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 80228c8:	460b      	mov	r3, r1
 80228ca:	1b1b      	subs	r3, r3, r4
 80228cc:	613b      	str	r3, [r7, #16]
 80228ce:	4613      	mov	r3, r2
 80228d0:	eb63 0305 	sbc.w	r3, r3, r5
 80228d4:	617b      	str	r3, [r7, #20]
 80228d6:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80228da:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
     c->dp[x]  = (fp_digit)t;
 80228de:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 80228e0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80228e2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80228e4:	3302      	adds	r3, #2
 80228e6:	009b      	lsls	r3, r3, #2
 80228e8:	4413      	add	r3, r2
 80228ea:	6059      	str	r1, [r3, #4]
     t         = (t >> DIGIT_BIT)&1;
 80228ec:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80228f0:	f04f 0000 	mov.w	r0, #0
 80228f4:	f04f 0100 	mov.w	r1, #0
 80228f8:	0018      	movs	r0, r3
 80228fa:	2100      	movs	r1, #0
 80228fc:	f000 0301 	and.w	r3, r0, #1
 8022900:	60bb      	str	r3, [r7, #8]
 8022902:	2300      	movs	r3, #0
 8022904:	60fb      	str	r3, [r7, #12]
 8022906:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 802290a:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
  for (x = 0; x < oldbused; x++) {
 802290e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022910:	3301      	adds	r3, #1
 8022912:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8022914:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8022916:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022918:	429a      	cmp	r2, r3
 802291a:	dbba      	blt.n	8022892 <s_fp_sub+0x34>
  }
  for (; x < a->used; x++) {
 802291c:	e02b      	b.n	8022976 <s_fp_sub+0x118>
     t         = ((fp_word)a->dp[x]) - t;
 802291e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8022920:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022922:	3302      	adds	r3, #2
 8022924:	009b      	lsls	r3, r3, #2
 8022926:	4413      	add	r3, r2
 8022928:	685b      	ldr	r3, [r3, #4]
 802292a:	2200      	movs	r2, #0
 802292c:	4698      	mov	r8, r3
 802292e:	4691      	mov	r9, r2
 8022930:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 8022934:	ebb8 0a02 	subs.w	sl, r8, r2
 8022938:	eb69 0b03 	sbc.w	fp, r9, r3
 802293c:	e9c7 ab10 	strd	sl, fp, [r7, #64]	@ 0x40
     c->dp[x]  = (fp_digit)t;
 8022940:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8022942:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8022944:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022946:	3302      	adds	r3, #2
 8022948:	009b      	lsls	r3, r3, #2
 802294a:	440b      	add	r3, r1
 802294c:	605a      	str	r2, [r3, #4]
     t         = (t >> DIGIT_BIT)&1;
 802294e:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 8022952:	f04f 0200 	mov.w	r2, #0
 8022956:	f04f 0300 	mov.w	r3, #0
 802295a:	000a      	movs	r2, r1
 802295c:	2300      	movs	r3, #0
 802295e:	f002 0301 	and.w	r3, r2, #1
 8022962:	603b      	str	r3, [r7, #0]
 8022964:	2300      	movs	r3, #0
 8022966:	607b      	str	r3, [r7, #4]
 8022968:	e9d7 3400 	ldrd	r3, r4, [r7]
 802296c:	e9c7 3410 	strd	r3, r4, [r7, #64]	@ 0x40
  for (; x < a->used; x++) {
 8022970:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022972:	3301      	adds	r3, #1
 8022974:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8022976:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022978:	681b      	ldr	r3, [r3, #0]
 802297a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802297c:	429a      	cmp	r2, r3
 802297e:	dbce      	blt.n	802291e <s_fp_sub+0xc0>
   }

  /* zero any excess digits on the destination that we didn't write to */
  for (; x < oldused; x++) {
 8022980:	e009      	b.n	8022996 <s_fp_sub+0x138>
     c->dp[x] = 0;
 8022982:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8022984:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022986:	3302      	adds	r3, #2
 8022988:	009b      	lsls	r3, r3, #2
 802298a:	4413      	add	r3, r2
 802298c:	2200      	movs	r2, #0
 802298e:	605a      	str	r2, [r3, #4]
  for (; x < oldused; x++) {
 8022990:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022992:	3301      	adds	r3, #1
 8022994:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8022996:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8022998:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802299a:	429a      	cmp	r2, r3
 802299c:	dbf1      	blt.n	8022982 <s_fp_sub+0x124>
  }
  fp_clamp(c);
 802299e:	e004      	b.n	80229aa <s_fp_sub+0x14c>
 80229a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80229a2:	681b      	ldr	r3, [r3, #0]
 80229a4:	1e5a      	subs	r2, r3, #1
 80229a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80229a8:	601a      	str	r2, [r3, #0]
 80229aa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80229ac:	681b      	ldr	r3, [r3, #0]
 80229ae:	2b00      	cmp	r3, #0
 80229b0:	d009      	beq.n	80229c6 <s_fp_sub+0x168>
 80229b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80229b4:	681b      	ldr	r3, [r3, #0]
 80229b6:	3b01      	subs	r3, #1
 80229b8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80229ba:	3302      	adds	r3, #2
 80229bc:	009b      	lsls	r3, r3, #2
 80229be:	4413      	add	r3, r2
 80229c0:	685b      	ldr	r3, [r3, #4]
 80229c2:	2b00      	cmp	r3, #0
 80229c4:	d0ec      	beq.n	80229a0 <s_fp_sub+0x142>
 80229c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80229c8:	681b      	ldr	r3, [r3, #0]
 80229ca:	2b00      	cmp	r3, #0
 80229cc:	d002      	beq.n	80229d4 <s_fp_sub+0x176>
 80229ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80229d0:	685b      	ldr	r3, [r3, #4]
 80229d2:	e000      	b.n	80229d6 <s_fp_sub+0x178>
 80229d4:	2300      	movs	r3, #0
 80229d6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80229d8:	6053      	str	r3, [r2, #4]
}
 80229da:	bf00      	nop
 80229dc:	3754      	adds	r7, #84	@ 0x54
 80229de:	46bd      	mov	sp, r7
 80229e0:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80229e4:	4770      	bx	lr

080229e6 <fp_mul>:

/* c = a * b */
int fp_mul(fp_int *A, fp_int *B, fp_int *C)
{
 80229e6:	b580      	push	{r7, lr}
 80229e8:	b088      	sub	sp, #32
 80229ea:	af00      	add	r7, sp, #0
 80229ec:	60f8      	str	r0, [r7, #12]
 80229ee:	60b9      	str	r1, [r7, #8]
 80229f0:	607a      	str	r2, [r7, #4]
    int   ret = FP_OKAY;
 80229f2:	2300      	movs	r3, #0
 80229f4:	61fb      	str	r3, [r7, #28]
    int   y, yy, oldused;

    oldused = C->used;
 80229f6:	687b      	ldr	r3, [r7, #4]
 80229f8:	681b      	ldr	r3, [r3, #0]
 80229fa:	617b      	str	r3, [r7, #20]

    y  = MAX(A->used, B->used);
 80229fc:	68bb      	ldr	r3, [r7, #8]
 80229fe:	681a      	ldr	r2, [r3, #0]
 8022a00:	68fb      	ldr	r3, [r7, #12]
 8022a02:	681b      	ldr	r3, [r3, #0]
 8022a04:	4293      	cmp	r3, r2
 8022a06:	bfb8      	it	lt
 8022a08:	4613      	movlt	r3, r2
 8022a0a:	61bb      	str	r3, [r7, #24]
    yy = MIN(A->used, B->used);
 8022a0c:	68bb      	ldr	r3, [r7, #8]
 8022a0e:	681a      	ldr	r2, [r3, #0]
 8022a10:	68fb      	ldr	r3, [r7, #12]
 8022a12:	681b      	ldr	r3, [r3, #0]
 8022a14:	4293      	cmp	r3, r2
 8022a16:	bfa8      	it	ge
 8022a18:	4613      	movge	r3, r2
 8022a1a:	613b      	str	r3, [r7, #16]

    /* fail if we are out of range */
    if (y + yy >= FP_SIZE) {
 8022a1c:	69ba      	ldr	r2, [r7, #24]
 8022a1e:	693b      	ldr	r3, [r7, #16]
 8022a20:	4413      	add	r3, r2
 8022a22:	2b87      	cmp	r3, #135	@ 0x87
 8022a24:	dd03      	ble.n	8022a2e <fp_mul+0x48>
       ret = FP_VAL;
 8022a26:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022a2a:	61fb      	str	r3, [r7, #28]
       goto clean;
 8022a2c:	e005      	b.n	8022a3a <fp_mul+0x54>
        if (yy >= 56 && y <= 64) {
           ret = fp_mul_comba64(A,B,C);
           goto clean;
        }
#endif
        ret = fp_mul_comba(A,B,C);
 8022a2e:	687a      	ldr	r2, [r7, #4]
 8022a30:	68b9      	ldr	r1, [r7, #8]
 8022a32:	68f8      	ldr	r0, [r7, #12]
 8022a34:	f000 f9bb 	bl	8022dae <fp_mul_comba>
 8022a38:	61f8      	str	r0, [r7, #28]

clean:
    /* zero any excess digits on the destination that we didn't write to */
    for (y = C->used; y >= 0 && y < oldused; y++) {
 8022a3a:	687b      	ldr	r3, [r7, #4]
 8022a3c:	681b      	ldr	r3, [r3, #0]
 8022a3e:	61bb      	str	r3, [r7, #24]
 8022a40:	e009      	b.n	8022a56 <fp_mul+0x70>
        C->dp[y] = 0;
 8022a42:	687a      	ldr	r2, [r7, #4]
 8022a44:	69bb      	ldr	r3, [r7, #24]
 8022a46:	3302      	adds	r3, #2
 8022a48:	009b      	lsls	r3, r3, #2
 8022a4a:	4413      	add	r3, r2
 8022a4c:	2200      	movs	r2, #0
 8022a4e:	605a      	str	r2, [r3, #4]
    for (y = C->used; y >= 0 && y < oldused; y++) {
 8022a50:	69bb      	ldr	r3, [r7, #24]
 8022a52:	3301      	adds	r3, #1
 8022a54:	61bb      	str	r3, [r7, #24]
 8022a56:	69bb      	ldr	r3, [r7, #24]
 8022a58:	2b00      	cmp	r3, #0
 8022a5a:	db03      	blt.n	8022a64 <fp_mul+0x7e>
 8022a5c:	69ba      	ldr	r2, [r7, #24]
 8022a5e:	697b      	ldr	r3, [r7, #20]
 8022a60:	429a      	cmp	r2, r3
 8022a62:	dbee      	blt.n	8022a42 <fp_mul+0x5c>
    }

    return ret;
 8022a64:	69fb      	ldr	r3, [r7, #28]
}
 8022a66:	4618      	mov	r0, r3
 8022a68:	3720      	adds	r7, #32
 8022a6a:	46bd      	mov	sp, r7
 8022a6c:	bd80      	pop	{r7, pc}

08022a6e <fp_mul_2>:

int fp_mul_2(fp_int * a, fp_int * b)
{
 8022a6e:	b480      	push	{r7}
 8022a70:	b089      	sub	sp, #36	@ 0x24
 8022a72:	af00      	add	r7, sp, #0
 8022a74:	6078      	str	r0, [r7, #4]
 8022a76:	6039      	str	r1, [r7, #0]
  int     x, oldused;

  /* Make sure value to double and result are in range. */
  if ((a->used > (FP_SIZE-1)) || ((a->used == (FP_SIZE - 1)) &&
 8022a78:	687b      	ldr	r3, [r7, #4]
 8022a7a:	681b      	ldr	r3, [r3, #0]
 8022a7c:	2b87      	cmp	r3, #135	@ 0x87
 8022a7e:	dc08      	bgt.n	8022a92 <fp_mul_2+0x24>
 8022a80:	687b      	ldr	r3, [r7, #4]
 8022a82:	681b      	ldr	r3, [r3, #0]
 8022a84:	2b87      	cmp	r3, #135	@ 0x87
 8022a86:	d107      	bne.n	8022a98 <fp_mul_2+0x2a>
              ((a->dp[FP_SIZE - 1] & ((fp_digit)1 << (DIGIT_BIT - 1))) != 0))) {
 8022a88:	687b      	ldr	r3, [r7, #4]
 8022a8a:	f8d3 3228 	ldr.w	r3, [r3, #552]	@ 0x228
  if ((a->used > (FP_SIZE-1)) || ((a->used == (FP_SIZE - 1)) &&
 8022a8e:	2b00      	cmp	r3, #0
 8022a90:	da02      	bge.n	8022a98 <fp_mul_2+0x2a>
    return FP_VAL;
 8022a92:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022a96:	e052      	b.n	8022b3e <fp_mul_2+0xd0>
  }

  oldused = b->used;
 8022a98:	683b      	ldr	r3, [r7, #0]
 8022a9a:	681b      	ldr	r3, [r3, #0]
 8022a9c:	60fb      	str	r3, [r7, #12]
  b->used = a->used;
 8022a9e:	687b      	ldr	r3, [r7, #4]
 8022aa0:	681a      	ldr	r2, [r3, #0]
 8022aa2:	683b      	ldr	r3, [r7, #0]
 8022aa4:	601a      	str	r2, [r3, #0]

  {
    fp_digit r, rr, *tmpa, *tmpb;

    /* alias for source */
    tmpa = a->dp;
 8022aa6:	687b      	ldr	r3, [r7, #4]
 8022aa8:	330c      	adds	r3, #12
 8022aaa:	617b      	str	r3, [r7, #20]

    /* alias for dest */
    tmpb = b->dp;
 8022aac:	683b      	ldr	r3, [r7, #0]
 8022aae:	330c      	adds	r3, #12
 8022ab0:	613b      	str	r3, [r7, #16]

    /* carry */
    r = 0;
 8022ab2:	2300      	movs	r3, #0
 8022ab4:	61bb      	str	r3, [r7, #24]
    for (x = 0; x < a->used; x++) {
 8022ab6:	2300      	movs	r3, #0
 8022ab8:	61fb      	str	r3, [r7, #28]
 8022aba:	e013      	b.n	8022ae4 <fp_mul_2+0x76>

      /* get what will be the *next* carry bit from the
       * MSB of the current digit
       */
      rr = *tmpa >> ((fp_digit)(DIGIT_BIT - 1));
 8022abc:	697b      	ldr	r3, [r7, #20]
 8022abe:	681b      	ldr	r3, [r3, #0]
 8022ac0:	0fdb      	lsrs	r3, r3, #31
 8022ac2:	60bb      	str	r3, [r7, #8]

      /* now shift up this digit, add in the carry [from the previous] */
      *tmpb++ = ((*tmpa++ << ((fp_digit)1)) | r);
 8022ac4:	697b      	ldr	r3, [r7, #20]
 8022ac6:	1d1a      	adds	r2, r3, #4
 8022ac8:	617a      	str	r2, [r7, #20]
 8022aca:	681b      	ldr	r3, [r3, #0]
 8022acc:	0059      	lsls	r1, r3, #1
 8022ace:	693b      	ldr	r3, [r7, #16]
 8022ad0:	1d1a      	adds	r2, r3, #4
 8022ad2:	613a      	str	r2, [r7, #16]
 8022ad4:	69ba      	ldr	r2, [r7, #24]
 8022ad6:	430a      	orrs	r2, r1
 8022ad8:	601a      	str	r2, [r3, #0]

      /* copy the carry that would be from the source
       * digit into the next iteration
       */
      r = rr;
 8022ada:	68bb      	ldr	r3, [r7, #8]
 8022adc:	61bb      	str	r3, [r7, #24]
    for (x = 0; x < a->used; x++) {
 8022ade:	69fb      	ldr	r3, [r7, #28]
 8022ae0:	3301      	adds	r3, #1
 8022ae2:	61fb      	str	r3, [r7, #28]
 8022ae4:	687b      	ldr	r3, [r7, #4]
 8022ae6:	681b      	ldr	r3, [r3, #0]
 8022ae8:	69fa      	ldr	r2, [r7, #28]
 8022aea:	429a      	cmp	r2, r3
 8022aec:	dbe6      	blt.n	8022abc <fp_mul_2+0x4e>
    }

    /* new leading digit? */
    if (r != 0) {
 8022aee:	69bb      	ldr	r3, [r7, #24]
 8022af0:	2b00      	cmp	r3, #0
 8022af2:	d007      	beq.n	8022b04 <fp_mul_2+0x96>
      /* add a MSB which is always 1 at this point */
      *tmpb = 1;
 8022af4:	693b      	ldr	r3, [r7, #16]
 8022af6:	2201      	movs	r2, #1
 8022af8:	601a      	str	r2, [r3, #0]
      ++(b->used);
 8022afa:	683b      	ldr	r3, [r7, #0]
 8022afc:	681b      	ldr	r3, [r3, #0]
 8022afe:	1c5a      	adds	r2, r3, #1
 8022b00:	683b      	ldr	r3, [r7, #0]
 8022b02:	601a      	str	r2, [r3, #0]
    }

    /* zero any excess digits on the destination that we didn't write to */
    tmpb = b->dp + b->used;
 8022b04:	683b      	ldr	r3, [r7, #0]
 8022b06:	f103 020c 	add.w	r2, r3, #12
 8022b0a:	683b      	ldr	r3, [r7, #0]
 8022b0c:	681b      	ldr	r3, [r3, #0]
 8022b0e:	009b      	lsls	r3, r3, #2
 8022b10:	4413      	add	r3, r2
 8022b12:	613b      	str	r3, [r7, #16]
    for (x = b->used; x < oldused; x++) {
 8022b14:	683b      	ldr	r3, [r7, #0]
 8022b16:	681b      	ldr	r3, [r3, #0]
 8022b18:	61fb      	str	r3, [r7, #28]
 8022b1a:	e007      	b.n	8022b2c <fp_mul_2+0xbe>
      *tmpb++ = 0;
 8022b1c:	693b      	ldr	r3, [r7, #16]
 8022b1e:	1d1a      	adds	r2, r3, #4
 8022b20:	613a      	str	r2, [r7, #16]
 8022b22:	2200      	movs	r2, #0
 8022b24:	601a      	str	r2, [r3, #0]
    for (x = b->used; x < oldused; x++) {
 8022b26:	69fb      	ldr	r3, [r7, #28]
 8022b28:	3301      	adds	r3, #1
 8022b2a:	61fb      	str	r3, [r7, #28]
 8022b2c:	69fa      	ldr	r2, [r7, #28]
 8022b2e:	68fb      	ldr	r3, [r7, #12]
 8022b30:	429a      	cmp	r2, r3
 8022b32:	dbf3      	blt.n	8022b1c <fp_mul_2+0xae>
    }
  }
  b->sign = a->sign;
 8022b34:	687b      	ldr	r3, [r7, #4]
 8022b36:	685a      	ldr	r2, [r3, #4]
 8022b38:	683b      	ldr	r3, [r7, #0]
 8022b3a:	605a      	str	r2, [r3, #4]

  return FP_OKAY;
 8022b3c:	2300      	movs	r3, #0
}
 8022b3e:	4618      	mov	r0, r3
 8022b40:	3724      	adds	r7, #36	@ 0x24
 8022b42:	46bd      	mov	sp, r7
 8022b44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022b48:	4770      	bx	lr

08022b4a <fp_mul_d>:

/* c = a * b */
int fp_mul_d(fp_int *a, fp_digit b, fp_int *c)
{
 8022b4a:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022b4e:	b08b      	sub	sp, #44	@ 0x2c
 8022b50:	af00      	add	r7, sp, #0
 8022b52:	6178      	str	r0, [r7, #20]
 8022b54:	6139      	str	r1, [r7, #16]
 8022b56:	60fa      	str	r2, [r7, #12]
   fp_word  w;
   int      x, oldused;

   oldused = c->used;
 8022b58:	68fb      	ldr	r3, [r7, #12]
 8022b5a:	681b      	ldr	r3, [r3, #0]
 8022b5c:	61bb      	str	r3, [r7, #24]
   c->used = a->used;
 8022b5e:	697b      	ldr	r3, [r7, #20]
 8022b60:	681a      	ldr	r2, [r3, #0]
 8022b62:	68fb      	ldr	r3, [r7, #12]
 8022b64:	601a      	str	r2, [r3, #0]
   c->sign = a->sign;
 8022b66:	697b      	ldr	r3, [r7, #20]
 8022b68:	685a      	ldr	r2, [r3, #4]
 8022b6a:	68fb      	ldr	r3, [r7, #12]
 8022b6c:	605a      	str	r2, [r3, #4]
   w       = 0;
 8022b6e:	f04f 0200 	mov.w	r2, #0
 8022b72:	f04f 0300 	mov.w	r3, #0
 8022b76:	e9c7 2308 	strd	r2, r3, [r7, #32]
   for (x = 0; x < a->used; x++) {
 8022b7a:	2300      	movs	r3, #0
 8022b7c:	61fb      	str	r3, [r7, #28]
 8022b7e:	e033      	b.n	8022be8 <fp_mul_d+0x9e>
       w         = ((fp_word)a->dp[x]) * ((fp_word)b) + w;
 8022b80:	697a      	ldr	r2, [r7, #20]
 8022b82:	69fb      	ldr	r3, [r7, #28]
 8022b84:	3302      	adds	r3, #2
 8022b86:	009b      	lsls	r3, r3, #2
 8022b88:	4413      	add	r3, r2
 8022b8a:	685b      	ldr	r3, [r3, #4]
 8022b8c:	2200      	movs	r2, #0
 8022b8e:	4698      	mov	r8, r3
 8022b90:	4691      	mov	r9, r2
 8022b92:	693b      	ldr	r3, [r7, #16]
 8022b94:	2200      	movs	r2, #0
 8022b96:	469a      	mov	sl, r3
 8022b98:	4693      	mov	fp, r2
 8022b9a:	fb0a f209 	mul.w	r2, sl, r9
 8022b9e:	fb08 f30b 	mul.w	r3, r8, fp
 8022ba2:	4413      	add	r3, r2
 8022ba4:	fba8 450a 	umull	r4, r5, r8, sl
 8022ba8:	442b      	add	r3, r5
 8022baa:	461d      	mov	r5, r3
 8022bac:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8022bb0:	1911      	adds	r1, r2, r4
 8022bb2:	6039      	str	r1, [r7, #0]
 8022bb4:	416b      	adcs	r3, r5
 8022bb6:	607b      	str	r3, [r7, #4]
 8022bb8:	e9d7 2300 	ldrd	r2, r3, [r7]
 8022bbc:	e9c7 2308 	strd	r2, r3, [r7, #32]
       c->dp[x]  = (fp_digit)w;
 8022bc0:	6a3a      	ldr	r2, [r7, #32]
 8022bc2:	68f9      	ldr	r1, [r7, #12]
 8022bc4:	69fb      	ldr	r3, [r7, #28]
 8022bc6:	3302      	adds	r3, #2
 8022bc8:	009b      	lsls	r3, r3, #2
 8022bca:	440b      	add	r3, r1
 8022bcc:	605a      	str	r2, [r3, #4]
       w         = w >> DIGIT_BIT;
 8022bce:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8022bd2:	f04f 0200 	mov.w	r2, #0
 8022bd6:	f04f 0300 	mov.w	r3, #0
 8022bda:	000a      	movs	r2, r1
 8022bdc:	2300      	movs	r3, #0
 8022bde:	e9c7 2308 	strd	r2, r3, [r7, #32]
   for (x = 0; x < a->used; x++) {
 8022be2:	69fb      	ldr	r3, [r7, #28]
 8022be4:	3301      	adds	r3, #1
 8022be6:	61fb      	str	r3, [r7, #28]
 8022be8:	697b      	ldr	r3, [r7, #20]
 8022bea:	681b      	ldr	r3, [r3, #0]
 8022bec:	69fa      	ldr	r2, [r7, #28]
 8022bee:	429a      	cmp	r2, r3
 8022bf0:	dbc6      	blt.n	8022b80 <fp_mul_d+0x36>
   }
   if (w != 0) {
 8022bf2:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8022bf6:	4313      	orrs	r3, r2
 8022bf8:	d01f      	beq.n	8022c3a <fp_mul_d+0xf0>
      if (a->used == FP_SIZE)
 8022bfa:	697b      	ldr	r3, [r7, #20]
 8022bfc:	681b      	ldr	r3, [r3, #0]
 8022bfe:	2b88      	cmp	r3, #136	@ 0x88
 8022c00:	d102      	bne.n	8022c08 <fp_mul_d+0xbe>
          return FP_VAL;
 8022c02:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022c06:	e03e      	b.n	8022c86 <fp_mul_d+0x13c>
      c->dp[c->used++] = (fp_digit) w;
 8022c08:	68fb      	ldr	r3, [r7, #12]
 8022c0a:	681b      	ldr	r3, [r3, #0]
 8022c0c:	1c59      	adds	r1, r3, #1
 8022c0e:	68fa      	ldr	r2, [r7, #12]
 8022c10:	6011      	str	r1, [r2, #0]
 8022c12:	6a3a      	ldr	r2, [r7, #32]
 8022c14:	68f9      	ldr	r1, [r7, #12]
 8022c16:	3302      	adds	r3, #2
 8022c18:	009b      	lsls	r3, r3, #2
 8022c1a:	440b      	add	r3, r1
 8022c1c:	605a      	str	r2, [r3, #4]
      ++x;
 8022c1e:	69fb      	ldr	r3, [r7, #28]
 8022c20:	3301      	adds	r3, #1
 8022c22:	61fb      	str	r3, [r7, #28]
   }

   /* zero any excess digits on the destination that we didn't write to */
   /* also checking FP_SIZE here for static analysis */
   for (; x < oldused && x < FP_SIZE; x++) {
 8022c24:	e009      	b.n	8022c3a <fp_mul_d+0xf0>
      c->dp[x] = 0;
 8022c26:	68fa      	ldr	r2, [r7, #12]
 8022c28:	69fb      	ldr	r3, [r7, #28]
 8022c2a:	3302      	adds	r3, #2
 8022c2c:	009b      	lsls	r3, r3, #2
 8022c2e:	4413      	add	r3, r2
 8022c30:	2200      	movs	r2, #0
 8022c32:	605a      	str	r2, [r3, #4]
   for (; x < oldused && x < FP_SIZE; x++) {
 8022c34:	69fb      	ldr	r3, [r7, #28]
 8022c36:	3301      	adds	r3, #1
 8022c38:	61fb      	str	r3, [r7, #28]
 8022c3a:	69fa      	ldr	r2, [r7, #28]
 8022c3c:	69bb      	ldr	r3, [r7, #24]
 8022c3e:	429a      	cmp	r2, r3
 8022c40:	da08      	bge.n	8022c54 <fp_mul_d+0x10a>
 8022c42:	69fb      	ldr	r3, [r7, #28]
 8022c44:	2b87      	cmp	r3, #135	@ 0x87
 8022c46:	ddee      	ble.n	8022c26 <fp_mul_d+0xdc>
   }

   fp_clamp(c);
 8022c48:	e004      	b.n	8022c54 <fp_mul_d+0x10a>
 8022c4a:	68fb      	ldr	r3, [r7, #12]
 8022c4c:	681b      	ldr	r3, [r3, #0]
 8022c4e:	1e5a      	subs	r2, r3, #1
 8022c50:	68fb      	ldr	r3, [r7, #12]
 8022c52:	601a      	str	r2, [r3, #0]
 8022c54:	68fb      	ldr	r3, [r7, #12]
 8022c56:	681b      	ldr	r3, [r3, #0]
 8022c58:	2b00      	cmp	r3, #0
 8022c5a:	d009      	beq.n	8022c70 <fp_mul_d+0x126>
 8022c5c:	68fb      	ldr	r3, [r7, #12]
 8022c5e:	681b      	ldr	r3, [r3, #0]
 8022c60:	3b01      	subs	r3, #1
 8022c62:	68fa      	ldr	r2, [r7, #12]
 8022c64:	3302      	adds	r3, #2
 8022c66:	009b      	lsls	r3, r3, #2
 8022c68:	4413      	add	r3, r2
 8022c6a:	685b      	ldr	r3, [r3, #4]
 8022c6c:	2b00      	cmp	r3, #0
 8022c6e:	d0ec      	beq.n	8022c4a <fp_mul_d+0x100>
 8022c70:	68fb      	ldr	r3, [r7, #12]
 8022c72:	681b      	ldr	r3, [r3, #0]
 8022c74:	2b00      	cmp	r3, #0
 8022c76:	d002      	beq.n	8022c7e <fp_mul_d+0x134>
 8022c78:	68fb      	ldr	r3, [r7, #12]
 8022c7a:	685b      	ldr	r3, [r3, #4]
 8022c7c:	e000      	b.n	8022c80 <fp_mul_d+0x136>
 8022c7e:	2300      	movs	r3, #0
 8022c80:	68fa      	ldr	r2, [r7, #12]
 8022c82:	6053      	str	r3, [r2, #4]
   return FP_OKAY;
 8022c84:	2300      	movs	r3, #0
}
 8022c86:	4618      	mov	r0, r3
 8022c88:	372c      	adds	r7, #44	@ 0x2c
 8022c8a:	46bd      	mov	sp, r7
 8022c8c:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022c90:	4770      	bx	lr

08022c92 <fp_mul_2d>:

/* c = a * 2**d */
int fp_mul_2d(fp_int *a, int b, fp_int *c)
{
 8022c92:	b580      	push	{r7, lr}
 8022c94:	b08a      	sub	sp, #40	@ 0x28
 8022c96:	af00      	add	r7, sp, #0
 8022c98:	60f8      	str	r0, [r7, #12]
 8022c9a:	60b9      	str	r1, [r7, #8]
 8022c9c:	607a      	str	r2, [r7, #4]
   fp_digit carry, carrytmp, shift;
   int x;

   /* copy it */
   fp_copy(a, c);
 8022c9e:	6879      	ldr	r1, [r7, #4]
 8022ca0:	68f8      	ldr	r0, [r7, #12]
 8022ca2:	f004 f893 	bl	8026dcc <fp_copy>

   /* handle whole digits */
   if (b >= DIGIT_BIT) {
 8022ca6:	68bb      	ldr	r3, [r7, #8]
 8022ca8:	2b1f      	cmp	r3, #31
 8022caa:	dd0e      	ble.n	8022cca <fp_mul_2d+0x38>
      int ret = fp_lshd(c, b/DIGIT_BIT);
 8022cac:	68bb      	ldr	r3, [r7, #8]
 8022cae:	2b00      	cmp	r3, #0
 8022cb0:	da00      	bge.n	8022cb4 <fp_mul_2d+0x22>
 8022cb2:	331f      	adds	r3, #31
 8022cb4:	115b      	asrs	r3, r3, #5
 8022cb6:	4619      	mov	r1, r3
 8022cb8:	6878      	ldr	r0, [r7, #4]
 8022cba:	f003 fd0d 	bl	80266d8 <fp_lshd>
 8022cbe:	61f8      	str	r0, [r7, #28]
      if (ret != FP_OKAY)
 8022cc0:	69fb      	ldr	r3, [r7, #28]
 8022cc2:	2b00      	cmp	r3, #0
 8022cc4:	d001      	beq.n	8022cca <fp_mul_2d+0x38>
         return ret;
 8022cc6:	69fb      	ldr	r3, [r7, #28]
 8022cc8:	e06d      	b.n	8022da6 <fp_mul_2d+0x114>
   }
   b %= DIGIT_BIT;
 8022cca:	68bb      	ldr	r3, [r7, #8]
 8022ccc:	425a      	negs	r2, r3
 8022cce:	f003 031f 	and.w	r3, r3, #31
 8022cd2:	f002 021f 	and.w	r2, r2, #31
 8022cd6:	bf58      	it	pl
 8022cd8:	4253      	negpl	r3, r2
 8022cda:	60bb      	str	r3, [r7, #8]

   /* shift the digits */
   if (b != 0) {
 8022cdc:	68bb      	ldr	r3, [r7, #8]
 8022cde:	2b00      	cmp	r3, #0
 8022ce0:	d048      	beq.n	8022d74 <fp_mul_2d+0xe2>
      carry = 0;
 8022ce2:	2300      	movs	r3, #0
 8022ce4:	627b      	str	r3, [r7, #36]	@ 0x24
      shift = DIGIT_BIT - b;
 8022ce6:	68bb      	ldr	r3, [r7, #8]
 8022ce8:	f1c3 0320 	rsb	r3, r3, #32
 8022cec:	61bb      	str	r3, [r7, #24]
      for (x = 0; x < c->used; x++) {
 8022cee:	2300      	movs	r3, #0
 8022cf0:	623b      	str	r3, [r7, #32]
 8022cf2:	e01e      	b.n	8022d32 <fp_mul_2d+0xa0>
          carrytmp = c->dp[x] >> shift;
 8022cf4:	687a      	ldr	r2, [r7, #4]
 8022cf6:	6a3b      	ldr	r3, [r7, #32]
 8022cf8:	3302      	adds	r3, #2
 8022cfa:	009b      	lsls	r3, r3, #2
 8022cfc:	4413      	add	r3, r2
 8022cfe:	685a      	ldr	r2, [r3, #4]
 8022d00:	69bb      	ldr	r3, [r7, #24]
 8022d02:	fa22 f303 	lsr.w	r3, r2, r3
 8022d06:	617b      	str	r3, [r7, #20]
          c->dp[x] = (c->dp[x] << b) + carry;
 8022d08:	687a      	ldr	r2, [r7, #4]
 8022d0a:	6a3b      	ldr	r3, [r7, #32]
 8022d0c:	3302      	adds	r3, #2
 8022d0e:	009b      	lsls	r3, r3, #2
 8022d10:	4413      	add	r3, r2
 8022d12:	685a      	ldr	r2, [r3, #4]
 8022d14:	68bb      	ldr	r3, [r7, #8]
 8022d16:	409a      	lsls	r2, r3
 8022d18:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022d1a:	441a      	add	r2, r3
 8022d1c:	6879      	ldr	r1, [r7, #4]
 8022d1e:	6a3b      	ldr	r3, [r7, #32]
 8022d20:	3302      	adds	r3, #2
 8022d22:	009b      	lsls	r3, r3, #2
 8022d24:	440b      	add	r3, r1
 8022d26:	605a      	str	r2, [r3, #4]
          carry = carrytmp;
 8022d28:	697b      	ldr	r3, [r7, #20]
 8022d2a:	627b      	str	r3, [r7, #36]	@ 0x24
      for (x = 0; x < c->used; x++) {
 8022d2c:	6a3b      	ldr	r3, [r7, #32]
 8022d2e:	3301      	adds	r3, #1
 8022d30:	623b      	str	r3, [r7, #32]
 8022d32:	687b      	ldr	r3, [r7, #4]
 8022d34:	681b      	ldr	r3, [r3, #0]
 8022d36:	6a3a      	ldr	r2, [r7, #32]
 8022d38:	429a      	cmp	r2, r3
 8022d3a:	dbdb      	blt.n	8022cf4 <fp_mul_2d+0x62>
      }
      /* store last carry if room */
      if (carry && x < FP_SIZE) {
 8022d3c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022d3e:	2b00      	cmp	r3, #0
 8022d40:	d00d      	beq.n	8022d5e <fp_mul_2d+0xcc>
 8022d42:	6a3b      	ldr	r3, [r7, #32]
 8022d44:	2b87      	cmp	r3, #135	@ 0x87
 8022d46:	dc0a      	bgt.n	8022d5e <fp_mul_2d+0xcc>
         c->dp[c->used++] = carry;
 8022d48:	687b      	ldr	r3, [r7, #4]
 8022d4a:	681b      	ldr	r3, [r3, #0]
 8022d4c:	1c59      	adds	r1, r3, #1
 8022d4e:	687a      	ldr	r2, [r7, #4]
 8022d50:	6011      	str	r1, [r2, #0]
 8022d52:	687a      	ldr	r2, [r7, #4]
 8022d54:	3302      	adds	r3, #2
 8022d56:	009b      	lsls	r3, r3, #2
 8022d58:	4413      	add	r3, r2
 8022d5a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8022d5c:	605a      	str	r2, [r3, #4]
      }
      if (x == FP_SIZE)
 8022d5e:	6a3b      	ldr	r3, [r7, #32]
 8022d60:	2b88      	cmp	r3, #136	@ 0x88
 8022d62:	d107      	bne.n	8022d74 <fp_mul_2d+0xe2>
         return FP_VAL;
 8022d64:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022d68:	e01d      	b.n	8022da6 <fp_mul_2d+0x114>
   }
   fp_clamp(c);
 8022d6a:	687b      	ldr	r3, [r7, #4]
 8022d6c:	681b      	ldr	r3, [r3, #0]
 8022d6e:	1e5a      	subs	r2, r3, #1
 8022d70:	687b      	ldr	r3, [r7, #4]
 8022d72:	601a      	str	r2, [r3, #0]
 8022d74:	687b      	ldr	r3, [r7, #4]
 8022d76:	681b      	ldr	r3, [r3, #0]
 8022d78:	2b00      	cmp	r3, #0
 8022d7a:	d009      	beq.n	8022d90 <fp_mul_2d+0xfe>
 8022d7c:	687b      	ldr	r3, [r7, #4]
 8022d7e:	681b      	ldr	r3, [r3, #0]
 8022d80:	3b01      	subs	r3, #1
 8022d82:	687a      	ldr	r2, [r7, #4]
 8022d84:	3302      	adds	r3, #2
 8022d86:	009b      	lsls	r3, r3, #2
 8022d88:	4413      	add	r3, r2
 8022d8a:	685b      	ldr	r3, [r3, #4]
 8022d8c:	2b00      	cmp	r3, #0
 8022d8e:	d0ec      	beq.n	8022d6a <fp_mul_2d+0xd8>
 8022d90:	687b      	ldr	r3, [r7, #4]
 8022d92:	681b      	ldr	r3, [r3, #0]
 8022d94:	2b00      	cmp	r3, #0
 8022d96:	d002      	beq.n	8022d9e <fp_mul_2d+0x10c>
 8022d98:	687b      	ldr	r3, [r7, #4]
 8022d9a:	685b      	ldr	r3, [r3, #4]
 8022d9c:	e000      	b.n	8022da0 <fp_mul_2d+0x10e>
 8022d9e:	2300      	movs	r3, #0
 8022da0:	687a      	ldr	r2, [r7, #4]
 8022da2:	6053      	str	r3, [r2, #4]
   return FP_OKAY;
 8022da4:	2300      	movs	r3, #0
}
 8022da6:	4618      	mov	r0, r3
 8022da8:	3728      	adds	r7, #40	@ 0x28
 8022daa:	46bd      	mov	sp, r7
 8022dac:	bd80      	pop	{r7, pc}

08022dae <fp_mul_comba>:
}
#endif

/*  C = (A * B)   */
int fp_mul_comba(fp_int *A, fp_int *B, fp_int *C)
{
 8022dae:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8022db2:	b0a0      	sub	sp, #128	@ 0x80
 8022db4:	af00      	add	r7, sp, #0
 8022db6:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8022db8:	62b9      	str	r1, [r7, #40]	@ 0x28
 8022dba:	627a      	str	r2, [r7, #36]	@ 0x24
   int       ret = 0;
 8022dbc:	2300      	movs	r3, #0
 8022dbe:	65fb      	str	r3, [r7, #92]	@ 0x5c
   fp_int    tmp[1];
#else
   fp_int    *tmp;
#endif

   if (A->used + B->used >= FP_SIZE) return FP_VAL;
 8022dc0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022dc2:	681a      	ldr	r2, [r3, #0]
 8022dc4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022dc6:	681b      	ldr	r3, [r3, #0]
 8022dc8:	4413      	add	r3, r2
 8022dca:	2b87      	cmp	r3, #135	@ 0x87
 8022dcc:	dd02      	ble.n	8022dd4 <fp_mul_comba+0x26>
 8022dce:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022dd2:	e0f4      	b.n	8022fbe <fp_mul_comba+0x210>

   IF_HAVE_INTEL_MULX(ret = fp_mul_comba_mulx(A, B, C), return ret) ;

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8022dd4:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8022dd8:	f7fb ff50 	bl	801ec7c <wolfSSL_Malloc>
 8022ddc:	65b8      	str	r0, [r7, #88]	@ 0x58
   if (tmp == NULL)
 8022dde:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8022de0:	2b00      	cmp	r3, #0
 8022de2:	d102      	bne.n	8022dea <fp_mul_comba+0x3c>
       return FP_MEM;
 8022de4:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8022de8:	e0e9      	b.n	8022fbe <fp_mul_comba+0x210>
#endif

   COMBA_START;
   COMBA_CLEAR;
 8022dea:	2300      	movs	r3, #0
 8022dec:	66bb      	str	r3, [r7, #104]	@ 0x68
 8022dee:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022df0:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8022df2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022df4:	673b      	str	r3, [r7, #112]	@ 0x70

   /* get size of output and trim */
   pa = A->used + B->used;
 8022df6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022df8:	681a      	ldr	r2, [r3, #0]
 8022dfa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022dfc:	681b      	ldr	r3, [r3, #0]
 8022dfe:	4413      	add	r3, r2
 8022e00:	677b      	str	r3, [r7, #116]	@ 0x74
   if (pa >= FP_SIZE) {
 8022e02:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022e04:	2b87      	cmp	r3, #135	@ 0x87
 8022e06:	dd01      	ble.n	8022e0c <fp_mul_comba+0x5e>
      pa = FP_SIZE-1;
 8022e08:	2387      	movs	r3, #135	@ 0x87
 8022e0a:	677b      	str	r3, [r7, #116]	@ 0x74
   }

   /* Always take branch to use tmp variable. This avoids a cache attack for
    * determining if C equals A */
   if (1) {
      fp_init(tmp);
 8022e0c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8022e0e:	f003 fdf3 	bl	80269f8 <fp_init>
      dst = tmp;
 8022e12:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8022e14:	657b      	str	r3, [r7, #84]	@ 0x54
   }

   for (ix = 0; ix < pa; ix++) {
 8022e16:	2300      	movs	r3, #0
 8022e18:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8022e1a:	e096      	b.n	8022f4a <fp_mul_comba+0x19c>
      /* get offsets into the two bignums */
      ty = MIN(ix, (B->used > 0 ? B->used - 1 : 0));
 8022e1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022e1e:	681b      	ldr	r3, [r3, #0]
 8022e20:	2b01      	cmp	r3, #1
 8022e22:	bfb8      	it	lt
 8022e24:	2301      	movlt	r3, #1
 8022e26:	1e5a      	subs	r2, r3, #1
 8022e28:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8022e2a:	4293      	cmp	r3, r2
 8022e2c:	bfa8      	it	ge
 8022e2e:	4613      	movge	r3, r2
 8022e30:	64fb      	str	r3, [r7, #76]	@ 0x4c
      tx = ix - ty;
 8022e32:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8022e34:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022e36:	1ad3      	subs	r3, r2, r3
 8022e38:	64bb      	str	r3, [r7, #72]	@ 0x48

      /* setup temp aliases */
      tmpx = A->dp + tx;
 8022e3a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022e3c:	f103 020c 	add.w	r2, r3, #12
 8022e40:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022e42:	009b      	lsls	r3, r3, #2
 8022e44:	4413      	add	r3, r2
 8022e46:	667b      	str	r3, [r7, #100]	@ 0x64
      tmpy = B->dp + ty;
 8022e48:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022e4a:	f103 020c 	add.w	r2, r3, #12
 8022e4e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022e50:	009b      	lsls	r3, r3, #2
 8022e52:	4413      	add	r3, r2
 8022e54:	663b      	str	r3, [r7, #96]	@ 0x60

      /* this is the number of times the loop will iterate, essentially its
         while (tx++ < a->used && ty-- >= 0) { ... }
       */
      iy = MIN(A->used-tx, ty+1);
 8022e56:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022e58:	681a      	ldr	r2, [r3, #0]
 8022e5a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022e5c:	1ad2      	subs	r2, r2, r3
 8022e5e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022e60:	4293      	cmp	r3, r2
 8022e62:	db04      	blt.n	8022e6e <fp_mul_comba+0xc0>
 8022e64:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022e66:	681a      	ldr	r2, [r3, #0]
 8022e68:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022e6a:	1ad3      	subs	r3, r2, r3
 8022e6c:	e001      	b.n	8022e72 <fp_mul_comba+0xc4>
 8022e6e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022e70:	3301      	adds	r3, #1
 8022e72:	647b      	str	r3, [r7, #68]	@ 0x44

      /* execute loop */
      COMBA_FORWARD;
 8022e74:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022e76:	673b      	str	r3, [r7, #112]	@ 0x70
 8022e78:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022e7a:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8022e7c:	2300      	movs	r3, #0
 8022e7e:	66bb      	str	r3, [r7, #104]	@ 0x68
      for (iz = 0; iz < iy; ++iz) {
 8022e80:	2300      	movs	r3, #0
 8022e82:	67bb      	str	r3, [r7, #120]	@ 0x78
 8022e84:	e053      	b.n	8022f2e <fp_mul_comba+0x180>
          fp_digit _tmpx = *tmpx++;
 8022e86:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022e88:	1d13      	adds	r3, r2, #4
 8022e8a:	667b      	str	r3, [r7, #100]	@ 0x64
 8022e8c:	6813      	ldr	r3, [r2, #0]
 8022e8e:	643b      	str	r3, [r7, #64]	@ 0x40
          fp_digit _tmpy = *tmpy--;
 8022e90:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8022e92:	1f13      	subs	r3, r2, #4
 8022e94:	663b      	str	r3, [r7, #96]	@ 0x60
 8022e96:	6813      	ldr	r3, [r2, #0]
 8022e98:	63fb      	str	r3, [r7, #60]	@ 0x3c
          MULADD(_tmpx, _tmpy);
 8022e9a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8022e9c:	2200      	movs	r2, #0
 8022e9e:	613b      	str	r3, [r7, #16]
 8022ea0:	617a      	str	r2, [r7, #20]
 8022ea2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8022ea4:	2200      	movs	r2, #0
 8022ea6:	4698      	mov	r8, r3
 8022ea8:	4691      	mov	r9, r2
 8022eaa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8022eac:	2200      	movs	r2, #0
 8022eae:	469a      	mov	sl, r3
 8022eb0:	4693      	mov	fp, r2
 8022eb2:	fb0a f209 	mul.w	r2, sl, r9
 8022eb6:	fb08 f30b 	mul.w	r3, r8, fp
 8022eba:	4413      	add	r3, r2
 8022ebc:	fba8 450a 	umull	r4, r5, r8, sl
 8022ec0:	442b      	add	r3, r5
 8022ec2:	461d      	mov	r5, r3
 8022ec4:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8022ec8:	460b      	mov	r3, r1
 8022eca:	191b      	adds	r3, r3, r4
 8022ecc:	60bb      	str	r3, [r7, #8]
 8022ece:	4613      	mov	r3, r2
 8022ed0:	416b      	adcs	r3, r5
 8022ed2:	60fb      	str	r3, [r7, #12]
 8022ed4:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8022ed8:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
 8022edc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022ede:	673b      	str	r3, [r7, #112]	@ 0x70
 8022ee0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022ee2:	2200      	movs	r2, #0
 8022ee4:	61bb      	str	r3, [r7, #24]
 8022ee6:	61fa      	str	r2, [r7, #28]
 8022ee8:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8022eec:	f04f 0000 	mov.w	r0, #0
 8022ef0:	f04f 0100 	mov.w	r1, #0
 8022ef4:	0018      	movs	r0, r3
 8022ef6:	2100      	movs	r1, #0
 8022ef8:	69bb      	ldr	r3, [r7, #24]
 8022efa:	181b      	adds	r3, r3, r0
 8022efc:	603b      	str	r3, [r7, #0]
 8022efe:	69fb      	ldr	r3, [r7, #28]
 8022f00:	414b      	adcs	r3, r1
 8022f02:	607b      	str	r3, [r7, #4]
 8022f04:	e9d7 2300 	ldrd	r2, r3, [r7]
 8022f08:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
 8022f0c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022f0e:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8022f10:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8022f14:	f04f 0000 	mov.w	r0, #0
 8022f18:	f04f 0100 	mov.w	r1, #0
 8022f1c:	0018      	movs	r0, r3
 8022f1e:	2100      	movs	r1, #0
 8022f20:	4602      	mov	r2, r0
 8022f22:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022f24:	4413      	add	r3, r2
 8022f26:	66bb      	str	r3, [r7, #104]	@ 0x68
      for (iz = 0; iz < iy; ++iz) {
 8022f28:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8022f2a:	3301      	adds	r3, #1
 8022f2c:	67bb      	str	r3, [r7, #120]	@ 0x78
 8022f2e:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8022f30:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f32:	429a      	cmp	r2, r3
 8022f34:	dba7      	blt.n	8022e86 <fp_mul_comba+0xd8>
      }

      /* store term */
      COMBA_STORE(dst->dp[ix]);
 8022f36:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8022f38:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8022f3a:	3302      	adds	r3, #2
 8022f3c:	009a      	lsls	r2, r3, #2
 8022f3e:	440a      	add	r2, r1
 8022f40:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8022f42:	6053      	str	r3, [r2, #4]
   for (ix = 0; ix < pa; ix++) {
 8022f44:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8022f46:	3301      	adds	r3, #1
 8022f48:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8022f4a:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8022f4c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022f4e:	429a      	cmp	r2, r3
 8022f50:	f6ff af64 	blt.w	8022e1c <fp_mul_comba+0x6e>
  }
  COMBA_FINI;

  dst->used = pa;
 8022f54:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022f56:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022f58:	601a      	str	r2, [r3, #0]

  /* warning: WOLFSSL_SP_INT_NEGATIVE may disable negative numbers */
  dst->sign = A->sign ^ B->sign;
 8022f5a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022f5c:	685a      	ldr	r2, [r3, #4]
 8022f5e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022f60:	685b      	ldr	r3, [r3, #4]
 8022f62:	405a      	eors	r2, r3
 8022f64:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022f66:	605a      	str	r2, [r3, #4]
  fp_clamp(dst);
 8022f68:	e004      	b.n	8022f74 <fp_mul_comba+0x1c6>
 8022f6a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022f6c:	681b      	ldr	r3, [r3, #0]
 8022f6e:	1e5a      	subs	r2, r3, #1
 8022f70:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022f72:	601a      	str	r2, [r3, #0]
 8022f74:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022f76:	681b      	ldr	r3, [r3, #0]
 8022f78:	2b00      	cmp	r3, #0
 8022f7a:	d009      	beq.n	8022f90 <fp_mul_comba+0x1e2>
 8022f7c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022f7e:	681b      	ldr	r3, [r3, #0]
 8022f80:	3b01      	subs	r3, #1
 8022f82:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8022f84:	3302      	adds	r3, #2
 8022f86:	009b      	lsls	r3, r3, #2
 8022f88:	4413      	add	r3, r2
 8022f8a:	685b      	ldr	r3, [r3, #4]
 8022f8c:	2b00      	cmp	r3, #0
 8022f8e:	d0ec      	beq.n	8022f6a <fp_mul_comba+0x1bc>
 8022f90:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022f92:	681b      	ldr	r3, [r3, #0]
 8022f94:	2b00      	cmp	r3, #0
 8022f96:	d002      	beq.n	8022f9e <fp_mul_comba+0x1f0>
 8022f98:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022f9a:	685b      	ldr	r3, [r3, #4]
 8022f9c:	e000      	b.n	8022fa0 <fp_mul_comba+0x1f2>
 8022f9e:	2300      	movs	r3, #0
 8022fa0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8022fa2:	6053      	str	r3, [r2, #4]
  fp_copy(dst, C);
 8022fa4:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8022fa6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8022fa8:	f003 ff10 	bl	8026dcc <fp_copy>

  /* Variables used but not seen by cppcheck. */
  (void)c0; (void)c1; (void)c2;

#ifdef WOLFSSL_SMALL_STACK
  XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8022fac:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8022fae:	653b      	str	r3, [r7, #80]	@ 0x50
 8022fb0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8022fb2:	2b00      	cmp	r3, #0
 8022fb4:	d002      	beq.n	8022fbc <fp_mul_comba+0x20e>
 8022fb6:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8022fb8:	f7fb fe7c 	bl	801ecb4 <wolfSSL_Free>
#endif
  return ret;
 8022fbc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
}
 8022fbe:	4618      	mov	r0, r3
 8022fc0:	3780      	adds	r7, #128	@ 0x80
 8022fc2:	46bd      	mov	sp, r7
 8022fc4:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08022fc8 <fp_div>:

/* a/b => cb + d == a */
int fp_div(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 8022fc8:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8022fcc:	b09e      	sub	sp, #120	@ 0x78
 8022fce:	af00      	add	r7, sp, #0
 8022fd0:	6178      	str	r0, [r7, #20]
 8022fd2:	6139      	str	r1, [r7, #16]
 8022fd4:	60fa      	str	r2, [r7, #12]
 8022fd6:	60bb      	str	r3, [r7, #8]
#else
  fp_int  *q, *x, *y, *t1, *t2;
#endif

  /* is divisor zero ? */
  if (fp_iszero (b) == FP_YES) {
 8022fd8:	693b      	ldr	r3, [r7, #16]
 8022fda:	681b      	ldr	r3, [r3, #0]
 8022fdc:	2b00      	cmp	r3, #0
 8022fde:	d102      	bne.n	8022fe6 <fp_div+0x1e>
    return FP_VAL;
 8022fe0:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022fe4:	e2e0      	b.n	80235a8 <fp_div+0x5e0>
  }

  /* if a < b then q=0, r = a */
  if (fp_cmp_mag (a, b) == FP_LT)
 8022fe6:	6939      	ldr	r1, [r7, #16]
 8022fe8:	6978      	ldr	r0, [r7, #20]
 8022fea:	f002 ff50 	bl	8025e8e <fp_cmp_mag>
 8022fee:	4603      	mov	r3, r0
 8022ff0:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8022ff4:	d10e      	bne.n	8023014 <fp_div+0x4c>
  {
    if (d != NULL) {
 8022ff6:	68bb      	ldr	r3, [r7, #8]
 8022ff8:	2b00      	cmp	r3, #0
 8022ffa:	d003      	beq.n	8023004 <fp_div+0x3c>
      fp_copy (a, d);
 8022ffc:	68b9      	ldr	r1, [r7, #8]
 8022ffe:	6978      	ldr	r0, [r7, #20]
 8023000:	f003 fee4 	bl	8026dcc <fp_copy>
    }
    if (c != NULL) {
 8023004:	68fb      	ldr	r3, [r7, #12]
 8023006:	2b00      	cmp	r3, #0
 8023008:	d002      	beq.n	8023010 <fp_div+0x48>
      fp_zero (c);
 802300a:	68f8      	ldr	r0, [r7, #12]
 802300c:	f003 fd02 	bl	8026a14 <fp_zero>
    }
    return FP_OKAY;
 8023010:	2300      	movs	r3, #0
 8023012:	e2c9      	b.n	80235a8 <fp_div+0x5e0>
  }

#ifdef WOLFSSL_SMALL_STACK          /* 0  1  2  3   4  */
  /* allocate 5 elements of fp_int for q, x, y, t1, t2 */
  q = (fp_int*)XMALLOC(sizeof(fp_int) * 5, NULL, DYNAMIC_TYPE_BIGINT);
 8023014:	f640 20dc 	movw	r0, #2780	@ 0xadc
 8023018:	f7fb fe30 	bl	801ec7c <wolfSSL_Malloc>
 802301c:	66f8      	str	r0, [r7, #108]	@ 0x6c
  if (q == NULL) {
 802301e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023020:	2b00      	cmp	r3, #0
 8023022:	d102      	bne.n	802302a <fp_div+0x62>
      return FP_MEM;
 8023024:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8023028:	e2be      	b.n	80235a8 <fp_div+0x5e0>
  }
  x = &q[1]; y = &q[2]; t1 = &q[3]; t2 = &q[4];
 802302a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802302c:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8023030:	66bb      	str	r3, [r7, #104]	@ 0x68
 8023032:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023034:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8023038:	667b      	str	r3, [r7, #100]	@ 0x64
 802303a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802303c:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8023040:	663b      	str	r3, [r7, #96]	@ 0x60
 8023042:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023044:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8023048:	65fb      	str	r3, [r7, #92]	@ 0x5c
#endif

  fp_init(q);
 802304a:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 802304c:	f003 fcd4 	bl	80269f8 <fp_init>
  /* qb + d = a, and b is an integer > 0, therefore q <= a */
  q->used = a->used;
 8023050:	697b      	ldr	r3, [r7, #20]
 8023052:	681a      	ldr	r2, [r3, #0]
 8023054:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023056:	601a      	str	r2, [r3, #0]

  fp_init(t1);
 8023058:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 802305a:	f003 fccd 	bl	80269f8 <fp_init>
  fp_init(t2);
 802305e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023060:	f003 fcca 	bl	80269f8 <fp_init>
  ** Init a copy (x) of the input (a)
  **
  ** ALERT: Not calling fp_init_copy() as some compiler optimization settings
  ** such as -O2 will complain that (x) or (y) "may be used uninitialized".
  ** The fp_init() is here only to appease the compiler.  */
  fp_init(x);
 8023064:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023066:	f003 fcc7 	bl	80269f8 <fp_init>
  fp_copy(a, x); /* copy (src = a) to (dst = x) */
 802306a:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 802306c:	6978      	ldr	r0, [r7, #20]
 802306e:	f003 fead 	bl	8026dcc <fp_copy>

  fp_init(y);
 8023072:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023074:	f003 fcc0 	bl	80269f8 <fp_init>
  fp_copy(b, y); /* copy (src = b) to (dst = y) */
 8023078:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 802307a:	6938      	ldr	r0, [r7, #16]
 802307c:	f003 fea6 	bl	8026dcc <fp_copy>

  /* fix the sign */
  neg = (a->sign == b->sign) ? FP_ZPOS : FP_NEG;
 8023080:	697b      	ldr	r3, [r7, #20]
 8023082:	685a      	ldr	r2, [r3, #4]
 8023084:	693b      	ldr	r3, [r7, #16]
 8023086:	685b      	ldr	r3, [r3, #4]
 8023088:	429a      	cmp	r2, r3
 802308a:	bf14      	ite	ne
 802308c:	2301      	movne	r3, #1
 802308e:	2300      	moveq	r3, #0
 8023090:	b2db      	uxtb	r3, r3
 8023092:	65bb      	str	r3, [r7, #88]	@ 0x58
  x->sign = y->sign = FP_ZPOS;
 8023094:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8023096:	2200      	movs	r2, #0
 8023098:	605a      	str	r2, [r3, #4]
 802309a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802309c:	685a      	ldr	r2, [r3, #4]
 802309e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80230a0:	605a      	str	r2, [r3, #4]

  /* normalize both x and y, ensure that y >= b/2, [b == 2**DIGIT_BIT] */
  norm = fp_count_bits(y) % DIGIT_BIT;
 80230a2:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80230a4:	f003 fabc 	bl	8026620 <fp_count_bits>
 80230a8:	4603      	mov	r3, r0
 80230aa:	425a      	negs	r2, r3
 80230ac:	f003 031f 	and.w	r3, r3, #31
 80230b0:	f002 021f 	and.w	r2, r2, #31
 80230b4:	bf58      	it	pl
 80230b6:	4253      	negpl	r3, r2
 80230b8:	673b      	str	r3, [r7, #112]	@ 0x70
  if (norm < (int)(DIGIT_BIT-1)) {
 80230ba:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80230bc:	2b1e      	cmp	r3, #30
 80230be:	dc29      	bgt.n	8023114 <fp_div+0x14c>
    norm = (DIGIT_BIT-1) - norm;
 80230c0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80230c2:	f1c3 031f 	rsb	r3, r3, #31
 80230c6:	673b      	str	r3, [r7, #112]	@ 0x70
    ret = fp_mul_2d (x, norm, x);
 80230c8:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80230ca:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80230cc:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 80230ce:	f7ff fde0 	bl	8022c92 <fp_mul_2d>
 80230d2:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 80230d4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230d6:	2b00      	cmp	r3, #0
 80230d8:	d009      	beq.n	80230ee <fp_div+0x126>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 80230da:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80230dc:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80230de:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80230e0:	2b00      	cmp	r3, #0
 80230e2:	d002      	beq.n	80230ea <fp_div+0x122>
 80230e4:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 80230e6:	f7fb fde5 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return ret;
 80230ea:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230ec:	e25c      	b.n	80235a8 <fp_div+0x5e0>
    }
    ret = fp_mul_2d (y, norm, y);
 80230ee:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80230f0:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80230f2:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80230f4:	f7ff fdcd 	bl	8022c92 <fp_mul_2d>
 80230f8:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 80230fa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230fc:	2b00      	cmp	r3, #0
 80230fe:	d00b      	beq.n	8023118 <fp_div+0x150>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023100:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023102:	653b      	str	r3, [r7, #80]	@ 0x50
 8023104:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8023106:	2b00      	cmp	r3, #0
 8023108:	d002      	beq.n	8023110 <fp_div+0x148>
 802310a:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 802310c:	f7fb fdd2 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return ret;
 8023110:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023112:	e249      	b.n	80235a8 <fp_div+0x5e0>
    }
  } else {
    norm = 0;
 8023114:	2300      	movs	r3, #0
 8023116:	673b      	str	r3, [r7, #112]	@ 0x70
  }

  /* note hac does 0 based, so if used==5 then its 0,1,2,3,4, e.g. use 4 */
  n = x->used - 1;
 8023118:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802311a:	681b      	ldr	r3, [r3, #0]
 802311c:	3b01      	subs	r3, #1
 802311e:	64bb      	str	r3, [r7, #72]	@ 0x48
  t = y->used - 1;
 8023120:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8023122:	681b      	ldr	r3, [r3, #0]
 8023124:	3b01      	subs	r3, #1
 8023126:	647b      	str	r3, [r7, #68]	@ 0x44

  /* while (x >= y*b**n-t) do { q[n-t] += 1; x -= y*b**{n-t} } */
  ret = fp_lshd (y, n - t); /* y = y*b**{n-t} */
 8023128:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802312a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802312c:	1ad3      	subs	r3, r2, r3
 802312e:	4619      	mov	r1, r3
 8023130:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023132:	f003 fad1 	bl	80266d8 <fp_lshd>
 8023136:	6578      	str	r0, [r7, #84]	@ 0x54
  if (ret != FP_OKAY) {
 8023138:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802313a:	2b00      	cmp	r3, #0
 802313c:	d02a      	beq.n	8023194 <fp_div+0x1cc>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 802313e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023140:	61bb      	str	r3, [r7, #24]
 8023142:	69bb      	ldr	r3, [r7, #24]
 8023144:	2b00      	cmp	r3, #0
 8023146:	d002      	beq.n	802314e <fp_div+0x186>
 8023148:	69b8      	ldr	r0, [r7, #24]
 802314a:	f7fb fdb3 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return ret;
 802314e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023150:	e22a      	b.n	80235a8 <fp_div+0x5e0>
  }

  while (fp_cmp (x, y) != FP_LT) {
    ++(q->dp[n - t]);
 8023152:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8023154:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023156:	1ad2      	subs	r2, r2, r3
 8023158:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 802315a:	1c93      	adds	r3, r2, #2
 802315c:	009b      	lsls	r3, r3, #2
 802315e:	440b      	add	r3, r1
 8023160:	685b      	ldr	r3, [r3, #4]
 8023162:	1c59      	adds	r1, r3, #1
 8023164:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023166:	1c93      	adds	r3, r2, #2
 8023168:	009b      	lsls	r3, r3, #2
 802316a:	4403      	add	r3, r0
 802316c:	6059      	str	r1, [r3, #4]
    ret = fp_sub (x, y, x);
 802316e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023170:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8023172:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023174:	f7ff fb33 	bl	80227de <fp_sub>
 8023178:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 802317a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802317c:	2b00      	cmp	r3, #0
 802317e:	d009      	beq.n	8023194 <fp_div+0x1cc>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023180:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023182:	61fb      	str	r3, [r7, #28]
 8023184:	69fb      	ldr	r3, [r7, #28]
 8023186:	2b00      	cmp	r3, #0
 8023188:	d002      	beq.n	8023190 <fp_div+0x1c8>
 802318a:	69f8      	ldr	r0, [r7, #28]
 802318c:	f7fb fd92 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return ret;
 8023190:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023192:	e209      	b.n	80235a8 <fp_div+0x5e0>
  while (fp_cmp (x, y) != FP_LT) {
 8023194:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8023196:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023198:	f002 fe14 	bl	8025dc4 <fp_cmp>
 802319c:	4603      	mov	r3, r0
 802319e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80231a2:	d1d6      	bne.n	8023152 <fp_div+0x18a>
    }
  }

  /* reset y by shifting it back down */
  fp_rshd (y, n - t);
 80231a4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80231a6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80231a8:	1ad3      	subs	r3, r2, r3
 80231aa:	4619      	mov	r1, r3
 80231ac:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80231ae:	f003 fb78 	bl	80268a2 <fp_rshd>

  /* step 3. for i from n down to (t + 1) */
  for (i = n; i >= (t + 1); i--) {
 80231b2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80231b4:	677b      	str	r3, [r7, #116]	@ 0x74
 80231b6:	e179      	b.n	80234ac <fp_div+0x4e4>
    if (i > x->used) {
 80231b8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80231ba:	681b      	ldr	r3, [r3, #0]
 80231bc:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80231be:	429a      	cmp	r2, r3
 80231c0:	f300 8170 	bgt.w	80234a4 <fp_div+0x4dc>
      continue;
    }

    /* step 3.1 if xi == yt then set q{i-t-1} to b-1,
     * otherwise set q{i-t-1} to (xi*b + x{i-1})/yt */
    if (x->dp[i] == y->dp[t]) {
 80231c4:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80231c6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80231c8:	3302      	adds	r3, #2
 80231ca:	009b      	lsls	r3, r3, #2
 80231cc:	4413      	add	r3, r2
 80231ce:	685a      	ldr	r2, [r3, #4]
 80231d0:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 80231d2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80231d4:	3302      	adds	r3, #2
 80231d6:	009b      	lsls	r3, r3, #2
 80231d8:	440b      	add	r3, r1
 80231da:	685b      	ldr	r3, [r3, #4]
 80231dc:	429a      	cmp	r2, r3
 80231de:	d10b      	bne.n	80231f8 <fp_div+0x230>
      q->dp[i - t - 1] = (fp_digit) ((((fp_word)1) << DIGIT_BIT) - 1);
 80231e0:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80231e2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80231e4:	1ad3      	subs	r3, r2, r3
 80231e6:	3b01      	subs	r3, #1
 80231e8:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80231ea:	3302      	adds	r3, #2
 80231ec:	009b      	lsls	r3, r3, #2
 80231ee:	4413      	add	r3, r2
 80231f0:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80231f4:	605a      	str	r2, [r3, #4]
 80231f6:	e03f      	b.n	8023278 <fp_div+0x2b0>
    } else {
      fp_word tmp;
      tmp = ((fp_word) x->dp[i]) << ((fp_word) DIGIT_BIT);
 80231f8:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80231fa:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80231fc:	3302      	adds	r3, #2
 80231fe:	009b      	lsls	r3, r3, #2
 8023200:	4413      	add	r3, r2
 8023202:	685b      	ldr	r3, [r3, #4]
 8023204:	2200      	movs	r2, #0
 8023206:	469a      	mov	sl, r3
 8023208:	4693      	mov	fp, r2
 802320a:	f04f 0200 	mov.w	r2, #0
 802320e:	f04f 0300 	mov.w	r3, #0
 8023212:	4653      	mov	r3, sl
 8023214:	2200      	movs	r2, #0
 8023216:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
      tmp |= ((fp_word) x->dp[i - 1]);
 802321a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802321c:	3b01      	subs	r3, #1
 802321e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023220:	3302      	adds	r3, #2
 8023222:	009b      	lsls	r3, r3, #2
 8023224:	4413      	add	r3, r2
 8023226:	685b      	ldr	r3, [r3, #4]
 8023228:	2200      	movs	r2, #0
 802322a:	461c      	mov	r4, r3
 802322c:	4615      	mov	r5, r2
 802322e:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 8023232:	ea42 0804 	orr.w	r8, r2, r4
 8023236:	ea43 0905 	orr.w	r9, r3, r5
 802323a:	e9c7 890e 	strd	r8, r9, [r7, #56]	@ 0x38
#ifdef WOLFSSL_LINUXKM
      /* Linux kernel macro for in-place 64 bit integer division. */
      do_div(tmp, (fp_word)y->dp[t]);
#else
      tmp /= ((fp_word)y->dp[t]);
 802323e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8023240:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023242:	3302      	adds	r3, #2
 8023244:	009b      	lsls	r3, r3, #2
 8023246:	4413      	add	r3, r2
 8023248:	685b      	ldr	r3, [r3, #4]
 802324a:	2200      	movs	r2, #0
 802324c:	603b      	str	r3, [r7, #0]
 802324e:	607a      	str	r2, [r7, #4]
 8023250:	e9d7 2300 	ldrd	r2, r3, [r7]
 8023254:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 8023258:	f7dd f822 	bl	80002a0 <__aeabi_uldivmod>
 802325c:	4602      	mov	r2, r0
 802325e:	460b      	mov	r3, r1
 8023260:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
#endif
      q->dp[i - t - 1] = (fp_digit) (tmp);
 8023264:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8023266:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023268:	1ad3      	subs	r3, r2, r3
 802326a:	3b01      	subs	r3, #1
 802326c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802326e:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8023270:	3302      	adds	r3, #2
 8023272:	009b      	lsls	r3, r3, #2
 8023274:	440b      	add	r3, r1
 8023276:	605a      	str	r2, [r3, #4]
    /* while (q{i-t-1} * (yt * b + y{t-1})) >
             xi * b**2 + xi-1 * b + xi-2

       do q{i-t-1} -= 1;
    */
    q->dp[i - t - 1] = (q->dp[i - t - 1] + 1);
 8023278:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802327a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802327c:	1ad3      	subs	r3, r2, r3
 802327e:	3b01      	subs	r3, #1
 8023280:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8023282:	3302      	adds	r3, #2
 8023284:	009b      	lsls	r3, r3, #2
 8023286:	4413      	add	r3, r2
 8023288:	685a      	ldr	r2, [r3, #4]
 802328a:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 802328c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802328e:	1acb      	subs	r3, r1, r3
 8023290:	3b01      	subs	r3, #1
 8023292:	3201      	adds	r2, #1
 8023294:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8023296:	3302      	adds	r3, #2
 8023298:	009b      	lsls	r3, r3, #2
 802329a:	440b      	add	r3, r1
 802329c:	605a      	str	r2, [r3, #4]
    do {
      q->dp[i - t - 1] = (q->dp[i - t - 1] - 1);
 802329e:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80232a0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80232a2:	1ad3      	subs	r3, r2, r3
 80232a4:	3b01      	subs	r3, #1
 80232a6:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80232a8:	3302      	adds	r3, #2
 80232aa:	009b      	lsls	r3, r3, #2
 80232ac:	4413      	add	r3, r2
 80232ae:	685a      	ldr	r2, [r3, #4]
 80232b0:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 80232b2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80232b4:	1acb      	subs	r3, r1, r3
 80232b6:	3b01      	subs	r3, #1
 80232b8:	3a01      	subs	r2, #1
 80232ba:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 80232bc:	3302      	adds	r3, #2
 80232be:	009b      	lsls	r3, r3, #2
 80232c0:	440b      	add	r3, r1
 80232c2:	605a      	str	r2, [r3, #4]

      /* find left hand */
      fp_zero (t1);
 80232c4:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80232c6:	f003 fba5 	bl	8026a14 <fp_zero>
      t1->dp[0] = (t - 1 < 0) ? 0 : y->dp[t - 1];
 80232ca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80232cc:	2b00      	cmp	r3, #0
 80232ce:	dd07      	ble.n	80232e0 <fp_div+0x318>
 80232d0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80232d2:	3b01      	subs	r3, #1
 80232d4:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80232d6:	3302      	adds	r3, #2
 80232d8:	009b      	lsls	r3, r3, #2
 80232da:	4413      	add	r3, r2
 80232dc:	685b      	ldr	r3, [r3, #4]
 80232de:	e000      	b.n	80232e2 <fp_div+0x31a>
 80232e0:	2300      	movs	r3, #0
 80232e2:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80232e4:	60d3      	str	r3, [r2, #12]
      t1->dp[1] = y->dp[t];
 80232e6:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80232e8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80232ea:	3302      	adds	r3, #2
 80232ec:	009b      	lsls	r3, r3, #2
 80232ee:	4413      	add	r3, r2
 80232f0:	685a      	ldr	r2, [r3, #4]
 80232f2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80232f4:	611a      	str	r2, [r3, #16]
      t1->used = 2;
 80232f6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80232f8:	2202      	movs	r2, #2
 80232fa:	601a      	str	r2, [r3, #0]
      ret = fp_mul_d (t1, q->dp[i - t - 1], t1);
 80232fc:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80232fe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023300:	1ad3      	subs	r3, r2, r3
 8023302:	3b01      	subs	r3, #1
 8023304:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8023306:	3302      	adds	r3, #2
 8023308:	009b      	lsls	r3, r3, #2
 802330a:	4413      	add	r3, r2
 802330c:	685b      	ldr	r3, [r3, #4]
 802330e:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8023310:	4619      	mov	r1, r3
 8023312:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8023314:	f7ff fc19 	bl	8022b4a <fp_mul_d>
 8023318:	6578      	str	r0, [r7, #84]	@ 0x54
      if (ret != FP_OKAY) {
 802331a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802331c:	2b00      	cmp	r3, #0
 802331e:	d009      	beq.n	8023334 <fp_div+0x36c>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023320:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023322:	623b      	str	r3, [r7, #32]
 8023324:	6a3b      	ldr	r3, [r7, #32]
 8023326:	2b00      	cmp	r3, #0
 8023328:	d002      	beq.n	8023330 <fp_div+0x368>
 802332a:	6a38      	ldr	r0, [r7, #32]
 802332c:	f7fb fcc2 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return ret;
 8023330:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023332:	e139      	b.n	80235a8 <fp_div+0x5e0>
      }

      /* find right hand */
      t2->dp[0] = (i - 2 < 0) ? 0 : x->dp[i - 2];
 8023334:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023336:	2b01      	cmp	r3, #1
 8023338:	dd07      	ble.n	802334a <fp_div+0x382>
 802333a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802333c:	3b02      	subs	r3, #2
 802333e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023340:	3302      	adds	r3, #2
 8023342:	009b      	lsls	r3, r3, #2
 8023344:	4413      	add	r3, r2
 8023346:	685b      	ldr	r3, [r3, #4]
 8023348:	e000      	b.n	802334c <fp_div+0x384>
 802334a:	2300      	movs	r3, #0
 802334c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802334e:	60d3      	str	r3, [r2, #12]
      t2->dp[1] = (i - 1 < 0) ? 0 : x->dp[i - 1];
 8023350:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023352:	2b00      	cmp	r3, #0
 8023354:	dd07      	ble.n	8023366 <fp_div+0x39e>
 8023356:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023358:	3b01      	subs	r3, #1
 802335a:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 802335c:	3302      	adds	r3, #2
 802335e:	009b      	lsls	r3, r3, #2
 8023360:	4413      	add	r3, r2
 8023362:	685b      	ldr	r3, [r3, #4]
 8023364:	e000      	b.n	8023368 <fp_div+0x3a0>
 8023366:	2300      	movs	r3, #0
 8023368:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802336a:	6113      	str	r3, [r2, #16]
      t2->dp[2] = x->dp[i];
 802336c:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 802336e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023370:	3302      	adds	r3, #2
 8023372:	009b      	lsls	r3, r3, #2
 8023374:	4413      	add	r3, r2
 8023376:	685a      	ldr	r2, [r3, #4]
 8023378:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802337a:	615a      	str	r2, [r3, #20]
      t2->used = 3;
 802337c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802337e:	2203      	movs	r2, #3
 8023380:	601a      	str	r2, [r3, #0]
    } while (fp_cmp_mag(t1, t2) == FP_GT);
 8023382:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023384:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8023386:	f002 fd82 	bl	8025e8e <fp_cmp_mag>
 802338a:	4603      	mov	r3, r0
 802338c:	2b01      	cmp	r3, #1
 802338e:	d086      	beq.n	802329e <fp_div+0x2d6>

    /* step 3.3 x = x - q{i-t-1} * y * b**{i-t-1} */
    ret = fp_mul_d (y, q->dp[i - t - 1], t1);
 8023390:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8023392:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023394:	1ad3      	subs	r3, r2, r3
 8023396:	3b01      	subs	r3, #1
 8023398:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802339a:	3302      	adds	r3, #2
 802339c:	009b      	lsls	r3, r3, #2
 802339e:	4413      	add	r3, r2
 80233a0:	685b      	ldr	r3, [r3, #4]
 80233a2:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80233a4:	4619      	mov	r1, r3
 80233a6:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80233a8:	f7ff fbcf 	bl	8022b4a <fp_mul_d>
 80233ac:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 80233ae:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80233b0:	2b00      	cmp	r3, #0
 80233b2:	d009      	beq.n	80233c8 <fp_div+0x400>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 80233b4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80233b6:	627b      	str	r3, [r7, #36]	@ 0x24
 80233b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80233ba:	2b00      	cmp	r3, #0
 80233bc:	d002      	beq.n	80233c4 <fp_div+0x3fc>
 80233be:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 80233c0:	f7fb fc78 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return ret;
 80233c4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80233c6:	e0ef      	b.n	80235a8 <fp_div+0x5e0>
    }
    ret = fp_lshd  (t1, i - t - 1);
 80233c8:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80233ca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80233cc:	1ad3      	subs	r3, r2, r3
 80233ce:	3b01      	subs	r3, #1
 80233d0:	4619      	mov	r1, r3
 80233d2:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80233d4:	f003 f980 	bl	80266d8 <fp_lshd>
 80233d8:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 80233da:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80233dc:	2b00      	cmp	r3, #0
 80233de:	d009      	beq.n	80233f4 <fp_div+0x42c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 80233e0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80233e2:	62bb      	str	r3, [r7, #40]	@ 0x28
 80233e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80233e6:	2b00      	cmp	r3, #0
 80233e8:	d002      	beq.n	80233f0 <fp_div+0x428>
 80233ea:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80233ec:	f7fb fc62 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return ret;
 80233f0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80233f2:	e0d9      	b.n	80235a8 <fp_div+0x5e0>
    }
    ret = fp_sub   (x, t1, x);
 80233f4:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80233f6:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80233f8:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 80233fa:	f7ff f9f0 	bl	80227de <fp_sub>
 80233fe:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 8023400:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023402:	2b00      	cmp	r3, #0
 8023404:	d009      	beq.n	802341a <fp_div+0x452>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023406:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023408:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802340a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802340c:	2b00      	cmp	r3, #0
 802340e:	d002      	beq.n	8023416 <fp_div+0x44e>
 8023410:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8023412:	f7fb fc4f 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return ret;
 8023416:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023418:	e0c6      	b.n	80235a8 <fp_div+0x5e0>
    }

    /* if x < 0 then { x = x + y*b**{i-t-1}; q{i-t-1} -= 1; } */
    if (x->sign == FP_NEG) {
 802341a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802341c:	685b      	ldr	r3, [r3, #4]
 802341e:	2b01      	cmp	r3, #1
 8023420:	d141      	bne.n	80234a6 <fp_div+0x4de>
      fp_copy (y, t1);
 8023422:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8023424:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023426:	f003 fcd1 	bl	8026dcc <fp_copy>
      ret = fp_lshd (t1, i - t - 1);
 802342a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802342c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802342e:	1ad3      	subs	r3, r2, r3
 8023430:	3b01      	subs	r3, #1
 8023432:	4619      	mov	r1, r3
 8023434:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8023436:	f003 f94f 	bl	80266d8 <fp_lshd>
 802343a:	6578      	str	r0, [r7, #84]	@ 0x54
      if (ret != FP_OKAY) {
 802343c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802343e:	2b00      	cmp	r3, #0
 8023440:	d009      	beq.n	8023456 <fp_div+0x48e>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023442:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023444:	633b      	str	r3, [r7, #48]	@ 0x30
 8023446:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023448:	2b00      	cmp	r3, #0
 802344a:	d002      	beq.n	8023452 <fp_div+0x48a>
 802344c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 802344e:	f7fb fc31 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return ret;
 8023452:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023454:	e0a8      	b.n	80235a8 <fp_div+0x5e0>
      }
      ret = fp_add (x, t1, x);
 8023456:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023458:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 802345a:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 802345c:	f7ff f8dd 	bl	802261a <fp_add>
 8023460:	6578      	str	r0, [r7, #84]	@ 0x54
      if (ret != FP_OKAY) {
 8023462:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023464:	2b00      	cmp	r3, #0
 8023466:	d009      	beq.n	802347c <fp_div+0x4b4>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023468:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802346a:	637b      	str	r3, [r7, #52]	@ 0x34
 802346c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802346e:	2b00      	cmp	r3, #0
 8023470:	d002      	beq.n	8023478 <fp_div+0x4b0>
 8023472:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8023474:	f7fb fc1e 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return ret;
 8023478:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802347a:	e095      	b.n	80235a8 <fp_div+0x5e0>
      }
      q->dp[i - t - 1] = q->dp[i - t - 1] - 1;
 802347c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802347e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023480:	1ad3      	subs	r3, r2, r3
 8023482:	3b01      	subs	r3, #1
 8023484:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8023486:	3302      	adds	r3, #2
 8023488:	009b      	lsls	r3, r3, #2
 802348a:	4413      	add	r3, r2
 802348c:	685a      	ldr	r2, [r3, #4]
 802348e:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8023490:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023492:	1acb      	subs	r3, r1, r3
 8023494:	3b01      	subs	r3, #1
 8023496:	3a01      	subs	r2, #1
 8023498:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 802349a:	3302      	adds	r3, #2
 802349c:	009b      	lsls	r3, r3, #2
 802349e:	440b      	add	r3, r1
 80234a0:	605a      	str	r2, [r3, #4]
 80234a2:	e000      	b.n	80234a6 <fp_div+0x4de>
      continue;
 80234a4:	bf00      	nop
  for (i = n; i >= (t + 1); i--) {
 80234a6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80234a8:	3b01      	subs	r3, #1
 80234aa:	677b      	str	r3, [r7, #116]	@ 0x74
 80234ac:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80234ae:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80234b0:	429a      	cmp	r2, r3
 80234b2:	f6ff ae81 	blt.w	80231b8 <fp_div+0x1f0>
  /* now q is the quotient and x is the remainder
   * [which we have to normalize]
   */

  /* get sign before writing to c */
  x->sign = x->used == 0 ? FP_ZPOS : a->sign;
 80234b6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80234b8:	681b      	ldr	r3, [r3, #0]
 80234ba:	2b00      	cmp	r3, #0
 80234bc:	d002      	beq.n	80234c4 <fp_div+0x4fc>
 80234be:	697b      	ldr	r3, [r7, #20]
 80234c0:	685b      	ldr	r3, [r3, #4]
 80234c2:	e000      	b.n	80234c6 <fp_div+0x4fe>
 80234c4:	2300      	movs	r3, #0
 80234c6:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80234c8:	6053      	str	r3, [r2, #4]

  if (c != NULL) {
 80234ca:	68fb      	ldr	r3, [r7, #12]
 80234cc:	2b00      	cmp	r3, #0
 80234ce:	d024      	beq.n	802351a <fp_div+0x552>
    fp_clamp (q);
 80234d0:	e004      	b.n	80234dc <fp_div+0x514>
 80234d2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80234d4:	681b      	ldr	r3, [r3, #0]
 80234d6:	1e5a      	subs	r2, r3, #1
 80234d8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80234da:	601a      	str	r2, [r3, #0]
 80234dc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80234de:	681b      	ldr	r3, [r3, #0]
 80234e0:	2b00      	cmp	r3, #0
 80234e2:	d009      	beq.n	80234f8 <fp_div+0x530>
 80234e4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80234e6:	681b      	ldr	r3, [r3, #0]
 80234e8:	3b01      	subs	r3, #1
 80234ea:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80234ec:	3302      	adds	r3, #2
 80234ee:	009b      	lsls	r3, r3, #2
 80234f0:	4413      	add	r3, r2
 80234f2:	685b      	ldr	r3, [r3, #4]
 80234f4:	2b00      	cmp	r3, #0
 80234f6:	d0ec      	beq.n	80234d2 <fp_div+0x50a>
 80234f8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80234fa:	681b      	ldr	r3, [r3, #0]
 80234fc:	2b00      	cmp	r3, #0
 80234fe:	d002      	beq.n	8023506 <fp_div+0x53e>
 8023500:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023502:	685b      	ldr	r3, [r3, #4]
 8023504:	e000      	b.n	8023508 <fp_div+0x540>
 8023506:	2300      	movs	r3, #0
 8023508:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802350a:	6053      	str	r3, [r2, #4]
    fp_copy (q, c);
 802350c:	68f9      	ldr	r1, [r7, #12]
 802350e:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023510:	f003 fc5c 	bl	8026dcc <fp_copy>
    c->sign = neg;
 8023514:	68fb      	ldr	r3, [r7, #12]
 8023516:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8023518:	605a      	str	r2, [r3, #4]
  }

  if (d != NULL) {
 802351a:	68bb      	ldr	r3, [r7, #8]
 802351c:	2b00      	cmp	r3, #0
 802351e:	d03a      	beq.n	8023596 <fp_div+0x5ce>
    fp_div_2d (x, norm, x, NULL);
 8023520:	2300      	movs	r3, #0
 8023522:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023524:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8023526:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023528:	f000 f986 	bl	8023838 <fp_div_2d>

    /* zero any excess digits on the destination that we didn't write to */
    for (i = b->used; i < x->used; i++) {
 802352c:	693b      	ldr	r3, [r7, #16]
 802352e:	681b      	ldr	r3, [r3, #0]
 8023530:	677b      	str	r3, [r7, #116]	@ 0x74
 8023532:	e009      	b.n	8023548 <fp_div+0x580>
        x->dp[i] = 0;
 8023534:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023536:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023538:	3302      	adds	r3, #2
 802353a:	009b      	lsls	r3, r3, #2
 802353c:	4413      	add	r3, r2
 802353e:	2200      	movs	r2, #0
 8023540:	605a      	str	r2, [r3, #4]
    for (i = b->used; i < x->used; i++) {
 8023542:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023544:	3301      	adds	r3, #1
 8023546:	677b      	str	r3, [r7, #116]	@ 0x74
 8023548:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802354a:	681b      	ldr	r3, [r3, #0]
 802354c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802354e:	429a      	cmp	r2, r3
 8023550:	dbf0      	blt.n	8023534 <fp_div+0x56c>
    }
    fp_clamp(x);
 8023552:	e004      	b.n	802355e <fp_div+0x596>
 8023554:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023556:	681b      	ldr	r3, [r3, #0]
 8023558:	1e5a      	subs	r2, r3, #1
 802355a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802355c:	601a      	str	r2, [r3, #0]
 802355e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023560:	681b      	ldr	r3, [r3, #0]
 8023562:	2b00      	cmp	r3, #0
 8023564:	d009      	beq.n	802357a <fp_div+0x5b2>
 8023566:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023568:	681b      	ldr	r3, [r3, #0]
 802356a:	3b01      	subs	r3, #1
 802356c:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 802356e:	3302      	adds	r3, #2
 8023570:	009b      	lsls	r3, r3, #2
 8023572:	4413      	add	r3, r2
 8023574:	685b      	ldr	r3, [r3, #4]
 8023576:	2b00      	cmp	r3, #0
 8023578:	d0ec      	beq.n	8023554 <fp_div+0x58c>
 802357a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802357c:	681b      	ldr	r3, [r3, #0]
 802357e:	2b00      	cmp	r3, #0
 8023580:	d002      	beq.n	8023588 <fp_div+0x5c0>
 8023582:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023584:	685b      	ldr	r3, [r3, #4]
 8023586:	e000      	b.n	802358a <fp_div+0x5c2>
 8023588:	2300      	movs	r3, #0
 802358a:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 802358c:	6053      	str	r3, [r2, #4]
    fp_copy (x, d);
 802358e:	68b9      	ldr	r1, [r7, #8]
 8023590:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023592:	f003 fc1b 	bl	8026dcc <fp_copy>
  }

#ifdef WOLFSSL_SMALL_STACK
  XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023596:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023598:	643b      	str	r3, [r7, #64]	@ 0x40
 802359a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802359c:	2b00      	cmp	r3, #0
 802359e:	d002      	beq.n	80235a6 <fp_div+0x5de>
 80235a0:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 80235a2:	f7fb fb87 	bl	801ecb4 <wolfSSL_Free>
#endif
  return FP_OKAY;
 80235a6:	2300      	movs	r3, #0
}
 80235a8:	4618      	mov	r0, r3
 80235aa:	3778      	adds	r7, #120	@ 0x78
 80235ac:	46bd      	mov	sp, r7
 80235ae:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080235b2 <fp_div_2>:

/* b = a/2 */
void fp_div_2(fp_int * a, fp_int * b)
{
 80235b2:	b480      	push	{r7}
 80235b4:	b089      	sub	sp, #36	@ 0x24
 80235b6:	af00      	add	r7, sp, #0
 80235b8:	6078      	str	r0, [r7, #4]
 80235ba:	6039      	str	r1, [r7, #0]
  int     x, oldused;

  oldused = b->used;
 80235bc:	683b      	ldr	r3, [r7, #0]
 80235be:	681b      	ldr	r3, [r3, #0]
 80235c0:	60fb      	str	r3, [r7, #12]
  b->used = a->used;
 80235c2:	687b      	ldr	r3, [r7, #4]
 80235c4:	681a      	ldr	r2, [r3, #0]
 80235c6:	683b      	ldr	r3, [r7, #0]
 80235c8:	601a      	str	r2, [r3, #0]
  {
    fp_digit r, rr, *tmpa, *tmpb;

    /* source alias */
    tmpa = a->dp + b->used - 1;
 80235ca:	687b      	ldr	r3, [r7, #4]
 80235cc:	f103 020c 	add.w	r2, r3, #12
 80235d0:	683b      	ldr	r3, [r7, #0]
 80235d2:	681b      	ldr	r3, [r3, #0]
 80235d4:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80235d8:	3b01      	subs	r3, #1
 80235da:	009b      	lsls	r3, r3, #2
 80235dc:	4413      	add	r3, r2
 80235de:	617b      	str	r3, [r7, #20]

    /* dest alias */
    tmpb = b->dp + b->used - 1;
 80235e0:	683b      	ldr	r3, [r7, #0]
 80235e2:	f103 020c 	add.w	r2, r3, #12
 80235e6:	683b      	ldr	r3, [r7, #0]
 80235e8:	681b      	ldr	r3, [r3, #0]
 80235ea:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80235ee:	3b01      	subs	r3, #1
 80235f0:	009b      	lsls	r3, r3, #2
 80235f2:	4413      	add	r3, r2
 80235f4:	613b      	str	r3, [r7, #16]

    /* carry */
    r = 0;
 80235f6:	2300      	movs	r3, #0
 80235f8:	61bb      	str	r3, [r7, #24]
    for (x = b->used - 1; x >= 0; x--) {
 80235fa:	683b      	ldr	r3, [r7, #0]
 80235fc:	681b      	ldr	r3, [r3, #0]
 80235fe:	3b01      	subs	r3, #1
 8023600:	61fb      	str	r3, [r7, #28]
 8023602:	e015      	b.n	8023630 <fp_div_2+0x7e>
      /* get the carry for the next iteration */
      rr = *tmpa & 1;
 8023604:	697b      	ldr	r3, [r7, #20]
 8023606:	681b      	ldr	r3, [r3, #0]
 8023608:	f003 0301 	and.w	r3, r3, #1
 802360c:	60bb      	str	r3, [r7, #8]

      /* shift the current digit, add in carry and store */
      *tmpb-- = (*tmpa-- >> 1) | (r << (DIGIT_BIT - 1));
 802360e:	697b      	ldr	r3, [r7, #20]
 8023610:	1f1a      	subs	r2, r3, #4
 8023612:	617a      	str	r2, [r7, #20]
 8023614:	681b      	ldr	r3, [r3, #0]
 8023616:	0859      	lsrs	r1, r3, #1
 8023618:	69bb      	ldr	r3, [r7, #24]
 802361a:	07da      	lsls	r2, r3, #31
 802361c:	693b      	ldr	r3, [r7, #16]
 802361e:	1f18      	subs	r0, r3, #4
 8023620:	6138      	str	r0, [r7, #16]
 8023622:	430a      	orrs	r2, r1
 8023624:	601a      	str	r2, [r3, #0]

      /* forward carry to next iteration */
      r = rr;
 8023626:	68bb      	ldr	r3, [r7, #8]
 8023628:	61bb      	str	r3, [r7, #24]
    for (x = b->used - 1; x >= 0; x--) {
 802362a:	69fb      	ldr	r3, [r7, #28]
 802362c:	3b01      	subs	r3, #1
 802362e:	61fb      	str	r3, [r7, #28]
 8023630:	69fb      	ldr	r3, [r7, #28]
 8023632:	2b00      	cmp	r3, #0
 8023634:	dae6      	bge.n	8023604 <fp_div_2+0x52>
    }

    /* zero any excess digits on the destination that we didn't write to */
    tmpb = b->dp + b->used;
 8023636:	683b      	ldr	r3, [r7, #0]
 8023638:	f103 020c 	add.w	r2, r3, #12
 802363c:	683b      	ldr	r3, [r7, #0]
 802363e:	681b      	ldr	r3, [r3, #0]
 8023640:	009b      	lsls	r3, r3, #2
 8023642:	4413      	add	r3, r2
 8023644:	613b      	str	r3, [r7, #16]
    for (x = b->used; x < oldused; x++) {
 8023646:	683b      	ldr	r3, [r7, #0]
 8023648:	681b      	ldr	r3, [r3, #0]
 802364a:	61fb      	str	r3, [r7, #28]
 802364c:	e007      	b.n	802365e <fp_div_2+0xac>
      *tmpb++ = 0;
 802364e:	693b      	ldr	r3, [r7, #16]
 8023650:	1d1a      	adds	r2, r3, #4
 8023652:	613a      	str	r2, [r7, #16]
 8023654:	2200      	movs	r2, #0
 8023656:	601a      	str	r2, [r3, #0]
    for (x = b->used; x < oldused; x++) {
 8023658:	69fb      	ldr	r3, [r7, #28]
 802365a:	3301      	adds	r3, #1
 802365c:	61fb      	str	r3, [r7, #28]
 802365e:	69fa      	ldr	r2, [r7, #28]
 8023660:	68fb      	ldr	r3, [r7, #12]
 8023662:	429a      	cmp	r2, r3
 8023664:	dbf3      	blt.n	802364e <fp_div_2+0x9c>
    }
  }
  b->sign = a->sign;
 8023666:	687b      	ldr	r3, [r7, #4]
 8023668:	685a      	ldr	r2, [r3, #4]
 802366a:	683b      	ldr	r3, [r7, #0]
 802366c:	605a      	str	r2, [r3, #4]
  fp_clamp (b);
 802366e:	e004      	b.n	802367a <fp_div_2+0xc8>
 8023670:	683b      	ldr	r3, [r7, #0]
 8023672:	681b      	ldr	r3, [r3, #0]
 8023674:	1e5a      	subs	r2, r3, #1
 8023676:	683b      	ldr	r3, [r7, #0]
 8023678:	601a      	str	r2, [r3, #0]
 802367a:	683b      	ldr	r3, [r7, #0]
 802367c:	681b      	ldr	r3, [r3, #0]
 802367e:	2b00      	cmp	r3, #0
 8023680:	d009      	beq.n	8023696 <fp_div_2+0xe4>
 8023682:	683b      	ldr	r3, [r7, #0]
 8023684:	681b      	ldr	r3, [r3, #0]
 8023686:	3b01      	subs	r3, #1
 8023688:	683a      	ldr	r2, [r7, #0]
 802368a:	3302      	adds	r3, #2
 802368c:	009b      	lsls	r3, r3, #2
 802368e:	4413      	add	r3, r2
 8023690:	685b      	ldr	r3, [r3, #4]
 8023692:	2b00      	cmp	r3, #0
 8023694:	d0ec      	beq.n	8023670 <fp_div_2+0xbe>
 8023696:	683b      	ldr	r3, [r7, #0]
 8023698:	681b      	ldr	r3, [r3, #0]
 802369a:	2b00      	cmp	r3, #0
 802369c:	d002      	beq.n	80236a4 <fp_div_2+0xf2>
 802369e:	683b      	ldr	r3, [r7, #0]
 80236a0:	685b      	ldr	r3, [r3, #4]
 80236a2:	e000      	b.n	80236a6 <fp_div_2+0xf4>
 80236a4:	2300      	movs	r3, #0
 80236a6:	683a      	ldr	r2, [r7, #0]
 80236a8:	6053      	str	r3, [r2, #4]
}
 80236aa:	bf00      	nop
 80236ac:	3724      	adds	r7, #36	@ 0x24
 80236ae:	46bd      	mov	sp, r7
 80236b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80236b4:	4770      	bx	lr

080236b6 <fp_div_2_mod_ct>:

/* c = a / 2 (mod b) - constant time (a < b and positive) */
int fp_div_2_mod_ct(fp_int *a, fp_int *b, fp_int *c)
{
 80236b6:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80236ba:	b08d      	sub	sp, #52	@ 0x34
 80236bc:	af00      	add	r7, sp, #0
 80236be:	6178      	str	r0, [r7, #20]
 80236c0:	6139      	str	r1, [r7, #16]
 80236c2:	60fa      	str	r2, [r7, #12]
  fp_word  w = 0;
 80236c4:	f04f 0200 	mov.w	r2, #0
 80236c8:	f04f 0300 	mov.w	r3, #0
 80236cc:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
  fp_digit mask;
  int i;

  mask = (fp_digit)0 - (a->dp[0] & 1);
 80236d0:	697b      	ldr	r3, [r7, #20]
 80236d2:	68db      	ldr	r3, [r3, #12]
 80236d4:	f003 0301 	and.w	r3, r3, #1
 80236d8:	425b      	negs	r3, r3
 80236da:	623b      	str	r3, [r7, #32]
  for (i = 0; i < b->used; i++) {
 80236dc:	2300      	movs	r3, #0
 80236de:	627b      	str	r3, [r7, #36]	@ 0x24
 80236e0:	e047      	b.n	8023772 <fp_div_2_mod_ct+0xbc>
      fp_digit mask_a = (fp_digit)0 - (i < a->used);
 80236e2:	697b      	ldr	r3, [r7, #20]
 80236e4:	681b      	ldr	r3, [r3, #0]
 80236e6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80236e8:	429a      	cmp	r2, r3
 80236ea:	bfb4      	ite	lt
 80236ec:	2301      	movlt	r3, #1
 80236ee:	2300      	movge	r3, #0
 80236f0:	b2db      	uxtb	r3, r3
 80236f2:	425b      	negs	r3, r3
 80236f4:	61fb      	str	r3, [r7, #28]

      w         += b->dp[i] & mask;
 80236f6:	693a      	ldr	r2, [r7, #16]
 80236f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80236fa:	3302      	adds	r3, #2
 80236fc:	009b      	lsls	r3, r3, #2
 80236fe:	4413      	add	r3, r2
 8023700:	685a      	ldr	r2, [r3, #4]
 8023702:	6a3b      	ldr	r3, [r7, #32]
 8023704:	4013      	ands	r3, r2
 8023706:	2200      	movs	r2, #0
 8023708:	461c      	mov	r4, r3
 802370a:	4615      	mov	r5, r2
 802370c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8023710:	eb12 0a04 	adds.w	sl, r2, r4
 8023714:	eb43 0b05 	adc.w	fp, r3, r5
 8023718:	e9c7 ab0a 	strd	sl, fp, [r7, #40]	@ 0x28
      w         += a->dp[i] & mask_a;
 802371c:	697a      	ldr	r2, [r7, #20]
 802371e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023720:	3302      	adds	r3, #2
 8023722:	009b      	lsls	r3, r3, #2
 8023724:	4413      	add	r3, r2
 8023726:	685a      	ldr	r2, [r3, #4]
 8023728:	69fb      	ldr	r3, [r7, #28]
 802372a:	4013      	ands	r3, r2
 802372c:	2200      	movs	r2, #0
 802372e:	4698      	mov	r8, r3
 8023730:	4691      	mov	r9, r2
 8023732:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8023736:	eb12 0108 	adds.w	r1, r2, r8
 802373a:	6039      	str	r1, [r7, #0]
 802373c:	eb43 0309 	adc.w	r3, r3, r9
 8023740:	607b      	str	r3, [r7, #4]
 8023742:	e9d7 2300 	ldrd	r2, r3, [r7]
 8023746:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
      c->dp[i]   = (fp_digit)w;
 802374a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802374c:	68f9      	ldr	r1, [r7, #12]
 802374e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023750:	3302      	adds	r3, #2
 8023752:	009b      	lsls	r3, r3, #2
 8023754:	440b      	add	r3, r1
 8023756:	605a      	str	r2, [r3, #4]
      w        >>= DIGIT_BIT;
 8023758:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 802375c:	f04f 0200 	mov.w	r2, #0
 8023760:	f04f 0300 	mov.w	r3, #0
 8023764:	000a      	movs	r2, r1
 8023766:	2300      	movs	r3, #0
 8023768:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
  for (i = 0; i < b->used; i++) {
 802376c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802376e:	3301      	adds	r3, #1
 8023770:	627b      	str	r3, [r7, #36]	@ 0x24
 8023772:	693b      	ldr	r3, [r7, #16]
 8023774:	681b      	ldr	r3, [r3, #0]
 8023776:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8023778:	429a      	cmp	r2, r3
 802377a:	dbb2      	blt.n	80236e2 <fp_div_2_mod_ct+0x2c>
  }
  for (i = 0; i < b->used-1; i++) {
 802377c:	2300      	movs	r3, #0
 802377e:	627b      	str	r3, [r7, #36]	@ 0x24
 8023780:	e018      	b.n	80237b4 <fp_div_2_mod_ct+0xfe>
      c->dp[i] = (c->dp[i] >> 1) | (c->dp[i+1] << (DIGIT_BIT - 1));
 8023782:	68fa      	ldr	r2, [r7, #12]
 8023784:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023786:	3302      	adds	r3, #2
 8023788:	009b      	lsls	r3, r3, #2
 802378a:	4413      	add	r3, r2
 802378c:	685b      	ldr	r3, [r3, #4]
 802378e:	085a      	lsrs	r2, r3, #1
 8023790:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023792:	3301      	adds	r3, #1
 8023794:	68f9      	ldr	r1, [r7, #12]
 8023796:	3302      	adds	r3, #2
 8023798:	009b      	lsls	r3, r3, #2
 802379a:	440b      	add	r3, r1
 802379c:	685b      	ldr	r3, [r3, #4]
 802379e:	07db      	lsls	r3, r3, #31
 80237a0:	431a      	orrs	r2, r3
 80237a2:	68f9      	ldr	r1, [r7, #12]
 80237a4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80237a6:	3302      	adds	r3, #2
 80237a8:	009b      	lsls	r3, r3, #2
 80237aa:	440b      	add	r3, r1
 80237ac:	605a      	str	r2, [r3, #4]
  for (i = 0; i < b->used-1; i++) {
 80237ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80237b0:	3301      	adds	r3, #1
 80237b2:	627b      	str	r3, [r7, #36]	@ 0x24
 80237b4:	693b      	ldr	r3, [r7, #16]
 80237b6:	681b      	ldr	r3, [r3, #0]
 80237b8:	3b01      	subs	r3, #1
 80237ba:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80237bc:	429a      	cmp	r2, r3
 80237be:	dbe0      	blt.n	8023782 <fp_div_2_mod_ct+0xcc>
  }
  c->dp[i] = (c->dp[i] >> 1) | ((fp_digit)w << (DIGIT_BIT - 1));
 80237c0:	68fa      	ldr	r2, [r7, #12]
 80237c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80237c4:	3302      	adds	r3, #2
 80237c6:	009b      	lsls	r3, r3, #2
 80237c8:	4413      	add	r3, r2
 80237ca:	685b      	ldr	r3, [r3, #4]
 80237cc:	085a      	lsrs	r2, r3, #1
 80237ce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80237d0:	07db      	lsls	r3, r3, #31
 80237d2:	431a      	orrs	r2, r3
 80237d4:	68f9      	ldr	r1, [r7, #12]
 80237d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80237d8:	3302      	adds	r3, #2
 80237da:	009b      	lsls	r3, r3, #2
 80237dc:	440b      	add	r3, r1
 80237de:	605a      	str	r2, [r3, #4]
  c->used = i + 1;
 80237e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80237e2:	1c5a      	adds	r2, r3, #1
 80237e4:	68fb      	ldr	r3, [r7, #12]
 80237e6:	601a      	str	r2, [r3, #0]
  c->sign = FP_ZPOS;
 80237e8:	68fb      	ldr	r3, [r7, #12]
 80237ea:	2200      	movs	r2, #0
 80237ec:	605a      	str	r2, [r3, #4]
  fp_clamp(c);
 80237ee:	e004      	b.n	80237fa <fp_div_2_mod_ct+0x144>
 80237f0:	68fb      	ldr	r3, [r7, #12]
 80237f2:	681b      	ldr	r3, [r3, #0]
 80237f4:	1e5a      	subs	r2, r3, #1
 80237f6:	68fb      	ldr	r3, [r7, #12]
 80237f8:	601a      	str	r2, [r3, #0]
 80237fa:	68fb      	ldr	r3, [r7, #12]
 80237fc:	681b      	ldr	r3, [r3, #0]
 80237fe:	2b00      	cmp	r3, #0
 8023800:	d009      	beq.n	8023816 <fp_div_2_mod_ct+0x160>
 8023802:	68fb      	ldr	r3, [r7, #12]
 8023804:	681b      	ldr	r3, [r3, #0]
 8023806:	3b01      	subs	r3, #1
 8023808:	68fa      	ldr	r2, [r7, #12]
 802380a:	3302      	adds	r3, #2
 802380c:	009b      	lsls	r3, r3, #2
 802380e:	4413      	add	r3, r2
 8023810:	685b      	ldr	r3, [r3, #4]
 8023812:	2b00      	cmp	r3, #0
 8023814:	d0ec      	beq.n	80237f0 <fp_div_2_mod_ct+0x13a>
 8023816:	68fb      	ldr	r3, [r7, #12]
 8023818:	681b      	ldr	r3, [r3, #0]
 802381a:	2b00      	cmp	r3, #0
 802381c:	d002      	beq.n	8023824 <fp_div_2_mod_ct+0x16e>
 802381e:	68fb      	ldr	r3, [r7, #12]
 8023820:	685b      	ldr	r3, [r3, #4]
 8023822:	e000      	b.n	8023826 <fp_div_2_mod_ct+0x170>
 8023824:	2300      	movs	r3, #0
 8023826:	68fa      	ldr	r2, [r7, #12]
 8023828:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 802382a:	2300      	movs	r3, #0
}
 802382c:	4618      	mov	r0, r3
 802382e:	3734      	adds	r7, #52	@ 0x34
 8023830:	46bd      	mov	sp, r7
 8023832:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8023836:	4770      	bx	lr

08023838 <fp_div_2d>:

/* c = a / 2**b */
void fp_div_2d(fp_int *a, int b, fp_int *c, fp_int *d)
{
 8023838:	b580      	push	{r7, lr}
 802383a:	b086      	sub	sp, #24
 802383c:	af00      	add	r7, sp, #0
 802383e:	60f8      	str	r0, [r7, #12]
 8023840:	60b9      	str	r1, [r7, #8]
 8023842:	607a      	str	r2, [r7, #4]
 8023844:	603b      	str	r3, [r7, #0]
  int      D;

  /* if the shift count is <= 0 then we do no work */
  if (b <= 0) {
 8023846:	68bb      	ldr	r3, [r7, #8]
 8023848:	2b00      	cmp	r3, #0
 802384a:	dc0a      	bgt.n	8023862 <fp_div_2d+0x2a>
    fp_copy (a, c);
 802384c:	6879      	ldr	r1, [r7, #4]
 802384e:	68f8      	ldr	r0, [r7, #12]
 8023850:	f003 fabc 	bl	8026dcc <fp_copy>
    if (d != NULL) {
 8023854:	683b      	ldr	r3, [r7, #0]
 8023856:	2b00      	cmp	r3, #0
 8023858:	d05a      	beq.n	8023910 <fp_div_2d+0xd8>
      fp_zero (d);
 802385a:	6838      	ldr	r0, [r7, #0]
 802385c:	f003 f8da 	bl	8026a14 <fp_zero>
    }
    return;
 8023860:	e056      	b.n	8023910 <fp_div_2d+0xd8>
  }

  /* get the remainder before a is changed in calculating c */
  if (a == c && d != NULL) {
 8023862:	68fa      	ldr	r2, [r7, #12]
 8023864:	687b      	ldr	r3, [r7, #4]
 8023866:	429a      	cmp	r2, r3
 8023868:	d107      	bne.n	802387a <fp_div_2d+0x42>
 802386a:	683b      	ldr	r3, [r7, #0]
 802386c:	2b00      	cmp	r3, #0
 802386e:	d004      	beq.n	802387a <fp_div_2d+0x42>
    fp_mod_2d (a, b, d);
 8023870:	683a      	ldr	r2, [r7, #0]
 8023872:	68b9      	ldr	r1, [r7, #8]
 8023874:	68f8      	ldr	r0, [r7, #12]
 8023876:	f000 f88f 	bl	8023998 <fp_mod_2d>
  }

  /* copy */
  fp_copy(a, c);
 802387a:	6879      	ldr	r1, [r7, #4]
 802387c:	68f8      	ldr	r0, [r7, #12]
 802387e:	f003 faa5 	bl	8026dcc <fp_copy>

  /* shift by as many digits in the bit count */
  if (b >= (int)DIGIT_BIT) {
 8023882:	68bb      	ldr	r3, [r7, #8]
 8023884:	2b1f      	cmp	r3, #31
 8023886:	dd08      	ble.n	802389a <fp_div_2d+0x62>
    fp_rshd (c, b / DIGIT_BIT);
 8023888:	68bb      	ldr	r3, [r7, #8]
 802388a:	2b00      	cmp	r3, #0
 802388c:	da00      	bge.n	8023890 <fp_div_2d+0x58>
 802388e:	331f      	adds	r3, #31
 8023890:	115b      	asrs	r3, r3, #5
 8023892:	4619      	mov	r1, r3
 8023894:	6878      	ldr	r0, [r7, #4]
 8023896:	f003 f804 	bl	80268a2 <fp_rshd>
  }

  /* shift any bit count < DIGIT_BIT */
  D = (b % DIGIT_BIT);
 802389a:	68bb      	ldr	r3, [r7, #8]
 802389c:	425a      	negs	r2, r3
 802389e:	f003 031f 	and.w	r3, r3, #31
 80238a2:	f002 021f 	and.w	r2, r2, #31
 80238a6:	bf58      	it	pl
 80238a8:	4253      	negpl	r3, r2
 80238aa:	617b      	str	r3, [r7, #20]
  if (D != 0) {
 80238ac:	697b      	ldr	r3, [r7, #20]
 80238ae:	2b00      	cmp	r3, #0
 80238b0:	d003      	beq.n	80238ba <fp_div_2d+0x82>
    fp_rshb(c, D);
 80238b2:	6979      	ldr	r1, [r7, #20]
 80238b4:	6878      	ldr	r0, [r7, #4]
 80238b6:	f002 ff70 	bl	802679a <fp_rshb>
  }

  /* get the remainder if a is not changed in calculating c */
  if (a != c && d != NULL) {
 80238ba:	68fa      	ldr	r2, [r7, #12]
 80238bc:	687b      	ldr	r3, [r7, #4]
 80238be:	429a      	cmp	r2, r3
 80238c0:	d00d      	beq.n	80238de <fp_div_2d+0xa6>
 80238c2:	683b      	ldr	r3, [r7, #0]
 80238c4:	2b00      	cmp	r3, #0
 80238c6:	d00a      	beq.n	80238de <fp_div_2d+0xa6>
    fp_mod_2d (a, b, d);
 80238c8:	683a      	ldr	r2, [r7, #0]
 80238ca:	68b9      	ldr	r1, [r7, #8]
 80238cc:	68f8      	ldr	r0, [r7, #12]
 80238ce:	f000 f863 	bl	8023998 <fp_mod_2d>
  }

  fp_clamp (c);
 80238d2:	e004      	b.n	80238de <fp_div_2d+0xa6>
 80238d4:	687b      	ldr	r3, [r7, #4]
 80238d6:	681b      	ldr	r3, [r3, #0]
 80238d8:	1e5a      	subs	r2, r3, #1
 80238da:	687b      	ldr	r3, [r7, #4]
 80238dc:	601a      	str	r2, [r3, #0]
 80238de:	687b      	ldr	r3, [r7, #4]
 80238e0:	681b      	ldr	r3, [r3, #0]
 80238e2:	2b00      	cmp	r3, #0
 80238e4:	d009      	beq.n	80238fa <fp_div_2d+0xc2>
 80238e6:	687b      	ldr	r3, [r7, #4]
 80238e8:	681b      	ldr	r3, [r3, #0]
 80238ea:	3b01      	subs	r3, #1
 80238ec:	687a      	ldr	r2, [r7, #4]
 80238ee:	3302      	adds	r3, #2
 80238f0:	009b      	lsls	r3, r3, #2
 80238f2:	4413      	add	r3, r2
 80238f4:	685b      	ldr	r3, [r3, #4]
 80238f6:	2b00      	cmp	r3, #0
 80238f8:	d0ec      	beq.n	80238d4 <fp_div_2d+0x9c>
 80238fa:	687b      	ldr	r3, [r7, #4]
 80238fc:	681b      	ldr	r3, [r3, #0]
 80238fe:	2b00      	cmp	r3, #0
 8023900:	d002      	beq.n	8023908 <fp_div_2d+0xd0>
 8023902:	687b      	ldr	r3, [r7, #4]
 8023904:	685b      	ldr	r3, [r3, #4]
 8023906:	e000      	b.n	802390a <fp_div_2d+0xd2>
 8023908:	2300      	movs	r3, #0
 802390a:	687a      	ldr	r2, [r7, #4]
 802390c:	6053      	str	r3, [r2, #4]
 802390e:	e000      	b.n	8023912 <fp_div_2d+0xda>
    return;
 8023910:	bf00      	nop
}
 8023912:	3718      	adds	r7, #24
 8023914:	46bd      	mov	sp, r7
 8023916:	bd80      	pop	{r7, pc}

08023918 <fp_mod>:

/* c = a mod b, 0 <= c < b  */
int fp_mod(fp_int *a, fp_int *b, fp_int *c)
{
 8023918:	b580      	push	{r7, lr}
 802391a:	b088      	sub	sp, #32
 802391c:	af00      	add	r7, sp, #0
 802391e:	60f8      	str	r0, [r7, #12]
 8023920:	60b9      	str	r1, [r7, #8]
 8023922:	607a      	str	r2, [r7, #4]
   fp_int *t;
#endif
   int    err;

#ifdef WOLFSSL_SMALL_STACK
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8023924:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8023928:	f7fb f9a8 	bl	801ec7c <wolfSSL_Malloc>
 802392c:	61b8      	str	r0, [r7, #24]
   if (t == NULL)
 802392e:	69bb      	ldr	r3, [r7, #24]
 8023930:	2b00      	cmp	r3, #0
 8023932:	d102      	bne.n	802393a <fp_mod+0x22>
       return FP_MEM;
 8023934:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8023938:	e02a      	b.n	8023990 <fp_mod+0x78>
#endif

   fp_init(t);
 802393a:	69b8      	ldr	r0, [r7, #24]
 802393c:	f003 f85c 	bl	80269f8 <fp_init>
   err = fp_div(a, b, NULL, t);
 8023940:	69bb      	ldr	r3, [r7, #24]
 8023942:	2200      	movs	r2, #0
 8023944:	68b9      	ldr	r1, [r7, #8]
 8023946:	68f8      	ldr	r0, [r7, #12]
 8023948:	f7ff fb3e 	bl	8022fc8 <fp_div>
 802394c:	61f8      	str	r0, [r7, #28]
   if (err == FP_OKAY) {
 802394e:	69fb      	ldr	r3, [r7, #28]
 8023950:	2b00      	cmp	r3, #0
 8023952:	d114      	bne.n	802397e <fp_mod+0x66>
      if (!fp_iszero(t) && (t->sign != b->sign)) {
 8023954:	69bb      	ldr	r3, [r7, #24]
 8023956:	681b      	ldr	r3, [r3, #0]
 8023958:	2b00      	cmp	r3, #0
 802395a:	d00c      	beq.n	8023976 <fp_mod+0x5e>
 802395c:	69bb      	ldr	r3, [r7, #24]
 802395e:	685a      	ldr	r2, [r3, #4]
 8023960:	68bb      	ldr	r3, [r7, #8]
 8023962:	685b      	ldr	r3, [r3, #4]
 8023964:	429a      	cmp	r2, r3
 8023966:	d006      	beq.n	8023976 <fp_mod+0x5e>
         err = fp_add(t, b, c);
 8023968:	687a      	ldr	r2, [r7, #4]
 802396a:	68b9      	ldr	r1, [r7, #8]
 802396c:	69b8      	ldr	r0, [r7, #24]
 802396e:	f7fe fe54 	bl	802261a <fp_add>
 8023972:	61f8      	str	r0, [r7, #28]
 8023974:	e003      	b.n	802397e <fp_mod+0x66>
      } else {
         fp_copy(t, c);
 8023976:	6879      	ldr	r1, [r7, #4]
 8023978:	69b8      	ldr	r0, [r7, #24]
 802397a:	f003 fa27 	bl	8026dcc <fp_copy>
     }
  }

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 802397e:	69bb      	ldr	r3, [r7, #24]
 8023980:	617b      	str	r3, [r7, #20]
 8023982:	697b      	ldr	r3, [r7, #20]
 8023984:	2b00      	cmp	r3, #0
 8023986:	d002      	beq.n	802398e <fp_mod+0x76>
 8023988:	6978      	ldr	r0, [r7, #20]
 802398a:	f7fb f993 	bl	801ecb4 <wolfSSL_Free>
#endif
  return err;
 802398e:	69fb      	ldr	r3, [r7, #28]
}
 8023990:	4618      	mov	r0, r3
 8023992:	3720      	adds	r7, #32
 8023994:	46bd      	mov	sp, r7
 8023996:	bd80      	pop	{r7, pc}

08023998 <fp_mod_2d>:

/* c = a mod 2**d */
void fp_mod_2d(fp_int *a, int b, fp_int *c)
{
 8023998:	b580      	push	{r7, lr}
 802399a:	b088      	sub	sp, #32
 802399c:	af00      	add	r7, sp, #0
 802399e:	60f8      	str	r0, [r7, #12]
 80239a0:	60b9      	str	r1, [r7, #8]
 80239a2:	607a      	str	r2, [r7, #4]
   unsigned int x;
   unsigned int bmax;

   /* zero if count less than or equal to zero */
   if (b <= 0) {
 80239a4:	68bb      	ldr	r3, [r7, #8]
 80239a6:	2b00      	cmp	r3, #0
 80239a8:	dc03      	bgt.n	80239b2 <fp_mod_2d+0x1a>
      fp_zero(c);
 80239aa:	6878      	ldr	r0, [r7, #4]
 80239ac:	f003 f832 	bl	8026a14 <fp_zero>
      return;
 80239b0:	e0b7      	b.n	8023b22 <fp_mod_2d+0x18a>
   }

   /* get copy of input */
   fp_copy(a, c);
 80239b2:	6879      	ldr	r1, [r7, #4]
 80239b4:	68f8      	ldr	r0, [r7, #12]
 80239b6:	f003 fa09 	bl	8026dcc <fp_copy>

   /* if 2**d is larger than we just return */
   if (c->sign == FP_ZPOS && b >= (DIGIT_BIT * a->used)) {
 80239ba:	687b      	ldr	r3, [r7, #4]
 80239bc:	685b      	ldr	r3, [r3, #4]
 80239be:	2b00      	cmp	r3, #0
 80239c0:	d106      	bne.n	80239d0 <fp_mod_2d+0x38>
 80239c2:	68fb      	ldr	r3, [r7, #12]
 80239c4:	681b      	ldr	r3, [r3, #0]
 80239c6:	015b      	lsls	r3, r3, #5
 80239c8:	68ba      	ldr	r2, [r7, #8]
 80239ca:	429a      	cmp	r2, r3
 80239cc:	f280 80a6 	bge.w	8023b1c <fp_mod_2d+0x184>
      return;
   }

   bmax = ((unsigned int)b + DIGIT_BIT - 1) / DIGIT_BIT;
 80239d0:	68bb      	ldr	r3, [r7, #8]
 80239d2:	331f      	adds	r3, #31
 80239d4:	095b      	lsrs	r3, r3, #5
 80239d6:	617b      	str	r3, [r7, #20]

   /* If a is negative and bmax is greater than or equal to FP_SIZE, then the
    * result can't fit within c. Just return. */
   if (c->sign == FP_NEG && bmax >= FP_SIZE) {
 80239d8:	687b      	ldr	r3, [r7, #4]
 80239da:	685b      	ldr	r3, [r3, #4]
 80239dc:	2b01      	cmp	r3, #1
 80239de:	d103      	bne.n	80239e8 <fp_mod_2d+0x50>
 80239e0:	697b      	ldr	r3, [r7, #20]
 80239e2:	2b87      	cmp	r3, #135	@ 0x87
 80239e4:	f200 809c 	bhi.w	8023b20 <fp_mod_2d+0x188>
      return;
   }

  /* zero digits above the last digit of the modulus */
   for (x = bmax; x < (unsigned int)c->used; x++) {
 80239e8:	697b      	ldr	r3, [r7, #20]
 80239ea:	61fb      	str	r3, [r7, #28]
 80239ec:	e009      	b.n	8023a02 <fp_mod_2d+0x6a>
    c->dp[x] = 0;
 80239ee:	687a      	ldr	r2, [r7, #4]
 80239f0:	69fb      	ldr	r3, [r7, #28]
 80239f2:	3302      	adds	r3, #2
 80239f4:	009b      	lsls	r3, r3, #2
 80239f6:	4413      	add	r3, r2
 80239f8:	2200      	movs	r2, #0
 80239fa:	605a      	str	r2, [r3, #4]
   for (x = bmax; x < (unsigned int)c->used; x++) {
 80239fc:	69fb      	ldr	r3, [r7, #28]
 80239fe:	3301      	adds	r3, #1
 8023a00:	61fb      	str	r3, [r7, #28]
 8023a02:	687b      	ldr	r3, [r7, #4]
 8023a04:	681b      	ldr	r3, [r3, #0]
 8023a06:	461a      	mov	r2, r3
 8023a08:	69fb      	ldr	r3, [r7, #28]
 8023a0a:	4293      	cmp	r3, r2
 8023a0c:	d3ef      	bcc.n	80239ee <fp_mod_2d+0x56>
  }

  if (c->sign == FP_NEG) {
 8023a0e:	687b      	ldr	r3, [r7, #4]
 8023a10:	685b      	ldr	r3, [r3, #4]
 8023a12:	2b01      	cmp	r3, #1
 8023a14:	d142      	bne.n	8023a9c <fp_mod_2d+0x104>
     fp_digit carry = 0;
 8023a16:	2300      	movs	r3, #0
 8023a18:	61bb      	str	r3, [r7, #24]
     /* negate value */
     for (x = 0; x < (unsigned int)c->used; x++) {
 8023a1a:	2300      	movs	r3, #0
 8023a1c:	61fb      	str	r3, [r7, #28]
 8023a1e:	e021      	b.n	8023a64 <fp_mod_2d+0xcc>
         fp_digit next = c->dp[x] > 0;
 8023a20:	687a      	ldr	r2, [r7, #4]
 8023a22:	69fb      	ldr	r3, [r7, #28]
 8023a24:	3302      	adds	r3, #2
 8023a26:	009b      	lsls	r3, r3, #2
 8023a28:	4413      	add	r3, r2
 8023a2a:	685b      	ldr	r3, [r3, #4]
 8023a2c:	2b00      	cmp	r3, #0
 8023a2e:	bf14      	ite	ne
 8023a30:	2301      	movne	r3, #1
 8023a32:	2300      	moveq	r3, #0
 8023a34:	b2db      	uxtb	r3, r3
 8023a36:	613b      	str	r3, [r7, #16]
         c->dp[x] = (fp_digit)0 - c->dp[x] - carry;
 8023a38:	687a      	ldr	r2, [r7, #4]
 8023a3a:	69fb      	ldr	r3, [r7, #28]
 8023a3c:	3302      	adds	r3, #2
 8023a3e:	009b      	lsls	r3, r3, #2
 8023a40:	4413      	add	r3, r2
 8023a42:	685b      	ldr	r3, [r3, #4]
 8023a44:	425a      	negs	r2, r3
 8023a46:	69bb      	ldr	r3, [r7, #24]
 8023a48:	1ad2      	subs	r2, r2, r3
 8023a4a:	6879      	ldr	r1, [r7, #4]
 8023a4c:	69fb      	ldr	r3, [r7, #28]
 8023a4e:	3302      	adds	r3, #2
 8023a50:	009b      	lsls	r3, r3, #2
 8023a52:	440b      	add	r3, r1
 8023a54:	605a      	str	r2, [r3, #4]
         carry |= next;
 8023a56:	69ba      	ldr	r2, [r7, #24]
 8023a58:	693b      	ldr	r3, [r7, #16]
 8023a5a:	4313      	orrs	r3, r2
 8023a5c:	61bb      	str	r3, [r7, #24]
     for (x = 0; x < (unsigned int)c->used; x++) {
 8023a5e:	69fb      	ldr	r3, [r7, #28]
 8023a60:	3301      	adds	r3, #1
 8023a62:	61fb      	str	r3, [r7, #28]
 8023a64:	687b      	ldr	r3, [r7, #4]
 8023a66:	681b      	ldr	r3, [r3, #0]
 8023a68:	461a      	mov	r2, r3
 8023a6a:	69fb      	ldr	r3, [r7, #28]
 8023a6c:	4293      	cmp	r3, r2
 8023a6e:	d3d7      	bcc.n	8023a20 <fp_mod_2d+0x88>
     }
     for (; x < bmax; x++) {
 8023a70:	e00a      	b.n	8023a88 <fp_mod_2d+0xf0>
         c->dp[x] = (fp_digit)0 - carry;
 8023a72:	69bb      	ldr	r3, [r7, #24]
 8023a74:	425a      	negs	r2, r3
 8023a76:	6879      	ldr	r1, [r7, #4]
 8023a78:	69fb      	ldr	r3, [r7, #28]
 8023a7a:	3302      	adds	r3, #2
 8023a7c:	009b      	lsls	r3, r3, #2
 8023a7e:	440b      	add	r3, r1
 8023a80:	605a      	str	r2, [r3, #4]
     for (; x < bmax; x++) {
 8023a82:	69fb      	ldr	r3, [r7, #28]
 8023a84:	3301      	adds	r3, #1
 8023a86:	61fb      	str	r3, [r7, #28]
 8023a88:	69fa      	ldr	r2, [r7, #28]
 8023a8a:	697b      	ldr	r3, [r7, #20]
 8023a8c:	429a      	cmp	r2, r3
 8023a8e:	d3f0      	bcc.n	8023a72 <fp_mod_2d+0xda>
     }
     c->used = (int)bmax;
 8023a90:	697a      	ldr	r2, [r7, #20]
 8023a92:	687b      	ldr	r3, [r7, #4]
 8023a94:	601a      	str	r2, [r3, #0]
     c->sign = FP_ZPOS;
 8023a96:	687b      	ldr	r3, [r7, #4]
 8023a98:	2200      	movs	r2, #0
 8023a9a:	605a      	str	r2, [r3, #4]
  }

  /* clear the digit that is not completely outside/inside the modulus */
  x = DIGIT_BIT - (b % DIGIT_BIT);
 8023a9c:	68bb      	ldr	r3, [r7, #8]
 8023a9e:	425a      	negs	r2, r3
 8023aa0:	f003 031f 	and.w	r3, r3, #31
 8023aa4:	f002 021f 	and.w	r2, r2, #31
 8023aa8:	bf58      	it	pl
 8023aaa:	4253      	negpl	r3, r2
 8023aac:	f1c3 0320 	rsb	r3, r3, #32
 8023ab0:	61fb      	str	r3, [r7, #28]
  if (x != DIGIT_BIT) {
 8023ab2:	69fb      	ldr	r3, [r7, #28]
 8023ab4:	2b20      	cmp	r3, #32
 8023ab6:	d018      	beq.n	8023aea <fp_mod_2d+0x152>
     c->dp[bmax - 1] &= ~((fp_digit)0) >> x;
 8023ab8:	697b      	ldr	r3, [r7, #20]
 8023aba:	3b01      	subs	r3, #1
 8023abc:	687a      	ldr	r2, [r7, #4]
 8023abe:	3302      	adds	r3, #2
 8023ac0:	009b      	lsls	r3, r3, #2
 8023ac2:	4413      	add	r3, r2
 8023ac4:	6859      	ldr	r1, [r3, #4]
 8023ac6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8023aca:	69fb      	ldr	r3, [r7, #28]
 8023acc:	40da      	lsrs	r2, r3
 8023ace:	697b      	ldr	r3, [r7, #20]
 8023ad0:	3b01      	subs	r3, #1
 8023ad2:	400a      	ands	r2, r1
 8023ad4:	6879      	ldr	r1, [r7, #4]
 8023ad6:	3302      	adds	r3, #2
 8023ad8:	009b      	lsls	r3, r3, #2
 8023ada:	440b      	add	r3, r1
 8023adc:	605a      	str	r2, [r3, #4]
  }

  fp_clamp (c);
 8023ade:	e004      	b.n	8023aea <fp_mod_2d+0x152>
 8023ae0:	687b      	ldr	r3, [r7, #4]
 8023ae2:	681b      	ldr	r3, [r3, #0]
 8023ae4:	1e5a      	subs	r2, r3, #1
 8023ae6:	687b      	ldr	r3, [r7, #4]
 8023ae8:	601a      	str	r2, [r3, #0]
 8023aea:	687b      	ldr	r3, [r7, #4]
 8023aec:	681b      	ldr	r3, [r3, #0]
 8023aee:	2b00      	cmp	r3, #0
 8023af0:	d009      	beq.n	8023b06 <fp_mod_2d+0x16e>
 8023af2:	687b      	ldr	r3, [r7, #4]
 8023af4:	681b      	ldr	r3, [r3, #0]
 8023af6:	3b01      	subs	r3, #1
 8023af8:	687a      	ldr	r2, [r7, #4]
 8023afa:	3302      	adds	r3, #2
 8023afc:	009b      	lsls	r3, r3, #2
 8023afe:	4413      	add	r3, r2
 8023b00:	685b      	ldr	r3, [r3, #4]
 8023b02:	2b00      	cmp	r3, #0
 8023b04:	d0ec      	beq.n	8023ae0 <fp_mod_2d+0x148>
 8023b06:	687b      	ldr	r3, [r7, #4]
 8023b08:	681b      	ldr	r3, [r3, #0]
 8023b0a:	2b00      	cmp	r3, #0
 8023b0c:	d002      	beq.n	8023b14 <fp_mod_2d+0x17c>
 8023b0e:	687b      	ldr	r3, [r7, #4]
 8023b10:	685b      	ldr	r3, [r3, #4]
 8023b12:	e000      	b.n	8023b16 <fp_mod_2d+0x17e>
 8023b14:	2300      	movs	r3, #0
 8023b16:	687a      	ldr	r2, [r7, #4]
 8023b18:	6053      	str	r3, [r2, #4]
 8023b1a:	e002      	b.n	8023b22 <fp_mod_2d+0x18a>
      return;
 8023b1c:	bf00      	nop
 8023b1e:	e000      	b.n	8023b22 <fp_mod_2d+0x18a>
      return;
 8023b20:	bf00      	nop
}
 8023b22:	3720      	adds	r7, #32
 8023b24:	46bd      	mov	sp, r7
 8023b26:	bd80      	pop	{r7, pc}

08023b28 <fp_invmod_slow>:

static int fp_invmod_slow (fp_int * a, fp_int * b, fp_int * c)
{
 8023b28:	b580      	push	{r7, lr}
 8023b2a:	b09e      	sub	sp, #120	@ 0x78
 8023b2c:	af00      	add	r7, sp, #0
 8023b2e:	60f8      	str	r0, [r7, #12]
 8023b30:	60b9      	str	r1, [r7, #8]
 8023b32:	607a      	str	r2, [r7, #4]
  fp_int  *x, *y, *u, *v, *A, *B, *C, *D;
#endif
  int     err;

  /* b cannot be negative */
  if (b->sign == FP_NEG || fp_iszero(b) == FP_YES) {
 8023b34:	68bb      	ldr	r3, [r7, #8]
 8023b36:	685b      	ldr	r3, [r3, #4]
 8023b38:	2b01      	cmp	r3, #1
 8023b3a:	d003      	beq.n	8023b44 <fp_invmod_slow+0x1c>
 8023b3c:	68bb      	ldr	r3, [r7, #8]
 8023b3e:	681b      	ldr	r3, [r3, #0]
 8023b40:	2b00      	cmp	r3, #0
 8023b42:	d102      	bne.n	8023b4a <fp_invmod_slow+0x22>
    return FP_VAL;
 8023b44:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023b48:	e239      	b.n	8023fbe <fp_invmod_slow+0x496>
  }
  if (fp_iszero(a) == FP_YES) {
 8023b4a:	68fb      	ldr	r3, [r7, #12]
 8023b4c:	681b      	ldr	r3, [r3, #0]
 8023b4e:	2b00      	cmp	r3, #0
 8023b50:	d102      	bne.n	8023b58 <fp_invmod_slow+0x30>
    return FP_VAL;
 8023b52:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023b56:	e232      	b.n	8023fbe <fp_invmod_slow+0x496>
  }

#ifdef WOLFSSL_SMALL_STACK
  x = (fp_int*)XMALLOC(sizeof(fp_int) * 8, NULL, DYNAMIC_TYPE_BIGINT);
 8023b58:	f44f 508b 	mov.w	r0, #4448	@ 0x1160
 8023b5c:	f7fb f88e 	bl	801ec7c <wolfSSL_Malloc>
 8023b60:	6778      	str	r0, [r7, #116]	@ 0x74
  if (x == NULL) {
 8023b62:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b64:	2b00      	cmp	r3, #0
 8023b66:	d102      	bne.n	8023b6e <fp_invmod_slow+0x46>
      return FP_MEM;
 8023b68:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8023b6c:	e227      	b.n	8023fbe <fp_invmod_slow+0x496>
  }
  y = &x[1]; u = &x[2]; v = &x[3]; A = &x[4]; B = &x[5]; C = &x[6]; D = &x[7];
 8023b6e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b70:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8023b74:	673b      	str	r3, [r7, #112]	@ 0x70
 8023b76:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b78:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8023b7c:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8023b7e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b80:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8023b84:	66bb      	str	r3, [r7, #104]	@ 0x68
 8023b86:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b88:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8023b8c:	667b      	str	r3, [r7, #100]	@ 0x64
 8023b8e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b90:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 8023b94:	663b      	str	r3, [r7, #96]	@ 0x60
 8023b96:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b98:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 8023b9c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8023b9e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023ba0:	f603 7334 	addw	r3, r3, #3892	@ 0xf34
 8023ba4:	65bb      	str	r3, [r7, #88]	@ 0x58
#endif

  /* init temps */
  fp_init(x);    fp_init(y);
 8023ba6:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8023ba8:	f002 ff26 	bl	80269f8 <fp_init>
 8023bac:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8023bae:	f002 ff23 	bl	80269f8 <fp_init>
  fp_init(u);    fp_init(v);
 8023bb2:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023bb4:	f002 ff20 	bl	80269f8 <fp_init>
 8023bb8:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023bba:	f002 ff1d 	bl	80269f8 <fp_init>
  fp_init(A);    fp_init(B);
 8023bbe:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023bc0:	f002 ff1a 	bl	80269f8 <fp_init>
 8023bc4:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8023bc6:	f002 ff17 	bl	80269f8 <fp_init>
  fp_init(C);    fp_init(D);
 8023bca:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023bcc:	f002 ff14 	bl	80269f8 <fp_init>
 8023bd0:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023bd2:	f002 ff11 	bl	80269f8 <fp_init>

  /* x = a, y = b */
  if ((err = fp_mod(a, b, x)) != FP_OKAY) {
 8023bd6:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8023bd8:	68b9      	ldr	r1, [r7, #8]
 8023bda:	68f8      	ldr	r0, [r7, #12]
 8023bdc:	f7ff fe9c 	bl	8023918 <fp_mod>
 8023be0:	6578      	str	r0, [r7, #84]	@ 0x54
 8023be2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023be4:	2b00      	cmp	r3, #0
 8023be6:	d009      	beq.n	8023bfc <fp_invmod_slow+0xd4>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023be8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023bea:	613b      	str	r3, [r7, #16]
 8023bec:	693b      	ldr	r3, [r7, #16]
 8023bee:	2b00      	cmp	r3, #0
 8023bf0:	d002      	beq.n	8023bf8 <fp_invmod_slow+0xd0>
 8023bf2:	6938      	ldr	r0, [r7, #16]
 8023bf4:	f7fb f85e 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return err;
 8023bf8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023bfa:	e1e0      	b.n	8023fbe <fp_invmod_slow+0x496>
  }
  fp_copy(b, y);
 8023bfc:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8023bfe:	68b8      	ldr	r0, [r7, #8]
 8023c00:	f003 f8e4 	bl	8026dcc <fp_copy>

  if (fp_iszero(x) == FP_YES) {
 8023c04:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c06:	681b      	ldr	r3, [r3, #0]
 8023c08:	2b00      	cmp	r3, #0
 8023c0a:	d10a      	bne.n	8023c22 <fp_invmod_slow+0xfa>
    /* invmod doesn't exist for this a and b */
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023c0c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c0e:	617b      	str	r3, [r7, #20]
 8023c10:	697b      	ldr	r3, [r7, #20]
 8023c12:	2b00      	cmp	r3, #0
 8023c14:	d002      	beq.n	8023c1c <fp_invmod_slow+0xf4>
 8023c16:	6978      	ldr	r0, [r7, #20]
 8023c18:	f7fb f84c 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023c1c:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023c20:	e1cd      	b.n	8023fbe <fp_invmod_slow+0x496>
  }

  /* 2. [modified] if x,y are both even then return an error! */
  if (fp_iseven(x) == FP_YES && fp_iseven(y) == FP_YES) {
 8023c22:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c24:	681b      	ldr	r3, [r3, #0]
 8023c26:	2b00      	cmp	r3, #0
 8023c28:	dd07      	ble.n	8023c3a <fp_invmod_slow+0x112>
 8023c2a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c2c:	68db      	ldr	r3, [r3, #12]
 8023c2e:	f003 0301 	and.w	r3, r3, #1
 8023c32:	2b00      	cmp	r3, #0
 8023c34:	d101      	bne.n	8023c3a <fp_invmod_slow+0x112>
 8023c36:	2301      	movs	r3, #1
 8023c38:	e000      	b.n	8023c3c <fp_invmod_slow+0x114>
 8023c3a:	2300      	movs	r3, #0
 8023c3c:	2b01      	cmp	r3, #1
 8023c3e:	d119      	bne.n	8023c74 <fp_invmod_slow+0x14c>
 8023c40:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8023c42:	681b      	ldr	r3, [r3, #0]
 8023c44:	2b00      	cmp	r3, #0
 8023c46:	dd07      	ble.n	8023c58 <fp_invmod_slow+0x130>
 8023c48:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8023c4a:	68db      	ldr	r3, [r3, #12]
 8023c4c:	f003 0301 	and.w	r3, r3, #1
 8023c50:	2b00      	cmp	r3, #0
 8023c52:	d101      	bne.n	8023c58 <fp_invmod_slow+0x130>
 8023c54:	2301      	movs	r3, #1
 8023c56:	e000      	b.n	8023c5a <fp_invmod_slow+0x132>
 8023c58:	2300      	movs	r3, #0
 8023c5a:	2b01      	cmp	r3, #1
 8023c5c:	d10a      	bne.n	8023c74 <fp_invmod_slow+0x14c>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023c5e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c60:	653b      	str	r3, [r7, #80]	@ 0x50
 8023c62:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8023c64:	2b00      	cmp	r3, #0
 8023c66:	d002      	beq.n	8023c6e <fp_invmod_slow+0x146>
 8023c68:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8023c6a:	f7fb f823 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023c6e:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023c72:	e1a4      	b.n	8023fbe <fp_invmod_slow+0x496>
  }

  /* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
  fp_copy (x, u);
 8023c74:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8023c76:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8023c78:	f003 f8a8 	bl	8026dcc <fp_copy>
  fp_copy (y, v);
 8023c7c:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023c7e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8023c80:	f003 f8a4 	bl	8026dcc <fp_copy>
  fp_set (A, 1);
 8023c84:	2101      	movs	r1, #1
 8023c86:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023c88:	f002 fc87 	bl	802659a <fp_set>
  fp_set (D, 1);
 8023c8c:	2101      	movs	r1, #1
 8023c8e:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023c90:	f002 fc83 	bl	802659a <fp_set>

top:
  /* 4.  while u is even do */
  while (fp_iseven (u) == FP_YES) {
 8023c94:	e04f      	b.n	8023d36 <fp_invmod_slow+0x20e>
    /* 4.1 u = u/2 */
    fp_div_2 (u, u);
 8023c96:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8023c98:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023c9a:	f7ff fc8a 	bl	80235b2 <fp_div_2>

    /* 4.2 if A or B is odd then */
    if (fp_isodd (A) == FP_YES || fp_isodd (B) == FP_YES) {
 8023c9e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8023ca0:	681b      	ldr	r3, [r3, #0]
 8023ca2:	2b00      	cmp	r3, #0
 8023ca4:	dd07      	ble.n	8023cb6 <fp_invmod_slow+0x18e>
 8023ca6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8023ca8:	68db      	ldr	r3, [r3, #12]
 8023caa:	f003 0301 	and.w	r3, r3, #1
 8023cae:	2b00      	cmp	r3, #0
 8023cb0:	d001      	beq.n	8023cb6 <fp_invmod_slow+0x18e>
 8023cb2:	2301      	movs	r3, #1
 8023cb4:	e000      	b.n	8023cb8 <fp_invmod_slow+0x190>
 8023cb6:	2300      	movs	r3, #0
 8023cb8:	2b01      	cmp	r3, #1
 8023cba:	d00e      	beq.n	8023cda <fp_invmod_slow+0x1b2>
 8023cbc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8023cbe:	681b      	ldr	r3, [r3, #0]
 8023cc0:	2b00      	cmp	r3, #0
 8023cc2:	dd07      	ble.n	8023cd4 <fp_invmod_slow+0x1ac>
 8023cc4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8023cc6:	68db      	ldr	r3, [r3, #12]
 8023cc8:	f003 0301 	and.w	r3, r3, #1
 8023ccc:	2b00      	cmp	r3, #0
 8023cce:	d001      	beq.n	8023cd4 <fp_invmod_slow+0x1ac>
 8023cd0:	2301      	movs	r3, #1
 8023cd2:	e000      	b.n	8023cd6 <fp_invmod_slow+0x1ae>
 8023cd4:	2300      	movs	r3, #0
 8023cd6:	2b01      	cmp	r3, #1
 8023cd8:	d125      	bne.n	8023d26 <fp_invmod_slow+0x1fe>
      /* A = (A+y)/2, B = (B-x)/2 */
      err = fp_add (A, y, A);
 8023cda:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8023cdc:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8023cde:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023ce0:	f7fe fc9b 	bl	802261a <fp_add>
 8023ce4:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 8023ce6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023ce8:	2b00      	cmp	r3, #0
 8023cea:	d009      	beq.n	8023d00 <fp_invmod_slow+0x1d8>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023cec:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023cee:	61bb      	str	r3, [r7, #24]
 8023cf0:	69bb      	ldr	r3, [r7, #24]
 8023cf2:	2b00      	cmp	r3, #0
 8023cf4:	d002      	beq.n	8023cfc <fp_invmod_slow+0x1d4>
 8023cf6:	69b8      	ldr	r0, [r7, #24]
 8023cf8:	f7fa ffdc 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 8023cfc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023cfe:	e15e      	b.n	8023fbe <fp_invmod_slow+0x496>
      }
      err = fp_sub (B, x, B);
 8023d00:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8023d02:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8023d04:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8023d06:	f7fe fd6a 	bl	80227de <fp_sub>
 8023d0a:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 8023d0c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023d0e:	2b00      	cmp	r3, #0
 8023d10:	d009      	beq.n	8023d26 <fp_invmod_slow+0x1fe>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023d12:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023d14:	61fb      	str	r3, [r7, #28]
 8023d16:	69fb      	ldr	r3, [r7, #28]
 8023d18:	2b00      	cmp	r3, #0
 8023d1a:	d002      	beq.n	8023d22 <fp_invmod_slow+0x1fa>
 8023d1c:	69f8      	ldr	r0, [r7, #28]
 8023d1e:	f7fa ffc9 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 8023d22:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023d24:	e14b      	b.n	8023fbe <fp_invmod_slow+0x496>
      }
    }
    /* A = A/2, B = B/2 */
    fp_div_2 (A, A);
 8023d26:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8023d28:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023d2a:	f7ff fc42 	bl	80235b2 <fp_div_2>
    fp_div_2 (B, B);
 8023d2e:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8023d30:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8023d32:	f7ff fc3e 	bl	80235b2 <fp_div_2>
  while (fp_iseven (u) == FP_YES) {
 8023d36:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023d38:	681b      	ldr	r3, [r3, #0]
 8023d3a:	2b00      	cmp	r3, #0
 8023d3c:	dd07      	ble.n	8023d4e <fp_invmod_slow+0x226>
 8023d3e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023d40:	68db      	ldr	r3, [r3, #12]
 8023d42:	f003 0301 	and.w	r3, r3, #1
 8023d46:	2b00      	cmp	r3, #0
 8023d48:	d101      	bne.n	8023d4e <fp_invmod_slow+0x226>
 8023d4a:	2301      	movs	r3, #1
 8023d4c:	e000      	b.n	8023d50 <fp_invmod_slow+0x228>
 8023d4e:	2300      	movs	r3, #0
 8023d50:	2b01      	cmp	r3, #1
 8023d52:	d0a0      	beq.n	8023c96 <fp_invmod_slow+0x16e>
  }

  /* 5.  while v is even do */
  while (fp_iseven (v) == FP_YES) {
 8023d54:	e04f      	b.n	8023df6 <fp_invmod_slow+0x2ce>
    /* 5.1 v = v/2 */
    fp_div_2 (v, v);
 8023d56:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023d58:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023d5a:	f7ff fc2a 	bl	80235b2 <fp_div_2>

    /* 5.2 if C or D is odd then */
    if (fp_isodd (C) == FP_YES || fp_isodd (D) == FP_YES) {
 8023d5e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d60:	681b      	ldr	r3, [r3, #0]
 8023d62:	2b00      	cmp	r3, #0
 8023d64:	dd07      	ble.n	8023d76 <fp_invmod_slow+0x24e>
 8023d66:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d68:	68db      	ldr	r3, [r3, #12]
 8023d6a:	f003 0301 	and.w	r3, r3, #1
 8023d6e:	2b00      	cmp	r3, #0
 8023d70:	d001      	beq.n	8023d76 <fp_invmod_slow+0x24e>
 8023d72:	2301      	movs	r3, #1
 8023d74:	e000      	b.n	8023d78 <fp_invmod_slow+0x250>
 8023d76:	2300      	movs	r3, #0
 8023d78:	2b01      	cmp	r3, #1
 8023d7a:	d00e      	beq.n	8023d9a <fp_invmod_slow+0x272>
 8023d7c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8023d7e:	681b      	ldr	r3, [r3, #0]
 8023d80:	2b00      	cmp	r3, #0
 8023d82:	dd07      	ble.n	8023d94 <fp_invmod_slow+0x26c>
 8023d84:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8023d86:	68db      	ldr	r3, [r3, #12]
 8023d88:	f003 0301 	and.w	r3, r3, #1
 8023d8c:	2b00      	cmp	r3, #0
 8023d8e:	d001      	beq.n	8023d94 <fp_invmod_slow+0x26c>
 8023d90:	2301      	movs	r3, #1
 8023d92:	e000      	b.n	8023d96 <fp_invmod_slow+0x26e>
 8023d94:	2300      	movs	r3, #0
 8023d96:	2b01      	cmp	r3, #1
 8023d98:	d125      	bne.n	8023de6 <fp_invmod_slow+0x2be>
      /* C = (C+y)/2, D = (D-x)/2 */
      err = fp_add (C, y, C);
 8023d9a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023d9c:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8023d9e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023da0:	f7fe fc3b 	bl	802261a <fp_add>
 8023da4:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 8023da6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023da8:	2b00      	cmp	r3, #0
 8023daa:	d009      	beq.n	8023dc0 <fp_invmod_slow+0x298>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023dac:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023dae:	623b      	str	r3, [r7, #32]
 8023db0:	6a3b      	ldr	r3, [r7, #32]
 8023db2:	2b00      	cmp	r3, #0
 8023db4:	d002      	beq.n	8023dbc <fp_invmod_slow+0x294>
 8023db6:	6a38      	ldr	r0, [r7, #32]
 8023db8:	f7fa ff7c 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 8023dbc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023dbe:	e0fe      	b.n	8023fbe <fp_invmod_slow+0x496>
      }
      err = fp_sub (D, x, D);
 8023dc0:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8023dc2:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8023dc4:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023dc6:	f7fe fd0a 	bl	80227de <fp_sub>
 8023dca:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 8023dcc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023dce:	2b00      	cmp	r3, #0
 8023dd0:	d009      	beq.n	8023de6 <fp_invmod_slow+0x2be>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023dd2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023dd4:	627b      	str	r3, [r7, #36]	@ 0x24
 8023dd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023dd8:	2b00      	cmp	r3, #0
 8023dda:	d002      	beq.n	8023de2 <fp_invmod_slow+0x2ba>
 8023ddc:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8023dde:	f7fa ff69 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 8023de2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023de4:	e0eb      	b.n	8023fbe <fp_invmod_slow+0x496>
      }
    }
    /* C = C/2, D = D/2 */
    fp_div_2 (C, C);
 8023de6:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023de8:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023dea:	f7ff fbe2 	bl	80235b2 <fp_div_2>
    fp_div_2 (D, D);
 8023dee:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 8023df0:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023df2:	f7ff fbde 	bl	80235b2 <fp_div_2>
  while (fp_iseven (v) == FP_YES) {
 8023df6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023df8:	681b      	ldr	r3, [r3, #0]
 8023dfa:	2b00      	cmp	r3, #0
 8023dfc:	dd07      	ble.n	8023e0e <fp_invmod_slow+0x2e6>
 8023dfe:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023e00:	68db      	ldr	r3, [r3, #12]
 8023e02:	f003 0301 	and.w	r3, r3, #1
 8023e06:	2b00      	cmp	r3, #0
 8023e08:	d101      	bne.n	8023e0e <fp_invmod_slow+0x2e6>
 8023e0a:	2301      	movs	r3, #1
 8023e0c:	e000      	b.n	8023e10 <fp_invmod_slow+0x2e8>
 8023e0e:	2300      	movs	r3, #0
 8023e10:	2b01      	cmp	r3, #1
 8023e12:	d0a0      	beq.n	8023d56 <fp_invmod_slow+0x22e>
  }

  /* 6.  if u >= v then */
  if (fp_cmp (u, v) != FP_LT) {
 8023e14:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023e16:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023e18:	f001 ffd4 	bl	8025dc4 <fp_cmp>
 8023e1c:	4603      	mov	r3, r0
 8023e1e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023e22:	d038      	beq.n	8023e96 <fp_invmod_slow+0x36e>
    /* u = u - v, A = A - C, B = B - D */
    err = fp_sub (u, v, u);
 8023e24:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8023e26:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023e28:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023e2a:	f7fe fcd8 	bl	80227de <fp_sub>
 8023e2e:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023e30:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023e32:	2b00      	cmp	r3, #0
 8023e34:	d009      	beq.n	8023e4a <fp_invmod_slow+0x322>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023e36:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023e38:	63bb      	str	r3, [r7, #56]	@ 0x38
 8023e3a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8023e3c:	2b00      	cmp	r3, #0
 8023e3e:	d002      	beq.n	8023e46 <fp_invmod_slow+0x31e>
 8023e40:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8023e42:	f7fa ff37 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8023e46:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023e48:	e0b9      	b.n	8023fbe <fp_invmod_slow+0x496>
    }
    err = fp_sub (A, C, A);
 8023e4a:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8023e4c:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023e4e:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023e50:	f7fe fcc5 	bl	80227de <fp_sub>
 8023e54:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023e56:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023e58:	2b00      	cmp	r3, #0
 8023e5a:	d009      	beq.n	8023e70 <fp_invmod_slow+0x348>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023e5c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023e5e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8023e60:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8023e62:	2b00      	cmp	r3, #0
 8023e64:	d002      	beq.n	8023e6c <fp_invmod_slow+0x344>
 8023e66:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8023e68:	f7fa ff24 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8023e6c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023e6e:	e0a6      	b.n	8023fbe <fp_invmod_slow+0x496>
    }
    err = fp_sub (B, D, B);
 8023e70:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8023e72:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 8023e74:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8023e76:	f7fe fcb2 	bl	80227de <fp_sub>
 8023e7a:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023e7c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023e7e:	2b00      	cmp	r3, #0
 8023e80:	d042      	beq.n	8023f08 <fp_invmod_slow+0x3e0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023e82:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023e84:	643b      	str	r3, [r7, #64]	@ 0x40
 8023e86:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8023e88:	2b00      	cmp	r3, #0
 8023e8a:	d002      	beq.n	8023e92 <fp_invmod_slow+0x36a>
 8023e8c:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8023e8e:	f7fa ff11 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8023e92:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023e94:	e093      	b.n	8023fbe <fp_invmod_slow+0x496>
    }
  } else {
    /* v - v - u, C = C - A, D = D - B */
    err = fp_sub (v, u, v);
 8023e96:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023e98:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8023e9a:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023e9c:	f7fe fc9f 	bl	80227de <fp_sub>
 8023ea0:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023ea2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023ea4:	2b00      	cmp	r3, #0
 8023ea6:	d009      	beq.n	8023ebc <fp_invmod_slow+0x394>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023ea8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023eaa:	647b      	str	r3, [r7, #68]	@ 0x44
 8023eac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023eae:	2b00      	cmp	r3, #0
 8023eb0:	d002      	beq.n	8023eb8 <fp_invmod_slow+0x390>
 8023eb2:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8023eb4:	f7fa fefe 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8023eb8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023eba:	e080      	b.n	8023fbe <fp_invmod_slow+0x496>
    }
    err = fp_sub (C, A, C);
 8023ebc:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023ebe:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8023ec0:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023ec2:	f7fe fc8c 	bl	80227de <fp_sub>
 8023ec6:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023ec8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023eca:	2b00      	cmp	r3, #0
 8023ecc:	d009      	beq.n	8023ee2 <fp_invmod_slow+0x3ba>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023ece:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023ed0:	64bb      	str	r3, [r7, #72]	@ 0x48
 8023ed2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8023ed4:	2b00      	cmp	r3, #0
 8023ed6:	d002      	beq.n	8023ede <fp_invmod_slow+0x3b6>
 8023ed8:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023eda:	f7fa feeb 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8023ede:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023ee0:	e06d      	b.n	8023fbe <fp_invmod_slow+0x496>
    }
    err = fp_sub (D, B, D);
 8023ee2:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8023ee4:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8023ee6:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023ee8:	f7fe fc79 	bl	80227de <fp_sub>
 8023eec:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023eee:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023ef0:	2b00      	cmp	r3, #0
 8023ef2:	d009      	beq.n	8023f08 <fp_invmod_slow+0x3e0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023ef4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023ef6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8023ef8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8023efa:	2b00      	cmp	r3, #0
 8023efc:	d002      	beq.n	8023f04 <fp_invmod_slow+0x3dc>
 8023efe:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023f00:	f7fa fed8 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8023f04:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023f06:	e05a      	b.n	8023fbe <fp_invmod_slow+0x496>
    }
  }

  /* if not zero goto step 4 */
  if (fp_iszero (u) == FP_NO)
 8023f08:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023f0a:	681b      	ldr	r3, [r3, #0]
 8023f0c:	2b00      	cmp	r3, #0
 8023f0e:	d000      	beq.n	8023f12 <fp_invmod_slow+0x3ea>
    goto top;
 8023f10:	e6c0      	b.n	8023c94 <fp_invmod_slow+0x16c>

  /* now a = C, b = D, gcd == g*v */

  /* if v != 1 then there is no inverse */
  if (fp_cmp_d (v, 1) != FP_EQ) {
 8023f12:	2101      	movs	r1, #1
 8023f14:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023f16:	f001 ff82 	bl	8025e1e <fp_cmp_d>
 8023f1a:	4603      	mov	r3, r0
 8023f1c:	2b00      	cmp	r3, #0
 8023f1e:	d01d      	beq.n	8023f5c <fp_invmod_slow+0x434>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f20:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023f22:	62bb      	str	r3, [r7, #40]	@ 0x28
 8023f24:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023f26:	2b00      	cmp	r3, #0
 8023f28:	d002      	beq.n	8023f30 <fp_invmod_slow+0x408>
 8023f2a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8023f2c:	f7fa fec2 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023f30:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023f34:	e043      	b.n	8023fbe <fp_invmod_slow+0x496>
  }

  /* if its too low */
  while (fp_cmp_d(C, 0) == FP_LT) {
    err = fp_add(C, b, C);
 8023f36:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023f38:	68b9      	ldr	r1, [r7, #8]
 8023f3a:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023f3c:	f7fe fb6d 	bl	802261a <fp_add>
 8023f40:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023f42:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023f44:	2b00      	cmp	r3, #0
 8023f46:	d009      	beq.n	8023f5c <fp_invmod_slow+0x434>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f48:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023f4a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8023f4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023f4e:	2b00      	cmp	r3, #0
 8023f50:	d002      	beq.n	8023f58 <fp_invmod_slow+0x430>
 8023f52:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8023f54:	f7fa feae 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8023f58:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023f5a:	e030      	b.n	8023fbe <fp_invmod_slow+0x496>
  while (fp_cmp_d(C, 0) == FP_LT) {
 8023f5c:	2100      	movs	r1, #0
 8023f5e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023f60:	f001 ff5d 	bl	8025e1e <fp_cmp_d>
 8023f64:	4603      	mov	r3, r0
 8023f66:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023f6a:	d0e4      	beq.n	8023f36 <fp_invmod_slow+0x40e>
    }
  }

  /* too big */
  while (fp_cmp_mag(C, b) != FP_LT) {
 8023f6c:	e012      	b.n	8023f94 <fp_invmod_slow+0x46c>
    err = fp_sub(C, b, C);
 8023f6e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023f70:	68b9      	ldr	r1, [r7, #8]
 8023f72:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023f74:	f7fe fc33 	bl	80227de <fp_sub>
 8023f78:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023f7a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023f7c:	2b00      	cmp	r3, #0
 8023f7e:	d009      	beq.n	8023f94 <fp_invmod_slow+0x46c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f80:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023f82:	633b      	str	r3, [r7, #48]	@ 0x30
 8023f84:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023f86:	2b00      	cmp	r3, #0
 8023f88:	d002      	beq.n	8023f90 <fp_invmod_slow+0x468>
 8023f8a:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8023f8c:	f7fa fe92 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8023f90:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023f92:	e014      	b.n	8023fbe <fp_invmod_slow+0x496>
  while (fp_cmp_mag(C, b) != FP_LT) {
 8023f94:	68b9      	ldr	r1, [r7, #8]
 8023f96:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023f98:	f001 ff79 	bl	8025e8e <fp_cmp_mag>
 8023f9c:	4603      	mov	r3, r0
 8023f9e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023fa2:	d1e4      	bne.n	8023f6e <fp_invmod_slow+0x446>
    }
  }

  /* C is now the inverse */
  fp_copy(C, c);
 8023fa4:	6879      	ldr	r1, [r7, #4]
 8023fa6:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023fa8:	f002 ff10 	bl	8026dcc <fp_copy>
#ifdef WOLFSSL_SMALL_STACK
  XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023fac:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023fae:	637b      	str	r3, [r7, #52]	@ 0x34
 8023fb0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023fb2:	2b00      	cmp	r3, #0
 8023fb4:	d002      	beq.n	8023fbc <fp_invmod_slow+0x494>
 8023fb6:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8023fb8:	f7fa fe7c 	bl	801ecb4 <wolfSSL_Free>
#endif
  return FP_OKAY;
 8023fbc:	2300      	movs	r3, #0
}
 8023fbe:	4618      	mov	r0, r3
 8023fc0:	3778      	adds	r7, #120	@ 0x78
 8023fc2:	46bd      	mov	sp, r7
 8023fc4:	bd80      	pop	{r7, pc}

08023fc6 <fp_invmod>:

/* c = 1/a (mod b) for odd b only */
int fp_invmod(fp_int *a, fp_int *b, fp_int *c)
{
 8023fc6:	b580      	push	{r7, lr}
 8023fc8:	b098      	sub	sp, #96	@ 0x60
 8023fca:	af00      	add	r7, sp, #0
 8023fcc:	60f8      	str	r0, [r7, #12]
 8023fce:	60b9      	str	r1, [r7, #8]
 8023fd0:	607a      	str	r2, [r7, #4]
#else
  fp_int  *x, *y, *u, *v, *B, *D;
#endif
  int     err;

  if (b->sign == FP_NEG || fp_iszero(b) == FP_YES) {
 8023fd2:	68bb      	ldr	r3, [r7, #8]
 8023fd4:	685b      	ldr	r3, [r3, #4]
 8023fd6:	2b01      	cmp	r3, #1
 8023fd8:	d003      	beq.n	8023fe2 <fp_invmod+0x1c>
 8023fda:	68bb      	ldr	r3, [r7, #8]
 8023fdc:	681b      	ldr	r3, [r3, #0]
 8023fde:	2b00      	cmp	r3, #0
 8023fe0:	d102      	bne.n	8023fe8 <fp_invmod+0x22>
    return FP_VAL;
 8023fe2:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023fe6:	e1ad      	b.n	8024344 <fp_invmod+0x37e>
  }

  /* [modified] sanity check on "a" */
  if (fp_iszero(a) == FP_YES) {
 8023fe8:	68fb      	ldr	r3, [r7, #12]
 8023fea:	681b      	ldr	r3, [r3, #0]
 8023fec:	2b00      	cmp	r3, #0
 8023fee:	d102      	bne.n	8023ff6 <fp_invmod+0x30>
    return FP_VAL; /* can not divide by 0 here */
 8023ff0:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023ff4:	e1a6      	b.n	8024344 <fp_invmod+0x37e>
  }

  /* 2. [modified] b must be odd   */
  if (fp_iseven(b) == FP_YES) {
 8023ff6:	68bb      	ldr	r3, [r7, #8]
 8023ff8:	681b      	ldr	r3, [r3, #0]
 8023ffa:	2b00      	cmp	r3, #0
 8023ffc:	dd07      	ble.n	802400e <fp_invmod+0x48>
 8023ffe:	68bb      	ldr	r3, [r7, #8]
 8024000:	68db      	ldr	r3, [r3, #12]
 8024002:	f003 0301 	and.w	r3, r3, #1
 8024006:	2b00      	cmp	r3, #0
 8024008:	d101      	bne.n	802400e <fp_invmod+0x48>
 802400a:	2301      	movs	r3, #1
 802400c:	e000      	b.n	8024010 <fp_invmod+0x4a>
 802400e:	2300      	movs	r3, #0
 8024010:	2b01      	cmp	r3, #1
 8024012:	d106      	bne.n	8024022 <fp_invmod+0x5c>
    return fp_invmod_slow(a,b,c);
 8024014:	687a      	ldr	r2, [r7, #4]
 8024016:	68b9      	ldr	r1, [r7, #8]
 8024018:	68f8      	ldr	r0, [r7, #12]
 802401a:	f7ff fd85 	bl	8023b28 <fp_invmod_slow>
 802401e:	4603      	mov	r3, r0
 8024020:	e190      	b.n	8024344 <fp_invmod+0x37e>
  }

#ifdef WOLFSSL_SMALL_STACK
  x = (fp_int*)XMALLOC(sizeof(fp_int) * 6, NULL, DYNAMIC_TYPE_BIGINT);
 8024022:	f640 5008 	movw	r0, #3336	@ 0xd08
 8024026:	f7fa fe29 	bl	801ec7c <wolfSSL_Malloc>
 802402a:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (x == NULL) {
 802402c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802402e:	2b00      	cmp	r3, #0
 8024030:	d102      	bne.n	8024038 <fp_invmod+0x72>
      return FP_MEM;
 8024032:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8024036:	e185      	b.n	8024344 <fp_invmod+0x37e>
  }
  y = &x[1]; u = &x[2]; v = &x[3]; B = &x[4]; D = &x[5];
 8024038:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802403a:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802403e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8024040:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024042:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024046:	657b      	str	r3, [r7, #84]	@ 0x54
 8024048:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802404a:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 802404e:	653b      	str	r3, [r7, #80]	@ 0x50
 8024050:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024052:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8024056:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8024058:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802405a:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 802405e:	64bb      	str	r3, [r7, #72]	@ 0x48
#endif

  /* init all our temps */
  fp_init(x);  fp_init(y);
 8024060:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8024062:	f002 fcc9 	bl	80269f8 <fp_init>
 8024066:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8024068:	f002 fcc6 	bl	80269f8 <fp_init>
  fp_init(u);  fp_init(v);
 802406c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802406e:	f002 fcc3 	bl	80269f8 <fp_init>
 8024072:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8024074:	f002 fcc0 	bl	80269f8 <fp_init>
  fp_init(B);  fp_init(D);
 8024078:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 802407a:	f002 fcbd 	bl	80269f8 <fp_init>
 802407e:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8024080:	f002 fcba 	bl	80269f8 <fp_init>

  if (fp_iszero(a) == FP_YES) {
 8024084:	68fb      	ldr	r3, [r7, #12]
 8024086:	681b      	ldr	r3, [r3, #0]
 8024088:	2b00      	cmp	r3, #0
 802408a:	d10a      	bne.n	80240a2 <fp_invmod+0xdc>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 802408c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802408e:	613b      	str	r3, [r7, #16]
 8024090:	693b      	ldr	r3, [r7, #16]
 8024092:	2b00      	cmp	r3, #0
 8024094:	d002      	beq.n	802409c <fp_invmod+0xd6>
 8024096:	6938      	ldr	r0, [r7, #16]
 8024098:	f7fa fe0c 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return FP_VAL;
 802409c:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80240a0:	e150      	b.n	8024344 <fp_invmod+0x37e>
  }

  /* x == modulus, y == value to invert */
  fp_copy(b, x);
 80240a2:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80240a4:	68b8      	ldr	r0, [r7, #8]
 80240a6:	f002 fe91 	bl	8026dcc <fp_copy>

  /* we need y = |a| */
  if ((err = mp_mod(a, b, y)) != FP_OKAY) {
 80240aa:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80240ac:	68b9      	ldr	r1, [r7, #8]
 80240ae:	68f8      	ldr	r0, [r7, #12]
 80240b0:	f002 fdd0 	bl	8026c54 <mp_mod>
 80240b4:	6478      	str	r0, [r7, #68]	@ 0x44
 80240b6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80240b8:	2b00      	cmp	r3, #0
 80240ba:	d009      	beq.n	80240d0 <fp_invmod+0x10a>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80240bc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80240be:	617b      	str	r3, [r7, #20]
 80240c0:	697b      	ldr	r3, [r7, #20]
 80240c2:	2b00      	cmp	r3, #0
 80240c4:	d002      	beq.n	80240cc <fp_invmod+0x106>
 80240c6:	6978      	ldr	r0, [r7, #20]
 80240c8:	f7fa fdf4 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return err;
 80240cc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80240ce:	e139      	b.n	8024344 <fp_invmod+0x37e>
  }

  if (fp_iszero(y) == FP_YES) {
 80240d0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80240d2:	681b      	ldr	r3, [r3, #0]
 80240d4:	2b00      	cmp	r3, #0
 80240d6:	d10a      	bne.n	80240ee <fp_invmod+0x128>
    /* invmod doesn't exist for this a and b */
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80240d8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80240da:	61bb      	str	r3, [r7, #24]
 80240dc:	69bb      	ldr	r3, [r7, #24]
 80240de:	2b00      	cmp	r3, #0
 80240e0:	d002      	beq.n	80240e8 <fp_invmod+0x122>
 80240e2:	69b8      	ldr	r0, [r7, #24]
 80240e4:	f7fa fde6 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return FP_VAL;
 80240e8:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80240ec:	e12a      	b.n	8024344 <fp_invmod+0x37e>
  }

  /* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
  fp_copy(x, u);
 80240ee:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 80240f0:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 80240f2:	f002 fe6b 	bl	8026dcc <fp_copy>
  fp_copy(y, v);
 80240f6:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 80240f8:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 80240fa:	f002 fe67 	bl	8026dcc <fp_copy>
  fp_set (D, 1);
 80240fe:	2101      	movs	r1, #1
 8024100:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8024102:	f002 fa4a 	bl	802659a <fp_set>

top:
  /* 4.  while u is even do */
  while (fp_iseven (u) == FP_YES) {
 8024106:	e029      	b.n	802415c <fp_invmod+0x196>
    /* 4.1 u = u/2 */
    fp_div_2 (u, u);
 8024108:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 802410a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802410c:	f7ff fa51 	bl	80235b2 <fp_div_2>

    /* 4.2 if B is odd then */
    if (fp_isodd (B) == FP_YES) {
 8024110:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8024112:	681b      	ldr	r3, [r3, #0]
 8024114:	2b00      	cmp	r3, #0
 8024116:	dd07      	ble.n	8024128 <fp_invmod+0x162>
 8024118:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802411a:	68db      	ldr	r3, [r3, #12]
 802411c:	f003 0301 	and.w	r3, r3, #1
 8024120:	2b00      	cmp	r3, #0
 8024122:	d001      	beq.n	8024128 <fp_invmod+0x162>
 8024124:	2301      	movs	r3, #1
 8024126:	e000      	b.n	802412a <fp_invmod+0x164>
 8024128:	2300      	movs	r3, #0
 802412a:	2b01      	cmp	r3, #1
 802412c:	d112      	bne.n	8024154 <fp_invmod+0x18e>
      err = fp_sub (B, x, B);
 802412e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8024130:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8024132:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8024134:	f7fe fb53 	bl	80227de <fp_sub>
 8024138:	6478      	str	r0, [r7, #68]	@ 0x44
      if (err != FP_OKAY) {
 802413a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802413c:	2b00      	cmp	r3, #0
 802413e:	d009      	beq.n	8024154 <fp_invmod+0x18e>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8024140:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024142:	61fb      	str	r3, [r7, #28]
 8024144:	69fb      	ldr	r3, [r7, #28]
 8024146:	2b00      	cmp	r3, #0
 8024148:	d002      	beq.n	8024150 <fp_invmod+0x18a>
 802414a:	69f8      	ldr	r0, [r7, #28]
 802414c:	f7fa fdb2 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 8024150:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024152:	e0f7      	b.n	8024344 <fp_invmod+0x37e>
      }
    }
    /* B = B/2 */
    fp_div_2 (B, B);
 8024154:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8024156:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8024158:	f7ff fa2b 	bl	80235b2 <fp_div_2>
  while (fp_iseven (u) == FP_YES) {
 802415c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802415e:	681b      	ldr	r3, [r3, #0]
 8024160:	2b00      	cmp	r3, #0
 8024162:	dd07      	ble.n	8024174 <fp_invmod+0x1ae>
 8024164:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8024166:	68db      	ldr	r3, [r3, #12]
 8024168:	f003 0301 	and.w	r3, r3, #1
 802416c:	2b00      	cmp	r3, #0
 802416e:	d101      	bne.n	8024174 <fp_invmod+0x1ae>
 8024170:	2301      	movs	r3, #1
 8024172:	e000      	b.n	8024176 <fp_invmod+0x1b0>
 8024174:	2300      	movs	r3, #0
 8024176:	2b01      	cmp	r3, #1
 8024178:	d0c6      	beq.n	8024108 <fp_invmod+0x142>
  }

  /* 5.  while v is even do */
  while (fp_iseven (v) == FP_YES) {
 802417a:	e029      	b.n	80241d0 <fp_invmod+0x20a>
    /* 5.1 v = v/2 */
    fp_div_2 (v, v);
 802417c:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 802417e:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8024180:	f7ff fa17 	bl	80235b2 <fp_div_2>

    /* 5.2 if D is odd then */
    if (fp_isodd (D) == FP_YES) {
 8024184:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024186:	681b      	ldr	r3, [r3, #0]
 8024188:	2b00      	cmp	r3, #0
 802418a:	dd07      	ble.n	802419c <fp_invmod+0x1d6>
 802418c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802418e:	68db      	ldr	r3, [r3, #12]
 8024190:	f003 0301 	and.w	r3, r3, #1
 8024194:	2b00      	cmp	r3, #0
 8024196:	d001      	beq.n	802419c <fp_invmod+0x1d6>
 8024198:	2301      	movs	r3, #1
 802419a:	e000      	b.n	802419e <fp_invmod+0x1d8>
 802419c:	2300      	movs	r3, #0
 802419e:	2b01      	cmp	r3, #1
 80241a0:	d112      	bne.n	80241c8 <fp_invmod+0x202>
      /* D = (D-x)/2 */
      err = fp_sub (D, x, D);
 80241a2:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80241a4:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80241a6:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80241a8:	f7fe fb19 	bl	80227de <fp_sub>
 80241ac:	6478      	str	r0, [r7, #68]	@ 0x44
      if (err != FP_OKAY) {
 80241ae:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80241b0:	2b00      	cmp	r3, #0
 80241b2:	d009      	beq.n	80241c8 <fp_invmod+0x202>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80241b4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80241b6:	623b      	str	r3, [r7, #32]
 80241b8:	6a3b      	ldr	r3, [r7, #32]
 80241ba:	2b00      	cmp	r3, #0
 80241bc:	d002      	beq.n	80241c4 <fp_invmod+0x1fe>
 80241be:	6a38      	ldr	r0, [r7, #32]
 80241c0:	f7fa fd78 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 80241c4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80241c6:	e0bd      	b.n	8024344 <fp_invmod+0x37e>
      }
    }
    /* D = D/2 */
    fp_div_2 (D, D);
 80241c8:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 80241ca:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80241cc:	f7ff f9f1 	bl	80235b2 <fp_div_2>
  while (fp_iseven (v) == FP_YES) {
 80241d0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80241d2:	681b      	ldr	r3, [r3, #0]
 80241d4:	2b00      	cmp	r3, #0
 80241d6:	dd07      	ble.n	80241e8 <fp_invmod+0x222>
 80241d8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80241da:	68db      	ldr	r3, [r3, #12]
 80241dc:	f003 0301 	and.w	r3, r3, #1
 80241e0:	2b00      	cmp	r3, #0
 80241e2:	d101      	bne.n	80241e8 <fp_invmod+0x222>
 80241e4:	2301      	movs	r3, #1
 80241e6:	e000      	b.n	80241ea <fp_invmod+0x224>
 80241e8:	2300      	movs	r3, #0
 80241ea:	2b01      	cmp	r3, #1
 80241ec:	d0c6      	beq.n	802417c <fp_invmod+0x1b6>
  }

  /* 6.  if u >= v then */
  if (fp_cmp (u, v) != FP_LT) {
 80241ee:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 80241f0:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80241f2:	f001 fde7 	bl	8025dc4 <fp_cmp>
 80241f6:	4603      	mov	r3, r0
 80241f8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80241fc:	d025      	beq.n	802424a <fp_invmod+0x284>
    /* u = u - v, B = B - D */
    err = fp_sub (u, v, u);
 80241fe:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8024200:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8024202:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8024204:	f7fe faeb 	bl	80227de <fp_sub>
 8024208:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 802420a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802420c:	2b00      	cmp	r3, #0
 802420e:	d009      	beq.n	8024224 <fp_invmod+0x25e>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8024210:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024212:	637b      	str	r3, [r7, #52]	@ 0x34
 8024214:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8024216:	2b00      	cmp	r3, #0
 8024218:	d002      	beq.n	8024220 <fp_invmod+0x25a>
 802421a:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 802421c:	f7fa fd4a 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8024220:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024222:	e08f      	b.n	8024344 <fp_invmod+0x37e>
    }
    err = fp_sub (B, D, B);
 8024224:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8024226:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8024228:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 802422a:	f7fe fad8 	bl	80227de <fp_sub>
 802422e:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8024230:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024232:	2b00      	cmp	r3, #0
 8024234:	d02f      	beq.n	8024296 <fp_invmod+0x2d0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8024236:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024238:	63bb      	str	r3, [r7, #56]	@ 0x38
 802423a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802423c:	2b00      	cmp	r3, #0
 802423e:	d002      	beq.n	8024246 <fp_invmod+0x280>
 8024240:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8024242:	f7fa fd37 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8024246:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024248:	e07c      	b.n	8024344 <fp_invmod+0x37e>
    }
  } else {
    /* v - v - u, D = D - B */
    err = fp_sub (v, u, v);
 802424a:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802424c:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 802424e:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8024250:	f7fe fac5 	bl	80227de <fp_sub>
 8024254:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8024256:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024258:	2b00      	cmp	r3, #0
 802425a:	d009      	beq.n	8024270 <fp_invmod+0x2aa>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 802425c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802425e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8024260:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024262:	2b00      	cmp	r3, #0
 8024264:	d002      	beq.n	802426c <fp_invmod+0x2a6>
 8024266:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024268:	f7fa fd24 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 802426c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802426e:	e069      	b.n	8024344 <fp_invmod+0x37e>
    }
    err = fp_sub (D, B, D);
 8024270:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8024272:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8024274:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8024276:	f7fe fab2 	bl	80227de <fp_sub>
 802427a:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 802427c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802427e:	2b00      	cmp	r3, #0
 8024280:	d009      	beq.n	8024296 <fp_invmod+0x2d0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8024282:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024284:	643b      	str	r3, [r7, #64]	@ 0x40
 8024286:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024288:	2b00      	cmp	r3, #0
 802428a:	d002      	beq.n	8024292 <fp_invmod+0x2cc>
 802428c:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 802428e:	f7fa fd11 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8024292:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024294:	e056      	b.n	8024344 <fp_invmod+0x37e>
    }
  }

  /* if not zero goto step 4 */
  if (fp_iszero (u) == FP_NO) {
 8024296:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8024298:	681b      	ldr	r3, [r3, #0]
 802429a:	2b00      	cmp	r3, #0
 802429c:	d000      	beq.n	80242a0 <fp_invmod+0x2da>
    goto top;
 802429e:	e732      	b.n	8024106 <fp_invmod+0x140>
  }

  /* now a = C, b = D, gcd == g*v */

  /* if v != 1 then there is no inverse */
  if (fp_cmp_d (v, 1) != FP_EQ) {
 80242a0:	2101      	movs	r1, #1
 80242a2:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 80242a4:	f001 fdbb 	bl	8025e1e <fp_cmp_d>
 80242a8:	4603      	mov	r3, r0
 80242aa:	2b00      	cmp	r3, #0
 80242ac:	d01d      	beq.n	80242ea <fp_invmod+0x324>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80242ae:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80242b0:	627b      	str	r3, [r7, #36]	@ 0x24
 80242b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80242b4:	2b00      	cmp	r3, #0
 80242b6:	d002      	beq.n	80242be <fp_invmod+0x2f8>
 80242b8:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 80242ba:	f7fa fcfb 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return FP_VAL;
 80242be:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80242c2:	e03f      	b.n	8024344 <fp_invmod+0x37e>
  }

  /* b is now the inverse */
  while (D->sign == FP_NEG) {
    err = fp_add (D, b, D);
 80242c4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80242c6:	68b9      	ldr	r1, [r7, #8]
 80242c8:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80242ca:	f7fe f9a6 	bl	802261a <fp_add>
 80242ce:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 80242d0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80242d2:	2b00      	cmp	r3, #0
 80242d4:	d009      	beq.n	80242ea <fp_invmod+0x324>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80242d6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80242d8:	62bb      	str	r3, [r7, #40]	@ 0x28
 80242da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80242dc:	2b00      	cmp	r3, #0
 80242de:	d002      	beq.n	80242e6 <fp_invmod+0x320>
 80242e0:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80242e2:	f7fa fce7 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return FP_OKAY;
 80242e6:	2300      	movs	r3, #0
 80242e8:	e02c      	b.n	8024344 <fp_invmod+0x37e>
  while (D->sign == FP_NEG) {
 80242ea:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80242ec:	685b      	ldr	r3, [r3, #4]
 80242ee:	2b01      	cmp	r3, #1
 80242f0:	d0e8      	beq.n	80242c4 <fp_invmod+0x2fe>
    }
  }
  /* too big */
  while (fp_cmp_mag(D, b) != FP_LT) {
 80242f2:	e012      	b.n	802431a <fp_invmod+0x354>
    err = fp_sub(D, b, D);
 80242f4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80242f6:	68b9      	ldr	r1, [r7, #8]
 80242f8:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80242fa:	f7fe fa70 	bl	80227de <fp_sub>
 80242fe:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8024300:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024302:	2b00      	cmp	r3, #0
 8024304:	d009      	beq.n	802431a <fp_invmod+0x354>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8024306:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024308:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802430a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802430c:	2b00      	cmp	r3, #0
 802430e:	d002      	beq.n	8024316 <fp_invmod+0x350>
 8024310:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8024312:	f7fa fccf 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8024316:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024318:	e014      	b.n	8024344 <fp_invmod+0x37e>
  while (fp_cmp_mag(D, b) != FP_LT) {
 802431a:	68b9      	ldr	r1, [r7, #8]
 802431c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 802431e:	f001 fdb6 	bl	8025e8e <fp_cmp_mag>
 8024322:	4603      	mov	r3, r0
 8024324:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8024328:	d1e4      	bne.n	80242f4 <fp_invmod+0x32e>
    }
  }
  fp_copy (D, c);
 802432a:	6879      	ldr	r1, [r7, #4]
 802432c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 802432e:	f002 fd4d 	bl	8026dcc <fp_copy>
#ifdef WOLFSSL_SMALL_STACK
  XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8024332:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024334:	633b      	str	r3, [r7, #48]	@ 0x30
 8024336:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024338:	2b00      	cmp	r3, #0
 802433a:	d002      	beq.n	8024342 <fp_invmod+0x37c>
 802433c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 802433e:	f7fa fcb9 	bl	801ecb4 <wolfSSL_Free>
#endif
  return FP_OKAY;
 8024342:	2300      	movs	r3, #0
}
 8024344:	4618      	mov	r0, r3
 8024346:	3760      	adds	r7, #96	@ 0x60
 8024348:	46bd      	mov	sp, r7
 802434a:	bd80      	pop	{r7, pc}

0802434c <fp_invmod_mont_ct>:

#define CT_INV_MOD_PRE_CNT      8

/* modulus (b) must be greater than 2 and a prime */
int fp_invmod_mont_ct(fp_int *a, fp_int *b, fp_int *c, fp_digit mp)
{
 802434c:	b580      	push	{r7, lr}
 802434e:	b08c      	sub	sp, #48	@ 0x30
 8024350:	af00      	add	r7, sp, #0
 8024352:	60f8      	str	r0, [r7, #12]
 8024354:	60b9      	str	r1, [r7, #8]
 8024356:	607a      	str	r2, [r7, #4]
 8024358:	603b      	str	r3, [r7, #0]
  int i, j, err = FP_OKAY;
 802435a:	2300      	movs	r3, #0
 802435c:	627b      	str	r3, [r7, #36]	@ 0x24
  fp_int* t;
  fp_int* e;
  fp_int* pre;
#endif

  if ((a->used * 2 > FP_SIZE) || (b->used * 2 > FP_SIZE)) {
 802435e:	68fb      	ldr	r3, [r7, #12]
 8024360:	681b      	ldr	r3, [r3, #0]
 8024362:	005b      	lsls	r3, r3, #1
 8024364:	2b88      	cmp	r3, #136	@ 0x88
 8024366:	dc04      	bgt.n	8024372 <fp_invmod_mont_ct+0x26>
 8024368:	68bb      	ldr	r3, [r7, #8]
 802436a:	681b      	ldr	r3, [r3, #0]
 802436c:	005b      	lsls	r3, r3, #1
 802436e:	2b88      	cmp	r3, #136	@ 0x88
 8024370:	dd02      	ble.n	8024378 <fp_invmod_mont_ct+0x2c>
    return FP_VAL;
 8024372:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8024376:	e128      	b.n	80245ca <fp_invmod_mont_ct+0x27e>
  }

#ifdef WOLFSSL_SMALL_STACK
  t = (fp_int*)XMALLOC(sizeof(fp_int) * (2 + CT_INV_MOD_PRE_CNT), NULL,
 8024378:	f241 50b8 	movw	r0, #5560	@ 0x15b8
 802437c:	f7fa fc7e 	bl	801ec7c <wolfSSL_Malloc>
 8024380:	6238      	str	r0, [r7, #32]
                                                           DYNAMIC_TYPE_BIGINT);
  if (t == NULL)
 8024382:	6a3b      	ldr	r3, [r7, #32]
 8024384:	2b00      	cmp	r3, #0
 8024386:	d102      	bne.n	802438e <fp_invmod_mont_ct+0x42>
    return FP_MEM;
 8024388:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 802438c:	e11d      	b.n	80245ca <fp_invmod_mont_ct+0x27e>
  e = t + 1;
 802438e:	6a3b      	ldr	r3, [r7, #32]
 8024390:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024394:	61fb      	str	r3, [r7, #28]
  pre = t + 2;
 8024396:	6a3b      	ldr	r3, [r7, #32]
 8024398:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 802439c:	61bb      	str	r3, [r7, #24]
#endif

  fp_init(t);
 802439e:	6a38      	ldr	r0, [r7, #32]
 80243a0:	f002 fb2a 	bl	80269f8 <fp_init>
  fp_init(e);
 80243a4:	69f8      	ldr	r0, [r7, #28]
 80243a6:	f002 fb27 	bl	80269f8 <fp_init>

  fp_init(&pre[0]);
 80243aa:	69b8      	ldr	r0, [r7, #24]
 80243ac:	f002 fb24 	bl	80269f8 <fp_init>
  fp_copy(a, &pre[0]);
 80243b0:	69b9      	ldr	r1, [r7, #24]
 80243b2:	68f8      	ldr	r0, [r7, #12]
 80243b4:	f002 fd0a 	bl	8026dcc <fp_copy>
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
 80243b8:	2301      	movs	r3, #1
 80243ba:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80243bc:	e059      	b.n	8024472 <fp_invmod_mont_ct+0x126>
    fp_init(&pre[i]);
 80243be:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80243c0:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80243c4:	fb02 f303 	mul.w	r3, r2, r3
 80243c8:	69ba      	ldr	r2, [r7, #24]
 80243ca:	4413      	add	r3, r2
 80243cc:	4618      	mov	r0, r3
 80243ce:	f002 fb13 	bl	80269f8 <fp_init>
    err |= fp_sqr(&pre[i-1], &pre[i]);
 80243d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80243d4:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80243d8:	fb02 f303 	mul.w	r3, r2, r3
 80243dc:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 80243e0:	69ba      	ldr	r2, [r7, #24]
 80243e2:	18d0      	adds	r0, r2, r3
 80243e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80243e6:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80243ea:	fb02 f303 	mul.w	r3, r2, r3
 80243ee:	69ba      	ldr	r2, [r7, #24]
 80243f0:	4413      	add	r3, r2
 80243f2:	4619      	mov	r1, r3
 80243f4:	f001 fa9f 	bl	8025936 <fp_sqr>
 80243f8:	4602      	mov	r2, r0
 80243fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80243fc:	4313      	orrs	r3, r2
 80243fe:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(&pre[i], b, mp);
 8024400:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024402:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024406:	fb02 f303 	mul.w	r3, r2, r3
 802440a:	69ba      	ldr	r2, [r7, #24]
 802440c:	4413      	add	r3, r2
 802440e:	683a      	ldr	r2, [r7, #0]
 8024410:	68b9      	ldr	r1, [r7, #8]
 8024412:	4618      	mov	r0, r3
 8024414:	f001 ff4b 	bl	80262ae <fp_montgomery_reduce>
 8024418:	4602      	mov	r2, r0
 802441a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802441c:	4313      	orrs	r3, r2
 802441e:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_mul(&pre[i], a, &pre[i]);
 8024420:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024422:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024426:	fb02 f303 	mul.w	r3, r2, r3
 802442a:	69ba      	ldr	r2, [r7, #24]
 802442c:	18d0      	adds	r0, r2, r3
 802442e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024430:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024434:	fb02 f303 	mul.w	r3, r2, r3
 8024438:	69ba      	ldr	r2, [r7, #24]
 802443a:	4413      	add	r3, r2
 802443c:	461a      	mov	r2, r3
 802443e:	68f9      	ldr	r1, [r7, #12]
 8024440:	f7fe fad1 	bl	80229e6 <fp_mul>
 8024444:	4602      	mov	r2, r0
 8024446:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024448:	4313      	orrs	r3, r2
 802444a:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(&pre[i], b, mp);
 802444c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802444e:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024452:	fb02 f303 	mul.w	r3, r2, r3
 8024456:	69ba      	ldr	r2, [r7, #24]
 8024458:	4413      	add	r3, r2
 802445a:	683a      	ldr	r2, [r7, #0]
 802445c:	68b9      	ldr	r1, [r7, #8]
 802445e:	4618      	mov	r0, r3
 8024460:	f001 ff25 	bl	80262ae <fp_montgomery_reduce>
 8024464:	4602      	mov	r2, r0
 8024466:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024468:	4313      	orrs	r3, r2
 802446a:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
 802446c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802446e:	3301      	adds	r3, #1
 8024470:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024472:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024474:	2b07      	cmp	r3, #7
 8024476:	dda2      	ble.n	80243be <fp_invmod_mont_ct+0x72>
  }

  err |= fp_sub_d(b, 2, e);
 8024478:	69fa      	ldr	r2, [r7, #28]
 802447a:	2102      	movs	r1, #2
 802447c:	68b8      	ldr	r0, [r7, #8]
 802447e:	f002 fa70 	bl	8026962 <fp_sub_d>
 8024482:	4602      	mov	r2, r0
 8024484:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024486:	4313      	orrs	r3, r2
 8024488:	627b      	str	r3, [r7, #36]	@ 0x24
  /* Highest bit is always set. */
  j = 1;
 802448a:	2301      	movs	r3, #1
 802448c:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = fp_count_bits(e)-2; i >= 0; i--) {
 802448e:	69f8      	ldr	r0, [r7, #28]
 8024490:	f002 f8c6 	bl	8026620 <fp_count_bits>
 8024494:	4603      	mov	r3, r0
 8024496:	3b02      	subs	r3, #2
 8024498:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802449a:	e010      	b.n	80244be <fp_invmod_mont_ct+0x172>
      if (!fp_is_bit_set(e, i) || j == CT_INV_MOD_PRE_CNT)
 802449c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802449e:	4619      	mov	r1, r3
 80244a0:	69f8      	ldr	r0, [r7, #28]
 80244a2:	f002 f893 	bl	80265cc <fp_is_bit_set>
 80244a6:	4603      	mov	r3, r0
 80244a8:	2b00      	cmp	r3, #0
 80244aa:	d00b      	beq.n	80244c4 <fp_invmod_mont_ct+0x178>
 80244ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80244ae:	2b08      	cmp	r3, #8
 80244b0:	d008      	beq.n	80244c4 <fp_invmod_mont_ct+0x178>
          break;
      j++;
 80244b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80244b4:	3301      	adds	r3, #1
 80244b6:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = fp_count_bits(e)-2; i >= 0; i--) {
 80244b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80244ba:	3b01      	subs	r3, #1
 80244bc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80244be:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80244c0:	2b00      	cmp	r3, #0
 80244c2:	daeb      	bge.n	802449c <fp_invmod_mont_ct+0x150>
  }
  fp_copy(&pre[j-1], t);
 80244c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80244c6:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80244ca:	fb02 f303 	mul.w	r3, r2, r3
 80244ce:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 80244d2:	69ba      	ldr	r2, [r7, #24]
 80244d4:	4413      	add	r3, r2
 80244d6:	6a39      	ldr	r1, [r7, #32]
 80244d8:	4618      	mov	r0, r3
 80244da:	f002 fc77 	bl	8026dcc <fp_copy>
  j = 0;
 80244de:	2300      	movs	r3, #0
 80244e0:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (; i >= 0; i--) {
 80244e2:	e043      	b.n	802456c <fp_invmod_mont_ct+0x220>
    int set = fp_is_bit_set(e, i);
 80244e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80244e6:	4619      	mov	r1, r3
 80244e8:	69f8      	ldr	r0, [r7, #28]
 80244ea:	f002 f86f 	bl	80265cc <fp_is_bit_set>
 80244ee:	6138      	str	r0, [r7, #16]

    if ((j == CT_INV_MOD_PRE_CNT) || (!set && j > 0)) {
 80244f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80244f2:	2b08      	cmp	r3, #8
 80244f4:	d005      	beq.n	8024502 <fp_invmod_mont_ct+0x1b6>
 80244f6:	693b      	ldr	r3, [r7, #16]
 80244f8:	2b00      	cmp	r3, #0
 80244fa:	d11f      	bne.n	802453c <fp_invmod_mont_ct+0x1f0>
 80244fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80244fe:	2b00      	cmp	r3, #0
 8024500:	dd1c      	ble.n	802453c <fp_invmod_mont_ct+0x1f0>
      err |= fp_mul(t, &pre[j-1], t);
 8024502:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8024504:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024508:	fb02 f303 	mul.w	r3, r2, r3
 802450c:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 8024510:	69ba      	ldr	r2, [r7, #24]
 8024512:	4413      	add	r3, r2
 8024514:	6a3a      	ldr	r2, [r7, #32]
 8024516:	4619      	mov	r1, r3
 8024518:	6a38      	ldr	r0, [r7, #32]
 802451a:	f7fe fa64 	bl	80229e6 <fp_mul>
 802451e:	4602      	mov	r2, r0
 8024520:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024522:	4313      	orrs	r3, r2
 8024524:	627b      	str	r3, [r7, #36]	@ 0x24
      err |= fp_montgomery_reduce(t, b, mp);
 8024526:	683a      	ldr	r2, [r7, #0]
 8024528:	68b9      	ldr	r1, [r7, #8]
 802452a:	6a38      	ldr	r0, [r7, #32]
 802452c:	f001 febf 	bl	80262ae <fp_montgomery_reduce>
 8024530:	4602      	mov	r2, r0
 8024532:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024534:	4313      	orrs	r3, r2
 8024536:	627b      	str	r3, [r7, #36]	@ 0x24
      j = 0;
 8024538:	2300      	movs	r3, #0
 802453a:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
    err |= fp_sqr(t, t);
 802453c:	6a39      	ldr	r1, [r7, #32]
 802453e:	6a38      	ldr	r0, [r7, #32]
 8024540:	f001 f9f9 	bl	8025936 <fp_sqr>
 8024544:	4602      	mov	r2, r0
 8024546:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024548:	4313      	orrs	r3, r2
 802454a:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(t, b, mp);
 802454c:	683a      	ldr	r2, [r7, #0]
 802454e:	68b9      	ldr	r1, [r7, #8]
 8024550:	6a38      	ldr	r0, [r7, #32]
 8024552:	f001 feac 	bl	80262ae <fp_montgomery_reduce>
 8024556:	4602      	mov	r2, r0
 8024558:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802455a:	4313      	orrs	r3, r2
 802455c:	627b      	str	r3, [r7, #36]	@ 0x24
    j += set;
 802455e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8024560:	693b      	ldr	r3, [r7, #16]
 8024562:	4413      	add	r3, r2
 8024564:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (; i >= 0; i--) {
 8024566:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024568:	3b01      	subs	r3, #1
 802456a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802456c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802456e:	2b00      	cmp	r3, #0
 8024570:	dab8      	bge.n	80244e4 <fp_invmod_mont_ct+0x198>
  }
  if (j > 0) {
 8024572:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8024574:	2b00      	cmp	r3, #0
 8024576:	dd1b      	ble.n	80245b0 <fp_invmod_mont_ct+0x264>
    err |= fp_mul(t, &pre[j-1], c);
 8024578:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802457a:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 802457e:	fb02 f303 	mul.w	r3, r2, r3
 8024582:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 8024586:	69ba      	ldr	r2, [r7, #24]
 8024588:	4413      	add	r3, r2
 802458a:	687a      	ldr	r2, [r7, #4]
 802458c:	4619      	mov	r1, r3
 802458e:	6a38      	ldr	r0, [r7, #32]
 8024590:	f7fe fa29 	bl	80229e6 <fp_mul>
 8024594:	4602      	mov	r2, r0
 8024596:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024598:	4313      	orrs	r3, r2
 802459a:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(c, b, mp);
 802459c:	683a      	ldr	r2, [r7, #0]
 802459e:	68b9      	ldr	r1, [r7, #8]
 80245a0:	6878      	ldr	r0, [r7, #4]
 80245a2:	f001 fe84 	bl	80262ae <fp_montgomery_reduce>
 80245a6:	4602      	mov	r2, r0
 80245a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80245aa:	4313      	orrs	r3, r2
 80245ac:	627b      	str	r3, [r7, #36]	@ 0x24
 80245ae:	e003      	b.n	80245b8 <fp_invmod_mont_ct+0x26c>
  }
  else
    fp_copy(t, c);
 80245b0:	6879      	ldr	r1, [r7, #4]
 80245b2:	6a38      	ldr	r0, [r7, #32]
 80245b4:	f002 fc0a 	bl	8026dcc <fp_copy>

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 80245b8:	6a3b      	ldr	r3, [r7, #32]
 80245ba:	617b      	str	r3, [r7, #20]
 80245bc:	697b      	ldr	r3, [r7, #20]
 80245be:	2b00      	cmp	r3, #0
 80245c0:	d002      	beq.n	80245c8 <fp_invmod_mont_ct+0x27c>
 80245c2:	6978      	ldr	r0, [r7, #20]
 80245c4:	f7fa fb76 	bl	801ecb4 <wolfSSL_Free>
#endif

  return err;
 80245c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 80245ca:	4618      	mov	r0, r3
 80245cc:	3730      	adds	r7, #48	@ 0x30
 80245ce:	46bd      	mov	sp, r7
 80245d0:	bd80      	pop	{r7, pc}

080245d2 <fp_mulmod>:

/* d = a * b (mod c) */
int fp_mulmod(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 80245d2:	b580      	push	{r7, lr}
 80245d4:	b088      	sub	sp, #32
 80245d6:	af00      	add	r7, sp, #0
 80245d8:	60f8      	str	r0, [r7, #12]
 80245da:	60b9      	str	r1, [r7, #8]
 80245dc:	607a      	str	r2, [r7, #4]
 80245de:	603b      	str	r3, [r7, #0]
#else
   fp_int *t;
#endif

#ifdef WOLFSSL_SMALL_STACK
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 80245e0:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 80245e4:	f7fa fb4a 	bl	801ec7c <wolfSSL_Malloc>
 80245e8:	61b8      	str	r0, [r7, #24]
   if (t == NULL)
 80245ea:	69bb      	ldr	r3, [r7, #24]
 80245ec:	2b00      	cmp	r3, #0
 80245ee:	d102      	bne.n	80245f6 <fp_mulmod+0x24>
       return FP_MEM;
 80245f0:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80245f4:	e029      	b.n	802464a <fp_mulmod+0x78>
#endif

  fp_init(t);
 80245f6:	69b8      	ldr	r0, [r7, #24]
 80245f8:	f002 f9fe 	bl	80269f8 <fp_init>
  err = fp_mul(a, b, t);
 80245fc:	69ba      	ldr	r2, [r7, #24]
 80245fe:	68b9      	ldr	r1, [r7, #8]
 8024600:	68f8      	ldr	r0, [r7, #12]
 8024602:	f7fe f9f0 	bl	80229e6 <fp_mul>
 8024606:	61f8      	str	r0, [r7, #28]
  if (err == FP_OKAY) {
 8024608:	69fb      	ldr	r3, [r7, #28]
 802460a:	2b00      	cmp	r3, #0
 802460c:	d114      	bne.n	8024638 <fp_mulmod+0x66>
  #if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    if (d->size < FP_SIZE) {
 802460e:	683b      	ldr	r3, [r7, #0]
 8024610:	689b      	ldr	r3, [r3, #8]
 8024612:	2b87      	cmp	r3, #135	@ 0x87
 8024614:	dc0a      	bgt.n	802462c <fp_mulmod+0x5a>
      err = fp_mod(t, c, t);
 8024616:	69ba      	ldr	r2, [r7, #24]
 8024618:	6879      	ldr	r1, [r7, #4]
 802461a:	69b8      	ldr	r0, [r7, #24]
 802461c:	f7ff f97c 	bl	8023918 <fp_mod>
 8024620:	61f8      	str	r0, [r7, #28]
      fp_copy(t, d);
 8024622:	6839      	ldr	r1, [r7, #0]
 8024624:	69b8      	ldr	r0, [r7, #24]
 8024626:	f002 fbd1 	bl	8026dcc <fp_copy>
 802462a:	e005      	b.n	8024638 <fp_mulmod+0x66>
    } else
  #endif
    {
      err = fp_mod(t, c, d);
 802462c:	683a      	ldr	r2, [r7, #0]
 802462e:	6879      	ldr	r1, [r7, #4]
 8024630:	69b8      	ldr	r0, [r7, #24]
 8024632:	f7ff f971 	bl	8023918 <fp_mod>
 8024636:	61f8      	str	r0, [r7, #28]
    }
  }

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 8024638:	69bb      	ldr	r3, [r7, #24]
 802463a:	617b      	str	r3, [r7, #20]
 802463c:	697b      	ldr	r3, [r7, #20]
 802463e:	2b00      	cmp	r3, #0
 8024640:	d002      	beq.n	8024648 <fp_mulmod+0x76>
 8024642:	6978      	ldr	r0, [r7, #20]
 8024644:	f7fa fb36 	bl	801ecb4 <wolfSSL_Free>
#endif
  return err;
 8024648:	69fb      	ldr	r3, [r7, #28]
}
 802464a:	4618      	mov	r0, r3
 802464c:	3720      	adds	r7, #32
 802464e:	46bd      	mov	sp, r7
 8024650:	bd80      	pop	{r7, pc}

08024652 <fp_submod_ct>:

/* d = a - b (mod c) - constant time (a < c and b < c and all positive)
 * c and d must not be the same pointers.
 */
int fp_submod_ct(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 8024652:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8024656:	b09b      	sub	sp, #108	@ 0x6c
 8024658:	af00      	add	r7, sp, #0
 802465a:	6578      	str	r0, [r7, #84]	@ 0x54
 802465c:	6539      	str	r1, [r7, #80]	@ 0x50
 802465e:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8024660:	64bb      	str	r3, [r7, #72]	@ 0x48
  fp_sword w;
  fp_digit mask;
  int i;

  if (c->used + 1 > FP_SIZE) {
 8024662:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8024664:	681b      	ldr	r3, [r3, #0]
 8024666:	2b87      	cmp	r3, #135	@ 0x87
 8024668:	dd02      	ble.n	8024670 <fp_submod_ct+0x1e>
    return FP_VAL;
 802466a:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802466e:	e106      	b.n	802487e <fp_submod_ct+0x22c>
  }
  if (c == d) {
 8024670:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8024672:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024674:	429a      	cmp	r2, r3
 8024676:	d102      	bne.n	802467e <fp_submod_ct+0x2c>
    return FP_VAL;
 8024678:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802467c:	e0ff      	b.n	802487e <fp_submod_ct+0x22c>
  }

  /* In constant time, subtract b from a putting result in d. */
  w = 0;
 802467e:	f04f 0200 	mov.w	r2, #0
 8024682:	f04f 0300 	mov.w	r3, #0
 8024686:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 802468a:	2300      	movs	r3, #0
 802468c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 802468e:	e03e      	b.n	802470e <fp_submod_ct+0xbc>
    w         += a->dp[i];
 8024690:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8024692:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024694:	3302      	adds	r3, #2
 8024696:	009b      	lsls	r3, r3, #2
 8024698:	4413      	add	r3, r2
 802469a:	685b      	ldr	r3, [r3, #4]
 802469c:	2200      	movs	r2, #0
 802469e:	643b      	str	r3, [r7, #64]	@ 0x40
 80246a0:	647a      	str	r2, [r7, #68]	@ 0x44
 80246a2:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80246a6:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 80246a8:	1851      	adds	r1, r2, r1
 80246aa:	62b9      	str	r1, [r7, #40]	@ 0x28
 80246ac:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 80246ae:	414b      	adcs	r3, r1
 80246b0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80246b2:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 80246b6:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
    w         -= b->dp[i];
 80246ba:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80246bc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80246be:	3302      	adds	r3, #2
 80246c0:	009b      	lsls	r3, r3, #2
 80246c2:	4413      	add	r3, r2
 80246c4:	685b      	ldr	r3, [r3, #4]
 80246c6:	2200      	movs	r2, #0
 80246c8:	63bb      	str	r3, [r7, #56]	@ 0x38
 80246ca:	63fa      	str	r2, [r7, #60]	@ 0x3c
 80246cc:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80246d0:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80246d2:	1a51      	subs	r1, r2, r1
 80246d4:	6239      	str	r1, [r7, #32]
 80246d6:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 80246d8:	eb63 0301 	sbc.w	r3, r3, r1
 80246dc:	627b      	str	r3, [r7, #36]	@ 0x24
 80246de:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80246e2:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
    d->dp[i]   = (fp_digit)w;
 80246e6:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80246e8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80246ea:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80246ec:	3302      	adds	r3, #2
 80246ee:	009b      	lsls	r3, r3, #2
 80246f0:	4413      	add	r3, r2
 80246f2:	6059      	str	r1, [r3, #4]
    w        >>= DIGIT_BIT;
 80246f4:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80246f8:	f04f 0000 	mov.w	r0, #0
 80246fc:	f04f 0100 	mov.w	r1, #0
 8024700:	0018      	movs	r0, r3
 8024702:	17d9      	asrs	r1, r3, #31
 8024704:	e9c7 0118 	strd	r0, r1, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 8024708:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802470a:	3301      	adds	r3, #1
 802470c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 802470e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8024710:	681a      	ldr	r2, [r3, #0]
 8024712:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024714:	4293      	cmp	r3, r2
 8024716:	dbbb      	blt.n	8024690 <fp_submod_ct+0x3e>
  }
  w  += a->dp[i];
 8024718:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802471a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802471c:	3302      	adds	r3, #2
 802471e:	009b      	lsls	r3, r3, #2
 8024720:	4413      	add	r3, r2
 8024722:	685b      	ldr	r3, [r3, #4]
 8024724:	2200      	movs	r2, #0
 8024726:	461c      	mov	r4, r3
 8024728:	4615      	mov	r5, r2
 802472a:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 802472e:	1911      	adds	r1, r2, r4
 8024730:	61b9      	str	r1, [r7, #24]
 8024732:	416b      	adcs	r3, r5
 8024734:	61fb      	str	r3, [r7, #28]
 8024736:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 802473a:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
  w  -= b->dp[i];
 802473e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8024740:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024742:	3302      	adds	r3, #2
 8024744:	009b      	lsls	r3, r3, #2
 8024746:	4413      	add	r3, r2
 8024748:	685b      	ldr	r3, [r3, #4]
 802474a:	2200      	movs	r2, #0
 802474c:	633b      	str	r3, [r7, #48]	@ 0x30
 802474e:	637a      	str	r2, [r7, #52]	@ 0x34
 8024750:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8024754:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 8024758:	4621      	mov	r1, r4
 802475a:	1a51      	subs	r1, r2, r1
 802475c:	6139      	str	r1, [r7, #16]
 802475e:	4629      	mov	r1, r5
 8024760:	eb63 0301 	sbc.w	r3, r3, r1
 8024764:	617b      	str	r3, [r7, #20]
 8024766:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 802476a:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
  w >>= DIGIT_BIT;
 802476e:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
 8024772:	f04f 0200 	mov.w	r2, #0
 8024776:	f04f 0300 	mov.w	r3, #0
 802477a:	000a      	movs	r2, r1
 802477c:	17cb      	asrs	r3, r1, #31
 802477e:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  /* When w is negative then we need to add modulus to make result positive. */
  mask = (fp_digit)0 - (w < 0);
 8024782:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
 8024786:	f04f 0200 	mov.w	r2, #0
 802478a:	f04f 0300 	mov.w	r3, #0
 802478e:	0fca      	lsrs	r2, r1, #31
 8024790:	2300      	movs	r3, #0
 8024792:	b2d3      	uxtb	r3, r2
 8024794:	425b      	negs	r3, r3
 8024796:	65bb      	str	r3, [r7, #88]	@ 0x58
  /* Constant time, conditionally, add modulus to difference. */
  w = 0;
 8024798:	f04f 0200 	mov.w	r2, #0
 802479c:	f04f 0300 	mov.w	r3, #0
 80247a0:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 80247a4:	2300      	movs	r3, #0
 80247a6:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80247a8:	e03f      	b.n	802482a <fp_submod_ct+0x1d8>
    w         += d->dp[i];
 80247aa:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80247ac:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80247ae:	3302      	adds	r3, #2
 80247b0:	009b      	lsls	r3, r3, #2
 80247b2:	4413      	add	r3, r2
 80247b4:	685b      	ldr	r3, [r3, #4]
 80247b6:	2200      	movs	r2, #0
 80247b8:	4698      	mov	r8, r3
 80247ba:	4691      	mov	r9, r2
 80247bc:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80247c0:	eb12 0108 	adds.w	r1, r2, r8
 80247c4:	60b9      	str	r1, [r7, #8]
 80247c6:	eb43 0309 	adc.w	r3, r3, r9
 80247ca:	60fb      	str	r3, [r7, #12]
 80247cc:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 80247d0:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
    w         += c->dp[i] & mask;
 80247d4:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80247d6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80247d8:	3302      	adds	r3, #2
 80247da:	009b      	lsls	r3, r3, #2
 80247dc:	4413      	add	r3, r2
 80247de:	685a      	ldr	r2, [r3, #4]
 80247e0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80247e2:	4013      	ands	r3, r2
 80247e4:	2200      	movs	r2, #0
 80247e6:	469a      	mov	sl, r3
 80247e8:	4693      	mov	fp, r2
 80247ea:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80247ee:	eb12 010a 	adds.w	r1, r2, sl
 80247f2:	6039      	str	r1, [r7, #0]
 80247f4:	eb43 030b 	adc.w	r3, r3, fp
 80247f8:	607b      	str	r3, [r7, #4]
 80247fa:	e9d7 3400 	ldrd	r3, r4, [r7]
 80247fe:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
    d->dp[i]   = (fp_digit)w;
 8024802:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8024804:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8024806:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024808:	3302      	adds	r3, #2
 802480a:	009b      	lsls	r3, r3, #2
 802480c:	440b      	add	r3, r1
 802480e:	605a      	str	r2, [r3, #4]
    w        >>= DIGIT_BIT;
 8024810:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
 8024814:	f04f 0200 	mov.w	r2, #0
 8024818:	f04f 0300 	mov.w	r3, #0
 802481c:	000a      	movs	r2, r1
 802481e:	17cb      	asrs	r3, r1, #31
 8024820:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 8024824:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024826:	3301      	adds	r3, #1
 8024828:	65fb      	str	r3, [r7, #92]	@ 0x5c
 802482a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802482c:	681b      	ldr	r3, [r3, #0]
 802482e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8024830:	429a      	cmp	r2, r3
 8024832:	dbba      	blt.n	80247aa <fp_submod_ct+0x158>
  }
  /* Result will always have digits equal to or less than those in modulus. */
  d->used = i;
 8024834:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024836:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8024838:	601a      	str	r2, [r3, #0]
  d->sign = FP_ZPOS;
 802483a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802483c:	2200      	movs	r2, #0
 802483e:	605a      	str	r2, [r3, #4]
  fp_clamp(d);
 8024840:	e004      	b.n	802484c <fp_submod_ct+0x1fa>
 8024842:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024844:	681b      	ldr	r3, [r3, #0]
 8024846:	1e5a      	subs	r2, r3, #1
 8024848:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802484a:	601a      	str	r2, [r3, #0]
 802484c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802484e:	681b      	ldr	r3, [r3, #0]
 8024850:	2b00      	cmp	r3, #0
 8024852:	d009      	beq.n	8024868 <fp_submod_ct+0x216>
 8024854:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024856:	681b      	ldr	r3, [r3, #0]
 8024858:	3b01      	subs	r3, #1
 802485a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802485c:	3302      	adds	r3, #2
 802485e:	009b      	lsls	r3, r3, #2
 8024860:	4413      	add	r3, r2
 8024862:	685b      	ldr	r3, [r3, #4]
 8024864:	2b00      	cmp	r3, #0
 8024866:	d0ec      	beq.n	8024842 <fp_submod_ct+0x1f0>
 8024868:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802486a:	681b      	ldr	r3, [r3, #0]
 802486c:	2b00      	cmp	r3, #0
 802486e:	d002      	beq.n	8024876 <fp_submod_ct+0x224>
 8024870:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024872:	685b      	ldr	r3, [r3, #4]
 8024874:	e000      	b.n	8024878 <fp_submod_ct+0x226>
 8024876:	2300      	movs	r3, #0
 8024878:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802487a:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 802487c:	2300      	movs	r3, #0
}
 802487e:	4618      	mov	r0, r3
 8024880:	376c      	adds	r7, #108	@ 0x6c
 8024882:	46bd      	mov	sp, r7
 8024884:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8024888:	4770      	bx	lr

0802488a <fp_addmod_ct>:

/* d = a + b (mod c) - constant time (a < c and b < c and all positive)
 * c and d must not be the same pointers.
 */
int fp_addmod_ct(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 802488a:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 802488e:	b0a5      	sub	sp, #148	@ 0x94
 8024890:	af00      	add	r7, sp, #0
 8024892:	6778      	str	r0, [r7, #116]	@ 0x74
 8024894:	6739      	str	r1, [r7, #112]	@ 0x70
 8024896:	66fa      	str	r2, [r7, #108]	@ 0x6c
 8024898:	66bb      	str	r3, [r7, #104]	@ 0x68
  fp_word  w;
  fp_sword s;
  fp_digit mask;
  int i;

  if (c == d) {
 802489a:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802489c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802489e:	429a      	cmp	r2, r3
 80248a0:	d102      	bne.n	80248a8 <fp_addmod_ct+0x1e>
    return FP_VAL;
 80248a2:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80248a6:	e11d      	b.n	8024ae4 <fp_addmod_ct+0x25a>

  /* Add a to b into d. Do the subtract of modulus but don't store result.
   * When subtract result is negative, the overflow will be negative.
   * Only need to subtract mod when result is positive - overflow is positive.
   */
  w = 0;
 80248a8:	f04f 0200 	mov.w	r2, #0
 80248ac:	f04f 0300 	mov.w	r3, #0
 80248b0:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
  s = 0;
 80248b4:	f04f 0200 	mov.w	r2, #0
 80248b8:	f04f 0300 	mov.w	r3, #0
 80248bc:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
  for (i = 0; i < c->used; i++) {
 80248c0:	2300      	movs	r3, #0
 80248c2:	67fb      	str	r3, [r7, #124]	@ 0x7c
 80248c4:	e06f      	b.n	80249a6 <fp_addmod_ct+0x11c>
    w         += a->dp[i];
 80248c6:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80248c8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80248ca:	3302      	adds	r3, #2
 80248cc:	009b      	lsls	r3, r3, #2
 80248ce:	4413      	add	r3, r2
 80248d0:	685b      	ldr	r3, [r3, #4]
 80248d2:	2200      	movs	r2, #0
 80248d4:	663b      	str	r3, [r7, #96]	@ 0x60
 80248d6:	667a      	str	r2, [r7, #100]	@ 0x64
 80248d8:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 80248dc:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80248de:	1851      	adds	r1, r2, r1
 80248e0:	6439      	str	r1, [r7, #64]	@ 0x40
 80248e2:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 80248e4:	414b      	adcs	r3, r1
 80248e6:	647b      	str	r3, [r7, #68]	@ 0x44
 80248e8:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80248ec:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    w         += b->dp[i];
 80248f0:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80248f2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80248f4:	3302      	adds	r3, #2
 80248f6:	009b      	lsls	r3, r3, #2
 80248f8:	4413      	add	r3, r2
 80248fa:	685b      	ldr	r3, [r3, #4]
 80248fc:	2200      	movs	r2, #0
 80248fe:	65bb      	str	r3, [r7, #88]	@ 0x58
 8024900:	65fa      	str	r2, [r7, #92]	@ 0x5c
 8024902:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8024906:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 8024908:	1851      	adds	r1, r2, r1
 802490a:	63b9      	str	r1, [r7, #56]	@ 0x38
 802490c:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 802490e:	414b      	adcs	r3, r1
 8024910:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8024912:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 8024916:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    d->dp[i]   = (fp_digit)w;
 802491a:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 802491e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024920:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024922:	3302      	adds	r3, #2
 8024924:	009b      	lsls	r3, r3, #2
 8024926:	4413      	add	r3, r2
 8024928:	6059      	str	r1, [r3, #4]
    s         += (fp_digit)w;
 802492a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 802492e:	2200      	movs	r2, #0
 8024930:	653b      	str	r3, [r7, #80]	@ 0x50
 8024932:	657a      	str	r2, [r7, #84]	@ 0x54
 8024934:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8024938:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 802493a:	1851      	adds	r1, r2, r1
 802493c:	6339      	str	r1, [r7, #48]	@ 0x30
 802493e:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8024940:	414b      	adcs	r3, r1
 8024942:	637b      	str	r3, [r7, #52]	@ 0x34
 8024944:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8024948:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
    s         -= c->dp[i];
 802494c:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802494e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024950:	3302      	adds	r3, #2
 8024952:	009b      	lsls	r3, r3, #2
 8024954:	4413      	add	r3, r2
 8024956:	685b      	ldr	r3, [r3, #4]
 8024958:	2200      	movs	r2, #0
 802495a:	64bb      	str	r3, [r7, #72]	@ 0x48
 802495c:	64fa      	str	r2, [r7, #76]	@ 0x4c
 802495e:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8024962:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8024964:	1a51      	subs	r1, r2, r1
 8024966:	62b9      	str	r1, [r7, #40]	@ 0x28
 8024968:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 802496a:	eb63 0301 	sbc.w	r3, r3, r1
 802496e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024970:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8024974:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
    w        >>= DIGIT_BIT;
 8024978:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 802497c:	f04f 0000 	mov.w	r0, #0
 8024980:	f04f 0100 	mov.w	r1, #0
 8024984:	0018      	movs	r0, r3
 8024986:	2100      	movs	r1, #0
 8024988:	e9c7 0122 	strd	r0, r1, [r7, #136]	@ 0x88
    s        >>= DIGIT_BIT;
 802498c:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8024990:	f04f 0000 	mov.w	r0, #0
 8024994:	f04f 0100 	mov.w	r1, #0
 8024998:	0018      	movs	r0, r3
 802499a:	17d9      	asrs	r1, r3, #31
 802499c:	e9c7 0120 	strd	r0, r1, [r7, #128]	@ 0x80
  for (i = 0; i < c->used; i++) {
 80249a0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80249a2:	3301      	adds	r3, #1
 80249a4:	67fb      	str	r3, [r7, #124]	@ 0x7c
 80249a6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80249a8:	681a      	ldr	r2, [r3, #0]
 80249aa:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80249ac:	4293      	cmp	r3, r2
 80249ae:	db8a      	blt.n	80248c6 <fp_addmod_ct+0x3c>
  }
  s += (fp_digit)w;
 80249b0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80249b4:	2200      	movs	r2, #0
 80249b6:	469a      	mov	sl, r3
 80249b8:	4693      	mov	fp, r2
 80249ba:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 80249be:	eb12 010a 	adds.w	r1, r2, sl
 80249c2:	6239      	str	r1, [r7, #32]
 80249c4:	eb43 030b 	adc.w	r3, r3, fp
 80249c8:	627b      	str	r3, [r7, #36]	@ 0x24
 80249ca:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80249ce:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
  /* s will be positive when subtracting modulus is needed. */
  mask = (fp_digit)0 - (s >= 0);
 80249d2:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 80249d6:	43d1      	mvns	r1, r2
 80249d8:	61b9      	str	r1, [r7, #24]
 80249da:	43db      	mvns	r3, r3
 80249dc:	61fb      	str	r3, [r7, #28]
 80249de:	f04f 0200 	mov.w	r2, #0
 80249e2:	f04f 0300 	mov.w	r3, #0
 80249e6:	69f9      	ldr	r1, [r7, #28]
 80249e8:	0fca      	lsrs	r2, r1, #31
 80249ea:	2300      	movs	r3, #0
 80249ec:	b2d3      	uxtb	r3, r2
 80249ee:	425b      	negs	r3, r3
 80249f0:	67bb      	str	r3, [r7, #120]	@ 0x78

  /* Constant time, conditionally, subtract modulus from sum. */
  w = 0;
 80249f2:	f04f 0200 	mov.w	r2, #0
 80249f6:	f04f 0300 	mov.w	r3, #0
 80249fa:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
  for (i = 0; i < c->used; i++) {
 80249fe:	2300      	movs	r3, #0
 8024a00:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8024a02:	e045      	b.n	8024a90 <fp_addmod_ct+0x206>
    w        += c->dp[i] & mask;
 8024a04:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8024a06:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024a08:	3302      	adds	r3, #2
 8024a0a:	009b      	lsls	r3, r3, #2
 8024a0c:	4413      	add	r3, r2
 8024a0e:	685a      	ldr	r2, [r3, #4]
 8024a10:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8024a12:	4013      	ands	r3, r2
 8024a14:	2200      	movs	r2, #0
 8024a16:	461c      	mov	r4, r3
 8024a18:	4615      	mov	r5, r2
 8024a1a:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8024a1e:	1911      	adds	r1, r2, r4
 8024a20:	6139      	str	r1, [r7, #16]
 8024a22:	416b      	adcs	r3, r5
 8024a24:	617b      	str	r3, [r7, #20]
 8024a26:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8024a2a:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    w         = d->dp[i] - w;
 8024a2e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024a30:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024a32:	3302      	adds	r3, #2
 8024a34:	009b      	lsls	r3, r3, #2
 8024a36:	4413      	add	r3, r2
 8024a38:	685b      	ldr	r3, [r3, #4]
 8024a3a:	2200      	movs	r2, #0
 8024a3c:	4698      	mov	r8, r3
 8024a3e:	4691      	mov	r9, r2
 8024a40:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8024a44:	ebb8 0102 	subs.w	r1, r8, r2
 8024a48:	60b9      	str	r1, [r7, #8]
 8024a4a:	eb69 0303 	sbc.w	r3, r9, r3
 8024a4e:	60fb      	str	r3, [r7, #12]
 8024a50:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8024a54:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    d->dp[i]  = (fp_digit)w;
 8024a58:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8024a5c:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8024a5e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024a60:	3302      	adds	r3, #2
 8024a62:	009b      	lsls	r3, r3, #2
 8024a64:	440b      	add	r3, r1
 8024a66:	605a      	str	r2, [r3, #4]
    w         = (w >> DIGIT_BIT)&1;
 8024a68:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
 8024a6c:	f04f 0200 	mov.w	r2, #0
 8024a70:	f04f 0300 	mov.w	r3, #0
 8024a74:	000a      	movs	r2, r1
 8024a76:	2300      	movs	r3, #0
 8024a78:	f002 0301 	and.w	r3, r2, #1
 8024a7c:	603b      	str	r3, [r7, #0]
 8024a7e:	2300      	movs	r3, #0
 8024a80:	607b      	str	r3, [r7, #4]
 8024a82:	e9d7 2300 	ldrd	r2, r3, [r7]
 8024a86:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
  for (i = 0; i < c->used; i++) {
 8024a8a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024a8c:	3301      	adds	r3, #1
 8024a8e:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8024a90:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024a92:	681b      	ldr	r3, [r3, #0]
 8024a94:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8024a96:	429a      	cmp	r2, r3
 8024a98:	dbb4      	blt.n	8024a04 <fp_addmod_ct+0x17a>
  }
  /* Result will always have digits equal to or less than those in modulus. */
  d->used = i;
 8024a9a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024a9c:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8024a9e:	601a      	str	r2, [r3, #0]
  d->sign = FP_ZPOS;
 8024aa0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024aa2:	2200      	movs	r2, #0
 8024aa4:	605a      	str	r2, [r3, #4]
  fp_clamp(d);
 8024aa6:	e004      	b.n	8024ab2 <fp_addmod_ct+0x228>
 8024aa8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024aaa:	681b      	ldr	r3, [r3, #0]
 8024aac:	1e5a      	subs	r2, r3, #1
 8024aae:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ab0:	601a      	str	r2, [r3, #0]
 8024ab2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ab4:	681b      	ldr	r3, [r3, #0]
 8024ab6:	2b00      	cmp	r3, #0
 8024ab8:	d009      	beq.n	8024ace <fp_addmod_ct+0x244>
 8024aba:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024abc:	681b      	ldr	r3, [r3, #0]
 8024abe:	3b01      	subs	r3, #1
 8024ac0:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024ac2:	3302      	adds	r3, #2
 8024ac4:	009b      	lsls	r3, r3, #2
 8024ac6:	4413      	add	r3, r2
 8024ac8:	685b      	ldr	r3, [r3, #4]
 8024aca:	2b00      	cmp	r3, #0
 8024acc:	d0ec      	beq.n	8024aa8 <fp_addmod_ct+0x21e>
 8024ace:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ad0:	681b      	ldr	r3, [r3, #0]
 8024ad2:	2b00      	cmp	r3, #0
 8024ad4:	d002      	beq.n	8024adc <fp_addmod_ct+0x252>
 8024ad6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ad8:	685b      	ldr	r3, [r3, #4]
 8024ada:	e000      	b.n	8024ade <fp_addmod_ct+0x254>
 8024adc:	2300      	movs	r3, #0
 8024ade:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024ae0:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 8024ae2:	2300      	movs	r3, #0
}
 8024ae4:	4618      	mov	r0, r3
 8024ae6:	3794      	adds	r7, #148	@ 0x94
 8024ae8:	46bd      	mov	sp, r7
 8024aea:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8024aee:	4770      	bx	lr

08024af0 <_fp_exptmod_ct>:
   Based on work by Marc Joye, Sung-Ming Yen, "The Montgomery Powering Ladder",
   Cryptographic Hardware and Embedded Systems, CHES 2002
*/
static int _fp_exptmod_ct(fp_int * G, fp_int * X, int digits, fp_int * P,
                          fp_int * Y)
{
 8024af0:	b590      	push	{r4, r7, lr}
 8024af2:	b095      	sub	sp, #84	@ 0x54
 8024af4:	af00      	add	r7, sp, #0
 8024af6:	60f8      	str	r0, [r7, #12]
 8024af8:	60b9      	str	r1, [r7, #8]
 8024afa:	607a      	str	r2, [r7, #4]
 8024afc:	603b      	str	r3, [r7, #0]
#endif
  fp_digit buf, mp;
  int      err, bitcnt, digidx, y;

  /* now setup montgomery  */
  if ((err = fp_montgomery_setup (P, &mp)) != FP_OKAY) {
 8024afe:	f107 0314 	add.w	r3, r7, #20
 8024b02:	4619      	mov	r1, r3
 8024b04:	6838      	ldr	r0, [r7, #0]
 8024b06:	f001 fa0b 	bl	8025f20 <fp_montgomery_setup>
 8024b0a:	6438      	str	r0, [r7, #64]	@ 0x40
 8024b0c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024b0e:	2b00      	cmp	r3, #0
 8024b10:	d001      	beq.n	8024b16 <_fp_exptmod_ct+0x26>
     return err;
 8024b12:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024b14:	e146      	b.n	8024da4 <_fp_exptmod_ct+0x2b4>
  }

#ifdef WOLFSSL_SMALL_STACK
#ifndef WC_NO_CACHE_RESISTANT
   R = (fp_int*)XMALLOC(sizeof(fp_int) * 3, NULL, DYNAMIC_TYPE_BIGINT);
 8024b16:	f240 6084 	movw	r0, #1668	@ 0x684
 8024b1a:	f7fa f8af 	bl	801ec7c <wolfSSL_Malloc>
 8024b1e:	63f8      	str	r0, [r7, #60]	@ 0x3c
#else
   R = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_BIGINT);
#endif
   if (R == NULL)
 8024b20:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024b22:	2b00      	cmp	r3, #0
 8024b24:	d102      	bne.n	8024b2c <_fp_exptmod_ct+0x3c>
       return FP_MEM;
 8024b26:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8024b2a:	e13b      	b.n	8024da4 <_fp_exptmod_ct+0x2b4>
#endif
  fp_init(&R[0]);
 8024b2c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024b2e:	f001 ff63 	bl	80269f8 <fp_init>
  fp_init(&R[1]);
 8024b32:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024b34:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024b38:	4618      	mov	r0, r3
 8024b3a:	f001 ff5d 	bl	80269f8 <fp_init>
#ifndef WC_NO_CACHE_RESISTANT
  fp_init(&R[2]);
 8024b3e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024b40:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024b44:	4618      	mov	r0, r3
 8024b46:	f001 ff57 	bl	80269f8 <fp_init>
#endif

  /* now we need R mod m */
  err = fp_montgomery_calc_normalization (&R[0], P);
 8024b4a:	6839      	ldr	r1, [r7, #0]
 8024b4c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024b4e:	f001 fa28 	bl	8025fa2 <fp_montgomery_calc_normalization>
 8024b52:	6438      	str	r0, [r7, #64]	@ 0x40
  if (err != FP_OKAY) {
 8024b54:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024b56:	2b00      	cmp	r3, #0
 8024b58:	d009      	beq.n	8024b6e <_fp_exptmod_ct+0x7e>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024b5a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024b5c:	61bb      	str	r3, [r7, #24]
 8024b5e:	69bb      	ldr	r3, [r7, #24]
 8024b60:	2b00      	cmp	r3, #0
 8024b62:	d002      	beq.n	8024b6a <_fp_exptmod_ct+0x7a>
 8024b64:	69b8      	ldr	r0, [r7, #24]
 8024b66:	f7fa f8a5 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return err;
 8024b6a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024b6c:	e11a      	b.n	8024da4 <_fp_exptmod_ct+0x2b4>
  }

  /* now set R[0][1] to G * R mod m */
  if (fp_cmp_mag(P, G) != FP_GT) {
 8024b6e:	68f9      	ldr	r1, [r7, #12]
 8024b70:	6838      	ldr	r0, [r7, #0]
 8024b72:	f001 f98c 	bl	8025e8e <fp_cmp_mag>
 8024b76:	4603      	mov	r3, r0
 8024b78:	2b01      	cmp	r3, #1
 8024b7a:	d015      	beq.n	8024ba8 <_fp_exptmod_ct+0xb8>
     /* G > P so we reduce it first */
     err = fp_mod(G, P, &R[1]);
 8024b7c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024b7e:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024b82:	461a      	mov	r2, r3
 8024b84:	6839      	ldr	r1, [r7, #0]
 8024b86:	68f8      	ldr	r0, [r7, #12]
 8024b88:	f7fe fec6 	bl	8023918 <fp_mod>
 8024b8c:	6438      	str	r0, [r7, #64]	@ 0x40
     if (err != FP_OKAY) {
 8024b8e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024b90:	2b00      	cmp	r3, #0
 8024b92:	d010      	beq.n	8024bb6 <_fp_exptmod_ct+0xc6>
#ifdef WOLFSSL_SMALL_STACK
         XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024b94:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024b96:	63bb      	str	r3, [r7, #56]	@ 0x38
 8024b98:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8024b9a:	2b00      	cmp	r3, #0
 8024b9c:	d002      	beq.n	8024ba4 <_fp_exptmod_ct+0xb4>
 8024b9e:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8024ba0:	f7fa f888 	bl	801ecb4 <wolfSSL_Free>
#endif
         return err;
 8024ba4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024ba6:	e0fd      	b.n	8024da4 <_fp_exptmod_ct+0x2b4>
     }
  } else {
     fp_copy(G, &R[1]);
 8024ba8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024baa:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024bae:	4619      	mov	r1, r3
 8024bb0:	68f8      	ldr	r0, [r7, #12]
 8024bb2:	f002 f90b 	bl	8026dcc <fp_copy>
  }
  err = fp_mulmod (&R[1], &R[0], P, &R[1]);
 8024bb6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024bb8:	f503 700b 	add.w	r0, r3, #556	@ 0x22c
 8024bbc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024bbe:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024bc2:	683a      	ldr	r2, [r7, #0]
 8024bc4:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8024bc6:	f7ff fd04 	bl	80245d2 <fp_mulmod>
 8024bca:	6438      	str	r0, [r7, #64]	@ 0x40
  if (err != FP_OKAY) {
 8024bcc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024bce:	2b00      	cmp	r3, #0
 8024bd0:	d009      	beq.n	8024be6 <_fp_exptmod_ct+0xf6>
#ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024bd2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024bd4:	61fb      	str	r3, [r7, #28]
 8024bd6:	69fb      	ldr	r3, [r7, #28]
 8024bd8:	2b00      	cmp	r3, #0
 8024bda:	d002      	beq.n	8024be2 <_fp_exptmod_ct+0xf2>
 8024bdc:	69f8      	ldr	r0, [r7, #28]
 8024bde:	f7fa f869 	bl	801ecb4 <wolfSSL_Free>
#endif
      return err;
 8024be2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024be4:	e0de      	b.n	8024da4 <_fp_exptmod_ct+0x2b4>
  /* for j = t-1 downto 0 do
        r_!k = R0*R1; r_k = r_k^2
  */

  /* set initial mode and bit cnt */
  bitcnt = 1;
 8024be6:	2301      	movs	r3, #1
 8024be8:	64bb      	str	r3, [r7, #72]	@ 0x48
  buf    = 0;
 8024bea:	2300      	movs	r3, #0
 8024bec:	64fb      	str	r3, [r7, #76]	@ 0x4c
  digidx = digits - 1;
 8024bee:	687b      	ldr	r3, [r7, #4]
 8024bf0:	3b01      	subs	r3, #1
 8024bf2:	647b      	str	r3, [r7, #68]	@ 0x44

  for (;;) {
    /* grab next digit as required */
    if (--bitcnt == 0) {
 8024bf4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024bf6:	3b01      	subs	r3, #1
 8024bf8:	64bb      	str	r3, [r7, #72]	@ 0x48
 8024bfa:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024bfc:	2b00      	cmp	r3, #0
 8024bfe:	d10f      	bne.n	8024c20 <_fp_exptmod_ct+0x130>
      /* if digidx == -1 we are out of digits so break */
      if (digidx == -1) {
 8024c00:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024c02:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8024c06:	f000 80b8 	beq.w	8024d7a <_fp_exptmod_ct+0x28a>
        break;
      }
      /* read next digit and reset bitcnt */
      buf    = X->dp[digidx--];
 8024c0a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024c0c:	1e5a      	subs	r2, r3, #1
 8024c0e:	647a      	str	r2, [r7, #68]	@ 0x44
 8024c10:	68ba      	ldr	r2, [r7, #8]
 8024c12:	3302      	adds	r3, #2
 8024c14:	009b      	lsls	r3, r3, #2
 8024c16:	4413      	add	r3, r2
 8024c18:	685b      	ldr	r3, [r3, #4]
 8024c1a:	64fb      	str	r3, [r7, #76]	@ 0x4c
      bitcnt = (int)DIGIT_BIT;
 8024c1c:	2320      	movs	r3, #32
 8024c1e:	64bb      	str	r3, [r7, #72]	@ 0x48
    }

    /* grab the next msb from the exponent */
    y     = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 8024c20:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8024c22:	0fdb      	lsrs	r3, r3, #31
 8024c24:	633b      	str	r3, [r7, #48]	@ 0x30
    buf <<= (fp_digit)1;
 8024c26:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8024c28:	005b      	lsls	r3, r3, #1
 8024c2a:	64fb      	str	r3, [r7, #76]	@ 0x4c
    #endif
      return err;
    }
#else
    /* do ops */
    err = fp_mul(&R[0], &R[1], &R[2]);
 8024c2c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024c2e:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 8024c32:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024c34:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024c38:	461a      	mov	r2, r3
 8024c3a:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024c3c:	f7fd fed3 	bl	80229e6 <fp_mul>
 8024c40:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 8024c42:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024c44:	2b00      	cmp	r3, #0
 8024c46:	d009      	beq.n	8024c5c <_fp_exptmod_ct+0x16c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024c48:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024c4a:	623b      	str	r3, [r7, #32]
 8024c4c:	6a3b      	ldr	r3, [r7, #32]
 8024c4e:	2b00      	cmp	r3, #0
 8024c50:	d002      	beq.n	8024c58 <_fp_exptmod_ct+0x168>
 8024c52:	6a38      	ldr	r0, [r7, #32]
 8024c54:	f7fa f82e 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8024c58:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024c5a:	e0a3      	b.n	8024da4 <_fp_exptmod_ct+0x2b4>
    }
    err = fp_montgomery_reduce(&R[2], P, mp);
 8024c5c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024c5e:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024c62:	697a      	ldr	r2, [r7, #20]
 8024c64:	6839      	ldr	r1, [r7, #0]
 8024c66:	4618      	mov	r0, r3
 8024c68:	f001 fb21 	bl	80262ae <fp_montgomery_reduce>
 8024c6c:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 8024c6e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024c70:	2b00      	cmp	r3, #0
 8024c72:	d009      	beq.n	8024c88 <_fp_exptmod_ct+0x198>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024c74:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024c76:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c7a:	2b00      	cmp	r3, #0
 8024c7c:	d002      	beq.n	8024c84 <_fp_exptmod_ct+0x194>
 8024c7e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8024c80:	f7fa f818 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8024c84:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024c86:	e08d      	b.n	8024da4 <_fp_exptmod_ct+0x2b4>
    }
    /* instead of using R[y^1] for mul, which leaks key bit to cache monitor,
     * use R[2] as temp, make sure address calc is constant, keep
     * &R[0] and &R[1] in cache */
    fp_copy(&R[2],
 8024c88:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024c8a:	f503 608b 	add.w	r0, r3, #1112	@ 0x458
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y]) +
 8024c8e:	4a47      	ldr	r2, [pc, #284]	@ (8024dac <_fp_exptmod_ct+0x2bc>)
 8024c90:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024c92:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8024c96:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024c98:	401a      	ands	r2, r3
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y^1]) ) );
 8024c9a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024c9c:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024ca0:	461c      	mov	r4, r3
 8024ca2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024ca4:	f083 0301 	eor.w	r3, r3, #1
 8024ca8:	4940      	ldr	r1, [pc, #256]	@ (8024dac <_fp_exptmod_ct+0x2bc>)
 8024caa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8024cae:	4023      	ands	r3, r4
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y]) +
 8024cb0:	4413      	add	r3, r2
    fp_copy(&R[2],
 8024cb2:	4619      	mov	r1, r3
 8024cb4:	f002 f88a 	bl	8026dcc <fp_copy>

    /* instead of using R[y] for sqr, which leaks key bit to cache monitor,
     * use R[2] as temp, make sure address calc is constant, keep
     * &R[0] and &R[1] in cache */
    fp_copy((fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 8024cb8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024cba:	f083 0301 	eor.w	r3, r3, #1
 8024cbe:	4a3b      	ldr	r2, [pc, #236]	@ (8024dac <_fp_exptmod_ct+0x2bc>)
 8024cc0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8024cc4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024cc6:	401a      	ands	r2, r3
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y]) ),
 8024cc8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024cca:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024cce:	4618      	mov	r0, r3
 8024cd0:	4936      	ldr	r1, [pc, #216]	@ (8024dac <_fp_exptmod_ct+0x2bc>)
 8024cd2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024cd4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8024cd8:	4003      	ands	r3, r0
    fp_copy((fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 8024cda:	4413      	add	r3, r2
 8024cdc:	461a      	mov	r2, r3
 8024cde:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024ce0:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024ce4:	4619      	mov	r1, r3
 8024ce6:	4610      	mov	r0, r2
 8024ce8:	f002 f870 	bl	8026dcc <fp_copy>
            &R[2]);
    err = fp_sqr(&R[2], &R[2]);
 8024cec:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024cee:	f503 628b 	add.w	r2, r3, #1112	@ 0x458
 8024cf2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024cf4:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024cf8:	4619      	mov	r1, r3
 8024cfa:	4610      	mov	r0, r2
 8024cfc:	f000 fe1b 	bl	8025936 <fp_sqr>
 8024d00:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 8024d02:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024d04:	2b00      	cmp	r3, #0
 8024d06:	d009      	beq.n	8024d1c <_fp_exptmod_ct+0x22c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024d08:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024d0a:	62bb      	str	r3, [r7, #40]	@ 0x28
 8024d0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8024d0e:	2b00      	cmp	r3, #0
 8024d10:	d002      	beq.n	8024d18 <_fp_exptmod_ct+0x228>
 8024d12:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8024d14:	f7f9 ffce 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8024d18:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024d1a:	e043      	b.n	8024da4 <_fp_exptmod_ct+0x2b4>
    }
    err = fp_montgomery_reduce(&R[2], P, mp);
 8024d1c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024d1e:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024d22:	697a      	ldr	r2, [r7, #20]
 8024d24:	6839      	ldr	r1, [r7, #0]
 8024d26:	4618      	mov	r0, r3
 8024d28:	f001 fac1 	bl	80262ae <fp_montgomery_reduce>
 8024d2c:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 8024d2e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024d30:	2b00      	cmp	r3, #0
 8024d32:	d009      	beq.n	8024d48 <_fp_exptmod_ct+0x258>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024d34:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024d36:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024d38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024d3a:	2b00      	cmp	r3, #0
 8024d3c:	d002      	beq.n	8024d44 <_fp_exptmod_ct+0x254>
 8024d3e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8024d40:	f7f9 ffb8 	bl	801ecb4 <wolfSSL_Free>
    #endif
      return err;
 8024d44:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024d46:	e02d      	b.n	8024da4 <_fp_exptmod_ct+0x2b4>
    }
    fp_copy(&R[2],
 8024d48:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024d4a:	f503 608b 	add.w	r0, r3, #1112	@ 0x458
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 8024d4e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024d50:	f083 0301 	eor.w	r3, r3, #1
 8024d54:	4a15      	ldr	r2, [pc, #84]	@ (8024dac <_fp_exptmod_ct+0x2bc>)
 8024d56:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8024d5a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024d5c:	401a      	ands	r2, r3
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y]) ) );
 8024d5e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024d60:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024d64:	461c      	mov	r4, r3
 8024d66:	4911      	ldr	r1, [pc, #68]	@ (8024dac <_fp_exptmod_ct+0x2bc>)
 8024d68:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024d6a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8024d6e:	4023      	ands	r3, r4
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 8024d70:	4413      	add	r3, r2
    fp_copy(&R[2],
 8024d72:	4619      	mov	r1, r3
 8024d74:	f002 f82a 	bl	8026dcc <fp_copy>
    if (--bitcnt == 0) {
 8024d78:	e73c      	b.n	8024bf4 <_fp_exptmod_ct+0x104>
        break;
 8024d7a:	bf00      	nop
#endif /* WC_NO_CACHE_RESISTANT */
  }

   err = fp_montgomery_reduce(&R[0], P, mp);
 8024d7c:	697b      	ldr	r3, [r7, #20]
 8024d7e:	461a      	mov	r2, r3
 8024d80:	6839      	ldr	r1, [r7, #0]
 8024d82:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024d84:	f001 fa93 	bl	80262ae <fp_montgomery_reduce>
 8024d88:	6438      	str	r0, [r7, #64]	@ 0x40
   fp_copy(&R[0], Y);
 8024d8a:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8024d8c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024d8e:	f002 f81d 	bl	8026dcc <fp_copy>
#ifdef WOLFSSL_SMALL_STACK
   XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024d92:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024d94:	637b      	str	r3, [r7, #52]	@ 0x34
 8024d96:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8024d98:	2b00      	cmp	r3, #0
 8024d9a:	d002      	beq.n	8024da2 <_fp_exptmod_ct+0x2b2>
 8024d9c:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8024d9e:	f7f9 ff89 	bl	801ecb4 <wolfSSL_Free>
#endif

   return err;
 8024da2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
}
 8024da4:	4618      	mov	r0, r3
 8024da6:	3754      	adds	r7, #84	@ 0x54
 8024da8:	46bd      	mov	sp, r7
 8024daa:	bd90      	pop	{r4, r7, pc}
 8024dac:	08034bf0 	.word	0x08034bf0

08024db0 <_fp_exptmod_nct>:

/* y = g**x (mod b)
 * Some restrictions... x must be positive and < b
 */
static int _fp_exptmod_nct(fp_int * G, fp_int * X, fp_int * P, fp_int * Y)
{
 8024db0:	b580      	push	{r7, lr}
 8024db2:	b0a4      	sub	sp, #144	@ 0x90
 8024db4:	af00      	add	r7, sp, #0
 8024db6:	60f8      	str	r0, [r7, #12]
 8024db8:	60b9      	str	r1, [r7, #8]
 8024dba:	607a      	str	r2, [r7, #4]
 8024dbc:	603b      	str	r3, [r7, #0]
#else
  fp_int   M[(1 << 6) + 1];
#endif

  /* find window size */
  x = fp_count_bits (X);
 8024dbe:	68b8      	ldr	r0, [r7, #8]
 8024dc0:	f001 fc2e 	bl	8026620 <fp_count_bits>
 8024dc4:	6778      	str	r0, [r7, #116]	@ 0x74
  if (x <= 21) {
 8024dc6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024dc8:	2b15      	cmp	r3, #21
 8024dca:	dc02      	bgt.n	8024dd2 <_fp_exptmod_nct+0x22>
    winsize = 1;
 8024dcc:	2301      	movs	r3, #1
 8024dce:	673b      	str	r3, [r7, #112]	@ 0x70
 8024dd0:	e014      	b.n	8024dfc <_fp_exptmod_nct+0x4c>
  } else if (x <= 36) {
 8024dd2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024dd4:	2b24      	cmp	r3, #36	@ 0x24
 8024dd6:	dc02      	bgt.n	8024dde <_fp_exptmod_nct+0x2e>
    winsize = 3;
 8024dd8:	2303      	movs	r3, #3
 8024dda:	673b      	str	r3, [r7, #112]	@ 0x70
 8024ddc:	e00e      	b.n	8024dfc <_fp_exptmod_nct+0x4c>
  } else if (x <= 140) {
 8024dde:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024de0:	2b8c      	cmp	r3, #140	@ 0x8c
 8024de2:	dc02      	bgt.n	8024dea <_fp_exptmod_nct+0x3a>
    winsize = 4;
 8024de4:	2304      	movs	r3, #4
 8024de6:	673b      	str	r3, [r7, #112]	@ 0x70
 8024de8:	e008      	b.n	8024dfc <_fp_exptmod_nct+0x4c>
  } else if (x <= 450) {
 8024dea:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024dec:	f5b3 7fe1 	cmp.w	r3, #450	@ 0x1c2
 8024df0:	dc02      	bgt.n	8024df8 <_fp_exptmod_nct+0x48>
    winsize = 5;
 8024df2:	2305      	movs	r3, #5
 8024df4:	673b      	str	r3, [r7, #112]	@ 0x70
 8024df6:	e001      	b.n	8024dfc <_fp_exptmod_nct+0x4c>
  } else {
    winsize = 6;
 8024df8:	2306      	movs	r3, #6
 8024dfa:	673b      	str	r3, [r7, #112]	@ 0x70
  }

  /* now setup montgomery  */
  if ((err = fp_montgomery_setup (P, &mp)) != FP_OKAY) {
 8024dfc:	f107 0314 	add.w	r3, r7, #20
 8024e00:	4619      	mov	r1, r3
 8024e02:	6878      	ldr	r0, [r7, #4]
 8024e04:	f001 f88c 	bl	8025f20 <fp_montgomery_setup>
 8024e08:	66f8      	str	r0, [r7, #108]	@ 0x6c
 8024e0a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e0c:	2b00      	cmp	r3, #0
 8024e0e:	d001      	beq.n	8024e14 <_fp_exptmod_nct+0x64>
     return err;
 8024e10:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e12:	e2a3      	b.n	802535c <_fp_exptmod_nct+0x5ac>
  }

#ifndef WOLFSSL_NO_MALLOC
  /* only allocate space for what's needed for window plus res */
  M = (fp_int*)XMALLOC(sizeof(fp_int)*((1 << winsize) + 1), NULL,
 8024e14:	2201      	movs	r2, #1
 8024e16:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024e18:	fa02 f303 	lsl.w	r3, r2, r3
 8024e1c:	3301      	adds	r3, #1
 8024e1e:	461a      	mov	r2, r3
 8024e20:	f44f 730b 	mov.w	r3, #556	@ 0x22c
 8024e24:	fb02 f303 	mul.w	r3, r2, r3
 8024e28:	4618      	mov	r0, r3
 8024e2a:	f7f9 ff27 	bl	801ec7c <wolfSSL_Malloc>
 8024e2e:	66b8      	str	r0, [r7, #104]	@ 0x68
                                                           DYNAMIC_TYPE_BIGINT);
  if (M == NULL) {
 8024e30:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024e32:	2b00      	cmp	r3, #0
 8024e34:	d102      	bne.n	8024e3c <_fp_exptmod_nct+0x8c>
     return FP_MEM;
 8024e36:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8024e3a:	e28f      	b.n	802535c <_fp_exptmod_nct+0x5ac>
  }
#endif
  res = &M[(word32)(1 << winsize)];
 8024e3c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024e40:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024e42:	fa02 f303 	lsl.w	r3, r2, r3
 8024e46:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024e48:	4413      	add	r3, r2
 8024e4a:	667b      	str	r3, [r7, #100]	@ 0x64

  /* init M array */
  for(x = 0; x < (1 << winsize); x++)
 8024e4c:	2300      	movs	r3, #0
 8024e4e:	677b      	str	r3, [r7, #116]	@ 0x74
 8024e50:	e00c      	b.n	8024e6c <_fp_exptmod_nct+0xbc>
    fp_init(&M[x]);
 8024e52:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024e54:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024e58:	fb02 f303 	mul.w	r3, r2, r3
 8024e5c:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024e5e:	4413      	add	r3, r2
 8024e60:	4618      	mov	r0, r3
 8024e62:	f001 fdc9 	bl	80269f8 <fp_init>
  for(x = 0; x < (1 << winsize); x++)
 8024e66:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024e68:	3301      	adds	r3, #1
 8024e6a:	677b      	str	r3, [r7, #116]	@ 0x74
 8024e6c:	2201      	movs	r2, #1
 8024e6e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024e70:	fa02 f303 	lsl.w	r3, r2, r3
 8024e74:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024e76:	429a      	cmp	r2, r3
 8024e78:	dbeb      	blt.n	8024e52 <_fp_exptmod_nct+0xa2>

  /* setup result */
  fp_init(res);
 8024e7a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024e7c:	f001 fdbc 	bl	80269f8 <fp_init>
   *
   * The first half of the table is not computed though except for M[0] and M[1]
   */

  /* now we need R mod m */
  err = fp_montgomery_calc_normalization (res, P);
 8024e80:	6879      	ldr	r1, [r7, #4]
 8024e82:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024e84:	f001 f88d 	bl	8025fa2 <fp_montgomery_calc_normalization>
 8024e88:	66f8      	str	r0, [r7, #108]	@ 0x6c
  if (err != FP_OKAY) {
 8024e8a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e8c:	2b00      	cmp	r3, #0
 8024e8e:	d009      	beq.n	8024ea4 <_fp_exptmod_nct+0xf4>
#ifndef WOLFSSL_NO_MALLOC
    XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024e90:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024e92:	61bb      	str	r3, [r7, #24]
 8024e94:	69bb      	ldr	r3, [r7, #24]
 8024e96:	2b00      	cmp	r3, #0
 8024e98:	d002      	beq.n	8024ea0 <_fp_exptmod_nct+0xf0>
 8024e9a:	69b8      	ldr	r0, [r7, #24]
 8024e9c:	f7f9 ff0a 	bl	801ecb4 <wolfSSL_Free>
#endif
    return err;
 8024ea0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ea2:	e25b      	b.n	802535c <_fp_exptmod_nct+0x5ac>
  }

  /* now set M[1] to G * R mod m */
  if (fp_cmp_mag(P, G) != FP_GT) {
 8024ea4:	68f9      	ldr	r1, [r7, #12]
 8024ea6:	6878      	ldr	r0, [r7, #4]
 8024ea8:	f000 fff1 	bl	8025e8e <fp_cmp_mag>
 8024eac:	4603      	mov	r3, r0
 8024eae:	2b01      	cmp	r3, #1
 8024eb0:	d015      	beq.n	8024ede <_fp_exptmod_nct+0x12e>
     /* G > P so we reduce it first */
     err = fp_mod(G, P, &M[1]);
 8024eb2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024eb4:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024eb8:	461a      	mov	r2, r3
 8024eba:	6879      	ldr	r1, [r7, #4]
 8024ebc:	68f8      	ldr	r0, [r7, #12]
 8024ebe:	f7fe fd2b 	bl	8023918 <fp_mod>
 8024ec2:	66f8      	str	r0, [r7, #108]	@ 0x6c
     if (err != FP_OKAY) {
 8024ec4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ec6:	2b00      	cmp	r3, #0
 8024ec8:	d010      	beq.n	8024eec <_fp_exptmod_nct+0x13c>
     #ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024eca:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ecc:	663b      	str	r3, [r7, #96]	@ 0x60
 8024ece:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8024ed0:	2b00      	cmp	r3, #0
 8024ed2:	d002      	beq.n	8024eda <_fp_exptmod_nct+0x12a>
 8024ed4:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8024ed6:	f7f9 feed 	bl	801ecb4 <wolfSSL_Free>
     #endif
        return err;
 8024eda:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024edc:	e23e      	b.n	802535c <_fp_exptmod_nct+0x5ac>
     }
  } else {
     fp_copy(G, &M[1]);
 8024ede:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ee0:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024ee4:	4619      	mov	r1, r3
 8024ee6:	68f8      	ldr	r0, [r7, #12]
 8024ee8:	f001 ff70 	bl	8026dcc <fp_copy>
  }
  err = fp_mulmod (&M[1], res, P, &M[1]);
 8024eec:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024eee:	f503 700b 	add.w	r0, r3, #556	@ 0x22c
 8024ef2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ef4:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024ef8:	687a      	ldr	r2, [r7, #4]
 8024efa:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8024efc:	f7ff fb69 	bl	80245d2 <fp_mulmod>
 8024f00:	66f8      	str	r0, [r7, #108]	@ 0x6c
  if (err != FP_OKAY) {
 8024f02:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f04:	2b00      	cmp	r3, #0
 8024f06:	d009      	beq.n	8024f1c <_fp_exptmod_nct+0x16c>
  #ifndef WOLFSSL_NO_MALLOC
     XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024f08:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024f0a:	61fb      	str	r3, [r7, #28]
 8024f0c:	69fb      	ldr	r3, [r7, #28]
 8024f0e:	2b00      	cmp	r3, #0
 8024f10:	d002      	beq.n	8024f18 <_fp_exptmod_nct+0x168>
 8024f12:	69f8      	ldr	r0, [r7, #28]
 8024f14:	f7f9 fece 	bl	801ecb4 <wolfSSL_Free>
  #endif
     return err;
 8024f18:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f1a:	e21f      	b.n	802535c <_fp_exptmod_nct+0x5ac>
  }

  /* compute the value at M[1<<(winsize-1)] by
   * squaring M[1] (winsize-1) times */
  fp_copy (&M[1], &M[(word32)(1 << (winsize - 1))]);
 8024f1c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024f1e:	f503 700b 	add.w	r0, r3, #556	@ 0x22c
 8024f22:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024f24:	3b01      	subs	r3, #1
 8024f26:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024f2a:	fa02 f303 	lsl.w	r3, r2, r3
 8024f2e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024f30:	4413      	add	r3, r2
 8024f32:	4619      	mov	r1, r3
 8024f34:	f001 ff4a 	bl	8026dcc <fp_copy>
  for (x = 0; x < (winsize - 1); x++) {
 8024f38:	2300      	movs	r3, #0
 8024f3a:	677b      	str	r3, [r7, #116]	@ 0x74
 8024f3c:	e03e      	b.n	8024fbc <_fp_exptmod_nct+0x20c>
    err = fp_sqr (&M[(word32)(1 << (winsize - 1))],
 8024f3e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024f40:	3b01      	subs	r3, #1
 8024f42:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024f46:	fa02 f303 	lsl.w	r3, r2, r3
 8024f4a:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024f4c:	18d0      	adds	r0, r2, r3
                  &M[(word32)(1 << (winsize - 1))]);
 8024f4e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024f50:	3b01      	subs	r3, #1
 8024f52:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024f56:	fa02 f303 	lsl.w	r3, r2, r3
    err = fp_sqr (&M[(word32)(1 << (winsize - 1))],
 8024f5a:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024f5c:	4413      	add	r3, r2
 8024f5e:	4619      	mov	r1, r3
 8024f60:	f000 fce9 	bl	8025936 <fp_sqr>
 8024f64:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8024f66:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f68:	2b00      	cmp	r3, #0
 8024f6a:	d009      	beq.n	8024f80 <_fp_exptmod_nct+0x1d0>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024f6c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024f6e:	623b      	str	r3, [r7, #32]
 8024f70:	6a3b      	ldr	r3, [r7, #32]
 8024f72:	2b00      	cmp	r3, #0
 8024f74:	d002      	beq.n	8024f7c <_fp_exptmod_nct+0x1cc>
 8024f76:	6a38      	ldr	r0, [r7, #32]
 8024f78:	f7f9 fe9c 	bl	801ecb4 <wolfSSL_Free>
#endif
      return err;
 8024f7c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f7e:	e1ed      	b.n	802535c <_fp_exptmod_nct+0x5ac>
    }
    err = fp_montgomery_reduce_ex(&M[(word32)(1 << (winsize - 1))], P, mp, 0);
 8024f80:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024f82:	3b01      	subs	r3, #1
 8024f84:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024f88:	fa02 f303 	lsl.w	r3, r2, r3
 8024f8c:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024f8e:	18d0      	adds	r0, r2, r3
 8024f90:	697a      	ldr	r2, [r7, #20]
 8024f92:	2300      	movs	r3, #0
 8024f94:	6879      	ldr	r1, [r7, #4]
 8024f96:	f001 f856 	bl	8026046 <fp_montgomery_reduce_ex>
 8024f9a:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8024f9c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f9e:	2b00      	cmp	r3, #0
 8024fa0:	d009      	beq.n	8024fb6 <_fp_exptmod_nct+0x206>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024fa2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024fa4:	627b      	str	r3, [r7, #36]	@ 0x24
 8024fa6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024fa8:	2b00      	cmp	r3, #0
 8024faa:	d002      	beq.n	8024fb2 <_fp_exptmod_nct+0x202>
 8024fac:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8024fae:	f7f9 fe81 	bl	801ecb4 <wolfSSL_Free>
#endif
      return err;
 8024fb2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024fb4:	e1d2      	b.n	802535c <_fp_exptmod_nct+0x5ac>
  for (x = 0; x < (winsize - 1); x++) {
 8024fb6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024fb8:	3301      	adds	r3, #1
 8024fba:	677b      	str	r3, [r7, #116]	@ 0x74
 8024fbc:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024fbe:	3b01      	subs	r3, #1
 8024fc0:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024fc2:	429a      	cmp	r2, r3
 8024fc4:	dbbb      	blt.n	8024f3e <_fp_exptmod_nct+0x18e>
    }
  }

  /* create upper table */
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 8024fc6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024fc8:	3b01      	subs	r3, #1
 8024fca:	2201      	movs	r2, #1
 8024fcc:	fa02 f303 	lsl.w	r3, r2, r3
 8024fd0:	3301      	adds	r3, #1
 8024fd2:	677b      	str	r3, [r7, #116]	@ 0x74
 8024fd4:	e040      	b.n	8025058 <_fp_exptmod_nct+0x2a8>
    err = fp_mul(&M[x - 1], &M[1], &M[x]);
 8024fd6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024fd8:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024fdc:	fb02 f303 	mul.w	r3, r2, r3
 8024fe0:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 8024fe4:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024fe6:	18d0      	adds	r0, r2, r3
 8024fe8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024fea:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 8024fee:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024ff0:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024ff4:	fb02 f303 	mul.w	r3, r2, r3
 8024ff8:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024ffa:	4413      	add	r3, r2
 8024ffc:	461a      	mov	r2, r3
 8024ffe:	f7fd fcf2 	bl	80229e6 <fp_mul>
 8025002:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8025004:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025006:	2b00      	cmp	r3, #0
 8025008:	d009      	beq.n	802501e <_fp_exptmod_nct+0x26e>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 802500a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802500c:	62bb      	str	r3, [r7, #40]	@ 0x28
 802500e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025010:	2b00      	cmp	r3, #0
 8025012:	d002      	beq.n	802501a <_fp_exptmod_nct+0x26a>
 8025014:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8025016:	f7f9 fe4d 	bl	801ecb4 <wolfSSL_Free>
#endif
      return err;
 802501a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802501c:	e19e      	b.n	802535c <_fp_exptmod_nct+0x5ac>
    }
    err = fp_montgomery_reduce_ex(&M[x], P, mp, 0);
 802501e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8025020:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8025024:	fb02 f303 	mul.w	r3, r2, r3
 8025028:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 802502a:	18d0      	adds	r0, r2, r3
 802502c:	697a      	ldr	r2, [r7, #20]
 802502e:	2300      	movs	r3, #0
 8025030:	6879      	ldr	r1, [r7, #4]
 8025032:	f001 f808 	bl	8026046 <fp_montgomery_reduce_ex>
 8025036:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8025038:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802503a:	2b00      	cmp	r3, #0
 802503c:	d009      	beq.n	8025052 <_fp_exptmod_nct+0x2a2>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 802503e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8025040:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8025042:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025044:	2b00      	cmp	r3, #0
 8025046:	d002      	beq.n	802504e <_fp_exptmod_nct+0x29e>
 8025048:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 802504a:	f7f9 fe33 	bl	801ecb4 <wolfSSL_Free>
#endif
      return err;
 802504e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025050:	e184      	b.n	802535c <_fp_exptmod_nct+0x5ac>
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 8025052:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8025054:	3301      	adds	r3, #1
 8025056:	677b      	str	r3, [r7, #116]	@ 0x74
 8025058:	2201      	movs	r2, #1
 802505a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 802505c:	fa02 f303 	lsl.w	r3, r2, r3
 8025060:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8025062:	429a      	cmp	r2, r3
 8025064:	dbb7      	blt.n	8024fd6 <_fp_exptmod_nct+0x226>
    }
  }

  /* set initial mode and bit cnt */
  mode   = 0;
 8025066:	2300      	movs	r3, #0
 8025068:	67fb      	str	r3, [r7, #124]	@ 0x7c
  bitcnt = (x % DIGIT_BIT) + 1;
 802506a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802506c:	425a      	negs	r2, r3
 802506e:	f003 031f 	and.w	r3, r3, #31
 8025072:	f002 021f 	and.w	r2, r2, #31
 8025076:	bf58      	it	pl
 8025078:	4253      	negpl	r3, r2
 802507a:	3301      	adds	r3, #1
 802507c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  buf    = 0;
 8025080:	2300      	movs	r3, #0
 8025082:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  digidx = X->used - 1;
 8025086:	68bb      	ldr	r3, [r7, #8]
 8025088:	681b      	ldr	r3, [r3, #0]
 802508a:	3b01      	subs	r3, #1
 802508c:	67bb      	str	r3, [r7, #120]	@ 0x78
  bitcpy = 0;
 802508e:	2300      	movs	r3, #0
 8025090:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  bitbuf = 0;
 8025094:	2300      	movs	r3, #0
 8025096:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88

  for (;;) {
    /* grab next digit as required */
    if (--bitcnt == 0) {
 802509a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 802509e:	3b01      	subs	r3, #1
 80250a0:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 80250a4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 80250a8:	2b00      	cmp	r3, #0
 80250aa:	d111      	bne.n	80250d0 <_fp_exptmod_nct+0x320>
      /* if digidx == -1 we are out of digits so break */
      if (digidx == -1) {
 80250ac:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80250ae:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80250b2:	f000 80ce 	beq.w	8025252 <_fp_exptmod_nct+0x4a2>
        break;
      }
      /* read next digit and reset bitcnt */
      buf    = X->dp[digidx--];
 80250b6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80250b8:	1e5a      	subs	r2, r3, #1
 80250ba:	67ba      	str	r2, [r7, #120]	@ 0x78
 80250bc:	68ba      	ldr	r2, [r7, #8]
 80250be:	3302      	adds	r3, #2
 80250c0:	009b      	lsls	r3, r3, #2
 80250c2:	4413      	add	r3, r2
 80250c4:	685b      	ldr	r3, [r3, #4]
 80250c6:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
      bitcnt = (int)DIGIT_BIT;
 80250ca:	2320      	movs	r3, #32
 80250cc:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    }

    /* grab the next msb from the exponent */
    y     = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 80250d0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80250d4:	0fdb      	lsrs	r3, r3, #31
 80250d6:	64bb      	str	r3, [r7, #72]	@ 0x48
    buf <<= (fp_digit)1;
 80250d8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80250dc:	005b      	lsls	r3, r3, #1
 80250de:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    /* if the bit is zero and mode == 0 then we ignore it
     * These represent the leading zero bits before the first 1 bit
     * in the exponent.  Technically this opt is not required but it
     * does lower the # of trivial squaring/reductions used
     */
    if (mode == 0 && y == 0) {
 80250e2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80250e4:	2b00      	cmp	r3, #0
 80250e6:	d103      	bne.n	80250f0 <_fp_exptmod_nct+0x340>
 80250e8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80250ea:	2b00      	cmp	r3, #0
 80250ec:	f000 80ad 	beq.w	802524a <_fp_exptmod_nct+0x49a>
      continue;
    }

    /* if the bit is zero and mode == 1 then we square */
    if (mode == 1 && y == 0) {
 80250f0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80250f2:	2b01      	cmp	r3, #1
 80250f4:	d129      	bne.n	802514a <_fp_exptmod_nct+0x39a>
 80250f6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80250f8:	2b00      	cmp	r3, #0
 80250fa:	d126      	bne.n	802514a <_fp_exptmod_nct+0x39a>
      err = fp_sqr(res, res);
 80250fc:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 80250fe:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8025100:	f000 fc19 	bl	8025936 <fp_sqr>
 8025104:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8025106:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025108:	2b00      	cmp	r3, #0
 802510a:	d009      	beq.n	8025120 <_fp_exptmod_nct+0x370>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 802510c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802510e:	643b      	str	r3, [r7, #64]	@ 0x40
 8025110:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025112:	2b00      	cmp	r3, #0
 8025114:	d002      	beq.n	802511c <_fp_exptmod_nct+0x36c>
 8025116:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8025118:	f7f9 fdcc 	bl	801ecb4 <wolfSSL_Free>
#endif
        return err;
 802511c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802511e:	e11d      	b.n	802535c <_fp_exptmod_nct+0x5ac>
      }
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8025120:	697a      	ldr	r2, [r7, #20]
 8025122:	2300      	movs	r3, #0
 8025124:	6879      	ldr	r1, [r7, #4]
 8025126:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8025128:	f000 ff8d 	bl	8026046 <fp_montgomery_reduce_ex>
 802512c:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 802512e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025130:	2b00      	cmp	r3, #0
 8025132:	f000 808c 	beq.w	802524e <_fp_exptmod_nct+0x49e>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8025136:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8025138:	647b      	str	r3, [r7, #68]	@ 0x44
 802513a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802513c:	2b00      	cmp	r3, #0
 802513e:	d002      	beq.n	8025146 <_fp_exptmod_nct+0x396>
 8025140:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8025142:	f7f9 fdb7 	bl	801ecb4 <wolfSSL_Free>
#endif
        return err;
 8025146:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025148:	e108      	b.n	802535c <_fp_exptmod_nct+0x5ac>
      }
      continue;
    }

    /* else we add it to the window */
    bitbuf |= (y << (winsize - ++bitcpy));
 802514a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 802514e:	3301      	adds	r3, #1
 8025150:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 8025154:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8025156:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 802515a:	1ad3      	subs	r3, r2, r3
 802515c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802515e:	fa02 f303 	lsl.w	r3, r2, r3
 8025162:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8025166:	4313      	orrs	r3, r2
 8025168:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    mode    = 2;
 802516c:	2302      	movs	r3, #2
 802516e:	67fb      	str	r3, [r7, #124]	@ 0x7c

    if (bitcpy == winsize) {
 8025170:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8025174:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8025176:	429a      	cmp	r2, r3
 8025178:	d18f      	bne.n	802509a <_fp_exptmod_nct+0x2ea>
      /* ok window is filled so square as required and multiply  */
      /* square first */
      for (x = 0; x < winsize; x++) {
 802517a:	2300      	movs	r3, #0
 802517c:	677b      	str	r3, [r7, #116]	@ 0x74
 802517e:	e028      	b.n	80251d2 <_fp_exptmod_nct+0x422>
        err = fp_sqr(res, res);
 8025180:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8025182:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8025184:	f000 fbd7 	bl	8025936 <fp_sqr>
 8025188:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 802518a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802518c:	2b00      	cmp	r3, #0
 802518e:	d009      	beq.n	80251a4 <_fp_exptmod_nct+0x3f4>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8025190:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8025192:	633b      	str	r3, [r7, #48]	@ 0x30
 8025194:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8025196:	2b00      	cmp	r3, #0
 8025198:	d002      	beq.n	80251a0 <_fp_exptmod_nct+0x3f0>
 802519a:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 802519c:	f7f9 fd8a 	bl	801ecb4 <wolfSSL_Free>
#endif
          return err;
 80251a0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80251a2:	e0db      	b.n	802535c <_fp_exptmod_nct+0x5ac>
        }
        err = fp_montgomery_reduce_ex(res, P, mp, 0);
 80251a4:	697a      	ldr	r2, [r7, #20]
 80251a6:	2300      	movs	r3, #0
 80251a8:	6879      	ldr	r1, [r7, #4]
 80251aa:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80251ac:	f000 ff4b 	bl	8026046 <fp_montgomery_reduce_ex>
 80251b0:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 80251b2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80251b4:	2b00      	cmp	r3, #0
 80251b6:	d009      	beq.n	80251cc <_fp_exptmod_nct+0x41c>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 80251b8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80251ba:	637b      	str	r3, [r7, #52]	@ 0x34
 80251bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80251be:	2b00      	cmp	r3, #0
 80251c0:	d002      	beq.n	80251c8 <_fp_exptmod_nct+0x418>
 80251c2:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80251c4:	f7f9 fd76 	bl	801ecb4 <wolfSSL_Free>
#endif
          return err;
 80251c8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80251ca:	e0c7      	b.n	802535c <_fp_exptmod_nct+0x5ac>
      for (x = 0; x < winsize; x++) {
 80251cc:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80251ce:	3301      	adds	r3, #1
 80251d0:	677b      	str	r3, [r7, #116]	@ 0x74
 80251d2:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80251d4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80251d6:	429a      	cmp	r2, r3
 80251d8:	dbd2      	blt.n	8025180 <_fp_exptmod_nct+0x3d0>
        }
      }

      /* then multiply */
      err = fp_mul(res, &M[bitbuf], res);
 80251da:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80251de:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80251e2:	fb02 f303 	mul.w	r3, r2, r3
 80251e6:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80251e8:	4413      	add	r3, r2
 80251ea:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80251ec:	4619      	mov	r1, r3
 80251ee:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80251f0:	f7fd fbf9 	bl	80229e6 <fp_mul>
 80251f4:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 80251f6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80251f8:	2b00      	cmp	r3, #0
 80251fa:	d009      	beq.n	8025210 <_fp_exptmod_nct+0x460>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 80251fc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80251fe:	63bb      	str	r3, [r7, #56]	@ 0x38
 8025200:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8025202:	2b00      	cmp	r3, #0
 8025204:	d002      	beq.n	802520c <_fp_exptmod_nct+0x45c>
 8025206:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8025208:	f7f9 fd54 	bl	801ecb4 <wolfSSL_Free>
#endif
        return err;
 802520c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802520e:	e0a5      	b.n	802535c <_fp_exptmod_nct+0x5ac>
      }
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8025210:	697a      	ldr	r2, [r7, #20]
 8025212:	2300      	movs	r3, #0
 8025214:	6879      	ldr	r1, [r7, #4]
 8025216:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8025218:	f000 ff15 	bl	8026046 <fp_montgomery_reduce_ex>
 802521c:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 802521e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025220:	2b00      	cmp	r3, #0
 8025222:	d009      	beq.n	8025238 <_fp_exptmod_nct+0x488>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8025224:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8025226:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8025228:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802522a:	2b00      	cmp	r3, #0
 802522c:	d002      	beq.n	8025234 <_fp_exptmod_nct+0x484>
 802522e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8025230:	f7f9 fd40 	bl	801ecb4 <wolfSSL_Free>
#endif
        return err;
 8025234:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025236:	e091      	b.n	802535c <_fp_exptmod_nct+0x5ac>
      }

      /* empty window and reset */
      bitcpy = 0;
 8025238:	2300      	movs	r3, #0
 802523a:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
      bitbuf = 0;
 802523e:	2300      	movs	r3, #0
 8025240:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
      mode   = 1;
 8025244:	2301      	movs	r3, #1
 8025246:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8025248:	e727      	b.n	802509a <_fp_exptmod_nct+0x2ea>
      continue;
 802524a:	bf00      	nop
 802524c:	e725      	b.n	802509a <_fp_exptmod_nct+0x2ea>
      continue;
 802524e:	bf00      	nop
    if (--bitcnt == 0) {
 8025250:	e723      	b.n	802509a <_fp_exptmod_nct+0x2ea>
        break;
 8025252:	bf00      	nop
    }
  }

  /* if bits remain then square/multiply */
  if (mode == 2 && bitcpy > 0) {
 8025254:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025256:	2b02      	cmp	r3, #2
 8025258:	d16c      	bne.n	8025334 <_fp_exptmod_nct+0x584>
 802525a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 802525e:	2b00      	cmp	r3, #0
 8025260:	dd68      	ble.n	8025334 <_fp_exptmod_nct+0x584>
    /* square then multiply if the bit is set */
    for (x = 0; x < bitcpy; x++) {
 8025262:	2300      	movs	r3, #0
 8025264:	677b      	str	r3, [r7, #116]	@ 0x74
 8025266:	e060      	b.n	802532a <_fp_exptmod_nct+0x57a>
      err = fp_sqr(res, res);
 8025268:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 802526a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 802526c:	f000 fb63 	bl	8025936 <fp_sqr>
 8025270:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8025272:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025274:	2b00      	cmp	r3, #0
 8025276:	d009      	beq.n	802528c <_fp_exptmod_nct+0x4dc>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8025278:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802527a:	653b      	str	r3, [r7, #80]	@ 0x50
 802527c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802527e:	2b00      	cmp	r3, #0
 8025280:	d002      	beq.n	8025288 <_fp_exptmod_nct+0x4d8>
 8025282:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8025284:	f7f9 fd16 	bl	801ecb4 <wolfSSL_Free>
#endif
        return err;
 8025288:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802528a:	e067      	b.n	802535c <_fp_exptmod_nct+0x5ac>
      }
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 802528c:	697a      	ldr	r2, [r7, #20]
 802528e:	2300      	movs	r3, #0
 8025290:	6879      	ldr	r1, [r7, #4]
 8025292:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8025294:	f000 fed7 	bl	8026046 <fp_montgomery_reduce_ex>
 8025298:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 802529a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802529c:	2b00      	cmp	r3, #0
 802529e:	d009      	beq.n	80252b4 <_fp_exptmod_nct+0x504>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 80252a0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80252a2:	657b      	str	r3, [r7, #84]	@ 0x54
 80252a4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80252a6:	2b00      	cmp	r3, #0
 80252a8:	d002      	beq.n	80252b0 <_fp_exptmod_nct+0x500>
 80252aa:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80252ac:	f7f9 fd02 	bl	801ecb4 <wolfSSL_Free>
#endif
        return err;
 80252b0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80252b2:	e053      	b.n	802535c <_fp_exptmod_nct+0x5ac>
      }

      /* get next bit of the window */
      bitbuf <<= 1;
 80252b4:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80252b8:	005b      	lsls	r3, r3, #1
 80252ba:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
      if ((bitbuf & (1 << winsize)) != 0) {
 80252be:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 80252c2:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80252c4:	fa42 f303 	asr.w	r3, r2, r3
 80252c8:	f003 0301 	and.w	r3, r3, #1
 80252cc:	2b00      	cmp	r3, #0
 80252ce:	d029      	beq.n	8025324 <_fp_exptmod_nct+0x574>
        /* then multiply */
        err = fp_mul(res, &M[1], res);
 80252d0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80252d2:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80252d6:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80252d8:	4619      	mov	r1, r3
 80252da:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80252dc:	f7fd fb83 	bl	80229e6 <fp_mul>
 80252e0:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 80252e2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80252e4:	2b00      	cmp	r3, #0
 80252e6:	d009      	beq.n	80252fc <_fp_exptmod_nct+0x54c>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 80252e8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80252ea:	65bb      	str	r3, [r7, #88]	@ 0x58
 80252ec:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80252ee:	2b00      	cmp	r3, #0
 80252f0:	d002      	beq.n	80252f8 <_fp_exptmod_nct+0x548>
 80252f2:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 80252f4:	f7f9 fcde 	bl	801ecb4 <wolfSSL_Free>
#endif
          return err;
 80252f8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80252fa:	e02f      	b.n	802535c <_fp_exptmod_nct+0x5ac>
        }
        err = fp_montgomery_reduce_ex(res, P, mp, 0);
 80252fc:	697a      	ldr	r2, [r7, #20]
 80252fe:	2300      	movs	r3, #0
 8025300:	6879      	ldr	r1, [r7, #4]
 8025302:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8025304:	f000 fe9f 	bl	8026046 <fp_montgomery_reduce_ex>
 8025308:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 802530a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802530c:	2b00      	cmp	r3, #0
 802530e:	d009      	beq.n	8025324 <_fp_exptmod_nct+0x574>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8025310:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8025312:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8025314:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8025316:	2b00      	cmp	r3, #0
 8025318:	d002      	beq.n	8025320 <_fp_exptmod_nct+0x570>
 802531a:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 802531c:	f7f9 fcca 	bl	801ecb4 <wolfSSL_Free>
#endif
          return err;
 8025320:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025322:	e01b      	b.n	802535c <_fp_exptmod_nct+0x5ac>
    for (x = 0; x < bitcpy; x++) {
 8025324:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8025326:	3301      	adds	r3, #1
 8025328:	677b      	str	r3, [r7, #116]	@ 0x74
 802532a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802532c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8025330:	429a      	cmp	r2, r3
 8025332:	db99      	blt.n	8025268 <_fp_exptmod_nct+0x4b8>
   * recall that any value in a Montgomery system is
   * actually multiplied by R mod n.  So we have
   * to reduce one more time to cancel out the factor
   * of R.
   */
  err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8025334:	697a      	ldr	r2, [r7, #20]
 8025336:	2300      	movs	r3, #0
 8025338:	6879      	ldr	r1, [r7, #4]
 802533a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 802533c:	f000 fe83 	bl	8026046 <fp_montgomery_reduce_ex>
 8025340:	66f8      	str	r0, [r7, #108]	@ 0x6c

  /* swap res with Y */
  fp_copy (res, Y);
 8025342:	6839      	ldr	r1, [r7, #0]
 8025344:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8025346:	f001 fd41 	bl	8026dcc <fp_copy>

#ifndef WOLFSSL_NO_MALLOC
  XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 802534a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802534c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 802534e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025350:	2b00      	cmp	r3, #0
 8025352:	d002      	beq.n	802535a <_fp_exptmod_nct+0x5aa>
 8025354:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8025356:	f7f9 fcad 	bl	801ecb4 <wolfSSL_Free>
#endif
  return err;
 802535a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
}
 802535c:	4618      	mov	r0, r3
 802535e:	3790      	adds	r7, #144	@ 0x90
 8025360:	46bd      	mov	sp, r7
 8025362:	bd80      	pop	{r7, pc}

08025364 <_fp_exptmod_base_2>:
/* y = 2**x (mod b)
 * Some restrictions... x must be positive and < b
 */
static int _fp_exptmod_base_2(fp_int * X, int digits, fp_int * P,
                              fp_int * Y)
{
 8025364:	b580      	push	{r7, lr}
 8025366:	b09c      	sub	sp, #112	@ 0x70
 8025368:	af00      	add	r7, sp, #0
 802536a:	60f8      	str	r0, [r7, #12]
 802536c:	60b9      	str	r1, [r7, #8]
 802536e:	607a      	str	r2, [r7, #4]
 8025370:	603b      	str	r3, [r7, #0]
  fp_int   res[1];
  fp_int   tmp[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
  res = (fp_int*)XMALLOC(2*sizeof(fp_int), NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025372:	f44f 608b 	mov.w	r0, #1112	@ 0x458
 8025376:	f7f9 fc81 	bl	801ec7c <wolfSSL_Malloc>
 802537a:	6578      	str	r0, [r7, #84]	@ 0x54
  if (res == NULL) {
 802537c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802537e:	2b00      	cmp	r3, #0
 8025380:	d102      	bne.n	8025388 <_fp_exptmod_base_2+0x24>
     return FP_MEM;
 8025382:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8025386:	e15d      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
  }
  tmp = &res[1];
 8025388:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802538a:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802538e:	653b      	str	r3, [r7, #80]	@ 0x50
#endif

  /* now setup montgomery  */
  if ((err = fp_montgomery_setup(P, &mp)) != FP_OKAY) {
 8025390:	f107 0314 	add.w	r3, r7, #20
 8025394:	4619      	mov	r1, r3
 8025396:	6878      	ldr	r0, [r7, #4]
 8025398:	f000 fdc2 	bl	8025f20 <fp_montgomery_setup>
 802539c:	64f8      	str	r0, [r7, #76]	@ 0x4c
 802539e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80253a0:	2b00      	cmp	r3, #0
 80253a2:	d009      	beq.n	80253b8 <_fp_exptmod_base_2+0x54>
#ifdef WOLFSSL_SMALL_STACK
     XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80253a4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80253a6:	61bb      	str	r3, [r7, #24]
 80253a8:	69bb      	ldr	r3, [r7, #24]
 80253aa:	2b00      	cmp	r3, #0
 80253ac:	d002      	beq.n	80253b4 <_fp_exptmod_base_2+0x50>
 80253ae:	69b8      	ldr	r0, [r7, #24]
 80253b0:	f7f9 fc80 	bl	801ecb4 <wolfSSL_Free>
#endif
     return err;
 80253b4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80253b6:	e145      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
  }

  /* setup result */
  fp_init(res);
 80253b8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80253ba:	f001 fb1d 	bl	80269f8 <fp_init>
  fp_init(tmp);
 80253be:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 80253c0:	f001 fb1a 	bl	80269f8 <fp_init>

  err = fp_mul_2d(P, 1 << WINSIZE, tmp);
 80253c4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80253c6:	2108      	movs	r1, #8
 80253c8:	6878      	ldr	r0, [r7, #4]
 80253ca:	f7fd fc62 	bl	8022c92 <fp_mul_2d>
 80253ce:	64f8      	str	r0, [r7, #76]	@ 0x4c
  if (err != FP_OKAY) {
 80253d0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80253d2:	2b00      	cmp	r3, #0
 80253d4:	d009      	beq.n	80253ea <_fp_exptmod_base_2+0x86>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80253d6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80253d8:	61fb      	str	r3, [r7, #28]
 80253da:	69fb      	ldr	r3, [r7, #28]
 80253dc:	2b00      	cmp	r3, #0
 80253de:	d002      	beq.n	80253e6 <_fp_exptmod_base_2+0x82>
 80253e0:	69f8      	ldr	r0, [r7, #28]
 80253e2:	f7f9 fc67 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return err;
 80253e6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80253e8:	e12c      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
  }

  /* now we need R mod m */
  err = fp_montgomery_calc_normalization(res, P);
 80253ea:	6879      	ldr	r1, [r7, #4]
 80253ec:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80253ee:	f000 fdd8 	bl	8025fa2 <fp_montgomery_calc_normalization>
 80253f2:	64f8      	str	r0, [r7, #76]	@ 0x4c
  if (err != FP_OKAY) {
 80253f4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80253f6:	2b00      	cmp	r3, #0
 80253f8:	d009      	beq.n	802540e <_fp_exptmod_base_2+0xaa>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80253fa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80253fc:	623b      	str	r3, [r7, #32]
 80253fe:	6a3b      	ldr	r3, [r7, #32]
 8025400:	2b00      	cmp	r3, #0
 8025402:	d002      	beq.n	802540a <_fp_exptmod_base_2+0xa6>
 8025404:	6a38      	ldr	r0, [r7, #32]
 8025406:	f7f9 fc55 	bl	801ecb4 <wolfSSL_Free>
  #endif
    return err;
 802540a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802540c:	e11a      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
  }

  /* Get the top bits left over after taking WINSIZE bits starting at the
   * least-significant.
   */
  digidx = digits - 1;
 802540e:	68bb      	ldr	r3, [r7, #8]
 8025410:	3b01      	subs	r3, #1
 8025412:	65fb      	str	r3, [r7, #92]	@ 0x5c
  bitcpy = (digits * DIGIT_BIT) % WINSIZE;
 8025414:	68bb      	ldr	r3, [r7, #8]
 8025416:	015a      	lsls	r2, r3, #5
 8025418:	4b8c      	ldr	r3, [pc, #560]	@ (802564c <_fp_exptmod_base_2+0x2e8>)
 802541a:	fb83 3102 	smull	r3, r1, r3, r2
 802541e:	17d3      	asrs	r3, r2, #31
 8025420:	1ac9      	subs	r1, r1, r3
 8025422:	460b      	mov	r3, r1
 8025424:	005b      	lsls	r3, r3, #1
 8025426:	440b      	add	r3, r1
 8025428:	1ad3      	subs	r3, r2, r3
 802542a:	667b      	str	r3, [r7, #100]	@ 0x64
  if (bitcpy > 0) {
 802542c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802542e:	2b00      	cmp	r3, #0
 8025430:	dd53      	ble.n	80254da <_fp_exptmod_base_2+0x176>
      bitcnt = (int)DIGIT_BIT - bitcpy;
 8025432:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025434:	f1c3 0320 	rsb	r3, r3, #32
 8025438:	663b      	str	r3, [r7, #96]	@ 0x60
      buf    = X->dp[digidx--];
 802543a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802543c:	1e5a      	subs	r2, r3, #1
 802543e:	65fa      	str	r2, [r7, #92]	@ 0x5c
 8025440:	68fa      	ldr	r2, [r7, #12]
 8025442:	3302      	adds	r3, #2
 8025444:	009b      	lsls	r3, r3, #2
 8025446:	4413      	add	r3, r2
 8025448:	685b      	ldr	r3, [r3, #4]
 802544a:	66fb      	str	r3, [r7, #108]	@ 0x6c
      bitbuf = (int)(buf >> bitcnt);
 802544c:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802544e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8025450:	fa22 f303 	lsr.w	r3, r2, r3
 8025454:	66bb      	str	r3, [r7, #104]	@ 0x68
      /* Multiply montgomery representation of 1 by 2 ^ top */
      err = fp_mul_2d(res, bitbuf, res);
 8025456:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8025458:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 802545a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802545c:	f7fd fc19 	bl	8022c92 <fp_mul_2d>
 8025460:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 8025462:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025464:	2b00      	cmp	r3, #0
 8025466:	d009      	beq.n	802547c <_fp_exptmod_base_2+0x118>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025468:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802546a:	643b      	str	r3, [r7, #64]	@ 0x40
 802546c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802546e:	2b00      	cmp	r3, #0
 8025470:	d002      	beq.n	8025478 <_fp_exptmod_base_2+0x114>
 8025472:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8025474:	f7f9 fc1e 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 8025478:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802547a:	e0e3      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
      }
      err = fp_add(res, tmp, res);
 802547c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802547e:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8025480:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025482:	f7fd f8ca 	bl	802261a <fp_add>
 8025486:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 8025488:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802548a:	2b00      	cmp	r3, #0
 802548c:	d009      	beq.n	80254a2 <_fp_exptmod_base_2+0x13e>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802548e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025490:	647b      	str	r3, [r7, #68]	@ 0x44
 8025492:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025494:	2b00      	cmp	r3, #0
 8025496:	d002      	beq.n	802549e <_fp_exptmod_base_2+0x13a>
 8025498:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 802549a:	f7f9 fc0b 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 802549e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80254a0:	e0d0      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
      }
      err = fp_mod(res, P, res);
 80254a2:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80254a4:	6879      	ldr	r1, [r7, #4]
 80254a6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80254a8:	f7fe fa36 	bl	8023918 <fp_mod>
 80254ac:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 80254ae:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80254b0:	2b00      	cmp	r3, #0
 80254b2:	d009      	beq.n	80254c8 <_fp_exptmod_base_2+0x164>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80254b4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80254b6:	64bb      	str	r3, [r7, #72]	@ 0x48
 80254b8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80254ba:	2b00      	cmp	r3, #0
 80254bc:	d002      	beq.n	80254c4 <_fp_exptmod_base_2+0x160>
 80254be:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80254c0:	f7f9 fbf8 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 80254c4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80254c6:	e0bd      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
      }
      /* Move out bits used */
      buf  <<= bitcpy;
 80254c8:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80254ca:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80254cc:	fa02 f303 	lsl.w	r3, r2, r3
 80254d0:	66fb      	str	r3, [r7, #108]	@ 0x6c
      bitcnt++;
 80254d2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80254d4:	3301      	adds	r3, #1
 80254d6:	663b      	str	r3, [r7, #96]	@ 0x60
 80254d8:	e003      	b.n	80254e2 <_fp_exptmod_base_2+0x17e>
  }
  else {
      bitcnt = 1;
 80254da:	2301      	movs	r3, #1
 80254dc:	663b      	str	r3, [r7, #96]	@ 0x60
      buf    = 0;
 80254de:	2300      	movs	r3, #0
 80254e0:	66fb      	str	r3, [r7, #108]	@ 0x6c
  }

  /* empty window and reset  */
  bitbuf = 0;
 80254e2:	2300      	movs	r3, #0
 80254e4:	66bb      	str	r3, [r7, #104]	@ 0x68
  bitcpy = 0;
 80254e6:	2300      	movs	r3, #0
 80254e8:	667b      	str	r3, [r7, #100]	@ 0x64

  for (;;) {
    /* grab next digit as required */
    if (--bitcnt == 0) {
 80254ea:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80254ec:	3b01      	subs	r3, #1
 80254ee:	663b      	str	r3, [r7, #96]	@ 0x60
 80254f0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80254f2:	2b00      	cmp	r3, #0
 80254f4:	d10f      	bne.n	8025516 <_fp_exptmod_base_2+0x1b2>
      /* if digidx == -1 we are out of digits so break */
      if (digidx == -1) {
 80254f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80254f8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80254fc:	f000 808d 	beq.w	802561a <_fp_exptmod_base_2+0x2b6>
        break;
      }
      /* read next digit and reset bitcnt */
      buf    = X->dp[digidx--];
 8025500:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8025502:	1e5a      	subs	r2, r3, #1
 8025504:	65fa      	str	r2, [r7, #92]	@ 0x5c
 8025506:	68fa      	ldr	r2, [r7, #12]
 8025508:	3302      	adds	r3, #2
 802550a:	009b      	lsls	r3, r3, #2
 802550c:	4413      	add	r3, r2
 802550e:	685b      	ldr	r3, [r3, #4]
 8025510:	66fb      	str	r3, [r7, #108]	@ 0x6c
      bitcnt = (int)DIGIT_BIT;
 8025512:	2320      	movs	r3, #32
 8025514:	663b      	str	r3, [r7, #96]	@ 0x60
    }

    /* grab the next msb from the exponent */
    y       = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 8025516:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025518:	0fdb      	lsrs	r3, r3, #31
 802551a:	63bb      	str	r3, [r7, #56]	@ 0x38
    buf   <<= (fp_digit)1;
 802551c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802551e:	005b      	lsls	r3, r3, #1
 8025520:	66fb      	str	r3, [r7, #108]	@ 0x6c
    /* add bit to the window */
  #ifndef WC_PROTECT_ENCRYPTED_MEM
    bitbuf |= (y << (WINSIZE - ++bitcpy));
 8025522:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025524:	3301      	adds	r3, #1
 8025526:	667b      	str	r3, [r7, #100]	@ 0x64
 8025528:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802552a:	f1c3 0303 	rsb	r3, r3, #3
 802552e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8025530:	fa02 f303 	lsl.w	r3, r2, r3
 8025534:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8025536:	4313      	orrs	r3, r2
 8025538:	66bb      	str	r3, [r7, #104]	@ 0x68
  #else
    /* Ensure value changes even when y is zero. */
    bitbuf += (WINMASK + 1) + (y << (WINSIZE - ++bitcpy));
  #endif

    if (bitcpy == WINSIZE) {
 802553a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802553c:	2b03      	cmp	r3, #3
 802553e:	d1d4      	bne.n	80254ea <_fp_exptmod_base_2+0x186>
      /* ok window is filled so square as required and multiply  */
      /* square first */
      for (x = 0; x < WINSIZE; x++) {
 8025540:	2300      	movs	r3, #0
 8025542:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025544:	e028      	b.n	8025598 <_fp_exptmod_base_2+0x234>
        err = fp_sqr(res, res);
 8025546:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8025548:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802554a:	f000 f9f4 	bl	8025936 <fp_sqr>
 802554e:	64f8      	str	r0, [r7, #76]	@ 0x4c
        if (err != FP_OKAY) {
 8025550:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025552:	2b00      	cmp	r3, #0
 8025554:	d009      	beq.n	802556a <_fp_exptmod_base_2+0x206>
        #ifdef WOLFSSL_SMALL_STACK
          XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025556:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025558:	627b      	str	r3, [r7, #36]	@ 0x24
 802555a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802555c:	2b00      	cmp	r3, #0
 802555e:	d002      	beq.n	8025566 <_fp_exptmod_base_2+0x202>
 8025560:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8025562:	f7f9 fba7 	bl	801ecb4 <wolfSSL_Free>
        #endif
          return err;
 8025566:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025568:	e06c      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
        }
        err = fp_montgomery_reduce(res, P, mp);
 802556a:	697b      	ldr	r3, [r7, #20]
 802556c:	461a      	mov	r2, r3
 802556e:	6879      	ldr	r1, [r7, #4]
 8025570:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025572:	f000 fe9c 	bl	80262ae <fp_montgomery_reduce>
 8025576:	64f8      	str	r0, [r7, #76]	@ 0x4c
        if (err != FP_OKAY) {
 8025578:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802557a:	2b00      	cmp	r3, #0
 802557c:	d009      	beq.n	8025592 <_fp_exptmod_base_2+0x22e>
        #ifdef WOLFSSL_SMALL_STACK
          XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802557e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025580:	62bb      	str	r3, [r7, #40]	@ 0x28
 8025582:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025584:	2b00      	cmp	r3, #0
 8025586:	d002      	beq.n	802558e <_fp_exptmod_base_2+0x22a>
 8025588:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 802558a:	f7f9 fb93 	bl	801ecb4 <wolfSSL_Free>
        #endif
          return err;
 802558e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025590:	e058      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
      for (x = 0; x < WINSIZE; x++) {
 8025592:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025594:	3301      	adds	r3, #1
 8025596:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025598:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802559a:	2b02      	cmp	r3, #2
 802559c:	ddd3      	ble.n	8025546 <_fp_exptmod_base_2+0x1e2>
        }
      }

      /* then multiply by 2^bitbuf */
    #ifndef WC_PROTECT_ENCRYPTED_MEM
      err = fp_mul_2d(res, bitbuf, res);
 802559e:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80255a0:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 80255a2:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80255a4:	f7fd fb75 	bl	8022c92 <fp_mul_2d>
 80255a8:	64f8      	str	r0, [r7, #76]	@ 0x4c
    #else
      /* Get the window bits. */
      err = fp_mul_2d(res, bitbuf & WINMASK, res);
    #endif
      if (err != FP_OKAY) {
 80255aa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80255ac:	2b00      	cmp	r3, #0
 80255ae:	d009      	beq.n	80255c4 <_fp_exptmod_base_2+0x260>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80255b0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80255b2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80255b4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80255b6:	2b00      	cmp	r3, #0
 80255b8:	d002      	beq.n	80255c0 <_fp_exptmod_base_2+0x25c>
 80255ba:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80255bc:	f7f9 fb7a 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 80255c0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80255c2:	e03f      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
      }
      /* Add in value to make mod operation take same time */
      err = fp_add(res, tmp, res);
 80255c4:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80255c6:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 80255c8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80255ca:	f7fd f826 	bl	802261a <fp_add>
 80255ce:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 80255d0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80255d2:	2b00      	cmp	r3, #0
 80255d4:	d009      	beq.n	80255ea <_fp_exptmod_base_2+0x286>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80255d6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80255d8:	633b      	str	r3, [r7, #48]	@ 0x30
 80255da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80255dc:	2b00      	cmp	r3, #0
 80255de:	d002      	beq.n	80255e6 <_fp_exptmod_base_2+0x282>
 80255e0:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80255e2:	f7f9 fb67 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 80255e6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80255e8:	e02c      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
      }
      err = fp_mod(res, P, res);
 80255ea:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80255ec:	6879      	ldr	r1, [r7, #4]
 80255ee:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80255f0:	f7fe f992 	bl	8023918 <fp_mod>
 80255f4:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 80255f6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80255f8:	2b00      	cmp	r3, #0
 80255fa:	d009      	beq.n	8025610 <_fp_exptmod_base_2+0x2ac>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80255fc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80255fe:	637b      	str	r3, [r7, #52]	@ 0x34
 8025600:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8025602:	2b00      	cmp	r3, #0
 8025604:	d002      	beq.n	802560c <_fp_exptmod_base_2+0x2a8>
 8025606:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8025608:	f7f9 fb54 	bl	801ecb4 <wolfSSL_Free>
      #endif
        return err;
 802560c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802560e:	e019      	b.n	8025644 <_fp_exptmod_base_2+0x2e0>
      }

      /* empty window and reset */
      bitcpy = 0;
 8025610:	2300      	movs	r3, #0
 8025612:	667b      	str	r3, [r7, #100]	@ 0x64
    #ifndef WC_PROTECT_ENCRYPTED_MEM
      bitbuf = 0;
 8025614:	2300      	movs	r3, #0
 8025616:	66bb      	str	r3, [r7, #104]	@ 0x68
    if (--bitcnt == 0) {
 8025618:	e767      	b.n	80254ea <_fp_exptmod_base_2+0x186>
        break;
 802561a:	bf00      	nop
   * recall that any value in a Montgomery system is
   * actually multiplied by R mod n.  So we have
   * to reduce one more time to cancel out the factor
   * of R.
   */
  err = fp_montgomery_reduce(res, P, mp);
 802561c:	697b      	ldr	r3, [r7, #20]
 802561e:	461a      	mov	r2, r3
 8025620:	6879      	ldr	r1, [r7, #4]
 8025622:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025624:	f000 fe43 	bl	80262ae <fp_montgomery_reduce>
 8025628:	64f8      	str	r0, [r7, #76]	@ 0x4c

  /* swap res with Y */
  fp_copy(res, Y);
 802562a:	6839      	ldr	r1, [r7, #0]
 802562c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802562e:	f001 fbcd 	bl	8026dcc <fp_copy>

#ifdef WOLFSSL_SMALL_STACK
  XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025632:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025634:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8025636:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8025638:	2b00      	cmp	r3, #0
 802563a:	d002      	beq.n	8025642 <_fp_exptmod_base_2+0x2de>
 802563c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 802563e:	f7f9 fb39 	bl	801ecb4 <wolfSSL_Free>
#endif
  return err;
 8025642:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 8025644:	4618      	mov	r0, r3
 8025646:	3770      	adds	r7, #112	@ 0x70
 8025648:	46bd      	mov	sp, r7
 802564a:	bd80      	pop	{r7, pc}
 802564c:	55555556 	.word	0x55555556

08025650 <fp_exptmod>:
#undef WINSIZE
#endif

/* Y = (G * X) mod P */
int fp_exptmod(fp_int * G, fp_int * X, fp_int * P, fp_int * Y)
{
 8025650:	b580      	push	{r7, lr}
 8025652:	b08a      	sub	sp, #40	@ 0x28
 8025654:	af02      	add	r7, sp, #8
 8025656:	60f8      	str	r0, [r7, #12]
 8025658:	60b9      	str	r1, [r7, #8]
 802565a:	607a      	str	r2, [r7, #4]
 802565c:	603b      	str	r3, [r7, #0]
#if defined(WOLFSSL_ESP32_CRYPT_RSA_PRI_EXPTMOD)
    int retHW = FP_OKAY;
#endif

   /* handle modulus of zero and prevent overflows */
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
 802565e:	687b      	ldr	r3, [r7, #4]
 8025660:	681b      	ldr	r3, [r3, #0]
 8025662:	2b00      	cmp	r3, #0
 8025664:	d003      	beq.n	802566e <fp_exptmod+0x1e>
 8025666:	687b      	ldr	r3, [r7, #4]
 8025668:	681b      	ldr	r3, [r3, #0]
 802566a:	2b44      	cmp	r3, #68	@ 0x44
 802566c:	dd02      	ble.n	8025674 <fp_exptmod+0x24>
      return FP_VAL;
 802566e:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025672:	e09c      	b.n	80257ae <fp_exptmod+0x15e>
   }
   if (fp_isone(P)) {
 8025674:	687b      	ldr	r3, [r7, #4]
 8025676:	681b      	ldr	r3, [r3, #0]
 8025678:	2b01      	cmp	r3, #1
 802567a:	d10d      	bne.n	8025698 <fp_exptmod+0x48>
 802567c:	687b      	ldr	r3, [r7, #4]
 802567e:	68db      	ldr	r3, [r3, #12]
 8025680:	2b01      	cmp	r3, #1
 8025682:	d109      	bne.n	8025698 <fp_exptmod+0x48>
 8025684:	687b      	ldr	r3, [r7, #4]
 8025686:	685b      	ldr	r3, [r3, #4]
 8025688:	2b00      	cmp	r3, #0
 802568a:	d105      	bne.n	8025698 <fp_exptmod+0x48>
      fp_set(Y, 0);
 802568c:	2100      	movs	r1, #0
 802568e:	6838      	ldr	r0, [r7, #0]
 8025690:	f000 ff83 	bl	802659a <fp_set>
      return FP_OKAY;
 8025694:	2300      	movs	r3, #0
 8025696:	e08a      	b.n	80257ae <fp_exptmod+0x15e>
   }
   if (fp_iszero(X)) {
 8025698:	68bb      	ldr	r3, [r7, #8]
 802569a:	681b      	ldr	r3, [r3, #0]
 802569c:	2b00      	cmp	r3, #0
 802569e:	d105      	bne.n	80256ac <fp_exptmod+0x5c>
      fp_set(Y, 1);
 80256a0:	2101      	movs	r1, #1
 80256a2:	6838      	ldr	r0, [r7, #0]
 80256a4:	f000 ff79 	bl	802659a <fp_set>
      return FP_OKAY;
 80256a8:	2300      	movs	r3, #0
 80256aa:	e080      	b.n	80257ae <fp_exptmod+0x15e>
   }
   if (fp_iszero(G)) {
 80256ac:	68fb      	ldr	r3, [r7, #12]
 80256ae:	681b      	ldr	r3, [r3, #0]
 80256b0:	2b00      	cmp	r3, #0
 80256b2:	d105      	bne.n	80256c0 <fp_exptmod+0x70>
      fp_set(Y, 0);
 80256b4:	2100      	movs	r1, #0
 80256b6:	6838      	ldr	r0, [r7, #0]
 80256b8:	f000 ff6f 	bl	802659a <fp_set>
      return FP_OKAY;
 80256bc:	2300      	movs	r3, #0
 80256be:	e076      	b.n	80257ae <fp_exptmod+0x15e>
      } /* switch */
   } /* if validation check */
   /* fall through to software calcs */
#endif /* WOLFSSL_ESP32_CRYPT_RSA_PRI_EXPTMOD */

   if (X->sign == FP_NEG) {
 80256c0:	68bb      	ldr	r3, [r7, #8]
 80256c2:	685b      	ldr	r3, [r3, #4]
 80256c4:	2b01      	cmp	r3, #1
 80256c6:	d157      	bne.n	8025778 <fp_exptmod+0x128>
   #else
      fp_int *tmp;
   #endif

   #ifdef WOLFSSL_SMALL_STACK
      tmp = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_BIGINT);
 80256c8:	f44f 608b 	mov.w	r0, #1112	@ 0x458
 80256cc:	f7f9 fad6 	bl	801ec7c <wolfSSL_Malloc>
 80256d0:	61b8      	str	r0, [r7, #24]
      if (tmp == NULL)
 80256d2:	69bb      	ldr	r3, [r7, #24]
 80256d4:	2b00      	cmp	r3, #0
 80256d6:	d102      	bne.n	80256de <fp_exptmod+0x8e>
          return FP_MEM;
 80256d8:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80256dc:	e067      	b.n	80257ae <fp_exptmod+0x15e>
   #endif

      /* yes, copy G and invmod it */
      fp_init_copy(&tmp[0], G);
 80256de:	68f9      	ldr	r1, [r7, #12]
 80256e0:	69b8      	ldr	r0, [r7, #24]
 80256e2:	f001 fbb2 	bl	8026e4a <fp_init_copy>
      fp_init_copy(&tmp[1], P);
 80256e6:	69bb      	ldr	r3, [r7, #24]
 80256e8:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80256ec:	6879      	ldr	r1, [r7, #4]
 80256ee:	4618      	mov	r0, r3
 80256f0:	f001 fbab 	bl	8026e4a <fp_init_copy>
      tmp[1].sign = FP_ZPOS;
 80256f4:	69bb      	ldr	r3, [r7, #24]
 80256f6:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80256fa:	2200      	movs	r2, #0
 80256fc:	605a      	str	r2, [r3, #4]
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
 80256fe:	69bb      	ldr	r3, [r7, #24]
 8025700:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8025704:	69ba      	ldr	r2, [r7, #24]
 8025706:	4619      	mov	r1, r3
 8025708:	69b8      	ldr	r0, [r7, #24]
 802570a:	f7fe fc5c 	bl	8023fc6 <fp_invmod>
 802570e:	61f8      	str	r0, [r7, #28]
      if (err == FP_OKAY) {
 8025710:	69fb      	ldr	r3, [r7, #28]
 8025712:	2b00      	cmp	r3, #0
 8025714:	d126      	bne.n	8025764 <fp_exptmod+0x114>
         fp_copy(X, &tmp[1]);
 8025716:	69bb      	ldr	r3, [r7, #24]
 8025718:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802571c:	4619      	mov	r1, r3
 802571e:	68b8      	ldr	r0, [r7, #8]
 8025720:	f001 fb54 	bl	8026dcc <fp_copy>
         tmp[1].sign = FP_ZPOS;
 8025724:	69bb      	ldr	r3, [r7, #24]
 8025726:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802572a:	2200      	movs	r2, #0
 802572c:	605a      	str	r2, [r3, #4]
   #ifdef TFM_TIMING_RESISTANT
         err =  _fp_exptmod_ct(&tmp[0], &tmp[1], tmp[1].used, P, Y);
 802572e:	69bb      	ldr	r3, [r7, #24]
 8025730:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 8025734:	69bb      	ldr	r3, [r7, #24]
 8025736:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802573a:	681a      	ldr	r2, [r3, #0]
 802573c:	683b      	ldr	r3, [r7, #0]
 802573e:	9300      	str	r3, [sp, #0]
 8025740:	687b      	ldr	r3, [r7, #4]
 8025742:	69b8      	ldr	r0, [r7, #24]
 8025744:	f7ff f9d4 	bl	8024af0 <_fp_exptmod_ct>
 8025748:	61f8      	str	r0, [r7, #28]
   #else
         err =  _fp_exptmod_nct(&tmp[0], &tmp[1], P, Y);
   #endif
         if ((err == 0) && (P->sign == FP_NEG)) {
 802574a:	69fb      	ldr	r3, [r7, #28]
 802574c:	2b00      	cmp	r3, #0
 802574e:	d109      	bne.n	8025764 <fp_exptmod+0x114>
 8025750:	687b      	ldr	r3, [r7, #4]
 8025752:	685b      	ldr	r3, [r3, #4]
 8025754:	2b01      	cmp	r3, #1
 8025756:	d105      	bne.n	8025764 <fp_exptmod+0x114>
            err = fp_add(Y, P, Y);
 8025758:	683a      	ldr	r2, [r7, #0]
 802575a:	6879      	ldr	r1, [r7, #4]
 802575c:	6838      	ldr	r0, [r7, #0]
 802575e:	f7fc ff5c 	bl	802261a <fp_add>
 8025762:	61f8      	str	r0, [r7, #28]
         }
      }
   #ifdef WOLFSSL_SMALL_STACK
      XFREE(tmp, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025764:	69bb      	ldr	r3, [r7, #24]
 8025766:	617b      	str	r3, [r7, #20]
 8025768:	697b      	ldr	r3, [r7, #20]
 802576a:	2b00      	cmp	r3, #0
 802576c:	d002      	beq.n	8025774 <fp_exptmod+0x124>
 802576e:	6978      	ldr	r0, [r7, #20]
 8025770:	f7f9 faa0 	bl	801ecb4 <wolfSSL_Free>
   #endif
      return err;
 8025774:	69fb      	ldr	r3, [r7, #28]
 8025776:	e01a      	b.n	80257ae <fp_exptmod+0x15e>
#else
      return FP_VAL;
#endif /* POSITIVE_EXP_ONLY check */
   }
   else if (G->used == 1 && G->dp[0] == 2) {
 8025778:	68fb      	ldr	r3, [r7, #12]
 802577a:	681b      	ldr	r3, [r3, #0]
 802577c:	2b01      	cmp	r3, #1
 802577e:	d10c      	bne.n	802579a <fp_exptmod+0x14a>
 8025780:	68fb      	ldr	r3, [r7, #12]
 8025782:	68db      	ldr	r3, [r3, #12]
 8025784:	2b02      	cmp	r3, #2
 8025786:	d108      	bne.n	802579a <fp_exptmod+0x14a>
      return _fp_exptmod_base_2(X, X->used, P, Y);
 8025788:	68bb      	ldr	r3, [r7, #8]
 802578a:	6819      	ldr	r1, [r3, #0]
 802578c:	683b      	ldr	r3, [r7, #0]
 802578e:	687a      	ldr	r2, [r7, #4]
 8025790:	68b8      	ldr	r0, [r7, #8]
 8025792:	f7ff fde7 	bl	8025364 <_fp_exptmod_base_2>
 8025796:	4603      	mov	r3, r0
 8025798:	e009      	b.n	80257ae <fp_exptmod+0x15e>
   }
   else {
      /* Positive exponent so just exptmod */
#ifdef TFM_TIMING_RESISTANT
      return _fp_exptmod_ct(G, X, X->used, P, Y);
 802579a:	68bb      	ldr	r3, [r7, #8]
 802579c:	681a      	ldr	r2, [r3, #0]
 802579e:	683b      	ldr	r3, [r7, #0]
 80257a0:	9300      	str	r3, [sp, #0]
 80257a2:	687b      	ldr	r3, [r7, #4]
 80257a4:	68b9      	ldr	r1, [r7, #8]
 80257a6:	68f8      	ldr	r0, [r7, #12]
 80257a8:	f7ff f9a2 	bl	8024af0 <_fp_exptmod_ct>
 80257ac:	4603      	mov	r3, r0
#else
      return _fp_exptmod_nct(G, X, P, Y);
#endif
   }
}
 80257ae:	4618      	mov	r0, r3
 80257b0:	3720      	adds	r7, #32
 80257b2:	46bd      	mov	sp, r7
 80257b4:	bd80      	pop	{r7, pc}

080257b6 <fp_exptmod_nct>:
#endif
   }
}

int fp_exptmod_nct(fp_int * G, fp_int * X, fp_int * P, fp_int * Y)
{
 80257b6:	b580      	push	{r7, lr}
 80257b8:	b088      	sub	sp, #32
 80257ba:	af00      	add	r7, sp, #0
 80257bc:	60f8      	str	r0, [r7, #12]
 80257be:	60b9      	str	r1, [r7, #8]
 80257c0:	607a      	str	r2, [r7, #4]
 80257c2:	603b      	str	r3, [r7, #0]
#if defined(WOLFSSL_ESP32_CRYPT_RSA_PRI_EXPTMOD)
   int retHW = FP_OKAY;
#endif

   /* handle modulus of zero and prevent overflows */
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
 80257c4:	687b      	ldr	r3, [r7, #4]
 80257c6:	681b      	ldr	r3, [r3, #0]
 80257c8:	2b00      	cmp	r3, #0
 80257ca:	d003      	beq.n	80257d4 <fp_exptmod_nct+0x1e>
 80257cc:	687b      	ldr	r3, [r7, #4]
 80257ce:	681b      	ldr	r3, [r3, #0]
 80257d0:	2b44      	cmp	r3, #68	@ 0x44
 80257d2:	dd02      	ble.n	80257da <fp_exptmod_nct+0x24>
      return FP_VAL;
 80257d4:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80257d8:	e07f      	b.n	80258da <fp_exptmod_nct+0x124>
   }
   if (fp_isone(P)) {
 80257da:	687b      	ldr	r3, [r7, #4]
 80257dc:	681b      	ldr	r3, [r3, #0]
 80257de:	2b01      	cmp	r3, #1
 80257e0:	d10d      	bne.n	80257fe <fp_exptmod_nct+0x48>
 80257e2:	687b      	ldr	r3, [r7, #4]
 80257e4:	68db      	ldr	r3, [r3, #12]
 80257e6:	2b01      	cmp	r3, #1
 80257e8:	d109      	bne.n	80257fe <fp_exptmod_nct+0x48>
 80257ea:	687b      	ldr	r3, [r7, #4]
 80257ec:	685b      	ldr	r3, [r3, #4]
 80257ee:	2b00      	cmp	r3, #0
 80257f0:	d105      	bne.n	80257fe <fp_exptmod_nct+0x48>
      fp_set(Y, 0);
 80257f2:	2100      	movs	r1, #0
 80257f4:	6838      	ldr	r0, [r7, #0]
 80257f6:	f000 fed0 	bl	802659a <fp_set>
      return FP_OKAY;
 80257fa:	2300      	movs	r3, #0
 80257fc:	e06d      	b.n	80258da <fp_exptmod_nct+0x124>
   }
   if (fp_iszero(X)) {
 80257fe:	68bb      	ldr	r3, [r7, #8]
 8025800:	681b      	ldr	r3, [r3, #0]
 8025802:	2b00      	cmp	r3, #0
 8025804:	d105      	bne.n	8025812 <fp_exptmod_nct+0x5c>
      fp_set(Y, 1);
 8025806:	2101      	movs	r1, #1
 8025808:	6838      	ldr	r0, [r7, #0]
 802580a:	f000 fec6 	bl	802659a <fp_set>
      return FP_OKAY;
 802580e:	2300      	movs	r3, #0
 8025810:	e063      	b.n	80258da <fp_exptmod_nct+0x124>
   }
   if (fp_iszero(G)) {
 8025812:	68fb      	ldr	r3, [r7, #12]
 8025814:	681b      	ldr	r3, [r3, #0]
 8025816:	2b00      	cmp	r3, #0
 8025818:	d105      	bne.n	8025826 <fp_exptmod_nct+0x70>
      fp_set(Y, 0);
 802581a:	2100      	movs	r1, #0
 802581c:	6838      	ldr	r0, [r7, #0]
 802581e:	f000 febc 	bl	802659a <fp_set>
      return FP_OKAY;
 8025822:	2300      	movs	r3, #0
 8025824:	e059      	b.n	80258da <fp_exptmod_nct+0x124>
         break;
   }
   /* falling through to SW: */
#endif

   if (X->sign == FP_NEG) {
 8025826:	68bb      	ldr	r3, [r7, #8]
 8025828:	685b      	ldr	r3, [r3, #4]
 802582a:	2b01      	cmp	r3, #1
 802582c:	d14e      	bne.n	80258cc <fp_exptmod_nct+0x116>
   #else
      fp_int *tmp;
   #endif

   #ifdef WOLFSSL_SMALL_STACK
      tmp = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802582e:	f44f 608b 	mov.w	r0, #1112	@ 0x458
 8025832:	f7f9 fa23 	bl	801ec7c <wolfSSL_Malloc>
 8025836:	61b8      	str	r0, [r7, #24]
      if (tmp == NULL)
 8025838:	69bb      	ldr	r3, [r7, #24]
 802583a:	2b00      	cmp	r3, #0
 802583c:	d102      	bne.n	8025844 <fp_exptmod_nct+0x8e>
          return FP_MEM;
 802583e:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8025842:	e04a      	b.n	80258da <fp_exptmod_nct+0x124>
   #endif

      /* yes, copy G and invmod it */
      fp_init_copy(&tmp[0], G);
 8025844:	68f9      	ldr	r1, [r7, #12]
 8025846:	69b8      	ldr	r0, [r7, #24]
 8025848:	f001 faff 	bl	8026e4a <fp_init_copy>
      fp_init_copy(&tmp[1], P);
 802584c:	69bb      	ldr	r3, [r7, #24]
 802584e:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8025852:	6879      	ldr	r1, [r7, #4]
 8025854:	4618      	mov	r0, r3
 8025856:	f001 faf8 	bl	8026e4a <fp_init_copy>
      tmp[1].sign = FP_ZPOS;
 802585a:	69bb      	ldr	r3, [r7, #24]
 802585c:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8025860:	2200      	movs	r2, #0
 8025862:	605a      	str	r2, [r3, #4]
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
 8025864:	69bb      	ldr	r3, [r7, #24]
 8025866:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802586a:	69ba      	ldr	r2, [r7, #24]
 802586c:	4619      	mov	r1, r3
 802586e:	69b8      	ldr	r0, [r7, #24]
 8025870:	f7fe fba9 	bl	8023fc6 <fp_invmod>
 8025874:	61f8      	str	r0, [r7, #28]
      if (err == FP_OKAY) {
 8025876:	69fb      	ldr	r3, [r7, #28]
 8025878:	2b00      	cmp	r3, #0
 802587a:	d11d      	bne.n	80258b8 <fp_exptmod_nct+0x102>
         X->sign = FP_ZPOS;
 802587c:	68bb      	ldr	r3, [r7, #8]
 802587e:	2200      	movs	r2, #0
 8025880:	605a      	str	r2, [r3, #4]
         err =  _fp_exptmod_nct(&tmp[0], X, P, Y);
 8025882:	683b      	ldr	r3, [r7, #0]
 8025884:	687a      	ldr	r2, [r7, #4]
 8025886:	68b9      	ldr	r1, [r7, #8]
 8025888:	69b8      	ldr	r0, [r7, #24]
 802588a:	f7ff fa91 	bl	8024db0 <_fp_exptmod_nct>
 802588e:	61f8      	str	r0, [r7, #28]
         if (X != Y) {
 8025890:	68ba      	ldr	r2, [r7, #8]
 8025892:	683b      	ldr	r3, [r7, #0]
 8025894:	429a      	cmp	r2, r3
 8025896:	d002      	beq.n	802589e <fp_exptmod_nct+0xe8>
            X->sign = FP_NEG;
 8025898:	68bb      	ldr	r3, [r7, #8]
 802589a:	2201      	movs	r2, #1
 802589c:	605a      	str	r2, [r3, #4]
         }
         if ((err == 0) && (P->sign == FP_NEG)) {
 802589e:	69fb      	ldr	r3, [r7, #28]
 80258a0:	2b00      	cmp	r3, #0
 80258a2:	d109      	bne.n	80258b8 <fp_exptmod_nct+0x102>
 80258a4:	687b      	ldr	r3, [r7, #4]
 80258a6:	685b      	ldr	r3, [r3, #4]
 80258a8:	2b01      	cmp	r3, #1
 80258aa:	d105      	bne.n	80258b8 <fp_exptmod_nct+0x102>
            err = fp_add(Y, P, Y);
 80258ac:	683a      	ldr	r2, [r7, #0]
 80258ae:	6879      	ldr	r1, [r7, #4]
 80258b0:	6838      	ldr	r0, [r7, #0]
 80258b2:	f7fc feb2 	bl	802261a <fp_add>
 80258b6:	61f8      	str	r0, [r7, #28]
         }
      }
   #ifdef WOLFSSL_SMALL_STACK
      XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 80258b8:	69bb      	ldr	r3, [r7, #24]
 80258ba:	617b      	str	r3, [r7, #20]
 80258bc:	697b      	ldr	r3, [r7, #20]
 80258be:	2b00      	cmp	r3, #0
 80258c0:	d002      	beq.n	80258c8 <fp_exptmod_nct+0x112>
 80258c2:	6978      	ldr	r0, [r7, #20]
 80258c4:	f7f9 f9f6 	bl	801ecb4 <wolfSSL_Free>
   #endif
      return err;
 80258c8:	69fb      	ldr	r3, [r7, #28]
 80258ca:	e006      	b.n	80258da <fp_exptmod_nct+0x124>
      return FP_VAL;
#endif
   }
   else {
      /* Positive exponent so just exptmod */
      return  _fp_exptmod_nct(G, X, P, Y);
 80258cc:	683b      	ldr	r3, [r7, #0]
 80258ce:	687a      	ldr	r2, [r7, #4]
 80258d0:	68b9      	ldr	r1, [r7, #8]
 80258d2:	68f8      	ldr	r0, [r7, #12]
 80258d4:	f7ff fa6c 	bl	8024db0 <_fp_exptmod_nct>
 80258d8:	4603      	mov	r3, r0
   }
}
 80258da:	4618      	mov	r0, r3
 80258dc:	3720      	adds	r7, #32
 80258de:	46bd      	mov	sp, r7
 80258e0:	bd80      	pop	{r7, pc}

080258e2 <fp_2expt>:

/* computes a = 2**b */
void fp_2expt(fp_int *a, int b)
{
 80258e2:	b580      	push	{r7, lr}
 80258e4:	b084      	sub	sp, #16
 80258e6:	af00      	add	r7, sp, #0
 80258e8:	6078      	str	r0, [r7, #4]
 80258ea:	6039      	str	r1, [r7, #0]
   int     z;

   /* zero a as per default */
   fp_zero (a);
 80258ec:	6878      	ldr	r0, [r7, #4]
 80258ee:	f001 f891 	bl	8026a14 <fp_zero>

   if (b < 0) {
 80258f2:	683b      	ldr	r3, [r7, #0]
 80258f4:	2b00      	cmp	r3, #0
 80258f6:	db18      	blt.n	802592a <fp_2expt+0x48>
      return;
   }

   z = b / DIGIT_BIT;
 80258f8:	683b      	ldr	r3, [r7, #0]
 80258fa:	2b00      	cmp	r3, #0
 80258fc:	da00      	bge.n	8025900 <fp_2expt+0x1e>
 80258fe:	331f      	adds	r3, #31
 8025900:	115b      	asrs	r3, r3, #5
 8025902:	60fb      	str	r3, [r7, #12]
   if (z >= FP_SIZE) {
 8025904:	68fb      	ldr	r3, [r7, #12]
 8025906:	2b87      	cmp	r3, #135	@ 0x87
 8025908:	dc11      	bgt.n	802592e <fp_2expt+0x4c>
      return;
   }

  /* set the used count of where the bit will go */
  a->used = z + 1;
 802590a:	68fb      	ldr	r3, [r7, #12]
 802590c:	1c5a      	adds	r2, r3, #1
 802590e:	687b      	ldr	r3, [r7, #4]
 8025910:	601a      	str	r2, [r3, #0]

  /* put the single bit in its place */
  a->dp[z] = ((fp_digit)1) << (b % DIGIT_BIT);
 8025912:	683b      	ldr	r3, [r7, #0]
 8025914:	f003 031f 	and.w	r3, r3, #31
 8025918:	2201      	movs	r2, #1
 802591a:	409a      	lsls	r2, r3
 802591c:	6879      	ldr	r1, [r7, #4]
 802591e:	68fb      	ldr	r3, [r7, #12]
 8025920:	3302      	adds	r3, #2
 8025922:	009b      	lsls	r3, r3, #2
 8025924:	440b      	add	r3, r1
 8025926:	605a      	str	r2, [r3, #4]
 8025928:	e002      	b.n	8025930 <fp_2expt+0x4e>
      return;
 802592a:	bf00      	nop
 802592c:	e000      	b.n	8025930 <fp_2expt+0x4e>
      return;
 802592e:	bf00      	nop
}
 8025930:	3710      	adds	r7, #16
 8025932:	46bd      	mov	sp, r7
 8025934:	bd80      	pop	{r7, pc}

08025936 <fp_sqr>:

/* b = a*a  */
int fp_sqr(fp_int *A, fp_int *B)
{
 8025936:	b580      	push	{r7, lr}
 8025938:	b086      	sub	sp, #24
 802593a:	af00      	add	r7, sp, #0
 802593c:	6078      	str	r0, [r7, #4]
 802593e:	6039      	str	r1, [r7, #0]
    int err;
    int y, oldused;

    oldused = B->used;
 8025940:	683b      	ldr	r3, [r7, #0]
 8025942:	681b      	ldr	r3, [r3, #0]
 8025944:	60fb      	str	r3, [r7, #12]
    y = A->used;
 8025946:	687b      	ldr	r3, [r7, #4]
 8025948:	681b      	ldr	r3, [r3, #0]
 802594a:	613b      	str	r3, [r7, #16]

    /* error if we're out of range */
    if (y + y >= FP_SIZE) {
 802594c:	693b      	ldr	r3, [r7, #16]
 802594e:	005b      	lsls	r3, r3, #1
 8025950:	2b87      	cmp	r3, #135	@ 0x87
 8025952:	dd03      	ble.n	802595c <fp_sqr+0x26>
       err = FP_VAL;
 8025954:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025958:	617b      	str	r3, [r7, #20]
       goto clean;
 802595a:	e004      	b.n	8025966 <fp_sqr+0x30>
        if (y <= 64) {
           err = fp_sqr_comba64(A,B);
           goto clean;
        }
#endif
       err = fp_sqr_comba(A, B);
 802595c:	6839      	ldr	r1, [r7, #0]
 802595e:	6878      	ldr	r0, [r7, #4]
 8025960:	f000 f81b 	bl	802599a <fp_sqr_comba>
 8025964:	6178      	str	r0, [r7, #20]

clean:
  /* zero any excess digits on the destination that we didn't write to */
  for (y = B->used; y >= 0 && y < oldused; y++) {
 8025966:	683b      	ldr	r3, [r7, #0]
 8025968:	681b      	ldr	r3, [r3, #0]
 802596a:	613b      	str	r3, [r7, #16]
 802596c:	e009      	b.n	8025982 <fp_sqr+0x4c>
    B->dp[y] = 0;
 802596e:	683a      	ldr	r2, [r7, #0]
 8025970:	693b      	ldr	r3, [r7, #16]
 8025972:	3302      	adds	r3, #2
 8025974:	009b      	lsls	r3, r3, #2
 8025976:	4413      	add	r3, r2
 8025978:	2200      	movs	r2, #0
 802597a:	605a      	str	r2, [r3, #4]
  for (y = B->used; y >= 0 && y < oldused; y++) {
 802597c:	693b      	ldr	r3, [r7, #16]
 802597e:	3301      	adds	r3, #1
 8025980:	613b      	str	r3, [r7, #16]
 8025982:	693b      	ldr	r3, [r7, #16]
 8025984:	2b00      	cmp	r3, #0
 8025986:	db03      	blt.n	8025990 <fp_sqr+0x5a>
 8025988:	693a      	ldr	r2, [r7, #16]
 802598a:	68fb      	ldr	r3, [r7, #12]
 802598c:	429a      	cmp	r2, r3
 802598e:	dbee      	blt.n	802596e <fp_sqr+0x38>
  }

  return err;
 8025990:	697b      	ldr	r3, [r7, #20]
}
 8025992:	4618      	mov	r0, r3
 8025994:	3718      	adds	r7, #24
 8025996:	46bd      	mov	sp, r7
 8025998:	bd80      	pop	{r7, pc}

0802599a <fp_sqr_comba>:

/* generic comba squarer */
int fp_sqr_comba(fp_int *A, fp_int *B)
{
 802599a:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 802599e:	b0b6      	sub	sp, #216	@ 0xd8
 80259a0:	af00      	add	r7, sp, #0
 80259a2:	67f8      	str	r0, [r7, #124]	@ 0x7c
 80259a4:	67b9      	str	r1, [r7, #120]	@ 0x78
  int       pa, ix, iz;
  fp_digit  c0, c1, c2;
#ifdef TFM_ISO
  fp_word   tt = 0;
 80259a6:	f04f 0200 	mov.w	r2, #0
 80259aa:	f04f 0300 	mov.w	r3, #0
 80259ae:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
#else
   fp_int    *tmp;
#endif

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 80259b2:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 80259b6:	f7f9 f961 	bl	801ec7c <wolfSSL_Malloc>
 80259ba:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
   if (tmp == NULL)
 80259be:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80259c2:	2b00      	cmp	r3, #0
 80259c4:	d102      	bne.n	80259cc <fp_sqr_comba+0x32>
       return FP_MEM;
 80259c6:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80259ca:	e1f6      	b.n	8025dba <fp_sqr_comba+0x420>
#endif

  /* get size of output and trim */
  pa = A->used + A->used;
 80259cc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80259ce:	681b      	ldr	r3, [r3, #0]
 80259d0:	005b      	lsls	r3, r3, #1
 80259d2:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  if (pa >= FP_SIZE) {
 80259d6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80259da:	2b87      	cmp	r3, #135	@ 0x87
 80259dc:	dd02      	ble.n	80259e4 <fp_sqr_comba+0x4a>
     pa = FP_SIZE-1;
 80259de:	2387      	movs	r3, #135	@ 0x87
 80259e0:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  }

  /* number of output digits to produce */
  COMBA_START;
  COMBA_CLEAR;
 80259e4:	2300      	movs	r3, #0
 80259e6:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80259ea:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80259ee:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 80259f2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80259f6:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

  if (A == B) {
 80259fa:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 80259fc:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80259fe:	429a      	cmp	r2, r3
 8025a00:	d108      	bne.n	8025a14 <fp_sqr_comba+0x7a>
     fp_init(tmp);
 8025a02:	f8d7 00a4 	ldr.w	r0, [r7, #164]	@ 0xa4
 8025a06:	f000 fff7 	bl	80269f8 <fp_init>
     dst = tmp;
 8025a0a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8025a0e:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 8025a12:	e005      	b.n	8025a20 <fp_sqr_comba+0x86>
  } else {
     fp_zero(B);
 8025a14:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8025a16:	f000 fffd 	bl	8026a14 <fp_zero>
     dst = B;
 8025a1a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8025a1c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  }

  for (ix = 0; ix < pa; ix++) {
 8025a20:	2300      	movs	r3, #0
 8025a22:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 8025a26:	e17f      	b.n	8025d28 <fp_sqr_comba+0x38e>
      int      tx, ty, iy;
      fp_digit *tmpy, *tmpx;

      /* get offsets into the two bignums */
      ty = MIN(A->used-1, ix);
 8025a28:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025a2a:	681a      	ldr	r2, [r3, #0]
 8025a2c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025a30:	4293      	cmp	r3, r2
 8025a32:	db03      	blt.n	8025a3c <fp_sqr_comba+0xa2>
 8025a34:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025a36:	681b      	ldr	r3, [r3, #0]
 8025a38:	3b01      	subs	r3, #1
 8025a3a:	e001      	b.n	8025a40 <fp_sqr_comba+0xa6>
 8025a3c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025a40:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
      tx = ix - ty;
 8025a44:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8025a48:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8025a4c:	1ad3      	subs	r3, r2, r3
 8025a4e:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98

      /* setup temp aliases */
      tmpx = A->dp + tx;
 8025a52:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025a54:	f103 020c 	add.w	r2, r3, #12
 8025a58:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8025a5c:	009b      	lsls	r3, r3, #2
 8025a5e:	4413      	add	r3, r2
 8025a60:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
      tmpy = A->dp + ty;
 8025a64:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025a66:	f103 020c 	add.w	r2, r3, #12
 8025a6a:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8025a6e:	009b      	lsls	r3, r3, #2
 8025a70:	4413      	add	r3, r2
 8025a72:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

      /* this is the number of times the loop will iterate,
         while (tx++ < a->used && ty-- >= 0) { ... }
       */
      iy = MIN(A->used-tx, ty+1);
 8025a76:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025a78:	681a      	ldr	r2, [r3, #0]
 8025a7a:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8025a7e:	1ad2      	subs	r2, r2, r3
 8025a80:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8025a84:	4293      	cmp	r3, r2
 8025a86:	db05      	blt.n	8025a94 <fp_sqr_comba+0xfa>
 8025a88:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025a8a:	681a      	ldr	r2, [r3, #0]
 8025a8c:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8025a90:	1ad3      	subs	r3, r2, r3
 8025a92:	e002      	b.n	8025a9a <fp_sqr_comba+0x100>
 8025a94:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8025a98:	3301      	adds	r3, #1
 8025a9a:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
      /* now for squaring tx can never equal ty
       * we halve the distance since they approach
       * at a rate of 2x and we have to round because
       * odd cases need to be executed
       */
      iy = MIN(iy, (ty-tx+1)>>1);
 8025a9e:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8025aa2:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8025aa6:	1ad3      	subs	r3, r2, r3
 8025aa8:	3301      	adds	r3, #1
 8025aaa:	105a      	asrs	r2, r3, #1
 8025aac:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8025ab0:	4293      	cmp	r3, r2
 8025ab2:	bfa8      	it	ge
 8025ab4:	4613      	movge	r3, r2
 8025ab6:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

      /* forward carries */
      COMBA_FORWARD;
 8025aba:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025abe:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8025ac2:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8025ac6:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8025aca:	2300      	movs	r3, #0
 8025acc:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0

      /* execute loop */
      for (iz = 0; iz < iy; iz++) {
 8025ad0:	2300      	movs	r3, #0
 8025ad2:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 8025ad6:	e0a9      	b.n	8025c2c <fp_sqr_comba+0x292>
          SQRADD2(*tmpx++, *tmpy--);
 8025ad8:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8025adc:	1d13      	adds	r3, r2, #4
 8025ade:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 8025ae2:	6813      	ldr	r3, [r2, #0]
 8025ae4:	2200      	movs	r2, #0
 8025ae6:	673b      	str	r3, [r7, #112]	@ 0x70
 8025ae8:	677a      	str	r2, [r7, #116]	@ 0x74
 8025aea:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8025aee:	1f13      	subs	r3, r2, #4
 8025af0:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 8025af4:	6813      	ldr	r3, [r2, #0]
 8025af6:	2200      	movs	r2, #0
 8025af8:	66bb      	str	r3, [r7, #104]	@ 0x68
 8025afa:	66fa      	str	r2, [r7, #108]	@ 0x6c
 8025afc:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
 8025b00:	460b      	mov	r3, r1
 8025b02:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8025b04:	fb02 f203 	mul.w	r2, r2, r3
 8025b08:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8025b0a:	e9c7 011c 	strd	r0, r1, [r7, #112]	@ 0x70
 8025b0e:	4601      	mov	r1, r0
 8025b10:	fb01 f303 	mul.w	r3, r1, r3
 8025b14:	4413      	add	r3, r2
 8025b16:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8025b18:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8025b1a:	fba2 8901 	umull	r8, r9, r2, r1
 8025b1e:	444b      	add	r3, r9
 8025b20:	4699      	mov	r9, r3
 8025b22:	e9c7 8920 	strd	r8, r9, [r7, #128]	@ 0x80
 8025b26:	e9c7 8920 	strd	r8, r9, [r7, #128]	@ 0x80
 8025b2a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8025b2e:	2200      	movs	r2, #0
 8025b30:	663b      	str	r3, [r7, #96]	@ 0x60
 8025b32:	667a      	str	r2, [r7, #100]	@ 0x64
 8025b34:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8025b38:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8025b3a:	1851      	adds	r1, r2, r1
 8025b3c:	62b9      	str	r1, [r7, #40]	@ 0x28
 8025b3e:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8025b40:	414b      	adcs	r3, r1
 8025b42:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8025b44:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8025b48:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 8025b4c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8025b50:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8025b54:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025b58:	2200      	movs	r2, #0
 8025b5a:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025b5c:	65fa      	str	r2, [r7, #92]	@ 0x5c
 8025b5e:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8025b62:	f04f 0000 	mov.w	r0, #0
 8025b66:	f04f 0100 	mov.w	r1, #0
 8025b6a:	0018      	movs	r0, r3
 8025b6c:	2100      	movs	r1, #0
 8025b6e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025b70:	181b      	adds	r3, r3, r0
 8025b72:	623b      	str	r3, [r7, #32]
 8025b74:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8025b76:	414b      	adcs	r3, r1
 8025b78:	627b      	str	r3, [r7, #36]	@ 0x24
 8025b7a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8025b7e:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 8025b82:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8025b86:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8025b8a:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8025b8e:	f04f 0000 	mov.w	r0, #0
 8025b92:	f04f 0100 	mov.w	r1, #0
 8025b96:	0018      	movs	r0, r3
 8025b98:	2100      	movs	r1, #0
 8025b9a:	4602      	mov	r2, r0
 8025b9c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8025ba0:	4413      	add	r3, r2
 8025ba2:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8025ba6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8025baa:	2200      	movs	r2, #0
 8025bac:	653b      	str	r3, [r7, #80]	@ 0x50
 8025bae:	657a      	str	r2, [r7, #84]	@ 0x54
 8025bb0:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8025bb4:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8025bb6:	1851      	adds	r1, r2, r1
 8025bb8:	61b9      	str	r1, [r7, #24]
 8025bba:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8025bbc:	414b      	adcs	r3, r1
 8025bbe:	61fb      	str	r3, [r7, #28]
 8025bc0:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8025bc4:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 8025bc8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8025bcc:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8025bd0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025bd4:	2200      	movs	r2, #0
 8025bd6:	64bb      	str	r3, [r7, #72]	@ 0x48
 8025bd8:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8025bda:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8025bde:	f04f 0000 	mov.w	r0, #0
 8025be2:	f04f 0100 	mov.w	r1, #0
 8025be6:	0018      	movs	r0, r3
 8025be8:	2100      	movs	r1, #0
 8025bea:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8025bec:	181b      	adds	r3, r3, r0
 8025bee:	613b      	str	r3, [r7, #16]
 8025bf0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025bf2:	414b      	adcs	r3, r1
 8025bf4:	617b      	str	r3, [r7, #20]
 8025bf6:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8025bfa:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 8025bfe:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8025c02:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8025c06:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8025c0a:	f04f 0000 	mov.w	r0, #0
 8025c0e:	f04f 0100 	mov.w	r1, #0
 8025c12:	0018      	movs	r0, r3
 8025c14:	2100      	movs	r1, #0
 8025c16:	4602      	mov	r2, r0
 8025c18:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8025c1c:	4413      	add	r3, r2
 8025c1e:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
      for (iz = 0; iz < iy; iz++) {
 8025c22:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8025c26:	3301      	adds	r3, #1
 8025c28:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 8025c2c:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8025c30:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8025c34:	429a      	cmp	r2, r3
 8025c36:	f6ff af4f 	blt.w	8025ad8 <fp_sqr_comba+0x13e>
      }

      /* even columns have the square term in them */
      if ((ix&1) == 0) {
 8025c3a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025c3e:	f003 0301 	and.w	r3, r3, #1
 8025c42:	2b00      	cmp	r3, #0
 8025c44:	d161      	bne.n	8025d0a <fp_sqr_comba+0x370>
          /* TAO change COMBA_ADD back to SQRADD */
          SQRADD(A->dp[ix>>1], A->dp[ix>>1]);
 8025c46:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8025c4a:	2200      	movs	r2, #0
 8025c4c:	63bb      	str	r3, [r7, #56]	@ 0x38
 8025c4e:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8025c50:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025c54:	105b      	asrs	r3, r3, #1
 8025c56:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8025c58:	3302      	adds	r3, #2
 8025c5a:	009b      	lsls	r3, r3, #2
 8025c5c:	4413      	add	r3, r2
 8025c5e:	685b      	ldr	r3, [r3, #4]
 8025c60:	2200      	movs	r2, #0
 8025c62:	633b      	str	r3, [r7, #48]	@ 0x30
 8025c64:	637a      	str	r2, [r7, #52]	@ 0x34
 8025c66:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025c6a:	105b      	asrs	r3, r3, #1
 8025c6c:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8025c6e:	3302      	adds	r3, #2
 8025c70:	009b      	lsls	r3, r3, #2
 8025c72:	4413      	add	r3, r2
 8025c74:	685b      	ldr	r3, [r3, #4]
 8025c76:	2200      	movs	r2, #0
 8025c78:	469a      	mov	sl, r3
 8025c7a:	4693      	mov	fp, r2
 8025c7c:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
 8025c80:	460b      	mov	r3, r1
 8025c82:	fb0a f203 	mul.w	r2, sl, r3
 8025c86:	4603      	mov	r3, r0
 8025c88:	fb03 f30b 	mul.w	r3, r3, fp
 8025c8c:	4413      	add	r3, r2
 8025c8e:	4602      	mov	r2, r0
 8025c90:	fba2 450a 	umull	r4, r5, r2, sl
 8025c94:	442b      	add	r3, r5
 8025c96:	461d      	mov	r5, r3
 8025c98:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 8025c9c:	460b      	mov	r3, r1
 8025c9e:	191b      	adds	r3, r3, r4
 8025ca0:	60bb      	str	r3, [r7, #8]
 8025ca2:	4613      	mov	r3, r2
 8025ca4:	416b      	adcs	r3, r5
 8025ca6:	60fb      	str	r3, [r7, #12]
 8025ca8:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8025cac:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
 8025cb0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8025cb4:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8025cb8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025cbc:	2200      	movs	r2, #0
 8025cbe:	643b      	str	r3, [r7, #64]	@ 0x40
 8025cc0:	647a      	str	r2, [r7, #68]	@ 0x44
 8025cc2:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8025cc6:	f04f 0000 	mov.w	r0, #0
 8025cca:	f04f 0100 	mov.w	r1, #0
 8025cce:	0018      	movs	r0, r3
 8025cd0:	2100      	movs	r1, #0
 8025cd2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025cd4:	181b      	adds	r3, r3, r0
 8025cd6:	603b      	str	r3, [r7, #0]
 8025cd8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025cda:	414b      	adcs	r3, r1
 8025cdc:	607b      	str	r3, [r7, #4]
 8025cde:	e9d7 2300 	ldrd	r2, r3, [r7]
 8025ce2:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
 8025ce6:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8025cea:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8025cee:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8025cf2:	f04f 0000 	mov.w	r0, #0
 8025cf6:	f04f 0100 	mov.w	r1, #0
 8025cfa:	0018      	movs	r0, r3
 8025cfc:	2100      	movs	r1, #0
 8025cfe:	4602      	mov	r2, r0
 8025d00:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8025d04:	4413      	add	r3, r2
 8025d06:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
      }

      /* store it */
      COMBA_STORE(dst->dp[ix]);
 8025d0a:	f8d7 10bc 	ldr.w	r1, [r7, #188]	@ 0xbc
 8025d0e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025d12:	3302      	adds	r3, #2
 8025d14:	009a      	lsls	r2, r3, #2
 8025d16:	440a      	add	r2, r1
 8025d18:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8025d1c:	6053      	str	r3, [r2, #4]
  for (ix = 0; ix < pa; ix++) {
 8025d1e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025d22:	3301      	adds	r3, #1
 8025d24:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 8025d28:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8025d2c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8025d30:	429a      	cmp	r2, r3
 8025d32:	f6ff ae79 	blt.w	8025a28 <fp_sqr_comba+0x8e>
  }

  COMBA_FINI;

  /* setup dest */
  dst->used = pa;
 8025d36:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025d3a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8025d3e:	601a      	str	r2, [r3, #0]
  fp_clamp (dst);
 8025d40:	e006      	b.n	8025d50 <fp_sqr_comba+0x3b6>
 8025d42:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025d46:	681b      	ldr	r3, [r3, #0]
 8025d48:	1e5a      	subs	r2, r3, #1
 8025d4a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025d4e:	601a      	str	r2, [r3, #0]
 8025d50:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025d54:	681b      	ldr	r3, [r3, #0]
 8025d56:	2b00      	cmp	r3, #0
 8025d58:	d00b      	beq.n	8025d72 <fp_sqr_comba+0x3d8>
 8025d5a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025d5e:	681b      	ldr	r3, [r3, #0]
 8025d60:	3b01      	subs	r3, #1
 8025d62:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8025d66:	3302      	adds	r3, #2
 8025d68:	009b      	lsls	r3, r3, #2
 8025d6a:	4413      	add	r3, r2
 8025d6c:	685b      	ldr	r3, [r3, #4]
 8025d6e:	2b00      	cmp	r3, #0
 8025d70:	d0e7      	beq.n	8025d42 <fp_sqr_comba+0x3a8>
 8025d72:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025d76:	681b      	ldr	r3, [r3, #0]
 8025d78:	2b00      	cmp	r3, #0
 8025d7a:	d003      	beq.n	8025d84 <fp_sqr_comba+0x3ea>
 8025d7c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025d80:	685b      	ldr	r3, [r3, #4]
 8025d82:	e000      	b.n	8025d86 <fp_sqr_comba+0x3ec>
 8025d84:	2300      	movs	r3, #0
 8025d86:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8025d8a:	6053      	str	r3, [r2, #4]
  if (dst != B) {
 8025d8c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8025d90:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8025d92:	429a      	cmp	r2, r3
 8025d94:	d004      	beq.n	8025da0 <fp_sqr_comba+0x406>
     fp_copy(dst, B);
 8025d96:	6fb9      	ldr	r1, [r7, #120]	@ 0x78
 8025d98:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8025d9c:	f001 f816 	bl	8026dcc <fp_copy>
#ifdef TFM_ISO
  (void)tt;
#endif

#ifdef WOLFSSL_SMALL_STACK
  XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8025da0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8025da4:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8025da8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8025dac:	2b00      	cmp	r3, #0
 8025dae:	d003      	beq.n	8025db8 <fp_sqr_comba+0x41e>
 8025db0:	f8d7 00a0 	ldr.w	r0, [r7, #160]	@ 0xa0
 8025db4:	f7f8 ff7e 	bl	801ecb4 <wolfSSL_Free>
#endif
  return FP_OKAY;
 8025db8:	2300      	movs	r3, #0
}
 8025dba:	4618      	mov	r0, r3
 8025dbc:	37d8      	adds	r7, #216	@ 0xd8
 8025dbe:	46bd      	mov	sp, r7
 8025dc0:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08025dc4 <fp_cmp>:

int fp_cmp(fp_int *a, fp_int *b)
{
 8025dc4:	b580      	push	{r7, lr}
 8025dc6:	b082      	sub	sp, #8
 8025dc8:	af00      	add	r7, sp, #0
 8025dca:	6078      	str	r0, [r7, #4]
 8025dcc:	6039      	str	r1, [r7, #0]
   if (a->sign == FP_NEG && b->sign == FP_ZPOS) {
 8025dce:	687b      	ldr	r3, [r7, #4]
 8025dd0:	685b      	ldr	r3, [r3, #4]
 8025dd2:	2b01      	cmp	r3, #1
 8025dd4:	d106      	bne.n	8025de4 <fp_cmp+0x20>
 8025dd6:	683b      	ldr	r3, [r7, #0]
 8025dd8:	685b      	ldr	r3, [r3, #4]
 8025dda:	2b00      	cmp	r3, #0
 8025ddc:	d102      	bne.n	8025de4 <fp_cmp+0x20>
      return FP_LT;
 8025dde:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025de2:	e018      	b.n	8025e16 <fp_cmp+0x52>
   } else if (a->sign == FP_ZPOS && b->sign == FP_NEG) {
 8025de4:	687b      	ldr	r3, [r7, #4]
 8025de6:	685b      	ldr	r3, [r3, #4]
 8025de8:	2b00      	cmp	r3, #0
 8025dea:	d105      	bne.n	8025df8 <fp_cmp+0x34>
 8025dec:	683b      	ldr	r3, [r7, #0]
 8025dee:	685b      	ldr	r3, [r3, #4]
 8025df0:	2b01      	cmp	r3, #1
 8025df2:	d101      	bne.n	8025df8 <fp_cmp+0x34>
      return FP_GT;
 8025df4:	2301      	movs	r3, #1
 8025df6:	e00e      	b.n	8025e16 <fp_cmp+0x52>
   } else {
      /* compare digits */
      if (a->sign == FP_NEG) {
 8025df8:	687b      	ldr	r3, [r7, #4]
 8025dfa:	685b      	ldr	r3, [r3, #4]
 8025dfc:	2b01      	cmp	r3, #1
 8025dfe:	d105      	bne.n	8025e0c <fp_cmp+0x48>
         /* if negative compare opposite direction */
         return fp_cmp_mag(b, a);
 8025e00:	6879      	ldr	r1, [r7, #4]
 8025e02:	6838      	ldr	r0, [r7, #0]
 8025e04:	f000 f843 	bl	8025e8e <fp_cmp_mag>
 8025e08:	4603      	mov	r3, r0
 8025e0a:	e004      	b.n	8025e16 <fp_cmp+0x52>
      } else {
         return fp_cmp_mag(a, b);
 8025e0c:	6839      	ldr	r1, [r7, #0]
 8025e0e:	6878      	ldr	r0, [r7, #4]
 8025e10:	f000 f83d 	bl	8025e8e <fp_cmp_mag>
 8025e14:	4603      	mov	r3, r0
      }
   }
}
 8025e16:	4618      	mov	r0, r3
 8025e18:	3708      	adds	r7, #8
 8025e1a:	46bd      	mov	sp, r7
 8025e1c:	bd80      	pop	{r7, pc}

08025e1e <fp_cmp_d>:

/* compare against a single digit */
int fp_cmp_d(fp_int *a, fp_digit b)
{
 8025e1e:	b480      	push	{r7}
 8025e20:	b083      	sub	sp, #12
 8025e22:	af00      	add	r7, sp, #0
 8025e24:	6078      	str	r0, [r7, #4]
 8025e26:	6039      	str	r1, [r7, #0]
  /* special case for zero*/
  if (a->used == 0 && b == 0)
 8025e28:	687b      	ldr	r3, [r7, #4]
 8025e2a:	681b      	ldr	r3, [r3, #0]
 8025e2c:	2b00      	cmp	r3, #0
 8025e2e:	d104      	bne.n	8025e3a <fp_cmp_d+0x1c>
 8025e30:	683b      	ldr	r3, [r7, #0]
 8025e32:	2b00      	cmp	r3, #0
 8025e34:	d101      	bne.n	8025e3a <fp_cmp_d+0x1c>
    return FP_EQ;
 8025e36:	2300      	movs	r3, #0
 8025e38:	e023      	b.n	8025e82 <fp_cmp_d+0x64>

  /* compare based on sign */
  if ((b && a->used == 0) || a->sign == FP_NEG) {
 8025e3a:	683b      	ldr	r3, [r7, #0]
 8025e3c:	2b00      	cmp	r3, #0
 8025e3e:	d003      	beq.n	8025e48 <fp_cmp_d+0x2a>
 8025e40:	687b      	ldr	r3, [r7, #4]
 8025e42:	681b      	ldr	r3, [r3, #0]
 8025e44:	2b00      	cmp	r3, #0
 8025e46:	d003      	beq.n	8025e50 <fp_cmp_d+0x32>
 8025e48:	687b      	ldr	r3, [r7, #4]
 8025e4a:	685b      	ldr	r3, [r3, #4]
 8025e4c:	2b01      	cmp	r3, #1
 8025e4e:	d102      	bne.n	8025e56 <fp_cmp_d+0x38>
    return FP_LT;
 8025e50:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025e54:	e015      	b.n	8025e82 <fp_cmp_d+0x64>
  }

  /* compare based on magnitude */
  if (a->used > 1) {
 8025e56:	687b      	ldr	r3, [r7, #4]
 8025e58:	681b      	ldr	r3, [r3, #0]
 8025e5a:	2b01      	cmp	r3, #1
 8025e5c:	dd01      	ble.n	8025e62 <fp_cmp_d+0x44>
    return FP_GT;
 8025e5e:	2301      	movs	r3, #1
 8025e60:	e00f      	b.n	8025e82 <fp_cmp_d+0x64>
  }

  /* compare the only digit of a to b */
  if (a->dp[0] > b) {
 8025e62:	687b      	ldr	r3, [r7, #4]
 8025e64:	68db      	ldr	r3, [r3, #12]
 8025e66:	683a      	ldr	r2, [r7, #0]
 8025e68:	429a      	cmp	r2, r3
 8025e6a:	d201      	bcs.n	8025e70 <fp_cmp_d+0x52>
    return FP_GT;
 8025e6c:	2301      	movs	r3, #1
 8025e6e:	e008      	b.n	8025e82 <fp_cmp_d+0x64>
  } else if (a->dp[0] < b) {
 8025e70:	687b      	ldr	r3, [r7, #4]
 8025e72:	68db      	ldr	r3, [r3, #12]
 8025e74:	683a      	ldr	r2, [r7, #0]
 8025e76:	429a      	cmp	r2, r3
 8025e78:	d902      	bls.n	8025e80 <fp_cmp_d+0x62>
    return FP_LT;
 8025e7a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025e7e:	e000      	b.n	8025e82 <fp_cmp_d+0x64>
  } else {
    return FP_EQ;
 8025e80:	2300      	movs	r3, #0
  }

}
 8025e82:	4618      	mov	r0, r3
 8025e84:	370c      	adds	r7, #12
 8025e86:	46bd      	mov	sp, r7
 8025e88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025e8c:	4770      	bx	lr

08025e8e <fp_cmp_mag>:

int fp_cmp_mag(fp_int *a, fp_int *b)
{
 8025e8e:	b480      	push	{r7}
 8025e90:	b085      	sub	sp, #20
 8025e92:	af00      	add	r7, sp, #0
 8025e94:	6078      	str	r0, [r7, #4]
 8025e96:	6039      	str	r1, [r7, #0]
   int x;

   if (a->used > b->used) {
 8025e98:	687b      	ldr	r3, [r7, #4]
 8025e9a:	681a      	ldr	r2, [r3, #0]
 8025e9c:	683b      	ldr	r3, [r7, #0]
 8025e9e:	681b      	ldr	r3, [r3, #0]
 8025ea0:	429a      	cmp	r2, r3
 8025ea2:	dd01      	ble.n	8025ea8 <fp_cmp_mag+0x1a>
      return FP_GT;
 8025ea4:	2301      	movs	r3, #1
 8025ea6:	e035      	b.n	8025f14 <fp_cmp_mag+0x86>
   } else if (a->used < b->used) {
 8025ea8:	687b      	ldr	r3, [r7, #4]
 8025eaa:	681a      	ldr	r2, [r3, #0]
 8025eac:	683b      	ldr	r3, [r7, #0]
 8025eae:	681b      	ldr	r3, [r3, #0]
 8025eb0:	429a      	cmp	r2, r3
 8025eb2:	da02      	bge.n	8025eba <fp_cmp_mag+0x2c>
      return FP_LT;
 8025eb4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025eb8:	e02c      	b.n	8025f14 <fp_cmp_mag+0x86>
   } else {
      for (x = a->used - 1; x >= 0; x--) {
 8025eba:	687b      	ldr	r3, [r7, #4]
 8025ebc:	681b      	ldr	r3, [r3, #0]
 8025ebe:	3b01      	subs	r3, #1
 8025ec0:	60fb      	str	r3, [r7, #12]
 8025ec2:	e023      	b.n	8025f0c <fp_cmp_mag+0x7e>
          if (a->dp[x] > b->dp[x]) {
 8025ec4:	687a      	ldr	r2, [r7, #4]
 8025ec6:	68fb      	ldr	r3, [r7, #12]
 8025ec8:	3302      	adds	r3, #2
 8025eca:	009b      	lsls	r3, r3, #2
 8025ecc:	4413      	add	r3, r2
 8025ece:	685a      	ldr	r2, [r3, #4]
 8025ed0:	6839      	ldr	r1, [r7, #0]
 8025ed2:	68fb      	ldr	r3, [r7, #12]
 8025ed4:	3302      	adds	r3, #2
 8025ed6:	009b      	lsls	r3, r3, #2
 8025ed8:	440b      	add	r3, r1
 8025eda:	685b      	ldr	r3, [r3, #4]
 8025edc:	429a      	cmp	r2, r3
 8025ede:	d901      	bls.n	8025ee4 <fp_cmp_mag+0x56>
             return FP_GT;
 8025ee0:	2301      	movs	r3, #1
 8025ee2:	e017      	b.n	8025f14 <fp_cmp_mag+0x86>
          } else if (a->dp[x] < b->dp[x]) {
 8025ee4:	687a      	ldr	r2, [r7, #4]
 8025ee6:	68fb      	ldr	r3, [r7, #12]
 8025ee8:	3302      	adds	r3, #2
 8025eea:	009b      	lsls	r3, r3, #2
 8025eec:	4413      	add	r3, r2
 8025eee:	685a      	ldr	r2, [r3, #4]
 8025ef0:	6839      	ldr	r1, [r7, #0]
 8025ef2:	68fb      	ldr	r3, [r7, #12]
 8025ef4:	3302      	adds	r3, #2
 8025ef6:	009b      	lsls	r3, r3, #2
 8025ef8:	440b      	add	r3, r1
 8025efa:	685b      	ldr	r3, [r3, #4]
 8025efc:	429a      	cmp	r2, r3
 8025efe:	d202      	bcs.n	8025f06 <fp_cmp_mag+0x78>
             return FP_LT;
 8025f00:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025f04:	e006      	b.n	8025f14 <fp_cmp_mag+0x86>
      for (x = a->used - 1; x >= 0; x--) {
 8025f06:	68fb      	ldr	r3, [r7, #12]
 8025f08:	3b01      	subs	r3, #1
 8025f0a:	60fb      	str	r3, [r7, #12]
 8025f0c:	68fb      	ldr	r3, [r7, #12]
 8025f0e:	2b00      	cmp	r3, #0
 8025f10:	dad8      	bge.n	8025ec4 <fp_cmp_mag+0x36>
          }
      }
   }
   return FP_EQ;
 8025f12:	2300      	movs	r3, #0
}
 8025f14:	4618      	mov	r0, r3
 8025f16:	3714      	adds	r7, #20
 8025f18:	46bd      	mov	sp, r7
 8025f1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025f1e:	4770      	bx	lr

08025f20 <fp_montgomery_setup>:


/* sets up the montgomery reduction */
int fp_montgomery_setup(fp_int *a, fp_digit *rho)
{
 8025f20:	b480      	push	{r7}
 8025f22:	b085      	sub	sp, #20
 8025f24:	af00      	add	r7, sp, #0
 8025f26:	6078      	str	r0, [r7, #4]
 8025f28:	6039      	str	r1, [r7, #0]
 *
 * XA = 1 (mod 2**n)  =>  (X(2-XA)) A = 1 (mod 2**2n)
 *                    =>  2*X*A - X*X*A*A = 1
 *                    =>  2*(1) - (1)     = 1
 */
  b = a->dp[0];
 8025f2a:	687b      	ldr	r3, [r7, #4]
 8025f2c:	68db      	ldr	r3, [r3, #12]
 8025f2e:	60fb      	str	r3, [r7, #12]

  if ((b & 1) == 0) {
 8025f30:	68fb      	ldr	r3, [r7, #12]
 8025f32:	f003 0301 	and.w	r3, r3, #1
 8025f36:	2b00      	cmp	r3, #0
 8025f38:	d102      	bne.n	8025f40 <fp_montgomery_setup+0x20>
    return FP_VAL;
 8025f3a:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025f3e:	e02a      	b.n	8025f96 <fp_montgomery_setup+0x76>
  }

  x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
 8025f40:	68fb      	ldr	r3, [r7, #12]
 8025f42:	3302      	adds	r3, #2
 8025f44:	005b      	lsls	r3, r3, #1
 8025f46:	f003 0308 	and.w	r3, r3, #8
 8025f4a:	68fa      	ldr	r2, [r7, #12]
 8025f4c:	4413      	add	r3, r2
 8025f4e:	60bb      	str	r3, [r7, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
 8025f50:	68fb      	ldr	r3, [r7, #12]
 8025f52:	68ba      	ldr	r2, [r7, #8]
 8025f54:	fb02 f303 	mul.w	r3, r2, r3
 8025f58:	f1c3 0202 	rsb	r2, r3, #2
 8025f5c:	68bb      	ldr	r3, [r7, #8]
 8025f5e:	fb02 f303 	mul.w	r3, r2, r3
 8025f62:	60bb      	str	r3, [r7, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
 8025f64:	68fb      	ldr	r3, [r7, #12]
 8025f66:	68ba      	ldr	r2, [r7, #8]
 8025f68:	fb02 f303 	mul.w	r3, r2, r3
 8025f6c:	f1c3 0202 	rsb	r2, r3, #2
 8025f70:	68bb      	ldr	r3, [r7, #8]
 8025f72:	fb02 f303 	mul.w	r3, r2, r3
 8025f76:	60bb      	str	r3, [r7, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
 8025f78:	68fb      	ldr	r3, [r7, #12]
 8025f7a:	68ba      	ldr	r2, [r7, #8]
 8025f7c:	fb02 f303 	mul.w	r3, r2, r3
 8025f80:	f1c3 0202 	rsb	r2, r3, #2
 8025f84:	68bb      	ldr	r3, [r7, #8]
 8025f86:	fb02 f303 	mul.w	r3, r2, r3
 8025f8a:	60bb      	str	r3, [r7, #8]
#ifdef FP_64BIT
  x *= 2 - b * x;               /* here x*a==1 mod 2**64 */
#endif

  /* rho = -1/m mod b */
  *rho = (fp_digit) (((fp_word) 1 << ((fp_word) DIGIT_BIT)) - ((fp_word)x));
 8025f8c:	68bb      	ldr	r3, [r7, #8]
 8025f8e:	425a      	negs	r2, r3
 8025f90:	683b      	ldr	r3, [r7, #0]
 8025f92:	601a      	str	r2, [r3, #0]

  return FP_OKAY;
 8025f94:	2300      	movs	r3, #0
}
 8025f96:	4618      	mov	r0, r3
 8025f98:	3714      	adds	r7, #20
 8025f9a:	46bd      	mov	sp, r7
 8025f9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025fa0:	4770      	bx	lr

08025fa2 <fp_montgomery_calc_normalization>:

/* computes a = B**n mod b without division or multiplication useful for
 * normalizing numbers in a Montgomery system.
 */
int fp_montgomery_calc_normalization(fp_int *a, fp_int *b)
{
 8025fa2:	b580      	push	{r7, lr}
 8025fa4:	b086      	sub	sp, #24
 8025fa6:	af00      	add	r7, sp, #0
 8025fa8:	6078      	str	r0, [r7, #4]
 8025faa:	6039      	str	r1, [r7, #0]
  int     x, bits;

  /* how many bits of last digit does b use */
  bits = fp_count_bits (b) % DIGIT_BIT;
 8025fac:	6838      	ldr	r0, [r7, #0]
 8025fae:	f000 fb37 	bl	8026620 <fp_count_bits>
 8025fb2:	4603      	mov	r3, r0
 8025fb4:	425a      	negs	r2, r3
 8025fb6:	f003 031f 	and.w	r3, r3, #31
 8025fba:	f002 021f 	and.w	r2, r2, #31
 8025fbe:	bf58      	it	pl
 8025fc0:	4253      	negpl	r3, r2
 8025fc2:	613b      	str	r3, [r7, #16]
  if (!bits) bits = DIGIT_BIT;
 8025fc4:	693b      	ldr	r3, [r7, #16]
 8025fc6:	2b00      	cmp	r3, #0
 8025fc8:	d101      	bne.n	8025fce <fp_montgomery_calc_normalization+0x2c>
 8025fca:	2320      	movs	r3, #32
 8025fcc:	613b      	str	r3, [r7, #16]

  /* compute A = B^(n-1) * 2^(bits-1) */
  if (b->used > 1) {
 8025fce:	683b      	ldr	r3, [r7, #0]
 8025fd0:	681b      	ldr	r3, [r3, #0]
 8025fd2:	2b01      	cmp	r3, #1
 8025fd4:	dd0b      	ble.n	8025fee <fp_montgomery_calc_normalization+0x4c>
     fp_2expt (a, (b->used - 1) * DIGIT_BIT + bits - 1);
 8025fd6:	683b      	ldr	r3, [r7, #0]
 8025fd8:	681b      	ldr	r3, [r3, #0]
 8025fda:	3b01      	subs	r3, #1
 8025fdc:	015a      	lsls	r2, r3, #5
 8025fde:	693b      	ldr	r3, [r7, #16]
 8025fe0:	4413      	add	r3, r2
 8025fe2:	3b01      	subs	r3, #1
 8025fe4:	4619      	mov	r1, r3
 8025fe6:	6878      	ldr	r0, [r7, #4]
 8025fe8:	f7ff fc7b 	bl	80258e2 <fp_2expt>
 8025fec:	e005      	b.n	8025ffa <fp_montgomery_calc_normalization+0x58>
  } else {
     fp_set(a, 1);
 8025fee:	2101      	movs	r1, #1
 8025ff0:	6878      	ldr	r0, [r7, #4]
 8025ff2:	f000 fad2 	bl	802659a <fp_set>
     bits = 1;
 8025ff6:	2301      	movs	r3, #1
 8025ff8:	613b      	str	r3, [r7, #16]
  }

  /* now compute C = A * B mod b */
  for (x = bits - 1; x < (int)DIGIT_BIT; x++) {
 8025ffa:	693b      	ldr	r3, [r7, #16]
 8025ffc:	3b01      	subs	r3, #1
 8025ffe:	617b      	str	r3, [r7, #20]
 8026000:	e019      	b.n	8026036 <fp_montgomery_calc_normalization+0x94>
    int err = fp_mul_2 (a, a);
 8026002:	6879      	ldr	r1, [r7, #4]
 8026004:	6878      	ldr	r0, [r7, #4]
 8026006:	f7fc fd32 	bl	8022a6e <fp_mul_2>
 802600a:	60f8      	str	r0, [r7, #12]
    if (err != FP_OKAY) {
 802600c:	68fb      	ldr	r3, [r7, #12]
 802600e:	2b00      	cmp	r3, #0
 8026010:	d001      	beq.n	8026016 <fp_montgomery_calc_normalization+0x74>
      return err;
 8026012:	68fb      	ldr	r3, [r7, #12]
 8026014:	e013      	b.n	802603e <fp_montgomery_calc_normalization+0x9c>
    }
    if (fp_cmp_mag (a, b) != FP_LT) {
 8026016:	6839      	ldr	r1, [r7, #0]
 8026018:	6878      	ldr	r0, [r7, #4]
 802601a:	f7ff ff38 	bl	8025e8e <fp_cmp_mag>
 802601e:	4603      	mov	r3, r0
 8026020:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8026024:	d004      	beq.n	8026030 <fp_montgomery_calc_normalization+0x8e>
      s_fp_sub (a, b, a);
 8026026:	687a      	ldr	r2, [r7, #4]
 8026028:	6839      	ldr	r1, [r7, #0]
 802602a:	6878      	ldr	r0, [r7, #4]
 802602c:	f7fc fc17 	bl	802285e <s_fp_sub>
  for (x = bits - 1; x < (int)DIGIT_BIT; x++) {
 8026030:	697b      	ldr	r3, [r7, #20]
 8026032:	3301      	adds	r3, #1
 8026034:	617b      	str	r3, [r7, #20]
 8026036:	697b      	ldr	r3, [r7, #20]
 8026038:	2b1f      	cmp	r3, #31
 802603a:	dde2      	ble.n	8026002 <fp_montgomery_calc_normalization+0x60>
    }
  }
  return FP_OKAY;
 802603c:	2300      	movs	r3, #0
}
 802603e:	4618      	mov	r0, r3
 8026040:	3718      	adds	r7, #24
 8026042:	46bd      	mov	sp, r7
 8026044:	bd80      	pop	{r7, pc}

08026046 <fp_montgomery_reduce_ex>:
}
#endif

/* computes x/R == x (mod N) via Montgomery Reduction */
int fp_montgomery_reduce_ex(fp_int *a, fp_int *m, fp_digit mp, int ct)
{
 8026046:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 802604a:	b09a      	sub	sp, #104	@ 0x68
 802604c:	af00      	add	r7, sp, #0
 802604e:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8026050:	62b9      	str	r1, [r7, #40]	@ 0x28
 8026052:	627a      	str	r2, [r7, #36]	@ 0x24
 8026054:	623b      	str	r3, [r7, #32]
#ifndef WOLFSSL_SMALL_STACK
   fp_digit c[FP_SIZE+1];
#else
   fp_digit *c;
#endif
   fp_digit *_c, *tmpm, mu = 0;
 8026056:	2300      	movs	r3, #0
 8026058:	64fb      	str	r3, [r7, #76]	@ 0x4c
   int      oldused, x, y, pa, err = 0;
 802605a:	2300      	movs	r3, #0
 802605c:	64bb      	str	r3, [r7, #72]	@ 0x48

   IF_HAVE_INTEL_MULX(err=fp_montgomery_reduce_mulx(a, m, mp, ct), return err) ;
   (void)err;

   /* bail if too large */
   if (m->used > (FP_SIZE/2)) {
 802605e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8026060:	681b      	ldr	r3, [r3, #0]
 8026062:	2b44      	cmp	r3, #68	@ 0x44
 8026064:	dd02      	ble.n	802606c <fp_montgomery_reduce_ex+0x26>
      (void)mu;                     /* shut up compiler */
      return FP_VAL;
 8026066:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802606a:	e11b      	b.n	80262a4 <fp_montgomery_reduce_ex+0x25e>
   }
#endif

#ifdef WOLFSSL_SMALL_STACK
   /* only allocate space for what's needed for window plus res */
   c = (fp_digit*)XMALLOC(sizeof(fp_digit)*(FP_SIZE + 1), NULL, DYNAMIC_TYPE_BIGINT);
 802606c:	f44f 7009 	mov.w	r0, #548	@ 0x224
 8026070:	f7f8 fe04 	bl	801ec7c <wolfSSL_Malloc>
 8026074:	6478      	str	r0, [r7, #68]	@ 0x44
   if (c == NULL) {
 8026076:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8026078:	2b00      	cmp	r3, #0
 802607a:	d102      	bne.n	8026082 <fp_montgomery_reduce_ex+0x3c>
      return FP_MEM;
 802607c:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8026080:	e110      	b.n	80262a4 <fp_montgomery_reduce_ex+0x25e>
   }
#endif

   /* now zero the buff */
   XMEMSET(c, 0, sizeof(fp_digit)*(FP_SIZE + 1));
 8026082:	f44f 7209 	mov.w	r2, #548	@ 0x224
 8026086:	2100      	movs	r1, #0
 8026088:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 802608a:	f002 fdcb 	bl	8028c24 <memset>
   pa = m->used;
 802608e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8026090:	681b      	ldr	r3, [r3, #0]
 8026092:	643b      	str	r3, [r7, #64]	@ 0x40

   /* copy the input */
#ifdef TFM_TIMING_RESISTANT
   if (a->used <= m->used) {
 8026094:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8026096:	681a      	ldr	r2, [r3, #0]
 8026098:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802609a:	681b      	ldr	r3, [r3, #0]
 802609c:	429a      	cmp	r2, r3
 802609e:	dc03      	bgt.n	80260a8 <fp_montgomery_reduce_ex+0x62>
      oldused = m->used;
 80260a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80260a2:	681b      	ldr	r3, [r3, #0]
 80260a4:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80260a6:	e003      	b.n	80260b0 <fp_montgomery_reduce_ex+0x6a>
   }
   else {
      oldused = m->used * 2;
 80260a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80260aa:	681b      	ldr	r3, [r3, #0]
 80260ac:	005b      	lsls	r3, r3, #1
 80260ae:	65fb      	str	r3, [r7, #92]	@ 0x5c
   }
#else
   oldused = a->used;
#endif
   for (x = 0; x < oldused; x++) {
 80260b0:	2300      	movs	r3, #0
 80260b2:	65bb      	str	r3, [r7, #88]	@ 0x58
 80260b4:	e00d      	b.n	80260d2 <fp_montgomery_reduce_ex+0x8c>
       c[x] = a->dp[x];
 80260b6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80260b8:	009a      	lsls	r2, r3, #2
 80260ba:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80260bc:	1899      	adds	r1, r3, r2
 80260be:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80260c0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80260c2:	3302      	adds	r3, #2
 80260c4:	009b      	lsls	r3, r3, #2
 80260c6:	4413      	add	r3, r2
 80260c8:	685b      	ldr	r3, [r3, #4]
 80260ca:	600b      	str	r3, [r1, #0]
   for (x = 0; x < oldused; x++) {
 80260cc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80260ce:	3301      	adds	r3, #1
 80260d0:	65bb      	str	r3, [r7, #88]	@ 0x58
 80260d2:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80260d4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80260d6:	429a      	cmp	r2, r3
 80260d8:	dbed      	blt.n	80260b6 <fp_montgomery_reduce_ex+0x70>
   }
   MONT_START;

   for (x = 0; x < pa; x++) {
 80260da:	2300      	movs	r3, #0
 80260dc:	65bb      	str	r3, [r7, #88]	@ 0x58
 80260de:	e07d      	b.n	80261dc <fp_montgomery_reduce_ex+0x196>
       fp_digit cy = 0;
 80260e0:	2300      	movs	r3, #0
 80260e2:	653b      	str	r3, [r7, #80]	@ 0x50
       /* get Mu for this round */
       LOOP_START;
 80260e4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80260e6:	009a      	lsls	r2, r3, #2
 80260e8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80260ea:	4413      	add	r3, r2
 80260ec:	681a      	ldr	r2, [r3, #0]
 80260ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80260f0:	fb02 f303 	mul.w	r3, r2, r3
 80260f4:	64fb      	str	r3, [r7, #76]	@ 0x4c
       _c   = c + x;
 80260f6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80260f8:	009a      	lsls	r2, r3, #2
 80260fa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80260fc:	4413      	add	r3, r2
 80260fe:	667b      	str	r3, [r7, #100]	@ 0x64
       tmpm = m->dp;
 8026100:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8026102:	330c      	adds	r3, #12
 8026104:	663b      	str	r3, [r7, #96]	@ 0x60
       y = 0;
 8026106:	2300      	movs	r3, #0
 8026108:	657b      	str	r3, [r7, #84]	@ 0x54
              INNERMUL8 ;
              _c   += 8;
              tmpm += 8;
           }
#endif
       for (; y < pa; y++) {
 802610a:	e048      	b.n	802619e <fp_montgomery_reduce_ex+0x158>
          INNERMUL;
 802610c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802610e:	681b      	ldr	r3, [r3, #0]
 8026110:	2200      	movs	r2, #0
 8026112:	61bb      	str	r3, [r7, #24]
 8026114:	61fa      	str	r2, [r7, #28]
 8026116:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8026118:	2200      	movs	r2, #0
 802611a:	613b      	str	r3, [r7, #16]
 802611c:	617a      	str	r2, [r7, #20]
 802611e:	69bb      	ldr	r3, [r7, #24]
 8026120:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8026124:	4602      	mov	r2, r0
 8026126:	eb13 0802 	adds.w	r8, r3, r2
 802612a:	69fb      	ldr	r3, [r7, #28]
 802612c:	460a      	mov	r2, r1
 802612e:	eb43 0902 	adc.w	r9, r3, r2
 8026132:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8026134:	2200      	movs	r2, #0
 8026136:	469a      	mov	sl, r3
 8026138:	4693      	mov	fp, r2
 802613a:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 802613c:	1d13      	adds	r3, r2, #4
 802613e:	663b      	str	r3, [r7, #96]	@ 0x60
 8026140:	6813      	ldr	r3, [r2, #0]
 8026142:	2200      	movs	r2, #0
 8026144:	60bb      	str	r3, [r7, #8]
 8026146:	60fa      	str	r2, [r7, #12]
 8026148:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 802614c:	4603      	mov	r3, r0
 802614e:	fb03 f20b 	mul.w	r2, r3, fp
 8026152:	460b      	mov	r3, r1
 8026154:	fb0a f303 	mul.w	r3, sl, r3
 8026158:	4413      	add	r3, r2
 802615a:	4602      	mov	r2, r0
 802615c:	fbaa 4502 	umull	r4, r5, sl, r2
 8026160:	442b      	add	r3, r5
 8026162:	461d      	mov	r5, r3
 8026164:	eb18 0304 	adds.w	r3, r8, r4
 8026168:	603b      	str	r3, [r7, #0]
 802616a:	eb49 0305 	adc.w	r3, r9, r5
 802616e:	607b      	str	r3, [r7, #4]
 8026170:	e9d7 2300 	ldrd	r2, r3, [r7]
 8026174:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
 8026178:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802617a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802617c:	601a      	str	r2, [r3, #0]
 802617e:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8026182:	f04f 0000 	mov.w	r0, #0
 8026186:	f04f 0100 	mov.w	r1, #0
 802618a:	0018      	movs	r0, r3
 802618c:	2100      	movs	r1, #0
 802618e:	4603      	mov	r3, r0
 8026190:	653b      	str	r3, [r7, #80]	@ 0x50
          ++_c;
 8026192:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8026194:	3304      	adds	r3, #4
 8026196:	667b      	str	r3, [r7, #100]	@ 0x64
       for (; y < pa; y++) {
 8026198:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802619a:	3301      	adds	r3, #1
 802619c:	657b      	str	r3, [r7, #84]	@ 0x54
 802619e:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80261a0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80261a2:	429a      	cmp	r2, r3
 80261a4:	dbb2      	blt.n	802610c <fp_montgomery_reduce_ex+0xc6>
       }
       LOOP_END;
       while (cy) { /* //NOLINT(bugprone-infinite-loop) */ /* PROPCARRY is an asm macro */
 80261a6:	e013      	b.n	80261d0 <fp_montgomery_reduce_ex+0x18a>
           PROPCARRY;
 80261a8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80261aa:	681a      	ldr	r2, [r3, #0]
 80261ac:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80261ae:	441a      	add	r2, r3
 80261b0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80261b2:	601a      	str	r2, [r3, #0]
 80261b4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80261b6:	681b      	ldr	r3, [r3, #0]
 80261b8:	63bb      	str	r3, [r7, #56]	@ 0x38
 80261ba:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80261bc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80261be:	429a      	cmp	r2, r3
 80261c0:	bf34      	ite	cc
 80261c2:	2301      	movcc	r3, #1
 80261c4:	2300      	movcs	r3, #0
 80261c6:	b2db      	uxtb	r3, r3
 80261c8:	653b      	str	r3, [r7, #80]	@ 0x50
           ++_c;
 80261ca:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80261cc:	3304      	adds	r3, #4
 80261ce:	667b      	str	r3, [r7, #100]	@ 0x64
       while (cy) { /* //NOLINT(bugprone-infinite-loop) */ /* PROPCARRY is an asm macro */
 80261d0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80261d2:	2b00      	cmp	r3, #0
 80261d4:	d1e8      	bne.n	80261a8 <fp_montgomery_reduce_ex+0x162>
   for (x = 0; x < pa; x++) {
 80261d6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80261d8:	3301      	adds	r3, #1
 80261da:	65bb      	str	r3, [r7, #88]	@ 0x58
 80261dc:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80261de:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80261e0:	429a      	cmp	r2, r3
 80261e2:	f6ff af7d 	blt.w	80260e0 <fp_montgomery_reduce_ex+0x9a>
       }
  }

  /* now copy out */
  _c   = c + pa;
 80261e6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80261e8:	009b      	lsls	r3, r3, #2
 80261ea:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80261ec:	4413      	add	r3, r2
 80261ee:	667b      	str	r3, [r7, #100]	@ 0x64
  tmpm = a->dp;
 80261f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80261f2:	330c      	adds	r3, #12
 80261f4:	663b      	str	r3, [r7, #96]	@ 0x60
  for (x = 0; x < pa+1; x++) {
 80261f6:	2300      	movs	r3, #0
 80261f8:	65bb      	str	r3, [r7, #88]	@ 0x58
 80261fa:	e00a      	b.n	8026212 <fp_montgomery_reduce_ex+0x1cc>
     *tmpm++ = *_c++;
 80261fc:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80261fe:	1d13      	adds	r3, r2, #4
 8026200:	667b      	str	r3, [r7, #100]	@ 0x64
 8026202:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8026204:	1d19      	adds	r1, r3, #4
 8026206:	6639      	str	r1, [r7, #96]	@ 0x60
 8026208:	6812      	ldr	r2, [r2, #0]
 802620a:	601a      	str	r2, [r3, #0]
  for (x = 0; x < pa+1; x++) {
 802620c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802620e:	3301      	adds	r3, #1
 8026210:	65bb      	str	r3, [r7, #88]	@ 0x58
 8026212:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8026214:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8026216:	429a      	cmp	r2, r3
 8026218:	daf0      	bge.n	80261fc <fp_montgomery_reduce_ex+0x1b6>
  }

  /* zero any excess digits on the destination that we didn't write to */
  for (; x < oldused; x++) {
 802621a:	e007      	b.n	802622c <fp_montgomery_reduce_ex+0x1e6>
     *tmpm++ = 0;
 802621c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802621e:	1d1a      	adds	r2, r3, #4
 8026220:	663a      	str	r2, [r7, #96]	@ 0x60
 8026222:	2200      	movs	r2, #0
 8026224:	601a      	str	r2, [r3, #0]
  for (; x < oldused; x++) {
 8026226:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8026228:	3301      	adds	r3, #1
 802622a:	65bb      	str	r3, [r7, #88]	@ 0x58
 802622c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 802622e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8026230:	429a      	cmp	r2, r3
 8026232:	dbf3      	blt.n	802621c <fp_montgomery_reduce_ex+0x1d6>
  }

  MONT_FINI;

  a->used = pa+1;
 8026234:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8026236:	1c5a      	adds	r2, r3, #1
 8026238:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802623a:	601a      	str	r2, [r3, #0]
  fp_clamp(a);
 802623c:	e004      	b.n	8026248 <fp_montgomery_reduce_ex+0x202>
 802623e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8026240:	681b      	ldr	r3, [r3, #0]
 8026242:	1e5a      	subs	r2, r3, #1
 8026244:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8026246:	601a      	str	r2, [r3, #0]
 8026248:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802624a:	681b      	ldr	r3, [r3, #0]
 802624c:	2b00      	cmp	r3, #0
 802624e:	d009      	beq.n	8026264 <fp_montgomery_reduce_ex+0x21e>
 8026250:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8026252:	681b      	ldr	r3, [r3, #0]
 8026254:	3b01      	subs	r3, #1
 8026256:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8026258:	3302      	adds	r3, #2
 802625a:	009b      	lsls	r3, r3, #2
 802625c:	4413      	add	r3, r2
 802625e:	685b      	ldr	r3, [r3, #4]
 8026260:	2b00      	cmp	r3, #0
 8026262:	d0ec      	beq.n	802623e <fp_montgomery_reduce_ex+0x1f8>
 8026264:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8026266:	681b      	ldr	r3, [r3, #0]
 8026268:	2b00      	cmp	r3, #0
 802626a:	d002      	beq.n	8026272 <fp_montgomery_reduce_ex+0x22c>
 802626c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802626e:	685b      	ldr	r3, [r3, #4]
 8026270:	e000      	b.n	8026274 <fp_montgomery_reduce_ex+0x22e>
 8026272:	2300      	movs	r3, #0
 8026274:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8026276:	6053      	str	r3, [r2, #4]

#ifndef WOLFSSL_MONT_RED_CT
  /* if A >= m then A = A - m */
  if (fp_cmp_mag (a, m) != FP_LT) {
 8026278:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 802627a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 802627c:	f7ff fe07 	bl	8025e8e <fp_cmp_mag>
 8026280:	4603      	mov	r3, r0
 8026282:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8026286:	d004      	beq.n	8026292 <fp_montgomery_reduce_ex+0x24c>
    s_fp_sub (a, m, a);
 8026288:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802628a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 802628c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 802628e:	f7fc fae6 	bl	802285e <s_fp_sub>
    s_fp_sub (a, m, a);
  }
#endif

#ifdef WOLFSSL_SMALL_STACK
  XFREE(c, NULL, DYNAMIC_TYPE_BIGINT);
 8026292:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8026294:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8026296:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8026298:	2b00      	cmp	r3, #0
 802629a:	d002      	beq.n	80262a2 <fp_montgomery_reduce_ex+0x25c>
 802629c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 802629e:	f7f8 fd09 	bl	801ecb4 <wolfSSL_Free>
#endif
  return FP_OKAY;
 80262a2:	2300      	movs	r3, #0
}
 80262a4:	4618      	mov	r0, r3
 80262a6:	3768      	adds	r7, #104	@ 0x68
 80262a8:	46bd      	mov	sp, r7
 80262aa:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080262ae <fp_montgomery_reduce>:

int fp_montgomery_reduce(fp_int *a, fp_int *m, fp_digit mp)
{
 80262ae:	b580      	push	{r7, lr}
 80262b0:	b084      	sub	sp, #16
 80262b2:	af00      	add	r7, sp, #0
 80262b4:	60f8      	str	r0, [r7, #12]
 80262b6:	60b9      	str	r1, [r7, #8]
 80262b8:	607a      	str	r2, [r7, #4]
  return fp_montgomery_reduce_ex(a, m, mp, 1);
 80262ba:	2301      	movs	r3, #1
 80262bc:	687a      	ldr	r2, [r7, #4]
 80262be:	68b9      	ldr	r1, [r7, #8]
 80262c0:	68f8      	ldr	r0, [r7, #12]
 80262c2:	f7ff fec0 	bl	8026046 <fp_montgomery_reduce_ex>
 80262c6:	4603      	mov	r3, r0
}
 80262c8:	4618      	mov	r0, r3
 80262ca:	3710      	adds	r7, #16
 80262cc:	46bd      	mov	sp, r7
 80262ce:	bd80      	pop	{r7, pc}

080262d0 <fp_read_unsigned_bin>:

int fp_read_unsigned_bin(fp_int *a, const unsigned char *b, int c)
{
 80262d0:	b580      	push	{r7, lr}
 80262d2:	b088      	sub	sp, #32
 80262d4:	af00      	add	r7, sp, #0
 80262d6:	60f8      	str	r0, [r7, #12]
 80262d8:	60b9      	str	r1, [r7, #8]
 80262da:	607a      	str	r2, [r7, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
  const word32 maxC = (a->size * sizeof(fp_digit));
 80262dc:	68fb      	ldr	r3, [r7, #12]
 80262de:	689b      	ldr	r3, [r3, #8]
 80262e0:	009b      	lsls	r3, r3, #2
 80262e2:	61fb      	str	r3, [r7, #28]
#else
  const word32 maxC = (FP_SIZE * sizeof(fp_digit));
#endif

  /* zero the int */
  fp_zero (a);
 80262e4:	68f8      	ldr	r0, [r7, #12]
 80262e6:	f000 fb95 	bl	8026a14 <fp_zero>

  if (c < 0) {
 80262ea:	687b      	ldr	r3, [r7, #4]
 80262ec:	2b00      	cmp	r3, #0
 80262ee:	da02      	bge.n	80262f6 <fp_read_unsigned_bin+0x26>
      return FP_VAL;
 80262f0:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80262f4:	e04e      	b.n	8026394 <fp_read_unsigned_bin+0xc4>
  }

  if (c == 0) {
 80262f6:	687b      	ldr	r3, [r7, #4]
 80262f8:	2b00      	cmp	r3, #0
 80262fa:	d101      	bne.n	8026300 <fp_read_unsigned_bin+0x30>
      return FP_OKAY;
 80262fc:	2300      	movs	r3, #0
 80262fe:	e049      	b.n	8026394 <fp_read_unsigned_bin+0xc4>
  }

  /* if input b excess max, then truncate */
  if ((word32)c > maxC) {
 8026300:	687b      	ldr	r3, [r7, #4]
 8026302:	69fa      	ldr	r2, [r7, #28]
 8026304:	429a      	cmp	r2, r3
 8026306:	d20b      	bcs.n	8026320 <fp_read_unsigned_bin+0x50>
     int excess = (c - maxC);
 8026308:	687a      	ldr	r2, [r7, #4]
 802630a:	69fb      	ldr	r3, [r7, #28]
 802630c:	1ad3      	subs	r3, r2, r3
 802630e:	61bb      	str	r3, [r7, #24]
     c -= excess;
 8026310:	687a      	ldr	r2, [r7, #4]
 8026312:	69bb      	ldr	r3, [r7, #24]
 8026314:	1ad3      	subs	r3, r2, r3
 8026316:	607b      	str	r3, [r7, #4]
     b += excess;
 8026318:	69bb      	ldr	r3, [r7, #24]
 802631a:	68ba      	ldr	r2, [r7, #8]
 802631c:	4413      	add	r3, r2
 802631e:	60bb      	str	r3, [r7, #8]
    (defined(FP_32BIT) || defined(FP_64BIT))
#ifdef FP_32BIT
  /* If we know the endianness of this architecture, and we're using
     32-bit fp_digits, we can optimize this */
  {
     unsigned char *pd = (unsigned char *)a->dp;
 8026320:	68fb      	ldr	r3, [r7, #12]
 8026322:	330c      	adds	r3, #12
 8026324:	617b      	str	r3, [r7, #20]

     a->used = (c + sizeof(fp_digit) - 1)/sizeof(fp_digit);
 8026326:	687b      	ldr	r3, [r7, #4]
 8026328:	3303      	adds	r3, #3
 802632a:	089b      	lsrs	r3, r3, #2
 802632c:	461a      	mov	r2, r3
 802632e:	68fb      	ldr	r3, [r7, #12]
 8026330:	601a      	str	r2, [r3, #0]
                 } while ((c -= 4) > 0);
       }
     }
#else
     /* read the bytes in one at a time. */
     for (c -= 1; c >= 0; c -= 1) {
 8026332:	687b      	ldr	r3, [r7, #4]
 8026334:	3b01      	subs	r3, #1
 8026336:	607b      	str	r3, [r7, #4]
 8026338:	e00a      	b.n	8026350 <fp_read_unsigned_bin+0x80>
       pd[c] = *b++;
 802633a:	68bb      	ldr	r3, [r7, #8]
 802633c:	1c5a      	adds	r2, r3, #1
 802633e:	60ba      	str	r2, [r7, #8]
 8026340:	687a      	ldr	r2, [r7, #4]
 8026342:	6979      	ldr	r1, [r7, #20]
 8026344:	440a      	add	r2, r1
 8026346:	781b      	ldrb	r3, [r3, #0]
 8026348:	7013      	strb	r3, [r2, #0]
     for (c -= 1; c >= 0; c -= 1) {
 802634a:	687b      	ldr	r3, [r7, #4]
 802634c:	3b01      	subs	r3, #1
 802634e:	607b      	str	r3, [r7, #4]
 8026350:	687b      	ldr	r3, [r7, #4]
 8026352:	2b00      	cmp	r3, #0
 8026354:	daf1      	bge.n	802633a <fp_read_unsigned_bin+0x6a>
     if (a->used == 0) {
         a->used = 1;
     }
  }
#endif
  fp_clamp (a);
 8026356:	e004      	b.n	8026362 <fp_read_unsigned_bin+0x92>
 8026358:	68fb      	ldr	r3, [r7, #12]
 802635a:	681b      	ldr	r3, [r3, #0]
 802635c:	1e5a      	subs	r2, r3, #1
 802635e:	68fb      	ldr	r3, [r7, #12]
 8026360:	601a      	str	r2, [r3, #0]
 8026362:	68fb      	ldr	r3, [r7, #12]
 8026364:	681b      	ldr	r3, [r3, #0]
 8026366:	2b00      	cmp	r3, #0
 8026368:	d009      	beq.n	802637e <fp_read_unsigned_bin+0xae>
 802636a:	68fb      	ldr	r3, [r7, #12]
 802636c:	681b      	ldr	r3, [r3, #0]
 802636e:	3b01      	subs	r3, #1
 8026370:	68fa      	ldr	r2, [r7, #12]
 8026372:	3302      	adds	r3, #2
 8026374:	009b      	lsls	r3, r3, #2
 8026376:	4413      	add	r3, r2
 8026378:	685b      	ldr	r3, [r3, #4]
 802637a:	2b00      	cmp	r3, #0
 802637c:	d0ec      	beq.n	8026358 <fp_read_unsigned_bin+0x88>
 802637e:	68fb      	ldr	r3, [r7, #12]
 8026380:	681b      	ldr	r3, [r3, #0]
 8026382:	2b00      	cmp	r3, #0
 8026384:	d002      	beq.n	802638c <fp_read_unsigned_bin+0xbc>
 8026386:	68fb      	ldr	r3, [r7, #12]
 8026388:	685b      	ldr	r3, [r3, #4]
 802638a:	e000      	b.n	802638e <fp_read_unsigned_bin+0xbe>
 802638c:	2300      	movs	r3, #0
 802638e:	68fa      	ldr	r2, [r7, #12]
 8026390:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 8026392:	2300      	movs	r3, #0
}
 8026394:	4618      	mov	r0, r3
 8026396:	3720      	adds	r7, #32
 8026398:	46bd      	mov	sp, r7
 802639a:	bd80      	pop	{r7, pc}

0802639c <fp_to_unsigned_bin_at_pos>:

int fp_to_unsigned_bin_at_pos(int x, fp_int *t, unsigned char *b)
{
 802639c:	b480      	push	{r7}
 802639e:	b089      	sub	sp, #36	@ 0x24
 80263a0:	af00      	add	r7, sp, #0
 80263a2:	60f8      	str	r0, [r7, #12]
 80263a4:	60b9      	str	r1, [r7, #8]
 80263a6:	607a      	str	r2, [r7, #4]
#if DIGIT_BIT == 64 || DIGIT_BIT == 32
   int i;
   int j = 0;
 80263a8:	2300      	movs	r3, #0
 80263aa:	61bb      	str	r3, [r7, #24]
   fp_digit n;

   for (i = 0; i < t->used-1; ) {
 80263ac:	2300      	movs	r3, #0
 80263ae:	61fb      	str	r3, [r7, #28]
 80263b0:	e021      	b.n	80263f6 <fp_to_unsigned_bin_at_pos+0x5a>
       b[x++] = (unsigned char)(t->dp[i] >> j);
 80263b2:	68ba      	ldr	r2, [r7, #8]
 80263b4:	69fb      	ldr	r3, [r7, #28]
 80263b6:	3302      	adds	r3, #2
 80263b8:	009b      	lsls	r3, r3, #2
 80263ba:	4413      	add	r3, r2
 80263bc:	685a      	ldr	r2, [r3, #4]
 80263be:	69bb      	ldr	r3, [r7, #24]
 80263c0:	fa22 f103 	lsr.w	r1, r2, r3
 80263c4:	68fb      	ldr	r3, [r7, #12]
 80263c6:	1c5a      	adds	r2, r3, #1
 80263c8:	60fa      	str	r2, [r7, #12]
 80263ca:	461a      	mov	r2, r3
 80263cc:	687b      	ldr	r3, [r7, #4]
 80263ce:	4413      	add	r3, r2
 80263d0:	b2ca      	uxtb	r2, r1
 80263d2:	701a      	strb	r2, [r3, #0]
       j += 8;
 80263d4:	69bb      	ldr	r3, [r7, #24]
 80263d6:	3308      	adds	r3, #8
 80263d8:	61bb      	str	r3, [r7, #24]
       i += j == DIGIT_BIT;
 80263da:	69bb      	ldr	r3, [r7, #24]
 80263dc:	2b20      	cmp	r3, #32
 80263de:	bf0c      	ite	eq
 80263e0:	2301      	moveq	r3, #1
 80263e2:	2300      	movne	r3, #0
 80263e4:	b2db      	uxtb	r3, r3
 80263e6:	461a      	mov	r2, r3
 80263e8:	69fb      	ldr	r3, [r7, #28]
 80263ea:	4413      	add	r3, r2
 80263ec:	61fb      	str	r3, [r7, #28]
       j &= DIGIT_BIT - 1;
 80263ee:	69bb      	ldr	r3, [r7, #24]
 80263f0:	f003 031f 	and.w	r3, r3, #31
 80263f4:	61bb      	str	r3, [r7, #24]
   for (i = 0; i < t->used-1; ) {
 80263f6:	68bb      	ldr	r3, [r7, #8]
 80263f8:	681b      	ldr	r3, [r3, #0]
 80263fa:	3b01      	subs	r3, #1
 80263fc:	69fa      	ldr	r2, [r7, #28]
 80263fe:	429a      	cmp	r2, r3
 8026400:	dbd7      	blt.n	80263b2 <fp_to_unsigned_bin_at_pos+0x16>
   }
   n = t->dp[i];
 8026402:	68ba      	ldr	r2, [r7, #8]
 8026404:	69fb      	ldr	r3, [r7, #28]
 8026406:	3302      	adds	r3, #2
 8026408:	009b      	lsls	r3, r3, #2
 802640a:	4413      	add	r3, r2
 802640c:	685b      	ldr	r3, [r3, #4]
 802640e:	617b      	str	r3, [r7, #20]
   while (n != 0) {
 8026410:	e00b      	b.n	802642a <fp_to_unsigned_bin_at_pos+0x8e>
       b[x++] = (unsigned char)n;
 8026412:	68fb      	ldr	r3, [r7, #12]
 8026414:	1c5a      	adds	r2, r3, #1
 8026416:	60fa      	str	r2, [r7, #12]
 8026418:	461a      	mov	r2, r3
 802641a:	687b      	ldr	r3, [r7, #4]
 802641c:	4413      	add	r3, r2
 802641e:	697a      	ldr	r2, [r7, #20]
 8026420:	b2d2      	uxtb	r2, r2
 8026422:	701a      	strb	r2, [r3, #0]
       n >>= 8;
 8026424:	697b      	ldr	r3, [r7, #20]
 8026426:	0a1b      	lsrs	r3, r3, #8
 8026428:	617b      	str	r3, [r7, #20]
   while (n != 0) {
 802642a:	697b      	ldr	r3, [r7, #20]
 802642c:	2b00      	cmp	r3, #0
 802642e:	d1f0      	bne.n	8026412 <fp_to_unsigned_bin_at_pos+0x76>
   }
   return x;
 8026430:	68fb      	ldr	r3, [r7, #12]
      b[x++] = (unsigned char) (t->dp[0] & 255);
      fp_div_2d (t, 8, t, NULL);
  }
  return x;
#endif
}
 8026432:	4618      	mov	r0, r3
 8026434:	3724      	adds	r7, #36	@ 0x24
 8026436:	46bd      	mov	sp, r7
 8026438:	f85d 7b04 	ldr.w	r7, [sp], #4
 802643c:	4770      	bx	lr

0802643e <fp_to_unsigned_bin>:

int fp_to_unsigned_bin(fp_int *a, unsigned char *b)
{
 802643e:	b580      	push	{r7, lr}
 8026440:	b086      	sub	sp, #24
 8026442:	af00      	add	r7, sp, #0
 8026444:	6078      	str	r0, [r7, #4]
 8026446:	6039      	str	r1, [r7, #0]
#else
   fp_int *t;
#endif

#ifdef WOLFSSL_SMALL_STACK
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8026448:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 802644c:	f7f8 fc16 	bl	801ec7c <wolfSSL_Malloc>
 8026450:	6178      	str	r0, [r7, #20]
   if (t == NULL)
 8026452:	697b      	ldr	r3, [r7, #20]
 8026454:	2b00      	cmp	r3, #0
 8026456:	d102      	bne.n	802645e <fp_to_unsigned_bin+0x20>
       return FP_MEM;
 8026458:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 802645c:	e016      	b.n	802648c <fp_to_unsigned_bin+0x4e>
#endif

  fp_init_copy(t, a);
 802645e:	6879      	ldr	r1, [r7, #4]
 8026460:	6978      	ldr	r0, [r7, #20]
 8026462:	f000 fcf2 	bl	8026e4a <fp_init_copy>

  x = fp_to_unsigned_bin_at_pos(0, t, b);
 8026466:	683a      	ldr	r2, [r7, #0]
 8026468:	6979      	ldr	r1, [r7, #20]
 802646a:	2000      	movs	r0, #0
 802646c:	f7ff ff96 	bl	802639c <fp_to_unsigned_bin_at_pos>
 8026470:	6138      	str	r0, [r7, #16]
  mp_reverse (b, x);
 8026472:	6939      	ldr	r1, [r7, #16]
 8026474:	6838      	ldr	r0, [r7, #0]
 8026476:	f001 f983 	bl	8027780 <mp_reverse>

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 802647a:	697b      	ldr	r3, [r7, #20]
 802647c:	60fb      	str	r3, [r7, #12]
 802647e:	68fb      	ldr	r3, [r7, #12]
 8026480:	2b00      	cmp	r3, #0
 8026482:	d002      	beq.n	802648a <fp_to_unsigned_bin+0x4c>
 8026484:	68f8      	ldr	r0, [r7, #12]
 8026486:	f7f8 fc15 	bl	801ecb4 <wolfSSL_Free>
#endif
  return FP_OKAY;
 802648a:	2300      	movs	r3, #0
}
 802648c:	4618      	mov	r0, r3
 802648e:	3718      	adds	r7, #24
 8026490:	46bd      	mov	sp, r7
 8026492:	bd80      	pop	{r7, pc}

08026494 <fp_to_unsigned_bin_len>:

int fp_to_unsigned_bin_len(fp_int *a, unsigned char *b, int c)
{
 8026494:	b480      	push	{r7}
 8026496:	b089      	sub	sp, #36	@ 0x24
 8026498:	af00      	add	r7, sp, #0
 802649a:	60f8      	str	r0, [r7, #12]
 802649c:	60b9      	str	r1, [r7, #8]
 802649e:	607a      	str	r2, [r7, #4]
#if DIGIT_BIT == 64 || DIGIT_BIT == 32 || DIGIT_BIT == 16
  int i = 0;
 80264a0:	2300      	movs	r3, #0
 80264a2:	61fb      	str	r3, [r7, #28]
  int j = 0;
 80264a4:	2300      	movs	r3, #0
 80264a6:	61bb      	str	r3, [r7, #24]
  int x;

  for (x=c-1; x >= 0 && i < a->used; x--) {
 80264a8:	687b      	ldr	r3, [r7, #4]
 80264aa:	3b01      	subs	r3, #1
 80264ac:	617b      	str	r3, [r7, #20]
 80264ae:	e021      	b.n	80264f4 <fp_to_unsigned_bin_len+0x60>
     b[x] = (unsigned char)(a->dp[i] >> j);
 80264b0:	68fa      	ldr	r2, [r7, #12]
 80264b2:	69fb      	ldr	r3, [r7, #28]
 80264b4:	3302      	adds	r3, #2
 80264b6:	009b      	lsls	r3, r3, #2
 80264b8:	4413      	add	r3, r2
 80264ba:	685a      	ldr	r2, [r3, #4]
 80264bc:	69bb      	ldr	r3, [r7, #24]
 80264be:	fa22 f103 	lsr.w	r1, r2, r3
 80264c2:	697b      	ldr	r3, [r7, #20]
 80264c4:	68ba      	ldr	r2, [r7, #8]
 80264c6:	4413      	add	r3, r2
 80264c8:	b2ca      	uxtb	r2, r1
 80264ca:	701a      	strb	r2, [r3, #0]
     j += 8;
 80264cc:	69bb      	ldr	r3, [r7, #24]
 80264ce:	3308      	adds	r3, #8
 80264d0:	61bb      	str	r3, [r7, #24]
     i += j == DIGIT_BIT;
 80264d2:	69bb      	ldr	r3, [r7, #24]
 80264d4:	2b20      	cmp	r3, #32
 80264d6:	bf0c      	ite	eq
 80264d8:	2301      	moveq	r3, #1
 80264da:	2300      	movne	r3, #0
 80264dc:	b2db      	uxtb	r3, r3
 80264de:	461a      	mov	r2, r3
 80264e0:	69fb      	ldr	r3, [r7, #28]
 80264e2:	4413      	add	r3, r2
 80264e4:	61fb      	str	r3, [r7, #28]
     j &= DIGIT_BIT - 1;
 80264e6:	69bb      	ldr	r3, [r7, #24]
 80264e8:	f003 031f 	and.w	r3, r3, #31
 80264ec:	61bb      	str	r3, [r7, #24]
  for (x=c-1; x >= 0 && i < a->used; x--) {
 80264ee:	697b      	ldr	r3, [r7, #20]
 80264f0:	3b01      	subs	r3, #1
 80264f2:	617b      	str	r3, [r7, #20]
 80264f4:	697b      	ldr	r3, [r7, #20]
 80264f6:	2b00      	cmp	r3, #0
 80264f8:	db0d      	blt.n	8026516 <fp_to_unsigned_bin_len+0x82>
 80264fa:	68fb      	ldr	r3, [r7, #12]
 80264fc:	681b      	ldr	r3, [r3, #0]
 80264fe:	69fa      	ldr	r2, [r7, #28]
 8026500:	429a      	cmp	r2, r3
 8026502:	dbd5      	blt.n	80264b0 <fp_to_unsigned_bin_len+0x1c>
  }
  for (; x >= 0; x--) {
 8026504:	e007      	b.n	8026516 <fp_to_unsigned_bin_len+0x82>
     b[x] = 0;
 8026506:	697b      	ldr	r3, [r7, #20]
 8026508:	68ba      	ldr	r2, [r7, #8]
 802650a:	4413      	add	r3, r2
 802650c:	2200      	movs	r2, #0
 802650e:	701a      	strb	r2, [r3, #0]
  for (; x >= 0; x--) {
 8026510:	697b      	ldr	r3, [r7, #20]
 8026512:	3b01      	subs	r3, #1
 8026514:	617b      	str	r3, [r7, #20]
 8026516:	697b      	ldr	r3, [r7, #20]
 8026518:	2b00      	cmp	r3, #0
 802651a:	daf4      	bge.n	8026506 <fp_to_unsigned_bin_len+0x72>
  }
  if (i < a->used - 1) {
 802651c:	68fb      	ldr	r3, [r7, #12]
 802651e:	681b      	ldr	r3, [r3, #0]
 8026520:	3b01      	subs	r3, #1
 8026522:	69fa      	ldr	r2, [r7, #28]
 8026524:	429a      	cmp	r2, r3
 8026526:	da02      	bge.n	802652e <fp_to_unsigned_bin_len+0x9a>
      return FP_VAL;
 8026528:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802652c:	e014      	b.n	8026558 <fp_to_unsigned_bin_len+0xc4>
  }
  if ((i == a->used - 1) && ((a->dp[i] >> j) != 0)) {
 802652e:	68fb      	ldr	r3, [r7, #12]
 8026530:	681b      	ldr	r3, [r3, #0]
 8026532:	3b01      	subs	r3, #1
 8026534:	69fa      	ldr	r2, [r7, #28]
 8026536:	429a      	cmp	r2, r3
 8026538:	d10d      	bne.n	8026556 <fp_to_unsigned_bin_len+0xc2>
 802653a:	68fa      	ldr	r2, [r7, #12]
 802653c:	69fb      	ldr	r3, [r7, #28]
 802653e:	3302      	adds	r3, #2
 8026540:	009b      	lsls	r3, r3, #2
 8026542:	4413      	add	r3, r2
 8026544:	685a      	ldr	r2, [r3, #4]
 8026546:	69bb      	ldr	r3, [r7, #24]
 8026548:	fa22 f303 	lsr.w	r3, r2, r3
 802654c:	2b00      	cmp	r3, #0
 802654e:	d002      	beq.n	8026556 <fp_to_unsigned_bin_len+0xc2>
      return FP_VAL;
 8026550:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8026554:	e000      	b.n	8026558 <fp_to_unsigned_bin_len+0xc4>
  }

  return FP_OKAY;
 8026556:	2300      	movs	r3, #0
  if (!fp_iszero(t)) {
      return FP_VAL;
  }
  return FP_OKAY;
#endif
}
 8026558:	4618      	mov	r0, r3
 802655a:	3724      	adds	r7, #36	@ 0x24
 802655c:	46bd      	mov	sp, r7
 802655e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026562:	4770      	bx	lr

08026564 <fp_unsigned_bin_size>:

int fp_unsigned_bin_size(const fp_int *a)
{
 8026564:	b580      	push	{r7, lr}
 8026566:	b084      	sub	sp, #16
 8026568:	af00      	add	r7, sp, #0
 802656a:	6078      	str	r0, [r7, #4]
  int     size = fp_count_bits (a);
 802656c:	6878      	ldr	r0, [r7, #4]
 802656e:	f000 f857 	bl	8026620 <fp_count_bits>
 8026572:	60f8      	str	r0, [r7, #12]
  return (size / 8 + ((size & 7) != 0 ? 1 : 0));
 8026574:	68fb      	ldr	r3, [r7, #12]
 8026576:	2b00      	cmp	r3, #0
 8026578:	da00      	bge.n	802657c <fp_unsigned_bin_size+0x18>
 802657a:	3307      	adds	r3, #7
 802657c:	10db      	asrs	r3, r3, #3
 802657e:	461a      	mov	r2, r3
 8026580:	68fb      	ldr	r3, [r7, #12]
 8026582:	f003 0307 	and.w	r3, r3, #7
 8026586:	2b00      	cmp	r3, #0
 8026588:	bf14      	ite	ne
 802658a:	2301      	movne	r3, #1
 802658c:	2300      	moveq	r3, #0
 802658e:	b2db      	uxtb	r3, r3
 8026590:	4413      	add	r3, r2
}
 8026592:	4618      	mov	r0, r3
 8026594:	3710      	adds	r7, #16
 8026596:	46bd      	mov	sp, r7
 8026598:	bd80      	pop	{r7, pc}

0802659a <fp_set>:

void fp_set(fp_int *a, fp_digit b)
{
 802659a:	b580      	push	{r7, lr}
 802659c:	b082      	sub	sp, #8
 802659e:	af00      	add	r7, sp, #0
 80265a0:	6078      	str	r0, [r7, #4]
 80265a2:	6039      	str	r1, [r7, #0]
   fp_zero(a);
 80265a4:	6878      	ldr	r0, [r7, #4]
 80265a6:	f000 fa35 	bl	8026a14 <fp_zero>
   a->dp[0] = b;
 80265aa:	687b      	ldr	r3, [r7, #4]
 80265ac:	683a      	ldr	r2, [r7, #0]
 80265ae:	60da      	str	r2, [r3, #12]
   a->used  = a->dp[0] ? 1 : 0;
 80265b0:	687b      	ldr	r3, [r7, #4]
 80265b2:	68db      	ldr	r3, [r3, #12]
 80265b4:	2b00      	cmp	r3, #0
 80265b6:	bf14      	ite	ne
 80265b8:	2301      	movne	r3, #1
 80265ba:	2300      	moveq	r3, #0
 80265bc:	b2db      	uxtb	r3, r3
 80265be:	461a      	mov	r2, r3
 80265c0:	687b      	ldr	r3, [r7, #4]
 80265c2:	601a      	str	r2, [r3, #0]
}
 80265c4:	bf00      	nop
 80265c6:	3708      	adds	r7, #8
 80265c8:	46bd      	mov	sp, r7
 80265ca:	bd80      	pop	{r7, pc}

080265cc <fp_is_bit_set>:
  return FP_OKAY;
}

/* check if a bit is set */
int fp_is_bit_set (fp_int *a, fp_digit b)
{
 80265cc:	b480      	push	{r7}
 80265ce:	b085      	sub	sp, #20
 80265d0:	af00      	add	r7, sp, #0
 80265d2:	6078      	str	r0, [r7, #4]
 80265d4:	6039      	str	r1, [r7, #0]
    fp_digit i;

    if (b > FP_MAX_BITS)
 80265d6:	683b      	ldr	r3, [r7, #0]
 80265d8:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80265dc:	d902      	bls.n	80265e4 <fp_is_bit_set+0x18>
        return FP_VAL;
 80265de:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80265e2:	e017      	b.n	8026614 <fp_is_bit_set+0x48>

    i = b/DIGIT_BIT;
 80265e4:	683b      	ldr	r3, [r7, #0]
 80265e6:	095b      	lsrs	r3, r3, #5
 80265e8:	60fb      	str	r3, [r7, #12]

    if ((fp_digit)a->used < i)
 80265ea:	687b      	ldr	r3, [r7, #4]
 80265ec:	681b      	ldr	r3, [r3, #0]
 80265ee:	461a      	mov	r2, r3
 80265f0:	68fb      	ldr	r3, [r7, #12]
 80265f2:	4293      	cmp	r3, r2
 80265f4:	d901      	bls.n	80265fa <fp_is_bit_set+0x2e>
        return 0;
 80265f6:	2300      	movs	r3, #0
 80265f8:	e00c      	b.n	8026614 <fp_is_bit_set+0x48>

    return (int)((a->dp[i] >> b%DIGIT_BIT) & (fp_digit)1);
 80265fa:	687a      	ldr	r2, [r7, #4]
 80265fc:	68fb      	ldr	r3, [r7, #12]
 80265fe:	3302      	adds	r3, #2
 8026600:	009b      	lsls	r3, r3, #2
 8026602:	4413      	add	r3, r2
 8026604:	685a      	ldr	r2, [r3, #4]
 8026606:	683b      	ldr	r3, [r7, #0]
 8026608:	f003 031f 	and.w	r3, r3, #31
 802660c:	fa22 f303 	lsr.w	r3, r2, r3
 8026610:	f003 0301 	and.w	r3, r3, #1
}
 8026614:	4618      	mov	r0, r3
 8026616:	3714      	adds	r7, #20
 8026618:	46bd      	mov	sp, r7
 802661a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802661e:	4770      	bx	lr

08026620 <fp_count_bits>:

    return MP_OKAY;
}

int fp_count_bits (const fp_int * a)
{
 8026620:	b480      	push	{r7}
 8026622:	b085      	sub	sp, #20
 8026624:	af00      	add	r7, sp, #0
 8026626:	6078      	str	r0, [r7, #4]
  int     r;
  fp_digit q;

  /* shortcut */
  if (a->used == 0) {
 8026628:	687b      	ldr	r3, [r7, #4]
 802662a:	681b      	ldr	r3, [r3, #0]
 802662c:	2b00      	cmp	r3, #0
 802662e:	d101      	bne.n	8026634 <fp_count_bits+0x14>
    return 0;
 8026630:	2300      	movs	r3, #0
 8026632:	e018      	b.n	8026666 <fp_count_bits+0x46>
  }

  /* get number of digits and add that */
  r = (a->used - 1) * DIGIT_BIT;
 8026634:	687b      	ldr	r3, [r7, #4]
 8026636:	681b      	ldr	r3, [r3, #0]
 8026638:	3b01      	subs	r3, #1
 802663a:	015b      	lsls	r3, r3, #5
 802663c:	60fb      	str	r3, [r7, #12]

  /* take the last digit and count the bits in it */
  q = a->dp[a->used - 1];
 802663e:	687b      	ldr	r3, [r7, #4]
 8026640:	681b      	ldr	r3, [r3, #0]
 8026642:	3b01      	subs	r3, #1
 8026644:	687a      	ldr	r2, [r7, #4]
 8026646:	3302      	adds	r3, #2
 8026648:	009b      	lsls	r3, r3, #2
 802664a:	4413      	add	r3, r2
 802664c:	685b      	ldr	r3, [r3, #4]
 802664e:	60bb      	str	r3, [r7, #8]
  while (q > ((fp_digit) 0)) {
 8026650:	e005      	b.n	802665e <fp_count_bits+0x3e>
    ++r;
 8026652:	68fb      	ldr	r3, [r7, #12]
 8026654:	3301      	adds	r3, #1
 8026656:	60fb      	str	r3, [r7, #12]
    q >>= ((fp_digit) 1);
 8026658:	68bb      	ldr	r3, [r7, #8]
 802665a:	085b      	lsrs	r3, r3, #1
 802665c:	60bb      	str	r3, [r7, #8]
  while (q > ((fp_digit) 0)) {
 802665e:	68bb      	ldr	r3, [r7, #8]
 8026660:	2b00      	cmp	r3, #0
 8026662:	d1f6      	bne.n	8026652 <fp_count_bits+0x32>
  }

  return r;
 8026664:	68fb      	ldr	r3, [r7, #12]
}
 8026666:	4618      	mov	r0, r3
 8026668:	3714      	adds	r7, #20
 802666a:	46bd      	mov	sp, r7
 802666c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026670:	4770      	bx	lr

08026672 <fp_leading_bit>:

int fp_leading_bit(fp_int *a)
{
 8026672:	b480      	push	{r7}
 8026674:	b087      	sub	sp, #28
 8026676:	af00      	add	r7, sp, #0
 8026678:	6078      	str	r0, [r7, #4]
    int bit = 0;
 802667a:	2300      	movs	r3, #0
 802667c:	617b      	str	r3, [r7, #20]

    if (a->used != 0) {
 802667e:	687b      	ldr	r3, [r7, #4]
 8026680:	681b      	ldr	r3, [r3, #0]
 8026682:	2b00      	cmp	r3, #0
 8026684:	d021      	beq.n	80266ca <fp_leading_bit+0x58>
        fp_digit q = a->dp[a->used - 1];
 8026686:	687b      	ldr	r3, [r7, #4]
 8026688:	681b      	ldr	r3, [r3, #0]
 802668a:	3b01      	subs	r3, #1
 802668c:	687a      	ldr	r2, [r7, #4]
 802668e:	3302      	adds	r3, #2
 8026690:	009b      	lsls	r3, r3, #2
 8026692:	4413      	add	r3, r2
 8026694:	685b      	ldr	r3, [r3, #4]
 8026696:	613b      	str	r3, [r7, #16]
        int qSz = sizeof(fp_digit);
 8026698:	2304      	movs	r3, #4
 802669a:	60fb      	str	r3, [r7, #12]

        while (qSz > 0) {
 802669c:	e012      	b.n	80266c4 <fp_leading_bit+0x52>
            if ((unsigned char)q != 0)
 802669e:	693b      	ldr	r3, [r7, #16]
 80266a0:	b2db      	uxtb	r3, r3
 80266a2:	2b00      	cmp	r3, #0
 80266a4:	d008      	beq.n	80266b8 <fp_leading_bit+0x46>
                bit = (q & 0x80) != 0;
 80266a6:	693b      	ldr	r3, [r7, #16]
 80266a8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80266ac:	2b00      	cmp	r3, #0
 80266ae:	bf14      	ite	ne
 80266b0:	2301      	movne	r3, #1
 80266b2:	2300      	moveq	r3, #0
 80266b4:	b2db      	uxtb	r3, r3
 80266b6:	617b      	str	r3, [r7, #20]
            q >>= 8;
 80266b8:	693b      	ldr	r3, [r7, #16]
 80266ba:	0a1b      	lsrs	r3, r3, #8
 80266bc:	613b      	str	r3, [r7, #16]
            qSz--;
 80266be:	68fb      	ldr	r3, [r7, #12]
 80266c0:	3b01      	subs	r3, #1
 80266c2:	60fb      	str	r3, [r7, #12]
        while (qSz > 0) {
 80266c4:	68fb      	ldr	r3, [r7, #12]
 80266c6:	2b00      	cmp	r3, #0
 80266c8:	dce9      	bgt.n	802669e <fp_leading_bit+0x2c>
        }
    }

    return bit;
 80266ca:	697b      	ldr	r3, [r7, #20]
}
 80266cc:	4618      	mov	r0, r3
 80266ce:	371c      	adds	r7, #28
 80266d0:	46bd      	mov	sp, r7
 80266d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80266d6:	4770      	bx	lr

080266d8 <fp_lshd>:

int fp_lshd(fp_int *a, int x)
{
 80266d8:	b480      	push	{r7}
 80266da:	b085      	sub	sp, #20
 80266dc:	af00      	add	r7, sp, #0
 80266de:	6078      	str	r0, [r7, #4]
 80266e0:	6039      	str	r1, [r7, #0]
    int y;

    if (a->used + x > FP_SIZE) return FP_VAL;
 80266e2:	687b      	ldr	r3, [r7, #4]
 80266e4:	681a      	ldr	r2, [r3, #0]
 80266e6:	683b      	ldr	r3, [r7, #0]
 80266e8:	4413      	add	r3, r2
 80266ea:	2b88      	cmp	r3, #136	@ 0x88
 80266ec:	dd02      	ble.n	80266f4 <fp_lshd+0x1c>
 80266ee:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80266f2:	e04c      	b.n	802678e <fp_lshd+0xb6>

    y = a->used + x - 1;
 80266f4:	687b      	ldr	r3, [r7, #4]
 80266f6:	681a      	ldr	r2, [r3, #0]
 80266f8:	683b      	ldr	r3, [r7, #0]
 80266fa:	4413      	add	r3, r2
 80266fc:	3b01      	subs	r3, #1
 80266fe:	60fb      	str	r3, [r7, #12]

    /* store new size */
    a->used = y + 1;
 8026700:	68fb      	ldr	r3, [r7, #12]
 8026702:	1c5a      	adds	r2, r3, #1
 8026704:	687b      	ldr	r3, [r7, #4]
 8026706:	601a      	str	r2, [r3, #0]

    /* move digits */
    for (; y >= x; y--) {
 8026708:	e010      	b.n	802672c <fp_lshd+0x54>
        a->dp[y] = a->dp[y-x];
 802670a:	68fa      	ldr	r2, [r7, #12]
 802670c:	683b      	ldr	r3, [r7, #0]
 802670e:	1ad3      	subs	r3, r2, r3
 8026710:	687a      	ldr	r2, [r7, #4]
 8026712:	3302      	adds	r3, #2
 8026714:	009b      	lsls	r3, r3, #2
 8026716:	4413      	add	r3, r2
 8026718:	685a      	ldr	r2, [r3, #4]
 802671a:	6879      	ldr	r1, [r7, #4]
 802671c:	68fb      	ldr	r3, [r7, #12]
 802671e:	3302      	adds	r3, #2
 8026720:	009b      	lsls	r3, r3, #2
 8026722:	440b      	add	r3, r1
 8026724:	605a      	str	r2, [r3, #4]
    for (; y >= x; y--) {
 8026726:	68fb      	ldr	r3, [r7, #12]
 8026728:	3b01      	subs	r3, #1
 802672a:	60fb      	str	r3, [r7, #12]
 802672c:	68fa      	ldr	r2, [r7, #12]
 802672e:	683b      	ldr	r3, [r7, #0]
 8026730:	429a      	cmp	r2, r3
 8026732:	daea      	bge.n	802670a <fp_lshd+0x32>
    }

    /* zero lower digits */
    for (; y >= 0; y--) {
 8026734:	e009      	b.n	802674a <fp_lshd+0x72>
        a->dp[y] = 0;
 8026736:	687a      	ldr	r2, [r7, #4]
 8026738:	68fb      	ldr	r3, [r7, #12]
 802673a:	3302      	adds	r3, #2
 802673c:	009b      	lsls	r3, r3, #2
 802673e:	4413      	add	r3, r2
 8026740:	2200      	movs	r2, #0
 8026742:	605a      	str	r2, [r3, #4]
    for (; y >= 0; y--) {
 8026744:	68fb      	ldr	r3, [r7, #12]
 8026746:	3b01      	subs	r3, #1
 8026748:	60fb      	str	r3, [r7, #12]
 802674a:	68fb      	ldr	r3, [r7, #12]
 802674c:	2b00      	cmp	r3, #0
 802674e:	daf2      	bge.n	8026736 <fp_lshd+0x5e>
    }

    /* clamp digits */
    fp_clamp(a);
 8026750:	e004      	b.n	802675c <fp_lshd+0x84>
 8026752:	687b      	ldr	r3, [r7, #4]
 8026754:	681b      	ldr	r3, [r3, #0]
 8026756:	1e5a      	subs	r2, r3, #1
 8026758:	687b      	ldr	r3, [r7, #4]
 802675a:	601a      	str	r2, [r3, #0]
 802675c:	687b      	ldr	r3, [r7, #4]
 802675e:	681b      	ldr	r3, [r3, #0]
 8026760:	2b00      	cmp	r3, #0
 8026762:	d009      	beq.n	8026778 <fp_lshd+0xa0>
 8026764:	687b      	ldr	r3, [r7, #4]
 8026766:	681b      	ldr	r3, [r3, #0]
 8026768:	3b01      	subs	r3, #1
 802676a:	687a      	ldr	r2, [r7, #4]
 802676c:	3302      	adds	r3, #2
 802676e:	009b      	lsls	r3, r3, #2
 8026770:	4413      	add	r3, r2
 8026772:	685b      	ldr	r3, [r3, #4]
 8026774:	2b00      	cmp	r3, #0
 8026776:	d0ec      	beq.n	8026752 <fp_lshd+0x7a>
 8026778:	687b      	ldr	r3, [r7, #4]
 802677a:	681b      	ldr	r3, [r3, #0]
 802677c:	2b00      	cmp	r3, #0
 802677e:	d002      	beq.n	8026786 <fp_lshd+0xae>
 8026780:	687b      	ldr	r3, [r7, #4]
 8026782:	685b      	ldr	r3, [r3, #4]
 8026784:	e000      	b.n	8026788 <fp_lshd+0xb0>
 8026786:	2300      	movs	r3, #0
 8026788:	687a      	ldr	r2, [r7, #4]
 802678a:	6053      	str	r3, [r2, #4]
    return FP_OKAY;
 802678c:	2300      	movs	r3, #0
}
 802678e:	4618      	mov	r0, r3
 8026790:	3714      	adds	r7, #20
 8026792:	46bd      	mov	sp, r7
 8026794:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026798:	4770      	bx	lr

0802679a <fp_rshb>:


/* right shift by bit count */
void fp_rshb(fp_int *c, int x)
{
 802679a:	b580      	push	{r7, lr}
 802679c:	b088      	sub	sp, #32
 802679e:	af00      	add	r7, sp, #0
 80267a0:	6078      	str	r0, [r7, #4]
 80267a2:	6039      	str	r1, [r7, #0]
    fp_digit *tmpc, mask, shift;
    fp_digit r, rr;
    fp_digit D = x;
 80267a4:	683b      	ldr	r3, [r7, #0]
 80267a6:	617b      	str	r3, [r7, #20]

    /* shifting by a negative number not supported, and shifting by
     * zero changes nothing.
     */
    if (x <= 0) return;
 80267a8:	683b      	ldr	r3, [r7, #0]
 80267aa:	2b00      	cmp	r3, #0
 80267ac:	dd71      	ble.n	8026892 <fp_rshb+0xf8>

    /* shift digits first if needed */
    if (x >= DIGIT_BIT) {
 80267ae:	683b      	ldr	r3, [r7, #0]
 80267b0:	2b1f      	cmp	r3, #31
 80267b2:	dd14      	ble.n	80267de <fp_rshb+0x44>
        fp_rshd(c, x / DIGIT_BIT);
 80267b4:	683b      	ldr	r3, [r7, #0]
 80267b6:	2b00      	cmp	r3, #0
 80267b8:	da00      	bge.n	80267bc <fp_rshb+0x22>
 80267ba:	331f      	adds	r3, #31
 80267bc:	115b      	asrs	r3, r3, #5
 80267be:	4619      	mov	r1, r3
 80267c0:	6878      	ldr	r0, [r7, #4]
 80267c2:	f000 f86e 	bl	80268a2 <fp_rshd>
        /* recalculate number of bits to shift */
        D = x % DIGIT_BIT;
 80267c6:	683b      	ldr	r3, [r7, #0]
 80267c8:	425a      	negs	r2, r3
 80267ca:	f003 031f 	and.w	r3, r3, #31
 80267ce:	f002 021f 	and.w	r2, r2, #31
 80267d2:	bf58      	it	pl
 80267d4:	4253      	negpl	r3, r2
 80267d6:	617b      	str	r3, [r7, #20]
        /* check if any more shifting needed */
        if (D == 0) return;
 80267d8:	697b      	ldr	r3, [r7, #20]
 80267da:	2b00      	cmp	r3, #0
 80267dc:	d05b      	beq.n	8026896 <fp_rshb+0xfc>

    }

    /* zero shifted is always zero */
    if (fp_iszero(c)) return;
 80267de:	687b      	ldr	r3, [r7, #4]
 80267e0:	681b      	ldr	r3, [r3, #0]
 80267e2:	2b00      	cmp	r3, #0
 80267e4:	d059      	beq.n	802689a <fp_rshb+0x100>

    /* mask */
    mask = (((fp_digit)1) << D) - 1;
 80267e6:	2201      	movs	r2, #1
 80267e8:	697b      	ldr	r3, [r7, #20]
 80267ea:	fa02 f303 	lsl.w	r3, r2, r3
 80267ee:	3b01      	subs	r3, #1
 80267f0:	613b      	str	r3, [r7, #16]

    /* shift for lsb */
    shift = DIGIT_BIT - D;
 80267f2:	697b      	ldr	r3, [r7, #20]
 80267f4:	f1c3 0320 	rsb	r3, r3, #32
 80267f8:	60fb      	str	r3, [r7, #12]

    /* alias */
    tmpc = c->dp + (c->used - 1);
 80267fa:	687b      	ldr	r3, [r7, #4]
 80267fc:	f103 020c 	add.w	r2, r3, #12
 8026800:	687b      	ldr	r3, [r7, #4]
 8026802:	681b      	ldr	r3, [r3, #0]
 8026804:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8026808:	3b01      	subs	r3, #1
 802680a:	009b      	lsls	r3, r3, #2
 802680c:	4413      	add	r3, r2
 802680e:	61fb      	str	r3, [r7, #28]

    /* carry */
    r = 0;
 8026810:	2300      	movs	r3, #0
 8026812:	61bb      	str	r3, [r7, #24]
    for (x = c->used - 1; x >= 0; x--) {
 8026814:	687b      	ldr	r3, [r7, #4]
 8026816:	681b      	ldr	r3, [r3, #0]
 8026818:	3b01      	subs	r3, #1
 802681a:	603b      	str	r3, [r7, #0]
 802681c:	e017      	b.n	802684e <fp_rshb+0xb4>
      /* get the lower  bits of this word in a temp */
      rr = *tmpc & mask;
 802681e:	69fb      	ldr	r3, [r7, #28]
 8026820:	681b      	ldr	r3, [r3, #0]
 8026822:	693a      	ldr	r2, [r7, #16]
 8026824:	4013      	ands	r3, r2
 8026826:	60bb      	str	r3, [r7, #8]

      /* shift the current word and mix in the carry bits from previous word */
      *tmpc = (*tmpc >> D) | (r << shift);
 8026828:	69fb      	ldr	r3, [r7, #28]
 802682a:	681a      	ldr	r2, [r3, #0]
 802682c:	697b      	ldr	r3, [r7, #20]
 802682e:	40da      	lsrs	r2, r3
 8026830:	69b9      	ldr	r1, [r7, #24]
 8026832:	68fb      	ldr	r3, [r7, #12]
 8026834:	fa01 f303 	lsl.w	r3, r1, r3
 8026838:	431a      	orrs	r2, r3
 802683a:	69fb      	ldr	r3, [r7, #28]
 802683c:	601a      	str	r2, [r3, #0]
      --tmpc;
 802683e:	69fb      	ldr	r3, [r7, #28]
 8026840:	3b04      	subs	r3, #4
 8026842:	61fb      	str	r3, [r7, #28]

      /* set the carry to the carry bits of the current word found above */
      r = rr;
 8026844:	68bb      	ldr	r3, [r7, #8]
 8026846:	61bb      	str	r3, [r7, #24]
    for (x = c->used - 1; x >= 0; x--) {
 8026848:	683b      	ldr	r3, [r7, #0]
 802684a:	3b01      	subs	r3, #1
 802684c:	603b      	str	r3, [r7, #0]
 802684e:	683b      	ldr	r3, [r7, #0]
 8026850:	2b00      	cmp	r3, #0
 8026852:	dae4      	bge.n	802681e <fp_rshb+0x84>
    }

    /* clamp digits */
    fp_clamp(c);
 8026854:	e004      	b.n	8026860 <fp_rshb+0xc6>
 8026856:	687b      	ldr	r3, [r7, #4]
 8026858:	681b      	ldr	r3, [r3, #0]
 802685a:	1e5a      	subs	r2, r3, #1
 802685c:	687b      	ldr	r3, [r7, #4]
 802685e:	601a      	str	r2, [r3, #0]
 8026860:	687b      	ldr	r3, [r7, #4]
 8026862:	681b      	ldr	r3, [r3, #0]
 8026864:	2b00      	cmp	r3, #0
 8026866:	d009      	beq.n	802687c <fp_rshb+0xe2>
 8026868:	687b      	ldr	r3, [r7, #4]
 802686a:	681b      	ldr	r3, [r3, #0]
 802686c:	3b01      	subs	r3, #1
 802686e:	687a      	ldr	r2, [r7, #4]
 8026870:	3302      	adds	r3, #2
 8026872:	009b      	lsls	r3, r3, #2
 8026874:	4413      	add	r3, r2
 8026876:	685b      	ldr	r3, [r3, #4]
 8026878:	2b00      	cmp	r3, #0
 802687a:	d0ec      	beq.n	8026856 <fp_rshb+0xbc>
 802687c:	687b      	ldr	r3, [r7, #4]
 802687e:	681b      	ldr	r3, [r3, #0]
 8026880:	2b00      	cmp	r3, #0
 8026882:	d002      	beq.n	802688a <fp_rshb+0xf0>
 8026884:	687b      	ldr	r3, [r7, #4]
 8026886:	685b      	ldr	r3, [r3, #4]
 8026888:	e000      	b.n	802688c <fp_rshb+0xf2>
 802688a:	2300      	movs	r3, #0
 802688c:	687a      	ldr	r2, [r7, #4]
 802688e:	6053      	str	r3, [r2, #4]
 8026890:	e004      	b.n	802689c <fp_rshb+0x102>
    if (x <= 0) return;
 8026892:	bf00      	nop
 8026894:	e002      	b.n	802689c <fp_rshb+0x102>
        if (D == 0) return;
 8026896:	bf00      	nop
 8026898:	e000      	b.n	802689c <fp_rshb+0x102>
    if (fp_iszero(c)) return;
 802689a:	bf00      	nop
}
 802689c:	3720      	adds	r7, #32
 802689e:	46bd      	mov	sp, r7
 80268a0:	bd80      	pop	{r7, pc}

080268a2 <fp_rshd>:


void fp_rshd(fp_int *a, int x)
{
 80268a2:	b580      	push	{r7, lr}
 80268a4:	b084      	sub	sp, #16
 80268a6:	af00      	add	r7, sp, #0
 80268a8:	6078      	str	r0, [r7, #4]
 80268aa:	6039      	str	r1, [r7, #0]
  int y;

  /* too many digits just zero and return */
  if (x >= a->used) {
 80268ac:	687b      	ldr	r3, [r7, #4]
 80268ae:	681b      	ldr	r3, [r3, #0]
 80268b0:	683a      	ldr	r2, [r7, #0]
 80268b2:	429a      	cmp	r2, r3
 80268b4:	db03      	blt.n	80268be <fp_rshd+0x1c>
     fp_zero(a);
 80268b6:	6878      	ldr	r0, [r7, #4]
 80268b8:	f000 f8ac 	bl	8026a14 <fp_zero>
     return;
 80268bc:	e04e      	b.n	802695c <fp_rshd+0xba>
  }

   /* shift */
   for (y = 0; y < a->used - x; y++) {
 80268be:	2300      	movs	r3, #0
 80268c0:	60fb      	str	r3, [r7, #12]
 80268c2:	e010      	b.n	80268e6 <fp_rshd+0x44>
      a->dp[y] = a->dp[y+x];
 80268c4:	68fa      	ldr	r2, [r7, #12]
 80268c6:	683b      	ldr	r3, [r7, #0]
 80268c8:	4413      	add	r3, r2
 80268ca:	687a      	ldr	r2, [r7, #4]
 80268cc:	3302      	adds	r3, #2
 80268ce:	009b      	lsls	r3, r3, #2
 80268d0:	4413      	add	r3, r2
 80268d2:	685a      	ldr	r2, [r3, #4]
 80268d4:	6879      	ldr	r1, [r7, #4]
 80268d6:	68fb      	ldr	r3, [r7, #12]
 80268d8:	3302      	adds	r3, #2
 80268da:	009b      	lsls	r3, r3, #2
 80268dc:	440b      	add	r3, r1
 80268de:	605a      	str	r2, [r3, #4]
   for (y = 0; y < a->used - x; y++) {
 80268e0:	68fb      	ldr	r3, [r7, #12]
 80268e2:	3301      	adds	r3, #1
 80268e4:	60fb      	str	r3, [r7, #12]
 80268e6:	687b      	ldr	r3, [r7, #4]
 80268e8:	681a      	ldr	r2, [r3, #0]
 80268ea:	683b      	ldr	r3, [r7, #0]
 80268ec:	1ad3      	subs	r3, r2, r3
 80268ee:	68fa      	ldr	r2, [r7, #12]
 80268f0:	429a      	cmp	r2, r3
 80268f2:	dbe7      	blt.n	80268c4 <fp_rshd+0x22>
   }

   /* zero rest */
   for (; y < a->used; y++) {
 80268f4:	e009      	b.n	802690a <fp_rshd+0x68>
      a->dp[y] = 0;
 80268f6:	687a      	ldr	r2, [r7, #4]
 80268f8:	68fb      	ldr	r3, [r7, #12]
 80268fa:	3302      	adds	r3, #2
 80268fc:	009b      	lsls	r3, r3, #2
 80268fe:	4413      	add	r3, r2
 8026900:	2200      	movs	r2, #0
 8026902:	605a      	str	r2, [r3, #4]
   for (; y < a->used; y++) {
 8026904:	68fb      	ldr	r3, [r7, #12]
 8026906:	3301      	adds	r3, #1
 8026908:	60fb      	str	r3, [r7, #12]
 802690a:	687b      	ldr	r3, [r7, #4]
 802690c:	681b      	ldr	r3, [r3, #0]
 802690e:	68fa      	ldr	r2, [r7, #12]
 8026910:	429a      	cmp	r2, r3
 8026912:	dbf0      	blt.n	80268f6 <fp_rshd+0x54>
   }

   /* decrement count */
   a->used -= x;
 8026914:	687b      	ldr	r3, [r7, #4]
 8026916:	681a      	ldr	r2, [r3, #0]
 8026918:	683b      	ldr	r3, [r7, #0]
 802691a:	1ad2      	subs	r2, r2, r3
 802691c:	687b      	ldr	r3, [r7, #4]
 802691e:	601a      	str	r2, [r3, #0]
   fp_clamp(a);
 8026920:	e004      	b.n	802692c <fp_rshd+0x8a>
 8026922:	687b      	ldr	r3, [r7, #4]
 8026924:	681b      	ldr	r3, [r3, #0]
 8026926:	1e5a      	subs	r2, r3, #1
 8026928:	687b      	ldr	r3, [r7, #4]
 802692a:	601a      	str	r2, [r3, #0]
 802692c:	687b      	ldr	r3, [r7, #4]
 802692e:	681b      	ldr	r3, [r3, #0]
 8026930:	2b00      	cmp	r3, #0
 8026932:	d009      	beq.n	8026948 <fp_rshd+0xa6>
 8026934:	687b      	ldr	r3, [r7, #4]
 8026936:	681b      	ldr	r3, [r3, #0]
 8026938:	3b01      	subs	r3, #1
 802693a:	687a      	ldr	r2, [r7, #4]
 802693c:	3302      	adds	r3, #2
 802693e:	009b      	lsls	r3, r3, #2
 8026940:	4413      	add	r3, r2
 8026942:	685b      	ldr	r3, [r3, #4]
 8026944:	2b00      	cmp	r3, #0
 8026946:	d0ec      	beq.n	8026922 <fp_rshd+0x80>
 8026948:	687b      	ldr	r3, [r7, #4]
 802694a:	681b      	ldr	r3, [r3, #0]
 802694c:	2b00      	cmp	r3, #0
 802694e:	d002      	beq.n	8026956 <fp_rshd+0xb4>
 8026950:	687b      	ldr	r3, [r7, #4]
 8026952:	685b      	ldr	r3, [r3, #4]
 8026954:	e000      	b.n	8026958 <fp_rshd+0xb6>
 8026956:	2300      	movs	r3, #0
 8026958:	687a      	ldr	r2, [r7, #4]
 802695a:	6053      	str	r3, [r2, #4]
}
 802695c:	3710      	adds	r7, #16
 802695e:	46bd      	mov	sp, r7
 8026960:	bd80      	pop	{r7, pc}

08026962 <fp_sub_d>:


/* c = a - b */
int fp_sub_d(fp_int *a, fp_digit b, fp_int *c)
{
 8026962:	b580      	push	{r7, lr}
 8026964:	b088      	sub	sp, #32
 8026966:	af00      	add	r7, sp, #0
 8026968:	60f8      	str	r0, [r7, #12]
 802696a:	60b9      	str	r1, [r7, #8]
 802696c:	607a      	str	r2, [r7, #4]
#ifndef WOLFSSL_SMALL_STACK
   fp_int    tmp[1];
#else
   fp_int    *tmp;
#endif
   int       err = FP_OKAY;
 802696e:	2300      	movs	r3, #0
 8026970:	61fb      	str	r3, [r7, #28]

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8026972:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8026976:	f7f8 f981 	bl	801ec7c <wolfSSL_Malloc>
 802697a:	61b8      	str	r0, [r7, #24]
   if (tmp == NULL)
 802697c:	69bb      	ldr	r3, [r7, #24]
 802697e:	2b00      	cmp	r3, #0
 8026980:	d102      	bne.n	8026988 <fp_sub_d+0x26>
       return FP_MEM;
 8026982:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8026986:	e024      	b.n	80269d2 <fp_sub_d+0x70>
#endif

   fp_init(tmp);
 8026988:	69b8      	ldr	r0, [r7, #24]
 802698a:	f000 f835 	bl	80269f8 <fp_init>
   fp_set(tmp, b);
 802698e:	68b9      	ldr	r1, [r7, #8]
 8026990:	69b8      	ldr	r0, [r7, #24]
 8026992:	f7ff fe02 	bl	802659a <fp_set>
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
   if (c->size < FP_SIZE) {
 8026996:	687b      	ldr	r3, [r7, #4]
 8026998:	689b      	ldr	r3, [r3, #8]
 802699a:	2b87      	cmp	r3, #135	@ 0x87
 802699c:	dc0a      	bgt.n	80269b4 <fp_sub_d+0x52>
     err = fp_sub(a, tmp, tmp);
 802699e:	69ba      	ldr	r2, [r7, #24]
 80269a0:	69b9      	ldr	r1, [r7, #24]
 80269a2:	68f8      	ldr	r0, [r7, #12]
 80269a4:	f7fb ff1b 	bl	80227de <fp_sub>
 80269a8:	61f8      	str	r0, [r7, #28]
     fp_copy(tmp, c);
 80269aa:	6879      	ldr	r1, [r7, #4]
 80269ac:	69b8      	ldr	r0, [r7, #24]
 80269ae:	f000 fa0d 	bl	8026dcc <fp_copy>
 80269b2:	e005      	b.n	80269c0 <fp_sub_d+0x5e>
   }
   else
#endif
   {
     err = fp_sub(a, tmp, c);
 80269b4:	687a      	ldr	r2, [r7, #4]
 80269b6:	69b9      	ldr	r1, [r7, #24]
 80269b8:	68f8      	ldr	r0, [r7, #12]
 80269ba:	f7fb ff10 	bl	80227de <fp_sub>
 80269be:	61f8      	str	r0, [r7, #28]
   }

#ifdef WOLFSSL_SMALL_STACK
   XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 80269c0:	69bb      	ldr	r3, [r7, #24]
 80269c2:	617b      	str	r3, [r7, #20]
 80269c4:	697b      	ldr	r3, [r7, #20]
 80269c6:	2b00      	cmp	r3, #0
 80269c8:	d002      	beq.n	80269d0 <fp_sub_d+0x6e>
 80269ca:	6978      	ldr	r0, [r7, #20]
 80269cc:	f7f8 f972 	bl	801ecb4 <wolfSSL_Free>
#endif
   return err;
 80269d0:	69fb      	ldr	r3, [r7, #28]
}
 80269d2:	4618      	mov	r0, r3
 80269d4:	3720      	adds	r7, #32
 80269d6:	46bd      	mov	sp, r7
 80269d8:	bd80      	pop	{r7, pc}

080269da <mp_init>:

/* wolfSSL callers from normal lib */

/* init a new mp_int */
int mp_init (mp_int * a)
{
 80269da:	b580      	push	{r7, lr}
 80269dc:	b082      	sub	sp, #8
 80269de:	af00      	add	r7, sp, #0
 80269e0:	6078      	str	r0, [r7, #4]
  if (a)
 80269e2:	687b      	ldr	r3, [r7, #4]
 80269e4:	2b00      	cmp	r3, #0
 80269e6:	d002      	beq.n	80269ee <mp_init+0x14>
    fp_init(a);
 80269e8:	6878      	ldr	r0, [r7, #4]
 80269ea:	f000 f805 	bl	80269f8 <fp_init>
  return MP_OKAY;
 80269ee:	2300      	movs	r3, #0
}
 80269f0:	4618      	mov	r0, r3
 80269f2:	3708      	adds	r7, #8
 80269f4:	46bd      	mov	sp, r7
 80269f6:	bd80      	pop	{r7, pc}

080269f8 <fp_init>:

void fp_init(fp_int *a)
{
 80269f8:	b580      	push	{r7, lr}
 80269fa:	b082      	sub	sp, #8
 80269fc:	af00      	add	r7, sp, #0
 80269fe:	6078      	str	r0, [r7, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    a->size = FP_SIZE;
 8026a00:	687b      	ldr	r3, [r7, #4]
 8026a02:	2288      	movs	r2, #136	@ 0x88
 8026a04:	609a      	str	r2, [r3, #8]
#endif
#ifdef HAVE_WOLF_BIGINT
    wc_bigint_init(&a->raw);
#endif
    fp_zero(a);
 8026a06:	6878      	ldr	r0, [r7, #4]
 8026a08:	f000 f804 	bl	8026a14 <fp_zero>
}
 8026a0c:	bf00      	nop
 8026a0e:	3708      	adds	r7, #8
 8026a10:	46bd      	mov	sp, r7
 8026a12:	bd80      	pop	{r7, pc}

08026a14 <fp_zero>:

void fp_zero(fp_int *a)
{
 8026a14:	b580      	push	{r7, lr}
 8026a16:	b084      	sub	sp, #16
 8026a18:	af00      	add	r7, sp, #0
 8026a1a:	6078      	str	r0, [r7, #4]
    int size;
    a->used = 0;
 8026a1c:	687b      	ldr	r3, [r7, #4]
 8026a1e:	2200      	movs	r2, #0
 8026a20:	601a      	str	r2, [r3, #0]
    a->sign = FP_ZPOS;
 8026a22:	687b      	ldr	r3, [r7, #4]
 8026a24:	2200      	movs	r2, #0
 8026a26:	605a      	str	r2, [r3, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    size = a->size;
 8026a28:	687b      	ldr	r3, [r7, #4]
 8026a2a:	689b      	ldr	r3, [r3, #8]
 8026a2c:	60fb      	str	r3, [r7, #12]
#else
    size = FP_SIZE;
#endif
    XMEMSET(a->dp, 0, size * sizeof(fp_digit));
 8026a2e:	687b      	ldr	r3, [r7, #4]
 8026a30:	f103 000c 	add.w	r0, r3, #12
 8026a34:	68fb      	ldr	r3, [r7, #12]
 8026a36:	009b      	lsls	r3, r3, #2
 8026a38:	461a      	mov	r2, r3
 8026a3a:	2100      	movs	r1, #0
 8026a3c:	f002 f8f2 	bl	8028c24 <memset>
}
 8026a40:	bf00      	nop
 8026a42:	3710      	adds	r7, #16
 8026a44:	46bd      	mov	sp, r7
 8026a46:	bd80      	pop	{r7, pc}

08026a48 <fp_clear>:

void fp_clear(fp_int *a)
{
 8026a48:	b580      	push	{r7, lr}
 8026a4a:	b084      	sub	sp, #16
 8026a4c:	af00      	add	r7, sp, #0
 8026a4e:	6078      	str	r0, [r7, #4]
    int size;
    a->used = 0;
 8026a50:	687b      	ldr	r3, [r7, #4]
 8026a52:	2200      	movs	r2, #0
 8026a54:	601a      	str	r2, [r3, #0]
    a->sign = FP_ZPOS;
 8026a56:	687b      	ldr	r3, [r7, #4]
 8026a58:	2200      	movs	r2, #0
 8026a5a:	605a      	str	r2, [r3, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    size = a->size;
 8026a5c:	687b      	ldr	r3, [r7, #4]
 8026a5e:	689b      	ldr	r3, [r3, #8]
 8026a60:	60fb      	str	r3, [r7, #12]
#else
    size = FP_SIZE;
#endif
    XMEMSET(a->dp, 0, size * sizeof(fp_digit));
 8026a62:	687b      	ldr	r3, [r7, #4]
 8026a64:	f103 000c 	add.w	r0, r3, #12
 8026a68:	68fb      	ldr	r3, [r7, #12]
 8026a6a:	009b      	lsls	r3, r3, #2
 8026a6c:	461a      	mov	r2, r3
 8026a6e:	2100      	movs	r1, #0
 8026a70:	f002 f8d8 	bl	8028c24 <memset>
    fp_free(a);
 8026a74:	6878      	ldr	r0, [r7, #4]
 8026a76:	f000 f830 	bl	8026ada <fp_free>
}
 8026a7a:	bf00      	nop
 8026a7c:	3710      	adds	r7, #16
 8026a7e:	46bd      	mov	sp, r7
 8026a80:	bd80      	pop	{r7, pc}

08026a82 <fp_forcezero>:

void fp_forcezero (mp_int * a)
{
 8026a82:	b580      	push	{r7, lr}
 8026a84:	b084      	sub	sp, #16
 8026a86:	af00      	add	r7, sp, #0
 8026a88:	6078      	str	r0, [r7, #4]
    int size;

    if (a == NULL)
 8026a8a:	687b      	ldr	r3, [r7, #4]
 8026a8c:	2b00      	cmp	r3, #0
 8026a8e:	d015      	beq.n	8026abc <fp_forcezero+0x3a>
      return;

    a->used = 0;
 8026a90:	687b      	ldr	r3, [r7, #4]
 8026a92:	2200      	movs	r2, #0
 8026a94:	601a      	str	r2, [r3, #0]
    a->sign = FP_ZPOS;
 8026a96:	687b      	ldr	r3, [r7, #4]
 8026a98:	2200      	movs	r2, #0
 8026a9a:	605a      	str	r2, [r3, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    size = a->size;
 8026a9c:	687b      	ldr	r3, [r7, #4]
 8026a9e:	689b      	ldr	r3, [r3, #8]
 8026aa0:	60fb      	str	r3, [r7, #12]
#else
    size = FP_SIZE;
#endif
    ForceZero(a->dp, size * sizeof(fp_digit));
 8026aa2:	687b      	ldr	r3, [r7, #4]
 8026aa4:	f103 020c 	add.w	r2, r3, #12
 8026aa8:	68fb      	ldr	r3, [r7, #12]
 8026aaa:	009b      	lsls	r3, r3, #2
 8026aac:	4619      	mov	r1, r3
 8026aae:	4610      	mov	r0, r2
 8026ab0:	f7fb fd4c 	bl	802254c <ForceZero>
#ifdef HAVE_WOLF_BIGINT
    wc_bigint_zero(&a->raw);
#endif
    fp_free(a);
 8026ab4:	6878      	ldr	r0, [r7, #4]
 8026ab6:	f000 f810 	bl	8026ada <fp_free>
 8026aba:	e000      	b.n	8026abe <fp_forcezero+0x3c>
      return;
 8026abc:	bf00      	nop
}
 8026abe:	3710      	adds	r7, #16
 8026ac0:	46bd      	mov	sp, r7
 8026ac2:	bd80      	pop	{r7, pc}

08026ac4 <mp_forcezero>:

void mp_forcezero (mp_int * a)
{
 8026ac4:	b580      	push	{r7, lr}
 8026ac6:	b082      	sub	sp, #8
 8026ac8:	af00      	add	r7, sp, #0
 8026aca:	6078      	str	r0, [r7, #4]
    fp_forcezero(a);
 8026acc:	6878      	ldr	r0, [r7, #4]
 8026ace:	f7ff ffd8 	bl	8026a82 <fp_forcezero>
}
 8026ad2:	bf00      	nop
 8026ad4:	3708      	adds	r7, #8
 8026ad6:	46bd      	mov	sp, r7
 8026ad8:	bd80      	pop	{r7, pc}

08026ada <fp_free>:

void fp_free(fp_int* a)
{
 8026ada:	b480      	push	{r7}
 8026adc:	b083      	sub	sp, #12
 8026ade:	af00      	add	r7, sp, #0
 8026ae0:	6078      	str	r0, [r7, #4]
#ifdef HAVE_WOLF_BIGINT
    wc_bigint_free(&a->raw);
#else
    (void)a;
#endif
}
 8026ae2:	bf00      	nop
 8026ae4:	370c      	adds	r7, #12
 8026ae6:	46bd      	mov	sp, r7
 8026ae8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026aec:	4770      	bx	lr

08026aee <mp_clear>:


/* clear one (frees)  */
void mp_clear (mp_int * a)
{
 8026aee:	b580      	push	{r7, lr}
 8026af0:	b082      	sub	sp, #8
 8026af2:	af00      	add	r7, sp, #0
 8026af4:	6078      	str	r0, [r7, #4]
    if (a == NULL)
 8026af6:	687b      	ldr	r3, [r7, #4]
 8026af8:	2b00      	cmp	r3, #0
 8026afa:	d003      	beq.n	8026b04 <mp_clear+0x16>
        return;
    fp_clear(a);
 8026afc:	6878      	ldr	r0, [r7, #4]
 8026afe:	f7ff ffa3 	bl	8026a48 <fp_clear>
 8026b02:	e000      	b.n	8026b06 <mp_clear+0x18>
        return;
 8026b04:	bf00      	nop
}
 8026b06:	3708      	adds	r7, #8
 8026b08:	46bd      	mov	sp, r7
 8026b0a:	bd80      	pop	{r7, pc}

08026b0c <mp_free>:

void mp_free(mp_int* a)
{
 8026b0c:	b580      	push	{r7, lr}
 8026b0e:	b082      	sub	sp, #8
 8026b10:	af00      	add	r7, sp, #0
 8026b12:	6078      	str	r0, [r7, #4]
    fp_free(a);
 8026b14:	6878      	ldr	r0, [r7, #4]
 8026b16:	f7ff ffe0 	bl	8026ada <fp_free>
}
 8026b1a:	bf00      	nop
 8026b1c:	3708      	adds	r7, #8
 8026b1e:	46bd      	mov	sp, r7
 8026b20:	bd80      	pop	{r7, pc}

08026b22 <mp_init_multi>:

/* handle up to 6 inits */
int mp_init_multi(mp_int* a, mp_int* b, mp_int* c, mp_int* d,
                  mp_int* e, mp_int* f)
{
 8026b22:	b580      	push	{r7, lr}
 8026b24:	b084      	sub	sp, #16
 8026b26:	af00      	add	r7, sp, #0
 8026b28:	60f8      	str	r0, [r7, #12]
 8026b2a:	60b9      	str	r1, [r7, #8]
 8026b2c:	607a      	str	r2, [r7, #4]
 8026b2e:	603b      	str	r3, [r7, #0]
    if (a)
 8026b30:	68fb      	ldr	r3, [r7, #12]
 8026b32:	2b00      	cmp	r3, #0
 8026b34:	d002      	beq.n	8026b3c <mp_init_multi+0x1a>
        fp_init(a);
 8026b36:	68f8      	ldr	r0, [r7, #12]
 8026b38:	f7ff ff5e 	bl	80269f8 <fp_init>
    if (b)
 8026b3c:	68bb      	ldr	r3, [r7, #8]
 8026b3e:	2b00      	cmp	r3, #0
 8026b40:	d002      	beq.n	8026b48 <mp_init_multi+0x26>
        fp_init(b);
 8026b42:	68b8      	ldr	r0, [r7, #8]
 8026b44:	f7ff ff58 	bl	80269f8 <fp_init>
    if (c)
 8026b48:	687b      	ldr	r3, [r7, #4]
 8026b4a:	2b00      	cmp	r3, #0
 8026b4c:	d002      	beq.n	8026b54 <mp_init_multi+0x32>
        fp_init(c);
 8026b4e:	6878      	ldr	r0, [r7, #4]
 8026b50:	f7ff ff52 	bl	80269f8 <fp_init>
    if (d)
 8026b54:	683b      	ldr	r3, [r7, #0]
 8026b56:	2b00      	cmp	r3, #0
 8026b58:	d002      	beq.n	8026b60 <mp_init_multi+0x3e>
        fp_init(d);
 8026b5a:	6838      	ldr	r0, [r7, #0]
 8026b5c:	f7ff ff4c 	bl	80269f8 <fp_init>
    if (e)
 8026b60:	69bb      	ldr	r3, [r7, #24]
 8026b62:	2b00      	cmp	r3, #0
 8026b64:	d002      	beq.n	8026b6c <mp_init_multi+0x4a>
        fp_init(e);
 8026b66:	69b8      	ldr	r0, [r7, #24]
 8026b68:	f7ff ff46 	bl	80269f8 <fp_init>
    if (f)
 8026b6c:	69fb      	ldr	r3, [r7, #28]
 8026b6e:	2b00      	cmp	r3, #0
 8026b70:	d002      	beq.n	8026b78 <mp_init_multi+0x56>
        fp_init(f);
 8026b72:	69f8      	ldr	r0, [r7, #28]
 8026b74:	f7ff ff40 	bl	80269f8 <fp_init>

    return MP_OKAY;
 8026b78:	2300      	movs	r3, #0
}
 8026b7a:	4618      	mov	r0, r3
 8026b7c:	3710      	adds	r7, #16
 8026b7e:	46bd      	mov	sp, r7
 8026b80:	bd80      	pop	{r7, pc}

08026b82 <mp_add>:

/* high level addition (handles signs) */
int mp_add (mp_int * a, mp_int * b, mp_int * c)
{
 8026b82:	b580      	push	{r7, lr}
 8026b84:	b084      	sub	sp, #16
 8026b86:	af00      	add	r7, sp, #0
 8026b88:	60f8      	str	r0, [r7, #12]
 8026b8a:	60b9      	str	r1, [r7, #8]
 8026b8c:	607a      	str	r2, [r7, #4]
  return fp_add(a, b, c);
 8026b8e:	687a      	ldr	r2, [r7, #4]
 8026b90:	68b9      	ldr	r1, [r7, #8]
 8026b92:	68f8      	ldr	r0, [r7, #12]
 8026b94:	f7fb fd41 	bl	802261a <fp_add>
 8026b98:	4603      	mov	r3, r0
}
 8026b9a:	4618      	mov	r0, r3
 8026b9c:	3710      	adds	r7, #16
 8026b9e:	46bd      	mov	sp, r7
 8026ba0:	bd80      	pop	{r7, pc}

08026ba2 <mp_sub>:

/* high level subtraction (handles signs) */
int mp_sub (mp_int * a, mp_int * b, mp_int * c)
{
 8026ba2:	b580      	push	{r7, lr}
 8026ba4:	b084      	sub	sp, #16
 8026ba6:	af00      	add	r7, sp, #0
 8026ba8:	60f8      	str	r0, [r7, #12]
 8026baa:	60b9      	str	r1, [r7, #8]
 8026bac:	607a      	str	r2, [r7, #4]
  return fp_sub(a, b, c);
 8026bae:	687a      	ldr	r2, [r7, #4]
 8026bb0:	68b9      	ldr	r1, [r7, #8]
 8026bb2:	68f8      	ldr	r0, [r7, #12]
 8026bb4:	f7fb fe13 	bl	80227de <fp_sub>
 8026bb8:	4603      	mov	r3, r0
}
 8026bba:	4618      	mov	r0, r3
 8026bbc:	3710      	adds	r7, #16
 8026bbe:	46bd      	mov	sp, r7
 8026bc0:	bd80      	pop	{r7, pc}

08026bc2 <mp_mul>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_mul(mp_int * a, mp_int * b, mp_int * c)
#else
int mp_mul (mp_int * a, mp_int * b, mp_int * c)
#endif
{
 8026bc2:	b580      	push	{r7, lr}
 8026bc4:	b084      	sub	sp, #16
 8026bc6:	af00      	add	r7, sp, #0
 8026bc8:	60f8      	str	r0, [r7, #12]
 8026bca:	60b9      	str	r1, [r7, #8]
 8026bcc:	607a      	str	r2, [r7, #4]
  return fp_mul(a, b, c);
 8026bce:	687a      	ldr	r2, [r7, #4]
 8026bd0:	68b9      	ldr	r1, [r7, #8]
 8026bd2:	68f8      	ldr	r0, [r7, #12]
 8026bd4:	f7fb ff07 	bl	80229e6 <fp_mul>
 8026bd8:	4603      	mov	r3, r0
}
 8026bda:	4618      	mov	r0, r3
 8026bdc:	3710      	adds	r7, #16
 8026bde:	46bd      	mov	sp, r7
 8026be0:	bd80      	pop	{r7, pc}

08026be2 <mp_mulmod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_mulmod (mp_int * a, mp_int * b, mp_int * c, mp_int * d)
#else
int mp_mulmod (mp_int * a, mp_int * b, mp_int * c, mp_int * d)
#endif
{
 8026be2:	b580      	push	{r7, lr}
 8026be4:	b086      	sub	sp, #24
 8026be6:	af00      	add	r7, sp, #0
 8026be8:	60f8      	str	r0, [r7, #12]
 8026bea:	60b9      	str	r1, [r7, #8]
 8026bec:	607a      	str	r2, [r7, #4]
 8026bee:	603b      	str	r3, [r7, #0]
   int ret = MP_OKAY;
 8026bf0:	2300      	movs	r3, #0
 8026bf2:	617b      	str	r3, [r7, #20]
          * Future implementation may consider saving operands,
          * but hard errors should never actually occur. */
         break;
   }
#else /* no HW */
   ret = fp_mulmod(a, b, c, d);
 8026bf4:	683b      	ldr	r3, [r7, #0]
 8026bf6:	687a      	ldr	r2, [r7, #4]
 8026bf8:	68b9      	ldr	r1, [r7, #8]
 8026bfa:	68f8      	ldr	r0, [r7, #12]
 8026bfc:	f7fd fce9 	bl	80245d2 <fp_mulmod>
 8026c00:	6178      	str	r0, [r7, #20]
#endif /* WOLFSSL_ESP32_CRYPT_RSA_PRI_MULMOD */
   return ret;
 8026c02:	697b      	ldr	r3, [r7, #20]
}
 8026c04:	4618      	mov	r0, r3
 8026c06:	3718      	adds	r7, #24
 8026c08:	46bd      	mov	sp, r7
 8026c0a:	bd80      	pop	{r7, pc}

08026c0c <mp_submod_ct>:
  return fp_addmod(a, b, c, d);
}

/* d = a - b (mod c) - constant time (a < c and b < c) */
int mp_submod_ct(mp_int *a, mp_int *b, mp_int *c, mp_int *d)
{
 8026c0c:	b580      	push	{r7, lr}
 8026c0e:	b084      	sub	sp, #16
 8026c10:	af00      	add	r7, sp, #0
 8026c12:	60f8      	str	r0, [r7, #12]
 8026c14:	60b9      	str	r1, [r7, #8]
 8026c16:	607a      	str	r2, [r7, #4]
 8026c18:	603b      	str	r3, [r7, #0]
  return fp_submod_ct(a, b, c, d);
 8026c1a:	683b      	ldr	r3, [r7, #0]
 8026c1c:	687a      	ldr	r2, [r7, #4]
 8026c1e:	68b9      	ldr	r1, [r7, #8]
 8026c20:	68f8      	ldr	r0, [r7, #12]
 8026c22:	f7fd fd16 	bl	8024652 <fp_submod_ct>
 8026c26:	4603      	mov	r3, r0
}
 8026c28:	4618      	mov	r0, r3
 8026c2a:	3710      	adds	r7, #16
 8026c2c:	46bd      	mov	sp, r7
 8026c2e:	bd80      	pop	{r7, pc}

08026c30 <mp_addmod_ct>:

/* d = a + b (mod c) - constant time (a < c and b < c) */
int mp_addmod_ct(mp_int *a, mp_int *b, mp_int *c, mp_int *d)
{
 8026c30:	b580      	push	{r7, lr}
 8026c32:	b084      	sub	sp, #16
 8026c34:	af00      	add	r7, sp, #0
 8026c36:	60f8      	str	r0, [r7, #12]
 8026c38:	60b9      	str	r1, [r7, #8]
 8026c3a:	607a      	str	r2, [r7, #4]
 8026c3c:	603b      	str	r3, [r7, #0]
  return fp_addmod_ct(a, b, c, d);
 8026c3e:	683b      	ldr	r3, [r7, #0]
 8026c40:	687a      	ldr	r2, [r7, #4]
 8026c42:	68b9      	ldr	r1, [r7, #8]
 8026c44:	68f8      	ldr	r0, [r7, #12]
 8026c46:	f7fd fe20 	bl	802488a <fp_addmod_ct>
 8026c4a:	4603      	mov	r3, r0
}
 8026c4c:	4618      	mov	r0, r3
 8026c4e:	3710      	adds	r7, #16
 8026c50:	46bd      	mov	sp, r7
 8026c52:	bd80      	pop	{r7, pc}

08026c54 <mp_mod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_mod (mp_int * a, mp_int * b, mp_int * c)
#else
int mp_mod (mp_int * a, mp_int * b, mp_int * c)
#endif
{
 8026c54:	b580      	push	{r7, lr}
 8026c56:	b084      	sub	sp, #16
 8026c58:	af00      	add	r7, sp, #0
 8026c5a:	60f8      	str	r0, [r7, #12]
 8026c5c:	60b9      	str	r1, [r7, #8]
 8026c5e:	607a      	str	r2, [r7, #4]
  return fp_mod (a, b, c);
 8026c60:	687a      	ldr	r2, [r7, #4]
 8026c62:	68b9      	ldr	r1, [r7, #8]
 8026c64:	68f8      	ldr	r0, [r7, #12]
 8026c66:	f7fc fe57 	bl	8023918 <fp_mod>
 8026c6a:	4603      	mov	r3, r0
}
 8026c6c:	4618      	mov	r0, r3
 8026c6e:	3710      	adds	r7, #16
 8026c70:	46bd      	mov	sp, r7
 8026c72:	bd80      	pop	{r7, pc}

08026c74 <mp_invmod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_invmod (mp_int * a, mp_int * b, mp_int * c)
#else
int mp_invmod (mp_int * a, mp_int * b, mp_int * c)
#endif
{
 8026c74:	b580      	push	{r7, lr}
 8026c76:	b084      	sub	sp, #16
 8026c78:	af00      	add	r7, sp, #0
 8026c7a:	60f8      	str	r0, [r7, #12]
 8026c7c:	60b9      	str	r1, [r7, #8]
 8026c7e:	607a      	str	r2, [r7, #4]
  return fp_invmod(a, b, c);
 8026c80:	687a      	ldr	r2, [r7, #4]
 8026c82:	68b9      	ldr	r1, [r7, #8]
 8026c84:	68f8      	ldr	r0, [r7, #12]
 8026c86:	f7fd f99e 	bl	8023fc6 <fp_invmod>
 8026c8a:	4603      	mov	r3, r0
}
 8026c8c:	4618      	mov	r0, r3
 8026c8e:	3710      	adds	r7, #16
 8026c90:	46bd      	mov	sp, r7
 8026c92:	bd80      	pop	{r7, pc}

08026c94 <mp_invmod_mont_ct>:

/* hac 14.61, pp608 */
int mp_invmod_mont_ct (mp_int * a, mp_int * b, mp_int * c, mp_digit mp)
{
 8026c94:	b580      	push	{r7, lr}
 8026c96:	b084      	sub	sp, #16
 8026c98:	af00      	add	r7, sp, #0
 8026c9a:	60f8      	str	r0, [r7, #12]
 8026c9c:	60b9      	str	r1, [r7, #8]
 8026c9e:	607a      	str	r2, [r7, #4]
 8026ca0:	603b      	str	r3, [r7, #0]
  return fp_invmod_mont_ct(a, b, c, mp);
 8026ca2:	683b      	ldr	r3, [r7, #0]
 8026ca4:	687a      	ldr	r2, [r7, #4]
 8026ca6:	68b9      	ldr	r1, [r7, #8]
 8026ca8:	68f8      	ldr	r0, [r7, #12]
 8026caa:	f7fd fb4f 	bl	802434c <fp_invmod_mont_ct>
 8026cae:	4603      	mov	r3, r0
}
 8026cb0:	4618      	mov	r0, r3
 8026cb2:	3710      	adds	r7, #16
 8026cb4:	46bd      	mov	sp, r7
 8026cb6:	bd80      	pop	{r7, pc}

08026cb8 <mp_exptmod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_exptmod (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#else
int mp_exptmod (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#endif
{
 8026cb8:	b580      	push	{r7, lr}
 8026cba:	b084      	sub	sp, #16
 8026cbc:	af00      	add	r7, sp, #0
 8026cbe:	60f8      	str	r0, [r7, #12]
 8026cc0:	60b9      	str	r1, [r7, #8]
 8026cc2:	607a      	str	r2, [r7, #4]
 8026cc4:	603b      	str	r3, [r7, #0]
  return fp_exptmod(G, X, P, Y);
 8026cc6:	683b      	ldr	r3, [r7, #0]
 8026cc8:	687a      	ldr	r2, [r7, #4]
 8026cca:	68b9      	ldr	r1, [r7, #8]
 8026ccc:	68f8      	ldr	r0, [r7, #12]
 8026cce:	f7fe fcbf 	bl	8025650 <fp_exptmod>
 8026cd2:	4603      	mov	r3, r0
}
 8026cd4:	4618      	mov	r0, r3
 8026cd6:	3710      	adds	r7, #16
 8026cd8:	46bd      	mov	sp, r7
 8026cda:	bd80      	pop	{r7, pc}

08026cdc <mp_exptmod_nct>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_exptmod_nct (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#else
int mp_exptmod_nct (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#endif
{
 8026cdc:	b580      	push	{r7, lr}
 8026cde:	b084      	sub	sp, #16
 8026ce0:	af00      	add	r7, sp, #0
 8026ce2:	60f8      	str	r0, [r7, #12]
 8026ce4:	60b9      	str	r1, [r7, #8]
 8026ce6:	607a      	str	r2, [r7, #4]
 8026ce8:	603b      	str	r3, [r7, #0]
  return fp_exptmod_nct(G, X, P, Y);
 8026cea:	683b      	ldr	r3, [r7, #0]
 8026cec:	687a      	ldr	r2, [r7, #4]
 8026cee:	68b9      	ldr	r1, [r7, #8]
 8026cf0:	68f8      	ldr	r0, [r7, #12]
 8026cf2:	f7fe fd60 	bl	80257b6 <fp_exptmod_nct>
 8026cf6:	4603      	mov	r3, r0
}
 8026cf8:	4618      	mov	r0, r3
 8026cfa:	3710      	adds	r7, #16
 8026cfc:	46bd      	mov	sp, r7
 8026cfe:	bd80      	pop	{r7, pc}

08026d00 <mp_cmp>:


/* compare two ints (signed)*/
int mp_cmp (mp_int * a, mp_int * b)
{
 8026d00:	b580      	push	{r7, lr}
 8026d02:	b082      	sub	sp, #8
 8026d04:	af00      	add	r7, sp, #0
 8026d06:	6078      	str	r0, [r7, #4]
 8026d08:	6039      	str	r1, [r7, #0]
  return fp_cmp(a, b);
 8026d0a:	6839      	ldr	r1, [r7, #0]
 8026d0c:	6878      	ldr	r0, [r7, #4]
 8026d0e:	f7ff f859 	bl	8025dc4 <fp_cmp>
 8026d12:	4603      	mov	r3, r0
}
 8026d14:	4618      	mov	r0, r3
 8026d16:	3708      	adds	r7, #8
 8026d18:	46bd      	mov	sp, r7
 8026d1a:	bd80      	pop	{r7, pc}

08026d1c <mp_cmp_d>:

/* compare a digit */
int mp_cmp_d(mp_int * a, mp_digit b)
{
 8026d1c:	b580      	push	{r7, lr}
 8026d1e:	b082      	sub	sp, #8
 8026d20:	af00      	add	r7, sp, #0
 8026d22:	6078      	str	r0, [r7, #4]
 8026d24:	6039      	str	r1, [r7, #0]
  return fp_cmp_d(a, b);
 8026d26:	6839      	ldr	r1, [r7, #0]
 8026d28:	6878      	ldr	r0, [r7, #4]
 8026d2a:	f7ff f878 	bl	8025e1e <fp_cmp_d>
 8026d2e:	4603      	mov	r3, r0
}
 8026d30:	4618      	mov	r0, r3
 8026d32:	3708      	adds	r7, #8
 8026d34:	46bd      	mov	sp, r7
 8026d36:	bd80      	pop	{r7, pc}

08026d38 <mp_unsigned_bin_size>:

/* get the size for an unsigned equivalent */
int mp_unsigned_bin_size (const mp_int * a)
{
 8026d38:	b580      	push	{r7, lr}
 8026d3a:	b082      	sub	sp, #8
 8026d3c:	af00      	add	r7, sp, #0
 8026d3e:	6078      	str	r0, [r7, #4]
  return fp_unsigned_bin_size(a);
 8026d40:	6878      	ldr	r0, [r7, #4]
 8026d42:	f7ff fc0f 	bl	8026564 <fp_unsigned_bin_size>
 8026d46:	4603      	mov	r3, r0
}
 8026d48:	4618      	mov	r0, r3
 8026d4a:	3708      	adds	r7, #8
 8026d4c:	46bd      	mov	sp, r7
 8026d4e:	bd80      	pop	{r7, pc}

08026d50 <mp_to_unsigned_bin>:
  return fp_to_unsigned_bin_at_pos(x, t, b);
}

/* store in unsigned [big endian] format */
int mp_to_unsigned_bin (mp_int * a, unsigned char *b)
{
 8026d50:	b580      	push	{r7, lr}
 8026d52:	b082      	sub	sp, #8
 8026d54:	af00      	add	r7, sp, #0
 8026d56:	6078      	str	r0, [r7, #4]
 8026d58:	6039      	str	r1, [r7, #0]
  return fp_to_unsigned_bin(a,b);
 8026d5a:	6839      	ldr	r1, [r7, #0]
 8026d5c:	6878      	ldr	r0, [r7, #4]
 8026d5e:	f7ff fb6e 	bl	802643e <fp_to_unsigned_bin>
 8026d62:	4603      	mov	r3, r0
}
 8026d64:	4618      	mov	r0, r3
 8026d66:	3708      	adds	r7, #8
 8026d68:	46bd      	mov	sp, r7
 8026d6a:	bd80      	pop	{r7, pc}

08026d6c <mp_to_unsigned_bin_len>:

int mp_to_unsigned_bin_len(mp_int * a, unsigned char *b, int c)
{
 8026d6c:	b580      	push	{r7, lr}
 8026d6e:	b084      	sub	sp, #16
 8026d70:	af00      	add	r7, sp, #0
 8026d72:	60f8      	str	r0, [r7, #12]
 8026d74:	60b9      	str	r1, [r7, #8]
 8026d76:	607a      	str	r2, [r7, #4]
  return fp_to_unsigned_bin_len(a, b, c);
 8026d78:	687a      	ldr	r2, [r7, #4]
 8026d7a:	68b9      	ldr	r1, [r7, #8]
 8026d7c:	68f8      	ldr	r0, [r7, #12]
 8026d7e:	f7ff fb89 	bl	8026494 <fp_to_unsigned_bin_len>
 8026d82:	4603      	mov	r3, r0
}
 8026d84:	4618      	mov	r0, r3
 8026d86:	3710      	adds	r7, #16
 8026d88:	46bd      	mov	sp, r7
 8026d8a:	bd80      	pop	{r7, pc}

08026d8c <mp_read_unsigned_bin>:
/* reads a unsigned char array, assumes the msb is stored first [big endian] */
int mp_read_unsigned_bin (mp_int * a, const unsigned char *b, int c)
{
 8026d8c:	b580      	push	{r7, lr}
 8026d8e:	b084      	sub	sp, #16
 8026d90:	af00      	add	r7, sp, #0
 8026d92:	60f8      	str	r0, [r7, #12]
 8026d94:	60b9      	str	r1, [r7, #8]
 8026d96:	607a      	str	r2, [r7, #4]
  return fp_read_unsigned_bin(a, b, c);
 8026d98:	687a      	ldr	r2, [r7, #4]
 8026d9a:	68b9      	ldr	r1, [r7, #8]
 8026d9c:	68f8      	ldr	r0, [r7, #12]
 8026d9e:	f7ff fa97 	bl	80262d0 <fp_read_unsigned_bin>
 8026da2:	4603      	mov	r3, r0
}
 8026da4:	4618      	mov	r0, r3
 8026da6:	3710      	adds	r7, #16
 8026da8:	46bd      	mov	sp, r7
 8026daa:	bd80      	pop	{r7, pc}

08026dac <mp_sub_d>:


int mp_sub_d(fp_int *a, fp_digit b, fp_int *c)
{
 8026dac:	b580      	push	{r7, lr}
 8026dae:	b084      	sub	sp, #16
 8026db0:	af00      	add	r7, sp, #0
 8026db2:	60f8      	str	r0, [r7, #12]
 8026db4:	60b9      	str	r1, [r7, #8]
 8026db6:	607a      	str	r2, [r7, #4]
  return fp_sub_d(a, b, c);
 8026db8:	687a      	ldr	r2, [r7, #4]
 8026dba:	68b9      	ldr	r1, [r7, #8]
 8026dbc:	68f8      	ldr	r0, [r7, #12]
 8026dbe:	f7ff fdd0 	bl	8026962 <fp_sub_d>
 8026dc2:	4603      	mov	r3, r0
}
 8026dc4:	4618      	mov	r0, r3
 8026dc6:	3710      	adds	r7, #16
 8026dc8:	46bd      	mov	sp, r7
 8026dca:	bd80      	pop	{r7, pc}

08026dcc <fp_copy>:
  return MP_OKAY;
}

/* copy (src = a) to (dst = b) */
void fp_copy(const fp_int *a, fp_int *b)
{
 8026dcc:	b580      	push	{r7, lr}
 8026dce:	b084      	sub	sp, #16
 8026dd0:	af00      	add	r7, sp, #0
 8026dd2:	6078      	str	r0, [r7, #4]
 8026dd4:	6039      	str	r1, [r7, #0]
    /* if source and destination are different */
    if (a != b) {
 8026dd6:	687a      	ldr	r2, [r7, #4]
 8026dd8:	683b      	ldr	r3, [r7, #0]
 8026dda:	429a      	cmp	r2, r3
 8026ddc:	d031      	beq.n	8026e42 <fp_copy+0x76>
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
        /* verify a will fit in b */
        if (b->size >= a->used) {
 8026dde:	683b      	ldr	r3, [r7, #0]
 8026de0:	689a      	ldr	r2, [r3, #8]
 8026de2:	687b      	ldr	r3, [r7, #4]
 8026de4:	681b      	ldr	r3, [r3, #0]
 8026de6:	429a      	cmp	r2, r3
 8026de8:	db2b      	blt.n	8026e42 <fp_copy+0x76>
            int x, oldused;
            oldused = b->used;
 8026dea:	683b      	ldr	r3, [r7, #0]
 8026dec:	681b      	ldr	r3, [r3, #0]
 8026dee:	60bb      	str	r3, [r7, #8]
            b->used = a->used;
 8026df0:	687b      	ldr	r3, [r7, #4]
 8026df2:	681a      	ldr	r2, [r3, #0]
 8026df4:	683b      	ldr	r3, [r7, #0]
 8026df6:	601a      	str	r2, [r3, #0]
            b->sign = a->sign;
 8026df8:	687b      	ldr	r3, [r7, #4]
 8026dfa:	685a      	ldr	r2, [r3, #4]
 8026dfc:	683b      	ldr	r3, [r7, #0]
 8026dfe:	605a      	str	r2, [r3, #4]

            XMEMCPY(b->dp, a->dp, a->used * sizeof(fp_digit));
 8026e00:	683b      	ldr	r3, [r7, #0]
 8026e02:	f103 000c 	add.w	r0, r3, #12
 8026e06:	687b      	ldr	r3, [r7, #4]
 8026e08:	f103 010c 	add.w	r1, r3, #12
 8026e0c:	687b      	ldr	r3, [r7, #4]
 8026e0e:	681b      	ldr	r3, [r3, #0]
 8026e10:	009b      	lsls	r3, r3, #2
 8026e12:	461a      	mov	r2, r3
 8026e14:	f001 ffb7 	bl	8028d86 <memcpy>

            /* zero any excess digits on the destination that we didn't write to */
            for (x = b->used; x >= 0 && x < oldused; x++) {
 8026e18:	683b      	ldr	r3, [r7, #0]
 8026e1a:	681b      	ldr	r3, [r3, #0]
 8026e1c:	60fb      	str	r3, [r7, #12]
 8026e1e:	e009      	b.n	8026e34 <fp_copy+0x68>
                b->dp[x] = 0;
 8026e20:	683a      	ldr	r2, [r7, #0]
 8026e22:	68fb      	ldr	r3, [r7, #12]
 8026e24:	3302      	adds	r3, #2
 8026e26:	009b      	lsls	r3, r3, #2
 8026e28:	4413      	add	r3, r2
 8026e2a:	2200      	movs	r2, #0
 8026e2c:	605a      	str	r2, [r3, #4]
            for (x = b->used; x >= 0 && x < oldused; x++) {
 8026e2e:	68fb      	ldr	r3, [r7, #12]
 8026e30:	3301      	adds	r3, #1
 8026e32:	60fb      	str	r3, [r7, #12]
 8026e34:	68fb      	ldr	r3, [r7, #12]
 8026e36:	2b00      	cmp	r3, #0
 8026e38:	db03      	blt.n	8026e42 <fp_copy+0x76>
 8026e3a:	68fa      	ldr	r2, [r7, #12]
 8026e3c:	68bb      	ldr	r3, [r7, #8]
 8026e3e:	429a      	cmp	r2, r3
 8026e40:	dbee      	blt.n	8026e20 <fp_copy+0x54>
        b->used = a->used;
        b->sign = a->sign;
        XMEMCPY(b->dp, a->dp, FP_SIZE * sizeof(fp_digit));
#endif
    }
}
 8026e42:	bf00      	nop
 8026e44:	3710      	adds	r7, #16
 8026e46:	46bd      	mov	sp, r7
 8026e48:	bd80      	pop	{r7, pc}

08026e4a <fp_init_copy>:
    return MP_OKAY;
}

/* Copy (dst = a) from (src = b) */
void fp_init_copy(fp_int *a, fp_int* b)
{
 8026e4a:	b580      	push	{r7, lr}
 8026e4c:	b082      	sub	sp, #8
 8026e4e:	af00      	add	r7, sp, #0
 8026e50:	6078      	str	r0, [r7, #4]
 8026e52:	6039      	str	r1, [r7, #0]
    if (a != b) {
 8026e54:	687a      	ldr	r2, [r7, #4]
 8026e56:	683b      	ldr	r3, [r7, #0]
 8026e58:	429a      	cmp	r2, r3
 8026e5a:	d006      	beq.n	8026e6a <fp_init_copy+0x20>
        fp_init(a);
 8026e5c:	6878      	ldr	r0, [r7, #4]
 8026e5e:	f7ff fdcb 	bl	80269f8 <fp_init>
        /* Note reversed parameter order! */
        fp_copy(b, a); /* copy (src = b) to (dst = a) */
 8026e62:	6879      	ldr	r1, [r7, #4]
 8026e64:	6838      	ldr	r0, [r7, #0]
 8026e66:	f7ff ffb1 	bl	8026dcc <fp_copy>
    }
}
 8026e6a:	bf00      	nop
 8026e6c:	3708      	adds	r7, #8
 8026e6e:	46bd      	mov	sp, r7
 8026e70:	bd80      	pop	{r7, pc}

08026e72 <mp_copy>:

/* fast math wrappers */
int mp_copy(const fp_int* a, fp_int* b)
{
 8026e72:	b580      	push	{r7, lr}
 8026e74:	b082      	sub	sp, #8
 8026e76:	af00      	add	r7, sp, #0
 8026e78:	6078      	str	r0, [r7, #4]
 8026e7a:	6039      	str	r1, [r7, #0]
    fp_copy(a, b);
 8026e7c:	6839      	ldr	r1, [r7, #0]
 8026e7e:	6878      	ldr	r0, [r7, #4]
 8026e80:	f7ff ffa4 	bl	8026dcc <fp_copy>
    return MP_OKAY;
 8026e84:	2300      	movs	r3, #0
}
 8026e86:	4618      	mov	r0, r3
 8026e88:	3708      	adds	r7, #8
 8026e8a:	46bd      	mov	sp, r7
 8026e8c:	bd80      	pop	{r7, pc}

08026e8e <mp_iszero>:
{
    return fp_isodd(a);
}

int mp_iszero(const mp_int* a)
{
 8026e8e:	b480      	push	{r7}
 8026e90:	b083      	sub	sp, #12
 8026e92:	af00      	add	r7, sp, #0
 8026e94:	6078      	str	r0, [r7, #4]
    return fp_iszero(a);
 8026e96:	687b      	ldr	r3, [r7, #4]
 8026e98:	681b      	ldr	r3, [r3, #0]
 8026e9a:	2b00      	cmp	r3, #0
 8026e9c:	bf0c      	ite	eq
 8026e9e:	2301      	moveq	r3, #1
 8026ea0:	2300      	movne	r3, #0
 8026ea2:	b2db      	uxtb	r3, r3
}
 8026ea4:	4618      	mov	r0, r3
 8026ea6:	370c      	adds	r7, #12
 8026ea8:	46bd      	mov	sp, r7
 8026eaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026eae:	4770      	bx	lr

08026eb0 <mp_count_bits>:

int mp_count_bits (const mp_int* a)
{
 8026eb0:	b580      	push	{r7, lr}
 8026eb2:	b082      	sub	sp, #8
 8026eb4:	af00      	add	r7, sp, #0
 8026eb6:	6078      	str	r0, [r7, #4]
    return fp_count_bits(a);
 8026eb8:	6878      	ldr	r0, [r7, #4]
 8026eba:	f7ff fbb1 	bl	8026620 <fp_count_bits>
 8026ebe:	4603      	mov	r3, r0
}
 8026ec0:	4618      	mov	r0, r3
 8026ec2:	3708      	adds	r7, #8
 8026ec4:	46bd      	mov	sp, r7
 8026ec6:	bd80      	pop	{r7, pc}

08026ec8 <mp_leading_bit>:

int mp_leading_bit (mp_int* a)
{
 8026ec8:	b580      	push	{r7, lr}
 8026eca:	b082      	sub	sp, #8
 8026ecc:	af00      	add	r7, sp, #0
 8026ece:	6078      	str	r0, [r7, #4]
    return fp_leading_bit(a);
 8026ed0:	6878      	ldr	r0, [r7, #4]
 8026ed2:	f7ff fbce 	bl	8026672 <fp_leading_bit>
 8026ed6:	4603      	mov	r3, r0
}
 8026ed8:	4618      	mov	r0, r3
 8026eda:	3708      	adds	r7, #8
 8026edc:	46bd      	mov	sp, r7
 8026ede:	bd80      	pop	{r7, pc}

08026ee0 <mp_rshb>:

void mp_rshb (mp_int* a, int x)
{
 8026ee0:	b580      	push	{r7, lr}
 8026ee2:	b082      	sub	sp, #8
 8026ee4:	af00      	add	r7, sp, #0
 8026ee6:	6078      	str	r0, [r7, #4]
 8026ee8:	6039      	str	r1, [r7, #0]
    fp_rshb(a, x);
 8026eea:	6839      	ldr	r1, [r7, #0]
 8026eec:	6878      	ldr	r0, [r7, #4]
 8026eee:	f7ff fc54 	bl	802679a <fp_rshb>
}
 8026ef2:	bf00      	nop
 8026ef4:	3708      	adds	r7, #8
 8026ef6:	46bd      	mov	sp, r7
 8026ef8:	bd80      	pop	{r7, pc}

08026efa <mp_montgomery_calc_normalization>:
    return fp_sqrmod(a, b, c);
}

/* fast math conversion */
int mp_montgomery_calc_normalization(mp_int *a, mp_int *b)
{
 8026efa:	b580      	push	{r7, lr}
 8026efc:	b082      	sub	sp, #8
 8026efe:	af00      	add	r7, sp, #0
 8026f00:	6078      	str	r0, [r7, #4]
 8026f02:	6039      	str	r1, [r7, #0]
    return fp_montgomery_calc_normalization(a, b);
 8026f04:	6839      	ldr	r1, [r7, #0]
 8026f06:	6878      	ldr	r0, [r7, #4]
 8026f08:	f7ff f84b 	bl	8025fa2 <fp_montgomery_calc_normalization>
 8026f0c:	4603      	mov	r3, r0
}
 8026f0e:	4618      	mov	r0, r3
 8026f10:	3708      	adds	r7, #8
 8026f12:	46bd      	mov	sp, r7
 8026f14:	bd80      	pop	{r7, pc}

08026f16 <fp_cond_swap_ct_ex>:

#endif /* WOLFSSL_KEY_GEN || HAVE_ECC */

static int fp_cond_swap_ct_ex(mp_int* a, mp_int* b, int c, int m, mp_int* t)
{
 8026f16:	b480      	push	{r7}
 8026f18:	b087      	sub	sp, #28
 8026f1a:	af00      	add	r7, sp, #0
 8026f1c:	60f8      	str	r0, [r7, #12]
 8026f1e:	60b9      	str	r1, [r7, #8]
 8026f20:	607a      	str	r2, [r7, #4]
 8026f22:	603b      	str	r3, [r7, #0]
    int i;
    mp_digit mask = (mp_digit)0 - m;
 8026f24:	683b      	ldr	r3, [r7, #0]
 8026f26:	425b      	negs	r3, r3
 8026f28:	613b      	str	r3, [r7, #16]

    t->used = (a->used ^ b->used) & mask;
 8026f2a:	68fb      	ldr	r3, [r7, #12]
 8026f2c:	681a      	ldr	r2, [r3, #0]
 8026f2e:	68bb      	ldr	r3, [r7, #8]
 8026f30:	681b      	ldr	r3, [r3, #0]
 8026f32:	4053      	eors	r3, r2
 8026f34:	461a      	mov	r2, r3
 8026f36:	693b      	ldr	r3, [r7, #16]
 8026f38:	4013      	ands	r3, r2
 8026f3a:	461a      	mov	r2, r3
 8026f3c:	6a3b      	ldr	r3, [r7, #32]
 8026f3e:	601a      	str	r2, [r3, #0]
    for (i = 0; i < c; i++) {
 8026f40:	2300      	movs	r3, #0
 8026f42:	617b      	str	r3, [r7, #20]
 8026f44:	e017      	b.n	8026f76 <fp_cond_swap_ct_ex+0x60>
        t->dp[i] = (a->dp[i] ^ b->dp[i]) & mask;
 8026f46:	68fa      	ldr	r2, [r7, #12]
 8026f48:	697b      	ldr	r3, [r7, #20]
 8026f4a:	3302      	adds	r3, #2
 8026f4c:	009b      	lsls	r3, r3, #2
 8026f4e:	4413      	add	r3, r2
 8026f50:	685a      	ldr	r2, [r3, #4]
 8026f52:	68b9      	ldr	r1, [r7, #8]
 8026f54:	697b      	ldr	r3, [r7, #20]
 8026f56:	3302      	adds	r3, #2
 8026f58:	009b      	lsls	r3, r3, #2
 8026f5a:	440b      	add	r3, r1
 8026f5c:	685b      	ldr	r3, [r3, #4]
 8026f5e:	405a      	eors	r2, r3
 8026f60:	693b      	ldr	r3, [r7, #16]
 8026f62:	401a      	ands	r2, r3
 8026f64:	6a39      	ldr	r1, [r7, #32]
 8026f66:	697b      	ldr	r3, [r7, #20]
 8026f68:	3302      	adds	r3, #2
 8026f6a:	009b      	lsls	r3, r3, #2
 8026f6c:	440b      	add	r3, r1
 8026f6e:	605a      	str	r2, [r3, #4]
    for (i = 0; i < c; i++) {
 8026f70:	697b      	ldr	r3, [r7, #20]
 8026f72:	3301      	adds	r3, #1
 8026f74:	617b      	str	r3, [r7, #20]
 8026f76:	697a      	ldr	r2, [r7, #20]
 8026f78:	687b      	ldr	r3, [r7, #4]
 8026f7a:	429a      	cmp	r2, r3
 8026f7c:	dbe3      	blt.n	8026f46 <fp_cond_swap_ct_ex+0x30>
    }
    a->used ^= t->used;
 8026f7e:	68fb      	ldr	r3, [r7, #12]
 8026f80:	681a      	ldr	r2, [r3, #0]
 8026f82:	6a3b      	ldr	r3, [r7, #32]
 8026f84:	681b      	ldr	r3, [r3, #0]
 8026f86:	405a      	eors	r2, r3
 8026f88:	68fb      	ldr	r3, [r7, #12]
 8026f8a:	601a      	str	r2, [r3, #0]
    for (i = 0; i < c; i++) {
 8026f8c:	2300      	movs	r3, #0
 8026f8e:	617b      	str	r3, [r7, #20]
 8026f90:	e015      	b.n	8026fbe <fp_cond_swap_ct_ex+0xa8>
        a->dp[i] ^= t->dp[i];
 8026f92:	68fa      	ldr	r2, [r7, #12]
 8026f94:	697b      	ldr	r3, [r7, #20]
 8026f96:	3302      	adds	r3, #2
 8026f98:	009b      	lsls	r3, r3, #2
 8026f9a:	4413      	add	r3, r2
 8026f9c:	685a      	ldr	r2, [r3, #4]
 8026f9e:	6a39      	ldr	r1, [r7, #32]
 8026fa0:	697b      	ldr	r3, [r7, #20]
 8026fa2:	3302      	adds	r3, #2
 8026fa4:	009b      	lsls	r3, r3, #2
 8026fa6:	440b      	add	r3, r1
 8026fa8:	685b      	ldr	r3, [r3, #4]
 8026faa:	405a      	eors	r2, r3
 8026fac:	68f9      	ldr	r1, [r7, #12]
 8026fae:	697b      	ldr	r3, [r7, #20]
 8026fb0:	3302      	adds	r3, #2
 8026fb2:	009b      	lsls	r3, r3, #2
 8026fb4:	440b      	add	r3, r1
 8026fb6:	605a      	str	r2, [r3, #4]
    for (i = 0; i < c; i++) {
 8026fb8:	697b      	ldr	r3, [r7, #20]
 8026fba:	3301      	adds	r3, #1
 8026fbc:	617b      	str	r3, [r7, #20]
 8026fbe:	697a      	ldr	r2, [r7, #20]
 8026fc0:	687b      	ldr	r3, [r7, #4]
 8026fc2:	429a      	cmp	r2, r3
 8026fc4:	dbe5      	blt.n	8026f92 <fp_cond_swap_ct_ex+0x7c>
    }
    b->used ^= t->used;
 8026fc6:	68bb      	ldr	r3, [r7, #8]
 8026fc8:	681a      	ldr	r2, [r3, #0]
 8026fca:	6a3b      	ldr	r3, [r7, #32]
 8026fcc:	681b      	ldr	r3, [r3, #0]
 8026fce:	405a      	eors	r2, r3
 8026fd0:	68bb      	ldr	r3, [r7, #8]
 8026fd2:	601a      	str	r2, [r3, #0]
    for (i = 0; i < c; i++) {
 8026fd4:	2300      	movs	r3, #0
 8026fd6:	617b      	str	r3, [r7, #20]
 8026fd8:	e015      	b.n	8027006 <fp_cond_swap_ct_ex+0xf0>
        b->dp[i] ^= t->dp[i];
 8026fda:	68ba      	ldr	r2, [r7, #8]
 8026fdc:	697b      	ldr	r3, [r7, #20]
 8026fde:	3302      	adds	r3, #2
 8026fe0:	009b      	lsls	r3, r3, #2
 8026fe2:	4413      	add	r3, r2
 8026fe4:	685a      	ldr	r2, [r3, #4]
 8026fe6:	6a39      	ldr	r1, [r7, #32]
 8026fe8:	697b      	ldr	r3, [r7, #20]
 8026fea:	3302      	adds	r3, #2
 8026fec:	009b      	lsls	r3, r3, #2
 8026fee:	440b      	add	r3, r1
 8026ff0:	685b      	ldr	r3, [r3, #4]
 8026ff2:	405a      	eors	r2, r3
 8026ff4:	68b9      	ldr	r1, [r7, #8]
 8026ff6:	697b      	ldr	r3, [r7, #20]
 8026ff8:	3302      	adds	r3, #2
 8026ffa:	009b      	lsls	r3, r3, #2
 8026ffc:	440b      	add	r3, r1
 8026ffe:	605a      	str	r2, [r3, #4]
    for (i = 0; i < c; i++) {
 8027000:	697b      	ldr	r3, [r7, #20]
 8027002:	3301      	adds	r3, #1
 8027004:	617b      	str	r3, [r7, #20]
 8027006:	697a      	ldr	r2, [r7, #20]
 8027008:	687b      	ldr	r3, [r7, #4]
 802700a:	429a      	cmp	r2, r3
 802700c:	dbe5      	blt.n	8026fda <fp_cond_swap_ct_ex+0xc4>
    }

    return FP_OKAY;
 802700e:	2300      	movs	r3, #0
}
 8027010:	4618      	mov	r0, r3
 8027012:	371c      	adds	r7, #28
 8027014:	46bd      	mov	sp, r7
 8027016:	f85d 7b04 	ldr.w	r7, [sp], #4
 802701a:	4770      	bx	lr

0802701c <mp_cond_swap_ct_ex>:
}
#endif /* !NO_RSA || !NO_DSA || !NO_DH || WOLFSSL_KEY_GEN */


int mp_cond_swap_ct_ex(mp_int* a, mp_int* b, int c, int m, mp_int* t)
{
 802701c:	b580      	push	{r7, lr}
 802701e:	b086      	sub	sp, #24
 8027020:	af02      	add	r7, sp, #8
 8027022:	60f8      	str	r0, [r7, #12]
 8027024:	60b9      	str	r1, [r7, #8]
 8027026:	607a      	str	r2, [r7, #4]
 8027028:	603b      	str	r3, [r7, #0]
    return fp_cond_swap_ct_ex(a, b, c, m, t);
 802702a:	69bb      	ldr	r3, [r7, #24]
 802702c:	9300      	str	r3, [sp, #0]
 802702e:	683b      	ldr	r3, [r7, #0]
 8027030:	687a      	ldr	r2, [r7, #4]
 8027032:	68b9      	ldr	r1, [r7, #8]
 8027034:	68f8      	ldr	r0, [r7, #12]
 8027036:	f7ff ff6e 	bl	8026f16 <fp_cond_swap_ct_ex>
 802703a:	4603      	mov	r3, r0
}
 802703c:	4618      	mov	r0, r3
 802703e:	3710      	adds	r7, #16
 8027040:	46bd      	mov	sp, r7
 8027042:	bd80      	pop	{r7, pc}

08027044 <fp_add_d>:
#if defined(HAVE_ECC) || !defined(NO_PWDBASED) || defined(OPENSSL_EXTRA) || \
    defined(WC_RSA_BLINDING) || !defined(NO_DSA) || \
    (!defined(NO_RSA) && !defined(NO_RSA_BOUNDS_CHECK))
/* c = a + b */
int fp_add_d(fp_int *a, fp_digit b, fp_int *c)
{
 8027044:	b580      	push	{r7, lr}
 8027046:	b088      	sub	sp, #32
 8027048:	af00      	add	r7, sp, #0
 802704a:	60f8      	str	r0, [r7, #12]
 802704c:	60b9      	str	r1, [r7, #8]
 802704e:	607a      	str	r2, [r7, #4]
   fp_int* tmp;
#endif
   int     err;

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8027050:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8027054:	f7f7 fe12 	bl	801ec7c <wolfSSL_Malloc>
 8027058:	61f8      	str	r0, [r7, #28]
   if (tmp == NULL)
 802705a:	69fb      	ldr	r3, [r7, #28]
 802705c:	2b00      	cmp	r3, #0
 802705e:	d102      	bne.n	8027066 <fp_add_d+0x22>
       return FP_MEM;
 8027060:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8027064:	e015      	b.n	8027092 <fp_add_d+0x4e>
#endif

   fp_init(tmp);
 8027066:	69f8      	ldr	r0, [r7, #28]
 8027068:	f7ff fcc6 	bl	80269f8 <fp_init>
   fp_set(tmp, b);
 802706c:	68b9      	ldr	r1, [r7, #8]
 802706e:	69f8      	ldr	r0, [r7, #28]
 8027070:	f7ff fa93 	bl	802659a <fp_set>
   err = fp_add(a, tmp, c);
 8027074:	687a      	ldr	r2, [r7, #4]
 8027076:	69f9      	ldr	r1, [r7, #28]
 8027078:	68f8      	ldr	r0, [r7, #12]
 802707a:	f7fb face 	bl	802261a <fp_add>
 802707e:	61b8      	str	r0, [r7, #24]

#ifdef WOLFSSL_SMALL_STACK
   XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8027080:	69fb      	ldr	r3, [r7, #28]
 8027082:	617b      	str	r3, [r7, #20]
 8027084:	697b      	ldr	r3, [r7, #20]
 8027086:	2b00      	cmp	r3, #0
 8027088:	d002      	beq.n	8027090 <fp_add_d+0x4c>
 802708a:	6978      	ldr	r0, [r7, #20]
 802708c:	f7f7 fe12 	bl	801ecb4 <wolfSSL_Free>
#endif
   return err;
 8027090:	69bb      	ldr	r3, [r7, #24]
}
 8027092:	4618      	mov	r0, r3
 8027094:	3720      	adds	r7, #32
 8027096:	46bd      	mov	sp, r7
 8027098:	bd80      	pop	{r7, pc}

0802709a <mp_add_d>:

/* external compatibility */
int mp_add_d(fp_int *a, fp_digit b, fp_int *c)
{
 802709a:	b580      	push	{r7, lr}
 802709c:	b084      	sub	sp, #16
 802709e:	af00      	add	r7, sp, #0
 80270a0:	60f8      	str	r0, [r7, #12]
 80270a2:	60b9      	str	r1, [r7, #8]
 80270a4:	607a      	str	r2, [r7, #4]
    return fp_add_d(a, b, c);
 80270a6:	687a      	ldr	r2, [r7, #4]
 80270a8:	68b9      	ldr	r1, [r7, #8]
 80270aa:	68f8      	ldr	r0, [r7, #12]
 80270ac:	f7ff ffca 	bl	8027044 <fp_add_d>
 80270b0:	4603      	mov	r3, r0
}
 80270b2:	4618      	mov	r0, r3
 80270b4:	3710      	adds	r7, #16
 80270b6:	46bd      	mov	sp, r7
 80270b8:	bd80      	pop	{r7, pc}

080270ba <fp_read_radix_16>:
#endif

#if defined(OPENSSL_EXTRA) || !defined(NO_DSA) || defined(HAVE_ECC)
#if DIGIT_BIT == 64 || DIGIT_BIT == 32
static int fp_read_radix_16(fp_int *a, const char *str)
{
 80270ba:	b580      	push	{r7, lr}
 80270bc:	b088      	sub	sp, #32
 80270be:	af00      	add	r7, sp, #0
 80270c0:	6078      	str	r0, [r7, #4]
 80270c2:	6039      	str	r1, [r7, #0]
  int     i, j, k, neg;
  int     ch;
  /* Skip whitespace at end of line */
  int     eol_done = 0;
 80270c4:	2300      	movs	r3, #0
 80270c6:	60fb      	str	r3, [r7, #12]

  /* if the leading digit is a
   * minus set the sign to negative.
   */
  if (*str == '-') {
 80270c8:	683b      	ldr	r3, [r7, #0]
 80270ca:	781b      	ldrb	r3, [r3, #0]
 80270cc:	2b2d      	cmp	r3, #45	@ 0x2d
 80270ce:	d105      	bne.n	80270dc <fp_read_radix_16+0x22>
    ++str;
 80270d0:	683b      	ldr	r3, [r7, #0]
 80270d2:	3301      	adds	r3, #1
 80270d4:	603b      	str	r3, [r7, #0]
    neg = FP_NEG;
 80270d6:	2301      	movs	r3, #1
 80270d8:	613b      	str	r3, [r7, #16]
 80270da:	e001      	b.n	80270e0 <fp_read_radix_16+0x26>
  } else {
    neg = FP_ZPOS;
 80270dc:	2300      	movs	r3, #0
 80270de:	613b      	str	r3, [r7, #16]
  }

  j = 0;
 80270e0:	2300      	movs	r3, #0
 80270e2:	61bb      	str	r3, [r7, #24]
  k = 0;
 80270e4:	2300      	movs	r3, #0
 80270e6:	617b      	str	r3, [r7, #20]
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
 80270e8:	6838      	ldr	r0, [r7, #0]
 80270ea:	f7d9 f87b 	bl	80001e4 <strlen>
 80270ee:	4603      	mov	r3, r0
 80270f0:	3b01      	subs	r3, #1
 80270f2:	61fb      	str	r3, [r7, #28]
 80270f4:	e04a      	b.n	802718c <fp_read_radix_16+0xd2>
      ch = (int)HexCharToByte(str[i]);
 80270f6:	69fb      	ldr	r3, [r7, #28]
 80270f8:	683a      	ldr	r2, [r7, #0]
 80270fa:	4413      	add	r3, r2
 80270fc:	781b      	ldrb	r3, [r3, #0]
 80270fe:	4618      	mov	r0, r3
 8027100:	f7fb fa3d 	bl	802257e <HexCharToByte>
 8027104:	4603      	mov	r3, r0
 8027106:	60bb      	str	r3, [r7, #8]
      if (ch < 0) {
 8027108:	68bb      	ldr	r3, [r7, #8]
 802710a:	2b00      	cmp	r3, #0
 802710c:	da0f      	bge.n	802712e <fp_read_radix_16+0x74>
        if (!eol_done && CharIsWhiteSpace(str[i]))
 802710e:	68fb      	ldr	r3, [r7, #12]
 8027110:	2b00      	cmp	r3, #0
 8027112:	d109      	bne.n	8027128 <fp_read_radix_16+0x6e>
 8027114:	69fb      	ldr	r3, [r7, #28]
 8027116:	683a      	ldr	r2, [r7, #0]
 8027118:	4413      	add	r3, r2
 802711a:	781b      	ldrb	r3, [r3, #0]
 802711c:	4618      	mov	r0, r3
 802711e:	f7fb fa66 	bl	80225ee <CharIsWhiteSpace>
 8027122:	4603      	mov	r3, r0
 8027124:	2b00      	cmp	r3, #0
 8027126:	d12d      	bne.n	8027184 <fp_read_radix_16+0xca>
          continue;
        return FP_VAL;
 8027128:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802712c:	e05b      	b.n	80271e6 <fp_read_radix_16+0x12c>
      }
      eol_done = 1;
 802712e:	2301      	movs	r3, #1
 8027130:	60fb      	str	r3, [r7, #12]

      k += j == DIGIT_BIT;
 8027132:	69bb      	ldr	r3, [r7, #24]
 8027134:	2b20      	cmp	r3, #32
 8027136:	bf0c      	ite	eq
 8027138:	2301      	moveq	r3, #1
 802713a:	2300      	movne	r3, #0
 802713c:	b2db      	uxtb	r3, r3
 802713e:	461a      	mov	r2, r3
 8027140:	697b      	ldr	r3, [r7, #20]
 8027142:	4413      	add	r3, r2
 8027144:	617b      	str	r3, [r7, #20]
      j &= DIGIT_BIT - 1;
 8027146:	69bb      	ldr	r3, [r7, #24]
 8027148:	f003 031f 	and.w	r3, r3, #31
 802714c:	61bb      	str	r3, [r7, #24]
      if (k >= FP_SIZE)
 802714e:	697b      	ldr	r3, [r7, #20]
 8027150:	2b87      	cmp	r3, #135	@ 0x87
 8027152:	dd02      	ble.n	802715a <fp_read_radix_16+0xa0>
          return FP_VAL;
 8027154:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8027158:	e045      	b.n	80271e6 <fp_read_radix_16+0x12c>

      a->dp[k] |= ((fp_digit)ch) << j;
 802715a:	687a      	ldr	r2, [r7, #4]
 802715c:	697b      	ldr	r3, [r7, #20]
 802715e:	3302      	adds	r3, #2
 8027160:	009b      	lsls	r3, r3, #2
 8027162:	4413      	add	r3, r2
 8027164:	685a      	ldr	r2, [r3, #4]
 8027166:	68b9      	ldr	r1, [r7, #8]
 8027168:	69bb      	ldr	r3, [r7, #24]
 802716a:	fa01 f303 	lsl.w	r3, r1, r3
 802716e:	431a      	orrs	r2, r3
 8027170:	6879      	ldr	r1, [r7, #4]
 8027172:	697b      	ldr	r3, [r7, #20]
 8027174:	3302      	adds	r3, #2
 8027176:	009b      	lsls	r3, r3, #2
 8027178:	440b      	add	r3, r1
 802717a:	605a      	str	r2, [r3, #4]
      j += 4;
 802717c:	69bb      	ldr	r3, [r7, #24]
 802717e:	3304      	adds	r3, #4
 8027180:	61bb      	str	r3, [r7, #24]
 8027182:	e000      	b.n	8027186 <fp_read_radix_16+0xcc>
          continue;
 8027184:	bf00      	nop
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
 8027186:	69fb      	ldr	r3, [r7, #28]
 8027188:	3b01      	subs	r3, #1
 802718a:	61fb      	str	r3, [r7, #28]
 802718c:	69fb      	ldr	r3, [r7, #28]
 802718e:	2b00      	cmp	r3, #0
 8027190:	dab1      	bge.n	80270f6 <fp_read_radix_16+0x3c>
  }

  a->used = k + 1;
 8027192:	697b      	ldr	r3, [r7, #20]
 8027194:	1c5a      	adds	r2, r3, #1
 8027196:	687b      	ldr	r3, [r7, #4]
 8027198:	601a      	str	r2, [r3, #0]
  fp_clamp(a);
 802719a:	e004      	b.n	80271a6 <fp_read_radix_16+0xec>
 802719c:	687b      	ldr	r3, [r7, #4]
 802719e:	681b      	ldr	r3, [r3, #0]
 80271a0:	1e5a      	subs	r2, r3, #1
 80271a2:	687b      	ldr	r3, [r7, #4]
 80271a4:	601a      	str	r2, [r3, #0]
 80271a6:	687b      	ldr	r3, [r7, #4]
 80271a8:	681b      	ldr	r3, [r3, #0]
 80271aa:	2b00      	cmp	r3, #0
 80271ac:	d009      	beq.n	80271c2 <fp_read_radix_16+0x108>
 80271ae:	687b      	ldr	r3, [r7, #4]
 80271b0:	681b      	ldr	r3, [r3, #0]
 80271b2:	3b01      	subs	r3, #1
 80271b4:	687a      	ldr	r2, [r7, #4]
 80271b6:	3302      	adds	r3, #2
 80271b8:	009b      	lsls	r3, r3, #2
 80271ba:	4413      	add	r3, r2
 80271bc:	685b      	ldr	r3, [r3, #4]
 80271be:	2b00      	cmp	r3, #0
 80271c0:	d0ec      	beq.n	802719c <fp_read_radix_16+0xe2>
 80271c2:	687b      	ldr	r3, [r7, #4]
 80271c4:	681b      	ldr	r3, [r3, #0]
 80271c6:	2b00      	cmp	r3, #0
 80271c8:	d002      	beq.n	80271d0 <fp_read_radix_16+0x116>
 80271ca:	687b      	ldr	r3, [r7, #4]
 80271cc:	685b      	ldr	r3, [r3, #4]
 80271ce:	e000      	b.n	80271d2 <fp_read_radix_16+0x118>
 80271d0:	2300      	movs	r3, #0
 80271d2:	687a      	ldr	r2, [r7, #4]
 80271d4:	6053      	str	r3, [r2, #4]
  /* set the sign only if a != 0 */
  if (fp_iszero(a) != FP_YES) {
 80271d6:	687b      	ldr	r3, [r7, #4]
 80271d8:	681b      	ldr	r3, [r3, #0]
 80271da:	2b00      	cmp	r3, #0
 80271dc:	d002      	beq.n	80271e4 <fp_read_radix_16+0x12a>
     a->sign = neg;
 80271de:	687b      	ldr	r3, [r7, #4]
 80271e0:	693a      	ldr	r2, [r7, #16]
 80271e2:	605a      	str	r2, [r3, #4]
  }
  return FP_OKAY;
 80271e4:	2300      	movs	r3, #0
}
 80271e6:	4618      	mov	r0, r3
 80271e8:	3720      	adds	r7, #32
 80271ea:	46bd      	mov	sp, r7
 80271ec:	bd80      	pop	{r7, pc}
	...

080271f0 <fp_read_radix>:
#endif

static int fp_read_radix(fp_int *a, const char *str, int radix)
{
 80271f0:	b580      	push	{r7, lr}
 80271f2:	b088      	sub	sp, #32
 80271f4:	af00      	add	r7, sp, #0
 80271f6:	60f8      	str	r0, [r7, #12]
 80271f8:	60b9      	str	r1, [r7, #8]
 80271fa:	607a      	str	r2, [r7, #4]
  int     y, neg;
  char    ch;

  /* set the integer to the default of zero */
  fp_zero (a);
 80271fc:	68f8      	ldr	r0, [r7, #12]
 80271fe:	f7ff fc09 	bl	8026a14 <fp_zero>

#if DIGIT_BIT == 64 || DIGIT_BIT == 32
  if (radix == 16)
 8027202:	687b      	ldr	r3, [r7, #4]
 8027204:	2b10      	cmp	r3, #16
 8027206:	d105      	bne.n	8027214 <fp_read_radix+0x24>
      return fp_read_radix_16(a, str);
 8027208:	68b9      	ldr	r1, [r7, #8]
 802720a:	68f8      	ldr	r0, [r7, #12]
 802720c:	f7ff ff55 	bl	80270ba <fp_read_radix_16>
 8027210:	4603      	mov	r3, r0
 8027212:	e085      	b.n	8027320 <fp_read_radix+0x130>
#endif

  /* make sure the radix is ok */
  if (radix < 2 || radix > 64) {
 8027214:	687b      	ldr	r3, [r7, #4]
 8027216:	2b01      	cmp	r3, #1
 8027218:	dd02      	ble.n	8027220 <fp_read_radix+0x30>
 802721a:	687b      	ldr	r3, [r7, #4]
 802721c:	2b40      	cmp	r3, #64	@ 0x40
 802721e:	dd02      	ble.n	8027226 <fp_read_radix+0x36>
    return FP_VAL;
 8027220:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8027224:	e07c      	b.n	8027320 <fp_read_radix+0x130>
  }

  /* if the leading digit is a
   * minus set the sign to negative.
   */
  if (*str == '-') {
 8027226:	68bb      	ldr	r3, [r7, #8]
 8027228:	781b      	ldrb	r3, [r3, #0]
 802722a:	2b2d      	cmp	r3, #45	@ 0x2d
 802722c:	d105      	bne.n	802723a <fp_read_radix+0x4a>
    ++str;
 802722e:	68bb      	ldr	r3, [r7, #8]
 8027230:	3301      	adds	r3, #1
 8027232:	60bb      	str	r3, [r7, #8]
    neg = FP_NEG;
 8027234:	2301      	movs	r3, #1
 8027236:	61bb      	str	r3, [r7, #24]
 8027238:	e062      	b.n	8027300 <fp_read_radix+0x110>
  } else {
    neg = FP_ZPOS;
 802723a:	2300      	movs	r3, #0
 802723c:	61bb      	str	r3, [r7, #24]
  }

  /* process each digit of the string */
  while (*str) {
 802723e:	e05f      	b.n	8027300 <fp_read_radix+0x110>
    /* if the radix <= 36 the conversion is case insensitive
     * this allows numbers like 1AB and 1ab to represent the same  value
     * [e.g. in hex]
     */
    ch = (char)((radix <= 36) ? XTOUPPER((unsigned char)*str) : *str);
 8027240:	687b      	ldr	r3, [r7, #4]
 8027242:	2b24      	cmp	r3, #36	@ 0x24
 8027244:	dc11      	bgt.n	802726a <fp_read_radix+0x7a>
 8027246:	68bb      	ldr	r3, [r7, #8]
 8027248:	781b      	ldrb	r3, [r3, #0]
 802724a:	75fb      	strb	r3, [r7, #23]
 802724c:	7dfb      	ldrb	r3, [r7, #23]
 802724e:	3301      	adds	r3, #1
 8027250:	4a35      	ldr	r2, [pc, #212]	@ (8027328 <fp_read_radix+0x138>)
 8027252:	4413      	add	r3, r2
 8027254:	781b      	ldrb	r3, [r3, #0]
 8027256:	f003 0303 	and.w	r3, r3, #3
 802725a:	2b02      	cmp	r3, #2
 802725c:	d102      	bne.n	8027264 <fp_read_radix+0x74>
 802725e:	7dfb      	ldrb	r3, [r7, #23]
 8027260:	3b20      	subs	r3, #32
 8027262:	e000      	b.n	8027266 <fp_read_radix+0x76>
 8027264:	7dfb      	ldrb	r3, [r7, #23]
 8027266:	b2db      	uxtb	r3, r3
 8027268:	e001      	b.n	802726e <fp_read_radix+0x7e>
 802726a:	68bb      	ldr	r3, [r7, #8]
 802726c:	781b      	ldrb	r3, [r3, #0]
 802726e:	75bb      	strb	r3, [r7, #22]
    for (y = 0; y < 64; y++) {
 8027270:	2300      	movs	r3, #0
 8027272:	61fb      	str	r3, [r7, #28]
 8027274:	e009      	b.n	802728a <fp_read_radix+0x9a>
      if (ch == fp_s_rmap[y]) {
 8027276:	4a2d      	ldr	r2, [pc, #180]	@ (802732c <fp_read_radix+0x13c>)
 8027278:	69fb      	ldr	r3, [r7, #28]
 802727a:	4413      	add	r3, r2
 802727c:	781b      	ldrb	r3, [r3, #0]
 802727e:	7dba      	ldrb	r2, [r7, #22]
 8027280:	429a      	cmp	r2, r3
 8027282:	d006      	beq.n	8027292 <fp_read_radix+0xa2>
    for (y = 0; y < 64; y++) {
 8027284:	69fb      	ldr	r3, [r7, #28]
 8027286:	3301      	adds	r3, #1
 8027288:	61fb      	str	r3, [r7, #28]
 802728a:	69fb      	ldr	r3, [r7, #28]
 802728c:	2b3f      	cmp	r3, #63	@ 0x3f
 802728e:	ddf2      	ble.n	8027276 <fp_read_radix+0x86>
 8027290:	e000      	b.n	8027294 <fp_read_radix+0xa4>
         break;
 8027292:	bf00      	nop
      }
    }
    if (y >= radix) {
 8027294:	69fa      	ldr	r2, [r7, #28]
 8027296:	687b      	ldr	r3, [r7, #4]
 8027298:	429a      	cmp	r2, r3
 802729a:	db12      	blt.n	80272c2 <fp_read_radix+0xd2>
      /* Check if whitespace at end of line */
      while (CharIsWhiteSpace(*str))
 802729c:	e002      	b.n	80272a4 <fp_read_radix+0xb4>
        ++str;
 802729e:	68bb      	ldr	r3, [r7, #8]
 80272a0:	3301      	adds	r3, #1
 80272a2:	60bb      	str	r3, [r7, #8]
      while (CharIsWhiteSpace(*str))
 80272a4:	68bb      	ldr	r3, [r7, #8]
 80272a6:	781b      	ldrb	r3, [r3, #0]
 80272a8:	4618      	mov	r0, r3
 80272aa:	f7fb f9a0 	bl	80225ee <CharIsWhiteSpace>
 80272ae:	4603      	mov	r3, r0
 80272b0:	2b00      	cmp	r3, #0
 80272b2:	d1f4      	bne.n	802729e <fp_read_radix+0xae>
      if (*str)
 80272b4:	68bb      	ldr	r3, [r7, #8]
 80272b6:	781b      	ldrb	r3, [r3, #0]
 80272b8:	2b00      	cmp	r3, #0
 80272ba:	d026      	beq.n	802730a <fp_read_radix+0x11a>
        return FP_VAL;
 80272bc:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80272c0:	e02e      	b.n	8027320 <fp_read_radix+0x130>

    /* if the char was found in the map
     * and is less than the given radix add it
     * to the number, otherwise exit the loop.
     */
    if (y < radix) {
 80272c2:	69fa      	ldr	r2, [r7, #28]
 80272c4:	687b      	ldr	r3, [r7, #4]
 80272c6:	429a      	cmp	r2, r3
 80272c8:	da21      	bge.n	802730e <fp_read_radix+0x11e>
      int ret = fp_mul_d (a, (fp_digit) radix, a);
 80272ca:	687b      	ldr	r3, [r7, #4]
 80272cc:	68fa      	ldr	r2, [r7, #12]
 80272ce:	4619      	mov	r1, r3
 80272d0:	68f8      	ldr	r0, [r7, #12]
 80272d2:	f7fb fc3a 	bl	8022b4a <fp_mul_d>
 80272d6:	6138      	str	r0, [r7, #16]
      if (ret != FP_OKAY)
 80272d8:	693b      	ldr	r3, [r7, #16]
 80272da:	2b00      	cmp	r3, #0
 80272dc:	d001      	beq.n	80272e2 <fp_read_radix+0xf2>
        return ret;
 80272de:	693b      	ldr	r3, [r7, #16]
 80272e0:	e01e      	b.n	8027320 <fp_read_radix+0x130>
      ret = fp_add_d (a, (fp_digit) y, a);
 80272e2:	69fb      	ldr	r3, [r7, #28]
 80272e4:	68fa      	ldr	r2, [r7, #12]
 80272e6:	4619      	mov	r1, r3
 80272e8:	68f8      	ldr	r0, [r7, #12]
 80272ea:	f7ff feab 	bl	8027044 <fp_add_d>
 80272ee:	6138      	str	r0, [r7, #16]
      if (ret != FP_OKAY)
 80272f0:	693b      	ldr	r3, [r7, #16]
 80272f2:	2b00      	cmp	r3, #0
 80272f4:	d001      	beq.n	80272fa <fp_read_radix+0x10a>
        return ret;
 80272f6:	693b      	ldr	r3, [r7, #16]
 80272f8:	e012      	b.n	8027320 <fp_read_radix+0x130>
    } else {
      break;
    }
    ++str;
 80272fa:	68bb      	ldr	r3, [r7, #8]
 80272fc:	3301      	adds	r3, #1
 80272fe:	60bb      	str	r3, [r7, #8]
  while (*str) {
 8027300:	68bb      	ldr	r3, [r7, #8]
 8027302:	781b      	ldrb	r3, [r3, #0]
 8027304:	2b00      	cmp	r3, #0
 8027306:	d19b      	bne.n	8027240 <fp_read_radix+0x50>
 8027308:	e002      	b.n	8027310 <fp_read_radix+0x120>
        break;
 802730a:	bf00      	nop
 802730c:	e000      	b.n	8027310 <fp_read_radix+0x120>
      break;
 802730e:	bf00      	nop
  }

  /* set the sign only if a != 0 */
  if (fp_iszero(a) != FP_YES) {
 8027310:	68fb      	ldr	r3, [r7, #12]
 8027312:	681b      	ldr	r3, [r3, #0]
 8027314:	2b00      	cmp	r3, #0
 8027316:	d002      	beq.n	802731e <fp_read_radix+0x12e>
     a->sign = neg;
 8027318:	68fb      	ldr	r3, [r7, #12]
 802731a:	69ba      	ldr	r2, [r7, #24]
 802731c:	605a      	str	r2, [r3, #4]
  }
  return FP_OKAY;
 802731e:	2300      	movs	r3, #0
}
 8027320:	4618      	mov	r0, r3
 8027322:	3720      	adds	r7, #32
 8027324:	46bd      	mov	sp, r7
 8027326:	bd80      	pop	{r7, pc}
 8027328:	08034bf8 	.word	0x08034bf8
 802732c:	08030cfc 	.word	0x08030cfc

08027330 <mp_read_radix>:

/* fast math conversion */
int mp_read_radix(mp_int *a, const char *str, int radix)
{
 8027330:	b580      	push	{r7, lr}
 8027332:	b084      	sub	sp, #16
 8027334:	af00      	add	r7, sp, #0
 8027336:	60f8      	str	r0, [r7, #12]
 8027338:	60b9      	str	r1, [r7, #8]
 802733a:	607a      	str	r2, [r7, #4]
    return fp_read_radix(a, str, radix);
 802733c:	687a      	ldr	r2, [r7, #4]
 802733e:	68b9      	ldr	r1, [r7, #8]
 8027340:	68f8      	ldr	r0, [r7, #12]
 8027342:	f7ff ff55 	bl	80271f0 <fp_read_radix>
 8027346:	4603      	mov	r3, r0
}
 8027348:	4618      	mov	r0, r3
 802734a:	3710      	adds	r7, #16
 802734c:	46bd      	mov	sp, r7
 802734e:	bd80      	pop	{r7, pc}

08027350 <mp_montgomery_reduce>:
#endif /* !defined(NO_DSA) || defined(HAVE_ECC) */

#if defined(HAVE_ECC) || (!defined(NO_RSA) && defined(WC_RSA_BLINDING))

int mp_montgomery_reduce(fp_int *a, fp_int *m, fp_digit mp)
{
 8027350:	b580      	push	{r7, lr}
 8027352:	b084      	sub	sp, #16
 8027354:	af00      	add	r7, sp, #0
 8027356:	60f8      	str	r0, [r7, #12]
 8027358:	60b9      	str	r1, [r7, #8]
 802735a:	607a      	str	r2, [r7, #4]
    return fp_montgomery_reduce(a, m, mp);
 802735c:	687a      	ldr	r2, [r7, #4]
 802735e:	68b9      	ldr	r1, [r7, #8]
 8027360:	68f8      	ldr	r0, [r7, #12]
 8027362:	f7fe ffa4 	bl	80262ae <fp_montgomery_reduce>
 8027366:	4603      	mov	r3, r0
}
 8027368:	4618      	mov	r0, r3
 802736a:	3710      	adds	r7, #16
 802736c:	46bd      	mov	sp, r7
 802736e:	bd80      	pop	{r7, pc}

08027370 <mp_montgomery_reduce_ex>:

int mp_montgomery_reduce_ex(fp_int *a, fp_int *m, fp_digit mp, int ct)
{
 8027370:	b580      	push	{r7, lr}
 8027372:	b084      	sub	sp, #16
 8027374:	af00      	add	r7, sp, #0
 8027376:	60f8      	str	r0, [r7, #12]
 8027378:	60b9      	str	r1, [r7, #8]
 802737a:	607a      	str	r2, [r7, #4]
 802737c:	603b      	str	r3, [r7, #0]
    return fp_montgomery_reduce_ex(a, m, mp, ct);
 802737e:	683b      	ldr	r3, [r7, #0]
 8027380:	687a      	ldr	r2, [r7, #4]
 8027382:	68b9      	ldr	r1, [r7, #8]
 8027384:	68f8      	ldr	r0, [r7, #12]
 8027386:	f7fe fe5e 	bl	8026046 <fp_montgomery_reduce_ex>
 802738a:	4603      	mov	r3, r0
}
 802738c:	4618      	mov	r0, r3
 802738e:	3710      	adds	r7, #16
 8027390:	46bd      	mov	sp, r7
 8027392:	bd80      	pop	{r7, pc}

08027394 <mp_montgomery_setup>:


/* fast math conversion */
int mp_montgomery_setup(fp_int *a, fp_digit *rho)
{
 8027394:	b580      	push	{r7, lr}
 8027396:	b082      	sub	sp, #8
 8027398:	af00      	add	r7, sp, #0
 802739a:	6078      	str	r0, [r7, #4]
 802739c:	6039      	str	r1, [r7, #0]
    return fp_montgomery_setup(a, rho);
 802739e:	6839      	ldr	r1, [r7, #0]
 80273a0:	6878      	ldr	r0, [r7, #4]
 80273a2:	f7fe fdbd 	bl	8025f20 <fp_montgomery_setup>
 80273a6:	4603      	mov	r3, r0
}
 80273a8:	4618      	mov	r0, r3
 80273aa:	3708      	adds	r7, #8
 80273ac:	46bd      	mov	sp, r7
 80273ae:	bd80      	pop	{r7, pc}

080273b0 <mp_sqr>:

#endif /* HAVE_ECC || (!NO_RSA && WC_RSA_BLINDING) */

/* fast math conversion */
int mp_sqr(fp_int *A, fp_int *B)
{
 80273b0:	b580      	push	{r7, lr}
 80273b2:	b082      	sub	sp, #8
 80273b4:	af00      	add	r7, sp, #0
 80273b6:	6078      	str	r0, [r7, #4]
 80273b8:	6039      	str	r1, [r7, #0]
    return fp_sqr(A, B);
 80273ba:	6839      	ldr	r1, [r7, #0]
 80273bc:	6878      	ldr	r0, [r7, #4]
 80273be:	f7fe faba 	bl	8025936 <fp_sqr>
 80273c2:	4603      	mov	r3, r0
}
 80273c4:	4618      	mov	r0, r3
 80273c6:	3708      	adds	r7, #8
 80273c8:	46bd      	mov	sp, r7
 80273ca:	bd80      	pop	{r7, pc}

080273cc <mp_div_2_mod_ct>:
    return MP_OKAY;
}

/* c = a / 2 (mod b) - constant time (a < b and positive) */
int mp_div_2_mod_ct(mp_int *a, mp_int *b, mp_int *c)
{
 80273cc:	b580      	push	{r7, lr}
 80273ce:	b084      	sub	sp, #16
 80273d0:	af00      	add	r7, sp, #0
 80273d2:	60f8      	str	r0, [r7, #12]
 80273d4:	60b9      	str	r1, [r7, #8]
 80273d6:	607a      	str	r2, [r7, #4]
  return fp_div_2_mod_ct(a, b, c);
 80273d8:	687a      	ldr	r2, [r7, #4]
 80273da:	68b9      	ldr	r1, [r7, #8]
 80273dc:	68f8      	ldr	r0, [r7, #12]
 80273de:	f7fc f96a 	bl	80236b6 <fp_div_2_mod_ct>
 80273e2:	4603      	mov	r3, r0
}
 80273e4:	4618      	mov	r0, r3
 80273e6:	3710      	adds	r7, #16
 80273e8:	46bd      	mov	sp, r7
 80273ea:	bd80      	pop	{r7, pc}

080273ec <mp_set>:

#if defined(HAVE_ECC) || !defined(NO_RSA) || !defined(NO_DSA) || \
    defined(WOLFSSL_KEY_GEN)
/* fast math conversion */
int mp_set(fp_int *a, fp_digit b)
{
 80273ec:	b580      	push	{r7, lr}
 80273ee:	b082      	sub	sp, #8
 80273f0:	af00      	add	r7, sp, #0
 80273f2:	6078      	str	r0, [r7, #4]
 80273f4:	6039      	str	r1, [r7, #0]
    fp_set(a,b);
 80273f6:	6839      	ldr	r1, [r7, #0]
 80273f8:	6878      	ldr	r0, [r7, #4]
 80273fa:	f7ff f8ce 	bl	802659a <fp_set>
    return MP_OKAY;
 80273fe:	2300      	movs	r3, #0
}
 8027400:	4618      	mov	r0, r3
 8027402:	3708      	adds	r7, #8
 8027404:	46bd      	mov	sp, r7
 8027406:	bd80      	pop	{r7, pc}

08027408 <ForceZero>:
{
 8027408:	b480      	push	{r7}
 802740a:	b085      	sub	sp, #20
 802740c:	af00      	add	r7, sp, #0
 802740e:	6078      	str	r0, [r7, #4]
 8027410:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 8027412:	687b      	ldr	r3, [r7, #4]
 8027414:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 8027416:	e004      	b.n	8027422 <ForceZero+0x1a>
 8027418:	68fb      	ldr	r3, [r7, #12]
 802741a:	1c5a      	adds	r2, r3, #1
 802741c:	60fa      	str	r2, [r7, #12]
 802741e:	2200      	movs	r2, #0
 8027420:	701a      	strb	r2, [r3, #0]
 8027422:	683b      	ldr	r3, [r7, #0]
 8027424:	1e5a      	subs	r2, r3, #1
 8027426:	603a      	str	r2, [r7, #0]
 8027428:	2b00      	cmp	r3, #0
 802742a:	d1f5      	bne.n	8027418 <ForceZero+0x10>
}
 802742c:	bf00      	nop
 802742e:	bf00      	nop
 8027430:	3714      	adds	r7, #20
 8027432:	46bd      	mov	sp, r7
 8027434:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027438:	4770      	bx	lr

0802743a <wc_AesCbcDecryptWithKey>:

#if !defined(NO_AES) && defined(HAVE_AES_CBC)
#ifdef HAVE_AES_DECRYPT
int wc_AesCbcDecryptWithKey(byte* out, const byte* in, word32 inSz,
                                  const byte* key, word32 keySz, const byte* iv)
{
 802743a:	b580      	push	{r7, lr}
 802743c:	b08a      	sub	sp, #40	@ 0x28
 802743e:	af02      	add	r7, sp, #8
 8027440:	60f8      	str	r0, [r7, #12]
 8027442:	60b9      	str	r1, [r7, #8]
 8027444:	607a      	str	r2, [r7, #4]
 8027446:	603b      	str	r3, [r7, #0]
    int  ret = 0;
 8027448:	2300      	movs	r3, #0
 802744a:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_SMALL_STACK
    Aes* aes = NULL;
 802744c:	2300      	movs	r3, #0
 802744e:	61bb      	str	r3, [r7, #24]
#else
    Aes  aes[1];
#endif

    if (out == NULL || in == NULL || key == NULL || iv == NULL) {
 8027450:	68fb      	ldr	r3, [r7, #12]
 8027452:	2b00      	cmp	r3, #0
 8027454:	d008      	beq.n	8027468 <wc_AesCbcDecryptWithKey+0x2e>
 8027456:	68bb      	ldr	r3, [r7, #8]
 8027458:	2b00      	cmp	r3, #0
 802745a:	d005      	beq.n	8027468 <wc_AesCbcDecryptWithKey+0x2e>
 802745c:	683b      	ldr	r3, [r7, #0]
 802745e:	2b00      	cmp	r3, #0
 8027460:	d002      	beq.n	8027468 <wc_AesCbcDecryptWithKey+0x2e>
 8027462:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8027464:	2b00      	cmp	r3, #0
 8027466:	d102      	bne.n	802746e <wc_AesCbcDecryptWithKey+0x34>
        return BAD_FUNC_ARG;
 8027468:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802746c:	e033      	b.n	80274d6 <wc_AesCbcDecryptWithKey+0x9c>
    }

#ifdef WOLFSSL_SMALL_STACK
    aes = (Aes*)XMALLOC(sizeof(Aes), NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802746e:	f44f 70a6 	mov.w	r0, #332	@ 0x14c
 8027472:	f7f7 fc03 	bl	801ec7c <wolfSSL_Malloc>
 8027476:	61b8      	str	r0, [r7, #24]
    if (aes == NULL)
 8027478:	69bb      	ldr	r3, [r7, #24]
 802747a:	2b00      	cmp	r3, #0
 802747c:	d102      	bne.n	8027484 <wc_AesCbcDecryptWithKey+0x4a>
        return MEMORY_E;
 802747e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8027482:	e028      	b.n	80274d6 <wc_AesCbcDecryptWithKey+0x9c>
#endif

    ret = wc_AesInit(aes, NULL, INVALID_DEVID);
 8027484:	f06f 0201 	mvn.w	r2, #1
 8027488:	2100      	movs	r1, #0
 802748a:	69b8      	ldr	r0, [r7, #24]
 802748c:	f7eb f98b 	bl	80127a6 <wc_AesInit>
 8027490:	61f8      	str	r0, [r7, #28]
    if (ret == 0) {
 8027492:	69fb      	ldr	r3, [r7, #28]
 8027494:	2b00      	cmp	r3, #0
 8027496:	d115      	bne.n	80274c4 <wc_AesCbcDecryptWithKey+0x8a>
        ret = wc_AesSetKey(aes, key, keySz, iv, AES_DECRYPTION);
 8027498:	2301      	movs	r3, #1
 802749a:	9300      	str	r3, [sp, #0]
 802749c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802749e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80274a0:	6839      	ldr	r1, [r7, #0]
 80274a2:	69b8      	ldr	r0, [r7, #24]
 80274a4:	f7eb f896 	bl	80125d4 <wc_AesSetKey>
 80274a8:	61f8      	str	r0, [r7, #28]
        if (ret == 0)
 80274aa:	69fb      	ldr	r3, [r7, #28]
 80274ac:	2b00      	cmp	r3, #0
 80274ae:	d106      	bne.n	80274be <wc_AesCbcDecryptWithKey+0x84>
            ret = wc_AesCbcDecrypt(aes, out, in, inSz);
 80274b0:	687b      	ldr	r3, [r7, #4]
 80274b2:	68ba      	ldr	r2, [r7, #8]
 80274b4:	68f9      	ldr	r1, [r7, #12]
 80274b6:	69b8      	ldr	r0, [r7, #24]
 80274b8:	f7eb f91b 	bl	80126f2 <wc_AesCbcDecrypt>
 80274bc:	61f8      	str	r0, [r7, #28]

        wc_AesFree(aes);
 80274be:	69b8      	ldr	r0, [r7, #24]
 80274c0:	f7eb f98e 	bl	80127e0 <wc_AesFree>
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(aes, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80274c4:	69bb      	ldr	r3, [r7, #24]
 80274c6:	617b      	str	r3, [r7, #20]
 80274c8:	697b      	ldr	r3, [r7, #20]
 80274ca:	2b00      	cmp	r3, #0
 80274cc:	d002      	beq.n	80274d4 <wc_AesCbcDecryptWithKey+0x9a>
 80274ce:	6978      	ldr	r0, [r7, #20]
 80274d0:	f7f7 fbf0 	bl	801ecb4 <wolfSSL_Free>
#endif

    return ret;
 80274d4:	69fb      	ldr	r3, [r7, #28]
}
 80274d6:	4618      	mov	r0, r3
 80274d8:	3720      	adds	r7, #32
 80274da:	46bd      	mov	sp, r7
 80274dc:	bd80      	pop	{r7, pc}

080274de <wc_BufferKeyDecrypt>:

#if !defined(NO_ASN) && defined(WOLFSSL_ENCRYPTED_KEYS)

int wc_BufferKeyDecrypt(EncryptedInfo* info, byte* der, word32 derSz,
    const byte* password, int passwordSz, int hashType)
{
 80274de:	b580      	push	{r7, lr}
 80274e0:	b08a      	sub	sp, #40	@ 0x28
 80274e2:	af02      	add	r7, sp, #8
 80274e4:	60f8      	str	r0, [r7, #12]
 80274e6:	60b9      	str	r1, [r7, #8]
 80274e8:	607a      	str	r2, [r7, #4]
 80274ea:	603b      	str	r3, [r7, #0]
    int ret = WC_NO_ERR_TRACE(NOT_COMPILED_IN);
 80274ec:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 80274f0:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_SMALL_STACK
    byte* key      = NULL;
 80274f2:	2300      	movs	r3, #0
 80274f4:	61bb      	str	r3, [r7, #24]

    (void)derSz;
    (void)passwordSz;
    (void)hashType;

    if (der == NULL || password == NULL || info == NULL || info->keySz == 0) {
 80274f6:	68bb      	ldr	r3, [r7, #8]
 80274f8:	2b00      	cmp	r3, #0
 80274fa:	d009      	beq.n	8027510 <wc_BufferKeyDecrypt+0x32>
 80274fc:	683b      	ldr	r3, [r7, #0]
 80274fe:	2b00      	cmp	r3, #0
 8027500:	d006      	beq.n	8027510 <wc_BufferKeyDecrypt+0x32>
 8027502:	68fb      	ldr	r3, [r7, #12]
 8027504:	2b00      	cmp	r3, #0
 8027506:	d003      	beq.n	8027510 <wc_BufferKeyDecrypt+0x32>
 8027508:	68fb      	ldr	r3, [r7, #12]
 802750a:	691b      	ldr	r3, [r3, #16]
 802750c:	2b00      	cmp	r3, #0
 802750e:	d102      	bne.n	8027516 <wc_BufferKeyDecrypt+0x38>
        return BAD_FUNC_ARG;
 8027510:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8027514:	e045      	b.n	80275a2 <wc_BufferKeyDecrypt+0xc4>
    }

    /* use file's salt for key derivation, hex decode first */
    if (Base16_Decode(info->iv, info->ivSz, info->iv, &info->ivSz) != 0) {
 8027516:	68fb      	ldr	r3, [r7, #12]
 8027518:	f103 0068 	add.w	r0, r3, #104	@ 0x68
 802751c:	68fb      	ldr	r3, [r7, #12]
 802751e:	6959      	ldr	r1, [r3, #20]
 8027520:	68fb      	ldr	r3, [r7, #12]
 8027522:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 8027526:	68fb      	ldr	r3, [r7, #12]
 8027528:	3314      	adds	r3, #20
 802752a:	f7f3 f91f 	bl	801a76c <Base16_Decode>
 802752e:	4603      	mov	r3, r0
 8027530:	2b00      	cmp	r3, #0
 8027532:	d002      	beq.n	802753a <wc_BufferKeyDecrypt+0x5c>
        WOLFSSL_ERROR_VERBOSE(BUFFER_E);
        return BUFFER_E;
 8027534:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8027538:	e033      	b.n	80275a2 <wc_BufferKeyDecrypt+0xc4>
    }
    if (info->ivSz < PKCS5_SALT_SZ) {
 802753a:	68fb      	ldr	r3, [r7, #12]
 802753c:	695b      	ldr	r3, [r3, #20]
 802753e:	2b07      	cmp	r3, #7
 8027540:	d802      	bhi.n	8027548 <wc_BufferKeyDecrypt+0x6a>
        WOLFSSL_ERROR_VERBOSE(BUFFER_E);
        return BUFFER_E;
 8027542:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8027546:	e02c      	b.n	80275a2 <wc_BufferKeyDecrypt+0xc4>
    }

#ifdef WOLFSSL_SMALL_STACK
    key = (byte*)XMALLOC(WC_MAX_SYM_KEY_SIZE, NULL, DYNAMIC_TYPE_SYMMETRIC_KEY);
 8027548:	2020      	movs	r0, #32
 802754a:	f7f7 fb97 	bl	801ec7c <wolfSSL_Malloc>
 802754e:	61b8      	str	r0, [r7, #24]
    if (key == NULL) {
 8027550:	69bb      	ldr	r3, [r7, #24]
 8027552:	2b00      	cmp	r3, #0
 8027554:	d102      	bne.n	802755c <wc_BufferKeyDecrypt+0x7e>
        return MEMORY_E;
 8027556:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 802755a:	e022      	b.n	80275a2 <wc_BufferKeyDecrypt+0xc4>
#endif
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Add("wc_BufferKeyDecrypt key", key, WC_MAX_SYM_KEY_SIZE);
#endif

    (void)XMEMSET(key, 0, WC_MAX_SYM_KEY_SIZE);
 802755c:	2220      	movs	r2, #32
 802755e:	2100      	movs	r1, #0
 8027560:	69b8      	ldr	r0, [r7, #24]
 8027562:	f001 fb5f 	bl	8028c24 <memset>
        ret = wc_Des_CbcDecryptWithKey(der, der, derSz, key, info->iv);
    if (info->cipherType == WC_CIPHER_DES3)
        ret = wc_Des3_CbcDecryptWithKey(der, der, derSz, key, info->iv);
#endif /* NO_DES3 */
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(HAVE_AES_DECRYPT)
    if (info->cipherType == WC_CIPHER_AES_CBC)
 8027566:	68fb      	ldr	r3, [r7, #12]
 8027568:	68db      	ldr	r3, [r3, #12]
 802756a:	2b02      	cmp	r3, #2
 802756c:	d10c      	bne.n	8027588 <wc_BufferKeyDecrypt+0xaa>
        ret = wc_AesCbcDecryptWithKey(der, der, derSz, key, info->keySz,
 802756e:	68fb      	ldr	r3, [r7, #12]
 8027570:	691b      	ldr	r3, [r3, #16]
            info->iv);
 8027572:	68fa      	ldr	r2, [r7, #12]
 8027574:	3268      	adds	r2, #104	@ 0x68
        ret = wc_AesCbcDecryptWithKey(der, der, derSz, key, info->keySz,
 8027576:	9201      	str	r2, [sp, #4]
 8027578:	9300      	str	r3, [sp, #0]
 802757a:	69bb      	ldr	r3, [r7, #24]
 802757c:	687a      	ldr	r2, [r7, #4]
 802757e:	68b9      	ldr	r1, [r7, #8]
 8027580:	68b8      	ldr	r0, [r7, #8]
 8027582:	f7ff ff5a 	bl	802743a <wc_AesCbcDecryptWithKey>
 8027586:	61f8      	str	r0, [r7, #28]
#endif /* !NO_AES && HAVE_AES_CBC && HAVE_AES_DECRYPT */

    ForceZero(key, WC_MAX_SYM_KEY_SIZE);
 8027588:	2120      	movs	r1, #32
 802758a:	69b8      	ldr	r0, [r7, #24]
 802758c:	f7ff ff3c 	bl	8027408 <ForceZero>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(key, NULL, DYNAMIC_TYPE_SYMMETRIC_KEY);
 8027590:	69bb      	ldr	r3, [r7, #24]
 8027592:	617b      	str	r3, [r7, #20]
 8027594:	697b      	ldr	r3, [r7, #20]
 8027596:	2b00      	cmp	r3, #0
 8027598:	d002      	beq.n	80275a0 <wc_BufferKeyDecrypt+0xc2>
 802759a:	6978      	ldr	r0, [r7, #20]
 802759c:	f7f7 fb8a 	bl	801ecb4 <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
    wc_MemZero_Check(key, WC_MAX_SYM_KEY_SIZE);
#endif

    return ret;
 80275a0:	69fb      	ldr	r3, [r7, #28]
}
 80275a2:	4618      	mov	r0, r3
 80275a4:	3720      	adds	r7, #32
 80275a6:	46bd      	mov	sp, r7
 80275a8:	bd80      	pop	{r7, pc}
	...

080275ac <wolfCrypt_Init>:
/* Used to initialize state for wolfcrypt
   return 0 on success
 */
WOLFSSL_ABI
int wolfCrypt_Init(void)
{
 80275ac:	b580      	push	{r7, lr}
 80275ae:	b082      	sub	sp, #8
 80275b0:	af00      	add	r7, sp, #0
    int ret = 0;
 80275b2:	2300      	movs	r3, #0
 80275b4:	607b      	str	r3, [r7, #4]
    if (initRefCount == 0) {
 80275b6:	4b10      	ldr	r3, [pc, #64]	@ (80275f8 <wolfCrypt_Init+0x4c>)
 80275b8:	681b      	ldr	r3, [r3, #0]
 80275ba:	2b00      	cmp	r3, #0
 80275bc:	d111      	bne.n	80275e2 <wolfCrypt_Init+0x36>
        }
    #endif

    #if WOLFSSL_CRYPT_HW_MUTEX
        /* If crypto hardware mutex protection is enabled, then initialize it */
        ret = wolfSSL_CryptHwMutexInit();
 80275be:	f000 f83d 	bl	802763c <wolfSSL_CryptHwMutexInit>
 80275c2:	6078      	str	r0, [r7, #4]
        if (ret != 0) {
 80275c4:	687b      	ldr	r3, [r7, #4]
 80275c6:	2b00      	cmp	r3, #0
 80275c8:	d001      	beq.n	80275ce <wolfCrypt_Init+0x22>
            WOLFSSL_MSG("Hw crypt mutex init failed");
            return ret;
 80275ca:	687b      	ldr	r3, [r7, #4]
 80275cc:	e00f      	b.n	80275ee <wolfCrypt_Init+0x42>
    #ifdef WOLFSSL_AFALG
        WOLFSSL_MSG("Using AF_ALG for crypto acceleration");
    #endif

    #if !defined(WOLFCRYPT_ONLY) && defined(OPENSSL_EXTRA)
        wolfSSL_EVP_init();
 80275ce:	f7e3 ff2f 	bl	800b430 <wolfSSL_EVP_init>
    #endif

    #if defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE)
        if ((ret = wc_LoggingInit()) != 0) {
 80275d2:	f7f7 f8f9 	bl	801e7c8 <wc_LoggingInit>
 80275d6:	6078      	str	r0, [r7, #4]
 80275d8:	687b      	ldr	r3, [r7, #4]
 80275da:	2b00      	cmp	r3, #0
 80275dc:	d001      	beq.n	80275e2 <wolfCrypt_Init+0x36>
            WOLFSSL_MSG("Error creating logging mutex");
            return ret;
 80275de:	687b      	ldr	r3, [r7, #4]
 80275e0:	e005      	b.n	80275ee <wolfCrypt_Init+0x42>
        if ((ret = wolfSSL_liboqsInit()) != 0) {
            return ret;
        }
#endif
    }
    initRefCount++;
 80275e2:	4b05      	ldr	r3, [pc, #20]	@ (80275f8 <wolfCrypt_Init+0x4c>)
 80275e4:	681b      	ldr	r3, [r3, #0]
 80275e6:	3301      	adds	r3, #1
 80275e8:	4a03      	ldr	r2, [pc, #12]	@ (80275f8 <wolfCrypt_Init+0x4c>)
 80275ea:	6013      	str	r3, [r2, #0]

    return ret;
 80275ec:	687b      	ldr	r3, [r7, #4]
}
 80275ee:	4618      	mov	r0, r3
 80275f0:	3708      	adds	r7, #8
 80275f2:	46bd      	mov	sp, r7
 80275f4:	bd80      	pop	{r7, pc}
 80275f6:	bf00      	nop
 80275f8:	20001c4c 	.word	0x20001c4c

080275fc <wolfCrypt_Cleanup>:
#endif

/* return success value is the same as wolfCrypt_Init */
WOLFSSL_ABI
int wolfCrypt_Cleanup(void)
{
 80275fc:	b580      	push	{r7, lr}
 80275fe:	b082      	sub	sp, #8
 8027600:	af00      	add	r7, sp, #0
    int ret = 0;
 8027602:	2300      	movs	r3, #0
 8027604:	607b      	str	r3, [r7, #4]

    initRefCount--;
 8027606:	4b0c      	ldr	r3, [pc, #48]	@ (8027638 <wolfCrypt_Cleanup+0x3c>)
 8027608:	681b      	ldr	r3, [r3, #0]
 802760a:	3b01      	subs	r3, #1
 802760c:	4a0a      	ldr	r2, [pc, #40]	@ (8027638 <wolfCrypt_Cleanup+0x3c>)
 802760e:	6013      	str	r3, [r2, #0]
    if (initRefCount < 0)
 8027610:	4b09      	ldr	r3, [pc, #36]	@ (8027638 <wolfCrypt_Cleanup+0x3c>)
 8027612:	681b      	ldr	r3, [r3, #0]
 8027614:	2b00      	cmp	r3, #0
 8027616:	da02      	bge.n	802761e <wolfCrypt_Cleanup+0x22>
        initRefCount = 0;
 8027618:	4b07      	ldr	r3, [pc, #28]	@ (8027638 <wolfCrypt_Cleanup+0x3c>)
 802761a:	2200      	movs	r2, #0
 802761c:	601a      	str	r2, [r3, #0]

    if (initRefCount == 0) {
 802761e:	4b06      	ldr	r3, [pc, #24]	@ (8027638 <wolfCrypt_Cleanup+0x3c>)
 8027620:	681b      	ldr	r3, [r3, #0]
 8027622:	2b00      	cmp	r3, #0
 8027624:	d102      	bne.n	802762c <wolfCrypt_Cleanup+0x30>
        wc_ecc_oid_cache_free();
    #endif
#endif /* HAVE_ECC */

    #if defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE)
        ret = wc_LoggingCleanup();
 8027626:	f7f7 f8f3 	bl	801e810 <wc_LoggingCleanup>
 802762a:	6078      	str	r0, [r7, #4]

#if defined(HAVE_LIBOQS)
    wolfSSL_liboqsClose();
#endif

    return ret;
 802762c:	687b      	ldr	r3, [r7, #4]
}
 802762e:	4618      	mov	r0, r3
 8027630:	3708      	adds	r7, #8
 8027632:	46bd      	mov	sp, r7
 8027634:	bd80      	pop	{r7, pc}
 8027636:	bf00      	nop
 8027638:	20001c4c 	.word	0x20001c4c

0802763c <wolfSSL_CryptHwMutexInit>:
#ifndef WOLFSSL_MUTEX_INITIALIZER
static int wcCryptHwMutexInit = 0;
#endif

int wolfSSL_CryptHwMutexInit(void)
{
 802763c:	b580      	push	{r7, lr}
 802763e:	b082      	sub	sp, #8
 8027640:	af00      	add	r7, sp, #0
    int ret = 0;
 8027642:	2300      	movs	r3, #0
 8027644:	607b      	str	r3, [r7, #4]
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (wcCryptHwMutexInit == 0) {
 8027646:	4b09      	ldr	r3, [pc, #36]	@ (802766c <wolfSSL_CryptHwMutexInit+0x30>)
 8027648:	681b      	ldr	r3, [r3, #0]
 802764a:	2b00      	cmp	r3, #0
 802764c:	d109      	bne.n	8027662 <wolfSSL_CryptHwMutexInit+0x26>
        ret = wc_InitMutex(&wcCryptHwMutex);
 802764e:	4808      	ldr	r0, [pc, #32]	@ (8027670 <wolfSSL_CryptHwMutexInit+0x34>)
 8027650:	f000 f838 	bl	80276c4 <wc_InitMutex>
 8027654:	6078      	str	r0, [r7, #4]
        if (ret == 0) {
 8027656:	687b      	ldr	r3, [r7, #4]
 8027658:	2b00      	cmp	r3, #0
 802765a:	d102      	bne.n	8027662 <wolfSSL_CryptHwMutexInit+0x26>
            wcCryptHwMutexInit = 1;
 802765c:	4b03      	ldr	r3, [pc, #12]	@ (802766c <wolfSSL_CryptHwMutexInit+0x30>)
 802765e:	2201      	movs	r2, #1
 8027660:	601a      	str	r2, [r3, #0]
        }
    }
#endif
    return ret;
 8027662:	687b      	ldr	r3, [r7, #4]
}
 8027664:	4618      	mov	r0, r3
 8027666:	3708      	adds	r7, #8
 8027668:	46bd      	mov	sp, r7
 802766a:	bd80      	pop	{r7, pc}
 802766c:	20001c54 	.word	0x20001c54
 8027670:	20001c50 	.word	0x20001c50

08027674 <wolfSSL_CryptHwMutexLock>:
int wolfSSL_CryptHwMutexLock(void)
{
 8027674:	b580      	push	{r7, lr}
 8027676:	b082      	sub	sp, #8
 8027678:	af00      	add	r7, sp, #0
    /* Make sure HW Mutex has been initialized */
    int ret = wolfSSL_CryptHwMutexInit();
 802767a:	f7ff ffdf 	bl	802763c <wolfSSL_CryptHwMutexInit>
 802767e:	6078      	str	r0, [r7, #4]
    if (ret == 0) {
 8027680:	687b      	ldr	r3, [r7, #4]
 8027682:	2b00      	cmp	r3, #0
 8027684:	d103      	bne.n	802768e <wolfSSL_CryptHwMutexLock+0x1a>
        ret = wc_LockMutex(&wcCryptHwMutex);
 8027686:	4804      	ldr	r0, [pc, #16]	@ (8027698 <wolfSSL_CryptHwMutexLock+0x24>)
 8027688:	f000 f832 	bl	80276f0 <wc_LockMutex>
 802768c:	6078      	str	r0, [r7, #4]
    }
    return ret;
 802768e:	687b      	ldr	r3, [r7, #4]
}
 8027690:	4618      	mov	r0, r3
 8027692:	3708      	adds	r7, #8
 8027694:	46bd      	mov	sp, r7
 8027696:	bd80      	pop	{r7, pc}
 8027698:	20001c50 	.word	0x20001c50

0802769c <wolfSSL_CryptHwMutexUnLock>:
int wolfSSL_CryptHwMutexUnLock(void)
{
 802769c:	b580      	push	{r7, lr}
 802769e:	af00      	add	r7, sp, #0
    if (wcCryptHwMutexInit) {
 80276a0:	4b06      	ldr	r3, [pc, #24]	@ (80276bc <wolfSSL_CryptHwMutexUnLock+0x20>)
 80276a2:	681b      	ldr	r3, [r3, #0]
 80276a4:	2b00      	cmp	r3, #0
 80276a6:	d004      	beq.n	80276b2 <wolfSSL_CryptHwMutexUnLock+0x16>
        return wc_UnLockMutex(&wcCryptHwMutex);
 80276a8:	4805      	ldr	r0, [pc, #20]	@ (80276c0 <wolfSSL_CryptHwMutexUnLock+0x24>)
 80276aa:	f000 f82c 	bl	8027706 <wc_UnLockMutex>
 80276ae:	4603      	mov	r3, r0
 80276b0:	e001      	b.n	80276b6 <wolfSSL_CryptHwMutexUnLock+0x1a>
    }
    else {
        return BAD_MUTEX_E;
 80276b2:	f06f 0369 	mvn.w	r3, #105	@ 0x69
    }
}
 80276b6:	4618      	mov	r0, r3
 80276b8:	bd80      	pop	{r7, pc}
 80276ba:	bf00      	nop
 80276bc:	20001c54 	.word	0x20001c54
 80276c0:	20001c50 	.word	0x20001c50

080276c4 <wc_InitMutex>:
    }
#endif /* defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) */
#ifdef SINGLE_THREADED

    int wc_InitMutex(wolfSSL_Mutex* m)
    {
 80276c4:	b480      	push	{r7}
 80276c6:	b083      	sub	sp, #12
 80276c8:	af00      	add	r7, sp, #0
 80276ca:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 80276cc:	2300      	movs	r3, #0
    }
 80276ce:	4618      	mov	r0, r3
 80276d0:	370c      	adds	r7, #12
 80276d2:	46bd      	mov	sp, r7
 80276d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80276d8:	4770      	bx	lr

080276da <wc_FreeMutex>:

    int wc_FreeMutex(wolfSSL_Mutex *m)
    {
 80276da:	b480      	push	{r7}
 80276dc:	b083      	sub	sp, #12
 80276de:	af00      	add	r7, sp, #0
 80276e0:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 80276e2:	2300      	movs	r3, #0
    }
 80276e4:	4618      	mov	r0, r3
 80276e6:	370c      	adds	r7, #12
 80276e8:	46bd      	mov	sp, r7
 80276ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80276ee:	4770      	bx	lr

080276f0 <wc_LockMutex>:


    int wc_LockMutex(wolfSSL_Mutex *m)
    {
 80276f0:	b480      	push	{r7}
 80276f2:	b083      	sub	sp, #12
 80276f4:	af00      	add	r7, sp, #0
 80276f6:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 80276f8:	2300      	movs	r3, #0
    }
 80276fa:	4618      	mov	r0, r3
 80276fc:	370c      	adds	r7, #12
 80276fe:	46bd      	mov	sp, r7
 8027700:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027704:	4770      	bx	lr

08027706 <wc_UnLockMutex>:


    int wc_UnLockMutex(wolfSSL_Mutex *m)
    {
 8027706:	b480      	push	{r7}
 8027708:	b083      	sub	sp, #12
 802770a:	af00      	add	r7, sp, #0
 802770c:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 802770e:	2300      	movs	r3, #0
    }
 8027710:	4618      	mov	r0, r3
 8027712:	370c      	adds	r7, #12
 8027714:	46bd      	mov	sp, r7
 8027716:	f85d 7b04 	ldr.w	r7, [sp], #4
 802771a:	4770      	bx	lr

0802771c <mystrnstr>:
#endif /* !NO_ASN_TIME */

#if (!defined(WOLFSSL_LEANPSK) && !defined(STRING_USER)) || \
    defined(USE_WOLF_STRNSTR)
char* mystrnstr(const char* s1, const char* s2, unsigned int n)
{
 802771c:	b580      	push	{r7, lr}
 802771e:	b086      	sub	sp, #24
 8027720:	af00      	add	r7, sp, #0
 8027722:	60f8      	str	r0, [r7, #12]
 8027724:	60b9      	str	r1, [r7, #8]
 8027726:	607a      	str	r2, [r7, #4]
    unsigned int s2_len = (unsigned int)XSTRLEN(s2);
 8027728:	68b8      	ldr	r0, [r7, #8]
 802772a:	f7d8 fd5b 	bl	80001e4 <strlen>
 802772e:	6178      	str	r0, [r7, #20]

    if (s2_len == 0)
 8027730:	697b      	ldr	r3, [r7, #20]
 8027732:	2b00      	cmp	r3, #0
 8027734:	d117      	bne.n	8027766 <mystrnstr+0x4a>
        return (char*)s1;
 8027736:	68fb      	ldr	r3, [r7, #12]
 8027738:	e01e      	b.n	8027778 <mystrnstr+0x5c>

    while (n >= s2_len && s1[0]) {
        if (s1[0] == s2[0])
 802773a:	68fb      	ldr	r3, [r7, #12]
 802773c:	781a      	ldrb	r2, [r3, #0]
 802773e:	68bb      	ldr	r3, [r7, #8]
 8027740:	781b      	ldrb	r3, [r3, #0]
 8027742:	429a      	cmp	r2, r3
 8027744:	d109      	bne.n	802775a <mystrnstr+0x3e>
            if (XMEMCMP(s1, s2, s2_len) == 0)
 8027746:	697a      	ldr	r2, [r7, #20]
 8027748:	68b9      	ldr	r1, [r7, #8]
 802774a:	68f8      	ldr	r0, [r7, #12]
 802774c:	f001 fa40 	bl	8028bd0 <memcmp>
 8027750:	4603      	mov	r3, r0
 8027752:	2b00      	cmp	r3, #0
 8027754:	d101      	bne.n	802775a <mystrnstr+0x3e>
                return (char*)s1;
 8027756:	68fb      	ldr	r3, [r7, #12]
 8027758:	e00e      	b.n	8027778 <mystrnstr+0x5c>
        s1++;
 802775a:	68fb      	ldr	r3, [r7, #12]
 802775c:	3301      	adds	r3, #1
 802775e:	60fb      	str	r3, [r7, #12]
        n--;
 8027760:	687b      	ldr	r3, [r7, #4]
 8027762:	3b01      	subs	r3, #1
 8027764:	607b      	str	r3, [r7, #4]
    while (n >= s2_len && s1[0]) {
 8027766:	687a      	ldr	r2, [r7, #4]
 8027768:	697b      	ldr	r3, [r7, #20]
 802776a:	429a      	cmp	r2, r3
 802776c:	d303      	bcc.n	8027776 <mystrnstr+0x5a>
 802776e:	68fb      	ldr	r3, [r7, #12]
 8027770:	781b      	ldrb	r3, [r3, #0]
 8027772:	2b00      	cmp	r3, #0
 8027774:	d1e1      	bne.n	802773a <mystrnstr+0x1e>
    }

    return NULL;
 8027776:	2300      	movs	r3, #0
}
 8027778:	4618      	mov	r0, r3
 802777a:	3718      	adds	r7, #24
 802777c:	46bd      	mov	sp, r7
 802777e:	bd80      	pop	{r7, pc}

08027780 <mp_reverse>:
#endif


/* reverse an array, used for radix code */
void mp_reverse(unsigned char *s, int len)
{
 8027780:	b480      	push	{r7}
 8027782:	b087      	sub	sp, #28
 8027784:	af00      	add	r7, sp, #0
 8027786:	6078      	str	r0, [r7, #4]
 8027788:	6039      	str	r1, [r7, #0]
    int ix, iy;

    if (s == NULL)
 802778a:	687b      	ldr	r3, [r7, #4]
 802778c:	2b00      	cmp	r3, #0
 802778e:	d022      	beq.n	80277d6 <mp_reverse+0x56>
        return;

    ix = 0;
 8027790:	2300      	movs	r3, #0
 8027792:	617b      	str	r3, [r7, #20]
    iy = len - 1;
 8027794:	683b      	ldr	r3, [r7, #0]
 8027796:	3b01      	subs	r3, #1
 8027798:	613b      	str	r3, [r7, #16]
    while (ix < iy) {
 802779a:	e017      	b.n	80277cc <mp_reverse+0x4c>
        unsigned char t = s[ix];
 802779c:	697b      	ldr	r3, [r7, #20]
 802779e:	687a      	ldr	r2, [r7, #4]
 80277a0:	4413      	add	r3, r2
 80277a2:	781b      	ldrb	r3, [r3, #0]
 80277a4:	73fb      	strb	r3, [r7, #15]
        s[ix] = s[iy];
 80277a6:	693b      	ldr	r3, [r7, #16]
 80277a8:	687a      	ldr	r2, [r7, #4]
 80277aa:	441a      	add	r2, r3
 80277ac:	697b      	ldr	r3, [r7, #20]
 80277ae:	6879      	ldr	r1, [r7, #4]
 80277b0:	440b      	add	r3, r1
 80277b2:	7812      	ldrb	r2, [r2, #0]
 80277b4:	701a      	strb	r2, [r3, #0]
        s[iy] = t;
 80277b6:	693b      	ldr	r3, [r7, #16]
 80277b8:	687a      	ldr	r2, [r7, #4]
 80277ba:	4413      	add	r3, r2
 80277bc:	7bfa      	ldrb	r2, [r7, #15]
 80277be:	701a      	strb	r2, [r3, #0]
        ++ix;
 80277c0:	697b      	ldr	r3, [r7, #20]
 80277c2:	3301      	adds	r3, #1
 80277c4:	617b      	str	r3, [r7, #20]
        --iy;
 80277c6:	693b      	ldr	r3, [r7, #16]
 80277c8:	3b01      	subs	r3, #1
 80277ca:	613b      	str	r3, [r7, #16]
    while (ix < iy) {
 80277cc:	697a      	ldr	r2, [r7, #20]
 80277ce:	693b      	ldr	r3, [r7, #16]
 80277d0:	429a      	cmp	r2, r3
 80277d2:	dbe3      	blt.n	802779c <mp_reverse+0x1c>
 80277d4:	e000      	b.n	80277d8 <mp_reverse+0x58>
        return;
 80277d6:	bf00      	nop
    }
}
 80277d8:	371c      	adds	r7, #28
 80277da:	46bd      	mov	sp, r7
 80277dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80277e0:	4770      	bx	lr

080277e2 <get_digit_count>:

int get_digit_count(const mp_int* a)
{
 80277e2:	b480      	push	{r7}
 80277e4:	b083      	sub	sp, #12
 80277e6:	af00      	add	r7, sp, #0
 80277e8:	6078      	str	r0, [r7, #4]
    if (a == NULL)
 80277ea:	687b      	ldr	r3, [r7, #4]
 80277ec:	2b00      	cmp	r3, #0
 80277ee:	d101      	bne.n	80277f4 <get_digit_count+0x12>
        return 0;
 80277f0:	2300      	movs	r3, #0
 80277f2:	e001      	b.n	80277f8 <get_digit_count+0x16>

    return (int)a->used;
 80277f4:	687b      	ldr	r3, [r7, #4]
 80277f6:	681b      	ldr	r3, [r3, #0]
}
 80277f8:	4618      	mov	r0, r3
 80277fa:	370c      	adds	r7, #12
 80277fc:	46bd      	mov	sp, r7
 80277fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027802:	4770      	bx	lr

08027804 <get_digit>:

mp_digit get_digit(const mp_int* a, int n)
{
 8027804:	b480      	push	{r7}
 8027806:	b083      	sub	sp, #12
 8027808:	af00      	add	r7, sp, #0
 802780a:	6078      	str	r0, [r7, #4]
 802780c:	6039      	str	r1, [r7, #0]
    if (a == NULL)
 802780e:	687b      	ldr	r3, [r7, #4]
 8027810:	2b00      	cmp	r3, #0
 8027812:	d101      	bne.n	8027818 <get_digit+0x14>
        return 0;
 8027814:	2300      	movs	r3, #0
 8027816:	e010      	b.n	802783a <get_digit+0x36>

    return (n < 0 || (unsigned int)n >= (unsigned int)a->used) ? 0 : a->dp[n];
 8027818:	683b      	ldr	r3, [r7, #0]
 802781a:	2b00      	cmp	r3, #0
 802781c:	db0c      	blt.n	8027838 <get_digit+0x34>
 802781e:	687b      	ldr	r3, [r7, #4]
 8027820:	681b      	ldr	r3, [r3, #0]
 8027822:	461a      	mov	r2, r3
 8027824:	683b      	ldr	r3, [r7, #0]
 8027826:	429a      	cmp	r2, r3
 8027828:	d906      	bls.n	8027838 <get_digit+0x34>
 802782a:	687a      	ldr	r2, [r7, #4]
 802782c:	683b      	ldr	r3, [r7, #0]
 802782e:	3302      	adds	r3, #2
 8027830:	009b      	lsls	r3, r3, #2
 8027832:	4413      	add	r3, r2
 8027834:	685b      	ldr	r3, [r3, #4]
 8027836:	e000      	b.n	802783a <get_digit+0x36>
 8027838:	2300      	movs	r3, #0
}
 802783a:	4618      	mov	r0, r3
 802783c:	370c      	adds	r7, #12
 802783e:	46bd      	mov	sp, r7
 8027840:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027844:	4770      	bx	lr

08027846 <mp_cond_copy>:
 * b     MP integer to copy into.
 * returns BAD_FUNC_ARG when a or b is NULL, MEMORY_E when growing b fails and
 *         MP_OKAY otherwise.
 */
int mp_cond_copy(mp_int* a, int copy, mp_int* b)
{
 8027846:	b590      	push	{r4, r7, lr}
 8027848:	b089      	sub	sp, #36	@ 0x24
 802784a:	af00      	add	r7, sp, #0
 802784c:	60f8      	str	r0, [r7, #12]
 802784e:	60b9      	str	r1, [r7, #8]
 8027850:	607a      	str	r2, [r7, #4]
    int err = MP_OKAY;
 8027852:	2300      	movs	r3, #0
 8027854:	61fb      	str	r3, [r7, #28]
#if defined(SP_WORD_SIZE) && SP_WORD_SIZE == 8
    unsigned int mask = (unsigned int)0 - copy;
#else
    mp_digit mask = (mp_digit)0 - (mp_digit)copy;
 8027856:	68bb      	ldr	r3, [r7, #8]
 8027858:	425b      	negs	r3, r3
 802785a:	617b      	str	r3, [r7, #20]
#endif

    if (a == NULL || b == NULL)
 802785c:	68fb      	ldr	r3, [r7, #12]
 802785e:	2b00      	cmp	r3, #0
 8027860:	d002      	beq.n	8027868 <mp_cond_copy+0x22>
 8027862:	687b      	ldr	r3, [r7, #4]
 8027864:	2b00      	cmp	r3, #0
 8027866:	d102      	bne.n	802786e <mp_cond_copy+0x28>
        err = BAD_FUNC_ARG;
 8027868:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802786c:	61fb      	str	r3, [r7, #28]

    /* Ensure b has enough space to copy a into */
    if (err == MP_OKAY)
 802786e:	69fb      	ldr	r3, [r7, #28]
 8027870:	2b00      	cmp	r3, #0
 8027872:	d101      	bne.n	8027878 <mp_cond_copy+0x32>
        err = mp_grow(b, (int)a->used + 1);
 8027874:	2300      	movs	r3, #0
 8027876:	61fb      	str	r3, [r7, #28]
    if (err == MP_OKAY) {
 8027878:	69fb      	ldr	r3, [r7, #28]
 802787a:	2b00      	cmp	r3, #0
 802787c:	d161      	bne.n	8027942 <mp_cond_copy+0xfc>
         * When mask all set, b ^ b ^ a = a
         */
        /* Conditionally copy all digits and then number of used digits.
         * get_digit() returns 0 when index greater than available digit.
         */
        for (i = 0; i < a->used; i++) {
 802787e:	2300      	movs	r3, #0
 8027880:	61bb      	str	r3, [r7, #24]
 8027882:	e01d      	b.n	80278c0 <mp_cond_copy+0x7a>
            b->dp[i] ^= (get_digit(a, (int)i) ^ get_digit(b, (int)i)) & mask;
 8027884:	69b9      	ldr	r1, [r7, #24]
 8027886:	68f8      	ldr	r0, [r7, #12]
 8027888:	f7ff ffbc 	bl	8027804 <get_digit>
 802788c:	4604      	mov	r4, r0
 802788e:	69b9      	ldr	r1, [r7, #24]
 8027890:	6878      	ldr	r0, [r7, #4]
 8027892:	f7ff ffb7 	bl	8027804 <get_digit>
 8027896:	4603      	mov	r3, r0
 8027898:	ea84 0203 	eor.w	r2, r4, r3
 802789c:	697b      	ldr	r3, [r7, #20]
 802789e:	401a      	ands	r2, r3
 80278a0:	6879      	ldr	r1, [r7, #4]
 80278a2:	69bb      	ldr	r3, [r7, #24]
 80278a4:	3302      	adds	r3, #2
 80278a6:	009b      	lsls	r3, r3, #2
 80278a8:	440b      	add	r3, r1
 80278aa:	685b      	ldr	r3, [r3, #4]
 80278ac:	405a      	eors	r2, r3
 80278ae:	6879      	ldr	r1, [r7, #4]
 80278b0:	69bb      	ldr	r3, [r7, #24]
 80278b2:	3302      	adds	r3, #2
 80278b4:	009b      	lsls	r3, r3, #2
 80278b6:	440b      	add	r3, r1
 80278b8:	605a      	str	r2, [r3, #4]
        for (i = 0; i < a->used; i++) {
 80278ba:	69bb      	ldr	r3, [r7, #24]
 80278bc:	3301      	adds	r3, #1
 80278be:	61bb      	str	r3, [r7, #24]
 80278c0:	68fb      	ldr	r3, [r7, #12]
 80278c2:	681b      	ldr	r3, [r3, #0]
 80278c4:	69ba      	ldr	r2, [r7, #24]
 80278c6:	429a      	cmp	r2, r3
 80278c8:	dbdc      	blt.n	8027884 <mp_cond_copy+0x3e>
        }
        for (; i < b->used; i++) {
 80278ca:	e01d      	b.n	8027908 <mp_cond_copy+0xc2>
            b->dp[i] ^= (get_digit(a, (int)i) ^ get_digit(b, (int)i)) & mask;
 80278cc:	69b9      	ldr	r1, [r7, #24]
 80278ce:	68f8      	ldr	r0, [r7, #12]
 80278d0:	f7ff ff98 	bl	8027804 <get_digit>
 80278d4:	4604      	mov	r4, r0
 80278d6:	69b9      	ldr	r1, [r7, #24]
 80278d8:	6878      	ldr	r0, [r7, #4]
 80278da:	f7ff ff93 	bl	8027804 <get_digit>
 80278de:	4603      	mov	r3, r0
 80278e0:	ea84 0203 	eor.w	r2, r4, r3
 80278e4:	697b      	ldr	r3, [r7, #20]
 80278e6:	401a      	ands	r2, r3
 80278e8:	6879      	ldr	r1, [r7, #4]
 80278ea:	69bb      	ldr	r3, [r7, #24]
 80278ec:	3302      	adds	r3, #2
 80278ee:	009b      	lsls	r3, r3, #2
 80278f0:	440b      	add	r3, r1
 80278f2:	685b      	ldr	r3, [r3, #4]
 80278f4:	405a      	eors	r2, r3
 80278f6:	6879      	ldr	r1, [r7, #4]
 80278f8:	69bb      	ldr	r3, [r7, #24]
 80278fa:	3302      	adds	r3, #2
 80278fc:	009b      	lsls	r3, r3, #2
 80278fe:	440b      	add	r3, r1
 8027900:	605a      	str	r2, [r3, #4]
        for (; i < b->used; i++) {
 8027902:	69bb      	ldr	r3, [r7, #24]
 8027904:	3301      	adds	r3, #1
 8027906:	61bb      	str	r3, [r7, #24]
 8027908:	687b      	ldr	r3, [r7, #4]
 802790a:	681b      	ldr	r3, [r3, #0]
 802790c:	69ba      	ldr	r2, [r7, #24]
 802790e:	429a      	cmp	r2, r3
 8027910:	dbdc      	blt.n	80278cc <mp_cond_copy+0x86>
        }
        b->used ^= (a->used ^ b->used) & (wc_mp_size_t)mask;
 8027912:	687b      	ldr	r3, [r7, #4]
 8027914:	681a      	ldr	r2, [r3, #0]
 8027916:	68fb      	ldr	r3, [r7, #12]
 8027918:	6819      	ldr	r1, [r3, #0]
 802791a:	687b      	ldr	r3, [r7, #4]
 802791c:	681b      	ldr	r3, [r3, #0]
 802791e:	4059      	eors	r1, r3
 8027920:	697b      	ldr	r3, [r7, #20]
 8027922:	400b      	ands	r3, r1
 8027924:	405a      	eors	r2, r3
 8027926:	687b      	ldr	r3, [r7, #4]
 8027928:	601a      	str	r2, [r3, #0]
#if (!defined(WOLFSSL_SP_MATH) && !defined(WOLFSSL_SP_MATH_ALL)) || \
    defined(WOLFSSL_SP_INT_NEGATIVE)
        b->sign ^= (wc_mp_sign_t)(a->sign ^ b->sign) & (wc_mp_sign_t)mask;
 802792a:	687b      	ldr	r3, [r7, #4]
 802792c:	685a      	ldr	r2, [r3, #4]
 802792e:	68fb      	ldr	r3, [r7, #12]
 8027930:	6859      	ldr	r1, [r3, #4]
 8027932:	687b      	ldr	r3, [r7, #4]
 8027934:	685b      	ldr	r3, [r3, #4]
 8027936:	4059      	eors	r1, r3
 8027938:	697b      	ldr	r3, [r7, #20]
 802793a:	400b      	ands	r3, r1
 802793c:	405a      	eors	r2, r3
 802793e:	687b      	ldr	r3, [r7, #4]
 8027940:	605a      	str	r2, [r3, #4]
#endif
    }

    return err;
 8027942:	69fb      	ldr	r3, [r7, #28]
}
 8027944:	4618      	mov	r0, r3
 8027946:	3724      	adds	r7, #36	@ 0x24
 8027948:	46bd      	mov	sp, r7
 802794a:	bd90      	pop	{r4, r7, pc}

0802794c <get_rand_digit>:
#endif /* HAVE_ECC || WOLFSSL_MP_COND_COPY */


#ifndef WC_NO_RNG
int get_rand_digit(WC_RNG* rng, mp_digit* d)
{
 802794c:	b580      	push	{r7, lr}
 802794e:	b082      	sub	sp, #8
 8027950:	af00      	add	r7, sp, #0
 8027952:	6078      	str	r0, [r7, #4]
 8027954:	6039      	str	r1, [r7, #0]
    return wc_RNG_GenerateBlock(rng, (byte*)d, sizeof(mp_digit));
 8027956:	2204      	movs	r2, #4
 8027958:	6839      	ldr	r1, [r7, #0]
 802795a:	6878      	ldr	r0, [r7, #4]
 802795c:	f7f7 ff15 	bl	801f78a <wc_RNG_GenerateBlock>
 8027960:	4603      	mov	r3, r0
}
 8027962:	4618      	mov	r0, r3
 8027964:	3708      	adds	r7, #8
 8027966:	46bd      	mov	sp, r7
 8027968:	bd80      	pop	{r7, pc}

0802796a <mp_rand>:

int mp_rand(mp_int* a, int digits, WC_RNG* rng)
{
 802796a:	b580      	push	{r7, lr}
 802796c:	b086      	sub	sp, #24
 802796e:	af00      	add	r7, sp, #0
 8027970:	60f8      	str	r0, [r7, #12]
 8027972:	60b9      	str	r1, [r7, #8]
 8027974:	607a      	str	r2, [r7, #4]
    int ret = 0;
 8027976:	2300      	movs	r3, #0
 8027978:	617b      	str	r3, [r7, #20]
    int cnt = digits * (int)sizeof(mp_digit);
 802797a:	68bb      	ldr	r3, [r7, #8]
 802797c:	009b      	lsls	r3, r3, #2
 802797e:	613b      	str	r3, [r7, #16]

    if (rng == NULL) {
 8027980:	687b      	ldr	r3, [r7, #4]
 8027982:	2b00      	cmp	r3, #0
 8027984:	d103      	bne.n	802798e <mp_rand+0x24>
        ret = MISSING_RNG_E;
 8027986:	f06f 03eb 	mvn.w	r3, #235	@ 0xeb
 802798a:	617b      	str	r3, [r7, #20]
 802798c:	e008      	b.n	80279a0 <mp_rand+0x36>
    }
    else if (a == NULL || digits <= 0) {
 802798e:	68fb      	ldr	r3, [r7, #12]
 8027990:	2b00      	cmp	r3, #0
 8027992:	d002      	beq.n	802799a <mp_rand+0x30>
 8027994:	68bb      	ldr	r3, [r7, #8]
 8027996:	2b00      	cmp	r3, #0
 8027998:	dc02      	bgt.n	80279a0 <mp_rand+0x36>
        ret = BAD_FUNC_ARG;
 802799a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 802799e:	617b      	str	r3, [r7, #20]
    }
#else
#if defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_SP_MATH_ALL)
    if ((ret == MP_OKAY) && ((unsigned int)digits > a->size))
#else
    if ((ret == MP_OKAY) && (digits > FP_SIZE))
 80279a0:	697b      	ldr	r3, [r7, #20]
 80279a2:	2b00      	cmp	r3, #0
 80279a4:	d105      	bne.n	80279b2 <mp_rand+0x48>
 80279a6:	68bb      	ldr	r3, [r7, #8]
 80279a8:	2b88      	cmp	r3, #136	@ 0x88
 80279aa:	dd02      	ble.n	80279b2 <mp_rand+0x48>
#endif
    {
        ret = BAD_FUNC_ARG;
 80279ac:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80279b0:	617b      	str	r3, [r7, #20]
    }
    if (ret == MP_OKAY) {
 80279b2:	697b      	ldr	r3, [r7, #20]
 80279b4:	2b00      	cmp	r3, #0
 80279b6:	d102      	bne.n	80279be <mp_rand+0x54>
        a->used = (wc_mp_size_t)digits;
 80279b8:	68fb      	ldr	r3, [r7, #12]
 80279ba:	68ba      	ldr	r2, [r7, #8]
 80279bc:	601a      	str	r2, [r3, #0]
    }
#endif
    /* fill the data with random bytes */
    if (ret == MP_OKAY) {
 80279be:	697b      	ldr	r3, [r7, #20]
 80279c0:	2b00      	cmp	r3, #0
 80279c2:	d107      	bne.n	80279d4 <mp_rand+0x6a>
        ret = wc_RNG_GenerateBlock(rng, (byte*)a->dp, (word32)cnt);
 80279c4:	68fb      	ldr	r3, [r7, #12]
 80279c6:	330c      	adds	r3, #12
 80279c8:	693a      	ldr	r2, [r7, #16]
 80279ca:	4619      	mov	r1, r3
 80279cc:	6878      	ldr	r0, [r7, #4]
 80279ce:	f7f7 fedc 	bl	801f78a <wc_RNG_GenerateBlock>
 80279d2:	6178      	str	r0, [r7, #20]
    }
    if (ret == MP_OKAY) {
 80279d4:	697b      	ldr	r3, [r7, #20]
 80279d6:	2b00      	cmp	r3, #0
 80279d8:	d11a      	bne.n	8027a10 <mp_rand+0xa6>
        for (i = 0; i < a->used; i++) {
            a->dp[i] &= MP_MASK;
        }
#endif
        /* ensure top digit is not zero */
        while ((ret == MP_OKAY) && (a->dp[a->used - 1] == 0)) {
 80279da:	e00c      	b.n	80279f6 <mp_rand+0x8c>
            ret = get_rand_digit(rng, &a->dp[a->used - 1]);
 80279dc:	68fb      	ldr	r3, [r7, #12]
 80279de:	681b      	ldr	r3, [r3, #0]
 80279e0:	3b01      	subs	r3, #1
 80279e2:	3302      	adds	r3, #2
 80279e4:	009b      	lsls	r3, r3, #2
 80279e6:	68fa      	ldr	r2, [r7, #12]
 80279e8:	4413      	add	r3, r2
 80279ea:	3304      	adds	r3, #4
 80279ec:	4619      	mov	r1, r3
 80279ee:	6878      	ldr	r0, [r7, #4]
 80279f0:	f7ff ffac 	bl	802794c <get_rand_digit>
 80279f4:	6178      	str	r0, [r7, #20]
        while ((ret == MP_OKAY) && (a->dp[a->used - 1] == 0)) {
 80279f6:	697b      	ldr	r3, [r7, #20]
 80279f8:	2b00      	cmp	r3, #0
 80279fa:	d109      	bne.n	8027a10 <mp_rand+0xa6>
 80279fc:	68fb      	ldr	r3, [r7, #12]
 80279fe:	681b      	ldr	r3, [r3, #0]
 8027a00:	3b01      	subs	r3, #1
 8027a02:	68fa      	ldr	r2, [r7, #12]
 8027a04:	3302      	adds	r3, #2
 8027a06:	009b      	lsls	r3, r3, #2
 8027a08:	4413      	add	r3, r2
 8027a0a:	685b      	ldr	r3, [r3, #4]
 8027a0c:	2b00      	cmp	r3, #0
 8027a0e:	d0e5      	beq.n	80279dc <mp_rand+0x72>
            a->dp[a->used - 1] &= MP_MASK;
#endif
        }
    }

    return ret;
 8027a10:	697b      	ldr	r3, [r7, #20]
}
 8027a12:	4618      	mov	r0, r3
 8027a14:	3718      	adds	r7, #24
 8027a16:	46bd      	mov	sp, r7
 8027a18:	bd80      	pop	{r7, pc}
	...

08027a1c <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 8027a1c:	b580      	push	{r7, lr}
 8027a1e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 8027a20:	2200      	movs	r2, #0
 8027a22:	4912      	ldr	r1, [pc, #72]	@ (8027a6c <MX_USB_DEVICE_Init+0x50>)
 8027a24:	4812      	ldr	r0, [pc, #72]	@ (8027a70 <MX_USB_DEVICE_Init+0x54>)
 8027a26:	f7df fce9 	bl	80073fc <USBD_Init>
 8027a2a:	4603      	mov	r3, r0
 8027a2c:	2b00      	cmp	r3, #0
 8027a2e:	d001      	beq.n	8027a34 <MX_USB_DEVICE_Init+0x18>
  {
    Error_Handler();
 8027a30:	f7d9 ff30 	bl	8001894 <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 8027a34:	490f      	ldr	r1, [pc, #60]	@ (8027a74 <MX_USB_DEVICE_Init+0x58>)
 8027a36:	480e      	ldr	r0, [pc, #56]	@ (8027a70 <MX_USB_DEVICE_Init+0x54>)
 8027a38:	f7df fd10 	bl	800745c <USBD_RegisterClass>
 8027a3c:	4603      	mov	r3, r0
 8027a3e:	2b00      	cmp	r3, #0
 8027a40:	d001      	beq.n	8027a46 <MX_USB_DEVICE_Init+0x2a>
  {
    Error_Handler();
 8027a42:	f7d9 ff27 	bl	8001894 <Error_Handler>
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 8027a46:	490c      	ldr	r1, [pc, #48]	@ (8027a78 <MX_USB_DEVICE_Init+0x5c>)
 8027a48:	4809      	ldr	r0, [pc, #36]	@ (8027a70 <MX_USB_DEVICE_Init+0x54>)
 8027a4a:	f7df fc07 	bl	800725c <USBD_CDC_RegisterInterface>
 8027a4e:	4603      	mov	r3, r0
 8027a50:	2b00      	cmp	r3, #0
 8027a52:	d001      	beq.n	8027a58 <MX_USB_DEVICE_Init+0x3c>
  {
    Error_Handler();
 8027a54:	f7d9 ff1e 	bl	8001894 <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 8027a58:	4805      	ldr	r0, [pc, #20]	@ (8027a70 <MX_USB_DEVICE_Init+0x54>)
 8027a5a:	f7df fd35 	bl	80074c8 <USBD_Start>
 8027a5e:	4603      	mov	r3, r0
 8027a60:	2b00      	cmp	r3, #0
 8027a62:	d001      	beq.n	8027a68 <MX_USB_DEVICE_Init+0x4c>
  {
    Error_Handler();
 8027a64:	f7d9 ff16 	bl	8001894 <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 8027a68:	bf00      	nop
 8027a6a:	bd80      	pop	{r7, pc}
 8027a6c:	200000e4 	.word	0x200000e4
 8027a70:	20001c58 	.word	0x20001c58
 8027a74:	20000030 	.word	0x20000030
 8027a78:	200000d0 	.word	0x200000d0

08027a7c <CDC_Init_FS>:
/**
  * @brief  Initializes the CDC media low layer over the FS USB IP
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
 8027a7c:	b580      	push	{r7, lr}
 8027a7e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 3 */
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 8027a80:	2200      	movs	r2, #0
 8027a82:	4905      	ldr	r1, [pc, #20]	@ (8027a98 <CDC_Init_FS+0x1c>)
 8027a84:	4805      	ldr	r0, [pc, #20]	@ (8027a9c <CDC_Init_FS+0x20>)
 8027a86:	f7df fc03 	bl	8007290 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 8027a8a:	4905      	ldr	r1, [pc, #20]	@ (8027aa0 <CDC_Init_FS+0x24>)
 8027a8c:	4803      	ldr	r0, [pc, #12]	@ (8027a9c <CDC_Init_FS+0x20>)
 8027a8e:	f7df fc21 	bl	80072d4 <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
 8027a92:	2300      	movs	r3, #0
  /* USER CODE END 3 */
}
 8027a94:	4618      	mov	r0, r3
 8027a96:	bd80      	pop	{r7, pc}
 8027a98:	20002734 	.word	0x20002734
 8027a9c:	20001c58 	.word	0x20001c58
 8027aa0:	20001f34 	.word	0x20001f34

08027aa4 <CDC_DeInit_FS>:
/**
  * @brief  DeInitializes the CDC media low layer
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_DeInit_FS(void)
{
 8027aa4:	b480      	push	{r7}
 8027aa6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
 8027aa8:	2300      	movs	r3, #0
  /* USER CODE END 4 */
}
 8027aaa:	4618      	mov	r0, r3
 8027aac:	46bd      	mov	sp, r7
 8027aae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027ab2:	4770      	bx	lr

08027ab4 <CDC_Control_FS>:
  * @param  pbuf: Buffer containing command data (request parameters)
  * @param  length: Number of data to be sent (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
 8027ab4:	b480      	push	{r7}
 8027ab6:	b083      	sub	sp, #12
 8027ab8:	af00      	add	r7, sp, #0
 8027aba:	4603      	mov	r3, r0
 8027abc:	6039      	str	r1, [r7, #0]
 8027abe:	71fb      	strb	r3, [r7, #7]
 8027ac0:	4613      	mov	r3, r2
 8027ac2:	80bb      	strh	r3, [r7, #4]
  /* USER CODE BEGIN 5 */
  switch(cmd)
 8027ac4:	79fb      	ldrb	r3, [r7, #7]
 8027ac6:	2b23      	cmp	r3, #35	@ 0x23
 8027ac8:	f200 808c 	bhi.w	8027be4 <CDC_Control_FS+0x130>
 8027acc:	a201      	add	r2, pc, #4	@ (adr r2, 8027ad4 <CDC_Control_FS+0x20>)
 8027ace:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8027ad2:	bf00      	nop
 8027ad4:	08027be5 	.word	0x08027be5
 8027ad8:	08027be5 	.word	0x08027be5
 8027adc:	08027be5 	.word	0x08027be5
 8027ae0:	08027be5 	.word	0x08027be5
 8027ae4:	08027be5 	.word	0x08027be5
 8027ae8:	08027be5 	.word	0x08027be5
 8027aec:	08027be5 	.word	0x08027be5
 8027af0:	08027be5 	.word	0x08027be5
 8027af4:	08027be5 	.word	0x08027be5
 8027af8:	08027be5 	.word	0x08027be5
 8027afc:	08027be5 	.word	0x08027be5
 8027b00:	08027be5 	.word	0x08027be5
 8027b04:	08027be5 	.word	0x08027be5
 8027b08:	08027be5 	.word	0x08027be5
 8027b0c:	08027be5 	.word	0x08027be5
 8027b10:	08027be5 	.word	0x08027be5
 8027b14:	08027be5 	.word	0x08027be5
 8027b18:	08027be5 	.word	0x08027be5
 8027b1c:	08027be5 	.word	0x08027be5
 8027b20:	08027be5 	.word	0x08027be5
 8027b24:	08027be5 	.word	0x08027be5
 8027b28:	08027be5 	.word	0x08027be5
 8027b2c:	08027be5 	.word	0x08027be5
 8027b30:	08027be5 	.word	0x08027be5
 8027b34:	08027be5 	.word	0x08027be5
 8027b38:	08027be5 	.word	0x08027be5
 8027b3c:	08027be5 	.word	0x08027be5
 8027b40:	08027be5 	.word	0x08027be5
 8027b44:	08027be5 	.word	0x08027be5
 8027b48:	08027be5 	.word	0x08027be5
 8027b4c:	08027be5 	.word	0x08027be5
 8027b50:	08027be5 	.word	0x08027be5
 8027b54:	08027b65 	.word	0x08027b65
 8027b58:	08027b9f 	.word	0x08027b9f
 8027b5c:	08027be5 	.word	0x08027be5
 8027b60:	08027be5 	.word	0x08027be5
  /*                                        3 - Mark                             */
  /*                                        4 - Space                            */
  /* 6      | bDataBits  |   1   | Number Data bits (5, 6, 7, 8 or 16).          */
  /*******************************************************************************/
    case CDC_SET_LINE_CODING:
    	temp[0] = pbuf[0];
 8027b64:	683b      	ldr	r3, [r7, #0]
 8027b66:	781a      	ldrb	r2, [r3, #0]
 8027b68:	4b22      	ldr	r3, [pc, #136]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027b6a:	701a      	strb	r2, [r3, #0]
    	temp[1] = pbuf[1];
 8027b6c:	683b      	ldr	r3, [r7, #0]
 8027b6e:	785a      	ldrb	r2, [r3, #1]
 8027b70:	4b20      	ldr	r3, [pc, #128]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027b72:	705a      	strb	r2, [r3, #1]
    	temp[2] = pbuf[2];
 8027b74:	683b      	ldr	r3, [r7, #0]
 8027b76:	789a      	ldrb	r2, [r3, #2]
 8027b78:	4b1e      	ldr	r3, [pc, #120]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027b7a:	709a      	strb	r2, [r3, #2]
    	temp[3] = pbuf[3];
 8027b7c:	683b      	ldr	r3, [r7, #0]
 8027b7e:	78da      	ldrb	r2, [r3, #3]
 8027b80:	4b1c      	ldr	r3, [pc, #112]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027b82:	70da      	strb	r2, [r3, #3]
    	temp[4] = pbuf[4];
 8027b84:	683b      	ldr	r3, [r7, #0]
 8027b86:	791a      	ldrb	r2, [r3, #4]
 8027b88:	4b1a      	ldr	r3, [pc, #104]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027b8a:	711a      	strb	r2, [r3, #4]
    	temp[5] = pbuf[5];
 8027b8c:	683b      	ldr	r3, [r7, #0]
 8027b8e:	795a      	ldrb	r2, [r3, #5]
 8027b90:	4b18      	ldr	r3, [pc, #96]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027b92:	715a      	strb	r2, [r3, #5]
    	temp[6] = pbuf[6];
 8027b94:	683b      	ldr	r3, [r7, #0]
 8027b96:	799a      	ldrb	r2, [r3, #6]
 8027b98:	4b16      	ldr	r3, [pc, #88]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027b9a:	719a      	strb	r2, [r3, #6]
    break;
 8027b9c:	e023      	b.n	8027be6 <CDC_Control_FS+0x132>

    case CDC_GET_LINE_CODING:
    	pbuf[0] = temp[0];
 8027b9e:	4b15      	ldr	r3, [pc, #84]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027ba0:	781a      	ldrb	r2, [r3, #0]
 8027ba2:	683b      	ldr	r3, [r7, #0]
 8027ba4:	701a      	strb	r2, [r3, #0]
    	pbuf[1] = temp[1];
 8027ba6:	683b      	ldr	r3, [r7, #0]
 8027ba8:	3301      	adds	r3, #1
 8027baa:	4a12      	ldr	r2, [pc, #72]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027bac:	7852      	ldrb	r2, [r2, #1]
 8027bae:	701a      	strb	r2, [r3, #0]
    	pbuf[2] = temp[2];
 8027bb0:	683b      	ldr	r3, [r7, #0]
 8027bb2:	3302      	adds	r3, #2
 8027bb4:	4a0f      	ldr	r2, [pc, #60]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027bb6:	7892      	ldrb	r2, [r2, #2]
 8027bb8:	701a      	strb	r2, [r3, #0]
    	pbuf[3] = temp[3];
 8027bba:	683b      	ldr	r3, [r7, #0]
 8027bbc:	3303      	adds	r3, #3
 8027bbe:	4a0d      	ldr	r2, [pc, #52]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027bc0:	78d2      	ldrb	r2, [r2, #3]
 8027bc2:	701a      	strb	r2, [r3, #0]
    	pbuf[4] = temp[4];
 8027bc4:	683b      	ldr	r3, [r7, #0]
 8027bc6:	3304      	adds	r3, #4
 8027bc8:	4a0a      	ldr	r2, [pc, #40]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027bca:	7912      	ldrb	r2, [r2, #4]
 8027bcc:	701a      	strb	r2, [r3, #0]
    	pbuf[5] = temp[5];
 8027bce:	683b      	ldr	r3, [r7, #0]
 8027bd0:	3305      	adds	r3, #5
 8027bd2:	4a08      	ldr	r2, [pc, #32]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027bd4:	7952      	ldrb	r2, [r2, #5]
 8027bd6:	701a      	strb	r2, [r3, #0]
    	pbuf[6] = temp[6];
 8027bd8:	683b      	ldr	r3, [r7, #0]
 8027bda:	3306      	adds	r3, #6
 8027bdc:	4a05      	ldr	r2, [pc, #20]	@ (8027bf4 <CDC_Control_FS+0x140>)
 8027bde:	7992      	ldrb	r2, [r2, #6]
 8027be0:	701a      	strb	r2, [r3, #0]
    break;
 8027be2:	e000      	b.n	8027be6 <CDC_Control_FS+0x132>
    case CDC_SEND_BREAK:

    break;

  default:
    break;
 8027be4:	bf00      	nop
  }

  return (USBD_OK);
 8027be6:	2300      	movs	r3, #0
  /* USER CODE END 5 */
}
 8027be8:	4618      	mov	r0, r3
 8027bea:	370c      	adds	r7, #12
 8027bec:	46bd      	mov	sp, r7
 8027bee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027bf2:	4770      	bx	lr
 8027bf4:	20002f34 	.word	0x20002f34

08027bf8 <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
 8027bf8:	b580      	push	{r7, lr}
 8027bfa:	b082      	sub	sp, #8
 8027bfc:	af00      	add	r7, sp, #0
 8027bfe:	6078      	str	r0, [r7, #4]
 8027c00:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 8027c02:	6879      	ldr	r1, [r7, #4]
 8027c04:	4823      	ldr	r0, [pc, #140]	@ (8027c94 <CDC_Receive_FS+0x9c>)
 8027c06:	f7df fb65 	bl	80072d4 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 8027c0a:	4822      	ldr	r0, [pc, #136]	@ (8027c94 <CDC_Receive_FS+0x9c>)
 8027c0c:	f7df fbc0 	bl	8007390 <USBD_CDC_ReceivePacket>
  if (*Len == 0 || Buf == NULL) return USBD_OK;
 8027c10:	683b      	ldr	r3, [r7, #0]
 8027c12:	681b      	ldr	r3, [r3, #0]
 8027c14:	2b00      	cmp	r3, #0
 8027c16:	d002      	beq.n	8027c1e <CDC_Receive_FS+0x26>
 8027c18:	687b      	ldr	r3, [r7, #4]
 8027c1a:	2b00      	cmp	r3, #0
 8027c1c:	d101      	bne.n	8027c22 <CDC_Receive_FS+0x2a>
 8027c1e:	2300      	movs	r3, #0
 8027c20:	e033      	b.n	8027c8a <CDC_Receive_FS+0x92>
  // spravy sa prijimaju po 64 bytovych kuskoch - paketoch
  // po odoslani celej spravy posielam dalsiu, ktora sa sklada iba zo znaku '\r', teda dlzka je 1
  // teoreticky moze nastat edge case kedy povodna sprava sa tak rozkuskuje
  // ze posledny byte spravy pride sam a sklada sa iba z '\r' co vtedy by nastal problem, ale je to worth fixing?
  // uz len to ze som mal edge case ze prijaty paket sa zacina prave na '\r' je celkom uletene
  if (Buf[0] == '\r' && *Len == 1) {
 8027c22:	687b      	ldr	r3, [r7, #4]
 8027c24:	781b      	ldrb	r3, [r3, #0]
 8027c26:	2b0d      	cmp	r3, #13
 8027c28:	d108      	bne.n	8027c3c <CDC_Receive_FS+0x44>
 8027c2a:	683b      	ldr	r3, [r7, #0]
 8027c2c:	681b      	ldr	r3, [r3, #0]
 8027c2e:	2b01      	cmp	r3, #1
 8027c30:	d104      	bne.n	8027c3c <CDC_Receive_FS+0x44>
      dataReceivedFlag = 1;
 8027c32:	4b19      	ldr	r3, [pc, #100]	@ (8027c98 <CDC_Receive_FS+0xa0>)
 8027c34:	2201      	movs	r2, #1
 8027c36:	701a      	strb	r2, [r3, #0]
      return USBD_OK;
 8027c38:	2300      	movs	r3, #0
 8027c3a:	e026      	b.n	8027c8a <CDC_Receive_FS+0x92>
  }
  // receiveBuffer ma velkost 2048, nie je to dobre ze je to takto hardcoded
  // ale iba 3. sprava sa k tomu velkostne blizi
  if ((receiveCounter + *Len) < 2500) {
 8027c3c:	4b17      	ldr	r3, [pc, #92]	@ (8027c9c <CDC_Receive_FS+0xa4>)
 8027c3e:	881b      	ldrh	r3, [r3, #0]
 8027c40:	461a      	mov	r2, r3
 8027c42:	683b      	ldr	r3, [r7, #0]
 8027c44:	681b      	ldr	r3, [r3, #0]
 8027c46:	4413      	add	r3, r2
 8027c48:	f640 12c3 	movw	r2, #2499	@ 0x9c3
 8027c4c:	4293      	cmp	r3, r2
 8027c4e:	d815      	bhi.n	8027c7c <CDC_Receive_FS+0x84>
      memcpy(&receiveBuffer[receiveCounter], Buf, *Len);
 8027c50:	4b12      	ldr	r3, [pc, #72]	@ (8027c9c <CDC_Receive_FS+0xa4>)
 8027c52:	881b      	ldrh	r3, [r3, #0]
 8027c54:	461a      	mov	r2, r3
 8027c56:	4b12      	ldr	r3, [pc, #72]	@ (8027ca0 <CDC_Receive_FS+0xa8>)
 8027c58:	18d0      	adds	r0, r2, r3
 8027c5a:	683b      	ldr	r3, [r7, #0]
 8027c5c:	681b      	ldr	r3, [r3, #0]
 8027c5e:	461a      	mov	r2, r3
 8027c60:	6879      	ldr	r1, [r7, #4]
 8027c62:	f001 f890 	bl	8028d86 <memcpy>
      receiveCounter += *Len;
 8027c66:	683b      	ldr	r3, [r7, #0]
 8027c68:	681b      	ldr	r3, [r3, #0]
 8027c6a:	b29a      	uxth	r2, r3
 8027c6c:	4b0b      	ldr	r3, [pc, #44]	@ (8027c9c <CDC_Receive_FS+0xa4>)
 8027c6e:	881b      	ldrh	r3, [r3, #0]
 8027c70:	4413      	add	r3, r2
 8027c72:	b29a      	uxth	r2, r3
 8027c74:	4b09      	ldr	r3, [pc, #36]	@ (8027c9c <CDC_Receive_FS+0xa4>)
 8027c76:	801a      	strh	r2, [r3, #0]
      // Buffer overflow handler, asi to rovno deletnem jak boss
      receiveCounter = 0;
      dataReceivedFlag = 0;
      return USBD_FAIL;
  }
  return USBD_OK;
 8027c78:	2300      	movs	r3, #0
 8027c7a:	e006      	b.n	8027c8a <CDC_Receive_FS+0x92>
      receiveCounter = 0;
 8027c7c:	4b07      	ldr	r3, [pc, #28]	@ (8027c9c <CDC_Receive_FS+0xa4>)
 8027c7e:	2200      	movs	r2, #0
 8027c80:	801a      	strh	r2, [r3, #0]
      dataReceivedFlag = 0;
 8027c82:	4b05      	ldr	r3, [pc, #20]	@ (8027c98 <CDC_Receive_FS+0xa0>)
 8027c84:	2200      	movs	r2, #0
 8027c86:	701a      	strb	r2, [r3, #0]
      return USBD_FAIL;
 8027c88:	2303      	movs	r3, #3
  /* USER CODE END 6 */
}
 8027c8a:	4618      	mov	r0, r3
 8027c8c:	3708      	adds	r7, #8
 8027c8e:	46bd      	mov	sp, r7
 8027c90:	bd80      	pop	{r7, pc}
 8027c92:	bf00      	nop
 8027c94:	20001c58 	.word	0x20001c58
 8027c98:	20000850 	.word	0x20000850
 8027c9c:	20001218 	.word	0x20001218
 8027ca0:	20000854 	.word	0x20000854

08027ca4 <CDC_Transmit_FS>:
  * @param  Buf: Buffer of data to be sent
  * @param  Len: Number of data to be sent (in bytes)
  * @retval USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
 8027ca4:	b580      	push	{r7, lr}
 8027ca6:	b084      	sub	sp, #16
 8027ca8:	af00      	add	r7, sp, #0
 8027caa:	6078      	str	r0, [r7, #4]
 8027cac:	460b      	mov	r3, r1
 8027cae:	807b      	strh	r3, [r7, #2]
  uint8_t result = USBD_OK;
 8027cb0:	2300      	movs	r3, #0
 8027cb2:	73fb      	strb	r3, [r7, #15]
  /* USER CODE BEGIN 7 */
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 8027cb4:	4b0d      	ldr	r3, [pc, #52]	@ (8027cec <CDC_Transmit_FS+0x48>)
 8027cb6:	f8d3 32bc 	ldr.w	r3, [r3, #700]	@ 0x2bc
 8027cba:	60bb      	str	r3, [r7, #8]
  if (hcdc->TxState != 0){
 8027cbc:	68bb      	ldr	r3, [r7, #8]
 8027cbe:	f8d3 3214 	ldr.w	r3, [r3, #532]	@ 0x214
 8027cc2:	2b00      	cmp	r3, #0
 8027cc4:	d001      	beq.n	8027cca <CDC_Transmit_FS+0x26>
    return USBD_BUSY;
 8027cc6:	2301      	movs	r3, #1
 8027cc8:	e00b      	b.n	8027ce2 <CDC_Transmit_FS+0x3e>
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 8027cca:	887b      	ldrh	r3, [r7, #2]
 8027ccc:	461a      	mov	r2, r3
 8027cce:	6879      	ldr	r1, [r7, #4]
 8027cd0:	4806      	ldr	r0, [pc, #24]	@ (8027cec <CDC_Transmit_FS+0x48>)
 8027cd2:	f7df fadd 	bl	8007290 <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 8027cd6:	4805      	ldr	r0, [pc, #20]	@ (8027cec <CDC_Transmit_FS+0x48>)
 8027cd8:	f7df fb1a 	bl	8007310 <USBD_CDC_TransmitPacket>
 8027cdc:	4603      	mov	r3, r0
 8027cde:	73fb      	strb	r3, [r7, #15]
  /* USER CODE END 7 */
  return result;
 8027ce0:	7bfb      	ldrb	r3, [r7, #15]
}
 8027ce2:	4618      	mov	r0, r3
 8027ce4:	3710      	adds	r7, #16
 8027ce6:	46bd      	mov	sp, r7
 8027ce8:	bd80      	pop	{r7, pc}
 8027cea:	bf00      	nop
 8027cec:	20001c58 	.word	0x20001c58

08027cf0 <CDC_TransmitCplt_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_TransmitCplt_FS(uint8_t *Buf, uint32_t *Len, uint8_t epnum)
{
 8027cf0:	b480      	push	{r7}
 8027cf2:	b087      	sub	sp, #28
 8027cf4:	af00      	add	r7, sp, #0
 8027cf6:	60f8      	str	r0, [r7, #12]
 8027cf8:	60b9      	str	r1, [r7, #8]
 8027cfa:	4613      	mov	r3, r2
 8027cfc:	71fb      	strb	r3, [r7, #7]
  uint8_t result = USBD_OK;
 8027cfe:	2300      	movs	r3, #0
 8027d00:	75fb      	strb	r3, [r7, #23]
  /* USER CODE BEGIN 13 */
  UNUSED(Buf);
  UNUSED(Len);
  UNUSED(epnum);
  /* USER CODE END 13 */
  return result;
 8027d02:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 8027d06:	4618      	mov	r0, r3
 8027d08:	371c      	adds	r7, #28
 8027d0a:	46bd      	mov	sp, r7
 8027d0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027d10:	4770      	bx	lr
	...

08027d14 <USBD_FS_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027d14:	b480      	push	{r7}
 8027d16:	b083      	sub	sp, #12
 8027d18:	af00      	add	r7, sp, #0
 8027d1a:	4603      	mov	r3, r0
 8027d1c:	6039      	str	r1, [r7, #0]
 8027d1e:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 8027d20:	683b      	ldr	r3, [r7, #0]
 8027d22:	2212      	movs	r2, #18
 8027d24:	801a      	strh	r2, [r3, #0]
  return USBD_FS_DeviceDesc;
 8027d26:	4b03      	ldr	r3, [pc, #12]	@ (8027d34 <USBD_FS_DeviceDescriptor+0x20>)
}
 8027d28:	4618      	mov	r0, r3
 8027d2a:	370c      	adds	r7, #12
 8027d2c:	46bd      	mov	sp, r7
 8027d2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027d32:	4770      	bx	lr
 8027d34:	20000100 	.word	0x20000100

08027d38 <USBD_FS_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027d38:	b480      	push	{r7}
 8027d3a:	b083      	sub	sp, #12
 8027d3c:	af00      	add	r7, sp, #0
 8027d3e:	4603      	mov	r3, r0
 8027d40:	6039      	str	r1, [r7, #0]
 8027d42:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 8027d44:	683b      	ldr	r3, [r7, #0]
 8027d46:	2204      	movs	r2, #4
 8027d48:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 8027d4a:	4b03      	ldr	r3, [pc, #12]	@ (8027d58 <USBD_FS_LangIDStrDescriptor+0x20>)
}
 8027d4c:	4618      	mov	r0, r3
 8027d4e:	370c      	adds	r7, #12
 8027d50:	46bd      	mov	sp, r7
 8027d52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027d56:	4770      	bx	lr
 8027d58:	20000114 	.word	0x20000114

08027d5c <USBD_FS_ProductStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027d5c:	b580      	push	{r7, lr}
 8027d5e:	b082      	sub	sp, #8
 8027d60:	af00      	add	r7, sp, #0
 8027d62:	4603      	mov	r3, r0
 8027d64:	6039      	str	r1, [r7, #0]
 8027d66:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8027d68:	79fb      	ldrb	r3, [r7, #7]
 8027d6a:	2b00      	cmp	r3, #0
 8027d6c:	d105      	bne.n	8027d7a <USBD_FS_ProductStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8027d6e:	683a      	ldr	r2, [r7, #0]
 8027d70:	4907      	ldr	r1, [pc, #28]	@ (8027d90 <USBD_FS_ProductStrDescriptor+0x34>)
 8027d72:	4808      	ldr	r0, [pc, #32]	@ (8027d94 <USBD_FS_ProductStrDescriptor+0x38>)
 8027d74:	f7e0 fd58 	bl	8008828 <USBD_GetString>
 8027d78:	e004      	b.n	8027d84 <USBD_FS_ProductStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8027d7a:	683a      	ldr	r2, [r7, #0]
 8027d7c:	4904      	ldr	r1, [pc, #16]	@ (8027d90 <USBD_FS_ProductStrDescriptor+0x34>)
 8027d7e:	4805      	ldr	r0, [pc, #20]	@ (8027d94 <USBD_FS_ProductStrDescriptor+0x38>)
 8027d80:	f7e0 fd52 	bl	8008828 <USBD_GetString>
  }
  return USBD_StrDesc;
 8027d84:	4b02      	ldr	r3, [pc, #8]	@ (8027d90 <USBD_FS_ProductStrDescriptor+0x34>)
}
 8027d86:	4618      	mov	r0, r3
 8027d88:	3708      	adds	r7, #8
 8027d8a:	46bd      	mov	sp, r7
 8027d8c:	bd80      	pop	{r7, pc}
 8027d8e:	bf00      	nop
 8027d90:	20002f3c 	.word	0x20002f3c
 8027d94:	08030d40 	.word	0x08030d40

08027d98 <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027d98:	b580      	push	{r7, lr}
 8027d9a:	b082      	sub	sp, #8
 8027d9c:	af00      	add	r7, sp, #0
 8027d9e:	4603      	mov	r3, r0
 8027da0:	6039      	str	r1, [r7, #0]
 8027da2:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8027da4:	683a      	ldr	r2, [r7, #0]
 8027da6:	4904      	ldr	r1, [pc, #16]	@ (8027db8 <USBD_FS_ManufacturerStrDescriptor+0x20>)
 8027da8:	4804      	ldr	r0, [pc, #16]	@ (8027dbc <USBD_FS_ManufacturerStrDescriptor+0x24>)
 8027daa:	f7e0 fd3d 	bl	8008828 <USBD_GetString>
  return USBD_StrDesc;
 8027dae:	4b02      	ldr	r3, [pc, #8]	@ (8027db8 <USBD_FS_ManufacturerStrDescriptor+0x20>)
}
 8027db0:	4618      	mov	r0, r3
 8027db2:	3708      	adds	r7, #8
 8027db4:	46bd      	mov	sp, r7
 8027db6:	bd80      	pop	{r7, pc}
 8027db8:	20002f3c 	.word	0x20002f3c
 8027dbc:	08030d58 	.word	0x08030d58

08027dc0 <USBD_FS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027dc0:	b580      	push	{r7, lr}
 8027dc2:	b082      	sub	sp, #8
 8027dc4:	af00      	add	r7, sp, #0
 8027dc6:	4603      	mov	r3, r0
 8027dc8:	6039      	str	r1, [r7, #0]
 8027dca:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
 8027dcc:	683b      	ldr	r3, [r7, #0]
 8027dce:	221a      	movs	r2, #26
 8027dd0:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
 8027dd2:	f000 f843 	bl	8027e5c <Get_SerialNum>
  /* USER CODE BEGIN USBD_FS_SerialStrDescriptor */

  /* USER CODE END USBD_FS_SerialStrDescriptor */
  return (uint8_t *) USBD_StringSerial;
 8027dd6:	4b02      	ldr	r3, [pc, #8]	@ (8027de0 <USBD_FS_SerialStrDescriptor+0x20>)
}
 8027dd8:	4618      	mov	r0, r3
 8027dda:	3708      	adds	r7, #8
 8027ddc:	46bd      	mov	sp, r7
 8027dde:	bd80      	pop	{r7, pc}
 8027de0:	20000118 	.word	0x20000118

08027de4 <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027de4:	b580      	push	{r7, lr}
 8027de6:	b082      	sub	sp, #8
 8027de8:	af00      	add	r7, sp, #0
 8027dea:	4603      	mov	r3, r0
 8027dec:	6039      	str	r1, [r7, #0]
 8027dee:	71fb      	strb	r3, [r7, #7]
  if(speed == USBD_SPEED_HIGH)
 8027df0:	79fb      	ldrb	r3, [r7, #7]
 8027df2:	2b00      	cmp	r3, #0
 8027df4:	d105      	bne.n	8027e02 <USBD_FS_ConfigStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8027df6:	683a      	ldr	r2, [r7, #0]
 8027df8:	4907      	ldr	r1, [pc, #28]	@ (8027e18 <USBD_FS_ConfigStrDescriptor+0x34>)
 8027dfa:	4808      	ldr	r0, [pc, #32]	@ (8027e1c <USBD_FS_ConfigStrDescriptor+0x38>)
 8027dfc:	f7e0 fd14 	bl	8008828 <USBD_GetString>
 8027e00:	e004      	b.n	8027e0c <USBD_FS_ConfigStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8027e02:	683a      	ldr	r2, [r7, #0]
 8027e04:	4904      	ldr	r1, [pc, #16]	@ (8027e18 <USBD_FS_ConfigStrDescriptor+0x34>)
 8027e06:	4805      	ldr	r0, [pc, #20]	@ (8027e1c <USBD_FS_ConfigStrDescriptor+0x38>)
 8027e08:	f7e0 fd0e 	bl	8008828 <USBD_GetString>
  }
  return USBD_StrDesc;
 8027e0c:	4b02      	ldr	r3, [pc, #8]	@ (8027e18 <USBD_FS_ConfigStrDescriptor+0x34>)
}
 8027e0e:	4618      	mov	r0, r3
 8027e10:	3708      	adds	r7, #8
 8027e12:	46bd      	mov	sp, r7
 8027e14:	bd80      	pop	{r7, pc}
 8027e16:	bf00      	nop
 8027e18:	20002f3c 	.word	0x20002f3c
 8027e1c:	08030d6c 	.word	0x08030d6c

08027e20 <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027e20:	b580      	push	{r7, lr}
 8027e22:	b082      	sub	sp, #8
 8027e24:	af00      	add	r7, sp, #0
 8027e26:	4603      	mov	r3, r0
 8027e28:	6039      	str	r1, [r7, #0]
 8027e2a:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8027e2c:	79fb      	ldrb	r3, [r7, #7]
 8027e2e:	2b00      	cmp	r3, #0
 8027e30:	d105      	bne.n	8027e3e <USBD_FS_InterfaceStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8027e32:	683a      	ldr	r2, [r7, #0]
 8027e34:	4907      	ldr	r1, [pc, #28]	@ (8027e54 <USBD_FS_InterfaceStrDescriptor+0x34>)
 8027e36:	4808      	ldr	r0, [pc, #32]	@ (8027e58 <USBD_FS_InterfaceStrDescriptor+0x38>)
 8027e38:	f7e0 fcf6 	bl	8008828 <USBD_GetString>
 8027e3c:	e004      	b.n	8027e48 <USBD_FS_InterfaceStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8027e3e:	683a      	ldr	r2, [r7, #0]
 8027e40:	4904      	ldr	r1, [pc, #16]	@ (8027e54 <USBD_FS_InterfaceStrDescriptor+0x34>)
 8027e42:	4805      	ldr	r0, [pc, #20]	@ (8027e58 <USBD_FS_InterfaceStrDescriptor+0x38>)
 8027e44:	f7e0 fcf0 	bl	8008828 <USBD_GetString>
  }
  return USBD_StrDesc;
 8027e48:	4b02      	ldr	r3, [pc, #8]	@ (8027e54 <USBD_FS_InterfaceStrDescriptor+0x34>)
}
 8027e4a:	4618      	mov	r0, r3
 8027e4c:	3708      	adds	r7, #8
 8027e4e:	46bd      	mov	sp, r7
 8027e50:	bd80      	pop	{r7, pc}
 8027e52:	bf00      	nop
 8027e54:	20002f3c 	.word	0x20002f3c
 8027e58:	08030d78 	.word	0x08030d78

08027e5c <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
 8027e5c:	b580      	push	{r7, lr}
 8027e5e:	b084      	sub	sp, #16
 8027e60:	af00      	add	r7, sp, #0
  uint32_t deviceserial0;
  uint32_t deviceserial1;
  uint32_t deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 8027e62:	4b0f      	ldr	r3, [pc, #60]	@ (8027ea0 <Get_SerialNum+0x44>)
 8027e64:	681b      	ldr	r3, [r3, #0]
 8027e66:	60fb      	str	r3, [r7, #12]
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 8027e68:	4b0e      	ldr	r3, [pc, #56]	@ (8027ea4 <Get_SerialNum+0x48>)
 8027e6a:	681b      	ldr	r3, [r3, #0]
 8027e6c:	60bb      	str	r3, [r7, #8]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 8027e6e:	4b0e      	ldr	r3, [pc, #56]	@ (8027ea8 <Get_SerialNum+0x4c>)
 8027e70:	681b      	ldr	r3, [r3, #0]
 8027e72:	607b      	str	r3, [r7, #4]

  deviceserial0 += deviceserial2;
 8027e74:	68fa      	ldr	r2, [r7, #12]
 8027e76:	687b      	ldr	r3, [r7, #4]
 8027e78:	4413      	add	r3, r2
 8027e7a:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
 8027e7c:	68fb      	ldr	r3, [r7, #12]
 8027e7e:	2b00      	cmp	r3, #0
 8027e80:	d009      	beq.n	8027e96 <Get_SerialNum+0x3a>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 8027e82:	2208      	movs	r2, #8
 8027e84:	4909      	ldr	r1, [pc, #36]	@ (8027eac <Get_SerialNum+0x50>)
 8027e86:	68f8      	ldr	r0, [r7, #12]
 8027e88:	f000 f814 	bl	8027eb4 <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 8027e8c:	2204      	movs	r2, #4
 8027e8e:	4908      	ldr	r1, [pc, #32]	@ (8027eb0 <Get_SerialNum+0x54>)
 8027e90:	68b8      	ldr	r0, [r7, #8]
 8027e92:	f000 f80f 	bl	8027eb4 <IntToUnicode>
  }
}
 8027e96:	bf00      	nop
 8027e98:	3710      	adds	r7, #16
 8027e9a:	46bd      	mov	sp, r7
 8027e9c:	bd80      	pop	{r7, pc}
 8027e9e:	bf00      	nop
 8027ea0:	1fff7a10 	.word	0x1fff7a10
 8027ea4:	1fff7a14 	.word	0x1fff7a14
 8027ea8:	1fff7a18 	.word	0x1fff7a18
 8027eac:	2000011a 	.word	0x2000011a
 8027eb0:	2000012a 	.word	0x2000012a

08027eb4 <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 8027eb4:	b480      	push	{r7}
 8027eb6:	b087      	sub	sp, #28
 8027eb8:	af00      	add	r7, sp, #0
 8027eba:	60f8      	str	r0, [r7, #12]
 8027ebc:	60b9      	str	r1, [r7, #8]
 8027ebe:	4613      	mov	r3, r2
 8027ec0:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
 8027ec2:	2300      	movs	r3, #0
 8027ec4:	75fb      	strb	r3, [r7, #23]

  for (idx = 0; idx < len; idx++)
 8027ec6:	2300      	movs	r3, #0
 8027ec8:	75fb      	strb	r3, [r7, #23]
 8027eca:	e027      	b.n	8027f1c <IntToUnicode+0x68>
  {
    if (((value >> 28)) < 0xA)
 8027ecc:	68fb      	ldr	r3, [r7, #12]
 8027ece:	0f1b      	lsrs	r3, r3, #28
 8027ed0:	2b09      	cmp	r3, #9
 8027ed2:	d80b      	bhi.n	8027eec <IntToUnicode+0x38>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 8027ed4:	68fb      	ldr	r3, [r7, #12]
 8027ed6:	0f1b      	lsrs	r3, r3, #28
 8027ed8:	b2da      	uxtb	r2, r3
 8027eda:	7dfb      	ldrb	r3, [r7, #23]
 8027edc:	005b      	lsls	r3, r3, #1
 8027ede:	4619      	mov	r1, r3
 8027ee0:	68bb      	ldr	r3, [r7, #8]
 8027ee2:	440b      	add	r3, r1
 8027ee4:	3230      	adds	r2, #48	@ 0x30
 8027ee6:	b2d2      	uxtb	r2, r2
 8027ee8:	701a      	strb	r2, [r3, #0]
 8027eea:	e00a      	b.n	8027f02 <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8027eec:	68fb      	ldr	r3, [r7, #12]
 8027eee:	0f1b      	lsrs	r3, r3, #28
 8027ef0:	b2da      	uxtb	r2, r3
 8027ef2:	7dfb      	ldrb	r3, [r7, #23]
 8027ef4:	005b      	lsls	r3, r3, #1
 8027ef6:	4619      	mov	r1, r3
 8027ef8:	68bb      	ldr	r3, [r7, #8]
 8027efa:	440b      	add	r3, r1
 8027efc:	3237      	adds	r2, #55	@ 0x37
 8027efe:	b2d2      	uxtb	r2, r2
 8027f00:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
 8027f02:	68fb      	ldr	r3, [r7, #12]
 8027f04:	011b      	lsls	r3, r3, #4
 8027f06:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
 8027f08:	7dfb      	ldrb	r3, [r7, #23]
 8027f0a:	005b      	lsls	r3, r3, #1
 8027f0c:	3301      	adds	r3, #1
 8027f0e:	68ba      	ldr	r2, [r7, #8]
 8027f10:	4413      	add	r3, r2
 8027f12:	2200      	movs	r2, #0
 8027f14:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
 8027f16:	7dfb      	ldrb	r3, [r7, #23]
 8027f18:	3301      	adds	r3, #1
 8027f1a:	75fb      	strb	r3, [r7, #23]
 8027f1c:	7dfa      	ldrb	r2, [r7, #23]
 8027f1e:	79fb      	ldrb	r3, [r7, #7]
 8027f20:	429a      	cmp	r2, r3
 8027f22:	d3d3      	bcc.n	8027ecc <IntToUnicode+0x18>
  }
}
 8027f24:	bf00      	nop
 8027f26:	bf00      	nop
 8027f28:	371c      	adds	r7, #28
 8027f2a:	46bd      	mov	sp, r7
 8027f2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027f30:	4770      	bx	lr
	...

08027f34 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8027f34:	b580      	push	{r7, lr}
 8027f36:	b08a      	sub	sp, #40	@ 0x28
 8027f38:	af00      	add	r7, sp, #0
 8027f3a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8027f3c:	f107 0314 	add.w	r3, r7, #20
 8027f40:	2200      	movs	r2, #0
 8027f42:	601a      	str	r2, [r3, #0]
 8027f44:	605a      	str	r2, [r3, #4]
 8027f46:	609a      	str	r2, [r3, #8]
 8027f48:	60da      	str	r2, [r3, #12]
 8027f4a:	611a      	str	r2, [r3, #16]
  if(pcdHandle->Instance==USB_OTG_FS)
 8027f4c:	687b      	ldr	r3, [r7, #4]
 8027f4e:	681b      	ldr	r3, [r3, #0]
 8027f50:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8027f54:	d147      	bne.n	8027fe6 <HAL_PCD_MspInit+0xb2>
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8027f56:	2300      	movs	r3, #0
 8027f58:	613b      	str	r3, [r7, #16]
 8027f5a:	4b25      	ldr	r3, [pc, #148]	@ (8027ff0 <HAL_PCD_MspInit+0xbc>)
 8027f5c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8027f5e:	4a24      	ldr	r2, [pc, #144]	@ (8027ff0 <HAL_PCD_MspInit+0xbc>)
 8027f60:	f043 0301 	orr.w	r3, r3, #1
 8027f64:	6313      	str	r3, [r2, #48]	@ 0x30
 8027f66:	4b22      	ldr	r3, [pc, #136]	@ (8027ff0 <HAL_PCD_MspInit+0xbc>)
 8027f68:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8027f6a:	f003 0301 	and.w	r3, r3, #1
 8027f6e:	613b      	str	r3, [r7, #16]
 8027f70:	693b      	ldr	r3, [r7, #16]
    PA9     ------> USB_OTG_FS_VBUS
    PA10     ------> USB_OTG_FS_ID
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.Pin = VBUS_FS_Pin;
 8027f72:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8027f76:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8027f78:	2300      	movs	r3, #0
 8027f7a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8027f7c:	2300      	movs	r3, #0
 8027f7e:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);
 8027f80:	f107 0314 	add.w	r3, r7, #20
 8027f84:	4619      	mov	r1, r3
 8027f86:	481b      	ldr	r0, [pc, #108]	@ (8027ff4 <HAL_PCD_MspInit+0xc0>)
 8027f88:	f7da f922 	bl	80021d0 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = OTG_FS_ID_Pin|OTG_FS_DM_Pin|OTG_FS_DP_Pin;
 8027f8c:	f44f 53e0 	mov.w	r3, #7168	@ 0x1c00
 8027f90:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8027f92:	2302      	movs	r3, #2
 8027f94:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8027f96:	2300      	movs	r3, #0
 8027f98:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8027f9a:	2300      	movs	r3, #0
 8027f9c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8027f9e:	230a      	movs	r3, #10
 8027fa0:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8027fa2:	f107 0314 	add.w	r3, r7, #20
 8027fa6:	4619      	mov	r1, r3
 8027fa8:	4812      	ldr	r0, [pc, #72]	@ (8027ff4 <HAL_PCD_MspInit+0xc0>)
 8027faa:	f7da f911 	bl	80021d0 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8027fae:	4b10      	ldr	r3, [pc, #64]	@ (8027ff0 <HAL_PCD_MspInit+0xbc>)
 8027fb0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8027fb2:	4a0f      	ldr	r2, [pc, #60]	@ (8027ff0 <HAL_PCD_MspInit+0xbc>)
 8027fb4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8027fb8:	6353      	str	r3, [r2, #52]	@ 0x34
 8027fba:	2300      	movs	r3, #0
 8027fbc:	60fb      	str	r3, [r7, #12]
 8027fbe:	4b0c      	ldr	r3, [pc, #48]	@ (8027ff0 <HAL_PCD_MspInit+0xbc>)
 8027fc0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8027fc2:	4a0b      	ldr	r2, [pc, #44]	@ (8027ff0 <HAL_PCD_MspInit+0xbc>)
 8027fc4:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8027fc8:	6453      	str	r3, [r2, #68]	@ 0x44
 8027fca:	4b09      	ldr	r3, [pc, #36]	@ (8027ff0 <HAL_PCD_MspInit+0xbc>)
 8027fcc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8027fce:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8027fd2:	60fb      	str	r3, [r7, #12]
 8027fd4:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8027fd6:	2200      	movs	r2, #0
 8027fd8:	2100      	movs	r1, #0
 8027fda:	2043      	movs	r0, #67	@ 0x43
 8027fdc:	f7da f8a5 	bl	800212a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8027fe0:	2043      	movs	r0, #67	@ 0x43
 8027fe2:	f7da f8be 	bl	8002162 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8027fe6:	bf00      	nop
 8027fe8:	3728      	adds	r7, #40	@ 0x28
 8027fea:	46bd      	mov	sp, r7
 8027fec:	bd80      	pop	{r7, pc}
 8027fee:	bf00      	nop
 8027ff0:	40023800 	.word	0x40023800
 8027ff4:	40020000 	.word	0x40020000

08027ff8 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027ff8:	b580      	push	{r7, lr}
 8027ffa:	b082      	sub	sp, #8
 8027ffc:	af00      	add	r7, sp, #0
 8027ffe:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8028000:	687b      	ldr	r3, [r7, #4]
 8028002:	f8d3 24e0 	ldr.w	r2, [r3, #1248]	@ 0x4e0
 8028006:	687b      	ldr	r3, [r7, #4]
 8028008:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 802800c:	4619      	mov	r1, r3
 802800e:	4610      	mov	r0, r2
 8028010:	f7df faa7 	bl	8007562 <USBD_LL_SetupStage>
}
 8028014:	bf00      	nop
 8028016:	3708      	adds	r7, #8
 8028018:	46bd      	mov	sp, r7
 802801a:	bd80      	pop	{r7, pc}

0802801c <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 802801c:	b580      	push	{r7, lr}
 802801e:	b082      	sub	sp, #8
 8028020:	af00      	add	r7, sp, #0
 8028022:	6078      	str	r0, [r7, #4]
 8028024:	460b      	mov	r3, r1
 8028026:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8028028:	687b      	ldr	r3, [r7, #4]
 802802a:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 802802e:	78fa      	ldrb	r2, [r7, #3]
 8028030:	6879      	ldr	r1, [r7, #4]
 8028032:	4613      	mov	r3, r2
 8028034:	00db      	lsls	r3, r3, #3
 8028036:	4413      	add	r3, r2
 8028038:	009b      	lsls	r3, r3, #2
 802803a:	440b      	add	r3, r1
 802803c:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 8028040:	681a      	ldr	r2, [r3, #0]
 8028042:	78fb      	ldrb	r3, [r7, #3]
 8028044:	4619      	mov	r1, r3
 8028046:	f7df fae1 	bl	800760c <USBD_LL_DataOutStage>
}
 802804a:	bf00      	nop
 802804c:	3708      	adds	r7, #8
 802804e:	46bd      	mov	sp, r7
 8028050:	bd80      	pop	{r7, pc}

08028052 <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028052:	b580      	push	{r7, lr}
 8028054:	b082      	sub	sp, #8
 8028056:	af00      	add	r7, sp, #0
 8028058:	6078      	str	r0, [r7, #4]
 802805a:	460b      	mov	r3, r1
 802805c:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 802805e:	687b      	ldr	r3, [r7, #4]
 8028060:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 8028064:	78fa      	ldrb	r2, [r7, #3]
 8028066:	6879      	ldr	r1, [r7, #4]
 8028068:	4613      	mov	r3, r2
 802806a:	00db      	lsls	r3, r3, #3
 802806c:	4413      	add	r3, r2
 802806e:	009b      	lsls	r3, r3, #2
 8028070:	440b      	add	r3, r1
 8028072:	3320      	adds	r3, #32
 8028074:	681a      	ldr	r2, [r3, #0]
 8028076:	78fb      	ldrb	r3, [r7, #3]
 8028078:	4619      	mov	r1, r3
 802807a:	f7df fb7a 	bl	8007772 <USBD_LL_DataInStage>
}
 802807e:	bf00      	nop
 8028080:	3708      	adds	r7, #8
 8028082:	46bd      	mov	sp, r7
 8028084:	bd80      	pop	{r7, pc}

08028086 <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028086:	b580      	push	{r7, lr}
 8028088:	b082      	sub	sp, #8
 802808a:	af00      	add	r7, sp, #0
 802808c:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 802808e:	687b      	ldr	r3, [r7, #4]
 8028090:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8028094:	4618      	mov	r0, r3
 8028096:	f7df fcb4 	bl	8007a02 <USBD_LL_SOF>
}
 802809a:	bf00      	nop
 802809c:	3708      	adds	r7, #8
 802809e:	46bd      	mov	sp, r7
 80280a0:	bd80      	pop	{r7, pc}

080280a2 <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80280a2:	b580      	push	{r7, lr}
 80280a4:	b084      	sub	sp, #16
 80280a6:	af00      	add	r7, sp, #0
 80280a8:	6078      	str	r0, [r7, #4]
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 80280aa:	2301      	movs	r3, #1
 80280ac:	73fb      	strb	r3, [r7, #15]

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 80280ae:	687b      	ldr	r3, [r7, #4]
 80280b0:	79db      	ldrb	r3, [r3, #7]
 80280b2:	2b00      	cmp	r3, #0
 80280b4:	d102      	bne.n	80280bc <HAL_PCD_ResetCallback+0x1a>
  {
    speed = USBD_SPEED_HIGH;
 80280b6:	2300      	movs	r3, #0
 80280b8:	73fb      	strb	r3, [r7, #15]
 80280ba:	e008      	b.n	80280ce <HAL_PCD_ResetCallback+0x2c>
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 80280bc:	687b      	ldr	r3, [r7, #4]
 80280be:	79db      	ldrb	r3, [r3, #7]
 80280c0:	2b02      	cmp	r3, #2
 80280c2:	d102      	bne.n	80280ca <HAL_PCD_ResetCallback+0x28>
  {
    speed = USBD_SPEED_FULL;
 80280c4:	2301      	movs	r3, #1
 80280c6:	73fb      	strb	r3, [r7, #15]
 80280c8:	e001      	b.n	80280ce <HAL_PCD_ResetCallback+0x2c>
  }
  else
  {
    Error_Handler();
 80280ca:	f7d9 fbe3 	bl	8001894 <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 80280ce:	687b      	ldr	r3, [r7, #4]
 80280d0:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 80280d4:	7bfa      	ldrb	r2, [r7, #15]
 80280d6:	4611      	mov	r1, r2
 80280d8:	4618      	mov	r0, r3
 80280da:	f7df fc4e 	bl	800797a <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 80280de:	687b      	ldr	r3, [r7, #4]
 80280e0:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 80280e4:	4618      	mov	r0, r3
 80280e6:	f7df fbf6 	bl	80078d6 <USBD_LL_Reset>
}
 80280ea:	bf00      	nop
 80280ec:	3710      	adds	r7, #16
 80280ee:	46bd      	mov	sp, r7
 80280f0:	bd80      	pop	{r7, pc}
	...

080280f4 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80280f4:	b580      	push	{r7, lr}
 80280f6:	b082      	sub	sp, #8
 80280f8:	af00      	add	r7, sp, #0
 80280fa:	6078      	str	r0, [r7, #4]
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 80280fc:	687b      	ldr	r3, [r7, #4]
 80280fe:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8028102:	4618      	mov	r0, r3
 8028104:	f7df fc49 	bl	800799a <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8028108:	687b      	ldr	r3, [r7, #4]
 802810a:	681b      	ldr	r3, [r3, #0]
 802810c:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8028110:	681b      	ldr	r3, [r3, #0]
 8028112:	687a      	ldr	r2, [r7, #4]
 8028114:	6812      	ldr	r2, [r2, #0]
 8028116:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 802811a:	f043 0301 	orr.w	r3, r3, #1
 802811e:	6013      	str	r3, [r2, #0]
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8028120:	687b      	ldr	r3, [r7, #4]
 8028122:	7adb      	ldrb	r3, [r3, #11]
 8028124:	2b00      	cmp	r3, #0
 8028126:	d005      	beq.n	8028134 <HAL_PCD_SuspendCallback+0x40>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8028128:	4b04      	ldr	r3, [pc, #16]	@ (802813c <HAL_PCD_SuspendCallback+0x48>)
 802812a:	691b      	ldr	r3, [r3, #16]
 802812c:	4a03      	ldr	r2, [pc, #12]	@ (802813c <HAL_PCD_SuspendCallback+0x48>)
 802812e:	f043 0306 	orr.w	r3, r3, #6
 8028132:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8028134:	bf00      	nop
 8028136:	3708      	adds	r7, #8
 8028138:	46bd      	mov	sp, r7
 802813a:	bd80      	pop	{r7, pc}
 802813c:	e000ed00 	.word	0xe000ed00

08028140 <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028140:	b580      	push	{r7, lr}
 8028142:	b082      	sub	sp, #8
 8028144:	af00      	add	r7, sp, #0
 8028146:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8028148:	687b      	ldr	r3, [r7, #4]
 802814a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 802814e:	4618      	mov	r0, r3
 8028150:	f7df fc3f 	bl	80079d2 <USBD_LL_Resume>
}
 8028154:	bf00      	nop
 8028156:	3708      	adds	r7, #8
 8028158:	46bd      	mov	sp, r7
 802815a:	bd80      	pop	{r7, pc}

0802815c <HAL_PCD_ISOOUTIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 802815c:	b580      	push	{r7, lr}
 802815e:	b082      	sub	sp, #8
 8028160:	af00      	add	r7, sp, #0
 8028162:	6078      	str	r0, [r7, #4]
 8028164:	460b      	mov	r3, r1
 8028166:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8028168:	687b      	ldr	r3, [r7, #4]
 802816a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 802816e:	78fa      	ldrb	r2, [r7, #3]
 8028170:	4611      	mov	r1, r2
 8028172:	4618      	mov	r0, r3
 8028174:	f7df fc97 	bl	8007aa6 <USBD_LL_IsoOUTIncomplete>
}
 8028178:	bf00      	nop
 802817a:	3708      	adds	r7, #8
 802817c:	46bd      	mov	sp, r7
 802817e:	bd80      	pop	{r7, pc}

08028180 <HAL_PCD_ISOINIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028180:	b580      	push	{r7, lr}
 8028182:	b082      	sub	sp, #8
 8028184:	af00      	add	r7, sp, #0
 8028186:	6078      	str	r0, [r7, #4]
 8028188:	460b      	mov	r3, r1
 802818a:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 802818c:	687b      	ldr	r3, [r7, #4]
 802818e:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8028192:	78fa      	ldrb	r2, [r7, #3]
 8028194:	4611      	mov	r1, r2
 8028196:	4618      	mov	r0, r3
 8028198:	f7df fc53 	bl	8007a42 <USBD_LL_IsoINIncomplete>
}
 802819c:	bf00      	nop
 802819e:	3708      	adds	r7, #8
 80281a0:	46bd      	mov	sp, r7
 80281a2:	bd80      	pop	{r7, pc}

080281a4 <HAL_PCD_ConnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80281a4:	b580      	push	{r7, lr}
 80281a6:	b082      	sub	sp, #8
 80281a8:	af00      	add	r7, sp, #0
 80281aa:	6078      	str	r0, [r7, #4]
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 80281ac:	687b      	ldr	r3, [r7, #4]
 80281ae:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 80281b2:	4618      	mov	r0, r3
 80281b4:	f7df fca9 	bl	8007b0a <USBD_LL_DevConnected>
}
 80281b8:	bf00      	nop
 80281ba:	3708      	adds	r7, #8
 80281bc:	46bd      	mov	sp, r7
 80281be:	bd80      	pop	{r7, pc}

080281c0 <HAL_PCD_DisconnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80281c0:	b580      	push	{r7, lr}
 80281c2:	b082      	sub	sp, #8
 80281c4:	af00      	add	r7, sp, #0
 80281c6:	6078      	str	r0, [r7, #4]
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 80281c8:	687b      	ldr	r3, [r7, #4]
 80281ca:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 80281ce:	4618      	mov	r0, r3
 80281d0:	f7df fca6 	bl	8007b20 <USBD_LL_DevDisconnected>
}
 80281d4:	bf00      	nop
 80281d6:	3708      	adds	r7, #8
 80281d8:	46bd      	mov	sp, r7
 80281da:	bd80      	pop	{r7, pc}

080281dc <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 80281dc:	b580      	push	{r7, lr}
 80281de:	b082      	sub	sp, #8
 80281e0:	af00      	add	r7, sp, #0
 80281e2:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 80281e4:	687b      	ldr	r3, [r7, #4]
 80281e6:	781b      	ldrb	r3, [r3, #0]
 80281e8:	2b00      	cmp	r3, #0
 80281ea:	d13c      	bne.n	8028266 <USBD_LL_Init+0x8a>
  /* Link the driver to the stack. */
  hpcd_USB_OTG_FS.pData = pdev;
 80281ec:	4a20      	ldr	r2, [pc, #128]	@ (8028270 <USBD_LL_Init+0x94>)
 80281ee:	687b      	ldr	r3, [r7, #4]
 80281f0:	f8c2 34e0 	str.w	r3, [r2, #1248]	@ 0x4e0
  pdev->pData = &hpcd_USB_OTG_FS;
 80281f4:	687b      	ldr	r3, [r7, #4]
 80281f6:	4a1e      	ldr	r2, [pc, #120]	@ (8028270 <USBD_LL_Init+0x94>)
 80281f8:	f8c3 22c8 	str.w	r2, [r3, #712]	@ 0x2c8

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 80281fc:	4b1c      	ldr	r3, [pc, #112]	@ (8028270 <USBD_LL_Init+0x94>)
 80281fe:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 8028202:	601a      	str	r2, [r3, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 8028204:	4b1a      	ldr	r3, [pc, #104]	@ (8028270 <USBD_LL_Init+0x94>)
 8028206:	2204      	movs	r2, #4
 8028208:	711a      	strb	r2, [r3, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 802820a:	4b19      	ldr	r3, [pc, #100]	@ (8028270 <USBD_LL_Init+0x94>)
 802820c:	2202      	movs	r2, #2
 802820e:	71da      	strb	r2, [r3, #7]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8028210:	4b17      	ldr	r3, [pc, #92]	@ (8028270 <USBD_LL_Init+0x94>)
 8028212:	2200      	movs	r2, #0
 8028214:	719a      	strb	r2, [r3, #6]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8028216:	4b16      	ldr	r3, [pc, #88]	@ (8028270 <USBD_LL_Init+0x94>)
 8028218:	2202      	movs	r2, #2
 802821a:	725a      	strb	r2, [r3, #9]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 802821c:	4b14      	ldr	r3, [pc, #80]	@ (8028270 <USBD_LL_Init+0x94>)
 802821e:	2200      	movs	r2, #0
 8028220:	729a      	strb	r2, [r3, #10]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8028222:	4b13      	ldr	r3, [pc, #76]	@ (8028270 <USBD_LL_Init+0x94>)
 8028224:	2200      	movs	r2, #0
 8028226:	72da      	strb	r2, [r3, #11]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8028228:	4b11      	ldr	r3, [pc, #68]	@ (8028270 <USBD_LL_Init+0x94>)
 802822a:	2200      	movs	r2, #0
 802822c:	731a      	strb	r2, [r3, #12]
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 802822e:	4b10      	ldr	r3, [pc, #64]	@ (8028270 <USBD_LL_Init+0x94>)
 8028230:	2201      	movs	r2, #1
 8028232:	739a      	strb	r2, [r3, #14]
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8028234:	4b0e      	ldr	r3, [pc, #56]	@ (8028270 <USBD_LL_Init+0x94>)
 8028236:	2200      	movs	r2, #0
 8028238:	73da      	strb	r2, [r3, #15]
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 802823a:	480d      	ldr	r0, [pc, #52]	@ (8028270 <USBD_LL_Init+0x94>)
 802823c:	f7da ff7a 	bl	8003134 <HAL_PCD_Init>
 8028240:	4603      	mov	r3, r0
 8028242:	2b00      	cmp	r3, #0
 8028244:	d001      	beq.n	802824a <USBD_LL_Init+0x6e>
  {
    Error_Handler( );
 8028246:	f7d9 fb25 	bl	8001894 <Error_Handler>
  HAL_PCD_RegisterDataOutStageCallback(&hpcd_USB_OTG_FS, PCD_DataOutStageCallback);
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_OTG_FS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 802824a:	2180      	movs	r1, #128	@ 0x80
 802824c:	4808      	ldr	r0, [pc, #32]	@ (8028270 <USBD_LL_Init+0x94>)
 802824e:	f7dc f9a6 	bl	800459e <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8028252:	2240      	movs	r2, #64	@ 0x40
 8028254:	2100      	movs	r1, #0
 8028256:	4806      	ldr	r0, [pc, #24]	@ (8028270 <USBD_LL_Init+0x94>)
 8028258:	f7dc f95a 	bl	8004510 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 802825c:	2280      	movs	r2, #128	@ 0x80
 802825e:	2101      	movs	r1, #1
 8028260:	4803      	ldr	r0, [pc, #12]	@ (8028270 <USBD_LL_Init+0x94>)
 8028262:	f7dc f955 	bl	8004510 <HAL_PCDEx_SetTxFiFo>
  }
  return USBD_OK;
 8028266:	2300      	movs	r3, #0
}
 8028268:	4618      	mov	r0, r3
 802826a:	3708      	adds	r7, #8
 802826c:	46bd      	mov	sp, r7
 802826e:	bd80      	pop	{r7, pc}
 8028270:	2000313c 	.word	0x2000313c

08028274 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8028274:	b580      	push	{r7, lr}
 8028276:	b084      	sub	sp, #16
 8028278:	af00      	add	r7, sp, #0
 802827a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802827c:	2300      	movs	r3, #0
 802827e:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028280:	2300      	movs	r3, #0
 8028282:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_Start(pdev->pData);
 8028284:	687b      	ldr	r3, [r7, #4]
 8028286:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 802828a:	4618      	mov	r0, r3
 802828c:	f7db f861 	bl	8003352 <HAL_PCD_Start>
 8028290:	4603      	mov	r3, r0
 8028292:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028294:	7bfb      	ldrb	r3, [r7, #15]
 8028296:	4618      	mov	r0, r3
 8028298:	f000 f942 	bl	8028520 <USBD_Get_USB_Status>
 802829c:	4603      	mov	r3, r0
 802829e:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 80282a0:	7bbb      	ldrb	r3, [r7, #14]
}
 80282a2:	4618      	mov	r0, r3
 80282a4:	3710      	adds	r7, #16
 80282a6:	46bd      	mov	sp, r7
 80282a8:	bd80      	pop	{r7, pc}

080282aa <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 80282aa:	b580      	push	{r7, lr}
 80282ac:	b084      	sub	sp, #16
 80282ae:	af00      	add	r7, sp, #0
 80282b0:	6078      	str	r0, [r7, #4]
 80282b2:	4608      	mov	r0, r1
 80282b4:	4611      	mov	r1, r2
 80282b6:	461a      	mov	r2, r3
 80282b8:	4603      	mov	r3, r0
 80282ba:	70fb      	strb	r3, [r7, #3]
 80282bc:	460b      	mov	r3, r1
 80282be:	70bb      	strb	r3, [r7, #2]
 80282c0:	4613      	mov	r3, r2
 80282c2:	803b      	strh	r3, [r7, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 80282c4:	2300      	movs	r3, #0
 80282c6:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 80282c8:	2300      	movs	r3, #0
 80282ca:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 80282cc:	687b      	ldr	r3, [r7, #4]
 80282ce:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 80282d2:	78bb      	ldrb	r3, [r7, #2]
 80282d4:	883a      	ldrh	r2, [r7, #0]
 80282d6:	78f9      	ldrb	r1, [r7, #3]
 80282d8:	f7db fd35 	bl	8003d46 <HAL_PCD_EP_Open>
 80282dc:	4603      	mov	r3, r0
 80282de:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 80282e0:	7bfb      	ldrb	r3, [r7, #15]
 80282e2:	4618      	mov	r0, r3
 80282e4:	f000 f91c 	bl	8028520 <USBD_Get_USB_Status>
 80282e8:	4603      	mov	r3, r0
 80282ea:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 80282ec:	7bbb      	ldrb	r3, [r7, #14]
}
 80282ee:	4618      	mov	r0, r3
 80282f0:	3710      	adds	r7, #16
 80282f2:	46bd      	mov	sp, r7
 80282f4:	bd80      	pop	{r7, pc}

080282f6 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 80282f6:	b580      	push	{r7, lr}
 80282f8:	b084      	sub	sp, #16
 80282fa:	af00      	add	r7, sp, #0
 80282fc:	6078      	str	r0, [r7, #4]
 80282fe:	460b      	mov	r3, r1
 8028300:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028302:	2300      	movs	r3, #0
 8028304:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028306:	2300      	movs	r3, #0
 8028308:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 802830a:	687b      	ldr	r3, [r7, #4]
 802830c:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8028310:	78fa      	ldrb	r2, [r7, #3]
 8028312:	4611      	mov	r1, r2
 8028314:	4618      	mov	r0, r3
 8028316:	f7db fd80 	bl	8003e1a <HAL_PCD_EP_Close>
 802831a:	4603      	mov	r3, r0
 802831c:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 802831e:	7bfb      	ldrb	r3, [r7, #15]
 8028320:	4618      	mov	r0, r3
 8028322:	f000 f8fd 	bl	8028520 <USBD_Get_USB_Status>
 8028326:	4603      	mov	r3, r0
 8028328:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802832a:	7bbb      	ldrb	r3, [r7, #14]
}
 802832c:	4618      	mov	r0, r3
 802832e:	3710      	adds	r7, #16
 8028330:	46bd      	mov	sp, r7
 8028332:	bd80      	pop	{r7, pc}

08028334 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8028334:	b580      	push	{r7, lr}
 8028336:	b084      	sub	sp, #16
 8028338:	af00      	add	r7, sp, #0
 802833a:	6078      	str	r0, [r7, #4]
 802833c:	460b      	mov	r3, r1
 802833e:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028340:	2300      	movs	r3, #0
 8028342:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028344:	2300      	movs	r3, #0
 8028346:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8028348:	687b      	ldr	r3, [r7, #4]
 802834a:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 802834e:	78fa      	ldrb	r2, [r7, #3]
 8028350:	4611      	mov	r1, r2
 8028352:	4618      	mov	r0, r3
 8028354:	f7db fe38 	bl	8003fc8 <HAL_PCD_EP_SetStall>
 8028358:	4603      	mov	r3, r0
 802835a:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 802835c:	7bfb      	ldrb	r3, [r7, #15]
 802835e:	4618      	mov	r0, r3
 8028360:	f000 f8de 	bl	8028520 <USBD_Get_USB_Status>
 8028364:	4603      	mov	r3, r0
 8028366:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028368:	7bbb      	ldrb	r3, [r7, #14]
}
 802836a:	4618      	mov	r0, r3
 802836c:	3710      	adds	r7, #16
 802836e:	46bd      	mov	sp, r7
 8028370:	bd80      	pop	{r7, pc}

08028372 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8028372:	b580      	push	{r7, lr}
 8028374:	b084      	sub	sp, #16
 8028376:	af00      	add	r7, sp, #0
 8028378:	6078      	str	r0, [r7, #4]
 802837a:	460b      	mov	r3, r1
 802837c:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802837e:	2300      	movs	r3, #0
 8028380:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028382:	2300      	movs	r3, #0
 8028384:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8028386:	687b      	ldr	r3, [r7, #4]
 8028388:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 802838c:	78fa      	ldrb	r2, [r7, #3]
 802838e:	4611      	mov	r1, r2
 8028390:	4618      	mov	r0, r3
 8028392:	f7db fe7c 	bl	800408e <HAL_PCD_EP_ClrStall>
 8028396:	4603      	mov	r3, r0
 8028398:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 802839a:	7bfb      	ldrb	r3, [r7, #15]
 802839c:	4618      	mov	r0, r3
 802839e:	f000 f8bf 	bl	8028520 <USBD_Get_USB_Status>
 80283a2:	4603      	mov	r3, r0
 80283a4:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 80283a6:	7bbb      	ldrb	r3, [r7, #14]
}
 80283a8:	4618      	mov	r0, r3
 80283aa:	3710      	adds	r7, #16
 80283ac:	46bd      	mov	sp, r7
 80283ae:	bd80      	pop	{r7, pc}

080283b0 <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 80283b0:	b480      	push	{r7}
 80283b2:	b085      	sub	sp, #20
 80283b4:	af00      	add	r7, sp, #0
 80283b6:	6078      	str	r0, [r7, #4]
 80283b8:	460b      	mov	r3, r1
 80283ba:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 80283bc:	687b      	ldr	r3, [r7, #4]
 80283be:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 80283c2:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
 80283c4:	f997 3003 	ldrsb.w	r3, [r7, #3]
 80283c8:	2b00      	cmp	r3, #0
 80283ca:	da0b      	bge.n	80283e4 <USBD_LL_IsStallEP+0x34>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 80283cc:	78fb      	ldrb	r3, [r7, #3]
 80283ce:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 80283d2:	68f9      	ldr	r1, [r7, #12]
 80283d4:	4613      	mov	r3, r2
 80283d6:	00db      	lsls	r3, r3, #3
 80283d8:	4413      	add	r3, r2
 80283da:	009b      	lsls	r3, r3, #2
 80283dc:	440b      	add	r3, r1
 80283de:	3316      	adds	r3, #22
 80283e0:	781b      	ldrb	r3, [r3, #0]
 80283e2:	e00b      	b.n	80283fc <USBD_LL_IsStallEP+0x4c>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 80283e4:	78fb      	ldrb	r3, [r7, #3]
 80283e6:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 80283ea:	68f9      	ldr	r1, [r7, #12]
 80283ec:	4613      	mov	r3, r2
 80283ee:	00db      	lsls	r3, r3, #3
 80283f0:	4413      	add	r3, r2
 80283f2:	009b      	lsls	r3, r3, #2
 80283f4:	440b      	add	r3, r1
 80283f6:	f203 2356 	addw	r3, r3, #598	@ 0x256
 80283fa:	781b      	ldrb	r3, [r3, #0]
  }
}
 80283fc:	4618      	mov	r0, r3
 80283fe:	3714      	adds	r7, #20
 8028400:	46bd      	mov	sp, r7
 8028402:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028406:	4770      	bx	lr

08028408 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8028408:	b580      	push	{r7, lr}
 802840a:	b084      	sub	sp, #16
 802840c:	af00      	add	r7, sp, #0
 802840e:	6078      	str	r0, [r7, #4]
 8028410:	460b      	mov	r3, r1
 8028412:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028414:	2300      	movs	r3, #0
 8028416:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028418:	2300      	movs	r3, #0
 802841a:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 802841c:	687b      	ldr	r3, [r7, #4]
 802841e:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8028422:	78fa      	ldrb	r2, [r7, #3]
 8028424:	4611      	mov	r1, r2
 8028426:	4618      	mov	r0, r3
 8028428:	f7db fc69 	bl	8003cfe <HAL_PCD_SetAddress>
 802842c:	4603      	mov	r3, r0
 802842e:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028430:	7bfb      	ldrb	r3, [r7, #15]
 8028432:	4618      	mov	r0, r3
 8028434:	f000 f874 	bl	8028520 <USBD_Get_USB_Status>
 8028438:	4603      	mov	r3, r0
 802843a:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802843c:	7bbb      	ldrb	r3, [r7, #14]
}
 802843e:	4618      	mov	r0, r3
 8028440:	3710      	adds	r7, #16
 8028442:	46bd      	mov	sp, r7
 8028444:	bd80      	pop	{r7, pc}

08028446 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8028446:	b580      	push	{r7, lr}
 8028448:	b086      	sub	sp, #24
 802844a:	af00      	add	r7, sp, #0
 802844c:	60f8      	str	r0, [r7, #12]
 802844e:	607a      	str	r2, [r7, #4]
 8028450:	603b      	str	r3, [r7, #0]
 8028452:	460b      	mov	r3, r1
 8028454:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028456:	2300      	movs	r3, #0
 8028458:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 802845a:	2300      	movs	r3, #0
 802845c:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 802845e:	68fb      	ldr	r3, [r7, #12]
 8028460:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 8028464:	7af9      	ldrb	r1, [r7, #11]
 8028466:	683b      	ldr	r3, [r7, #0]
 8028468:	687a      	ldr	r2, [r7, #4]
 802846a:	f7db fd73 	bl	8003f54 <HAL_PCD_EP_Transmit>
 802846e:	4603      	mov	r3, r0
 8028470:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028472:	7dfb      	ldrb	r3, [r7, #23]
 8028474:	4618      	mov	r0, r3
 8028476:	f000 f853 	bl	8028520 <USBD_Get_USB_Status>
 802847a:	4603      	mov	r3, r0
 802847c:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 802847e:	7dbb      	ldrb	r3, [r7, #22]
}
 8028480:	4618      	mov	r0, r3
 8028482:	3718      	adds	r7, #24
 8028484:	46bd      	mov	sp, r7
 8028486:	bd80      	pop	{r7, pc}

08028488 <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8028488:	b580      	push	{r7, lr}
 802848a:	b086      	sub	sp, #24
 802848c:	af00      	add	r7, sp, #0
 802848e:	60f8      	str	r0, [r7, #12]
 8028490:	607a      	str	r2, [r7, #4]
 8028492:	603b      	str	r3, [r7, #0]
 8028494:	460b      	mov	r3, r1
 8028496:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028498:	2300      	movs	r3, #0
 802849a:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 802849c:	2300      	movs	r3, #0
 802849e:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 80284a0:	68fb      	ldr	r3, [r7, #12]
 80284a2:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 80284a6:	7af9      	ldrb	r1, [r7, #11]
 80284a8:	683b      	ldr	r3, [r7, #0]
 80284aa:	687a      	ldr	r2, [r7, #4]
 80284ac:	f7db fcff 	bl	8003eae <HAL_PCD_EP_Receive>
 80284b0:	4603      	mov	r3, r0
 80284b2:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 80284b4:	7dfb      	ldrb	r3, [r7, #23]
 80284b6:	4618      	mov	r0, r3
 80284b8:	f000 f832 	bl	8028520 <USBD_Get_USB_Status>
 80284bc:	4603      	mov	r3, r0
 80284be:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 80284c0:	7dbb      	ldrb	r3, [r7, #22]
}
 80284c2:	4618      	mov	r0, r3
 80284c4:	3718      	adds	r7, #24
 80284c6:	46bd      	mov	sp, r7
 80284c8:	bd80      	pop	{r7, pc}

080284ca <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Received Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 80284ca:	b580      	push	{r7, lr}
 80284cc:	b082      	sub	sp, #8
 80284ce:	af00      	add	r7, sp, #0
 80284d0:	6078      	str	r0, [r7, #4]
 80284d2:	460b      	mov	r3, r1
 80284d4:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 80284d6:	687b      	ldr	r3, [r7, #4]
 80284d8:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 80284dc:	78fa      	ldrb	r2, [r7, #3]
 80284de:	4611      	mov	r1, r2
 80284e0:	4618      	mov	r0, r3
 80284e2:	f7db fd1f 	bl	8003f24 <HAL_PCD_EP_GetRxCount>
 80284e6:	4603      	mov	r3, r0
}
 80284e8:	4618      	mov	r0, r3
 80284ea:	3708      	adds	r7, #8
 80284ec:	46bd      	mov	sp, r7
 80284ee:	bd80      	pop	{r7, pc}

080284f0 <USBD_static_malloc>:
  * @brief  Static single allocation.
  * @param  size: Size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
 80284f0:	b480      	push	{r7}
 80284f2:	b083      	sub	sp, #12
 80284f4:	af00      	add	r7, sp, #0
 80284f6:	6078      	str	r0, [r7, #4]
  static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
 80284f8:	4b03      	ldr	r3, [pc, #12]	@ (8028508 <USBD_static_malloc+0x18>)
}
 80284fa:	4618      	mov	r0, r3
 80284fc:	370c      	adds	r7, #12
 80284fe:	46bd      	mov	sp, r7
 8028500:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028504:	4770      	bx	lr
 8028506:	bf00      	nop
 8028508:	20003620 	.word	0x20003620

0802850c <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 802850c:	b480      	push	{r7}
 802850e:	b083      	sub	sp, #12
 8028510:	af00      	add	r7, sp, #0
 8028512:	6078      	str	r0, [r7, #4]

}
 8028514:	bf00      	nop
 8028516:	370c      	adds	r7, #12
 8028518:	46bd      	mov	sp, r7
 802851a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802851e:	4770      	bx	lr

08028520 <USBD_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 8028520:	b480      	push	{r7}
 8028522:	b085      	sub	sp, #20
 8028524:	af00      	add	r7, sp, #0
 8028526:	4603      	mov	r3, r0
 8028528:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef usb_status = USBD_OK;
 802852a:	2300      	movs	r3, #0
 802852c:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 802852e:	79fb      	ldrb	r3, [r7, #7]
 8028530:	2b03      	cmp	r3, #3
 8028532:	d817      	bhi.n	8028564 <USBD_Get_USB_Status+0x44>
 8028534:	a201      	add	r2, pc, #4	@ (adr r2, 802853c <USBD_Get_USB_Status+0x1c>)
 8028536:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802853a:	bf00      	nop
 802853c:	0802854d 	.word	0x0802854d
 8028540:	08028553 	.word	0x08028553
 8028544:	08028559 	.word	0x08028559
 8028548:	0802855f 	.word	0x0802855f
  {
    case HAL_OK :
      usb_status = USBD_OK;
 802854c:	2300      	movs	r3, #0
 802854e:	73fb      	strb	r3, [r7, #15]
    break;
 8028550:	e00b      	b.n	802856a <USBD_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8028552:	2303      	movs	r3, #3
 8028554:	73fb      	strb	r3, [r7, #15]
    break;
 8028556:	e008      	b.n	802856a <USBD_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 8028558:	2301      	movs	r3, #1
 802855a:	73fb      	strb	r3, [r7, #15]
    break;
 802855c:	e005      	b.n	802856a <USBD_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
 802855e:	2303      	movs	r3, #3
 8028560:	73fb      	strb	r3, [r7, #15]
    break;
 8028562:	e002      	b.n	802856a <USBD_Get_USB_Status+0x4a>
    default :
      usb_status = USBD_FAIL;
 8028564:	2303      	movs	r3, #3
 8028566:	73fb      	strb	r3, [r7, #15]
    break;
 8028568:	bf00      	nop
  }
  return usb_status;
 802856a:	7bfb      	ldrb	r3, [r7, #15]
}
 802856c:	4618      	mov	r0, r3
 802856e:	3714      	adds	r7, #20
 8028570:	46bd      	mov	sp, r7
 8028572:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028576:	4770      	bx	lr

08028578 <malloc>:
 8028578:	4b02      	ldr	r3, [pc, #8]	@ (8028584 <malloc+0xc>)
 802857a:	4601      	mov	r1, r0
 802857c:	6818      	ldr	r0, [r3, #0]
 802857e:	f000 b82d 	b.w	80285dc <_malloc_r>
 8028582:	bf00      	nop
 8028584:	20000140 	.word	0x20000140

08028588 <free>:
 8028588:	4b02      	ldr	r3, [pc, #8]	@ (8028594 <free+0xc>)
 802858a:	4601      	mov	r1, r0
 802858c:	6818      	ldr	r0, [r3, #0]
 802858e:	f000 bc09 	b.w	8028da4 <_free_r>
 8028592:	bf00      	nop
 8028594:	20000140 	.word	0x20000140

08028598 <sbrk_aligned>:
 8028598:	b570      	push	{r4, r5, r6, lr}
 802859a:	4e0f      	ldr	r6, [pc, #60]	@ (80285d8 <sbrk_aligned+0x40>)
 802859c:	460c      	mov	r4, r1
 802859e:	6831      	ldr	r1, [r6, #0]
 80285a0:	4605      	mov	r5, r0
 80285a2:	b911      	cbnz	r1, 80285aa <sbrk_aligned+0x12>
 80285a4:	f000 fba0 	bl	8028ce8 <_sbrk_r>
 80285a8:	6030      	str	r0, [r6, #0]
 80285aa:	4621      	mov	r1, r4
 80285ac:	4628      	mov	r0, r5
 80285ae:	f000 fb9b 	bl	8028ce8 <_sbrk_r>
 80285b2:	1c43      	adds	r3, r0, #1
 80285b4:	d103      	bne.n	80285be <sbrk_aligned+0x26>
 80285b6:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
 80285ba:	4620      	mov	r0, r4
 80285bc:	bd70      	pop	{r4, r5, r6, pc}
 80285be:	1cc4      	adds	r4, r0, #3
 80285c0:	f024 0403 	bic.w	r4, r4, #3
 80285c4:	42a0      	cmp	r0, r4
 80285c6:	d0f8      	beq.n	80285ba <sbrk_aligned+0x22>
 80285c8:	1a21      	subs	r1, r4, r0
 80285ca:	4628      	mov	r0, r5
 80285cc:	f000 fb8c 	bl	8028ce8 <_sbrk_r>
 80285d0:	3001      	adds	r0, #1
 80285d2:	d1f2      	bne.n	80285ba <sbrk_aligned+0x22>
 80285d4:	e7ef      	b.n	80285b6 <sbrk_aligned+0x1e>
 80285d6:	bf00      	nop
 80285d8:	20003840 	.word	0x20003840

080285dc <_malloc_r>:
 80285dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80285e0:	1ccd      	adds	r5, r1, #3
 80285e2:	f025 0503 	bic.w	r5, r5, #3
 80285e6:	3508      	adds	r5, #8
 80285e8:	2d0c      	cmp	r5, #12
 80285ea:	bf38      	it	cc
 80285ec:	250c      	movcc	r5, #12
 80285ee:	2d00      	cmp	r5, #0
 80285f0:	4606      	mov	r6, r0
 80285f2:	db01      	blt.n	80285f8 <_malloc_r+0x1c>
 80285f4:	42a9      	cmp	r1, r5
 80285f6:	d904      	bls.n	8028602 <_malloc_r+0x26>
 80285f8:	230c      	movs	r3, #12
 80285fa:	6033      	str	r3, [r6, #0]
 80285fc:	2000      	movs	r0, #0
 80285fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8028602:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 80286d8 <_malloc_r+0xfc>
 8028606:	f000 f869 	bl	80286dc <__malloc_lock>
 802860a:	f8d8 3000 	ldr.w	r3, [r8]
 802860e:	461c      	mov	r4, r3
 8028610:	bb44      	cbnz	r4, 8028664 <_malloc_r+0x88>
 8028612:	4629      	mov	r1, r5
 8028614:	4630      	mov	r0, r6
 8028616:	f7ff ffbf 	bl	8028598 <sbrk_aligned>
 802861a:	1c43      	adds	r3, r0, #1
 802861c:	4604      	mov	r4, r0
 802861e:	d158      	bne.n	80286d2 <_malloc_r+0xf6>
 8028620:	f8d8 4000 	ldr.w	r4, [r8]
 8028624:	4627      	mov	r7, r4
 8028626:	2f00      	cmp	r7, #0
 8028628:	d143      	bne.n	80286b2 <_malloc_r+0xd6>
 802862a:	2c00      	cmp	r4, #0
 802862c:	d04b      	beq.n	80286c6 <_malloc_r+0xea>
 802862e:	6823      	ldr	r3, [r4, #0]
 8028630:	4639      	mov	r1, r7
 8028632:	4630      	mov	r0, r6
 8028634:	eb04 0903 	add.w	r9, r4, r3
 8028638:	f000 fb56 	bl	8028ce8 <_sbrk_r>
 802863c:	4581      	cmp	r9, r0
 802863e:	d142      	bne.n	80286c6 <_malloc_r+0xea>
 8028640:	6821      	ldr	r1, [r4, #0]
 8028642:	1a6d      	subs	r5, r5, r1
 8028644:	4629      	mov	r1, r5
 8028646:	4630      	mov	r0, r6
 8028648:	f7ff ffa6 	bl	8028598 <sbrk_aligned>
 802864c:	3001      	adds	r0, #1
 802864e:	d03a      	beq.n	80286c6 <_malloc_r+0xea>
 8028650:	6823      	ldr	r3, [r4, #0]
 8028652:	442b      	add	r3, r5
 8028654:	6023      	str	r3, [r4, #0]
 8028656:	f8d8 3000 	ldr.w	r3, [r8]
 802865a:	685a      	ldr	r2, [r3, #4]
 802865c:	bb62      	cbnz	r2, 80286b8 <_malloc_r+0xdc>
 802865e:	f8c8 7000 	str.w	r7, [r8]
 8028662:	e00f      	b.n	8028684 <_malloc_r+0xa8>
 8028664:	6822      	ldr	r2, [r4, #0]
 8028666:	1b52      	subs	r2, r2, r5
 8028668:	d420      	bmi.n	80286ac <_malloc_r+0xd0>
 802866a:	2a0b      	cmp	r2, #11
 802866c:	d917      	bls.n	802869e <_malloc_r+0xc2>
 802866e:	1961      	adds	r1, r4, r5
 8028670:	42a3      	cmp	r3, r4
 8028672:	6025      	str	r5, [r4, #0]
 8028674:	bf18      	it	ne
 8028676:	6059      	strne	r1, [r3, #4]
 8028678:	6863      	ldr	r3, [r4, #4]
 802867a:	bf08      	it	eq
 802867c:	f8c8 1000 	streq.w	r1, [r8]
 8028680:	5162      	str	r2, [r4, r5]
 8028682:	604b      	str	r3, [r1, #4]
 8028684:	4630      	mov	r0, r6
 8028686:	f000 f82f 	bl	80286e8 <__malloc_unlock>
 802868a:	f104 000b 	add.w	r0, r4, #11
 802868e:	1d23      	adds	r3, r4, #4
 8028690:	f020 0007 	bic.w	r0, r0, #7
 8028694:	1ac2      	subs	r2, r0, r3
 8028696:	bf1c      	itt	ne
 8028698:	1a1b      	subne	r3, r3, r0
 802869a:	50a3      	strne	r3, [r4, r2]
 802869c:	e7af      	b.n	80285fe <_malloc_r+0x22>
 802869e:	6862      	ldr	r2, [r4, #4]
 80286a0:	42a3      	cmp	r3, r4
 80286a2:	bf0c      	ite	eq
 80286a4:	f8c8 2000 	streq.w	r2, [r8]
 80286a8:	605a      	strne	r2, [r3, #4]
 80286aa:	e7eb      	b.n	8028684 <_malloc_r+0xa8>
 80286ac:	4623      	mov	r3, r4
 80286ae:	6864      	ldr	r4, [r4, #4]
 80286b0:	e7ae      	b.n	8028610 <_malloc_r+0x34>
 80286b2:	463c      	mov	r4, r7
 80286b4:	687f      	ldr	r7, [r7, #4]
 80286b6:	e7b6      	b.n	8028626 <_malloc_r+0x4a>
 80286b8:	461a      	mov	r2, r3
 80286ba:	685b      	ldr	r3, [r3, #4]
 80286bc:	42a3      	cmp	r3, r4
 80286be:	d1fb      	bne.n	80286b8 <_malloc_r+0xdc>
 80286c0:	2300      	movs	r3, #0
 80286c2:	6053      	str	r3, [r2, #4]
 80286c4:	e7de      	b.n	8028684 <_malloc_r+0xa8>
 80286c6:	230c      	movs	r3, #12
 80286c8:	6033      	str	r3, [r6, #0]
 80286ca:	4630      	mov	r0, r6
 80286cc:	f000 f80c 	bl	80286e8 <__malloc_unlock>
 80286d0:	e794      	b.n	80285fc <_malloc_r+0x20>
 80286d2:	6005      	str	r5, [r0, #0]
 80286d4:	e7d6      	b.n	8028684 <_malloc_r+0xa8>
 80286d6:	bf00      	nop
 80286d8:	20003844 	.word	0x20003844

080286dc <__malloc_lock>:
 80286dc:	4801      	ldr	r0, [pc, #4]	@ (80286e4 <__malloc_lock+0x8>)
 80286de:	f000 bb50 	b.w	8028d82 <__retarget_lock_acquire_recursive>
 80286e2:	bf00      	nop
 80286e4:	20003988 	.word	0x20003988

080286e8 <__malloc_unlock>:
 80286e8:	4801      	ldr	r0, [pc, #4]	@ (80286f0 <__malloc_unlock+0x8>)
 80286ea:	f000 bb4b 	b.w	8028d84 <__retarget_lock_release_recursive>
 80286ee:	bf00      	nop
 80286f0:	20003988 	.word	0x20003988

080286f4 <_realloc_r>:
 80286f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80286f8:	4607      	mov	r7, r0
 80286fa:	4614      	mov	r4, r2
 80286fc:	460d      	mov	r5, r1
 80286fe:	b921      	cbnz	r1, 802870a <_realloc_r+0x16>
 8028700:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8028704:	4611      	mov	r1, r2
 8028706:	f7ff bf69 	b.w	80285dc <_malloc_r>
 802870a:	b92a      	cbnz	r2, 8028718 <_realloc_r+0x24>
 802870c:	f000 fb4a 	bl	8028da4 <_free_r>
 8028710:	4625      	mov	r5, r4
 8028712:	4628      	mov	r0, r5
 8028714:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8028718:	f000 fb8e 	bl	8028e38 <_malloc_usable_size_r>
 802871c:	4284      	cmp	r4, r0
 802871e:	4606      	mov	r6, r0
 8028720:	d802      	bhi.n	8028728 <_realloc_r+0x34>
 8028722:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 8028726:	d8f4      	bhi.n	8028712 <_realloc_r+0x1e>
 8028728:	4621      	mov	r1, r4
 802872a:	4638      	mov	r0, r7
 802872c:	f7ff ff56 	bl	80285dc <_malloc_r>
 8028730:	4680      	mov	r8, r0
 8028732:	b908      	cbnz	r0, 8028738 <_realloc_r+0x44>
 8028734:	4645      	mov	r5, r8
 8028736:	e7ec      	b.n	8028712 <_realloc_r+0x1e>
 8028738:	42b4      	cmp	r4, r6
 802873a:	4622      	mov	r2, r4
 802873c:	4629      	mov	r1, r5
 802873e:	bf28      	it	cs
 8028740:	4632      	movcs	r2, r6
 8028742:	f000 fb20 	bl	8028d86 <memcpy>
 8028746:	4629      	mov	r1, r5
 8028748:	4638      	mov	r0, r7
 802874a:	f000 fb2b 	bl	8028da4 <_free_r>
 802874e:	e7f1      	b.n	8028734 <_realloc_r+0x40>

08028750 <std>:
 8028750:	2300      	movs	r3, #0
 8028752:	b510      	push	{r4, lr}
 8028754:	4604      	mov	r4, r0
 8028756:	e9c0 3300 	strd	r3, r3, [r0]
 802875a:	e9c0 3304 	strd	r3, r3, [r0, #16]
 802875e:	6083      	str	r3, [r0, #8]
 8028760:	8181      	strh	r1, [r0, #12]
 8028762:	6643      	str	r3, [r0, #100]	@ 0x64
 8028764:	81c2      	strh	r2, [r0, #14]
 8028766:	6183      	str	r3, [r0, #24]
 8028768:	4619      	mov	r1, r3
 802876a:	2208      	movs	r2, #8
 802876c:	305c      	adds	r0, #92	@ 0x5c
 802876e:	f000 fa59 	bl	8028c24 <memset>
 8028772:	4b0d      	ldr	r3, [pc, #52]	@ (80287a8 <std+0x58>)
 8028774:	6263      	str	r3, [r4, #36]	@ 0x24
 8028776:	4b0d      	ldr	r3, [pc, #52]	@ (80287ac <std+0x5c>)
 8028778:	62a3      	str	r3, [r4, #40]	@ 0x28
 802877a:	4b0d      	ldr	r3, [pc, #52]	@ (80287b0 <std+0x60>)
 802877c:	62e3      	str	r3, [r4, #44]	@ 0x2c
 802877e:	4b0d      	ldr	r3, [pc, #52]	@ (80287b4 <std+0x64>)
 8028780:	6323      	str	r3, [r4, #48]	@ 0x30
 8028782:	4b0d      	ldr	r3, [pc, #52]	@ (80287b8 <std+0x68>)
 8028784:	6224      	str	r4, [r4, #32]
 8028786:	429c      	cmp	r4, r3
 8028788:	d006      	beq.n	8028798 <std+0x48>
 802878a:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 802878e:	4294      	cmp	r4, r2
 8028790:	d002      	beq.n	8028798 <std+0x48>
 8028792:	33d0      	adds	r3, #208	@ 0xd0
 8028794:	429c      	cmp	r4, r3
 8028796:	d105      	bne.n	80287a4 <std+0x54>
 8028798:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 802879c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80287a0:	f000 baee 	b.w	8028d80 <__retarget_lock_init_recursive>
 80287a4:	bd10      	pop	{r4, pc}
 80287a6:	bf00      	nop
 80287a8:	08028a21 	.word	0x08028a21
 80287ac:	08028a43 	.word	0x08028a43
 80287b0:	08028a7b 	.word	0x08028a7b
 80287b4:	08028a9f 	.word	0x08028a9f
 80287b8:	20003848 	.word	0x20003848

080287bc <stdio_exit_handler>:
 80287bc:	4a02      	ldr	r2, [pc, #8]	@ (80287c8 <stdio_exit_handler+0xc>)
 80287be:	4903      	ldr	r1, [pc, #12]	@ (80287cc <stdio_exit_handler+0x10>)
 80287c0:	4803      	ldr	r0, [pc, #12]	@ (80287d0 <stdio_exit_handler+0x14>)
 80287c2:	f000 b869 	b.w	8028898 <_fwalk_sglue>
 80287c6:	bf00      	nop
 80287c8:	20000134 	.word	0x20000134
 80287cc:	0802979d 	.word	0x0802979d
 80287d0:	20000144 	.word	0x20000144

080287d4 <cleanup_stdio>:
 80287d4:	6841      	ldr	r1, [r0, #4]
 80287d6:	4b0c      	ldr	r3, [pc, #48]	@ (8028808 <cleanup_stdio+0x34>)
 80287d8:	4299      	cmp	r1, r3
 80287da:	b510      	push	{r4, lr}
 80287dc:	4604      	mov	r4, r0
 80287de:	d001      	beq.n	80287e4 <cleanup_stdio+0x10>
 80287e0:	f000 ffdc 	bl	802979c <_fflush_r>
 80287e4:	68a1      	ldr	r1, [r4, #8]
 80287e6:	4b09      	ldr	r3, [pc, #36]	@ (802880c <cleanup_stdio+0x38>)
 80287e8:	4299      	cmp	r1, r3
 80287ea:	d002      	beq.n	80287f2 <cleanup_stdio+0x1e>
 80287ec:	4620      	mov	r0, r4
 80287ee:	f000 ffd5 	bl	802979c <_fflush_r>
 80287f2:	68e1      	ldr	r1, [r4, #12]
 80287f4:	4b06      	ldr	r3, [pc, #24]	@ (8028810 <cleanup_stdio+0x3c>)
 80287f6:	4299      	cmp	r1, r3
 80287f8:	d004      	beq.n	8028804 <cleanup_stdio+0x30>
 80287fa:	4620      	mov	r0, r4
 80287fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8028800:	f000 bfcc 	b.w	802979c <_fflush_r>
 8028804:	bd10      	pop	{r4, pc}
 8028806:	bf00      	nop
 8028808:	20003848 	.word	0x20003848
 802880c:	200038b0 	.word	0x200038b0
 8028810:	20003918 	.word	0x20003918

08028814 <global_stdio_init.part.0>:
 8028814:	b510      	push	{r4, lr}
 8028816:	4b0b      	ldr	r3, [pc, #44]	@ (8028844 <global_stdio_init.part.0+0x30>)
 8028818:	4c0b      	ldr	r4, [pc, #44]	@ (8028848 <global_stdio_init.part.0+0x34>)
 802881a:	4a0c      	ldr	r2, [pc, #48]	@ (802884c <global_stdio_init.part.0+0x38>)
 802881c:	601a      	str	r2, [r3, #0]
 802881e:	4620      	mov	r0, r4
 8028820:	2200      	movs	r2, #0
 8028822:	2104      	movs	r1, #4
 8028824:	f7ff ff94 	bl	8028750 <std>
 8028828:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 802882c:	2201      	movs	r2, #1
 802882e:	2109      	movs	r1, #9
 8028830:	f7ff ff8e 	bl	8028750 <std>
 8028834:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 8028838:	2202      	movs	r2, #2
 802883a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802883e:	2112      	movs	r1, #18
 8028840:	f7ff bf86 	b.w	8028750 <std>
 8028844:	20003980 	.word	0x20003980
 8028848:	20003848 	.word	0x20003848
 802884c:	080287bd 	.word	0x080287bd

08028850 <__sfp_lock_acquire>:
 8028850:	4801      	ldr	r0, [pc, #4]	@ (8028858 <__sfp_lock_acquire+0x8>)
 8028852:	f000 ba96 	b.w	8028d82 <__retarget_lock_acquire_recursive>
 8028856:	bf00      	nop
 8028858:	20003989 	.word	0x20003989

0802885c <__sfp_lock_release>:
 802885c:	4801      	ldr	r0, [pc, #4]	@ (8028864 <__sfp_lock_release+0x8>)
 802885e:	f000 ba91 	b.w	8028d84 <__retarget_lock_release_recursive>
 8028862:	bf00      	nop
 8028864:	20003989 	.word	0x20003989

08028868 <__sinit>:
 8028868:	b510      	push	{r4, lr}
 802886a:	4604      	mov	r4, r0
 802886c:	f7ff fff0 	bl	8028850 <__sfp_lock_acquire>
 8028870:	6a23      	ldr	r3, [r4, #32]
 8028872:	b11b      	cbz	r3, 802887c <__sinit+0x14>
 8028874:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8028878:	f7ff bff0 	b.w	802885c <__sfp_lock_release>
 802887c:	4b04      	ldr	r3, [pc, #16]	@ (8028890 <__sinit+0x28>)
 802887e:	6223      	str	r3, [r4, #32]
 8028880:	4b04      	ldr	r3, [pc, #16]	@ (8028894 <__sinit+0x2c>)
 8028882:	681b      	ldr	r3, [r3, #0]
 8028884:	2b00      	cmp	r3, #0
 8028886:	d1f5      	bne.n	8028874 <__sinit+0xc>
 8028888:	f7ff ffc4 	bl	8028814 <global_stdio_init.part.0>
 802888c:	e7f2      	b.n	8028874 <__sinit+0xc>
 802888e:	bf00      	nop
 8028890:	080287d5 	.word	0x080287d5
 8028894:	20003980 	.word	0x20003980

08028898 <_fwalk_sglue>:
 8028898:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802889c:	4607      	mov	r7, r0
 802889e:	4688      	mov	r8, r1
 80288a0:	4614      	mov	r4, r2
 80288a2:	2600      	movs	r6, #0
 80288a4:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 80288a8:	f1b9 0901 	subs.w	r9, r9, #1
 80288ac:	d505      	bpl.n	80288ba <_fwalk_sglue+0x22>
 80288ae:	6824      	ldr	r4, [r4, #0]
 80288b0:	2c00      	cmp	r4, #0
 80288b2:	d1f7      	bne.n	80288a4 <_fwalk_sglue+0xc>
 80288b4:	4630      	mov	r0, r6
 80288b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80288ba:	89ab      	ldrh	r3, [r5, #12]
 80288bc:	2b01      	cmp	r3, #1
 80288be:	d907      	bls.n	80288d0 <_fwalk_sglue+0x38>
 80288c0:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 80288c4:	3301      	adds	r3, #1
 80288c6:	d003      	beq.n	80288d0 <_fwalk_sglue+0x38>
 80288c8:	4629      	mov	r1, r5
 80288ca:	4638      	mov	r0, r7
 80288cc:	47c0      	blx	r8
 80288ce:	4306      	orrs	r6, r0
 80288d0:	3568      	adds	r5, #104	@ 0x68
 80288d2:	e7e9      	b.n	80288a8 <_fwalk_sglue+0x10>

080288d4 <iprintf>:
 80288d4:	b40f      	push	{r0, r1, r2, r3}
 80288d6:	b507      	push	{r0, r1, r2, lr}
 80288d8:	4906      	ldr	r1, [pc, #24]	@ (80288f4 <iprintf+0x20>)
 80288da:	ab04      	add	r3, sp, #16
 80288dc:	6808      	ldr	r0, [r1, #0]
 80288de:	f853 2b04 	ldr.w	r2, [r3], #4
 80288e2:	6881      	ldr	r1, [r0, #8]
 80288e4:	9301      	str	r3, [sp, #4]
 80288e6:	f000 fc31 	bl	802914c <_vfiprintf_r>
 80288ea:	b003      	add	sp, #12
 80288ec:	f85d eb04 	ldr.w	lr, [sp], #4
 80288f0:	b004      	add	sp, #16
 80288f2:	4770      	bx	lr
 80288f4:	20000140 	.word	0x20000140

080288f8 <_puts_r>:
 80288f8:	6a03      	ldr	r3, [r0, #32]
 80288fa:	b570      	push	{r4, r5, r6, lr}
 80288fc:	6884      	ldr	r4, [r0, #8]
 80288fe:	4605      	mov	r5, r0
 8028900:	460e      	mov	r6, r1
 8028902:	b90b      	cbnz	r3, 8028908 <_puts_r+0x10>
 8028904:	f7ff ffb0 	bl	8028868 <__sinit>
 8028908:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 802890a:	07db      	lsls	r3, r3, #31
 802890c:	d405      	bmi.n	802891a <_puts_r+0x22>
 802890e:	89a3      	ldrh	r3, [r4, #12]
 8028910:	0598      	lsls	r0, r3, #22
 8028912:	d402      	bmi.n	802891a <_puts_r+0x22>
 8028914:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8028916:	f000 fa34 	bl	8028d82 <__retarget_lock_acquire_recursive>
 802891a:	89a3      	ldrh	r3, [r4, #12]
 802891c:	0719      	lsls	r1, r3, #28
 802891e:	d502      	bpl.n	8028926 <_puts_r+0x2e>
 8028920:	6923      	ldr	r3, [r4, #16]
 8028922:	2b00      	cmp	r3, #0
 8028924:	d135      	bne.n	8028992 <_puts_r+0x9a>
 8028926:	4621      	mov	r1, r4
 8028928:	4628      	mov	r0, r5
 802892a:	f000 f8fb 	bl	8028b24 <__swsetup_r>
 802892e:	b380      	cbz	r0, 8028992 <_puts_r+0x9a>
 8028930:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
 8028934:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8028936:	07da      	lsls	r2, r3, #31
 8028938:	d405      	bmi.n	8028946 <_puts_r+0x4e>
 802893a:	89a3      	ldrh	r3, [r4, #12]
 802893c:	059b      	lsls	r3, r3, #22
 802893e:	d402      	bmi.n	8028946 <_puts_r+0x4e>
 8028940:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8028942:	f000 fa1f 	bl	8028d84 <__retarget_lock_release_recursive>
 8028946:	4628      	mov	r0, r5
 8028948:	bd70      	pop	{r4, r5, r6, pc}
 802894a:	2b00      	cmp	r3, #0
 802894c:	da04      	bge.n	8028958 <_puts_r+0x60>
 802894e:	69a2      	ldr	r2, [r4, #24]
 8028950:	429a      	cmp	r2, r3
 8028952:	dc17      	bgt.n	8028984 <_puts_r+0x8c>
 8028954:	290a      	cmp	r1, #10
 8028956:	d015      	beq.n	8028984 <_puts_r+0x8c>
 8028958:	6823      	ldr	r3, [r4, #0]
 802895a:	1c5a      	adds	r2, r3, #1
 802895c:	6022      	str	r2, [r4, #0]
 802895e:	7019      	strb	r1, [r3, #0]
 8028960:	68a3      	ldr	r3, [r4, #8]
 8028962:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8028966:	3b01      	subs	r3, #1
 8028968:	60a3      	str	r3, [r4, #8]
 802896a:	2900      	cmp	r1, #0
 802896c:	d1ed      	bne.n	802894a <_puts_r+0x52>
 802896e:	2b00      	cmp	r3, #0
 8028970:	da11      	bge.n	8028996 <_puts_r+0x9e>
 8028972:	4622      	mov	r2, r4
 8028974:	210a      	movs	r1, #10
 8028976:	4628      	mov	r0, r5
 8028978:	f000 f895 	bl	8028aa6 <__swbuf_r>
 802897c:	3001      	adds	r0, #1
 802897e:	d0d7      	beq.n	8028930 <_puts_r+0x38>
 8028980:	250a      	movs	r5, #10
 8028982:	e7d7      	b.n	8028934 <_puts_r+0x3c>
 8028984:	4622      	mov	r2, r4
 8028986:	4628      	mov	r0, r5
 8028988:	f000 f88d 	bl	8028aa6 <__swbuf_r>
 802898c:	3001      	adds	r0, #1
 802898e:	d1e7      	bne.n	8028960 <_puts_r+0x68>
 8028990:	e7ce      	b.n	8028930 <_puts_r+0x38>
 8028992:	3e01      	subs	r6, #1
 8028994:	e7e4      	b.n	8028960 <_puts_r+0x68>
 8028996:	6823      	ldr	r3, [r4, #0]
 8028998:	1c5a      	adds	r2, r3, #1
 802899a:	6022      	str	r2, [r4, #0]
 802899c:	220a      	movs	r2, #10
 802899e:	701a      	strb	r2, [r3, #0]
 80289a0:	e7ee      	b.n	8028980 <_puts_r+0x88>
	...

080289a4 <puts>:
 80289a4:	4b02      	ldr	r3, [pc, #8]	@ (80289b0 <puts+0xc>)
 80289a6:	4601      	mov	r1, r0
 80289a8:	6818      	ldr	r0, [r3, #0]
 80289aa:	f7ff bfa5 	b.w	80288f8 <_puts_r>
 80289ae:	bf00      	nop
 80289b0:	20000140 	.word	0x20000140

080289b4 <sniprintf>:
 80289b4:	b40c      	push	{r2, r3}
 80289b6:	b530      	push	{r4, r5, lr}
 80289b8:	4b18      	ldr	r3, [pc, #96]	@ (8028a1c <sniprintf+0x68>)
 80289ba:	1e0c      	subs	r4, r1, #0
 80289bc:	681d      	ldr	r5, [r3, #0]
 80289be:	b09d      	sub	sp, #116	@ 0x74
 80289c0:	da08      	bge.n	80289d4 <sniprintf+0x20>
 80289c2:	238b      	movs	r3, #139	@ 0x8b
 80289c4:	602b      	str	r3, [r5, #0]
 80289c6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80289ca:	b01d      	add	sp, #116	@ 0x74
 80289cc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80289d0:	b002      	add	sp, #8
 80289d2:	4770      	bx	lr
 80289d4:	f44f 7302 	mov.w	r3, #520	@ 0x208
 80289d8:	f8ad 3014 	strh.w	r3, [sp, #20]
 80289dc:	f04f 0300 	mov.w	r3, #0
 80289e0:	931b      	str	r3, [sp, #108]	@ 0x6c
 80289e2:	bf14      	ite	ne
 80289e4:	f104 33ff 	addne.w	r3, r4, #4294967295	@ 0xffffffff
 80289e8:	4623      	moveq	r3, r4
 80289ea:	9304      	str	r3, [sp, #16]
 80289ec:	9307      	str	r3, [sp, #28]
 80289ee:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80289f2:	9002      	str	r0, [sp, #8]
 80289f4:	9006      	str	r0, [sp, #24]
 80289f6:	f8ad 3016 	strh.w	r3, [sp, #22]
 80289fa:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 80289fc:	ab21      	add	r3, sp, #132	@ 0x84
 80289fe:	a902      	add	r1, sp, #8
 8028a00:	4628      	mov	r0, r5
 8028a02:	9301      	str	r3, [sp, #4]
 8028a04:	f000 fa7c 	bl	8028f00 <_svfiprintf_r>
 8028a08:	1c43      	adds	r3, r0, #1
 8028a0a:	bfbc      	itt	lt
 8028a0c:	238b      	movlt	r3, #139	@ 0x8b
 8028a0e:	602b      	strlt	r3, [r5, #0]
 8028a10:	2c00      	cmp	r4, #0
 8028a12:	d0da      	beq.n	80289ca <sniprintf+0x16>
 8028a14:	9b02      	ldr	r3, [sp, #8]
 8028a16:	2200      	movs	r2, #0
 8028a18:	701a      	strb	r2, [r3, #0]
 8028a1a:	e7d6      	b.n	80289ca <sniprintf+0x16>
 8028a1c:	20000140 	.word	0x20000140

08028a20 <__sread>:
 8028a20:	b510      	push	{r4, lr}
 8028a22:	460c      	mov	r4, r1
 8028a24:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8028a28:	f000 f94c 	bl	8028cc4 <_read_r>
 8028a2c:	2800      	cmp	r0, #0
 8028a2e:	bfab      	itete	ge
 8028a30:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 8028a32:	89a3      	ldrhlt	r3, [r4, #12]
 8028a34:	181b      	addge	r3, r3, r0
 8028a36:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 8028a3a:	bfac      	ite	ge
 8028a3c:	6563      	strge	r3, [r4, #84]	@ 0x54
 8028a3e:	81a3      	strhlt	r3, [r4, #12]
 8028a40:	bd10      	pop	{r4, pc}

08028a42 <__swrite>:
 8028a42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8028a46:	461f      	mov	r7, r3
 8028a48:	898b      	ldrh	r3, [r1, #12]
 8028a4a:	05db      	lsls	r3, r3, #23
 8028a4c:	4605      	mov	r5, r0
 8028a4e:	460c      	mov	r4, r1
 8028a50:	4616      	mov	r6, r2
 8028a52:	d505      	bpl.n	8028a60 <__swrite+0x1e>
 8028a54:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8028a58:	2302      	movs	r3, #2
 8028a5a:	2200      	movs	r2, #0
 8028a5c:	f000 f920 	bl	8028ca0 <_lseek_r>
 8028a60:	89a3      	ldrh	r3, [r4, #12]
 8028a62:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8028a66:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8028a6a:	81a3      	strh	r3, [r4, #12]
 8028a6c:	4632      	mov	r2, r6
 8028a6e:	463b      	mov	r3, r7
 8028a70:	4628      	mov	r0, r5
 8028a72:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8028a76:	f000 b947 	b.w	8028d08 <_write_r>

08028a7a <__sseek>:
 8028a7a:	b510      	push	{r4, lr}
 8028a7c:	460c      	mov	r4, r1
 8028a7e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8028a82:	f000 f90d 	bl	8028ca0 <_lseek_r>
 8028a86:	1c43      	adds	r3, r0, #1
 8028a88:	89a3      	ldrh	r3, [r4, #12]
 8028a8a:	bf15      	itete	ne
 8028a8c:	6560      	strne	r0, [r4, #84]	@ 0x54
 8028a8e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 8028a92:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 8028a96:	81a3      	strheq	r3, [r4, #12]
 8028a98:	bf18      	it	ne
 8028a9a:	81a3      	strhne	r3, [r4, #12]
 8028a9c:	bd10      	pop	{r4, pc}

08028a9e <__sclose>:
 8028a9e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8028aa2:	f000 b8ed 	b.w	8028c80 <_close_r>

08028aa6 <__swbuf_r>:
 8028aa6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028aa8:	460e      	mov	r6, r1
 8028aaa:	4614      	mov	r4, r2
 8028aac:	4605      	mov	r5, r0
 8028aae:	b118      	cbz	r0, 8028ab8 <__swbuf_r+0x12>
 8028ab0:	6a03      	ldr	r3, [r0, #32]
 8028ab2:	b90b      	cbnz	r3, 8028ab8 <__swbuf_r+0x12>
 8028ab4:	f7ff fed8 	bl	8028868 <__sinit>
 8028ab8:	69a3      	ldr	r3, [r4, #24]
 8028aba:	60a3      	str	r3, [r4, #8]
 8028abc:	89a3      	ldrh	r3, [r4, #12]
 8028abe:	071a      	lsls	r2, r3, #28
 8028ac0:	d501      	bpl.n	8028ac6 <__swbuf_r+0x20>
 8028ac2:	6923      	ldr	r3, [r4, #16]
 8028ac4:	b943      	cbnz	r3, 8028ad8 <__swbuf_r+0x32>
 8028ac6:	4621      	mov	r1, r4
 8028ac8:	4628      	mov	r0, r5
 8028aca:	f000 f82b 	bl	8028b24 <__swsetup_r>
 8028ace:	b118      	cbz	r0, 8028ad8 <__swbuf_r+0x32>
 8028ad0:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
 8028ad4:	4638      	mov	r0, r7
 8028ad6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8028ad8:	6823      	ldr	r3, [r4, #0]
 8028ada:	6922      	ldr	r2, [r4, #16]
 8028adc:	1a98      	subs	r0, r3, r2
 8028ade:	6963      	ldr	r3, [r4, #20]
 8028ae0:	b2f6      	uxtb	r6, r6
 8028ae2:	4283      	cmp	r3, r0
 8028ae4:	4637      	mov	r7, r6
 8028ae6:	dc05      	bgt.n	8028af4 <__swbuf_r+0x4e>
 8028ae8:	4621      	mov	r1, r4
 8028aea:	4628      	mov	r0, r5
 8028aec:	f000 fe56 	bl	802979c <_fflush_r>
 8028af0:	2800      	cmp	r0, #0
 8028af2:	d1ed      	bne.n	8028ad0 <__swbuf_r+0x2a>
 8028af4:	68a3      	ldr	r3, [r4, #8]
 8028af6:	3b01      	subs	r3, #1
 8028af8:	60a3      	str	r3, [r4, #8]
 8028afa:	6823      	ldr	r3, [r4, #0]
 8028afc:	1c5a      	adds	r2, r3, #1
 8028afe:	6022      	str	r2, [r4, #0]
 8028b00:	701e      	strb	r6, [r3, #0]
 8028b02:	6962      	ldr	r2, [r4, #20]
 8028b04:	1c43      	adds	r3, r0, #1
 8028b06:	429a      	cmp	r2, r3
 8028b08:	d004      	beq.n	8028b14 <__swbuf_r+0x6e>
 8028b0a:	89a3      	ldrh	r3, [r4, #12]
 8028b0c:	07db      	lsls	r3, r3, #31
 8028b0e:	d5e1      	bpl.n	8028ad4 <__swbuf_r+0x2e>
 8028b10:	2e0a      	cmp	r6, #10
 8028b12:	d1df      	bne.n	8028ad4 <__swbuf_r+0x2e>
 8028b14:	4621      	mov	r1, r4
 8028b16:	4628      	mov	r0, r5
 8028b18:	f000 fe40 	bl	802979c <_fflush_r>
 8028b1c:	2800      	cmp	r0, #0
 8028b1e:	d0d9      	beq.n	8028ad4 <__swbuf_r+0x2e>
 8028b20:	e7d6      	b.n	8028ad0 <__swbuf_r+0x2a>
	...

08028b24 <__swsetup_r>:
 8028b24:	b538      	push	{r3, r4, r5, lr}
 8028b26:	4b29      	ldr	r3, [pc, #164]	@ (8028bcc <__swsetup_r+0xa8>)
 8028b28:	4605      	mov	r5, r0
 8028b2a:	6818      	ldr	r0, [r3, #0]
 8028b2c:	460c      	mov	r4, r1
 8028b2e:	b118      	cbz	r0, 8028b38 <__swsetup_r+0x14>
 8028b30:	6a03      	ldr	r3, [r0, #32]
 8028b32:	b90b      	cbnz	r3, 8028b38 <__swsetup_r+0x14>
 8028b34:	f7ff fe98 	bl	8028868 <__sinit>
 8028b38:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8028b3c:	0719      	lsls	r1, r3, #28
 8028b3e:	d422      	bmi.n	8028b86 <__swsetup_r+0x62>
 8028b40:	06da      	lsls	r2, r3, #27
 8028b42:	d407      	bmi.n	8028b54 <__swsetup_r+0x30>
 8028b44:	2209      	movs	r2, #9
 8028b46:	602a      	str	r2, [r5, #0]
 8028b48:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8028b4c:	81a3      	strh	r3, [r4, #12]
 8028b4e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8028b52:	e033      	b.n	8028bbc <__swsetup_r+0x98>
 8028b54:	0758      	lsls	r0, r3, #29
 8028b56:	d512      	bpl.n	8028b7e <__swsetup_r+0x5a>
 8028b58:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8028b5a:	b141      	cbz	r1, 8028b6e <__swsetup_r+0x4a>
 8028b5c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8028b60:	4299      	cmp	r1, r3
 8028b62:	d002      	beq.n	8028b6a <__swsetup_r+0x46>
 8028b64:	4628      	mov	r0, r5
 8028b66:	f000 f91d 	bl	8028da4 <_free_r>
 8028b6a:	2300      	movs	r3, #0
 8028b6c:	6363      	str	r3, [r4, #52]	@ 0x34
 8028b6e:	89a3      	ldrh	r3, [r4, #12]
 8028b70:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 8028b74:	81a3      	strh	r3, [r4, #12]
 8028b76:	2300      	movs	r3, #0
 8028b78:	6063      	str	r3, [r4, #4]
 8028b7a:	6923      	ldr	r3, [r4, #16]
 8028b7c:	6023      	str	r3, [r4, #0]
 8028b7e:	89a3      	ldrh	r3, [r4, #12]
 8028b80:	f043 0308 	orr.w	r3, r3, #8
 8028b84:	81a3      	strh	r3, [r4, #12]
 8028b86:	6923      	ldr	r3, [r4, #16]
 8028b88:	b94b      	cbnz	r3, 8028b9e <__swsetup_r+0x7a>
 8028b8a:	89a3      	ldrh	r3, [r4, #12]
 8028b8c:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8028b90:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8028b94:	d003      	beq.n	8028b9e <__swsetup_r+0x7a>
 8028b96:	4621      	mov	r1, r4
 8028b98:	4628      	mov	r0, r5
 8028b9a:	f000 fe4d 	bl	8029838 <__smakebuf_r>
 8028b9e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8028ba2:	f013 0201 	ands.w	r2, r3, #1
 8028ba6:	d00a      	beq.n	8028bbe <__swsetup_r+0x9a>
 8028ba8:	2200      	movs	r2, #0
 8028baa:	60a2      	str	r2, [r4, #8]
 8028bac:	6962      	ldr	r2, [r4, #20]
 8028bae:	4252      	negs	r2, r2
 8028bb0:	61a2      	str	r2, [r4, #24]
 8028bb2:	6922      	ldr	r2, [r4, #16]
 8028bb4:	b942      	cbnz	r2, 8028bc8 <__swsetup_r+0xa4>
 8028bb6:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 8028bba:	d1c5      	bne.n	8028b48 <__swsetup_r+0x24>
 8028bbc:	bd38      	pop	{r3, r4, r5, pc}
 8028bbe:	0799      	lsls	r1, r3, #30
 8028bc0:	bf58      	it	pl
 8028bc2:	6962      	ldrpl	r2, [r4, #20]
 8028bc4:	60a2      	str	r2, [r4, #8]
 8028bc6:	e7f4      	b.n	8028bb2 <__swsetup_r+0x8e>
 8028bc8:	2000      	movs	r0, #0
 8028bca:	e7f7      	b.n	8028bbc <__swsetup_r+0x98>
 8028bcc:	20000140 	.word	0x20000140

08028bd0 <memcmp>:
 8028bd0:	b510      	push	{r4, lr}
 8028bd2:	3901      	subs	r1, #1
 8028bd4:	4402      	add	r2, r0
 8028bd6:	4290      	cmp	r0, r2
 8028bd8:	d101      	bne.n	8028bde <memcmp+0xe>
 8028bda:	2000      	movs	r0, #0
 8028bdc:	e005      	b.n	8028bea <memcmp+0x1a>
 8028bde:	7803      	ldrb	r3, [r0, #0]
 8028be0:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8028be4:	42a3      	cmp	r3, r4
 8028be6:	d001      	beq.n	8028bec <memcmp+0x1c>
 8028be8:	1b18      	subs	r0, r3, r4
 8028bea:	bd10      	pop	{r4, pc}
 8028bec:	3001      	adds	r0, #1
 8028bee:	e7f2      	b.n	8028bd6 <memcmp+0x6>

08028bf0 <memmove>:
 8028bf0:	4288      	cmp	r0, r1
 8028bf2:	b510      	push	{r4, lr}
 8028bf4:	eb01 0402 	add.w	r4, r1, r2
 8028bf8:	d902      	bls.n	8028c00 <memmove+0x10>
 8028bfa:	4284      	cmp	r4, r0
 8028bfc:	4623      	mov	r3, r4
 8028bfe:	d807      	bhi.n	8028c10 <memmove+0x20>
 8028c00:	1e43      	subs	r3, r0, #1
 8028c02:	42a1      	cmp	r1, r4
 8028c04:	d008      	beq.n	8028c18 <memmove+0x28>
 8028c06:	f811 2b01 	ldrb.w	r2, [r1], #1
 8028c0a:	f803 2f01 	strb.w	r2, [r3, #1]!
 8028c0e:	e7f8      	b.n	8028c02 <memmove+0x12>
 8028c10:	4402      	add	r2, r0
 8028c12:	4601      	mov	r1, r0
 8028c14:	428a      	cmp	r2, r1
 8028c16:	d100      	bne.n	8028c1a <memmove+0x2a>
 8028c18:	bd10      	pop	{r4, pc}
 8028c1a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8028c1e:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8028c22:	e7f7      	b.n	8028c14 <memmove+0x24>

08028c24 <memset>:
 8028c24:	4402      	add	r2, r0
 8028c26:	4603      	mov	r3, r0
 8028c28:	4293      	cmp	r3, r2
 8028c2a:	d100      	bne.n	8028c2e <memset+0xa>
 8028c2c:	4770      	bx	lr
 8028c2e:	f803 1b01 	strb.w	r1, [r3], #1
 8028c32:	e7f9      	b.n	8028c28 <memset+0x4>

08028c34 <strncmp>:
 8028c34:	b510      	push	{r4, lr}
 8028c36:	b16a      	cbz	r2, 8028c54 <strncmp+0x20>
 8028c38:	3901      	subs	r1, #1
 8028c3a:	1884      	adds	r4, r0, r2
 8028c3c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8028c40:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8028c44:	429a      	cmp	r2, r3
 8028c46:	d103      	bne.n	8028c50 <strncmp+0x1c>
 8028c48:	42a0      	cmp	r0, r4
 8028c4a:	d001      	beq.n	8028c50 <strncmp+0x1c>
 8028c4c:	2a00      	cmp	r2, #0
 8028c4e:	d1f5      	bne.n	8028c3c <strncmp+0x8>
 8028c50:	1ad0      	subs	r0, r2, r3
 8028c52:	bd10      	pop	{r4, pc}
 8028c54:	4610      	mov	r0, r2
 8028c56:	e7fc      	b.n	8028c52 <strncmp+0x1e>

08028c58 <strncpy>:
 8028c58:	b510      	push	{r4, lr}
 8028c5a:	3901      	subs	r1, #1
 8028c5c:	4603      	mov	r3, r0
 8028c5e:	b132      	cbz	r2, 8028c6e <strncpy+0x16>
 8028c60:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8028c64:	f803 4b01 	strb.w	r4, [r3], #1
 8028c68:	3a01      	subs	r2, #1
 8028c6a:	2c00      	cmp	r4, #0
 8028c6c:	d1f7      	bne.n	8028c5e <strncpy+0x6>
 8028c6e:	441a      	add	r2, r3
 8028c70:	2100      	movs	r1, #0
 8028c72:	4293      	cmp	r3, r2
 8028c74:	d100      	bne.n	8028c78 <strncpy+0x20>
 8028c76:	bd10      	pop	{r4, pc}
 8028c78:	f803 1b01 	strb.w	r1, [r3], #1
 8028c7c:	e7f9      	b.n	8028c72 <strncpy+0x1a>
	...

08028c80 <_close_r>:
 8028c80:	b538      	push	{r3, r4, r5, lr}
 8028c82:	4d06      	ldr	r5, [pc, #24]	@ (8028c9c <_close_r+0x1c>)
 8028c84:	2300      	movs	r3, #0
 8028c86:	4604      	mov	r4, r0
 8028c88:	4608      	mov	r0, r1
 8028c8a:	602b      	str	r3, [r5, #0]
 8028c8c:	f7d9 f811 	bl	8001cb2 <_close>
 8028c90:	1c43      	adds	r3, r0, #1
 8028c92:	d102      	bne.n	8028c9a <_close_r+0x1a>
 8028c94:	682b      	ldr	r3, [r5, #0]
 8028c96:	b103      	cbz	r3, 8028c9a <_close_r+0x1a>
 8028c98:	6023      	str	r3, [r4, #0]
 8028c9a:	bd38      	pop	{r3, r4, r5, pc}
 8028c9c:	20003984 	.word	0x20003984

08028ca0 <_lseek_r>:
 8028ca0:	b538      	push	{r3, r4, r5, lr}
 8028ca2:	4d07      	ldr	r5, [pc, #28]	@ (8028cc0 <_lseek_r+0x20>)
 8028ca4:	4604      	mov	r4, r0
 8028ca6:	4608      	mov	r0, r1
 8028ca8:	4611      	mov	r1, r2
 8028caa:	2200      	movs	r2, #0
 8028cac:	602a      	str	r2, [r5, #0]
 8028cae:	461a      	mov	r2, r3
 8028cb0:	f7d9 f826 	bl	8001d00 <_lseek>
 8028cb4:	1c43      	adds	r3, r0, #1
 8028cb6:	d102      	bne.n	8028cbe <_lseek_r+0x1e>
 8028cb8:	682b      	ldr	r3, [r5, #0]
 8028cba:	b103      	cbz	r3, 8028cbe <_lseek_r+0x1e>
 8028cbc:	6023      	str	r3, [r4, #0]
 8028cbe:	bd38      	pop	{r3, r4, r5, pc}
 8028cc0:	20003984 	.word	0x20003984

08028cc4 <_read_r>:
 8028cc4:	b538      	push	{r3, r4, r5, lr}
 8028cc6:	4d07      	ldr	r5, [pc, #28]	@ (8028ce4 <_read_r+0x20>)
 8028cc8:	4604      	mov	r4, r0
 8028cca:	4608      	mov	r0, r1
 8028ccc:	4611      	mov	r1, r2
 8028cce:	2200      	movs	r2, #0
 8028cd0:	602a      	str	r2, [r5, #0]
 8028cd2:	461a      	mov	r2, r3
 8028cd4:	f7d8 ffb4 	bl	8001c40 <_read>
 8028cd8:	1c43      	adds	r3, r0, #1
 8028cda:	d102      	bne.n	8028ce2 <_read_r+0x1e>
 8028cdc:	682b      	ldr	r3, [r5, #0]
 8028cde:	b103      	cbz	r3, 8028ce2 <_read_r+0x1e>
 8028ce0:	6023      	str	r3, [r4, #0]
 8028ce2:	bd38      	pop	{r3, r4, r5, pc}
 8028ce4:	20003984 	.word	0x20003984

08028ce8 <_sbrk_r>:
 8028ce8:	b538      	push	{r3, r4, r5, lr}
 8028cea:	4d06      	ldr	r5, [pc, #24]	@ (8028d04 <_sbrk_r+0x1c>)
 8028cec:	2300      	movs	r3, #0
 8028cee:	4604      	mov	r4, r0
 8028cf0:	4608      	mov	r0, r1
 8028cf2:	602b      	str	r3, [r5, #0]
 8028cf4:	f7d9 f812 	bl	8001d1c <_sbrk>
 8028cf8:	1c43      	adds	r3, r0, #1
 8028cfa:	d102      	bne.n	8028d02 <_sbrk_r+0x1a>
 8028cfc:	682b      	ldr	r3, [r5, #0]
 8028cfe:	b103      	cbz	r3, 8028d02 <_sbrk_r+0x1a>
 8028d00:	6023      	str	r3, [r4, #0]
 8028d02:	bd38      	pop	{r3, r4, r5, pc}
 8028d04:	20003984 	.word	0x20003984

08028d08 <_write_r>:
 8028d08:	b538      	push	{r3, r4, r5, lr}
 8028d0a:	4d07      	ldr	r5, [pc, #28]	@ (8028d28 <_write_r+0x20>)
 8028d0c:	4604      	mov	r4, r0
 8028d0e:	4608      	mov	r0, r1
 8028d10:	4611      	mov	r1, r2
 8028d12:	2200      	movs	r2, #0
 8028d14:	602a      	str	r2, [r5, #0]
 8028d16:	461a      	mov	r2, r3
 8028d18:	f7d8 ffaf 	bl	8001c7a <_write>
 8028d1c:	1c43      	adds	r3, r0, #1
 8028d1e:	d102      	bne.n	8028d26 <_write_r+0x1e>
 8028d20:	682b      	ldr	r3, [r5, #0]
 8028d22:	b103      	cbz	r3, 8028d26 <_write_r+0x1e>
 8028d24:	6023      	str	r3, [r4, #0]
 8028d26:	bd38      	pop	{r3, r4, r5, pc}
 8028d28:	20003984 	.word	0x20003984

08028d2c <__errno>:
 8028d2c:	4b01      	ldr	r3, [pc, #4]	@ (8028d34 <__errno+0x8>)
 8028d2e:	6818      	ldr	r0, [r3, #0]
 8028d30:	4770      	bx	lr
 8028d32:	bf00      	nop
 8028d34:	20000140 	.word	0x20000140

08028d38 <__libc_init_array>:
 8028d38:	b570      	push	{r4, r5, r6, lr}
 8028d3a:	4d0d      	ldr	r5, [pc, #52]	@ (8028d70 <__libc_init_array+0x38>)
 8028d3c:	4c0d      	ldr	r4, [pc, #52]	@ (8028d74 <__libc_init_array+0x3c>)
 8028d3e:	1b64      	subs	r4, r4, r5
 8028d40:	10a4      	asrs	r4, r4, #2
 8028d42:	2600      	movs	r6, #0
 8028d44:	42a6      	cmp	r6, r4
 8028d46:	d109      	bne.n	8028d5c <__libc_init_array+0x24>
 8028d48:	4d0b      	ldr	r5, [pc, #44]	@ (8028d78 <__libc_init_array+0x40>)
 8028d4a:	4c0c      	ldr	r4, [pc, #48]	@ (8028d7c <__libc_init_array+0x44>)
 8028d4c:	f000 fdd2 	bl	80298f4 <_init>
 8028d50:	1b64      	subs	r4, r4, r5
 8028d52:	10a4      	asrs	r4, r4, #2
 8028d54:	2600      	movs	r6, #0
 8028d56:	42a6      	cmp	r6, r4
 8028d58:	d105      	bne.n	8028d66 <__libc_init_array+0x2e>
 8028d5a:	bd70      	pop	{r4, r5, r6, pc}
 8028d5c:	f855 3b04 	ldr.w	r3, [r5], #4
 8028d60:	4798      	blx	r3
 8028d62:	3601      	adds	r6, #1
 8028d64:	e7ee      	b.n	8028d44 <__libc_init_array+0xc>
 8028d66:	f855 3b04 	ldr.w	r3, [r5], #4
 8028d6a:	4798      	blx	r3
 8028d6c:	3601      	adds	r6, #1
 8028d6e:	e7f2      	b.n	8028d56 <__libc_init_array+0x1e>
 8028d70:	08034d34 	.word	0x08034d34
 8028d74:	08034d34 	.word	0x08034d34
 8028d78:	08034d34 	.word	0x08034d34
 8028d7c:	08034d38 	.word	0x08034d38

08028d80 <__retarget_lock_init_recursive>:
 8028d80:	4770      	bx	lr

08028d82 <__retarget_lock_acquire_recursive>:
 8028d82:	4770      	bx	lr

08028d84 <__retarget_lock_release_recursive>:
 8028d84:	4770      	bx	lr

08028d86 <memcpy>:
 8028d86:	440a      	add	r2, r1
 8028d88:	4291      	cmp	r1, r2
 8028d8a:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
 8028d8e:	d100      	bne.n	8028d92 <memcpy+0xc>
 8028d90:	4770      	bx	lr
 8028d92:	b510      	push	{r4, lr}
 8028d94:	f811 4b01 	ldrb.w	r4, [r1], #1
 8028d98:	f803 4f01 	strb.w	r4, [r3, #1]!
 8028d9c:	4291      	cmp	r1, r2
 8028d9e:	d1f9      	bne.n	8028d94 <memcpy+0xe>
 8028da0:	bd10      	pop	{r4, pc}
	...

08028da4 <_free_r>:
 8028da4:	b538      	push	{r3, r4, r5, lr}
 8028da6:	4605      	mov	r5, r0
 8028da8:	2900      	cmp	r1, #0
 8028daa:	d041      	beq.n	8028e30 <_free_r+0x8c>
 8028dac:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8028db0:	1f0c      	subs	r4, r1, #4
 8028db2:	2b00      	cmp	r3, #0
 8028db4:	bfb8      	it	lt
 8028db6:	18e4      	addlt	r4, r4, r3
 8028db8:	f7ff fc90 	bl	80286dc <__malloc_lock>
 8028dbc:	4a1d      	ldr	r2, [pc, #116]	@ (8028e34 <_free_r+0x90>)
 8028dbe:	6813      	ldr	r3, [r2, #0]
 8028dc0:	b933      	cbnz	r3, 8028dd0 <_free_r+0x2c>
 8028dc2:	6063      	str	r3, [r4, #4]
 8028dc4:	6014      	str	r4, [r2, #0]
 8028dc6:	4628      	mov	r0, r5
 8028dc8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8028dcc:	f7ff bc8c 	b.w	80286e8 <__malloc_unlock>
 8028dd0:	42a3      	cmp	r3, r4
 8028dd2:	d908      	bls.n	8028de6 <_free_r+0x42>
 8028dd4:	6820      	ldr	r0, [r4, #0]
 8028dd6:	1821      	adds	r1, r4, r0
 8028dd8:	428b      	cmp	r3, r1
 8028dda:	bf01      	itttt	eq
 8028ddc:	6819      	ldreq	r1, [r3, #0]
 8028dde:	685b      	ldreq	r3, [r3, #4]
 8028de0:	1809      	addeq	r1, r1, r0
 8028de2:	6021      	streq	r1, [r4, #0]
 8028de4:	e7ed      	b.n	8028dc2 <_free_r+0x1e>
 8028de6:	461a      	mov	r2, r3
 8028de8:	685b      	ldr	r3, [r3, #4]
 8028dea:	b10b      	cbz	r3, 8028df0 <_free_r+0x4c>
 8028dec:	42a3      	cmp	r3, r4
 8028dee:	d9fa      	bls.n	8028de6 <_free_r+0x42>
 8028df0:	6811      	ldr	r1, [r2, #0]
 8028df2:	1850      	adds	r0, r2, r1
 8028df4:	42a0      	cmp	r0, r4
 8028df6:	d10b      	bne.n	8028e10 <_free_r+0x6c>
 8028df8:	6820      	ldr	r0, [r4, #0]
 8028dfa:	4401      	add	r1, r0
 8028dfc:	1850      	adds	r0, r2, r1
 8028dfe:	4283      	cmp	r3, r0
 8028e00:	6011      	str	r1, [r2, #0]
 8028e02:	d1e0      	bne.n	8028dc6 <_free_r+0x22>
 8028e04:	6818      	ldr	r0, [r3, #0]
 8028e06:	685b      	ldr	r3, [r3, #4]
 8028e08:	6053      	str	r3, [r2, #4]
 8028e0a:	4408      	add	r0, r1
 8028e0c:	6010      	str	r0, [r2, #0]
 8028e0e:	e7da      	b.n	8028dc6 <_free_r+0x22>
 8028e10:	d902      	bls.n	8028e18 <_free_r+0x74>
 8028e12:	230c      	movs	r3, #12
 8028e14:	602b      	str	r3, [r5, #0]
 8028e16:	e7d6      	b.n	8028dc6 <_free_r+0x22>
 8028e18:	6820      	ldr	r0, [r4, #0]
 8028e1a:	1821      	adds	r1, r4, r0
 8028e1c:	428b      	cmp	r3, r1
 8028e1e:	bf04      	itt	eq
 8028e20:	6819      	ldreq	r1, [r3, #0]
 8028e22:	685b      	ldreq	r3, [r3, #4]
 8028e24:	6063      	str	r3, [r4, #4]
 8028e26:	bf04      	itt	eq
 8028e28:	1809      	addeq	r1, r1, r0
 8028e2a:	6021      	streq	r1, [r4, #0]
 8028e2c:	6054      	str	r4, [r2, #4]
 8028e2e:	e7ca      	b.n	8028dc6 <_free_r+0x22>
 8028e30:	bd38      	pop	{r3, r4, r5, pc}
 8028e32:	bf00      	nop
 8028e34:	20003844 	.word	0x20003844

08028e38 <_malloc_usable_size_r>:
 8028e38:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8028e3c:	1f18      	subs	r0, r3, #4
 8028e3e:	2b00      	cmp	r3, #0
 8028e40:	bfbc      	itt	lt
 8028e42:	580b      	ldrlt	r3, [r1, r0]
 8028e44:	18c0      	addlt	r0, r0, r3
 8028e46:	4770      	bx	lr

08028e48 <__ssputs_r>:
 8028e48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028e4c:	688e      	ldr	r6, [r1, #8]
 8028e4e:	461f      	mov	r7, r3
 8028e50:	42be      	cmp	r6, r7
 8028e52:	680b      	ldr	r3, [r1, #0]
 8028e54:	4682      	mov	sl, r0
 8028e56:	460c      	mov	r4, r1
 8028e58:	4690      	mov	r8, r2
 8028e5a:	d82d      	bhi.n	8028eb8 <__ssputs_r+0x70>
 8028e5c:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8028e60:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 8028e64:	d026      	beq.n	8028eb4 <__ssputs_r+0x6c>
 8028e66:	6965      	ldr	r5, [r4, #20]
 8028e68:	6909      	ldr	r1, [r1, #16]
 8028e6a:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8028e6e:	eba3 0901 	sub.w	r9, r3, r1
 8028e72:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8028e76:	1c7b      	adds	r3, r7, #1
 8028e78:	444b      	add	r3, r9
 8028e7a:	106d      	asrs	r5, r5, #1
 8028e7c:	429d      	cmp	r5, r3
 8028e7e:	bf38      	it	cc
 8028e80:	461d      	movcc	r5, r3
 8028e82:	0553      	lsls	r3, r2, #21
 8028e84:	d527      	bpl.n	8028ed6 <__ssputs_r+0x8e>
 8028e86:	4629      	mov	r1, r5
 8028e88:	f7ff fba8 	bl	80285dc <_malloc_r>
 8028e8c:	4606      	mov	r6, r0
 8028e8e:	b360      	cbz	r0, 8028eea <__ssputs_r+0xa2>
 8028e90:	6921      	ldr	r1, [r4, #16]
 8028e92:	464a      	mov	r2, r9
 8028e94:	f7ff ff77 	bl	8028d86 <memcpy>
 8028e98:	89a3      	ldrh	r3, [r4, #12]
 8028e9a:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 8028e9e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8028ea2:	81a3      	strh	r3, [r4, #12]
 8028ea4:	6126      	str	r6, [r4, #16]
 8028ea6:	6165      	str	r5, [r4, #20]
 8028ea8:	444e      	add	r6, r9
 8028eaa:	eba5 0509 	sub.w	r5, r5, r9
 8028eae:	6026      	str	r6, [r4, #0]
 8028eb0:	60a5      	str	r5, [r4, #8]
 8028eb2:	463e      	mov	r6, r7
 8028eb4:	42be      	cmp	r6, r7
 8028eb6:	d900      	bls.n	8028eba <__ssputs_r+0x72>
 8028eb8:	463e      	mov	r6, r7
 8028eba:	6820      	ldr	r0, [r4, #0]
 8028ebc:	4632      	mov	r2, r6
 8028ebe:	4641      	mov	r1, r8
 8028ec0:	f7ff fe96 	bl	8028bf0 <memmove>
 8028ec4:	68a3      	ldr	r3, [r4, #8]
 8028ec6:	1b9b      	subs	r3, r3, r6
 8028ec8:	60a3      	str	r3, [r4, #8]
 8028eca:	6823      	ldr	r3, [r4, #0]
 8028ecc:	4433      	add	r3, r6
 8028ece:	6023      	str	r3, [r4, #0]
 8028ed0:	2000      	movs	r0, #0
 8028ed2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028ed6:	462a      	mov	r2, r5
 8028ed8:	f7ff fc0c 	bl	80286f4 <_realloc_r>
 8028edc:	4606      	mov	r6, r0
 8028ede:	2800      	cmp	r0, #0
 8028ee0:	d1e0      	bne.n	8028ea4 <__ssputs_r+0x5c>
 8028ee2:	6921      	ldr	r1, [r4, #16]
 8028ee4:	4650      	mov	r0, sl
 8028ee6:	f7ff ff5d 	bl	8028da4 <_free_r>
 8028eea:	230c      	movs	r3, #12
 8028eec:	f8ca 3000 	str.w	r3, [sl]
 8028ef0:	89a3      	ldrh	r3, [r4, #12]
 8028ef2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8028ef6:	81a3      	strh	r3, [r4, #12]
 8028ef8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8028efc:	e7e9      	b.n	8028ed2 <__ssputs_r+0x8a>
	...

08028f00 <_svfiprintf_r>:
 8028f00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028f04:	4698      	mov	r8, r3
 8028f06:	898b      	ldrh	r3, [r1, #12]
 8028f08:	061b      	lsls	r3, r3, #24
 8028f0a:	b09d      	sub	sp, #116	@ 0x74
 8028f0c:	4607      	mov	r7, r0
 8028f0e:	460d      	mov	r5, r1
 8028f10:	4614      	mov	r4, r2
 8028f12:	d510      	bpl.n	8028f36 <_svfiprintf_r+0x36>
 8028f14:	690b      	ldr	r3, [r1, #16]
 8028f16:	b973      	cbnz	r3, 8028f36 <_svfiprintf_r+0x36>
 8028f18:	2140      	movs	r1, #64	@ 0x40
 8028f1a:	f7ff fb5f 	bl	80285dc <_malloc_r>
 8028f1e:	6028      	str	r0, [r5, #0]
 8028f20:	6128      	str	r0, [r5, #16]
 8028f22:	b930      	cbnz	r0, 8028f32 <_svfiprintf_r+0x32>
 8028f24:	230c      	movs	r3, #12
 8028f26:	603b      	str	r3, [r7, #0]
 8028f28:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8028f2c:	b01d      	add	sp, #116	@ 0x74
 8028f2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028f32:	2340      	movs	r3, #64	@ 0x40
 8028f34:	616b      	str	r3, [r5, #20]
 8028f36:	2300      	movs	r3, #0
 8028f38:	9309      	str	r3, [sp, #36]	@ 0x24
 8028f3a:	2320      	movs	r3, #32
 8028f3c:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 8028f40:	f8cd 800c 	str.w	r8, [sp, #12]
 8028f44:	2330      	movs	r3, #48	@ 0x30
 8028f46:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 80290e4 <_svfiprintf_r+0x1e4>
 8028f4a:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 8028f4e:	f04f 0901 	mov.w	r9, #1
 8028f52:	4623      	mov	r3, r4
 8028f54:	469a      	mov	sl, r3
 8028f56:	f813 2b01 	ldrb.w	r2, [r3], #1
 8028f5a:	b10a      	cbz	r2, 8028f60 <_svfiprintf_r+0x60>
 8028f5c:	2a25      	cmp	r2, #37	@ 0x25
 8028f5e:	d1f9      	bne.n	8028f54 <_svfiprintf_r+0x54>
 8028f60:	ebba 0b04 	subs.w	fp, sl, r4
 8028f64:	d00b      	beq.n	8028f7e <_svfiprintf_r+0x7e>
 8028f66:	465b      	mov	r3, fp
 8028f68:	4622      	mov	r2, r4
 8028f6a:	4629      	mov	r1, r5
 8028f6c:	4638      	mov	r0, r7
 8028f6e:	f7ff ff6b 	bl	8028e48 <__ssputs_r>
 8028f72:	3001      	adds	r0, #1
 8028f74:	f000 80a7 	beq.w	80290c6 <_svfiprintf_r+0x1c6>
 8028f78:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8028f7a:	445a      	add	r2, fp
 8028f7c:	9209      	str	r2, [sp, #36]	@ 0x24
 8028f7e:	f89a 3000 	ldrb.w	r3, [sl]
 8028f82:	2b00      	cmp	r3, #0
 8028f84:	f000 809f 	beq.w	80290c6 <_svfiprintf_r+0x1c6>
 8028f88:	2300      	movs	r3, #0
 8028f8a:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8028f8e:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8028f92:	f10a 0a01 	add.w	sl, sl, #1
 8028f96:	9304      	str	r3, [sp, #16]
 8028f98:	9307      	str	r3, [sp, #28]
 8028f9a:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8028f9e:	931a      	str	r3, [sp, #104]	@ 0x68
 8028fa0:	4654      	mov	r4, sl
 8028fa2:	2205      	movs	r2, #5
 8028fa4:	f814 1b01 	ldrb.w	r1, [r4], #1
 8028fa8:	484e      	ldr	r0, [pc, #312]	@ (80290e4 <_svfiprintf_r+0x1e4>)
 8028faa:	f7d7 f929 	bl	8000200 <memchr>
 8028fae:	9a04      	ldr	r2, [sp, #16]
 8028fb0:	b9d8      	cbnz	r0, 8028fea <_svfiprintf_r+0xea>
 8028fb2:	06d0      	lsls	r0, r2, #27
 8028fb4:	bf44      	itt	mi
 8028fb6:	2320      	movmi	r3, #32
 8028fb8:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8028fbc:	0711      	lsls	r1, r2, #28
 8028fbe:	bf44      	itt	mi
 8028fc0:	232b      	movmi	r3, #43	@ 0x2b
 8028fc2:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8028fc6:	f89a 3000 	ldrb.w	r3, [sl]
 8028fca:	2b2a      	cmp	r3, #42	@ 0x2a
 8028fcc:	d015      	beq.n	8028ffa <_svfiprintf_r+0xfa>
 8028fce:	9a07      	ldr	r2, [sp, #28]
 8028fd0:	4654      	mov	r4, sl
 8028fd2:	2000      	movs	r0, #0
 8028fd4:	f04f 0c0a 	mov.w	ip, #10
 8028fd8:	4621      	mov	r1, r4
 8028fda:	f811 3b01 	ldrb.w	r3, [r1], #1
 8028fde:	3b30      	subs	r3, #48	@ 0x30
 8028fe0:	2b09      	cmp	r3, #9
 8028fe2:	d94b      	bls.n	802907c <_svfiprintf_r+0x17c>
 8028fe4:	b1b0      	cbz	r0, 8029014 <_svfiprintf_r+0x114>
 8028fe6:	9207      	str	r2, [sp, #28]
 8028fe8:	e014      	b.n	8029014 <_svfiprintf_r+0x114>
 8028fea:	eba0 0308 	sub.w	r3, r0, r8
 8028fee:	fa09 f303 	lsl.w	r3, r9, r3
 8028ff2:	4313      	orrs	r3, r2
 8028ff4:	9304      	str	r3, [sp, #16]
 8028ff6:	46a2      	mov	sl, r4
 8028ff8:	e7d2      	b.n	8028fa0 <_svfiprintf_r+0xa0>
 8028ffa:	9b03      	ldr	r3, [sp, #12]
 8028ffc:	1d19      	adds	r1, r3, #4
 8028ffe:	681b      	ldr	r3, [r3, #0]
 8029000:	9103      	str	r1, [sp, #12]
 8029002:	2b00      	cmp	r3, #0
 8029004:	bfbb      	ittet	lt
 8029006:	425b      	neglt	r3, r3
 8029008:	f042 0202 	orrlt.w	r2, r2, #2
 802900c:	9307      	strge	r3, [sp, #28]
 802900e:	9307      	strlt	r3, [sp, #28]
 8029010:	bfb8      	it	lt
 8029012:	9204      	strlt	r2, [sp, #16]
 8029014:	7823      	ldrb	r3, [r4, #0]
 8029016:	2b2e      	cmp	r3, #46	@ 0x2e
 8029018:	d10a      	bne.n	8029030 <_svfiprintf_r+0x130>
 802901a:	7863      	ldrb	r3, [r4, #1]
 802901c:	2b2a      	cmp	r3, #42	@ 0x2a
 802901e:	d132      	bne.n	8029086 <_svfiprintf_r+0x186>
 8029020:	9b03      	ldr	r3, [sp, #12]
 8029022:	1d1a      	adds	r2, r3, #4
 8029024:	681b      	ldr	r3, [r3, #0]
 8029026:	9203      	str	r2, [sp, #12]
 8029028:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 802902c:	3402      	adds	r4, #2
 802902e:	9305      	str	r3, [sp, #20]
 8029030:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 80290f4 <_svfiprintf_r+0x1f4>
 8029034:	7821      	ldrb	r1, [r4, #0]
 8029036:	2203      	movs	r2, #3
 8029038:	4650      	mov	r0, sl
 802903a:	f7d7 f8e1 	bl	8000200 <memchr>
 802903e:	b138      	cbz	r0, 8029050 <_svfiprintf_r+0x150>
 8029040:	9b04      	ldr	r3, [sp, #16]
 8029042:	eba0 000a 	sub.w	r0, r0, sl
 8029046:	2240      	movs	r2, #64	@ 0x40
 8029048:	4082      	lsls	r2, r0
 802904a:	4313      	orrs	r3, r2
 802904c:	3401      	adds	r4, #1
 802904e:	9304      	str	r3, [sp, #16]
 8029050:	f814 1b01 	ldrb.w	r1, [r4], #1
 8029054:	4824      	ldr	r0, [pc, #144]	@ (80290e8 <_svfiprintf_r+0x1e8>)
 8029056:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 802905a:	2206      	movs	r2, #6
 802905c:	f7d7 f8d0 	bl	8000200 <memchr>
 8029060:	2800      	cmp	r0, #0
 8029062:	d036      	beq.n	80290d2 <_svfiprintf_r+0x1d2>
 8029064:	4b21      	ldr	r3, [pc, #132]	@ (80290ec <_svfiprintf_r+0x1ec>)
 8029066:	bb1b      	cbnz	r3, 80290b0 <_svfiprintf_r+0x1b0>
 8029068:	9b03      	ldr	r3, [sp, #12]
 802906a:	3307      	adds	r3, #7
 802906c:	f023 0307 	bic.w	r3, r3, #7
 8029070:	3308      	adds	r3, #8
 8029072:	9303      	str	r3, [sp, #12]
 8029074:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8029076:	4433      	add	r3, r6
 8029078:	9309      	str	r3, [sp, #36]	@ 0x24
 802907a:	e76a      	b.n	8028f52 <_svfiprintf_r+0x52>
 802907c:	fb0c 3202 	mla	r2, ip, r2, r3
 8029080:	460c      	mov	r4, r1
 8029082:	2001      	movs	r0, #1
 8029084:	e7a8      	b.n	8028fd8 <_svfiprintf_r+0xd8>
 8029086:	2300      	movs	r3, #0
 8029088:	3401      	adds	r4, #1
 802908a:	9305      	str	r3, [sp, #20]
 802908c:	4619      	mov	r1, r3
 802908e:	f04f 0c0a 	mov.w	ip, #10
 8029092:	4620      	mov	r0, r4
 8029094:	f810 2b01 	ldrb.w	r2, [r0], #1
 8029098:	3a30      	subs	r2, #48	@ 0x30
 802909a:	2a09      	cmp	r2, #9
 802909c:	d903      	bls.n	80290a6 <_svfiprintf_r+0x1a6>
 802909e:	2b00      	cmp	r3, #0
 80290a0:	d0c6      	beq.n	8029030 <_svfiprintf_r+0x130>
 80290a2:	9105      	str	r1, [sp, #20]
 80290a4:	e7c4      	b.n	8029030 <_svfiprintf_r+0x130>
 80290a6:	fb0c 2101 	mla	r1, ip, r1, r2
 80290aa:	4604      	mov	r4, r0
 80290ac:	2301      	movs	r3, #1
 80290ae:	e7f0      	b.n	8029092 <_svfiprintf_r+0x192>
 80290b0:	ab03      	add	r3, sp, #12
 80290b2:	9300      	str	r3, [sp, #0]
 80290b4:	462a      	mov	r2, r5
 80290b6:	4b0e      	ldr	r3, [pc, #56]	@ (80290f0 <_svfiprintf_r+0x1f0>)
 80290b8:	a904      	add	r1, sp, #16
 80290ba:	4638      	mov	r0, r7
 80290bc:	f3af 8000 	nop.w
 80290c0:	1c42      	adds	r2, r0, #1
 80290c2:	4606      	mov	r6, r0
 80290c4:	d1d6      	bne.n	8029074 <_svfiprintf_r+0x174>
 80290c6:	89ab      	ldrh	r3, [r5, #12]
 80290c8:	065b      	lsls	r3, r3, #25
 80290ca:	f53f af2d 	bmi.w	8028f28 <_svfiprintf_r+0x28>
 80290ce:	9809      	ldr	r0, [sp, #36]	@ 0x24
 80290d0:	e72c      	b.n	8028f2c <_svfiprintf_r+0x2c>
 80290d2:	ab03      	add	r3, sp, #12
 80290d4:	9300      	str	r3, [sp, #0]
 80290d6:	462a      	mov	r2, r5
 80290d8:	4b05      	ldr	r3, [pc, #20]	@ (80290f0 <_svfiprintf_r+0x1f0>)
 80290da:	a904      	add	r1, sp, #16
 80290dc:	4638      	mov	r0, r7
 80290de:	f000 f9bb 	bl	8029458 <_printf_i>
 80290e2:	e7ed      	b.n	80290c0 <_svfiprintf_r+0x1c0>
 80290e4:	08034cf9 	.word	0x08034cf9
 80290e8:	08034d03 	.word	0x08034d03
 80290ec:	00000000 	.word	0x00000000
 80290f0:	08028e49 	.word	0x08028e49
 80290f4:	08034cff 	.word	0x08034cff

080290f8 <__sfputc_r>:
 80290f8:	6893      	ldr	r3, [r2, #8]
 80290fa:	3b01      	subs	r3, #1
 80290fc:	2b00      	cmp	r3, #0
 80290fe:	b410      	push	{r4}
 8029100:	6093      	str	r3, [r2, #8]
 8029102:	da08      	bge.n	8029116 <__sfputc_r+0x1e>
 8029104:	6994      	ldr	r4, [r2, #24]
 8029106:	42a3      	cmp	r3, r4
 8029108:	db01      	blt.n	802910e <__sfputc_r+0x16>
 802910a:	290a      	cmp	r1, #10
 802910c:	d103      	bne.n	8029116 <__sfputc_r+0x1e>
 802910e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8029112:	f7ff bcc8 	b.w	8028aa6 <__swbuf_r>
 8029116:	6813      	ldr	r3, [r2, #0]
 8029118:	1c58      	adds	r0, r3, #1
 802911a:	6010      	str	r0, [r2, #0]
 802911c:	7019      	strb	r1, [r3, #0]
 802911e:	4608      	mov	r0, r1
 8029120:	f85d 4b04 	ldr.w	r4, [sp], #4
 8029124:	4770      	bx	lr

08029126 <__sfputs_r>:
 8029126:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8029128:	4606      	mov	r6, r0
 802912a:	460f      	mov	r7, r1
 802912c:	4614      	mov	r4, r2
 802912e:	18d5      	adds	r5, r2, r3
 8029130:	42ac      	cmp	r4, r5
 8029132:	d101      	bne.n	8029138 <__sfputs_r+0x12>
 8029134:	2000      	movs	r0, #0
 8029136:	e007      	b.n	8029148 <__sfputs_r+0x22>
 8029138:	f814 1b01 	ldrb.w	r1, [r4], #1
 802913c:	463a      	mov	r2, r7
 802913e:	4630      	mov	r0, r6
 8029140:	f7ff ffda 	bl	80290f8 <__sfputc_r>
 8029144:	1c43      	adds	r3, r0, #1
 8029146:	d1f3      	bne.n	8029130 <__sfputs_r+0xa>
 8029148:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0802914c <_vfiprintf_r>:
 802914c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029150:	460d      	mov	r5, r1
 8029152:	b09d      	sub	sp, #116	@ 0x74
 8029154:	4614      	mov	r4, r2
 8029156:	4698      	mov	r8, r3
 8029158:	4606      	mov	r6, r0
 802915a:	b118      	cbz	r0, 8029164 <_vfiprintf_r+0x18>
 802915c:	6a03      	ldr	r3, [r0, #32]
 802915e:	b90b      	cbnz	r3, 8029164 <_vfiprintf_r+0x18>
 8029160:	f7ff fb82 	bl	8028868 <__sinit>
 8029164:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 8029166:	07d9      	lsls	r1, r3, #31
 8029168:	d405      	bmi.n	8029176 <_vfiprintf_r+0x2a>
 802916a:	89ab      	ldrh	r3, [r5, #12]
 802916c:	059a      	lsls	r2, r3, #22
 802916e:	d402      	bmi.n	8029176 <_vfiprintf_r+0x2a>
 8029170:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8029172:	f7ff fe06 	bl	8028d82 <__retarget_lock_acquire_recursive>
 8029176:	89ab      	ldrh	r3, [r5, #12]
 8029178:	071b      	lsls	r3, r3, #28
 802917a:	d501      	bpl.n	8029180 <_vfiprintf_r+0x34>
 802917c:	692b      	ldr	r3, [r5, #16]
 802917e:	b99b      	cbnz	r3, 80291a8 <_vfiprintf_r+0x5c>
 8029180:	4629      	mov	r1, r5
 8029182:	4630      	mov	r0, r6
 8029184:	f7ff fcce 	bl	8028b24 <__swsetup_r>
 8029188:	b170      	cbz	r0, 80291a8 <_vfiprintf_r+0x5c>
 802918a:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 802918c:	07dc      	lsls	r4, r3, #31
 802918e:	d504      	bpl.n	802919a <_vfiprintf_r+0x4e>
 8029190:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8029194:	b01d      	add	sp, #116	@ 0x74
 8029196:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802919a:	89ab      	ldrh	r3, [r5, #12]
 802919c:	0598      	lsls	r0, r3, #22
 802919e:	d4f7      	bmi.n	8029190 <_vfiprintf_r+0x44>
 80291a0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 80291a2:	f7ff fdef 	bl	8028d84 <__retarget_lock_release_recursive>
 80291a6:	e7f3      	b.n	8029190 <_vfiprintf_r+0x44>
 80291a8:	2300      	movs	r3, #0
 80291aa:	9309      	str	r3, [sp, #36]	@ 0x24
 80291ac:	2320      	movs	r3, #32
 80291ae:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 80291b2:	f8cd 800c 	str.w	r8, [sp, #12]
 80291b6:	2330      	movs	r3, #48	@ 0x30
 80291b8:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 8029368 <_vfiprintf_r+0x21c>
 80291bc:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 80291c0:	f04f 0901 	mov.w	r9, #1
 80291c4:	4623      	mov	r3, r4
 80291c6:	469a      	mov	sl, r3
 80291c8:	f813 2b01 	ldrb.w	r2, [r3], #1
 80291cc:	b10a      	cbz	r2, 80291d2 <_vfiprintf_r+0x86>
 80291ce:	2a25      	cmp	r2, #37	@ 0x25
 80291d0:	d1f9      	bne.n	80291c6 <_vfiprintf_r+0x7a>
 80291d2:	ebba 0b04 	subs.w	fp, sl, r4
 80291d6:	d00b      	beq.n	80291f0 <_vfiprintf_r+0xa4>
 80291d8:	465b      	mov	r3, fp
 80291da:	4622      	mov	r2, r4
 80291dc:	4629      	mov	r1, r5
 80291de:	4630      	mov	r0, r6
 80291e0:	f7ff ffa1 	bl	8029126 <__sfputs_r>
 80291e4:	3001      	adds	r0, #1
 80291e6:	f000 80a7 	beq.w	8029338 <_vfiprintf_r+0x1ec>
 80291ea:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80291ec:	445a      	add	r2, fp
 80291ee:	9209      	str	r2, [sp, #36]	@ 0x24
 80291f0:	f89a 3000 	ldrb.w	r3, [sl]
 80291f4:	2b00      	cmp	r3, #0
 80291f6:	f000 809f 	beq.w	8029338 <_vfiprintf_r+0x1ec>
 80291fa:	2300      	movs	r3, #0
 80291fc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8029200:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8029204:	f10a 0a01 	add.w	sl, sl, #1
 8029208:	9304      	str	r3, [sp, #16]
 802920a:	9307      	str	r3, [sp, #28]
 802920c:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8029210:	931a      	str	r3, [sp, #104]	@ 0x68
 8029212:	4654      	mov	r4, sl
 8029214:	2205      	movs	r2, #5
 8029216:	f814 1b01 	ldrb.w	r1, [r4], #1
 802921a:	4853      	ldr	r0, [pc, #332]	@ (8029368 <_vfiprintf_r+0x21c>)
 802921c:	f7d6 fff0 	bl	8000200 <memchr>
 8029220:	9a04      	ldr	r2, [sp, #16]
 8029222:	b9d8      	cbnz	r0, 802925c <_vfiprintf_r+0x110>
 8029224:	06d1      	lsls	r1, r2, #27
 8029226:	bf44      	itt	mi
 8029228:	2320      	movmi	r3, #32
 802922a:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802922e:	0713      	lsls	r3, r2, #28
 8029230:	bf44      	itt	mi
 8029232:	232b      	movmi	r3, #43	@ 0x2b
 8029234:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8029238:	f89a 3000 	ldrb.w	r3, [sl]
 802923c:	2b2a      	cmp	r3, #42	@ 0x2a
 802923e:	d015      	beq.n	802926c <_vfiprintf_r+0x120>
 8029240:	9a07      	ldr	r2, [sp, #28]
 8029242:	4654      	mov	r4, sl
 8029244:	2000      	movs	r0, #0
 8029246:	f04f 0c0a 	mov.w	ip, #10
 802924a:	4621      	mov	r1, r4
 802924c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8029250:	3b30      	subs	r3, #48	@ 0x30
 8029252:	2b09      	cmp	r3, #9
 8029254:	d94b      	bls.n	80292ee <_vfiprintf_r+0x1a2>
 8029256:	b1b0      	cbz	r0, 8029286 <_vfiprintf_r+0x13a>
 8029258:	9207      	str	r2, [sp, #28]
 802925a:	e014      	b.n	8029286 <_vfiprintf_r+0x13a>
 802925c:	eba0 0308 	sub.w	r3, r0, r8
 8029260:	fa09 f303 	lsl.w	r3, r9, r3
 8029264:	4313      	orrs	r3, r2
 8029266:	9304      	str	r3, [sp, #16]
 8029268:	46a2      	mov	sl, r4
 802926a:	e7d2      	b.n	8029212 <_vfiprintf_r+0xc6>
 802926c:	9b03      	ldr	r3, [sp, #12]
 802926e:	1d19      	adds	r1, r3, #4
 8029270:	681b      	ldr	r3, [r3, #0]
 8029272:	9103      	str	r1, [sp, #12]
 8029274:	2b00      	cmp	r3, #0
 8029276:	bfbb      	ittet	lt
 8029278:	425b      	neglt	r3, r3
 802927a:	f042 0202 	orrlt.w	r2, r2, #2
 802927e:	9307      	strge	r3, [sp, #28]
 8029280:	9307      	strlt	r3, [sp, #28]
 8029282:	bfb8      	it	lt
 8029284:	9204      	strlt	r2, [sp, #16]
 8029286:	7823      	ldrb	r3, [r4, #0]
 8029288:	2b2e      	cmp	r3, #46	@ 0x2e
 802928a:	d10a      	bne.n	80292a2 <_vfiprintf_r+0x156>
 802928c:	7863      	ldrb	r3, [r4, #1]
 802928e:	2b2a      	cmp	r3, #42	@ 0x2a
 8029290:	d132      	bne.n	80292f8 <_vfiprintf_r+0x1ac>
 8029292:	9b03      	ldr	r3, [sp, #12]
 8029294:	1d1a      	adds	r2, r3, #4
 8029296:	681b      	ldr	r3, [r3, #0]
 8029298:	9203      	str	r2, [sp, #12]
 802929a:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 802929e:	3402      	adds	r4, #2
 80292a0:	9305      	str	r3, [sp, #20]
 80292a2:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 8029378 <_vfiprintf_r+0x22c>
 80292a6:	7821      	ldrb	r1, [r4, #0]
 80292a8:	2203      	movs	r2, #3
 80292aa:	4650      	mov	r0, sl
 80292ac:	f7d6 ffa8 	bl	8000200 <memchr>
 80292b0:	b138      	cbz	r0, 80292c2 <_vfiprintf_r+0x176>
 80292b2:	9b04      	ldr	r3, [sp, #16]
 80292b4:	eba0 000a 	sub.w	r0, r0, sl
 80292b8:	2240      	movs	r2, #64	@ 0x40
 80292ba:	4082      	lsls	r2, r0
 80292bc:	4313      	orrs	r3, r2
 80292be:	3401      	adds	r4, #1
 80292c0:	9304      	str	r3, [sp, #16]
 80292c2:	f814 1b01 	ldrb.w	r1, [r4], #1
 80292c6:	4829      	ldr	r0, [pc, #164]	@ (802936c <_vfiprintf_r+0x220>)
 80292c8:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 80292cc:	2206      	movs	r2, #6
 80292ce:	f7d6 ff97 	bl	8000200 <memchr>
 80292d2:	2800      	cmp	r0, #0
 80292d4:	d03f      	beq.n	8029356 <_vfiprintf_r+0x20a>
 80292d6:	4b26      	ldr	r3, [pc, #152]	@ (8029370 <_vfiprintf_r+0x224>)
 80292d8:	bb1b      	cbnz	r3, 8029322 <_vfiprintf_r+0x1d6>
 80292da:	9b03      	ldr	r3, [sp, #12]
 80292dc:	3307      	adds	r3, #7
 80292de:	f023 0307 	bic.w	r3, r3, #7
 80292e2:	3308      	adds	r3, #8
 80292e4:	9303      	str	r3, [sp, #12]
 80292e6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80292e8:	443b      	add	r3, r7
 80292ea:	9309      	str	r3, [sp, #36]	@ 0x24
 80292ec:	e76a      	b.n	80291c4 <_vfiprintf_r+0x78>
 80292ee:	fb0c 3202 	mla	r2, ip, r2, r3
 80292f2:	460c      	mov	r4, r1
 80292f4:	2001      	movs	r0, #1
 80292f6:	e7a8      	b.n	802924a <_vfiprintf_r+0xfe>
 80292f8:	2300      	movs	r3, #0
 80292fa:	3401      	adds	r4, #1
 80292fc:	9305      	str	r3, [sp, #20]
 80292fe:	4619      	mov	r1, r3
 8029300:	f04f 0c0a 	mov.w	ip, #10
 8029304:	4620      	mov	r0, r4
 8029306:	f810 2b01 	ldrb.w	r2, [r0], #1
 802930a:	3a30      	subs	r2, #48	@ 0x30
 802930c:	2a09      	cmp	r2, #9
 802930e:	d903      	bls.n	8029318 <_vfiprintf_r+0x1cc>
 8029310:	2b00      	cmp	r3, #0
 8029312:	d0c6      	beq.n	80292a2 <_vfiprintf_r+0x156>
 8029314:	9105      	str	r1, [sp, #20]
 8029316:	e7c4      	b.n	80292a2 <_vfiprintf_r+0x156>
 8029318:	fb0c 2101 	mla	r1, ip, r1, r2
 802931c:	4604      	mov	r4, r0
 802931e:	2301      	movs	r3, #1
 8029320:	e7f0      	b.n	8029304 <_vfiprintf_r+0x1b8>
 8029322:	ab03      	add	r3, sp, #12
 8029324:	9300      	str	r3, [sp, #0]
 8029326:	462a      	mov	r2, r5
 8029328:	4b12      	ldr	r3, [pc, #72]	@ (8029374 <_vfiprintf_r+0x228>)
 802932a:	a904      	add	r1, sp, #16
 802932c:	4630      	mov	r0, r6
 802932e:	f3af 8000 	nop.w
 8029332:	4607      	mov	r7, r0
 8029334:	1c78      	adds	r0, r7, #1
 8029336:	d1d6      	bne.n	80292e6 <_vfiprintf_r+0x19a>
 8029338:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 802933a:	07d9      	lsls	r1, r3, #31
 802933c:	d405      	bmi.n	802934a <_vfiprintf_r+0x1fe>
 802933e:	89ab      	ldrh	r3, [r5, #12]
 8029340:	059a      	lsls	r2, r3, #22
 8029342:	d402      	bmi.n	802934a <_vfiprintf_r+0x1fe>
 8029344:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8029346:	f7ff fd1d 	bl	8028d84 <__retarget_lock_release_recursive>
 802934a:	89ab      	ldrh	r3, [r5, #12]
 802934c:	065b      	lsls	r3, r3, #25
 802934e:	f53f af1f 	bmi.w	8029190 <_vfiprintf_r+0x44>
 8029352:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8029354:	e71e      	b.n	8029194 <_vfiprintf_r+0x48>
 8029356:	ab03      	add	r3, sp, #12
 8029358:	9300      	str	r3, [sp, #0]
 802935a:	462a      	mov	r2, r5
 802935c:	4b05      	ldr	r3, [pc, #20]	@ (8029374 <_vfiprintf_r+0x228>)
 802935e:	a904      	add	r1, sp, #16
 8029360:	4630      	mov	r0, r6
 8029362:	f000 f879 	bl	8029458 <_printf_i>
 8029366:	e7e4      	b.n	8029332 <_vfiprintf_r+0x1e6>
 8029368:	08034cf9 	.word	0x08034cf9
 802936c:	08034d03 	.word	0x08034d03
 8029370:	00000000 	.word	0x00000000
 8029374:	08029127 	.word	0x08029127
 8029378:	08034cff 	.word	0x08034cff

0802937c <_printf_common>:
 802937c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8029380:	4616      	mov	r6, r2
 8029382:	4698      	mov	r8, r3
 8029384:	688a      	ldr	r2, [r1, #8]
 8029386:	690b      	ldr	r3, [r1, #16]
 8029388:	f8dd 9020 	ldr.w	r9, [sp, #32]
 802938c:	4293      	cmp	r3, r2
 802938e:	bfb8      	it	lt
 8029390:	4613      	movlt	r3, r2
 8029392:	6033      	str	r3, [r6, #0]
 8029394:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 8029398:	4607      	mov	r7, r0
 802939a:	460c      	mov	r4, r1
 802939c:	b10a      	cbz	r2, 80293a2 <_printf_common+0x26>
 802939e:	3301      	adds	r3, #1
 80293a0:	6033      	str	r3, [r6, #0]
 80293a2:	6823      	ldr	r3, [r4, #0]
 80293a4:	0699      	lsls	r1, r3, #26
 80293a6:	bf42      	ittt	mi
 80293a8:	6833      	ldrmi	r3, [r6, #0]
 80293aa:	3302      	addmi	r3, #2
 80293ac:	6033      	strmi	r3, [r6, #0]
 80293ae:	6825      	ldr	r5, [r4, #0]
 80293b0:	f015 0506 	ands.w	r5, r5, #6
 80293b4:	d106      	bne.n	80293c4 <_printf_common+0x48>
 80293b6:	f104 0a19 	add.w	sl, r4, #25
 80293ba:	68e3      	ldr	r3, [r4, #12]
 80293bc:	6832      	ldr	r2, [r6, #0]
 80293be:	1a9b      	subs	r3, r3, r2
 80293c0:	42ab      	cmp	r3, r5
 80293c2:	dc26      	bgt.n	8029412 <_printf_common+0x96>
 80293c4:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 80293c8:	6822      	ldr	r2, [r4, #0]
 80293ca:	3b00      	subs	r3, #0
 80293cc:	bf18      	it	ne
 80293ce:	2301      	movne	r3, #1
 80293d0:	0692      	lsls	r2, r2, #26
 80293d2:	d42b      	bmi.n	802942c <_printf_common+0xb0>
 80293d4:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 80293d8:	4641      	mov	r1, r8
 80293da:	4638      	mov	r0, r7
 80293dc:	47c8      	blx	r9
 80293de:	3001      	adds	r0, #1
 80293e0:	d01e      	beq.n	8029420 <_printf_common+0xa4>
 80293e2:	6823      	ldr	r3, [r4, #0]
 80293e4:	6922      	ldr	r2, [r4, #16]
 80293e6:	f003 0306 	and.w	r3, r3, #6
 80293ea:	2b04      	cmp	r3, #4
 80293ec:	bf02      	ittt	eq
 80293ee:	68e5      	ldreq	r5, [r4, #12]
 80293f0:	6833      	ldreq	r3, [r6, #0]
 80293f2:	1aed      	subeq	r5, r5, r3
 80293f4:	68a3      	ldr	r3, [r4, #8]
 80293f6:	bf0c      	ite	eq
 80293f8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 80293fc:	2500      	movne	r5, #0
 80293fe:	4293      	cmp	r3, r2
 8029400:	bfc4      	itt	gt
 8029402:	1a9b      	subgt	r3, r3, r2
 8029404:	18ed      	addgt	r5, r5, r3
 8029406:	2600      	movs	r6, #0
 8029408:	341a      	adds	r4, #26
 802940a:	42b5      	cmp	r5, r6
 802940c:	d11a      	bne.n	8029444 <_printf_common+0xc8>
 802940e:	2000      	movs	r0, #0
 8029410:	e008      	b.n	8029424 <_printf_common+0xa8>
 8029412:	2301      	movs	r3, #1
 8029414:	4652      	mov	r2, sl
 8029416:	4641      	mov	r1, r8
 8029418:	4638      	mov	r0, r7
 802941a:	47c8      	blx	r9
 802941c:	3001      	adds	r0, #1
 802941e:	d103      	bne.n	8029428 <_printf_common+0xac>
 8029420:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8029424:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8029428:	3501      	adds	r5, #1
 802942a:	e7c6      	b.n	80293ba <_printf_common+0x3e>
 802942c:	18e1      	adds	r1, r4, r3
 802942e:	1c5a      	adds	r2, r3, #1
 8029430:	2030      	movs	r0, #48	@ 0x30
 8029432:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 8029436:	4422      	add	r2, r4
 8029438:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 802943c:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 8029440:	3302      	adds	r3, #2
 8029442:	e7c7      	b.n	80293d4 <_printf_common+0x58>
 8029444:	2301      	movs	r3, #1
 8029446:	4622      	mov	r2, r4
 8029448:	4641      	mov	r1, r8
 802944a:	4638      	mov	r0, r7
 802944c:	47c8      	blx	r9
 802944e:	3001      	adds	r0, #1
 8029450:	d0e6      	beq.n	8029420 <_printf_common+0xa4>
 8029452:	3601      	adds	r6, #1
 8029454:	e7d9      	b.n	802940a <_printf_common+0x8e>
	...

08029458 <_printf_i>:
 8029458:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 802945c:	7e0f      	ldrb	r7, [r1, #24]
 802945e:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8029460:	2f78      	cmp	r7, #120	@ 0x78
 8029462:	4691      	mov	r9, r2
 8029464:	4680      	mov	r8, r0
 8029466:	460c      	mov	r4, r1
 8029468:	469a      	mov	sl, r3
 802946a:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 802946e:	d807      	bhi.n	8029480 <_printf_i+0x28>
 8029470:	2f62      	cmp	r7, #98	@ 0x62
 8029472:	d80a      	bhi.n	802948a <_printf_i+0x32>
 8029474:	2f00      	cmp	r7, #0
 8029476:	f000 80d1 	beq.w	802961c <_printf_i+0x1c4>
 802947a:	2f58      	cmp	r7, #88	@ 0x58
 802947c:	f000 80b8 	beq.w	80295f0 <_printf_i+0x198>
 8029480:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8029484:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 8029488:	e03a      	b.n	8029500 <_printf_i+0xa8>
 802948a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 802948e:	2b15      	cmp	r3, #21
 8029490:	d8f6      	bhi.n	8029480 <_printf_i+0x28>
 8029492:	a101      	add	r1, pc, #4	@ (adr r1, 8029498 <_printf_i+0x40>)
 8029494:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8029498:	080294f1 	.word	0x080294f1
 802949c:	08029505 	.word	0x08029505
 80294a0:	08029481 	.word	0x08029481
 80294a4:	08029481 	.word	0x08029481
 80294a8:	08029481 	.word	0x08029481
 80294ac:	08029481 	.word	0x08029481
 80294b0:	08029505 	.word	0x08029505
 80294b4:	08029481 	.word	0x08029481
 80294b8:	08029481 	.word	0x08029481
 80294bc:	08029481 	.word	0x08029481
 80294c0:	08029481 	.word	0x08029481
 80294c4:	08029603 	.word	0x08029603
 80294c8:	0802952f 	.word	0x0802952f
 80294cc:	080295bd 	.word	0x080295bd
 80294d0:	08029481 	.word	0x08029481
 80294d4:	08029481 	.word	0x08029481
 80294d8:	08029625 	.word	0x08029625
 80294dc:	08029481 	.word	0x08029481
 80294e0:	0802952f 	.word	0x0802952f
 80294e4:	08029481 	.word	0x08029481
 80294e8:	08029481 	.word	0x08029481
 80294ec:	080295c5 	.word	0x080295c5
 80294f0:	6833      	ldr	r3, [r6, #0]
 80294f2:	1d1a      	adds	r2, r3, #4
 80294f4:	681b      	ldr	r3, [r3, #0]
 80294f6:	6032      	str	r2, [r6, #0]
 80294f8:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 80294fc:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8029500:	2301      	movs	r3, #1
 8029502:	e09c      	b.n	802963e <_printf_i+0x1e6>
 8029504:	6833      	ldr	r3, [r6, #0]
 8029506:	6820      	ldr	r0, [r4, #0]
 8029508:	1d19      	adds	r1, r3, #4
 802950a:	6031      	str	r1, [r6, #0]
 802950c:	0606      	lsls	r6, r0, #24
 802950e:	d501      	bpl.n	8029514 <_printf_i+0xbc>
 8029510:	681d      	ldr	r5, [r3, #0]
 8029512:	e003      	b.n	802951c <_printf_i+0xc4>
 8029514:	0645      	lsls	r5, r0, #25
 8029516:	d5fb      	bpl.n	8029510 <_printf_i+0xb8>
 8029518:	f9b3 5000 	ldrsh.w	r5, [r3]
 802951c:	2d00      	cmp	r5, #0
 802951e:	da03      	bge.n	8029528 <_printf_i+0xd0>
 8029520:	232d      	movs	r3, #45	@ 0x2d
 8029522:	426d      	negs	r5, r5
 8029524:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8029528:	4858      	ldr	r0, [pc, #352]	@ (802968c <_printf_i+0x234>)
 802952a:	230a      	movs	r3, #10
 802952c:	e011      	b.n	8029552 <_printf_i+0xfa>
 802952e:	6821      	ldr	r1, [r4, #0]
 8029530:	6833      	ldr	r3, [r6, #0]
 8029532:	0608      	lsls	r0, r1, #24
 8029534:	f853 5b04 	ldr.w	r5, [r3], #4
 8029538:	d402      	bmi.n	8029540 <_printf_i+0xe8>
 802953a:	0649      	lsls	r1, r1, #25
 802953c:	bf48      	it	mi
 802953e:	b2ad      	uxthmi	r5, r5
 8029540:	2f6f      	cmp	r7, #111	@ 0x6f
 8029542:	4852      	ldr	r0, [pc, #328]	@ (802968c <_printf_i+0x234>)
 8029544:	6033      	str	r3, [r6, #0]
 8029546:	bf14      	ite	ne
 8029548:	230a      	movne	r3, #10
 802954a:	2308      	moveq	r3, #8
 802954c:	2100      	movs	r1, #0
 802954e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 8029552:	6866      	ldr	r6, [r4, #4]
 8029554:	60a6      	str	r6, [r4, #8]
 8029556:	2e00      	cmp	r6, #0
 8029558:	db05      	blt.n	8029566 <_printf_i+0x10e>
 802955a:	6821      	ldr	r1, [r4, #0]
 802955c:	432e      	orrs	r6, r5
 802955e:	f021 0104 	bic.w	r1, r1, #4
 8029562:	6021      	str	r1, [r4, #0]
 8029564:	d04b      	beq.n	80295fe <_printf_i+0x1a6>
 8029566:	4616      	mov	r6, r2
 8029568:	fbb5 f1f3 	udiv	r1, r5, r3
 802956c:	fb03 5711 	mls	r7, r3, r1, r5
 8029570:	5dc7      	ldrb	r7, [r0, r7]
 8029572:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8029576:	462f      	mov	r7, r5
 8029578:	42bb      	cmp	r3, r7
 802957a:	460d      	mov	r5, r1
 802957c:	d9f4      	bls.n	8029568 <_printf_i+0x110>
 802957e:	2b08      	cmp	r3, #8
 8029580:	d10b      	bne.n	802959a <_printf_i+0x142>
 8029582:	6823      	ldr	r3, [r4, #0]
 8029584:	07df      	lsls	r7, r3, #31
 8029586:	d508      	bpl.n	802959a <_printf_i+0x142>
 8029588:	6923      	ldr	r3, [r4, #16]
 802958a:	6861      	ldr	r1, [r4, #4]
 802958c:	4299      	cmp	r1, r3
 802958e:	bfde      	ittt	le
 8029590:	2330      	movle	r3, #48	@ 0x30
 8029592:	f806 3c01 	strble.w	r3, [r6, #-1]
 8029596:	f106 36ff 	addle.w	r6, r6, #4294967295	@ 0xffffffff
 802959a:	1b92      	subs	r2, r2, r6
 802959c:	6122      	str	r2, [r4, #16]
 802959e:	f8cd a000 	str.w	sl, [sp]
 80295a2:	464b      	mov	r3, r9
 80295a4:	aa03      	add	r2, sp, #12
 80295a6:	4621      	mov	r1, r4
 80295a8:	4640      	mov	r0, r8
 80295aa:	f7ff fee7 	bl	802937c <_printf_common>
 80295ae:	3001      	adds	r0, #1
 80295b0:	d14a      	bne.n	8029648 <_printf_i+0x1f0>
 80295b2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80295b6:	b004      	add	sp, #16
 80295b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80295bc:	6823      	ldr	r3, [r4, #0]
 80295be:	f043 0320 	orr.w	r3, r3, #32
 80295c2:	6023      	str	r3, [r4, #0]
 80295c4:	4832      	ldr	r0, [pc, #200]	@ (8029690 <_printf_i+0x238>)
 80295c6:	2778      	movs	r7, #120	@ 0x78
 80295c8:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 80295cc:	6823      	ldr	r3, [r4, #0]
 80295ce:	6831      	ldr	r1, [r6, #0]
 80295d0:	061f      	lsls	r7, r3, #24
 80295d2:	f851 5b04 	ldr.w	r5, [r1], #4
 80295d6:	d402      	bmi.n	80295de <_printf_i+0x186>
 80295d8:	065f      	lsls	r7, r3, #25
 80295da:	bf48      	it	mi
 80295dc:	b2ad      	uxthmi	r5, r5
 80295de:	6031      	str	r1, [r6, #0]
 80295e0:	07d9      	lsls	r1, r3, #31
 80295e2:	bf44      	itt	mi
 80295e4:	f043 0320 	orrmi.w	r3, r3, #32
 80295e8:	6023      	strmi	r3, [r4, #0]
 80295ea:	b11d      	cbz	r5, 80295f4 <_printf_i+0x19c>
 80295ec:	2310      	movs	r3, #16
 80295ee:	e7ad      	b.n	802954c <_printf_i+0xf4>
 80295f0:	4826      	ldr	r0, [pc, #152]	@ (802968c <_printf_i+0x234>)
 80295f2:	e7e9      	b.n	80295c8 <_printf_i+0x170>
 80295f4:	6823      	ldr	r3, [r4, #0]
 80295f6:	f023 0320 	bic.w	r3, r3, #32
 80295fa:	6023      	str	r3, [r4, #0]
 80295fc:	e7f6      	b.n	80295ec <_printf_i+0x194>
 80295fe:	4616      	mov	r6, r2
 8029600:	e7bd      	b.n	802957e <_printf_i+0x126>
 8029602:	6833      	ldr	r3, [r6, #0]
 8029604:	6825      	ldr	r5, [r4, #0]
 8029606:	6961      	ldr	r1, [r4, #20]
 8029608:	1d18      	adds	r0, r3, #4
 802960a:	6030      	str	r0, [r6, #0]
 802960c:	062e      	lsls	r6, r5, #24
 802960e:	681b      	ldr	r3, [r3, #0]
 8029610:	d501      	bpl.n	8029616 <_printf_i+0x1be>
 8029612:	6019      	str	r1, [r3, #0]
 8029614:	e002      	b.n	802961c <_printf_i+0x1c4>
 8029616:	0668      	lsls	r0, r5, #25
 8029618:	d5fb      	bpl.n	8029612 <_printf_i+0x1ba>
 802961a:	8019      	strh	r1, [r3, #0]
 802961c:	2300      	movs	r3, #0
 802961e:	6123      	str	r3, [r4, #16]
 8029620:	4616      	mov	r6, r2
 8029622:	e7bc      	b.n	802959e <_printf_i+0x146>
 8029624:	6833      	ldr	r3, [r6, #0]
 8029626:	1d1a      	adds	r2, r3, #4
 8029628:	6032      	str	r2, [r6, #0]
 802962a:	681e      	ldr	r6, [r3, #0]
 802962c:	6862      	ldr	r2, [r4, #4]
 802962e:	2100      	movs	r1, #0
 8029630:	4630      	mov	r0, r6
 8029632:	f7d6 fde5 	bl	8000200 <memchr>
 8029636:	b108      	cbz	r0, 802963c <_printf_i+0x1e4>
 8029638:	1b80      	subs	r0, r0, r6
 802963a:	6060      	str	r0, [r4, #4]
 802963c:	6863      	ldr	r3, [r4, #4]
 802963e:	6123      	str	r3, [r4, #16]
 8029640:	2300      	movs	r3, #0
 8029642:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8029646:	e7aa      	b.n	802959e <_printf_i+0x146>
 8029648:	6923      	ldr	r3, [r4, #16]
 802964a:	4632      	mov	r2, r6
 802964c:	4649      	mov	r1, r9
 802964e:	4640      	mov	r0, r8
 8029650:	47d0      	blx	sl
 8029652:	3001      	adds	r0, #1
 8029654:	d0ad      	beq.n	80295b2 <_printf_i+0x15a>
 8029656:	6823      	ldr	r3, [r4, #0]
 8029658:	079b      	lsls	r3, r3, #30
 802965a:	d413      	bmi.n	8029684 <_printf_i+0x22c>
 802965c:	68e0      	ldr	r0, [r4, #12]
 802965e:	9b03      	ldr	r3, [sp, #12]
 8029660:	4298      	cmp	r0, r3
 8029662:	bfb8      	it	lt
 8029664:	4618      	movlt	r0, r3
 8029666:	e7a6      	b.n	80295b6 <_printf_i+0x15e>
 8029668:	2301      	movs	r3, #1
 802966a:	4632      	mov	r2, r6
 802966c:	4649      	mov	r1, r9
 802966e:	4640      	mov	r0, r8
 8029670:	47d0      	blx	sl
 8029672:	3001      	adds	r0, #1
 8029674:	d09d      	beq.n	80295b2 <_printf_i+0x15a>
 8029676:	3501      	adds	r5, #1
 8029678:	68e3      	ldr	r3, [r4, #12]
 802967a:	9903      	ldr	r1, [sp, #12]
 802967c:	1a5b      	subs	r3, r3, r1
 802967e:	42ab      	cmp	r3, r5
 8029680:	dcf2      	bgt.n	8029668 <_printf_i+0x210>
 8029682:	e7eb      	b.n	802965c <_printf_i+0x204>
 8029684:	2500      	movs	r5, #0
 8029686:	f104 0619 	add.w	r6, r4, #25
 802968a:	e7f5      	b.n	8029678 <_printf_i+0x220>
 802968c:	08034d0a 	.word	0x08034d0a
 8029690:	08034d1b 	.word	0x08034d1b

08029694 <__sflush_r>:
 8029694:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8029698:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802969c:	0716      	lsls	r6, r2, #28
 802969e:	4605      	mov	r5, r0
 80296a0:	460c      	mov	r4, r1
 80296a2:	d454      	bmi.n	802974e <__sflush_r+0xba>
 80296a4:	684b      	ldr	r3, [r1, #4]
 80296a6:	2b00      	cmp	r3, #0
 80296a8:	dc02      	bgt.n	80296b0 <__sflush_r+0x1c>
 80296aa:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 80296ac:	2b00      	cmp	r3, #0
 80296ae:	dd48      	ble.n	8029742 <__sflush_r+0xae>
 80296b0:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 80296b2:	2e00      	cmp	r6, #0
 80296b4:	d045      	beq.n	8029742 <__sflush_r+0xae>
 80296b6:	2300      	movs	r3, #0
 80296b8:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 80296bc:	682f      	ldr	r7, [r5, #0]
 80296be:	6a21      	ldr	r1, [r4, #32]
 80296c0:	602b      	str	r3, [r5, #0]
 80296c2:	d030      	beq.n	8029726 <__sflush_r+0x92>
 80296c4:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 80296c6:	89a3      	ldrh	r3, [r4, #12]
 80296c8:	0759      	lsls	r1, r3, #29
 80296ca:	d505      	bpl.n	80296d8 <__sflush_r+0x44>
 80296cc:	6863      	ldr	r3, [r4, #4]
 80296ce:	1ad2      	subs	r2, r2, r3
 80296d0:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 80296d2:	b10b      	cbz	r3, 80296d8 <__sflush_r+0x44>
 80296d4:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 80296d6:	1ad2      	subs	r2, r2, r3
 80296d8:	2300      	movs	r3, #0
 80296da:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 80296dc:	6a21      	ldr	r1, [r4, #32]
 80296de:	4628      	mov	r0, r5
 80296e0:	47b0      	blx	r6
 80296e2:	1c43      	adds	r3, r0, #1
 80296e4:	89a3      	ldrh	r3, [r4, #12]
 80296e6:	d106      	bne.n	80296f6 <__sflush_r+0x62>
 80296e8:	6829      	ldr	r1, [r5, #0]
 80296ea:	291d      	cmp	r1, #29
 80296ec:	d82b      	bhi.n	8029746 <__sflush_r+0xb2>
 80296ee:	4a2a      	ldr	r2, [pc, #168]	@ (8029798 <__sflush_r+0x104>)
 80296f0:	40ca      	lsrs	r2, r1
 80296f2:	07d6      	lsls	r6, r2, #31
 80296f4:	d527      	bpl.n	8029746 <__sflush_r+0xb2>
 80296f6:	2200      	movs	r2, #0
 80296f8:	6062      	str	r2, [r4, #4]
 80296fa:	04d9      	lsls	r1, r3, #19
 80296fc:	6922      	ldr	r2, [r4, #16]
 80296fe:	6022      	str	r2, [r4, #0]
 8029700:	d504      	bpl.n	802970c <__sflush_r+0x78>
 8029702:	1c42      	adds	r2, r0, #1
 8029704:	d101      	bne.n	802970a <__sflush_r+0x76>
 8029706:	682b      	ldr	r3, [r5, #0]
 8029708:	b903      	cbnz	r3, 802970c <__sflush_r+0x78>
 802970a:	6560      	str	r0, [r4, #84]	@ 0x54
 802970c:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 802970e:	602f      	str	r7, [r5, #0]
 8029710:	b1b9      	cbz	r1, 8029742 <__sflush_r+0xae>
 8029712:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8029716:	4299      	cmp	r1, r3
 8029718:	d002      	beq.n	8029720 <__sflush_r+0x8c>
 802971a:	4628      	mov	r0, r5
 802971c:	f7ff fb42 	bl	8028da4 <_free_r>
 8029720:	2300      	movs	r3, #0
 8029722:	6363      	str	r3, [r4, #52]	@ 0x34
 8029724:	e00d      	b.n	8029742 <__sflush_r+0xae>
 8029726:	2301      	movs	r3, #1
 8029728:	4628      	mov	r0, r5
 802972a:	47b0      	blx	r6
 802972c:	4602      	mov	r2, r0
 802972e:	1c50      	adds	r0, r2, #1
 8029730:	d1c9      	bne.n	80296c6 <__sflush_r+0x32>
 8029732:	682b      	ldr	r3, [r5, #0]
 8029734:	2b00      	cmp	r3, #0
 8029736:	d0c6      	beq.n	80296c6 <__sflush_r+0x32>
 8029738:	2b1d      	cmp	r3, #29
 802973a:	d001      	beq.n	8029740 <__sflush_r+0xac>
 802973c:	2b16      	cmp	r3, #22
 802973e:	d11e      	bne.n	802977e <__sflush_r+0xea>
 8029740:	602f      	str	r7, [r5, #0]
 8029742:	2000      	movs	r0, #0
 8029744:	e022      	b.n	802978c <__sflush_r+0xf8>
 8029746:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802974a:	b21b      	sxth	r3, r3
 802974c:	e01b      	b.n	8029786 <__sflush_r+0xf2>
 802974e:	690f      	ldr	r7, [r1, #16]
 8029750:	2f00      	cmp	r7, #0
 8029752:	d0f6      	beq.n	8029742 <__sflush_r+0xae>
 8029754:	0793      	lsls	r3, r2, #30
 8029756:	680e      	ldr	r6, [r1, #0]
 8029758:	bf08      	it	eq
 802975a:	694b      	ldreq	r3, [r1, #20]
 802975c:	600f      	str	r7, [r1, #0]
 802975e:	bf18      	it	ne
 8029760:	2300      	movne	r3, #0
 8029762:	eba6 0807 	sub.w	r8, r6, r7
 8029766:	608b      	str	r3, [r1, #8]
 8029768:	f1b8 0f00 	cmp.w	r8, #0
 802976c:	dde9      	ble.n	8029742 <__sflush_r+0xae>
 802976e:	6a21      	ldr	r1, [r4, #32]
 8029770:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8029772:	4643      	mov	r3, r8
 8029774:	463a      	mov	r2, r7
 8029776:	4628      	mov	r0, r5
 8029778:	47b0      	blx	r6
 802977a:	2800      	cmp	r0, #0
 802977c:	dc08      	bgt.n	8029790 <__sflush_r+0xfc>
 802977e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8029782:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8029786:	81a3      	strh	r3, [r4, #12]
 8029788:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 802978c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8029790:	4407      	add	r7, r0
 8029792:	eba8 0800 	sub.w	r8, r8, r0
 8029796:	e7e7      	b.n	8029768 <__sflush_r+0xd4>
 8029798:	20400001 	.word	0x20400001

0802979c <_fflush_r>:
 802979c:	b538      	push	{r3, r4, r5, lr}
 802979e:	690b      	ldr	r3, [r1, #16]
 80297a0:	4605      	mov	r5, r0
 80297a2:	460c      	mov	r4, r1
 80297a4:	b913      	cbnz	r3, 80297ac <_fflush_r+0x10>
 80297a6:	2500      	movs	r5, #0
 80297a8:	4628      	mov	r0, r5
 80297aa:	bd38      	pop	{r3, r4, r5, pc}
 80297ac:	b118      	cbz	r0, 80297b6 <_fflush_r+0x1a>
 80297ae:	6a03      	ldr	r3, [r0, #32]
 80297b0:	b90b      	cbnz	r3, 80297b6 <_fflush_r+0x1a>
 80297b2:	f7ff f859 	bl	8028868 <__sinit>
 80297b6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80297ba:	2b00      	cmp	r3, #0
 80297bc:	d0f3      	beq.n	80297a6 <_fflush_r+0xa>
 80297be:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 80297c0:	07d0      	lsls	r0, r2, #31
 80297c2:	d404      	bmi.n	80297ce <_fflush_r+0x32>
 80297c4:	0599      	lsls	r1, r3, #22
 80297c6:	d402      	bmi.n	80297ce <_fflush_r+0x32>
 80297c8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 80297ca:	f7ff fada 	bl	8028d82 <__retarget_lock_acquire_recursive>
 80297ce:	4628      	mov	r0, r5
 80297d0:	4621      	mov	r1, r4
 80297d2:	f7ff ff5f 	bl	8029694 <__sflush_r>
 80297d6:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 80297d8:	07da      	lsls	r2, r3, #31
 80297da:	4605      	mov	r5, r0
 80297dc:	d4e4      	bmi.n	80297a8 <_fflush_r+0xc>
 80297de:	89a3      	ldrh	r3, [r4, #12]
 80297e0:	059b      	lsls	r3, r3, #22
 80297e2:	d4e1      	bmi.n	80297a8 <_fflush_r+0xc>
 80297e4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 80297e6:	f7ff facd 	bl	8028d84 <__retarget_lock_release_recursive>
 80297ea:	e7dd      	b.n	80297a8 <_fflush_r+0xc>

080297ec <__swhatbuf_r>:
 80297ec:	b570      	push	{r4, r5, r6, lr}
 80297ee:	460c      	mov	r4, r1
 80297f0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80297f4:	2900      	cmp	r1, #0
 80297f6:	b096      	sub	sp, #88	@ 0x58
 80297f8:	4615      	mov	r5, r2
 80297fa:	461e      	mov	r6, r3
 80297fc:	da0d      	bge.n	802981a <__swhatbuf_r+0x2e>
 80297fe:	89a3      	ldrh	r3, [r4, #12]
 8029800:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8029804:	f04f 0100 	mov.w	r1, #0
 8029808:	bf14      	ite	ne
 802980a:	2340      	movne	r3, #64	@ 0x40
 802980c:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 8029810:	2000      	movs	r0, #0
 8029812:	6031      	str	r1, [r6, #0]
 8029814:	602b      	str	r3, [r5, #0]
 8029816:	b016      	add	sp, #88	@ 0x58
 8029818:	bd70      	pop	{r4, r5, r6, pc}
 802981a:	466a      	mov	r2, sp
 802981c:	f000 f848 	bl	80298b0 <_fstat_r>
 8029820:	2800      	cmp	r0, #0
 8029822:	dbec      	blt.n	80297fe <__swhatbuf_r+0x12>
 8029824:	9901      	ldr	r1, [sp, #4]
 8029826:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 802982a:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 802982e:	4259      	negs	r1, r3
 8029830:	4159      	adcs	r1, r3
 8029832:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8029836:	e7eb      	b.n	8029810 <__swhatbuf_r+0x24>

08029838 <__smakebuf_r>:
 8029838:	898b      	ldrh	r3, [r1, #12]
 802983a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802983c:	079d      	lsls	r5, r3, #30
 802983e:	4606      	mov	r6, r0
 8029840:	460c      	mov	r4, r1
 8029842:	d507      	bpl.n	8029854 <__smakebuf_r+0x1c>
 8029844:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 8029848:	6023      	str	r3, [r4, #0]
 802984a:	6123      	str	r3, [r4, #16]
 802984c:	2301      	movs	r3, #1
 802984e:	6163      	str	r3, [r4, #20]
 8029850:	b003      	add	sp, #12
 8029852:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8029854:	ab01      	add	r3, sp, #4
 8029856:	466a      	mov	r2, sp
 8029858:	f7ff ffc8 	bl	80297ec <__swhatbuf_r>
 802985c:	9f00      	ldr	r7, [sp, #0]
 802985e:	4605      	mov	r5, r0
 8029860:	4639      	mov	r1, r7
 8029862:	4630      	mov	r0, r6
 8029864:	f7fe feba 	bl	80285dc <_malloc_r>
 8029868:	b948      	cbnz	r0, 802987e <__smakebuf_r+0x46>
 802986a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802986e:	059a      	lsls	r2, r3, #22
 8029870:	d4ee      	bmi.n	8029850 <__smakebuf_r+0x18>
 8029872:	f023 0303 	bic.w	r3, r3, #3
 8029876:	f043 0302 	orr.w	r3, r3, #2
 802987a:	81a3      	strh	r3, [r4, #12]
 802987c:	e7e2      	b.n	8029844 <__smakebuf_r+0xc>
 802987e:	89a3      	ldrh	r3, [r4, #12]
 8029880:	6020      	str	r0, [r4, #0]
 8029882:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8029886:	81a3      	strh	r3, [r4, #12]
 8029888:	9b01      	ldr	r3, [sp, #4]
 802988a:	e9c4 0704 	strd	r0, r7, [r4, #16]
 802988e:	b15b      	cbz	r3, 80298a8 <__smakebuf_r+0x70>
 8029890:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8029894:	4630      	mov	r0, r6
 8029896:	f000 f81d 	bl	80298d4 <_isatty_r>
 802989a:	b128      	cbz	r0, 80298a8 <__smakebuf_r+0x70>
 802989c:	89a3      	ldrh	r3, [r4, #12]
 802989e:	f023 0303 	bic.w	r3, r3, #3
 80298a2:	f043 0301 	orr.w	r3, r3, #1
 80298a6:	81a3      	strh	r3, [r4, #12]
 80298a8:	89a3      	ldrh	r3, [r4, #12]
 80298aa:	431d      	orrs	r5, r3
 80298ac:	81a5      	strh	r5, [r4, #12]
 80298ae:	e7cf      	b.n	8029850 <__smakebuf_r+0x18>

080298b0 <_fstat_r>:
 80298b0:	b538      	push	{r3, r4, r5, lr}
 80298b2:	4d07      	ldr	r5, [pc, #28]	@ (80298d0 <_fstat_r+0x20>)
 80298b4:	2300      	movs	r3, #0
 80298b6:	4604      	mov	r4, r0
 80298b8:	4608      	mov	r0, r1
 80298ba:	4611      	mov	r1, r2
 80298bc:	602b      	str	r3, [r5, #0]
 80298be:	f7d8 fa04 	bl	8001cca <_fstat>
 80298c2:	1c43      	adds	r3, r0, #1
 80298c4:	d102      	bne.n	80298cc <_fstat_r+0x1c>
 80298c6:	682b      	ldr	r3, [r5, #0]
 80298c8:	b103      	cbz	r3, 80298cc <_fstat_r+0x1c>
 80298ca:	6023      	str	r3, [r4, #0]
 80298cc:	bd38      	pop	{r3, r4, r5, pc}
 80298ce:	bf00      	nop
 80298d0:	20003984 	.word	0x20003984

080298d4 <_isatty_r>:
 80298d4:	b538      	push	{r3, r4, r5, lr}
 80298d6:	4d06      	ldr	r5, [pc, #24]	@ (80298f0 <_isatty_r+0x1c>)
 80298d8:	2300      	movs	r3, #0
 80298da:	4604      	mov	r4, r0
 80298dc:	4608      	mov	r0, r1
 80298de:	602b      	str	r3, [r5, #0]
 80298e0:	f7d8 fa03 	bl	8001cea <_isatty>
 80298e4:	1c43      	adds	r3, r0, #1
 80298e6:	d102      	bne.n	80298ee <_isatty_r+0x1a>
 80298e8:	682b      	ldr	r3, [r5, #0]
 80298ea:	b103      	cbz	r3, 80298ee <_isatty_r+0x1a>
 80298ec:	6023      	str	r3, [r4, #0]
 80298ee:	bd38      	pop	{r3, r4, r5, pc}
 80298f0:	20003984 	.word	0x20003984

080298f4 <_init>:
 80298f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80298f6:	bf00      	nop
 80298f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80298fa:	bc08      	pop	{r3}
 80298fc:	469e      	mov	lr, r3
 80298fe:	4770      	bx	lr

08029900 <_fini>:
 8029900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8029902:	bf00      	nop
 8029904:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8029906:	bc08      	pop	{r3}
 8029908:	469e      	mov	lr, r3
 802990a:	4770      	bx	lr
