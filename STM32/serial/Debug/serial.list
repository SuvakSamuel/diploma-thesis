
serial.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00028ab4  08000190  08000190  00001190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000b18c  08028c44  08028c44  00029c44  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08033dd0  08033dd0  00035184  2**0
                  CONTENTS, READONLY
  4 .ARM          00000008  08033dd0  08033dd0  00034dd0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08033dd8  08033dd8  00035184  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08033dd8  08033dd8  00034dd8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08033ddc  08033ddc  00034ddc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000184  20000000  08033de0  00035000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .ccmram       00000000  10000000  10000000  00035184  2**0
                  CONTENTS
 10 .bss          000042c8  20000184  20000184  00035184  2**2
                  ALLOC
 11 ._user_heap_stack 00000804  2000444c  2000444c  00035184  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  00035184  2**0
                  CONTENTS, READONLY
 13 .debug_info   0009720b  00000000  00000000  000351b4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00008752  00000000  00000000  000cc3bf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00006bd0  00000000  00000000  000d4b18  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 000058a4  00000000  00000000  000db6e8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0003662c  00000000  00000000  000e0f8c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0006a8fd  00000000  00000000  001175b8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00113f73  00000000  00000000  00181eb5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  00295e28  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0001ee74  00000000  00000000  00295e6c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000059  00000000  00000000  002b4ce0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	@ (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	@ (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	@ (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000184 	.word	0x20000184
 80001ac:	00000000 	.word	0x00000000
 80001b0:	08028c2c 	.word	0x08028c2c

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	@ (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	@ (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	@ (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20000188 	.word	0x20000188
 80001cc:	08028c2c 	.word	0x08028c2c

080001d0 <strcmp>:
 80001d0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001d4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001d8:	2a01      	cmp	r2, #1
 80001da:	bf28      	it	cs
 80001dc:	429a      	cmpcs	r2, r3
 80001de:	d0f7      	beq.n	80001d0 <strcmp>
 80001e0:	1ad0      	subs	r0, r2, r3
 80001e2:	4770      	bx	lr

080001e4 <strlen>:
 80001e4:	4603      	mov	r3, r0
 80001e6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001ea:	2a00      	cmp	r2, #0
 80001ec:	d1fb      	bne.n	80001e6 <strlen+0x2>
 80001ee:	1a18      	subs	r0, r3, r0
 80001f0:	3801      	subs	r0, #1
 80001f2:	4770      	bx	lr
	...

08000200 <memchr>:
 8000200:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 8000204:	2a10      	cmp	r2, #16
 8000206:	db2b      	blt.n	8000260 <memchr+0x60>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	d008      	beq.n	8000220 <memchr+0x20>
 800020e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000212:	3a01      	subs	r2, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d02d      	beq.n	8000274 <memchr+0x74>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	b342      	cbz	r2, 8000270 <memchr+0x70>
 800021e:	d1f6      	bne.n	800020e <memchr+0xe>
 8000220:	b4f0      	push	{r4, r5, r6, r7}
 8000222:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000226:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800022a:	f022 0407 	bic.w	r4, r2, #7
 800022e:	f07f 0700 	mvns.w	r7, #0
 8000232:	2300      	movs	r3, #0
 8000234:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000238:	3c08      	subs	r4, #8
 800023a:	ea85 0501 	eor.w	r5, r5, r1
 800023e:	ea86 0601 	eor.w	r6, r6, r1
 8000242:	fa85 f547 	uadd8	r5, r5, r7
 8000246:	faa3 f587 	sel	r5, r3, r7
 800024a:	fa86 f647 	uadd8	r6, r6, r7
 800024e:	faa5 f687 	sel	r6, r5, r7
 8000252:	b98e      	cbnz	r6, 8000278 <memchr+0x78>
 8000254:	d1ee      	bne.n	8000234 <memchr+0x34>
 8000256:	bcf0      	pop	{r4, r5, r6, r7}
 8000258:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800025c:	f002 0207 	and.w	r2, r2, #7
 8000260:	b132      	cbz	r2, 8000270 <memchr+0x70>
 8000262:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000266:	3a01      	subs	r2, #1
 8000268:	ea83 0301 	eor.w	r3, r3, r1
 800026c:	b113      	cbz	r3, 8000274 <memchr+0x74>
 800026e:	d1f8      	bne.n	8000262 <memchr+0x62>
 8000270:	2000      	movs	r0, #0
 8000272:	4770      	bx	lr
 8000274:	3801      	subs	r0, #1
 8000276:	4770      	bx	lr
 8000278:	2d00      	cmp	r5, #0
 800027a:	bf06      	itte	eq
 800027c:	4635      	moveq	r5, r6
 800027e:	3803      	subeq	r0, #3
 8000280:	3807      	subne	r0, #7
 8000282:	f015 0f01 	tst.w	r5, #1
 8000286:	d107      	bne.n	8000298 <memchr+0x98>
 8000288:	3001      	adds	r0, #1
 800028a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800028e:	bf02      	ittt	eq
 8000290:	3001      	addeq	r0, #1
 8000292:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000296:	3001      	addeq	r0, #1
 8000298:	bcf0      	pop	{r4, r5, r6, r7}
 800029a:	3801      	subs	r0, #1
 800029c:	4770      	bx	lr
 800029e:	bf00      	nop

080002a0 <__aeabi_uldivmod>:
 80002a0:	b953      	cbnz	r3, 80002b8 <__aeabi_uldivmod+0x18>
 80002a2:	b94a      	cbnz	r2, 80002b8 <__aeabi_uldivmod+0x18>
 80002a4:	2900      	cmp	r1, #0
 80002a6:	bf08      	it	eq
 80002a8:	2800      	cmpeq	r0, #0
 80002aa:	bf1c      	itt	ne
 80002ac:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
 80002b0:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
 80002b4:	f000 b988 	b.w	80005c8 <__aeabi_idiv0>
 80002b8:	f1ad 0c08 	sub.w	ip, sp, #8
 80002bc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002c0:	f000 f806 	bl	80002d0 <__udivmoddi4>
 80002c4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002c8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002cc:	b004      	add	sp, #16
 80002ce:	4770      	bx	lr

080002d0 <__udivmoddi4>:
 80002d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002d4:	9d08      	ldr	r5, [sp, #32]
 80002d6:	468e      	mov	lr, r1
 80002d8:	4604      	mov	r4, r0
 80002da:	4688      	mov	r8, r1
 80002dc:	2b00      	cmp	r3, #0
 80002de:	d14a      	bne.n	8000376 <__udivmoddi4+0xa6>
 80002e0:	428a      	cmp	r2, r1
 80002e2:	4617      	mov	r7, r2
 80002e4:	d962      	bls.n	80003ac <__udivmoddi4+0xdc>
 80002e6:	fab2 f682 	clz	r6, r2
 80002ea:	b14e      	cbz	r6, 8000300 <__udivmoddi4+0x30>
 80002ec:	f1c6 0320 	rsb	r3, r6, #32
 80002f0:	fa01 f806 	lsl.w	r8, r1, r6
 80002f4:	fa20 f303 	lsr.w	r3, r0, r3
 80002f8:	40b7      	lsls	r7, r6
 80002fa:	ea43 0808 	orr.w	r8, r3, r8
 80002fe:	40b4      	lsls	r4, r6
 8000300:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000304:	fa1f fc87 	uxth.w	ip, r7
 8000308:	fbb8 f1fe 	udiv	r1, r8, lr
 800030c:	0c23      	lsrs	r3, r4, #16
 800030e:	fb0e 8811 	mls	r8, lr, r1, r8
 8000312:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000316:	fb01 f20c 	mul.w	r2, r1, ip
 800031a:	429a      	cmp	r2, r3
 800031c:	d909      	bls.n	8000332 <__udivmoddi4+0x62>
 800031e:	18fb      	adds	r3, r7, r3
 8000320:	f101 30ff 	add.w	r0, r1, #4294967295	@ 0xffffffff
 8000324:	f080 80ea 	bcs.w	80004fc <__udivmoddi4+0x22c>
 8000328:	429a      	cmp	r2, r3
 800032a:	f240 80e7 	bls.w	80004fc <__udivmoddi4+0x22c>
 800032e:	3902      	subs	r1, #2
 8000330:	443b      	add	r3, r7
 8000332:	1a9a      	subs	r2, r3, r2
 8000334:	b2a3      	uxth	r3, r4
 8000336:	fbb2 f0fe 	udiv	r0, r2, lr
 800033a:	fb0e 2210 	mls	r2, lr, r0, r2
 800033e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8000342:	fb00 fc0c 	mul.w	ip, r0, ip
 8000346:	459c      	cmp	ip, r3
 8000348:	d909      	bls.n	800035e <__udivmoddi4+0x8e>
 800034a:	18fb      	adds	r3, r7, r3
 800034c:	f100 32ff 	add.w	r2, r0, #4294967295	@ 0xffffffff
 8000350:	f080 80d6 	bcs.w	8000500 <__udivmoddi4+0x230>
 8000354:	459c      	cmp	ip, r3
 8000356:	f240 80d3 	bls.w	8000500 <__udivmoddi4+0x230>
 800035a:	443b      	add	r3, r7
 800035c:	3802      	subs	r0, #2
 800035e:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000362:	eba3 030c 	sub.w	r3, r3, ip
 8000366:	2100      	movs	r1, #0
 8000368:	b11d      	cbz	r5, 8000372 <__udivmoddi4+0xa2>
 800036a:	40f3      	lsrs	r3, r6
 800036c:	2200      	movs	r2, #0
 800036e:	e9c5 3200 	strd	r3, r2, [r5]
 8000372:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000376:	428b      	cmp	r3, r1
 8000378:	d905      	bls.n	8000386 <__udivmoddi4+0xb6>
 800037a:	b10d      	cbz	r5, 8000380 <__udivmoddi4+0xb0>
 800037c:	e9c5 0100 	strd	r0, r1, [r5]
 8000380:	2100      	movs	r1, #0
 8000382:	4608      	mov	r0, r1
 8000384:	e7f5      	b.n	8000372 <__udivmoddi4+0xa2>
 8000386:	fab3 f183 	clz	r1, r3
 800038a:	2900      	cmp	r1, #0
 800038c:	d146      	bne.n	800041c <__udivmoddi4+0x14c>
 800038e:	4573      	cmp	r3, lr
 8000390:	d302      	bcc.n	8000398 <__udivmoddi4+0xc8>
 8000392:	4282      	cmp	r2, r0
 8000394:	f200 8105 	bhi.w	80005a2 <__udivmoddi4+0x2d2>
 8000398:	1a84      	subs	r4, r0, r2
 800039a:	eb6e 0203 	sbc.w	r2, lr, r3
 800039e:	2001      	movs	r0, #1
 80003a0:	4690      	mov	r8, r2
 80003a2:	2d00      	cmp	r5, #0
 80003a4:	d0e5      	beq.n	8000372 <__udivmoddi4+0xa2>
 80003a6:	e9c5 4800 	strd	r4, r8, [r5]
 80003aa:	e7e2      	b.n	8000372 <__udivmoddi4+0xa2>
 80003ac:	2a00      	cmp	r2, #0
 80003ae:	f000 8090 	beq.w	80004d2 <__udivmoddi4+0x202>
 80003b2:	fab2 f682 	clz	r6, r2
 80003b6:	2e00      	cmp	r6, #0
 80003b8:	f040 80a4 	bne.w	8000504 <__udivmoddi4+0x234>
 80003bc:	1a8a      	subs	r2, r1, r2
 80003be:	0c03      	lsrs	r3, r0, #16
 80003c0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 80003c4:	b280      	uxth	r0, r0
 80003c6:	b2bc      	uxth	r4, r7
 80003c8:	2101      	movs	r1, #1
 80003ca:	fbb2 fcfe 	udiv	ip, r2, lr
 80003ce:	fb0e 221c 	mls	r2, lr, ip, r2
 80003d2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80003d6:	fb04 f20c 	mul.w	r2, r4, ip
 80003da:	429a      	cmp	r2, r3
 80003dc:	d907      	bls.n	80003ee <__udivmoddi4+0x11e>
 80003de:	18fb      	adds	r3, r7, r3
 80003e0:	f10c 38ff 	add.w	r8, ip, #4294967295	@ 0xffffffff
 80003e4:	d202      	bcs.n	80003ec <__udivmoddi4+0x11c>
 80003e6:	429a      	cmp	r2, r3
 80003e8:	f200 80e0 	bhi.w	80005ac <__udivmoddi4+0x2dc>
 80003ec:	46c4      	mov	ip, r8
 80003ee:	1a9b      	subs	r3, r3, r2
 80003f0:	fbb3 f2fe 	udiv	r2, r3, lr
 80003f4:	fb0e 3312 	mls	r3, lr, r2, r3
 80003f8:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 80003fc:	fb02 f404 	mul.w	r4, r2, r4
 8000400:	429c      	cmp	r4, r3
 8000402:	d907      	bls.n	8000414 <__udivmoddi4+0x144>
 8000404:	18fb      	adds	r3, r7, r3
 8000406:	f102 30ff 	add.w	r0, r2, #4294967295	@ 0xffffffff
 800040a:	d202      	bcs.n	8000412 <__udivmoddi4+0x142>
 800040c:	429c      	cmp	r4, r3
 800040e:	f200 80ca 	bhi.w	80005a6 <__udivmoddi4+0x2d6>
 8000412:	4602      	mov	r2, r0
 8000414:	1b1b      	subs	r3, r3, r4
 8000416:	ea42 400c 	orr.w	r0, r2, ip, lsl #16
 800041a:	e7a5      	b.n	8000368 <__udivmoddi4+0x98>
 800041c:	f1c1 0620 	rsb	r6, r1, #32
 8000420:	408b      	lsls	r3, r1
 8000422:	fa22 f706 	lsr.w	r7, r2, r6
 8000426:	431f      	orrs	r7, r3
 8000428:	fa0e f401 	lsl.w	r4, lr, r1
 800042c:	fa20 f306 	lsr.w	r3, r0, r6
 8000430:	fa2e fe06 	lsr.w	lr, lr, r6
 8000434:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8000438:	4323      	orrs	r3, r4
 800043a:	fa00 f801 	lsl.w	r8, r0, r1
 800043e:	fa1f fc87 	uxth.w	ip, r7
 8000442:	fbbe f0f9 	udiv	r0, lr, r9
 8000446:	0c1c      	lsrs	r4, r3, #16
 8000448:	fb09 ee10 	mls	lr, r9, r0, lr
 800044c:	ea44 440e 	orr.w	r4, r4, lr, lsl #16
 8000450:	fb00 fe0c 	mul.w	lr, r0, ip
 8000454:	45a6      	cmp	lr, r4
 8000456:	fa02 f201 	lsl.w	r2, r2, r1
 800045a:	d909      	bls.n	8000470 <__udivmoddi4+0x1a0>
 800045c:	193c      	adds	r4, r7, r4
 800045e:	f100 3aff 	add.w	sl, r0, #4294967295	@ 0xffffffff
 8000462:	f080 809c 	bcs.w	800059e <__udivmoddi4+0x2ce>
 8000466:	45a6      	cmp	lr, r4
 8000468:	f240 8099 	bls.w	800059e <__udivmoddi4+0x2ce>
 800046c:	3802      	subs	r0, #2
 800046e:	443c      	add	r4, r7
 8000470:	eba4 040e 	sub.w	r4, r4, lr
 8000474:	fa1f fe83 	uxth.w	lr, r3
 8000478:	fbb4 f3f9 	udiv	r3, r4, r9
 800047c:	fb09 4413 	mls	r4, r9, r3, r4
 8000480:	ea4e 4404 	orr.w	r4, lr, r4, lsl #16
 8000484:	fb03 fc0c 	mul.w	ip, r3, ip
 8000488:	45a4      	cmp	ip, r4
 800048a:	d908      	bls.n	800049e <__udivmoddi4+0x1ce>
 800048c:	193c      	adds	r4, r7, r4
 800048e:	f103 3eff 	add.w	lr, r3, #4294967295	@ 0xffffffff
 8000492:	f080 8082 	bcs.w	800059a <__udivmoddi4+0x2ca>
 8000496:	45a4      	cmp	ip, r4
 8000498:	d97f      	bls.n	800059a <__udivmoddi4+0x2ca>
 800049a:	3b02      	subs	r3, #2
 800049c:	443c      	add	r4, r7
 800049e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80004a2:	eba4 040c 	sub.w	r4, r4, ip
 80004a6:	fba0 ec02 	umull	lr, ip, r0, r2
 80004aa:	4564      	cmp	r4, ip
 80004ac:	4673      	mov	r3, lr
 80004ae:	46e1      	mov	r9, ip
 80004b0:	d362      	bcc.n	8000578 <__udivmoddi4+0x2a8>
 80004b2:	d05f      	beq.n	8000574 <__udivmoddi4+0x2a4>
 80004b4:	b15d      	cbz	r5, 80004ce <__udivmoddi4+0x1fe>
 80004b6:	ebb8 0203 	subs.w	r2, r8, r3
 80004ba:	eb64 0409 	sbc.w	r4, r4, r9
 80004be:	fa04 f606 	lsl.w	r6, r4, r6
 80004c2:	fa22 f301 	lsr.w	r3, r2, r1
 80004c6:	431e      	orrs	r6, r3
 80004c8:	40cc      	lsrs	r4, r1
 80004ca:	e9c5 6400 	strd	r6, r4, [r5]
 80004ce:	2100      	movs	r1, #0
 80004d0:	e74f      	b.n	8000372 <__udivmoddi4+0xa2>
 80004d2:	fbb1 fcf2 	udiv	ip, r1, r2
 80004d6:	0c01      	lsrs	r1, r0, #16
 80004d8:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
 80004dc:	b280      	uxth	r0, r0
 80004de:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 80004e2:	463b      	mov	r3, r7
 80004e4:	4638      	mov	r0, r7
 80004e6:	463c      	mov	r4, r7
 80004e8:	46b8      	mov	r8, r7
 80004ea:	46be      	mov	lr, r7
 80004ec:	2620      	movs	r6, #32
 80004ee:	fbb1 f1f7 	udiv	r1, r1, r7
 80004f2:	eba2 0208 	sub.w	r2, r2, r8
 80004f6:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 80004fa:	e766      	b.n	80003ca <__udivmoddi4+0xfa>
 80004fc:	4601      	mov	r1, r0
 80004fe:	e718      	b.n	8000332 <__udivmoddi4+0x62>
 8000500:	4610      	mov	r0, r2
 8000502:	e72c      	b.n	800035e <__udivmoddi4+0x8e>
 8000504:	f1c6 0220 	rsb	r2, r6, #32
 8000508:	fa2e f302 	lsr.w	r3, lr, r2
 800050c:	40b7      	lsls	r7, r6
 800050e:	40b1      	lsls	r1, r6
 8000510:	fa20 f202 	lsr.w	r2, r0, r2
 8000514:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000518:	430a      	orrs	r2, r1
 800051a:	fbb3 f8fe 	udiv	r8, r3, lr
 800051e:	b2bc      	uxth	r4, r7
 8000520:	fb0e 3318 	mls	r3, lr, r8, r3
 8000524:	0c11      	lsrs	r1, r2, #16
 8000526:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800052a:	fb08 f904 	mul.w	r9, r8, r4
 800052e:	40b0      	lsls	r0, r6
 8000530:	4589      	cmp	r9, r1
 8000532:	ea4f 4310 	mov.w	r3, r0, lsr #16
 8000536:	b280      	uxth	r0, r0
 8000538:	d93e      	bls.n	80005b8 <__udivmoddi4+0x2e8>
 800053a:	1879      	adds	r1, r7, r1
 800053c:	f108 3cff 	add.w	ip, r8, #4294967295	@ 0xffffffff
 8000540:	d201      	bcs.n	8000546 <__udivmoddi4+0x276>
 8000542:	4589      	cmp	r9, r1
 8000544:	d81f      	bhi.n	8000586 <__udivmoddi4+0x2b6>
 8000546:	eba1 0109 	sub.w	r1, r1, r9
 800054a:	fbb1 f9fe 	udiv	r9, r1, lr
 800054e:	fb09 f804 	mul.w	r8, r9, r4
 8000552:	fb0e 1119 	mls	r1, lr, r9, r1
 8000556:	b292      	uxth	r2, r2
 8000558:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800055c:	4542      	cmp	r2, r8
 800055e:	d229      	bcs.n	80005b4 <__udivmoddi4+0x2e4>
 8000560:	18ba      	adds	r2, r7, r2
 8000562:	f109 31ff 	add.w	r1, r9, #4294967295	@ 0xffffffff
 8000566:	d2c4      	bcs.n	80004f2 <__udivmoddi4+0x222>
 8000568:	4542      	cmp	r2, r8
 800056a:	d2c2      	bcs.n	80004f2 <__udivmoddi4+0x222>
 800056c:	f1a9 0102 	sub.w	r1, r9, #2
 8000570:	443a      	add	r2, r7
 8000572:	e7be      	b.n	80004f2 <__udivmoddi4+0x222>
 8000574:	45f0      	cmp	r8, lr
 8000576:	d29d      	bcs.n	80004b4 <__udivmoddi4+0x1e4>
 8000578:	ebbe 0302 	subs.w	r3, lr, r2
 800057c:	eb6c 0c07 	sbc.w	ip, ip, r7
 8000580:	3801      	subs	r0, #1
 8000582:	46e1      	mov	r9, ip
 8000584:	e796      	b.n	80004b4 <__udivmoddi4+0x1e4>
 8000586:	eba7 0909 	sub.w	r9, r7, r9
 800058a:	4449      	add	r1, r9
 800058c:	f1a8 0c02 	sub.w	ip, r8, #2
 8000590:	fbb1 f9fe 	udiv	r9, r1, lr
 8000594:	fb09 f804 	mul.w	r8, r9, r4
 8000598:	e7db      	b.n	8000552 <__udivmoddi4+0x282>
 800059a:	4673      	mov	r3, lr
 800059c:	e77f      	b.n	800049e <__udivmoddi4+0x1ce>
 800059e:	4650      	mov	r0, sl
 80005a0:	e766      	b.n	8000470 <__udivmoddi4+0x1a0>
 80005a2:	4608      	mov	r0, r1
 80005a4:	e6fd      	b.n	80003a2 <__udivmoddi4+0xd2>
 80005a6:	443b      	add	r3, r7
 80005a8:	3a02      	subs	r2, #2
 80005aa:	e733      	b.n	8000414 <__udivmoddi4+0x144>
 80005ac:	f1ac 0c02 	sub.w	ip, ip, #2
 80005b0:	443b      	add	r3, r7
 80005b2:	e71c      	b.n	80003ee <__udivmoddi4+0x11e>
 80005b4:	4649      	mov	r1, r9
 80005b6:	e79c      	b.n	80004f2 <__udivmoddi4+0x222>
 80005b8:	eba1 0109 	sub.w	r1, r1, r9
 80005bc:	46c4      	mov	ip, r8
 80005be:	fbb1 f9fe 	udiv	r9, r1, lr
 80005c2:	fb09 f804 	mul.w	r8, r9, r4
 80005c6:	e7c4      	b.n	8000552 <__udivmoddi4+0x282>

080005c8 <__aeabi_idiv0>:
 80005c8:	4770      	bx	lr
 80005ca:	bf00      	nop

080005cc <firstMessageHandler>:
	thirdMessage = (MessageThree){{0},{0},{0},{0},{0},{0},{0}};
	fourthMessage = (MessageFour){{0},{0},{0},{0},{0}};
	fifthMessage = (MessageFive){{0},{0},{0},{0},{0}};
	sixthMessage = (MessageSix){{0},{0},{0},{0},{0},{0}};
}*/
void firstMessageHandler(uint8_t* receivedChars) {
 80005cc:	b580      	push	{r7, lr}
 80005ce:	b084      	sub	sp, #16
 80005d0:	af00      	add	r7, sp, #0
 80005d2:	6078      	str	r0, [r7, #4]
	for (int i = 0; i < 4; i++) {
 80005d4:	2300      	movs	r3, #0
 80005d6:	60fb      	str	r3, [r7, #12]
 80005d8:	e00b      	b.n	80005f2 <firstMessageHandler+0x26>
		firstMessage.initChars[i] = receivedChars[i];
 80005da:	68fb      	ldr	r3, [r7, #12]
 80005dc:	687a      	ldr	r2, [r7, #4]
 80005de:	4413      	add	r3, r2
 80005e0:	7819      	ldrb	r1, [r3, #0]
 80005e2:	4a0c      	ldr	r2, [pc, #48]	@ (8000614 <firstMessageHandler+0x48>)
 80005e4:	68fb      	ldr	r3, [r7, #12]
 80005e6:	4413      	add	r3, r2
 80005e8:	460a      	mov	r2, r1
 80005ea:	701a      	strb	r2, [r3, #0]
	for (int i = 0; i < 4; i++) {
 80005ec:	68fb      	ldr	r3, [r7, #12]
 80005ee:	3301      	adds	r3, #1
 80005f0:	60fb      	str	r3, [r7, #12]
 80005f2:	68fb      	ldr	r3, [r7, #12]
 80005f4:	2b03      	cmp	r3, #3
 80005f6:	ddf0      	ble.n	80005da <firstMessageHandler+0xe>
	}
	// skontroluj ci sme v prvej sprave dostali uvodne znaky 'H' 'e' 'l' 'o'.
	// treba dorobit odpoved v pripade ze sme nedostali taketo znaky.
	// v podstate celemu projektu treba dorobit vratenie chyboveho kodu v pripade ze nieco zlyha.
	if(memcmp(firstMessage.initChars, secondMessage.replyChars, sizeof(secondMessage.replyChars)) == 0) {
 80005f8:	2204      	movs	r2, #4
 80005fa:	4907      	ldr	r1, [pc, #28]	@ (8000618 <firstMessageHandler+0x4c>)
 80005fc:	4805      	ldr	r0, [pc, #20]	@ (8000614 <firstMessageHandler+0x48>)
 80005fe:	f027 ff3d 	bl	802847c <memcmp>
 8000602:	4603      	mov	r3, r0
 8000604:	2b00      	cmp	r3, #0
 8000606:	d101      	bne.n	800060c <firstMessageHandler+0x40>
		secondMessageSender();
 8000608:	f000 f808 	bl	800061c <secondMessageSender>
	}
}
 800060c:	bf00      	nop
 800060e:	3710      	adds	r7, #16
 8000610:	46bd      	mov	sp, r7
 8000612:	bd80      	pop	{r7, pc}
 8000614:	20000000 	.word	0x20000000
 8000618:	20000004 	.word	0x20000004

0800061c <secondMessageSender>:

void secondMessageSender() {
 800061c:	b580      	push	{r7, lr}
 800061e:	b086      	sub	sp, #24
 8000620:	af00      	add	r7, sp, #0
	// vrat device ID co je rozdelene do troch 32bit hodnot
	uint32_t uid_one = HAL_GetUIDw0();
 8000622:	f001 fbd1 	bl	8001dc8 <HAL_GetUIDw0>
 8000626:	6138      	str	r0, [r7, #16]
	uint32_t uid_two = HAL_GetUIDw1();
 8000628:	f001 fbda 	bl	8001de0 <HAL_GetUIDw1>
 800062c:	60f8      	str	r0, [r7, #12]
	uint32_t uid_three = HAL_GetUIDw2();
 800062e:	f001 fbe3 	bl	8001df8 <HAL_GetUIDw2>
 8000632:	60b8      	str	r0, [r7, #8]

	// vsetko nasekaj do sendBuffera
	memcpy(sendBuffer, secondMessage.replyChars, 4);
 8000634:	4b49      	ldr	r3, [pc, #292]	@ (800075c <secondMessageSender+0x140>)
 8000636:	681b      	ldr	r3, [r3, #0]
 8000638:	4a49      	ldr	r2, [pc, #292]	@ (8000760 <secondMessageSender+0x144>)
 800063a:	6013      	str	r3, [r2, #0]
	sendCounter += 4;
 800063c:	4b49      	ldr	r3, [pc, #292]	@ (8000764 <secondMessageSender+0x148>)
 800063e:	881b      	ldrh	r3, [r3, #0]
 8000640:	3304      	adds	r3, #4
 8000642:	b29a      	uxth	r2, r3
 8000644:	4b47      	ldr	r3, [pc, #284]	@ (8000764 <secondMessageSender+0x148>)
 8000646:	801a      	strh	r2, [r3, #0]
	for (size_t i = 0; i < 3; i++)
 8000648:	2300      	movs	r3, #0
 800064a:	617b      	str	r3, [r7, #20]
 800064c:	e04d      	b.n	80006ea <secondMessageSender+0xce>
	{
		uint8_t UIDsplit[4];
		if (i == 0) {
 800064e:	697b      	ldr	r3, [r7, #20]
 8000650:	2b00      	cmp	r3, #0
 8000652:	d112      	bne.n	800067a <secondMessageSender+0x5e>
			UIDsplit[0] = (uid_one & 0x000000ff);
 8000654:	693b      	ldr	r3, [r7, #16]
 8000656:	b2db      	uxtb	r3, r3
 8000658:	713b      	strb	r3, [r7, #4]
			UIDsplit[1] = (uid_one & 0x0000ff00) >> 8;
 800065a:	693b      	ldr	r3, [r7, #16]
 800065c:	0a1b      	lsrs	r3, r3, #8
 800065e:	b2db      	uxtb	r3, r3
 8000660:	717b      	strb	r3, [r7, #5]
			UIDsplit[2] = (uid_one & 0x00ff0000) >> 16;
 8000662:	693b      	ldr	r3, [r7, #16]
 8000664:	0c1b      	lsrs	r3, r3, #16
 8000666:	b2db      	uxtb	r3, r3
 8000668:	71bb      	strb	r3, [r7, #6]
			UIDsplit[3] = (uid_one & 0xff000000) >> 24;
 800066a:	693b      	ldr	r3, [r7, #16]
 800066c:	0e1b      	lsrs	r3, r3, #24
 800066e:	b2db      	uxtb	r3, r3
 8000670:	71fb      	strb	r3, [r7, #7]
			memcpy(secondMessage.Tid_one, UIDsplit, 4);
 8000672:	687b      	ldr	r3, [r7, #4]
 8000674:	4a39      	ldr	r2, [pc, #228]	@ (800075c <secondMessageSender+0x140>)
 8000676:	6053      	str	r3, [r2, #4]
 8000678:	e027      	b.n	80006ca <secondMessageSender+0xae>
		} else if (i == 1) {
 800067a:	697b      	ldr	r3, [r7, #20]
 800067c:	2b01      	cmp	r3, #1
 800067e:	d112      	bne.n	80006a6 <secondMessageSender+0x8a>
			UIDsplit[0] = (uid_two & 0x000000ff);
 8000680:	68fb      	ldr	r3, [r7, #12]
 8000682:	b2db      	uxtb	r3, r3
 8000684:	713b      	strb	r3, [r7, #4]
			UIDsplit[1] = (uid_two & 0x0000ff00) >> 8;
 8000686:	68fb      	ldr	r3, [r7, #12]
 8000688:	0a1b      	lsrs	r3, r3, #8
 800068a:	b2db      	uxtb	r3, r3
 800068c:	717b      	strb	r3, [r7, #5]
			UIDsplit[2] = (uid_two & 0x00ff0000) >> 16;
 800068e:	68fb      	ldr	r3, [r7, #12]
 8000690:	0c1b      	lsrs	r3, r3, #16
 8000692:	b2db      	uxtb	r3, r3
 8000694:	71bb      	strb	r3, [r7, #6]
			UIDsplit[3] = (uid_two & 0xff000000) >> 24;
 8000696:	68fb      	ldr	r3, [r7, #12]
 8000698:	0e1b      	lsrs	r3, r3, #24
 800069a:	b2db      	uxtb	r3, r3
 800069c:	71fb      	strb	r3, [r7, #7]
			memcpy(secondMessage.Tid_two, UIDsplit, 4);
 800069e:	687b      	ldr	r3, [r7, #4]
 80006a0:	4a2e      	ldr	r2, [pc, #184]	@ (800075c <secondMessageSender+0x140>)
 80006a2:	6093      	str	r3, [r2, #8]
 80006a4:	e011      	b.n	80006ca <secondMessageSender+0xae>
		} else {
			UIDsplit[0] = (uid_three & 0x000000ff);
 80006a6:	68bb      	ldr	r3, [r7, #8]
 80006a8:	b2db      	uxtb	r3, r3
 80006aa:	713b      	strb	r3, [r7, #4]
			UIDsplit[1] = (uid_three & 0x0000ff00) >> 8;
 80006ac:	68bb      	ldr	r3, [r7, #8]
 80006ae:	0a1b      	lsrs	r3, r3, #8
 80006b0:	b2db      	uxtb	r3, r3
 80006b2:	717b      	strb	r3, [r7, #5]
			UIDsplit[2] = (uid_three & 0x00ff0000) >> 16;
 80006b4:	68bb      	ldr	r3, [r7, #8]
 80006b6:	0c1b      	lsrs	r3, r3, #16
 80006b8:	b2db      	uxtb	r3, r3
 80006ba:	71bb      	strb	r3, [r7, #6]
			UIDsplit[3] = (uid_three & 0xff000000) >> 24;
 80006bc:	68bb      	ldr	r3, [r7, #8]
 80006be:	0e1b      	lsrs	r3, r3, #24
 80006c0:	b2db      	uxtb	r3, r3
 80006c2:	71fb      	strb	r3, [r7, #7]
			memcpy(secondMessage.Tid_three, UIDsplit, 4);
 80006c4:	687b      	ldr	r3, [r7, #4]
 80006c6:	4a25      	ldr	r2, [pc, #148]	@ (800075c <secondMessageSender+0x140>)
 80006c8:	60d3      	str	r3, [r2, #12]
		}
		memcpy(sendBuffer + sendCounter, UIDsplit, 4);
 80006ca:	4b26      	ldr	r3, [pc, #152]	@ (8000764 <secondMessageSender+0x148>)
 80006cc:	881b      	ldrh	r3, [r3, #0]
 80006ce:	461a      	mov	r2, r3
 80006d0:	4b23      	ldr	r3, [pc, #140]	@ (8000760 <secondMessageSender+0x144>)
 80006d2:	4413      	add	r3, r2
 80006d4:	687a      	ldr	r2, [r7, #4]
 80006d6:	601a      	str	r2, [r3, #0]
		sendCounter += 4;
 80006d8:	4b22      	ldr	r3, [pc, #136]	@ (8000764 <secondMessageSender+0x148>)
 80006da:	881b      	ldrh	r3, [r3, #0]
 80006dc:	3304      	adds	r3, #4
 80006de:	b29a      	uxth	r2, r3
 80006e0:	4b20      	ldr	r3, [pc, #128]	@ (8000764 <secondMessageSender+0x148>)
 80006e2:	801a      	strh	r2, [r3, #0]
	for (size_t i = 0; i < 3; i++)
 80006e4:	697b      	ldr	r3, [r7, #20]
 80006e6:	3301      	adds	r3, #1
 80006e8:	617b      	str	r3, [r7, #20]
 80006ea:	697b      	ldr	r3, [r7, #20]
 80006ec:	2b02      	cmp	r3, #2
 80006ee:	d9ae      	bls.n	800064e <secondMessageSender+0x32>
	}

	// treba este vlozit velkost certifikatu tokenu pred samotny certifikat
	// velkost je ale vyssia ako 256, treba ju splitnut na uint8_t
	sendBuffer[sendCounter] = (tokenCertLen >> 8) & 0xFF;
 80006f0:	4b1d      	ldr	r3, [pc, #116]	@ (8000768 <secondMessageSender+0x14c>)
 80006f2:	881b      	ldrh	r3, [r3, #0]
 80006f4:	0a1b      	lsrs	r3, r3, #8
 80006f6:	b299      	uxth	r1, r3
 80006f8:	4b1a      	ldr	r3, [pc, #104]	@ (8000764 <secondMessageSender+0x148>)
 80006fa:	881b      	ldrh	r3, [r3, #0]
 80006fc:	461a      	mov	r2, r3
 80006fe:	b2c9      	uxtb	r1, r1
 8000700:	4b17      	ldr	r3, [pc, #92]	@ (8000760 <secondMessageSender+0x144>)
 8000702:	5499      	strb	r1, [r3, r2]
	sendCounter++;
 8000704:	4b17      	ldr	r3, [pc, #92]	@ (8000764 <secondMessageSender+0x148>)
 8000706:	881b      	ldrh	r3, [r3, #0]
 8000708:	3301      	adds	r3, #1
 800070a:	b29a      	uxth	r2, r3
 800070c:	4b15      	ldr	r3, [pc, #84]	@ (8000764 <secondMessageSender+0x148>)
 800070e:	801a      	strh	r2, [r3, #0]
	sendBuffer[sendCounter] = tokenCertLen  & 0xFF;
 8000710:	4b15      	ldr	r3, [pc, #84]	@ (8000768 <secondMessageSender+0x14c>)
 8000712:	8819      	ldrh	r1, [r3, #0]
 8000714:	4b13      	ldr	r3, [pc, #76]	@ (8000764 <secondMessageSender+0x148>)
 8000716:	881b      	ldrh	r3, [r3, #0]
 8000718:	461a      	mov	r2, r3
 800071a:	b2c9      	uxtb	r1, r1
 800071c:	4b10      	ldr	r3, [pc, #64]	@ (8000760 <secondMessageSender+0x144>)
 800071e:	5499      	strb	r1, [r3, r2]
	sendCounter++;
 8000720:	4b10      	ldr	r3, [pc, #64]	@ (8000764 <secondMessageSender+0x148>)
 8000722:	881b      	ldrh	r3, [r3, #0]
 8000724:	3301      	adds	r3, #1
 8000726:	b29a      	uxth	r2, r3
 8000728:	4b0e      	ldr	r3, [pc, #56]	@ (8000764 <secondMessageSender+0x148>)
 800072a:	801a      	strh	r2, [r3, #0]
	// vkladam uz certifikat tokenu
	memcpy(sendBuffer + sendCounter, tokenCert, tokenCertLen);
 800072c:	4b0d      	ldr	r3, [pc, #52]	@ (8000764 <secondMessageSender+0x148>)
 800072e:	881b      	ldrh	r3, [r3, #0]
 8000730:	461a      	mov	r2, r3
 8000732:	4b0b      	ldr	r3, [pc, #44]	@ (8000760 <secondMessageSender+0x144>)
 8000734:	4413      	add	r3, r2
 8000736:	4a0c      	ldr	r2, [pc, #48]	@ (8000768 <secondMessageSender+0x14c>)
 8000738:	8812      	ldrh	r2, [r2, #0]
 800073a:	490c      	ldr	r1, [pc, #48]	@ (800076c <secondMessageSender+0x150>)
 800073c:	4618      	mov	r0, r3
 800073e:	f027 ff31 	bl	80285a4 <memcpy>
	sendCounter += tokenCertLen;
 8000742:	4b08      	ldr	r3, [pc, #32]	@ (8000764 <secondMessageSender+0x148>)
 8000744:	881a      	ldrh	r2, [r3, #0]
 8000746:	4b08      	ldr	r3, [pc, #32]	@ (8000768 <secondMessageSender+0x14c>)
 8000748:	881b      	ldrh	r3, [r3, #0]
 800074a:	4413      	add	r3, r2
 800074c:	b29a      	uxth	r2, r3
 800074e:	4b05      	ldr	r3, [pc, #20]	@ (8000764 <secondMessageSender+0x148>)
 8000750:	801a      	strh	r2, [r3, #0]
	return;
 8000752:	bf00      	nop
}
 8000754:	3718      	adds	r7, #24
 8000756:	46bd      	mov	sp, r7
 8000758:	bd80      	pop	{r7, pc}
 800075a:	bf00      	nop
 800075c:	20000004 	.word	0x20000004
 8000760:	20001ce0 	.word	0x20001ce0
 8000764:	200026a4 	.word	0x200026a4
 8000768:	080302ec 	.word	0x080302ec
 800076c:	0802ffa0 	.word	0x0802ffa0

08000770 <thirdMessageHandler>:

void thirdMessageHandler(uint8_t* encryptedKey, uint8_t* encryptedIV, uint8_t* payload, uint8_t* deviceCertBuffer, uint16_t deviceCertLen) {
 8000770:	b590      	push	{r4, r7, lr}
 8000772:	f5ad 5dde 	sub.w	sp, sp, #7104	@ 0x1bc0
 8000776:	b085      	sub	sp, #20
 8000778:	af02      	add	r7, sp, #8
 800077a:	f607 34c8 	addw	r4, r7, #3016	@ 0xbc8
 800077e:	f6a4 34bc 	subw	r4, r4, #3004	@ 0xbbc
 8000782:	6020      	str	r0, [r4, #0]
 8000784:	f607 30c8 	addw	r0, r7, #3016	@ 0xbc8
 8000788:	f5a0 603c 	sub.w	r0, r0, #3008	@ 0xbc0
 800078c:	6001      	str	r1, [r0, #0]
 800078e:	f607 31c8 	addw	r1, r7, #3016	@ 0xbc8
 8000792:	f6a1 31c4 	subw	r1, r1, #3012	@ 0xbc4
 8000796:	600a      	str	r2, [r1, #0]
 8000798:	f607 32c8 	addw	r2, r7, #3016	@ 0xbc8
 800079c:	f6a2 32c8 	subw	r2, r2, #3016	@ 0xbc8
 80007a0:	6013      	str	r3, [r2, #0]
	// over certifikat zariadenia ci je podpisany CA
	WOLFSSL_CTX* ctx = wolfSSL_CTX_new(wolfTLSv1_2_client_method());
 80007a2:	f00e fef7 	bl	800f594 <wolfTLSv1_2_client_method>
 80007a6:	4603      	mov	r3, r0
 80007a8:	4618      	mov	r0, r3
 80007aa:	f00b fcd9 	bl	800c160 <wolfSSL_CTX_new>
 80007ae:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80007b2:	f103 0304 	add.w	r3, r3, #4
 80007b6:	6018      	str	r0, [r3, #0]
	int ret = wolfSSL_CTX_load_verify_buffer(ctx, CACert, CACertLen, WOLFSSL_FILETYPE_ASN1);
 80007b8:	4b80      	ldr	r3, [pc, #512]	@ (80009bc <thirdMessageHandler+0x24c>)
 80007ba:	881b      	ldrh	r3, [r3, #0]
 80007bc:	461a      	mov	r2, r3
 80007be:	2302      	movs	r3, #2
 80007c0:	497f      	ldr	r1, [pc, #508]	@ (80009c0 <thirdMessageHandler+0x250>)
 80007c2:	f507 50de 	add.w	r0, r7, #7104	@ 0x1bc0
 80007c6:	f100 0004 	add.w	r0, r0, #4
 80007ca:	6800      	ldr	r0, [r0, #0]
 80007cc:	f00d f8ba 	bl	800d944 <wolfSSL_CTX_load_verify_buffer>
 80007d0:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80007d4:	6018      	str	r0, [r3, #0]
    if (ret != SSL_SUCCESS) {
 80007d6:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80007da:	681b      	ldr	r3, [r3, #0]
 80007dc:	2b01      	cmp	r3, #1
 80007de:	f040 8205 	bne.w	8000bec <thirdMessageHandler+0x47c>
        return;
    }
    WOLFSSL_CERT_MANAGER* cm = wolfSSL_CTX_GetCertManager(ctx);
 80007e2:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80007e6:	f103 0304 	add.w	r3, r3, #4
 80007ea:	6818      	ldr	r0, [r3, #0]
 80007ec:	f00b fd08 	bl	800c200 <wolfSSL_CTX_GetCertManager>
 80007f0:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 80007f4:	f103 031c 	add.w	r3, r3, #28
 80007f8:	6018      	str	r0, [r3, #0]
    if (!cm) {
 80007fa:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 80007fe:	f103 031c 	add.w	r3, r3, #28
 8000802:	681b      	ldr	r3, [r3, #0]
 8000804:	2b00      	cmp	r3, #0
 8000806:	f000 81f3 	beq.w	8000bf0 <thirdMessageHandler+0x480>
        return;
    }
    ret = wolfSSL_CertManagerVerifyBuffer(cm, deviceCertBuffer, deviceCertLen, WOLFSSL_FILETYPE_ASN1);
 800080a:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 800080e:	f103 0318 	add.w	r3, r3, #24
 8000812:	881a      	ldrh	r2, [r3, #0]
 8000814:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000818:	f6a3 31c8 	subw	r1, r3, #3016	@ 0xbc8
 800081c:	2302      	movs	r3, #2
 800081e:	6809      	ldr	r1, [r1, #0]
 8000820:	f507 50dd 	add.w	r0, r7, #7072	@ 0x1ba0
 8000824:	f100 001c 	add.w	r0, r0, #28
 8000828:	6800      	ldr	r0, [r0, #0]
 800082a:	f00a ffc3 	bl	800b7b4 <wolfSSL_CertManagerVerifyBuffer>
 800082e:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 8000832:	6018      	str	r0, [r3, #0]
    if (ret != SSL_SUCCESS) {
 8000834:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 8000838:	681b      	ldr	r3, [r3, #0]
 800083a:	2b01      	cmp	r3, #1
 800083c:	f040 81da 	bne.w	8000bf4 <thirdMessageHandler+0x484>
        return;
    }

    // ak ano, tak extrahuj z neho verejny kluc
    wc_InitRsaKey(&pubKey, NULL);
 8000840:	2100      	movs	r1, #0
 8000842:	4860      	ldr	r0, [pc, #384]	@ (80009c4 <thirdMessageHandler+0x254>)
 8000844:	f01f fb9a 	bl	801ff7c <wc_InitRsaKey>
    DecodedCert extractedPCCert;
    InitDecodedCert(&extractedPCCert, (byte*)deviceCertBuffer, deviceCertLen, NULL);
 8000848:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 800084c:	f103 0318 	add.w	r3, r3, #24
 8000850:	881a      	ldrh	r2, [r3, #0]
 8000852:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000856:	f6a3 31c8 	subw	r1, r3, #3016	@ 0xbc8
 800085a:	f507 50b7 	add.w	r0, r7, #5856	@ 0x16e0
 800085e:	f100 0010 	add.w	r0, r0, #16
 8000862:	2300      	movs	r3, #0
 8000864:	6809      	ldr	r1, [r1, #0]
 8000866:	f014 fc42 	bl	80150ee <InitDecodedCert>
    ret = ParseCert(&extractedPCCert, CERT_TYPE, NO_VERIFY, NULL);
 800086a:	f507 50b7 	add.w	r0, r7, #5856	@ 0x16e0
 800086e:	f100 0010 	add.w	r0, r0, #16
 8000872:	2300      	movs	r3, #0
 8000874:	2200      	movs	r2, #0
 8000876:	2100      	movs	r1, #0
 8000878:	f017 ff01 	bl	801867e <ParseCert>
 800087c:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 8000880:	6018      	str	r0, [r3, #0]
    word32 idx = 0;
 8000882:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 8000886:	f103 0308 	add.w	r3, r3, #8
 800088a:	f2a3 43dc 	subw	r3, r3, #1244	@ 0x4dc
 800088e:	2200      	movs	r2, #0
 8000890:	601a      	str	r2, [r3, #0]
    ret = wc_RsaPublicKeyDecode(extractedPCCert.publicKey, &idx, &pubKey, extractedPCCert.pubKeySize);
 8000892:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 8000896:	f103 0308 	add.w	r3, r3, #8
 800089a:	f5a3 639b 	sub.w	r3, r3, #1240	@ 0x4d8
 800089e:	6818      	ldr	r0, [r3, #0]
 80008a0:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80008a4:	f103 0308 	add.w	r3, r3, #8
 80008a8:	f5a3 639b 	sub.w	r3, r3, #1240	@ 0x4d8
 80008ac:	685b      	ldr	r3, [r3, #4]
 80008ae:	f507 51b7 	add.w	r1, r7, #5856	@ 0x16e0
 80008b2:	f101 010c 	add.w	r1, r1, #12
 80008b6:	4a43      	ldr	r2, [pc, #268]	@ (80009c4 <thirdMessageHandler+0x254>)
 80008b8:	f014 fbe0 	bl	801507c <wc_RsaPublicKeyDecode>
 80008bc:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80008c0:	6018      	str	r0, [r3, #0]
    if (ret != 0) {
 80008c2:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80008c6:	681b      	ldr	r3, [r3, #0]
 80008c8:	2b00      	cmp	r3, #0
 80008ca:	d00e      	beq.n	80008ea <thirdMessageHandler+0x17a>
        wolfSSL_CertManagerFree(cm);
 80008cc:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 80008d0:	f103 031c 	add.w	r3, r3, #28
 80008d4:	6818      	ldr	r0, [r3, #0]
 80008d6:	f00a fe84 	bl	800b5e2 <wolfSSL_CertManagerFree>
        wolfSSL_CTX_free(ctx);
 80008da:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80008de:	f103 0304 	add.w	r3, r3, #4
 80008e2:	6818      	ldr	r0, [r3, #0]
 80008e4:	f00b fc49 	bl	800c17a <wolfSSL_CTX_free>
        return;
 80008e8:	e18d      	b.n	8000c06 <thirdMessageHandler+0x496>
    }
    wolfSSL_CertManagerFree(cm);
 80008ea:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 80008ee:	f103 031c 	add.w	r3, r3, #28
 80008f2:	6818      	ldr	r0, [r3, #0]
 80008f4:	f00a fe75 	bl	800b5e2 <wolfSSL_CertManagerFree>
    wolfSSL_CTX_free(ctx);
 80008f8:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 80008fc:	f103 0304 	add.w	r3, r3, #4
 8000900:	6818      	ldr	r0, [r3, #0]
 8000902:	f00b fc3a 	bl	800c17a <wolfSSL_CTX_free>

    // ak ano tak mozeme desifrovat prijate data. zober sukromny kluc tokenu
    RsaKey rsaKey;
    WC_RNG rng;
    int rsaRet = wc_InitRsaKey(&rsaKey, NULL);
 8000906:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 800090a:	3b18      	subs	r3, #24
 800090c:	2100      	movs	r1, #0
 800090e:	4618      	mov	r0, r3
 8000910:	f01f fb34 	bl	801ff7c <wc_InitRsaKey>
 8000914:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000918:	f103 0318 	add.w	r3, r3, #24
 800091c:	6018      	str	r0, [r3, #0]
    if (rsaRet != 0) {
 800091e:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000922:	f103 0318 	add.w	r3, r3, #24
 8000926:	681b      	ldr	r3, [r3, #0]
 8000928:	2b00      	cmp	r3, #0
 800092a:	f040 8165 	bne.w	8000bf8 <thirdMessageHandler+0x488>
        return;
    }
    rsaRet = wc_InitRng(&rng);
 800092e:	f507 63ad 	add.w	r3, r7, #1384	@ 0x568
 8000932:	3b08      	subs	r3, #8
 8000934:	4618      	mov	r0, r3
 8000936:	f01e fe22 	bl	801f57e <wc_InitRng>
 800093a:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 800093e:	f103 0318 	add.w	r3, r3, #24
 8000942:	6018      	str	r0, [r3, #0]
    if (rsaRet != 0) {
 8000944:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000948:	f103 0318 	add.w	r3, r3, #24
 800094c:	681b      	ldr	r3, [r3, #0]
 800094e:	2b00      	cmp	r3, #0
 8000950:	d006      	beq.n	8000960 <thirdMessageHandler+0x1f0>
        wc_FreeRsaKey(&rsaKey);
 8000952:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 8000956:	3b18      	subs	r3, #24
 8000958:	4618      	mov	r0, r3
 800095a:	f01f fb1f 	bl	801ff9c <wc_FreeRsaKey>
        return;
 800095e:	e152      	b.n	8000c06 <thirdMessageHandler+0x496>
    }
    idx = 0;
 8000960:	f507 53de 	add.w	r3, r7, #7104	@ 0x1bc0
 8000964:	f103 0308 	add.w	r3, r3, #8
 8000968:	f2a3 43dc 	subw	r3, r3, #1244	@ 0x4dc
 800096c:	2200      	movs	r2, #0
 800096e:	601a      	str	r2, [r3, #0]
    rsaRet = wc_RsaPrivateKeyDecode(tokenPrivKey, &idx, &rsaKey, tokenPrivKeyLen);
 8000970:	4b15      	ldr	r3, [pc, #84]	@ (80009c8 <thirdMessageHandler+0x258>)
 8000972:	881b      	ldrh	r3, [r3, #0]
 8000974:	f507 62b1 	add.w	r2, r7, #1416	@ 0x588
 8000978:	3a18      	subs	r2, #24
 800097a:	f507 51b7 	add.w	r1, r7, #5856	@ 0x16e0
 800097e:	f101 010c 	add.w	r1, r1, #12
 8000982:	4812      	ldr	r0, [pc, #72]	@ (80009cc <thirdMessageHandler+0x25c>)
 8000984:	f014 f944 	bl	8014c10 <wc_RsaPrivateKeyDecode>
 8000988:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 800098c:	f103 0318 	add.w	r3, r3, #24
 8000990:	6018      	str	r0, [r3, #0]
    if (rsaRet != 0) {
 8000992:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000996:	f103 0318 	add.w	r3, r3, #24
 800099a:	681b      	ldr	r3, [r3, #0]
 800099c:	2b00      	cmp	r3, #0
 800099e:	d017      	beq.n	80009d0 <thirdMessageHandler+0x260>
        wc_FreeRsaKey(&rsaKey);
 80009a0:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 80009a4:	3b18      	subs	r3, #24
 80009a6:	4618      	mov	r0, r3
 80009a8:	f01f faf8 	bl	801ff9c <wc_FreeRsaKey>
        wc_FreeRng(&rng);
 80009ac:	f507 63ad 	add.w	r3, r7, #1384	@ 0x568
 80009b0:	3b08      	subs	r3, #8
 80009b2:	4618      	mov	r0, r3
 80009b4:	f01e fe96 	bl	801f6e4 <wc_FreeRng>
        return;
 80009b8:	e125      	b.n	8000c06 <thirdMessageHandler+0x496>
 80009ba:	bf00      	nop
 80009bc:	08030b56 	.word	0x08030b56
 80009c0:	080307b4 	.word	0x080307b4
 80009c4:	200001a0 	.word	0x200001a0
 80009c8:	080307b0 	.word	0x080307b0
 80009cc:	080302f0 	.word	0x080302f0
    }
    wc_RsaSetRNG(&rsaKey, &rng);
 80009d0:	f507 62ad 	add.w	r2, r7, #1384	@ 0x568
 80009d4:	3a08      	subs	r2, #8
 80009d6:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 80009da:	3b18      	subs	r3, #24
 80009dc:	4611      	mov	r1, r2
 80009de:	4618      	mov	r0, r3
 80009e0:	f020 fd1a 	bl	8021418 <wc_RsaSetRNG>

    // desifrujeme
    uint8_t decryptedKey[256] = {0};
 80009e4:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 80009e8:	f5a3 63ed 	sub.w	r3, r3, #1896	@ 0x768
 80009ec:	4618      	mov	r0, r3
 80009ee:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80009f2:	461a      	mov	r2, r3
 80009f4:	2100      	movs	r1, #0
 80009f6:	f027 fd6b 	bl	80284d0 <memset>
    word32 decryptedKeyLen = sizeof(decryptedKey);
 80009fa:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80009fe:	f507 52dd 	add.w	r2, r7, #7072	@ 0x1ba0
 8000a02:	f102 0214 	add.w	r2, r2, #20
 8000a06:	6013      	str	r3, [r2, #0]
    uint8_t decryptedIV[256] = {0};
 8000a08:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000a0c:	f6a3 0368 	subw	r3, r3, #2152	@ 0x868
 8000a10:	4618      	mov	r0, r3
 8000a12:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000a16:	461a      	mov	r2, r3
 8000a18:	2100      	movs	r1, #0
 8000a1a:	f027 fd59 	bl	80284d0 <memset>
    word32 decryptedIVLen = sizeof(decryptedIV);
 8000a1e:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000a22:	f507 52dd 	add.w	r2, r7, #7072	@ 0x1ba0
 8000a26:	f102 0210 	add.w	r2, r2, #16
 8000a2a:	6013      	str	r3, [r2, #0]
    word32 inputSize = 256;
 8000a2c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000a30:	f507 52dd 	add.w	r2, r7, #7072	@ 0x1ba0
 8000a34:	f102 020c 	add.w	r2, r2, #12
 8000a38:	6013      	str	r3, [r2, #0]
    // najprv kluc od celej spravy, sukromnym klucom tokenu
    rsaRet = wc_RsaPrivateDecrypt(encryptedKey, inputSize, decryptedKey, decryptedKeyLen, &rsaKey);
 8000a3a:	f507 628d 	add.w	r2, r7, #1128	@ 0x468
 8000a3e:	3a08      	subs	r2, #8
 8000a40:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000a44:	f6a3 30bc 	subw	r0, r3, #3004	@ 0xbbc
 8000a48:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 8000a4c:	3b18      	subs	r3, #24
 8000a4e:	9300      	str	r3, [sp, #0]
 8000a50:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000a54:	f103 0314 	add.w	r3, r3, #20
 8000a58:	681b      	ldr	r3, [r3, #0]
 8000a5a:	f507 51dd 	add.w	r1, r7, #7072	@ 0x1ba0
 8000a5e:	f101 010c 	add.w	r1, r1, #12
 8000a62:	6809      	ldr	r1, [r1, #0]
 8000a64:	6800      	ldr	r0, [r0, #0]
 8000a66:	f020 fb9f 	bl	80211a8 <wc_RsaPrivateDecrypt>
 8000a6a:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000a6e:	f103 0318 	add.w	r3, r3, #24
 8000a72:	6018      	str	r0, [r3, #0]
    // potom inicializacny vektor, sukromnym klucom tokenu
    rsaRet = wc_RsaPrivateDecrypt(encryptedIV, inputSize, decryptedIV, decryptedIVLen, &rsaKey);
 8000a74:	f507 725a 	add.w	r2, r7, #872	@ 0x368
 8000a78:	3a08      	subs	r2, #8
 8000a7a:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000a7e:	f5a3 603c 	sub.w	r0, r3, #3008	@ 0xbc0
 8000a82:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 8000a86:	3b18      	subs	r3, #24
 8000a88:	9300      	str	r3, [sp, #0]
 8000a8a:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000a8e:	f103 0310 	add.w	r3, r3, #16
 8000a92:	681b      	ldr	r3, [r3, #0]
 8000a94:	f507 51dd 	add.w	r1, r7, #7072	@ 0x1ba0
 8000a98:	f101 010c 	add.w	r1, r1, #12
 8000a9c:	6809      	ldr	r1, [r1, #0]
 8000a9e:	6800      	ldr	r0, [r0, #0]
 8000aa0:	f020 fb82 	bl	80211a8 <wc_RsaPrivateDecrypt>
 8000aa4:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000aa8:	f103 0318 	add.w	r3, r3, #24
 8000aac:	6018      	str	r0, [r3, #0]
    // a nakoniec celu spravu (payload)
    Aes aes;
    int aesRet = wc_AesSetKey(&aes, decryptedKey, 16, decryptedIV, AES_DECRYPTION);
 8000aae:	f507 735a 	add.w	r3, r7, #872	@ 0x368
 8000ab2:	3b08      	subs	r3, #8
 8000ab4:	f507 618d 	add.w	r1, r7, #1128	@ 0x468
 8000ab8:	3908      	subs	r1, #8
 8000aba:	f507 700a 	add.w	r0, r7, #552	@ 0x228
 8000abe:	3814      	subs	r0, #20
 8000ac0:	2201      	movs	r2, #1
 8000ac2:	9200      	str	r2, [sp, #0]
 8000ac4:	2210      	movs	r2, #16
 8000ac6:	f011 fcd3 	bl	8012470 <wc_AesSetKey>
 8000aca:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000ace:	f103 0308 	add.w	r3, r3, #8
 8000ad2:	6018      	str	r0, [r3, #0]
    if (aesRet != 0) {
 8000ad4:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000ad8:	f103 0308 	add.w	r3, r3, #8
 8000adc:	681b      	ldr	r3, [r3, #0]
 8000ade:	2b00      	cmp	r3, #0
 8000ae0:	f040 808c 	bne.w	8000bfc <thirdMessageHandler+0x48c>
        return;
    }
    uint8_t decryptedPayload[512];
    aesRet = wc_AesCbcDecrypt(&aes, decryptedPayload, payload, 512);
 8000ae4:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000ae8:	f6a3 32c4 	subw	r2, r3, #3012	@ 0xbc4
 8000aec:	f107 0128 	add.w	r1, r7, #40	@ 0x28
 8000af0:	3914      	subs	r1, #20
 8000af2:	f507 700a 	add.w	r0, r7, #552	@ 0x228
 8000af6:	3814      	subs	r0, #20
 8000af8:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000afc:	6812      	ldr	r2, [r2, #0]
 8000afe:	f011 fd46 	bl	801258e <wc_AesCbcDecrypt>
 8000b02:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000b06:	f103 0308 	add.w	r3, r3, #8
 8000b0a:	6018      	str	r0, [r3, #0]
    if (aesRet != 0) {
 8000b0c:	f507 53dd 	add.w	r3, r7, #7072	@ 0x1ba0
 8000b10:	f103 0308 	add.w	r3, r3, #8
 8000b14:	681b      	ldr	r3, [r3, #0]
 8000b16:	2b00      	cmp	r3, #0
 8000b18:	d172      	bne.n	8000c00 <thirdMessageHandler+0x490>
        return;
    }

    // ukladanie dat do struktury
    memcpy(thirdMessage.timestamp, &decryptedPayload[0], 4);
 8000b1a:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b1e:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b22:	681b      	ldr	r3, [r3, #0]
 8000b24:	4a3a      	ldr	r2, [pc, #232]	@ (8000c10 <thirdMessageHandler+0x4a0>)
 8000b26:	6013      	str	r3, [r2, #0]
    memcpy(thirdMessage.session_key, &decryptedPayload[4], 16);
 8000b28:	4a39      	ldr	r2, [pc, #228]	@ (8000c10 <thirdMessageHandler+0x4a0>)
 8000b2a:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b2e:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b32:	1d14      	adds	r4, r2, #4
 8000b34:	3304      	adds	r3, #4
 8000b36:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000b38:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    memcpy(thirdMessage.session_IV, &decryptedPayload[20], 16);
 8000b3c:	4a34      	ldr	r2, [pc, #208]	@ (8000c10 <thirdMessageHandler+0x4a0>)
 8000b3e:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b42:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b46:	f102 0414 	add.w	r4, r2, #20
 8000b4a:	3314      	adds	r3, #20
 8000b4c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000b4e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    memcpy(thirdMessage.Tid_one, &decryptedPayload[36], 4);
 8000b52:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b56:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b5a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000b5c:	4a2c      	ldr	r2, [pc, #176]	@ (8000c10 <thirdMessageHandler+0x4a0>)
 8000b5e:	6253      	str	r3, [r2, #36]	@ 0x24
    memcpy(thirdMessage.Tid_two, &decryptedPayload[40], 4);
 8000b60:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b64:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b68:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000b6a:	4a29      	ldr	r2, [pc, #164]	@ (8000c10 <thirdMessageHandler+0x4a0>)
 8000b6c:	6293      	str	r3, [r2, #40]	@ 0x28
    memcpy(thirdMessage.Tid_three, &decryptedPayload[44], 4);
 8000b6e:	f607 33c8 	addw	r3, r7, #3016	@ 0xbc8
 8000b72:	f6a3 33b4 	subw	r3, r3, #2996	@ 0xbb4
 8000b76:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8000b78:	4a25      	ldr	r2, [pc, #148]	@ (8000c10 <thirdMessageHandler+0x4a0>)
 8000b7a:	62d3      	str	r3, [r2, #44]	@ 0x2c
    memcpy(thirdMessage.PC_id, &decryptedPayload[48], 8);
 8000b7c:	4b24      	ldr	r3, [pc, #144]	@ (8000c10 <thirdMessageHandler+0x4a0>)
 8000b7e:	f607 32c8 	addw	r2, r7, #3016	@ 0xbc8
 8000b82:	f6a2 32b4 	subw	r2, r2, #2996	@ 0xbb4
 8000b86:	3330      	adds	r3, #48	@ 0x30
 8000b88:	3230      	adds	r2, #48	@ 0x30
 8000b8a:	e892 0003 	ldmia.w	r2, {r0, r1}
 8000b8e:	e883 0003 	stmia.w	r3, {r0, r1}
    wc_FreeRsaKey(&rsaKey);
 8000b92:	f507 63b1 	add.w	r3, r7, #1416	@ 0x588
 8000b96:	3b18      	subs	r3, #24
 8000b98:	4618      	mov	r0, r3
 8000b9a:	f01f f9ff 	bl	801ff9c <wc_FreeRsaKey>
    wc_FreeRng(&rng);
 8000b9e:	f507 63ad 	add.w	r3, r7, #1384	@ 0x568
 8000ba2:	3b08      	subs	r3, #8
 8000ba4:	4618      	mov	r0, r3
 8000ba6:	f01e fd9d 	bl	801f6e4 <wc_FreeRng>
    wc_AesFree(&aes);
 8000baa:	f507 730a 	add.w	r3, r7, #552	@ 0x228
 8000bae:	3b14      	subs	r3, #20
 8000bb0:	4618      	mov	r0, r3
 8000bb2:	f011 fd63 	bl	801267c <wc_AesFree>

    // skontrolujme este ci prijaty token ID suladi s tym co sme odoslali v druhej sprave
    if(memcmp(secondMessage.Tid_one, thirdMessage.Tid_one, sizeof(secondMessage.Tid_one)) != 0 ||
 8000bb6:	2204      	movs	r2, #4
 8000bb8:	4916      	ldr	r1, [pc, #88]	@ (8000c14 <thirdMessageHandler+0x4a4>)
 8000bba:	4817      	ldr	r0, [pc, #92]	@ (8000c18 <thirdMessageHandler+0x4a8>)
 8000bbc:	f027 fc5e 	bl	802847c <memcmp>
 8000bc0:	4603      	mov	r3, r0
 8000bc2:	2b00      	cmp	r3, #0
 8000bc4:	d11e      	bne.n	8000c04 <thirdMessageHandler+0x494>
    		memcmp(secondMessage.Tid_two, thirdMessage.Tid_two, sizeof(secondMessage.Tid_two)) != 0 ||
 8000bc6:	2204      	movs	r2, #4
 8000bc8:	4914      	ldr	r1, [pc, #80]	@ (8000c1c <thirdMessageHandler+0x4ac>)
 8000bca:	4815      	ldr	r0, [pc, #84]	@ (8000c20 <thirdMessageHandler+0x4b0>)
 8000bcc:	f027 fc56 	bl	802847c <memcmp>
 8000bd0:	4603      	mov	r3, r0
    if(memcmp(secondMessage.Tid_one, thirdMessage.Tid_one, sizeof(secondMessage.Tid_one)) != 0 ||
 8000bd2:	2b00      	cmp	r3, #0
 8000bd4:	d116      	bne.n	8000c04 <thirdMessageHandler+0x494>
    				memcmp(secondMessage.Tid_three, thirdMessage.Tid_three, sizeof(secondMessage.Tid_three)) != 0) {
 8000bd6:	2204      	movs	r2, #4
 8000bd8:	4912      	ldr	r1, [pc, #72]	@ (8000c24 <thirdMessageHandler+0x4b4>)
 8000bda:	4813      	ldr	r0, [pc, #76]	@ (8000c28 <thirdMessageHandler+0x4b8>)
 8000bdc:	f027 fc4e 	bl	802847c <memcmp>
 8000be0:	4603      	mov	r3, r0
    		memcmp(secondMessage.Tid_two, thirdMessage.Tid_two, sizeof(secondMessage.Tid_two)) != 0 ||
 8000be2:	2b00      	cmp	r3, #0
 8000be4:	d10e      	bne.n	8000c04 <thirdMessageHandler+0x494>
    	return;
    }
	fourthMessageSender();
 8000be6:	f000 f821 	bl	8000c2c <fourthMessageSender>
 8000bea:	e00c      	b.n	8000c06 <thirdMessageHandler+0x496>
        return;
 8000bec:	bf00      	nop
 8000bee:	e00a      	b.n	8000c06 <thirdMessageHandler+0x496>
        return;
 8000bf0:	bf00      	nop
 8000bf2:	e008      	b.n	8000c06 <thirdMessageHandler+0x496>
        return;
 8000bf4:	bf00      	nop
 8000bf6:	e006      	b.n	8000c06 <thirdMessageHandler+0x496>
        return;
 8000bf8:	bf00      	nop
 8000bfa:	e004      	b.n	8000c06 <thirdMessageHandler+0x496>
        return;
 8000bfc:	bf00      	nop
 8000bfe:	e002      	b.n	8000c06 <thirdMessageHandler+0x496>
        return;
 8000c00:	bf00      	nop
 8000c02:	e000      	b.n	8000c06 <thirdMessageHandler+0x496>
    	return;
 8000c04:	bf00      	nop
}
 8000c06:	f507 57de 	add.w	r7, r7, #7104	@ 0x1bc0
 8000c0a:	370c      	adds	r7, #12
 8000c0c:	46bd      	mov	sp, r7
 8000c0e:	bd90      	pop	{r4, r7, pc}
 8000c10:	2000131c 	.word	0x2000131c
 8000c14:	20001340 	.word	0x20001340
 8000c18:	20000008 	.word	0x20000008
 8000c1c:	20001344 	.word	0x20001344
 8000c20:	2000000c 	.word	0x2000000c
 8000c24:	20001348 	.word	0x20001348
 8000c28:	20000010 	.word	0x20000010

08000c2c <fourthMessageSender>:

void fourthMessageSender() {
 8000c2c:	b5b0      	push	{r4, r5, r7, lr}
 8000c2e:	f5ad 6db0 	sub.w	sp, sp, #1408	@ 0x580
 8000c32:	af02      	add	r7, sp, #8
	// inkrementujme timestamp o 1
	uint32_t timestamp = (thirdMessage.timestamp[3] << 24) | (thirdMessage.timestamp[2] << 16) |
 8000c34:	4b5e      	ldr	r3, [pc, #376]	@ (8000db0 <fourthMessageSender+0x184>)
 8000c36:	78db      	ldrb	r3, [r3, #3]
 8000c38:	061a      	lsls	r2, r3, #24
 8000c3a:	4b5d      	ldr	r3, [pc, #372]	@ (8000db0 <fourthMessageSender+0x184>)
 8000c3c:	789b      	ldrb	r3, [r3, #2]
 8000c3e:	041b      	lsls	r3, r3, #16
 8000c40:	431a      	orrs	r2, r3
	     ( thirdMessage.timestamp[1] << 8 ) | (thirdMessage.timestamp[0]);
 8000c42:	4b5b      	ldr	r3, [pc, #364]	@ (8000db0 <fourthMessageSender+0x184>)
 8000c44:	785b      	ldrb	r3, [r3, #1]
 8000c46:	021b      	lsls	r3, r3, #8
	uint32_t timestamp = (thirdMessage.timestamp[3] << 24) | (thirdMessage.timestamp[2] << 16) |
 8000c48:	4313      	orrs	r3, r2
	     ( thirdMessage.timestamp[1] << 8 ) | (thirdMessage.timestamp[0]);
 8000c4a:	4a59      	ldr	r2, [pc, #356]	@ (8000db0 <fourthMessageSender+0x184>)
 8000c4c:	7812      	ldrb	r2, [r2, #0]
 8000c4e:	4313      	orrs	r3, r2
	uint32_t timestamp = (thirdMessage.timestamp[3] << 24) | (thirdMessage.timestamp[2] << 16) |
 8000c50:	f8c7 3574 	str.w	r3, [r7, #1396]	@ 0x574
	timestamp += 1;
 8000c54:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c58:	3301      	adds	r3, #1
 8000c5a:	f8c7 3574 	str.w	r3, [r7, #1396]	@ 0x574

	// pripravme si  takmer celu stvrtu spravu podla struktury MessageFour
	fourthMessage.timestamp[0] = (timestamp & 0x000000ff);
 8000c5e:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c62:	b2da      	uxtb	r2, r3
 8000c64:	4b53      	ldr	r3, [pc, #332]	@ (8000db4 <fourthMessageSender+0x188>)
 8000c66:	701a      	strb	r2, [r3, #0]
	fourthMessage.timestamp[1] = (timestamp & 0x0000ff00) >> 8;
 8000c68:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c6c:	0a1b      	lsrs	r3, r3, #8
 8000c6e:	b2da      	uxtb	r2, r3
 8000c70:	4b50      	ldr	r3, [pc, #320]	@ (8000db4 <fourthMessageSender+0x188>)
 8000c72:	705a      	strb	r2, [r3, #1]
	fourthMessage.timestamp[2] = (timestamp & 0x00ff0000) >> 16;
 8000c74:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c78:	0c1b      	lsrs	r3, r3, #16
 8000c7a:	b2da      	uxtb	r2, r3
 8000c7c:	4b4d      	ldr	r3, [pc, #308]	@ (8000db4 <fourthMessageSender+0x188>)
 8000c7e:	709a      	strb	r2, [r3, #2]
	fourthMessage.timestamp[3] = (timestamp & 0xff000000) >> 24;
 8000c80:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8000c84:	0e1b      	lsrs	r3, r3, #24
 8000c86:	b2da      	uxtb	r2, r3
 8000c88:	4b4a      	ldr	r3, [pc, #296]	@ (8000db4 <fourthMessageSender+0x188>)
 8000c8a:	70da      	strb	r2, [r3, #3]
	memcpy(fourthMessage.Tid_one, thirdMessage.Tid_one, 4);
 8000c8c:	4b48      	ldr	r3, [pc, #288]	@ (8000db0 <fourthMessageSender+0x184>)
 8000c8e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8000c90:	4a48      	ldr	r2, [pc, #288]	@ (8000db4 <fourthMessageSender+0x188>)
 8000c92:	6053      	str	r3, [r2, #4]
	memcpy(fourthMessage.Tid_two, thirdMessage.Tid_two, 4);
 8000c94:	4b46      	ldr	r3, [pc, #280]	@ (8000db0 <fourthMessageSender+0x184>)
 8000c96:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000c98:	4a46      	ldr	r2, [pc, #280]	@ (8000db4 <fourthMessageSender+0x188>)
 8000c9a:	6093      	str	r3, [r2, #8]
	memcpy(fourthMessage.Tid_three, thirdMessage.Tid_three, 4);
 8000c9c:	4b44      	ldr	r3, [pc, #272]	@ (8000db0 <fourthMessageSender+0x184>)
 8000c9e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8000ca0:	4a44      	ldr	r2, [pc, #272]	@ (8000db4 <fourthMessageSender+0x188>)
 8000ca2:	60d3      	str	r3, [r2, #12]
	memcpy(fourthMessage.PC_id, thirdMessage.PC_id, 8);
 8000ca4:	4b43      	ldr	r3, [pc, #268]	@ (8000db4 <fourthMessageSender+0x188>)
 8000ca6:	4a42      	ldr	r2, [pc, #264]	@ (8000db0 <fourthMessageSender+0x184>)
 8000ca8:	3310      	adds	r3, #16
 8000caa:	3230      	adds	r2, #48	@ 0x30
 8000cac:	e892 0003 	ldmia.w	r2, {r0, r1}
 8000cb0:	e883 0003 	stmia.w	r3, {r0, r1}

	// este vygenerujme nonce
	uint8_t randomBytes[16];
	WC_RNG rng;
	if (wc_InitRng(&rng) != 0) {
 8000cb4:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000cb8:	4618      	mov	r0, r3
 8000cba:	f01e fc60 	bl	801f57e <wc_InitRng>
 8000cbe:	4603      	mov	r3, r0
 8000cc0:	2b00      	cmp	r3, #0
 8000cc2:	d16b      	bne.n	8000d9c <fourthMessageSender+0x170>
	    return;
	}
	if (wc_RNG_GenerateBlock(&rng, randomBytes, sizeof(randomBytes)) != 0) {
 8000cc4:	f507 61ac 	add.w	r1, r7, #1376	@ 0x560
 8000cc8:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000ccc:	2210      	movs	r2, #16
 8000cce:	4618      	mov	r0, r3
 8000cd0:	f01e fc67 	bl	801f5a2 <wc_RNG_GenerateBlock>
 8000cd4:	4603      	mov	r3, r0
 8000cd6:	2b00      	cmp	r3, #0
 8000cd8:	d005      	beq.n	8000ce6 <fourthMessageSender+0xba>
	    wc_FreeRng(&rng);
 8000cda:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000cde:	4618      	mov	r0, r3
 8000ce0:	f01e fd00 	bl	801f6e4 <wc_FreeRng>
	    return;
 8000ce4:	e05f      	b.n	8000da6 <fourthMessageSender+0x17a>
	}
	wc_FreeRng(&rng);
 8000ce6:	f507 63aa 	add.w	r3, r7, #1360	@ 0x550
 8000cea:	4618      	mov	r0, r3
 8000cec:	f01e fcfa 	bl	801f6e4 <wc_FreeRng>
	memcpy(fourthMessage.T_nonce, randomBytes, 16);
 8000cf0:	4b30      	ldr	r3, [pc, #192]	@ (8000db4 <fourthMessageSender+0x188>)
 8000cf2:	f103 0418 	add.w	r4, r3, #24
 8000cf6:	f507 63ac 	add.w	r3, r7, #1376	@ 0x560
 8000cfa:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000cfc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	// nasledne zasifrujme spravu cez sessionKey
	unsigned char paddedPlaintext[512] = {0};
 8000d00:	f507 63af 	add.w	r3, r7, #1400	@ 0x578
 8000d04:	f5a3 730a 	sub.w	r3, r3, #552	@ 0x228
 8000d08:	4618      	mov	r0, r3
 8000d0a:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000d0e:	461a      	mov	r2, r3
 8000d10:	2100      	movs	r1, #0
 8000d12:	f027 fbdd 	bl	80284d0 <memset>
	memcpy(paddedPlaintext, &fourthMessage, sizeof(fourthMessage));
 8000d16:	f507 63af 	add.w	r3, r7, #1400	@ 0x578
 8000d1a:	f5a3 730a 	sub.w	r3, r3, #552	@ 0x228
 8000d1e:	4a25      	ldr	r2, [pc, #148]	@ (8000db4 <fourthMessageSender+0x188>)
 8000d20:	461c      	mov	r4, r3
 8000d22:	4615      	mov	r5, r2
 8000d24:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d26:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d28:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d2a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d2c:	e895 0003 	ldmia.w	r5, {r0, r1}
 8000d30:	e884 0003 	stmia.w	r4, {r0, r1}
	Aes aes;
	int aesRet = wc_AesSetKey(&aes, thirdMessage.session_key, 16, thirdMessage.session_IV, AES_ENCRYPTION);
 8000d34:	f507 7001 	add.w	r0, r7, #516	@ 0x204
 8000d38:	2300      	movs	r3, #0
 8000d3a:	9300      	str	r3, [sp, #0]
 8000d3c:	4b1e      	ldr	r3, [pc, #120]	@ (8000db8 <fourthMessageSender+0x18c>)
 8000d3e:	2210      	movs	r2, #16
 8000d40:	491e      	ldr	r1, [pc, #120]	@ (8000dbc <fourthMessageSender+0x190>)
 8000d42:	f011 fb95 	bl	8012470 <wc_AesSetKey>
 8000d46:	f8c7 0570 	str.w	r0, [r7, #1392]	@ 0x570
	if (aesRet != 0) {
 8000d4a:	f8d7 3570 	ldr.w	r3, [r7, #1392]	@ 0x570
 8000d4e:	2b00      	cmp	r3, #0
 8000d50:	d126      	bne.n	8000da0 <fourthMessageSender+0x174>
	    return;
	}
	uint8_t encryptedPayload[512];
	aesRet = wc_AesCbcEncrypt(&aes, encryptedPayload, paddedPlaintext, 512);
 8000d52:	f507 7254 	add.w	r2, r7, #848	@ 0x350
 8000d56:	1d39      	adds	r1, r7, #4
 8000d58:	f507 7001 	add.w	r0, r7, #516	@ 0x204
 8000d5c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000d60:	f011 fbca 	bl	80124f8 <wc_AesCbcEncrypt>
 8000d64:	f8c7 0570 	str.w	r0, [r7, #1392]	@ 0x570
	if (aesRet != 0) {
 8000d68:	f8d7 3570 	ldr.w	r3, [r7, #1392]	@ 0x570
 8000d6c:	2b00      	cmp	r3, #0
 8000d6e:	d119      	bne.n	8000da4 <fourthMessageSender+0x178>
	    return;
	}

	// a potom vlozme ju do sendBuffer na odoslanie
	memcpy(sendBuffer, encryptedPayload, 512);
 8000d70:	4a13      	ldr	r2, [pc, #76]	@ (8000dc0 <fourthMessageSender+0x194>)
 8000d72:	f507 63af 	add.w	r3, r7, #1400	@ 0x578
 8000d76:	f2a3 5374 	subw	r3, r3, #1396	@ 0x574
 8000d7a:	4610      	mov	r0, r2
 8000d7c:	4619      	mov	r1, r3
 8000d7e:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000d82:	461a      	mov	r2, r3
 8000d84:	f027 fc0e 	bl	80285a4 <memcpy>
	sendCounter = 512;
 8000d88:	4b0e      	ldr	r3, [pc, #56]	@ (8000dc4 <fourthMessageSender+0x198>)
 8000d8a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8000d8e:	801a      	strh	r2, [r3, #0]
	wc_AesFree(&aes);
 8000d90:	f507 7301 	add.w	r3, r7, #516	@ 0x204
 8000d94:	4618      	mov	r0, r3
 8000d96:	f011 fc71 	bl	801267c <wc_AesFree>
	return;
 8000d9a:	e004      	b.n	8000da6 <fourthMessageSender+0x17a>
	    return;
 8000d9c:	bf00      	nop
 8000d9e:	e002      	b.n	8000da6 <fourthMessageSender+0x17a>
	    return;
 8000da0:	bf00      	nop
 8000da2:	e000      	b.n	8000da6 <fourthMessageSender+0x17a>
	    return;
 8000da4:	bf00      	nop
}
 8000da6:	f507 67af 	add.w	r7, r7, #1400	@ 0x578
 8000daa:	46bd      	mov	sp, r7
 8000dac:	bdb0      	pop	{r4, r5, r7, pc}
 8000dae:	bf00      	nop
 8000db0:	2000131c 	.word	0x2000131c
 8000db4:	20001354 	.word	0x20001354
 8000db8:	20001330 	.word	0x20001330
 8000dbc:	20001320 	.word	0x20001320
 8000dc0:	20001ce0 	.word	0x20001ce0
 8000dc4:	200026a4 	.word	0x200026a4

08000dc8 <fifthMessageHandler>:

void fifthMessageHandler(uint8_t* payload, uint8_t* sigHash) {
 8000dc8:	b590      	push	{r4, r7, lr}
 8000dca:	f2ad 4d04 	subw	sp, sp, #1028	@ 0x404
 8000dce:	af04      	add	r7, sp, #16
 8000dd0:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000dd4:	f5a3 737b 	sub.w	r3, r3, #1004	@ 0x3ec
 8000dd8:	6018      	str	r0, [r3, #0]
 8000dda:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000dde:	f5a3 737c 	sub.w	r3, r3, #1008	@ 0x3f0
 8000de2:	6019      	str	r1, [r3, #0]
	// AES desifrovanie payload a ulozenie do struktury
	Aes aes;
	int aesRet = wc_AesSetKey(&aes, thirdMessage.session_key, 16, thirdMessage.session_IV, AES_DECRYPTION);
 8000de4:	f507 7027 	add.w	r0, r7, #668	@ 0x29c
 8000de8:	2301      	movs	r3, #1
 8000dea:	9300      	str	r3, [sp, #0]
 8000dec:	4b62      	ldr	r3, [pc, #392]	@ (8000f78 <fifthMessageHandler+0x1b0>)
 8000dee:	2210      	movs	r2, #16
 8000df0:	4962      	ldr	r1, [pc, #392]	@ (8000f7c <fifthMessageHandler+0x1b4>)
 8000df2:	f011 fb3d 	bl	8012470 <wc_AesSetKey>
 8000df6:	f8c7 03ec 	str.w	r0, [r7, #1004]	@ 0x3ec
	if (aesRet != 0) {
 8000dfa:	f8d7 33ec 	ldr.w	r3, [r7, #1004]	@ 0x3ec
 8000dfe:	2b00      	cmp	r3, #0
 8000e00:	f040 80ac 	bne.w	8000f5c <fifthMessageHandler+0x194>
	    return;
	}
	uint8_t decryptedPayload[512];
	aesRet = wc_AesCbcDecrypt(&aes, decryptedPayload, payload, 512);
 8000e04:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e08:	f5a3 727b 	sub.w	r2, r3, #1004	@ 0x3ec
 8000e0c:	f107 019c 	add.w	r1, r7, #156	@ 0x9c
 8000e10:	f507 7027 	add.w	r0, r7, #668	@ 0x29c
 8000e14:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000e18:	6812      	ldr	r2, [r2, #0]
 8000e1a:	f011 fbb8 	bl	801258e <wc_AesCbcDecrypt>
 8000e1e:	f8c7 03ec 	str.w	r0, [r7, #1004]	@ 0x3ec
	if (aesRet != 0) {
 8000e22:	f8d7 33ec 	ldr.w	r3, [r7, #1004]	@ 0x3ec
 8000e26:	2b00      	cmp	r3, #0
 8000e28:	f040 809a 	bne.w	8000f60 <fifthMessageHandler+0x198>
	    return;
	}
	memcpy(fifthMessage.timestamp, &decryptedPayload[0], 4);
 8000e2c:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e30:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e34:	681b      	ldr	r3, [r3, #0]
 8000e36:	4a52      	ldr	r2, [pc, #328]	@ (8000f80 <fifthMessageHandler+0x1b8>)
 8000e38:	6013      	str	r3, [r2, #0]
	memcpy(fifthMessage.Tid_one, &decryptedPayload[4], 4);
 8000e3a:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e3e:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e42:	685b      	ldr	r3, [r3, #4]
 8000e44:	4a4e      	ldr	r2, [pc, #312]	@ (8000f80 <fifthMessageHandler+0x1b8>)
 8000e46:	6053      	str	r3, [r2, #4]
	memcpy(fifthMessage.Tid_two, &decryptedPayload[8], 4);
 8000e48:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e4c:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e50:	689b      	ldr	r3, [r3, #8]
 8000e52:	4a4b      	ldr	r2, [pc, #300]	@ (8000f80 <fifthMessageHandler+0x1b8>)
 8000e54:	6093      	str	r3, [r2, #8]
	memcpy(fifthMessage.Tid_three, &decryptedPayload[12], 4);
 8000e56:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e5a:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e5e:	68db      	ldr	r3, [r3, #12]
 8000e60:	4a47      	ldr	r2, [pc, #284]	@ (8000f80 <fifthMessageHandler+0x1b8>)
 8000e62:	60d3      	str	r3, [r2, #12]
	memcpy(fifthMessage.PC_id, &decryptedPayload[16], 8);
 8000e64:	4946      	ldr	r1, [pc, #280]	@ (8000f80 <fifthMessageHandler+0x1b8>)
 8000e66:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e6a:	f5a3 7255 	sub.w	r2, r3, #852	@ 0x354
 8000e6e:	f101 0310 	add.w	r3, r1, #16
 8000e72:	3210      	adds	r2, #16
 8000e74:	e892 0003 	ldmia.w	r2, {r0, r1}
 8000e78:	e883 0003 	stmia.w	r3, {r0, r1}
	memcpy(fifthMessage.T_nonce, &decryptedPayload[24], 16);
 8000e7c:	4a40      	ldr	r2, [pc, #256]	@ (8000f80 <fifthMessageHandler+0x1b8>)
 8000e7e:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000e82:	f5a3 7355 	sub.w	r3, r3, #852	@ 0x354
 8000e86:	f102 0418 	add.w	r4, r2, #24
 8000e8a:	3318      	adds	r3, #24
 8000e8c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8000e8e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	wc_AesFree(&aes);
 8000e92:	f507 7327 	add.w	r3, r7, #668	@ 0x29c
 8000e96:	4618      	mov	r0, r3
 8000e98:	f011 fbf0 	bl	801267c <wc_AesFree>

	// teraz vytvorme SHA256 hash z prijatej piatej spravy
	Sha256 sha;
	uint8_t genHash[SHA256_DIGEST_SIZE];
	int hashRet = wc_InitSha256(&sha);
 8000e9c:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8000ea0:	4618      	mov	r0, r3
 8000ea2:	f021 f8a7 	bl	8021ff4 <wc_InitSha256>
 8000ea6:	f8c7 03e8 	str.w	r0, [r7, #1000]	@ 0x3e8
	hashRet = wc_Sha256Update(&sha, (const uint8_t*)&fifthMessage, sizeof(MessageFive));
 8000eaa:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8000eae:	2228      	movs	r2, #40	@ 0x28
 8000eb0:	4933      	ldr	r1, [pc, #204]	@ (8000f80 <fifthMessageHandler+0x1b8>)
 8000eb2:	4618      	mov	r0, r3
 8000eb4:	f020 ffd5 	bl	8021e62 <wc_Sha256Update>
 8000eb8:	f8c7 03e8 	str.w	r0, [r7, #1000]	@ 0x3e8
	hashRet = wc_Sha256Final(&sha, genHash);
 8000ebc:	f107 020c 	add.w	r2, r7, #12
 8000ec0:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8000ec4:	4611      	mov	r1, r2
 8000ec6:	4618      	mov	r0, r3
 8000ec8:	f021 f869 	bl	8021f9e <wc_Sha256Final>
 8000ecc:	f8c7 03e8 	str.w	r0, [r7, #1000]	@ 0x3e8

	// kontrolujme token id, PC id a nonce ci su rovnake
	if(memcmp(fifthMessage.Tid_one, fourthMessage.Tid_one, sizeof(fourthMessage.Tid_one)) != 0 ||
 8000ed0:	2204      	movs	r2, #4
 8000ed2:	492c      	ldr	r1, [pc, #176]	@ (8000f84 <fifthMessageHandler+0x1bc>)
 8000ed4:	482c      	ldr	r0, [pc, #176]	@ (8000f88 <fifthMessageHandler+0x1c0>)
 8000ed6:	f027 fad1 	bl	802847c <memcmp>
 8000eda:	4603      	mov	r3, r0
 8000edc:	2b00      	cmp	r3, #0
 8000ede:	d141      	bne.n	8000f64 <fifthMessageHandler+0x19c>
			memcmp(fifthMessage.Tid_two, fourthMessage.Tid_two, sizeof(fourthMessage.Tid_two)) != 0 ||
 8000ee0:	2204      	movs	r2, #4
 8000ee2:	492a      	ldr	r1, [pc, #168]	@ (8000f8c <fifthMessageHandler+0x1c4>)
 8000ee4:	482a      	ldr	r0, [pc, #168]	@ (8000f90 <fifthMessageHandler+0x1c8>)
 8000ee6:	f027 fac9 	bl	802847c <memcmp>
 8000eea:	4603      	mov	r3, r0
	if(memcmp(fifthMessage.Tid_one, fourthMessage.Tid_one, sizeof(fourthMessage.Tid_one)) != 0 ||
 8000eec:	2b00      	cmp	r3, #0
 8000eee:	d139      	bne.n	8000f64 <fifthMessageHandler+0x19c>
					memcmp(fifthMessage.Tid_three, fourthMessage.Tid_three, sizeof(fourthMessage.Tid_three)) != 0) {
 8000ef0:	2204      	movs	r2, #4
 8000ef2:	4928      	ldr	r1, [pc, #160]	@ (8000f94 <fifthMessageHandler+0x1cc>)
 8000ef4:	4828      	ldr	r0, [pc, #160]	@ (8000f98 <fifthMessageHandler+0x1d0>)
 8000ef6:	f027 fac1 	bl	802847c <memcmp>
 8000efa:	4603      	mov	r3, r0
			memcmp(fifthMessage.Tid_two, fourthMessage.Tid_two, sizeof(fourthMessage.Tid_two)) != 0 ||
 8000efc:	2b00      	cmp	r3, #0
 8000efe:	d131      	bne.n	8000f64 <fifthMessageHandler+0x19c>
		return;
	}
	if(memcmp(fifthMessage.PC_id, fourthMessage.PC_id, sizeof(fourthMessage.PC_id)) != 0) {
 8000f00:	2208      	movs	r2, #8
 8000f02:	4926      	ldr	r1, [pc, #152]	@ (8000f9c <fifthMessageHandler+0x1d4>)
 8000f04:	4826      	ldr	r0, [pc, #152]	@ (8000fa0 <fifthMessageHandler+0x1d8>)
 8000f06:	f027 fab9 	bl	802847c <memcmp>
 8000f0a:	4603      	mov	r3, r0
 8000f0c:	2b00      	cmp	r3, #0
 8000f0e:	d12b      	bne.n	8000f68 <fifthMessageHandler+0x1a0>
	    return;
	}
	if(memcmp(fifthMessage.T_nonce, fourthMessage.T_nonce, sizeof(fourthMessage.T_nonce)) != 0) {
 8000f10:	2210      	movs	r2, #16
 8000f12:	4924      	ldr	r1, [pc, #144]	@ (8000fa4 <fifthMessageHandler+0x1dc>)
 8000f14:	4824      	ldr	r0, [pc, #144]	@ (8000fa8 <fifthMessageHandler+0x1e0>)
 8000f16:	f027 fab1 	bl	802847c <memcmp>
 8000f1a:	4603      	mov	r3, r0
 8000f1c:	2b00      	cmp	r3, #0
 8000f1e:	d125      	bne.n	8000f6c <fifthMessageHandler+0x1a4>
		    return;
	}

	// ak ano, tak overme este, ci prijaty podpisany hash je podpisany vypoctovym zariadenim
	// teda pouzije sa vygenerovany hash a verejny kluc zariadenia na porovnanie s prijatym podpisanym hashom
	hashRet = wc_SignatureVerifyHash(
 8000f20:	f107 020c 	add.w	r2, r7, #12
 8000f24:	f241 137c 	movw	r3, #4476	@ 0x117c
 8000f28:	9303      	str	r3, [sp, #12]
 8000f2a:	4b20      	ldr	r3, [pc, #128]	@ (8000fac <fifthMessageHandler+0x1e4>)
 8000f2c:	9302      	str	r3, [sp, #8]
 8000f2e:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000f32:	9301      	str	r3, [sp, #4]
 8000f34:	f507 737c 	add.w	r3, r7, #1008	@ 0x3f0
 8000f38:	f5a3 737c 	sub.w	r3, r3, #1008	@ 0x3f0
 8000f3c:	681b      	ldr	r3, [r3, #0]
 8000f3e:	9300      	str	r3, [sp, #0]
 8000f40:	2320      	movs	r3, #32
 8000f42:	2102      	movs	r1, #2
 8000f44:	2006      	movs	r0, #6
 8000f46:	f021 f8a8 	bl	802209a <wc_SignatureVerifyHash>
 8000f4a:	f8c7 03e8 	str.w	r0, [r7, #1000]	@ 0x3e8
			WC_SIGNATURE_TYPE_RSA, 		// typ podpisu RSA
			genHash, 32, 				// hash vytvoreny z prijatych dat
			sigHash, 256, 				// hash co podpisalo zariadenie
			&pubKey, sizeof(RsaKey)		// verejny kluc zariadenia
				);
	if(hashRet == 0) {
 8000f4e:	f8d7 33e8 	ldr.w	r3, [r7, #1000]	@ 0x3e8
 8000f52:	2b00      	cmp	r3, #0
 8000f54:	d10b      	bne.n	8000f6e <fifthMessageHandler+0x1a6>
		sixthMessageSender();
 8000f56:	f000 f82b 	bl	8000fb0 <sixthMessageSender>
 8000f5a:	e008      	b.n	8000f6e <fifthMessageHandler+0x1a6>
	    return;
 8000f5c:	bf00      	nop
 8000f5e:	e006      	b.n	8000f6e <fifthMessageHandler+0x1a6>
	    return;
 8000f60:	bf00      	nop
 8000f62:	e004      	b.n	8000f6e <fifthMessageHandler+0x1a6>
		return;
 8000f64:	bf00      	nop
 8000f66:	e002      	b.n	8000f6e <fifthMessageHandler+0x1a6>
	    return;
 8000f68:	bf00      	nop
 8000f6a:	e000      	b.n	8000f6e <fifthMessageHandler+0x1a6>
		    return;
 8000f6c:	bf00      	nop
	}
}
 8000f6e:	f507 777d 	add.w	r7, r7, #1012	@ 0x3f4
 8000f72:	46bd      	mov	sp, r7
 8000f74:	bd90      	pop	{r4, r7, pc}
 8000f76:	bf00      	nop
 8000f78:	20001330 	.word	0x20001330
 8000f7c:	20001320 	.word	0x20001320
 8000f80:	2000137c 	.word	0x2000137c
 8000f84:	20001358 	.word	0x20001358
 8000f88:	20001380 	.word	0x20001380
 8000f8c:	2000135c 	.word	0x2000135c
 8000f90:	20001384 	.word	0x20001384
 8000f94:	20001360 	.word	0x20001360
 8000f98:	20001388 	.word	0x20001388
 8000f9c:	20001364 	.word	0x20001364
 8000fa0:	2000138c 	.word	0x2000138c
 8000fa4:	2000136c 	.word	0x2000136c
 8000fa8:	20001394 	.word	0x20001394
 8000fac:	200001a0 	.word	0x200001a0

08000fb0 <sixthMessageSender>:

void sixthMessageSender() {
 8000fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000fb2:	f2ad 5d8c 	subw	sp, sp, #1420	@ 0x58c
 8000fb6:	af02      	add	r7, sp, #8
	// inkrementujme timestamp o 1
	uint32_t timestamp = (fifthMessage.timestamp[3] << 24) | (fifthMessage.timestamp[2] << 16) |
 8000fb8:	4b76      	ldr	r3, [pc, #472]	@ (8001194 <sixthMessageSender+0x1e4>)
 8000fba:	78db      	ldrb	r3, [r3, #3]
 8000fbc:	061a      	lsls	r2, r3, #24
 8000fbe:	4b75      	ldr	r3, [pc, #468]	@ (8001194 <sixthMessageSender+0x1e4>)
 8000fc0:	789b      	ldrb	r3, [r3, #2]
 8000fc2:	041b      	lsls	r3, r3, #16
 8000fc4:	431a      	orrs	r2, r3
		     ( fifthMessage.timestamp[1] << 8 ) | (fifthMessage.timestamp[0]);
 8000fc6:	4b73      	ldr	r3, [pc, #460]	@ (8001194 <sixthMessageSender+0x1e4>)
 8000fc8:	785b      	ldrb	r3, [r3, #1]
 8000fca:	021b      	lsls	r3, r3, #8
	uint32_t timestamp = (fifthMessage.timestamp[3] << 24) | (fifthMessage.timestamp[2] << 16) |
 8000fcc:	4313      	orrs	r3, r2
		     ( fifthMessage.timestamp[1] << 8 ) | (fifthMessage.timestamp[0]);
 8000fce:	4a71      	ldr	r2, [pc, #452]	@ (8001194 <sixthMessageSender+0x1e4>)
 8000fd0:	7812      	ldrb	r2, [r2, #0]
 8000fd2:	4313      	orrs	r3, r2
	uint32_t timestamp = (fifthMessage.timestamp[3] << 24) | (fifthMessage.timestamp[2] << 16) |
 8000fd4:	f8c7 357c 	str.w	r3, [r7, #1404]	@ 0x57c
	timestamp += 1;
 8000fd8:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8000fdc:	3301      	adds	r3, #1
 8000fde:	f8c7 357c 	str.w	r3, [r7, #1404]	@ 0x57c

	// pripravme si takmer celu siestu spravu podla struktury MessageSix
	sixthMessage.timestamp[0] = (timestamp & 0x000000ff);
 8000fe2:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8000fe6:	b2da      	uxtb	r2, r3
 8000fe8:	4b6b      	ldr	r3, [pc, #428]	@ (8001198 <sixthMessageSender+0x1e8>)
 8000fea:	701a      	strb	r2, [r3, #0]
	sixthMessage.timestamp[1] = (timestamp & 0x0000ff00) >> 8;
 8000fec:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8000ff0:	0a1b      	lsrs	r3, r3, #8
 8000ff2:	b2da      	uxtb	r2, r3
 8000ff4:	4b68      	ldr	r3, [pc, #416]	@ (8001198 <sixthMessageSender+0x1e8>)
 8000ff6:	705a      	strb	r2, [r3, #1]
	sixthMessage.timestamp[2] = (timestamp & 0x00ff0000) >> 16;
 8000ff8:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8000ffc:	0c1b      	lsrs	r3, r3, #16
 8000ffe:	b2da      	uxtb	r2, r3
 8001000:	4b65      	ldr	r3, [pc, #404]	@ (8001198 <sixthMessageSender+0x1e8>)
 8001002:	709a      	strb	r2, [r3, #2]
	sixthMessage.timestamp[3] = (timestamp & 0xff000000) >> 24;
 8001004:	f8d7 357c 	ldr.w	r3, [r7, #1404]	@ 0x57c
 8001008:	0e1b      	lsrs	r3, r3, #24
 800100a:	b2da      	uxtb	r2, r3
 800100c:	4b62      	ldr	r3, [pc, #392]	@ (8001198 <sixthMessageSender+0x1e8>)
 800100e:	70da      	strb	r2, [r3, #3]
	memcpy(sixthMessage.Tid_one, fifthMessage.Tid_one, 4);
 8001010:	4b60      	ldr	r3, [pc, #384]	@ (8001194 <sixthMessageSender+0x1e4>)
 8001012:	685b      	ldr	r3, [r3, #4]
 8001014:	4a60      	ldr	r2, [pc, #384]	@ (8001198 <sixthMessageSender+0x1e8>)
 8001016:	6053      	str	r3, [r2, #4]
	memcpy(sixthMessage.Tid_two, fifthMessage.Tid_two, 4);
 8001018:	4b5e      	ldr	r3, [pc, #376]	@ (8001194 <sixthMessageSender+0x1e4>)
 800101a:	689b      	ldr	r3, [r3, #8]
 800101c:	4a5e      	ldr	r2, [pc, #376]	@ (8001198 <sixthMessageSender+0x1e8>)
 800101e:	6093      	str	r3, [r2, #8]
	memcpy(sixthMessage.Tid_three, fifthMessage.Tid_three, 4);
 8001020:	4b5c      	ldr	r3, [pc, #368]	@ (8001194 <sixthMessageSender+0x1e4>)
 8001022:	68db      	ldr	r3, [r3, #12]
 8001024:	4a5c      	ldr	r2, [pc, #368]	@ (8001198 <sixthMessageSender+0x1e8>)
 8001026:	60d3      	str	r3, [r2, #12]
	memcpy(sixthMessage.PC_id, fifthMessage.PC_id, 8);
 8001028:	4b5b      	ldr	r3, [pc, #364]	@ (8001198 <sixthMessageSender+0x1e8>)
 800102a:	4a5a      	ldr	r2, [pc, #360]	@ (8001194 <sixthMessageSender+0x1e4>)
 800102c:	3310      	adds	r3, #16
 800102e:	3210      	adds	r2, #16
 8001030:	e892 0003 	ldmia.w	r2, {r0, r1}
 8001034:	e883 0003 	stmia.w	r3, {r0, r1}

	// treba este vlozit druhu cast hlavneho kluca, na tu vsak potrebujeme interakciu s tlacidlom na tokene
	GPIO_InitTypeDef gpioLed = {0};
 8001038:	f507 63ac 	add.w	r3, r7, #1376	@ 0x560
 800103c:	2200      	movs	r2, #0
 800103e:	601a      	str	r2, [r3, #0]
 8001040:	605a      	str	r2, [r3, #4]
 8001042:	609a      	str	r2, [r3, #8]
 8001044:	60da      	str	r2, [r3, #12]
 8001046:	611a      	str	r2, [r3, #16]
	gpioLed.Pin = GPIO_PIN_12;
 8001048:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 800104c:	f8c7 3560 	str.w	r3, [r7, #1376]	@ 0x560
	gpioLed.Mode = GPIO_MODE_OUTPUT_PP;
 8001050:	2301      	movs	r3, #1
 8001052:	f8c7 3564 	str.w	r3, [r7, #1380]	@ 0x564
	gpioLed.Pull = GPIO_NOPULL;
 8001056:	2300      	movs	r3, #0
 8001058:	f8c7 3568 	str.w	r3, [r7, #1384]	@ 0x568
	gpioLed.Speed = GPIO_SPEED_FREQ_LOW;
 800105c:	2300      	movs	r3, #0
 800105e:	f8c7 356c 	str.w	r3, [r7, #1388]	@ 0x56c
	HAL_GPIO_Init(GPIOD, &gpioLed);
 8001062:	f507 63ac 	add.w	r3, r7, #1376	@ 0x560
 8001066:	4619      	mov	r1, r3
 8001068:	484c      	ldr	r0, [pc, #304]	@ (800119c <sixthMessageSender+0x1ec>)
 800106a:	f000 ffff 	bl	800206c <HAL_GPIO_Init>

	GPIO_InitTypeDef gpioBtn = {0};
 800106e:	f207 534c 	addw	r3, r7, #1356	@ 0x54c
 8001072:	2200      	movs	r2, #0
 8001074:	601a      	str	r2, [r3, #0]
 8001076:	605a      	str	r2, [r3, #4]
 8001078:	609a      	str	r2, [r3, #8]
 800107a:	60da      	str	r2, [r3, #12]
 800107c:	611a      	str	r2, [r3, #16]
	gpioBtn.Pin = GPIO_PIN_0;
 800107e:	2301      	movs	r3, #1
 8001080:	f8c7 354c 	str.w	r3, [r7, #1356]	@ 0x54c
	gpioBtn.Mode = GPIO_MODE_INPUT;
 8001084:	2300      	movs	r3, #0
 8001086:	f8c7 3550 	str.w	r3, [r7, #1360]	@ 0x550
	gpioBtn.Pull = GPIO_NOPULL;
 800108a:	2300      	movs	r3, #0
 800108c:	f8c7 3554 	str.w	r3, [r7, #1364]	@ 0x554
	HAL_GPIO_Init(GPIOA, &gpioBtn);
 8001090:	f207 534c 	addw	r3, r7, #1356	@ 0x54c
 8001094:	4619      	mov	r1, r3
 8001096:	4842      	ldr	r0, [pc, #264]	@ (80011a0 <sixthMessageSender+0x1f0>)
 8001098:	f000 ffe8 	bl	800206c <HAL_GPIO_Init>

	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
 800109c:	2201      	movs	r2, #1
 800109e:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 80010a2:	483e      	ldr	r0, [pc, #248]	@ (800119c <sixthMessageSender+0x1ec>)
 80010a4:	f001 f996 	bl	80023d4 <HAL_GPIO_WritePin>
	while (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET) {
 80010a8:	bf00      	nop
 80010aa:	2101      	movs	r1, #1
 80010ac:	483c      	ldr	r0, [pc, #240]	@ (80011a0 <sixthMessageSender+0x1f0>)
 80010ae:	f001 f979 	bl	80023a4 <HAL_GPIO_ReadPin>
 80010b2:	4603      	mov	r3, r0
 80010b4:	2b00      	cmp	r3, #0
 80010b6:	d0f8      	beq.n	80010aa <sixthMessageSender+0xfa>
	    // cakame kym sa stlaci tlacidlo
	}
	const char *predefinedHash = "3d9cf246585e2e116a9a4407ebd7d8dffea0dfa934a515dbe5cd6657aac7c222";
 80010b8:	4b3a      	ldr	r3, [pc, #232]	@ (80011a4 <sixthMessageSender+0x1f4>)
 80010ba:	f8c7 3578 	str.w	r3, [r7, #1400]	@ 0x578
	memcpy(sixthMessage.key, predefinedHash, 64);
 80010be:	4b36      	ldr	r3, [pc, #216]	@ (8001198 <sixthMessageSender+0x1e8>)
 80010c0:	f8d7 2578 	ldr.w	r2, [r7, #1400]	@ 0x578
 80010c4:	4614      	mov	r4, r2
 80010c6:	f103 0618 	add.w	r6, r3, #24
 80010ca:	f104 0c40 	add.w	ip, r4, #64	@ 0x40
 80010ce:	4635      	mov	r5, r6
 80010d0:	4623      	mov	r3, r4
 80010d2:	6818      	ldr	r0, [r3, #0]
 80010d4:	6859      	ldr	r1, [r3, #4]
 80010d6:	689a      	ldr	r2, [r3, #8]
 80010d8:	68db      	ldr	r3, [r3, #12]
 80010da:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80010dc:	3410      	adds	r4, #16
 80010de:	3610      	adds	r6, #16
 80010e0:	4564      	cmp	r4, ip
 80010e2:	d1f4      	bne.n	80010ce <sixthMessageSender+0x11e>
	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);
 80010e4:	2200      	movs	r2, #0
 80010e6:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 80010ea:	482c      	ldr	r0, [pc, #176]	@ (800119c <sixthMessageSender+0x1ec>)
 80010ec:	f001 f972 	bl	80023d4 <HAL_GPIO_WritePin>

	// nasledne zasifrujme celu spravu cez sessionKey
	unsigned char paddedPlaintext[512] = {0};
 80010f0:	f507 63b0 	add.w	r3, r7, #1408	@ 0x580
 80010f4:	f5a3 730d 	sub.w	r3, r3, #564	@ 0x234
 80010f8:	4618      	mov	r0, r3
 80010fa:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80010fe:	461a      	mov	r2, r3
 8001100:	2100      	movs	r1, #0
 8001102:	f027 f9e5 	bl	80284d0 <memset>
	memcpy(paddedPlaintext, &sixthMessage, sizeof(sixthMessage));
 8001106:	f507 63b0 	add.w	r3, r7, #1408	@ 0x580
 800110a:	f5a3 730d 	sub.w	r3, r3, #564	@ 0x234
 800110e:	4a22      	ldr	r2, [pc, #136]	@ (8001198 <sixthMessageSender+0x1e8>)
 8001110:	4618      	mov	r0, r3
 8001112:	4611      	mov	r1, r2
 8001114:	2358      	movs	r3, #88	@ 0x58
 8001116:	461a      	mov	r2, r3
 8001118:	f027 fa44 	bl	80285a4 <memcpy>
	Aes aes;
	int aesRet = wc_AesSetKey(&aes, thirdMessage.session_key, 16, thirdMessage.session_IV, AES_ENCRYPTION);
 800111c:	f507 7000 	add.w	r0, r7, #512	@ 0x200
 8001120:	2300      	movs	r3, #0
 8001122:	9300      	str	r3, [sp, #0]
 8001124:	4b20      	ldr	r3, [pc, #128]	@ (80011a8 <sixthMessageSender+0x1f8>)
 8001126:	2210      	movs	r2, #16
 8001128:	4920      	ldr	r1, [pc, #128]	@ (80011ac <sixthMessageSender+0x1fc>)
 800112a:	f011 f9a1 	bl	8012470 <wc_AesSetKey>
 800112e:	f8c7 0574 	str.w	r0, [r7, #1396]	@ 0x574
	if (aesRet != 0) {
 8001132:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8001136:	2b00      	cmp	r3, #0
 8001138:	d124      	bne.n	8001184 <sixthMessageSender+0x1d4>
		return;
	}
	uint8_t encryptedPayload[512];
	aesRet = wc_AesCbcEncrypt(&aes, encryptedPayload, paddedPlaintext, 512);
 800113a:	f507 7253 	add.w	r2, r7, #844	@ 0x34c
 800113e:	4639      	mov	r1, r7
 8001140:	f507 7000 	add.w	r0, r7, #512	@ 0x200
 8001144:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8001148:	f011 f9d6 	bl	80124f8 <wc_AesCbcEncrypt>
 800114c:	f8c7 0574 	str.w	r0, [r7, #1396]	@ 0x574
	if (aesRet != 0) {
 8001150:	f8d7 3574 	ldr.w	r3, [r7, #1396]	@ 0x574
 8001154:	2b00      	cmp	r3, #0
 8001156:	d117      	bne.n	8001188 <sixthMessageSender+0x1d8>
		return;
	}

	// a potom vlozme ju do sendBuffer na odoslanie
	memcpy(sendBuffer, encryptedPayload, 512);
 8001158:	4a15      	ldr	r2, [pc, #84]	@ (80011b0 <sixthMessageSender+0x200>)
 800115a:	f507 63b0 	add.w	r3, r7, #1408	@ 0x580
 800115e:	f5a3 63b0 	sub.w	r3, r3, #1408	@ 0x580
 8001162:	4610      	mov	r0, r2
 8001164:	4619      	mov	r1, r3
 8001166:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800116a:	461a      	mov	r2, r3
 800116c:	f027 fa1a 	bl	80285a4 <memcpy>
	sendCounter = 512;
 8001170:	4b10      	ldr	r3, [pc, #64]	@ (80011b4 <sixthMessageSender+0x204>)
 8001172:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8001176:	801a      	strh	r2, [r3, #0]
	wc_AesFree(&aes);
 8001178:	f507 7300 	add.w	r3, r7, #512	@ 0x200
 800117c:	4618      	mov	r0, r3
 800117e:	f011 fa7d 	bl	801267c <wc_AesFree>
	return;
 8001182:	e002      	b.n	800118a <sixthMessageSender+0x1da>
		return;
 8001184:	bf00      	nop
 8001186:	e000      	b.n	800118a <sixthMessageSender+0x1da>
		return;
 8001188:	bf00      	nop
}
 800118a:	f207 5784 	addw	r7, r7, #1412	@ 0x584
 800118e:	46bd      	mov	sp, r7
 8001190:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001192:	bf00      	nop
 8001194:	2000137c 	.word	0x2000137c
 8001198:	200013a4 	.word	0x200013a4
 800119c:	40020c00 	.word	0x40020c00
 80011a0:	40020000 	.word	0x40020000
 80011a4:	08028c44 	.word	0x08028c44
 80011a8:	20001330 	.word	0x20001330
 80011ac:	20001320 	.word	0x20001320
 80011b0:	20001ce0 	.word	0x20001ce0
 80011b4:	200026a4 	.word	0x200026a4

080011b8 <transmitBuffer>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

void transmitBuffer(uint8_t *data, uint16_t length) {
 80011b8:	b580      	push	{r7, lr}
 80011ba:	b084      	sub	sp, #16
 80011bc:	af00      	add	r7, sp, #0
 80011be:	6078      	str	r0, [r7, #4]
 80011c0:	460b      	mov	r3, r1
 80011c2:	807b      	strh	r3, [r7, #2]
	// cely sendBuffer sa rozkuskuje na 64 bytove pakety ktore CDC_Transmit_FS vie preniest seriovo
	// Middlewares/ST/STM32_USB_Device_Library/Core/Inc/usbd_def.h
	// riadok 156 - #define USB_FS_MAX_PACKET_SIZE 64U - paket ma max velkost 64 bytov na transmit
    uint16_t sent = 0;
 80011c4:	2300      	movs	r3, #0
 80011c6:	81fb      	strh	r3, [r7, #14]
    while (sent < length) {
 80011c8:	e016      	b.n	80011f8 <transmitBuffer+0x40>
    	uint16_t chunk = (length - sent > 64) ? 64 : (length - sent);
 80011ca:	887a      	ldrh	r2, [r7, #2]
 80011cc:	89fb      	ldrh	r3, [r7, #14]
 80011ce:	1ad3      	subs	r3, r2, r3
 80011d0:	2b40      	cmp	r3, #64	@ 0x40
 80011d2:	bfa8      	it	ge
 80011d4:	2340      	movge	r3, #64	@ 0x40
 80011d6:	81bb      	strh	r3, [r7, #12]
    	while (CDC_Transmit_FS(data + sent, chunk) == USBD_BUSY) {
 80011d8:	bf00      	nop
 80011da:	89fb      	ldrh	r3, [r7, #14]
 80011dc:	687a      	ldr	r2, [r7, #4]
 80011de:	4413      	add	r3, r2
 80011e0:	89ba      	ldrh	r2, [r7, #12]
 80011e2:	4611      	mov	r1, r2
 80011e4:	4618      	mov	r0, r3
 80011e6:	f026 fbbd 	bl	8027964 <CDC_Transmit_FS>
 80011ea:	4603      	mov	r3, r0
 80011ec:	2b01      	cmp	r3, #1
 80011ee:	d0f4      	beq.n	80011da <transmitBuffer+0x22>
    		// cakame kym sa skonci prenos paketu
    	}
    	sent += chunk;
 80011f0:	89fa      	ldrh	r2, [r7, #14]
 80011f2:	89bb      	ldrh	r3, [r7, #12]
 80011f4:	4413      	add	r3, r2
 80011f6:	81fb      	strh	r3, [r7, #14]
    while (sent < length) {
 80011f8:	89fa      	ldrh	r2, [r7, #14]
 80011fa:	887b      	ldrh	r3, [r7, #2]
 80011fc:	429a      	cmp	r2, r3
 80011fe:	d3e4      	bcc.n	80011ca <transmitBuffer+0x12>
    }
}
 8001200:	bf00      	nop
 8001202:	bf00      	nop
 8001204:	3710      	adds	r7, #16
 8001206:	46bd      	mov	sp, r7
 8001208:	bd80      	pop	{r7, pc}
	...

0800120c <USBReceiveHandler>:

void USBReceiveHandler() {
 800120c:	b580      	push	{r7, lr}
 800120e:	b08a      	sub	sp, #40	@ 0x28
 8001210:	af02      	add	r7, sp, #8
	if (messageCounter == 1) {
 8001212:	4b54      	ldr	r3, [pc, #336]	@ (8001364 <USBReceiveHandler+0x158>)
 8001214:	781b      	ldrb	r3, [r3, #0]
 8001216:	2b01      	cmp	r3, #1
 8001218:	d112      	bne.n	8001240 <USBReceiveHandler+0x34>
		uint8_t* receivedChars = malloc(4);
 800121a:	2004      	movs	r0, #4
 800121c:	f027 f80c 	bl	8028238 <malloc>
 8001220:	4603      	mov	r3, r0
 8001222:	603b      	str	r3, [r7, #0]
		memcpy(receivedChars, &receiveBuffer[0], 4);
 8001224:	4b50      	ldr	r3, [pc, #320]	@ (8001368 <USBReceiveHandler+0x15c>)
 8001226:	681a      	ldr	r2, [r3, #0]
 8001228:	683b      	ldr	r3, [r7, #0]
 800122a:	601a      	str	r2, [r3, #0]
		firstMessageHandler(receivedChars);
 800122c:	6838      	ldr	r0, [r7, #0]
 800122e:	f7ff f9cd 	bl	80005cc <firstMessageHandler>
		free(receivedChars);
 8001232:	6838      	ldr	r0, [r7, #0]
 8001234:	f027 f808 	bl	8028248 <free>
		messageCounter = 3;
 8001238:	4b4a      	ldr	r3, [pc, #296]	@ (8001364 <USBReceiveHandler+0x158>)
 800123a:	2203      	movs	r2, #3
 800123c:	701a      	strb	r2, [r3, #0]
 800123e:	e075      	b.n	800132c <USBReceiveHandler+0x120>
	} else if (messageCounter == 3) {
 8001240:	4b48      	ldr	r3, [pc, #288]	@ (8001364 <USBReceiveHandler+0x158>)
 8001242:	781b      	ldrb	r3, [r3, #0]
 8001244:	2b03      	cmp	r3, #3
 8001246:	d14c      	bne.n	80012e2 <USBReceiveHandler+0xd6>
		uint8_t* encryptedKey = malloc(256);
 8001248:	f44f 7080 	mov.w	r0, #256	@ 0x100
 800124c:	f026 fff4 	bl	8028238 <malloc>
 8001250:	4603      	mov	r3, r0
 8001252:	617b      	str	r3, [r7, #20]
		uint8_t* encryptedIV = malloc(256);
 8001254:	f44f 7080 	mov.w	r0, #256	@ 0x100
 8001258:	f026 ffee 	bl	8028238 <malloc>
 800125c:	4603      	mov	r3, r0
 800125e:	613b      	str	r3, [r7, #16]
		uint8_t* payload = malloc(512);
 8001260:	f44f 7000 	mov.w	r0, #512	@ 0x200
 8001264:	f026 ffe8 	bl	8028238 <malloc>
 8001268:	4603      	mov	r3, r0
 800126a:	60fb      	str	r3, [r7, #12]
		uint16_t deviceCertLen = receiveCounter - 1024;
 800126c:	4b3f      	ldr	r3, [pc, #252]	@ (800136c <USBReceiveHandler+0x160>)
 800126e:	881b      	ldrh	r3, [r3, #0]
 8001270:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
 8001274:	817b      	strh	r3, [r7, #10]
		uint8_t* deviceCertBuffer = malloc(deviceCertLen);
 8001276:	897b      	ldrh	r3, [r7, #10]
 8001278:	4618      	mov	r0, r3
 800127a:	f026 ffdd 	bl	8028238 <malloc>
 800127e:	4603      	mov	r3, r0
 8001280:	607b      	str	r3, [r7, #4]
		memcpy(encryptedKey, &receiveBuffer[0], 256);
 8001282:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001286:	4938      	ldr	r1, [pc, #224]	@ (8001368 <USBReceiveHandler+0x15c>)
 8001288:	6978      	ldr	r0, [r7, #20]
 800128a:	f027 f98b 	bl	80285a4 <memcpy>
		memcpy(encryptedIV, &receiveBuffer[256], 256);
 800128e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001292:	4937      	ldr	r1, [pc, #220]	@ (8001370 <USBReceiveHandler+0x164>)
 8001294:	6938      	ldr	r0, [r7, #16]
 8001296:	f027 f985 	bl	80285a4 <memcpy>
		memcpy(payload, &receiveBuffer[512], 512);
 800129a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800129e:	4935      	ldr	r1, [pc, #212]	@ (8001374 <USBReceiveHandler+0x168>)
 80012a0:	68f8      	ldr	r0, [r7, #12]
 80012a2:	f027 f97f 	bl	80285a4 <memcpy>
		memcpy(deviceCertBuffer, &receiveBuffer[1024], deviceCertLen);
 80012a6:	897b      	ldrh	r3, [r7, #10]
 80012a8:	461a      	mov	r2, r3
 80012aa:	4933      	ldr	r1, [pc, #204]	@ (8001378 <USBReceiveHandler+0x16c>)
 80012ac:	6878      	ldr	r0, [r7, #4]
 80012ae:	f027 f979 	bl	80285a4 <memcpy>
		thirdMessageHandler(encryptedKey, encryptedIV, payload, deviceCertBuffer, deviceCertLen);
 80012b2:	897b      	ldrh	r3, [r7, #10]
 80012b4:	9300      	str	r3, [sp, #0]
 80012b6:	687b      	ldr	r3, [r7, #4]
 80012b8:	68fa      	ldr	r2, [r7, #12]
 80012ba:	6939      	ldr	r1, [r7, #16]
 80012bc:	6978      	ldr	r0, [r7, #20]
 80012be:	f7ff fa57 	bl	8000770 <thirdMessageHandler>
		free(encryptedKey);
 80012c2:	6978      	ldr	r0, [r7, #20]
 80012c4:	f026 ffc0 	bl	8028248 <free>
		free(encryptedIV);
 80012c8:	6938      	ldr	r0, [r7, #16]
 80012ca:	f026 ffbd 	bl	8028248 <free>
		free(payload);
 80012ce:	68f8      	ldr	r0, [r7, #12]
 80012d0:	f026 ffba 	bl	8028248 <free>
		free(deviceCertBuffer);
 80012d4:	6878      	ldr	r0, [r7, #4]
 80012d6:	f026 ffb7 	bl	8028248 <free>
		messageCounter = 5;
 80012da:	4b22      	ldr	r3, [pc, #136]	@ (8001364 <USBReceiveHandler+0x158>)
 80012dc:	2205      	movs	r2, #5
 80012de:	701a      	strb	r2, [r3, #0]
 80012e0:	e024      	b.n	800132c <USBReceiveHandler+0x120>
	} else {
		uint8_t* payload = malloc(512);
 80012e2:	f44f 7000 	mov.w	r0, #512	@ 0x200
 80012e6:	f026 ffa7 	bl	8028238 <malloc>
 80012ea:	4603      	mov	r3, r0
 80012ec:	61fb      	str	r3, [r7, #28]
		uint8_t* sigHash = malloc(256);
 80012ee:	f44f 7080 	mov.w	r0, #256	@ 0x100
 80012f2:	f026 ffa1 	bl	8028238 <malloc>
 80012f6:	4603      	mov	r3, r0
 80012f8:	61bb      	str	r3, [r7, #24]
		memcpy(payload, &receiveBuffer[0], 512);
 80012fa:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80012fe:	491a      	ldr	r1, [pc, #104]	@ (8001368 <USBReceiveHandler+0x15c>)
 8001300:	69f8      	ldr	r0, [r7, #28]
 8001302:	f027 f94f 	bl	80285a4 <memcpy>
		memcpy(sigHash, &receiveBuffer[512], 256);
 8001306:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800130a:	491a      	ldr	r1, [pc, #104]	@ (8001374 <USBReceiveHandler+0x168>)
 800130c:	69b8      	ldr	r0, [r7, #24]
 800130e:	f027 f949 	bl	80285a4 <memcpy>
		fifthMessageHandler(payload, sigHash);
 8001312:	69b9      	ldr	r1, [r7, #24]
 8001314:	69f8      	ldr	r0, [r7, #28]
 8001316:	f7ff fd57 	bl	8000dc8 <fifthMessageHandler>
		free(payload);
 800131a:	69f8      	ldr	r0, [r7, #28]
 800131c:	f026 ff94 	bl	8028248 <free>
		free(sigHash);
 8001320:	69b8      	ldr	r0, [r7, #24]
 8001322:	f026 ff91 	bl	8028248 <free>
		messageCounter = 1;
 8001326:	4b0f      	ldr	r3, [pc, #60]	@ (8001364 <USBReceiveHandler+0x158>)
 8001328:	2201      	movs	r2, #1
 800132a:	701a      	strb	r2, [r3, #0]
	}
	receiveCounter = 0;
 800132c:	4b0f      	ldr	r3, [pc, #60]	@ (800136c <USBReceiveHandler+0x160>)
 800132e:	2200      	movs	r2, #0
 8001330:	801a      	strh	r2, [r3, #0]
	memset(&receiveBuffer, 0, sizeof(receiveBuffer));
 8001332:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 8001336:	2100      	movs	r1, #0
 8001338:	480b      	ldr	r0, [pc, #44]	@ (8001368 <USBReceiveHandler+0x15c>)
 800133a:	f027 f8c9 	bl	80284d0 <memset>
	transmitBuffer(sendBuffer, sendCounter);
 800133e:	4b0f      	ldr	r3, [pc, #60]	@ (800137c <USBReceiveHandler+0x170>)
 8001340:	881b      	ldrh	r3, [r3, #0]
 8001342:	4619      	mov	r1, r3
 8001344:	480e      	ldr	r0, [pc, #56]	@ (8001380 <USBReceiveHandler+0x174>)
 8001346:	f7ff ff37 	bl	80011b8 <transmitBuffer>
	sendCounter = 0;
 800134a:	4b0c      	ldr	r3, [pc, #48]	@ (800137c <USBReceiveHandler+0x170>)
 800134c:	2200      	movs	r2, #0
 800134e:	801a      	strh	r2, [r3, #0]
	memset(&sendBuffer, 0, sizeof(sendBuffer));
 8001350:	f640 12c4 	movw	r2, #2500	@ 0x9c4
 8001354:	2100      	movs	r1, #0
 8001356:	480a      	ldr	r0, [pc, #40]	@ (8001380 <USBReceiveHandler+0x174>)
 8001358:	f027 f8ba 	bl	80284d0 <memset>
}
 800135c:	bf00      	nop
 800135e:	3720      	adds	r7, #32
 8001360:	46bd      	mov	sp, r7
 8001362:	bd80      	pop	{r7, pc}
 8001364:	20000014 	.word	0x20000014
 8001368:	2000150c 	.word	0x2000150c
 800136c:	20001cdc 	.word	0x20001cdc
 8001370:	2000160c 	.word	0x2000160c
 8001374:	2000170c 	.word	0x2000170c
 8001378:	2000190c 	.word	0x2000190c
 800137c:	200026a4 	.word	0x200026a4
 8001380:	20001ce0 	.word	0x20001ce0

08001384 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8001384:	b580      	push	{r7, lr}
 8001386:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8001388:	f000 fc88 	bl	8001c9c <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800138c:	f000 f81a 	bl	80013c4 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8001390:	f000 f93e 	bl	8001610 <MX_GPIO_Init>
  MX_I2C1_Init();
 8001394:	f000 f894 	bl	80014c0 <MX_I2C1_Init>
  MX_I2S3_Init();
 8001398:	f000 f8c0 	bl	800151c <MX_I2S3_Init>
  MX_SPI1_Init();
 800139c:	f000 f902 	bl	80015a4 <MX_SPI1_Init>
  MX_USB_DEVICE_Init();
 80013a0:	f026 f99e 	bl	80276e0 <MX_USB_DEVICE_Init>
  MX_CRC_Init();
 80013a4:	f000 f878 	bl	8001498 <MX_CRC_Init>
  MX_RNG_Init();
 80013a8:	f000 f8e8 	bl	800157c <MX_RNG_Init>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  if (dataReceivedFlag == 1) {
 80013ac:	4b04      	ldr	r3, [pc, #16]	@ (80013c0 <main+0x3c>)
 80013ae:	781b      	ldrb	r3, [r3, #0]
 80013b0:	2b01      	cmp	r3, #1
 80013b2:	d1fb      	bne.n	80013ac <main+0x28>
		  USBReceiveHandler();
 80013b4:	f7ff ff2a 	bl	800120c <USBReceiveHandler>
		  dataReceivedFlag = 0;
 80013b8:	4b01      	ldr	r3, [pc, #4]	@ (80013c0 <main+0x3c>)
 80013ba:	2200      	movs	r2, #0
 80013bc:	701a      	strb	r2, [r3, #0]
	  if (dataReceivedFlag == 1) {
 80013be:	e7f5      	b.n	80013ac <main+0x28>
 80013c0:	20001508 	.word	0x20001508

080013c4 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80013c4:	b580      	push	{r7, lr}
 80013c6:	b094      	sub	sp, #80	@ 0x50
 80013c8:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80013ca:	f107 0320 	add.w	r3, r7, #32
 80013ce:	2230      	movs	r2, #48	@ 0x30
 80013d0:	2100      	movs	r1, #0
 80013d2:	4618      	mov	r0, r3
 80013d4:	f027 f87c 	bl	80284d0 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80013d8:	f107 030c 	add.w	r3, r7, #12
 80013dc:	2200      	movs	r2, #0
 80013de:	601a      	str	r2, [r3, #0]
 80013e0:	605a      	str	r2, [r3, #4]
 80013e2:	609a      	str	r2, [r3, #8]
 80013e4:	60da      	str	r2, [r3, #12]
 80013e6:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 80013e8:	2300      	movs	r3, #0
 80013ea:	60bb      	str	r3, [r7, #8]
 80013ec:	4b28      	ldr	r3, [pc, #160]	@ (8001490 <SystemClock_Config+0xcc>)
 80013ee:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80013f0:	4a27      	ldr	r2, [pc, #156]	@ (8001490 <SystemClock_Config+0xcc>)
 80013f2:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80013f6:	6413      	str	r3, [r2, #64]	@ 0x40
 80013f8:	4b25      	ldr	r3, [pc, #148]	@ (8001490 <SystemClock_Config+0xcc>)
 80013fa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80013fc:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8001400:	60bb      	str	r3, [r7, #8]
 8001402:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001404:	2300      	movs	r3, #0
 8001406:	607b      	str	r3, [r7, #4]
 8001408:	4b22      	ldr	r3, [pc, #136]	@ (8001494 <SystemClock_Config+0xd0>)
 800140a:	681b      	ldr	r3, [r3, #0]
 800140c:	4a21      	ldr	r2, [pc, #132]	@ (8001494 <SystemClock_Config+0xd0>)
 800140e:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001412:	6013      	str	r3, [r2, #0]
 8001414:	4b1f      	ldr	r3, [pc, #124]	@ (8001494 <SystemClock_Config+0xd0>)
 8001416:	681b      	ldr	r3, [r3, #0]
 8001418:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800141c:	607b      	str	r3, [r7, #4]
 800141e:	687b      	ldr	r3, [r7, #4]

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001420:	2301      	movs	r3, #1
 8001422:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8001424:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8001428:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800142a:	2302      	movs	r3, #2
 800142c:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800142e:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8001432:	63fb      	str	r3, [r7, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLM = 8;
 8001434:	2308      	movs	r3, #8
 8001436:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLN = 336;
 8001438:	f44f 73a8 	mov.w	r3, #336	@ 0x150
 800143c:	647b      	str	r3, [r7, #68]	@ 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800143e:	2302      	movs	r3, #2
 8001440:	64bb      	str	r3, [r7, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLQ = 7;
 8001442:	2307      	movs	r3, #7
 8001444:	64fb      	str	r3, [r7, #76]	@ 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001446:	f107 0320 	add.w	r3, r7, #32
 800144a:	4618      	mov	r0, r3
 800144c:	f003 f812 	bl	8004474 <HAL_RCC_OscConfig>
 8001450:	4603      	mov	r3, r0
 8001452:	2b00      	cmp	r3, #0
 8001454:	d001      	beq.n	800145a <SystemClock_Config+0x96>
  {
    Error_Handler();
 8001456:	f000 f9d9 	bl	800180c <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800145a:	230f      	movs	r3, #15
 800145c:	60fb      	str	r3, [r7, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800145e:	2302      	movs	r3, #2
 8001460:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001462:	2300      	movs	r3, #0
 8001464:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8001466:	f44f 53a0 	mov.w	r3, #5120	@ 0x1400
 800146a:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800146c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8001470:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8001472:	f107 030c 	add.w	r3, r7, #12
 8001476:	2105      	movs	r1, #5
 8001478:	4618      	mov	r0, r3
 800147a:	f003 fa73 	bl	8004964 <HAL_RCC_ClockConfig>
 800147e:	4603      	mov	r3, r0
 8001480:	2b00      	cmp	r3, #0
 8001482:	d001      	beq.n	8001488 <SystemClock_Config+0xc4>
  {
    Error_Handler();
 8001484:	f000 f9c2 	bl	800180c <Error_Handler>
  }
}
 8001488:	bf00      	nop
 800148a:	3750      	adds	r7, #80	@ 0x50
 800148c:	46bd      	mov	sp, r7
 800148e:	bd80      	pop	{r7, pc}
 8001490:	40023800 	.word	0x40023800
 8001494:	40007000 	.word	0x40007000

08001498 <MX_CRC_Init>:
  * @brief CRC Initialization Function
  * @param None
  * @retval None
  */
static void MX_CRC_Init(void)
{
 8001498:	b580      	push	{r7, lr}
 800149a:	af00      	add	r7, sp, #0
  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
 800149c:	4b06      	ldr	r3, [pc, #24]	@ (80014b8 <MX_CRC_Init+0x20>)
 800149e:	4a07      	ldr	r2, [pc, #28]	@ (80014bc <MX_CRC_Init+0x24>)
 80014a0:	601a      	str	r2, [r3, #0]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 80014a2:	4805      	ldr	r0, [pc, #20]	@ (80014b8 <MX_CRC_Init+0x20>)
 80014a4:	f000 fdc5 	bl	8002032 <HAL_CRC_Init>
 80014a8:	4603      	mov	r3, r0
 80014aa:	2b00      	cmp	r3, #0
 80014ac:	d001      	beq.n	80014b2 <MX_CRC_Init+0x1a>
  {
    Error_Handler();
 80014ae:	f000 f9ad 	bl	800180c <Error_Handler>
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}
 80014b2:	bf00      	nop
 80014b4:	bd80      	pop	{r7, pc}
 80014b6:	bf00      	nop
 80014b8:	200013fc 	.word	0x200013fc
 80014bc:	40023000 	.word	0x40023000

080014c0 <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
 80014c0:	b580      	push	{r7, lr}
 80014c2:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 80014c4:	4b12      	ldr	r3, [pc, #72]	@ (8001510 <MX_I2C1_Init+0x50>)
 80014c6:	4a13      	ldr	r2, [pc, #76]	@ (8001514 <MX_I2C1_Init+0x54>)
 80014c8:	601a      	str	r2, [r3, #0]
  hi2c1.Init.ClockSpeed = 100000;
 80014ca:	4b11      	ldr	r3, [pc, #68]	@ (8001510 <MX_I2C1_Init+0x50>)
 80014cc:	4a12      	ldr	r2, [pc, #72]	@ (8001518 <MX_I2C1_Init+0x58>)
 80014ce:	605a      	str	r2, [r3, #4]
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 80014d0:	4b0f      	ldr	r3, [pc, #60]	@ (8001510 <MX_I2C1_Init+0x50>)
 80014d2:	2200      	movs	r2, #0
 80014d4:	609a      	str	r2, [r3, #8]
  hi2c1.Init.OwnAddress1 = 0;
 80014d6:	4b0e      	ldr	r3, [pc, #56]	@ (8001510 <MX_I2C1_Init+0x50>)
 80014d8:	2200      	movs	r2, #0
 80014da:	60da      	str	r2, [r3, #12]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80014dc:	4b0c      	ldr	r3, [pc, #48]	@ (8001510 <MX_I2C1_Init+0x50>)
 80014de:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 80014e2:	611a      	str	r2, [r3, #16]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 80014e4:	4b0a      	ldr	r3, [pc, #40]	@ (8001510 <MX_I2C1_Init+0x50>)
 80014e6:	2200      	movs	r2, #0
 80014e8:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2 = 0;
 80014ea:	4b09      	ldr	r3, [pc, #36]	@ (8001510 <MX_I2C1_Init+0x50>)
 80014ec:	2200      	movs	r2, #0
 80014ee:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80014f0:	4b07      	ldr	r3, [pc, #28]	@ (8001510 <MX_I2C1_Init+0x50>)
 80014f2:	2200      	movs	r2, #0
 80014f4:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80014f6:	4b06      	ldr	r3, [pc, #24]	@ (8001510 <MX_I2C1_Init+0x50>)
 80014f8:	2200      	movs	r2, #0
 80014fa:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 80014fc:	4804      	ldr	r0, [pc, #16]	@ (8001510 <MX_I2C1_Init+0x50>)
 80014fe:	f000 ff83 	bl	8002408 <HAL_I2C_Init>
 8001502:	4603      	mov	r3, r0
 8001504:	2b00      	cmp	r3, #0
 8001506:	d001      	beq.n	800150c <MX_I2C1_Init+0x4c>
  {
    Error_Handler();
 8001508:	f000 f980 	bl	800180c <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 800150c:	bf00      	nop
 800150e:	bd80      	pop	{r7, pc}
 8001510:	20001404 	.word	0x20001404
 8001514:	40005400 	.word	0x40005400
 8001518:	000186a0 	.word	0x000186a0

0800151c <MX_I2S3_Init>:
  * @brief I2S3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2S3_Init(void)
{
 800151c:	b580      	push	{r7, lr}
 800151e:	af00      	add	r7, sp, #0
  /* USER CODE END I2S3_Init 0 */

  /* USER CODE BEGIN I2S3_Init 1 */

  /* USER CODE END I2S3_Init 1 */
  hi2s3.Instance = SPI3;
 8001520:	4b13      	ldr	r3, [pc, #76]	@ (8001570 <MX_I2S3_Init+0x54>)
 8001522:	4a14      	ldr	r2, [pc, #80]	@ (8001574 <MX_I2S3_Init+0x58>)
 8001524:	601a      	str	r2, [r3, #0]
  hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
 8001526:	4b12      	ldr	r3, [pc, #72]	@ (8001570 <MX_I2S3_Init+0x54>)
 8001528:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800152c:	605a      	str	r2, [r3, #4]
  hi2s3.Init.Standard = I2S_STANDARD_PHILIPS;
 800152e:	4b10      	ldr	r3, [pc, #64]	@ (8001570 <MX_I2S3_Init+0x54>)
 8001530:	2200      	movs	r2, #0
 8001532:	609a      	str	r2, [r3, #8]
  hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
 8001534:	4b0e      	ldr	r3, [pc, #56]	@ (8001570 <MX_I2S3_Init+0x54>)
 8001536:	2200      	movs	r2, #0
 8001538:	60da      	str	r2, [r3, #12]
  hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
 800153a:	4b0d      	ldr	r3, [pc, #52]	@ (8001570 <MX_I2S3_Init+0x54>)
 800153c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8001540:	611a      	str	r2, [r3, #16]
  hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_96K;
 8001542:	4b0b      	ldr	r3, [pc, #44]	@ (8001570 <MX_I2S3_Init+0x54>)
 8001544:	4a0c      	ldr	r2, [pc, #48]	@ (8001578 <MX_I2S3_Init+0x5c>)
 8001546:	615a      	str	r2, [r3, #20]
  hi2s3.Init.CPOL = I2S_CPOL_LOW;
 8001548:	4b09      	ldr	r3, [pc, #36]	@ (8001570 <MX_I2S3_Init+0x54>)
 800154a:	2200      	movs	r2, #0
 800154c:	619a      	str	r2, [r3, #24]
  hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
 800154e:	4b08      	ldr	r3, [pc, #32]	@ (8001570 <MX_I2S3_Init+0x54>)
 8001550:	2200      	movs	r2, #0
 8001552:	61da      	str	r2, [r3, #28]
  hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
 8001554:	4b06      	ldr	r3, [pc, #24]	@ (8001570 <MX_I2S3_Init+0x54>)
 8001556:	2200      	movs	r2, #0
 8001558:	621a      	str	r2, [r3, #32]
  if (HAL_I2S_Init(&hi2s3) != HAL_OK)
 800155a:	4805      	ldr	r0, [pc, #20]	@ (8001570 <MX_I2S3_Init+0x54>)
 800155c:	f001 f898 	bl	8002690 <HAL_I2S_Init>
 8001560:	4603      	mov	r3, r0
 8001562:	2b00      	cmp	r3, #0
 8001564:	d001      	beq.n	800156a <MX_I2S3_Init+0x4e>
  {
    Error_Handler();
 8001566:	f000 f951 	bl	800180c <Error_Handler>
  }
  /* USER CODE BEGIN I2S3_Init 2 */

  /* USER CODE END I2S3_Init 2 */

}
 800156a:	bf00      	nop
 800156c:	bd80      	pop	{r7, pc}
 800156e:	bf00      	nop
 8001570:	20001458 	.word	0x20001458
 8001574:	40003c00 	.word	0x40003c00
 8001578:	00017700 	.word	0x00017700

0800157c <MX_RNG_Init>:
  * @brief RNG Initialization Function
  * @param None
  * @retval None
  */
static void MX_RNG_Init(void)
{
 800157c:	b580      	push	{r7, lr}
 800157e:	af00      	add	r7, sp, #0
  /* USER CODE END RNG_Init 0 */

  /* USER CODE BEGIN RNG_Init 1 */

  /* USER CODE END RNG_Init 1 */
  hrng.Instance = RNG;
 8001580:	4b06      	ldr	r3, [pc, #24]	@ (800159c <MX_RNG_Init+0x20>)
 8001582:	4a07      	ldr	r2, [pc, #28]	@ (80015a0 <MX_RNG_Init+0x24>)
 8001584:	601a      	str	r2, [r3, #0]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 8001586:	4805      	ldr	r0, [pc, #20]	@ (800159c <MX_RNG_Init+0x20>)
 8001588:	f003 fd3a 	bl	8005000 <HAL_RNG_Init>
 800158c:	4603      	mov	r3, r0
 800158e:	2b00      	cmp	r3, #0
 8001590:	d001      	beq.n	8001596 <MX_RNG_Init+0x1a>
  {
    Error_Handler();
 8001592:	f000 f93b 	bl	800180c <Error_Handler>
  }
  /* USER CODE BEGIN RNG_Init 2 */

  /* USER CODE END RNG_Init 2 */

}
 8001596:	bf00      	nop
 8001598:	bd80      	pop	{r7, pc}
 800159a:	bf00      	nop
 800159c:	200014a0 	.word	0x200014a0
 80015a0:	50060800 	.word	0x50060800

080015a4 <MX_SPI1_Init>:
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{
 80015a4:	b580      	push	{r7, lr}
 80015a6:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 80015a8:	4b17      	ldr	r3, [pc, #92]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015aa:	4a18      	ldr	r2, [pc, #96]	@ (800160c <MX_SPI1_Init+0x68>)
 80015ac:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80015ae:	4b16      	ldr	r3, [pc, #88]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015b0:	f44f 7282 	mov.w	r2, #260	@ 0x104
 80015b4:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 80015b6:	4b14      	ldr	r3, [pc, #80]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015b8:	2200      	movs	r2, #0
 80015ba:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 80015bc:	4b12      	ldr	r3, [pc, #72]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015be:	2200      	movs	r2, #0
 80015c0:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 80015c2:	4b11      	ldr	r3, [pc, #68]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015c4:	2200      	movs	r2, #0
 80015c6:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 80015c8:	4b0f      	ldr	r3, [pc, #60]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015ca:	2200      	movs	r2, #0
 80015cc:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80015ce:	4b0e      	ldr	r3, [pc, #56]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015d0:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80015d4:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80015d6:	4b0c      	ldr	r3, [pc, #48]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015d8:	2200      	movs	r2, #0
 80015da:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80015dc:	4b0a      	ldr	r3, [pc, #40]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015de:	2200      	movs	r2, #0
 80015e0:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 80015e2:	4b09      	ldr	r3, [pc, #36]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015e4:	2200      	movs	r2, #0
 80015e6:	625a      	str	r2, [r3, #36]	@ 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80015e8:	4b07      	ldr	r3, [pc, #28]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015ea:	2200      	movs	r2, #0
 80015ec:	629a      	str	r2, [r3, #40]	@ 0x28
  hspi1.Init.CRCPolynomial = 10;
 80015ee:	4b06      	ldr	r3, [pc, #24]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015f0:	220a      	movs	r2, #10
 80015f2:	62da      	str	r2, [r3, #44]	@ 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 80015f4:	4804      	ldr	r0, [pc, #16]	@ (8001608 <MX_SPI1_Init+0x64>)
 80015f6:	f003 fdad 	bl	8005154 <HAL_SPI_Init>
 80015fa:	4603      	mov	r3, r0
 80015fc:	2b00      	cmp	r3, #0
 80015fe:	d001      	beq.n	8001604 <MX_SPI1_Init+0x60>
  {
    Error_Handler();
 8001600:	f000 f904 	bl	800180c <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 8001604:	bf00      	nop
 8001606:	bd80      	pop	{r7, pc}
 8001608:	200014b0 	.word	0x200014b0
 800160c:	40013000 	.word	0x40013000

08001610 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8001610:	b580      	push	{r7, lr}
 8001612:	b08c      	sub	sp, #48	@ 0x30
 8001614:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001616:	f107 031c 	add.w	r3, r7, #28
 800161a:	2200      	movs	r2, #0
 800161c:	601a      	str	r2, [r3, #0]
 800161e:	605a      	str	r2, [r3, #4]
 8001620:	609a      	str	r2, [r3, #8]
 8001622:	60da      	str	r2, [r3, #12]
 8001624:	611a      	str	r2, [r3, #16]
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8001626:	2300      	movs	r3, #0
 8001628:	61bb      	str	r3, [r7, #24]
 800162a:	4b72      	ldr	r3, [pc, #456]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 800162c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800162e:	4a71      	ldr	r2, [pc, #452]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 8001630:	f043 0310 	orr.w	r3, r3, #16
 8001634:	6313      	str	r3, [r2, #48]	@ 0x30
 8001636:	4b6f      	ldr	r3, [pc, #444]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 8001638:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800163a:	f003 0310 	and.w	r3, r3, #16
 800163e:	61bb      	str	r3, [r7, #24]
 8001640:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001642:	2300      	movs	r3, #0
 8001644:	617b      	str	r3, [r7, #20]
 8001646:	4b6b      	ldr	r3, [pc, #428]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 8001648:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800164a:	4a6a      	ldr	r2, [pc, #424]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 800164c:	f043 0304 	orr.w	r3, r3, #4
 8001650:	6313      	str	r3, [r2, #48]	@ 0x30
 8001652:	4b68      	ldr	r3, [pc, #416]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 8001654:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001656:	f003 0304 	and.w	r3, r3, #4
 800165a:	617b      	str	r3, [r7, #20]
 800165c:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800165e:	2300      	movs	r3, #0
 8001660:	613b      	str	r3, [r7, #16]
 8001662:	4b64      	ldr	r3, [pc, #400]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 8001664:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001666:	4a63      	ldr	r2, [pc, #396]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 8001668:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800166c:	6313      	str	r3, [r2, #48]	@ 0x30
 800166e:	4b61      	ldr	r3, [pc, #388]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 8001670:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001672:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8001676:	613b      	str	r3, [r7, #16]
 8001678:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800167a:	2300      	movs	r3, #0
 800167c:	60fb      	str	r3, [r7, #12]
 800167e:	4b5d      	ldr	r3, [pc, #372]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 8001680:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001682:	4a5c      	ldr	r2, [pc, #368]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 8001684:	f043 0301 	orr.w	r3, r3, #1
 8001688:	6313      	str	r3, [r2, #48]	@ 0x30
 800168a:	4b5a      	ldr	r3, [pc, #360]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 800168c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800168e:	f003 0301 	and.w	r3, r3, #1
 8001692:	60fb      	str	r3, [r7, #12]
 8001694:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001696:	2300      	movs	r3, #0
 8001698:	60bb      	str	r3, [r7, #8]
 800169a:	4b56      	ldr	r3, [pc, #344]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 800169c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800169e:	4a55      	ldr	r2, [pc, #340]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 80016a0:	f043 0302 	orr.w	r3, r3, #2
 80016a4:	6313      	str	r3, [r2, #48]	@ 0x30
 80016a6:	4b53      	ldr	r3, [pc, #332]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 80016a8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016aa:	f003 0302 	and.w	r3, r3, #2
 80016ae:	60bb      	str	r3, [r7, #8]
 80016b0:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80016b2:	2300      	movs	r3, #0
 80016b4:	607b      	str	r3, [r7, #4]
 80016b6:	4b4f      	ldr	r3, [pc, #316]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 80016b8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016ba:	4a4e      	ldr	r2, [pc, #312]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 80016bc:	f043 0308 	orr.w	r3, r3, #8
 80016c0:	6313      	str	r3, [r2, #48]	@ 0x30
 80016c2:	4b4c      	ldr	r3, [pc, #304]	@ (80017f4 <MX_GPIO_Init+0x1e4>)
 80016c4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80016c6:	f003 0308 	and.w	r3, r3, #8
 80016ca:	607b      	str	r3, [r7, #4]
 80016cc:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(CS_I2C_SPI_GPIO_Port, CS_I2C_SPI_Pin, GPIO_PIN_RESET);
 80016ce:	2200      	movs	r2, #0
 80016d0:	2108      	movs	r1, #8
 80016d2:	4849      	ldr	r0, [pc, #292]	@ (80017f8 <MX_GPIO_Init+0x1e8>)
 80016d4:	f000 fe7e 	bl	80023d4 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 80016d8:	2201      	movs	r2, #1
 80016da:	2101      	movs	r1, #1
 80016dc:	4847      	ldr	r0, [pc, #284]	@ (80017fc <MX_GPIO_Init+0x1ec>)
 80016de:	f000 fe79 	bl	80023d4 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
 80016e2:	2200      	movs	r2, #0
 80016e4:	f24f 0110 	movw	r1, #61456	@ 0xf010
 80016e8:	4845      	ldr	r0, [pc, #276]	@ (8001800 <MX_GPIO_Init+0x1f0>)
 80016ea:	f000 fe73 	bl	80023d4 <HAL_GPIO_WritePin>
                          |Audio_RST_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : CS_I2C_SPI_Pin */
  GPIO_InitStruct.Pin = CS_I2C_SPI_Pin;
 80016ee:	2308      	movs	r3, #8
 80016f0:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80016f2:	2301      	movs	r3, #1
 80016f4:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80016f6:	2300      	movs	r3, #0
 80016f8:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80016fa:	2300      	movs	r3, #0
 80016fc:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(CS_I2C_SPI_GPIO_Port, &GPIO_InitStruct);
 80016fe:	f107 031c 	add.w	r3, r7, #28
 8001702:	4619      	mov	r1, r3
 8001704:	483c      	ldr	r0, [pc, #240]	@ (80017f8 <MX_GPIO_Init+0x1e8>)
 8001706:	f000 fcb1 	bl	800206c <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_PowerSwitchOn_Pin */
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
 800170a:	2301      	movs	r3, #1
 800170c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800170e:	2301      	movs	r3, #1
 8001710:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001712:	2300      	movs	r3, #0
 8001714:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001716:	2300      	movs	r3, #0
 8001718:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 800171a:	f107 031c 	add.w	r3, r7, #28
 800171e:	4619      	mov	r1, r3
 8001720:	4836      	ldr	r0, [pc, #216]	@ (80017fc <MX_GPIO_Init+0x1ec>)
 8001722:	f000 fca3 	bl	800206c <HAL_GPIO_Init>

  /*Configure GPIO pin : PDM_OUT_Pin */
  GPIO_InitStruct.Pin = PDM_OUT_Pin;
 8001726:	2308      	movs	r3, #8
 8001728:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800172a:	2302      	movs	r3, #2
 800172c:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800172e:	2300      	movs	r3, #0
 8001730:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001732:	2300      	movs	r3, #0
 8001734:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8001736:	2305      	movs	r3, #5
 8001738:	62fb      	str	r3, [r7, #44]	@ 0x2c
  HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);
 800173a:	f107 031c 	add.w	r3, r7, #28
 800173e:	4619      	mov	r1, r3
 8001740:	482e      	ldr	r0, [pc, #184]	@ (80017fc <MX_GPIO_Init+0x1ec>)
 8001742:	f000 fc93 	bl	800206c <HAL_GPIO_Init>

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
 8001746:	2301      	movs	r3, #1
 8001748:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 800174a:	f44f 1390 	mov.w	r3, #1179648	@ 0x120000
 800174e:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001750:	2300      	movs	r3, #0
 8001752:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8001754:	f107 031c 	add.w	r3, r7, #28
 8001758:	4619      	mov	r1, r3
 800175a:	482a      	ldr	r0, [pc, #168]	@ (8001804 <MX_GPIO_Init+0x1f4>)
 800175c:	f000 fc86 	bl	800206c <HAL_GPIO_Init>

  /*Configure GPIO pin : BOOT1_Pin */
  GPIO_InitStruct.Pin = BOOT1_Pin;
 8001760:	2304      	movs	r3, #4
 8001762:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8001764:	2300      	movs	r3, #0
 8001766:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001768:	2300      	movs	r3, #0
 800176a:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
 800176c:	f107 031c 	add.w	r3, r7, #28
 8001770:	4619      	mov	r1, r3
 8001772:	4825      	ldr	r0, [pc, #148]	@ (8001808 <MX_GPIO_Init+0x1f8>)
 8001774:	f000 fc7a 	bl	800206c <HAL_GPIO_Init>

  /*Configure GPIO pin : CLK_IN_Pin */
  GPIO_InitStruct.Pin = CLK_IN_Pin;
 8001778:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800177c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800177e:	2302      	movs	r3, #2
 8001780:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001782:	2300      	movs	r3, #0
 8001784:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001786:	2300      	movs	r3, #0
 8001788:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800178a:	2305      	movs	r3, #5
 800178c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);
 800178e:	f107 031c 	add.w	r3, r7, #28
 8001792:	4619      	mov	r1, r3
 8001794:	481c      	ldr	r0, [pc, #112]	@ (8001808 <MX_GPIO_Init+0x1f8>)
 8001796:	f000 fc69 	bl	800206c <HAL_GPIO_Init>

  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin
                           Audio_RST_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
 800179a:	f24f 0310 	movw	r3, #61456	@ 0xf010
 800179e:	61fb      	str	r3, [r7, #28]
                          |Audio_RST_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80017a0:	2301      	movs	r3, #1
 80017a2:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80017a4:	2300      	movs	r3, #0
 80017a6:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80017a8:	2300      	movs	r3, #0
 80017aa:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80017ac:	f107 031c 	add.w	r3, r7, #28
 80017b0:	4619      	mov	r1, r3
 80017b2:	4813      	ldr	r0, [pc, #76]	@ (8001800 <MX_GPIO_Init+0x1f0>)
 80017b4:	f000 fc5a 	bl	800206c <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_OverCurrent_Pin */
  GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
 80017b8:	2320      	movs	r3, #32
 80017ba:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80017bc:	2300      	movs	r3, #0
 80017be:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80017c0:	2300      	movs	r3, #0
 80017c2:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 80017c4:	f107 031c 	add.w	r3, r7, #28
 80017c8:	4619      	mov	r1, r3
 80017ca:	480d      	ldr	r0, [pc, #52]	@ (8001800 <MX_GPIO_Init+0x1f0>)
 80017cc:	f000 fc4e 	bl	800206c <HAL_GPIO_Init>

  /*Configure GPIO pin : MEMS_INT2_Pin */
  GPIO_InitStruct.Pin = MEMS_INT2_Pin;
 80017d0:	2302      	movs	r3, #2
 80017d2:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 80017d4:	f44f 1390 	mov.w	r3, #1179648	@ 0x120000
 80017d8:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80017da:	2300      	movs	r3, #0
 80017dc:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(MEMS_INT2_GPIO_Port, &GPIO_InitStruct);
 80017de:	f107 031c 	add.w	r3, r7, #28
 80017e2:	4619      	mov	r1, r3
 80017e4:	4804      	ldr	r0, [pc, #16]	@ (80017f8 <MX_GPIO_Init+0x1e8>)
 80017e6:	f000 fc41 	bl	800206c <HAL_GPIO_Init>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
 80017ea:	bf00      	nop
 80017ec:	3730      	adds	r7, #48	@ 0x30
 80017ee:	46bd      	mov	sp, r7
 80017f0:	bd80      	pop	{r7, pc}
 80017f2:	bf00      	nop
 80017f4:	40023800 	.word	0x40023800
 80017f8:	40021000 	.word	0x40021000
 80017fc:	40020800 	.word	0x40020800
 8001800:	40020c00 	.word	0x40020c00
 8001804:	40020000 	.word	0x40020000
 8001808:	40020400 	.word	0x40020400

0800180c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800180c:	b480      	push	{r7}
 800180e:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001810:	b672      	cpsid	i
}
 8001812:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8001814:	bf00      	nop
 8001816:	e7fd      	b.n	8001814 <Error_Handler+0x8>

08001818 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8001818:	b580      	push	{r7, lr}
 800181a:	b082      	sub	sp, #8
 800181c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800181e:	2300      	movs	r3, #0
 8001820:	607b      	str	r3, [r7, #4]
 8001822:	4b10      	ldr	r3, [pc, #64]	@ (8001864 <HAL_MspInit+0x4c>)
 8001824:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8001826:	4a0f      	ldr	r2, [pc, #60]	@ (8001864 <HAL_MspInit+0x4c>)
 8001828:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800182c:	6453      	str	r3, [r2, #68]	@ 0x44
 800182e:	4b0d      	ldr	r3, [pc, #52]	@ (8001864 <HAL_MspInit+0x4c>)
 8001830:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8001832:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8001836:	607b      	str	r3, [r7, #4]
 8001838:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800183a:	2300      	movs	r3, #0
 800183c:	603b      	str	r3, [r7, #0]
 800183e:	4b09      	ldr	r3, [pc, #36]	@ (8001864 <HAL_MspInit+0x4c>)
 8001840:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001842:	4a08      	ldr	r2, [pc, #32]	@ (8001864 <HAL_MspInit+0x4c>)
 8001844:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8001848:	6413      	str	r3, [r2, #64]	@ 0x40
 800184a:	4b06      	ldr	r3, [pc, #24]	@ (8001864 <HAL_MspInit+0x4c>)
 800184c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800184e:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8001852:	603b      	str	r3, [r7, #0]
 8001854:	683b      	ldr	r3, [r7, #0]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 8001856:	2007      	movs	r0, #7
 8001858:	f000 fbaa 	bl	8001fb0 <HAL_NVIC_SetPriorityGrouping>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800185c:	bf00      	nop
 800185e:	3708      	adds	r7, #8
 8001860:	46bd      	mov	sp, r7
 8001862:	bd80      	pop	{r7, pc}
 8001864:	40023800 	.word	0x40023800

08001868 <HAL_CRC_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hcrc: CRC handle pointer
  * @retval None
  */
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
 8001868:	b480      	push	{r7}
 800186a:	b085      	sub	sp, #20
 800186c:	af00      	add	r7, sp, #0
 800186e:	6078      	str	r0, [r7, #4]
  if(hcrc->Instance==CRC)
 8001870:	687b      	ldr	r3, [r7, #4]
 8001872:	681b      	ldr	r3, [r3, #0]
 8001874:	4a0b      	ldr	r2, [pc, #44]	@ (80018a4 <HAL_CRC_MspInit+0x3c>)
 8001876:	4293      	cmp	r3, r2
 8001878:	d10d      	bne.n	8001896 <HAL_CRC_MspInit+0x2e>
  {
    /* USER CODE BEGIN CRC_MspInit 0 */

    /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 800187a:	2300      	movs	r3, #0
 800187c:	60fb      	str	r3, [r7, #12]
 800187e:	4b0a      	ldr	r3, [pc, #40]	@ (80018a8 <HAL_CRC_MspInit+0x40>)
 8001880:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001882:	4a09      	ldr	r2, [pc, #36]	@ (80018a8 <HAL_CRC_MspInit+0x40>)
 8001884:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8001888:	6313      	str	r3, [r2, #48]	@ 0x30
 800188a:	4b07      	ldr	r3, [pc, #28]	@ (80018a8 <HAL_CRC_MspInit+0x40>)
 800188c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800188e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8001892:	60fb      	str	r3, [r7, #12]
 8001894:	68fb      	ldr	r3, [r7, #12]

    /* USER CODE END CRC_MspInit 1 */

  }

}
 8001896:	bf00      	nop
 8001898:	3714      	adds	r7, #20
 800189a:	46bd      	mov	sp, r7
 800189c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80018a0:	4770      	bx	lr
 80018a2:	bf00      	nop
 80018a4:	40023000 	.word	0x40023000
 80018a8:	40023800 	.word	0x40023800

080018ac <HAL_I2C_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 80018ac:	b580      	push	{r7, lr}
 80018ae:	b08a      	sub	sp, #40	@ 0x28
 80018b0:	af00      	add	r7, sp, #0
 80018b2:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018b4:	f107 0314 	add.w	r3, r7, #20
 80018b8:	2200      	movs	r2, #0
 80018ba:	601a      	str	r2, [r3, #0]
 80018bc:	605a      	str	r2, [r3, #4]
 80018be:	609a      	str	r2, [r3, #8]
 80018c0:	60da      	str	r2, [r3, #12]
 80018c2:	611a      	str	r2, [r3, #16]
  if(hi2c->Instance==I2C1)
 80018c4:	687b      	ldr	r3, [r7, #4]
 80018c6:	681b      	ldr	r3, [r3, #0]
 80018c8:	4a19      	ldr	r2, [pc, #100]	@ (8001930 <HAL_I2C_MspInit+0x84>)
 80018ca:	4293      	cmp	r3, r2
 80018cc:	d12c      	bne.n	8001928 <HAL_I2C_MspInit+0x7c>
  {
    /* USER CODE BEGIN I2C1_MspInit 0 */

    /* USER CODE END I2C1_MspInit 0 */

    __HAL_RCC_GPIOB_CLK_ENABLE();
 80018ce:	2300      	movs	r3, #0
 80018d0:	613b      	str	r3, [r7, #16]
 80018d2:	4b18      	ldr	r3, [pc, #96]	@ (8001934 <HAL_I2C_MspInit+0x88>)
 80018d4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80018d6:	4a17      	ldr	r2, [pc, #92]	@ (8001934 <HAL_I2C_MspInit+0x88>)
 80018d8:	f043 0302 	orr.w	r3, r3, #2
 80018dc:	6313      	str	r3, [r2, #48]	@ 0x30
 80018de:	4b15      	ldr	r3, [pc, #84]	@ (8001934 <HAL_I2C_MspInit+0x88>)
 80018e0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80018e2:	f003 0302 	and.w	r3, r3, #2
 80018e6:	613b      	str	r3, [r7, #16]
 80018e8:	693b      	ldr	r3, [r7, #16]
    /**I2C1 GPIO Configuration
    PB6     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = Audio_SCL_Pin|Audio_SDA_Pin;
 80018ea:	f44f 7310 	mov.w	r3, #576	@ 0x240
 80018ee:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80018f0:	2312      	movs	r3, #18
 80018f2:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80018f4:	2301      	movs	r3, #1
 80018f6:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80018f8:	2300      	movs	r3, #0
 80018fa:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 80018fc:	2304      	movs	r3, #4
 80018fe:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001900:	f107 0314 	add.w	r3, r7, #20
 8001904:	4619      	mov	r1, r3
 8001906:	480c      	ldr	r0, [pc, #48]	@ (8001938 <HAL_I2C_MspInit+0x8c>)
 8001908:	f000 fbb0 	bl	800206c <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 800190c:	2300      	movs	r3, #0
 800190e:	60fb      	str	r3, [r7, #12]
 8001910:	4b08      	ldr	r3, [pc, #32]	@ (8001934 <HAL_I2C_MspInit+0x88>)
 8001912:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001914:	4a07      	ldr	r2, [pc, #28]	@ (8001934 <HAL_I2C_MspInit+0x88>)
 8001916:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800191a:	6413      	str	r3, [r2, #64]	@ 0x40
 800191c:	4b05      	ldr	r3, [pc, #20]	@ (8001934 <HAL_I2C_MspInit+0x88>)
 800191e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001920:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8001924:	60fb      	str	r3, [r7, #12]
 8001926:	68fb      	ldr	r3, [r7, #12]

    /* USER CODE END I2C1_MspInit 1 */

  }

}
 8001928:	bf00      	nop
 800192a:	3728      	adds	r7, #40	@ 0x28
 800192c:	46bd      	mov	sp, r7
 800192e:	bd80      	pop	{r7, pc}
 8001930:	40005400 	.word	0x40005400
 8001934:	40023800 	.word	0x40023800
 8001938:	40020400 	.word	0x40020400

0800193c <HAL_I2S_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hi2s: I2S handle pointer
  * @retval None
  */
void HAL_I2S_MspInit(I2S_HandleTypeDef* hi2s)
{
 800193c:	b580      	push	{r7, lr}
 800193e:	b08e      	sub	sp, #56	@ 0x38
 8001940:	af00      	add	r7, sp, #0
 8001942:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001944:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8001948:	2200      	movs	r2, #0
 800194a:	601a      	str	r2, [r3, #0]
 800194c:	605a      	str	r2, [r3, #4]
 800194e:	609a      	str	r2, [r3, #8]
 8001950:	60da      	str	r2, [r3, #12]
 8001952:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001954:	f107 0314 	add.w	r3, r7, #20
 8001958:	2200      	movs	r2, #0
 800195a:	601a      	str	r2, [r3, #0]
 800195c:	605a      	str	r2, [r3, #4]
 800195e:	609a      	str	r2, [r3, #8]
 8001960:	60da      	str	r2, [r3, #12]
  if(hi2s->Instance==SPI3)
 8001962:	687b      	ldr	r3, [r7, #4]
 8001964:	681b      	ldr	r3, [r3, #0]
 8001966:	4a31      	ldr	r2, [pc, #196]	@ (8001a2c <HAL_I2S_MspInit+0xf0>)
 8001968:	4293      	cmp	r3, r2
 800196a:	d15a      	bne.n	8001a22 <HAL_I2S_MspInit+0xe6>

    /* USER CODE END SPI3_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2S;
 800196c:	2301      	movs	r3, #1
 800196e:	617b      	str	r3, [r7, #20]
    PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
 8001970:	23c0      	movs	r3, #192	@ 0xc0
 8001972:	61bb      	str	r3, [r7, #24]
    PeriphClkInitStruct.PLLI2S.PLLI2SR = 2;
 8001974:	2302      	movs	r3, #2
 8001976:	61fb      	str	r3, [r7, #28]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001978:	f107 0314 	add.w	r3, r7, #20
 800197c:	4618      	mov	r0, r3
 800197e:	f003 f9fd 	bl	8004d7c <HAL_RCCEx_PeriphCLKConfig>
 8001982:	4603      	mov	r3, r0
 8001984:	2b00      	cmp	r3, #0
 8001986:	d001      	beq.n	800198c <HAL_I2S_MspInit+0x50>
    {
      Error_Handler();
 8001988:	f7ff ff40 	bl	800180c <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_SPI3_CLK_ENABLE();
 800198c:	2300      	movs	r3, #0
 800198e:	613b      	str	r3, [r7, #16]
 8001990:	4b27      	ldr	r3, [pc, #156]	@ (8001a30 <HAL_I2S_MspInit+0xf4>)
 8001992:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001994:	4a26      	ldr	r2, [pc, #152]	@ (8001a30 <HAL_I2S_MspInit+0xf4>)
 8001996:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800199a:	6413      	str	r3, [r2, #64]	@ 0x40
 800199c:	4b24      	ldr	r3, [pc, #144]	@ (8001a30 <HAL_I2S_MspInit+0xf4>)
 800199e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80019a0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80019a4:	613b      	str	r3, [r7, #16]
 80019a6:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80019a8:	2300      	movs	r3, #0
 80019aa:	60fb      	str	r3, [r7, #12]
 80019ac:	4b20      	ldr	r3, [pc, #128]	@ (8001a30 <HAL_I2S_MspInit+0xf4>)
 80019ae:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019b0:	4a1f      	ldr	r2, [pc, #124]	@ (8001a30 <HAL_I2S_MspInit+0xf4>)
 80019b2:	f043 0301 	orr.w	r3, r3, #1
 80019b6:	6313      	str	r3, [r2, #48]	@ 0x30
 80019b8:	4b1d      	ldr	r3, [pc, #116]	@ (8001a30 <HAL_I2S_MspInit+0xf4>)
 80019ba:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019bc:	f003 0301 	and.w	r3, r3, #1
 80019c0:	60fb      	str	r3, [r7, #12]
 80019c2:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80019c4:	2300      	movs	r3, #0
 80019c6:	60bb      	str	r3, [r7, #8]
 80019c8:	4b19      	ldr	r3, [pc, #100]	@ (8001a30 <HAL_I2S_MspInit+0xf4>)
 80019ca:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019cc:	4a18      	ldr	r2, [pc, #96]	@ (8001a30 <HAL_I2S_MspInit+0xf4>)
 80019ce:	f043 0304 	orr.w	r3, r3, #4
 80019d2:	6313      	str	r3, [r2, #48]	@ 0x30
 80019d4:	4b16      	ldr	r3, [pc, #88]	@ (8001a30 <HAL_I2S_MspInit+0xf4>)
 80019d6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019d8:	f003 0304 	and.w	r3, r3, #4
 80019dc:	60bb      	str	r3, [r7, #8]
 80019de:	68bb      	ldr	r3, [r7, #8]
    PA4     ------> I2S3_WS
    PC7     ------> I2S3_MCK
    PC10     ------> I2S3_CK
    PC12     ------> I2S3_SD
    */
    GPIO_InitStruct.Pin = I2S3_WS_Pin;
 80019e0:	2310      	movs	r3, #16
 80019e2:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80019e4:	2302      	movs	r3, #2
 80019e6:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80019e8:	2300      	movs	r3, #0
 80019ea:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80019ec:	2300      	movs	r3, #0
 80019ee:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 80019f0:	2306      	movs	r3, #6
 80019f2:	637b      	str	r3, [r7, #52]	@ 0x34
    HAL_GPIO_Init(I2S3_WS_GPIO_Port, &GPIO_InitStruct);
 80019f4:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80019f8:	4619      	mov	r1, r3
 80019fa:	480e      	ldr	r0, [pc, #56]	@ (8001a34 <HAL_I2S_MspInit+0xf8>)
 80019fc:	f000 fb36 	bl	800206c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = I2S3_MCK_Pin|I2S3_SCK_Pin|I2S3_SD_Pin;
 8001a00:	f44f 53a4 	mov.w	r3, #5248	@ 0x1480
 8001a04:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001a06:	2302      	movs	r3, #2
 8001a08:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001a0a:	2300      	movs	r3, #0
 8001a0c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001a0e:	2300      	movs	r3, #0
 8001a10:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8001a12:	2306      	movs	r3, #6
 8001a14:	637b      	str	r3, [r7, #52]	@ 0x34
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001a16:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8001a1a:	4619      	mov	r1, r3
 8001a1c:	4806      	ldr	r0, [pc, #24]	@ (8001a38 <HAL_I2S_MspInit+0xfc>)
 8001a1e:	f000 fb25 	bl	800206c <HAL_GPIO_Init>

    /* USER CODE END SPI3_MspInit 1 */

  }

}
 8001a22:	bf00      	nop
 8001a24:	3738      	adds	r7, #56	@ 0x38
 8001a26:	46bd      	mov	sp, r7
 8001a28:	bd80      	pop	{r7, pc}
 8001a2a:	bf00      	nop
 8001a2c:	40003c00 	.word	0x40003c00
 8001a30:	40023800 	.word	0x40023800
 8001a34:	40020000 	.word	0x40020000
 8001a38:	40020800 	.word	0x40020800

08001a3c <HAL_RNG_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hrng: RNG handle pointer
  * @retval None
  */
void HAL_RNG_MspInit(RNG_HandleTypeDef* hrng)
{
 8001a3c:	b480      	push	{r7}
 8001a3e:	b085      	sub	sp, #20
 8001a40:	af00      	add	r7, sp, #0
 8001a42:	6078      	str	r0, [r7, #4]
  if(hrng->Instance==RNG)
 8001a44:	687b      	ldr	r3, [r7, #4]
 8001a46:	681b      	ldr	r3, [r3, #0]
 8001a48:	4a0b      	ldr	r2, [pc, #44]	@ (8001a78 <HAL_RNG_MspInit+0x3c>)
 8001a4a:	4293      	cmp	r3, r2
 8001a4c:	d10d      	bne.n	8001a6a <HAL_RNG_MspInit+0x2e>
  {
    /* USER CODE BEGIN RNG_MspInit 0 */

    /* USER CODE END RNG_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
 8001a4e:	2300      	movs	r3, #0
 8001a50:	60fb      	str	r3, [r7, #12]
 8001a52:	4b0a      	ldr	r3, [pc, #40]	@ (8001a7c <HAL_RNG_MspInit+0x40>)
 8001a54:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001a56:	4a09      	ldr	r2, [pc, #36]	@ (8001a7c <HAL_RNG_MspInit+0x40>)
 8001a58:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8001a5c:	6353      	str	r3, [r2, #52]	@ 0x34
 8001a5e:	4b07      	ldr	r3, [pc, #28]	@ (8001a7c <HAL_RNG_MspInit+0x40>)
 8001a60:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001a62:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8001a66:	60fb      	str	r3, [r7, #12]
 8001a68:	68fb      	ldr	r3, [r7, #12]

    /* USER CODE END RNG_MspInit 1 */

  }

}
 8001a6a:	bf00      	nop
 8001a6c:	3714      	adds	r7, #20
 8001a6e:	46bd      	mov	sp, r7
 8001a70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a74:	4770      	bx	lr
 8001a76:	bf00      	nop
 8001a78:	50060800 	.word	0x50060800
 8001a7c:	40023800 	.word	0x40023800

08001a80 <HAL_RNG_MspDeInit>:
  * This function freeze the hardware resources used in this example
  * @param hrng: RNG handle pointer
  * @retval None
  */
void HAL_RNG_MspDeInit(RNG_HandleTypeDef* hrng)
{
 8001a80:	b480      	push	{r7}
 8001a82:	b083      	sub	sp, #12
 8001a84:	af00      	add	r7, sp, #0
 8001a86:	6078      	str	r0, [r7, #4]
  if(hrng->Instance==RNG)
 8001a88:	687b      	ldr	r3, [r7, #4]
 8001a8a:	681b      	ldr	r3, [r3, #0]
 8001a8c:	4a07      	ldr	r2, [pc, #28]	@ (8001aac <HAL_RNG_MspDeInit+0x2c>)
 8001a8e:	4293      	cmp	r3, r2
 8001a90:	d105      	bne.n	8001a9e <HAL_RNG_MspDeInit+0x1e>
  {
    /* USER CODE BEGIN RNG_MspDeInit 0 */

    /* USER CODE END RNG_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_RNG_CLK_DISABLE();
 8001a92:	4b07      	ldr	r3, [pc, #28]	@ (8001ab0 <HAL_RNG_MspDeInit+0x30>)
 8001a94:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8001a96:	4a06      	ldr	r2, [pc, #24]	@ (8001ab0 <HAL_RNG_MspDeInit+0x30>)
 8001a98:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8001a9c:	6353      	str	r3, [r2, #52]	@ 0x34
    /* USER CODE BEGIN RNG_MspDeInit 1 */

    /* USER CODE END RNG_MspDeInit 1 */
  }

}
 8001a9e:	bf00      	nop
 8001aa0:	370c      	adds	r7, #12
 8001aa2:	46bd      	mov	sp, r7
 8001aa4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001aa8:	4770      	bx	lr
 8001aaa:	bf00      	nop
 8001aac:	50060800 	.word	0x50060800
 8001ab0:	40023800 	.word	0x40023800

08001ab4 <HAL_SPI_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hspi: SPI handle pointer
  * @retval None
  */
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8001ab4:	b580      	push	{r7, lr}
 8001ab6:	b08a      	sub	sp, #40	@ 0x28
 8001ab8:	af00      	add	r7, sp, #0
 8001aba:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001abc:	f107 0314 	add.w	r3, r7, #20
 8001ac0:	2200      	movs	r2, #0
 8001ac2:	601a      	str	r2, [r3, #0]
 8001ac4:	605a      	str	r2, [r3, #4]
 8001ac6:	609a      	str	r2, [r3, #8]
 8001ac8:	60da      	str	r2, [r3, #12]
 8001aca:	611a      	str	r2, [r3, #16]
  if(hspi->Instance==SPI1)
 8001acc:	687b      	ldr	r3, [r7, #4]
 8001ace:	681b      	ldr	r3, [r3, #0]
 8001ad0:	4a19      	ldr	r2, [pc, #100]	@ (8001b38 <HAL_SPI_MspInit+0x84>)
 8001ad2:	4293      	cmp	r3, r2
 8001ad4:	d12b      	bne.n	8001b2e <HAL_SPI_MspInit+0x7a>
  {
    /* USER CODE BEGIN SPI1_MspInit 0 */

    /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8001ad6:	2300      	movs	r3, #0
 8001ad8:	613b      	str	r3, [r7, #16]
 8001ada:	4b18      	ldr	r3, [pc, #96]	@ (8001b3c <HAL_SPI_MspInit+0x88>)
 8001adc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8001ade:	4a17      	ldr	r2, [pc, #92]	@ (8001b3c <HAL_SPI_MspInit+0x88>)
 8001ae0:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8001ae4:	6453      	str	r3, [r2, #68]	@ 0x44
 8001ae6:	4b15      	ldr	r3, [pc, #84]	@ (8001b3c <HAL_SPI_MspInit+0x88>)
 8001ae8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8001aea:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8001aee:	613b      	str	r3, [r7, #16]
 8001af0:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001af2:	2300      	movs	r3, #0
 8001af4:	60fb      	str	r3, [r7, #12]
 8001af6:	4b11      	ldr	r3, [pc, #68]	@ (8001b3c <HAL_SPI_MspInit+0x88>)
 8001af8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001afa:	4a10      	ldr	r2, [pc, #64]	@ (8001b3c <HAL_SPI_MspInit+0x88>)
 8001afc:	f043 0301 	orr.w	r3, r3, #1
 8001b00:	6313      	str	r3, [r2, #48]	@ 0x30
 8001b02:	4b0e      	ldr	r3, [pc, #56]	@ (8001b3c <HAL_SPI_MspInit+0x88>)
 8001b04:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001b06:	f003 0301 	and.w	r3, r3, #1
 8001b0a:	60fb      	str	r3, [r7, #12]
 8001b0c:	68fb      	ldr	r3, [r7, #12]
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = SPI1_SCK_Pin|SPI1_MISO_Pin|SPI1_MOSI_Pin;
 8001b0e:	23e0      	movs	r3, #224	@ 0xe0
 8001b10:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b12:	2302      	movs	r3, #2
 8001b14:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001b16:	2300      	movs	r3, #0
 8001b18:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001b1a:	2300      	movs	r3, #0
 8001b1c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8001b1e:	2305      	movs	r3, #5
 8001b20:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001b22:	f107 0314 	add.w	r3, r7, #20
 8001b26:	4619      	mov	r1, r3
 8001b28:	4805      	ldr	r0, [pc, #20]	@ (8001b40 <HAL_SPI_MspInit+0x8c>)
 8001b2a:	f000 fa9f 	bl	800206c <HAL_GPIO_Init>

    /* USER CODE END SPI1_MspInit 1 */

  }

}
 8001b2e:	bf00      	nop
 8001b30:	3728      	adds	r7, #40	@ 0x28
 8001b32:	46bd      	mov	sp, r7
 8001b34:	bd80      	pop	{r7, pc}
 8001b36:	bf00      	nop
 8001b38:	40013000 	.word	0x40013000
 8001b3c:	40023800 	.word	0x40023800
 8001b40:	40020000 	.word	0x40020000

08001b44 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8001b44:	b480      	push	{r7}
 8001b46:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8001b48:	bf00      	nop
 8001b4a:	e7fd      	b.n	8001b48 <NMI_Handler+0x4>

08001b4c <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8001b4c:	b480      	push	{r7}
 8001b4e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001b50:	bf00      	nop
 8001b52:	e7fd      	b.n	8001b50 <HardFault_Handler+0x4>

08001b54 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8001b54:	b480      	push	{r7}
 8001b56:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001b58:	bf00      	nop
 8001b5a:	e7fd      	b.n	8001b58 <MemManage_Handler+0x4>

08001b5c <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8001b5c:	b480      	push	{r7}
 8001b5e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001b60:	bf00      	nop
 8001b62:	e7fd      	b.n	8001b60 <BusFault_Handler+0x4>

08001b64 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8001b64:	b480      	push	{r7}
 8001b66:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001b68:	bf00      	nop
 8001b6a:	e7fd      	b.n	8001b68 <UsageFault_Handler+0x4>

08001b6c <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8001b6c:	b480      	push	{r7}
 8001b6e:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8001b70:	bf00      	nop
 8001b72:	46bd      	mov	sp, r7
 8001b74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b78:	4770      	bx	lr

08001b7a <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8001b7a:	b480      	push	{r7}
 8001b7c:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8001b7e:	bf00      	nop
 8001b80:	46bd      	mov	sp, r7
 8001b82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b86:	4770      	bx	lr

08001b88 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8001b88:	b480      	push	{r7}
 8001b8a:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8001b8c:	bf00      	nop
 8001b8e:	46bd      	mov	sp, r7
 8001b90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b94:	4770      	bx	lr

08001b96 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8001b96:	b580      	push	{r7, lr}
 8001b98:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8001b9a:	f000 f8d1 	bl	8001d40 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8001b9e:	bf00      	nop
 8001ba0:	bd80      	pop	{r7, pc}
	...

08001ba4 <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 8001ba4:	b580      	push	{r7, lr}
 8001ba6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8001ba8:	4802      	ldr	r0, [pc, #8]	@ (8001bb4 <OTG_FS_IRQHandler+0x10>)
 8001baa:	f001 fb55 	bl	8003258 <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 8001bae:	bf00      	nop
 8001bb0:	bd80      	pop	{r7, pc}
 8001bb2:	bf00      	nop
 8001bb4:	20003c00 	.word	0x20003c00

08001bb8 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001bb8:	b580      	push	{r7, lr}
 8001bba:	b086      	sub	sp, #24
 8001bbc:	af00      	add	r7, sp, #0
 8001bbe:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001bc0:	4a14      	ldr	r2, [pc, #80]	@ (8001c14 <_sbrk+0x5c>)
 8001bc2:	4b15      	ldr	r3, [pc, #84]	@ (8001c18 <_sbrk+0x60>)
 8001bc4:	1ad3      	subs	r3, r2, r3
 8001bc6:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8001bc8:	697b      	ldr	r3, [r7, #20]
 8001bca:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001bcc:	4b13      	ldr	r3, [pc, #76]	@ (8001c1c <_sbrk+0x64>)
 8001bce:	681b      	ldr	r3, [r3, #0]
 8001bd0:	2b00      	cmp	r3, #0
 8001bd2:	d102      	bne.n	8001bda <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8001bd4:	4b11      	ldr	r3, [pc, #68]	@ (8001c1c <_sbrk+0x64>)
 8001bd6:	4a12      	ldr	r2, [pc, #72]	@ (8001c20 <_sbrk+0x68>)
 8001bd8:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001bda:	4b10      	ldr	r3, [pc, #64]	@ (8001c1c <_sbrk+0x64>)
 8001bdc:	681a      	ldr	r2, [r3, #0]
 8001bde:	687b      	ldr	r3, [r7, #4]
 8001be0:	4413      	add	r3, r2
 8001be2:	693a      	ldr	r2, [r7, #16]
 8001be4:	429a      	cmp	r2, r3
 8001be6:	d207      	bcs.n	8001bf8 <_sbrk+0x40>
  {
    errno = ENOMEM;
 8001be8:	f026 fcb0 	bl	802854c <__errno>
 8001bec:	4603      	mov	r3, r0
 8001bee:	220c      	movs	r2, #12
 8001bf0:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8001bf2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8001bf6:	e009      	b.n	8001c0c <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8001bf8:	4b08      	ldr	r3, [pc, #32]	@ (8001c1c <_sbrk+0x64>)
 8001bfa:	681b      	ldr	r3, [r3, #0]
 8001bfc:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8001bfe:	4b07      	ldr	r3, [pc, #28]	@ (8001c1c <_sbrk+0x64>)
 8001c00:	681a      	ldr	r2, [r3, #0]
 8001c02:	687b      	ldr	r3, [r7, #4]
 8001c04:	4413      	add	r3, r2
 8001c06:	4a05      	ldr	r2, [pc, #20]	@ (8001c1c <_sbrk+0x64>)
 8001c08:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8001c0a:	68fb      	ldr	r3, [r7, #12]
}
 8001c0c:	4618      	mov	r0, r3
 8001c0e:	3718      	adds	r7, #24
 8001c10:	46bd      	mov	sp, r7
 8001c12:	bd80      	pop	{r7, pc}
 8001c14:	20020000 	.word	0x20020000
 8001c18:	00000400 	.word	0x00000400
 8001c1c:	200026a8 	.word	0x200026a8
 8001c20:	20004450 	.word	0x20004450

08001c24 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8001c24:	b480      	push	{r7}
 8001c26:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001c28:	4b06      	ldr	r3, [pc, #24]	@ (8001c44 <SystemInit+0x20>)
 8001c2a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8001c2e:	4a05      	ldr	r2, [pc, #20]	@ (8001c44 <SystemInit+0x20>)
 8001c30:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8001c34:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8001c38:	bf00      	nop
 8001c3a:	46bd      	mov	sp, r7
 8001c3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c40:	4770      	bx	lr
 8001c42:	bf00      	nop
 8001c44:	e000ed00 	.word	0xe000ed00

08001c48 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8001c48:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8001c80 <LoopFillZerobss+0xe>
  
/* Call the clock system initialization function.*/
  bl  SystemInit  
 8001c4c:	f7ff ffea 	bl	8001c24 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8001c50:	480c      	ldr	r0, [pc, #48]	@ (8001c84 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8001c52:	490d      	ldr	r1, [pc, #52]	@ (8001c88 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8001c54:	4a0d      	ldr	r2, [pc, #52]	@ (8001c8c <LoopFillZerobss+0x1a>)
  movs r3, #0
 8001c56:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001c58:	e002      	b.n	8001c60 <LoopCopyDataInit>

08001c5a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001c5a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001c5c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001c5e:	3304      	adds	r3, #4

08001c60 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001c60:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001c62:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001c64:	d3f9      	bcc.n	8001c5a <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001c66:	4a0a      	ldr	r2, [pc, #40]	@ (8001c90 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001c68:	4c0a      	ldr	r4, [pc, #40]	@ (8001c94 <LoopFillZerobss+0x22>)
  movs r3, #0
 8001c6a:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001c6c:	e001      	b.n	8001c72 <LoopFillZerobss>

08001c6e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001c6e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001c70:	3204      	adds	r2, #4

08001c72 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001c72:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001c74:	d3fb      	bcc.n	8001c6e <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8001c76:	f026 fc6f 	bl	8028558 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001c7a:	f7ff fb83 	bl	8001384 <main>
  bx  lr    
 8001c7e:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 8001c80:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8001c84:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001c88:	20000184 	.word	0x20000184
  ldr r2, =_sidata
 8001c8c:	08033de0 	.word	0x08033de0
  ldr r2, =_sbss
 8001c90:	20000184 	.word	0x20000184
  ldr r4, =_ebss
 8001c94:	2000444c 	.word	0x2000444c

08001c98 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001c98:	e7fe      	b.n	8001c98 <ADC_IRQHandler>
	...

08001c9c <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001c9c:	b580      	push	{r7, lr}
 8001c9e:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001ca0:	4b0e      	ldr	r3, [pc, #56]	@ (8001cdc <HAL_Init+0x40>)
 8001ca2:	681b      	ldr	r3, [r3, #0]
 8001ca4:	4a0d      	ldr	r2, [pc, #52]	@ (8001cdc <HAL_Init+0x40>)
 8001ca6:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8001caa:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8001cac:	4b0b      	ldr	r3, [pc, #44]	@ (8001cdc <HAL_Init+0x40>)
 8001cae:	681b      	ldr	r3, [r3, #0]
 8001cb0:	4a0a      	ldr	r2, [pc, #40]	@ (8001cdc <HAL_Init+0x40>)
 8001cb2:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8001cb6:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001cb8:	4b08      	ldr	r3, [pc, #32]	@ (8001cdc <HAL_Init+0x40>)
 8001cba:	681b      	ldr	r3, [r3, #0]
 8001cbc:	4a07      	ldr	r2, [pc, #28]	@ (8001cdc <HAL_Init+0x40>)
 8001cbe:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001cc2:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001cc4:	2003      	movs	r0, #3
 8001cc6:	f000 f973 	bl	8001fb0 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001cca:	2000      	movs	r0, #0
 8001ccc:	f000 f808 	bl	8001ce0 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8001cd0:	f7ff fda2 	bl	8001818 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8001cd4:	2300      	movs	r3, #0
}
 8001cd6:	4618      	mov	r0, r3
 8001cd8:	bd80      	pop	{r7, pc}
 8001cda:	bf00      	nop
 8001cdc:	40023c00 	.word	0x40023c00

08001ce0 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001ce0:	b580      	push	{r7, lr}
 8001ce2:	b082      	sub	sp, #8
 8001ce4:	af00      	add	r7, sp, #0
 8001ce6:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8001ce8:	4b12      	ldr	r3, [pc, #72]	@ (8001d34 <HAL_InitTick+0x54>)
 8001cea:	681a      	ldr	r2, [r3, #0]
 8001cec:	4b12      	ldr	r3, [pc, #72]	@ (8001d38 <HAL_InitTick+0x58>)
 8001cee:	781b      	ldrb	r3, [r3, #0]
 8001cf0:	4619      	mov	r1, r3
 8001cf2:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8001cf6:	fbb3 f3f1 	udiv	r3, r3, r1
 8001cfa:	fbb2 f3f3 	udiv	r3, r2, r3
 8001cfe:	4618      	mov	r0, r3
 8001d00:	f000 f98b 	bl	800201a <HAL_SYSTICK_Config>
 8001d04:	4603      	mov	r3, r0
 8001d06:	2b00      	cmp	r3, #0
 8001d08:	d001      	beq.n	8001d0e <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 8001d0a:	2301      	movs	r3, #1
 8001d0c:	e00e      	b.n	8001d2c <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001d0e:	687b      	ldr	r3, [r7, #4]
 8001d10:	2b0f      	cmp	r3, #15
 8001d12:	d80a      	bhi.n	8001d2a <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001d14:	2200      	movs	r2, #0
 8001d16:	6879      	ldr	r1, [r7, #4]
 8001d18:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8001d1c:	f000 f953 	bl	8001fc6 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8001d20:	4a06      	ldr	r2, [pc, #24]	@ (8001d3c <HAL_InitTick+0x5c>)
 8001d22:	687b      	ldr	r3, [r7, #4]
 8001d24:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8001d26:	2300      	movs	r3, #0
 8001d28:	e000      	b.n	8001d2c <HAL_InitTick+0x4c>
    return HAL_ERROR;
 8001d2a:	2301      	movs	r3, #1
}
 8001d2c:	4618      	mov	r0, r3
 8001d2e:	3708      	adds	r7, #8
 8001d30:	46bd      	mov	sp, r7
 8001d32:	bd80      	pop	{r7, pc}
 8001d34:	20000018 	.word	0x20000018
 8001d38:	20000020 	.word	0x20000020
 8001d3c:	2000001c 	.word	0x2000001c

08001d40 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8001d40:	b480      	push	{r7}
 8001d42:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8001d44:	4b06      	ldr	r3, [pc, #24]	@ (8001d60 <HAL_IncTick+0x20>)
 8001d46:	781b      	ldrb	r3, [r3, #0]
 8001d48:	461a      	mov	r2, r3
 8001d4a:	4b06      	ldr	r3, [pc, #24]	@ (8001d64 <HAL_IncTick+0x24>)
 8001d4c:	681b      	ldr	r3, [r3, #0]
 8001d4e:	4413      	add	r3, r2
 8001d50:	4a04      	ldr	r2, [pc, #16]	@ (8001d64 <HAL_IncTick+0x24>)
 8001d52:	6013      	str	r3, [r2, #0]
}
 8001d54:	bf00      	nop
 8001d56:	46bd      	mov	sp, r7
 8001d58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d5c:	4770      	bx	lr
 8001d5e:	bf00      	nop
 8001d60:	20000020 	.word	0x20000020
 8001d64:	200026ac 	.word	0x200026ac

08001d68 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001d68:	b480      	push	{r7}
 8001d6a:	af00      	add	r7, sp, #0
  return uwTick;
 8001d6c:	4b03      	ldr	r3, [pc, #12]	@ (8001d7c <HAL_GetTick+0x14>)
 8001d6e:	681b      	ldr	r3, [r3, #0]
}
 8001d70:	4618      	mov	r0, r3
 8001d72:	46bd      	mov	sp, r7
 8001d74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d78:	4770      	bx	lr
 8001d7a:	bf00      	nop
 8001d7c:	200026ac 	.word	0x200026ac

08001d80 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001d80:	b580      	push	{r7, lr}
 8001d82:	b084      	sub	sp, #16
 8001d84:	af00      	add	r7, sp, #0
 8001d86:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8001d88:	f7ff ffee 	bl	8001d68 <HAL_GetTick>
 8001d8c:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8001d8e:	687b      	ldr	r3, [r7, #4]
 8001d90:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001d92:	68fb      	ldr	r3, [r7, #12]
 8001d94:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8001d98:	d005      	beq.n	8001da6 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8001d9a:	4b0a      	ldr	r3, [pc, #40]	@ (8001dc4 <HAL_Delay+0x44>)
 8001d9c:	781b      	ldrb	r3, [r3, #0]
 8001d9e:	461a      	mov	r2, r3
 8001da0:	68fb      	ldr	r3, [r7, #12]
 8001da2:	4413      	add	r3, r2
 8001da4:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8001da6:	bf00      	nop
 8001da8:	f7ff ffde 	bl	8001d68 <HAL_GetTick>
 8001dac:	4602      	mov	r2, r0
 8001dae:	68bb      	ldr	r3, [r7, #8]
 8001db0:	1ad3      	subs	r3, r2, r3
 8001db2:	68fa      	ldr	r2, [r7, #12]
 8001db4:	429a      	cmp	r2, r3
 8001db6:	d8f7      	bhi.n	8001da8 <HAL_Delay+0x28>
  {
  }
}
 8001db8:	bf00      	nop
 8001dba:	bf00      	nop
 8001dbc:	3710      	adds	r7, #16
 8001dbe:	46bd      	mov	sp, r7
 8001dc0:	bd80      	pop	{r7, pc}
 8001dc2:	bf00      	nop
 8001dc4:	20000020 	.word	0x20000020

08001dc8 <HAL_GetUIDw0>:
/**
  * @brief  Returns first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
 8001dc8:	b480      	push	{r7}
 8001dca:	af00      	add	r7, sp, #0
  return (READ_REG(*((uint32_t *)UID_BASE)));
 8001dcc:	4b03      	ldr	r3, [pc, #12]	@ (8001ddc <HAL_GetUIDw0+0x14>)
 8001dce:	681b      	ldr	r3, [r3, #0]
}
 8001dd0:	4618      	mov	r0, r3
 8001dd2:	46bd      	mov	sp, r7
 8001dd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001dd8:	4770      	bx	lr
 8001dda:	bf00      	nop
 8001ddc:	1fff7a10 	.word	0x1fff7a10

08001de0 <HAL_GetUIDw1>:
/**
  * @brief  Returns second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
 8001de0:	b480      	push	{r7}
 8001de2:	af00      	add	r7, sp, #0
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
 8001de4:	4b03      	ldr	r3, [pc, #12]	@ (8001df4 <HAL_GetUIDw1+0x14>)
 8001de6:	681b      	ldr	r3, [r3, #0]
}
 8001de8:	4618      	mov	r0, r3
 8001dea:	46bd      	mov	sp, r7
 8001dec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001df0:	4770      	bx	lr
 8001df2:	bf00      	nop
 8001df4:	1fff7a14 	.word	0x1fff7a14

08001df8 <HAL_GetUIDw2>:
/**
  * @brief  Returns third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
 8001df8:	b480      	push	{r7}
 8001dfa:	af00      	add	r7, sp, #0
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
 8001dfc:	4b03      	ldr	r3, [pc, #12]	@ (8001e0c <HAL_GetUIDw2+0x14>)
 8001dfe:	681b      	ldr	r3, [r3, #0]
}
 8001e00:	4618      	mov	r0, r3
 8001e02:	46bd      	mov	sp, r7
 8001e04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e08:	4770      	bx	lr
 8001e0a:	bf00      	nop
 8001e0c:	1fff7a18 	.word	0x1fff7a18

08001e10 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001e10:	b480      	push	{r7}
 8001e12:	b085      	sub	sp, #20
 8001e14:	af00      	add	r7, sp, #0
 8001e16:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8001e18:	687b      	ldr	r3, [r7, #4]
 8001e1a:	f003 0307 	and.w	r3, r3, #7
 8001e1e:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001e20:	4b0c      	ldr	r3, [pc, #48]	@ (8001e54 <__NVIC_SetPriorityGrouping+0x44>)
 8001e22:	68db      	ldr	r3, [r3, #12]
 8001e24:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001e26:	68ba      	ldr	r2, [r7, #8]
 8001e28:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8001e2c:	4013      	ands	r3, r2
 8001e2e:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001e30:	68fb      	ldr	r3, [r7, #12]
 8001e32:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001e34:	68bb      	ldr	r3, [r7, #8]
 8001e36:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001e38:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8001e3c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8001e40:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8001e42:	4a04      	ldr	r2, [pc, #16]	@ (8001e54 <__NVIC_SetPriorityGrouping+0x44>)
 8001e44:	68bb      	ldr	r3, [r7, #8]
 8001e46:	60d3      	str	r3, [r2, #12]
}
 8001e48:	bf00      	nop
 8001e4a:	3714      	adds	r7, #20
 8001e4c:	46bd      	mov	sp, r7
 8001e4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e52:	4770      	bx	lr
 8001e54:	e000ed00 	.word	0xe000ed00

08001e58 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001e58:	b480      	push	{r7}
 8001e5a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001e5c:	4b04      	ldr	r3, [pc, #16]	@ (8001e70 <__NVIC_GetPriorityGrouping+0x18>)
 8001e5e:	68db      	ldr	r3, [r3, #12]
 8001e60:	0a1b      	lsrs	r3, r3, #8
 8001e62:	f003 0307 	and.w	r3, r3, #7
}
 8001e66:	4618      	mov	r0, r3
 8001e68:	46bd      	mov	sp, r7
 8001e6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e6e:	4770      	bx	lr
 8001e70:	e000ed00 	.word	0xe000ed00

08001e74 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001e74:	b480      	push	{r7}
 8001e76:	b083      	sub	sp, #12
 8001e78:	af00      	add	r7, sp, #0
 8001e7a:	4603      	mov	r3, r0
 8001e7c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001e7e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001e82:	2b00      	cmp	r3, #0
 8001e84:	db0b      	blt.n	8001e9e <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001e86:	79fb      	ldrb	r3, [r7, #7]
 8001e88:	f003 021f 	and.w	r2, r3, #31
 8001e8c:	4907      	ldr	r1, [pc, #28]	@ (8001eac <__NVIC_EnableIRQ+0x38>)
 8001e8e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001e92:	095b      	lsrs	r3, r3, #5
 8001e94:	2001      	movs	r0, #1
 8001e96:	fa00 f202 	lsl.w	r2, r0, r2
 8001e9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8001e9e:	bf00      	nop
 8001ea0:	370c      	adds	r7, #12
 8001ea2:	46bd      	mov	sp, r7
 8001ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ea8:	4770      	bx	lr
 8001eaa:	bf00      	nop
 8001eac:	e000e100 	.word	0xe000e100

08001eb0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001eb0:	b480      	push	{r7}
 8001eb2:	b083      	sub	sp, #12
 8001eb4:	af00      	add	r7, sp, #0
 8001eb6:	4603      	mov	r3, r0
 8001eb8:	6039      	str	r1, [r7, #0]
 8001eba:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001ebc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001ec0:	2b00      	cmp	r3, #0
 8001ec2:	db0a      	blt.n	8001eda <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001ec4:	683b      	ldr	r3, [r7, #0]
 8001ec6:	b2da      	uxtb	r2, r3
 8001ec8:	490c      	ldr	r1, [pc, #48]	@ (8001efc <__NVIC_SetPriority+0x4c>)
 8001eca:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001ece:	0112      	lsls	r2, r2, #4
 8001ed0:	b2d2      	uxtb	r2, r2
 8001ed2:	440b      	add	r3, r1
 8001ed4:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8001ed8:	e00a      	b.n	8001ef0 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001eda:	683b      	ldr	r3, [r7, #0]
 8001edc:	b2da      	uxtb	r2, r3
 8001ede:	4908      	ldr	r1, [pc, #32]	@ (8001f00 <__NVIC_SetPriority+0x50>)
 8001ee0:	79fb      	ldrb	r3, [r7, #7]
 8001ee2:	f003 030f 	and.w	r3, r3, #15
 8001ee6:	3b04      	subs	r3, #4
 8001ee8:	0112      	lsls	r2, r2, #4
 8001eea:	b2d2      	uxtb	r2, r2
 8001eec:	440b      	add	r3, r1
 8001eee:	761a      	strb	r2, [r3, #24]
}
 8001ef0:	bf00      	nop
 8001ef2:	370c      	adds	r7, #12
 8001ef4:	46bd      	mov	sp, r7
 8001ef6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001efa:	4770      	bx	lr
 8001efc:	e000e100 	.word	0xe000e100
 8001f00:	e000ed00 	.word	0xe000ed00

08001f04 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001f04:	b480      	push	{r7}
 8001f06:	b089      	sub	sp, #36	@ 0x24
 8001f08:	af00      	add	r7, sp, #0
 8001f0a:	60f8      	str	r0, [r7, #12]
 8001f0c:	60b9      	str	r1, [r7, #8]
 8001f0e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001f10:	68fb      	ldr	r3, [r7, #12]
 8001f12:	f003 0307 	and.w	r3, r3, #7
 8001f16:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001f18:	69fb      	ldr	r3, [r7, #28]
 8001f1a:	f1c3 0307 	rsb	r3, r3, #7
 8001f1e:	2b04      	cmp	r3, #4
 8001f20:	bf28      	it	cs
 8001f22:	2304      	movcs	r3, #4
 8001f24:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001f26:	69fb      	ldr	r3, [r7, #28]
 8001f28:	3304      	adds	r3, #4
 8001f2a:	2b06      	cmp	r3, #6
 8001f2c:	d902      	bls.n	8001f34 <NVIC_EncodePriority+0x30>
 8001f2e:	69fb      	ldr	r3, [r7, #28]
 8001f30:	3b03      	subs	r3, #3
 8001f32:	e000      	b.n	8001f36 <NVIC_EncodePriority+0x32>
 8001f34:	2300      	movs	r3, #0
 8001f36:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001f38:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8001f3c:	69bb      	ldr	r3, [r7, #24]
 8001f3e:	fa02 f303 	lsl.w	r3, r2, r3
 8001f42:	43da      	mvns	r2, r3
 8001f44:	68bb      	ldr	r3, [r7, #8]
 8001f46:	401a      	ands	r2, r3
 8001f48:	697b      	ldr	r3, [r7, #20]
 8001f4a:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001f4c:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8001f50:	697b      	ldr	r3, [r7, #20]
 8001f52:	fa01 f303 	lsl.w	r3, r1, r3
 8001f56:	43d9      	mvns	r1, r3
 8001f58:	687b      	ldr	r3, [r7, #4]
 8001f5a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001f5c:	4313      	orrs	r3, r2
         );
}
 8001f5e:	4618      	mov	r0, r3
 8001f60:	3724      	adds	r7, #36	@ 0x24
 8001f62:	46bd      	mov	sp, r7
 8001f64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f68:	4770      	bx	lr
	...

08001f6c <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8001f6c:	b580      	push	{r7, lr}
 8001f6e:	b082      	sub	sp, #8
 8001f70:	af00      	add	r7, sp, #0
 8001f72:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001f74:	687b      	ldr	r3, [r7, #4]
 8001f76:	3b01      	subs	r3, #1
 8001f78:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8001f7c:	d301      	bcc.n	8001f82 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8001f7e:	2301      	movs	r3, #1
 8001f80:	e00f      	b.n	8001fa2 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001f82:	4a0a      	ldr	r2, [pc, #40]	@ (8001fac <SysTick_Config+0x40>)
 8001f84:	687b      	ldr	r3, [r7, #4]
 8001f86:	3b01      	subs	r3, #1
 8001f88:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8001f8a:	210f      	movs	r1, #15
 8001f8c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8001f90:	f7ff ff8e 	bl	8001eb0 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001f94:	4b05      	ldr	r3, [pc, #20]	@ (8001fac <SysTick_Config+0x40>)
 8001f96:	2200      	movs	r2, #0
 8001f98:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001f9a:	4b04      	ldr	r3, [pc, #16]	@ (8001fac <SysTick_Config+0x40>)
 8001f9c:	2207      	movs	r2, #7
 8001f9e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8001fa0:	2300      	movs	r3, #0
}
 8001fa2:	4618      	mov	r0, r3
 8001fa4:	3708      	adds	r7, #8
 8001fa6:	46bd      	mov	sp, r7
 8001fa8:	bd80      	pop	{r7, pc}
 8001faa:	bf00      	nop
 8001fac:	e000e010 	.word	0xe000e010

08001fb0 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001fb0:	b580      	push	{r7, lr}
 8001fb2:	b082      	sub	sp, #8
 8001fb4:	af00      	add	r7, sp, #0
 8001fb6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8001fb8:	6878      	ldr	r0, [r7, #4]
 8001fba:	f7ff ff29 	bl	8001e10 <__NVIC_SetPriorityGrouping>
}
 8001fbe:	bf00      	nop
 8001fc0:	3708      	adds	r7, #8
 8001fc2:	46bd      	mov	sp, r7
 8001fc4:	bd80      	pop	{r7, pc}

08001fc6 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001fc6:	b580      	push	{r7, lr}
 8001fc8:	b086      	sub	sp, #24
 8001fca:	af00      	add	r7, sp, #0
 8001fcc:	4603      	mov	r3, r0
 8001fce:	60b9      	str	r1, [r7, #8]
 8001fd0:	607a      	str	r2, [r7, #4]
 8001fd2:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8001fd4:	2300      	movs	r3, #0
 8001fd6:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8001fd8:	f7ff ff3e 	bl	8001e58 <__NVIC_GetPriorityGrouping>
 8001fdc:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8001fde:	687a      	ldr	r2, [r7, #4]
 8001fe0:	68b9      	ldr	r1, [r7, #8]
 8001fe2:	6978      	ldr	r0, [r7, #20]
 8001fe4:	f7ff ff8e 	bl	8001f04 <NVIC_EncodePriority>
 8001fe8:	4602      	mov	r2, r0
 8001fea:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8001fee:	4611      	mov	r1, r2
 8001ff0:	4618      	mov	r0, r3
 8001ff2:	f7ff ff5d 	bl	8001eb0 <__NVIC_SetPriority>
}
 8001ff6:	bf00      	nop
 8001ff8:	3718      	adds	r7, #24
 8001ffa:	46bd      	mov	sp, r7
 8001ffc:	bd80      	pop	{r7, pc}

08001ffe <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001ffe:	b580      	push	{r7, lr}
 8002000:	b082      	sub	sp, #8
 8002002:	af00      	add	r7, sp, #0
 8002004:	4603      	mov	r3, r0
 8002006:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8002008:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800200c:	4618      	mov	r0, r3
 800200e:	f7ff ff31 	bl	8001e74 <__NVIC_EnableIRQ>
}
 8002012:	bf00      	nop
 8002014:	3708      	adds	r7, #8
 8002016:	46bd      	mov	sp, r7
 8002018:	bd80      	pop	{r7, pc}

0800201a <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800201a:	b580      	push	{r7, lr}
 800201c:	b082      	sub	sp, #8
 800201e:	af00      	add	r7, sp, #0
 8002020:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8002022:	6878      	ldr	r0, [r7, #4]
 8002024:	f7ff ffa2 	bl	8001f6c <SysTick_Config>
 8002028:	4603      	mov	r3, r0
}
 800202a:	4618      	mov	r0, r3
 800202c:	3708      	adds	r7, #8
 800202e:	46bd      	mov	sp, r7
 8002030:	bd80      	pop	{r7, pc}

08002032 <HAL_CRC_Init>:
  *         parameters in the CRC_InitTypeDef and create the associated handle.
  * @param  hcrc CRC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 8002032:	b580      	push	{r7, lr}
 8002034:	b082      	sub	sp, #8
 8002036:	af00      	add	r7, sp, #0
 8002038:	6078      	str	r0, [r7, #4]
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 800203a:	687b      	ldr	r3, [r7, #4]
 800203c:	2b00      	cmp	r3, #0
 800203e:	d101      	bne.n	8002044 <HAL_CRC_Init+0x12>
  {
    return HAL_ERROR;
 8002040:	2301      	movs	r3, #1
 8002042:	e00e      	b.n	8002062 <HAL_CRC_Init+0x30>
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 8002044:	687b      	ldr	r3, [r7, #4]
 8002046:	795b      	ldrb	r3, [r3, #5]
 8002048:	b2db      	uxtb	r3, r3
 800204a:	2b00      	cmp	r3, #0
 800204c:	d105      	bne.n	800205a <HAL_CRC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 800204e:	687b      	ldr	r3, [r7, #4]
 8002050:	2200      	movs	r2, #0
 8002052:	711a      	strb	r2, [r3, #4]
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 8002054:	6878      	ldr	r0, [r7, #4]
 8002056:	f7ff fc07 	bl	8001868 <HAL_CRC_MspInit>
  }

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 800205a:	687b      	ldr	r3, [r7, #4]
 800205c:	2201      	movs	r2, #1
 800205e:	715a      	strb	r2, [r3, #5]

  /* Return function status */
  return HAL_OK;
 8002060:	2300      	movs	r3, #0
}
 8002062:	4618      	mov	r0, r3
 8002064:	3708      	adds	r7, #8
 8002066:	46bd      	mov	sp, r7
 8002068:	bd80      	pop	{r7, pc}
	...

0800206c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800206c:	b480      	push	{r7}
 800206e:	b089      	sub	sp, #36	@ 0x24
 8002070:	af00      	add	r7, sp, #0
 8002072:	6078      	str	r0, [r7, #4]
 8002074:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 8002076:	2300      	movs	r3, #0
 8002078:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 800207a:	2300      	movs	r3, #0
 800207c:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 800207e:	2300      	movs	r3, #0
 8002080:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002082:	2300      	movs	r3, #0
 8002084:	61fb      	str	r3, [r7, #28]
 8002086:	e16b      	b.n	8002360 <HAL_GPIO_Init+0x2f4>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 8002088:	2201      	movs	r2, #1
 800208a:	69fb      	ldr	r3, [r7, #28]
 800208c:	fa02 f303 	lsl.w	r3, r2, r3
 8002090:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8002092:	683b      	ldr	r3, [r7, #0]
 8002094:	681b      	ldr	r3, [r3, #0]
 8002096:	697a      	ldr	r2, [r7, #20]
 8002098:	4013      	ands	r3, r2
 800209a:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 800209c:	693a      	ldr	r2, [r7, #16]
 800209e:	697b      	ldr	r3, [r7, #20]
 80020a0:	429a      	cmp	r2, r3
 80020a2:	f040 815a 	bne.w	800235a <HAL_GPIO_Init+0x2ee>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 80020a6:	683b      	ldr	r3, [r7, #0]
 80020a8:	685b      	ldr	r3, [r3, #4]
 80020aa:	f003 0303 	and.w	r3, r3, #3
 80020ae:	2b01      	cmp	r3, #1
 80020b0:	d005      	beq.n	80020be <HAL_GPIO_Init+0x52>
          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80020b2:	683b      	ldr	r3, [r7, #0]
 80020b4:	685b      	ldr	r3, [r3, #4]
 80020b6:	f003 0303 	and.w	r3, r3, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 80020ba:	2b02      	cmp	r3, #2
 80020bc:	d130      	bne.n	8002120 <HAL_GPIO_Init+0xb4>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 80020be:	687b      	ldr	r3, [r7, #4]
 80020c0:	689b      	ldr	r3, [r3, #8]
 80020c2:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80020c4:	69fb      	ldr	r3, [r7, #28]
 80020c6:	005b      	lsls	r3, r3, #1
 80020c8:	2203      	movs	r2, #3
 80020ca:	fa02 f303 	lsl.w	r3, r2, r3
 80020ce:	43db      	mvns	r3, r3
 80020d0:	69ba      	ldr	r2, [r7, #24]
 80020d2:	4013      	ands	r3, r2
 80020d4:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 80020d6:	683b      	ldr	r3, [r7, #0]
 80020d8:	68da      	ldr	r2, [r3, #12]
 80020da:	69fb      	ldr	r3, [r7, #28]
 80020dc:	005b      	lsls	r3, r3, #1
 80020de:	fa02 f303 	lsl.w	r3, r2, r3
 80020e2:	69ba      	ldr	r2, [r7, #24]
 80020e4:	4313      	orrs	r3, r2
 80020e6:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 80020e8:	687b      	ldr	r3, [r7, #4]
 80020ea:	69ba      	ldr	r2, [r7, #24]
 80020ec:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80020ee:	687b      	ldr	r3, [r7, #4]
 80020f0:	685b      	ldr	r3, [r3, #4]
 80020f2:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80020f4:	2201      	movs	r2, #1
 80020f6:	69fb      	ldr	r3, [r7, #28]
 80020f8:	fa02 f303 	lsl.w	r3, r2, r3
 80020fc:	43db      	mvns	r3, r3
 80020fe:	69ba      	ldr	r2, [r7, #24]
 8002100:	4013      	ands	r3, r2
 8002102:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8002104:	683b      	ldr	r3, [r7, #0]
 8002106:	685b      	ldr	r3, [r3, #4]
 8002108:	091b      	lsrs	r3, r3, #4
 800210a:	f003 0201 	and.w	r2, r3, #1
 800210e:	69fb      	ldr	r3, [r7, #28]
 8002110:	fa02 f303 	lsl.w	r3, r2, r3
 8002114:	69ba      	ldr	r2, [r7, #24]
 8002116:	4313      	orrs	r3, r2
 8002118:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 800211a:	687b      	ldr	r3, [r7, #4]
 800211c:	69ba      	ldr	r2, [r7, #24]
 800211e:	605a      	str	r2, [r3, #4]
       }

      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8002120:	683b      	ldr	r3, [r7, #0]
 8002122:	685b      	ldr	r3, [r3, #4]
 8002124:	f003 0303 	and.w	r3, r3, #3
 8002128:	2b03      	cmp	r3, #3
 800212a:	d017      	beq.n	800215c <HAL_GPIO_Init+0xf0>
      {
        /* Check the parameters */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
        
        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 800212c:	687b      	ldr	r3, [r7, #4]
 800212e:	68db      	ldr	r3, [r3, #12]
 8002130:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8002132:	69fb      	ldr	r3, [r7, #28]
 8002134:	005b      	lsls	r3, r3, #1
 8002136:	2203      	movs	r2, #3
 8002138:	fa02 f303 	lsl.w	r3, r2, r3
 800213c:	43db      	mvns	r3, r3
 800213e:	69ba      	ldr	r2, [r7, #24]
 8002140:	4013      	ands	r3, r2
 8002142:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002144:	683b      	ldr	r3, [r7, #0]
 8002146:	689a      	ldr	r2, [r3, #8]
 8002148:	69fb      	ldr	r3, [r7, #28]
 800214a:	005b      	lsls	r3, r3, #1
 800214c:	fa02 f303 	lsl.w	r3, r2, r3
 8002150:	69ba      	ldr	r2, [r7, #24]
 8002152:	4313      	orrs	r3, r2
 8002154:	61bb      	str	r3, [r7, #24]
        GPIOx->PUPDR = temp;
 8002156:	687b      	ldr	r3, [r7, #4]
 8002158:	69ba      	ldr	r2, [r7, #24]
 800215a:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800215c:	683b      	ldr	r3, [r7, #0]
 800215e:	685b      	ldr	r3, [r3, #4]
 8002160:	f003 0303 	and.w	r3, r3, #3
 8002164:	2b02      	cmp	r3, #2
 8002166:	d123      	bne.n	80021b0 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8002168:	69fb      	ldr	r3, [r7, #28]
 800216a:	08da      	lsrs	r2, r3, #3
 800216c:	687b      	ldr	r3, [r7, #4]
 800216e:	3208      	adds	r2, #8
 8002170:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002174:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8002176:	69fb      	ldr	r3, [r7, #28]
 8002178:	f003 0307 	and.w	r3, r3, #7
 800217c:	009b      	lsls	r3, r3, #2
 800217e:	220f      	movs	r2, #15
 8002180:	fa02 f303 	lsl.w	r3, r2, r3
 8002184:	43db      	mvns	r3, r3
 8002186:	69ba      	ldr	r2, [r7, #24]
 8002188:	4013      	ands	r3, r2
 800218a:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 800218c:	683b      	ldr	r3, [r7, #0]
 800218e:	691a      	ldr	r2, [r3, #16]
 8002190:	69fb      	ldr	r3, [r7, #28]
 8002192:	f003 0307 	and.w	r3, r3, #7
 8002196:	009b      	lsls	r3, r3, #2
 8002198:	fa02 f303 	lsl.w	r3, r2, r3
 800219c:	69ba      	ldr	r2, [r7, #24]
 800219e:	4313      	orrs	r3, r2
 80021a0:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 80021a2:	69fb      	ldr	r3, [r7, #28]
 80021a4:	08da      	lsrs	r2, r3, #3
 80021a6:	687b      	ldr	r3, [r7, #4]
 80021a8:	3208      	adds	r2, #8
 80021aa:	69b9      	ldr	r1, [r7, #24]
 80021ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80021b0:	687b      	ldr	r3, [r7, #4]
 80021b2:	681b      	ldr	r3, [r3, #0]
 80021b4:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80021b6:	69fb      	ldr	r3, [r7, #28]
 80021b8:	005b      	lsls	r3, r3, #1
 80021ba:	2203      	movs	r2, #3
 80021bc:	fa02 f303 	lsl.w	r3, r2, r3
 80021c0:	43db      	mvns	r3, r3
 80021c2:	69ba      	ldr	r2, [r7, #24]
 80021c4:	4013      	ands	r3, r2
 80021c6:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80021c8:	683b      	ldr	r3, [r7, #0]
 80021ca:	685b      	ldr	r3, [r3, #4]
 80021cc:	f003 0203 	and.w	r2, r3, #3
 80021d0:	69fb      	ldr	r3, [r7, #28]
 80021d2:	005b      	lsls	r3, r3, #1
 80021d4:	fa02 f303 	lsl.w	r3, r2, r3
 80021d8:	69ba      	ldr	r2, [r7, #24]
 80021da:	4313      	orrs	r3, r2
 80021dc:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 80021de:	687b      	ldr	r3, [r7, #4]
 80021e0:	69ba      	ldr	r2, [r7, #24]
 80021e2:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 80021e4:	683b      	ldr	r3, [r7, #0]
 80021e6:	685b      	ldr	r3, [r3, #4]
 80021e8:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 80021ec:	2b00      	cmp	r3, #0
 80021ee:	f000 80b4 	beq.w	800235a <HAL_GPIO_Init+0x2ee>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80021f2:	2300      	movs	r3, #0
 80021f4:	60fb      	str	r3, [r7, #12]
 80021f6:	4b60      	ldr	r3, [pc, #384]	@ (8002378 <HAL_GPIO_Init+0x30c>)
 80021f8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80021fa:	4a5f      	ldr	r2, [pc, #380]	@ (8002378 <HAL_GPIO_Init+0x30c>)
 80021fc:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8002200:	6453      	str	r3, [r2, #68]	@ 0x44
 8002202:	4b5d      	ldr	r3, [pc, #372]	@ (8002378 <HAL_GPIO_Init+0x30c>)
 8002204:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002206:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800220a:	60fb      	str	r3, [r7, #12]
 800220c:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 800220e:	4a5b      	ldr	r2, [pc, #364]	@ (800237c <HAL_GPIO_Init+0x310>)
 8002210:	69fb      	ldr	r3, [r7, #28]
 8002212:	089b      	lsrs	r3, r3, #2
 8002214:	3302      	adds	r3, #2
 8002216:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800221a:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 800221c:	69fb      	ldr	r3, [r7, #28]
 800221e:	f003 0303 	and.w	r3, r3, #3
 8002222:	009b      	lsls	r3, r3, #2
 8002224:	220f      	movs	r2, #15
 8002226:	fa02 f303 	lsl.w	r3, r2, r3
 800222a:	43db      	mvns	r3, r3
 800222c:	69ba      	ldr	r2, [r7, #24]
 800222e:	4013      	ands	r3, r2
 8002230:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8002232:	687b      	ldr	r3, [r7, #4]
 8002234:	4a52      	ldr	r2, [pc, #328]	@ (8002380 <HAL_GPIO_Init+0x314>)
 8002236:	4293      	cmp	r3, r2
 8002238:	d02b      	beq.n	8002292 <HAL_GPIO_Init+0x226>
 800223a:	687b      	ldr	r3, [r7, #4]
 800223c:	4a51      	ldr	r2, [pc, #324]	@ (8002384 <HAL_GPIO_Init+0x318>)
 800223e:	4293      	cmp	r3, r2
 8002240:	d025      	beq.n	800228e <HAL_GPIO_Init+0x222>
 8002242:	687b      	ldr	r3, [r7, #4]
 8002244:	4a50      	ldr	r2, [pc, #320]	@ (8002388 <HAL_GPIO_Init+0x31c>)
 8002246:	4293      	cmp	r3, r2
 8002248:	d01f      	beq.n	800228a <HAL_GPIO_Init+0x21e>
 800224a:	687b      	ldr	r3, [r7, #4]
 800224c:	4a4f      	ldr	r2, [pc, #316]	@ (800238c <HAL_GPIO_Init+0x320>)
 800224e:	4293      	cmp	r3, r2
 8002250:	d019      	beq.n	8002286 <HAL_GPIO_Init+0x21a>
 8002252:	687b      	ldr	r3, [r7, #4]
 8002254:	4a4e      	ldr	r2, [pc, #312]	@ (8002390 <HAL_GPIO_Init+0x324>)
 8002256:	4293      	cmp	r3, r2
 8002258:	d013      	beq.n	8002282 <HAL_GPIO_Init+0x216>
 800225a:	687b      	ldr	r3, [r7, #4]
 800225c:	4a4d      	ldr	r2, [pc, #308]	@ (8002394 <HAL_GPIO_Init+0x328>)
 800225e:	4293      	cmp	r3, r2
 8002260:	d00d      	beq.n	800227e <HAL_GPIO_Init+0x212>
 8002262:	687b      	ldr	r3, [r7, #4]
 8002264:	4a4c      	ldr	r2, [pc, #304]	@ (8002398 <HAL_GPIO_Init+0x32c>)
 8002266:	4293      	cmp	r3, r2
 8002268:	d007      	beq.n	800227a <HAL_GPIO_Init+0x20e>
 800226a:	687b      	ldr	r3, [r7, #4]
 800226c:	4a4b      	ldr	r2, [pc, #300]	@ (800239c <HAL_GPIO_Init+0x330>)
 800226e:	4293      	cmp	r3, r2
 8002270:	d101      	bne.n	8002276 <HAL_GPIO_Init+0x20a>
 8002272:	2307      	movs	r3, #7
 8002274:	e00e      	b.n	8002294 <HAL_GPIO_Init+0x228>
 8002276:	2308      	movs	r3, #8
 8002278:	e00c      	b.n	8002294 <HAL_GPIO_Init+0x228>
 800227a:	2306      	movs	r3, #6
 800227c:	e00a      	b.n	8002294 <HAL_GPIO_Init+0x228>
 800227e:	2305      	movs	r3, #5
 8002280:	e008      	b.n	8002294 <HAL_GPIO_Init+0x228>
 8002282:	2304      	movs	r3, #4
 8002284:	e006      	b.n	8002294 <HAL_GPIO_Init+0x228>
 8002286:	2303      	movs	r3, #3
 8002288:	e004      	b.n	8002294 <HAL_GPIO_Init+0x228>
 800228a:	2302      	movs	r3, #2
 800228c:	e002      	b.n	8002294 <HAL_GPIO_Init+0x228>
 800228e:	2301      	movs	r3, #1
 8002290:	e000      	b.n	8002294 <HAL_GPIO_Init+0x228>
 8002292:	2300      	movs	r3, #0
 8002294:	69fa      	ldr	r2, [r7, #28]
 8002296:	f002 0203 	and.w	r2, r2, #3
 800229a:	0092      	lsls	r2, r2, #2
 800229c:	4093      	lsls	r3, r2
 800229e:	69ba      	ldr	r2, [r7, #24]
 80022a0:	4313      	orrs	r3, r2
 80022a2:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 80022a4:	4935      	ldr	r1, [pc, #212]	@ (800237c <HAL_GPIO_Init+0x310>)
 80022a6:	69fb      	ldr	r3, [r7, #28]
 80022a8:	089b      	lsrs	r3, r3, #2
 80022aa:	3302      	adds	r3, #2
 80022ac:	69ba      	ldr	r2, [r7, #24]
 80022ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80022b2:	4b3b      	ldr	r3, [pc, #236]	@ (80023a0 <HAL_GPIO_Init+0x334>)
 80022b4:	689b      	ldr	r3, [r3, #8]
 80022b6:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 80022b8:	693b      	ldr	r3, [r7, #16]
 80022ba:	43db      	mvns	r3, r3
 80022bc:	69ba      	ldr	r2, [r7, #24]
 80022be:	4013      	ands	r3, r2
 80022c0:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 80022c2:	683b      	ldr	r3, [r7, #0]
 80022c4:	685b      	ldr	r3, [r3, #4]
 80022c6:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 80022ca:	2b00      	cmp	r3, #0
 80022cc:	d003      	beq.n	80022d6 <HAL_GPIO_Init+0x26a>
        {
          temp |= iocurrent;
 80022ce:	69ba      	ldr	r2, [r7, #24]
 80022d0:	693b      	ldr	r3, [r7, #16]
 80022d2:	4313      	orrs	r3, r2
 80022d4:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 80022d6:	4a32      	ldr	r2, [pc, #200]	@ (80023a0 <HAL_GPIO_Init+0x334>)
 80022d8:	69bb      	ldr	r3, [r7, #24]
 80022da:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 80022dc:	4b30      	ldr	r3, [pc, #192]	@ (80023a0 <HAL_GPIO_Init+0x334>)
 80022de:	68db      	ldr	r3, [r3, #12]
 80022e0:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 80022e2:	693b      	ldr	r3, [r7, #16]
 80022e4:	43db      	mvns	r3, r3
 80022e6:	69ba      	ldr	r2, [r7, #24]
 80022e8:	4013      	ands	r3, r2
 80022ea:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 80022ec:	683b      	ldr	r3, [r7, #0]
 80022ee:	685b      	ldr	r3, [r3, #4]
 80022f0:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 80022f4:	2b00      	cmp	r3, #0
 80022f6:	d003      	beq.n	8002300 <HAL_GPIO_Init+0x294>
        {
          temp |= iocurrent;
 80022f8:	69ba      	ldr	r2, [r7, #24]
 80022fa:	693b      	ldr	r3, [r7, #16]
 80022fc:	4313      	orrs	r3, r2
 80022fe:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 8002300:	4a27      	ldr	r2, [pc, #156]	@ (80023a0 <HAL_GPIO_Init+0x334>)
 8002302:	69bb      	ldr	r3, [r7, #24]
 8002304:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 8002306:	4b26      	ldr	r3, [pc, #152]	@ (80023a0 <HAL_GPIO_Init+0x334>)
 8002308:	685b      	ldr	r3, [r3, #4]
 800230a:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800230c:	693b      	ldr	r3, [r7, #16]
 800230e:	43db      	mvns	r3, r3
 8002310:	69ba      	ldr	r2, [r7, #24]
 8002312:	4013      	ands	r3, r2
 8002314:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8002316:	683b      	ldr	r3, [r7, #0]
 8002318:	685b      	ldr	r3, [r3, #4]
 800231a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800231e:	2b00      	cmp	r3, #0
 8002320:	d003      	beq.n	800232a <HAL_GPIO_Init+0x2be>
        {
          temp |= iocurrent;
 8002322:	69ba      	ldr	r2, [r7, #24]
 8002324:	693b      	ldr	r3, [r7, #16]
 8002326:	4313      	orrs	r3, r2
 8002328:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 800232a:	4a1d      	ldr	r2, [pc, #116]	@ (80023a0 <HAL_GPIO_Init+0x334>)
 800232c:	69bb      	ldr	r3, [r7, #24]
 800232e:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8002330:	4b1b      	ldr	r3, [pc, #108]	@ (80023a0 <HAL_GPIO_Init+0x334>)
 8002332:	681b      	ldr	r3, [r3, #0]
 8002334:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8002336:	693b      	ldr	r3, [r7, #16]
 8002338:	43db      	mvns	r3, r3
 800233a:	69ba      	ldr	r2, [r7, #24]
 800233c:	4013      	ands	r3, r2
 800233e:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8002340:	683b      	ldr	r3, [r7, #0]
 8002342:	685b      	ldr	r3, [r3, #4]
 8002344:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8002348:	2b00      	cmp	r3, #0
 800234a:	d003      	beq.n	8002354 <HAL_GPIO_Init+0x2e8>
        {
          temp |= iocurrent;
 800234c:	69ba      	ldr	r2, [r7, #24]
 800234e:	693b      	ldr	r3, [r7, #16]
 8002350:	4313      	orrs	r3, r2
 8002352:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 8002354:	4a12      	ldr	r2, [pc, #72]	@ (80023a0 <HAL_GPIO_Init+0x334>)
 8002356:	69bb      	ldr	r3, [r7, #24]
 8002358:	6013      	str	r3, [r2, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800235a:	69fb      	ldr	r3, [r7, #28]
 800235c:	3301      	adds	r3, #1
 800235e:	61fb      	str	r3, [r7, #28]
 8002360:	69fb      	ldr	r3, [r7, #28]
 8002362:	2b0f      	cmp	r3, #15
 8002364:	f67f ae90 	bls.w	8002088 <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 8002368:	bf00      	nop
 800236a:	bf00      	nop
 800236c:	3724      	adds	r7, #36	@ 0x24
 800236e:	46bd      	mov	sp, r7
 8002370:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002374:	4770      	bx	lr
 8002376:	bf00      	nop
 8002378:	40023800 	.word	0x40023800
 800237c:	40013800 	.word	0x40013800
 8002380:	40020000 	.word	0x40020000
 8002384:	40020400 	.word	0x40020400
 8002388:	40020800 	.word	0x40020800
 800238c:	40020c00 	.word	0x40020c00
 8002390:	40021000 	.word	0x40021000
 8002394:	40021400 	.word	0x40021400
 8002398:	40021800 	.word	0x40021800
 800239c:	40021c00 	.word	0x40021c00
 80023a0:	40013c00 	.word	0x40013c00

080023a4 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80023a4:	b480      	push	{r7}
 80023a6:	b085      	sub	sp, #20
 80023a8:	af00      	add	r7, sp, #0
 80023aa:	6078      	str	r0, [r7, #4]
 80023ac:	460b      	mov	r3, r1
 80023ae:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 80023b0:	687b      	ldr	r3, [r7, #4]
 80023b2:	691a      	ldr	r2, [r3, #16]
 80023b4:	887b      	ldrh	r3, [r7, #2]
 80023b6:	4013      	ands	r3, r2
 80023b8:	2b00      	cmp	r3, #0
 80023ba:	d002      	beq.n	80023c2 <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 80023bc:	2301      	movs	r3, #1
 80023be:	73fb      	strb	r3, [r7, #15]
 80023c0:	e001      	b.n	80023c6 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 80023c2:	2300      	movs	r3, #0
 80023c4:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80023c6:	7bfb      	ldrb	r3, [r7, #15]
}
 80023c8:	4618      	mov	r0, r3
 80023ca:	3714      	adds	r7, #20
 80023cc:	46bd      	mov	sp, r7
 80023ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023d2:	4770      	bx	lr

080023d4 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 80023d4:	b480      	push	{r7}
 80023d6:	b083      	sub	sp, #12
 80023d8:	af00      	add	r7, sp, #0
 80023da:	6078      	str	r0, [r7, #4]
 80023dc:	460b      	mov	r3, r1
 80023de:	807b      	strh	r3, [r7, #2]
 80023e0:	4613      	mov	r3, r2
 80023e2:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80023e4:	787b      	ldrb	r3, [r7, #1]
 80023e6:	2b00      	cmp	r3, #0
 80023e8:	d003      	beq.n	80023f2 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 80023ea:	887a      	ldrh	r2, [r7, #2]
 80023ec:	687b      	ldr	r3, [r7, #4]
 80023ee:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 80023f0:	e003      	b.n	80023fa <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 80023f2:	887b      	ldrh	r3, [r7, #2]
 80023f4:	041a      	lsls	r2, r3, #16
 80023f6:	687b      	ldr	r3, [r7, #4]
 80023f8:	619a      	str	r2, [r3, #24]
}
 80023fa:	bf00      	nop
 80023fc:	370c      	adds	r7, #12
 80023fe:	46bd      	mov	sp, r7
 8002400:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002404:	4770      	bx	lr
	...

08002408 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8002408:	b580      	push	{r7, lr}
 800240a:	b084      	sub	sp, #16
 800240c:	af00      	add	r7, sp, #0
 800240e:	6078      	str	r0, [r7, #4]
  uint32_t freqrange;
  uint32_t pclk1;

  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8002410:	687b      	ldr	r3, [r7, #4]
 8002412:	2b00      	cmp	r3, #0
 8002414:	d101      	bne.n	800241a <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 8002416:	2301      	movs	r3, #1
 8002418:	e12b      	b.n	8002672 <HAL_I2C_Init+0x26a>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800241a:	687b      	ldr	r3, [r7, #4]
 800241c:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8002420:	b2db      	uxtb	r3, r3
 8002422:	2b00      	cmp	r3, #0
 8002424:	d106      	bne.n	8002434 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 8002426:	687b      	ldr	r3, [r7, #4]
 8002428:	2200      	movs	r2, #0
 800242a:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 800242e:	6878      	ldr	r0, [r7, #4]
 8002430:	f7ff fa3c 	bl	80018ac <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 8002434:	687b      	ldr	r3, [r7, #4]
 8002436:	2224      	movs	r2, #36	@ 0x24
 8002438:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800243c:	687b      	ldr	r3, [r7, #4]
 800243e:	681b      	ldr	r3, [r3, #0]
 8002440:	681a      	ldr	r2, [r3, #0]
 8002442:	687b      	ldr	r3, [r7, #4]
 8002444:	681b      	ldr	r3, [r3, #0]
 8002446:	f022 0201 	bic.w	r2, r2, #1
 800244a:	601a      	str	r2, [r3, #0]

  /*Reset I2C*/
  hi2c->Instance->CR1 |= I2C_CR1_SWRST;
 800244c:	687b      	ldr	r3, [r7, #4]
 800244e:	681b      	ldr	r3, [r3, #0]
 8002450:	681a      	ldr	r2, [r3, #0]
 8002452:	687b      	ldr	r3, [r7, #4]
 8002454:	681b      	ldr	r3, [r3, #0]
 8002456:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800245a:	601a      	str	r2, [r3, #0]
  hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
 800245c:	687b      	ldr	r3, [r7, #4]
 800245e:	681b      	ldr	r3, [r3, #0]
 8002460:	681a      	ldr	r2, [r3, #0]
 8002462:	687b      	ldr	r3, [r7, #4]
 8002464:	681b      	ldr	r3, [r3, #0]
 8002466:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 800246a:	601a      	str	r2, [r3, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();
 800246c:	f002 fc72 	bl	8004d54 <HAL_RCC_GetPCLK1Freq>
 8002470:	60f8      	str	r0, [r7, #12]

  /* Check the minimum allowed PCLK1 frequency */
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 8002472:	687b      	ldr	r3, [r7, #4]
 8002474:	685b      	ldr	r3, [r3, #4]
 8002476:	4a81      	ldr	r2, [pc, #516]	@ (800267c <HAL_I2C_Init+0x274>)
 8002478:	4293      	cmp	r3, r2
 800247a:	d807      	bhi.n	800248c <HAL_I2C_Init+0x84>
 800247c:	68fb      	ldr	r3, [r7, #12]
 800247e:	4a80      	ldr	r2, [pc, #512]	@ (8002680 <HAL_I2C_Init+0x278>)
 8002480:	4293      	cmp	r3, r2
 8002482:	bf94      	ite	ls
 8002484:	2301      	movls	r3, #1
 8002486:	2300      	movhi	r3, #0
 8002488:	b2db      	uxtb	r3, r3
 800248a:	e006      	b.n	800249a <HAL_I2C_Init+0x92>
 800248c:	68fb      	ldr	r3, [r7, #12]
 800248e:	4a7d      	ldr	r2, [pc, #500]	@ (8002684 <HAL_I2C_Init+0x27c>)
 8002490:	4293      	cmp	r3, r2
 8002492:	bf94      	ite	ls
 8002494:	2301      	movls	r3, #1
 8002496:	2300      	movhi	r3, #0
 8002498:	b2db      	uxtb	r3, r3
 800249a:	2b00      	cmp	r3, #0
 800249c:	d001      	beq.n	80024a2 <HAL_I2C_Init+0x9a>
  {
    return HAL_ERROR;
 800249e:	2301      	movs	r3, #1
 80024a0:	e0e7      	b.n	8002672 <HAL_I2C_Init+0x26a>
  }

  /* Calculate frequency range */
  freqrange = I2C_FREQRANGE(pclk1);
 80024a2:	68fb      	ldr	r3, [r7, #12]
 80024a4:	4a78      	ldr	r2, [pc, #480]	@ (8002688 <HAL_I2C_Init+0x280>)
 80024a6:	fba2 2303 	umull	r2, r3, r2, r3
 80024aa:	0c9b      	lsrs	r3, r3, #18
 80024ac:	60bb      	str	r3, [r7, #8]

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 80024ae:	687b      	ldr	r3, [r7, #4]
 80024b0:	681b      	ldr	r3, [r3, #0]
 80024b2:	685b      	ldr	r3, [r3, #4]
 80024b4:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
 80024b8:	687b      	ldr	r3, [r7, #4]
 80024ba:	681b      	ldr	r3, [r3, #0]
 80024bc:	68ba      	ldr	r2, [r7, #8]
 80024be:	430a      	orrs	r2, r1
 80024c0:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 80024c2:	687b      	ldr	r3, [r7, #4]
 80024c4:	681b      	ldr	r3, [r3, #0]
 80024c6:	6a1b      	ldr	r3, [r3, #32]
 80024c8:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
 80024cc:	687b      	ldr	r3, [r7, #4]
 80024ce:	685b      	ldr	r3, [r3, #4]
 80024d0:	4a6a      	ldr	r2, [pc, #424]	@ (800267c <HAL_I2C_Init+0x274>)
 80024d2:	4293      	cmp	r3, r2
 80024d4:	d802      	bhi.n	80024dc <HAL_I2C_Init+0xd4>
 80024d6:	68bb      	ldr	r3, [r7, #8]
 80024d8:	3301      	adds	r3, #1
 80024da:	e009      	b.n	80024f0 <HAL_I2C_Init+0xe8>
 80024dc:	68bb      	ldr	r3, [r7, #8]
 80024de:	f44f 7296 	mov.w	r2, #300	@ 0x12c
 80024e2:	fb02 f303 	mul.w	r3, r2, r3
 80024e6:	4a69      	ldr	r2, [pc, #420]	@ (800268c <HAL_I2C_Init+0x284>)
 80024e8:	fba2 2303 	umull	r2, r3, r2, r3
 80024ec:	099b      	lsrs	r3, r3, #6
 80024ee:	3301      	adds	r3, #1
 80024f0:	687a      	ldr	r2, [r7, #4]
 80024f2:	6812      	ldr	r2, [r2, #0]
 80024f4:	430b      	orrs	r3, r1
 80024f6:	6213      	str	r3, [r2, #32]

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 80024f8:	687b      	ldr	r3, [r7, #4]
 80024fa:	681b      	ldr	r3, [r3, #0]
 80024fc:	69db      	ldr	r3, [r3, #28]
 80024fe:	f423 424f 	bic.w	r2, r3, #52992	@ 0xcf00
 8002502:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8002506:	687b      	ldr	r3, [r7, #4]
 8002508:	685b      	ldr	r3, [r3, #4]
 800250a:	495c      	ldr	r1, [pc, #368]	@ (800267c <HAL_I2C_Init+0x274>)
 800250c:	428b      	cmp	r3, r1
 800250e:	d819      	bhi.n	8002544 <HAL_I2C_Init+0x13c>
 8002510:	68fb      	ldr	r3, [r7, #12]
 8002512:	1e59      	subs	r1, r3, #1
 8002514:	687b      	ldr	r3, [r7, #4]
 8002516:	685b      	ldr	r3, [r3, #4]
 8002518:	005b      	lsls	r3, r3, #1
 800251a:	fbb1 f3f3 	udiv	r3, r1, r3
 800251e:	1c59      	adds	r1, r3, #1
 8002520:	f640 73fc 	movw	r3, #4092	@ 0xffc
 8002524:	400b      	ands	r3, r1
 8002526:	2b00      	cmp	r3, #0
 8002528:	d00a      	beq.n	8002540 <HAL_I2C_Init+0x138>
 800252a:	68fb      	ldr	r3, [r7, #12]
 800252c:	1e59      	subs	r1, r3, #1
 800252e:	687b      	ldr	r3, [r7, #4]
 8002530:	685b      	ldr	r3, [r3, #4]
 8002532:	005b      	lsls	r3, r3, #1
 8002534:	fbb1 f3f3 	udiv	r3, r1, r3
 8002538:	3301      	adds	r3, #1
 800253a:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800253e:	e051      	b.n	80025e4 <HAL_I2C_Init+0x1dc>
 8002540:	2304      	movs	r3, #4
 8002542:	e04f      	b.n	80025e4 <HAL_I2C_Init+0x1dc>
 8002544:	687b      	ldr	r3, [r7, #4]
 8002546:	689b      	ldr	r3, [r3, #8]
 8002548:	2b00      	cmp	r3, #0
 800254a:	d111      	bne.n	8002570 <HAL_I2C_Init+0x168>
 800254c:	68fb      	ldr	r3, [r7, #12]
 800254e:	1e58      	subs	r0, r3, #1
 8002550:	687b      	ldr	r3, [r7, #4]
 8002552:	6859      	ldr	r1, [r3, #4]
 8002554:	460b      	mov	r3, r1
 8002556:	005b      	lsls	r3, r3, #1
 8002558:	440b      	add	r3, r1
 800255a:	fbb0 f3f3 	udiv	r3, r0, r3
 800255e:	3301      	adds	r3, #1
 8002560:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002564:	2b00      	cmp	r3, #0
 8002566:	bf0c      	ite	eq
 8002568:	2301      	moveq	r3, #1
 800256a:	2300      	movne	r3, #0
 800256c:	b2db      	uxtb	r3, r3
 800256e:	e012      	b.n	8002596 <HAL_I2C_Init+0x18e>
 8002570:	68fb      	ldr	r3, [r7, #12]
 8002572:	1e58      	subs	r0, r3, #1
 8002574:	687b      	ldr	r3, [r7, #4]
 8002576:	6859      	ldr	r1, [r3, #4]
 8002578:	460b      	mov	r3, r1
 800257a:	009b      	lsls	r3, r3, #2
 800257c:	440b      	add	r3, r1
 800257e:	0099      	lsls	r1, r3, #2
 8002580:	440b      	add	r3, r1
 8002582:	fbb0 f3f3 	udiv	r3, r0, r3
 8002586:	3301      	adds	r3, #1
 8002588:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800258c:	2b00      	cmp	r3, #0
 800258e:	bf0c      	ite	eq
 8002590:	2301      	moveq	r3, #1
 8002592:	2300      	movne	r3, #0
 8002594:	b2db      	uxtb	r3, r3
 8002596:	2b00      	cmp	r3, #0
 8002598:	d001      	beq.n	800259e <HAL_I2C_Init+0x196>
 800259a:	2301      	movs	r3, #1
 800259c:	e022      	b.n	80025e4 <HAL_I2C_Init+0x1dc>
 800259e:	687b      	ldr	r3, [r7, #4]
 80025a0:	689b      	ldr	r3, [r3, #8]
 80025a2:	2b00      	cmp	r3, #0
 80025a4:	d10e      	bne.n	80025c4 <HAL_I2C_Init+0x1bc>
 80025a6:	68fb      	ldr	r3, [r7, #12]
 80025a8:	1e58      	subs	r0, r3, #1
 80025aa:	687b      	ldr	r3, [r7, #4]
 80025ac:	6859      	ldr	r1, [r3, #4]
 80025ae:	460b      	mov	r3, r1
 80025b0:	005b      	lsls	r3, r3, #1
 80025b2:	440b      	add	r3, r1
 80025b4:	fbb0 f3f3 	udiv	r3, r0, r3
 80025b8:	3301      	adds	r3, #1
 80025ba:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80025be:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80025c2:	e00f      	b.n	80025e4 <HAL_I2C_Init+0x1dc>
 80025c4:	68fb      	ldr	r3, [r7, #12]
 80025c6:	1e58      	subs	r0, r3, #1
 80025c8:	687b      	ldr	r3, [r7, #4]
 80025ca:	6859      	ldr	r1, [r3, #4]
 80025cc:	460b      	mov	r3, r1
 80025ce:	009b      	lsls	r3, r3, #2
 80025d0:	440b      	add	r3, r1
 80025d2:	0099      	lsls	r1, r3, #2
 80025d4:	440b      	add	r3, r1
 80025d6:	fbb0 f3f3 	udiv	r3, r0, r3
 80025da:	3301      	adds	r3, #1
 80025dc:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80025e0:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 80025e4:	6879      	ldr	r1, [r7, #4]
 80025e6:	6809      	ldr	r1, [r1, #0]
 80025e8:	4313      	orrs	r3, r2
 80025ea:	61cb      	str	r3, [r1, #28]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 80025ec:	687b      	ldr	r3, [r7, #4]
 80025ee:	681b      	ldr	r3, [r3, #0]
 80025f0:	681b      	ldr	r3, [r3, #0]
 80025f2:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 80025f6:	687b      	ldr	r3, [r7, #4]
 80025f8:	69da      	ldr	r2, [r3, #28]
 80025fa:	687b      	ldr	r3, [r7, #4]
 80025fc:	6a1b      	ldr	r3, [r3, #32]
 80025fe:	431a      	orrs	r2, r3
 8002600:	687b      	ldr	r3, [r7, #4]
 8002602:	681b      	ldr	r3, [r3, #0]
 8002604:	430a      	orrs	r2, r1
 8002606:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 8002608:	687b      	ldr	r3, [r7, #4]
 800260a:	681b      	ldr	r3, [r3, #0]
 800260c:	689b      	ldr	r3, [r3, #8]
 800260e:	f423 4303 	bic.w	r3, r3, #33536	@ 0x8300
 8002612:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 8002616:	687a      	ldr	r2, [r7, #4]
 8002618:	6911      	ldr	r1, [r2, #16]
 800261a:	687a      	ldr	r2, [r7, #4]
 800261c:	68d2      	ldr	r2, [r2, #12]
 800261e:	4311      	orrs	r1, r2
 8002620:	687a      	ldr	r2, [r7, #4]
 8002622:	6812      	ldr	r2, [r2, #0]
 8002624:	430b      	orrs	r3, r1
 8002626:	6093      	str	r3, [r2, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 8002628:	687b      	ldr	r3, [r7, #4]
 800262a:	681b      	ldr	r3, [r3, #0]
 800262c:	68db      	ldr	r3, [r3, #12]
 800262e:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
 8002632:	687b      	ldr	r3, [r7, #4]
 8002634:	695a      	ldr	r2, [r3, #20]
 8002636:	687b      	ldr	r3, [r7, #4]
 8002638:	699b      	ldr	r3, [r3, #24]
 800263a:	431a      	orrs	r2, r3
 800263c:	687b      	ldr	r3, [r7, #4]
 800263e:	681b      	ldr	r3, [r3, #0]
 8002640:	430a      	orrs	r2, r1
 8002642:	60da      	str	r2, [r3, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8002644:	687b      	ldr	r3, [r7, #4]
 8002646:	681b      	ldr	r3, [r3, #0]
 8002648:	681a      	ldr	r2, [r3, #0]
 800264a:	687b      	ldr	r3, [r7, #4]
 800264c:	681b      	ldr	r3, [r3, #0]
 800264e:	f042 0201 	orr.w	r2, r2, #1
 8002652:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002654:	687b      	ldr	r3, [r7, #4]
 8002656:	2200      	movs	r2, #0
 8002658:	641a      	str	r2, [r3, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 800265a:	687b      	ldr	r3, [r7, #4]
 800265c:	2220      	movs	r2, #32
 800265e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 8002662:	687b      	ldr	r3, [r7, #4]
 8002664:	2200      	movs	r2, #0
 8002666:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8002668:	687b      	ldr	r3, [r7, #4]
 800266a:	2200      	movs	r2, #0
 800266c:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

  return HAL_OK;
 8002670:	2300      	movs	r3, #0
}
 8002672:	4618      	mov	r0, r3
 8002674:	3710      	adds	r7, #16
 8002676:	46bd      	mov	sp, r7
 8002678:	bd80      	pop	{r7, pc}
 800267a:	bf00      	nop
 800267c:	000186a0 	.word	0x000186a0
 8002680:	001e847f 	.word	0x001e847f
 8002684:	003d08ff 	.word	0x003d08ff
 8002688:	431bde83 	.word	0x431bde83
 800268c:	10624dd3 	.word	0x10624dd3

08002690 <HAL_I2S_Init>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s)
{
 8002690:	b580      	push	{r7, lr}
 8002692:	b088      	sub	sp, #32
 8002694:	af00      	add	r7, sp, #0
 8002696:	6078      	str	r0, [r7, #4]
#if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
  uint16_t tmpreg;
#endif

  /* Check the I2S handle allocation */
  if (hi2s == NULL)
 8002698:	687b      	ldr	r3, [r7, #4]
 800269a:	2b00      	cmp	r3, #0
 800269c:	d101      	bne.n	80026a2 <HAL_I2S_Init+0x12>
  {
    return HAL_ERROR;
 800269e:	2301      	movs	r3, #1
 80026a0:	e128      	b.n	80028f4 <HAL_I2S_Init+0x264>
  assert_param(IS_I2S_MCLK_OUTPUT(hi2s->Init.MCLKOutput));
  assert_param(IS_I2S_AUDIO_FREQ(hi2s->Init.AudioFreq));
  assert_param(IS_I2S_CPOL(hi2s->Init.CPOL));
  assert_param(IS_I2S_CLOCKSOURCE(hi2s->Init.ClockSource));

  if (hi2s->State == HAL_I2S_STATE_RESET)
 80026a2:	687b      	ldr	r3, [r7, #4]
 80026a4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80026a8:	b2db      	uxtb	r3, r3
 80026aa:	2b00      	cmp	r3, #0
 80026ac:	d109      	bne.n	80026c2 <HAL_I2S_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hi2s->Lock = HAL_UNLOCKED;
 80026ae:	687b      	ldr	r3, [r7, #4]
 80026b0:	2200      	movs	r2, #0
 80026b2:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Initialize Default I2S IrqHandler ISR */
    hi2s->IrqHandlerISR = I2S_IRQHandler;
 80026b6:	687b      	ldr	r3, [r7, #4]
 80026b8:	4a90      	ldr	r2, [pc, #576]	@ (80028fc <HAL_I2S_Init+0x26c>)
 80026ba:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hi2s->MspInitCallback(hi2s);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2S_MspInit(hi2s);
 80026bc:	6878      	ldr	r0, [r7, #4]
 80026be:	f7ff f93d 	bl	800193c <HAL_I2S_MspInit>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }

  hi2s->State = HAL_I2S_STATE_BUSY;
 80026c2:	687b      	ldr	r3, [r7, #4]
 80026c4:	2202      	movs	r2, #2
 80026c6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  CLEAR_BIT(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 80026ca:	687b      	ldr	r3, [r7, #4]
 80026cc:	681b      	ldr	r3, [r3, #0]
 80026ce:	69db      	ldr	r3, [r3, #28]
 80026d0:	687a      	ldr	r2, [r7, #4]
 80026d2:	6812      	ldr	r2, [r2, #0]
 80026d4:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 80026d8:	f023 030f 	bic.w	r3, r3, #15
 80026dc:	61d3      	str	r3, [r2, #28]
                                      SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                      SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
  hi2s->Instance->I2SPR = 0x0002U;
 80026de:	687b      	ldr	r3, [r7, #4]
 80026e0:	681b      	ldr	r3, [r3, #0]
 80026e2:	2202      	movs	r2, #2
 80026e4:	621a      	str	r2, [r3, #32]

  /*----------------------- I2SPR: I2SDIV and ODD Calculation -----------------*/
  /* If the requested audio frequency is not the default, compute the prescaler */
  if (hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
 80026e6:	687b      	ldr	r3, [r7, #4]
 80026e8:	695b      	ldr	r3, [r3, #20]
 80026ea:	2b02      	cmp	r3, #2
 80026ec:	d060      	beq.n	80027b0 <HAL_I2S_Init+0x120>
  {
    /* Check the frame length (For the Prescaler computing) ********************/
    if (hi2s->Init.DataFormat == I2S_DATAFORMAT_16B)
 80026ee:	687b      	ldr	r3, [r7, #4]
 80026f0:	68db      	ldr	r3, [r3, #12]
 80026f2:	2b00      	cmp	r3, #0
 80026f4:	d102      	bne.n	80026fc <HAL_I2S_Init+0x6c>
    {
      /* Packet length is 16 bits */
      packetlength = 16U;
 80026f6:	2310      	movs	r3, #16
 80026f8:	617b      	str	r3, [r7, #20]
 80026fa:	e001      	b.n	8002700 <HAL_I2S_Init+0x70>
    }
    else
    {
      /* Packet length is 32 bits */
      packetlength = 32U;
 80026fc:	2320      	movs	r3, #32
 80026fe:	617b      	str	r3, [r7, #20]
    }

    /* I2S standard */
    if (hi2s->Init.Standard <= I2S_STANDARD_LSB)
 8002700:	687b      	ldr	r3, [r7, #4]
 8002702:	689b      	ldr	r3, [r3, #8]
 8002704:	2b20      	cmp	r3, #32
 8002706:	d802      	bhi.n	800270e <HAL_I2S_Init+0x7e>
    {
      /* In I2S standard packet length is multiplied by 2 */
      packetlength = packetlength * 2U;
 8002708:	697b      	ldr	r3, [r7, #20]
 800270a:	005b      	lsls	r3, r3, #1
 800270c:	617b      	str	r3, [r7, #20]
    else
    {
      i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S_APB2);
    }
#else
    i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S);
 800270e:	2001      	movs	r0, #1
 8002710:	f002 fc16 	bl	8004f40 <HAL_RCCEx_GetPeriphCLKFreq>
 8002714:	60f8      	str	r0, [r7, #12]
#endif /* I2S_APB1_APB2_FEATURE */

    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if (hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
 8002716:	687b      	ldr	r3, [r7, #4]
 8002718:	691b      	ldr	r3, [r3, #16]
 800271a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800271e:	d125      	bne.n	800276c <HAL_I2S_Init+0xdc>
    {
      /* MCLK output is enabled */
      if (hi2s->Init.DataFormat != I2S_DATAFORMAT_16B)
 8002720:	687b      	ldr	r3, [r7, #4]
 8002722:	68db      	ldr	r3, [r3, #12]
 8002724:	2b00      	cmp	r3, #0
 8002726:	d010      	beq.n	800274a <HAL_I2S_Init+0xba>
      {
        tmp = (uint32_t)(((((i2sclk / (packetlength * 4U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 8002728:	697b      	ldr	r3, [r7, #20]
 800272a:	009b      	lsls	r3, r3, #2
 800272c:	68fa      	ldr	r2, [r7, #12]
 800272e:	fbb2 f2f3 	udiv	r2, r2, r3
 8002732:	4613      	mov	r3, r2
 8002734:	009b      	lsls	r3, r3, #2
 8002736:	4413      	add	r3, r2
 8002738:	005b      	lsls	r3, r3, #1
 800273a:	461a      	mov	r2, r3
 800273c:	687b      	ldr	r3, [r7, #4]
 800273e:	695b      	ldr	r3, [r3, #20]
 8002740:	fbb2 f3f3 	udiv	r3, r2, r3
 8002744:	3305      	adds	r3, #5
 8002746:	613b      	str	r3, [r7, #16]
 8002748:	e01f      	b.n	800278a <HAL_I2S_Init+0xfa>
      }
      else
      {
        tmp = (uint32_t)(((((i2sclk / (packetlength * 8U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800274a:	697b      	ldr	r3, [r7, #20]
 800274c:	00db      	lsls	r3, r3, #3
 800274e:	68fa      	ldr	r2, [r7, #12]
 8002750:	fbb2 f2f3 	udiv	r2, r2, r3
 8002754:	4613      	mov	r3, r2
 8002756:	009b      	lsls	r3, r3, #2
 8002758:	4413      	add	r3, r2
 800275a:	005b      	lsls	r3, r3, #1
 800275c:	461a      	mov	r2, r3
 800275e:	687b      	ldr	r3, [r7, #4]
 8002760:	695b      	ldr	r3, [r3, #20]
 8002762:	fbb2 f3f3 	udiv	r3, r2, r3
 8002766:	3305      	adds	r3, #5
 8002768:	613b      	str	r3, [r7, #16]
 800276a:	e00e      	b.n	800278a <HAL_I2S_Init+0xfa>
      }
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint32_t)(((((i2sclk / packetlength) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800276c:	68fa      	ldr	r2, [r7, #12]
 800276e:	697b      	ldr	r3, [r7, #20]
 8002770:	fbb2 f2f3 	udiv	r2, r2, r3
 8002774:	4613      	mov	r3, r2
 8002776:	009b      	lsls	r3, r3, #2
 8002778:	4413      	add	r3, r2
 800277a:	005b      	lsls	r3, r3, #1
 800277c:	461a      	mov	r2, r3
 800277e:	687b      	ldr	r3, [r7, #4]
 8002780:	695b      	ldr	r3, [r3, #20]
 8002782:	fbb2 f3f3 	udiv	r3, r2, r3
 8002786:	3305      	adds	r3, #5
 8002788:	613b      	str	r3, [r7, #16]
    }

    /* Remove the flatting point */
    tmp = tmp / 10U;
 800278a:	693b      	ldr	r3, [r7, #16]
 800278c:	4a5c      	ldr	r2, [pc, #368]	@ (8002900 <HAL_I2S_Init+0x270>)
 800278e:	fba2 2303 	umull	r2, r3, r2, r3
 8002792:	08db      	lsrs	r3, r3, #3
 8002794:	613b      	str	r3, [r7, #16]

    /* Check the parity of the divider */
    i2sodd = (uint32_t)(tmp & (uint32_t)1U);
 8002796:	693b      	ldr	r3, [r7, #16]
 8002798:	f003 0301 	and.w	r3, r3, #1
 800279c:	61bb      	str	r3, [r7, #24]

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint32_t)((tmp - i2sodd) / 2U);
 800279e:	693a      	ldr	r2, [r7, #16]
 80027a0:	69bb      	ldr	r3, [r7, #24]
 80027a2:	1ad3      	subs	r3, r2, r3
 80027a4:	085b      	lsrs	r3, r3, #1
 80027a6:	61fb      	str	r3, [r7, #28]

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint32_t)(i2sodd << 8U);
 80027a8:	69bb      	ldr	r3, [r7, #24]
 80027aa:	021b      	lsls	r3, r3, #8
 80027ac:	61bb      	str	r3, [r7, #24]
 80027ae:	e003      	b.n	80027b8 <HAL_I2S_Init+0x128>
  }
  else
  {
    /* Set the default values */
    i2sdiv = 2U;
 80027b0:	2302      	movs	r3, #2
 80027b2:	61fb      	str	r3, [r7, #28]
    i2sodd = 0U;
 80027b4:	2300      	movs	r3, #0
 80027b6:	61bb      	str	r3, [r7, #24]
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2U) || (i2sdiv > 0xFFU))
 80027b8:	69fb      	ldr	r3, [r7, #28]
 80027ba:	2b01      	cmp	r3, #1
 80027bc:	d902      	bls.n	80027c4 <HAL_I2S_Init+0x134>
 80027be:	69fb      	ldr	r3, [r7, #28]
 80027c0:	2bff      	cmp	r3, #255	@ 0xff
 80027c2:	d907      	bls.n	80027d4 <HAL_I2S_Init+0x144>
  {
    /* Set the error code and execute error callback*/
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_PRESCALER);
 80027c4:	687b      	ldr	r3, [r7, #4]
 80027c6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80027c8:	f043 0210 	orr.w	r2, r3, #16
 80027cc:	687b      	ldr	r3, [r7, #4]
 80027ce:	645a      	str	r2, [r3, #68]	@ 0x44
    return  HAL_ERROR;
 80027d0:	2301      	movs	r3, #1
 80027d2:	e08f      	b.n	80028f4 <HAL_I2S_Init+0x264>
  }

  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/

  /* Write to SPIx I2SPR register the computed value */
  hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
 80027d4:	687b      	ldr	r3, [r7, #4]
 80027d6:	691a      	ldr	r2, [r3, #16]
 80027d8:	69bb      	ldr	r3, [r7, #24]
 80027da:	ea42 0103 	orr.w	r1, r2, r3
 80027de:	687b      	ldr	r3, [r7, #4]
 80027e0:	681b      	ldr	r3, [r3, #0]
 80027e2:	69fa      	ldr	r2, [r7, #28]
 80027e4:	430a      	orrs	r2, r1
 80027e6:	621a      	str	r2, [r3, #32]

  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  /* And configure the I2S with the I2S_InitStruct values                      */
  MODIFY_REG(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | \
 80027e8:	687b      	ldr	r3, [r7, #4]
 80027ea:	681b      	ldr	r3, [r3, #0]
 80027ec:	69db      	ldr	r3, [r3, #28]
 80027ee:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 80027f2:	f023 030f 	bic.w	r3, r3, #15
 80027f6:	687a      	ldr	r2, [r7, #4]
 80027f8:	6851      	ldr	r1, [r2, #4]
 80027fa:	687a      	ldr	r2, [r7, #4]
 80027fc:	6892      	ldr	r2, [r2, #8]
 80027fe:	4311      	orrs	r1, r2
 8002800:	687a      	ldr	r2, [r7, #4]
 8002802:	68d2      	ldr	r2, [r2, #12]
 8002804:	4311      	orrs	r1, r2
 8002806:	687a      	ldr	r2, [r7, #4]
 8002808:	6992      	ldr	r2, [r2, #24]
 800280a:	430a      	orrs	r2, r1
 800280c:	431a      	orrs	r2, r3
 800280e:	687b      	ldr	r3, [r7, #4]
 8002810:	681b      	ldr	r3, [r3, #0]
 8002812:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8002816:	61da      	str	r2, [r3, #28]
#if defined (SPI_I2S_FULLDUPLEX_SUPPORT)

  /* Configure the I2S extended if the full duplex mode is enabled */
  assert_param(IS_I2S_FULLDUPLEX_MODE(hi2s->Init.FullDuplexMode));

  if (hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 8002818:	687b      	ldr	r3, [r7, #4]
 800281a:	6a1b      	ldr	r3, [r3, #32]
 800281c:	2b01      	cmp	r3, #1
 800281e:	d161      	bne.n	80028e4 <HAL_I2S_Init+0x254>
  {
    /* Set FullDuplex I2S IrqHandler ISR if FULLDUPLEXMODE is enabled */
    hi2s->IrqHandlerISR = HAL_I2SEx_FullDuplex_IRQHandler;
 8002820:	687b      	ldr	r3, [r7, #4]
 8002822:	4a38      	ldr	r2, [pc, #224]	@ (8002904 <HAL_I2S_Init+0x274>)
 8002824:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    CLEAR_BIT(I2SxEXT(hi2s->Instance)->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 8002826:	687b      	ldr	r3, [r7, #4]
 8002828:	681b      	ldr	r3, [r3, #0]
 800282a:	4a37      	ldr	r2, [pc, #220]	@ (8002908 <HAL_I2S_Init+0x278>)
 800282c:	4293      	cmp	r3, r2
 800282e:	d101      	bne.n	8002834 <HAL_I2S_Init+0x1a4>
 8002830:	4b36      	ldr	r3, [pc, #216]	@ (800290c <HAL_I2S_Init+0x27c>)
 8002832:	e001      	b.n	8002838 <HAL_I2S_Init+0x1a8>
 8002834:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002838:	69db      	ldr	r3, [r3, #28]
 800283a:	687a      	ldr	r2, [r7, #4]
 800283c:	6812      	ldr	r2, [r2, #0]
 800283e:	4932      	ldr	r1, [pc, #200]	@ (8002908 <HAL_I2S_Init+0x278>)
 8002840:	428a      	cmp	r2, r1
 8002842:	d101      	bne.n	8002848 <HAL_I2S_Init+0x1b8>
 8002844:	4a31      	ldr	r2, [pc, #196]	@ (800290c <HAL_I2S_Init+0x27c>)
 8002846:	e001      	b.n	800284c <HAL_I2S_Init+0x1bc>
 8002848:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 800284c:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 8002850:	f023 030f 	bic.w	r3, r3, #15
 8002854:	61d3      	str	r3, [r2, #28]
                                                 SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                                 SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
    I2SxEXT(hi2s->Instance)->I2SPR = 2U;
 8002856:	687b      	ldr	r3, [r7, #4]
 8002858:	681b      	ldr	r3, [r3, #0]
 800285a:	4a2b      	ldr	r2, [pc, #172]	@ (8002908 <HAL_I2S_Init+0x278>)
 800285c:	4293      	cmp	r3, r2
 800285e:	d101      	bne.n	8002864 <HAL_I2S_Init+0x1d4>
 8002860:	4b2a      	ldr	r3, [pc, #168]	@ (800290c <HAL_I2S_Init+0x27c>)
 8002862:	e001      	b.n	8002868 <HAL_I2S_Init+0x1d8>
 8002864:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002868:	2202      	movs	r2, #2
 800286a:	621a      	str	r2, [r3, #32]

    /* Get the I2SCFGR register value */
    tmpreg = I2SxEXT(hi2s->Instance)->I2SCFGR;
 800286c:	687b      	ldr	r3, [r7, #4]
 800286e:	681b      	ldr	r3, [r3, #0]
 8002870:	4a25      	ldr	r2, [pc, #148]	@ (8002908 <HAL_I2S_Init+0x278>)
 8002872:	4293      	cmp	r3, r2
 8002874:	d101      	bne.n	800287a <HAL_I2S_Init+0x1ea>
 8002876:	4b25      	ldr	r3, [pc, #148]	@ (800290c <HAL_I2S_Init+0x27c>)
 8002878:	e001      	b.n	800287e <HAL_I2S_Init+0x1ee>
 800287a:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800287e:	69db      	ldr	r3, [r3, #28]
 8002880:	817b      	strh	r3, [r7, #10]

    /* Get the mode to be configured for the extended I2S */
    if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 8002882:	687b      	ldr	r3, [r7, #4]
 8002884:	685b      	ldr	r3, [r3, #4]
 8002886:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800288a:	d003      	beq.n	8002894 <HAL_I2S_Init+0x204>
 800288c:	687b      	ldr	r3, [r7, #4]
 800288e:	685b      	ldr	r3, [r3, #4]
 8002890:	2b00      	cmp	r3, #0
 8002892:	d103      	bne.n	800289c <HAL_I2S_Init+0x20c>
    {
      tmp = I2S_MODE_SLAVE_RX;
 8002894:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8002898:	613b      	str	r3, [r7, #16]
 800289a:	e001      	b.n	80028a0 <HAL_I2S_Init+0x210>
    }
    else /* I2S_MODE_MASTER_RX ||  I2S_MODE_SLAVE_RX */
    {
      tmp = I2S_MODE_SLAVE_TX;
 800289c:	2300      	movs	r3, #0
 800289e:	613b      	str	r3, [r7, #16]
    }

    /* Configure the I2S Slave with the I2S Master parameter values */
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
                         (uint16_t)tmp                   | \
 80028a0:	693b      	ldr	r3, [r7, #16]
 80028a2:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.Standard   | \
 80028a4:	687b      	ldr	r3, [r7, #4]
 80028a6:	689b      	ldr	r3, [r3, #8]
 80028a8:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 80028aa:	4313      	orrs	r3, r2
 80028ac:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.DataFormat | \
 80028ae:	687b      	ldr	r3, [r7, #4]
 80028b0:	68db      	ldr	r3, [r3, #12]
 80028b2:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 80028b4:	4313      	orrs	r3, r2
 80028b6:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.CPOL);
 80028b8:	687b      	ldr	r3, [r7, #4]
 80028ba:	699b      	ldr	r3, [r3, #24]
 80028bc:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 80028be:	4313      	orrs	r3, r2
 80028c0:	b29a      	uxth	r2, r3
 80028c2:	897b      	ldrh	r3, [r7, #10]
 80028c4:	4313      	orrs	r3, r2
 80028c6:	b29b      	uxth	r3, r3
 80028c8:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 80028cc:	817b      	strh	r3, [r7, #10]

    /* Write to SPIx I2SCFGR */
    WRITE_REG(I2SxEXT(hi2s->Instance)->I2SCFGR, tmpreg);
 80028ce:	687b      	ldr	r3, [r7, #4]
 80028d0:	681b      	ldr	r3, [r3, #0]
 80028d2:	4a0d      	ldr	r2, [pc, #52]	@ (8002908 <HAL_I2S_Init+0x278>)
 80028d4:	4293      	cmp	r3, r2
 80028d6:	d101      	bne.n	80028dc <HAL_I2S_Init+0x24c>
 80028d8:	4b0c      	ldr	r3, [pc, #48]	@ (800290c <HAL_I2S_Init+0x27c>)
 80028da:	e001      	b.n	80028e0 <HAL_I2S_Init+0x250>
 80028dc:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 80028e0:	897a      	ldrh	r2, [r7, #10]
 80028e2:	61da      	str	r2, [r3, #28]
  }
#endif /* SPI_I2S_FULLDUPLEX_SUPPORT */

  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 80028e4:	687b      	ldr	r3, [r7, #4]
 80028e6:	2200      	movs	r2, #0
 80028e8:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2s->State     = HAL_I2S_STATE_READY;
 80028ea:	687b      	ldr	r3, [r7, #4]
 80028ec:	2201      	movs	r2, #1
 80028ee:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  return HAL_OK;
 80028f2:	2300      	movs	r3, #0
}
 80028f4:	4618      	mov	r0, r3
 80028f6:	3720      	adds	r7, #32
 80028f8:	46bd      	mov	sp, r7
 80028fa:	bd80      	pop	{r7, pc}
 80028fc:	08002a07 	.word	0x08002a07
 8002900:	cccccccd 	.word	0xcccccccd
 8002904:	08002b1d 	.word	0x08002b1d
 8002908:	40003800 	.word	0x40003800
 800290c:	40003400 	.word	0x40003400

08002910 <HAL_I2S_TxCpltCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8002910:	b480      	push	{r7}
 8002912:	b083      	sub	sp, #12
 8002914:	af00      	add	r7, sp, #0
 8002916:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_TxCpltCallback could be implemented in the user file
   */
}
 8002918:	bf00      	nop
 800291a:	370c      	adds	r7, #12
 800291c:	46bd      	mov	sp, r7
 800291e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002922:	4770      	bx	lr

08002924 <HAL_I2S_RxCpltCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8002924:	b480      	push	{r7}
 8002926:	b083      	sub	sp, #12
 8002928:	af00      	add	r7, sp, #0
 800292a:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_RxCpltCallback could be implemented in the user file
   */
}
 800292c:	bf00      	nop
 800292e:	370c      	adds	r7, #12
 8002930:	46bd      	mov	sp, r7
 8002932:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002936:	4770      	bx	lr

08002938 <HAL_I2S_ErrorCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_ErrorCallback(I2S_HandleTypeDef *hi2s)
{
 8002938:	b480      	push	{r7}
 800293a:	b083      	sub	sp, #12
 800293c:	af00      	add	r7, sp, #0
 800293e:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_ErrorCallback could be implemented in the user file
   */
}
 8002940:	bf00      	nop
 8002942:	370c      	adds	r7, #12
 8002944:	46bd      	mov	sp, r7
 8002946:	f85d 7b04 	ldr.w	r7, [sp], #4
 800294a:	4770      	bx	lr

0800294c <I2S_Transmit_IT>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_Transmit_IT(I2S_HandleTypeDef *hi2s)
{
 800294c:	b580      	push	{r7, lr}
 800294e:	b082      	sub	sp, #8
 8002950:	af00      	add	r7, sp, #0
 8002952:	6078      	str	r0, [r7, #4]
  /* Transmit data */
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr);
 8002954:	687b      	ldr	r3, [r7, #4]
 8002956:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002958:	881a      	ldrh	r2, [r3, #0]
 800295a:	687b      	ldr	r3, [r7, #4]
 800295c:	681b      	ldr	r3, [r3, #0]
 800295e:	60da      	str	r2, [r3, #12]
  hi2s->pTxBuffPtr++;
 8002960:	687b      	ldr	r3, [r7, #4]
 8002962:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002964:	1c9a      	adds	r2, r3, #2
 8002966:	687b      	ldr	r3, [r7, #4]
 8002968:	625a      	str	r2, [r3, #36]	@ 0x24
  hi2s->TxXferCount--;
 800296a:	687b      	ldr	r3, [r7, #4]
 800296c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800296e:	b29b      	uxth	r3, r3
 8002970:	3b01      	subs	r3, #1
 8002972:	b29a      	uxth	r2, r3
 8002974:	687b      	ldr	r3, [r7, #4]
 8002976:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 8002978:	687b      	ldr	r3, [r7, #4]
 800297a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800297c:	b29b      	uxth	r3, r3
 800297e:	2b00      	cmp	r3, #0
 8002980:	d10e      	bne.n	80029a0 <I2S_Transmit_IT+0x54>
  {
    /* Disable TXE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002982:	687b      	ldr	r3, [r7, #4]
 8002984:	681b      	ldr	r3, [r3, #0]
 8002986:	685a      	ldr	r2, [r3, #4]
 8002988:	687b      	ldr	r3, [r7, #4]
 800298a:	681b      	ldr	r3, [r3, #0]
 800298c:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002990:	605a      	str	r2, [r3, #4]

    hi2s->State = HAL_I2S_STATE_READY;
 8002992:	687b      	ldr	r3, [r7, #4]
 8002994:	2201      	movs	r2, #1
 8002996:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    /* Call user Tx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    hi2s->TxCpltCallback(hi2s);
#else
    HAL_I2S_TxCpltCallback(hi2s);
 800299a:	6878      	ldr	r0, [r7, #4]
 800299c:	f7ff ffb8 	bl	8002910 <HAL_I2S_TxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }
}
 80029a0:	bf00      	nop
 80029a2:	3708      	adds	r7, #8
 80029a4:	46bd      	mov	sp, r7
 80029a6:	bd80      	pop	{r7, pc}

080029a8 <I2S_Receive_IT>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_Receive_IT(I2S_HandleTypeDef *hi2s)
{
 80029a8:	b580      	push	{r7, lr}
 80029aa:	b082      	sub	sp, #8
 80029ac:	af00      	add	r7, sp, #0
 80029ae:	6078      	str	r0, [r7, #4]
  /* Receive data */
  (*hi2s->pRxBuffPtr) = (uint16_t)hi2s->Instance->DR;
 80029b0:	687b      	ldr	r3, [r7, #4]
 80029b2:	681b      	ldr	r3, [r3, #0]
 80029b4:	68da      	ldr	r2, [r3, #12]
 80029b6:	687b      	ldr	r3, [r7, #4]
 80029b8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80029ba:	b292      	uxth	r2, r2
 80029bc:	801a      	strh	r2, [r3, #0]
  hi2s->pRxBuffPtr++;
 80029be:	687b      	ldr	r3, [r7, #4]
 80029c0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80029c2:	1c9a      	adds	r2, r3, #2
 80029c4:	687b      	ldr	r3, [r7, #4]
 80029c6:	62da      	str	r2, [r3, #44]	@ 0x2c
  hi2s->RxXferCount--;
 80029c8:	687b      	ldr	r3, [r7, #4]
 80029ca:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 80029cc:	b29b      	uxth	r3, r3
 80029ce:	3b01      	subs	r3, #1
 80029d0:	b29a      	uxth	r2, r3
 80029d2:	687b      	ldr	r3, [r7, #4]
 80029d4:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 80029d6:	687b      	ldr	r3, [r7, #4]
 80029d8:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 80029da:	b29b      	uxth	r3, r3
 80029dc:	2b00      	cmp	r3, #0
 80029de:	d10e      	bne.n	80029fe <I2S_Receive_IT+0x56>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80029e0:	687b      	ldr	r3, [r7, #4]
 80029e2:	681b      	ldr	r3, [r3, #0]
 80029e4:	685a      	ldr	r2, [r3, #4]
 80029e6:	687b      	ldr	r3, [r7, #4]
 80029e8:	681b      	ldr	r3, [r3, #0]
 80029ea:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 80029ee:	605a      	str	r2, [r3, #4]

    hi2s->State = HAL_I2S_STATE_READY;
 80029f0:	687b      	ldr	r3, [r7, #4]
 80029f2:	2201      	movs	r2, #1
 80029f4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    /* Call user Rx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    hi2s->RxCpltCallback(hi2s);
#else
    HAL_I2S_RxCpltCallback(hi2s);
 80029f8:	6878      	ldr	r0, [r7, #4]
 80029fa:	f7ff ff93 	bl	8002924 <HAL_I2S_RxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }
}
 80029fe:	bf00      	nop
 8002a00:	3708      	adds	r7, #8
 8002a02:	46bd      	mov	sp, r7
 8002a04:	bd80      	pop	{r7, pc}

08002a06 <I2S_IRQHandler>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 8002a06:	b580      	push	{r7, lr}
 8002a08:	b086      	sub	sp, #24
 8002a0a:	af00      	add	r7, sp, #0
 8002a0c:	6078      	str	r0, [r7, #4]
  __IO uint32_t i2ssr = hi2s->Instance->SR;
 8002a0e:	687b      	ldr	r3, [r7, #4]
 8002a10:	681b      	ldr	r3, [r3, #0]
 8002a12:	689b      	ldr	r3, [r3, #8]
 8002a14:	617b      	str	r3, [r7, #20]

  if (hi2s->State == HAL_I2S_STATE_BUSY_RX)
 8002a16:	687b      	ldr	r3, [r7, #4]
 8002a18:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002a1c:	b2db      	uxtb	r3, r3
 8002a1e:	2b04      	cmp	r3, #4
 8002a20:	d13a      	bne.n	8002a98 <I2S_IRQHandler+0x92>
  {
    /* I2S in mode Receiver ------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE) != RESET))
 8002a22:	697b      	ldr	r3, [r7, #20]
 8002a24:	f003 0301 	and.w	r3, r3, #1
 8002a28:	2b01      	cmp	r3, #1
 8002a2a:	d109      	bne.n	8002a40 <I2S_IRQHandler+0x3a>
 8002a2c:	687b      	ldr	r3, [r7, #4]
 8002a2e:	681b      	ldr	r3, [r3, #0]
 8002a30:	685b      	ldr	r3, [r3, #4]
 8002a32:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002a36:	2b40      	cmp	r3, #64	@ 0x40
 8002a38:	d102      	bne.n	8002a40 <I2S_IRQHandler+0x3a>
    {
      I2S_Receive_IT(hi2s);
 8002a3a:	6878      	ldr	r0, [r7, #4]
 8002a3c:	f7ff ffb4 	bl	80029a8 <I2S_Receive_IT>
    }

    /* I2S Overrun error interrupt occurred -------------------------------------*/
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 8002a40:	697b      	ldr	r3, [r7, #20]
 8002a42:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002a46:	2b40      	cmp	r3, #64	@ 0x40
 8002a48:	d126      	bne.n	8002a98 <I2S_IRQHandler+0x92>
 8002a4a:	687b      	ldr	r3, [r7, #4]
 8002a4c:	681b      	ldr	r3, [r3, #0]
 8002a4e:	685b      	ldr	r3, [r3, #4]
 8002a50:	f003 0320 	and.w	r3, r3, #32
 8002a54:	2b20      	cmp	r3, #32
 8002a56:	d11f      	bne.n	8002a98 <I2S_IRQHandler+0x92>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002a58:	687b      	ldr	r3, [r7, #4]
 8002a5a:	681b      	ldr	r3, [r3, #0]
 8002a5c:	685a      	ldr	r2, [r3, #4]
 8002a5e:	687b      	ldr	r3, [r7, #4]
 8002a60:	681b      	ldr	r3, [r3, #0]
 8002a62:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002a66:	605a      	str	r2, [r3, #4]

      /* Clear Overrun flag */
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8002a68:	2300      	movs	r3, #0
 8002a6a:	613b      	str	r3, [r7, #16]
 8002a6c:	687b      	ldr	r3, [r7, #4]
 8002a6e:	681b      	ldr	r3, [r3, #0]
 8002a70:	68db      	ldr	r3, [r3, #12]
 8002a72:	613b      	str	r3, [r7, #16]
 8002a74:	687b      	ldr	r3, [r7, #4]
 8002a76:	681b      	ldr	r3, [r3, #0]
 8002a78:	689b      	ldr	r3, [r3, #8]
 8002a7a:	613b      	str	r3, [r7, #16]
 8002a7c:	693b      	ldr	r3, [r7, #16]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002a7e:	687b      	ldr	r3, [r7, #4]
 8002a80:	2201      	movs	r2, #1
 8002a82:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41


      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8002a86:	687b      	ldr	r3, [r7, #4]
 8002a88:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002a8a:	f043 0202 	orr.w	r2, r3, #2
 8002a8e:	687b      	ldr	r3, [r7, #4]
 8002a90:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002a92:	6878      	ldr	r0, [r7, #4]
 8002a94:	f7ff ff50 	bl	8002938 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }

  if (hi2s->State == HAL_I2S_STATE_BUSY_TX)
 8002a98:	687b      	ldr	r3, [r7, #4]
 8002a9a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002a9e:	b2db      	uxtb	r3, r3
 8002aa0:	2b03      	cmp	r3, #3
 8002aa2:	d136      	bne.n	8002b12 <I2S_IRQHandler+0x10c>
  {
    /* I2S in mode Transmitter -----------------------------------------------*/
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE) != RESET))
 8002aa4:	697b      	ldr	r3, [r7, #20]
 8002aa6:	f003 0302 	and.w	r3, r3, #2
 8002aaa:	2b02      	cmp	r3, #2
 8002aac:	d109      	bne.n	8002ac2 <I2S_IRQHandler+0xbc>
 8002aae:	687b      	ldr	r3, [r7, #4]
 8002ab0:	681b      	ldr	r3, [r3, #0]
 8002ab2:	685b      	ldr	r3, [r3, #4]
 8002ab4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002ab8:	2b80      	cmp	r3, #128	@ 0x80
 8002aba:	d102      	bne.n	8002ac2 <I2S_IRQHandler+0xbc>
    {
      I2S_Transmit_IT(hi2s);
 8002abc:	6878      	ldr	r0, [r7, #4]
 8002abe:	f7ff ff45 	bl	800294c <I2S_Transmit_IT>
    }

    /* I2S Underrun error interrupt occurred --------------------------------*/
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 8002ac2:	697b      	ldr	r3, [r7, #20]
 8002ac4:	f003 0308 	and.w	r3, r3, #8
 8002ac8:	2b08      	cmp	r3, #8
 8002aca:	d122      	bne.n	8002b12 <I2S_IRQHandler+0x10c>
 8002acc:	687b      	ldr	r3, [r7, #4]
 8002ace:	681b      	ldr	r3, [r3, #0]
 8002ad0:	685b      	ldr	r3, [r3, #4]
 8002ad2:	f003 0320 	and.w	r3, r3, #32
 8002ad6:	2b20      	cmp	r3, #32
 8002ad8:	d11b      	bne.n	8002b12 <I2S_IRQHandler+0x10c>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002ada:	687b      	ldr	r3, [r7, #4]
 8002adc:	681b      	ldr	r3, [r3, #0]
 8002ade:	685a      	ldr	r2, [r3, #4]
 8002ae0:	687b      	ldr	r3, [r7, #4]
 8002ae2:	681b      	ldr	r3, [r3, #0]
 8002ae4:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002ae8:	605a      	str	r2, [r3, #4]

      /* Clear Underrun flag */
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 8002aea:	2300      	movs	r3, #0
 8002aec:	60fb      	str	r3, [r7, #12]
 8002aee:	687b      	ldr	r3, [r7, #4]
 8002af0:	681b      	ldr	r3, [r3, #0]
 8002af2:	689b      	ldr	r3, [r3, #8]
 8002af4:	60fb      	str	r3, [r7, #12]
 8002af6:	68fb      	ldr	r3, [r7, #12]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002af8:	687b      	ldr	r3, [r7, #4]
 8002afa:	2201      	movs	r2, #1
 8002afc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 8002b00:	687b      	ldr	r3, [r7, #4]
 8002b02:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002b04:	f043 0204 	orr.w	r2, r3, #4
 8002b08:	687b      	ldr	r3, [r7, #4]
 8002b0a:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002b0c:	6878      	ldr	r0, [r7, #4]
 8002b0e:	f7ff ff13 	bl	8002938 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002b12:	bf00      	nop
 8002b14:	3718      	adds	r7, #24
 8002b16:	46bd      	mov	sp, r7
 8002b18:	bd80      	pop	{r7, pc}
	...

08002b1c <HAL_I2SEx_FullDuplex_IRQHandler>:
  * @brief  This function handles I2S/I2Sext interrupt requests in full-duplex mode.
  * @param  hi2s I2S handle
  * @retval HAL status
  */
void HAL_I2SEx_FullDuplex_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 8002b1c:	b580      	push	{r7, lr}
 8002b1e:	b088      	sub	sp, #32
 8002b20:	af00      	add	r7, sp, #0
 8002b22:	6078      	str	r0, [r7, #4]
  __IO uint32_t i2ssr     = hi2s->Instance->SR;
 8002b24:	687b      	ldr	r3, [r7, #4]
 8002b26:	681b      	ldr	r3, [r3, #0]
 8002b28:	689b      	ldr	r3, [r3, #8]
 8002b2a:	61fb      	str	r3, [r7, #28]
  __IO uint32_t i2sextsr  = I2SxEXT(hi2s->Instance)->SR;
 8002b2c:	687b      	ldr	r3, [r7, #4]
 8002b2e:	681b      	ldr	r3, [r3, #0]
 8002b30:	4a92      	ldr	r2, [pc, #584]	@ (8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002b32:	4293      	cmp	r3, r2
 8002b34:	d101      	bne.n	8002b3a <HAL_I2SEx_FullDuplex_IRQHandler+0x1e>
 8002b36:	4b92      	ldr	r3, [pc, #584]	@ (8002d80 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002b38:	e001      	b.n	8002b3e <HAL_I2SEx_FullDuplex_IRQHandler+0x22>
 8002b3a:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002b3e:	689b      	ldr	r3, [r3, #8]
 8002b40:	61bb      	str	r3, [r7, #24]
  __IO uint32_t i2scr2    = hi2s->Instance->CR2;
 8002b42:	687b      	ldr	r3, [r7, #4]
 8002b44:	681b      	ldr	r3, [r3, #0]
 8002b46:	685b      	ldr	r3, [r3, #4]
 8002b48:	617b      	str	r3, [r7, #20]
  __IO uint32_t i2sextcr2 = I2SxEXT(hi2s->Instance)->CR2;
 8002b4a:	687b      	ldr	r3, [r7, #4]
 8002b4c:	681b      	ldr	r3, [r3, #0]
 8002b4e:	4a8b      	ldr	r2, [pc, #556]	@ (8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002b50:	4293      	cmp	r3, r2
 8002b52:	d101      	bne.n	8002b58 <HAL_I2SEx_FullDuplex_IRQHandler+0x3c>
 8002b54:	4b8a      	ldr	r3, [pc, #552]	@ (8002d80 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002b56:	e001      	b.n	8002b5c <HAL_I2SEx_FullDuplex_IRQHandler+0x40>
 8002b58:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002b5c:	685b      	ldr	r3, [r3, #4]
 8002b5e:	613b      	str	r3, [r7, #16]

  /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
  if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 8002b60:	687b      	ldr	r3, [r7, #4]
 8002b62:	685b      	ldr	r3, [r3, #4]
 8002b64:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8002b68:	d004      	beq.n	8002b74 <HAL_I2SEx_FullDuplex_IRQHandler+0x58>
 8002b6a:	687b      	ldr	r3, [r7, #4]
 8002b6c:	685b      	ldr	r3, [r3, #4]
 8002b6e:	2b00      	cmp	r3, #0
 8002b70:	f040 8099 	bne.w	8002ca6 <HAL_I2SEx_FullDuplex_IRQHandler+0x18a>
  {
    /* I2S in mode Transmitter -------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2scr2 & I2S_IT_TXE) != RESET))
 8002b74:	69fb      	ldr	r3, [r7, #28]
 8002b76:	f003 0302 	and.w	r3, r3, #2
 8002b7a:	2b02      	cmp	r3, #2
 8002b7c:	d107      	bne.n	8002b8e <HAL_I2SEx_FullDuplex_IRQHandler+0x72>
 8002b7e:	697b      	ldr	r3, [r7, #20]
 8002b80:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002b84:	2b00      	cmp	r3, #0
 8002b86:	d002      	beq.n	8002b8e <HAL_I2SEx_FullDuplex_IRQHandler+0x72>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
      the I2S TXE interrupt will be generated to manage the full-duplex transmit phase. */
      I2SEx_TxISR_I2S(hi2s);
 8002b88:	6878      	ldr	r0, [r7, #4]
 8002b8a:	f000 f925 	bl	8002dd8 <I2SEx_TxISR_I2S>
    }

    /* I2Sext in mode Receiver -----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2sextcr2 & I2S_IT_RXNE) != RESET))
 8002b8e:	69bb      	ldr	r3, [r7, #24]
 8002b90:	f003 0301 	and.w	r3, r3, #1
 8002b94:	2b01      	cmp	r3, #1
 8002b96:	d107      	bne.n	8002ba8 <HAL_I2SEx_FullDuplex_IRQHandler+0x8c>
 8002b98:	693b      	ldr	r3, [r7, #16]
 8002b9a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002b9e:	2b00      	cmp	r3, #0
 8002ba0:	d002      	beq.n	8002ba8 <HAL_I2SEx_FullDuplex_IRQHandler+0x8c>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
      the I2Sext RXNE interrupt will be generated to manage the full-duplex receive phase. */
      I2SEx_RxISR_I2SExt(hi2s);
 8002ba2:	6878      	ldr	r0, [r7, #4]
 8002ba4:	f000 f9c8 	bl	8002f38 <I2SEx_RxISR_I2SExt>
    }

    /* I2Sext Overrun error interrupt occurred --------------------------------*/
    if (((i2sextsr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 8002ba8:	69bb      	ldr	r3, [r7, #24]
 8002baa:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002bae:	2b40      	cmp	r3, #64	@ 0x40
 8002bb0:	d13a      	bne.n	8002c28 <HAL_I2SEx_FullDuplex_IRQHandler+0x10c>
 8002bb2:	693b      	ldr	r3, [r7, #16]
 8002bb4:	f003 0320 	and.w	r3, r3, #32
 8002bb8:	2b00      	cmp	r3, #0
 8002bba:	d035      	beq.n	8002c28 <HAL_I2SEx_FullDuplex_IRQHandler+0x10c>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002bbc:	687b      	ldr	r3, [r7, #4]
 8002bbe:	681b      	ldr	r3, [r3, #0]
 8002bc0:	4a6e      	ldr	r2, [pc, #440]	@ (8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002bc2:	4293      	cmp	r3, r2
 8002bc4:	d101      	bne.n	8002bca <HAL_I2SEx_FullDuplex_IRQHandler+0xae>
 8002bc6:	4b6e      	ldr	r3, [pc, #440]	@ (8002d80 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002bc8:	e001      	b.n	8002bce <HAL_I2SEx_FullDuplex_IRQHandler+0xb2>
 8002bca:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002bce:	685a      	ldr	r2, [r3, #4]
 8002bd0:	687b      	ldr	r3, [r7, #4]
 8002bd2:	681b      	ldr	r3, [r3, #0]
 8002bd4:	4969      	ldr	r1, [pc, #420]	@ (8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002bd6:	428b      	cmp	r3, r1
 8002bd8:	d101      	bne.n	8002bde <HAL_I2SEx_FullDuplex_IRQHandler+0xc2>
 8002bda:	4b69      	ldr	r3, [pc, #420]	@ (8002d80 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002bdc:	e001      	b.n	8002be2 <HAL_I2SEx_FullDuplex_IRQHandler+0xc6>
 8002bde:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002be2:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002be6:	605a      	str	r2, [r3, #4]

      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002be8:	687b      	ldr	r3, [r7, #4]
 8002bea:	681b      	ldr	r3, [r3, #0]
 8002bec:	685a      	ldr	r2, [r3, #4]
 8002bee:	687b      	ldr	r3, [r7, #4]
 8002bf0:	681b      	ldr	r3, [r3, #0]
 8002bf2:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002bf6:	605a      	str	r2, [r3, #4]

      /* Clear Overrun flag */
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8002bf8:	2300      	movs	r3, #0
 8002bfa:	60fb      	str	r3, [r7, #12]
 8002bfc:	687b      	ldr	r3, [r7, #4]
 8002bfe:	681b      	ldr	r3, [r3, #0]
 8002c00:	68db      	ldr	r3, [r3, #12]
 8002c02:	60fb      	str	r3, [r7, #12]
 8002c04:	687b      	ldr	r3, [r7, #4]
 8002c06:	681b      	ldr	r3, [r3, #0]
 8002c08:	689b      	ldr	r3, [r3, #8]
 8002c0a:	60fb      	str	r3, [r7, #12]
 8002c0c:	68fb      	ldr	r3, [r7, #12]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002c0e:	687b      	ldr	r3, [r7, #4]
 8002c10:	2201      	movs	r2, #1
 8002c12:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8002c16:	687b      	ldr	r3, [r7, #4]
 8002c18:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002c1a:	f043 0202 	orr.w	r2, r3, #2
 8002c1e:	687b      	ldr	r3, [r7, #4]
 8002c20:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002c22:	6878      	ldr	r0, [r7, #4]
 8002c24:	f7ff fe88 	bl	8002938 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }

    /* I2S Underrun error interrupt occurred ----------------------------------*/
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002c28:	69fb      	ldr	r3, [r7, #28]
 8002c2a:	f003 0308 	and.w	r3, r3, #8
 8002c2e:	2b08      	cmp	r3, #8
 8002c30:	f040 80c3 	bne.w	8002dba <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
 8002c34:	697b      	ldr	r3, [r7, #20]
 8002c36:	f003 0320 	and.w	r3, r3, #32
 8002c3a:	2b00      	cmp	r3, #0
 8002c3c:	f000 80bd 	beq.w	8002dba <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002c40:	687b      	ldr	r3, [r7, #4]
 8002c42:	681b      	ldr	r3, [r3, #0]
 8002c44:	685a      	ldr	r2, [r3, #4]
 8002c46:	687b      	ldr	r3, [r7, #4]
 8002c48:	681b      	ldr	r3, [r3, #0]
 8002c4a:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002c4e:	605a      	str	r2, [r3, #4]

      /* Disable RXNE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002c50:	687b      	ldr	r3, [r7, #4]
 8002c52:	681b      	ldr	r3, [r3, #0]
 8002c54:	4a49      	ldr	r2, [pc, #292]	@ (8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002c56:	4293      	cmp	r3, r2
 8002c58:	d101      	bne.n	8002c5e <HAL_I2SEx_FullDuplex_IRQHandler+0x142>
 8002c5a:	4b49      	ldr	r3, [pc, #292]	@ (8002d80 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002c5c:	e001      	b.n	8002c62 <HAL_I2SEx_FullDuplex_IRQHandler+0x146>
 8002c5e:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002c62:	685a      	ldr	r2, [r3, #4]
 8002c64:	687b      	ldr	r3, [r7, #4]
 8002c66:	681b      	ldr	r3, [r3, #0]
 8002c68:	4944      	ldr	r1, [pc, #272]	@ (8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002c6a:	428b      	cmp	r3, r1
 8002c6c:	d101      	bne.n	8002c72 <HAL_I2SEx_FullDuplex_IRQHandler+0x156>
 8002c6e:	4b44      	ldr	r3, [pc, #272]	@ (8002d80 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002c70:	e001      	b.n	8002c76 <HAL_I2SEx_FullDuplex_IRQHandler+0x15a>
 8002c72:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002c76:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002c7a:	605a      	str	r2, [r3, #4]

      /* Clear underrun flag */
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 8002c7c:	2300      	movs	r3, #0
 8002c7e:	60bb      	str	r3, [r7, #8]
 8002c80:	687b      	ldr	r3, [r7, #4]
 8002c82:	681b      	ldr	r3, [r3, #0]
 8002c84:	689b      	ldr	r3, [r3, #8]
 8002c86:	60bb      	str	r3, [r7, #8]
 8002c88:	68bb      	ldr	r3, [r7, #8]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002c8a:	687b      	ldr	r3, [r7, #4]
 8002c8c:	2201      	movs	r2, #1
 8002c8e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 8002c92:	687b      	ldr	r3, [r7, #4]
 8002c94:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002c96:	f043 0204 	orr.w	r2, r3, #4
 8002c9a:	687b      	ldr	r3, [r7, #4]
 8002c9c:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002c9e:	6878      	ldr	r0, [r7, #4]
 8002ca0:	f7ff fe4a 	bl	8002938 <HAL_I2S_ErrorCallback>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002ca4:	e089      	b.n	8002dba <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
  }
  /* The I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX Mode is selected */
  else
  {
    /* I2Sext in mode Transmitter ----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2sextcr2 & I2S_IT_TXE) != RESET))
 8002ca6:	69bb      	ldr	r3, [r7, #24]
 8002ca8:	f003 0302 	and.w	r3, r3, #2
 8002cac:	2b02      	cmp	r3, #2
 8002cae:	d107      	bne.n	8002cc0 <HAL_I2SEx_FullDuplex_IRQHandler+0x1a4>
 8002cb0:	693b      	ldr	r3, [r7, #16]
 8002cb2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002cb6:	2b00      	cmp	r3, #0
 8002cb8:	d002      	beq.n	8002cc0 <HAL_I2SEx_FullDuplex_IRQHandler+0x1a4>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
      the I2Sext TXE interrupt will be generated to manage the full-duplex transmit phase. */
      I2SEx_TxISR_I2SExt(hi2s);
 8002cba:	6878      	ldr	r0, [r7, #4]
 8002cbc:	f000 f8be 	bl	8002e3c <I2SEx_TxISR_I2SExt>
    }

    /* I2S in mode Receiver --------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2scr2 & I2S_IT_RXNE) != RESET))
 8002cc0:	69fb      	ldr	r3, [r7, #28]
 8002cc2:	f003 0301 	and.w	r3, r3, #1
 8002cc6:	2b01      	cmp	r3, #1
 8002cc8:	d107      	bne.n	8002cda <HAL_I2SEx_FullDuplex_IRQHandler+0x1be>
 8002cca:	697b      	ldr	r3, [r7, #20]
 8002ccc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002cd0:	2b00      	cmp	r3, #0
 8002cd2:	d002      	beq.n	8002cda <HAL_I2SEx_FullDuplex_IRQHandler+0x1be>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
      the I2S RXNE interrupt will be generated to manage the full-duplex receive phase. */
      I2SEx_RxISR_I2S(hi2s);
 8002cd4:	6878      	ldr	r0, [r7, #4]
 8002cd6:	f000 f8fd 	bl	8002ed4 <I2SEx_RxISR_I2S>
    }

    /* I2S Overrun error interrupt occurred -------------------------------------*/
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002cda:	69fb      	ldr	r3, [r7, #28]
 8002cdc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002ce0:	2b40      	cmp	r3, #64	@ 0x40
 8002ce2:	d12f      	bne.n	8002d44 <HAL_I2SEx_FullDuplex_IRQHandler+0x228>
 8002ce4:	697b      	ldr	r3, [r7, #20]
 8002ce6:	f003 0320 	and.w	r3, r3, #32
 8002cea:	2b00      	cmp	r3, #0
 8002cec:	d02a      	beq.n	8002d44 <HAL_I2SEx_FullDuplex_IRQHandler+0x228>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002cee:	687b      	ldr	r3, [r7, #4]
 8002cf0:	681b      	ldr	r3, [r3, #0]
 8002cf2:	685a      	ldr	r2, [r3, #4]
 8002cf4:	687b      	ldr	r3, [r7, #4]
 8002cf6:	681b      	ldr	r3, [r3, #0]
 8002cf8:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002cfc:	605a      	str	r2, [r3, #4]

      /* Disable TXE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002cfe:	687b      	ldr	r3, [r7, #4]
 8002d00:	681b      	ldr	r3, [r3, #0]
 8002d02:	4a1e      	ldr	r2, [pc, #120]	@ (8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002d04:	4293      	cmp	r3, r2
 8002d06:	d101      	bne.n	8002d0c <HAL_I2SEx_FullDuplex_IRQHandler+0x1f0>
 8002d08:	4b1d      	ldr	r3, [pc, #116]	@ (8002d80 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002d0a:	e001      	b.n	8002d10 <HAL_I2SEx_FullDuplex_IRQHandler+0x1f4>
 8002d0c:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002d10:	685a      	ldr	r2, [r3, #4]
 8002d12:	687b      	ldr	r3, [r7, #4]
 8002d14:	681b      	ldr	r3, [r3, #0]
 8002d16:	4919      	ldr	r1, [pc, #100]	@ (8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002d18:	428b      	cmp	r3, r1
 8002d1a:	d101      	bne.n	8002d20 <HAL_I2SEx_FullDuplex_IRQHandler+0x204>
 8002d1c:	4b18      	ldr	r3, [pc, #96]	@ (8002d80 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002d1e:	e001      	b.n	8002d24 <HAL_I2SEx_FullDuplex_IRQHandler+0x208>
 8002d20:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002d24:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002d28:	605a      	str	r2, [r3, #4]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002d2a:	687b      	ldr	r3, [r7, #4]
 8002d2c:	2201      	movs	r2, #1
 8002d2e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8002d32:	687b      	ldr	r3, [r7, #4]
 8002d34:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002d36:	f043 0202 	orr.w	r2, r3, #2
 8002d3a:	687b      	ldr	r3, [r7, #4]
 8002d3c:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002d3e:	6878      	ldr	r0, [r7, #4]
 8002d40:	f7ff fdfa 	bl	8002938 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }

    /* I2Sext Underrun error interrupt occurred -------------------------------*/
    if (((i2sextsr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 8002d44:	69bb      	ldr	r3, [r7, #24]
 8002d46:	f003 0308 	and.w	r3, r3, #8
 8002d4a:	2b08      	cmp	r3, #8
 8002d4c:	d136      	bne.n	8002dbc <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
 8002d4e:	693b      	ldr	r3, [r7, #16]
 8002d50:	f003 0320 	and.w	r3, r3, #32
 8002d54:	2b00      	cmp	r3, #0
 8002d56:	d031      	beq.n	8002dbc <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002d58:	687b      	ldr	r3, [r7, #4]
 8002d5a:	681b      	ldr	r3, [r3, #0]
 8002d5c:	4a07      	ldr	r2, [pc, #28]	@ (8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002d5e:	4293      	cmp	r3, r2
 8002d60:	d101      	bne.n	8002d66 <HAL_I2SEx_FullDuplex_IRQHandler+0x24a>
 8002d62:	4b07      	ldr	r3, [pc, #28]	@ (8002d80 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002d64:	e001      	b.n	8002d6a <HAL_I2SEx_FullDuplex_IRQHandler+0x24e>
 8002d66:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002d6a:	685a      	ldr	r2, [r3, #4]
 8002d6c:	687b      	ldr	r3, [r7, #4]
 8002d6e:	681b      	ldr	r3, [r3, #0]
 8002d70:	4902      	ldr	r1, [pc, #8]	@ (8002d7c <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 8002d72:	428b      	cmp	r3, r1
 8002d74:	d106      	bne.n	8002d84 <HAL_I2SEx_FullDuplex_IRQHandler+0x268>
 8002d76:	4b02      	ldr	r3, [pc, #8]	@ (8002d80 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 8002d78:	e006      	b.n	8002d88 <HAL_I2SEx_FullDuplex_IRQHandler+0x26c>
 8002d7a:	bf00      	nop
 8002d7c:	40003800 	.word	0x40003800
 8002d80:	40003400 	.word	0x40003400
 8002d84:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002d88:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002d8c:	605a      	str	r2, [r3, #4]

      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002d8e:	687b      	ldr	r3, [r7, #4]
 8002d90:	681b      	ldr	r3, [r3, #0]
 8002d92:	685a      	ldr	r2, [r3, #4]
 8002d94:	687b      	ldr	r3, [r7, #4]
 8002d96:	681b      	ldr	r3, [r3, #0]
 8002d98:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002d9c:	605a      	str	r2, [r3, #4]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 8002d9e:	687b      	ldr	r3, [r7, #4]
 8002da0:	2201      	movs	r2, #1
 8002da2:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 8002da6:	687b      	ldr	r3, [r7, #4]
 8002da8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8002daa:	f043 0204 	orr.w	r2, r3, #4
 8002dae:	687b      	ldr	r3, [r7, #4]
 8002db0:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 8002db2:	6878      	ldr	r0, [r7, #4]
 8002db4:	f7ff fdc0 	bl	8002938 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002db8:	e000      	b.n	8002dbc <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 8002dba:	bf00      	nop
}
 8002dbc:	bf00      	nop
 8002dbe:	3720      	adds	r7, #32
 8002dc0:	46bd      	mov	sp, r7
 8002dc2:	bd80      	pop	{r7, pc}

08002dc4 <HAL_I2SEx_TxRxCpltCallback>:
  * @brief  Tx and Rx Transfer completed callback
  * @param  hi2s I2S handle
  * @retval None
  */
__weak void HAL_I2SEx_TxRxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8002dc4:	b480      	push	{r7}
 8002dc6:	b083      	sub	sp, #12
 8002dc8:	af00      	add	r7, sp, #0
 8002dca:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2SEx_TxRxCpltCallback could be implemented in the user file
   */
}
 8002dcc:	bf00      	nop
 8002dce:	370c      	adds	r7, #12
 8002dd0:	46bd      	mov	sp, r7
 8002dd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002dd6:	4770      	bx	lr

08002dd8 <I2SEx_TxISR_I2S>:
  * @brief  I2S Full-Duplex IT handler transmit function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_TxISR_I2S(I2S_HandleTypeDef *hi2s)
{
 8002dd8:	b580      	push	{r7, lr}
 8002dda:	b082      	sub	sp, #8
 8002ddc:	af00      	add	r7, sp, #0
 8002dde:	6078      	str	r0, [r7, #4]
  /* Write Data on DR register */
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr++);
 8002de0:	687b      	ldr	r3, [r7, #4]
 8002de2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002de4:	1c99      	adds	r1, r3, #2
 8002de6:	687a      	ldr	r2, [r7, #4]
 8002de8:	6251      	str	r1, [r2, #36]	@ 0x24
 8002dea:	881a      	ldrh	r2, [r3, #0]
 8002dec:	687b      	ldr	r3, [r7, #4]
 8002dee:	681b      	ldr	r3, [r3, #0]
 8002df0:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 8002df2:	687b      	ldr	r3, [r7, #4]
 8002df4:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002df6:	b29b      	uxth	r3, r3
 8002df8:	3b01      	subs	r3, #1
 8002dfa:	b29a      	uxth	r2, r3
 8002dfc:	687b      	ldr	r3, [r7, #4]
 8002dfe:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 8002e00:	687b      	ldr	r3, [r7, #4]
 8002e02:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002e04:	b29b      	uxth	r3, r3
 8002e06:	2b00      	cmp	r3, #0
 8002e08:	d113      	bne.n	8002e32 <I2SEx_TxISR_I2S+0x5a>
  {
    /* Disable TXE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002e0a:	687b      	ldr	r3, [r7, #4]
 8002e0c:	681b      	ldr	r3, [r3, #0]
 8002e0e:	685a      	ldr	r2, [r3, #4]
 8002e10:	687b      	ldr	r3, [r7, #4]
 8002e12:	681b      	ldr	r3, [r3, #0]
 8002e14:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002e18:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 8002e1a:	687b      	ldr	r3, [r7, #4]
 8002e1c:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002e1e:	b29b      	uxth	r3, r3
 8002e20:	2b00      	cmp	r3, #0
 8002e22:	d106      	bne.n	8002e32 <I2SEx_TxISR_I2S+0x5a>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8002e24:	687b      	ldr	r3, [r7, #4]
 8002e26:	2201      	movs	r2, #1
 8002e28:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8002e2c:	6878      	ldr	r0, [r7, #4]
 8002e2e:	f7ff ffc9 	bl	8002dc4 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002e32:	bf00      	nop
 8002e34:	3708      	adds	r7, #8
 8002e36:	46bd      	mov	sp, r7
 8002e38:	bd80      	pop	{r7, pc}
	...

08002e3c <I2SEx_TxISR_I2SExt>:
  * @brief  I2SExt Full-Duplex IT handler transmit function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_TxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
 8002e3c:	b580      	push	{r7, lr}
 8002e3e:	b082      	sub	sp, #8
 8002e40:	af00      	add	r7, sp, #0
 8002e42:	6078      	str	r0, [r7, #4]
  /* Write Data on DR register */
  I2SxEXT(hi2s->Instance)->DR = (*hi2s->pTxBuffPtr++);
 8002e44:	687b      	ldr	r3, [r7, #4]
 8002e46:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002e48:	1c99      	adds	r1, r3, #2
 8002e4a:	687a      	ldr	r2, [r7, #4]
 8002e4c:	6251      	str	r1, [r2, #36]	@ 0x24
 8002e4e:	8819      	ldrh	r1, [r3, #0]
 8002e50:	687b      	ldr	r3, [r7, #4]
 8002e52:	681b      	ldr	r3, [r3, #0]
 8002e54:	4a1d      	ldr	r2, [pc, #116]	@ (8002ecc <I2SEx_TxISR_I2SExt+0x90>)
 8002e56:	4293      	cmp	r3, r2
 8002e58:	d101      	bne.n	8002e5e <I2SEx_TxISR_I2SExt+0x22>
 8002e5a:	4b1d      	ldr	r3, [pc, #116]	@ (8002ed0 <I2SEx_TxISR_I2SExt+0x94>)
 8002e5c:	e001      	b.n	8002e62 <I2SEx_TxISR_I2SExt+0x26>
 8002e5e:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002e62:	460a      	mov	r2, r1
 8002e64:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 8002e66:	687b      	ldr	r3, [r7, #4]
 8002e68:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002e6a:	b29b      	uxth	r3, r3
 8002e6c:	3b01      	subs	r3, #1
 8002e6e:	b29a      	uxth	r2, r3
 8002e70:	687b      	ldr	r3, [r7, #4]
 8002e72:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 8002e74:	687b      	ldr	r3, [r7, #4]
 8002e76:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002e78:	b29b      	uxth	r3, r3
 8002e7a:	2b00      	cmp	r3, #0
 8002e7c:	d121      	bne.n	8002ec2 <I2SEx_TxISR_I2SExt+0x86>
  {
    /* Disable I2Sext TXE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8002e7e:	687b      	ldr	r3, [r7, #4]
 8002e80:	681b      	ldr	r3, [r3, #0]
 8002e82:	4a12      	ldr	r2, [pc, #72]	@ (8002ecc <I2SEx_TxISR_I2SExt+0x90>)
 8002e84:	4293      	cmp	r3, r2
 8002e86:	d101      	bne.n	8002e8c <I2SEx_TxISR_I2SExt+0x50>
 8002e88:	4b11      	ldr	r3, [pc, #68]	@ (8002ed0 <I2SEx_TxISR_I2SExt+0x94>)
 8002e8a:	e001      	b.n	8002e90 <I2SEx_TxISR_I2SExt+0x54>
 8002e8c:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002e90:	685a      	ldr	r2, [r3, #4]
 8002e92:	687b      	ldr	r3, [r7, #4]
 8002e94:	681b      	ldr	r3, [r3, #0]
 8002e96:	490d      	ldr	r1, [pc, #52]	@ (8002ecc <I2SEx_TxISR_I2SExt+0x90>)
 8002e98:	428b      	cmp	r3, r1
 8002e9a:	d101      	bne.n	8002ea0 <I2SEx_TxISR_I2SExt+0x64>
 8002e9c:	4b0c      	ldr	r3, [pc, #48]	@ (8002ed0 <I2SEx_TxISR_I2SExt+0x94>)
 8002e9e:	e001      	b.n	8002ea4 <I2SEx_TxISR_I2SExt+0x68>
 8002ea0:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002ea4:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8002ea8:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 8002eaa:	687b      	ldr	r3, [r7, #4]
 8002eac:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002eae:	b29b      	uxth	r3, r3
 8002eb0:	2b00      	cmp	r3, #0
 8002eb2:	d106      	bne.n	8002ec2 <I2SEx_TxISR_I2SExt+0x86>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8002eb4:	687b      	ldr	r3, [r7, #4]
 8002eb6:	2201      	movs	r2, #1
 8002eb8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8002ebc:	6878      	ldr	r0, [r7, #4]
 8002ebe:	f7ff ff81 	bl	8002dc4 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002ec2:	bf00      	nop
 8002ec4:	3708      	adds	r7, #8
 8002ec6:	46bd      	mov	sp, r7
 8002ec8:	bd80      	pop	{r7, pc}
 8002eca:	bf00      	nop
 8002ecc:	40003800 	.word	0x40003800
 8002ed0:	40003400 	.word	0x40003400

08002ed4 <I2SEx_RxISR_I2S>:
  * @brief  I2S Full-Duplex IT handler receive function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_RxISR_I2S(I2S_HandleTypeDef *hi2s)
{
 8002ed4:	b580      	push	{r7, lr}
 8002ed6:	b082      	sub	sp, #8
 8002ed8:	af00      	add	r7, sp, #0
 8002eda:	6078      	str	r0, [r7, #4]
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = hi2s->Instance->DR;
 8002edc:	687b      	ldr	r3, [r7, #4]
 8002ede:	681b      	ldr	r3, [r3, #0]
 8002ee0:	68d8      	ldr	r0, [r3, #12]
 8002ee2:	687b      	ldr	r3, [r7, #4]
 8002ee4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002ee6:	1c99      	adds	r1, r3, #2
 8002ee8:	687a      	ldr	r2, [r7, #4]
 8002eea:	62d1      	str	r1, [r2, #44]	@ 0x2c
 8002eec:	b282      	uxth	r2, r0
 8002eee:	801a      	strh	r2, [r3, #0]
  hi2s->RxXferCount--;
 8002ef0:	687b      	ldr	r3, [r7, #4]
 8002ef2:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002ef4:	b29b      	uxth	r3, r3
 8002ef6:	3b01      	subs	r3, #1
 8002ef8:	b29a      	uxth	r2, r3
 8002efa:	687b      	ldr	r3, [r7, #4]
 8002efc:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 8002efe:	687b      	ldr	r3, [r7, #4]
 8002f00:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002f02:	b29b      	uxth	r3, r3
 8002f04:	2b00      	cmp	r3, #0
 8002f06:	d113      	bne.n	8002f30 <I2SEx_RxISR_I2S+0x5c>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002f08:	687b      	ldr	r3, [r7, #4]
 8002f0a:	681b      	ldr	r3, [r3, #0]
 8002f0c:	685a      	ldr	r2, [r3, #4]
 8002f0e:	687b      	ldr	r3, [r7, #4]
 8002f10:	681b      	ldr	r3, [r3, #0]
 8002f12:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002f16:	605a      	str	r2, [r3, #4]

    if (hi2s->TxXferCount == 0U)
 8002f18:	687b      	ldr	r3, [r7, #4]
 8002f1a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002f1c:	b29b      	uxth	r3, r3
 8002f1e:	2b00      	cmp	r3, #0
 8002f20:	d106      	bne.n	8002f30 <I2SEx_RxISR_I2S+0x5c>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8002f22:	687b      	ldr	r3, [r7, #4]
 8002f24:	2201      	movs	r2, #1
 8002f26:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8002f2a:	6878      	ldr	r0, [r7, #4]
 8002f2c:	f7ff ff4a 	bl	8002dc4 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002f30:	bf00      	nop
 8002f32:	3708      	adds	r7, #8
 8002f34:	46bd      	mov	sp, r7
 8002f36:	bd80      	pop	{r7, pc}

08002f38 <I2SEx_RxISR_I2SExt>:
  * @brief  I2SExt Full-Duplex IT handler receive function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_RxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
 8002f38:	b580      	push	{r7, lr}
 8002f3a:	b082      	sub	sp, #8
 8002f3c:	af00      	add	r7, sp, #0
 8002f3e:	6078      	str	r0, [r7, #4]
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = I2SxEXT(hi2s->Instance)->DR;
 8002f40:	687b      	ldr	r3, [r7, #4]
 8002f42:	681b      	ldr	r3, [r3, #0]
 8002f44:	4a20      	ldr	r2, [pc, #128]	@ (8002fc8 <I2SEx_RxISR_I2SExt+0x90>)
 8002f46:	4293      	cmp	r3, r2
 8002f48:	d101      	bne.n	8002f4e <I2SEx_RxISR_I2SExt+0x16>
 8002f4a:	4b20      	ldr	r3, [pc, #128]	@ (8002fcc <I2SEx_RxISR_I2SExt+0x94>)
 8002f4c:	e001      	b.n	8002f52 <I2SEx_RxISR_I2SExt+0x1a>
 8002f4e:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002f52:	68d8      	ldr	r0, [r3, #12]
 8002f54:	687b      	ldr	r3, [r7, #4]
 8002f56:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002f58:	1c99      	adds	r1, r3, #2
 8002f5a:	687a      	ldr	r2, [r7, #4]
 8002f5c:	62d1      	str	r1, [r2, #44]	@ 0x2c
 8002f5e:	b282      	uxth	r2, r0
 8002f60:	801a      	strh	r2, [r3, #0]
  hi2s->RxXferCount--;
 8002f62:	687b      	ldr	r3, [r7, #4]
 8002f64:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002f66:	b29b      	uxth	r3, r3
 8002f68:	3b01      	subs	r3, #1
 8002f6a:	b29a      	uxth	r2, r3
 8002f6c:	687b      	ldr	r3, [r7, #4]
 8002f6e:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 8002f70:	687b      	ldr	r3, [r7, #4]
 8002f72:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 8002f74:	b29b      	uxth	r3, r3
 8002f76:	2b00      	cmp	r3, #0
 8002f78:	d121      	bne.n	8002fbe <I2SEx_RxISR_I2SExt+0x86>
  {
    /* Disable I2Sext RXNE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8002f7a:	687b      	ldr	r3, [r7, #4]
 8002f7c:	681b      	ldr	r3, [r3, #0]
 8002f7e:	4a12      	ldr	r2, [pc, #72]	@ (8002fc8 <I2SEx_RxISR_I2SExt+0x90>)
 8002f80:	4293      	cmp	r3, r2
 8002f82:	d101      	bne.n	8002f88 <I2SEx_RxISR_I2SExt+0x50>
 8002f84:	4b11      	ldr	r3, [pc, #68]	@ (8002fcc <I2SEx_RxISR_I2SExt+0x94>)
 8002f86:	e001      	b.n	8002f8c <I2SEx_RxISR_I2SExt+0x54>
 8002f88:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002f8c:	685a      	ldr	r2, [r3, #4]
 8002f8e:	687b      	ldr	r3, [r7, #4]
 8002f90:	681b      	ldr	r3, [r3, #0]
 8002f92:	490d      	ldr	r1, [pc, #52]	@ (8002fc8 <I2SEx_RxISR_I2SExt+0x90>)
 8002f94:	428b      	cmp	r3, r1
 8002f96:	d101      	bne.n	8002f9c <I2SEx_RxISR_I2SExt+0x64>
 8002f98:	4b0c      	ldr	r3, [pc, #48]	@ (8002fcc <I2SEx_RxISR_I2SExt+0x94>)
 8002f9a:	e001      	b.n	8002fa0 <I2SEx_RxISR_I2SExt+0x68>
 8002f9c:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 8002fa0:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002fa4:	605a      	str	r2, [r3, #4]

    if (hi2s->TxXferCount == 0U)
 8002fa6:	687b      	ldr	r3, [r7, #4]
 8002fa8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8002faa:	b29b      	uxth	r3, r3
 8002fac:	2b00      	cmp	r3, #0
 8002fae:	d106      	bne.n	8002fbe <I2SEx_RxISR_I2SExt+0x86>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8002fb0:	687b      	ldr	r3, [r7, #4]
 8002fb2:	2201      	movs	r2, #1
 8002fb4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8002fb8:	6878      	ldr	r0, [r7, #4]
 8002fba:	f7ff ff03 	bl	8002dc4 <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8002fbe:	bf00      	nop
 8002fc0:	3708      	adds	r7, #8
 8002fc2:	46bd      	mov	sp, r7
 8002fc4:	bd80      	pop	{r7, pc}
 8002fc6:	bf00      	nop
 8002fc8:	40003800 	.word	0x40003800
 8002fcc:	40003400 	.word	0x40003400

08002fd0 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 8002fd0:	b580      	push	{r7, lr}
 8002fd2:	b086      	sub	sp, #24
 8002fd4:	af02      	add	r7, sp, #8
 8002fd6:	6078      	str	r0, [r7, #4]
  const USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 8002fd8:	687b      	ldr	r3, [r7, #4]
 8002fda:	2b00      	cmp	r3, #0
 8002fdc:	d101      	bne.n	8002fe2 <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 8002fde:	2301      	movs	r3, #1
 8002fe0:	e101      	b.n	80031e6 <HAL_PCD_Init+0x216>

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
 8002fe2:	687b      	ldr	r3, [r7, #4]
 8002fe4:	681b      	ldr	r3, [r3, #0]
 8002fe6:	60bb      	str	r3, [r7, #8]
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
 8002fe8:	687b      	ldr	r3, [r7, #4]
 8002fea:	f893 3495 	ldrb.w	r3, [r3, #1173]	@ 0x495
 8002fee:	b2db      	uxtb	r3, r3
 8002ff0:	2b00      	cmp	r3, #0
 8002ff2:	d106      	bne.n	8003002 <HAL_PCD_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 8002ff4:	687b      	ldr	r3, [r7, #4]
 8002ff6:	2200      	movs	r2, #0
 8002ff8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 8002ffc:	6878      	ldr	r0, [r7, #4]
 8002ffe:	f024 fdf9 	bl	8027bf4 <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 8003002:	687b      	ldr	r3, [r7, #4]
 8003004:	2203      	movs	r2, #3
 8003006:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

#if defined (USB_OTG_FS)
  /* Disable DMA mode for FS instance */
  if (USBx == USB_OTG_FS)
 800300a:	68bb      	ldr	r3, [r7, #8]
 800300c:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8003010:	d102      	bne.n	8003018 <HAL_PCD_Init+0x48>
  {
    hpcd->Init.dma_enable = 0U;
 8003012:	687b      	ldr	r3, [r7, #4]
 8003014:	2200      	movs	r2, #0
 8003016:	719a      	strb	r2, [r3, #6]
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 8003018:	687b      	ldr	r3, [r7, #4]
 800301a:	681b      	ldr	r3, [r3, #0]
 800301c:	4618      	mov	r0, r3
 800301e:	f002 fa3a 	bl	8005496 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8003022:	687b      	ldr	r3, [r7, #4]
 8003024:	6818      	ldr	r0, [r3, #0]
 8003026:	687b      	ldr	r3, [r7, #4]
 8003028:	7c1a      	ldrb	r2, [r3, #16]
 800302a:	f88d 2000 	strb.w	r2, [sp]
 800302e:	3304      	adds	r3, #4
 8003030:	cb0e      	ldmia	r3, {r1, r2, r3}
 8003032:	f002 f918 	bl	8005266 <USB_CoreInit>
 8003036:	4603      	mov	r3, r0
 8003038:	2b00      	cmp	r3, #0
 800303a:	d005      	beq.n	8003048 <HAL_PCD_Init+0x78>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 800303c:	687b      	ldr	r3, [r7, #4]
 800303e:	2202      	movs	r2, #2
 8003040:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 8003044:	2301      	movs	r3, #1
 8003046:	e0ce      	b.n	80031e6 <HAL_PCD_Init+0x216>
  }

  /* Force Device Mode */
  if (USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE) != HAL_OK)
 8003048:	687b      	ldr	r3, [r7, #4]
 800304a:	681b      	ldr	r3, [r3, #0]
 800304c:	2100      	movs	r1, #0
 800304e:	4618      	mov	r0, r3
 8003050:	f002 fa32 	bl	80054b8 <USB_SetCurrentMode>
 8003054:	4603      	mov	r3, r0
 8003056:	2b00      	cmp	r3, #0
 8003058:	d005      	beq.n	8003066 <HAL_PCD_Init+0x96>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 800305a:	687b      	ldr	r3, [r7, #4]
 800305c:	2202      	movs	r2, #2
 800305e:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 8003062:	2301      	movs	r3, #1
 8003064:	e0bf      	b.n	80031e6 <HAL_PCD_Init+0x216>
  }

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003066:	2300      	movs	r3, #0
 8003068:	73fb      	strb	r3, [r7, #15]
 800306a:	e04a      	b.n	8003102 <HAL_PCD_Init+0x132>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 800306c:	7bfa      	ldrb	r2, [r7, #15]
 800306e:	6879      	ldr	r1, [r7, #4]
 8003070:	4613      	mov	r3, r2
 8003072:	00db      	lsls	r3, r3, #3
 8003074:	4413      	add	r3, r2
 8003076:	009b      	lsls	r3, r3, #2
 8003078:	440b      	add	r3, r1
 800307a:	3315      	adds	r3, #21
 800307c:	2201      	movs	r2, #1
 800307e:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 8003080:	7bfa      	ldrb	r2, [r7, #15]
 8003082:	6879      	ldr	r1, [r7, #4]
 8003084:	4613      	mov	r3, r2
 8003086:	00db      	lsls	r3, r3, #3
 8003088:	4413      	add	r3, r2
 800308a:	009b      	lsls	r3, r3, #2
 800308c:	440b      	add	r3, r1
 800308e:	3314      	adds	r3, #20
 8003090:	7bfa      	ldrb	r2, [r7, #15]
 8003092:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
 8003094:	7bfa      	ldrb	r2, [r7, #15]
 8003096:	7bfb      	ldrb	r3, [r7, #15]
 8003098:	b298      	uxth	r0, r3
 800309a:	6879      	ldr	r1, [r7, #4]
 800309c:	4613      	mov	r3, r2
 800309e:	00db      	lsls	r3, r3, #3
 80030a0:	4413      	add	r3, r2
 80030a2:	009b      	lsls	r3, r3, #2
 80030a4:	440b      	add	r3, r1
 80030a6:	332e      	adds	r3, #46	@ 0x2e
 80030a8:	4602      	mov	r2, r0
 80030aa:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80030ac:	7bfa      	ldrb	r2, [r7, #15]
 80030ae:	6879      	ldr	r1, [r7, #4]
 80030b0:	4613      	mov	r3, r2
 80030b2:	00db      	lsls	r3, r3, #3
 80030b4:	4413      	add	r3, r2
 80030b6:	009b      	lsls	r3, r3, #2
 80030b8:	440b      	add	r3, r1
 80030ba:	3318      	adds	r3, #24
 80030bc:	2200      	movs	r2, #0
 80030be:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 80030c0:	7bfa      	ldrb	r2, [r7, #15]
 80030c2:	6879      	ldr	r1, [r7, #4]
 80030c4:	4613      	mov	r3, r2
 80030c6:	00db      	lsls	r3, r3, #3
 80030c8:	4413      	add	r3, r2
 80030ca:	009b      	lsls	r3, r3, #2
 80030cc:	440b      	add	r3, r1
 80030ce:	331c      	adds	r3, #28
 80030d0:	2200      	movs	r2, #0
 80030d2:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 80030d4:	7bfa      	ldrb	r2, [r7, #15]
 80030d6:	6879      	ldr	r1, [r7, #4]
 80030d8:	4613      	mov	r3, r2
 80030da:	00db      	lsls	r3, r3, #3
 80030dc:	4413      	add	r3, r2
 80030de:	009b      	lsls	r3, r3, #2
 80030e0:	440b      	add	r3, r1
 80030e2:	3320      	adds	r3, #32
 80030e4:	2200      	movs	r2, #0
 80030e6:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 80030e8:	7bfa      	ldrb	r2, [r7, #15]
 80030ea:	6879      	ldr	r1, [r7, #4]
 80030ec:	4613      	mov	r3, r2
 80030ee:	00db      	lsls	r3, r3, #3
 80030f0:	4413      	add	r3, r2
 80030f2:	009b      	lsls	r3, r3, #2
 80030f4:	440b      	add	r3, r1
 80030f6:	3324      	adds	r3, #36	@ 0x24
 80030f8:	2200      	movs	r2, #0
 80030fa:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80030fc:	7bfb      	ldrb	r3, [r7, #15]
 80030fe:	3301      	adds	r3, #1
 8003100:	73fb      	strb	r3, [r7, #15]
 8003102:	687b      	ldr	r3, [r7, #4]
 8003104:	791b      	ldrb	r3, [r3, #4]
 8003106:	7bfa      	ldrb	r2, [r7, #15]
 8003108:	429a      	cmp	r2, r3
 800310a:	d3af      	bcc.n	800306c <HAL_PCD_Init+0x9c>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800310c:	2300      	movs	r3, #0
 800310e:	73fb      	strb	r3, [r7, #15]
 8003110:	e044      	b.n	800319c <HAL_PCD_Init+0x1cc>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 8003112:	7bfa      	ldrb	r2, [r7, #15]
 8003114:	6879      	ldr	r1, [r7, #4]
 8003116:	4613      	mov	r3, r2
 8003118:	00db      	lsls	r3, r3, #3
 800311a:	4413      	add	r3, r2
 800311c:	009b      	lsls	r3, r3, #2
 800311e:	440b      	add	r3, r1
 8003120:	f203 2355 	addw	r3, r3, #597	@ 0x255
 8003124:	2200      	movs	r2, #0
 8003126:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 8003128:	7bfa      	ldrb	r2, [r7, #15]
 800312a:	6879      	ldr	r1, [r7, #4]
 800312c:	4613      	mov	r3, r2
 800312e:	00db      	lsls	r3, r3, #3
 8003130:	4413      	add	r3, r2
 8003132:	009b      	lsls	r3, r3, #2
 8003134:	440b      	add	r3, r1
 8003136:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 800313a:	7bfa      	ldrb	r2, [r7, #15]
 800313c:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 800313e:	7bfa      	ldrb	r2, [r7, #15]
 8003140:	6879      	ldr	r1, [r7, #4]
 8003142:	4613      	mov	r3, r2
 8003144:	00db      	lsls	r3, r3, #3
 8003146:	4413      	add	r3, r2
 8003148:	009b      	lsls	r3, r3, #2
 800314a:	440b      	add	r3, r1
 800314c:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 8003150:	2200      	movs	r2, #0
 8003152:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 8003154:	7bfa      	ldrb	r2, [r7, #15]
 8003156:	6879      	ldr	r1, [r7, #4]
 8003158:	4613      	mov	r3, r2
 800315a:	00db      	lsls	r3, r3, #3
 800315c:	4413      	add	r3, r2
 800315e:	009b      	lsls	r3, r3, #2
 8003160:	440b      	add	r3, r1
 8003162:	f503 7317 	add.w	r3, r3, #604	@ 0x25c
 8003166:	2200      	movs	r2, #0
 8003168:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800316a:	7bfa      	ldrb	r2, [r7, #15]
 800316c:	6879      	ldr	r1, [r7, #4]
 800316e:	4613      	mov	r3, r2
 8003170:	00db      	lsls	r3, r3, #3
 8003172:	4413      	add	r3, r2
 8003174:	009b      	lsls	r3, r3, #2
 8003176:	440b      	add	r3, r1
 8003178:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800317c:	2200      	movs	r2, #0
 800317e:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 8003180:	7bfa      	ldrb	r2, [r7, #15]
 8003182:	6879      	ldr	r1, [r7, #4]
 8003184:	4613      	mov	r3, r2
 8003186:	00db      	lsls	r3, r3, #3
 8003188:	4413      	add	r3, r2
 800318a:	009b      	lsls	r3, r3, #2
 800318c:	440b      	add	r3, r1
 800318e:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 8003192:	2200      	movs	r2, #0
 8003194:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003196:	7bfb      	ldrb	r3, [r7, #15]
 8003198:	3301      	adds	r3, #1
 800319a:	73fb      	strb	r3, [r7, #15]
 800319c:	687b      	ldr	r3, [r7, #4]
 800319e:	791b      	ldrb	r3, [r3, #4]
 80031a0:	7bfa      	ldrb	r2, [r7, #15]
 80031a2:	429a      	cmp	r2, r3
 80031a4:	d3b5      	bcc.n	8003112 <HAL_PCD_Init+0x142>
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 80031a6:	687b      	ldr	r3, [r7, #4]
 80031a8:	6818      	ldr	r0, [r3, #0]
 80031aa:	687b      	ldr	r3, [r7, #4]
 80031ac:	7c1a      	ldrb	r2, [r3, #16]
 80031ae:	f88d 2000 	strb.w	r2, [sp]
 80031b2:	3304      	adds	r3, #4
 80031b4:	cb0e      	ldmia	r3, {r1, r2, r3}
 80031b6:	f002 f9cb 	bl	8005550 <USB_DevInit>
 80031ba:	4603      	mov	r3, r0
 80031bc:	2b00      	cmp	r3, #0
 80031be:	d005      	beq.n	80031cc <HAL_PCD_Init+0x1fc>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 80031c0:	687b      	ldr	r3, [r7, #4]
 80031c2:	2202      	movs	r2, #2
 80031c4:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 80031c8:	2301      	movs	r3, #1
 80031ca:	e00c      	b.n	80031e6 <HAL_PCD_Init+0x216>
  }

  hpcd->USB_Address = 0U;
 80031cc:	687b      	ldr	r3, [r7, #4]
 80031ce:	2200      	movs	r2, #0
 80031d0:	745a      	strb	r2, [r3, #17]
  hpcd->State = HAL_PCD_STATE_READY;
 80031d2:	687b      	ldr	r3, [r7, #4]
 80031d4:	2201      	movs	r2, #1
 80031d6:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    (void)HAL_PCDEx_ActivateLPM(hpcd);
  }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */
  (void)USB_DevDisconnect(hpcd->Instance);
 80031da:	687b      	ldr	r3, [r7, #4]
 80031dc:	681b      	ldr	r3, [r3, #0]
 80031de:	4618      	mov	r0, r3
 80031e0:	f003 fa15 	bl	800660e <USB_DevDisconnect>

  return HAL_OK;
 80031e4:	2300      	movs	r3, #0
}
 80031e6:	4618      	mov	r0, r3
 80031e8:	3710      	adds	r7, #16
 80031ea:	46bd      	mov	sp, r7
 80031ec:	bd80      	pop	{r7, pc}

080031ee <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 80031ee:	b580      	push	{r7, lr}
 80031f0:	b084      	sub	sp, #16
 80031f2:	af00      	add	r7, sp, #0
 80031f4:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80031f6:	687b      	ldr	r3, [r7, #4]
 80031f8:	681b      	ldr	r3, [r3, #0]
 80031fa:	60fb      	str	r3, [r7, #12]

  __HAL_LOCK(hpcd);
 80031fc:	687b      	ldr	r3, [r7, #4]
 80031fe:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003202:	2b01      	cmp	r3, #1
 8003204:	d101      	bne.n	800320a <HAL_PCD_Start+0x1c>
 8003206:	2302      	movs	r3, #2
 8003208:	e022      	b.n	8003250 <HAL_PCD_Start+0x62>
 800320a:	687b      	ldr	r3, [r7, #4]
 800320c:	2201      	movs	r2, #1
 800320e:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 8003212:	68fb      	ldr	r3, [r7, #12]
 8003214:	68db      	ldr	r3, [r3, #12]
 8003216:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800321a:	2b00      	cmp	r3, #0
 800321c:	d009      	beq.n	8003232 <HAL_PCD_Start+0x44>
      (hpcd->Init.battery_charging_enable == 1U))
 800321e:	687b      	ldr	r3, [r7, #4]
 8003220:	7b5b      	ldrb	r3, [r3, #13]
  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 8003222:	2b01      	cmp	r3, #1
 8003224:	d105      	bne.n	8003232 <HAL_PCD_Start+0x44>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8003226:	68fb      	ldr	r3, [r7, #12]
 8003228:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800322a:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 800322e:	68fb      	ldr	r3, [r7, #12]
 8003230:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  __HAL_PCD_ENABLE(hpcd);
 8003232:	687b      	ldr	r3, [r7, #4]
 8003234:	681b      	ldr	r3, [r3, #0]
 8003236:	4618      	mov	r0, r3
 8003238:	f002 f91c 	bl	8005474 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 800323c:	687b      	ldr	r3, [r7, #4]
 800323e:	681b      	ldr	r3, [r3, #0]
 8003240:	4618      	mov	r0, r3
 8003242:	f003 f9c3 	bl	80065cc <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 8003246:	687b      	ldr	r3, [r7, #4]
 8003248:	2200      	movs	r2, #0
 800324a:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 800324e:	2300      	movs	r3, #0
}
 8003250:	4618      	mov	r0, r3
 8003252:	3710      	adds	r7, #16
 8003254:	46bd      	mov	sp, r7
 8003256:	bd80      	pop	{r7, pc}

08003258 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8003258:	b590      	push	{r4, r7, lr}
 800325a:	b08d      	sub	sp, #52	@ 0x34
 800325c:	af00      	add	r7, sp, #0
 800325e:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8003260:	687b      	ldr	r3, [r7, #4]
 8003262:	681b      	ldr	r3, [r3, #0]
 8003264:	623b      	str	r3, [r7, #32]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8003266:	6a3b      	ldr	r3, [r7, #32]
 8003268:	61fb      	str	r3, [r7, #28]
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 800326a:	687b      	ldr	r3, [r7, #4]
 800326c:	681b      	ldr	r3, [r3, #0]
 800326e:	4618      	mov	r0, r3
 8003270:	f003 fa81 	bl	8006776 <USB_GetMode>
 8003274:	4603      	mov	r3, r0
 8003276:	2b00      	cmp	r3, #0
 8003278:	f040 848c 	bne.w	8003b94 <HAL_PCD_IRQHandler+0x93c>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 800327c:	687b      	ldr	r3, [r7, #4]
 800327e:	681b      	ldr	r3, [r3, #0]
 8003280:	4618      	mov	r0, r3
 8003282:	f003 f9e5 	bl	8006650 <USB_ReadInterrupts>
 8003286:	4603      	mov	r3, r0
 8003288:	2b00      	cmp	r3, #0
 800328a:	f000 8482 	beq.w	8003b92 <HAL_PCD_IRQHandler+0x93a>
    {
      return;
    }

    /* store current frame number */
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 800328e:	69fb      	ldr	r3, [r7, #28]
 8003290:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003294:	689b      	ldr	r3, [r3, #8]
 8003296:	0a1b      	lsrs	r3, r3, #8
 8003298:	f3c3 020d 	ubfx	r2, r3, #0, #14
 800329c:	687b      	ldr	r3, [r7, #4]
 800329e:	f8c3 24d4 	str.w	r2, [r3, #1236]	@ 0x4d4

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 80032a2:	687b      	ldr	r3, [r7, #4]
 80032a4:	681b      	ldr	r3, [r3, #0]
 80032a6:	4618      	mov	r0, r3
 80032a8:	f003 f9d2 	bl	8006650 <USB_ReadInterrupts>
 80032ac:	4603      	mov	r3, r0
 80032ae:	f003 0302 	and.w	r3, r3, #2
 80032b2:	2b02      	cmp	r3, #2
 80032b4:	d107      	bne.n	80032c6 <HAL_PCD_IRQHandler+0x6e>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 80032b6:	687b      	ldr	r3, [r7, #4]
 80032b8:	681b      	ldr	r3, [r3, #0]
 80032ba:	695a      	ldr	r2, [r3, #20]
 80032bc:	687b      	ldr	r3, [r7, #4]
 80032be:	681b      	ldr	r3, [r3, #0]
 80032c0:	f002 0202 	and.w	r2, r2, #2
 80032c4:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 80032c6:	687b      	ldr	r3, [r7, #4]
 80032c8:	681b      	ldr	r3, [r3, #0]
 80032ca:	4618      	mov	r0, r3
 80032cc:	f003 f9c0 	bl	8006650 <USB_ReadInterrupts>
 80032d0:	4603      	mov	r3, r0
 80032d2:	f003 0310 	and.w	r3, r3, #16
 80032d6:	2b10      	cmp	r3, #16
 80032d8:	d161      	bne.n	800339e <HAL_PCD_IRQHandler+0x146>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80032da:	687b      	ldr	r3, [r7, #4]
 80032dc:	681b      	ldr	r3, [r3, #0]
 80032de:	699a      	ldr	r2, [r3, #24]
 80032e0:	687b      	ldr	r3, [r7, #4]
 80032e2:	681b      	ldr	r3, [r3, #0]
 80032e4:	f022 0210 	bic.w	r2, r2, #16
 80032e8:	619a      	str	r2, [r3, #24]

      RegVal = USBx->GRXSTSP;
 80032ea:	6a3b      	ldr	r3, [r7, #32]
 80032ec:	6a1b      	ldr	r3, [r3, #32]
 80032ee:	61bb      	str	r3, [r7, #24]

      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 80032f0:	69bb      	ldr	r3, [r7, #24]
 80032f2:	f003 020f 	and.w	r2, r3, #15
 80032f6:	4613      	mov	r3, r2
 80032f8:	00db      	lsls	r3, r3, #3
 80032fa:	4413      	add	r3, r2
 80032fc:	009b      	lsls	r3, r3, #2
 80032fe:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003302:	687a      	ldr	r2, [r7, #4]
 8003304:	4413      	add	r3, r2
 8003306:	3304      	adds	r3, #4
 8003308:	617b      	str	r3, [r7, #20]

      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800330a:	69bb      	ldr	r3, [r7, #24]
 800330c:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
 8003310:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8003314:	d124      	bne.n	8003360 <HAL_PCD_IRQHandler+0x108>
      {
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 8003316:	69ba      	ldr	r2, [r7, #24]
 8003318:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
 800331c:	4013      	ands	r3, r2
 800331e:	2b00      	cmp	r3, #0
 8003320:	d035      	beq.n	800338e <HAL_PCD_IRQHandler+0x136>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8003322:	697b      	ldr	r3, [r7, #20]
 8003324:	68d9      	ldr	r1, [r3, #12]
                               (uint16_t)((RegVal & USB_OTG_GRXSTSP_BCNT) >> 4));
 8003326:	69bb      	ldr	r3, [r7, #24]
 8003328:	091b      	lsrs	r3, r3, #4
 800332a:	b29b      	uxth	r3, r3
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 800332c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8003330:	b29b      	uxth	r3, r3
 8003332:	461a      	mov	r2, r3
 8003334:	6a38      	ldr	r0, [r7, #32]
 8003336:	f002 fff7 	bl	8006328 <USB_ReadPacket>

          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800333a:	697b      	ldr	r3, [r7, #20]
 800333c:	68da      	ldr	r2, [r3, #12]
 800333e:	69bb      	ldr	r3, [r7, #24]
 8003340:	091b      	lsrs	r3, r3, #4
 8003342:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8003346:	441a      	add	r2, r3
 8003348:	697b      	ldr	r3, [r7, #20]
 800334a:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800334c:	697b      	ldr	r3, [r7, #20]
 800334e:	695a      	ldr	r2, [r3, #20]
 8003350:	69bb      	ldr	r3, [r7, #24]
 8003352:	091b      	lsrs	r3, r3, #4
 8003354:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8003358:	441a      	add	r2, r3
 800335a:	697b      	ldr	r3, [r7, #20]
 800335c:	615a      	str	r2, [r3, #20]
 800335e:	e016      	b.n	800338e <HAL_PCD_IRQHandler+0x136>
        }
      }
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 8003360:	69bb      	ldr	r3, [r7, #24]
 8003362:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
 8003366:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 800336a:	d110      	bne.n	800338e <HAL_PCD_IRQHandler+0x136>
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 800336c:	687b      	ldr	r3, [r7, #4]
 800336e:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8003372:	2208      	movs	r2, #8
 8003374:	4619      	mov	r1, r3
 8003376:	6a38      	ldr	r0, [r7, #32]
 8003378:	f002 ffd6 	bl	8006328 <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800337c:	697b      	ldr	r3, [r7, #20]
 800337e:	695a      	ldr	r2, [r3, #20]
 8003380:	69bb      	ldr	r3, [r7, #24]
 8003382:	091b      	lsrs	r3, r3, #4
 8003384:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8003388:	441a      	add	r2, r3
 800338a:	697b      	ldr	r3, [r7, #20]
 800338c:	615a      	str	r2, [r3, #20]
      else
      {
        /* ... */
      }

      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800338e:	687b      	ldr	r3, [r7, #4]
 8003390:	681b      	ldr	r3, [r3, #0]
 8003392:	699a      	ldr	r2, [r3, #24]
 8003394:	687b      	ldr	r3, [r7, #4]
 8003396:	681b      	ldr	r3, [r3, #0]
 8003398:	f042 0210 	orr.w	r2, r2, #16
 800339c:	619a      	str	r2, [r3, #24]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 800339e:	687b      	ldr	r3, [r7, #4]
 80033a0:	681b      	ldr	r3, [r3, #0]
 80033a2:	4618      	mov	r0, r3
 80033a4:	f003 f954 	bl	8006650 <USB_ReadInterrupts>
 80033a8:	4603      	mov	r3, r0
 80033aa:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 80033ae:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 80033b2:	f040 80a7 	bne.w	8003504 <HAL_PCD_IRQHandler+0x2ac>
    {
      epnum = 0U;
 80033b6:	2300      	movs	r3, #0
 80033b8:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 80033ba:	687b      	ldr	r3, [r7, #4]
 80033bc:	681b      	ldr	r3, [r3, #0]
 80033be:	4618      	mov	r0, r3
 80033c0:	f003 f959 	bl	8006676 <USB_ReadDevAllOutEpInterrupt>
 80033c4:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (ep_intr != 0U)
 80033c6:	e099      	b.n	80034fc <HAL_PCD_IRQHandler+0x2a4>
      {
        if ((ep_intr & 0x1U) != 0U)
 80033c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80033ca:	f003 0301 	and.w	r3, r3, #1
 80033ce:	2b00      	cmp	r3, #0
 80033d0:	f000 808e 	beq.w	80034f0 <HAL_PCD_IRQHandler+0x298>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 80033d4:	687b      	ldr	r3, [r7, #4]
 80033d6:	681b      	ldr	r3, [r3, #0]
 80033d8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80033da:	b2d2      	uxtb	r2, r2
 80033dc:	4611      	mov	r1, r2
 80033de:	4618      	mov	r0, r3
 80033e0:	f003 f97d 	bl	80066de <USB_ReadDevOutEPInterrupt>
 80033e4:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 80033e6:	693b      	ldr	r3, [r7, #16]
 80033e8:	f003 0301 	and.w	r3, r3, #1
 80033ec:	2b00      	cmp	r3, #0
 80033ee:	d00c      	beq.n	800340a <HAL_PCD_IRQHandler+0x1b2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 80033f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80033f2:	015a      	lsls	r2, r3, #5
 80033f4:	69fb      	ldr	r3, [r7, #28]
 80033f6:	4413      	add	r3, r2
 80033f8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80033fc:	461a      	mov	r2, r3
 80033fe:	2301      	movs	r3, #1
 8003400:	6093      	str	r3, [r2, #8]
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
 8003402:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8003404:	6878      	ldr	r0, [r7, #4]
 8003406:	f000 fea3 	bl	8004150 <PCD_EP_OutXfrComplete_int>
          }

          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 800340a:	693b      	ldr	r3, [r7, #16]
 800340c:	f003 0308 	and.w	r3, r3, #8
 8003410:	2b00      	cmp	r3, #0
 8003412:	d00c      	beq.n	800342e <HAL_PCD_IRQHandler+0x1d6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8003414:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003416:	015a      	lsls	r2, r3, #5
 8003418:	69fb      	ldr	r3, [r7, #28]
 800341a:	4413      	add	r3, r2
 800341c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003420:	461a      	mov	r2, r3
 8003422:	2308      	movs	r3, #8
 8003424:	6093      	str	r3, [r2, #8]
            /* Class B setup phase done for previous decoded setup */
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
 8003426:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8003428:	6878      	ldr	r0, [r7, #4]
 800342a:	f000 ff79 	bl	8004320 <PCD_EP_OutSetupPacket_int>
          }

          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 800342e:	693b      	ldr	r3, [r7, #16]
 8003430:	f003 0310 	and.w	r3, r3, #16
 8003434:	2b00      	cmp	r3, #0
 8003436:	d008      	beq.n	800344a <HAL_PCD_IRQHandler+0x1f2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8003438:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800343a:	015a      	lsls	r2, r3, #5
 800343c:	69fb      	ldr	r3, [r7, #28]
 800343e:	4413      	add	r3, r2
 8003440:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003444:	461a      	mov	r2, r3
 8003446:	2310      	movs	r3, #16
 8003448:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT Endpoint disable interrupt */
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 800344a:	693b      	ldr	r3, [r7, #16]
 800344c:	f003 0302 	and.w	r3, r3, #2
 8003450:	2b00      	cmp	r3, #0
 8003452:	d030      	beq.n	80034b6 <HAL_PCD_IRQHandler+0x25e>
          {
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 8003454:	6a3b      	ldr	r3, [r7, #32]
 8003456:	695b      	ldr	r3, [r3, #20]
 8003458:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800345c:	2b80      	cmp	r3, #128	@ 0x80
 800345e:	d109      	bne.n	8003474 <HAL_PCD_IRQHandler+0x21c>
            {
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8003460:	69fb      	ldr	r3, [r7, #28]
 8003462:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003466:	685b      	ldr	r3, [r3, #4]
 8003468:	69fa      	ldr	r2, [r7, #28]
 800346a:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800346e:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8003472:	6053      	str	r3, [r2, #4]
            }

            ep = &hpcd->OUT_ep[epnum];
 8003474:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003476:	4613      	mov	r3, r2
 8003478:	00db      	lsls	r3, r3, #3
 800347a:	4413      	add	r3, r2
 800347c:	009b      	lsls	r3, r3, #2
 800347e:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003482:	687a      	ldr	r2, [r7, #4]
 8003484:	4413      	add	r3, r2
 8003486:	3304      	adds	r3, #4
 8003488:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 800348a:	697b      	ldr	r3, [r7, #20]
 800348c:	78db      	ldrb	r3, [r3, #3]
 800348e:	2b01      	cmp	r3, #1
 8003490:	d108      	bne.n	80034a4 <HAL_PCD_IRQHandler+0x24c>
            {
              ep->is_iso_incomplete = 0U;
 8003492:	697b      	ldr	r3, [r7, #20]
 8003494:	2200      	movs	r2, #0
 8003496:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8003498:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800349a:	b2db      	uxtb	r3, r3
 800349c:	4619      	mov	r1, r3
 800349e:	6878      	ldr	r0, [r7, #4]
 80034a0:	f024 fcbc 	bl	8027e1c <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 80034a4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80034a6:	015a      	lsls	r2, r3, #5
 80034a8:	69fb      	ldr	r3, [r7, #28]
 80034aa:	4413      	add	r3, r2
 80034ac:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80034b0:	461a      	mov	r2, r3
 80034b2:	2302      	movs	r3, #2
 80034b4:	6093      	str	r3, [r2, #8]
          }

          /* Clear Status Phase Received interrupt */
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 80034b6:	693b      	ldr	r3, [r7, #16]
 80034b8:	f003 0320 	and.w	r3, r3, #32
 80034bc:	2b00      	cmp	r3, #0
 80034be:	d008      	beq.n	80034d2 <HAL_PCD_IRQHandler+0x27a>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80034c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80034c2:	015a      	lsls	r2, r3, #5
 80034c4:	69fb      	ldr	r3, [r7, #28]
 80034c6:	4413      	add	r3, r2
 80034c8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80034cc:	461a      	mov	r2, r3
 80034ce:	2320      	movs	r3, #32
 80034d0:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT NAK interrupt */
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 80034d2:	693b      	ldr	r3, [r7, #16]
 80034d4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80034d8:	2b00      	cmp	r3, #0
 80034da:	d009      	beq.n	80034f0 <HAL_PCD_IRQHandler+0x298>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 80034dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80034de:	015a      	lsls	r2, r3, #5
 80034e0:	69fb      	ldr	r3, [r7, #28]
 80034e2:	4413      	add	r3, r2
 80034e4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80034e8:	461a      	mov	r2, r3
 80034ea:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 80034ee:	6093      	str	r3, [r2, #8]
          }
        }
        epnum++;
 80034f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80034f2:	3301      	adds	r3, #1
 80034f4:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 80034f6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80034f8:	085b      	lsrs	r3, r3, #1
 80034fa:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 80034fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80034fe:	2b00      	cmp	r3, #0
 8003500:	f47f af62 	bne.w	80033c8 <HAL_PCD_IRQHandler+0x170>
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8003504:	687b      	ldr	r3, [r7, #4]
 8003506:	681b      	ldr	r3, [r3, #0]
 8003508:	4618      	mov	r0, r3
 800350a:	f003 f8a1 	bl	8006650 <USB_ReadInterrupts>
 800350e:	4603      	mov	r3, r0
 8003510:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8003514:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8003518:	f040 80db 	bne.w	80036d2 <HAL_PCD_IRQHandler+0x47a>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 800351c:	687b      	ldr	r3, [r7, #4]
 800351e:	681b      	ldr	r3, [r3, #0]
 8003520:	4618      	mov	r0, r3
 8003522:	f003 f8c2 	bl	80066aa <USB_ReadDevAllInEpInterrupt>
 8003526:	62b8      	str	r0, [r7, #40]	@ 0x28

      epnum = 0U;
 8003528:	2300      	movs	r3, #0
 800352a:	627b      	str	r3, [r7, #36]	@ 0x24

      while (ep_intr != 0U)
 800352c:	e0cd      	b.n	80036ca <HAL_PCD_IRQHandler+0x472>
      {
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 800352e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8003530:	f003 0301 	and.w	r3, r3, #1
 8003534:	2b00      	cmp	r3, #0
 8003536:	f000 80c2 	beq.w	80036be <HAL_PCD_IRQHandler+0x466>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800353a:	687b      	ldr	r3, [r7, #4]
 800353c:	681b      	ldr	r3, [r3, #0]
 800353e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003540:	b2d2      	uxtb	r2, r2
 8003542:	4611      	mov	r1, r2
 8003544:	4618      	mov	r0, r3
 8003546:	f003 f8e8 	bl	800671a <USB_ReadDevInEPInterrupt>
 800354a:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 800354c:	693b      	ldr	r3, [r7, #16]
 800354e:	f003 0301 	and.w	r3, r3, #1
 8003552:	2b00      	cmp	r3, #0
 8003554:	d057      	beq.n	8003606 <HAL_PCD_IRQHandler+0x3ae>
          {
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8003556:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003558:	f003 030f 	and.w	r3, r3, #15
 800355c:	2201      	movs	r2, #1
 800355e:	fa02 f303 	lsl.w	r3, r2, r3
 8003562:	60fb      	str	r3, [r7, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8003564:	69fb      	ldr	r3, [r7, #28]
 8003566:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800356a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800356c:	68fb      	ldr	r3, [r7, #12]
 800356e:	43db      	mvns	r3, r3
 8003570:	69f9      	ldr	r1, [r7, #28]
 8003572:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8003576:	4013      	ands	r3, r2
 8003578:	634b      	str	r3, [r1, #52]	@ 0x34

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 800357a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800357c:	015a      	lsls	r2, r3, #5
 800357e:	69fb      	ldr	r3, [r7, #28]
 8003580:	4413      	add	r3, r2
 8003582:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8003586:	461a      	mov	r2, r3
 8003588:	2301      	movs	r3, #1
 800358a:	6093      	str	r3, [r2, #8]

            if (hpcd->Init.dma_enable == 1U)
 800358c:	687b      	ldr	r3, [r7, #4]
 800358e:	799b      	ldrb	r3, [r3, #6]
 8003590:	2b01      	cmp	r3, #1
 8003592:	d132      	bne.n	80035fa <HAL_PCD_IRQHandler+0x3a2>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 8003594:	6879      	ldr	r1, [r7, #4]
 8003596:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003598:	4613      	mov	r3, r2
 800359a:	00db      	lsls	r3, r3, #3
 800359c:	4413      	add	r3, r2
 800359e:	009b      	lsls	r3, r3, #2
 80035a0:	440b      	add	r3, r1
 80035a2:	3320      	adds	r3, #32
 80035a4:	6819      	ldr	r1, [r3, #0]
 80035a6:	6878      	ldr	r0, [r7, #4]
 80035a8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80035aa:	4613      	mov	r3, r2
 80035ac:	00db      	lsls	r3, r3, #3
 80035ae:	4413      	add	r3, r2
 80035b0:	009b      	lsls	r3, r3, #2
 80035b2:	4403      	add	r3, r0
 80035b4:	331c      	adds	r3, #28
 80035b6:	681b      	ldr	r3, [r3, #0]
 80035b8:	4419      	add	r1, r3
 80035ba:	6878      	ldr	r0, [r7, #4]
 80035bc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80035be:	4613      	mov	r3, r2
 80035c0:	00db      	lsls	r3, r3, #3
 80035c2:	4413      	add	r3, r2
 80035c4:	009b      	lsls	r3, r3, #2
 80035c6:	4403      	add	r3, r0
 80035c8:	3320      	adds	r3, #32
 80035ca:	6019      	str	r1, [r3, #0]

              /* this is ZLP, so prepare EP0 for next setup */
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 80035cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80035ce:	2b00      	cmp	r3, #0
 80035d0:	d113      	bne.n	80035fa <HAL_PCD_IRQHandler+0x3a2>
 80035d2:	6879      	ldr	r1, [r7, #4]
 80035d4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80035d6:	4613      	mov	r3, r2
 80035d8:	00db      	lsls	r3, r3, #3
 80035da:	4413      	add	r3, r2
 80035dc:	009b      	lsls	r3, r3, #2
 80035de:	440b      	add	r3, r1
 80035e0:	3324      	adds	r3, #36	@ 0x24
 80035e2:	681b      	ldr	r3, [r3, #0]
 80035e4:	2b00      	cmp	r3, #0
 80035e6:	d108      	bne.n	80035fa <HAL_PCD_IRQHandler+0x3a2>
              {
                /* prepare to rx more setup packets */
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80035e8:	687b      	ldr	r3, [r7, #4]
 80035ea:	6818      	ldr	r0, [r3, #0]
 80035ec:	687b      	ldr	r3, [r7, #4]
 80035ee:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 80035f2:	461a      	mov	r2, r3
 80035f4:	2101      	movs	r1, #1
 80035f6:	f003 f8ef 	bl	80067d8 <USB_EP0_OutStart>
            }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
#else
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 80035fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80035fc:	b2db      	uxtb	r3, r3
 80035fe:	4619      	mov	r1, r3
 8003600:	6878      	ldr	r0, [r7, #4]
 8003602:	f024 fb86 	bl	8027d12 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8003606:	693b      	ldr	r3, [r7, #16]
 8003608:	f003 0308 	and.w	r3, r3, #8
 800360c:	2b00      	cmp	r3, #0
 800360e:	d008      	beq.n	8003622 <HAL_PCD_IRQHandler+0x3ca>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8003610:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003612:	015a      	lsls	r2, r3, #5
 8003614:	69fb      	ldr	r3, [r7, #28]
 8003616:	4413      	add	r3, r2
 8003618:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800361c:	461a      	mov	r2, r3
 800361e:	2308      	movs	r3, #8
 8003620:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8003622:	693b      	ldr	r3, [r7, #16]
 8003624:	f003 0310 	and.w	r3, r3, #16
 8003628:	2b00      	cmp	r3, #0
 800362a:	d008      	beq.n	800363e <HAL_PCD_IRQHandler+0x3e6>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 800362c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800362e:	015a      	lsls	r2, r3, #5
 8003630:	69fb      	ldr	r3, [r7, #28]
 8003632:	4413      	add	r3, r2
 8003634:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8003638:	461a      	mov	r2, r3
 800363a:	2310      	movs	r3, #16
 800363c:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 800363e:	693b      	ldr	r3, [r7, #16]
 8003640:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8003644:	2b00      	cmp	r3, #0
 8003646:	d008      	beq.n	800365a <HAL_PCD_IRQHandler+0x402>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8003648:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800364a:	015a      	lsls	r2, r3, #5
 800364c:	69fb      	ldr	r3, [r7, #28]
 800364e:	4413      	add	r3, r2
 8003650:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8003654:	461a      	mov	r2, r3
 8003656:	2340      	movs	r3, #64	@ 0x40
 8003658:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 800365a:	693b      	ldr	r3, [r7, #16]
 800365c:	f003 0302 	and.w	r3, r3, #2
 8003660:	2b00      	cmp	r3, #0
 8003662:	d023      	beq.n	80036ac <HAL_PCD_IRQHandler+0x454>
          {
            (void)USB_FlushTxFifo(USBx, epnum);
 8003664:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8003666:	6a38      	ldr	r0, [r7, #32]
 8003668:	f002 f8d6 	bl	8005818 <USB_FlushTxFifo>

            ep = &hpcd->IN_ep[epnum];
 800366c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800366e:	4613      	mov	r3, r2
 8003670:	00db      	lsls	r3, r3, #3
 8003672:	4413      	add	r3, r2
 8003674:	009b      	lsls	r3, r3, #2
 8003676:	3310      	adds	r3, #16
 8003678:	687a      	ldr	r2, [r7, #4]
 800367a:	4413      	add	r3, r2
 800367c:	3304      	adds	r3, #4
 800367e:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 8003680:	697b      	ldr	r3, [r7, #20]
 8003682:	78db      	ldrb	r3, [r3, #3]
 8003684:	2b01      	cmp	r3, #1
 8003686:	d108      	bne.n	800369a <HAL_PCD_IRQHandler+0x442>
            {
              ep->is_iso_incomplete = 0U;
 8003688:	697b      	ldr	r3, [r7, #20]
 800368a:	2200      	movs	r2, #0
 800368c:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 800368e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003690:	b2db      	uxtb	r3, r3
 8003692:	4619      	mov	r1, r3
 8003694:	6878      	ldr	r0, [r7, #4]
 8003696:	f024 fbd3 	bl	8027e40 <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 800369a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800369c:	015a      	lsls	r2, r3, #5
 800369e:	69fb      	ldr	r3, [r7, #28]
 80036a0:	4413      	add	r3, r2
 80036a2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80036a6:	461a      	mov	r2, r3
 80036a8:	2302      	movs	r3, #2
 80036aa:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 80036ac:	693b      	ldr	r3, [r7, #16]
 80036ae:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80036b2:	2b00      	cmp	r3, #0
 80036b4:	d003      	beq.n	80036be <HAL_PCD_IRQHandler+0x466>
          {
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
 80036b6:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80036b8:	6878      	ldr	r0, [r7, #4]
 80036ba:	f000 fcbd 	bl	8004038 <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
 80036be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80036c0:	3301      	adds	r3, #1
 80036c2:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 80036c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80036c6:	085b      	lsrs	r3, r3, #1
 80036c8:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 80036ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80036cc:	2b00      	cmp	r3, #0
 80036ce:	f47f af2e 	bne.w	800352e <HAL_PCD_IRQHandler+0x2d6>
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80036d2:	687b      	ldr	r3, [r7, #4]
 80036d4:	681b      	ldr	r3, [r3, #0]
 80036d6:	4618      	mov	r0, r3
 80036d8:	f002 ffba 	bl	8006650 <USB_ReadInterrupts>
 80036dc:	4603      	mov	r3, r0
 80036de:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80036e2:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80036e6:	d122      	bne.n	800372e <HAL_PCD_IRQHandler+0x4d6>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80036e8:	69fb      	ldr	r3, [r7, #28]
 80036ea:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80036ee:	685b      	ldr	r3, [r3, #4]
 80036f0:	69fa      	ldr	r2, [r7, #28]
 80036f2:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80036f6:	f023 0301 	bic.w	r3, r3, #1
 80036fa:	6053      	str	r3, [r2, #4]

      if (hpcd->LPM_State == LPM_L1)
 80036fc:	687b      	ldr	r3, [r7, #4]
 80036fe:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
 8003702:	2b01      	cmp	r3, #1
 8003704:	d108      	bne.n	8003718 <HAL_PCD_IRQHandler+0x4c0>
      {
        hpcd->LPM_State = LPM_L0;
 8003706:	687b      	ldr	r3, [r7, #4]
 8003708:	2200      	movs	r2, #0
 800370a:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800370e:	2100      	movs	r1, #0
 8003710:	6878      	ldr	r0, [r7, #4]
 8003712:	f000 fea3 	bl	800445c <HAL_PCDEx_LPM_Callback>
 8003716:	e002      	b.n	800371e <HAL_PCD_IRQHandler+0x4c6>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->ResumeCallback(hpcd);
#else
        HAL_PCD_ResumeCallback(hpcd);
 8003718:	6878      	ldr	r0, [r7, #4]
 800371a:	f024 fb71 	bl	8027e00 <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 800371e:	687b      	ldr	r3, [r7, #4]
 8003720:	681b      	ldr	r3, [r3, #0]
 8003722:	695a      	ldr	r2, [r3, #20]
 8003724:	687b      	ldr	r3, [r7, #4]
 8003726:	681b      	ldr	r3, [r3, #0]
 8003728:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
 800372c:	615a      	str	r2, [r3, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 800372e:	687b      	ldr	r3, [r7, #4]
 8003730:	681b      	ldr	r3, [r3, #0]
 8003732:	4618      	mov	r0, r3
 8003734:	f002 ff8c 	bl	8006650 <USB_ReadInterrupts>
 8003738:	4603      	mov	r3, r0
 800373a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800373e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8003742:	d112      	bne.n	800376a <HAL_PCD_IRQHandler+0x512>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8003744:	69fb      	ldr	r3, [r7, #28]
 8003746:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800374a:	689b      	ldr	r3, [r3, #8]
 800374c:	f003 0301 	and.w	r3, r3, #1
 8003750:	2b01      	cmp	r3, #1
 8003752:	d102      	bne.n	800375a <HAL_PCD_IRQHandler+0x502>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 8003754:	6878      	ldr	r0, [r7, #4]
 8003756:	f024 fb2d 	bl	8027db4 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 800375a:	687b      	ldr	r3, [r7, #4]
 800375c:	681b      	ldr	r3, [r3, #0]
 800375e:	695a      	ldr	r2, [r3, #20]
 8003760:	687b      	ldr	r3, [r7, #4]
 8003762:	681b      	ldr	r3, [r3, #0]
 8003764:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 8003768:	615a      	str	r2, [r3, #20]
    }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */
    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 800376a:	687b      	ldr	r3, [r7, #4]
 800376c:	681b      	ldr	r3, [r3, #0]
 800376e:	4618      	mov	r0, r3
 8003770:	f002 ff6e 	bl	8006650 <USB_ReadInterrupts>
 8003774:	4603      	mov	r3, r0
 8003776:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 800377a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800377e:	f040 80b7 	bne.w	80038f0 <HAL_PCD_IRQHandler+0x698>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8003782:	69fb      	ldr	r3, [r7, #28]
 8003784:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003788:	685b      	ldr	r3, [r3, #4]
 800378a:	69fa      	ldr	r2, [r7, #28]
 800378c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003790:	f023 0301 	bic.w	r3, r3, #1
 8003794:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8003796:	687b      	ldr	r3, [r7, #4]
 8003798:	681b      	ldr	r3, [r3, #0]
 800379a:	2110      	movs	r1, #16
 800379c:	4618      	mov	r0, r3
 800379e:	f002 f83b 	bl	8005818 <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80037a2:	2300      	movs	r3, #0
 80037a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80037a6:	e046      	b.n	8003836 <HAL_PCD_IRQHandler+0x5de>
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 80037a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80037aa:	015a      	lsls	r2, r3, #5
 80037ac:	69fb      	ldr	r3, [r7, #28]
 80037ae:	4413      	add	r3, r2
 80037b0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80037b4:	461a      	mov	r2, r3
 80037b6:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 80037ba:	6093      	str	r3, [r2, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 80037bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80037be:	015a      	lsls	r2, r3, #5
 80037c0:	69fb      	ldr	r3, [r7, #28]
 80037c2:	4413      	add	r3, r2
 80037c4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80037c8:	681b      	ldr	r3, [r3, #0]
 80037ca:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80037cc:	0151      	lsls	r1, r2, #5
 80037ce:	69fa      	ldr	r2, [r7, #28]
 80037d0:	440a      	add	r2, r1
 80037d2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80037d6:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 80037da:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 80037dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80037de:	015a      	lsls	r2, r3, #5
 80037e0:	69fb      	ldr	r3, [r7, #28]
 80037e2:	4413      	add	r3, r2
 80037e4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80037e8:	461a      	mov	r2, r3
 80037ea:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 80037ee:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 80037f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80037f2:	015a      	lsls	r2, r3, #5
 80037f4:	69fb      	ldr	r3, [r7, #28]
 80037f6:	4413      	add	r3, r2
 80037f8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80037fc:	681b      	ldr	r3, [r3, #0]
 80037fe:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8003800:	0151      	lsls	r1, r2, #5
 8003802:	69fa      	ldr	r2, [r7, #28]
 8003804:	440a      	add	r2, r1
 8003806:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800380a:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 800380e:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8003810:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003812:	015a      	lsls	r2, r3, #5
 8003814:	69fb      	ldr	r3, [r7, #28]
 8003816:	4413      	add	r3, r2
 8003818:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800381c:	681b      	ldr	r3, [r3, #0]
 800381e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8003820:	0151      	lsls	r1, r2, #5
 8003822:	69fa      	ldr	r2, [r7, #28]
 8003824:	440a      	add	r2, r1
 8003826:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800382a:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 800382e:	6013      	str	r3, [r2, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003830:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003832:	3301      	adds	r3, #1
 8003834:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8003836:	687b      	ldr	r3, [r7, #4]
 8003838:	791b      	ldrb	r3, [r3, #4]
 800383a:	461a      	mov	r2, r3
 800383c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800383e:	4293      	cmp	r3, r2
 8003840:	d3b2      	bcc.n	80037a8 <HAL_PCD_IRQHandler+0x550>
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8003842:	69fb      	ldr	r3, [r7, #28]
 8003844:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003848:	69db      	ldr	r3, [r3, #28]
 800384a:	69fa      	ldr	r2, [r7, #28]
 800384c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003850:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
 8003854:	61d3      	str	r3, [r2, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8003856:	687b      	ldr	r3, [r7, #4]
 8003858:	7bdb      	ldrb	r3, [r3, #15]
 800385a:	2b00      	cmp	r3, #0
 800385c:	d016      	beq.n	800388c <HAL_PCD_IRQHandler+0x634>
      {
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 800385e:	69fb      	ldr	r3, [r7, #28]
 8003860:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003864:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8003868:	69fa      	ldr	r2, [r7, #28]
 800386a:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800386e:	f043 030b 	orr.w	r3, r3, #11
 8003872:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                   USB_OTG_DOEPMSK_XFRCM |
                                   USB_OTG_DOEPMSK_EPDM;

        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 8003876:	69fb      	ldr	r3, [r7, #28]
 8003878:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800387c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800387e:	69fa      	ldr	r2, [r7, #28]
 8003880:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003884:	f043 030b 	orr.w	r3, r3, #11
 8003888:	6453      	str	r3, [r2, #68]	@ 0x44
 800388a:	e015      	b.n	80038b8 <HAL_PCD_IRQHandler+0x660>
                                  USB_OTG_DIEPMSK_XFRCM |
                                  USB_OTG_DIEPMSK_EPDM;
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 800388c:	69fb      	ldr	r3, [r7, #28]
 800388e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003892:	695b      	ldr	r3, [r3, #20]
 8003894:	69fa      	ldr	r2, [r7, #28]
 8003896:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800389a:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800389e:	f043 032b 	orr.w	r3, r3, #43	@ 0x2b
 80038a2:	6153      	str	r3, [r2, #20]
                                USB_OTG_DOEPMSK_XFRCM |
                                USB_OTG_DOEPMSK_EPDM |
                                USB_OTG_DOEPMSK_OTEPSPRM |
                                USB_OTG_DOEPMSK_NAKM;

        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 80038a4:	69fb      	ldr	r3, [r7, #28]
 80038a6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80038aa:	691b      	ldr	r3, [r3, #16]
 80038ac:	69fa      	ldr	r2, [r7, #28]
 80038ae:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80038b2:	f043 030b 	orr.w	r3, r3, #11
 80038b6:	6113      	str	r3, [r2, #16]
                                USB_OTG_DIEPMSK_XFRCM |
                                USB_OTG_DIEPMSK_EPDM;
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 80038b8:	69fb      	ldr	r3, [r7, #28]
 80038ba:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80038be:	681b      	ldr	r3, [r3, #0]
 80038c0:	69fa      	ldr	r2, [r7, #28]
 80038c2:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80038c6:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 80038ca:	6013      	str	r3, [r2, #0]

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 80038cc:	687b      	ldr	r3, [r7, #4]
 80038ce:	6818      	ldr	r0, [r3, #0]
 80038d0:	687b      	ldr	r3, [r7, #4]
 80038d2:	7999      	ldrb	r1, [r3, #6]
                             (uint8_t *)hpcd->Setup);
 80038d4:	687b      	ldr	r3, [r7, #4]
 80038d6:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 80038da:	461a      	mov	r2, r3
 80038dc:	f002 ff7c 	bl	80067d8 <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 80038e0:	687b      	ldr	r3, [r7, #4]
 80038e2:	681b      	ldr	r3, [r3, #0]
 80038e4:	695a      	ldr	r2, [r3, #20]
 80038e6:	687b      	ldr	r3, [r7, #4]
 80038e8:	681b      	ldr	r3, [r3, #0]
 80038ea:	f402 5280 	and.w	r2, r2, #4096	@ 0x1000
 80038ee:	615a      	str	r2, [r3, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80038f0:	687b      	ldr	r3, [r7, #4]
 80038f2:	681b      	ldr	r3, [r3, #0]
 80038f4:	4618      	mov	r0, r3
 80038f6:	f002 feab 	bl	8006650 <USB_ReadInterrupts>
 80038fa:	4603      	mov	r3, r0
 80038fc:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8003900:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8003904:	d123      	bne.n	800394e <HAL_PCD_IRQHandler+0x6f6>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
 8003906:	687b      	ldr	r3, [r7, #4]
 8003908:	681b      	ldr	r3, [r3, #0]
 800390a:	4618      	mov	r0, r3
 800390c:	f002 ff41 	bl	8006792 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8003910:	687b      	ldr	r3, [r7, #4]
 8003912:	681b      	ldr	r3, [r3, #0]
 8003914:	4618      	mov	r0, r3
 8003916:	f001 fff8 	bl	800590a <USB_GetDevSpeed>
 800391a:	4603      	mov	r3, r0
 800391c:	461a      	mov	r2, r3
 800391e:	687b      	ldr	r3, [r7, #4]
 8003920:	71da      	strb	r2, [r3, #7]

      /* Set USB Turnaround time */
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8003922:	687b      	ldr	r3, [r7, #4]
 8003924:	681c      	ldr	r4, [r3, #0]
 8003926:	f001 fa09 	bl	8004d3c <HAL_RCC_GetHCLKFreq>
 800392a:	4601      	mov	r1, r0
                                  HAL_RCC_GetHCLKFreq(),
                                  (uint8_t)hpcd->Init.speed);
 800392c:	687b      	ldr	r3, [r7, #4]
 800392e:	79db      	ldrb	r3, [r3, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8003930:	461a      	mov	r2, r3
 8003932:	4620      	mov	r0, r4
 8003934:	f001 fcfc 	bl	8005330 <USB_SetTurnaroundTime>

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
 8003938:	6878      	ldr	r0, [r7, #4]
 800393a:	f024 fa12 	bl	8027d62 <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 800393e:	687b      	ldr	r3, [r7, #4]
 8003940:	681b      	ldr	r3, [r3, #0]
 8003942:	695a      	ldr	r2, [r3, #20]
 8003944:	687b      	ldr	r3, [r7, #4]
 8003946:	681b      	ldr	r3, [r3, #0]
 8003948:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 800394c:	615a      	str	r2, [r3, #20]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 800394e:	687b      	ldr	r3, [r7, #4]
 8003950:	681b      	ldr	r3, [r3, #0]
 8003952:	4618      	mov	r0, r3
 8003954:	f002 fe7c 	bl	8006650 <USB_ReadInterrupts>
 8003958:	4603      	mov	r3, r0
 800395a:	f003 0308 	and.w	r3, r3, #8
 800395e:	2b08      	cmp	r3, #8
 8003960:	d10a      	bne.n	8003978 <HAL_PCD_IRQHandler+0x720>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
 8003962:	6878      	ldr	r0, [r7, #4]
 8003964:	f024 f9ef 	bl	8027d46 <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8003968:	687b      	ldr	r3, [r7, #4]
 800396a:	681b      	ldr	r3, [r3, #0]
 800396c:	695a      	ldr	r2, [r3, #20]
 800396e:	687b      	ldr	r3, [r7, #4]
 8003970:	681b      	ldr	r3, [r3, #0]
 8003972:	f002 0208 	and.w	r2, r2, #8
 8003976:	615a      	str	r2, [r3, #20]
    }

    /* Handle Global OUT NAK effective Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 8003978:	687b      	ldr	r3, [r7, #4]
 800397a:	681b      	ldr	r3, [r3, #0]
 800397c:	4618      	mov	r0, r3
 800397e:	f002 fe67 	bl	8006650 <USB_ReadInterrupts>
 8003982:	4603      	mov	r3, r0
 8003984:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8003988:	2b80      	cmp	r3, #128	@ 0x80
 800398a:	d123      	bne.n	80039d4 <HAL_PCD_IRQHandler+0x77c>
    {
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 800398c:	6a3b      	ldr	r3, [r7, #32]
 800398e:	699b      	ldr	r3, [r3, #24]
 8003990:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8003994:	6a3b      	ldr	r3, [r7, #32]
 8003996:	619a      	str	r2, [r3, #24]

      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003998:	2301      	movs	r3, #1
 800399a:	627b      	str	r3, [r7, #36]	@ 0x24
 800399c:	e014      	b.n	80039c8 <HAL_PCD_IRQHandler+0x770>
      {
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800399e:	6879      	ldr	r1, [r7, #4]
 80039a0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80039a2:	4613      	mov	r3, r2
 80039a4:	00db      	lsls	r3, r3, #3
 80039a6:	4413      	add	r3, r2
 80039a8:	009b      	lsls	r3, r3, #2
 80039aa:	440b      	add	r3, r1
 80039ac:	f203 2357 	addw	r3, r3, #599	@ 0x257
 80039b0:	781b      	ldrb	r3, [r3, #0]
 80039b2:	2b01      	cmp	r3, #1
 80039b4:	d105      	bne.n	80039c2 <HAL_PCD_IRQHandler+0x76a>
        {
          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)epnum);
 80039b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80039b8:	b2db      	uxtb	r3, r3
 80039ba:	4619      	mov	r1, r3
 80039bc:	6878      	ldr	r0, [r7, #4]
 80039be:	f000 fb0a 	bl	8003fd6 <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80039c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80039c4:	3301      	adds	r3, #1
 80039c6:	627b      	str	r3, [r7, #36]	@ 0x24
 80039c8:	687b      	ldr	r3, [r7, #4]
 80039ca:	791b      	ldrb	r3, [r3, #4]
 80039cc:	461a      	mov	r2, r3
 80039ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80039d0:	4293      	cmp	r3, r2
 80039d2:	d3e4      	bcc.n	800399e <HAL_PCD_IRQHandler+0x746>
        }
      }
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 80039d4:	687b      	ldr	r3, [r7, #4]
 80039d6:	681b      	ldr	r3, [r3, #0]
 80039d8:	4618      	mov	r0, r3
 80039da:	f002 fe39 	bl	8006650 <USB_ReadInterrupts>
 80039de:	4603      	mov	r3, r0
 80039e0:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 80039e4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80039e8:	d13c      	bne.n	8003a64 <HAL_PCD_IRQHandler+0x80c>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80039ea:	2301      	movs	r3, #1
 80039ec:	627b      	str	r3, [r7, #36]	@ 0x24
 80039ee:	e02b      	b.n	8003a48 <HAL_PCD_IRQHandler+0x7f0>
      {
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80039f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80039f2:	015a      	lsls	r2, r3, #5
 80039f4:	69fb      	ldr	r3, [r7, #28]
 80039f6:	4413      	add	r3, r2
 80039f8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80039fc:	681b      	ldr	r3, [r3, #0]
 80039fe:	61bb      	str	r3, [r7, #24]

        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8003a00:	6879      	ldr	r1, [r7, #4]
 8003a02:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003a04:	4613      	mov	r3, r2
 8003a06:	00db      	lsls	r3, r3, #3
 8003a08:	4413      	add	r3, r2
 8003a0a:	009b      	lsls	r3, r3, #2
 8003a0c:	440b      	add	r3, r1
 8003a0e:	3318      	adds	r3, #24
 8003a10:	781b      	ldrb	r3, [r3, #0]
 8003a12:	2b01      	cmp	r3, #1
 8003a14:	d115      	bne.n	8003a42 <HAL_PCD_IRQHandler+0x7ea>
            ((RegVal & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA))
 8003a16:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8003a18:	2b00      	cmp	r3, #0
 8003a1a:	da12      	bge.n	8003a42 <HAL_PCD_IRQHandler+0x7ea>
        {
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8003a1c:	6879      	ldr	r1, [r7, #4]
 8003a1e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003a20:	4613      	mov	r3, r2
 8003a22:	00db      	lsls	r3, r3, #3
 8003a24:	4413      	add	r3, r2
 8003a26:	009b      	lsls	r3, r3, #2
 8003a28:	440b      	add	r3, r1
 8003a2a:	3317      	adds	r3, #23
 8003a2c:	2201      	movs	r2, #1
 8003a2e:	701a      	strb	r2, [r3, #0]

          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
 8003a30:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003a32:	b2db      	uxtb	r3, r3
 8003a34:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8003a38:	b2db      	uxtb	r3, r3
 8003a3a:	4619      	mov	r1, r3
 8003a3c:	6878      	ldr	r0, [r7, #4]
 8003a3e:	f000 faca 	bl	8003fd6 <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003a42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003a44:	3301      	adds	r3, #1
 8003a46:	627b      	str	r3, [r7, #36]	@ 0x24
 8003a48:	687b      	ldr	r3, [r7, #4]
 8003a4a:	791b      	ldrb	r3, [r3, #4]
 8003a4c:	461a      	mov	r2, r3
 8003a4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003a50:	4293      	cmp	r3, r2
 8003a52:	d3cd      	bcc.n	80039f0 <HAL_PCD_IRQHandler+0x798>
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8003a54:	687b      	ldr	r3, [r7, #4]
 8003a56:	681b      	ldr	r3, [r3, #0]
 8003a58:	695a      	ldr	r2, [r3, #20]
 8003a5a:	687b      	ldr	r3, [r7, #4]
 8003a5c:	681b      	ldr	r3, [r3, #0]
 8003a5e:	f402 1280 	and.w	r2, r2, #1048576	@ 0x100000
 8003a62:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8003a64:	687b      	ldr	r3, [r7, #4]
 8003a66:	681b      	ldr	r3, [r3, #0]
 8003a68:	4618      	mov	r0, r3
 8003a6a:	f002 fdf1 	bl	8006650 <USB_ReadInterrupts>
 8003a6e:	4603      	mov	r3, r0
 8003a70:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8003a74:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8003a78:	d156      	bne.n	8003b28 <HAL_PCD_IRQHandler+0x8d0>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003a7a:	2301      	movs	r3, #1
 8003a7c:	627b      	str	r3, [r7, #36]	@ 0x24
 8003a7e:	e045      	b.n	8003b0c <HAL_PCD_IRQHandler+0x8b4>
      {
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 8003a80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003a82:	015a      	lsls	r2, r3, #5
 8003a84:	69fb      	ldr	r3, [r7, #28]
 8003a86:	4413      	add	r3, r2
 8003a88:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8003a8c:	681b      	ldr	r3, [r3, #0]
 8003a8e:	61bb      	str	r3, [r7, #24]

        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8003a90:	6879      	ldr	r1, [r7, #4]
 8003a92:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003a94:	4613      	mov	r3, r2
 8003a96:	00db      	lsls	r3, r3, #3
 8003a98:	4413      	add	r3, r2
 8003a9a:	009b      	lsls	r3, r3, #2
 8003a9c:	440b      	add	r3, r1
 8003a9e:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 8003aa2:	781b      	ldrb	r3, [r3, #0]
 8003aa4:	2b01      	cmp	r3, #1
 8003aa6:	d12e      	bne.n	8003b06 <HAL_PCD_IRQHandler+0x8ae>
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8003aa8:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8003aaa:	2b00      	cmp	r3, #0
 8003aac:	da2b      	bge.n	8003b06 <HAL_PCD_IRQHandler+0x8ae>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 8003aae:	69bb      	ldr	r3, [r7, #24]
 8003ab0:	f403 3280 	and.w	r2, r3, #65536	@ 0x10000
 8003ab4:	687b      	ldr	r3, [r7, #4]
 8003ab6:	f8d3 34d4 	ldr.w	r3, [r3, #1236]	@ 0x4d4
 8003aba:	f003 0301 	and.w	r3, r3, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8003abe:	429a      	cmp	r2, r3
 8003ac0:	d121      	bne.n	8003b06 <HAL_PCD_IRQHandler+0x8ae>
        {
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 8003ac2:	6879      	ldr	r1, [r7, #4]
 8003ac4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8003ac6:	4613      	mov	r3, r2
 8003ac8:	00db      	lsls	r3, r3, #3
 8003aca:	4413      	add	r3, r2
 8003acc:	009b      	lsls	r3, r3, #2
 8003ace:	440b      	add	r3, r1
 8003ad0:	f203 2357 	addw	r3, r3, #599	@ 0x257
 8003ad4:	2201      	movs	r2, #1
 8003ad6:	701a      	strb	r2, [r3, #0]

          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 8003ad8:	6a3b      	ldr	r3, [r7, #32]
 8003ada:	699b      	ldr	r3, [r3, #24]
 8003adc:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 8003ae0:	6a3b      	ldr	r3, [r7, #32]
 8003ae2:	619a      	str	r2, [r3, #24]

          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 8003ae4:	6a3b      	ldr	r3, [r7, #32]
 8003ae6:	695b      	ldr	r3, [r3, #20]
 8003ae8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8003aec:	2b00      	cmp	r3, #0
 8003aee:	d10a      	bne.n	8003b06 <HAL_PCD_IRQHandler+0x8ae>
          {
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 8003af0:	69fb      	ldr	r3, [r7, #28]
 8003af2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8003af6:	685b      	ldr	r3, [r3, #4]
 8003af8:	69fa      	ldr	r2, [r7, #28]
 8003afa:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8003afe:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8003b02:	6053      	str	r3, [r2, #4]
            break;
 8003b04:	e008      	b.n	8003b18 <HAL_PCD_IRQHandler+0x8c0>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8003b06:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003b08:	3301      	adds	r3, #1
 8003b0a:	627b      	str	r3, [r7, #36]	@ 0x24
 8003b0c:	687b      	ldr	r3, [r7, #4]
 8003b0e:	791b      	ldrb	r3, [r3, #4]
 8003b10:	461a      	mov	r2, r3
 8003b12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003b14:	4293      	cmp	r3, r2
 8003b16:	d3b3      	bcc.n	8003a80 <HAL_PCD_IRQHandler+0x828>
          }
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8003b18:	687b      	ldr	r3, [r7, #4]
 8003b1a:	681b      	ldr	r3, [r3, #0]
 8003b1c:	695a      	ldr	r2, [r3, #20]
 8003b1e:	687b      	ldr	r3, [r7, #4]
 8003b20:	681b      	ldr	r3, [r3, #0]
 8003b22:	f402 1200 	and.w	r2, r2, #2097152	@ 0x200000
 8003b26:	615a      	str	r2, [r3, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8003b28:	687b      	ldr	r3, [r7, #4]
 8003b2a:	681b      	ldr	r3, [r3, #0]
 8003b2c:	4618      	mov	r0, r3
 8003b2e:	f002 fd8f 	bl	8006650 <USB_ReadInterrupts>
 8003b32:	4603      	mov	r3, r0
 8003b34:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 8003b38:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8003b3c:	d10a      	bne.n	8003b54 <HAL_PCD_IRQHandler+0x8fc>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
 8003b3e:	6878      	ldr	r0, [r7, #4]
 8003b40:	f024 f990 	bl	8027e64 <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8003b44:	687b      	ldr	r3, [r7, #4]
 8003b46:	681b      	ldr	r3, [r3, #0]
 8003b48:	695a      	ldr	r2, [r3, #20]
 8003b4a:	687b      	ldr	r3, [r7, #4]
 8003b4c:	681b      	ldr	r3, [r3, #0]
 8003b4e:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
 8003b52:	615a      	str	r2, [r3, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8003b54:	687b      	ldr	r3, [r7, #4]
 8003b56:	681b      	ldr	r3, [r3, #0]
 8003b58:	4618      	mov	r0, r3
 8003b5a:	f002 fd79 	bl	8006650 <USB_ReadInterrupts>
 8003b5e:	4603      	mov	r3, r0
 8003b60:	f003 0304 	and.w	r3, r3, #4
 8003b64:	2b04      	cmp	r3, #4
 8003b66:	d115      	bne.n	8003b94 <HAL_PCD_IRQHandler+0x93c>
    {
      RegVal = hpcd->Instance->GOTGINT;
 8003b68:	687b      	ldr	r3, [r7, #4]
 8003b6a:	681b      	ldr	r3, [r3, #0]
 8003b6c:	685b      	ldr	r3, [r3, #4]
 8003b6e:	61bb      	str	r3, [r7, #24]

      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8003b70:	69bb      	ldr	r3, [r7, #24]
 8003b72:	f003 0304 	and.w	r3, r3, #4
 8003b76:	2b00      	cmp	r3, #0
 8003b78:	d002      	beq.n	8003b80 <HAL_PCD_IRQHandler+0x928>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
 8003b7a:	6878      	ldr	r0, [r7, #4]
 8003b7c:	f024 f980 	bl	8027e80 <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
 8003b80:	687b      	ldr	r3, [r7, #4]
 8003b82:	681b      	ldr	r3, [r3, #0]
 8003b84:	6859      	ldr	r1, [r3, #4]
 8003b86:	687b      	ldr	r3, [r7, #4]
 8003b88:	681b      	ldr	r3, [r3, #0]
 8003b8a:	69ba      	ldr	r2, [r7, #24]
 8003b8c:	430a      	orrs	r2, r1
 8003b8e:	605a      	str	r2, [r3, #4]
 8003b90:	e000      	b.n	8003b94 <HAL_PCD_IRQHandler+0x93c>
      return;
 8003b92:	bf00      	nop
    }
  }
}
 8003b94:	3734      	adds	r7, #52	@ 0x34
 8003b96:	46bd      	mov	sp, r7
 8003b98:	bd90      	pop	{r4, r7, pc}

08003b9a <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8003b9a:	b580      	push	{r7, lr}
 8003b9c:	b082      	sub	sp, #8
 8003b9e:	af00      	add	r7, sp, #0
 8003ba0:	6078      	str	r0, [r7, #4]
 8003ba2:	460b      	mov	r3, r1
 8003ba4:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
 8003ba6:	687b      	ldr	r3, [r7, #4]
 8003ba8:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003bac:	2b01      	cmp	r3, #1
 8003bae:	d101      	bne.n	8003bb4 <HAL_PCD_SetAddress+0x1a>
 8003bb0:	2302      	movs	r3, #2
 8003bb2:	e012      	b.n	8003bda <HAL_PCD_SetAddress+0x40>
 8003bb4:	687b      	ldr	r3, [r7, #4]
 8003bb6:	2201      	movs	r2, #1
 8003bb8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  hpcd->USB_Address = address;
 8003bbc:	687b      	ldr	r3, [r7, #4]
 8003bbe:	78fa      	ldrb	r2, [r7, #3]
 8003bc0:	745a      	strb	r2, [r3, #17]
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8003bc2:	687b      	ldr	r3, [r7, #4]
 8003bc4:	681b      	ldr	r3, [r3, #0]
 8003bc6:	78fa      	ldrb	r2, [r7, #3]
 8003bc8:	4611      	mov	r1, r2
 8003bca:	4618      	mov	r0, r3
 8003bcc:	f002 fcd8 	bl	8006580 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8003bd0:	687b      	ldr	r3, [r7, #4]
 8003bd2:	2200      	movs	r2, #0
 8003bd4:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8003bd8:	2300      	movs	r3, #0
}
 8003bda:	4618      	mov	r0, r3
 8003bdc:	3708      	adds	r7, #8
 8003bde:	46bd      	mov	sp, r7
 8003be0:	bd80      	pop	{r7, pc}

08003be2 <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 8003be2:	b580      	push	{r7, lr}
 8003be4:	b084      	sub	sp, #16
 8003be6:	af00      	add	r7, sp, #0
 8003be8:	6078      	str	r0, [r7, #4]
 8003bea:	4608      	mov	r0, r1
 8003bec:	4611      	mov	r1, r2
 8003bee:	461a      	mov	r2, r3
 8003bf0:	4603      	mov	r3, r0
 8003bf2:	70fb      	strb	r3, [r7, #3]
 8003bf4:	460b      	mov	r3, r1
 8003bf6:	803b      	strh	r3, [r7, #0]
 8003bf8:	4613      	mov	r3, r2
 8003bfa:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef ret = HAL_OK;
 8003bfc:	2300      	movs	r3, #0
 8003bfe:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8003c00:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003c04:	2b00      	cmp	r3, #0
 8003c06:	da0f      	bge.n	8003c28 <HAL_PCD_EP_Open+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003c08:	78fb      	ldrb	r3, [r7, #3]
 8003c0a:	f003 020f 	and.w	r2, r3, #15
 8003c0e:	4613      	mov	r3, r2
 8003c10:	00db      	lsls	r3, r3, #3
 8003c12:	4413      	add	r3, r2
 8003c14:	009b      	lsls	r3, r3, #2
 8003c16:	3310      	adds	r3, #16
 8003c18:	687a      	ldr	r2, [r7, #4]
 8003c1a:	4413      	add	r3, r2
 8003c1c:	3304      	adds	r3, #4
 8003c1e:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003c20:	68fb      	ldr	r3, [r7, #12]
 8003c22:	2201      	movs	r2, #1
 8003c24:	705a      	strb	r2, [r3, #1]
 8003c26:	e00f      	b.n	8003c48 <HAL_PCD_EP_Open+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003c28:	78fb      	ldrb	r3, [r7, #3]
 8003c2a:	f003 020f 	and.w	r2, r3, #15
 8003c2e:	4613      	mov	r3, r2
 8003c30:	00db      	lsls	r3, r3, #3
 8003c32:	4413      	add	r3, r2
 8003c34:	009b      	lsls	r3, r3, #2
 8003c36:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003c3a:	687a      	ldr	r2, [r7, #4]
 8003c3c:	4413      	add	r3, r2
 8003c3e:	3304      	adds	r3, #4
 8003c40:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003c42:	68fb      	ldr	r3, [r7, #12]
 8003c44:	2200      	movs	r2, #0
 8003c46:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 8003c48:	78fb      	ldrb	r3, [r7, #3]
 8003c4a:	f003 030f 	and.w	r3, r3, #15
 8003c4e:	b2da      	uxtb	r2, r3
 8003c50:	68fb      	ldr	r3, [r7, #12]
 8003c52:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = (uint32_t)ep_mps & 0x7FFU;
 8003c54:	883b      	ldrh	r3, [r7, #0]
 8003c56:	f3c3 020a 	ubfx	r2, r3, #0, #11
 8003c5a:	68fb      	ldr	r3, [r7, #12]
 8003c5c:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
 8003c5e:	68fb      	ldr	r3, [r7, #12]
 8003c60:	78ba      	ldrb	r2, [r7, #2]
 8003c62:	711a      	strb	r2, [r3, #4]

  if (ep->is_in != 0U)
 8003c64:	68fb      	ldr	r3, [r7, #12]
 8003c66:	785b      	ldrb	r3, [r3, #1]
 8003c68:	2b00      	cmp	r3, #0
 8003c6a:	d004      	beq.n	8003c76 <HAL_PCD_EP_Open+0x94>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8003c6c:	68fb      	ldr	r3, [r7, #12]
 8003c6e:	781b      	ldrb	r3, [r3, #0]
 8003c70:	461a      	mov	r2, r3
 8003c72:	68fb      	ldr	r3, [r7, #12]
 8003c74:	835a      	strh	r2, [r3, #26]
  }

  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 8003c76:	78bb      	ldrb	r3, [r7, #2]
 8003c78:	2b02      	cmp	r3, #2
 8003c7a:	d102      	bne.n	8003c82 <HAL_PCD_EP_Open+0xa0>
  {
    ep->data_pid_start = 0U;
 8003c7c:	68fb      	ldr	r3, [r7, #12]
 8003c7e:	2200      	movs	r2, #0
 8003c80:	715a      	strb	r2, [r3, #5]
  }

  __HAL_LOCK(hpcd);
 8003c82:	687b      	ldr	r3, [r7, #4]
 8003c84:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003c88:	2b01      	cmp	r3, #1
 8003c8a:	d101      	bne.n	8003c90 <HAL_PCD_EP_Open+0xae>
 8003c8c:	2302      	movs	r3, #2
 8003c8e:	e00e      	b.n	8003cae <HAL_PCD_EP_Open+0xcc>
 8003c90:	687b      	ldr	r3, [r7, #4]
 8003c92:	2201      	movs	r2, #1
 8003c94:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8003c98:	687b      	ldr	r3, [r7, #4]
 8003c9a:	681b      	ldr	r3, [r3, #0]
 8003c9c:	68f9      	ldr	r1, [r7, #12]
 8003c9e:	4618      	mov	r0, r3
 8003ca0:	f001 fe58 	bl	8005954 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8003ca4:	687b      	ldr	r3, [r7, #4]
 8003ca6:	2200      	movs	r2, #0
 8003ca8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return ret;
 8003cac:	7afb      	ldrb	r3, [r7, #11]
}
 8003cae:	4618      	mov	r0, r3
 8003cb0:	3710      	adds	r7, #16
 8003cb2:	46bd      	mov	sp, r7
 8003cb4:	bd80      	pop	{r7, pc}

08003cb6 <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003cb6:	b580      	push	{r7, lr}
 8003cb8:	b084      	sub	sp, #16
 8003cba:	af00      	add	r7, sp, #0
 8003cbc:	6078      	str	r0, [r7, #4]
 8003cbe:	460b      	mov	r3, r1
 8003cc0:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8003cc2:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003cc6:	2b00      	cmp	r3, #0
 8003cc8:	da0f      	bge.n	8003cea <HAL_PCD_EP_Close+0x34>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003cca:	78fb      	ldrb	r3, [r7, #3]
 8003ccc:	f003 020f 	and.w	r2, r3, #15
 8003cd0:	4613      	mov	r3, r2
 8003cd2:	00db      	lsls	r3, r3, #3
 8003cd4:	4413      	add	r3, r2
 8003cd6:	009b      	lsls	r3, r3, #2
 8003cd8:	3310      	adds	r3, #16
 8003cda:	687a      	ldr	r2, [r7, #4]
 8003cdc:	4413      	add	r3, r2
 8003cde:	3304      	adds	r3, #4
 8003ce0:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003ce2:	68fb      	ldr	r3, [r7, #12]
 8003ce4:	2201      	movs	r2, #1
 8003ce6:	705a      	strb	r2, [r3, #1]
 8003ce8:	e00f      	b.n	8003d0a <HAL_PCD_EP_Close+0x54>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003cea:	78fb      	ldrb	r3, [r7, #3]
 8003cec:	f003 020f 	and.w	r2, r3, #15
 8003cf0:	4613      	mov	r3, r2
 8003cf2:	00db      	lsls	r3, r3, #3
 8003cf4:	4413      	add	r3, r2
 8003cf6:	009b      	lsls	r3, r3, #2
 8003cf8:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003cfc:	687a      	ldr	r2, [r7, #4]
 8003cfe:	4413      	add	r3, r2
 8003d00:	3304      	adds	r3, #4
 8003d02:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003d04:	68fb      	ldr	r3, [r7, #12]
 8003d06:	2200      	movs	r2, #0
 8003d08:	705a      	strb	r2, [r3, #1]
  }
  ep->num = ep_addr & EP_ADDR_MSK;
 8003d0a:	78fb      	ldrb	r3, [r7, #3]
 8003d0c:	f003 030f 	and.w	r3, r3, #15
 8003d10:	b2da      	uxtb	r2, r3
 8003d12:	68fb      	ldr	r3, [r7, #12]
 8003d14:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8003d16:	687b      	ldr	r3, [r7, #4]
 8003d18:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003d1c:	2b01      	cmp	r3, #1
 8003d1e:	d101      	bne.n	8003d24 <HAL_PCD_EP_Close+0x6e>
 8003d20:	2302      	movs	r3, #2
 8003d22:	e00e      	b.n	8003d42 <HAL_PCD_EP_Close+0x8c>
 8003d24:	687b      	ldr	r3, [r7, #4]
 8003d26:	2201      	movs	r2, #1
 8003d28:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8003d2c:	687b      	ldr	r3, [r7, #4]
 8003d2e:	681b      	ldr	r3, [r3, #0]
 8003d30:	68f9      	ldr	r1, [r7, #12]
 8003d32:	4618      	mov	r0, r3
 8003d34:	f001 fe96 	bl	8005a64 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8003d38:	687b      	ldr	r3, [r7, #4]
 8003d3a:	2200      	movs	r2, #0
 8003d3c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  return HAL_OK;
 8003d40:	2300      	movs	r3, #0
}
 8003d42:	4618      	mov	r0, r3
 8003d44:	3710      	adds	r7, #16
 8003d46:	46bd      	mov	sp, r7
 8003d48:	bd80      	pop	{r7, pc}

08003d4a <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8003d4a:	b580      	push	{r7, lr}
 8003d4c:	b086      	sub	sp, #24
 8003d4e:	af00      	add	r7, sp, #0
 8003d50:	60f8      	str	r0, [r7, #12]
 8003d52:	607a      	str	r2, [r7, #4]
 8003d54:	603b      	str	r3, [r7, #0]
 8003d56:	460b      	mov	r3, r1
 8003d58:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003d5a:	7afb      	ldrb	r3, [r7, #11]
 8003d5c:	f003 020f 	and.w	r2, r3, #15
 8003d60:	4613      	mov	r3, r2
 8003d62:	00db      	lsls	r3, r3, #3
 8003d64:	4413      	add	r3, r2
 8003d66:	009b      	lsls	r3, r3, #2
 8003d68:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003d6c:	68fa      	ldr	r2, [r7, #12]
 8003d6e:	4413      	add	r3, r2
 8003d70:	3304      	adds	r3, #4
 8003d72:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 8003d74:	697b      	ldr	r3, [r7, #20]
 8003d76:	687a      	ldr	r2, [r7, #4]
 8003d78:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8003d7a:	697b      	ldr	r3, [r7, #20]
 8003d7c:	683a      	ldr	r2, [r7, #0]
 8003d7e:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 8003d80:	697b      	ldr	r3, [r7, #20]
 8003d82:	2200      	movs	r2, #0
 8003d84:	615a      	str	r2, [r3, #20]
  ep->is_in = 0U;
 8003d86:	697b      	ldr	r3, [r7, #20]
 8003d88:	2200      	movs	r2, #0
 8003d8a:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003d8c:	7afb      	ldrb	r3, [r7, #11]
 8003d8e:	f003 030f 	and.w	r3, r3, #15
 8003d92:	b2da      	uxtb	r2, r3
 8003d94:	697b      	ldr	r3, [r7, #20]
 8003d96:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 8003d98:	68fb      	ldr	r3, [r7, #12]
 8003d9a:	799b      	ldrb	r3, [r3, #6]
 8003d9c:	2b01      	cmp	r3, #1
 8003d9e:	d102      	bne.n	8003da6 <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;
 8003da0:	687a      	ldr	r2, [r7, #4]
 8003da2:	697b      	ldr	r3, [r7, #20]
 8003da4:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8003da6:	68fb      	ldr	r3, [r7, #12]
 8003da8:	6818      	ldr	r0, [r3, #0]
 8003daa:	68fb      	ldr	r3, [r7, #12]
 8003dac:	799b      	ldrb	r3, [r3, #6]
 8003dae:	461a      	mov	r2, r3
 8003db0:	6979      	ldr	r1, [r7, #20]
 8003db2:	f001 ff33 	bl	8005c1c <USB_EPStartXfer>

  return HAL_OK;
 8003db6:	2300      	movs	r3, #0
}
 8003db8:	4618      	mov	r0, r3
 8003dba:	3718      	adds	r7, #24
 8003dbc:	46bd      	mov	sp, r7
 8003dbe:	bd80      	pop	{r7, pc}

08003dc0 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef const *hpcd, uint8_t ep_addr)
{
 8003dc0:	b480      	push	{r7}
 8003dc2:	b083      	sub	sp, #12
 8003dc4:	af00      	add	r7, sp, #0
 8003dc6:	6078      	str	r0, [r7, #4]
 8003dc8:	460b      	mov	r3, r1
 8003dca:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 8003dcc:	78fb      	ldrb	r3, [r7, #3]
 8003dce:	f003 020f 	and.w	r2, r3, #15
 8003dd2:	6879      	ldr	r1, [r7, #4]
 8003dd4:	4613      	mov	r3, r2
 8003dd6:	00db      	lsls	r3, r3, #3
 8003dd8:	4413      	add	r3, r2
 8003dda:	009b      	lsls	r3, r3, #2
 8003ddc:	440b      	add	r3, r1
 8003dde:	f503 731a 	add.w	r3, r3, #616	@ 0x268
 8003de2:	681b      	ldr	r3, [r3, #0]
}
 8003de4:	4618      	mov	r0, r3
 8003de6:	370c      	adds	r7, #12
 8003de8:	46bd      	mov	sp, r7
 8003dea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003dee:	4770      	bx	lr

08003df0 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8003df0:	b580      	push	{r7, lr}
 8003df2:	b086      	sub	sp, #24
 8003df4:	af00      	add	r7, sp, #0
 8003df6:	60f8      	str	r0, [r7, #12]
 8003df8:	607a      	str	r2, [r7, #4]
 8003dfa:	603b      	str	r3, [r7, #0]
 8003dfc:	460b      	mov	r3, r1
 8003dfe:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003e00:	7afb      	ldrb	r3, [r7, #11]
 8003e02:	f003 020f 	and.w	r2, r3, #15
 8003e06:	4613      	mov	r3, r2
 8003e08:	00db      	lsls	r3, r3, #3
 8003e0a:	4413      	add	r3, r2
 8003e0c:	009b      	lsls	r3, r3, #2
 8003e0e:	3310      	adds	r3, #16
 8003e10:	68fa      	ldr	r2, [r7, #12]
 8003e12:	4413      	add	r3, r2
 8003e14:	3304      	adds	r3, #4
 8003e16:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 8003e18:	697b      	ldr	r3, [r7, #20]
 8003e1a:	687a      	ldr	r2, [r7, #4]
 8003e1c:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8003e1e:	697b      	ldr	r3, [r7, #20]
 8003e20:	683a      	ldr	r2, [r7, #0]
 8003e22:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 8003e24:	697b      	ldr	r3, [r7, #20]
 8003e26:	2200      	movs	r2, #0
 8003e28:	615a      	str	r2, [r3, #20]
  ep->is_in = 1U;
 8003e2a:	697b      	ldr	r3, [r7, #20]
 8003e2c:	2201      	movs	r2, #1
 8003e2e:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003e30:	7afb      	ldrb	r3, [r7, #11]
 8003e32:	f003 030f 	and.w	r3, r3, #15
 8003e36:	b2da      	uxtb	r2, r3
 8003e38:	697b      	ldr	r3, [r7, #20]
 8003e3a:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 8003e3c:	68fb      	ldr	r3, [r7, #12]
 8003e3e:	799b      	ldrb	r3, [r3, #6]
 8003e40:	2b01      	cmp	r3, #1
 8003e42:	d102      	bne.n	8003e4a <HAL_PCD_EP_Transmit+0x5a>
  {
    ep->dma_addr = (uint32_t)pBuf;
 8003e44:	687a      	ldr	r2, [r7, #4]
 8003e46:	697b      	ldr	r3, [r7, #20]
 8003e48:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8003e4a:	68fb      	ldr	r3, [r7, #12]
 8003e4c:	6818      	ldr	r0, [r3, #0]
 8003e4e:	68fb      	ldr	r3, [r7, #12]
 8003e50:	799b      	ldrb	r3, [r3, #6]
 8003e52:	461a      	mov	r2, r3
 8003e54:	6979      	ldr	r1, [r7, #20]
 8003e56:	f001 fee1 	bl	8005c1c <USB_EPStartXfer>

  return HAL_OK;
 8003e5a:	2300      	movs	r3, #0
}
 8003e5c:	4618      	mov	r0, r3
 8003e5e:	3718      	adds	r7, #24
 8003e60:	46bd      	mov	sp, r7
 8003e62:	bd80      	pop	{r7, pc}

08003e64 <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003e64:	b580      	push	{r7, lr}
 8003e66:	b084      	sub	sp, #16
 8003e68:	af00      	add	r7, sp, #0
 8003e6a:	6078      	str	r0, [r7, #4]
 8003e6c:	460b      	mov	r3, r1
 8003e6e:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8003e70:	78fb      	ldrb	r3, [r7, #3]
 8003e72:	f003 030f 	and.w	r3, r3, #15
 8003e76:	687a      	ldr	r2, [r7, #4]
 8003e78:	7912      	ldrb	r2, [r2, #4]
 8003e7a:	4293      	cmp	r3, r2
 8003e7c:	d901      	bls.n	8003e82 <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
 8003e7e:	2301      	movs	r3, #1
 8003e80:	e04f      	b.n	8003f22 <HAL_PCD_EP_SetStall+0xbe>
  }

  if ((0x80U & ep_addr) == 0x80U)
 8003e82:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003e86:	2b00      	cmp	r3, #0
 8003e88:	da0f      	bge.n	8003eaa <HAL_PCD_EP_SetStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003e8a:	78fb      	ldrb	r3, [r7, #3]
 8003e8c:	f003 020f 	and.w	r2, r3, #15
 8003e90:	4613      	mov	r3, r2
 8003e92:	00db      	lsls	r3, r3, #3
 8003e94:	4413      	add	r3, r2
 8003e96:	009b      	lsls	r3, r3, #2
 8003e98:	3310      	adds	r3, #16
 8003e9a:	687a      	ldr	r2, [r7, #4]
 8003e9c:	4413      	add	r3, r2
 8003e9e:	3304      	adds	r3, #4
 8003ea0:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003ea2:	68fb      	ldr	r3, [r7, #12]
 8003ea4:	2201      	movs	r2, #1
 8003ea6:	705a      	strb	r2, [r3, #1]
 8003ea8:	e00d      	b.n	8003ec6 <HAL_PCD_EP_SetStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8003eaa:	78fa      	ldrb	r2, [r7, #3]
 8003eac:	4613      	mov	r3, r2
 8003eae:	00db      	lsls	r3, r3, #3
 8003eb0:	4413      	add	r3, r2
 8003eb2:	009b      	lsls	r3, r3, #2
 8003eb4:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003eb8:	687a      	ldr	r2, [r7, #4]
 8003eba:	4413      	add	r3, r2
 8003ebc:	3304      	adds	r3, #4
 8003ebe:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003ec0:	68fb      	ldr	r3, [r7, #12]
 8003ec2:	2200      	movs	r2, #0
 8003ec4:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 8003ec6:	68fb      	ldr	r3, [r7, #12]
 8003ec8:	2201      	movs	r2, #1
 8003eca:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003ecc:	78fb      	ldrb	r3, [r7, #3]
 8003ece:	f003 030f 	and.w	r3, r3, #15
 8003ed2:	b2da      	uxtb	r2, r3
 8003ed4:	68fb      	ldr	r3, [r7, #12]
 8003ed6:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8003ed8:	687b      	ldr	r3, [r7, #4]
 8003eda:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003ede:	2b01      	cmp	r3, #1
 8003ee0:	d101      	bne.n	8003ee6 <HAL_PCD_EP_SetStall+0x82>
 8003ee2:	2302      	movs	r3, #2
 8003ee4:	e01d      	b.n	8003f22 <HAL_PCD_EP_SetStall+0xbe>
 8003ee6:	687b      	ldr	r3, [r7, #4]
 8003ee8:	2201      	movs	r2, #1
 8003eea:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  (void)USB_EPSetStall(hpcd->Instance, ep);
 8003eee:	687b      	ldr	r3, [r7, #4]
 8003ef0:	681b      	ldr	r3, [r3, #0]
 8003ef2:	68f9      	ldr	r1, [r7, #12]
 8003ef4:	4618      	mov	r0, r3
 8003ef6:	f002 fa6f 	bl	80063d8 <USB_EPSetStall>

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8003efa:	78fb      	ldrb	r3, [r7, #3]
 8003efc:	f003 030f 	and.w	r3, r3, #15
 8003f00:	2b00      	cmp	r3, #0
 8003f02:	d109      	bne.n	8003f18 <HAL_PCD_EP_SetStall+0xb4>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8003f04:	687b      	ldr	r3, [r7, #4]
 8003f06:	6818      	ldr	r0, [r3, #0]
 8003f08:	687b      	ldr	r3, [r7, #4]
 8003f0a:	7999      	ldrb	r1, [r3, #6]
 8003f0c:	687b      	ldr	r3, [r7, #4]
 8003f0e:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8003f12:	461a      	mov	r2, r3
 8003f14:	f002 fc60 	bl	80067d8 <USB_EP0_OutStart>
  }

  __HAL_UNLOCK(hpcd);
 8003f18:	687b      	ldr	r3, [r7, #4]
 8003f1a:	2200      	movs	r2, #0
 8003f1c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8003f20:	2300      	movs	r3, #0
}
 8003f22:	4618      	mov	r0, r3
 8003f24:	3710      	adds	r7, #16
 8003f26:	46bd      	mov	sp, r7
 8003f28:	bd80      	pop	{r7, pc}

08003f2a <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003f2a:	b580      	push	{r7, lr}
 8003f2c:	b084      	sub	sp, #16
 8003f2e:	af00      	add	r7, sp, #0
 8003f30:	6078      	str	r0, [r7, #4]
 8003f32:	460b      	mov	r3, r1
 8003f34:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8003f36:	78fb      	ldrb	r3, [r7, #3]
 8003f38:	f003 030f 	and.w	r3, r3, #15
 8003f3c:	687a      	ldr	r2, [r7, #4]
 8003f3e:	7912      	ldrb	r2, [r2, #4]
 8003f40:	4293      	cmp	r3, r2
 8003f42:	d901      	bls.n	8003f48 <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
 8003f44:	2301      	movs	r3, #1
 8003f46:	e042      	b.n	8003fce <HAL_PCD_EP_ClrStall+0xa4>
  }

  if ((0x80U & ep_addr) == 0x80U)
 8003f48:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003f4c:	2b00      	cmp	r3, #0
 8003f4e:	da0f      	bge.n	8003f70 <HAL_PCD_EP_ClrStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003f50:	78fb      	ldrb	r3, [r7, #3]
 8003f52:	f003 020f 	and.w	r2, r3, #15
 8003f56:	4613      	mov	r3, r2
 8003f58:	00db      	lsls	r3, r3, #3
 8003f5a:	4413      	add	r3, r2
 8003f5c:	009b      	lsls	r3, r3, #2
 8003f5e:	3310      	adds	r3, #16
 8003f60:	687a      	ldr	r2, [r7, #4]
 8003f62:	4413      	add	r3, r2
 8003f64:	3304      	adds	r3, #4
 8003f66:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003f68:	68fb      	ldr	r3, [r7, #12]
 8003f6a:	2201      	movs	r2, #1
 8003f6c:	705a      	strb	r2, [r3, #1]
 8003f6e:	e00f      	b.n	8003f90 <HAL_PCD_EP_ClrStall+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003f70:	78fb      	ldrb	r3, [r7, #3]
 8003f72:	f003 020f 	and.w	r2, r3, #15
 8003f76:	4613      	mov	r3, r2
 8003f78:	00db      	lsls	r3, r3, #3
 8003f7a:	4413      	add	r3, r2
 8003f7c:	009b      	lsls	r3, r3, #2
 8003f7e:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8003f82:	687a      	ldr	r2, [r7, #4]
 8003f84:	4413      	add	r3, r2
 8003f86:	3304      	adds	r3, #4
 8003f88:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003f8a:	68fb      	ldr	r3, [r7, #12]
 8003f8c:	2200      	movs	r2, #0
 8003f8e:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 8003f90:	68fb      	ldr	r3, [r7, #12]
 8003f92:	2200      	movs	r2, #0
 8003f94:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003f96:	78fb      	ldrb	r3, [r7, #3]
 8003f98:	f003 030f 	and.w	r3, r3, #15
 8003f9c:	b2da      	uxtb	r2, r3
 8003f9e:	68fb      	ldr	r3, [r7, #12]
 8003fa0:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8003fa2:	687b      	ldr	r3, [r7, #4]
 8003fa4:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8003fa8:	2b01      	cmp	r3, #1
 8003faa:	d101      	bne.n	8003fb0 <HAL_PCD_EP_ClrStall+0x86>
 8003fac:	2302      	movs	r3, #2
 8003fae:	e00e      	b.n	8003fce <HAL_PCD_EP_ClrStall+0xa4>
 8003fb0:	687b      	ldr	r3, [r7, #4]
 8003fb2:	2201      	movs	r2, #1
 8003fb4:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8003fb8:	687b      	ldr	r3, [r7, #4]
 8003fba:	681b      	ldr	r3, [r3, #0]
 8003fbc:	68f9      	ldr	r1, [r7, #12]
 8003fbe:	4618      	mov	r0, r3
 8003fc0:	f002 fa78 	bl	80064b4 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8003fc4:	687b      	ldr	r3, [r7, #4]
 8003fc6:	2200      	movs	r2, #0
 8003fc8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8003fcc:	2300      	movs	r3, #0
}
 8003fce:	4618      	mov	r0, r3
 8003fd0:	3710      	adds	r7, #16
 8003fd2:	46bd      	mov	sp, r7
 8003fd4:	bd80      	pop	{r7, pc}

08003fd6 <HAL_PCD_EP_Abort>:
   * @param  hpcd PCD handle
   * @param  ep_addr endpoint address
   * @retval HAL status
   */
HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003fd6:	b580      	push	{r7, lr}
 8003fd8:	b084      	sub	sp, #16
 8003fda:	af00      	add	r7, sp, #0
 8003fdc:	6078      	str	r0, [r7, #4]
 8003fde:	460b      	mov	r3, r1
 8003fe0:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef ret;
  PCD_EPTypeDef *ep;

  if ((0x80U & ep_addr) == 0x80U)
 8003fe2:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003fe6:	2b00      	cmp	r3, #0
 8003fe8:	da0c      	bge.n	8004004 <HAL_PCD_EP_Abort+0x2e>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003fea:	78fb      	ldrb	r3, [r7, #3]
 8003fec:	f003 020f 	and.w	r2, r3, #15
 8003ff0:	4613      	mov	r3, r2
 8003ff2:	00db      	lsls	r3, r3, #3
 8003ff4:	4413      	add	r3, r2
 8003ff6:	009b      	lsls	r3, r3, #2
 8003ff8:	3310      	adds	r3, #16
 8003ffa:	687a      	ldr	r2, [r7, #4]
 8003ffc:	4413      	add	r3, r2
 8003ffe:	3304      	adds	r3, #4
 8004000:	60fb      	str	r3, [r7, #12]
 8004002:	e00c      	b.n	800401e <HAL_PCD_EP_Abort+0x48>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8004004:	78fb      	ldrb	r3, [r7, #3]
 8004006:	f003 020f 	and.w	r2, r3, #15
 800400a:	4613      	mov	r3, r2
 800400c:	00db      	lsls	r3, r3, #3
 800400e:	4413      	add	r3, r2
 8004010:	009b      	lsls	r3, r3, #2
 8004012:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8004016:	687a      	ldr	r2, [r7, #4]
 8004018:	4413      	add	r3, r2
 800401a:	3304      	adds	r3, #4
 800401c:	60fb      	str	r3, [r7, #12]
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800401e:	687b      	ldr	r3, [r7, #4]
 8004020:	681b      	ldr	r3, [r3, #0]
 8004022:	68f9      	ldr	r1, [r7, #12]
 8004024:	4618      	mov	r0, r3
 8004026:	f002 f897 	bl	8006158 <USB_EPStopXfer>
 800402a:	4603      	mov	r3, r0
 800402c:	72fb      	strb	r3, [r7, #11]

  return ret;
 800402e:	7afb      	ldrb	r3, [r7, #11]
}
 8004030:	4618      	mov	r0, r3
 8004032:	3710      	adds	r7, #16
 8004034:	46bd      	mov	sp, r7
 8004036:	bd80      	pop	{r7, pc}

08004038 <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8004038:	b580      	push	{r7, lr}
 800403a:	b08a      	sub	sp, #40	@ 0x28
 800403c:	af02      	add	r7, sp, #8
 800403e:	6078      	str	r0, [r7, #4]
 8004040:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8004042:	687b      	ldr	r3, [r7, #4]
 8004044:	681b      	ldr	r3, [r3, #0]
 8004046:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004048:	697b      	ldr	r3, [r7, #20]
 800404a:	613b      	str	r3, [r7, #16]
  USB_OTG_EPTypeDef *ep;
  uint32_t len;
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];
 800404c:	683a      	ldr	r2, [r7, #0]
 800404e:	4613      	mov	r3, r2
 8004050:	00db      	lsls	r3, r3, #3
 8004052:	4413      	add	r3, r2
 8004054:	009b      	lsls	r3, r3, #2
 8004056:	3310      	adds	r3, #16
 8004058:	687a      	ldr	r2, [r7, #4]
 800405a:	4413      	add	r3, r2
 800405c:	3304      	adds	r3, #4
 800405e:	60fb      	str	r3, [r7, #12]

  if (ep->xfer_count > ep->xfer_len)
 8004060:	68fb      	ldr	r3, [r7, #12]
 8004062:	695a      	ldr	r2, [r3, #20]
 8004064:	68fb      	ldr	r3, [r7, #12]
 8004066:	691b      	ldr	r3, [r3, #16]
 8004068:	429a      	cmp	r2, r3
 800406a:	d901      	bls.n	8004070 <PCD_WriteEmptyTxFifo+0x38>
  {
    return HAL_ERROR;
 800406c:	2301      	movs	r3, #1
 800406e:	e06b      	b.n	8004148 <PCD_WriteEmptyTxFifo+0x110>
  }

  len = ep->xfer_len - ep->xfer_count;
 8004070:	68fb      	ldr	r3, [r7, #12]
 8004072:	691a      	ldr	r2, [r3, #16]
 8004074:	68fb      	ldr	r3, [r7, #12]
 8004076:	695b      	ldr	r3, [r3, #20]
 8004078:	1ad3      	subs	r3, r2, r3
 800407a:	61fb      	str	r3, [r7, #28]

  if (len > ep->maxpacket)
 800407c:	68fb      	ldr	r3, [r7, #12]
 800407e:	689b      	ldr	r3, [r3, #8]
 8004080:	69fa      	ldr	r2, [r7, #28]
 8004082:	429a      	cmp	r2, r3
 8004084:	d902      	bls.n	800408c <PCD_WriteEmptyTxFifo+0x54>
  {
    len = ep->maxpacket;
 8004086:	68fb      	ldr	r3, [r7, #12]
 8004088:	689b      	ldr	r3, [r3, #8]
 800408a:	61fb      	str	r3, [r7, #28]
  }

  len32b = (len + 3U) / 4U;
 800408c:	69fb      	ldr	r3, [r7, #28]
 800408e:	3303      	adds	r3, #3
 8004090:	089b      	lsrs	r3, r3, #2
 8004092:	61bb      	str	r3, [r7, #24]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8004094:	e02a      	b.n	80040ec <PCD_WriteEmptyTxFifo+0xb4>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8004096:	68fb      	ldr	r3, [r7, #12]
 8004098:	691a      	ldr	r2, [r3, #16]
 800409a:	68fb      	ldr	r3, [r7, #12]
 800409c:	695b      	ldr	r3, [r3, #20]
 800409e:	1ad3      	subs	r3, r2, r3
 80040a0:	61fb      	str	r3, [r7, #28]

    if (len > ep->maxpacket)
 80040a2:	68fb      	ldr	r3, [r7, #12]
 80040a4:	689b      	ldr	r3, [r3, #8]
 80040a6:	69fa      	ldr	r2, [r7, #28]
 80040a8:	429a      	cmp	r2, r3
 80040aa:	d902      	bls.n	80040b2 <PCD_WriteEmptyTxFifo+0x7a>
    {
      len = ep->maxpacket;
 80040ac:	68fb      	ldr	r3, [r7, #12]
 80040ae:	689b      	ldr	r3, [r3, #8]
 80040b0:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
 80040b2:	69fb      	ldr	r3, [r7, #28]
 80040b4:	3303      	adds	r3, #3
 80040b6:	089b      	lsrs	r3, r3, #2
 80040b8:	61bb      	str	r3, [r7, #24]

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 80040ba:	68fb      	ldr	r3, [r7, #12]
 80040bc:	68d9      	ldr	r1, [r3, #12]
 80040be:	683b      	ldr	r3, [r7, #0]
 80040c0:	b2da      	uxtb	r2, r3
 80040c2:	69fb      	ldr	r3, [r7, #28]
 80040c4:	b298      	uxth	r0, r3
                          (uint8_t)hpcd->Init.dma_enable);
 80040c6:	687b      	ldr	r3, [r7, #4]
 80040c8:	799b      	ldrb	r3, [r3, #6]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 80040ca:	9300      	str	r3, [sp, #0]
 80040cc:	4603      	mov	r3, r0
 80040ce:	6978      	ldr	r0, [r7, #20]
 80040d0:	f002 f8ec 	bl	80062ac <USB_WritePacket>

    ep->xfer_buff  += len;
 80040d4:	68fb      	ldr	r3, [r7, #12]
 80040d6:	68da      	ldr	r2, [r3, #12]
 80040d8:	69fb      	ldr	r3, [r7, #28]
 80040da:	441a      	add	r2, r3
 80040dc:	68fb      	ldr	r3, [r7, #12]
 80040de:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
 80040e0:	68fb      	ldr	r3, [r7, #12]
 80040e2:	695a      	ldr	r2, [r3, #20]
 80040e4:	69fb      	ldr	r3, [r7, #28]
 80040e6:	441a      	add	r2, r3
 80040e8:	68fb      	ldr	r3, [r7, #12]
 80040ea:	615a      	str	r2, [r3, #20]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80040ec:	683b      	ldr	r3, [r7, #0]
 80040ee:	015a      	lsls	r2, r3, #5
 80040f0:	693b      	ldr	r3, [r7, #16]
 80040f2:	4413      	add	r3, r2
 80040f4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80040f8:	699b      	ldr	r3, [r3, #24]
 80040fa:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 80040fc:	69ba      	ldr	r2, [r7, #24]
 80040fe:	429a      	cmp	r2, r3
 8004100:	d809      	bhi.n	8004116 <PCD_WriteEmptyTxFifo+0xde>
 8004102:	68fb      	ldr	r3, [r7, #12]
 8004104:	695a      	ldr	r2, [r3, #20]
 8004106:	68fb      	ldr	r3, [r7, #12]
 8004108:	691b      	ldr	r3, [r3, #16]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800410a:	429a      	cmp	r2, r3
 800410c:	d203      	bcs.n	8004116 <PCD_WriteEmptyTxFifo+0xde>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 800410e:	68fb      	ldr	r3, [r7, #12]
 8004110:	691b      	ldr	r3, [r3, #16]
 8004112:	2b00      	cmp	r3, #0
 8004114:	d1bf      	bne.n	8004096 <PCD_WriteEmptyTxFifo+0x5e>
  }

  if (ep->xfer_len <= ep->xfer_count)
 8004116:	68fb      	ldr	r3, [r7, #12]
 8004118:	691a      	ldr	r2, [r3, #16]
 800411a:	68fb      	ldr	r3, [r7, #12]
 800411c:	695b      	ldr	r3, [r3, #20]
 800411e:	429a      	cmp	r2, r3
 8004120:	d811      	bhi.n	8004146 <PCD_WriteEmptyTxFifo+0x10e>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8004122:	683b      	ldr	r3, [r7, #0]
 8004124:	f003 030f 	and.w	r3, r3, #15
 8004128:	2201      	movs	r2, #1
 800412a:	fa02 f303 	lsl.w	r3, r2, r3
 800412e:	60bb      	str	r3, [r7, #8]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8004130:	693b      	ldr	r3, [r7, #16]
 8004132:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8004136:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8004138:	68bb      	ldr	r3, [r7, #8]
 800413a:	43db      	mvns	r3, r3
 800413c:	6939      	ldr	r1, [r7, #16]
 800413e:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8004142:	4013      	ands	r3, r2
 8004144:	634b      	str	r3, [r1, #52]	@ 0x34
  }

  return HAL_OK;
 8004146:	2300      	movs	r3, #0
}
 8004148:	4618      	mov	r0, r3
 800414a:	3720      	adds	r7, #32
 800414c:	46bd      	mov	sp, r7
 800414e:	bd80      	pop	{r7, pc}

08004150 <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8004150:	b580      	push	{r7, lr}
 8004152:	b088      	sub	sp, #32
 8004154:	af00      	add	r7, sp, #0
 8004156:	6078      	str	r0, [r7, #4]
 8004158:	6039      	str	r1, [r7, #0]
  USB_OTG_EPTypeDef *ep;
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800415a:	687b      	ldr	r3, [r7, #4]
 800415c:	681b      	ldr	r3, [r3, #0]
 800415e:	61fb      	str	r3, [r7, #28]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004160:	69fb      	ldr	r3, [r7, #28]
 8004162:	61bb      	str	r3, [r7, #24]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8004164:	69fb      	ldr	r3, [r7, #28]
 8004166:	333c      	adds	r3, #60	@ 0x3c
 8004168:	3304      	adds	r3, #4
 800416a:	681b      	ldr	r3, [r3, #0]
 800416c:	617b      	str	r3, [r7, #20]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800416e:	683b      	ldr	r3, [r7, #0]
 8004170:	015a      	lsls	r2, r3, #5
 8004172:	69bb      	ldr	r3, [r7, #24]
 8004174:	4413      	add	r3, r2
 8004176:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800417a:	689b      	ldr	r3, [r3, #8]
 800417c:	613b      	str	r3, [r7, #16]

  if (hpcd->Init.dma_enable == 1U)
 800417e:	687b      	ldr	r3, [r7, #4]
 8004180:	799b      	ldrb	r3, [r3, #6]
 8004182:	2b01      	cmp	r3, #1
 8004184:	d17b      	bne.n	800427e <PCD_EP_OutXfrComplete_int+0x12e>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 8004186:	693b      	ldr	r3, [r7, #16]
 8004188:	f003 0308 	and.w	r3, r3, #8
 800418c:	2b00      	cmp	r3, #0
 800418e:	d015      	beq.n	80041bc <PCD_EP_OutXfrComplete_int+0x6c>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8004190:	697b      	ldr	r3, [r7, #20]
 8004192:	4a61      	ldr	r2, [pc, #388]	@ (8004318 <PCD_EP_OutXfrComplete_int+0x1c8>)
 8004194:	4293      	cmp	r3, r2
 8004196:	f240 80b9 	bls.w	800430c <PCD_EP_OutXfrComplete_int+0x1bc>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 800419a:	693b      	ldr	r3, [r7, #16]
 800419c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80041a0:	2b00      	cmp	r3, #0
 80041a2:	f000 80b3 	beq.w	800430c <PCD_EP_OutXfrComplete_int+0x1bc>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80041a6:	683b      	ldr	r3, [r7, #0]
 80041a8:	015a      	lsls	r2, r3, #5
 80041aa:	69bb      	ldr	r3, [r7, #24]
 80041ac:	4413      	add	r3, r2
 80041ae:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80041b2:	461a      	mov	r2, r3
 80041b4:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80041b8:	6093      	str	r3, [r2, #8]
 80041ba:	e0a7      	b.n	800430c <PCD_EP_OutXfrComplete_int+0x1bc>
      }
    }
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 80041bc:	693b      	ldr	r3, [r7, #16]
 80041be:	f003 0320 	and.w	r3, r3, #32
 80041c2:	2b00      	cmp	r3, #0
 80041c4:	d009      	beq.n	80041da <PCD_EP_OutXfrComplete_int+0x8a>
    {
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80041c6:	683b      	ldr	r3, [r7, #0]
 80041c8:	015a      	lsls	r2, r3, #5
 80041ca:	69bb      	ldr	r3, [r7, #24]
 80041cc:	4413      	add	r3, r2
 80041ce:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80041d2:	461a      	mov	r2, r3
 80041d4:	2320      	movs	r3, #32
 80041d6:	6093      	str	r3, [r2, #8]
 80041d8:	e098      	b.n	800430c <PCD_EP_OutXfrComplete_int+0x1bc>
    }
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 80041da:	693b      	ldr	r3, [r7, #16]
 80041dc:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 80041e0:	2b00      	cmp	r3, #0
 80041e2:	f040 8093 	bne.w	800430c <PCD_EP_OutXfrComplete_int+0x1bc>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80041e6:	697b      	ldr	r3, [r7, #20]
 80041e8:	4a4b      	ldr	r2, [pc, #300]	@ (8004318 <PCD_EP_OutXfrComplete_int+0x1c8>)
 80041ea:	4293      	cmp	r3, r2
 80041ec:	d90f      	bls.n	800420e <PCD_EP_OutXfrComplete_int+0xbe>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 80041ee:	693b      	ldr	r3, [r7, #16]
 80041f0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80041f4:	2b00      	cmp	r3, #0
 80041f6:	d00a      	beq.n	800420e <PCD_EP_OutXfrComplete_int+0xbe>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80041f8:	683b      	ldr	r3, [r7, #0]
 80041fa:	015a      	lsls	r2, r3, #5
 80041fc:	69bb      	ldr	r3, [r7, #24]
 80041fe:	4413      	add	r3, r2
 8004200:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004204:	461a      	mov	r2, r3
 8004206:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800420a:	6093      	str	r3, [r2, #8]
 800420c:	e07e      	b.n	800430c <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        ep = &hpcd->OUT_ep[epnum];
 800420e:	683a      	ldr	r2, [r7, #0]
 8004210:	4613      	mov	r3, r2
 8004212:	00db      	lsls	r3, r3, #3
 8004214:	4413      	add	r3, r2
 8004216:	009b      	lsls	r3, r3, #2
 8004218:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800421c:	687a      	ldr	r2, [r7, #4]
 800421e:	4413      	add	r3, r2
 8004220:	3304      	adds	r3, #4
 8004222:	60fb      	str	r3, [r7, #12]

        /* out data packet received over EP */
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 8004224:	68fb      	ldr	r3, [r7, #12]
 8004226:	6a1a      	ldr	r2, [r3, #32]
 8004228:	683b      	ldr	r3, [r7, #0]
 800422a:	0159      	lsls	r1, r3, #5
 800422c:	69bb      	ldr	r3, [r7, #24]
 800422e:	440b      	add	r3, r1
 8004230:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8004234:	691b      	ldr	r3, [r3, #16]
 8004236:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800423a:	1ad2      	subs	r2, r2, r3
 800423c:	68fb      	ldr	r3, [r7, #12]
 800423e:	615a      	str	r2, [r3, #20]

        if (epnum == 0U)
 8004240:	683b      	ldr	r3, [r7, #0]
 8004242:	2b00      	cmp	r3, #0
 8004244:	d114      	bne.n	8004270 <PCD_EP_OutXfrComplete_int+0x120>
        {
          if (ep->xfer_len == 0U)
 8004246:	68fb      	ldr	r3, [r7, #12]
 8004248:	691b      	ldr	r3, [r3, #16]
 800424a:	2b00      	cmp	r3, #0
 800424c:	d109      	bne.n	8004262 <PCD_EP_OutXfrComplete_int+0x112>
          {
            /* this is ZLP, so prepare EP0 for next setup */
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800424e:	687b      	ldr	r3, [r7, #4]
 8004250:	6818      	ldr	r0, [r3, #0]
 8004252:	687b      	ldr	r3, [r7, #4]
 8004254:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8004258:	461a      	mov	r2, r3
 800425a:	2101      	movs	r1, #1
 800425c:	f002 fabc 	bl	80067d8 <USB_EP0_OutStart>
 8004260:	e006      	b.n	8004270 <PCD_EP_OutXfrComplete_int+0x120>
          }
          else
          {
            ep->xfer_buff += ep->xfer_count;
 8004262:	68fb      	ldr	r3, [r7, #12]
 8004264:	68da      	ldr	r2, [r3, #12]
 8004266:	68fb      	ldr	r3, [r7, #12]
 8004268:	695b      	ldr	r3, [r3, #20]
 800426a:	441a      	add	r2, r3
 800426c:	68fb      	ldr	r3, [r7, #12]
 800426e:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8004270:	683b      	ldr	r3, [r7, #0]
 8004272:	b2db      	uxtb	r3, r3
 8004274:	4619      	mov	r1, r3
 8004276:	6878      	ldr	r0, [r7, #4]
 8004278:	f023 fd30 	bl	8027cdc <HAL_PCD_DataOutStageCallback>
 800427c:	e046      	b.n	800430c <PCD_EP_OutXfrComplete_int+0x1bc>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 800427e:	697b      	ldr	r3, [r7, #20]
 8004280:	4a26      	ldr	r2, [pc, #152]	@ (800431c <PCD_EP_OutXfrComplete_int+0x1cc>)
 8004282:	4293      	cmp	r3, r2
 8004284:	d124      	bne.n	80042d0 <PCD_EP_OutXfrComplete_int+0x180>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 8004286:	693b      	ldr	r3, [r7, #16]
 8004288:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 800428c:	2b00      	cmp	r3, #0
 800428e:	d00a      	beq.n	80042a6 <PCD_EP_OutXfrComplete_int+0x156>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8004290:	683b      	ldr	r3, [r7, #0]
 8004292:	015a      	lsls	r2, r3, #5
 8004294:	69bb      	ldr	r3, [r7, #24]
 8004296:	4413      	add	r3, r2
 8004298:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800429c:	461a      	mov	r2, r3
 800429e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80042a2:	6093      	str	r3, [r2, #8]
 80042a4:	e032      	b.n	800430c <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 80042a6:	693b      	ldr	r3, [r7, #16]
 80042a8:	f003 0320 	and.w	r3, r3, #32
 80042ac:	2b00      	cmp	r3, #0
 80042ae:	d008      	beq.n	80042c2 <PCD_EP_OutXfrComplete_int+0x172>
        {
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80042b0:	683b      	ldr	r3, [r7, #0]
 80042b2:	015a      	lsls	r2, r3, #5
 80042b4:	69bb      	ldr	r3, [r7, #24]
 80042b6:	4413      	add	r3, r2
 80042b8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80042bc:	461a      	mov	r2, r3
 80042be:	2320      	movs	r3, #32
 80042c0:	6093      	str	r3, [r2, #8]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80042c2:	683b      	ldr	r3, [r7, #0]
 80042c4:	b2db      	uxtb	r3, r3
 80042c6:	4619      	mov	r1, r3
 80042c8:	6878      	ldr	r0, [r7, #4]
 80042ca:	f023 fd07 	bl	8027cdc <HAL_PCD_DataOutStageCallback>
 80042ce:	e01d      	b.n	800430c <PCD_EP_OutXfrComplete_int+0x1bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 80042d0:	683b      	ldr	r3, [r7, #0]
 80042d2:	2b00      	cmp	r3, #0
 80042d4:	d114      	bne.n	8004300 <PCD_EP_OutXfrComplete_int+0x1b0>
 80042d6:	6879      	ldr	r1, [r7, #4]
 80042d8:	683a      	ldr	r2, [r7, #0]
 80042da:	4613      	mov	r3, r2
 80042dc:	00db      	lsls	r3, r3, #3
 80042de:	4413      	add	r3, r2
 80042e0:	009b      	lsls	r3, r3, #2
 80042e2:	440b      	add	r3, r1
 80042e4:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 80042e8:	681b      	ldr	r3, [r3, #0]
 80042ea:	2b00      	cmp	r3, #0
 80042ec:	d108      	bne.n	8004300 <PCD_EP_OutXfrComplete_int+0x1b0>
      {
        /* this is ZLP, so prepare EP0 for next setup */
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 80042ee:	687b      	ldr	r3, [r7, #4]
 80042f0:	6818      	ldr	r0, [r3, #0]
 80042f2:	687b      	ldr	r3, [r7, #4]
 80042f4:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 80042f8:	461a      	mov	r2, r3
 80042fa:	2100      	movs	r1, #0
 80042fc:	f002 fa6c 	bl	80067d8 <USB_EP0_OutStart>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8004300:	683b      	ldr	r3, [r7, #0]
 8004302:	b2db      	uxtb	r3, r3
 8004304:	4619      	mov	r1, r3
 8004306:	6878      	ldr	r0, [r7, #4]
 8004308:	f023 fce8 	bl	8027cdc <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
 800430c:	2300      	movs	r3, #0
}
 800430e:	4618      	mov	r0, r3
 8004310:	3720      	adds	r7, #32
 8004312:	46bd      	mov	sp, r7
 8004314:	bd80      	pop	{r7, pc}
 8004316:	bf00      	nop
 8004318:	4f54300a 	.word	0x4f54300a
 800431c:	4f54310a 	.word	0x4f54310a

08004320 <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8004320:	b580      	push	{r7, lr}
 8004322:	b086      	sub	sp, #24
 8004324:	af00      	add	r7, sp, #0
 8004326:	6078      	str	r0, [r7, #4]
 8004328:	6039      	str	r1, [r7, #0]
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800432a:	687b      	ldr	r3, [r7, #4]
 800432c:	681b      	ldr	r3, [r3, #0]
 800432e:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004330:	697b      	ldr	r3, [r7, #20]
 8004332:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8004334:	697b      	ldr	r3, [r7, #20]
 8004336:	333c      	adds	r3, #60	@ 0x3c
 8004338:	3304      	adds	r3, #4
 800433a:	681b      	ldr	r3, [r3, #0]
 800433c:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800433e:	683b      	ldr	r3, [r7, #0]
 8004340:	015a      	lsls	r2, r3, #5
 8004342:	693b      	ldr	r3, [r7, #16]
 8004344:	4413      	add	r3, r2
 8004346:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800434a:	689b      	ldr	r3, [r3, #8]
 800434c:	60bb      	str	r3, [r7, #8]

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800434e:	68fb      	ldr	r3, [r7, #12]
 8004350:	4a15      	ldr	r2, [pc, #84]	@ (80043a8 <PCD_EP_OutSetupPacket_int+0x88>)
 8004352:	4293      	cmp	r3, r2
 8004354:	d90e      	bls.n	8004374 <PCD_EP_OutSetupPacket_int+0x54>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 8004356:	68bb      	ldr	r3, [r7, #8]
 8004358:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800435c:	2b00      	cmp	r3, #0
 800435e:	d009      	beq.n	8004374 <PCD_EP_OutSetupPacket_int+0x54>
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8004360:	683b      	ldr	r3, [r7, #0]
 8004362:	015a      	lsls	r2, r3, #5
 8004364:	693b      	ldr	r3, [r7, #16]
 8004366:	4413      	add	r3, r2
 8004368:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800436c:	461a      	mov	r2, r3
 800436e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8004372:	6093      	str	r3, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 8004374:	6878      	ldr	r0, [r7, #4]
 8004376:	f023 fc9f 	bl	8027cb8 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 800437a:	68fb      	ldr	r3, [r7, #12]
 800437c:	4a0a      	ldr	r2, [pc, #40]	@ (80043a8 <PCD_EP_OutSetupPacket_int+0x88>)
 800437e:	4293      	cmp	r3, r2
 8004380:	d90c      	bls.n	800439c <PCD_EP_OutSetupPacket_int+0x7c>
 8004382:	687b      	ldr	r3, [r7, #4]
 8004384:	799b      	ldrb	r3, [r3, #6]
 8004386:	2b01      	cmp	r3, #1
 8004388:	d108      	bne.n	800439c <PCD_EP_OutSetupPacket_int+0x7c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800438a:	687b      	ldr	r3, [r7, #4]
 800438c:	6818      	ldr	r0, [r3, #0]
 800438e:	687b      	ldr	r3, [r7, #4]
 8004390:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8004394:	461a      	mov	r2, r3
 8004396:	2101      	movs	r1, #1
 8004398:	f002 fa1e 	bl	80067d8 <USB_EP0_OutStart>
  }

  return HAL_OK;
 800439c:	2300      	movs	r3, #0
}
 800439e:	4618      	mov	r0, r3
 80043a0:	3718      	adds	r7, #24
 80043a2:	46bd      	mov	sp, r7
 80043a4:	bd80      	pop	{r7, pc}
 80043a6:	bf00      	nop
 80043a8:	4f54300a 	.word	0x4f54300a

080043ac <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 80043ac:	b480      	push	{r7}
 80043ae:	b085      	sub	sp, #20
 80043b0:	af00      	add	r7, sp, #0
 80043b2:	6078      	str	r0, [r7, #4]
 80043b4:	460b      	mov	r3, r1
 80043b6:	70fb      	strb	r3, [r7, #3]
 80043b8:	4613      	mov	r3, r2
 80043ba:	803b      	strh	r3, [r7, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 80043bc:	687b      	ldr	r3, [r7, #4]
 80043be:	681b      	ldr	r3, [r3, #0]
 80043c0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80043c2:	60bb      	str	r3, [r7, #8]

  if (fifo == 0U)
 80043c4:	78fb      	ldrb	r3, [r7, #3]
 80043c6:	2b00      	cmp	r3, #0
 80043c8:	d107      	bne.n	80043da <HAL_PCDEx_SetTxFiFo+0x2e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 80043ca:	883b      	ldrh	r3, [r7, #0]
 80043cc:	0419      	lsls	r1, r3, #16
 80043ce:	687b      	ldr	r3, [r7, #4]
 80043d0:	681b      	ldr	r3, [r3, #0]
 80043d2:	68ba      	ldr	r2, [r7, #8]
 80043d4:	430a      	orrs	r2, r1
 80043d6:	629a      	str	r2, [r3, #40]	@ 0x28
 80043d8:	e028      	b.n	800442c <HAL_PCDEx_SetTxFiFo+0x80>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 80043da:	687b      	ldr	r3, [r7, #4]
 80043dc:	681b      	ldr	r3, [r3, #0]
 80043de:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80043e0:	0c1b      	lsrs	r3, r3, #16
 80043e2:	68ba      	ldr	r2, [r7, #8]
 80043e4:	4413      	add	r3, r2
 80043e6:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 80043e8:	2300      	movs	r3, #0
 80043ea:	73fb      	strb	r3, [r7, #15]
 80043ec:	e00d      	b.n	800440a <HAL_PCDEx_SetTxFiFo+0x5e>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80043ee:	687b      	ldr	r3, [r7, #4]
 80043f0:	681a      	ldr	r2, [r3, #0]
 80043f2:	7bfb      	ldrb	r3, [r7, #15]
 80043f4:	3340      	adds	r3, #64	@ 0x40
 80043f6:	009b      	lsls	r3, r3, #2
 80043f8:	4413      	add	r3, r2
 80043fa:	685b      	ldr	r3, [r3, #4]
 80043fc:	0c1b      	lsrs	r3, r3, #16
 80043fe:	68ba      	ldr	r2, [r7, #8]
 8004400:	4413      	add	r3, r2
 8004402:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 8004404:	7bfb      	ldrb	r3, [r7, #15]
 8004406:	3301      	adds	r3, #1
 8004408:	73fb      	strb	r3, [r7, #15]
 800440a:	7bfa      	ldrb	r2, [r7, #15]
 800440c:	78fb      	ldrb	r3, [r7, #3]
 800440e:	3b01      	subs	r3, #1
 8004410:	429a      	cmp	r2, r3
 8004412:	d3ec      	bcc.n	80043ee <HAL_PCDEx_SetTxFiFo+0x42>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8004414:	883b      	ldrh	r3, [r7, #0]
 8004416:	0418      	lsls	r0, r3, #16
 8004418:	687b      	ldr	r3, [r7, #4]
 800441a:	6819      	ldr	r1, [r3, #0]
 800441c:	78fb      	ldrb	r3, [r7, #3]
 800441e:	3b01      	subs	r3, #1
 8004420:	68ba      	ldr	r2, [r7, #8]
 8004422:	4302      	orrs	r2, r0
 8004424:	3340      	adds	r3, #64	@ 0x40
 8004426:	009b      	lsls	r3, r3, #2
 8004428:	440b      	add	r3, r1
 800442a:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
 800442c:	2300      	movs	r3, #0
}
 800442e:	4618      	mov	r0, r3
 8004430:	3714      	adds	r7, #20
 8004432:	46bd      	mov	sp, r7
 8004434:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004438:	4770      	bx	lr

0800443a <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 800443a:	b480      	push	{r7}
 800443c:	b083      	sub	sp, #12
 800443e:	af00      	add	r7, sp, #0
 8004440:	6078      	str	r0, [r7, #4]
 8004442:	460b      	mov	r3, r1
 8004444:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
 8004446:	687b      	ldr	r3, [r7, #4]
 8004448:	681b      	ldr	r3, [r3, #0]
 800444a:	887a      	ldrh	r2, [r7, #2]
 800444c:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_OK;
 800444e:	2300      	movs	r3, #0
}
 8004450:	4618      	mov	r0, r3
 8004452:	370c      	adds	r7, #12
 8004454:	46bd      	mov	sp, r7
 8004456:	f85d 7b04 	ldr.w	r7, [sp], #4
 800445a:	4770      	bx	lr

0800445c <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 800445c:	b480      	push	{r7}
 800445e:	b083      	sub	sp, #12
 8004460:	af00      	add	r7, sp, #0
 8004462:	6078      	str	r0, [r7, #4]
 8004464:	460b      	mov	r3, r1
 8004466:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 8004468:	bf00      	nop
 800446a:	370c      	adds	r7, #12
 800446c:	46bd      	mov	sp, r7
 800446e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004472:	4770      	bx	lr

08004474 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8004474:	b580      	push	{r7, lr}
 8004476:	b086      	sub	sp, #24
 8004478:	af00      	add	r7, sp, #0
 800447a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;
  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800447c:	687b      	ldr	r3, [r7, #4]
 800447e:	2b00      	cmp	r3, #0
 8004480:	d101      	bne.n	8004486 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8004482:	2301      	movs	r3, #1
 8004484:	e267      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8004486:	687b      	ldr	r3, [r7, #4]
 8004488:	681b      	ldr	r3, [r3, #0]
 800448a:	f003 0301 	and.w	r3, r3, #1
 800448e:	2b00      	cmp	r3, #0
 8004490:	d075      	beq.n	800457e <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || \
 8004492:	4b88      	ldr	r3, [pc, #544]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004494:	689b      	ldr	r3, [r3, #8]
 8004496:	f003 030c 	and.w	r3, r3, #12
 800449a:	2b04      	cmp	r3, #4
 800449c:	d00c      	beq.n	80044b8 <HAL_RCC_OscConfig+0x44>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800449e:	4b85      	ldr	r3, [pc, #532]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80044a0:	689b      	ldr	r3, [r3, #8]
 80044a2:	f003 030c 	and.w	r3, r3, #12
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || \
 80044a6:	2b08      	cmp	r3, #8
 80044a8:	d112      	bne.n	80044d0 <HAL_RCC_OscConfig+0x5c>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80044aa:	4b82      	ldr	r3, [pc, #520]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80044ac:	685b      	ldr	r3, [r3, #4]
 80044ae:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80044b2:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 80044b6:	d10b      	bne.n	80044d0 <HAL_RCC_OscConfig+0x5c>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80044b8:	4b7e      	ldr	r3, [pc, #504]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80044ba:	681b      	ldr	r3, [r3, #0]
 80044bc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80044c0:	2b00      	cmp	r3, #0
 80044c2:	d05b      	beq.n	800457c <HAL_RCC_OscConfig+0x108>
 80044c4:	687b      	ldr	r3, [r7, #4]
 80044c6:	685b      	ldr	r3, [r3, #4]
 80044c8:	2b00      	cmp	r3, #0
 80044ca:	d157      	bne.n	800457c <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 80044cc:	2301      	movs	r3, #1
 80044ce:	e242      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80044d0:	687b      	ldr	r3, [r7, #4]
 80044d2:	685b      	ldr	r3, [r3, #4]
 80044d4:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80044d8:	d106      	bne.n	80044e8 <HAL_RCC_OscConfig+0x74>
 80044da:	4b76      	ldr	r3, [pc, #472]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80044dc:	681b      	ldr	r3, [r3, #0]
 80044de:	4a75      	ldr	r2, [pc, #468]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80044e0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80044e4:	6013      	str	r3, [r2, #0]
 80044e6:	e01d      	b.n	8004524 <HAL_RCC_OscConfig+0xb0>
 80044e8:	687b      	ldr	r3, [r7, #4]
 80044ea:	685b      	ldr	r3, [r3, #4]
 80044ec:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 80044f0:	d10c      	bne.n	800450c <HAL_RCC_OscConfig+0x98>
 80044f2:	4b70      	ldr	r3, [pc, #448]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80044f4:	681b      	ldr	r3, [r3, #0]
 80044f6:	4a6f      	ldr	r2, [pc, #444]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80044f8:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 80044fc:	6013      	str	r3, [r2, #0]
 80044fe:	4b6d      	ldr	r3, [pc, #436]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004500:	681b      	ldr	r3, [r3, #0]
 8004502:	4a6c      	ldr	r2, [pc, #432]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004504:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8004508:	6013      	str	r3, [r2, #0]
 800450a:	e00b      	b.n	8004524 <HAL_RCC_OscConfig+0xb0>
 800450c:	4b69      	ldr	r3, [pc, #420]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 800450e:	681b      	ldr	r3, [r3, #0]
 8004510:	4a68      	ldr	r2, [pc, #416]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004512:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8004516:	6013      	str	r3, [r2, #0]
 8004518:	4b66      	ldr	r3, [pc, #408]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 800451a:	681b      	ldr	r3, [r3, #0]
 800451c:	4a65      	ldr	r2, [pc, #404]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 800451e:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8004522:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if ((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8004524:	687b      	ldr	r3, [r7, #4]
 8004526:	685b      	ldr	r3, [r3, #4]
 8004528:	2b00      	cmp	r3, #0
 800452a:	d013      	beq.n	8004554 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800452c:	f7fd fc1c 	bl	8001d68 <HAL_GetTick>
 8004530:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004532:	e008      	b.n	8004546 <HAL_RCC_OscConfig+0xd2>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004534:	f7fd fc18 	bl	8001d68 <HAL_GetTick>
 8004538:	4602      	mov	r2, r0
 800453a:	693b      	ldr	r3, [r7, #16]
 800453c:	1ad3      	subs	r3, r2, r3
 800453e:	2b64      	cmp	r3, #100	@ 0x64
 8004540:	d901      	bls.n	8004546 <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 8004542:	2303      	movs	r3, #3
 8004544:	e207      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004546:	4b5b      	ldr	r3, [pc, #364]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004548:	681b      	ldr	r3, [r3, #0]
 800454a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800454e:	2b00      	cmp	r3, #0
 8004550:	d0f0      	beq.n	8004534 <HAL_RCC_OscConfig+0xc0>
 8004552:	e014      	b.n	800457e <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004554:	f7fd fc08 	bl	8001d68 <HAL_GetTick>
 8004558:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800455a:	e008      	b.n	800456e <HAL_RCC_OscConfig+0xfa>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800455c:	f7fd fc04 	bl	8001d68 <HAL_GetTick>
 8004560:	4602      	mov	r2, r0
 8004562:	693b      	ldr	r3, [r7, #16]
 8004564:	1ad3      	subs	r3, r2, r3
 8004566:	2b64      	cmp	r3, #100	@ 0x64
 8004568:	d901      	bls.n	800456e <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800456a:	2303      	movs	r3, #3
 800456c:	e1f3      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800456e:	4b51      	ldr	r3, [pc, #324]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004570:	681b      	ldr	r3, [r3, #0]
 8004572:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8004576:	2b00      	cmp	r3, #0
 8004578:	d1f0      	bne.n	800455c <HAL_RCC_OscConfig+0xe8>
 800457a:	e000      	b.n	800457e <HAL_RCC_OscConfig+0x10a>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800457c:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800457e:	687b      	ldr	r3, [r7, #4]
 8004580:	681b      	ldr	r3, [r3, #0]
 8004582:	f003 0302 	and.w	r3, r3, #2
 8004586:	2b00      	cmp	r3, #0
 8004588:	d063      	beq.n	8004652 <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || \
 800458a:	4b4a      	ldr	r3, [pc, #296]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 800458c:	689b      	ldr	r3, [r3, #8]
 800458e:	f003 030c 	and.w	r3, r3, #12
 8004592:	2b00      	cmp	r3, #0
 8004594:	d00b      	beq.n	80045ae <HAL_RCC_OscConfig+0x13a>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8004596:	4b47      	ldr	r3, [pc, #284]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004598:	689b      	ldr	r3, [r3, #8]
 800459a:	f003 030c 	and.w	r3, r3, #12
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || \
 800459e:	2b08      	cmp	r3, #8
 80045a0:	d11c      	bne.n	80045dc <HAL_RCC_OscConfig+0x168>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80045a2:	4b44      	ldr	r3, [pc, #272]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80045a4:	685b      	ldr	r3, [r3, #4]
 80045a6:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80045aa:	2b00      	cmp	r3, #0
 80045ac:	d116      	bne.n	80045dc <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80045ae:	4b41      	ldr	r3, [pc, #260]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80045b0:	681b      	ldr	r3, [r3, #0]
 80045b2:	f003 0302 	and.w	r3, r3, #2
 80045b6:	2b00      	cmp	r3, #0
 80045b8:	d005      	beq.n	80045c6 <HAL_RCC_OscConfig+0x152>
 80045ba:	687b      	ldr	r3, [r7, #4]
 80045bc:	68db      	ldr	r3, [r3, #12]
 80045be:	2b01      	cmp	r3, #1
 80045c0:	d001      	beq.n	80045c6 <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 80045c2:	2301      	movs	r3, #1
 80045c4:	e1c7      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80045c6:	4b3b      	ldr	r3, [pc, #236]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80045c8:	681b      	ldr	r3, [r3, #0]
 80045ca:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 80045ce:	687b      	ldr	r3, [r7, #4]
 80045d0:	691b      	ldr	r3, [r3, #16]
 80045d2:	00db      	lsls	r3, r3, #3
 80045d4:	4937      	ldr	r1, [pc, #220]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 80045d6:	4313      	orrs	r3, r2
 80045d8:	600b      	str	r3, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80045da:	e03a      	b.n	8004652 <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 80045dc:	687b      	ldr	r3, [r7, #4]
 80045de:	68db      	ldr	r3, [r3, #12]
 80045e0:	2b00      	cmp	r3, #0
 80045e2:	d020      	beq.n	8004626 <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80045e4:	4b34      	ldr	r3, [pc, #208]	@ (80046b8 <HAL_RCC_OscConfig+0x244>)
 80045e6:	2201      	movs	r2, #1
 80045e8:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80045ea:	f7fd fbbd 	bl	8001d68 <HAL_GetTick>
 80045ee:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80045f0:	e008      	b.n	8004604 <HAL_RCC_OscConfig+0x190>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80045f2:	f7fd fbb9 	bl	8001d68 <HAL_GetTick>
 80045f6:	4602      	mov	r2, r0
 80045f8:	693b      	ldr	r3, [r7, #16]
 80045fa:	1ad3      	subs	r3, r2, r3
 80045fc:	2b02      	cmp	r3, #2
 80045fe:	d901      	bls.n	8004604 <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 8004600:	2303      	movs	r3, #3
 8004602:	e1a8      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004604:	4b2b      	ldr	r3, [pc, #172]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004606:	681b      	ldr	r3, [r3, #0]
 8004608:	f003 0302 	and.w	r3, r3, #2
 800460c:	2b00      	cmp	r3, #0
 800460e:	d0f0      	beq.n	80045f2 <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004610:	4b28      	ldr	r3, [pc, #160]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004612:	681b      	ldr	r3, [r3, #0]
 8004614:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 8004618:	687b      	ldr	r3, [r7, #4]
 800461a:	691b      	ldr	r3, [r3, #16]
 800461c:	00db      	lsls	r3, r3, #3
 800461e:	4925      	ldr	r1, [pc, #148]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004620:	4313      	orrs	r3, r2
 8004622:	600b      	str	r3, [r1, #0]
 8004624:	e015      	b.n	8004652 <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8004626:	4b24      	ldr	r3, [pc, #144]	@ (80046b8 <HAL_RCC_OscConfig+0x244>)
 8004628:	2200      	movs	r2, #0
 800462a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800462c:	f7fd fb9c 	bl	8001d68 <HAL_GetTick>
 8004630:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8004632:	e008      	b.n	8004646 <HAL_RCC_OscConfig+0x1d2>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004634:	f7fd fb98 	bl	8001d68 <HAL_GetTick>
 8004638:	4602      	mov	r2, r0
 800463a:	693b      	ldr	r3, [r7, #16]
 800463c:	1ad3      	subs	r3, r2, r3
 800463e:	2b02      	cmp	r3, #2
 8004640:	d901      	bls.n	8004646 <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 8004642:	2303      	movs	r3, #3
 8004644:	e187      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8004646:	4b1b      	ldr	r3, [pc, #108]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004648:	681b      	ldr	r3, [r3, #0]
 800464a:	f003 0302 	and.w	r3, r3, #2
 800464e:	2b00      	cmp	r3, #0
 8004650:	d1f0      	bne.n	8004634 <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004652:	687b      	ldr	r3, [r7, #4]
 8004654:	681b      	ldr	r3, [r3, #0]
 8004656:	f003 0308 	and.w	r3, r3, #8
 800465a:	2b00      	cmp	r3, #0
 800465c:	d036      	beq.n	80046cc <HAL_RCC_OscConfig+0x258>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 800465e:	687b      	ldr	r3, [r7, #4]
 8004660:	695b      	ldr	r3, [r3, #20]
 8004662:	2b00      	cmp	r3, #0
 8004664:	d016      	beq.n	8004694 <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8004666:	4b15      	ldr	r3, [pc, #84]	@ (80046bc <HAL_RCC_OscConfig+0x248>)
 8004668:	2201      	movs	r2, #1
 800466a:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800466c:	f7fd fb7c 	bl	8001d68 <HAL_GetTick>
 8004670:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8004672:	e008      	b.n	8004686 <HAL_RCC_OscConfig+0x212>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8004674:	f7fd fb78 	bl	8001d68 <HAL_GetTick>
 8004678:	4602      	mov	r2, r0
 800467a:	693b      	ldr	r3, [r7, #16]
 800467c:	1ad3      	subs	r3, r2, r3
 800467e:	2b02      	cmp	r3, #2
 8004680:	d901      	bls.n	8004686 <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 8004682:	2303      	movs	r3, #3
 8004684:	e167      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8004686:	4b0b      	ldr	r3, [pc, #44]	@ (80046b4 <HAL_RCC_OscConfig+0x240>)
 8004688:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800468a:	f003 0302 	and.w	r3, r3, #2
 800468e:	2b00      	cmp	r3, #0
 8004690:	d0f0      	beq.n	8004674 <HAL_RCC_OscConfig+0x200>
 8004692:	e01b      	b.n	80046cc <HAL_RCC_OscConfig+0x258>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8004694:	4b09      	ldr	r3, [pc, #36]	@ (80046bc <HAL_RCC_OscConfig+0x248>)
 8004696:	2200      	movs	r2, #0
 8004698:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800469a:	f7fd fb65 	bl	8001d68 <HAL_GetTick>
 800469e:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80046a0:	e00e      	b.n	80046c0 <HAL_RCC_OscConfig+0x24c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80046a2:	f7fd fb61 	bl	8001d68 <HAL_GetTick>
 80046a6:	4602      	mov	r2, r0
 80046a8:	693b      	ldr	r3, [r7, #16]
 80046aa:	1ad3      	subs	r3, r2, r3
 80046ac:	2b02      	cmp	r3, #2
 80046ae:	d907      	bls.n	80046c0 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
 80046b0:	2303      	movs	r3, #3
 80046b2:	e150      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
 80046b4:	40023800 	.word	0x40023800
 80046b8:	42470000 	.word	0x42470000
 80046bc:	42470e80 	.word	0x42470e80
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80046c0:	4b88      	ldr	r3, [pc, #544]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 80046c2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80046c4:	f003 0302 	and.w	r3, r3, #2
 80046c8:	2b00      	cmp	r3, #0
 80046ca:	d1ea      	bne.n	80046a2 <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80046cc:	687b      	ldr	r3, [r7, #4]
 80046ce:	681b      	ldr	r3, [r3, #0]
 80046d0:	f003 0304 	and.w	r3, r3, #4
 80046d4:	2b00      	cmp	r3, #0
 80046d6:	f000 8097 	beq.w	8004808 <HAL_RCC_OscConfig+0x394>
  {
    FlagStatus       pwrclkchanged = RESET;
 80046da:	2300      	movs	r3, #0
 80046dc:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80046de:	4b81      	ldr	r3, [pc, #516]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 80046e0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80046e2:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80046e6:	2b00      	cmp	r3, #0
 80046e8:	d10f      	bne.n	800470a <HAL_RCC_OscConfig+0x296>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80046ea:	2300      	movs	r3, #0
 80046ec:	60bb      	str	r3, [r7, #8]
 80046ee:	4b7d      	ldr	r3, [pc, #500]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 80046f0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80046f2:	4a7c      	ldr	r2, [pc, #496]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 80046f4:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80046f8:	6413      	str	r3, [r2, #64]	@ 0x40
 80046fa:	4b7a      	ldr	r3, [pc, #488]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 80046fc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80046fe:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8004702:	60bb      	str	r3, [r7, #8]
 8004704:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 8004706:	2301      	movs	r3, #1
 8004708:	75fb      	strb	r3, [r7, #23]
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800470a:	4b77      	ldr	r3, [pc, #476]	@ (80048e8 <HAL_RCC_OscConfig+0x474>)
 800470c:	681b      	ldr	r3, [r3, #0]
 800470e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8004712:	2b00      	cmp	r3, #0
 8004714:	d118      	bne.n	8004748 <HAL_RCC_OscConfig+0x2d4>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8004716:	4b74      	ldr	r3, [pc, #464]	@ (80048e8 <HAL_RCC_OscConfig+0x474>)
 8004718:	681b      	ldr	r3, [r3, #0]
 800471a:	4a73      	ldr	r2, [pc, #460]	@ (80048e8 <HAL_RCC_OscConfig+0x474>)
 800471c:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8004720:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8004722:	f7fd fb21 	bl	8001d68 <HAL_GetTick>
 8004726:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8004728:	e008      	b.n	800473c <HAL_RCC_OscConfig+0x2c8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800472a:	f7fd fb1d 	bl	8001d68 <HAL_GetTick>
 800472e:	4602      	mov	r2, r0
 8004730:	693b      	ldr	r3, [r7, #16]
 8004732:	1ad3      	subs	r3, r2, r3
 8004734:	2b02      	cmp	r3, #2
 8004736:	d901      	bls.n	800473c <HAL_RCC_OscConfig+0x2c8>
        {
          return HAL_TIMEOUT;
 8004738:	2303      	movs	r3, #3
 800473a:	e10c      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800473c:	4b6a      	ldr	r3, [pc, #424]	@ (80048e8 <HAL_RCC_OscConfig+0x474>)
 800473e:	681b      	ldr	r3, [r3, #0]
 8004740:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8004744:	2b00      	cmp	r3, #0
 8004746:	d0f0      	beq.n	800472a <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8004748:	687b      	ldr	r3, [r7, #4]
 800474a:	689b      	ldr	r3, [r3, #8]
 800474c:	2b01      	cmp	r3, #1
 800474e:	d106      	bne.n	800475e <HAL_RCC_OscConfig+0x2ea>
 8004750:	4b64      	ldr	r3, [pc, #400]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004752:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004754:	4a63      	ldr	r2, [pc, #396]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004756:	f043 0301 	orr.w	r3, r3, #1
 800475a:	6713      	str	r3, [r2, #112]	@ 0x70
 800475c:	e01c      	b.n	8004798 <HAL_RCC_OscConfig+0x324>
 800475e:	687b      	ldr	r3, [r7, #4]
 8004760:	689b      	ldr	r3, [r3, #8]
 8004762:	2b05      	cmp	r3, #5
 8004764:	d10c      	bne.n	8004780 <HAL_RCC_OscConfig+0x30c>
 8004766:	4b5f      	ldr	r3, [pc, #380]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004768:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800476a:	4a5e      	ldr	r2, [pc, #376]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 800476c:	f043 0304 	orr.w	r3, r3, #4
 8004770:	6713      	str	r3, [r2, #112]	@ 0x70
 8004772:	4b5c      	ldr	r3, [pc, #368]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004774:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004776:	4a5b      	ldr	r2, [pc, #364]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004778:	f043 0301 	orr.w	r3, r3, #1
 800477c:	6713      	str	r3, [r2, #112]	@ 0x70
 800477e:	e00b      	b.n	8004798 <HAL_RCC_OscConfig+0x324>
 8004780:	4b58      	ldr	r3, [pc, #352]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004782:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004784:	4a57      	ldr	r2, [pc, #348]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004786:	f023 0301 	bic.w	r3, r3, #1
 800478a:	6713      	str	r3, [r2, #112]	@ 0x70
 800478c:	4b55      	ldr	r3, [pc, #340]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 800478e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004790:	4a54      	ldr	r2, [pc, #336]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004792:	f023 0304 	bic.w	r3, r3, #4
 8004796:	6713      	str	r3, [r2, #112]	@ 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8004798:	687b      	ldr	r3, [r7, #4]
 800479a:	689b      	ldr	r3, [r3, #8]
 800479c:	2b00      	cmp	r3, #0
 800479e:	d015      	beq.n	80047cc <HAL_RCC_OscConfig+0x358>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80047a0:	f7fd fae2 	bl	8001d68 <HAL_GetTick>
 80047a4:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80047a6:	e00a      	b.n	80047be <HAL_RCC_OscConfig+0x34a>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80047a8:	f7fd fade 	bl	8001d68 <HAL_GetTick>
 80047ac:	4602      	mov	r2, r0
 80047ae:	693b      	ldr	r3, [r7, #16]
 80047b0:	1ad3      	subs	r3, r2, r3
 80047b2:	f241 3288 	movw	r2, #5000	@ 0x1388
 80047b6:	4293      	cmp	r3, r2
 80047b8:	d901      	bls.n	80047be <HAL_RCC_OscConfig+0x34a>
        {
          return HAL_TIMEOUT;
 80047ba:	2303      	movs	r3, #3
 80047bc:	e0cb      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80047be:	4b49      	ldr	r3, [pc, #292]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 80047c0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80047c2:	f003 0302 	and.w	r3, r3, #2
 80047c6:	2b00      	cmp	r3, #0
 80047c8:	d0ee      	beq.n	80047a8 <HAL_RCC_OscConfig+0x334>
 80047ca:	e014      	b.n	80047f6 <HAL_RCC_OscConfig+0x382>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80047cc:	f7fd facc 	bl	8001d68 <HAL_GetTick>
 80047d0:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80047d2:	e00a      	b.n	80047ea <HAL_RCC_OscConfig+0x376>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80047d4:	f7fd fac8 	bl	8001d68 <HAL_GetTick>
 80047d8:	4602      	mov	r2, r0
 80047da:	693b      	ldr	r3, [r7, #16]
 80047dc:	1ad3      	subs	r3, r2, r3
 80047de:	f241 3288 	movw	r2, #5000	@ 0x1388
 80047e2:	4293      	cmp	r3, r2
 80047e4:	d901      	bls.n	80047ea <HAL_RCC_OscConfig+0x376>
        {
          return HAL_TIMEOUT;
 80047e6:	2303      	movs	r3, #3
 80047e8:	e0b5      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80047ea:	4b3e      	ldr	r3, [pc, #248]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 80047ec:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80047ee:	f003 0302 	and.w	r3, r3, #2
 80047f2:	2b00      	cmp	r3, #0
 80047f4:	d1ee      	bne.n	80047d4 <HAL_RCC_OscConfig+0x360>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 80047f6:	7dfb      	ldrb	r3, [r7, #23]
 80047f8:	2b01      	cmp	r3, #1
 80047fa:	d105      	bne.n	8004808 <HAL_RCC_OscConfig+0x394>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80047fc:	4b39      	ldr	r3, [pc, #228]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 80047fe:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004800:	4a38      	ldr	r2, [pc, #224]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004802:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8004806:	6413      	str	r3, [r2, #64]	@ 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8004808:	687b      	ldr	r3, [r7, #4]
 800480a:	699b      	ldr	r3, [r3, #24]
 800480c:	2b00      	cmp	r3, #0
 800480e:	f000 80a1 	beq.w	8004954 <HAL_RCC_OscConfig+0x4e0>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8004812:	4b34      	ldr	r3, [pc, #208]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004814:	689b      	ldr	r3, [r3, #8]
 8004816:	f003 030c 	and.w	r3, r3, #12
 800481a:	2b08      	cmp	r3, #8
 800481c:	d05c      	beq.n	80048d8 <HAL_RCC_OscConfig+0x464>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800481e:	687b      	ldr	r3, [r7, #4]
 8004820:	699b      	ldr	r3, [r3, #24]
 8004822:	2b02      	cmp	r3, #2
 8004824:	d141      	bne.n	80048aa <HAL_RCC_OscConfig+0x436>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8004826:	4b31      	ldr	r3, [pc, #196]	@ (80048ec <HAL_RCC_OscConfig+0x478>)
 8004828:	2200      	movs	r2, #0
 800482a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800482c:	f7fd fa9c 	bl	8001d68 <HAL_GetTick>
 8004830:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004832:	e008      	b.n	8004846 <HAL_RCC_OscConfig+0x3d2>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004834:	f7fd fa98 	bl	8001d68 <HAL_GetTick>
 8004838:	4602      	mov	r2, r0
 800483a:	693b      	ldr	r3, [r7, #16]
 800483c:	1ad3      	subs	r3, r2, r3
 800483e:	2b02      	cmp	r3, #2
 8004840:	d901      	bls.n	8004846 <HAL_RCC_OscConfig+0x3d2>
          {
            return HAL_TIMEOUT;
 8004842:	2303      	movs	r3, #3
 8004844:	e087      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004846:	4b27      	ldr	r3, [pc, #156]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004848:	681b      	ldr	r3, [r3, #0]
 800484a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800484e:	2b00      	cmp	r3, #0
 8004850:	d1f0      	bne.n	8004834 <HAL_RCC_OscConfig+0x3c0>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8004852:	687b      	ldr	r3, [r7, #4]
 8004854:	69da      	ldr	r2, [r3, #28]
 8004856:	687b      	ldr	r3, [r7, #4]
 8004858:	6a1b      	ldr	r3, [r3, #32]
 800485a:	431a      	orrs	r2, r3
 800485c:	687b      	ldr	r3, [r7, #4]
 800485e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004860:	019b      	lsls	r3, r3, #6
 8004862:	431a      	orrs	r2, r3
 8004864:	687b      	ldr	r3, [r7, #4]
 8004866:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004868:	085b      	lsrs	r3, r3, #1
 800486a:	3b01      	subs	r3, #1
 800486c:	041b      	lsls	r3, r3, #16
 800486e:	431a      	orrs	r2, r3
 8004870:	687b      	ldr	r3, [r7, #4]
 8004872:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8004874:	061b      	lsls	r3, r3, #24
 8004876:	491b      	ldr	r1, [pc, #108]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 8004878:	4313      	orrs	r3, r2
 800487a:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800487c:	4b1b      	ldr	r3, [pc, #108]	@ (80048ec <HAL_RCC_OscConfig+0x478>)
 800487e:	2201      	movs	r2, #1
 8004880:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004882:	f7fd fa71 	bl	8001d68 <HAL_GetTick>
 8004886:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004888:	e008      	b.n	800489c <HAL_RCC_OscConfig+0x428>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800488a:	f7fd fa6d 	bl	8001d68 <HAL_GetTick>
 800488e:	4602      	mov	r2, r0
 8004890:	693b      	ldr	r3, [r7, #16]
 8004892:	1ad3      	subs	r3, r2, r3
 8004894:	2b02      	cmp	r3, #2
 8004896:	d901      	bls.n	800489c <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
 8004898:	2303      	movs	r3, #3
 800489a:	e05c      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800489c:	4b11      	ldr	r3, [pc, #68]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 800489e:	681b      	ldr	r3, [r3, #0]
 80048a0:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80048a4:	2b00      	cmp	r3, #0
 80048a6:	d0f0      	beq.n	800488a <HAL_RCC_OscConfig+0x416>
 80048a8:	e054      	b.n	8004954 <HAL_RCC_OscConfig+0x4e0>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80048aa:	4b10      	ldr	r3, [pc, #64]	@ (80048ec <HAL_RCC_OscConfig+0x478>)
 80048ac:	2200      	movs	r2, #0
 80048ae:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80048b0:	f7fd fa5a 	bl	8001d68 <HAL_GetTick>
 80048b4:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80048b6:	e008      	b.n	80048ca <HAL_RCC_OscConfig+0x456>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80048b8:	f7fd fa56 	bl	8001d68 <HAL_GetTick>
 80048bc:	4602      	mov	r2, r0
 80048be:	693b      	ldr	r3, [r7, #16]
 80048c0:	1ad3      	subs	r3, r2, r3
 80048c2:	2b02      	cmp	r3, #2
 80048c4:	d901      	bls.n	80048ca <HAL_RCC_OscConfig+0x456>
          {
            return HAL_TIMEOUT;
 80048c6:	2303      	movs	r3, #3
 80048c8:	e045      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80048ca:	4b06      	ldr	r3, [pc, #24]	@ (80048e4 <HAL_RCC_OscConfig+0x470>)
 80048cc:	681b      	ldr	r3, [r3, #0]
 80048ce:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80048d2:	2b00      	cmp	r3, #0
 80048d4:	d1f0      	bne.n	80048b8 <HAL_RCC_OscConfig+0x444>
 80048d6:	e03d      	b.n	8004954 <HAL_RCC_OscConfig+0x4e0>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80048d8:	687b      	ldr	r3, [r7, #4]
 80048da:	699b      	ldr	r3, [r3, #24]
 80048dc:	2b01      	cmp	r3, #1
 80048de:	d107      	bne.n	80048f0 <HAL_RCC_OscConfig+0x47c>
      {
        return HAL_ERROR;
 80048e0:	2301      	movs	r3, #1
 80048e2:	e038      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
 80048e4:	40023800 	.word	0x40023800
 80048e8:	40007000 	.word	0x40007000
 80048ec:	42470060 	.word	0x42470060
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 80048f0:	4b1b      	ldr	r3, [pc, #108]	@ (8004960 <HAL_RCC_OscConfig+0x4ec>)
 80048f2:	685b      	ldr	r3, [r3, #4]
 80048f4:	60fb      	str	r3, [r7, #12]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
#else
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80048f6:	687b      	ldr	r3, [r7, #4]
 80048f8:	699b      	ldr	r3, [r3, #24]
 80048fa:	2b01      	cmp	r3, #1
 80048fc:	d028      	beq.n	8004950 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80048fe:	68fb      	ldr	r3, [r7, #12]
 8004900:	f403 0280 	and.w	r2, r3, #4194304	@ 0x400000
 8004904:	687b      	ldr	r3, [r7, #4]
 8004906:	69db      	ldr	r3, [r3, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8004908:	429a      	cmp	r2, r3
 800490a:	d121      	bne.n	8004950 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 800490c:	68fb      	ldr	r3, [r7, #12]
 800490e:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 8004912:	687b      	ldr	r3, [r7, #4]
 8004914:	6a1b      	ldr	r3, [r3, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8004916:	429a      	cmp	r2, r3
 8004918:	d11a      	bne.n	8004950 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 800491a:	68fa      	ldr	r2, [r7, #12]
 800491c:	f647 73c0 	movw	r3, #32704	@ 0x7fc0
 8004920:	4013      	ands	r3, r2
 8004922:	687a      	ldr	r2, [r7, #4]
 8004924:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8004926:	0192      	lsls	r2, r2, #6
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8004928:	4293      	cmp	r3, r2
 800492a:	d111      	bne.n	8004950 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 800492c:	68fb      	ldr	r3, [r7, #12]
 800492e:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
 8004932:	687b      	ldr	r3, [r7, #4]
 8004934:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004936:	085b      	lsrs	r3, r3, #1
 8004938:	3b01      	subs	r3, #1
 800493a:	041b      	lsls	r3, r3, #16
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 800493c:	429a      	cmp	r2, r3
 800493e:	d107      	bne.n	8004950 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 8004940:	68fb      	ldr	r3, [r7, #12]
 8004942:	f003 6270 	and.w	r2, r3, #251658240	@ 0xf000000
 8004946:	687b      	ldr	r3, [r7, #4]
 8004948:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800494a:	061b      	lsls	r3, r3, #24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 800494c:	429a      	cmp	r2, r3
 800494e:	d001      	beq.n	8004954 <HAL_RCC_OscConfig+0x4e0>
#endif /* RCC_PLLCFGR_PLLR */
        {
          return HAL_ERROR;
 8004950:	2301      	movs	r3, #1
 8004952:	e000      	b.n	8004956 <HAL_RCC_OscConfig+0x4e2>
        }
      }
    }
  }
  return HAL_OK;
 8004954:	2300      	movs	r3, #0
}
 8004956:	4618      	mov	r0, r3
 8004958:	3718      	adds	r7, #24
 800495a:	46bd      	mov	sp, r7
 800495c:	bd80      	pop	{r7, pc}
 800495e:	bf00      	nop
 8004960:	40023800 	.word	0x40023800

08004964 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8004964:	b580      	push	{r7, lr}
 8004966:	b084      	sub	sp, #16
 8004968:	af00      	add	r7, sp, #0
 800496a:	6078      	str	r0, [r7, #4]
 800496c:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 800496e:	687b      	ldr	r3, [r7, #4]
 8004970:	2b00      	cmp	r3, #0
 8004972:	d101      	bne.n	8004978 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8004974:	2301      	movs	r3, #1
 8004976:	e0cc      	b.n	8004b12 <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8004978:	4b68      	ldr	r3, [pc, #416]	@ (8004b1c <HAL_RCC_ClockConfig+0x1b8>)
 800497a:	681b      	ldr	r3, [r3, #0]
 800497c:	f003 0307 	and.w	r3, r3, #7
 8004980:	683a      	ldr	r2, [r7, #0]
 8004982:	429a      	cmp	r2, r3
 8004984:	d90c      	bls.n	80049a0 <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004986:	4b65      	ldr	r3, [pc, #404]	@ (8004b1c <HAL_RCC_ClockConfig+0x1b8>)
 8004988:	683a      	ldr	r2, [r7, #0]
 800498a:	b2d2      	uxtb	r2, r2
 800498c:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800498e:	4b63      	ldr	r3, [pc, #396]	@ (8004b1c <HAL_RCC_ClockConfig+0x1b8>)
 8004990:	681b      	ldr	r3, [r3, #0]
 8004992:	f003 0307 	and.w	r3, r3, #7
 8004996:	683a      	ldr	r2, [r7, #0]
 8004998:	429a      	cmp	r2, r3
 800499a:	d001      	beq.n	80049a0 <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 800499c:	2301      	movs	r3, #1
 800499e:	e0b8      	b.n	8004b12 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80049a0:	687b      	ldr	r3, [r7, #4]
 80049a2:	681b      	ldr	r3, [r3, #0]
 80049a4:	f003 0302 	and.w	r3, r3, #2
 80049a8:	2b00      	cmp	r3, #0
 80049aa:	d020      	beq.n	80049ee <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80049ac:	687b      	ldr	r3, [r7, #4]
 80049ae:	681b      	ldr	r3, [r3, #0]
 80049b0:	f003 0304 	and.w	r3, r3, #4
 80049b4:	2b00      	cmp	r3, #0
 80049b6:	d005      	beq.n	80049c4 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80049b8:	4b59      	ldr	r3, [pc, #356]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 80049ba:	689b      	ldr	r3, [r3, #8]
 80049bc:	4a58      	ldr	r2, [pc, #352]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 80049be:	f443 53e0 	orr.w	r3, r3, #7168	@ 0x1c00
 80049c2:	6093      	str	r3, [r2, #8]
    }

    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80049c4:	687b      	ldr	r3, [r7, #4]
 80049c6:	681b      	ldr	r3, [r3, #0]
 80049c8:	f003 0308 	and.w	r3, r3, #8
 80049cc:	2b00      	cmp	r3, #0
 80049ce:	d005      	beq.n	80049dc <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80049d0:	4b53      	ldr	r3, [pc, #332]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 80049d2:	689b      	ldr	r3, [r3, #8]
 80049d4:	4a52      	ldr	r2, [pc, #328]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 80049d6:	f443 4360 	orr.w	r3, r3, #57344	@ 0xe000
 80049da:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80049dc:	4b50      	ldr	r3, [pc, #320]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 80049de:	689b      	ldr	r3, [r3, #8]
 80049e0:	f023 02f0 	bic.w	r2, r3, #240	@ 0xf0
 80049e4:	687b      	ldr	r3, [r7, #4]
 80049e6:	689b      	ldr	r3, [r3, #8]
 80049e8:	494d      	ldr	r1, [pc, #308]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 80049ea:	4313      	orrs	r3, r2
 80049ec:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80049ee:	687b      	ldr	r3, [r7, #4]
 80049f0:	681b      	ldr	r3, [r3, #0]
 80049f2:	f003 0301 	and.w	r3, r3, #1
 80049f6:	2b00      	cmp	r3, #0
 80049f8:	d044      	beq.n	8004a84 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80049fa:	687b      	ldr	r3, [r7, #4]
 80049fc:	685b      	ldr	r3, [r3, #4]
 80049fe:	2b01      	cmp	r3, #1
 8004a00:	d107      	bne.n	8004a12 <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004a02:	4b47      	ldr	r3, [pc, #284]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004a04:	681b      	ldr	r3, [r3, #0]
 8004a06:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8004a0a:	2b00      	cmp	r3, #0
 8004a0c:	d119      	bne.n	8004a42 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8004a0e:	2301      	movs	r3, #1
 8004a10:	e07f      	b.n	8004b12 <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if ((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8004a12:	687b      	ldr	r3, [r7, #4]
 8004a14:	685b      	ldr	r3, [r3, #4]
 8004a16:	2b02      	cmp	r3, #2
 8004a18:	d003      	beq.n	8004a22 <HAL_RCC_ClockConfig+0xbe>
             (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 8004a1a:	687b      	ldr	r3, [r7, #4]
 8004a1c:	685b      	ldr	r3, [r3, #4]
    else if ((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8004a1e:	2b03      	cmp	r3, #3
 8004a20:	d107      	bne.n	8004a32 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004a22:	4b3f      	ldr	r3, [pc, #252]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004a24:	681b      	ldr	r3, [r3, #0]
 8004a26:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8004a2a:	2b00      	cmp	r3, #0
 8004a2c:	d109      	bne.n	8004a42 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8004a2e:	2301      	movs	r3, #1
 8004a30:	e06f      	b.n	8004b12 <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004a32:	4b3b      	ldr	r3, [pc, #236]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004a34:	681b      	ldr	r3, [r3, #0]
 8004a36:	f003 0302 	and.w	r3, r3, #2
 8004a3a:	2b00      	cmp	r3, #0
 8004a3c:	d101      	bne.n	8004a42 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8004a3e:	2301      	movs	r3, #1
 8004a40:	e067      	b.n	8004b12 <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8004a42:	4b37      	ldr	r3, [pc, #220]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004a44:	689b      	ldr	r3, [r3, #8]
 8004a46:	f023 0203 	bic.w	r2, r3, #3
 8004a4a:	687b      	ldr	r3, [r7, #4]
 8004a4c:	685b      	ldr	r3, [r3, #4]
 8004a4e:	4934      	ldr	r1, [pc, #208]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004a50:	4313      	orrs	r3, r2
 8004a52:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8004a54:	f7fd f988 	bl	8001d68 <HAL_GetTick>
 8004a58:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004a5a:	e00a      	b.n	8004a72 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004a5c:	f7fd f984 	bl	8001d68 <HAL_GetTick>
 8004a60:	4602      	mov	r2, r0
 8004a62:	68fb      	ldr	r3, [r7, #12]
 8004a64:	1ad3      	subs	r3, r2, r3
 8004a66:	f241 3288 	movw	r2, #5000	@ 0x1388
 8004a6a:	4293      	cmp	r3, r2
 8004a6c:	d901      	bls.n	8004a72 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 8004a6e:	2303      	movs	r3, #3
 8004a70:	e04f      	b.n	8004b12 <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004a72:	4b2b      	ldr	r3, [pc, #172]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004a74:	689b      	ldr	r3, [r3, #8]
 8004a76:	f003 020c 	and.w	r2, r3, #12
 8004a7a:	687b      	ldr	r3, [r7, #4]
 8004a7c:	685b      	ldr	r3, [r3, #4]
 8004a7e:	009b      	lsls	r3, r3, #2
 8004a80:	429a      	cmp	r2, r3
 8004a82:	d1eb      	bne.n	8004a5c <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8004a84:	4b25      	ldr	r3, [pc, #148]	@ (8004b1c <HAL_RCC_ClockConfig+0x1b8>)
 8004a86:	681b      	ldr	r3, [r3, #0]
 8004a88:	f003 0307 	and.w	r3, r3, #7
 8004a8c:	683a      	ldr	r2, [r7, #0]
 8004a8e:	429a      	cmp	r2, r3
 8004a90:	d20c      	bcs.n	8004aac <HAL_RCC_ClockConfig+0x148>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004a92:	4b22      	ldr	r3, [pc, #136]	@ (8004b1c <HAL_RCC_ClockConfig+0x1b8>)
 8004a94:	683a      	ldr	r2, [r7, #0]
 8004a96:	b2d2      	uxtb	r2, r2
 8004a98:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004a9a:	4b20      	ldr	r3, [pc, #128]	@ (8004b1c <HAL_RCC_ClockConfig+0x1b8>)
 8004a9c:	681b      	ldr	r3, [r3, #0]
 8004a9e:	f003 0307 	and.w	r3, r3, #7
 8004aa2:	683a      	ldr	r2, [r7, #0]
 8004aa4:	429a      	cmp	r2, r3
 8004aa6:	d001      	beq.n	8004aac <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 8004aa8:	2301      	movs	r3, #1
 8004aaa:	e032      	b.n	8004b12 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004aac:	687b      	ldr	r3, [r7, #4]
 8004aae:	681b      	ldr	r3, [r3, #0]
 8004ab0:	f003 0304 	and.w	r3, r3, #4
 8004ab4:	2b00      	cmp	r3, #0
 8004ab6:	d008      	beq.n	8004aca <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8004ab8:	4b19      	ldr	r3, [pc, #100]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004aba:	689b      	ldr	r3, [r3, #8]
 8004abc:	f423 52e0 	bic.w	r2, r3, #7168	@ 0x1c00
 8004ac0:	687b      	ldr	r3, [r7, #4]
 8004ac2:	68db      	ldr	r3, [r3, #12]
 8004ac4:	4916      	ldr	r1, [pc, #88]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004ac6:	4313      	orrs	r3, r2
 8004ac8:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004aca:	687b      	ldr	r3, [r7, #4]
 8004acc:	681b      	ldr	r3, [r3, #0]
 8004ace:	f003 0308 	and.w	r3, r3, #8
 8004ad2:	2b00      	cmp	r3, #0
 8004ad4:	d009      	beq.n	8004aea <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8004ad6:	4b12      	ldr	r3, [pc, #72]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004ad8:	689b      	ldr	r3, [r3, #8]
 8004ada:	f423 4260 	bic.w	r2, r3, #57344	@ 0xe000
 8004ade:	687b      	ldr	r3, [r7, #4]
 8004ae0:	691b      	ldr	r3, [r3, #16]
 8004ae2:	00db      	lsls	r3, r3, #3
 8004ae4:	490e      	ldr	r1, [pc, #56]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004ae6:	4313      	orrs	r3, r2
 8004ae8:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8004aea:	f000 f821 	bl	8004b30 <HAL_RCC_GetSysClockFreq>
 8004aee:	4602      	mov	r2, r0
 8004af0:	4b0b      	ldr	r3, [pc, #44]	@ (8004b20 <HAL_RCC_ClockConfig+0x1bc>)
 8004af2:	689b      	ldr	r3, [r3, #8]
 8004af4:	091b      	lsrs	r3, r3, #4
 8004af6:	f003 030f 	and.w	r3, r3, #15
 8004afa:	490a      	ldr	r1, [pc, #40]	@ (8004b24 <HAL_RCC_ClockConfig+0x1c0>)
 8004afc:	5ccb      	ldrb	r3, [r1, r3]
 8004afe:	fa22 f303 	lsr.w	r3, r2, r3
 8004b02:	4a09      	ldr	r2, [pc, #36]	@ (8004b28 <HAL_RCC_ClockConfig+0x1c4>)
 8004b04:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick(uwTickPrio);
 8004b06:	4b09      	ldr	r3, [pc, #36]	@ (8004b2c <HAL_RCC_ClockConfig+0x1c8>)
 8004b08:	681b      	ldr	r3, [r3, #0]
 8004b0a:	4618      	mov	r0, r3
 8004b0c:	f7fd f8e8 	bl	8001ce0 <HAL_InitTick>

  return HAL_OK;
 8004b10:	2300      	movs	r3, #0
}
 8004b12:	4618      	mov	r0, r3
 8004b14:	3710      	adds	r7, #16
 8004b16:	46bd      	mov	sp, r7
 8004b18:	bd80      	pop	{r7, pc}
 8004b1a:	bf00      	nop
 8004b1c:	40023c00 	.word	0x40023c00
 8004b20:	40023800 	.word	0x40023800
 8004b24:	08030b58 	.word	0x08030b58
 8004b28:	20000018 	.word	0x20000018
 8004b2c:	2000001c 	.word	0x2000001c

08004b30 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8004b30:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8004b34:	b094      	sub	sp, #80	@ 0x50
 8004b36:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U;
 8004b38:	2300      	movs	r3, #0
 8004b3a:	647b      	str	r3, [r7, #68]	@ 0x44
  uint32_t pllvco = 0U;
 8004b3c:	2300      	movs	r3, #0
 8004b3e:	64fb      	str	r3, [r7, #76]	@ 0x4c
  uint32_t pllp = 0U;
 8004b40:	2300      	movs	r3, #0
 8004b42:	643b      	str	r3, [r7, #64]	@ 0x40
  uint32_t sysclockfreq = 0U;
 8004b44:	2300      	movs	r3, #0
 8004b46:	64bb      	str	r3, [r7, #72]	@ 0x48

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8004b48:	4b79      	ldr	r3, [pc, #484]	@ (8004d30 <HAL_RCC_GetSysClockFreq+0x200>)
 8004b4a:	689b      	ldr	r3, [r3, #8]
 8004b4c:	f003 030c 	and.w	r3, r3, #12
 8004b50:	2b08      	cmp	r3, #8
 8004b52:	d00d      	beq.n	8004b70 <HAL_RCC_GetSysClockFreq+0x40>
 8004b54:	2b08      	cmp	r3, #8
 8004b56:	f200 80e1 	bhi.w	8004d1c <HAL_RCC_GetSysClockFreq+0x1ec>
 8004b5a:	2b00      	cmp	r3, #0
 8004b5c:	d002      	beq.n	8004b64 <HAL_RCC_GetSysClockFreq+0x34>
 8004b5e:	2b04      	cmp	r3, #4
 8004b60:	d003      	beq.n	8004b6a <HAL_RCC_GetSysClockFreq+0x3a>
 8004b62:	e0db      	b.n	8004d1c <HAL_RCC_GetSysClockFreq+0x1ec>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8004b64:	4b73      	ldr	r3, [pc, #460]	@ (8004d34 <HAL_RCC_GetSysClockFreq+0x204>)
 8004b66:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004b68:	e0db      	b.n	8004d22 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8004b6a:	4b73      	ldr	r3, [pc, #460]	@ (8004d38 <HAL_RCC_GetSysClockFreq+0x208>)
 8004b6c:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004b6e:	e0d8      	b.n	8004d22 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8004b70:	4b6f      	ldr	r3, [pc, #444]	@ (8004d30 <HAL_RCC_GetSysClockFreq+0x200>)
 8004b72:	685b      	ldr	r3, [r3, #4]
 8004b74:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8004b78:	647b      	str	r3, [r7, #68]	@ 0x44
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8004b7a:	4b6d      	ldr	r3, [pc, #436]	@ (8004d30 <HAL_RCC_GetSysClockFreq+0x200>)
 8004b7c:	685b      	ldr	r3, [r3, #4]
 8004b7e:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8004b82:	2b00      	cmp	r3, #0
 8004b84:	d063      	beq.n	8004c4e <HAL_RCC_GetSysClockFreq+0x11e>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004b86:	4b6a      	ldr	r3, [pc, #424]	@ (8004d30 <HAL_RCC_GetSysClockFreq+0x200>)
 8004b88:	685b      	ldr	r3, [r3, #4]
 8004b8a:	099b      	lsrs	r3, r3, #6
 8004b8c:	2200      	movs	r2, #0
 8004b8e:	63bb      	str	r3, [r7, #56]	@ 0x38
 8004b90:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8004b92:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8004b94:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004b98:	633b      	str	r3, [r7, #48]	@ 0x30
 8004b9a:	2300      	movs	r3, #0
 8004b9c:	637b      	str	r3, [r7, #52]	@ 0x34
 8004b9e:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 8004ba2:	4622      	mov	r2, r4
 8004ba4:	462b      	mov	r3, r5
 8004ba6:	f04f 0000 	mov.w	r0, #0
 8004baa:	f04f 0100 	mov.w	r1, #0
 8004bae:	0159      	lsls	r1, r3, #5
 8004bb0:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8004bb4:	0150      	lsls	r0, r2, #5
 8004bb6:	4602      	mov	r2, r0
 8004bb8:	460b      	mov	r3, r1
 8004bba:	4621      	mov	r1, r4
 8004bbc:	1a51      	subs	r1, r2, r1
 8004bbe:	6139      	str	r1, [r7, #16]
 8004bc0:	4629      	mov	r1, r5
 8004bc2:	eb63 0301 	sbc.w	r3, r3, r1
 8004bc6:	617b      	str	r3, [r7, #20]
 8004bc8:	f04f 0200 	mov.w	r2, #0
 8004bcc:	f04f 0300 	mov.w	r3, #0
 8004bd0:	e9d7 ab04 	ldrd	sl, fp, [r7, #16]
 8004bd4:	4659      	mov	r1, fp
 8004bd6:	018b      	lsls	r3, r1, #6
 8004bd8:	4651      	mov	r1, sl
 8004bda:	ea43 6391 	orr.w	r3, r3, r1, lsr #26
 8004bde:	4651      	mov	r1, sl
 8004be0:	018a      	lsls	r2, r1, #6
 8004be2:	4651      	mov	r1, sl
 8004be4:	ebb2 0801 	subs.w	r8, r2, r1
 8004be8:	4659      	mov	r1, fp
 8004bea:	eb63 0901 	sbc.w	r9, r3, r1
 8004bee:	f04f 0200 	mov.w	r2, #0
 8004bf2:	f04f 0300 	mov.w	r3, #0
 8004bf6:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8004bfa:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 8004bfe:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 8004c02:	4690      	mov	r8, r2
 8004c04:	4699      	mov	r9, r3
 8004c06:	4623      	mov	r3, r4
 8004c08:	eb18 0303 	adds.w	r3, r8, r3
 8004c0c:	60bb      	str	r3, [r7, #8]
 8004c0e:	462b      	mov	r3, r5
 8004c10:	eb49 0303 	adc.w	r3, r9, r3
 8004c14:	60fb      	str	r3, [r7, #12]
 8004c16:	f04f 0200 	mov.w	r2, #0
 8004c1a:	f04f 0300 	mov.w	r3, #0
 8004c1e:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 8004c22:	4629      	mov	r1, r5
 8004c24:	024b      	lsls	r3, r1, #9
 8004c26:	4621      	mov	r1, r4
 8004c28:	ea43 53d1 	orr.w	r3, r3, r1, lsr #23
 8004c2c:	4621      	mov	r1, r4
 8004c2e:	024a      	lsls	r2, r1, #9
 8004c30:	4610      	mov	r0, r2
 8004c32:	4619      	mov	r1, r3
 8004c34:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8004c36:	2200      	movs	r2, #0
 8004c38:	62bb      	str	r3, [r7, #40]	@ 0x28
 8004c3a:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8004c3c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8004c40:	f7fb fb2e 	bl	80002a0 <__aeabi_uldivmod>
 8004c44:	4602      	mov	r2, r0
 8004c46:	460b      	mov	r3, r1
 8004c48:	4613      	mov	r3, r2
 8004c4a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8004c4c:	e058      	b.n	8004d00 <HAL_RCC_GetSysClockFreq+0x1d0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004c4e:	4b38      	ldr	r3, [pc, #224]	@ (8004d30 <HAL_RCC_GetSysClockFreq+0x200>)
 8004c50:	685b      	ldr	r3, [r3, #4]
 8004c52:	099b      	lsrs	r3, r3, #6
 8004c54:	2200      	movs	r2, #0
 8004c56:	4618      	mov	r0, r3
 8004c58:	4611      	mov	r1, r2
 8004c5a:	f3c0 0308 	ubfx	r3, r0, #0, #9
 8004c5e:	623b      	str	r3, [r7, #32]
 8004c60:	2300      	movs	r3, #0
 8004c62:	627b      	str	r3, [r7, #36]	@ 0x24
 8004c64:	e9d7 8908 	ldrd	r8, r9, [r7, #32]
 8004c68:	4642      	mov	r2, r8
 8004c6a:	464b      	mov	r3, r9
 8004c6c:	f04f 0000 	mov.w	r0, #0
 8004c70:	f04f 0100 	mov.w	r1, #0
 8004c74:	0159      	lsls	r1, r3, #5
 8004c76:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8004c7a:	0150      	lsls	r0, r2, #5
 8004c7c:	4602      	mov	r2, r0
 8004c7e:	460b      	mov	r3, r1
 8004c80:	4641      	mov	r1, r8
 8004c82:	ebb2 0a01 	subs.w	sl, r2, r1
 8004c86:	4649      	mov	r1, r9
 8004c88:	eb63 0b01 	sbc.w	fp, r3, r1
 8004c8c:	f04f 0200 	mov.w	r2, #0
 8004c90:	f04f 0300 	mov.w	r3, #0
 8004c94:	ea4f 138b 	mov.w	r3, fp, lsl #6
 8004c98:	ea43 639a 	orr.w	r3, r3, sl, lsr #26
 8004c9c:	ea4f 128a 	mov.w	r2, sl, lsl #6
 8004ca0:	ebb2 040a 	subs.w	r4, r2, sl
 8004ca4:	eb63 050b 	sbc.w	r5, r3, fp
 8004ca8:	f04f 0200 	mov.w	r2, #0
 8004cac:	f04f 0300 	mov.w	r3, #0
 8004cb0:	00eb      	lsls	r3, r5, #3
 8004cb2:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8004cb6:	00e2      	lsls	r2, r4, #3
 8004cb8:	4614      	mov	r4, r2
 8004cba:	461d      	mov	r5, r3
 8004cbc:	4643      	mov	r3, r8
 8004cbe:	18e3      	adds	r3, r4, r3
 8004cc0:	603b      	str	r3, [r7, #0]
 8004cc2:	464b      	mov	r3, r9
 8004cc4:	eb45 0303 	adc.w	r3, r5, r3
 8004cc8:	607b      	str	r3, [r7, #4]
 8004cca:	f04f 0200 	mov.w	r2, #0
 8004cce:	f04f 0300 	mov.w	r3, #0
 8004cd2:	e9d7 4500 	ldrd	r4, r5, [r7]
 8004cd6:	4629      	mov	r1, r5
 8004cd8:	028b      	lsls	r3, r1, #10
 8004cda:	4621      	mov	r1, r4
 8004cdc:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 8004ce0:	4621      	mov	r1, r4
 8004ce2:	028a      	lsls	r2, r1, #10
 8004ce4:	4610      	mov	r0, r2
 8004ce6:	4619      	mov	r1, r3
 8004ce8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8004cea:	2200      	movs	r2, #0
 8004cec:	61bb      	str	r3, [r7, #24]
 8004cee:	61fa      	str	r2, [r7, #28]
 8004cf0:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8004cf4:	f7fb fad4 	bl	80002a0 <__aeabi_uldivmod>
 8004cf8:	4602      	mov	r2, r0
 8004cfa:	460b      	mov	r3, r1
 8004cfc:	4613      	mov	r3, r2
 8004cfe:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 8004d00:	4b0b      	ldr	r3, [pc, #44]	@ (8004d30 <HAL_RCC_GetSysClockFreq+0x200>)
 8004d02:	685b      	ldr	r3, [r3, #4]
 8004d04:	0c1b      	lsrs	r3, r3, #16
 8004d06:	f003 0303 	and.w	r3, r3, #3
 8004d0a:	3301      	adds	r3, #1
 8004d0c:	005b      	lsls	r3, r3, #1
 8004d0e:	643b      	str	r3, [r7, #64]	@ 0x40

      sysclockfreq = pllvco / pllp;
 8004d10:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8004d12:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8004d14:	fbb2 f3f3 	udiv	r3, r2, r3
 8004d18:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004d1a:	e002      	b.n	8004d22 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 8004d1c:	4b05      	ldr	r3, [pc, #20]	@ (8004d34 <HAL_RCC_GetSysClockFreq+0x204>)
 8004d1e:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 8004d20:	bf00      	nop
    }
  }
  return sysclockfreq;
 8004d22:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
}
 8004d24:	4618      	mov	r0, r3
 8004d26:	3750      	adds	r7, #80	@ 0x50
 8004d28:	46bd      	mov	sp, r7
 8004d2a:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8004d2e:	bf00      	nop
 8004d30:	40023800 	.word	0x40023800
 8004d34:	00f42400 	.word	0x00f42400
 8004d38:	007a1200 	.word	0x007a1200

08004d3c <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8004d3c:	b480      	push	{r7}
 8004d3e:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8004d40:	4b03      	ldr	r3, [pc, #12]	@ (8004d50 <HAL_RCC_GetHCLKFreq+0x14>)
 8004d42:	681b      	ldr	r3, [r3, #0]
}
 8004d44:	4618      	mov	r0, r3
 8004d46:	46bd      	mov	sp, r7
 8004d48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004d4c:	4770      	bx	lr
 8004d4e:	bf00      	nop
 8004d50:	20000018 	.word	0x20000018

08004d54 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8004d54:	b580      	push	{r7, lr}
 8004d56:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8004d58:	f7ff fff0 	bl	8004d3c <HAL_RCC_GetHCLKFreq>
 8004d5c:	4602      	mov	r2, r0
 8004d5e:	4b05      	ldr	r3, [pc, #20]	@ (8004d74 <HAL_RCC_GetPCLK1Freq+0x20>)
 8004d60:	689b      	ldr	r3, [r3, #8]
 8004d62:	0a9b      	lsrs	r3, r3, #10
 8004d64:	f003 0307 	and.w	r3, r3, #7
 8004d68:	4903      	ldr	r1, [pc, #12]	@ (8004d78 <HAL_RCC_GetPCLK1Freq+0x24>)
 8004d6a:	5ccb      	ldrb	r3, [r1, r3]
 8004d6c:	fa22 f303 	lsr.w	r3, r2, r3
}
 8004d70:	4618      	mov	r0, r3
 8004d72:	bd80      	pop	{r7, pc}
 8004d74:	40023800 	.word	0x40023800
 8004d78:	08030b68 	.word	0x08030b68

08004d7c <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8004d7c:	b580      	push	{r7, lr}
 8004d7e:	b086      	sub	sp, #24
 8004d80:	af00      	add	r7, sp, #0
 8004d82:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8004d84:	2300      	movs	r3, #0
 8004d86:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg1 = 0U;
 8004d88:	2300      	movs	r3, #0
 8004d8a:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8004d8c:	687b      	ldr	r3, [r7, #4]
 8004d8e:	681b      	ldr	r3, [r3, #0]
 8004d90:	f003 0301 	and.w	r3, r3, #1
 8004d94:	2b00      	cmp	r3, #0
 8004d96:	d105      	bne.n	8004da4 <HAL_RCCEx_PeriphCLKConfig+0x28>
      (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8004d98:	687b      	ldr	r3, [r7, #4]
 8004d9a:	681b      	ldr	r3, [r3, #0]
 8004d9c:	f003 0304 	and.w	r3, r3, #4
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8004da0:	2b00      	cmp	r3, #0
 8004da2:	d035      	beq.n	8004e10 <HAL_RCCEx_PeriphCLKConfig+0x94>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
#if defined(STM32F411xE)
    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
#endif /* STM32F411xE */
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8004da4:	4b62      	ldr	r3, [pc, #392]	@ (8004f30 <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 8004da6:	2200      	movs	r2, #0
 8004da8:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8004daa:	f7fc ffdd 	bl	8001d68 <HAL_GetTick>
 8004dae:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is disabled */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004db0:	e008      	b.n	8004dc4 <HAL_RCCEx_PeriphCLKConfig+0x48>
    {
      if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8004db2:	f7fc ffd9 	bl	8001d68 <HAL_GetTick>
 8004db6:	4602      	mov	r2, r0
 8004db8:	697b      	ldr	r3, [r7, #20]
 8004dba:	1ad3      	subs	r3, r2, r3
 8004dbc:	2b02      	cmp	r3, #2
 8004dbe:	d901      	bls.n	8004dc4 <HAL_RCCEx_PeriphCLKConfig+0x48>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8004dc0:	2303      	movs	r3, #3
 8004dc2:	e0b0      	b.n	8004f26 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004dc4:	4b5b      	ldr	r3, [pc, #364]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004dc6:	681b      	ldr	r3, [r3, #0]
 8004dc8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8004dcc:	2b00      	cmp	r3, #0
 8004dce:	d1f0      	bne.n	8004db2 <HAL_RCCEx_PeriphCLKConfig+0x36>
                                   PeriphClkInit->PLLI2S.PLLI2SR);
#else
    /* Configure the PLLI2S division factors */
    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
 8004dd0:	687b      	ldr	r3, [r7, #4]
 8004dd2:	685b      	ldr	r3, [r3, #4]
 8004dd4:	019a      	lsls	r2, r3, #6
 8004dd6:	687b      	ldr	r3, [r7, #4]
 8004dd8:	689b      	ldr	r3, [r3, #8]
 8004dda:	071b      	lsls	r3, r3, #28
 8004ddc:	4955      	ldr	r1, [pc, #340]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004dde:	4313      	orrs	r3, r2
 8004de0:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
#endif /* STM32F411xE */

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 8004de4:	4b52      	ldr	r3, [pc, #328]	@ (8004f30 <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 8004de6:	2201      	movs	r2, #1
 8004de8:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8004dea:	f7fc ffbd 	bl	8001d68 <HAL_GetTick>
 8004dee:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8004df0:	e008      	b.n	8004e04 <HAL_RCCEx_PeriphCLKConfig+0x88>
    {
      if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8004df2:	f7fc ffb9 	bl	8001d68 <HAL_GetTick>
 8004df6:	4602      	mov	r2, r0
 8004df8:	697b      	ldr	r3, [r7, #20]
 8004dfa:	1ad3      	subs	r3, r2, r3
 8004dfc:	2b02      	cmp	r3, #2
 8004dfe:	d901      	bls.n	8004e04 <HAL_RCCEx_PeriphCLKConfig+0x88>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8004e00:	2303      	movs	r3, #3
 8004e02:	e090      	b.n	8004f26 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8004e04:	4b4b      	ldr	r3, [pc, #300]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e06:	681b      	ldr	r3, [r3, #0]
 8004e08:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8004e0c:	2b00      	cmp	r3, #0
 8004e0e:	d0f0      	beq.n	8004df2 <HAL_RCCEx_PeriphCLKConfig+0x76>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8004e10:	687b      	ldr	r3, [r7, #4]
 8004e12:	681b      	ldr	r3, [r3, #0]
 8004e14:	f003 0302 	and.w	r3, r3, #2
 8004e18:	2b00      	cmp	r3, #0
 8004e1a:	f000 8083 	beq.w	8004f24 <HAL_RCCEx_PeriphCLKConfig+0x1a8>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8004e1e:	2300      	movs	r3, #0
 8004e20:	60fb      	str	r3, [r7, #12]
 8004e22:	4b44      	ldr	r3, [pc, #272]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e24:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004e26:	4a43      	ldr	r2, [pc, #268]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e28:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8004e2c:	6413      	str	r3, [r2, #64]	@ 0x40
 8004e2e:	4b41      	ldr	r3, [pc, #260]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e30:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004e32:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8004e36:	60fb      	str	r3, [r7, #12]
 8004e38:	68fb      	ldr	r3, [r7, #12]

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8004e3a:	4b3f      	ldr	r3, [pc, #252]	@ (8004f38 <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8004e3c:	681b      	ldr	r3, [r3, #0]
 8004e3e:	4a3e      	ldr	r2, [pc, #248]	@ (8004f38 <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8004e40:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8004e44:	6013      	str	r3, [r2, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 8004e46:	f7fc ff8f 	bl	8001d68 <HAL_GetTick>
 8004e4a:	6178      	str	r0, [r7, #20]

    while ((PWR->CR & PWR_CR_DBP) == RESET)
 8004e4c:	e008      	b.n	8004e60 <HAL_RCCEx_PeriphCLKConfig+0xe4>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004e4e:	f7fc ff8b 	bl	8001d68 <HAL_GetTick>
 8004e52:	4602      	mov	r2, r0
 8004e54:	697b      	ldr	r3, [r7, #20]
 8004e56:	1ad3      	subs	r3, r2, r3
 8004e58:	2b02      	cmp	r3, #2
 8004e5a:	d901      	bls.n	8004e60 <HAL_RCCEx_PeriphCLKConfig+0xe4>
      {
        return HAL_TIMEOUT;
 8004e5c:	2303      	movs	r3, #3
 8004e5e:	e062      	b.n	8004f26 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    while ((PWR->CR & PWR_CR_DBP) == RESET)
 8004e60:	4b35      	ldr	r3, [pc, #212]	@ (8004f38 <HAL_RCCEx_PeriphCLKConfig+0x1bc>)
 8004e62:	681b      	ldr	r3, [r3, #0]
 8004e64:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8004e68:	2b00      	cmp	r3, #0
 8004e6a:	d0f0      	beq.n	8004e4e <HAL_RCCEx_PeriphCLKConfig+0xd2>
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8004e6c:	4b31      	ldr	r3, [pc, #196]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e6e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004e70:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004e74:	613b      	str	r3, [r7, #16]
    if ((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8004e76:	693b      	ldr	r3, [r7, #16]
 8004e78:	2b00      	cmp	r3, #0
 8004e7a:	d02f      	beq.n	8004edc <HAL_RCCEx_PeriphCLKConfig+0x160>
 8004e7c:	687b      	ldr	r3, [r7, #4]
 8004e7e:	68db      	ldr	r3, [r3, #12]
 8004e80:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004e84:	693a      	ldr	r2, [r7, #16]
 8004e86:	429a      	cmp	r2, r3
 8004e88:	d028      	beq.n	8004edc <HAL_RCCEx_PeriphCLKConfig+0x160>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8004e8a:	4b2a      	ldr	r3, [pc, #168]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004e8c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004e8e:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8004e92:	613b      	str	r3, [r7, #16]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8004e94:	4b29      	ldr	r3, [pc, #164]	@ (8004f3c <HAL_RCCEx_PeriphCLKConfig+0x1c0>)
 8004e96:	2201      	movs	r2, #1
 8004e98:	601a      	str	r2, [r3, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8004e9a:	4b28      	ldr	r3, [pc, #160]	@ (8004f3c <HAL_RCCEx_PeriphCLKConfig+0x1c0>)
 8004e9c:	2200      	movs	r2, #0
 8004e9e:	601a      	str	r2, [r3, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg1;
 8004ea0:	4a24      	ldr	r2, [pc, #144]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004ea2:	693b      	ldr	r3, [r7, #16]
 8004ea4:	6713      	str	r3, [r2, #112]	@ 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8004ea6:	4b23      	ldr	r3, [pc, #140]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004ea8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004eaa:	f003 0301 	and.w	r3, r3, #1
 8004eae:	2b01      	cmp	r3, #1
 8004eb0:	d114      	bne.n	8004edc <HAL_RCCEx_PeriphCLKConfig+0x160>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 8004eb2:	f7fc ff59 	bl	8001d68 <HAL_GetTick>
 8004eb6:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004eb8:	e00a      	b.n	8004ed0 <HAL_RCCEx_PeriphCLKConfig+0x154>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004eba:	f7fc ff55 	bl	8001d68 <HAL_GetTick>
 8004ebe:	4602      	mov	r2, r0
 8004ec0:	697b      	ldr	r3, [r7, #20]
 8004ec2:	1ad3      	subs	r3, r2, r3
 8004ec4:	f241 3288 	movw	r2, #5000	@ 0x1388
 8004ec8:	4293      	cmp	r3, r2
 8004eca:	d901      	bls.n	8004ed0 <HAL_RCCEx_PeriphCLKConfig+0x154>
          {
            return HAL_TIMEOUT;
 8004ecc:	2303      	movs	r3, #3
 8004ece:	e02a      	b.n	8004f26 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004ed0:	4b18      	ldr	r3, [pc, #96]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004ed2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004ed4:	f003 0302 	and.w	r3, r3, #2
 8004ed8:	2b00      	cmp	r3, #0
 8004eda:	d0ee      	beq.n	8004eba <HAL_RCCEx_PeriphCLKConfig+0x13e>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8004edc:	687b      	ldr	r3, [r7, #4]
 8004ede:	68db      	ldr	r3, [r3, #12]
 8004ee0:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004ee4:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8004ee8:	d10d      	bne.n	8004f06 <HAL_RCCEx_PeriphCLKConfig+0x18a>
 8004eea:	4b12      	ldr	r3, [pc, #72]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004eec:	689b      	ldr	r3, [r3, #8]
 8004eee:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 8004ef2:	687b      	ldr	r3, [r7, #4]
 8004ef4:	68db      	ldr	r3, [r3, #12]
 8004ef6:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 8004efa:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8004efe:	490d      	ldr	r1, [pc, #52]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f00:	4313      	orrs	r3, r2
 8004f02:	608b      	str	r3, [r1, #8]
 8004f04:	e005      	b.n	8004f12 <HAL_RCCEx_PeriphCLKConfig+0x196>
 8004f06:	4b0b      	ldr	r3, [pc, #44]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f08:	689b      	ldr	r3, [r3, #8]
 8004f0a:	4a0a      	ldr	r2, [pc, #40]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f0c:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
 8004f10:	6093      	str	r3, [r2, #8]
 8004f12:	4b08      	ldr	r3, [pc, #32]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f14:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8004f16:	687b      	ldr	r3, [r7, #4]
 8004f18:	68db      	ldr	r3, [r3, #12]
 8004f1a:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8004f1e:	4905      	ldr	r1, [pc, #20]	@ (8004f34 <HAL_RCCEx_PeriphCLKConfig+0x1b8>)
 8004f20:	4313      	orrs	r3, r2
 8004f22:	670b      	str	r3, [r1, #112]	@ 0x70
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 8004f24:	2300      	movs	r3, #0
}
 8004f26:	4618      	mov	r0, r3
 8004f28:	3718      	adds	r7, #24
 8004f2a:	46bd      	mov	sp, r7
 8004f2c:	bd80      	pop	{r7, pc}
 8004f2e:	bf00      	nop
 8004f30:	42470068 	.word	0x42470068
 8004f34:	40023800 	.word	0x40023800
 8004f38:	40007000 	.word	0x40007000
 8004f3c:	42470e40 	.word	0x42470e40

08004f40 <HAL_RCCEx_GetPeriphCLKFreq>:
  *         This parameter can be one of the following values:
  *            @arg RCC_PERIPHCLK_I2S: I2S peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 8004f40:	b480      	push	{r7}
 8004f42:	b087      	sub	sp, #28
 8004f44:	af00      	add	r7, sp, #0
 8004f46:	6078      	str	r0, [r7, #4]
  /* This variable used to store the I2S clock frequency (value in Hz) */
  uint32_t frequency = 0U;
 8004f48:	2300      	movs	r3, #0
 8004f4a:	617b      	str	r3, [r7, #20]
  /* This variable used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0U;
 8004f4c:	2300      	movs	r3, #0
 8004f4e:	613b      	str	r3, [r7, #16]
  uint32_t srcclk = 0U;
 8004f50:	2300      	movs	r3, #0
 8004f52:	60fb      	str	r3, [r7, #12]
  /* This variable used to store the VCO Output (value in Hz) */
  uint32_t vcooutput = 0U;
 8004f54:	2300      	movs	r3, #0
 8004f56:	60bb      	str	r3, [r7, #8]
  switch (PeriphClk)
 8004f58:	687b      	ldr	r3, [r7, #4]
 8004f5a:	2b01      	cmp	r3, #1
 8004f5c:	d13f      	bne.n	8004fde <HAL_RCCEx_GetPeriphCLKFreq+0x9e>
  {
    case RCC_PERIPHCLK_I2S:
    {
      /* Get the current I2S source */
      srcclk = __HAL_RCC_GET_I2S_SOURCE();
 8004f5e:	4b24      	ldr	r3, [pc, #144]	@ (8004ff0 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004f60:	689b      	ldr	r3, [r3, #8]
 8004f62:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8004f66:	60fb      	str	r3, [r7, #12]
      switch (srcclk)
 8004f68:	68fb      	ldr	r3, [r7, #12]
 8004f6a:	2b00      	cmp	r3, #0
 8004f6c:	d006      	beq.n	8004f7c <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
 8004f6e:	68fb      	ldr	r3, [r7, #12]
 8004f70:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 8004f74:	d12f      	bne.n	8004fd6 <HAL_RCCEx_GetPeriphCLKFreq+0x96>
      {
        /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */
        case RCC_I2SCLKSOURCE_EXT:
        {
          /* Set the I2S clock to the external clock  value */
          frequency = EXTERNAL_CLOCK_VALUE;
 8004f76:	4b1f      	ldr	r3, [pc, #124]	@ (8004ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 8004f78:	617b      	str	r3, [r7, #20]
          break;
 8004f7a:	e02f      	b.n	8004fdc <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
          }
#else
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
          if ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 8004f7c:	4b1c      	ldr	r3, [pc, #112]	@ (8004ff0 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004f7e:	685b      	ldr	r3, [r3, #4]
 8004f80:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8004f84:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8004f88:	d108      	bne.n	8004f9c <HAL_RCCEx_GetPeriphCLKFreq+0x5c>
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8004f8a:	4b19      	ldr	r3, [pc, #100]	@ (8004ff0 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004f8c:	685b      	ldr	r3, [r3, #4]
 8004f8e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8004f92:	4a19      	ldr	r2, [pc, #100]	@ (8004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0xb8>)
 8004f94:	fbb2 f3f3 	udiv	r3, r2, r3
 8004f98:	613b      	str	r3, [r7, #16]
 8004f9a:	e007      	b.n	8004fac <HAL_RCCEx_GetPeriphCLKFreq+0x6c>
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8004f9c:	4b14      	ldr	r3, [pc, #80]	@ (8004ff0 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004f9e:	685b      	ldr	r3, [r3, #4]
 8004fa0:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8004fa4:	4a15      	ldr	r2, [pc, #84]	@ (8004ffc <HAL_RCCEx_GetPeriphCLKFreq+0xbc>)
 8004fa6:	fbb2 f3f3 	udiv	r3, r2, r3
 8004faa:	613b      	str	r3, [r7, #16]
          }
#endif /* STM32F411xE */
          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
 8004fac:	4b10      	ldr	r3, [pc, #64]	@ (8004ff0 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004fae:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8004fb2:	099b      	lsrs	r3, r3, #6
 8004fb4:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8004fb8:	693b      	ldr	r3, [r7, #16]
 8004fba:	fb02 f303 	mul.w	r3, r2, r3
 8004fbe:	60bb      	str	r3, [r7, #8]
          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
          frequency = (uint32_t)(vcooutput / (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
 8004fc0:	4b0b      	ldr	r3, [pc, #44]	@ (8004ff0 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 8004fc2:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8004fc6:	0f1b      	lsrs	r3, r3, #28
 8004fc8:	f003 0307 	and.w	r3, r3, #7
 8004fcc:	68ba      	ldr	r2, [r7, #8]
 8004fce:	fbb2 f3f3 	udiv	r3, r2, r3
 8004fd2:	617b      	str	r3, [r7, #20]
          break;
 8004fd4:	e002      	b.n	8004fdc <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
        }
        /* Clock not enabled for I2S*/
        default:
        {
          frequency = 0U;
 8004fd6:	2300      	movs	r3, #0
 8004fd8:	617b      	str	r3, [r7, #20]
          break;
 8004fda:	bf00      	nop
        }
      }
      break;
 8004fdc:	e000      	b.n	8004fe0 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
    }
    default:
    {
      break;
 8004fde:	bf00      	nop
    }
  }
  return frequency;
 8004fe0:	697b      	ldr	r3, [r7, #20]
}
 8004fe2:	4618      	mov	r0, r3
 8004fe4:	371c      	adds	r7, #28
 8004fe6:	46bd      	mov	sp, r7
 8004fe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004fec:	4770      	bx	lr
 8004fee:	bf00      	nop
 8004ff0:	40023800 	.word	0x40023800
 8004ff4:	00bb8000 	.word	0x00bb8000
 8004ff8:	007a1200 	.word	0x007a1200
 8004ffc:	00f42400 	.word	0x00f42400

08005000 <HAL_RNG_Init>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
 8005000:	b580      	push	{r7, lr}
 8005002:	b082      	sub	sp, #8
 8005004:	af00      	add	r7, sp, #0
 8005006:	6078      	str	r0, [r7, #4]
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 8005008:	687b      	ldr	r3, [r7, #4]
 800500a:	2b00      	cmp	r3, #0
 800500c:	d101      	bne.n	8005012 <HAL_RNG_Init+0x12>
  {
    return HAL_ERROR;
 800500e:	2301      	movs	r3, #1
 8005010:	e01c      	b.n	800504c <HAL_RNG_Init+0x4c>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 8005012:	687b      	ldr	r3, [r7, #4]
 8005014:	795b      	ldrb	r3, [r3, #5]
 8005016:	b2db      	uxtb	r3, r3
 8005018:	2b00      	cmp	r3, #0
 800501a:	d105      	bne.n	8005028 <HAL_RNG_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hrng->Lock = HAL_UNLOCKED;
 800501c:	687b      	ldr	r3, [r7, #4]
 800501e:	2200      	movs	r2, #0
 8005020:	711a      	strb	r2, [r3, #4]

    /* Init the low level hardware */
    HAL_RNG_MspInit(hrng);
 8005022:	6878      	ldr	r0, [r7, #4]
 8005024:	f7fc fd0a 	bl	8001a3c <HAL_RNG_MspInit>
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 8005028:	687b      	ldr	r3, [r7, #4]
 800502a:	2202      	movs	r2, #2
 800502c:	715a      	strb	r2, [r3, #5]


  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 800502e:	687b      	ldr	r3, [r7, #4]
 8005030:	681b      	ldr	r3, [r3, #0]
 8005032:	681a      	ldr	r2, [r3, #0]
 8005034:	687b      	ldr	r3, [r7, #4]
 8005036:	681b      	ldr	r3, [r3, #0]
 8005038:	f042 0204 	orr.w	r2, r2, #4
 800503c:	601a      	str	r2, [r3, #0]

  /* Initialize the RNG state */
  hrng->State = HAL_RNG_STATE_READY;
 800503e:	687b      	ldr	r3, [r7, #4]
 8005040:	2201      	movs	r2, #1
 8005042:	715a      	strb	r2, [r3, #5]

  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 8005044:	687b      	ldr	r3, [r7, #4]
 8005046:	2200      	movs	r2, #0
 8005048:	609a      	str	r2, [r3, #8]

  /* Return function status */
  return HAL_OK;
 800504a:	2300      	movs	r3, #0
}
 800504c:	4618      	mov	r0, r3
 800504e:	3708      	adds	r7, #8
 8005050:	46bd      	mov	sp, r7
 8005052:	bd80      	pop	{r7, pc}

08005054 <HAL_RNG_DeInit>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_DeInit(RNG_HandleTypeDef *hrng)
{
 8005054:	b580      	push	{r7, lr}
 8005056:	b082      	sub	sp, #8
 8005058:	af00      	add	r7, sp, #0
 800505a:	6078      	str	r0, [r7, #4]
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 800505c:	687b      	ldr	r3, [r7, #4]
 800505e:	2b00      	cmp	r3, #0
 8005060:	d101      	bne.n	8005066 <HAL_RNG_DeInit+0x12>
  {
    return HAL_ERROR;
 8005062:	2301      	movs	r3, #1
 8005064:	e01c      	b.n	80050a0 <HAL_RNG_DeInit+0x4c>
  }

  /* Disable the RNG Peripheral */
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_IE | RNG_CR_RNGEN);
 8005066:	687b      	ldr	r3, [r7, #4]
 8005068:	681b      	ldr	r3, [r3, #0]
 800506a:	681a      	ldr	r2, [r3, #0]
 800506c:	687b      	ldr	r3, [r7, #4]
 800506e:	681b      	ldr	r3, [r3, #0]
 8005070:	f022 020c 	bic.w	r2, r2, #12
 8005074:	601a      	str	r2, [r3, #0]

  /* Clear RNG interrupt status flags */
  CLEAR_BIT(hrng->Instance->SR, RNG_SR_CEIS | RNG_SR_SEIS);
 8005076:	687b      	ldr	r3, [r7, #4]
 8005078:	681b      	ldr	r3, [r3, #0]
 800507a:	685a      	ldr	r2, [r3, #4]
 800507c:	687b      	ldr	r3, [r7, #4]
 800507e:	681b      	ldr	r3, [r3, #0]
 8005080:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8005084:	605a      	str	r2, [r3, #4]

  /* DeInit the low level hardware */
  hrng->MspDeInitCallback(hrng);
#else
  /* DeInit the low level hardware */
  HAL_RNG_MspDeInit(hrng);
 8005086:	6878      	ldr	r0, [r7, #4]
 8005088:	f7fc fcfa 	bl	8001a80 <HAL_RNG_MspDeInit>
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Update the RNG state */
  hrng->State = HAL_RNG_STATE_RESET;
 800508c:	687b      	ldr	r3, [r7, #4]
 800508e:	2200      	movs	r2, #0
 8005090:	715a      	strb	r2, [r3, #5]

  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 8005092:	687b      	ldr	r3, [r7, #4]
 8005094:	2200      	movs	r2, #0
 8005096:	609a      	str	r2, [r3, #8]

  /* Release Lock */
  __HAL_UNLOCK(hrng);
 8005098:	687b      	ldr	r3, [r7, #4]
 800509a:	2200      	movs	r2, #0
 800509c:	711a      	strb	r2, [r3, #4]

  /* Return the function status */
  return HAL_OK;
 800509e:	2300      	movs	r3, #0
}
 80050a0:	4618      	mov	r0, r3
 80050a2:	3708      	adds	r7, #8
 80050a4:	46bd      	mov	sp, r7
 80050a6:	bd80      	pop	{r7, pc}

080050a8 <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 80050a8:	b580      	push	{r7, lr}
 80050aa:	b084      	sub	sp, #16
 80050ac:	af00      	add	r7, sp, #0
 80050ae:	6078      	str	r0, [r7, #4]
 80050b0:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 80050b2:	2300      	movs	r3, #0
 80050b4:	73fb      	strb	r3, [r7, #15]

  /* Process Locked */
  __HAL_LOCK(hrng);
 80050b6:	687b      	ldr	r3, [r7, #4]
 80050b8:	791b      	ldrb	r3, [r3, #4]
 80050ba:	2b01      	cmp	r3, #1
 80050bc:	d101      	bne.n	80050c2 <HAL_RNG_GenerateRandomNumber+0x1a>
 80050be:	2302      	movs	r3, #2
 80050c0:	e044      	b.n	800514c <HAL_RNG_GenerateRandomNumber+0xa4>
 80050c2:	687b      	ldr	r3, [r7, #4]
 80050c4:	2201      	movs	r2, #1
 80050c6:	711a      	strb	r2, [r3, #4]

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
 80050c8:	687b      	ldr	r3, [r7, #4]
 80050ca:	795b      	ldrb	r3, [r3, #5]
 80050cc:	b2db      	uxtb	r3, r3
 80050ce:	2b01      	cmp	r3, #1
 80050d0:	d133      	bne.n	800513a <HAL_RNG_GenerateRandomNumber+0x92>
  {
    /* Change RNG peripheral state */
    hrng->State = HAL_RNG_STATE_BUSY;
 80050d2:	687b      	ldr	r3, [r7, #4]
 80050d4:	2202      	movs	r2, #2
 80050d6:	715a      	strb	r2, [r3, #5]

    /* Get tick */
    tickstart = HAL_GetTick();
 80050d8:	f7fc fe46 	bl	8001d68 <HAL_GetTick>
 80050dc:	60b8      	str	r0, [r7, #8]

    /* Check if data register contains valid random data */
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 80050de:	e018      	b.n	8005112 <HAL_RNG_GenerateRandomNumber+0x6a>
    {
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 80050e0:	f7fc fe42 	bl	8001d68 <HAL_GetTick>
 80050e4:	4602      	mov	r2, r0
 80050e6:	68bb      	ldr	r3, [r7, #8]
 80050e8:	1ad3      	subs	r3, r2, r3
 80050ea:	2b02      	cmp	r3, #2
 80050ec:	d911      	bls.n	8005112 <HAL_RNG_GenerateRandomNumber+0x6a>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 80050ee:	687b      	ldr	r3, [r7, #4]
 80050f0:	681b      	ldr	r3, [r3, #0]
 80050f2:	685b      	ldr	r3, [r3, #4]
 80050f4:	f003 0301 	and.w	r3, r3, #1
 80050f8:	2b01      	cmp	r3, #1
 80050fa:	d00a      	beq.n	8005112 <HAL_RNG_GenerateRandomNumber+0x6a>
        {
          hrng->State = HAL_RNG_STATE_READY;
 80050fc:	687b      	ldr	r3, [r7, #4]
 80050fe:	2201      	movs	r2, #1
 8005100:	715a      	strb	r2, [r3, #5]
          hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 8005102:	687b      	ldr	r3, [r7, #4]
 8005104:	2202      	movs	r2, #2
 8005106:	609a      	str	r2, [r3, #8]
          /* Process Unlocked */
          __HAL_UNLOCK(hrng);
 8005108:	687b      	ldr	r3, [r7, #4]
 800510a:	2200      	movs	r2, #0
 800510c:	711a      	strb	r2, [r3, #4]
          return HAL_ERROR;
 800510e:	2301      	movs	r3, #1
 8005110:	e01c      	b.n	800514c <HAL_RNG_GenerateRandomNumber+0xa4>
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8005112:	687b      	ldr	r3, [r7, #4]
 8005114:	681b      	ldr	r3, [r3, #0]
 8005116:	685b      	ldr	r3, [r3, #4]
 8005118:	f003 0301 	and.w	r3, r3, #1
 800511c:	2b01      	cmp	r3, #1
 800511e:	d1df      	bne.n	80050e0 <HAL_RNG_GenerateRandomNumber+0x38>
        }
      }
    }

    /* Get a 32bit Random number */
    hrng->RandomNumber = hrng->Instance->DR;
 8005120:	687b      	ldr	r3, [r7, #4]
 8005122:	681b      	ldr	r3, [r3, #0]
 8005124:	689a      	ldr	r2, [r3, #8]
 8005126:	687b      	ldr	r3, [r7, #4]
 8005128:	60da      	str	r2, [r3, #12]
    *random32bit = hrng->RandomNumber;
 800512a:	687b      	ldr	r3, [r7, #4]
 800512c:	68da      	ldr	r2, [r3, #12]
 800512e:	683b      	ldr	r3, [r7, #0]
 8005130:	601a      	str	r2, [r3, #0]

    hrng->State = HAL_RNG_STATE_READY;
 8005132:	687b      	ldr	r3, [r7, #4]
 8005134:	2201      	movs	r2, #1
 8005136:	715a      	strb	r2, [r3, #5]
 8005138:	e004      	b.n	8005144 <HAL_RNG_GenerateRandomNumber+0x9c>
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 800513a:	687b      	ldr	r3, [r7, #4]
 800513c:	2204      	movs	r2, #4
 800513e:	609a      	str	r2, [r3, #8]
    status = HAL_ERROR;
 8005140:	2301      	movs	r3, #1
 8005142:	73fb      	strb	r3, [r7, #15]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 8005144:	687b      	ldr	r3, [r7, #4]
 8005146:	2200      	movs	r2, #0
 8005148:	711a      	strb	r2, [r3, #4]

  return status;
 800514a:	7bfb      	ldrb	r3, [r7, #15]
}
 800514c:	4618      	mov	r0, r3
 800514e:	3710      	adds	r7, #16
 8005150:	46bd      	mov	sp, r7
 8005152:	bd80      	pop	{r7, pc}

08005154 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8005154:	b580      	push	{r7, lr}
 8005156:	b082      	sub	sp, #8
 8005158:	af00      	add	r7, sp, #0
 800515a:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 800515c:	687b      	ldr	r3, [r7, #4]
 800515e:	2b00      	cmp	r3, #0
 8005160:	d101      	bne.n	8005166 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 8005162:	2301      	movs	r3, #1
 8005164:	e07b      	b.n	800525e <HAL_SPI_Init+0x10a>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 8005166:	687b      	ldr	r3, [r7, #4]
 8005168:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800516a:	2b00      	cmp	r3, #0
 800516c:	d108      	bne.n	8005180 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 800516e:	687b      	ldr	r3, [r7, #4]
 8005170:	685b      	ldr	r3, [r3, #4]
 8005172:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8005176:	d009      	beq.n	800518c <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8005178:	687b      	ldr	r3, [r7, #4]
 800517a:	2200      	movs	r2, #0
 800517c:	61da      	str	r2, [r3, #28]
 800517e:	e005      	b.n	800518c <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8005180:	687b      	ldr	r3, [r7, #4]
 8005182:	2200      	movs	r2, #0
 8005184:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8005186:	687b      	ldr	r3, [r7, #4]
 8005188:	2200      	movs	r2, #0
 800518a:	615a      	str	r2, [r3, #20]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800518c:	687b      	ldr	r3, [r7, #4]
 800518e:	2200      	movs	r2, #0
 8005190:	629a      	str	r2, [r3, #40]	@ 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8005192:	687b      	ldr	r3, [r7, #4]
 8005194:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 8005198:	b2db      	uxtb	r3, r3
 800519a:	2b00      	cmp	r3, #0
 800519c:	d106      	bne.n	80051ac <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800519e:	687b      	ldr	r3, [r7, #4]
 80051a0:	2200      	movs	r2, #0
 80051a2:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 80051a6:	6878      	ldr	r0, [r7, #4]
 80051a8:	f7fc fc84 	bl	8001ab4 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80051ac:	687b      	ldr	r3, [r7, #4]
 80051ae:	2202      	movs	r2, #2
 80051b0:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80051b4:	687b      	ldr	r3, [r7, #4]
 80051b6:	681b      	ldr	r3, [r3, #0]
 80051b8:	681a      	ldr	r2, [r3, #0]
 80051ba:	687b      	ldr	r3, [r7, #4]
 80051bc:	681b      	ldr	r3, [r3, #0]
 80051be:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 80051c2:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80051c4:	687b      	ldr	r3, [r7, #4]
 80051c6:	685b      	ldr	r3, [r3, #4]
 80051c8:	f403 7282 	and.w	r2, r3, #260	@ 0x104
 80051cc:	687b      	ldr	r3, [r7, #4]
 80051ce:	689b      	ldr	r3, [r3, #8]
 80051d0:	f403 4304 	and.w	r3, r3, #33792	@ 0x8400
 80051d4:	431a      	orrs	r2, r3
 80051d6:	687b      	ldr	r3, [r7, #4]
 80051d8:	68db      	ldr	r3, [r3, #12]
 80051da:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 80051de:	431a      	orrs	r2, r3
 80051e0:	687b      	ldr	r3, [r7, #4]
 80051e2:	691b      	ldr	r3, [r3, #16]
 80051e4:	f003 0302 	and.w	r3, r3, #2
 80051e8:	431a      	orrs	r2, r3
 80051ea:	687b      	ldr	r3, [r7, #4]
 80051ec:	695b      	ldr	r3, [r3, #20]
 80051ee:	f003 0301 	and.w	r3, r3, #1
 80051f2:	431a      	orrs	r2, r3
 80051f4:	687b      	ldr	r3, [r7, #4]
 80051f6:	699b      	ldr	r3, [r3, #24]
 80051f8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80051fc:	431a      	orrs	r2, r3
 80051fe:	687b      	ldr	r3, [r7, #4]
 8005200:	69db      	ldr	r3, [r3, #28]
 8005202:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8005206:	431a      	orrs	r2, r3
 8005208:	687b      	ldr	r3, [r7, #4]
 800520a:	6a1b      	ldr	r3, [r3, #32]
 800520c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8005210:	ea42 0103 	orr.w	r1, r2, r3
 8005214:	687b      	ldr	r3, [r7, #4]
 8005216:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8005218:	f403 5200 	and.w	r2, r3, #8192	@ 0x2000
 800521c:	687b      	ldr	r3, [r7, #4]
 800521e:	681b      	ldr	r3, [r3, #0]
 8005220:	430a      	orrs	r2, r1
 8005222:	601a      	str	r2, [r3, #0]
                                  (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
                                  (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
                                  (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 8005224:	687b      	ldr	r3, [r7, #4]
 8005226:	699b      	ldr	r3, [r3, #24]
 8005228:	0c1b      	lsrs	r3, r3, #16
 800522a:	f003 0104 	and.w	r1, r3, #4
 800522e:	687b      	ldr	r3, [r7, #4]
 8005230:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8005232:	f003 0210 	and.w	r2, r3, #16
 8005236:	687b      	ldr	r3, [r7, #4]
 8005238:	681b      	ldr	r3, [r3, #0]
 800523a:	430a      	orrs	r2, r1
 800523c:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800523e:	687b      	ldr	r3, [r7, #4]
 8005240:	681b      	ldr	r3, [r3, #0]
 8005242:	69da      	ldr	r2, [r3, #28]
 8005244:	687b      	ldr	r3, [r7, #4]
 8005246:	681b      	ldr	r3, [r3, #0]
 8005248:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 800524c:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800524e:	687b      	ldr	r3, [r7, #4]
 8005250:	2200      	movs	r2, #0
 8005252:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 8005254:	687b      	ldr	r3, [r7, #4]
 8005256:	2201      	movs	r2, #1
 8005258:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  return HAL_OK;
 800525c:	2300      	movs	r3, #0
}
 800525e:	4618      	mov	r0, r3
 8005260:	3708      	adds	r7, #8
 8005262:	46bd      	mov	sp, r7
 8005264:	bd80      	pop	{r7, pc}

08005266 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8005266:	b084      	sub	sp, #16
 8005268:	b580      	push	{r7, lr}
 800526a:	b084      	sub	sp, #16
 800526c:	af00      	add	r7, sp, #0
 800526e:	6078      	str	r0, [r7, #4]
 8005270:	f107 001c 	add.w	r0, r7, #28
 8005274:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8005278:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 800527c:	2b01      	cmp	r3, #1
 800527e:	d123      	bne.n	80052c8 <USB_CoreInit+0x62>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8005280:	687b      	ldr	r3, [r7, #4]
 8005282:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8005284:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 8005288:	687b      	ldr	r3, [r7, #4]
 800528a:	639a      	str	r2, [r3, #56]	@ 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 800528c:	687b      	ldr	r3, [r7, #4]
 800528e:	68db      	ldr	r3, [r3, #12]
 8005290:	f423 0384 	bic.w	r3, r3, #4325376	@ 0x420000
 8005294:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8005298:	687a      	ldr	r2, [r7, #4]
 800529a:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 800529c:	687b      	ldr	r3, [r7, #4]
 800529e:	68db      	ldr	r3, [r3, #12]
 80052a0:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 80052a4:	687b      	ldr	r3, [r7, #4]
 80052a6:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 80052a8:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 80052ac:	2b01      	cmp	r3, #1
 80052ae:	d105      	bne.n	80052bc <USB_CoreInit+0x56>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 80052b0:	687b      	ldr	r3, [r7, #4]
 80052b2:	68db      	ldr	r3, [r3, #12]
 80052b4:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
 80052b8:	687b      	ldr	r3, [r7, #4]
 80052ba:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 80052bc:	6878      	ldr	r0, [r7, #4]
 80052be:	f001 fae9 	bl	8006894 <USB_CoreReset>
 80052c2:	4603      	mov	r3, r0
 80052c4:	73fb      	strb	r3, [r7, #15]
 80052c6:	e01b      	b.n	8005300 <USB_CoreInit+0x9a>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 80052c8:	687b      	ldr	r3, [r7, #4]
 80052ca:	68db      	ldr	r3, [r3, #12]
 80052cc:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 80052d0:	687b      	ldr	r3, [r7, #4]
 80052d2:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 80052d4:	6878      	ldr	r0, [r7, #4]
 80052d6:	f001 fadd 	bl	8006894 <USB_CoreReset>
 80052da:	4603      	mov	r3, r0
 80052dc:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 80052de:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 80052e2:	2b00      	cmp	r3, #0
 80052e4:	d106      	bne.n	80052f4 <USB_CoreInit+0x8e>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80052e6:	687b      	ldr	r3, [r7, #4]
 80052e8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80052ea:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 80052ee:	687b      	ldr	r3, [r7, #4]
 80052f0:	639a      	str	r2, [r3, #56]	@ 0x38
 80052f2:	e005      	b.n	8005300 <USB_CoreInit+0x9a>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80052f4:	687b      	ldr	r3, [r7, #4]
 80052f6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80052f8:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 80052fc:	687b      	ldr	r3, [r7, #4]
 80052fe:	639a      	str	r2, [r3, #56]	@ 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 8005300:	7fbb      	ldrb	r3, [r7, #30]
 8005302:	2b01      	cmp	r3, #1
 8005304:	d10b      	bne.n	800531e <USB_CoreInit+0xb8>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8005306:	687b      	ldr	r3, [r7, #4]
 8005308:	689b      	ldr	r3, [r3, #8]
 800530a:	f043 0206 	orr.w	r2, r3, #6
 800530e:	687b      	ldr	r3, [r7, #4]
 8005310:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8005312:	687b      	ldr	r3, [r7, #4]
 8005314:	689b      	ldr	r3, [r3, #8]
 8005316:	f043 0220 	orr.w	r2, r3, #32
 800531a:	687b      	ldr	r3, [r7, #4]
 800531c:	609a      	str	r2, [r3, #8]
  }

  return ret;
 800531e:	7bfb      	ldrb	r3, [r7, #15]
}
 8005320:	4618      	mov	r0, r3
 8005322:	3710      	adds	r7, #16
 8005324:	46bd      	mov	sp, r7
 8005326:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800532a:	b004      	add	sp, #16
 800532c:	4770      	bx	lr
	...

08005330 <USB_SetTurnaroundTime>:
  * @param  hclk: AHB clock frequency
  * @retval USB turnaround time In PHY Clocks number
  */
HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
                                        uint32_t hclk, uint8_t speed)
{
 8005330:	b480      	push	{r7}
 8005332:	b087      	sub	sp, #28
 8005334:	af00      	add	r7, sp, #0
 8005336:	60f8      	str	r0, [r7, #12]
 8005338:	60b9      	str	r1, [r7, #8]
 800533a:	4613      	mov	r3, r2
 800533c:	71fb      	strb	r3, [r7, #7]

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
 800533e:	79fb      	ldrb	r3, [r7, #7]
 8005340:	2b02      	cmp	r3, #2
 8005342:	d165      	bne.n	8005410 <USB_SetTurnaroundTime+0xe0>
  {
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 8005344:	68bb      	ldr	r3, [r7, #8]
 8005346:	4a41      	ldr	r2, [pc, #260]	@ (800544c <USB_SetTurnaroundTime+0x11c>)
 8005348:	4293      	cmp	r3, r2
 800534a:	d906      	bls.n	800535a <USB_SetTurnaroundTime+0x2a>
 800534c:	68bb      	ldr	r3, [r7, #8]
 800534e:	4a40      	ldr	r2, [pc, #256]	@ (8005450 <USB_SetTurnaroundTime+0x120>)
 8005350:	4293      	cmp	r3, r2
 8005352:	d202      	bcs.n	800535a <USB_SetTurnaroundTime+0x2a>
    {
      /* hclk Clock Range between 14.2-15 MHz */
      UsbTrd = 0xFU;
 8005354:	230f      	movs	r3, #15
 8005356:	617b      	str	r3, [r7, #20]
 8005358:	e062      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 800535a:	68bb      	ldr	r3, [r7, #8]
 800535c:	4a3c      	ldr	r2, [pc, #240]	@ (8005450 <USB_SetTurnaroundTime+0x120>)
 800535e:	4293      	cmp	r3, r2
 8005360:	d306      	bcc.n	8005370 <USB_SetTurnaroundTime+0x40>
 8005362:	68bb      	ldr	r3, [r7, #8]
 8005364:	4a3b      	ldr	r2, [pc, #236]	@ (8005454 <USB_SetTurnaroundTime+0x124>)
 8005366:	4293      	cmp	r3, r2
 8005368:	d202      	bcs.n	8005370 <USB_SetTurnaroundTime+0x40>
    {
      /* hclk Clock Range between 15-16 MHz */
      UsbTrd = 0xEU;
 800536a:	230e      	movs	r3, #14
 800536c:	617b      	str	r3, [r7, #20]
 800536e:	e057      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 8005370:	68bb      	ldr	r3, [r7, #8]
 8005372:	4a38      	ldr	r2, [pc, #224]	@ (8005454 <USB_SetTurnaroundTime+0x124>)
 8005374:	4293      	cmp	r3, r2
 8005376:	d306      	bcc.n	8005386 <USB_SetTurnaroundTime+0x56>
 8005378:	68bb      	ldr	r3, [r7, #8]
 800537a:	4a37      	ldr	r2, [pc, #220]	@ (8005458 <USB_SetTurnaroundTime+0x128>)
 800537c:	4293      	cmp	r3, r2
 800537e:	d202      	bcs.n	8005386 <USB_SetTurnaroundTime+0x56>
    {
      /* hclk Clock Range between 16-17.2 MHz */
      UsbTrd = 0xDU;
 8005380:	230d      	movs	r3, #13
 8005382:	617b      	str	r3, [r7, #20]
 8005384:	e04c      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 8005386:	68bb      	ldr	r3, [r7, #8]
 8005388:	4a33      	ldr	r2, [pc, #204]	@ (8005458 <USB_SetTurnaroundTime+0x128>)
 800538a:	4293      	cmp	r3, r2
 800538c:	d306      	bcc.n	800539c <USB_SetTurnaroundTime+0x6c>
 800538e:	68bb      	ldr	r3, [r7, #8]
 8005390:	4a32      	ldr	r2, [pc, #200]	@ (800545c <USB_SetTurnaroundTime+0x12c>)
 8005392:	4293      	cmp	r3, r2
 8005394:	d802      	bhi.n	800539c <USB_SetTurnaroundTime+0x6c>
    {
      /* hclk Clock Range between 17.2-18.5 MHz */
      UsbTrd = 0xCU;
 8005396:	230c      	movs	r3, #12
 8005398:	617b      	str	r3, [r7, #20]
 800539a:	e041      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 800539c:	68bb      	ldr	r3, [r7, #8]
 800539e:	4a2f      	ldr	r2, [pc, #188]	@ (800545c <USB_SetTurnaroundTime+0x12c>)
 80053a0:	4293      	cmp	r3, r2
 80053a2:	d906      	bls.n	80053b2 <USB_SetTurnaroundTime+0x82>
 80053a4:	68bb      	ldr	r3, [r7, #8]
 80053a6:	4a2e      	ldr	r2, [pc, #184]	@ (8005460 <USB_SetTurnaroundTime+0x130>)
 80053a8:	4293      	cmp	r3, r2
 80053aa:	d802      	bhi.n	80053b2 <USB_SetTurnaroundTime+0x82>
    {
      /* hclk Clock Range between 18.5-20 MHz */
      UsbTrd = 0xBU;
 80053ac:	230b      	movs	r3, #11
 80053ae:	617b      	str	r3, [r7, #20]
 80053b0:	e036      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 80053b2:	68bb      	ldr	r3, [r7, #8]
 80053b4:	4a2a      	ldr	r2, [pc, #168]	@ (8005460 <USB_SetTurnaroundTime+0x130>)
 80053b6:	4293      	cmp	r3, r2
 80053b8:	d906      	bls.n	80053c8 <USB_SetTurnaroundTime+0x98>
 80053ba:	68bb      	ldr	r3, [r7, #8]
 80053bc:	4a29      	ldr	r2, [pc, #164]	@ (8005464 <USB_SetTurnaroundTime+0x134>)
 80053be:	4293      	cmp	r3, r2
 80053c0:	d802      	bhi.n	80053c8 <USB_SetTurnaroundTime+0x98>
    {
      /* hclk Clock Range between 20-21.8 MHz */
      UsbTrd = 0xAU;
 80053c2:	230a      	movs	r3, #10
 80053c4:	617b      	str	r3, [r7, #20]
 80053c6:	e02b      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 80053c8:	68bb      	ldr	r3, [r7, #8]
 80053ca:	4a26      	ldr	r2, [pc, #152]	@ (8005464 <USB_SetTurnaroundTime+0x134>)
 80053cc:	4293      	cmp	r3, r2
 80053ce:	d906      	bls.n	80053de <USB_SetTurnaroundTime+0xae>
 80053d0:	68bb      	ldr	r3, [r7, #8]
 80053d2:	4a25      	ldr	r2, [pc, #148]	@ (8005468 <USB_SetTurnaroundTime+0x138>)
 80053d4:	4293      	cmp	r3, r2
 80053d6:	d202      	bcs.n	80053de <USB_SetTurnaroundTime+0xae>
    {
      /* hclk Clock Range between 21.8-24 MHz */
      UsbTrd = 0x9U;
 80053d8:	2309      	movs	r3, #9
 80053da:	617b      	str	r3, [r7, #20]
 80053dc:	e020      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 80053de:	68bb      	ldr	r3, [r7, #8]
 80053e0:	4a21      	ldr	r2, [pc, #132]	@ (8005468 <USB_SetTurnaroundTime+0x138>)
 80053e2:	4293      	cmp	r3, r2
 80053e4:	d306      	bcc.n	80053f4 <USB_SetTurnaroundTime+0xc4>
 80053e6:	68bb      	ldr	r3, [r7, #8]
 80053e8:	4a20      	ldr	r2, [pc, #128]	@ (800546c <USB_SetTurnaroundTime+0x13c>)
 80053ea:	4293      	cmp	r3, r2
 80053ec:	d802      	bhi.n	80053f4 <USB_SetTurnaroundTime+0xc4>
    {
      /* hclk Clock Range between 24-27.7 MHz */
      UsbTrd = 0x8U;
 80053ee:	2308      	movs	r3, #8
 80053f0:	617b      	str	r3, [r7, #20]
 80053f2:	e015      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 80053f4:	68bb      	ldr	r3, [r7, #8]
 80053f6:	4a1d      	ldr	r2, [pc, #116]	@ (800546c <USB_SetTurnaroundTime+0x13c>)
 80053f8:	4293      	cmp	r3, r2
 80053fa:	d906      	bls.n	800540a <USB_SetTurnaroundTime+0xda>
 80053fc:	68bb      	ldr	r3, [r7, #8]
 80053fe:	4a1c      	ldr	r2, [pc, #112]	@ (8005470 <USB_SetTurnaroundTime+0x140>)
 8005400:	4293      	cmp	r3, r2
 8005402:	d202      	bcs.n	800540a <USB_SetTurnaroundTime+0xda>
    {
      /* hclk Clock Range between 27.7-32 MHz */
      UsbTrd = 0x7U;
 8005404:	2307      	movs	r3, #7
 8005406:	617b      	str	r3, [r7, #20]
 8005408:	e00a      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
    }
    else /* if(hclk >= 32000000) */
    {
      /* hclk Clock Range between 32-200 MHz */
      UsbTrd = 0x6U;
 800540a:	2306      	movs	r3, #6
 800540c:	617b      	str	r3, [r7, #20]
 800540e:	e007      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
    }
  }
  else if (speed == USBD_HS_SPEED)
 8005410:	79fb      	ldrb	r3, [r7, #7]
 8005412:	2b00      	cmp	r3, #0
 8005414:	d102      	bne.n	800541c <USB_SetTurnaroundTime+0xec>
  {
    UsbTrd = USBD_HS_TRDT_VALUE;
 8005416:	2309      	movs	r3, #9
 8005418:	617b      	str	r3, [r7, #20]
 800541a:	e001      	b.n	8005420 <USB_SetTurnaroundTime+0xf0>
  }
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
 800541c:	2309      	movs	r3, #9
 800541e:	617b      	str	r3, [r7, #20]
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8005420:	68fb      	ldr	r3, [r7, #12]
 8005422:	68db      	ldr	r3, [r3, #12]
 8005424:	f423 5270 	bic.w	r2, r3, #15360	@ 0x3c00
 8005428:	68fb      	ldr	r3, [r7, #12]
 800542a:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 800542c:	68fb      	ldr	r3, [r7, #12]
 800542e:	68da      	ldr	r2, [r3, #12]
 8005430:	697b      	ldr	r3, [r7, #20]
 8005432:	029b      	lsls	r3, r3, #10
 8005434:	f403 5370 	and.w	r3, r3, #15360	@ 0x3c00
 8005438:	431a      	orrs	r2, r3
 800543a:	68fb      	ldr	r3, [r7, #12]
 800543c:	60da      	str	r2, [r3, #12]

  return HAL_OK;
 800543e:	2300      	movs	r3, #0
}
 8005440:	4618      	mov	r0, r3
 8005442:	371c      	adds	r7, #28
 8005444:	46bd      	mov	sp, r7
 8005446:	f85d 7b04 	ldr.w	r7, [sp], #4
 800544a:	4770      	bx	lr
 800544c:	00d8acbf 	.word	0x00d8acbf
 8005450:	00e4e1c0 	.word	0x00e4e1c0
 8005454:	00f42400 	.word	0x00f42400
 8005458:	01067380 	.word	0x01067380
 800545c:	011a499f 	.word	0x011a499f
 8005460:	01312cff 	.word	0x01312cff
 8005464:	014ca43f 	.word	0x014ca43f
 8005468:	016e3600 	.word	0x016e3600
 800546c:	01a6ab1f 	.word	0x01a6ab1f
 8005470:	01e84800 	.word	0x01e84800

08005474 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8005474:	b480      	push	{r7}
 8005476:	b083      	sub	sp, #12
 8005478:	af00      	add	r7, sp, #0
 800547a:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 800547c:	687b      	ldr	r3, [r7, #4]
 800547e:	689b      	ldr	r3, [r3, #8]
 8005480:	f043 0201 	orr.w	r2, r3, #1
 8005484:	687b      	ldr	r3, [r7, #4]
 8005486:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8005488:	2300      	movs	r3, #0
}
 800548a:	4618      	mov	r0, r3
 800548c:	370c      	adds	r7, #12
 800548e:	46bd      	mov	sp, r7
 8005490:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005494:	4770      	bx	lr

08005496 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8005496:	b480      	push	{r7}
 8005498:	b083      	sub	sp, #12
 800549a:	af00      	add	r7, sp, #0
 800549c:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800549e:	687b      	ldr	r3, [r7, #4]
 80054a0:	689b      	ldr	r3, [r3, #8]
 80054a2:	f023 0201 	bic.w	r2, r3, #1
 80054a6:	687b      	ldr	r3, [r7, #4]
 80054a8:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 80054aa:	2300      	movs	r3, #0
}
 80054ac:	4618      	mov	r0, r3
 80054ae:	370c      	adds	r7, #12
 80054b0:	46bd      	mov	sp, r7
 80054b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80054b6:	4770      	bx	lr

080054b8 <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 80054b8:	b580      	push	{r7, lr}
 80054ba:	b084      	sub	sp, #16
 80054bc:	af00      	add	r7, sp, #0
 80054be:	6078      	str	r0, [r7, #4]
 80054c0:	460b      	mov	r3, r1
 80054c2:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
 80054c4:	2300      	movs	r3, #0
 80054c6:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80054c8:	687b      	ldr	r3, [r7, #4]
 80054ca:	68db      	ldr	r3, [r3, #12]
 80054cc:	f023 42c0 	bic.w	r2, r3, #1610612736	@ 0x60000000
 80054d0:	687b      	ldr	r3, [r7, #4]
 80054d2:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 80054d4:	78fb      	ldrb	r3, [r7, #3]
 80054d6:	2b01      	cmp	r3, #1
 80054d8:	d115      	bne.n	8005506 <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 80054da:	687b      	ldr	r3, [r7, #4]
 80054dc:	68db      	ldr	r3, [r3, #12]
 80054de:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
 80054e2:	687b      	ldr	r3, [r7, #4]
 80054e4:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 80054e6:	200a      	movs	r0, #10
 80054e8:	f7fc fc4a 	bl	8001d80 <HAL_Delay>
      ms += 10U;
 80054ec:	68fb      	ldr	r3, [r7, #12]
 80054ee:	330a      	adds	r3, #10
 80054f0:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 80054f2:	6878      	ldr	r0, [r7, #4]
 80054f4:	f001 f93f 	bl	8006776 <USB_GetMode>
 80054f8:	4603      	mov	r3, r0
 80054fa:	2b01      	cmp	r3, #1
 80054fc:	d01e      	beq.n	800553c <USB_SetCurrentMode+0x84>
 80054fe:	68fb      	ldr	r3, [r7, #12]
 8005500:	2bc7      	cmp	r3, #199	@ 0xc7
 8005502:	d9f0      	bls.n	80054e6 <USB_SetCurrentMode+0x2e>
 8005504:	e01a      	b.n	800553c <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
 8005506:	78fb      	ldrb	r3, [r7, #3]
 8005508:	2b00      	cmp	r3, #0
 800550a:	d115      	bne.n	8005538 <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 800550c:	687b      	ldr	r3, [r7, #4]
 800550e:	68db      	ldr	r3, [r3, #12]
 8005510:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 8005514:	687b      	ldr	r3, [r7, #4]
 8005516:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 8005518:	200a      	movs	r0, #10
 800551a:	f7fc fc31 	bl	8001d80 <HAL_Delay>
      ms += 10U;
 800551e:	68fb      	ldr	r3, [r7, #12]
 8005520:	330a      	adds	r3, #10
 8005522:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8005524:	6878      	ldr	r0, [r7, #4]
 8005526:	f001 f926 	bl	8006776 <USB_GetMode>
 800552a:	4603      	mov	r3, r0
 800552c:	2b00      	cmp	r3, #0
 800552e:	d005      	beq.n	800553c <USB_SetCurrentMode+0x84>
 8005530:	68fb      	ldr	r3, [r7, #12]
 8005532:	2bc7      	cmp	r3, #199	@ 0xc7
 8005534:	d9f0      	bls.n	8005518 <USB_SetCurrentMode+0x60>
 8005536:	e001      	b.n	800553c <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
 8005538:	2301      	movs	r3, #1
 800553a:	e005      	b.n	8005548 <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 800553c:	68fb      	ldr	r3, [r7, #12]
 800553e:	2bc8      	cmp	r3, #200	@ 0xc8
 8005540:	d101      	bne.n	8005546 <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
 8005542:	2301      	movs	r3, #1
 8005544:	e000      	b.n	8005548 <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
 8005546:	2300      	movs	r3, #0
}
 8005548:	4618      	mov	r0, r3
 800554a:	3710      	adds	r7, #16
 800554c:	46bd      	mov	sp, r7
 800554e:	bd80      	pop	{r7, pc}

08005550 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8005550:	b084      	sub	sp, #16
 8005552:	b580      	push	{r7, lr}
 8005554:	b086      	sub	sp, #24
 8005556:	af00      	add	r7, sp, #0
 8005558:	6078      	str	r0, [r7, #4]
 800555a:	f107 0024 	add.w	r0, r7, #36	@ 0x24
 800555e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
 8005562:	2300      	movs	r3, #0
 8005564:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005566:	687b      	ldr	r3, [r7, #4]
 8005568:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  for (i = 0U; i < 15U; i++)
 800556a:	2300      	movs	r3, #0
 800556c:	613b      	str	r3, [r7, #16]
 800556e:	e009      	b.n	8005584 <USB_DevInit+0x34>
  {
    USBx->DIEPTXF[i] = 0U;
 8005570:	687a      	ldr	r2, [r7, #4]
 8005572:	693b      	ldr	r3, [r7, #16]
 8005574:	3340      	adds	r3, #64	@ 0x40
 8005576:	009b      	lsls	r3, r3, #2
 8005578:	4413      	add	r3, r2
 800557a:	2200      	movs	r2, #0
 800557c:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < 15U; i++)
 800557e:	693b      	ldr	r3, [r7, #16]
 8005580:	3301      	adds	r3, #1
 8005582:	613b      	str	r3, [r7, #16]
 8005584:	693b      	ldr	r3, [r7, #16]
 8005586:	2b0e      	cmp	r3, #14
 8005588:	d9f2      	bls.n	8005570 <USB_DevInit+0x20>
    /* Enable HW VBUS sensing */
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
  }
#else
  /* VBUS Sensing setup */
  if (cfg.vbus_sensing_enable == 0U)
 800558a:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 800558e:	2b00      	cmp	r3, #0
 8005590:	d11c      	bne.n	80055cc <USB_DevInit+0x7c>
  {
    /*
     * Disable HW VBUS sensing. VBUS is internally considered to be always
     * at VBUS-Valid level (5V).
     */
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8005592:	68fb      	ldr	r3, [r7, #12]
 8005594:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005598:	685b      	ldr	r3, [r3, #4]
 800559a:	68fa      	ldr	r2, [r7, #12]
 800559c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80055a0:	f043 0302 	orr.w	r3, r3, #2
 80055a4:	6053      	str	r3, [r2, #4]
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 80055a6:	687b      	ldr	r3, [r7, #4]
 80055a8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80055aa:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 80055ae:	687b      	ldr	r3, [r7, #4]
 80055b0:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 80055b2:	687b      	ldr	r3, [r7, #4]
 80055b4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80055b6:	f423 2200 	bic.w	r2, r3, #524288	@ 0x80000
 80055ba:	687b      	ldr	r3, [r7, #4]
 80055bc:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 80055be:	687b      	ldr	r3, [r7, #4]
 80055c0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80055c2:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
 80055c6:	687b      	ldr	r3, [r7, #4]
 80055c8:	639a      	str	r2, [r3, #56]	@ 0x38
 80055ca:	e00b      	b.n	80055e4 <USB_DevInit+0x94>
  }
  else
  {
    /* Enable HW VBUS sensing */
    USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
 80055cc:	687b      	ldr	r3, [r7, #4]
 80055ce:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80055d0:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
 80055d4:	687b      	ldr	r3, [r7, #4]
 80055d6:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 80055d8:	687b      	ldr	r3, [r7, #4]
 80055da:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80055dc:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
 80055e0:	687b      	ldr	r3, [r7, #4]
 80055e2:	639a      	str	r2, [r3, #56]	@ 0x38
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 80055e4:	68fb      	ldr	r3, [r7, #12]
 80055e6:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 80055ea:	461a      	mov	r2, r3
 80055ec:	2300      	movs	r3, #0
 80055ee:	6013      	str	r3, [r2, #0]

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80055f0:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 80055f4:	2b01      	cmp	r3, #1
 80055f6:	d10d      	bne.n	8005614 <USB_DevInit+0xc4>
  {
    if (cfg.speed == USBD_HS_SPEED)
 80055f8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80055fc:	2b00      	cmp	r3, #0
 80055fe:	d104      	bne.n	800560a <USB_DevInit+0xba>
    {
      /* Set Core speed to High speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 8005600:	2100      	movs	r1, #0
 8005602:	6878      	ldr	r0, [r7, #4]
 8005604:	f000 f968 	bl	80058d8 <USB_SetDevSpeed>
 8005608:	e008      	b.n	800561c <USB_DevInit+0xcc>
    }
    else
    {
      /* Set Core speed to Full speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 800560a:	2101      	movs	r1, #1
 800560c:	6878      	ldr	r0, [r7, #4]
 800560e:	f000 f963 	bl	80058d8 <USB_SetDevSpeed>
 8005612:	e003      	b.n	800561c <USB_DevInit+0xcc>
    }
  }
  else
  {
    /* Set Core speed to Full speed mode */
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 8005614:	2103      	movs	r1, #3
 8005616:	6878      	ldr	r0, [r7, #4]
 8005618:	f000 f95e 	bl	80058d8 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 800561c:	2110      	movs	r1, #16
 800561e:	6878      	ldr	r0, [r7, #4]
 8005620:	f000 f8fa 	bl	8005818 <USB_FlushTxFifo>
 8005624:	4603      	mov	r3, r0
 8005626:	2b00      	cmp	r3, #0
 8005628:	d001      	beq.n	800562e <USB_DevInit+0xde>
  {
    ret = HAL_ERROR;
 800562a:	2301      	movs	r3, #1
 800562c:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 800562e:	6878      	ldr	r0, [r7, #4]
 8005630:	f000 f924 	bl	800587c <USB_FlushRxFifo>
 8005634:	4603      	mov	r3, r0
 8005636:	2b00      	cmp	r3, #0
 8005638:	d001      	beq.n	800563e <USB_DevInit+0xee>
  {
    ret = HAL_ERROR;
 800563a:	2301      	movs	r3, #1
 800563c:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 800563e:	68fb      	ldr	r3, [r7, #12]
 8005640:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005644:	461a      	mov	r2, r3
 8005646:	2300      	movs	r3, #0
 8005648:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 800564a:	68fb      	ldr	r3, [r7, #12]
 800564c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005650:	461a      	mov	r2, r3
 8005652:	2300      	movs	r3, #0
 8005654:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 8005656:	68fb      	ldr	r3, [r7, #12]
 8005658:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800565c:	461a      	mov	r2, r3
 800565e:	2300      	movs	r3, #0
 8005660:	61d3      	str	r3, [r2, #28]

  for (i = 0U; i < cfg.dev_endpoints; i++)
 8005662:	2300      	movs	r3, #0
 8005664:	613b      	str	r3, [r7, #16]
 8005666:	e043      	b.n	80056f0 <USB_DevInit+0x1a0>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8005668:	693b      	ldr	r3, [r7, #16]
 800566a:	015a      	lsls	r2, r3, #5
 800566c:	68fb      	ldr	r3, [r7, #12]
 800566e:	4413      	add	r3, r2
 8005670:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005674:	681b      	ldr	r3, [r3, #0]
 8005676:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800567a:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800567e:	d118      	bne.n	80056b2 <USB_DevInit+0x162>
    {
      if (i == 0U)
 8005680:	693b      	ldr	r3, [r7, #16]
 8005682:	2b00      	cmp	r3, #0
 8005684:	d10a      	bne.n	800569c <USB_DevInit+0x14c>
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8005686:	693b      	ldr	r3, [r7, #16]
 8005688:	015a      	lsls	r2, r3, #5
 800568a:	68fb      	ldr	r3, [r7, #12]
 800568c:	4413      	add	r3, r2
 800568e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005692:	461a      	mov	r2, r3
 8005694:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8005698:	6013      	str	r3, [r2, #0]
 800569a:	e013      	b.n	80056c4 <USB_DevInit+0x174>
      }
      else
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 800569c:	693b      	ldr	r3, [r7, #16]
 800569e:	015a      	lsls	r2, r3, #5
 80056a0:	68fb      	ldr	r3, [r7, #12]
 80056a2:	4413      	add	r3, r2
 80056a4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80056a8:	461a      	mov	r2, r3
 80056aa:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 80056ae:	6013      	str	r3, [r2, #0]
 80056b0:	e008      	b.n	80056c4 <USB_DevInit+0x174>
      }
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 80056b2:	693b      	ldr	r3, [r7, #16]
 80056b4:	015a      	lsls	r2, r3, #5
 80056b6:	68fb      	ldr	r3, [r7, #12]
 80056b8:	4413      	add	r3, r2
 80056ba:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80056be:	461a      	mov	r2, r3
 80056c0:	2300      	movs	r3, #0
 80056c2:	6013      	str	r3, [r2, #0]
    }

    USBx_INEP(i)->DIEPTSIZ = 0U;
 80056c4:	693b      	ldr	r3, [r7, #16]
 80056c6:	015a      	lsls	r2, r3, #5
 80056c8:	68fb      	ldr	r3, [r7, #12]
 80056ca:	4413      	add	r3, r2
 80056cc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80056d0:	461a      	mov	r2, r3
 80056d2:	2300      	movs	r3, #0
 80056d4:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 80056d6:	693b      	ldr	r3, [r7, #16]
 80056d8:	015a      	lsls	r2, r3, #5
 80056da:	68fb      	ldr	r3, [r7, #12]
 80056dc:	4413      	add	r3, r2
 80056de:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80056e2:	461a      	mov	r2, r3
 80056e4:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 80056e8:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80056ea:	693b      	ldr	r3, [r7, #16]
 80056ec:	3301      	adds	r3, #1
 80056ee:	613b      	str	r3, [r7, #16]
 80056f0:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 80056f4:	461a      	mov	r2, r3
 80056f6:	693b      	ldr	r3, [r7, #16]
 80056f8:	4293      	cmp	r3, r2
 80056fa:	d3b5      	bcc.n	8005668 <USB_DevInit+0x118>
  }

  for (i = 0U; i < cfg.dev_endpoints; i++)
 80056fc:	2300      	movs	r3, #0
 80056fe:	613b      	str	r3, [r7, #16]
 8005700:	e043      	b.n	800578a <USB_DevInit+0x23a>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8005702:	693b      	ldr	r3, [r7, #16]
 8005704:	015a      	lsls	r2, r3, #5
 8005706:	68fb      	ldr	r3, [r7, #12]
 8005708:	4413      	add	r3, r2
 800570a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800570e:	681b      	ldr	r3, [r3, #0]
 8005710:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8005714:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8005718:	d118      	bne.n	800574c <USB_DevInit+0x1fc>
    {
      if (i == 0U)
 800571a:	693b      	ldr	r3, [r7, #16]
 800571c:	2b00      	cmp	r3, #0
 800571e:	d10a      	bne.n	8005736 <USB_DevInit+0x1e6>
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8005720:	693b      	ldr	r3, [r7, #16]
 8005722:	015a      	lsls	r2, r3, #5
 8005724:	68fb      	ldr	r3, [r7, #12]
 8005726:	4413      	add	r3, r2
 8005728:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800572c:	461a      	mov	r2, r3
 800572e:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8005732:	6013      	str	r3, [r2, #0]
 8005734:	e013      	b.n	800575e <USB_DevInit+0x20e>
      }
      else
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8005736:	693b      	ldr	r3, [r7, #16]
 8005738:	015a      	lsls	r2, r3, #5
 800573a:	68fb      	ldr	r3, [r7, #12]
 800573c:	4413      	add	r3, r2
 800573e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005742:	461a      	mov	r2, r3
 8005744:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8005748:	6013      	str	r3, [r2, #0]
 800574a:	e008      	b.n	800575e <USB_DevInit+0x20e>
      }
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 800574c:	693b      	ldr	r3, [r7, #16]
 800574e:	015a      	lsls	r2, r3, #5
 8005750:	68fb      	ldr	r3, [r7, #12]
 8005752:	4413      	add	r3, r2
 8005754:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005758:	461a      	mov	r2, r3
 800575a:	2300      	movs	r3, #0
 800575c:	6013      	str	r3, [r2, #0]
    }

    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 800575e:	693b      	ldr	r3, [r7, #16]
 8005760:	015a      	lsls	r2, r3, #5
 8005762:	68fb      	ldr	r3, [r7, #12]
 8005764:	4413      	add	r3, r2
 8005766:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800576a:	461a      	mov	r2, r3
 800576c:	2300      	movs	r3, #0
 800576e:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8005770:	693b      	ldr	r3, [r7, #16]
 8005772:	015a      	lsls	r2, r3, #5
 8005774:	68fb      	ldr	r3, [r7, #12]
 8005776:	4413      	add	r3, r2
 8005778:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800577c:	461a      	mov	r2, r3
 800577e:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8005782:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8005784:	693b      	ldr	r3, [r7, #16]
 8005786:	3301      	adds	r3, #1
 8005788:	613b      	str	r3, [r7, #16]
 800578a:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 800578e:	461a      	mov	r2, r3
 8005790:	693b      	ldr	r3, [r7, #16]
 8005792:	4293      	cmp	r3, r2
 8005794:	d3b5      	bcc.n	8005702 <USB_DevInit+0x1b2>
  }

  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8005796:	68fb      	ldr	r3, [r7, #12]
 8005798:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800579c:	691b      	ldr	r3, [r3, #16]
 800579e:	68fa      	ldr	r2, [r7, #12]
 80057a0:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80057a4:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80057a8:	6113      	str	r3, [r2, #16]

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 80057aa:	687b      	ldr	r3, [r7, #4]
 80057ac:	2200      	movs	r2, #0
 80057ae:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 80057b0:	687b      	ldr	r3, [r7, #4]
 80057b2:	f06f 4280 	mvn.w	r2, #1073741824	@ 0x40000000
 80057b6:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 80057b8:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 80057bc:	2b00      	cmp	r3, #0
 80057be:	d105      	bne.n	80057cc <USB_DevInit+0x27c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 80057c0:	687b      	ldr	r3, [r7, #4]
 80057c2:	699b      	ldr	r3, [r3, #24]
 80057c4:	f043 0210 	orr.w	r2, r3, #16
 80057c8:	687b      	ldr	r3, [r7, #4]
 80057ca:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 80057cc:	687b      	ldr	r3, [r7, #4]
 80057ce:	699a      	ldr	r2, [r3, #24]
 80057d0:	4b10      	ldr	r3, [pc, #64]	@ (8005814 <USB_DevInit+0x2c4>)
 80057d2:	4313      	orrs	r3, r2
 80057d4:	687a      	ldr	r2, [r7, #4]
 80057d6:	6193      	str	r3, [r2, #24]
                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;

  if (cfg.Sof_enable != 0U)
 80057d8:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 80057dc:	2b00      	cmp	r3, #0
 80057de:	d005      	beq.n	80057ec <USB_DevInit+0x29c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 80057e0:	687b      	ldr	r3, [r7, #4]
 80057e2:	699b      	ldr	r3, [r3, #24]
 80057e4:	f043 0208 	orr.w	r2, r3, #8
 80057e8:	687b      	ldr	r3, [r7, #4]
 80057ea:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == 1U)
 80057ec:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 80057f0:	2b01      	cmp	r3, #1
 80057f2:	d107      	bne.n	8005804 <USB_DevInit+0x2b4>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 80057f4:	687b      	ldr	r3, [r7, #4]
 80057f6:	699b      	ldr	r3, [r3, #24]
 80057f8:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 80057fc:	f043 0304 	orr.w	r3, r3, #4
 8005800:	687a      	ldr	r2, [r7, #4]
 8005802:	6193      	str	r3, [r2, #24]
  }

  return ret;
 8005804:	7dfb      	ldrb	r3, [r7, #23]
}
 8005806:	4618      	mov	r0, r3
 8005808:	3718      	adds	r7, #24
 800580a:	46bd      	mov	sp, r7
 800580c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8005810:	b004      	add	sp, #16
 8005812:	4770      	bx	lr
 8005814:	803c3800 	.word	0x803c3800

08005818 <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 8005818:	b480      	push	{r7}
 800581a:	b085      	sub	sp, #20
 800581c:	af00      	add	r7, sp, #0
 800581e:	6078      	str	r0, [r7, #4]
 8005820:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 8005822:	2300      	movs	r3, #0
 8005824:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8005826:	68fb      	ldr	r3, [r7, #12]
 8005828:	3301      	adds	r3, #1
 800582a:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 800582c:	68fb      	ldr	r3, [r7, #12]
 800582e:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8005832:	d901      	bls.n	8005838 <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
 8005834:	2303      	movs	r3, #3
 8005836:	e01b      	b.n	8005870 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8005838:	687b      	ldr	r3, [r7, #4]
 800583a:	691b      	ldr	r3, [r3, #16]
 800583c:	2b00      	cmp	r3, #0
 800583e:	daf2      	bge.n	8005826 <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
 8005840:	2300      	movs	r3, #0
 8005842:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8005844:	683b      	ldr	r3, [r7, #0]
 8005846:	019b      	lsls	r3, r3, #6
 8005848:	f043 0220 	orr.w	r2, r3, #32
 800584c:	687b      	ldr	r3, [r7, #4]
 800584e:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8005850:	68fb      	ldr	r3, [r7, #12]
 8005852:	3301      	adds	r3, #1
 8005854:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8005856:	68fb      	ldr	r3, [r7, #12]
 8005858:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 800585c:	d901      	bls.n	8005862 <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
 800585e:	2303      	movs	r3, #3
 8005860:	e006      	b.n	8005870 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8005862:	687b      	ldr	r3, [r7, #4]
 8005864:	691b      	ldr	r3, [r3, #16]
 8005866:	f003 0320 	and.w	r3, r3, #32
 800586a:	2b20      	cmp	r3, #32
 800586c:	d0f0      	beq.n	8005850 <USB_FlushTxFifo+0x38>

  return HAL_OK;
 800586e:	2300      	movs	r3, #0
}
 8005870:	4618      	mov	r0, r3
 8005872:	3714      	adds	r7, #20
 8005874:	46bd      	mov	sp, r7
 8005876:	f85d 7b04 	ldr.w	r7, [sp], #4
 800587a:	4770      	bx	lr

0800587c <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 800587c:	b480      	push	{r7}
 800587e:	b085      	sub	sp, #20
 8005880:	af00      	add	r7, sp, #0
 8005882:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8005884:	2300      	movs	r3, #0
 8005886:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8005888:	68fb      	ldr	r3, [r7, #12]
 800588a:	3301      	adds	r3, #1
 800588c:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 800588e:	68fb      	ldr	r3, [r7, #12]
 8005890:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8005894:	d901      	bls.n	800589a <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
 8005896:	2303      	movs	r3, #3
 8005898:	e018      	b.n	80058cc <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800589a:	687b      	ldr	r3, [r7, #4]
 800589c:	691b      	ldr	r3, [r3, #16]
 800589e:	2b00      	cmp	r3, #0
 80058a0:	daf2      	bge.n	8005888 <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
 80058a2:	2300      	movs	r3, #0
 80058a4:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80058a6:	687b      	ldr	r3, [r7, #4]
 80058a8:	2210      	movs	r2, #16
 80058aa:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 80058ac:	68fb      	ldr	r3, [r7, #12]
 80058ae:	3301      	adds	r3, #1
 80058b0:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 80058b2:	68fb      	ldr	r3, [r7, #12]
 80058b4:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80058b8:	d901      	bls.n	80058be <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
 80058ba:	2303      	movs	r3, #3
 80058bc:	e006      	b.n	80058cc <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 80058be:	687b      	ldr	r3, [r7, #4]
 80058c0:	691b      	ldr	r3, [r3, #16]
 80058c2:	f003 0310 	and.w	r3, r3, #16
 80058c6:	2b10      	cmp	r3, #16
 80058c8:	d0f0      	beq.n	80058ac <USB_FlushRxFifo+0x30>

  return HAL_OK;
 80058ca:	2300      	movs	r3, #0
}
 80058cc:	4618      	mov	r0, r3
 80058ce:	3714      	adds	r7, #20
 80058d0:	46bd      	mov	sp, r7
 80058d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80058d6:	4770      	bx	lr

080058d8 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(const USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
{
 80058d8:	b480      	push	{r7}
 80058da:	b085      	sub	sp, #20
 80058dc:	af00      	add	r7, sp, #0
 80058de:	6078      	str	r0, [r7, #4]
 80058e0:	460b      	mov	r3, r1
 80058e2:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80058e4:	687b      	ldr	r3, [r7, #4]
 80058e6:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG |= speed;
 80058e8:	68fb      	ldr	r3, [r7, #12]
 80058ea:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80058ee:	681a      	ldr	r2, [r3, #0]
 80058f0:	78fb      	ldrb	r3, [r7, #3]
 80058f2:	68f9      	ldr	r1, [r7, #12]
 80058f4:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80058f8:	4313      	orrs	r3, r2
 80058fa:	600b      	str	r3, [r1, #0]
  return HAL_OK;
 80058fc:	2300      	movs	r3, #0
}
 80058fe:	4618      	mov	r0, r3
 8005900:	3714      	adds	r7, #20
 8005902:	46bd      	mov	sp, r7
 8005904:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005908:	4770      	bx	lr

0800590a <USB_GetDevSpeed>:
  *          This parameter can be one of these values:
  *            @arg USBD_HS_SPEED: High speed mode
  *            @arg USBD_FS_SPEED: Full speed mode
  */
uint8_t USB_GetDevSpeed(const USB_OTG_GlobalTypeDef *USBx)
{
 800590a:	b480      	push	{r7}
 800590c:	b087      	sub	sp, #28
 800590e:	af00      	add	r7, sp, #0
 8005910:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005912:	687b      	ldr	r3, [r7, #4]
 8005914:	613b      	str	r3, [r7, #16]
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 8005916:	693b      	ldr	r3, [r7, #16]
 8005918:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800591c:	689b      	ldr	r3, [r3, #8]
 800591e:	f003 0306 	and.w	r3, r3, #6
 8005922:	60fb      	str	r3, [r7, #12]

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8005924:	68fb      	ldr	r3, [r7, #12]
 8005926:	2b00      	cmp	r3, #0
 8005928:	d102      	bne.n	8005930 <USB_GetDevSpeed+0x26>
  {
    speed = USBD_HS_SPEED;
 800592a:	2300      	movs	r3, #0
 800592c:	75fb      	strb	r3, [r7, #23]
 800592e:	e00a      	b.n	8005946 <USB_GetDevSpeed+0x3c>
  }
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 8005930:	68fb      	ldr	r3, [r7, #12]
 8005932:	2b02      	cmp	r3, #2
 8005934:	d002      	beq.n	800593c <USB_GetDevSpeed+0x32>
 8005936:	68fb      	ldr	r3, [r7, #12]
 8005938:	2b06      	cmp	r3, #6
 800593a:	d102      	bne.n	8005942 <USB_GetDevSpeed+0x38>
           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USBD_FS_SPEED;
 800593c:	2302      	movs	r3, #2
 800593e:	75fb      	strb	r3, [r7, #23]
 8005940:	e001      	b.n	8005946 <USB_GetDevSpeed+0x3c>
  }
  else
  {
    speed = 0xFU;
 8005942:	230f      	movs	r3, #15
 8005944:	75fb      	strb	r3, [r7, #23]
  }

  return speed;
 8005946:	7dfb      	ldrb	r3, [r7, #23]
}
 8005948:	4618      	mov	r0, r3
 800594a:	371c      	adds	r7, #28
 800594c:	46bd      	mov	sp, r7
 800594e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005952:	4770      	bx	lr

08005954 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8005954:	b480      	push	{r7}
 8005956:	b085      	sub	sp, #20
 8005958:	af00      	add	r7, sp, #0
 800595a:	6078      	str	r0, [r7, #4]
 800595c:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800595e:	687b      	ldr	r3, [r7, #4]
 8005960:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8005962:	683b      	ldr	r3, [r7, #0]
 8005964:	781b      	ldrb	r3, [r3, #0]
 8005966:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8005968:	683b      	ldr	r3, [r7, #0]
 800596a:	785b      	ldrb	r3, [r3, #1]
 800596c:	2b01      	cmp	r3, #1
 800596e:	d13a      	bne.n	80059e6 <USB_ActivateEndpoint+0x92>
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8005970:	68fb      	ldr	r3, [r7, #12]
 8005972:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005976:	69da      	ldr	r2, [r3, #28]
 8005978:	683b      	ldr	r3, [r7, #0]
 800597a:	781b      	ldrb	r3, [r3, #0]
 800597c:	f003 030f 	and.w	r3, r3, #15
 8005980:	2101      	movs	r1, #1
 8005982:	fa01 f303 	lsl.w	r3, r1, r3
 8005986:	b29b      	uxth	r3, r3
 8005988:	68f9      	ldr	r1, [r7, #12]
 800598a:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800598e:	4313      	orrs	r3, r2
 8005990:	61cb      	str	r3, [r1, #28]

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8005992:	68bb      	ldr	r3, [r7, #8]
 8005994:	015a      	lsls	r2, r3, #5
 8005996:	68fb      	ldr	r3, [r7, #12]
 8005998:	4413      	add	r3, r2
 800599a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800599e:	681b      	ldr	r3, [r3, #0]
 80059a0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80059a4:	2b00      	cmp	r3, #0
 80059a6:	d155      	bne.n	8005a54 <USB_ActivateEndpoint+0x100>
    {
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 80059a8:	68bb      	ldr	r3, [r7, #8]
 80059aa:	015a      	lsls	r2, r3, #5
 80059ac:	68fb      	ldr	r3, [r7, #12]
 80059ae:	4413      	add	r3, r2
 80059b0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80059b4:	681a      	ldr	r2, [r3, #0]
 80059b6:	683b      	ldr	r3, [r7, #0]
 80059b8:	689b      	ldr	r3, [r3, #8]
 80059ba:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 80059be:	683b      	ldr	r3, [r7, #0]
 80059c0:	791b      	ldrb	r3, [r3, #4]
 80059c2:	049b      	lsls	r3, r3, #18
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 80059c4:	4319      	orrs	r1, r3
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 80059c6:	68bb      	ldr	r3, [r7, #8]
 80059c8:	059b      	lsls	r3, r3, #22
 80059ca:	430b      	orrs	r3, r1
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 80059cc:	4313      	orrs	r3, r2
 80059ce:	68ba      	ldr	r2, [r7, #8]
 80059d0:	0151      	lsls	r1, r2, #5
 80059d2:	68fa      	ldr	r2, [r7, #12]
 80059d4:	440a      	add	r2, r1
 80059d6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80059da:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80059de:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80059e2:	6013      	str	r3, [r2, #0]
 80059e4:	e036      	b.n	8005a54 <USB_ActivateEndpoint+0x100>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 80059e6:	68fb      	ldr	r3, [r7, #12]
 80059e8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80059ec:	69da      	ldr	r2, [r3, #28]
 80059ee:	683b      	ldr	r3, [r7, #0]
 80059f0:	781b      	ldrb	r3, [r3, #0]
 80059f2:	f003 030f 	and.w	r3, r3, #15
 80059f6:	2101      	movs	r1, #1
 80059f8:	fa01 f303 	lsl.w	r3, r1, r3
 80059fc:	041b      	lsls	r3, r3, #16
 80059fe:	68f9      	ldr	r1, [r7, #12]
 8005a00:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005a04:	4313      	orrs	r3, r2
 8005a06:	61cb      	str	r3, [r1, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8005a08:	68bb      	ldr	r3, [r7, #8]
 8005a0a:	015a      	lsls	r2, r3, #5
 8005a0c:	68fb      	ldr	r3, [r7, #12]
 8005a0e:	4413      	add	r3, r2
 8005a10:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005a14:	681b      	ldr	r3, [r3, #0]
 8005a16:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8005a1a:	2b00      	cmp	r3, #0
 8005a1c:	d11a      	bne.n	8005a54 <USB_ActivateEndpoint+0x100>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8005a1e:	68bb      	ldr	r3, [r7, #8]
 8005a20:	015a      	lsls	r2, r3, #5
 8005a22:	68fb      	ldr	r3, [r7, #12]
 8005a24:	4413      	add	r3, r2
 8005a26:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005a2a:	681a      	ldr	r2, [r3, #0]
 8005a2c:	683b      	ldr	r3, [r7, #0]
 8005a2e:	689b      	ldr	r3, [r3, #8]
 8005a30:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 8005a34:	683b      	ldr	r3, [r7, #0]
 8005a36:	791b      	ldrb	r3, [r3, #4]
 8005a38:	049b      	lsls	r3, r3, #18
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8005a3a:	430b      	orrs	r3, r1
 8005a3c:	4313      	orrs	r3, r2
 8005a3e:	68ba      	ldr	r2, [r7, #8]
 8005a40:	0151      	lsls	r1, r2, #5
 8005a42:	68fa      	ldr	r2, [r7, #12]
 8005a44:	440a      	add	r2, r1
 8005a46:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005a4a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8005a4e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8005a52:	6013      	str	r3, [r2, #0]
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
 8005a54:	2300      	movs	r3, #0
}
 8005a56:	4618      	mov	r0, r3
 8005a58:	3714      	adds	r7, #20
 8005a5a:	46bd      	mov	sp, r7
 8005a5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a60:	4770      	bx	lr
	...

08005a64 <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8005a64:	b480      	push	{r7}
 8005a66:	b085      	sub	sp, #20
 8005a68:	af00      	add	r7, sp, #0
 8005a6a:	6078      	str	r0, [r7, #4]
 8005a6c:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005a6e:	687b      	ldr	r3, [r7, #4]
 8005a70:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8005a72:	683b      	ldr	r3, [r7, #0]
 8005a74:	781b      	ldrb	r3, [r3, #0]
 8005a76:	60bb      	str	r3, [r7, #8]

  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 8005a78:	683b      	ldr	r3, [r7, #0]
 8005a7a:	785b      	ldrb	r3, [r3, #1]
 8005a7c:	2b01      	cmp	r3, #1
 8005a7e:	d161      	bne.n	8005b44 <USB_DeactivateEndpoint+0xe0>
  {
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8005a80:	68bb      	ldr	r3, [r7, #8]
 8005a82:	015a      	lsls	r2, r3, #5
 8005a84:	68fb      	ldr	r3, [r7, #12]
 8005a86:	4413      	add	r3, r2
 8005a88:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005a8c:	681b      	ldr	r3, [r3, #0]
 8005a8e:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8005a92:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8005a96:	d11f      	bne.n	8005ad8 <USB_DeactivateEndpoint+0x74>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 8005a98:	68bb      	ldr	r3, [r7, #8]
 8005a9a:	015a      	lsls	r2, r3, #5
 8005a9c:	68fb      	ldr	r3, [r7, #12]
 8005a9e:	4413      	add	r3, r2
 8005aa0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005aa4:	681b      	ldr	r3, [r3, #0]
 8005aa6:	68ba      	ldr	r2, [r7, #8]
 8005aa8:	0151      	lsls	r1, r2, #5
 8005aaa:	68fa      	ldr	r2, [r7, #12]
 8005aac:	440a      	add	r2, r1
 8005aae:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005ab2:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8005ab6:	6013      	str	r3, [r2, #0]
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 8005ab8:	68bb      	ldr	r3, [r7, #8]
 8005aba:	015a      	lsls	r2, r3, #5
 8005abc:	68fb      	ldr	r3, [r7, #12]
 8005abe:	4413      	add	r3, r2
 8005ac0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005ac4:	681b      	ldr	r3, [r3, #0]
 8005ac6:	68ba      	ldr	r2, [r7, #8]
 8005ac8:	0151      	lsls	r1, r2, #5
 8005aca:	68fa      	ldr	r2, [r7, #12]
 8005acc:	440a      	add	r2, r1
 8005ace:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005ad2:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8005ad6:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8005ad8:	68fb      	ldr	r3, [r7, #12]
 8005ada:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005ade:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005ae0:	683b      	ldr	r3, [r7, #0]
 8005ae2:	781b      	ldrb	r3, [r3, #0]
 8005ae4:	f003 030f 	and.w	r3, r3, #15
 8005ae8:	2101      	movs	r1, #1
 8005aea:	fa01 f303 	lsl.w	r3, r1, r3
 8005aee:	b29b      	uxth	r3, r3
 8005af0:	43db      	mvns	r3, r3
 8005af2:	68f9      	ldr	r1, [r7, #12]
 8005af4:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005af8:	4013      	ands	r3, r2
 8005afa:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8005afc:	68fb      	ldr	r3, [r7, #12]
 8005afe:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005b02:	69da      	ldr	r2, [r3, #28]
 8005b04:	683b      	ldr	r3, [r7, #0]
 8005b06:	781b      	ldrb	r3, [r3, #0]
 8005b08:	f003 030f 	and.w	r3, r3, #15
 8005b0c:	2101      	movs	r1, #1
 8005b0e:	fa01 f303 	lsl.w	r3, r1, r3
 8005b12:	b29b      	uxth	r3, r3
 8005b14:	43db      	mvns	r3, r3
 8005b16:	68f9      	ldr	r1, [r7, #12]
 8005b18:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005b1c:	4013      	ands	r3, r2
 8005b1e:	61cb      	str	r3, [r1, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8005b20:	68bb      	ldr	r3, [r7, #8]
 8005b22:	015a      	lsls	r2, r3, #5
 8005b24:	68fb      	ldr	r3, [r7, #12]
 8005b26:	4413      	add	r3, r2
 8005b28:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005b2c:	681a      	ldr	r2, [r3, #0]
 8005b2e:	68bb      	ldr	r3, [r7, #8]
 8005b30:	0159      	lsls	r1, r3, #5
 8005b32:	68fb      	ldr	r3, [r7, #12]
 8005b34:	440b      	add	r3, r1
 8005b36:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005b3a:	4619      	mov	r1, r3
 8005b3c:	4b35      	ldr	r3, [pc, #212]	@ (8005c14 <USB_DeactivateEndpoint+0x1b0>)
 8005b3e:	4013      	ands	r3, r2
 8005b40:	600b      	str	r3, [r1, #0]
 8005b42:	e060      	b.n	8005c06 <USB_DeactivateEndpoint+0x1a2>
                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                   USB_OTG_DIEPCTL_EPTYP);
  }
  else
  {
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8005b44:	68bb      	ldr	r3, [r7, #8]
 8005b46:	015a      	lsls	r2, r3, #5
 8005b48:	68fb      	ldr	r3, [r7, #12]
 8005b4a:	4413      	add	r3, r2
 8005b4c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005b50:	681b      	ldr	r3, [r3, #0]
 8005b52:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8005b56:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8005b5a:	d11f      	bne.n	8005b9c <USB_DeactivateEndpoint+0x138>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8005b5c:	68bb      	ldr	r3, [r7, #8]
 8005b5e:	015a      	lsls	r2, r3, #5
 8005b60:	68fb      	ldr	r3, [r7, #12]
 8005b62:	4413      	add	r3, r2
 8005b64:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005b68:	681b      	ldr	r3, [r3, #0]
 8005b6a:	68ba      	ldr	r2, [r7, #8]
 8005b6c:	0151      	lsls	r1, r2, #5
 8005b6e:	68fa      	ldr	r2, [r7, #12]
 8005b70:	440a      	add	r2, r1
 8005b72:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005b76:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8005b7a:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 8005b7c:	68bb      	ldr	r3, [r7, #8]
 8005b7e:	015a      	lsls	r2, r3, #5
 8005b80:	68fb      	ldr	r3, [r7, #12]
 8005b82:	4413      	add	r3, r2
 8005b84:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005b88:	681b      	ldr	r3, [r3, #0]
 8005b8a:	68ba      	ldr	r2, [r7, #8]
 8005b8c:	0151      	lsls	r1, r2, #5
 8005b8e:	68fa      	ldr	r2, [r7, #12]
 8005b90:	440a      	add	r2, r1
 8005b92:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005b96:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8005b9a:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8005b9c:	68fb      	ldr	r3, [r7, #12]
 8005b9e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005ba2:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005ba4:	683b      	ldr	r3, [r7, #0]
 8005ba6:	781b      	ldrb	r3, [r3, #0]
 8005ba8:	f003 030f 	and.w	r3, r3, #15
 8005bac:	2101      	movs	r1, #1
 8005bae:	fa01 f303 	lsl.w	r3, r1, r3
 8005bb2:	041b      	lsls	r3, r3, #16
 8005bb4:	43db      	mvns	r3, r3
 8005bb6:	68f9      	ldr	r1, [r7, #12]
 8005bb8:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005bbc:	4013      	ands	r3, r2
 8005bbe:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8005bc0:	68fb      	ldr	r3, [r7, #12]
 8005bc2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005bc6:	69da      	ldr	r2, [r3, #28]
 8005bc8:	683b      	ldr	r3, [r7, #0]
 8005bca:	781b      	ldrb	r3, [r3, #0]
 8005bcc:	f003 030f 	and.w	r3, r3, #15
 8005bd0:	2101      	movs	r1, #1
 8005bd2:	fa01 f303 	lsl.w	r3, r1, r3
 8005bd6:	041b      	lsls	r3, r3, #16
 8005bd8:	43db      	mvns	r3, r3
 8005bda:	68f9      	ldr	r1, [r7, #12]
 8005bdc:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005be0:	4013      	ands	r3, r2
 8005be2:	61cb      	str	r3, [r1, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8005be4:	68bb      	ldr	r3, [r7, #8]
 8005be6:	015a      	lsls	r2, r3, #5
 8005be8:	68fb      	ldr	r3, [r7, #12]
 8005bea:	4413      	add	r3, r2
 8005bec:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005bf0:	681a      	ldr	r2, [r3, #0]
 8005bf2:	68bb      	ldr	r3, [r7, #8]
 8005bf4:	0159      	lsls	r1, r3, #5
 8005bf6:	68fb      	ldr	r3, [r7, #12]
 8005bf8:	440b      	add	r3, r1
 8005bfa:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005bfe:	4619      	mov	r1, r3
 8005c00:	4b05      	ldr	r3, [pc, #20]	@ (8005c18 <USB_DeactivateEndpoint+0x1b4>)
 8005c02:	4013      	ands	r3, r2
 8005c04:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DOEPCTL_MPSIZ |
                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_EPTYP);
  }

  return HAL_OK;
 8005c06:	2300      	movs	r3, #0
}
 8005c08:	4618      	mov	r0, r3
 8005c0a:	3714      	adds	r7, #20
 8005c0c:	46bd      	mov	sp, r7
 8005c0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005c12:	4770      	bx	lr
 8005c14:	ec337800 	.word	0xec337800
 8005c18:	eff37800 	.word	0xeff37800

08005c1c <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8005c1c:	b580      	push	{r7, lr}
 8005c1e:	b08a      	sub	sp, #40	@ 0x28
 8005c20:	af02      	add	r7, sp, #8
 8005c22:	60f8      	str	r0, [r7, #12]
 8005c24:	60b9      	str	r1, [r7, #8]
 8005c26:	4613      	mov	r3, r2
 8005c28:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005c2a:	68fb      	ldr	r3, [r7, #12]
 8005c2c:	61fb      	str	r3, [r7, #28]
  uint32_t epnum = (uint32_t)ep->num;
 8005c2e:	68bb      	ldr	r3, [r7, #8]
 8005c30:	781b      	ldrb	r3, [r3, #0]
 8005c32:	61bb      	str	r3, [r7, #24]
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
 8005c34:	68bb      	ldr	r3, [r7, #8]
 8005c36:	785b      	ldrb	r3, [r3, #1]
 8005c38:	2b01      	cmp	r3, #1
 8005c3a:	f040 817f 	bne.w	8005f3c <USB_EPStartXfer+0x320>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8005c3e:	68bb      	ldr	r3, [r7, #8]
 8005c40:	691b      	ldr	r3, [r3, #16]
 8005c42:	2b00      	cmp	r3, #0
 8005c44:	d132      	bne.n	8005cac <USB_EPStartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005c46:	69bb      	ldr	r3, [r7, #24]
 8005c48:	015a      	lsls	r2, r3, #5
 8005c4a:	69fb      	ldr	r3, [r7, #28]
 8005c4c:	4413      	add	r3, r2
 8005c4e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005c52:	691b      	ldr	r3, [r3, #16]
 8005c54:	69ba      	ldr	r2, [r7, #24]
 8005c56:	0151      	lsls	r1, r2, #5
 8005c58:	69fa      	ldr	r2, [r7, #28]
 8005c5a:	440a      	add	r2, r1
 8005c5c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005c60:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 8005c64:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 8005c68:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005c6a:	69bb      	ldr	r3, [r7, #24]
 8005c6c:	015a      	lsls	r2, r3, #5
 8005c6e:	69fb      	ldr	r3, [r7, #28]
 8005c70:	4413      	add	r3, r2
 8005c72:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005c76:	691b      	ldr	r3, [r3, #16]
 8005c78:	69ba      	ldr	r2, [r7, #24]
 8005c7a:	0151      	lsls	r1, r2, #5
 8005c7c:	69fa      	ldr	r2, [r7, #28]
 8005c7e:	440a      	add	r2, r1
 8005c80:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005c84:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005c88:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005c8a:	69bb      	ldr	r3, [r7, #24]
 8005c8c:	015a      	lsls	r2, r3, #5
 8005c8e:	69fb      	ldr	r3, [r7, #28]
 8005c90:	4413      	add	r3, r2
 8005c92:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005c96:	691b      	ldr	r3, [r3, #16]
 8005c98:	69ba      	ldr	r2, [r7, #24]
 8005c9a:	0151      	lsls	r1, r2, #5
 8005c9c:	69fa      	ldr	r2, [r7, #28]
 8005c9e:	440a      	add	r2, r1
 8005ca0:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005ca4:	0cdb      	lsrs	r3, r3, #19
 8005ca6:	04db      	lsls	r3, r3, #19
 8005ca8:	6113      	str	r3, [r2, #16]
 8005caa:	e097      	b.n	8005ddc <USB_EPStartXfer+0x1c0>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005cac:	69bb      	ldr	r3, [r7, #24]
 8005cae:	015a      	lsls	r2, r3, #5
 8005cb0:	69fb      	ldr	r3, [r7, #28]
 8005cb2:	4413      	add	r3, r2
 8005cb4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005cb8:	691b      	ldr	r3, [r3, #16]
 8005cba:	69ba      	ldr	r2, [r7, #24]
 8005cbc:	0151      	lsls	r1, r2, #5
 8005cbe:	69fa      	ldr	r2, [r7, #28]
 8005cc0:	440a      	add	r2, r1
 8005cc2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005cc6:	0cdb      	lsrs	r3, r3, #19
 8005cc8:	04db      	lsls	r3, r3, #19
 8005cca:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005ccc:	69bb      	ldr	r3, [r7, #24]
 8005cce:	015a      	lsls	r2, r3, #5
 8005cd0:	69fb      	ldr	r3, [r7, #28]
 8005cd2:	4413      	add	r3, r2
 8005cd4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005cd8:	691b      	ldr	r3, [r3, #16]
 8005cda:	69ba      	ldr	r2, [r7, #24]
 8005cdc:	0151      	lsls	r1, r2, #5
 8005cde:	69fa      	ldr	r2, [r7, #28]
 8005ce0:	440a      	add	r2, r1
 8005ce2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005ce6:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 8005cea:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 8005cee:	6113      	str	r3, [r2, #16]

      if (epnum == 0U)
 8005cf0:	69bb      	ldr	r3, [r7, #24]
 8005cf2:	2b00      	cmp	r3, #0
 8005cf4:	d11a      	bne.n	8005d2c <USB_EPStartXfer+0x110>
      {
        if (ep->xfer_len > ep->maxpacket)
 8005cf6:	68bb      	ldr	r3, [r7, #8]
 8005cf8:	691a      	ldr	r2, [r3, #16]
 8005cfa:	68bb      	ldr	r3, [r7, #8]
 8005cfc:	689b      	ldr	r3, [r3, #8]
 8005cfe:	429a      	cmp	r2, r3
 8005d00:	d903      	bls.n	8005d0a <USB_EPStartXfer+0xee>
        {
          ep->xfer_len = ep->maxpacket;
 8005d02:	68bb      	ldr	r3, [r7, #8]
 8005d04:	689a      	ldr	r2, [r3, #8]
 8005d06:	68bb      	ldr	r3, [r7, #8]
 8005d08:	611a      	str	r2, [r3, #16]
        }

        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005d0a:	69bb      	ldr	r3, [r7, #24]
 8005d0c:	015a      	lsls	r2, r3, #5
 8005d0e:	69fb      	ldr	r3, [r7, #28]
 8005d10:	4413      	add	r3, r2
 8005d12:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005d16:	691b      	ldr	r3, [r3, #16]
 8005d18:	69ba      	ldr	r2, [r7, #24]
 8005d1a:	0151      	lsls	r1, r2, #5
 8005d1c:	69fa      	ldr	r2, [r7, #28]
 8005d1e:	440a      	add	r2, r1
 8005d20:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005d24:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005d28:	6113      	str	r3, [r2, #16]
 8005d2a:	e044      	b.n	8005db6 <USB_EPStartXfer+0x19a>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8005d2c:	68bb      	ldr	r3, [r7, #8]
 8005d2e:	691a      	ldr	r2, [r3, #16]
 8005d30:	68bb      	ldr	r3, [r7, #8]
 8005d32:	689b      	ldr	r3, [r3, #8]
 8005d34:	4413      	add	r3, r2
 8005d36:	1e5a      	subs	r2, r3, #1
 8005d38:	68bb      	ldr	r3, [r7, #8]
 8005d3a:	689b      	ldr	r3, [r3, #8]
 8005d3c:	fbb2 f3f3 	udiv	r3, r2, r3
 8005d40:	82fb      	strh	r3, [r7, #22]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (pktcnt << 19));
 8005d42:	69bb      	ldr	r3, [r7, #24]
 8005d44:	015a      	lsls	r2, r3, #5
 8005d46:	69fb      	ldr	r3, [r7, #28]
 8005d48:	4413      	add	r3, r2
 8005d4a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005d4e:	691a      	ldr	r2, [r3, #16]
 8005d50:	8afb      	ldrh	r3, [r7, #22]
 8005d52:	04d9      	lsls	r1, r3, #19
 8005d54:	4ba4      	ldr	r3, [pc, #656]	@ (8005fe8 <USB_EPStartXfer+0x3cc>)
 8005d56:	400b      	ands	r3, r1
 8005d58:	69b9      	ldr	r1, [r7, #24]
 8005d5a:	0148      	lsls	r0, r1, #5
 8005d5c:	69f9      	ldr	r1, [r7, #28]
 8005d5e:	4401      	add	r1, r0
 8005d60:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8005d64:	4313      	orrs	r3, r2
 8005d66:	610b      	str	r3, [r1, #16]

        if (ep->type == EP_TYPE_ISOC)
 8005d68:	68bb      	ldr	r3, [r7, #8]
 8005d6a:	791b      	ldrb	r3, [r3, #4]
 8005d6c:	2b01      	cmp	r3, #1
 8005d6e:	d122      	bne.n	8005db6 <USB_EPStartXfer+0x19a>
        {
          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8005d70:	69bb      	ldr	r3, [r7, #24]
 8005d72:	015a      	lsls	r2, r3, #5
 8005d74:	69fb      	ldr	r3, [r7, #28]
 8005d76:	4413      	add	r3, r2
 8005d78:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005d7c:	691b      	ldr	r3, [r3, #16]
 8005d7e:	69ba      	ldr	r2, [r7, #24]
 8005d80:	0151      	lsls	r1, r2, #5
 8005d82:	69fa      	ldr	r2, [r7, #28]
 8005d84:	440a      	add	r2, r1
 8005d86:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005d8a:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005d8e:	6113      	str	r3, [r2, #16]
          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (pktcnt << 29));
 8005d90:	69bb      	ldr	r3, [r7, #24]
 8005d92:	015a      	lsls	r2, r3, #5
 8005d94:	69fb      	ldr	r3, [r7, #28]
 8005d96:	4413      	add	r3, r2
 8005d98:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005d9c:	691a      	ldr	r2, [r3, #16]
 8005d9e:	8afb      	ldrh	r3, [r7, #22]
 8005da0:	075b      	lsls	r3, r3, #29
 8005da2:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8005da6:	69b9      	ldr	r1, [r7, #24]
 8005da8:	0148      	lsls	r0, r1, #5
 8005daa:	69f9      	ldr	r1, [r7, #28]
 8005dac:	4401      	add	r1, r0
 8005dae:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8005db2:	4313      	orrs	r3, r2
 8005db4:	610b      	str	r3, [r1, #16]
        }
      }

      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8005db6:	69bb      	ldr	r3, [r7, #24]
 8005db8:	015a      	lsls	r2, r3, #5
 8005dba:	69fb      	ldr	r3, [r7, #28]
 8005dbc:	4413      	add	r3, r2
 8005dbe:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005dc2:	691a      	ldr	r2, [r3, #16]
 8005dc4:	68bb      	ldr	r3, [r7, #8]
 8005dc6:	691b      	ldr	r3, [r3, #16]
 8005dc8:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8005dcc:	69b9      	ldr	r1, [r7, #24]
 8005dce:	0148      	lsls	r0, r1, #5
 8005dd0:	69f9      	ldr	r1, [r7, #28]
 8005dd2:	4401      	add	r1, r0
 8005dd4:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8005dd8:	4313      	orrs	r3, r2
 8005dda:	610b      	str	r3, [r1, #16]
    }

    if (dma == 1U)
 8005ddc:	79fb      	ldrb	r3, [r7, #7]
 8005dde:	2b01      	cmp	r3, #1
 8005de0:	d14b      	bne.n	8005e7a <USB_EPStartXfer+0x25e>
    {
      if ((uint32_t)ep->dma_addr != 0U)
 8005de2:	68bb      	ldr	r3, [r7, #8]
 8005de4:	69db      	ldr	r3, [r3, #28]
 8005de6:	2b00      	cmp	r3, #0
 8005de8:	d009      	beq.n	8005dfe <USB_EPStartXfer+0x1e2>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8005dea:	69bb      	ldr	r3, [r7, #24]
 8005dec:	015a      	lsls	r2, r3, #5
 8005dee:	69fb      	ldr	r3, [r7, #28]
 8005df0:	4413      	add	r3, r2
 8005df2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005df6:	461a      	mov	r2, r3
 8005df8:	68bb      	ldr	r3, [r7, #8]
 8005dfa:	69db      	ldr	r3, [r3, #28]
 8005dfc:	6153      	str	r3, [r2, #20]
      }

      if (ep->type == EP_TYPE_ISOC)
 8005dfe:	68bb      	ldr	r3, [r7, #8]
 8005e00:	791b      	ldrb	r3, [r3, #4]
 8005e02:	2b01      	cmp	r3, #1
 8005e04:	d128      	bne.n	8005e58 <USB_EPStartXfer+0x23c>
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8005e06:	69fb      	ldr	r3, [r7, #28]
 8005e08:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005e0c:	689b      	ldr	r3, [r3, #8]
 8005e0e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8005e12:	2b00      	cmp	r3, #0
 8005e14:	d110      	bne.n	8005e38 <USB_EPStartXfer+0x21c>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8005e16:	69bb      	ldr	r3, [r7, #24]
 8005e18:	015a      	lsls	r2, r3, #5
 8005e1a:	69fb      	ldr	r3, [r7, #28]
 8005e1c:	4413      	add	r3, r2
 8005e1e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e22:	681b      	ldr	r3, [r3, #0]
 8005e24:	69ba      	ldr	r2, [r7, #24]
 8005e26:	0151      	lsls	r1, r2, #5
 8005e28:	69fa      	ldr	r2, [r7, #28]
 8005e2a:	440a      	add	r2, r1
 8005e2c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e30:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8005e34:	6013      	str	r3, [r2, #0]
 8005e36:	e00f      	b.n	8005e58 <USB_EPStartXfer+0x23c>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8005e38:	69bb      	ldr	r3, [r7, #24]
 8005e3a:	015a      	lsls	r2, r3, #5
 8005e3c:	69fb      	ldr	r3, [r7, #28]
 8005e3e:	4413      	add	r3, r2
 8005e40:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e44:	681b      	ldr	r3, [r3, #0]
 8005e46:	69ba      	ldr	r2, [r7, #24]
 8005e48:	0151      	lsls	r1, r2, #5
 8005e4a:	69fa      	ldr	r2, [r7, #28]
 8005e4c:	440a      	add	r2, r1
 8005e4e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e52:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8005e56:	6013      	str	r3, [r2, #0]
        }
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8005e58:	69bb      	ldr	r3, [r7, #24]
 8005e5a:	015a      	lsls	r2, r3, #5
 8005e5c:	69fb      	ldr	r3, [r7, #28]
 8005e5e:	4413      	add	r3, r2
 8005e60:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e64:	681b      	ldr	r3, [r3, #0]
 8005e66:	69ba      	ldr	r2, [r7, #24]
 8005e68:	0151      	lsls	r1, r2, #5
 8005e6a:	69fa      	ldr	r2, [r7, #28]
 8005e6c:	440a      	add	r2, r1
 8005e6e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e72:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 8005e76:	6013      	str	r3, [r2, #0]
 8005e78:	e166      	b.n	8006148 <USB_EPStartXfer+0x52c>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8005e7a:	69bb      	ldr	r3, [r7, #24]
 8005e7c:	015a      	lsls	r2, r3, #5
 8005e7e:	69fb      	ldr	r3, [r7, #28]
 8005e80:	4413      	add	r3, r2
 8005e82:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005e86:	681b      	ldr	r3, [r3, #0]
 8005e88:	69ba      	ldr	r2, [r7, #24]
 8005e8a:	0151      	lsls	r1, r2, #5
 8005e8c:	69fa      	ldr	r2, [r7, #28]
 8005e8e:	440a      	add	r2, r1
 8005e90:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005e94:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 8005e98:	6013      	str	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 8005e9a:	68bb      	ldr	r3, [r7, #8]
 8005e9c:	791b      	ldrb	r3, [r3, #4]
 8005e9e:	2b01      	cmp	r3, #1
 8005ea0:	d015      	beq.n	8005ece <USB_EPStartXfer+0x2b2>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 8005ea2:	68bb      	ldr	r3, [r7, #8]
 8005ea4:	691b      	ldr	r3, [r3, #16]
 8005ea6:	2b00      	cmp	r3, #0
 8005ea8:	f000 814e 	beq.w	8006148 <USB_EPStartXfer+0x52c>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8005eac:	69fb      	ldr	r3, [r7, #28]
 8005eae:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005eb2:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8005eb4:	68bb      	ldr	r3, [r7, #8]
 8005eb6:	781b      	ldrb	r3, [r3, #0]
 8005eb8:	f003 030f 	and.w	r3, r3, #15
 8005ebc:	2101      	movs	r1, #1
 8005ebe:	fa01 f303 	lsl.w	r3, r1, r3
 8005ec2:	69f9      	ldr	r1, [r7, #28]
 8005ec4:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8005ec8:	4313      	orrs	r3, r2
 8005eca:	634b      	str	r3, [r1, #52]	@ 0x34
 8005ecc:	e13c      	b.n	8006148 <USB_EPStartXfer+0x52c>
        }
      }
      else
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8005ece:	69fb      	ldr	r3, [r7, #28]
 8005ed0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8005ed4:	689b      	ldr	r3, [r3, #8]
 8005ed6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8005eda:	2b00      	cmp	r3, #0
 8005edc:	d110      	bne.n	8005f00 <USB_EPStartXfer+0x2e4>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8005ede:	69bb      	ldr	r3, [r7, #24]
 8005ee0:	015a      	lsls	r2, r3, #5
 8005ee2:	69fb      	ldr	r3, [r7, #28]
 8005ee4:	4413      	add	r3, r2
 8005ee6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005eea:	681b      	ldr	r3, [r3, #0]
 8005eec:	69ba      	ldr	r2, [r7, #24]
 8005eee:	0151      	lsls	r1, r2, #5
 8005ef0:	69fa      	ldr	r2, [r7, #28]
 8005ef2:	440a      	add	r2, r1
 8005ef4:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005ef8:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8005efc:	6013      	str	r3, [r2, #0]
 8005efe:	e00f      	b.n	8005f20 <USB_EPStartXfer+0x304>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8005f00:	69bb      	ldr	r3, [r7, #24]
 8005f02:	015a      	lsls	r2, r3, #5
 8005f04:	69fb      	ldr	r3, [r7, #28]
 8005f06:	4413      	add	r3, r2
 8005f08:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8005f0c:	681b      	ldr	r3, [r3, #0]
 8005f0e:	69ba      	ldr	r2, [r7, #24]
 8005f10:	0151      	lsls	r1, r2, #5
 8005f12:	69fa      	ldr	r2, [r7, #28]
 8005f14:	440a      	add	r2, r1
 8005f16:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8005f1a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8005f1e:	6013      	str	r3, [r2, #0]
        }

        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 8005f20:	68bb      	ldr	r3, [r7, #8]
 8005f22:	68d9      	ldr	r1, [r3, #12]
 8005f24:	68bb      	ldr	r3, [r7, #8]
 8005f26:	781a      	ldrb	r2, [r3, #0]
 8005f28:	68bb      	ldr	r3, [r7, #8]
 8005f2a:	691b      	ldr	r3, [r3, #16]
 8005f2c:	b298      	uxth	r0, r3
 8005f2e:	79fb      	ldrb	r3, [r7, #7]
 8005f30:	9300      	str	r3, [sp, #0]
 8005f32:	4603      	mov	r3, r0
 8005f34:	68f8      	ldr	r0, [r7, #12]
 8005f36:	f000 f9b9 	bl	80062ac <USB_WritePacket>
 8005f3a:	e105      	b.n	8006148 <USB_EPStartXfer+0x52c>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8005f3c:	69bb      	ldr	r3, [r7, #24]
 8005f3e:	015a      	lsls	r2, r3, #5
 8005f40:	69fb      	ldr	r3, [r7, #28]
 8005f42:	4413      	add	r3, r2
 8005f44:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005f48:	691b      	ldr	r3, [r3, #16]
 8005f4a:	69ba      	ldr	r2, [r7, #24]
 8005f4c:	0151      	lsls	r1, r2, #5
 8005f4e:	69fa      	ldr	r2, [r7, #28]
 8005f50:	440a      	add	r2, r1
 8005f52:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005f56:	0cdb      	lsrs	r3, r3, #19
 8005f58:	04db      	lsls	r3, r3, #19
 8005f5a:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8005f5c:	69bb      	ldr	r3, [r7, #24]
 8005f5e:	015a      	lsls	r2, r3, #5
 8005f60:	69fb      	ldr	r3, [r7, #28]
 8005f62:	4413      	add	r3, r2
 8005f64:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005f68:	691b      	ldr	r3, [r3, #16]
 8005f6a:	69ba      	ldr	r2, [r7, #24]
 8005f6c:	0151      	lsls	r1, r2, #5
 8005f6e:	69fa      	ldr	r2, [r7, #28]
 8005f70:	440a      	add	r2, r1
 8005f72:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005f76:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 8005f7a:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 8005f7e:	6113      	str	r3, [r2, #16]

    if (epnum == 0U)
 8005f80:	69bb      	ldr	r3, [r7, #24]
 8005f82:	2b00      	cmp	r3, #0
 8005f84:	d132      	bne.n	8005fec <USB_EPStartXfer+0x3d0>
    {
      if (ep->xfer_len > 0U)
 8005f86:	68bb      	ldr	r3, [r7, #8]
 8005f88:	691b      	ldr	r3, [r3, #16]
 8005f8a:	2b00      	cmp	r3, #0
 8005f8c:	d003      	beq.n	8005f96 <USB_EPStartXfer+0x37a>
      {
        ep->xfer_len = ep->maxpacket;
 8005f8e:	68bb      	ldr	r3, [r7, #8]
 8005f90:	689a      	ldr	r2, [r3, #8]
 8005f92:	68bb      	ldr	r3, [r7, #8]
 8005f94:	611a      	str	r2, [r3, #16]
      }

      /* Store transfer size, for EP0 this is equal to endpoint max packet size */
      ep->xfer_size = ep->maxpacket;
 8005f96:	68bb      	ldr	r3, [r7, #8]
 8005f98:	689a      	ldr	r2, [r3, #8]
 8005f9a:	68bb      	ldr	r3, [r7, #8]
 8005f9c:	621a      	str	r2, [r3, #32]

      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 8005f9e:	69bb      	ldr	r3, [r7, #24]
 8005fa0:	015a      	lsls	r2, r3, #5
 8005fa2:	69fb      	ldr	r3, [r7, #28]
 8005fa4:	4413      	add	r3, r2
 8005fa6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005faa:	691a      	ldr	r2, [r3, #16]
 8005fac:	68bb      	ldr	r3, [r7, #8]
 8005fae:	6a1b      	ldr	r3, [r3, #32]
 8005fb0:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8005fb4:	69b9      	ldr	r1, [r7, #24]
 8005fb6:	0148      	lsls	r0, r1, #5
 8005fb8:	69f9      	ldr	r1, [r7, #28]
 8005fba:	4401      	add	r1, r0
 8005fbc:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 8005fc0:	4313      	orrs	r3, r2
 8005fc2:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8005fc4:	69bb      	ldr	r3, [r7, #24]
 8005fc6:	015a      	lsls	r2, r3, #5
 8005fc8:	69fb      	ldr	r3, [r7, #28]
 8005fca:	4413      	add	r3, r2
 8005fcc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8005fd0:	691b      	ldr	r3, [r3, #16]
 8005fd2:	69ba      	ldr	r2, [r7, #24]
 8005fd4:	0151      	lsls	r1, r2, #5
 8005fd6:	69fa      	ldr	r2, [r7, #28]
 8005fd8:	440a      	add	r2, r1
 8005fda:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8005fde:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005fe2:	6113      	str	r3, [r2, #16]
 8005fe4:	e062      	b.n	80060ac <USB_EPStartXfer+0x490>
 8005fe6:	bf00      	nop
 8005fe8:	1ff80000 	.word	0x1ff80000
    }
    else
    {
      if (ep->xfer_len == 0U)
 8005fec:	68bb      	ldr	r3, [r7, #8]
 8005fee:	691b      	ldr	r3, [r3, #16]
 8005ff0:	2b00      	cmp	r3, #0
 8005ff2:	d123      	bne.n	800603c <USB_EPStartXfer+0x420>
      {
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8005ff4:	69bb      	ldr	r3, [r7, #24]
 8005ff6:	015a      	lsls	r2, r3, #5
 8005ff8:	69fb      	ldr	r3, [r7, #28]
 8005ffa:	4413      	add	r3, r2
 8005ffc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006000:	691a      	ldr	r2, [r3, #16]
 8006002:	68bb      	ldr	r3, [r7, #8]
 8006004:	689b      	ldr	r3, [r3, #8]
 8006006:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800600a:	69b9      	ldr	r1, [r7, #24]
 800600c:	0148      	lsls	r0, r1, #5
 800600e:	69f9      	ldr	r1, [r7, #28]
 8006010:	4401      	add	r1, r0
 8006012:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 8006016:	4313      	orrs	r3, r2
 8006018:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800601a:	69bb      	ldr	r3, [r7, #24]
 800601c:	015a      	lsls	r2, r3, #5
 800601e:	69fb      	ldr	r3, [r7, #28]
 8006020:	4413      	add	r3, r2
 8006022:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006026:	691b      	ldr	r3, [r3, #16]
 8006028:	69ba      	ldr	r2, [r7, #24]
 800602a:	0151      	lsls	r1, r2, #5
 800602c:	69fa      	ldr	r2, [r7, #28]
 800602e:	440a      	add	r2, r1
 8006030:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006034:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8006038:	6113      	str	r3, [r2, #16]
 800603a:	e037      	b.n	80060ac <USB_EPStartXfer+0x490>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 800603c:	68bb      	ldr	r3, [r7, #8]
 800603e:	691a      	ldr	r2, [r3, #16]
 8006040:	68bb      	ldr	r3, [r7, #8]
 8006042:	689b      	ldr	r3, [r3, #8]
 8006044:	4413      	add	r3, r2
 8006046:	1e5a      	subs	r2, r3, #1
 8006048:	68bb      	ldr	r3, [r7, #8]
 800604a:	689b      	ldr	r3, [r3, #8]
 800604c:	fbb2 f3f3 	udiv	r3, r2, r3
 8006050:	82fb      	strh	r3, [r7, #22]
        ep->xfer_size = ep->maxpacket * pktcnt;
 8006052:	68bb      	ldr	r3, [r7, #8]
 8006054:	689b      	ldr	r3, [r3, #8]
 8006056:	8afa      	ldrh	r2, [r7, #22]
 8006058:	fb03 f202 	mul.w	r2, r3, r2
 800605c:	68bb      	ldr	r3, [r7, #8]
 800605e:	621a      	str	r2, [r3, #32]

        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8006060:	69bb      	ldr	r3, [r7, #24]
 8006062:	015a      	lsls	r2, r3, #5
 8006064:	69fb      	ldr	r3, [r7, #28]
 8006066:	4413      	add	r3, r2
 8006068:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800606c:	691a      	ldr	r2, [r3, #16]
 800606e:	8afb      	ldrh	r3, [r7, #22]
 8006070:	04d9      	lsls	r1, r3, #19
 8006072:	4b38      	ldr	r3, [pc, #224]	@ (8006154 <USB_EPStartXfer+0x538>)
 8006074:	400b      	ands	r3, r1
 8006076:	69b9      	ldr	r1, [r7, #24]
 8006078:	0148      	lsls	r0, r1, #5
 800607a:	69f9      	ldr	r1, [r7, #28]
 800607c:	4401      	add	r1, r0
 800607e:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 8006082:	4313      	orrs	r3, r2
 8006084:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 8006086:	69bb      	ldr	r3, [r7, #24]
 8006088:	015a      	lsls	r2, r3, #5
 800608a:	69fb      	ldr	r3, [r7, #28]
 800608c:	4413      	add	r3, r2
 800608e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006092:	691a      	ldr	r2, [r3, #16]
 8006094:	68bb      	ldr	r3, [r7, #8]
 8006096:	6a1b      	ldr	r3, [r3, #32]
 8006098:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800609c:	69b9      	ldr	r1, [r7, #24]
 800609e:	0148      	lsls	r0, r1, #5
 80060a0:	69f9      	ldr	r1, [r7, #28]
 80060a2:	4401      	add	r1, r0
 80060a4:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 80060a8:	4313      	orrs	r3, r2
 80060aa:	610b      	str	r3, [r1, #16]
      }
    }

    if (dma == 1U)
 80060ac:	79fb      	ldrb	r3, [r7, #7]
 80060ae:	2b01      	cmp	r3, #1
 80060b0:	d10d      	bne.n	80060ce <USB_EPStartXfer+0x4b2>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
 80060b2:	68bb      	ldr	r3, [r7, #8]
 80060b4:	68db      	ldr	r3, [r3, #12]
 80060b6:	2b00      	cmp	r3, #0
 80060b8:	d009      	beq.n	80060ce <USB_EPStartXfer+0x4b2>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 80060ba:	68bb      	ldr	r3, [r7, #8]
 80060bc:	68d9      	ldr	r1, [r3, #12]
 80060be:	69bb      	ldr	r3, [r7, #24]
 80060c0:	015a      	lsls	r2, r3, #5
 80060c2:	69fb      	ldr	r3, [r7, #28]
 80060c4:	4413      	add	r3, r2
 80060c6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80060ca:	460a      	mov	r2, r1
 80060cc:	615a      	str	r2, [r3, #20]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 80060ce:	68bb      	ldr	r3, [r7, #8]
 80060d0:	791b      	ldrb	r3, [r3, #4]
 80060d2:	2b01      	cmp	r3, #1
 80060d4:	d128      	bne.n	8006128 <USB_EPStartXfer+0x50c>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80060d6:	69fb      	ldr	r3, [r7, #28]
 80060d8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80060dc:	689b      	ldr	r3, [r3, #8]
 80060de:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80060e2:	2b00      	cmp	r3, #0
 80060e4:	d110      	bne.n	8006108 <USB_EPStartXfer+0x4ec>
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 80060e6:	69bb      	ldr	r3, [r7, #24]
 80060e8:	015a      	lsls	r2, r3, #5
 80060ea:	69fb      	ldr	r3, [r7, #28]
 80060ec:	4413      	add	r3, r2
 80060ee:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80060f2:	681b      	ldr	r3, [r3, #0]
 80060f4:	69ba      	ldr	r2, [r7, #24]
 80060f6:	0151      	lsls	r1, r2, #5
 80060f8:	69fa      	ldr	r2, [r7, #28]
 80060fa:	440a      	add	r2, r1
 80060fc:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006100:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8006104:	6013      	str	r3, [r2, #0]
 8006106:	e00f      	b.n	8006128 <USB_EPStartXfer+0x50c>
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 8006108:	69bb      	ldr	r3, [r7, #24]
 800610a:	015a      	lsls	r2, r3, #5
 800610c:	69fb      	ldr	r3, [r7, #28]
 800610e:	4413      	add	r3, r2
 8006110:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006114:	681b      	ldr	r3, [r3, #0]
 8006116:	69ba      	ldr	r2, [r7, #24]
 8006118:	0151      	lsls	r1, r2, #5
 800611a:	69fa      	ldr	r2, [r7, #28]
 800611c:	440a      	add	r2, r1
 800611e:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006122:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8006126:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8006128:	69bb      	ldr	r3, [r7, #24]
 800612a:	015a      	lsls	r2, r3, #5
 800612c:	69fb      	ldr	r3, [r7, #28]
 800612e:	4413      	add	r3, r2
 8006130:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006134:	681b      	ldr	r3, [r3, #0]
 8006136:	69ba      	ldr	r2, [r7, #24]
 8006138:	0151      	lsls	r1, r2, #5
 800613a:	69fa      	ldr	r2, [r7, #28]
 800613c:	440a      	add	r2, r1
 800613e:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006142:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 8006146:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8006148:	2300      	movs	r3, #0
}
 800614a:	4618      	mov	r0, r3
 800614c:	3720      	adds	r7, #32
 800614e:	46bd      	mov	sp, r7
 8006150:	bd80      	pop	{r7, pc}
 8006152:	bf00      	nop
 8006154:	1ff80000 	.word	0x1ff80000

08006158 <USB_EPStopXfer>:
   * @param  USBx  usb device instance
   * @param  ep pointer to endpoint structure
   * @retval HAL status
   */
HAL_StatusTypeDef USB_EPStopXfer(const USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8006158:	b480      	push	{r7}
 800615a:	b087      	sub	sp, #28
 800615c:	af00      	add	r7, sp, #0
 800615e:	6078      	str	r0, [r7, #4]
 8006160:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 8006162:	2300      	movs	r3, #0
 8006164:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 8006166:	2300      	movs	r3, #0
 8006168:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800616a:	687b      	ldr	r3, [r7, #4]
 800616c:	613b      	str	r3, [r7, #16]

  /* IN endpoint */
  if (ep->is_in == 1U)
 800616e:	683b      	ldr	r3, [r7, #0]
 8006170:	785b      	ldrb	r3, [r3, #1]
 8006172:	2b01      	cmp	r3, #1
 8006174:	d14a      	bne.n	800620c <USB_EPStopXfer+0xb4>
  {
    /* EP enable, IN data in FIFO */
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8006176:	683b      	ldr	r3, [r7, #0]
 8006178:	781b      	ldrb	r3, [r3, #0]
 800617a:	015a      	lsls	r2, r3, #5
 800617c:	693b      	ldr	r3, [r7, #16]
 800617e:	4413      	add	r3, r2
 8006180:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006184:	681b      	ldr	r3, [r3, #0]
 8006186:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800618a:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800618e:	f040 8086 	bne.w	800629e <USB_EPStopXfer+0x146>
    {
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 8006192:	683b      	ldr	r3, [r7, #0]
 8006194:	781b      	ldrb	r3, [r3, #0]
 8006196:	015a      	lsls	r2, r3, #5
 8006198:	693b      	ldr	r3, [r7, #16]
 800619a:	4413      	add	r3, r2
 800619c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80061a0:	681b      	ldr	r3, [r3, #0]
 80061a2:	683a      	ldr	r2, [r7, #0]
 80061a4:	7812      	ldrb	r2, [r2, #0]
 80061a6:	0151      	lsls	r1, r2, #5
 80061a8:	693a      	ldr	r2, [r7, #16]
 80061aa:	440a      	add	r2, r1
 80061ac:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80061b0:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 80061b4:	6013      	str	r3, [r2, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 80061b6:	683b      	ldr	r3, [r7, #0]
 80061b8:	781b      	ldrb	r3, [r3, #0]
 80061ba:	015a      	lsls	r2, r3, #5
 80061bc:	693b      	ldr	r3, [r7, #16]
 80061be:	4413      	add	r3, r2
 80061c0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80061c4:	681b      	ldr	r3, [r3, #0]
 80061c6:	683a      	ldr	r2, [r7, #0]
 80061c8:	7812      	ldrb	r2, [r2, #0]
 80061ca:	0151      	lsls	r1, r2, #5
 80061cc:	693a      	ldr	r2, [r7, #16]
 80061ce:	440a      	add	r2, r1
 80061d0:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80061d4:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 80061d8:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 80061da:	68fb      	ldr	r3, [r7, #12]
 80061dc:	3301      	adds	r3, #1
 80061de:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 80061e0:	68fb      	ldr	r3, [r7, #12]
 80061e2:	f242 7210 	movw	r2, #10000	@ 0x2710
 80061e6:	4293      	cmp	r3, r2
 80061e8:	d902      	bls.n	80061f0 <USB_EPStopXfer+0x98>
        {
          ret = HAL_ERROR;
 80061ea:	2301      	movs	r3, #1
 80061ec:	75fb      	strb	r3, [r7, #23]
          break;
 80061ee:	e056      	b.n	800629e <USB_EPStopXfer+0x146>
        }
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 80061f0:	683b      	ldr	r3, [r7, #0]
 80061f2:	781b      	ldrb	r3, [r3, #0]
 80061f4:	015a      	lsls	r2, r3, #5
 80061f6:	693b      	ldr	r3, [r7, #16]
 80061f8:	4413      	add	r3, r2
 80061fa:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80061fe:	681b      	ldr	r3, [r3, #0]
 8006200:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8006204:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8006208:	d0e7      	beq.n	80061da <USB_EPStopXfer+0x82>
 800620a:	e048      	b.n	800629e <USB_EPStopXfer+0x146>
    }
  }
  else /* OUT endpoint */
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800620c:	683b      	ldr	r3, [r7, #0]
 800620e:	781b      	ldrb	r3, [r3, #0]
 8006210:	015a      	lsls	r2, r3, #5
 8006212:	693b      	ldr	r3, [r7, #16]
 8006214:	4413      	add	r3, r2
 8006216:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800621a:	681b      	ldr	r3, [r3, #0]
 800621c:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8006220:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8006224:	d13b      	bne.n	800629e <USB_EPStopXfer+0x146>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 8006226:	683b      	ldr	r3, [r7, #0]
 8006228:	781b      	ldrb	r3, [r3, #0]
 800622a:	015a      	lsls	r2, r3, #5
 800622c:	693b      	ldr	r3, [r7, #16]
 800622e:	4413      	add	r3, r2
 8006230:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006234:	681b      	ldr	r3, [r3, #0]
 8006236:	683a      	ldr	r2, [r7, #0]
 8006238:	7812      	ldrb	r2, [r2, #0]
 800623a:	0151      	lsls	r1, r2, #5
 800623c:	693a      	ldr	r2, [r7, #16]
 800623e:	440a      	add	r2, r1
 8006240:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006244:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8006248:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 800624a:	683b      	ldr	r3, [r7, #0]
 800624c:	781b      	ldrb	r3, [r3, #0]
 800624e:	015a      	lsls	r2, r3, #5
 8006250:	693b      	ldr	r3, [r7, #16]
 8006252:	4413      	add	r3, r2
 8006254:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006258:	681b      	ldr	r3, [r3, #0]
 800625a:	683a      	ldr	r2, [r7, #0]
 800625c:	7812      	ldrb	r2, [r2, #0]
 800625e:	0151      	lsls	r1, r2, #5
 8006260:	693a      	ldr	r2, [r7, #16]
 8006262:	440a      	add	r2, r1
 8006264:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006268:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800626c:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 800626e:	68fb      	ldr	r3, [r7, #12]
 8006270:	3301      	adds	r3, #1
 8006272:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 8006274:	68fb      	ldr	r3, [r7, #12]
 8006276:	f242 7210 	movw	r2, #10000	@ 0x2710
 800627a:	4293      	cmp	r3, r2
 800627c:	d902      	bls.n	8006284 <USB_EPStopXfer+0x12c>
        {
          ret = HAL_ERROR;
 800627e:	2301      	movs	r3, #1
 8006280:	75fb      	strb	r3, [r7, #23]
          break;
 8006282:	e00c      	b.n	800629e <USB_EPStopXfer+0x146>
        }
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 8006284:	683b      	ldr	r3, [r7, #0]
 8006286:	781b      	ldrb	r3, [r3, #0]
 8006288:	015a      	lsls	r2, r3, #5
 800628a:	693b      	ldr	r3, [r7, #16]
 800628c:	4413      	add	r3, r2
 800628e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006292:	681b      	ldr	r3, [r3, #0]
 8006294:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8006298:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800629c:	d0e7      	beq.n	800626e <USB_EPStopXfer+0x116>
    }
  }

  return ret;
 800629e:	7dfb      	ldrb	r3, [r7, #23]
}
 80062a0:	4618      	mov	r0, r3
 80062a2:	371c      	adds	r7, #28
 80062a4:	46bd      	mov	sp, r7
 80062a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062aa:	4770      	bx	lr

080062ac <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 80062ac:	b480      	push	{r7}
 80062ae:	b089      	sub	sp, #36	@ 0x24
 80062b0:	af00      	add	r7, sp, #0
 80062b2:	60f8      	str	r0, [r7, #12]
 80062b4:	60b9      	str	r1, [r7, #8]
 80062b6:	4611      	mov	r1, r2
 80062b8:	461a      	mov	r2, r3
 80062ba:	460b      	mov	r3, r1
 80062bc:	71fb      	strb	r3, [r7, #7]
 80062be:	4613      	mov	r3, r2
 80062c0:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80062c2:	68fb      	ldr	r3, [r7, #12]
 80062c4:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
 80062c6:	68bb      	ldr	r3, [r7, #8]
 80062c8:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 80062ca:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 80062ce:	2b00      	cmp	r3, #0
 80062d0:	d123      	bne.n	800631a <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 80062d2:	88bb      	ldrh	r3, [r7, #4]
 80062d4:	3303      	adds	r3, #3
 80062d6:	089b      	lsrs	r3, r3, #2
 80062d8:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 80062da:	2300      	movs	r3, #0
 80062dc:	61bb      	str	r3, [r7, #24]
 80062de:	e018      	b.n	8006312 <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 80062e0:	79fb      	ldrb	r3, [r7, #7]
 80062e2:	031a      	lsls	r2, r3, #12
 80062e4:	697b      	ldr	r3, [r7, #20]
 80062e6:	4413      	add	r3, r2
 80062e8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80062ec:	461a      	mov	r2, r3
 80062ee:	69fb      	ldr	r3, [r7, #28]
 80062f0:	681b      	ldr	r3, [r3, #0]
 80062f2:	6013      	str	r3, [r2, #0]
      pSrc++;
 80062f4:	69fb      	ldr	r3, [r7, #28]
 80062f6:	3301      	adds	r3, #1
 80062f8:	61fb      	str	r3, [r7, #28]
      pSrc++;
 80062fa:	69fb      	ldr	r3, [r7, #28]
 80062fc:	3301      	adds	r3, #1
 80062fe:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8006300:	69fb      	ldr	r3, [r7, #28]
 8006302:	3301      	adds	r3, #1
 8006304:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8006306:	69fb      	ldr	r3, [r7, #28]
 8006308:	3301      	adds	r3, #1
 800630a:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 800630c:	69bb      	ldr	r3, [r7, #24]
 800630e:	3301      	adds	r3, #1
 8006310:	61bb      	str	r3, [r7, #24]
 8006312:	69ba      	ldr	r2, [r7, #24]
 8006314:	693b      	ldr	r3, [r7, #16]
 8006316:	429a      	cmp	r2, r3
 8006318:	d3e2      	bcc.n	80062e0 <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 800631a:	2300      	movs	r3, #0
}
 800631c:	4618      	mov	r0, r3
 800631e:	3724      	adds	r7, #36	@ 0x24
 8006320:	46bd      	mov	sp, r7
 8006322:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006326:	4770      	bx	lr

08006328 <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 8006328:	b480      	push	{r7}
 800632a:	b08b      	sub	sp, #44	@ 0x2c
 800632c:	af00      	add	r7, sp, #0
 800632e:	60f8      	str	r0, [r7, #12]
 8006330:	60b9      	str	r1, [r7, #8]
 8006332:	4613      	mov	r3, r2
 8006334:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006336:	68fb      	ldr	r3, [r7, #12]
 8006338:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
 800633a:	68bb      	ldr	r3, [r7, #8]
 800633c:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
 800633e:	88fb      	ldrh	r3, [r7, #6]
 8006340:	089b      	lsrs	r3, r3, #2
 8006342:	b29b      	uxth	r3, r3
 8006344:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
 8006346:	88fb      	ldrh	r3, [r7, #6]
 8006348:	f003 0303 	and.w	r3, r3, #3
 800634c:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
 800634e:	2300      	movs	r3, #0
 8006350:	623b      	str	r3, [r7, #32]
 8006352:	e014      	b.n	800637e <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8006354:	69bb      	ldr	r3, [r7, #24]
 8006356:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800635a:	681a      	ldr	r2, [r3, #0]
 800635c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800635e:	601a      	str	r2, [r3, #0]
    pDest++;
 8006360:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006362:	3301      	adds	r3, #1
 8006364:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8006366:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006368:	3301      	adds	r3, #1
 800636a:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 800636c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800636e:	3301      	adds	r3, #1
 8006370:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8006372:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006374:	3301      	adds	r3, #1
 8006376:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0U; i < count32b; i++)
 8006378:	6a3b      	ldr	r3, [r7, #32]
 800637a:	3301      	adds	r3, #1
 800637c:	623b      	str	r3, [r7, #32]
 800637e:	6a3a      	ldr	r2, [r7, #32]
 8006380:	697b      	ldr	r3, [r7, #20]
 8006382:	429a      	cmp	r2, r3
 8006384:	d3e6      	bcc.n	8006354 <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
 8006386:	8bfb      	ldrh	r3, [r7, #30]
 8006388:	2b00      	cmp	r3, #0
 800638a:	d01e      	beq.n	80063ca <USB_ReadPacket+0xa2>
  {
    i = 0U;
 800638c:	2300      	movs	r3, #0
 800638e:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8006390:	69bb      	ldr	r3, [r7, #24]
 8006392:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8006396:	461a      	mov	r2, r3
 8006398:	f107 0310 	add.w	r3, r7, #16
 800639c:	6812      	ldr	r2, [r2, #0]
 800639e:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 80063a0:	693a      	ldr	r2, [r7, #16]
 80063a2:	6a3b      	ldr	r3, [r7, #32]
 80063a4:	b2db      	uxtb	r3, r3
 80063a6:	00db      	lsls	r3, r3, #3
 80063a8:	fa22 f303 	lsr.w	r3, r2, r3
 80063ac:	b2da      	uxtb	r2, r3
 80063ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80063b0:	701a      	strb	r2, [r3, #0]
      i++;
 80063b2:	6a3b      	ldr	r3, [r7, #32]
 80063b4:	3301      	adds	r3, #1
 80063b6:	623b      	str	r3, [r7, #32]
      pDest++;
 80063b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80063ba:	3301      	adds	r3, #1
 80063bc:	627b      	str	r3, [r7, #36]	@ 0x24
      remaining_bytes--;
 80063be:	8bfb      	ldrh	r3, [r7, #30]
 80063c0:	3b01      	subs	r3, #1
 80063c2:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
 80063c4:	8bfb      	ldrh	r3, [r7, #30]
 80063c6:	2b00      	cmp	r3, #0
 80063c8:	d1ea      	bne.n	80063a0 <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
 80063ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 80063cc:	4618      	mov	r0, r3
 80063ce:	372c      	adds	r7, #44	@ 0x2c
 80063d0:	46bd      	mov	sp, r7
 80063d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80063d6:	4770      	bx	lr

080063d8 <USB_EPSetStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 80063d8:	b480      	push	{r7}
 80063da:	b085      	sub	sp, #20
 80063dc:	af00      	add	r7, sp, #0
 80063de:	6078      	str	r0, [r7, #4]
 80063e0:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80063e2:	687b      	ldr	r3, [r7, #4]
 80063e4:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 80063e6:	683b      	ldr	r3, [r7, #0]
 80063e8:	781b      	ldrb	r3, [r3, #0]
 80063ea:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 80063ec:	683b      	ldr	r3, [r7, #0]
 80063ee:	785b      	ldrb	r3, [r3, #1]
 80063f0:	2b01      	cmp	r3, #1
 80063f2:	d12c      	bne.n	800644e <USB_EPSetStall+0x76>
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 80063f4:	68bb      	ldr	r3, [r7, #8]
 80063f6:	015a      	lsls	r2, r3, #5
 80063f8:	68fb      	ldr	r3, [r7, #12]
 80063fa:	4413      	add	r3, r2
 80063fc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006400:	681b      	ldr	r3, [r3, #0]
 8006402:	2b00      	cmp	r3, #0
 8006404:	db12      	blt.n	800642c <USB_EPSetStall+0x54>
 8006406:	68bb      	ldr	r3, [r7, #8]
 8006408:	2b00      	cmp	r3, #0
 800640a:	d00f      	beq.n	800642c <USB_EPSetStall+0x54>
    {
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 800640c:	68bb      	ldr	r3, [r7, #8]
 800640e:	015a      	lsls	r2, r3, #5
 8006410:	68fb      	ldr	r3, [r7, #12]
 8006412:	4413      	add	r3, r2
 8006414:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006418:	681b      	ldr	r3, [r3, #0]
 800641a:	68ba      	ldr	r2, [r7, #8]
 800641c:	0151      	lsls	r1, r2, #5
 800641e:	68fa      	ldr	r2, [r7, #12]
 8006420:	440a      	add	r2, r1
 8006422:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8006426:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 800642a:	6013      	str	r3, [r2, #0]
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 800642c:	68bb      	ldr	r3, [r7, #8]
 800642e:	015a      	lsls	r2, r3, #5
 8006430:	68fb      	ldr	r3, [r7, #12]
 8006432:	4413      	add	r3, r2
 8006434:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006438:	681b      	ldr	r3, [r3, #0]
 800643a:	68ba      	ldr	r2, [r7, #8]
 800643c:	0151      	lsls	r1, r2, #5
 800643e:	68fa      	ldr	r2, [r7, #12]
 8006440:	440a      	add	r2, r1
 8006442:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8006446:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800644a:	6013      	str	r3, [r2, #0]
 800644c:	e02b      	b.n	80064a6 <USB_EPSetStall+0xce>
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 800644e:	68bb      	ldr	r3, [r7, #8]
 8006450:	015a      	lsls	r2, r3, #5
 8006452:	68fb      	ldr	r3, [r7, #12]
 8006454:	4413      	add	r3, r2
 8006456:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800645a:	681b      	ldr	r3, [r3, #0]
 800645c:	2b00      	cmp	r3, #0
 800645e:	db12      	blt.n	8006486 <USB_EPSetStall+0xae>
 8006460:	68bb      	ldr	r3, [r7, #8]
 8006462:	2b00      	cmp	r3, #0
 8006464:	d00f      	beq.n	8006486 <USB_EPSetStall+0xae>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 8006466:	68bb      	ldr	r3, [r7, #8]
 8006468:	015a      	lsls	r2, r3, #5
 800646a:	68fb      	ldr	r3, [r7, #12]
 800646c:	4413      	add	r3, r2
 800646e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006472:	681b      	ldr	r3, [r3, #0]
 8006474:	68ba      	ldr	r2, [r7, #8]
 8006476:	0151      	lsls	r1, r2, #5
 8006478:	68fa      	ldr	r2, [r7, #12]
 800647a:	440a      	add	r2, r1
 800647c:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006480:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8006484:	6013      	str	r3, [r2, #0]
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8006486:	68bb      	ldr	r3, [r7, #8]
 8006488:	015a      	lsls	r2, r3, #5
 800648a:	68fb      	ldr	r3, [r7, #12]
 800648c:	4413      	add	r3, r2
 800648e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006492:	681b      	ldr	r3, [r3, #0]
 8006494:	68ba      	ldr	r2, [r7, #8]
 8006496:	0151      	lsls	r1, r2, #5
 8006498:	68fa      	ldr	r2, [r7, #12]
 800649a:	440a      	add	r2, r1
 800649c:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80064a0:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 80064a4:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 80064a6:	2300      	movs	r3, #0
}
 80064a8:	4618      	mov	r0, r3
 80064aa:	3714      	adds	r7, #20
 80064ac:	46bd      	mov	sp, r7
 80064ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064b2:	4770      	bx	lr

080064b4 <USB_EPClearStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 80064b4:	b480      	push	{r7}
 80064b6:	b085      	sub	sp, #20
 80064b8:	af00      	add	r7, sp, #0
 80064ba:	6078      	str	r0, [r7, #4]
 80064bc:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80064be:	687b      	ldr	r3, [r7, #4]
 80064c0:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 80064c2:	683b      	ldr	r3, [r7, #0]
 80064c4:	781b      	ldrb	r3, [r3, #0]
 80064c6:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 80064c8:	683b      	ldr	r3, [r7, #0]
 80064ca:	785b      	ldrb	r3, [r3, #1]
 80064cc:	2b01      	cmp	r3, #1
 80064ce:	d128      	bne.n	8006522 <USB_EPClearStall+0x6e>
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 80064d0:	68bb      	ldr	r3, [r7, #8]
 80064d2:	015a      	lsls	r2, r3, #5
 80064d4:	68fb      	ldr	r3, [r7, #12]
 80064d6:	4413      	add	r3, r2
 80064d8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80064dc:	681b      	ldr	r3, [r3, #0]
 80064de:	68ba      	ldr	r2, [r7, #8]
 80064e0:	0151      	lsls	r1, r2, #5
 80064e2:	68fa      	ldr	r2, [r7, #12]
 80064e4:	440a      	add	r2, r1
 80064e6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80064ea:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 80064ee:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 80064f0:	683b      	ldr	r3, [r7, #0]
 80064f2:	791b      	ldrb	r3, [r3, #4]
 80064f4:	2b03      	cmp	r3, #3
 80064f6:	d003      	beq.n	8006500 <USB_EPClearStall+0x4c>
 80064f8:	683b      	ldr	r3, [r7, #0]
 80064fa:	791b      	ldrb	r3, [r3, #4]
 80064fc:	2b02      	cmp	r3, #2
 80064fe:	d138      	bne.n	8006572 <USB_EPClearStall+0xbe>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8006500:	68bb      	ldr	r3, [r7, #8]
 8006502:	015a      	lsls	r2, r3, #5
 8006504:	68fb      	ldr	r3, [r7, #12]
 8006506:	4413      	add	r3, r2
 8006508:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800650c:	681b      	ldr	r3, [r3, #0]
 800650e:	68ba      	ldr	r2, [r7, #8]
 8006510:	0151      	lsls	r1, r2, #5
 8006512:	68fa      	ldr	r2, [r7, #12]
 8006514:	440a      	add	r2, r1
 8006516:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800651a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800651e:	6013      	str	r3, [r2, #0]
 8006520:	e027      	b.n	8006572 <USB_EPClearStall+0xbe>
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8006522:	68bb      	ldr	r3, [r7, #8]
 8006524:	015a      	lsls	r2, r3, #5
 8006526:	68fb      	ldr	r3, [r7, #12]
 8006528:	4413      	add	r3, r2
 800652a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800652e:	681b      	ldr	r3, [r3, #0]
 8006530:	68ba      	ldr	r2, [r7, #8]
 8006532:	0151      	lsls	r1, r2, #5
 8006534:	68fa      	ldr	r2, [r7, #12]
 8006536:	440a      	add	r2, r1
 8006538:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800653c:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8006540:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8006542:	683b      	ldr	r3, [r7, #0]
 8006544:	791b      	ldrb	r3, [r3, #4]
 8006546:	2b03      	cmp	r3, #3
 8006548:	d003      	beq.n	8006552 <USB_EPClearStall+0x9e>
 800654a:	683b      	ldr	r3, [r7, #0]
 800654c:	791b      	ldrb	r3, [r3, #4]
 800654e:	2b02      	cmp	r3, #2
 8006550:	d10f      	bne.n	8006572 <USB_EPClearStall+0xbe>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8006552:	68bb      	ldr	r3, [r7, #8]
 8006554:	015a      	lsls	r2, r3, #5
 8006556:	68fb      	ldr	r3, [r7, #12]
 8006558:	4413      	add	r3, r2
 800655a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800655e:	681b      	ldr	r3, [r3, #0]
 8006560:	68ba      	ldr	r2, [r7, #8]
 8006562:	0151      	lsls	r1, r2, #5
 8006564:	68fa      	ldr	r2, [r7, #12]
 8006566:	440a      	add	r2, r1
 8006568:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800656c:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8006570:	6013      	str	r3, [r2, #0]
    }
  }
  return HAL_OK;
 8006572:	2300      	movs	r3, #0
}
 8006574:	4618      	mov	r0, r3
 8006576:	3714      	adds	r7, #20
 8006578:	46bd      	mov	sp, r7
 800657a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800657e:	4770      	bx	lr

08006580 <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetDevAddress(const USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
 8006580:	b480      	push	{r7}
 8006582:	b085      	sub	sp, #20
 8006584:	af00      	add	r7, sp, #0
 8006586:	6078      	str	r0, [r7, #4]
 8006588:	460b      	mov	r3, r1
 800658a:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800658c:	687b      	ldr	r3, [r7, #4]
 800658e:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 8006590:	68fb      	ldr	r3, [r7, #12]
 8006592:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006596:	681b      	ldr	r3, [r3, #0]
 8006598:	68fa      	ldr	r2, [r7, #12]
 800659a:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800659e:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 80065a2:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 80065a4:	68fb      	ldr	r3, [r7, #12]
 80065a6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80065aa:	681a      	ldr	r2, [r3, #0]
 80065ac:	78fb      	ldrb	r3, [r7, #3]
 80065ae:	011b      	lsls	r3, r3, #4
 80065b0:	f403 63fe 	and.w	r3, r3, #2032	@ 0x7f0
 80065b4:	68f9      	ldr	r1, [r7, #12]
 80065b6:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80065ba:	4313      	orrs	r3, r2
 80065bc:	600b      	str	r3, [r1, #0]

  return HAL_OK;
 80065be:	2300      	movs	r3, #0
}
 80065c0:	4618      	mov	r0, r3
 80065c2:	3714      	adds	r7, #20
 80065c4:	46bd      	mov	sp, r7
 80065c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80065ca:	4770      	bx	lr

080065cc <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevConnect(const USB_OTG_GlobalTypeDef *USBx)
{
 80065cc:	b480      	push	{r7}
 80065ce:	b085      	sub	sp, #20
 80065d0:	af00      	add	r7, sp, #0
 80065d2:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80065d4:	687b      	ldr	r3, [r7, #4]
 80065d6:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 80065d8:	68fb      	ldr	r3, [r7, #12]
 80065da:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 80065de:	681b      	ldr	r3, [r3, #0]
 80065e0:	68fa      	ldr	r2, [r7, #12]
 80065e2:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 80065e6:	f023 0303 	bic.w	r3, r3, #3
 80065ea:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 80065ec:	68fb      	ldr	r3, [r7, #12]
 80065ee:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80065f2:	685b      	ldr	r3, [r3, #4]
 80065f4:	68fa      	ldr	r2, [r7, #12]
 80065f6:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80065fa:	f023 0302 	bic.w	r3, r3, #2
 80065fe:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 8006600:	2300      	movs	r3, #0
}
 8006602:	4618      	mov	r0, r3
 8006604:	3714      	adds	r7, #20
 8006606:	46bd      	mov	sp, r7
 8006608:	f85d 7b04 	ldr.w	r7, [sp], #4
 800660c:	4770      	bx	lr

0800660e <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevDisconnect(const USB_OTG_GlobalTypeDef *USBx)
{
 800660e:	b480      	push	{r7}
 8006610:	b085      	sub	sp, #20
 8006612:	af00      	add	r7, sp, #0
 8006614:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006616:	687b      	ldr	r3, [r7, #4]
 8006618:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 800661a:	68fb      	ldr	r3, [r7, #12]
 800661c:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8006620:	681b      	ldr	r3, [r3, #0]
 8006622:	68fa      	ldr	r2, [r7, #12]
 8006624:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 8006628:	f023 0303 	bic.w	r3, r3, #3
 800662c:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 800662e:	68fb      	ldr	r3, [r7, #12]
 8006630:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006634:	685b      	ldr	r3, [r3, #4]
 8006636:	68fa      	ldr	r2, [r7, #12]
 8006638:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800663c:	f043 0302 	orr.w	r3, r3, #2
 8006640:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 8006642:	2300      	movs	r3, #0
}
 8006644:	4618      	mov	r0, r3
 8006646:	3714      	adds	r7, #20
 8006648:	46bd      	mov	sp, r7
 800664a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800664e:	4770      	bx	lr

08006650 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
 8006650:	b480      	push	{r7}
 8006652:	b085      	sub	sp, #20
 8006654:	af00      	add	r7, sp, #0
 8006656:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 8006658:	687b      	ldr	r3, [r7, #4]
 800665a:	695b      	ldr	r3, [r3, #20]
 800665c:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 800665e:	687b      	ldr	r3, [r7, #4]
 8006660:	699b      	ldr	r3, [r3, #24]
 8006662:	68fa      	ldr	r2, [r7, #12]
 8006664:	4013      	ands	r3, r2
 8006666:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 8006668:	68fb      	ldr	r3, [r7, #12]
}
 800666a:	4618      	mov	r0, r3
 800666c:	3714      	adds	r7, #20
 800666e:	46bd      	mov	sp, r7
 8006670:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006674:	4770      	bx	lr

08006676 <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device OUT EP interrupt status
  */
uint32_t USB_ReadDevAllOutEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 8006676:	b480      	push	{r7}
 8006678:	b085      	sub	sp, #20
 800667a:	af00      	add	r7, sp, #0
 800667c:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800667e:	687b      	ldr	r3, [r7, #4]
 8006680:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 8006682:	68fb      	ldr	r3, [r7, #12]
 8006684:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006688:	699b      	ldr	r3, [r3, #24]
 800668a:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 800668c:	68fb      	ldr	r3, [r7, #12]
 800668e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006692:	69db      	ldr	r3, [r3, #28]
 8006694:	68ba      	ldr	r2, [r7, #8]
 8006696:	4013      	ands	r3, r2
 8006698:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xffff0000U) >> 16);
 800669a:	68bb      	ldr	r3, [r7, #8]
 800669c:	0c1b      	lsrs	r3, r3, #16
}
 800669e:	4618      	mov	r0, r3
 80066a0:	3714      	adds	r7, #20
 80066a2:	46bd      	mov	sp, r7
 80066a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066a8:	4770      	bx	lr

080066aa <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device IN EP interrupt status
  */
uint32_t USB_ReadDevAllInEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 80066aa:	b480      	push	{r7}
 80066ac:	b085      	sub	sp, #20
 80066ae:	af00      	add	r7, sp, #0
 80066b0:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80066b2:	687b      	ldr	r3, [r7, #4]
 80066b4:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 80066b6:	68fb      	ldr	r3, [r7, #12]
 80066b8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80066bc:	699b      	ldr	r3, [r3, #24]
 80066be:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 80066c0:	68fb      	ldr	r3, [r7, #12]
 80066c2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80066c6:	69db      	ldr	r3, [r3, #28]
 80066c8:	68ba      	ldr	r2, [r7, #8]
 80066ca:	4013      	ands	r3, r2
 80066cc:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xFFFFU));
 80066ce:	68bb      	ldr	r3, [r7, #8]
 80066d0:	b29b      	uxth	r3, r3
}
 80066d2:	4618      	mov	r0, r3
 80066d4:	3714      	adds	r7, #20
 80066d6:	46bd      	mov	sp, r7
 80066d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066dc:	4770      	bx	lr

080066de <USB_ReadDevOutEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 80066de:	b480      	push	{r7}
 80066e0:	b085      	sub	sp, #20
 80066e2:	af00      	add	r7, sp, #0
 80066e4:	6078      	str	r0, [r7, #4]
 80066e6:	460b      	mov	r3, r1
 80066e8:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80066ea:	687b      	ldr	r3, [r7, #4]
 80066ec:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 80066ee:	78fb      	ldrb	r3, [r7, #3]
 80066f0:	015a      	lsls	r2, r3, #5
 80066f2:	68fb      	ldr	r3, [r7, #12]
 80066f4:	4413      	add	r3, r2
 80066f6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80066fa:	689b      	ldr	r3, [r3, #8]
 80066fc:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DOEPMSK;
 80066fe:	68fb      	ldr	r3, [r7, #12]
 8006700:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006704:	695b      	ldr	r3, [r3, #20]
 8006706:	68ba      	ldr	r2, [r7, #8]
 8006708:	4013      	ands	r3, r2
 800670a:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 800670c:	68bb      	ldr	r3, [r7, #8]
}
 800670e:	4618      	mov	r0, r3
 8006710:	3714      	adds	r7, #20
 8006712:	46bd      	mov	sp, r7
 8006714:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006718:	4770      	bx	lr

0800671a <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 800671a:	b480      	push	{r7}
 800671c:	b087      	sub	sp, #28
 800671e:	af00      	add	r7, sp, #0
 8006720:	6078      	str	r0, [r7, #4]
 8006722:	460b      	mov	r3, r1
 8006724:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006726:	687b      	ldr	r3, [r7, #4]
 8006728:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg;
  uint32_t msk;
  uint32_t emp;

  msk = USBx_DEVICE->DIEPMSK;
 800672a:	697b      	ldr	r3, [r7, #20]
 800672c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8006730:	691b      	ldr	r3, [r3, #16]
 8006732:	613b      	str	r3, [r7, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
 8006734:	697b      	ldr	r3, [r7, #20]
 8006736:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800673a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800673c:	60fb      	str	r3, [r7, #12]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 800673e:	78fb      	ldrb	r3, [r7, #3]
 8006740:	f003 030f 	and.w	r3, r3, #15
 8006744:	68fa      	ldr	r2, [r7, #12]
 8006746:	fa22 f303 	lsr.w	r3, r2, r3
 800674a:	01db      	lsls	r3, r3, #7
 800674c:	b2db      	uxtb	r3, r3
 800674e:	693a      	ldr	r2, [r7, #16]
 8006750:	4313      	orrs	r3, r2
 8006752:	613b      	str	r3, [r7, #16]
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8006754:	78fb      	ldrb	r3, [r7, #3]
 8006756:	015a      	lsls	r2, r3, #5
 8006758:	697b      	ldr	r3, [r7, #20]
 800675a:	4413      	add	r3, r2
 800675c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8006760:	689b      	ldr	r3, [r3, #8]
 8006762:	693a      	ldr	r2, [r7, #16]
 8006764:	4013      	ands	r3, r2
 8006766:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 8006768:	68bb      	ldr	r3, [r7, #8]
}
 800676a:	4618      	mov	r0, r3
 800676c:	371c      	adds	r7, #28
 800676e:	46bd      	mov	sp, r7
 8006770:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006774:	4770      	bx	lr

08006776 <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
 8006776:	b480      	push	{r7}
 8006778:	b083      	sub	sp, #12
 800677a:	af00      	add	r7, sp, #0
 800677c:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 800677e:	687b      	ldr	r3, [r7, #4]
 8006780:	695b      	ldr	r3, [r3, #20]
 8006782:	f003 0301 	and.w	r3, r3, #1
}
 8006786:	4618      	mov	r0, r3
 8006788:	370c      	adds	r7, #12
 800678a:	46bd      	mov	sp, r7
 800678c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006790:	4770      	bx	lr

08006792 <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateSetup(const USB_OTG_GlobalTypeDef *USBx)
{
 8006792:	b480      	push	{r7}
 8006794:	b085      	sub	sp, #20
 8006796:	af00      	add	r7, sp, #0
 8006798:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800679a:	687b      	ldr	r3, [r7, #4]
 800679c:	60fb      	str	r3, [r7, #12]

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 800679e:	68fb      	ldr	r3, [r7, #12]
 80067a0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80067a4:	681b      	ldr	r3, [r3, #0]
 80067a6:	68fa      	ldr	r2, [r7, #12]
 80067a8:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80067ac:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 80067b0:	f023 0307 	bic.w	r3, r3, #7
 80067b4:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 80067b6:	68fb      	ldr	r3, [r7, #12]
 80067b8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80067bc:	685b      	ldr	r3, [r3, #4]
 80067be:	68fa      	ldr	r2, [r7, #12]
 80067c0:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80067c4:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80067c8:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 80067ca:	2300      	movs	r3, #0
}
 80067cc:	4618      	mov	r0, r3
 80067ce:	3714      	adds	r7, #20
 80067d0:	46bd      	mov	sp, r7
 80067d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067d6:	4770      	bx	lr

080067d8 <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(const USB_OTG_GlobalTypeDef *USBx, uint8_t dma, const uint8_t *psetup)
{
 80067d8:	b480      	push	{r7}
 80067da:	b087      	sub	sp, #28
 80067dc:	af00      	add	r7, sp, #0
 80067de:	60f8      	str	r0, [r7, #12]
 80067e0:	460b      	mov	r3, r1
 80067e2:	607a      	str	r2, [r7, #4]
 80067e4:	72fb      	strb	r3, [r7, #11]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80067e6:	68fb      	ldr	r3, [r7, #12]
 80067e8:	617b      	str	r3, [r7, #20]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 80067ea:	68fb      	ldr	r3, [r7, #12]
 80067ec:	333c      	adds	r3, #60	@ 0x3c
 80067ee:	3304      	adds	r3, #4
 80067f0:	681b      	ldr	r3, [r3, #0]
 80067f2:	613b      	str	r3, [r7, #16]

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 80067f4:	693b      	ldr	r3, [r7, #16]
 80067f6:	4a26      	ldr	r2, [pc, #152]	@ (8006890 <USB_EP0_OutStart+0xb8>)
 80067f8:	4293      	cmp	r3, r2
 80067fa:	d90a      	bls.n	8006812 <USB_EP0_OutStart+0x3a>
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 80067fc:	697b      	ldr	r3, [r7, #20]
 80067fe:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006802:	681b      	ldr	r3, [r3, #0]
 8006804:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8006808:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800680c:	d101      	bne.n	8006812 <USB_EP0_OutStart+0x3a>
    {
      return HAL_OK;
 800680e:	2300      	movs	r3, #0
 8006810:	e037      	b.n	8006882 <USB_EP0_OutStart+0xaa>
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8006812:	697b      	ldr	r3, [r7, #20]
 8006814:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006818:	461a      	mov	r2, r3
 800681a:	2300      	movs	r3, #0
 800681c:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800681e:	697b      	ldr	r3, [r7, #20]
 8006820:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006824:	691b      	ldr	r3, [r3, #16]
 8006826:	697a      	ldr	r2, [r7, #20]
 8006828:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800682c:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8006830:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8006832:	697b      	ldr	r3, [r7, #20]
 8006834:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006838:	691b      	ldr	r3, [r3, #16]
 800683a:	697a      	ldr	r2, [r7, #20]
 800683c:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006840:	f043 0318 	orr.w	r3, r3, #24
 8006844:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 8006846:	697b      	ldr	r3, [r7, #20]
 8006848:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800684c:	691b      	ldr	r3, [r3, #16]
 800684e:	697a      	ldr	r2, [r7, #20]
 8006850:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8006854:	f043 43c0 	orr.w	r3, r3, #1610612736	@ 0x60000000
 8006858:	6113      	str	r3, [r2, #16]

  if (dma == 1U)
 800685a:	7afb      	ldrb	r3, [r7, #11]
 800685c:	2b01      	cmp	r3, #1
 800685e:	d10f      	bne.n	8006880 <USB_EP0_OutStart+0xa8>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 8006860:	697b      	ldr	r3, [r7, #20]
 8006862:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006866:	461a      	mov	r2, r3
 8006868:	687b      	ldr	r3, [r7, #4]
 800686a:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 800686c:	697b      	ldr	r3, [r7, #20]
 800686e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8006872:	681b      	ldr	r3, [r3, #0]
 8006874:	697a      	ldr	r2, [r7, #20]
 8006876:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800687a:	f043 2380 	orr.w	r3, r3, #2147516416	@ 0x80008000
 800687e:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8006880:	2300      	movs	r3, #0
}
 8006882:	4618      	mov	r0, r3
 8006884:	371c      	adds	r7, #28
 8006886:	46bd      	mov	sp, r7
 8006888:	f85d 7b04 	ldr.w	r7, [sp], #4
 800688c:	4770      	bx	lr
 800688e:	bf00      	nop
 8006890:	4f54300a 	.word	0x4f54300a

08006894 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8006894:	b480      	push	{r7}
 8006896:	b085      	sub	sp, #20
 8006898:	af00      	add	r7, sp, #0
 800689a:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 800689c:	2300      	movs	r3, #0
 800689e:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 80068a0:	68fb      	ldr	r3, [r7, #12]
 80068a2:	3301      	adds	r3, #1
 80068a4:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 80068a6:	68fb      	ldr	r3, [r7, #12]
 80068a8:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80068ac:	d901      	bls.n	80068b2 <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 80068ae:	2303      	movs	r3, #3
 80068b0:	e01b      	b.n	80068ea <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80068b2:	687b      	ldr	r3, [r7, #4]
 80068b4:	691b      	ldr	r3, [r3, #16]
 80068b6:	2b00      	cmp	r3, #0
 80068b8:	daf2      	bge.n	80068a0 <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 80068ba:	2300      	movs	r3, #0
 80068bc:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80068be:	687b      	ldr	r3, [r7, #4]
 80068c0:	691b      	ldr	r3, [r3, #16]
 80068c2:	f043 0201 	orr.w	r2, r3, #1
 80068c6:	687b      	ldr	r3, [r7, #4]
 80068c8:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 80068ca:	68fb      	ldr	r3, [r7, #12]
 80068cc:	3301      	adds	r3, #1
 80068ce:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 80068d0:	68fb      	ldr	r3, [r7, #12]
 80068d2:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 80068d6:	d901      	bls.n	80068dc <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 80068d8:	2303      	movs	r3, #3
 80068da:	e006      	b.n	80068ea <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80068dc:	687b      	ldr	r3, [r7, #4]
 80068de:	691b      	ldr	r3, [r3, #16]
 80068e0:	f003 0301 	and.w	r3, r3, #1
 80068e4:	2b01      	cmp	r3, #1
 80068e6:	d0f0      	beq.n	80068ca <USB_CoreReset+0x36>

  return HAL_OK;
 80068e8:	2300      	movs	r3, #0
}
 80068ea:	4618      	mov	r0, r3
 80068ec:	3714      	adds	r7, #20
 80068ee:	46bd      	mov	sp, r7
 80068f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80068f4:	4770      	bx	lr
	...

080068f8 <USBD_CDC_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80068f8:	b580      	push	{r7, lr}
 80068fa:	b084      	sub	sp, #16
 80068fc:	af00      	add	r7, sp, #0
 80068fe:	6078      	str	r0, [r7, #4]
 8006900:	460b      	mov	r3, r1
 8006902:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  USBD_CDC_HandleTypeDef *hcdc;

  hcdc = (USBD_CDC_HandleTypeDef *)USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 8006904:	f44f 7007 	mov.w	r0, #540	@ 0x21c
 8006908:	f021 fc52 	bl	80281b0 <USBD_static_malloc>
 800690c:	60f8      	str	r0, [r7, #12]

  if (hcdc == NULL)
 800690e:	68fb      	ldr	r3, [r7, #12]
 8006910:	2b00      	cmp	r3, #0
 8006912:	d109      	bne.n	8006928 <USBD_CDC_Init+0x30>
  {
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8006914:	687b      	ldr	r3, [r7, #4]
 8006916:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800691a:	687b      	ldr	r3, [r7, #4]
 800691c:	32b0      	adds	r2, #176	@ 0xb0
 800691e:	2100      	movs	r1, #0
 8006920:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    return (uint8_t)USBD_EMEM;
 8006924:	2302      	movs	r3, #2
 8006926:	e0d4      	b.n	8006ad2 <USBD_CDC_Init+0x1da>
  }

  (void)USBD_memset(hcdc, 0, sizeof(USBD_CDC_HandleTypeDef));
 8006928:	f44f 7207 	mov.w	r2, #540	@ 0x21c
 800692c:	2100      	movs	r1, #0
 800692e:	68f8      	ldr	r0, [r7, #12]
 8006930:	f021 fdce 	bl	80284d0 <memset>

  pdev->pClassDataCmsit[pdev->classId] = (void *)hcdc;
 8006934:	687b      	ldr	r3, [r7, #4]
 8006936:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800693a:	687b      	ldr	r3, [r7, #4]
 800693c:	32b0      	adds	r2, #176	@ 0xb0
 800693e:	68f9      	ldr	r1, [r7, #12]
 8006940:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 8006944:	687b      	ldr	r3, [r7, #4]
 8006946:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800694a:	687b      	ldr	r3, [r7, #4]
 800694c:	32b0      	adds	r2, #176	@ 0xb0
 800694e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8006952:	687b      	ldr	r3, [r7, #4]
 8006954:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8006958:	687b      	ldr	r3, [r7, #4]
 800695a:	7c1b      	ldrb	r3, [r3, #16]
 800695c:	2b00      	cmp	r3, #0
 800695e:	d138      	bne.n	80069d2 <USBD_CDC_Init+0xda>
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 8006960:	4b5e      	ldr	r3, [pc, #376]	@ (8006adc <USBD_CDC_Init+0x1e4>)
 8006962:	7819      	ldrb	r1, [r3, #0]
 8006964:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8006968:	2202      	movs	r2, #2
 800696a:	6878      	ldr	r0, [r7, #4]
 800696c:	f021 fafd 	bl	8027f6a <USBD_LL_OpenEP>
                         CDC_DATA_HS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 8006970:	4b5a      	ldr	r3, [pc, #360]	@ (8006adc <USBD_CDC_Init+0x1e4>)
 8006972:	781b      	ldrb	r3, [r3, #0]
 8006974:	f003 020f 	and.w	r2, r3, #15
 8006978:	6879      	ldr	r1, [r7, #4]
 800697a:	4613      	mov	r3, r2
 800697c:	009b      	lsls	r3, r3, #2
 800697e:	4413      	add	r3, r2
 8006980:	009b      	lsls	r3, r3, #2
 8006982:	440b      	add	r3, r1
 8006984:	3324      	adds	r3, #36	@ 0x24
 8006986:	2201      	movs	r2, #1
 8006988:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 800698a:	4b55      	ldr	r3, [pc, #340]	@ (8006ae0 <USBD_CDC_Init+0x1e8>)
 800698c:	7819      	ldrb	r1, [r3, #0]
 800698e:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8006992:	2202      	movs	r2, #2
 8006994:	6878      	ldr	r0, [r7, #4]
 8006996:	f021 fae8 	bl	8027f6a <USBD_LL_OpenEP>
                         CDC_DATA_HS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 800699a:	4b51      	ldr	r3, [pc, #324]	@ (8006ae0 <USBD_CDC_Init+0x1e8>)
 800699c:	781b      	ldrb	r3, [r3, #0]
 800699e:	f003 020f 	and.w	r2, r3, #15
 80069a2:	6879      	ldr	r1, [r7, #4]
 80069a4:	4613      	mov	r3, r2
 80069a6:	009b      	lsls	r3, r3, #2
 80069a8:	4413      	add	r3, r2
 80069aa:	009b      	lsls	r3, r3, #2
 80069ac:	440b      	add	r3, r1
 80069ae:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 80069b2:	2201      	movs	r2, #1
 80069b4:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CDC CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 80069b6:	4b4b      	ldr	r3, [pc, #300]	@ (8006ae4 <USBD_CDC_Init+0x1ec>)
 80069b8:	781b      	ldrb	r3, [r3, #0]
 80069ba:	f003 020f 	and.w	r2, r3, #15
 80069be:	6879      	ldr	r1, [r7, #4]
 80069c0:	4613      	mov	r3, r2
 80069c2:	009b      	lsls	r3, r3, #2
 80069c4:	4413      	add	r3, r2
 80069c6:	009b      	lsls	r3, r3, #2
 80069c8:	440b      	add	r3, r1
 80069ca:	3326      	adds	r3, #38	@ 0x26
 80069cc:	2210      	movs	r2, #16
 80069ce:	801a      	strh	r2, [r3, #0]
 80069d0:	e035      	b.n	8006a3e <USBD_CDC_Init+0x146>
  }
  else
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 80069d2:	4b42      	ldr	r3, [pc, #264]	@ (8006adc <USBD_CDC_Init+0x1e4>)
 80069d4:	7819      	ldrb	r1, [r3, #0]
 80069d6:	2340      	movs	r3, #64	@ 0x40
 80069d8:	2202      	movs	r2, #2
 80069da:	6878      	ldr	r0, [r7, #4]
 80069dc:	f021 fac5 	bl	8027f6a <USBD_LL_OpenEP>
                         CDC_DATA_FS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 80069e0:	4b3e      	ldr	r3, [pc, #248]	@ (8006adc <USBD_CDC_Init+0x1e4>)
 80069e2:	781b      	ldrb	r3, [r3, #0]
 80069e4:	f003 020f 	and.w	r2, r3, #15
 80069e8:	6879      	ldr	r1, [r7, #4]
 80069ea:	4613      	mov	r3, r2
 80069ec:	009b      	lsls	r3, r3, #2
 80069ee:	4413      	add	r3, r2
 80069f0:	009b      	lsls	r3, r3, #2
 80069f2:	440b      	add	r3, r1
 80069f4:	3324      	adds	r3, #36	@ 0x24
 80069f6:	2201      	movs	r2, #1
 80069f8:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 80069fa:	4b39      	ldr	r3, [pc, #228]	@ (8006ae0 <USBD_CDC_Init+0x1e8>)
 80069fc:	7819      	ldrb	r1, [r3, #0]
 80069fe:	2340      	movs	r3, #64	@ 0x40
 8006a00:	2202      	movs	r2, #2
 8006a02:	6878      	ldr	r0, [r7, #4]
 8006a04:	f021 fab1 	bl	8027f6a <USBD_LL_OpenEP>
                         CDC_DATA_FS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 8006a08:	4b35      	ldr	r3, [pc, #212]	@ (8006ae0 <USBD_CDC_Init+0x1e8>)
 8006a0a:	781b      	ldrb	r3, [r3, #0]
 8006a0c:	f003 020f 	and.w	r2, r3, #15
 8006a10:	6879      	ldr	r1, [r7, #4]
 8006a12:	4613      	mov	r3, r2
 8006a14:	009b      	lsls	r3, r3, #2
 8006a16:	4413      	add	r3, r2
 8006a18:	009b      	lsls	r3, r3, #2
 8006a1a:	440b      	add	r3, r1
 8006a1c:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8006a20:	2201      	movs	r2, #1
 8006a22:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_FS_BINTERVAL;
 8006a24:	4b2f      	ldr	r3, [pc, #188]	@ (8006ae4 <USBD_CDC_Init+0x1ec>)
 8006a26:	781b      	ldrb	r3, [r3, #0]
 8006a28:	f003 020f 	and.w	r2, r3, #15
 8006a2c:	6879      	ldr	r1, [r7, #4]
 8006a2e:	4613      	mov	r3, r2
 8006a30:	009b      	lsls	r3, r3, #2
 8006a32:	4413      	add	r3, r2
 8006a34:	009b      	lsls	r3, r3, #2
 8006a36:	440b      	add	r3, r1
 8006a38:	3326      	adds	r3, #38	@ 0x26
 8006a3a:	2210      	movs	r2, #16
 8006a3c:	801a      	strh	r2, [r3, #0]
  }

  /* Open Command IN EP */
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8006a3e:	4b29      	ldr	r3, [pc, #164]	@ (8006ae4 <USBD_CDC_Init+0x1ec>)
 8006a40:	7819      	ldrb	r1, [r3, #0]
 8006a42:	2308      	movs	r3, #8
 8006a44:	2203      	movs	r2, #3
 8006a46:	6878      	ldr	r0, [r7, #4]
 8006a48:	f021 fa8f 	bl	8027f6a <USBD_LL_OpenEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 1U;
 8006a4c:	4b25      	ldr	r3, [pc, #148]	@ (8006ae4 <USBD_CDC_Init+0x1ec>)
 8006a4e:	781b      	ldrb	r3, [r3, #0]
 8006a50:	f003 020f 	and.w	r2, r3, #15
 8006a54:	6879      	ldr	r1, [r7, #4]
 8006a56:	4613      	mov	r3, r2
 8006a58:	009b      	lsls	r3, r3, #2
 8006a5a:	4413      	add	r3, r2
 8006a5c:	009b      	lsls	r3, r3, #2
 8006a5e:	440b      	add	r3, r1
 8006a60:	3324      	adds	r3, #36	@ 0x24
 8006a62:	2201      	movs	r2, #1
 8006a64:	801a      	strh	r2, [r3, #0]

  hcdc->RxBuffer = NULL;
 8006a66:	68fb      	ldr	r3, [r7, #12]
 8006a68:	2200      	movs	r2, #0
 8006a6a:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204

  /* Init  physical Interface components */
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8006a6e:	687b      	ldr	r3, [r7, #4]
 8006a70:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006a74:	687a      	ldr	r2, [r7, #4]
 8006a76:	33b0      	adds	r3, #176	@ 0xb0
 8006a78:	009b      	lsls	r3, r3, #2
 8006a7a:	4413      	add	r3, r2
 8006a7c:	685b      	ldr	r3, [r3, #4]
 8006a7e:	681b      	ldr	r3, [r3, #0]
 8006a80:	4798      	blx	r3

  /* Init Xfer states */
  hcdc->TxState = 0U;
 8006a82:	68fb      	ldr	r3, [r7, #12]
 8006a84:	2200      	movs	r2, #0
 8006a86:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214
  hcdc->RxState = 0U;
 8006a8a:	68fb      	ldr	r3, [r7, #12]
 8006a8c:	2200      	movs	r2, #0
 8006a8e:	f8c3 2218 	str.w	r2, [r3, #536]	@ 0x218

  if (hcdc->RxBuffer == NULL)
 8006a92:	68fb      	ldr	r3, [r7, #12]
 8006a94:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
 8006a98:	2b00      	cmp	r3, #0
 8006a9a:	d101      	bne.n	8006aa0 <USBD_CDC_Init+0x1a8>
  {
    return (uint8_t)USBD_EMEM;
 8006a9c:	2302      	movs	r3, #2
 8006a9e:	e018      	b.n	8006ad2 <USBD_CDC_Init+0x1da>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8006aa0:	687b      	ldr	r3, [r7, #4]
 8006aa2:	7c1b      	ldrb	r3, [r3, #16]
 8006aa4:	2b00      	cmp	r3, #0
 8006aa6:	d10a      	bne.n	8006abe <USBD_CDC_Init+0x1c6>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8006aa8:	4b0d      	ldr	r3, [pc, #52]	@ (8006ae0 <USBD_CDC_Init+0x1e8>)
 8006aaa:	7819      	ldrb	r1, [r3, #0]
 8006aac:	68fb      	ldr	r3, [r7, #12]
 8006aae:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8006ab2:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8006ab6:	6878      	ldr	r0, [r7, #4]
 8006ab8:	f021 fb46 	bl	8028148 <USBD_LL_PrepareReceive>
 8006abc:	e008      	b.n	8006ad0 <USBD_CDC_Init+0x1d8>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8006abe:	4b08      	ldr	r3, [pc, #32]	@ (8006ae0 <USBD_CDC_Init+0x1e8>)
 8006ac0:	7819      	ldrb	r1, [r3, #0]
 8006ac2:	68fb      	ldr	r3, [r7, #12]
 8006ac4:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8006ac8:	2340      	movs	r3, #64	@ 0x40
 8006aca:	6878      	ldr	r0, [r7, #4]
 8006acc:	f021 fb3c 	bl	8028148 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 8006ad0:	2300      	movs	r3, #0
}
 8006ad2:	4618      	mov	r0, r3
 8006ad4:	3710      	adds	r7, #16
 8006ad6:	46bd      	mov	sp, r7
 8006ad8:	bd80      	pop	{r7, pc}
 8006ada:	bf00      	nop
 8006adc:	200000ab 	.word	0x200000ab
 8006ae0:	200000ac 	.word	0x200000ac
 8006ae4:	200000ad 	.word	0x200000ad

08006ae8 <USBD_CDC_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8006ae8:	b580      	push	{r7, lr}
 8006aea:	b082      	sub	sp, #8
 8006aec:	af00      	add	r7, sp, #0
 8006aee:	6078      	str	r0, [r7, #4]
 8006af0:	460b      	mov	r3, r1
 8006af2:	70fb      	strb	r3, [r7, #3]
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  /* Close EP IN */
  (void)USBD_LL_CloseEP(pdev, CDCInEpAdd);
 8006af4:	4b3a      	ldr	r3, [pc, #232]	@ (8006be0 <USBD_CDC_DeInit+0xf8>)
 8006af6:	781b      	ldrb	r3, [r3, #0]
 8006af8:	4619      	mov	r1, r3
 8006afa:	6878      	ldr	r0, [r7, #4]
 8006afc:	f021 fa5b 	bl	8027fb6 <USBD_LL_CloseEP>
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 8006b00:	4b37      	ldr	r3, [pc, #220]	@ (8006be0 <USBD_CDC_DeInit+0xf8>)
 8006b02:	781b      	ldrb	r3, [r3, #0]
 8006b04:	f003 020f 	and.w	r2, r3, #15
 8006b08:	6879      	ldr	r1, [r7, #4]
 8006b0a:	4613      	mov	r3, r2
 8006b0c:	009b      	lsls	r3, r3, #2
 8006b0e:	4413      	add	r3, r2
 8006b10:	009b      	lsls	r3, r3, #2
 8006b12:	440b      	add	r3, r1
 8006b14:	3324      	adds	r3, #36	@ 0x24
 8006b16:	2200      	movs	r2, #0
 8006b18:	801a      	strh	r2, [r3, #0]

  /* Close EP OUT */
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 8006b1a:	4b32      	ldr	r3, [pc, #200]	@ (8006be4 <USBD_CDC_DeInit+0xfc>)
 8006b1c:	781b      	ldrb	r3, [r3, #0]
 8006b1e:	4619      	mov	r1, r3
 8006b20:	6878      	ldr	r0, [r7, #4]
 8006b22:	f021 fa48 	bl	8027fb6 <USBD_LL_CloseEP>
  pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 0U;
 8006b26:	4b2f      	ldr	r3, [pc, #188]	@ (8006be4 <USBD_CDC_DeInit+0xfc>)
 8006b28:	781b      	ldrb	r3, [r3, #0]
 8006b2a:	f003 020f 	and.w	r2, r3, #15
 8006b2e:	6879      	ldr	r1, [r7, #4]
 8006b30:	4613      	mov	r3, r2
 8006b32:	009b      	lsls	r3, r3, #2
 8006b34:	4413      	add	r3, r2
 8006b36:	009b      	lsls	r3, r3, #2
 8006b38:	440b      	add	r3, r1
 8006b3a:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8006b3e:	2200      	movs	r2, #0
 8006b40:	801a      	strh	r2, [r3, #0]

  /* Close Command IN EP */
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 8006b42:	4b29      	ldr	r3, [pc, #164]	@ (8006be8 <USBD_CDC_DeInit+0x100>)
 8006b44:	781b      	ldrb	r3, [r3, #0]
 8006b46:	4619      	mov	r1, r3
 8006b48:	6878      	ldr	r0, [r7, #4]
 8006b4a:	f021 fa34 	bl	8027fb6 <USBD_LL_CloseEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 0U;
 8006b4e:	4b26      	ldr	r3, [pc, #152]	@ (8006be8 <USBD_CDC_DeInit+0x100>)
 8006b50:	781b      	ldrb	r3, [r3, #0]
 8006b52:	f003 020f 	and.w	r2, r3, #15
 8006b56:	6879      	ldr	r1, [r7, #4]
 8006b58:	4613      	mov	r3, r2
 8006b5a:	009b      	lsls	r3, r3, #2
 8006b5c:	4413      	add	r3, r2
 8006b5e:	009b      	lsls	r3, r3, #2
 8006b60:	440b      	add	r3, r1
 8006b62:	3324      	adds	r3, #36	@ 0x24
 8006b64:	2200      	movs	r2, #0
 8006b66:	801a      	strh	r2, [r3, #0]
  pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = 0U;
 8006b68:	4b1f      	ldr	r3, [pc, #124]	@ (8006be8 <USBD_CDC_DeInit+0x100>)
 8006b6a:	781b      	ldrb	r3, [r3, #0]
 8006b6c:	f003 020f 	and.w	r2, r3, #15
 8006b70:	6879      	ldr	r1, [r7, #4]
 8006b72:	4613      	mov	r3, r2
 8006b74:	009b      	lsls	r3, r3, #2
 8006b76:	4413      	add	r3, r2
 8006b78:	009b      	lsls	r3, r3, #2
 8006b7a:	440b      	add	r3, r1
 8006b7c:	3326      	adds	r3, #38	@ 0x26
 8006b7e:	2200      	movs	r2, #0
 8006b80:	801a      	strh	r2, [r3, #0]

  /* DeInit  physical Interface components */
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 8006b82:	687b      	ldr	r3, [r7, #4]
 8006b84:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006b88:	687b      	ldr	r3, [r7, #4]
 8006b8a:	32b0      	adds	r2, #176	@ 0xb0
 8006b8c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006b90:	2b00      	cmp	r3, #0
 8006b92:	d01f      	beq.n	8006bd4 <USBD_CDC_DeInit+0xec>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit();
 8006b94:	687b      	ldr	r3, [r7, #4]
 8006b96:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006b9a:	687a      	ldr	r2, [r7, #4]
 8006b9c:	33b0      	adds	r3, #176	@ 0xb0
 8006b9e:	009b      	lsls	r3, r3, #2
 8006ba0:	4413      	add	r3, r2
 8006ba2:	685b      	ldr	r3, [r3, #4]
 8006ba4:	685b      	ldr	r3, [r3, #4]
 8006ba6:	4798      	blx	r3
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 8006ba8:	687b      	ldr	r3, [r7, #4]
 8006baa:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006bae:	687b      	ldr	r3, [r7, #4]
 8006bb0:	32b0      	adds	r2, #176	@ 0xb0
 8006bb2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006bb6:	4618      	mov	r0, r3
 8006bb8:	f021 fb08 	bl	80281cc <USBD_static_free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8006bbc:	687b      	ldr	r3, [r7, #4]
 8006bbe:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006bc2:	687b      	ldr	r3, [r7, #4]
 8006bc4:	32b0      	adds	r2, #176	@ 0xb0
 8006bc6:	2100      	movs	r1, #0
 8006bc8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    pdev->pClassData = NULL;
 8006bcc:	687b      	ldr	r3, [r7, #4]
 8006bce:	2200      	movs	r2, #0
 8006bd0:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  }

  return (uint8_t)USBD_OK;
 8006bd4:	2300      	movs	r3, #0
}
 8006bd6:	4618      	mov	r0, r3
 8006bd8:	3708      	adds	r7, #8
 8006bda:	46bd      	mov	sp, r7
 8006bdc:	bd80      	pop	{r7, pc}
 8006bde:	bf00      	nop
 8006be0:	200000ab 	.word	0x200000ab
 8006be4:	200000ac 	.word	0x200000ac
 8006be8:	200000ad 	.word	0x200000ad

08006bec <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t USBD_CDC_Setup(USBD_HandleTypeDef *pdev,
                              USBD_SetupReqTypedef *req)
{
 8006bec:	b580      	push	{r7, lr}
 8006bee:	b086      	sub	sp, #24
 8006bf0:	af00      	add	r7, sp, #0
 8006bf2:	6078      	str	r0, [r7, #4]
 8006bf4:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8006bf6:	687b      	ldr	r3, [r7, #4]
 8006bf8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006bfc:	687b      	ldr	r3, [r7, #4]
 8006bfe:	32b0      	adds	r2, #176	@ 0xb0
 8006c00:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006c04:	613b      	str	r3, [r7, #16]
  uint16_t len;
  uint8_t ifalt = 0U;
 8006c06:	2300      	movs	r3, #0
 8006c08:	737b      	strb	r3, [r7, #13]
  uint16_t status_info = 0U;
 8006c0a:	2300      	movs	r3, #0
 8006c0c:	817b      	strh	r3, [r7, #10]
  USBD_StatusTypeDef ret = USBD_OK;
 8006c0e:	2300      	movs	r3, #0
 8006c10:	75fb      	strb	r3, [r7, #23]

  if (hcdc == NULL)
 8006c12:	693b      	ldr	r3, [r7, #16]
 8006c14:	2b00      	cmp	r3, #0
 8006c16:	d101      	bne.n	8006c1c <USBD_CDC_Setup+0x30>
  {
    return (uint8_t)USBD_FAIL;
 8006c18:	2303      	movs	r3, #3
 8006c1a:	e0bf      	b.n	8006d9c <USBD_CDC_Setup+0x1b0>
  }

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006c1c:	683b      	ldr	r3, [r7, #0]
 8006c1e:	781b      	ldrb	r3, [r3, #0]
 8006c20:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8006c24:	2b00      	cmp	r3, #0
 8006c26:	d050      	beq.n	8006cca <USBD_CDC_Setup+0xde>
 8006c28:	2b20      	cmp	r3, #32
 8006c2a:	f040 80af 	bne.w	8006d8c <USBD_CDC_Setup+0x1a0>
  {
    case USB_REQ_TYPE_CLASS:
      if (req->wLength != 0U)
 8006c2e:	683b      	ldr	r3, [r7, #0]
 8006c30:	88db      	ldrh	r3, [r3, #6]
 8006c32:	2b00      	cmp	r3, #0
 8006c34:	d03a      	beq.n	8006cac <USBD_CDC_Setup+0xc0>
      {
        if ((req->bmRequest & 0x80U) != 0U)
 8006c36:	683b      	ldr	r3, [r7, #0]
 8006c38:	781b      	ldrb	r3, [r3, #0]
 8006c3a:	b25b      	sxtb	r3, r3
 8006c3c:	2b00      	cmp	r3, #0
 8006c3e:	da1b      	bge.n	8006c78 <USBD_CDC_Setup+0x8c>
        {
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8006c40:	687b      	ldr	r3, [r7, #4]
 8006c42:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006c46:	687a      	ldr	r2, [r7, #4]
 8006c48:	33b0      	adds	r3, #176	@ 0xb0
 8006c4a:	009b      	lsls	r3, r3, #2
 8006c4c:	4413      	add	r3, r2
 8006c4e:	685b      	ldr	r3, [r3, #4]
 8006c50:	689b      	ldr	r3, [r3, #8]
 8006c52:	683a      	ldr	r2, [r7, #0]
 8006c54:	7850      	ldrb	r0, [r2, #1]
                                                                           (uint8_t *)hcdc->data,
 8006c56:	6939      	ldr	r1, [r7, #16]
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8006c58:	683a      	ldr	r2, [r7, #0]
 8006c5a:	88d2      	ldrh	r2, [r2, #6]
 8006c5c:	4798      	blx	r3
                                                                           req->wLength);

          len = MIN(CDC_REQ_MAX_DATA_SIZE, req->wLength);
 8006c5e:	683b      	ldr	r3, [r7, #0]
 8006c60:	88db      	ldrh	r3, [r3, #6]
 8006c62:	2b07      	cmp	r3, #7
 8006c64:	bf28      	it	cs
 8006c66:	2307      	movcs	r3, #7
 8006c68:	81fb      	strh	r3, [r7, #14]
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, len);
 8006c6a:	693b      	ldr	r3, [r7, #16]
 8006c6c:	89fa      	ldrh	r2, [r7, #14]
 8006c6e:	4619      	mov	r1, r3
 8006c70:	6878      	ldr	r0, [r7, #4]
 8006c72:	f001 fd93 	bl	800879c <USBD_CtlSendData>
      else
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
                                                                         (uint8_t *)req, 0U);
      }
      break;
 8006c76:	e090      	b.n	8006d9a <USBD_CDC_Setup+0x1ae>
          hcdc->CmdOpCode = req->bRequest;
 8006c78:	683b      	ldr	r3, [r7, #0]
 8006c7a:	785a      	ldrb	r2, [r3, #1]
 8006c7c:	693b      	ldr	r3, [r7, #16]
 8006c7e:	f883 2200 	strb.w	r2, [r3, #512]	@ 0x200
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 8006c82:	683b      	ldr	r3, [r7, #0]
 8006c84:	88db      	ldrh	r3, [r3, #6]
 8006c86:	2b3f      	cmp	r3, #63	@ 0x3f
 8006c88:	d803      	bhi.n	8006c92 <USBD_CDC_Setup+0xa6>
 8006c8a:	683b      	ldr	r3, [r7, #0]
 8006c8c:	88db      	ldrh	r3, [r3, #6]
 8006c8e:	b2da      	uxtb	r2, r3
 8006c90:	e000      	b.n	8006c94 <USBD_CDC_Setup+0xa8>
 8006c92:	2240      	movs	r2, #64	@ 0x40
 8006c94:	693b      	ldr	r3, [r7, #16]
 8006c96:	f883 2201 	strb.w	r2, [r3, #513]	@ 0x201
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 8006c9a:	6939      	ldr	r1, [r7, #16]
 8006c9c:	693b      	ldr	r3, [r7, #16]
 8006c9e:	f893 3201 	ldrb.w	r3, [r3, #513]	@ 0x201
 8006ca2:	461a      	mov	r2, r3
 8006ca4:	6878      	ldr	r0, [r7, #4]
 8006ca6:	f001 fda5 	bl	80087f4 <USBD_CtlPrepareRx>
      break;
 8006caa:	e076      	b.n	8006d9a <USBD_CDC_Setup+0x1ae>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8006cac:	687b      	ldr	r3, [r7, #4]
 8006cae:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006cb2:	687a      	ldr	r2, [r7, #4]
 8006cb4:	33b0      	adds	r3, #176	@ 0xb0
 8006cb6:	009b      	lsls	r3, r3, #2
 8006cb8:	4413      	add	r3, r2
 8006cba:	685b      	ldr	r3, [r3, #4]
 8006cbc:	689b      	ldr	r3, [r3, #8]
 8006cbe:	683a      	ldr	r2, [r7, #0]
 8006cc0:	7850      	ldrb	r0, [r2, #1]
 8006cc2:	2200      	movs	r2, #0
 8006cc4:	6839      	ldr	r1, [r7, #0]
 8006cc6:	4798      	blx	r3
      break;
 8006cc8:	e067      	b.n	8006d9a <USBD_CDC_Setup+0x1ae>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8006cca:	683b      	ldr	r3, [r7, #0]
 8006ccc:	785b      	ldrb	r3, [r3, #1]
 8006cce:	2b0b      	cmp	r3, #11
 8006cd0:	d851      	bhi.n	8006d76 <USBD_CDC_Setup+0x18a>
 8006cd2:	a201      	add	r2, pc, #4	@ (adr r2, 8006cd8 <USBD_CDC_Setup+0xec>)
 8006cd4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006cd8:	08006d09 	.word	0x08006d09
 8006cdc:	08006d85 	.word	0x08006d85
 8006ce0:	08006d77 	.word	0x08006d77
 8006ce4:	08006d77 	.word	0x08006d77
 8006ce8:	08006d77 	.word	0x08006d77
 8006cec:	08006d77 	.word	0x08006d77
 8006cf0:	08006d77 	.word	0x08006d77
 8006cf4:	08006d77 	.word	0x08006d77
 8006cf8:	08006d77 	.word	0x08006d77
 8006cfc:	08006d77 	.word	0x08006d77
 8006d00:	08006d33 	.word	0x08006d33
 8006d04:	08006d5d 	.word	0x08006d5d
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006d08:	687b      	ldr	r3, [r7, #4]
 8006d0a:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8006d0e:	b2db      	uxtb	r3, r3
 8006d10:	2b03      	cmp	r3, #3
 8006d12:	d107      	bne.n	8006d24 <USBD_CDC_Setup+0x138>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8006d14:	f107 030a 	add.w	r3, r7, #10
 8006d18:	2202      	movs	r2, #2
 8006d1a:	4619      	mov	r1, r3
 8006d1c:	6878      	ldr	r0, [r7, #4]
 8006d1e:	f001 fd3d 	bl	800879c <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8006d22:	e032      	b.n	8006d8a <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8006d24:	6839      	ldr	r1, [r7, #0]
 8006d26:	6878      	ldr	r0, [r7, #4]
 8006d28:	f001 fcbb 	bl	80086a2 <USBD_CtlError>
            ret = USBD_FAIL;
 8006d2c:	2303      	movs	r3, #3
 8006d2e:	75fb      	strb	r3, [r7, #23]
          break;
 8006d30:	e02b      	b.n	8006d8a <USBD_CDC_Setup+0x19e>

        case USB_REQ_GET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006d32:	687b      	ldr	r3, [r7, #4]
 8006d34:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8006d38:	b2db      	uxtb	r3, r3
 8006d3a:	2b03      	cmp	r3, #3
 8006d3c:	d107      	bne.n	8006d4e <USBD_CDC_Setup+0x162>
          {
            (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 8006d3e:	f107 030d 	add.w	r3, r7, #13
 8006d42:	2201      	movs	r2, #1
 8006d44:	4619      	mov	r1, r3
 8006d46:	6878      	ldr	r0, [r7, #4]
 8006d48:	f001 fd28 	bl	800879c <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8006d4c:	e01d      	b.n	8006d8a <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8006d4e:	6839      	ldr	r1, [r7, #0]
 8006d50:	6878      	ldr	r0, [r7, #4]
 8006d52:	f001 fca6 	bl	80086a2 <USBD_CtlError>
            ret = USBD_FAIL;
 8006d56:	2303      	movs	r3, #3
 8006d58:	75fb      	strb	r3, [r7, #23]
          break;
 8006d5a:	e016      	b.n	8006d8a <USBD_CDC_Setup+0x19e>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8006d5c:	687b      	ldr	r3, [r7, #4]
 8006d5e:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8006d62:	b2db      	uxtb	r3, r3
 8006d64:	2b03      	cmp	r3, #3
 8006d66:	d00f      	beq.n	8006d88 <USBD_CDC_Setup+0x19c>
          {
            USBD_CtlError(pdev, req);
 8006d68:	6839      	ldr	r1, [r7, #0]
 8006d6a:	6878      	ldr	r0, [r7, #4]
 8006d6c:	f001 fc99 	bl	80086a2 <USBD_CtlError>
            ret = USBD_FAIL;
 8006d70:	2303      	movs	r3, #3
 8006d72:	75fb      	strb	r3, [r7, #23]
          }
          break;
 8006d74:	e008      	b.n	8006d88 <USBD_CDC_Setup+0x19c>

        case USB_REQ_CLEAR_FEATURE:
          break;

        default:
          USBD_CtlError(pdev, req);
 8006d76:	6839      	ldr	r1, [r7, #0]
 8006d78:	6878      	ldr	r0, [r7, #4]
 8006d7a:	f001 fc92 	bl	80086a2 <USBD_CtlError>
          ret = USBD_FAIL;
 8006d7e:	2303      	movs	r3, #3
 8006d80:	75fb      	strb	r3, [r7, #23]
          break;
 8006d82:	e002      	b.n	8006d8a <USBD_CDC_Setup+0x19e>
          break;
 8006d84:	bf00      	nop
 8006d86:	e008      	b.n	8006d9a <USBD_CDC_Setup+0x1ae>
          break;
 8006d88:	bf00      	nop
      }
      break;
 8006d8a:	e006      	b.n	8006d9a <USBD_CDC_Setup+0x1ae>

    default:
      USBD_CtlError(pdev, req);
 8006d8c:	6839      	ldr	r1, [r7, #0]
 8006d8e:	6878      	ldr	r0, [r7, #4]
 8006d90:	f001 fc87 	bl	80086a2 <USBD_CtlError>
      ret = USBD_FAIL;
 8006d94:	2303      	movs	r3, #3
 8006d96:	75fb      	strb	r3, [r7, #23]
      break;
 8006d98:	bf00      	nop
  }

  return (uint8_t)ret;
 8006d9a:	7dfb      	ldrb	r3, [r7, #23]
}
 8006d9c:	4618      	mov	r0, r3
 8006d9e:	3718      	adds	r7, #24
 8006da0:	46bd      	mov	sp, r7
 8006da2:	bd80      	pop	{r7, pc}

08006da4 <USBD_CDC_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8006da4:	b580      	push	{r7, lr}
 8006da6:	b084      	sub	sp, #16
 8006da8:	af00      	add	r7, sp, #0
 8006daa:	6078      	str	r0, [r7, #4]
 8006dac:	460b      	mov	r3, r1
 8006dae:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc;
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef *)pdev->pData;
 8006db0:	687b      	ldr	r3, [r7, #4]
 8006db2:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8006db6:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8006db8:	687b      	ldr	r3, [r7, #4]
 8006dba:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006dbe:	687b      	ldr	r3, [r7, #4]
 8006dc0:	32b0      	adds	r2, #176	@ 0xb0
 8006dc2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006dc6:	2b00      	cmp	r3, #0
 8006dc8:	d101      	bne.n	8006dce <USBD_CDC_DataIn+0x2a>
  {
    return (uint8_t)USBD_FAIL;
 8006dca:	2303      	movs	r3, #3
 8006dcc:	e065      	b.n	8006e9a <USBD_CDC_DataIn+0xf6>
  }

  hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8006dce:	687b      	ldr	r3, [r7, #4]
 8006dd0:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006dd4:	687b      	ldr	r3, [r7, #4]
 8006dd6:	32b0      	adds	r2, #176	@ 0xb0
 8006dd8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006ddc:	60bb      	str	r3, [r7, #8]

  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8006dde:	78fb      	ldrb	r3, [r7, #3]
 8006de0:	f003 020f 	and.w	r2, r3, #15
 8006de4:	6879      	ldr	r1, [r7, #4]
 8006de6:	4613      	mov	r3, r2
 8006de8:	009b      	lsls	r3, r3, #2
 8006dea:	4413      	add	r3, r2
 8006dec:	009b      	lsls	r3, r3, #2
 8006dee:	440b      	add	r3, r1
 8006df0:	3318      	adds	r3, #24
 8006df2:	681b      	ldr	r3, [r3, #0]
 8006df4:	2b00      	cmp	r3, #0
 8006df6:	d02f      	beq.n	8006e58 <USBD_CDC_DataIn+0xb4>
      ((pdev->ep_in[epnum & 0xFU].total_length % hpcd->IN_ep[epnum & 0xFU].maxpacket) == 0U))
 8006df8:	78fb      	ldrb	r3, [r7, #3]
 8006dfa:	f003 020f 	and.w	r2, r3, #15
 8006dfe:	6879      	ldr	r1, [r7, #4]
 8006e00:	4613      	mov	r3, r2
 8006e02:	009b      	lsls	r3, r3, #2
 8006e04:	4413      	add	r3, r2
 8006e06:	009b      	lsls	r3, r3, #2
 8006e08:	440b      	add	r3, r1
 8006e0a:	3318      	adds	r3, #24
 8006e0c:	681a      	ldr	r2, [r3, #0]
 8006e0e:	78fb      	ldrb	r3, [r7, #3]
 8006e10:	f003 010f 	and.w	r1, r3, #15
 8006e14:	68f8      	ldr	r0, [r7, #12]
 8006e16:	460b      	mov	r3, r1
 8006e18:	00db      	lsls	r3, r3, #3
 8006e1a:	440b      	add	r3, r1
 8006e1c:	009b      	lsls	r3, r3, #2
 8006e1e:	4403      	add	r3, r0
 8006e20:	331c      	adds	r3, #28
 8006e22:	681b      	ldr	r3, [r3, #0]
 8006e24:	fbb2 f1f3 	udiv	r1, r2, r3
 8006e28:	fb01 f303 	mul.w	r3, r1, r3
 8006e2c:	1ad3      	subs	r3, r2, r3
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8006e2e:	2b00      	cmp	r3, #0
 8006e30:	d112      	bne.n	8006e58 <USBD_CDC_DataIn+0xb4>
  {
    /* Update the packet total length */
    pdev->ep_in[epnum & 0xFU].total_length = 0U;
 8006e32:	78fb      	ldrb	r3, [r7, #3]
 8006e34:	f003 020f 	and.w	r2, r3, #15
 8006e38:	6879      	ldr	r1, [r7, #4]
 8006e3a:	4613      	mov	r3, r2
 8006e3c:	009b      	lsls	r3, r3, #2
 8006e3e:	4413      	add	r3, r2
 8006e40:	009b      	lsls	r3, r3, #2
 8006e42:	440b      	add	r3, r1
 8006e44:	3318      	adds	r3, #24
 8006e46:	2200      	movs	r2, #0
 8006e48:	601a      	str	r2, [r3, #0]

    /* Send ZLP */
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 8006e4a:	78f9      	ldrb	r1, [r7, #3]
 8006e4c:	2300      	movs	r3, #0
 8006e4e:	2200      	movs	r2, #0
 8006e50:	6878      	ldr	r0, [r7, #4]
 8006e52:	f021 f958 	bl	8028106 <USBD_LL_Transmit>
 8006e56:	e01f      	b.n	8006e98 <USBD_CDC_DataIn+0xf4>
  }
  else
  {
    hcdc->TxState = 0U;
 8006e58:	68bb      	ldr	r3, [r7, #8]
 8006e5a:	2200      	movs	r2, #0
 8006e5c:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214

    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 8006e60:	687b      	ldr	r3, [r7, #4]
 8006e62:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006e66:	687a      	ldr	r2, [r7, #4]
 8006e68:	33b0      	adds	r3, #176	@ 0xb0
 8006e6a:	009b      	lsls	r3, r3, #2
 8006e6c:	4413      	add	r3, r2
 8006e6e:	685b      	ldr	r3, [r3, #4]
 8006e70:	691b      	ldr	r3, [r3, #16]
 8006e72:	2b00      	cmp	r3, #0
 8006e74:	d010      	beq.n	8006e98 <USBD_CDC_DataIn+0xf4>
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 8006e76:	687b      	ldr	r3, [r7, #4]
 8006e78:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006e7c:	687a      	ldr	r2, [r7, #4]
 8006e7e:	33b0      	adds	r3, #176	@ 0xb0
 8006e80:	009b      	lsls	r3, r3, #2
 8006e82:	4413      	add	r3, r2
 8006e84:	685b      	ldr	r3, [r3, #4]
 8006e86:	691b      	ldr	r3, [r3, #16]
 8006e88:	68ba      	ldr	r2, [r7, #8]
 8006e8a:	f8d2 0208 	ldr.w	r0, [r2, #520]	@ 0x208
 8006e8e:	68ba      	ldr	r2, [r7, #8]
 8006e90:	f502 7104 	add.w	r1, r2, #528	@ 0x210
 8006e94:	78fa      	ldrb	r2, [r7, #3]
 8006e96:	4798      	blx	r3
    }
  }

  return (uint8_t)USBD_OK;
 8006e98:	2300      	movs	r3, #0
}
 8006e9a:	4618      	mov	r0, r3
 8006e9c:	3710      	adds	r7, #16
 8006e9e:	46bd      	mov	sp, r7
 8006ea0:	bd80      	pop	{r7, pc}

08006ea2 <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8006ea2:	b580      	push	{r7, lr}
 8006ea4:	b084      	sub	sp, #16
 8006ea6:	af00      	add	r7, sp, #0
 8006ea8:	6078      	str	r0, [r7, #4]
 8006eaa:	460b      	mov	r3, r1
 8006eac:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8006eae:	687b      	ldr	r3, [r7, #4]
 8006eb0:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006eb4:	687b      	ldr	r3, [r7, #4]
 8006eb6:	32b0      	adds	r2, #176	@ 0xb0
 8006eb8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006ebc:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8006ebe:	687b      	ldr	r3, [r7, #4]
 8006ec0:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006ec4:	687b      	ldr	r3, [r7, #4]
 8006ec6:	32b0      	adds	r2, #176	@ 0xb0
 8006ec8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006ecc:	2b00      	cmp	r3, #0
 8006ece:	d101      	bne.n	8006ed4 <USBD_CDC_DataOut+0x32>
  {
    return (uint8_t)USBD_FAIL;
 8006ed0:	2303      	movs	r3, #3
 8006ed2:	e01a      	b.n	8006f0a <USBD_CDC_DataOut+0x68>
  }

  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8006ed4:	78fb      	ldrb	r3, [r7, #3]
 8006ed6:	4619      	mov	r1, r3
 8006ed8:	6878      	ldr	r0, [r7, #4]
 8006eda:	f021 f956 	bl	802818a <USBD_LL_GetRxDataSize>
 8006ede:	4602      	mov	r2, r0
 8006ee0:	68fb      	ldr	r3, [r7, #12]
 8006ee2:	f8c3 220c 	str.w	r2, [r3, #524]	@ 0x20c

  /* USB data will be immediately processed, this allow next USB traffic being
  NAKed till the end of the application Xfer */

  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8006ee6:	687b      	ldr	r3, [r7, #4]
 8006ee8:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006eec:	687a      	ldr	r2, [r7, #4]
 8006eee:	33b0      	adds	r3, #176	@ 0xb0
 8006ef0:	009b      	lsls	r3, r3, #2
 8006ef2:	4413      	add	r3, r2
 8006ef4:	685b      	ldr	r3, [r3, #4]
 8006ef6:	68db      	ldr	r3, [r3, #12]
 8006ef8:	68fa      	ldr	r2, [r7, #12]
 8006efa:	f8d2 0204 	ldr.w	r0, [r2, #516]	@ 0x204
 8006efe:	68fa      	ldr	r2, [r7, #12]
 8006f00:	f502 7203 	add.w	r2, r2, #524	@ 0x20c
 8006f04:	4611      	mov	r1, r2
 8006f06:	4798      	blx	r3

  return (uint8_t)USBD_OK;
 8006f08:	2300      	movs	r3, #0
}
 8006f0a:	4618      	mov	r0, r3
 8006f0c:	3710      	adds	r7, #16
 8006f0e:	46bd      	mov	sp, r7
 8006f10:	bd80      	pop	{r7, pc}

08006f12 <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 8006f12:	b580      	push	{r7, lr}
 8006f14:	b084      	sub	sp, #16
 8006f16:	af00      	add	r7, sp, #0
 8006f18:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8006f1a:	687b      	ldr	r3, [r7, #4]
 8006f1c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8006f20:	687b      	ldr	r3, [r7, #4]
 8006f22:	32b0      	adds	r2, #176	@ 0xb0
 8006f24:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006f28:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 8006f2a:	68fb      	ldr	r3, [r7, #12]
 8006f2c:	2b00      	cmp	r3, #0
 8006f2e:	d101      	bne.n	8006f34 <USBD_CDC_EP0_RxReady+0x22>
  {
    return (uint8_t)USBD_FAIL;
 8006f30:	2303      	movs	r3, #3
 8006f32:	e024      	b.n	8006f7e <USBD_CDC_EP0_RxReady+0x6c>
  }

  if ((pdev->pUserData[pdev->classId] != NULL) && (hcdc->CmdOpCode != 0xFFU))
 8006f34:	687b      	ldr	r3, [r7, #4]
 8006f36:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006f3a:	687a      	ldr	r2, [r7, #4]
 8006f3c:	33b0      	adds	r3, #176	@ 0xb0
 8006f3e:	009b      	lsls	r3, r3, #2
 8006f40:	4413      	add	r3, r2
 8006f42:	685b      	ldr	r3, [r3, #4]
 8006f44:	2b00      	cmp	r3, #0
 8006f46:	d019      	beq.n	8006f7c <USBD_CDC_EP0_RxReady+0x6a>
 8006f48:	68fb      	ldr	r3, [r7, #12]
 8006f4a:	f893 3200 	ldrb.w	r3, [r3, #512]	@ 0x200
 8006f4e:	2bff      	cmp	r3, #255	@ 0xff
 8006f50:	d014      	beq.n	8006f7c <USBD_CDC_EP0_RxReady+0x6a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 8006f52:	687b      	ldr	r3, [r7, #4]
 8006f54:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8006f58:	687a      	ldr	r2, [r7, #4]
 8006f5a:	33b0      	adds	r3, #176	@ 0xb0
 8006f5c:	009b      	lsls	r3, r3, #2
 8006f5e:	4413      	add	r3, r2
 8006f60:	685b      	ldr	r3, [r3, #4]
 8006f62:	689b      	ldr	r3, [r3, #8]
 8006f64:	68fa      	ldr	r2, [r7, #12]
 8006f66:	f892 0200 	ldrb.w	r0, [r2, #512]	@ 0x200
                                                                     (uint8_t *)hcdc->data,
 8006f6a:	68f9      	ldr	r1, [r7, #12]
                                                                     (uint16_t)hcdc->CmdLength);
 8006f6c:	68fa      	ldr	r2, [r7, #12]
 8006f6e:	f892 2201 	ldrb.w	r2, [r2, #513]	@ 0x201
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 8006f72:	4798      	blx	r3
    hcdc->CmdOpCode = 0xFFU;
 8006f74:	68fb      	ldr	r3, [r7, #12]
 8006f76:	22ff      	movs	r2, #255	@ 0xff
 8006f78:	f883 2200 	strb.w	r2, [r3, #512]	@ 0x200
  }

  return (uint8_t)USBD_OK;
 8006f7c:	2300      	movs	r3, #0
}
 8006f7e:	4618      	mov	r0, r3
 8006f80:	3710      	adds	r7, #16
 8006f82:	46bd      	mov	sp, r7
 8006f84:	bd80      	pop	{r7, pc}
	...

08006f88 <USBD_CDC_GetFSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
 8006f88:	b580      	push	{r7, lr}
 8006f8a:	b086      	sub	sp, #24
 8006f8c:	af00      	add	r7, sp, #0
 8006f8e:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8006f90:	2182      	movs	r1, #130	@ 0x82
 8006f92:	4818      	ldr	r0, [pc, #96]	@ (8006ff4 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8006f94:	f000 fd4f 	bl	8007a36 <USBD_GetEpDesc>
 8006f98:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8006f9a:	2101      	movs	r1, #1
 8006f9c:	4815      	ldr	r0, [pc, #84]	@ (8006ff4 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8006f9e:	f000 fd4a 	bl	8007a36 <USBD_GetEpDesc>
 8006fa2:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8006fa4:	2181      	movs	r1, #129	@ 0x81
 8006fa6:	4813      	ldr	r0, [pc, #76]	@ (8006ff4 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8006fa8:	f000 fd45 	bl	8007a36 <USBD_GetEpDesc>
 8006fac:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8006fae:	697b      	ldr	r3, [r7, #20]
 8006fb0:	2b00      	cmp	r3, #0
 8006fb2:	d002      	beq.n	8006fba <USBD_CDC_GetFSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8006fb4:	697b      	ldr	r3, [r7, #20]
 8006fb6:	2210      	movs	r2, #16
 8006fb8:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 8006fba:	693b      	ldr	r3, [r7, #16]
 8006fbc:	2b00      	cmp	r3, #0
 8006fbe:	d006      	beq.n	8006fce <USBD_CDC_GetFSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8006fc0:	693b      	ldr	r3, [r7, #16]
 8006fc2:	2200      	movs	r2, #0
 8006fc4:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8006fc8:	711a      	strb	r2, [r3, #4]
 8006fca:	2200      	movs	r2, #0
 8006fcc:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8006fce:	68fb      	ldr	r3, [r7, #12]
 8006fd0:	2b00      	cmp	r3, #0
 8006fd2:	d006      	beq.n	8006fe2 <USBD_CDC_GetFSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8006fd4:	68fb      	ldr	r3, [r7, #12]
 8006fd6:	2200      	movs	r2, #0
 8006fd8:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8006fdc:	711a      	strb	r2, [r3, #4]
 8006fde:	2200      	movs	r2, #0
 8006fe0:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8006fe2:	687b      	ldr	r3, [r7, #4]
 8006fe4:	2243      	movs	r2, #67	@ 0x43
 8006fe6:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 8006fe8:	4b02      	ldr	r3, [pc, #8]	@ (8006ff4 <USBD_CDC_GetFSCfgDesc+0x6c>)
}
 8006fea:	4618      	mov	r0, r3
 8006fec:	3718      	adds	r7, #24
 8006fee:	46bd      	mov	sp, r7
 8006ff0:	bd80      	pop	{r7, pc}
 8006ff2:	bf00      	nop
 8006ff4:	20000068 	.word	0x20000068

08006ff8 <USBD_CDC_GetHSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
 8006ff8:	b580      	push	{r7, lr}
 8006ffa:	b086      	sub	sp, #24
 8006ffc:	af00      	add	r7, sp, #0
 8006ffe:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8007000:	2182      	movs	r1, #130	@ 0x82
 8007002:	4818      	ldr	r0, [pc, #96]	@ (8007064 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8007004:	f000 fd17 	bl	8007a36 <USBD_GetEpDesc>
 8007008:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 800700a:	2101      	movs	r1, #1
 800700c:	4815      	ldr	r0, [pc, #84]	@ (8007064 <USBD_CDC_GetHSCfgDesc+0x6c>)
 800700e:	f000 fd12 	bl	8007a36 <USBD_GetEpDesc>
 8007012:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8007014:	2181      	movs	r1, #129	@ 0x81
 8007016:	4813      	ldr	r0, [pc, #76]	@ (8007064 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8007018:	f000 fd0d 	bl	8007a36 <USBD_GetEpDesc>
 800701c:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 800701e:	697b      	ldr	r3, [r7, #20]
 8007020:	2b00      	cmp	r3, #0
 8007022:	d002      	beq.n	800702a <USBD_CDC_GetHSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_HS_BINTERVAL;
 8007024:	697b      	ldr	r3, [r7, #20]
 8007026:	2210      	movs	r2, #16
 8007028:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 800702a:	693b      	ldr	r3, [r7, #16]
 800702c:	2b00      	cmp	r3, #0
 800702e:	d006      	beq.n	800703e <USBD_CDC_GetHSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8007030:	693b      	ldr	r3, [r7, #16]
 8007032:	2200      	movs	r2, #0
 8007034:	711a      	strb	r2, [r3, #4]
 8007036:	2200      	movs	r2, #0
 8007038:	f042 0202 	orr.w	r2, r2, #2
 800703c:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 800703e:	68fb      	ldr	r3, [r7, #12]
 8007040:	2b00      	cmp	r3, #0
 8007042:	d006      	beq.n	8007052 <USBD_CDC_GetHSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8007044:	68fb      	ldr	r3, [r7, #12]
 8007046:	2200      	movs	r2, #0
 8007048:	711a      	strb	r2, [r3, #4]
 800704a:	2200      	movs	r2, #0
 800704c:	f042 0202 	orr.w	r2, r2, #2
 8007050:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8007052:	687b      	ldr	r3, [r7, #4]
 8007054:	2243      	movs	r2, #67	@ 0x43
 8007056:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 8007058:	4b02      	ldr	r3, [pc, #8]	@ (8007064 <USBD_CDC_GetHSCfgDesc+0x6c>)
}
 800705a:	4618      	mov	r0, r3
 800705c:	3718      	adds	r7, #24
 800705e:	46bd      	mov	sp, r7
 8007060:	bd80      	pop	{r7, pc}
 8007062:	bf00      	nop
 8007064:	20000068 	.word	0x20000068

08007068 <USBD_CDC_GetOtherSpeedCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
 8007068:	b580      	push	{r7, lr}
 800706a:	b086      	sub	sp, #24
 800706c:	af00      	add	r7, sp, #0
 800706e:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8007070:	2182      	movs	r1, #130	@ 0x82
 8007072:	4818      	ldr	r0, [pc, #96]	@ (80070d4 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 8007074:	f000 fcdf 	bl	8007a36 <USBD_GetEpDesc>
 8007078:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 800707a:	2101      	movs	r1, #1
 800707c:	4815      	ldr	r0, [pc, #84]	@ (80070d4 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 800707e:	f000 fcda 	bl	8007a36 <USBD_GetEpDesc>
 8007082:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8007084:	2181      	movs	r1, #129	@ 0x81
 8007086:	4813      	ldr	r0, [pc, #76]	@ (80070d4 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 8007088:	f000 fcd5 	bl	8007a36 <USBD_GetEpDesc>
 800708c:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 800708e:	697b      	ldr	r3, [r7, #20]
 8007090:	2b00      	cmp	r3, #0
 8007092:	d002      	beq.n	800709a <USBD_CDC_GetOtherSpeedCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8007094:	697b      	ldr	r3, [r7, #20]
 8007096:	2210      	movs	r2, #16
 8007098:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 800709a:	693b      	ldr	r3, [r7, #16]
 800709c:	2b00      	cmp	r3, #0
 800709e:	d006      	beq.n	80070ae <USBD_CDC_GetOtherSpeedCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 80070a0:	693b      	ldr	r3, [r7, #16]
 80070a2:	2200      	movs	r2, #0
 80070a4:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80070a8:	711a      	strb	r2, [r3, #4]
 80070aa:	2200      	movs	r2, #0
 80070ac:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 80070ae:	68fb      	ldr	r3, [r7, #12]
 80070b0:	2b00      	cmp	r3, #0
 80070b2:	d006      	beq.n	80070c2 <USBD_CDC_GetOtherSpeedCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 80070b4:	68fb      	ldr	r3, [r7, #12]
 80070b6:	2200      	movs	r2, #0
 80070b8:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80070bc:	711a      	strb	r2, [r3, #4]
 80070be:	2200      	movs	r2, #0
 80070c0:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 80070c2:	687b      	ldr	r3, [r7, #4]
 80070c4:	2243      	movs	r2, #67	@ 0x43
 80070c6:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 80070c8:	4b02      	ldr	r3, [pc, #8]	@ (80070d4 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
}
 80070ca:	4618      	mov	r0, r3
 80070cc:	3718      	adds	r7, #24
 80070ce:	46bd      	mov	sp, r7
 80070d0:	bd80      	pop	{r7, pc}
 80070d2:	bf00      	nop
 80070d4:	20000068 	.word	0x20000068

080070d8 <USBD_CDC_GetDeviceQualifierDescriptor>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 80070d8:	b480      	push	{r7}
 80070da:	b083      	sub	sp, #12
 80070dc:	af00      	add	r7, sp, #0
 80070de:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 80070e0:	687b      	ldr	r3, [r7, #4]
 80070e2:	220a      	movs	r2, #10
 80070e4:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_DeviceQualifierDesc;
 80070e6:	4b03      	ldr	r3, [pc, #12]	@ (80070f4 <USBD_CDC_GetDeviceQualifierDescriptor+0x1c>)
}
 80070e8:	4618      	mov	r0, r3
 80070ea:	370c      	adds	r7, #12
 80070ec:	46bd      	mov	sp, r7
 80070ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070f2:	4770      	bx	lr
 80070f4:	20000024 	.word	0x20000024

080070f8 <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
 80070f8:	b480      	push	{r7}
 80070fa:	b083      	sub	sp, #12
 80070fc:	af00      	add	r7, sp, #0
 80070fe:	6078      	str	r0, [r7, #4]
 8007100:	6039      	str	r1, [r7, #0]
  if (fops == NULL)
 8007102:	683b      	ldr	r3, [r7, #0]
 8007104:	2b00      	cmp	r3, #0
 8007106:	d101      	bne.n	800710c <USBD_CDC_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
 8007108:	2303      	movs	r3, #3
 800710a:	e009      	b.n	8007120 <USBD_CDC_RegisterInterface+0x28>
  }

  pdev->pUserData[pdev->classId] = fops;
 800710c:	687b      	ldr	r3, [r7, #4]
 800710e:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8007112:	687a      	ldr	r2, [r7, #4]
 8007114:	33b0      	adds	r3, #176	@ 0xb0
 8007116:	009b      	lsls	r3, r3, #2
 8007118:	4413      	add	r3, r2
 800711a:	683a      	ldr	r2, [r7, #0]
 800711c:	605a      	str	r2, [r3, #4]

  return (uint8_t)USBD_OK;
 800711e:	2300      	movs	r3, #0
}
 8007120:	4618      	mov	r0, r3
 8007122:	370c      	adds	r7, #12
 8007124:	46bd      	mov	sp, r7
 8007126:	f85d 7b04 	ldr.w	r7, [sp], #4
 800712a:	4770      	bx	lr

0800712c <USBD_CDC_SetTxBuffer>:
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
 800712c:	b480      	push	{r7}
 800712e:	b087      	sub	sp, #28
 8007130:	af00      	add	r7, sp, #0
 8007132:	60f8      	str	r0, [r7, #12]
 8007134:	60b9      	str	r1, [r7, #8]
 8007136:	607a      	str	r2, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8007138:	68fb      	ldr	r3, [r7, #12]
 800713a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800713e:	68fb      	ldr	r3, [r7, #12]
 8007140:	32b0      	adds	r2, #176	@ 0xb0
 8007142:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007146:	617b      	str	r3, [r7, #20]
#endif /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 8007148:	697b      	ldr	r3, [r7, #20]
 800714a:	2b00      	cmp	r3, #0
 800714c:	d101      	bne.n	8007152 <USBD_CDC_SetTxBuffer+0x26>
  {
    return (uint8_t)USBD_FAIL;
 800714e:	2303      	movs	r3, #3
 8007150:	e008      	b.n	8007164 <USBD_CDC_SetTxBuffer+0x38>
  }

  hcdc->TxBuffer = pbuff;
 8007152:	697b      	ldr	r3, [r7, #20]
 8007154:	68ba      	ldr	r2, [r7, #8]
 8007156:	f8c3 2208 	str.w	r2, [r3, #520]	@ 0x208
  hcdc->TxLength = length;
 800715a:	697b      	ldr	r3, [r7, #20]
 800715c:	687a      	ldr	r2, [r7, #4]
 800715e:	f8c3 2210 	str.w	r2, [r3, #528]	@ 0x210

  return (uint8_t)USBD_OK;
 8007162:	2300      	movs	r3, #0
}
 8007164:	4618      	mov	r0, r3
 8007166:	371c      	adds	r7, #28
 8007168:	46bd      	mov	sp, r7
 800716a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800716e:	4770      	bx	lr

08007170 <USBD_CDC_SetRxBuffer>:
  * @param  pdev: device instance
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
 8007170:	b480      	push	{r7}
 8007172:	b085      	sub	sp, #20
 8007174:	af00      	add	r7, sp, #0
 8007176:	6078      	str	r0, [r7, #4]
 8007178:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 800717a:	687b      	ldr	r3, [r7, #4]
 800717c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007180:	687b      	ldr	r3, [r7, #4]
 8007182:	32b0      	adds	r2, #176	@ 0xb0
 8007184:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007188:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 800718a:	68fb      	ldr	r3, [r7, #12]
 800718c:	2b00      	cmp	r3, #0
 800718e:	d101      	bne.n	8007194 <USBD_CDC_SetRxBuffer+0x24>
  {
    return (uint8_t)USBD_FAIL;
 8007190:	2303      	movs	r3, #3
 8007192:	e004      	b.n	800719e <USBD_CDC_SetRxBuffer+0x2e>
  }

  hcdc->RxBuffer = pbuff;
 8007194:	68fb      	ldr	r3, [r7, #12]
 8007196:	683a      	ldr	r2, [r7, #0]
 8007198:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204

  return (uint8_t)USBD_OK;
 800719c:	2300      	movs	r3, #0
}
 800719e:	4618      	mov	r0, r3
 80071a0:	3714      	adds	r7, #20
 80071a2:	46bd      	mov	sp, r7
 80071a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80071a8:	4770      	bx	lr
	...

080071ac <USBD_CDC_TransmitPacket>:
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev, uint8_t ClassId)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
 80071ac:	b580      	push	{r7, lr}
 80071ae:	b084      	sub	sp, #16
 80071b0:	af00      	add	r7, sp, #0
 80071b2:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 80071b4:	687b      	ldr	r3, [r7, #4]
 80071b6:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80071ba:	687b      	ldr	r3, [r7, #4]
 80071bc:	32b0      	adds	r2, #176	@ 0xb0
 80071be:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80071c2:	60bb      	str	r3, [r7, #8]
#endif  /* USE_USBD_COMPOSITE */

  USBD_StatusTypeDef ret = USBD_BUSY;
 80071c4:	2301      	movs	r3, #1
 80071c6:	73fb      	strb	r3, [r7, #15]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, ClassId);
#endif  /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 80071c8:	68bb      	ldr	r3, [r7, #8]
 80071ca:	2b00      	cmp	r3, #0
 80071cc:	d101      	bne.n	80071d2 <USBD_CDC_TransmitPacket+0x26>
  {
    return (uint8_t)USBD_FAIL;
 80071ce:	2303      	movs	r3, #3
 80071d0:	e025      	b.n	800721e <USBD_CDC_TransmitPacket+0x72>
  }

  if (hcdc->TxState == 0U)
 80071d2:	68bb      	ldr	r3, [r7, #8]
 80071d4:	f8d3 3214 	ldr.w	r3, [r3, #532]	@ 0x214
 80071d8:	2b00      	cmp	r3, #0
 80071da:	d11f      	bne.n	800721c <USBD_CDC_TransmitPacket+0x70>
  {
    /* Tx Transfer in progress */
    hcdc->TxState = 1U;
 80071dc:	68bb      	ldr	r3, [r7, #8]
 80071de:	2201      	movs	r2, #1
 80071e0:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214

    /* Update the packet total length */
    pdev->ep_in[CDCInEpAdd & 0xFU].total_length = hcdc->TxLength;
 80071e4:	4b10      	ldr	r3, [pc, #64]	@ (8007228 <USBD_CDC_TransmitPacket+0x7c>)
 80071e6:	781b      	ldrb	r3, [r3, #0]
 80071e8:	f003 020f 	and.w	r2, r3, #15
 80071ec:	68bb      	ldr	r3, [r7, #8]
 80071ee:	f8d3 1210 	ldr.w	r1, [r3, #528]	@ 0x210
 80071f2:	6878      	ldr	r0, [r7, #4]
 80071f4:	4613      	mov	r3, r2
 80071f6:	009b      	lsls	r3, r3, #2
 80071f8:	4413      	add	r3, r2
 80071fa:	009b      	lsls	r3, r3, #2
 80071fc:	4403      	add	r3, r0
 80071fe:	3318      	adds	r3, #24
 8007200:	6019      	str	r1, [r3, #0]

    /* Transmit next packet */
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 8007202:	4b09      	ldr	r3, [pc, #36]	@ (8007228 <USBD_CDC_TransmitPacket+0x7c>)
 8007204:	7819      	ldrb	r1, [r3, #0]
 8007206:	68bb      	ldr	r3, [r7, #8]
 8007208:	f8d3 2208 	ldr.w	r2, [r3, #520]	@ 0x208
 800720c:	68bb      	ldr	r3, [r7, #8]
 800720e:	f8d3 3210 	ldr.w	r3, [r3, #528]	@ 0x210
 8007212:	6878      	ldr	r0, [r7, #4]
 8007214:	f020 ff77 	bl	8028106 <USBD_LL_Transmit>

    ret = USBD_OK;
 8007218:	2300      	movs	r3, #0
 800721a:	73fb      	strb	r3, [r7, #15]
  }

  return (uint8_t)ret;
 800721c:	7bfb      	ldrb	r3, [r7, #15]
}
 800721e:	4618      	mov	r0, r3
 8007220:	3710      	adds	r7, #16
 8007222:	46bd      	mov	sp, r7
 8007224:	bd80      	pop	{r7, pc}
 8007226:	bf00      	nop
 8007228:	200000ab 	.word	0x200000ab

0800722c <USBD_CDC_ReceivePacket>:
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
 800722c:	b580      	push	{r7, lr}
 800722e:	b084      	sub	sp, #16
 8007230:	af00      	add	r7, sp, #0
 8007232:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8007234:	687b      	ldr	r3, [r7, #4]
 8007236:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800723a:	687b      	ldr	r3, [r7, #4]
 800723c:	32b0      	adds	r2, #176	@ 0xb0
 800723e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007242:	60fb      	str	r3, [r7, #12]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8007244:	687b      	ldr	r3, [r7, #4]
 8007246:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800724a:	687b      	ldr	r3, [r7, #4]
 800724c:	32b0      	adds	r2, #176	@ 0xb0
 800724e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007252:	2b00      	cmp	r3, #0
 8007254:	d101      	bne.n	800725a <USBD_CDC_ReceivePacket+0x2e>
  {
    return (uint8_t)USBD_FAIL;
 8007256:	2303      	movs	r3, #3
 8007258:	e018      	b.n	800728c <USBD_CDC_ReceivePacket+0x60>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 800725a:	687b      	ldr	r3, [r7, #4]
 800725c:	7c1b      	ldrb	r3, [r3, #16]
 800725e:	2b00      	cmp	r3, #0
 8007260:	d10a      	bne.n	8007278 <USBD_CDC_ReceivePacket+0x4c>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8007262:	4b0c      	ldr	r3, [pc, #48]	@ (8007294 <USBD_CDC_ReceivePacket+0x68>)
 8007264:	7819      	ldrb	r1, [r3, #0]
 8007266:	68fb      	ldr	r3, [r7, #12]
 8007268:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 800726c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8007270:	6878      	ldr	r0, [r7, #4]
 8007272:	f020 ff69 	bl	8028148 <USBD_LL_PrepareReceive>
 8007276:	e008      	b.n	800728a <USBD_CDC_ReceivePacket+0x5e>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8007278:	4b06      	ldr	r3, [pc, #24]	@ (8007294 <USBD_CDC_ReceivePacket+0x68>)
 800727a:	7819      	ldrb	r1, [r3, #0]
 800727c:	68fb      	ldr	r3, [r7, #12]
 800727e:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8007282:	2340      	movs	r3, #64	@ 0x40
 8007284:	6878      	ldr	r0, [r7, #4]
 8007286:	f020 ff5f 	bl	8028148 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 800728a:	2300      	movs	r3, #0
}
 800728c:	4618      	mov	r0, r3
 800728e:	3710      	adds	r7, #16
 8007290:	46bd      	mov	sp, r7
 8007292:	bd80      	pop	{r7, pc}
 8007294:	200000ac 	.word	0x200000ac

08007298 <USBD_Init>:
  * @param  id: Low level core index
  * @retval status: USBD Status
  */
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8007298:	b580      	push	{r7, lr}
 800729a:	b086      	sub	sp, #24
 800729c:	af00      	add	r7, sp, #0
 800729e:	60f8      	str	r0, [r7, #12]
 80072a0:	60b9      	str	r1, [r7, #8]
 80072a2:	4613      	mov	r3, r2
 80072a4:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 80072a6:	68fb      	ldr	r3, [r7, #12]
 80072a8:	2b00      	cmp	r3, #0
 80072aa:	d101      	bne.n	80072b0 <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 80072ac:	2303      	movs	r3, #3
 80072ae:	e01f      	b.n	80072f0 <USBD_Init+0x58>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 80072b0:	68fb      	ldr	r3, [r7, #12]
 80072b2:	2200      	movs	r2, #0
 80072b4:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  pdev->pUserData[0] = NULL;
 80072b8:	68fb      	ldr	r3, [r7, #12]
 80072ba:	2200      	movs	r2, #0
 80072bc:	f8c3 22c4 	str.w	r2, [r3, #708]	@ 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 80072c0:	68fb      	ldr	r3, [r7, #12]
 80072c2:	2200      	movs	r2, #0
 80072c4:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 80072c8:	68bb      	ldr	r3, [r7, #8]
 80072ca:	2b00      	cmp	r3, #0
 80072cc:	d003      	beq.n	80072d6 <USBD_Init+0x3e>
  {
    pdev->pDesc = pdesc;
 80072ce:	68fb      	ldr	r3, [r7, #12]
 80072d0:	68ba      	ldr	r2, [r7, #8]
 80072d2:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80072d6:	68fb      	ldr	r3, [r7, #12]
 80072d8:	2201      	movs	r2, #1
 80072da:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->id = id;
 80072de:	68fb      	ldr	r3, [r7, #12]
 80072e0:	79fa      	ldrb	r2, [r7, #7]
 80072e2:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 80072e4:	68f8      	ldr	r0, [r7, #12]
 80072e6:	f020 fdd9 	bl	8027e9c <USBD_LL_Init>
 80072ea:	4603      	mov	r3, r0
 80072ec:	75fb      	strb	r3, [r7, #23]

  return ret;
 80072ee:	7dfb      	ldrb	r3, [r7, #23]
}
 80072f0:	4618      	mov	r0, r3
 80072f2:	3718      	adds	r7, #24
 80072f4:	46bd      	mov	sp, r7
 80072f6:	bd80      	pop	{r7, pc}

080072f8 <USBD_RegisterClass>:
  * @param  pdev: Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 80072f8:	b580      	push	{r7, lr}
 80072fa:	b084      	sub	sp, #16
 80072fc:	af00      	add	r7, sp, #0
 80072fe:	6078      	str	r0, [r7, #4]
 8007300:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8007302:	2300      	movs	r3, #0
 8007304:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
 8007306:	683b      	ldr	r3, [r7, #0]
 8007308:	2b00      	cmp	r3, #0
 800730a:	d101      	bne.n	8007310 <USBD_RegisterClass+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 800730c:	2303      	movs	r3, #3
 800730e:	e025      	b.n	800735c <USBD_RegisterClass+0x64>
  }

  /* link the class to the USB Device handle */
  pdev->pClass[0] = pclass;
 8007310:	687b      	ldr	r3, [r7, #4]
 8007312:	683a      	ldr	r2, [r7, #0]
 8007314:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 8007318:	687b      	ldr	r3, [r7, #4]
 800731a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800731e:	687b      	ldr	r3, [r7, #4]
 8007320:	32ae      	adds	r2, #174	@ 0xae
 8007322:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007326:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007328:	2b00      	cmp	r3, #0
 800732a:	d00f      	beq.n	800734c <USBD_RegisterClass+0x54>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 800732c:	687b      	ldr	r3, [r7, #4]
 800732e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007332:	687b      	ldr	r3, [r7, #4]
 8007334:	32ae      	adds	r2, #174	@ 0xae
 8007336:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800733a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800733c:	f107 020e 	add.w	r2, r7, #14
 8007340:	4610      	mov	r0, r2
 8007342:	4798      	blx	r3
 8007344:	4602      	mov	r2, r0
 8007346:	687b      	ldr	r3, [r7, #4]
 8007348:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses++;
 800734c:	687b      	ldr	r3, [r7, #4]
 800734e:	f8d3 32d8 	ldr.w	r3, [r3, #728]	@ 0x2d8
 8007352:	1c5a      	adds	r2, r3, #1
 8007354:	687b      	ldr	r3, [r7, #4]
 8007356:	f8c3 22d8 	str.w	r2, [r3, #728]	@ 0x2d8

  return USBD_OK;
 800735a:	2300      	movs	r3, #0
}
 800735c:	4618      	mov	r0, r3
 800735e:	3710      	adds	r7, #16
 8007360:	46bd      	mov	sp, r7
 8007362:	bd80      	pop	{r7, pc}

08007364 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 8007364:	b580      	push	{r7, lr}
 8007366:	b082      	sub	sp, #8
 8007368:	af00      	add	r7, sp, #0
 800736a:	6078      	str	r0, [r7, #4]
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 800736c:	6878      	ldr	r0, [r7, #4]
 800736e:	f020 fde1 	bl	8027f34 <USBD_LL_Start>
 8007372:	4603      	mov	r3, r0
}
 8007374:	4618      	mov	r0, r3
 8007376:	3708      	adds	r7, #8
 8007378:	46bd      	mov	sp, r7
 800737a:	bd80      	pop	{r7, pc}

0800737c <USBD_RunTestMode>:
  *         Launch test mode process
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef *pdev)
{
 800737c:	b480      	push	{r7}
 800737e:	b083      	sub	sp, #12
 8007380:	af00      	add	r7, sp, #0
 8007382:	6078      	str	r0, [r7, #4]
  return ret;
#else
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 8007384:	2300      	movs	r3, #0
#endif /* USBD_HS_TESTMODE_ENABLE */
}
 8007386:	4618      	mov	r0, r3
 8007388:	370c      	adds	r7, #12
 800738a:	46bd      	mov	sp, r7
 800738c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007390:	4770      	bx	lr

08007392 <USBD_SetClassConfig>:
  * @param  cfgidx: configuration index
  * @retval status
  */

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8007392:	b580      	push	{r7, lr}
 8007394:	b084      	sub	sp, #16
 8007396:	af00      	add	r7, sp, #0
 8007398:	6078      	str	r0, [r7, #4]
 800739a:	460b      	mov	r3, r1
 800739c:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 800739e:	2300      	movs	r3, #0
 80073a0:	73fb      	strb	r3, [r7, #15]
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 80073a2:	687b      	ldr	r3, [r7, #4]
 80073a4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80073a8:	2b00      	cmp	r3, #0
 80073aa:	d009      	beq.n	80073c0 <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 80073ac:	687b      	ldr	r3, [r7, #4]
 80073ae:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80073b2:	681b      	ldr	r3, [r3, #0]
 80073b4:	78fa      	ldrb	r2, [r7, #3]
 80073b6:	4611      	mov	r1, r2
 80073b8:	6878      	ldr	r0, [r7, #4]
 80073ba:	4798      	blx	r3
 80073bc:	4603      	mov	r3, r0
 80073be:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 80073c0:	7bfb      	ldrb	r3, [r7, #15]
}
 80073c2:	4618      	mov	r0, r3
 80073c4:	3710      	adds	r7, #16
 80073c6:	46bd      	mov	sp, r7
 80073c8:	bd80      	pop	{r7, pc}

080073ca <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80073ca:	b580      	push	{r7, lr}
 80073cc:	b084      	sub	sp, #16
 80073ce:	af00      	add	r7, sp, #0
 80073d0:	6078      	str	r0, [r7, #4]
 80073d2:	460b      	mov	r3, r1
 80073d4:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 80073d6:	2300      	movs	r3, #0
 80073d8:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 80073da:	687b      	ldr	r3, [r7, #4]
 80073dc:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80073e0:	685b      	ldr	r3, [r3, #4]
 80073e2:	78fa      	ldrb	r2, [r7, #3]
 80073e4:	4611      	mov	r1, r2
 80073e6:	6878      	ldr	r0, [r7, #4]
 80073e8:	4798      	blx	r3
 80073ea:	4603      	mov	r3, r0
 80073ec:	2b00      	cmp	r3, #0
 80073ee:	d001      	beq.n	80073f4 <USBD_ClrClassConfig+0x2a>
  {
    ret = USBD_FAIL;
 80073f0:	2303      	movs	r3, #3
 80073f2:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 80073f4:	7bfb      	ldrb	r3, [r7, #15]
}
 80073f6:	4618      	mov	r0, r3
 80073f8:	3710      	adds	r7, #16
 80073fa:	46bd      	mov	sp, r7
 80073fc:	bd80      	pop	{r7, pc}

080073fe <USBD_LL_SetupStage>:
  * @param  pdev: device instance
  * @param  psetup: setup packet buffer pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 80073fe:	b580      	push	{r7, lr}
 8007400:	b084      	sub	sp, #16
 8007402:	af00      	add	r7, sp, #0
 8007404:	6078      	str	r0, [r7, #4]
 8007406:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8007408:	687b      	ldr	r3, [r7, #4]
 800740a:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 800740e:	6839      	ldr	r1, [r7, #0]
 8007410:	4618      	mov	r0, r3
 8007412:	f001 f90c 	bl	800862e <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 8007416:	687b      	ldr	r3, [r7, #4]
 8007418:	2201      	movs	r2, #1
 800741a:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 800741e:	687b      	ldr	r3, [r7, #4]
 8007420:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	@ 0x2b0
 8007424:	461a      	mov	r2, r3
 8007426:	687b      	ldr	r3, [r7, #4]
 8007428:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 800742c:	687b      	ldr	r3, [r7, #4]
 800742e:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 8007432:	f003 031f 	and.w	r3, r3, #31
 8007436:	2b02      	cmp	r3, #2
 8007438:	d01a      	beq.n	8007470 <USBD_LL_SetupStage+0x72>
 800743a:	2b02      	cmp	r3, #2
 800743c:	d822      	bhi.n	8007484 <USBD_LL_SetupStage+0x86>
 800743e:	2b00      	cmp	r3, #0
 8007440:	d002      	beq.n	8007448 <USBD_LL_SetupStage+0x4a>
 8007442:	2b01      	cmp	r3, #1
 8007444:	d00a      	beq.n	800745c <USBD_LL_SetupStage+0x5e>
 8007446:	e01d      	b.n	8007484 <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 8007448:	687b      	ldr	r3, [r7, #4]
 800744a:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 800744e:	4619      	mov	r1, r3
 8007450:	6878      	ldr	r0, [r7, #4]
 8007452:	f000 fb63 	bl	8007b1c <USBD_StdDevReq>
 8007456:	4603      	mov	r3, r0
 8007458:	73fb      	strb	r3, [r7, #15]
      break;
 800745a:	e020      	b.n	800749e <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
 800745c:	687b      	ldr	r3, [r7, #4]
 800745e:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 8007462:	4619      	mov	r1, r3
 8007464:	6878      	ldr	r0, [r7, #4]
 8007466:	f000 fbcb 	bl	8007c00 <USBD_StdItfReq>
 800746a:	4603      	mov	r3, r0
 800746c:	73fb      	strb	r3, [r7, #15]
      break;
 800746e:	e016      	b.n	800749e <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
 8007470:	687b      	ldr	r3, [r7, #4]
 8007472:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 8007476:	4619      	mov	r1, r3
 8007478:	6878      	ldr	r0, [r7, #4]
 800747a:	f000 fc2d 	bl	8007cd8 <USBD_StdEPReq>
 800747e:	4603      	mov	r3, r0
 8007480:	73fb      	strb	r3, [r7, #15]
      break;
 8007482:	e00c      	b.n	800749e <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8007484:	687b      	ldr	r3, [r7, #4]
 8007486:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 800748a:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 800748e:	b2db      	uxtb	r3, r3
 8007490:	4619      	mov	r1, r3
 8007492:	6878      	ldr	r0, [r7, #4]
 8007494:	f020 fdae 	bl	8027ff4 <USBD_LL_StallEP>
 8007498:	4603      	mov	r3, r0
 800749a:	73fb      	strb	r3, [r7, #15]
      break;
 800749c:	bf00      	nop
  }

  return ret;
 800749e:	7bfb      	ldrb	r3, [r7, #15]
}
 80074a0:	4618      	mov	r0, r3
 80074a2:	3710      	adds	r7, #16
 80074a4:	46bd      	mov	sp, r7
 80074a6:	bd80      	pop	{r7, pc}

080074a8 <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 80074a8:	b580      	push	{r7, lr}
 80074aa:	b086      	sub	sp, #24
 80074ac:	af00      	add	r7, sp, #0
 80074ae:	60f8      	str	r0, [r7, #12]
 80074b0:	460b      	mov	r3, r1
 80074b2:	607a      	str	r2, [r7, #4]
 80074b4:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
 80074b6:	2300      	movs	r3, #0
 80074b8:	75fb      	strb	r3, [r7, #23]
  uint8_t idx;

  if (epnum == 0U)
 80074ba:	7afb      	ldrb	r3, [r7, #11]
 80074bc:	2b00      	cmp	r3, #0
 80074be:	d16e      	bne.n	800759e <USBD_LL_DataOutStage+0xf6>
  {
    pep = &pdev->ep_out[0];
 80074c0:	68fb      	ldr	r3, [r7, #12]
 80074c2:	f503 73aa 	add.w	r3, r3, #340	@ 0x154
 80074c6:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 80074c8:	68fb      	ldr	r3, [r7, #12]
 80074ca:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 80074ce:	2b03      	cmp	r3, #3
 80074d0:	f040 8098 	bne.w	8007604 <USBD_LL_DataOutStage+0x15c>
    {
      if (pep->rem_length > pep->maxpacket)
 80074d4:	693b      	ldr	r3, [r7, #16]
 80074d6:	689a      	ldr	r2, [r3, #8]
 80074d8:	693b      	ldr	r3, [r7, #16]
 80074da:	68db      	ldr	r3, [r3, #12]
 80074dc:	429a      	cmp	r2, r3
 80074de:	d913      	bls.n	8007508 <USBD_LL_DataOutStage+0x60>
      {
        pep->rem_length -= pep->maxpacket;
 80074e0:	693b      	ldr	r3, [r7, #16]
 80074e2:	689a      	ldr	r2, [r3, #8]
 80074e4:	693b      	ldr	r3, [r7, #16]
 80074e6:	68db      	ldr	r3, [r3, #12]
 80074e8:	1ad2      	subs	r2, r2, r3
 80074ea:	693b      	ldr	r3, [r7, #16]
 80074ec:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 80074ee:	693b      	ldr	r3, [r7, #16]
 80074f0:	68da      	ldr	r2, [r3, #12]
 80074f2:	693b      	ldr	r3, [r7, #16]
 80074f4:	689b      	ldr	r3, [r3, #8]
 80074f6:	4293      	cmp	r3, r2
 80074f8:	bf28      	it	cs
 80074fa:	4613      	movcs	r3, r2
 80074fc:	461a      	mov	r2, r3
 80074fe:	6879      	ldr	r1, [r7, #4]
 8007500:	68f8      	ldr	r0, [r7, #12]
 8007502:	f001 f994 	bl	800882e <USBD_CtlContinueRx>
 8007506:	e07d      	b.n	8007604 <USBD_LL_DataOutStage+0x15c>
      }
      else
      {
        /* Find the class ID relative to the current request */
        switch (pdev->request.bmRequest & 0x1FU)
 8007508:	68fb      	ldr	r3, [r7, #12]
 800750a:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 800750e:	f003 031f 	and.w	r3, r3, #31
 8007512:	2b02      	cmp	r3, #2
 8007514:	d014      	beq.n	8007540 <USBD_LL_DataOutStage+0x98>
 8007516:	2b02      	cmp	r3, #2
 8007518:	d81d      	bhi.n	8007556 <USBD_LL_DataOutStage+0xae>
 800751a:	2b00      	cmp	r3, #0
 800751c:	d002      	beq.n	8007524 <USBD_LL_DataOutStage+0x7c>
 800751e:	2b01      	cmp	r3, #1
 8007520:	d003      	beq.n	800752a <USBD_LL_DataOutStage+0x82>
 8007522:	e018      	b.n	8007556 <USBD_LL_DataOutStage+0xae>
        {
          case USB_REQ_RECIPIENT_DEVICE:
            /* Device requests must be managed by the first instantiated class
               (or duplicated by all classes for simplicity) */
            idx = 0U;
 8007524:	2300      	movs	r3, #0
 8007526:	75bb      	strb	r3, [r7, #22]
            break;
 8007528:	e018      	b.n	800755c <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_INTERFACE:
            idx = USBD_CoreFindIF(pdev, LOBYTE(pdev->request.wIndex));
 800752a:	68fb      	ldr	r3, [r7, #12]
 800752c:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 8007530:	b2db      	uxtb	r3, r3
 8007532:	4619      	mov	r1, r3
 8007534:	68f8      	ldr	r0, [r7, #12]
 8007536:	f000 fa64 	bl	8007a02 <USBD_CoreFindIF>
 800753a:	4603      	mov	r3, r0
 800753c:	75bb      	strb	r3, [r7, #22]
            break;
 800753e:	e00d      	b.n	800755c <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_ENDPOINT:
            idx = USBD_CoreFindEP(pdev, LOBYTE(pdev->request.wIndex));
 8007540:	68fb      	ldr	r3, [r7, #12]
 8007542:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 8007546:	b2db      	uxtb	r3, r3
 8007548:	4619      	mov	r1, r3
 800754a:	68f8      	ldr	r0, [r7, #12]
 800754c:	f000 fa66 	bl	8007a1c <USBD_CoreFindEP>
 8007550:	4603      	mov	r3, r0
 8007552:	75bb      	strb	r3, [r7, #22]
            break;
 8007554:	e002      	b.n	800755c <USBD_LL_DataOutStage+0xb4>

          default:
            /* Back to the first class in case of doubt */
            idx = 0U;
 8007556:	2300      	movs	r3, #0
 8007558:	75bb      	strb	r3, [r7, #22]
            break;
 800755a:	bf00      	nop
        }

        if (idx < USBD_MAX_SUPPORTED_CLASS)
 800755c:	7dbb      	ldrb	r3, [r7, #22]
 800755e:	2b00      	cmp	r3, #0
 8007560:	d119      	bne.n	8007596 <USBD_LL_DataOutStage+0xee>
        {
          /* Setup the class ID and route the request to the relative class function */
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007562:	68fb      	ldr	r3, [r7, #12]
 8007564:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007568:	b2db      	uxtb	r3, r3
 800756a:	2b03      	cmp	r3, #3
 800756c:	d113      	bne.n	8007596 <USBD_LL_DataOutStage+0xee>
          {
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 800756e:	7dba      	ldrb	r2, [r7, #22]
 8007570:	68fb      	ldr	r3, [r7, #12]
 8007572:	32ae      	adds	r2, #174	@ 0xae
 8007574:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007578:	691b      	ldr	r3, [r3, #16]
 800757a:	2b00      	cmp	r3, #0
 800757c:	d00b      	beq.n	8007596 <USBD_LL_DataOutStage+0xee>
            {
              pdev->classId = idx;
 800757e:	7dba      	ldrb	r2, [r7, #22]
 8007580:	68fb      	ldr	r3, [r7, #12]
 8007582:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 8007586:	7dba      	ldrb	r2, [r7, #22]
 8007588:	68fb      	ldr	r3, [r7, #12]
 800758a:	32ae      	adds	r2, #174	@ 0xae
 800758c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007590:	691b      	ldr	r3, [r3, #16]
 8007592:	68f8      	ldr	r0, [r7, #12]
 8007594:	4798      	blx	r3
            }
          }
        }

        (void)USBD_CtlSendStatus(pdev);
 8007596:	68f8      	ldr	r0, [r7, #12]
 8007598:	f001 f95a 	bl	8008850 <USBD_CtlSendStatus>
 800759c:	e032      	b.n	8007604 <USBD_LL_DataOutStage+0x15c>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, (epnum & 0x7FU));
 800759e:	7afb      	ldrb	r3, [r7, #11]
 80075a0:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80075a4:	b2db      	uxtb	r3, r3
 80075a6:	4619      	mov	r1, r3
 80075a8:	68f8      	ldr	r0, [r7, #12]
 80075aa:	f000 fa37 	bl	8007a1c <USBD_CoreFindEP>
 80075ae:	4603      	mov	r3, r0
 80075b0:	75bb      	strb	r3, [r7, #22]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 80075b2:	7dbb      	ldrb	r3, [r7, #22]
 80075b4:	2bff      	cmp	r3, #255	@ 0xff
 80075b6:	d025      	beq.n	8007604 <USBD_LL_DataOutStage+0x15c>
 80075b8:	7dbb      	ldrb	r3, [r7, #22]
 80075ba:	2b00      	cmp	r3, #0
 80075bc:	d122      	bne.n	8007604 <USBD_LL_DataOutStage+0x15c>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80075be:	68fb      	ldr	r3, [r7, #12]
 80075c0:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80075c4:	b2db      	uxtb	r3, r3
 80075c6:	2b03      	cmp	r3, #3
 80075c8:	d117      	bne.n	80075fa <USBD_LL_DataOutStage+0x152>
      {
        if (pdev->pClass[idx]->DataOut != NULL)
 80075ca:	7dba      	ldrb	r2, [r7, #22]
 80075cc:	68fb      	ldr	r3, [r7, #12]
 80075ce:	32ae      	adds	r2, #174	@ 0xae
 80075d0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80075d4:	699b      	ldr	r3, [r3, #24]
 80075d6:	2b00      	cmp	r3, #0
 80075d8:	d00f      	beq.n	80075fa <USBD_LL_DataOutStage+0x152>
        {
          pdev->classId = idx;
 80075da:	7dba      	ldrb	r2, [r7, #22]
 80075dc:	68fb      	ldr	r3, [r7, #12]
 80075de:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 80075e2:	7dba      	ldrb	r2, [r7, #22]
 80075e4:	68fb      	ldr	r3, [r7, #12]
 80075e6:	32ae      	adds	r2, #174	@ 0xae
 80075e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80075ec:	699b      	ldr	r3, [r3, #24]
 80075ee:	7afa      	ldrb	r2, [r7, #11]
 80075f0:	4611      	mov	r1, r2
 80075f2:	68f8      	ldr	r0, [r7, #12]
 80075f4:	4798      	blx	r3
 80075f6:	4603      	mov	r3, r0
 80075f8:	75fb      	strb	r3, [r7, #23]
        }
      }
      if (ret != USBD_OK)
 80075fa:	7dfb      	ldrb	r3, [r7, #23]
 80075fc:	2b00      	cmp	r3, #0
 80075fe:	d001      	beq.n	8007604 <USBD_LL_DataOutStage+0x15c>
      {
        return ret;
 8007600:	7dfb      	ldrb	r3, [r7, #23]
 8007602:	e000      	b.n	8007606 <USBD_LL_DataOutStage+0x15e>
      }
    }
  }

  return USBD_OK;
 8007604:	2300      	movs	r3, #0
}
 8007606:	4618      	mov	r0, r3
 8007608:	3718      	adds	r7, #24
 800760a:	46bd      	mov	sp, r7
 800760c:	bd80      	pop	{r7, pc}

0800760e <USBD_LL_DataInStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 800760e:	b580      	push	{r7, lr}
 8007610:	b086      	sub	sp, #24
 8007612:	af00      	add	r7, sp, #0
 8007614:	60f8      	str	r0, [r7, #12]
 8007616:	460b      	mov	r3, r1
 8007618:	607a      	str	r2, [r7, #4]
 800761a:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 800761c:	7afb      	ldrb	r3, [r7, #11]
 800761e:	2b00      	cmp	r3, #0
 8007620:	d16f      	bne.n	8007702 <USBD_LL_DataInStage+0xf4>
  {
    pep = &pdev->ep_in[0];
 8007622:	68fb      	ldr	r3, [r7, #12]
 8007624:	3314      	adds	r3, #20
 8007626:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 8007628:	68fb      	ldr	r3, [r7, #12]
 800762a:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 800762e:	2b02      	cmp	r3, #2
 8007630:	d15a      	bne.n	80076e8 <USBD_LL_DataInStage+0xda>
    {
      if (pep->rem_length > pep->maxpacket)
 8007632:	693b      	ldr	r3, [r7, #16]
 8007634:	689a      	ldr	r2, [r3, #8]
 8007636:	693b      	ldr	r3, [r7, #16]
 8007638:	68db      	ldr	r3, [r3, #12]
 800763a:	429a      	cmp	r2, r3
 800763c:	d914      	bls.n	8007668 <USBD_LL_DataInStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 800763e:	693b      	ldr	r3, [r7, #16]
 8007640:	689a      	ldr	r2, [r3, #8]
 8007642:	693b      	ldr	r3, [r7, #16]
 8007644:	68db      	ldr	r3, [r3, #12]
 8007646:	1ad2      	subs	r2, r2, r3
 8007648:	693b      	ldr	r3, [r7, #16]
 800764a:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 800764c:	693b      	ldr	r3, [r7, #16]
 800764e:	689b      	ldr	r3, [r3, #8]
 8007650:	461a      	mov	r2, r3
 8007652:	6879      	ldr	r1, [r7, #4]
 8007654:	68f8      	ldr	r0, [r7, #12]
 8007656:	f001 f8bc 	bl	80087d2 <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800765a:	2300      	movs	r3, #0
 800765c:	2200      	movs	r2, #0
 800765e:	2100      	movs	r1, #0
 8007660:	68f8      	ldr	r0, [r7, #12]
 8007662:	f020 fd71 	bl	8028148 <USBD_LL_PrepareReceive>
 8007666:	e03f      	b.n	80076e8 <USBD_LL_DataInStage+0xda>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
 8007668:	693b      	ldr	r3, [r7, #16]
 800766a:	68da      	ldr	r2, [r3, #12]
 800766c:	693b      	ldr	r3, [r7, #16]
 800766e:	689b      	ldr	r3, [r3, #8]
 8007670:	429a      	cmp	r2, r3
 8007672:	d11c      	bne.n	80076ae <USBD_LL_DataInStage+0xa0>
            (pep->total_length >= pep->maxpacket) &&
 8007674:	693b      	ldr	r3, [r7, #16]
 8007676:	685a      	ldr	r2, [r3, #4]
 8007678:	693b      	ldr	r3, [r7, #16]
 800767a:	68db      	ldr	r3, [r3, #12]
        if ((pep->maxpacket == pep->rem_length) &&
 800767c:	429a      	cmp	r2, r3
 800767e:	d316      	bcc.n	80076ae <USBD_LL_DataInStage+0xa0>
            (pep->total_length < pdev->ep0_data_len))
 8007680:	693b      	ldr	r3, [r7, #16]
 8007682:	685a      	ldr	r2, [r3, #4]
 8007684:	68fb      	ldr	r3, [r7, #12]
 8007686:	f8d3 3298 	ldr.w	r3, [r3, #664]	@ 0x298
            (pep->total_length >= pep->maxpacket) &&
 800768a:	429a      	cmp	r2, r3
 800768c:	d20f      	bcs.n	80076ae <USBD_LL_DataInStage+0xa0>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 800768e:	2200      	movs	r2, #0
 8007690:	2100      	movs	r1, #0
 8007692:	68f8      	ldr	r0, [r7, #12]
 8007694:	f001 f89d 	bl	80087d2 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 8007698:	68fb      	ldr	r3, [r7, #12]
 800769a:	2200      	movs	r2, #0
 800769c:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80076a0:	2300      	movs	r3, #0
 80076a2:	2200      	movs	r2, #0
 80076a4:	2100      	movs	r1, #0
 80076a6:	68f8      	ldr	r0, [r7, #12]
 80076a8:	f020 fd4e 	bl	8028148 <USBD_LL_PrepareReceive>
 80076ac:	e01c      	b.n	80076e8 <USBD_LL_DataInStage+0xda>
        }
        else
        {
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80076ae:	68fb      	ldr	r3, [r7, #12]
 80076b0:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80076b4:	b2db      	uxtb	r3, r3
 80076b6:	2b03      	cmp	r3, #3
 80076b8:	d10f      	bne.n	80076da <USBD_LL_DataInStage+0xcc>
          {
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 80076ba:	68fb      	ldr	r3, [r7, #12]
 80076bc:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80076c0:	68db      	ldr	r3, [r3, #12]
 80076c2:	2b00      	cmp	r3, #0
 80076c4:	d009      	beq.n	80076da <USBD_LL_DataInStage+0xcc>
            {
              pdev->classId = 0U;
 80076c6:	68fb      	ldr	r3, [r7, #12]
 80076c8:	2200      	movs	r2, #0
 80076ca:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 80076ce:	68fb      	ldr	r3, [r7, #12]
 80076d0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80076d4:	68db      	ldr	r3, [r3, #12]
 80076d6:	68f8      	ldr	r0, [r7, #12]
 80076d8:	4798      	blx	r3
            }
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
 80076da:	2180      	movs	r1, #128	@ 0x80
 80076dc:	68f8      	ldr	r0, [r7, #12]
 80076de:	f020 fc89 	bl	8027ff4 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 80076e2:	68f8      	ldr	r0, [r7, #12]
 80076e4:	f001 f8c7 	bl	8008876 <USBD_CtlReceiveStatus>
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
 80076e8:	68fb      	ldr	r3, [r7, #12]
 80076ea:	f893 32a0 	ldrb.w	r3, [r3, #672]	@ 0x2a0
 80076ee:	2b00      	cmp	r3, #0
 80076f0:	d03a      	beq.n	8007768 <USBD_LL_DataInStage+0x15a>
    {
      (void)USBD_RunTestMode(pdev);
 80076f2:	68f8      	ldr	r0, [r7, #12]
 80076f4:	f7ff fe42 	bl	800737c <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 80076f8:	68fb      	ldr	r3, [r7, #12]
 80076fa:	2200      	movs	r2, #0
 80076fc:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
 8007700:	e032      	b.n	8007768 <USBD_LL_DataInStage+0x15a>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, ((uint8_t)epnum | 0x80U));
 8007702:	7afb      	ldrb	r3, [r7, #11]
 8007704:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8007708:	b2db      	uxtb	r3, r3
 800770a:	4619      	mov	r1, r3
 800770c:	68f8      	ldr	r0, [r7, #12]
 800770e:	f000 f985 	bl	8007a1c <USBD_CoreFindEP>
 8007712:	4603      	mov	r3, r0
 8007714:	75fb      	strb	r3, [r7, #23]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007716:	7dfb      	ldrb	r3, [r7, #23]
 8007718:	2bff      	cmp	r3, #255	@ 0xff
 800771a:	d025      	beq.n	8007768 <USBD_LL_DataInStage+0x15a>
 800771c:	7dfb      	ldrb	r3, [r7, #23]
 800771e:	2b00      	cmp	r3, #0
 8007720:	d122      	bne.n	8007768 <USBD_LL_DataInStage+0x15a>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007722:	68fb      	ldr	r3, [r7, #12]
 8007724:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007728:	b2db      	uxtb	r3, r3
 800772a:	2b03      	cmp	r3, #3
 800772c:	d11c      	bne.n	8007768 <USBD_LL_DataInStage+0x15a>
      {
        if (pdev->pClass[idx]->DataIn != NULL)
 800772e:	7dfa      	ldrb	r2, [r7, #23]
 8007730:	68fb      	ldr	r3, [r7, #12]
 8007732:	32ae      	adds	r2, #174	@ 0xae
 8007734:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007738:	695b      	ldr	r3, [r3, #20]
 800773a:	2b00      	cmp	r3, #0
 800773c:	d014      	beq.n	8007768 <USBD_LL_DataInStage+0x15a>
        {
          pdev->classId = idx;
 800773e:	7dfa      	ldrb	r2, [r7, #23]
 8007740:	68fb      	ldr	r3, [r7, #12]
 8007742:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 8007746:	7dfa      	ldrb	r2, [r7, #23]
 8007748:	68fb      	ldr	r3, [r7, #12]
 800774a:	32ae      	adds	r2, #174	@ 0xae
 800774c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007750:	695b      	ldr	r3, [r3, #20]
 8007752:	7afa      	ldrb	r2, [r7, #11]
 8007754:	4611      	mov	r1, r2
 8007756:	68f8      	ldr	r0, [r7, #12]
 8007758:	4798      	blx	r3
 800775a:	4603      	mov	r3, r0
 800775c:	75bb      	strb	r3, [r7, #22]

          if (ret != USBD_OK)
 800775e:	7dbb      	ldrb	r3, [r7, #22]
 8007760:	2b00      	cmp	r3, #0
 8007762:	d001      	beq.n	8007768 <USBD_LL_DataInStage+0x15a>
          {
            return ret;
 8007764:	7dbb      	ldrb	r3, [r7, #22]
 8007766:	e000      	b.n	800776a <USBD_LL_DataInStage+0x15c>
        }
      }
    }
  }

  return USBD_OK;
 8007768:	2300      	movs	r3, #0
}
 800776a:	4618      	mov	r0, r3
 800776c:	3718      	adds	r7, #24
 800776e:	46bd      	mov	sp, r7
 8007770:	bd80      	pop	{r7, pc}

08007772 <USBD_LL_Reset>:
  *         Handle Reset event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 8007772:	b580      	push	{r7, lr}
 8007774:	b084      	sub	sp, #16
 8007776:	af00      	add	r7, sp, #0
 8007778:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef ret = USBD_OK;
 800777a:	2300      	movs	r3, #0
 800777c:	73fb      	strb	r3, [r7, #15]

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800777e:	687b      	ldr	r3, [r7, #4]
 8007780:	2201      	movs	r2, #1
 8007782:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 8007786:	687b      	ldr	r3, [r7, #4]
 8007788:	2200      	movs	r2, #0
 800778a:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->dev_config = 0U;
 800778e:	687b      	ldr	r3, [r7, #4]
 8007790:	2200      	movs	r2, #0
 8007792:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 8007794:	687b      	ldr	r3, [r7, #4]
 8007796:	2200      	movs	r2, #0
 8007798:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
  pdev->dev_test_mode = 0U;
 800779c:	687b      	ldr	r3, [r7, #4]
 800779e:	2200      	movs	r2, #0
 80077a0:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 80077a4:	687b      	ldr	r3, [r7, #4]
 80077a6:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80077aa:	2b00      	cmp	r3, #0
 80077ac:	d014      	beq.n	80077d8 <USBD_LL_Reset+0x66>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 80077ae:	687b      	ldr	r3, [r7, #4]
 80077b0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80077b4:	685b      	ldr	r3, [r3, #4]
 80077b6:	2b00      	cmp	r3, #0
 80077b8:	d00e      	beq.n	80077d8 <USBD_LL_Reset+0x66>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 80077ba:	687b      	ldr	r3, [r7, #4]
 80077bc:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80077c0:	685b      	ldr	r3, [r3, #4]
 80077c2:	687a      	ldr	r2, [r7, #4]
 80077c4:	6852      	ldr	r2, [r2, #4]
 80077c6:	b2d2      	uxtb	r2, r2
 80077c8:	4611      	mov	r1, r2
 80077ca:	6878      	ldr	r0, [r7, #4]
 80077cc:	4798      	blx	r3
 80077ce:	4603      	mov	r3, r0
 80077d0:	2b00      	cmp	r3, #0
 80077d2:	d001      	beq.n	80077d8 <USBD_LL_Reset+0x66>
      {
        ret = USBD_FAIL;
 80077d4:	2303      	movs	r3, #3
 80077d6:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80077d8:	2340      	movs	r3, #64	@ 0x40
 80077da:	2200      	movs	r2, #0
 80077dc:	2100      	movs	r1, #0
 80077de:	6878      	ldr	r0, [r7, #4]
 80077e0:	f020 fbc3 	bl	8027f6a <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 80077e4:	687b      	ldr	r3, [r7, #4]
 80077e6:	2201      	movs	r2, #1
 80077e8:	f8a3 2164 	strh.w	r2, [r3, #356]	@ 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80077ec:	687b      	ldr	r3, [r7, #4]
 80077ee:	2240      	movs	r2, #64	@ 0x40
 80077f0:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80077f4:	2340      	movs	r3, #64	@ 0x40
 80077f6:	2200      	movs	r2, #0
 80077f8:	2180      	movs	r1, #128	@ 0x80
 80077fa:	6878      	ldr	r0, [r7, #4]
 80077fc:	f020 fbb5 	bl	8027f6a <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8007800:	687b      	ldr	r3, [r7, #4]
 8007802:	2201      	movs	r2, #1
 8007804:	849a      	strh	r2, [r3, #36]	@ 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8007806:	687b      	ldr	r3, [r7, #4]
 8007808:	2240      	movs	r2, #64	@ 0x40
 800780a:	621a      	str	r2, [r3, #32]

  return ret;
 800780c:	7bfb      	ldrb	r3, [r7, #15]
}
 800780e:	4618      	mov	r0, r3
 8007810:	3710      	adds	r7, #16
 8007812:	46bd      	mov	sp, r7
 8007814:	bd80      	pop	{r7, pc}

08007816 <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 8007816:	b480      	push	{r7}
 8007818:	b083      	sub	sp, #12
 800781a:	af00      	add	r7, sp, #0
 800781c:	6078      	str	r0, [r7, #4]
 800781e:	460b      	mov	r3, r1
 8007820:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 8007822:	687b      	ldr	r3, [r7, #4]
 8007824:	78fa      	ldrb	r2, [r7, #3]
 8007826:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 8007828:	2300      	movs	r3, #0
}
 800782a:	4618      	mov	r0, r3
 800782c:	370c      	adds	r7, #12
 800782e:	46bd      	mov	sp, r7
 8007830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007834:	4770      	bx	lr

08007836 <USBD_LL_Suspend>:
  *         Handle Suspend event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 8007836:	b480      	push	{r7}
 8007838:	b083      	sub	sp, #12
 800783a:	af00      	add	r7, sp, #0
 800783c:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 800783e:	687b      	ldr	r3, [r7, #4]
 8007840:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007844:	b2db      	uxtb	r3, r3
 8007846:	2b04      	cmp	r3, #4
 8007848:	d006      	beq.n	8007858 <USBD_LL_Suspend+0x22>
  {
    pdev->dev_old_state = pdev->dev_state;
 800784a:	687b      	ldr	r3, [r7, #4]
 800784c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007850:	b2da      	uxtb	r2, r3
 8007852:	687b      	ldr	r3, [r7, #4]
 8007854:	f883 229d 	strb.w	r2, [r3, #669]	@ 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
 8007858:	687b      	ldr	r3, [r7, #4]
 800785a:	2204      	movs	r2, #4
 800785c:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c

  return USBD_OK;
 8007860:	2300      	movs	r3, #0
}
 8007862:	4618      	mov	r0, r3
 8007864:	370c      	adds	r7, #12
 8007866:	46bd      	mov	sp, r7
 8007868:	f85d 7b04 	ldr.w	r7, [sp], #4
 800786c:	4770      	bx	lr

0800786e <USBD_LL_Resume>:
  *         Handle Resume event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 800786e:	b480      	push	{r7}
 8007870:	b083      	sub	sp, #12
 8007872:	af00      	add	r7, sp, #0
 8007874:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 8007876:	687b      	ldr	r3, [r7, #4]
 8007878:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 800787c:	b2db      	uxtb	r3, r3
 800787e:	2b04      	cmp	r3, #4
 8007880:	d106      	bne.n	8007890 <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
 8007882:	687b      	ldr	r3, [r7, #4]
 8007884:	f893 329d 	ldrb.w	r3, [r3, #669]	@ 0x29d
 8007888:	b2da      	uxtb	r2, r3
 800788a:	687b      	ldr	r3, [r7, #4]
 800788c:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  }

  return USBD_OK;
 8007890:	2300      	movs	r3, #0
}
 8007892:	4618      	mov	r0, r3
 8007894:	370c      	adds	r7, #12
 8007896:	46bd      	mov	sp, r7
 8007898:	f85d 7b04 	ldr.w	r7, [sp], #4
 800789c:	4770      	bx	lr

0800789e <USBD_LL_SOF>:
  *         Handle SOF event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 800789e:	b580      	push	{r7, lr}
 80078a0:	b082      	sub	sp, #8
 80078a2:	af00      	add	r7, sp, #0
 80078a4:	6078      	str	r0, [r7, #4]
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80078a6:	687b      	ldr	r3, [r7, #4]
 80078a8:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80078ac:	b2db      	uxtb	r3, r3
 80078ae:	2b03      	cmp	r3, #3
 80078b0:	d110      	bne.n	80078d4 <USBD_LL_SOF+0x36>
          }
        }
      }
    }
#else
    if (pdev->pClass[0] != NULL)
 80078b2:	687b      	ldr	r3, [r7, #4]
 80078b4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80078b8:	2b00      	cmp	r3, #0
 80078ba:	d00b      	beq.n	80078d4 <USBD_LL_SOF+0x36>
    {
      if (pdev->pClass[0]->SOF != NULL)
 80078bc:	687b      	ldr	r3, [r7, #4]
 80078be:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80078c2:	69db      	ldr	r3, [r3, #28]
 80078c4:	2b00      	cmp	r3, #0
 80078c6:	d005      	beq.n	80078d4 <USBD_LL_SOF+0x36>
      {
        (void)pdev->pClass[0]->SOF(pdev);
 80078c8:	687b      	ldr	r3, [r7, #4]
 80078ca:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80078ce:	69db      	ldr	r3, [r3, #28]
 80078d0:	6878      	ldr	r0, [r7, #4]
 80078d2:	4798      	blx	r3
      }
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
 80078d4:	2300      	movs	r3, #0
}
 80078d6:	4618      	mov	r0, r3
 80078d8:	3708      	adds	r7, #8
 80078da:	46bd      	mov	sp, r7
 80078dc:	bd80      	pop	{r7, pc}

080078de <USBD_LL_IsoINIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
 80078de:	b580      	push	{r7, lr}
 80078e0:	b082      	sub	sp, #8
 80078e2:	af00      	add	r7, sp, #0
 80078e4:	6078      	str	r0, [r7, #4]
 80078e6:	460b      	mov	r3, r1
 80078e8:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 80078ea:	687b      	ldr	r3, [r7, #4]
 80078ec:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80078f0:	687b      	ldr	r3, [r7, #4]
 80078f2:	32ae      	adds	r2, #174	@ 0xae
 80078f4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80078f8:	2b00      	cmp	r3, #0
 80078fa:	d101      	bne.n	8007900 <USBD_LL_IsoINIncomplete+0x22>
  {
    return USBD_FAIL;
 80078fc:	2303      	movs	r3, #3
 80078fe:	e01c      	b.n	800793a <USBD_LL_IsoINIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007900:	687b      	ldr	r3, [r7, #4]
 8007902:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007906:	b2db      	uxtb	r3, r3
 8007908:	2b03      	cmp	r3, #3
 800790a:	d115      	bne.n	8007938 <USBD_LL_IsoINIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 800790c:	687b      	ldr	r3, [r7, #4]
 800790e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007912:	687b      	ldr	r3, [r7, #4]
 8007914:	32ae      	adds	r2, #174	@ 0xae
 8007916:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800791a:	6a1b      	ldr	r3, [r3, #32]
 800791c:	2b00      	cmp	r3, #0
 800791e:	d00b      	beq.n	8007938 <USBD_LL_IsoINIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 8007920:	687b      	ldr	r3, [r7, #4]
 8007922:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007926:	687b      	ldr	r3, [r7, #4]
 8007928:	32ae      	adds	r2, #174	@ 0xae
 800792a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800792e:	6a1b      	ldr	r3, [r3, #32]
 8007930:	78fa      	ldrb	r2, [r7, #3]
 8007932:	4611      	mov	r1, r2
 8007934:	6878      	ldr	r0, [r7, #4]
 8007936:	4798      	blx	r3
    }
  }

  return USBD_OK;
 8007938:	2300      	movs	r3, #0
}
 800793a:	4618      	mov	r0, r3
 800793c:	3708      	adds	r7, #8
 800793e:	46bd      	mov	sp, r7
 8007940:	bd80      	pop	{r7, pc}

08007942 <USBD_LL_IsoOUTIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
 8007942:	b580      	push	{r7, lr}
 8007944:	b082      	sub	sp, #8
 8007946:	af00      	add	r7, sp, #0
 8007948:	6078      	str	r0, [r7, #4]
 800794a:	460b      	mov	r3, r1
 800794c:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 800794e:	687b      	ldr	r3, [r7, #4]
 8007950:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007954:	687b      	ldr	r3, [r7, #4]
 8007956:	32ae      	adds	r2, #174	@ 0xae
 8007958:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800795c:	2b00      	cmp	r3, #0
 800795e:	d101      	bne.n	8007964 <USBD_LL_IsoOUTIncomplete+0x22>
  {
    return USBD_FAIL;
 8007960:	2303      	movs	r3, #3
 8007962:	e01c      	b.n	800799e <USBD_LL_IsoOUTIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8007964:	687b      	ldr	r3, [r7, #4]
 8007966:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 800796a:	b2db      	uxtb	r3, r3
 800796c:	2b03      	cmp	r3, #3
 800796e:	d115      	bne.n	800799c <USBD_LL_IsoOUTIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 8007970:	687b      	ldr	r3, [r7, #4]
 8007972:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007976:	687b      	ldr	r3, [r7, #4]
 8007978:	32ae      	adds	r2, #174	@ 0xae
 800797a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800797e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8007980:	2b00      	cmp	r3, #0
 8007982:	d00b      	beq.n	800799c <USBD_LL_IsoOUTIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 8007984:	687b      	ldr	r3, [r7, #4]
 8007986:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 800798a:	687b      	ldr	r3, [r7, #4]
 800798c:	32ae      	adds	r2, #174	@ 0xae
 800798e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007992:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8007994:	78fa      	ldrb	r2, [r7, #3]
 8007996:	4611      	mov	r1, r2
 8007998:	6878      	ldr	r0, [r7, #4]
 800799a:	4798      	blx	r3
    }
  }

  return USBD_OK;
 800799c:	2300      	movs	r3, #0
}
 800799e:	4618      	mov	r0, r3
 80079a0:	3708      	adds	r7, #8
 80079a2:	46bd      	mov	sp, r7
 80079a4:	bd80      	pop	{r7, pc}

080079a6 <USBD_LL_DevConnected>:
  *         Handle device connection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
{
 80079a6:	b480      	push	{r7}
 80079a8:	b083      	sub	sp, #12
 80079aa:	af00      	add	r7, sp, #0
 80079ac:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 80079ae:	2300      	movs	r3, #0
}
 80079b0:	4618      	mov	r0, r3
 80079b2:	370c      	adds	r7, #12
 80079b4:	46bd      	mov	sp, r7
 80079b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079ba:	4770      	bx	lr

080079bc <USBD_LL_DevDisconnected>:
  *         Handle device disconnection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
 80079bc:	b580      	push	{r7, lr}
 80079be:	b084      	sub	sp, #16
 80079c0:	af00      	add	r7, sp, #0
 80079c2:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef   ret = USBD_OK;
 80079c4:	2300      	movs	r3, #0
 80079c6:	73fb      	strb	r3, [r7, #15]

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80079c8:	687b      	ldr	r3, [r7, #4]
 80079ca:	2201      	movs	r2, #1
 80079cc:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 80079d0:	687b      	ldr	r3, [r7, #4]
 80079d2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80079d6:	2b00      	cmp	r3, #0
 80079d8:	d00e      	beq.n	80079f8 <USBD_LL_DevDisconnected+0x3c>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 80079da:	687b      	ldr	r3, [r7, #4]
 80079dc:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 80079e0:	685b      	ldr	r3, [r3, #4]
 80079e2:	687a      	ldr	r2, [r7, #4]
 80079e4:	6852      	ldr	r2, [r2, #4]
 80079e6:	b2d2      	uxtb	r2, r2
 80079e8:	4611      	mov	r1, r2
 80079ea:	6878      	ldr	r0, [r7, #4]
 80079ec:	4798      	blx	r3
 80079ee:	4603      	mov	r3, r0
 80079f0:	2b00      	cmp	r3, #0
 80079f2:	d001      	beq.n	80079f8 <USBD_LL_DevDisconnected+0x3c>
    {
      ret = USBD_FAIL;
 80079f4:	2303      	movs	r3, #3
 80079f6:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 80079f8:	7bfb      	ldrb	r3, [r7, #15]
}
 80079fa:	4618      	mov	r0, r3
 80079fc:	3710      	adds	r7, #16
 80079fe:	46bd      	mov	sp, r7
 8007a00:	bd80      	pop	{r7, pc}

08007a02 <USBD_CoreFindIF>:
  * @param  pdev: device instance
  * @param  index : selected interface number
  * @retval index of the class using the selected interface number. OxFF if no class found.
  */
uint8_t USBD_CoreFindIF(USBD_HandleTypeDef *pdev, uint8_t index)
{
 8007a02:	b480      	push	{r7}
 8007a04:	b083      	sub	sp, #12
 8007a06:	af00      	add	r7, sp, #0
 8007a08:	6078      	str	r0, [r7, #4]
 8007a0a:	460b      	mov	r3, r1
 8007a0c:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 8007a0e:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 8007a10:	4618      	mov	r0, r3
 8007a12:	370c      	adds	r7, #12
 8007a14:	46bd      	mov	sp, r7
 8007a16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a1a:	4770      	bx	lr

08007a1c <USBD_CoreFindEP>:
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
{
 8007a1c:	b480      	push	{r7}
 8007a1e:	b083      	sub	sp, #12
 8007a20:	af00      	add	r7, sp, #0
 8007a22:	6078      	str	r0, [r7, #4]
 8007a24:	460b      	mov	r3, r1
 8007a26:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 8007a28:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 8007a2a:	4618      	mov	r0, r3
 8007a2c:	370c      	adds	r7, #12
 8007a2e:	46bd      	mov	sp, r7
 8007a30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a34:	4770      	bx	lr

08007a36 <USBD_GetEpDesc>:
  * @param  pConfDesc:  pointer to Bos descriptor
  * @param  EpAddr:  endpoint address
  * @retval pointer to video endpoint descriptor
  */
void *USBD_GetEpDesc(uint8_t *pConfDesc, uint8_t EpAddr)
{
 8007a36:	b580      	push	{r7, lr}
 8007a38:	b086      	sub	sp, #24
 8007a3a:	af00      	add	r7, sp, #0
 8007a3c:	6078      	str	r0, [r7, #4]
 8007a3e:	460b      	mov	r3, r1
 8007a40:	70fb      	strb	r3, [r7, #3]
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
 8007a42:	687b      	ldr	r3, [r7, #4]
 8007a44:	617b      	str	r3, [r7, #20]
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
 8007a46:	687b      	ldr	r3, [r7, #4]
 8007a48:	60fb      	str	r3, [r7, #12]
  USBD_EpDescTypeDef *pEpDesc = NULL;
 8007a4a:	2300      	movs	r3, #0
 8007a4c:	613b      	str	r3, [r7, #16]
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 8007a4e:	68fb      	ldr	r3, [r7, #12]
 8007a50:	885b      	ldrh	r3, [r3, #2]
 8007a52:	b29b      	uxth	r3, r3
 8007a54:	68fa      	ldr	r2, [r7, #12]
 8007a56:	7812      	ldrb	r2, [r2, #0]
 8007a58:	4293      	cmp	r3, r2
 8007a5a:	d91f      	bls.n	8007a9c <USBD_GetEpDesc+0x66>
  {
    ptr = desc->bLength;
 8007a5c:	68fb      	ldr	r3, [r7, #12]
 8007a5e:	781b      	ldrb	r3, [r3, #0]
 8007a60:	817b      	strh	r3, [r7, #10]

    while (ptr < desc->wTotalLength)
 8007a62:	e013      	b.n	8007a8c <USBD_GetEpDesc+0x56>
    {
      pdesc = USBD_GetNextDesc((uint8_t *)pdesc, &ptr);
 8007a64:	f107 030a 	add.w	r3, r7, #10
 8007a68:	4619      	mov	r1, r3
 8007a6a:	6978      	ldr	r0, [r7, #20]
 8007a6c:	f000 f81b 	bl	8007aa6 <USBD_GetNextDesc>
 8007a70:	6178      	str	r0, [r7, #20]

      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 8007a72:	697b      	ldr	r3, [r7, #20]
 8007a74:	785b      	ldrb	r3, [r3, #1]
 8007a76:	2b05      	cmp	r3, #5
 8007a78:	d108      	bne.n	8007a8c <USBD_GetEpDesc+0x56>
      {
        pEpDesc = (USBD_EpDescTypeDef *)(void *)pdesc;
 8007a7a:	697b      	ldr	r3, [r7, #20]
 8007a7c:	613b      	str	r3, [r7, #16]

        if (pEpDesc->bEndpointAddress == EpAddr)
 8007a7e:	693b      	ldr	r3, [r7, #16]
 8007a80:	789b      	ldrb	r3, [r3, #2]
 8007a82:	78fa      	ldrb	r2, [r7, #3]
 8007a84:	429a      	cmp	r2, r3
 8007a86:	d008      	beq.n	8007a9a <USBD_GetEpDesc+0x64>
        {
          break;
        }
        else
        {
          pEpDesc = NULL;
 8007a88:	2300      	movs	r3, #0
 8007a8a:	613b      	str	r3, [r7, #16]
    while (ptr < desc->wTotalLength)
 8007a8c:	68fb      	ldr	r3, [r7, #12]
 8007a8e:	885b      	ldrh	r3, [r3, #2]
 8007a90:	b29a      	uxth	r2, r3
 8007a92:	897b      	ldrh	r3, [r7, #10]
 8007a94:	429a      	cmp	r2, r3
 8007a96:	d8e5      	bhi.n	8007a64 <USBD_GetEpDesc+0x2e>
 8007a98:	e000      	b.n	8007a9c <USBD_GetEpDesc+0x66>
          break;
 8007a9a:	bf00      	nop
        }
      }
    }
  }

  return (void *)pEpDesc;
 8007a9c:	693b      	ldr	r3, [r7, #16]
}
 8007a9e:	4618      	mov	r0, r3
 8007aa0:	3718      	adds	r7, #24
 8007aa2:	46bd      	mov	sp, r7
 8007aa4:	bd80      	pop	{r7, pc}

08007aa6 <USBD_GetNextDesc>:
  * @param  buf: Buffer where the descriptor is available
  * @param  ptr: data pointer inside the descriptor
  * @retval next header
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
 8007aa6:	b480      	push	{r7}
 8007aa8:	b085      	sub	sp, #20
 8007aaa:	af00      	add	r7, sp, #0
 8007aac:	6078      	str	r0, [r7, #4]
 8007aae:	6039      	str	r1, [r7, #0]
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;
 8007ab0:	687b      	ldr	r3, [r7, #4]
 8007ab2:	60fb      	str	r3, [r7, #12]

  *ptr += pnext->bLength;
 8007ab4:	683b      	ldr	r3, [r7, #0]
 8007ab6:	881b      	ldrh	r3, [r3, #0]
 8007ab8:	68fa      	ldr	r2, [r7, #12]
 8007aba:	7812      	ldrb	r2, [r2, #0]
 8007abc:	4413      	add	r3, r2
 8007abe:	b29a      	uxth	r2, r3
 8007ac0:	683b      	ldr	r3, [r7, #0]
 8007ac2:	801a      	strh	r2, [r3, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 8007ac4:	68fb      	ldr	r3, [r7, #12]
 8007ac6:	781b      	ldrb	r3, [r3, #0]
 8007ac8:	461a      	mov	r2, r3
 8007aca:	687b      	ldr	r3, [r7, #4]
 8007acc:	4413      	add	r3, r2
 8007ace:	60fb      	str	r3, [r7, #12]

  return (pnext);
 8007ad0:	68fb      	ldr	r3, [r7, #12]
}
 8007ad2:	4618      	mov	r0, r3
 8007ad4:	3714      	adds	r7, #20
 8007ad6:	46bd      	mov	sp, r7
 8007ad8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007adc:	4770      	bx	lr

08007ade <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
 8007ade:	b480      	push	{r7}
 8007ae0:	b087      	sub	sp, #28
 8007ae2:	af00      	add	r7, sp, #0
 8007ae4:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal;
  uint16_t _Byte1;
  uint16_t _Byte2;
  uint8_t *_pbuff = addr;
 8007ae6:	687b      	ldr	r3, [r7, #4]
 8007ae8:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
 8007aea:	697b      	ldr	r3, [r7, #20]
 8007aec:	781b      	ldrb	r3, [r3, #0]
 8007aee:	827b      	strh	r3, [r7, #18]
  _pbuff++;
 8007af0:	697b      	ldr	r3, [r7, #20]
 8007af2:	3301      	adds	r3, #1
 8007af4:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
 8007af6:	697b      	ldr	r3, [r7, #20]
 8007af8:	781b      	ldrb	r3, [r3, #0]
 8007afa:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 8007afc:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8007b00:	021b      	lsls	r3, r3, #8
 8007b02:	b21a      	sxth	r2, r3
 8007b04:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8007b08:	4313      	orrs	r3, r2
 8007b0a:	b21b      	sxth	r3, r3
 8007b0c:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
 8007b0e:	89fb      	ldrh	r3, [r7, #14]
}
 8007b10:	4618      	mov	r0, r3
 8007b12:	371c      	adds	r7, #28
 8007b14:	46bd      	mov	sp, r7
 8007b16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b1a:	4770      	bx	lr

08007b1c <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007b1c:	b580      	push	{r7, lr}
 8007b1e:	b084      	sub	sp, #16
 8007b20:	af00      	add	r7, sp, #0
 8007b22:	6078      	str	r0, [r7, #4]
 8007b24:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8007b26:	2300      	movs	r3, #0
 8007b28:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8007b2a:	683b      	ldr	r3, [r7, #0]
 8007b2c:	781b      	ldrb	r3, [r3, #0]
 8007b2e:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8007b32:	2b40      	cmp	r3, #64	@ 0x40
 8007b34:	d005      	beq.n	8007b42 <USBD_StdDevReq+0x26>
 8007b36:	2b40      	cmp	r3, #64	@ 0x40
 8007b38:	d857      	bhi.n	8007bea <USBD_StdDevReq+0xce>
 8007b3a:	2b00      	cmp	r3, #0
 8007b3c:	d00f      	beq.n	8007b5e <USBD_StdDevReq+0x42>
 8007b3e:	2b20      	cmp	r3, #32
 8007b40:	d153      	bne.n	8007bea <USBD_StdDevReq+0xce>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 8007b42:	687b      	ldr	r3, [r7, #4]
 8007b44:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8007b48:	687b      	ldr	r3, [r7, #4]
 8007b4a:	32ae      	adds	r2, #174	@ 0xae
 8007b4c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007b50:	689b      	ldr	r3, [r3, #8]
 8007b52:	6839      	ldr	r1, [r7, #0]
 8007b54:	6878      	ldr	r0, [r7, #4]
 8007b56:	4798      	blx	r3
 8007b58:	4603      	mov	r3, r0
 8007b5a:	73fb      	strb	r3, [r7, #15]
      break;
 8007b5c:	e04a      	b.n	8007bf4 <USBD_StdDevReq+0xd8>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8007b5e:	683b      	ldr	r3, [r7, #0]
 8007b60:	785b      	ldrb	r3, [r3, #1]
 8007b62:	2b09      	cmp	r3, #9
 8007b64:	d83b      	bhi.n	8007bde <USBD_StdDevReq+0xc2>
 8007b66:	a201      	add	r2, pc, #4	@ (adr r2, 8007b6c <USBD_StdDevReq+0x50>)
 8007b68:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007b6c:	08007bc1 	.word	0x08007bc1
 8007b70:	08007bd5 	.word	0x08007bd5
 8007b74:	08007bdf 	.word	0x08007bdf
 8007b78:	08007bcb 	.word	0x08007bcb
 8007b7c:	08007bdf 	.word	0x08007bdf
 8007b80:	08007b9f 	.word	0x08007b9f
 8007b84:	08007b95 	.word	0x08007b95
 8007b88:	08007bdf 	.word	0x08007bdf
 8007b8c:	08007bb7 	.word	0x08007bb7
 8007b90:	08007ba9 	.word	0x08007ba9
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
 8007b94:	6839      	ldr	r1, [r7, #0]
 8007b96:	6878      	ldr	r0, [r7, #4]
 8007b98:	f000 fa3c 	bl	8008014 <USBD_GetDescriptor>
          break;
 8007b9c:	e024      	b.n	8007be8 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
 8007b9e:	6839      	ldr	r1, [r7, #0]
 8007ba0:	6878      	ldr	r0, [r7, #4]
 8007ba2:	f000 fba1 	bl	80082e8 <USBD_SetAddress>
          break;
 8007ba6:	e01f      	b.n	8007be8 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_CONFIGURATION:
          ret = USBD_SetConfig(pdev, req);
 8007ba8:	6839      	ldr	r1, [r7, #0]
 8007baa:	6878      	ldr	r0, [r7, #4]
 8007bac:	f000 fbe0 	bl	8008370 <USBD_SetConfig>
 8007bb0:	4603      	mov	r3, r0
 8007bb2:	73fb      	strb	r3, [r7, #15]
          break;
 8007bb4:	e018      	b.n	8007be8 <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
 8007bb6:	6839      	ldr	r1, [r7, #0]
 8007bb8:	6878      	ldr	r0, [r7, #4]
 8007bba:	f000 fc83 	bl	80084c4 <USBD_GetConfig>
          break;
 8007bbe:	e013      	b.n	8007be8 <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
 8007bc0:	6839      	ldr	r1, [r7, #0]
 8007bc2:	6878      	ldr	r0, [r7, #4]
 8007bc4:	f000 fcb4 	bl	8008530 <USBD_GetStatus>
          break;
 8007bc8:	e00e      	b.n	8007be8 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
 8007bca:	6839      	ldr	r1, [r7, #0]
 8007bcc:	6878      	ldr	r0, [r7, #4]
 8007bce:	f000 fce3 	bl	8008598 <USBD_SetFeature>
          break;
 8007bd2:	e009      	b.n	8007be8 <USBD_StdDevReq+0xcc>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
 8007bd4:	6839      	ldr	r1, [r7, #0]
 8007bd6:	6878      	ldr	r0, [r7, #4]
 8007bd8:	f000 fd07 	bl	80085ea <USBD_ClrFeature>
          break;
 8007bdc:	e004      	b.n	8007be8 <USBD_StdDevReq+0xcc>

        default:
          USBD_CtlError(pdev, req);
 8007bde:	6839      	ldr	r1, [r7, #0]
 8007be0:	6878      	ldr	r0, [r7, #4]
 8007be2:	f000 fd5e 	bl	80086a2 <USBD_CtlError>
          break;
 8007be6:	bf00      	nop
      }
      break;
 8007be8:	e004      	b.n	8007bf4 <USBD_StdDevReq+0xd8>

    default:
      USBD_CtlError(pdev, req);
 8007bea:	6839      	ldr	r1, [r7, #0]
 8007bec:	6878      	ldr	r0, [r7, #4]
 8007bee:	f000 fd58 	bl	80086a2 <USBD_CtlError>
      break;
 8007bf2:	bf00      	nop
  }

  return ret;
 8007bf4:	7bfb      	ldrb	r3, [r7, #15]
}
 8007bf6:	4618      	mov	r0, r3
 8007bf8:	3710      	adds	r7, #16
 8007bfa:	46bd      	mov	sp, r7
 8007bfc:	bd80      	pop	{r7, pc}
 8007bfe:	bf00      	nop

08007c00 <USBD_StdItfReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007c00:	b580      	push	{r7, lr}
 8007c02:	b084      	sub	sp, #16
 8007c04:	af00      	add	r7, sp, #0
 8007c06:	6078      	str	r0, [r7, #4]
 8007c08:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8007c0a:	2300      	movs	r3, #0
 8007c0c:	73fb      	strb	r3, [r7, #15]
  uint8_t idx;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8007c0e:	683b      	ldr	r3, [r7, #0]
 8007c10:	781b      	ldrb	r3, [r3, #0]
 8007c12:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8007c16:	2b40      	cmp	r3, #64	@ 0x40
 8007c18:	d005      	beq.n	8007c26 <USBD_StdItfReq+0x26>
 8007c1a:	2b40      	cmp	r3, #64	@ 0x40
 8007c1c:	d852      	bhi.n	8007cc4 <USBD_StdItfReq+0xc4>
 8007c1e:	2b00      	cmp	r3, #0
 8007c20:	d001      	beq.n	8007c26 <USBD_StdItfReq+0x26>
 8007c22:	2b20      	cmp	r3, #32
 8007c24:	d14e      	bne.n	8007cc4 <USBD_StdItfReq+0xc4>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
 8007c26:	687b      	ldr	r3, [r7, #4]
 8007c28:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007c2c:	b2db      	uxtb	r3, r3
 8007c2e:	3b01      	subs	r3, #1
 8007c30:	2b02      	cmp	r3, #2
 8007c32:	d840      	bhi.n	8007cb6 <USBD_StdItfReq+0xb6>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8007c34:	683b      	ldr	r3, [r7, #0]
 8007c36:	889b      	ldrh	r3, [r3, #4]
 8007c38:	b2db      	uxtb	r3, r3
 8007c3a:	2b01      	cmp	r3, #1
 8007c3c:	d836      	bhi.n	8007cac <USBD_StdItfReq+0xac>
          {
            /* Get the class index relative to this interface */
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 8007c3e:	683b      	ldr	r3, [r7, #0]
 8007c40:	889b      	ldrh	r3, [r3, #4]
 8007c42:	b2db      	uxtb	r3, r3
 8007c44:	4619      	mov	r1, r3
 8007c46:	6878      	ldr	r0, [r7, #4]
 8007c48:	f7ff fedb 	bl	8007a02 <USBD_CoreFindIF>
 8007c4c:	4603      	mov	r3, r0
 8007c4e:	73bb      	strb	r3, [r7, #14]
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007c50:	7bbb      	ldrb	r3, [r7, #14]
 8007c52:	2bff      	cmp	r3, #255	@ 0xff
 8007c54:	d01d      	beq.n	8007c92 <USBD_StdItfReq+0x92>
 8007c56:	7bbb      	ldrb	r3, [r7, #14]
 8007c58:	2b00      	cmp	r3, #0
 8007c5a:	d11a      	bne.n	8007c92 <USBD_StdItfReq+0x92>
            {
              /* Call the class data out function to manage the request */
              if (pdev->pClass[idx]->Setup != NULL)
 8007c5c:	7bba      	ldrb	r2, [r7, #14]
 8007c5e:	687b      	ldr	r3, [r7, #4]
 8007c60:	32ae      	adds	r2, #174	@ 0xae
 8007c62:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007c66:	689b      	ldr	r3, [r3, #8]
 8007c68:	2b00      	cmp	r3, #0
 8007c6a:	d00f      	beq.n	8007c8c <USBD_StdItfReq+0x8c>
              {
                pdev->classId = idx;
 8007c6c:	7bba      	ldrb	r2, [r7, #14]
 8007c6e:	687b      	ldr	r3, [r7, #4]
 8007c70:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8007c74:	7bba      	ldrb	r2, [r7, #14]
 8007c76:	687b      	ldr	r3, [r7, #4]
 8007c78:	32ae      	adds	r2, #174	@ 0xae
 8007c7a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007c7e:	689b      	ldr	r3, [r3, #8]
 8007c80:	6839      	ldr	r1, [r7, #0]
 8007c82:	6878      	ldr	r0, [r7, #4]
 8007c84:	4798      	blx	r3
 8007c86:	4603      	mov	r3, r0
 8007c88:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 8007c8a:	e004      	b.n	8007c96 <USBD_StdItfReq+0x96>
              }
              else
              {
                /* should never reach this condition */
                ret = USBD_FAIL;
 8007c8c:	2303      	movs	r3, #3
 8007c8e:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 8007c90:	e001      	b.n	8007c96 <USBD_StdItfReq+0x96>
              }
            }
            else
            {
              /* No relative interface found */
              ret = USBD_FAIL;
 8007c92:	2303      	movs	r3, #3
 8007c94:	73fb      	strb	r3, [r7, #15]
            }

            if ((req->wLength == 0U) && (ret == USBD_OK))
 8007c96:	683b      	ldr	r3, [r7, #0]
 8007c98:	88db      	ldrh	r3, [r3, #6]
 8007c9a:	2b00      	cmp	r3, #0
 8007c9c:	d110      	bne.n	8007cc0 <USBD_StdItfReq+0xc0>
 8007c9e:	7bfb      	ldrb	r3, [r7, #15]
 8007ca0:	2b00      	cmp	r3, #0
 8007ca2:	d10d      	bne.n	8007cc0 <USBD_StdItfReq+0xc0>
            {
              (void)USBD_CtlSendStatus(pdev);
 8007ca4:	6878      	ldr	r0, [r7, #4]
 8007ca6:	f000 fdd3 	bl	8008850 <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
 8007caa:	e009      	b.n	8007cc0 <USBD_StdItfReq+0xc0>
            USBD_CtlError(pdev, req);
 8007cac:	6839      	ldr	r1, [r7, #0]
 8007cae:	6878      	ldr	r0, [r7, #4]
 8007cb0:	f000 fcf7 	bl	80086a2 <USBD_CtlError>
          break;
 8007cb4:	e004      	b.n	8007cc0 <USBD_StdItfReq+0xc0>

        default:
          USBD_CtlError(pdev, req);
 8007cb6:	6839      	ldr	r1, [r7, #0]
 8007cb8:	6878      	ldr	r0, [r7, #4]
 8007cba:	f000 fcf2 	bl	80086a2 <USBD_CtlError>
          break;
 8007cbe:	e000      	b.n	8007cc2 <USBD_StdItfReq+0xc2>
          break;
 8007cc0:	bf00      	nop
      }
      break;
 8007cc2:	e004      	b.n	8007cce <USBD_StdItfReq+0xce>

    default:
      USBD_CtlError(pdev, req);
 8007cc4:	6839      	ldr	r1, [r7, #0]
 8007cc6:	6878      	ldr	r0, [r7, #4]
 8007cc8:	f000 fceb 	bl	80086a2 <USBD_CtlError>
      break;
 8007ccc:	bf00      	nop
  }

  return ret;
 8007cce:	7bfb      	ldrb	r3, [r7, #15]
}
 8007cd0:	4618      	mov	r0, r3
 8007cd2:	3710      	adds	r7, #16
 8007cd4:	46bd      	mov	sp, r7
 8007cd6:	bd80      	pop	{r7, pc}

08007cd8 <USBD_StdEPReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007cd8:	b580      	push	{r7, lr}
 8007cda:	b084      	sub	sp, #16
 8007cdc:	af00      	add	r7, sp, #0
 8007cde:	6078      	str	r0, [r7, #4]
 8007ce0:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  uint8_t idx;
  USBD_StatusTypeDef ret = USBD_OK;
 8007ce2:	2300      	movs	r3, #0
 8007ce4:	73fb      	strb	r3, [r7, #15]

  ep_addr = LOBYTE(req->wIndex);
 8007ce6:	683b      	ldr	r3, [r7, #0]
 8007ce8:	889b      	ldrh	r3, [r3, #4]
 8007cea:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8007cec:	683b      	ldr	r3, [r7, #0]
 8007cee:	781b      	ldrb	r3, [r3, #0]
 8007cf0:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8007cf4:	2b40      	cmp	r3, #64	@ 0x40
 8007cf6:	d007      	beq.n	8007d08 <USBD_StdEPReq+0x30>
 8007cf8:	2b40      	cmp	r3, #64	@ 0x40
 8007cfa:	f200 817f 	bhi.w	8007ffc <USBD_StdEPReq+0x324>
 8007cfe:	2b00      	cmp	r3, #0
 8007d00:	d02a      	beq.n	8007d58 <USBD_StdEPReq+0x80>
 8007d02:	2b20      	cmp	r3, #32
 8007d04:	f040 817a 	bne.w	8007ffc <USBD_StdEPReq+0x324>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      /* Get the class index relative to this endpoint */
      idx = USBD_CoreFindEP(pdev, ep_addr);
 8007d08:	7bbb      	ldrb	r3, [r7, #14]
 8007d0a:	4619      	mov	r1, r3
 8007d0c:	6878      	ldr	r0, [r7, #4]
 8007d0e:	f7ff fe85 	bl	8007a1c <USBD_CoreFindEP>
 8007d12:	4603      	mov	r3, r0
 8007d14:	737b      	strb	r3, [r7, #13]
      if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007d16:	7b7b      	ldrb	r3, [r7, #13]
 8007d18:	2bff      	cmp	r3, #255	@ 0xff
 8007d1a:	f000 8174 	beq.w	8008006 <USBD_StdEPReq+0x32e>
 8007d1e:	7b7b      	ldrb	r3, [r7, #13]
 8007d20:	2b00      	cmp	r3, #0
 8007d22:	f040 8170 	bne.w	8008006 <USBD_StdEPReq+0x32e>
      {
        pdev->classId = idx;
 8007d26:	7b7a      	ldrb	r2, [r7, #13]
 8007d28:	687b      	ldr	r3, [r7, #4]
 8007d2a:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
        /* Call the class data out function to manage the request */
        if (pdev->pClass[idx]->Setup != NULL)
 8007d2e:	7b7a      	ldrb	r2, [r7, #13]
 8007d30:	687b      	ldr	r3, [r7, #4]
 8007d32:	32ae      	adds	r2, #174	@ 0xae
 8007d34:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007d38:	689b      	ldr	r3, [r3, #8]
 8007d3a:	2b00      	cmp	r3, #0
 8007d3c:	f000 8163 	beq.w	8008006 <USBD_StdEPReq+0x32e>
        {
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->Setup(pdev, req);
 8007d40:	7b7a      	ldrb	r2, [r7, #13]
 8007d42:	687b      	ldr	r3, [r7, #4]
 8007d44:	32ae      	adds	r2, #174	@ 0xae
 8007d46:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007d4a:	689b      	ldr	r3, [r3, #8]
 8007d4c:	6839      	ldr	r1, [r7, #0]
 8007d4e:	6878      	ldr	r0, [r7, #4]
 8007d50:	4798      	blx	r3
 8007d52:	4603      	mov	r3, r0
 8007d54:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 8007d56:	e156      	b.n	8008006 <USBD_StdEPReq+0x32e>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8007d58:	683b      	ldr	r3, [r7, #0]
 8007d5a:	785b      	ldrb	r3, [r3, #1]
 8007d5c:	2b03      	cmp	r3, #3
 8007d5e:	d008      	beq.n	8007d72 <USBD_StdEPReq+0x9a>
 8007d60:	2b03      	cmp	r3, #3
 8007d62:	f300 8145 	bgt.w	8007ff0 <USBD_StdEPReq+0x318>
 8007d66:	2b00      	cmp	r3, #0
 8007d68:	f000 809b 	beq.w	8007ea2 <USBD_StdEPReq+0x1ca>
 8007d6c:	2b01      	cmp	r3, #1
 8007d6e:	d03c      	beq.n	8007dea <USBD_StdEPReq+0x112>
 8007d70:	e13e      	b.n	8007ff0 <USBD_StdEPReq+0x318>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
 8007d72:	687b      	ldr	r3, [r7, #4]
 8007d74:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007d78:	b2db      	uxtb	r3, r3
 8007d7a:	2b02      	cmp	r3, #2
 8007d7c:	d002      	beq.n	8007d84 <USBD_StdEPReq+0xac>
 8007d7e:	2b03      	cmp	r3, #3
 8007d80:	d016      	beq.n	8007db0 <USBD_StdEPReq+0xd8>
 8007d82:	e02c      	b.n	8007dde <USBD_StdEPReq+0x106>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8007d84:	7bbb      	ldrb	r3, [r7, #14]
 8007d86:	2b00      	cmp	r3, #0
 8007d88:	d00d      	beq.n	8007da6 <USBD_StdEPReq+0xce>
 8007d8a:	7bbb      	ldrb	r3, [r7, #14]
 8007d8c:	2b80      	cmp	r3, #128	@ 0x80
 8007d8e:	d00a      	beq.n	8007da6 <USBD_StdEPReq+0xce>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8007d90:	7bbb      	ldrb	r3, [r7, #14]
 8007d92:	4619      	mov	r1, r3
 8007d94:	6878      	ldr	r0, [r7, #4]
 8007d96:	f020 f92d 	bl	8027ff4 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8007d9a:	2180      	movs	r1, #128	@ 0x80
 8007d9c:	6878      	ldr	r0, [r7, #4]
 8007d9e:	f020 f929 	bl	8027ff4 <USBD_LL_StallEP>
 8007da2:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8007da4:	e020      	b.n	8007de8 <USBD_StdEPReq+0x110>
                USBD_CtlError(pdev, req);
 8007da6:	6839      	ldr	r1, [r7, #0]
 8007da8:	6878      	ldr	r0, [r7, #4]
 8007daa:	f000 fc7a 	bl	80086a2 <USBD_CtlError>
              break;
 8007dae:	e01b      	b.n	8007de8 <USBD_StdEPReq+0x110>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8007db0:	683b      	ldr	r3, [r7, #0]
 8007db2:	885b      	ldrh	r3, [r3, #2]
 8007db4:	2b00      	cmp	r3, #0
 8007db6:	d10e      	bne.n	8007dd6 <USBD_StdEPReq+0xfe>
              {
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8007db8:	7bbb      	ldrb	r3, [r7, #14]
 8007dba:	2b00      	cmp	r3, #0
 8007dbc:	d00b      	beq.n	8007dd6 <USBD_StdEPReq+0xfe>
 8007dbe:	7bbb      	ldrb	r3, [r7, #14]
 8007dc0:	2b80      	cmp	r3, #128	@ 0x80
 8007dc2:	d008      	beq.n	8007dd6 <USBD_StdEPReq+0xfe>
 8007dc4:	683b      	ldr	r3, [r7, #0]
 8007dc6:	88db      	ldrh	r3, [r3, #6]
 8007dc8:	2b00      	cmp	r3, #0
 8007dca:	d104      	bne.n	8007dd6 <USBD_StdEPReq+0xfe>
                {
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 8007dcc:	7bbb      	ldrb	r3, [r7, #14]
 8007dce:	4619      	mov	r1, r3
 8007dd0:	6878      	ldr	r0, [r7, #4]
 8007dd2:	f020 f90f 	bl	8027ff4 <USBD_LL_StallEP>
                }
              }
              (void)USBD_CtlSendStatus(pdev);
 8007dd6:	6878      	ldr	r0, [r7, #4]
 8007dd8:	f000 fd3a 	bl	8008850 <USBD_CtlSendStatus>

              break;
 8007ddc:	e004      	b.n	8007de8 <USBD_StdEPReq+0x110>

            default:
              USBD_CtlError(pdev, req);
 8007dde:	6839      	ldr	r1, [r7, #0]
 8007de0:	6878      	ldr	r0, [r7, #4]
 8007de2:	f000 fc5e 	bl	80086a2 <USBD_CtlError>
              break;
 8007de6:	bf00      	nop
          }
          break;
 8007de8:	e107      	b.n	8007ffa <USBD_StdEPReq+0x322>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
 8007dea:	687b      	ldr	r3, [r7, #4]
 8007dec:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007df0:	b2db      	uxtb	r3, r3
 8007df2:	2b02      	cmp	r3, #2
 8007df4:	d002      	beq.n	8007dfc <USBD_StdEPReq+0x124>
 8007df6:	2b03      	cmp	r3, #3
 8007df8:	d016      	beq.n	8007e28 <USBD_StdEPReq+0x150>
 8007dfa:	e04b      	b.n	8007e94 <USBD_StdEPReq+0x1bc>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8007dfc:	7bbb      	ldrb	r3, [r7, #14]
 8007dfe:	2b00      	cmp	r3, #0
 8007e00:	d00d      	beq.n	8007e1e <USBD_StdEPReq+0x146>
 8007e02:	7bbb      	ldrb	r3, [r7, #14]
 8007e04:	2b80      	cmp	r3, #128	@ 0x80
 8007e06:	d00a      	beq.n	8007e1e <USBD_StdEPReq+0x146>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8007e08:	7bbb      	ldrb	r3, [r7, #14]
 8007e0a:	4619      	mov	r1, r3
 8007e0c:	6878      	ldr	r0, [r7, #4]
 8007e0e:	f020 f8f1 	bl	8027ff4 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8007e12:	2180      	movs	r1, #128	@ 0x80
 8007e14:	6878      	ldr	r0, [r7, #4]
 8007e16:	f020 f8ed 	bl	8027ff4 <USBD_LL_StallEP>
 8007e1a:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8007e1c:	e040      	b.n	8007ea0 <USBD_StdEPReq+0x1c8>
                USBD_CtlError(pdev, req);
 8007e1e:	6839      	ldr	r1, [r7, #0]
 8007e20:	6878      	ldr	r0, [r7, #4]
 8007e22:	f000 fc3e 	bl	80086a2 <USBD_CtlError>
              break;
 8007e26:	e03b      	b.n	8007ea0 <USBD_StdEPReq+0x1c8>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8007e28:	683b      	ldr	r3, [r7, #0]
 8007e2a:	885b      	ldrh	r3, [r3, #2]
 8007e2c:	2b00      	cmp	r3, #0
 8007e2e:	d136      	bne.n	8007e9e <USBD_StdEPReq+0x1c6>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
 8007e30:	7bbb      	ldrb	r3, [r7, #14]
 8007e32:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8007e36:	2b00      	cmp	r3, #0
 8007e38:	d004      	beq.n	8007e44 <USBD_StdEPReq+0x16c>
                {
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 8007e3a:	7bbb      	ldrb	r3, [r7, #14]
 8007e3c:	4619      	mov	r1, r3
 8007e3e:	6878      	ldr	r0, [r7, #4]
 8007e40:	f020 f8f7 	bl	8028032 <USBD_LL_ClearStallEP>
                }
                (void)USBD_CtlSendStatus(pdev);
 8007e44:	6878      	ldr	r0, [r7, #4]
 8007e46:	f000 fd03 	bl	8008850 <USBD_CtlSendStatus>

                /* Get the class index relative to this interface */
                idx = USBD_CoreFindEP(pdev, ep_addr);
 8007e4a:	7bbb      	ldrb	r3, [r7, #14]
 8007e4c:	4619      	mov	r1, r3
 8007e4e:	6878      	ldr	r0, [r7, #4]
 8007e50:	f7ff fde4 	bl	8007a1c <USBD_CoreFindEP>
 8007e54:	4603      	mov	r3, r0
 8007e56:	737b      	strb	r3, [r7, #13]
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8007e58:	7b7b      	ldrb	r3, [r7, #13]
 8007e5a:	2bff      	cmp	r3, #255	@ 0xff
 8007e5c:	d01f      	beq.n	8007e9e <USBD_StdEPReq+0x1c6>
 8007e5e:	7b7b      	ldrb	r3, [r7, #13]
 8007e60:	2b00      	cmp	r3, #0
 8007e62:	d11c      	bne.n	8007e9e <USBD_StdEPReq+0x1c6>
                {
                  pdev->classId = idx;
 8007e64:	7b7a      	ldrb	r2, [r7, #13]
 8007e66:	687b      	ldr	r3, [r7, #4]
 8007e68:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                  /* Call the class data out function to manage the request */
                  if (pdev->pClass[idx]->Setup != NULL)
 8007e6c:	7b7a      	ldrb	r2, [r7, #13]
 8007e6e:	687b      	ldr	r3, [r7, #4]
 8007e70:	32ae      	adds	r2, #174	@ 0xae
 8007e72:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007e76:	689b      	ldr	r3, [r3, #8]
 8007e78:	2b00      	cmp	r3, #0
 8007e7a:	d010      	beq.n	8007e9e <USBD_StdEPReq+0x1c6>
                  {
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8007e7c:	7b7a      	ldrb	r2, [r7, #13]
 8007e7e:	687b      	ldr	r3, [r7, #4]
 8007e80:	32ae      	adds	r2, #174	@ 0xae
 8007e82:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007e86:	689b      	ldr	r3, [r3, #8]
 8007e88:	6839      	ldr	r1, [r7, #0]
 8007e8a:	6878      	ldr	r0, [r7, #4]
 8007e8c:	4798      	blx	r3
 8007e8e:	4603      	mov	r3, r0
 8007e90:	73fb      	strb	r3, [r7, #15]
                  }
                }
              }
              break;
 8007e92:	e004      	b.n	8007e9e <USBD_StdEPReq+0x1c6>

            default:
              USBD_CtlError(pdev, req);
 8007e94:	6839      	ldr	r1, [r7, #0]
 8007e96:	6878      	ldr	r0, [r7, #4]
 8007e98:	f000 fc03 	bl	80086a2 <USBD_CtlError>
              break;
 8007e9c:	e000      	b.n	8007ea0 <USBD_StdEPReq+0x1c8>
              break;
 8007e9e:	bf00      	nop
          }
          break;
 8007ea0:	e0ab      	b.n	8007ffa <USBD_StdEPReq+0x322>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
 8007ea2:	687b      	ldr	r3, [r7, #4]
 8007ea4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8007ea8:	b2db      	uxtb	r3, r3
 8007eaa:	2b02      	cmp	r3, #2
 8007eac:	d002      	beq.n	8007eb4 <USBD_StdEPReq+0x1dc>
 8007eae:	2b03      	cmp	r3, #3
 8007eb0:	d032      	beq.n	8007f18 <USBD_StdEPReq+0x240>
 8007eb2:	e097      	b.n	8007fe4 <USBD_StdEPReq+0x30c>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8007eb4:	7bbb      	ldrb	r3, [r7, #14]
 8007eb6:	2b00      	cmp	r3, #0
 8007eb8:	d007      	beq.n	8007eca <USBD_StdEPReq+0x1f2>
 8007eba:	7bbb      	ldrb	r3, [r7, #14]
 8007ebc:	2b80      	cmp	r3, #128	@ 0x80
 8007ebe:	d004      	beq.n	8007eca <USBD_StdEPReq+0x1f2>
              {
                USBD_CtlError(pdev, req);
 8007ec0:	6839      	ldr	r1, [r7, #0]
 8007ec2:	6878      	ldr	r0, [r7, #4]
 8007ec4:	f000 fbed 	bl	80086a2 <USBD_CtlError>
                break;
 8007ec8:	e091      	b.n	8007fee <USBD_StdEPReq+0x316>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8007eca:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8007ece:	2b00      	cmp	r3, #0
 8007ed0:	da0b      	bge.n	8007eea <USBD_StdEPReq+0x212>
 8007ed2:	7bbb      	ldrb	r3, [r7, #14]
 8007ed4:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8007ed8:	4613      	mov	r3, r2
 8007eda:	009b      	lsls	r3, r3, #2
 8007edc:	4413      	add	r3, r2
 8007ede:	009b      	lsls	r3, r3, #2
 8007ee0:	3310      	adds	r3, #16
 8007ee2:	687a      	ldr	r2, [r7, #4]
 8007ee4:	4413      	add	r3, r2
 8007ee6:	3304      	adds	r3, #4
 8007ee8:	e00b      	b.n	8007f02 <USBD_StdEPReq+0x22a>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8007eea:	7bbb      	ldrb	r3, [r7, #14]
 8007eec:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8007ef0:	4613      	mov	r3, r2
 8007ef2:	009b      	lsls	r3, r3, #2
 8007ef4:	4413      	add	r3, r2
 8007ef6:	009b      	lsls	r3, r3, #2
 8007ef8:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8007efc:	687a      	ldr	r2, [r7, #4]
 8007efe:	4413      	add	r3, r2
 8007f00:	3304      	adds	r3, #4
 8007f02:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
 8007f04:	68bb      	ldr	r3, [r7, #8]
 8007f06:	2200      	movs	r2, #0
 8007f08:	601a      	str	r2, [r3, #0]

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8007f0a:	68bb      	ldr	r3, [r7, #8]
 8007f0c:	2202      	movs	r2, #2
 8007f0e:	4619      	mov	r1, r3
 8007f10:	6878      	ldr	r0, [r7, #4]
 8007f12:	f000 fc43 	bl	800879c <USBD_CtlSendData>
              break;
 8007f16:	e06a      	b.n	8007fee <USBD_StdEPReq+0x316>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
 8007f18:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8007f1c:	2b00      	cmp	r3, #0
 8007f1e:	da11      	bge.n	8007f44 <USBD_StdEPReq+0x26c>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8007f20:	7bbb      	ldrb	r3, [r7, #14]
 8007f22:	f003 020f 	and.w	r2, r3, #15
 8007f26:	6879      	ldr	r1, [r7, #4]
 8007f28:	4613      	mov	r3, r2
 8007f2a:	009b      	lsls	r3, r3, #2
 8007f2c:	4413      	add	r3, r2
 8007f2e:	009b      	lsls	r3, r3, #2
 8007f30:	440b      	add	r3, r1
 8007f32:	3324      	adds	r3, #36	@ 0x24
 8007f34:	881b      	ldrh	r3, [r3, #0]
 8007f36:	2b00      	cmp	r3, #0
 8007f38:	d117      	bne.n	8007f6a <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 8007f3a:	6839      	ldr	r1, [r7, #0]
 8007f3c:	6878      	ldr	r0, [r7, #4]
 8007f3e:	f000 fbb0 	bl	80086a2 <USBD_CtlError>
                  break;
 8007f42:	e054      	b.n	8007fee <USBD_StdEPReq+0x316>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8007f44:	7bbb      	ldrb	r3, [r7, #14]
 8007f46:	f003 020f 	and.w	r2, r3, #15
 8007f4a:	6879      	ldr	r1, [r7, #4]
 8007f4c:	4613      	mov	r3, r2
 8007f4e:	009b      	lsls	r3, r3, #2
 8007f50:	4413      	add	r3, r2
 8007f52:	009b      	lsls	r3, r3, #2
 8007f54:	440b      	add	r3, r1
 8007f56:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8007f5a:	881b      	ldrh	r3, [r3, #0]
 8007f5c:	2b00      	cmp	r3, #0
 8007f5e:	d104      	bne.n	8007f6a <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 8007f60:	6839      	ldr	r1, [r7, #0]
 8007f62:	6878      	ldr	r0, [r7, #4]
 8007f64:	f000 fb9d 	bl	80086a2 <USBD_CtlError>
                  break;
 8007f68:	e041      	b.n	8007fee <USBD_StdEPReq+0x316>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8007f6a:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8007f6e:	2b00      	cmp	r3, #0
 8007f70:	da0b      	bge.n	8007f8a <USBD_StdEPReq+0x2b2>
 8007f72:	7bbb      	ldrb	r3, [r7, #14]
 8007f74:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8007f78:	4613      	mov	r3, r2
 8007f7a:	009b      	lsls	r3, r3, #2
 8007f7c:	4413      	add	r3, r2
 8007f7e:	009b      	lsls	r3, r3, #2
 8007f80:	3310      	adds	r3, #16
 8007f82:	687a      	ldr	r2, [r7, #4]
 8007f84:	4413      	add	r3, r2
 8007f86:	3304      	adds	r3, #4
 8007f88:	e00b      	b.n	8007fa2 <USBD_StdEPReq+0x2ca>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8007f8a:	7bbb      	ldrb	r3, [r7, #14]
 8007f8c:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8007f90:	4613      	mov	r3, r2
 8007f92:	009b      	lsls	r3, r3, #2
 8007f94:	4413      	add	r3, r2
 8007f96:	009b      	lsls	r3, r3, #2
 8007f98:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8007f9c:	687a      	ldr	r2, [r7, #4]
 8007f9e:	4413      	add	r3, r2
 8007fa0:	3304      	adds	r3, #4
 8007fa2:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8007fa4:	7bbb      	ldrb	r3, [r7, #14]
 8007fa6:	2b00      	cmp	r3, #0
 8007fa8:	d002      	beq.n	8007fb0 <USBD_StdEPReq+0x2d8>
 8007faa:	7bbb      	ldrb	r3, [r7, #14]
 8007fac:	2b80      	cmp	r3, #128	@ 0x80
 8007fae:	d103      	bne.n	8007fb8 <USBD_StdEPReq+0x2e0>
              {
                pep->status = 0x0000U;
 8007fb0:	68bb      	ldr	r3, [r7, #8]
 8007fb2:	2200      	movs	r2, #0
 8007fb4:	601a      	str	r2, [r3, #0]
 8007fb6:	e00e      	b.n	8007fd6 <USBD_StdEPReq+0x2fe>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 8007fb8:	7bbb      	ldrb	r3, [r7, #14]
 8007fba:	4619      	mov	r1, r3
 8007fbc:	6878      	ldr	r0, [r7, #4]
 8007fbe:	f020 f857 	bl	8028070 <USBD_LL_IsStallEP>
 8007fc2:	4603      	mov	r3, r0
 8007fc4:	2b00      	cmp	r3, #0
 8007fc6:	d003      	beq.n	8007fd0 <USBD_StdEPReq+0x2f8>
              {
                pep->status = 0x0001U;
 8007fc8:	68bb      	ldr	r3, [r7, #8]
 8007fca:	2201      	movs	r2, #1
 8007fcc:	601a      	str	r2, [r3, #0]
 8007fce:	e002      	b.n	8007fd6 <USBD_StdEPReq+0x2fe>
              }
              else
              {
                pep->status = 0x0000U;
 8007fd0:	68bb      	ldr	r3, [r7, #8]
 8007fd2:	2200      	movs	r2, #0
 8007fd4:	601a      	str	r2, [r3, #0]
              }

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8007fd6:	68bb      	ldr	r3, [r7, #8]
 8007fd8:	2202      	movs	r2, #2
 8007fda:	4619      	mov	r1, r3
 8007fdc:	6878      	ldr	r0, [r7, #4]
 8007fde:	f000 fbdd 	bl	800879c <USBD_CtlSendData>
              break;
 8007fe2:	e004      	b.n	8007fee <USBD_StdEPReq+0x316>

            default:
              USBD_CtlError(pdev, req);
 8007fe4:	6839      	ldr	r1, [r7, #0]
 8007fe6:	6878      	ldr	r0, [r7, #4]
 8007fe8:	f000 fb5b 	bl	80086a2 <USBD_CtlError>
              break;
 8007fec:	bf00      	nop
          }
          break;
 8007fee:	e004      	b.n	8007ffa <USBD_StdEPReq+0x322>

        default:
          USBD_CtlError(pdev, req);
 8007ff0:	6839      	ldr	r1, [r7, #0]
 8007ff2:	6878      	ldr	r0, [r7, #4]
 8007ff4:	f000 fb55 	bl	80086a2 <USBD_CtlError>
          break;
 8007ff8:	bf00      	nop
      }
      break;
 8007ffa:	e005      	b.n	8008008 <USBD_StdEPReq+0x330>

    default:
      USBD_CtlError(pdev, req);
 8007ffc:	6839      	ldr	r1, [r7, #0]
 8007ffe:	6878      	ldr	r0, [r7, #4]
 8008000:	f000 fb4f 	bl	80086a2 <USBD_CtlError>
      break;
 8008004:	e000      	b.n	8008008 <USBD_StdEPReq+0x330>
      break;
 8008006:	bf00      	nop
  }

  return ret;
 8008008:	7bfb      	ldrb	r3, [r7, #15]
}
 800800a:	4618      	mov	r0, r3
 800800c:	3710      	adds	r7, #16
 800800e:	46bd      	mov	sp, r7
 8008010:	bd80      	pop	{r7, pc}
	...

08008014 <USBD_GetDescriptor>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008014:	b580      	push	{r7, lr}
 8008016:	b084      	sub	sp, #16
 8008018:	af00      	add	r7, sp, #0
 800801a:	6078      	str	r0, [r7, #4]
 800801c:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 800801e:	2300      	movs	r3, #0
 8008020:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
 8008022:	2300      	movs	r3, #0
 8008024:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 8008026:	2300      	movs	r3, #0
 8008028:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
 800802a:	683b      	ldr	r3, [r7, #0]
 800802c:	885b      	ldrh	r3, [r3, #2]
 800802e:	0a1b      	lsrs	r3, r3, #8
 8008030:	b29b      	uxth	r3, r3
 8008032:	3b01      	subs	r3, #1
 8008034:	2b06      	cmp	r3, #6
 8008036:	f200 8128 	bhi.w	800828a <USBD_GetDescriptor+0x276>
 800803a:	a201      	add	r2, pc, #4	@ (adr r2, 8008040 <USBD_GetDescriptor+0x2c>)
 800803c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008040:	0800805d 	.word	0x0800805d
 8008044:	08008075 	.word	0x08008075
 8008048:	080080b5 	.word	0x080080b5
 800804c:	0800828b 	.word	0x0800828b
 8008050:	0800828b 	.word	0x0800828b
 8008054:	0800822b 	.word	0x0800822b
 8008058:	08008257 	.word	0x08008257
        err++;
      }
      break;
#endif /* (USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U) */
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 800805c:	687b      	ldr	r3, [r7, #4]
 800805e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8008062:	681b      	ldr	r3, [r3, #0]
 8008064:	687a      	ldr	r2, [r7, #4]
 8008066:	7c12      	ldrb	r2, [r2, #16]
 8008068:	f107 0108 	add.w	r1, r7, #8
 800806c:	4610      	mov	r0, r2
 800806e:	4798      	blx	r3
 8008070:	60f8      	str	r0, [r7, #12]
      break;
 8008072:	e112      	b.n	800829a <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8008074:	687b      	ldr	r3, [r7, #4]
 8008076:	7c1b      	ldrb	r3, [r3, #16]
 8008078:	2b00      	cmp	r3, #0
 800807a:	d10d      	bne.n	8008098 <USBD_GetDescriptor+0x84>
          pbuf = (uint8_t *)USBD_CMPSIT.GetHSConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 800807c:	687b      	ldr	r3, [r7, #4]
 800807e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8008082:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8008084:	f107 0208 	add.w	r2, r7, #8
 8008088:	4610      	mov	r0, r2
 800808a:	4798      	blx	r3
 800808c:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800808e:	68fb      	ldr	r3, [r7, #12]
 8008090:	3301      	adds	r3, #1
 8008092:	2202      	movs	r2, #2
 8008094:	701a      	strb	r2, [r3, #0]
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
 8008096:	e100      	b.n	800829a <USBD_GetDescriptor+0x286>
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 8008098:	687b      	ldr	r3, [r7, #4]
 800809a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 800809e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80080a0:	f107 0208 	add.w	r2, r7, #8
 80080a4:	4610      	mov	r0, r2
 80080a6:	4798      	blx	r3
 80080a8:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80080aa:	68fb      	ldr	r3, [r7, #12]
 80080ac:	3301      	adds	r3, #1
 80080ae:	2202      	movs	r2, #2
 80080b0:	701a      	strb	r2, [r3, #0]
      break;
 80080b2:	e0f2      	b.n	800829a <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
 80080b4:	683b      	ldr	r3, [r7, #0]
 80080b6:	885b      	ldrh	r3, [r3, #2]
 80080b8:	b2db      	uxtb	r3, r3
 80080ba:	2b05      	cmp	r3, #5
 80080bc:	f200 80ac 	bhi.w	8008218 <USBD_GetDescriptor+0x204>
 80080c0:	a201      	add	r2, pc, #4	@ (adr r2, 80080c8 <USBD_GetDescriptor+0xb4>)
 80080c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80080c6:	bf00      	nop
 80080c8:	080080e1 	.word	0x080080e1
 80080cc:	08008115 	.word	0x08008115
 80080d0:	08008149 	.word	0x08008149
 80080d4:	0800817d 	.word	0x0800817d
 80080d8:	080081b1 	.word	0x080081b1
 80080dc:	080081e5 	.word	0x080081e5
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 80080e0:	687b      	ldr	r3, [r7, #4]
 80080e2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80080e6:	685b      	ldr	r3, [r3, #4]
 80080e8:	2b00      	cmp	r3, #0
 80080ea:	d00b      	beq.n	8008104 <USBD_GetDescriptor+0xf0>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 80080ec:	687b      	ldr	r3, [r7, #4]
 80080ee:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80080f2:	685b      	ldr	r3, [r3, #4]
 80080f4:	687a      	ldr	r2, [r7, #4]
 80080f6:	7c12      	ldrb	r2, [r2, #16]
 80080f8:	f107 0108 	add.w	r1, r7, #8
 80080fc:	4610      	mov	r0, r2
 80080fe:	4798      	blx	r3
 8008100:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8008102:	e091      	b.n	8008228 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8008104:	6839      	ldr	r1, [r7, #0]
 8008106:	6878      	ldr	r0, [r7, #4]
 8008108:	f000 facb 	bl	80086a2 <USBD_CtlError>
            err++;
 800810c:	7afb      	ldrb	r3, [r7, #11]
 800810e:	3301      	adds	r3, #1
 8008110:	72fb      	strb	r3, [r7, #11]
          break;
 8008112:	e089      	b.n	8008228 <USBD_GetDescriptor+0x214>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8008114:	687b      	ldr	r3, [r7, #4]
 8008116:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800811a:	689b      	ldr	r3, [r3, #8]
 800811c:	2b00      	cmp	r3, #0
 800811e:	d00b      	beq.n	8008138 <USBD_GetDescriptor+0x124>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8008120:	687b      	ldr	r3, [r7, #4]
 8008122:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8008126:	689b      	ldr	r3, [r3, #8]
 8008128:	687a      	ldr	r2, [r7, #4]
 800812a:	7c12      	ldrb	r2, [r2, #16]
 800812c:	f107 0108 	add.w	r1, r7, #8
 8008130:	4610      	mov	r0, r2
 8008132:	4798      	blx	r3
 8008134:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8008136:	e077      	b.n	8008228 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8008138:	6839      	ldr	r1, [r7, #0]
 800813a:	6878      	ldr	r0, [r7, #4]
 800813c:	f000 fab1 	bl	80086a2 <USBD_CtlError>
            err++;
 8008140:	7afb      	ldrb	r3, [r7, #11]
 8008142:	3301      	adds	r3, #1
 8008144:	72fb      	strb	r3, [r7, #11]
          break;
 8008146:	e06f      	b.n	8008228 <USBD_GetDescriptor+0x214>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 8008148:	687b      	ldr	r3, [r7, #4]
 800814a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800814e:	68db      	ldr	r3, [r3, #12]
 8008150:	2b00      	cmp	r3, #0
 8008152:	d00b      	beq.n	800816c <USBD_GetDescriptor+0x158>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8008154:	687b      	ldr	r3, [r7, #4]
 8008156:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800815a:	68db      	ldr	r3, [r3, #12]
 800815c:	687a      	ldr	r2, [r7, #4]
 800815e:	7c12      	ldrb	r2, [r2, #16]
 8008160:	f107 0108 	add.w	r1, r7, #8
 8008164:	4610      	mov	r0, r2
 8008166:	4798      	blx	r3
 8008168:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 800816a:	e05d      	b.n	8008228 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 800816c:	6839      	ldr	r1, [r7, #0]
 800816e:	6878      	ldr	r0, [r7, #4]
 8008170:	f000 fa97 	bl	80086a2 <USBD_CtlError>
            err++;
 8008174:	7afb      	ldrb	r3, [r7, #11]
 8008176:	3301      	adds	r3, #1
 8008178:	72fb      	strb	r3, [r7, #11]
          break;
 800817a:	e055      	b.n	8008228 <USBD_GetDescriptor+0x214>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 800817c:	687b      	ldr	r3, [r7, #4]
 800817e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8008182:	691b      	ldr	r3, [r3, #16]
 8008184:	2b00      	cmp	r3, #0
 8008186:	d00b      	beq.n	80081a0 <USBD_GetDescriptor+0x18c>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8008188:	687b      	ldr	r3, [r7, #4]
 800818a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 800818e:	691b      	ldr	r3, [r3, #16]
 8008190:	687a      	ldr	r2, [r7, #4]
 8008192:	7c12      	ldrb	r2, [r2, #16]
 8008194:	f107 0108 	add.w	r1, r7, #8
 8008198:	4610      	mov	r0, r2
 800819a:	4798      	blx	r3
 800819c:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 800819e:	e043      	b.n	8008228 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 80081a0:	6839      	ldr	r1, [r7, #0]
 80081a2:	6878      	ldr	r0, [r7, #4]
 80081a4:	f000 fa7d 	bl	80086a2 <USBD_CtlError>
            err++;
 80081a8:	7afb      	ldrb	r3, [r7, #11]
 80081aa:	3301      	adds	r3, #1
 80081ac:	72fb      	strb	r3, [r7, #11]
          break;
 80081ae:	e03b      	b.n	8008228 <USBD_GetDescriptor+0x214>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 80081b0:	687b      	ldr	r3, [r7, #4]
 80081b2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80081b6:	695b      	ldr	r3, [r3, #20]
 80081b8:	2b00      	cmp	r3, #0
 80081ba:	d00b      	beq.n	80081d4 <USBD_GetDescriptor+0x1c0>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 80081bc:	687b      	ldr	r3, [r7, #4]
 80081be:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80081c2:	695b      	ldr	r3, [r3, #20]
 80081c4:	687a      	ldr	r2, [r7, #4]
 80081c6:	7c12      	ldrb	r2, [r2, #16]
 80081c8:	f107 0108 	add.w	r1, r7, #8
 80081cc:	4610      	mov	r0, r2
 80081ce:	4798      	blx	r3
 80081d0:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 80081d2:	e029      	b.n	8008228 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 80081d4:	6839      	ldr	r1, [r7, #0]
 80081d6:	6878      	ldr	r0, [r7, #4]
 80081d8:	f000 fa63 	bl	80086a2 <USBD_CtlError>
            err++;
 80081dc:	7afb      	ldrb	r3, [r7, #11]
 80081de:	3301      	adds	r3, #1
 80081e0:	72fb      	strb	r3, [r7, #11]
          break;
 80081e2:	e021      	b.n	8008228 <USBD_GetDescriptor+0x214>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 80081e4:	687b      	ldr	r3, [r7, #4]
 80081e6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80081ea:	699b      	ldr	r3, [r3, #24]
 80081ec:	2b00      	cmp	r3, #0
 80081ee:	d00b      	beq.n	8008208 <USBD_GetDescriptor+0x1f4>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 80081f0:	687b      	ldr	r3, [r7, #4]
 80081f2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 80081f6:	699b      	ldr	r3, [r3, #24]
 80081f8:	687a      	ldr	r2, [r7, #4]
 80081fa:	7c12      	ldrb	r2, [r2, #16]
 80081fc:	f107 0108 	add.w	r1, r7, #8
 8008200:	4610      	mov	r0, r2
 8008202:	4798      	blx	r3
 8008204:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8008206:	e00f      	b.n	8008228 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8008208:	6839      	ldr	r1, [r7, #0]
 800820a:	6878      	ldr	r0, [r7, #4]
 800820c:	f000 fa49 	bl	80086a2 <USBD_CtlError>
            err++;
 8008210:	7afb      	ldrb	r3, [r7, #11]
 8008212:	3301      	adds	r3, #1
 8008214:	72fb      	strb	r3, [r7, #11]
          break;
 8008216:	e007      	b.n	8008228 <USBD_GetDescriptor+0x214>
            err++;
          }
#endif /* USBD_SUPPORT_USER_STRING_DESC  */

#if ((USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U))
          USBD_CtlError(pdev, req);
 8008218:	6839      	ldr	r1, [r7, #0]
 800821a:	6878      	ldr	r0, [r7, #4]
 800821c:	f000 fa41 	bl	80086a2 <USBD_CtlError>
          err++;
 8008220:	7afb      	ldrb	r3, [r7, #11]
 8008222:	3301      	adds	r3, #1
 8008224:	72fb      	strb	r3, [r7, #11]
#endif /* (USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U) */
          break;
 8008226:	bf00      	nop
      }
      break;
 8008228:	e037      	b.n	800829a <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800822a:	687b      	ldr	r3, [r7, #4]
 800822c:	7c1b      	ldrb	r3, [r3, #16]
 800822e:	2b00      	cmp	r3, #0
 8008230:	d109      	bne.n	8008246 <USBD_GetDescriptor+0x232>
          pbuf = (uint8_t *)USBD_CMPSIT.GetDeviceQualifierDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 8008232:	687b      	ldr	r3, [r7, #4]
 8008234:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8008238:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800823a:	f107 0208 	add.w	r2, r7, #8
 800823e:	4610      	mov	r0, r2
 8008240:	4798      	blx	r3
 8008242:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8008244:	e029      	b.n	800829a <USBD_GetDescriptor+0x286>
        USBD_CtlError(pdev, req);
 8008246:	6839      	ldr	r1, [r7, #0]
 8008248:	6878      	ldr	r0, [r7, #4]
 800824a:	f000 fa2a 	bl	80086a2 <USBD_CtlError>
        err++;
 800824e:	7afb      	ldrb	r3, [r7, #11]
 8008250:	3301      	adds	r3, #1
 8008252:	72fb      	strb	r3, [r7, #11]
      break;
 8008254:	e021      	b.n	800829a <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8008256:	687b      	ldr	r3, [r7, #4]
 8008258:	7c1b      	ldrb	r3, [r3, #16]
 800825a:	2b00      	cmp	r3, #0
 800825c:	d10d      	bne.n	800827a <USBD_GetDescriptor+0x266>
          pbuf = (uint8_t *)USBD_CMPSIT.GetOtherSpeedConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 800825e:	687b      	ldr	r3, [r7, #4]
 8008260:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8008264:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8008266:	f107 0208 	add.w	r2, r7, #8
 800826a:	4610      	mov	r0, r2
 800826c:	4798      	blx	r3
 800826e:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8008270:	68fb      	ldr	r3, [r7, #12]
 8008272:	3301      	adds	r3, #1
 8008274:	2207      	movs	r2, #7
 8008276:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8008278:	e00f      	b.n	800829a <USBD_GetDescriptor+0x286>
        USBD_CtlError(pdev, req);
 800827a:	6839      	ldr	r1, [r7, #0]
 800827c:	6878      	ldr	r0, [r7, #4]
 800827e:	f000 fa10 	bl	80086a2 <USBD_CtlError>
        err++;
 8008282:	7afb      	ldrb	r3, [r7, #11]
 8008284:	3301      	adds	r3, #1
 8008286:	72fb      	strb	r3, [r7, #11]
      break;
 8008288:	e007      	b.n	800829a <USBD_GetDescriptor+0x286>

    default:
      USBD_CtlError(pdev, req);
 800828a:	6839      	ldr	r1, [r7, #0]
 800828c:	6878      	ldr	r0, [r7, #4]
 800828e:	f000 fa08 	bl	80086a2 <USBD_CtlError>
      err++;
 8008292:	7afb      	ldrb	r3, [r7, #11]
 8008294:	3301      	adds	r3, #1
 8008296:	72fb      	strb	r3, [r7, #11]
      break;
 8008298:	bf00      	nop
  }

  if (err != 0U)
 800829a:	7afb      	ldrb	r3, [r7, #11]
 800829c:	2b00      	cmp	r3, #0
 800829e:	d11e      	bne.n	80082de <USBD_GetDescriptor+0x2ca>
  {
    return;
  }

  if (req->wLength != 0U)
 80082a0:	683b      	ldr	r3, [r7, #0]
 80082a2:	88db      	ldrh	r3, [r3, #6]
 80082a4:	2b00      	cmp	r3, #0
 80082a6:	d016      	beq.n	80082d6 <USBD_GetDescriptor+0x2c2>
  {
    if (len != 0U)
 80082a8:	893b      	ldrh	r3, [r7, #8]
 80082aa:	2b00      	cmp	r3, #0
 80082ac:	d00e      	beq.n	80082cc <USBD_GetDescriptor+0x2b8>
    {
      len = MIN(len, req->wLength);
 80082ae:	683b      	ldr	r3, [r7, #0]
 80082b0:	88da      	ldrh	r2, [r3, #6]
 80082b2:	893b      	ldrh	r3, [r7, #8]
 80082b4:	4293      	cmp	r3, r2
 80082b6:	bf28      	it	cs
 80082b8:	4613      	movcs	r3, r2
 80082ba:	b29b      	uxth	r3, r3
 80082bc:	813b      	strh	r3, [r7, #8]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 80082be:	893b      	ldrh	r3, [r7, #8]
 80082c0:	461a      	mov	r2, r3
 80082c2:	68f9      	ldr	r1, [r7, #12]
 80082c4:	6878      	ldr	r0, [r7, #4]
 80082c6:	f000 fa69 	bl	800879c <USBD_CtlSendData>
 80082ca:	e009      	b.n	80082e0 <USBD_GetDescriptor+0x2cc>
    }
    else
    {
      USBD_CtlError(pdev, req);
 80082cc:	6839      	ldr	r1, [r7, #0]
 80082ce:	6878      	ldr	r0, [r7, #4]
 80082d0:	f000 f9e7 	bl	80086a2 <USBD_CtlError>
 80082d4:	e004      	b.n	80082e0 <USBD_GetDescriptor+0x2cc>
    }
  }
  else
  {
    (void)USBD_CtlSendStatus(pdev);
 80082d6:	6878      	ldr	r0, [r7, #4]
 80082d8:	f000 faba 	bl	8008850 <USBD_CtlSendStatus>
 80082dc:	e000      	b.n	80082e0 <USBD_GetDescriptor+0x2cc>
    return;
 80082de:	bf00      	nop
  }
}
 80082e0:	3710      	adds	r7, #16
 80082e2:	46bd      	mov	sp, r7
 80082e4:	bd80      	pop	{r7, pc}
 80082e6:	bf00      	nop

080082e8 <USBD_SetAddress>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80082e8:	b580      	push	{r7, lr}
 80082ea:	b084      	sub	sp, #16
 80082ec:	af00      	add	r7, sp, #0
 80082ee:	6078      	str	r0, [r7, #4]
 80082f0:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 80082f2:	683b      	ldr	r3, [r7, #0]
 80082f4:	889b      	ldrh	r3, [r3, #4]
 80082f6:	2b00      	cmp	r3, #0
 80082f8:	d131      	bne.n	800835e <USBD_SetAddress+0x76>
 80082fa:	683b      	ldr	r3, [r7, #0]
 80082fc:	88db      	ldrh	r3, [r3, #6]
 80082fe:	2b00      	cmp	r3, #0
 8008300:	d12d      	bne.n	800835e <USBD_SetAddress+0x76>
 8008302:	683b      	ldr	r3, [r7, #0]
 8008304:	885b      	ldrh	r3, [r3, #2]
 8008306:	2b7f      	cmp	r3, #127	@ 0x7f
 8008308:	d829      	bhi.n	800835e <USBD_SetAddress+0x76>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 800830a:	683b      	ldr	r3, [r7, #0]
 800830c:	885b      	ldrh	r3, [r3, #2]
 800830e:	b2db      	uxtb	r3, r3
 8008310:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8008314:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8008316:	687b      	ldr	r3, [r7, #4]
 8008318:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 800831c:	b2db      	uxtb	r3, r3
 800831e:	2b03      	cmp	r3, #3
 8008320:	d104      	bne.n	800832c <USBD_SetAddress+0x44>
    {
      USBD_CtlError(pdev, req);
 8008322:	6839      	ldr	r1, [r7, #0]
 8008324:	6878      	ldr	r0, [r7, #4]
 8008326:	f000 f9bc 	bl	80086a2 <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800832a:	e01d      	b.n	8008368 <USBD_SetAddress+0x80>
    }
    else
    {
      pdev->dev_address = dev_addr;
 800832c:	687b      	ldr	r3, [r7, #4]
 800832e:	7bfa      	ldrb	r2, [r7, #15]
 8008330:	f883 229e 	strb.w	r2, [r3, #670]	@ 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 8008334:	7bfb      	ldrb	r3, [r7, #15]
 8008336:	4619      	mov	r1, r3
 8008338:	6878      	ldr	r0, [r7, #4]
 800833a:	f01f fec5 	bl	80280c8 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 800833e:	6878      	ldr	r0, [r7, #4]
 8008340:	f000 fa86 	bl	8008850 <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 8008344:	7bfb      	ldrb	r3, [r7, #15]
 8008346:	2b00      	cmp	r3, #0
 8008348:	d004      	beq.n	8008354 <USBD_SetAddress+0x6c>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800834a:	687b      	ldr	r3, [r7, #4]
 800834c:	2202      	movs	r2, #2
 800834e:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8008352:	e009      	b.n	8008368 <USBD_SetAddress+0x80>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 8008354:	687b      	ldr	r3, [r7, #4]
 8008356:	2201      	movs	r2, #1
 8008358:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800835c:	e004      	b.n	8008368 <USBD_SetAddress+0x80>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 800835e:	6839      	ldr	r1, [r7, #0]
 8008360:	6878      	ldr	r0, [r7, #4]
 8008362:	f000 f99e 	bl	80086a2 <USBD_CtlError>
  }
}
 8008366:	bf00      	nop
 8008368:	bf00      	nop
 800836a:	3710      	adds	r7, #16
 800836c:	46bd      	mov	sp, r7
 800836e:	bd80      	pop	{r7, pc}

08008370 <USBD_SetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008370:	b580      	push	{r7, lr}
 8008372:	b084      	sub	sp, #16
 8008374:	af00      	add	r7, sp, #0
 8008376:	6078      	str	r0, [r7, #4]
 8008378:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 800837a:	2300      	movs	r3, #0
 800837c:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 800837e:	683b      	ldr	r3, [r7, #0]
 8008380:	885b      	ldrh	r3, [r3, #2]
 8008382:	b2da      	uxtb	r2, r3
 8008384:	4b4e      	ldr	r3, [pc, #312]	@ (80084c0 <USBD_SetConfig+0x150>)
 8008386:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8008388:	4b4d      	ldr	r3, [pc, #308]	@ (80084c0 <USBD_SetConfig+0x150>)
 800838a:	781b      	ldrb	r3, [r3, #0]
 800838c:	2b01      	cmp	r3, #1
 800838e:	d905      	bls.n	800839c <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
 8008390:	6839      	ldr	r1, [r7, #0]
 8008392:	6878      	ldr	r0, [r7, #4]
 8008394:	f000 f985 	bl	80086a2 <USBD_CtlError>
    return USBD_FAIL;
 8008398:	2303      	movs	r3, #3
 800839a:	e08c      	b.n	80084b6 <USBD_SetConfig+0x146>
  }

  switch (pdev->dev_state)
 800839c:	687b      	ldr	r3, [r7, #4]
 800839e:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80083a2:	b2db      	uxtb	r3, r3
 80083a4:	2b02      	cmp	r3, #2
 80083a6:	d002      	beq.n	80083ae <USBD_SetConfig+0x3e>
 80083a8:	2b03      	cmp	r3, #3
 80083aa:	d029      	beq.n	8008400 <USBD_SetConfig+0x90>
 80083ac:	e075      	b.n	800849a <USBD_SetConfig+0x12a>
  {
    case USBD_STATE_ADDRESSED:
      if (cfgidx != 0U)
 80083ae:	4b44      	ldr	r3, [pc, #272]	@ (80084c0 <USBD_SetConfig+0x150>)
 80083b0:	781b      	ldrb	r3, [r3, #0]
 80083b2:	2b00      	cmp	r3, #0
 80083b4:	d020      	beq.n	80083f8 <USBD_SetConfig+0x88>
      {
        pdev->dev_config = cfgidx;
 80083b6:	4b42      	ldr	r3, [pc, #264]	@ (80084c0 <USBD_SetConfig+0x150>)
 80083b8:	781b      	ldrb	r3, [r3, #0]
 80083ba:	461a      	mov	r2, r3
 80083bc:	687b      	ldr	r3, [r7, #4]
 80083be:	605a      	str	r2, [r3, #4]

        ret = USBD_SetClassConfig(pdev, cfgidx);
 80083c0:	4b3f      	ldr	r3, [pc, #252]	@ (80084c0 <USBD_SetConfig+0x150>)
 80083c2:	781b      	ldrb	r3, [r3, #0]
 80083c4:	4619      	mov	r1, r3
 80083c6:	6878      	ldr	r0, [r7, #4]
 80083c8:	f7fe ffe3 	bl	8007392 <USBD_SetClassConfig>
 80083cc:	4603      	mov	r3, r0
 80083ce:	73fb      	strb	r3, [r7, #15]

        if (ret != USBD_OK)
 80083d0:	7bfb      	ldrb	r3, [r7, #15]
 80083d2:	2b00      	cmp	r3, #0
 80083d4:	d008      	beq.n	80083e8 <USBD_SetConfig+0x78>
        {
          USBD_CtlError(pdev, req);
 80083d6:	6839      	ldr	r1, [r7, #0]
 80083d8:	6878      	ldr	r0, [r7, #4]
 80083da:	f000 f962 	bl	80086a2 <USBD_CtlError>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 80083de:	687b      	ldr	r3, [r7, #4]
 80083e0:	2202      	movs	r2, #2
 80083e2:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 80083e6:	e065      	b.n	80084b4 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 80083e8:	6878      	ldr	r0, [r7, #4]
 80083ea:	f000 fa31 	bl	8008850 <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 80083ee:	687b      	ldr	r3, [r7, #4]
 80083f0:	2203      	movs	r2, #3
 80083f2:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 80083f6:	e05d      	b.n	80084b4 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 80083f8:	6878      	ldr	r0, [r7, #4]
 80083fa:	f000 fa29 	bl	8008850 <USBD_CtlSendStatus>
      break;
 80083fe:	e059      	b.n	80084b4 <USBD_SetConfig+0x144>

    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0U)
 8008400:	4b2f      	ldr	r3, [pc, #188]	@ (80084c0 <USBD_SetConfig+0x150>)
 8008402:	781b      	ldrb	r3, [r3, #0]
 8008404:	2b00      	cmp	r3, #0
 8008406:	d112      	bne.n	800842e <USBD_SetConfig+0xbe>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8008408:	687b      	ldr	r3, [r7, #4]
 800840a:	2202      	movs	r2, #2
 800840c:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        pdev->dev_config = cfgidx;
 8008410:	4b2b      	ldr	r3, [pc, #172]	@ (80084c0 <USBD_SetConfig+0x150>)
 8008412:	781b      	ldrb	r3, [r3, #0]
 8008414:	461a      	mov	r2, r3
 8008416:	687b      	ldr	r3, [r7, #4]
 8008418:	605a      	str	r2, [r3, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 800841a:	4b29      	ldr	r3, [pc, #164]	@ (80084c0 <USBD_SetConfig+0x150>)
 800841c:	781b      	ldrb	r3, [r3, #0]
 800841e:	4619      	mov	r1, r3
 8008420:	6878      	ldr	r0, [r7, #4]
 8008422:	f7fe ffd2 	bl	80073ca <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 8008426:	6878      	ldr	r0, [r7, #4]
 8008428:	f000 fa12 	bl	8008850 <USBD_CtlSendStatus>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 800842c:	e042      	b.n	80084b4 <USBD_SetConfig+0x144>
      else if (cfgidx != pdev->dev_config)
 800842e:	4b24      	ldr	r3, [pc, #144]	@ (80084c0 <USBD_SetConfig+0x150>)
 8008430:	781b      	ldrb	r3, [r3, #0]
 8008432:	461a      	mov	r2, r3
 8008434:	687b      	ldr	r3, [r7, #4]
 8008436:	685b      	ldr	r3, [r3, #4]
 8008438:	429a      	cmp	r2, r3
 800843a:	d02a      	beq.n	8008492 <USBD_SetConfig+0x122>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 800843c:	687b      	ldr	r3, [r7, #4]
 800843e:	685b      	ldr	r3, [r3, #4]
 8008440:	b2db      	uxtb	r3, r3
 8008442:	4619      	mov	r1, r3
 8008444:	6878      	ldr	r0, [r7, #4]
 8008446:	f7fe ffc0 	bl	80073ca <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 800844a:	4b1d      	ldr	r3, [pc, #116]	@ (80084c0 <USBD_SetConfig+0x150>)
 800844c:	781b      	ldrb	r3, [r3, #0]
 800844e:	461a      	mov	r2, r3
 8008450:	687b      	ldr	r3, [r7, #4]
 8008452:	605a      	str	r2, [r3, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 8008454:	4b1a      	ldr	r3, [pc, #104]	@ (80084c0 <USBD_SetConfig+0x150>)
 8008456:	781b      	ldrb	r3, [r3, #0]
 8008458:	4619      	mov	r1, r3
 800845a:	6878      	ldr	r0, [r7, #4]
 800845c:	f7fe ff99 	bl	8007392 <USBD_SetClassConfig>
 8008460:	4603      	mov	r3, r0
 8008462:	73fb      	strb	r3, [r7, #15]
        if (ret != USBD_OK)
 8008464:	7bfb      	ldrb	r3, [r7, #15]
 8008466:	2b00      	cmp	r3, #0
 8008468:	d00f      	beq.n	800848a <USBD_SetConfig+0x11a>
          USBD_CtlError(pdev, req);
 800846a:	6839      	ldr	r1, [r7, #0]
 800846c:	6878      	ldr	r0, [r7, #4]
 800846e:	f000 f918 	bl	80086a2 <USBD_CtlError>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8008472:	687b      	ldr	r3, [r7, #4]
 8008474:	685b      	ldr	r3, [r3, #4]
 8008476:	b2db      	uxtb	r3, r3
 8008478:	4619      	mov	r1, r3
 800847a:	6878      	ldr	r0, [r7, #4]
 800847c:	f7fe ffa5 	bl	80073ca <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8008480:	687b      	ldr	r3, [r7, #4]
 8008482:	2202      	movs	r2, #2
 8008484:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 8008488:	e014      	b.n	80084b4 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 800848a:	6878      	ldr	r0, [r7, #4]
 800848c:	f000 f9e0 	bl	8008850 <USBD_CtlSendStatus>
      break;
 8008490:	e010      	b.n	80084b4 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 8008492:	6878      	ldr	r0, [r7, #4]
 8008494:	f000 f9dc 	bl	8008850 <USBD_CtlSendStatus>
      break;
 8008498:	e00c      	b.n	80084b4 <USBD_SetConfig+0x144>

    default:
      USBD_CtlError(pdev, req);
 800849a:	6839      	ldr	r1, [r7, #0]
 800849c:	6878      	ldr	r0, [r7, #4]
 800849e:	f000 f900 	bl	80086a2 <USBD_CtlError>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 80084a2:	4b07      	ldr	r3, [pc, #28]	@ (80084c0 <USBD_SetConfig+0x150>)
 80084a4:	781b      	ldrb	r3, [r3, #0]
 80084a6:	4619      	mov	r1, r3
 80084a8:	6878      	ldr	r0, [r7, #4]
 80084aa:	f7fe ff8e 	bl	80073ca <USBD_ClrClassConfig>
      ret = USBD_FAIL;
 80084ae:	2303      	movs	r3, #3
 80084b0:	73fb      	strb	r3, [r7, #15]
      break;
 80084b2:	bf00      	nop
  }

  return ret;
 80084b4:	7bfb      	ldrb	r3, [r7, #15]
}
 80084b6:	4618      	mov	r0, r3
 80084b8:	3710      	adds	r7, #16
 80084ba:	46bd      	mov	sp, r7
 80084bc:	bd80      	pop	{r7, pc}
 80084be:	bf00      	nop
 80084c0:	200026b0 	.word	0x200026b0

080084c4 <USBD_GetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80084c4:	b580      	push	{r7, lr}
 80084c6:	b082      	sub	sp, #8
 80084c8:	af00      	add	r7, sp, #0
 80084ca:	6078      	str	r0, [r7, #4]
 80084cc:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 80084ce:	683b      	ldr	r3, [r7, #0]
 80084d0:	88db      	ldrh	r3, [r3, #6]
 80084d2:	2b01      	cmp	r3, #1
 80084d4:	d004      	beq.n	80084e0 <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
 80084d6:	6839      	ldr	r1, [r7, #0]
 80084d8:	6878      	ldr	r0, [r7, #4]
 80084da:	f000 f8e2 	bl	80086a2 <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
 80084de:	e023      	b.n	8008528 <USBD_GetConfig+0x64>
    switch (pdev->dev_state)
 80084e0:	687b      	ldr	r3, [r7, #4]
 80084e2:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80084e6:	b2db      	uxtb	r3, r3
 80084e8:	2b02      	cmp	r3, #2
 80084ea:	dc02      	bgt.n	80084f2 <USBD_GetConfig+0x2e>
 80084ec:	2b00      	cmp	r3, #0
 80084ee:	dc03      	bgt.n	80084f8 <USBD_GetConfig+0x34>
 80084f0:	e015      	b.n	800851e <USBD_GetConfig+0x5a>
 80084f2:	2b03      	cmp	r3, #3
 80084f4:	d00b      	beq.n	800850e <USBD_GetConfig+0x4a>
 80084f6:	e012      	b.n	800851e <USBD_GetConfig+0x5a>
        pdev->dev_default_config = 0U;
 80084f8:	687b      	ldr	r3, [r7, #4]
 80084fa:	2200      	movs	r2, #0
 80084fc:	609a      	str	r2, [r3, #8]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 80084fe:	687b      	ldr	r3, [r7, #4]
 8008500:	3308      	adds	r3, #8
 8008502:	2201      	movs	r2, #1
 8008504:	4619      	mov	r1, r3
 8008506:	6878      	ldr	r0, [r7, #4]
 8008508:	f000 f948 	bl	800879c <USBD_CtlSendData>
        break;
 800850c:	e00c      	b.n	8008528 <USBD_GetConfig+0x64>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 800850e:	687b      	ldr	r3, [r7, #4]
 8008510:	3304      	adds	r3, #4
 8008512:	2201      	movs	r2, #1
 8008514:	4619      	mov	r1, r3
 8008516:	6878      	ldr	r0, [r7, #4]
 8008518:	f000 f940 	bl	800879c <USBD_CtlSendData>
        break;
 800851c:	e004      	b.n	8008528 <USBD_GetConfig+0x64>
        USBD_CtlError(pdev, req);
 800851e:	6839      	ldr	r1, [r7, #0]
 8008520:	6878      	ldr	r0, [r7, #4]
 8008522:	f000 f8be 	bl	80086a2 <USBD_CtlError>
        break;
 8008526:	bf00      	nop
}
 8008528:	bf00      	nop
 800852a:	3708      	adds	r7, #8
 800852c:	46bd      	mov	sp, r7
 800852e:	bd80      	pop	{r7, pc}

08008530 <USBD_GetStatus>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008530:	b580      	push	{r7, lr}
 8008532:	b082      	sub	sp, #8
 8008534:	af00      	add	r7, sp, #0
 8008536:	6078      	str	r0, [r7, #4]
 8008538:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 800853a:	687b      	ldr	r3, [r7, #4]
 800853c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8008540:	b2db      	uxtb	r3, r3
 8008542:	3b01      	subs	r3, #1
 8008544:	2b02      	cmp	r3, #2
 8008546:	d81e      	bhi.n	8008586 <USBD_GetStatus+0x56>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
 8008548:	683b      	ldr	r3, [r7, #0]
 800854a:	88db      	ldrh	r3, [r3, #6]
 800854c:	2b02      	cmp	r3, #2
 800854e:	d004      	beq.n	800855a <USBD_GetStatus+0x2a>
      {
        USBD_CtlError(pdev, req);
 8008550:	6839      	ldr	r1, [r7, #0]
 8008552:	6878      	ldr	r0, [r7, #4]
 8008554:	f000 f8a5 	bl	80086a2 <USBD_CtlError>
        break;
 8008558:	e01a      	b.n	8008590 <USBD_GetStatus+0x60>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 800855a:	687b      	ldr	r3, [r7, #4]
 800855c:	2201      	movs	r2, #1
 800855e:	60da      	str	r2, [r3, #12]
#else
      pdev->dev_config_status = 0U;
#endif /* USBD_SELF_POWERED */

      if (pdev->dev_remote_wakeup != 0U)
 8008560:	687b      	ldr	r3, [r7, #4]
 8008562:	f8d3 32a4 	ldr.w	r3, [r3, #676]	@ 0x2a4
 8008566:	2b00      	cmp	r3, #0
 8008568:	d005      	beq.n	8008576 <USBD_GetStatus+0x46>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 800856a:	687b      	ldr	r3, [r7, #4]
 800856c:	68db      	ldr	r3, [r3, #12]
 800856e:	f043 0202 	orr.w	r2, r3, #2
 8008572:	687b      	ldr	r3, [r7, #4]
 8008574:	60da      	str	r2, [r3, #12]
      }

      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 8008576:	687b      	ldr	r3, [r7, #4]
 8008578:	330c      	adds	r3, #12
 800857a:	2202      	movs	r2, #2
 800857c:	4619      	mov	r1, r3
 800857e:	6878      	ldr	r0, [r7, #4]
 8008580:	f000 f90c 	bl	800879c <USBD_CtlSendData>
      break;
 8008584:	e004      	b.n	8008590 <USBD_GetStatus+0x60>

    default:
      USBD_CtlError(pdev, req);
 8008586:	6839      	ldr	r1, [r7, #0]
 8008588:	6878      	ldr	r0, [r7, #4]
 800858a:	f000 f88a 	bl	80086a2 <USBD_CtlError>
      break;
 800858e:	bf00      	nop
  }
}
 8008590:	bf00      	nop
 8008592:	3708      	adds	r7, #8
 8008594:	46bd      	mov	sp, r7
 8008596:	bd80      	pop	{r7, pc}

08008598 <USBD_SetFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8008598:	b580      	push	{r7, lr}
 800859a:	b082      	sub	sp, #8
 800859c:	af00      	add	r7, sp, #0
 800859e:	6078      	str	r0, [r7, #4]
 80085a0:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80085a2:	683b      	ldr	r3, [r7, #0]
 80085a4:	885b      	ldrh	r3, [r3, #2]
 80085a6:	2b01      	cmp	r3, #1
 80085a8:	d107      	bne.n	80085ba <USBD_SetFeature+0x22>
  {
    pdev->dev_remote_wakeup = 1U;
 80085aa:	687b      	ldr	r3, [r7, #4]
 80085ac:	2201      	movs	r2, #1
 80085ae:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 80085b2:	6878      	ldr	r0, [r7, #4]
 80085b4:	f000 f94c 	bl	8008850 <USBD_CtlSendStatus>
  }
  else
  {
    USBD_CtlError(pdev, req);
  }
}
 80085b8:	e013      	b.n	80085e2 <USBD_SetFeature+0x4a>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 80085ba:	683b      	ldr	r3, [r7, #0]
 80085bc:	885b      	ldrh	r3, [r3, #2]
 80085be:	2b02      	cmp	r3, #2
 80085c0:	d10b      	bne.n	80085da <USBD_SetFeature+0x42>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
 80085c2:	683b      	ldr	r3, [r7, #0]
 80085c4:	889b      	ldrh	r3, [r3, #4]
 80085c6:	0a1b      	lsrs	r3, r3, #8
 80085c8:	b29b      	uxth	r3, r3
 80085ca:	b2da      	uxtb	r2, r3
 80085cc:	687b      	ldr	r3, [r7, #4]
 80085ce:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 80085d2:	6878      	ldr	r0, [r7, #4]
 80085d4:	f000 f93c 	bl	8008850 <USBD_CtlSendStatus>
}
 80085d8:	e003      	b.n	80085e2 <USBD_SetFeature+0x4a>
    USBD_CtlError(pdev, req);
 80085da:	6839      	ldr	r1, [r7, #0]
 80085dc:	6878      	ldr	r0, [r7, #4]
 80085de:	f000 f860 	bl	80086a2 <USBD_CtlError>
}
 80085e2:	bf00      	nop
 80085e4:	3708      	adds	r7, #8
 80085e6:	46bd      	mov	sp, r7
 80085e8:	bd80      	pop	{r7, pc}

080085ea <USBD_ClrFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80085ea:	b580      	push	{r7, lr}
 80085ec:	b082      	sub	sp, #8
 80085ee:	af00      	add	r7, sp, #0
 80085f0:	6078      	str	r0, [r7, #4]
 80085f2:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 80085f4:	687b      	ldr	r3, [r7, #4]
 80085f6:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80085fa:	b2db      	uxtb	r3, r3
 80085fc:	3b01      	subs	r3, #1
 80085fe:	2b02      	cmp	r3, #2
 8008600:	d80b      	bhi.n	800861a <USBD_ClrFeature+0x30>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8008602:	683b      	ldr	r3, [r7, #0]
 8008604:	885b      	ldrh	r3, [r3, #2]
 8008606:	2b01      	cmp	r3, #1
 8008608:	d10c      	bne.n	8008624 <USBD_ClrFeature+0x3a>
      {
        pdev->dev_remote_wakeup = 0U;
 800860a:	687b      	ldr	r3, [r7, #4]
 800860c:	2200      	movs	r2, #0
 800860e:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 8008612:	6878      	ldr	r0, [r7, #4]
 8008614:	f000 f91c 	bl	8008850 <USBD_CtlSendStatus>
      }
      break;
 8008618:	e004      	b.n	8008624 <USBD_ClrFeature+0x3a>

    default:
      USBD_CtlError(pdev, req);
 800861a:	6839      	ldr	r1, [r7, #0]
 800861c:	6878      	ldr	r0, [r7, #4]
 800861e:	f000 f840 	bl	80086a2 <USBD_CtlError>
      break;
 8008622:	e000      	b.n	8008626 <USBD_ClrFeature+0x3c>
      break;
 8008624:	bf00      	nop
  }
}
 8008626:	bf00      	nop
 8008628:	3708      	adds	r7, #8
 800862a:	46bd      	mov	sp, r7
 800862c:	bd80      	pop	{r7, pc}

0800862e <USBD_ParseSetupRequest>:
  * @param  req: usb request
  * @param  pdata: setup data pointer
  * @retval None
  */
void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 800862e:	b580      	push	{r7, lr}
 8008630:	b084      	sub	sp, #16
 8008632:	af00      	add	r7, sp, #0
 8008634:	6078      	str	r0, [r7, #4]
 8008636:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
 8008638:	683b      	ldr	r3, [r7, #0]
 800863a:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
 800863c:	68fb      	ldr	r3, [r7, #12]
 800863e:	781a      	ldrb	r2, [r3, #0]
 8008640:	687b      	ldr	r3, [r7, #4]
 8008642:	701a      	strb	r2, [r3, #0]

  pbuff++;
 8008644:	68fb      	ldr	r3, [r7, #12]
 8008646:	3301      	adds	r3, #1
 8008648:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
 800864a:	68fb      	ldr	r3, [r7, #12]
 800864c:	781a      	ldrb	r2, [r3, #0]
 800864e:	687b      	ldr	r3, [r7, #4]
 8008650:	705a      	strb	r2, [r3, #1]

  pbuff++;
 8008652:	68fb      	ldr	r3, [r7, #12]
 8008654:	3301      	adds	r3, #1
 8008656:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
 8008658:	68f8      	ldr	r0, [r7, #12]
 800865a:	f7ff fa40 	bl	8007ade <SWAPBYTE>
 800865e:	4603      	mov	r3, r0
 8008660:	461a      	mov	r2, r3
 8008662:	687b      	ldr	r3, [r7, #4]
 8008664:	805a      	strh	r2, [r3, #2]

  pbuff++;
 8008666:	68fb      	ldr	r3, [r7, #12]
 8008668:	3301      	adds	r3, #1
 800866a:	60fb      	str	r3, [r7, #12]
  pbuff++;
 800866c:	68fb      	ldr	r3, [r7, #12]
 800866e:	3301      	adds	r3, #1
 8008670:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
 8008672:	68f8      	ldr	r0, [r7, #12]
 8008674:	f7ff fa33 	bl	8007ade <SWAPBYTE>
 8008678:	4603      	mov	r3, r0
 800867a:	461a      	mov	r2, r3
 800867c:	687b      	ldr	r3, [r7, #4]
 800867e:	809a      	strh	r2, [r3, #4]

  pbuff++;
 8008680:	68fb      	ldr	r3, [r7, #12]
 8008682:	3301      	adds	r3, #1
 8008684:	60fb      	str	r3, [r7, #12]
  pbuff++;
 8008686:	68fb      	ldr	r3, [r7, #12]
 8008688:	3301      	adds	r3, #1
 800868a:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
 800868c:	68f8      	ldr	r0, [r7, #12]
 800868e:	f7ff fa26 	bl	8007ade <SWAPBYTE>
 8008692:	4603      	mov	r3, r0
 8008694:	461a      	mov	r2, r3
 8008696:	687b      	ldr	r3, [r7, #4]
 8008698:	80da      	strh	r2, [r3, #6]
}
 800869a:	bf00      	nop
 800869c:	3710      	adds	r7, #16
 800869e:	46bd      	mov	sp, r7
 80086a0:	bd80      	pop	{r7, pc}

080086a2 <USBD_CtlError>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80086a2:	b580      	push	{r7, lr}
 80086a4:	b082      	sub	sp, #8
 80086a6:	af00      	add	r7, sp, #0
 80086a8:	6078      	str	r0, [r7, #4]
 80086aa:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 80086ac:	2180      	movs	r1, #128	@ 0x80
 80086ae:	6878      	ldr	r0, [r7, #4]
 80086b0:	f01f fca0 	bl	8027ff4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 80086b4:	2100      	movs	r1, #0
 80086b6:	6878      	ldr	r0, [r7, #4]
 80086b8:	f01f fc9c 	bl	8027ff4 <USBD_LL_StallEP>
}
 80086bc:	bf00      	nop
 80086be:	3708      	adds	r7, #8
 80086c0:	46bd      	mov	sp, r7
 80086c2:	bd80      	pop	{r7, pc}

080086c4 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 80086c4:	b580      	push	{r7, lr}
 80086c6:	b086      	sub	sp, #24
 80086c8:	af00      	add	r7, sp, #0
 80086ca:	60f8      	str	r0, [r7, #12]
 80086cc:	60b9      	str	r1, [r7, #8]
 80086ce:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 80086d0:	2300      	movs	r3, #0
 80086d2:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 80086d4:	68fb      	ldr	r3, [r7, #12]
 80086d6:	2b00      	cmp	r3, #0
 80086d8:	d042      	beq.n	8008760 <USBD_GetString+0x9c>
  {
    return;
  }

  pdesc = desc;
 80086da:	68fb      	ldr	r3, [r7, #12]
 80086dc:	613b      	str	r3, [r7, #16]
  *len = MIN(USBD_MAX_STR_DESC_SIZ, ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U);
 80086de:	6938      	ldr	r0, [r7, #16]
 80086e0:	f000 f842 	bl	8008768 <USBD_GetLen>
 80086e4:	4603      	mov	r3, r0
 80086e6:	3301      	adds	r3, #1
 80086e8:	005b      	lsls	r3, r3, #1
 80086ea:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80086ee:	d808      	bhi.n	8008702 <USBD_GetString+0x3e>
 80086f0:	6938      	ldr	r0, [r7, #16]
 80086f2:	f000 f839 	bl	8008768 <USBD_GetLen>
 80086f6:	4603      	mov	r3, r0
 80086f8:	3301      	adds	r3, #1
 80086fa:	b29b      	uxth	r3, r3
 80086fc:	005b      	lsls	r3, r3, #1
 80086fe:	b29a      	uxth	r2, r3
 8008700:	e001      	b.n	8008706 <USBD_GetString+0x42>
 8008702:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8008706:	687b      	ldr	r3, [r7, #4]
 8008708:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
 800870a:	7dfb      	ldrb	r3, [r7, #23]
 800870c:	68ba      	ldr	r2, [r7, #8]
 800870e:	4413      	add	r3, r2
 8008710:	687a      	ldr	r2, [r7, #4]
 8008712:	7812      	ldrb	r2, [r2, #0]
 8008714:	701a      	strb	r2, [r3, #0]
  idx++;
 8008716:	7dfb      	ldrb	r3, [r7, #23]
 8008718:	3301      	adds	r3, #1
 800871a:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
 800871c:	7dfb      	ldrb	r3, [r7, #23]
 800871e:	68ba      	ldr	r2, [r7, #8]
 8008720:	4413      	add	r3, r2
 8008722:	2203      	movs	r2, #3
 8008724:	701a      	strb	r2, [r3, #0]
  idx++;
 8008726:	7dfb      	ldrb	r3, [r7, #23]
 8008728:	3301      	adds	r3, #1
 800872a:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
 800872c:	e013      	b.n	8008756 <USBD_GetString+0x92>
  {
    unicode[idx] = *pdesc;
 800872e:	7dfb      	ldrb	r3, [r7, #23]
 8008730:	68ba      	ldr	r2, [r7, #8]
 8008732:	4413      	add	r3, r2
 8008734:	693a      	ldr	r2, [r7, #16]
 8008736:	7812      	ldrb	r2, [r2, #0]
 8008738:	701a      	strb	r2, [r3, #0]
    pdesc++;
 800873a:	693b      	ldr	r3, [r7, #16]
 800873c:	3301      	adds	r3, #1
 800873e:	613b      	str	r3, [r7, #16]
    idx++;
 8008740:	7dfb      	ldrb	r3, [r7, #23]
 8008742:	3301      	adds	r3, #1
 8008744:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
 8008746:	7dfb      	ldrb	r3, [r7, #23]
 8008748:	68ba      	ldr	r2, [r7, #8]
 800874a:	4413      	add	r3, r2
 800874c:	2200      	movs	r2, #0
 800874e:	701a      	strb	r2, [r3, #0]
    idx++;
 8008750:	7dfb      	ldrb	r3, [r7, #23]
 8008752:	3301      	adds	r3, #1
 8008754:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
 8008756:	693b      	ldr	r3, [r7, #16]
 8008758:	781b      	ldrb	r3, [r3, #0]
 800875a:	2b00      	cmp	r3, #0
 800875c:	d1e7      	bne.n	800872e <USBD_GetString+0x6a>
 800875e:	e000      	b.n	8008762 <USBD_GetString+0x9e>
    return;
 8008760:	bf00      	nop
  }
}
 8008762:	3718      	adds	r7, #24
 8008764:	46bd      	mov	sp, r7
 8008766:	bd80      	pop	{r7, pc}

08008768 <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 8008768:	b480      	push	{r7}
 800876a:	b085      	sub	sp, #20
 800876c:	af00      	add	r7, sp, #0
 800876e:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 8008770:	2300      	movs	r3, #0
 8008772:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 8008774:	687b      	ldr	r3, [r7, #4]
 8008776:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 8008778:	e005      	b.n	8008786 <USBD_GetLen+0x1e>
  {
    len++;
 800877a:	7bfb      	ldrb	r3, [r7, #15]
 800877c:	3301      	adds	r3, #1
 800877e:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 8008780:	68bb      	ldr	r3, [r7, #8]
 8008782:	3301      	adds	r3, #1
 8008784:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 8008786:	68bb      	ldr	r3, [r7, #8]
 8008788:	781b      	ldrb	r3, [r3, #0]
 800878a:	2b00      	cmp	r3, #0
 800878c:	d1f5      	bne.n	800877a <USBD_GetLen+0x12>
  }

  return len;
 800878e:	7bfb      	ldrb	r3, [r7, #15]
}
 8008790:	4618      	mov	r0, r3
 8008792:	3714      	adds	r7, #20
 8008794:	46bd      	mov	sp, r7
 8008796:	f85d 7b04 	ldr.w	r7, [sp], #4
 800879a:	4770      	bx	lr

0800879c <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 800879c:	b580      	push	{r7, lr}
 800879e:	b084      	sub	sp, #16
 80087a0:	af00      	add	r7, sp, #0
 80087a2:	60f8      	str	r0, [r7, #12]
 80087a4:	60b9      	str	r1, [r7, #8]
 80087a6:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 80087a8:	68fb      	ldr	r3, [r7, #12]
 80087aa:	2202      	movs	r2, #2
 80087ac:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_in[0].total_length = len;
 80087b0:	68fb      	ldr	r3, [r7, #12]
 80087b2:	687a      	ldr	r2, [r7, #4]
 80087b4:	619a      	str	r2, [r3, #24]

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 80087b6:	68fb      	ldr	r3, [r7, #12]
 80087b8:	687a      	ldr	r2, [r7, #4]
 80087ba:	61da      	str	r2, [r3, #28]
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 80087bc:	687b      	ldr	r3, [r7, #4]
 80087be:	68ba      	ldr	r2, [r7, #8]
 80087c0:	2100      	movs	r1, #0
 80087c2:	68f8      	ldr	r0, [r7, #12]
 80087c4:	f01f fc9f 	bl	8028106 <USBD_LL_Transmit>

  return USBD_OK;
 80087c8:	2300      	movs	r3, #0
}
 80087ca:	4618      	mov	r0, r3
 80087cc:	3710      	adds	r7, #16
 80087ce:	46bd      	mov	sp, r7
 80087d0:	bd80      	pop	{r7, pc}

080087d2 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 80087d2:	b580      	push	{r7, lr}
 80087d4:	b084      	sub	sp, #16
 80087d6:	af00      	add	r7, sp, #0
 80087d8:	60f8      	str	r0, [r7, #12]
 80087da:	60b9      	str	r1, [r7, #8]
 80087dc:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 80087de:	687b      	ldr	r3, [r7, #4]
 80087e0:	68ba      	ldr	r2, [r7, #8]
 80087e2:	2100      	movs	r1, #0
 80087e4:	68f8      	ldr	r0, [r7, #12]
 80087e6:	f01f fc8e 	bl	8028106 <USBD_LL_Transmit>

  return USBD_OK;
 80087ea:	2300      	movs	r3, #0
}
 80087ec:	4618      	mov	r0, r3
 80087ee:	3710      	adds	r7, #16
 80087f0:	46bd      	mov	sp, r7
 80087f2:	bd80      	pop	{r7, pc}

080087f4 <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 80087f4:	b580      	push	{r7, lr}
 80087f6:	b084      	sub	sp, #16
 80087f8:	af00      	add	r7, sp, #0
 80087fa:	60f8      	str	r0, [r7, #12]
 80087fc:	60b9      	str	r1, [r7, #8]
 80087fe:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8008800:	68fb      	ldr	r3, [r7, #12]
 8008802:	2203      	movs	r2, #3
 8008804:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_out[0].total_length = len;
 8008808:	68fb      	ldr	r3, [r7, #12]
 800880a:	687a      	ldr	r2, [r7, #4]
 800880c:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_out[0].rem_length = 0U;
#else
  pdev->ep_out[0].rem_length = len;
 8008810:	68fb      	ldr	r3, [r7, #12]
 8008812:	687a      	ldr	r2, [r7, #4]
 8008814:	f8c3 215c 	str.w	r2, [r3, #348]	@ 0x15c
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8008818:	687b      	ldr	r3, [r7, #4]
 800881a:	68ba      	ldr	r2, [r7, #8]
 800881c:	2100      	movs	r1, #0
 800881e:	68f8      	ldr	r0, [r7, #12]
 8008820:	f01f fc92 	bl	8028148 <USBD_LL_PrepareReceive>

  return USBD_OK;
 8008824:	2300      	movs	r3, #0
}
 8008826:	4618      	mov	r0, r3
 8008828:	3710      	adds	r7, #16
 800882a:	46bd      	mov	sp, r7
 800882c:	bd80      	pop	{r7, pc}

0800882e <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 800882e:	b580      	push	{r7, lr}
 8008830:	b084      	sub	sp, #16
 8008832:	af00      	add	r7, sp, #0
 8008834:	60f8      	str	r0, [r7, #12]
 8008836:	60b9      	str	r1, [r7, #8]
 8008838:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800883a:	687b      	ldr	r3, [r7, #4]
 800883c:	68ba      	ldr	r2, [r7, #8]
 800883e:	2100      	movs	r1, #0
 8008840:	68f8      	ldr	r0, [r7, #12]
 8008842:	f01f fc81 	bl	8028148 <USBD_LL_PrepareReceive>

  return USBD_OK;
 8008846:	2300      	movs	r3, #0
}
 8008848:	4618      	mov	r0, r3
 800884a:	3710      	adds	r7, #16
 800884c:	46bd      	mov	sp, r7
 800884e:	bd80      	pop	{r7, pc}

08008850 <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 8008850:	b580      	push	{r7, lr}
 8008852:	b082      	sub	sp, #8
 8008854:	af00      	add	r7, sp, #0
 8008856:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8008858:	687b      	ldr	r3, [r7, #4]
 800885a:	2204      	movs	r2, #4
 800885c:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8008860:	2300      	movs	r3, #0
 8008862:	2200      	movs	r2, #0
 8008864:	2100      	movs	r1, #0
 8008866:	6878      	ldr	r0, [r7, #4]
 8008868:	f01f fc4d 	bl	8028106 <USBD_LL_Transmit>

  return USBD_OK;
 800886c:	2300      	movs	r3, #0
}
 800886e:	4618      	mov	r0, r3
 8008870:	3708      	adds	r7, #8
 8008872:	46bd      	mov	sp, r7
 8008874:	bd80      	pop	{r7, pc}

08008876 <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 8008876:	b580      	push	{r7, lr}
 8008878:	b082      	sub	sp, #8
 800887a:	af00      	add	r7, sp, #0
 800887c:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 800887e:	687b      	ldr	r3, [r7, #4]
 8008880:	2205      	movs	r2, #5
 8008882:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8008886:	2300      	movs	r3, #0
 8008888:	2200      	movs	r2, #0
 800888a:	2100      	movs	r1, #0
 800888c:	6878      	ldr	r0, [r7, #4]
 800888e:	f01f fc5b 	bl	8028148 <USBD_LL_PrepareReceive>

  return USBD_OK;
 8008892:	2300      	movs	r3, #0
}
 8008894:	4618      	mov	r0, r3
 8008896:	3708      	adds	r7, #8
 8008898:	46bd      	mov	sp, r7
 800889a:	bd80      	pop	{r7, pc}

0800889c <wolfSSL_Atomic_Int_FetchSub>:
    static WC_INLINE int wolfSSL_Atomic_Int_FetchAdd(int *c, int i) {
        int ret = *c;
        *c += i;
        return ret;
    }
    static WC_INLINE int wolfSSL_Atomic_Int_FetchSub(int *c, int i) {
 800889c:	b480      	push	{r7}
 800889e:	b085      	sub	sp, #20
 80088a0:	af00      	add	r7, sp, #0
 80088a2:	6078      	str	r0, [r7, #4]
 80088a4:	6039      	str	r1, [r7, #0]
        int ret = *c;
 80088a6:	687b      	ldr	r3, [r7, #4]
 80088a8:	681b      	ldr	r3, [r3, #0]
 80088aa:	60fb      	str	r3, [r7, #12]
        *c -= i;
 80088ac:	687b      	ldr	r3, [r7, #4]
 80088ae:	681a      	ldr	r2, [r3, #0]
 80088b0:	683b      	ldr	r3, [r7, #0]
 80088b2:	1ad2      	subs	r2, r2, r3
 80088b4:	687b      	ldr	r3, [r7, #4]
 80088b6:	601a      	str	r2, [r3, #0]
        return ret;
 80088b8:	68fb      	ldr	r3, [r7, #12]
    }
 80088ba:	4618      	mov	r0, r3
 80088bc:	3714      	adds	r7, #20
 80088be:	46bd      	mov	sp, r7
 80088c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088c4:	4770      	bx	lr

080088c6 <ForceZero>:

#ifndef WOLFSSL_NO_FORCE_ZERO
/* This routine fills the first len bytes of the memory area pointed by mem
   with zeros. It ensures compiler optimizations doesn't skip it  */
WC_MISC_STATIC WC_INLINE void ForceZero(void* mem, word32 len)
{
 80088c6:	b480      	push	{r7}
 80088c8:	b085      	sub	sp, #20
 80088ca:	af00      	add	r7, sp, #0
 80088cc:	6078      	str	r0, [r7, #4]
 80088ce:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 80088d0:	687b      	ldr	r3, [r7, #4]
 80088d2:	60fb      	str	r3, [r7, #12]
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
 80088d4:	e004      	b.n	80088e0 <ForceZero+0x1a>
 80088d6:	68fb      	ldr	r3, [r7, #12]
 80088d8:	1c5a      	adds	r2, r3, #1
 80088da:	60fa      	str	r2, [r7, #12]
 80088dc:	2200      	movs	r2, #0
 80088de:	701a      	strb	r2, [r3, #0]
 80088e0:	683b      	ldr	r3, [r7, #0]
 80088e2:	1e5a      	subs	r2, r3, #1
 80088e4:	603a      	str	r2, [r7, #0]
 80088e6:	2b00      	cmp	r3, #0
 80088e8:	d1f5      	bne.n	80088d6 <ForceZero+0x10>
}
 80088ea:	bf00      	nop
 80088ec:	bf00      	nop
 80088ee:	3714      	adds	r7, #20
 80088f0:	46bd      	mov	sp, r7
 80088f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088f6:	4770      	bx	lr

080088f8 <min>:
    #if defined(HAVE_FIPS) && !defined(min) /* so ifdef check passes */
        #define min min
    #endif
    /* returns the smaller of a and b */
    WC_MISC_STATIC WC_INLINE word32 min(word32 a, word32 b)
    {
 80088f8:	b480      	push	{r7}
 80088fa:	b083      	sub	sp, #12
 80088fc:	af00      	add	r7, sp, #0
 80088fe:	6078      	str	r0, [r7, #4]
 8008900:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 8008902:	687a      	ldr	r2, [r7, #4]
 8008904:	683b      	ldr	r3, [r7, #0]
 8008906:	4293      	cmp	r3, r2
 8008908:	bf28      	it	cs
 800890a:	4613      	movcs	r3, r2
    }
 800890c:	4618      	mov	r0, r3
 800890e:	370c      	adds	r7, #12
 8008910:	46bd      	mov	sp, r7
 8008912:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008916:	4770      	bx	lr

08008918 <IsAtLeastTLSv1_3>:

    return 0;
}

int IsAtLeastTLSv1_3(const ProtocolVersion pv)
{
 8008918:	b480      	push	{r7}
 800891a:	b085      	sub	sp, #20
 800891c:	af00      	add	r7, sp, #0
 800891e:	80b8      	strh	r0, [r7, #4]
    int ret;
    ret = (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR);
 8008920:	793b      	ldrb	r3, [r7, #4]
 8008922:	2b03      	cmp	r3, #3
 8008924:	d104      	bne.n	8008930 <IsAtLeastTLSv1_3+0x18>
 8008926:	797b      	ldrb	r3, [r7, #5]
 8008928:	2b03      	cmp	r3, #3
 800892a:	d901      	bls.n	8008930 <IsAtLeastTLSv1_3+0x18>
 800892c:	2301      	movs	r3, #1
 800892e:	e000      	b.n	8008932 <IsAtLeastTLSv1_3+0x1a>
 8008930:	2300      	movs	r3, #0
 8008932:	60fb      	str	r3, [r7, #12]
#ifdef WOLFSSL_DTLS13
    if (ret == 0 && pv.major == DTLS_MAJOR && pv.minor <= DTLSv1_3_MINOR)
        return 1;
#endif

    return ret;
 8008934:	68fb      	ldr	r3, [r7, #12]
}
 8008936:	4618      	mov	r0, r3
 8008938:	3714      	adds	r7, #20
 800893a:	46bd      	mov	sp, r7
 800893c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008940:	4770      	bx	lr

08008942 <InitSSL_Method>:
}
#endif /* WOLFSSL_SESSION_EXPORT */


void InitSSL_Method(WOLFSSL_METHOD* method, ProtocolVersion pv)
{
 8008942:	b480      	push	{r7}
 8008944:	b083      	sub	sp, #12
 8008946:	af00      	add	r7, sp, #0
 8008948:	6078      	str	r0, [r7, #4]
 800894a:	8039      	strh	r1, [r7, #0]
    method->version    = pv;
 800894c:	687b      	ldr	r3, [r7, #4]
 800894e:	461a      	mov	r2, r3
 8008950:	463b      	mov	r3, r7
 8008952:	881b      	ldrh	r3, [r3, #0]
 8008954:	8013      	strh	r3, [r2, #0]
    method->side       = WOLFSSL_CLIENT_END;
 8008956:	687b      	ldr	r3, [r7, #4]
 8008958:	2201      	movs	r2, #1
 800895a:	709a      	strb	r2, [r3, #2]
    method->downgrade  = 0;
 800895c:	687b      	ldr	r3, [r7, #4]
 800895e:	2200      	movs	r2, #0
 8008960:	70da      	strb	r2, [r3, #3]
}
 8008962:	bf00      	nop
 8008964:	370c      	adds	r7, #12
 8008966:	46bd      	mov	sp, r7
 8008968:	f85d 7b04 	ldr.w	r7, [sp], #4
 800896c:	4770      	bx	lr

0800896e <InitSSL_Ctx>:
}
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

/* Initialize SSL context, return 0 on success */
int InitSSL_Ctx(WOLFSSL_CTX* ctx, WOLFSSL_METHOD* method, void* heap)
{
 800896e:	b580      	push	{r7, lr}
 8008970:	b086      	sub	sp, #24
 8008972:	af00      	add	r7, sp, #0
 8008974:	60f8      	str	r0, [r7, #12]
 8008976:	60b9      	str	r1, [r7, #8]
 8008978:	607a      	str	r2, [r7, #4]
    int ret = 0;
 800897a:	2300      	movs	r3, #0
 800897c:	617b      	str	r3, [r7, #20]

    XMEMSET(ctx, 0, sizeof(WOLFSSL_CTX));
 800897e:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 8008982:	2100      	movs	r1, #0
 8008984:	68f8      	ldr	r0, [r7, #12]
 8008986:	f01f fda3 	bl	80284d0 <memset>

    ctx->method   = method;
 800898a:	68fb      	ldr	r3, [r7, #12]
 800898c:	68ba      	ldr	r2, [r7, #8]
 800898e:	601a      	str	r2, [r3, #0]
    if (heap == NULL) {
 8008990:	687b      	ldr	r3, [r7, #4]
 8008992:	2b00      	cmp	r3, #0
 8008994:	d103      	bne.n	800899e <InitSSL_Ctx+0x30>
        ctx->heap = ctx;  /* defaults to self */
 8008996:	68fb      	ldr	r3, [r7, #12]
 8008998:	68fa      	ldr	r2, [r7, #12]
 800899a:	659a      	str	r2, [r3, #88]	@ 0x58
 800899c:	e002      	b.n	80089a4 <InitSSL_Ctx+0x36>
    }
    else {
        ctx->heap = heap; /* wolfSSL_CTX_load_static_memory sets */
 800899e:	68fb      	ldr	r3, [r7, #12]
 80089a0:	687a      	ldr	r2, [r7, #4]
 80089a2:	659a      	str	r2, [r3, #88]	@ 0x58
    }
    ctx->timeout  = WOLFSSL_SESSION_TIMEOUT;
 80089a4:	68fb      	ldr	r3, [r7, #12]
 80089a6:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
 80089aa:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4
    }
    else
#endif /* WOLFSSL_DTLS */
    {
        /* current default: TLSv1_MINOR */
        ctx->minDowngrade = WOLFSSL_MIN_DOWNGRADE;
 80089ae:	68fb      	ldr	r3, [r7, #12]
 80089b0:	2203      	movs	r2, #3
 80089b2:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
    }

    wolfSSL_RefWithMutexInit(&ctx->ref, &ret);
 80089b6:	68fb      	ldr	r3, [r7, #12]
 80089b8:	2201      	movs	r2, #1
 80089ba:	609a      	str	r2, [r3, #8]
 80089bc:	2300      	movs	r3, #0
 80089be:	617b      	str	r3, [r7, #20]
#else
    (void)ret;
#endif

#ifndef NO_CERTS
    ctx->privateKeyDevId = INVALID_DEVID;
 80089c0:	68fb      	ldr	r3, [r7, #12]
 80089c2:	f06f 0201 	mvn.w	r2, #1
 80089c6:	64da      	str	r2, [r3, #76]	@ 0x4c
    ctx->altPrivateKeyDevId = INVALID_DEVID;
#endif
#endif

#ifndef NO_DH
    ctx->minDhKeySz  = MIN_DHKEY_SZ;
 80089c8:	68fb      	ldr	r3, [r7, #12]
 80089ca:	2280      	movs	r2, #128	@ 0x80
 80089cc:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
    ctx->maxDhKeySz  = MAX_DHKEY_SZ;
 80089d0:	68fb      	ldr	r3, [r7, #12]
 80089d2:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80089d6:	f8a3 2064 	strh.w	r2, [r3, #100]	@ 0x64
#endif
#ifndef NO_RSA
    ctx->minRsaKeySz = MIN_RSAKEY_SZ;
 80089da:	68fb      	ldr	r3, [r7, #12]
 80089dc:	2280      	movs	r2, #128	@ 0x80
 80089de:	f8a3 2066 	strh.w	r2, [r3, #102]	@ 0x66
#endif

#ifdef HAVE_ECC
    ctx->minEccKeySz  = MIN_ECCKEY_SZ;
 80089e2:	68fb      	ldr	r3, [r7, #12]
 80089e4:	221c      	movs	r2, #28
 80089e6:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
    ctx->eccTempKeySz = ECDHE_SIZE;
 80089ea:	68fb      	ldr	r3, [r7, #12]
 80089ec:	2220      	movs	r2, #32
 80089ee:	f8a3 20cc 	strh.w	r2, [r3, #204]	@ 0xcc
    ctx->minFalconKeySz = MIN_FALCONKEY_SZ;
#endif /* HAVE_FALCON */
#ifdef HAVE_DILITHIUM
    ctx->minDilithiumKeySz = MIN_DILITHIUMKEY_SZ;
#endif /* HAVE_DILITHIUM */
    ctx->verifyDepth = MAX_CHAIN_DEPTH;
 80089f2:	68fb      	ldr	r3, [r7, #12]
 80089f4:	2209      	movs	r2, #9
 80089f6:	f883 205c 	strb.w	r2, [r3, #92]	@ 0x5c
#ifdef OPENSSL_EXTRA
    ctx->cbioFlag = WOLFSSL_CBIO_NONE;
 80089fa:	68fb      	ldr	r3, [r7, #12]
 80089fc:	2200      	movs	r2, #0
 80089fe:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0
    if (method->side == WOLFSSL_CLIENT_END)
        ctx->haveDilithiumSig = 1;     /* always on client side */
                                       /* server can turn on by loading key */
#endif /* HAVE_DILITHIUM */
#ifdef HAVE_ECC
    if (method->side == WOLFSSL_CLIENT_END) {
 8008a02:	68bb      	ldr	r3, [r7, #8]
 8008a04:	789b      	ldrb	r3, [r3, #2]
 8008a06:	2b01      	cmp	r3, #1
 8008a08:	d114      	bne.n	8008a34 <InitSSL_Ctx+0xc6>
        ctx->haveECDSAsig  = 1;        /* always on client side */
 8008a0a:	68fa      	ldr	r2, [r7, #12]
 8008a0c:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 8008a10:	f043 0320 	orr.w	r3, r3, #32
 8008a14:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
        ctx->haveECC  = 1;             /* server turns on with ECC key cert */
 8008a18:	68fa      	ldr	r2, [r7, #12]
 8008a1a:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 8008a1e:	f043 0308 	orr.w	r3, r3, #8
 8008a22:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
        ctx->haveStaticECC = 1;        /* server can turn on by loading key */
 8008a26:	68fa      	ldr	r2, [r7, #12]
 8008a28:	f892 305f 	ldrb.w	r3, [r2, #95]	@ 0x5f
 8008a2c:	f043 0301 	orr.w	r3, r3, #1
 8008a30:	f882 305f 	strb.w	r3, [r2, #95]	@ 0x5f
    /* default to try using CAAM when built */
    ctx->devId = WOLFSSL_CAAM_DEVID;
#elif defined(HAVE_ARIA) && defined(WOLF_CRYPTO_CB)
    ctx->devId = WOLFSSL_ARIA_DEVID;
#else
    ctx->devId = INVALID_DEVID;
 8008a34:	68fb      	ldr	r3, [r7, #12]
 8008a36:	f06f 0201 	mvn.w	r2, #1
 8008a3a:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
        ctx->dtlsMtuSz = MAX_MTU;
    #endif
#endif

#ifndef NO_CERTS
    ctx->cm = wolfSSL_CertManagerNew_ex(heap);
 8008a3e:	6878      	ldr	r0, [r7, #4]
 8008a40:	f002 fd88 	bl	800b554 <wolfSSL_CertManagerNew_ex>
 8008a44:	4602      	mov	r2, r0
 8008a46:	68fb      	ldr	r3, [r7, #12]
 8008a48:	651a      	str	r2, [r3, #80]	@ 0x50
    if (ctx->cm == NULL) {
 8008a4a:	68fb      	ldr	r3, [r7, #12]
 8008a4c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008a4e:	2b00      	cmp	r3, #0
 8008a50:	d102      	bne.n	8008a58 <InitSSL_Ctx+0xea>
        WOLFSSL_MSG("Bad Cert Manager New");
        WOLFSSL_ERROR_VERBOSE(BAD_CERT_MANAGER_ERROR);
        return BAD_CERT_MANAGER_ERROR;
 8008a52:	f46f 73b3 	mvn.w	r3, #358	@ 0x166
 8008a56:	e076      	b.n	8008b46 <InitSSL_Ctx+0x1d8>
    }
    #ifdef OPENSSL_EXTRA
    /* setup WOLFSSL_X509_STORE */
    ctx->x509_store.cm = ctx->cm;
 8008a58:	68fb      	ldr	r3, [r7, #12]
 8008a5a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8008a5c:	68fb      	ldr	r3, [r7, #12]
 8008a5e:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
    /* set pointer back to x509 store */
    ctx->cm->x509_store_p = &ctx->x509_store;
 8008a62:	68fb      	ldr	r3, [r7, #12]
 8008a64:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008a66:	68fa      	ldr	r2, [r7, #12]
 8008a68:	32f4      	adds	r2, #244	@ 0xf4
 8008a6a:	669a      	str	r2, [r3, #104]	@ 0x68

    /* WOLFSSL_X509_VERIFY_PARAM */
    if ((ctx->param = (WOLFSSL_X509_VERIFY_PARAM*)XMALLOC(
 8008a6c:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 8008a70:	f016 f810 	bl	801ea94 <wolfSSL_Malloc>
 8008a74:	4602      	mov	r2, r0
 8008a76:	68fb      	ldr	r3, [r7, #12]
 8008a78:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
 8008a7c:	68fb      	ldr	r3, [r7, #12]
 8008a7e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8008a82:	2b00      	cmp	r3, #0
 8008a84:	d102      	bne.n	8008a8c <InitSSL_Ctx+0x11e>
                           sizeof(WOLFSSL_X509_VERIFY_PARAM),
                           heap, DYNAMIC_TYPE_OPENSSL)) == NULL) {
        WOLFSSL_MSG("ctx->param memory error");
        return MEMORY_E;
 8008a86:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8008a8a:	e05c      	b.n	8008b46 <InitSSL_Ctx+0x1d8>
    }
    XMEMSET(ctx->param, 0, sizeof(WOLFSSL_X509_VERIFY_PARAM));
 8008a8c:	68fb      	ldr	r3, [r7, #12]
 8008a8e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8008a92:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 8008a96:	2100      	movs	r1, #0
 8008a98:	4618      	mov	r0, r3
 8008a9a:	f01f fd19 	bl	80284d0 <memset>

    /* WOLFSSL_X509_LOOKUP */
    if ((ctx->x509_store.lookup.dirs = (WOLFSSL_BY_DIR*)XMALLOC(
 8008a9e:	2008      	movs	r0, #8
 8008aa0:	f015 fff8 	bl	801ea94 <wolfSSL_Malloc>
 8008aa4:	4602      	mov	r2, r0
 8008aa6:	68fb      	ldr	r3, [r7, #12]
 8008aa8:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
 8008aac:	68fb      	ldr	r3, [r7, #12]
 8008aae:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008ab2:	2b00      	cmp	r3, #0
 8008ab4:	d102      	bne.n	8008abc <InitSSL_Ctx+0x14e>
                           sizeof(WOLFSSL_BY_DIR),
                           heap, DYNAMIC_TYPE_OPENSSL)) == NULL) {
        WOLFSSL_MSG("ctx->x509_store.lookup.dirs: allocation error");
        return MEMORY_E;
 8008ab6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8008aba:	e044      	b.n	8008b46 <InitSSL_Ctx+0x1d8>
    }
    XMEMSET(ctx->x509_store.lookup.dirs, 0, sizeof(WOLFSSL_BY_DIR));
 8008abc:	68fb      	ldr	r3, [r7, #12]
 8008abe:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008ac2:	2208      	movs	r2, #8
 8008ac4:	2100      	movs	r1, #0
 8008ac6:	4618      	mov	r0, r3
 8008ac8:	f01f fd02 	bl	80284d0 <memset>

    /* param */
    if ((ctx->x509_store.param = (WOLFSSL_X509_VERIFY_PARAM*)XMALLOC(
 8008acc:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 8008ad0:	f015 ffe0 	bl	801ea94 <wolfSSL_Malloc>
 8008ad4:	4602      	mov	r2, r0
 8008ad6:	68fb      	ldr	r3, [r7, #12]
 8008ad8:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
 8008adc:	68fb      	ldr	r3, [r7, #12]
 8008ade:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008ae2:	2b00      	cmp	r3, #0
 8008ae4:	d102      	bne.n	8008aec <InitSSL_Ctx+0x17e>
                           sizeof(WOLFSSL_X509_VERIFY_PARAM),
                           heap, DYNAMIC_TYPE_OPENSSL)) == NULL) {
        WOLFSSL_MSG("ctx->x509_store.param: allocation error");
        return MEMORY_E;
 8008ae6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8008aea:	e02c      	b.n	8008b46 <InitSSL_Ctx+0x1d8>
    }
    XMEMSET(ctx->x509_store.param, 0, sizeof(WOLFSSL_X509_VERIFY_PARAM));
 8008aec:	68fb      	ldr	r3, [r7, #12]
 8008aee:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008af2:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 8008af6:	2100      	movs	r1, #0
 8008af8:	4618      	mov	r0, r3
 8008afa:	f01f fce9 	bl	80284d0 <memset>

    if (wc_InitMutex(&ctx->x509_store.lookup.dirs->lock) != 0) {
 8008afe:	68fb      	ldr	r3, [r7, #12]
 8008b00:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008b04:	3304      	adds	r3, #4
 8008b06:	4618      	mov	r0, r3
 8008b08:	f01e fc3e 	bl	8027388 <wc_InitMutex>
 8008b0c:	4603      	mov	r3, r0
 8008b0e:	2b00      	cmp	r3, #0
 8008b10:	d002      	beq.n	8008b18 <InitSSL_Ctx+0x1aa>
        WOLFSSL_MSG("Bad mutex init");
        WOLFSSL_ERROR_VERBOSE(BAD_MUTEX_E);
        return BAD_MUTEX_E;
 8008b12:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 8008b16:	e016      	b.n	8008b46 <InitSSL_Ctx+0x1d8>
    }
    #endif
#endif

#if defined(HAVE_EXTENDED_MASTER) && !defined(NO_WOLFSSL_CLIENT)
    if (method->side == WOLFSSL_CLIENT_END) {
 8008b18:	68bb      	ldr	r3, [r7, #8]
 8008b1a:	789b      	ldrb	r3, [r3, #2]
 8008b1c:	2b01      	cmp	r3, #1
 8008b1e:	d10e      	bne.n	8008b3e <InitSSL_Ctx+0x1d0>
        if ((method->version.major == SSLv3_MAJOR) &&
 8008b20:	68bb      	ldr	r3, [r7, #8]
 8008b22:	781b      	ldrb	r3, [r3, #0]
 8008b24:	2b03      	cmp	r3, #3
 8008b26:	d10a      	bne.n	8008b3e <InitSSL_Ctx+0x1d0>
             (method->version.minor >= TLSv1_MINOR)) {
 8008b28:	68bb      	ldr	r3, [r7, #8]
 8008b2a:	785b      	ldrb	r3, [r3, #1]
        if ((method->version.major == SSLv3_MAJOR) &&
 8008b2c:	2b00      	cmp	r3, #0
 8008b2e:	d006      	beq.n	8008b3e <InitSSL_Ctx+0x1d0>

            ctx->haveEMS = 1;
 8008b30:	68fa      	ldr	r2, [r7, #12]
 8008b32:	f892 3061 	ldrb.w	r3, [r2, #97]	@ 0x61
 8008b36:	f043 0301 	orr.w	r3, r3, #1
 8008b3a:	f882 3061 	strb.w	r3, [r2, #97]	@ 0x61
     * Qt doesn't allow to use a cipher if it is not in the supported list.
     * Therefore, we need to enable PSK cipher at the beginning.
     */
    ctx->havePSK = 1;
#endif
    ctx->heap = heap; /* wolfSSL_CTX_load_static_memory sets */
 8008b3e:	68fb      	ldr	r3, [r7, #12]
 8008b40:	687a      	ldr	r2, [r7, #4]
 8008b42:	659a      	str	r2, [r3, #88]	@ 0x58
        WOLFSSL_MSG_EX("crypto_policy_init_ctx returned %d", ret);
        return ret;
    }
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

    return ret;
 8008b44:	697b      	ldr	r3, [r7, #20]
}
 8008b46:	4618      	mov	r0, r3
 8008b48:	3718      	adds	r7, #24
 8008b4a:	46bd      	mov	sp, r7
 8008b4c:	bd80      	pop	{r7, pc}

08008b4e <SSL_CtxResourceFree>:
 * logic. A WOLFSSL_CTX can be assigned a static memory heap hint using
 * wolfSSL_CTX_load_static_memory after CTX creation, which means variables
 * allocated in InitSSL_Ctx were allocated from heap and should be free'd with
 * a NULL heap hint. */
void SSL_CtxResourceFree(WOLFSSL_CTX* ctx)
{
 8008b4e:	b580      	push	{r7, lr}
 8008b50:	b08c      	sub	sp, #48	@ 0x30
 8008b52:	af00      	add	r7, sp, #0
 8008b54:	6078      	str	r0, [r7, #4]
#if defined(HAVE_CERTIFICATE_STATUS_REQUEST_V2) && \
                     defined(HAVE_TLS_EXTENSIONS) && !defined(NO_WOLFSSL_SERVER)
    int i;
#endif
    void* heapAtCTXInit = ctx->heap;
 8008b56:	687b      	ldr	r3, [r7, #4]
 8008b58:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008b5a:	62fb      	str	r3, [r7, #44]	@ 0x2c
#ifdef HAVE_WOLF_EVENT
    wolfEventQueue_Free(&ctx->event_queue);
#endif /* HAVE_WOLF_EVENT */

#ifndef NO_TLS /* its a static global see ssl.c "gNoTlsMethod" */
    XFREE(ctx->method, heapAtCTXInit, DYNAMIC_TYPE_METHOD);
 8008b5c:	687b      	ldr	r3, [r7, #4]
 8008b5e:	681b      	ldr	r3, [r3, #0]
 8008b60:	62bb      	str	r3, [r7, #40]	@ 0x28
 8008b62:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8008b64:	2b00      	cmp	r3, #0
 8008b66:	d002      	beq.n	8008b6e <SSL_CtxResourceFree+0x20>
 8008b68:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8008b6a:	f015 ffaf 	bl	801eacc <wolfSSL_Free>
#endif
    ctx->method = NULL;
 8008b6e:	687b      	ldr	r3, [r7, #4]
 8008b70:	2200      	movs	r2, #0
 8008b72:	601a      	str	r2, [r3, #0]

    XFREE(ctx->suites, ctx->heap, DYNAMIC_TYPE_SUITES);
 8008b74:	687b      	ldr	r3, [r7, #4]
 8008b76:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008b78:	627b      	str	r3, [r7, #36]	@ 0x24
 8008b7a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008b7c:	2b00      	cmp	r3, #0
 8008b7e:	d002      	beq.n	8008b86 <SSL_CtxResourceFree+0x38>
 8008b80:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8008b82:	f015 ffa3 	bl	801eacc <wolfSSL_Free>
    ctx->suites = NULL;
 8008b86:	687b      	ldr	r3, [r7, #4]
 8008b88:	2200      	movs	r2, #0
 8008b8a:	655a      	str	r2, [r3, #84]	@ 0x54

#ifndef NO_DH
    XFREE(ctx->serverDH_G.buffer, ctx->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8008b8c:	687b      	ldr	r3, [r7, #4]
 8008b8e:	699b      	ldr	r3, [r3, #24]
 8008b90:	623b      	str	r3, [r7, #32]
 8008b92:	6a3b      	ldr	r3, [r7, #32]
 8008b94:	2b00      	cmp	r3, #0
 8008b96:	d002      	beq.n	8008b9e <SSL_CtxResourceFree+0x50>
 8008b98:	6a38      	ldr	r0, [r7, #32]
 8008b9a:	f015 ff97 	bl	801eacc <wolfSSL_Free>
    ctx->serverDH_G.buffer = NULL;
 8008b9e:	687b      	ldr	r3, [r7, #4]
 8008ba0:	2200      	movs	r2, #0
 8008ba2:	619a      	str	r2, [r3, #24]
    XFREE(ctx->serverDH_P.buffer, ctx->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8008ba4:	687b      	ldr	r3, [r7, #4]
 8008ba6:	691b      	ldr	r3, [r3, #16]
 8008ba8:	61fb      	str	r3, [r7, #28]
 8008baa:	69fb      	ldr	r3, [r7, #28]
 8008bac:	2b00      	cmp	r3, #0
 8008bae:	d002      	beq.n	8008bb6 <SSL_CtxResourceFree+0x68>
 8008bb0:	69f8      	ldr	r0, [r7, #28]
 8008bb2:	f015 ff8b 	bl	801eacc <wolfSSL_Free>
    ctx->serverDH_P.buffer = NULL;
 8008bb6:	687b      	ldr	r3, [r7, #4]
 8008bb8:	2200      	movs	r2, #0
 8008bba:	611a      	str	r2, [r3, #16]
#endif /* !NO_DH */

#ifdef SINGLE_THREADED
    if (ctx->rng) {
 8008bbc:	687b      	ldr	r3, [r7, #4]
 8008bbe:	685b      	ldr	r3, [r3, #4]
 8008bc0:	2b00      	cmp	r3, #0
 8008bc2:	d010      	beq.n	8008be6 <SSL_CtxResourceFree+0x98>
        wc_FreeRng(ctx->rng);
 8008bc4:	687b      	ldr	r3, [r7, #4]
 8008bc6:	685b      	ldr	r3, [r3, #4]
 8008bc8:	4618      	mov	r0, r3
 8008bca:	f016 fd8b 	bl	801f6e4 <wc_FreeRng>
        XFREE(ctx->rng, ctx->heap, DYNAMIC_TYPE_RNG);
 8008bce:	687b      	ldr	r3, [r7, #4]
 8008bd0:	685b      	ldr	r3, [r3, #4]
 8008bd2:	61bb      	str	r3, [r7, #24]
 8008bd4:	69bb      	ldr	r3, [r7, #24]
 8008bd6:	2b00      	cmp	r3, #0
 8008bd8:	d002      	beq.n	8008be0 <SSL_CtxResourceFree+0x92>
 8008bda:	69b8      	ldr	r0, [r7, #24]
 8008bdc:	f015 ff76 	bl	801eacc <wolfSSL_Free>
        ctx->rng = NULL;
 8008be0:	687b      	ldr	r3, [r7, #4]
 8008be2:	2200      	movs	r2, #0
 8008be4:	605a      	str	r2, [r3, #4]
    }
#endif /* SINGLE_THREADED */

#ifndef NO_CERTS
    if (ctx->privateKey != NULL && ctx->privateKey->buffer != NULL) {
 8008be6:	687b      	ldr	r3, [r7, #4]
 8008be8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008bea:	2b00      	cmp	r3, #0
 8008bec:	d00e      	beq.n	8008c0c <SSL_CtxResourceFree+0xbe>
 8008bee:	687b      	ldr	r3, [r7, #4]
 8008bf0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008bf2:	681b      	ldr	r3, [r3, #0]
 8008bf4:	2b00      	cmp	r3, #0
 8008bf6:	d009      	beq.n	8008c0c <SSL_CtxResourceFree+0xbe>
        ForceZero(ctx->privateKey->buffer, ctx->privateKey->length);
 8008bf8:	687b      	ldr	r3, [r7, #4]
 8008bfa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008bfc:	681a      	ldr	r2, [r3, #0]
 8008bfe:	687b      	ldr	r3, [r7, #4]
 8008c00:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8008c02:	689b      	ldr	r3, [r3, #8]
 8008c04:	4619      	mov	r1, r3
 8008c06:	4610      	mov	r0, r2
 8008c08:	f7ff fe5d 	bl	80088c6 <ForceZero>
    }
    FreeDer(&ctx->privateKey);
 8008c0c:	687b      	ldr	r3, [r7, #4]
 8008c0e:	3340      	adds	r3, #64	@ 0x40
 8008c10:	4618      	mov	r0, r3
 8008c12:	f010 f9b9 	bl	8018f88 <FreeDer>
#endif
#endif /* WOLFSSL_DUAL_ALG_CERTS */
#ifdef OPENSSL_ALL
    wolfSSL_EVP_PKEY_free(ctx->privateKeyPKey);
#endif
    FreeDer(&ctx->certificate);
 8008c16:	687b      	ldr	r3, [r7, #4]
 8008c18:	3320      	adds	r3, #32
 8008c1a:	4618      	mov	r0, r3
 8008c1c:	f010 f9b4 	bl	8018f88 <FreeDer>
        if (ctx->ourCert && ctx->ownOurCert) {
            wolfSSL_X509_free(ctx->ourCert);
            ctx->ourCert = NULL;
        }
    #endif /* KEEP_OUR_CERT */
    FreeDer(&ctx->certChain);
 8008c20:	687b      	ldr	r3, [r7, #4]
 8008c22:	3324      	adds	r3, #36	@ 0x24
 8008c24:	4618      	mov	r0, r3
 8008c26:	f010 f9af 	bl	8018f88 <FreeDer>
    wolfSSL_CertManagerFree(ctx->cm);
 8008c2a:	687b      	ldr	r3, [r7, #4]
 8008c2c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008c2e:	4618      	mov	r0, r3
 8008c30:	f002 fcd7 	bl	800b5e2 <wolfSSL_CertManagerFree>
    ctx->cm = NULL;
 8008c34:	687b      	ldr	r3, [r7, #4]
 8008c36:	2200      	movs	r2, #0
 8008c38:	651a      	str	r2, [r3, #80]	@ 0x50
            ctx->x509_store.objs = NULL;
        }
    #endif
    #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \
        defined(WOLFSSL_WPAS_SMALL)
        wolfSSL_X509_STORE_free(ctx->x509_store_pt);
 8008c3a:	687b      	ldr	r3, [r7, #4]
 8008c3c:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 8008c40:	4618      	mov	r0, r3
 8008c42:	f006 fa3c 	bl	800f0be <wolfSSL_X509_STORE_free>
    #endif
    #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA) || defined(HAVE_LIGHTY)
        wolfSSL_sk_X509_NAME_pop_free(ctx->client_ca_names, NULL);
 8008c46:	687b      	ldr	r3, [r7, #4]
 8008c48:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8008c4a:	2100      	movs	r1, #0
 8008c4c:	4618      	mov	r0, r3
 8008c4e:	f005 ff97 	bl	800eb80 <wolfSSL_sk_X509_NAME_pop_free>
        ctx->client_ca_names = NULL;
 8008c52:	687b      	ldr	r3, [r7, #4]
 8008c54:	2200      	movs	r2, #0
 8008c56:	629a      	str	r2, [r3, #40]	@ 0x28
    #endif
    #ifdef OPENSSL_EXTRA
        if (ctx->x509Chain) {
 8008c58:	687b      	ldr	r3, [r7, #4]
 8008c5a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008c5c:	2b00      	cmp	r3, #0
 8008c5e:	d008      	beq.n	8008c72 <SSL_CtxResourceFree+0x124>
            wolfSSL_sk_X509_pop_free(ctx->x509Chain, NULL);
 8008c60:	687b      	ldr	r3, [r7, #4]
 8008c62:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008c64:	2100      	movs	r1, #0
 8008c66:	4618      	mov	r0, r3
 8008c68:	f005 fb7e 	bl	800e368 <wolfSSL_sk_X509_pop_free>
            ctx->x509Chain = NULL;
 8008c6c:	687b      	ldr	r3, [r7, #4]
 8008c6e:	2200      	movs	r2, #0
 8008c70:	62da      	str	r2, [r3, #44]	@ 0x2c
    #endif
#endif /* !NO_CERTS */

#ifdef HAVE_TLS_EXTENSIONS
#if !defined(NO_TLS)
    TLSX_FreeAll(ctx->extensions, ctx->heap);
 8008c72:	687b      	ldr	r3, [r7, #4]
 8008c74:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
 8008c78:	687b      	ldr	r3, [r7, #4]
 8008c7a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008c7c:	4619      	mov	r1, r3
 8008c7e:	4610      	mov	r0, r2
 8008c80:	f006 fbcc 	bl	800f41c <TLSX_FreeAll>
#endif /* HAVE_CERTIFICATE_STATUS_REQUEST_V2 */
#endif /* !NO_WOLFSSL_SERVER */

#endif /* HAVE_TLS_EXTENSIONS */
#ifdef OPENSSL_EXTRA
    if (ctx->alpn_cli_protos) {
 8008c84:	687b      	ldr	r3, [r7, #4]
 8008c86:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008c8a:	2b00      	cmp	r3, #0
 8008c8c:	d00d      	beq.n	8008caa <SSL_CtxResourceFree+0x15c>
        XFREE((void*)ctx->alpn_cli_protos, ctx->heap, DYNAMIC_TYPE_OPENSSL);
 8008c8e:	687b      	ldr	r3, [r7, #4]
 8008c90:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008c94:	617b      	str	r3, [r7, #20]
 8008c96:	697b      	ldr	r3, [r7, #20]
 8008c98:	2b00      	cmp	r3, #0
 8008c9a:	d002      	beq.n	8008ca2 <SSL_CtxResourceFree+0x154>
 8008c9c:	6978      	ldr	r0, [r7, #20]
 8008c9e:	f015 ff15 	bl	801eacc <wolfSSL_Free>
        ctx->alpn_cli_protos = NULL;
 8008ca2:	687b      	ldr	r3, [r7, #4]
 8008ca4:	2200      	movs	r2, #0
 8008ca6:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
    }
    XFREE(ctx->param, heapAtCTXInit, DYNAMIC_TYPE_OPENSSL);
 8008caa:	687b      	ldr	r3, [r7, #4]
 8008cac:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8008cb0:	613b      	str	r3, [r7, #16]
 8008cb2:	693b      	ldr	r3, [r7, #16]
 8008cb4:	2b00      	cmp	r3, #0
 8008cb6:	d002      	beq.n	8008cbe <SSL_CtxResourceFree+0x170>
 8008cb8:	6938      	ldr	r0, [r7, #16]
 8008cba:	f015 ff07 	bl	801eacc <wolfSSL_Free>
    ctx->param = NULL;
 8008cbe:	687b      	ldr	r3, [r7, #4]
 8008cc0:	2200      	movs	r2, #0
 8008cc2:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8

    if (ctx->x509_store.param) {
 8008cc6:	687b      	ldr	r3, [r7, #4]
 8008cc8:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008ccc:	2b00      	cmp	r3, #0
 8008cce:	d00d      	beq.n	8008cec <SSL_CtxResourceFree+0x19e>
        XFREE(ctx->x509_store.param, heapAtCTXInit, DYNAMIC_TYPE_OPENSSL);
 8008cd0:	687b      	ldr	r3, [r7, #4]
 8008cd2:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
 8008cd6:	60fb      	str	r3, [r7, #12]
 8008cd8:	68fb      	ldr	r3, [r7, #12]
 8008cda:	2b00      	cmp	r3, #0
 8008cdc:	d002      	beq.n	8008ce4 <SSL_CtxResourceFree+0x196>
 8008cde:	68f8      	ldr	r0, [r7, #12]
 8008ce0:	f015 fef4 	bl	801eacc <wolfSSL_Free>
        ctx->x509_store.param = NULL;
 8008ce4:	687b      	ldr	r3, [r7, #4]
 8008ce6:	2200      	movs	r2, #0
 8008ce8:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
    }

    if (ctx->x509_store.lookup.dirs) {
 8008cec:	687b      	ldr	r3, [r7, #4]
 8008cee:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008cf2:	2b00      	cmp	r3, #0
 8008cf4:	d010      	beq.n	8008d18 <SSL_CtxResourceFree+0x1ca>
        if (ctx->x509_store.lookup.dirs->dir_entry) {
            wolfSSL_sk_BY_DIR_entry_free(ctx->x509_store.lookup.dirs->dir_entry);
        }

#endif
        wc_FreeMutex(&ctx->x509_store.lookup.dirs->lock);
 8008cf6:	687b      	ldr	r3, [r7, #4]
 8008cf8:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008cfc:	3304      	adds	r3, #4
 8008cfe:	4618      	mov	r0, r3
 8008d00:	f01e fb4d 	bl	802739e <wc_FreeMutex>
        XFREE(ctx->x509_store.lookup.dirs, heapAtCTXInit, DYNAMIC_TYPE_OPENSSL);
 8008d04:	687b      	ldr	r3, [r7, #4]
 8008d06:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8008d0a:	60bb      	str	r3, [r7, #8]
 8008d0c:	68bb      	ldr	r3, [r7, #8]
 8008d0e:	2b00      	cmp	r3, #0
 8008d10:	d002      	beq.n	8008d18 <SSL_CtxResourceFree+0x1ca>
 8008d12:	68b8      	ldr	r0, [r7, #8]
 8008d14:	f015 feda 	bl	801eacc <wolfSSL_Free>
#if defined(WOLFSSL_TLS13) && defined(HAVE_ECH)
    FreeEchConfigs(ctx->echConfigs, ctx->heap);
    ctx->echConfigs = NULL;
#endif
    (void)heapAtCTXInit;
}
 8008d18:	bf00      	nop
 8008d1a:	3730      	adds	r7, #48	@ 0x30
 8008d1c:	46bd      	mov	sp, r7
 8008d1e:	bd80      	pop	{r7, pc}

08008d20 <FreeSSL_Ctx>:


void FreeSSL_Ctx(WOLFSSL_CTX* ctx)
{
 8008d20:	b580      	push	{r7, lr}
 8008d22:	b088      	sub	sp, #32
 8008d24:	af00      	add	r7, sp, #0
 8008d26:	6078      	str	r0, [r7, #4]
    int isZero;
    int ret;
    void* heap = ctx->heap;
 8008d28:	687b      	ldr	r3, [r7, #4]
 8008d2a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008d2c:	61fb      	str	r3, [r7, #28]
        heap = NULL;
    }
#endif

    /* decrement CTX reference count */
    wolfSSL_RefWithMutexDec(&ctx->ref, &isZero, &ret);
 8008d2e:	687b      	ldr	r3, [r7, #4]
 8008d30:	3308      	adds	r3, #8
 8008d32:	2101      	movs	r1, #1
 8008d34:	4618      	mov	r0, r3
 8008d36:	f7ff fdb1 	bl	800889c <wolfSSL_Atomic_Int_FetchSub>
 8008d3a:	61b8      	str	r0, [r7, #24]
 8008d3c:	69bb      	ldr	r3, [r7, #24]
 8008d3e:	2b01      	cmp	r3, #1
 8008d40:	bf0c      	ite	eq
 8008d42:	2301      	moveq	r3, #1
 8008d44:	2300      	movne	r3, #0
 8008d46:	b2db      	uxtb	r3, r3
 8008d48:	613b      	str	r3, [r7, #16]
 8008d4a:	2300      	movs	r3, #0
 8008d4c:	60fb      	str	r3, [r7, #12]
    }
#else
    (void)ret;
#endif

    if (isZero) {
 8008d4e:	693b      	ldr	r3, [r7, #16]
 8008d50:	2b00      	cmp	r3, #0
 8008d52:	d00a      	beq.n	8008d6a <FreeSSL_Ctx+0x4a>
        WOLFSSL_MSG("CTX ref count down to 0, doing full free");

        SSL_CtxResourceFree(ctx);
 8008d54:	6878      	ldr	r0, [r7, #4]
 8008d56:	f7ff fefa 	bl	8008b4e <SSL_CtxResourceFree>
#if defined(HAVE_SESSION_TICKET) && !defined(NO_WOLFSSL_SERVER) && \
    !defined(WOLFSSL_NO_DEF_TICKET_ENC_CB) && !defined(NO_TLS)
        TicketEncCbCtx_Free(&ctx->ticketKeyCtx);
#endif
        wolfSSL_RefFree(&ctx->ref);
        XFREE(ctx, heap, DYNAMIC_TYPE_CTX);
 8008d5a:	687b      	ldr	r3, [r7, #4]
 8008d5c:	617b      	str	r3, [r7, #20]
 8008d5e:	697b      	ldr	r3, [r7, #20]
 8008d60:	2b00      	cmp	r3, #0
 8008d62:	d002      	beq.n	8008d6a <FreeSSL_Ctx+0x4a>
 8008d64:	6978      	ldr	r0, [r7, #20]
 8008d66:	f015 feb1 	bl	801eacc <wolfSSL_Free>
    }
    else {
        WOLFSSL_MSG("CTX ref count not 0 yet, no free");
    }
    (void)heap; /* not used in some builds */
}
 8008d6a:	bf00      	nop
 8008d6c:	3720      	adds	r7, #32
 8008d6e:	46bd      	mov	sp, r7
 8008d70:	bd80      	pop	{r7, pc}

08008d72 <FreeCiphersSide>:
#endif /* WOLFSSL_DTLS13 */

}

static void FreeCiphersSide(Ciphers *cipher, void* heap)
{
 8008d72:	b580      	push	{r7, lr}
 8008d74:	b086      	sub	sp, #24
 8008d76:	af00      	add	r7, sp, #0
 8008d78:	6078      	str	r0, [r7, #4]
 8008d7a:	6039      	str	r1, [r7, #0]
    cipher->des3 = NULL;
#endif
#if defined(BUILD_AES) || defined(BUILD_AESGCM) || defined(HAVE_ARIA)
    /* See: InitKeys() in keys.c on addition of BUILD_AESGCM check (enc->aes,
     * dec->aes) */
    wc_AesFree(cipher->aes);
 8008d7c:	687b      	ldr	r3, [r7, #4]
 8008d7e:	681b      	ldr	r3, [r3, #0]
 8008d80:	4618      	mov	r0, r3
 8008d82:	f009 fc7b 	bl	801267c <wc_AesFree>
    XFREE(cipher->aes, heap, DYNAMIC_TYPE_CIPHER);
 8008d86:	687b      	ldr	r3, [r7, #4]
 8008d88:	681b      	ldr	r3, [r3, #0]
 8008d8a:	617b      	str	r3, [r7, #20]
 8008d8c:	697b      	ldr	r3, [r7, #20]
 8008d8e:	2b00      	cmp	r3, #0
 8008d90:	d002      	beq.n	8008d98 <FreeCiphersSide+0x26>
 8008d92:	6978      	ldr	r0, [r7, #20]
 8008d94:	f015 fe9a 	bl	801eacc <wolfSSL_Free>
    cipher->aes = NULL;
 8008d98:	687b      	ldr	r3, [r7, #4]
 8008d9a:	2200      	movs	r2, #0
 8008d9c:	601a      	str	r2, [r3, #0]
    XFREE(cipher->sm4, heap, DYNAMIC_TYPE_CIPHER);
    cipher->sm4 = NULL;
#endif
#if (defined(BUILD_AESGCM) || defined(BUILD_AESCCM) || defined(HAVE_ARIA)) && \
    !defined(WOLFSSL_NO_TLS12)
    XFREE(cipher->additional, heap, DYNAMIC_TYPE_CIPHER);
 8008d9e:	687b      	ldr	r3, [r7, #4]
 8008da0:	685b      	ldr	r3, [r3, #4]
 8008da2:	613b      	str	r3, [r7, #16]
 8008da4:	693b      	ldr	r3, [r7, #16]
 8008da6:	2b00      	cmp	r3, #0
 8008da8:	d002      	beq.n	8008db0 <FreeCiphersSide+0x3e>
 8008daa:	6938      	ldr	r0, [r7, #16]
 8008dac:	f015 fe8e 	bl	801eacc <wolfSSL_Free>
    cipher->additional = NULL;
 8008db0:	687b      	ldr	r3, [r7, #4]
 8008db2:	2200      	movs	r2, #0
 8008db4:	605a      	str	r2, [r3, #4]
#endif
#ifdef CIPHER_NONCE
    XFREE(cipher->nonce, heap, DYNAMIC_TYPE_CIPHER);
 8008db6:	687b      	ldr	r3, [r7, #4]
 8008db8:	689b      	ldr	r3, [r3, #8]
 8008dba:	60fb      	str	r3, [r7, #12]
 8008dbc:	68fb      	ldr	r3, [r7, #12]
 8008dbe:	2b00      	cmp	r3, #0
 8008dc0:	d002      	beq.n	8008dc8 <FreeCiphersSide+0x56>
 8008dc2:	68f8      	ldr	r0, [r7, #12]
 8008dc4:	f015 fe82 	bl	801eacc <wolfSSL_Free>
    cipher->nonce = NULL;
 8008dc8:	687b      	ldr	r3, [r7, #4]
 8008dca:	2200      	movs	r2, #0
 8008dcc:	609a      	str	r2, [r3, #8]
#ifdef HAVE_CAMELLIA
    XFREE(cipher->cam, heap, DYNAMIC_TYPE_CIPHER);
    cipher->cam = NULL;
#endif
#ifdef HAVE_CHACHA
    if (cipher->chacha)
 8008dce:	687b      	ldr	r3, [r7, #4]
 8008dd0:	68db      	ldr	r3, [r3, #12]
 8008dd2:	2b00      	cmp	r3, #0
 8008dd4:	d005      	beq.n	8008de2 <FreeCiphersSide+0x70>
        ForceZero(cipher->chacha, sizeof(ChaCha));
 8008dd6:	687b      	ldr	r3, [r7, #4]
 8008dd8:	68db      	ldr	r3, [r3, #12]
 8008dda:	2144      	movs	r1, #68	@ 0x44
 8008ddc:	4618      	mov	r0, r3
 8008dde:	f7ff fd72 	bl	80088c6 <ForceZero>
    XFREE(cipher->chacha, heap, DYNAMIC_TYPE_CIPHER);
 8008de2:	687b      	ldr	r3, [r7, #4]
 8008de4:	68db      	ldr	r3, [r3, #12]
 8008de6:	60bb      	str	r3, [r7, #8]
 8008de8:	68bb      	ldr	r3, [r7, #8]
 8008dea:	2b00      	cmp	r3, #0
 8008dec:	d002      	beq.n	8008df4 <FreeCiphersSide+0x82>
 8008dee:	68b8      	ldr	r0, [r7, #8]
 8008df0:	f015 fe6c 	bl	801eacc <wolfSSL_Free>
    cipher->chacha = NULL;
 8008df4:	687b      	ldr	r3, [r7, #4]
 8008df6:	2200      	movs	r2, #0
 8008df8:	60da      	str	r2, [r3, #12]
#if defined(WOLFSSL_TLS13) && defined(HAVE_NULL_CIPHER)
    wc_HmacFree(cipher->hmac);
    XFREE(cipher->hmac, heap, DYNAMIC_TYPE_CIPHER);
    cipher->hmac = NULL;
#endif
}
 8008dfa:	bf00      	nop
 8008dfc:	3718      	adds	r7, #24
 8008dfe:	46bd      	mov	sp, r7
 8008e00:	bd80      	pop	{r7, pc}

08008e02 <FreeCiphers>:

/* Free ciphers */
void FreeCiphers(WOLFSSL* ssl)
{
 8008e02:	b580      	push	{r7, lr}
 8008e04:	b084      	sub	sp, #16
 8008e06:	af00      	add	r7, sp, #0
 8008e08:	6078      	str	r0, [r7, #4]
    FreeCiphersSide(&ssl->encrypt, ssl->heap);
 8008e0a:	687b      	ldr	r3, [r7, #4]
 8008e0c:	f103 02bc 	add.w	r2, r3, #188	@ 0xbc
 8008e10:	687b      	ldr	r3, [r7, #4]
 8008e12:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8008e16:	4619      	mov	r1, r3
 8008e18:	4610      	mov	r0, r2
 8008e1a:	f7ff ffaa 	bl	8008d72 <FreeCiphersSide>
    FreeCiphersSide(&ssl->decrypt, ssl->heap);
 8008e1e:	687b      	ldr	r3, [r7, #4]
 8008e20:	f103 02d0 	add.w	r2, r3, #208	@ 0xd0
 8008e24:	687b      	ldr	r3, [r7, #4]
 8008e26:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8008e2a:	4619      	mov	r1, r3
 8008e2c:	4610      	mov	r0, r2
 8008e2e:	f7ff ffa0 	bl	8008d72 <FreeCiphersSide>

#if defined(HAVE_POLY1305) && defined(HAVE_ONE_TIME_AUTH)
    if (ssl->auth.poly1305)
 8008e32:	687b      	ldr	r3, [r7, #4]
 8008e34:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008e38:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008e3c:	2b00      	cmp	r3, #0
 8008e3e:	d008      	beq.n	8008e52 <FreeCiphers+0x50>
        ForceZero(ssl->auth.poly1305, sizeof(Poly1305));
 8008e40:	687b      	ldr	r3, [r7, #4]
 8008e42:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008e46:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008e4a:	2150      	movs	r1, #80	@ 0x50
 8008e4c:	4618      	mov	r0, r3
 8008e4e:	f7ff fd3a 	bl	80088c6 <ForceZero>
    XFREE(ssl->auth.poly1305, ssl->heap, DYNAMIC_TYPE_CIPHER);
 8008e52:	687b      	ldr	r3, [r7, #4]
 8008e54:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008e58:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8008e5c:	60fb      	str	r3, [r7, #12]
 8008e5e:	68fb      	ldr	r3, [r7, #12]
 8008e60:	2b00      	cmp	r3, #0
 8008e62:	d002      	beq.n	8008e6a <FreeCiphers+0x68>
 8008e64:	68f8      	ldr	r0, [r7, #12]
 8008e66:	f015 fe31 	bl	801eacc <wolfSSL_Free>
    ssl->auth.poly1305 = NULL;
 8008e6a:	687b      	ldr	r3, [r7, #4]
 8008e6c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8008e70:	461a      	mov	r2, r3
 8008e72:	2300      	movs	r3, #0
 8008e74:	f8c2 3098 	str.w	r3, [r2, #152]	@ 0x98
    XFREE(ssl->dtlsRecordNumberDecrypt.chacha, ssl->heap, DYNAMIC_TYPE_CIPHER);
    ssl->dtlsRecordNumberEncrypt.chacha = NULL;
    ssl->dtlsRecordNumberDecrypt.chacha = NULL;
#endif /* HAVE_CHACHA */
#endif /* WOLFSSL_DTLS13 */
}
 8008e78:	bf00      	nop
 8008e7a:	3710      	adds	r7, #16
 8008e7c:	46bd      	mov	sp, r7
 8008e7e:	bd80      	pop	{r7, pc}

08008e80 <AddSuiteHashSigAlgo>:
        *(inOutIdx) += 2;                               \
    } while (0)

static WC_INLINE void AddSuiteHashSigAlgo(byte* hashSigAlgo, byte macAlgo,
    byte sigAlgo, int keySz, word16* inOutIdx)
{
 8008e80:	b480      	push	{r7}
 8008e82:	b087      	sub	sp, #28
 8008e84:	af00      	add	r7, sp, #0
 8008e86:	60f8      	str	r0, [r7, #12]
 8008e88:	607b      	str	r3, [r7, #4]
 8008e8a:	460b      	mov	r3, r1
 8008e8c:	72fb      	strb	r3, [r7, #11]
 8008e8e:	4613      	mov	r3, r2
 8008e90:	72bb      	strb	r3, [r7, #10]
    int addSigAlgo = 1;
 8008e92:	2301      	movs	r3, #1
 8008e94:	617b      	str	r3, [r7, #20]
    }
#else
    (void)keySz;
#endif /* USE_ECDSA_KEYSZ_HASH_ALGO */

    if (addSigAlgo) {
 8008e96:	697b      	ldr	r3, [r7, #20]
 8008e98:	2b00      	cmp	r3, #0
 8008e9a:	d04a      	beq.n	8008f32 <AddSuiteHashSigAlgo+0xb2>
                DILITHIUM_LEVEL5_SA_MAJOR, DILITHIUM_LEVEL5_SA_MINOR);
        }
        else
    #endif /* HAVE_DILITHIUM */
#ifdef WC_RSA_PSS
        if (sigAlgo == rsa_pss_sa_algo) {
 8008e9c:	7abb      	ldrb	r3, [r7, #10]
 8008e9e:	2b08      	cmp	r3, #8
 8008ea0:	d130      	bne.n	8008f04 <AddSuiteHashSigAlgo+0x84>
            /* RSA PSS is sig then mac */
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, sigAlgo, macAlgo);
 8008ea2:	68fb      	ldr	r3, [r7, #12]
 8008ea4:	2b00      	cmp	r3, #0
 8008ea6:	d00d      	beq.n	8008ec4 <AddSuiteHashSigAlgo+0x44>
 8008ea8:	6a3b      	ldr	r3, [r7, #32]
 8008eaa:	881b      	ldrh	r3, [r3, #0]
 8008eac:	461a      	mov	r2, r3
 8008eae:	68fb      	ldr	r3, [r7, #12]
 8008eb0:	4413      	add	r3, r2
 8008eb2:	7aba      	ldrb	r2, [r7, #10]
 8008eb4:	701a      	strb	r2, [r3, #0]
 8008eb6:	6a3b      	ldr	r3, [r7, #32]
 8008eb8:	881b      	ldrh	r3, [r3, #0]
 8008eba:	3301      	adds	r3, #1
 8008ebc:	68fa      	ldr	r2, [r7, #12]
 8008ebe:	4413      	add	r3, r2
 8008ec0:	7afa      	ldrb	r2, [r7, #11]
 8008ec2:	701a      	strb	r2, [r3, #0]
 8008ec4:	6a3b      	ldr	r3, [r7, #32]
 8008ec6:	881b      	ldrh	r3, [r3, #0]
 8008ec8:	3302      	adds	r3, #2
 8008eca:	b29a      	uxth	r2, r3
 8008ecc:	6a3b      	ldr	r3, [r7, #32]
 8008ece:	801a      	strh	r2, [r3, #0]
    #ifdef WOLFSSL_TLS13
            /* Add the certificate algorithm as well */
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, sigAlgo,
 8008ed0:	68fb      	ldr	r3, [r7, #12]
 8008ed2:	2b00      	cmp	r3, #0
 8008ed4:	d00f      	beq.n	8008ef6 <AddSuiteHashSigAlgo+0x76>
 8008ed6:	6a3b      	ldr	r3, [r7, #32]
 8008ed8:	881b      	ldrh	r3, [r3, #0]
 8008eda:	461a      	mov	r2, r3
 8008edc:	68fb      	ldr	r3, [r7, #12]
 8008ede:	4413      	add	r3, r2
 8008ee0:	7aba      	ldrb	r2, [r7, #10]
 8008ee2:	701a      	strb	r2, [r3, #0]
 8008ee4:	6a3b      	ldr	r3, [r7, #32]
 8008ee6:	881b      	ldrh	r3, [r3, #0]
 8008ee8:	3301      	adds	r3, #1
 8008eea:	68fa      	ldr	r2, [r7, #12]
 8008eec:	4413      	add	r3, r2
 8008eee:	7afa      	ldrb	r2, [r7, #11]
 8008ef0:	3205      	adds	r2, #5
 8008ef2:	b2d2      	uxtb	r2, r2
 8008ef4:	701a      	strb	r2, [r3, #0]
 8008ef6:	6a3b      	ldr	r3, [r7, #32]
 8008ef8:	881b      	ldrh	r3, [r3, #0]
 8008efa:	3302      	adds	r3, #2
 8008efc:	b29a      	uxth	r2, r3
 8008efe:	6a3b      	ldr	r3, [r7, #32]
 8008f00:	801a      	strh	r2, [r3, #0]
#endif
        {
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, macAlgo, sigAlgo);
        }
    }
}
 8008f02:	e016      	b.n	8008f32 <AddSuiteHashSigAlgo+0xb2>
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, macAlgo, sigAlgo);
 8008f04:	68fb      	ldr	r3, [r7, #12]
 8008f06:	2b00      	cmp	r3, #0
 8008f08:	d00d      	beq.n	8008f26 <AddSuiteHashSigAlgo+0xa6>
 8008f0a:	6a3b      	ldr	r3, [r7, #32]
 8008f0c:	881b      	ldrh	r3, [r3, #0]
 8008f0e:	461a      	mov	r2, r3
 8008f10:	68fb      	ldr	r3, [r7, #12]
 8008f12:	4413      	add	r3, r2
 8008f14:	7afa      	ldrb	r2, [r7, #11]
 8008f16:	701a      	strb	r2, [r3, #0]
 8008f18:	6a3b      	ldr	r3, [r7, #32]
 8008f1a:	881b      	ldrh	r3, [r3, #0]
 8008f1c:	3301      	adds	r3, #1
 8008f1e:	68fa      	ldr	r2, [r7, #12]
 8008f20:	4413      	add	r3, r2
 8008f22:	7aba      	ldrb	r2, [r7, #10]
 8008f24:	701a      	strb	r2, [r3, #0]
 8008f26:	6a3b      	ldr	r3, [r7, #32]
 8008f28:	881b      	ldrh	r3, [r3, #0]
 8008f2a:	3302      	adds	r3, #2
 8008f2c:	b29a      	uxth	r2, r3
 8008f2e:	6a3b      	ldr	r3, [r7, #32]
 8008f30:	801a      	strh	r2, [r3, #0]
}
 8008f32:	bf00      	nop
 8008f34:	371c      	adds	r7, #28
 8008f36:	46bd      	mov	sp, r7
 8008f38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f3c:	4770      	bx	lr

08008f3e <InitSuitesHashSigAlgo>:

void InitSuitesHashSigAlgo(byte* hashSigAlgo, int haveSig, int tls1_2,
    int keySz, word16* len)
{
 8008f3e:	b580      	push	{r7, lr}
 8008f40:	b088      	sub	sp, #32
 8008f42:	af02      	add	r7, sp, #8
 8008f44:	60f8      	str	r0, [r7, #12]
 8008f46:	60b9      	str	r1, [r7, #8]
 8008f48:	607a      	str	r2, [r7, #4]
 8008f4a:	603b      	str	r3, [r7, #0]
    word16 idx = 0;
 8008f4c:	2300      	movs	r3, #0
 8008f4e:	82fb      	strh	r3, [r7, #22]

    (void)tls1_2;
    (void)keySz;

#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    if (haveSig & SIG_ECDSA) {
 8008f50:	68bb      	ldr	r3, [r7, #8]
 8008f52:	f003 0301 	and.w	r3, r3, #1
 8008f56:	2b00      	cmp	r3, #0
 8008f58:	d008      	beq.n	8008f6c <InitSuitesHashSigAlgo+0x2e>
    #ifdef WOLFSSL_SHA384
        AddSuiteHashSigAlgo(hashSigAlgo, sha384_mac, ecc_dsa_sa_algo, keySz,
            &idx);
    #endif
    #ifndef NO_SHA256
        AddSuiteHashSigAlgo(hashSigAlgo, sha256_mac, ecc_dsa_sa_algo, keySz,
 8008f5a:	f107 0316 	add.w	r3, r7, #22
 8008f5e:	9300      	str	r3, [sp, #0]
 8008f60:	683b      	ldr	r3, [r7, #0]
 8008f62:	2203      	movs	r2, #3
 8008f64:	2104      	movs	r1, #4
 8008f66:	68f8      	ldr	r0, [r7, #12]
 8008f68:	f7ff ff8a 	bl	8008e80 <AddSuiteHashSigAlgo>
            keySz, &idx);
        AddSuiteHashSigAlgo(hashSigAlgo, no_mac, dilithium_level5_sa_algo,
            keySz, &idx);
    }
#endif /* HAVE_DILITHIUM */
    if (haveSig & SIG_RSA) {
 8008f6c:	68bb      	ldr	r3, [r7, #8]
 8008f6e:	f003 0302 	and.w	r3, r3, #2
 8008f72:	2b00      	cmp	r3, #0
 8008f74:	d014      	beq.n	8008fa0 <InitSuitesHashSigAlgo+0x62>
    #ifdef WC_RSA_PSS
        if (tls1_2) {
 8008f76:	687b      	ldr	r3, [r7, #4]
 8008f78:	2b00      	cmp	r3, #0
 8008f7a:	d008      	beq.n	8008f8e <InitSuitesHashSigAlgo+0x50>
        #ifdef WOLFSSL_SHA384
            AddSuiteHashSigAlgo(hashSigAlgo, sha384_mac, rsa_pss_sa_algo, keySz,
                &idx);
        #endif
        #ifndef NO_SHA256
            AddSuiteHashSigAlgo(hashSigAlgo, sha256_mac, rsa_pss_sa_algo, keySz,
 8008f7c:	f107 0316 	add.w	r3, r7, #22
 8008f80:	9300      	str	r3, [sp, #0]
 8008f82:	683b      	ldr	r3, [r7, #0]
 8008f84:	2208      	movs	r2, #8
 8008f86:	2104      	movs	r1, #4
 8008f88:	68f8      	ldr	r0, [r7, #12]
 8008f8a:	f7ff ff79 	bl	8008e80 <AddSuiteHashSigAlgo>
    #endif
    #ifdef WOLFSSL_SHA384
        AddSuiteHashSigAlgo(hashSigAlgo, sha384_mac, rsa_sa_algo, keySz, &idx);
    #endif
    #ifndef NO_SHA256
        AddSuiteHashSigAlgo(hashSigAlgo, sha256_mac, rsa_sa_algo, keySz, &idx);
 8008f8e:	f107 0316 	add.w	r3, r7, #22
 8008f92:	9300      	str	r3, [sp, #0]
 8008f94:	683b      	ldr	r3, [r7, #0]
 8008f96:	2201      	movs	r2, #1
 8008f98:	2104      	movs	r1, #4
 8008f9a:	68f8      	ldr	r0, [r7, #12]
 8008f9c:	f7ff ff70 	bl	8008e80 <AddSuiteHashSigAlgo>
        AddSuiteHashSigAlgo(hashSigAlgo, sha_mac, anonymous_sa_algo, keySz,
            &idx);
    }
#endif

    *len = idx;
 8008fa0:	8afa      	ldrh	r2, [r7, #22]
 8008fa2:	6a3b      	ldr	r3, [r7, #32]
 8008fa4:	801a      	strh	r2, [r3, #0]
}
 8008fa6:	bf00      	nop
 8008fa8:	3718      	adds	r7, #24
 8008faa:	46bd      	mov	sp, r7
 8008fac:	bd80      	pop	{r7, pc}

08008fae <AllocateCtxSuites>:

int AllocateCtxSuites(WOLFSSL_CTX* ctx)
{
 8008fae:	b580      	push	{r7, lr}
 8008fb0:	b082      	sub	sp, #8
 8008fb2:	af00      	add	r7, sp, #0
 8008fb4:	6078      	str	r0, [r7, #4]
    if (ctx->suites == NULL) {
 8008fb6:	687b      	ldr	r3, [r7, #4]
 8008fb8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008fba:	2b00      	cmp	r3, #0
 8008fbc:	d115      	bne.n	8008fea <AllocateCtxSuites+0x3c>
        ctx->suites = (Suites*)XMALLOC(sizeof(Suites), ctx->heap,
 8008fbe:	f44f 70ac 	mov.w	r0, #344	@ 0x158
 8008fc2:	f015 fd67 	bl	801ea94 <wolfSSL_Malloc>
 8008fc6:	4602      	mov	r2, r0
 8008fc8:	687b      	ldr	r3, [r7, #4]
 8008fca:	655a      	str	r2, [r3, #84]	@ 0x54
                                       DYNAMIC_TYPE_SUITES);
        if (ctx->suites == NULL) {
 8008fcc:	687b      	ldr	r3, [r7, #4]
 8008fce:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008fd0:	2b00      	cmp	r3, #0
 8008fd2:	d102      	bne.n	8008fda <AllocateCtxSuites+0x2c>
            WOLFSSL_MSG("Memory alloc for Suites failed");
            return MEMORY_ERROR;
 8008fd4:	f46f 7397 	mvn.w	r3, #302	@ 0x12e
 8008fd8:	e008      	b.n	8008fec <AllocateCtxSuites+0x3e>
        }
        XMEMSET(ctx->suites, 0, sizeof(Suites));
 8008fda:	687b      	ldr	r3, [r7, #4]
 8008fdc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008fde:	f44f 72ac 	mov.w	r2, #344	@ 0x158
 8008fe2:	2100      	movs	r1, #0
 8008fe4:	4618      	mov	r0, r3
 8008fe6:	f01f fa73 	bl	80284d0 <memset>
    }
    return 0;
 8008fea:	2300      	movs	r3, #0
}
 8008fec:	4618      	mov	r0, r3
 8008fee:	3708      	adds	r7, #8
 8008ff0:	46bd      	mov	sp, r7
 8008ff2:	bd80      	pop	{r7, pc}

08008ff4 <AllocateSuites>:

/* Call this when the ssl object needs to have its own ssl->suites object */
int AllocateSuites(WOLFSSL* ssl)
{
 8008ff4:	b580      	push	{r7, lr}
 8008ff6:	b082      	sub	sp, #8
 8008ff8:	af00      	add	r7, sp, #0
 8008ffa:	6078      	str	r0, [r7, #4]
    if (ssl->suites == NULL) {
 8008ffc:	687b      	ldr	r3, [r7, #4]
 8008ffe:	685b      	ldr	r3, [r3, #4]
 8009000:	2b00      	cmp	r3, #0
 8009002:	d129      	bne.n	8009058 <AllocateSuites+0x64>
        ssl->suites = (Suites*)XMALLOC(sizeof(Suites), ssl->heap,
 8009004:	f44f 70ac 	mov.w	r0, #344	@ 0x158
 8009008:	f015 fd44 	bl	801ea94 <wolfSSL_Malloc>
 800900c:	4602      	mov	r2, r0
 800900e:	687b      	ldr	r3, [r7, #4]
 8009010:	605a      	str	r2, [r3, #4]
                                       DYNAMIC_TYPE_SUITES);
        if (ssl->suites == NULL) {
 8009012:	687b      	ldr	r3, [r7, #4]
 8009014:	685b      	ldr	r3, [r3, #4]
 8009016:	2b00      	cmp	r3, #0
 8009018:	d102      	bne.n	8009020 <AllocateSuites+0x2c>
            WOLFSSL_MSG("Suites Memory error");
            return MEMORY_ERROR;
 800901a:	f46f 7397 	mvn.w	r3, #302	@ 0x12e
 800901e:	e01c      	b.n	800905a <AllocateSuites+0x66>
        }
        if (ssl->ctx != NULL && ssl->ctx->suites != NULL)
 8009020:	687b      	ldr	r3, [r7, #4]
 8009022:	681b      	ldr	r3, [r3, #0]
 8009024:	2b00      	cmp	r3, #0
 8009026:	d00f      	beq.n	8009048 <AllocateSuites+0x54>
 8009028:	687b      	ldr	r3, [r7, #4]
 800902a:	681b      	ldr	r3, [r3, #0]
 800902c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800902e:	2b00      	cmp	r3, #0
 8009030:	d00a      	beq.n	8009048 <AllocateSuites+0x54>
            XMEMCPY(ssl->suites, ssl->ctx->suites, sizeof(Suites));
 8009032:	687b      	ldr	r3, [r7, #4]
 8009034:	6858      	ldr	r0, [r3, #4]
 8009036:	687b      	ldr	r3, [r7, #4]
 8009038:	681b      	ldr	r3, [r3, #0]
 800903a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800903c:	f44f 72ac 	mov.w	r2, #344	@ 0x158
 8009040:	4619      	mov	r1, r3
 8009042:	f01f faaf 	bl	80285a4 <memcpy>
 8009046:	e007      	b.n	8009058 <AllocateSuites+0x64>
        else
            XMEMSET(ssl->suites, 0, sizeof(Suites));
 8009048:	687b      	ldr	r3, [r7, #4]
 800904a:	685b      	ldr	r3, [r3, #4]
 800904c:	f44f 72ac 	mov.w	r2, #344	@ 0x158
 8009050:	2100      	movs	r1, #0
 8009052:	4618      	mov	r0, r3
 8009054:	f01f fa3c 	bl	80284d0 <memset>
    }
    return 0;
 8009058:	2300      	movs	r3, #0
}
 800905a:	4618      	mov	r0, r3
 800905c:	3708      	adds	r7, #8
 800905e:	46bd      	mov	sp, r7
 8009060:	bd80      	pop	{r7, pc}

08009062 <InitSuites>:
void InitSuites(Suites* suites, ProtocolVersion pv, int keySz, word16 haveRSA,
                word16 havePSK, word16 haveDH, word16 haveECDSAsig,
                word16 haveECC, word16 haveStaticRSA, word16 haveStaticECC,
                word16 haveAnon, word16 haveNull, word16 haveAES128,
                word16 haveSHA1, word16 haveRC4, int side)
{
 8009062:	b580      	push	{r7, lr}
 8009064:	b08c      	sub	sp, #48	@ 0x30
 8009066:	af02      	add	r7, sp, #8
 8009068:	60f8      	str	r0, [r7, #12]
 800906a:	8139      	strh	r1, [r7, #8]
 800906c:	607a      	str	r2, [r7, #4]
 800906e:	807b      	strh	r3, [r7, #2]
    word16 idx = 0;
 8009070:	2300      	movs	r3, #0
 8009072:	84fb      	strh	r3, [r7, #38]	@ 0x26
    int    tls    = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_MINOR;
 8009074:	7a3b      	ldrb	r3, [r7, #8]
 8009076:	2b03      	cmp	r3, #3
 8009078:	d104      	bne.n	8009084 <InitSuites+0x22>
 800907a:	7a7b      	ldrb	r3, [r7, #9]
 800907c:	2b00      	cmp	r3, #0
 800907e:	d001      	beq.n	8009084 <InitSuites+0x22>
 8009080:	2301      	movs	r3, #1
 8009082:	e000      	b.n	8009086 <InitSuites+0x24>
 8009084:	2300      	movs	r3, #0
 8009086:	623b      	str	r3, [r7, #32]
    int    tls1_2 = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_2_MINOR;
 8009088:	7a3b      	ldrb	r3, [r7, #8]
 800908a:	2b03      	cmp	r3, #3
 800908c:	d104      	bne.n	8009098 <InitSuites+0x36>
 800908e:	7a7b      	ldrb	r3, [r7, #9]
 8009090:	2b02      	cmp	r3, #2
 8009092:	d901      	bls.n	8009098 <InitSuites+0x36>
 8009094:	2301      	movs	r3, #1
 8009096:	e000      	b.n	800909a <InitSuites+0x38>
 8009098:	2300      	movs	r3, #0
 800909a:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_TLS13
    int    tls1_3 = IsAtLeastTLSv1_3(pv);
 800909c:	68b8      	ldr	r0, [r7, #8]
 800909e:	f7ff fc3b 	bl	8008918 <IsAtLeastTLSv1_3>
 80090a2:	61b8      	str	r0, [r7, #24]
#endif
    int    dtls   = 0;
 80090a4:	2300      	movs	r3, #0
 80090a6:	617b      	str	r3, [r7, #20]
    int    haveRSAsig = 1;
 80090a8:	2301      	movs	r3, #1
 80090aa:	613b      	str	r3, [r7, #16]
    (void)haveNull;
    (void)haveAES128;
    (void)haveSHA1;
    (void)haveRC4;

    if (suites == NULL) {
 80090ac:	68fb      	ldr	r3, [r7, #12]
 80090ae:	2b00      	cmp	r3, #0
 80090b0:	f000 81bc 	beq.w	800942c <InitSuites+0x3ca>
        WOLFSSL_MSG("InitSuites pointer error");
        return;
    }

    if (suites->setSuites)
 80090b4:	68fb      	ldr	r3, [r7, #12]
 80090b6:	f893 3156 	ldrb.w	r3, [r3, #342]	@ 0x156
 80090ba:	f003 0301 	and.w	r3, r3, #1
 80090be:	b2db      	uxtb	r3, r3
 80090c0:	2b00      	cmp	r3, #0
 80090c2:	f040 81b5 	bne.w	8009430 <InitSuites+0x3ce>
        suites->suites[idx++] = TLS_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_AES_128_GCM_SHA256
    if (tls1_3 && haveAES128) {
 80090c6:	69bb      	ldr	r3, [r7, #24]
 80090c8:	2b00      	cmp	r3, #0
 80090ca:	d013      	beq.n	80090f4 <InitSuites+0x92>
 80090cc:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80090d0:	2b00      	cmp	r3, #0
 80090d2:	d00f      	beq.n	80090f4 <InitSuites+0x92>
        suites->suites[idx++] = TLS13_BYTE;
 80090d4:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80090d6:	1c5a      	adds	r2, r3, #1
 80090d8:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80090da:	461a      	mov	r2, r3
 80090dc:	68fb      	ldr	r3, [r7, #12]
 80090de:	4413      	add	r3, r2
 80090e0:	2213      	movs	r2, #19
 80090e2:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_AES_128_GCM_SHA256;
 80090e4:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80090e6:	1c5a      	adds	r2, r3, #1
 80090e8:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80090ea:	461a      	mov	r2, r3
 80090ec:	68fb      	ldr	r3, [r7, #12]
 80090ee:	4413      	add	r3, r2
 80090f0:	2201      	movs	r2, #1
 80090f2:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_CHACHA20_POLY1305_SHA256
    if (tls1_3) {
 80090f4:	69bb      	ldr	r3, [r7, #24]
 80090f6:	2b00      	cmp	r3, #0
 80090f8:	d00f      	beq.n	800911a <InitSuites+0xb8>
        suites->suites[idx++] = TLS13_BYTE;
 80090fa:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80090fc:	1c5a      	adds	r2, r3, #1
 80090fe:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009100:	461a      	mov	r2, r3
 8009102:	68fb      	ldr	r3, [r7, #12]
 8009104:	4413      	add	r3, r2
 8009106:	2213      	movs	r2, #19
 8009108:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_CHACHA20_POLY1305_SHA256;
 800910a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800910c:	1c5a      	adds	r2, r3, #1
 800910e:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009110:	461a      	mov	r2, r3
 8009112:	68fb      	ldr	r3, [r7, #12]
 8009114:	4413      	add	r3, r2
 8009116:	2203      	movs	r2, #3
 8009118:	711a      	strb	r2, [r3, #4]
#endif /* WOLFSSL_TLS13 */

#ifndef WOLFSSL_NO_TLS12

#if !defined(NO_WOLFSSL_SERVER) && !defined(NO_RSA)
    if (side == WOLFSSL_SERVER_END && haveStaticECC) {
 800911a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800911c:	2b00      	cmp	r3, #0
 800911e:	d105      	bne.n	800912c <InitSuites+0xca>
 8009120:	f8b7 3044 	ldrh.w	r3, [r7, #68]	@ 0x44
 8009124:	2b00      	cmp	r3, #0
 8009126:	d001      	beq.n	800912c <InitSuites+0xca>
        haveRSA = 0;   /* can't do RSA with ECDSA key */
 8009128:	2300      	movs	r3, #0
 800912a:	807b      	strh	r3, [r7, #2]
    }

    if (side == WOLFSSL_SERVER_END && haveECDSAsig) {
 800912c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800912e:	2b00      	cmp	r3, #0
 8009130:	d104      	bne.n	800913c <InitSuites+0xda>
 8009132:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 8009134:	2b00      	cmp	r3, #0
 8009136:	d001      	beq.n	800913c <InitSuites+0xda>
        haveRSAsig = 0;     /* can't have RSA sig if signed by ECDSA */
 8009138:	2300      	movs	r3, #0
 800913a:	613b      	str	r3, [r7, #16]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
    if (tls1_2 && haveECC && haveAES128) {
 800913c:	69fb      	ldr	r3, [r7, #28]
 800913e:	2b00      	cmp	r3, #0
 8009140:	d016      	beq.n	8009170 <InitSuites+0x10e>
 8009142:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 8009144:	2b00      	cmp	r3, #0
 8009146:	d013      	beq.n	8009170 <InitSuites+0x10e>
 8009148:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 800914c:	2b00      	cmp	r3, #0
 800914e:	d00f      	beq.n	8009170 <InitSuites+0x10e>
        suites->suites[idx++] = ECC_BYTE;
 8009150:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009152:	1c5a      	adds	r2, r3, #1
 8009154:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009156:	461a      	mov	r2, r3
 8009158:	68fb      	ldr	r3, [r7, #12]
 800915a:	4413      	add	r3, r2
 800915c:	22c0      	movs	r2, #192	@ 0xc0
 800915e:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
 8009160:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009162:	1c5a      	adds	r2, r3, #1
 8009164:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009166:	461a      	mov	r2, r3
 8009168:	68fb      	ldr	r3, [r7, #12]
 800916a:	4413      	add	r3, r2
 800916c:	222b      	movs	r2, #43	@ 0x2b
 800916e:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA && haveAES128) ||
 8009170:	69fb      	ldr	r3, [r7, #28]
 8009172:	2b00      	cmp	r3, #0
 8009174:	d006      	beq.n	8009184 <InitSuites+0x122>
 8009176:	887b      	ldrh	r3, [r7, #2]
 8009178:	2b00      	cmp	r3, #0
 800917a:	d003      	beq.n	8009184 <InitSuites+0x122>
 800917c:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 8009180:	2b00      	cmp	r3, #0
 8009182:	d109      	bne.n	8009198 <InitSuites+0x136>
 8009184:	69fb      	ldr	r3, [r7, #28]
 8009186:	2b00      	cmp	r3, #0
 8009188:	d016      	beq.n	80091b8 <InitSuites+0x156>
        (tls1_2 && haveECDSAsig && haveAES128)) {
 800918a:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 800918c:	2b00      	cmp	r3, #0
 800918e:	d013      	beq.n	80091b8 <InitSuites+0x156>
 8009190:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 8009194:	2b00      	cmp	r3, #0
 8009196:	d00f      	beq.n	80091b8 <InitSuites+0x156>
    #else
    if (tls1_2 && haveRSA && haveAES128) {
    #endif
        suites->suites[idx++] = ECC_BYTE;
 8009198:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800919a:	1c5a      	adds	r2, r3, #1
 800919c:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800919e:	461a      	mov	r2, r3
 80091a0:	68fb      	ldr	r3, [r7, #12]
 80091a2:	4413      	add	r3, r2
 80091a4:	22c0      	movs	r2, #192	@ 0xc0
 80091a6:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
 80091a8:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80091aa:	1c5a      	adds	r2, r3, #1
 80091ac:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80091ae:	461a      	mov	r2, r3
 80091b0:	68fb      	ldr	r3, [r7, #12]
 80091b2:	4413      	add	r3, r2
 80091b4:	222f      	movs	r2, #47	@ 0x2f
 80091b6:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_256_GCM_SHA384;
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
    if (tls1_2 && haveDH && haveRSA && haveAES128) {
 80091b8:	69fb      	ldr	r3, [r7, #28]
 80091ba:	2b00      	cmp	r3, #0
 80091bc:	d019      	beq.n	80091f2 <InitSuites+0x190>
 80091be:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 80091c0:	2b00      	cmp	r3, #0
 80091c2:	d016      	beq.n	80091f2 <InitSuites+0x190>
 80091c4:	887b      	ldrh	r3, [r7, #2]
 80091c6:	2b00      	cmp	r3, #0
 80091c8:	d013      	beq.n	80091f2 <InitSuites+0x190>
 80091ca:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80091ce:	2b00      	cmp	r3, #0
 80091d0:	d00f      	beq.n	80091f2 <InitSuites+0x190>
        suites->suites[idx++] = CIPHER_BYTE;
 80091d2:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80091d4:	1c5a      	adds	r2, r3, #1
 80091d6:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80091d8:	461a      	mov	r2, r3
 80091da:	68fb      	ldr	r3, [r7, #12]
 80091dc:	4413      	add	r3, r2
 80091de:	2200      	movs	r2, #0
 80091e0:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_128_GCM_SHA256;
 80091e2:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80091e4:	1c5a      	adds	r2, r3, #1
 80091e6:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80091e8:	461a      	mov	r2, r3
 80091ea:	68fb      	ldr	r3, [r7, #12]
 80091ec:	4413      	add	r3, r2
 80091ee:	229e      	movs	r2, #158	@ 0x9e
 80091f0:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_PSK_WITH_AES_128_GCM_SHA256;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
    if (tls1_2 && haveECC) {
 80091f2:	69fb      	ldr	r3, [r7, #28]
 80091f4:	2b00      	cmp	r3, #0
 80091f6:	d012      	beq.n	800921e <InitSuites+0x1bc>
 80091f8:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 80091fa:	2b00      	cmp	r3, #0
 80091fc:	d00f      	beq.n	800921e <InitSuites+0x1bc>
        suites->suites[idx++] = CHACHA_BYTE;
 80091fe:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009200:	1c5a      	adds	r2, r3, #1
 8009202:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009204:	461a      	mov	r2, r3
 8009206:	68fb      	ldr	r3, [r7, #12]
 8009208:	4413      	add	r3, r2
 800920a:	22cc      	movs	r2, #204	@ 0xcc
 800920c:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256;
 800920e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009210:	1c5a      	adds	r2, r3, #1
 8009212:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009214:	461a      	mov	r2, r3
 8009216:	68fb      	ldr	r3, [r7, #12]
 8009218:	4413      	add	r3, r2
 800921a:	22a9      	movs	r2, #169	@ 0xa9
 800921c:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA) || (tls1_2 && haveECDSAsig)) {
 800921e:	69fb      	ldr	r3, [r7, #28]
 8009220:	2b00      	cmp	r3, #0
 8009222:	d002      	beq.n	800922a <InitSuites+0x1c8>
 8009224:	887b      	ldrh	r3, [r7, #2]
 8009226:	2b00      	cmp	r3, #0
 8009228:	d105      	bne.n	8009236 <InitSuites+0x1d4>
 800922a:	69fb      	ldr	r3, [r7, #28]
 800922c:	2b00      	cmp	r3, #0
 800922e:	d012      	beq.n	8009256 <InitSuites+0x1f4>
 8009230:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 8009232:	2b00      	cmp	r3, #0
 8009234:	d00f      	beq.n	8009256 <InitSuites+0x1f4>
    #else
    if (tls1_2 && haveRSA) {
    #endif
        suites->suites[idx++] = CHACHA_BYTE;
 8009236:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009238:	1c5a      	adds	r2, r3, #1
 800923a:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800923c:	461a      	mov	r2, r3
 800923e:	68fb      	ldr	r3, [r7, #12]
 8009240:	4413      	add	r3, r2
 8009242:	22cc      	movs	r2, #204	@ 0xcc
 8009244:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
 8009246:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009248:	1c5a      	adds	r2, r3, #1
 800924a:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800924c:	461a      	mov	r2, r3
 800924e:	68fb      	ldr	r3, [r7, #12]
 8009250:	4413      	add	r3, r2
 8009252:	22a8      	movs	r2, #168	@ 0xa8
 8009254:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    if (tls1_2 && haveRSA) {
 8009256:	69fb      	ldr	r3, [r7, #28]
 8009258:	2b00      	cmp	r3, #0
 800925a:	d012      	beq.n	8009282 <InitSuites+0x220>
 800925c:	887b      	ldrh	r3, [r7, #2]
 800925e:	2b00      	cmp	r3, #0
 8009260:	d00f      	beq.n	8009282 <InitSuites+0x220>
        suites->suites[idx++] = CHACHA_BYTE;
 8009262:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009264:	1c5a      	adds	r2, r3, #1
 8009266:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009268:	461a      	mov	r2, r3
 800926a:	68fb      	ldr	r3, [r7, #12]
 800926c:	4413      	add	r3, r2
 800926e:	22cc      	movs	r2, #204	@ 0xcc
 8009270:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
 8009272:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009274:	1c5a      	adds	r2, r3, #1
 8009276:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009278:	461a      	mov	r2, r3
 800927a:	68fb      	ldr	r3, [r7, #12]
 800927c:	4413      	add	r3, r2
 800927e:	22aa      	movs	r2, #170	@ 0xaa
 8009280:	711a      	strb	r2, [r3, #4]
#endif
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA && haveAES128) ||
 8009282:	69fb      	ldr	r3, [r7, #28]
 8009284:	2b00      	cmp	r3, #0
 8009286:	d006      	beq.n	8009296 <InitSuites+0x234>
 8009288:	887b      	ldrh	r3, [r7, #2]
 800928a:	2b00      	cmp	r3, #0
 800928c:	d003      	beq.n	8009296 <InitSuites+0x234>
 800928e:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 8009292:	2b00      	cmp	r3, #0
 8009294:	d109      	bne.n	80092aa <InitSuites+0x248>
 8009296:	69fb      	ldr	r3, [r7, #28]
 8009298:	2b00      	cmp	r3, #0
 800929a:	d016      	beq.n	80092ca <InitSuites+0x268>
        (tls1_2 && haveECDSAsig && haveAES128)) {
 800929c:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 800929e:	2b00      	cmp	r3, #0
 80092a0:	d013      	beq.n	80092ca <InitSuites+0x268>
 80092a2:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80092a6:	2b00      	cmp	r3, #0
 80092a8:	d00f      	beq.n	80092ca <InitSuites+0x268>
    #else
    if (tls1_2 && haveRSA && haveAES128) {
    #endif
        suites->suites[idx++] = ECC_BYTE;
 80092aa:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092ac:	1c5a      	adds	r2, r3, #1
 80092ae:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80092b0:	461a      	mov	r2, r3
 80092b2:	68fb      	ldr	r3, [r7, #12]
 80092b4:	4413      	add	r3, r2
 80092b6:	22c0      	movs	r2, #192	@ 0xc0
 80092b8:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
 80092ba:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092bc:	1c5a      	adds	r2, r3, #1
 80092be:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80092c0:	461a      	mov	r2, r3
 80092c2:	68fb      	ldr	r3, [r7, #12]
 80092c4:	4413      	add	r3, r2
 80092c6:	2227      	movs	r2, #39	@ 0x27
 80092c8:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
    if (tls1_2 && haveECC && haveAES128) {
 80092ca:	69fb      	ldr	r3, [r7, #28]
 80092cc:	2b00      	cmp	r3, #0
 80092ce:	d016      	beq.n	80092fe <InitSuites+0x29c>
 80092d0:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 80092d2:	2b00      	cmp	r3, #0
 80092d4:	d013      	beq.n	80092fe <InitSuites+0x29c>
 80092d6:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 80092da:	2b00      	cmp	r3, #0
 80092dc:	d00f      	beq.n	80092fe <InitSuites+0x29c>
        suites->suites[idx++] = ECC_BYTE;
 80092de:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092e0:	1c5a      	adds	r2, r3, #1
 80092e2:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80092e4:	461a      	mov	r2, r3
 80092e6:	68fb      	ldr	r3, [r7, #12]
 80092e8:	4413      	add	r3, r2
 80092ea:	22c0      	movs	r2, #192	@ 0xc0
 80092ec:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
 80092ee:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80092f0:	1c5a      	adds	r2, r3, #1
 80092f2:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80092f4:	461a      	mov	r2, r3
 80092f6:	68fb      	ldr	r3, [r7, #12]
 80092f8:	4413      	add	r3, r2
 80092fa:	2223      	movs	r2, #35	@ 0x23
 80092fc:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
#ifndef WOLFSSL_OLDTLS_SHA2_CIPHERSUITES
    if (tls1_2 && haveDH && haveRSA)
 80092fe:	69fb      	ldr	r3, [r7, #28]
 8009300:	2b00      	cmp	r3, #0
 8009302:	d015      	beq.n	8009330 <InitSuites+0x2ce>
 8009304:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 8009306:	2b00      	cmp	r3, #0
 8009308:	d012      	beq.n	8009330 <InitSuites+0x2ce>
 800930a:	887b      	ldrh	r3, [r7, #2]
 800930c:	2b00      	cmp	r3, #0
 800930e:	d00f      	beq.n	8009330 <InitSuites+0x2ce>
#else
    if (tls && haveDH && haveRSA)
#endif
    {
        suites->suites[idx++] = CIPHER_BYTE;
 8009310:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009312:	1c5a      	adds	r2, r3, #1
 8009314:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009316:	461a      	mov	r2, r3
 8009318:	68fb      	ldr	r3, [r7, #12]
 800931a:	4413      	add	r3, r2
 800931c:	2200      	movs	r2, #0
 800931e:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_256_CBC_SHA256;
 8009320:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009322:	1c5a      	adds	r2, r3, #1
 8009324:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009326:	461a      	mov	r2, r3
 8009328:	68fb      	ldr	r3, [r7, #12]
 800932a:	4413      	add	r3, r2
 800932c:	226b      	movs	r2, #107	@ 0x6b
 800932e:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
#ifndef WOLFSSL_OLDTLS_SHA2_CIPHERSUITES
    if (tls1_2 && haveDH && haveRSA && haveAES128)
 8009330:	69fb      	ldr	r3, [r7, #28]
 8009332:	2b00      	cmp	r3, #0
 8009334:	d019      	beq.n	800936a <InitSuites+0x308>
 8009336:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 8009338:	2b00      	cmp	r3, #0
 800933a:	d016      	beq.n	800936a <InitSuites+0x308>
 800933c:	887b      	ldrh	r3, [r7, #2]
 800933e:	2b00      	cmp	r3, #0
 8009340:	d013      	beq.n	800936a <InitSuites+0x308>
 8009342:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 8009346:	2b00      	cmp	r3, #0
 8009348:	d00f      	beq.n	800936a <InitSuites+0x308>
#else
    if (tls && haveDH && haveRSA && haveAES128)
#endif
    {
        suites->suites[idx++] = CIPHER_BYTE;
 800934a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800934c:	1c5a      	adds	r2, r3, #1
 800934e:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009350:	461a      	mov	r2, r3
 8009352:	68fb      	ldr	r3, [r7, #12]
 8009354:	4413      	add	r3, r2
 8009356:	2200      	movs	r2, #0
 8009358:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_AES_128_CBC_SHA256;
 800935a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800935c:	1c5a      	adds	r2, r3, #1
 800935e:	84fa      	strh	r2, [r7, #38]	@ 0x26
 8009360:	461a      	mov	r2, r3
 8009362:	68fb      	ldr	r3, [r7, #12]
 8009364:	4413      	add	r3, r2
 8009366:	2267      	movs	r2, #103	@ 0x67
 8009368:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_RSA_WITH_AES_128_CBC_SHA;
    }
#endif

#ifdef BUILD_TLS_ECDHE_ECDSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    if (tls1_2 && haveECC) {
 800936a:	69fb      	ldr	r3, [r7, #28]
 800936c:	2b00      	cmp	r3, #0
 800936e:	d012      	beq.n	8009396 <InitSuites+0x334>
 8009370:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 8009372:	2b00      	cmp	r3, #0
 8009374:	d00f      	beq.n	8009396 <InitSuites+0x334>
        suites->suites[idx++] = CHACHA_BYTE;
 8009376:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009378:	1c5a      	adds	r2, r3, #1
 800937a:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800937c:	461a      	mov	r2, r3
 800937e:	68fb      	ldr	r3, [r7, #12]
 8009380:	4413      	add	r3, r2
 8009382:	22cc      	movs	r2, #204	@ 0xcc
 8009384:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] =
 8009386:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8009388:	1c5a      	adds	r2, r3, #1
 800938a:	84fa      	strh	r2, [r7, #38]	@ 0x26
 800938c:	461a      	mov	r2, r3
 800938e:	68fb      	ldr	r3, [r7, #12]
 8009390:	4413      	add	r3, r2
 8009392:	2214      	movs	r2, #20
 8009394:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA) || (tls1_2 && haveECDSAsig)) {
 8009396:	69fb      	ldr	r3, [r7, #28]
 8009398:	2b00      	cmp	r3, #0
 800939a:	d002      	beq.n	80093a2 <InitSuites+0x340>
 800939c:	887b      	ldrh	r3, [r7, #2]
 800939e:	2b00      	cmp	r3, #0
 80093a0:	d105      	bne.n	80093ae <InitSuites+0x34c>
 80093a2:	69fb      	ldr	r3, [r7, #28]
 80093a4:	2b00      	cmp	r3, #0
 80093a6:	d012      	beq.n	80093ce <InitSuites+0x36c>
 80093a8:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 80093aa:	2b00      	cmp	r3, #0
 80093ac:	d00f      	beq.n	80093ce <InitSuites+0x36c>
    #else
    if (tls1_2 && haveRSA) {
    #endif
        suites->suites[idx++] = CHACHA_BYTE;
 80093ae:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093b0:	1c5a      	adds	r2, r3, #1
 80093b2:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093b4:	461a      	mov	r2, r3
 80093b6:	68fb      	ldr	r3, [r7, #12]
 80093b8:	4413      	add	r3, r2
 80093ba:	22cc      	movs	r2, #204	@ 0xcc
 80093bc:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256;
 80093be:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093c0:	1c5a      	adds	r2, r3, #1
 80093c2:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093c4:	461a      	mov	r2, r3
 80093c6:	68fb      	ldr	r3, [r7, #12]
 80093c8:	4413      	add	r3, r2
 80093ca:	2213      	movs	r2, #19
 80093cc:	711a      	strb	r2, [r3, #4]
    }
#endif

#ifdef BUILD_TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256
    #ifdef OPENSSL_EXTRA
    if ((tls1_2 && haveRSA) || (tls1_2 && haveECDSAsig)) {
 80093ce:	69fb      	ldr	r3, [r7, #28]
 80093d0:	2b00      	cmp	r3, #0
 80093d2:	d002      	beq.n	80093da <InitSuites+0x378>
 80093d4:	887b      	ldrh	r3, [r7, #2]
 80093d6:	2b00      	cmp	r3, #0
 80093d8:	d105      	bne.n	80093e6 <InitSuites+0x384>
 80093da:	69fb      	ldr	r3, [r7, #28]
 80093dc:	2b00      	cmp	r3, #0
 80093de:	d012      	beq.n	8009406 <InitSuites+0x3a4>
 80093e0:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 80093e2:	2b00      	cmp	r3, #0
 80093e4:	d00f      	beq.n	8009406 <InitSuites+0x3a4>
    #else
    if (tls1_2 && haveRSA) {
    #endif
        suites->suites[idx++] = CHACHA_BYTE;
 80093e6:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093e8:	1c5a      	adds	r2, r3, #1
 80093ea:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093ec:	461a      	mov	r2, r3
 80093ee:	68fb      	ldr	r3, [r7, #12]
 80093f0:	4413      	add	r3, r2
 80093f2:	22cc      	movs	r2, #204	@ 0xcc
 80093f4:	711a      	strb	r2, [r3, #4]
        suites->suites[idx++] = TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256;
 80093f6:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80093f8:	1c5a      	adds	r2, r3, #1
 80093fa:	84fa      	strh	r2, [r7, #38]	@ 0x26
 80093fc:	461a      	mov	r2, r3
 80093fe:	68fb      	ldr	r3, [r7, #12]
 8009400:	4413      	add	r3, r2
 8009402:	2215      	movs	r2, #21
 8009404:	711a      	strb	r2, [r3, #4]
    }
#endif

#endif /* !WOLFSSL_NO_TLS12 */

    suites->suiteSz = idx;
 8009406:	68fb      	ldr	r3, [r7, #12]
 8009408:	8cfa      	ldrh	r2, [r7, #38]	@ 0x26
 800940a:	801a      	strh	r2, [r3, #0]

    if (suites->hashSigAlgoSz == 0) {
 800940c:	68fb      	ldr	r3, [r7, #12]
 800940e:	885b      	ldrh	r3, [r3, #2]
 8009410:	2b00      	cmp	r3, #0
 8009412:	d10e      	bne.n	8009432 <InitSuites+0x3d0>
        InitSuitesHashSigAlgo(suites->hashSigAlgo, SIG_ALL, tls1_2, keySz,
 8009414:	68fb      	ldr	r3, [r7, #12]
 8009416:	f503 7098 	add.w	r0, r3, #304	@ 0x130
 800941a:	68fb      	ldr	r3, [r7, #12]
 800941c:	3302      	adds	r3, #2
 800941e:	9300      	str	r3, [sp, #0]
 8009420:	687b      	ldr	r3, [r7, #4]
 8009422:	69fa      	ldr	r2, [r7, #28]
 8009424:	211f      	movs	r1, #31
 8009426:	f7ff fd8a 	bl	8008f3e <InitSuitesHashSigAlgo>
 800942a:	e002      	b.n	8009432 <InitSuites+0x3d0>
        return;
 800942c:	bf00      	nop
 800942e:	e000      	b.n	8009432 <InitSuites+0x3d0>
        return;      /* trust user settings, don't override */
 8009430:	bf00      	nop
    (void)side;
    (void)haveRSA;    /* some builds won't read */
    (void)haveRSAsig; /* non ecc builds won't read */
    (void)haveAnon;   /* anon ciphers optional */
    (void)haveNull;
}
 8009432:	3728      	adds	r7, #40	@ 0x28
 8009434:	46bd      	mov	sp, r7
 8009436:	bd80      	pop	{r7, pc}

08009438 <InitX509Name>:
#endif /* !WOLFSSL_NO_TLS12 */

#ifndef NO_CERTS

void InitX509Name(WOLFSSL_X509_NAME* name, int dynamicFlag, void* heap)
{
 8009438:	b580      	push	{r7, lr}
 800943a:	b084      	sub	sp, #16
 800943c:	af00      	add	r7, sp, #0
 800943e:	60f8      	str	r0, [r7, #12]
 8009440:	60b9      	str	r1, [r7, #8]
 8009442:	607a      	str	r2, [r7, #4]
    (void)dynamicFlag;

    if (name != NULL) {
 8009444:	68fb      	ldr	r3, [r7, #12]
 8009446:	2b00      	cmp	r3, #0
 8009448:	d011      	beq.n	800946e <InitX509Name+0x36>
        XMEMSET(name, 0, sizeof(WOLFSSL_X509_NAME));
 800944a:	f240 520c 	movw	r2, #1292	@ 0x50c
 800944e:	2100      	movs	r1, #0
 8009450:	68f8      	ldr	r0, [r7, #12]
 8009452:	f01f f83d 	bl	80284d0 <memset>
        name->name        = name->staticName;
 8009456:	68fb      	ldr	r3, [r7, #12]
 8009458:	f103 020c 	add.w	r2, r3, #12
 800945c:	68fb      	ldr	r3, [r7, #12]
 800945e:	601a      	str	r2, [r3, #0]
        name->heap = heap;
 8009460:	68fb      	ldr	r3, [r7, #12]
 8009462:	687a      	ldr	r2, [r7, #4]
 8009464:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
        name->dynamicName = 0;
 8009468:	68fb      	ldr	r3, [r7, #12]
 800946a:	2200      	movs	r2, #0
 800946c:	605a      	str	r2, [r3, #4]
    }
}
 800946e:	bf00      	nop
 8009470:	3710      	adds	r7, #16
 8009472:	46bd      	mov	sp, r7
 8009474:	bd80      	pop	{r7, pc}

08009476 <FreeX509Name>:


void FreeX509Name(WOLFSSL_X509_NAME* name)
{
 8009476:	b580      	push	{r7, lr}
 8009478:	b084      	sub	sp, #16
 800947a:	af00      	add	r7, sp, #0
 800947c:	6078      	str	r0, [r7, #4]
    if (name != NULL) {
 800947e:	687b      	ldr	r3, [r7, #4]
 8009480:	2b00      	cmp	r3, #0
 8009482:	d059      	beq.n	8009538 <FreeX509Name+0xc2>
        if (name->dynamicName) {
 8009484:	687b      	ldr	r3, [r7, #4]
 8009486:	685b      	ldr	r3, [r3, #4]
 8009488:	2b00      	cmp	r3, #0
 800948a:	d00b      	beq.n	80094a4 <FreeX509Name+0x2e>
            XFREE(name->name, name->heap, DYNAMIC_TYPE_SUBJECT_CN);
 800948c:	687b      	ldr	r3, [r7, #4]
 800948e:	681b      	ldr	r3, [r3, #0]
 8009490:	60bb      	str	r3, [r7, #8]
 8009492:	68bb      	ldr	r3, [r7, #8]
 8009494:	2b00      	cmp	r3, #0
 8009496:	d002      	beq.n	800949e <FreeX509Name+0x28>
 8009498:	68b8      	ldr	r0, [r7, #8]
 800949a:	f015 fb17 	bl	801eacc <wolfSSL_Free>
            name->name = NULL;
 800949e:	687b      	ldr	r3, [r7, #4]
 80094a0:	2200      	movs	r2, #0
 80094a2:	601a      	str	r2, [r3, #0]
        }
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        {
            int i;
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 80094a4:	2300      	movs	r3, #0
 80094a6:	60fb      	str	r3, [r7, #12]
 80094a8:	e043      	b.n	8009532 <FreeX509Name+0xbc>
                if (name->entry[i].object != NULL)
 80094aa:	6879      	ldr	r1, [r7, #4]
 80094ac:	68fa      	ldr	r2, [r7, #12]
 80094ae:	4613      	mov	r3, r2
 80094b0:	009b      	lsls	r3, r3, #2
 80094b2:	4413      	add	r3, r2
 80094b4:	009b      	lsls	r3, r3, #2
 80094b6:	440b      	add	r3, r1
 80094b8:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 80094bc:	681b      	ldr	r3, [r3, #0]
 80094be:	2b00      	cmp	r3, #0
 80094c0:	d00c      	beq.n	80094dc <FreeX509Name+0x66>
                    wolfSSL_ASN1_OBJECT_free(name->entry[i].object);
 80094c2:	6879      	ldr	r1, [r7, #4]
 80094c4:	68fa      	ldr	r2, [r7, #12]
 80094c6:	4613      	mov	r3, r2
 80094c8:	009b      	lsls	r3, r3, #2
 80094ca:	4413      	add	r3, r2
 80094cc:	009b      	lsls	r3, r3, #2
 80094ce:	440b      	add	r3, r1
 80094d0:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 80094d4:	681b      	ldr	r3, [r3, #0]
 80094d6:	4618      	mov	r0, r3
 80094d8:	f002 fa87 	bl	800b9ea <wolfSSL_ASN1_OBJECT_free>
                if (name->entry[i].value != NULL)
 80094dc:	6879      	ldr	r1, [r7, #4]
 80094de:	68fa      	ldr	r2, [r7, #12]
 80094e0:	4613      	mov	r3, r2
 80094e2:	009b      	lsls	r3, r3, #2
 80094e4:	4413      	add	r3, r2
 80094e6:	009b      	lsls	r3, r3, #2
 80094e8:	440b      	add	r3, r1
 80094ea:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 80094ee:	681b      	ldr	r3, [r3, #0]
 80094f0:	2b00      	cmp	r3, #0
 80094f2:	d00c      	beq.n	800950e <FreeX509Name+0x98>
                    wolfSSL_ASN1_STRING_free(name->entry[i].value);
 80094f4:	6879      	ldr	r1, [r7, #4]
 80094f6:	68fa      	ldr	r2, [r7, #12]
 80094f8:	4613      	mov	r3, r2
 80094fa:	009b      	lsls	r3, r3, #2
 80094fc:	4413      	add	r3, r2
 80094fe:	009b      	lsls	r3, r3, #2
 8009500:	440b      	add	r3, r1
 8009502:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 8009506:	681b      	ldr	r3, [r3, #0]
 8009508:	4618      	mov	r0, r3
 800950a:	f002 facd 	bl	800baa8 <wolfSSL_ASN1_STRING_free>
                XMEMSET(&name->entry[i], 0, sizeof(WOLFSSL_X509_NAME_ENTRY));
 800950e:	68fa      	ldr	r2, [r7, #12]
 8009510:	4613      	mov	r3, r2
 8009512:	009b      	lsls	r3, r3, #2
 8009514:	4413      	add	r3, r2
 8009516:	009b      	lsls	r3, r3, #2
 8009518:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800951c:	687a      	ldr	r2, [r7, #4]
 800951e:	4413      	add	r3, r2
 8009520:	3304      	adds	r3, #4
 8009522:	2214      	movs	r2, #20
 8009524:	2100      	movs	r1, #0
 8009526:	4618      	mov	r0, r3
 8009528:	f01e ffd2 	bl	80284d0 <memset>
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800952c:	68fb      	ldr	r3, [r7, #12]
 800952e:	3301      	adds	r3, #1
 8009530:	60fb      	str	r3, [r7, #12]
 8009532:	68fb      	ldr	r3, [r7, #12]
 8009534:	2b0f      	cmp	r3, #15
 8009536:	ddb8      	ble.n	80094aa <FreeX509Name+0x34>
            wolfSSL_sk_X509_NAME_ENTRY_free(name->entries);
            name->entries = NULL;
        }
#endif
    }
}
 8009538:	bf00      	nop
 800953a:	3710      	adds	r7, #16
 800953c:	46bd      	mov	sp, r7
 800953e:	bd80      	pop	{r7, pc}

08009540 <InitX509>:


/* Initialize wolfSSL X509 type */
void InitX509(WOLFSSL_X509* x509, int dynamicFlag, void* heap)
{
 8009540:	b580      	push	{r7, lr}
 8009542:	b086      	sub	sp, #24
 8009544:	af00      	add	r7, sp, #0
 8009546:	60f8      	str	r0, [r7, #12]
 8009548:	60b9      	str	r1, [r7, #8]
 800954a:	607a      	str	r2, [r7, #4]
    if (x509 == NULL) {
 800954c:	68fb      	ldr	r3, [r7, #12]
 800954e:	2b00      	cmp	r3, #0
 8009550:	d025      	beq.n	800959e <InitX509+0x5e>
        WOLFSSL_MSG("Null parameter passed in!");
        return;
    }

    XMEMSET(x509, 0, sizeof(WOLFSSL_X509));
 8009552:	f640 42d4 	movw	r2, #3284	@ 0xcd4
 8009556:	2100      	movs	r1, #0
 8009558:	68f8      	ldr	r0, [r7, #12]
 800955a:	f01e ffb9 	bl	80284d0 <memset>

    x509->heap = heap;
 800955e:	68fb      	ldr	r3, [r7, #12]
 8009560:	687a      	ldr	r2, [r7, #4]
 8009562:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    InitX509Name(&x509->issuer, 0, heap);
 8009566:	68fb      	ldr	r3, [r7, #12]
 8009568:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800956c:	687a      	ldr	r2, [r7, #4]
 800956e:	2100      	movs	r1, #0
 8009570:	4618      	mov	r0, r3
 8009572:	f7ff ff61 	bl	8009438 <InitX509Name>
    InitX509Name(&x509->subject, 0, heap);
 8009576:	68fb      	ldr	r3, [r7, #12]
 8009578:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800957c:	687a      	ldr	r2, [r7, #4]
 800957e:	2100      	movs	r1, #0
 8009580:	4618      	mov	r0, r3
 8009582:	f7ff ff59 	bl	8009438 <InitX509Name>
    x509->dynamicMemory  = (byte)dynamicFlag;
 8009586:	68bb      	ldr	r3, [r7, #8]
 8009588:	b2da      	uxtb	r2, r3
 800958a:	68fb      	ldr	r3, [r7, #12]
 800958c:	f883 2094 	strb.w	r2, [r3, #148]	@ 0x94
#if defined(OPENSSL_EXTRA_X509_SMALL) || defined(OPENSSL_EXTRA)
    {
        int ret;
        wolfSSL_RefInit(&x509->ref, &ret);
 8009590:	68fb      	ldr	r3, [r7, #12]
 8009592:	2201      	movs	r2, #1
 8009594:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
 8009598:	2300      	movs	r3, #0
 800959a:	617b      	str	r3, [r7, #20]
 800959c:	e000      	b.n	80095a0 <InitX509+0x60>
        return;
 800959e:	bf00      	nop
        (void)ret;
    }
#endif
}
 80095a0:	3718      	adds	r7, #24
 80095a2:	46bd      	mov	sp, r7
 80095a4:	bd80      	pop	{r7, pc}

080095a6 <FreeX509>:


/* Free wolfSSL X509 type */
void FreeX509(WOLFSSL_X509* x509)
{
 80095a6:	b580      	push	{r7, lr}
 80095a8:	b08c      	sub	sp, #48	@ 0x30
 80095aa:	af00      	add	r7, sp, #0
 80095ac:	6078      	str	r0, [r7, #4]
    #if defined(WOLFSSL_CERT_REQ) && defined(OPENSSL_ALL) \
    &&  defined( WOLFSSL_CUSTOM_OID)
    int idx;
    #endif /* WOLFSSL_CERT_REQ && OPENSSL_ALL && WOLFSSL_CUSTOM_OID */
    if (x509 == NULL)
 80095ae:	687b      	ldr	r3, [r7, #4]
 80095b0:	2b00      	cmp	r3, #0
 80095b2:	f000 80dc 	beq.w	800976e <FreeX509+0x1c8>
        return;

    FreeX509Name(&x509->issuer);
 80095b6:	687b      	ldr	r3, [r7, #4]
 80095b8:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 80095bc:	4618      	mov	r0, r3
 80095be:	f7ff ff5a 	bl	8009476 <FreeX509Name>
    FreeX509Name(&x509->subject);
 80095c2:	687b      	ldr	r3, [r7, #4]
 80095c4:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 80095c8:	4618      	mov	r0, r3
 80095ca:	f7ff ff54 	bl	8009476 <FreeX509Name>
    if (x509->pubKey.buffer) {
 80095ce:	687b      	ldr	r3, [r7, #4]
 80095d0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80095d2:	2b00      	cmp	r3, #0
 80095d4:	d00b      	beq.n	80095ee <FreeX509+0x48>
        XFREE(x509->pubKey.buffer, x509->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 80095d6:	687b      	ldr	r3, [r7, #4]
 80095d8:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80095da:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80095dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80095de:	2b00      	cmp	r3, #0
 80095e0:	d002      	beq.n	80095e8 <FreeX509+0x42>
 80095e2:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80095e4:	f015 fa72 	bl	801eacc <wolfSSL_Free>
        x509->pubKey.buffer = NULL;
 80095e8:	687b      	ldr	r3, [r7, #4]
 80095ea:	2200      	movs	r2, #0
 80095ec:	679a      	str	r2, [r3, #120]	@ 0x78
    }
    FreeDer(&x509->derCert);
 80095ee:	687b      	ldr	r3, [r7, #4]
 80095f0:	338c      	adds	r3, #140	@ 0x8c
 80095f2:	4618      	mov	r0, r3
 80095f4:	f00f fcc8 	bl	8018f88 <FreeDer>
    XFREE(x509->sig.buffer, x509->heap, DYNAMIC_TYPE_SIGNATURE);
 80095f8:	687b      	ldr	r3, [r7, #4]
 80095fa:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80095fc:	62bb      	str	r3, [r7, #40]	@ 0x28
 80095fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009600:	2b00      	cmp	r3, #0
 8009602:	d002      	beq.n	800960a <FreeX509+0x64>
 8009604:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8009606:	f015 fa61 	bl	801eacc <wolfSSL_Free>
    x509->sig.buffer = NULL;
 800960a:	687b      	ldr	r3, [r7, #4]
 800960c:	2200      	movs	r2, #0
 800960e:	669a      	str	r2, [r3, #104]	@ 0x68
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        if (x509->authKeyIdSrc != NULL) {
 8009610:	687b      	ldr	r3, [r7, #4]
 8009612:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8009616:	2b00      	cmp	r3, #0
 8009618:	d00a      	beq.n	8009630 <FreeX509+0x8a>
            XFREE(x509->authKeyIdSrc, x509->heap, DYNAMIC_TYPE_X509_EXT);
 800961a:	687b      	ldr	r3, [r7, #4]
 800961c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8009620:	623b      	str	r3, [r7, #32]
 8009622:	6a3b      	ldr	r3, [r7, #32]
 8009624:	2b00      	cmp	r3, #0
 8009626:	d00d      	beq.n	8009644 <FreeX509+0x9e>
 8009628:	6a38      	ldr	r0, [r7, #32]
 800962a:	f015 fa4f 	bl	801eacc <wolfSSL_Free>
 800962e:	e009      	b.n	8009644 <FreeX509+0x9e>
        }
        else {
            XFREE(x509->authKeyId, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009630:	687b      	ldr	r3, [r7, #4]
 8009632:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8009636:	627b      	str	r3, [r7, #36]	@ 0x24
 8009638:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800963a:	2b00      	cmp	r3, #0
 800963c:	d002      	beq.n	8009644 <FreeX509+0x9e>
 800963e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8009640:	f015 fa44 	bl	801eacc <wolfSSL_Free>
        }
        x509->authKeyIdSrc = NULL;
 8009644:	687b      	ldr	r3, [r7, #4]
 8009646:	2200      	movs	r2, #0
 8009648:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
        x509->authKeyId = NULL;
 800964c:	687b      	ldr	r3, [r7, #4]
 800964e:	2200      	movs	r2, #0
 8009650:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
        XFREE(x509->subjKeyId, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009654:	687b      	ldr	r3, [r7, #4]
 8009656:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800965a:	61fb      	str	r3, [r7, #28]
 800965c:	69fb      	ldr	r3, [r7, #28]
 800965e:	2b00      	cmp	r3, #0
 8009660:	d002      	beq.n	8009668 <FreeX509+0xc2>
 8009662:	69f8      	ldr	r0, [r7, #28]
 8009664:	f015 fa32 	bl	801eacc <wolfSSL_Free>
        x509->subjKeyId = NULL;
 8009668:	687b      	ldr	r3, [r7, #4]
 800966a:	2200      	movs	r2, #0
 800966c:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
        wolfSSL_ASN1_STRING_free(x509->subjKeyIdStr);
 8009670:	687b      	ldr	r3, [r7, #4]
 8009672:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8009676:	4618      	mov	r0, r3
 8009678:	f002 fa16 	bl	800baa8 <wolfSSL_ASN1_STRING_free>
        x509->subjKeyIdStr = NULL;
 800967c:	687b      	ldr	r3, [r7, #4]
 800967e:	2200      	movs	r2, #0
 8009680:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
        XFREE(x509->authInfo, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009684:	687b      	ldr	r3, [r7, #4]
 8009686:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 800968a:	61bb      	str	r3, [r7, #24]
 800968c:	69bb      	ldr	r3, [r7, #24]
 800968e:	2b00      	cmp	r3, #0
 8009690:	d002      	beq.n	8009698 <FreeX509+0xf2>
 8009692:	69b8      	ldr	r0, [r7, #24]
 8009694:	f015 fa1a 	bl	801eacc <wolfSSL_Free>
        x509->authInfo = NULL;
 8009698:	687b      	ldr	r3, [r7, #4]
 800969a:	2200      	movs	r2, #0
 800969c:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8
        XFREE(x509->rawCRLInfo, x509->heap, DYNAMIC_TYPE_X509_EXT);
 80096a0:	687b      	ldr	r3, [r7, #4]
 80096a2:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 80096a6:	617b      	str	r3, [r7, #20]
 80096a8:	697b      	ldr	r3, [r7, #20]
 80096aa:	2b00      	cmp	r3, #0
 80096ac:	d002      	beq.n	80096b4 <FreeX509+0x10e>
 80096ae:	6978      	ldr	r0, [r7, #20]
 80096b0:	f015 fa0c 	bl	801eacc <wolfSSL_Free>
        x509->rawCRLInfo = NULL;
 80096b4:	687b      	ldr	r3, [r7, #4]
 80096b6:	2200      	movs	r2, #0
 80096b8:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
        XFREE(x509->CRLInfo, x509->heap, DYNAMIC_TYPE_X509_EXT);
 80096bc:	687b      	ldr	r3, [r7, #4]
 80096be:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 80096c2:	613b      	str	r3, [r7, #16]
 80096c4:	693b      	ldr	r3, [r7, #16]
 80096c6:	2b00      	cmp	r3, #0
 80096c8:	d002      	beq.n	80096d0 <FreeX509+0x12a>
 80096ca:	6938      	ldr	r0, [r7, #16]
 80096cc:	f015 f9fe 	bl	801eacc <wolfSSL_Free>
        x509->CRLInfo = NULL;
 80096d0:	687b      	ldr	r3, [r7, #4]
 80096d2:	2200      	movs	r2, #0
 80096d4:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4
        #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA) || \
            defined(WOLFSSL_QT)
        XFREE(x509->authInfoCaIssuer, x509->heap, DYNAMIC_TYPE_X509_EXT);
 80096d8:	687b      	ldr	r3, [r7, #4]
 80096da:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 80096de:	60fb      	str	r3, [r7, #12]
 80096e0:	68fb      	ldr	r3, [r7, #12]
 80096e2:	2b00      	cmp	r3, #0
 80096e4:	d002      	beq.n	80096ec <FreeX509+0x146>
 80096e6:	68f8      	ldr	r0, [r7, #12]
 80096e8:	f015 f9f0 	bl	801eacc <wolfSSL_Free>
        if (x509->ext_sk != NULL) {
 80096ec:	687b      	ldr	r3, [r7, #4]
 80096ee:	689b      	ldr	r3, [r3, #8]
 80096f0:	2b00      	cmp	r3, #0
 80096f2:	d005      	beq.n	8009700 <FreeX509+0x15a>
            wolfSSL_sk_X509_EXTENSION_pop_free(x509->ext_sk, NULL);
 80096f4:	687b      	ldr	r3, [r7, #4]
 80096f6:	689b      	ldr	r3, [r3, #8]
 80096f8:	2100      	movs	r1, #0
 80096fa:	4618      	mov	r0, r3
 80096fc:	f004 ff1e 	bl	800e53c <wolfSSL_sk_X509_EXTENSION_pop_free>
        }
        if (x509->ext_sk_full != NULL) {
 8009700:	687b      	ldr	r3, [r7, #4]
 8009702:	68db      	ldr	r3, [r3, #12]
 8009704:	2b00      	cmp	r3, #0
 8009706:	d005      	beq.n	8009714 <FreeX509+0x16e>
            wolfSSL_sk_X509_EXTENSION_pop_free(x509->ext_sk_full, NULL);
 8009708:	687b      	ldr	r3, [r7, #4]
 800970a:	68db      	ldr	r3, [r3, #12]
 800970c:	2100      	movs	r1, #0
 800970e:	4618      	mov	r0, r3
 8009710:	f004 ff14 	bl	800e53c <wolfSSL_sk_X509_EXTENSION_pop_free>
        }
        #endif /* OPENSSL_ALL || WOLFSSL_QT */
        #ifdef OPENSSL_EXTRA
        /* Free serialNumber that was set by wolfSSL_X509_get_serialNumber */
        if (x509->serialNumber != NULL) {
 8009714:	687b      	ldr	r3, [r7, #4]
 8009716:	695b      	ldr	r3, [r3, #20]
 8009718:	2b00      	cmp	r3, #0
 800971a:	d004      	beq.n	8009726 <FreeX509+0x180>
            wolfSSL_ASN1_INTEGER_free(x509->serialNumber);
 800971c:	687b      	ldr	r3, [r7, #4]
 800971e:	695b      	ldr	r3, [r3, #20]
 8009720:	4618      	mov	r0, r3
 8009722:	f002 f91b 	bl	800b95c <wolfSSL_ASN1_INTEGER_free>
        }
        #endif
        if (x509->extKeyUsageSrc != NULL) {
 8009726:	687b      	ldr	r3, [r7, #4]
 8009728:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 800972c:	2b00      	cmp	r3, #0
 800972e:	d00d      	beq.n	800974c <FreeX509+0x1a6>
            XFREE(x509->extKeyUsageSrc, x509->heap, DYNAMIC_TYPE_X509_EXT);
 8009730:	687b      	ldr	r3, [r7, #4]
 8009732:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8009736:	60bb      	str	r3, [r7, #8]
 8009738:	68bb      	ldr	r3, [r7, #8]
 800973a:	2b00      	cmp	r3, #0
 800973c:	d002      	beq.n	8009744 <FreeX509+0x19e>
 800973e:	68b8      	ldr	r0, [r7, #8]
 8009740:	f015 f9c4 	bl	801eacc <wolfSSL_Free>
            x509->extKeyUsageSrc= NULL;
 8009744:	687b      	ldr	r3, [r7, #4]
 8009746:	2200      	movs	r2, #0
 8009748:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
            XFREE(x509->custom_exts[idx].val, x509->heap,
                  DYNAMIC_TYPE_X509_EXT);
        }
    #endif /* WOLFSSL_CUSTOM_OID */
    #endif /* WOLFSSL_CERT_REQ && OPENSSL_ALL */
    if (x509->altNames) {
 800974c:	687b      	ldr	r3, [r7, #4]
 800974e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8009750:	2b00      	cmp	r3, #0
 8009752:	d00d      	beq.n	8009770 <FreeX509+0x1ca>
        FreeAltNames(x509->altNames, x509->heap);
 8009754:	687b      	ldr	r3, [r7, #4]
 8009756:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 8009758:	687b      	ldr	r3, [r7, #4]
 800975a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800975e:	4619      	mov	r1, r3
 8009760:	4610      	mov	r0, r2
 8009762:	f00b fd10 	bl	8015186 <FreeAltNames>
        x509->altNames = NULL;
 8009766:	687b      	ldr	r3, [r7, #4]
 8009768:	2200      	movs	r2, #0
 800976a:	675a      	str	r2, [r3, #116]	@ 0x74
 800976c:	e000      	b.n	8009770 <FreeX509+0x1ca>
        return;
 800976e:	bf00      	nop
    #endif /* WOLFSSL_DUAL_ALG_CERTS */

    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_ALL)
        wolfSSL_RefFree(&x509->ref);
    #endif
}
 8009770:	3730      	adds	r7, #48	@ 0x30
 8009772:	46bd      	mov	sp, r7
 8009774:	bd80      	pop	{r7, pc}

08009776 <FreeHandshakeHashes>:

    return ret;
}

void FreeHandshakeHashes(WOLFSSL* ssl)
{
 8009776:	b580      	push	{r7, lr}
 8009778:	b084      	sub	sp, #16
 800977a:	af00      	add	r7, sp, #0
 800977c:	6078      	str	r0, [r7, #4]
    if (ssl->hsHashes) {
 800977e:	687b      	ldr	r3, [r7, #4]
 8009780:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8009782:	2b00      	cmp	r3, #0
 8009784:	d011      	beq.n	80097aa <FreeHandshakeHashes+0x34>
    #if !defined(NO_SHA) && (!defined(NO_OLD_TLS) || \
                              defined(WOLFSSL_ALLOW_TLS_SHA1))
        wc_ShaFree(&ssl->hsHashes->hashSha);
    #endif
    #ifndef NO_SHA256
        wc_Sha256Free(&ssl->hsHashes->hashSha256);
 8009786:	687b      	ldr	r3, [r7, #4]
 8009788:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800978a:	3340      	adds	r3, #64	@ 0x40
 800978c:	4618      	mov	r0, r3
 800978e:	f018 fc42 	bl	8022016 <wc_Sha256Free>
            XFREE(ssl->hsHashes->messages, ssl->heap, DYNAMIC_TYPE_HASHES);
            ssl->hsHashes->messages = NULL;
         }
    #endif

        XFREE(ssl->hsHashes, ssl->heap, DYNAMIC_TYPE_HASHES);
 8009792:	687b      	ldr	r3, [r7, #4]
 8009794:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8009796:	60fb      	str	r3, [r7, #12]
 8009798:	68fb      	ldr	r3, [r7, #12]
 800979a:	2b00      	cmp	r3, #0
 800979c:	d002      	beq.n	80097a4 <FreeHandshakeHashes+0x2e>
 800979e:	68f8      	ldr	r0, [r7, #12]
 80097a0:	f015 f994 	bl	801eacc <wolfSSL_Free>
        ssl->hsHashes = NULL;
 80097a4:	687b      	ldr	r3, [r7, #4]
 80097a6:	2200      	movs	r2, #0
 80097a8:	675a      	str	r2, [r3, #116]	@ 0x74
    }
}
 80097aa:	bf00      	nop
 80097ac:	3710      	adds	r7, #16
 80097ae:	46bd      	mov	sp, r7
 80097b0:	bd80      	pop	{r7, pc}

080097b2 <FreeArrays>:
}


/* free use of temporary arrays */
void FreeArrays(WOLFSSL* ssl, int keep)
{
 80097b2:	b580      	push	{r7, lr}
 80097b4:	b086      	sub	sp, #24
 80097b6:	af00      	add	r7, sp, #0
 80097b8:	6078      	str	r0, [r7, #4]
 80097ba:	6039      	str	r1, [r7, #0]
    if (ssl->arrays) {
 80097bc:	687b      	ldr	r3, [r7, #4]
 80097be:	691b      	ldr	r3, [r3, #16]
 80097c0:	2b00      	cmp	r3, #0
 80097c2:	d052      	beq.n	800986a <FreeArrays+0xb8>
        if (keep && !IsAtLeastTLSv1_3(ssl->version)) {
 80097c4:	683b      	ldr	r3, [r7, #0]
 80097c6:	2b00      	cmp	r3, #0
 80097c8:	d020      	beq.n	800980c <FreeArrays+0x5a>
 80097ca:	687b      	ldr	r3, [r7, #4]
 80097cc:	f8b3 21da 	ldrh.w	r2, [r3, #474]	@ 0x1da
 80097d0:	2300      	movs	r3, #0
 80097d2:	f362 030f 	bfi	r3, r2, #0, #16
 80097d6:	4618      	mov	r0, r3
 80097d8:	f7ff f89e 	bl	8008918 <IsAtLeastTLSv1_3>
 80097dc:	4603      	mov	r3, r0
 80097de:	2b00      	cmp	r3, #0
 80097e0:	d114      	bne.n	800980c <FreeArrays+0x5a>
            /* keeps session id for user retrieval */
            XMEMCPY(ssl->session->sessionID, ssl->arrays->sessionID, ID_LEN);
 80097e2:	687b      	ldr	r3, [r7, #4]
 80097e4:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 80097e8:	f103 0040 	add.w	r0, r3, #64	@ 0x40
 80097ec:	687b      	ldr	r3, [r7, #4]
 80097ee:	691b      	ldr	r3, [r3, #16]
 80097f0:	3354      	adds	r3, #84	@ 0x54
 80097f2:	2220      	movs	r2, #32
 80097f4:	4619      	mov	r1, r3
 80097f6:	f01e fed5 	bl	80285a4 <memcpy>
            ssl->session->sessionIDSz = ssl->arrays->sessionIDSz;
 80097fa:	687b      	ldr	r3, [r7, #4]
 80097fc:	691a      	ldr	r2, [r3, #16]
 80097fe:	687b      	ldr	r3, [r7, #4]
 8009800:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 8009804:	f892 2074 	ldrb.w	r2, [r2, #116]	@ 0x74
 8009808:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
        }
        if (ssl->arrays->preMasterSecret) {
 800980c:	687b      	ldr	r3, [r7, #4]
 800980e:	691b      	ldr	r3, [r3, #16]
 8009810:	685b      	ldr	r3, [r3, #4]
 8009812:	2b00      	cmp	r3, #0
 8009814:	d015      	beq.n	8009842 <FreeArrays+0x90>
            ForceZero(ssl->arrays->preMasterSecret, ENCRYPT_LEN);
 8009816:	687b      	ldr	r3, [r7, #4]
 8009818:	691b      	ldr	r3, [r3, #16]
 800981a:	685b      	ldr	r3, [r3, #4]
 800981c:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8009820:	4618      	mov	r0, r3
 8009822:	f7ff f850 	bl	80088c6 <ForceZero>
            XFREE(ssl->arrays->preMasterSecret, ssl->heap, DYNAMIC_TYPE_SECRET);
 8009826:	687b      	ldr	r3, [r7, #4]
 8009828:	691b      	ldr	r3, [r3, #16]
 800982a:	685b      	ldr	r3, [r3, #4]
 800982c:	617b      	str	r3, [r7, #20]
 800982e:	697b      	ldr	r3, [r7, #20]
 8009830:	2b00      	cmp	r3, #0
 8009832:	d002      	beq.n	800983a <FreeArrays+0x88>
 8009834:	6978      	ldr	r0, [r7, #20]
 8009836:	f015 f949 	bl	801eacc <wolfSSL_Free>
            ssl->arrays->preMasterSecret = NULL;
 800983a:	687b      	ldr	r3, [r7, #4]
 800983c:	691b      	ldr	r3, [r3, #16]
 800983e:	2200      	movs	r2, #0
 8009840:	605a      	str	r2, [r3, #4]
        }
        XFREE(ssl->arrays->pendingMsg, ssl->heap, DYNAMIC_TYPE_ARRAYS);
 8009842:	687b      	ldr	r3, [r7, #4]
 8009844:	691b      	ldr	r3, [r3, #16]
 8009846:	681b      	ldr	r3, [r3, #0]
 8009848:	613b      	str	r3, [r7, #16]
 800984a:	693b      	ldr	r3, [r7, #16]
 800984c:	2b00      	cmp	r3, #0
 800984e:	d002      	beq.n	8009856 <FreeArrays+0xa4>
 8009850:	6938      	ldr	r0, [r7, #16]
 8009852:	f015 f93b 	bl	801eacc <wolfSSL_Free>
        ssl->arrays->pendingMsg = NULL;
 8009856:	687b      	ldr	r3, [r7, #4]
 8009858:	691b      	ldr	r3, [r3, #16]
 800985a:	2200      	movs	r2, #0
 800985c:	601a      	str	r2, [r3, #0]
        ForceZero(ssl->arrays, sizeof(Arrays)); /* clear arrays struct */
 800985e:	687b      	ldr	r3, [r7, #4]
 8009860:	691b      	ldr	r3, [r3, #16]
 8009862:	21d8      	movs	r1, #216	@ 0xd8
 8009864:	4618      	mov	r0, r3
 8009866:	f7ff f82e 	bl	80088c6 <ForceZero>
    }
    XFREE(ssl->arrays, ssl->heap, DYNAMIC_TYPE_ARRAYS);
 800986a:	687b      	ldr	r3, [r7, #4]
 800986c:	691b      	ldr	r3, [r3, #16]
 800986e:	60fb      	str	r3, [r7, #12]
 8009870:	68fb      	ldr	r3, [r7, #12]
 8009872:	2b00      	cmp	r3, #0
 8009874:	d002      	beq.n	800987c <FreeArrays+0xca>
 8009876:	68f8      	ldr	r0, [r7, #12]
 8009878:	f015 f928 	bl	801eacc <wolfSSL_Free>
    ssl->arrays = NULL;
 800987c:	687b      	ldr	r3, [r7, #4]
 800987e:	2200      	movs	r2, #0
 8009880:	611a      	str	r2, [r3, #16]
}
 8009882:	bf00      	nop
 8009884:	3718      	adds	r7, #24
 8009886:	46bd      	mov	sp, r7
 8009888:	bd80      	pop	{r7, pc}

0800988a <FreeKey>:

void FreeKey(WOLFSSL* ssl, int type, void** pKey)
{
 800988a:	b580      	push	{r7, lr}
 800988c:	b086      	sub	sp, #24
 800988e:	af00      	add	r7, sp, #0
 8009890:	60f8      	str	r0, [r7, #12]
 8009892:	60b9      	str	r1, [r7, #8]
 8009894:	607a      	str	r2, [r7, #4]
    if (ssl && pKey && *pKey) {
 8009896:	68fb      	ldr	r3, [r7, #12]
 8009898:	2b00      	cmp	r3, #0
 800989a:	d032      	beq.n	8009902 <FreeKey+0x78>
 800989c:	687b      	ldr	r3, [r7, #4]
 800989e:	2b00      	cmp	r3, #0
 80098a0:	d02f      	beq.n	8009902 <FreeKey+0x78>
 80098a2:	687b      	ldr	r3, [r7, #4]
 80098a4:	681b      	ldr	r3, [r3, #0]
 80098a6:	2b00      	cmp	r3, #0
 80098a8:	d02b      	beq.n	8009902 <FreeKey+0x78>
        switch (type) {
 80098aa:	68bb      	ldr	r3, [r7, #8]
 80098ac:	2b25      	cmp	r3, #37	@ 0x25
 80098ae:	d00f      	beq.n	80098d0 <FreeKey+0x46>
 80098b0:	68bb      	ldr	r3, [r7, #8]
 80098b2:	2b25      	cmp	r3, #37	@ 0x25
 80098b4:	dc18      	bgt.n	80098e8 <FreeKey+0x5e>
 80098b6:	68bb      	ldr	r3, [r7, #8]
 80098b8:	2b0a      	cmp	r3, #10
 80098ba:	d003      	beq.n	80098c4 <FreeKey+0x3a>
 80098bc:	68bb      	ldr	r3, [r7, #8]
 80098be:	2b0f      	cmp	r3, #15
 80098c0:	d00c      	beq.n	80098dc <FreeKey+0x52>
            case DYNAMIC_TYPE_DH:
                wc_FreeDhKey((DhKey*)*pKey);
                break;
        #endif /* !NO_DH */
            default:
                break;
 80098c2:	e011      	b.n	80098e8 <FreeKey+0x5e>
                wc_FreeRsaKey((RsaKey*)*pKey);
 80098c4:	687b      	ldr	r3, [r7, #4]
 80098c6:	681b      	ldr	r3, [r3, #0]
 80098c8:	4618      	mov	r0, r3
 80098ca:	f016 fb67 	bl	801ff9c <wc_FreeRsaKey>
                break;
 80098ce:	e00c      	b.n	80098ea <FreeKey+0x60>
                wc_ecc_free((ecc_key*)*pKey);
 80098d0:	687b      	ldr	r3, [r7, #4]
 80098d2:	681b      	ldr	r3, [r3, #0]
 80098d4:	4618      	mov	r0, r3
 80098d6:	f013 fb26 	bl	801cf26 <wc_ecc_free>
                break;
 80098da:	e006      	b.n	80098ea <FreeKey+0x60>
                wc_FreeDhKey((DhKey*)*pKey);
 80098dc:	687b      	ldr	r3, [r7, #4]
 80098de:	681b      	ldr	r3, [r3, #0]
 80098e0:	4618      	mov	r0, r3
 80098e2:	f010 ff35 	bl	801a750 <wc_FreeDhKey>
                break;
 80098e6:	e000      	b.n	80098ea <FreeKey+0x60>
                break;
 80098e8:	bf00      	nop
        }
        XFREE(*pKey, ssl->heap, type);
 80098ea:	687b      	ldr	r3, [r7, #4]
 80098ec:	681b      	ldr	r3, [r3, #0]
 80098ee:	617b      	str	r3, [r7, #20]
 80098f0:	697b      	ldr	r3, [r7, #20]
 80098f2:	2b00      	cmp	r3, #0
 80098f4:	d002      	beq.n	80098fc <FreeKey+0x72>
 80098f6:	6978      	ldr	r0, [r7, #20]
 80098f8:	f015 f8e8 	bl	801eacc <wolfSSL_Free>

        /* Reset pointer */
        *pKey = NULL;
 80098fc:	687b      	ldr	r3, [r7, #4]
 80098fe:	2200      	movs	r2, #0
 8009900:	601a      	str	r2, [r3, #0]
    }
}
 8009902:	bf00      	nop
 8009904:	3718      	adds	r7, #24
 8009906:	46bd      	mov	sp, r7
 8009908:	bd80      	pop	{r7, pc}

0800990a <FreeAsyncCtx>:
}
#endif

#ifdef WOLFSSL_ASYNC_IO
void FreeAsyncCtx(WOLFSSL* ssl, byte freeAsync)
{
 800990a:	b580      	push	{r7, lr}
 800990c:	b084      	sub	sp, #16
 800990e:	af00      	add	r7, sp, #0
 8009910:	6078      	str	r0, [r7, #4]
 8009912:	460b      	mov	r3, r1
 8009914:	70fb      	strb	r3, [r7, #3]
    if (ssl->async != NULL) {
 8009916:	687b      	ldr	r3, [r7, #4]
 8009918:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800991c:	2b00      	cmp	r3, #0
 800991e:	d026      	beq.n	800996e <FreeAsyncCtx+0x64>
        if (ssl->async->freeArgs != NULL) {
 8009920:	687b      	ldr	r3, [r7, #4]
 8009922:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009926:	681b      	ldr	r3, [r3, #0]
 8009928:	2b00      	cmp	r3, #0
 800992a:	d00f      	beq.n	800994c <FreeAsyncCtx+0x42>
            ssl->async->freeArgs(ssl, ssl->async->args);
 800992c:	687b      	ldr	r3, [r7, #4]
 800992e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009932:	681b      	ldr	r3, [r3, #0]
 8009934:	687a      	ldr	r2, [r7, #4]
 8009936:	f8d2 20a4 	ldr.w	r2, [r2, #164]	@ 0xa4
 800993a:	3204      	adds	r2, #4
 800993c:	4611      	mov	r1, r2
 800993e:	6878      	ldr	r0, [r7, #4]
 8009940:	4798      	blx	r3
            ssl->async->freeArgs = NULL;
 8009942:	687b      	ldr	r3, [r7, #4]
 8009944:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009948:	2200      	movs	r2, #0
 800994a:	601a      	str	r2, [r3, #0]
        if (ssl->options.buildArgsSet) {
            FreeBuildMsgArgs(ssl, &ssl->async->buildArgs);
            ssl->options.buildArgsSet = 0;
        }
#endif
        if (freeAsync) {
 800994c:	78fb      	ldrb	r3, [r7, #3]
 800994e:	2b00      	cmp	r3, #0
 8009950:	d00d      	beq.n	800996e <FreeAsyncCtx+0x64>
            XFREE(ssl->async, ssl->heap, DYNAMIC_TYPE_ASYNC);
 8009952:	687b      	ldr	r3, [r7, #4]
 8009954:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009958:	60fb      	str	r3, [r7, #12]
 800995a:	68fb      	ldr	r3, [r7, #12]
 800995c:	2b00      	cmp	r3, #0
 800995e:	d002      	beq.n	8009966 <FreeAsyncCtx+0x5c>
 8009960:	68f8      	ldr	r0, [r7, #12]
 8009962:	f015 f8b3 	bl	801eacc <wolfSSL_Free>
            ssl->async = NULL;
 8009966:	687b      	ldr	r3, [r7, #4]
 8009968:	2200      	movs	r2, #0
 800996a:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
        }
    }
}
 800996e:	bf00      	nop
 8009970:	3710      	adds	r7, #16
 8009972:	46bd      	mov	sp, r7
 8009974:	bd80      	pop	{r7, pc}

08009976 <FreeKeyExchange>:
#endif

void FreeKeyExchange(WOLFSSL* ssl)
{
 8009976:	b580      	push	{r7, lr}
 8009978:	b084      	sub	sp, #16
 800997a:	af00      	add	r7, sp, #0
 800997c:	6078      	str	r0, [r7, #4]
    /* Cleanup signature buffer */
    if (ssl->buffers.sig.buffer) {
 800997e:	687b      	ldr	r3, [r7, #4]
 8009980:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
 8009984:	2b00      	cmp	r3, #0
 8009986:	d011      	beq.n	80099ac <FreeKeyExchange+0x36>
        XFREE(ssl->buffers.sig.buffer, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
 8009988:	687b      	ldr	r3, [r7, #4]
 800998a:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
 800998e:	60fb      	str	r3, [r7, #12]
 8009990:	68fb      	ldr	r3, [r7, #12]
 8009992:	2b00      	cmp	r3, #0
 8009994:	d002      	beq.n	800999c <FreeKeyExchange+0x26>
 8009996:	68f8      	ldr	r0, [r7, #12]
 8009998:	f015 f898 	bl	801eacc <wolfSSL_Free>
        ssl->buffers.sig.buffer = NULL;
 800999c:	687b      	ldr	r3, [r7, #4]
 800999e:	2200      	movs	r2, #0
 80099a0:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
        ssl->buffers.sig.length = 0;
 80099a4:	687b      	ldr	r3, [r7, #4]
 80099a6:	2200      	movs	r2, #0
 80099a8:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130
    }

    /* Cleanup digest buffer */
    if (ssl->buffers.digest.buffer) {
 80099ac:	687b      	ldr	r3, [r7, #4]
 80099ae:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
 80099b2:	2b00      	cmp	r3, #0
 80099b4:	d020      	beq.n	80099f8 <FreeKeyExchange+0x82>
        /* Only free if digest buffer was not set using SetDigest */
        if (!ssl->options.dontFreeDigest) {
 80099b6:	687b      	ldr	r3, [r7, #4]
 80099b8:	f893 32d5 	ldrb.w	r3, [r3, #725]	@ 0x2d5
 80099bc:	f003 0310 	and.w	r3, r3, #16
 80099c0:	b2db      	uxtb	r3, r3
 80099c2:	2b00      	cmp	r3, #0
 80099c4:	d109      	bne.n	80099da <FreeKeyExchange+0x64>
            XFREE(ssl->buffers.digest.buffer, ssl->heap, DYNAMIC_TYPE_DIGEST);
 80099c6:	687b      	ldr	r3, [r7, #4]
 80099c8:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
 80099cc:	60bb      	str	r3, [r7, #8]
 80099ce:	68bb      	ldr	r3, [r7, #8]
 80099d0:	2b00      	cmp	r3, #0
 80099d2:	d002      	beq.n	80099da <FreeKeyExchange+0x64>
 80099d4:	68b8      	ldr	r0, [r7, #8]
 80099d6:	f015 f879 	bl	801eacc <wolfSSL_Free>
        }
        ssl->buffers.digest.buffer = NULL;
 80099da:	687b      	ldr	r3, [r7, #4]
 80099dc:	2200      	movs	r2, #0
 80099de:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
        ssl->buffers.digest.length = 0;
 80099e2:	687b      	ldr	r3, [r7, #4]
 80099e4:	2200      	movs	r2, #0
 80099e6:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
        ssl->options.dontFreeDigest = 0;
 80099ea:	687a      	ldr	r2, [r7, #4]
 80099ec:	f892 32d5 	ldrb.w	r3, [r2, #725]	@ 0x2d5
 80099f0:	f023 0310 	bic.w	r3, r3, #16
 80099f4:	f882 32d5 	strb.w	r3, [r2, #725]	@ 0x2d5
    }

    /* Free handshake key */
    FreeKey(ssl, (int)ssl->hsType, &ssl->hsKey);
 80099f8:	687b      	ldr	r3, [r7, #4]
 80099fa:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 80099fe:	4619      	mov	r1, r3
 8009a00:	687b      	ldr	r3, [r7, #4]
 8009a02:	33a8      	adds	r3, #168	@ 0xa8
 8009a04:	461a      	mov	r2, r3
 8009a06:	6878      	ldr	r0, [r7, #4]
 8009a08:	f7ff ff3f 	bl	800988a <FreeKey>
    FreeKey(ssl, ssl->hsAltType, &ssl->hsAltKey);
#endif /* WOLFSSL_DUAL_ALG_CERTS */

#ifndef NO_DH
    /* Free temp DH key */
    FreeKey(ssl, DYNAMIC_TYPE_DH, (void**)&ssl->buffers.serverDH_Key);
 8009a0c:	687b      	ldr	r3, [r7, #4]
 8009a0e:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8009a12:	461a      	mov	r2, r3
 8009a14:	210f      	movs	r1, #15
 8009a16:	6878      	ldr	r0, [r7, #4]
 8009a18:	f7ff ff37 	bl	800988a <FreeKey>
#endif
}
 8009a1c:	bf00      	nop
 8009a1e:	3710      	adds	r7, #16
 8009a20:	46bd      	mov	sp, r7
 8009a22:	bd80      	pop	{r7, pc}

08009a24 <FreeSuites>:


/* Free up all memory used by Suites structure from WOLFSSL */
void FreeSuites(WOLFSSL* ssl)
{
 8009a24:	b580      	push	{r7, lr}
 8009a26:	b084      	sub	sp, #16
 8009a28:	af00      	add	r7, sp, #0
 8009a2a:	6078      	str	r0, [r7, #4]
         * isn't allocated separately. */
        wolfSSL_sk_SSL_CIPHER_free(ssl->suitesStack);
        ssl->suitesStack = NULL;
    }
#endif
    XFREE(ssl->suites, ssl->heap, DYNAMIC_TYPE_SUITES);
 8009a2c:	687b      	ldr	r3, [r7, #4]
 8009a2e:	685b      	ldr	r3, [r3, #4]
 8009a30:	60fb      	str	r3, [r7, #12]
 8009a32:	68fb      	ldr	r3, [r7, #12]
 8009a34:	2b00      	cmp	r3, #0
 8009a36:	d002      	beq.n	8009a3e <FreeSuites+0x1a>
 8009a38:	68f8      	ldr	r0, [r7, #12]
 8009a3a:	f015 f847 	bl	801eacc <wolfSSL_Free>
    ssl->suites = NULL;
 8009a3e:	687b      	ldr	r3, [r7, #4]
 8009a40:	2200      	movs	r2, #0
 8009a42:	605a      	str	r2, [r3, #4]
}
 8009a44:	bf00      	nop
 8009a46:	3710      	adds	r7, #16
 8009a48:	46bd      	mov	sp, r7
 8009a4a:	bd80      	pop	{r7, pc}

08009a4c <wolfSSL_ResourceFree>:


/* In case holding SSL object in array and don't want to free actual ssl */
void wolfSSL_ResourceFree(WOLFSSL* ssl)
{
 8009a4c:	b580      	push	{r7, lr}
 8009a4e:	b08a      	sub	sp, #40	@ 0x28
 8009a50:	af00      	add	r7, sp, #0
 8009a52:	6078      	str	r0, [r7, #4]

#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
    wolfSSL_CRYPTO_cleanup_ex_data(&ssl->ex_data);
#endif

    FreeCiphers(ssl);
 8009a54:	6878      	ldr	r0, [r7, #4]
 8009a56:	f7ff f9d4 	bl	8008e02 <FreeCiphers>
    FreeArrays(ssl, 0);
 8009a5a:	2100      	movs	r1, #0
 8009a5c:	6878      	ldr	r0, [r7, #4]
 8009a5e:	f7ff fea8 	bl	80097b2 <FreeArrays>
    FreeKeyExchange(ssl);
 8009a62:	6878      	ldr	r0, [r7, #4]
 8009a64:	f7ff ff87 	bl	8009976 <FreeKeyExchange>
#ifdef WOLFSSL_ASYNC_IO
    /* Cleanup async */
    FreeAsyncCtx(ssl, 1);
 8009a68:	2101      	movs	r1, #1
 8009a6a:	6878      	ldr	r0, [r7, #4]
 8009a6c:	f7ff ff4d 	bl	800990a <FreeAsyncCtx>
#endif
    if (ssl->options.weOwnRng) {
 8009a70:	687b      	ldr	r3, [r7, #4]
 8009a72:	f893 32d5 	ldrb.w	r3, [r3, #725]	@ 0x2d5
 8009a76:	f003 0308 	and.w	r3, r3, #8
 8009a7a:	b2db      	uxtb	r3, r3
 8009a7c:	2b00      	cmp	r3, #0
 8009a7e:	d01a      	beq.n	8009ab6 <wolfSSL_ResourceFree+0x6a>
        wc_FreeRng(ssl->rng);
 8009a80:	687b      	ldr	r3, [r7, #4]
 8009a82:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8009a86:	4618      	mov	r0, r3
 8009a88:	f015 fe2c 	bl	801f6e4 <wc_FreeRng>
        XFREE(ssl->rng, ssl->heap, DYNAMIC_TYPE_RNG);
 8009a8c:	687b      	ldr	r3, [r7, #4]
 8009a8e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8009a92:	627b      	str	r3, [r7, #36]	@ 0x24
 8009a94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009a96:	2b00      	cmp	r3, #0
 8009a98:	d002      	beq.n	8009aa0 <wolfSSL_ResourceFree+0x54>
 8009a9a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8009a9c:	f015 f816 	bl	801eacc <wolfSSL_Free>
        ssl->rng = NULL;
 8009aa0:	687b      	ldr	r3, [r7, #4]
 8009aa2:	2200      	movs	r2, #0
 8009aa4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
        ssl->options.weOwnRng = 0;
 8009aa8:	687a      	ldr	r2, [r7, #4]
 8009aaa:	f892 32d5 	ldrb.w	r3, [r2, #725]	@ 0x2d5
 8009aae:	f023 0308 	bic.w	r3, r3, #8
 8009ab2:	f882 32d5 	strb.w	r3, [r2, #725]	@ 0x2d5
    }
    FreeSuites(ssl);
 8009ab6:	6878      	ldr	r0, [r7, #4]
 8009ab8:	f7ff ffb4 	bl	8009a24 <FreeSuites>
    FreeHandshakeHashes(ssl);
 8009abc:	6878      	ldr	r0, [r7, #4]
 8009abe:	f7ff fe5a 	bl	8009776 <FreeHandshakeHashes>
    XFREE(ssl->buffers.domainName.buffer, ssl->heap, DYNAMIC_TYPE_DOMAIN);
 8009ac2:	687b      	ldr	r3, [r7, #4]
 8009ac4:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 8009ac8:	623b      	str	r3, [r7, #32]
 8009aca:	6a3b      	ldr	r3, [r7, #32]
 8009acc:	2b00      	cmp	r3, #0
 8009ace:	d002      	beq.n	8009ad6 <wolfSSL_ResourceFree+0x8a>
 8009ad0:	6a38      	ldr	r0, [r7, #32]
 8009ad2:	f014 fffb 	bl	801eacc <wolfSSL_Free>

    /* clear keys struct after session */
    ForceZero(&ssl->keys, sizeof(Keys));
 8009ad6:	687b      	ldr	r3, [r7, #4]
 8009ad8:	f503 73f8 	add.w	r3, r3, #496	@ 0x1f0
 8009adc:	21dc      	movs	r1, #220	@ 0xdc
 8009ade:	4618      	mov	r0, r3
 8009ae0:	f7fe fef1 	bl	80088c6 <ForceZero>

#ifdef WOLFSSL_TLS13
    ForceZero(&ssl->clientSecret, sizeof(ssl->clientSecret));
 8009ae4:	687b      	ldr	r3, [r7, #4]
 8009ae6:	3314      	adds	r3, #20
 8009ae8:	2130      	movs	r1, #48	@ 0x30
 8009aea:	4618      	mov	r0, r3
 8009aec:	f7fe feeb 	bl	80088c6 <ForceZero>
    ForceZero(&ssl->serverSecret, sizeof(ssl->serverSecret));
 8009af0:	687b      	ldr	r3, [r7, #4]
 8009af2:	3344      	adds	r3, #68	@ 0x44
 8009af4:	2130      	movs	r1, #48	@ 0x30
 8009af6:	4618      	mov	r0, r3
 8009af8:	f7fe fee5 	bl	80088c6 <ForceZero>
    ForceZero(&ssl->serverFinished, TLS_FINISHED_SZ_MAX);
    ssl->serverFinished_len = 0;
    ssl->clientFinished_len = 0;
#endif
#ifndef NO_DH
    if (ssl->buffers.serverDH_Priv.buffer != NULL) {
 8009afc:	687b      	ldr	r3, [r7, #4]
 8009afe:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8009b02:	2b00      	cmp	r3, #0
 8009b04:	d009      	beq.n	8009b1a <wolfSSL_ResourceFree+0xce>
        ForceZero(ssl->buffers.serverDH_Priv.buffer,
 8009b06:	687b      	ldr	r3, [r7, #4]
 8009b08:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
 8009b0c:	687b      	ldr	r3, [r7, #4]
 8009b0e:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8009b12:	4619      	mov	r1, r3
 8009b14:	4610      	mov	r0, r2
 8009b16:	f7fe fed6 	bl	80088c6 <ForceZero>
                                             ssl->buffers.serverDH_Priv.length);
    }
    XFREE(ssl->buffers.serverDH_Priv.buffer, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
 8009b1a:	687b      	ldr	r3, [r7, #4]
 8009b1c:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8009b20:	61fb      	str	r3, [r7, #28]
 8009b22:	69fb      	ldr	r3, [r7, #28]
 8009b24:	2b00      	cmp	r3, #0
 8009b26:	d002      	beq.n	8009b2e <wolfSSL_ResourceFree+0xe2>
 8009b28:	69f8      	ldr	r0, [r7, #28]
 8009b2a:	f014 ffcf 	bl	801eacc <wolfSSL_Free>
    XFREE(ssl->buffers.serverDH_Pub.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8009b2e:	687b      	ldr	r3, [r7, #4]
 8009b30:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
 8009b34:	61bb      	str	r3, [r7, #24]
 8009b36:	69bb      	ldr	r3, [r7, #24]
 8009b38:	2b00      	cmp	r3, #0
 8009b3a:	d002      	beq.n	8009b42 <wolfSSL_ResourceFree+0xf6>
 8009b3c:	69b8      	ldr	r0, [r7, #24]
 8009b3e:	f014 ffc5 	bl	801eacc <wolfSSL_Free>
    /* parameters (p,g) may be owned by ctx */
    if (ssl->buffers.weOwnDH) {
 8009b42:	687b      	ldr	r3, [r7, #4]
 8009b44:	f893 3147 	ldrb.w	r3, [r3, #327]	@ 0x147
 8009b48:	2b00      	cmp	r3, #0
 8009b4a:	d013      	beq.n	8009b74 <wolfSSL_ResourceFree+0x128>
        XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8009b4c:	687b      	ldr	r3, [r7, #4]
 8009b4e:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8009b52:	617b      	str	r3, [r7, #20]
 8009b54:	697b      	ldr	r3, [r7, #20]
 8009b56:	2b00      	cmp	r3, #0
 8009b58:	d002      	beq.n	8009b60 <wolfSSL_ResourceFree+0x114>
 8009b5a:	6978      	ldr	r0, [r7, #20]
 8009b5c:	f014 ffb6 	bl	801eacc <wolfSSL_Free>
        XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8009b60:	687b      	ldr	r3, [r7, #4]
 8009b62:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8009b66:	613b      	str	r3, [r7, #16]
 8009b68:	693b      	ldr	r3, [r7, #16]
 8009b6a:	2b00      	cmp	r3, #0
 8009b6c:	d002      	beq.n	8009b74 <wolfSSL_ResourceFree+0x128>
 8009b6e:	6938      	ldr	r0, [r7, #16]
 8009b70:	f014 ffac 	bl	801eacc <wolfSSL_Free>
    }
#endif /* !NO_DH */
#ifndef NO_CERTS
    ssl->keepCert = 0; /* make sure certificate is free'd */
 8009b74:	687b      	ldr	r3, [r7, #4]
 8009b76:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009b7a:	2200      	movs	r2, #0
 8009b7c:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90
    wolfSSL_UnloadCertsKeys(ssl);
 8009b80:	6878      	ldr	r0, [r7, #4]
 8009b82:	f003 ff73 	bl	800da6c <wolfSSL_UnloadCertsKeys>
#endif
#ifndef NO_RSA
    FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);
 8009b86:	687b      	ldr	r3, [r7, #4]
 8009b88:	f503 7351 	add.w	r3, r3, #836	@ 0x344
 8009b8c:	461a      	mov	r2, r3
 8009b8e:	210a      	movs	r1, #10
 8009b90:	6878      	ldr	r0, [r7, #4]
 8009b92:	f7ff fe7a 	bl	800988a <FreeKey>
    ssl->peerRsaKeyPresent = 0;
 8009b96:	687b      	ldr	r3, [r7, #4]
 8009b98:	2200      	movs	r2, #0
 8009b9a:	f883 2348 	strb.w	r2, [r3, #840]	@ 0x348
#if defined(WOLFSSL_RENESAS_TSIP_TLS) || defined(WOLFSSL_RENESAS_FSPSM_TLS)
    XFREE(ssl->peerSceTsipEncRsaKeyIndex, ssl->heap, DYNAMIC_TYPE_RSA);
    Renesas_cmn_Cleanup(ssl);
#endif
#ifndef NO_TLS
    if (ssl->buffers.inputBuffer.dynamicFlag)
 8009b9e:	687b      	ldr	r3, [r7, #4]
 8009ba0:	f893 30fc 	ldrb.w	r3, [r3, #252]	@ 0xfc
 8009ba4:	2b00      	cmp	r3, #0
 8009ba6:	d003      	beq.n	8009bb0 <wolfSSL_ResourceFree+0x164>
        ShrinkInputBuffer(ssl, FORCED_FREE);
 8009ba8:	2101      	movs	r1, #1
 8009baa:	6878      	ldr	r0, [r7, #4]
 8009bac:	f000 f902 	bl	8009db4 <ShrinkInputBuffer>
    if (ssl->buffers.outputBuffer.dynamicFlag)
 8009bb0:	687b      	ldr	r3, [r7, #4]
 8009bb2:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
 8009bb6:	2b00      	cmp	r3, #0
 8009bb8:	d002      	beq.n	8009bc0 <wolfSSL_ResourceFree+0x174>
        ShrinkOutputBuffer(ssl);
 8009bba:	6878      	ldr	r0, [r7, #4]
 8009bbc:	f000 f8d1 	bl	8009d62 <ShrinkOutputBuffer>
#ifdef OPENSSL_EXTRA
#ifndef NO_BIO
    /* Don't free if there was/is a previous element in the chain.
     * This means that this BIO was part of a chain that will be
     * free'd separately. */
    if (ssl->biord != ssl->biowr)        /* only free write if different */
 8009bc0:	687b      	ldr	r3, [r7, #4]
 8009bc2:	f8d3 232c 	ldr.w	r2, [r3, #812]	@ 0x32c
 8009bc6:	687b      	ldr	r3, [r7, #4]
 8009bc8:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009bcc:	429a      	cmp	r2, r3
 8009bce:	d010      	beq.n	8009bf2 <wolfSSL_ResourceFree+0x1a6>
        if (ssl->biowr != NULL && ssl->biowr->prev == NULL)
 8009bd0:	687b      	ldr	r3, [r7, #4]
 8009bd2:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009bd6:	2b00      	cmp	r3, #0
 8009bd8:	d00b      	beq.n	8009bf2 <wolfSSL_ResourceFree+0x1a6>
 8009bda:	687b      	ldr	r3, [r7, #4]
 8009bdc:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009be0:	689b      	ldr	r3, [r3, #8]
 8009be2:	2b00      	cmp	r3, #0
 8009be4:	d105      	bne.n	8009bf2 <wolfSSL_ResourceFree+0x1a6>
            wolfSSL_BIO_free(ssl->biowr);
 8009be6:	687b      	ldr	r3, [r7, #4]
 8009be8:	f8d3 3330 	ldr.w	r3, [r3, #816]	@ 0x330
 8009bec:	4618      	mov	r0, r3
 8009bee:	f004 fa61 	bl	800e0b4 <wolfSSL_BIO_free>
    if (ssl->biord != NULL && ssl->biord->prev == NULL)
 8009bf2:	687b      	ldr	r3, [r7, #4]
 8009bf4:	f8d3 332c 	ldr.w	r3, [r3, #812]	@ 0x32c
 8009bf8:	2b00      	cmp	r3, #0
 8009bfa:	d00b      	beq.n	8009c14 <wolfSSL_ResourceFree+0x1c8>
 8009bfc:	687b      	ldr	r3, [r7, #4]
 8009bfe:	f8d3 332c 	ldr.w	r3, [r3, #812]	@ 0x32c
 8009c02:	689b      	ldr	r3, [r3, #8]
 8009c04:	2b00      	cmp	r3, #0
 8009c06:	d105      	bne.n	8009c14 <wolfSSL_ResourceFree+0x1c8>
        wolfSSL_BIO_free(ssl->biord);
 8009c08:	687b      	ldr	r3, [r7, #4]
 8009c0a:	f8d3 332c 	ldr.w	r3, [r3, #812]	@ 0x32c
 8009c0e:	4618      	mov	r0, r3
 8009c10:	f004 fa50 	bl	800e0b4 <wolfSSL_BIO_free>
    ssl->biowr = NULL;
 8009c14:	687b      	ldr	r3, [r7, #4]
 8009c16:	2200      	movs	r2, #0
 8009c18:	f8c3 2330 	str.w	r2, [r3, #816]	@ 0x330
    ssl->biord = NULL;
 8009c1c:	687b      	ldr	r3, [r7, #4]
 8009c1e:	2200      	movs	r2, #0
 8009c20:	f8c3 232c 	str.w	r2, [r3, #812]	@ 0x32c
#endif
#ifdef HAVE_LIBZ
    FreeStreams(ssl);
#endif
#ifdef HAVE_ECC
    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccKey);
 8009c24:	687b      	ldr	r3, [r7, #4]
 8009c26:	f503 7367 	add.w	r3, r3, #924	@ 0x39c
 8009c2a:	461a      	mov	r2, r3
 8009c2c:	2125      	movs	r1, #37	@ 0x25
 8009c2e:	6878      	ldr	r0, [r7, #4]
 8009c30:	f7ff fe2b 	bl	800988a <FreeKey>
    ssl->peerEccKeyPresent = 0;
 8009c34:	687b      	ldr	r3, [r7, #4]
 8009c36:	2200      	movs	r2, #0
 8009c38:	f883 2399 	strb.w	r2, [r3, #921]	@ 0x399
    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);
 8009c3c:	687b      	ldr	r3, [r7, #4]
 8009c3e:	f503 7368 	add.w	r3, r3, #928	@ 0x3a0
 8009c42:	461a      	mov	r2, r3
 8009c44:	2125      	movs	r1, #37	@ 0x25
 8009c46:	6878      	ldr	r0, [r7, #4]
 8009c48:	f7ff fe1f 	bl	800988a <FreeKey>
    ssl->peerEccDsaKeyPresent = 0;
 8009c4c:	687b      	ldr	r3, [r7, #4]
 8009c4e:	2200      	movs	r2, #0
 8009c50:	f883 23a6 	strb.w	r2, [r3, #934]	@ 0x3a6
#endif
#if defined(HAVE_ECC) || defined(HAVE_CURVE25519) ||defined(HAVE_CURVE448)
    {
        int dtype = 0;
 8009c54:	2300      	movs	r3, #0
 8009c56:	60fb      	str	r3, [r7, #12]
    #ifdef HAVE_ECC
        dtype = DYNAMIC_TYPE_ECC;
 8009c58:	2325      	movs	r3, #37	@ 0x25
 8009c5a:	60fb      	str	r3, [r7, #12]
           )
        {
            dtype = DYNAMIC_TYPE_CURVE448;
        }
    #endif /* HAVE_CURVE448 */
        FreeKey(ssl, dtype, (void**)&ssl->eccTempKey);
 8009c5c:	687b      	ldr	r3, [r7, #4]
 8009c5e:	f503 7365 	add.w	r3, r3, #916	@ 0x394
 8009c62:	461a      	mov	r2, r3
 8009c64:	68f9      	ldr	r1, [r7, #12]
 8009c66:	6878      	ldr	r0, [r7, #4]
 8009c68:	f7ff fe0f 	bl	800988a <FreeKey>
        ssl->eccTempKeyPresent = 0;
 8009c6c:	687b      	ldr	r3, [r7, #4]
 8009c6e:	2200      	movs	r2, #0
 8009c70:	f883 2398 	strb.w	r2, [r3, #920]	@ 0x398
        XFREE(ssl->buffers.peerRsaKey.buffer, ssl->heap, DYNAMIC_TYPE_RSA);
    #endif /* NO_RSA */
#endif /* HAVE_PK_CALLBACKS */
#ifdef HAVE_TLS_EXTENSIONS
#if !defined(NO_TLS)
    TLSX_FreeAll(ssl->extensions, ssl->heap);
 8009c74:	687b      	ldr	r3, [r7, #4]
 8009c76:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009c7a:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
 8009c7e:	687b      	ldr	r3, [r7, #4]
 8009c80:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8009c84:	4619      	mov	r1, r3
 8009c86:	4610      	mov	r0, r2
 8009c88:	f005 fbc8 	bl	800f41c <TLSX_FreeAll>
#ifdef HAVE_NETX
    if (ssl->nxCtx.nxPacket)
        nx_packet_release(ssl->nxCtx.nxPacket);
#endif
#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
    if (ssl->x509_store_pt)
 8009c8c:	687b      	ldr	r3, [r7, #4]
 8009c8e:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 8009c92:	2b00      	cmp	r3, #0
 8009c94:	d005      	beq.n	8009ca2 <wolfSSL_ResourceFree+0x256>
        wolfSSL_X509_STORE_free(ssl->x509_store_pt);
 8009c96:	687b      	ldr	r3, [r7, #4]
 8009c98:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 8009c9c:	4618      	mov	r0, r3
 8009c9e:	f005 fa0e 	bl	800f0be <wolfSSL_X509_STORE_free>
#endif
#ifdef KEEP_PEER_CERT
    FreeX509(&ssl->peerCert);
 8009ca2:	687b      	ldr	r3, [r7, #4]
 8009ca4:	f503 736f 	add.w	r3, r3, #956	@ 0x3bc
 8009ca8:	4618      	mov	r0, r3
 8009caa:	f7ff fc7c 	bl	80095a6 <FreeX509>
#endif

    if (ssl->session != NULL)
 8009cae:	687b      	ldr	r3, [r7, #4]
 8009cb0:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 8009cb4:	2b00      	cmp	r3, #0
 8009cb6:	d008      	beq.n	8009cca <wolfSSL_ResourceFree+0x27e>
        wolfSSL_FreeSession(ssl->ctx, ssl->session);
 8009cb8:	687b      	ldr	r3, [r7, #4]
 8009cba:	681a      	ldr	r2, [r3, #0]
 8009cbc:	687b      	ldr	r3, [r7, #4]
 8009cbe:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 8009cc2:	4619      	mov	r1, r3
 8009cc4:	4610      	mov	r0, r2
 8009cc6:	f001 fdae 	bl	800b826 <wolfSSL_FreeSession>
    if (ssl->dupWrite) {
        FreeWriteDup(ssl);
    }
#endif
#ifdef OPENSSL_EXTRA
    XFREE(ssl->param, ssl->heap, DYNAMIC_TYPE_OPENSSL);
 8009cca:	687b      	ldr	r3, [r7, #4]
 8009ccc:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 8009cd0:	60bb      	str	r3, [r7, #8]
 8009cd2:	68bb      	ldr	r3, [r7, #8]
 8009cd4:	2b00      	cmp	r3, #0
 8009cd6:	d002      	beq.n	8009cde <wolfSSL_ResourceFree+0x292>
 8009cd8:	68b8      	ldr	r0, [r7, #8]
 8009cda:	f014 fef7 	bl	801eacc <wolfSSL_Free>
    }
#endif /* WOLFSSL_STATIC_MEMORY */
#ifdef OPENSSL_EXTRA
    /* Enough to free stack structure since WOLFSSL_CIPHER
     * isn't allocated separately. */
    wolfSSL_sk_CIPHER_free(ssl->supportedCiphers);
 8009cde:	687b      	ldr	r3, [r7, #4]
 8009ce0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009ce4:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009ce8:	4618      	mov	r0, r3
 8009cea:	f003 ff99 	bl	800dc20 <wolfSSL_sk_CIPHER_free>
    wolfSSL_sk_X509_pop_free(ssl->peerCertChain, NULL);
 8009cee:	687b      	ldr	r3, [r7, #4]
 8009cf0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009cf4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8009cf8:	2100      	movs	r1, #0
 8009cfa:	4618      	mov	r0, r3
 8009cfc:	f004 fb34 	bl	800e368 <wolfSSL_sk_X509_pop_free>
    #ifdef KEEP_OUR_CERT
    wolfSSL_sk_X509_pop_free(ssl->ourCertChain, NULL);
    #endif
#endif
#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA) || defined(HAVE_LIGHTY)
    wolfSSL_sk_X509_NAME_pop_free(ssl->client_ca_names, NULL);
 8009d00:	687b      	ldr	r3, [r7, #4]
 8009d02:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009d06:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8009d0a:	2100      	movs	r1, #0
 8009d0c:	4618      	mov	r0, r3
 8009d0e:	f004 ff37 	bl	800eb80 <wolfSSL_sk_X509_NAME_pop_free>
    ssl->client_ca_names = NULL;
 8009d12:	687b      	ldr	r3, [r7, #4]
 8009d14:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8009d18:	461a      	mov	r2, r3
 8009d1a:	2300      	movs	r3, #0
 8009d1c:	f8c2 30ac 	str.w	r3, [r2, #172]	@ 0xac
    ssl->initial_ctx = NULL;
#endif
#ifdef WOLFSSL_DUAL_ALG_CERTS
    XFREE(ssl->peerSigSpec, ssl->heap, DYNAMIC_TYPE_TLSX);
#endif
}
 8009d20:	bf00      	nop
 8009d22:	3728      	adds	r7, #40	@ 0x28
 8009d24:	46bd      	mov	sp, r7
 8009d26:	bd80      	pop	{r7, pc}

08009d28 <FreeSSL>:
}


/* heap argument is the heap hint used when creating SSL */
void FreeSSL(WOLFSSL* ssl, void* heap)
{
 8009d28:	b580      	push	{r7, lr}
 8009d2a:	b084      	sub	sp, #16
 8009d2c:	af00      	add	r7, sp, #0
 8009d2e:	6078      	str	r0, [r7, #4]
 8009d30:	6039      	str	r1, [r7, #0]
    WOLFSSL_CTX* ctx = ssl->ctx;
 8009d32:	687b      	ldr	r3, [r7, #4]
 8009d34:	681b      	ldr	r3, [r3, #0]
 8009d36:	60fb      	str	r3, [r7, #12]
    wolfSSL_ResourceFree(ssl);
 8009d38:	6878      	ldr	r0, [r7, #4]
 8009d3a:	f7ff fe87 	bl	8009a4c <wolfSSL_ResourceFree>
    XFREE(ssl, heap, DYNAMIC_TYPE_SSL);
 8009d3e:	687b      	ldr	r3, [r7, #4]
 8009d40:	60bb      	str	r3, [r7, #8]
 8009d42:	68bb      	ldr	r3, [r7, #8]
 8009d44:	2b00      	cmp	r3, #0
 8009d46:	d002      	beq.n	8009d4e <FreeSSL+0x26>
 8009d48:	68b8      	ldr	r0, [r7, #8]
 8009d4a:	f014 febf 	bl	801eacc <wolfSSL_Free>
    if (ctx)
 8009d4e:	68fb      	ldr	r3, [r7, #12]
 8009d50:	2b00      	cmp	r3, #0
 8009d52:	d002      	beq.n	8009d5a <FreeSSL+0x32>
        FreeSSL_Ctx(ctx); /* will decrement and free underlying CTX if 0 */
 8009d54:	68f8      	ldr	r0, [r7, #12]
 8009d56:	f7fe ffe3 	bl	8008d20 <FreeSSL_Ctx>
    (void)heap;
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(ssl, sizeof(*ssl));
#endif
}
 8009d5a:	bf00      	nop
 8009d5c:	3710      	adds	r7, #16
 8009d5e:	46bd      	mov	sp, r7
 8009d60:	bd80      	pop	{r7, pc}

08009d62 <ShrinkOutputBuffer>:
}


/* Switch dynamic output buffer back to static, buffer is assumed clear */
void ShrinkOutputBuffer(WOLFSSL* ssl)
{
 8009d62:	b580      	push	{r7, lr}
 8009d64:	b084      	sub	sp, #16
 8009d66:	af00      	add	r7, sp, #0
 8009d68:	6078      	str	r0, [r7, #4]
    WOLFSSL_MSG("Shrinking output buffer");
    XFREE(ssl->buffers.outputBuffer.buffer - ssl->buffers.outputBuffer.offset,
 8009d6a:	687b      	ldr	r3, [r7, #4]
 8009d6c:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8009d70:	687b      	ldr	r3, [r7, #4]
 8009d72:	f893 3119 	ldrb.w	r3, [r3, #281]	@ 0x119
 8009d76:	425b      	negs	r3, r3
 8009d78:	4413      	add	r3, r2
 8009d7a:	60fb      	str	r3, [r7, #12]
 8009d7c:	68fb      	ldr	r3, [r7, #12]
 8009d7e:	2b00      	cmp	r3, #0
 8009d80:	d002      	beq.n	8009d88 <ShrinkOutputBuffer+0x26>
 8009d82:	68f8      	ldr	r0, [r7, #12]
 8009d84:	f014 fea2 	bl	801eacc <wolfSSL_Free>
          ssl->heap, DYNAMIC_TYPE_OUT_BUFFER);
    ssl->buffers.outputBuffer.buffer = ssl->buffers.outputBuffer.staticBuffer;
 8009d88:	687b      	ldr	r3, [r7, #4]
 8009d8a:	f503 7280 	add.w	r2, r3, #256	@ 0x100
 8009d8e:	687b      	ldr	r3, [r7, #4]
 8009d90:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    ssl->buffers.outputBuffer.bufferSize  = STATIC_BUFFER_LEN;
 8009d94:	687b      	ldr	r3, [r7, #4]
 8009d96:	2205      	movs	r2, #5
 8009d98:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
    ssl->buffers.outputBuffer.dynamicFlag = 0;
 8009d9c:	687b      	ldr	r3, [r7, #4]
 8009d9e:	2200      	movs	r2, #0
 8009da0:	f883 2118 	strb.w	r2, [r3, #280]	@ 0x118
    ssl->buffers.outputBuffer.offset      = 0;
 8009da4:	687b      	ldr	r3, [r7, #4]
 8009da6:	2200      	movs	r2, #0
 8009da8:	f883 2119 	strb.w	r2, [r3, #281]	@ 0x119
    /* idx and length are assumed to be 0. */
}
 8009dac:	bf00      	nop
 8009dae:	3710      	adds	r7, #16
 8009db0:	46bd      	mov	sp, r7
 8009db2:	bd80      	pop	{r7, pc}

08009db4 <ShrinkInputBuffer>:
/* forced free means cleaning up */
/* Be *CAREFUL* where this function is called. ProcessReply relies on
 * inputBuffer.idx *NOT* changing inside the ProcessReply function. ProcessReply
 * calls ShrinkInputBuffer itself when it is safe to do so. Don't overuse it. */
void ShrinkInputBuffer(WOLFSSL* ssl, int forcedFree)
{
 8009db4:	b580      	push	{r7, lr}
 8009db6:	b084      	sub	sp, #16
 8009db8:	af00      	add	r7, sp, #0
 8009dba:	6078      	str	r0, [r7, #4]
 8009dbc:	6039      	str	r1, [r7, #0]
    int usedLength = (int)(ssl->buffers.inputBuffer.length -
 8009dbe:	687b      	ldr	r3, [r7, #4]
 8009dc0:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
                     ssl->buffers.inputBuffer.idx);
 8009dc4:	687b      	ldr	r3, [r7, #4]
 8009dc6:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
    int usedLength = (int)(ssl->buffers.inputBuffer.length -
 8009dca:	1ad3      	subs	r3, r2, r3
 8009dcc:	60fb      	str	r3, [r7, #12]
    if (!forcedFree && (usedLength > STATIC_BUFFER_LEN ||
 8009dce:	683b      	ldr	r3, [r7, #0]
 8009dd0:	2b00      	cmp	r3, #0
 8009dd2:	d107      	bne.n	8009de4 <ShrinkInputBuffer+0x30>
 8009dd4:	68fb      	ldr	r3, [r7, #12]
 8009dd6:	2b05      	cmp	r3, #5
 8009dd8:	dc4c      	bgt.n	8009e74 <ShrinkInputBuffer+0xc0>
            ssl->buffers.clearOutputBuffer.length > 0))
 8009dda:	687b      	ldr	r3, [r7, #4]
 8009ddc:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
    if (!forcedFree && (usedLength > STATIC_BUFFER_LEN ||
 8009de0:	2b00      	cmp	r3, #0
 8009de2:	d147      	bne.n	8009e74 <ShrinkInputBuffer+0xc0>
        return;

    WOLFSSL_MSG("Shrinking input buffer");

    if (!forcedFree && usedLength > 0) {
 8009de4:	683b      	ldr	r3, [r7, #0]
 8009de6:	2b00      	cmp	r3, #0
 8009de8:	d110      	bne.n	8009e0c <ShrinkInputBuffer+0x58>
 8009dea:	68fb      	ldr	r3, [r7, #12]
 8009dec:	2b00      	cmp	r3, #0
 8009dee:	dd0d      	ble.n	8009e0c <ShrinkInputBuffer+0x58>
        XMEMCPY(ssl->buffers.inputBuffer.staticBuffer,
 8009df0:	687b      	ldr	r3, [r7, #4]
 8009df2:	f103 00e4 	add.w	r0, r3, #228	@ 0xe4
 8009df6:	687b      	ldr	r3, [r7, #4]
 8009df8:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
 8009dfc:	687b      	ldr	r3, [r7, #4]
 8009dfe:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8009e02:	4413      	add	r3, r2
 8009e04:	68fa      	ldr	r2, [r7, #12]
 8009e06:	4619      	mov	r1, r3
 8009e08:	f01e fbcc 	bl	80285a4 <memcpy>
               ssl->buffers.inputBuffer.buffer + ssl->buffers.inputBuffer.idx,
               usedLength);
    }

    ForceZero(ssl->buffers.inputBuffer.buffer,
 8009e0c:	687b      	ldr	r3, [r7, #4]
 8009e0e:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
 8009e12:	687b      	ldr	r3, [r7, #4]
 8009e14:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8009e18:	4619      	mov	r1, r3
 8009e1a:	4610      	mov	r0, r2
 8009e1c:	f7fe fd53 	bl	80088c6 <ForceZero>
        ssl->buffers.inputBuffer.length);
    XFREE(ssl->buffers.inputBuffer.buffer - ssl->buffers.inputBuffer.offset,
 8009e20:	687b      	ldr	r3, [r7, #4]
 8009e22:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
 8009e26:	687b      	ldr	r3, [r7, #4]
 8009e28:	f893 30fd 	ldrb.w	r3, [r3, #253]	@ 0xfd
 8009e2c:	425b      	negs	r3, r3
 8009e2e:	4413      	add	r3, r2
 8009e30:	60bb      	str	r3, [r7, #8]
 8009e32:	68bb      	ldr	r3, [r7, #8]
 8009e34:	2b00      	cmp	r3, #0
 8009e36:	d002      	beq.n	8009e3e <ShrinkInputBuffer+0x8a>
 8009e38:	68b8      	ldr	r0, [r7, #8]
 8009e3a:	f014 fe47 	bl	801eacc <wolfSSL_Free>
          ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
    ssl->buffers.inputBuffer.buffer = ssl->buffers.inputBuffer.staticBuffer;
 8009e3e:	687b      	ldr	r3, [r7, #4]
 8009e40:	f103 02e4 	add.w	r2, r3, #228	@ 0xe4
 8009e44:	687b      	ldr	r3, [r7, #4]
 8009e46:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
    ssl->buffers.inputBuffer.bufferSize  = STATIC_BUFFER_LEN;
 8009e4a:	687b      	ldr	r3, [r7, #4]
 8009e4c:	2205      	movs	r2, #5
 8009e4e:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
    ssl->buffers.inputBuffer.dynamicFlag = 0;
 8009e52:	687b      	ldr	r3, [r7, #4]
 8009e54:	2200      	movs	r2, #0
 8009e56:	f883 20fc 	strb.w	r2, [r3, #252]	@ 0xfc
    ssl->buffers.inputBuffer.offset      = 0;
 8009e5a:	687b      	ldr	r3, [r7, #4]
 8009e5c:	2200      	movs	r2, #0
 8009e5e:	f883 20fd 	strb.w	r2, [r3, #253]	@ 0xfd
    ssl->buffers.inputBuffer.idx = 0;
 8009e62:	687b      	ldr	r3, [r7, #4]
 8009e64:	2200      	movs	r2, #0
 8009e66:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
    ssl->buffers.inputBuffer.length = (word32)usedLength;
 8009e6a:	68fa      	ldr	r2, [r7, #12]
 8009e6c:	687b      	ldr	r3, [r7, #4]
 8009e6e:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
 8009e72:	e000      	b.n	8009e76 <ShrinkInputBuffer+0xc2>
        return;
 8009e74:	bf00      	nop
}
 8009e76:	3710      	adds	r7, #16
 8009e78:	46bd      	mov	sp, r7
 8009e7a:	bd80      	pop	{r7, pc}

08009e7c <MatchDomainName>:
   to left-most name component, compatible with RFC 2830 identity checking.

   return 1 on success */
int MatchDomainName(const char* pattern, int patternLen, const char* str,
                    word32 strLen, unsigned int flags)
{
 8009e7c:	b480      	push	{r7}
 8009e7e:	b089      	sub	sp, #36	@ 0x24
 8009e80:	af00      	add	r7, sp, #0
 8009e82:	60f8      	str	r0, [r7, #12]
 8009e84:	60b9      	str	r1, [r7, #8]
 8009e86:	607a      	str	r2, [r7, #4]
 8009e88:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8009e8a:	2300      	movs	r3, #0
 8009e8c:	61fb      	str	r3, [r7, #28]
    byte wildcardEligible = 1;
 8009e8e:	2301      	movs	r3, #1
 8009e90:	76fb      	strb	r3, [r7, #27]
    byte leftWildcardOnly = flags & WOLFSSL_LEFT_MOST_WILDCARD_ONLY;
 8009e92:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009e94:	b2db      	uxtb	r3, r3
 8009e96:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8009e9a:	767b      	strb	r3, [r7, #25]

    if (pattern == NULL || str == NULL || patternLen <= 0 || strLen == 0)
 8009e9c:	68fb      	ldr	r3, [r7, #12]
 8009e9e:	2b00      	cmp	r3, #0
 8009ea0:	d009      	beq.n	8009eb6 <MatchDomainName+0x3a>
 8009ea2:	687b      	ldr	r3, [r7, #4]
 8009ea4:	2b00      	cmp	r3, #0
 8009ea6:	d006      	beq.n	8009eb6 <MatchDomainName+0x3a>
 8009ea8:	68bb      	ldr	r3, [r7, #8]
 8009eaa:	2b00      	cmp	r3, #0
 8009eac:	dd03      	ble.n	8009eb6 <MatchDomainName+0x3a>
 8009eae:	683b      	ldr	r3, [r7, #0]
 8009eb0:	2b00      	cmp	r3, #0
 8009eb2:	f040 80b0 	bne.w	800a016 <MatchDomainName+0x19a>
        return 0;
 8009eb6:	2300      	movs	r3, #0
 8009eb8:	e0bc      	b.n	800a034 <MatchDomainName+0x1b8>

    while (patternLen > 0) {
        /* Get the next pattern char to evaluate */
        char p = (char)XTOLOWER((unsigned char)*pattern);
 8009eba:	68fb      	ldr	r3, [r7, #12]
 8009ebc:	781b      	ldrb	r3, [r3, #0]
 8009ebe:	763b      	strb	r3, [r7, #24]
 8009ec0:	7e3b      	ldrb	r3, [r7, #24]
 8009ec2:	3301      	adds	r3, #1
 8009ec4:	4a5e      	ldr	r2, [pc, #376]	@ (800a040 <MatchDomainName+0x1c4>)
 8009ec6:	4413      	add	r3, r2
 8009ec8:	781b      	ldrb	r3, [r3, #0]
 8009eca:	f003 0303 	and.w	r3, r3, #3
 8009ece:	2b01      	cmp	r3, #1
 8009ed0:	d102      	bne.n	8009ed8 <MatchDomainName+0x5c>
 8009ed2:	7e3b      	ldrb	r3, [r7, #24]
 8009ed4:	3320      	adds	r3, #32
 8009ed6:	e000      	b.n	8009eda <MatchDomainName+0x5e>
 8009ed8:	7e3b      	ldrb	r3, [r7, #24]
 8009eda:	76bb      	strb	r3, [r7, #26]
        if (p == '\0')
 8009edc:	7ebb      	ldrb	r3, [r7, #26]
 8009ede:	2b00      	cmp	r3, #0
 8009ee0:	f000 809e 	beq.w	800a020 <MatchDomainName+0x1a4>
            break;

        pattern++;
 8009ee4:	68fb      	ldr	r3, [r7, #12]
 8009ee6:	3301      	adds	r3, #1
 8009ee8:	60fb      	str	r3, [r7, #12]

        if ((p == '*') && wildcardEligible) {
 8009eea:	7ebb      	ldrb	r3, [r7, #26]
 8009eec:	2b2a      	cmp	r3, #42	@ 0x2a
 8009eee:	d16b      	bne.n	8009fc8 <MatchDomainName+0x14c>
 8009ef0:	7efb      	ldrb	r3, [r7, #27]
 8009ef2:	2b00      	cmp	r3, #0
 8009ef4:	d068      	beq.n	8009fc8 <MatchDomainName+0x14c>
            char s;
            /* We will always match '*' */
            patternLen--;
 8009ef6:	68bb      	ldr	r3, [r7, #8]
 8009ef8:	3b01      	subs	r3, #1
 8009efa:	60bb      	str	r3, [r7, #8]

            /* Only single wildcard allowed with strict left only */
            if (leftWildcardOnly) {
 8009efc:	7e7b      	ldrb	r3, [r7, #25]
 8009efe:	2b00      	cmp	r3, #0
 8009f00:	d02c      	beq.n	8009f5c <MatchDomainName+0xe0>
                wildcardEligible = 0;
 8009f02:	2300      	movs	r3, #0
 8009f04:	76fb      	strb	r3, [r7, #27]
            }

            /* Consume any extra '*' chars until the next non '*' char. */
            while (patternLen > 0) {
 8009f06:	e029      	b.n	8009f5c <MatchDomainName+0xe0>
                p = (char)XTOLOWER((unsigned char)*pattern);
 8009f08:	68fb      	ldr	r3, [r7, #12]
 8009f0a:	781b      	ldrb	r3, [r3, #0]
 8009f0c:	75fb      	strb	r3, [r7, #23]
 8009f0e:	7dfb      	ldrb	r3, [r7, #23]
 8009f10:	3301      	adds	r3, #1
 8009f12:	4a4b      	ldr	r2, [pc, #300]	@ (800a040 <MatchDomainName+0x1c4>)
 8009f14:	4413      	add	r3, r2
 8009f16:	781b      	ldrb	r3, [r3, #0]
 8009f18:	f003 0303 	and.w	r3, r3, #3
 8009f1c:	2b01      	cmp	r3, #1
 8009f1e:	d102      	bne.n	8009f26 <MatchDomainName+0xaa>
 8009f20:	7dfb      	ldrb	r3, [r7, #23]
 8009f22:	3320      	adds	r3, #32
 8009f24:	e000      	b.n	8009f28 <MatchDomainName+0xac>
 8009f26:	7dfb      	ldrb	r3, [r7, #23]
 8009f28:	76bb      	strb	r3, [r7, #26]
                pattern++;
 8009f2a:	68fb      	ldr	r3, [r7, #12]
 8009f2c:	3301      	adds	r3, #1
 8009f2e:	60fb      	str	r3, [r7, #12]
                if (p == '\0' && patternLen > 0)
 8009f30:	7ebb      	ldrb	r3, [r7, #26]
 8009f32:	2b00      	cmp	r3, #0
 8009f34:	d104      	bne.n	8009f40 <MatchDomainName+0xc4>
 8009f36:	68bb      	ldr	r3, [r7, #8]
 8009f38:	2b00      	cmp	r3, #0
 8009f3a:	dd01      	ble.n	8009f40 <MatchDomainName+0xc4>
                    return 0;
 8009f3c:	2300      	movs	r3, #0
 8009f3e:	e079      	b.n	800a034 <MatchDomainName+0x1b8>
                if (p != '*')
 8009f40:	7ebb      	ldrb	r3, [r7, #26]
 8009f42:	2b2a      	cmp	r3, #42	@ 0x2a
 8009f44:	d10e      	bne.n	8009f64 <MatchDomainName+0xe8>
                    break;
                if (leftWildcardOnly && (p == '*')) {
 8009f46:	7e7b      	ldrb	r3, [r7, #25]
 8009f48:	2b00      	cmp	r3, #0
 8009f4a:	d004      	beq.n	8009f56 <MatchDomainName+0xda>
 8009f4c:	7ebb      	ldrb	r3, [r7, #26]
 8009f4e:	2b2a      	cmp	r3, #42	@ 0x2a
 8009f50:	d101      	bne.n	8009f56 <MatchDomainName+0xda>
                    /* RFC2830 only allows single left-most wildcard */
                    return 0;
 8009f52:	2300      	movs	r3, #0
 8009f54:	e06e      	b.n	800a034 <MatchDomainName+0x1b8>
                }

                patternLen--;
 8009f56:	68bb      	ldr	r3, [r7, #8]
 8009f58:	3b01      	subs	r3, #1
 8009f5a:	60bb      	str	r3, [r7, #8]
            while (patternLen > 0) {
 8009f5c:	68bb      	ldr	r3, [r7, #8]
 8009f5e:	2b00      	cmp	r3, #0
 8009f60:	dcd2      	bgt.n	8009f08 <MatchDomainName+0x8c>
 8009f62:	e02b      	b.n	8009fbc <MatchDomainName+0x140>
                    break;
 8009f64:	bf00      	nop
            }

            /* Consume str until we reach next char in pattern after '*' or
             * end of string */
            while (strLen > 0) {
 8009f66:	e029      	b.n	8009fbc <MatchDomainName+0x140>
                s = (char)XTOLOWER((unsigned char) *str);
 8009f68:	687b      	ldr	r3, [r7, #4]
 8009f6a:	781b      	ldrb	r3, [r3, #0]
 8009f6c:	75bb      	strb	r3, [r7, #22]
 8009f6e:	7dbb      	ldrb	r3, [r7, #22]
 8009f70:	3301      	adds	r3, #1
 8009f72:	4a33      	ldr	r2, [pc, #204]	@ (800a040 <MatchDomainName+0x1c4>)
 8009f74:	4413      	add	r3, r2
 8009f76:	781b      	ldrb	r3, [r3, #0]
 8009f78:	f003 0303 	and.w	r3, r3, #3
 8009f7c:	2b01      	cmp	r3, #1
 8009f7e:	d102      	bne.n	8009f86 <MatchDomainName+0x10a>
 8009f80:	7dbb      	ldrb	r3, [r7, #22]
 8009f82:	3320      	adds	r3, #32
 8009f84:	e000      	b.n	8009f88 <MatchDomainName+0x10c>
 8009f86:	7dbb      	ldrb	r3, [r7, #22]
 8009f88:	757b      	strb	r3, [r7, #21]
                str++;
 8009f8a:	687b      	ldr	r3, [r7, #4]
 8009f8c:	3301      	adds	r3, #1
 8009f8e:	607b      	str	r3, [r7, #4]
                strLen--;
 8009f90:	683b      	ldr	r3, [r7, #0]
 8009f92:	3b01      	subs	r3, #1
 8009f94:	603b      	str	r3, [r7, #0]

                /* p is next char in pattern after '*', or '*' if '*' is the
                 * last char in the pattern (in which case patternLen is 1) */
                if ( ((s == p) && (patternLen > 0))) {
 8009f96:	7d7a      	ldrb	r2, [r7, #21]
 8009f98:	7ebb      	ldrb	r3, [r7, #26]
 8009f9a:	429a      	cmp	r2, r3
 8009f9c:	d106      	bne.n	8009fac <MatchDomainName+0x130>
 8009f9e:	68bb      	ldr	r3, [r7, #8]
 8009fa0:	2b00      	cmp	r3, #0
 8009fa2:	dd03      	ble.n	8009fac <MatchDomainName+0x130>
                    /* We had already counted the '*' as matched, this means
                     * we also matched the next non '*' char in pattern */
                    patternLen--;
 8009fa4:	68bb      	ldr	r3, [r7, #8]
 8009fa6:	3b01      	subs	r3, #1
 8009fa8:	60bb      	str	r3, [r7, #8]
                    break;
 8009faa:	e00c      	b.n	8009fc6 <MatchDomainName+0x14a>
                }

                /* If strlen is 0, we have consumed the entire string. Count that
                 * as a match of '*' */
                if (strLen == 0) {
 8009fac:	683b      	ldr	r3, [r7, #0]
 8009fae:	2b00      	cmp	r3, #0
 8009fb0:	d008      	beq.n	8009fc4 <MatchDomainName+0x148>
                    break;
                }

                if (s == '.')
 8009fb2:	7d7b      	ldrb	r3, [r7, #21]
 8009fb4:	2b2e      	cmp	r3, #46	@ 0x2e
 8009fb6:	d101      	bne.n	8009fbc <MatchDomainName+0x140>
                    return 0;
 8009fb8:	2300      	movs	r3, #0
 8009fba:	e03b      	b.n	800a034 <MatchDomainName+0x1b8>
            while (strLen > 0) {
 8009fbc:	683b      	ldr	r3, [r7, #0]
 8009fbe:	2b00      	cmp	r3, #0
 8009fc0:	d1d2      	bne.n	8009f68 <MatchDomainName+0xec>
        if ((p == '*') && wildcardEligible) {
 8009fc2:	e028      	b.n	800a016 <MatchDomainName+0x19a>
                    break;
 8009fc4:	bf00      	nop
        if ((p == '*') && wildcardEligible) {
 8009fc6:	e026      	b.n	800a016 <MatchDomainName+0x19a>
            }
        }
        else {
            /* Past left-most wildcard location, not eligible if flag set*/
            if (leftWildcardOnly && wildcardEligible) {
 8009fc8:	7e7b      	ldrb	r3, [r7, #25]
 8009fca:	2b00      	cmp	r3, #0
 8009fcc:	d004      	beq.n	8009fd8 <MatchDomainName+0x15c>
 8009fce:	7efb      	ldrb	r3, [r7, #27]
 8009fd0:	2b00      	cmp	r3, #0
 8009fd2:	d001      	beq.n	8009fd8 <MatchDomainName+0x15c>
                wildcardEligible = 0;
 8009fd4:	2300      	movs	r3, #0
 8009fd6:	76fb      	strb	r3, [r7, #27]
            }

            /* Simple case, pattern match exactly */
            if (p != (char)XTOLOWER((unsigned char) *str))
 8009fd8:	687b      	ldr	r3, [r7, #4]
 8009fda:	781b      	ldrb	r3, [r3, #0]
 8009fdc:	753b      	strb	r3, [r7, #20]
 8009fde:	7d3b      	ldrb	r3, [r7, #20]
 8009fe0:	3301      	adds	r3, #1
 8009fe2:	4a17      	ldr	r2, [pc, #92]	@ (800a040 <MatchDomainName+0x1c4>)
 8009fe4:	4413      	add	r3, r2
 8009fe6:	781b      	ldrb	r3, [r3, #0]
 8009fe8:	f003 0303 	and.w	r3, r3, #3
 8009fec:	2b01      	cmp	r3, #1
 8009fee:	d102      	bne.n	8009ff6 <MatchDomainName+0x17a>
 8009ff0:	7d3b      	ldrb	r3, [r7, #20]
 8009ff2:	3320      	adds	r3, #32
 8009ff4:	e000      	b.n	8009ff8 <MatchDomainName+0x17c>
 8009ff6:	7d3b      	ldrb	r3, [r7, #20]
 8009ff8:	b2db      	uxtb	r3, r3
 8009ffa:	7eba      	ldrb	r2, [r7, #26]
 8009ffc:	429a      	cmp	r2, r3
 8009ffe:	d001      	beq.n	800a004 <MatchDomainName+0x188>
                return 0;
 800a000:	2300      	movs	r3, #0
 800a002:	e017      	b.n	800a034 <MatchDomainName+0x1b8>

            str++;
 800a004:	687b      	ldr	r3, [r7, #4]
 800a006:	3301      	adds	r3, #1
 800a008:	607b      	str	r3, [r7, #4]
            strLen--;
 800a00a:	683b      	ldr	r3, [r7, #0]
 800a00c:	3b01      	subs	r3, #1
 800a00e:	603b      	str	r3, [r7, #0]
            patternLen--;
 800a010:	68bb      	ldr	r3, [r7, #8]
 800a012:	3b01      	subs	r3, #1
 800a014:	60bb      	str	r3, [r7, #8]
    while (patternLen > 0) {
 800a016:	68bb      	ldr	r3, [r7, #8]
 800a018:	2b00      	cmp	r3, #0
 800a01a:	f73f af4e 	bgt.w	8009eba <MatchDomainName+0x3e>
 800a01e:	e000      	b.n	800a022 <MatchDomainName+0x1a6>
            break;
 800a020:	bf00      	nop
        }
    }

    if (strLen == 0 && patternLen == 0) {
 800a022:	683b      	ldr	r3, [r7, #0]
 800a024:	2b00      	cmp	r3, #0
 800a026:	d104      	bne.n	800a032 <MatchDomainName+0x1b6>
 800a028:	68bb      	ldr	r3, [r7, #8]
 800a02a:	2b00      	cmp	r3, #0
 800a02c:	d101      	bne.n	800a032 <MatchDomainName+0x1b6>
        ret = 1; /* success */
 800a02e:	2301      	movs	r3, #1
 800a030:	61fb      	str	r3, [r7, #28]
    }

    return ret;
 800a032:	69fb      	ldr	r3, [r7, #28]
}
 800a034:	4618      	mov	r0, r3
 800a036:	3724      	adds	r7, #36	@ 0x24
 800a038:	46bd      	mov	sp, r7
 800a03a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a03e:	4770      	bx	lr
 800a040:	08033c9c 	.word	0x08033c9c

0800a044 <CheckForAltNames>:
 *           0 : no match found.
 *          -1 : No matches and wild pattern match failed.
 */
int CheckForAltNames(DecodedCert* dCert, const char* domain, word32 domainLen,
                     int* checkCN, unsigned int flags)
{
 800a044:	b580      	push	{r7, lr}
 800a046:	b08a      	sub	sp, #40	@ 0x28
 800a048:	af02      	add	r7, sp, #8
 800a04a:	60f8      	str	r0, [r7, #12]
 800a04c:	60b9      	str	r1, [r7, #8]
 800a04e:	607a      	str	r2, [r7, #4]
 800a050:	603b      	str	r3, [r7, #0]
    int match = 0;
 800a052:	2300      	movs	r3, #0
 800a054:	61fb      	str	r3, [r7, #28]
    DNS_entry* altName = NULL;
 800a056:	2300      	movs	r3, #0
 800a058:	61bb      	str	r3, [r7, #24]
    char *buf;
    word32 len;

    WOLFSSL_MSG("Checking AltNames");

    if (dCert)
 800a05a:	68fb      	ldr	r3, [r7, #12]
 800a05c:	2b00      	cmp	r3, #0
 800a05e:	d002      	beq.n	800a066 <CheckForAltNames+0x22>
        altName = dCert->altNames;
 800a060:	68fb      	ldr	r3, [r7, #12]
 800a062:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a064:	61bb      	str	r3, [r7, #24]

    if (checkCN != NULL) {
 800a066:	683b      	ldr	r3, [r7, #0]
 800a068:	2b00      	cmp	r3, #0
 800a06a:	d033      	beq.n	800a0d4 <CheckForAltNames+0x90>
        *checkCN = (altName == NULL) ? 1 : 0;
 800a06c:	69bb      	ldr	r3, [r7, #24]
 800a06e:	2b00      	cmp	r3, #0
 800a070:	bf0c      	ite	eq
 800a072:	2301      	moveq	r3, #1
 800a074:	2300      	movne	r3, #0
 800a076:	b2db      	uxtb	r3, r3
 800a078:	461a      	mov	r2, r3
 800a07a:	683b      	ldr	r3, [r7, #0]
 800a07c:	601a      	str	r2, [r3, #0]
    }

    while (altName) {
 800a07e:	e029      	b.n	800a0d4 <CheckForAltNames+0x90>
            len = (word32)XSTRLEN(buf);
        }
        else
#endif /* WOLFSSL_IP_ALT_NAME */
        {
            buf = altName->name;
 800a080:	69bb      	ldr	r3, [r7, #24]
 800a082:	68db      	ldr	r3, [r3, #12]
 800a084:	617b      	str	r3, [r7, #20]
            len = (word32)altName->len;
 800a086:	69bb      	ldr	r3, [r7, #24]
 800a088:	689b      	ldr	r3, [r3, #8]
 800a08a:	613b      	str	r3, [r7, #16]
        }

        if (MatchDomainName(buf, (int)len, domain, domainLen, flags)) {
 800a08c:	6939      	ldr	r1, [r7, #16]
 800a08e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a090:	9300      	str	r3, [sp, #0]
 800a092:	687b      	ldr	r3, [r7, #4]
 800a094:	68ba      	ldr	r2, [r7, #8]
 800a096:	6978      	ldr	r0, [r7, #20]
 800a098:	f7ff fef0 	bl	8009e7c <MatchDomainName>
 800a09c:	4603      	mov	r3, r0
 800a09e:	2b00      	cmp	r3, #0
 800a0a0:	d008      	beq.n	800a0b4 <CheckForAltNames+0x70>
            match = 1;
 800a0a2:	2301      	movs	r3, #1
 800a0a4:	61fb      	str	r3, [r7, #28]
            if (checkCN != NULL) {
 800a0a6:	683b      	ldr	r3, [r7, #0]
 800a0a8:	2b00      	cmp	r3, #0
 800a0aa:	d017      	beq.n	800a0dc <CheckForAltNames+0x98>
                *checkCN = 0;
 800a0ac:	683b      	ldr	r3, [r7, #0]
 800a0ae:	2200      	movs	r2, #0
 800a0b0:	601a      	str	r2, [r3, #0]
            }
            WOLFSSL_MSG("\tmatch found");
            break;
 800a0b2:	e013      	b.n	800a0dc <CheckForAltNames+0x98>
        }
        /* No matches and wild pattern match failed. */
        else if (buf && (len >=1) && (buf[0] == '*')) {
 800a0b4:	697b      	ldr	r3, [r7, #20]
 800a0b6:	2b00      	cmp	r3, #0
 800a0b8:	d009      	beq.n	800a0ce <CheckForAltNames+0x8a>
 800a0ba:	693b      	ldr	r3, [r7, #16]
 800a0bc:	2b00      	cmp	r3, #0
 800a0be:	d006      	beq.n	800a0ce <CheckForAltNames+0x8a>
 800a0c0:	697b      	ldr	r3, [r7, #20]
 800a0c2:	781b      	ldrb	r3, [r3, #0]
 800a0c4:	2b2a      	cmp	r3, #42	@ 0x2a
 800a0c6:	d102      	bne.n	800a0ce <CheckForAltNames+0x8a>
            match = -1;
 800a0c8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a0cc:	61fb      	str	r3, [r7, #28]
            WOLFSSL_MSG("\twildcard match failed");
        }

        altName = altName->next;
 800a0ce:	69bb      	ldr	r3, [r7, #24]
 800a0d0:	681b      	ldr	r3, [r3, #0]
 800a0d2:	61bb      	str	r3, [r7, #24]
    while (altName) {
 800a0d4:	69bb      	ldr	r3, [r7, #24]
 800a0d6:	2b00      	cmp	r3, #0
 800a0d8:	d1d2      	bne.n	800a080 <CheckForAltNames+0x3c>
 800a0da:	e000      	b.n	800a0de <CheckForAltNames+0x9a>
            break;
 800a0dc:	bf00      	nop
    }

    return match;
 800a0de:	69fb      	ldr	r3, [r7, #28]
}
 800a0e0:	4618      	mov	r0, r3
 800a0e2:	3720      	adds	r7, #32
 800a0e4:	46bd      	mov	sp, r7
 800a0e6:	bd80      	pop	{r7, pc}

0800a0e8 <CheckHostName>:
 * domainNameLen  The length of the domain name.
 * returns DOMAIN_NAME_MISMATCH when no match found and 0 on success.
 */
int CheckHostName(DecodedCert* dCert, const char *domainName,
                  size_t domainNameLen, unsigned int flags)
{
 800a0e8:	b580      	push	{r7, lr}
 800a0ea:	b088      	sub	sp, #32
 800a0ec:	af02      	add	r7, sp, #8
 800a0ee:	60f8      	str	r0, [r7, #12]
 800a0f0:	60b9      	str	r1, [r7, #8]
 800a0f2:	607a      	str	r2, [r7, #4]
 800a0f4:	603b      	str	r3, [r7, #0]
    int checkCN;
    int ret = WC_NO_ERR_TRACE(DOMAIN_NAME_MISMATCH);
 800a0f6:	4b18      	ldr	r3, [pc, #96]	@ (800a158 <CheckHostName+0x70>)
 800a0f8:	617b      	str	r3, [r7, #20]

    if (CheckForAltNames(dCert, domainName, (word32)domainNameLen,
 800a0fa:	f107 0210 	add.w	r2, r7, #16
 800a0fe:	683b      	ldr	r3, [r7, #0]
 800a100:	9300      	str	r3, [sp, #0]
 800a102:	4613      	mov	r3, r2
 800a104:	687a      	ldr	r2, [r7, #4]
 800a106:	68b9      	ldr	r1, [r7, #8]
 800a108:	68f8      	ldr	r0, [r7, #12]
 800a10a:	f7ff ff9b 	bl	800a044 <CheckForAltNames>
 800a10e:	4603      	mov	r3, r0
 800a110:	2b01      	cmp	r3, #1
 800a112:	d002      	beq.n	800a11a <CheckHostName+0x32>
                                            &checkCN, flags) != 1) {
        ret = DOMAIN_NAME_MISMATCH;
 800a114:	4b10      	ldr	r3, [pc, #64]	@ (800a158 <CheckHostName+0x70>)
 800a116:	617b      	str	r3, [r7, #20]
 800a118:	e001      	b.n	800a11e <CheckHostName+0x36>
        WOLFSSL_MSG("DomainName match on alt names failed");
    }
    else {
        ret = 0;
 800a11a:	2300      	movs	r3, #0
 800a11c:	617b      	str	r3, [r7, #20]
    }

#ifndef WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY
    if (checkCN == 1) {
 800a11e:	693b      	ldr	r3, [r7, #16]
 800a120:	2b01      	cmp	r3, #1
 800a122:	d113      	bne.n	800a14c <CheckHostName+0x64>
        if (MatchDomainName(dCert->subjectCN, dCert->subjectCNLen,
 800a124:	68fb      	ldr	r3, [r7, #12]
 800a126:	f8d3 0084 	ldr.w	r0, [r3, #132]	@ 0x84
 800a12a:	68fb      	ldr	r3, [r7, #12]
 800a12c:	f8d3 1088 	ldr.w	r1, [r3, #136]	@ 0x88
 800a130:	683b      	ldr	r3, [r7, #0]
 800a132:	9300      	str	r3, [sp, #0]
 800a134:	687b      	ldr	r3, [r7, #4]
 800a136:	68ba      	ldr	r2, [r7, #8]
 800a138:	f7ff fea0 	bl	8009e7c <MatchDomainName>
 800a13c:	4603      	mov	r3, r0
 800a13e:	2b01      	cmp	r3, #1
 800a140:	d102      	bne.n	800a148 <CheckHostName+0x60>
                            domainName, (word32)domainNameLen, flags) == 1) {
            ret = 0;
 800a142:	2300      	movs	r3, #0
 800a144:	617b      	str	r3, [r7, #20]
 800a146:	e001      	b.n	800a14c <CheckHostName+0x64>
        }
        else {
            ret = DOMAIN_NAME_MISMATCH;
 800a148:	4b03      	ldr	r3, [pc, #12]	@ (800a158 <CheckHostName+0x70>)
 800a14a:	617b      	str	r3, [r7, #20]
            WOLFSSL_MSG("DomainName match on common name failed");
        }
    }
#endif /* !WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY */

    return ret;
 800a14c:	697b      	ldr	r3, [r7, #20]
}
 800a14e:	4618      	mov	r0, r3
 800a150:	3718      	adds	r7, #24
 800a152:	46bd      	mov	sp, r7
 800a154:	bd80      	pop	{r7, pc}
 800a156:	bf00      	nop
 800a158:	fffffebe 	.word	0xfffffebe

0800a15c <CheckIPAddr>:

int CheckIPAddr(DecodedCert* dCert, const char* ipasc)
{
 800a15c:	b580      	push	{r7, lr}
 800a15e:	b082      	sub	sp, #8
 800a160:	af00      	add	r7, sp, #0
 800a162:	6078      	str	r0, [r7, #4]
 800a164:	6039      	str	r1, [r7, #0]
    WOLFSSL_MSG("Checking IPAddr");

    return CheckHostName(dCert, ipasc, (size_t)XSTRLEN(ipasc), 0);
 800a166:	6838      	ldr	r0, [r7, #0]
 800a168:	f7f6 f83c 	bl	80001e4 <strlen>
 800a16c:	4602      	mov	r2, r0
 800a16e:	2300      	movs	r3, #0
 800a170:	6839      	ldr	r1, [r7, #0]
 800a172:	6878      	ldr	r0, [r7, #4]
 800a174:	f7ff ffb8 	bl	800a0e8 <CheckHostName>
 800a178:	4603      	mov	r3, r0
}
 800a17a:	4618      	mov	r0, r3
 800a17c:	3708      	adds	r7, #8
 800a17e:	46bd      	mov	sp, r7
 800a180:	bd80      	pop	{r7, pc}

0800a182 <CopyAltNames>:

#if defined(KEEP_PEER_CERT) || defined(SESSION_CERTS) || \
    defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL) || \
    defined(WOLFSSL_ACERT)
    static int CopyAltNames(DNS_entry** to, DNS_entry* from, int type, void* heap)
{
 800a182:	b580      	push	{r7, lr}
 800a184:	b088      	sub	sp, #32
 800a186:	af00      	add	r7, sp, #0
 800a188:	60f8      	str	r0, [r7, #12]
 800a18a:	60b9      	str	r1, [r7, #8]
 800a18c:	607a      	str	r2, [r7, #4]
 800a18e:	603b      	str	r3, [r7, #0]
    /* Copy from to the beginning of to */
    DNS_entry** prev_next = to;
 800a190:	68fb      	ldr	r3, [r7, #12]
 800a192:	61fb      	str	r3, [r7, #28]
    DNS_entry* next;

    if (to == NULL) {
 800a194:	68fb      	ldr	r3, [r7, #12]
 800a196:	2b00      	cmp	r3, #0
 800a198:	d102      	bne.n	800a1a0 <CopyAltNames+0x1e>
        return BAD_FUNC_ARG;
 800a19a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800a19e:	e028      	b.n	800a1f2 <CopyAltNames+0x70>
    }

    next = *to;
 800a1a0:	68fb      	ldr	r3, [r7, #12]
 800a1a2:	681b      	ldr	r3, [r3, #0]
 800a1a4:	61bb      	str	r3, [r7, #24]

    for (; from != NULL; from = from->next) {
 800a1a6:	e020      	b.n	800a1ea <CopyAltNames+0x68>
        DNS_entry* dnsEntry;

        if (type != -1 && from->type != type)
 800a1a8:	687b      	ldr	r3, [r7, #4]
 800a1aa:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 800a1ae:	d004      	beq.n	800a1ba <CopyAltNames+0x38>
 800a1b0:	68bb      	ldr	r3, [r7, #8]
 800a1b2:	685b      	ldr	r3, [r3, #4]
 800a1b4:	687a      	ldr	r2, [r7, #4]
 800a1b6:	429a      	cmp	r2, r3
 800a1b8:	d113      	bne.n	800a1e2 <CopyAltNames+0x60>
            continue;

        dnsEntry = AltNameDup(from, heap);
 800a1ba:	6839      	ldr	r1, [r7, #0]
 800a1bc:	68b8      	ldr	r0, [r7, #8]
 800a1be:	f00b f81b 	bl	80151f8 <AltNameDup>
 800a1c2:	6178      	str	r0, [r7, #20]
        if (dnsEntry == NULL) {
 800a1c4:	697b      	ldr	r3, [r7, #20]
 800a1c6:	2b00      	cmp	r3, #0
 800a1c8:	d102      	bne.n	800a1d0 <CopyAltNames+0x4e>
            WOLFSSL_MSG("\tOut of Memory");
            return MEMORY_E;
 800a1ca:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a1ce:	e010      	b.n	800a1f2 <CopyAltNames+0x70>
        }

        dnsEntry->next = next;
 800a1d0:	697b      	ldr	r3, [r7, #20]
 800a1d2:	69ba      	ldr	r2, [r7, #24]
 800a1d4:	601a      	str	r2, [r3, #0]
        *prev_next = dnsEntry;
 800a1d6:	69fb      	ldr	r3, [r7, #28]
 800a1d8:	697a      	ldr	r2, [r7, #20]
 800a1da:	601a      	str	r2, [r3, #0]
        prev_next = &dnsEntry->next;
 800a1dc:	697b      	ldr	r3, [r7, #20]
 800a1de:	61fb      	str	r3, [r7, #28]
 800a1e0:	e000      	b.n	800a1e4 <CopyAltNames+0x62>
            continue;
 800a1e2:	bf00      	nop
    for (; from != NULL; from = from->next) {
 800a1e4:	68bb      	ldr	r3, [r7, #8]
 800a1e6:	681b      	ldr	r3, [r3, #0]
 800a1e8:	60bb      	str	r3, [r7, #8]
 800a1ea:	68bb      	ldr	r3, [r7, #8]
 800a1ec:	2b00      	cmp	r3, #0
 800a1ee:	d1db      	bne.n	800a1a8 <CopyAltNames+0x26>
    }

    return 0;
 800a1f0:	2300      	movs	r3, #0
}
 800a1f2:	4618      	mov	r0, r3
 800a1f4:	3720      	adds	r7, #32
 800a1f6:	46bd      	mov	sp, r7
 800a1f8:	bd80      	pop	{r7, pc}

0800a1fa <CopyDecodedName>:


#if defined(KEEP_PEER_CERT) || defined(SESSION_CERTS) || \
    defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
void CopyDecodedName(WOLFSSL_X509_NAME* name, DecodedCert* dCert, int nameType)
{
 800a1fa:	b580      	push	{r7, lr}
 800a1fc:	b086      	sub	sp, #24
 800a1fe:	af00      	add	r7, sp, #0
 800a200:	60f8      	str	r0, [r7, #12]
 800a202:	60b9      	str	r1, [r7, #8]
 800a204:	607a      	str	r2, [r7, #4]
    if (name->dynamicName) {
 800a206:	68fb      	ldr	r3, [r7, #12]
 800a208:	685b      	ldr	r3, [r3, #4]
 800a20a:	2b00      	cmp	r3, #0
 800a20c:	d010      	beq.n	800a230 <CopyDecodedName+0x36>
        XFREE(name->name, name->heap, DYNAMIC_TYPE_X509);
 800a20e:	68fb      	ldr	r3, [r7, #12]
 800a210:	681b      	ldr	r3, [r3, #0]
 800a212:	617b      	str	r3, [r7, #20]
 800a214:	697b      	ldr	r3, [r7, #20]
 800a216:	2b00      	cmp	r3, #0
 800a218:	d002      	beq.n	800a220 <CopyDecodedName+0x26>
 800a21a:	6978      	ldr	r0, [r7, #20]
 800a21c:	f014 fc56 	bl	801eacc <wolfSSL_Free>
        name->name = name->staticName;
 800a220:	68fb      	ldr	r3, [r7, #12]
 800a222:	f103 020c 	add.w	r2, r3, #12
 800a226:	68fb      	ldr	r3, [r7, #12]
 800a228:	601a      	str	r2, [r3, #0]
        name->dynamicName = 0;
 800a22a:	68fb      	ldr	r3, [r7, #12]
 800a22c:	2200      	movs	r2, #0
 800a22e:	605a      	str	r2, [r3, #4]
    }

    if (nameType == ASN_SUBJECT) {
 800a230:	687b      	ldr	r3, [r7, #4]
 800a232:	2b01      	cmp	r3, #1
 800a234:	d119      	bne.n	800a26a <CopyDecodedName+0x70>
        XSTRNCPY(name->name, dCert->subject, ASN_NAME_MAX);
 800a236:	68fb      	ldr	r3, [r7, #12]
 800a238:	6818      	ldr	r0, [r3, #0]
 800a23a:	68bb      	ldr	r3, [r7, #8]
 800a23c:	f203 13f5 	addw	r3, r3, #501	@ 0x1f5
 800a240:	f44f 72b4 	mov.w	r2, #360	@ 0x168
 800a244:	4619      	mov	r1, r3
 800a246:	f01e f95d 	bl	8028504 <strncpy>
        name->name[ASN_NAME_MAX - 1] = '\0';
 800a24a:	68fb      	ldr	r3, [r7, #12]
 800a24c:	681b      	ldr	r3, [r3, #0]
 800a24e:	f203 1367 	addw	r3, r3, #359	@ 0x167
 800a252:	2200      	movs	r2, #0
 800a254:	701a      	strb	r2, [r3, #0]
        name->sz = (int)XSTRLEN(name->name) + 1;
 800a256:	68fb      	ldr	r3, [r7, #12]
 800a258:	681b      	ldr	r3, [r3, #0]
 800a25a:	4618      	mov	r0, r3
 800a25c:	f7f5 ffc2 	bl	80001e4 <strlen>
 800a260:	4603      	mov	r3, r0
 800a262:	1c5a      	adds	r2, r3, #1
 800a264:	68fb      	ldr	r3, [r7, #12]
 800a266:	609a      	str	r2, [r3, #8]
        if (name->rawLen > 0) {
            XMEMCPY(name->raw, dCert->issuerRaw, name->rawLen);
        }
#endif
    }
}
 800a268:	e017      	b.n	800a29a <CopyDecodedName+0xa0>
        XSTRNCPY(name->name, dCert->issuer, ASN_NAME_MAX);
 800a26a:	68fb      	ldr	r3, [r7, #12]
 800a26c:	6818      	ldr	r0, [r3, #0]
 800a26e:	68bb      	ldr	r3, [r7, #8]
 800a270:	338d      	adds	r3, #141	@ 0x8d
 800a272:	f44f 72b4 	mov.w	r2, #360	@ 0x168
 800a276:	4619      	mov	r1, r3
 800a278:	f01e f944 	bl	8028504 <strncpy>
        name->name[ASN_NAME_MAX - 1] = '\0';
 800a27c:	68fb      	ldr	r3, [r7, #12]
 800a27e:	681b      	ldr	r3, [r3, #0]
 800a280:	f203 1367 	addw	r3, r3, #359	@ 0x167
 800a284:	2200      	movs	r2, #0
 800a286:	701a      	strb	r2, [r3, #0]
        name->sz = (int)XSTRLEN(name->name) + 1;
 800a288:	68fb      	ldr	r3, [r7, #12]
 800a28a:	681b      	ldr	r3, [r3, #0]
 800a28c:	4618      	mov	r0, r3
 800a28e:	f7f5 ffa9 	bl	80001e4 <strlen>
 800a292:	4603      	mov	r3, r0
 800a294:	1c5a      	adds	r2, r3, #1
 800a296:	68fb      	ldr	r3, [r7, #12]
 800a298:	609a      	str	r2, [r3, #8]
}
 800a29a:	bf00      	nop
 800a29c:	3718      	adds	r7, #24
 800a29e:	46bd      	mov	sp, r7
 800a2a0:	bd80      	pop	{r7, pc}

0800a2a2 <CopyDecodedToX509>:
}
#endif /* WOLFSSL_CERT_REQ */

/* Copy parts X509 needs from Decoded cert, 0 on success */
int CopyDecodedToX509(WOLFSSL_X509* x509, DecodedCert* dCert)
{
 800a2a2:	b580      	push	{r7, lr}
 800a2a4:	b084      	sub	sp, #16
 800a2a6:	af00      	add	r7, sp, #0
 800a2a8:	6078      	str	r0, [r7, #4]
 800a2aa:	6039      	str	r1, [r7, #0]
    int ret = 0;
 800a2ac:	2300      	movs	r3, #0
 800a2ae:	60fb      	str	r3, [r7, #12]
    int minSz;

    if (x509 == NULL || dCert == NULL ||
 800a2b0:	687b      	ldr	r3, [r7, #4]
 800a2b2:	2b00      	cmp	r3, #0
 800a2b4:	d007      	beq.n	800a2c6 <CopyDecodedToX509+0x24>
 800a2b6:	683b      	ldr	r3, [r7, #0]
 800a2b8:	2b00      	cmp	r3, #0
 800a2ba:	d004      	beq.n	800a2c6 <CopyDecodedToX509+0x24>
        dCert->subjectCNLen < 0)
 800a2bc:	683b      	ldr	r3, [r7, #0]
 800a2be:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
    if (x509 == NULL || dCert == NULL ||
 800a2c2:	2b00      	cmp	r3, #0
 800a2c4:	da03      	bge.n	800a2ce <CopyDecodedToX509+0x2c>
        return BAD_FUNC_ARG;
 800a2c6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800a2ca:	f000 bc03 	b.w	800aad4 <CopyDecodedToX509+0x832>

    if (x509->issuer.name == NULL || x509->subject.name == NULL) {
 800a2ce:	687b      	ldr	r3, [r7, #4]
 800a2d0:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
 800a2d4:	2b00      	cmp	r3, #0
 800a2d6:	d004      	beq.n	800a2e2 <CopyDecodedToX509+0x40>
 800a2d8:	687b      	ldr	r3, [r7, #4]
 800a2da:	f8d3 3788 	ldr.w	r3, [r3, #1928]	@ 0x788
 800a2de:	2b00      	cmp	r3, #0
 800a2e0:	d102      	bne.n	800a2e8 <CopyDecodedToX509+0x46>
        WOLFSSL_MSG("Either init was not called on X509 or programming error");
        WOLFSSL_ERROR_VERBOSE(BAD_FUNC_ARG);
        return BAD_FUNC_ARG;
 800a2e2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800a2e6:	e3f5      	b.n	800aad4 <CopyDecodedToX509+0x832>
    }

    x509->version = dCert->version + 1;
 800a2e8:	683b      	ldr	r3, [r7, #0]
 800a2ea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a2ec:	1c5a      	adds	r2, r3, #1
 800a2ee:	687b      	ldr	r3, [r7, #4]
 800a2f0:	601a      	str	r2, [r3, #0]

    CopyDecodedName(&x509->issuer, dCert, ASN_ISSUER);
 800a2f2:	687b      	ldr	r3, [r7, #4]
 800a2f4:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800a2f8:	2200      	movs	r2, #0
 800a2fa:	6839      	ldr	r1, [r7, #0]
 800a2fc:	4618      	mov	r0, r3
 800a2fe:	f7ff ff7c 	bl	800a1fa <CopyDecodedName>
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (dCert->issuerName != NULL) {
 800a302:	683b      	ldr	r3, [r7, #0]
 800a304:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
 800a308:	2b00      	cmp	r3, #0
 800a30a:	d00a      	beq.n	800a322 <CopyDecodedToX509+0x80>
        wolfSSL_X509_set_issuer_name(x509,
                (WOLFSSL_X509_NAME*)dCert->issuerName);
 800a30c:	683b      	ldr	r3, [r7, #0]
 800a30e:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
        wolfSSL_X509_set_issuer_name(x509,
 800a312:	4619      	mov	r1, r3
 800a314:	6878      	ldr	r0, [r7, #4]
 800a316:	f004 fce6 	bl	800ece6 <wolfSSL_X509_set_issuer_name>
        x509->issuer.x509 = x509;
 800a31a:	687b      	ldr	r3, [r7, #4]
 800a31c:	687a      	ldr	r2, [r7, #4]
 800a31e:	f8c3 2610 	str.w	r2, [r3, #1552]	@ 0x610
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */
    CopyDecodedName(&x509->subject, dCert, ASN_SUBJECT);
 800a322:	687b      	ldr	r3, [r7, #4]
 800a324:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800a328:	2201      	movs	r2, #1
 800a32a:	6839      	ldr	r1, [r7, #0]
 800a32c:	4618      	mov	r0, r3
 800a32e:	f7ff ff64 	bl	800a1fa <CopyDecodedName>
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (dCert->subjectName != NULL) {
 800a332:	683b      	ldr	r3, [r7, #0]
 800a334:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
 800a338:	2b00      	cmp	r3, #0
 800a33a:	d00a      	beq.n	800a352 <CopyDecodedToX509+0xb0>
        wolfSSL_X509_set_subject_name(x509,
                (WOLFSSL_X509_NAME*)dCert->subjectName);
 800a33c:	683b      	ldr	r3, [r7, #0]
 800a33e:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
        wolfSSL_X509_set_subject_name(x509,
 800a342:	4619      	mov	r1, r3
 800a344:	6878      	ldr	r0, [r7, #4]
 800a346:	f004 fc96 	bl	800ec76 <wolfSSL_X509_set_subject_name>
        x509->subject.x509 = x509;
 800a34a:	687b      	ldr	r3, [r7, #4]
 800a34c:	687a      	ldr	r2, [r7, #4]
 800a34e:	f8c3 2b1c 	str.w	r2, [r3, #2844]	@ 0xb1c
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */

    XMEMCPY(x509->serial, dCert->serial, EXTERNAL_SERIAL_SIZE);
 800a352:	687b      	ldr	r3, [r7, #4]
 800a354:	f103 00f4 	add.w	r0, r3, #244	@ 0xf4
 800a358:	683b      	ldr	r3, [r7, #0]
 800a35a:	f503 735d 	add.w	r3, r3, #884	@ 0x374
 800a35e:	2220      	movs	r2, #32
 800a360:	4619      	mov	r1, r3
 800a362:	f01e f91f 	bl	80285a4 <memcpy>
    x509->serialSz = dCert->serialSz;
 800a366:	683b      	ldr	r3, [r7, #0]
 800a368:	f8d3 2394 	ldr.w	r2, [r3, #916]	@ 0x394
 800a36c:	687b      	ldr	r3, [r7, #4]
 800a36e:	605a      	str	r2, [r3, #4]
    if (dCert->subjectCN && dCert->subjectCNLen < ASN_NAME_MAX) {
 800a370:	683b      	ldr	r3, [r7, #0]
 800a372:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800a376:	2b00      	cmp	r3, #0
 800a378:	d01a      	beq.n	800a3b0 <CopyDecodedToX509+0x10e>
 800a37a:	683b      	ldr	r3, [r7, #0]
 800a37c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800a380:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 800a384:	da14      	bge.n	800a3b0 <CopyDecodedToX509+0x10e>
        XMEMCPY(x509->subjectCN, dCert->subjectCN, dCert->subjectCNLen);
 800a386:	687b      	ldr	r3, [r7, #4]
 800a388:	f503 708a 	add.w	r0, r3, #276	@ 0x114
 800a38c:	683b      	ldr	r3, [r7, #0]
 800a38e:	f8d3 1084 	ldr.w	r1, [r3, #132]	@ 0x84
 800a392:	683b      	ldr	r3, [r7, #0]
 800a394:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800a398:	461a      	mov	r2, r3
 800a39a:	f01e f903 	bl	80285a4 <memcpy>
        x509->subjectCN[dCert->subjectCNLen] = '\0';
 800a39e:	683b      	ldr	r3, [r7, #0]
 800a3a0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800a3a4:	687a      	ldr	r2, [r7, #4]
 800a3a6:	4413      	add	r3, r2
 800a3a8:	2200      	movs	r2, #0
 800a3aa:	f883 2114 	strb.w	r2, [r3, #276]	@ 0x114
 800a3ae:	e003      	b.n	800a3b8 <CopyDecodedToX509+0x116>
    }
    else
        x509->subjectCN[0] = '\0';
 800a3b0:	687b      	ldr	r3, [r7, #4]
 800a3b2:	2200      	movs	r2, #0
 800a3b4:	f883 2114 	strb.w	r2, [r3, #276]	@ 0x114
    }
    else
        x509->hwSerialNumSz = 0;
#endif /* WOLFSSL_SEP */

    if (dCert->beforeDateLen > 0) {
 800a3b8:	683b      	ldr	r3, [r7, #0]
 800a3ba:	f8d3 3448 	ldr.w	r3, [r3, #1096]	@ 0x448
 800a3be:	2b00      	cmp	r3, #0
 800a3c0:	dd20      	ble.n	800a404 <CopyDecodedToX509+0x162>
        minSz = (int)min(dCert->beforeDate[1], MAX_DATE_SZ);
 800a3c2:	683b      	ldr	r3, [r7, #0]
 800a3c4:	f8d3 3444 	ldr.w	r3, [r3, #1092]	@ 0x444
 800a3c8:	3301      	adds	r3, #1
 800a3ca:	781b      	ldrb	r3, [r3, #0]
 800a3cc:	2120      	movs	r1, #32
 800a3ce:	4618      	mov	r0, r3
 800a3d0:	f7fe fa92 	bl	80088f8 <min>
 800a3d4:	4603      	mov	r3, r0
 800a3d6:	60bb      	str	r3, [r7, #8]
        x509->notBefore.type = dCert->beforeDate[0];
 800a3d8:	683b      	ldr	r3, [r7, #0]
 800a3da:	f8d3 3444 	ldr.w	r3, [r3, #1092]	@ 0x444
 800a3de:	781b      	ldrb	r3, [r3, #0]
 800a3e0:	461a      	mov	r2, r3
 800a3e2:	687b      	ldr	r3, [r7, #4]
 800a3e4:	63da      	str	r2, [r3, #60]	@ 0x3c
        x509->notBefore.length = minSz;
 800a3e6:	687b      	ldr	r3, [r7, #4]
 800a3e8:	68ba      	ldr	r2, [r7, #8]
 800a3ea:	639a      	str	r2, [r3, #56]	@ 0x38
        XMEMCPY(x509->notBefore.data, &dCert->beforeDate[2], minSz);
 800a3ec:	687b      	ldr	r3, [r7, #4]
 800a3ee:	f103 0018 	add.w	r0, r3, #24
 800a3f2:	683b      	ldr	r3, [r7, #0]
 800a3f4:	f8d3 3444 	ldr.w	r3, [r3, #1092]	@ 0x444
 800a3f8:	3302      	adds	r3, #2
 800a3fa:	68ba      	ldr	r2, [r7, #8]
 800a3fc:	4619      	mov	r1, r3
 800a3fe:	f01e f8d1 	bl	80285a4 <memcpy>
 800a402:	e002      	b.n	800a40a <CopyDecodedToX509+0x168>
    }
    else
        x509->notBefore.length = 0;
 800a404:	687b      	ldr	r3, [r7, #4]
 800a406:	2200      	movs	r2, #0
 800a408:	639a      	str	r2, [r3, #56]	@ 0x38
    if (dCert->afterDateLen > 0) {
 800a40a:	683b      	ldr	r3, [r7, #0]
 800a40c:	f8d3 3450 	ldr.w	r3, [r3, #1104]	@ 0x450
 800a410:	2b00      	cmp	r3, #0
 800a412:	dd20      	ble.n	800a456 <CopyDecodedToX509+0x1b4>
        minSz = (int)min(dCert->afterDate[1], MAX_DATE_SZ);
 800a414:	683b      	ldr	r3, [r7, #0]
 800a416:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
 800a41a:	3301      	adds	r3, #1
 800a41c:	781b      	ldrb	r3, [r3, #0]
 800a41e:	2120      	movs	r1, #32
 800a420:	4618      	mov	r0, r3
 800a422:	f7fe fa69 	bl	80088f8 <min>
 800a426:	4603      	mov	r3, r0
 800a428:	60bb      	str	r3, [r7, #8]
        x509->notAfter.type = dCert->afterDate[0];
 800a42a:	683b      	ldr	r3, [r7, #0]
 800a42c:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
 800a430:	781b      	ldrb	r3, [r3, #0]
 800a432:	461a      	mov	r2, r3
 800a434:	687b      	ldr	r3, [r7, #4]
 800a436:	665a      	str	r2, [r3, #100]	@ 0x64
        x509->notAfter.length = minSz;
 800a438:	687b      	ldr	r3, [r7, #4]
 800a43a:	68ba      	ldr	r2, [r7, #8]
 800a43c:	661a      	str	r2, [r3, #96]	@ 0x60
        XMEMCPY(x509->notAfter.data, &dCert->afterDate[2], minSz);
 800a43e:	687b      	ldr	r3, [r7, #4]
 800a440:	f103 0040 	add.w	r0, r3, #64	@ 0x40
 800a444:	683b      	ldr	r3, [r7, #0]
 800a446:	f8d3 344c 	ldr.w	r3, [r3, #1100]	@ 0x44c
 800a44a:	3302      	adds	r3, #2
 800a44c:	68ba      	ldr	r2, [r7, #8]
 800a44e:	4619      	mov	r1, r3
 800a450:	f01e f8a8 	bl	80285a4 <memcpy>
 800a454:	e002      	b.n	800a45c <CopyDecodedToX509+0x1ba>
    }
    else
        x509->notAfter.length = 0;
 800a456:	687b      	ldr	r3, [r7, #4]
 800a458:	2200      	movs	r2, #0
 800a45a:	661a      	str	r2, [r3, #96]	@ 0x60

    if (dCert->publicKey != NULL && dCert->pubKeySize != 0) {
 800a45c:	683b      	ldr	r3, [r7, #0]
 800a45e:	681b      	ldr	r3, [r3, #0]
 800a460:	2b00      	cmp	r3, #0
 800a462:	d026      	beq.n	800a4b2 <CopyDecodedToX509+0x210>
 800a464:	683b      	ldr	r3, [r7, #0]
 800a466:	685b      	ldr	r3, [r3, #4]
 800a468:	2b00      	cmp	r3, #0
 800a46a:	d022      	beq.n	800a4b2 <CopyDecodedToX509+0x210>
        x509->pubKey.buffer = (byte*)XMALLOC(
 800a46c:	683b      	ldr	r3, [r7, #0]
 800a46e:	685b      	ldr	r3, [r3, #4]
 800a470:	4618      	mov	r0, r3
 800a472:	f014 fb0f 	bl	801ea94 <wolfSSL_Malloc>
 800a476:	4602      	mov	r2, r0
 800a478:	687b      	ldr	r3, [r7, #4]
 800a47a:	679a      	str	r2, [r3, #120]	@ 0x78
                        dCert->pubKeySize, x509->heap, DYNAMIC_TYPE_PUBLIC_KEY);
        if (x509->pubKey.buffer != NULL) {
 800a47c:	687b      	ldr	r3, [r7, #4]
 800a47e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800a480:	2b00      	cmp	r3, #0
 800a482:	d013      	beq.n	800a4ac <CopyDecodedToX509+0x20a>
            x509->pubKeyOID = (int)dCert->keyOID;
 800a484:	683b      	ldr	r3, [r7, #0]
 800a486:	69db      	ldr	r3, [r3, #28]
 800a488:	461a      	mov	r2, r3
 800a48a:	687b      	ldr	r3, [r7, #4]
 800a48c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
            x509->pubKey.length = dCert->pubKeySize;
 800a490:	683b      	ldr	r3, [r7, #0]
 800a492:	685a      	ldr	r2, [r3, #4]
 800a494:	687b      	ldr	r3, [r7, #4]
 800a496:	67da      	str	r2, [r3, #124]	@ 0x7c
            XMEMCPY(x509->pubKey.buffer, dCert->publicKey, dCert->pubKeySize);
 800a498:	687b      	ldr	r3, [r7, #4]
 800a49a:	6f98      	ldr	r0, [r3, #120]	@ 0x78
 800a49c:	683b      	ldr	r3, [r7, #0]
 800a49e:	6819      	ldr	r1, [r3, #0]
 800a4a0:	683b      	ldr	r3, [r7, #0]
 800a4a2:	685b      	ldr	r3, [r3, #4]
 800a4a4:	461a      	mov	r2, r3
 800a4a6:	f01e f87d 	bl	80285a4 <memcpy>
 800a4aa:	e002      	b.n	800a4b2 <CopyDecodedToX509+0x210>
        }
        else
            ret = MEMORY_E;
 800a4ac:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a4b0:	60fb      	str	r3, [r7, #12]
            }
        }
#endif
    }

    if (dCert->signature != NULL && dCert->sigLength != 0 &&
 800a4b2:	683b      	ldr	r3, [r7, #0]
 800a4b4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800a4b8:	2b00      	cmp	r3, #0
 800a4ba:	d02b      	beq.n	800a514 <CopyDecodedToX509+0x272>
 800a4bc:	683b      	ldr	r3, [r7, #0]
 800a4be:	695b      	ldr	r3, [r3, #20]
 800a4c0:	2b00      	cmp	r3, #0
 800a4c2:	d027      	beq.n	800a514 <CopyDecodedToX509+0x272>
            dCert->sigLength <= MAX_ENCODED_SIG_SZ) {
 800a4c4:	683b      	ldr	r3, [r7, #0]
 800a4c6:	695b      	ldr	r3, [r3, #20]
    if (dCert->signature != NULL && dCert->sigLength != 0 &&
 800a4c8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800a4cc:	d822      	bhi.n	800a514 <CopyDecodedToX509+0x272>
        x509->sig.buffer = (byte*)XMALLOC(
 800a4ce:	683b      	ldr	r3, [r7, #0]
 800a4d0:	695b      	ldr	r3, [r3, #20]
 800a4d2:	4618      	mov	r0, r3
 800a4d4:	f014 fade 	bl	801ea94 <wolfSSL_Malloc>
 800a4d8:	4602      	mov	r2, r0
 800a4da:	687b      	ldr	r3, [r7, #4]
 800a4dc:	669a      	str	r2, [r3, #104]	@ 0x68
                          dCert->sigLength, x509->heap, DYNAMIC_TYPE_SIGNATURE);
        if (x509->sig.buffer == NULL) {
 800a4de:	687b      	ldr	r3, [r7, #4]
 800a4e0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800a4e2:	2b00      	cmp	r3, #0
 800a4e4:	d103      	bne.n	800a4ee <CopyDecodedToX509+0x24c>
            ret = MEMORY_E;
 800a4e6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a4ea:	60fb      	str	r3, [r7, #12]
 800a4ec:	e012      	b.n	800a514 <CopyDecodedToX509+0x272>
        }
        else {
            XMEMCPY(x509->sig.buffer, dCert->signature, dCert->sigLength);
 800a4ee:	687b      	ldr	r3, [r7, #4]
 800a4f0:	6e98      	ldr	r0, [r3, #104]	@ 0x68
 800a4f2:	683b      	ldr	r3, [r7, #0]
 800a4f4:	f8d3 1080 	ldr.w	r1, [r3, #128]	@ 0x80
 800a4f8:	683b      	ldr	r3, [r7, #0]
 800a4fa:	695b      	ldr	r3, [r3, #20]
 800a4fc:	461a      	mov	r2, r3
 800a4fe:	f01e f851 	bl	80285a4 <memcpy>
            x509->sig.length = dCert->sigLength;
 800a502:	683b      	ldr	r3, [r7, #0]
 800a504:	695a      	ldr	r2, [r3, #20]
 800a506:	687b      	ldr	r3, [r7, #4]
 800a508:	66da      	str	r2, [r3, #108]	@ 0x6c
            x509->sigOID = (int)dCert->signatureOID;
 800a50a:	683b      	ldr	r3, [r7, #0]
 800a50c:	699b      	ldr	r3, [r3, #24]
 800a50e:	461a      	mov	r2, r3
 800a510:	687b      	ldr	r3, [r7, #4]
 800a512:	671a      	str	r2, [r3, #112]	@ 0x70
#endif
    }

    /* if der contains original source buffer then store for potential
     * retrieval */
    if (dCert->source != NULL && dCert->maxIdx > 0) {
 800a514:	683b      	ldr	r3, [r7, #0]
 800a516:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 800a51a:	2b00      	cmp	r3, #0
 800a51c:	d024      	beq.n	800a568 <CopyDecodedToX509+0x2c6>
 800a51e:	683b      	ldr	r3, [r7, #0]
 800a520:	f8d3 336c 	ldr.w	r3, [r3, #876]	@ 0x36c
 800a524:	2b00      	cmp	r3, #0
 800a526:	d01f      	beq.n	800a568 <CopyDecodedToX509+0x2c6>
        if (AllocDer(&x509->derCert, dCert->maxIdx, CERT_TYPE, x509->heap)
 800a528:	687b      	ldr	r3, [r7, #4]
 800a52a:	f103 008c 	add.w	r0, r3, #140	@ 0x8c
 800a52e:	683b      	ldr	r3, [r7, #0]
 800a530:	f8d3 136c 	ldr.w	r1, [r3, #876]	@ 0x36c
 800a534:	687b      	ldr	r3, [r7, #4]
 800a536:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a53a:	2200      	movs	r2, #0
 800a53c:	f00e fc4e 	bl	8018ddc <AllocDer>
 800a540:	4603      	mov	r3, r0
 800a542:	2b00      	cmp	r3, #0
 800a544:	d10d      	bne.n	800a562 <CopyDecodedToX509+0x2c0>
                                                                         == 0) {
            XMEMCPY(x509->derCert->buffer, dCert->source, dCert->maxIdx);
 800a546:	687b      	ldr	r3, [r7, #4]
 800a548:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800a54c:	6818      	ldr	r0, [r3, #0]
 800a54e:	683b      	ldr	r3, [r7, #0]
 800a550:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 800a554:	683b      	ldr	r3, [r7, #0]
 800a556:	f8d3 336c 	ldr.w	r3, [r3, #876]	@ 0x36c
 800a55a:	461a      	mov	r2, r3
 800a55c:	f01e f822 	bl	80285a4 <memcpy>
 800a560:	e002      	b.n	800a568 <CopyDecodedToX509+0x2c6>
        }
        else {
            ret = MEMORY_E;
 800a562:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a566:	60fb      	str	r3, [r7, #12]
        }
    }

    /* add alt names from dCert to X509 */
    if (CopyAltNames(&x509->altNames, dCert->altNames, -1, x509->heap) != 0) {
 800a568:	687b      	ldr	r3, [r7, #4]
 800a56a:	f103 0074 	add.w	r0, r3, #116	@ 0x74
 800a56e:	683b      	ldr	r3, [r7, #0]
 800a570:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 800a572:	687b      	ldr	r3, [r7, #4]
 800a574:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a578:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800a57c:	f7ff fe01 	bl	800a182 <CopyAltNames>
 800a580:	4603      	mov	r3, r0
 800a582:	2b00      	cmp	r3, #0
 800a584:	d002      	beq.n	800a58c <CopyDecodedToX509+0x2ea>
        return MEMORY_E;
 800a586:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a58a:	e2a3      	b.n	800aad4 <CopyDecodedToX509+0x832>
    }
#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \
    !defined(IGNORE_NAME_CONSTRAINTS)
    /* add copies of email names from dCert to X509 */
    if (CopyAltNames(&x509->altNames, dCert->altEmailNames,
 800a58c:	687b      	ldr	r3, [r7, #4]
 800a58e:	f103 0074 	add.w	r0, r3, #116	@ 0x74
 800a592:	683b      	ldr	r3, [r7, #0]
 800a594:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 800a596:	687b      	ldr	r3, [r7, #4]
 800a598:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a59c:	2201      	movs	r2, #1
 800a59e:	f7ff fdf0 	bl	800a182 <CopyAltNames>
 800a5a2:	4603      	mov	r3, r0
 800a5a4:	2b00      	cmp	r3, #0
 800a5a6:	d002      	beq.n	800a5ae <CopyDecodedToX509+0x30c>
                ASN_RFC822_TYPE, x509->heap) != 0) {
        return MEMORY_E;
 800a5a8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a5ac:	e292      	b.n	800aad4 <CopyDecodedToX509+0x832>
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */
#if defined(OPENSSL_EXTRA) && !defined(IGNORE_NAME_CONSTRAINTS)
    /* add copies of alternate directory names from dCert to X509 */
    if (CopyAltNames(&x509->altNames, dCert->altDirNames,
 800a5ae:	687b      	ldr	r3, [r7, #4]
 800a5b0:	f103 0074 	add.w	r0, r3, #116	@ 0x74
 800a5b4:	683b      	ldr	r3, [r7, #0]
 800a5b6:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 800a5b8:	687b      	ldr	r3, [r7, #4]
 800a5ba:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800a5be:	2204      	movs	r2, #4
 800a5c0:	f7ff fddf 	bl	800a182 <CopyAltNames>
 800a5c4:	4603      	mov	r3, r0
 800a5c6:	2b00      	cmp	r3, #0
 800a5c8:	d002      	beq.n	800a5d0 <CopyDecodedToX509+0x32e>
                ASN_DIR_TYPE, x509->heap) != 0) {
        return MEMORY_E;
 800a5ca:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a5ce:	e281      	b.n	800aad4 <CopyDecodedToX509+0x832>
    }
#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */
    x509->altNamesNext   = x509->altNames;  /* index hint */
 800a5d0:	687b      	ldr	r3, [r7, #4]
 800a5d2:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 800a5d4:	687b      	ldr	r3, [r7, #4]
 800a5d6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

    x509->isCa = dCert->isCA;
 800a5da:	683b      	ldr	r3, [r7, #0]
 800a5dc:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a5e0:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800a5e4:	b2d9      	uxtb	r1, r3
 800a5e6:	687a      	ldr	r2, [r7, #4]
 800a5e8:	f892 3095 	ldrb.w	r3, [r2, #149]	@ 0x95
 800a5ec:	f361 0300 	bfi	r3, r1, #0, #1
 800a5f0:	f882 3095 	strb.w	r3, [r2, #149]	@ 0x95
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    x509->pathLength = dCert->pathLength;
 800a5f4:	683b      	ldr	r3, [r7, #0]
 800a5f6:	f893 341c 	ldrb.w	r3, [r3, #1052]	@ 0x41c
 800a5fa:	461a      	mov	r2, r3
 800a5fc:	687b      	ldr	r3, [r7, #4]
 800a5fe:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4
    x509->keyUsage = dCert->extKeyUsage;
 800a602:	683b      	ldr	r3, [r7, #0]
 800a604:	f8b3 2420 	ldrh.w	r2, [r3, #1056]	@ 0x420
 800a608:	687b      	ldr	r3, [r7, #4]
 800a60a:	f8a3 20c8 	strh.w	r2, [r3, #200]	@ 0xc8

    x509->CRLdistSet = dCert->extCRLdistSet;
 800a60e:	683b      	ldr	r3, [r7, #0]
 800a610:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a614:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800a618:	b2d9      	uxtb	r1, r3
 800a61a:	687a      	ldr	r2, [r7, #4]
 800a61c:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a620:	f361 0300 	bfi	r3, r1, #0, #1
 800a624:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->CRLdistCrit = dCert->extCRLdistCrit;
 800a628:	683b      	ldr	r3, [r7, #0]
 800a62a:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a62e:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800a632:	b2d9      	uxtb	r1, r3
 800a634:	687a      	ldr	r2, [r7, #4]
 800a636:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a63a:	f361 0341 	bfi	r3, r1, #1, #1
 800a63e:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    if (dCert->extCrlInfoRaw != NULL && dCert->extCrlInfoRawSz > 0) {
 800a642:	683b      	ldr	r3, [r7, #0]
 800a644:	f8d3 33b4 	ldr.w	r3, [r3, #948]	@ 0x3b4
 800a648:	2b00      	cmp	r3, #0
 800a64a:	d029      	beq.n	800a6a0 <CopyDecodedToX509+0x3fe>
 800a64c:	683b      	ldr	r3, [r7, #0]
 800a64e:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800a652:	2b00      	cmp	r3, #0
 800a654:	dd24      	ble.n	800a6a0 <CopyDecodedToX509+0x3fe>
        x509->rawCRLInfo = (byte*)XMALLOC(dCert->extCrlInfoRawSz, x509->heap,
 800a656:	683b      	ldr	r3, [r7, #0]
 800a658:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800a65c:	4618      	mov	r0, r3
 800a65e:	f014 fa19 	bl	801ea94 <wolfSSL_Malloc>
 800a662:	4602      	mov	r2, r0
 800a664:	687b      	ldr	r3, [r7, #4]
 800a666:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
            DYNAMIC_TYPE_X509_EXT);
        if (x509->rawCRLInfo != NULL) {
 800a66a:	687b      	ldr	r3, [r7, #4]
 800a66c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 800a670:	2b00      	cmp	r3, #0
 800a672:	d012      	beq.n	800a69a <CopyDecodedToX509+0x3f8>
            XMEMCPY(x509->rawCRLInfo, dCert->extCrlInfoRaw, dCert->extCrlInfoRawSz);
 800a674:	687b      	ldr	r3, [r7, #4]
 800a676:	f8d3 00b0 	ldr.w	r0, [r3, #176]	@ 0xb0
 800a67a:	683b      	ldr	r3, [r7, #0]
 800a67c:	f8d3 13b4 	ldr.w	r1, [r3, #948]	@ 0x3b4
 800a680:	683b      	ldr	r3, [r7, #0]
 800a682:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800a686:	461a      	mov	r2, r3
 800a688:	f01d ff8c 	bl	80285a4 <memcpy>
            x509->rawCRLInfoSz = dCert->extCrlInfoRawSz;
 800a68c:	683b      	ldr	r3, [r7, #0]
 800a68e:	f8d3 23b8 	ldr.w	r2, [r3, #952]	@ 0x3b8
 800a692:	687b      	ldr	r3, [r7, #4]
 800a694:	f8c3 20cc 	str.w	r2, [r3, #204]	@ 0xcc
 800a698:	e002      	b.n	800a6a0 <CopyDecodedToX509+0x3fe>
        }
        else {
            ret = MEMORY_E;
 800a69a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a69e:	60fb      	str	r3, [r7, #12]
        }
    }
    if (dCert->extCrlInfo != NULL && dCert->extCrlInfoSz > 0) {
 800a6a0:	683b      	ldr	r3, [r7, #0]
 800a6a2:	f8d3 33bc 	ldr.w	r3, [r3, #956]	@ 0x3bc
 800a6a6:	2b00      	cmp	r3, #0
 800a6a8:	d029      	beq.n	800a6fe <CopyDecodedToX509+0x45c>
 800a6aa:	683b      	ldr	r3, [r7, #0]
 800a6ac:	f8d3 33c0 	ldr.w	r3, [r3, #960]	@ 0x3c0
 800a6b0:	2b00      	cmp	r3, #0
 800a6b2:	dd24      	ble.n	800a6fe <CopyDecodedToX509+0x45c>
        x509->CRLInfo = (byte*)XMALLOC(dCert->extCrlInfoSz, x509->heap,
 800a6b4:	683b      	ldr	r3, [r7, #0]
 800a6b6:	f8d3 33c0 	ldr.w	r3, [r3, #960]	@ 0x3c0
 800a6ba:	4618      	mov	r0, r3
 800a6bc:	f014 f9ea 	bl	801ea94 <wolfSSL_Malloc>
 800a6c0:	4602      	mov	r2, r0
 800a6c2:	687b      	ldr	r3, [r7, #4]
 800a6c4:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4
            DYNAMIC_TYPE_X509_EXT);
        if (x509->CRLInfo != NULL) {
 800a6c8:	687b      	ldr	r3, [r7, #4]
 800a6ca:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 800a6ce:	2b00      	cmp	r3, #0
 800a6d0:	d012      	beq.n	800a6f8 <CopyDecodedToX509+0x456>
            XMEMCPY(x509->CRLInfo, dCert->extCrlInfo, dCert->extCrlInfoSz);
 800a6d2:	687b      	ldr	r3, [r7, #4]
 800a6d4:	f8d3 00b4 	ldr.w	r0, [r3, #180]	@ 0xb4
 800a6d8:	683b      	ldr	r3, [r7, #0]
 800a6da:	f8d3 13bc 	ldr.w	r1, [r3, #956]	@ 0x3bc
 800a6de:	683b      	ldr	r3, [r7, #0]
 800a6e0:	f8d3 33c0 	ldr.w	r3, [r3, #960]	@ 0x3c0
 800a6e4:	461a      	mov	r2, r3
 800a6e6:	f01d ff5d 	bl	80285a4 <memcpy>
            x509->CRLInfoSz = dCert->extCrlInfoSz;
 800a6ea:	683b      	ldr	r3, [r7, #0]
 800a6ec:	f8d3 23c0 	ldr.w	r2, [r3, #960]	@ 0x3c0
 800a6f0:	687b      	ldr	r3, [r7, #4]
 800a6f2:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
 800a6f6:	e002      	b.n	800a6fe <CopyDecodedToX509+0x45c>
        }
        else {
            ret = MEMORY_E;
 800a6f8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a6fc:	60fb      	str	r3, [r7, #12]
        }
    }
    x509->authInfoSet = dCert->extAuthInfoSet;
 800a6fe:	683b      	ldr	r3, [r7, #0]
 800a700:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a704:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800a708:	b2d9      	uxtb	r1, r3
 800a70a:	687a      	ldr	r2, [r7, #4]
 800a70c:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a710:	f361 0382 	bfi	r3, r1, #2, #1
 800a714:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->authInfoCrit = dCert->extAuthInfoCrit;
 800a718:	683b      	ldr	r3, [r7, #0]
 800a71a:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a71e:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800a722:	b2d9      	uxtb	r1, r3
 800a724:	687a      	ldr	r2, [r7, #4]
 800a726:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a72a:	f361 03c3 	bfi	r3, r1, #3, #1
 800a72e:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    if (dCert->extAuthInfo != NULL && dCert->extAuthInfoSz > 0) {
 800a732:	683b      	ldr	r3, [r7, #0]
 800a734:	f8d3 33a4 	ldr.w	r3, [r3, #932]	@ 0x3a4
 800a738:	2b00      	cmp	r3, #0
 800a73a:	d029      	beq.n	800a790 <CopyDecodedToX509+0x4ee>
 800a73c:	683b      	ldr	r3, [r7, #0]
 800a73e:	f8d3 33a8 	ldr.w	r3, [r3, #936]	@ 0x3a8
 800a742:	2b00      	cmp	r3, #0
 800a744:	dd24      	ble.n	800a790 <CopyDecodedToX509+0x4ee>
        x509->authInfo = (byte*)XMALLOC(dCert->extAuthInfoSz, x509->heap,
 800a746:	683b      	ldr	r3, [r7, #0]
 800a748:	f8d3 33a8 	ldr.w	r3, [r3, #936]	@ 0x3a8
 800a74c:	4618      	mov	r0, r3
 800a74e:	f014 f9a1 	bl	801ea94 <wolfSSL_Malloc>
 800a752:	4602      	mov	r2, r0
 800a754:	687b      	ldr	r3, [r7, #4]
 800a756:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8
                DYNAMIC_TYPE_X509_EXT);
        if (x509->authInfo != NULL) {
 800a75a:	687b      	ldr	r3, [r7, #4]
 800a75c:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 800a760:	2b00      	cmp	r3, #0
 800a762:	d012      	beq.n	800a78a <CopyDecodedToX509+0x4e8>
            XMEMCPY(x509->authInfo, dCert->extAuthInfo, dCert->extAuthInfoSz);
 800a764:	687b      	ldr	r3, [r7, #4]
 800a766:	f8d3 00b8 	ldr.w	r0, [r3, #184]	@ 0xb8
 800a76a:	683b      	ldr	r3, [r7, #0]
 800a76c:	f8d3 13a4 	ldr.w	r1, [r3, #932]	@ 0x3a4
 800a770:	683b      	ldr	r3, [r7, #0]
 800a772:	f8d3 33a8 	ldr.w	r3, [r3, #936]	@ 0x3a8
 800a776:	461a      	mov	r2, r3
 800a778:	f01d ff14 	bl	80285a4 <memcpy>
            x509->authInfoSz = dCert->extAuthInfoSz;
 800a77c:	683b      	ldr	r3, [r7, #0]
 800a77e:	f8d3 23a8 	ldr.w	r2, [r3, #936]	@ 0x3a8
 800a782:	687b      	ldr	r3, [r7, #4]
 800a784:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
 800a788:	e002      	b.n	800a790 <CopyDecodedToX509+0x4ee>
        }
        else {
            ret = MEMORY_E;
 800a78a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a78e:	60fb      	str	r3, [r7, #12]
        }
    }
    #ifdef WOLFSSL_ASN_CA_ISSUER
    if (dCert->extAuthInfoCaIssuer != NULL && dCert->extAuthInfoCaIssuerSz > 0) {
 800a790:	683b      	ldr	r3, [r7, #0]
 800a792:	f8d3 33ac 	ldr.w	r3, [r3, #940]	@ 0x3ac
 800a796:	2b00      	cmp	r3, #0
 800a798:	d029      	beq.n	800a7ee <CopyDecodedToX509+0x54c>
 800a79a:	683b      	ldr	r3, [r7, #0]
 800a79c:	f8d3 33b0 	ldr.w	r3, [r3, #944]	@ 0x3b0
 800a7a0:	2b00      	cmp	r3, #0
 800a7a2:	dd24      	ble.n	800a7ee <CopyDecodedToX509+0x54c>
        x509->authInfoCaIssuer = (byte*)XMALLOC(dCert->extAuthInfoCaIssuerSz, x509->heap,
 800a7a4:	683b      	ldr	r3, [r7, #0]
 800a7a6:	f8d3 33b0 	ldr.w	r3, [r3, #944]	@ 0x3b0
 800a7aa:	4618      	mov	r0, r3
 800a7ac:	f014 f972 	bl	801ea94 <wolfSSL_Malloc>
 800a7b0:	4602      	mov	r2, r0
 800a7b2:	687b      	ldr	r3, [r7, #4]
 800a7b4:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
                DYNAMIC_TYPE_X509_EXT);
        if (x509->authInfoCaIssuer != NULL) {
 800a7b8:	687b      	ldr	r3, [r7, #4]
 800a7ba:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800a7be:	2b00      	cmp	r3, #0
 800a7c0:	d012      	beq.n	800a7e8 <CopyDecodedToX509+0x546>
            XMEMCPY(x509->authInfoCaIssuer, dCert->extAuthInfoCaIssuer, dCert->extAuthInfoCaIssuerSz);
 800a7c2:	687b      	ldr	r3, [r7, #4]
 800a7c4:	f8d3 00bc 	ldr.w	r0, [r3, #188]	@ 0xbc
 800a7c8:	683b      	ldr	r3, [r7, #0]
 800a7ca:	f8d3 13ac 	ldr.w	r1, [r3, #940]	@ 0x3ac
 800a7ce:	683b      	ldr	r3, [r7, #0]
 800a7d0:	f8d3 33b0 	ldr.w	r3, [r3, #944]	@ 0x3b0
 800a7d4:	461a      	mov	r2, r3
 800a7d6:	f01d fee5 	bl	80285a4 <memcpy>
            x509->authInfoCaIssuerSz = dCert->extAuthInfoCaIssuerSz;
 800a7da:	683b      	ldr	r3, [r7, #0]
 800a7dc:	f8d3 23b0 	ldr.w	r2, [r3, #944]	@ 0x3b0
 800a7e0:	687b      	ldr	r3, [r7, #4]
 800a7e2:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
 800a7e6:	e002      	b.n	800a7ee <CopyDecodedToX509+0x54c>
        }
        else {
            ret = MEMORY_E;
 800a7e8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a7ec:	60fb      	str	r3, [r7, #12]
        }
    }
    #endif
    x509->basicConstSet = dCert->extBasicConstSet;
 800a7ee:	683b      	ldr	r3, [r7, #0]
 800a7f0:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a7f4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800a7f8:	b2d9      	uxtb	r1, r3
 800a7fa:	687a      	ldr	r2, [r7, #4]
 800a7fc:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a800:	f361 0341 	bfi	r3, r1, #1, #1
 800a804:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->basicConstCrit = dCert->extBasicConstCrit;
 800a808:	683b      	ldr	r3, [r7, #0]
 800a80a:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a80e:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800a812:	b2d9      	uxtb	r1, r3
 800a814:	687a      	ldr	r2, [r7, #4]
 800a816:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a81a:	f361 0382 	bfi	r3, r1, #2, #1
 800a81e:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->basicConstPlSet = dCert->pathLengthSet;
 800a822:	683b      	ldr	r3, [r7, #0]
 800a824:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a828:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800a82c:	b2d9      	uxtb	r1, r3
 800a82e:	687a      	ldr	r2, [r7, #4]
 800a830:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a834:	f361 03c3 	bfi	r3, r1, #3, #1
 800a838:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->subjAltNameSet = dCert->extSubjAltNameSet;
 800a83c:	683b      	ldr	r3, [r7, #0]
 800a83e:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 800a842:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800a846:	b2d9      	uxtb	r1, r3
 800a848:	687a      	ldr	r2, [r7, #4]
 800a84a:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a84e:	f361 1304 	bfi	r3, r1, #4, #1
 800a852:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->subjAltNameCrit = dCert->extSubjAltNameCrit;
 800a856:	683b      	ldr	r3, [r7, #0]
 800a858:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a85c:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800a860:	b2d9      	uxtb	r1, r3
 800a862:	687a      	ldr	r2, [r7, #4]
 800a864:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a868:	f361 1345 	bfi	r3, r1, #5, #1
 800a86c:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->authKeyIdSet = dCert->extAuthKeyIdSet;
 800a870:	683b      	ldr	r3, [r7, #0]
 800a872:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a876:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800a87a:	b2d9      	uxtb	r1, r3
 800a87c:	687a      	ldr	r2, [r7, #4]
 800a87e:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a882:	f361 1386 	bfi	r3, r1, #6, #1
 800a886:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    x509->authKeyIdCrit = dCert->extAuthKeyIdCrit;
 800a88a:	683b      	ldr	r3, [r7, #0]
 800a88c:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800a890:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800a894:	b2d9      	uxtb	r1, r3
 800a896:	687a      	ldr	r2, [r7, #4]
 800a898:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a89c:	f361 13c7 	bfi	r3, r1, #7, #1
 800a8a0:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    if (dCert->extAuthKeyIdSrc != NULL && dCert->extAuthKeyIdSz != 0) {
 800a8a4:	683b      	ldr	r3, [r7, #0]
 800a8a6:	f8d3 3438 	ldr.w	r3, [r3, #1080]	@ 0x438
 800a8aa:	2b00      	cmp	r3, #0
 800a8ac:	d05a      	beq.n	800a964 <CopyDecodedToX509+0x6c2>
 800a8ae:	683b      	ldr	r3, [r7, #0]
 800a8b0:	f8d3 3408 	ldr.w	r3, [r3, #1032]	@ 0x408
 800a8b4:	2b00      	cmp	r3, #0
 800a8b6:	d055      	beq.n	800a964 <CopyDecodedToX509+0x6c2>
    #ifdef WOLFSSL_AKID_NAME
        if (dCert->extRawAuthKeyIdSrc != NULL &&
 800a8b8:	683b      	ldr	r3, [r7, #0]
 800a8ba:	f8d3 3430 	ldr.w	r3, [r3, #1072]	@ 0x430
 800a8be:	2b00      	cmp	r3, #0
 800a8c0:	d04d      	beq.n	800a95e <CopyDecodedToX509+0x6bc>
                dCert->extAuthKeyIdSrc > dCert->extRawAuthKeyIdSrc &&
 800a8c2:	683b      	ldr	r3, [r7, #0]
 800a8c4:	f8d3 2438 	ldr.w	r2, [r3, #1080]	@ 0x438
 800a8c8:	683b      	ldr	r3, [r7, #0]
 800a8ca:	f8d3 3430 	ldr.w	r3, [r3, #1072]	@ 0x430
        if (dCert->extRawAuthKeyIdSrc != NULL &&
 800a8ce:	429a      	cmp	r2, r3
 800a8d0:	d945      	bls.n	800a95e <CopyDecodedToX509+0x6bc>
                dCert->extAuthKeyIdSrc <
 800a8d2:	683b      	ldr	r3, [r7, #0]
 800a8d4:	f8d3 2438 	ldr.w	r2, [r3, #1080]	@ 0x438
                    (dCert->extRawAuthKeyIdSrc + dCert->extRawAuthKeyIdSz)) {
 800a8d8:	683b      	ldr	r3, [r7, #0]
 800a8da:	f8d3 1430 	ldr.w	r1, [r3, #1072]	@ 0x430
 800a8de:	683b      	ldr	r3, [r7, #0]
 800a8e0:	f8d3 3434 	ldr.w	r3, [r3, #1076]	@ 0x434
 800a8e4:	440b      	add	r3, r1
                dCert->extAuthKeyIdSrc > dCert->extRawAuthKeyIdSrc &&
 800a8e6:	429a      	cmp	r2, r3
 800a8e8:	d239      	bcs.n	800a95e <CopyDecodedToX509+0x6bc>
            /* Confirmed: extAuthKeyIdSrc points inside extRawAuthKeyIdSrc */
            x509->authKeyIdSrc = (byte*)XMALLOC(dCert->extRawAuthKeyIdSz,
 800a8ea:	683b      	ldr	r3, [r7, #0]
 800a8ec:	f8d3 3434 	ldr.w	r3, [r3, #1076]	@ 0x434
 800a8f0:	4618      	mov	r0, r3
 800a8f2:	f014 f8cf 	bl	801ea94 <wolfSSL_Malloc>
 800a8f6:	4602      	mov	r2, r0
 800a8f8:	687b      	ldr	r3, [r7, #4]
 800a8fa:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
                    x509->heap, DYNAMIC_TYPE_X509_EXT);
            if (x509->authKeyIdSrc != NULL) {
 800a8fe:	687b      	ldr	r3, [r7, #4]
 800a900:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 800a904:	2b00      	cmp	r3, #0
 800a906:	d026      	beq.n	800a956 <CopyDecodedToX509+0x6b4>
                XMEMCPY(x509->authKeyIdSrc, dCert->extRawAuthKeyIdSrc,
 800a908:	687b      	ldr	r3, [r7, #4]
 800a90a:	f8d3 00a0 	ldr.w	r0, [r3, #160]	@ 0xa0
 800a90e:	683b      	ldr	r3, [r7, #0]
 800a910:	f8d3 1430 	ldr.w	r1, [r3, #1072]	@ 0x430
 800a914:	683b      	ldr	r3, [r7, #0]
 800a916:	f8d3 3434 	ldr.w	r3, [r3, #1076]	@ 0x434
 800a91a:	461a      	mov	r2, r3
 800a91c:	f01d fe42 	bl	80285a4 <memcpy>
                        dCert->extRawAuthKeyIdSz);
                x509->authKeyIdSrcSz = dCert->extRawAuthKeyIdSz;
 800a920:	683b      	ldr	r3, [r7, #0]
 800a922:	f8d3 2434 	ldr.w	r2, [r3, #1076]	@ 0x434
 800a926:	687b      	ldr	r3, [r7, #4]
 800a928:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
                /* Set authKeyId to same offset inside authKeyIdSrc */
                x509->authKeyId = x509->authKeyIdSrc +
 800a92c:	687b      	ldr	r3, [r7, #4]
 800a92e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
                        (dCert->extAuthKeyIdSrc - dCert->extRawAuthKeyIdSrc);
 800a932:	683a      	ldr	r2, [r7, #0]
 800a934:	f8d2 1438 	ldr.w	r1, [r2, #1080]	@ 0x438
 800a938:	683a      	ldr	r2, [r7, #0]
 800a93a:	f8d2 2430 	ldr.w	r2, [r2, #1072]	@ 0x430
 800a93e:	1a8a      	subs	r2, r1, r2
                x509->authKeyId = x509->authKeyIdSrc +
 800a940:	441a      	add	r2, r3
 800a942:	687b      	ldr	r3, [r7, #4]
 800a944:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
                x509->authKeyIdSz = dCert->extAuthKeyIdSz;
 800a948:	683b      	ldr	r3, [r7, #0]
 800a94a:	f8d3 2408 	ldr.w	r2, [r3, #1032]	@ 0x408
 800a94e:	687b      	ldr	r3, [r7, #4]
 800a950:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
            if (x509->authKeyIdSrc != NULL) {
 800a954:	e006      	b.n	800a964 <CopyDecodedToX509+0x6c2>
            }
            else
                ret = MEMORY_E;
 800a956:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a95a:	60fb      	str	r3, [r7, #12]
            if (x509->authKeyIdSrc != NULL) {
 800a95c:	e002      	b.n	800a964 <CopyDecodedToX509+0x6c2>
                                 dCert->extAuthKeyIdSrc, dCert->extAuthKeyIdSz);
            x509->authKeyIdSz = dCert->extAuthKeyIdSz;
        }
    #endif
        else
            ret = MEMORY_E;
 800a95e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a962:	60fb      	str	r3, [r7, #12]
    }
    x509->subjKeyIdSet = dCert->extSubjKeyIdSet;
 800a964:	683b      	ldr	r3, [r7, #0]
 800a966:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a96a:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800a96e:	b2d9      	uxtb	r1, r3
 800a970:	687a      	ldr	r2, [r7, #4]
 800a972:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800a976:	f361 13c7 	bfi	r3, r1, #7, #1
 800a97a:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->subjKeyIdCrit = dCert->extSubjKeyIdCrit;
 800a97e:	683b      	ldr	r3, [r7, #0]
 800a980:	f893 34b7 	ldrb.w	r3, [r3, #1207]	@ 0x4b7
 800a984:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800a988:	b2d9      	uxtb	r1, r3
 800a98a:	687a      	ldr	r2, [r7, #4]
 800a98c:	f892 30f2 	ldrb.w	r3, [r2, #242]	@ 0xf2
 800a990:	f361 0300 	bfi	r3, r1, #0, #1
 800a994:	f882 30f2 	strb.w	r3, [r2, #242]	@ 0xf2
    if (dCert->extSubjKeyIdSrc != NULL && dCert->extSubjKeyIdSz != 0) {
 800a998:	683b      	ldr	r3, [r7, #0]
 800a99a:	f8d3 343c 	ldr.w	r3, [r3, #1084]	@ 0x43c
 800a99e:	2b00      	cmp	r3, #0
 800a9a0:	d029      	beq.n	800a9f6 <CopyDecodedToX509+0x754>
 800a9a2:	683b      	ldr	r3, [r7, #0]
 800a9a4:	f8d3 33e4 	ldr.w	r3, [r3, #996]	@ 0x3e4
 800a9a8:	2b00      	cmp	r3, #0
 800a9aa:	d024      	beq.n	800a9f6 <CopyDecodedToX509+0x754>
        x509->subjKeyId = (byte*)XMALLOC(dCert->extSubjKeyIdSz, x509->heap,
 800a9ac:	683b      	ldr	r3, [r7, #0]
 800a9ae:	f8d3 33e4 	ldr.w	r3, [r3, #996]	@ 0x3e4
 800a9b2:	4618      	mov	r0, r3
 800a9b4:	f014 f86e 	bl	801ea94 <wolfSSL_Malloc>
 800a9b8:	4602      	mov	r2, r0
 800a9ba:	687b      	ldr	r3, [r7, #4]
 800a9bc:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
                                         DYNAMIC_TYPE_X509_EXT);
        if (x509->subjKeyId != NULL) {
 800a9c0:	687b      	ldr	r3, [r7, #4]
 800a9c2:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800a9c6:	2b00      	cmp	r3, #0
 800a9c8:	d012      	beq.n	800a9f0 <CopyDecodedToX509+0x74e>
            XMEMCPY(x509->subjKeyId,
 800a9ca:	687b      	ldr	r3, [r7, #4]
 800a9cc:	f8d3 00a4 	ldr.w	r0, [r3, #164]	@ 0xa4
 800a9d0:	683b      	ldr	r3, [r7, #0]
 800a9d2:	f8d3 143c 	ldr.w	r1, [r3, #1084]	@ 0x43c
 800a9d6:	683b      	ldr	r3, [r7, #0]
 800a9d8:	f8d3 33e4 	ldr.w	r3, [r3, #996]	@ 0x3e4
 800a9dc:	461a      	mov	r2, r3
 800a9de:	f01d fde1 	bl	80285a4 <memcpy>
                                 dCert->extSubjKeyIdSrc, dCert->extSubjKeyIdSz);
            x509->subjKeyIdSz = dCert->extSubjKeyIdSz;
 800a9e2:	683b      	ldr	r3, [r7, #0]
 800a9e4:	f8d3 23e4 	ldr.w	r2, [r3, #996]	@ 0x3e4
 800a9e8:	687b      	ldr	r3, [r7, #4]
 800a9ea:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800a9ee:	e002      	b.n	800a9f6 <CopyDecodedToX509+0x754>
        }
        else
            ret = MEMORY_E;
 800a9f0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800a9f4:	60fb      	str	r3, [r7, #12]
    }
    x509->keyUsageSet = dCert->extKeyUsageSet;
 800a9f6:	683b      	ldr	r3, [r7, #0]
 800a9f8:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800a9fc:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800aa00:	b2d9      	uxtb	r1, r3
 800aa02:	687a      	ldr	r2, [r7, #4]
 800aa04:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800aa08:	f361 1304 	bfi	r3, r1, #4, #1
 800aa0c:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    x509->keyUsageCrit = dCert->extKeyUsageCrit;
 800aa10:	683b      	ldr	r3, [r7, #0]
 800aa12:	f893 34b7 	ldrb.w	r3, [r3, #1207]	@ 0x4b7
 800aa16:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800aa1a:	b2d9      	uxtb	r1, r3
 800aa1c:	687a      	ldr	r2, [r7, #4]
 800aa1e:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800aa22:	f361 1345 	bfi	r3, r1, #5, #1
 800aa26:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
    if (dCert->extExtKeyUsageSrc != NULL && dCert->extExtKeyUsageSz > 0) {
 800aa2a:	683b      	ldr	r3, [r7, #0]
 800aa2c:	f8d3 3424 	ldr.w	r3, [r3, #1060]	@ 0x424
 800aa30:	2b00      	cmp	r3, #0
 800aa32:	d042      	beq.n	800aaba <CopyDecodedToX509+0x818>
 800aa34:	683b      	ldr	r3, [r7, #0]
 800aa36:	f8d3 3428 	ldr.w	r3, [r3, #1064]	@ 0x428
 800aa3a:	2b00      	cmp	r3, #0
 800aa3c:	d03d      	beq.n	800aaba <CopyDecodedToX509+0x818>
        x509->extKeyUsageSrc = (byte*)XMALLOC(dCert->extExtKeyUsageSz,
 800aa3e:	683b      	ldr	r3, [r7, #0]
 800aa40:	f8d3 3428 	ldr.w	r3, [r3, #1064]	@ 0x428
 800aa44:	4618      	mov	r0, r3
 800aa46:	f014 f825 	bl	801ea94 <wolfSSL_Malloc>
 800aa4a:	4602      	mov	r2, r0
 800aa4c:	687b      	ldr	r3, [r7, #4]
 800aa4e:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
                x509->heap, DYNAMIC_TYPE_X509_EXT);
        if (x509->extKeyUsageSrc != NULL) {
 800aa52:	687b      	ldr	r3, [r7, #4]
 800aa54:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 800aa58:	2b00      	cmp	r3, #0
 800aa5a:	d02b      	beq.n	800aab4 <CopyDecodedToX509+0x812>
            XMEMCPY(x509->extKeyUsageSrc, dCert->extExtKeyUsageSrc,
 800aa5c:	687b      	ldr	r3, [r7, #4]
 800aa5e:	f8d3 00ac 	ldr.w	r0, [r3, #172]	@ 0xac
 800aa62:	683b      	ldr	r3, [r7, #0]
 800aa64:	f8d3 1424 	ldr.w	r1, [r3, #1060]	@ 0x424
 800aa68:	683b      	ldr	r3, [r7, #0]
 800aa6a:	f8d3 3428 	ldr.w	r3, [r3, #1064]	@ 0x428
 800aa6e:	461a      	mov	r2, r3
 800aa70:	f01d fd98 	bl	80285a4 <memcpy>
                                                       dCert->extExtKeyUsageSz);
            x509->extKeyUsage      = dCert->extExtKeyUsage;
 800aa74:	683b      	ldr	r3, [r7, #0]
 800aa76:	f893 2422 	ldrb.w	r2, [r3, #1058]	@ 0x422
 800aa7a:	687b      	ldr	r3, [r7, #4]
 800aa7c:	f883 20e4 	strb.w	r2, [r3, #228]	@ 0xe4
            x509->extKeyUsageSz    = dCert->extExtKeyUsageSz;
 800aa80:	683b      	ldr	r3, [r7, #0]
 800aa82:	f8d3 2428 	ldr.w	r2, [r3, #1064]	@ 0x428
 800aa86:	687b      	ldr	r3, [r7, #4]
 800aa88:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
            x509->extKeyUsageCrit  = dCert->extExtKeyUsageCrit;
 800aa8c:	683b      	ldr	r3, [r7, #0]
 800aa8e:	f893 34b7 	ldrb.w	r3, [r3, #1207]	@ 0x4b7
 800aa92:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800aa96:	b2d9      	uxtb	r1, r3
 800aa98:	687a      	ldr	r2, [r7, #4]
 800aa9a:	f892 30f1 	ldrb.w	r3, [r2, #241]	@ 0xf1
 800aa9e:	f361 1386 	bfi	r3, r1, #6, #1
 800aaa2:	f882 30f1 	strb.w	r3, [r2, #241]	@ 0xf1
            x509->extKeyUsageCount = dCert->extExtKeyUsageCount;
 800aaa6:	683b      	ldr	r3, [r7, #0]
 800aaa8:	f8d3 242c 	ldr.w	r2, [r3, #1068]	@ 0x42c
 800aaac:	687b      	ldr	r3, [r7, #4]
 800aaae:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
 800aab2:	e002      	b.n	800aaba <CopyDecodedToX509+0x818>
        }
        else {
            ret = MEMORY_E;
 800aab4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800aab8:	60fb      	str	r3, [r7, #12]
        }
    }
    #ifndef IGNORE_NETSCAPE_CERT_TYPE
    x509->nsCertType = dCert->nsCertType;
 800aaba:	683b      	ldr	r3, [r7, #0]
 800aabc:	f893 246c 	ldrb.w	r2, [r3, #1132]	@ 0x46c
 800aac0:	687b      	ldr	r3, [r7, #4]
 800aac2:	f883 20f0 	strb.w	r2, [r3, #240]	@ 0xf0
        else
            ret = MEMORY_E;
    }
#endif
#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    x509->pkCurveOID = dCert->pkCurveOID;
 800aac6:	683b      	ldr	r3, [r7, #0]
 800aac8:	f8d3 2440 	ldr.w	r2, [r3, #1088]	@ 0x440
 800aacc:	687b      	ldr	r3, [r7, #4]
 800aace:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
            ret = MEMORY_E;
        }
    }
#endif /* WOLFSSL_DUAL_ALG_CERTS */

    return ret;
 800aad2:	68fb      	ldr	r3, [r7, #12]
}
 800aad4:	4618      	mov	r0, r3
 800aad6:	3710      	adds	r7, #16
 800aad8:	46bd      	mov	sp, r7
 800aada:	bd80      	pop	{r7, pc}

0800aadc <SetupStoreCtxCallback>:
}

int SetupStoreCtxCallback(WOLFSSL_X509_STORE_CTX** store_pt,
        WOLFSSL* ssl, WOLFSSL_CERT_MANAGER* cm, ProcPeerCertArgs* args,
        int cert_err, void* heap, int* x509Free)
{
 800aadc:	b580      	push	{r7, lr}
 800aade:	b08a      	sub	sp, #40	@ 0x28
 800aae0:	af00      	add	r7, sp, #0
 800aae2:	60f8      	str	r0, [r7, #12]
 800aae4:	60b9      	str	r1, [r7, #8]
 800aae6:	607a      	str	r2, [r7, #4]
 800aae8:	603b      	str	r3, [r7, #0]
    WOLFSSL_X509_STORE_CTX* store = NULL;
 800aaea:	2300      	movs	r3, #0
 800aaec:	61bb      	str	r3, [r7, #24]
    char* domain = NULL;
 800aaee:	2300      	movs	r3, #0
 800aaf0:	627b      	str	r3, [r7, #36]	@ 0x24
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    WOLFSSL_X509* x509 = NULL;
 800aaf2:	2300      	movs	r3, #0
 800aaf4:	623b      	str	r3, [r7, #32]
#endif

    *x509Free = 0;
 800aaf6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800aaf8:	2200      	movs	r2, #0
 800aafa:	601a      	str	r2, [r3, #0]

    store = wolfSSL_X509_STORE_CTX_new_ex(heap);
 800aafc:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 800aafe:	f004 fa19 	bl	800ef34 <wolfSSL_X509_STORE_CTX_new_ex>
 800ab02:	61b8      	str	r0, [r7, #24]
    if (store == NULL)
 800ab04:	69bb      	ldr	r3, [r7, #24]
 800ab06:	2b00      	cmp	r3, #0
 800ab08:	f000 8177 	beq.w	800adfa <SetupStoreCtxCallback+0x31e>
        goto mem_error;
    domain = (char*)XMALLOC(ASN_NAME_MAX, heap, DYNAMIC_TYPE_STRING);
 800ab0c:	f44f 70b4 	mov.w	r0, #360	@ 0x168
 800ab10:	f013 ffc0 	bl	801ea94 <wolfSSL_Malloc>
 800ab14:	6278      	str	r0, [r7, #36]	@ 0x24
    if (domain == NULL)
 800ab16:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ab18:	2b00      	cmp	r3, #0
 800ab1a:	f000 8170 	beq.w	800adfe <SetupStoreCtxCallback+0x322>
        goto mem_error;

    domain[0] = '\0';
 800ab1e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ab20:	2200      	movs	r2, #0
 800ab22:	701a      	strb	r2, [r3, #0]

    /* build subject CN as string to return in store */
    if (args->dCertInit && args->dCert && args->dCert->subjectCN) {
 800ab24:	683b      	ldr	r3, [r7, #0]
 800ab26:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800ab2a:	f003 0304 	and.w	r3, r3, #4
 800ab2e:	b2db      	uxtb	r3, r3
 800ab30:	2b00      	cmp	r3, #0
 800ab32:	d026      	beq.n	800ab82 <SetupStoreCtxCallback+0xa6>
 800ab34:	683b      	ldr	r3, [r7, #0]
 800ab36:	689b      	ldr	r3, [r3, #8]
 800ab38:	2b00      	cmp	r3, #0
 800ab3a:	d022      	beq.n	800ab82 <SetupStoreCtxCallback+0xa6>
 800ab3c:	683b      	ldr	r3, [r7, #0]
 800ab3e:	689b      	ldr	r3, [r3, #8]
 800ab40:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800ab44:	2b00      	cmp	r3, #0
 800ab46:	d01c      	beq.n	800ab82 <SetupStoreCtxCallback+0xa6>
        int subjectCNLen = args->dCert->subjectCNLen;
 800ab48:	683b      	ldr	r3, [r7, #0]
 800ab4a:	689b      	ldr	r3, [r3, #8]
 800ab4c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800ab50:	61fb      	str	r3, [r7, #28]
        if (subjectCNLen > ASN_NAME_MAX-1)
 800ab52:	69fb      	ldr	r3, [r7, #28]
 800ab54:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 800ab58:	db02      	blt.n	800ab60 <SetupStoreCtxCallback+0x84>
            subjectCNLen = ASN_NAME_MAX-1;
 800ab5a:	f240 1367 	movw	r3, #359	@ 0x167
 800ab5e:	61fb      	str	r3, [r7, #28]
        if (subjectCNLen > 0) {
 800ab60:	69fb      	ldr	r3, [r7, #28]
 800ab62:	2b00      	cmp	r3, #0
 800ab64:	dd0d      	ble.n	800ab82 <SetupStoreCtxCallback+0xa6>
            XMEMCPY(domain, args->dCert->subjectCN, subjectCNLen);
 800ab66:	683b      	ldr	r3, [r7, #0]
 800ab68:	689b      	ldr	r3, [r3, #8]
 800ab6a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800ab6e:	69fa      	ldr	r2, [r7, #28]
 800ab70:	4619      	mov	r1, r3
 800ab72:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800ab74:	f01d fd16 	bl	80285a4 <memcpy>
            domain[subjectCNLen] = '\0';
 800ab78:	69fb      	ldr	r3, [r7, #28]
 800ab7a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ab7c:	4413      	add	r3, r2
 800ab7e:	2200      	movs	r2, #0
 800ab80:	701a      	strb	r2, [r3, #0]
        }
    }

#ifndef OPENSSL_COMPATIBLE_DEFAULTS
    store->error = cert_err;
 800ab82:	69bb      	ldr	r3, [r7, #24]
 800ab84:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800ab86:	625a      	str	r2, [r3, #36]	@ 0x24
#else
    store->error = GetX509Error(cert_err);
#endif
    store->error_depth = args->certIdx;
 800ab88:	683b      	ldr	r3, [r7, #0]
 800ab8a:	69da      	ldr	r2, [r3, #28]
 800ab8c:	69bb      	ldr	r3, [r7, #24]
 800ab8e:	629a      	str	r2, [r3, #40]	@ 0x28
    store->discardSessionCerts = 0;
 800ab90:	69bb      	ldr	r3, [r7, #24]
 800ab92:	2200      	movs	r2, #0
 800ab94:	62da      	str	r2, [r3, #44]	@ 0x2c
    store->domain = domain;
 800ab96:	69bb      	ldr	r3, [r7, #24]
 800ab98:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ab9a:	619a      	str	r2, [r3, #24]
    if (ssl != NULL) {
 800ab9c:	68bb      	ldr	r3, [r7, #8]
 800ab9e:	2b00      	cmp	r3, #0
 800aba0:	d011      	beq.n	800abc6 <SetupStoreCtxCallback+0xea>
        if (ssl->verifyCbCtx != NULL) {
 800aba2:	68bb      	ldr	r3, [r7, #8]
 800aba4:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800aba8:	2b00      	cmp	r3, #0
 800abaa:	d005      	beq.n	800abb8 <SetupStoreCtxCallback+0xdc>
            /* Use the WOLFSSL user context if set */
            store->userCtx = ssl->verifyCbCtx;
 800abac:	68bb      	ldr	r3, [r7, #8]
 800abae:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 800abb2:	69bb      	ldr	r3, [r7, #24]
 800abb4:	621a      	str	r2, [r3, #32]
 800abb6:	e009      	b.n	800abcc <SetupStoreCtxCallback+0xf0>
        }
        else {
            /* Else use the WOLFSSL_CTX user context */
            store->userCtx = ssl->ctx->verifyCbCtx;
 800abb8:	68bb      	ldr	r3, [r7, #8]
 800abba:	681b      	ldr	r3, [r3, #0]
 800abbc:	f8d3 20b8 	ldr.w	r2, [r3, #184]	@ 0xb8
 800abc0:	69bb      	ldr	r3, [r7, #24]
 800abc2:	621a      	str	r2, [r3, #32]
 800abc4:	e002      	b.n	800abcc <SetupStoreCtxCallback+0xf0>
        }
    }
    else {
        store->userCtx = cm;
 800abc6:	69bb      	ldr	r3, [r7, #24]
 800abc8:	687a      	ldr	r2, [r7, #4]
 800abca:	621a      	str	r2, [r3, #32]
    }
    store->certs = args->certs;
 800abcc:	683b      	ldr	r3, [r7, #0]
 800abce:	681a      	ldr	r2, [r3, #0]
 800abd0:	69bb      	ldr	r3, [r7, #24]
 800abd2:	635a      	str	r2, [r3, #52]	@ 0x34
    store->totalCerts = args->totalCerts;
 800abd4:	683b      	ldr	r3, [r7, #0]
 800abd6:	695a      	ldr	r2, [r3, #20]
 800abd8:	69bb      	ldr	r3, [r7, #24]
 800abda:	631a      	str	r2, [r3, #48]	@ 0x30
            != WOLFSSL_SUCCESS) {
        WOLFSSL_MSG("Failed to store ssl context in WOLFSSL_X509_STORE_CTX");
    }
#endif

    if (ssl != NULL) {
 800abdc:	68bb      	ldr	r3, [r7, #8]
 800abde:	2b00      	cmp	r3, #0
 800abe0:	f000 8106 	beq.w	800adf0 <SetupStoreCtxCallback+0x314>
#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER)
        store->store = SSL_STORE(ssl);
 800abe4:	68bb      	ldr	r3, [r7, #8]
 800abe6:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800abea:	2b00      	cmp	r3, #0
 800abec:	d003      	beq.n	800abf6 <SetupStoreCtxCallback+0x11a>
 800abee:	68bb      	ldr	r3, [r7, #8]
 800abf0:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800abf4:	e00d      	b.n	800ac12 <SetupStoreCtxCallback+0x136>
 800abf6:	68bb      	ldr	r3, [r7, #8]
 800abf8:	681b      	ldr	r3, [r3, #0]
 800abfa:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800abfe:	2b00      	cmp	r3, #0
 800ac00:	d004      	beq.n	800ac0c <SetupStoreCtxCallback+0x130>
 800ac02:	68bb      	ldr	r3, [r7, #8]
 800ac04:	681b      	ldr	r3, [r3, #0]
 800ac06:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ac0a:	e002      	b.n	800ac12 <SetupStoreCtxCallback+0x136>
 800ac0c:	68bb      	ldr	r3, [r7, #8]
 800ac0e:	681b      	ldr	r3, [r3, #0]
 800ac10:	33f4      	adds	r3, #244	@ 0xf4
 800ac12:	69ba      	ldr	r2, [r7, #24]
 800ac14:	6013      	str	r3, [r2, #0]
#if defined(OPENSSL_EXTRA)
        store->depth = args->count;
 800ac16:	683b      	ldr	r3, [r7, #0]
 800ac18:	699a      	ldr	r2, [r3, #24]
 800ac1a:	69bb      	ldr	r3, [r7, #24]
 800ac1c:	61da      	str	r2, [r3, #28]
        /* Overwrite with non-default param values in SSL */
        if (ssl->param) {
 800ac1e:	68bb      	ldr	r3, [r7, #8]
 800ac20:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ac24:	2b00      	cmp	r3, #0
 800ac26:	f000 80aa 	beq.w	800ad7e <SetupStoreCtxCallback+0x2a2>
            if (ssl->param->check_time)
 800ac2a:	68bb      	ldr	r3, [r7, #8]
 800ac2c:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ac30:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ac34:	4313      	orrs	r3, r2
 800ac36:	d008      	beq.n	800ac4a <SetupStoreCtxCallback+0x16e>
                store->param->check_time = ssl->param->check_time;
 800ac38:	68bb      	ldr	r3, [r7, #8]
 800ac3a:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ac3e:	69ba      	ldr	r2, [r7, #24]
 800ac40:	6951      	ldr	r1, [r2, #20]
 800ac42:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ac46:	e9c1 2302 	strd	r2, r3, [r1, #8]

            if (ssl->param->flags)
 800ac4a:	68bb      	ldr	r3, [r7, #8]
 800ac4c:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ac50:	695b      	ldr	r3, [r3, #20]
 800ac52:	2b00      	cmp	r3, #0
 800ac54:	d007      	beq.n	800ac66 <SetupStoreCtxCallback+0x18a>
                store->param->flags = ssl->param->flags;
 800ac56:	68bb      	ldr	r3, [r7, #8]
 800ac58:	f8d3 2334 	ldr.w	r2, [r3, #820]	@ 0x334
 800ac5c:	69bb      	ldr	r3, [r7, #24]
 800ac5e:	695b      	ldr	r3, [r3, #20]
 800ac60:	6952      	ldr	r2, [r2, #20]
 800ac62:	615a      	str	r2, [r3, #20]
 800ac64:	e078      	b.n	800ad58 <SetupStoreCtxCallback+0x27c>
#ifdef WOLFSSL_LOCAL_X509_STORE
            else if (SSL_STORE(ssl) && SSL_STORE(ssl)->param &&
 800ac66:	68bb      	ldr	r3, [r7, #8]
 800ac68:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ac6c:	2b00      	cmp	r3, #0
 800ac6e:	d008      	beq.n	800ac82 <SetupStoreCtxCallback+0x1a6>
 800ac70:	68bb      	ldr	r3, [r7, #8]
 800ac72:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ac76:	2b00      	cmp	r3, #0
 800ac78:	bf14      	ite	ne
 800ac7a:	2301      	movne	r3, #1
 800ac7c:	2300      	moveq	r3, #0
 800ac7e:	b2db      	uxtb	r3, r3
 800ac80:	e017      	b.n	800acb2 <SetupStoreCtxCallback+0x1d6>
 800ac82:	68bb      	ldr	r3, [r7, #8]
 800ac84:	681b      	ldr	r3, [r3, #0]
 800ac86:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ac8a:	2b00      	cmp	r3, #0
 800ac8c:	d009      	beq.n	800aca2 <SetupStoreCtxCallback+0x1c6>
 800ac8e:	68bb      	ldr	r3, [r7, #8]
 800ac90:	681b      	ldr	r3, [r3, #0]
 800ac92:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ac96:	2b00      	cmp	r3, #0
 800ac98:	bf14      	ite	ne
 800ac9a:	2301      	movne	r3, #1
 800ac9c:	2300      	moveq	r3, #0
 800ac9e:	b2db      	uxtb	r3, r3
 800aca0:	e007      	b.n	800acb2 <SetupStoreCtxCallback+0x1d6>
 800aca2:	68bb      	ldr	r3, [r7, #8]
 800aca4:	681b      	ldr	r3, [r3, #0]
 800aca6:	33f4      	adds	r3, #244	@ 0xf4
 800aca8:	2b00      	cmp	r3, #0
 800acaa:	bf14      	ite	ne
 800acac:	2301      	movne	r3, #1
 800acae:	2300      	moveq	r3, #0
 800acb0:	b2db      	uxtb	r3, r3
 800acb2:	2b00      	cmp	r3, #0
 800acb4:	d050      	beq.n	800ad58 <SetupStoreCtxCallback+0x27c>
 800acb6:	68bb      	ldr	r3, [r7, #8]
 800acb8:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800acbc:	2b00      	cmp	r3, #0
 800acbe:	d003      	beq.n	800acc8 <SetupStoreCtxCallback+0x1ec>
 800acc0:	68bb      	ldr	r3, [r7, #8]
 800acc2:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800acc6:	e00d      	b.n	800ace4 <SetupStoreCtxCallback+0x208>
 800acc8:	68bb      	ldr	r3, [r7, #8]
 800acca:	681b      	ldr	r3, [r3, #0]
 800accc:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800acd0:	2b00      	cmp	r3, #0
 800acd2:	d004      	beq.n	800acde <SetupStoreCtxCallback+0x202>
 800acd4:	68bb      	ldr	r3, [r7, #8]
 800acd6:	681b      	ldr	r3, [r3, #0]
 800acd8:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800acdc:	e002      	b.n	800ace4 <SetupStoreCtxCallback+0x208>
 800acde:	68bb      	ldr	r3, [r7, #8]
 800ace0:	681b      	ldr	r3, [r3, #0]
 800ace2:	33f4      	adds	r3, #244	@ 0xf4
 800ace4:	699b      	ldr	r3, [r3, #24]
 800ace6:	2b00      	cmp	r3, #0
 800ace8:	d036      	beq.n	800ad58 <SetupStoreCtxCallback+0x27c>
                    SSL_STORE(ssl)->param->flags)
 800acea:	68bb      	ldr	r3, [r7, #8]
 800acec:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800acf0:	2b00      	cmp	r3, #0
 800acf2:	d003      	beq.n	800acfc <SetupStoreCtxCallback+0x220>
 800acf4:	68bb      	ldr	r3, [r7, #8]
 800acf6:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800acfa:	e00d      	b.n	800ad18 <SetupStoreCtxCallback+0x23c>
 800acfc:	68bb      	ldr	r3, [r7, #8]
 800acfe:	681b      	ldr	r3, [r3, #0]
 800ad00:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ad04:	2b00      	cmp	r3, #0
 800ad06:	d004      	beq.n	800ad12 <SetupStoreCtxCallback+0x236>
 800ad08:	68bb      	ldr	r3, [r7, #8]
 800ad0a:	681b      	ldr	r3, [r3, #0]
 800ad0c:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ad10:	e002      	b.n	800ad18 <SetupStoreCtxCallback+0x23c>
 800ad12:	68bb      	ldr	r3, [r7, #8]
 800ad14:	681b      	ldr	r3, [r3, #0]
 800ad16:	33f4      	adds	r3, #244	@ 0xf4
 800ad18:	699b      	ldr	r3, [r3, #24]
 800ad1a:	695b      	ldr	r3, [r3, #20]
            else if (SSL_STORE(ssl) && SSL_STORE(ssl)->param &&
 800ad1c:	2b00      	cmp	r3, #0
 800ad1e:	d01b      	beq.n	800ad58 <SetupStoreCtxCallback+0x27c>
                store->param->flags = SSL_STORE(ssl)->param->flags;
 800ad20:	68bb      	ldr	r3, [r7, #8]
 800ad22:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ad26:	2b00      	cmp	r3, #0
 800ad28:	d003      	beq.n	800ad32 <SetupStoreCtxCallback+0x256>
 800ad2a:	68bb      	ldr	r3, [r7, #8]
 800ad2c:	f8d3 33b8 	ldr.w	r3, [r3, #952]	@ 0x3b8
 800ad30:	e00d      	b.n	800ad4e <SetupStoreCtxCallback+0x272>
 800ad32:	68bb      	ldr	r3, [r7, #8]
 800ad34:	681b      	ldr	r3, [r3, #0]
 800ad36:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ad3a:	2b00      	cmp	r3, #0
 800ad3c:	d004      	beq.n	800ad48 <SetupStoreCtxCallback+0x26c>
 800ad3e:	68bb      	ldr	r3, [r7, #8]
 800ad40:	681b      	ldr	r3, [r3, #0]
 800ad42:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
 800ad46:	e002      	b.n	800ad4e <SetupStoreCtxCallback+0x272>
 800ad48:	68bb      	ldr	r3, [r7, #8]
 800ad4a:	681b      	ldr	r3, [r3, #0]
 800ad4c:	33f4      	adds	r3, #244	@ 0xf4
 800ad4e:	699a      	ldr	r2, [r3, #24]
 800ad50:	69bb      	ldr	r3, [r7, #24]
 800ad52:	695b      	ldr	r3, [r3, #20]
 800ad54:	6952      	ldr	r2, [r2, #20]
 800ad56:	615a      	str	r2, [r3, #20]
#endif


            if (ssl->param->hostName[0])
 800ad58:	68bb      	ldr	r3, [r7, #8]
 800ad5a:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ad5e:	7e1b      	ldrb	r3, [r3, #24]
 800ad60:	2b00      	cmp	r3, #0
 800ad62:	d00c      	beq.n	800ad7e <SetupStoreCtxCallback+0x2a2>
                XMEMCPY(store->param->hostName, ssl->param->hostName,
 800ad64:	69bb      	ldr	r3, [r7, #24]
 800ad66:	695b      	ldr	r3, [r3, #20]
 800ad68:	f103 0018 	add.w	r0, r3, #24
 800ad6c:	68bb      	ldr	r3, [r7, #8]
 800ad6e:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800ad72:	3318      	adds	r3, #24
 800ad74:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800ad78:	4619      	mov	r1, r3
 800ad7a:	f01d fc13 	bl	80285a4 <memcpy>
        }
#endif /* defined(OPENSSL_EXTRA) */
#endif /* defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER)*/
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    #ifdef KEEP_PEER_CERT
        if (args->certIdx == 0) {
 800ad7e:	683b      	ldr	r3, [r7, #0]
 800ad80:	69db      	ldr	r3, [r3, #28]
 800ad82:	2b00      	cmp	r3, #0
 800ad84:	d11e      	bne.n	800adc4 <SetupStoreCtxCallback+0x2e8>
            FreeX509(&ssl->peerCert);
 800ad86:	68bb      	ldr	r3, [r7, #8]
 800ad88:	f503 736f 	add.w	r3, r3, #956	@ 0x3bc
 800ad8c:	4618      	mov	r0, r3
 800ad8e:	f7fe fc0a 	bl	80095a6 <FreeX509>
            InitX509(&ssl->peerCert, 0, ssl->heap);
 800ad92:	68bb      	ldr	r3, [r7, #8]
 800ad94:	f503 706f 	add.w	r0, r3, #956	@ 0x3bc
 800ad98:	68bb      	ldr	r3, [r7, #8]
 800ad9a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800ad9e:	461a      	mov	r2, r3
 800ada0:	2100      	movs	r1, #0
 800ada2:	f7fe fbcd 	bl	8009540 <InitX509>
            if (CopyDecodedToX509(&ssl->peerCert, args->dCert) == 0)
 800ada6:	68bb      	ldr	r3, [r7, #8]
 800ada8:	f503 726f 	add.w	r2, r3, #956	@ 0x3bc
 800adac:	683b      	ldr	r3, [r7, #0]
 800adae:	689b      	ldr	r3, [r3, #8]
 800adb0:	4619      	mov	r1, r3
 800adb2:	4610      	mov	r0, r2
 800adb4:	f7ff fa75 	bl	800a2a2 <CopyDecodedToX509>
                WOLFSSL_MSG("Unable to copy to ssl->peerCert");
            store->current_cert = &ssl->peerCert; /* use existing X509 */
 800adb8:	68bb      	ldr	r3, [r7, #8]
 800adba:	f503 726f 	add.w	r2, r3, #956	@ 0x3bc
 800adbe:	69bb      	ldr	r3, [r7, #24]
 800adc0:	605a      	str	r2, [r3, #4]
 800adc2:	e015      	b.n	800adf0 <SetupStoreCtxCallback+0x314>
        }
        else
    #endif
        {
            x509 = wolfSSL_X509_new_ex(heap);
 800adc4:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 800adc6:	f003 fbc6 	bl	800e556 <wolfSSL_X509_new_ex>
 800adca:	6238      	str	r0, [r7, #32]
            if (x509 == NULL)
 800adcc:	6a3b      	ldr	r3, [r7, #32]
 800adce:	2b00      	cmp	r3, #0
 800add0:	d017      	beq.n	800ae02 <SetupStoreCtxCallback+0x326>
                goto mem_error;
            if (CopyDecodedToX509(x509, args->dCert) == 0) {
 800add2:	683b      	ldr	r3, [r7, #0]
 800add4:	689b      	ldr	r3, [r3, #8]
 800add6:	4619      	mov	r1, r3
 800add8:	6a38      	ldr	r0, [r7, #32]
 800adda:	f7ff fa62 	bl	800a2a2 <CopyDecodedToX509>
 800adde:	4603      	mov	r3, r0
 800ade0:	2b00      	cmp	r3, #0
 800ade2:	d110      	bne.n	800ae06 <SetupStoreCtxCallback+0x32a>
                store->current_cert = x509;
 800ade4:	69bb      	ldr	r3, [r7, #24]
 800ade6:	6a3a      	ldr	r2, [r7, #32]
 800ade8:	605a      	str	r2, [r3, #4]
                *x509Free = 1;
 800adea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800adec:	2201      	movs	r2, #1
 800adee:	601a      	str	r2, [r3, #0]
#endif
#ifdef SESSION_CERTS
        store->sesChain = &ssl->session->chain;
#endif
    }
    *store_pt = store;
 800adf0:	68fb      	ldr	r3, [r7, #12]
 800adf2:	69ba      	ldr	r2, [r7, #24]
 800adf4:	601a      	str	r2, [r3, #0]
    return 0;
 800adf6:	2300      	movs	r3, #0
 800adf8:	e01c      	b.n	800ae34 <SetupStoreCtxCallback+0x358>
        goto mem_error;
 800adfa:	bf00      	nop
 800adfc:	e004      	b.n	800ae08 <SetupStoreCtxCallback+0x32c>
        goto mem_error;
 800adfe:	bf00      	nop
 800ae00:	e002      	b.n	800ae08 <SetupStoreCtxCallback+0x32c>
                goto mem_error;
 800ae02:	bf00      	nop
 800ae04:	e000      	b.n	800ae08 <SetupStoreCtxCallback+0x32c>
                goto mem_error;
 800ae06:	bf00      	nop
mem_error:
    if (store != NULL)
 800ae08:	69bb      	ldr	r3, [r7, #24]
 800ae0a:	2b00      	cmp	r3, #0
 800ae0c:	d002      	beq.n	800ae14 <SetupStoreCtxCallback+0x338>
        wolfSSL_X509_STORE_CTX_free(store);
 800ae0e:	69b8      	ldr	r0, [r7, #24]
 800ae10:	f004 f8cc 	bl	800efac <wolfSSL_X509_STORE_CTX_free>
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (x509 != NULL)
 800ae14:	6a3b      	ldr	r3, [r7, #32]
 800ae16:	2b00      	cmp	r3, #0
 800ae18:	d002      	beq.n	800ae20 <SetupStoreCtxCallback+0x344>
        wolfSSL_X509_free(x509);
 800ae1a:	6a38      	ldr	r0, [r7, #32]
 800ae1c:	f003 fa99 	bl	800e352 <wolfSSL_X509_free>
#endif
    XFREE(domain, heap, DYNAMIC_TYPE_STRING);
 800ae20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ae22:	617b      	str	r3, [r7, #20]
 800ae24:	697b      	ldr	r3, [r7, #20]
 800ae26:	2b00      	cmp	r3, #0
 800ae28:	d002      	beq.n	800ae30 <SetupStoreCtxCallback+0x354>
 800ae2a:	6978      	ldr	r0, [r7, #20]
 800ae2c:	f013 fe4e 	bl	801eacc <wolfSSL_Free>
    return MEMORY_E;
 800ae30:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
}
 800ae34:	4618      	mov	r0, r3
 800ae36:	3728      	adds	r7, #40	@ 0x28
 800ae38:	46bd      	mov	sp, r7
 800ae3a:	bd80      	pop	{r7, pc}

0800ae3c <CleanupStoreCtxCallback>:

void CleanupStoreCtxCallback(WOLFSSL_X509_STORE_CTX* store,
        WOLFSSL* ssl, void* heap, int x509Free)
{
 800ae3c:	b580      	push	{r7, lr}
 800ae3e:	b086      	sub	sp, #24
 800ae40:	af00      	add	r7, sp, #0
 800ae42:	60f8      	str	r0, [r7, #12]
 800ae44:	60b9      	str	r1, [r7, #8]
 800ae46:	607a      	str	r2, [r7, #4]
 800ae48:	603b      	str	r3, [r7, #0]
    #ifdef WOLFSSL_ALT_CERT_CHAINS
        ssl->session->altChain.count = 0;
    #endif
    }
#endif /* SESSION_CERTS */
    XFREE(store->domain, heap, DYNAMIC_TYPE_STRING);
 800ae4a:	68fb      	ldr	r3, [r7, #12]
 800ae4c:	699b      	ldr	r3, [r3, #24]
 800ae4e:	617b      	str	r3, [r7, #20]
 800ae50:	697b      	ldr	r3, [r7, #20]
 800ae52:	2b00      	cmp	r3, #0
 800ae54:	d002      	beq.n	800ae5c <CleanupStoreCtxCallback+0x20>
 800ae56:	6978      	ldr	r0, [r7, #20]
 800ae58:	f013 fe38 	bl	801eacc <wolfSSL_Free>
    store->domain = NULL;
 800ae5c:	68fb      	ldr	r3, [r7, #12]
 800ae5e:	2200      	movs	r2, #0
 800ae60:	619a      	str	r2, [r3, #24]
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    if (x509Free)
 800ae62:	683b      	ldr	r3, [r7, #0]
 800ae64:	2b00      	cmp	r3, #0
 800ae66:	d004      	beq.n	800ae72 <CleanupStoreCtxCallback+0x36>
        wolfSSL_X509_free(store->current_cert);
 800ae68:	68fb      	ldr	r3, [r7, #12]
 800ae6a:	685b      	ldr	r3, [r3, #4]
 800ae6c:	4618      	mov	r0, r3
 800ae6e:	f003 fa70 	bl	800e352 <wolfSSL_X509_free>
    store->current_cert = NULL;
 800ae72:	68fb      	ldr	r3, [r7, #12]
 800ae74:	2200      	movs	r2, #0
 800ae76:	605a      	str	r2, [r3, #4]
#endif
    wolfSSL_X509_STORE_CTX_free(store);
 800ae78:	68f8      	ldr	r0, [r7, #12]
 800ae7a:	f004 f897 	bl	800efac <wolfSSL_X509_STORE_CTX_free>
}
 800ae7e:	bf00      	nop
 800ae80:	3718      	adds	r7, #24
 800ae82:	46bd      	mov	sp, r7
 800ae84:	bd80      	pop	{r7, pc}
	...

0800ae88 <DoVerifyCallback>:
 * store->error_depth member to determine index (0=peer, >1 intermediates)
 */

int DoVerifyCallback(WOLFSSL_CERT_MANAGER* cm, WOLFSSL* ssl, int cert_err,
                                                        ProcPeerCertArgs* args)
{
 800ae88:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ae8a:	b091      	sub	sp, #68	@ 0x44
 800ae8c:	af04      	add	r7, sp, #16
 800ae8e:	60f8      	str	r0, [r7, #12]
 800ae90:	60b9      	str	r1, [r7, #8]
 800ae92:	607a      	str	r2, [r7, #4]
 800ae94:	603b      	str	r3, [r7, #0]
    int verify_ok = 0, use_cb = 0, ret = cert_err;
 800ae96:	2300      	movs	r3, #0
 800ae98:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800ae9a:	2300      	movs	r3, #0
 800ae9c:	62bb      	str	r3, [r7, #40]	@ 0x28
 800ae9e:	687b      	ldr	r3, [r7, #4]
 800aea0:	627b      	str	r3, [r7, #36]	@ 0x24
    void *heap;

    if (cm == NULL) {
 800aea2:	68fb      	ldr	r3, [r7, #12]
 800aea4:	2b00      	cmp	r3, #0
 800aea6:	d102      	bne.n	800aeae <DoVerifyCallback+0x26>
        return BAD_FUNC_ARG;
 800aea8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800aeac:	e139      	b.n	800b122 <DoVerifyCallback+0x29a>
    }

    heap = (ssl != NULL) ? ssl->heap : cm->heap;
 800aeae:	68bb      	ldr	r3, [r7, #8]
 800aeb0:	2b00      	cmp	r3, #0
 800aeb2:	d003      	beq.n	800aebc <DoVerifyCallback+0x34>
 800aeb4:	68bb      	ldr	r3, [r7, #8]
 800aeb6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800aeba:	e001      	b.n	800aec0 <DoVerifyCallback+0x38>
 800aebc:	68fb      	ldr	r3, [r7, #12]
 800aebe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aec0:	61fb      	str	r3, [r7, #28]

    /* Determine if verify was okay */
    if (cert_err == 0) {
 800aec2:	687b      	ldr	r3, [r7, #4]
 800aec4:	2b00      	cmp	r3, #0
 800aec6:	d101      	bne.n	800aecc <DoVerifyCallback+0x44>
        verify_ok = 1;
 800aec8:	2301      	movs	r3, #1
 800aeca:	62fb      	str	r3, [r7, #44]	@ 0x2c
    }

    /* Determine if verify callback should be used */
    if (cert_err != 0) {
 800aecc:	687b      	ldr	r3, [r7, #4]
 800aece:	2b00      	cmp	r3, #0
 800aed0:	d00c      	beq.n	800aeec <DoVerifyCallback+0x64>
        if ((ssl != NULL) && (!ssl->options.verifyNone)) {
 800aed2:	68bb      	ldr	r3, [r7, #8]
 800aed4:	2b00      	cmp	r3, #0
 800aed6:	d009      	beq.n	800aeec <DoVerifyCallback+0x64>
 800aed8:	68bb      	ldr	r3, [r7, #8]
 800aeda:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800aede:	f003 0308 	and.w	r3, r3, #8
 800aee2:	b2db      	uxtb	r3, r3
 800aee4:	2b00      	cmp	r3, #0
 800aee6:	d101      	bne.n	800aeec <DoVerifyCallback+0x64>
            use_cb = 1; /* always report errors */
 800aee8:	2301      	movs	r3, #1
 800aeea:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
#ifdef WOLFSSL_ALWAYS_VERIFY_CB
    /* always use verify callback on peer leaf cert */
    if (args->certIdx == 0) {
 800aeec:	683b      	ldr	r3, [r7, #0]
 800aeee:	69db      	ldr	r3, [r3, #28]
 800aef0:	2b00      	cmp	r3, #0
 800aef2:	d101      	bne.n	800aef8 <DoVerifyCallback+0x70>
        use_cb = 1;
 800aef4:	2301      	movs	r3, #1
 800aef6:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
#endif
#ifdef WOLFSSL_VERIFY_CB_ALL_CERTS
    /* perform verify callback on other intermediate certs (not just peer) */
    if (args->certIdx > 0) {
 800aef8:	683b      	ldr	r3, [r7, #0]
 800aefa:	69db      	ldr	r3, [r3, #28]
 800aefc:	2b00      	cmp	r3, #0
 800aefe:	dd01      	ble.n	800af04 <DoVerifyCallback+0x7c>
        use_cb = 1;
 800af00:	2301      	movs	r3, #1
 800af02:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
#endif
#if defined(OPENSSL_EXTRA)
    /* Perform domain and IP check only for the leaf certificate */
    if (args->certIdx == 0) {
 800af04:	683b      	ldr	r3, [r7, #0]
 800af06:	69db      	ldr	r3, [r3, #28]
 800af08:	2b00      	cmp	r3, #0
 800af0a:	f040 8098 	bne.w	800b03e <DoVerifyCallback+0x1b6>
        /* perform domain name check on the peer certificate */
        if (args->dCertInit && args->dCert && (ssl != NULL) &&
 800af0e:	683b      	ldr	r3, [r7, #0]
 800af10:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800af14:	f003 0304 	and.w	r3, r3, #4
 800af18:	b2db      	uxtb	r3, r3
 800af1a:	2b00      	cmp	r3, #0
 800af1c:	d05f      	beq.n	800afde <DoVerifyCallback+0x156>
 800af1e:	683b      	ldr	r3, [r7, #0]
 800af20:	689b      	ldr	r3, [r3, #8]
 800af22:	2b00      	cmp	r3, #0
 800af24:	d05b      	beq.n	800afde <DoVerifyCallback+0x156>
 800af26:	68bb      	ldr	r3, [r7, #8]
 800af28:	2b00      	cmp	r3, #0
 800af2a:	d058      	beq.n	800afde <DoVerifyCallback+0x156>
                ssl->param && ssl->param->hostName[0]) {
 800af2c:	68bb      	ldr	r3, [r7, #8]
 800af2e:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
        if (args->dCertInit && args->dCert && (ssl != NULL) &&
 800af32:	2b00      	cmp	r3, #0
 800af34:	d053      	beq.n	800afde <DoVerifyCallback+0x156>
                ssl->param && ssl->param->hostName[0]) {
 800af36:	68bb      	ldr	r3, [r7, #8]
 800af38:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800af3c:	7e1b      	ldrb	r3, [r3, #24]
 800af3e:	2b00      	cmp	r3, #0
 800af40:	d04d      	beq.n	800afde <DoVerifyCallback+0x156>
            /* If altNames names is present, then subject common name is ignored */
            if (args->dCert->altNames != NULL) {
 800af42:	683b      	ldr	r3, [r7, #0]
 800af44:	689b      	ldr	r3, [r3, #8]
 800af46:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800af48:	2b00      	cmp	r3, #0
 800af4a:	d01e      	beq.n	800af8a <DoVerifyCallback+0x102>
                if (CheckForAltNames(args->dCert, ssl->param->hostName,
 800af4c:	683b      	ldr	r3, [r7, #0]
 800af4e:	689c      	ldr	r4, [r3, #8]
 800af50:	68bb      	ldr	r3, [r7, #8]
 800af52:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800af56:	f103 0518 	add.w	r5, r3, #24
                    (word32)XSTRLEN(ssl->param->hostName), NULL, 0) != 1) {
 800af5a:	68bb      	ldr	r3, [r7, #8]
 800af5c:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800af60:	3318      	adds	r3, #24
 800af62:	4618      	mov	r0, r3
 800af64:	f7f5 f93e 	bl	80001e4 <strlen>
 800af68:	4602      	mov	r2, r0
                if (CheckForAltNames(args->dCert, ssl->param->hostName,
 800af6a:	2300      	movs	r3, #0
 800af6c:	9300      	str	r3, [sp, #0]
 800af6e:	2300      	movs	r3, #0
 800af70:	4629      	mov	r1, r5
 800af72:	4620      	mov	r0, r4
 800af74:	f7ff f866 	bl	800a044 <CheckForAltNames>
 800af78:	4603      	mov	r3, r0
 800af7a:	2b01      	cmp	r3, #1
 800af7c:	d02f      	beq.n	800afde <DoVerifyCallback+0x156>
                    if (cert_err == 0) {
 800af7e:	687b      	ldr	r3, [r7, #4]
 800af80:	2b00      	cmp	r3, #0
 800af82:	d12c      	bne.n	800afde <DoVerifyCallback+0x156>
                        ret = DOMAIN_NAME_MISMATCH;
 800af84:	4b69      	ldr	r3, [pc, #420]	@ (800b12c <DoVerifyCallback+0x2a4>)
 800af86:	627b      	str	r3, [r7, #36]	@ 0x24
 800af88:	e029      	b.n	800afde <DoVerifyCallback+0x156>
                    }
                }
            }
        #ifndef WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY
            else {
                if (args->dCert->subjectCN) {
 800af8a:	683b      	ldr	r3, [r7, #0]
 800af8c:	689b      	ldr	r3, [r3, #8]
 800af8e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800af92:	2b00      	cmp	r3, #0
 800af94:	d023      	beq.n	800afde <DoVerifyCallback+0x156>
                    if (MatchDomainName(
                            args->dCert->subjectCN,
 800af96:	683b      	ldr	r3, [r7, #0]
 800af98:	689b      	ldr	r3, [r3, #8]
 800af9a:	f8d3 4084 	ldr.w	r4, [r3, #132]	@ 0x84
                            args->dCert->subjectCNLen,
 800af9e:	683b      	ldr	r3, [r7, #0]
 800afa0:	689b      	ldr	r3, [r3, #8]
                    if (MatchDomainName(
 800afa2:	f8d3 5088 	ldr.w	r5, [r3, #136]	@ 0x88
                            ssl->param->hostName,
 800afa6:	68bb      	ldr	r3, [r7, #8]
 800afa8:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800afac:	f103 0618 	add.w	r6, r3, #24
                            (word32)XSTRLEN(ssl->param->hostName), 0) == 0) {
 800afb0:	68bb      	ldr	r3, [r7, #8]
 800afb2:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800afb6:	3318      	adds	r3, #24
 800afb8:	4618      	mov	r0, r3
 800afba:	f7f5 f913 	bl	80001e4 <strlen>
 800afbe:	4603      	mov	r3, r0
                    if (MatchDomainName(
 800afc0:	2200      	movs	r2, #0
 800afc2:	9200      	str	r2, [sp, #0]
 800afc4:	4632      	mov	r2, r6
 800afc6:	4629      	mov	r1, r5
 800afc8:	4620      	mov	r0, r4
 800afca:	f7fe ff57 	bl	8009e7c <MatchDomainName>
 800afce:	4603      	mov	r3, r0
 800afd0:	2b00      	cmp	r3, #0
 800afd2:	d104      	bne.n	800afde <DoVerifyCallback+0x156>
                        if (cert_err == 0) {
 800afd4:	687b      	ldr	r3, [r7, #4]
 800afd6:	2b00      	cmp	r3, #0
 800afd8:	d101      	bne.n	800afde <DoVerifyCallback+0x156>
                            ret = DOMAIN_NAME_MISMATCH;
 800afda:	4b54      	ldr	r3, [pc, #336]	@ (800b12c <DoVerifyCallback+0x2a4>)
 800afdc:	627b      	str	r3, [r7, #36]	@ 0x24
            }
        #endif /* !WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY */
        }

        /* perform IP address check on the peer certificate */
        if ((args->dCertInit != 0) && (args->dCert != NULL) && (ssl != NULL) &&
 800afde:	683b      	ldr	r3, [r7, #0]
 800afe0:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 800afe4:	f003 0304 	and.w	r3, r3, #4
 800afe8:	b2db      	uxtb	r3, r3
 800afea:	2b00      	cmp	r3, #0
 800afec:	d027      	beq.n	800b03e <DoVerifyCallback+0x1b6>
 800afee:	683b      	ldr	r3, [r7, #0]
 800aff0:	689b      	ldr	r3, [r3, #8]
 800aff2:	2b00      	cmp	r3, #0
 800aff4:	d023      	beq.n	800b03e <DoVerifyCallback+0x1b6>
 800aff6:	68bb      	ldr	r3, [r7, #8]
 800aff8:	2b00      	cmp	r3, #0
 800affa:	d020      	beq.n	800b03e <DoVerifyCallback+0x1b6>
            (ssl->param != NULL) && (XSTRLEN(ssl->param->ipasc) > 0)) {
 800affc:	68bb      	ldr	r3, [r7, #8]
 800affe:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
        if ((args->dCertInit != 0) && (args->dCert != NULL) && (ssl != NULL) &&
 800b002:	2b00      	cmp	r3, #0
 800b004:	d01b      	beq.n	800b03e <DoVerifyCallback+0x1b6>
            (ssl->param != NULL) && (XSTRLEN(ssl->param->ipasc) > 0)) {
 800b006:	68bb      	ldr	r3, [r7, #8]
 800b008:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b00c:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800b010:	781b      	ldrb	r3, [r3, #0]
 800b012:	2b00      	cmp	r3, #0
 800b014:	d013      	beq.n	800b03e <DoVerifyCallback+0x1b6>
            if (CheckIPAddr(args->dCert, ssl->param->ipasc) != 0) {
 800b016:	683b      	ldr	r3, [r7, #0]
 800b018:	689a      	ldr	r2, [r3, #8]
 800b01a:	68bb      	ldr	r3, [r7, #8]
 800b01c:	f8d3 3334 	ldr.w	r3, [r3, #820]	@ 0x334
 800b020:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 800b024:	4619      	mov	r1, r3
 800b026:	4610      	mov	r0, r2
 800b028:	f7ff f898 	bl	800a15c <CheckIPAddr>
 800b02c:	4603      	mov	r3, r0
 800b02e:	2b00      	cmp	r3, #0
 800b030:	d005      	beq.n	800b03e <DoVerifyCallback+0x1b6>
                if (cert_err == 0) {
 800b032:	687b      	ldr	r3, [r7, #4]
 800b034:	2b00      	cmp	r3, #0
 800b036:	d102      	bne.n	800b03e <DoVerifyCallback+0x1b6>
                    ret = IPADDR_MISMATCH;
 800b038:	f46f 73a2 	mvn.w	r3, #324	@ 0x144
 800b03c:	627b      	str	r3, [r7, #36]	@ 0x24
            }
        }
    }
#endif
    /* if verify callback has been set */
    if ((use_cb && (ssl != NULL) && ((ssl->verifyCallback != NULL)
 800b03e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b040:	2b00      	cmp	r3, #0
 800b042:	d007      	beq.n	800b054 <DoVerifyCallback+0x1cc>
 800b044:	68bb      	ldr	r3, [r7, #8]
 800b046:	2b00      	cmp	r3, #0
 800b048:	d004      	beq.n	800b054 <DoVerifyCallback+0x1cc>
 800b04a:	68bb      	ldr	r3, [r7, #8]
 800b04c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b050:	2b00      	cmp	r3, #0
 800b052:	d103      	bne.n	800b05c <DoVerifyCallback+0x1d4>
        (defined(OPENSSL_ALL) || defined(WOLFSSL_QT))
        || (SSL_STORE(ssl) != NULL && SSL_STORE(ssl)->verify_cb != NULL)
    #endif
        ))
    #ifndef NO_WOLFSSL_CM_VERIFY
        || (cm->verifyCallback != NULL)
 800b054:	68fb      	ldr	r3, [r7, #12]
 800b056:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b058:	2b00      	cmp	r3, #0
 800b05a:	d061      	beq.n	800b120 <DoVerifyCallback+0x298>
    #endif
        ) {
        int verifyFail = 0;
 800b05c:	2300      	movs	r3, #0
 800b05e:	623b      	str	r3, [r7, #32]
        WOLFSSL_X509_STORE_CTX* store = NULL;
 800b060:	2300      	movs	r3, #0
 800b062:	617b      	str	r3, [r7, #20]
        int x509Free = 0;
 800b064:	2300      	movs	r3, #0
 800b066:	613b      	str	r3, [r7, #16]
        int setupRet = SetupStoreCtxCallback(&store, ssl, cm, args, cert_err,
 800b068:	f107 0014 	add.w	r0, r7, #20
 800b06c:	f107 0310 	add.w	r3, r7, #16
 800b070:	9302      	str	r3, [sp, #8]
 800b072:	69fb      	ldr	r3, [r7, #28]
 800b074:	9301      	str	r3, [sp, #4]
 800b076:	687b      	ldr	r3, [r7, #4]
 800b078:	9300      	str	r3, [sp, #0]
 800b07a:	683b      	ldr	r3, [r7, #0]
 800b07c:	68fa      	ldr	r2, [r7, #12]
 800b07e:	68b9      	ldr	r1, [r7, #8]
 800b080:	f7ff fd2c 	bl	800aadc <SetupStoreCtxCallback>
 800b084:	61b8      	str	r0, [r7, #24]
                heap, &x509Free);

        if (setupRet != 0)
 800b086:	69bb      	ldr	r3, [r7, #24]
 800b088:	2b00      	cmp	r3, #0
 800b08a:	d001      	beq.n	800b090 <DoVerifyCallback+0x208>
            return setupRet;
 800b08c:	69bb      	ldr	r3, [r7, #24]
 800b08e:	e048      	b.n	800b122 <DoVerifyCallback+0x29a>

    #ifndef NO_WOLFSSL_CM_VERIFY
        /* non-zero return code indicates failure override */
        if (cm->verifyCallback != NULL) {
 800b090:	68fb      	ldr	r3, [r7, #12]
 800b092:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b094:	2b00      	cmp	r3, #0
 800b096:	d013      	beq.n	800b0c0 <DoVerifyCallback+0x238>
            store->userCtx = cm;
 800b098:	697b      	ldr	r3, [r7, #20]
 800b09a:	68fa      	ldr	r2, [r7, #12]
 800b09c:	621a      	str	r2, [r3, #32]
            if (cm->verifyCallback(verify_ok, store)) {
 800b09e:	68fb      	ldr	r3, [r7, #12]
 800b0a0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b0a2:	697a      	ldr	r2, [r7, #20]
 800b0a4:	4611      	mov	r1, r2
 800b0a6:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b0a8:	4798      	blx	r3
 800b0aa:	4603      	mov	r3, r0
 800b0ac:	2b00      	cmp	r3, #0
 800b0ae:	d005      	beq.n	800b0bc <DoVerifyCallback+0x234>
                if (cert_err != 0) {
 800b0b0:	687b      	ldr	r3, [r7, #4]
 800b0b2:	2b00      	cmp	r3, #0
 800b0b4:	d004      	beq.n	800b0c0 <DoVerifyCallback+0x238>
                    WOLFSSL_MSG("Verify CM callback overriding error!");
                    ret = 0;
 800b0b6:	2300      	movs	r3, #0
 800b0b8:	627b      	str	r3, [r7, #36]	@ 0x24
 800b0ba:	e001      	b.n	800b0c0 <DoVerifyCallback+0x238>
                }
            }
            else {
                verifyFail = 1;
 800b0bc:	2301      	movs	r3, #1
 800b0be:	623b      	str	r3, [r7, #32]
            }
        }
    #endif

        if (ssl != NULL) {
 800b0c0:	68bb      	ldr	r3, [r7, #8]
 800b0c2:	2b00      	cmp	r3, #0
 800b0c4:	d016      	beq.n	800b0f4 <DoVerifyCallback+0x26c>
                    verifyFail = 1;
                }
            }
    #endif
            /* non-zero return code indicates failure override */
            if (ssl->verifyCallback) {
 800b0c6:	68bb      	ldr	r3, [r7, #8]
 800b0c8:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b0cc:	2b00      	cmp	r3, #0
 800b0ce:	d011      	beq.n	800b0f4 <DoVerifyCallback+0x26c>
                if (ssl->verifyCallback(verify_ok, store)) {
 800b0d0:	68bb      	ldr	r3, [r7, #8]
 800b0d2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b0d6:	697a      	ldr	r2, [r7, #20]
 800b0d8:	4611      	mov	r1, r2
 800b0da:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b0dc:	4798      	blx	r3
 800b0de:	4603      	mov	r3, r0
 800b0e0:	2b00      	cmp	r3, #0
 800b0e2:	d005      	beq.n	800b0f0 <DoVerifyCallback+0x268>
                    if (cert_err != 0) {
 800b0e4:	687b      	ldr	r3, [r7, #4]
 800b0e6:	2b00      	cmp	r3, #0
 800b0e8:	d004      	beq.n	800b0f4 <DoVerifyCallback+0x26c>
                        WOLFSSL_MSG("Verify callback overriding error!");
                        ret = 0;
 800b0ea:	2300      	movs	r3, #0
 800b0ec:	627b      	str	r3, [r7, #36]	@ 0x24
 800b0ee:	e001      	b.n	800b0f4 <DoVerifyCallback+0x26c>
                    }
                }
                else {
                    verifyFail = 1;
 800b0f0:	2301      	movs	r3, #1
 800b0f2:	623b      	str	r3, [r7, #32]
                }
            }
#endif
        }

        if (verifyFail) {
 800b0f4:	6a3b      	ldr	r3, [r7, #32]
 800b0f6:	2b00      	cmp	r3, #0
 800b0f8:	d00c      	beq.n	800b114 <DoVerifyCallback+0x28c>
            /* induce error if one not present */
            if (cert_err == 0) {
 800b0fa:	687b      	ldr	r3, [r7, #4]
 800b0fc:	2b00      	cmp	r3, #0
 800b0fe:	d102      	bne.n	800b106 <DoVerifyCallback+0x27e>
                ret = VERIFY_CERT_ERROR;
 800b100:	f46f 73a4 	mvn.w	r3, #328	@ 0x148
 800b104:	627b      	str	r3, [r7, #36]	@ 0x24
                WOLFSSL_ERROR_VERBOSE(ret);
            }

            /* mark as verify error */
            args->verifyErr = 1;
 800b106:	683a      	ldr	r2, [r7, #0]
 800b108:	f892 3026 	ldrb.w	r3, [r2, #38]	@ 0x26
 800b10c:	f043 0302 	orr.w	r3, r3, #2
 800b110:	f882 3026 	strb.w	r3, [r2, #38]	@ 0x26
        }
        CleanupStoreCtxCallback(store, ssl, heap, x509Free);
 800b114:	6978      	ldr	r0, [r7, #20]
 800b116:	693b      	ldr	r3, [r7, #16]
 800b118:	69fa      	ldr	r2, [r7, #28]
 800b11a:	68b9      	ldr	r1, [r7, #8]
 800b11c:	f7ff fe8e 	bl	800ae3c <CleanupStoreCtxCallback>
    }

    (void)heap;

    return ret;
 800b120:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800b122:	4618      	mov	r0, r3
 800b124:	3734      	adds	r7, #52	@ 0x34
 800b126:	46bd      	mov	sp, r7
 800b128:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b12a:	bf00      	nop
 800b12c:	fffffebe 	.word	0xfffffebe

0800b130 <wolfSSL_Atomic_Int_FetchSub>:
    static WC_INLINE int wolfSSL_Atomic_Int_FetchSub(int *c, int i) {
 800b130:	b480      	push	{r7}
 800b132:	b085      	sub	sp, #20
 800b134:	af00      	add	r7, sp, #0
 800b136:	6078      	str	r0, [r7, #4]
 800b138:	6039      	str	r1, [r7, #0]
        int ret = *c;
 800b13a:	687b      	ldr	r3, [r7, #4]
 800b13c:	681b      	ldr	r3, [r3, #0]
 800b13e:	60fb      	str	r3, [r7, #12]
        *c -= i;
 800b140:	687b      	ldr	r3, [r7, #4]
 800b142:	681a      	ldr	r2, [r3, #0]
 800b144:	683b      	ldr	r3, [r7, #0]
 800b146:	1ad2      	subs	r2, r2, r3
 800b148:	687b      	ldr	r3, [r7, #4]
 800b14a:	601a      	str	r2, [r3, #0]
        return ret;
 800b14c:	68fb      	ldr	r3, [r7, #12]
    }
 800b14e:	4618      	mov	r0, r3
 800b150:	3714      	adds	r7, #20
 800b152:	46bd      	mov	sp, r7
 800b154:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b158:	4770      	bx	lr

0800b15a <ForceZero>:
{
 800b15a:	b480      	push	{r7}
 800b15c:	b085      	sub	sp, #20
 800b15e:	af00      	add	r7, sp, #0
 800b160:	6078      	str	r0, [r7, #4]
 800b162:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 800b164:	687b      	ldr	r3, [r7, #4]
 800b166:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 800b168:	e004      	b.n	800b174 <ForceZero+0x1a>
 800b16a:	68fb      	ldr	r3, [r7, #12]
 800b16c:	1c5a      	adds	r2, r3, #1
 800b16e:	60fa      	str	r2, [r7, #12]
 800b170:	2200      	movs	r2, #0
 800b172:	701a      	strb	r2, [r3, #0]
 800b174:	683b      	ldr	r3, [r7, #0]
 800b176:	1e5a      	subs	r2, r3, #1
 800b178:	603a      	str	r2, [r7, #0]
 800b17a:	2b00      	cmp	r3, #0
 800b17c:	d1f5      	bne.n	800b16a <ForceZero+0x10>
}
 800b17e:	bf00      	nop
 800b180:	bf00      	nop
 800b182:	3714      	adds	r7, #20
 800b184:	46bd      	mov	sp, r7
 800b186:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b18a:	4770      	bx	lr

0800b18c <c32to24>:
#endif /* !WOLFSSL_HAVE_MAX */

#ifndef WOLFSSL_NO_INT_ENCODE
/* converts a 32 bit integer to 24 bit */
WC_MISC_STATIC WC_INLINE void c32to24(word32 in, word24 out)
{
 800b18c:	b480      	push	{r7}
 800b18e:	b083      	sub	sp, #12
 800b190:	af00      	add	r7, sp, #0
 800b192:	6078      	str	r0, [r7, #4]
 800b194:	6039      	str	r1, [r7, #0]
    out[0] = (byte)((in >> 16) & 0xff);
 800b196:	687b      	ldr	r3, [r7, #4]
 800b198:	0c1b      	lsrs	r3, r3, #16
 800b19a:	b2da      	uxtb	r2, r3
 800b19c:	683b      	ldr	r3, [r7, #0]
 800b19e:	701a      	strb	r2, [r3, #0]
    out[1] = (byte)((in >>  8) & 0xff);
 800b1a0:	687b      	ldr	r3, [r7, #4]
 800b1a2:	0a1a      	lsrs	r2, r3, #8
 800b1a4:	683b      	ldr	r3, [r7, #0]
 800b1a6:	3301      	adds	r3, #1
 800b1a8:	b2d2      	uxtb	r2, r2
 800b1aa:	701a      	strb	r2, [r3, #0]
    out[2] =  (byte)(in        & 0xff);
 800b1ac:	683b      	ldr	r3, [r7, #0]
 800b1ae:	3302      	adds	r3, #2
 800b1b0:	687a      	ldr	r2, [r7, #4]
 800b1b2:	b2d2      	uxtb	r2, r2
 800b1b4:	701a      	strb	r2, [r3, #0]
}
 800b1b6:	bf00      	nop
 800b1b8:	370c      	adds	r7, #12
 800b1ba:	46bd      	mov	sp, r7
 800b1bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b1c0:	4770      	bx	lr

0800b1c2 <MakeWordFromHash>:

#if defined(HAVE_SESSION_TICKET) || !defined(NO_CERTS) || \
    !defined(NO_SESSION_CACHE)
/* Make a word from the front of random hash */
WC_MISC_STATIC WC_INLINE word32 MakeWordFromHash(const byte* hashID)
{
 800b1c2:	b480      	push	{r7}
 800b1c4:	b083      	sub	sp, #12
 800b1c6:	af00      	add	r7, sp, #0
 800b1c8:	6078      	str	r0, [r7, #4]
    return ((word32)hashID[0] << 24) | ((word32)hashID[1] << 16) |
 800b1ca:	687b      	ldr	r3, [r7, #4]
 800b1cc:	781b      	ldrb	r3, [r3, #0]
 800b1ce:	061a      	lsls	r2, r3, #24
 800b1d0:	687b      	ldr	r3, [r7, #4]
 800b1d2:	3301      	adds	r3, #1
 800b1d4:	781b      	ldrb	r3, [r3, #0]
 800b1d6:	041b      	lsls	r3, r3, #16
 800b1d8:	431a      	orrs	r2, r3
           ((word32)hashID[2] <<  8) |  (word32)hashID[3];
 800b1da:	687b      	ldr	r3, [r7, #4]
 800b1dc:	3302      	adds	r3, #2
 800b1de:	781b      	ldrb	r3, [r3, #0]
 800b1e0:	021b      	lsls	r3, r3, #8
    return ((word32)hashID[0] << 24) | ((word32)hashID[1] << 16) |
 800b1e2:	4313      	orrs	r3, r2
           ((word32)hashID[2] <<  8) |  (word32)hashID[3];
 800b1e4:	687a      	ldr	r2, [r7, #4]
 800b1e6:	3203      	adds	r2, #3
 800b1e8:	7812      	ldrb	r2, [r2, #0]
 800b1ea:	4313      	orrs	r3, r2
}
 800b1ec:	4618      	mov	r0, r3
 800b1ee:	370c      	adds	r7, #12
 800b1f0:	46bd      	mov	sp, r7
 800b1f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b1f6:	4770      	bx	lr

0800b1f8 <static_buffer_init>:
/* Initialize static buffer.
 *
 * @param [in, out] sb  Static buffer.
 */
static void static_buffer_init(StaticBuffer* sb)
{
 800b1f8:	b480      	push	{r7}
 800b1fa:	b083      	sub	sp, #12
 800b1fc:	af00      	add	r7, sp, #0
 800b1fe:	6078      	str	r0, [r7, #4]
    sb->buffer = NULL;
 800b200:	687b      	ldr	r3, [r7, #4]
 800b202:	2200      	movs	r2, #0
 800b204:	601a      	str	r2, [r3, #0]
    sb->sz = 0;
 800b206:	687b      	ldr	r3, [r7, #4]
 800b208:	2200      	movs	r2, #0
 800b20a:	605a      	str	r2, [r3, #4]
}
 800b20c:	bf00      	nop
 800b20e:	370c      	adds	r7, #12
 800b210:	46bd      	mov	sp, r7
 800b212:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b216:	4770      	bx	lr

0800b218 <static_buffer_set_size>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int static_buffer_set_size(StaticBuffer* sb, word32 len, void* heap,
    int type)
{
 800b218:	b580      	push	{r7, lr}
 800b21a:	b086      	sub	sp, #24
 800b21c:	af00      	add	r7, sp, #0
 800b21e:	60f8      	str	r0, [r7, #12]
 800b220:	60b9      	str	r1, [r7, #8]
 800b222:	607a      	str	r2, [r7, #4]
 800b224:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800b226:	2300      	movs	r3, #0
 800b228:	617b      	str	r3, [r7, #20]

    (void)heap;
    (void)type;

    sb->buffer = (byte*)XMALLOC(len, heap, type);
 800b22a:	68b8      	ldr	r0, [r7, #8]
 800b22c:	f013 fc32 	bl	801ea94 <wolfSSL_Malloc>
 800b230:	4602      	mov	r2, r0
 800b232:	68fb      	ldr	r3, [r7, #12]
 800b234:	601a      	str	r2, [r3, #0]
    if (sb->buffer == NULL) {
 800b236:	68fb      	ldr	r3, [r7, #12]
 800b238:	681b      	ldr	r3, [r3, #0]
 800b23a:	2b00      	cmp	r3, #0
 800b23c:	d103      	bne.n	800b246 <static_buffer_set_size+0x2e>
        ret = MEMORY_E;
 800b23e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800b242:	617b      	str	r3, [r7, #20]
 800b244:	e002      	b.n	800b24c <static_buffer_set_size+0x34>
    }
    else {
        sb->sz = len;
 800b246:	68fb      	ldr	r3, [r7, #12]
 800b248:	68ba      	ldr	r2, [r7, #8]
 800b24a:	605a      	str	r2, [r3, #4]
    }

    return ret;
 800b24c:	697b      	ldr	r3, [r7, #20]
}
 800b24e:	4618      	mov	r0, r3
 800b250:	3718      	adds	r7, #24
 800b252:	46bd      	mov	sp, r7
 800b254:	bd80      	pop	{r7, pc}

0800b256 <static_buffer_free>:
 * @param [in] sb    Static buffer.
 * @param [in] heap  Dynamic memory allocation hint.
 * @param [in] type  Type of dynamic memory.
 */
static void static_buffer_free(StaticBuffer* sb, void* heap, int type)
{
 800b256:	b580      	push	{r7, lr}
 800b258:	b086      	sub	sp, #24
 800b25a:	af00      	add	r7, sp, #0
 800b25c:	60f8      	str	r0, [r7, #12]
 800b25e:	60b9      	str	r1, [r7, #8]
 800b260:	607a      	str	r2, [r7, #4]
    (void)heap;
    (void)type;
    XFREE(sb->buffer, heap, type);
 800b262:	68fb      	ldr	r3, [r7, #12]
 800b264:	681b      	ldr	r3, [r3, #0]
 800b266:	617b      	str	r3, [r7, #20]
 800b268:	697b      	ldr	r3, [r7, #20]
 800b26a:	2b00      	cmp	r3, #0
 800b26c:	d002      	beq.n	800b274 <static_buffer_free+0x1e>
 800b26e:	6978      	ldr	r0, [r7, #20]
 800b270:	f013 fc2c 	bl	801eacc <wolfSSL_Free>
}
 800b274:	bf00      	nop
 800b276:	3718      	adds	r7, #24
 800b278:	46bd      	mov	sp, r7
 800b27a:	bd80      	pop	{r7, pc}

0800b27c <wolfSSL_EVP_PKEY_CTX_free>:
#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x10100000L
void wolfSSL_EVP_PKEY_CTX_free(WOLFSSL_EVP_PKEY_CTX *ctx)
#else
int wolfSSL_EVP_PKEY_CTX_free(WOLFSSL_EVP_PKEY_CTX *ctx)
#endif
{
 800b27c:	b580      	push	{r7, lr}
 800b27e:	b084      	sub	sp, #16
 800b280:	af00      	add	r7, sp, #0
 800b282:	6078      	str	r0, [r7, #4]
    if (ctx == NULL)
 800b284:	687b      	ldr	r3, [r7, #4]
 800b286:	2b00      	cmp	r3, #0
 800b288:	d101      	bne.n	800b28e <wolfSSL_EVP_PKEY_CTX_free+0x12>
#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x10100000L
        return;
#else
        return 0;
 800b28a:	2300      	movs	r3, #0
 800b28c:	e01a      	b.n	800b2c4 <wolfSSL_EVP_PKEY_CTX_free+0x48>
#endif
    WOLFSSL_ENTER("wolfSSL_EVP_PKEY_CTX_free");
    if (ctx->pkey != NULL)
 800b28e:	687b      	ldr	r3, [r7, #4]
 800b290:	681b      	ldr	r3, [r3, #0]
 800b292:	2b00      	cmp	r3, #0
 800b294:	d004      	beq.n	800b2a0 <wolfSSL_EVP_PKEY_CTX_free+0x24>
        wolfSSL_EVP_PKEY_free(ctx->pkey);
 800b296:	687b      	ldr	r3, [r7, #4]
 800b298:	681b      	ldr	r3, [r3, #0]
 800b29a:	4618      	mov	r0, r3
 800b29c:	f000 f894 	bl	800b3c8 <wolfSSL_EVP_PKEY_free>
    if (ctx->peerKey != NULL)
 800b2a0:	687b      	ldr	r3, [r7, #4]
 800b2a2:	685b      	ldr	r3, [r3, #4]
 800b2a4:	2b00      	cmp	r3, #0
 800b2a6:	d004      	beq.n	800b2b2 <wolfSSL_EVP_PKEY_CTX_free+0x36>
        wolfSSL_EVP_PKEY_free(ctx->peerKey);
 800b2a8:	687b      	ldr	r3, [r7, #4]
 800b2aa:	685b      	ldr	r3, [r3, #4]
 800b2ac:	4618      	mov	r0, r3
 800b2ae:	f000 f88b 	bl	800b3c8 <wolfSSL_EVP_PKEY_free>
    XFREE(ctx, NULL, DYNAMIC_TYPE_PUBLIC_KEY);
 800b2b2:	687b      	ldr	r3, [r7, #4]
 800b2b4:	60fb      	str	r3, [r7, #12]
 800b2b6:	68fb      	ldr	r3, [r7, #12]
 800b2b8:	2b00      	cmp	r3, #0
 800b2ba:	d002      	beq.n	800b2c2 <wolfSSL_EVP_PKEY_CTX_free+0x46>
 800b2bc:	68f8      	ldr	r0, [r7, #12]
 800b2be:	f013 fc05 	bl	801eacc <wolfSSL_Free>
#if !defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER < 0x10100000L
    return WOLFSSL_SUCCESS;
 800b2c2:	2301      	movs	r3, #1
#endif
}
 800b2c4:	4618      	mov	r0, r3
 800b2c6:	3710      	adds	r7, #16
 800b2c8:	46bd      	mov	sp, r7
 800b2ca:	bd80      	pop	{r7, pc}

0800b2cc <wolfSSL_EVP_init>:

    return NULL;
}

void wolfSSL_EVP_init(void)
{
 800b2cc:	b480      	push	{r7}
 800b2ce:	af00      	add	r7, sp, #0
    /* Does nothing. */
}
 800b2d0:	bf00      	nop
 800b2d2:	46bd      	mov	sp, r7
 800b2d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2d8:	4770      	bx	lr

0800b2da <wolfSSL_EVP_MD_CTX_free>:
        }
        return ctx;
    }

    void wolfSSL_EVP_MD_CTX_free(WOLFSSL_EVP_MD_CTX *ctx)
    {
 800b2da:	b580      	push	{r7, lr}
 800b2dc:	b084      	sub	sp, #16
 800b2de:	af00      	add	r7, sp, #0
 800b2e0:	6078      	str	r0, [r7, #4]
        if (ctx) {
 800b2e2:	687b      	ldr	r3, [r7, #4]
 800b2e4:	2b00      	cmp	r3, #0
 800b2e6:	d00a      	beq.n	800b2fe <wolfSSL_EVP_MD_CTX_free+0x24>
            WOLFSSL_ENTER("EVP_MD_CTX_free");
            wolfSSL_EVP_MD_CTX_cleanup(ctx);
 800b2e8:	6878      	ldr	r0, [r7, #4]
 800b2ea:	f000 f80d 	bl	800b308 <wolfSSL_EVP_MD_CTX_cleanup>
            XFREE(ctx, NULL, DYNAMIC_TYPE_OPENSSL);
 800b2ee:	687b      	ldr	r3, [r7, #4]
 800b2f0:	60fb      	str	r3, [r7, #12]
 800b2f2:	68fb      	ldr	r3, [r7, #12]
 800b2f4:	2b00      	cmp	r3, #0
 800b2f6:	d002      	beq.n	800b2fe <wolfSSL_EVP_MD_CTX_free+0x24>
 800b2f8:	68f8      	ldr	r0, [r7, #12]
 800b2fa:	f013 fbe7 	bl	801eacc <wolfSSL_Free>
        }
    }
 800b2fe:	bf00      	nop
 800b300:	3710      	adds	r7, #16
 800b302:	46bd      	mov	sp, r7
 800b304:	bd80      	pop	{r7, pc}
	...

0800b308 <wolfSSL_EVP_MD_CTX_cleanup>:
                break;
        }
    }

    int wolfSSL_EVP_MD_CTX_cleanup(WOLFSSL_EVP_MD_CTX* ctx)
    {
 800b308:	b580      	push	{r7, lr}
 800b30a:	b084      	sub	sp, #16
 800b30c:	af00      	add	r7, sp, #0
 800b30e:	6078      	str	r0, [r7, #4]
        int ret = WOLFSSL_SUCCESS;
 800b310:	2301      	movs	r3, #1
 800b312:	60fb      	str	r3, [r7, #12]
        WOLFSSL_ENTER("wolfSSL_EVP_MD_CTX_cleanup");
    #ifdef OPENSSL_EXTRA
        if (ctx->pctx != NULL)
 800b314:	687b      	ldr	r3, [r7, #4]
 800b316:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 800b31a:	2b00      	cmp	r3, #0
 800b31c:	d005      	beq.n	800b32a <wolfSSL_EVP_MD_CTX_cleanup+0x22>
            wolfSSL_EVP_PKEY_CTX_free(ctx->pctx);
 800b31e:	687b      	ldr	r3, [r7, #4]
 800b320:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 800b324:	4618      	mov	r0, r3
 800b326:	f7ff ffa9 	bl	800b27c <wolfSSL_EVP_PKEY_CTX_free>
    #endif

        if (ctx->isHMAC) {
 800b32a:	687b      	ldr	r3, [r7, #4]
 800b32c:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 800b330:	2b00      	cmp	r3, #0
 800b332:	d004      	beq.n	800b33e <wolfSSL_EVP_MD_CTX_cleanup+0x36>
            wc_HmacFree(&ctx->hash.hmac);
 800b334:	687b      	ldr	r3, [r7, #4]
 800b336:	4618      	mov	r0, r3
 800b338:	f013 f935 	bl	801e5a6 <wc_HmacFree>
 800b33c:	e035      	b.n	800b3aa <wolfSSL_EVP_MD_CTX_cleanup+0xa2>
        }
        else {
            switch (ctx->macType) {
 800b33e:	687b      	ldr	r3, [r7, #4]
 800b340:	f893 31a8 	ldrb.w	r3, [r3, #424]	@ 0x1a8
 800b344:	2b11      	cmp	r3, #17
 800b346:	d82c      	bhi.n	800b3a2 <wolfSSL_EVP_MD_CTX_cleanup+0x9a>
 800b348:	a201      	add	r2, pc, #4	@ (adr r2, 800b350 <wolfSSL_EVP_MD_CTX_cleanup+0x48>)
 800b34a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b34e:	bf00      	nop
 800b350:	0800b3a9 	.word	0x0800b3a9
 800b354:	0800b3a3 	.word	0x0800b3a3
 800b358:	0800b3a3 	.word	0x0800b3a3
 800b35c:	0800b3a9 	.word	0x0800b3a9
 800b360:	0800b3a9 	.word	0x0800b3a9
 800b364:	0800b3a9 	.word	0x0800b3a9
 800b368:	0800b399 	.word	0x0800b399
 800b36c:	0800b3a9 	.word	0x0800b3a9
 800b370:	0800b3a9 	.word	0x0800b3a9
 800b374:	0800b3a3 	.word	0x0800b3a3
 800b378:	0800b3a9 	.word	0x0800b3a9
 800b37c:	0800b3a9 	.word	0x0800b3a9
 800b380:	0800b3a9 	.word	0x0800b3a9
 800b384:	0800b3a9 	.word	0x0800b3a9
 800b388:	0800b3a3 	.word	0x0800b3a3
 800b38c:	0800b3a3 	.word	0x0800b3a3
 800b390:	0800b3a9 	.word	0x0800b3a9
 800b394:	0800b3a9 	.word	0x0800b3a9
                    wc_Sha224Free((wc_Sha224*)&ctx->hash.digest);
            #endif /* WOLFSSL_SHA224 */
                    break;
                case WC_HASH_TYPE_SHA256:
            #ifndef NO_SHA256
                    wc_Sha256Free((wc_Sha256*)&ctx->hash.digest);
 800b398:	687b      	ldr	r3, [r7, #4]
 800b39a:	4618      	mov	r0, r3
 800b39c:	f016 fe3b 	bl	8022016 <wc_Sha256Free>
            #endif /* !NO_SHA256 */
                    break;
 800b3a0:	e003      	b.n	800b3aa <wolfSSL_EVP_MD_CTX_cleanup+0xa2>
            #endif
            #if defined(WOLFSSL_SHA3) && defined(WOLFSSL_SHAKE256)
                case WC_HASH_TYPE_SHAKE256:
            #endif
                default:
                    ret = WOLFSSL_FAILURE;
 800b3a2:	2300      	movs	r3, #0
 800b3a4:	60fb      	str	r3, [r7, #12]
                    break;
 800b3a6:	e000      	b.n	800b3aa <wolfSSL_EVP_MD_CTX_cleanup+0xa2>
                    break;
 800b3a8:	bf00      	nop
            }
        }
        ForceZero(ctx, sizeof(*ctx));
 800b3aa:	f44f 71da 	mov.w	r1, #436	@ 0x1b4
 800b3ae:	6878      	ldr	r0, [r7, #4]
 800b3b0:	f7ff fed3 	bl	800b15a <ForceZero>
        ctx->macType = WC_HASH_TYPE_NONE;
 800b3b4:	687b      	ldr	r3, [r7, #4]
 800b3b6:	2200      	movs	r2, #0
 800b3b8:	f883 21a8 	strb.w	r2, [r3, #424]	@ 0x1a8
        return ret;
 800b3bc:	68fb      	ldr	r3, [r7, #12]
    }
 800b3be:	4618      	mov	r0, r3
 800b3c0:	3710      	adds	r7, #16
 800b3c2:	46bd      	mov	sp, r7
 800b3c4:	bd80      	pop	{r7, pc}
 800b3c6:	bf00      	nop

0800b3c8 <wolfSSL_EVP_PKEY_free>:

    return pkey;
}

void wolfSSL_EVP_PKEY_free(WOLFSSL_EVP_PKEY* key)
{
 800b3c8:	b580      	push	{r7, lr}
 800b3ca:	b08a      	sub	sp, #40	@ 0x28
 800b3cc:	af00      	add	r7, sp, #0
 800b3ce:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800b3d0:	2300      	movs	r3, #0
 800b3d2:	60fb      	str	r3, [r7, #12]
    WOLFSSL_ENTER("wolfSSL_EVP_PKEY_free");
    if (key != NULL) {
 800b3d4:	687b      	ldr	r3, [r7, #4]
 800b3d6:	2b00      	cmp	r3, #0
 800b3d8:	f000 80b8 	beq.w	800b54c <wolfSSL_EVP_PKEY_free+0x184>
        int ret;
        wolfSSL_RefDec(&key->ref, &doFree, &ret);
 800b3dc:	687b      	ldr	r3, [r7, #4]
 800b3de:	3310      	adds	r3, #16
 800b3e0:	2101      	movs	r1, #1
 800b3e2:	4618      	mov	r0, r3
 800b3e4:	f7ff fea4 	bl	800b130 <wolfSSL_Atomic_Int_FetchSub>
 800b3e8:	6278      	str	r0, [r7, #36]	@ 0x24
 800b3ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b3ec:	2b01      	cmp	r3, #1
 800b3ee:	bf0c      	ite	eq
 800b3f0:	2301      	moveq	r3, #1
 800b3f2:	2300      	movne	r3, #0
 800b3f4:	b2db      	uxtb	r3, r3
 800b3f6:	60fb      	str	r3, [r7, #12]
 800b3f8:	2300      	movs	r3, #0
 800b3fa:	60bb      	str	r3, [r7, #8]
        }
    #else
        (void)ret;
    #endif

        if (doFree) {
 800b3fc:	68fb      	ldr	r3, [r7, #12]
 800b3fe:	2b00      	cmp	r3, #0
 800b400:	f000 80a4 	beq.w	800b54c <wolfSSL_EVP_PKEY_free+0x184>
            wc_FreeRng(&key->rng);
 800b404:	687b      	ldr	r3, [r7, #4]
 800b406:	3324      	adds	r3, #36	@ 0x24
 800b408:	4618      	mov	r0, r3
 800b40a:	f014 f96b 	bl	801f6e4 <wc_FreeRng>

            if (key->pkey.ptr != NULL) {
 800b40e:	687b      	ldr	r3, [r7, #4]
 800b410:	695b      	ldr	r3, [r3, #20]
 800b412:	2b00      	cmp	r3, #0
 800b414:	d00b      	beq.n	800b42e <wolfSSL_EVP_PKEY_free+0x66>
                XFREE(key->pkey.ptr, key->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800b416:	687b      	ldr	r3, [r7, #4]
 800b418:	695b      	ldr	r3, [r3, #20]
 800b41a:	623b      	str	r3, [r7, #32]
 800b41c:	6a3b      	ldr	r3, [r7, #32]
 800b41e:	2b00      	cmp	r3, #0
 800b420:	d002      	beq.n	800b428 <wolfSSL_EVP_PKEY_free+0x60>
 800b422:	6a38      	ldr	r0, [r7, #32]
 800b424:	f013 fb52 	bl	801eacc <wolfSSL_Free>
                key->pkey.ptr = NULL;
 800b428:	687b      	ldr	r3, [r7, #4]
 800b42a:	2200      	movs	r2, #0
 800b42c:	615a      	str	r2, [r3, #20]
            }
            switch(key->type)
 800b42e:	687b      	ldr	r3, [r7, #4]
 800b430:	685b      	ldr	r3, [r3, #4]
 800b432:	f240 420c 	movw	r2, #1036	@ 0x40c
 800b436:	4293      	cmp	r3, r2
 800b438:	d04b      	beq.n	800b4d2 <wolfSSL_EVP_PKEY_free+0x10a>
 800b43a:	f240 420c 	movw	r2, #1036	@ 0x40c
 800b43e:	4293      	cmp	r3, r2
 800b440:	dc75      	bgt.n	800b52e <wolfSSL_EVP_PKEY_free+0x166>
 800b442:	2b1c      	cmp	r3, #28
 800b444:	d030      	beq.n	800b4a8 <wolfSSL_EVP_PKEY_free+0xe0>
 800b446:	2b1c      	cmp	r3, #28
 800b448:	dc71      	bgt.n	800b52e <wolfSSL_EVP_PKEY_free+0x166>
 800b44a:	2b10      	cmp	r3, #16
 800b44c:	d002      	beq.n	800b454 <wolfSSL_EVP_PKEY_free+0x8c>
 800b44e:	2b12      	cmp	r3, #18
 800b450:	d015      	beq.n	800b47e <wolfSSL_EVP_PKEY_free+0xb6>
                    }
                    break;
                #endif /* defined(WOLFSSL_CMAC) ... */

                default:
                    break;
 800b452:	e06c      	b.n	800b52e <wolfSSL_EVP_PKEY_free+0x166>
                    if (key->rsa != NULL && key->ownRsa == 1) {
 800b454:	687b      	ldr	r3, [r7, #4]
 800b456:	699b      	ldr	r3, [r3, #24]
 800b458:	2b00      	cmp	r3, #0
 800b45a:	d06a      	beq.n	800b532 <wolfSSL_EVP_PKEY_free+0x16a>
 800b45c:	687b      	ldr	r3, [r7, #4]
 800b45e:	f893 305a 	ldrb.w	r3, [r3, #90]	@ 0x5a
 800b462:	f003 0308 	and.w	r3, r3, #8
 800b466:	b2db      	uxtb	r3, r3
 800b468:	2b00      	cmp	r3, #0
 800b46a:	d062      	beq.n	800b532 <wolfSSL_EVP_PKEY_free+0x16a>
                        wolfSSL_RSA_free(key->rsa);
 800b46c:	687b      	ldr	r3, [r7, #4]
 800b46e:	699b      	ldr	r3, [r3, #24]
 800b470:	4618      	mov	r0, r3
 800b472:	f000 fc9d 	bl	800bdb0 <wolfSSL_RSA_free>
                        key->rsa = NULL;
 800b476:	687b      	ldr	r3, [r7, #4]
 800b478:	2200      	movs	r2, #0
 800b47a:	619a      	str	r2, [r3, #24]
                    break;
 800b47c:	e059      	b.n	800b532 <wolfSSL_EVP_PKEY_free+0x16a>
                    if (key->ecc != NULL && key->ownEcc == 1) {
 800b47e:	687b      	ldr	r3, [r7, #4]
 800b480:	69db      	ldr	r3, [r3, #28]
 800b482:	2b00      	cmp	r3, #0
 800b484:	d057      	beq.n	800b536 <wolfSSL_EVP_PKEY_free+0x16e>
 800b486:	687b      	ldr	r3, [r7, #4]
 800b488:	f893 305a 	ldrb.w	r3, [r3, #90]	@ 0x5a
 800b48c:	f003 0302 	and.w	r3, r3, #2
 800b490:	b2db      	uxtb	r3, r3
 800b492:	2b00      	cmp	r3, #0
 800b494:	d04f      	beq.n	800b536 <wolfSSL_EVP_PKEY_free+0x16e>
                        wolfSSL_EC_KEY_free(key->ecc);
 800b496:	687b      	ldr	r3, [r7, #4]
 800b498:	69db      	ldr	r3, [r3, #28]
 800b49a:	4618      	mov	r0, r3
 800b49c:	f000 fdca 	bl	800c034 <wolfSSL_EC_KEY_free>
                        key->ecc = NULL;
 800b4a0:	687b      	ldr	r3, [r7, #4]
 800b4a2:	2200      	movs	r2, #0
 800b4a4:	61da      	str	r2, [r3, #28]
                    break;
 800b4a6:	e046      	b.n	800b536 <wolfSSL_EVP_PKEY_free+0x16e>
                    if (key->dh != NULL && key->ownDh == 1) {
 800b4a8:	687b      	ldr	r3, [r7, #4]
 800b4aa:	6a1b      	ldr	r3, [r3, #32]
 800b4ac:	2b00      	cmp	r3, #0
 800b4ae:	d044      	beq.n	800b53a <wolfSSL_EVP_PKEY_free+0x172>
 800b4b0:	687b      	ldr	r3, [r7, #4]
 800b4b2:	f893 305a 	ldrb.w	r3, [r3, #90]	@ 0x5a
 800b4b6:	f003 0301 	and.w	r3, r3, #1
 800b4ba:	b2db      	uxtb	r3, r3
 800b4bc:	2b00      	cmp	r3, #0
 800b4be:	d03c      	beq.n	800b53a <wolfSSL_EVP_PKEY_free+0x172>
                        wolfSSL_DH_free(key->dh);
 800b4c0:	687b      	ldr	r3, [r7, #4]
 800b4c2:	6a1b      	ldr	r3, [r3, #32]
 800b4c4:	4618      	mov	r0, r3
 800b4c6:	f000 fd0d 	bl	800bee4 <wolfSSL_DH_free>
                        key->dh = NULL;
 800b4ca:	687b      	ldr	r3, [r7, #4]
 800b4cc:	2200      	movs	r2, #0
 800b4ce:	621a      	str	r2, [r3, #32]
                    break;
 800b4d0:	e033      	b.n	800b53a <wolfSSL_EVP_PKEY_free+0x172>
                    XFREE(key->hkdfSalt, NULL, DYNAMIC_TYPE_SALT);
 800b4d2:	687b      	ldr	r3, [r7, #4]
 800b4d4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800b4d6:	61fb      	str	r3, [r7, #28]
 800b4d8:	69fb      	ldr	r3, [r7, #28]
 800b4da:	2b00      	cmp	r3, #0
 800b4dc:	d002      	beq.n	800b4e4 <wolfSSL_EVP_PKEY_free+0x11c>
 800b4de:	69f8      	ldr	r0, [r7, #28]
 800b4e0:	f013 faf4 	bl	801eacc <wolfSSL_Free>
                    key->hkdfSalt = NULL;
 800b4e4:	687b      	ldr	r3, [r7, #4]
 800b4e6:	2200      	movs	r2, #0
 800b4e8:	639a      	str	r2, [r3, #56]	@ 0x38
                    XFREE(key->hkdfKey, NULL, DYNAMIC_TYPE_KEY);
 800b4ea:	687b      	ldr	r3, [r7, #4]
 800b4ec:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b4ee:	61bb      	str	r3, [r7, #24]
 800b4f0:	69bb      	ldr	r3, [r7, #24]
 800b4f2:	2b00      	cmp	r3, #0
 800b4f4:	d002      	beq.n	800b4fc <wolfSSL_EVP_PKEY_free+0x134>
 800b4f6:	69b8      	ldr	r0, [r7, #24]
 800b4f8:	f013 fae8 	bl	801eacc <wolfSSL_Free>
                    key->hkdfKey = NULL;
 800b4fc:	687b      	ldr	r3, [r7, #4]
 800b4fe:	2200      	movs	r2, #0
 800b500:	641a      	str	r2, [r3, #64]	@ 0x40
                    XFREE(key->hkdfInfo, NULL, DYNAMIC_TYPE_INFO);
 800b502:	687b      	ldr	r3, [r7, #4]
 800b504:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b506:	617b      	str	r3, [r7, #20]
 800b508:	697b      	ldr	r3, [r7, #20]
 800b50a:	2b00      	cmp	r3, #0
 800b50c:	d002      	beq.n	800b514 <wolfSSL_EVP_PKEY_free+0x14c>
 800b50e:	6978      	ldr	r0, [r7, #20]
 800b510:	f013 fadc 	bl	801eacc <wolfSSL_Free>
                    key->hkdfInfo = NULL;
 800b514:	687b      	ldr	r3, [r7, #4]
 800b516:	2200      	movs	r2, #0
 800b518:	649a      	str	r2, [r3, #72]	@ 0x48
                    key->hkdfSaltSz = 0;
 800b51a:	687b      	ldr	r3, [r7, #4]
 800b51c:	2200      	movs	r2, #0
 800b51e:	63da      	str	r2, [r3, #60]	@ 0x3c
                    key->hkdfKeySz = 0;
 800b520:	687b      	ldr	r3, [r7, #4]
 800b522:	2200      	movs	r2, #0
 800b524:	645a      	str	r2, [r3, #68]	@ 0x44
                    key->hkdfInfoSz = 0;
 800b526:	687b      	ldr	r3, [r7, #4]
 800b528:	2200      	movs	r2, #0
 800b52a:	64da      	str	r2, [r3, #76]	@ 0x4c
                    break;
 800b52c:	e006      	b.n	800b53c <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b52e:	bf00      	nop
 800b530:	e004      	b.n	800b53c <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b532:	bf00      	nop
 800b534:	e002      	b.n	800b53c <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b536:	bf00      	nop
 800b538:	e000      	b.n	800b53c <wolfSSL_EVP_PKEY_free+0x174>
                    break;
 800b53a:	bf00      	nop
            }

            wolfSSL_RefFree(&key->ref);
            XFREE(key, key->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800b53c:	687b      	ldr	r3, [r7, #4]
 800b53e:	613b      	str	r3, [r7, #16]
 800b540:	693b      	ldr	r3, [r7, #16]
 800b542:	2b00      	cmp	r3, #0
 800b544:	d002      	beq.n	800b54c <wolfSSL_EVP_PKEY_free+0x184>
 800b546:	6938      	ldr	r0, [r7, #16]
 800b548:	f013 fac0 	bl	801eacc <wolfSSL_Free>
        }
    }
}
 800b54c:	bf00      	nop
 800b54e:	3728      	adds	r7, #40	@ 0x28
 800b550:	46bd      	mov	sp, r7
 800b552:	bd80      	pop	{r7, pc}

0800b554 <wolfSSL_CertManagerNew_ex>:
 * @param [in] heap  Heap hint.
 * @return  Certificate manager object on success.
 * @return  NULL on failure.
 */
WOLFSSL_CERT_MANAGER* wolfSSL_CertManagerNew_ex(void* heap)
{
 800b554:	b580      	push	{r7, lr}
 800b556:	b084      	sub	sp, #16
 800b558:	af00      	add	r7, sp, #0
 800b55a:	6078      	str	r0, [r7, #4]
    int err = 0;
 800b55c:	2300      	movs	r3, #0
 800b55e:	60bb      	str	r3, [r7, #8]
    }
    WOLFSSL_MSG_EX("DYNAMIC_TYPE_CERT_MANAGER Allocating = %d bytes",
                    (word32)sizeof(WOLFSSL_CERT_MANAGER));

    /* Allocate memory for certificate manager. */
    cm = (WOLFSSL_CERT_MANAGER*)XMALLOC(sizeof(WOLFSSL_CERT_MANAGER), heap,
 800b560:	2070      	movs	r0, #112	@ 0x70
 800b562:	f013 fa97 	bl	801ea94 <wolfSSL_Malloc>
 800b566:	60f8      	str	r0, [r7, #12]
        DYNAMIC_TYPE_CERT_MANAGER);
    if (cm == NULL) {
 800b568:	68fb      	ldr	r3, [r7, #12]
 800b56a:	2b00      	cmp	r3, #0
 800b56c:	d101      	bne.n	800b572 <wolfSSL_CertManagerNew_ex+0x1e>
        WOLFSSL_MSG_EX("XMALLOC failed to allocate WOLFSSL_CERT_MANAGER %d "
                    "bytes.", (int)sizeof(WOLFSSL_CERT_MANAGER));
        err = 1;
 800b56e:	2301      	movs	r3, #1
 800b570:	60bb      	str	r3, [r7, #8]
    }
    if (!err) {
 800b572:	68bb      	ldr	r3, [r7, #8]
 800b574:	2b00      	cmp	r3, #0
 800b576:	d10e      	bne.n	800b596 <wolfSSL_CertManagerNew_ex+0x42>
        /* Reset all fields. */
        XMEMSET(cm, 0, sizeof(WOLFSSL_CERT_MANAGER));
 800b578:	2270      	movs	r2, #112	@ 0x70
 800b57a:	2100      	movs	r1, #0
 800b57c:	68f8      	ldr	r0, [r7, #12]
 800b57e:	f01c ffa7 	bl	80284d0 <memset>

        /* Create a mutex for use when modify table of stored CAs. */
        if (wc_InitMutex(&cm->caLock) != 0) {
 800b582:	68fb      	ldr	r3, [r7, #12]
 800b584:	335c      	adds	r3, #92	@ 0x5c
 800b586:	4618      	mov	r0, r3
 800b588:	f01b fefe 	bl	8027388 <wc_InitMutex>
 800b58c:	4603      	mov	r3, r0
 800b58e:	2b00      	cmp	r3, #0
 800b590:	d001      	beq.n	800b596 <wolfSSL_CertManagerNew_ex+0x42>
            WOLFSSL_MSG("Bad mutex init");
            err = 1;
 800b592:	2301      	movs	r3, #1
 800b594:	60bb      	str	r3, [r7, #8]
        }
    }
    if (!err) {
 800b596:	68bb      	ldr	r3, [r7, #8]
 800b598:	2b00      	cmp	r3, #0
 800b59a:	d104      	bne.n	800b5a6 <wolfSSL_CertManagerNew_ex+0x52>
        /* Initialize reference count. */
        wolfSSL_RefInit(&cm->ref, &err);
 800b59c:	68fb      	ldr	r3, [r7, #12]
 800b59e:	2201      	movs	r2, #1
 800b5a0:	66da      	str	r2, [r3, #108]	@ 0x6c
 800b5a2:	2300      	movs	r3, #0
 800b5a4:	60bb      	str	r3, [r7, #8]
    if ((!err) && (wc_InitMutex(&cm->tpLock) != 0)) {
        WOLFSSL_MSG("Bad mutex init");
        err = 1;
    }
#endif
    if (!err) {
 800b5a6:	68bb      	ldr	r3, [r7, #8]
 800b5a8:	2b00      	cmp	r3, #0
 800b5aa:	d10a      	bne.n	800b5c2 <wolfSSL_CertManagerNew_ex+0x6e>
        /* Set default minimum key sizes allowed. */
    #ifndef NO_RSA
        cm->minRsaKeySz = MIN_RSAKEY_SZ;
 800b5ac:	68fb      	ldr	r3, [r7, #12]
 800b5ae:	2280      	movs	r2, #128	@ 0x80
 800b5b0:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
    #endif
    #ifdef HAVE_ECC
        cm->minEccKeySz = MIN_ECCKEY_SZ;
 800b5b4:	68fb      	ldr	r3, [r7, #12]
 800b5b6:	221c      	movs	r2, #28
 800b5b8:	f8a3 2064 	strh.w	r2, [r3, #100]	@ 0x64
    #ifdef HAVE_DILITHIUM
        cm->minDilithiumKeySz = MIN_DILITHIUMKEY_SZ;
    #endif /* HAVE_DILITHIUM */

        /* Set heap hint to use in certificate manager operations. */
        cm->heap = heap;
 800b5bc:	68fb      	ldr	r3, [r7, #12]
 800b5be:	687a      	ldr	r2, [r7, #4]
 800b5c0:	62da      	str	r2, [r3, #44]	@ 0x2c
    }

    /* Dispose of certificate manager on error. */
    if (err && (cm != NULL)) {
 800b5c2:	68bb      	ldr	r3, [r7, #8]
 800b5c4:	2b00      	cmp	r3, #0
 800b5c6:	d007      	beq.n	800b5d8 <wolfSSL_CertManagerNew_ex+0x84>
 800b5c8:	68fb      	ldr	r3, [r7, #12]
 800b5ca:	2b00      	cmp	r3, #0
 800b5cc:	d004      	beq.n	800b5d8 <wolfSSL_CertManagerNew_ex+0x84>
        wolfSSL_CertManagerFree(cm);
 800b5ce:	68f8      	ldr	r0, [r7, #12]
 800b5d0:	f000 f807 	bl	800b5e2 <wolfSSL_CertManagerFree>
        cm = NULL;
 800b5d4:	2300      	movs	r3, #0
 800b5d6:	60fb      	str	r3, [r7, #12]
    }
    return cm;
 800b5d8:	68fb      	ldr	r3, [r7, #12]
}
 800b5da:	4618      	mov	r0, r3
 800b5dc:	3710      	adds	r7, #16
 800b5de:	46bd      	mov	sp, r7
 800b5e0:	bd80      	pop	{r7, pc}

0800b5e2 <wolfSSL_CertManagerFree>:
/* Dispose of certificate manager.
 *
 * @param [in, out] cm  Certificate manager.
 */
void wolfSSL_CertManagerFree(WOLFSSL_CERT_MANAGER* cm)
{
 800b5e2:	b580      	push	{r7, lr}
 800b5e4:	b086      	sub	sp, #24
 800b5e6:	af00      	add	r7, sp, #0
 800b5e8:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_CertManagerFree");

    /* Validate parameter. */
    if (cm != NULL) {
 800b5ea:	687b      	ldr	r3, [r7, #4]
 800b5ec:	2b00      	cmp	r3, #0
 800b5ee:	d028      	beq.n	800b642 <wolfSSL_CertManagerFree+0x60>
        int doFree = 0;
 800b5f0:	2300      	movs	r3, #0
 800b5f2:	60fb      	str	r3, [r7, #12]
        int ret;

        /* Decrement reference count and check if value is 0. */
        wolfSSL_RefDec(&cm->ref, &doFree, &ret);
 800b5f4:	687b      	ldr	r3, [r7, #4]
 800b5f6:	336c      	adds	r3, #108	@ 0x6c
 800b5f8:	2101      	movs	r1, #1
 800b5fa:	4618      	mov	r0, r3
 800b5fc:	f7ff fd98 	bl	800b130 <wolfSSL_Atomic_Int_FetchSub>
 800b600:	6178      	str	r0, [r7, #20]
 800b602:	697b      	ldr	r3, [r7, #20]
 800b604:	2b01      	cmp	r3, #1
 800b606:	bf0c      	ite	eq
 800b608:	2301      	moveq	r3, #1
 800b60a:	2300      	movne	r3, #0
 800b60c:	b2db      	uxtb	r3, r3
 800b60e:	60fb      	str	r3, [r7, #12]
 800b610:	2300      	movs	r3, #0
 800b612:	60bb      	str	r3, [r7, #8]
            WOLFSSL_MSG("Couldn't lock cm mutex");
        }
    #else
        (void)ret;
    #endif
        if (doFree) {
 800b614:	68fb      	ldr	r3, [r7, #12]
 800b616:	2b00      	cmp	r3, #0
 800b618:	d013      	beq.n	800b642 <wolfSSL_CertManagerFree+0x60>
            }
        #endif
    #endif /* HAVE_OCSP */

            /* Dispose of CA table and mutex. */
            FreeSignerTable(cm->caTable, CA_TABLE_SIZE, cm->heap);
 800b61a:	6878      	ldr	r0, [r7, #4]
 800b61c:	687b      	ldr	r3, [r7, #4]
 800b61e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b620:	461a      	mov	r2, r3
 800b622:	210b      	movs	r1, #11
 800b624:	f00d fbaa 	bl	8018d7c <FreeSignerTable>
            wc_FreeMutex(&cm->caLock);
 800b628:	687b      	ldr	r3, [r7, #4]
 800b62a:	335c      	adds	r3, #92	@ 0x5c
 800b62c:	4618      	mov	r0, r3
 800b62e:	f01b feb6 	bl	802739e <wc_FreeMutex>
        #endif

            /* Dispose of reference count. */
            wolfSSL_RefFree(&cm->ref);
            /* Dispose of certificate manager memory. */
            XFREE(cm, cm->heap, DYNAMIC_TYPE_CERT_MANAGER);
 800b632:	687b      	ldr	r3, [r7, #4]
 800b634:	613b      	str	r3, [r7, #16]
 800b636:	693b      	ldr	r3, [r7, #16]
 800b638:	2b00      	cmp	r3, #0
 800b63a:	d002      	beq.n	800b642 <wolfSSL_CertManagerFree+0x60>
 800b63c:	6938      	ldr	r0, [r7, #16]
 800b63e:	f013 fa45 	bl	801eacc <wolfSSL_Free>
        }
    }
}
 800b642:	bf00      	nop
 800b644:	3718      	adds	r7, #24
 800b646:	46bd      	mov	sp, r7
 800b648:	bd80      	pop	{r7, pc}

0800b64a <CM_VerifyBuffer_ex>:
 * @return  NOT_COMPILED_IN when converting from PEM to DER is not a feature of
 *          the wolfSSL build.
 */
int CM_VerifyBuffer_ex(WOLFSSL_CERT_MANAGER* cm, const unsigned char* buff,
    long sz, int format, int prev_err)
{
 800b64a:	b580      	push	{r7, lr}
 800b64c:	b092      	sub	sp, #72	@ 0x48
 800b64e:	af04      	add	r7, sp, #16
 800b650:	60f8      	str	r0, [r7, #12]
 800b652:	60b9      	str	r1, [r7, #8]
 800b654:	607a      	str	r2, [r7, #4]
 800b656:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800b658:	2300      	movs	r3, #0
 800b65a:	637b      	str	r3, [r7, #52]	@ 0x34
    int fatal = 0;
 800b65c:	2300      	movs	r3, #0
 800b65e:	633b      	str	r3, [r7, #48]	@ 0x30
    DerBuffer* der = NULL;
 800b660:	2300      	movs	r3, #0
 800b662:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_SMALL_STACK
    DecodedCert* cert = NULL;
 800b664:	2300      	movs	r3, #0
 800b666:	62fb      	str	r3, [r7, #44]	@ 0x2c

    (void)prev_err;

#ifdef WOLFSSL_SMALL_STACK
    /* Allocate memory for decoded certificate. */
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), cm->heap,
 800b668:	f44f 6097 	mov.w	r0, #1208	@ 0x4b8
 800b66c:	f013 fa12 	bl	801ea94 <wolfSSL_Malloc>
 800b670:	62f8      	str	r0, [r7, #44]	@ 0x2c
         DYNAMIC_TYPE_DCERT);
    if (cert == NULL) {
 800b672:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800b674:	2b00      	cmp	r3, #0
 800b676:	d104      	bne.n	800b682 <CM_VerifyBuffer_ex+0x38>
        ret = MEMORY_E;
 800b678:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800b67c:	637b      	str	r3, [r7, #52]	@ 0x34
        fatal = 1;
 800b67e:	2301      	movs	r3, #1
 800b680:	633b      	str	r3, [r7, #48]	@ 0x30
    }
    if (ret == 0)
 800b682:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b684:	2b00      	cmp	r3, #0
 800b686:	d124      	bne.n	800b6d2 <CM_VerifyBuffer_ex+0x88>
#endif
    {
        /* Reset fields of decoded certificate. */
        XMEMSET(cert, 0, sizeof(DecodedCert));
 800b688:	f44f 6297 	mov.w	r2, #1208	@ 0x4b8
 800b68c:	2100      	movs	r1, #0
 800b68e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b690:	f01c ff1e 	bl	80284d0 <memset>

        if (format == WOLFSSL_FILETYPE_PEM) {
 800b694:	683b      	ldr	r3, [r7, #0]
 800b696:	2b01      	cmp	r3, #1
 800b698:	d11b      	bne.n	800b6d2 <CM_VerifyBuffer_ex+0x88>
        #ifndef WOLFSSL_PEM_TO_DER
            ret = NOT_COMPILED_IN;
            fatal = 1;
        #else
            /* Convert to DER from PEM. */
            ret = PemToDer(buff, sz, CERT_TYPE, &der, cm->heap, NULL, NULL);
 800b69a:	68fb      	ldr	r3, [r7, #12]
 800b69c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b69e:	f107 021c 	add.w	r2, r7, #28
 800b6a2:	2100      	movs	r1, #0
 800b6a4:	9102      	str	r1, [sp, #8]
 800b6a6:	2100      	movs	r1, #0
 800b6a8:	9101      	str	r1, [sp, #4]
 800b6aa:	9300      	str	r3, [sp, #0]
 800b6ac:	4613      	mov	r3, r2
 800b6ae:	2200      	movs	r2, #0
 800b6b0:	6879      	ldr	r1, [r7, #4]
 800b6b2:	68b8      	ldr	r0, [r7, #8]
 800b6b4:	f00d ff88 	bl	80195c8 <PemToDer>
 800b6b8:	6378      	str	r0, [r7, #52]	@ 0x34
            if (ret != 0) {
 800b6ba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b6bc:	2b00      	cmp	r3, #0
 800b6be:	d002      	beq.n	800b6c6 <CM_VerifyBuffer_ex+0x7c>
                fatal = 1;
 800b6c0:	2301      	movs	r3, #1
 800b6c2:	633b      	str	r3, [r7, #48]	@ 0x30
 800b6c4:	e005      	b.n	800b6d2 <CM_VerifyBuffer_ex+0x88>
            }
            else {
                /* Replace buffer pointer and size with DER buffer. */
                buff = der->buffer;
 800b6c6:	69fb      	ldr	r3, [r7, #28]
 800b6c8:	681b      	ldr	r3, [r3, #0]
 800b6ca:	60bb      	str	r3, [r7, #8]
                sz = (long)der->length;
 800b6cc:	69fb      	ldr	r3, [r7, #28]
 800b6ce:	689b      	ldr	r3, [r3, #8]
 800b6d0:	607b      	str	r3, [r7, #4]
            }
        #endif
        }
    }
    if (ret == 0) {
 800b6d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b6d4:	2b00      	cmp	r3, #0
 800b6d6:	d10f      	bne.n	800b6f8 <CM_VerifyBuffer_ex+0xae>
        /* Create a decoded certificate with DER buffer. */
        InitDecodedCert(cert, buff, (word32)sz, cm->heap);
 800b6d8:	687a      	ldr	r2, [r7, #4]
 800b6da:	68fb      	ldr	r3, [r7, #12]
 800b6dc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b6de:	68b9      	ldr	r1, [r7, #8]
 800b6e0:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b6e2:	f009 fd04 	bl	80150ee <InitDecodedCert>
            wc_SetUnknownExtCallback(cert, cm->unknownExtCallback);
#endif

        /* Parse DER into decoded certificate fields and verify signature
         * against a known CA. */
        ret = ParseCertRelative(cert, CERT_TYPE, VERIFY, cm, NULL);
 800b6e6:	2300      	movs	r3, #0
 800b6e8:	9300      	str	r3, [sp, #0]
 800b6ea:	68fb      	ldr	r3, [r7, #12]
 800b6ec:	2201      	movs	r2, #1
 800b6ee:	2100      	movs	r1, #0
 800b6f0:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b6f2:	f00d f83c 	bl	801876e <ParseCertRelative>
 800b6f6:	6378      	str	r0, [r7, #52]	@ 0x34

    (void)fatal;

#ifndef NO_WOLFSSL_CM_VERIFY
    /* Use callback to perform verification too if available. */
    if ((!fatal) && cm->verifyCallback) {
 800b6f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800b6fa:	2b00      	cmp	r3, #0
 800b6fc:	d140      	bne.n	800b780 <CM_VerifyBuffer_ex+0x136>
 800b6fe:	68fb      	ldr	r3, [r7, #12]
 800b700:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b702:	2b00      	cmp	r3, #0
 800b704:	d03c      	beq.n	800b780 <CM_VerifyBuffer_ex+0x136>
    #endif
        buffer certBuf;

    #ifdef WOLFSSL_SMALL_STACK
        /* Allocate memory for object to hold arguments for callback. */
        args = (ProcPeerCertArgs*)XMALLOC(sizeof(ProcPeerCertArgs), cm->heap,
 800b706:	2028      	movs	r0, #40	@ 0x28
 800b708:	f013 f9c4 	bl	801ea94 <wolfSSL_Malloc>
 800b70c:	62b8      	str	r0, [r7, #40]	@ 0x28
            DYNAMIC_TYPE_TMP_BUFFER);
        if (args == NULL) {
 800b70e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b710:	2b00      	cmp	r3, #0
 800b712:	d104      	bne.n	800b71e <CM_VerifyBuffer_ex+0xd4>
            ret = MEMORY_E;
 800b714:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800b718:	637b      	str	r3, [r7, #52]	@ 0x34
            fatal = 1;
 800b71a:	2301      	movs	r3, #1
 800b71c:	633b      	str	r3, [r7, #48]	@ 0x30
        }
        if (!fatal)
 800b71e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800b720:	2b00      	cmp	r3, #0
 800b722:	d125      	bne.n	800b770 <CM_VerifyBuffer_ex+0x126>
    #endif
        {
            XMEMSET(args, 0, sizeof(ProcPeerCertArgs));
 800b724:	2228      	movs	r2, #40	@ 0x28
 800b726:	2100      	movs	r1, #0
 800b728:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800b72a:	f01c fed1 	bl	80284d0 <memset>

            /* DER encoding. */
            certBuf.buffer = (byte*)buff;
 800b72e:	68bb      	ldr	r3, [r7, #8]
 800b730:	617b      	str	r3, [r7, #20]
            certBuf.length = (unsigned int)sz;
 800b732:	687b      	ldr	r3, [r7, #4]
 800b734:	61bb      	str	r3, [r7, #24]

            /* One certificate available. */
            args->totalCerts = 1;
 800b736:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b738:	2201      	movs	r2, #1
 800b73a:	615a      	str	r2, [r3, #20]
            args->certs = &certBuf;
 800b73c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b73e:	f107 0214 	add.w	r2, r7, #20
 800b742:	601a      	str	r2, [r3, #0]
            args->dCert = cert;
 800b744:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b746:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800b748:	609a      	str	r2, [r3, #8]
            args->dCertInit = 1;
 800b74a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800b74c:	f892 3026 	ldrb.w	r3, [r2, #38]	@ 0x26
 800b750:	f043 0304 	orr.w	r3, r3, #4
 800b754:	f882 3026 	strb.w	r3, [r2, #38]	@ 0x26

            /* Replace value in ret with an error value passed in. */
            if (prev_err != 0) {
 800b758:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b75a:	2b00      	cmp	r3, #0
 800b75c:	d001      	beq.n	800b762 <CM_VerifyBuffer_ex+0x118>
                ret = prev_err;
 800b75e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b760:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            /* Use callback to verify certificate. */
            ret = DoVerifyCallback(cm, NULL, ret, args);
 800b762:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b764:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800b766:	2100      	movs	r1, #0
 800b768:	68f8      	ldr	r0, [r7, #12]
 800b76a:	f7ff fb8d 	bl	800ae88 <DoVerifyCallback>
 800b76e:	6378      	str	r0, [r7, #52]	@ 0x34
        }
    #ifdef WOLFSSL_SMALL_STACK
        /* Dispose of allocated callback args. */
        XFREE(args, cm->heap, DYNAMIC_TYPE_TMP_BUFFER);
 800b770:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b772:	627b      	str	r3, [r7, #36]	@ 0x24
 800b774:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b776:	2b00      	cmp	r3, #0
 800b778:	d002      	beq.n	800b780 <CM_VerifyBuffer_ex+0x136>
 800b77a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800b77c:	f013 f9a6 	bl	801eacc <wolfSSL_Free>
    #endif
    }
#endif

    /* Dispose of allocated memory. */
    FreeDecodedCert(cert);
 800b780:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800b782:	f009 fd8d 	bl	80152a0 <FreeDecodedCert>
    FreeDer(&der);
 800b786:	f107 031c 	add.w	r3, r7, #28
 800b78a:	4618      	mov	r0, r3
 800b78c:	f00d fbfc 	bl	8018f88 <FreeDer>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(cert, cm->heap, DYNAMIC_TYPE_DCERT);
 800b790:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800b792:	623b      	str	r3, [r7, #32]
 800b794:	6a3b      	ldr	r3, [r7, #32]
 800b796:	2b00      	cmp	r3, #0
 800b798:	d002      	beq.n	800b7a0 <CM_VerifyBuffer_ex+0x156>
 800b79a:	6a38      	ldr	r0, [r7, #32]
 800b79c:	f013 f996 	bl	801eacc <wolfSSL_Free>
#endif

    /* Convert the ret value to a return value. */
    return (ret == 0) ? WOLFSSL_SUCCESS : ret;
 800b7a0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b7a2:	2b00      	cmp	r3, #0
 800b7a4:	d001      	beq.n	800b7aa <CM_VerifyBuffer_ex+0x160>
 800b7a6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b7a8:	e000      	b.n	800b7ac <CM_VerifyBuffer_ex+0x162>
 800b7aa:	2301      	movs	r3, #1
}
 800b7ac:	4618      	mov	r0, r3
 800b7ae:	3738      	adds	r7, #56	@ 0x38
 800b7b0:	46bd      	mov	sp, r7
 800b7b2:	bd80      	pop	{r7, pc}

0800b7b4 <wolfSSL_CertManagerVerifyBuffer>:
 * @return  NOT_COMPILED_IN when converting from PEM to DER is not a feature of
 *          the wolfSSL build.
 */
int wolfSSL_CertManagerVerifyBuffer(WOLFSSL_CERT_MANAGER* cm,
    const unsigned char* buff, long sz, int format)
{
 800b7b4:	b580      	push	{r7, lr}
 800b7b6:	b088      	sub	sp, #32
 800b7b8:	af02      	add	r7, sp, #8
 800b7ba:	60f8      	str	r0, [r7, #12]
 800b7bc:	60b9      	str	r1, [r7, #8]
 800b7be:	607a      	str	r2, [r7, #4]
 800b7c0:	603b      	str	r3, [r7, #0]
    int ret;

    WOLFSSL_ENTER("wolfSSL_CertManagerVerifyBuffer");

    /* Validate parameters. */
    if ((cm == NULL) || (buff == NULL) || (sz <= 0)) {
 800b7c2:	68fb      	ldr	r3, [r7, #12]
 800b7c4:	2b00      	cmp	r3, #0
 800b7c6:	d005      	beq.n	800b7d4 <wolfSSL_CertManagerVerifyBuffer+0x20>
 800b7c8:	68bb      	ldr	r3, [r7, #8]
 800b7ca:	2b00      	cmp	r3, #0
 800b7cc:	d002      	beq.n	800b7d4 <wolfSSL_CertManagerVerifyBuffer+0x20>
 800b7ce:	687b      	ldr	r3, [r7, #4]
 800b7d0:	2b00      	cmp	r3, #0
 800b7d2:	dc03      	bgt.n	800b7dc <wolfSSL_CertManagerVerifyBuffer+0x28>
        ret = BAD_FUNC_ARG;
 800b7d4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800b7d8:	617b      	str	r3, [r7, #20]
 800b7da:	e011      	b.n	800b800 <wolfSSL_CertManagerVerifyBuffer+0x4c>
    }
    else if ((format != WOLFSSL_FILETYPE_ASN1) &&
 800b7dc:	683b      	ldr	r3, [r7, #0]
 800b7de:	2b02      	cmp	r3, #2
 800b7e0:	d005      	beq.n	800b7ee <wolfSSL_CertManagerVerifyBuffer+0x3a>
 800b7e2:	683b      	ldr	r3, [r7, #0]
 800b7e4:	2b01      	cmp	r3, #1
 800b7e6:	d002      	beq.n	800b7ee <wolfSSL_CertManagerVerifyBuffer+0x3a>
             (format != WOLFSSL_FILETYPE_PEM)) {
        ret = WOLFSSL_BAD_FILETYPE;
 800b7e8:	4b08      	ldr	r3, [pc, #32]	@ (800b80c <wolfSSL_CertManagerVerifyBuffer+0x58>)
 800b7ea:	617b      	str	r3, [r7, #20]
 800b7ec:	e008      	b.n	800b800 <wolfSSL_CertManagerVerifyBuffer+0x4c>
    }
    else {
        /* No previous error. */
        ret = CM_VerifyBuffer_ex(cm, buff, sz, format, 0);
 800b7ee:	2300      	movs	r3, #0
 800b7f0:	9300      	str	r3, [sp, #0]
 800b7f2:	683b      	ldr	r3, [r7, #0]
 800b7f4:	687a      	ldr	r2, [r7, #4]
 800b7f6:	68b9      	ldr	r1, [r7, #8]
 800b7f8:	68f8      	ldr	r0, [r7, #12]
 800b7fa:	f7ff ff26 	bl	800b64a <CM_VerifyBuffer_ex>
 800b7fe:	6178      	str	r0, [r7, #20]
    }

    return ret;
 800b800:	697b      	ldr	r3, [r7, #20]
}
 800b802:	4618      	mov	r0, r3
 800b804:	3718      	adds	r7, #24
 800b806:	46bd      	mov	sp, r7
 800b808:	bd80      	pop	{r7, pc}
 800b80a:	bf00      	nop
 800b80c:	fffffe32 	.word	0xfffffe32

0800b810 <ClientSessionToSession>:
    #endif /* SESSION_STATS */

#else  /* NO_SESSION_CACHE */

WOLFSSL_SESSION* ClientSessionToSession(const WOLFSSL_SESSION* session)
{
 800b810:	b480      	push	{r7}
 800b812:	b083      	sub	sp, #12
 800b814:	af00      	add	r7, sp, #0
 800b816:	6078      	str	r0, [r7, #4]
    return (WOLFSSL_SESSION*)session;
 800b818:	687b      	ldr	r3, [r7, #4]
}
 800b81a:	4618      	mov	r0, r3
 800b81c:	370c      	adds	r7, #12
 800b81e:	46bd      	mov	sp, r7
 800b820:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b824:	4770      	bx	lr

0800b826 <wolfSSL_FreeSession>:
    }
    return copy;
}

void wolfSSL_FreeSession(WOLFSSL_CTX* ctx, WOLFSSL_SESSION* session)
{
 800b826:	b580      	push	{r7, lr}
 800b828:	b086      	sub	sp, #24
 800b82a:	af00      	add	r7, sp, #0
 800b82c:	6078      	str	r0, [r7, #4]
 800b82e:	6039      	str	r1, [r7, #0]
    session = ClientSessionToSession(session);
 800b830:	6838      	ldr	r0, [r7, #0]
 800b832:	f7ff ffed 	bl	800b810 <ClientSessionToSession>
 800b836:	6038      	str	r0, [r7, #0]
    if (session == NULL)
 800b838:	683b      	ldr	r3, [r7, #0]
 800b83a:	2b00      	cmp	r3, #0
 800b83c:	d02f      	beq.n	800b89e <wolfSSL_FreeSession+0x78>

    (void)ctx;

    WOLFSSL_ENTER("wolfSSL_FreeSession");

    if (session->ref.count > 0) {
 800b83e:	683b      	ldr	r3, [r7, #0]
 800b840:	685b      	ldr	r3, [r3, #4]
 800b842:	2b00      	cmp	r3, #0
 800b844:	dd12      	ble.n	800b86c <wolfSSL_FreeSession+0x46>
        int ret;
        int isZero;
        wolfSSL_RefDec(&session->ref, &isZero, &ret);
 800b846:	683b      	ldr	r3, [r7, #0]
 800b848:	3304      	adds	r3, #4
 800b84a:	2101      	movs	r1, #1
 800b84c:	4618      	mov	r0, r3
 800b84e:	f7ff fc6f 	bl	800b130 <wolfSSL_Atomic_Int_FetchSub>
 800b852:	6178      	str	r0, [r7, #20]
 800b854:	697b      	ldr	r3, [r7, #20]
 800b856:	2b01      	cmp	r3, #1
 800b858:	bf0c      	ite	eq
 800b85a:	2301      	moveq	r3, #1
 800b85c:	2300      	movne	r3, #0
 800b85e:	b2db      	uxtb	r3, r3
 800b860:	60bb      	str	r3, [r7, #8]
 800b862:	2300      	movs	r3, #0
 800b864:	60fb      	str	r3, [r7, #12]
        (void)ret;
        if (!isZero) {
 800b866:	68bb      	ldr	r3, [r7, #8]
 800b868:	2b00      	cmp	r3, #0
 800b86a:	d01a      	beq.n	800b8a2 <wolfSSL_FreeSession+0x7c>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
    wolfSSL_CRYPTO_cleanup_ex_data(&session->ex_data);
#endif

    /* Make sure masterSecret is zeroed. */
    ForceZero(session->masterSecret, SECRET_LEN);
 800b86c:	683b      	ldr	r3, [r7, #0]
 800b86e:	3361      	adds	r3, #97	@ 0x61
 800b870:	2130      	movs	r1, #48	@ 0x30
 800b872:	4618      	mov	r0, r3
 800b874:	f7ff fc71 	bl	800b15a <ForceZero>
    /* Session ID is sensitive information too. */
    ForceZero(session->sessionID, ID_LEN);
 800b878:	683b      	ldr	r3, [r7, #0]
 800b87a:	3340      	adds	r3, #64	@ 0x40
 800b87c:	2120      	movs	r1, #32
 800b87e:	4618      	mov	r0, r3
 800b880:	f7ff fc6b 	bl	800b15a <ForceZero>

    if (session->type == WOLFSSL_SESSION_TYPE_HEAP) {
 800b884:	683b      	ldr	r3, [r7, #0]
 800b886:	781b      	ldrb	r3, [r3, #0]
 800b888:	2b03      	cmp	r3, #3
 800b88a:	d10b      	bne.n	800b8a4 <wolfSSL_FreeSession+0x7e>
        XFREE(session, session->heap, DYNAMIC_TYPE_SESSION);
 800b88c:	683b      	ldr	r3, [r7, #0]
 800b88e:	613b      	str	r3, [r7, #16]
 800b890:	693b      	ldr	r3, [r7, #16]
 800b892:	2b00      	cmp	r3, #0
 800b894:	d006      	beq.n	800b8a4 <wolfSSL_FreeSession+0x7e>
 800b896:	6938      	ldr	r0, [r7, #16]
 800b898:	f013 f918 	bl	801eacc <wolfSSL_Free>
 800b89c:	e002      	b.n	800b8a4 <wolfSSL_FreeSession+0x7e>
        return;
 800b89e:	bf00      	nop
 800b8a0:	e000      	b.n	800b8a4 <wolfSSL_FreeSession+0x7e>
            return;
 800b8a2:	bf00      	nop
    }
}
 800b8a4:	3718      	adds	r7, #24
 800b8a6:	46bd      	mov	sp, r7
 800b8a8:	bd80      	pop	{r7, pc}
	...

0800b8ac <wolfssl_get_global_rng>:
#if defined(OPENSSL_EXTRA) && defined(HAVE_HASHDRBG)
static WOLFSSL_DRBG_CTX* gDrbgDefCtx = NULL;
#endif

WC_RNG* wolfssl_get_global_rng(void)
{
 800b8ac:	b480      	push	{r7}
 800b8ae:	b083      	sub	sp, #12
 800b8b0:	af00      	add	r7, sp, #0
    WC_RNG* ret = NULL;
 800b8b2:	2300      	movs	r3, #0
 800b8b4:	607b      	str	r3, [r7, #4]

    if (initGlobalRNG == 0)
 800b8b6:	4b06      	ldr	r3, [pc, #24]	@ (800b8d0 <wolfssl_get_global_rng+0x24>)
 800b8b8:	681b      	ldr	r3, [r3, #0]
 800b8ba:	2b00      	cmp	r3, #0
 800b8bc:	d001      	beq.n	800b8c2 <wolfssl_get_global_rng+0x16>
        WOLFSSL_MSG("Global RNG no Init");
    else
        ret = &globalRNG;
 800b8be:	4b05      	ldr	r3, [pc, #20]	@ (800b8d4 <wolfssl_get_global_rng+0x28>)
 800b8c0:	607b      	str	r3, [r7, #4]

    return ret;
 800b8c2:	687b      	ldr	r3, [r7, #4]
}
 800b8c4:	4618      	mov	r0, r3
 800b8c6:	370c      	adds	r7, #12
 800b8c8:	46bd      	mov	sp, r7
 800b8ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8ce:	4770      	bx	lr
 800b8d0:	200026c4 	.word	0x200026c4
 800b8d4:	200026b4 	.word	0x200026b4

0800b8d8 <wolfSSL_BN_free>:
 * bn is unusable after this call.
 *
 * @param [in, out] bn  Big number to free.
 */
void wolfSSL_BN_free(WOLFSSL_BIGNUM* bn)
{
 800b8d8:	b580      	push	{r7, lr}
 800b8da:	b084      	sub	sp, #16
 800b8dc:	af00      	add	r7, sp, #0
 800b8de:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_BN_free");
#endif

    /* Validate parameter. */
    if (bn != NULL) {
 800b8e0:	687b      	ldr	r3, [r7, #4]
 800b8e2:	2b00      	cmp	r3, #0
 800b8e4:	d010      	beq.n	800b908 <wolfSSL_BN_free+0x30>
        /* Cleanup any internal representation. */
        if (bn->internal != NULL) {
 800b8e6:	687b      	ldr	r3, [r7, #4]
 800b8e8:	685b      	ldr	r3, [r3, #4]
 800b8ea:	2b00      	cmp	r3, #0
 800b8ec:	d004      	beq.n	800b8f8 <wolfSSL_BN_free+0x20>
            /* Free MP integer. */
            mp_free(&bn->mpi);
 800b8ee:	687b      	ldr	r3, [r7, #4]
 800b8f0:	3308      	adds	r3, #8
 800b8f2:	4618      	mov	r0, r3
 800b8f4:	f01a ff6c 	bl	80267d0 <mp_free>
        }
        /* Dispose of big number object. */
        XFREE(bn, NULL, DYNAMIC_TYPE_BIGINT);
 800b8f8:	687b      	ldr	r3, [r7, #4]
 800b8fa:	60fb      	str	r3, [r7, #12]
 800b8fc:	68fb      	ldr	r3, [r7, #12]
 800b8fe:	2b00      	cmp	r3, #0
 800b900:	d002      	beq.n	800b908 <wolfSSL_BN_free+0x30>
 800b902:	68f8      	ldr	r0, [r7, #12]
 800b904:	f013 f8e2 	bl	801eacc <wolfSSL_Free>
        /* bn = NULL, don't try to access or double free it */
    }
}
 800b908:	bf00      	nop
 800b90a:	3710      	adds	r7, #16
 800b90c:	46bd      	mov	sp, r7
 800b90e:	bd80      	pop	{r7, pc}

0800b910 <wolfSSL_BN_clear_free>:
 * bn is unusable after this call.
 *
 * @param [in, out] bn  Big number to clear and free.
 */
void wolfSSL_BN_clear_free(WOLFSSL_BIGNUM* bn)
{
 800b910:	b580      	push	{r7, lr}
 800b912:	b082      	sub	sp, #8
 800b914:	af00      	add	r7, sp, #0
 800b916:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_BN_clear_free");
#endif

    /* Validate parameter. */
    if (bn != NULL) {
 800b918:	687b      	ldr	r3, [r7, #4]
 800b91a:	2b00      	cmp	r3, #0
 800b91c:	d00b      	beq.n	800b936 <wolfSSL_BN_clear_free+0x26>
        /* Check for internal representation. */
        if (bn->internal != NULL) {
 800b91e:	687b      	ldr	r3, [r7, #4]
 800b920:	685b      	ldr	r3, [r3, #4]
 800b922:	2b00      	cmp	r3, #0
 800b924:	d004      	beq.n	800b930 <wolfSSL_BN_clear_free+0x20>
            /* Zeroize MP integer. */
            mp_forcezero((mp_int*)bn->internal);
 800b926:	687b      	ldr	r3, [r7, #4]
 800b928:	685b      	ldr	r3, [r3, #4]
 800b92a:	4618      	mov	r0, r3
 800b92c:	f01a ff2c 	bl	8026788 <mp_forcezero>
        }
        /* Dispose of big number. */
        wolfSSL_BN_free(bn);
 800b930:	6878      	ldr	r0, [r7, #4]
 800b932:	f7ff ffd1 	bl	800b8d8 <wolfSSL_BN_free>
    }
}
 800b936:	bf00      	nop
 800b938:	3708      	adds	r7, #8
 800b93a:	46bd      	mov	sp, r7
 800b93c:	bd80      	pop	{r7, pc}
	...

0800b940 <wolfSSL_BN_free_one>:
    }

    return one;
}

static void wolfSSL_BN_free_one(void) {
 800b940:	b580      	push	{r7, lr}
 800b942:	af00      	add	r7, sp, #0
    wolfSSL_BN_free(bn_one);
 800b944:	4b04      	ldr	r3, [pc, #16]	@ (800b958 <wolfSSL_BN_free_one+0x18>)
 800b946:	681b      	ldr	r3, [r3, #0]
 800b948:	4618      	mov	r0, r3
 800b94a:	f7ff ffc5 	bl	800b8d8 <wolfSSL_BN_free>
    bn_one = NULL;
 800b94e:	4b02      	ldr	r3, [pc, #8]	@ (800b958 <wolfSSL_BN_free_one+0x18>)
 800b950:	2200      	movs	r2, #0
 800b952:	601a      	str	r2, [r3, #0]
}
 800b954:	bf00      	nop
 800b956:	bd80      	pop	{r7, pc}
 800b958:	200026e0 	.word	0x200026e0

0800b95c <wolfSSL_ASN1_INTEGER_free>:
/* Free the ASN.1 INTEGER object and any dynamically allocated data.
 *
 * @param [in, out] in  ASN.1 INTEGER object.
 */
void wolfSSL_ASN1_INTEGER_free(WOLFSSL_ASN1_INTEGER* in)
{
 800b95c:	b580      	push	{r7, lr}
 800b95e:	b084      	sub	sp, #16
 800b960:	af00      	add	r7, sp, #0
 800b962:	6078      	str	r0, [r7, #4]
    if ((in != NULL) && (in->isDynamic)) {
 800b964:	687b      	ldr	r3, [r7, #4]
 800b966:	2b00      	cmp	r3, #0
 800b968:	d010      	beq.n	800b98c <wolfSSL_ASN1_INTEGER_free+0x30>
 800b96a:	687b      	ldr	r3, [r7, #4]
 800b96c:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b970:	f003 0301 	and.w	r3, r3, #1
 800b974:	b2db      	uxtb	r3, r3
 800b976:	2b00      	cmp	r3, #0
 800b978:	d008      	beq.n	800b98c <wolfSSL_ASN1_INTEGER_free+0x30>
        /* Dispose of any data allocated in INTEGER. */
        XFREE(in->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800b97a:	687b      	ldr	r3, [r7, #4]
 800b97c:	699b      	ldr	r3, [r3, #24]
 800b97e:	60fb      	str	r3, [r7, #12]
 800b980:	68fb      	ldr	r3, [r7, #12]
 800b982:	2b00      	cmp	r3, #0
 800b984:	d002      	beq.n	800b98c <wolfSSL_ASN1_INTEGER_free+0x30>
 800b986:	68f8      	ldr	r0, [r7, #12]
 800b988:	f013 f8a0 	bl	801eacc <wolfSSL_Free>
    }
    /* Dispose of the ASN.1 INTEGER object. */
    XFREE(in, NULL, DYNAMIC_TYPE_OPENSSL);
 800b98c:	687b      	ldr	r3, [r7, #4]
 800b98e:	60bb      	str	r3, [r7, #8]
 800b990:	68bb      	ldr	r3, [r7, #8]
 800b992:	2b00      	cmp	r3, #0
 800b994:	d002      	beq.n	800b99c <wolfSSL_ASN1_INTEGER_free+0x40>
 800b996:	68b8      	ldr	r0, [r7, #8]
 800b998:	f013 f898 	bl	801eacc <wolfSSL_Free>
}
 800b99c:	bf00      	nop
 800b99e:	3710      	adds	r7, #16
 800b9a0:	46bd      	mov	sp, r7
 800b9a2:	bd80      	pop	{r7, pc}

0800b9a4 <wolfSSL_ASN1_OBJECT_new>:
 *
 * @return  ASN.1 OBJECT_ID object on success.
 * @return  NULL when dynamic memory allocation fails.
 */
WOLFSSL_ASN1_OBJECT* wolfSSL_ASN1_OBJECT_new(void)
{
 800b9a4:	b580      	push	{r7, lr}
 800b9a6:	b082      	sub	sp, #8
 800b9a8:	af00      	add	r7, sp, #0
    WOLFSSL_ASN1_OBJECT* obj;

    /* Allocate memory for new ASN.1 OBJECT. */
    obj = (WOLFSSL_ASN1_OBJECT*)XMALLOC(sizeof(WOLFSSL_ASN1_OBJECT), NULL,
 800b9aa:	20b0      	movs	r0, #176	@ 0xb0
 800b9ac:	f013 f872 	bl	801ea94 <wolfSSL_Malloc>
 800b9b0:	6078      	str	r0, [r7, #4]
        DYNAMIC_TYPE_ASN1);
    if (obj != NULL) {
 800b9b2:	687b      	ldr	r3, [r7, #4]
 800b9b4:	2b00      	cmp	r3, #0
 800b9b6:	d013      	beq.n	800b9e0 <wolfSSL_ASN1_OBJECT_new+0x3c>
        XMEMSET(obj, 0, sizeof(WOLFSSL_ASN1_OBJECT));
 800b9b8:	22b0      	movs	r2, #176	@ 0xb0
 800b9ba:	2100      	movs	r1, #0
 800b9bc:	6878      	ldr	r0, [r7, #4]
 800b9be:	f01c fd87 	bl	80284d0 <memset>
        /* Setup pointers. */
        obj->d.ia5 = &(obj->d.ia5_internal);
 800b9c2:	687b      	ldr	r3, [r7, #4]
 800b9c4:	f103 0250 	add.w	r2, r3, #80	@ 0x50
 800b9c8:	687b      	ldr	r3, [r7, #4]
 800b9ca:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
    #if defined(OPENSSL_ALL)
        obj->d.iPAddress = &(obj->d.iPAddress_internal);
    #endif
        /* Object was allocated. */
        obj->dynamic |= WOLFSSL_ASN1_DYNAMIC;
 800b9ce:	687b      	ldr	r3, [r7, #4]
 800b9d0:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800b9d4:	f043 0301 	orr.w	r3, r3, #1
 800b9d8:	b2da      	uxtb	r2, r3
 800b9da:	687b      	ldr	r3, [r7, #4]
 800b9dc:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
    }

    return obj;
 800b9e0:	687b      	ldr	r3, [r7, #4]
}
 800b9e2:	4618      	mov	r0, r3
 800b9e4:	3708      	adds	r7, #8
 800b9e6:	46bd      	mov	sp, r7
 800b9e8:	bd80      	pop	{r7, pc}

0800b9ea <wolfSSL_ASN1_OBJECT_free>:
 * Do not use obj after calling this function.
 *
 * @param [in, out] obj  ASN.1 OBJECT_ID object.
 */
void wolfSSL_ASN1_OBJECT_free(WOLFSSL_ASN1_OBJECT* obj)
{
 800b9ea:	b580      	push	{r7, lr}
 800b9ec:	b084      	sub	sp, #16
 800b9ee:	af00      	add	r7, sp, #0
 800b9f0:	6078      	str	r0, [r7, #4]
    if (obj != NULL) {
 800b9f2:	687b      	ldr	r3, [r7, #4]
 800b9f4:	2b00      	cmp	r3, #0
 800b9f6:	d02d      	beq.n	800ba54 <wolfSSL_ASN1_OBJECT_free+0x6a>
        /* Check for dynamically allocated copy of encoded data. */
        if ((obj->dynamic & WOLFSSL_ASN1_DYNAMIC_DATA) != 0) {
 800b9f8:	687b      	ldr	r3, [r7, #4]
 800b9fa:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800b9fe:	f003 0302 	and.w	r3, r3, #2
 800ba02:	2b00      	cmp	r3, #0
 800ba04:	d00b      	beq.n	800ba1e <wolfSSL_ASN1_OBJECT_free+0x34>
        #ifdef WOLFSSL_DEBUG_OPENSSL
            WOLFSSL_MSG("Freeing ASN1 data");
        #endif
            XFREE((void*)obj->obj, obj->heap, DYNAMIC_TYPE_ASN1);
 800ba06:	687b      	ldr	r3, [r7, #4]
 800ba08:	685b      	ldr	r3, [r3, #4]
 800ba0a:	60fb      	str	r3, [r7, #12]
 800ba0c:	68fb      	ldr	r3, [r7, #12]
 800ba0e:	2b00      	cmp	r3, #0
 800ba10:	d002      	beq.n	800ba18 <wolfSSL_ASN1_OBJECT_free+0x2e>
 800ba12:	68f8      	ldr	r0, [r7, #12]
 800ba14:	f013 f85a 	bl	801eacc <wolfSSL_Free>
            obj->obj = NULL;
 800ba18:	687b      	ldr	r3, [r7, #4]
 800ba1a:	2200      	movs	r2, #0
 800ba1c:	605a      	str	r2, [r3, #4]
        }
    #if defined(OPENSSL_EXTRA)
        /* Check for path length ASN.1 INTEGER - X.509 extension. */
        if (obj->pathlen != NULL) {
 800ba1e:	687b      	ldr	r3, [r7, #4]
 800ba20:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800ba22:	2b00      	cmp	r3, #0
 800ba24:	d007      	beq.n	800ba36 <wolfSSL_ASN1_OBJECT_free+0x4c>
            wolfSSL_ASN1_INTEGER_free(obj->pathlen);
 800ba26:	687b      	ldr	r3, [r7, #4]
 800ba28:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800ba2a:	4618      	mov	r0, r3
 800ba2c:	f7ff ff96 	bl	800b95c <wolfSSL_ASN1_INTEGER_free>
            obj->pathlen = NULL;
 800ba30:	687b      	ldr	r3, [r7, #4]
 800ba32:	2200      	movs	r2, #0
 800ba34:	645a      	str	r2, [r3, #68]	@ 0x44
        }
    #endif
        /* Check whether object was dynamically allocated. */
        if ((obj->dynamic & WOLFSSL_ASN1_DYNAMIC) != 0) {
 800ba36:	687b      	ldr	r3, [r7, #4]
 800ba38:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800ba3c:	f003 0301 	and.w	r3, r3, #1
 800ba40:	2b00      	cmp	r3, #0
 800ba42:	d007      	beq.n	800ba54 <wolfSSL_ASN1_OBJECT_free+0x6a>
    #ifdef WOLFSSL_DEBUG_OPENSSL
            WOLFSSL_MSG("Freeing ASN1 OBJECT");
    #endif
            XFREE(obj, NULL, DYNAMIC_TYPE_ASN1);
 800ba44:	687b      	ldr	r3, [r7, #4]
 800ba46:	60bb      	str	r3, [r7, #8]
 800ba48:	68bb      	ldr	r3, [r7, #8]
 800ba4a:	2b00      	cmp	r3, #0
 800ba4c:	d002      	beq.n	800ba54 <wolfSSL_ASN1_OBJECT_free+0x6a>
 800ba4e:	68b8      	ldr	r0, [r7, #8]
 800ba50:	f013 f83c 	bl	801eacc <wolfSSL_Free>
        }
    }
}
 800ba54:	bf00      	nop
 800ba56:	3710      	adds	r7, #16
 800ba58:	46bd      	mov	sp, r7
 800ba5a:	bd80      	pop	{r7, pc}

0800ba5c <wolfSSL_ASN1_STRING_new>:
 *
 * @return  New ASN.1 STRING object on success.
 * @return  NULL when dynamic memory allocation fails.
 */
WOLFSSL_ASN1_STRING* wolfSSL_ASN1_STRING_new(void)
{
 800ba5c:	b580      	push	{r7, lr}
 800ba5e:	b082      	sub	sp, #8
 800ba60:	af00      	add	r7, sp, #0

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_new");
#endif

    asn1 = (WOLFSSL_ASN1_STRING*)XMALLOC(sizeof(WOLFSSL_ASN1_STRING), NULL,
 800ba62:	2058      	movs	r0, #88	@ 0x58
 800ba64:	f013 f816 	bl	801ea94 <wolfSSL_Malloc>
 800ba68:	6078      	str	r0, [r7, #4]
        DYNAMIC_TYPE_OPENSSL);
    if (asn1 != NULL) {
 800ba6a:	687b      	ldr	r3, [r7, #4]
 800ba6c:	2b00      	cmp	r3, #0
 800ba6e:	d004      	beq.n	800ba7a <wolfSSL_ASN1_STRING_new+0x1e>
        XMEMSET(asn1, 0, sizeof(WOLFSSL_ASN1_STRING));
 800ba70:	2258      	movs	r2, #88	@ 0x58
 800ba72:	2100      	movs	r1, #0
 800ba74:	6878      	ldr	r0, [r7, #4]
 800ba76:	f01c fd2b 	bl	80284d0 <memset>
    }

    return asn1;
 800ba7a:	687b      	ldr	r3, [r7, #4]
}
 800ba7c:	4618      	mov	r0, r3
 800ba7e:	3708      	adds	r7, #8
 800ba80:	46bd      	mov	sp, r7
 800ba82:	bd80      	pop	{r7, pc}

0800ba84 <wolfSSL_ASN1_STRING_type_new>:
 * @param [in] type  Encoding type.
 * @return  New ASN.1 STRING object on success.
 * @return  NULL when dynamic memory allocation fails.
 */
WOLFSSL_ASN1_STRING* wolfSSL_ASN1_STRING_type_new(int type)
{
 800ba84:	b580      	push	{r7, lr}
 800ba86:	b084      	sub	sp, #16
 800ba88:	af00      	add	r7, sp, #0
 800ba8a:	6078      	str	r0, [r7, #4]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_type_new");
#endif

    asn1 = wolfSSL_ASN1_STRING_new();
 800ba8c:	f7ff ffe6 	bl	800ba5c <wolfSSL_ASN1_STRING_new>
 800ba90:	60f8      	str	r0, [r7, #12]
    if (asn1 != NULL) {
 800ba92:	68fb      	ldr	r3, [r7, #12]
 800ba94:	2b00      	cmp	r3, #0
 800ba96:	d002      	beq.n	800ba9e <wolfSSL_ASN1_STRING_type_new+0x1a>
        asn1->type = type;
 800ba98:	68fb      	ldr	r3, [r7, #12]
 800ba9a:	687a      	ldr	r2, [r7, #4]
 800ba9c:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    return asn1;
 800ba9e:	68fb      	ldr	r3, [r7, #12]
}
 800baa0:	4618      	mov	r0, r3
 800baa2:	3710      	adds	r7, #16
 800baa4:	46bd      	mov	sp, r7
 800baa6:	bd80      	pop	{r7, pc}

0800baa8 <wolfSSL_ASN1_STRING_free>:
/* Dispose of ASN.1 STRING object.
 *
 * @param [in, out] asn1  ASN.1 STRING object.
 */
void wolfSSL_ASN1_STRING_free(WOLFSSL_ASN1_STRING* asn1)
{
 800baa8:	b580      	push	{r7, lr}
 800baaa:	b084      	sub	sp, #16
 800baac:	af00      	add	r7, sp, #0
 800baae:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_free");
#endif

    /* Check we have an object to free. */
    if (asn1 != NULL) {
 800bab0:	687b      	ldr	r3, [r7, #4]
 800bab2:	2b00      	cmp	r3, #0
 800bab4:	d014      	beq.n	800bae0 <wolfSSL_ASN1_STRING_free+0x38>
        /* Dispose of dynamic data. */
        if ((asn1->length > 0) && asn1->isDynamic) {
 800bab6:	687b      	ldr	r3, [r7, #4]
 800bab8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800baba:	2b00      	cmp	r3, #0
 800babc:	dd10      	ble.n	800bae0 <wolfSSL_ASN1_STRING_free+0x38>
 800babe:	687b      	ldr	r3, [r7, #4]
 800bac0:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800bac4:	f003 0301 	and.w	r3, r3, #1
 800bac8:	b2db      	uxtb	r3, r3
 800baca:	2b00      	cmp	r3, #0
 800bacc:	d008      	beq.n	800bae0 <wolfSSL_ASN1_STRING_free+0x38>
            XFREE(asn1->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800bace:	687b      	ldr	r3, [r7, #4]
 800bad0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bad2:	60fb      	str	r3, [r7, #12]
 800bad4:	68fb      	ldr	r3, [r7, #12]
 800bad6:	2b00      	cmp	r3, #0
 800bad8:	d002      	beq.n	800bae0 <wolfSSL_ASN1_STRING_free+0x38>
 800bada:	68f8      	ldr	r0, [r7, #12]
 800badc:	f012 fff6 	bl	801eacc <wolfSSL_Free>
        }
    }
    /* Dispose of ASN.1 STRING object. */
    XFREE(asn1, NULL, DYNAMIC_TYPE_OPENSSL);
 800bae0:	687b      	ldr	r3, [r7, #4]
 800bae2:	60bb      	str	r3, [r7, #8]
 800bae4:	68bb      	ldr	r3, [r7, #8]
 800bae6:	2b00      	cmp	r3, #0
 800bae8:	d002      	beq.n	800baf0 <wolfSSL_ASN1_STRING_free+0x48>
 800baea:	68b8      	ldr	r0, [r7, #8]
 800baec:	f012 ffee 	bl	801eacc <wolfSSL_Free>
}
 800baf0:	bf00      	nop
 800baf2:	3710      	adds	r7, #16
 800baf4:	46bd      	mov	sp, r7
 800baf6:	bd80      	pop	{r7, pc}

0800baf8 <wolfSSL_ASN1_STRING_type>:
 * @param [in] asn1  ASN.1 STRING object.
 * @return  Encoding type on success.
 * @return  0 when asn1 is NULL or no encoding set.
 */
int wolfSSL_ASN1_STRING_type(const WOLFSSL_ASN1_STRING* asn1)
{
 800baf8:	b480      	push	{r7}
 800bafa:	b085      	sub	sp, #20
 800bafc:	af00      	add	r7, sp, #0
 800bafe:	6078      	str	r0, [r7, #4]
    int type = 0;
 800bb00:	2300      	movs	r3, #0
 800bb02:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_type");
#endif

    if (asn1 != NULL) {
 800bb04:	687b      	ldr	r3, [r7, #4]
 800bb06:	2b00      	cmp	r3, #0
 800bb08:	d002      	beq.n	800bb10 <wolfSSL_ASN1_STRING_type+0x18>
        type = asn1->type;
 800bb0a:	687b      	ldr	r3, [r7, #4]
 800bb0c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bb0e:	60fb      	str	r3, [r7, #12]
    }

    return type;
 800bb10:	68fb      	ldr	r3, [r7, #12]
}
 800bb12:	4618      	mov	r0, r3
 800bb14:	3714      	adds	r7, #20
 800bb16:	46bd      	mov	sp, r7
 800bb18:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb1c:	4770      	bx	lr

0800bb1e <wolfSSL_ASN1_STRING_data>:
 * @param [in] asn  ASN.1 STRING object.
 * @return  Buffer with string on success.
 * @return  NULL when asn is NULL or no data set.
 */
unsigned char* wolfSSL_ASN1_STRING_data(WOLFSSL_ASN1_STRING* asn)
{
 800bb1e:	b480      	push	{r7}
 800bb20:	b085      	sub	sp, #20
 800bb22:	af00      	add	r7, sp, #0
 800bb24:	6078      	str	r0, [r7, #4]
    char* data = NULL;
 800bb26:	2300      	movs	r3, #0
 800bb28:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_data");
#endif

    if (asn != NULL) {
 800bb2a:	687b      	ldr	r3, [r7, #4]
 800bb2c:	2b00      	cmp	r3, #0
 800bb2e:	d002      	beq.n	800bb36 <wolfSSL_ASN1_STRING_data+0x18>
        data = asn->data;
 800bb30:	687b      	ldr	r3, [r7, #4]
 800bb32:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bb34:	60fb      	str	r3, [r7, #12]
    }

    return (unsigned char*)data;
 800bb36:	68fb      	ldr	r3, [r7, #12]
}
 800bb38:	4618      	mov	r0, r3
 800bb3a:	3714      	adds	r7, #20
 800bb3c:	46bd      	mov	sp, r7
 800bb3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb42:	4770      	bx	lr

0800bb44 <wolfSSL_ASN1_STRING_length>:
 * @param [in] asn  ASN.1 STRING object.
 * @return  String length on success.
 * @return  0 when asn is NULL or no data set.
 */
int wolfSSL_ASN1_STRING_length(const WOLFSSL_ASN1_STRING* asn)
{
 800bb44:	b480      	push	{r7}
 800bb46:	b085      	sub	sp, #20
 800bb48:	af00      	add	r7, sp, #0
 800bb4a:	6078      	str	r0, [r7, #4]
    int len = 0;
 800bb4c:	2300      	movs	r3, #0
 800bb4e:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_length");
#endif

    if (asn) {
 800bb50:	687b      	ldr	r3, [r7, #4]
 800bb52:	2b00      	cmp	r3, #0
 800bb54:	d002      	beq.n	800bb5c <wolfSSL_ASN1_STRING_length+0x18>
        len = asn->length;
 800bb56:	687b      	ldr	r3, [r7, #4]
 800bb58:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800bb5a:	60fb      	str	r3, [r7, #12]
    }

    return len;
 800bb5c:	68fb      	ldr	r3, [r7, #12]
}
 800bb5e:	4618      	mov	r0, r3
 800bb60:	3714      	adds	r7, #20
 800bb62:	46bd      	mov	sp, r7
 800bb64:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb68:	4770      	bx	lr

0800bb6a <wolfSSL_ASN1_STRING_set>:
 * @return  1 on success.
 * @return  0 when asn1 is NULL or data is NULL and sz is not zero.
 * @return  0 when dynamic memory allocation fails.
 */
int wolfSSL_ASN1_STRING_set(WOLFSSL_ASN1_STRING* asn1, const void* data, int sz)
{
 800bb6a:	b580      	push	{r7, lr}
 800bb6c:	b086      	sub	sp, #24
 800bb6e:	af00      	add	r7, sp, #0
 800bb70:	60f8      	str	r0, [r7, #12]
 800bb72:	60b9      	str	r1, [r7, #8]
 800bb74:	607a      	str	r2, [r7, #4]
    int ret = 1;
 800bb76:	2301      	movs	r3, #1
 800bb78:	617b      	str	r3, [r7, #20]
#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_ASN1_STRING_set");
#endif

    /* Validate parameters. */
    if ((asn1 == NULL) || ((data == NULL) && (sz != 0))) {
 800bb7a:	68fb      	ldr	r3, [r7, #12]
 800bb7c:	2b00      	cmp	r3, #0
 800bb7e:	d005      	beq.n	800bb8c <wolfSSL_ASN1_STRING_set+0x22>
 800bb80:	68bb      	ldr	r3, [r7, #8]
 800bb82:	2b00      	cmp	r3, #0
 800bb84:	d104      	bne.n	800bb90 <wolfSSL_ASN1_STRING_set+0x26>
 800bb86:	687b      	ldr	r3, [r7, #4]
 800bb88:	2b00      	cmp	r3, #0
 800bb8a:	d001      	beq.n	800bb90 <wolfSSL_ASN1_STRING_set+0x26>
        ret = 0;
 800bb8c:	2300      	movs	r3, #0
 800bb8e:	617b      	str	r3, [r7, #20]
    }

    /* Calculate size from data if not passed in. */
    if ((ret == 1) && (sz < 0)) {
 800bb90:	697b      	ldr	r3, [r7, #20]
 800bb92:	2b01      	cmp	r3, #1
 800bb94:	d10c      	bne.n	800bbb0 <wolfSSL_ASN1_STRING_set+0x46>
 800bb96:	687b      	ldr	r3, [r7, #4]
 800bb98:	2b00      	cmp	r3, #0
 800bb9a:	da09      	bge.n	800bbb0 <wolfSSL_ASN1_STRING_set+0x46>
        sz = (int)XSTRLEN((const char*)data);
 800bb9c:	68b8      	ldr	r0, [r7, #8]
 800bb9e:	f7f4 fb21 	bl	80001e4 <strlen>
 800bba2:	4603      	mov	r3, r0
 800bba4:	607b      	str	r3, [r7, #4]
        if (sz < 0) {
 800bba6:	687b      	ldr	r3, [r7, #4]
 800bba8:	2b00      	cmp	r3, #0
 800bbaa:	da01      	bge.n	800bbb0 <wolfSSL_ASN1_STRING_set+0x46>
            ret = 0;
 800bbac:	2300      	movs	r3, #0
 800bbae:	617b      	str	r3, [r7, #20]
        }
    }

    if (ret == 1) {
 800bbb0:	697b      	ldr	r3, [r7, #20]
 800bbb2:	2b01      	cmp	r3, #1
 800bbb4:	d13d      	bne.n	800bc32 <wolfSSL_ASN1_STRING_set+0xc8>
        /* Dispose of any existing dynamic data. */
        if (asn1->isDynamic) {
 800bbb6:	68fb      	ldr	r3, [r7, #12]
 800bbb8:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800bbbc:	f003 0301 	and.w	r3, r3, #1
 800bbc0:	b2db      	uxtb	r3, r3
 800bbc2:	2b00      	cmp	r3, #0
 800bbc4:	d00b      	beq.n	800bbde <wolfSSL_ASN1_STRING_set+0x74>
            XFREE(asn1->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800bbc6:	68fb      	ldr	r3, [r7, #12]
 800bbc8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bbca:	613b      	str	r3, [r7, #16]
 800bbcc:	693b      	ldr	r3, [r7, #16]
 800bbce:	2b00      	cmp	r3, #0
 800bbd0:	d002      	beq.n	800bbd8 <wolfSSL_ASN1_STRING_set+0x6e>
 800bbd2:	6938      	ldr	r0, [r7, #16]
 800bbd4:	f012 ff7a 	bl	801eacc <wolfSSL_Free>
            asn1->data = NULL;
 800bbd8:	68fb      	ldr	r3, [r7, #12]
 800bbda:	2200      	movs	r2, #0
 800bbdc:	64da      	str	r2, [r3, #76]	@ 0x4c
        }

        /* Check string will fit - including NUL. */
        if (sz + 1 > CTC_NAME_SIZE) {
 800bbde:	687b      	ldr	r3, [r7, #4]
 800bbe0:	2b3f      	cmp	r3, #63	@ 0x3f
 800bbe2:	dd16      	ble.n	800bc12 <wolfSSL_ASN1_STRING_set+0xa8>
            /* Allocate new buffer. */
            asn1->data = (char*)XMALLOC((size_t)(sz + 1), NULL,
 800bbe4:	687b      	ldr	r3, [r7, #4]
 800bbe6:	3301      	adds	r3, #1
 800bbe8:	4618      	mov	r0, r3
 800bbea:	f012 ff53 	bl	801ea94 <wolfSSL_Malloc>
 800bbee:	4602      	mov	r2, r0
 800bbf0:	68fb      	ldr	r3, [r7, #12]
 800bbf2:	64da      	str	r2, [r3, #76]	@ 0x4c
                DYNAMIC_TYPE_OPENSSL);
            if (asn1->data == NULL) {
 800bbf4:	68fb      	ldr	r3, [r7, #12]
 800bbf6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bbf8:	2b00      	cmp	r3, #0
 800bbfa:	d102      	bne.n	800bc02 <wolfSSL_ASN1_STRING_set+0x98>
                ret = 0;
 800bbfc:	2300      	movs	r3, #0
 800bbfe:	617b      	str	r3, [r7, #20]
 800bc00:	e017      	b.n	800bc32 <wolfSSL_ASN1_STRING_set+0xc8>
            }
            else {
                /* Ensure buffer will be freed. */
                asn1->isDynamic = 1;
 800bc02:	68fa      	ldr	r2, [r7, #12]
 800bc04:	f892 3054 	ldrb.w	r3, [r2, #84]	@ 0x54
 800bc08:	f043 0301 	orr.w	r3, r3, #1
 800bc0c:	f882 3054 	strb.w	r3, [r2, #84]	@ 0x54
 800bc10:	e00f      	b.n	800bc32 <wolfSSL_ASN1_STRING_set+0xc8>
            }
        }
        else {
            /* Clear out fixed array and use it for data. */
            XMEMSET(asn1->strData, 0, CTC_NAME_SIZE);
 800bc12:	68fb      	ldr	r3, [r7, #12]
 800bc14:	2240      	movs	r2, #64	@ 0x40
 800bc16:	2100      	movs	r1, #0
 800bc18:	4618      	mov	r0, r3
 800bc1a:	f01c fc59 	bl	80284d0 <memset>
            asn1->data = asn1->strData;
 800bc1e:	68fa      	ldr	r2, [r7, #12]
 800bc20:	68fb      	ldr	r3, [r7, #12]
 800bc22:	64da      	str	r2, [r3, #76]	@ 0x4c
            asn1->isDynamic = 0;
 800bc24:	68fa      	ldr	r2, [r7, #12]
 800bc26:	f892 3054 	ldrb.w	r3, [r2, #84]	@ 0x54
 800bc2a:	f023 0301 	bic.w	r3, r3, #1
 800bc2e:	f882 3054 	strb.w	r3, [r2, #84]	@ 0x54
        }
    }
    if (ret == 1) {
 800bc32:	697b      	ldr	r3, [r7, #20]
 800bc34:	2b01      	cmp	r3, #1
 800bc36:	d112      	bne.n	800bc5e <wolfSSL_ASN1_STRING_set+0xf4>
        /* Check if there is a string to copy. */
        if (data != NULL) {
 800bc38:	68bb      	ldr	r3, [r7, #8]
 800bc3a:	2b00      	cmp	r3, #0
 800bc3c:	d00c      	beq.n	800bc58 <wolfSSL_ASN1_STRING_set+0xee>
            /* Copy string and append NUL. */
            XMEMCPY(asn1->data, data, (size_t)sz);
 800bc3e:	68fb      	ldr	r3, [r7, #12]
 800bc40:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bc42:	687a      	ldr	r2, [r7, #4]
 800bc44:	68b9      	ldr	r1, [r7, #8]
 800bc46:	4618      	mov	r0, r3
 800bc48:	f01c fcac 	bl	80285a4 <memcpy>
            asn1->data[sz] = '\0';
 800bc4c:	68fb      	ldr	r3, [r7, #12]
 800bc4e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800bc50:	687b      	ldr	r3, [r7, #4]
 800bc52:	4413      	add	r3, r2
 800bc54:	2200      	movs	r2, #0
 800bc56:	701a      	strb	r2, [r3, #0]
        }
        /* Set size of string. */
        asn1->length = sz;
 800bc58:	68fb      	ldr	r3, [r7, #12]
 800bc5a:	687a      	ldr	r2, [r7, #4]
 800bc5c:	641a      	str	r2, [r3, #64]	@ 0x40
    }

    return ret;
 800bc5e:	697b      	ldr	r3, [r7, #20]
}
 800bc60:	4618      	mov	r0, r3
 800bc62:	3718      	adds	r7, #24
 800bc64:	46bd      	mov	sp, r7
 800bc66:	bd80      	pop	{r7, pc}

0800bc68 <wolfssl_asn1_type_free_value>:
/* Free the ASN.1 TYPE object's value field.
 *
 * @param [in, out] at  ASN.1 TYPE object.
 */
static void wolfssl_asn1_type_free_value(WOLFSSL_ASN1_TYPE* at)
{
 800bc68:	b580      	push	{r7, lr}
 800bc6a:	b082      	sub	sp, #8
 800bc6c:	af00      	add	r7, sp, #0
 800bc6e:	6078      	str	r0, [r7, #4]
    switch (at->type) {
 800bc70:	687b      	ldr	r3, [r7, #4]
 800bc72:	681b      	ldr	r3, [r3, #0]
 800bc74:	2b1c      	cmp	r3, #28
 800bc76:	dc35      	bgt.n	800bce4 <wolfssl_asn1_type_free_value+0x7c>
 800bc78:	2b0c      	cmp	r3, #12
 800bc7a:	da08      	bge.n	800bc8e <wolfssl_asn1_type_free_value+0x26>
 800bc7c:	2b06      	cmp	r3, #6
 800bc7e:	d025      	beq.n	800bccc <wolfssl_asn1_type_free_value+0x64>
 800bc80:	2b06      	cmp	r3, #6
 800bc82:	dc2f      	bgt.n	800bce4 <wolfssl_asn1_type_free_value+0x7c>
 800bc84:	2b04      	cmp	r3, #4
 800bc86:	d027      	beq.n	800bcd8 <wolfssl_asn1_type_free_value+0x70>
 800bc88:	2b05      	cmp	r3, #5
 800bc8a:	d02d      	beq.n	800bce8 <wolfssl_asn1_type_free_value+0x80>
        case WOLFSSL_V_ASN1_UNIVERSALSTRING:
        case WOLFSSL_V_ASN1_SEQUENCE:
            wolfSSL_ASN1_STRING_free(at->value.asn1_string);
            break;
        default:
            break;
 800bc8c:	e02a      	b.n	800bce4 <wolfssl_asn1_type_free_value+0x7c>
    switch (at->type) {
 800bc8e:	461a      	mov	r2, r3
 800bc90:	2301      	movs	r3, #1
 800bc92:	4093      	lsls	r3, r2
 800bc94:	4a19      	ldr	r2, [pc, #100]	@ (800bcfc <wolfssl_asn1_type_free_value+0x94>)
 800bc96:	401a      	ands	r2, r3
 800bc98:	2a00      	cmp	r2, #0
 800bc9a:	bf14      	ite	ne
 800bc9c:	2201      	movne	r2, #1
 800bc9e:	2200      	moveq	r2, #0
 800bca0:	b2d2      	uxtb	r2, r2
 800bca2:	2a00      	cmp	r2, #0
 800bca4:	d118      	bne.n	800bcd8 <wolfssl_asn1_type_free_value+0x70>
 800bca6:	f003 7280 	and.w	r2, r3, #16777216	@ 0x1000000
 800bcaa:	2a00      	cmp	r2, #0
 800bcac:	bf14      	ite	ne
 800bcae:	2201      	movne	r2, #1
 800bcb0:	2200      	moveq	r2, #0
 800bcb2:	b2d2      	uxtb	r2, r2
 800bcb4:	2a00      	cmp	r2, #0
 800bcb6:	d119      	bne.n	800bcec <wolfssl_asn1_type_free_value+0x84>
 800bcb8:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800bcbc:	2b00      	cmp	r3, #0
 800bcbe:	bf14      	ite	ne
 800bcc0:	2301      	movne	r3, #1
 800bcc2:	2300      	moveq	r3, #0
 800bcc4:	b2db      	uxtb	r3, r3
 800bcc6:	2b00      	cmp	r3, #0
 800bcc8:	d112      	bne.n	800bcf0 <wolfssl_asn1_type_free_value+0x88>
            break;
 800bcca:	e00b      	b.n	800bce4 <wolfssl_asn1_type_free_value+0x7c>
            wolfSSL_ASN1_OBJECT_free(at->value.object);
 800bccc:	687b      	ldr	r3, [r7, #4]
 800bcce:	685b      	ldr	r3, [r3, #4]
 800bcd0:	4618      	mov	r0, r3
 800bcd2:	f7ff fe8a 	bl	800b9ea <wolfSSL_ASN1_OBJECT_free>
            break;
 800bcd6:	e00c      	b.n	800bcf2 <wolfssl_asn1_type_free_value+0x8a>
            wolfSSL_ASN1_STRING_free(at->value.asn1_string);
 800bcd8:	687b      	ldr	r3, [r7, #4]
 800bcda:	685b      	ldr	r3, [r3, #4]
 800bcdc:	4618      	mov	r0, r3
 800bcde:	f7ff fee3 	bl	800baa8 <wolfSSL_ASN1_STRING_free>
            break;
 800bce2:	e006      	b.n	800bcf2 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800bce4:	bf00      	nop
 800bce6:	e004      	b.n	800bcf2 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800bce8:	bf00      	nop
 800bcea:	e002      	b.n	800bcf2 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800bcec:	bf00      	nop
 800bcee:	e000      	b.n	800bcf2 <wolfssl_asn1_type_free_value+0x8a>
            break;
 800bcf0:	bf00      	nop
    }
}
 800bcf2:	bf00      	nop
 800bcf4:	3708      	adds	r7, #8
 800bcf6:	46bd      	mov	sp, r7
 800bcf8:	bd80      	pop	{r7, pc}
 800bcfa:	bf00      	nop
 800bcfc:	10591000 	.word	0x10591000

0800bd00 <wolfSSL_ASN1_TYPE_free>:
 * Free ASN.1 TYPE object and its value.
 *
 * @param [in, out] at  ASN.1 TYPE object.
 */
void wolfSSL_ASN1_TYPE_free(WOLFSSL_ASN1_TYPE* at)
{
 800bd00:	b580      	push	{r7, lr}
 800bd02:	b084      	sub	sp, #16
 800bd04:	af00      	add	r7, sp, #0
 800bd06:	6078      	str	r0, [r7, #4]
    if (at != NULL) {
 800bd08:	687b      	ldr	r3, [r7, #4]
 800bd0a:	2b00      	cmp	r3, #0
 800bd0c:	d002      	beq.n	800bd14 <wolfSSL_ASN1_TYPE_free+0x14>
        /* Dispose of value in ASN.1 TYPE object. */
        wolfssl_asn1_type_free_value(at);
 800bd0e:	6878      	ldr	r0, [r7, #4]
 800bd10:	f7ff ffaa 	bl	800bc68 <wolfssl_asn1_type_free_value>
    }
    /* Dispose of ASN.1 TYPE object. */
    XFREE(at, NULL, DYNAMIC_TYPE_OPENSSL);
 800bd14:	687b      	ldr	r3, [r7, #4]
 800bd16:	60fb      	str	r3, [r7, #12]
 800bd18:	68fb      	ldr	r3, [r7, #12]
 800bd1a:	2b00      	cmp	r3, #0
 800bd1c:	d002      	beq.n	800bd24 <wolfSSL_ASN1_TYPE_free+0x24>
 800bd1e:	68f8      	ldr	r0, [r7, #12]
 800bd20:	f012 fed4 	bl	801eacc <wolfSSL_Free>
}
 800bd24:	bf00      	nop
 800bd26:	3710      	adds	r7, #16
 800bd28:	46bd      	mov	sp, r7
 800bd2a:	bd80      	pop	{r7, pc}

0800bd2c <wolfssl_der_length>:
 * @param [in] len  Length of data in buffer (may be larger than SEQ).
 * @return  Size of complete DER encoding on success.
 * @return  0 on failure.
 */
static int wolfssl_der_length(const unsigned char* seq, int len)
{
 800bd2c:	b580      	push	{r7, lr}
 800bd2e:	b086      	sub	sp, #24
 800bd30:	af02      	add	r7, sp, #8
 800bd32:	6078      	str	r0, [r7, #4]
 800bd34:	6039      	str	r1, [r7, #0]
    int ret = 0;
 800bd36:	2300      	movs	r3, #0
 800bd38:	60fb      	str	r3, [r7, #12]
    word32 i = 0;
 800bd3a:	2300      	movs	r3, #0
 800bd3c:	60bb      	str	r3, [r7, #8]

    /* Check it is a SEQUENCE and get the length of the underlying data.
     * i is updated to be after SEQUENCE header bytes.
     */
    if (GetSequence_ex(seq, &i, &ret, (word32)len, 0) >= 0) {
 800bd3e:	683b      	ldr	r3, [r7, #0]
 800bd40:	f107 020c 	add.w	r2, r7, #12
 800bd44:	f107 0108 	add.w	r1, r7, #8
 800bd48:	2000      	movs	r0, #0
 800bd4a:	9000      	str	r0, [sp, #0]
 800bd4c:	6878      	ldr	r0, [r7, #4]
 800bd4e:	f008 f935 	bl	8013fbc <GetSequence_ex>
 800bd52:	4603      	mov	r3, r0
 800bd54:	2b00      	cmp	r3, #0
 800bd56:	db03      	blt.n	800bd60 <wolfssl_der_length+0x34>
        /* Add SEQUENCE header length to underlying data length. */
        ret += (int)i;
 800bd58:	68fb      	ldr	r3, [r7, #12]
 800bd5a:	68ba      	ldr	r2, [r7, #8]
 800bd5c:	4413      	add	r3, r2
 800bd5e:	60fb      	str	r3, [r7, #12]
    }

    return ret;
 800bd60:	68fb      	ldr	r3, [r7, #12]
}
 800bd62:	4618      	mov	r0, r3
 800bd64:	3710      	adds	r7, #16
 800bd66:	46bd      	mov	sp, r7
 800bd68:	bd80      	pop	{r7, pc}

0800bd6a <wolfSSL_RSA_meth_free>:
/* Dispose of RSA method and allocated data.
 *
 * @param [in] meth  RSA method to free.
 */
void wolfSSL_RSA_meth_free(WOLFSSL_RSA_METHOD *meth)
{
 800bd6a:	b580      	push	{r7, lr}
 800bd6c:	b084      	sub	sp, #16
 800bd6e:	af00      	add	r7, sp, #0
 800bd70:	6078      	str	r0, [r7, #4]
    /* Free method if available and dynamically allocated. */
    if ((meth != NULL) && meth->dynamic) {
 800bd72:	687b      	ldr	r3, [r7, #4]
 800bd74:	2b00      	cmp	r3, #0
 800bd76:	d017      	beq.n	800bda8 <wolfSSL_RSA_meth_free+0x3e>
 800bd78:	687b      	ldr	r3, [r7, #4]
 800bd7a:	7a1b      	ldrb	r3, [r3, #8]
 800bd7c:	f003 0301 	and.w	r3, r3, #1
 800bd80:	b2db      	uxtb	r3, r3
 800bd82:	2b00      	cmp	r3, #0
 800bd84:	d010      	beq.n	800bda8 <wolfSSL_RSA_meth_free+0x3e>
        /* Name was duplicated and must be freed. */
        XFREE(meth->name, NULL, DYNAMIC_TYPE_OPENSSL);
 800bd86:	687b      	ldr	r3, [r7, #4]
 800bd88:	685b      	ldr	r3, [r3, #4]
 800bd8a:	60fb      	str	r3, [r7, #12]
 800bd8c:	68fb      	ldr	r3, [r7, #12]
 800bd8e:	2b00      	cmp	r3, #0
 800bd90:	d002      	beq.n	800bd98 <wolfSSL_RSA_meth_free+0x2e>
 800bd92:	68f8      	ldr	r0, [r7, #12]
 800bd94:	f012 fe9a 	bl	801eacc <wolfSSL_Free>
        /* Dispose of RSA method. */
        XFREE(meth, NULL, DYNAMIC_TYPE_OPENSSL);
 800bd98:	687b      	ldr	r3, [r7, #4]
 800bd9a:	60bb      	str	r3, [r7, #8]
 800bd9c:	68bb      	ldr	r3, [r7, #8]
 800bd9e:	2b00      	cmp	r3, #0
 800bda0:	d002      	beq.n	800bda8 <wolfSSL_RSA_meth_free+0x3e>
 800bda2:	68b8      	ldr	r0, [r7, #8]
 800bda4:	f012 fe92 	bl	801eacc <wolfSSL_Free>
    }
}
 800bda8:	bf00      	nop
 800bdaa:	3710      	adds	r7, #16
 800bdac:	46bd      	mov	sp, r7
 800bdae:	bd80      	pop	{r7, pc}

0800bdb0 <wolfSSL_RSA_free>:
 * Cannot use rsa after this call.
 *
 * @param [in] rsa  RSA key to free.
 */
void wolfSSL_RSA_free(WOLFSSL_RSA* rsa)
{
 800bdb0:	b580      	push	{r7, lr}
 800bdb2:	b08a      	sub	sp, #40	@ 0x28
 800bdb4:	af00      	add	r7, sp, #0
 800bdb6:	6078      	str	r0, [r7, #4]
    int doFree = 1;
 800bdb8:	2301      	movs	r3, #1
 800bdba:	60fb      	str	r3, [r7, #12]

    WOLFSSL_ENTER("wolfSSL_RSA_free");

    /* Validate parameter. */
    if (rsa == NULL) {
 800bdbc:	687b      	ldr	r3, [r7, #4]
 800bdbe:	2b00      	cmp	r3, #0
 800bdc0:	d101      	bne.n	800bdc6 <wolfSSL_RSA_free+0x16>
        doFree = 0;
 800bdc2:	2300      	movs	r3, #0
 800bdc4:	60fb      	str	r3, [r7, #12]
    }
    if (doFree) {
 800bdc6:	68fb      	ldr	r3, [r7, #12]
 800bdc8:	2b00      	cmp	r3, #0
 800bdca:	d00f      	beq.n	800bdec <wolfSSL_RSA_free+0x3c>
        int err;

        /* Decrement reference count. */
        wolfSSL_RefDec(&rsa->ref, &doFree, &err);
 800bdcc:	687b      	ldr	r3, [r7, #4]
 800bdce:	332c      	adds	r3, #44	@ 0x2c
 800bdd0:	2101      	movs	r1, #1
 800bdd2:	4618      	mov	r0, r3
 800bdd4:	f7ff f9ac 	bl	800b130 <wolfSSL_Atomic_Int_FetchSub>
 800bdd8:	6278      	str	r0, [r7, #36]	@ 0x24
 800bdda:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800bddc:	2b01      	cmp	r3, #1
 800bdde:	bf0c      	ite	eq
 800bde0:	2301      	moveq	r3, #1
 800bde2:	2300      	movne	r3, #0
 800bde4:	b2db      	uxtb	r3, r3
 800bde6:	60fb      	str	r3, [r7, #12]
 800bde8:	2300      	movs	r3, #0
 800bdea:	60bb      	str	r3, [r7, #8]
    #ifndef WOLFSSL_REFCNT_ERROR_RETURN
        (void)err;
    #endif
    }
    if (doFree) {
 800bdec:	68fb      	ldr	r3, [r7, #12]
 800bdee:	2b00      	cmp	r3, #0
 800bdf0:	d074      	beq.n	800bedc <wolfSSL_RSA_free+0x12c>
        void* heap = rsa->heap;
 800bdf2:	687b      	ldr	r3, [r7, #4]
 800bdf4:	6a1b      	ldr	r3, [r3, #32]
 800bdf6:	623b      	str	r3, [r7, #32]

    #ifdef HAVE_EX_DATA_CLEANUP_HOOKS
        wolfSSL_CRYPTO_cleanup_ex_data(&rsa->ex_data);
    #endif

        if (rsa->internal != NULL) {
 800bdf8:	687b      	ldr	r3, [r7, #4]
 800bdfa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bdfc:	2b00      	cmp	r3, #0
 800bdfe:	d030      	beq.n	800be62 <wolfSSL_RSA_free+0xb2>
        #if !defined(HAVE_FIPS) && defined(WC_RSA_BLINDING)
            /* Check if RNG is owned before freeing it. */
            if (rsa->ownRng) {
 800be00:	687b      	ldr	r3, [r7, #4]
 800be02:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 800be06:	f003 0304 	and.w	r3, r3, #4
 800be0a:	b2db      	uxtb	r3, r3
 800be0c:	2b00      	cmp	r3, #0
 800be0e:	d01a      	beq.n	800be46 <wolfSSL_RSA_free+0x96>
                WC_RNG* rng = ((RsaKey*)(rsa->internal))->rng;
 800be10:	687b      	ldr	r3, [r7, #4]
 800be12:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800be14:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800be18:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 800be1c:	61fb      	str	r3, [r7, #28]
                if ((rng != NULL) && (rng != wolfssl_get_global_rng())) {
 800be1e:	69fb      	ldr	r3, [r7, #28]
 800be20:	2b00      	cmp	r3, #0
 800be22:	d010      	beq.n	800be46 <wolfSSL_RSA_free+0x96>
 800be24:	f7ff fd42 	bl	800b8ac <wolfssl_get_global_rng>
 800be28:	4602      	mov	r2, r0
 800be2a:	69fb      	ldr	r3, [r7, #28]
 800be2c:	4293      	cmp	r3, r2
 800be2e:	d00a      	beq.n	800be46 <wolfSSL_RSA_free+0x96>
                    wc_FreeRng(rng);
 800be30:	69f8      	ldr	r0, [r7, #28]
 800be32:	f013 fc57 	bl	801f6e4 <wc_FreeRng>
                    XFREE(rng, heap, DYNAMIC_TYPE_RNG);
 800be36:	69fb      	ldr	r3, [r7, #28]
 800be38:	61bb      	str	r3, [r7, #24]
 800be3a:	69bb      	ldr	r3, [r7, #24]
 800be3c:	2b00      	cmp	r3, #0
 800be3e:	d002      	beq.n	800be46 <wolfSSL_RSA_free+0x96>
 800be40:	69b8      	ldr	r0, [r7, #24]
 800be42:	f012 fe43 	bl	801eacc <wolfSSL_Free>
                }
                /* RNG isn't freed by wolfCrypt RSA free. */
            }
        #endif
            /* Dispose of allocated data in wolfCrypt RSA key. */
            wc_FreeRsaKey((RsaKey*)rsa->internal);
 800be46:	687b      	ldr	r3, [r7, #4]
 800be48:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800be4a:	4618      	mov	r0, r3
 800be4c:	f014 f8a6 	bl	801ff9c <wc_FreeRsaKey>
            /* Dispose of memory for wolfCrypt RSA key. */
            XFREE(rsa->internal, heap, DYNAMIC_TYPE_RSA);
 800be50:	687b      	ldr	r3, [r7, #4]
 800be52:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800be54:	617b      	str	r3, [r7, #20]
 800be56:	697b      	ldr	r3, [r7, #20]
 800be58:	2b00      	cmp	r3, #0
 800be5a:	d002      	beq.n	800be62 <wolfSSL_RSA_free+0xb2>
 800be5c:	6978      	ldr	r0, [r7, #20]
 800be5e:	f012 fe35 	bl	801eacc <wolfSSL_Free>
        }

        /* Dispose of external representation of RSA values. */
        wolfSSL_BN_clear_free(rsa->iqmp);
 800be62:	687b      	ldr	r3, [r7, #4]
 800be64:	69db      	ldr	r3, [r3, #28]
 800be66:	4618      	mov	r0, r3
 800be68:	f7ff fd52 	bl	800b910 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->dmq1);
 800be6c:	687b      	ldr	r3, [r7, #4]
 800be6e:	699b      	ldr	r3, [r3, #24]
 800be70:	4618      	mov	r0, r3
 800be72:	f7ff fd4d 	bl	800b910 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->dmp1);
 800be76:	687b      	ldr	r3, [r7, #4]
 800be78:	695b      	ldr	r3, [r3, #20]
 800be7a:	4618      	mov	r0, r3
 800be7c:	f7ff fd48 	bl	800b910 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->q);
 800be80:	687b      	ldr	r3, [r7, #4]
 800be82:	691b      	ldr	r3, [r3, #16]
 800be84:	4618      	mov	r0, r3
 800be86:	f7ff fd43 	bl	800b910 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->p);
 800be8a:	687b      	ldr	r3, [r7, #4]
 800be8c:	68db      	ldr	r3, [r3, #12]
 800be8e:	4618      	mov	r0, r3
 800be90:	f7ff fd3e 	bl	800b910 <wolfSSL_BN_clear_free>
        wolfSSL_BN_clear_free(rsa->d);
 800be94:	687b      	ldr	r3, [r7, #4]
 800be96:	689b      	ldr	r3, [r3, #8]
 800be98:	4618      	mov	r0, r3
 800be9a:	f7ff fd39 	bl	800b910 <wolfSSL_BN_clear_free>
        wolfSSL_BN_free(rsa->e);
 800be9e:	687b      	ldr	r3, [r7, #4]
 800bea0:	685b      	ldr	r3, [r3, #4]
 800bea2:	4618      	mov	r0, r3
 800bea4:	f7ff fd18 	bl	800b8d8 <wolfSSL_BN_free>
        wolfSSL_BN_free(rsa->n);
 800bea8:	687b      	ldr	r3, [r7, #4]
 800beaa:	681b      	ldr	r3, [r3, #0]
 800beac:	4618      	mov	r0, r3
 800beae:	f7ff fd13 	bl	800b8d8 <wolfSSL_BN_free>

    #if defined(OPENSSL_EXTRA)
        if (rsa->meth) {
 800beb2:	687b      	ldr	r3, [r7, #4]
 800beb4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800beb6:	2b00      	cmp	r3, #0
 800beb8:	d004      	beq.n	800bec4 <wolfSSL_RSA_free+0x114>
            wolfSSL_RSA_meth_free((WOLFSSL_RSA_METHOD*)rsa->meth);
 800beba:	687b      	ldr	r3, [r7, #4]
 800bebc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800bebe:	4618      	mov	r0, r3
 800bec0:	f7ff ff53 	bl	800bd6a <wolfSSL_RSA_meth_free>
        }
    #endif

        /* Set back to NULLs for safety. */
        ForceZero(rsa, sizeof(*rsa));
 800bec4:	213c      	movs	r1, #60	@ 0x3c
 800bec6:	6878      	ldr	r0, [r7, #4]
 800bec8:	f7ff f947 	bl	800b15a <ForceZero>

        XFREE(rsa, heap, DYNAMIC_TYPE_RSA);
 800becc:	687b      	ldr	r3, [r7, #4]
 800bece:	613b      	str	r3, [r7, #16]
 800bed0:	693b      	ldr	r3, [r7, #16]
 800bed2:	2b00      	cmp	r3, #0
 800bed4:	d002      	beq.n	800bedc <wolfSSL_RSA_free+0x12c>
 800bed6:	6938      	ldr	r0, [r7, #16]
 800bed8:	f012 fdf8 	bl	801eacc <wolfSSL_Free>
        (void)heap;
    }
}
 800bedc:	bf00      	nop
 800bede:	3728      	adds	r7, #40	@ 0x28
 800bee0:	46bd      	mov	sp, r7
 800bee2:	bd80      	pop	{r7, pc}

0800bee4 <wolfSSL_DH_free>:
 * Cannot use dh after this call.
 *
 * @param [in] dh  DH key to free.
 */
void wolfSSL_DH_free(WOLFSSL_DH* dh)
{
 800bee4:	b580      	push	{r7, lr}
 800bee6:	b088      	sub	sp, #32
 800bee8:	af00      	add	r7, sp, #0
 800beea:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800beec:	2300      	movs	r3, #0
 800beee:	613b      	str	r3, [r7, #16]

    WOLFSSL_ENTER("wolfSSL_DH_free");

    if (dh != NULL) {
 800bef0:	687b      	ldr	r3, [r7, #4]
 800bef2:	2b00      	cmp	r3, #0
 800bef4:	d00f      	beq.n	800bf16 <wolfSSL_DH_free+0x32>
        int err;

        /* Only free if all references to it are done */
        wolfSSL_RefDec(&dh->ref, &doFree, &err);
 800bef6:	687b      	ldr	r3, [r7, #4]
 800bef8:	3320      	adds	r3, #32
 800befa:	2101      	movs	r1, #1
 800befc:	4618      	mov	r0, r3
 800befe:	f7ff f917 	bl	800b130 <wolfSSL_Atomic_Int_FetchSub>
 800bf02:	61f8      	str	r0, [r7, #28]
 800bf04:	69fb      	ldr	r3, [r7, #28]
 800bf06:	2b01      	cmp	r3, #1
 800bf08:	bf0c      	ite	eq
 800bf0a:	2301      	moveq	r3, #1
 800bf0c:	2300      	movne	r3, #0
 800bf0e:	b2db      	uxtb	r3, r3
 800bf10:	613b      	str	r3, [r7, #16]
 800bf12:	2300      	movs	r3, #0
 800bf14:	60fb      	str	r3, [r7, #12]
        /* Ignore errors - doFree will be 0 on error. */
        (void)err;
    }
    if (doFree) {
 800bf16:	693b      	ldr	r3, [r7, #16]
 800bf18:	2b00      	cmp	r3, #0
 800bf1a:	d03a      	beq.n	800bf92 <wolfSSL_DH_free+0xae>
        /* Dispose of allocated reference counting data. */
        wolfSSL_RefFree(&dh->ref);

        /* Dispose of wolfSSL DH key. */
        if (dh->internal) {
 800bf1c:	687b      	ldr	r3, [r7, #4]
 800bf1e:	695b      	ldr	r3, [r3, #20]
 800bf20:	2b00      	cmp	r3, #0
 800bf22:	d010      	beq.n	800bf46 <wolfSSL_DH_free+0x62>
            wc_FreeDhKey((DhKey*)dh->internal);
 800bf24:	687b      	ldr	r3, [r7, #4]
 800bf26:	695b      	ldr	r3, [r3, #20]
 800bf28:	4618      	mov	r0, r3
 800bf2a:	f00e fc11 	bl	801a750 <wc_FreeDhKey>
            XFREE(dh->internal, NULL, DYNAMIC_TYPE_DH);
 800bf2e:	687b      	ldr	r3, [r7, #4]
 800bf30:	695b      	ldr	r3, [r3, #20]
 800bf32:	61bb      	str	r3, [r7, #24]
 800bf34:	69bb      	ldr	r3, [r7, #24]
 800bf36:	2b00      	cmp	r3, #0
 800bf38:	d002      	beq.n	800bf40 <wolfSSL_DH_free+0x5c>
 800bf3a:	69b8      	ldr	r0, [r7, #24]
 800bf3c:	f012 fdc6 	bl	801eacc <wolfSSL_Free>
            dh->internal = NULL;
 800bf40:	687b      	ldr	r3, [r7, #4]
 800bf42:	2200      	movs	r2, #0
 800bf44:	615a      	str	r2, [r3, #20]
        }

        /* Dispose of any allocated BNs. */
        wolfSSL_BN_free(dh->priv_key);
 800bf46:	687b      	ldr	r3, [r7, #4]
 800bf48:	691b      	ldr	r3, [r3, #16]
 800bf4a:	4618      	mov	r0, r3
 800bf4c:	f7ff fcc4 	bl	800b8d8 <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->pub_key);
 800bf50:	687b      	ldr	r3, [r7, #4]
 800bf52:	68db      	ldr	r3, [r3, #12]
 800bf54:	4618      	mov	r0, r3
 800bf56:	f7ff fcbf 	bl	800b8d8 <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->g);
 800bf5a:	687b      	ldr	r3, [r7, #4]
 800bf5c:	685b      	ldr	r3, [r3, #4]
 800bf5e:	4618      	mov	r0, r3
 800bf60:	f7ff fcba 	bl	800b8d8 <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->p);
 800bf64:	687b      	ldr	r3, [r7, #4]
 800bf66:	681b      	ldr	r3, [r3, #0]
 800bf68:	4618      	mov	r0, r3
 800bf6a:	f7ff fcb5 	bl	800b8d8 <wolfSSL_BN_free>
        wolfSSL_BN_free(dh->q);
 800bf6e:	687b      	ldr	r3, [r7, #4]
 800bf70:	689b      	ldr	r3, [r3, #8]
 800bf72:	4618      	mov	r0, r3
 800bf74:	f7ff fcb0 	bl	800b8d8 <wolfSSL_BN_free>
        /* Set back to NULLs for safety. */
        XMEMSET(dh, 0, sizeof(WOLFSSL_DH));
 800bf78:	2224      	movs	r2, #36	@ 0x24
 800bf7a:	2100      	movs	r1, #0
 800bf7c:	6878      	ldr	r0, [r7, #4]
 800bf7e:	f01c faa7 	bl	80284d0 <memset>

        XFREE(dh, NULL, DYNAMIC_TYPE_DH);
 800bf82:	687b      	ldr	r3, [r7, #4]
 800bf84:	617b      	str	r3, [r7, #20]
 800bf86:	697b      	ldr	r3, [r7, #20]
 800bf88:	2b00      	cmp	r3, #0
 800bf8a:	d002      	beq.n	800bf92 <wolfSSL_DH_free+0xae>
 800bf8c:	6978      	ldr	r0, [r7, #20]
 800bf8e:	f012 fd9d 	bl	801eacc <wolfSSL_Free>
    }
}
 800bf92:	bf00      	nop
 800bf94:	3720      	adds	r7, #32
 800bf96:	46bd      	mov	sp, r7
 800bf98:	bd80      	pop	{r7, pc}

0800bf9a <wolfSSL_EC_GROUP_free>:
 * Cannot use group after this call.
 *
 * @param [in] group  EC group to free.
 */
void wolfSSL_EC_GROUP_free(WOLFSSL_EC_GROUP *group)
{
 800bf9a:	b580      	push	{r7, lr}
 800bf9c:	b084      	sub	sp, #16
 800bf9e:	af00      	add	r7, sp, #0
 800bfa0:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_EC_GROUP_free");

    /* Dispose of EC group. */
    XFREE(group, NULL, DYNAMIC_TYPE_ECC);
 800bfa2:	687b      	ldr	r3, [r7, #4]
 800bfa4:	60fb      	str	r3, [r7, #12]
 800bfa6:	68fb      	ldr	r3, [r7, #12]
 800bfa8:	2b00      	cmp	r3, #0
 800bfaa:	d002      	beq.n	800bfb2 <wolfSSL_EC_GROUP_free+0x18>
 800bfac:	68f8      	ldr	r0, [r7, #12]
 800bfae:	f012 fd8d 	bl	801eacc <wolfSSL_Free>
}
 800bfb2:	bf00      	nop
 800bfb4:	3710      	adds	r7, #16
 800bfb6:	46bd      	mov	sp, r7
 800bfb8:	bd80      	pop	{r7, pc}

0800bfba <wolfSSL_EC_POINT_free>:
 * Cannot use point after this call.
 *
 * @param [in, out] point  EC point to free.
 */
void wolfSSL_EC_POINT_free(WOLFSSL_EC_POINT *point)
{
 800bfba:	b580      	push	{r7, lr}
 800bfbc:	b084      	sub	sp, #16
 800bfbe:	af00      	add	r7, sp, #0
 800bfc0:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_EC_POINT_free");

    if (point != NULL) {
 800bfc2:	687b      	ldr	r3, [r7, #4]
 800bfc4:	2b00      	cmp	r3, #0
 800bfc6:	d031      	beq.n	800c02c <wolfSSL_EC_POINT_free+0x72>
        if (point->internal != NULL) {
 800bfc8:	687b      	ldr	r3, [r7, #4]
 800bfca:	68db      	ldr	r3, [r3, #12]
 800bfcc:	2b00      	cmp	r3, #0
 800bfce:	d007      	beq.n	800bfe0 <wolfSSL_EC_POINT_free+0x26>
            wc_ecc_del_point((ecc_point*)point->internal);
 800bfd0:	687b      	ldr	r3, [r7, #4]
 800bfd2:	68db      	ldr	r3, [r3, #12]
 800bfd4:	4618      	mov	r0, r3
 800bfd6:	f010 fd00 	bl	801c9da <wc_ecc_del_point>
            point->internal = NULL;
 800bfda:	687b      	ldr	r3, [r7, #4]
 800bfdc:	2200      	movs	r2, #0
 800bfde:	60da      	str	r2, [r3, #12]
        }

        /* Free ordinates. */
        wolfSSL_BN_free(point->X);
 800bfe0:	687b      	ldr	r3, [r7, #4]
 800bfe2:	681b      	ldr	r3, [r3, #0]
 800bfe4:	4618      	mov	r0, r3
 800bfe6:	f7ff fc77 	bl	800b8d8 <wolfSSL_BN_free>
        wolfSSL_BN_free(point->Y);
 800bfea:	687b      	ldr	r3, [r7, #4]
 800bfec:	685b      	ldr	r3, [r3, #4]
 800bfee:	4618      	mov	r0, r3
 800bff0:	f7ff fc72 	bl	800b8d8 <wolfSSL_BN_free>
        wolfSSL_BN_free(point->Z);
 800bff4:	687b      	ldr	r3, [r7, #4]
 800bff6:	689b      	ldr	r3, [r3, #8]
 800bff8:	4618      	mov	r0, r3
 800bffa:	f7ff fc6d 	bl	800b8d8 <wolfSSL_BN_free>
        /* Clear fields. */
        point->X = NULL;
 800bffe:	687b      	ldr	r3, [r7, #4]
 800c000:	2200      	movs	r2, #0
 800c002:	601a      	str	r2, [r3, #0]
        point->Y = NULL;
 800c004:	687b      	ldr	r3, [r7, #4]
 800c006:	2200      	movs	r2, #0
 800c008:	605a      	str	r2, [r3, #4]
        point->Z = NULL;
 800c00a:	687b      	ldr	r3, [r7, #4]
 800c00c:	2200      	movs	r2, #0
 800c00e:	609a      	str	r2, [r3, #8]
        point->inSet = 0;
 800c010:	687b      	ldr	r3, [r7, #4]
 800c012:	2200      	movs	r2, #0
 800c014:	741a      	strb	r2, [r3, #16]
        point->exSet = 0;
 800c016:	687b      	ldr	r3, [r7, #4]
 800c018:	2200      	movs	r2, #0
 800c01a:	745a      	strb	r2, [r3, #17]

        /* Dispose of EC point. */
        XFREE(point, NULL, DYNAMIC_TYPE_ECC);
 800c01c:	687b      	ldr	r3, [r7, #4]
 800c01e:	60fb      	str	r3, [r7, #12]
 800c020:	68fb      	ldr	r3, [r7, #12]
 800c022:	2b00      	cmp	r3, #0
 800c024:	d002      	beq.n	800c02c <wolfSSL_EC_POINT_free+0x72>
 800c026:	68f8      	ldr	r0, [r7, #12]
 800c028:	f012 fd50 	bl	801eacc <wolfSSL_Free>
    }
}
 800c02c:	bf00      	nop
 800c02e:	3710      	adds	r7, #16
 800c030:	46bd      	mov	sp, r7
 800c032:	bd80      	pop	{r7, pc}

0800c034 <wolfSSL_EC_KEY_free>:
 * Cannot use key after this call.
 *
 * @param [in] key  EC key to free.
 */
void wolfSSL_EC_KEY_free(WOLFSSL_EC_KEY *key)
{
 800c034:	b580      	push	{r7, lr}
 800c036:	b088      	sub	sp, #32
 800c038:	af00      	add	r7, sp, #0
 800c03a:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800c03c:	2300      	movs	r3, #0
 800c03e:	60fb      	str	r3, [r7, #12]

    (void)err;

    WOLFSSL_ENTER("wolfSSL_EC_KEY_free");

    if (key != NULL) {
 800c040:	687b      	ldr	r3, [r7, #4]
 800c042:	2b00      	cmp	r3, #0
 800c044:	d042      	beq.n	800c0cc <wolfSSL_EC_KEY_free+0x98>
        void* heap = key->heap;
 800c046:	687b      	ldr	r3, [r7, #4]
 800c048:	691b      	ldr	r3, [r3, #16]
 800c04a:	61fb      	str	r3, [r7, #28]

        /* Decrement reference count. */
        wolfSSL_RefDec(&key->ref, &doFree, &err);
 800c04c:	687b      	ldr	r3, [r7, #4]
 800c04e:	331c      	adds	r3, #28
 800c050:	2101      	movs	r1, #1
 800c052:	4618      	mov	r0, r3
 800c054:	f7ff f86c 	bl	800b130 <wolfSSL_Atomic_Int_FetchSub>
 800c058:	61b8      	str	r0, [r7, #24]
 800c05a:	69bb      	ldr	r3, [r7, #24]
 800c05c:	2b01      	cmp	r3, #1
 800c05e:	bf0c      	ite	eq
 800c060:	2301      	moveq	r3, #1
 800c062:	2300      	movne	r3, #0
 800c064:	b2db      	uxtb	r3, r3
 800c066:	60fb      	str	r3, [r7, #12]
 800c068:	2300      	movs	r3, #0
 800c06a:	60bb      	str	r3, [r7, #8]
        if (doFree) {
 800c06c:	68fb      	ldr	r3, [r7, #12]
 800c06e:	2b00      	cmp	r3, #0
 800c070:	d02c      	beq.n	800c0cc <wolfSSL_EC_KEY_free+0x98>
            /* Dispose of allocated reference counting data. */
            wolfSSL_RefFree(&key->ref);

            /* Dispose of private key. */
            wolfSSL_BN_free(key->priv_key);
 800c072:	687b      	ldr	r3, [r7, #4]
 800c074:	689b      	ldr	r3, [r3, #8]
 800c076:	4618      	mov	r0, r3
 800c078:	f7ff fc2e 	bl	800b8d8 <wolfSSL_BN_free>
            wolfSSL_EC_POINT_free(key->pub_key);
 800c07c:	687b      	ldr	r3, [r7, #4]
 800c07e:	685b      	ldr	r3, [r3, #4]
 800c080:	4618      	mov	r0, r3
 800c082:	f7ff ff9a 	bl	800bfba <wolfSSL_EC_POINT_free>
            wolfSSL_EC_GROUP_free(key->group);
 800c086:	687b      	ldr	r3, [r7, #4]
 800c088:	681b      	ldr	r3, [r3, #0]
 800c08a:	4618      	mov	r0, r3
 800c08c:	f7ff ff85 	bl	800bf9a <wolfSSL_EC_GROUP_free>
            if (key->internal != NULL) {
 800c090:	687b      	ldr	r3, [r7, #4]
 800c092:	68db      	ldr	r3, [r3, #12]
 800c094:	2b00      	cmp	r3, #0
 800c096:	d00d      	beq.n	800c0b4 <wolfSSL_EC_KEY_free+0x80>
                /* Dispose of wolfCrypt representation of EC key. */
                wc_ecc_free((ecc_key*)key->internal);
 800c098:	687b      	ldr	r3, [r7, #4]
 800c09a:	68db      	ldr	r3, [r3, #12]
 800c09c:	4618      	mov	r0, r3
 800c09e:	f010 ff42 	bl	801cf26 <wc_ecc_free>
                XFREE(key->internal, heap, DYNAMIC_TYPE_ECC);
 800c0a2:	687b      	ldr	r3, [r7, #4]
 800c0a4:	68db      	ldr	r3, [r3, #12]
 800c0a6:	617b      	str	r3, [r7, #20]
 800c0a8:	697b      	ldr	r3, [r7, #20]
 800c0aa:	2b00      	cmp	r3, #0
 800c0ac:	d002      	beq.n	800c0b4 <wolfSSL_EC_KEY_free+0x80>
 800c0ae:	6978      	ldr	r0, [r7, #20]
 800c0b0:	f012 fd0c 	bl	801eacc <wolfSSL_Free>
            }

            /* Set back to NULLs for safety. */
            ForceZero(key, sizeof(*key));
 800c0b4:	2120      	movs	r1, #32
 800c0b6:	6878      	ldr	r0, [r7, #4]
 800c0b8:	f7ff f84f 	bl	800b15a <ForceZero>

            /* Dispose of the memory associated with the EC key. */
            XFREE(key, heap, DYNAMIC_TYPE_ECC);
 800c0bc:	687b      	ldr	r3, [r7, #4]
 800c0be:	613b      	str	r3, [r7, #16]
 800c0c0:	693b      	ldr	r3, [r7, #16]
 800c0c2:	2b00      	cmp	r3, #0
 800c0c4:	d002      	beq.n	800c0cc <wolfSSL_EC_KEY_free+0x98>
 800c0c6:	6938      	ldr	r0, [r7, #16]
 800c0c8:	f012 fd00 	bl	801eacc <wolfSSL_Free>
            (void)heap;
        }
    }
}
 800c0cc:	bf00      	nop
 800c0ce:	3720      	adds	r7, #32
 800c0d0:	46bd      	mov	sp, r7
 800c0d2:	bd80      	pop	{r7, pc}

0800c0d4 <wolfSSL_CTX_new_ex>:
   WOLFSSL_METHOD pointer passed in is given to ctx to manage.
   This function frees the passed in WOLFSSL_METHOD struct on failure and on
   success is freed when ctx is freed.
 */
WOLFSSL_CTX* wolfSSL_CTX_new_ex(WOLFSSL_METHOD* method, void* heap)
{
 800c0d4:	b580      	push	{r7, lr}
 800c0d6:	b088      	sub	sp, #32
 800c0d8:	af00      	add	r7, sp, #0
 800c0da:	6078      	str	r0, [r7, #4]
 800c0dc:	6039      	str	r1, [r7, #0]
    WOLFSSL_CTX* ctx = NULL;
 800c0de:	2300      	movs	r3, #0
 800c0e0:	61fb      	str	r3, [r7, #28]

    WOLFSSL_ENTER("wolfSSL_CTX_new_ex");

    if (initRefCount == 0) {
 800c0e2:	4b1e      	ldr	r3, [pc, #120]	@ (800c15c <wolfSSL_CTX_new_ex+0x88>)
 800c0e4:	681b      	ldr	r3, [r3, #0]
 800c0e6:	2b00      	cmp	r3, #0
 800c0e8:	d10f      	bne.n	800c10a <wolfSSL_CTX_new_ex+0x36>
        /* user no longer forced to call Init themselves */
        int ret = wolfSSL_Init();
 800c0ea:	f000 fb2f 	bl	800c74c <wolfSSL_Init>
 800c0ee:	61b8      	str	r0, [r7, #24]
        if (ret != WOLFSSL_SUCCESS) {
 800c0f0:	69bb      	ldr	r3, [r7, #24]
 800c0f2:	2b01      	cmp	r3, #1
 800c0f4:	d009      	beq.n	800c10a <wolfSSL_CTX_new_ex+0x36>
            WOLFSSL_MSG("wolfSSL_Init failed");
            WOLFSSL_LEAVE("wolfSSL_CTX_new_ex", 0);
            XFREE(method, heap, DYNAMIC_TYPE_METHOD);
 800c0f6:	687b      	ldr	r3, [r7, #4]
 800c0f8:	617b      	str	r3, [r7, #20]
 800c0fa:	697b      	ldr	r3, [r7, #20]
 800c0fc:	2b00      	cmp	r3, #0
 800c0fe:	d002      	beq.n	800c106 <wolfSSL_CTX_new_ex+0x32>
 800c100:	6978      	ldr	r0, [r7, #20]
 800c102:	f012 fce3 	bl	801eacc <wolfSSL_Free>
            return NULL;
 800c106:	2300      	movs	r3, #0
 800c108:	e024      	b.n	800c154 <wolfSSL_CTX_new_ex+0x80>
        }
    }

#ifndef NO_TLS
    if (method == NULL)
 800c10a:	687b      	ldr	r3, [r7, #4]
 800c10c:	2b00      	cmp	r3, #0
 800c10e:	d101      	bne.n	800c114 <wolfSSL_CTX_new_ex+0x40>
        return ctx;
 800c110:	69fb      	ldr	r3, [r7, #28]
 800c112:	e01f      	b.n	800c154 <wolfSSL_CTX_new_ex+0x80>
#else
    /* a blank TLS method */
    method = (WOLFSSL_METHOD*)&gNoTlsMethod;
#endif

    ctx = (WOLFSSL_CTX*)XMALLOC(sizeof(WOLFSSL_CTX), heap, DYNAMIC_TYPE_CTX);
 800c114:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 800c118:	f012 fcbc 	bl	801ea94 <wolfSSL_Malloc>
 800c11c:	61f8      	str	r0, [r7, #28]
    if (ctx) {
 800c11e:	69fb      	ldr	r3, [r7, #28]
 800c120:	2b00      	cmp	r3, #0
 800c122:	d00e      	beq.n	800c142 <wolfSSL_CTX_new_ex+0x6e>
        int ret;

        ret = InitSSL_Ctx(ctx, method, heap);
 800c124:	683a      	ldr	r2, [r7, #0]
 800c126:	6879      	ldr	r1, [r7, #4]
 800c128:	69f8      	ldr	r0, [r7, #28]
 800c12a:	f7fc fc20 	bl	800896e <InitSSL_Ctx>
 800c12e:	60f8      	str	r0, [r7, #12]
    #ifdef WOLFSSL_STATIC_MEMORY
        if (heap != NULL) {
            ctx->onHeapHint = 1; /* free the memory back to heap when done */
        }
    #endif
        if (ret < 0) {
 800c130:	68fb      	ldr	r3, [r7, #12]
 800c132:	2b00      	cmp	r3, #0
 800c134:	da0d      	bge.n	800c152 <wolfSSL_CTX_new_ex+0x7e>
            WOLFSSL_MSG("Init CTX failed");
            wolfSSL_CTX_free(ctx);
 800c136:	69f8      	ldr	r0, [r7, #28]
 800c138:	f000 f81f 	bl	800c17a <wolfSSL_CTX_free>
            ctx = NULL;
 800c13c:	2300      	movs	r3, #0
 800c13e:	61fb      	str	r3, [r7, #28]
 800c140:	e007      	b.n	800c152 <wolfSSL_CTX_new_ex+0x7e>
        }
#endif
    }
    else {
        WOLFSSL_MSG("Alloc CTX failed, method freed");
        XFREE(method, heap, DYNAMIC_TYPE_METHOD);
 800c142:	687b      	ldr	r3, [r7, #4]
 800c144:	613b      	str	r3, [r7, #16]
 800c146:	693b      	ldr	r3, [r7, #16]
 800c148:	2b00      	cmp	r3, #0
 800c14a:	d002      	beq.n	800c152 <wolfSSL_CTX_new_ex+0x7e>
 800c14c:	6938      	ldr	r0, [r7, #16]
 800c14e:	f012 fcbd 	bl	801eacc <wolfSSL_Free>
        }
    }
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

    WOLFSSL_LEAVE("wolfSSL_CTX_new_ex", 0);
    return ctx;
 800c152:	69fb      	ldr	r3, [r7, #28]
}
 800c154:	4618      	mov	r0, r3
 800c156:	3720      	adds	r7, #32
 800c158:	46bd      	mov	sp, r7
 800c15a:	bd80      	pop	{r7, pc}
 800c15c:	200026e4 	.word	0x200026e4

0800c160 <wolfSSL_CTX_new>:


WOLFSSL_ABI
WOLFSSL_CTX* wolfSSL_CTX_new(WOLFSSL_METHOD* method)
{
 800c160:	b580      	push	{r7, lr}
 800c162:	b082      	sub	sp, #8
 800c164:	af00      	add	r7, sp, #0
 800c166:	6078      	str	r0, [r7, #4]
#ifdef WOLFSSL_HEAP_TEST
    /* if testing the heap hint then set top level CTX to have test value */
    return wolfSSL_CTX_new_ex(method, (void*)WOLFSSL_HEAP_TEST);
#else
    return wolfSSL_CTX_new_ex(method, NULL);
 800c168:	2100      	movs	r1, #0
 800c16a:	6878      	ldr	r0, [r7, #4]
 800c16c:	f7ff ffb2 	bl	800c0d4 <wolfSSL_CTX_new_ex>
 800c170:	4603      	mov	r3, r0
#endif
}
 800c172:	4618      	mov	r0, r3
 800c174:	3708      	adds	r7, #8
 800c176:	46bd      	mov	sp, r7
 800c178:	bd80      	pop	{r7, pc}

0800c17a <wolfSSL_CTX_free>:
#endif
}

WOLFSSL_ABI
void wolfSSL_CTX_free(WOLFSSL_CTX* ctx)
{
 800c17a:	b580      	push	{r7, lr}
 800c17c:	b082      	sub	sp, #8
 800c17e:	af00      	add	r7, sp, #0
 800c180:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_CTX_free");
    if (ctx) {
 800c182:	687b      	ldr	r3, [r7, #4]
 800c184:	2b00      	cmp	r3, #0
 800c186:	d002      	beq.n	800c18e <wolfSSL_CTX_free+0x14>
            wc_SrpTerm(ctx->srp);
            XFREE(ctx->srp, ctx->heap, DYNAMIC_TYPE_SRP);
            ctx->srp = NULL;
        }
#endif
        FreeSSL_Ctx(ctx);
 800c188:	6878      	ldr	r0, [r7, #4]
 800c18a:	f7fc fdc9 	bl	8008d20 <FreeSSL_Ctx>
    }

    WOLFSSL_LEAVE("wolfSSL_CTX_free", 0);
}
 800c18e:	bf00      	nop
 800c190:	3708      	adds	r7, #8
 800c192:	46bd      	mov	sp, r7
 800c194:	bd80      	pop	{r7, pc}

0800c196 <wolfSSL_free>:
}


WOLFSSL_ABI
void wolfSSL_free(WOLFSSL* ssl)
{
 800c196:	b580      	push	{r7, lr}
 800c198:	b082      	sub	sp, #8
 800c19a:	af00      	add	r7, sp, #0
 800c19c:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_free");

    if (ssl) {
 800c19e:	687b      	ldr	r3, [r7, #4]
 800c1a0:	2b00      	cmp	r3, #0
 800c1a2:	d006      	beq.n	800c1b2 <wolfSSL_free+0x1c>
        WOLFSSL_MSG_EX("Free SSL: %p", (wc_ptr_t)ssl);
        FreeSSL(ssl, ssl->ctx->heap);
 800c1a4:	687b      	ldr	r3, [r7, #4]
 800c1a6:	681b      	ldr	r3, [r3, #0]
 800c1a8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800c1aa:	4619      	mov	r1, r3
 800c1ac:	6878      	ldr	r0, [r7, #4]
 800c1ae:	f7fd fdbb 	bl	8009d28 <FreeSSL>
    }
    else {
        WOLFSSL_MSG("Free SSL: wolfSSL_free already null");
    }
    WOLFSSL_LEAVE("wolfSSL_free", 0);
}
 800c1b2:	bf00      	nop
 800c1b4:	3708      	adds	r7, #8
 800c1b6:	46bd      	mov	sp, r7
 800c1b8:	bd80      	pop	{r7, pc}

0800c1ba <wolfSSL_CTX_GetDevId>:
}

/* helpers to get device id and heap */
WOLFSSL_ABI
int wolfSSL_CTX_GetDevId(WOLFSSL_CTX* ctx, WOLFSSL* ssl)
{
 800c1ba:	b480      	push	{r7}
 800c1bc:	b085      	sub	sp, #20
 800c1be:	af00      	add	r7, sp, #0
 800c1c0:	6078      	str	r0, [r7, #4]
 800c1c2:	6039      	str	r1, [r7, #0]
    int devId = INVALID_DEVID;
 800c1c4:	f06f 0301 	mvn.w	r3, #1
 800c1c8:	60fb      	str	r3, [r7, #12]
    if (ssl != NULL)
 800c1ca:	683b      	ldr	r3, [r7, #0]
 800c1cc:	2b00      	cmp	r3, #0
 800c1ce:	d005      	beq.n	800c1dc <wolfSSL_CTX_GetDevId+0x22>
        devId = ssl->devId;
 800c1d0:	683b      	ldr	r3, [r7, #0]
 800c1d2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800c1d6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800c1da:	60fb      	str	r3, [r7, #12]
    if (ctx != NULL && devId == INVALID_DEVID)
 800c1dc:	687b      	ldr	r3, [r7, #4]
 800c1de:	2b00      	cmp	r3, #0
 800c1e0:	d007      	beq.n	800c1f2 <wolfSSL_CTX_GetDevId+0x38>
 800c1e2:	68fb      	ldr	r3, [r7, #12]
 800c1e4:	f113 0f02 	cmn.w	r3, #2
 800c1e8:	d103      	bne.n	800c1f2 <wolfSSL_CTX_GetDevId+0x38>
        devId = ctx->devId;
 800c1ea:	687b      	ldr	r3, [r7, #4]
 800c1ec:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 800c1f0:	60fb      	str	r3, [r7, #12]
    return devId;
 800c1f2:	68fb      	ldr	r3, [r7, #12]
}
 800c1f4:	4618      	mov	r0, r3
 800c1f6:	3714      	adds	r7, #20
 800c1f8:	46bd      	mov	sp, r7
 800c1fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c1fe:	4770      	bx	lr

0800c200 <wolfSSL_CTX_GetCertManager>:

#endif /* ATOMIC_USER */

#ifndef NO_CERTS
WOLFSSL_CERT_MANAGER* wolfSSL_CTX_GetCertManager(WOLFSSL_CTX* ctx)
{
 800c200:	b480      	push	{r7}
 800c202:	b085      	sub	sp, #20
 800c204:	af00      	add	r7, sp, #0
 800c206:	6078      	str	r0, [r7, #4]
    WOLFSSL_CERT_MANAGER* cm = NULL;
 800c208:	2300      	movs	r3, #0
 800c20a:	60fb      	str	r3, [r7, #12]
    if (ctx)
 800c20c:	687b      	ldr	r3, [r7, #4]
 800c20e:	2b00      	cmp	r3, #0
 800c210:	d002      	beq.n	800c218 <wolfSSL_CTX_GetCertManager+0x18>
        cm = ctx->cm;
 800c212:	687b      	ldr	r3, [r7, #4]
 800c214:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c216:	60fb      	str	r3, [r7, #12]
    return cm;
 800c218:	68fb      	ldr	r3, [r7, #12]
}
 800c21a:	4618      	mov	r0, r3
 800c21c:	3714      	adds	r7, #20
 800c21e:	46bd      	mov	sp, r7
 800c220:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c224:	4770      	bx	lr
	...

0800c228 <HashSigner>:

#ifndef NO_CERTS

/* hash is the SHA digest of name, just use first 32 bits as hash */
static WC_INLINE word32 HashSigner(const byte* hash)
{
 800c228:	b580      	push	{r7, lr}
 800c22a:	b082      	sub	sp, #8
 800c22c:	af00      	add	r7, sp, #0
 800c22e:	6078      	str	r0, [r7, #4]
    return MakeWordFromHash(hash) % CA_TABLE_SIZE;
 800c230:	6878      	ldr	r0, [r7, #4]
 800c232:	f7fe ffc6 	bl	800b1c2 <MakeWordFromHash>
 800c236:	4601      	mov	r1, r0
 800c238:	4b07      	ldr	r3, [pc, #28]	@ (800c258 <HashSigner+0x30>)
 800c23a:	fba3 2301 	umull	r2, r3, r3, r1
 800c23e:	08da      	lsrs	r2, r3, #3
 800c240:	4613      	mov	r3, r2
 800c242:	009b      	lsls	r3, r3, #2
 800c244:	4413      	add	r3, r2
 800c246:	005b      	lsls	r3, r3, #1
 800c248:	4413      	add	r3, r2
 800c24a:	1aca      	subs	r2, r1, r3
 800c24c:	4613      	mov	r3, r2
}
 800c24e:	4618      	mov	r0, r3
 800c250:	3708      	adds	r7, #8
 800c252:	46bd      	mov	sp, r7
 800c254:	bd80      	pop	{r7, pc}
 800c256:	bf00      	nop
 800c258:	ba2e8ba3 	.word	0xba2e8ba3

0800c25c <AlreadySigner>:


/* does CA already exist on signer list */
int AlreadySigner(WOLFSSL_CERT_MANAGER* cm, byte* hash)
{
 800c25c:	b580      	push	{r7, lr}
 800c25e:	b086      	sub	sp, #24
 800c260:	af00      	add	r7, sp, #0
 800c262:	6078      	str	r0, [r7, #4]
 800c264:	6039      	str	r1, [r7, #0]
    Signer* signers;
    int     ret = 0;
 800c266:	2300      	movs	r3, #0
 800c268:	613b      	str	r3, [r7, #16]
    word32  row;

    if (cm == NULL || hash == NULL) {
 800c26a:	687b      	ldr	r3, [r7, #4]
 800c26c:	2b00      	cmp	r3, #0
 800c26e:	d002      	beq.n	800c276 <AlreadySigner+0x1a>
 800c270:	683b      	ldr	r3, [r7, #0]
 800c272:	2b00      	cmp	r3, #0
 800c274:	d101      	bne.n	800c27a <AlreadySigner+0x1e>
        return ret;
 800c276:	693b      	ldr	r3, [r7, #16]
 800c278:	e02e      	b.n	800c2d8 <AlreadySigner+0x7c>
    }

    row = HashSigner(hash);
 800c27a:	6838      	ldr	r0, [r7, #0]
 800c27c:	f7ff ffd4 	bl	800c228 <HashSigner>
 800c280:	60f8      	str	r0, [r7, #12]

    if (wc_LockMutex(&cm->caLock) != 0) {
 800c282:	687b      	ldr	r3, [r7, #4]
 800c284:	335c      	adds	r3, #92	@ 0x5c
 800c286:	4618      	mov	r0, r3
 800c288:	f01b f894 	bl	80273b4 <wc_LockMutex>
 800c28c:	4603      	mov	r3, r0
 800c28e:	2b00      	cmp	r3, #0
 800c290:	d001      	beq.n	800c296 <AlreadySigner+0x3a>
        return ret;
 800c292:	693b      	ldr	r3, [r7, #16]
 800c294:	e020      	b.n	800c2d8 <AlreadySigner+0x7c>
    }
    signers = cm->caTable[row];
 800c296:	687b      	ldr	r3, [r7, #4]
 800c298:	68fa      	ldr	r2, [r7, #12]
 800c29a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c29e:	617b      	str	r3, [r7, #20]
    while (signers) {
 800c2a0:	e011      	b.n	800c2c6 <AlreadySigner+0x6a>
        byte* subjectHash;

    #ifndef NO_SKID
        subjectHash = signers->subjectKeyIdHash;
 800c2a2:	697b      	ldr	r3, [r7, #20]
 800c2a4:	3340      	adds	r3, #64	@ 0x40
 800c2a6:	60bb      	str	r3, [r7, #8]
    #else
        subjectHash = signers->subjectNameHash;
    #endif

        if (XMEMCMP(hash, subjectHash, SIGNER_DIGEST_SIZE) == 0) {
 800c2a8:	2220      	movs	r2, #32
 800c2aa:	68b9      	ldr	r1, [r7, #8]
 800c2ac:	6838      	ldr	r0, [r7, #0]
 800c2ae:	f01c f8e5 	bl	802847c <memcmp>
 800c2b2:	4603      	mov	r3, r0
 800c2b4:	2b00      	cmp	r3, #0
 800c2b6:	d102      	bne.n	800c2be <AlreadySigner+0x62>
            ret = 1; /* success */
 800c2b8:	2301      	movs	r3, #1
 800c2ba:	613b      	str	r3, [r7, #16]
            break;
 800c2bc:	e006      	b.n	800c2cc <AlreadySigner+0x70>
        }
        signers = signers->next;
 800c2be:	697b      	ldr	r3, [r7, #20]
 800c2c0:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c2c4:	617b      	str	r3, [r7, #20]
    while (signers) {
 800c2c6:	697b      	ldr	r3, [r7, #20]
 800c2c8:	2b00      	cmp	r3, #0
 800c2ca:	d1ea      	bne.n	800c2a2 <AlreadySigner+0x46>
    }
    wc_UnLockMutex(&cm->caLock);
 800c2cc:	687b      	ldr	r3, [r7, #4]
 800c2ce:	335c      	adds	r3, #92	@ 0x5c
 800c2d0:	4618      	mov	r0, r3
 800c2d2:	f01b f87a 	bl	80273ca <wc_UnLockMutex>

    return ret;
 800c2d6:	693b      	ldr	r3, [r7, #16]
}
 800c2d8:	4618      	mov	r0, r3
 800c2da:	3718      	adds	r7, #24
 800c2dc:	46bd      	mov	sp, r7
 800c2de:	bd80      	pop	{r7, pc}

0800c2e0 <GetCA>:
#endif /* WOLFSSL_TRUST_PEER_CERT */


/* return CA if found, otherwise NULL */
Signer* GetCA(void* vp, byte* hash)
{
 800c2e0:	b580      	push	{r7, lr}
 800c2e2:	b088      	sub	sp, #32
 800c2e4:	af00      	add	r7, sp, #0
 800c2e6:	6078      	str	r0, [r7, #4]
 800c2e8:	6039      	str	r1, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 800c2ea:	687b      	ldr	r3, [r7, #4]
 800c2ec:	617b      	str	r3, [r7, #20]
    Signer* ret = NULL;
 800c2ee:	2300      	movs	r3, #0
 800c2f0:	61fb      	str	r3, [r7, #28]
    Signer* signers;
    word32  row = 0;
 800c2f2:	2300      	movs	r3, #0
 800c2f4:	613b      	str	r3, [r7, #16]

    if (cm == NULL || hash == NULL)
 800c2f6:	697b      	ldr	r3, [r7, #20]
 800c2f8:	2b00      	cmp	r3, #0
 800c2fa:	d002      	beq.n	800c302 <GetCA+0x22>
 800c2fc:	683b      	ldr	r3, [r7, #0]
 800c2fe:	2b00      	cmp	r3, #0
 800c300:	d101      	bne.n	800c306 <GetCA+0x26>
        return NULL;
 800c302:	2300      	movs	r3, #0
 800c304:	e02e      	b.n	800c364 <GetCA+0x84>

    row = HashSigner(hash);
 800c306:	6838      	ldr	r0, [r7, #0]
 800c308:	f7ff ff8e 	bl	800c228 <HashSigner>
 800c30c:	6138      	str	r0, [r7, #16]

    if (wc_LockMutex(&cm->caLock) != 0)
 800c30e:	697b      	ldr	r3, [r7, #20]
 800c310:	335c      	adds	r3, #92	@ 0x5c
 800c312:	4618      	mov	r0, r3
 800c314:	f01b f84e 	bl	80273b4 <wc_LockMutex>
 800c318:	4603      	mov	r3, r0
 800c31a:	2b00      	cmp	r3, #0
 800c31c:	d001      	beq.n	800c322 <GetCA+0x42>
        return ret;
 800c31e:	69fb      	ldr	r3, [r7, #28]
 800c320:	e020      	b.n	800c364 <GetCA+0x84>

    signers = cm->caTable[row];
 800c322:	697b      	ldr	r3, [r7, #20]
 800c324:	693a      	ldr	r2, [r7, #16]
 800c326:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c32a:	61bb      	str	r3, [r7, #24]
    while (signers) {
 800c32c:	e011      	b.n	800c352 <GetCA+0x72>
        byte* subjectHash;
        #ifndef NO_SKID
            subjectHash = signers->subjectKeyIdHash;
 800c32e:	69bb      	ldr	r3, [r7, #24]
 800c330:	3340      	adds	r3, #64	@ 0x40
 800c332:	60fb      	str	r3, [r7, #12]
        #else
            subjectHash = signers->subjectNameHash;
        #endif
        if (XMEMCMP(hash, subjectHash, SIGNER_DIGEST_SIZE) == 0) {
 800c334:	2220      	movs	r2, #32
 800c336:	68f9      	ldr	r1, [r7, #12]
 800c338:	6838      	ldr	r0, [r7, #0]
 800c33a:	f01c f89f 	bl	802847c <memcmp>
 800c33e:	4603      	mov	r3, r0
 800c340:	2b00      	cmp	r3, #0
 800c342:	d102      	bne.n	800c34a <GetCA+0x6a>
            ret = signers;
 800c344:	69bb      	ldr	r3, [r7, #24]
 800c346:	61fb      	str	r3, [r7, #28]
            break;
 800c348:	e006      	b.n	800c358 <GetCA+0x78>
        }
        signers = signers->next;
 800c34a:	69bb      	ldr	r3, [r7, #24]
 800c34c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c350:	61bb      	str	r3, [r7, #24]
    while (signers) {
 800c352:	69bb      	ldr	r3, [r7, #24]
 800c354:	2b00      	cmp	r3, #0
 800c356:	d1ea      	bne.n	800c32e <GetCA+0x4e>
    }
    wc_UnLockMutex(&cm->caLock);
 800c358:	697b      	ldr	r3, [r7, #20]
 800c35a:	335c      	adds	r3, #92	@ 0x5c
 800c35c:	4618      	mov	r0, r3
 800c35e:	f01b f834 	bl	80273ca <wc_UnLockMutex>

    return ret;
 800c362:	69fb      	ldr	r3, [r7, #28]
}
 800c364:	4618      	mov	r0, r3
 800c366:	3720      	adds	r7, #32
 800c368:	46bd      	mov	sp, r7
 800c36a:	bd80      	pop	{r7, pc}

0800c36c <GetCAByAKID>:
}
#endif
#ifdef WOLFSSL_AKID_NAME
Signer* GetCAByAKID(void* vp, const byte* issuer, word32 issuerSz,
        const byte* serial, word32 serialSz)
{
 800c36c:	b580      	push	{r7, lr}
 800c36e:	b098      	sub	sp, #96	@ 0x60
 800c370:	af00      	add	r7, sp, #0
 800c372:	60f8      	str	r0, [r7, #12]
 800c374:	60b9      	str	r1, [r7, #8]
 800c376:	607a      	str	r2, [r7, #4]
 800c378:	603b      	str	r3, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 800c37a:	68fb      	ldr	r3, [r7, #12]
 800c37c:	653b      	str	r3, [r7, #80]	@ 0x50
    Signer* ret = NULL;
 800c37e:	2300      	movs	r3, #0
 800c380:	65fb      	str	r3, [r7, #92]	@ 0x5c
    Signer* signers;
    byte nameHash[SIGNER_DIGEST_SIZE];
    byte serialHash[SIGNER_DIGEST_SIZE];
    word32 row;

    if (cm == NULL || issuer == NULL || issuerSz == 0 ||
 800c382:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c384:	2b00      	cmp	r3, #0
 800c386:	d00b      	beq.n	800c3a0 <GetCAByAKID+0x34>
 800c388:	68bb      	ldr	r3, [r7, #8]
 800c38a:	2b00      	cmp	r3, #0
 800c38c:	d008      	beq.n	800c3a0 <GetCAByAKID+0x34>
 800c38e:	687b      	ldr	r3, [r7, #4]
 800c390:	2b00      	cmp	r3, #0
 800c392:	d005      	beq.n	800c3a0 <GetCAByAKID+0x34>
 800c394:	683b      	ldr	r3, [r7, #0]
 800c396:	2b00      	cmp	r3, #0
 800c398:	d002      	beq.n	800c3a0 <GetCAByAKID+0x34>
            serial == NULL || serialSz == 0)
 800c39a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800c39c:	2b00      	cmp	r3, #0
 800c39e:	d101      	bne.n	800c3a4 <GetCAByAKID+0x38>
        return NULL;
 800c3a0:	2300      	movs	r3, #0
 800c3a2:	e057      	b.n	800c454 <GetCAByAKID+0xe8>

    if (CalcHashId(issuer, issuerSz, nameHash) != 0 ||
 800c3a4:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 800c3a8:	461a      	mov	r2, r3
 800c3aa:	6879      	ldr	r1, [r7, #4]
 800c3ac:	68b8      	ldr	r0, [r7, #8]
 800c3ae:	f009 f9ac 	bl	801570a <CalcHashId>
 800c3b2:	4603      	mov	r3, r0
 800c3b4:	2b00      	cmp	r3, #0
 800c3b6:	d109      	bne.n	800c3cc <GetCAByAKID+0x60>
            CalcHashId(serial, serialSz, serialHash) != 0)
 800c3b8:	f107 0310 	add.w	r3, r7, #16
 800c3bc:	461a      	mov	r2, r3
 800c3be:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 800c3c0:	6838      	ldr	r0, [r7, #0]
 800c3c2:	f009 f9a2 	bl	801570a <CalcHashId>
 800c3c6:	4603      	mov	r3, r0
    if (CalcHashId(issuer, issuerSz, nameHash) != 0 ||
 800c3c8:	2b00      	cmp	r3, #0
 800c3ca:	d001      	beq.n	800c3d0 <GetCAByAKID+0x64>
        return NULL;
 800c3cc:	2300      	movs	r3, #0
 800c3ce:	e041      	b.n	800c454 <GetCAByAKID+0xe8>

    if (wc_LockMutex(&cm->caLock) != 0)
 800c3d0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c3d2:	335c      	adds	r3, #92	@ 0x5c
 800c3d4:	4618      	mov	r0, r3
 800c3d6:	f01a ffed 	bl	80273b4 <wc_LockMutex>
 800c3da:	4603      	mov	r3, r0
 800c3dc:	2b00      	cmp	r3, #0
 800c3de:	d001      	beq.n	800c3e4 <GetCAByAKID+0x78>
        return ret;
 800c3e0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800c3e2:	e037      	b.n	800c454 <GetCAByAKID+0xe8>

    /* Unfortunately we need to look through the entire table */
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c3e4:	2300      	movs	r3, #0
 800c3e6:	657b      	str	r3, [r7, #84]	@ 0x54
 800c3e8:	e028      	b.n	800c43c <GetCAByAKID+0xd0>
        for (signers = cm->caTable[row]; signers != NULL;
 800c3ea:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c3ec:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800c3ee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c3f2:	65bb      	str	r3, [r7, #88]	@ 0x58
 800c3f4:	e01c      	b.n	800c430 <GetCAByAKID+0xc4>
                signers = signers->next) {
            if (XMEMCMP(signers->subjectNameHash, nameHash, SIGNER_DIGEST_SIZE)
 800c3f6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c3f8:	3320      	adds	r3, #32
 800c3fa:	f107 0130 	add.w	r1, r7, #48	@ 0x30
 800c3fe:	2220      	movs	r2, #32
 800c400:	4618      	mov	r0, r3
 800c402:	f01c f83b 	bl	802847c <memcmp>
 800c406:	4603      	mov	r3, r0
 800c408:	2b00      	cmp	r3, #0
 800c40a:	d10d      	bne.n	800c428 <GetCAByAKID+0xbc>
                    == 0 && XMEMCMP(signers->serialHash, serialHash,
 800c40c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c40e:	3360      	adds	r3, #96	@ 0x60
 800c410:	f107 0110 	add.w	r1, r7, #16
 800c414:	2220      	movs	r2, #32
 800c416:	4618      	mov	r0, r3
 800c418:	f01c f830 	bl	802847c <memcmp>
 800c41c:	4603      	mov	r3, r0
 800c41e:	2b00      	cmp	r3, #0
 800c420:	d102      	bne.n	800c428 <GetCAByAKID+0xbc>
                                    SIGNER_DIGEST_SIZE) == 0) {
                ret = signers;
 800c422:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c424:	65fb      	str	r3, [r7, #92]	@ 0x5c
                break;
 800c426:	e006      	b.n	800c436 <GetCAByAKID+0xca>
                signers = signers->next) {
 800c428:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c42a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c42e:	65bb      	str	r3, [r7, #88]	@ 0x58
        for (signers = cm->caTable[row]; signers != NULL;
 800c430:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c432:	2b00      	cmp	r3, #0
 800c434:	d1df      	bne.n	800c3f6 <GetCAByAKID+0x8a>
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c436:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800c438:	3301      	adds	r3, #1
 800c43a:	657b      	str	r3, [r7, #84]	@ 0x54
 800c43c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800c43e:	2b0a      	cmp	r3, #10
 800c440:	d802      	bhi.n	800c448 <GetCAByAKID+0xdc>
 800c442:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800c444:	2b00      	cmp	r3, #0
 800c446:	d0d0      	beq.n	800c3ea <GetCAByAKID+0x7e>
            }
        }
    }

    wc_UnLockMutex(&cm->caLock);
 800c448:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c44a:	335c      	adds	r3, #92	@ 0x5c
 800c44c:	4618      	mov	r0, r3
 800c44e:	f01a ffbc 	bl	80273ca <wc_UnLockMutex>

    return ret;
 800c452:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
}
 800c454:	4618      	mov	r0, r3
 800c456:	3760      	adds	r7, #96	@ 0x60
 800c458:	46bd      	mov	sp, r7
 800c45a:	bd80      	pop	{r7, pc}

0800c45c <GetCAByName>:
#endif

#ifndef NO_SKID
/* return CA if found, otherwise NULL. Walk through hash table. */
Signer* GetCAByName(void* vp, byte* hash)
{
 800c45c:	b580      	push	{r7, lr}
 800c45e:	b086      	sub	sp, #24
 800c460:	af00      	add	r7, sp, #0
 800c462:	6078      	str	r0, [r7, #4]
 800c464:	6039      	str	r1, [r7, #0]
    WOLFSSL_CERT_MANAGER* cm = (WOLFSSL_CERT_MANAGER*)vp;
 800c466:	687b      	ldr	r3, [r7, #4]
 800c468:	60bb      	str	r3, [r7, #8]
    Signer* ret = NULL;
 800c46a:	2300      	movs	r3, #0
 800c46c:	617b      	str	r3, [r7, #20]
    Signer* signers;
    word32  row;

    if (cm == NULL)
 800c46e:	68bb      	ldr	r3, [r7, #8]
 800c470:	2b00      	cmp	r3, #0
 800c472:	d101      	bne.n	800c478 <GetCAByName+0x1c>
        return NULL;
 800c474:	2300      	movs	r3, #0
 800c476:	e037      	b.n	800c4e8 <GetCAByName+0x8c>

    if (wc_LockMutex(&cm->caLock) != 0)
 800c478:	68bb      	ldr	r3, [r7, #8]
 800c47a:	335c      	adds	r3, #92	@ 0x5c
 800c47c:	4618      	mov	r0, r3
 800c47e:	f01a ff99 	bl	80273b4 <wc_LockMutex>
 800c482:	4603      	mov	r3, r0
 800c484:	2b00      	cmp	r3, #0
 800c486:	d001      	beq.n	800c48c <GetCAByName+0x30>
        return ret;
 800c488:	697b      	ldr	r3, [r7, #20]
 800c48a:	e02d      	b.n	800c4e8 <GetCAByName+0x8c>

    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c48c:	2300      	movs	r3, #0
 800c48e:	60fb      	str	r3, [r7, #12]
 800c490:	e01e      	b.n	800c4d0 <GetCAByName+0x74>
        signers = cm->caTable[row];
 800c492:	68bb      	ldr	r3, [r7, #8]
 800c494:	68fa      	ldr	r2, [r7, #12]
 800c496:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c49a:	613b      	str	r3, [r7, #16]
        while (signers && ret == NULL) {
 800c49c:	e00f      	b.n	800c4be <GetCAByName+0x62>
            if (XMEMCMP(hash, signers->subjectNameHash,
 800c49e:	693b      	ldr	r3, [r7, #16]
 800c4a0:	3320      	adds	r3, #32
 800c4a2:	2220      	movs	r2, #32
 800c4a4:	4619      	mov	r1, r3
 800c4a6:	6838      	ldr	r0, [r7, #0]
 800c4a8:	f01b ffe8 	bl	802847c <memcmp>
 800c4ac:	4603      	mov	r3, r0
 800c4ae:	2b00      	cmp	r3, #0
 800c4b0:	d101      	bne.n	800c4b6 <GetCAByName+0x5a>
                        SIGNER_DIGEST_SIZE) == 0) {
                ret = signers;
 800c4b2:	693b      	ldr	r3, [r7, #16]
 800c4b4:	617b      	str	r3, [r7, #20]
            }
            signers = signers->next;
 800c4b6:	693b      	ldr	r3, [r7, #16]
 800c4b8:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800c4bc:	613b      	str	r3, [r7, #16]
        while (signers && ret == NULL) {
 800c4be:	693b      	ldr	r3, [r7, #16]
 800c4c0:	2b00      	cmp	r3, #0
 800c4c2:	d002      	beq.n	800c4ca <GetCAByName+0x6e>
 800c4c4:	697b      	ldr	r3, [r7, #20]
 800c4c6:	2b00      	cmp	r3, #0
 800c4c8:	d0e9      	beq.n	800c49e <GetCAByName+0x42>
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
 800c4ca:	68fb      	ldr	r3, [r7, #12]
 800c4cc:	3301      	adds	r3, #1
 800c4ce:	60fb      	str	r3, [r7, #12]
 800c4d0:	68fb      	ldr	r3, [r7, #12]
 800c4d2:	2b0a      	cmp	r3, #10
 800c4d4:	d802      	bhi.n	800c4dc <GetCAByName+0x80>
 800c4d6:	697b      	ldr	r3, [r7, #20]
 800c4d8:	2b00      	cmp	r3, #0
 800c4da:	d0da      	beq.n	800c492 <GetCAByName+0x36>
        }
    }
    wc_UnLockMutex(&cm->caLock);
 800c4dc:	68bb      	ldr	r3, [r7, #8]
 800c4de:	335c      	adds	r3, #92	@ 0x5c
 800c4e0:	4618      	mov	r0, r3
 800c4e2:	f01a ff72 	bl	80273ca <wc_UnLockMutex>

    return ret;
 800c4e6:	697b      	ldr	r3, [r7, #20]
}
 800c4e8:	4618      	mov	r0, r3
 800c4ea:	3718      	adds	r7, #24
 800c4ec:	46bd      	mov	sp, r7
 800c4ee:	bd80      	pop	{r7, pc}

0800c4f0 <AddCA>:

/* owns der, internal now uses too */
/* type flag ids from user or from chain received during verify
   don't allow chain ones to be added w/o isCA extension */
int AddCA(WOLFSSL_CERT_MANAGER* cm, DerBuffer** pDer, int type, int verify)
{
 800c4f0:	b580      	push	{r7, lr}
 800c4f2:	b08c      	sub	sp, #48	@ 0x30
 800c4f4:	af00      	add	r7, sp, #0
 800c4f6:	60f8      	str	r0, [r7, #12]
 800c4f8:	60b9      	str	r1, [r7, #8]
 800c4fa:	607a      	str	r2, [r7, #4]
 800c4fc:	603b      	str	r3, [r7, #0]
    int         ret;
    Signer*     signer = NULL;
 800c4fe:	2300      	movs	r3, #0
 800c500:	62bb      	str	r3, [r7, #40]	@ 0x28
    word32      row;
    byte*       subjectHash;
#ifdef WOLFSSL_SMALL_STACK
    DecodedCert* cert = NULL;
 800c502:	2300      	movs	r3, #0
 800c504:	627b      	str	r3, [r7, #36]	@ 0x24
#else
    DecodedCert  cert[1];
#endif
    DerBuffer*   der = *pDer;
 800c506:	68bb      	ldr	r3, [r7, #8]
 800c508:	681b      	ldr	r3, [r3, #0]
 800c50a:	623b      	str	r3, [r7, #32]

    WOLFSSL_MSG("Adding a CA");

    if (cm == NULL) {
 800c50c:	68fb      	ldr	r3, [r7, #12]
 800c50e:	2b00      	cmp	r3, #0
 800c510:	d105      	bne.n	800c51e <AddCA+0x2e>
        FreeDer(pDer);
 800c512:	68b8      	ldr	r0, [r7, #8]
 800c514:	f00c fd38 	bl	8018f88 <FreeDer>
        return BAD_FUNC_ARG;
 800c518:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800c51c:	e110      	b.n	800c740 <AddCA+0x250>
    }

#ifdef WOLFSSL_SMALL_STACK
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), NULL,
 800c51e:	f44f 6097 	mov.w	r0, #1208	@ 0x4b8
 800c522:	f012 fab7 	bl	801ea94 <wolfSSL_Malloc>
 800c526:	6278      	str	r0, [r7, #36]	@ 0x24
                                 DYNAMIC_TYPE_DCERT);
    if (cert == NULL) {
 800c528:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c52a:	2b00      	cmp	r3, #0
 800c52c:	d105      	bne.n	800c53a <AddCA+0x4a>
        FreeDer(pDer);
 800c52e:	68b8      	ldr	r0, [r7, #8]
 800c530:	f00c fd2a 	bl	8018f88 <FreeDer>
        return MEMORY_E;
 800c534:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800c538:	e102      	b.n	800c740 <AddCA+0x250>
    }
#endif

    InitDecodedCert(cert, der->buffer, der->length, cm->heap);
 800c53a:	6a3b      	ldr	r3, [r7, #32]
 800c53c:	6819      	ldr	r1, [r3, #0]
 800c53e:	6a3b      	ldr	r3, [r7, #32]
 800c540:	689a      	ldr	r2, [r3, #8]
 800c542:	68fb      	ldr	r3, [r7, #12]
 800c544:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c546:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800c548:	f008 fdd1 	bl	80150ee <InitDecodedCert>
    if (cm->unknownExtCallback != NULL) {
        wc_SetUnknownExtCallback(cert, cm->unknownExtCallback);
    }
#endif

    ret = ParseCert(cert, CA_TYPE, verify, cm);
 800c54c:	68fb      	ldr	r3, [r7, #12]
 800c54e:	683a      	ldr	r2, [r7, #0]
 800c550:	2106      	movs	r1, #6
 800c552:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800c554:	f00c f893 	bl	801867e <ParseCert>
 800c558:	62f8      	str	r0, [r7, #44]	@ 0x2c
    WOLFSSL_MSG("\tParsed new CA");

#ifndef NO_SKID
    subjectHash = cert->extSubjKeyId;
 800c55a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c55c:	f503 7371 	add.w	r3, r3, #964	@ 0x3c4
 800c560:	61fb      	str	r3, [r7, #28]
#else
    subjectHash = cert->subjectHash;
#endif

    /* check CA key size */
    if (verify) {
 800c562:	683b      	ldr	r3, [r7, #0]
 800c564:	2b00      	cmp	r3, #0
 800c566:	d037      	beq.n	800c5d8 <AddCA+0xe8>
        switch (cert->keyOID) {
 800c568:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c56a:	69db      	ldr	r3, [r3, #28]
 800c56c:	f240 228e 	movw	r2, #654	@ 0x28e
 800c570:	4293      	cmp	r3, r2
 800c572:	d00b      	beq.n	800c58c <AddCA+0x9c>
 800c574:	f240 228e 	movw	r2, #654	@ 0x28e
 800c578:	4293      	cmp	r3, r2
 800c57a:	d828      	bhi.n	800c5ce <AddCA+0xde>
 800c57c:	f240 2206 	movw	r2, #518	@ 0x206
 800c580:	4293      	cmp	r3, r2
 800c582:	d014      	beq.n	800c5ae <AddCA+0xbe>
 800c584:	f240 2285 	movw	r2, #645	@ 0x285
 800c588:	4293      	cmp	r3, r2
 800c58a:	d120      	bne.n	800c5ce <AddCA+0xde>
        #ifndef NO_RSA
            #ifdef WC_RSA_PSS
            case RSAPSSk:
            #endif
            case RSAk:
                if (cm->minRsaKeySz < 0 ||
 800c58c:	68fb      	ldr	r3, [r7, #12]
 800c58e:	f9b3 3062 	ldrsh.w	r3, [r3, #98]	@ 0x62
 800c592:	2b00      	cmp	r3, #0
 800c594:	db07      	blt.n	800c5a6 <AddCA+0xb6>
                                   cert->pubKeySize < (word16)cm->minRsaKeySz) {
 800c596:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c598:	685b      	ldr	r3, [r3, #4]
 800c59a:	68fa      	ldr	r2, [r7, #12]
 800c59c:	f9b2 2062 	ldrsh.w	r2, [r2, #98]	@ 0x62
 800c5a0:	b292      	uxth	r2, r2
                if (cm->minRsaKeySz < 0 ||
 800c5a2:	4293      	cmp	r3, r2
 800c5a4:	d215      	bcs.n	800c5d2 <AddCA+0xe2>
                    ret = RSA_KEY_SIZE_E;
 800c5a6:	f46f 73cc 	mvn.w	r3, #408	@ 0x198
 800c5aa:	62fb      	str	r3, [r7, #44]	@ 0x2c
                    WOLFSSL_MSG("\tCA RSA key size error");
                }
                break;
 800c5ac:	e011      	b.n	800c5d2 <AddCA+0xe2>
        #endif /* !NO_RSA */
            #ifdef HAVE_ECC
            case ECDSAk:
                if (cm->minEccKeySz < 0 ||
 800c5ae:	68fb      	ldr	r3, [r7, #12]
 800c5b0:	f9b3 3064 	ldrsh.w	r3, [r3, #100]	@ 0x64
 800c5b4:	2b00      	cmp	r3, #0
 800c5b6:	db07      	blt.n	800c5c8 <AddCA+0xd8>
                                   cert->pubKeySize < (word16)cm->minEccKeySz) {
 800c5b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c5ba:	685b      	ldr	r3, [r3, #4]
 800c5bc:	68fa      	ldr	r2, [r7, #12]
 800c5be:	f9b2 2064 	ldrsh.w	r2, [r2, #100]	@ 0x64
 800c5c2:	b292      	uxth	r2, r2
                if (cm->minEccKeySz < 0 ||
 800c5c4:	4293      	cmp	r3, r2
 800c5c6:	d206      	bcs.n	800c5d6 <AddCA+0xe6>
                    ret = ECC_KEY_SIZE_E;
 800c5c8:	4b5f      	ldr	r3, [pc, #380]	@ (800c748 <AddCA+0x258>)
 800c5ca:	62fb      	str	r3, [r7, #44]	@ 0x2c
                    WOLFSSL_MSG("\tCA ECC key size error");
                }
                break;
 800c5cc:	e003      	b.n	800c5d6 <AddCA+0xe6>
                break;
            #endif /* HAVE_DILITHIUM */

            default:
                WOLFSSL_MSG("\tNo key size check done on CA");
                break; /* no size check if key type is not in switch */
 800c5ce:	bf00      	nop
 800c5d0:	e002      	b.n	800c5d8 <AddCA+0xe8>
                break;
 800c5d2:	bf00      	nop
 800c5d4:	e000      	b.n	800c5d8 <AddCA+0xe8>
                break;
 800c5d6:	bf00      	nop
        }
    }

    if (ret == 0 && cert->isCA == 0 && type != WOLFSSL_USER_CA &&
 800c5d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c5da:	2b00      	cmp	r3, #0
 800c5dc:	d111      	bne.n	800c602 <AddCA+0x112>
 800c5de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c5e0:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800c5e4:	f003 0310 	and.w	r3, r3, #16
 800c5e8:	b2db      	uxtb	r3, r3
 800c5ea:	2b00      	cmp	r3, #0
 800c5ec:	d109      	bne.n	800c602 <AddCA+0x112>
 800c5ee:	687b      	ldr	r3, [r7, #4]
 800c5f0:	2b01      	cmp	r3, #1
 800c5f2:	d006      	beq.n	800c602 <AddCA+0x112>
 800c5f4:	687b      	ldr	r3, [r7, #4]
 800c5f6:	2b03      	cmp	r3, #3
 800c5f8:	d003      	beq.n	800c602 <AddCA+0x112>
        type != WOLFSSL_TEMP_CA) {
        WOLFSSL_MSG("\tCan't add as CA if not actually one");
        ret = NOT_CA_ERROR;
 800c5fa:	f46f 73b2 	mvn.w	r3, #356	@ 0x164
 800c5fe:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800c600:	e03e      	b.n	800c680 <AddCA+0x190>
    }
#ifndef ALLOW_INVALID_CERTSIGN
    else if (ret == 0 && cert->isCA == 1 && type != WOLFSSL_USER_CA &&
 800c602:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c604:	2b00      	cmp	r3, #0
 800c606:	d120      	bne.n	800c64a <AddCA+0x15a>
 800c608:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c60a:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 800c60e:	f003 0310 	and.w	r3, r3, #16
 800c612:	b2db      	uxtb	r3, r3
 800c614:	2b00      	cmp	r3, #0
 800c616:	d018      	beq.n	800c64a <AddCA+0x15a>
 800c618:	687b      	ldr	r3, [r7, #4]
 800c61a:	2b01      	cmp	r3, #1
 800c61c:	d015      	beq.n	800c64a <AddCA+0x15a>
 800c61e:	687b      	ldr	r3, [r7, #4]
 800c620:	2b03      	cmp	r3, #3
 800c622:	d012      	beq.n	800c64a <AddCA+0x15a>
        type != WOLFSSL_TEMP_CA && !cert->selfSigned &&
 800c624:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c626:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 800c62a:	f003 0302 	and.w	r3, r3, #2
 800c62e:	b2db      	uxtb	r3, r3
 800c630:	2b00      	cmp	r3, #0
 800c632:	d10a      	bne.n	800c64a <AddCA+0x15a>
        (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) == 0) {
 800c634:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c636:	f8b3 3420 	ldrh.w	r3, [r3, #1056]	@ 0x420
 800c63a:	f003 0304 	and.w	r3, r3, #4
        type != WOLFSSL_TEMP_CA && !cert->selfSigned &&
 800c63e:	2b00      	cmp	r3, #0
 800c640:	d103      	bne.n	800c64a <AddCA+0x15a>
        /* Intermediate CA certs are required to have the keyCertSign
        * extension set. User loaded root certs are not. */
        WOLFSSL_MSG("\tDoesn't have key usage certificate signing");
        ret = NOT_CA_ERROR;
 800c642:	f46f 73b2 	mvn.w	r3, #356	@ 0x164
 800c646:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800c648:	e01a      	b.n	800c680 <AddCA+0x190>
    }
#endif
    else if (ret == 0 && AlreadySigner(cm, subjectHash)) {
 800c64a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c64c:	2b00      	cmp	r3, #0
 800c64e:	d106      	bne.n	800c65e <AddCA+0x16e>
 800c650:	69f9      	ldr	r1, [r7, #28]
 800c652:	68f8      	ldr	r0, [r7, #12]
 800c654:	f7ff fe02 	bl	800c25c <AlreadySigner>
 800c658:	4603      	mov	r3, r0
 800c65a:	2b00      	cmp	r3, #0
 800c65c:	d10f      	bne.n	800c67e <AddCA+0x18e>
        WOLFSSL_MSG("\tAlready have this CA, not adding again");
        (void)ret;
    }
    else if (ret == 0) {
 800c65e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c660:	2b00      	cmp	r3, #0
 800c662:	d10d      	bne.n	800c680 <AddCA+0x190>
        /* take over signer parts */
        signer = MakeSigner(cm->heap);
 800c664:	68fb      	ldr	r3, [r7, #12]
 800c666:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c668:	4618      	mov	r0, r3
 800c66a:	f00c fb3b 	bl	8018ce4 <MakeSigner>
 800c66e:	62b8      	str	r0, [r7, #40]	@ 0x28
        if (!signer)
 800c670:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c672:	2b00      	cmp	r3, #0
 800c674:	d104      	bne.n	800c680 <AddCA+0x190>
            ret = MEMORY_ERROR;
 800c676:	f46f 7397 	mvn.w	r3, #302	@ 0x12e
 800c67a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800c67c:	e000      	b.n	800c680 <AddCA+0x190>
        (void)ret;
 800c67e:	bf00      	nop
    }
    if (ret == 0 && signer != NULL) {
 800c680:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c682:	2b00      	cmp	r3, #0
 800c684:	d13c      	bne.n	800c700 <AddCA+0x210>
 800c686:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c688:	2b00      	cmp	r3, #0
 800c68a:	d039      	beq.n	800c700 <AddCA+0x210>
        ret = FillSigner(signer, cert, type, der);
 800c68c:	6a3b      	ldr	r3, [r7, #32]
 800c68e:	687a      	ldr	r2, [r7, #4]
 800c690:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800c692:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c694:	f00c fa83 	bl	8018b9e <FillSigner>
 800c698:	62f8      	str	r0, [r7, #44]	@ 0x2c

    #ifndef NO_SKID
        row = HashSigner(signer->subjectKeyIdHash);
 800c69a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c69c:	3340      	adds	r3, #64	@ 0x40
 800c69e:	4618      	mov	r0, r3
 800c6a0:	f7ff fdc2 	bl	800c228 <HashSigner>
 800c6a4:	61b8      	str	r0, [r7, #24]
                    WOLFSSL_MSG("Renesas_RootCertVerify() succeed or skipped");
            }
        }
    #endif /* TSIP or SCE */

        if (ret == 0 && wc_LockMutex(&cm->caLock) == 0) {
 800c6a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c6a8:	2b00      	cmp	r3, #0
 800c6aa:	d126      	bne.n	800c6fa <AddCA+0x20a>
 800c6ac:	68fb      	ldr	r3, [r7, #12]
 800c6ae:	335c      	adds	r3, #92	@ 0x5c
 800c6b0:	4618      	mov	r0, r3
 800c6b2:	f01a fe7f 	bl	80273b4 <wc_LockMutex>
 800c6b6:	4603      	mov	r3, r0
 800c6b8:	2b00      	cmp	r3, #0
 800c6ba:	d11e      	bne.n	800c6fa <AddCA+0x20a>
            signer->next = cm->caTable[row];
 800c6bc:	68fb      	ldr	r3, [r7, #12]
 800c6be:	69ba      	ldr	r2, [r7, #24]
 800c6c0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c6c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c6c6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
            cm->caTable[row] = signer;   /* takes ownership */
 800c6ca:	68fb      	ldr	r3, [r7, #12]
 800c6cc:	69ba      	ldr	r2, [r7, #24]
 800c6ce:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800c6d0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            wc_UnLockMutex(&cm->caLock);
 800c6d4:	68fb      	ldr	r3, [r7, #12]
 800c6d6:	335c      	adds	r3, #92	@ 0x5c
 800c6d8:	4618      	mov	r0, r3
 800c6da:	f01a fe76 	bl	80273ca <wc_UnLockMutex>
            if (cm->caCacheCallback)
 800c6de:	68fb      	ldr	r3, [r7, #12]
 800c6e0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800c6e2:	2b00      	cmp	r3, #0
 800c6e4:	d00c      	beq.n	800c700 <AddCA+0x210>
                cm->caCacheCallback(der->buffer, (int)der->length, type);
 800c6e6:	68fb      	ldr	r3, [r7, #12]
 800c6e8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800c6ea:	6a3a      	ldr	r2, [r7, #32]
 800c6ec:	6810      	ldr	r0, [r2, #0]
 800c6ee:	6a3a      	ldr	r2, [r7, #32]
 800c6f0:	6892      	ldr	r2, [r2, #8]
 800c6f2:	4611      	mov	r1, r2
 800c6f4:	687a      	ldr	r2, [r7, #4]
 800c6f6:	4798      	blx	r3
            if (cm->caCacheCallback)
 800c6f8:	e002      	b.n	800c700 <AddCA+0x210>
        }
        else {
            WOLFSSL_MSG("\tCA Mutex Lock failed");
            ret = BAD_MUTEX_E;
 800c6fa:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c6fe:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }
    }

    WOLFSSL_MSG("\tFreeing Parsed CA");
    FreeDecodedCert(cert);
 800c700:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800c702:	f008 fdcd 	bl	80152a0 <FreeDecodedCert>
    if (ret != 0 && signer != NULL)
 800c706:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c708:	2b00      	cmp	r3, #0
 800c70a:	d008      	beq.n	800c71e <AddCA+0x22e>
 800c70c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c70e:	2b00      	cmp	r3, #0
 800c710:	d005      	beq.n	800c71e <AddCA+0x22e>
        FreeSigner(signer, cm->heap);
 800c712:	68fb      	ldr	r3, [r7, #12]
 800c714:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c716:	4619      	mov	r1, r3
 800c718:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c71a:	f00c faf8 	bl	8018d0e <FreeSigner>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(cert, NULL, DYNAMIC_TYPE_DCERT);
 800c71e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c720:	617b      	str	r3, [r7, #20]
 800c722:	697b      	ldr	r3, [r7, #20]
 800c724:	2b00      	cmp	r3, #0
 800c726:	d002      	beq.n	800c72e <AddCA+0x23e>
 800c728:	6978      	ldr	r0, [r7, #20]
 800c72a:	f012 f9cf 	bl	801eacc <wolfSSL_Free>
#endif
    WOLFSSL_MSG("\tFreeing der CA");
    FreeDer(pDer);
 800c72e:	68b8      	ldr	r0, [r7, #8]
 800c730:	f00c fc2a 	bl	8018f88 <FreeDer>
    WOLFSSL_MSG("\t\tOK Freeing der CA");

    WOLFSSL_LEAVE("AddCA", ret);

    return ret == 0 ? WOLFSSL_SUCCESS : ret;
 800c734:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c736:	2b00      	cmp	r3, #0
 800c738:	d001      	beq.n	800c73e <AddCA+0x24e>
 800c73a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c73c:	e000      	b.n	800c740 <AddCA+0x250>
 800c73e:	2301      	movs	r3, #1
}
 800c740:	4618      	mov	r0, r3
 800c742:	3730      	adds	r7, #48	@ 0x30
 800c744:	46bd      	mov	sp, r7
 800c746:	bd80      	pop	{r7, pc}
 800c748:	fffffe66 	.word	0xfffffe66

0800c74c <wolfSSL_Init>:
}
#endif

WOLFSSL_ABI
int wolfSSL_Init(void)
{
 800c74c:	b580      	push	{r7, lr}
 800c74e:	b082      	sub	sp, #8
 800c750:	af00      	add	r7, sp, #0
    int ret = WOLFSSL_SUCCESS;
 800c752:	2301      	movs	r3, #1
 800c754:	607b      	str	r3, [r7, #4]
#endif

    WOLFSSL_ENTER("wolfSSL_Init");

#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (inits_count_mutex_valid == 0) {
 800c756:	4b34      	ldr	r3, [pc, #208]	@ (800c828 <wolfSSL_Init+0xdc>)
 800c758:	681b      	ldr	r3, [r3, #0]
 800c75a:	2b00      	cmp	r3, #0
 800c75c:	d10b      	bne.n	800c776 <wolfSSL_Init+0x2a>
            (void)wolfSSL_Atomic_Int_FetchSub(
                &inits_count_mutex_atomic_initing_flag, 1);
            return DEADLOCK_AVERTED_E;
        }
    #endif /* WOLFSSL_CLEANUP_THREADSAFE_BY_ATOMIC_OPS */
        if (wc_InitMutex(&inits_count_mutex) != 0) {
 800c75e:	4833      	ldr	r0, [pc, #204]	@ (800c82c <wolfSSL_Init+0xe0>)
 800c760:	f01a fe12 	bl	8027388 <wc_InitMutex>
 800c764:	4603      	mov	r3, r0
 800c766:	2b00      	cmp	r3, #0
 800c768:	d002      	beq.n	800c770 <wolfSSL_Init+0x24>
            WOLFSSL_MSG("Bad Init Mutex count");
    #if WOLFSSL_CLEANUP_THREADSAFE_BY_ATOMIC_OPS
            (void)wolfSSL_Atomic_Int_FetchSub(
                &inits_count_mutex_atomic_initing_flag, 1);
    #endif
            return BAD_MUTEX_E;
 800c76a:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c76e:	e057      	b.n	800c820 <wolfSSL_Init+0xd4>
        }
        else {
            inits_count_mutex_valid = 1;
 800c770:	4b2d      	ldr	r3, [pc, #180]	@ (800c828 <wolfSSL_Init+0xdc>)
 800c772:	2201      	movs	r2, #1
 800c774:	601a      	str	r2, [r3, #0]
        }
    }
#endif /* !WOLFSSL_MUTEX_INITIALIZER */

    if (wc_LockMutex(&inits_count_mutex) != 0) {
 800c776:	482d      	ldr	r0, [pc, #180]	@ (800c82c <wolfSSL_Init+0xe0>)
 800c778:	f01a fe1c 	bl	80273b4 <wc_LockMutex>
 800c77c:	4603      	mov	r3, r0
 800c77e:	2b00      	cmp	r3, #0
 800c780:	d002      	beq.n	800c788 <wolfSSL_Init+0x3c>
        WOLFSSL_MSG("Bad Lock Mutex count");
        return BAD_MUTEX_E;
 800c782:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c786:	e04b      	b.n	800c820 <wolfSSL_Init+0xd4>
        if (ret == 0)
            ret = WOLFSSL_SUCCESS;
    }
#endif

    if ((ret == WOLFSSL_SUCCESS) && (initRefCount == 0)) {
 800c788:	687b      	ldr	r3, [r7, #4]
 800c78a:	2b01      	cmp	r3, #1
 800c78c:	d133      	bne.n	800c7f6 <wolfSSL_Init+0xaa>
 800c78e:	4b28      	ldr	r3, [pc, #160]	@ (800c830 <wolfSSL_Init+0xe4>)
 800c790:	681b      	ldr	r3, [r3, #0]
 800c792:	2b00      	cmp	r3, #0
 800c794:	d12f      	bne.n	800c7f6 <wolfSSL_Init+0xaa>
        /* Initialize crypto for use with TLS connection */

        if (wolfCrypt_Init() != 0) {
 800c796:	f01a fd6b 	bl	8027270 <wolfCrypt_Init>
 800c79a:	4603      	mov	r3, r0
 800c79c:	2b00      	cmp	r3, #0
 800c79e:	d002      	beq.n	800c7a6 <wolfSSL_Init+0x5a>
            WOLFSSL_MSG("Bad wolfCrypt Init");
            ret = WC_INIT_E;
 800c7a0:	f06f 03e3 	mvn.w	r3, #227	@ 0xe3
 800c7a4:	607b      	str	r3, [r7, #4]
        }

#if defined(HAVE_GLOBAL_RNG) && !defined(WOLFSSL_MUTEX_INITIALIZER)
        if (ret == WOLFSSL_SUCCESS) {
 800c7a6:	687b      	ldr	r3, [r7, #4]
 800c7a8:	2b01      	cmp	r3, #1
 800c7aa:	d10c      	bne.n	800c7c6 <wolfSSL_Init+0x7a>
            if (wc_InitMutex(&globalRNGMutex) != 0) {
 800c7ac:	4821      	ldr	r0, [pc, #132]	@ (800c834 <wolfSSL_Init+0xe8>)
 800c7ae:	f01a fdeb 	bl	8027388 <wc_InitMutex>
 800c7b2:	4603      	mov	r3, r0
 800c7b4:	2b00      	cmp	r3, #0
 800c7b6:	d003      	beq.n	800c7c0 <wolfSSL_Init+0x74>
                WOLFSSL_MSG("Bad Init Mutex rng");
                ret = BAD_MUTEX_E;
 800c7b8:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c7bc:	607b      	str	r3, [r7, #4]
 800c7be:	e002      	b.n	800c7c6 <wolfSSL_Init+0x7a>
            }
            else {
                globalRNGMutex_valid = 1;
 800c7c0:	4b1d      	ldr	r3, [pc, #116]	@ (800c838 <wolfSSL_Init+0xec>)
 800c7c2:	2201      	movs	r2, #1
 800c7c4:	601a      	str	r2, [r3, #0]
        wc_SetSeed_Cb(wc_GenerateSeed);
    #endif

#ifdef OPENSSL_EXTRA
    #ifndef WOLFSSL_NO_OPENSSL_RAND_CB
        if ((ret == WOLFSSL_SUCCESS) && (wolfSSL_RAND_InitMutex() != 0)) {
 800c7c6:	687b      	ldr	r3, [r7, #4]
 800c7c8:	2b01      	cmp	r3, #1
 800c7ca:	d107      	bne.n	800c7dc <wolfSSL_Init+0x90>
 800c7cc:	f002 faf0 	bl	800edb0 <wolfSSL_RAND_InitMutex>
 800c7d0:	4603      	mov	r3, r0
 800c7d2:	2b00      	cmp	r3, #0
 800c7d4:	d002      	beq.n	800c7dc <wolfSSL_Init+0x90>
            ret = BAD_MUTEX_E;
 800c7d6:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800c7da:	607b      	str	r3, [r7, #4]
        }
    #endif
        if ((ret == WOLFSSL_SUCCESS) &&
 800c7dc:	687b      	ldr	r3, [r7, #4]
 800c7de:	2b01      	cmp	r3, #1
 800c7e0:	d109      	bne.n	800c7f6 <wolfSSL_Init+0xaa>
            (wolfSSL_RAND_seed(NULL, 0) != WOLFSSL_SUCCESS)) {
 800c7e2:	2100      	movs	r1, #0
 800c7e4:	2000      	movs	r0, #0
 800c7e6:	f002 fb29 	bl	800ee3c <wolfSSL_RAND_seed>
 800c7ea:	4603      	mov	r3, r0
        if ((ret == WOLFSSL_SUCCESS) &&
 800c7ec:	2b01      	cmp	r3, #1
 800c7ee:	d002      	beq.n	800c7f6 <wolfSSL_Init+0xaa>
            WOLFSSL_MSG("wolfSSL_RAND_seed failed");
            ret = WC_INIT_E;
 800c7f0:	f06f 03e3 	mvn.w	r3, #227	@ 0xe3
 800c7f4:	607b      	str	r3, [r7, #4]
#if defined(WOLFSSL_SYS_CRYPTO_POLICY)
    /* System wide crypto policy disabled by default. */
    XMEMSET(&crypto_policy, 0, sizeof(crypto_policy));
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

    if (ret == WOLFSSL_SUCCESS) {
 800c7f6:	687b      	ldr	r3, [r7, #4]
 800c7f8:	2b01      	cmp	r3, #1
 800c7fa:	d105      	bne.n	800c808 <wolfSSL_Init+0xbc>
        initRefCount++;
 800c7fc:	4b0c      	ldr	r3, [pc, #48]	@ (800c830 <wolfSSL_Init+0xe4>)
 800c7fe:	681b      	ldr	r3, [r3, #0]
 800c800:	3301      	adds	r3, #1
 800c802:	4a0b      	ldr	r2, [pc, #44]	@ (800c830 <wolfSSL_Init+0xe4>)
 800c804:	6013      	str	r3, [r2, #0]
 800c806:	e002      	b.n	800c80e <wolfSSL_Init+0xc2>
    }
    else {
        initRefCount = 1; /* Force cleanup */
 800c808:	4b09      	ldr	r3, [pc, #36]	@ (800c830 <wolfSSL_Init+0xe4>)
 800c80a:	2201      	movs	r2, #1
 800c80c:	601a      	str	r2, [r3, #0]
    }

    wc_UnLockMutex(&inits_count_mutex);
 800c80e:	4807      	ldr	r0, [pc, #28]	@ (800c82c <wolfSSL_Init+0xe0>)
 800c810:	f01a fddb 	bl	80273ca <wc_UnLockMutex>

    if (ret != WOLFSSL_SUCCESS) {
 800c814:	687b      	ldr	r3, [r7, #4]
 800c816:	2b01      	cmp	r3, #1
 800c818:	d001      	beq.n	800c81e <wolfSSL_Init+0xd2>
        (void)wolfSSL_Cleanup(); /* Ignore any error from cleanup */
 800c81a:	f001 f8a9 	bl	800d970 <wolfSSL_Cleanup>
    }

    return ret;
 800c81e:	687b      	ldr	r3, [r7, #4]
}
 800c820:	4618      	mov	r0, r3
 800c822:	3708      	adds	r7, #8
 800c824:	46bd      	mov	sp, r7
 800c826:	bd80      	pop	{r7, pc}
 800c828:	200026ec 	.word	0x200026ec
 800c82c:	200026e8 	.word	0x200026e8
 800c830:	200026e4 	.word	0x200026e4
 800c834:	200026c8 	.word	0x200026c8
 800c838:	200026cc 	.word	0x200026cc

0800c83c <DataToDerBuffer>:
 * @return  ASN_PARSE_E when format is ASN.1 and invalid DER encoding.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int DataToDerBuffer(const unsigned char* buff, word32 len, int format,
    int type, EncryptedInfo* info, void* heap, DerBuffer** der, int* algId)
{
 800c83c:	b580      	push	{r7, lr}
 800c83e:	b08a      	sub	sp, #40	@ 0x28
 800c840:	af04      	add	r7, sp, #16
 800c842:	60f8      	str	r0, [r7, #12]
 800c844:	60b9      	str	r1, [r7, #8]
 800c846:	607a      	str	r2, [r7, #4]
 800c848:	603b      	str	r3, [r7, #0]
    int ret;

    info->consumed = 0;
 800c84a:	6a3b      	ldr	r3, [r7, #32]
 800c84c:	2200      	movs	r2, #0
 800c84e:	601a      	str	r2, [r3, #0]

    /* Data in buffer has PEM format - extract DER data. */
    if (format == WOLFSSL_FILETYPE_PEM) {
 800c850:	687b      	ldr	r3, [r7, #4]
 800c852:	2b01      	cmp	r3, #1
 800c854:	d113      	bne.n	800c87e <DataToDerBuffer+0x42>
    #ifdef WOLFSSL_PEM_TO_DER
        ret = PemToDer(buff, len, type, der, heap, info, algId);
 800c856:	68b9      	ldr	r1, [r7, #8]
 800c858:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c85a:	9302      	str	r3, [sp, #8]
 800c85c:	6a3b      	ldr	r3, [r7, #32]
 800c85e:	9301      	str	r3, [sp, #4]
 800c860:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c862:	9300      	str	r3, [sp, #0]
 800c864:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c866:	683a      	ldr	r2, [r7, #0]
 800c868:	68f8      	ldr	r0, [r7, #12]
 800c86a:	f00c fead 	bl	80195c8 <PemToDer>
 800c86e:	6178      	str	r0, [r7, #20]
        if (ret != 0) {
 800c870:	697b      	ldr	r3, [r7, #20]
 800c872:	2b00      	cmp	r3, #0
 800c874:	d02b      	beq.n	800c8ce <DataToDerBuffer+0x92>
            FreeDer(der);
 800c876:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c878:	f00c fb86 	bl	8018f88 <FreeDer>
 800c87c:	e027      	b.n	800c8ce <DataToDerBuffer+0x92>
    #endif
    }
    /* Data in buffer is ASN.1 format - get first SEQ or OCT into der. */
    else {
        /* Get length of SEQ including header. */
        if ((info->consumed = wolfssl_der_length(buff, (int)len)) > 0) {
 800c87e:	68bb      	ldr	r3, [r7, #8]
 800c880:	4619      	mov	r1, r3
 800c882:	68f8      	ldr	r0, [r7, #12]
 800c884:	f7ff fa52 	bl	800bd2c <wolfssl_der_length>
 800c888:	4602      	mov	r2, r0
 800c88a:	6a3b      	ldr	r3, [r7, #32]
 800c88c:	601a      	str	r2, [r3, #0]
 800c88e:	6a3b      	ldr	r3, [r7, #32]
 800c890:	681b      	ldr	r3, [r3, #0]
 800c892:	2b00      	cmp	r3, #0
 800c894:	dd02      	ble.n	800c89c <DataToDerBuffer+0x60>
            ret = 0;
 800c896:	2300      	movs	r3, #0
 800c898:	617b      	str	r3, [r7, #20]
 800c89a:	e002      	b.n	800c8a2 <DataToDerBuffer+0x66>
        }
        else {
            ret = ASN_PARSE_E;
 800c89c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 800c8a0:	617b      	str	r3, [r7, #20]
        }

        if (info->consumed > (int)len) {
 800c8a2:	6a3b      	ldr	r3, [r7, #32]
 800c8a4:	681a      	ldr	r2, [r3, #0]
 800c8a6:	68bb      	ldr	r3, [r7, #8]
 800c8a8:	429a      	cmp	r2, r3
 800c8aa:	dd02      	ble.n	800c8b2 <DataToDerBuffer+0x76>
            ret = ASN_PARSE_E;
 800c8ac:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 800c8b0:	617b      	str	r3, [r7, #20]
        }
        if (ret == 0) {
 800c8b2:	697b      	ldr	r3, [r7, #20]
 800c8b4:	2b00      	cmp	r3, #0
 800c8b6:	d10a      	bne.n	800c8ce <DataToDerBuffer+0x92>
            ret = AllocCopyDer(der, buff, (word32)info->consumed, type, heap);
 800c8b8:	6a3b      	ldr	r3, [r7, #32]
 800c8ba:	681b      	ldr	r3, [r3, #0]
 800c8bc:	461a      	mov	r2, r3
 800c8be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c8c0:	9300      	str	r3, [sp, #0]
 800c8c2:	683b      	ldr	r3, [r7, #0]
 800c8c4:	68f9      	ldr	r1, [r7, #12]
 800c8c6:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800c8c8:	f00c fb40 	bl	8018f4c <AllocCopyDer>
 800c8cc:	6178      	str	r0, [r7, #20]
        }
    }

    return ret;
 800c8ce:	697b      	ldr	r3, [r7, #20]
}
 800c8d0:	4618      	mov	r0, r3
 800c8d2:	3718      	adds	r7, #24
 800c8d4:	46bd      	mov	sp, r7
 800c8d6:	bd80      	pop	{r7, pc}

0800c8d8 <ProcessUserCert>:
 * @return  0 on success.
 * @return  BUFFER_E if chain buffer not big enough to hold certificate.
 */
static int ProcessUserCert(WOLFSSL_CERT_MANAGER* cm, DerBuffer** pDer,
    int type, int verify, byte* chainBuffer, word32* pIdx, word32 bufferSz)
{
 800c8d8:	b580      	push	{r7, lr}
 800c8da:	b088      	sub	sp, #32
 800c8dc:	af00      	add	r7, sp, #0
 800c8de:	60f8      	str	r0, [r7, #12]
 800c8e0:	60b9      	str	r1, [r7, #8]
 800c8e2:	607a      	str	r2, [r7, #4]
 800c8e4:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800c8e6:	2300      	movs	r3, #0
 800c8e8:	61fb      	str	r3, [r7, #28]
    word32 idx = *pIdx;
 800c8ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c8ec:	681b      	ldr	r3, [r3, #0]
 800c8ee:	61bb      	str	r3, [r7, #24]
    DerBuffer* der = *pDer;
 800c8f0:	68bb      	ldr	r3, [r7, #8]
 800c8f2:	681b      	ldr	r3, [r3, #0]
 800c8f4:	617b      	str	r3, [r7, #20]

    /* Check there is space for certificate in chainBuffer. */
    if ((ret == 0) && ((idx + der->length + CERT_HEADER_SZ) > bufferSz)) {
 800c8f6:	69fb      	ldr	r3, [r7, #28]
 800c8f8:	2b00      	cmp	r3, #0
 800c8fa:	d10a      	bne.n	800c912 <ProcessUserCert+0x3a>
 800c8fc:	697b      	ldr	r3, [r7, #20]
 800c8fe:	689a      	ldr	r2, [r3, #8]
 800c900:	69bb      	ldr	r3, [r7, #24]
 800c902:	4413      	add	r3, r2
 800c904:	3303      	adds	r3, #3
 800c906:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800c908:	429a      	cmp	r2, r3
 800c90a:	d202      	bcs.n	800c912 <ProcessUserCert+0x3a>
        WOLFSSL_MSG("   Cert Chain bigger than buffer. "
                    "Consider increasing MAX_CHAIN_DEPTH");
        ret = BUFFER_E;
 800c90c:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 800c910:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 800c912:	69fb      	ldr	r3, [r7, #28]
 800c914:	2b00      	cmp	r3, #0
 800c916:	d128      	bne.n	800c96a <ProcessUserCert+0x92>
        /* 3-byte length. */
        c32to24(der->length, &chainBuffer[idx]);
 800c918:	697b      	ldr	r3, [r7, #20]
 800c91a:	6898      	ldr	r0, [r3, #8]
 800c91c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800c91e:	69bb      	ldr	r3, [r7, #24]
 800c920:	4413      	add	r3, r2
 800c922:	4619      	mov	r1, r3
 800c924:	f7fe fc32 	bl	800b18c <c32to24>
        idx += CERT_HEADER_SZ;
 800c928:	69bb      	ldr	r3, [r7, #24]
 800c92a:	3303      	adds	r3, #3
 800c92c:	61bb      	str	r3, [r7, #24]
        /* Add complete DER encoded certificate. */
        XMEMCPY(&chainBuffer[idx], der->buffer, der->length);
 800c92e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800c930:	69bb      	ldr	r3, [r7, #24]
 800c932:	18d0      	adds	r0, r2, r3
 800c934:	697b      	ldr	r3, [r7, #20]
 800c936:	6819      	ldr	r1, [r3, #0]
 800c938:	697b      	ldr	r3, [r7, #20]
 800c93a:	689b      	ldr	r3, [r3, #8]
 800c93c:	461a      	mov	r2, r3
 800c93e:	f01b fe31 	bl	80285a4 <memcpy>
        idx += der->length;
 800c942:	697b      	ldr	r3, [r7, #20]
 800c944:	689b      	ldr	r3, [r3, #8]
 800c946:	69ba      	ldr	r2, [r7, #24]
 800c948:	4413      	add	r3, r2
 800c94a:	61bb      	str	r3, [r7, #24]

        if (type == CA_TYPE) {
 800c94c:	687b      	ldr	r3, [r7, #4]
 800c94e:	2b06      	cmp	r3, #6
 800c950:	d10b      	bne.n	800c96a <ProcessUserCert+0x92>
            /* Add CA to certificate manager */
            ret = AddCA(cm, pDer, WOLFSSL_USER_CA, verify);
 800c952:	683b      	ldr	r3, [r7, #0]
 800c954:	2201      	movs	r2, #1
 800c956:	68b9      	ldr	r1, [r7, #8]
 800c958:	68f8      	ldr	r0, [r7, #12]
 800c95a:	f7ff fdc9 	bl	800c4f0 <AddCA>
 800c95e:	61f8      	str	r0, [r7, #28]
            if (ret == 1) {
 800c960:	69fb      	ldr	r3, [r7, #28]
 800c962:	2b01      	cmp	r3, #1
 800c964:	d101      	bne.n	800c96a <ProcessUserCert+0x92>
                ret = 0;
 800c966:	2300      	movs	r3, #0
 800c968:	61fb      	str	r3, [r7, #28]
            }
        }
    }

    /* Update the index into chainBuffer. */
    *pIdx = idx;
 800c96a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c96c:	69ba      	ldr	r2, [r7, #24]
 800c96e:	601a      	str	r2, [r3, #0]
    return ret;
 800c970:	69fb      	ldr	r3, [r7, #28]
}
 800c972:	4618      	mov	r0, r3
 800c974:	3720      	adds	r7, #32
 800c976:	46bd      	mov	sp, r7
 800c978:	bd80      	pop	{r7, pc}

0800c97a <ProcessUserChainRetain>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int ProcessUserChainRetain(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const byte* chainBuffer, word32 len, int cnt, int type, void* heap)
{
 800c97a:	b580      	push	{r7, lr}
 800c97c:	b088      	sub	sp, #32
 800c97e:	af02      	add	r7, sp, #8
 800c980:	60f8      	str	r0, [r7, #12]
 800c982:	60b9      	str	r1, [r7, #8]
 800c984:	607a      	str	r2, [r7, #4]
 800c986:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800c988:	2300      	movs	r3, #0
 800c98a:	617b      	str	r3, [r7, #20]

    (void)cnt;

    /* Store in SSL object if available. */
    if (ssl != NULL) {
 800c98c:	68bb      	ldr	r3, [r7, #8]
 800c98e:	2b00      	cmp	r3, #0
 800c990:	d024      	beq.n	800c9dc <ProcessUserChainRetain+0x62>
        /* Dispose of old chain if not reference to context's. */
        if (ssl->buffers.weOwnCertChain) {
 800c992:	68bb      	ldr	r3, [r7, #8]
 800c994:	f893 3145 	ldrb.w	r3, [r3, #325]	@ 0x145
 800c998:	2b00      	cmp	r3, #0
 800c99a:	d005      	beq.n	800c9a8 <ProcessUserChainRetain+0x2e>
            FreeDer(&ssl->buffers.certChain);
 800c99c:	68bb      	ldr	r3, [r7, #8]
 800c99e:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 800c9a2:	4618      	mov	r0, r3
 800c9a4:	f00c faf0 	bl	8018f88 <FreeDer>
        }
        /* Allocate and copy the buffer into SSL object. */
        ret = AllocCopyDer(&ssl->buffers.certChain, chainBuffer, len, type,
 800c9a8:	68bb      	ldr	r3, [r7, #8]
 800c9aa:	f503 70c0 	add.w	r0, r3, #384	@ 0x180
 800c9ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c9b0:	9300      	str	r3, [sp, #0]
 800c9b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c9b4:	683a      	ldr	r2, [r7, #0]
 800c9b6:	6879      	ldr	r1, [r7, #4]
 800c9b8:	f00c fac8 	bl	8018f4c <AllocCopyDer>
 800c9bc:	6178      	str	r0, [r7, #20]
            heap);
        ssl->buffers.weOwnCertChain = (ret == 0);
 800c9be:	697b      	ldr	r3, [r7, #20]
 800c9c0:	2b00      	cmp	r3, #0
 800c9c2:	bf0c      	ite	eq
 800c9c4:	2301      	moveq	r3, #1
 800c9c6:	2300      	movne	r3, #0
 800c9c8:	b2db      	uxtb	r3, r3
 800c9ca:	461a      	mov	r2, r3
 800c9cc:	68bb      	ldr	r3, [r7, #8]
 800c9ce:	f883 2145 	strb.w	r2, [r3, #325]	@ 0x145
    #ifdef WOLFSSL_TLS13
        /* Update count of certificates in chain. */
        ssl->buffers.certChainCnt = cnt;
 800c9d2:	68bb      	ldr	r3, [r7, #8]
 800c9d4:	6a3a      	ldr	r2, [r7, #32]
 800c9d6:	f8c3 2184 	str.w	r2, [r3, #388]	@ 0x184
 800c9da:	e015      	b.n	800ca08 <ProcessUserChainRetain+0x8e>
    #endif
    }
    /* Store in SSL context object if available. */
    else if (ctx != NULL) {
 800c9dc:	68fb      	ldr	r3, [r7, #12]
 800c9de:	2b00      	cmp	r3, #0
 800c9e0:	d012      	beq.n	800ca08 <ProcessUserChainRetain+0x8e>
        /* Dispose of old chain and allocate and copy in new chain. */
        FreeDer(&ctx->certChain);
 800c9e2:	68fb      	ldr	r3, [r7, #12]
 800c9e4:	3324      	adds	r3, #36	@ 0x24
 800c9e6:	4618      	mov	r0, r3
 800c9e8:	f00c face 	bl	8018f88 <FreeDer>
        /* Allocate and copy the buffer into SSL context object. */
        ret = AllocCopyDer(&ctx->certChain, chainBuffer, len, type, heap);
 800c9ec:	68fb      	ldr	r3, [r7, #12]
 800c9ee:	f103 0024 	add.w	r0, r3, #36	@ 0x24
 800c9f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c9f4:	9300      	str	r3, [sp, #0]
 800c9f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c9f8:	683a      	ldr	r2, [r7, #0]
 800c9fa:	6879      	ldr	r1, [r7, #4]
 800c9fc:	f00c faa6 	bl	8018f4c <AllocCopyDer>
 800ca00:	6178      	str	r0, [r7, #20]
    #ifdef WOLFSSL_TLS13
        /* Update count of certificates in chain. */
        ctx->certChainCnt = cnt;
 800ca02:	68fb      	ldr	r3, [r7, #12]
 800ca04:	6a3a      	ldr	r2, [r7, #32]
 800ca06:	63da      	str	r2, [r3, #60]	@ 0x3c
    #endif
    }

    return ret;
 800ca08:	697b      	ldr	r3, [r7, #20]
}
 800ca0a:	4618      	mov	r0, r3
 800ca0c:	3718      	adds	r7, #24
 800ca0e:	46bd      	mov	sp, r7
 800ca10:	bd80      	pop	{r7, pc}

0800ca12 <ProcessUserChain>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int ProcessUserChain(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const unsigned char* buff, long sz, int format, int type, long* used,
    EncryptedInfo* info, int verify)
{
 800ca12:	b580      	push	{r7, lr}
 800ca14:	b092      	sub	sp, #72	@ 0x48
 800ca16:	af04      	add	r7, sp, #16
 800ca18:	60f8      	str	r0, [r7, #12]
 800ca1a:	60b9      	str	r1, [r7, #8]
 800ca1c:	607a      	str	r2, [r7, #4]
 800ca1e:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800ca20:	2300      	movs	r3, #0
 800ca22:	637b      	str	r3, [r7, #52]	@ 0x34
    void* heap = WOLFSSL_HEAP(ctx, ssl);
 800ca24:	68fb      	ldr	r3, [r7, #12]
 800ca26:	2b00      	cmp	r3, #0
 800ca28:	d002      	beq.n	800ca30 <ProcessUserChain+0x1e>
 800ca2a:	68fb      	ldr	r3, [r7, #12]
 800ca2c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800ca2e:	e007      	b.n	800ca40 <ProcessUserChain+0x2e>
 800ca30:	68bb      	ldr	r3, [r7, #8]
 800ca32:	2b00      	cmp	r3, #0
 800ca34:	d003      	beq.n	800ca3e <ProcessUserChain+0x2c>
 800ca36:	68bb      	ldr	r3, [r7, #8]
 800ca38:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800ca3c:	e000      	b.n	800ca40 <ProcessUserChain+0x2e>
 800ca3e:	2300      	movs	r3, #0
 800ca40:	627b      	str	r3, [r7, #36]	@ 0x24

    WOLFSSL_ENTER("ProcessUserChain");

    /* Check we haven't consumed all the data. */
    if (info->consumed >= sz) {
 800ca42:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ca44:	681b      	ldr	r3, [r3, #0]
 800ca46:	683a      	ldr	r2, [r7, #0]
 800ca48:	429a      	cmp	r2, r3
 800ca4a:	f340 8092 	ble.w	800cb72 <ProcessUserChain+0x160>
    else {
    #ifndef WOLFSSL_SMALL_STACK
        byte stackBuffer[FILE_BUFFER_SIZE];
    #endif
        StaticBuffer chain;
        long   consumed = info->consumed;
 800ca4e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ca50:	681b      	ldr	r3, [r3, #0]
 800ca52:	633b      	str	r3, [r7, #48]	@ 0x30
        word32 idx = 0;
 800ca54:	2300      	movs	r3, #0
 800ca56:	617b      	str	r3, [r7, #20]
        int    gotOne = 0;
 800ca58:	2300      	movs	r3, #0
 800ca5a:	62fb      	str	r3, [r7, #44]	@ 0x2c
        int    cnt = 0;
 800ca5c:	2300      	movs	r3, #0
 800ca5e:	62bb      	str	r3, [r7, #40]	@ 0x28
        /* Calculate max possible size, including max headers */
        long   maxSz = (sz - consumed) + (CERT_HEADER_SZ * MAX_CHAIN_DEPTH);
 800ca60:	683a      	ldr	r2, [r7, #0]
 800ca62:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ca64:	1ad3      	subs	r3, r2, r3
 800ca66:	331b      	adds	r3, #27
 800ca68:	623b      	str	r3, [r7, #32]

        /* Setup buffer to hold chain. */
    #ifdef WOLFSSL_SMALL_STACK
        static_buffer_init(&chain);
 800ca6a:	f107 0318 	add.w	r3, r7, #24
 800ca6e:	4618      	mov	r0, r3
 800ca70:	f7fe fbc2 	bl	800b1f8 <static_buffer_init>
    #else
        static_buffer_init(&chain, stackBuffer, FILE_BUFFER_SIZE);
    #endif
        /* Make buffer big enough to support maximum size. */
        ret = static_buffer_set_size(&chain, (word32)maxSz, heap,
 800ca74:	6a39      	ldr	r1, [r7, #32]
 800ca76:	f107 0018 	add.w	r0, r7, #24
 800ca7a:	2304      	movs	r3, #4
 800ca7c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ca7e:	f7fe fbcb 	bl	800b218 <static_buffer_set_size>
 800ca82:	6378      	str	r0, [r7, #52]	@ 0x34
            DYNAMIC_TYPE_FILE);

        WOLFSSL_MSG("Processing Cert Chain");
        /* Keep parsing certificates will data available. */
        while ((ret == 0) && (consumed < sz)) {
 800ca84:	e04d      	b.n	800cb22 <ProcessUserChain+0x110>
            DerBuffer* part = NULL;
 800ca86:	2300      	movs	r3, #0
 800ca88:	613b      	str	r3, [r7, #16]

            /* Get a certificate as DER. */
            ret = DataToDerBuffer(buff + consumed, (word32)(sz - consumed),
 800ca8a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ca8c:	687a      	ldr	r2, [r7, #4]
 800ca8e:	18d0      	adds	r0, r2, r3
 800ca90:	683a      	ldr	r2, [r7, #0]
 800ca92:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ca94:	1ad3      	subs	r3, r2, r3
 800ca96:	4619      	mov	r1, r3
 800ca98:	2300      	movs	r3, #0
 800ca9a:	9303      	str	r3, [sp, #12]
 800ca9c:	f107 0310 	add.w	r3, r7, #16
 800caa0:	9302      	str	r3, [sp, #8]
 800caa2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800caa4:	9301      	str	r3, [sp, #4]
 800caa6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800caa8:	9300      	str	r3, [sp, #0]
 800caaa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800caac:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800caae:	f7ff fec5 	bl	800c83c <DataToDerBuffer>
 800cab2:	6378      	str	r0, [r7, #52]	@ 0x34
                format, type, info, heap, &part, NULL);
            if (ret == 0) {
 800cab4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cab6:	2b00      	cmp	r3, #0
 800cab8:	d10f      	bne.n	800cada <ProcessUserChain+0xc8>
                /* Process the user certificate. */
                ret = ProcessUserCert(ctx->cm, &part, type, verify,
 800caba:	68fb      	ldr	r3, [r7, #12]
 800cabc:	6d18      	ldr	r0, [r3, #80]	@ 0x50
 800cabe:	69bb      	ldr	r3, [r7, #24]
 800cac0:	6a3a      	ldr	r2, [r7, #32]
 800cac2:	f107 0110 	add.w	r1, r7, #16
 800cac6:	9202      	str	r2, [sp, #8]
 800cac8:	f107 0214 	add.w	r2, r7, #20
 800cacc:	9201      	str	r2, [sp, #4]
 800cace:	9300      	str	r3, [sp, #0]
 800cad0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800cad2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800cad4:	f7ff ff00 	bl	800c8d8 <ProcessUserCert>
 800cad8:	6378      	str	r0, [r7, #52]	@ 0x34
                   chain.buffer, &idx, (word32)maxSz);
            }
            /* PEM may have trailing data that can be ignored. */
            if ((ret == WC_NO_ERR_TRACE(ASN_NO_PEM_HEADER)) && gotOne) {
 800cada:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cadc:	f113 0fa2 	cmn.w	r3, #162	@ 0xa2
 800cae0:	d105      	bne.n	800caee <ProcessUserChain+0xdc>
 800cae2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cae4:	2b00      	cmp	r3, #0
 800cae6:	d002      	beq.n	800caee <ProcessUserChain+0xdc>
                WOLFSSL_MSG("We got one good cert, so stuff at end ok");
                ret = 0;
 800cae8:	2300      	movs	r3, #0
 800caea:	637b      	str	r3, [r7, #52]	@ 0x34
 800caec:	e020      	b.n	800cb30 <ProcessUserChain+0x11e>
                break;
            }
            /* Certificate data handled. */
            FreeDer(&part);
 800caee:	f107 0310 	add.w	r3, r7, #16
 800caf2:	4618      	mov	r0, r3
 800caf4:	f00c fa48 	bl	8018f88 <FreeDer>

            if (ret == 0) {
 800caf8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cafa:	2b00      	cmp	r3, #0
 800cafc:	d111      	bne.n	800cb22 <ProcessUserChain+0x110>
                /* Update consumed length. */
                consumed += info->consumed;
 800cafe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800cb00:	681b      	ldr	r3, [r3, #0]
 800cb02:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800cb04:	4413      	add	r3, r2
 800cb06:	633b      	str	r3, [r7, #48]	@ 0x30
                WOLFSSL_MSG("   Consumed another Cert in Chain");
                /* Update whether we got a user certificate. */
                gotOne |= (type != CA_TYPE);
 800cb08:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800cb0a:	2b06      	cmp	r3, #6
 800cb0c:	bf14      	ite	ne
 800cb0e:	2301      	movne	r3, #1
 800cb10:	2300      	moveq	r3, #0
 800cb12:	b2db      	uxtb	r3, r3
 800cb14:	461a      	mov	r2, r3
 800cb16:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cb18:	4313      	orrs	r3, r2
 800cb1a:	62fb      	str	r3, [r7, #44]	@ 0x2c
                /* Update count of certificates added to chain. */
                cnt++;
 800cb1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cb1e:	3301      	adds	r3, #1
 800cb20:	62bb      	str	r3, [r7, #40]	@ 0x28
        while ((ret == 0) && (consumed < sz)) {
 800cb22:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cb24:	2b00      	cmp	r3, #0
 800cb26:	d103      	bne.n	800cb30 <ProcessUserChain+0x11e>
 800cb28:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800cb2a:	683b      	ldr	r3, [r7, #0]
 800cb2c:	429a      	cmp	r2, r3
 800cb2e:	dbaa      	blt.n	800ca86 <ProcessUserChain+0x74>
            }
        }
        if (used != NULL) {
 800cb30:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800cb32:	2b00      	cmp	r3, #0
 800cb34:	d002      	beq.n	800cb3c <ProcessUserChain+0x12a>
            /* Return the total consumed length. */
            *used = consumed;
 800cb36:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800cb38:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800cb3a:	601a      	str	r2, [r3, #0]
        }

        /* Check whether there is data in the chain buffer. */
        if ((ret == 0) && (idx > 0)) {
 800cb3c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800cb3e:	2b00      	cmp	r3, #0
 800cb40:	d110      	bne.n	800cb64 <ProcessUserChain+0x152>
 800cb42:	697b      	ldr	r3, [r7, #20]
 800cb44:	2b00      	cmp	r3, #0
 800cb46:	d00d      	beq.n	800cb64 <ProcessUserChain+0x152>
            /* Put the chain buffer against the SSL or SSL context object. */
            ret = ProcessUserChainRetain(ctx, ssl, chain.buffer, idx, cnt, type,
 800cb48:	69ba      	ldr	r2, [r7, #24]
 800cb4a:	6979      	ldr	r1, [r7, #20]
 800cb4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cb4e:	9302      	str	r3, [sp, #8]
 800cb50:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800cb52:	9301      	str	r3, [sp, #4]
 800cb54:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cb56:	9300      	str	r3, [sp, #0]
 800cb58:	460b      	mov	r3, r1
 800cb5a:	68b9      	ldr	r1, [r7, #8]
 800cb5c:	68f8      	ldr	r0, [r7, #12]
 800cb5e:	f7ff ff0c 	bl	800c97a <ProcessUserChainRetain>
 800cb62:	6378      	str	r0, [r7, #52]	@ 0x34
                heap);
        }

        /* Dispose of chain buffer. */
        static_buffer_free(&chain, heap, DYNAMIC_TYPE_FILE);
 800cb64:	f107 0318 	add.w	r3, r7, #24
 800cb68:	2204      	movs	r2, #4
 800cb6a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800cb6c:	4618      	mov	r0, r3
 800cb6e:	f7fe fb72 	bl	800b256 <static_buffer_free>
    }

    WOLFSSL_LEAVE("ProcessUserChain", ret);
    return ret;
 800cb72:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 800cb74:	4618      	mov	r0, r3
 800cb76:	3738      	adds	r7, #56	@ 0x38
 800cb78:	46bd      	mov	sp, r7
 800cb7a:	bd80      	pop	{r7, pc}

0800cb7c <ProcessBufferTryDecodeRsa>:
 * @return  0 on success or not an RSA key and format unknown.
 * @return  RSA_KEY_SIZE_E when key size doesn't meet minimum required.
 */
static int ProcessBufferTryDecodeRsa(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int* keyFormat, int devId, byte* keyType, int* keySize)
{
 800cb7c:	b580      	push	{r7, lr}
 800cb7e:	b088      	sub	sp, #32
 800cb80:	af00      	add	r7, sp, #0
 800cb82:	60f8      	str	r0, [r7, #12]
 800cb84:	60b9      	str	r1, [r7, #8]
 800cb86:	607a      	str	r2, [r7, #4]
 800cb88:	603b      	str	r3, [r7, #0]
    int ret;
    word32 idx;
    int keySz = 0;
 800cb8a:	2300      	movs	r3, #0
 800cb8c:	613b      	str	r3, [r7, #16]

    (void)devId;

    /* Validate we have an RSA private key and get key size. */
    idx = 0;
 800cb8e:	2300      	movs	r3, #0
 800cb90:	617b      	str	r3, [r7, #20]
    ret = wc_RsaPrivateKeyValidate(der->buffer, &idx, &keySz, der->length);
 800cb92:	687b      	ldr	r3, [r7, #4]
 800cb94:	6818      	ldr	r0, [r3, #0]
 800cb96:	687b      	ldr	r3, [r7, #4]
 800cb98:	689b      	ldr	r3, [r3, #8]
 800cb9a:	f107 0210 	add.w	r2, r7, #16
 800cb9e:	f107 0114 	add.w	r1, r7, #20
 800cba2:	f008 f84f 	bl	8014c44 <wc_RsaPrivateKeyValidate>
 800cba6:	61f8      	str	r0, [r7, #28]
        if (ret == 0) {
            keySz = (int)nSz;
        }
    }
#endif
    if (ret == 0) {
 800cba8:	69fb      	ldr	r3, [r7, #28]
 800cbaa:	2b00      	cmp	r3, #0
 800cbac:	d12e      	bne.n	800cc0c <ProcessBufferTryDecodeRsa+0x90>
        /* Get the minimum RSA key size from SSL or SSL context object. */
        int minRsaSz = ssl ? ssl->options.minRsaKeySz : ctx->minRsaKeySz;
 800cbae:	68bb      	ldr	r3, [r7, #8]
 800cbb0:	2b00      	cmp	r3, #0
 800cbb2:	d003      	beq.n	800cbbc <ProcessBufferTryDecodeRsa+0x40>
 800cbb4:	68bb      	ldr	r3, [r7, #8]
 800cbb6:	f9b3 32f4 	ldrsh.w	r3, [r3, #756]	@ 0x2f4
 800cbba:	e002      	b.n	800cbc2 <ProcessBufferTryDecodeRsa+0x46>
 800cbbc:	68fb      	ldr	r3, [r7, #12]
 800cbbe:	f9b3 3066 	ldrsh.w	r3, [r3, #102]	@ 0x66
 800cbc2:	61bb      	str	r3, [r7, #24]

        /* Format, type and size are known. */
        *keyFormat = RSAk;
 800cbc4:	683b      	ldr	r3, [r7, #0]
 800cbc6:	f240 2285 	movw	r2, #645	@ 0x285
 800cbca:	601a      	str	r2, [r3, #0]
        *keyType = rsa_sa_algo;
 800cbcc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cbce:	2201      	movs	r2, #1
 800cbd0:	701a      	strb	r2, [r3, #0]
        *keySize = keySz;
 800cbd2:	693a      	ldr	r2, [r7, #16]
 800cbd4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800cbd6:	601a      	str	r2, [r3, #0]

        /* Check that the size of the RSA key is enough. */
        if (keySz < minRsaSz) {
 800cbd8:	693b      	ldr	r3, [r7, #16]
 800cbda:	69ba      	ldr	r2, [r7, #24]
 800cbdc:	429a      	cmp	r2, r3
 800cbde:	dd02      	ble.n	800cbe6 <ProcessBufferTryDecodeRsa+0x6a>
            WOLFSSL_MSG("Private Key size too small");
            ret = RSA_KEY_SIZE_E;
 800cbe0:	f46f 73cc 	mvn.w	r3, #408	@ 0x198
 800cbe4:	61fb      	str	r3, [r7, #28]
        }
         /* No static ECC key possible. */
        if ((ssl != NULL) && (ssl->options.side == WOLFSSL_SERVER_END)) {
 800cbe6:	68bb      	ldr	r3, [r7, #8]
 800cbe8:	2b00      	cmp	r3, #0
 800cbea:	d015      	beq.n	800cc18 <ProcessBufferTryDecodeRsa+0x9c>
 800cbec:	68bb      	ldr	r3, [r7, #8]
 800cbee:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800cbf2:	f003 0303 	and.w	r3, r3, #3
 800cbf6:	b2db      	uxtb	r3, r3
 800cbf8:	2b00      	cmp	r3, #0
 800cbfa:	d10d      	bne.n	800cc18 <ProcessBufferTryDecodeRsa+0x9c>
             ssl->options.haveStaticECC = 0;
 800cbfc:	68ba      	ldr	r2, [r7, #8]
 800cbfe:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800cc02:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800cc06:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
 800cc0a:	e005      	b.n	800cc18 <ProcessBufferTryDecodeRsa+0x9c>
        }
    }
    /* Not an RSA key but check whether we know what it is. */
    else if (*keyFormat == 0) {
 800cc0c:	683b      	ldr	r3, [r7, #0]
 800cc0e:	681b      	ldr	r3, [r3, #0]
 800cc10:	2b00      	cmp	r3, #0
 800cc12:	d101      	bne.n	800cc18 <ProcessBufferTryDecodeRsa+0x9c>
        WOLFSSL_MSG("Not an RSA key");
        /* Format unknown so keep trying. */
        ret = 0;
 800cc14:	2300      	movs	r3, #0
 800cc16:	61fb      	str	r3, [r7, #28]
    }

    return ret;
 800cc18:	69fb      	ldr	r3, [r7, #28]
}
 800cc1a:	4618      	mov	r0, r3
 800cc1c:	3720      	adds	r7, #32
 800cc1e:	46bd      	mov	sp, r7
 800cc20:	bd80      	pop	{r7, pc}
	...

0800cc24 <ProcessBufferTryDecodeEcc>:
 * @return  ECC_KEY_SIZE_E when ECC key size doesn't meet minimum required.
 */
static int ProcessBufferTryDecodeEcc(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int* keyFormat, void* heap, int devId, byte* keyType,
    int* keySize)
{
 800cc24:	b580      	push	{r7, lr}
 800cc26:	b08a      	sub	sp, #40	@ 0x28
 800cc28:	af00      	add	r7, sp, #0
 800cc2a:	60f8      	str	r0, [r7, #12]
 800cc2c:	60b9      	str	r1, [r7, #8]
 800cc2e:	607a      	str	r2, [r7, #4]
 800cc30:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800cc32:	2300      	movs	r3, #0
 800cc34:	627b      	str	r3, [r7, #36]	@ 0x24
    ecc_key  key[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    /* Allocate an ECC key to parse into. */
    key = (ecc_key*)XMALLOC(sizeof(ecc_key), heap, DYNAMIC_TYPE_ECC);
 800cc36:	f44f 70b8 	mov.w	r0, #368	@ 0x170
 800cc3a:	f011 ff2b 	bl	801ea94 <wolfSSL_Malloc>
 800cc3e:	6238      	str	r0, [r7, #32]
    if (key == NULL)
 800cc40:	6a3b      	ldr	r3, [r7, #32]
 800cc42:	2b00      	cmp	r3, #0
 800cc44:	d102      	bne.n	800cc4c <ProcessBufferTryDecodeEcc+0x28>
        return MEMORY_E;
 800cc46:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800cc4a:	e05a      	b.n	800cd02 <ProcessBufferTryDecodeEcc+0xde>
#endif

    /* Initialize ECC key. */
    if (wc_ecc_init_ex(key, heap, devId) == 0) {
 800cc4c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800cc4e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 800cc50:	6a38      	ldr	r0, [r7, #32]
 800cc52:	f010 f8cd 	bl	801cdf0 <wc_ecc_init_ex>
 800cc56:	4603      	mov	r3, r0
 800cc58:	2b00      	cmp	r3, #0
 800cc5a:	d149      	bne.n	800ccf0 <ProcessBufferTryDecodeEcc+0xcc>
        /* Decode as an ECC private key. */
        idx = 0;
 800cc5c:	2300      	movs	r3, #0
 800cc5e:	613b      	str	r3, [r7, #16]
        ret = wc_EccPrivateKeyDecode(der->buffer, &idx, key, der->length);
 800cc60:	687b      	ldr	r3, [r7, #4]
 800cc62:	6818      	ldr	r0, [r3, #0]
 800cc64:	687b      	ldr	r3, [r7, #4]
 800cc66:	689b      	ldr	r3, [r3, #8]
 800cc68:	f107 0110 	add.w	r1, r7, #16
 800cc6c:	6a3a      	ldr	r2, [r7, #32]
 800cc6e:	f00d f8b5 	bl	8019ddc <wc_EccPrivateKeyDecode>
 800cc72:	6278      	str	r0, [r7, #36]	@ 0x24
        if (*keyFormat == SM2k) {
            ret = wc_ecc_set_curve(key, WOLFSSL_SM2_KEY_BITS / 8,
                ECC_SM2P256V1);
        }
    #endif
        if (ret == 0) {
 800cc74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cc76:	2b00      	cmp	r3, #0
 800cc78:	d131      	bne.n	800ccde <ProcessBufferTryDecodeEcc+0xba>
            /* Get the minimum ECC key size from SSL or SSL context object. */
            int minKeySz = ssl ? ssl->options.minEccKeySz : ctx->minEccKeySz;
 800cc7a:	68bb      	ldr	r3, [r7, #8]
 800cc7c:	2b00      	cmp	r3, #0
 800cc7e:	d003      	beq.n	800cc88 <ProcessBufferTryDecodeEcc+0x64>
 800cc80:	68bb      	ldr	r3, [r7, #8]
 800cc82:	f9b3 32f6 	ldrsh.w	r3, [r3, #758]	@ 0x2f6
 800cc86:	e002      	b.n	800cc8e <ProcessBufferTryDecodeEcc+0x6a>
 800cc88:	68fb      	ldr	r3, [r7, #12]
 800cc8a:	f9b3 3068 	ldrsh.w	r3, [r3, #104]	@ 0x68
 800cc8e:	61fb      	str	r3, [r7, #28]
            int keySz = wc_ecc_size(key);
 800cc90:	6a38      	ldr	r0, [r7, #32]
 800cc92:	f011 fac7 	bl	801e224 <wc_ecc_size>
 800cc96:	61b8      	str	r0, [r7, #24]

            /* Format is known. */
            *keyFormat = ECDSAk;
 800cc98:	683b      	ldr	r3, [r7, #0]
 800cc9a:	f240 2206 	movw	r2, #518	@ 0x206
 800cc9e:	601a      	str	r2, [r3, #0]
                *keyType = sm2_sa_algo;
            }
            else
        #endif
            {
                *keyType = ecc_dsa_sa_algo;
 800cca0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800cca2:	2203      	movs	r2, #3
 800cca4:	701a      	strb	r2, [r3, #0]
            }
            *keySize = keySz;
 800cca6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800cca8:	69ba      	ldr	r2, [r7, #24]
 800ccaa:	601a      	str	r2, [r3, #0]

            /* Check that the size of the ECC key is enough. */
            if (keySz < minKeySz) {
 800ccac:	69ba      	ldr	r2, [r7, #24]
 800ccae:	69fb      	ldr	r3, [r7, #28]
 800ccb0:	429a      	cmp	r2, r3
 800ccb2:	da01      	bge.n	800ccb8 <ProcessBufferTryDecodeEcc+0x94>
                WOLFSSL_MSG("ECC private key too small");
                ret = ECC_KEY_SIZE_E;
 800ccb4:	4b15      	ldr	r3, [pc, #84]	@ (800cd0c <ProcessBufferTryDecodeEcc+0xe8>)
 800ccb6:	627b      	str	r3, [r7, #36]	@ 0x24
            }
            /* Static ECC key possible. */
            if (ssl) {
 800ccb8:	68bb      	ldr	r3, [r7, #8]
 800ccba:	2b00      	cmp	r3, #0
 800ccbc:	d007      	beq.n	800ccce <ProcessBufferTryDecodeEcc+0xaa>
                ssl->options.haveStaticECC = 1;
 800ccbe:	68ba      	ldr	r2, [r7, #8]
 800ccc0:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800ccc4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800ccc8:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
 800cccc:	e00d      	b.n	800ccea <ProcessBufferTryDecodeEcc+0xc6>
            }
            else {
                ctx->haveStaticECC = 1;
 800ccce:	68fa      	ldr	r2, [r7, #12]
 800ccd0:	f892 305f 	ldrb.w	r3, [r2, #95]	@ 0x5f
 800ccd4:	f043 0301 	orr.w	r3, r3, #1
 800ccd8:	f882 305f 	strb.w	r3, [r2, #95]	@ 0x5f
 800ccdc:	e005      	b.n	800ccea <ProcessBufferTryDecodeEcc+0xc6>
            }
        }
        /* Not an ECC key but check whether we know what it is. */
        else if (*keyFormat == 0) {
 800ccde:	683b      	ldr	r3, [r7, #0]
 800cce0:	681b      	ldr	r3, [r3, #0]
 800cce2:	2b00      	cmp	r3, #0
 800cce4:	d101      	bne.n	800ccea <ProcessBufferTryDecodeEcc+0xc6>
            WOLFSSL_MSG("Not an ECC key");
            /* Format unknown so keep trying. */
            ret = 0;
 800cce6:	2300      	movs	r3, #0
 800cce8:	627b      	str	r3, [r7, #36]	@ 0x24
        }

        /* Free dynamically allocated data in key. */
        wc_ecc_free(key);
 800ccea:	6a38      	ldr	r0, [r7, #32]
 800ccec:	f010 f91b 	bl	801cf26 <wc_ecc_free>
    }

#ifdef WOLFSSL_SMALL_STACK
    /* Dispose of allocated key. */
    XFREE(key, heap, DYNAMIC_TYPE_ECC);
 800ccf0:	6a3b      	ldr	r3, [r7, #32]
 800ccf2:	617b      	str	r3, [r7, #20]
 800ccf4:	697b      	ldr	r3, [r7, #20]
 800ccf6:	2b00      	cmp	r3, #0
 800ccf8:	d002      	beq.n	800cd00 <ProcessBufferTryDecodeEcc+0xdc>
 800ccfa:	6978      	ldr	r0, [r7, #20]
 800ccfc:	f011 fee6 	bl	801eacc <wolfSSL_Free>
#endif
    return ret;
 800cd00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800cd02:	4618      	mov	r0, r3
 800cd04:	3728      	adds	r7, #40	@ 0x28
 800cd06:	46bd      	mov	sp, r7
 800cd08:	bd80      	pop	{r7, pc}
 800cd0a:	bf00      	nop
 800cd0c:	fffffe66 	.word	0xfffffe66

0800cd10 <ProcessBufferTryDecode>:
 * @return  BAD_FUNC_ARG when ctx and ssl are NULL.
 * @return  WOLFSSL_BAD_FILE when unable to identify the key format.
 */
static int ProcessBufferTryDecode(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int* keyFormat, void* heap, int type)
{
 800cd10:	b580      	push	{r7, lr}
 800cd12:	b08c      	sub	sp, #48	@ 0x30
 800cd14:	af04      	add	r7, sp, #16
 800cd16:	60f8      	str	r0, [r7, #12]
 800cd18:	60b9      	str	r1, [r7, #8]
 800cd1a:	607a      	str	r2, [r7, #4]
 800cd1c:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800cd1e:	2300      	movs	r3, #0
 800cd20:	61fb      	str	r3, [r7, #28]
    int devId = wolfSSL_CTX_GetDevId(ctx, ssl);
 800cd22:	68b9      	ldr	r1, [r7, #8]
 800cd24:	68f8      	ldr	r0, [r7, #12]
 800cd26:	f7ff fa48 	bl	800c1ba <wolfSSL_CTX_GetDevId>
 800cd2a:	6138      	str	r0, [r7, #16]
    byte* keyType = NULL;
 800cd2c:	2300      	movs	r3, #0
 800cd2e:	61bb      	str	r3, [r7, #24]
    int* keySz = NULL;
 800cd30:	2300      	movs	r3, #0
 800cd32:	617b      	str	r3, [r7, #20]
    (void)heap;
    (void)devId;
    (void)type;

    /* Validate parameters. */
    if ((der == NULL) || (keyFormat == NULL)) {
 800cd34:	687b      	ldr	r3, [r7, #4]
 800cd36:	2b00      	cmp	r3, #0
 800cd38:	d002      	beq.n	800cd40 <ProcessBufferTryDecode+0x30>
 800cd3a:	683b      	ldr	r3, [r7, #0]
 800cd3c:	2b00      	cmp	r3, #0
 800cd3e:	d102      	bne.n	800cd46 <ProcessBufferTryDecode+0x36>
        ret = BAD_FUNC_ARG;
 800cd40:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800cd44:	61fb      	str	r3, [r7, #28]
    }
    /* Must have an SSL context or SSL object to use. */
    if ((ret == 0) && (ctx == NULL) && (ssl == NULL)) {
 800cd46:	69fb      	ldr	r3, [r7, #28]
 800cd48:	2b00      	cmp	r3, #0
 800cd4a:	d108      	bne.n	800cd5e <ProcessBufferTryDecode+0x4e>
 800cd4c:	68fb      	ldr	r3, [r7, #12]
 800cd4e:	2b00      	cmp	r3, #0
 800cd50:	d105      	bne.n	800cd5e <ProcessBufferTryDecode+0x4e>
 800cd52:	68bb      	ldr	r3, [r7, #8]
 800cd54:	2b00      	cmp	r3, #0
 800cd56:	d102      	bne.n	800cd5e <ProcessBufferTryDecode+0x4e>
        ret = BAD_FUNC_ARG;
 800cd58:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800cd5c:	61fb      	str	r3, [r7, #28]
    }

    if (ret == 0) {
 800cd5e:	69fb      	ldr	r3, [r7, #28]
 800cd60:	2b00      	cmp	r3, #0
 800cd62:	d111      	bne.n	800cd88 <ProcessBufferTryDecode+0x78>
            }
        }
        else
    #endif
        /* Type is PRIVATEKEY_TYPE. */
        if (ssl != NULL) {
 800cd64:	68bb      	ldr	r3, [r7, #8]
 800cd66:	2b00      	cmp	r3, #0
 800cd68:	d008      	beq.n	800cd7c <ProcessBufferTryDecode+0x6c>
            keyType = &ssl->buffers.keyType;
 800cd6a:	68bb      	ldr	r3, [r7, #8]
 800cd6c:	f503 73ba 	add.w	r3, r3, #372	@ 0x174
 800cd70:	61bb      	str	r3, [r7, #24]
            keySz = &ssl->buffers.keySz;
 800cd72:	68bb      	ldr	r3, [r7, #8]
 800cd74:	f503 73bc 	add.w	r3, r3, #376	@ 0x178
 800cd78:	617b      	str	r3, [r7, #20]
 800cd7a:	e005      	b.n	800cd88 <ProcessBufferTryDecode+0x78>
        }
        else {
            keyType = &ctx->privateKeyType;
 800cd7c:	68fb      	ldr	r3, [r7, #12]
 800cd7e:	3344      	adds	r3, #68	@ 0x44
 800cd80:	61bb      	str	r3, [r7, #24]
            keySz = &ctx->privateKeySz;
 800cd82:	68fb      	ldr	r3, [r7, #12]
 800cd84:	3348      	adds	r3, #72	@ 0x48
 800cd86:	617b      	str	r3, [r7, #20]
        }
    }

#ifndef NO_RSA
    /* Try RSA if key format is RSA or yet unknown. */
    if ((ret == 0) && ((*keyFormat == 0) || (*keyFormat == RSAk))) {
 800cd88:	69fb      	ldr	r3, [r7, #28]
 800cd8a:	2b00      	cmp	r3, #0
 800cd8c:	d116      	bne.n	800cdbc <ProcessBufferTryDecode+0xac>
 800cd8e:	683b      	ldr	r3, [r7, #0]
 800cd90:	681b      	ldr	r3, [r3, #0]
 800cd92:	2b00      	cmp	r3, #0
 800cd94:	d005      	beq.n	800cda2 <ProcessBufferTryDecode+0x92>
 800cd96:	683b      	ldr	r3, [r7, #0]
 800cd98:	681b      	ldr	r3, [r3, #0]
 800cd9a:	f240 2285 	movw	r2, #645	@ 0x285
 800cd9e:	4293      	cmp	r3, r2
 800cda0:	d10c      	bne.n	800cdbc <ProcessBufferTryDecode+0xac>
#if !defined(HAVE_FIPS) || (defined(HAVE_FIPS_VERSION) && \
    (HAVE_FIPS_VERSION > 2))
        ret = ProcessBufferTryDecodeRsa(ctx, ssl, der, keyFormat, devId,
 800cda2:	697b      	ldr	r3, [r7, #20]
 800cda4:	9302      	str	r3, [sp, #8]
 800cda6:	69bb      	ldr	r3, [r7, #24]
 800cda8:	9301      	str	r3, [sp, #4]
 800cdaa:	693b      	ldr	r3, [r7, #16]
 800cdac:	9300      	str	r3, [sp, #0]
 800cdae:	683b      	ldr	r3, [r7, #0]
 800cdb0:	687a      	ldr	r2, [r7, #4]
 800cdb2:	68b9      	ldr	r1, [r7, #8]
 800cdb4:	68f8      	ldr	r0, [r7, #12]
 800cdb6:	f7ff fee1 	bl	800cb7c <ProcessBufferTryDecodeRsa>
 800cdba:	61f8      	str	r0, [r7, #28]
#endif
    }
#endif
#ifdef HAVE_ECC
    /* Try ECC if key format is ECDSA or SM2, or yet unknown. */
    if ((ret == 0) && ((*keyFormat == 0) || (*keyFormat == ECDSAk)
 800cdbc:	69fb      	ldr	r3, [r7, #28]
 800cdbe:	2b00      	cmp	r3, #0
 800cdc0:	d118      	bne.n	800cdf4 <ProcessBufferTryDecode+0xe4>
 800cdc2:	683b      	ldr	r3, [r7, #0]
 800cdc4:	681b      	ldr	r3, [r3, #0]
 800cdc6:	2b00      	cmp	r3, #0
 800cdc8:	d005      	beq.n	800cdd6 <ProcessBufferTryDecode+0xc6>
 800cdca:	683b      	ldr	r3, [r7, #0]
 800cdcc:	681b      	ldr	r3, [r3, #0]
 800cdce:	f240 2206 	movw	r2, #518	@ 0x206
 800cdd2:	4293      	cmp	r3, r2
 800cdd4:	d10e      	bne.n	800cdf4 <ProcessBufferTryDecode+0xe4>
    #ifdef WOLFSSL_SM2
        || (*keyFormat == SM2k)
    #endif
        )) {
        ret = ProcessBufferTryDecodeEcc(ctx, ssl, der, keyFormat, heap, devId,
 800cdd6:	697b      	ldr	r3, [r7, #20]
 800cdd8:	9303      	str	r3, [sp, #12]
 800cdda:	69bb      	ldr	r3, [r7, #24]
 800cddc:	9302      	str	r3, [sp, #8]
 800cdde:	693b      	ldr	r3, [r7, #16]
 800cde0:	9301      	str	r3, [sp, #4]
 800cde2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cde4:	9300      	str	r3, [sp, #0]
 800cde6:	683b      	ldr	r3, [r7, #0]
 800cde8:	687a      	ldr	r2, [r7, #4]
 800cdea:	68b9      	ldr	r1, [r7, #8]
 800cdec:	68f8      	ldr	r0, [r7, #12]
 800cdee:	f7ff ff19 	bl	800cc24 <ProcessBufferTryDecodeEcc>
 800cdf2:	61f8      	str	r0, [r7, #28]
            keyType, keySz);
    }
#endif /* HAVE_DILITHIUM */

    /* Check we know the format. */
    if ((ret == 0) && (*keyFormat == 0)) {
 800cdf4:	69fb      	ldr	r3, [r7, #28]
 800cdf6:	2b00      	cmp	r3, #0
 800cdf8:	d106      	bne.n	800ce08 <ProcessBufferTryDecode+0xf8>
 800cdfa:	683b      	ldr	r3, [r7, #0]
 800cdfc:	681b      	ldr	r3, [r3, #0]
 800cdfe:	2b00      	cmp	r3, #0
 800ce00:	d102      	bne.n	800ce08 <ProcessBufferTryDecode+0xf8>
        WOLFSSL_MSG("Not a supported key type");
        /* Not supported key format. */
        ret = WOLFSSL_BAD_FILE;
 800ce02:	f46f 73e7 	mvn.w	r3, #462	@ 0x1ce
 800ce06:	61fb      	str	r3, [r7, #28]
    }

    return ret;
 800ce08:	69fb      	ldr	r3, [r7, #28]
}
 800ce0a:	4618      	mov	r0, r3
 800ce0c:	3720      	adds	r7, #32
 800ce0e:	46bd      	mov	sp, r7
 800ce10:	bd80      	pop	{r7, pc}

0800ce12 <ProcessBufferPrivKeyHandleDer>:
 * @param [in]      der  DER encoding.
 * @return  0 on success.
 */
static int ProcessBufferPrivKeyHandleDer(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer** der, int type)
{
 800ce12:	b580      	push	{r7, lr}
 800ce14:	b086      	sub	sp, #24
 800ce16:	af00      	add	r7, sp, #0
 800ce18:	60f8      	str	r0, [r7, #12]
 800ce1a:	60b9      	str	r1, [r7, #8]
 800ce1c:	607a      	str	r2, [r7, #4]
 800ce1e:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800ce20:	2300      	movs	r3, #0
 800ce22:	617b      	str	r3, [r7, #20]
        #endif
        }
    }
    else
#endif /* WOLFSSL_DUAL_ALG_CERTS */
    if (ssl != NULL) {
 800ce24:	68bb      	ldr	r3, [r7, #8]
 800ce26:	2b00      	cmp	r3, #0
 800ce28:	d027      	beq.n	800ce7a <ProcessBufferPrivKeyHandleDer+0x68>
        /* Dispose of previous key if not context's. */
        if (ssl->buffers.weOwnKey) {
 800ce2a:	68bb      	ldr	r3, [r7, #8]
 800ce2c:	f893 3146 	ldrb.w	r3, [r3, #326]	@ 0x146
 800ce30:	2b00      	cmp	r3, #0
 800ce32:	d005      	beq.n	800ce40 <ProcessBufferPrivKeyHandleDer+0x2e>
            FreeDer(&ssl->buffers.key);
 800ce34:	68bb      	ldr	r3, [r7, #8]
 800ce36:	f503 73b8 	add.w	r3, r3, #368	@ 0x170
 800ce3a:	4618      	mov	r0, r3
 800ce3c:	f00c f8a4 	bl	8018f88 <FreeDer>
        #ifdef WOLFSSL_BLIND_PRIVATE_KEY
            FreeDer(&ssl->buffers.keyMask);
        #endif
        }
        ssl->buffers.keyId = 0;
 800ce40:	68ba      	ldr	r2, [r7, #8]
 800ce42:	f892 3175 	ldrb.w	r3, [r2, #373]	@ 0x175
 800ce46:	f023 0301 	bic.w	r3, r3, #1
 800ce4a:	f882 3175 	strb.w	r3, [r2, #373]	@ 0x175
        ssl->buffers.keyLabel = 0;
 800ce4e:	68ba      	ldr	r2, [r7, #8]
 800ce50:	f892 3175 	ldrb.w	r3, [r2, #373]	@ 0x175
 800ce54:	f023 0302 	bic.w	r3, r3, #2
 800ce58:	f882 3175 	strb.w	r3, [r2, #373]	@ 0x175
        ssl->buffers.keyDevId = INVALID_DEVID;
 800ce5c:	68bb      	ldr	r3, [r7, #8]
 800ce5e:	f06f 0201 	mvn.w	r2, #1
 800ce62:	f8c3 217c 	str.w	r2, [r3, #380]	@ 0x17c
        /* Store key by reference and own it. */
        ssl->buffers.key = *der;
 800ce66:	687b      	ldr	r3, [r7, #4]
 800ce68:	681a      	ldr	r2, [r3, #0]
 800ce6a:	68bb      	ldr	r3, [r7, #8]
 800ce6c:	f8c3 2170 	str.w	r2, [r3, #368]	@ 0x170
    #ifdef WOLFSSL_CHECK_MEM_ZERO
        wc_MemZero_Add("SSL Buffers key", (*der)->buffer, (*der)->length);
    #endif
        ssl->buffers.weOwnKey = 1;
 800ce70:	68bb      	ldr	r3, [r7, #8]
 800ce72:	2201      	movs	r2, #1
 800ce74:	f883 2146 	strb.w	r2, [r3, #326]	@ 0x146
 800ce78:	e01d      	b.n	800ceb6 <ProcessBufferPrivKeyHandleDer+0xa4>
    }
    else if (ctx != NULL) {
 800ce7a:	68fb      	ldr	r3, [r7, #12]
 800ce7c:	2b00      	cmp	r3, #0
 800ce7e:	d01a      	beq.n	800ceb6 <ProcessBufferPrivKeyHandleDer+0xa4>
        /* Dispose of previous key. */
        FreeDer(&ctx->privateKey);
 800ce80:	68fb      	ldr	r3, [r7, #12]
 800ce82:	3340      	adds	r3, #64	@ 0x40
 800ce84:	4618      	mov	r0, r3
 800ce86:	f00c f87f 	bl	8018f88 <FreeDer>
        ctx->privateKeyId = 0;
 800ce8a:	68fa      	ldr	r2, [r7, #12]
 800ce8c:	f892 3045 	ldrb.w	r3, [r2, #69]	@ 0x45
 800ce90:	f023 0301 	bic.w	r3, r3, #1
 800ce94:	f882 3045 	strb.w	r3, [r2, #69]	@ 0x45
        ctx->privateKeyLabel = 0;
 800ce98:	68fa      	ldr	r2, [r7, #12]
 800ce9a:	f892 3045 	ldrb.w	r3, [r2, #69]	@ 0x45
 800ce9e:	f023 0302 	bic.w	r3, r3, #2
 800cea2:	f882 3045 	strb.w	r3, [r2, #69]	@ 0x45
        ctx->privateKeyDevId = INVALID_DEVID;
 800cea6:	68fb      	ldr	r3, [r7, #12]
 800cea8:	f06f 0201 	mvn.w	r2, #1
 800ceac:	64da      	str	r2, [r3, #76]	@ 0x4c
        /* Store key by reference. */
        ctx->privateKey = *der;
 800ceae:	687b      	ldr	r3, [r7, #4]
 800ceb0:	681a      	ldr	r2, [r3, #0]
 800ceb2:	68fb      	ldr	r3, [r7, #12]
 800ceb4:	641a      	str	r2, [r3, #64]	@ 0x40
    #ifdef WOLFSSL_CHECK_MEM_ZERO
        wc_MemZero_Add("CTX private key", (*der)->buffer, (*der)->length);
    #endif
    }

    return ret;
 800ceb6:	697b      	ldr	r3, [r7, #20]
}
 800ceb8:	4618      	mov	r0, r3
 800ceba:	3718      	adds	r7, #24
 800cebc:	46bd      	mov	sp, r7
 800cebe:	bd80      	pop	{r7, pc}

0800cec0 <ProcessBufferPrivateKey>:
 * @return  WOLFSSL_BAD_FILE when not able to decode.
 */
static int ProcessBufferPrivateKey(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int format, EncryptedInfo* info, void* heap, int type,
    int algId)
{
 800cec0:	b580      	push	{r7, lr}
 800cec2:	b088      	sub	sp, #32
 800cec4:	af02      	add	r7, sp, #8
 800cec6:	60f8      	str	r0, [r7, #12]
 800cec8:	60b9      	str	r1, [r7, #8]
 800ceca:	607a      	str	r2, [r7, #4]
 800cecc:	603b      	str	r3, [r7, #0]

    (void)info;
    (void)format;

    /* Put the data into the SSL or SSL context object. */
    ret = ProcessBufferPrivKeyHandleDer(ctx, ssl, &der, type);
 800cece:	1d3a      	adds	r2, r7, #4
 800ced0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ced2:	68b9      	ldr	r1, [r7, #8]
 800ced4:	68f8      	ldr	r0, [r7, #12]
 800ced6:	f7ff ff9c 	bl	800ce12 <ProcessBufferPrivKeyHandleDer>
 800ceda:	6178      	str	r0, [r7, #20]
    if (ret == 0) {
 800cedc:	697b      	ldr	r3, [r7, #20]
 800cede:	2b00      	cmp	r3, #0
 800cee0:	d10c      	bne.n	800cefc <ProcessBufferPrivateKey+0x3c>
        /* Try to decode the DER data. */
        ret = ProcessBufferTryDecode(ctx, ssl, der, &algId, heap, type);
 800cee2:	687a      	ldr	r2, [r7, #4]
 800cee4:	f107 012c 	add.w	r1, r7, #44	@ 0x2c
 800cee8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ceea:	9301      	str	r3, [sp, #4]
 800ceec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ceee:	9300      	str	r3, [sp, #0]
 800cef0:	460b      	mov	r3, r1
 800cef2:	68b9      	ldr	r1, [r7, #8]
 800cef4:	68f8      	ldr	r0, [r7, #12]
 800cef6:	f7ff ff0b 	bl	800cd10 <ProcessBufferTryDecode>
 800cefa:	6178      	str	r0, [r7, #20]
            &ctx->privateKeyMask);
    }
#endif

    /* Check if we were able to determine algorithm id. */
    if ((ret == 0) && (algId == 0)) {
 800cefc:	697b      	ldr	r3, [r7, #20]
 800cefe:	2b00      	cmp	r3, #0
 800cf00:	d11d      	bne.n	800cf3e <ProcessBufferPrivateKey+0x7e>
 800cf02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800cf04:	2b00      	cmp	r3, #0
 800cf06:	d11a      	bne.n	800cf3e <ProcessBufferPrivateKey+0x7e>
    #ifdef OPENSSL_EXTRA
        /* Decryption password is probably wrong. */
        if (info->passwd_cb) {
 800cf08:	6a3b      	ldr	r3, [r7, #32]
 800cf0a:	685b      	ldr	r3, [r3, #4]
 800cf0c:	2b00      	cmp	r3, #0
 800cf0e:	d009      	beq.n	800cf24 <ProcessBufferPrivateKey+0x64>
            WOLFSSL_EVPerr(0, -WOLFSSL_EVP_R_BAD_DECRYPT_E);
 800cf10:	f44f 63af 	mov.w	r3, #1400	@ 0x578
 800cf14:	9300      	str	r3, [sp, #0]
 800cf16:	4b0c      	ldr	r3, [pc, #48]	@ (800cf48 <ProcessBufferPrivateKey+0x88>)
 800cf18:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800cf1c:	2100      	movs	r1, #0
 800cf1e:	200b      	movs	r0, #11
 800cf20:	f000 fe68 	bl	800dbf4 <wolfSSL_ERR_put_error>
        }
    #endif
        WOLFSSL_ERROR(WOLFSSL_BAD_FILE);
 800cf24:	2300      	movs	r3, #0
 800cf26:	9300      	str	r3, [sp, #0]
 800cf28:	4b07      	ldr	r3, [pc, #28]	@ (800cf48 <ProcessBufferPrivateKey+0x88>)
 800cf2a:	f240 527b 	movw	r2, #1403	@ 0x57b
 800cf2e:	4907      	ldr	r1, [pc, #28]	@ (800cf4c <ProcessBufferPrivateKey+0x8c>)
 800cf30:	f46f 70e7 	mvn.w	r0, #462	@ 0x1ce
 800cf34:	f011 fd62 	bl	801e9fc <WOLFSSL_ERROR_LINE>
        /* Unable to decode DER data. */
        ret = WOLFSSL_BAD_FILE;
 800cf38:	f46f 73e7 	mvn.w	r3, #462	@ 0x1ce
 800cf3c:	617b      	str	r3, [r7, #20]
    }

    return ret;
 800cf3e:	697b      	ldr	r3, [r7, #20]
}
 800cf40:	4618      	mov	r0, r3
 800cf42:	3718      	adds	r7, #24
 800cf44:	46bd      	mov	sp, r7
 800cf46:	bd80      	pop	{r7, pc}
 800cf48:	08029f34 	.word	0x08029f34
 800cf4c:	080312d4 	.word	0x080312d4

0800cf50 <wolfssl_set_have_from_key_oid>:
 * @param [in, out] ssl     SSL object.
 * @param [in]      keyOID  OID for public/private key.
 */
static void wolfssl_set_have_from_key_oid(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    int keyOID)
{
 800cf50:	b480      	push	{r7}
 800cf52:	b085      	sub	sp, #20
 800cf54:	af00      	add	r7, sp, #0
 800cf56:	60f8      	str	r0, [r7, #12]
 800cf58:	60b9      	str	r1, [r7, #8]
 800cf5a:	607a      	str	r2, [r7, #4]
    /* Set which private key algorithm available based on key OID. */
    switch (keyOID) {
 800cf5c:	687b      	ldr	r3, [r7, #4]
 800cf5e:	f240 228e 	movw	r2, #654	@ 0x28e
 800cf62:	4293      	cmp	r3, r2
 800cf64:	d022      	beq.n	800cfac <wolfssl_set_have_from_key_oid+0x5c>
 800cf66:	687b      	ldr	r3, [r7, #4]
 800cf68:	f240 228e 	movw	r2, #654	@ 0x28e
 800cf6c:	4293      	cmp	r3, r2
 800cf6e:	dc30      	bgt.n	800cfd2 <wolfssl_set_have_from_key_oid+0x82>
 800cf70:	687b      	ldr	r3, [r7, #4]
 800cf72:	f240 2206 	movw	r2, #518	@ 0x206
 800cf76:	4293      	cmp	r3, r2
 800cf78:	d005      	beq.n	800cf86 <wolfssl_set_have_from_key_oid+0x36>
 800cf7a:	687b      	ldr	r3, [r7, #4]
 800cf7c:	f240 2285 	movw	r2, #645	@ 0x285
 800cf80:	4293      	cmp	r3, r2
 800cf82:	d013      	beq.n	800cfac <wolfssl_set_have_from_key_oid+0x5c>
            }
            break;
    #endif /* HAVE_DILITHIUM */
        default:
            WOLFSSL_MSG("Cert key not supported");
            break;
 800cf84:	e025      	b.n	800cfd2 <wolfssl_set_have_from_key_oid+0x82>
            if (ssl != NULL) {
 800cf86:	68bb      	ldr	r3, [r7, #8]
 800cf88:	2b00      	cmp	r3, #0
 800cf8a:	d007      	beq.n	800cf9c <wolfssl_set_have_from_key_oid+0x4c>
                ssl->options.haveECC = 1;
 800cf8c:	68ba      	ldr	r2, [r7, #8]
 800cf8e:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800cf92:	f043 0310 	orr.w	r3, r3, #16
 800cf96:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
            break;
 800cf9a:	e01b      	b.n	800cfd4 <wolfssl_set_have_from_key_oid+0x84>
                ctx->haveECC = 1;
 800cf9c:	68fa      	ldr	r2, [r7, #12]
 800cf9e:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 800cfa2:	f043 0308 	orr.w	r3, r3, #8
 800cfa6:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
            break;
 800cfaa:	e013      	b.n	800cfd4 <wolfssl_set_have_from_key_oid+0x84>
            if (ssl != NULL) {
 800cfac:	68bb      	ldr	r3, [r7, #8]
 800cfae:	2b00      	cmp	r3, #0
 800cfb0:	d007      	beq.n	800cfc2 <wolfssl_set_have_from_key_oid+0x72>
                ssl->options.haveRSA = 1;
 800cfb2:	68ba      	ldr	r2, [r7, #8]
 800cfb4:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800cfb8:	f043 0308 	orr.w	r3, r3, #8
 800cfbc:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
            break;
 800cfc0:	e008      	b.n	800cfd4 <wolfssl_set_have_from_key_oid+0x84>
                ctx->haveRSA = 1;
 800cfc2:	68fa      	ldr	r2, [r7, #12]
 800cfc4:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 800cfc8:	f043 0304 	orr.w	r3, r3, #4
 800cfcc:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
            break;
 800cfd0:	e000      	b.n	800cfd4 <wolfssl_set_have_from_key_oid+0x84>
            break;
 800cfd2:	bf00      	nop
        }
}
 800cfd4:	bf00      	nop
 800cfd6:	3714      	adds	r7, #20
 800cfd8:	46bd      	mov	sp, r7
 800cfda:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfde:	4770      	bx	lr

0800cfe0 <ProcessBufferCertSetHave>:
 * @param [in, out] ssl     SSL object.
 * @param [in]      cert    Decode certificate.
 */
static void ProcessBufferCertSetHave(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DecodedCert* cert)
{
 800cfe0:	b580      	push	{r7, lr}
 800cfe2:	b084      	sub	sp, #16
 800cfe4:	af00      	add	r7, sp, #0
 800cfe6:	60f8      	str	r0, [r7, #12]
 800cfe8:	60b9      	str	r1, [r7, #8]
 800cfea:	607a      	str	r2, [r7, #4]
    if (ssl != NULL) {
 800cfec:	68bb      	ldr	r3, [r7, #8]
 800cfee:	2b00      	cmp	r3, #0
 800cff0:	d014      	beq.n	800d01c <ProcessBufferCertSetHave+0x3c>
        /* Reset signatures we have in SSL. */
        ssl->options.haveECDSAsig = 0;
 800cff2:	68ba      	ldr	r2, [r7, #8]
 800cff4:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800cff8:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800cffc:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
        ssl->options.haveFalconSig = 0;
 800d000:	68ba      	ldr	r2, [r7, #8]
 800d002:	f892 32d4 	ldrb.w	r3, [r2, #724]	@ 0x2d4
 800d006:	f023 0301 	bic.w	r3, r3, #1
 800d00a:	f882 32d4 	strb.w	r3, [r2, #724]	@ 0x2d4
        ssl->options.haveDilithiumSig = 0;
 800d00e:	68ba      	ldr	r2, [r7, #8]
 800d010:	f892 32d4 	ldrb.w	r3, [r2, #724]	@ 0x2d4
 800d014:	f023 0302 	bic.w	r3, r3, #2
 800d018:	f882 32d4 	strb.w	r3, [r2, #724]	@ 0x2d4
    }

    /* Set which signature we have based on the type in the cert. */
    switch (cert->signatureOID) {
 800d01c:	687b      	ldr	r3, [r7, #4]
 800d01e:	699b      	ldr	r3, [r3, #24]
 800d020:	f5b3 7f02 	cmp.w	r3, #520	@ 0x208
 800d024:	d006      	beq.n	800d034 <ProcessBufferCertSetHave+0x54>
 800d026:	f5b3 7f02 	cmp.w	r3, #520	@ 0x208
 800d02a:	d319      	bcc.n	800d060 <ProcessBufferCertSetHave+0x80>
 800d02c:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 800d030:	2b02      	cmp	r3, #2
 800d032:	d815      	bhi.n	800d060 <ProcessBufferCertSetHave+0x80>
    #endif
    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        case CTC_SM3wSM2:
    #endif
            WOLFSSL_MSG("ECDSA/ED25519/ED448 cert signature");
            if (ssl) {
 800d034:	68bb      	ldr	r3, [r7, #8]
 800d036:	2b00      	cmp	r3, #0
 800d038:	d007      	beq.n	800d04a <ProcessBufferCertSetHave+0x6a>
                ssl->options.haveECDSAsig = 1;
 800d03a:	68ba      	ldr	r2, [r7, #8]
 800d03c:	f892 32d3 	ldrb.w	r3, [r2, #723]	@ 0x2d3
 800d040:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800d044:	f882 32d3 	strb.w	r3, [r2, #723]	@ 0x2d3
            }
            else if (ctx) {
                ctx->haveECDSAsig = 1;
            }
            break;
 800d048:	e00c      	b.n	800d064 <ProcessBufferCertSetHave+0x84>
            else if (ctx) {
 800d04a:	68fb      	ldr	r3, [r7, #12]
 800d04c:	2b00      	cmp	r3, #0
 800d04e:	d009      	beq.n	800d064 <ProcessBufferCertSetHave+0x84>
                ctx->haveECDSAsig = 1;
 800d050:	68fa      	ldr	r2, [r7, #12]
 800d052:	f892 305e 	ldrb.w	r3, [r2, #94]	@ 0x5e
 800d056:	f043 0320 	orr.w	r3, r3, #32
 800d05a:	f882 305e 	strb.w	r3, [r2, #94]	@ 0x5e
            break;
 800d05e:	e001      	b.n	800d064 <ProcessBufferCertSetHave+0x84>
            }
            break;
    #endif
        default:
            WOLFSSL_MSG("Cert signature not supported");
            break;
 800d060:	bf00      	nop
 800d062:	e000      	b.n	800d066 <ProcessBufferCertSetHave+0x86>
            break;
 800d064:	bf00      	nop

#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
    defined(HAVE_FALCON) || defined(HAVE_DILITHIUM) || !defined(NO_RSA)
    #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
    /* Set the private key curve OID. */
    if (ssl != NULL) {
 800d066:	68bb      	ldr	r3, [r7, #8]
 800d068:	2b00      	cmp	r3, #0
 800d06a:	d006      	beq.n	800d07a <ProcessBufferCertSetHave+0x9a>
        ssl->pkCurveOID = cert->pkCurveOID;
 800d06c:	687b      	ldr	r3, [r7, #4]
 800d06e:	f8d3 2440 	ldr.w	r2, [r3, #1088]	@ 0x440
 800d072:	68bb      	ldr	r3, [r7, #8]
 800d074:	f8c3 23a8 	str.w	r2, [r3, #936]	@ 0x3a8
 800d078:	e008      	b.n	800d08c <ProcessBufferCertSetHave+0xac>
    }
    else if (ctx) {
 800d07a:	68fb      	ldr	r3, [r7, #12]
 800d07c:	2b00      	cmp	r3, #0
 800d07e:	d005      	beq.n	800d08c <ProcessBufferCertSetHave+0xac>
        ctx->pkCurveOID = cert->pkCurveOID;
 800d080:	687b      	ldr	r3, [r7, #4]
 800d082:	f8d3 2440 	ldr.w	r2, [r3, #1088]	@ 0x440
 800d086:	68fb      	ldr	r3, [r7, #12]
 800d088:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
    }
    #endif
#ifndef WC_STRICT_SIG
    if ((ctx != NULL) || (ssl != NULL)) {
 800d08c:	68fb      	ldr	r3, [r7, #12]
 800d08e:	2b00      	cmp	r3, #0
 800d090:	d102      	bne.n	800d098 <ProcessBufferCertSetHave+0xb8>
 800d092:	68bb      	ldr	r3, [r7, #8]
 800d094:	2b00      	cmp	r3, #0
 800d096:	d006      	beq.n	800d0a6 <ProcessBufferCertSetHave+0xc6>
        wolfssl_set_have_from_key_oid(ctx, ssl, (int)cert->keyOID);
 800d098:	687b      	ldr	r3, [r7, #4]
 800d09a:	69db      	ldr	r3, [r3, #28]
 800d09c:	461a      	mov	r2, r3
 800d09e:	68b9      	ldr	r1, [r7, #8]
 800d0a0:	68f8      	ldr	r0, [r7, #12]
 800d0a2:	f7ff ff55 	bl	800cf50 <wolfssl_set_have_from_key_oid>
    else if (ctx) {
        ctx->haveECC = ctx->haveECDSAsig;
    }
#endif /* !WC_STRICT_SIG */
#endif
}
 800d0a6:	bf00      	nop
 800d0a8:	3710      	adds	r7, #16
 800d0aa:	46bd      	mov	sp, r7
 800d0ac:	bd80      	pop	{r7, pc}
	...

0800d0b0 <ProcessBufferCertPublicKey>:
 * @return  0 on success.
 * @return  Non-zero when an error occurred.
 */
static int ProcessBufferCertPublicKey(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DecodedCert* cert, int checkKeySz)
{
 800d0b0:	b580      	push	{r7, lr}
 800d0b2:	b08c      	sub	sp, #48	@ 0x30
 800d0b4:	af04      	add	r7, sp, #16
 800d0b6:	60f8      	str	r0, [r7, #12]
 800d0b8:	60b9      	str	r1, [r7, #8]
 800d0ba:	607a      	str	r2, [r7, #4]
 800d0bc:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800d0be:	2300      	movs	r3, #0
 800d0c0:	61fb      	str	r3, [r7, #28]
    byte keyType = 0;
 800d0c2:	2300      	movs	r3, #0
 800d0c4:	76fb      	strb	r3, [r7, #27]
    int keySz = 0;
 800d0c6:	2300      	movs	r3, #0
 800d0c8:	617b      	str	r3, [r7, #20]
#ifndef NO_RSA
    word32 idx;
#endif

    /* Get key size and check unless not verifying. */
    switch (cert->keyOID) {
 800d0ca:	687b      	ldr	r3, [r7, #4]
 800d0cc:	69db      	ldr	r3, [r3, #28]
 800d0ce:	f240 228e 	movw	r2, #654	@ 0x28e
 800d0d2:	4293      	cmp	r3, r2
 800d0d4:	d00c      	beq.n	800d0f0 <ProcessBufferCertPublicKey+0x40>
 800d0d6:	f240 228e 	movw	r2, #654	@ 0x28e
 800d0da:	4293      	cmp	r3, r2
 800d0dc:	f200 8082 	bhi.w	800d1e4 <ProcessBufferCertPublicKey+0x134>
 800d0e0:	f240 2206 	movw	r2, #518	@ 0x206
 800d0e4:	4293      	cmp	r3, r2
 800d0e6:	d045      	beq.n	800d174 <ProcessBufferCertPublicKey+0xc4>
 800d0e8:	f240 2285 	movw	r2, #645	@ 0x285
 800d0ec:	4293      	cmp	r3, r2
 800d0ee:	d179      	bne.n	800d1e4 <ProcessBufferCertPublicKey+0x134>
#ifndef NO_RSA
    #ifdef WC_RSA_PSS
        case RSAPSSk:
    #endif
        case RSAk:
            keyType = rsa_sa_algo;
 800d0f0:	2301      	movs	r3, #1
 800d0f2:	76fb      	strb	r3, [r7, #27]
            /* Determine RSA key size by parsing public key */
            idx = 0;
 800d0f4:	2300      	movs	r3, #0
 800d0f6:	613b      	str	r3, [r7, #16]
            ret = wc_RsaPublicKeyDecode_ex(cert->publicKey, &idx,
 800d0f8:	687b      	ldr	r3, [r7, #4]
 800d0fa:	6818      	ldr	r0, [r3, #0]
 800d0fc:	687b      	ldr	r3, [r7, #4]
 800d0fe:	685a      	ldr	r2, [r3, #4]
 800d100:	f107 0110 	add.w	r1, r7, #16
 800d104:	2300      	movs	r3, #0
 800d106:	9302      	str	r3, [sp, #8]
 800d108:	2300      	movs	r3, #0
 800d10a:	9301      	str	r3, [sp, #4]
 800d10c:	f107 0314 	add.w	r3, r7, #20
 800d110:	9300      	str	r3, [sp, #0]
 800d112:	2300      	movs	r3, #0
 800d114:	f007 fed0 	bl	8014eb8 <wc_RsaPublicKeyDecode_ex>
 800d118:	61f8      	str	r0, [r7, #28]
                cert->pubKeySize, NULL, (word32*)&keySz, NULL, NULL);
            if ((ret == 0) && checkKeySz) {
 800d11a:	69fb      	ldr	r3, [r7, #28]
 800d11c:	2b00      	cmp	r3, #0
 800d11e:	d163      	bne.n	800d1e8 <ProcessBufferCertPublicKey+0x138>
 800d120:	683b      	ldr	r3, [r7, #0]
 800d122:	2b00      	cmp	r3, #0
 800d124:	d060      	beq.n	800d1e8 <ProcessBufferCertPublicKey+0x138>
                ret = CHECK_KEY_SZ(ssl ? ssl->options.minRsaKeySz :
 800d126:	68bb      	ldr	r3, [r7, #8]
 800d128:	2b00      	cmp	r3, #0
 800d12a:	d005      	beq.n	800d138 <ProcessBufferCertPublicKey+0x88>
 800d12c:	68bb      	ldr	r3, [r7, #8]
 800d12e:	f9b3 32f4 	ldrsh.w	r3, [r3, #756]	@ 0x2f4
 800d132:	2b00      	cmp	r3, #0
 800d134:	db18      	blt.n	800d168 <ProcessBufferCertPublicKey+0xb8>
 800d136:	e004      	b.n	800d142 <ProcessBufferCertPublicKey+0x92>
 800d138:	68fb      	ldr	r3, [r7, #12]
 800d13a:	f9b3 3066 	ldrsh.w	r3, [r3, #102]	@ 0x66
 800d13e:	2b00      	cmp	r3, #0
 800d140:	db12      	blt.n	800d168 <ProcessBufferCertPublicKey+0xb8>
 800d142:	68bb      	ldr	r3, [r7, #8]
 800d144:	2b00      	cmp	r3, #0
 800d146:	d004      	beq.n	800d152 <ProcessBufferCertPublicKey+0xa2>
 800d148:	68bb      	ldr	r3, [r7, #8]
 800d14a:	f9b3 32f4 	ldrsh.w	r3, [r3, #756]	@ 0x2f4
 800d14e:	461a      	mov	r2, r3
 800d150:	e003      	b.n	800d15a <ProcessBufferCertPublicKey+0xaa>
 800d152:	68fb      	ldr	r3, [r7, #12]
 800d154:	f9b3 3066 	ldrsh.w	r3, [r3, #102]	@ 0x66
 800d158:	461a      	mov	r2, r3
 800d15a:	697b      	ldr	r3, [r7, #20]
 800d15c:	429a      	cmp	r2, r3
 800d15e:	dc03      	bgt.n	800d168 <ProcessBufferCertPublicKey+0xb8>
 800d160:	697b      	ldr	r3, [r7, #20]
 800d162:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800d166:	dd02      	ble.n	800d16e <ProcessBufferCertPublicKey+0xbe>
 800d168:	f46f 73cc 	mvn.w	r3, #408	@ 0x198
 800d16c:	e000      	b.n	800d170 <ProcessBufferCertPublicKey+0xc0>
 800d16e:	2300      	movs	r3, #0
 800d170:	61fb      	str	r3, [r7, #28]
                    ctx->minRsaKeySz, RSA_MAX_SIZE / 8, keySz, RSA_KEY_SIZE_E);
            }
            break;
 800d172:	e039      	b.n	800d1e8 <ProcessBufferCertPublicKey+0x138>
#endif /* !NO_RSA */
    #ifdef HAVE_ECC
        case ECDSAk:
            keyType = ecc_dsa_sa_algo;
 800d174:	2303      	movs	r3, #3
 800d176:	76fb      	strb	r3, [r7, #27]
                keySz = cert->pkCurveSize;
            }
            else
        #endif
            {
                keySz = wc_ecc_get_curve_size_from_id(wc_ecc_get_oid(
 800d178:	687b      	ldr	r3, [r7, #4]
 800d17a:	f8d3 3440 	ldr.w	r3, [r3, #1088]	@ 0x440
 800d17e:	2200      	movs	r2, #0
 800d180:	2100      	movs	r1, #0
 800d182:	4618      	mov	r0, r3
 800d184:	f011 f89e 	bl	801e2c4 <wc_ecc_get_oid>
 800d188:	4603      	mov	r3, r0
 800d18a:	4618      	mov	r0, r3
 800d18c:	f00f fcd0 	bl	801cb30 <wc_ecc_get_curve_size_from_id>
 800d190:	4603      	mov	r3, r0
 800d192:	617b      	str	r3, [r7, #20]
                    cert->pkCurveOID, NULL, NULL));
            }

            if (checkKeySz) {
 800d194:	683b      	ldr	r3, [r7, #0]
 800d196:	2b00      	cmp	r3, #0
 800d198:	d028      	beq.n	800d1ec <ProcessBufferCertPublicKey+0x13c>
                ret = CHECK_KEY_SZ(ssl ? ssl->options.minEccKeySz :
 800d19a:	68bb      	ldr	r3, [r7, #8]
 800d19c:	2b00      	cmp	r3, #0
 800d19e:	d005      	beq.n	800d1ac <ProcessBufferCertPublicKey+0xfc>
 800d1a0:	68bb      	ldr	r3, [r7, #8]
 800d1a2:	f9b3 32f6 	ldrsh.w	r3, [r3, #758]	@ 0x2f6
 800d1a6:	2b00      	cmp	r3, #0
 800d1a8:	db17      	blt.n	800d1da <ProcessBufferCertPublicKey+0x12a>
 800d1aa:	e004      	b.n	800d1b6 <ProcessBufferCertPublicKey+0x106>
 800d1ac:	68fb      	ldr	r3, [r7, #12]
 800d1ae:	f9b3 3068 	ldrsh.w	r3, [r3, #104]	@ 0x68
 800d1b2:	2b00      	cmp	r3, #0
 800d1b4:	db11      	blt.n	800d1da <ProcessBufferCertPublicKey+0x12a>
 800d1b6:	68bb      	ldr	r3, [r7, #8]
 800d1b8:	2b00      	cmp	r3, #0
 800d1ba:	d004      	beq.n	800d1c6 <ProcessBufferCertPublicKey+0x116>
 800d1bc:	68bb      	ldr	r3, [r7, #8]
 800d1be:	f9b3 32f6 	ldrsh.w	r3, [r3, #758]	@ 0x2f6
 800d1c2:	461a      	mov	r2, r3
 800d1c4:	e003      	b.n	800d1ce <ProcessBufferCertPublicKey+0x11e>
 800d1c6:	68fb      	ldr	r3, [r7, #12]
 800d1c8:	f9b3 3068 	ldrsh.w	r3, [r3, #104]	@ 0x68
 800d1cc:	461a      	mov	r2, r3
 800d1ce:	697b      	ldr	r3, [r7, #20]
 800d1d0:	429a      	cmp	r2, r3
 800d1d2:	dc02      	bgt.n	800d1da <ProcessBufferCertPublicKey+0x12a>
 800d1d4:	697b      	ldr	r3, [r7, #20]
 800d1d6:	2b20      	cmp	r3, #32
 800d1d8:	dd01      	ble.n	800d1de <ProcessBufferCertPublicKey+0x12e>
 800d1da:	4b11      	ldr	r3, [pc, #68]	@ (800d220 <ProcessBufferCertPublicKey+0x170>)
 800d1dc:	e000      	b.n	800d1e0 <ProcessBufferCertPublicKey+0x130>
 800d1de:	2300      	movs	r3, #0
 800d1e0:	61fb      	str	r3, [r7, #28]
                     ctx->minEccKeySz, (MAX_ECC_BITS + 7) / 8, keySz,
                     ECC_KEY_SIZE_E);
            }
            break;
 800d1e2:	e003      	b.n	800d1ec <ProcessBufferCertPublicKey+0x13c>
            break;
    #endif /* HAVE_DILITHIUM */

        default:
            WOLFSSL_MSG("No key size check done on public key in certificate");
            break;
 800d1e4:	bf00      	nop
 800d1e6:	e002      	b.n	800d1ee <ProcessBufferCertPublicKey+0x13e>
            break;
 800d1e8:	bf00      	nop
 800d1ea:	e000      	b.n	800d1ee <ProcessBufferCertPublicKey+0x13e>
            break;
 800d1ec:	bf00      	nop
    }

    /* Store the type and key size as there may not be a private key set. */
    if (ssl != NULL) {
 800d1ee:	68bb      	ldr	r3, [r7, #8]
 800d1f0:	2b00      	cmp	r3, #0
 800d1f2:	d008      	beq.n	800d206 <ProcessBufferCertPublicKey+0x156>
        ssl->buffers.keyType = keyType;
 800d1f4:	68bb      	ldr	r3, [r7, #8]
 800d1f6:	7efa      	ldrb	r2, [r7, #27]
 800d1f8:	f883 2174 	strb.w	r2, [r3, #372]	@ 0x174
        ssl->buffers.keySz = keySz;
 800d1fc:	697a      	ldr	r2, [r7, #20]
 800d1fe:	68bb      	ldr	r3, [r7, #8]
 800d200:	f8c3 2178 	str.w	r2, [r3, #376]	@ 0x178
 800d204:	e006      	b.n	800d214 <ProcessBufferCertPublicKey+0x164>
    }
    else {
        ctx->privateKeyType = keyType;
 800d206:	68fb      	ldr	r3, [r7, #12]
 800d208:	7efa      	ldrb	r2, [r7, #27]
 800d20a:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
        ctx->privateKeySz = keySz;
 800d20e:	697a      	ldr	r2, [r7, #20]
 800d210:	68fb      	ldr	r3, [r7, #12]
 800d212:	649a      	str	r2, [r3, #72]	@ 0x48
    }

    return ret;
 800d214:	69fb      	ldr	r3, [r7, #28]
}
 800d216:	4618      	mov	r0, r3
 800d218:	3720      	adds	r7, #32
 800d21a:	46bd      	mov	sp, r7
 800d21c:	bd80      	pop	{r7, pc}
 800d21e:	bf00      	nop
 800d220:	fffffe66 	.word	0xfffffe66

0800d224 <ProcessBufferCert>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  WOLFSSL_BAD_FILE when decoding certificate fails.
 */
static int ProcessBufferCert(WOLFSSL_CTX* ctx, WOLFSSL* ssl, DerBuffer* der)
{
 800d224:	b580      	push	{r7, lr}
 800d226:	b08c      	sub	sp, #48	@ 0x30
 800d228:	af02      	add	r7, sp, #8
 800d22a:	60f8      	str	r0, [r7, #12]
 800d22c:	60b9      	str	r1, [r7, #8]
 800d22e:	607a      	str	r2, [r7, #4]
    int ret = 0;
 800d230:	2300      	movs	r3, #0
 800d232:	627b      	str	r3, [r7, #36]	@ 0x24
    void* heap = WOLFSSL_HEAP(ctx, ssl);
 800d234:	68fb      	ldr	r3, [r7, #12]
 800d236:	2b00      	cmp	r3, #0
 800d238:	d002      	beq.n	800d240 <ProcessBufferCert+0x1c>
 800d23a:	68fb      	ldr	r3, [r7, #12]
 800d23c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800d23e:	e007      	b.n	800d250 <ProcessBufferCert+0x2c>
 800d240:	68bb      	ldr	r3, [r7, #8]
 800d242:	2b00      	cmp	r3, #0
 800d244:	d003      	beq.n	800d24e <ProcessBufferCert+0x2a>
 800d246:	68bb      	ldr	r3, [r7, #8]
 800d248:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d24c:	e000      	b.n	800d250 <ProcessBufferCert+0x2c>
 800d24e:	2300      	movs	r3, #0
 800d250:	61fb      	str	r3, [r7, #28]
    DecodedCert  cert[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    /* Allocate memory for certificate to be decoded into. */
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), heap, DYNAMIC_TYPE_DCERT);
 800d252:	f44f 6097 	mov.w	r0, #1208	@ 0x4b8
 800d256:	f011 fc1d 	bl	801ea94 <wolfSSL_Malloc>
 800d25a:	61b8      	str	r0, [r7, #24]
    if (cert == NULL) {
 800d25c:	69bb      	ldr	r3, [r7, #24]
 800d25e:	2b00      	cmp	r3, #0
 800d260:	d102      	bne.n	800d268 <ProcessBufferCert+0x44>
        ret = MEMORY_E;
 800d262:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800d266:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    if (ret == 0)
 800d268:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d26a:	2b00      	cmp	r3, #0
 800d26c:	d144      	bne.n	800d2f8 <ProcessBufferCert+0xd4>
#endif
    {
        /* Get device id from SSL context or SSL object. */
        int devId = wolfSSL_CTX_GetDevId(ctx, ssl);
 800d26e:	68b9      	ldr	r1, [r7, #8]
 800d270:	68f8      	ldr	r0, [r7, #12]
 800d272:	f7fe ffa2 	bl	800c1ba <wolfSSL_CTX_GetDevId>
 800d276:	6178      	str	r0, [r7, #20]

        WOLFSSL_MSG("Checking cert signature type");
        /* Initialize certificate object. */
        InitDecodedCert_ex(cert, der->buffer, der->length, heap, devId);
 800d278:	687b      	ldr	r3, [r7, #4]
 800d27a:	6819      	ldr	r1, [r3, #0]
 800d27c:	687b      	ldr	r3, [r7, #4]
 800d27e:	689a      	ldr	r2, [r3, #8]
 800d280:	697b      	ldr	r3, [r7, #20]
 800d282:	9300      	str	r3, [sp, #0]
 800d284:	69fb      	ldr	r3, [r7, #28]
 800d286:	69b8      	ldr	r0, [r7, #24]
 800d288:	f007 ff45 	bl	8015116 <InitDecodedCert_ex>

        /* Decode up to and including public key. */
        if (DecodeToKey(cert, 0) < 0) {
 800d28c:	2100      	movs	r1, #0
 800d28e:	69b8      	ldr	r0, [r7, #24]
 800d290:	f008 fddc 	bl	8015e4c <DecodeToKey>
 800d294:	4603      	mov	r3, r0
 800d296:	2b00      	cmp	r3, #0
 800d298:	da02      	bge.n	800d2a0 <ProcessBufferCert+0x7c>
            WOLFSSL_MSG("Decode to key failed");
            ret = WOLFSSL_BAD_FILE;
 800d29a:	f46f 73e7 	mvn.w	r3, #462	@ 0x1ce
 800d29e:	627b      	str	r3, [r7, #36]	@ 0x24
        }
        if (ret == 0) {
 800d2a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d2a2:	2b00      	cmp	r3, #0
 800d2a4:	d128      	bne.n	800d2f8 <ProcessBufferCert+0xd4>
            int checkKeySz = 1;
 800d2a6:	2301      	movs	r3, #1
 800d2a8:	623b      	str	r3, [r7, #32]
            /* Store whether the crtificate is a raw public key. */
            rpkState->isRPKLoaded = cert->isRPK;
        #endif /* HAVE_RPK */

            /* Set which private key algorithm we have. */
            ProcessBufferCertSetHave(ctx, ssl, cert);
 800d2aa:	69ba      	ldr	r2, [r7, #24]
 800d2ac:	68b9      	ldr	r1, [r7, #8]
 800d2ae:	68f8      	ldr	r0, [r7, #12]
 800d2b0:	f7ff fe96 	bl	800cfe0 <ProcessBufferCertSetHave>

            /* Don't check if verification is disabled for SSL. */
            if ((ssl != NULL) && ssl->options.verifyNone) {
 800d2b4:	68bb      	ldr	r3, [r7, #8]
 800d2b6:	2b00      	cmp	r3, #0
 800d2b8:	d00a      	beq.n	800d2d0 <ProcessBufferCert+0xac>
 800d2ba:	68bb      	ldr	r3, [r7, #8]
 800d2bc:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800d2c0:	f003 0308 	and.w	r3, r3, #8
 800d2c4:	b2db      	uxtb	r3, r3
 800d2c6:	2b00      	cmp	r3, #0
 800d2c8:	d002      	beq.n	800d2d0 <ProcessBufferCert+0xac>
                checkKeySz = 0;
 800d2ca:	2300      	movs	r3, #0
 800d2cc:	623b      	str	r3, [r7, #32]
 800d2ce:	e00c      	b.n	800d2ea <ProcessBufferCert+0xc6>
            }
            /* Don't check if no SSL object verification is disabled for SSL
             * context. */
            else if ((ssl == NULL) && ctx->verifyNone) {
 800d2d0:	68bb      	ldr	r3, [r7, #8]
 800d2d2:	2b00      	cmp	r3, #0
 800d2d4:	d109      	bne.n	800d2ea <ProcessBufferCert+0xc6>
 800d2d6:	68fb      	ldr	r3, [r7, #12]
 800d2d8:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
 800d2dc:	f003 0302 	and.w	r3, r3, #2
 800d2e0:	b2db      	uxtb	r3, r3
 800d2e2:	2b00      	cmp	r3, #0
 800d2e4:	d001      	beq.n	800d2ea <ProcessBufferCert+0xc6>
                checkKeySz = 0;
 800d2e6:	2300      	movs	r3, #0
 800d2e8:	623b      	str	r3, [r7, #32]
            }

            /* Check public key size. */
            ret = ProcessBufferCertPublicKey(ctx, ssl, cert, checkKeySz);
 800d2ea:	6a3b      	ldr	r3, [r7, #32]
 800d2ec:	69ba      	ldr	r2, [r7, #24]
 800d2ee:	68b9      	ldr	r1, [r7, #8]
 800d2f0:	68f8      	ldr	r0, [r7, #12]
 800d2f2:	f7ff fedd 	bl	800d0b0 <ProcessBufferCertPublicKey>
 800d2f6:	6278      	str	r0, [r7, #36]	@ 0x24
        #endif
        }
    }

    /* Dispose of dynamic memory in certificate object. */
    FreeDecodedCert(cert);
 800d2f8:	69b8      	ldr	r0, [r7, #24]
 800d2fa:	f007 ffd1 	bl	80152a0 <FreeDecodedCert>
#ifdef WOLFSSL_SMALL_STACK
    /* Dispose of certificate object. */
    XFREE(cert, heap, DYNAMIC_TYPE_DCERT);
 800d2fe:	69bb      	ldr	r3, [r7, #24]
 800d300:	613b      	str	r3, [r7, #16]
 800d302:	693b      	ldr	r3, [r7, #16]
 800d304:	2b00      	cmp	r3, #0
 800d306:	d002      	beq.n	800d30e <ProcessBufferCert+0xea>
 800d308:	6938      	ldr	r0, [r7, #16]
 800d30a:	f011 fbdf 	bl	801eacc <wolfSSL_Free>
#endif
    return ret;
 800d30e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800d310:	4618      	mov	r0, r3
 800d312:	3728      	adds	r7, #40	@ 0x28
 800d314:	46bd      	mov	sp, r7
 800d316:	bd80      	pop	{r7, pc}

0800d318 <ProcessBufferCertHandleDer>:
 * @return  BAD_FUNC_ARG when type is CA_TYPE and ctx is NULL.
 * @return  WOLFSSL_BAD_CERTTYPE when data type is not supported.
 */
static int ProcessBufferCertHandleDer(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    DerBuffer* der, int type, int verify)
{
 800d318:	b580      	push	{r7, lr}
 800d31a:	b086      	sub	sp, #24
 800d31c:	af00      	add	r7, sp, #0
 800d31e:	60f8      	str	r0, [r7, #12]
 800d320:	60b9      	str	r1, [r7, #8]
 800d322:	607a      	str	r2, [r7, #4]
 800d324:	603b      	str	r3, [r7, #0]
    int ret = 0;
 800d326:	2300      	movs	r3, #0
 800d328:	617b      	str	r3, [r7, #20]

    /* CA certificate to verify with. */
    if (type == CA_TYPE) {
 800d32a:	683b      	ldr	r3, [r7, #0]
 800d32c:	2b06      	cmp	r3, #6
 800d32e:	d10d      	bne.n	800d34c <ProcessBufferCertHandleDer+0x34>
        /* verify CA unless user set to no verify */
        ret = AddCA(ctx->cm, &der, WOLFSSL_USER_CA, verify);
 800d330:	68fb      	ldr	r3, [r7, #12]
 800d332:	6d18      	ldr	r0, [r3, #80]	@ 0x50
 800d334:	1d39      	adds	r1, r7, #4
 800d336:	6a3b      	ldr	r3, [r7, #32]
 800d338:	2201      	movs	r2, #1
 800d33a:	f7ff f8d9 	bl	800c4f0 <AddCA>
 800d33e:	6178      	str	r0, [r7, #20]
        if (ret == 1) {
 800d340:	697b      	ldr	r3, [r7, #20]
 800d342:	2b01      	cmp	r3, #1
 800d344:	d12f      	bne.n	800d3a6 <ProcessBufferCertHandleDer+0x8e>
            ret = 0;
 800d346:	2300      	movs	r3, #0
 800d348:	617b      	str	r3, [r7, #20]
 800d34a:	e02c      	b.n	800d3a6 <ProcessBufferCertHandleDer+0x8e>
            WOLFSSL_MSG("Error adding trusted peer");
        }
    }
#endif /* WOLFSSL_TRUST_PEER_CERT */
    /* Leaf certificate - our certificate. */
    else if (type == CERT_TYPE) {
 800d34c:	683b      	ldr	r3, [r7, #0]
 800d34e:	2b00      	cmp	r3, #0
 800d350:	d122      	bne.n	800d398 <ProcessBufferCertHandleDer+0x80>
        if (ssl != NULL) {
 800d352:	68bb      	ldr	r3, [r7, #8]
 800d354:	2b00      	cmp	r3, #0
 800d356:	d013      	beq.n	800d380 <ProcessBufferCertHandleDer+0x68>
            /* Free previous certificate if we own it. */
            if (ssl->buffers.weOwnCert) {
 800d358:	68bb      	ldr	r3, [r7, #8]
 800d35a:	f893 3144 	ldrb.w	r3, [r3, #324]	@ 0x144
 800d35e:	2b00      	cmp	r3, #0
 800d360:	d005      	beq.n	800d36e <ProcessBufferCertHandleDer+0x56>
                FreeDer(&ssl->buffers.certificate);
 800d362:	68bb      	ldr	r3, [r7, #8]
 800d364:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 800d368:	4618      	mov	r0, r3
 800d36a:	f00b fe0d 	bl	8018f88 <FreeDer>
                wolfSSL_X509_free(ssl->ourCert);
                ssl->ourCert = NULL;
            #endif
            }
            /* Store certificate as ours. */
            ssl->buffers.certificate = der;
 800d36e:	687a      	ldr	r2, [r7, #4]
 800d370:	68bb      	ldr	r3, [r7, #8]
 800d372:	f8c3 216c 	str.w	r2, [r3, #364]	@ 0x16c
        #ifdef KEEP_OUR_CERT
            ssl->keepCert = 1; /* hold cert for ssl lifetime */
        #endif
            /* We have to free the certificate buffer. */
            ssl->buffers.weOwnCert = 1;
 800d376:	68bb      	ldr	r3, [r7, #8]
 800d378:	2201      	movs	r2, #1
 800d37a:	f883 2144 	strb.w	r2, [r3, #324]	@ 0x144
 800d37e:	e012      	b.n	800d3a6 <ProcessBufferCertHandleDer+0x8e>
            /* ourCert is created on demand. */
        }
        else if (ctx != NULL) {
 800d380:	68fb      	ldr	r3, [r7, #12]
 800d382:	2b00      	cmp	r3, #0
 800d384:	d00f      	beq.n	800d3a6 <ProcessBufferCertHandleDer+0x8e>
            /* Free previous certificate. */
            FreeDer(&ctx->certificate); /* Make sure previous is free'd */
 800d386:	68fb      	ldr	r3, [r7, #12]
 800d388:	3320      	adds	r3, #32
 800d38a:	4618      	mov	r0, r3
 800d38c:	f00b fdfc 	bl	8018f88 <FreeDer>
                wolfSSL_X509_free(ctx->ourCert);
            }
            ctx->ourCert = NULL;
        #endif
            /* Store certificate as ours. */
            ctx->certificate = der;
 800d390:	687a      	ldr	r2, [r7, #4]
 800d392:	68fb      	ldr	r3, [r7, #12]
 800d394:	621a      	str	r2, [r3, #32]
 800d396:	e006      	b.n	800d3a6 <ProcessBufferCertHandleDer+0x8e>
            /* ourCert is created on demand. */
        }
    }
    else {
        /* Dispose of DER buffer. */
        FreeDer(&der);
 800d398:	1d3b      	adds	r3, r7, #4
 800d39a:	4618      	mov	r0, r3
 800d39c:	f00b fdf4 	bl	8018f88 <FreeDer>
        /* Not a certificate type supported. */
        ret = WOLFSSL_BAD_CERTTYPE;
 800d3a0:	f46f 73e5 	mvn.w	r3, #458	@ 0x1ca
 800d3a4:	617b      	str	r3, [r7, #20]
    }

    return ret;
 800d3a6:	697b      	ldr	r3, [r7, #20]
}
 800d3a8:	4618      	mov	r0, r3
 800d3aa:	3718      	adds	r7, #24
 800d3ac:	46bd      	mov	sp, r7
 800d3ae:	bd80      	pop	{r7, pc}

0800d3b0 <ProcessBufferCertTypes>:
 * @return  WOLFSSL_FATAL_ERROR on failure.
 */
static int ProcessBufferCertTypes(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const unsigned char* buff, long sz, DerBuffer* der, int format, int type,
    int verify)
{
 800d3b0:	b580      	push	{r7, lr}
 800d3b2:	b088      	sub	sp, #32
 800d3b4:	af02      	add	r7, sp, #8
 800d3b6:	60f8      	str	r0, [r7, #12]
 800d3b8:	60b9      	str	r1, [r7, #8]
 800d3ba:	607a      	str	r2, [r7, #4]
 800d3bc:	603b      	str	r3, [r7, #0]

    (void)buff;
    (void)sz;
    (void)format;

    ret = ProcessBufferCertHandleDer(ctx, ssl, der, type, verify);
 800d3be:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d3c0:	9300      	str	r3, [sp, #0]
 800d3c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d3c4:	6a3a      	ldr	r2, [r7, #32]
 800d3c6:	68b9      	ldr	r1, [r7, #8]
 800d3c8:	68f8      	ldr	r0, [r7, #12]
 800d3ca:	f7ff ffa5 	bl	800d318 <ProcessBufferCertHandleDer>
 800d3ce:	6178      	str	r0, [r7, #20]
    if ((ret == 0) && (type == CERT_TYPE)) {
 800d3d0:	697b      	ldr	r3, [r7, #20]
 800d3d2:	2b00      	cmp	r3, #0
 800d3d4:	d108      	bne.n	800d3e8 <ProcessBufferCertTypes+0x38>
 800d3d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d3d8:	2b00      	cmp	r3, #0
 800d3da:	d105      	bne.n	800d3e8 <ProcessBufferCertTypes+0x38>
        /* Process leaf certificate. */
        ret = ProcessBufferCert(ctx, ssl, der);
 800d3dc:	6a3a      	ldr	r2, [r7, #32]
 800d3de:	68b9      	ldr	r1, [r7, #8]
 800d3e0:	68f8      	ldr	r0, [r7, #12]
 800d3e2:	f7ff ff1f 	bl	800d224 <ProcessBufferCert>
 800d3e6:	6178      	str	r0, [r7, #20]
    }
#if !defined(NO_WOLFSSL_CM_VERIFY) && (!defined(NO_WOLFSSL_CLIENT) || \
    !defined(WOLFSSL_NO_CLIENT_AUTH))
    /* Hand bad CA or user certificate to callback. */
    if ((ret < 0) && ((type == CA_TYPE) || (type == CERT_TYPE))) {
 800d3e8:	697b      	ldr	r3, [r7, #20]
 800d3ea:	2b00      	cmp	r3, #0
 800d3ec:	da26      	bge.n	800d43c <ProcessBufferCertTypes+0x8c>
 800d3ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d3f0:	2b06      	cmp	r3, #6
 800d3f2:	d002      	beq.n	800d3fa <ProcessBufferCertTypes+0x4a>
 800d3f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d3f6:	2b00      	cmp	r3, #0
 800d3f8:	d120      	bne.n	800d43c <ProcessBufferCertTypes+0x8c>
        /* Check for verification callback that may override error. */
        if ((ctx != NULL) && (ctx->cm != NULL) &&
 800d3fa:	68fb      	ldr	r3, [r7, #12]
 800d3fc:	2b00      	cmp	r3, #0
 800d3fe:	d01d      	beq.n	800d43c <ProcessBufferCertTypes+0x8c>
 800d400:	68fb      	ldr	r3, [r7, #12]
 800d402:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d404:	2b00      	cmp	r3, #0
 800d406:	d019      	beq.n	800d43c <ProcessBufferCertTypes+0x8c>
                (ctx->cm->verifyCallback != NULL)) {
 800d408:	68fb      	ldr	r3, [r7, #12]
 800d40a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d40c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
        if ((ctx != NULL) && (ctx->cm != NULL) &&
 800d40e:	2b00      	cmp	r3, #0
 800d410:	d014      	beq.n	800d43c <ProcessBufferCertTypes+0x8c>
            /* Verify and use callback. */
            ret = CM_VerifyBuffer_ex(ctx->cm, buff, sz, format, ret);
 800d412:	68fb      	ldr	r3, [r7, #12]
 800d414:	6d18      	ldr	r0, [r3, #80]	@ 0x50
 800d416:	697b      	ldr	r3, [r7, #20]
 800d418:	9300      	str	r3, [sp, #0]
 800d41a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d41c:	683a      	ldr	r2, [r7, #0]
 800d41e:	6879      	ldr	r1, [r7, #4]
 800d420:	f7fe f913 	bl	800b64a <CM_VerifyBuffer_ex>
 800d424:	6178      	str	r0, [r7, #20]
            /* Convert error. */
            if (ret == 0) {
 800d426:	697b      	ldr	r3, [r7, #20]
 800d428:	2b00      	cmp	r3, #0
 800d42a:	d102      	bne.n	800d432 <ProcessBufferCertTypes+0x82>
                ret = WOLFSSL_FATAL_ERROR;
 800d42c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d430:	617b      	str	r3, [r7, #20]
            }
            if (ret == 1) {
 800d432:	697b      	ldr	r3, [r7, #20]
 800d434:	2b01      	cmp	r3, #1
 800d436:	d101      	bne.n	800d43c <ProcessBufferCertTypes+0x8c>
                ret = 0;
 800d438:	2300      	movs	r3, #0
 800d43a:	617b      	str	r3, [r7, #20]
            }
        }
    }
#endif /* NO_WOLFSSL_CM_VERIFY */

    return ret;
 800d43c:	697b      	ldr	r3, [r7, #20]
}
 800d43e:	4618      	mov	r0, r3
 800d440:	3718      	adds	r7, #24
 800d442:	46bd      	mov	sp, r7
 800d444:	bd80      	pop	{r7, pc}

0800d446 <ProcessBufferResetSuites>:
 * @param [in]      type    Type of certificate.
 * @return  0 on success.
 * @return  WOLFSSL_FATAL_ERROR when allocation fails.
 */
static int ProcessBufferResetSuites(WOLFSSL_CTX* ctx, WOLFSSL* ssl, int type)
{
 800d446:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d448:	b095      	sub	sp, #84	@ 0x54
 800d44a:	af0c      	add	r7, sp, #48	@ 0x30
 800d44c:	6178      	str	r0, [r7, #20]
 800d44e:	6139      	str	r1, [r7, #16]
 800d450:	60fa      	str	r2, [r7, #12]
    int ret = 0;
 800d452:	2300      	movs	r3, #0
 800d454:	61fb      	str	r3, [r7, #28]

    /* Reset suites of SSL object. */
    if (ssl != NULL) {
 800d456:	693b      	ldr	r3, [r7, #16]
 800d458:	2b00      	cmp	r3, #0
 800d45a:	d05f      	beq.n	800d51c <ProcessBufferResetSuites+0xd6>
        if (ssl->options.side == WOLFSSL_SERVER_END) {
 800d45c:	693b      	ldr	r3, [r7, #16]
 800d45e:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800d462:	f003 0303 	and.w	r3, r3, #3
 800d466:	b2db      	uxtb	r3, r3
 800d468:	2b00      	cmp	r3, #0
 800d46a:	f040 80ad 	bne.w	800d5c8 <ProcessBufferResetSuites+0x182>
            /* Allocate memory for suites. */
            if (AllocateSuites(ssl) != 0) {
 800d46e:	6938      	ldr	r0, [r7, #16]
 800d470:	f7fb fdc0 	bl	8008ff4 <AllocateSuites>
 800d474:	4603      	mov	r3, r0
 800d476:	2b00      	cmp	r3, #0
 800d478:	d003      	beq.n	800d482 <ProcessBufferResetSuites+0x3c>
                ret = WOLFSSL_FATAL_ERROR;
 800d47a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d47e:	61fb      	str	r3, [r7, #28]
 800d480:	e0a2      	b.n	800d5c8 <ProcessBufferResetSuites+0x182>
            }
            else {
                /* Determine cipher suites based on what we have. */
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d482:	693b      	ldr	r3, [r7, #16]
 800d484:	6858      	ldr	r0, [r3, #4]
 800d486:	693b      	ldr	r3, [r7, #16]
 800d488:	f8d3 2178 	ldr.w	r2, [r3, #376]	@ 0x178
                    WOLFSSL_HAVE_RSA, SSL_HAVE_PSK(ssl), ssl->options.haveDH,
 800d48c:	693b      	ldr	r3, [r7, #16]
 800d48e:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d492:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800d496:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d498:	461c      	mov	r4, r3
                    ssl->options.haveECDSAsig, ssl->options.haveECC, TRUE,
 800d49a:	693b      	ldr	r3, [r7, #16]
 800d49c:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d4a0:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800d4a4:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d4a6:	461d      	mov	r5, r3
                    ssl->options.haveECDSAsig, ssl->options.haveECC, TRUE,
 800d4a8:	693b      	ldr	r3, [r7, #16]
 800d4aa:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d4ae:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800d4b2:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d4b4:	461e      	mov	r6, r3
                    ssl->options.haveStaticECC,
 800d4b6:	693b      	ldr	r3, [r7, #16]
 800d4b8:	f893 32d3 	ldrb.w	r3, [r3, #723]	@ 0x2d3
 800d4bc:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d4c0:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d4c2:	60bb      	str	r3, [r7, #8]
                    ssl->options.useAnon, TRUE,
 800d4c4:	693b      	ldr	r3, [r7, #16]
 800d4c6:	f893 32d5 	ldrb.w	r3, [r3, #725]	@ 0x2d5
 800d4ca:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d4ce:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d4d0:	607b      	str	r3, [r7, #4]
                    TRUE, TRUE, TRUE, ssl->options.side);
 800d4d2:	693b      	ldr	r3, [r7, #16]
 800d4d4:	f893 32d1 	ldrb.w	r3, [r3, #721]	@ 0x2d1
 800d4d8:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800d4dc:	b2db      	uxtb	r3, r3
                InitSuites(ssl->suites, ssl->version, ssl->buffers.keySz,
 800d4de:	4619      	mov	r1, r3
 800d4e0:	693b      	ldr	r3, [r7, #16]
 800d4e2:	910b      	str	r1, [sp, #44]	@ 0x2c
 800d4e4:	2101      	movs	r1, #1
 800d4e6:	910a      	str	r1, [sp, #40]	@ 0x28
 800d4e8:	2101      	movs	r1, #1
 800d4ea:	9109      	str	r1, [sp, #36]	@ 0x24
 800d4ec:	2101      	movs	r1, #1
 800d4ee:	9108      	str	r1, [sp, #32]
 800d4f0:	2101      	movs	r1, #1
 800d4f2:	9107      	str	r1, [sp, #28]
 800d4f4:	6879      	ldr	r1, [r7, #4]
 800d4f6:	9106      	str	r1, [sp, #24]
 800d4f8:	68b9      	ldr	r1, [r7, #8]
 800d4fa:	9105      	str	r1, [sp, #20]
 800d4fc:	2101      	movs	r1, #1
 800d4fe:	9104      	str	r1, [sp, #16]
 800d500:	9603      	str	r6, [sp, #12]
 800d502:	9502      	str	r5, [sp, #8]
 800d504:	9401      	str	r4, [sp, #4]
 800d506:	2100      	movs	r1, #0
 800d508:	9100      	str	r1, [sp, #0]
 800d50a:	f8b3 31da 	ldrh.w	r3, [r3, #474]	@ 0x1da
 800d50e:	2100      	movs	r1, #0
 800d510:	f363 010f 	bfi	r1, r3, #0, #16
 800d514:	2301      	movs	r3, #1
 800d516:	f7fb fda4 	bl	8009062 <InitSuites>
 800d51a:	e055      	b.n	800d5c8 <ProcessBufferResetSuites+0x182>
            }
        }
    }
    /* Reset suites of SSL context object. */
    else if ((type == CERT_TYPE) && (ctx->method->side == WOLFSSL_SERVER_END)) {
 800d51c:	68fb      	ldr	r3, [r7, #12]
 800d51e:	2b00      	cmp	r3, #0
 800d520:	d152      	bne.n	800d5c8 <ProcessBufferResetSuites+0x182>
 800d522:	697b      	ldr	r3, [r7, #20]
 800d524:	681b      	ldr	r3, [r3, #0]
 800d526:	789b      	ldrb	r3, [r3, #2]
 800d528:	2b00      	cmp	r3, #0
 800d52a:	d14d      	bne.n	800d5c8 <ProcessBufferResetSuites+0x182>
        /* Allocate memory for suites. */
        if (AllocateCtxSuites(ctx) != 0) {
 800d52c:	6978      	ldr	r0, [r7, #20]
 800d52e:	f7fb fd3e 	bl	8008fae <AllocateCtxSuites>
 800d532:	4603      	mov	r3, r0
 800d534:	2b00      	cmp	r3, #0
 800d536:	d003      	beq.n	800d540 <ProcessBufferResetSuites+0xfa>
            ret = WOLFSSL_FATAL_ERROR;
 800d538:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d53c:	61fb      	str	r3, [r7, #28]
 800d53e:	e043      	b.n	800d5c8 <ProcessBufferResetSuites+0x182>
        }
        else {
            /* Determine cipher suites based on what we have. */
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d540:	697b      	ldr	r3, [r7, #20]
 800d542:	6d58      	ldr	r0, [r3, #84]	@ 0x54
 800d544:	697b      	ldr	r3, [r7, #20]
 800d546:	681b      	ldr	r3, [r3, #0]
 800d548:	697a      	ldr	r2, [r7, #20]
 800d54a:	6c94      	ldr	r4, [r2, #72]	@ 0x48
                WOLFSSL_HAVE_RSA, CTX_HAVE_PSK(ctx), ctx->haveDH,
 800d54c:	697a      	ldr	r2, [r7, #20]
 800d54e:	f892 205e 	ldrb.w	r2, [r2, #94]	@ 0x5e
 800d552:	f3c2 1200 	ubfx	r2, r2, #4, #1
 800d556:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d558:	4611      	mov	r1, r2
                ctx->haveECDSAsig, ctx->haveECC, TRUE, ctx->haveStaticECC,
 800d55a:	697a      	ldr	r2, [r7, #20]
 800d55c:	f892 205e 	ldrb.w	r2, [r2, #94]	@ 0x5e
 800d560:	f3c2 1240 	ubfx	r2, r2, #5, #1
 800d564:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d566:	4615      	mov	r5, r2
                ctx->haveECDSAsig, ctx->haveECC, TRUE, ctx->haveStaticECC,
 800d568:	697a      	ldr	r2, [r7, #20]
 800d56a:	f892 205e 	ldrb.w	r2, [r2, #94]	@ 0x5e
 800d56e:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 800d572:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d574:	4616      	mov	r6, r2
                ctx->haveECDSAsig, ctx->haveECC, TRUE, ctx->haveStaticECC,
 800d576:	697a      	ldr	r2, [r7, #20]
 800d578:	f892 205f 	ldrb.w	r2, [r2, #95]	@ 0x5f
 800d57c:	f3c2 0200 	ubfx	r2, r2, #0, #1
 800d580:	b2d2      	uxtb	r2, r2
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d582:	60ba      	str	r2, [r7, #8]
                CTX_USE_ANON(ctx),
                TRUE, TRUE, TRUE, TRUE, ctx->method->side);
 800d584:	697a      	ldr	r2, [r7, #20]
 800d586:	6812      	ldr	r2, [r2, #0]
 800d588:	7892      	ldrb	r2, [r2, #2]
            InitSuites(ctx->suites, ctx->method->version, ctx->privateKeySz,
 800d58a:	920b      	str	r2, [sp, #44]	@ 0x2c
 800d58c:	2201      	movs	r2, #1
 800d58e:	920a      	str	r2, [sp, #40]	@ 0x28
 800d590:	2201      	movs	r2, #1
 800d592:	9209      	str	r2, [sp, #36]	@ 0x24
 800d594:	2201      	movs	r2, #1
 800d596:	9208      	str	r2, [sp, #32]
 800d598:	2201      	movs	r2, #1
 800d59a:	9207      	str	r2, [sp, #28]
 800d59c:	2200      	movs	r2, #0
 800d59e:	9206      	str	r2, [sp, #24]
 800d5a0:	68ba      	ldr	r2, [r7, #8]
 800d5a2:	9205      	str	r2, [sp, #20]
 800d5a4:	2201      	movs	r2, #1
 800d5a6:	9204      	str	r2, [sp, #16]
 800d5a8:	9603      	str	r6, [sp, #12]
 800d5aa:	9502      	str	r5, [sp, #8]
 800d5ac:	9101      	str	r1, [sp, #4]
 800d5ae:	2200      	movs	r2, #0
 800d5b0:	9200      	str	r2, [sp, #0]
 800d5b2:	781a      	ldrb	r2, [r3, #0]
 800d5b4:	785b      	ldrb	r3, [r3, #1]
 800d5b6:	021b      	lsls	r3, r3, #8
 800d5b8:	4313      	orrs	r3, r2
 800d5ba:	2100      	movs	r1, #0
 800d5bc:	f363 010f 	bfi	r1, r3, #0, #16
 800d5c0:	2301      	movs	r3, #1
 800d5c2:	4622      	mov	r2, r4
 800d5c4:	f7fb fd4d 	bl	8009062 <InitSuites>
        }
    }

    return ret;
 800d5c8:	69fb      	ldr	r3, [r7, #28]
}
 800d5ca:	4618      	mov	r0, r3
 800d5cc:	3724      	adds	r7, #36	@ 0x24
 800d5ce:	46bd      	mov	sp, r7
 800d5d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0800d5d4 <ProcessBuffer>:
 * @return  1 on success.
 * @return  Less than 1 on failure.
 */
int ProcessBuffer(WOLFSSL_CTX* ctx, const unsigned char* buff, long sz,
    int format, int type, WOLFSSL* ssl, long* used, int userChain, int verify)
{
 800d5d4:	b580      	push	{r7, lr}
 800d5d6:	b094      	sub	sp, #80	@ 0x50
 800d5d8:	af06      	add	r7, sp, #24
 800d5da:	60f8      	str	r0, [r7, #12]
 800d5dc:	60b9      	str	r1, [r7, #8]
 800d5de:	607a      	str	r2, [r7, #4]
 800d5e0:	603b      	str	r3, [r7, #0]
    DerBuffer*    der = NULL;
 800d5e2:	2300      	movs	r3, #0
 800d5e4:	61bb      	str	r3, [r7, #24]
    int           ret = 0;
 800d5e6:	2300      	movs	r3, #0
 800d5e8:	637b      	str	r3, [r7, #52]	@ 0x34
    void*         heap = WOLFSSL_HEAP(ctx, ssl);
 800d5ea:	68fb      	ldr	r3, [r7, #12]
 800d5ec:	2b00      	cmp	r3, #0
 800d5ee:	d002      	beq.n	800d5f6 <ProcessBuffer+0x22>
 800d5f0:	68fb      	ldr	r3, [r7, #12]
 800d5f2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800d5f4:	e007      	b.n	800d606 <ProcessBuffer+0x32>
 800d5f6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d5f8:	2b00      	cmp	r3, #0
 800d5fa:	d003      	beq.n	800d604 <ProcessBuffer+0x30>
 800d5fc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d5fe:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d602:	e000      	b.n	800d606 <ProcessBuffer+0x32>
 800d604:	2300      	movs	r3, #0
 800d606:	62fb      	str	r3, [r7, #44]	@ 0x2c
#ifdef WOLFSSL_SMALL_STACK
    EncryptedInfo* info = NULL;
 800d608:	2300      	movs	r3, #0
 800d60a:	633b      	str	r3, [r7, #48]	@ 0x30
#else
    EncryptedInfo  info[1];
#endif
    int           algId = 0;
 800d60c:	2300      	movs	r3, #0
 800d60e:	617b      	str	r3, [r7, #20]

    WOLFSSL_ENTER("ProcessBuffer");

    /* Check data format is supported. */
    if ((format != WOLFSSL_FILETYPE_ASN1) && (format != WOLFSSL_FILETYPE_PEM)) {
 800d610:	683b      	ldr	r3, [r7, #0]
 800d612:	2b02      	cmp	r3, #2
 800d614:	d004      	beq.n	800d620 <ProcessBuffer+0x4c>
 800d616:	683b      	ldr	r3, [r7, #0]
 800d618:	2b01      	cmp	r3, #1
 800d61a:	d001      	beq.n	800d620 <ProcessBuffer+0x4c>
        ret = WOLFSSL_BAD_FILETYPE;
 800d61c:	4b77      	ldr	r3, [pc, #476]	@ (800d7fc <ProcessBuffer+0x228>)
 800d61e:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Need an object to store certificate into. */
    if ((ret == 0) && (ctx == NULL) && (ssl == NULL)) {
 800d620:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d622:	2b00      	cmp	r3, #0
 800d624:	d108      	bne.n	800d638 <ProcessBuffer+0x64>
 800d626:	68fb      	ldr	r3, [r7, #12]
 800d628:	2b00      	cmp	r3, #0
 800d62a:	d105      	bne.n	800d638 <ProcessBuffer+0x64>
 800d62c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800d62e:	2b00      	cmp	r3, #0
 800d630:	d102      	bne.n	800d638 <ProcessBuffer+0x64>
        ret = BAD_FUNC_ARG;
 800d632:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800d636:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* CA certificates go into the SSL context object. */
    if ((ret == 0) && (ctx == NULL) && (type == CA_TYPE)) {
 800d638:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d63a:	2b00      	cmp	r3, #0
 800d63c:	d108      	bne.n	800d650 <ProcessBuffer+0x7c>
 800d63e:	68fb      	ldr	r3, [r7, #12]
 800d640:	2b00      	cmp	r3, #0
 800d642:	d105      	bne.n	800d650 <ProcessBuffer+0x7c>
 800d644:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d646:	2b06      	cmp	r3, #6
 800d648:	d102      	bne.n	800d650 <ProcessBuffer+0x7c>
        ret = BAD_FUNC_ARG;
 800d64a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800d64e:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* This API does not handle CHAIN_CERT_TYPE */
    if ((ret == 0) && (type == CHAIN_CERT_TYPE)) {
 800d650:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d652:	2b00      	cmp	r3, #0
 800d654:	d105      	bne.n	800d662 <ProcessBuffer+0x8e>
 800d656:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d658:	2b2a      	cmp	r3, #42	@ 0x2a
 800d65a:	d102      	bne.n	800d662 <ProcessBuffer+0x8e>
        ret = BAD_FUNC_ARG;
 800d65c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800d660:	637b      	str	r3, [r7, #52]	@ 0x34
    }

#ifdef WOLFSSL_SMALL_STACK
    if (ret == 0) {
 800d662:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d664:	2b00      	cmp	r3, #0
 800d666:	d109      	bne.n	800d67c <ProcessBuffer+0xa8>
        /* Allocate memory for encryption information. */
        info = (EncryptedInfo*)XMALLOC(sizeof(EncryptedInfo), heap,
 800d668:	208c      	movs	r0, #140	@ 0x8c
 800d66a:	f011 fa13 	bl	801ea94 <wolfSSL_Malloc>
 800d66e:	6338      	str	r0, [r7, #48]	@ 0x30
            DYNAMIC_TYPE_ENCRYPTEDINFO);
        if (info == NULL) {
 800d670:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d672:	2b00      	cmp	r3, #0
 800d674:	d102      	bne.n	800d67c <ProcessBuffer+0xa8>
            ret = MEMORY_E;
 800d676:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800d67a:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }
#endif
    if (ret == 0) {
 800d67c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d67e:	2b00      	cmp	r3, #0
 800d680:	d127      	bne.n	800d6d2 <ProcessBuffer+0xfe>
        /* Initialize encryption information. */
        XMEMSET(info, 0, sizeof(EncryptedInfo));
 800d682:	228c      	movs	r2, #140	@ 0x8c
 800d684:	2100      	movs	r1, #0
 800d686:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800d688:	f01a ff22 	bl	80284d0 <memset>
            info->passwd_userdata = ctx->passwd_userdata;
        }
    #endif

        /* Get the DER data for a private key or certificate. */
        ret = DataToDerBuffer(buff, (word32)sz, format, type, info, heap, &der,
 800d68c:	6879      	ldr	r1, [r7, #4]
 800d68e:	f107 0314 	add.w	r3, r7, #20
 800d692:	9303      	str	r3, [sp, #12]
 800d694:	f107 0318 	add.w	r3, r7, #24
 800d698:	9302      	str	r3, [sp, #8]
 800d69a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d69c:	9301      	str	r3, [sp, #4]
 800d69e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d6a0:	9300      	str	r3, [sp, #0]
 800d6a2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d6a4:	683a      	ldr	r2, [r7, #0]
 800d6a6:	68b8      	ldr	r0, [r7, #8]
 800d6a8:	f7ff f8c8 	bl	800c83c <DataToDerBuffer>
 800d6ac:	6378      	str	r0, [r7, #52]	@ 0x34
            &algId);
        if (used != NULL) {
 800d6ae:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800d6b0:	2b00      	cmp	r3, #0
 800d6b2:	d003      	beq.n	800d6bc <ProcessBuffer+0xe8>
            /* Update to amount used/consumed. */
            *used = info->consumed;
 800d6b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d6b6:	681a      	ldr	r2, [r3, #0]
 800d6b8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800d6ba:	601a      	str	r2, [r3, #0]
        }
    #ifdef WOLFSSL_SMALL_STACK
        if (ret != 0) {
 800d6bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d6be:	2b00      	cmp	r3, #0
 800d6c0:	d007      	beq.n	800d6d2 <ProcessBuffer+0xfe>
             /* Info no longer needed as loading failed. */
             XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d6c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d6c4:	62bb      	str	r3, [r7, #40]	@ 0x28
 800d6c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d6c8:	2b00      	cmp	r3, #0
 800d6ca:	d002      	beq.n	800d6d2 <ProcessBuffer+0xfe>
 800d6cc:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800d6ce:	f011 f9fd 	bl	801eacc <wolfSSL_Free>
        }
    #endif
    }

    if ((ret == 0) && IS_PRIVKEY_TYPE(type)) {
 800d6d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d6d4:	2b00      	cmp	r3, #0
 800d6d6:	d11a      	bne.n	800d70e <ProcessBuffer+0x13a>
 800d6d8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d6da:	2b01      	cmp	r3, #1
 800d6dc:	d117      	bne.n	800d70e <ProcessBuffer+0x13a>
        /* Process the private key. */
        ret = ProcessBufferPrivateKey(ctx, ssl, der, format, info, heap, type,
 800d6de:	69ba      	ldr	r2, [r7, #24]
 800d6e0:	697b      	ldr	r3, [r7, #20]
 800d6e2:	9303      	str	r3, [sp, #12]
 800d6e4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d6e6:	9302      	str	r3, [sp, #8]
 800d6e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d6ea:	9301      	str	r3, [sp, #4]
 800d6ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d6ee:	9300      	str	r3, [sp, #0]
 800d6f0:	683b      	ldr	r3, [r7, #0]
 800d6f2:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d6f4:	68f8      	ldr	r0, [r7, #12]
 800d6f6:	f7ff fbe3 	bl	800cec0 <ProcessBufferPrivateKey>
 800d6fa:	6378      	str	r0, [r7, #52]	@ 0x34
            algId);
    #ifdef WOLFSSL_SMALL_STACK
        /* Info no longer needed - keep max memory usage down. */
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d6fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d6fe:	627b      	str	r3, [r7, #36]	@ 0x24
 800d700:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d702:	2b00      	cmp	r3, #0
 800d704:	d058      	beq.n	800d7b8 <ProcessBuffer+0x1e4>
 800d706:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800d708:	f011 f9e0 	bl	801eacc <wolfSSL_Free>
 800d70c:	e054      	b.n	800d7b8 <ProcessBuffer+0x1e4>
    #endif
    }
    else if (ret == 0) {
 800d70e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d710:	2b00      	cmp	r3, #0
 800d712:	d152      	bne.n	800d7ba <ProcessBuffer+0x1e6>
        /* Processing a certificate. */
        if (userChain) {
 800d714:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d716:	2b00      	cmp	r3, #0
 800d718:	d02d      	beq.n	800d776 <ProcessBuffer+0x1a2>
            /* Take original buffer and add to user chain to send in TLS
             * handshake. */
            ret = ProcessUserChain(ctx, ssl, buff, sz, format, type, used, info,
 800d71a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800d71c:	9304      	str	r3, [sp, #16]
 800d71e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d720:	9303      	str	r3, [sp, #12]
 800d722:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800d724:	9302      	str	r3, [sp, #8]
 800d726:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d728:	9301      	str	r3, [sp, #4]
 800d72a:	683b      	ldr	r3, [r7, #0]
 800d72c:	9300      	str	r3, [sp, #0]
 800d72e:	687b      	ldr	r3, [r7, #4]
 800d730:	68ba      	ldr	r2, [r7, #8]
 800d732:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d734:	68f8      	ldr	r0, [r7, #12]
 800d736:	f7ff f96c 	bl	800ca12 <ProcessUserChain>
 800d73a:	6378      	str	r0, [r7, #52]	@ 0x34
                verify);
            /* Additional chain is optional */
            if (ret == WC_NO_ERR_TRACE(ASN_NO_PEM_HEADER)) {
 800d73c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d73e:	f113 0fa2 	cmn.w	r3, #162	@ 0xa2
 800d742:	d118      	bne.n	800d776 <ProcessBuffer+0x1a2>
                unsigned long pemErr = 0;
 800d744:	2300      	movs	r3, #0
 800d746:	623b      	str	r3, [r7, #32]
                CLEAR_ASN_NO_PEM_HEADER_ERROR(pemErr);
 800d748:	f000 fc88 	bl	800e05c <wolfSSL_ERR_peek_last_error>
 800d74c:	6238      	str	r0, [r7, #32]
 800d74e:	6a38      	ldr	r0, [r7, #32]
 800d750:	f000 fa71 	bl	800dc36 <wolfSSL_ERR_GET_LIB>
 800d754:	4603      	mov	r3, r0
 800d756:	2b09      	cmp	r3, #9
 800d758:	d10b      	bne.n	800d772 <ProcessBuffer+0x19e>
 800d75a:	6a38      	ldr	r0, [r7, #32]
 800d75c:	f000 faa2 	bl	800dca4 <wolfSSL_ERR_GET_REASON>
 800d760:	4603      	mov	r3, r0
 800d762:	f240 12fb 	movw	r2, #507	@ 0x1fb
 800d766:	4293      	cmp	r3, r2
 800d768:	d103      	bne.n	800d772 <ProcessBuffer+0x19e>
 800d76a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 800d76e:	f011 f8eb 	bl	801e948 <wc_RemoveErrorNode>
                ret = 0;
 800d772:	2300      	movs	r3, #0
 800d774:	637b      	str	r3, [r7, #52]	@ 0x34
            }
        }

    #ifdef WOLFSSL_SMALL_STACK
        /* Info no longer needed - keep max memory usage down. */
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d776:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d778:	61fb      	str	r3, [r7, #28]
 800d77a:	69fb      	ldr	r3, [r7, #28]
 800d77c:	2b00      	cmp	r3, #0
 800d77e:	d002      	beq.n	800d786 <ProcessBuffer+0x1b2>
 800d780:	69f8      	ldr	r0, [r7, #28]
 800d782:	f011 f9a3 	bl	801eacc <wolfSSL_Free>
    #endif

        if (ret == 0) {
 800d786:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d788:	2b00      	cmp	r3, #0
 800d78a:	d10f      	bne.n	800d7ac <ProcessBuffer+0x1d8>
            /* Process the different types of certificates. */
            ret = ProcessBufferCertTypes(ctx, ssl, buff, sz, der, format, type,
 800d78c:	69bb      	ldr	r3, [r7, #24]
 800d78e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800d790:	9203      	str	r2, [sp, #12]
 800d792:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800d794:	9202      	str	r2, [sp, #8]
 800d796:	683a      	ldr	r2, [r7, #0]
 800d798:	9201      	str	r2, [sp, #4]
 800d79a:	9300      	str	r3, [sp, #0]
 800d79c:	687b      	ldr	r3, [r7, #4]
 800d79e:	68ba      	ldr	r2, [r7, #8]
 800d7a0:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d7a2:	68f8      	ldr	r0, [r7, #12]
 800d7a4:	f7ff fe04 	bl	800d3b0 <ProcessBufferCertTypes>
 800d7a8:	6378      	str	r0, [r7, #52]	@ 0x34
 800d7aa:	e006      	b.n	800d7ba <ProcessBuffer+0x1e6>
                verify);
        }
        else {
            FreeDer(&der);
 800d7ac:	f107 0318 	add.w	r3, r7, #24
 800d7b0:	4618      	mov	r0, r3
 800d7b2:	f00b fbe9 	bl	8018f88 <FreeDer>
 800d7b6:	e000      	b.n	800d7ba <ProcessBuffer+0x1e6>
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 800d7b8:	bf00      	nop
        }
    }

    /* Reset suites if this is a private key or user certificate. */
    if ((ret == 0) && ((type == PRIVATEKEY_TYPE) || (type == CERT_TYPE))) {
 800d7ba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d7bc:	2b00      	cmp	r3, #0
 800d7be:	d10b      	bne.n	800d7d8 <ProcessBuffer+0x204>
 800d7c0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d7c2:	2b01      	cmp	r3, #1
 800d7c4:	d002      	beq.n	800d7cc <ProcessBuffer+0x1f8>
 800d7c6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d7c8:	2b00      	cmp	r3, #0
 800d7ca:	d105      	bne.n	800d7d8 <ProcessBuffer+0x204>
        ret = ProcessBufferResetSuites(ctx, ssl, type);
 800d7cc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800d7ce:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800d7d0:	68f8      	ldr	r0, [r7, #12]
 800d7d2:	f7ff fe38 	bl	800d446 <ProcessBufferResetSuites>
 800d7d6:	6378      	str	r0, [r7, #52]	@ 0x34
    }

    /* Convert return code. */
    if (ret == 0) {
 800d7d8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d7da:	2b00      	cmp	r3, #0
 800d7dc:	d102      	bne.n	800d7e4 <ProcessBuffer+0x210>
        ret = 1;
 800d7de:	2301      	movs	r3, #1
 800d7e0:	637b      	str	r3, [r7, #52]	@ 0x34
 800d7e2:	e005      	b.n	800d7f0 <ProcessBuffer+0x21c>
    }
    else if (ret == WC_NO_ERR_TRACE(WOLFSSL_FATAL_ERROR)) {
 800d7e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d7e6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 800d7ea:	d101      	bne.n	800d7f0 <ProcessBuffer+0x21c>
        ret = 0;
 800d7ec:	2300      	movs	r3, #0
 800d7ee:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    WOLFSSL_LEAVE("ProcessBuffer", ret);
    return ret;
 800d7f0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 800d7f2:	4618      	mov	r0, r3
 800d7f4:	3738      	adds	r7, #56	@ 0x38
 800d7f6:	46bd      	mov	sp, r7
 800d7f8:	bd80      	pop	{r7, pc}
 800d7fa:	bf00      	nop
 800d7fc:	fffffe32 	.word	0xfffffe32

0800d800 <ProcessChainBuffer>:
 * @return  0 on failure.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int ProcessChainBuffer(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
    const unsigned char* buff, long sz, int type, int verify)
{
 800d800:	b580      	push	{r7, lr}
 800d802:	b08e      	sub	sp, #56	@ 0x38
 800d804:	af06      	add	r7, sp, #24
 800d806:	60f8      	str	r0, [r7, #12]
 800d808:	60b9      	str	r1, [r7, #8]
 800d80a:	607a      	str	r2, [r7, #4]
 800d80c:	603b      	str	r3, [r7, #0]
    int  ret    = 0;
 800d80e:	2300      	movs	r3, #0
 800d810:	61fb      	str	r3, [r7, #28]
    long used   = 0;
 800d812:	2300      	movs	r3, #0
 800d814:	61bb      	str	r3, [r7, #24]
    int  gotOne = 0;
 800d816:	2300      	movs	r3, #0
 800d818:	617b      	str	r3, [r7, #20]

    WOLFSSL_MSG("Processing CA PEM file");
    /* Keep processing file while no errors and data to parse. */
    while ((ret >= 0) && (used < sz)) {
 800d81a:	e03c      	b.n	800d896 <ProcessChainBuffer+0x96>
        long consumed = 0;
 800d81c:	2300      	movs	r3, #0
 800d81e:	613b      	str	r3, [r7, #16]

        /* Process the buffer. */
        ret = ProcessBuffer(ctx, buff + used, sz - used, WOLFSSL_FILETYPE_PEM,
 800d820:	69bb      	ldr	r3, [r7, #24]
 800d822:	687a      	ldr	r2, [r7, #4]
 800d824:	18d1      	adds	r1, r2, r3
 800d826:	683a      	ldr	r2, [r7, #0]
 800d828:	69bb      	ldr	r3, [r7, #24]
 800d82a:	1ad2      	subs	r2, r2, r3
 800d82c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d82e:	9304      	str	r3, [sp, #16]
 800d830:	2300      	movs	r3, #0
 800d832:	9303      	str	r3, [sp, #12]
 800d834:	f107 0310 	add.w	r3, r7, #16
 800d838:	9302      	str	r3, [sp, #8]
 800d83a:	68bb      	ldr	r3, [r7, #8]
 800d83c:	9301      	str	r3, [sp, #4]
 800d83e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d840:	9300      	str	r3, [sp, #0]
 800d842:	2301      	movs	r3, #1
 800d844:	68f8      	ldr	r0, [r7, #12]
 800d846:	f7ff fec5 	bl	800d5d4 <ProcessBuffer>
 800d84a:	61f8      	str	r0, [r7, #28]
            type, ssl, &consumed, 0, verify);
        /* Memory allocation failure is fatal. */
        if (ret == WC_NO_ERR_TRACE(MEMORY_E)) {
 800d84c:	69fb      	ldr	r3, [r7, #28]
 800d84e:	f113 0f7d 	cmn.w	r3, #125	@ 0x7d
 800d852:	d102      	bne.n	800d85a <ProcessChainBuffer+0x5a>
            gotOne = 0;
 800d854:	2300      	movs	r3, #0
 800d856:	617b      	str	r3, [r7, #20]
 800d858:	e019      	b.n	800d88e <ProcessChainBuffer+0x8e>
        }
        /* Other error parsing. */
        else if (ret < 0) {
 800d85a:	69fb      	ldr	r3, [r7, #28]
 800d85c:	2b00      	cmp	r3, #0
 800d85e:	da14      	bge.n	800d88a <ProcessChainBuffer+0x8a>
                ret = 0;
            }
            else
#endif
            /* Check whether we made progress. */
            if (consumed > 0) {
 800d860:	693b      	ldr	r3, [r7, #16]
 800d862:	2b00      	cmp	r3, #0
 800d864:	dd13      	ble.n	800d88e <ProcessChainBuffer+0x8e>
                WOLFSSL_ERROR(ret);
 800d866:	2300      	movs	r3, #0
 800d868:	9300      	str	r3, [sp, #0]
 800d86a:	4b13      	ldr	r3, [pc, #76]	@ (800d8b8 <ProcessChainBuffer+0xb8>)
 800d86c:	f640 1295 	movw	r2, #2453	@ 0x995
 800d870:	4912      	ldr	r1, [pc, #72]	@ (800d8bc <ProcessChainBuffer+0xbc>)
 800d872:	69f8      	ldr	r0, [r7, #28]
 800d874:	f011 f8c2 	bl	801e9fc <WOLFSSL_ERROR_LINE>
                WOLFSSL_MSG("CA Parse failed, with progress in file.");
                WOLFSSL_MSG("Search for other certs in file");
                /* Check if we have more data to parse to recover. */
                if (used + consumed < sz) {
 800d878:	693a      	ldr	r2, [r7, #16]
 800d87a:	69bb      	ldr	r3, [r7, #24]
 800d87c:	4413      	add	r3, r2
 800d87e:	683a      	ldr	r2, [r7, #0]
 800d880:	429a      	cmp	r2, r3
 800d882:	dd04      	ble.n	800d88e <ProcessChainBuffer+0x8e>
                    ret = 0;
 800d884:	2300      	movs	r3, #0
 800d886:	61fb      	str	r3, [r7, #28]
 800d888:	e001      	b.n	800d88e <ProcessChainBuffer+0x8e>
            }
        }
        else {
            /* Got a certificate out. */
            WOLFSSL_MSG("   Processed a CA");
            gotOne = 1;
 800d88a:	2301      	movs	r3, #1
 800d88c:	617b      	str	r3, [r7, #20]
        }
        /* Update used count. */
        used += consumed;
 800d88e:	693b      	ldr	r3, [r7, #16]
 800d890:	69ba      	ldr	r2, [r7, #24]
 800d892:	4413      	add	r3, r2
 800d894:	61bb      	str	r3, [r7, #24]
    while ((ret >= 0) && (used < sz)) {
 800d896:	69fb      	ldr	r3, [r7, #28]
 800d898:	2b00      	cmp	r3, #0
 800d89a:	db03      	blt.n	800d8a4 <ProcessChainBuffer+0xa4>
 800d89c:	69ba      	ldr	r2, [r7, #24]
 800d89e:	683b      	ldr	r3, [r7, #0]
 800d8a0:	429a      	cmp	r2, r3
 800d8a2:	dbbb      	blt.n	800d81c <ProcessChainBuffer+0x1c>
    }

    /* May have other unparsable data but did we get a certificate? */
    if (gotOne) {
 800d8a4:	697b      	ldr	r3, [r7, #20]
 800d8a6:	2b00      	cmp	r3, #0
 800d8a8:	d001      	beq.n	800d8ae <ProcessChainBuffer+0xae>
        WOLFSSL_MSG("Processed at least one valid CA. Other stuff OK");
        ret = 1;
 800d8aa:	2301      	movs	r3, #1
 800d8ac:	61fb      	str	r3, [r7, #28]
    }
    return ret;
 800d8ae:	69fb      	ldr	r3, [r7, #28]
}
 800d8b0:	4618      	mov	r0, r3
 800d8b2:	3720      	adds	r7, #32
 800d8b4:	46bd      	mov	sp, r7
 800d8b6:	bd80      	pop	{r7, pc}
 800d8b8:	08029f34 	.word	0x08029f34
 800d8bc:	080312ec 	.word	0x080312ec

0800d8c0 <wolfSSL_CTX_load_verify_buffer_ex>:
 * @return  0 on failure.
 * @return  Negative on error.
 */
int wolfSSL_CTX_load_verify_buffer_ex(WOLFSSL_CTX* ctx, const unsigned char* in,
    long sz, int format, int userChain, word32 flags)
{
 800d8c0:	b580      	push	{r7, lr}
 800d8c2:	b08c      	sub	sp, #48	@ 0x30
 800d8c4:	af06      	add	r7, sp, #24
 800d8c6:	60f8      	str	r0, [r7, #12]
 800d8c8:	60b9      	str	r1, [r7, #8]
 800d8ca:	607a      	str	r2, [r7, #4]
 800d8cc:	603b      	str	r3, [r7, #0]
    int verify;

    WOLFSSL_ENTER("wolfSSL_CTX_load_verify_buffer_ex");

    /* Get setting on how to verify certificates. */
    verify = GET_VERIFY_SETTING_CTX(ctx);
 800d8ce:	68fb      	ldr	r3, [r7, #12]
 800d8d0:	2b00      	cmp	r3, #0
 800d8d2:	d007      	beq.n	800d8e4 <wolfSSL_CTX_load_verify_buffer_ex+0x24>
 800d8d4:	68fb      	ldr	r3, [r7, #12]
 800d8d6:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
 800d8da:	f003 0302 	and.w	r3, r3, #2
 800d8de:	b2db      	uxtb	r3, r3
 800d8e0:	2b00      	cmp	r3, #0
 800d8e2:	d101      	bne.n	800d8e8 <wolfSSL_CTX_load_verify_buffer_ex+0x28>
 800d8e4:	2301      	movs	r3, #1
 800d8e6:	e000      	b.n	800d8ea <wolfSSL_CTX_load_verify_buffer_ex+0x2a>
 800d8e8:	2300      	movs	r3, #0
 800d8ea:	613b      	str	r3, [r7, #16]
    /* Overwrite setting when flag set. */
    if (flags & WOLFSSL_LOAD_FLAG_DATE_ERR_OKAY) {
 800d8ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d8ee:	f003 0302 	and.w	r3, r3, #2
 800d8f2:	2b00      	cmp	r3, #0
 800d8f4:	d001      	beq.n	800d8fa <wolfSSL_CTX_load_verify_buffer_ex+0x3a>
        verify = VERIFY_SKIP_DATE;
 800d8f6:	2305      	movs	r3, #5
 800d8f8:	613b      	str	r3, [r7, #16]
    }

    /* When PEM, treat as certificate chain of CA certificates. */
    if (format == WOLFSSL_FILETYPE_PEM) {
 800d8fa:	683b      	ldr	r3, [r7, #0]
 800d8fc:	2b01      	cmp	r3, #1
 800d8fe:	d10b      	bne.n	800d918 <wolfSSL_CTX_load_verify_buffer_ex+0x58>
        ret = ProcessChainBuffer(ctx, NULL, in, sz, CA_TYPE, verify);
 800d900:	693b      	ldr	r3, [r7, #16]
 800d902:	9301      	str	r3, [sp, #4]
 800d904:	2306      	movs	r3, #6
 800d906:	9300      	str	r3, [sp, #0]
 800d908:	687b      	ldr	r3, [r7, #4]
 800d90a:	68ba      	ldr	r2, [r7, #8]
 800d90c:	2100      	movs	r1, #0
 800d90e:	68f8      	ldr	r0, [r7, #12]
 800d910:	f7ff ff76 	bl	800d800 <ProcessChainBuffer>
 800d914:	6178      	str	r0, [r7, #20]
 800d916:	e010      	b.n	800d93a <wolfSSL_CTX_load_verify_buffer_ex+0x7a>
    }
    /* When DER, load the CA certificate. */
    else {
        ret = ProcessBuffer(ctx, in, sz, format, CA_TYPE, NULL, NULL,
 800d918:	693b      	ldr	r3, [r7, #16]
 800d91a:	9304      	str	r3, [sp, #16]
 800d91c:	6a3b      	ldr	r3, [r7, #32]
 800d91e:	9303      	str	r3, [sp, #12]
 800d920:	2300      	movs	r3, #0
 800d922:	9302      	str	r3, [sp, #8]
 800d924:	2300      	movs	r3, #0
 800d926:	9301      	str	r3, [sp, #4]
 800d928:	2306      	movs	r3, #6
 800d92a:	9300      	str	r3, [sp, #0]
 800d92c:	683b      	ldr	r3, [r7, #0]
 800d92e:	687a      	ldr	r2, [r7, #4]
 800d930:	68b9      	ldr	r1, [r7, #8]
 800d932:	68f8      	ldr	r0, [r7, #12]
 800d934:	f7ff fe4e 	bl	800d5d4 <ProcessBuffer>
 800d938:	6178      	str	r0, [r7, #20]
        ret = wolfSSL_CTX_trust_peer_buffer(ctx, in, sz, format);
    }
#endif

    WOLFSSL_LEAVE("wolfSSL_CTX_load_verify_buffer_ex", ret);
    return ret;
 800d93a:	697b      	ldr	r3, [r7, #20]
}
 800d93c:	4618      	mov	r0, r3
 800d93e:	3718      	adds	r7, #24
 800d940:	46bd      	mov	sp, r7
 800d942:	bd80      	pop	{r7, pc}

0800d944 <wolfSSL_CTX_load_verify_buffer>:
 * @return  0 on failure.
 * @return  Negative on error.
 */
int wolfSSL_CTX_load_verify_buffer(WOLFSSL_CTX* ctx, const unsigned char* in,
    long sz, int format)
{
 800d944:	b580      	push	{r7, lr}
 800d946:	b086      	sub	sp, #24
 800d948:	af02      	add	r7, sp, #8
 800d94a:	60f8      	str	r0, [r7, #12]
 800d94c:	60b9      	str	r1, [r7, #8]
 800d94e:	607a      	str	r2, [r7, #4]
 800d950:	603b      	str	r3, [r7, #0]
    return wolfSSL_CTX_load_verify_buffer_ex(ctx, in, sz, format, 0,
 800d952:	2300      	movs	r3, #0
 800d954:	9301      	str	r3, [sp, #4]
 800d956:	2300      	movs	r3, #0
 800d958:	9300      	str	r3, [sp, #0]
 800d95a:	683b      	ldr	r3, [r7, #0]
 800d95c:	687a      	ldr	r2, [r7, #4]
 800d95e:	68b9      	ldr	r1, [r7, #8]
 800d960:	68f8      	ldr	r0, [r7, #12]
 800d962:	f7ff ffad 	bl	800d8c0 <wolfSSL_CTX_load_verify_buffer_ex>
 800d966:	4603      	mov	r3, r0
        WOLFSSL_LOAD_VERIFY_DEFAULT_FLAGS);
}
 800d968:	4618      	mov	r0, r3
 800d96a:	3710      	adds	r7, #16
 800d96c:	46bd      	mov	sp, r7
 800d96e:	bd80      	pop	{r7, pc}

0800d970 <wolfSSL_Cleanup>:

#endif /* NO_HANDSHAKE_DONE_CB */

WOLFSSL_ABI
int wolfSSL_Cleanup(void)
{
 800d970:	b580      	push	{r7, lr}
 800d972:	b082      	sub	sp, #8
 800d974:	af00      	add	r7, sp, #0
    int ret = WOLFSSL_SUCCESS; /* Only the first error will be returned */
 800d976:	2301      	movs	r3, #1
 800d978:	607b      	str	r3, [r7, #4]
    int release = 0;
 800d97a:	2300      	movs	r3, #0
 800d97c:	603b      	str	r3, [r7, #0]
#endif

    WOLFSSL_ENTER("wolfSSL_Cleanup");

#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (inits_count_mutex_valid == 1) {
 800d97e:	4b35      	ldr	r3, [pc, #212]	@ (800da54 <wolfSSL_Cleanup+0xe4>)
 800d980:	681b      	ldr	r3, [r3, #0]
 800d982:	2b01      	cmp	r3, #1
 800d984:	d108      	bne.n	800d998 <wolfSSL_Cleanup+0x28>
#endif
        if (wc_LockMutex(&inits_count_mutex) != 0) {
 800d986:	4834      	ldr	r0, [pc, #208]	@ (800da58 <wolfSSL_Cleanup+0xe8>)
 800d988:	f019 fd14 	bl	80273b4 <wc_LockMutex>
 800d98c:	4603      	mov	r3, r0
 800d98e:	2b00      	cmp	r3, #0
 800d990:	d002      	beq.n	800d998 <wolfSSL_Cleanup+0x28>
            WOLFSSL_MSG("Bad Lock Mutex count");
            return BAD_MUTEX_E;
 800d992:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800d996:	e058      	b.n	800da4a <wolfSSL_Cleanup+0xda>
        }
#ifndef WOLFSSL_MUTEX_INITIALIZER
    }
#endif

    if (initRefCount > 0) {
 800d998:	4b30      	ldr	r3, [pc, #192]	@ (800da5c <wolfSSL_Cleanup+0xec>)
 800d99a:	681b      	ldr	r3, [r3, #0]
 800d99c:	2b00      	cmp	r3, #0
 800d99e:	dd0a      	ble.n	800d9b6 <wolfSSL_Cleanup+0x46>
        --initRefCount;
 800d9a0:	4b2e      	ldr	r3, [pc, #184]	@ (800da5c <wolfSSL_Cleanup+0xec>)
 800d9a2:	681b      	ldr	r3, [r3, #0]
 800d9a4:	3b01      	subs	r3, #1
 800d9a6:	4a2d      	ldr	r2, [pc, #180]	@ (800da5c <wolfSSL_Cleanup+0xec>)
 800d9a8:	6013      	str	r3, [r2, #0]
        if (initRefCount == 0)
 800d9aa:	4b2c      	ldr	r3, [pc, #176]	@ (800da5c <wolfSSL_Cleanup+0xec>)
 800d9ac:	681b      	ldr	r3, [r3, #0]
 800d9ae:	2b00      	cmp	r3, #0
 800d9b0:	d101      	bne.n	800d9b6 <wolfSSL_Cleanup+0x46>
            release = 1;
 800d9b2:	2301      	movs	r3, #1
 800d9b4:	603b      	str	r3, [r7, #0]
    }

#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (inits_count_mutex_valid == 1) {
 800d9b6:	4b27      	ldr	r3, [pc, #156]	@ (800da54 <wolfSSL_Cleanup+0xe4>)
 800d9b8:	681b      	ldr	r3, [r3, #0]
 800d9ba:	2b01      	cmp	r3, #1
 800d9bc:	d102      	bne.n	800d9c4 <wolfSSL_Cleanup+0x54>
#endif
        wc_UnLockMutex(&inits_count_mutex);
 800d9be:	4826      	ldr	r0, [pc, #152]	@ (800da58 <wolfSSL_Cleanup+0xe8>)
 800d9c0:	f019 fd03 	bl	80273ca <wc_UnLockMutex>
#ifndef WOLFSSL_MUTEX_INITIALIZER
    }
#endif

    if (!release)
 800d9c4:	683b      	ldr	r3, [r7, #0]
 800d9c6:	2b00      	cmp	r3, #0
 800d9c8:	d101      	bne.n	800d9ce <wolfSSL_Cleanup+0x5e>
        return ret;
 800d9ca:	687b      	ldr	r3, [r7, #4]
 800d9cc:	e03d      	b.n	800da4a <wolfSSL_Cleanup+0xda>
#if defined(WOLFSSL_SYS_CRYPTO_POLICY)
    wolfSSL_crypto_policy_disable();
#endif /* WOLFSSL_SYS_CRYPTO_POLICY */

#ifdef OPENSSL_EXTRA
    wolfSSL_BN_free_one();
 800d9ce:	f7fd ffb7 	bl	800b940 <wolfSSL_BN_free_one>
    #endif
#endif /* !NO_SESSION_CACHE */

#if !defined(WOLFSSL_MUTEX_INITIALIZER) && \
      !WOLFSSL_CLEANUP_THREADSAFE_BY_ATOMIC_OPS
    if ((inits_count_mutex_valid == 1) &&
 800d9d2:	4b20      	ldr	r3, [pc, #128]	@ (800da54 <wolfSSL_Cleanup+0xe4>)
 800d9d4:	681b      	ldr	r3, [r3, #0]
 800d9d6:	2b01      	cmp	r3, #1
 800d9d8:	d10b      	bne.n	800d9f2 <wolfSSL_Cleanup+0x82>
            (wc_FreeMutex(&inits_count_mutex) != 0)) {
 800d9da:	481f      	ldr	r0, [pc, #124]	@ (800da58 <wolfSSL_Cleanup+0xe8>)
 800d9dc:	f019 fcdf 	bl	802739e <wc_FreeMutex>
 800d9e0:	4603      	mov	r3, r0
    if ((inits_count_mutex_valid == 1) &&
 800d9e2:	2b00      	cmp	r3, #0
 800d9e4:	d005      	beq.n	800d9f2 <wolfSSL_Cleanup+0x82>
        if (ret == WOLFSSL_SUCCESS)
 800d9e6:	687b      	ldr	r3, [r7, #4]
 800d9e8:	2b01      	cmp	r3, #1
 800d9ea:	d102      	bne.n	800d9f2 <wolfSSL_Cleanup+0x82>
            ret = BAD_MUTEX_E;
 800d9ec:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800d9f0:	607b      	str	r3, [r7, #4]
    }
    inits_count_mutex_valid = 0;
 800d9f2:	4b18      	ldr	r3, [pc, #96]	@ (800da54 <wolfSSL_Cleanup+0xe4>)
 800d9f4:	2200      	movs	r2, #0
 800d9f6:	601a      	str	r2, [r3, #0]
#endif

#ifdef OPENSSL_EXTRA
    wolfSSL_RAND_Cleanup();
 800d9f8:	f001 fa54 	bl	800eea4 <wolfSSL_RAND_Cleanup>
#endif

    if (wolfCrypt_Cleanup() != 0) {
 800d9fc:	f019 fc60 	bl	80272c0 <wolfCrypt_Cleanup>
 800da00:	4603      	mov	r3, r0
 800da02:	2b00      	cmp	r3, #0
 800da04:	d005      	beq.n	800da12 <wolfSSL_Cleanup+0xa2>
        WOLFSSL_MSG("Error with wolfCrypt_Cleanup call");
        if (ret == WOLFSSL_SUCCESS)
 800da06:	687b      	ldr	r3, [r7, #4]
 800da08:	2b01      	cmp	r3, #1
 800da0a:	d102      	bne.n	800da12 <wolfSSL_Cleanup+0xa2>
            ret = WC_CLEANUP_E;
 800da0c:	f06f 03f0 	mvn.w	r3, #240	@ 0xf0
 800da10:	607b      	str	r3, [r7, #4]
    }
#endif

#ifdef HAVE_GLOBAL_RNG
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if ((globalRNGMutex_valid == 1) && (wc_FreeMutex(&globalRNGMutex) != 0)) {
 800da12:	4b13      	ldr	r3, [pc, #76]	@ (800da60 <wolfSSL_Cleanup+0xf0>)
 800da14:	681b      	ldr	r3, [r3, #0]
 800da16:	2b01      	cmp	r3, #1
 800da18:	d10b      	bne.n	800da32 <wolfSSL_Cleanup+0xc2>
 800da1a:	4812      	ldr	r0, [pc, #72]	@ (800da64 <wolfSSL_Cleanup+0xf4>)
 800da1c:	f019 fcbf 	bl	802739e <wc_FreeMutex>
 800da20:	4603      	mov	r3, r0
 800da22:	2b00      	cmp	r3, #0
 800da24:	d005      	beq.n	800da32 <wolfSSL_Cleanup+0xc2>
        if (ret == WOLFSSL_SUCCESS)
 800da26:	687b      	ldr	r3, [r7, #4]
 800da28:	2b01      	cmp	r3, #1
 800da2a:	d102      	bne.n	800da32 <wolfSSL_Cleanup+0xc2>
            ret = BAD_MUTEX_E;
 800da2c:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800da30:	607b      	str	r3, [r7, #4]
    }
    globalRNGMutex_valid = 0;
 800da32:	4b0b      	ldr	r3, [pc, #44]	@ (800da60 <wolfSSL_Cleanup+0xf0>)
 800da34:	2200      	movs	r2, #0
 800da36:	601a      	str	r2, [r3, #0]
#endif /* !WOLFSSL_MUTEX_INITIALIZER */

    #if defined(OPENSSL_EXTRA) && defined(HAVE_HASHDRBG)
    wolfSSL_FIPS_drbg_free(gDrbgDefCtx);
 800da38:	4b0b      	ldr	r3, [pc, #44]	@ (800da68 <wolfSSL_Cleanup+0xf8>)
 800da3a:	681b      	ldr	r3, [r3, #0]
 800da3c:	4618      	mov	r0, r3
 800da3e:	f001 fbdb 	bl	800f1f8 <wolfSSL_FIPS_drbg_free>
    gDrbgDefCtx = NULL;
 800da42:	4b09      	ldr	r3, [pc, #36]	@ (800da68 <wolfSSL_Cleanup+0xf8>)
 800da44:	2200      	movs	r2, #0
 800da46:	601a      	str	r2, [r3, #0]

#ifdef WOLFSSL_MEM_FAIL_COUNT
    wc_MemFailCount_Free();
#endif

    return ret;
 800da48:	687b      	ldr	r3, [r7, #4]
}
 800da4a:	4618      	mov	r0, r3
 800da4c:	3708      	adds	r7, #8
 800da4e:	46bd      	mov	sp, r7
 800da50:	bd80      	pop	{r7, pc}
 800da52:	bf00      	nop
 800da54:	200026ec 	.word	0x200026ec
 800da58:	200026e8 	.word	0x200026e8
 800da5c:	200026e4 	.word	0x200026e4
 800da60:	200026cc 	.word	0x200026cc
 800da64:	200026c8 	.word	0x200026c8
 800da68:	200026d0 	.word	0x200026d0

0800da6c <wolfSSL_UnloadCertsKeys>:
#ifndef NO_CERTS

    /* unload any certs or keys that SSL owns, leave CTX as is
       WOLFSSL_SUCCESS on ok */
    int wolfSSL_UnloadCertsKeys(WOLFSSL* ssl)
    {
 800da6c:	b580      	push	{r7, lr}
 800da6e:	b082      	sub	sp, #8
 800da70:	af00      	add	r7, sp, #0
 800da72:	6078      	str	r0, [r7, #4]
        if (ssl == NULL) {
 800da74:	687b      	ldr	r3, [r7, #4]
 800da76:	2b00      	cmp	r3, #0
 800da78:	d102      	bne.n	800da80 <wolfSSL_UnloadCertsKeys+0x14>
            WOLFSSL_MSG("Null function arg");
            return BAD_FUNC_ARG;
 800da7a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800da7e:	e040      	b.n	800db02 <wolfSSL_UnloadCertsKeys+0x96>
        }

        if (ssl->buffers.weOwnCert && !ssl->keepCert) {
 800da80:	687b      	ldr	r3, [r7, #4]
 800da82:	f893 3144 	ldrb.w	r3, [r3, #324]	@ 0x144
 800da86:	2b00      	cmp	r3, #0
 800da88:	d010      	beq.n	800daac <wolfSSL_UnloadCertsKeys+0x40>
 800da8a:	687b      	ldr	r3, [r7, #4]
 800da8c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800da90:	f893 3090 	ldrb.w	r3, [r3, #144]	@ 0x90
 800da94:	2b00      	cmp	r3, #0
 800da96:	d109      	bne.n	800daac <wolfSSL_UnloadCertsKeys+0x40>
            WOLFSSL_MSG("Unloading cert");
            FreeDer(&ssl->buffers.certificate);
 800da98:	687b      	ldr	r3, [r7, #4]
 800da9a:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 800da9e:	4618      	mov	r0, r3
 800daa0:	f00b fa72 	bl	8018f88 <FreeDer>
            #ifdef KEEP_OUR_CERT
            wolfSSL_X509_free(ssl->ourCert);
            ssl->ourCert = NULL;
            #endif
            ssl->buffers.weOwnCert = 0;
 800daa4:	687b      	ldr	r3, [r7, #4]
 800daa6:	2200      	movs	r2, #0
 800daa8:	f883 2144 	strb.w	r2, [r3, #324]	@ 0x144
        }

        if (ssl->buffers.weOwnCertChain) {
 800daac:	687b      	ldr	r3, [r7, #4]
 800daae:	f893 3145 	ldrb.w	r3, [r3, #325]	@ 0x145
 800dab2:	2b00      	cmp	r3, #0
 800dab4:	d009      	beq.n	800daca <wolfSSL_UnloadCertsKeys+0x5e>
            WOLFSSL_MSG("Unloading cert chain");
            FreeDer(&ssl->buffers.certChain);
 800dab6:	687b      	ldr	r3, [r7, #4]
 800dab8:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 800dabc:	4618      	mov	r0, r3
 800dabe:	f00b fa63 	bl	8018f88 <FreeDer>
            ssl->buffers.weOwnCertChain = 0;
 800dac2:	687b      	ldr	r3, [r7, #4]
 800dac4:	2200      	movs	r2, #0
 800dac6:	f883 2145 	strb.w	r2, [r3, #325]	@ 0x145
        }

        if (ssl->buffers.weOwnKey) {
 800daca:	687b      	ldr	r3, [r7, #4]
 800dacc:	f893 3146 	ldrb.w	r3, [r3, #326]	@ 0x146
 800dad0:	2b00      	cmp	r3, #0
 800dad2:	d015      	beq.n	800db00 <wolfSSL_UnloadCertsKeys+0x94>
            WOLFSSL_MSG("Unloading key");
            ForceZero(ssl->buffers.key->buffer, ssl->buffers.key->length);
 800dad4:	687b      	ldr	r3, [r7, #4]
 800dad6:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 800dada:	681a      	ldr	r2, [r3, #0]
 800dadc:	687b      	ldr	r3, [r7, #4]
 800dade:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 800dae2:	689b      	ldr	r3, [r3, #8]
 800dae4:	4619      	mov	r1, r3
 800dae6:	4610      	mov	r0, r2
 800dae8:	f7fd fb37 	bl	800b15a <ForceZero>
            FreeDer(&ssl->buffers.key);
 800daec:	687b      	ldr	r3, [r7, #4]
 800daee:	f503 73b8 	add.w	r3, r3, #368	@ 0x170
 800daf2:	4618      	mov	r0, r3
 800daf4:	f00b fa48 	bl	8018f88 <FreeDer>
        #ifdef WOLFSSL_BLIND_PRIVATE_KEY
            FreeDer(&ssl->buffers.keyMask);
        #endif
            ssl->buffers.weOwnKey = 0;
 800daf8:	687b      	ldr	r3, [r7, #4]
 800dafa:	2200      	movs	r2, #0
 800dafc:	f883 2146 	strb.w	r2, [r3, #326]	@ 0x146
        #endif
            ssl->buffers.weOwnAltKey = 0;
        }
#endif /* WOLFSSL_DUAL_ALG_CERTS */

        return WOLFSSL_SUCCESS;
 800db00:	2301      	movs	r3, #1
    }
 800db02:	4618      	mov	r0, r3
 800db04:	3708      	adds	r7, #8
 800db06:	46bd      	mov	sp, r7
 800db08:	bd80      	pop	{r7, pc}
	...

0800db0c <wolfSSL_ERR_sys_func>:
    static const char WOLFSSL_SYS_SETSOCKOPT_T[]    = "setsockopt";
    static const char WOLFSSL_SYS_SOCKET_T[]        = "socket";

    /* switch with int mapped to function name for compatibility */
    static const char* wolfSSL_ERR_sys_func(int fun)
    {
 800db0c:	b480      	push	{r7}
 800db0e:	b083      	sub	sp, #12
 800db10:	af00      	add	r7, sp, #0
 800db12:	6078      	str	r0, [r7, #4]
        switch (fun) {
 800db14:	687b      	ldr	r3, [r7, #4]
 800db16:	2b0f      	cmp	r3, #15
 800db18:	d842      	bhi.n	800dba0 <wolfSSL_ERR_sys_func+0x94>
 800db1a:	a201      	add	r2, pc, #4	@ (adr r2, 800db20 <wolfSSL_ERR_sys_func+0x14>)
 800db1c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800db20:	0800db61 	.word	0x0800db61
 800db24:	0800db65 	.word	0x0800db65
 800db28:	0800db69 	.word	0x0800db69
 800db2c:	0800db6d 	.word	0x0800db6d
 800db30:	0800db71 	.word	0x0800db71
 800db34:	0800db75 	.word	0x0800db75
 800db38:	0800db79 	.word	0x0800db79
 800db3c:	0800db7d 	.word	0x0800db7d
 800db40:	0800db81 	.word	0x0800db81
 800db44:	0800db85 	.word	0x0800db85
 800db48:	0800db89 	.word	0x0800db89
 800db4c:	0800db8d 	.word	0x0800db8d
 800db50:	0800db91 	.word	0x0800db91
 800db54:	0800db95 	.word	0x0800db95
 800db58:	0800db99 	.word	0x0800db99
 800db5c:	0800db9d 	.word	0x0800db9d
            case WOLFSSL_SYS_ACCEPT:      return WOLFSSL_SYS_ACCEPT_T;
 800db60:	4b13      	ldr	r3, [pc, #76]	@ (800dbb0 <wolfSSL_ERR_sys_func+0xa4>)
 800db62:	e01e      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_BIND:        return WOLFSSL_SYS_BIND_T;
 800db64:	4b13      	ldr	r3, [pc, #76]	@ (800dbb4 <wolfSSL_ERR_sys_func+0xa8>)
 800db66:	e01c      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_CONNECT:     return WOLFSSL_SYS_CONNECT_T;
 800db68:	4b13      	ldr	r3, [pc, #76]	@ (800dbb8 <wolfSSL_ERR_sys_func+0xac>)
 800db6a:	e01a      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_FOPEN:       return WOLFSSL_SYS_FOPEN_T;
 800db6c:	4b13      	ldr	r3, [pc, #76]	@ (800dbbc <wolfSSL_ERR_sys_func+0xb0>)
 800db6e:	e018      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_FREAD:       return WOLFSSL_SYS_FREAD_T;
 800db70:	4b13      	ldr	r3, [pc, #76]	@ (800dbc0 <wolfSSL_ERR_sys_func+0xb4>)
 800db72:	e016      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETADDRINFO: return WOLFSSL_SYS_GETADDRINFO_T;
 800db74:	4b13      	ldr	r3, [pc, #76]	@ (800dbc4 <wolfSSL_ERR_sys_func+0xb8>)
 800db76:	e014      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETSOCKOPT:  return WOLFSSL_SYS_GETSOCKOPT_T;
 800db78:	4b13      	ldr	r3, [pc, #76]	@ (800dbc8 <wolfSSL_ERR_sys_func+0xbc>)
 800db7a:	e012      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETSOCKNAME: return WOLFSSL_SYS_GETSOCKNAME_T;
 800db7c:	4b13      	ldr	r3, [pc, #76]	@ (800dbcc <wolfSSL_ERR_sys_func+0xc0>)
 800db7e:	e010      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETHOSTBYNAME: return WOLFSSL_SYS_GETHOSTBYNAME_T;
 800db80:	4b13      	ldr	r3, [pc, #76]	@ (800dbd0 <wolfSSL_ERR_sys_func+0xc4>)
 800db82:	e00e      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETNAMEINFO: return WOLFSSL_SYS_GETNAMEINFO_T;
 800db84:	4b13      	ldr	r3, [pc, #76]	@ (800dbd4 <wolfSSL_ERR_sys_func+0xc8>)
 800db86:	e00c      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_GETSERVBYNAME: return WOLFSSL_SYS_GETSERVBYNAME_T;
 800db88:	4b13      	ldr	r3, [pc, #76]	@ (800dbd8 <wolfSSL_ERR_sys_func+0xcc>)
 800db8a:	e00a      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_IOCTLSOCKET: return WOLFSSL_SYS_IOCTLSOCKET_T;
 800db8c:	4b13      	ldr	r3, [pc, #76]	@ (800dbdc <wolfSSL_ERR_sys_func+0xd0>)
 800db8e:	e008      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_LISTEN:      return WOLFSSL_SYS_LISTEN_T;
 800db90:	4b13      	ldr	r3, [pc, #76]	@ (800dbe0 <wolfSSL_ERR_sys_func+0xd4>)
 800db92:	e006      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_OPENDIR:     return WOLFSSL_SYS_OPENDIR_T;
 800db94:	4b13      	ldr	r3, [pc, #76]	@ (800dbe4 <wolfSSL_ERR_sys_func+0xd8>)
 800db96:	e004      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_SETSOCKOPT:  return WOLFSSL_SYS_SETSOCKOPT_T;
 800db98:	4b13      	ldr	r3, [pc, #76]	@ (800dbe8 <wolfSSL_ERR_sys_func+0xdc>)
 800db9a:	e002      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            case WOLFSSL_SYS_SOCKET:      return WOLFSSL_SYS_SOCKET_T;
 800db9c:	4b13      	ldr	r3, [pc, #76]	@ (800dbec <wolfSSL_ERR_sys_func+0xe0>)
 800db9e:	e000      	b.n	800dba2 <wolfSSL_ERR_sys_func+0x96>
            default:
                return "NULL";
 800dba0:	4b13      	ldr	r3, [pc, #76]	@ (800dbf0 <wolfSSL_ERR_sys_func+0xe4>)
        }
    }
 800dba2:	4618      	mov	r0, r3
 800dba4:	370c      	adds	r7, #12
 800dba6:	46bd      	mov	sp, r7
 800dba8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbac:	4770      	bx	lr
 800dbae:	bf00      	nop
 800dbb0:	08030bd8 	.word	0x08030bd8
 800dbb4:	08030be0 	.word	0x08030be0
 800dbb8:	08030be8 	.word	0x08030be8
 800dbbc:	08030bf0 	.word	0x08030bf0
 800dbc0:	08030bf8 	.word	0x08030bf8
 800dbc4:	08030c00 	.word	0x08030c00
 800dbc8:	08030c0c 	.word	0x08030c0c
 800dbcc:	08030c18 	.word	0x08030c18
 800dbd0:	08030c24 	.word	0x08030c24
 800dbd4:	08030c34 	.word	0x08030c34
 800dbd8:	08030c40 	.word	0x08030c40
 800dbdc:	08030c50 	.word	0x08030c50
 800dbe0:	08030c5c 	.word	0x08030c5c
 800dbe4:	08030c64 	.word	0x08030c64
 800dbe8:	08030c6c 	.word	0x08030c6c
 800dbec:	08030c78 	.word	0x08030c78
 800dbf0:	08029fc4 	.word	0x08029fc4

0800dbf4 <wolfSSL_ERR_put_error>:
#endif /* DEBUG_WOLFSSL */


    void wolfSSL_ERR_put_error(int lib, int fun, int err, const char* file,
            int line)
    {
 800dbf4:	b580      	push	{r7, lr}
 800dbf6:	b086      	sub	sp, #24
 800dbf8:	af02      	add	r7, sp, #8
 800dbfa:	60f8      	str	r0, [r7, #12]
 800dbfc:	60b9      	str	r1, [r7, #8]
 800dbfe:	607a      	str	r2, [r7, #4]
 800dc00:	603b      	str	r3, [r7, #0]
        (void)fun;
        (void)file;
        (void)line;
        WOLFSSL_ERROR(err);
        #else
        WOLFSSL_ERROR_LINE(err, wolfSSL_ERR_sys_func(fun), (unsigned int)line,
 800dc02:	68b8      	ldr	r0, [r7, #8]
 800dc04:	f7ff ff82 	bl	800db0c <wolfSSL_ERR_sys_func>
 800dc08:	4601      	mov	r1, r0
 800dc0a:	69ba      	ldr	r2, [r7, #24]
 800dc0c:	2300      	movs	r3, #0
 800dc0e:	9300      	str	r3, [sp, #0]
 800dc10:	683b      	ldr	r3, [r7, #0]
 800dc12:	6878      	ldr	r0, [r7, #4]
 800dc14:	f010 fef2 	bl	801e9fc <WOLFSSL_ERROR_LINE>
            file, NULL);
        #endif
        (void)lib;
    }
 800dc18:	bf00      	nop
 800dc1a:	3710      	adds	r7, #16
 800dc1c:	46bd      	mov	sp, r7
 800dc1e:	bd80      	pop	{r7, pc}

0800dc20 <wolfSSL_sk_CIPHER_free>:
/* Free the structure for WOLFSSL_CIPHER stack
 *
 * sk  stack to free nodes in
 */
void wolfSSL_sk_CIPHER_free(WOLF_STACK_OF(WOLFSSL_CIPHER)* sk)
{
 800dc20:	b580      	push	{r7, lr}
 800dc22:	b082      	sub	sp, #8
 800dc24:	af00      	add	r7, sp, #0
 800dc26:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_sk_CIPHER_free");

    wolfSSL_sk_free(sk);
 800dc28:	6878      	ldr	r0, [r7, #4]
 800dc2a:	f000 f867 	bl	800dcfc <wolfSSL_sk_free>
}
 800dc2e:	bf00      	nop
 800dc30:	3708      	adds	r7, #8
 800dc32:	46bd      	mov	sp, r7
 800dc34:	bd80      	pop	{r7, pc}

0800dc36 <wolfSSL_ERR_GET_LIB>:
#ifdef WOLFSSL_DEBUG_TRACE_ERROR_CODES_H
#include <wolfssl/debug-untrace-error-codes.h>
#endif

int wolfSSL_ERR_GET_LIB(unsigned long err)
{
 800dc36:	b480      	push	{r7}
 800dc38:	b085      	sub	sp, #20
 800dc3a:	af00      	add	r7, sp, #0
 800dc3c:	6078      	str	r0, [r7, #4]
    unsigned long value;

    value = (err & 0xFFFFFFL);
 800dc3e:	687b      	ldr	r3, [r7, #4]
 800dc40:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 800dc44:	60fb      	str	r3, [r7, #12]
    switch (value) {
 800dc46:	68fb      	ldr	r3, [r7, #12]
 800dc48:	f5b3 7f01 	cmp.w	r3, #516	@ 0x204
 800dc4c:	d223      	bcs.n	800dc96 <wolfSSL_ERR_GET_LIB+0x60>
 800dc4e:	68fb      	ldr	r3, [r7, #12]
 800dc50:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800dc54:	d21b      	bcs.n	800dc8e <wolfSSL_ERR_GET_LIB+0x58>
 800dc56:	68fb      	ldr	r3, [r7, #12]
 800dc58:	f240 12ff 	movw	r2, #511	@ 0x1ff
 800dc5c:	4293      	cmp	r3, r2
 800dc5e:	d018      	beq.n	800dc92 <wolfSSL_ERR_GET_LIB+0x5c>
 800dc60:	68fb      	ldr	r3, [r7, #12]
 800dc62:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800dc66:	d216      	bcs.n	800dc96 <wolfSSL_ERR_GET_LIB+0x60>
 800dc68:	68fb      	ldr	r3, [r7, #12]
 800dc6a:	f5b3 7fff 	cmp.w	r3, #510	@ 0x1fe
 800dc6e:	d812      	bhi.n	800dc96 <wolfSSL_ERR_GET_LIB+0x60>
 800dc70:	68fb      	ldr	r3, [r7, #12]
 800dc72:	f5b3 7ffd 	cmp.w	r3, #506	@ 0x1fa
 800dc76:	d808      	bhi.n	800dc8a <wolfSSL_ERR_GET_LIB+0x54>
 800dc78:	68fb      	ldr	r3, [r7, #12]
 800dc7a:	2ba2      	cmp	r3, #162	@ 0xa2
 800dc7c:	d005      	beq.n	800dc8a <wolfSSL_ERR_GET_LIB+0x54>
 800dc7e:	68fb      	ldr	r3, [r7, #12]
 800dc80:	f5b3 7f99 	cmp.w	r3, #306	@ 0x132
 800dc84:	d107      	bne.n	800dc96 <wolfSSL_ERR_GET_LIB+0x60>
    case -PARSE_ERROR:
        return WOLFSSL_ERR_LIB_SSL;
 800dc86:	2314      	movs	r3, #20
 800dc88:	e006      	b.n	800dc98 <wolfSSL_ERR_GET_LIB+0x62>
    case -ASN_NO_PEM_HEADER:
    case -WOLFSSL_PEM_R_NO_START_LINE_E:
    case -WOLFSSL_PEM_R_PROBLEMS_GETTING_PASSWORD_E:
    case -WOLFSSL_PEM_R_BAD_PASSWORD_READ_E:
    case -WOLFSSL_PEM_R_BAD_DECRYPT_E:
        return WOLFSSL_ERR_LIB_PEM;
 800dc8a:	2309      	movs	r3, #9
 800dc8c:	e004      	b.n	800dc98 <wolfSSL_ERR_GET_LIB+0x62>
    case -WOLFSSL_EVP_R_BAD_DECRYPT_E:
    case -WOLFSSL_EVP_R_BN_DECODE_ERROR:
    case -WOLFSSL_EVP_R_DECODE_ERROR:
    case -WOLFSSL_EVP_R_PRIVATE_KEY_DECODE_ERROR:
        return WOLFSSL_ERR_LIB_EVP;
 800dc8e:	230b      	movs	r3, #11
 800dc90:	e002      	b.n	800dc98 <wolfSSL_ERR_GET_LIB+0x62>
    case -WOLFSSL_ASN1_R_HEADER_TOO_LONG_E:
        return WOLFSSL_ERR_LIB_ASN1;
 800dc92:	230c      	movs	r3, #12
 800dc94:	e000      	b.n	800dc98 <wolfSSL_ERR_GET_LIB+0x62>
    default:
        return 0;
 800dc96:	2300      	movs	r3, #0
    }
}
 800dc98:	4618      	mov	r0, r3
 800dc9a:	3714      	adds	r7, #20
 800dc9c:	46bd      	mov	sp, r7
 800dc9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dca2:	4770      	bx	lr

0800dca4 <wolfSSL_ERR_GET_REASON>:
 * error values are typically negative.
 *
 * Returns the error reason
 */
int wolfSSL_ERR_GET_REASON(unsigned long err)
{
 800dca4:	b480      	push	{r7}
 800dca6:	b085      	sub	sp, #20
 800dca8:	af00      	add	r7, sp, #0
 800dcaa:	6078      	str	r0, [r7, #4]
    int ret = (int)err;
 800dcac:	687b      	ldr	r3, [r7, #4]
 800dcae:	60fb      	str	r3, [r7, #12]
    if (err == ((ERR_LIB_ASN1 << 24) | ASN1_R_HEADER_TOO_LONG))
        return ASN1_R_HEADER_TOO_LONG;
#endif

    /* check if error value is in range of wolfCrypt or wolfSSL errors */
    ret = 0 - ret; /* setting as negative value */
 800dcb0:	68fb      	ldr	r3, [r7, #12]
 800dcb2:	425b      	negs	r3, r3
 800dcb4:	60fb      	str	r3, [r7, #12]

    if ((ret <= WC_SPAN1_FIRST_E && ret >= WC_SPAN1_LAST_E) ||
 800dcb6:	68fb      	ldr	r3, [r7, #12]
 800dcb8:	f113 0f60 	cmn.w	r3, #96	@ 0x60
 800dcbc:	da03      	bge.n	800dcc6 <wolfSSL_ERR_GET_REASON+0x22>
 800dcbe:	68fb      	ldr	r3, [r7, #12]
 800dcc0:	f513 7f96 	cmn.w	r3, #300	@ 0x12c
 800dcc4:	dc0f      	bgt.n	800dce6 <wolfSSL_ERR_GET_REASON+0x42>
 800dcc6:	68fb      	ldr	r3, [r7, #12]
 800dcc8:	f513 7f7a 	cmn.w	r3, #1000	@ 0x3e8
 800dccc:	dc03      	bgt.n	800dcd6 <wolfSSL_ERR_GET_REASON+0x32>
        (ret <= WC_SPAN2_FIRST_E && ret >= WC_SPAN2_LAST_E) ||
 800dcce:	68fb      	ldr	r3, [r7, #12]
 800dcd0:	f513 7f7a 	cmn.w	r3, #1000	@ 0x3e8
 800dcd4:	da07      	bge.n	800dce6 <wolfSSL_ERR_GET_REASON+0x42>
 800dcd6:	68fb      	ldr	r3, [r7, #12]
 800dcd8:	f513 7f96 	cmn.w	r3, #300	@ 0x12c
 800dcdc:	da05      	bge.n	800dcea <wolfSSL_ERR_GET_REASON+0x46>
        (ret <= WOLFSSL_FIRST_E && ret >= WOLFSSL_LAST_E))
 800dcde:	68fb      	ldr	r3, [r7, #12]
 800dce0:	f513 7f01 	cmn.w	r3, #516	@ 0x204
 800dce4:	db01      	blt.n	800dcea <wolfSSL_ERR_GET_REASON+0x46>
    {
        return ret;
 800dce6:	68fb      	ldr	r3, [r7, #12]
 800dce8:	e002      	b.n	800dcf0 <wolfSSL_ERR_GET_REASON+0x4c>
    }
    else {
        WOLFSSL_MSG("Not in range of typical error values");
        ret = (int)err;
 800dcea:	687b      	ldr	r3, [r7, #4]
 800dcec:	60fb      	str	r3, [r7, #12]
    }

    return ret;
 800dcee:	68fb      	ldr	r3, [r7, #12]
}
 800dcf0:	4618      	mov	r0, r3
 800dcf2:	3714      	adds	r7, #20
 800dcf4:	46bd      	mov	sp, r7
 800dcf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dcfa:	4770      	bx	lr

0800dcfc <wolfSSL_sk_free>:
    return NULL;
}

/* Free the just the stack structure */
void wolfSSL_sk_free(WOLFSSL_STACK* sk)
{
 800dcfc:	b580      	push	{r7, lr}
 800dcfe:	b084      	sub	sp, #16
 800dd00:	af00      	add	r7, sp, #0
 800dd02:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_sk_free");

    while (sk != NULL) {
 800dd04:	e00c      	b.n	800dd20 <wolfSSL_sk_free+0x24>
        WOLFSSL_STACK* next = sk->next;
 800dd06:	687b      	ldr	r3, [r7, #4]
 800dd08:	691b      	ldr	r3, [r3, #16]
 800dd0a:	60fb      	str	r3, [r7, #12]
        XFREE(sk, NULL, DYNAMIC_TYPE_OPENSSL);
 800dd0c:	687b      	ldr	r3, [r7, #4]
 800dd0e:	60bb      	str	r3, [r7, #8]
 800dd10:	68bb      	ldr	r3, [r7, #8]
 800dd12:	2b00      	cmp	r3, #0
 800dd14:	d002      	beq.n	800dd1c <wolfSSL_sk_free+0x20>
 800dd16:	68b8      	ldr	r0, [r7, #8]
 800dd18:	f010 fed8 	bl	801eacc <wolfSSL_Free>
        sk = next;
 800dd1c:	68fb      	ldr	r3, [r7, #12]
 800dd1e:	607b      	str	r3, [r7, #4]
    while (sk != NULL) {
 800dd20:	687b      	ldr	r3, [r7, #4]
 800dd22:	2b00      	cmp	r3, #0
 800dd24:	d1ef      	bne.n	800dd06 <wolfSSL_sk_free+0xa>
    }
}
 800dd26:	bf00      	nop
 800dd28:	bf00      	nop
 800dd2a:	3710      	adds	r7, #16
 800dd2c:	46bd      	mov	sp, r7
 800dd2e:	bd80      	pop	{r7, pc}

0800dd30 <wolfSSL_sk_pop_free>:
}

/* Free all nodes in a stack including the pushed objects */
void wolfSSL_sk_pop_free(WOLF_STACK_OF(WOLFSSL_ASN1_OBJECT)* sk,
                                                       wolfSSL_sk_freefunc func)
{
 800dd30:	b580      	push	{r7, lr}
 800dd32:	b084      	sub	sp, #16
 800dd34:	af00      	add	r7, sp, #0
 800dd36:	6078      	str	r0, [r7, #4]
 800dd38:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_sk_pop_free");

    if (sk == NULL) {
 800dd3a:	687b      	ldr	r3, [r7, #4]
 800dd3c:	2b00      	cmp	r3, #0
 800dd3e:	d069      	beq.n	800de14 <wolfSSL_sk_pop_free+0xe4>
    */
    if (sk->type == STACK_TYPE_ACCESS_DESCRIPTION) {
        func = (wolfSSL_sk_freefunc)wolfSSL_ACCESS_DESCRIPTION_free;
    }
    #endif
    if (func == NULL) {
 800dd40:	683b      	ldr	r3, [r7, #0]
 800dd42:	2b00      	cmp	r3, #0
 800dd44:	d162      	bne.n	800de0c <wolfSSL_sk_pop_free+0xdc>
        switch(sk->type) {
 800dd46:	687b      	ldr	r3, [r7, #4]
 800dd48:	7d1b      	ldrb	r3, [r3, #20]
 800dd4a:	2b12      	cmp	r3, #18
 800dd4c:	d843      	bhi.n	800ddd6 <wolfSSL_sk_pop_free+0xa6>
 800dd4e:	a201      	add	r2, pc, #4	@ (adr r2, 800dd54 <wolfSSL_sk_pop_free+0x24>)
 800dd50:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800dd54:	0800dda1 	.word	0x0800dda1
 800dd58:	0800ddb3 	.word	0x0800ddb3
 800dd5c:	0800ddd1 	.word	0x0800ddd1
 800dd60:	0800dda7 	.word	0x0800dda7
 800dd64:	0800ddb9 	.word	0x0800ddb9
 800dd68:	0800ddd7 	.word	0x0800ddd7
 800dd6c:	0800ddd7 	.word	0x0800ddd7
 800dd70:	0800ddcb 	.word	0x0800ddcb
 800dd74:	0800ddd7 	.word	0x0800ddd7
 800dd78:	0800ddbf 	.word	0x0800ddbf
 800dd7c:	0800ddd7 	.word	0x0800ddd7
 800dd80:	0800ddd7 	.word	0x0800ddd7
 800dd84:	0800ddd7 	.word	0x0800ddd7
 800dd88:	0800ddd7 	.word	0x0800ddd7
 800dd8c:	0800ddd7 	.word	0x0800ddd7
 800dd90:	0800ddad 	.word	0x0800ddad
 800dd94:	0800ddd7 	.word	0x0800ddd7
 800dd98:	0800ddc5 	.word	0x0800ddc5
 800dd9c:	0800ddd7 	.word	0x0800ddd7
            #if defined(OPENSSL_ALL)
                func = (wolfSSL_sk_freefunc)wolfSSL_ACCESS_DESCRIPTION_free;
            #endif
                break;
            case STACK_TYPE_X509:
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_free;
 800dda0:	4b1e      	ldr	r3, [pc, #120]	@ (800de1c <wolfSSL_sk_pop_free+0xec>)
 800dda2:	603b      	str	r3, [r7, #0]
                break;
 800dda4:	e018      	b.n	800ddd8 <wolfSSL_sk_pop_free+0xa8>
            #ifdef OPENSSL_ALL
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_OBJECT_free;
            #endif
                break;
            case STACK_TYPE_OBJ:
                func = (wolfSSL_sk_freefunc)wolfSSL_ASN1_OBJECT_free;
 800dda6:	4b1e      	ldr	r3, [pc, #120]	@ (800de20 <wolfSSL_sk_pop_free+0xf0>)
 800dda8:	603b      	str	r3, [r7, #0]
                break;
 800ddaa:	e015      	b.n	800ddd8 <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_DIST_POINT:
            #ifdef OPENSSL_EXTRA
                func = (wolfSSL_sk_freefunc)wolfSSL_DIST_POINT_free;
 800ddac:	4b1d      	ldr	r3, [pc, #116]	@ (800de24 <wolfSSL_sk_pop_free+0xf4>)
 800ddae:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800ddb0:	e012      	b.n	800ddd8 <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_GEN_NAME:
                func = (wolfSSL_sk_freefunc)wolfSSL_GENERAL_NAME_free;
 800ddb2:	4b1d      	ldr	r3, [pc, #116]	@ (800de28 <wolfSSL_sk_pop_free+0xf8>)
 800ddb4:	603b      	str	r3, [r7, #0]
                break;
 800ddb6:	e00f      	b.n	800ddd8 <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_STRING:
            #if defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY) || \
                defined(OPENSSL_EXTRA) || defined(OPENSSL_ALL)
                func = (wolfSSL_sk_freefunc)wolfSSL_WOLFSSL_STRING_free;
 800ddb8:	4b1c      	ldr	r3, [pc, #112]	@ (800de2c <wolfSSL_sk_pop_free+0xfc>)
 800ddba:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800ddbc:	e00c      	b.n	800ddd8 <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_X509_NAME:
            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \
                && !defined(WOLFCRYPT_ONLY)
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_NAME_free;
 800ddbe:	4b1c      	ldr	r3, [pc, #112]	@ (800de30 <wolfSSL_sk_pop_free+0x100>)
 800ddc0:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800ddc2:	e009      	b.n	800ddd8 <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_X509_NAME_ENTRY:
            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \
                && !defined(WOLFCRYPT_ONLY)
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_NAME_ENTRY_free;
 800ddc4:	4b1b      	ldr	r3, [pc, #108]	@ (800de34 <wolfSSL_sk_pop_free+0x104>)
 800ddc6:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800ddc8:	e006      	b.n	800ddd8 <wolfSSL_sk_pop_free+0xa8>
            case STACK_TYPE_X509_EXT:
            #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA)
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_EXTENSION_free;
 800ddca:	4b1b      	ldr	r3, [pc, #108]	@ (800de38 <wolfSSL_sk_pop_free+0x108>)
 800ddcc:	603b      	str	r3, [r7, #0]
            #endif
                break;
 800ddce:	e003      	b.n	800ddd8 <wolfSSL_sk_pop_free+0xa8>
                func = (wolfSSL_sk_freefunc)wolfSSL_X509_INFO_free;
            #endif
                break;
            case STACK_TYPE_BIO:
#if !defined(NO_BIO) && defined(OPENSSL_EXTRA)
                func = (wolfSSL_sk_freefunc)wolfSSL_BIO_vfree;
 800ddd0:	4b1a      	ldr	r3, [pc, #104]	@ (800de3c <wolfSSL_sk_pop_free+0x10c>)
 800ddd2:	603b      	str	r3, [r7, #0]
#endif
                break;
 800ddd4:	e000      	b.n	800ddd8 <wolfSSL_sk_pop_free+0xa8>
#endif
                break;
            case STACK_TYPE_CIPHER:
            case STACK_TYPE_NULL:
            default:
                break;
 800ddd6:	bf00      	nop
        }
    }

    while (sk != NULL) {
 800ddd8:	e018      	b.n	800de0c <wolfSSL_sk_pop_free+0xdc>
        WOLFSSL_STACK* next = sk->next;
 800ddda:	687b      	ldr	r3, [r7, #4]
 800dddc:	691b      	ldr	r3, [r3, #16]
 800ddde:	60fb      	str	r3, [r7, #12]

        if (func != NULL) {
 800dde0:	683b      	ldr	r3, [r7, #0]
 800dde2:	2b00      	cmp	r3, #0
 800dde4:	d008      	beq.n	800ddf8 <wolfSSL_sk_pop_free+0xc8>
            if (sk->type != STACK_TYPE_CIPHER)
 800dde6:	687b      	ldr	r3, [r7, #4]
 800dde8:	7d1b      	ldrb	r3, [r3, #20]
 800ddea:	2b05      	cmp	r3, #5
 800ddec:	d004      	beq.n	800ddf8 <wolfSSL_sk_pop_free+0xc8>
                func(sk->data.generic);
 800ddee:	687b      	ldr	r3, [r7, #4]
 800ddf0:	685a      	ldr	r2, [r3, #4]
 800ddf2:	683b      	ldr	r3, [r7, #0]
 800ddf4:	4610      	mov	r0, r2
 800ddf6:	4798      	blx	r3
        }
        XFREE(sk, NULL, DYNAMIC_TYPE_OPENSSL);
 800ddf8:	687b      	ldr	r3, [r7, #4]
 800ddfa:	60bb      	str	r3, [r7, #8]
 800ddfc:	68bb      	ldr	r3, [r7, #8]
 800ddfe:	2b00      	cmp	r3, #0
 800de00:	d002      	beq.n	800de08 <wolfSSL_sk_pop_free+0xd8>
 800de02:	68b8      	ldr	r0, [r7, #8]
 800de04:	f010 fe62 	bl	801eacc <wolfSSL_Free>
        sk = next;
 800de08:	68fb      	ldr	r3, [r7, #12]
 800de0a:	607b      	str	r3, [r7, #4]
    while (sk != NULL) {
 800de0c:	687b      	ldr	r3, [r7, #4]
 800de0e:	2b00      	cmp	r3, #0
 800de10:	d1e3      	bne.n	800ddda <wolfSSL_sk_pop_free+0xaa>
 800de12:	e000      	b.n	800de16 <wolfSSL_sk_pop_free+0xe6>
        return;
 800de14:	bf00      	nop
    }
}
 800de16:	3710      	adds	r7, #16
 800de18:	46bd      	mov	sp, r7
 800de1a:	bd80      	pop	{r7, pc}
 800de1c:	0800e353 	.word	0x0800e353
 800de20:	0800b9eb 	.word	0x0800b9eb
 800de24:	0800e3d3 	.word	0x0800e3d3
 800de28:	0800e511 	.word	0x0800e511
 800de2c:	0800e095 	.word	0x0800e095
 800de30:	0800e583 	.word	0x0800e583
 800de34:	0800e5db 	.word	0x0800e5db
 800de38:	0800e2a1 	.word	0x0800e2a1
 800de3c:	0800e241 	.word	0x0800e241

0800de40 <wolfSSL_OBJ_nid2obj_ex>:
    }


    WOLFSSL_LOCAL WOLFSSL_ASN1_OBJECT* wolfSSL_OBJ_nid2obj_ex(int id,
                                                WOLFSSL_ASN1_OBJECT* arg_obj)
    {
 800de40:	b590      	push	{r4, r7, lr}
 800de42:	b097      	sub	sp, #92	@ 0x5c
 800de44:	af00      	add	r7, sp, #0
 800de46:	6078      	str	r0, [r7, #4]
 800de48:	6039      	str	r1, [r7, #0]
        word32 oidSz = 0;
 800de4a:	2300      	movs	r3, #0
 800de4c:	63bb      	str	r3, [r7, #56]	@ 0x38
        int nid = 0;
 800de4e:	2300      	movs	r3, #0
 800de50:	657b      	str	r3, [r7, #84]	@ 0x54
        const byte* oid;
        word32 type = 0;
 800de52:	2300      	movs	r3, #0
 800de54:	653b      	str	r3, [r7, #80]	@ 0x50
        WOLFSSL_ASN1_OBJECT* obj = arg_obj;
 800de56:	683b      	ldr	r3, [r7, #0]
 800de58:	64fb      	str	r3, [r7, #76]	@ 0x4c
        byte objBuf[MAX_OID_SZ + MAX_LENGTH_SZ + 1]; /* +1 for object tag */
        word32 objSz = 0;
 800de5a:	2300      	movs	r3, #0
 800de5c:	64bb      	str	r3, [r7, #72]	@ 0x48
        const char* sName = NULL;
 800de5e:	2300      	movs	r3, #0
 800de60:	647b      	str	r3, [r7, #68]	@ 0x44

#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_OBJ_nid2obj");
#endif

        for (i = 0; i < (int)WOLFSSL_OBJECT_INFO_SZ; i++) {
 800de62:	2300      	movs	r3, #0
 800de64:	643b      	str	r3, [r7, #64]	@ 0x40
 800de66:	e02e      	b.n	800dec6 <wolfSSL_OBJ_nid2obj_ex+0x86>
            if (wolfssl_object_info[i].nid == id) {
 800de68:	497b      	ldr	r1, [pc, #492]	@ (800e058 <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800de6a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800de6c:	4613      	mov	r3, r2
 800de6e:	009b      	lsls	r3, r3, #2
 800de70:	4413      	add	r3, r2
 800de72:	009b      	lsls	r3, r3, #2
 800de74:	440b      	add	r3, r1
 800de76:	681b      	ldr	r3, [r3, #0]
 800de78:	687a      	ldr	r2, [r7, #4]
 800de7a:	429a      	cmp	r2, r3
 800de7c:	d120      	bne.n	800dec0 <wolfSSL_OBJ_nid2obj_ex+0x80>
                nid = id;
 800de7e:	687b      	ldr	r3, [r7, #4]
 800de80:	657b      	str	r3, [r7, #84]	@ 0x54
                id = wolfssl_object_info[i].id;
 800de82:	4975      	ldr	r1, [pc, #468]	@ (800e058 <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800de84:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800de86:	4613      	mov	r3, r2
 800de88:	009b      	lsls	r3, r3, #2
 800de8a:	4413      	add	r3, r2
 800de8c:	009b      	lsls	r3, r3, #2
 800de8e:	440b      	add	r3, r1
 800de90:	3304      	adds	r3, #4
 800de92:	681b      	ldr	r3, [r3, #0]
 800de94:	607b      	str	r3, [r7, #4]
                sName = wolfssl_object_info[i].sName;
 800de96:	4970      	ldr	r1, [pc, #448]	@ (800e058 <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800de98:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800de9a:	4613      	mov	r3, r2
 800de9c:	009b      	lsls	r3, r3, #2
 800de9e:	4413      	add	r3, r2
 800dea0:	009b      	lsls	r3, r3, #2
 800dea2:	440b      	add	r3, r1
 800dea4:	330c      	adds	r3, #12
 800dea6:	681b      	ldr	r3, [r3, #0]
 800dea8:	647b      	str	r3, [r7, #68]	@ 0x44
                type = wolfssl_object_info[i].type;
 800deaa:	496b      	ldr	r1, [pc, #428]	@ (800e058 <wolfSSL_OBJ_nid2obj_ex+0x218>)
 800deac:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800deae:	4613      	mov	r3, r2
 800deb0:	009b      	lsls	r3, r3, #2
 800deb2:	4413      	add	r3, r2
 800deb4:	009b      	lsls	r3, r3, #2
 800deb6:	440b      	add	r3, r1
 800deb8:	3308      	adds	r3, #8
 800deba:	681b      	ldr	r3, [r3, #0]
 800debc:	653b      	str	r3, [r7, #80]	@ 0x50
                break;
 800debe:	e005      	b.n	800decc <wolfSSL_OBJ_nid2obj_ex+0x8c>
        for (i = 0; i < (int)WOLFSSL_OBJECT_INFO_SZ; i++) {
 800dec0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800dec2:	3301      	adds	r3, #1
 800dec4:	643b      	str	r3, [r7, #64]	@ 0x40
 800dec6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800dec8:	2b50      	cmp	r3, #80	@ 0x50
 800deca:	ddcd      	ble.n	800de68 <wolfSSL_OBJ_nid2obj_ex+0x28>
            }
        }
        if (i == (int)WOLFSSL_OBJECT_INFO_SZ) {
 800decc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800dece:	2b51      	cmp	r3, #81	@ 0x51
 800ded0:	d101      	bne.n	800ded6 <wolfSSL_OBJ_nid2obj_ex+0x96>
            WOLFSSL_MSG("NID not in table");
        #ifdef WOLFSSL_QT
            sName = NULL;
            type = (word32)id;
        #else
            return NULL;
 800ded2:	2300      	movs	r3, #0
 800ded4:	e0bc      	b.n	800e050 <wolfSSL_OBJ_nid2obj_ex+0x210>
        #endif
        }

    #ifdef HAVE_ECC
         if (type == 0 && wc_ecc_get_oid((word32)id, &oid, &oidSz) > 0) {
 800ded6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ded8:	2b00      	cmp	r3, #0
 800deda:	d10c      	bne.n	800def6 <wolfSSL_OBJ_nid2obj_ex+0xb6>
 800dedc:	687b      	ldr	r3, [r7, #4]
 800dede:	f107 0238 	add.w	r2, r7, #56	@ 0x38
 800dee2:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 800dee6:	4618      	mov	r0, r3
 800dee8:	f010 f9ec 	bl	801e2c4 <wc_ecc_get_oid>
 800deec:	4603      	mov	r3, r0
 800deee:	2b00      	cmp	r3, #0
 800def0:	dd01      	ble.n	800def6 <wolfSSL_OBJ_nid2obj_ex+0xb6>
             type = oidCurveType;
 800def2:	2303      	movs	r3, #3
 800def4:	653b      	str	r3, [r7, #80]	@ 0x50
         }
    #endif /* HAVE_ECC */

        if (sName != NULL) {
 800def6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800def8:	2b00      	cmp	r3, #0
 800defa:	d007      	beq.n	800df0c <wolfSSL_OBJ_nid2obj_ex+0xcc>
            if (XSTRLEN(sName) > WOLFSSL_MAX_SNAME - 1) {
 800defc:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800defe:	f7f2 f971 	bl	80001e4 <strlen>
 800df02:	4603      	mov	r3, r0
 800df04:	2b27      	cmp	r3, #39	@ 0x27
 800df06:	d901      	bls.n	800df0c <wolfSSL_OBJ_nid2obj_ex+0xcc>
                WOLFSSL_MSG("Attempted short name is too large");
                return NULL;
 800df08:	2300      	movs	r3, #0
 800df0a:	e0a1      	b.n	800e050 <wolfSSL_OBJ_nid2obj_ex+0x210>
            }
        }

        oid = OidFromId((word32)id, type, &oidSz);
 800df0c:	687b      	ldr	r3, [r7, #4]
 800df0e:	f107 0238 	add.w	r2, r7, #56	@ 0x38
 800df12:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 800df14:	4618      	mov	r0, r3
 800df16:	f006 f8c1 	bl	801409c <OidFromId>
 800df1a:	4603      	mov	r3, r0
 800df1c:	637b      	str	r3, [r7, #52]	@ 0x34

        /* set object ID to buffer */
        if (obj == NULL){
 800df1e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df20:	2b00      	cmp	r3, #0
 800df22:	d107      	bne.n	800df34 <wolfSSL_OBJ_nid2obj_ex+0xf4>
            obj = wolfSSL_ASN1_OBJECT_new();
 800df24:	f7fd fd3e 	bl	800b9a4 <wolfSSL_ASN1_OBJECT_new>
 800df28:	64f8      	str	r0, [r7, #76]	@ 0x4c
            if (obj == NULL) {
 800df2a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df2c:	2b00      	cmp	r3, #0
 800df2e:	d101      	bne.n	800df34 <wolfSSL_OBJ_nid2obj_ex+0xf4>
                WOLFSSL_MSG("Issue creating WOLFSSL_ASN1_OBJECT struct");
                return NULL;
 800df30:	2300      	movs	r3, #0
 800df32:	e08d      	b.n	800e050 <wolfSSL_OBJ_nid2obj_ex+0x210>
            }
        }
        obj->nid     = nid;
 800df34:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df36:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800df38:	639a      	str	r2, [r3, #56]	@ 0x38
        obj->type    = id;
 800df3a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df3c:	687a      	ldr	r2, [r7, #4]
 800df3e:	631a      	str	r2, [r3, #48]	@ 0x30
        obj->grp     = (int)type;
 800df40:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800df42:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df44:	635a      	str	r2, [r3, #52]	@ 0x34

        obj->sName[0] = '\0';
 800df46:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df48:	2200      	movs	r2, #0
 800df4a:	721a      	strb	r2, [r3, #8]
        if (sName != NULL) {
 800df4c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800df4e:	2b00      	cmp	r3, #0
 800df50:	d00b      	beq.n	800df6a <wolfSSL_OBJ_nid2obj_ex+0x12a>
            XMEMCPY(obj->sName, (char*)sName, XSTRLEN((char*)sName));
 800df52:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800df54:	f103 0408 	add.w	r4, r3, #8
 800df58:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800df5a:	f7f2 f943 	bl	80001e4 <strlen>
 800df5e:	4603      	mov	r3, r0
 800df60:	461a      	mov	r2, r3
 800df62:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800df64:	4620      	mov	r0, r4
 800df66:	f01a fb1d 	bl	80285a4 <memcpy>
        }

        objBuf[0] = ASN_OBJECT_ID; objSz++;
 800df6a:	2306      	movs	r3, #6
 800df6c:	733b      	strb	r3, [r7, #12]
 800df6e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800df70:	3301      	adds	r3, #1
 800df72:	64bb      	str	r3, [r7, #72]	@ 0x48
        objSz += SetLength(oidSz, objBuf + 1);
 800df74:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800df76:	f107 030c 	add.w	r3, r7, #12
 800df7a:	3301      	adds	r3, #1
 800df7c:	4619      	mov	r1, r3
 800df7e:	4610      	mov	r0, r2
 800df80:	f007 ff81 	bl	8015e86 <SetLength>
 800df84:	4602      	mov	r2, r0
 800df86:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800df88:	4413      	add	r3, r2
 800df8a:	64bb      	str	r3, [r7, #72]	@ 0x48
        if (oidSz) {
 800df8c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800df8e:	2b00      	cmp	r3, #0
 800df90:	d00c      	beq.n	800dfac <wolfSSL_OBJ_nid2obj_ex+0x16c>
            XMEMCPY(objBuf + objSz, oid, oidSz);
 800df92:	f107 020c 	add.w	r2, r7, #12
 800df96:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800df98:	4413      	add	r3, r2
 800df9a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800df9c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800df9e:	4618      	mov	r0, r3
 800dfa0:	f01a fb00 	bl	80285a4 <memcpy>
            objSz     += oidSz;
 800dfa4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800dfa6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800dfa8:	4413      	add	r3, r2
 800dfaa:	64bb      	str	r3, [r7, #72]	@ 0x48
        }

        if (obj->objSz == 0 || objSz != obj->objSz) {
 800dfac:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfae:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800dfb0:	2b00      	cmp	r3, #0
 800dfb2:	d004      	beq.n	800dfbe <wolfSSL_OBJ_nid2obj_ex+0x17e>
 800dfb4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfb6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800dfb8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800dfba:	429a      	cmp	r2, r3
 800dfbc:	d03e      	beq.n	800e03c <wolfSSL_OBJ_nid2obj_ex+0x1fc>
            obj->objSz = objSz;
 800dfbe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfc0:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800dfc2:	63da      	str	r2, [r3, #60]	@ 0x3c
            if(((obj->dynamic & WOLFSSL_ASN1_DYNAMIC_DATA) != 0) ||
 800dfc4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfc6:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800dfca:	f003 0302 	and.w	r3, r3, #2
 800dfce:	2b00      	cmp	r3, #0
 800dfd0:	d103      	bne.n	800dfda <wolfSSL_OBJ_nid2obj_ex+0x19a>
                                                           (obj->obj == NULL)) {
 800dfd2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfd4:	685b      	ldr	r3, [r3, #4]
            if(((obj->dynamic & WOLFSSL_ASN1_DYNAMIC_DATA) != 0) ||
 800dfd6:	2b00      	cmp	r3, #0
 800dfd8:	d127      	bne.n	800e02a <wolfSSL_OBJ_nid2obj_ex+0x1ea>
                if (obj->obj != NULL)
 800dfda:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfdc:	685b      	ldr	r3, [r3, #4]
 800dfde:	2b00      	cmp	r3, #0
 800dfe0:	d008      	beq.n	800dff4 <wolfSSL_OBJ_nid2obj_ex+0x1b4>
                    XFREE((byte*)obj->obj, NULL, DYNAMIC_TYPE_ASN1);
 800dfe2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dfe4:	685b      	ldr	r3, [r3, #4]
 800dfe6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800dfe8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800dfea:	2b00      	cmp	r3, #0
 800dfec:	d002      	beq.n	800dff4 <wolfSSL_OBJ_nid2obj_ex+0x1b4>
 800dfee:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 800dff0:	f010 fd6c 	bl	801eacc <wolfSSL_Free>
                obj->obj = (byte*)XMALLOC(obj->objSz, NULL, DYNAMIC_TYPE_ASN1);
 800dff4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800dff6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800dff8:	4618      	mov	r0, r3
 800dffa:	f010 fd4b 	bl	801ea94 <wolfSSL_Malloc>
 800dffe:	4602      	mov	r2, r0
 800e000:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e002:	605a      	str	r2, [r3, #4]
                if (obj->obj == NULL) {
 800e004:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e006:	685b      	ldr	r3, [r3, #4]
 800e008:	2b00      	cmp	r3, #0
 800e00a:	d104      	bne.n	800e016 <wolfSSL_OBJ_nid2obj_ex+0x1d6>
                    wolfSSL_ASN1_OBJECT_free(obj);
 800e00c:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800e00e:	f7fd fcec 	bl	800b9ea <wolfSSL_ASN1_OBJECT_free>
                    return NULL;
 800e012:	2300      	movs	r3, #0
 800e014:	e01c      	b.n	800e050 <wolfSSL_OBJ_nid2obj_ex+0x210>
                }
                obj->dynamic |= WOLFSSL_ASN1_DYNAMIC_DATA;
 800e016:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e018:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800e01c:	f043 0302 	orr.w	r3, r3, #2
 800e020:	b2da      	uxtb	r2, r3
 800e022:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e024:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
 800e028:	e008      	b.n	800e03c <wolfSSL_OBJ_nid2obj_ex+0x1fc>
            }
            else {
                obj->dynamic &= ~WOLFSSL_ASN1_DYNAMIC_DATA;
 800e02a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e02c:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800e030:	f023 0302 	bic.w	r3, r3, #2
 800e034:	b2da      	uxtb	r2, r3
 800e036:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e038:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
            }
        }
        XMEMCPY((byte*)obj->obj, objBuf, obj->objSz);
 800e03c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e03e:	6858      	ldr	r0, [r3, #4]
 800e040:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e042:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800e044:	f107 030c 	add.w	r3, r7, #12
 800e048:	4619      	mov	r1, r3
 800e04a:	f01a faab 	bl	80285a4 <memcpy>

        (void)type;

        return obj;
 800e04e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    }
 800e050:	4618      	mov	r0, r3
 800e052:	375c      	adds	r7, #92	@ 0x5c
 800e054:	46bd      	mov	sp, r7
 800e056:	bd90      	pop	{r4, r7, pc}
 800e058:	08030c80 	.word	0x08030c80

0800e05c <wolfSSL_ERR_peek_last_error>:
        return 0;
    return ConstantCompare((const byte*)a, (const byte*)b, (int)size);
}

unsigned long wolfSSL_ERR_peek_last_error(void)
{
 800e05c:	b580      	push	{r7, lr}
 800e05e:	b082      	sub	sp, #8
 800e060:	af00      	add	r7, sp, #0

#ifdef WOLFSSL_HAVE_ERROR_QUEUE
    {
        int ret;

        if ((ret = wc_PeekErrorNode(-1, NULL, NULL, NULL)) < 0) {
 800e062:	2300      	movs	r3, #0
 800e064:	2200      	movs	r2, #0
 800e066:	2100      	movs	r1, #0
 800e068:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 800e06c:	f010 fb3e 	bl	801e6ec <wc_PeekErrorNode>
 800e070:	6078      	str	r0, [r7, #4]
 800e072:	687b      	ldr	r3, [r7, #4]
 800e074:	2b00      	cmp	r3, #0
 800e076:	da01      	bge.n	800e07c <wolfSSL_ERR_peek_last_error+0x20>
            WOLFSSL_MSG("Issue peeking at error node in queue");
            return 0;
 800e078:	2300      	movs	r3, #0
 800e07a:	e005      	b.n	800e088 <wolfSSL_ERR_peek_last_error+0x2c>
        }
        if (ret == -WC_NO_ERR_TRACE(ASN_NO_PEM_HEADER))
 800e07c:	687b      	ldr	r3, [r7, #4]
 800e07e:	2ba2      	cmp	r3, #162	@ 0xa2
 800e080:	d101      	bne.n	800e086 <wolfSSL_ERR_peek_last_error+0x2a>
            return (WOLFSSL_ERR_LIB_PEM << 24) | -WC_NO_ERR_TRACE(WOLFSSL_PEM_R_NO_START_LINE_E);
 800e082:	4b03      	ldr	r3, [pc, #12]	@ (800e090 <wolfSSL_ERR_peek_last_error+0x34>)
 800e084:	e000      	b.n	800e088 <wolfSSL_ERR_peek_last_error+0x2c>
    #if defined(WOLFSSL_PYTHON)
        if (ret == WC_NO_ERR_TRACE(ASN1_R_HEADER_TOO_LONG))
            return (WOLFSSL_ERR_LIB_ASN1 << 24) | -WC_NO_ERR_TRACE(WOLFSSL_ASN1_R_HEADER_TOO_LONG_E);
    #endif
        return (unsigned long)ret;
 800e086:	687b      	ldr	r3, [r7, #4]
    }
#else
    return (unsigned long)(0 - NOT_COMPILED_IN);
#endif
}
 800e088:	4618      	mov	r0, r3
 800e08a:	3708      	adds	r7, #8
 800e08c:	46bd      	mov	sp, r7
 800e08e:	bd80      	pop	{r7, pc}
 800e090:	090001fb 	.word	0x090001fb

0800e094 <wolfSSL_WOLFSSL_STRING_free>:

    return ret;
}

void wolfSSL_WOLFSSL_STRING_free(WOLFSSL_STRING s)
{
 800e094:	b580      	push	{r7, lr}
 800e096:	b084      	sub	sp, #16
 800e098:	af00      	add	r7, sp, #0
 800e09a:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_WOLFSSL_STRING_free");

    XFREE(s, NULL, DYNAMIC_TYPE_OPENSSL);
 800e09c:	687b      	ldr	r3, [r7, #4]
 800e09e:	60fb      	str	r3, [r7, #12]
 800e0a0:	68fb      	ldr	r3, [r7, #12]
 800e0a2:	2b00      	cmp	r3, #0
 800e0a4:	d002      	beq.n	800e0ac <wolfSSL_WOLFSSL_STRING_free+0x18>
 800e0a6:	68f8      	ldr	r0, [r7, #12]
 800e0a8:	f010 fd10 	bl	801eacc <wolfSSL_Free>
}
 800e0ac:	bf00      	nop
 800e0ae:	3710      	adds	r7, #16
 800e0b0:	46bd      	mov	sp, r7
 800e0b2:	bd80      	pop	{r7, pc}

0800e0b4 <wolfSSL_BIO_free>:
     * Note : If the flag BIO_NOCLOSE is set then freeing memory buffers is up
     *        to the application.
     * Returns 1 on success, 0 on failure
     */
    int wolfSSL_BIO_free(WOLFSSL_BIO* bio)
    {
 800e0b4:	b590      	push	{r4, r7, lr}
 800e0b6:	b08d      	sub	sp, #52	@ 0x34
 800e0b8:	af02      	add	r7, sp, #8
 800e0ba:	6078      	str	r0, [r7, #4]
        int ret;
    #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA)
        int doFree = 0;
 800e0bc:	2300      	movs	r3, #0
 800e0be:	60fb      	str	r3, [r7, #12]
    #endif

        /* unchain?, doesn't matter in goahead since from free all */
        WOLFSSL_ENTER("wolfSSL_BIO_free");
        if (bio) {
 800e0c0:	687b      	ldr	r3, [r7, #4]
 800e0c2:	2b00      	cmp	r3, #0
 800e0c4:	f000 80b7 	beq.w	800e236 <wolfSSL_BIO_free+0x182>

            if (bio->infoCb) {
 800e0c8:	687b      	ldr	r3, [r7, #4]
 800e0ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e0cc:	2b00      	cmp	r3, #0
 800e0ce:	d011      	beq.n	800e0f4 <wolfSSL_BIO_free+0x40>
                /* info callback is called before free */
                ret = (int)bio->infoCb(bio, WOLFSSL_BIO_CB_FREE, NULL, 0, 0, 1);
 800e0d0:	687b      	ldr	r3, [r7, #4]
 800e0d2:	6adc      	ldr	r4, [r3, #44]	@ 0x2c
 800e0d4:	2301      	movs	r3, #1
 800e0d6:	9301      	str	r3, [sp, #4]
 800e0d8:	2300      	movs	r3, #0
 800e0da:	9300      	str	r3, [sp, #0]
 800e0dc:	2300      	movs	r3, #0
 800e0de:	2200      	movs	r2, #0
 800e0e0:	2101      	movs	r1, #1
 800e0e2:	6878      	ldr	r0, [r7, #4]
 800e0e4:	47a0      	blx	r4
 800e0e6:	4603      	mov	r3, r0
 800e0e8:	613b      	str	r3, [r7, #16]
                if (ret <= 0) {
 800e0ea:	693b      	ldr	r3, [r7, #16]
 800e0ec:	2b00      	cmp	r3, #0
 800e0ee:	dc01      	bgt.n	800e0f4 <wolfSSL_BIO_free+0x40>
                    return ret;
 800e0f0:	693b      	ldr	r3, [r7, #16]
 800e0f2:	e0a1      	b.n	800e238 <wolfSSL_BIO_free+0x184>
                }
            }

    #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA)
            wolfSSL_RefDec(&bio->ref, &doFree, &ret);
 800e0f4:	687b      	ldr	r3, [r7, #4]
 800e0f6:	3368      	adds	r3, #104	@ 0x68
 800e0f8:	2101      	movs	r1, #1
 800e0fa:	4618      	mov	r0, r3
 800e0fc:	f7fd f818 	bl	800b130 <wolfSSL_Atomic_Int_FetchSub>
 800e100:	6278      	str	r0, [r7, #36]	@ 0x24
 800e102:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e104:	2b01      	cmp	r3, #1
 800e106:	bf0c      	ite	eq
 800e108:	2301      	moveq	r3, #1
 800e10a:	2300      	movne	r3, #0
 800e10c:	b2db      	uxtb	r3, r3
 800e10e:	60fb      	str	r3, [r7, #12]
 800e110:	2300      	movs	r3, #0
 800e112:	613b      	str	r3, [r7, #16]

            if (!doFree) {
 800e114:	68fb      	ldr	r3, [r7, #12]
 800e116:	2b00      	cmp	r3, #0
 800e118:	d101      	bne.n	800e11e <wolfSSL_BIO_free+0x6a>
                /* return success if BIO ref count is not 1 yet */
            #ifdef WOLFSSL_REFCNT_ERROR_RETURN
                return (ret == 0) ? WOLFSSL_SUCCESS : WOLFSSL_FAILURE ;
            #else
                (void)ret;
                return WOLFSSL_SUCCESS;
 800e11a:	2301      	movs	r3, #1
 800e11c:	e08c      	b.n	800e238 <wolfSSL_BIO_free+0x184>
        #ifdef HAVE_EX_DATA_CLEANUP_HOOKS
            wolfSSL_CRYPTO_cleanup_ex_data(&bio->ex_data);
        #endif

            /* call custom set free callback */
            if (bio->method && bio->method->freeCb) {
 800e11e:	687b      	ldr	r3, [r7, #4]
 800e120:	685b      	ldr	r3, [r3, #4]
 800e122:	2b00      	cmp	r3, #0
 800e124:	d00b      	beq.n	800e13e <wolfSSL_BIO_free+0x8a>
 800e126:	687b      	ldr	r3, [r7, #4]
 800e128:	685b      	ldr	r3, [r3, #4]
 800e12a:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 800e12e:	2b00      	cmp	r3, #0
 800e130:	d005      	beq.n	800e13e <wolfSSL_BIO_free+0x8a>
                bio->method->freeCb(bio);
 800e132:	687b      	ldr	r3, [r7, #4]
 800e134:	685b      	ldr	r3, [r3, #4]
 800e136:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
 800e13a:	6878      	ldr	r0, [r7, #4]
 800e13c:	4798      	blx	r3
            }

            /* remove from pair by setting the paired bios pair to NULL */
            if (bio->pair != NULL) {
 800e13e:	687b      	ldr	r3, [r7, #4]
 800e140:	691b      	ldr	r3, [r3, #16]
 800e142:	2b00      	cmp	r3, #0
 800e144:	d003      	beq.n	800e14e <wolfSSL_BIO_free+0x9a>
                bio->pair->pair = NULL;
 800e146:	687b      	ldr	r3, [r7, #4]
 800e148:	691b      	ldr	r3, [r3, #16]
 800e14a:	2200      	movs	r2, #0
 800e14c:	611a      	str	r2, [r3, #16]
            }

            XFREE(bio->ip, bio->heap, DYNAMIC_TYPE_OPENSSL);
 800e14e:	687b      	ldr	r3, [r7, #4]
 800e150:	6a1b      	ldr	r3, [r3, #32]
 800e152:	623b      	str	r3, [r7, #32]
 800e154:	6a3b      	ldr	r3, [r7, #32]
 800e156:	2b00      	cmp	r3, #0
 800e158:	d002      	beq.n	800e160 <wolfSSL_BIO_free+0xac>
 800e15a:	6a38      	ldr	r0, [r7, #32]
 800e15c:	f010 fcb6 	bl	801eacc <wolfSSL_Free>

            if (bio->shutdown) {
 800e160:	687b      	ldr	r3, [r7, #4]
 800e162:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 800e166:	f003 0302 	and.w	r3, r3, #2
 800e16a:	b2db      	uxtb	r3, r3
 800e16c:	2b00      	cmp	r3, #0
 800e16e:	d00d      	beq.n	800e18c <wolfSSL_BIO_free+0xd8>
                if (bio->type == WOLFSSL_BIO_SSL && bio->ptr.ssl)
 800e170:	687b      	ldr	r3, [r7, #4]
 800e172:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800e176:	2b03      	cmp	r3, #3
 800e178:	d108      	bne.n	800e18c <wolfSSL_BIO_free+0xd8>
 800e17a:	687b      	ldr	r3, [r7, #4]
 800e17c:	699b      	ldr	r3, [r3, #24]
 800e17e:	2b00      	cmp	r3, #0
 800e180:	d004      	beq.n	800e18c <wolfSSL_BIO_free+0xd8>
                    wolfSSL_free(bio->ptr.ssl);
 800e182:	687b      	ldr	r3, [r7, #4]
 800e184:	699b      	ldr	r3, [r3, #24]
 800e186:	4618      	mov	r0, r3
 800e188:	f7fe f805 	bl	800c196 <wolfSSL_free>
                }
            #endif
            }
        #endif

            if (bio->shutdown != WOLFSSL_BIO_NOCLOSE) {
 800e18c:	687b      	ldr	r3, [r7, #4]
 800e18e:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 800e192:	f003 0302 	and.w	r3, r3, #2
 800e196:	b2db      	uxtb	r3, r3
 800e198:	2b00      	cmp	r3, #0
 800e19a:	d038      	beq.n	800e20e <wolfSSL_BIO_free+0x15a>
                if (bio->type == WOLFSSL_BIO_MEMORY &&
 800e19c:	687b      	ldr	r3, [r7, #4]
 800e19e:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800e1a2:	2b04      	cmp	r3, #4
 800e1a4:	d127      	bne.n	800e1f6 <wolfSSL_BIO_free+0x142>
                    bio->ptr.mem_buf_data != NULL)
 800e1a6:	687b      	ldr	r3, [r7, #4]
 800e1a8:	699b      	ldr	r3, [r3, #24]
                if (bio->type == WOLFSSL_BIO_MEMORY &&
 800e1aa:	2b00      	cmp	r3, #0
 800e1ac:	d023      	beq.n	800e1f6 <wolfSSL_BIO_free+0x142>
                {
                    if (bio->mem_buf != NULL) {
 800e1ae:	687b      	ldr	r3, [r7, #4]
 800e1b0:	681b      	ldr	r3, [r3, #0]
 800e1b2:	2b00      	cmp	r3, #0
 800e1b4:	d013      	beq.n	800e1de <wolfSSL_BIO_free+0x12a>
                        if ((byte *)bio->mem_buf->data != bio->ptr.mem_buf_data)
 800e1b6:	687b      	ldr	r3, [r7, #4]
 800e1b8:	681b      	ldr	r3, [r3, #0]
 800e1ba:	681a      	ldr	r2, [r3, #0]
 800e1bc:	687b      	ldr	r3, [r7, #4]
 800e1be:	699b      	ldr	r3, [r3, #24]
 800e1c0:	429a      	cmp	r2, r3
 800e1c2:	d018      	beq.n	800e1f6 <wolfSSL_BIO_free+0x142>
                        {
                            XFREE(bio->ptr.mem_buf_data, bio->heap,
 800e1c4:	687b      	ldr	r3, [r7, #4]
 800e1c6:	699b      	ldr	r3, [r3, #24]
 800e1c8:	61bb      	str	r3, [r7, #24]
 800e1ca:	69bb      	ldr	r3, [r7, #24]
 800e1cc:	2b00      	cmp	r3, #0
 800e1ce:	d002      	beq.n	800e1d6 <wolfSSL_BIO_free+0x122>
 800e1d0:	69b8      	ldr	r0, [r7, #24]
 800e1d2:	f010 fc7b 	bl	801eacc <wolfSSL_Free>
                                  DYNAMIC_TYPE_OPENSSL);
                            bio->ptr.mem_buf_data = NULL;
 800e1d6:	687b      	ldr	r3, [r7, #4]
 800e1d8:	2200      	movs	r2, #0
 800e1da:	619a      	str	r2, [r3, #24]
 800e1dc:	e00b      	b.n	800e1f6 <wolfSSL_BIO_free+0x142>
                        }
                    }
                    else {
                        XFREE(bio->ptr.mem_buf_data, bio->heap,
 800e1de:	687b      	ldr	r3, [r7, #4]
 800e1e0:	699b      	ldr	r3, [r3, #24]
 800e1e2:	61fb      	str	r3, [r7, #28]
 800e1e4:	69fb      	ldr	r3, [r7, #28]
 800e1e6:	2b00      	cmp	r3, #0
 800e1e8:	d002      	beq.n	800e1f0 <wolfSSL_BIO_free+0x13c>
 800e1ea:	69f8      	ldr	r0, [r7, #28]
 800e1ec:	f010 fc6e 	bl	801eacc <wolfSSL_Free>
                              DYNAMIC_TYPE_OPENSSL);
                        bio->ptr.mem_buf_data = NULL;
 800e1f0:	687b      	ldr	r3, [r7, #4]
 800e1f2:	2200      	movs	r2, #0
 800e1f4:	619a      	str	r2, [r3, #24]
                    }
                }
                if (bio->mem_buf != NULL) {
 800e1f6:	687b      	ldr	r3, [r7, #4]
 800e1f8:	681b      	ldr	r3, [r3, #0]
 800e1fa:	2b00      	cmp	r3, #0
 800e1fc:	d007      	beq.n	800e20e <wolfSSL_BIO_free+0x15a>
                    wolfSSL_BUF_MEM_free(bio->mem_buf);
 800e1fe:	687b      	ldr	r3, [r7, #4]
 800e200:	681b      	ldr	r3, [r3, #0]
 800e202:	4618      	mov	r0, r3
 800e204:	f000 fdae 	bl	800ed64 <wolfSSL_BUF_MEM_free>
                    bio->mem_buf = NULL;
 800e208:	687b      	ldr	r3, [r7, #4]
 800e20a:	2200      	movs	r2, #0
 800e20c:	601a      	str	r2, [r3, #0]
                }
            }

            if (bio->type == WOLFSSL_BIO_MD) {
 800e20e:	687b      	ldr	r3, [r7, #4]
 800e210:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800e214:	2b08      	cmp	r3, #8
 800e216:	d104      	bne.n	800e222 <wolfSSL_BIO_free+0x16e>
                wolfSSL_EVP_MD_CTX_free(bio->ptr.md_ctx);
 800e218:	687b      	ldr	r3, [r7, #4]
 800e21a:	699b      	ldr	r3, [r3, #24]
 800e21c:	4618      	mov	r0, r3
 800e21e:	f7fd f85c 	bl	800b2da <wolfSSL_EVP_MD_CTX_free>
            }

            XFREE(bio, 0, DYNAMIC_TYPE_OPENSSL);
 800e222:	687b      	ldr	r3, [r7, #4]
 800e224:	617b      	str	r3, [r7, #20]
 800e226:	697b      	ldr	r3, [r7, #20]
 800e228:	2b00      	cmp	r3, #0
 800e22a:	d002      	beq.n	800e232 <wolfSSL_BIO_free+0x17e>
 800e22c:	6978      	ldr	r0, [r7, #20]
 800e22e:	f010 fc4d 	bl	801eacc <wolfSSL_Free>
            return WOLFSSL_SUCCESS;
 800e232:	2301      	movs	r3, #1
 800e234:	e000      	b.n	800e238 <wolfSSL_BIO_free+0x184>
        }
        return WOLFSSL_FAILURE;
 800e236:	2300      	movs	r3, #0
    }
 800e238:	4618      	mov	r0, r3
 800e23a:	372c      	adds	r7, #44	@ 0x2c
 800e23c:	46bd      	mov	sp, r7
 800e23e:	bd90      	pop	{r4, r7, pc}

0800e240 <wolfSSL_BIO_vfree>:

    /* like BIO_free, but no return value */
    void wolfSSL_BIO_vfree(WOLFSSL_BIO* bio)
    {
 800e240:	b580      	push	{r7, lr}
 800e242:	b082      	sub	sp, #8
 800e244:	af00      	add	r7, sp, #0
 800e246:	6078      	str	r0, [r7, #4]
        wolfSSL_BIO_free(bio);
 800e248:	6878      	ldr	r0, [r7, #4]
 800e24a:	f7ff ff33 	bl	800e0b4 <wolfSSL_BIO_free>
    }
 800e24e:	bf00      	nop
 800e250:	3708      	adds	r7, #8
 800e252:	46bd      	mov	sp, r7
 800e254:	bd80      	pop	{r7, pc}

0800e256 <wolfSSL_ASN1_STRING_clear>:
/* Clear out and free internal pointers of ASN.1 STRING object.
 *
 * @param [in] asn1  ASN.1 STRING object.
 */
static void wolfSSL_ASN1_STRING_clear(WOLFSSL_ASN1_STRING* asn1)
{
 800e256:	b580      	push	{r7, lr}
 800e258:	b084      	sub	sp, #16
 800e25a:	af00      	add	r7, sp, #0
 800e25c:	6078      	str	r0, [r7, #4]
    /* Check we have an object to free. */
    if (asn1 != NULL) {
 800e25e:	687b      	ldr	r3, [r7, #4]
 800e260:	2b00      	cmp	r3, #0
 800e262:	d019      	beq.n	800e298 <wolfSSL_ASN1_STRING_clear+0x42>
        /* Dispose of dynamic data. */
        if ((asn1->length > 0) && asn1->isDynamic) {
 800e264:	687b      	ldr	r3, [r7, #4]
 800e266:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800e268:	2b00      	cmp	r3, #0
 800e26a:	dd10      	ble.n	800e28e <wolfSSL_ASN1_STRING_clear+0x38>
 800e26c:	687b      	ldr	r3, [r7, #4]
 800e26e:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800e272:	f003 0301 	and.w	r3, r3, #1
 800e276:	b2db      	uxtb	r3, r3
 800e278:	2b00      	cmp	r3, #0
 800e27a:	d008      	beq.n	800e28e <wolfSSL_ASN1_STRING_clear+0x38>
            XFREE(asn1->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800e27c:	687b      	ldr	r3, [r7, #4]
 800e27e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800e280:	60fb      	str	r3, [r7, #12]
 800e282:	68fb      	ldr	r3, [r7, #12]
 800e284:	2b00      	cmp	r3, #0
 800e286:	d002      	beq.n	800e28e <wolfSSL_ASN1_STRING_clear+0x38>
 800e288:	68f8      	ldr	r0, [r7, #12]
 800e28a:	f010 fc1f 	bl	801eacc <wolfSSL_Free>
        }
        XMEMSET(asn1, 0, sizeof(WOLFSSL_ASN1_STRING));
 800e28e:	2258      	movs	r2, #88	@ 0x58
 800e290:	2100      	movs	r1, #0
 800e292:	6878      	ldr	r0, [r7, #4]
 800e294:	f01a f91c 	bl	80284d0 <memset>
    }
}
 800e298:	bf00      	nop
 800e29a:	3710      	adds	r7, #16
 800e29c:	46bd      	mov	sp, r7
 800e29e:	bd80      	pop	{r7, pc}

0800e2a0 <wolfSSL_X509_EXTENSION_free>:


void wolfSSL_X509_EXTENSION_free(WOLFSSL_X509_EXTENSION* x)
{
 800e2a0:	b580      	push	{r7, lr}
 800e2a2:	b084      	sub	sp, #16
 800e2a4:	af00      	add	r7, sp, #0
 800e2a6:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_X509_EXTENSION_free");
    if (x == NULL)
 800e2a8:	687b      	ldr	r3, [r7, #4]
 800e2aa:	2b00      	cmp	r3, #0
 800e2ac:	d01d      	beq.n	800e2ea <wolfSSL_X509_EXTENSION_free+0x4a>
        return;

    if (x->obj != NULL) {
 800e2ae:	687b      	ldr	r3, [r7, #4]
 800e2b0:	681b      	ldr	r3, [r3, #0]
 800e2b2:	2b00      	cmp	r3, #0
 800e2b4:	d004      	beq.n	800e2c0 <wolfSSL_X509_EXTENSION_free+0x20>
        wolfSSL_ASN1_OBJECT_free(x->obj);
 800e2b6:	687b      	ldr	r3, [r7, #4]
 800e2b8:	681b      	ldr	r3, [r3, #0]
 800e2ba:	4618      	mov	r0, r3
 800e2bc:	f7fd fb95 	bl	800b9ea <wolfSSL_ASN1_OBJECT_free>
    }

    wolfSSL_ASN1_STRING_clear(&x->value);
 800e2c0:	687b      	ldr	r3, [r7, #4]
 800e2c2:	3308      	adds	r3, #8
 800e2c4:	4618      	mov	r0, r3
 800e2c6:	f7ff ffc6 	bl	800e256 <wolfSSL_ASN1_STRING_clear>
    wolfSSL_sk_pop_free(x->ext_sk, NULL);
 800e2ca:	687b      	ldr	r3, [r7, #4]
 800e2cc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800e2d0:	2100      	movs	r1, #0
 800e2d2:	4618      	mov	r0, r3
 800e2d4:	f7ff fd2c 	bl	800dd30 <wolfSSL_sk_pop_free>

    XFREE(x, NULL, DYNAMIC_TYPE_X509_EXT);
 800e2d8:	687b      	ldr	r3, [r7, #4]
 800e2da:	60fb      	str	r3, [r7, #12]
 800e2dc:	68fb      	ldr	r3, [r7, #12]
 800e2de:	2b00      	cmp	r3, #0
 800e2e0:	d004      	beq.n	800e2ec <wolfSSL_X509_EXTENSION_free+0x4c>
 800e2e2:	68f8      	ldr	r0, [r7, #12]
 800e2e4:	f010 fbf2 	bl	801eacc <wolfSSL_Free>
 800e2e8:	e000      	b.n	800e2ec <wolfSSL_X509_EXTENSION_free+0x4c>
        return;
 800e2ea:	bf00      	nop
}
 800e2ec:	3710      	adds	r7, #16
 800e2ee:	46bd      	mov	sp, r7
 800e2f0:	bd80      	pop	{r7, pc}

0800e2f2 <ExternalFreeX509>:
    defined(OPENSSL_EXTRA)  || defined(OPENSSL_EXTRA_X509_SMALL)

/* user externally called free X509, if dynamic go ahead with free, otherwise
 * don't */
static void ExternalFreeX509(WOLFSSL_X509* x509)
{
 800e2f2:	b580      	push	{r7, lr}
 800e2f4:	b086      	sub	sp, #24
 800e2f6:	af00      	add	r7, sp, #0
 800e2f8:	6078      	str	r0, [r7, #4]
#if defined(OPENSSL_EXTRA_X509_SMALL) || defined(OPENSSL_EXTRA)
    int doFree = 0;
 800e2fa:	2300      	movs	r3, #0
 800e2fc:	60fb      	str	r3, [r7, #12]
#endif

    WOLFSSL_ENTER("ExternalFreeX509");
    if (x509) {
 800e2fe:	687b      	ldr	r3, [r7, #4]
 800e300:	2b00      	cmp	r3, #0
 800e302:	d022      	beq.n	800e34a <ExternalFreeX509+0x58>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
        wolfSSL_CRYPTO_cleanup_ex_data(&x509->ex_data);
#endif
        if (x509->dynamicMemory) {
 800e304:	687b      	ldr	r3, [r7, #4]
 800e306:	f893 3094 	ldrb.w	r3, [r3, #148]	@ 0x94
 800e30a:	2b00      	cmp	r3, #0
 800e30c:	d01d      	beq.n	800e34a <ExternalFreeX509+0x58>
        #if defined(OPENSSL_EXTRA_X509_SMALL) || defined(OPENSSL_EXTRA)
            int ret;
            wolfSSL_RefDec(&x509->ref, &doFree, &ret);
 800e30e:	687b      	ldr	r3, [r7, #4]
 800e310:	3398      	adds	r3, #152	@ 0x98
 800e312:	2101      	movs	r1, #1
 800e314:	4618      	mov	r0, r3
 800e316:	f7fc ff0b 	bl	800b130 <wolfSSL_Atomic_Int_FetchSub>
 800e31a:	6178      	str	r0, [r7, #20]
 800e31c:	697b      	ldr	r3, [r7, #20]
 800e31e:	2b01      	cmp	r3, #1
 800e320:	bf0c      	ite	eq
 800e322:	2301      	moveq	r3, #1
 800e324:	2300      	movne	r3, #0
 800e326:	b2db      	uxtb	r3, r3
 800e328:	60fb      	str	r3, [r7, #12]
 800e32a:	2300      	movs	r3, #0
 800e32c:	60bb      	str	r3, [r7, #8]
            if (ret != 0) {
                WOLFSSL_MSG("Couldn't lock x509 mutex");
            }
            if (doFree)
 800e32e:	68fb      	ldr	r3, [r7, #12]
 800e330:	2b00      	cmp	r3, #0
 800e332:	d00a      	beq.n	800e34a <ExternalFreeX509+0x58>
        #endif /* OPENSSL_EXTRA_X509_SMALL || OPENSSL_EXTRA */
            {
                FreeX509(x509);
 800e334:	6878      	ldr	r0, [r7, #4]
 800e336:	f7fb f936 	bl	80095a6 <FreeX509>
                XFREE(x509, x509->heap, DYNAMIC_TYPE_X509);
 800e33a:	687b      	ldr	r3, [r7, #4]
 800e33c:	613b      	str	r3, [r7, #16]
 800e33e:	693b      	ldr	r3, [r7, #16]
 800e340:	2b00      	cmp	r3, #0
 800e342:	d002      	beq.n	800e34a <ExternalFreeX509+0x58>
 800e344:	6938      	ldr	r0, [r7, #16]
 800e346:	f010 fbc1 	bl	801eacc <wolfSSL_Free>
        }
        else {
            WOLFSSL_MSG("free called on non dynamic object, not freeing");
        }
    }
}
 800e34a:	bf00      	nop
 800e34c:	3718      	adds	r7, #24
 800e34e:	46bd      	mov	sp, r7
 800e350:	bd80      	pop	{r7, pc}

0800e352 <wolfSSL_X509_free>:

/* Frees an external WOLFSSL_X509 structure */
WOLFSSL_ABI
void wolfSSL_X509_free(WOLFSSL_X509* x509)
{
 800e352:	b580      	push	{r7, lr}
 800e354:	b082      	sub	sp, #8
 800e356:	af00      	add	r7, sp, #0
 800e358:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_X509_free");
    ExternalFreeX509(x509);
 800e35a:	6878      	ldr	r0, [r7, #4]
 800e35c:	f7ff ffc9 	bl	800e2f2 <ExternalFreeX509>
}
 800e360:	bf00      	nop
 800e362:	3708      	adds	r7, #8
 800e364:	46bd      	mov	sp, r7
 800e366:	bd80      	pop	{r7, pc}

0800e368 <wolfSSL_sk_X509_pop_free>:
 * sk  stack to free nodes in
 * f   X509 free function
 */
void wolfSSL_sk_X509_pop_free(WOLF_STACK_OF(WOLFSSL_X509)* sk,
    void (*f) (WOLFSSL_X509*))
{
 800e368:	b580      	push	{r7, lr}
 800e36a:	b082      	sub	sp, #8
 800e36c:	af00      	add	r7, sp, #0
 800e36e:	6078      	str	r0, [r7, #4]
 800e370:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_sk_X509_pop_free");
    wolfSSL_sk_pop_free(sk, (wolfSSL_sk_freefunc)f);
 800e372:	6839      	ldr	r1, [r7, #0]
 800e374:	6878      	ldr	r0, [r7, #4]
 800e376:	f7ff fcdb 	bl	800dd30 <wolfSSL_sk_pop_free>
}
 800e37a:	bf00      	nop
 800e37c:	3708      	adds	r7, #8
 800e37e:	46bd      	mov	sp, r7
 800e380:	bd80      	pop	{r7, pc}

0800e382 <wolfSSL_sk_X509_free>:


/* free just the stack structure */
void wolfSSL_sk_X509_free(WOLF_STACK_OF(WOLFSSL_X509)* sk)
{
 800e382:	b580      	push	{r7, lr}
 800e384:	b082      	sub	sp, #8
 800e386:	af00      	add	r7, sp, #0
 800e388:	6078      	str	r0, [r7, #4]
    wolfSSL_sk_free(sk);
 800e38a:	6878      	ldr	r0, [r7, #4]
 800e38c:	f7ff fcb6 	bl	800dcfc <wolfSSL_sk_free>
}
 800e390:	bf00      	nop
 800e392:	3708      	adds	r7, #8
 800e394:	46bd      	mov	sp, r7
 800e396:	bd80      	pop	{r7, pc}

0800e398 <wolfSSL_DIST_POINT_NAME_free>:
}
#endif /* OPENSSL_EXTRA || WOLFSSL_WPAS_SMALL */

#ifdef OPENSSL_EXTRA
static void wolfSSL_DIST_POINT_NAME_free(WOLFSSL_DIST_POINT_NAME* dpn)
{
 800e398:	b580      	push	{r7, lr}
 800e39a:	b084      	sub	sp, #16
 800e39c:	af00      	add	r7, sp, #0
 800e39e:	6078      	str	r0, [r7, #4]
    if (dpn != NULL) {
 800e3a0:	687b      	ldr	r3, [r7, #4]
 800e3a2:	2b00      	cmp	r3, #0
 800e3a4:	d011      	beq.n	800e3ca <wolfSSL_DIST_POINT_NAME_free+0x32>
        if (dpn->name.fullname != NULL) {
 800e3a6:	687b      	ldr	r3, [r7, #4]
 800e3a8:	685b      	ldr	r3, [r3, #4]
 800e3aa:	2b00      	cmp	r3, #0
 800e3ac:	d005      	beq.n	800e3ba <wolfSSL_DIST_POINT_NAME_free+0x22>
            wolfSSL_sk_X509_pop_free(dpn->name.fullname, NULL);
 800e3ae:	687b      	ldr	r3, [r7, #4]
 800e3b0:	685b      	ldr	r3, [r3, #4]
 800e3b2:	2100      	movs	r1, #0
 800e3b4:	4618      	mov	r0, r3
 800e3b6:	f7ff ffd7 	bl	800e368 <wolfSSL_sk_X509_pop_free>
        }
        XFREE(dpn, NULL, DYNAMIC_TYPE_OPENSSL);
 800e3ba:	687b      	ldr	r3, [r7, #4]
 800e3bc:	60fb      	str	r3, [r7, #12]
 800e3be:	68fb      	ldr	r3, [r7, #12]
 800e3c0:	2b00      	cmp	r3, #0
 800e3c2:	d002      	beq.n	800e3ca <wolfSSL_DIST_POINT_NAME_free+0x32>
 800e3c4:	68f8      	ldr	r0, [r7, #12]
 800e3c6:	f010 fb81 	bl	801eacc <wolfSSL_Free>
    }
}
 800e3ca:	bf00      	nop
 800e3cc:	3710      	adds	r7, #16
 800e3ce:	46bd      	mov	sp, r7
 800e3d0:	bd80      	pop	{r7, pc}

0800e3d2 <wolfSSL_DIST_POINT_free>:


/* Frees DIST_POINT objects.
*/
void wolfSSL_DIST_POINT_free(WOLFSSL_DIST_POINT* dp)
{
 800e3d2:	b580      	push	{r7, lr}
 800e3d4:	b084      	sub	sp, #16
 800e3d6:	af00      	add	r7, sp, #0
 800e3d8:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_DIST_POINT_free");
    if (dp != NULL) {
 800e3da:	687b      	ldr	r3, [r7, #4]
 800e3dc:	2b00      	cmp	r3, #0
 800e3de:	d00c      	beq.n	800e3fa <wolfSSL_DIST_POINT_free+0x28>
        wolfSSL_DIST_POINT_NAME_free(dp->distpoint);
 800e3e0:	687b      	ldr	r3, [r7, #4]
 800e3e2:	681b      	ldr	r3, [r3, #0]
 800e3e4:	4618      	mov	r0, r3
 800e3e6:	f7ff ffd7 	bl	800e398 <wolfSSL_DIST_POINT_NAME_free>
        XFREE(dp, NULL, DYNAMIC_TYPE_OPENSSL);
 800e3ea:	687b      	ldr	r3, [r7, #4]
 800e3ec:	60fb      	str	r3, [r7, #12]
 800e3ee:	68fb      	ldr	r3, [r7, #12]
 800e3f0:	2b00      	cmp	r3, #0
 800e3f2:	d002      	beq.n	800e3fa <wolfSSL_DIST_POINT_free+0x28>
 800e3f4:	68f8      	ldr	r0, [r7, #12]
 800e3f6:	f010 fb69 	bl	801eacc <wolfSSL_Free>
    }
}
 800e3fa:	bf00      	nop
 800e3fc:	3710      	adds	r7, #16
 800e3fe:	46bd      	mov	sp, r7
 800e400:	bd80      	pop	{r7, pc}
	...

0800e404 <wolfSSL_GENERAL_NAME_type_free>:
#endif /* OPENSSL_EXTRA */

#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
/* free's the internal type for the general name */
static void wolfSSL_GENERAL_NAME_type_free(WOLFSSL_GENERAL_NAME* name)
{
 800e404:	b580      	push	{r7, lr}
 800e406:	b084      	sub	sp, #16
 800e408:	af00      	add	r7, sp, #0
 800e40a:	6078      	str	r0, [r7, #4]
    if (name != NULL) {
 800e40c:	687b      	ldr	r3, [r7, #4]
 800e40e:	2b00      	cmp	r3, #0
 800e410:	d079      	beq.n	800e506 <wolfSSL_GENERAL_NAME_type_free+0x102>
        switch (name->type) {
 800e412:	687b      	ldr	r3, [r7, #4]
 800e414:	681b      	ldr	r3, [r3, #0]
 800e416:	2b09      	cmp	r3, #9
 800e418:	d872      	bhi.n	800e500 <wolfSSL_GENERAL_NAME_type_free+0xfc>
 800e41a:	a201      	add	r2, pc, #4	@ (adr r2, 800e420 <wolfSSL_GENERAL_NAME_type_free+0x1c>)
 800e41c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e420:	0800e4c7 	.word	0x0800e4c7
 800e424:	0800e45b 	.word	0x0800e45b
 800e428:	0800e46d 	.word	0x0800e46d
 800e42c:	0800e501 	.word	0x0800e501
 800e430:	0800e47f 	.word	0x0800e47f
 800e434:	0800e501 	.word	0x0800e501
 800e438:	0800e491 	.word	0x0800e491
 800e43c:	0800e4a3 	.word	0x0800e4a3
 800e440:	0800e4b5 	.word	0x0800e4b5
 800e444:	0800e449 	.word	0x0800e449
        case WOLFSSL_GEN_IA5:
            wolfSSL_ASN1_STRING_free(name->d.ia5);
 800e448:	687b      	ldr	r3, [r7, #4]
 800e44a:	685b      	ldr	r3, [r3, #4]
 800e44c:	4618      	mov	r0, r3
 800e44e:	f7fd fb2b 	bl	800baa8 <wolfSSL_ASN1_STRING_free>
            name->d.ia5 = NULL;
 800e452:	687b      	ldr	r3, [r7, #4]
 800e454:	2200      	movs	r2, #0
 800e456:	605a      	str	r2, [r3, #4]
            break;
 800e458:	e055      	b.n	800e506 <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_EMAIL:
            wolfSSL_ASN1_STRING_free(name->d.rfc822Name);
 800e45a:	687b      	ldr	r3, [r7, #4]
 800e45c:	685b      	ldr	r3, [r3, #4]
 800e45e:	4618      	mov	r0, r3
 800e460:	f7fd fb22 	bl	800baa8 <wolfSSL_ASN1_STRING_free>
            name->d.rfc822Name = NULL;
 800e464:	687b      	ldr	r3, [r7, #4]
 800e466:	2200      	movs	r2, #0
 800e468:	605a      	str	r2, [r3, #4]
            break;
 800e46a:	e04c      	b.n	800e506 <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_DNS:
            wolfSSL_ASN1_STRING_free(name->d.dNSName);
 800e46c:	687b      	ldr	r3, [r7, #4]
 800e46e:	685b      	ldr	r3, [r3, #4]
 800e470:	4618      	mov	r0, r3
 800e472:	f7fd fb19 	bl	800baa8 <wolfSSL_ASN1_STRING_free>
            name->d.dNSName = NULL;
 800e476:	687b      	ldr	r3, [r7, #4]
 800e478:	2200      	movs	r2, #0
 800e47a:	605a      	str	r2, [r3, #4]
            break;
 800e47c:	e043      	b.n	800e506 <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_DIRNAME:
            wolfSSL_X509_NAME_free(name->d.dirn);
 800e47e:	687b      	ldr	r3, [r7, #4]
 800e480:	685b      	ldr	r3, [r3, #4]
 800e482:	4618      	mov	r0, r3
 800e484:	f000 f87d 	bl	800e582 <wolfSSL_X509_NAME_free>
            name->d.dirn = NULL;
 800e488:	687b      	ldr	r3, [r7, #4]
 800e48a:	2200      	movs	r2, #0
 800e48c:	605a      	str	r2, [r3, #4]
            break;
 800e48e:	e03a      	b.n	800e506 <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_URI:
            wolfSSL_ASN1_STRING_free(name->d.uniformResourceIdentifier);
 800e490:	687b      	ldr	r3, [r7, #4]
 800e492:	685b      	ldr	r3, [r3, #4]
 800e494:	4618      	mov	r0, r3
 800e496:	f7fd fb07 	bl	800baa8 <wolfSSL_ASN1_STRING_free>
            name->d.uniformResourceIdentifier = NULL;
 800e49a:	687b      	ldr	r3, [r7, #4]
 800e49c:	2200      	movs	r2, #0
 800e49e:	605a      	str	r2, [r3, #4]
            break;
 800e4a0:	e031      	b.n	800e506 <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_IPADD:
            wolfSSL_ASN1_STRING_free(name->d.iPAddress);
 800e4a2:	687b      	ldr	r3, [r7, #4]
 800e4a4:	685b      	ldr	r3, [r3, #4]
 800e4a6:	4618      	mov	r0, r3
 800e4a8:	f7fd fafe 	bl	800baa8 <wolfSSL_ASN1_STRING_free>
            name->d.iPAddress = NULL;
 800e4ac:	687b      	ldr	r3, [r7, #4]
 800e4ae:	2200      	movs	r2, #0
 800e4b0:	605a      	str	r2, [r3, #4]
            break;
 800e4b2:	e028      	b.n	800e506 <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_RID:
            wolfSSL_ASN1_OBJECT_free(name->d.registeredID);
 800e4b4:	687b      	ldr	r3, [r7, #4]
 800e4b6:	685b      	ldr	r3, [r3, #4]
 800e4b8:	4618      	mov	r0, r3
 800e4ba:	f7fd fa96 	bl	800b9ea <wolfSSL_ASN1_OBJECT_free>
            name->d.registeredID = NULL;
 800e4be:	687b      	ldr	r3, [r7, #4]
 800e4c0:	2200      	movs	r2, #0
 800e4c2:	605a      	str	r2, [r3, #4]
            break;
 800e4c4:	e01f      	b.n	800e506 <wolfSSL_GENERAL_NAME_type_free+0x102>
        case WOLFSSL_GEN_OTHERNAME:
            if (name->d.otherName != NULL) {
 800e4c6:	687b      	ldr	r3, [r7, #4]
 800e4c8:	685b      	ldr	r3, [r3, #4]
 800e4ca:	2b00      	cmp	r3, #0
 800e4cc:	d01a      	beq.n	800e504 <wolfSSL_GENERAL_NAME_type_free+0x100>
                wolfSSL_ASN1_OBJECT_free(name->d.otherName->type_id);
 800e4ce:	687b      	ldr	r3, [r7, #4]
 800e4d0:	685b      	ldr	r3, [r3, #4]
 800e4d2:	681b      	ldr	r3, [r3, #0]
 800e4d4:	4618      	mov	r0, r3
 800e4d6:	f7fd fa88 	bl	800b9ea <wolfSSL_ASN1_OBJECT_free>
                wolfSSL_ASN1_TYPE_free(name->d.otherName->value);
 800e4da:	687b      	ldr	r3, [r7, #4]
 800e4dc:	685b      	ldr	r3, [r3, #4]
 800e4de:	685b      	ldr	r3, [r3, #4]
 800e4e0:	4618      	mov	r0, r3
 800e4e2:	f7fd fc0d 	bl	800bd00 <wolfSSL_ASN1_TYPE_free>
                XFREE(name->d.otherName, NULL, DYNAMIC_TYPE_ASN1);
 800e4e6:	687b      	ldr	r3, [r7, #4]
 800e4e8:	685b      	ldr	r3, [r3, #4]
 800e4ea:	60fb      	str	r3, [r7, #12]
 800e4ec:	68fb      	ldr	r3, [r7, #12]
 800e4ee:	2b00      	cmp	r3, #0
 800e4f0:	d002      	beq.n	800e4f8 <wolfSSL_GENERAL_NAME_type_free+0xf4>
 800e4f2:	68f8      	ldr	r0, [r7, #12]
 800e4f4:	f010 faea 	bl	801eacc <wolfSSL_Free>
                name->d.otherName = NULL;
 800e4f8:	687b      	ldr	r3, [r7, #4]
 800e4fa:	2200      	movs	r2, #0
 800e4fc:	605a      	str	r2, [r3, #4]
            }
            break;
 800e4fe:	e001      	b.n	800e504 <wolfSSL_GENERAL_NAME_type_free+0x100>
            /* Unsupported: fall through */
        case WOLFSSL_GEN_EDIPARTY:
            /* Unsupported: fall through */
        default:
            WOLFSSL_MSG("wolfSSL_GENERAL_NAME_type_free: possible leak");
            break;
 800e500:	bf00      	nop
 800e502:	e000      	b.n	800e506 <wolfSSL_GENERAL_NAME_type_free+0x102>
            break;
 800e504:	bf00      	nop
        }
    }
}
 800e506:	bf00      	nop
 800e508:	3710      	adds	r7, #16
 800e50a:	46bd      	mov	sp, r7
 800e50c:	bd80      	pop	{r7, pc}
 800e50e:	bf00      	nop

0800e510 <wolfSSL_GENERAL_NAME_free>:
}

/* Frees GENERAL_NAME objects.
*/
void wolfSSL_GENERAL_NAME_free(WOLFSSL_GENERAL_NAME* name)
{
 800e510:	b580      	push	{r7, lr}
 800e512:	b084      	sub	sp, #16
 800e514:	af00      	add	r7, sp, #0
 800e516:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_GENERAL_NAME_Free");
    if (name != NULL) {
 800e518:	687b      	ldr	r3, [r7, #4]
 800e51a:	2b00      	cmp	r3, #0
 800e51c:	d00a      	beq.n	800e534 <wolfSSL_GENERAL_NAME_free+0x24>
        wolfSSL_GENERAL_NAME_type_free(name);
 800e51e:	6878      	ldr	r0, [r7, #4]
 800e520:	f7ff ff70 	bl	800e404 <wolfSSL_GENERAL_NAME_type_free>
        XFREE(name, NULL, DYNAMIC_TYPE_OPENSSL);
 800e524:	687b      	ldr	r3, [r7, #4]
 800e526:	60fb      	str	r3, [r7, #12]
 800e528:	68fb      	ldr	r3, [r7, #12]
 800e52a:	2b00      	cmp	r3, #0
 800e52c:	d002      	beq.n	800e534 <wolfSSL_GENERAL_NAME_free+0x24>
 800e52e:	68f8      	ldr	r0, [r7, #12]
 800e530:	f010 facc 	bl	801eacc <wolfSSL_Free>
    }
}
 800e534:	bf00      	nop
 800e536:	3710      	adds	r7, #16
 800e538:	46bd      	mov	sp, r7
 800e53a:	bd80      	pop	{r7, pc}

0800e53c <wolfSSL_sk_X509_EXTENSION_pop_free>:

/* frees all of the nodes and the values in stack */
void wolfSSL_sk_X509_EXTENSION_pop_free(
        WOLF_STACK_OF(WOLFSSL_X509_EXTENSION)* sk,
        void (*f) (WOLFSSL_X509_EXTENSION*))
{
 800e53c:	b580      	push	{r7, lr}
 800e53e:	b082      	sub	sp, #8
 800e540:	af00      	add	r7, sp, #0
 800e542:	6078      	str	r0, [r7, #4]
 800e544:	6039      	str	r1, [r7, #0]
    wolfSSL_sk_pop_free(sk, (wolfSSL_sk_freefunc)f);
 800e546:	6839      	ldr	r1, [r7, #0]
 800e548:	6878      	ldr	r0, [r7, #4]
 800e54a:	f7ff fbf1 	bl	800dd30 <wolfSSL_sk_pop_free>
}
 800e54e:	bf00      	nop
 800e550:	3708      	adds	r7, #8
 800e552:	46bd      	mov	sp, r7
 800e554:	bd80      	pop	{r7, pc}

0800e556 <wolfSSL_X509_new_ex>:

/* returns a pointer to a new WOLFSSL_X509 structure on success and NULL on
 * fail
 */
WOLFSSL_X509* wolfSSL_X509_new_ex(void* heap)
{
 800e556:	b580      	push	{r7, lr}
 800e558:	b084      	sub	sp, #16
 800e55a:	af00      	add	r7, sp, #0
 800e55c:	6078      	str	r0, [r7, #4]
    WOLFSSL_X509* x509;

    x509 = (WOLFSSL_X509*)XMALLOC(sizeof(WOLFSSL_X509), heap,
 800e55e:	f640 40d4 	movw	r0, #3284	@ 0xcd4
 800e562:	f010 fa97 	bl	801ea94 <wolfSSL_Malloc>
 800e566:	60f8      	str	r0, [r7, #12]
            DYNAMIC_TYPE_X509);
    if (x509 != NULL) {
 800e568:	68fb      	ldr	r3, [r7, #12]
 800e56a:	2b00      	cmp	r3, #0
 800e56c:	d004      	beq.n	800e578 <wolfSSL_X509_new_ex+0x22>
        InitX509(x509, 1, heap);
 800e56e:	687a      	ldr	r2, [r7, #4]
 800e570:	2101      	movs	r1, #1
 800e572:	68f8      	ldr	r0, [r7, #12]
 800e574:	f7fa ffe4 	bl	8009540 <InitX509>
    }

    return x509;
 800e578:	68fb      	ldr	r3, [r7, #12]
}
 800e57a:	4618      	mov	r0, r3
 800e57c:	3710      	adds	r7, #16
 800e57e:	46bd      	mov	sp, r7
 800e580:	bd80      	pop	{r7, pc}

0800e582 <wolfSSL_X509_NAME_free>:
}
#endif

#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    void wolfSSL_X509_NAME_free(WOLFSSL_X509_NAME *name)
    {
 800e582:	b580      	push	{r7, lr}
 800e584:	b084      	sub	sp, #16
 800e586:	af00      	add	r7, sp, #0
 800e588:	6078      	str	r0, [r7, #4]
        WOLFSSL_ENTER("wolfSSL_X509_NAME_free");
        FreeX509Name(name);
 800e58a:	6878      	ldr	r0, [r7, #4]
 800e58c:	f7fa ff73 	bl	8009476 <FreeX509Name>
        if (name != NULL) {
 800e590:	687b      	ldr	r3, [r7, #4]
 800e592:	2b00      	cmp	r3, #0
 800e594:	d007      	beq.n	800e5a6 <wolfSSL_X509_NAME_free+0x24>
            XFREE(name, name->heap, DYNAMIC_TYPE_X509);
 800e596:	687b      	ldr	r3, [r7, #4]
 800e598:	60fb      	str	r3, [r7, #12]
 800e59a:	68fb      	ldr	r3, [r7, #12]
 800e59c:	2b00      	cmp	r3, #0
 800e59e:	d002      	beq.n	800e5a6 <wolfSSL_X509_NAME_free+0x24>
 800e5a0:	68f8      	ldr	r0, [r7, #12]
 800e5a2:	f010 fa93 	bl	801eacc <wolfSSL_Free>
        }
    }
 800e5a6:	bf00      	nop
 800e5a8:	3710      	adds	r7, #16
 800e5aa:	46bd      	mov	sp, r7
 800e5ac:	bd80      	pop	{r7, pc}

0800e5ae <wolfSSL_X509_NAME_new_ex>:
    /* Malloc's a new WOLFSSL_X509_NAME structure
     *
     * returns NULL on failure, otherwise returns a new structure.
     */
    WOLFSSL_X509_NAME* wolfSSL_X509_NAME_new_ex(void *heap)
    {
 800e5ae:	b580      	push	{r7, lr}
 800e5b0:	b084      	sub	sp, #16
 800e5b2:	af00      	add	r7, sp, #0
 800e5b4:	6078      	str	r0, [r7, #4]
        WOLFSSL_X509_NAME* name;

        WOLFSSL_ENTER("wolfSSL_X509_NAME_new_ex");

        name = (WOLFSSL_X509_NAME*)XMALLOC(sizeof(WOLFSSL_X509_NAME), heap,
 800e5b6:	f240 500c 	movw	r0, #1292	@ 0x50c
 800e5ba:	f010 fa6b 	bl	801ea94 <wolfSSL_Malloc>
 800e5be:	60f8      	str	r0, [r7, #12]
                DYNAMIC_TYPE_X509);
        if (name != NULL) {
 800e5c0:	68fb      	ldr	r3, [r7, #12]
 800e5c2:	2b00      	cmp	r3, #0
 800e5c4:	d004      	beq.n	800e5d0 <wolfSSL_X509_NAME_new_ex+0x22>
            InitX509Name(name, 1, heap);
 800e5c6:	687a      	ldr	r2, [r7, #4]
 800e5c8:	2101      	movs	r1, #1
 800e5ca:	68f8      	ldr	r0, [r7, #12]
 800e5cc:	f7fa ff34 	bl	8009438 <InitX509Name>
        }
        return name;
 800e5d0:	68fb      	ldr	r3, [r7, #12]
    }
 800e5d2:	4618      	mov	r0, r3
 800e5d4:	3710      	adds	r7, #16
 800e5d6:	46bd      	mov	sp, r7
 800e5d8:	bd80      	pop	{r7, pc}

0800e5da <wolfSSL_X509_NAME_ENTRY_free>:
    }
#endif /* !NO_BIO */
#endif /* OPENSSL_ALL */

    void wolfSSL_X509_NAME_ENTRY_free(WOLFSSL_X509_NAME_ENTRY* ne)
    {
 800e5da:	b580      	push	{r7, lr}
 800e5dc:	b084      	sub	sp, #16
 800e5de:	af00      	add	r7, sp, #0
 800e5e0:	6078      	str	r0, [r7, #4]
        WOLFSSL_ENTER("wolfSSL_X509_NAME_ENTRY_free");
        if (ne != NULL) {
 800e5e2:	687b      	ldr	r3, [r7, #4]
 800e5e4:	2b00      	cmp	r3, #0
 800e5e6:	d015      	beq.n	800e614 <wolfSSL_X509_NAME_ENTRY_free+0x3a>
            wolfSSL_ASN1_OBJECT_free(ne->object);
 800e5e8:	687b      	ldr	r3, [r7, #4]
 800e5ea:	681b      	ldr	r3, [r3, #0]
 800e5ec:	4618      	mov	r0, r3
 800e5ee:	f7fd f9fc 	bl	800b9ea <wolfSSL_ASN1_OBJECT_free>
            if (ne->value != NULL) {
 800e5f2:	687b      	ldr	r3, [r7, #4]
 800e5f4:	685b      	ldr	r3, [r3, #4]
 800e5f6:	2b00      	cmp	r3, #0
 800e5f8:	d004      	beq.n	800e604 <wolfSSL_X509_NAME_ENTRY_free+0x2a>
                wolfSSL_ASN1_STRING_free(ne->value);
 800e5fa:	687b      	ldr	r3, [r7, #4]
 800e5fc:	685b      	ldr	r3, [r3, #4]
 800e5fe:	4618      	mov	r0, r3
 800e600:	f7fd fa52 	bl	800baa8 <wolfSSL_ASN1_STRING_free>
            }
            XFREE(ne, NULL, DYNAMIC_TYPE_NAME_ENTRY);
 800e604:	687b      	ldr	r3, [r7, #4]
 800e606:	60fb      	str	r3, [r7, #12]
 800e608:	68fb      	ldr	r3, [r7, #12]
 800e60a:	2b00      	cmp	r3, #0
 800e60c:	d002      	beq.n	800e614 <wolfSSL_X509_NAME_ENTRY_free+0x3a>
 800e60e:	68f8      	ldr	r0, [r7, #12]
 800e610:	f010 fa5c 	bl	801eacc <wolfSSL_Free>
        }
    }
 800e614:	bf00      	nop
 800e616:	3710      	adds	r7, #16
 800e618:	46bd      	mov	sp, r7
 800e61a:	bd80      	pop	{r7, pc}

0800e61c <wolfSSL_X509_NAME_ENTRY_new>:


    WOLFSSL_X509_NAME_ENTRY* wolfSSL_X509_NAME_ENTRY_new(void)
    {
 800e61c:	b580      	push	{r7, lr}
 800e61e:	b082      	sub	sp, #8
 800e620:	af00      	add	r7, sp, #0
        WOLFSSL_X509_NAME_ENTRY* ne;

        ne = (WOLFSSL_X509_NAME_ENTRY*)XMALLOC(sizeof(WOLFSSL_X509_NAME_ENTRY),
 800e622:	2014      	movs	r0, #20
 800e624:	f010 fa36 	bl	801ea94 <wolfSSL_Malloc>
 800e628:	6078      	str	r0, [r7, #4]
                NULL, DYNAMIC_TYPE_NAME_ENTRY);
        if (ne != NULL) {
 800e62a:	687b      	ldr	r3, [r7, #4]
 800e62c:	2b00      	cmp	r3, #0
 800e62e:	d004      	beq.n	800e63a <wolfSSL_X509_NAME_ENTRY_new+0x1e>
            XMEMSET(ne, 0, sizeof(WOLFSSL_X509_NAME_ENTRY));
 800e630:	2214      	movs	r2, #20
 800e632:	2100      	movs	r1, #0
 800e634:	6878      	ldr	r0, [r7, #4]
 800e636:	f019 ff4b 	bl	80284d0 <memset>
        }

        return ne;
 800e63a:	687b      	ldr	r3, [r7, #4]
    }
 800e63c:	4618      	mov	r0, r3
 800e63e:	3708      	adds	r7, #8
 800e640:	46bd      	mov	sp, r7
 800e642:	bd80      	pop	{r7, pc}

0800e644 <wolfssl_x509_name_entry_set>:

    static void wolfssl_x509_name_entry_set(WOLFSSL_X509_NAME_ENTRY* ne,
        int nid, int type, const unsigned char *data, int dataSz)
    {
 800e644:	b580      	push	{r7, lr}
 800e646:	b084      	sub	sp, #16
 800e648:	af00      	add	r7, sp, #0
 800e64a:	60f8      	str	r0, [r7, #12]
 800e64c:	60b9      	str	r1, [r7, #8]
 800e64e:	607a      	str	r2, [r7, #4]
 800e650:	603b      	str	r3, [r7, #0]
        ne->nid = nid;
 800e652:	68fb      	ldr	r3, [r7, #12]
 800e654:	68ba      	ldr	r2, [r7, #8]
 800e656:	609a      	str	r2, [r3, #8]
        /* Reuse the object if already available. */
        ne->object = wolfSSL_OBJ_nid2obj_ex(nid, ne->object);
 800e658:	68fb      	ldr	r3, [r7, #12]
 800e65a:	681b      	ldr	r3, [r3, #0]
 800e65c:	4619      	mov	r1, r3
 800e65e:	68b8      	ldr	r0, [r7, #8]
 800e660:	f7ff fbee 	bl	800de40 <wolfSSL_OBJ_nid2obj_ex>
 800e664:	4602      	mov	r2, r0
 800e666:	68fb      	ldr	r3, [r7, #12]
 800e668:	601a      	str	r2, [r3, #0]
        if (ne->value == NULL) {
 800e66a:	68fb      	ldr	r3, [r7, #12]
 800e66c:	685b      	ldr	r3, [r3, #4]
 800e66e:	2b00      	cmp	r3, #0
 800e670:	d105      	bne.n	800e67e <wolfssl_x509_name_entry_set+0x3a>
            ne->value = wolfSSL_ASN1_STRING_type_new(type);
 800e672:	6878      	ldr	r0, [r7, #4]
 800e674:	f7fd fa06 	bl	800ba84 <wolfSSL_ASN1_STRING_type_new>
 800e678:	4602      	mov	r2, r0
 800e67a:	68fb      	ldr	r3, [r7, #12]
 800e67c:	605a      	str	r2, [r3, #4]
        }
        if (ne->value != NULL) {
 800e67e:	68fb      	ldr	r3, [r7, #12]
 800e680:	685b      	ldr	r3, [r3, #4]
 800e682:	2b00      	cmp	r3, #0
 800e684:	d015      	beq.n	800e6b2 <wolfssl_x509_name_entry_set+0x6e>
            if (wolfSSL_ASN1_STRING_set(ne->value, (const void*)data,
 800e686:	68fb      	ldr	r3, [r7, #12]
 800e688:	685b      	ldr	r3, [r3, #4]
 800e68a:	69ba      	ldr	r2, [r7, #24]
 800e68c:	6839      	ldr	r1, [r7, #0]
 800e68e:	4618      	mov	r0, r3
 800e690:	f7fd fa6b 	bl	800bb6a <wolfSSL_ASN1_STRING_set>
 800e694:	4603      	mov	r3, r0
 800e696:	2b01      	cmp	r3, #1
 800e698:	d103      	bne.n	800e6a2 <wolfssl_x509_name_entry_set+0x5e>
                                            dataSz) == WOLFSSL_SUCCESS) {
                ne->set = 1;
 800e69a:	68fb      	ldr	r3, [r7, #12]
 800e69c:	2201      	movs	r2, #1
 800e69e:	60da      	str	r2, [r3, #12]
                /* Free the ASN1_STRING if it is not set. */
                wolfSSL_ASN1_STRING_free(ne->value);
                ne->value = NULL;
            }
        }
    }
 800e6a0:	e007      	b.n	800e6b2 <wolfssl_x509_name_entry_set+0x6e>
                wolfSSL_ASN1_STRING_free(ne->value);
 800e6a2:	68fb      	ldr	r3, [r7, #12]
 800e6a4:	685b      	ldr	r3, [r3, #4]
 800e6a6:	4618      	mov	r0, r3
 800e6a8:	f7fd f9fe 	bl	800baa8 <wolfSSL_ASN1_STRING_free>
                ne->value = NULL;
 800e6ac:	68fb      	ldr	r3, [r7, #12]
 800e6ae:	2200      	movs	r2, #0
 800e6b0:	605a      	str	r2, [r3, #4]
    }
 800e6b2:	bf00      	nop
 800e6b4:	3710      	adds	r7, #16
 800e6b6:	46bd      	mov	sp, r7
 800e6b8:	bd80      	pop	{r7, pc}

0800e6ba <wolfSSL_X509_NAME_ENTRY_create_by_NID>:
     * returns a pointer to WOLFSSL_X509_NAME_ENTRY on success and NULL on fail
     */
    WOLFSSL_X509_NAME_ENTRY* wolfSSL_X509_NAME_ENTRY_create_by_NID(
            WOLFSSL_X509_NAME_ENTRY** out, int nid, int type,
            const unsigned char* data, int dataSz)
    {
 800e6ba:	b580      	push	{r7, lr}
 800e6bc:	b088      	sub	sp, #32
 800e6be:	af02      	add	r7, sp, #8
 800e6c0:	60f8      	str	r0, [r7, #12]
 800e6c2:	60b9      	str	r1, [r7, #8]
 800e6c4:	607a      	str	r2, [r7, #4]
 800e6c6:	603b      	str	r3, [r7, #0]

#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_X509_NAME_ENTRY_create_by_NID");
#endif

        if (!data) {
 800e6c8:	683b      	ldr	r3, [r7, #0]
 800e6ca:	2b00      	cmp	r3, #0
 800e6cc:	d101      	bne.n	800e6d2 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x18>
            WOLFSSL_MSG("Bad parameter");
            return NULL;
 800e6ce:	2300      	movs	r3, #0
 800e6d0:	e021      	b.n	800e716 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x5c>
        }

        if (out == NULL || *out == NULL) {
 800e6d2:	68fb      	ldr	r3, [r7, #12]
 800e6d4:	2b00      	cmp	r3, #0
 800e6d6:	d003      	beq.n	800e6e0 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x26>
 800e6d8:	68fb      	ldr	r3, [r7, #12]
 800e6da:	681b      	ldr	r3, [r3, #0]
 800e6dc:	2b00      	cmp	r3, #0
 800e6de:	d10e      	bne.n	800e6fe <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x44>
            ne = wolfSSL_X509_NAME_ENTRY_new();
 800e6e0:	f7ff ff9c 	bl	800e61c <wolfSSL_X509_NAME_ENTRY_new>
 800e6e4:	6178      	str	r0, [r7, #20]
            if (ne == NULL) {
 800e6e6:	697b      	ldr	r3, [r7, #20]
 800e6e8:	2b00      	cmp	r3, #0
 800e6ea:	d101      	bne.n	800e6f0 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x36>
                return NULL;
 800e6ec:	2300      	movs	r3, #0
 800e6ee:	e012      	b.n	800e716 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x5c>
            }
            if (out != NULL) {
 800e6f0:	68fb      	ldr	r3, [r7, #12]
 800e6f2:	2b00      	cmp	r3, #0
 800e6f4:	d006      	beq.n	800e704 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x4a>
                *out = ne;
 800e6f6:	68fb      	ldr	r3, [r7, #12]
 800e6f8:	697a      	ldr	r2, [r7, #20]
 800e6fa:	601a      	str	r2, [r3, #0]
            if (out != NULL) {
 800e6fc:	e002      	b.n	800e704 <wolfSSL_X509_NAME_ENTRY_create_by_NID+0x4a>
            }
        }
        else {
            ne = *out;
 800e6fe:	68fb      	ldr	r3, [r7, #12]
 800e700:	681b      	ldr	r3, [r3, #0]
 800e702:	617b      	str	r3, [r7, #20]
        }

        wolfssl_x509_name_entry_set(ne, nid, type, data, dataSz);
 800e704:	6a3b      	ldr	r3, [r7, #32]
 800e706:	9300      	str	r3, [sp, #0]
 800e708:	683b      	ldr	r3, [r7, #0]
 800e70a:	687a      	ldr	r2, [r7, #4]
 800e70c:	68b9      	ldr	r1, [r7, #8]
 800e70e:	6978      	ldr	r0, [r7, #20]
 800e710:	f7ff ff98 	bl	800e644 <wolfssl_x509_name_entry_set>

        return ne;
 800e714:	697b      	ldr	r3, [r7, #20]
    }
 800e716:	4618      	mov	r0, r3
 800e718:	3718      	adds	r7, #24
 800e71a:	46bd      	mov	sp, r7
 800e71c:	bd80      	pop	{r7, pc}

0800e71e <wolfSSL_X509_NAME_ENTRY_get_object>:
    defined(HAVE_LIGHTY) || defined(WOLFSSL_MYSQL_COMPATIBLE) || \
    defined(HAVE_STUNNEL) || defined(WOLFSSL_NGINX) || \
    defined(HAVE_POCO_LIB) || defined(WOLFSSL_HAPROXY)
WOLFSSL_ASN1_OBJECT* wolfSSL_X509_NAME_ENTRY_get_object(
    WOLFSSL_X509_NAME_ENTRY *ne)
{
 800e71e:	b580      	push	{r7, lr}
 800e720:	b084      	sub	sp, #16
 800e722:	af00      	add	r7, sp, #0
 800e724:	6078      	str	r0, [r7, #4]
    WOLFSSL_ASN1_OBJECT* object = NULL;
 800e726:	2300      	movs	r3, #0
 800e728:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_DEBUG_OPENSSL
    WOLFSSL_ENTER("wolfSSL_X509_NAME_ENTRY_get_object");
#endif

    if (ne != NULL) {
 800e72a:	687b      	ldr	r3, [r7, #4]
 800e72c:	2b00      	cmp	r3, #0
 800e72e:	d00e      	beq.n	800e74e <wolfSSL_X509_NAME_ENTRY_get_object+0x30>
        /* Create object from nid - reuse existing object if possible. */
        object = wolfSSL_OBJ_nid2obj_ex(ne->nid, ne->object);
 800e730:	687b      	ldr	r3, [r7, #4]
 800e732:	689a      	ldr	r2, [r3, #8]
 800e734:	687b      	ldr	r3, [r7, #4]
 800e736:	681b      	ldr	r3, [r3, #0]
 800e738:	4619      	mov	r1, r3
 800e73a:	4610      	mov	r0, r2
 800e73c:	f7ff fb80 	bl	800de40 <wolfSSL_OBJ_nid2obj_ex>
 800e740:	60f8      	str	r0, [r7, #12]
        if (object != NULL) {
 800e742:	68fb      	ldr	r3, [r7, #12]
 800e744:	2b00      	cmp	r3, #0
 800e746:	d002      	beq.n	800e74e <wolfSSL_X509_NAME_ENTRY_get_object+0x30>
            /* Set the object when no error. */
            ne->object = object;
 800e748:	687b      	ldr	r3, [r7, #4]
 800e74a:	68fa      	ldr	r2, [r7, #12]
 800e74c:	601a      	str	r2, [r3, #0]
        }
    }

    return object;
 800e74e:	68fb      	ldr	r3, [r7, #12]
}
 800e750:	4618      	mov	r0, r3
 800e752:	3710      	adds	r7, #16
 800e754:	46bd      	mov	sp, r7
 800e756:	bd80      	pop	{r7, pc}

0800e758 <AddAllEntry>:
     * since number of entries is small, a brute force search is used here
     * returns the number of entries added
     */
    static int AddAllEntry(WOLFSSL_X509_NAME* name, char* fullName,
            int fullNameSz, int* idx)
    {
 800e758:	b580      	push	{r7, lr}
 800e75a:	b08a      	sub	sp, #40	@ 0x28
 800e75c:	af00      	add	r7, sp, #0
 800e75e:	60f8      	str	r0, [r7, #12]
 800e760:	60b9      	str	r1, [r7, #8]
 800e762:	607a      	str	r2, [r7, #4]
 800e764:	603b      	str	r3, [r7, #0]
        int i;
        int ret = 0;
 800e766:	2300      	movs	r3, #0
 800e768:	623b      	str	r3, [r7, #32]

        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e76a:	2300      	movs	r3, #0
 800e76c:	627b      	str	r3, [r7, #36]	@ 0x24
 800e76e:	e07a      	b.n	800e866 <AddAllEntry+0x10e>
            if (name->entry[i].set) {
 800e770:	68f9      	ldr	r1, [r7, #12]
 800e772:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e774:	4613      	mov	r3, r2
 800e776:	009b      	lsls	r3, r3, #2
 800e778:	4413      	add	r3, r2
 800e77a:	009b      	lsls	r3, r3, #2
 800e77c:	440b      	add	r3, r1
 800e77e:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800e782:	681b      	ldr	r3, [r3, #0]
 800e784:	2b00      	cmp	r3, #0
 800e786:	d06b      	beq.n	800e860 <AddAllEntry+0x108>
                WOLFSSL_ASN1_OBJECT* obj;

                int sz;
                unsigned char* data;

                e = &name->entry[i];
 800e788:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e78a:	4613      	mov	r3, r2
 800e78c:	009b      	lsls	r3, r3, #2
 800e78e:	4413      	add	r3, r2
 800e790:	009b      	lsls	r3, r3, #2
 800e792:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800e796:	68fa      	ldr	r2, [r7, #12]
 800e798:	4413      	add	r3, r2
 800e79a:	3304      	adds	r3, #4
 800e79c:	61fb      	str	r3, [r7, #28]
                obj = wolfSSL_X509_NAME_ENTRY_get_object(e);
 800e79e:	69f8      	ldr	r0, [r7, #28]
 800e7a0:	f7ff ffbd 	bl	800e71e <wolfSSL_X509_NAME_ENTRY_get_object>
 800e7a4:	61b8      	str	r0, [r7, #24]
                if (obj == NULL) {
 800e7a6:	69bb      	ldr	r3, [r7, #24]
 800e7a8:	2b00      	cmp	r3, #0
 800e7aa:	d102      	bne.n	800e7b2 <AddAllEntry+0x5a>
                    return BAD_FUNC_ARG;
 800e7ac:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800e7b0:	e05d      	b.n	800e86e <AddAllEntry+0x116>
                }

                XMEMCPY(fullName + *idx, "/", 1); *idx = *idx + 1;
 800e7b2:	683b      	ldr	r3, [r7, #0]
 800e7b4:	681b      	ldr	r3, [r3, #0]
 800e7b6:	461a      	mov	r2, r3
 800e7b8:	68bb      	ldr	r3, [r7, #8]
 800e7ba:	4413      	add	r3, r2
 800e7bc:	2201      	movs	r2, #1
 800e7be:	492e      	ldr	r1, [pc, #184]	@ (800e878 <AddAllEntry+0x120>)
 800e7c0:	4618      	mov	r0, r3
 800e7c2:	f019 feef 	bl	80285a4 <memcpy>
 800e7c6:	683b      	ldr	r3, [r7, #0]
 800e7c8:	681b      	ldr	r3, [r3, #0]
 800e7ca:	1c5a      	adds	r2, r3, #1
 800e7cc:	683b      	ldr	r3, [r7, #0]
 800e7ce:	601a      	str	r2, [r3, #0]
                sz = (int)XSTRLEN(obj->sName);
 800e7d0:	69bb      	ldr	r3, [r7, #24]
 800e7d2:	3308      	adds	r3, #8
 800e7d4:	4618      	mov	r0, r3
 800e7d6:	f7f1 fd05 	bl	80001e4 <strlen>
 800e7da:	4603      	mov	r3, r0
 800e7dc:	617b      	str	r3, [r7, #20]
                XMEMCPY(fullName + *idx, obj->sName, sz);
 800e7de:	683b      	ldr	r3, [r7, #0]
 800e7e0:	681b      	ldr	r3, [r3, #0]
 800e7e2:	461a      	mov	r2, r3
 800e7e4:	68bb      	ldr	r3, [r7, #8]
 800e7e6:	1898      	adds	r0, r3, r2
 800e7e8:	69bb      	ldr	r3, [r7, #24]
 800e7ea:	3308      	adds	r3, #8
 800e7ec:	697a      	ldr	r2, [r7, #20]
 800e7ee:	4619      	mov	r1, r3
 800e7f0:	f019 fed8 	bl	80285a4 <memcpy>
                *idx += sz;
 800e7f4:	683b      	ldr	r3, [r7, #0]
 800e7f6:	681a      	ldr	r2, [r3, #0]
 800e7f8:	697b      	ldr	r3, [r7, #20]
 800e7fa:	441a      	add	r2, r3
 800e7fc:	683b      	ldr	r3, [r7, #0]
 800e7fe:	601a      	str	r2, [r3, #0]
                XMEMCPY(fullName + *idx, "=", 1); *idx = *idx + 1;
 800e800:	683b      	ldr	r3, [r7, #0]
 800e802:	681b      	ldr	r3, [r3, #0]
 800e804:	461a      	mov	r2, r3
 800e806:	68bb      	ldr	r3, [r7, #8]
 800e808:	4413      	add	r3, r2
 800e80a:	2201      	movs	r2, #1
 800e80c:	491b      	ldr	r1, [pc, #108]	@ (800e87c <AddAllEntry+0x124>)
 800e80e:	4618      	mov	r0, r3
 800e810:	f019 fec8 	bl	80285a4 <memcpy>
 800e814:	683b      	ldr	r3, [r7, #0]
 800e816:	681b      	ldr	r3, [r3, #0]
 800e818:	1c5a      	adds	r2, r3, #1
 800e81a:	683b      	ldr	r3, [r7, #0]
 800e81c:	601a      	str	r2, [r3, #0]

                data = wolfSSL_ASN1_STRING_data(e->value);
 800e81e:	69fb      	ldr	r3, [r7, #28]
 800e820:	685b      	ldr	r3, [r3, #4]
 800e822:	4618      	mov	r0, r3
 800e824:	f7fd f97b 	bl	800bb1e <wolfSSL_ASN1_STRING_data>
 800e828:	6138      	str	r0, [r7, #16]
                if (data != NULL) {
 800e82a:	693b      	ldr	r3, [r7, #16]
 800e82c:	2b00      	cmp	r3, #0
 800e82e:	d014      	beq.n	800e85a <AddAllEntry+0x102>
                    sz = (int)XSTRLEN((const char*)data);
 800e830:	6938      	ldr	r0, [r7, #16]
 800e832:	f7f1 fcd7 	bl	80001e4 <strlen>
 800e836:	4603      	mov	r3, r0
 800e838:	617b      	str	r3, [r7, #20]
                    XMEMCPY(fullName + *idx, data, sz);
 800e83a:	683b      	ldr	r3, [r7, #0]
 800e83c:	681b      	ldr	r3, [r3, #0]
 800e83e:	461a      	mov	r2, r3
 800e840:	68bb      	ldr	r3, [r7, #8]
 800e842:	4413      	add	r3, r2
 800e844:	697a      	ldr	r2, [r7, #20]
 800e846:	6939      	ldr	r1, [r7, #16]
 800e848:	4618      	mov	r0, r3
 800e84a:	f019 feab 	bl	80285a4 <memcpy>
                    *idx += sz;
 800e84e:	683b      	ldr	r3, [r7, #0]
 800e850:	681a      	ldr	r2, [r3, #0]
 800e852:	697b      	ldr	r3, [r7, #20]
 800e854:	441a      	add	r2, r3
 800e856:	683b      	ldr	r3, [r7, #0]
 800e858:	601a      	str	r2, [r3, #0]
                }

                ret++;
 800e85a:	6a3b      	ldr	r3, [r7, #32]
 800e85c:	3301      	adds	r3, #1
 800e85e:	623b      	str	r3, [r7, #32]
        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e860:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e862:	3301      	adds	r3, #1
 800e864:	627b      	str	r3, [r7, #36]	@ 0x24
 800e866:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e868:	2b0f      	cmp	r3, #15
 800e86a:	dd81      	ble.n	800e770 <AddAllEntry+0x18>
            }
        }
        (void)fullNameSz;
        return ret;
 800e86c:	6a3b      	ldr	r3, [r7, #32]
    }
 800e86e:	4618      	mov	r0, r3
 800e870:	3728      	adds	r7, #40	@ 0x28
 800e872:	46bd      	mov	sp, r7
 800e874:	bd80      	pop	{r7, pc}
 800e876:	bf00      	nop
 800e878:	0802a104 	.word	0x0802a104
 800e87c:	0802ae30 	.word	0x0802ae30

0800e880 <RebuildFullName>:


    /* Converts a list of entries in WOLFSSL_X509_NAME struct into a string
     * returns 0 on success */
    static int RebuildFullName(WOLFSSL_X509_NAME* name)
    {
 800e880:	b580      	push	{r7, lr}
 800e882:	b08a      	sub	sp, #40	@ 0x28
 800e884:	af00      	add	r7, sp, #0
 800e886:	6078      	str	r0, [r7, #4]
        int totalLen = 0, i, idx, entryCount = 0;
 800e888:	2300      	movs	r3, #0
 800e88a:	627b      	str	r3, [r7, #36]	@ 0x24
 800e88c:	2300      	movs	r3, #0
 800e88e:	61fb      	str	r3, [r7, #28]

        if (name == NULL)
 800e890:	687b      	ldr	r3, [r7, #4]
 800e892:	2b00      	cmp	r3, #0
 800e894:	d102      	bne.n	800e89c <RebuildFullName+0x1c>
            return BAD_FUNC_ARG;
 800e896:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800e89a:	e086      	b.n	800e9aa <RebuildFullName+0x12a>

        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e89c:	2300      	movs	r3, #0
 800e89e:	623b      	str	r3, [r7, #32]
 800e8a0:	e036      	b.n	800e910 <RebuildFullName+0x90>
            if (name->entry[i].set) {
 800e8a2:	6879      	ldr	r1, [r7, #4]
 800e8a4:	6a3a      	ldr	r2, [r7, #32]
 800e8a6:	4613      	mov	r3, r2
 800e8a8:	009b      	lsls	r3, r3, #2
 800e8aa:	4413      	add	r3, r2
 800e8ac:	009b      	lsls	r3, r3, #2
 800e8ae:	440b      	add	r3, r1
 800e8b0:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800e8b4:	681b      	ldr	r3, [r3, #0]
 800e8b6:	2b00      	cmp	r3, #0
 800e8b8:	d027      	beq.n	800e90a <RebuildFullName+0x8a>
                WOLFSSL_X509_NAME_ENTRY* e;
                WOLFSSL_ASN1_OBJECT* obj;

                e = &name->entry[i];
 800e8ba:	6a3a      	ldr	r2, [r7, #32]
 800e8bc:	4613      	mov	r3, r2
 800e8be:	009b      	lsls	r3, r3, #2
 800e8c0:	4413      	add	r3, r2
 800e8c2:	009b      	lsls	r3, r3, #2
 800e8c4:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800e8c8:	687a      	ldr	r2, [r7, #4]
 800e8ca:	4413      	add	r3, r2
 800e8cc:	3304      	adds	r3, #4
 800e8ce:	617b      	str	r3, [r7, #20]
                obj = wolfSSL_X509_NAME_ENTRY_get_object(e);
 800e8d0:	6978      	ldr	r0, [r7, #20]
 800e8d2:	f7ff ff24 	bl	800e71e <wolfSSL_X509_NAME_ENTRY_get_object>
 800e8d6:	6138      	str	r0, [r7, #16]
                if (obj == NULL)
 800e8d8:	693b      	ldr	r3, [r7, #16]
 800e8da:	2b00      	cmp	r3, #0
 800e8dc:	d102      	bne.n	800e8e4 <RebuildFullName+0x64>
                    return BAD_FUNC_ARG;
 800e8de:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800e8e2:	e062      	b.n	800e9aa <RebuildFullName+0x12a>

                totalLen += (int)XSTRLEN(obj->sName) + 2;/*+2 for '/' and '=' */
 800e8e4:	693b      	ldr	r3, [r7, #16]
 800e8e6:	3308      	adds	r3, #8
 800e8e8:	4618      	mov	r0, r3
 800e8ea:	f7f1 fc7b 	bl	80001e4 <strlen>
 800e8ee:	4603      	mov	r3, r0
 800e8f0:	3302      	adds	r3, #2
 800e8f2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e8f4:	4413      	add	r3, r2
 800e8f6:	627b      	str	r3, [r7, #36]	@ 0x24
                totalLen += wolfSSL_ASN1_STRING_length(e->value);
 800e8f8:	697b      	ldr	r3, [r7, #20]
 800e8fa:	685b      	ldr	r3, [r3, #4]
 800e8fc:	4618      	mov	r0, r3
 800e8fe:	f7fd f921 	bl	800bb44 <wolfSSL_ASN1_STRING_length>
 800e902:	4602      	mov	r2, r0
 800e904:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e906:	4413      	add	r3, r2
 800e908:	627b      	str	r3, [r7, #36]	@ 0x24
        for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e90a:	6a3b      	ldr	r3, [r7, #32]
 800e90c:	3301      	adds	r3, #1
 800e90e:	623b      	str	r3, [r7, #32]
 800e910:	6a3b      	ldr	r3, [r7, #32]
 800e912:	2b0f      	cmp	r3, #15
 800e914:	ddc5      	ble.n	800e8a2 <RebuildFullName+0x22>
            }
        }

        if (name->dynamicName) {
 800e916:	687b      	ldr	r3, [r7, #4]
 800e918:	685b      	ldr	r3, [r3, #4]
 800e91a:	2b00      	cmp	r3, #0
 800e91c:	d010      	beq.n	800e940 <RebuildFullName+0xc0>
            XFREE(name->name, name->heap, DYNAMIC_TYPE_X509);
 800e91e:	687b      	ldr	r3, [r7, #4]
 800e920:	681b      	ldr	r3, [r3, #0]
 800e922:	61bb      	str	r3, [r7, #24]
 800e924:	69bb      	ldr	r3, [r7, #24]
 800e926:	2b00      	cmp	r3, #0
 800e928:	d002      	beq.n	800e930 <RebuildFullName+0xb0>
 800e92a:	69b8      	ldr	r0, [r7, #24]
 800e92c:	f010 f8ce 	bl	801eacc <wolfSSL_Free>
            name->name = name->staticName;
 800e930:	687b      	ldr	r3, [r7, #4]
 800e932:	f103 020c 	add.w	r2, r3, #12
 800e936:	687b      	ldr	r3, [r7, #4]
 800e938:	601a      	str	r2, [r3, #0]
            name->dynamicName = 0;
 800e93a:	687b      	ldr	r3, [r7, #4]
 800e93c:	2200      	movs	r2, #0
 800e93e:	605a      	str	r2, [r3, #4]
        }

        if (totalLen >= ASN_NAME_MAX) {
 800e940:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e942:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 800e946:	db11      	blt.n	800e96c <RebuildFullName+0xec>
            name->name = (char*)XMALLOC(totalLen + 1, name->heap,
 800e948:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e94a:	3301      	adds	r3, #1
 800e94c:	4618      	mov	r0, r3
 800e94e:	f010 f8a1 	bl	801ea94 <wolfSSL_Malloc>
 800e952:	4602      	mov	r2, r0
 800e954:	687b      	ldr	r3, [r7, #4]
 800e956:	601a      	str	r2, [r3, #0]
                    DYNAMIC_TYPE_X509);
            if (name->name == NULL)
 800e958:	687b      	ldr	r3, [r7, #4]
 800e95a:	681b      	ldr	r3, [r3, #0]
 800e95c:	2b00      	cmp	r3, #0
 800e95e:	d102      	bne.n	800e966 <RebuildFullName+0xe6>
                return MEMORY_E;
 800e960:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 800e964:	e021      	b.n	800e9aa <RebuildFullName+0x12a>
            name->dynamicName = 1;
 800e966:	687b      	ldr	r3, [r7, #4]
 800e968:	2201      	movs	r2, #1
 800e96a:	605a      	str	r2, [r3, #4]
        }

        idx = 0;
 800e96c:	2300      	movs	r3, #0
 800e96e:	60fb      	str	r3, [r7, #12]
        entryCount = AddAllEntry(name, name->name, totalLen, &idx);
 800e970:	687b      	ldr	r3, [r7, #4]
 800e972:	6819      	ldr	r1, [r3, #0]
 800e974:	f107 030c 	add.w	r3, r7, #12
 800e978:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e97a:	6878      	ldr	r0, [r7, #4]
 800e97c:	f7ff feec 	bl	800e758 <AddAllEntry>
 800e980:	61f8      	str	r0, [r7, #28]
        if (entryCount < 0)
 800e982:	69fb      	ldr	r3, [r7, #28]
 800e984:	2b00      	cmp	r3, #0
 800e986:	da01      	bge.n	800e98c <RebuildFullName+0x10c>
            return entryCount;
 800e988:	69fb      	ldr	r3, [r7, #28]
 800e98a:	e00e      	b.n	800e9aa <RebuildFullName+0x12a>

        name->name[idx] = '\0';
 800e98c:	687b      	ldr	r3, [r7, #4]
 800e98e:	681b      	ldr	r3, [r3, #0]
 800e990:	68fa      	ldr	r2, [r7, #12]
 800e992:	4413      	add	r3, r2
 800e994:	2200      	movs	r2, #0
 800e996:	701a      	strb	r2, [r3, #0]
        name->sz = idx + 1; /* size includes null terminator */
 800e998:	68fb      	ldr	r3, [r7, #12]
 800e99a:	1c5a      	adds	r2, r3, #1
 800e99c:	687b      	ldr	r3, [r7, #4]
 800e99e:	609a      	str	r2, [r3, #8]
        name->entrySz = entryCount;
 800e9a0:	687b      	ldr	r3, [r7, #4]
 800e9a2:	69fa      	ldr	r2, [r7, #28]
 800e9a4:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250

        return 0;
 800e9a8:	2300      	movs	r3, #0
    }
 800e9aa:	4618      	mov	r0, r3
 800e9ac:	3728      	adds	r7, #40	@ 0x28
 800e9ae:	46bd      	mov	sp, r7
 800e9b0:	bd80      	pop	{r7, pc}

0800e9b2 <wolfSSL_X509_NAME_add_entry>:
    /* Copies entry into name. With it being copied freeing entry becomes the
     * callers responsibility.
     * returns 1 for success and 0 for error */
    int wolfSSL_X509_NAME_add_entry(WOLFSSL_X509_NAME* name,
            WOLFSSL_X509_NAME_ENTRY* entry, int idx, int set)
    {
 800e9b2:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e9b4:	b08b      	sub	sp, #44	@ 0x2c
 800e9b6:	af02      	add	r7, sp, #8
 800e9b8:	60f8      	str	r0, [r7, #12]
 800e9ba:	60b9      	str	r1, [r7, #8]
 800e9bc:	607a      	str	r2, [r7, #4]
 800e9be:	603b      	str	r3, [r7, #0]
        WOLFSSL_X509_NAME_ENTRY* current = NULL;
 800e9c0:	2300      	movs	r3, #0
 800e9c2:	617b      	str	r3, [r7, #20]

#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_X509_NAME_add_entry");
#endif

        if (name == NULL || entry == NULL || entry->value == NULL) {
 800e9c4:	68fb      	ldr	r3, [r7, #12]
 800e9c6:	2b00      	cmp	r3, #0
 800e9c8:	d006      	beq.n	800e9d8 <wolfSSL_X509_NAME_add_entry+0x26>
 800e9ca:	68bb      	ldr	r3, [r7, #8]
 800e9cc:	2b00      	cmp	r3, #0
 800e9ce:	d003      	beq.n	800e9d8 <wolfSSL_X509_NAME_add_entry+0x26>
 800e9d0:	68bb      	ldr	r3, [r7, #8]
 800e9d2:	685b      	ldr	r3, [r3, #4]
 800e9d4:	2b00      	cmp	r3, #0
 800e9d6:	d101      	bne.n	800e9dc <wolfSSL_X509_NAME_add_entry+0x2a>
            WOLFSSL_MSG("NULL argument passed in");
            return WOLFSSL_FAILURE;
 800e9d8:	2300      	movs	r3, #0
 800e9da:	e079      	b.n	800ead0 <wolfSSL_X509_NAME_add_entry+0x11e>
        }

        if (idx >= 0) {
 800e9dc:	687b      	ldr	r3, [r7, #4]
 800e9de:	2b00      	cmp	r3, #0
 800e9e0:	db07      	blt.n	800e9f2 <wolfSSL_X509_NAME_add_entry+0x40>
            /* place in specific index */

            if (idx >= MAX_NAME_ENTRIES) {
 800e9e2:	687b      	ldr	r3, [r7, #4]
 800e9e4:	2b0f      	cmp	r3, #15
 800e9e6:	dd01      	ble.n	800e9ec <wolfSSL_X509_NAME_add_entry+0x3a>
                WOLFSSL_MSG("Error index to insert entry is larger than array");
                return WOLFSSL_FAILURE;
 800e9e8:	2300      	movs	r3, #0
 800e9ea:	e071      	b.n	800ead0 <wolfSSL_X509_NAME_add_entry+0x11e>
            }
            i = idx;
 800e9ec:	687b      	ldr	r3, [r7, #4]
 800e9ee:	61bb      	str	r3, [r7, #24]
 800e9f0:	e01b      	b.n	800ea2a <wolfSSL_X509_NAME_add_entry+0x78>
        }
        else {
            /* iterate through and find first open spot */
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800e9f2:	2300      	movs	r3, #0
 800e9f4:	61bb      	str	r3, [r7, #24]
 800e9f6:	e00e      	b.n	800ea16 <wolfSSL_X509_NAME_add_entry+0x64>
                if (name->entry[i].set != 1) { /* not set so overwritten */
 800e9f8:	68f9      	ldr	r1, [r7, #12]
 800e9fa:	69ba      	ldr	r2, [r7, #24]
 800e9fc:	4613      	mov	r3, r2
 800e9fe:	009b      	lsls	r3, r3, #2
 800ea00:	4413      	add	r3, r2
 800ea02:	009b      	lsls	r3, r3, #2
 800ea04:	440b      	add	r3, r1
 800ea06:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800ea0a:	681b      	ldr	r3, [r3, #0]
 800ea0c:	2b01      	cmp	r3, #1
 800ea0e:	d106      	bne.n	800ea1e <wolfSSL_X509_NAME_add_entry+0x6c>
            for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800ea10:	69bb      	ldr	r3, [r7, #24]
 800ea12:	3301      	adds	r3, #1
 800ea14:	61bb      	str	r3, [r7, #24]
 800ea16:	69bb      	ldr	r3, [r7, #24]
 800ea18:	2b0f      	cmp	r3, #15
 800ea1a:	dded      	ble.n	800e9f8 <wolfSSL_X509_NAME_add_entry+0x46>
 800ea1c:	e000      	b.n	800ea20 <wolfSSL_X509_NAME_add_entry+0x6e>
                    WOLFSSL_MSG("Found place for name entry");
                    break;
 800ea1e:	bf00      	nop
                }
            }

            if (i == MAX_NAME_ENTRIES) {
 800ea20:	69bb      	ldr	r3, [r7, #24]
 800ea22:	2b10      	cmp	r3, #16
 800ea24:	d101      	bne.n	800ea2a <wolfSSL_X509_NAME_add_entry+0x78>
                WOLFSSL_MSG("No spot found for name entry");
                return WOLFSSL_FAILURE;
 800ea26:	2300      	movs	r3, #0
 800ea28:	e052      	b.n	800ead0 <wolfSSL_X509_NAME_add_entry+0x11e>
            }
        }

        current = &name->entry[i];
 800ea2a:	69ba      	ldr	r2, [r7, #24]
 800ea2c:	4613      	mov	r3, r2
 800ea2e:	009b      	lsls	r3, r3, #2
 800ea30:	4413      	add	r3, r2
 800ea32:	009b      	lsls	r3, r3, #2
 800ea34:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800ea38:	68fa      	ldr	r2, [r7, #12]
 800ea3a:	4413      	add	r3, r2
 800ea3c:	3304      	adds	r3, #4
 800ea3e:	617b      	str	r3, [r7, #20]
        if (current->set == 0)
 800ea40:	697b      	ldr	r3, [r7, #20]
 800ea42:	68db      	ldr	r3, [r3, #12]
 800ea44:	2b00      	cmp	r3, #0
 800ea46:	d106      	bne.n	800ea56 <wolfSSL_X509_NAME_add_entry+0xa4>
            name->entrySz++;
 800ea48:	68fb      	ldr	r3, [r7, #12]
 800ea4a:	f8d3 3250 	ldr.w	r3, [r3, #592]	@ 0x250
 800ea4e:	1c5a      	adds	r2, r3, #1
 800ea50:	68fb      	ldr	r3, [r7, #12]
 800ea52:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250

        if (wolfSSL_X509_NAME_ENTRY_create_by_NID(&current,
 800ea56:	68bb      	ldr	r3, [r7, #8]
 800ea58:	689c      	ldr	r4, [r3, #8]
                            entry->nid,
                            wolfSSL_ASN1_STRING_type(entry->value),
 800ea5a:	68bb      	ldr	r3, [r7, #8]
 800ea5c:	685b      	ldr	r3, [r3, #4]
        if (wolfSSL_X509_NAME_ENTRY_create_by_NID(&current,
 800ea5e:	4618      	mov	r0, r3
 800ea60:	f7fd f84a 	bl	800baf8 <wolfSSL_ASN1_STRING_type>
 800ea64:	4605      	mov	r5, r0
                            wolfSSL_ASN1_STRING_data(entry->value),
 800ea66:	68bb      	ldr	r3, [r7, #8]
 800ea68:	685b      	ldr	r3, [r3, #4]
 800ea6a:	4618      	mov	r0, r3
 800ea6c:	f7fd f857 	bl	800bb1e <wolfSSL_ASN1_STRING_data>
 800ea70:	4606      	mov	r6, r0
                            wolfSSL_ASN1_STRING_length(entry->value)) != NULL)
 800ea72:	68bb      	ldr	r3, [r7, #8]
 800ea74:	685b      	ldr	r3, [r3, #4]
        if (wolfSSL_X509_NAME_ENTRY_create_by_NID(&current,
 800ea76:	4618      	mov	r0, r3
 800ea78:	f7fd f864 	bl	800bb44 <wolfSSL_ASN1_STRING_length>
 800ea7c:	4603      	mov	r3, r0
 800ea7e:	f107 0014 	add.w	r0, r7, #20
 800ea82:	9300      	str	r3, [sp, #0]
 800ea84:	4633      	mov	r3, r6
 800ea86:	462a      	mov	r2, r5
 800ea88:	4621      	mov	r1, r4
 800ea8a:	f7ff fe16 	bl	800e6ba <wolfSSL_X509_NAME_ENTRY_create_by_NID>
 800ea8e:	4603      	mov	r3, r0
 800ea90:	2b00      	cmp	r3, #0
 800ea92:	d002      	beq.n	800ea9a <wolfSSL_X509_NAME_add_entry+0xe8>
        {
            ret = WOLFSSL_SUCCESS;
 800ea94:	2301      	movs	r3, #1
 800ea96:	61fb      	str	r3, [r7, #28]
 800ea98:	e001      	b.n	800ea9e <wolfSSL_X509_NAME_add_entry+0xec>
                ret = WOLFSSL_FAILURE;
            }
        #endif
        }
        else {
            ret = WOLFSSL_FAILURE;
 800ea9a:	2300      	movs	r3, #0
 800ea9c:	61fb      	str	r3, [r7, #28]
        }

        if (ret != WOLFSSL_SUCCESS) {
 800ea9e:	69fb      	ldr	r3, [r7, #28]
 800eaa0:	2b01      	cmp	r3, #1
 800eaa2:	d00c      	beq.n	800eabe <wolfSSL_X509_NAME_add_entry+0x10c>
            WOLFSSL_MSG("Error adding the name entry");
            if (current->set == 0)
 800eaa4:	697b      	ldr	r3, [r7, #20]
 800eaa6:	68db      	ldr	r3, [r3, #12]
 800eaa8:	2b00      	cmp	r3, #0
 800eaaa:	d106      	bne.n	800eaba <wolfSSL_X509_NAME_add_entry+0x108>
                name->entrySz--;
 800eaac:	68fb      	ldr	r3, [r7, #12]
 800eaae:	f8d3 3250 	ldr.w	r3, [r3, #592]	@ 0x250
 800eab2:	1e5a      	subs	r2, r3, #1
 800eab4:	68fb      	ldr	r3, [r7, #12]
 800eab6:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
            return WOLFSSL_FAILURE;
 800eaba:	2300      	movs	r3, #0
 800eabc:	e008      	b.n	800ead0 <wolfSSL_X509_NAME_add_entry+0x11e>
        }

        if (RebuildFullName(name) != 0)
 800eabe:	68f8      	ldr	r0, [r7, #12]
 800eac0:	f7ff fede 	bl	800e880 <RebuildFullName>
 800eac4:	4603      	mov	r3, r0
 800eac6:	2b00      	cmp	r3, #0
 800eac8:	d001      	beq.n	800eace <wolfSSL_X509_NAME_add_entry+0x11c>
            return WOLFSSL_FAILURE;
 800eaca:	2300      	movs	r3, #0
 800eacc:	e000      	b.n	800ead0 <wolfSSL_X509_NAME_add_entry+0x11e>

        (void)set;
        return WOLFSSL_SUCCESS;
 800eace:	2301      	movs	r3, #1
    }
 800ead0:	4618      	mov	r0, r3
 800ead2:	3724      	adds	r7, #36	@ 0x24
 800ead4:	46bd      	mov	sp, r7
 800ead6:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800ead8 <wolfSSL_X509_NAME_add_entry_by_NID>:
    }

    int wolfSSL_X509_NAME_add_entry_by_NID(WOLFSSL_X509_NAME *name, int nid,
                                           int type, const unsigned char *bytes,
                                           int len, int loc, int set)
    {
 800ead8:	b580      	push	{r7, lr}
 800eada:	b088      	sub	sp, #32
 800eadc:	af02      	add	r7, sp, #8
 800eade:	60f8      	str	r0, [r7, #12]
 800eae0:	60b9      	str	r1, [r7, #8]
 800eae2:	607a      	str	r2, [r7, #4]
 800eae4:	603b      	str	r3, [r7, #0]
        int ret;
        WOLFSSL_X509_NAME_ENTRY* entry;
        WOLFSSL_ENTER("wolfSSL_X509_NAME_add_entry_by_NID");
        entry = wolfSSL_X509_NAME_ENTRY_create_by_NID(NULL, nid, type, bytes,
 800eae6:	6a3b      	ldr	r3, [r7, #32]
 800eae8:	9300      	str	r3, [sp, #0]
 800eaea:	683b      	ldr	r3, [r7, #0]
 800eaec:	687a      	ldr	r2, [r7, #4]
 800eaee:	68b9      	ldr	r1, [r7, #8]
 800eaf0:	2000      	movs	r0, #0
 800eaf2:	f7ff fde2 	bl	800e6ba <wolfSSL_X509_NAME_ENTRY_create_by_NID>
 800eaf6:	6178      	str	r0, [r7, #20]
                len);
        if (entry == NULL)
 800eaf8:	697b      	ldr	r3, [r7, #20]
 800eafa:	2b00      	cmp	r3, #0
 800eafc:	d101      	bne.n	800eb02 <wolfSSL_X509_NAME_add_entry_by_NID+0x2a>
            return WOLFSSL_FAILURE;
 800eafe:	2300      	movs	r3, #0
 800eb00:	e00a      	b.n	800eb18 <wolfSSL_X509_NAME_add_entry_by_NID+0x40>
        ret = wolfSSL_X509_NAME_add_entry(name, entry, loc, set);
 800eb02:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800eb04:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800eb06:	6979      	ldr	r1, [r7, #20]
 800eb08:	68f8      	ldr	r0, [r7, #12]
 800eb0a:	f7ff ff52 	bl	800e9b2 <wolfSSL_X509_NAME_add_entry>
 800eb0e:	6138      	str	r0, [r7, #16]
        wolfSSL_X509_NAME_ENTRY_free(entry);
 800eb10:	6978      	ldr	r0, [r7, #20]
 800eb12:	f7ff fd62 	bl	800e5da <wolfSSL_X509_NAME_ENTRY_free>
        return ret;
 800eb16:	693b      	ldr	r3, [r7, #16]
    }
 800eb18:	4618      	mov	r0, r3
 800eb1a:	3718      	adds	r7, #24
 800eb1c:	46bd      	mov	sp, r7
 800eb1e:	bd80      	pop	{r7, pc}

0800eb20 <wolfSSL_X509_NAME_get_entry>:

    /* returns a pointer to the internal entry at location 'loc' on success,
     * a null pointer is returned in fail cases */
    WOLFSSL_X509_NAME_ENTRY *wolfSSL_X509_NAME_get_entry(
                                             WOLFSSL_X509_NAME *name, int loc)
    {
 800eb20:	b480      	push	{r7}
 800eb22:	b083      	sub	sp, #12
 800eb24:	af00      	add	r7, sp, #0
 800eb26:	6078      	str	r0, [r7, #4]
 800eb28:	6039      	str	r1, [r7, #0]
#ifdef WOLFSSL_DEBUG_OPENSSL
        WOLFSSL_ENTER("wolfSSL_X509_NAME_get_entry");
#endif

        if (name == NULL) {
 800eb2a:	687b      	ldr	r3, [r7, #4]
 800eb2c:	2b00      	cmp	r3, #0
 800eb2e:	d101      	bne.n	800eb34 <wolfSSL_X509_NAME_get_entry+0x14>
            return NULL;
 800eb30:	2300      	movs	r3, #0
 800eb32:	e01f      	b.n	800eb74 <wolfSSL_X509_NAME_get_entry+0x54>
        }

        if (loc < 0 || loc >= MAX_NAME_ENTRIES) {
 800eb34:	683b      	ldr	r3, [r7, #0]
 800eb36:	2b00      	cmp	r3, #0
 800eb38:	db02      	blt.n	800eb40 <wolfSSL_X509_NAME_get_entry+0x20>
 800eb3a:	683b      	ldr	r3, [r7, #0]
 800eb3c:	2b0f      	cmp	r3, #15
 800eb3e:	dd01      	ble.n	800eb44 <wolfSSL_X509_NAME_get_entry+0x24>
            WOLFSSL_MSG("Bad argument");
            return NULL;
 800eb40:	2300      	movs	r3, #0
 800eb42:	e017      	b.n	800eb74 <wolfSSL_X509_NAME_get_entry+0x54>
        }

        if (name->entry[loc].set) {
 800eb44:	6879      	ldr	r1, [r7, #4]
 800eb46:	683a      	ldr	r2, [r7, #0]
 800eb48:	4613      	mov	r3, r2
 800eb4a:	009b      	lsls	r3, r3, #2
 800eb4c:	4413      	add	r3, r2
 800eb4e:	009b      	lsls	r3, r3, #2
 800eb50:	440b      	add	r3, r1
 800eb52:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800eb56:	681b      	ldr	r3, [r3, #0]
 800eb58:	2b00      	cmp	r3, #0
 800eb5a:	d00a      	beq.n	800eb72 <wolfSSL_X509_NAME_get_entry+0x52>
            *  updating "set" by position + 1. "plus 1" means to avoid "not set"
            *  zero.
            */
            name->entry[loc].set = loc + 1;
#endif
            return &name->entry[loc];
 800eb5c:	683a      	ldr	r2, [r7, #0]
 800eb5e:	4613      	mov	r3, r2
 800eb60:	009b      	lsls	r3, r3, #2
 800eb62:	4413      	add	r3, r2
 800eb64:	009b      	lsls	r3, r3, #2
 800eb66:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800eb6a:	687a      	ldr	r2, [r7, #4]
 800eb6c:	4413      	add	r3, r2
 800eb6e:	3304      	adds	r3, #4
 800eb70:	e000      	b.n	800eb74 <wolfSSL_X509_NAME_get_entry+0x54>
        }
        else {
            return NULL;
 800eb72:	2300      	movs	r3, #0
        }
    }
 800eb74:	4618      	mov	r0, r3
 800eb76:	370c      	adds	r7, #12
 800eb78:	46bd      	mov	sp, r7
 800eb7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb7e:	4770      	bx	lr

0800eb80 <wolfSSL_sk_X509_NAME_pop_free>:
    return name;
}

void wolfSSL_sk_X509_NAME_pop_free(WOLF_STACK_OF(WOLFSSL_X509_NAME)* sk,
    void (*f) (WOLFSSL_X509_NAME*))
{
 800eb80:	b580      	push	{r7, lr}
 800eb82:	b082      	sub	sp, #8
 800eb84:	af00      	add	r7, sp, #0
 800eb86:	6078      	str	r0, [r7, #4]
 800eb88:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_sk_X509_NAME_pop_free");
    wolfSSL_sk_pop_free(sk, (wolfSSL_sk_freefunc)f);
 800eb8a:	6839      	ldr	r1, [r7, #0]
 800eb8c:	6878      	ldr	r0, [r7, #4]
 800eb8e:	f7ff f8cf 	bl	800dd30 <wolfSSL_sk_pop_free>
}
 800eb92:	bf00      	nop
 800eb94:	3708      	adds	r7, #8
 800eb96:	46bd      	mov	sp, r7
 800eb98:	bd80      	pop	{r7, pc}

0800eb9a <wolfSSL_sk_X509_new_null>:
    (void)cb;
    return wolfSSL_sk_X509_new_null();
}

WOLFSSL_STACK* wolfSSL_sk_X509_new_null(void)
{
 800eb9a:	b580      	push	{r7, lr}
 800eb9c:	b082      	sub	sp, #8
 800eb9e:	af00      	add	r7, sp, #0
    WOLFSSL_STACK* s = (WOLFSSL_STACK*)XMALLOC(sizeof(WOLFSSL_STACK), NULL,
 800eba0:	2018      	movs	r0, #24
 800eba2:	f00f ff77 	bl	801ea94 <wolfSSL_Malloc>
 800eba6:	6078      	str	r0, [r7, #4]
            DYNAMIC_TYPE_OPENSSL);
    if (s != NULL) {
 800eba8:	687b      	ldr	r3, [r7, #4]
 800ebaa:	2b00      	cmp	r3, #0
 800ebac:	d007      	beq.n	800ebbe <wolfSSL_sk_X509_new_null+0x24>
        XMEMSET(s, 0, sizeof(*s));
 800ebae:	2218      	movs	r2, #24
 800ebb0:	2100      	movs	r1, #0
 800ebb2:	6878      	ldr	r0, [r7, #4]
 800ebb4:	f019 fc8c 	bl	80284d0 <memset>
        s->type = STACK_TYPE_X509;
 800ebb8:	687b      	ldr	r3, [r7, #4]
 800ebba:	2200      	movs	r2, #0
 800ebbc:	751a      	strb	r2, [r3, #20]
    }

    return s;
 800ebbe:	687b      	ldr	r3, [r7, #4]
}
 800ebc0:	4618      	mov	r0, r3
 800ebc2:	3708      	adds	r7, #8
 800ebc4:	46bd      	mov	sp, r7
 800ebc6:	bd80      	pop	{r7, pc}

0800ebc8 <wolfSSL_X509_NAME_copy>:
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
/* unlike wolfSSL_X509_NAME_dup this does not malloc a duplicate, only deep
 * copy. "to" is expected to be a fresh blank name, if not pointers could be
 * lost */
int wolfSSL_X509_NAME_copy(WOLFSSL_X509_NAME* from, WOLFSSL_X509_NAME* to)
{
 800ebc8:	b580      	push	{r7, lr}
 800ebca:	b084      	sub	sp, #16
 800ebcc:	af00      	add	r7, sp, #0
 800ebce:	6078      	str	r0, [r7, #4]
 800ebd0:	6039      	str	r1, [r7, #0]
    int i;

    WOLFSSL_ENTER("wolfSSL_X509_NAME_copy");

    if (from == NULL || to == NULL) {
 800ebd2:	687b      	ldr	r3, [r7, #4]
 800ebd4:	2b00      	cmp	r3, #0
 800ebd6:	d002      	beq.n	800ebde <wolfSSL_X509_NAME_copy+0x16>
 800ebd8:	683b      	ldr	r3, [r7, #0]
 800ebda:	2b00      	cmp	r3, #0
 800ebdc:	d102      	bne.n	800ebe4 <wolfSSL_X509_NAME_copy+0x1c>
        WOLFSSL_MSG("NULL parameter");
        return BAD_FUNC_ARG;
 800ebde:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 800ebe2:	e044      	b.n	800ec6e <wolfSSL_X509_NAME_copy+0xa6>
        XMEMCPY(to->raw, from->raw, from->rawLen);
        to->rawLen = from->rawLen;
    }
#endif

    if (from->dynamicName) {
 800ebe4:	687b      	ldr	r3, [r7, #4]
 800ebe6:	685b      	ldr	r3, [r3, #4]
 800ebe8:	2b00      	cmp	r3, #0
 800ebea:	d010      	beq.n	800ec0e <wolfSSL_X509_NAME_copy+0x46>
        to->name = (char*)XMALLOC(from->sz, to->heap, DYNAMIC_TYPE_SUBJECT_CN);
 800ebec:	687b      	ldr	r3, [r7, #4]
 800ebee:	689b      	ldr	r3, [r3, #8]
 800ebf0:	4618      	mov	r0, r3
 800ebf2:	f00f ff4f 	bl	801ea94 <wolfSSL_Malloc>
 800ebf6:	4602      	mov	r2, r0
 800ebf8:	683b      	ldr	r3, [r7, #0]
 800ebfa:	601a      	str	r2, [r3, #0]
        if (to->name == NULL)
 800ebfc:	683b      	ldr	r3, [r7, #0]
 800ebfe:	681b      	ldr	r3, [r3, #0]
 800ec00:	2b00      	cmp	r3, #0
 800ec02:	d101      	bne.n	800ec08 <wolfSSL_X509_NAME_copy+0x40>
            return WOLFSSL_FAILURE;
 800ec04:	2300      	movs	r3, #0
 800ec06:	e032      	b.n	800ec6e <wolfSSL_X509_NAME_copy+0xa6>
        to->dynamicName = 1;
 800ec08:	683b      	ldr	r3, [r7, #0]
 800ec0a:	2201      	movs	r2, #1
 800ec0c:	605a      	str	r2, [r3, #4]
    }
    XMEMCPY(to->name, from->name, from->sz);
 800ec0e:	683b      	ldr	r3, [r7, #0]
 800ec10:	6818      	ldr	r0, [r3, #0]
 800ec12:	687b      	ldr	r3, [r7, #4]
 800ec14:	6819      	ldr	r1, [r3, #0]
 800ec16:	687b      	ldr	r3, [r7, #4]
 800ec18:	689b      	ldr	r3, [r3, #8]
 800ec1a:	461a      	mov	r2, r3
 800ec1c:	f019 fcc2 	bl	80285a4 <memcpy>
    to->sz = from->sz;
 800ec20:	687b      	ldr	r3, [r7, #4]
 800ec22:	689a      	ldr	r2, [r3, #8]
 800ec24:	683b      	ldr	r3, [r7, #0]
 800ec26:	609a      	str	r2, [r3, #8]

    for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800ec28:	2300      	movs	r3, #0
 800ec2a:	60fb      	str	r3, [r7, #12]
 800ec2c:	e015      	b.n	800ec5a <wolfSSL_X509_NAME_copy+0x92>
        WOLFSSL_X509_NAME_ENTRY* ne = wolfSSL_X509_NAME_get_entry(from, i);
 800ec2e:	68f9      	ldr	r1, [r7, #12]
 800ec30:	6878      	ldr	r0, [r7, #4]
 800ec32:	f7ff ff75 	bl	800eb20 <wolfSSL_X509_NAME_get_entry>
 800ec36:	60b8      	str	r0, [r7, #8]
        if (ne != NULL) {
 800ec38:	68bb      	ldr	r3, [r7, #8]
 800ec3a:	2b00      	cmp	r3, #0
 800ec3c:	d00a      	beq.n	800ec54 <wolfSSL_X509_NAME_copy+0x8c>
            if (wolfSSL_X509_NAME_add_entry(to, ne, i, 1) != WOLFSSL_SUCCESS) {
 800ec3e:	2301      	movs	r3, #1
 800ec40:	68fa      	ldr	r2, [r7, #12]
 800ec42:	68b9      	ldr	r1, [r7, #8]
 800ec44:	6838      	ldr	r0, [r7, #0]
 800ec46:	f7ff feb4 	bl	800e9b2 <wolfSSL_X509_NAME_add_entry>
 800ec4a:	4603      	mov	r3, r0
 800ec4c:	2b01      	cmp	r3, #1
 800ec4e:	d001      	beq.n	800ec54 <wolfSSL_X509_NAME_copy+0x8c>
                return WOLFSSL_FAILURE;
 800ec50:	2300      	movs	r3, #0
 800ec52:	e00c      	b.n	800ec6e <wolfSSL_X509_NAME_copy+0xa6>
    for (i = 0; i < MAX_NAME_ENTRIES; i++) {
 800ec54:	68fb      	ldr	r3, [r7, #12]
 800ec56:	3301      	adds	r3, #1
 800ec58:	60fb      	str	r3, [r7, #12]
 800ec5a:	68fb      	ldr	r3, [r7, #12]
 800ec5c:	2b0f      	cmp	r3, #15
 800ec5e:	dde6      	ble.n	800ec2e <wolfSSL_X509_NAME_copy+0x66>
            }
        }
    }
    to->entrySz = from->entrySz;
 800ec60:	687b      	ldr	r3, [r7, #4]
 800ec62:	f8d3 2250 	ldr.w	r2, [r3, #592]	@ 0x250
 800ec66:	683b      	ldr	r3, [r7, #0]
 800ec68:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
    return WOLFSSL_SUCCESS;
 800ec6c:	2301      	movs	r3, #1
}
 800ec6e:	4618      	mov	r0, r3
 800ec70:	3710      	adds	r7, #16
 800ec72:	46bd      	mov	sp, r7
 800ec74:	bd80      	pop	{r7, pc}

0800ec76 <wolfSSL_X509_set_subject_name>:


/* copies over information from "name" to the "cert" subject name
 * returns WOLFSSL_SUCCESS on success */
int wolfSSL_X509_set_subject_name(WOLFSSL_X509 *cert, WOLFSSL_X509_NAME *name)
{
 800ec76:	b580      	push	{r7, lr}
 800ec78:	b082      	sub	sp, #8
 800ec7a:	af00      	add	r7, sp, #0
 800ec7c:	6078      	str	r0, [r7, #4]
 800ec7e:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_X509_set_subject_name");
    if (cert == NULL || name == NULL)
 800ec80:	687b      	ldr	r3, [r7, #4]
 800ec82:	2b00      	cmp	r3, #0
 800ec84:	d002      	beq.n	800ec8c <wolfSSL_X509_set_subject_name+0x16>
 800ec86:	683b      	ldr	r3, [r7, #0]
 800ec88:	2b00      	cmp	r3, #0
 800ec8a:	d101      	bne.n	800ec90 <wolfSSL_X509_set_subject_name+0x1a>
        return WOLFSSL_FAILURE;
 800ec8c:	2300      	movs	r3, #0
 800ec8e:	e026      	b.n	800ecde <wolfSSL_X509_set_subject_name+0x68>

    FreeX509Name(&cert->subject);
 800ec90:	687b      	ldr	r3, [r7, #4]
 800ec92:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800ec96:	4618      	mov	r0, r3
 800ec98:	f7fa fbed 	bl	8009476 <FreeX509Name>
    InitX509Name(&cert->subject, 0, cert->heap);
 800ec9c:	687b      	ldr	r3, [r7, #4]
 800ec9e:	f503 60f1 	add.w	r0, r3, #1928	@ 0x788
 800eca2:	687b      	ldr	r3, [r7, #4]
 800eca4:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800eca8:	461a      	mov	r2, r3
 800ecaa:	2100      	movs	r1, #0
 800ecac:	f7fa fbc4 	bl	8009438 <InitX509Name>

    if (wolfSSL_X509_NAME_copy(name, &cert->subject) != WOLFSSL_SUCCESS) {
 800ecb0:	687b      	ldr	r3, [r7, #4]
 800ecb2:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800ecb6:	4619      	mov	r1, r3
 800ecb8:	6838      	ldr	r0, [r7, #0]
 800ecba:	f7ff ff85 	bl	800ebc8 <wolfSSL_X509_NAME_copy>
 800ecbe:	4603      	mov	r3, r0
 800ecc0:	2b01      	cmp	r3, #1
 800ecc2:	d007      	beq.n	800ecd4 <wolfSSL_X509_set_subject_name+0x5e>
        FreeX509Name(&cert->subject);
 800ecc4:	687b      	ldr	r3, [r7, #4]
 800ecc6:	f503 63f1 	add.w	r3, r3, #1928	@ 0x788
 800ecca:	4618      	mov	r0, r3
 800eccc:	f7fa fbd3 	bl	8009476 <FreeX509Name>
        return WOLFSSL_FAILURE;
 800ecd0:	2300      	movs	r3, #0
 800ecd2:	e004      	b.n	800ecde <wolfSSL_X509_set_subject_name+0x68>
    }

    cert->subject.x509 = cert;
 800ecd4:	687b      	ldr	r3, [r7, #4]
 800ecd6:	687a      	ldr	r2, [r7, #4]
 800ecd8:	f8c3 2b1c 	str.w	r2, [r3, #2844]	@ 0xb1c
    return WOLFSSL_SUCCESS;
 800ecdc:	2301      	movs	r3, #1
}
 800ecde:	4618      	mov	r0, r3
 800ece0:	3708      	adds	r7, #8
 800ece2:	46bd      	mov	sp, r7
 800ece4:	bd80      	pop	{r7, pc}

0800ece6 <wolfSSL_X509_set_issuer_name>:


/* copies over information from "name" to the "cert" issuer name
 * returns WOLFSSL_SUCCESS on success */
int wolfSSL_X509_set_issuer_name(WOLFSSL_X509 *cert, WOLFSSL_X509_NAME *name)
{
 800ece6:	b580      	push	{r7, lr}
 800ece8:	b082      	sub	sp, #8
 800ecea:	af00      	add	r7, sp, #0
 800ecec:	6078      	str	r0, [r7, #4]
 800ecee:	6039      	str	r1, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_X509_set_issuer_name");
    if (cert == NULL || name == NULL)
 800ecf0:	687b      	ldr	r3, [r7, #4]
 800ecf2:	2b00      	cmp	r3, #0
 800ecf4:	d002      	beq.n	800ecfc <wolfSSL_X509_set_issuer_name+0x16>
 800ecf6:	683b      	ldr	r3, [r7, #0]
 800ecf8:	2b00      	cmp	r3, #0
 800ecfa:	d101      	bne.n	800ed00 <wolfSSL_X509_set_issuer_name+0x1a>
        return WOLFSSL_FAILURE;
 800ecfc:	2300      	movs	r3, #0
 800ecfe:	e02d      	b.n	800ed5c <wolfSSL_X509_set_issuer_name+0x76>

    FreeX509Name(&cert->issuer);
 800ed00:	687b      	ldr	r3, [r7, #4]
 800ed02:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800ed06:	4618      	mov	r0, r3
 800ed08:	f7fa fbb5 	bl	8009476 <FreeX509Name>
    InitX509Name(&cert->issuer, 0, cert->heap);
 800ed0c:	687b      	ldr	r3, [r7, #4]
 800ed0e:	f503 701f 	add.w	r0, r3, #636	@ 0x27c
 800ed12:	687b      	ldr	r3, [r7, #4]
 800ed14:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800ed18:	461a      	mov	r2, r3
 800ed1a:	2100      	movs	r1, #0
 800ed1c:	f7fa fb8c 	bl	8009438 <InitX509Name>

    if (wolfSSL_X509_NAME_copy(name, &cert->issuer) != WOLFSSL_SUCCESS) {
 800ed20:	687b      	ldr	r3, [r7, #4]
 800ed22:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800ed26:	4619      	mov	r1, r3
 800ed28:	6838      	ldr	r0, [r7, #0]
 800ed2a:	f7ff ff4d 	bl	800ebc8 <wolfSSL_X509_NAME_copy>
 800ed2e:	4603      	mov	r3, r0
 800ed30:	2b01      	cmp	r3, #1
 800ed32:	d007      	beq.n	800ed44 <wolfSSL_X509_set_issuer_name+0x5e>
        FreeX509Name(&cert->issuer);
 800ed34:	687b      	ldr	r3, [r7, #4]
 800ed36:	f503 731f 	add.w	r3, r3, #636	@ 0x27c
 800ed3a:	4618      	mov	r0, r3
 800ed3c:	f7fa fb9b 	bl	8009476 <FreeX509Name>
        return WOLFSSL_FAILURE;
 800ed40:	2300      	movs	r3, #0
 800ed42:	e00b      	b.n	800ed5c <wolfSSL_X509_set_issuer_name+0x76>
    }

    cert->issuer.x509 = cert;
 800ed44:	687b      	ldr	r3, [r7, #4]
 800ed46:	687a      	ldr	r2, [r7, #4]
 800ed48:	f8c3 2610 	str.w	r2, [r3, #1552]	@ 0x610
    cert->issuerSet = 1;
 800ed4c:	687a      	ldr	r2, [r7, #4]
 800ed4e:	f892 30f3 	ldrb.w	r3, [r2, #243]	@ 0xf3
 800ed52:	f043 0301 	orr.w	r3, r3, #1
 800ed56:	f882 30f3 	strb.w	r3, [r2, #243]	@ 0xf3

    return WOLFSSL_SUCCESS;
 800ed5a:	2301      	movs	r3, #1
}
 800ed5c:	4618      	mov	r0, r3
 800ed5e:	3708      	adds	r7, #8
 800ed60:	46bd      	mov	sp, r7
 800ed62:	bd80      	pop	{r7, pc}

0800ed64 <wolfSSL_BUF_MEM_free>:

    return (int)len;
}

void wolfSSL_BUF_MEM_free(WOLFSSL_BUF_MEM* buf)
{
 800ed64:	b580      	push	{r7, lr}
 800ed66:	b084      	sub	sp, #16
 800ed68:	af00      	add	r7, sp, #0
 800ed6a:	6078      	str	r0, [r7, #4]
    if (buf) {
 800ed6c:	687b      	ldr	r3, [r7, #4]
 800ed6e:	2b00      	cmp	r3, #0
 800ed70:	d019      	beq.n	800eda6 <wolfSSL_BUF_MEM_free+0x42>
        XFREE(buf->data, NULL, DYNAMIC_TYPE_OPENSSL);
 800ed72:	687b      	ldr	r3, [r7, #4]
 800ed74:	681b      	ldr	r3, [r3, #0]
 800ed76:	60fb      	str	r3, [r7, #12]
 800ed78:	68fb      	ldr	r3, [r7, #12]
 800ed7a:	2b00      	cmp	r3, #0
 800ed7c:	d002      	beq.n	800ed84 <wolfSSL_BUF_MEM_free+0x20>
 800ed7e:	68f8      	ldr	r0, [r7, #12]
 800ed80:	f00f fea4 	bl	801eacc <wolfSSL_Free>
        buf->data = NULL;
 800ed84:	687b      	ldr	r3, [r7, #4]
 800ed86:	2200      	movs	r2, #0
 800ed88:	601a      	str	r2, [r3, #0]
        buf->max = 0;
 800ed8a:	687b      	ldr	r3, [r7, #4]
 800ed8c:	2200      	movs	r2, #0
 800ed8e:	609a      	str	r2, [r3, #8]
        buf->length = 0;
 800ed90:	687b      	ldr	r3, [r7, #4]
 800ed92:	2200      	movs	r2, #0
 800ed94:	605a      	str	r2, [r3, #4]
        XFREE(buf, NULL, DYNAMIC_TYPE_OPENSSL);
 800ed96:	687b      	ldr	r3, [r7, #4]
 800ed98:	60bb      	str	r3, [r7, #8]
 800ed9a:	68bb      	ldr	r3, [r7, #8]
 800ed9c:	2b00      	cmp	r3, #0
 800ed9e:	d002      	beq.n	800eda6 <wolfSSL_BUF_MEM_free+0x42>
 800eda0:	68b8      	ldr	r0, [r7, #8]
 800eda2:	f00f fe93 	bl	801eacc <wolfSSL_Free>
    }
}
 800eda6:	bf00      	nop
 800eda8:	3710      	adds	r7, #16
 800edaa:	46bd      	mov	sp, r7
 800edac:	bd80      	pop	{r7, pc}
	...

0800edb0 <wolfSSL_RAND_InitMutex>:
 * START OF RAND API
 ******************************************************************************/

#if defined(OPENSSL_EXTRA) && !defined(WOLFSSL_NO_OPENSSL_RAND_CB)
static int wolfSSL_RAND_InitMutex(void)
{
 800edb0:	b580      	push	{r7, lr}
 800edb2:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (gRandMethodsInit == 0) {
 800edb4:	4b09      	ldr	r3, [pc, #36]	@ (800eddc <wolfSSL_RAND_InitMutex+0x2c>)
 800edb6:	681b      	ldr	r3, [r3, #0]
 800edb8:	2b00      	cmp	r3, #0
 800edba:	d10b      	bne.n	800edd4 <wolfSSL_RAND_InitMutex+0x24>
        if (wc_InitMutex(&gRandMethodMutex) != 0) {
 800edbc:	4808      	ldr	r0, [pc, #32]	@ (800ede0 <wolfSSL_RAND_InitMutex+0x30>)
 800edbe:	f018 fae3 	bl	8027388 <wc_InitMutex>
 800edc2:	4603      	mov	r3, r0
 800edc4:	2b00      	cmp	r3, #0
 800edc6:	d002      	beq.n	800edce <wolfSSL_RAND_InitMutex+0x1e>
            WOLFSSL_MSG("Bad Init Mutex rand methods");
            return BAD_MUTEX_E;
 800edc8:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 800edcc:	e003      	b.n	800edd6 <wolfSSL_RAND_InitMutex+0x26>
        }
        gRandMethodsInit = 1;
 800edce:	4b03      	ldr	r3, [pc, #12]	@ (800eddc <wolfSSL_RAND_InitMutex+0x2c>)
 800edd0:	2201      	movs	r2, #1
 800edd2:	601a      	str	r2, [r3, #0]
    }
#endif
    return 0;
 800edd4:	2300      	movs	r3, #0
}
 800edd6:	4618      	mov	r0, r3
 800edd8:	bd80      	pop	{r7, pc}
 800edda:	bf00      	nop
 800eddc:	200026dc 	.word	0x200026dc
 800ede0:	200026d8 	.word	0x200026d8

0800ede4 <wolfSSL_RAND_Init>:
/* Checks if the global RNG has been created. If not then one is created.
 *
 * Returns WOLFSSL_SUCCESS when no error is encountered.
 */
int wolfSSL_RAND_Init(void)
{
 800ede4:	b580      	push	{r7, lr}
 800ede6:	b082      	sub	sp, #8
 800ede8:	af00      	add	r7, sp, #0
    int ret = WC_NO_ERR_TRACE(WOLFSSL_FAILURE);
 800edea:	2300      	movs	r3, #0
 800edec:	607b      	str	r3, [r7, #4]
#ifdef HAVE_GLOBAL_RNG
    if (wc_LockMutex(&globalRNGMutex) == 0) {
 800edee:	4810      	ldr	r0, [pc, #64]	@ (800ee30 <wolfSSL_RAND_Init+0x4c>)
 800edf0:	f018 fae0 	bl	80273b4 <wc_LockMutex>
 800edf4:	4603      	mov	r3, r0
 800edf6:	2b00      	cmp	r3, #0
 800edf8:	d115      	bne.n	800ee26 <wolfSSL_RAND_Init+0x42>
        if (initGlobalRNG == 0) {
 800edfa:	4b0e      	ldr	r3, [pc, #56]	@ (800ee34 <wolfSSL_RAND_Init+0x50>)
 800edfc:	681b      	ldr	r3, [r3, #0]
 800edfe:	2b00      	cmp	r3, #0
 800ee00:	d10c      	bne.n	800ee1c <wolfSSL_RAND_Init+0x38>
            ret = wc_InitRng(&globalRNG);
 800ee02:	480d      	ldr	r0, [pc, #52]	@ (800ee38 <wolfSSL_RAND_Init+0x54>)
 800ee04:	f010 fbbb 	bl	801f57e <wc_InitRng>
 800ee08:	6078      	str	r0, [r7, #4]
            if (ret == 0) {
 800ee0a:	687b      	ldr	r3, [r7, #4]
 800ee0c:	2b00      	cmp	r3, #0
 800ee0e:	d107      	bne.n	800ee20 <wolfSSL_RAND_Init+0x3c>
                initGlobalRNG = 1;
 800ee10:	4b08      	ldr	r3, [pc, #32]	@ (800ee34 <wolfSSL_RAND_Init+0x50>)
 800ee12:	2201      	movs	r2, #1
 800ee14:	601a      	str	r2, [r3, #0]
                ret = WOLFSSL_SUCCESS;
 800ee16:	2301      	movs	r3, #1
 800ee18:	607b      	str	r3, [r7, #4]
 800ee1a:	e001      	b.n	800ee20 <wolfSSL_RAND_Init+0x3c>
            }
        }
        else {
            /* GlobalRNG is already initialized */
            ret = WOLFSSL_SUCCESS;
 800ee1c:	2301      	movs	r3, #1
 800ee1e:	607b      	str	r3, [r7, #4]
        }

        wc_UnLockMutex(&globalRNGMutex);
 800ee20:	4803      	ldr	r0, [pc, #12]	@ (800ee30 <wolfSSL_RAND_Init+0x4c>)
 800ee22:	f018 fad2 	bl	80273ca <wc_UnLockMutex>
    }
#endif
    return ret;
 800ee26:	687b      	ldr	r3, [r7, #4]
}
 800ee28:	4618      	mov	r0, r3
 800ee2a:	3708      	adds	r7, #8
 800ee2c:	46bd      	mov	sp, r7
 800ee2e:	bd80      	pop	{r7, pc}
 800ee30:	200026c8 	.word	0x200026c8
 800ee34:	200026c4 	.word	0x200026c4
 800ee38:	200026b4 	.word	0x200026b4

0800ee3c <wolfSSL_RAND_seed>:


/* WOLFSSL_SUCCESS on ok */
int wolfSSL_RAND_seed(const void* seed, int len)
{
 800ee3c:	b580      	push	{r7, lr}
 800ee3e:	b084      	sub	sp, #16
 800ee40:	af00      	add	r7, sp, #0
 800ee42:	6078      	str	r0, [r7, #4]
 800ee44:	6039      	str	r1, [r7, #0]
#ifndef WOLFSSL_NO_OPENSSL_RAND_CB
    if (wolfSSL_RAND_InitMutex() == 0 && wc_LockMutex(&gRandMethodMutex) == 0) {
 800ee46:	f7ff ffb3 	bl	800edb0 <wolfSSL_RAND_InitMutex>
 800ee4a:	4603      	mov	r3, r0
 800ee4c:	2b00      	cmp	r3, #0
 800ee4e:	d11d      	bne.n	800ee8c <wolfSSL_RAND_seed+0x50>
 800ee50:	4812      	ldr	r0, [pc, #72]	@ (800ee9c <wolfSSL_RAND_seed+0x60>)
 800ee52:	f018 faaf 	bl	80273b4 <wc_LockMutex>
 800ee56:	4603      	mov	r3, r0
 800ee58:	2b00      	cmp	r3, #0
 800ee5a:	d117      	bne.n	800ee8c <wolfSSL_RAND_seed+0x50>
        if (gRandMethods && gRandMethods->seed) {
 800ee5c:	4b10      	ldr	r3, [pc, #64]	@ (800eea0 <wolfSSL_RAND_seed+0x64>)
 800ee5e:	681b      	ldr	r3, [r3, #0]
 800ee60:	2b00      	cmp	r3, #0
 800ee62:	d010      	beq.n	800ee86 <wolfSSL_RAND_seed+0x4a>
 800ee64:	4b0e      	ldr	r3, [pc, #56]	@ (800eea0 <wolfSSL_RAND_seed+0x64>)
 800ee66:	681b      	ldr	r3, [r3, #0]
 800ee68:	681b      	ldr	r3, [r3, #0]
 800ee6a:	2b00      	cmp	r3, #0
 800ee6c:	d00b      	beq.n	800ee86 <wolfSSL_RAND_seed+0x4a>
            int ret = gRandMethods->seed(seed, len);
 800ee6e:	4b0c      	ldr	r3, [pc, #48]	@ (800eea0 <wolfSSL_RAND_seed+0x64>)
 800ee70:	681b      	ldr	r3, [r3, #0]
 800ee72:	681b      	ldr	r3, [r3, #0]
 800ee74:	6839      	ldr	r1, [r7, #0]
 800ee76:	6878      	ldr	r0, [r7, #4]
 800ee78:	4798      	blx	r3
 800ee7a:	60f8      	str	r0, [r7, #12]
            wc_UnLockMutex(&gRandMethodMutex);
 800ee7c:	4807      	ldr	r0, [pc, #28]	@ (800ee9c <wolfSSL_RAND_seed+0x60>)
 800ee7e:	f018 faa4 	bl	80273ca <wc_UnLockMutex>
            return ret;
 800ee82:	68fb      	ldr	r3, [r7, #12]
 800ee84:	e005      	b.n	800ee92 <wolfSSL_RAND_seed+0x56>
        }
        wc_UnLockMutex(&gRandMethodMutex);
 800ee86:	4805      	ldr	r0, [pc, #20]	@ (800ee9c <wolfSSL_RAND_seed+0x60>)
 800ee88:	f018 fa9f 	bl	80273ca <wc_UnLockMutex>
    (void)seed;
    (void)len;
#endif

    /* Make sure global shared RNG (globalRNG) is initialized */
    return wolfSSL_RAND_Init();
 800ee8c:	f7ff ffaa 	bl	800ede4 <wolfSSL_RAND_Init>
 800ee90:	4603      	mov	r3, r0
}
 800ee92:	4618      	mov	r0, r3
 800ee94:	3710      	adds	r7, #16
 800ee96:	46bd      	mov	sp, r7
 800ee98:	bd80      	pop	{r7, pc}
 800ee9a:	bf00      	nop
 800ee9c:	200026d8 	.word	0x200026d8
 800eea0:	200026d4 	.word	0x200026d4

0800eea4 <wolfSSL_RAND_Cleanup>:
}

#endif /* !FREERTOS_TCP */

void wolfSSL_RAND_Cleanup(void)
{
 800eea4:	b580      	push	{r7, lr}
 800eea6:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_NO_OPENSSL_RAND_CB
    if (wolfSSL_RAND_InitMutex() == 0 && wc_LockMutex(&gRandMethodMutex) == 0) {
 800eea8:	f7ff ff82 	bl	800edb0 <wolfSSL_RAND_InitMutex>
 800eeac:	4603      	mov	r3, r0
 800eeae:	2b00      	cmp	r3, #0
 800eeb0:	d115      	bne.n	800eede <wolfSSL_RAND_Cleanup+0x3a>
 800eeb2:	481a      	ldr	r0, [pc, #104]	@ (800ef1c <wolfSSL_RAND_Cleanup+0x78>)
 800eeb4:	f018 fa7e 	bl	80273b4 <wc_LockMutex>
 800eeb8:	4603      	mov	r3, r0
 800eeba:	2b00      	cmp	r3, #0
 800eebc:	d10f      	bne.n	800eede <wolfSSL_RAND_Cleanup+0x3a>
        if (gRandMethods && gRandMethods->cleanup)
 800eebe:	4b18      	ldr	r3, [pc, #96]	@ (800ef20 <wolfSSL_RAND_Cleanup+0x7c>)
 800eec0:	681b      	ldr	r3, [r3, #0]
 800eec2:	2b00      	cmp	r3, #0
 800eec4:	d008      	beq.n	800eed8 <wolfSSL_RAND_Cleanup+0x34>
 800eec6:	4b16      	ldr	r3, [pc, #88]	@ (800ef20 <wolfSSL_RAND_Cleanup+0x7c>)
 800eec8:	681b      	ldr	r3, [r3, #0]
 800eeca:	689b      	ldr	r3, [r3, #8]
 800eecc:	2b00      	cmp	r3, #0
 800eece:	d003      	beq.n	800eed8 <wolfSSL_RAND_Cleanup+0x34>
            gRandMethods->cleanup();
 800eed0:	4b13      	ldr	r3, [pc, #76]	@ (800ef20 <wolfSSL_RAND_Cleanup+0x7c>)
 800eed2:	681b      	ldr	r3, [r3, #0]
 800eed4:	689b      	ldr	r3, [r3, #8]
 800eed6:	4798      	blx	r3
        wc_UnLockMutex(&gRandMethodMutex);
 800eed8:	4810      	ldr	r0, [pc, #64]	@ (800ef1c <wolfSSL_RAND_Cleanup+0x78>)
 800eeda:	f018 fa76 	bl	80273ca <wc_UnLockMutex>
    }

    #ifndef WOLFSSL_MUTEX_INITIALIZER
    if (wc_FreeMutex(&gRandMethodMutex) == 0)
 800eede:	480f      	ldr	r0, [pc, #60]	@ (800ef1c <wolfSSL_RAND_Cleanup+0x78>)
 800eee0:	f018 fa5d 	bl	802739e <wc_FreeMutex>
 800eee4:	4603      	mov	r3, r0
 800eee6:	2b00      	cmp	r3, #0
 800eee8:	d102      	bne.n	800eef0 <wolfSSL_RAND_Cleanup+0x4c>
        gRandMethodsInit = 0;
 800eeea:	4b0e      	ldr	r3, [pc, #56]	@ (800ef24 <wolfSSL_RAND_Cleanup+0x80>)
 800eeec:	2200      	movs	r2, #0
 800eeee:	601a      	str	r2, [r3, #0]
    #endif
#endif
#ifdef HAVE_GLOBAL_RNG
    if (wc_LockMutex(&globalRNGMutex) == 0) {
 800eef0:	480d      	ldr	r0, [pc, #52]	@ (800ef28 <wolfSSL_RAND_Cleanup+0x84>)
 800eef2:	f018 fa5f 	bl	80273b4 <wc_LockMutex>
 800eef6:	4603      	mov	r3, r0
 800eef8:	2b00      	cmp	r3, #0
 800eefa:	d10c      	bne.n	800ef16 <wolfSSL_RAND_Cleanup+0x72>
        if (initGlobalRNG) {
 800eefc:	4b0b      	ldr	r3, [pc, #44]	@ (800ef2c <wolfSSL_RAND_Cleanup+0x88>)
 800eefe:	681b      	ldr	r3, [r3, #0]
 800ef00:	2b00      	cmp	r3, #0
 800ef02:	d005      	beq.n	800ef10 <wolfSSL_RAND_Cleanup+0x6c>
            wc_FreeRng(&globalRNG);
 800ef04:	480a      	ldr	r0, [pc, #40]	@ (800ef30 <wolfSSL_RAND_Cleanup+0x8c>)
 800ef06:	f010 fbed 	bl	801f6e4 <wc_FreeRng>
            initGlobalRNG = 0;
 800ef0a:	4b08      	ldr	r3, [pc, #32]	@ (800ef2c <wolfSSL_RAND_Cleanup+0x88>)
 800ef0c:	2200      	movs	r2, #0
 800ef0e:	601a      	str	r2, [r3, #0]
        }
        wc_UnLockMutex(&globalRNGMutex);
 800ef10:	4805      	ldr	r0, [pc, #20]	@ (800ef28 <wolfSSL_RAND_Cleanup+0x84>)
 800ef12:	f018 fa5a 	bl	80273ca <wc_UnLockMutex>
    }
#endif
}
 800ef16:	bf00      	nop
 800ef18:	bd80      	pop	{r7, pc}
 800ef1a:	bf00      	nop
 800ef1c:	200026d8 	.word	0x200026d8
 800ef20:	200026d4 	.word	0x200026d4
 800ef24:	200026dc 	.word	0x200026dc
 800ef28:	200026c8 	.word	0x200026c8
 800ef2c:	200026c4 	.word	0x200026c4
 800ef30:	200026b4 	.word	0x200026b4

0800ef34 <wolfSSL_X509_STORE_CTX_new_ex>:
 *****************************************************************************/

/* This API is necessary outside of OPENSSL_EXTRA because it is used in
 * SetupStoreCtxCallback */
WOLFSSL_X509_STORE_CTX* wolfSSL_X509_STORE_CTX_new_ex(void* heap)
{
 800ef34:	b580      	push	{r7, lr}
 800ef36:	b084      	sub	sp, #16
 800ef38:	af00      	add	r7, sp, #0
 800ef3a:	6078      	str	r0, [r7, #4]
    WOLFSSL_X509_STORE_CTX* ctx;
    WOLFSSL_ENTER("wolfSSL_X509_STORE_CTX_new_ex");

    ctx = (WOLFSSL_X509_STORE_CTX*)XMALLOC(sizeof(WOLFSSL_X509_STORE_CTX), heap,
 800ef3c:	2050      	movs	r0, #80	@ 0x50
 800ef3e:	f00f fda9 	bl	801ea94 <wolfSSL_Malloc>
 800ef42:	60f8      	str	r0, [r7, #12]
                                    DYNAMIC_TYPE_X509_CTX);
    if (ctx != NULL) {
 800ef44:	68fb      	ldr	r3, [r7, #12]
 800ef46:	2b00      	cmp	r3, #0
 800ef48:	d02b      	beq.n	800efa2 <wolfSSL_X509_STORE_CTX_new_ex+0x6e>
        XMEMSET(ctx, 0, sizeof(WOLFSSL_X509_STORE_CTX));
 800ef4a:	2250      	movs	r2, #80	@ 0x50
 800ef4c:	2100      	movs	r1, #0
 800ef4e:	68f8      	ldr	r0, [r7, #12]
 800ef50:	f019 fabe 	bl	80284d0 <memset>
        ctx->heap = heap;
 800ef54:	68fb      	ldr	r3, [r7, #12]
 800ef56:	687a      	ldr	r2, [r7, #4]
 800ef58:	63da      	str	r2, [r3, #60]	@ 0x3c
#ifdef OPENSSL_EXTRA
        if ((ctx->owned = wolfSSL_sk_X509_new_null()) == NULL) {
 800ef5a:	f7ff fe1e 	bl	800eb9a <wolfSSL_sk_X509_new_null>
 800ef5e:	4602      	mov	r2, r0
 800ef60:	68fb      	ldr	r3, [r7, #12]
 800ef62:	645a      	str	r2, [r3, #68]	@ 0x44
 800ef64:	68fb      	ldr	r3, [r7, #12]
 800ef66:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800ef68:	2b00      	cmp	r3, #0
 800ef6a:	d109      	bne.n	800ef80 <wolfSSL_X509_STORE_CTX_new_ex+0x4c>
            XFREE(ctx, heap, DYNAMIC_TYPE_X509_CTX);
 800ef6c:	68fb      	ldr	r3, [r7, #12]
 800ef6e:	60bb      	str	r3, [r7, #8]
 800ef70:	68bb      	ldr	r3, [r7, #8]
 800ef72:	2b00      	cmp	r3, #0
 800ef74:	d002      	beq.n	800ef7c <wolfSSL_X509_STORE_CTX_new_ex+0x48>
 800ef76:	68b8      	ldr	r0, [r7, #8]
 800ef78:	f00f fda8 	bl	801eacc <wolfSSL_Free>
            ctx = NULL;
 800ef7c:	2300      	movs	r3, #0
 800ef7e:	60fb      	str	r3, [r7, #12]
        }
        if (ctx != NULL &&
 800ef80:	68fb      	ldr	r3, [r7, #12]
 800ef82:	2b00      	cmp	r3, #0
 800ef84:	d00d      	beq.n	800efa2 <wolfSSL_X509_STORE_CTX_new_ex+0x6e>
            wolfSSL_X509_STORE_CTX_init(ctx, NULL, NULL, NULL) !=
 800ef86:	2300      	movs	r3, #0
 800ef88:	2200      	movs	r2, #0
 800ef8a:	2100      	movs	r1, #0
 800ef8c:	68f8      	ldr	r0, [r7, #12]
 800ef8e:	f000 f848 	bl	800f022 <wolfSSL_X509_STORE_CTX_init>
 800ef92:	4603      	mov	r3, r0
        if (ctx != NULL &&
 800ef94:	2b01      	cmp	r3, #1
 800ef96:	d004      	beq.n	800efa2 <wolfSSL_X509_STORE_CTX_new_ex+0x6e>
                WOLFSSL_SUCCESS) {
            wolfSSL_X509_STORE_CTX_free(ctx);
 800ef98:	68f8      	ldr	r0, [r7, #12]
 800ef9a:	f000 f807 	bl	800efac <wolfSSL_X509_STORE_CTX_free>
            ctx = NULL;
 800ef9e:	2300      	movs	r3, #0
 800efa0:	60fb      	str	r3, [r7, #12]
        }
#endif
    }

    return ctx;
 800efa2:	68fb      	ldr	r3, [r7, #12]
}
 800efa4:	4618      	mov	r0, r3
 800efa6:	3710      	adds	r7, #16
 800efa8:	46bd      	mov	sp, r7
 800efaa:	bd80      	pop	{r7, pc}

0800efac <wolfSSL_X509_STORE_CTX_free>:

/* This API is necessary outside of OPENSSL_EXTRA because it is used in
 * SetupStoreCtxCallback */
/* free's extra data */
void wolfSSL_X509_STORE_CTX_free(WOLFSSL_X509_STORE_CTX* ctx)
{
 800efac:	b580      	push	{r7, lr}
 800efae:	b084      	sub	sp, #16
 800efb0:	af00      	add	r7, sp, #0
 800efb2:	6078      	str	r0, [r7, #4]
    WOLFSSL_ENTER("wolfSSL_X509_STORE_CTX_free");
    if (ctx != NULL) {
 800efb4:	687b      	ldr	r3, [r7, #4]
 800efb6:	2b00      	cmp	r3, #0
 800efb8:	d02f      	beq.n	800f01a <wolfSSL_X509_STORE_CTX_free+0x6e>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
        wolfSSL_CRYPTO_cleanup_ex_data(&ctx->ex_data);
#endif

#ifdef OPENSSL_EXTRA
        XFREE(ctx->param, ctx->heap, DYNAMIC_TYPE_OPENSSL);
 800efba:	687b      	ldr	r3, [r7, #4]
 800efbc:	695b      	ldr	r3, [r3, #20]
 800efbe:	60fb      	str	r3, [r7, #12]
 800efc0:	68fb      	ldr	r3, [r7, #12]
 800efc2:	2b00      	cmp	r3, #0
 800efc4:	d002      	beq.n	800efcc <wolfSSL_X509_STORE_CTX_free+0x20>
 800efc6:	68f8      	ldr	r0, [r7, #12]
 800efc8:	f00f fd80 	bl	801eacc <wolfSSL_Free>
        ctx->param = NULL;
 800efcc:	687b      	ldr	r3, [r7, #4]
 800efce:	2200      	movs	r2, #0
 800efd0:	615a      	str	r2, [r3, #20]

        if (ctx->chain != NULL) {
 800efd2:	687b      	ldr	r3, [r7, #4]
 800efd4:	691b      	ldr	r3, [r3, #16]
 800efd6:	2b00      	cmp	r3, #0
 800efd8:	d004      	beq.n	800efe4 <wolfSSL_X509_STORE_CTX_free+0x38>
            wolfSSL_sk_X509_free(ctx->chain);
 800efda:	687b      	ldr	r3, [r7, #4]
 800efdc:	691b      	ldr	r3, [r3, #16]
 800efde:	4618      	mov	r0, r3
 800efe0:	f7ff f9cf 	bl	800e382 <wolfSSL_sk_X509_free>
        }
        if (ctx->owned != NULL) {
 800efe4:	687b      	ldr	r3, [r7, #4]
 800efe6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800efe8:	2b00      	cmp	r3, #0
 800efea:	d005      	beq.n	800eff8 <wolfSSL_X509_STORE_CTX_free+0x4c>
            wolfSSL_sk_X509_pop_free(ctx->owned, NULL);
 800efec:	687b      	ldr	r3, [r7, #4]
 800efee:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800eff0:	2100      	movs	r1, #0
 800eff2:	4618      	mov	r0, r3
 800eff4:	f7ff f9b8 	bl	800e368 <wolfSSL_sk_X509_pop_free>
        }

        if (ctx->current_issuer != NULL) {
 800eff8:	687b      	ldr	r3, [r7, #4]
 800effa:	689b      	ldr	r3, [r3, #8]
 800effc:	2b00      	cmp	r3, #0
 800effe:	d004      	beq.n	800f00a <wolfSSL_X509_STORE_CTX_free+0x5e>
            wolfSSL_X509_free(ctx->current_issuer);
 800f000:	687b      	ldr	r3, [r7, #4]
 800f002:	689b      	ldr	r3, [r3, #8]
 800f004:	4618      	mov	r0, r3
 800f006:	f7ff f9a4 	bl	800e352 <wolfSSL_X509_free>
        }
#endif

        XFREE(ctx, ctx->heap, DYNAMIC_TYPE_X509_CTX);
 800f00a:	687b      	ldr	r3, [r7, #4]
 800f00c:	60bb      	str	r3, [r7, #8]
 800f00e:	68bb      	ldr	r3, [r7, #8]
 800f010:	2b00      	cmp	r3, #0
 800f012:	d002      	beq.n	800f01a <wolfSSL_X509_STORE_CTX_free+0x6e>
 800f014:	68b8      	ldr	r0, [r7, #8]
 800f016:	f00f fd59 	bl	801eacc <wolfSSL_Free>
    }
}
 800f01a:	bf00      	nop
 800f01c:	3710      	adds	r7, #16
 800f01e:	46bd      	mov	sp, r7
 800f020:	bd80      	pop	{r7, pc}

0800f022 <wolfSSL_X509_STORE_CTX_init>:
}

int wolfSSL_X509_STORE_CTX_init(WOLFSSL_X509_STORE_CTX* ctx,
     WOLFSSL_X509_STORE* store, WOLFSSL_X509* x509,
     WOLF_STACK_OF(WOLFSSL_X509)* sk)
{
 800f022:	b580      	push	{r7, lr}
 800f024:	b084      	sub	sp, #16
 800f026:	af00      	add	r7, sp, #0
 800f028:	60f8      	str	r0, [r7, #12]
 800f02a:	60b9      	str	r1, [r7, #8]
 800f02c:	607a      	str	r2, [r7, #4]
 800f02e:	603b      	str	r3, [r7, #0]
    WOLFSSL_ENTER("wolfSSL_X509_STORE_CTX_init");

    if (ctx != NULL) {
 800f030:	68fb      	ldr	r3, [r7, #12]
 800f032:	2b00      	cmp	r3, #0
 800f034:	d03e      	beq.n	800f0b4 <wolfSSL_X509_STORE_CTX_init+0x92>
        ctx->store = store;
 800f036:	68fb      	ldr	r3, [r7, #12]
 800f038:	68ba      	ldr	r2, [r7, #8]
 800f03a:	601a      	str	r2, [r3, #0]
        #ifndef WOLFSSL_X509_STORE_CERTS
        ctx->current_cert = x509;
 800f03c:	68fb      	ldr	r3, [r7, #12]
 800f03e:	687a      	ldr	r2, [r7, #4]
 800f040:	605a      	str	r2, [r3, #4]
                return WOLFSSL_FAILURE;
        } else
            ctx->current_cert = NULL;
        #endif

        ctx->ctxIntermediates = sk;
 800f042:	68fb      	ldr	r3, [r7, #12]
 800f044:	683a      	ldr	r2, [r7, #0]
 800f046:	649a      	str	r2, [r3, #72]	@ 0x48
        if (ctx->chain != NULL) {
 800f048:	68fb      	ldr	r3, [r7, #12]
 800f04a:	691b      	ldr	r3, [r3, #16]
 800f04c:	2b00      	cmp	r3, #0
 800f04e:	d007      	beq.n	800f060 <wolfSSL_X509_STORE_CTX_init+0x3e>
            wolfSSL_sk_X509_free(ctx->chain);
 800f050:	68fb      	ldr	r3, [r7, #12]
 800f052:	691b      	ldr	r3, [r3, #16]
 800f054:	4618      	mov	r0, r3
 800f056:	f7ff f994 	bl	800e382 <wolfSSL_sk_X509_free>
            ctx->chain = NULL;
 800f05a:	68fb      	ldr	r3, [r7, #12]
 800f05c:	2200      	movs	r2, #0
 800f05e:	611a      	str	r2, [r3, #16]
        }
#ifdef SESSION_CERTS
        ctx->sesChain = NULL;
#endif
        ctx->domain = NULL;
 800f060:	68fb      	ldr	r3, [r7, #12]
 800f062:	2200      	movs	r2, #0
 800f064:	619a      	str	r2, [r3, #24]
#ifdef HAVE_EX_DATA
        XMEMSET(&ctx->ex_data, 0, sizeof(ctx->ex_data));
#endif
        ctx->userCtx = NULL;
 800f066:	68fb      	ldr	r3, [r7, #12]
 800f068:	2200      	movs	r2, #0
 800f06a:	621a      	str	r2, [r3, #32]
        ctx->error = 0;
 800f06c:	68fb      	ldr	r3, [r7, #12]
 800f06e:	2200      	movs	r2, #0
 800f070:	625a      	str	r2, [r3, #36]	@ 0x24
        ctx->error_depth = 0;
 800f072:	68fb      	ldr	r3, [r7, #12]
 800f074:	2200      	movs	r2, #0
 800f076:	629a      	str	r2, [r3, #40]	@ 0x28
        ctx->discardSessionCerts = 0;
 800f078:	68fb      	ldr	r3, [r7, #12]
 800f07a:	2200      	movs	r2, #0
 800f07c:	62da      	str	r2, [r3, #44]	@ 0x2c

        if (ctx->param == NULL) {
 800f07e:	68fb      	ldr	r3, [r7, #12]
 800f080:	695b      	ldr	r3, [r3, #20]
 800f082:	2b00      	cmp	r3, #0
 800f084:	d114      	bne.n	800f0b0 <wolfSSL_X509_STORE_CTX_init+0x8e>
            ctx->param = (WOLFSSL_X509_VERIFY_PARAM*)XMALLOC(
 800f086:	f44f 70a8 	mov.w	r0, #336	@ 0x150
 800f08a:	f00f fd03 	bl	801ea94 <wolfSSL_Malloc>
 800f08e:	4602      	mov	r2, r0
 800f090:	68fb      	ldr	r3, [r7, #12]
 800f092:	615a      	str	r2, [r3, #20]
                           sizeof(WOLFSSL_X509_VERIFY_PARAM),
                           ctx->heap, DYNAMIC_TYPE_OPENSSL);
            if (ctx->param == NULL){
 800f094:	68fb      	ldr	r3, [r7, #12]
 800f096:	695b      	ldr	r3, [r3, #20]
 800f098:	2b00      	cmp	r3, #0
 800f09a:	d101      	bne.n	800f0a0 <wolfSSL_X509_STORE_CTX_init+0x7e>
                WOLFSSL_MSG("wolfSSL_X509_STORE_CTX_init failed");
                return WOLFSSL_FAILURE;
 800f09c:	2300      	movs	r3, #0
 800f09e:	e00a      	b.n	800f0b6 <wolfSSL_X509_STORE_CTX_init+0x94>
            }
            XMEMSET(ctx->param, 0, sizeof(*ctx->param));
 800f0a0:	68fb      	ldr	r3, [r7, #12]
 800f0a2:	695b      	ldr	r3, [r3, #20]
 800f0a4:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 800f0a8:	2100      	movs	r1, #0
 800f0aa:	4618      	mov	r0, r3
 800f0ac:	f019 fa10 	bl	80284d0 <memset>
        }

        return WOLFSSL_SUCCESS;
 800f0b0:	2301      	movs	r3, #1
 800f0b2:	e000      	b.n	800f0b6 <wolfSSL_X509_STORE_CTX_init+0x94>
    }
    return WOLFSSL_FAILURE;
 800f0b4:	2300      	movs	r3, #0
}
 800f0b6:	4618      	mov	r0, r3
 800f0b8:	3710      	adds	r7, #16
 800f0ba:	46bd      	mov	sp, r7
 800f0bc:	bd80      	pop	{r7, pc}

0800f0be <wolfSSL_X509_STORE_free>:
    wolfSSL_sk_X509_OBJECT_pop_free(objs, NULL);
}
#endif

void wolfSSL_X509_STORE_free(WOLFSSL_X509_STORE* store)
{
 800f0be:	b580      	push	{r7, lr}
 800f0c0:	b088      	sub	sp, #32
 800f0c2:	af00      	add	r7, sp, #0
 800f0c4:	6078      	str	r0, [r7, #4]
    int doFree = 0;
 800f0c6:	2300      	movs	r3, #0
 800f0c8:	60fb      	str	r3, [r7, #12]
    if (store != NULL && store->isDynamic) {
 800f0ca:	687b      	ldr	r3, [r7, #4]
 800f0cc:	2b00      	cmp	r3, #0
 800f0ce:	d073      	beq.n	800f1b8 <wolfSSL_X509_STORE_free+0xfa>
 800f0d0:	687b      	ldr	r3, [r7, #4]
 800f0d2:	695b      	ldr	r3, [r3, #20]
 800f0d4:	2b00      	cmp	r3, #0
 800f0d6:	d06f      	beq.n	800f1b8 <wolfSSL_X509_STORE_free+0xfa>
        int ret;
        wolfSSL_RefDec(&store->ref, &doFree, &ret);
 800f0d8:	687b      	ldr	r3, [r7, #4]
 800f0da:	331c      	adds	r3, #28
 800f0dc:	2101      	movs	r1, #1
 800f0de:	4618      	mov	r0, r3
 800f0e0:	f7fc f826 	bl	800b130 <wolfSSL_Atomic_Int_FetchSub>
 800f0e4:	61f8      	str	r0, [r7, #28]
 800f0e6:	69fb      	ldr	r3, [r7, #28]
 800f0e8:	2b01      	cmp	r3, #1
 800f0ea:	bf0c      	ite	eq
 800f0ec:	2301      	moveq	r3, #1
 800f0ee:	2300      	movne	r3, #0
 800f0f0:	b2db      	uxtb	r3, r3
 800f0f2:	60fb      	str	r3, [r7, #12]
 800f0f4:	2300      	movs	r3, #0
 800f0f6:	60bb      	str	r3, [r7, #8]
        }
    #else
        (void)ret;
    #endif

        if (doFree) {
 800f0f8:	68fb      	ldr	r3, [r7, #12]
 800f0fa:	2b00      	cmp	r3, #0
 800f0fc:	d05c      	beq.n	800f1b8 <wolfSSL_X509_STORE_free+0xfa>
#ifdef HAVE_EX_DATA_CLEANUP_HOOKS
            wolfSSL_CRYPTO_cleanup_ex_data(&store->ex_data);
#endif
            if (store->cm != NULL) {
 800f0fe:	687b      	ldr	r3, [r7, #4]
 800f100:	685b      	ldr	r3, [r3, #4]
 800f102:	2b00      	cmp	r3, #0
 800f104:	d007      	beq.n	800f116 <wolfSSL_X509_STORE_free+0x58>
                wolfSSL_CertManagerFree(store->cm);
 800f106:	687b      	ldr	r3, [r7, #4]
 800f108:	685b      	ldr	r3, [r3, #4]
 800f10a:	4618      	mov	r0, r3
 800f10c:	f7fc fa69 	bl	800b5e2 <wolfSSL_CertManagerFree>
                store->cm = NULL;
 800f110:	687b      	ldr	r3, [r7, #4]
 800f112:	2200      	movs	r2, #0
 800f114:	605a      	str	r2, [r3, #4]
            }
#if defined(OPENSSL_EXTRA)
            if (store->certs != NULL) {
 800f116:	687b      	ldr	r3, [r7, #4]
 800f118:	6a1b      	ldr	r3, [r3, #32]
 800f11a:	2b00      	cmp	r3, #0
 800f11c:	d008      	beq.n	800f130 <wolfSSL_X509_STORE_free+0x72>
                wolfSSL_sk_X509_pop_free(store->certs, NULL);
 800f11e:	687b      	ldr	r3, [r7, #4]
 800f120:	6a1b      	ldr	r3, [r3, #32]
 800f122:	2100      	movs	r1, #0
 800f124:	4618      	mov	r0, r3
 800f126:	f7ff f91f 	bl	800e368 <wolfSSL_sk_X509_pop_free>
                store->certs = NULL;
 800f12a:	687b      	ldr	r3, [r7, #4]
 800f12c:	2200      	movs	r2, #0
 800f12e:	621a      	str	r2, [r3, #32]
            }
            if (store->owned != NULL) {
 800f130:	687b      	ldr	r3, [r7, #4]
 800f132:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f134:	2b00      	cmp	r3, #0
 800f136:	d008      	beq.n	800f14a <wolfSSL_X509_STORE_free+0x8c>
                wolfSSL_sk_X509_pop_free(store->owned, NULL);
 800f138:	687b      	ldr	r3, [r7, #4]
 800f13a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f13c:	2100      	movs	r1, #0
 800f13e:	4618      	mov	r0, r3
 800f140:	f7ff f912 	bl	800e368 <wolfSSL_sk_X509_pop_free>
                store->owned = NULL;
 800f144:	687b      	ldr	r3, [r7, #4]
 800f146:	2200      	movs	r2, #0
 800f148:	629a      	str	r2, [r3, #40]	@ 0x28
            }
            if (store->trusted != NULL) {
 800f14a:	687b      	ldr	r3, [r7, #4]
 800f14c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f14e:	2b00      	cmp	r3, #0
 800f150:	d008      	beq.n	800f164 <wolfSSL_X509_STORE_free+0xa6>
                wolfSSL_sk_X509_pop_free(store->trusted, NULL);
 800f152:	687b      	ldr	r3, [r7, #4]
 800f154:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f156:	2100      	movs	r1, #0
 800f158:	4618      	mov	r0, r3
 800f15a:	f7ff f905 	bl	800e368 <wolfSSL_sk_X509_pop_free>
                store->trusted = NULL;
 800f15e:	687b      	ldr	r3, [r7, #4]
 800f160:	2200      	movs	r2, #0
 800f162:	625a      	str	r2, [r3, #36]	@ 0x24
            if (store->objs != NULL) {
                X509StoreFreeObjList(store, store->objs);
            }
#endif
#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
            XFREE(store->param, NULL, DYNAMIC_TYPE_OPENSSL);
 800f164:	687b      	ldr	r3, [r7, #4]
 800f166:	699b      	ldr	r3, [r3, #24]
 800f168:	61bb      	str	r3, [r7, #24]
 800f16a:	69bb      	ldr	r3, [r7, #24]
 800f16c:	2b00      	cmp	r3, #0
 800f16e:	d002      	beq.n	800f176 <wolfSSL_X509_STORE_free+0xb8>
 800f170:	69b8      	ldr	r0, [r7, #24]
 800f172:	f00f fcab 	bl	801eacc <wolfSSL_Free>
            store->param = NULL;
 800f176:	687b      	ldr	r3, [r7, #4]
 800f178:	2200      	movs	r2, #0
 800f17a:	619a      	str	r2, [r3, #24]

            if (store->lookup.dirs != NULL) {
 800f17c:	687b      	ldr	r3, [r7, #4]
 800f17e:	691b      	ldr	r3, [r3, #16]
 800f180:	2b00      	cmp	r3, #0
 800f182:	d011      	beq.n	800f1a8 <wolfSSL_X509_STORE_free+0xea>
                if (store->lookup.dirs->dir_entry) {
                    wolfSSL_sk_BY_DIR_entry_free(
                        store->lookup.dirs->dir_entry);
                }
#endif
                wc_FreeMutex(&store->lookup.dirs->lock);
 800f184:	687b      	ldr	r3, [r7, #4]
 800f186:	691b      	ldr	r3, [r3, #16]
 800f188:	3304      	adds	r3, #4
 800f18a:	4618      	mov	r0, r3
 800f18c:	f018 f907 	bl	802739e <wc_FreeMutex>
                XFREE(store->lookup.dirs, NULL, DYNAMIC_TYPE_OPENSSL);
 800f190:	687b      	ldr	r3, [r7, #4]
 800f192:	691b      	ldr	r3, [r3, #16]
 800f194:	617b      	str	r3, [r7, #20]
 800f196:	697b      	ldr	r3, [r7, #20]
 800f198:	2b00      	cmp	r3, #0
 800f19a:	d002      	beq.n	800f1a2 <wolfSSL_X509_STORE_free+0xe4>
 800f19c:	6978      	ldr	r0, [r7, #20]
 800f19e:	f00f fc95 	bl	801eacc <wolfSSL_Free>
                store->lookup.dirs = NULL;
 800f1a2:	687b      	ldr	r3, [r7, #4]
 800f1a4:	2200      	movs	r2, #0
 800f1a6:	611a      	str	r2, [r3, #16]
            }
#endif
            wolfSSL_RefFree(&store->ref);
            XFREE(store, NULL, DYNAMIC_TYPE_X509_STORE);
 800f1a8:	687b      	ldr	r3, [r7, #4]
 800f1aa:	613b      	str	r3, [r7, #16]
 800f1ac:	693b      	ldr	r3, [r7, #16]
 800f1ae:	2b00      	cmp	r3, #0
 800f1b0:	d002      	beq.n	800f1b8 <wolfSSL_X509_STORE_free+0xfa>
 800f1b2:	6938      	ldr	r0, [r7, #16]
 800f1b4:	f00f fc8a 	bl	801eacc <wolfSSL_Free>
        }
    }
}
 800f1b8:	bf00      	nop
 800f1ba:	3720      	adds	r7, #32
 800f1bc:	46bd      	mov	sp, r7
 800f1be:	bd80      	pop	{r7, pc}

0800f1c0 <wolfSSL_FIPS_drbg_uninstantiate>:
    (void)adin;
    (void)adinlen;
    return ret;
}
int wolfSSL_FIPS_drbg_uninstantiate(WOLFSSL_DRBG_CTX *ctx)
{
 800f1c0:	b580      	push	{r7, lr}
 800f1c2:	b082      	sub	sp, #8
 800f1c4:	af00      	add	r7, sp, #0
 800f1c6:	6078      	str	r0, [r7, #4]
    if (ctx != NULL && ctx->rng != NULL) {
 800f1c8:	687b      	ldr	r3, [r7, #4]
 800f1ca:	2b00      	cmp	r3, #0
 800f1cc:	d00e      	beq.n	800f1ec <wolfSSL_FIPS_drbg_uninstantiate+0x2c>
 800f1ce:	687b      	ldr	r3, [r7, #4]
 800f1d0:	681b      	ldr	r3, [r3, #0]
 800f1d2:	2b00      	cmp	r3, #0
 800f1d4:	d00a      	beq.n	800f1ec <wolfSSL_FIPS_drbg_uninstantiate+0x2c>
    #if !defined(HAVE_SELFTEST) && (!defined(HAVE_FIPS) || \
        (defined(HAVE_FIPS) && FIPS_VERSION_GE(5,0)))
        wc_rng_free(ctx->rng);
 800f1d6:	687b      	ldr	r3, [r7, #4]
 800f1d8:	681b      	ldr	r3, [r3, #0]
 800f1da:	4618      	mov	r0, r3
 800f1dc:	f010 f9b2 	bl	801f544 <wc_rng_free>
    #else
        wc_FreeRng(ctx->rng);
        XFREE(ctx->rng, NULL, DYNAMIC_TYPE_RNG);
    #endif
        ctx->rng = NULL;
 800f1e0:	687b      	ldr	r3, [r7, #4]
 800f1e2:	2200      	movs	r2, #0
 800f1e4:	601a      	str	r2, [r3, #0]
        ctx->status = DRBG_STATUS_UNINITIALISED;
 800f1e6:	687b      	ldr	r3, [r7, #4]
 800f1e8:	2200      	movs	r2, #0
 800f1ea:	61da      	str	r2, [r3, #28]
    }
    return WOLFSSL_SUCCESS;
 800f1ec:	2301      	movs	r3, #1
}
 800f1ee:	4618      	mov	r0, r3
 800f1f0:	3708      	adds	r7, #8
 800f1f2:	46bd      	mov	sp, r7
 800f1f4:	bd80      	pop	{r7, pc}
	...

0800f1f8 <wolfSSL_FIPS_drbg_free>:
void wolfSSL_FIPS_drbg_free(WOLFSSL_DRBG_CTX *ctx)
{
 800f1f8:	b580      	push	{r7, lr}
 800f1fa:	b084      	sub	sp, #16
 800f1fc:	af00      	add	r7, sp, #0
 800f1fe:	6078      	str	r0, [r7, #4]
    if (ctx != NULL) {
 800f200:	687b      	ldr	r3, [r7, #4]
 800f202:	2b00      	cmp	r3, #0
 800f204:	d012      	beq.n	800f22c <wolfSSL_FIPS_drbg_free+0x34>
        /* As safety check if free'ing the default drbg, then mark global NULL.
         * Technically the user should not call free on the default drbg. */
        if (ctx == gDrbgDefCtx) {
 800f206:	4b0b      	ldr	r3, [pc, #44]	@ (800f234 <wolfSSL_FIPS_drbg_free+0x3c>)
 800f208:	681b      	ldr	r3, [r3, #0]
 800f20a:	687a      	ldr	r2, [r7, #4]
 800f20c:	429a      	cmp	r2, r3
 800f20e:	d102      	bne.n	800f216 <wolfSSL_FIPS_drbg_free+0x1e>
            gDrbgDefCtx = NULL;
 800f210:	4b08      	ldr	r3, [pc, #32]	@ (800f234 <wolfSSL_FIPS_drbg_free+0x3c>)
 800f212:	2200      	movs	r2, #0
 800f214:	601a      	str	r2, [r3, #0]
        }
        wolfSSL_FIPS_drbg_uninstantiate(ctx);
 800f216:	6878      	ldr	r0, [r7, #4]
 800f218:	f7ff ffd2 	bl	800f1c0 <wolfSSL_FIPS_drbg_uninstantiate>
        XFREE(ctx, NULL, DYNAMIC_TYPE_OPENSSL);
 800f21c:	687b      	ldr	r3, [r7, #4]
 800f21e:	60fb      	str	r3, [r7, #12]
 800f220:	68fb      	ldr	r3, [r7, #12]
 800f222:	2b00      	cmp	r3, #0
 800f224:	d002      	beq.n	800f22c <wolfSSL_FIPS_drbg_free+0x34>
 800f226:	68f8      	ldr	r0, [r7, #12]
 800f228:	f00f fc50 	bl	801eacc <wolfSSL_Free>
    }
}
 800f22c:	bf00      	nop
 800f22e:	3710      	adds	r7, #16
 800f230:	46bd      	mov	sp, r7
 800f232:	bd80      	pop	{r7, pc}
 800f234:	200026d0 	.word	0x200026d0

0800f238 <MakeTLSv1_2>:


#ifndef WOLFSSL_NO_TLS12

ProtocolVersion MakeTLSv1_2(void)
{
 800f238:	b480      	push	{r7}
 800f23a:	b083      	sub	sp, #12
 800f23c:	af00      	add	r7, sp, #0
    ProtocolVersion pv;
    pv.major = SSLv3_MAJOR;
 800f23e:	2303      	movs	r3, #3
 800f240:	703b      	strb	r3, [r7, #0]
    pv.minor = TLSv1_2_MINOR;
 800f242:	2303      	movs	r3, #3
 800f244:	707b      	strb	r3, [r7, #1]

    return pv;
 800f246:	883b      	ldrh	r3, [r7, #0]
 800f248:	80bb      	strh	r3, [r7, #4]
 800f24a:	2300      	movs	r3, #0
 800f24c:	793a      	ldrb	r2, [r7, #4]
 800f24e:	f362 0307 	bfi	r3, r2, #0, #8
 800f252:	797a      	ldrb	r2, [r7, #5]
 800f254:	f362 230f 	bfi	r3, r2, #8, #8
}
 800f258:	4618      	mov	r0, r3
 800f25a:	370c      	adds	r7, #12
 800f25c:	46bd      	mov	sp, r7
 800f25e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f262:	4770      	bx	lr

0800f264 <TLSX_SNI_Free>:
    return sni;
}

/** Releases a SNI object. */
static void TLSX_SNI_Free(SNI* sni, void* heap)
{
 800f264:	b580      	push	{r7, lr}
 800f266:	b084      	sub	sp, #16
 800f268:	af00      	add	r7, sp, #0
 800f26a:	6078      	str	r0, [r7, #4]
 800f26c:	6039      	str	r1, [r7, #0]
    if (sni) {
 800f26e:	687b      	ldr	r3, [r7, #4]
 800f270:	2b00      	cmp	r3, #0
 800f272:	d015      	beq.n	800f2a0 <TLSX_SNI_Free+0x3c>
        switch (sni->type) {
 800f274:	687b      	ldr	r3, [r7, #4]
 800f276:	781b      	ldrb	r3, [r3, #0]
 800f278:	2b00      	cmp	r3, #0
 800f27a:	d109      	bne.n	800f290 <TLSX_SNI_Free+0x2c>
            case WOLFSSL_SNI_HOST_NAME:
                XFREE(sni->data.host_name, heap, DYNAMIC_TYPE_TLSX);
 800f27c:	687b      	ldr	r3, [r7, #4]
 800f27e:	685b      	ldr	r3, [r3, #4]
 800f280:	60fb      	str	r3, [r7, #12]
 800f282:	68fb      	ldr	r3, [r7, #12]
 800f284:	2b00      	cmp	r3, #0
 800f286:	d002      	beq.n	800f28e <TLSX_SNI_Free+0x2a>
 800f288:	68f8      	ldr	r0, [r7, #12]
 800f28a:	f00f fc1f 	bl	801eacc <wolfSSL_Free>
            break;
 800f28e:	bf00      	nop
        }

        XFREE(sni, heap, DYNAMIC_TYPE_TLSX);
 800f290:	687b      	ldr	r3, [r7, #4]
 800f292:	60bb      	str	r3, [r7, #8]
 800f294:	68bb      	ldr	r3, [r7, #8]
 800f296:	2b00      	cmp	r3, #0
 800f298:	d002      	beq.n	800f2a0 <TLSX_SNI_Free+0x3c>
 800f29a:	68b8      	ldr	r0, [r7, #8]
 800f29c:	f00f fc16 	bl	801eacc <wolfSSL_Free>
    }
    (void)heap;
}
 800f2a0:	bf00      	nop
 800f2a2:	3710      	adds	r7, #16
 800f2a4:	46bd      	mov	sp, r7
 800f2a6:	bd80      	pop	{r7, pc}

0800f2a8 <TLSX_SNI_FreeAll>:

/** Releases all SNI objects in the provided list. */
static void TLSX_SNI_FreeAll(SNI* list, void* heap)
{
 800f2a8:	b580      	push	{r7, lr}
 800f2aa:	b084      	sub	sp, #16
 800f2ac:	af00      	add	r7, sp, #0
 800f2ae:	6078      	str	r0, [r7, #4]
 800f2b0:	6039      	str	r1, [r7, #0]
    SNI* sni;

    while ((sni = list)) {
 800f2b2:	e006      	b.n	800f2c2 <TLSX_SNI_FreeAll+0x1a>
        list = sni->next;
 800f2b4:	68fb      	ldr	r3, [r7, #12]
 800f2b6:	689b      	ldr	r3, [r3, #8]
 800f2b8:	607b      	str	r3, [r7, #4]
        TLSX_SNI_Free(sni, heap);
 800f2ba:	6839      	ldr	r1, [r7, #0]
 800f2bc:	68f8      	ldr	r0, [r7, #12]
 800f2be:	f7ff ffd1 	bl	800f264 <TLSX_SNI_Free>
    while ((sni = list)) {
 800f2c2:	687b      	ldr	r3, [r7, #4]
 800f2c4:	60fb      	str	r3, [r7, #12]
 800f2c6:	68fb      	ldr	r3, [r7, #12]
 800f2c8:	2b00      	cmp	r3, #0
 800f2ca:	d1f3      	bne.n	800f2b4 <TLSX_SNI_FreeAll+0xc>
    }
}
 800f2cc:	bf00      	nop
 800f2ce:	bf00      	nop
 800f2d0:	3710      	adds	r7, #16
 800f2d2:	46bd      	mov	sp, r7
 800f2d4:	bd80      	pop	{r7, pc}

0800f2d6 <TLSX_SupportedCurve_FreeAll>:

    return 0;
}

static void TLSX_SupportedCurve_FreeAll(SupportedCurve* list, void* heap)
{
 800f2d6:	b580      	push	{r7, lr}
 800f2d8:	b084      	sub	sp, #16
 800f2da:	af00      	add	r7, sp, #0
 800f2dc:	6078      	str	r0, [r7, #4]
 800f2de:	6039      	str	r1, [r7, #0]
    SupportedCurve* curve;

    while ((curve = list)) {
 800f2e0:	e00a      	b.n	800f2f8 <TLSX_SupportedCurve_FreeAll+0x22>
        list = curve->next;
 800f2e2:	68fb      	ldr	r3, [r7, #12]
 800f2e4:	685b      	ldr	r3, [r3, #4]
 800f2e6:	607b      	str	r3, [r7, #4]
        XFREE(curve, heap, DYNAMIC_TYPE_TLSX);
 800f2e8:	68fb      	ldr	r3, [r7, #12]
 800f2ea:	60bb      	str	r3, [r7, #8]
 800f2ec:	68bb      	ldr	r3, [r7, #8]
 800f2ee:	2b00      	cmp	r3, #0
 800f2f0:	d002      	beq.n	800f2f8 <TLSX_SupportedCurve_FreeAll+0x22>
 800f2f2:	68b8      	ldr	r0, [r7, #8]
 800f2f4:	f00f fbea 	bl	801eacc <wolfSSL_Free>
    while ((curve = list)) {
 800f2f8:	687b      	ldr	r3, [r7, #4]
 800f2fa:	60fb      	str	r3, [r7, #12]
 800f2fc:	68fb      	ldr	r3, [r7, #12]
 800f2fe:	2b00      	cmp	r3, #0
 800f300:	d1ef      	bne.n	800f2e2 <TLSX_SupportedCurve_FreeAll+0xc>
    }
    (void)heap;
}
 800f302:	bf00      	nop
 800f304:	bf00      	nop
 800f306:	3710      	adds	r7, #16
 800f308:	46bd      	mov	sp, r7
 800f30a:	bd80      	pop	{r7, pc}

0800f30c <TLSX_PointFormat_FreeAll>:

static void TLSX_PointFormat_FreeAll(PointFormat* list, void* heap)
{
 800f30c:	b580      	push	{r7, lr}
 800f30e:	b084      	sub	sp, #16
 800f310:	af00      	add	r7, sp, #0
 800f312:	6078      	str	r0, [r7, #4]
 800f314:	6039      	str	r1, [r7, #0]
    PointFormat* point;

    while ((point = list)) {
 800f316:	e00a      	b.n	800f32e <TLSX_PointFormat_FreeAll+0x22>
        list = point->next;
 800f318:	68fb      	ldr	r3, [r7, #12]
 800f31a:	685b      	ldr	r3, [r3, #4]
 800f31c:	607b      	str	r3, [r7, #4]
        XFREE(point, heap, DYNAMIC_TYPE_TLSX);
 800f31e:	68fb      	ldr	r3, [r7, #12]
 800f320:	60bb      	str	r3, [r7, #8]
 800f322:	68bb      	ldr	r3, [r7, #8]
 800f324:	2b00      	cmp	r3, #0
 800f326:	d002      	beq.n	800f32e <TLSX_PointFormat_FreeAll+0x22>
 800f328:	68b8      	ldr	r0, [r7, #8]
 800f32a:	f00f fbcf 	bl	801eacc <wolfSSL_Free>
    while ((point = list)) {
 800f32e:	687b      	ldr	r3, [r7, #4]
 800f330:	60fb      	str	r3, [r7, #12]
 800f332:	68fb      	ldr	r3, [r7, #12]
 800f334:	2b00      	cmp	r3, #0
 800f336:	d1ef      	bne.n	800f318 <TLSX_PointFormat_FreeAll+0xc>
    }
    (void)heap;
}
 800f338:	bf00      	nop
 800f33a:	bf00      	nop
 800f33c:	3710      	adds	r7, #16
 800f33e:	46bd      	mov	sp, r7
 800f340:	bd80      	pop	{r7, pc}

0800f342 <TLSX_SignatureAlgorithms_FreeAll>:
    return sa;
}

void TLSX_SignatureAlgorithms_FreeAll(SignatureAlgorithms* sa,
                                             void* heap)
{
 800f342:	b580      	push	{r7, lr}
 800f344:	b084      	sub	sp, #16
 800f346:	af00      	add	r7, sp, #0
 800f348:	6078      	str	r0, [r7, #4]
 800f34a:	6039      	str	r1, [r7, #0]
    XFREE(sa, heap, DYNAMIC_TYPE_TLSX);
 800f34c:	687b      	ldr	r3, [r7, #4]
 800f34e:	60fb      	str	r3, [r7, #12]
 800f350:	68fb      	ldr	r3, [r7, #12]
 800f352:	2b00      	cmp	r3, #0
 800f354:	d002      	beq.n	800f35c <TLSX_SignatureAlgorithms_FreeAll+0x1a>
 800f356:	68f8      	ldr	r0, [r7, #12]
 800f358:	f00f fbb8 	bl	801eacc <wolfSSL_Free>
    (void)heap;
}
 800f35c:	bf00      	nop
 800f35e:	3710      	adds	r7, #16
 800f360:	46bd      	mov	sp, r7
 800f362:	bd80      	pop	{r7, pc}

0800f364 <TLSX_KeyShare_FreeAll>:
 *
 * list  The linked list of key share entry objects.
 * heap  The heap used for allocation.
 */
static void TLSX_KeyShare_FreeAll(KeyShareEntry* list, void* heap)
{
 800f364:	b580      	push	{r7, lr}
 800f366:	b088      	sub	sp, #32
 800f368:	af00      	add	r7, sp, #0
 800f36a:	6078      	str	r0, [r7, #4]
 800f36c:	6039      	str	r1, [r7, #0]
    KeyShareEntry* current;

    while ((current = list) != NULL) {
 800f36e:	e04a      	b.n	800f406 <TLSX_KeyShare_FreeAll+0xa2>
        list = current->next;
 800f370:	69fb      	ldr	r3, [r7, #28]
 800f372:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f374:	607b      	str	r3, [r7, #4]
        if (WOLFSSL_NAMED_GROUP_IS_FFHDE(current->group)) {
 800f376:	69fb      	ldr	r3, [r7, #28]
 800f378:	881b      	ldrh	r3, [r3, #0]
 800f37a:	2bff      	cmp	r3, #255	@ 0xff
 800f37c:	d90a      	bls.n	800f394 <TLSX_KeyShare_FreeAll+0x30>
 800f37e:	69fb      	ldr	r3, [r7, #28]
 800f380:	881b      	ldrh	r3, [r3, #0]
 800f382:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800f386:	d205      	bcs.n	800f394 <TLSX_KeyShare_FreeAll+0x30>
#ifndef NO_DH
            wc_FreeDhKey((DhKey*)current->key);
 800f388:	69fb      	ldr	r3, [r7, #28]
 800f38a:	68db      	ldr	r3, [r3, #12]
 800f38c:	4618      	mov	r0, r3
 800f38e:	f00b f9df 	bl	801a750 <wc_FreeDhKey>
 800f392:	e00c      	b.n	800f3ae <TLSX_KeyShare_FreeAll+0x4a>
#endif
        }
        else if (current->group == WOLFSSL_ECC_X25519) {
 800f394:	69fb      	ldr	r3, [r7, #28]
 800f396:	881b      	ldrh	r3, [r3, #0]
 800f398:	2b1d      	cmp	r3, #29
 800f39a:	d008      	beq.n	800f3ae <TLSX_KeyShare_FreeAll+0x4a>
#ifdef HAVE_CURVE25519
            wc_curve25519_free((curve25519_key*)current->key);
#endif
        }
        else if (current->group == WOLFSSL_ECC_X448) {
 800f39c:	69fb      	ldr	r3, [r7, #28]
 800f39e:	881b      	ldrh	r3, [r3, #0]
 800f3a0:	2b1e      	cmp	r3, #30
 800f3a2:	d004      	beq.n	800f3ae <TLSX_KeyShare_FreeAll+0x4a>
            }
        }
#endif
        else {
#ifdef HAVE_ECC
            wc_ecc_free((ecc_key*)current->key);
 800f3a4:	69fb      	ldr	r3, [r7, #28]
 800f3a6:	68db      	ldr	r3, [r3, #12]
 800f3a8:	4618      	mov	r0, r3
 800f3aa:	f00d fdbc 	bl	801cf26 <wc_ecc_free>
#endif
        }
        XFREE(current->key, heap, DYNAMIC_TYPE_PRIVATE_KEY);
 800f3ae:	69fb      	ldr	r3, [r7, #28]
 800f3b0:	68db      	ldr	r3, [r3, #12]
 800f3b2:	61bb      	str	r3, [r7, #24]
 800f3b4:	69bb      	ldr	r3, [r7, #24]
 800f3b6:	2b00      	cmp	r3, #0
 800f3b8:	d002      	beq.n	800f3c0 <TLSX_KeyShare_FreeAll+0x5c>
 800f3ba:	69b8      	ldr	r0, [r7, #24]
 800f3bc:	f00f fb86 	bl	801eacc <wolfSSL_Free>
    #if !defined(NO_DH) && (!defined(NO_CERTS) || !defined(NO_PSK))
        XFREE(current->privKey, heap, DYNAMIC_TYPE_PRIVATE_KEY);
 800f3c0:	69fb      	ldr	r3, [r7, #28]
 800f3c2:	69db      	ldr	r3, [r3, #28]
 800f3c4:	617b      	str	r3, [r7, #20]
 800f3c6:	697b      	ldr	r3, [r7, #20]
 800f3c8:	2b00      	cmp	r3, #0
 800f3ca:	d002      	beq.n	800f3d2 <TLSX_KeyShare_FreeAll+0x6e>
 800f3cc:	6978      	ldr	r0, [r7, #20]
 800f3ce:	f00f fb7d 	bl	801eacc <wolfSSL_Free>
    #endif
        XFREE(current->pubKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800f3d2:	69fb      	ldr	r3, [r7, #28]
 800f3d4:	695b      	ldr	r3, [r3, #20]
 800f3d6:	613b      	str	r3, [r7, #16]
 800f3d8:	693b      	ldr	r3, [r7, #16]
 800f3da:	2b00      	cmp	r3, #0
 800f3dc:	d002      	beq.n	800f3e4 <TLSX_KeyShare_FreeAll+0x80>
 800f3de:	6938      	ldr	r0, [r7, #16]
 800f3e0:	f00f fb74 	bl	801eacc <wolfSSL_Free>
        XFREE(current->ke, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 800f3e4:	69fb      	ldr	r3, [r7, #28]
 800f3e6:	685b      	ldr	r3, [r3, #4]
 800f3e8:	60fb      	str	r3, [r7, #12]
 800f3ea:	68fb      	ldr	r3, [r7, #12]
 800f3ec:	2b00      	cmp	r3, #0
 800f3ee:	d002      	beq.n	800f3f6 <TLSX_KeyShare_FreeAll+0x92>
 800f3f0:	68f8      	ldr	r0, [r7, #12]
 800f3f2:	f00f fb6b 	bl	801eacc <wolfSSL_Free>
        XFREE(current, heap, DYNAMIC_TYPE_TLSX);
 800f3f6:	69fb      	ldr	r3, [r7, #28]
 800f3f8:	60bb      	str	r3, [r7, #8]
 800f3fa:	68bb      	ldr	r3, [r7, #8]
 800f3fc:	2b00      	cmp	r3, #0
 800f3fe:	d002      	beq.n	800f406 <TLSX_KeyShare_FreeAll+0xa2>
 800f400:	68b8      	ldr	r0, [r7, #8]
 800f402:	f00f fb63 	bl	801eacc <wolfSSL_Free>
    while ((current = list) != NULL) {
 800f406:	687b      	ldr	r3, [r7, #4]
 800f408:	61fb      	str	r3, [r7, #28]
 800f40a:	69fb      	ldr	r3, [r7, #28]
 800f40c:	2b00      	cmp	r3, #0
 800f40e:	d1af      	bne.n	800f370 <TLSX_KeyShare_FreeAll+0xc>
    }

    (void)heap;
}
 800f410:	bf00      	nop
 800f412:	bf00      	nop
 800f414:	3720      	adds	r7, #32
 800f416:	46bd      	mov	sp, r7
 800f418:	bd80      	pop	{r7, pc}
	...

0800f41c <TLSX_FreeAll>:

#endif

/** Releases all extensions in the provided list. */
void TLSX_FreeAll(TLSX* list, void* heap)
{
 800f41c:	b580      	push	{r7, lr}
 800f41e:	b084      	sub	sp, #16
 800f420:	af00      	add	r7, sp, #0
 800f422:	6078      	str	r0, [r7, #4]
 800f424:	6039      	str	r1, [r7, #0]
    TLSX* extension;

    while ((extension = list)) {
 800f426:	e0aa      	b.n	800f57e <TLSX_FreeAll+0x162>
        list = extension->next;
 800f428:	68fb      	ldr	r3, [r7, #12]
 800f42a:	691b      	ldr	r3, [r3, #16]
 800f42c:	607b      	str	r3, [r7, #4]

        switch (extension->type) {
 800f42e:	68fb      	ldr	r3, [r7, #12]
 800f430:	881b      	ldrh	r3, [r3, #0]
 800f432:	2b33      	cmp	r3, #51	@ 0x33
 800f434:	dc70      	bgt.n	800f518 <TLSX_FreeAll+0xfc>
 800f436:	2b00      	cmp	r3, #0
 800f438:	f2c0 8096 	blt.w	800f568 <TLSX_FreeAll+0x14c>
 800f43c:	2b33      	cmp	r3, #51	@ 0x33
 800f43e:	f200 8093 	bhi.w	800f568 <TLSX_FreeAll+0x14c>
 800f442:	a201      	add	r2, pc, #4	@ (adr r2, 800f448 <TLSX_FreeAll+0x2c>)
 800f444:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f448:	0800f523 	.word	0x0800f523
 800f44c:	0800f569 	.word	0x0800f569
 800f450:	0800f569 	.word	0x0800f569
 800f454:	0800f569 	.word	0x0800f569
 800f458:	0800f569 	.word	0x0800f569
 800f45c:	0800f569 	.word	0x0800f569
 800f460:	0800f569 	.word	0x0800f569
 800f464:	0800f569 	.word	0x0800f569
 800f468:	0800f569 	.word	0x0800f569
 800f46c:	0800f569 	.word	0x0800f569
 800f470:	0800f531 	.word	0x0800f531
 800f474:	0800f53f 	.word	0x0800f53f
 800f478:	0800f569 	.word	0x0800f569
 800f47c:	0800f54d 	.word	0x0800f54d
 800f480:	0800f569 	.word	0x0800f569
 800f484:	0800f569 	.word	0x0800f569
 800f488:	0800f569 	.word	0x0800f569
 800f48c:	0800f569 	.word	0x0800f569
 800f490:	0800f569 	.word	0x0800f569
 800f494:	0800f569 	.word	0x0800f569
 800f498:	0800f569 	.word	0x0800f569
 800f49c:	0800f569 	.word	0x0800f569
 800f4a0:	0800f569 	.word	0x0800f569
 800f4a4:	0800f569 	.word	0x0800f569
 800f4a8:	0800f569 	.word	0x0800f569
 800f4ac:	0800f569 	.word	0x0800f569
 800f4b0:	0800f569 	.word	0x0800f569
 800f4b4:	0800f569 	.word	0x0800f569
 800f4b8:	0800f569 	.word	0x0800f569
 800f4bc:	0800f569 	.word	0x0800f569
 800f4c0:	0800f569 	.word	0x0800f569
 800f4c4:	0800f569 	.word	0x0800f569
 800f4c8:	0800f569 	.word	0x0800f569
 800f4cc:	0800f569 	.word	0x0800f569
 800f4d0:	0800f569 	.word	0x0800f569
 800f4d4:	0800f569 	.word	0x0800f569
 800f4d8:	0800f569 	.word	0x0800f569
 800f4dc:	0800f569 	.word	0x0800f569
 800f4e0:	0800f569 	.word	0x0800f569
 800f4e4:	0800f569 	.word	0x0800f569
 800f4e8:	0800f569 	.word	0x0800f569
 800f4ec:	0800f569 	.word	0x0800f569
 800f4f0:	0800f569 	.word	0x0800f569
 800f4f4:	0800f569 	.word	0x0800f569
 800f4f8:	0800f569 	.word	0x0800f569
 800f4fc:	0800f569 	.word	0x0800f569
 800f500:	0800f569 	.word	0x0800f569
 800f504:	0800f569 	.word	0x0800f569
 800f508:	0800f569 	.word	0x0800f569
 800f50c:	0800f569 	.word	0x0800f569
 800f510:	0800f569 	.word	0x0800f569
 800f514:	0800f55b 	.word	0x0800f55b
 800f518:	f64f 7201 	movw	r2, #65281	@ 0xff01
 800f51c:	4293      	cmp	r3, r2
 800f51e:	d025      	beq.n	800f56c <TLSX_FreeAll+0x150>
                WOLFSSL_MSG("CKS extension free");
                /* nothing to do */
                break;
#endif
            default:
                break;
 800f520:	e022      	b.n	800f568 <TLSX_FreeAll+0x14c>
                SNI_FREE_ALL((SNI*)extension->data, heap);
 800f522:	68fb      	ldr	r3, [r7, #12]
 800f524:	685b      	ldr	r3, [r3, #4]
 800f526:	6839      	ldr	r1, [r7, #0]
 800f528:	4618      	mov	r0, r3
 800f52a:	f7ff febd 	bl	800f2a8 <TLSX_SNI_FreeAll>
                break;
 800f52e:	e01e      	b.n	800f56e <TLSX_FreeAll+0x152>
                EC_FREE_ALL((SupportedCurve*)extension->data, heap);
 800f530:	68fb      	ldr	r3, [r7, #12]
 800f532:	685b      	ldr	r3, [r3, #4]
 800f534:	6839      	ldr	r1, [r7, #0]
 800f536:	4618      	mov	r0, r3
 800f538:	f7ff fecd 	bl	800f2d6 <TLSX_SupportedCurve_FreeAll>
                break;
 800f53c:	e017      	b.n	800f56e <TLSX_FreeAll+0x152>
                PF_FREE_ALL((PointFormat*)extension->data, heap);
 800f53e:	68fb      	ldr	r3, [r7, #12]
 800f540:	685b      	ldr	r3, [r3, #4]
 800f542:	6839      	ldr	r1, [r7, #0]
 800f544:	4618      	mov	r0, r3
 800f546:	f7ff fee1 	bl	800f30c <TLSX_PointFormat_FreeAll>
                break;
 800f54a:	e010      	b.n	800f56e <TLSX_FreeAll+0x152>
                SA_FREE_ALL((SignatureAlgorithms*)extension->data, heap);
 800f54c:	68fb      	ldr	r3, [r7, #12]
 800f54e:	685b      	ldr	r3, [r3, #4]
 800f550:	6839      	ldr	r1, [r7, #0]
 800f552:	4618      	mov	r0, r3
 800f554:	f7ff fef5 	bl	800f342 <TLSX_SignatureAlgorithms_FreeAll>
                break;
 800f558:	e009      	b.n	800f56e <TLSX_FreeAll+0x152>
                KS_FREE_ALL((KeyShareEntry*)extension->data, heap);
 800f55a:	68fb      	ldr	r3, [r7, #12]
 800f55c:	685b      	ldr	r3, [r3, #4]
 800f55e:	6839      	ldr	r1, [r7, #0]
 800f560:	4618      	mov	r0, r3
 800f562:	f7ff feff 	bl	800f364 <TLSX_KeyShare_FreeAll>
                break;
 800f566:	e002      	b.n	800f56e <TLSX_FreeAll+0x152>
                break;
 800f568:	bf00      	nop
 800f56a:	e000      	b.n	800f56e <TLSX_FreeAll+0x152>
                break;
 800f56c:	bf00      	nop
        }

        XFREE(extension, heap, DYNAMIC_TYPE_TLSX);
 800f56e:	68fb      	ldr	r3, [r7, #12]
 800f570:	60bb      	str	r3, [r7, #8]
 800f572:	68bb      	ldr	r3, [r7, #8]
 800f574:	2b00      	cmp	r3, #0
 800f576:	d002      	beq.n	800f57e <TLSX_FreeAll+0x162>
 800f578:	68b8      	ldr	r0, [r7, #8]
 800f57a:	f00f faa7 	bl	801eacc <wolfSSL_Free>
    while ((extension = list)) {
 800f57e:	687b      	ldr	r3, [r7, #4]
 800f580:	60fb      	str	r3, [r7, #12]
 800f582:	68fb      	ldr	r3, [r7, #12]
 800f584:	2b00      	cmp	r3, #0
 800f586:	f47f af4f 	bne.w	800f428 <TLSX_FreeAll+0xc>
    }

    (void)heap;
}
 800f58a:	bf00      	nop
 800f58c:	bf00      	nop
 800f58e:	3710      	adds	r7, #16
 800f590:	46bd      	mov	sp, r7
 800f592:	bd80      	pop	{r7, pc}

0800f594 <wolfTLSv1_2_client_method>:
#endif /* !NO_OLD_TLS */

#ifndef WOLFSSL_NO_TLS12
    WOLFSSL_ABI
    WOLFSSL_METHOD* wolfTLSv1_2_client_method(void)
    {
 800f594:	b580      	push	{r7, lr}
 800f596:	af00      	add	r7, sp, #0
        return wolfTLSv1_2_client_method_ex(NULL);
 800f598:	2000      	movs	r0, #0
 800f59a:	f000 f803 	bl	800f5a4 <wolfTLSv1_2_client_method_ex>
 800f59e:	4603      	mov	r3, r0
    }
 800f5a0:	4618      	mov	r0, r3
 800f5a2:	bd80      	pop	{r7, pc}

0800f5a4 <wolfTLSv1_2_client_method_ex>:
    WOLFSSL_METHOD* wolfTLSv1_2_client_method_ex(void* heap)
    {
 800f5a4:	b580      	push	{r7, lr}
 800f5a6:	b084      	sub	sp, #16
 800f5a8:	af00      	add	r7, sp, #0
 800f5aa:	6078      	str	r0, [r7, #4]
        WOLFSSL_METHOD* method =
                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
 800f5ac:	2004      	movs	r0, #4
 800f5ae:	f00f fa71 	bl	801ea94 <wolfSSL_Malloc>
 800f5b2:	60f8      	str	r0, [r7, #12]
                                                     heap, DYNAMIC_TYPE_METHOD);
        (void)heap;
        WOLFSSL_ENTER("TLSv1_2_client_method_ex");
        if (method)
 800f5b4:	68fb      	ldr	r3, [r7, #12]
 800f5b6:	2b00      	cmp	r3, #0
 800f5b8:	d007      	beq.n	800f5ca <wolfTLSv1_2_client_method_ex+0x26>
            InitSSL_Method(method, MakeTLSv1_2());
 800f5ba:	f7ff fe3d 	bl	800f238 <MakeTLSv1_2>
 800f5be:	4603      	mov	r3, r0
 800f5c0:	813b      	strh	r3, [r7, #8]
 800f5c2:	68b9      	ldr	r1, [r7, #8]
 800f5c4:	68f8      	ldr	r0, [r7, #12]
 800f5c6:	f7f9 f9bc 	bl	8008942 <InitSSL_Method>
        return method;
 800f5ca:	68fb      	ldr	r3, [r7, #12]
    }
 800f5cc:	4618      	mov	r0, r3
 800f5ce:	3710      	adds	r7, #16
 800f5d0:	46bd      	mov	sp, r7
 800f5d2:	bd80      	pop	{r7, pc}

0800f5d4 <rotlFixed>:
    {
 800f5d4:	b480      	push	{r7}
 800f5d6:	b083      	sub	sp, #12
 800f5d8:	af00      	add	r7, sp, #0
 800f5da:	6078      	str	r0, [r7, #4]
 800f5dc:	6039      	str	r1, [r7, #0]
        return (x << y) | (x >> (sizeof(x) * 8 - y));
 800f5de:	687a      	ldr	r2, [r7, #4]
 800f5e0:	683b      	ldr	r3, [r7, #0]
 800f5e2:	f1c3 0320 	rsb	r3, r3, #32
 800f5e6:	fa62 f303 	ror.w	r3, r2, r3
    }
 800f5ea:	4618      	mov	r0, r3
 800f5ec:	370c      	adds	r7, #12
 800f5ee:	46bd      	mov	sp, r7
 800f5f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f5f4:	4770      	bx	lr

0800f5f6 <ByteReverseWord32>:
{
 800f5f6:	b580      	push	{r7, lr}
 800f5f8:	b082      	sub	sp, #8
 800f5fa:	af00      	add	r7, sp, #0
 800f5fc:	6078      	str	r0, [r7, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 800f5fe:	687b      	ldr	r3, [r7, #4]
 800f600:	0a1b      	lsrs	r3, r3, #8
 800f602:	f003 12ff 	and.w	r2, r3, #16711935	@ 0xff00ff
 800f606:	687b      	ldr	r3, [r7, #4]
 800f608:	021b      	lsls	r3, r3, #8
 800f60a:	f003 23ff 	and.w	r3, r3, #4278255360	@ 0xff00ff00
 800f60e:	4313      	orrs	r3, r2
 800f610:	607b      	str	r3, [r7, #4]
    return rotlFixed(value, 16U);
 800f612:	2110      	movs	r1, #16
 800f614:	6878      	ldr	r0, [r7, #4]
 800f616:	f7ff ffdd 	bl	800f5d4 <rotlFixed>
 800f61a:	4603      	mov	r3, r0
}
 800f61c:	4618      	mov	r0, r3
 800f61e:	3708      	adds	r7, #8
 800f620:	46bd      	mov	sp, r7
 800f622:	bd80      	pop	{r7, pc}

0800f624 <ByteReverseWords>:
{
 800f624:	b590      	push	{r4, r7, lr}
 800f626:	b087      	sub	sp, #28
 800f628:	af00      	add	r7, sp, #0
 800f62a:	60f8      	str	r0, [r7, #12]
 800f62c:	60b9      	str	r1, [r7, #8]
 800f62e:	607a      	str	r2, [r7, #4]
        word32 count = byteCount/(word32)sizeof(word32);
 800f630:	687b      	ldr	r3, [r7, #4]
 800f632:	089b      	lsrs	r3, r3, #2
 800f634:	613b      	str	r3, [r7, #16]
        for (i = 0; i < count; i++)
 800f636:	2300      	movs	r3, #0
 800f638:	617b      	str	r3, [r7, #20]
 800f63a:	e010      	b.n	800f65e <ByteReverseWords+0x3a>
            out[i] = ByteReverseWord32(in[i]);
 800f63c:	697b      	ldr	r3, [r7, #20]
 800f63e:	009b      	lsls	r3, r3, #2
 800f640:	68ba      	ldr	r2, [r7, #8]
 800f642:	4413      	add	r3, r2
 800f644:	6819      	ldr	r1, [r3, #0]
 800f646:	697b      	ldr	r3, [r7, #20]
 800f648:	009b      	lsls	r3, r3, #2
 800f64a:	68fa      	ldr	r2, [r7, #12]
 800f64c:	18d4      	adds	r4, r2, r3
 800f64e:	4608      	mov	r0, r1
 800f650:	f7ff ffd1 	bl	800f5f6 <ByteReverseWord32>
 800f654:	4603      	mov	r3, r0
 800f656:	6023      	str	r3, [r4, #0]
        for (i = 0; i < count; i++)
 800f658:	697b      	ldr	r3, [r7, #20]
 800f65a:	3301      	adds	r3, #1
 800f65c:	617b      	str	r3, [r7, #20]
 800f65e:	697a      	ldr	r2, [r7, #20]
 800f660:	693b      	ldr	r3, [r7, #16]
 800f662:	429a      	cmp	r2, r3
 800f664:	d3ea      	bcc.n	800f63c <ByteReverseWords+0x18>
}
 800f666:	bf00      	nop
 800f668:	bf00      	nop
 800f66a:	371c      	adds	r7, #28
 800f66c:	46bd      	mov	sp, r7
 800f66e:	bd90      	pop	{r4, r7, pc}

0800f670 <XorWords>:
{
 800f670:	b480      	push	{r7}
 800f672:	b087      	sub	sp, #28
 800f674:	af00      	add	r7, sp, #0
 800f676:	60f8      	str	r0, [r7, #12]
 800f678:	60b9      	str	r1, [r7, #8]
 800f67a:	607a      	str	r2, [r7, #4]
    for (i = 0; i < n; i++)
 800f67c:	2300      	movs	r3, #0
 800f67e:	617b      	str	r3, [r7, #20]
 800f680:	e010      	b.n	800f6a4 <XorWords+0x34>
        *((*r)++) ^= *((*a)++);
 800f682:	68bb      	ldr	r3, [r7, #8]
 800f684:	681b      	ldr	r3, [r3, #0]
 800f686:	1d19      	adds	r1, r3, #4
 800f688:	68ba      	ldr	r2, [r7, #8]
 800f68a:	6011      	str	r1, [r2, #0]
 800f68c:	6819      	ldr	r1, [r3, #0]
 800f68e:	68fb      	ldr	r3, [r7, #12]
 800f690:	681b      	ldr	r3, [r3, #0]
 800f692:	1d18      	adds	r0, r3, #4
 800f694:	68fa      	ldr	r2, [r7, #12]
 800f696:	6010      	str	r0, [r2, #0]
 800f698:	681a      	ldr	r2, [r3, #0]
 800f69a:	404a      	eors	r2, r1
 800f69c:	601a      	str	r2, [r3, #0]
    for (i = 0; i < n; i++)
 800f69e:	697b      	ldr	r3, [r7, #20]
 800f6a0:	3301      	adds	r3, #1
 800f6a2:	617b      	str	r3, [r7, #20]
 800f6a4:	697a      	ldr	r2, [r7, #20]
 800f6a6:	687b      	ldr	r3, [r7, #4]
 800f6a8:	429a      	cmp	r2, r3
 800f6aa:	d3ea      	bcc.n	800f682 <XorWords+0x12>
}
 800f6ac:	bf00      	nop
 800f6ae:	bf00      	nop
 800f6b0:	371c      	adds	r7, #28
 800f6b2:	46bd      	mov	sp, r7
 800f6b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6b8:	4770      	bx	lr

0800f6ba <xorbuf>:
{
 800f6ba:	b580      	push	{r7, lr}
 800f6bc:	b08a      	sub	sp, #40	@ 0x28
 800f6be:	af00      	add	r7, sp, #0
 800f6c0:	60f8      	str	r0, [r7, #12]
 800f6c2:	60b9      	str	r1, [r7, #8]
 800f6c4:	607a      	str	r2, [r7, #4]
    b = (byte*)buf;
 800f6c6:	68fb      	ldr	r3, [r7, #12]
 800f6c8:	623b      	str	r3, [r7, #32]
    m = (const byte*)mask;
 800f6ca:	68bb      	ldr	r3, [r7, #8]
 800f6cc:	61fb      	str	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 800f6ce:	6a3a      	ldr	r2, [r7, #32]
            ((wc_ptr_t)m) % WOLFSSL_WORD_SIZE) {
 800f6d0:	69fb      	ldr	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 800f6d2:	4053      	eors	r3, r2
 800f6d4:	f003 0303 	and.w	r3, r3, #3
 800f6d8:	2b00      	cmp	r3, #0
 800f6da:	d12b      	bne.n	800f734 <xorbuf+0x7a>
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 800f6dc:	e00d      	b.n	800f6fa <xorbuf+0x40>
            *(b++) ^= *(m++);
 800f6de:	69fb      	ldr	r3, [r7, #28]
 800f6e0:	1c5a      	adds	r2, r3, #1
 800f6e2:	61fa      	str	r2, [r7, #28]
 800f6e4:	7819      	ldrb	r1, [r3, #0]
 800f6e6:	6a3b      	ldr	r3, [r7, #32]
 800f6e8:	1c5a      	adds	r2, r3, #1
 800f6ea:	623a      	str	r2, [r7, #32]
 800f6ec:	781a      	ldrb	r2, [r3, #0]
 800f6ee:	404a      	eors	r2, r1
 800f6f0:	b2d2      	uxtb	r2, r2
 800f6f2:	701a      	strb	r2, [r3, #0]
            count--;
 800f6f4:	687b      	ldr	r3, [r7, #4]
 800f6f6:	3b01      	subs	r3, #1
 800f6f8:	607b      	str	r3, [r7, #4]
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 800f6fa:	68fb      	ldr	r3, [r7, #12]
 800f6fc:	f003 0303 	and.w	r3, r3, #3
 800f700:	2b00      	cmp	r3, #0
 800f702:	d002      	beq.n	800f70a <xorbuf+0x50>
 800f704:	687b      	ldr	r3, [r7, #4]
 800f706:	2b00      	cmp	r3, #0
 800f708:	d1e9      	bne.n	800f6de <xorbuf+0x24>
        tpb.bp = b;
 800f70a:	6a3b      	ldr	r3, [r7, #32]
 800f70c:	61bb      	str	r3, [r7, #24]
        tpm.bp = m;
 800f70e:	69fb      	ldr	r3, [r7, #28]
 800f710:	617b      	str	r3, [r7, #20]
        XorWords( &tpb.wp, &tpm.wp, count / WOLFSSL_WORD_SIZE);
 800f712:	687b      	ldr	r3, [r7, #4]
 800f714:	089a      	lsrs	r2, r3, #2
 800f716:	f107 0114 	add.w	r1, r7, #20
 800f71a:	f107 0318 	add.w	r3, r7, #24
 800f71e:	4618      	mov	r0, r3
 800f720:	f7ff ffa6 	bl	800f670 <XorWords>
        b = tpb.bp;
 800f724:	69bb      	ldr	r3, [r7, #24]
 800f726:	623b      	str	r3, [r7, #32]
        m = tpm.bp;
 800f728:	697b      	ldr	r3, [r7, #20]
 800f72a:	61fb      	str	r3, [r7, #28]
        count %= WOLFSSL_WORD_SIZE;
 800f72c:	687b      	ldr	r3, [r7, #4]
 800f72e:	f003 0303 	and.w	r3, r3, #3
 800f732:	607b      	str	r3, [r7, #4]
    for (i = 0; i < count; i++)
 800f734:	2300      	movs	r3, #0
 800f736:	627b      	str	r3, [r7, #36]	@ 0x24
 800f738:	e010      	b.n	800f75c <xorbuf+0xa2>
        b[i] ^= m[i];
 800f73a:	6a3a      	ldr	r2, [r7, #32]
 800f73c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f73e:	4413      	add	r3, r2
 800f740:	7819      	ldrb	r1, [r3, #0]
 800f742:	69fa      	ldr	r2, [r7, #28]
 800f744:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f746:	4413      	add	r3, r2
 800f748:	781a      	ldrb	r2, [r3, #0]
 800f74a:	6a38      	ldr	r0, [r7, #32]
 800f74c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f74e:	4403      	add	r3, r0
 800f750:	404a      	eors	r2, r1
 800f752:	b2d2      	uxtb	r2, r2
 800f754:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < count; i++)
 800f756:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f758:	3301      	adds	r3, #1
 800f75a:	627b      	str	r3, [r7, #36]	@ 0x24
 800f75c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800f75e:	687b      	ldr	r3, [r7, #4]
 800f760:	429a      	cmp	r2, r3
 800f762:	d3ea      	bcc.n	800f73a <xorbuf+0x80>
}
 800f764:	bf00      	nop
 800f766:	bf00      	nop
 800f768:	3728      	adds	r7, #40	@ 0x28
 800f76a:	46bd      	mov	sp, r7
 800f76c:	bd80      	pop	{r7, pc}

0800f76e <ForceZero>:
{
 800f76e:	b480      	push	{r7}
 800f770:	b085      	sub	sp, #20
 800f772:	af00      	add	r7, sp, #0
 800f774:	6078      	str	r0, [r7, #4]
 800f776:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 800f778:	687b      	ldr	r3, [r7, #4]
 800f77a:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 800f77c:	e004      	b.n	800f788 <ForceZero+0x1a>
 800f77e:	68fb      	ldr	r3, [r7, #12]
 800f780:	1c5a      	adds	r2, r3, #1
 800f782:	60fa      	str	r2, [r7, #12]
 800f784:	2200      	movs	r2, #0
 800f786:	701a      	strb	r2, [r3, #0]
 800f788:	683b      	ldr	r3, [r7, #0]
 800f78a:	1e5a      	subs	r2, r3, #1
 800f78c:	603a      	str	r2, [r7, #0]
 800f78e:	2b00      	cmp	r3, #0
 800f790:	d1f5      	bne.n	800f77e <ForceZero+0x10>
}
 800f792:	bf00      	nop
 800f794:	bf00      	nop
 800f796:	3714      	adds	r7, #20
 800f798:	46bd      	mov	sp, r7
 800f79a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f79e:	4770      	bx	lr

0800f7a0 <PreFetchTe>:
#endif

#ifndef WOLFSSL_AES_SMALL_TABLES
/* load 4 Te Tables into cache by cache line stride */
static WARN_UNUSED_RESULT WC_INLINE word32 PreFetchTe(void)
{
 800f7a0:	b480      	push	{r7}
 800f7a2:	b085      	sub	sp, #20
 800f7a4:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_AES_TOUCH_LINES
    word32 x = 0;
 800f7a6:	2300      	movs	r3, #0
 800f7a8:	60fb      	str	r3, [r7, #12]
    int i,j;

    for (i = 0; i < 4; i++) {
 800f7aa:	2300      	movs	r3, #0
 800f7ac:	60bb      	str	r3, [r7, #8]
 800f7ae:	e015      	b.n	800f7dc <PreFetchTe+0x3c>
        /* 256 elements, each one is 4 bytes */
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 800f7b0:	2300      	movs	r3, #0
 800f7b2:	607b      	str	r3, [r7, #4]
 800f7b4:	e00c      	b.n	800f7d0 <PreFetchTe+0x30>
            x &= Te[i][j];
 800f7b6:	490e      	ldr	r1, [pc, #56]	@ (800f7f0 <PreFetchTe+0x50>)
 800f7b8:	68bb      	ldr	r3, [r7, #8]
 800f7ba:	021a      	lsls	r2, r3, #8
 800f7bc:	687b      	ldr	r3, [r7, #4]
 800f7be:	4413      	add	r3, r2
 800f7c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f7c4:	68fa      	ldr	r2, [r7, #12]
 800f7c6:	4013      	ands	r3, r2
 800f7c8:	60fb      	str	r3, [r7, #12]
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 800f7ca:	687b      	ldr	r3, [r7, #4]
 800f7cc:	3308      	adds	r3, #8
 800f7ce:	607b      	str	r3, [r7, #4]
 800f7d0:	687b      	ldr	r3, [r7, #4]
 800f7d2:	2bff      	cmp	r3, #255	@ 0xff
 800f7d4:	ddef      	ble.n	800f7b6 <PreFetchTe+0x16>
    for (i = 0; i < 4; i++) {
 800f7d6:	68bb      	ldr	r3, [r7, #8]
 800f7d8:	3301      	adds	r3, #1
 800f7da:	60bb      	str	r3, [r7, #8]
 800f7dc:	68bb      	ldr	r3, [r7, #8]
 800f7de:	2b03      	cmp	r3, #3
 800f7e0:	dde6      	ble.n	800f7b0 <PreFetchTe+0x10>
        }
    }
    return x;
 800f7e2:	68fb      	ldr	r3, [r7, #12]
#else
    return 0;
#endif
}
 800f7e4:	4618      	mov	r0, r3
 800f7e6:	3714      	adds	r7, #20
 800f7e8:	46bd      	mov	sp, r7
 800f7ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f7ee:	4770      	bx	lr
 800f7f0:	08031328 	.word	0x08031328

0800f7f4 <AesEncrypt_C>:
 * @param [out] outBlock  Encrypted block.
 * @param [in]  r         Rounds divided by 2.
 */
static void AesEncrypt_C(Aes* aes, const byte* inBlock, byte* outBlock,
        word32 r)
{
 800f7f4:	b580      	push	{r7, lr}
 800f7f6:	b08e      	sub	sp, #56	@ 0x38
 800f7f8:	af00      	add	r7, sp, #0
 800f7fa:	60f8      	str	r0, [r7, #12]
 800f7fc:	60b9      	str	r1, [r7, #8]
 800f7fe:	607a      	str	r2, [r7, #4]
 800f800:	603b      	str	r3, [r7, #0]
    const word32* rk;

#ifdef WC_C_DYNAMIC_FALLBACK
    rk = aes->key_C_fallback;
#else
    rk = aes->key;
 800f802:	68fb      	ldr	r3, [r7, #12]
 800f804:	627b      	str	r3, [r7, #36]	@ 0x24

    /*
     * map byte array block to cipher state
     * and add initial round key:
     */
    XMEMCPY(&s0, inBlock,                  sizeof(s0));
 800f806:	68bb      	ldr	r3, [r7, #8]
 800f808:	681b      	ldr	r3, [r3, #0]
 800f80a:	623b      	str	r3, [r7, #32]
    XMEMCPY(&s1, inBlock +     sizeof(s0), sizeof(s1));
 800f80c:	68bb      	ldr	r3, [r7, #8]
 800f80e:	3304      	adds	r3, #4
 800f810:	681b      	ldr	r3, [r3, #0]
 800f812:	61fb      	str	r3, [r7, #28]
    XMEMCPY(&s2, inBlock + 2 * sizeof(s0), sizeof(s2));
 800f814:	68bb      	ldr	r3, [r7, #8]
 800f816:	3308      	adds	r3, #8
 800f818:	681b      	ldr	r3, [r3, #0]
 800f81a:	61bb      	str	r3, [r7, #24]
    XMEMCPY(&s3, inBlock + 3 * sizeof(s0), sizeof(s3));
 800f81c:	68bb      	ldr	r3, [r7, #8]
 800f81e:	330c      	adds	r3, #12
 800f820:	681b      	ldr	r3, [r3, #0]
 800f822:	617b      	str	r3, [r7, #20]

#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 800f824:	6a3b      	ldr	r3, [r7, #32]
 800f826:	4618      	mov	r0, r3
 800f828:	f7ff fee5 	bl	800f5f6 <ByteReverseWord32>
 800f82c:	4603      	mov	r3, r0
 800f82e:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 800f830:	69fb      	ldr	r3, [r7, #28]
 800f832:	4618      	mov	r0, r3
 800f834:	f7ff fedf 	bl	800f5f6 <ByteReverseWord32>
 800f838:	4603      	mov	r3, r0
 800f83a:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 800f83c:	69bb      	ldr	r3, [r7, #24]
 800f83e:	4618      	mov	r0, r3
 800f840:	f7ff fed9 	bl	800f5f6 <ByteReverseWord32>
 800f844:	4603      	mov	r3, r0
 800f846:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 800f848:	697b      	ldr	r3, [r7, #20]
 800f84a:	4618      	mov	r0, r3
 800f84c:	f7ff fed3 	bl	800f5f6 <ByteReverseWord32>
 800f850:	4603      	mov	r3, r0
 800f852:	617b      	str	r3, [r7, #20]
#endif

    /* AddRoundKey */
    s0 ^= rk[0];
 800f854:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f856:	681a      	ldr	r2, [r3, #0]
 800f858:	6a3b      	ldr	r3, [r7, #32]
 800f85a:	4053      	eors	r3, r2
 800f85c:	623b      	str	r3, [r7, #32]
    s1 ^= rk[1];
 800f85e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f860:	3304      	adds	r3, #4
 800f862:	681a      	ldr	r2, [r3, #0]
 800f864:	69fb      	ldr	r3, [r7, #28]
 800f866:	4053      	eors	r3, r2
 800f868:	61fb      	str	r3, [r7, #28]
    s2 ^= rk[2];
 800f86a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f86c:	3308      	adds	r3, #8
 800f86e:	681a      	ldr	r2, [r3, #0]
 800f870:	69bb      	ldr	r3, [r7, #24]
 800f872:	4053      	eors	r3, r2
 800f874:	61bb      	str	r3, [r7, #24]
    s3 ^= rk[3];
 800f876:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f878:	330c      	adds	r3, #12
 800f87a:	681a      	ldr	r2, [r3, #0]
 800f87c:	697b      	ldr	r3, [r7, #20]
 800f87e:	4053      	eors	r3, r2
 800f880:	617b      	str	r3, [r7, #20]

#ifndef WOLFSSL_AES_SMALL_TABLES
#ifndef WC_NO_CACHE_RESISTANT
    s0 |= PreFetchTe();
 800f882:	f7ff ff8d 	bl	800f7a0 <PreFetchTe>
 800f886:	4602      	mov	r2, r0
 800f888:	6a3b      	ldr	r3, [r7, #32]
 800f88a:	4313      	orrs	r3, r2
 800f88c:	623b      	str	r3, [r7, #32]
    s0 ^= rk[(o)+0]; s1 ^= rk[(o)+1]; s2 ^= rk[(o)+2]; s3 ^= rk[(o)+3];
#endif

#ifndef WOLFSSL_AES_NO_UNROLL
/* Unroll the loop. */
                       ENC_ROUND_T_S( 0);
 800f88e:	6a3b      	ldr	r3, [r7, #32]
 800f890:	0e1b      	lsrs	r3, r3, #24
 800f892:	b2db      	uxtb	r3, r3
 800f894:	461a      	mov	r2, r3
 800f896:	4bb6      	ldr	r3, [pc, #728]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f898:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800f89c:	69fb      	ldr	r3, [r7, #28]
 800f89e:	0c1b      	lsrs	r3, r3, #16
 800f8a0:	b2db      	uxtb	r3, r3
 800f8a2:	49b3      	ldr	r1, [pc, #716]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f8a4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800f8a8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f8ac:	405a      	eors	r2, r3
 800f8ae:	69bb      	ldr	r3, [r7, #24]
 800f8b0:	0a1b      	lsrs	r3, r3, #8
 800f8b2:	b2db      	uxtb	r3, r3
 800f8b4:	49ae      	ldr	r1, [pc, #696]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f8b6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800f8ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f8be:	405a      	eors	r2, r3
 800f8c0:	697b      	ldr	r3, [r7, #20]
 800f8c2:	b2db      	uxtb	r3, r3
 800f8c4:	49aa      	ldr	r1, [pc, #680]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f8c6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800f8ca:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f8ce:	405a      	eors	r2, r3
 800f8d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f8d2:	3310      	adds	r3, #16
 800f8d4:	681b      	ldr	r3, [r3, #0]
 800f8d6:	4053      	eors	r3, r2
 800f8d8:	637b      	str	r3, [r7, #52]	@ 0x34
 800f8da:	69fb      	ldr	r3, [r7, #28]
 800f8dc:	0e1b      	lsrs	r3, r3, #24
 800f8de:	b2db      	uxtb	r3, r3
 800f8e0:	461a      	mov	r2, r3
 800f8e2:	4ba3      	ldr	r3, [pc, #652]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f8e4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800f8e8:	69bb      	ldr	r3, [r7, #24]
 800f8ea:	0c1b      	lsrs	r3, r3, #16
 800f8ec:	b2db      	uxtb	r3, r3
 800f8ee:	49a0      	ldr	r1, [pc, #640]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f8f0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800f8f4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f8f8:	405a      	eors	r2, r3
 800f8fa:	697b      	ldr	r3, [r7, #20]
 800f8fc:	0a1b      	lsrs	r3, r3, #8
 800f8fe:	b2db      	uxtb	r3, r3
 800f900:	499b      	ldr	r1, [pc, #620]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f902:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800f906:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f90a:	405a      	eors	r2, r3
 800f90c:	6a3b      	ldr	r3, [r7, #32]
 800f90e:	b2db      	uxtb	r3, r3
 800f910:	4997      	ldr	r1, [pc, #604]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f912:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800f916:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f91a:	405a      	eors	r2, r3
 800f91c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f91e:	3314      	adds	r3, #20
 800f920:	681b      	ldr	r3, [r3, #0]
 800f922:	4053      	eors	r3, r2
 800f924:	633b      	str	r3, [r7, #48]	@ 0x30
 800f926:	69bb      	ldr	r3, [r7, #24]
 800f928:	0e1b      	lsrs	r3, r3, #24
 800f92a:	b2db      	uxtb	r3, r3
 800f92c:	461a      	mov	r2, r3
 800f92e:	4b90      	ldr	r3, [pc, #576]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f930:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800f934:	697b      	ldr	r3, [r7, #20]
 800f936:	0c1b      	lsrs	r3, r3, #16
 800f938:	b2db      	uxtb	r3, r3
 800f93a:	498d      	ldr	r1, [pc, #564]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f93c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800f940:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f944:	405a      	eors	r2, r3
 800f946:	6a3b      	ldr	r3, [r7, #32]
 800f948:	0a1b      	lsrs	r3, r3, #8
 800f94a:	b2db      	uxtb	r3, r3
 800f94c:	4988      	ldr	r1, [pc, #544]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f94e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800f952:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f956:	405a      	eors	r2, r3
 800f958:	69fb      	ldr	r3, [r7, #28]
 800f95a:	b2db      	uxtb	r3, r3
 800f95c:	4984      	ldr	r1, [pc, #528]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f95e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800f962:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f966:	405a      	eors	r2, r3
 800f968:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f96a:	3318      	adds	r3, #24
 800f96c:	681b      	ldr	r3, [r3, #0]
 800f96e:	4053      	eors	r3, r2
 800f970:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800f972:	697b      	ldr	r3, [r7, #20]
 800f974:	0e1b      	lsrs	r3, r3, #24
 800f976:	b2db      	uxtb	r3, r3
 800f978:	461a      	mov	r2, r3
 800f97a:	4b7d      	ldr	r3, [pc, #500]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f97c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800f980:	6a3b      	ldr	r3, [r7, #32]
 800f982:	0c1b      	lsrs	r3, r3, #16
 800f984:	b2db      	uxtb	r3, r3
 800f986:	497a      	ldr	r1, [pc, #488]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f988:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800f98c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f990:	405a      	eors	r2, r3
 800f992:	69fb      	ldr	r3, [r7, #28]
 800f994:	0a1b      	lsrs	r3, r3, #8
 800f996:	b2db      	uxtb	r3, r3
 800f998:	4975      	ldr	r1, [pc, #468]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f99a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800f99e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f9a2:	405a      	eors	r2, r3
 800f9a4:	69bb      	ldr	r3, [r7, #24]
 800f9a6:	b2db      	uxtb	r3, r3
 800f9a8:	4971      	ldr	r1, [pc, #452]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f9aa:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800f9ae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f9b2:	405a      	eors	r2, r3
 800f9b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f9b6:	331c      	adds	r3, #28
 800f9b8:	681b      	ldr	r3, [r3, #0]
 800f9ba:	4053      	eors	r3, r2
 800f9bc:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T( 8); ENC_ROUND_T_S( 8);
 800f9be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9c0:	0e1b      	lsrs	r3, r3, #24
 800f9c2:	b2db      	uxtb	r3, r3
 800f9c4:	461a      	mov	r2, r3
 800f9c6:	4b6a      	ldr	r3, [pc, #424]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f9c8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800f9cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f9ce:	0c1b      	lsrs	r3, r3, #16
 800f9d0:	b2db      	uxtb	r3, r3
 800f9d2:	4967      	ldr	r1, [pc, #412]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f9d4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800f9d8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f9dc:	405a      	eors	r2, r3
 800f9de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f9e0:	0a1b      	lsrs	r3, r3, #8
 800f9e2:	b2db      	uxtb	r3, r3
 800f9e4:	4962      	ldr	r1, [pc, #392]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f9e6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800f9ea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f9ee:	405a      	eors	r2, r3
 800f9f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f9f2:	b2db      	uxtb	r3, r3
 800f9f4:	495e      	ldr	r1, [pc, #376]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800f9f6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800f9fa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f9fe:	405a      	eors	r2, r3
 800fa00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fa02:	3320      	adds	r3, #32
 800fa04:	681b      	ldr	r3, [r3, #0]
 800fa06:	4053      	eors	r3, r2
 800fa08:	623b      	str	r3, [r7, #32]
 800fa0a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fa0c:	0e1b      	lsrs	r3, r3, #24
 800fa0e:	b2db      	uxtb	r3, r3
 800fa10:	461a      	mov	r2, r3
 800fa12:	4b57      	ldr	r3, [pc, #348]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fa14:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fa18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fa1a:	0c1b      	lsrs	r3, r3, #16
 800fa1c:	b2db      	uxtb	r3, r3
 800fa1e:	4954      	ldr	r1, [pc, #336]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fa20:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fa24:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa28:	405a      	eors	r2, r3
 800fa2a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fa2c:	0a1b      	lsrs	r3, r3, #8
 800fa2e:	b2db      	uxtb	r3, r3
 800fa30:	494f      	ldr	r1, [pc, #316]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fa32:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fa36:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa3a:	405a      	eors	r2, r3
 800fa3c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa3e:	b2db      	uxtb	r3, r3
 800fa40:	494b      	ldr	r1, [pc, #300]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fa42:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fa46:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa4a:	405a      	eors	r2, r3
 800fa4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fa4e:	3324      	adds	r3, #36	@ 0x24
 800fa50:	681b      	ldr	r3, [r3, #0]
 800fa52:	4053      	eors	r3, r2
 800fa54:	61fb      	str	r3, [r7, #28]
 800fa56:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fa58:	0e1b      	lsrs	r3, r3, #24
 800fa5a:	b2db      	uxtb	r3, r3
 800fa5c:	461a      	mov	r2, r3
 800fa5e:	4b44      	ldr	r3, [pc, #272]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fa60:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fa64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fa66:	0c1b      	lsrs	r3, r3, #16
 800fa68:	b2db      	uxtb	r3, r3
 800fa6a:	4941      	ldr	r1, [pc, #260]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fa6c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fa70:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa74:	405a      	eors	r2, r3
 800fa76:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa78:	0a1b      	lsrs	r3, r3, #8
 800fa7a:	b2db      	uxtb	r3, r3
 800fa7c:	493c      	ldr	r1, [pc, #240]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fa7e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fa82:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa86:	405a      	eors	r2, r3
 800fa88:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fa8a:	b2db      	uxtb	r3, r3
 800fa8c:	4938      	ldr	r1, [pc, #224]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fa8e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fa92:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fa96:	405a      	eors	r2, r3
 800fa98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fa9a:	3328      	adds	r3, #40	@ 0x28
 800fa9c:	681b      	ldr	r3, [r3, #0]
 800fa9e:	4053      	eors	r3, r2
 800faa0:	61bb      	str	r3, [r7, #24]
 800faa2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800faa4:	0e1b      	lsrs	r3, r3, #24
 800faa6:	b2db      	uxtb	r3, r3
 800faa8:	461a      	mov	r2, r3
 800faaa:	4b31      	ldr	r3, [pc, #196]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800faac:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fab0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fab2:	0c1b      	lsrs	r3, r3, #16
 800fab4:	b2db      	uxtb	r3, r3
 800fab6:	492e      	ldr	r1, [pc, #184]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fab8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fabc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fac0:	405a      	eors	r2, r3
 800fac2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fac4:	0a1b      	lsrs	r3, r3, #8
 800fac6:	b2db      	uxtb	r3, r3
 800fac8:	4929      	ldr	r1, [pc, #164]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800faca:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800face:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fad2:	405a      	eors	r2, r3
 800fad4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fad6:	b2db      	uxtb	r3, r3
 800fad8:	4925      	ldr	r1, [pc, #148]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fada:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fade:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fae2:	405a      	eors	r2, r3
 800fae4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fae6:	332c      	adds	r3, #44	@ 0x2c
 800fae8:	681b      	ldr	r3, [r3, #0]
 800faea:	4053      	eors	r3, r2
 800faec:	617b      	str	r3, [r7, #20]
 800faee:	6a3b      	ldr	r3, [r7, #32]
 800faf0:	0e1b      	lsrs	r3, r3, #24
 800faf2:	b2db      	uxtb	r3, r3
 800faf4:	461a      	mov	r2, r3
 800faf6:	4b1e      	ldr	r3, [pc, #120]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800faf8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fafc:	69fb      	ldr	r3, [r7, #28]
 800fafe:	0c1b      	lsrs	r3, r3, #16
 800fb00:	b2db      	uxtb	r3, r3
 800fb02:	491b      	ldr	r1, [pc, #108]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fb04:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fb08:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb0c:	405a      	eors	r2, r3
 800fb0e:	69bb      	ldr	r3, [r7, #24]
 800fb10:	0a1b      	lsrs	r3, r3, #8
 800fb12:	b2db      	uxtb	r3, r3
 800fb14:	4916      	ldr	r1, [pc, #88]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fb16:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fb1a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb1e:	405a      	eors	r2, r3
 800fb20:	697b      	ldr	r3, [r7, #20]
 800fb22:	b2db      	uxtb	r3, r3
 800fb24:	4912      	ldr	r1, [pc, #72]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fb26:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fb2a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb2e:	405a      	eors	r2, r3
 800fb30:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fb32:	3330      	adds	r3, #48	@ 0x30
 800fb34:	681b      	ldr	r3, [r3, #0]
 800fb36:	4053      	eors	r3, r2
 800fb38:	637b      	str	r3, [r7, #52]	@ 0x34
 800fb3a:	69fb      	ldr	r3, [r7, #28]
 800fb3c:	0e1b      	lsrs	r3, r3, #24
 800fb3e:	b2db      	uxtb	r3, r3
 800fb40:	461a      	mov	r2, r3
 800fb42:	4b0b      	ldr	r3, [pc, #44]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fb44:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fb48:	69bb      	ldr	r3, [r7, #24]
 800fb4a:	0c1b      	lsrs	r3, r3, #16
 800fb4c:	b2db      	uxtb	r3, r3
 800fb4e:	4908      	ldr	r1, [pc, #32]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fb50:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fb54:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb58:	405a      	eors	r2, r3
 800fb5a:	697b      	ldr	r3, [r7, #20]
 800fb5c:	0a1b      	lsrs	r3, r3, #8
 800fb5e:	b2db      	uxtb	r3, r3
 800fb60:	4903      	ldr	r1, [pc, #12]	@ (800fb70 <AesEncrypt_C+0x37c>)
 800fb62:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fb66:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb6a:	405a      	eors	r2, r3
 800fb6c:	6a3b      	ldr	r3, [r7, #32]
 800fb6e:	e001      	b.n	800fb74 <AesEncrypt_C+0x380>
 800fb70:	08031328 	.word	0x08031328
 800fb74:	b2db      	uxtb	r3, r3
 800fb76:	49b6      	ldr	r1, [pc, #728]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fb78:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fb7c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fb80:	405a      	eors	r2, r3
 800fb82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fb84:	3334      	adds	r3, #52	@ 0x34
 800fb86:	681b      	ldr	r3, [r3, #0]
 800fb88:	4053      	eors	r3, r2
 800fb8a:	633b      	str	r3, [r7, #48]	@ 0x30
 800fb8c:	69bb      	ldr	r3, [r7, #24]
 800fb8e:	0e1b      	lsrs	r3, r3, #24
 800fb90:	b2db      	uxtb	r3, r3
 800fb92:	461a      	mov	r2, r3
 800fb94:	4bae      	ldr	r3, [pc, #696]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fb96:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fb9a:	697b      	ldr	r3, [r7, #20]
 800fb9c:	0c1b      	lsrs	r3, r3, #16
 800fb9e:	b2db      	uxtb	r3, r3
 800fba0:	49ab      	ldr	r1, [pc, #684]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fba2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fba6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbaa:	405a      	eors	r2, r3
 800fbac:	6a3b      	ldr	r3, [r7, #32]
 800fbae:	0a1b      	lsrs	r3, r3, #8
 800fbb0:	b2db      	uxtb	r3, r3
 800fbb2:	49a7      	ldr	r1, [pc, #668]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fbb4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fbb8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbbc:	405a      	eors	r2, r3
 800fbbe:	69fb      	ldr	r3, [r7, #28]
 800fbc0:	b2db      	uxtb	r3, r3
 800fbc2:	49a3      	ldr	r1, [pc, #652]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fbc4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fbc8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbcc:	405a      	eors	r2, r3
 800fbce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fbd0:	3338      	adds	r3, #56	@ 0x38
 800fbd2:	681b      	ldr	r3, [r3, #0]
 800fbd4:	4053      	eors	r3, r2
 800fbd6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800fbd8:	697b      	ldr	r3, [r7, #20]
 800fbda:	0e1b      	lsrs	r3, r3, #24
 800fbdc:	b2db      	uxtb	r3, r3
 800fbde:	461a      	mov	r2, r3
 800fbe0:	4b9b      	ldr	r3, [pc, #620]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fbe2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fbe6:	6a3b      	ldr	r3, [r7, #32]
 800fbe8:	0c1b      	lsrs	r3, r3, #16
 800fbea:	b2db      	uxtb	r3, r3
 800fbec:	4998      	ldr	r1, [pc, #608]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fbee:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fbf2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fbf6:	405a      	eors	r2, r3
 800fbf8:	69fb      	ldr	r3, [r7, #28]
 800fbfa:	0a1b      	lsrs	r3, r3, #8
 800fbfc:	b2db      	uxtb	r3, r3
 800fbfe:	4994      	ldr	r1, [pc, #592]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fc00:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fc04:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc08:	405a      	eors	r2, r3
 800fc0a:	69bb      	ldr	r3, [r7, #24]
 800fc0c:	b2db      	uxtb	r3, r3
 800fc0e:	4990      	ldr	r1, [pc, #576]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fc10:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fc14:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc18:	405a      	eors	r2, r3
 800fc1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fc1c:	333c      	adds	r3, #60	@ 0x3c
 800fc1e:	681b      	ldr	r3, [r3, #0]
 800fc20:	4053      	eors	r3, r2
 800fc22:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T(16); ENC_ROUND_T_S(16);
 800fc24:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc26:	0e1b      	lsrs	r3, r3, #24
 800fc28:	b2db      	uxtb	r3, r3
 800fc2a:	461a      	mov	r2, r3
 800fc2c:	4b88      	ldr	r3, [pc, #544]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fc2e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fc32:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fc34:	0c1b      	lsrs	r3, r3, #16
 800fc36:	b2db      	uxtb	r3, r3
 800fc38:	4985      	ldr	r1, [pc, #532]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fc3a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fc3e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc42:	405a      	eors	r2, r3
 800fc44:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fc46:	0a1b      	lsrs	r3, r3, #8
 800fc48:	b2db      	uxtb	r3, r3
 800fc4a:	4981      	ldr	r1, [pc, #516]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fc4c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fc50:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc54:	405a      	eors	r2, r3
 800fc56:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fc58:	b2db      	uxtb	r3, r3
 800fc5a:	497d      	ldr	r1, [pc, #500]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fc5c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fc60:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc64:	405a      	eors	r2, r3
 800fc66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fc68:	3340      	adds	r3, #64	@ 0x40
 800fc6a:	681b      	ldr	r3, [r3, #0]
 800fc6c:	4053      	eors	r3, r2
 800fc6e:	623b      	str	r3, [r7, #32]
 800fc70:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fc72:	0e1b      	lsrs	r3, r3, #24
 800fc74:	b2db      	uxtb	r3, r3
 800fc76:	461a      	mov	r2, r3
 800fc78:	4b75      	ldr	r3, [pc, #468]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fc7a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fc7e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fc80:	0c1b      	lsrs	r3, r3, #16
 800fc82:	b2db      	uxtb	r3, r3
 800fc84:	4972      	ldr	r1, [pc, #456]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fc86:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fc8a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fc8e:	405a      	eors	r2, r3
 800fc90:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fc92:	0a1b      	lsrs	r3, r3, #8
 800fc94:	b2db      	uxtb	r3, r3
 800fc96:	496e      	ldr	r1, [pc, #440]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fc98:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fc9c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fca0:	405a      	eors	r2, r3
 800fca2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fca4:	b2db      	uxtb	r3, r3
 800fca6:	496a      	ldr	r1, [pc, #424]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fca8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fcac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fcb0:	405a      	eors	r2, r3
 800fcb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fcb4:	3344      	adds	r3, #68	@ 0x44
 800fcb6:	681b      	ldr	r3, [r3, #0]
 800fcb8:	4053      	eors	r3, r2
 800fcba:	61fb      	str	r3, [r7, #28]
 800fcbc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fcbe:	0e1b      	lsrs	r3, r3, #24
 800fcc0:	b2db      	uxtb	r3, r3
 800fcc2:	461a      	mov	r2, r3
 800fcc4:	4b62      	ldr	r3, [pc, #392]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fcc6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fcca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fccc:	0c1b      	lsrs	r3, r3, #16
 800fcce:	b2db      	uxtb	r3, r3
 800fcd0:	495f      	ldr	r1, [pc, #380]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fcd2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fcd6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fcda:	405a      	eors	r2, r3
 800fcdc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fcde:	0a1b      	lsrs	r3, r3, #8
 800fce0:	b2db      	uxtb	r3, r3
 800fce2:	495b      	ldr	r1, [pc, #364]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fce4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fce8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fcec:	405a      	eors	r2, r3
 800fcee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fcf0:	b2db      	uxtb	r3, r3
 800fcf2:	4957      	ldr	r1, [pc, #348]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fcf4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fcf8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fcfc:	405a      	eors	r2, r3
 800fcfe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fd00:	3348      	adds	r3, #72	@ 0x48
 800fd02:	681b      	ldr	r3, [r3, #0]
 800fd04:	4053      	eors	r3, r2
 800fd06:	61bb      	str	r3, [r7, #24]
 800fd08:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fd0a:	0e1b      	lsrs	r3, r3, #24
 800fd0c:	b2db      	uxtb	r3, r3
 800fd0e:	461a      	mov	r2, r3
 800fd10:	4b4f      	ldr	r3, [pc, #316]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fd12:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fd16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fd18:	0c1b      	lsrs	r3, r3, #16
 800fd1a:	b2db      	uxtb	r3, r3
 800fd1c:	494c      	ldr	r1, [pc, #304]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fd1e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fd22:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd26:	405a      	eors	r2, r3
 800fd28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fd2a:	0a1b      	lsrs	r3, r3, #8
 800fd2c:	b2db      	uxtb	r3, r3
 800fd2e:	4948      	ldr	r1, [pc, #288]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fd30:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fd34:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd38:	405a      	eors	r2, r3
 800fd3a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fd3c:	b2db      	uxtb	r3, r3
 800fd3e:	4944      	ldr	r1, [pc, #272]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fd40:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fd44:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd48:	405a      	eors	r2, r3
 800fd4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fd4c:	334c      	adds	r3, #76	@ 0x4c
 800fd4e:	681b      	ldr	r3, [r3, #0]
 800fd50:	4053      	eors	r3, r2
 800fd52:	617b      	str	r3, [r7, #20]
 800fd54:	6a3b      	ldr	r3, [r7, #32]
 800fd56:	0e1b      	lsrs	r3, r3, #24
 800fd58:	b2db      	uxtb	r3, r3
 800fd5a:	461a      	mov	r2, r3
 800fd5c:	4b3c      	ldr	r3, [pc, #240]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fd5e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fd62:	69fb      	ldr	r3, [r7, #28]
 800fd64:	0c1b      	lsrs	r3, r3, #16
 800fd66:	b2db      	uxtb	r3, r3
 800fd68:	4939      	ldr	r1, [pc, #228]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fd6a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fd6e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd72:	405a      	eors	r2, r3
 800fd74:	69bb      	ldr	r3, [r7, #24]
 800fd76:	0a1b      	lsrs	r3, r3, #8
 800fd78:	b2db      	uxtb	r3, r3
 800fd7a:	4935      	ldr	r1, [pc, #212]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fd7c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fd80:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd84:	405a      	eors	r2, r3
 800fd86:	697b      	ldr	r3, [r7, #20]
 800fd88:	b2db      	uxtb	r3, r3
 800fd8a:	4931      	ldr	r1, [pc, #196]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fd8c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fd90:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fd94:	405a      	eors	r2, r3
 800fd96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fd98:	3350      	adds	r3, #80	@ 0x50
 800fd9a:	681b      	ldr	r3, [r3, #0]
 800fd9c:	4053      	eors	r3, r2
 800fd9e:	637b      	str	r3, [r7, #52]	@ 0x34
 800fda0:	69fb      	ldr	r3, [r7, #28]
 800fda2:	0e1b      	lsrs	r3, r3, #24
 800fda4:	b2db      	uxtb	r3, r3
 800fda6:	461a      	mov	r2, r3
 800fda8:	4b29      	ldr	r3, [pc, #164]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fdaa:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fdae:	69bb      	ldr	r3, [r7, #24]
 800fdb0:	0c1b      	lsrs	r3, r3, #16
 800fdb2:	b2db      	uxtb	r3, r3
 800fdb4:	4926      	ldr	r1, [pc, #152]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fdb6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fdba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fdbe:	405a      	eors	r2, r3
 800fdc0:	697b      	ldr	r3, [r7, #20]
 800fdc2:	0a1b      	lsrs	r3, r3, #8
 800fdc4:	b2db      	uxtb	r3, r3
 800fdc6:	4922      	ldr	r1, [pc, #136]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fdc8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fdcc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fdd0:	405a      	eors	r2, r3
 800fdd2:	6a3b      	ldr	r3, [r7, #32]
 800fdd4:	b2db      	uxtb	r3, r3
 800fdd6:	491e      	ldr	r1, [pc, #120]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fdd8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fddc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fde0:	405a      	eors	r2, r3
 800fde2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fde4:	3354      	adds	r3, #84	@ 0x54
 800fde6:	681b      	ldr	r3, [r3, #0]
 800fde8:	4053      	eors	r3, r2
 800fdea:	633b      	str	r3, [r7, #48]	@ 0x30
 800fdec:	69bb      	ldr	r3, [r7, #24]
 800fdee:	0e1b      	lsrs	r3, r3, #24
 800fdf0:	b2db      	uxtb	r3, r3
 800fdf2:	461a      	mov	r2, r3
 800fdf4:	4b16      	ldr	r3, [pc, #88]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fdf6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fdfa:	697b      	ldr	r3, [r7, #20]
 800fdfc:	0c1b      	lsrs	r3, r3, #16
 800fdfe:	b2db      	uxtb	r3, r3
 800fe00:	4913      	ldr	r1, [pc, #76]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fe02:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe06:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe0a:	405a      	eors	r2, r3
 800fe0c:	6a3b      	ldr	r3, [r7, #32]
 800fe0e:	0a1b      	lsrs	r3, r3, #8
 800fe10:	b2db      	uxtb	r3, r3
 800fe12:	490f      	ldr	r1, [pc, #60]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fe14:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fe18:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe1c:	405a      	eors	r2, r3
 800fe1e:	69fb      	ldr	r3, [r7, #28]
 800fe20:	b2db      	uxtb	r3, r3
 800fe22:	490b      	ldr	r1, [pc, #44]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fe24:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fe28:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe2c:	405a      	eors	r2, r3
 800fe2e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fe30:	3358      	adds	r3, #88	@ 0x58
 800fe32:	681b      	ldr	r3, [r3, #0]
 800fe34:	4053      	eors	r3, r2
 800fe36:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800fe38:	697b      	ldr	r3, [r7, #20]
 800fe3a:	0e1b      	lsrs	r3, r3, #24
 800fe3c:	b2db      	uxtb	r3, r3
 800fe3e:	461a      	mov	r2, r3
 800fe40:	4b03      	ldr	r3, [pc, #12]	@ (800fe50 <AesEncrypt_C+0x65c>)
 800fe42:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fe46:	6a3b      	ldr	r3, [r7, #32]
 800fe48:	0c1b      	lsrs	r3, r3, #16
 800fe4a:	b2db      	uxtb	r3, r3
 800fe4c:	e002      	b.n	800fe54 <AesEncrypt_C+0x660>
 800fe4e:	bf00      	nop
 800fe50:	08031328 	.word	0x08031328
 800fe54:	49b6      	ldr	r1, [pc, #728]	@ (8010130 <AesEncrypt_C+0x93c>)
 800fe56:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe5a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe5e:	405a      	eors	r2, r3
 800fe60:	69fb      	ldr	r3, [r7, #28]
 800fe62:	0a1b      	lsrs	r3, r3, #8
 800fe64:	b2db      	uxtb	r3, r3
 800fe66:	49b2      	ldr	r1, [pc, #712]	@ (8010130 <AesEncrypt_C+0x93c>)
 800fe68:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800fe6c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe70:	405a      	eors	r2, r3
 800fe72:	69bb      	ldr	r3, [r7, #24]
 800fe74:	b2db      	uxtb	r3, r3
 800fe76:	49ae      	ldr	r1, [pc, #696]	@ (8010130 <AesEncrypt_C+0x93c>)
 800fe78:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fe7c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fe80:	405a      	eors	r2, r3
 800fe82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fe84:	335c      	adds	r3, #92	@ 0x5c
 800fe86:	681b      	ldr	r3, [r3, #0]
 800fe88:	4053      	eors	r3, r2
 800fe8a:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T(24); ENC_ROUND_T_S(24);
 800fe8c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fe8e:	0e1b      	lsrs	r3, r3, #24
 800fe90:	b2db      	uxtb	r3, r3
 800fe92:	461a      	mov	r2, r3
 800fe94:	4ba6      	ldr	r3, [pc, #664]	@ (8010130 <AesEncrypt_C+0x93c>)
 800fe96:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fe9a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fe9c:	0c1b      	lsrs	r3, r3, #16
 800fe9e:	b2db      	uxtb	r3, r3
 800fea0:	49a3      	ldr	r1, [pc, #652]	@ (8010130 <AesEncrypt_C+0x93c>)
 800fea2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fea6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800feaa:	405a      	eors	r2, r3
 800feac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800feae:	0a1b      	lsrs	r3, r3, #8
 800feb0:	b2db      	uxtb	r3, r3
 800feb2:	499f      	ldr	r1, [pc, #636]	@ (8010130 <AesEncrypt_C+0x93c>)
 800feb4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800feb8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800febc:	405a      	eors	r2, r3
 800febe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fec0:	b2db      	uxtb	r3, r3
 800fec2:	499b      	ldr	r1, [pc, #620]	@ (8010130 <AesEncrypt_C+0x93c>)
 800fec4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fec8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fecc:	405a      	eors	r2, r3
 800fece:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fed0:	3360      	adds	r3, #96	@ 0x60
 800fed2:	681b      	ldr	r3, [r3, #0]
 800fed4:	4053      	eors	r3, r2
 800fed6:	623b      	str	r3, [r7, #32]
 800fed8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800feda:	0e1b      	lsrs	r3, r3, #24
 800fedc:	b2db      	uxtb	r3, r3
 800fede:	461a      	mov	r2, r3
 800fee0:	4b93      	ldr	r3, [pc, #588]	@ (8010130 <AesEncrypt_C+0x93c>)
 800fee2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800fee6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fee8:	0c1b      	lsrs	r3, r3, #16
 800feea:	b2db      	uxtb	r3, r3
 800feec:	4990      	ldr	r1, [pc, #576]	@ (8010130 <AesEncrypt_C+0x93c>)
 800feee:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fef2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fef6:	405a      	eors	r2, r3
 800fef8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fefa:	0a1b      	lsrs	r3, r3, #8
 800fefc:	b2db      	uxtb	r3, r3
 800fefe:	498c      	ldr	r1, [pc, #560]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ff00:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800ff04:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff08:	405a      	eors	r2, r3
 800ff0a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ff0c:	b2db      	uxtb	r3, r3
 800ff0e:	4988      	ldr	r1, [pc, #544]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ff10:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800ff14:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff18:	405a      	eors	r2, r3
 800ff1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ff1c:	3364      	adds	r3, #100	@ 0x64
 800ff1e:	681b      	ldr	r3, [r3, #0]
 800ff20:	4053      	eors	r3, r2
 800ff22:	61fb      	str	r3, [r7, #28]
 800ff24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ff26:	0e1b      	lsrs	r3, r3, #24
 800ff28:	b2db      	uxtb	r3, r3
 800ff2a:	461a      	mov	r2, r3
 800ff2c:	4b80      	ldr	r3, [pc, #512]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ff2e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ff32:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ff34:	0c1b      	lsrs	r3, r3, #16
 800ff36:	b2db      	uxtb	r3, r3
 800ff38:	497d      	ldr	r1, [pc, #500]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ff3a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800ff3e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff42:	405a      	eors	r2, r3
 800ff44:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ff46:	0a1b      	lsrs	r3, r3, #8
 800ff48:	b2db      	uxtb	r3, r3
 800ff4a:	4979      	ldr	r1, [pc, #484]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ff4c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800ff50:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff54:	405a      	eors	r2, r3
 800ff56:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ff58:	b2db      	uxtb	r3, r3
 800ff5a:	4975      	ldr	r1, [pc, #468]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ff5c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800ff60:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff64:	405a      	eors	r2, r3
 800ff66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ff68:	3368      	adds	r3, #104	@ 0x68
 800ff6a:	681b      	ldr	r3, [r3, #0]
 800ff6c:	4053      	eors	r3, r2
 800ff6e:	61bb      	str	r3, [r7, #24]
 800ff70:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ff72:	0e1b      	lsrs	r3, r3, #24
 800ff74:	b2db      	uxtb	r3, r3
 800ff76:	461a      	mov	r2, r3
 800ff78:	4b6d      	ldr	r3, [pc, #436]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ff7a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ff7e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ff80:	0c1b      	lsrs	r3, r3, #16
 800ff82:	b2db      	uxtb	r3, r3
 800ff84:	496a      	ldr	r1, [pc, #424]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ff86:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800ff8a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ff8e:	405a      	eors	r2, r3
 800ff90:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ff92:	0a1b      	lsrs	r3, r3, #8
 800ff94:	b2db      	uxtb	r3, r3
 800ff96:	4966      	ldr	r1, [pc, #408]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ff98:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800ff9c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ffa0:	405a      	eors	r2, r3
 800ffa2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ffa4:	b2db      	uxtb	r3, r3
 800ffa6:	4962      	ldr	r1, [pc, #392]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ffa8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800ffac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ffb0:	405a      	eors	r2, r3
 800ffb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ffb4:	336c      	adds	r3, #108	@ 0x6c
 800ffb6:	681b      	ldr	r3, [r3, #0]
 800ffb8:	4053      	eors	r3, r2
 800ffba:	617b      	str	r3, [r7, #20]
 800ffbc:	6a3b      	ldr	r3, [r7, #32]
 800ffbe:	0e1b      	lsrs	r3, r3, #24
 800ffc0:	b2db      	uxtb	r3, r3
 800ffc2:	461a      	mov	r2, r3
 800ffc4:	4b5a      	ldr	r3, [pc, #360]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ffc6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ffca:	69fb      	ldr	r3, [r7, #28]
 800ffcc:	0c1b      	lsrs	r3, r3, #16
 800ffce:	b2db      	uxtb	r3, r3
 800ffd0:	4957      	ldr	r1, [pc, #348]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ffd2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800ffd6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ffda:	405a      	eors	r2, r3
 800ffdc:	69bb      	ldr	r3, [r7, #24]
 800ffde:	0a1b      	lsrs	r3, r3, #8
 800ffe0:	b2db      	uxtb	r3, r3
 800ffe2:	4953      	ldr	r1, [pc, #332]	@ (8010130 <AesEncrypt_C+0x93c>)
 800ffe4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800ffe8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ffec:	405a      	eors	r2, r3
 800ffee:	697b      	ldr	r3, [r7, #20]
 800fff0:	b2db      	uxtb	r3, r3
 800fff2:	494f      	ldr	r1, [pc, #316]	@ (8010130 <AesEncrypt_C+0x93c>)
 800fff4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 800fff8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800fffc:	405a      	eors	r2, r3
 800fffe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010000:	3370      	adds	r3, #112	@ 0x70
 8010002:	681b      	ldr	r3, [r3, #0]
 8010004:	4053      	eors	r3, r2
 8010006:	637b      	str	r3, [r7, #52]	@ 0x34
 8010008:	69fb      	ldr	r3, [r7, #28]
 801000a:	0e1b      	lsrs	r3, r3, #24
 801000c:	b2db      	uxtb	r3, r3
 801000e:	461a      	mov	r2, r3
 8010010:	4b47      	ldr	r3, [pc, #284]	@ (8010130 <AesEncrypt_C+0x93c>)
 8010012:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010016:	69bb      	ldr	r3, [r7, #24]
 8010018:	0c1b      	lsrs	r3, r3, #16
 801001a:	b2db      	uxtb	r3, r3
 801001c:	4944      	ldr	r1, [pc, #272]	@ (8010130 <AesEncrypt_C+0x93c>)
 801001e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010022:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010026:	405a      	eors	r2, r3
 8010028:	697b      	ldr	r3, [r7, #20]
 801002a:	0a1b      	lsrs	r3, r3, #8
 801002c:	b2db      	uxtb	r3, r3
 801002e:	4940      	ldr	r1, [pc, #256]	@ (8010130 <AesEncrypt_C+0x93c>)
 8010030:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010034:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010038:	405a      	eors	r2, r3
 801003a:	6a3b      	ldr	r3, [r7, #32]
 801003c:	b2db      	uxtb	r3, r3
 801003e:	493c      	ldr	r1, [pc, #240]	@ (8010130 <AesEncrypt_C+0x93c>)
 8010040:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010044:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010048:	405a      	eors	r2, r3
 801004a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801004c:	3374      	adds	r3, #116	@ 0x74
 801004e:	681b      	ldr	r3, [r3, #0]
 8010050:	4053      	eors	r3, r2
 8010052:	633b      	str	r3, [r7, #48]	@ 0x30
 8010054:	69bb      	ldr	r3, [r7, #24]
 8010056:	0e1b      	lsrs	r3, r3, #24
 8010058:	b2db      	uxtb	r3, r3
 801005a:	461a      	mov	r2, r3
 801005c:	4b34      	ldr	r3, [pc, #208]	@ (8010130 <AesEncrypt_C+0x93c>)
 801005e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010062:	697b      	ldr	r3, [r7, #20]
 8010064:	0c1b      	lsrs	r3, r3, #16
 8010066:	b2db      	uxtb	r3, r3
 8010068:	4931      	ldr	r1, [pc, #196]	@ (8010130 <AesEncrypt_C+0x93c>)
 801006a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801006e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010072:	405a      	eors	r2, r3
 8010074:	6a3b      	ldr	r3, [r7, #32]
 8010076:	0a1b      	lsrs	r3, r3, #8
 8010078:	b2db      	uxtb	r3, r3
 801007a:	492d      	ldr	r1, [pc, #180]	@ (8010130 <AesEncrypt_C+0x93c>)
 801007c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010080:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010084:	405a      	eors	r2, r3
 8010086:	69fb      	ldr	r3, [r7, #28]
 8010088:	b2db      	uxtb	r3, r3
 801008a:	4929      	ldr	r1, [pc, #164]	@ (8010130 <AesEncrypt_C+0x93c>)
 801008c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010090:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010094:	405a      	eors	r2, r3
 8010096:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010098:	3378      	adds	r3, #120	@ 0x78
 801009a:	681b      	ldr	r3, [r3, #0]
 801009c:	4053      	eors	r3, r2
 801009e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80100a0:	697b      	ldr	r3, [r7, #20]
 80100a2:	0e1b      	lsrs	r3, r3, #24
 80100a4:	b2db      	uxtb	r3, r3
 80100a6:	461a      	mov	r2, r3
 80100a8:	4b21      	ldr	r3, [pc, #132]	@ (8010130 <AesEncrypt_C+0x93c>)
 80100aa:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80100ae:	6a3b      	ldr	r3, [r7, #32]
 80100b0:	0c1b      	lsrs	r3, r3, #16
 80100b2:	b2db      	uxtb	r3, r3
 80100b4:	491e      	ldr	r1, [pc, #120]	@ (8010130 <AesEncrypt_C+0x93c>)
 80100b6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80100ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100be:	405a      	eors	r2, r3
 80100c0:	69fb      	ldr	r3, [r7, #28]
 80100c2:	0a1b      	lsrs	r3, r3, #8
 80100c4:	b2db      	uxtb	r3, r3
 80100c6:	491a      	ldr	r1, [pc, #104]	@ (8010130 <AesEncrypt_C+0x93c>)
 80100c8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80100cc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100d0:	405a      	eors	r2, r3
 80100d2:	69bb      	ldr	r3, [r7, #24]
 80100d4:	b2db      	uxtb	r3, r3
 80100d6:	4916      	ldr	r1, [pc, #88]	@ (8010130 <AesEncrypt_C+0x93c>)
 80100d8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80100dc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80100e0:	405a      	eors	r2, r3
 80100e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80100e4:	337c      	adds	r3, #124	@ 0x7c
 80100e6:	681b      	ldr	r3, [r3, #0]
 80100e8:	4053      	eors	r3, r2
 80100ea:	62bb      	str	r3, [r7, #40]	@ 0x28
    ENC_ROUND_S_T(32); ENC_ROUND_T_S(32);
 80100ec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80100ee:	0e1b      	lsrs	r3, r3, #24
 80100f0:	b2db      	uxtb	r3, r3
 80100f2:	461a      	mov	r2, r3
 80100f4:	4b0e      	ldr	r3, [pc, #56]	@ (8010130 <AesEncrypt_C+0x93c>)
 80100f6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80100fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80100fc:	0c1b      	lsrs	r3, r3, #16
 80100fe:	b2db      	uxtb	r3, r3
 8010100:	490b      	ldr	r1, [pc, #44]	@ (8010130 <AesEncrypt_C+0x93c>)
 8010102:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010106:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801010a:	405a      	eors	r2, r3
 801010c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801010e:	0a1b      	lsrs	r3, r3, #8
 8010110:	b2db      	uxtb	r3, r3
 8010112:	4907      	ldr	r1, [pc, #28]	@ (8010130 <AesEncrypt_C+0x93c>)
 8010114:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010118:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801011c:	405a      	eors	r2, r3
 801011e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010120:	b2db      	uxtb	r3, r3
 8010122:	4903      	ldr	r1, [pc, #12]	@ (8010130 <AesEncrypt_C+0x93c>)
 8010124:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010128:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801012c:	405a      	eors	r2, r3
 801012e:	e001      	b.n	8010134 <AesEncrypt_C+0x940>
 8010130:	08031328 	.word	0x08031328
 8010134:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010136:	3380      	adds	r3, #128	@ 0x80
 8010138:	681b      	ldr	r3, [r3, #0]
 801013a:	4053      	eors	r3, r2
 801013c:	623b      	str	r3, [r7, #32]
 801013e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010140:	0e1b      	lsrs	r3, r3, #24
 8010142:	b2db      	uxtb	r3, r3
 8010144:	461a      	mov	r2, r3
 8010146:	4bb6      	ldr	r3, [pc, #728]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010148:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801014c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801014e:	0c1b      	lsrs	r3, r3, #16
 8010150:	b2db      	uxtb	r3, r3
 8010152:	49b3      	ldr	r1, [pc, #716]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010154:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010158:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801015c:	405a      	eors	r2, r3
 801015e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010160:	0a1b      	lsrs	r3, r3, #8
 8010162:	b2db      	uxtb	r3, r3
 8010164:	49ae      	ldr	r1, [pc, #696]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010166:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801016a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801016e:	405a      	eors	r2, r3
 8010170:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010172:	b2db      	uxtb	r3, r3
 8010174:	49aa      	ldr	r1, [pc, #680]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010176:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801017a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801017e:	405a      	eors	r2, r3
 8010180:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010182:	3384      	adds	r3, #132	@ 0x84
 8010184:	681b      	ldr	r3, [r3, #0]
 8010186:	4053      	eors	r3, r2
 8010188:	61fb      	str	r3, [r7, #28]
 801018a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801018c:	0e1b      	lsrs	r3, r3, #24
 801018e:	b2db      	uxtb	r3, r3
 8010190:	461a      	mov	r2, r3
 8010192:	4ba3      	ldr	r3, [pc, #652]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010194:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010198:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801019a:	0c1b      	lsrs	r3, r3, #16
 801019c:	b2db      	uxtb	r3, r3
 801019e:	49a0      	ldr	r1, [pc, #640]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80101a0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80101a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101a8:	405a      	eors	r2, r3
 80101aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80101ac:	0a1b      	lsrs	r3, r3, #8
 80101ae:	b2db      	uxtb	r3, r3
 80101b0:	499b      	ldr	r1, [pc, #620]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80101b2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80101b6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101ba:	405a      	eors	r2, r3
 80101bc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80101be:	b2db      	uxtb	r3, r3
 80101c0:	4997      	ldr	r1, [pc, #604]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80101c2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80101c6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101ca:	405a      	eors	r2, r3
 80101cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80101ce:	3388      	adds	r3, #136	@ 0x88
 80101d0:	681b      	ldr	r3, [r3, #0]
 80101d2:	4053      	eors	r3, r2
 80101d4:	61bb      	str	r3, [r7, #24]
 80101d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80101d8:	0e1b      	lsrs	r3, r3, #24
 80101da:	b2db      	uxtb	r3, r3
 80101dc:	461a      	mov	r2, r3
 80101de:	4b90      	ldr	r3, [pc, #576]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80101e0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80101e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80101e6:	0c1b      	lsrs	r3, r3, #16
 80101e8:	b2db      	uxtb	r3, r3
 80101ea:	498d      	ldr	r1, [pc, #564]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80101ec:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80101f0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80101f4:	405a      	eors	r2, r3
 80101f6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80101f8:	0a1b      	lsrs	r3, r3, #8
 80101fa:	b2db      	uxtb	r3, r3
 80101fc:	4988      	ldr	r1, [pc, #544]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80101fe:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010202:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010206:	405a      	eors	r2, r3
 8010208:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801020a:	b2db      	uxtb	r3, r3
 801020c:	4984      	ldr	r1, [pc, #528]	@ (8010420 <AesEncrypt_C+0xc2c>)
 801020e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010212:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010216:	405a      	eors	r2, r3
 8010218:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801021a:	338c      	adds	r3, #140	@ 0x8c
 801021c:	681b      	ldr	r3, [r3, #0]
 801021e:	4053      	eors	r3, r2
 8010220:	617b      	str	r3, [r7, #20]
 8010222:	6a3b      	ldr	r3, [r7, #32]
 8010224:	0e1b      	lsrs	r3, r3, #24
 8010226:	b2db      	uxtb	r3, r3
 8010228:	461a      	mov	r2, r3
 801022a:	4b7d      	ldr	r3, [pc, #500]	@ (8010420 <AesEncrypt_C+0xc2c>)
 801022c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010230:	69fb      	ldr	r3, [r7, #28]
 8010232:	0c1b      	lsrs	r3, r3, #16
 8010234:	b2db      	uxtb	r3, r3
 8010236:	497a      	ldr	r1, [pc, #488]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010238:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801023c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010240:	405a      	eors	r2, r3
 8010242:	69bb      	ldr	r3, [r7, #24]
 8010244:	0a1b      	lsrs	r3, r3, #8
 8010246:	b2db      	uxtb	r3, r3
 8010248:	4975      	ldr	r1, [pc, #468]	@ (8010420 <AesEncrypt_C+0xc2c>)
 801024a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801024e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010252:	405a      	eors	r2, r3
 8010254:	697b      	ldr	r3, [r7, #20]
 8010256:	b2db      	uxtb	r3, r3
 8010258:	4971      	ldr	r1, [pc, #452]	@ (8010420 <AesEncrypt_C+0xc2c>)
 801025a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801025e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010262:	405a      	eors	r2, r3
 8010264:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010266:	3390      	adds	r3, #144	@ 0x90
 8010268:	681b      	ldr	r3, [r3, #0]
 801026a:	4053      	eors	r3, r2
 801026c:	637b      	str	r3, [r7, #52]	@ 0x34
 801026e:	69fb      	ldr	r3, [r7, #28]
 8010270:	0e1b      	lsrs	r3, r3, #24
 8010272:	b2db      	uxtb	r3, r3
 8010274:	461a      	mov	r2, r3
 8010276:	4b6a      	ldr	r3, [pc, #424]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010278:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801027c:	69bb      	ldr	r3, [r7, #24]
 801027e:	0c1b      	lsrs	r3, r3, #16
 8010280:	b2db      	uxtb	r3, r3
 8010282:	4967      	ldr	r1, [pc, #412]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010284:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010288:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801028c:	405a      	eors	r2, r3
 801028e:	697b      	ldr	r3, [r7, #20]
 8010290:	0a1b      	lsrs	r3, r3, #8
 8010292:	b2db      	uxtb	r3, r3
 8010294:	4962      	ldr	r1, [pc, #392]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010296:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801029a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801029e:	405a      	eors	r2, r3
 80102a0:	6a3b      	ldr	r3, [r7, #32]
 80102a2:	b2db      	uxtb	r3, r3
 80102a4:	495e      	ldr	r1, [pc, #376]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80102a6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80102aa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102ae:	405a      	eors	r2, r3
 80102b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102b2:	3394      	adds	r3, #148	@ 0x94
 80102b4:	681b      	ldr	r3, [r3, #0]
 80102b6:	4053      	eors	r3, r2
 80102b8:	633b      	str	r3, [r7, #48]	@ 0x30
 80102ba:	69bb      	ldr	r3, [r7, #24]
 80102bc:	0e1b      	lsrs	r3, r3, #24
 80102be:	b2db      	uxtb	r3, r3
 80102c0:	461a      	mov	r2, r3
 80102c2:	4b57      	ldr	r3, [pc, #348]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80102c4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80102c8:	697b      	ldr	r3, [r7, #20]
 80102ca:	0c1b      	lsrs	r3, r3, #16
 80102cc:	b2db      	uxtb	r3, r3
 80102ce:	4954      	ldr	r1, [pc, #336]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80102d0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80102d4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102d8:	405a      	eors	r2, r3
 80102da:	6a3b      	ldr	r3, [r7, #32]
 80102dc:	0a1b      	lsrs	r3, r3, #8
 80102de:	b2db      	uxtb	r3, r3
 80102e0:	494f      	ldr	r1, [pc, #316]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80102e2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80102e6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102ea:	405a      	eors	r2, r3
 80102ec:	69fb      	ldr	r3, [r7, #28]
 80102ee:	b2db      	uxtb	r3, r3
 80102f0:	494b      	ldr	r1, [pc, #300]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80102f2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80102f6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80102fa:	405a      	eors	r2, r3
 80102fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102fe:	3398      	adds	r3, #152	@ 0x98
 8010300:	681b      	ldr	r3, [r3, #0]
 8010302:	4053      	eors	r3, r2
 8010304:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010306:	697b      	ldr	r3, [r7, #20]
 8010308:	0e1b      	lsrs	r3, r3, #24
 801030a:	b2db      	uxtb	r3, r3
 801030c:	461a      	mov	r2, r3
 801030e:	4b44      	ldr	r3, [pc, #272]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010310:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010314:	6a3b      	ldr	r3, [r7, #32]
 8010316:	0c1b      	lsrs	r3, r3, #16
 8010318:	b2db      	uxtb	r3, r3
 801031a:	4941      	ldr	r1, [pc, #260]	@ (8010420 <AesEncrypt_C+0xc2c>)
 801031c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010320:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010324:	405a      	eors	r2, r3
 8010326:	69fb      	ldr	r3, [r7, #28]
 8010328:	0a1b      	lsrs	r3, r3, #8
 801032a:	b2db      	uxtb	r3, r3
 801032c:	493c      	ldr	r1, [pc, #240]	@ (8010420 <AesEncrypt_C+0xc2c>)
 801032e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010332:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010336:	405a      	eors	r2, r3
 8010338:	69bb      	ldr	r3, [r7, #24]
 801033a:	b2db      	uxtb	r3, r3
 801033c:	4938      	ldr	r1, [pc, #224]	@ (8010420 <AesEncrypt_C+0xc2c>)
 801033e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010342:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010346:	405a      	eors	r2, r3
 8010348:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801034a:	339c      	adds	r3, #156	@ 0x9c
 801034c:	681b      	ldr	r3, [r3, #0]
 801034e:	4053      	eors	r3, r2
 8010350:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (r > 5) {
 8010352:	683b      	ldr	r3, [r7, #0]
 8010354:	2b05      	cmp	r3, #5
 8010356:	f240 826a 	bls.w	801082e <AesEncrypt_C+0x103a>
        ENC_ROUND_S_T(40); ENC_ROUND_T_S(40);
 801035a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801035c:	0e1b      	lsrs	r3, r3, #24
 801035e:	b2db      	uxtb	r3, r3
 8010360:	461a      	mov	r2, r3
 8010362:	4b2f      	ldr	r3, [pc, #188]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010364:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010368:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801036a:	0c1b      	lsrs	r3, r3, #16
 801036c:	b2db      	uxtb	r3, r3
 801036e:	492c      	ldr	r1, [pc, #176]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010370:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010374:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010378:	405a      	eors	r2, r3
 801037a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801037c:	0a1b      	lsrs	r3, r3, #8
 801037e:	b2db      	uxtb	r3, r3
 8010380:	4927      	ldr	r1, [pc, #156]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010382:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010386:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801038a:	405a      	eors	r2, r3
 801038c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801038e:	b2db      	uxtb	r3, r3
 8010390:	4923      	ldr	r1, [pc, #140]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010392:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010396:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801039a:	405a      	eors	r2, r3
 801039c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801039e:	33a0      	adds	r3, #160	@ 0xa0
 80103a0:	681b      	ldr	r3, [r3, #0]
 80103a2:	4053      	eors	r3, r2
 80103a4:	623b      	str	r3, [r7, #32]
 80103a6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80103a8:	0e1b      	lsrs	r3, r3, #24
 80103aa:	b2db      	uxtb	r3, r3
 80103ac:	461a      	mov	r2, r3
 80103ae:	4b1c      	ldr	r3, [pc, #112]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80103b0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80103b4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80103b6:	0c1b      	lsrs	r3, r3, #16
 80103b8:	b2db      	uxtb	r3, r3
 80103ba:	4919      	ldr	r1, [pc, #100]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80103bc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80103c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80103c4:	405a      	eors	r2, r3
 80103c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80103c8:	0a1b      	lsrs	r3, r3, #8
 80103ca:	b2db      	uxtb	r3, r3
 80103cc:	4914      	ldr	r1, [pc, #80]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80103ce:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80103d2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80103d6:	405a      	eors	r2, r3
 80103d8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80103da:	b2db      	uxtb	r3, r3
 80103dc:	4910      	ldr	r1, [pc, #64]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80103de:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80103e2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80103e6:	405a      	eors	r2, r3
 80103e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80103ea:	33a4      	adds	r3, #164	@ 0xa4
 80103ec:	681b      	ldr	r3, [r3, #0]
 80103ee:	4053      	eors	r3, r2
 80103f0:	61fb      	str	r3, [r7, #28]
 80103f2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80103f4:	0e1b      	lsrs	r3, r3, #24
 80103f6:	b2db      	uxtb	r3, r3
 80103f8:	461a      	mov	r2, r3
 80103fa:	4b09      	ldr	r3, [pc, #36]	@ (8010420 <AesEncrypt_C+0xc2c>)
 80103fc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010400:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010402:	0c1b      	lsrs	r3, r3, #16
 8010404:	b2db      	uxtb	r3, r3
 8010406:	4906      	ldr	r1, [pc, #24]	@ (8010420 <AesEncrypt_C+0xc2c>)
 8010408:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801040c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010410:	405a      	eors	r2, r3
 8010412:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010414:	0a1b      	lsrs	r3, r3, #8
 8010416:	b2db      	uxtb	r3, r3
 8010418:	4901      	ldr	r1, [pc, #4]	@ (8010420 <AesEncrypt_C+0xc2c>)
 801041a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801041e:	e001      	b.n	8010424 <AesEncrypt_C+0xc30>
 8010420:	08031328 	.word	0x08031328
 8010424:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010428:	405a      	eors	r2, r3
 801042a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801042c:	b2db      	uxtb	r3, r3
 801042e:	49b6      	ldr	r1, [pc, #728]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010430:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010434:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010438:	405a      	eors	r2, r3
 801043a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801043c:	33a8      	adds	r3, #168	@ 0xa8
 801043e:	681b      	ldr	r3, [r3, #0]
 8010440:	4053      	eors	r3, r2
 8010442:	61bb      	str	r3, [r7, #24]
 8010444:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010446:	0e1b      	lsrs	r3, r3, #24
 8010448:	b2db      	uxtb	r3, r3
 801044a:	461a      	mov	r2, r3
 801044c:	4bae      	ldr	r3, [pc, #696]	@ (8010708 <AesEncrypt_C+0xf14>)
 801044e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010452:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010454:	0c1b      	lsrs	r3, r3, #16
 8010456:	b2db      	uxtb	r3, r3
 8010458:	49ab      	ldr	r1, [pc, #684]	@ (8010708 <AesEncrypt_C+0xf14>)
 801045a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801045e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010462:	405a      	eors	r2, r3
 8010464:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010466:	0a1b      	lsrs	r3, r3, #8
 8010468:	b2db      	uxtb	r3, r3
 801046a:	49a7      	ldr	r1, [pc, #668]	@ (8010708 <AesEncrypt_C+0xf14>)
 801046c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010470:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010474:	405a      	eors	r2, r3
 8010476:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010478:	b2db      	uxtb	r3, r3
 801047a:	49a3      	ldr	r1, [pc, #652]	@ (8010708 <AesEncrypt_C+0xf14>)
 801047c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010480:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010484:	405a      	eors	r2, r3
 8010486:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010488:	33ac      	adds	r3, #172	@ 0xac
 801048a:	681b      	ldr	r3, [r3, #0]
 801048c:	4053      	eors	r3, r2
 801048e:	617b      	str	r3, [r7, #20]
 8010490:	6a3b      	ldr	r3, [r7, #32]
 8010492:	0e1b      	lsrs	r3, r3, #24
 8010494:	b2db      	uxtb	r3, r3
 8010496:	461a      	mov	r2, r3
 8010498:	4b9b      	ldr	r3, [pc, #620]	@ (8010708 <AesEncrypt_C+0xf14>)
 801049a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801049e:	69fb      	ldr	r3, [r7, #28]
 80104a0:	0c1b      	lsrs	r3, r3, #16
 80104a2:	b2db      	uxtb	r3, r3
 80104a4:	4998      	ldr	r1, [pc, #608]	@ (8010708 <AesEncrypt_C+0xf14>)
 80104a6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80104aa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104ae:	405a      	eors	r2, r3
 80104b0:	69bb      	ldr	r3, [r7, #24]
 80104b2:	0a1b      	lsrs	r3, r3, #8
 80104b4:	b2db      	uxtb	r3, r3
 80104b6:	4994      	ldr	r1, [pc, #592]	@ (8010708 <AesEncrypt_C+0xf14>)
 80104b8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80104bc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104c0:	405a      	eors	r2, r3
 80104c2:	697b      	ldr	r3, [r7, #20]
 80104c4:	b2db      	uxtb	r3, r3
 80104c6:	4990      	ldr	r1, [pc, #576]	@ (8010708 <AesEncrypt_C+0xf14>)
 80104c8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80104cc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104d0:	405a      	eors	r2, r3
 80104d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80104d4:	33b0      	adds	r3, #176	@ 0xb0
 80104d6:	681b      	ldr	r3, [r3, #0]
 80104d8:	4053      	eors	r3, r2
 80104da:	637b      	str	r3, [r7, #52]	@ 0x34
 80104dc:	69fb      	ldr	r3, [r7, #28]
 80104de:	0e1b      	lsrs	r3, r3, #24
 80104e0:	b2db      	uxtb	r3, r3
 80104e2:	461a      	mov	r2, r3
 80104e4:	4b88      	ldr	r3, [pc, #544]	@ (8010708 <AesEncrypt_C+0xf14>)
 80104e6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80104ea:	69bb      	ldr	r3, [r7, #24]
 80104ec:	0c1b      	lsrs	r3, r3, #16
 80104ee:	b2db      	uxtb	r3, r3
 80104f0:	4985      	ldr	r1, [pc, #532]	@ (8010708 <AesEncrypt_C+0xf14>)
 80104f2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80104f6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80104fa:	405a      	eors	r2, r3
 80104fc:	697b      	ldr	r3, [r7, #20]
 80104fe:	0a1b      	lsrs	r3, r3, #8
 8010500:	b2db      	uxtb	r3, r3
 8010502:	4981      	ldr	r1, [pc, #516]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010504:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010508:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801050c:	405a      	eors	r2, r3
 801050e:	6a3b      	ldr	r3, [r7, #32]
 8010510:	b2db      	uxtb	r3, r3
 8010512:	497d      	ldr	r1, [pc, #500]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010514:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010518:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801051c:	405a      	eors	r2, r3
 801051e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010520:	33b4      	adds	r3, #180	@ 0xb4
 8010522:	681b      	ldr	r3, [r3, #0]
 8010524:	4053      	eors	r3, r2
 8010526:	633b      	str	r3, [r7, #48]	@ 0x30
 8010528:	69bb      	ldr	r3, [r7, #24]
 801052a:	0e1b      	lsrs	r3, r3, #24
 801052c:	b2db      	uxtb	r3, r3
 801052e:	461a      	mov	r2, r3
 8010530:	4b75      	ldr	r3, [pc, #468]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010532:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010536:	697b      	ldr	r3, [r7, #20]
 8010538:	0c1b      	lsrs	r3, r3, #16
 801053a:	b2db      	uxtb	r3, r3
 801053c:	4972      	ldr	r1, [pc, #456]	@ (8010708 <AesEncrypt_C+0xf14>)
 801053e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010542:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010546:	405a      	eors	r2, r3
 8010548:	6a3b      	ldr	r3, [r7, #32]
 801054a:	0a1b      	lsrs	r3, r3, #8
 801054c:	b2db      	uxtb	r3, r3
 801054e:	496e      	ldr	r1, [pc, #440]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010550:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010554:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010558:	405a      	eors	r2, r3
 801055a:	69fb      	ldr	r3, [r7, #28]
 801055c:	b2db      	uxtb	r3, r3
 801055e:	496a      	ldr	r1, [pc, #424]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010560:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010564:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010568:	405a      	eors	r2, r3
 801056a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801056c:	33b8      	adds	r3, #184	@ 0xb8
 801056e:	681b      	ldr	r3, [r3, #0]
 8010570:	4053      	eors	r3, r2
 8010572:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010574:	697b      	ldr	r3, [r7, #20]
 8010576:	0e1b      	lsrs	r3, r3, #24
 8010578:	b2db      	uxtb	r3, r3
 801057a:	461a      	mov	r2, r3
 801057c:	4b62      	ldr	r3, [pc, #392]	@ (8010708 <AesEncrypt_C+0xf14>)
 801057e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010582:	6a3b      	ldr	r3, [r7, #32]
 8010584:	0c1b      	lsrs	r3, r3, #16
 8010586:	b2db      	uxtb	r3, r3
 8010588:	495f      	ldr	r1, [pc, #380]	@ (8010708 <AesEncrypt_C+0xf14>)
 801058a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801058e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010592:	405a      	eors	r2, r3
 8010594:	69fb      	ldr	r3, [r7, #28]
 8010596:	0a1b      	lsrs	r3, r3, #8
 8010598:	b2db      	uxtb	r3, r3
 801059a:	495b      	ldr	r1, [pc, #364]	@ (8010708 <AesEncrypt_C+0xf14>)
 801059c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80105a0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105a4:	405a      	eors	r2, r3
 80105a6:	69bb      	ldr	r3, [r7, #24]
 80105a8:	b2db      	uxtb	r3, r3
 80105aa:	4957      	ldr	r1, [pc, #348]	@ (8010708 <AesEncrypt_C+0xf14>)
 80105ac:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80105b0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105b4:	405a      	eors	r2, r3
 80105b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80105b8:	33bc      	adds	r3, #188	@ 0xbc
 80105ba:	681b      	ldr	r3, [r3, #0]
 80105bc:	4053      	eors	r3, r2
 80105be:	62bb      	str	r3, [r7, #40]	@ 0x28
        if (r > 6) {
 80105c0:	683b      	ldr	r3, [r7, #0]
 80105c2:	2b06      	cmp	r3, #6
 80105c4:	f240 8133 	bls.w	801082e <AesEncrypt_C+0x103a>
            ENC_ROUND_S_T(48); ENC_ROUND_T_S(48);
 80105c8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80105ca:	0e1b      	lsrs	r3, r3, #24
 80105cc:	b2db      	uxtb	r3, r3
 80105ce:	461a      	mov	r2, r3
 80105d0:	4b4d      	ldr	r3, [pc, #308]	@ (8010708 <AesEncrypt_C+0xf14>)
 80105d2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80105d6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80105d8:	0c1b      	lsrs	r3, r3, #16
 80105da:	b2db      	uxtb	r3, r3
 80105dc:	494a      	ldr	r1, [pc, #296]	@ (8010708 <AesEncrypt_C+0xf14>)
 80105de:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80105e2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105e6:	405a      	eors	r2, r3
 80105e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80105ea:	0a1b      	lsrs	r3, r3, #8
 80105ec:	b2db      	uxtb	r3, r3
 80105ee:	4946      	ldr	r1, [pc, #280]	@ (8010708 <AesEncrypt_C+0xf14>)
 80105f0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80105f4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80105f8:	405a      	eors	r2, r3
 80105fa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80105fc:	b2db      	uxtb	r3, r3
 80105fe:	4942      	ldr	r1, [pc, #264]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010600:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010604:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010608:	405a      	eors	r2, r3
 801060a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801060c:	33c0      	adds	r3, #192	@ 0xc0
 801060e:	681b      	ldr	r3, [r3, #0]
 8010610:	4053      	eors	r3, r2
 8010612:	623b      	str	r3, [r7, #32]
 8010614:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010616:	0e1b      	lsrs	r3, r3, #24
 8010618:	b2db      	uxtb	r3, r3
 801061a:	461a      	mov	r2, r3
 801061c:	4b3a      	ldr	r3, [pc, #232]	@ (8010708 <AesEncrypt_C+0xf14>)
 801061e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010622:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010624:	0c1b      	lsrs	r3, r3, #16
 8010626:	b2db      	uxtb	r3, r3
 8010628:	4937      	ldr	r1, [pc, #220]	@ (8010708 <AesEncrypt_C+0xf14>)
 801062a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801062e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010632:	405a      	eors	r2, r3
 8010634:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010636:	0a1b      	lsrs	r3, r3, #8
 8010638:	b2db      	uxtb	r3, r3
 801063a:	4933      	ldr	r1, [pc, #204]	@ (8010708 <AesEncrypt_C+0xf14>)
 801063c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010640:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010644:	405a      	eors	r2, r3
 8010646:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010648:	b2db      	uxtb	r3, r3
 801064a:	492f      	ldr	r1, [pc, #188]	@ (8010708 <AesEncrypt_C+0xf14>)
 801064c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010650:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010654:	405a      	eors	r2, r3
 8010656:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010658:	33c4      	adds	r3, #196	@ 0xc4
 801065a:	681b      	ldr	r3, [r3, #0]
 801065c:	4053      	eors	r3, r2
 801065e:	61fb      	str	r3, [r7, #28]
 8010660:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010662:	0e1b      	lsrs	r3, r3, #24
 8010664:	b2db      	uxtb	r3, r3
 8010666:	461a      	mov	r2, r3
 8010668:	4b27      	ldr	r3, [pc, #156]	@ (8010708 <AesEncrypt_C+0xf14>)
 801066a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801066e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010670:	0c1b      	lsrs	r3, r3, #16
 8010672:	b2db      	uxtb	r3, r3
 8010674:	4924      	ldr	r1, [pc, #144]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010676:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801067a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801067e:	405a      	eors	r2, r3
 8010680:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010682:	0a1b      	lsrs	r3, r3, #8
 8010684:	b2db      	uxtb	r3, r3
 8010686:	4920      	ldr	r1, [pc, #128]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010688:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801068c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010690:	405a      	eors	r2, r3
 8010692:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010694:	b2db      	uxtb	r3, r3
 8010696:	491c      	ldr	r1, [pc, #112]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010698:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801069c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106a0:	405a      	eors	r2, r3
 80106a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80106a4:	33c8      	adds	r3, #200	@ 0xc8
 80106a6:	681b      	ldr	r3, [r3, #0]
 80106a8:	4053      	eors	r3, r2
 80106aa:	61bb      	str	r3, [r7, #24]
 80106ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80106ae:	0e1b      	lsrs	r3, r3, #24
 80106b0:	b2db      	uxtb	r3, r3
 80106b2:	461a      	mov	r2, r3
 80106b4:	4b14      	ldr	r3, [pc, #80]	@ (8010708 <AesEncrypt_C+0xf14>)
 80106b6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80106ba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80106bc:	0c1b      	lsrs	r3, r3, #16
 80106be:	b2db      	uxtb	r3, r3
 80106c0:	4911      	ldr	r1, [pc, #68]	@ (8010708 <AesEncrypt_C+0xf14>)
 80106c2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80106c6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106ca:	405a      	eors	r2, r3
 80106cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80106ce:	0a1b      	lsrs	r3, r3, #8
 80106d0:	b2db      	uxtb	r3, r3
 80106d2:	490d      	ldr	r1, [pc, #52]	@ (8010708 <AesEncrypt_C+0xf14>)
 80106d4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80106d8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106dc:	405a      	eors	r2, r3
 80106de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80106e0:	b2db      	uxtb	r3, r3
 80106e2:	4909      	ldr	r1, [pc, #36]	@ (8010708 <AesEncrypt_C+0xf14>)
 80106e4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80106e8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80106ec:	405a      	eors	r2, r3
 80106ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80106f0:	33cc      	adds	r3, #204	@ 0xcc
 80106f2:	681b      	ldr	r3, [r3, #0]
 80106f4:	4053      	eors	r3, r2
 80106f6:	617b      	str	r3, [r7, #20]
 80106f8:	6a3b      	ldr	r3, [r7, #32]
 80106fa:	0e1b      	lsrs	r3, r3, #24
 80106fc:	b2db      	uxtb	r3, r3
 80106fe:	461a      	mov	r2, r3
 8010700:	4b01      	ldr	r3, [pc, #4]	@ (8010708 <AesEncrypt_C+0xf14>)
 8010702:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010706:	e001      	b.n	801070c <AesEncrypt_C+0xf18>
 8010708:	08031328 	.word	0x08031328
 801070c:	69fb      	ldr	r3, [r7, #28]
 801070e:	0c1b      	lsrs	r3, r3, #16
 8010710:	b2db      	uxtb	r3, r3
 8010712:	49b8      	ldr	r1, [pc, #736]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010714:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010718:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801071c:	405a      	eors	r2, r3
 801071e:	69bb      	ldr	r3, [r7, #24]
 8010720:	0a1b      	lsrs	r3, r3, #8
 8010722:	b2db      	uxtb	r3, r3
 8010724:	49b3      	ldr	r1, [pc, #716]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010726:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801072a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801072e:	405a      	eors	r2, r3
 8010730:	697b      	ldr	r3, [r7, #20]
 8010732:	b2db      	uxtb	r3, r3
 8010734:	49af      	ldr	r1, [pc, #700]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010736:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801073a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801073e:	405a      	eors	r2, r3
 8010740:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010742:	33d0      	adds	r3, #208	@ 0xd0
 8010744:	681b      	ldr	r3, [r3, #0]
 8010746:	4053      	eors	r3, r2
 8010748:	637b      	str	r3, [r7, #52]	@ 0x34
 801074a:	69fb      	ldr	r3, [r7, #28]
 801074c:	0e1b      	lsrs	r3, r3, #24
 801074e:	b2db      	uxtb	r3, r3
 8010750:	461a      	mov	r2, r3
 8010752:	4ba8      	ldr	r3, [pc, #672]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010754:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010758:	69bb      	ldr	r3, [r7, #24]
 801075a:	0c1b      	lsrs	r3, r3, #16
 801075c:	b2db      	uxtb	r3, r3
 801075e:	49a5      	ldr	r1, [pc, #660]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010760:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010764:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010768:	405a      	eors	r2, r3
 801076a:	697b      	ldr	r3, [r7, #20]
 801076c:	0a1b      	lsrs	r3, r3, #8
 801076e:	b2db      	uxtb	r3, r3
 8010770:	49a0      	ldr	r1, [pc, #640]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010772:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010776:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801077a:	405a      	eors	r2, r3
 801077c:	6a3b      	ldr	r3, [r7, #32]
 801077e:	b2db      	uxtb	r3, r3
 8010780:	499c      	ldr	r1, [pc, #624]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010782:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010786:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801078a:	405a      	eors	r2, r3
 801078c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801078e:	33d4      	adds	r3, #212	@ 0xd4
 8010790:	681b      	ldr	r3, [r3, #0]
 8010792:	4053      	eors	r3, r2
 8010794:	633b      	str	r3, [r7, #48]	@ 0x30
 8010796:	69bb      	ldr	r3, [r7, #24]
 8010798:	0e1b      	lsrs	r3, r3, #24
 801079a:	b2db      	uxtb	r3, r3
 801079c:	461a      	mov	r2, r3
 801079e:	4b95      	ldr	r3, [pc, #596]	@ (80109f4 <AesEncrypt_C+0x1200>)
 80107a0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80107a4:	697b      	ldr	r3, [r7, #20]
 80107a6:	0c1b      	lsrs	r3, r3, #16
 80107a8:	b2db      	uxtb	r3, r3
 80107aa:	4992      	ldr	r1, [pc, #584]	@ (80109f4 <AesEncrypt_C+0x1200>)
 80107ac:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80107b0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107b4:	405a      	eors	r2, r3
 80107b6:	6a3b      	ldr	r3, [r7, #32]
 80107b8:	0a1b      	lsrs	r3, r3, #8
 80107ba:	b2db      	uxtb	r3, r3
 80107bc:	498d      	ldr	r1, [pc, #564]	@ (80109f4 <AesEncrypt_C+0x1200>)
 80107be:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80107c2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107c6:	405a      	eors	r2, r3
 80107c8:	69fb      	ldr	r3, [r7, #28]
 80107ca:	b2db      	uxtb	r3, r3
 80107cc:	4989      	ldr	r1, [pc, #548]	@ (80109f4 <AesEncrypt_C+0x1200>)
 80107ce:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80107d2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80107d6:	405a      	eors	r2, r3
 80107d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80107da:	33d8      	adds	r3, #216	@ 0xd8
 80107dc:	681b      	ldr	r3, [r3, #0]
 80107de:	4053      	eors	r3, r2
 80107e0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80107e2:	697b      	ldr	r3, [r7, #20]
 80107e4:	0e1b      	lsrs	r3, r3, #24
 80107e6:	b2db      	uxtb	r3, r3
 80107e8:	461a      	mov	r2, r3
 80107ea:	4b82      	ldr	r3, [pc, #520]	@ (80109f4 <AesEncrypt_C+0x1200>)
 80107ec:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80107f0:	6a3b      	ldr	r3, [r7, #32]
 80107f2:	0c1b      	lsrs	r3, r3, #16
 80107f4:	b2db      	uxtb	r3, r3
 80107f6:	497f      	ldr	r1, [pc, #508]	@ (80109f4 <AesEncrypt_C+0x1200>)
 80107f8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80107fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010800:	405a      	eors	r2, r3
 8010802:	69fb      	ldr	r3, [r7, #28]
 8010804:	0a1b      	lsrs	r3, r3, #8
 8010806:	b2db      	uxtb	r3, r3
 8010808:	497a      	ldr	r1, [pc, #488]	@ (80109f4 <AesEncrypt_C+0x1200>)
 801080a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801080e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010812:	405a      	eors	r2, r3
 8010814:	69bb      	ldr	r3, [r7, #24]
 8010816:	b2db      	uxtb	r3, r3
 8010818:	4976      	ldr	r1, [pc, #472]	@ (80109f4 <AesEncrypt_C+0x1200>)
 801081a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801081e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010822:	405a      	eors	r2, r3
 8010824:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010826:	33dc      	adds	r3, #220	@ 0xdc
 8010828:	681b      	ldr	r3, [r3, #0]
 801082a:	4053      	eors	r3, r2
 801082c:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
    rk += r * 8;
 801082e:	683b      	ldr	r3, [r7, #0]
 8010830:	015b      	lsls	r3, r3, #5
 8010832:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8010834:	4413      	add	r3, r2
 8010836:	627b      	str	r3, [r7, #36]	@ 0x24
     * map cipher state to byte array block:
     */

#ifndef WOLFSSL_AES_TOUCH_LINES
    s0 =
        (GetTable(Te[2], GETBYTE(t0, 3)) & 0xff000000) ^
 8010838:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801083a:	0e1b      	lsrs	r3, r3, #24
 801083c:	b2db      	uxtb	r3, r3
 801083e:	4a6d      	ldr	r2, [pc, #436]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010840:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010844:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010848:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t1, 2)) & 0x00ff0000) ^
 801084c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801084e:	0c1b      	lsrs	r3, r3, #16
 8010850:	b2db      	uxtb	r3, r3
 8010852:	4968      	ldr	r1, [pc, #416]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010854:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010858:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801085c:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t0, 3)) & 0xff000000) ^
 8010860:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t2, 1)) & 0x0000ff00) ^
 8010862:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010864:	0a1b      	lsrs	r3, r3, #8
 8010866:	b2db      	uxtb	r3, r3
 8010868:	4619      	mov	r1, r3
 801086a:	4b62      	ldr	r3, [pc, #392]	@ (80109f4 <AesEncrypt_C+0x1200>)
 801086c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8010870:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t1, 2)) & 0x00ff0000) ^
 8010874:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 8010876:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010878:	b2db      	uxtb	r3, r3
 801087a:	495e      	ldr	r1, [pc, #376]	@ (80109f4 <AesEncrypt_C+0x1200>)
 801087c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010880:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010884:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t2, 1)) & 0x0000ff00) ^
 8010886:	405a      	eors	r2, r3
        rk[0];
 8010888:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801088a:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 801088c:	4053      	eors	r3, r2
    s0 =
 801088e:	623b      	str	r3, [r7, #32]
    s1 =
        (GetTable(Te[2], GETBYTE(t1, 3)) & 0xff000000) ^
 8010890:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010892:	0e1b      	lsrs	r3, r3, #24
 8010894:	b2db      	uxtb	r3, r3
 8010896:	4a57      	ldr	r2, [pc, #348]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010898:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801089c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80108a0:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t2, 2)) & 0x00ff0000) ^
 80108a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80108a6:	0c1b      	lsrs	r3, r3, #16
 80108a8:	b2db      	uxtb	r3, r3
 80108aa:	4952      	ldr	r1, [pc, #328]	@ (80109f4 <AesEncrypt_C+0x1200>)
 80108ac:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80108b0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80108b4:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t1, 3)) & 0xff000000) ^
 80108b8:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t3, 1)) & 0x0000ff00) ^
 80108ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80108bc:	0a1b      	lsrs	r3, r3, #8
 80108be:	b2db      	uxtb	r3, r3
 80108c0:	4619      	mov	r1, r3
 80108c2:	4b4c      	ldr	r3, [pc, #304]	@ (80109f4 <AesEncrypt_C+0x1200>)
 80108c4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80108c8:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t2, 2)) & 0x00ff0000) ^
 80108cc:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 80108ce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80108d0:	b2db      	uxtb	r3, r3
 80108d2:	4948      	ldr	r1, [pc, #288]	@ (80109f4 <AesEncrypt_C+0x1200>)
 80108d4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80108d8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80108dc:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t3, 1)) & 0x0000ff00) ^
 80108de:	405a      	eors	r2, r3
        rk[1];
 80108e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80108e2:	3304      	adds	r3, #4
 80108e4:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 80108e6:	4053      	eors	r3, r2
    s1 =
 80108e8:	61fb      	str	r3, [r7, #28]
    s2 =
        (GetTable(Te[2], GETBYTE(t2, 3)) & 0xff000000) ^
 80108ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80108ec:	0e1b      	lsrs	r3, r3, #24
 80108ee:	b2db      	uxtb	r3, r3
 80108f0:	4a40      	ldr	r2, [pc, #256]	@ (80109f4 <AesEncrypt_C+0x1200>)
 80108f2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80108f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80108fa:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t3, 2)) & 0x00ff0000) ^
 80108fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010900:	0c1b      	lsrs	r3, r3, #16
 8010902:	b2db      	uxtb	r3, r3
 8010904:	493b      	ldr	r1, [pc, #236]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010906:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801090a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801090e:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t2, 3)) & 0xff000000) ^
 8010912:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t0, 1)) & 0x0000ff00) ^
 8010914:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010916:	0a1b      	lsrs	r3, r3, #8
 8010918:	b2db      	uxtb	r3, r3
 801091a:	4619      	mov	r1, r3
 801091c:	4b35      	ldr	r3, [pc, #212]	@ (80109f4 <AesEncrypt_C+0x1200>)
 801091e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8010922:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t3, 2)) & 0x00ff0000) ^
 8010926:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t1, 0)) & 0x000000ff) ^
 8010928:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801092a:	b2db      	uxtb	r3, r3
 801092c:	4931      	ldr	r1, [pc, #196]	@ (80109f4 <AesEncrypt_C+0x1200>)
 801092e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010932:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010936:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t0, 1)) & 0x0000ff00) ^
 8010938:	405a      	eors	r2, r3
        rk[2];
 801093a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801093c:	3308      	adds	r3, #8
 801093e:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t1, 0)) & 0x000000ff) ^
 8010940:	4053      	eors	r3, r2
    s2 =
 8010942:	61bb      	str	r3, [r7, #24]
    s3 =
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 8010944:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010946:	0e1b      	lsrs	r3, r3, #24
 8010948:	b2db      	uxtb	r3, r3
 801094a:	4a2a      	ldr	r2, [pc, #168]	@ (80109f4 <AesEncrypt_C+0x1200>)
 801094c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010950:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010954:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
        (GetTable(Te[3], GETBYTE(t0, 2)) & 0x00ff0000) ^
 8010958:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801095a:	0c1b      	lsrs	r3, r3, #16
 801095c:	b2db      	uxtb	r3, r3
 801095e:	4925      	ldr	r1, [pc, #148]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010960:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010964:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010968:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 801096c:	431a      	orrs	r2, r3
        (GetTable(Te[0], GETBYTE(t1, 1)) & 0x0000ff00) ^
 801096e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010970:	0a1b      	lsrs	r3, r3, #8
 8010972:	b2db      	uxtb	r3, r3
 8010974:	4619      	mov	r1, r3
 8010976:	4b1f      	ldr	r3, [pc, #124]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010978:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 801097c:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
        (GetTable(Te[3], GETBYTE(t0, 2)) & 0x00ff0000) ^
 8010980:	405a      	eors	r2, r3
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 8010982:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010984:	b2db      	uxtb	r3, r3
 8010986:	491b      	ldr	r1, [pc, #108]	@ (80109f4 <AesEncrypt_C+0x1200>)
 8010988:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801098c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010990:	b2db      	uxtb	r3, r3
        (GetTable(Te[0], GETBYTE(t1, 1)) & 0x0000ff00) ^
 8010992:	405a      	eors	r2, r3
        rk[3];
 8010994:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010996:	330c      	adds	r3, #12
 8010998:	681b      	ldr	r3, [r3, #0]
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 801099a:	4053      	eors	r3, r2
    s3 =
 801099c:	617b      	str	r3, [r7, #20]
    s3 = t3 ^ rk[3];
#endif

    /* write out */
#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 801099e:	6a3b      	ldr	r3, [r7, #32]
 80109a0:	4618      	mov	r0, r3
 80109a2:	f7fe fe28 	bl	800f5f6 <ByteReverseWord32>
 80109a6:	4603      	mov	r3, r0
 80109a8:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 80109aa:	69fb      	ldr	r3, [r7, #28]
 80109ac:	4618      	mov	r0, r3
 80109ae:	f7fe fe22 	bl	800f5f6 <ByteReverseWord32>
 80109b2:	4603      	mov	r3, r0
 80109b4:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 80109b6:	69bb      	ldr	r3, [r7, #24]
 80109b8:	4618      	mov	r0, r3
 80109ba:	f7fe fe1c 	bl	800f5f6 <ByteReverseWord32>
 80109be:	4603      	mov	r3, r0
 80109c0:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 80109c2:	697b      	ldr	r3, [r7, #20]
 80109c4:	4618      	mov	r0, r3
 80109c6:	f7fe fe16 	bl	800f5f6 <ByteReverseWord32>
 80109ca:	4603      	mov	r3, r0
 80109cc:	617b      	str	r3, [r7, #20]
#endif

    XMEMCPY(outBlock,                  &s0, sizeof(s0));
 80109ce:	6a3a      	ldr	r2, [r7, #32]
 80109d0:	687b      	ldr	r3, [r7, #4]
 80109d2:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock +     sizeof(s0), &s1, sizeof(s1));
 80109d4:	687b      	ldr	r3, [r7, #4]
 80109d6:	3304      	adds	r3, #4
 80109d8:	69fa      	ldr	r2, [r7, #28]
 80109da:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 2 * sizeof(s0), &s2, sizeof(s2));
 80109dc:	687b      	ldr	r3, [r7, #4]
 80109de:	3308      	adds	r3, #8
 80109e0:	69ba      	ldr	r2, [r7, #24]
 80109e2:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 3 * sizeof(s0), &s3, sizeof(s3));
 80109e4:	687b      	ldr	r3, [r7, #4]
 80109e6:	330c      	adds	r3, #12
 80109e8:	697a      	ldr	r2, [r7, #20]
 80109ea:	601a      	str	r2, [r3, #0]
}
 80109ec:	bf00      	nop
 80109ee:	3738      	adds	r7, #56	@ 0x38
 80109f0:	46bd      	mov	sp, r7
 80109f2:	bd80      	pop	{r7, pc}
 80109f4:	08031328 	.word	0x08031328

080109f8 <wc_AesEncrypt>:

/* this section disabled with NO_AES_192 */
/* calling this one when missing NO_AES_192  */
static WARN_UNUSED_RESULT int wc_AesEncrypt(
    Aes* aes, const byte* inBlock, byte* outBlock)
{
 80109f8:	b580      	push	{r7, lr}
 80109fa:	b086      	sub	sp, #24
 80109fc:	af00      	add	r7, sp, #0
 80109fe:	60f8      	str	r0, [r7, #12]
 8010a00:	60b9      	str	r1, [r7, #8]
 8010a02:	607a      	str	r2, [r7, #4]
#if defined(MAX3266X_CB)
    int ret_cb;
#endif
    word32 r;

    if (aes == NULL) {
 8010a04:	68fb      	ldr	r3, [r7, #12]
 8010a06:	2b00      	cmp	r3, #0
 8010a08:	d102      	bne.n	8010a10 <wc_AesEncrypt+0x18>
        return BAD_FUNC_ARG;
 8010a0a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8010a0e:	e014      	b.n	8010a3a <wc_AesEncrypt+0x42>
        if (ret < 0)
            return ret;
    }
#endif

    r = aes->rounds >> 1;
 8010a10:	68fb      	ldr	r3, [r7, #12]
 8010a12:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8010a16:	085b      	lsrs	r3, r3, #1
 8010a18:	617b      	str	r3, [r7, #20]

    if (r > 7 || r == 0) {
 8010a1a:	697b      	ldr	r3, [r7, #20]
 8010a1c:	2b07      	cmp	r3, #7
 8010a1e:	d802      	bhi.n	8010a26 <wc_AesEncrypt+0x2e>
 8010a20:	697b      	ldr	r3, [r7, #20]
 8010a22:	2b00      	cmp	r3, #0
 8010a24:	d102      	bne.n	8010a2c <wc_AesEncrypt+0x34>
        WOLFSSL_ERROR_VERBOSE(KEYUSAGE_E);
        return KEYUSAGE_E;
 8010a26:	f06f 03e1 	mvn.w	r3, #225	@ 0xe1
 8010a2a:	e006      	b.n	8010a3a <wc_AesEncrypt+0x42>
            return ret_cb;
        /* fall-through when unavailable */
    }
#endif

    AesEncrypt_C(aes, inBlock, outBlock, r);
 8010a2c:	697b      	ldr	r3, [r7, #20]
 8010a2e:	687a      	ldr	r2, [r7, #4]
 8010a30:	68b9      	ldr	r1, [r7, #8]
 8010a32:	68f8      	ldr	r0, [r7, #12]
 8010a34:	f7fe fede 	bl	800f7f4 <AesEncrypt_C>

    return 0;
 8010a38:	2300      	movs	r3, #0
} /* wc_AesEncrypt */
 8010a3a:	4618      	mov	r0, r3
 8010a3c:	3718      	adds	r7, #24
 8010a3e:	46bd      	mov	sp, r7
 8010a40:	bd80      	pop	{r7, pc}
	...

08010a44 <PreFetchTd>:
#ifndef WC_AES_BITSLICED
#ifndef WC_NO_CACHE_RESISTANT
#ifndef WOLFSSL_AES_SMALL_TABLES
/* load 4 Td Tables into cache by cache line stride */
static WARN_UNUSED_RESULT WC_INLINE word32 PreFetchTd(void)
{
 8010a44:	b480      	push	{r7}
 8010a46:	b085      	sub	sp, #20
 8010a48:	af00      	add	r7, sp, #0
    word32 x = 0;
 8010a4a:	2300      	movs	r3, #0
 8010a4c:	60fb      	str	r3, [r7, #12]
    int i,j;

    for (i = 0; i < 4; i++) {
 8010a4e:	2300      	movs	r3, #0
 8010a50:	60bb      	str	r3, [r7, #8]
 8010a52:	e015      	b.n	8010a80 <PreFetchTd+0x3c>
        /* 256 elements, each one is 4 bytes */
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 8010a54:	2300      	movs	r3, #0
 8010a56:	607b      	str	r3, [r7, #4]
 8010a58:	e00c      	b.n	8010a74 <PreFetchTd+0x30>
            x &= Td[i][j];
 8010a5a:	490e      	ldr	r1, [pc, #56]	@ (8010a94 <PreFetchTd+0x50>)
 8010a5c:	68bb      	ldr	r3, [r7, #8]
 8010a5e:	021a      	lsls	r2, r3, #8
 8010a60:	687b      	ldr	r3, [r7, #4]
 8010a62:	4413      	add	r3, r2
 8010a64:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010a68:	68fa      	ldr	r2, [r7, #12]
 8010a6a:	4013      	ands	r3, r2
 8010a6c:	60fb      	str	r3, [r7, #12]
        for (j = 0; j < 256; j += WC_CACHE_LINE_SZ/4) {
 8010a6e:	687b      	ldr	r3, [r7, #4]
 8010a70:	3308      	adds	r3, #8
 8010a72:	607b      	str	r3, [r7, #4]
 8010a74:	687b      	ldr	r3, [r7, #4]
 8010a76:	2bff      	cmp	r3, #255	@ 0xff
 8010a78:	ddef      	ble.n	8010a5a <PreFetchTd+0x16>
    for (i = 0; i < 4; i++) {
 8010a7a:	68bb      	ldr	r3, [r7, #8]
 8010a7c:	3301      	adds	r3, #1
 8010a7e:	60bb      	str	r3, [r7, #8]
 8010a80:	68bb      	ldr	r3, [r7, #8]
 8010a82:	2b03      	cmp	r3, #3
 8010a84:	dde6      	ble.n	8010a54 <PreFetchTd+0x10>
        }
    }
    return x;
 8010a86:	68fb      	ldr	r3, [r7, #12]
}
 8010a88:	4618      	mov	r0, r3
 8010a8a:	3714      	adds	r7, #20
 8010a8c:	46bd      	mov	sp, r7
 8010a8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010a92:	4770      	bx	lr
 8010a94:	08032328 	.word	0x08032328

08010a98 <PreFetchTd4>:
#endif /* !WOLFSSL_AES_SMALL_TABLES */

/* load Td Table4 into cache by cache line stride */
static WARN_UNUSED_RESULT WC_INLINE word32 PreFetchTd4(void)
{
 8010a98:	b480      	push	{r7}
 8010a9a:	b083      	sub	sp, #12
 8010a9c:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_AES_TOUCH_LINES
    word32 x = 0;
 8010a9e:	2300      	movs	r3, #0
 8010aa0:	607b      	str	r3, [r7, #4]
    int i;

    for (i = 0; i < 256; i += WC_CACHE_LINE_SZ) {
 8010aa2:	2300      	movs	r3, #0
 8010aa4:	603b      	str	r3, [r7, #0]
 8010aa6:	e00a      	b.n	8010abe <PreFetchTd4+0x26>
        x &= (word32)Td4[i];
 8010aa8:	4a0a      	ldr	r2, [pc, #40]	@ (8010ad4 <PreFetchTd4+0x3c>)
 8010aaa:	683b      	ldr	r3, [r7, #0]
 8010aac:	4413      	add	r3, r2
 8010aae:	781b      	ldrb	r3, [r3, #0]
 8010ab0:	461a      	mov	r2, r3
 8010ab2:	687b      	ldr	r3, [r7, #4]
 8010ab4:	4013      	ands	r3, r2
 8010ab6:	607b      	str	r3, [r7, #4]
    for (i = 0; i < 256; i += WC_CACHE_LINE_SZ) {
 8010ab8:	683b      	ldr	r3, [r7, #0]
 8010aba:	3320      	adds	r3, #32
 8010abc:	603b      	str	r3, [r7, #0]
 8010abe:	683b      	ldr	r3, [r7, #0]
 8010ac0:	2bff      	cmp	r3, #255	@ 0xff
 8010ac2:	ddf1      	ble.n	8010aa8 <PreFetchTd4+0x10>
    }
    return x;
 8010ac4:	687b      	ldr	r3, [r7, #4]
#else
    return 0;
#endif
}
 8010ac6:	4618      	mov	r0, r3
 8010ac8:	370c      	adds	r7, #12
 8010aca:	46bd      	mov	sp, r7
 8010acc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ad0:	4770      	bx	lr
 8010ad2:	bf00      	nop
 8010ad4:	08033328 	.word	0x08033328

08010ad8 <AesDecrypt_C>:
 * @param [out] outBlock  Encrypted block.
 * @param [in]  r         Rounds divided by 2.
 */
static void AesDecrypt_C(Aes* aes, const byte* inBlock, byte* outBlock,
    word32 r)
{
 8010ad8:	b580      	push	{r7, lr}
 8010ada:	b08e      	sub	sp, #56	@ 0x38
 8010adc:	af00      	add	r7, sp, #0
 8010ade:	60f8      	str	r0, [r7, #12]
 8010ae0:	60b9      	str	r1, [r7, #8]
 8010ae2:	607a      	str	r2, [r7, #4]
 8010ae4:	603b      	str	r3, [r7, #0]
    const word32* rk;

#ifdef WC_C_DYNAMIC_FALLBACK
    rk = aes->key_C_fallback;
#else
    rk = aes->key;
 8010ae6:	68fb      	ldr	r3, [r7, #12]
 8010ae8:	627b      	str	r3, [r7, #36]	@ 0x24

    /*
     * map byte array block to cipher state
     * and add initial round key:
     */
    XMEMCPY(&s0, inBlock,                  sizeof(s0));
 8010aea:	68bb      	ldr	r3, [r7, #8]
 8010aec:	681b      	ldr	r3, [r3, #0]
 8010aee:	623b      	str	r3, [r7, #32]
    XMEMCPY(&s1, inBlock + sizeof(s0),     sizeof(s1));
 8010af0:	68bb      	ldr	r3, [r7, #8]
 8010af2:	3304      	adds	r3, #4
 8010af4:	681b      	ldr	r3, [r3, #0]
 8010af6:	61fb      	str	r3, [r7, #28]
    XMEMCPY(&s2, inBlock + 2 * sizeof(s0), sizeof(s2));
 8010af8:	68bb      	ldr	r3, [r7, #8]
 8010afa:	3308      	adds	r3, #8
 8010afc:	681b      	ldr	r3, [r3, #0]
 8010afe:	61bb      	str	r3, [r7, #24]
    XMEMCPY(&s3, inBlock + 3 * sizeof(s0), sizeof(s3));
 8010b00:	68bb      	ldr	r3, [r7, #8]
 8010b02:	330c      	adds	r3, #12
 8010b04:	681b      	ldr	r3, [r3, #0]
 8010b06:	617b      	str	r3, [r7, #20]

#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 8010b08:	6a3b      	ldr	r3, [r7, #32]
 8010b0a:	4618      	mov	r0, r3
 8010b0c:	f7fe fd73 	bl	800f5f6 <ByteReverseWord32>
 8010b10:	4603      	mov	r3, r0
 8010b12:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 8010b14:	69fb      	ldr	r3, [r7, #28]
 8010b16:	4618      	mov	r0, r3
 8010b18:	f7fe fd6d 	bl	800f5f6 <ByteReverseWord32>
 8010b1c:	4603      	mov	r3, r0
 8010b1e:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 8010b20:	69bb      	ldr	r3, [r7, #24]
 8010b22:	4618      	mov	r0, r3
 8010b24:	f7fe fd67 	bl	800f5f6 <ByteReverseWord32>
 8010b28:	4603      	mov	r3, r0
 8010b2a:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 8010b2c:	697b      	ldr	r3, [r7, #20]
 8010b2e:	4618      	mov	r0, r3
 8010b30:	f7fe fd61 	bl	800f5f6 <ByteReverseWord32>
 8010b34:	4603      	mov	r3, r0
 8010b36:	617b      	str	r3, [r7, #20]
#endif

    s0 ^= rk[0];
 8010b38:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010b3a:	681a      	ldr	r2, [r3, #0]
 8010b3c:	6a3b      	ldr	r3, [r7, #32]
 8010b3e:	4053      	eors	r3, r2
 8010b40:	623b      	str	r3, [r7, #32]
    s1 ^= rk[1];
 8010b42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010b44:	3304      	adds	r3, #4
 8010b46:	681a      	ldr	r2, [r3, #0]
 8010b48:	69fb      	ldr	r3, [r7, #28]
 8010b4a:	4053      	eors	r3, r2
 8010b4c:	61fb      	str	r3, [r7, #28]
    s2 ^= rk[2];
 8010b4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010b50:	3308      	adds	r3, #8
 8010b52:	681a      	ldr	r2, [r3, #0]
 8010b54:	69bb      	ldr	r3, [r7, #24]
 8010b56:	4053      	eors	r3, r2
 8010b58:	61bb      	str	r3, [r7, #24]
    s3 ^= rk[3];
 8010b5a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010b5c:	330c      	adds	r3, #12
 8010b5e:	681a      	ldr	r2, [r3, #0]
 8010b60:	697b      	ldr	r3, [r7, #20]
 8010b62:	4053      	eors	r3, r2
 8010b64:	617b      	str	r3, [r7, #20]

#ifndef WOLFSSL_AES_SMALL_TABLES
#ifndef WC_NO_CACHE_RESISTANT
    s0 |= PreFetchTd();
 8010b66:	f7ff ff6d 	bl	8010a44 <PreFetchTd>
 8010b6a:	4602      	mov	r2, r0
 8010b6c:	6a3b      	ldr	r3, [r7, #32]
 8010b6e:	4313      	orrs	r3, r2
 8010b70:	623b      	str	r3, [r7, #32]
                          &s2, GETBYTE(t3, 0), &s3, GETBYTE(t0, 0));           \
    s0 ^= rk[(o)+0]; s1 ^= rk[(o)+1]; s2 ^= rk[(o)+2]; s3 ^= rk[(o)+3];
#endif

#ifndef WOLFSSL_AES_NO_UNROLL
                       DEC_ROUND_T_S( 0);
 8010b72:	6a3b      	ldr	r3, [r7, #32]
 8010b74:	0e1b      	lsrs	r3, r3, #24
 8010b76:	b2db      	uxtb	r3, r3
 8010b78:	461a      	mov	r2, r3
 8010b7a:	4bb6      	ldr	r3, [pc, #728]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010b7c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010b80:	697b      	ldr	r3, [r7, #20]
 8010b82:	0c1b      	lsrs	r3, r3, #16
 8010b84:	b2db      	uxtb	r3, r3
 8010b86:	49b3      	ldr	r1, [pc, #716]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010b88:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010b8c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010b90:	405a      	eors	r2, r3
 8010b92:	69bb      	ldr	r3, [r7, #24]
 8010b94:	0a1b      	lsrs	r3, r3, #8
 8010b96:	b2db      	uxtb	r3, r3
 8010b98:	49ae      	ldr	r1, [pc, #696]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010b9a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010b9e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ba2:	405a      	eors	r2, r3
 8010ba4:	69fb      	ldr	r3, [r7, #28]
 8010ba6:	b2db      	uxtb	r3, r3
 8010ba8:	49aa      	ldr	r1, [pc, #680]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010baa:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010bae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010bb2:	405a      	eors	r2, r3
 8010bb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010bb6:	3310      	adds	r3, #16
 8010bb8:	681b      	ldr	r3, [r3, #0]
 8010bba:	4053      	eors	r3, r2
 8010bbc:	637b      	str	r3, [r7, #52]	@ 0x34
 8010bbe:	69fb      	ldr	r3, [r7, #28]
 8010bc0:	0e1b      	lsrs	r3, r3, #24
 8010bc2:	b2db      	uxtb	r3, r3
 8010bc4:	461a      	mov	r2, r3
 8010bc6:	4ba3      	ldr	r3, [pc, #652]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010bc8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010bcc:	6a3b      	ldr	r3, [r7, #32]
 8010bce:	0c1b      	lsrs	r3, r3, #16
 8010bd0:	b2db      	uxtb	r3, r3
 8010bd2:	49a0      	ldr	r1, [pc, #640]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010bd4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010bd8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010bdc:	405a      	eors	r2, r3
 8010bde:	697b      	ldr	r3, [r7, #20]
 8010be0:	0a1b      	lsrs	r3, r3, #8
 8010be2:	b2db      	uxtb	r3, r3
 8010be4:	499b      	ldr	r1, [pc, #620]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010be6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010bea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010bee:	405a      	eors	r2, r3
 8010bf0:	69bb      	ldr	r3, [r7, #24]
 8010bf2:	b2db      	uxtb	r3, r3
 8010bf4:	4997      	ldr	r1, [pc, #604]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010bf6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010bfa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010bfe:	405a      	eors	r2, r3
 8010c00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010c02:	3314      	adds	r3, #20
 8010c04:	681b      	ldr	r3, [r3, #0]
 8010c06:	4053      	eors	r3, r2
 8010c08:	633b      	str	r3, [r7, #48]	@ 0x30
 8010c0a:	69bb      	ldr	r3, [r7, #24]
 8010c0c:	0e1b      	lsrs	r3, r3, #24
 8010c0e:	b2db      	uxtb	r3, r3
 8010c10:	461a      	mov	r2, r3
 8010c12:	4b90      	ldr	r3, [pc, #576]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010c14:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010c18:	69fb      	ldr	r3, [r7, #28]
 8010c1a:	0c1b      	lsrs	r3, r3, #16
 8010c1c:	b2db      	uxtb	r3, r3
 8010c1e:	498d      	ldr	r1, [pc, #564]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010c20:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010c24:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c28:	405a      	eors	r2, r3
 8010c2a:	6a3b      	ldr	r3, [r7, #32]
 8010c2c:	0a1b      	lsrs	r3, r3, #8
 8010c2e:	b2db      	uxtb	r3, r3
 8010c30:	4988      	ldr	r1, [pc, #544]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010c32:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010c36:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c3a:	405a      	eors	r2, r3
 8010c3c:	697b      	ldr	r3, [r7, #20]
 8010c3e:	b2db      	uxtb	r3, r3
 8010c40:	4984      	ldr	r1, [pc, #528]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010c42:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010c46:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c4a:	405a      	eors	r2, r3
 8010c4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010c4e:	3318      	adds	r3, #24
 8010c50:	681b      	ldr	r3, [r3, #0]
 8010c52:	4053      	eors	r3, r2
 8010c54:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010c56:	697b      	ldr	r3, [r7, #20]
 8010c58:	0e1b      	lsrs	r3, r3, #24
 8010c5a:	b2db      	uxtb	r3, r3
 8010c5c:	461a      	mov	r2, r3
 8010c5e:	4b7d      	ldr	r3, [pc, #500]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010c60:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010c64:	69bb      	ldr	r3, [r7, #24]
 8010c66:	0c1b      	lsrs	r3, r3, #16
 8010c68:	b2db      	uxtb	r3, r3
 8010c6a:	497a      	ldr	r1, [pc, #488]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010c6c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010c70:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c74:	405a      	eors	r2, r3
 8010c76:	69fb      	ldr	r3, [r7, #28]
 8010c78:	0a1b      	lsrs	r3, r3, #8
 8010c7a:	b2db      	uxtb	r3, r3
 8010c7c:	4975      	ldr	r1, [pc, #468]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010c7e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010c82:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c86:	405a      	eors	r2, r3
 8010c88:	6a3b      	ldr	r3, [r7, #32]
 8010c8a:	b2db      	uxtb	r3, r3
 8010c8c:	4971      	ldr	r1, [pc, #452]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010c8e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010c92:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010c96:	405a      	eors	r2, r3
 8010c98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010c9a:	331c      	adds	r3, #28
 8010c9c:	681b      	ldr	r3, [r3, #0]
 8010c9e:	4053      	eors	r3, r2
 8010ca0:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T( 8); DEC_ROUND_T_S( 8);
 8010ca2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010ca4:	0e1b      	lsrs	r3, r3, #24
 8010ca6:	b2db      	uxtb	r3, r3
 8010ca8:	461a      	mov	r2, r3
 8010caa:	4b6a      	ldr	r3, [pc, #424]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010cac:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010cb0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010cb2:	0c1b      	lsrs	r3, r3, #16
 8010cb4:	b2db      	uxtb	r3, r3
 8010cb6:	4967      	ldr	r1, [pc, #412]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010cb8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010cbc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010cc0:	405a      	eors	r2, r3
 8010cc2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010cc4:	0a1b      	lsrs	r3, r3, #8
 8010cc6:	b2db      	uxtb	r3, r3
 8010cc8:	4962      	ldr	r1, [pc, #392]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010cca:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010cce:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010cd2:	405a      	eors	r2, r3
 8010cd4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010cd6:	b2db      	uxtb	r3, r3
 8010cd8:	495e      	ldr	r1, [pc, #376]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010cda:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010cde:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ce2:	405a      	eors	r2, r3
 8010ce4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010ce6:	3320      	adds	r3, #32
 8010ce8:	681b      	ldr	r3, [r3, #0]
 8010cea:	4053      	eors	r3, r2
 8010cec:	623b      	str	r3, [r7, #32]
 8010cee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010cf0:	0e1b      	lsrs	r3, r3, #24
 8010cf2:	b2db      	uxtb	r3, r3
 8010cf4:	461a      	mov	r2, r3
 8010cf6:	4b57      	ldr	r3, [pc, #348]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010cf8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010cfc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010cfe:	0c1b      	lsrs	r3, r3, #16
 8010d00:	b2db      	uxtb	r3, r3
 8010d02:	4954      	ldr	r1, [pc, #336]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010d04:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010d08:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d0c:	405a      	eors	r2, r3
 8010d0e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010d10:	0a1b      	lsrs	r3, r3, #8
 8010d12:	b2db      	uxtb	r3, r3
 8010d14:	494f      	ldr	r1, [pc, #316]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010d16:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010d1a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d1e:	405a      	eors	r2, r3
 8010d20:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010d22:	b2db      	uxtb	r3, r3
 8010d24:	494b      	ldr	r1, [pc, #300]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010d26:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010d2a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d2e:	405a      	eors	r2, r3
 8010d30:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010d32:	3324      	adds	r3, #36	@ 0x24
 8010d34:	681b      	ldr	r3, [r3, #0]
 8010d36:	4053      	eors	r3, r2
 8010d38:	61fb      	str	r3, [r7, #28]
 8010d3a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010d3c:	0e1b      	lsrs	r3, r3, #24
 8010d3e:	b2db      	uxtb	r3, r3
 8010d40:	461a      	mov	r2, r3
 8010d42:	4b44      	ldr	r3, [pc, #272]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010d44:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010d48:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010d4a:	0c1b      	lsrs	r3, r3, #16
 8010d4c:	b2db      	uxtb	r3, r3
 8010d4e:	4941      	ldr	r1, [pc, #260]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010d50:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010d54:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d58:	405a      	eors	r2, r3
 8010d5a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010d5c:	0a1b      	lsrs	r3, r3, #8
 8010d5e:	b2db      	uxtb	r3, r3
 8010d60:	493c      	ldr	r1, [pc, #240]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010d62:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010d66:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d6a:	405a      	eors	r2, r3
 8010d6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010d6e:	b2db      	uxtb	r3, r3
 8010d70:	4938      	ldr	r1, [pc, #224]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010d72:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010d76:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010d7a:	405a      	eors	r2, r3
 8010d7c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010d7e:	3328      	adds	r3, #40	@ 0x28
 8010d80:	681b      	ldr	r3, [r3, #0]
 8010d82:	4053      	eors	r3, r2
 8010d84:	61bb      	str	r3, [r7, #24]
 8010d86:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010d88:	0e1b      	lsrs	r3, r3, #24
 8010d8a:	b2db      	uxtb	r3, r3
 8010d8c:	461a      	mov	r2, r3
 8010d8e:	4b31      	ldr	r3, [pc, #196]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010d90:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010d94:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010d96:	0c1b      	lsrs	r3, r3, #16
 8010d98:	b2db      	uxtb	r3, r3
 8010d9a:	492e      	ldr	r1, [pc, #184]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010d9c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010da0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010da4:	405a      	eors	r2, r3
 8010da6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010da8:	0a1b      	lsrs	r3, r3, #8
 8010daa:	b2db      	uxtb	r3, r3
 8010dac:	4929      	ldr	r1, [pc, #164]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010dae:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010db2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010db6:	405a      	eors	r2, r3
 8010db8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010dba:	b2db      	uxtb	r3, r3
 8010dbc:	4925      	ldr	r1, [pc, #148]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010dbe:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010dc2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010dc6:	405a      	eors	r2, r3
 8010dc8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010dca:	332c      	adds	r3, #44	@ 0x2c
 8010dcc:	681b      	ldr	r3, [r3, #0]
 8010dce:	4053      	eors	r3, r2
 8010dd0:	617b      	str	r3, [r7, #20]
 8010dd2:	6a3b      	ldr	r3, [r7, #32]
 8010dd4:	0e1b      	lsrs	r3, r3, #24
 8010dd6:	b2db      	uxtb	r3, r3
 8010dd8:	461a      	mov	r2, r3
 8010dda:	4b1e      	ldr	r3, [pc, #120]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010ddc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010de0:	697b      	ldr	r3, [r7, #20]
 8010de2:	0c1b      	lsrs	r3, r3, #16
 8010de4:	b2db      	uxtb	r3, r3
 8010de6:	491b      	ldr	r1, [pc, #108]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010de8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010dec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010df0:	405a      	eors	r2, r3
 8010df2:	69bb      	ldr	r3, [r7, #24]
 8010df4:	0a1b      	lsrs	r3, r3, #8
 8010df6:	b2db      	uxtb	r3, r3
 8010df8:	4916      	ldr	r1, [pc, #88]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010dfa:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010dfe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e02:	405a      	eors	r2, r3
 8010e04:	69fb      	ldr	r3, [r7, #28]
 8010e06:	b2db      	uxtb	r3, r3
 8010e08:	4912      	ldr	r1, [pc, #72]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010e0a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010e0e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e12:	405a      	eors	r2, r3
 8010e14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010e16:	3330      	adds	r3, #48	@ 0x30
 8010e18:	681b      	ldr	r3, [r3, #0]
 8010e1a:	4053      	eors	r3, r2
 8010e1c:	637b      	str	r3, [r7, #52]	@ 0x34
 8010e1e:	69fb      	ldr	r3, [r7, #28]
 8010e20:	0e1b      	lsrs	r3, r3, #24
 8010e22:	b2db      	uxtb	r3, r3
 8010e24:	461a      	mov	r2, r3
 8010e26:	4b0b      	ldr	r3, [pc, #44]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010e28:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010e2c:	6a3b      	ldr	r3, [r7, #32]
 8010e2e:	0c1b      	lsrs	r3, r3, #16
 8010e30:	b2db      	uxtb	r3, r3
 8010e32:	4908      	ldr	r1, [pc, #32]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010e34:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010e38:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e3c:	405a      	eors	r2, r3
 8010e3e:	697b      	ldr	r3, [r7, #20]
 8010e40:	0a1b      	lsrs	r3, r3, #8
 8010e42:	b2db      	uxtb	r3, r3
 8010e44:	4903      	ldr	r1, [pc, #12]	@ (8010e54 <AesDecrypt_C+0x37c>)
 8010e46:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010e4a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e4e:	405a      	eors	r2, r3
 8010e50:	69bb      	ldr	r3, [r7, #24]
 8010e52:	e001      	b.n	8010e58 <AesDecrypt_C+0x380>
 8010e54:	08032328 	.word	0x08032328
 8010e58:	b2db      	uxtb	r3, r3
 8010e5a:	49b6      	ldr	r1, [pc, #728]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010e5c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010e60:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e64:	405a      	eors	r2, r3
 8010e66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010e68:	3334      	adds	r3, #52	@ 0x34
 8010e6a:	681b      	ldr	r3, [r3, #0]
 8010e6c:	4053      	eors	r3, r2
 8010e6e:	633b      	str	r3, [r7, #48]	@ 0x30
 8010e70:	69bb      	ldr	r3, [r7, #24]
 8010e72:	0e1b      	lsrs	r3, r3, #24
 8010e74:	b2db      	uxtb	r3, r3
 8010e76:	461a      	mov	r2, r3
 8010e78:	4bae      	ldr	r3, [pc, #696]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010e7a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010e7e:	69fb      	ldr	r3, [r7, #28]
 8010e80:	0c1b      	lsrs	r3, r3, #16
 8010e82:	b2db      	uxtb	r3, r3
 8010e84:	49ab      	ldr	r1, [pc, #684]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010e86:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010e8a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010e8e:	405a      	eors	r2, r3
 8010e90:	6a3b      	ldr	r3, [r7, #32]
 8010e92:	0a1b      	lsrs	r3, r3, #8
 8010e94:	b2db      	uxtb	r3, r3
 8010e96:	49a7      	ldr	r1, [pc, #668]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010e98:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010e9c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010ea0:	405a      	eors	r2, r3
 8010ea2:	697b      	ldr	r3, [r7, #20]
 8010ea4:	b2db      	uxtb	r3, r3
 8010ea6:	49a3      	ldr	r1, [pc, #652]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010ea8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010eac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010eb0:	405a      	eors	r2, r3
 8010eb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010eb4:	3338      	adds	r3, #56	@ 0x38
 8010eb6:	681b      	ldr	r3, [r3, #0]
 8010eb8:	4053      	eors	r3, r2
 8010eba:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010ebc:	697b      	ldr	r3, [r7, #20]
 8010ebe:	0e1b      	lsrs	r3, r3, #24
 8010ec0:	b2db      	uxtb	r3, r3
 8010ec2:	461a      	mov	r2, r3
 8010ec4:	4b9b      	ldr	r3, [pc, #620]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010ec6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010eca:	69bb      	ldr	r3, [r7, #24]
 8010ecc:	0c1b      	lsrs	r3, r3, #16
 8010ece:	b2db      	uxtb	r3, r3
 8010ed0:	4998      	ldr	r1, [pc, #608]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010ed2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010ed6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010eda:	405a      	eors	r2, r3
 8010edc:	69fb      	ldr	r3, [r7, #28]
 8010ede:	0a1b      	lsrs	r3, r3, #8
 8010ee0:	b2db      	uxtb	r3, r3
 8010ee2:	4994      	ldr	r1, [pc, #592]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010ee4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010ee8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010eec:	405a      	eors	r2, r3
 8010eee:	6a3b      	ldr	r3, [r7, #32]
 8010ef0:	b2db      	uxtb	r3, r3
 8010ef2:	4990      	ldr	r1, [pc, #576]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010ef4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010ef8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010efc:	405a      	eors	r2, r3
 8010efe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010f00:	333c      	adds	r3, #60	@ 0x3c
 8010f02:	681b      	ldr	r3, [r3, #0]
 8010f04:	4053      	eors	r3, r2
 8010f06:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T(16); DEC_ROUND_T_S(16);
 8010f08:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010f0a:	0e1b      	lsrs	r3, r3, #24
 8010f0c:	b2db      	uxtb	r3, r3
 8010f0e:	461a      	mov	r2, r3
 8010f10:	4b88      	ldr	r3, [pc, #544]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010f12:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010f16:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010f18:	0c1b      	lsrs	r3, r3, #16
 8010f1a:	b2db      	uxtb	r3, r3
 8010f1c:	4985      	ldr	r1, [pc, #532]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010f1e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010f22:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f26:	405a      	eors	r2, r3
 8010f28:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010f2a:	0a1b      	lsrs	r3, r3, #8
 8010f2c:	b2db      	uxtb	r3, r3
 8010f2e:	4981      	ldr	r1, [pc, #516]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010f30:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010f34:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f38:	405a      	eors	r2, r3
 8010f3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f3c:	b2db      	uxtb	r3, r3
 8010f3e:	497d      	ldr	r1, [pc, #500]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010f40:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010f44:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f48:	405a      	eors	r2, r3
 8010f4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010f4c:	3340      	adds	r3, #64	@ 0x40
 8010f4e:	681b      	ldr	r3, [r3, #0]
 8010f50:	4053      	eors	r3, r2
 8010f52:	623b      	str	r3, [r7, #32]
 8010f54:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f56:	0e1b      	lsrs	r3, r3, #24
 8010f58:	b2db      	uxtb	r3, r3
 8010f5a:	461a      	mov	r2, r3
 8010f5c:	4b75      	ldr	r3, [pc, #468]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010f5e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010f62:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010f64:	0c1b      	lsrs	r3, r3, #16
 8010f66:	b2db      	uxtb	r3, r3
 8010f68:	4972      	ldr	r1, [pc, #456]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010f6a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010f6e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f72:	405a      	eors	r2, r3
 8010f74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010f76:	0a1b      	lsrs	r3, r3, #8
 8010f78:	b2db      	uxtb	r3, r3
 8010f7a:	496e      	ldr	r1, [pc, #440]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010f7c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010f80:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f84:	405a      	eors	r2, r3
 8010f86:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010f88:	b2db      	uxtb	r3, r3
 8010f8a:	496a      	ldr	r1, [pc, #424]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010f8c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010f90:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010f94:	405a      	eors	r2, r3
 8010f96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010f98:	3344      	adds	r3, #68	@ 0x44
 8010f9a:	681b      	ldr	r3, [r3, #0]
 8010f9c:	4053      	eors	r3, r2
 8010f9e:	61fb      	str	r3, [r7, #28]
 8010fa0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010fa2:	0e1b      	lsrs	r3, r3, #24
 8010fa4:	b2db      	uxtb	r3, r3
 8010fa6:	461a      	mov	r2, r3
 8010fa8:	4b62      	ldr	r3, [pc, #392]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010faa:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010fae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010fb0:	0c1b      	lsrs	r3, r3, #16
 8010fb2:	b2db      	uxtb	r3, r3
 8010fb4:	495f      	ldr	r1, [pc, #380]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010fb6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8010fba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010fbe:	405a      	eors	r2, r3
 8010fc0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010fc2:	0a1b      	lsrs	r3, r3, #8
 8010fc4:	b2db      	uxtb	r3, r3
 8010fc6:	495b      	ldr	r1, [pc, #364]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010fc8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8010fcc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010fd0:	405a      	eors	r2, r3
 8010fd2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010fd4:	b2db      	uxtb	r3, r3
 8010fd6:	4957      	ldr	r1, [pc, #348]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010fd8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8010fdc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8010fe0:	405a      	eors	r2, r3
 8010fe2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010fe4:	3348      	adds	r3, #72	@ 0x48
 8010fe6:	681b      	ldr	r3, [r3, #0]
 8010fe8:	4053      	eors	r3, r2
 8010fea:	61bb      	str	r3, [r7, #24]
 8010fec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010fee:	0e1b      	lsrs	r3, r3, #24
 8010ff0:	b2db      	uxtb	r3, r3
 8010ff2:	461a      	mov	r2, r3
 8010ff4:	4b4f      	ldr	r3, [pc, #316]	@ (8011134 <AesDecrypt_C+0x65c>)
 8010ff6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010ffa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010ffc:	0c1b      	lsrs	r3, r3, #16
 8010ffe:	b2db      	uxtb	r3, r3
 8011000:	494c      	ldr	r1, [pc, #304]	@ (8011134 <AesDecrypt_C+0x65c>)
 8011002:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011006:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801100a:	405a      	eors	r2, r3
 801100c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801100e:	0a1b      	lsrs	r3, r3, #8
 8011010:	b2db      	uxtb	r3, r3
 8011012:	4948      	ldr	r1, [pc, #288]	@ (8011134 <AesDecrypt_C+0x65c>)
 8011014:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011018:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801101c:	405a      	eors	r2, r3
 801101e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011020:	b2db      	uxtb	r3, r3
 8011022:	4944      	ldr	r1, [pc, #272]	@ (8011134 <AesDecrypt_C+0x65c>)
 8011024:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011028:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801102c:	405a      	eors	r2, r3
 801102e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011030:	334c      	adds	r3, #76	@ 0x4c
 8011032:	681b      	ldr	r3, [r3, #0]
 8011034:	4053      	eors	r3, r2
 8011036:	617b      	str	r3, [r7, #20]
 8011038:	6a3b      	ldr	r3, [r7, #32]
 801103a:	0e1b      	lsrs	r3, r3, #24
 801103c:	b2db      	uxtb	r3, r3
 801103e:	461a      	mov	r2, r3
 8011040:	4b3c      	ldr	r3, [pc, #240]	@ (8011134 <AesDecrypt_C+0x65c>)
 8011042:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011046:	697b      	ldr	r3, [r7, #20]
 8011048:	0c1b      	lsrs	r3, r3, #16
 801104a:	b2db      	uxtb	r3, r3
 801104c:	4939      	ldr	r1, [pc, #228]	@ (8011134 <AesDecrypt_C+0x65c>)
 801104e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011052:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011056:	405a      	eors	r2, r3
 8011058:	69bb      	ldr	r3, [r7, #24]
 801105a:	0a1b      	lsrs	r3, r3, #8
 801105c:	b2db      	uxtb	r3, r3
 801105e:	4935      	ldr	r1, [pc, #212]	@ (8011134 <AesDecrypt_C+0x65c>)
 8011060:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011064:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011068:	405a      	eors	r2, r3
 801106a:	69fb      	ldr	r3, [r7, #28]
 801106c:	b2db      	uxtb	r3, r3
 801106e:	4931      	ldr	r1, [pc, #196]	@ (8011134 <AesDecrypt_C+0x65c>)
 8011070:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011074:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011078:	405a      	eors	r2, r3
 801107a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801107c:	3350      	adds	r3, #80	@ 0x50
 801107e:	681b      	ldr	r3, [r3, #0]
 8011080:	4053      	eors	r3, r2
 8011082:	637b      	str	r3, [r7, #52]	@ 0x34
 8011084:	69fb      	ldr	r3, [r7, #28]
 8011086:	0e1b      	lsrs	r3, r3, #24
 8011088:	b2db      	uxtb	r3, r3
 801108a:	461a      	mov	r2, r3
 801108c:	4b29      	ldr	r3, [pc, #164]	@ (8011134 <AesDecrypt_C+0x65c>)
 801108e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011092:	6a3b      	ldr	r3, [r7, #32]
 8011094:	0c1b      	lsrs	r3, r3, #16
 8011096:	b2db      	uxtb	r3, r3
 8011098:	4926      	ldr	r1, [pc, #152]	@ (8011134 <AesDecrypt_C+0x65c>)
 801109a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801109e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110a2:	405a      	eors	r2, r3
 80110a4:	697b      	ldr	r3, [r7, #20]
 80110a6:	0a1b      	lsrs	r3, r3, #8
 80110a8:	b2db      	uxtb	r3, r3
 80110aa:	4922      	ldr	r1, [pc, #136]	@ (8011134 <AesDecrypt_C+0x65c>)
 80110ac:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80110b0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110b4:	405a      	eors	r2, r3
 80110b6:	69bb      	ldr	r3, [r7, #24]
 80110b8:	b2db      	uxtb	r3, r3
 80110ba:	491e      	ldr	r1, [pc, #120]	@ (8011134 <AesDecrypt_C+0x65c>)
 80110bc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80110c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110c4:	405a      	eors	r2, r3
 80110c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80110c8:	3354      	adds	r3, #84	@ 0x54
 80110ca:	681b      	ldr	r3, [r3, #0]
 80110cc:	4053      	eors	r3, r2
 80110ce:	633b      	str	r3, [r7, #48]	@ 0x30
 80110d0:	69bb      	ldr	r3, [r7, #24]
 80110d2:	0e1b      	lsrs	r3, r3, #24
 80110d4:	b2db      	uxtb	r3, r3
 80110d6:	461a      	mov	r2, r3
 80110d8:	4b16      	ldr	r3, [pc, #88]	@ (8011134 <AesDecrypt_C+0x65c>)
 80110da:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80110de:	69fb      	ldr	r3, [r7, #28]
 80110e0:	0c1b      	lsrs	r3, r3, #16
 80110e2:	b2db      	uxtb	r3, r3
 80110e4:	4913      	ldr	r1, [pc, #76]	@ (8011134 <AesDecrypt_C+0x65c>)
 80110e6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80110ea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80110ee:	405a      	eors	r2, r3
 80110f0:	6a3b      	ldr	r3, [r7, #32]
 80110f2:	0a1b      	lsrs	r3, r3, #8
 80110f4:	b2db      	uxtb	r3, r3
 80110f6:	490f      	ldr	r1, [pc, #60]	@ (8011134 <AesDecrypt_C+0x65c>)
 80110f8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80110fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011100:	405a      	eors	r2, r3
 8011102:	697b      	ldr	r3, [r7, #20]
 8011104:	b2db      	uxtb	r3, r3
 8011106:	490b      	ldr	r1, [pc, #44]	@ (8011134 <AesDecrypt_C+0x65c>)
 8011108:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801110c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011110:	405a      	eors	r2, r3
 8011112:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011114:	3358      	adds	r3, #88	@ 0x58
 8011116:	681b      	ldr	r3, [r3, #0]
 8011118:	4053      	eors	r3, r2
 801111a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801111c:	697b      	ldr	r3, [r7, #20]
 801111e:	0e1b      	lsrs	r3, r3, #24
 8011120:	b2db      	uxtb	r3, r3
 8011122:	461a      	mov	r2, r3
 8011124:	4b03      	ldr	r3, [pc, #12]	@ (8011134 <AesDecrypt_C+0x65c>)
 8011126:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801112a:	69bb      	ldr	r3, [r7, #24]
 801112c:	0c1b      	lsrs	r3, r3, #16
 801112e:	b2db      	uxtb	r3, r3
 8011130:	e002      	b.n	8011138 <AesDecrypt_C+0x660>
 8011132:	bf00      	nop
 8011134:	08032328 	.word	0x08032328
 8011138:	49b6      	ldr	r1, [pc, #728]	@ (8011414 <AesDecrypt_C+0x93c>)
 801113a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801113e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011142:	405a      	eors	r2, r3
 8011144:	69fb      	ldr	r3, [r7, #28]
 8011146:	0a1b      	lsrs	r3, r3, #8
 8011148:	b2db      	uxtb	r3, r3
 801114a:	49b2      	ldr	r1, [pc, #712]	@ (8011414 <AesDecrypt_C+0x93c>)
 801114c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011150:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011154:	405a      	eors	r2, r3
 8011156:	6a3b      	ldr	r3, [r7, #32]
 8011158:	b2db      	uxtb	r3, r3
 801115a:	49ae      	ldr	r1, [pc, #696]	@ (8011414 <AesDecrypt_C+0x93c>)
 801115c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011160:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011164:	405a      	eors	r2, r3
 8011166:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011168:	335c      	adds	r3, #92	@ 0x5c
 801116a:	681b      	ldr	r3, [r3, #0]
 801116c:	4053      	eors	r3, r2
 801116e:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T(24); DEC_ROUND_T_S(24);
 8011170:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011172:	0e1b      	lsrs	r3, r3, #24
 8011174:	b2db      	uxtb	r3, r3
 8011176:	461a      	mov	r2, r3
 8011178:	4ba6      	ldr	r3, [pc, #664]	@ (8011414 <AesDecrypt_C+0x93c>)
 801117a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801117e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011180:	0c1b      	lsrs	r3, r3, #16
 8011182:	b2db      	uxtb	r3, r3
 8011184:	49a3      	ldr	r1, [pc, #652]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011186:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801118a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801118e:	405a      	eors	r2, r3
 8011190:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011192:	0a1b      	lsrs	r3, r3, #8
 8011194:	b2db      	uxtb	r3, r3
 8011196:	499f      	ldr	r1, [pc, #636]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011198:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801119c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111a0:	405a      	eors	r2, r3
 80111a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80111a4:	b2db      	uxtb	r3, r3
 80111a6:	499b      	ldr	r1, [pc, #620]	@ (8011414 <AesDecrypt_C+0x93c>)
 80111a8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80111ac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111b0:	405a      	eors	r2, r3
 80111b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80111b4:	3360      	adds	r3, #96	@ 0x60
 80111b6:	681b      	ldr	r3, [r3, #0]
 80111b8:	4053      	eors	r3, r2
 80111ba:	623b      	str	r3, [r7, #32]
 80111bc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80111be:	0e1b      	lsrs	r3, r3, #24
 80111c0:	b2db      	uxtb	r3, r3
 80111c2:	461a      	mov	r2, r3
 80111c4:	4b93      	ldr	r3, [pc, #588]	@ (8011414 <AesDecrypt_C+0x93c>)
 80111c6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80111ca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80111cc:	0c1b      	lsrs	r3, r3, #16
 80111ce:	b2db      	uxtb	r3, r3
 80111d0:	4990      	ldr	r1, [pc, #576]	@ (8011414 <AesDecrypt_C+0x93c>)
 80111d2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80111d6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111da:	405a      	eors	r2, r3
 80111dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80111de:	0a1b      	lsrs	r3, r3, #8
 80111e0:	b2db      	uxtb	r3, r3
 80111e2:	498c      	ldr	r1, [pc, #560]	@ (8011414 <AesDecrypt_C+0x93c>)
 80111e4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80111e8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111ec:	405a      	eors	r2, r3
 80111ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80111f0:	b2db      	uxtb	r3, r3
 80111f2:	4988      	ldr	r1, [pc, #544]	@ (8011414 <AesDecrypt_C+0x93c>)
 80111f4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80111f8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80111fc:	405a      	eors	r2, r3
 80111fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011200:	3364      	adds	r3, #100	@ 0x64
 8011202:	681b      	ldr	r3, [r3, #0]
 8011204:	4053      	eors	r3, r2
 8011206:	61fb      	str	r3, [r7, #28]
 8011208:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801120a:	0e1b      	lsrs	r3, r3, #24
 801120c:	b2db      	uxtb	r3, r3
 801120e:	461a      	mov	r2, r3
 8011210:	4b80      	ldr	r3, [pc, #512]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011212:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011216:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011218:	0c1b      	lsrs	r3, r3, #16
 801121a:	b2db      	uxtb	r3, r3
 801121c:	497d      	ldr	r1, [pc, #500]	@ (8011414 <AesDecrypt_C+0x93c>)
 801121e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011222:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011226:	405a      	eors	r2, r3
 8011228:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801122a:	0a1b      	lsrs	r3, r3, #8
 801122c:	b2db      	uxtb	r3, r3
 801122e:	4979      	ldr	r1, [pc, #484]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011230:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011234:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011238:	405a      	eors	r2, r3
 801123a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801123c:	b2db      	uxtb	r3, r3
 801123e:	4975      	ldr	r1, [pc, #468]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011240:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011244:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011248:	405a      	eors	r2, r3
 801124a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801124c:	3368      	adds	r3, #104	@ 0x68
 801124e:	681b      	ldr	r3, [r3, #0]
 8011250:	4053      	eors	r3, r2
 8011252:	61bb      	str	r3, [r7, #24]
 8011254:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011256:	0e1b      	lsrs	r3, r3, #24
 8011258:	b2db      	uxtb	r3, r3
 801125a:	461a      	mov	r2, r3
 801125c:	4b6d      	ldr	r3, [pc, #436]	@ (8011414 <AesDecrypt_C+0x93c>)
 801125e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011262:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011264:	0c1b      	lsrs	r3, r3, #16
 8011266:	b2db      	uxtb	r3, r3
 8011268:	496a      	ldr	r1, [pc, #424]	@ (8011414 <AesDecrypt_C+0x93c>)
 801126a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801126e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011272:	405a      	eors	r2, r3
 8011274:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011276:	0a1b      	lsrs	r3, r3, #8
 8011278:	b2db      	uxtb	r3, r3
 801127a:	4966      	ldr	r1, [pc, #408]	@ (8011414 <AesDecrypt_C+0x93c>)
 801127c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011280:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011284:	405a      	eors	r2, r3
 8011286:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011288:	b2db      	uxtb	r3, r3
 801128a:	4962      	ldr	r1, [pc, #392]	@ (8011414 <AesDecrypt_C+0x93c>)
 801128c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011290:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011294:	405a      	eors	r2, r3
 8011296:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011298:	336c      	adds	r3, #108	@ 0x6c
 801129a:	681b      	ldr	r3, [r3, #0]
 801129c:	4053      	eors	r3, r2
 801129e:	617b      	str	r3, [r7, #20]
 80112a0:	6a3b      	ldr	r3, [r7, #32]
 80112a2:	0e1b      	lsrs	r3, r3, #24
 80112a4:	b2db      	uxtb	r3, r3
 80112a6:	461a      	mov	r2, r3
 80112a8:	4b5a      	ldr	r3, [pc, #360]	@ (8011414 <AesDecrypt_C+0x93c>)
 80112aa:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80112ae:	697b      	ldr	r3, [r7, #20]
 80112b0:	0c1b      	lsrs	r3, r3, #16
 80112b2:	b2db      	uxtb	r3, r3
 80112b4:	4957      	ldr	r1, [pc, #348]	@ (8011414 <AesDecrypt_C+0x93c>)
 80112b6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80112ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112be:	405a      	eors	r2, r3
 80112c0:	69bb      	ldr	r3, [r7, #24]
 80112c2:	0a1b      	lsrs	r3, r3, #8
 80112c4:	b2db      	uxtb	r3, r3
 80112c6:	4953      	ldr	r1, [pc, #332]	@ (8011414 <AesDecrypt_C+0x93c>)
 80112c8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80112cc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112d0:	405a      	eors	r2, r3
 80112d2:	69fb      	ldr	r3, [r7, #28]
 80112d4:	b2db      	uxtb	r3, r3
 80112d6:	494f      	ldr	r1, [pc, #316]	@ (8011414 <AesDecrypt_C+0x93c>)
 80112d8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80112dc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80112e0:	405a      	eors	r2, r3
 80112e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80112e4:	3370      	adds	r3, #112	@ 0x70
 80112e6:	681b      	ldr	r3, [r3, #0]
 80112e8:	4053      	eors	r3, r2
 80112ea:	637b      	str	r3, [r7, #52]	@ 0x34
 80112ec:	69fb      	ldr	r3, [r7, #28]
 80112ee:	0e1b      	lsrs	r3, r3, #24
 80112f0:	b2db      	uxtb	r3, r3
 80112f2:	461a      	mov	r2, r3
 80112f4:	4b47      	ldr	r3, [pc, #284]	@ (8011414 <AesDecrypt_C+0x93c>)
 80112f6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80112fa:	6a3b      	ldr	r3, [r7, #32]
 80112fc:	0c1b      	lsrs	r3, r3, #16
 80112fe:	b2db      	uxtb	r3, r3
 8011300:	4944      	ldr	r1, [pc, #272]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011302:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011306:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801130a:	405a      	eors	r2, r3
 801130c:	697b      	ldr	r3, [r7, #20]
 801130e:	0a1b      	lsrs	r3, r3, #8
 8011310:	b2db      	uxtb	r3, r3
 8011312:	4940      	ldr	r1, [pc, #256]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011314:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011318:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801131c:	405a      	eors	r2, r3
 801131e:	69bb      	ldr	r3, [r7, #24]
 8011320:	b2db      	uxtb	r3, r3
 8011322:	493c      	ldr	r1, [pc, #240]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011324:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011328:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801132c:	405a      	eors	r2, r3
 801132e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011330:	3374      	adds	r3, #116	@ 0x74
 8011332:	681b      	ldr	r3, [r3, #0]
 8011334:	4053      	eors	r3, r2
 8011336:	633b      	str	r3, [r7, #48]	@ 0x30
 8011338:	69bb      	ldr	r3, [r7, #24]
 801133a:	0e1b      	lsrs	r3, r3, #24
 801133c:	b2db      	uxtb	r3, r3
 801133e:	461a      	mov	r2, r3
 8011340:	4b34      	ldr	r3, [pc, #208]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011342:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011346:	69fb      	ldr	r3, [r7, #28]
 8011348:	0c1b      	lsrs	r3, r3, #16
 801134a:	b2db      	uxtb	r3, r3
 801134c:	4931      	ldr	r1, [pc, #196]	@ (8011414 <AesDecrypt_C+0x93c>)
 801134e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011352:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011356:	405a      	eors	r2, r3
 8011358:	6a3b      	ldr	r3, [r7, #32]
 801135a:	0a1b      	lsrs	r3, r3, #8
 801135c:	b2db      	uxtb	r3, r3
 801135e:	492d      	ldr	r1, [pc, #180]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011360:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011364:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011368:	405a      	eors	r2, r3
 801136a:	697b      	ldr	r3, [r7, #20]
 801136c:	b2db      	uxtb	r3, r3
 801136e:	4929      	ldr	r1, [pc, #164]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011370:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011374:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011378:	405a      	eors	r2, r3
 801137a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801137c:	3378      	adds	r3, #120	@ 0x78
 801137e:	681b      	ldr	r3, [r3, #0]
 8011380:	4053      	eors	r3, r2
 8011382:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011384:	697b      	ldr	r3, [r7, #20]
 8011386:	0e1b      	lsrs	r3, r3, #24
 8011388:	b2db      	uxtb	r3, r3
 801138a:	461a      	mov	r2, r3
 801138c:	4b21      	ldr	r3, [pc, #132]	@ (8011414 <AesDecrypt_C+0x93c>)
 801138e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011392:	69bb      	ldr	r3, [r7, #24]
 8011394:	0c1b      	lsrs	r3, r3, #16
 8011396:	b2db      	uxtb	r3, r3
 8011398:	491e      	ldr	r1, [pc, #120]	@ (8011414 <AesDecrypt_C+0x93c>)
 801139a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801139e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113a2:	405a      	eors	r2, r3
 80113a4:	69fb      	ldr	r3, [r7, #28]
 80113a6:	0a1b      	lsrs	r3, r3, #8
 80113a8:	b2db      	uxtb	r3, r3
 80113aa:	491a      	ldr	r1, [pc, #104]	@ (8011414 <AesDecrypt_C+0x93c>)
 80113ac:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80113b0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113b4:	405a      	eors	r2, r3
 80113b6:	6a3b      	ldr	r3, [r7, #32]
 80113b8:	b2db      	uxtb	r3, r3
 80113ba:	4916      	ldr	r1, [pc, #88]	@ (8011414 <AesDecrypt_C+0x93c>)
 80113bc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80113c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113c4:	405a      	eors	r2, r3
 80113c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80113c8:	337c      	adds	r3, #124	@ 0x7c
 80113ca:	681b      	ldr	r3, [r3, #0]
 80113cc:	4053      	eors	r3, r2
 80113ce:	62bb      	str	r3, [r7, #40]	@ 0x28
    DEC_ROUND_S_T(32); DEC_ROUND_T_S(32);
 80113d0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80113d2:	0e1b      	lsrs	r3, r3, #24
 80113d4:	b2db      	uxtb	r3, r3
 80113d6:	461a      	mov	r2, r3
 80113d8:	4b0e      	ldr	r3, [pc, #56]	@ (8011414 <AesDecrypt_C+0x93c>)
 80113da:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80113de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80113e0:	0c1b      	lsrs	r3, r3, #16
 80113e2:	b2db      	uxtb	r3, r3
 80113e4:	490b      	ldr	r1, [pc, #44]	@ (8011414 <AesDecrypt_C+0x93c>)
 80113e6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80113ea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80113ee:	405a      	eors	r2, r3
 80113f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80113f2:	0a1b      	lsrs	r3, r3, #8
 80113f4:	b2db      	uxtb	r3, r3
 80113f6:	4907      	ldr	r1, [pc, #28]	@ (8011414 <AesDecrypt_C+0x93c>)
 80113f8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80113fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011400:	405a      	eors	r2, r3
 8011402:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011404:	b2db      	uxtb	r3, r3
 8011406:	4903      	ldr	r1, [pc, #12]	@ (8011414 <AesDecrypt_C+0x93c>)
 8011408:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801140c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011410:	405a      	eors	r2, r3
 8011412:	e001      	b.n	8011418 <AesDecrypt_C+0x940>
 8011414:	08032328 	.word	0x08032328
 8011418:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801141a:	3380      	adds	r3, #128	@ 0x80
 801141c:	681b      	ldr	r3, [r3, #0]
 801141e:	4053      	eors	r3, r2
 8011420:	623b      	str	r3, [r7, #32]
 8011422:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011424:	0e1b      	lsrs	r3, r3, #24
 8011426:	b2db      	uxtb	r3, r3
 8011428:	461a      	mov	r2, r3
 801142a:	4bb6      	ldr	r3, [pc, #728]	@ (8011704 <AesDecrypt_C+0xc2c>)
 801142c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011430:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011432:	0c1b      	lsrs	r3, r3, #16
 8011434:	b2db      	uxtb	r3, r3
 8011436:	49b3      	ldr	r1, [pc, #716]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011438:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801143c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011440:	405a      	eors	r2, r3
 8011442:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011444:	0a1b      	lsrs	r3, r3, #8
 8011446:	b2db      	uxtb	r3, r3
 8011448:	49ae      	ldr	r1, [pc, #696]	@ (8011704 <AesDecrypt_C+0xc2c>)
 801144a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801144e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011452:	405a      	eors	r2, r3
 8011454:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011456:	b2db      	uxtb	r3, r3
 8011458:	49aa      	ldr	r1, [pc, #680]	@ (8011704 <AesDecrypt_C+0xc2c>)
 801145a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801145e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011462:	405a      	eors	r2, r3
 8011464:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011466:	3384      	adds	r3, #132	@ 0x84
 8011468:	681b      	ldr	r3, [r3, #0]
 801146a:	4053      	eors	r3, r2
 801146c:	61fb      	str	r3, [r7, #28]
 801146e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011470:	0e1b      	lsrs	r3, r3, #24
 8011472:	b2db      	uxtb	r3, r3
 8011474:	461a      	mov	r2, r3
 8011476:	4ba3      	ldr	r3, [pc, #652]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011478:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801147c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801147e:	0c1b      	lsrs	r3, r3, #16
 8011480:	b2db      	uxtb	r3, r3
 8011482:	49a0      	ldr	r1, [pc, #640]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011484:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011488:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801148c:	405a      	eors	r2, r3
 801148e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011490:	0a1b      	lsrs	r3, r3, #8
 8011492:	b2db      	uxtb	r3, r3
 8011494:	499b      	ldr	r1, [pc, #620]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011496:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801149a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801149e:	405a      	eors	r2, r3
 80114a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80114a2:	b2db      	uxtb	r3, r3
 80114a4:	4997      	ldr	r1, [pc, #604]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80114a6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80114aa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114ae:	405a      	eors	r2, r3
 80114b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80114b2:	3388      	adds	r3, #136	@ 0x88
 80114b4:	681b      	ldr	r3, [r3, #0]
 80114b6:	4053      	eors	r3, r2
 80114b8:	61bb      	str	r3, [r7, #24]
 80114ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80114bc:	0e1b      	lsrs	r3, r3, #24
 80114be:	b2db      	uxtb	r3, r3
 80114c0:	461a      	mov	r2, r3
 80114c2:	4b90      	ldr	r3, [pc, #576]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80114c4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80114c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80114ca:	0c1b      	lsrs	r3, r3, #16
 80114cc:	b2db      	uxtb	r3, r3
 80114ce:	498d      	ldr	r1, [pc, #564]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80114d0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80114d4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114d8:	405a      	eors	r2, r3
 80114da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80114dc:	0a1b      	lsrs	r3, r3, #8
 80114de:	b2db      	uxtb	r3, r3
 80114e0:	4988      	ldr	r1, [pc, #544]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80114e2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80114e6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114ea:	405a      	eors	r2, r3
 80114ec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80114ee:	b2db      	uxtb	r3, r3
 80114f0:	4984      	ldr	r1, [pc, #528]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80114f2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80114f6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80114fa:	405a      	eors	r2, r3
 80114fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80114fe:	338c      	adds	r3, #140	@ 0x8c
 8011500:	681b      	ldr	r3, [r3, #0]
 8011502:	4053      	eors	r3, r2
 8011504:	617b      	str	r3, [r7, #20]
 8011506:	6a3b      	ldr	r3, [r7, #32]
 8011508:	0e1b      	lsrs	r3, r3, #24
 801150a:	b2db      	uxtb	r3, r3
 801150c:	461a      	mov	r2, r3
 801150e:	4b7d      	ldr	r3, [pc, #500]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011510:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011514:	697b      	ldr	r3, [r7, #20]
 8011516:	0c1b      	lsrs	r3, r3, #16
 8011518:	b2db      	uxtb	r3, r3
 801151a:	497a      	ldr	r1, [pc, #488]	@ (8011704 <AesDecrypt_C+0xc2c>)
 801151c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011520:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011524:	405a      	eors	r2, r3
 8011526:	69bb      	ldr	r3, [r7, #24]
 8011528:	0a1b      	lsrs	r3, r3, #8
 801152a:	b2db      	uxtb	r3, r3
 801152c:	4975      	ldr	r1, [pc, #468]	@ (8011704 <AesDecrypt_C+0xc2c>)
 801152e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011532:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011536:	405a      	eors	r2, r3
 8011538:	69fb      	ldr	r3, [r7, #28]
 801153a:	b2db      	uxtb	r3, r3
 801153c:	4971      	ldr	r1, [pc, #452]	@ (8011704 <AesDecrypt_C+0xc2c>)
 801153e:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011542:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011546:	405a      	eors	r2, r3
 8011548:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801154a:	3390      	adds	r3, #144	@ 0x90
 801154c:	681b      	ldr	r3, [r3, #0]
 801154e:	4053      	eors	r3, r2
 8011550:	637b      	str	r3, [r7, #52]	@ 0x34
 8011552:	69fb      	ldr	r3, [r7, #28]
 8011554:	0e1b      	lsrs	r3, r3, #24
 8011556:	b2db      	uxtb	r3, r3
 8011558:	461a      	mov	r2, r3
 801155a:	4b6a      	ldr	r3, [pc, #424]	@ (8011704 <AesDecrypt_C+0xc2c>)
 801155c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011560:	6a3b      	ldr	r3, [r7, #32]
 8011562:	0c1b      	lsrs	r3, r3, #16
 8011564:	b2db      	uxtb	r3, r3
 8011566:	4967      	ldr	r1, [pc, #412]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011568:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801156c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011570:	405a      	eors	r2, r3
 8011572:	697b      	ldr	r3, [r7, #20]
 8011574:	0a1b      	lsrs	r3, r3, #8
 8011576:	b2db      	uxtb	r3, r3
 8011578:	4962      	ldr	r1, [pc, #392]	@ (8011704 <AesDecrypt_C+0xc2c>)
 801157a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801157e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011582:	405a      	eors	r2, r3
 8011584:	69bb      	ldr	r3, [r7, #24]
 8011586:	b2db      	uxtb	r3, r3
 8011588:	495e      	ldr	r1, [pc, #376]	@ (8011704 <AesDecrypt_C+0xc2c>)
 801158a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801158e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011592:	405a      	eors	r2, r3
 8011594:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011596:	3394      	adds	r3, #148	@ 0x94
 8011598:	681b      	ldr	r3, [r3, #0]
 801159a:	4053      	eors	r3, r2
 801159c:	633b      	str	r3, [r7, #48]	@ 0x30
 801159e:	69bb      	ldr	r3, [r7, #24]
 80115a0:	0e1b      	lsrs	r3, r3, #24
 80115a2:	b2db      	uxtb	r3, r3
 80115a4:	461a      	mov	r2, r3
 80115a6:	4b57      	ldr	r3, [pc, #348]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80115a8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80115ac:	69fb      	ldr	r3, [r7, #28]
 80115ae:	0c1b      	lsrs	r3, r3, #16
 80115b0:	b2db      	uxtb	r3, r3
 80115b2:	4954      	ldr	r1, [pc, #336]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80115b4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80115b8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115bc:	405a      	eors	r2, r3
 80115be:	6a3b      	ldr	r3, [r7, #32]
 80115c0:	0a1b      	lsrs	r3, r3, #8
 80115c2:	b2db      	uxtb	r3, r3
 80115c4:	494f      	ldr	r1, [pc, #316]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80115c6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80115ca:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115ce:	405a      	eors	r2, r3
 80115d0:	697b      	ldr	r3, [r7, #20]
 80115d2:	b2db      	uxtb	r3, r3
 80115d4:	494b      	ldr	r1, [pc, #300]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80115d6:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80115da:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80115de:	405a      	eors	r2, r3
 80115e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80115e2:	3398      	adds	r3, #152	@ 0x98
 80115e4:	681b      	ldr	r3, [r3, #0]
 80115e6:	4053      	eors	r3, r2
 80115e8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80115ea:	697b      	ldr	r3, [r7, #20]
 80115ec:	0e1b      	lsrs	r3, r3, #24
 80115ee:	b2db      	uxtb	r3, r3
 80115f0:	461a      	mov	r2, r3
 80115f2:	4b44      	ldr	r3, [pc, #272]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80115f4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80115f8:	69bb      	ldr	r3, [r7, #24]
 80115fa:	0c1b      	lsrs	r3, r3, #16
 80115fc:	b2db      	uxtb	r3, r3
 80115fe:	4941      	ldr	r1, [pc, #260]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011600:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011604:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011608:	405a      	eors	r2, r3
 801160a:	69fb      	ldr	r3, [r7, #28]
 801160c:	0a1b      	lsrs	r3, r3, #8
 801160e:	b2db      	uxtb	r3, r3
 8011610:	493c      	ldr	r1, [pc, #240]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011612:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011616:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801161a:	405a      	eors	r2, r3
 801161c:	6a3b      	ldr	r3, [r7, #32]
 801161e:	b2db      	uxtb	r3, r3
 8011620:	4938      	ldr	r1, [pc, #224]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011622:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011626:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801162a:	405a      	eors	r2, r3
 801162c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801162e:	339c      	adds	r3, #156	@ 0x9c
 8011630:	681b      	ldr	r3, [r3, #0]
 8011632:	4053      	eors	r3, r2
 8011634:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (r > 5) {
 8011636:	683b      	ldr	r3, [r7, #0]
 8011638:	2b05      	cmp	r3, #5
 801163a:	f240 826a 	bls.w	8011b12 <AesDecrypt_C+0x103a>
        DEC_ROUND_S_T(40); DEC_ROUND_T_S(40);
 801163e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011640:	0e1b      	lsrs	r3, r3, #24
 8011642:	b2db      	uxtb	r3, r3
 8011644:	461a      	mov	r2, r3
 8011646:	4b2f      	ldr	r3, [pc, #188]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011648:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801164c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801164e:	0c1b      	lsrs	r3, r3, #16
 8011650:	b2db      	uxtb	r3, r3
 8011652:	492c      	ldr	r1, [pc, #176]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011654:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011658:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801165c:	405a      	eors	r2, r3
 801165e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011660:	0a1b      	lsrs	r3, r3, #8
 8011662:	b2db      	uxtb	r3, r3
 8011664:	4927      	ldr	r1, [pc, #156]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011666:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801166a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801166e:	405a      	eors	r2, r3
 8011670:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011672:	b2db      	uxtb	r3, r3
 8011674:	4923      	ldr	r1, [pc, #140]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011676:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801167a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801167e:	405a      	eors	r2, r3
 8011680:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011682:	33a0      	adds	r3, #160	@ 0xa0
 8011684:	681b      	ldr	r3, [r3, #0]
 8011686:	4053      	eors	r3, r2
 8011688:	623b      	str	r3, [r7, #32]
 801168a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801168c:	0e1b      	lsrs	r3, r3, #24
 801168e:	b2db      	uxtb	r3, r3
 8011690:	461a      	mov	r2, r3
 8011692:	4b1c      	ldr	r3, [pc, #112]	@ (8011704 <AesDecrypt_C+0xc2c>)
 8011694:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011698:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801169a:	0c1b      	lsrs	r3, r3, #16
 801169c:	b2db      	uxtb	r3, r3
 801169e:	4919      	ldr	r1, [pc, #100]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80116a0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80116a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116a8:	405a      	eors	r2, r3
 80116aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80116ac:	0a1b      	lsrs	r3, r3, #8
 80116ae:	b2db      	uxtb	r3, r3
 80116b0:	4914      	ldr	r1, [pc, #80]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80116b2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80116b6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116ba:	405a      	eors	r2, r3
 80116bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80116be:	b2db      	uxtb	r3, r3
 80116c0:	4910      	ldr	r1, [pc, #64]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80116c2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80116c6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116ca:	405a      	eors	r2, r3
 80116cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80116ce:	33a4      	adds	r3, #164	@ 0xa4
 80116d0:	681b      	ldr	r3, [r3, #0]
 80116d2:	4053      	eors	r3, r2
 80116d4:	61fb      	str	r3, [r7, #28]
 80116d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80116d8:	0e1b      	lsrs	r3, r3, #24
 80116da:	b2db      	uxtb	r3, r3
 80116dc:	461a      	mov	r2, r3
 80116de:	4b09      	ldr	r3, [pc, #36]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80116e0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80116e4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80116e6:	0c1b      	lsrs	r3, r3, #16
 80116e8:	b2db      	uxtb	r3, r3
 80116ea:	4906      	ldr	r1, [pc, #24]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80116ec:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80116f0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80116f4:	405a      	eors	r2, r3
 80116f6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80116f8:	0a1b      	lsrs	r3, r3, #8
 80116fa:	b2db      	uxtb	r3, r3
 80116fc:	4901      	ldr	r1, [pc, #4]	@ (8011704 <AesDecrypt_C+0xc2c>)
 80116fe:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011702:	e001      	b.n	8011708 <AesDecrypt_C+0xc30>
 8011704:	08032328 	.word	0x08032328
 8011708:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801170c:	405a      	eors	r2, r3
 801170e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011710:	b2db      	uxtb	r3, r3
 8011712:	49b6      	ldr	r1, [pc, #728]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011714:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011718:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801171c:	405a      	eors	r2, r3
 801171e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011720:	33a8      	adds	r3, #168	@ 0xa8
 8011722:	681b      	ldr	r3, [r3, #0]
 8011724:	4053      	eors	r3, r2
 8011726:	61bb      	str	r3, [r7, #24]
 8011728:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801172a:	0e1b      	lsrs	r3, r3, #24
 801172c:	b2db      	uxtb	r3, r3
 801172e:	461a      	mov	r2, r3
 8011730:	4bae      	ldr	r3, [pc, #696]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011732:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011736:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011738:	0c1b      	lsrs	r3, r3, #16
 801173a:	b2db      	uxtb	r3, r3
 801173c:	49ab      	ldr	r1, [pc, #684]	@ (80119ec <AesDecrypt_C+0xf14>)
 801173e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011742:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011746:	405a      	eors	r2, r3
 8011748:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801174a:	0a1b      	lsrs	r3, r3, #8
 801174c:	b2db      	uxtb	r3, r3
 801174e:	49a7      	ldr	r1, [pc, #668]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011750:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011754:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011758:	405a      	eors	r2, r3
 801175a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801175c:	b2db      	uxtb	r3, r3
 801175e:	49a3      	ldr	r1, [pc, #652]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011760:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011764:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011768:	405a      	eors	r2, r3
 801176a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801176c:	33ac      	adds	r3, #172	@ 0xac
 801176e:	681b      	ldr	r3, [r3, #0]
 8011770:	4053      	eors	r3, r2
 8011772:	617b      	str	r3, [r7, #20]
 8011774:	6a3b      	ldr	r3, [r7, #32]
 8011776:	0e1b      	lsrs	r3, r3, #24
 8011778:	b2db      	uxtb	r3, r3
 801177a:	461a      	mov	r2, r3
 801177c:	4b9b      	ldr	r3, [pc, #620]	@ (80119ec <AesDecrypt_C+0xf14>)
 801177e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011782:	697b      	ldr	r3, [r7, #20]
 8011784:	0c1b      	lsrs	r3, r3, #16
 8011786:	b2db      	uxtb	r3, r3
 8011788:	4998      	ldr	r1, [pc, #608]	@ (80119ec <AesDecrypt_C+0xf14>)
 801178a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801178e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011792:	405a      	eors	r2, r3
 8011794:	69bb      	ldr	r3, [r7, #24]
 8011796:	0a1b      	lsrs	r3, r3, #8
 8011798:	b2db      	uxtb	r3, r3
 801179a:	4994      	ldr	r1, [pc, #592]	@ (80119ec <AesDecrypt_C+0xf14>)
 801179c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80117a0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117a4:	405a      	eors	r2, r3
 80117a6:	69fb      	ldr	r3, [r7, #28]
 80117a8:	b2db      	uxtb	r3, r3
 80117aa:	4990      	ldr	r1, [pc, #576]	@ (80119ec <AesDecrypt_C+0xf14>)
 80117ac:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80117b0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117b4:	405a      	eors	r2, r3
 80117b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80117b8:	33b0      	adds	r3, #176	@ 0xb0
 80117ba:	681b      	ldr	r3, [r3, #0]
 80117bc:	4053      	eors	r3, r2
 80117be:	637b      	str	r3, [r7, #52]	@ 0x34
 80117c0:	69fb      	ldr	r3, [r7, #28]
 80117c2:	0e1b      	lsrs	r3, r3, #24
 80117c4:	b2db      	uxtb	r3, r3
 80117c6:	461a      	mov	r2, r3
 80117c8:	4b88      	ldr	r3, [pc, #544]	@ (80119ec <AesDecrypt_C+0xf14>)
 80117ca:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80117ce:	6a3b      	ldr	r3, [r7, #32]
 80117d0:	0c1b      	lsrs	r3, r3, #16
 80117d2:	b2db      	uxtb	r3, r3
 80117d4:	4985      	ldr	r1, [pc, #532]	@ (80119ec <AesDecrypt_C+0xf14>)
 80117d6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80117da:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117de:	405a      	eors	r2, r3
 80117e0:	697b      	ldr	r3, [r7, #20]
 80117e2:	0a1b      	lsrs	r3, r3, #8
 80117e4:	b2db      	uxtb	r3, r3
 80117e6:	4981      	ldr	r1, [pc, #516]	@ (80119ec <AesDecrypt_C+0xf14>)
 80117e8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80117ec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80117f0:	405a      	eors	r2, r3
 80117f2:	69bb      	ldr	r3, [r7, #24]
 80117f4:	b2db      	uxtb	r3, r3
 80117f6:	497d      	ldr	r1, [pc, #500]	@ (80119ec <AesDecrypt_C+0xf14>)
 80117f8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80117fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011800:	405a      	eors	r2, r3
 8011802:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011804:	33b4      	adds	r3, #180	@ 0xb4
 8011806:	681b      	ldr	r3, [r3, #0]
 8011808:	4053      	eors	r3, r2
 801180a:	633b      	str	r3, [r7, #48]	@ 0x30
 801180c:	69bb      	ldr	r3, [r7, #24]
 801180e:	0e1b      	lsrs	r3, r3, #24
 8011810:	b2db      	uxtb	r3, r3
 8011812:	461a      	mov	r2, r3
 8011814:	4b75      	ldr	r3, [pc, #468]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011816:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801181a:	69fb      	ldr	r3, [r7, #28]
 801181c:	0c1b      	lsrs	r3, r3, #16
 801181e:	b2db      	uxtb	r3, r3
 8011820:	4972      	ldr	r1, [pc, #456]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011822:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011826:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801182a:	405a      	eors	r2, r3
 801182c:	6a3b      	ldr	r3, [r7, #32]
 801182e:	0a1b      	lsrs	r3, r3, #8
 8011830:	b2db      	uxtb	r3, r3
 8011832:	496e      	ldr	r1, [pc, #440]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011834:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011838:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801183c:	405a      	eors	r2, r3
 801183e:	697b      	ldr	r3, [r7, #20]
 8011840:	b2db      	uxtb	r3, r3
 8011842:	496a      	ldr	r1, [pc, #424]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011844:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011848:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801184c:	405a      	eors	r2, r3
 801184e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011850:	33b8      	adds	r3, #184	@ 0xb8
 8011852:	681b      	ldr	r3, [r3, #0]
 8011854:	4053      	eors	r3, r2
 8011856:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011858:	697b      	ldr	r3, [r7, #20]
 801185a:	0e1b      	lsrs	r3, r3, #24
 801185c:	b2db      	uxtb	r3, r3
 801185e:	461a      	mov	r2, r3
 8011860:	4b62      	ldr	r3, [pc, #392]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011862:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011866:	69bb      	ldr	r3, [r7, #24]
 8011868:	0c1b      	lsrs	r3, r3, #16
 801186a:	b2db      	uxtb	r3, r3
 801186c:	495f      	ldr	r1, [pc, #380]	@ (80119ec <AesDecrypt_C+0xf14>)
 801186e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011872:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011876:	405a      	eors	r2, r3
 8011878:	69fb      	ldr	r3, [r7, #28]
 801187a:	0a1b      	lsrs	r3, r3, #8
 801187c:	b2db      	uxtb	r3, r3
 801187e:	495b      	ldr	r1, [pc, #364]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011880:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011884:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011888:	405a      	eors	r2, r3
 801188a:	6a3b      	ldr	r3, [r7, #32]
 801188c:	b2db      	uxtb	r3, r3
 801188e:	4957      	ldr	r1, [pc, #348]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011890:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011894:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011898:	405a      	eors	r2, r3
 801189a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801189c:	33bc      	adds	r3, #188	@ 0xbc
 801189e:	681b      	ldr	r3, [r3, #0]
 80118a0:	4053      	eors	r3, r2
 80118a2:	62bb      	str	r3, [r7, #40]	@ 0x28
        if (r > 6) {
 80118a4:	683b      	ldr	r3, [r7, #0]
 80118a6:	2b06      	cmp	r3, #6
 80118a8:	f240 8133 	bls.w	8011b12 <AesDecrypt_C+0x103a>
            DEC_ROUND_S_T(48); DEC_ROUND_T_S(48);
 80118ac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80118ae:	0e1b      	lsrs	r3, r3, #24
 80118b0:	b2db      	uxtb	r3, r3
 80118b2:	461a      	mov	r2, r3
 80118b4:	4b4d      	ldr	r3, [pc, #308]	@ (80119ec <AesDecrypt_C+0xf14>)
 80118b6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80118ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80118bc:	0c1b      	lsrs	r3, r3, #16
 80118be:	b2db      	uxtb	r3, r3
 80118c0:	494a      	ldr	r1, [pc, #296]	@ (80119ec <AesDecrypt_C+0xf14>)
 80118c2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80118c6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80118ca:	405a      	eors	r2, r3
 80118cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80118ce:	0a1b      	lsrs	r3, r3, #8
 80118d0:	b2db      	uxtb	r3, r3
 80118d2:	4946      	ldr	r1, [pc, #280]	@ (80119ec <AesDecrypt_C+0xf14>)
 80118d4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80118d8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80118dc:	405a      	eors	r2, r3
 80118de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80118e0:	b2db      	uxtb	r3, r3
 80118e2:	4942      	ldr	r1, [pc, #264]	@ (80119ec <AesDecrypt_C+0xf14>)
 80118e4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80118e8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80118ec:	405a      	eors	r2, r3
 80118ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80118f0:	33c0      	adds	r3, #192	@ 0xc0
 80118f2:	681b      	ldr	r3, [r3, #0]
 80118f4:	4053      	eors	r3, r2
 80118f6:	623b      	str	r3, [r7, #32]
 80118f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80118fa:	0e1b      	lsrs	r3, r3, #24
 80118fc:	b2db      	uxtb	r3, r3
 80118fe:	461a      	mov	r2, r3
 8011900:	4b3a      	ldr	r3, [pc, #232]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011902:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011906:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011908:	0c1b      	lsrs	r3, r3, #16
 801190a:	b2db      	uxtb	r3, r3
 801190c:	4937      	ldr	r1, [pc, #220]	@ (80119ec <AesDecrypt_C+0xf14>)
 801190e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011912:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011916:	405a      	eors	r2, r3
 8011918:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801191a:	0a1b      	lsrs	r3, r3, #8
 801191c:	b2db      	uxtb	r3, r3
 801191e:	4933      	ldr	r1, [pc, #204]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011920:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011924:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011928:	405a      	eors	r2, r3
 801192a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801192c:	b2db      	uxtb	r3, r3
 801192e:	492f      	ldr	r1, [pc, #188]	@ (80119ec <AesDecrypt_C+0xf14>)
 8011930:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011934:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011938:	405a      	eors	r2, r3
 801193a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801193c:	33c4      	adds	r3, #196	@ 0xc4
 801193e:	681b      	ldr	r3, [r3, #0]
 8011940:	4053      	eors	r3, r2
 8011942:	61fb      	str	r3, [r7, #28]
 8011944:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011946:	0e1b      	lsrs	r3, r3, #24
 8011948:	b2db      	uxtb	r3, r3
 801194a:	461a      	mov	r2, r3
 801194c:	4b27      	ldr	r3, [pc, #156]	@ (80119ec <AesDecrypt_C+0xf14>)
 801194e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011952:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011954:	0c1b      	lsrs	r3, r3, #16
 8011956:	b2db      	uxtb	r3, r3
 8011958:	4924      	ldr	r1, [pc, #144]	@ (80119ec <AesDecrypt_C+0xf14>)
 801195a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801195e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011962:	405a      	eors	r2, r3
 8011964:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011966:	0a1b      	lsrs	r3, r3, #8
 8011968:	b2db      	uxtb	r3, r3
 801196a:	4920      	ldr	r1, [pc, #128]	@ (80119ec <AesDecrypt_C+0xf14>)
 801196c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011970:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011974:	405a      	eors	r2, r3
 8011976:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011978:	b2db      	uxtb	r3, r3
 801197a:	491c      	ldr	r1, [pc, #112]	@ (80119ec <AesDecrypt_C+0xf14>)
 801197c:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011980:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011984:	405a      	eors	r2, r3
 8011986:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011988:	33c8      	adds	r3, #200	@ 0xc8
 801198a:	681b      	ldr	r3, [r3, #0]
 801198c:	4053      	eors	r3, r2
 801198e:	61bb      	str	r3, [r7, #24]
 8011990:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011992:	0e1b      	lsrs	r3, r3, #24
 8011994:	b2db      	uxtb	r3, r3
 8011996:	461a      	mov	r2, r3
 8011998:	4b14      	ldr	r3, [pc, #80]	@ (80119ec <AesDecrypt_C+0xf14>)
 801199a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801199e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80119a0:	0c1b      	lsrs	r3, r3, #16
 80119a2:	b2db      	uxtb	r3, r3
 80119a4:	4911      	ldr	r1, [pc, #68]	@ (80119ec <AesDecrypt_C+0xf14>)
 80119a6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80119aa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119ae:	405a      	eors	r2, r3
 80119b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80119b2:	0a1b      	lsrs	r3, r3, #8
 80119b4:	b2db      	uxtb	r3, r3
 80119b6:	490d      	ldr	r1, [pc, #52]	@ (80119ec <AesDecrypt_C+0xf14>)
 80119b8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80119bc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119c0:	405a      	eors	r2, r3
 80119c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80119c4:	b2db      	uxtb	r3, r3
 80119c6:	4909      	ldr	r1, [pc, #36]	@ (80119ec <AesDecrypt_C+0xf14>)
 80119c8:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80119cc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80119d0:	405a      	eors	r2, r3
 80119d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80119d4:	33cc      	adds	r3, #204	@ 0xcc
 80119d6:	681b      	ldr	r3, [r3, #0]
 80119d8:	4053      	eors	r3, r2
 80119da:	617b      	str	r3, [r7, #20]
 80119dc:	6a3b      	ldr	r3, [r7, #32]
 80119de:	0e1b      	lsrs	r3, r3, #24
 80119e0:	b2db      	uxtb	r3, r3
 80119e2:	461a      	mov	r2, r3
 80119e4:	4b01      	ldr	r3, [pc, #4]	@ (80119ec <AesDecrypt_C+0xf14>)
 80119e6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80119ea:	e001      	b.n	80119f0 <AesDecrypt_C+0xf18>
 80119ec:	08032328 	.word	0x08032328
 80119f0:	697b      	ldr	r3, [r7, #20]
 80119f2:	0c1b      	lsrs	r3, r3, #16
 80119f4:	b2db      	uxtb	r3, r3
 80119f6:	49a5      	ldr	r1, [pc, #660]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 80119f8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80119fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a00:	405a      	eors	r2, r3
 8011a02:	69bb      	ldr	r3, [r7, #24]
 8011a04:	0a1b      	lsrs	r3, r3, #8
 8011a06:	b2db      	uxtb	r3, r3
 8011a08:	49a0      	ldr	r1, [pc, #640]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011a0a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011a0e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a12:	405a      	eors	r2, r3
 8011a14:	69fb      	ldr	r3, [r7, #28]
 8011a16:	b2db      	uxtb	r3, r3
 8011a18:	499c      	ldr	r1, [pc, #624]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011a1a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011a1e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a22:	405a      	eors	r2, r3
 8011a24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011a26:	33d0      	adds	r3, #208	@ 0xd0
 8011a28:	681b      	ldr	r3, [r3, #0]
 8011a2a:	4053      	eors	r3, r2
 8011a2c:	637b      	str	r3, [r7, #52]	@ 0x34
 8011a2e:	69fb      	ldr	r3, [r7, #28]
 8011a30:	0e1b      	lsrs	r3, r3, #24
 8011a32:	b2db      	uxtb	r3, r3
 8011a34:	461a      	mov	r2, r3
 8011a36:	4b95      	ldr	r3, [pc, #596]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011a38:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011a3c:	6a3b      	ldr	r3, [r7, #32]
 8011a3e:	0c1b      	lsrs	r3, r3, #16
 8011a40:	b2db      	uxtb	r3, r3
 8011a42:	4992      	ldr	r1, [pc, #584]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011a44:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011a48:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a4c:	405a      	eors	r2, r3
 8011a4e:	697b      	ldr	r3, [r7, #20]
 8011a50:	0a1b      	lsrs	r3, r3, #8
 8011a52:	b2db      	uxtb	r3, r3
 8011a54:	498d      	ldr	r1, [pc, #564]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011a56:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011a5a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a5e:	405a      	eors	r2, r3
 8011a60:	69bb      	ldr	r3, [r7, #24]
 8011a62:	b2db      	uxtb	r3, r3
 8011a64:	4989      	ldr	r1, [pc, #548]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011a66:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011a6a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a6e:	405a      	eors	r2, r3
 8011a70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011a72:	33d4      	adds	r3, #212	@ 0xd4
 8011a74:	681b      	ldr	r3, [r3, #0]
 8011a76:	4053      	eors	r3, r2
 8011a78:	633b      	str	r3, [r7, #48]	@ 0x30
 8011a7a:	69bb      	ldr	r3, [r7, #24]
 8011a7c:	0e1b      	lsrs	r3, r3, #24
 8011a7e:	b2db      	uxtb	r3, r3
 8011a80:	461a      	mov	r2, r3
 8011a82:	4b82      	ldr	r3, [pc, #520]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011a84:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011a88:	69fb      	ldr	r3, [r7, #28]
 8011a8a:	0c1b      	lsrs	r3, r3, #16
 8011a8c:	b2db      	uxtb	r3, r3
 8011a8e:	497f      	ldr	r1, [pc, #508]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011a90:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011a94:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011a98:	405a      	eors	r2, r3
 8011a9a:	6a3b      	ldr	r3, [r7, #32]
 8011a9c:	0a1b      	lsrs	r3, r3, #8
 8011a9e:	b2db      	uxtb	r3, r3
 8011aa0:	497a      	ldr	r1, [pc, #488]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011aa2:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011aa6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011aaa:	405a      	eors	r2, r3
 8011aac:	697b      	ldr	r3, [r7, #20]
 8011aae:	b2db      	uxtb	r3, r3
 8011ab0:	4976      	ldr	r1, [pc, #472]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011ab2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011ab6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011aba:	405a      	eors	r2, r3
 8011abc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011abe:	33d8      	adds	r3, #216	@ 0xd8
 8011ac0:	681b      	ldr	r3, [r3, #0]
 8011ac2:	4053      	eors	r3, r2
 8011ac4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011ac6:	697b      	ldr	r3, [r7, #20]
 8011ac8:	0e1b      	lsrs	r3, r3, #24
 8011aca:	b2db      	uxtb	r3, r3
 8011acc:	461a      	mov	r2, r3
 8011ace:	4b6f      	ldr	r3, [pc, #444]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011ad0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011ad4:	69bb      	ldr	r3, [r7, #24]
 8011ad6:	0c1b      	lsrs	r3, r3, #16
 8011ad8:	b2db      	uxtb	r3, r3
 8011ada:	496c      	ldr	r1, [pc, #432]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011adc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011ae0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011ae4:	405a      	eors	r2, r3
 8011ae6:	69fb      	ldr	r3, [r7, #28]
 8011ae8:	0a1b      	lsrs	r3, r3, #8
 8011aea:	b2db      	uxtb	r3, r3
 8011aec:	4967      	ldr	r1, [pc, #412]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011aee:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011af2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011af6:	405a      	eors	r2, r3
 8011af8:	6a3b      	ldr	r3, [r7, #32]
 8011afa:	b2db      	uxtb	r3, r3
 8011afc:	4963      	ldr	r1, [pc, #396]	@ (8011c8c <AesDecrypt_C+0x11b4>)
 8011afe:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011b02:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011b06:	405a      	eors	r2, r3
 8011b08:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b0a:	33dc      	adds	r3, #220	@ 0xdc
 8011b0c:	681b      	ldr	r3, [r3, #0]
 8011b0e:	4053      	eors	r3, r2
 8011b10:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
    rk += r * 8;
 8011b12:	683b      	ldr	r3, [r7, #0]
 8011b14:	015b      	lsls	r3, r3, #5
 8011b16:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011b18:	4413      	add	r3, r2
 8011b1a:	627b      	str	r3, [r7, #36]	@ 0x24
     * apply last round and
     * map cipher state to byte array block:
     */

#ifndef WC_NO_CACHE_RESISTANT
    t0 |= PreFetchTd4();
 8011b1c:	f7fe ffbc 	bl	8010a98 <PreFetchTd4>
 8011b20:	4602      	mov	r2, r0
 8011b22:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011b24:	4313      	orrs	r3, r2
 8011b26:	637b      	str	r3, [r7, #52]	@ 0x34
#endif

    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 8011b28:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011b2a:	0e1b      	lsrs	r3, r3, #24
 8011b2c:	b2db      	uxtb	r3, r3
 8011b2e:	461a      	mov	r2, r3
 8011b30:	4b57      	ldr	r3, [pc, #348]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011b32:	5c9b      	ldrb	r3, [r3, r2]
 8011b34:	061a      	lsls	r2, r3, #24
 8011b36:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011b38:	0c1b      	lsrs	r3, r3, #16
 8011b3a:	b2db      	uxtb	r3, r3
 8011b3c:	4619      	mov	r1, r3
 8011b3e:	4b54      	ldr	r3, [pc, #336]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011b40:	5c5b      	ldrb	r3, [r3, r1]
 8011b42:	041b      	lsls	r3, r3, #16
 8011b44:	431a      	orrs	r2, r3
 8011b46:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011b48:	0a1b      	lsrs	r3, r3, #8
 8011b4a:	b2db      	uxtb	r3, r3
 8011b4c:	4619      	mov	r1, r3
 8011b4e:	4b50      	ldr	r3, [pc, #320]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011b50:	5c5b      	ldrb	r3, [r3, r1]
 8011b52:	021b      	lsls	r3, r3, #8
 8011b54:	4313      	orrs	r3, r2
 8011b56:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011b58:	b2d2      	uxtb	r2, r2
 8011b5a:	4611      	mov	r1, r2
 8011b5c:	4a4c      	ldr	r2, [pc, #304]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011b5e:	5c52      	ldrb	r2, [r2, r1]
 8011b60:	431a      	orrs	r2, r3
                          GETBYTE(t2, 1), GETBYTE(t1, 0)) ^ rk[0];
 8011b62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b64:	681b      	ldr	r3, [r3, #0]
 8011b66:	4053      	eors	r3, r2
    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 8011b68:	623b      	str	r3, [r7, #32]
    s1 = GetTable8_4(Td4, GETBYTE(t1, 3), GETBYTE(t0, 2),
 8011b6a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011b6c:	0e1b      	lsrs	r3, r3, #24
 8011b6e:	b2db      	uxtb	r3, r3
 8011b70:	461a      	mov	r2, r3
 8011b72:	4b47      	ldr	r3, [pc, #284]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011b74:	5c9b      	ldrb	r3, [r3, r2]
 8011b76:	061a      	lsls	r2, r3, #24
 8011b78:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011b7a:	0c1b      	lsrs	r3, r3, #16
 8011b7c:	b2db      	uxtb	r3, r3
 8011b7e:	4619      	mov	r1, r3
 8011b80:	4b43      	ldr	r3, [pc, #268]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011b82:	5c5b      	ldrb	r3, [r3, r1]
 8011b84:	041b      	lsls	r3, r3, #16
 8011b86:	431a      	orrs	r2, r3
 8011b88:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011b8a:	0a1b      	lsrs	r3, r3, #8
 8011b8c:	b2db      	uxtb	r3, r3
 8011b8e:	4619      	mov	r1, r3
 8011b90:	4b3f      	ldr	r3, [pc, #252]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011b92:	5c5b      	ldrb	r3, [r3, r1]
 8011b94:	021b      	lsls	r3, r3, #8
 8011b96:	4313      	orrs	r3, r2
 8011b98:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011b9a:	b2d2      	uxtb	r2, r2
 8011b9c:	4611      	mov	r1, r2
 8011b9e:	4a3c      	ldr	r2, [pc, #240]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011ba0:	5c52      	ldrb	r2, [r2, r1]
 8011ba2:	431a      	orrs	r2, r3
                          GETBYTE(t3, 1), GETBYTE(t2, 0)) ^ rk[1];
 8011ba4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011ba6:	3304      	adds	r3, #4
 8011ba8:	681b      	ldr	r3, [r3, #0]
 8011baa:	4053      	eors	r3, r2
    s1 = GetTable8_4(Td4, GETBYTE(t1, 3), GETBYTE(t0, 2),
 8011bac:	61fb      	str	r3, [r7, #28]
    s2 = GetTable8_4(Td4, GETBYTE(t2, 3), GETBYTE(t1, 2),
 8011bae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011bb0:	0e1b      	lsrs	r3, r3, #24
 8011bb2:	b2db      	uxtb	r3, r3
 8011bb4:	461a      	mov	r2, r3
 8011bb6:	4b36      	ldr	r3, [pc, #216]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011bb8:	5c9b      	ldrb	r3, [r3, r2]
 8011bba:	061a      	lsls	r2, r3, #24
 8011bbc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011bbe:	0c1b      	lsrs	r3, r3, #16
 8011bc0:	b2db      	uxtb	r3, r3
 8011bc2:	4619      	mov	r1, r3
 8011bc4:	4b32      	ldr	r3, [pc, #200]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011bc6:	5c5b      	ldrb	r3, [r3, r1]
 8011bc8:	041b      	lsls	r3, r3, #16
 8011bca:	431a      	orrs	r2, r3
 8011bcc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011bce:	0a1b      	lsrs	r3, r3, #8
 8011bd0:	b2db      	uxtb	r3, r3
 8011bd2:	4619      	mov	r1, r3
 8011bd4:	4b2e      	ldr	r3, [pc, #184]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011bd6:	5c5b      	ldrb	r3, [r3, r1]
 8011bd8:	021b      	lsls	r3, r3, #8
 8011bda:	4313      	orrs	r3, r2
 8011bdc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011bde:	b2d2      	uxtb	r2, r2
 8011be0:	4611      	mov	r1, r2
 8011be2:	4a2b      	ldr	r2, [pc, #172]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011be4:	5c52      	ldrb	r2, [r2, r1]
 8011be6:	431a      	orrs	r2, r3
                          GETBYTE(t0, 1), GETBYTE(t3, 0)) ^ rk[2];
 8011be8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011bea:	3308      	adds	r3, #8
 8011bec:	681b      	ldr	r3, [r3, #0]
 8011bee:	4053      	eors	r3, r2
    s2 = GetTable8_4(Td4, GETBYTE(t2, 3), GETBYTE(t1, 2),
 8011bf0:	61bb      	str	r3, [r7, #24]
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 8011bf2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011bf4:	0e1b      	lsrs	r3, r3, #24
 8011bf6:	b2db      	uxtb	r3, r3
 8011bf8:	461a      	mov	r2, r3
 8011bfa:	4b25      	ldr	r3, [pc, #148]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011bfc:	5c9b      	ldrb	r3, [r3, r2]
 8011bfe:	061a      	lsls	r2, r3, #24
 8011c00:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011c02:	0c1b      	lsrs	r3, r3, #16
 8011c04:	b2db      	uxtb	r3, r3
 8011c06:	4619      	mov	r1, r3
 8011c08:	4b21      	ldr	r3, [pc, #132]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011c0a:	5c5b      	ldrb	r3, [r3, r1]
 8011c0c:	041b      	lsls	r3, r3, #16
 8011c0e:	431a      	orrs	r2, r3
 8011c10:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011c12:	0a1b      	lsrs	r3, r3, #8
 8011c14:	b2db      	uxtb	r3, r3
 8011c16:	4619      	mov	r1, r3
 8011c18:	4b1d      	ldr	r3, [pc, #116]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011c1a:	5c5b      	ldrb	r3, [r3, r1]
 8011c1c:	021b      	lsls	r3, r3, #8
 8011c1e:	4313      	orrs	r3, r2
 8011c20:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011c22:	b2d2      	uxtb	r2, r2
 8011c24:	4611      	mov	r1, r2
 8011c26:	4a1a      	ldr	r2, [pc, #104]	@ (8011c90 <AesDecrypt_C+0x11b8>)
 8011c28:	5c52      	ldrb	r2, [r2, r1]
 8011c2a:	431a      	orrs	r2, r3
                          GETBYTE(t1, 1), GETBYTE(t0, 0)) ^ rk[3];
 8011c2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011c2e:	330c      	adds	r3, #12
 8011c30:	681b      	ldr	r3, [r3, #0]
 8011c32:	4053      	eors	r3, r2
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 8011c34:	617b      	str	r3, [r7, #20]
    s3 = t3 ^ rk[3];
#endif

    /* write out */
#ifdef LITTLE_ENDIAN_ORDER
    s0 = ByteReverseWord32(s0);
 8011c36:	6a3b      	ldr	r3, [r7, #32]
 8011c38:	4618      	mov	r0, r3
 8011c3a:	f7fd fcdc 	bl	800f5f6 <ByteReverseWord32>
 8011c3e:	4603      	mov	r3, r0
 8011c40:	623b      	str	r3, [r7, #32]
    s1 = ByteReverseWord32(s1);
 8011c42:	69fb      	ldr	r3, [r7, #28]
 8011c44:	4618      	mov	r0, r3
 8011c46:	f7fd fcd6 	bl	800f5f6 <ByteReverseWord32>
 8011c4a:	4603      	mov	r3, r0
 8011c4c:	61fb      	str	r3, [r7, #28]
    s2 = ByteReverseWord32(s2);
 8011c4e:	69bb      	ldr	r3, [r7, #24]
 8011c50:	4618      	mov	r0, r3
 8011c52:	f7fd fcd0 	bl	800f5f6 <ByteReverseWord32>
 8011c56:	4603      	mov	r3, r0
 8011c58:	61bb      	str	r3, [r7, #24]
    s3 = ByteReverseWord32(s3);
 8011c5a:	697b      	ldr	r3, [r7, #20]
 8011c5c:	4618      	mov	r0, r3
 8011c5e:	f7fd fcca 	bl	800f5f6 <ByteReverseWord32>
 8011c62:	4603      	mov	r3, r0
 8011c64:	617b      	str	r3, [r7, #20]
#endif

    XMEMCPY(outBlock,                  &s0, sizeof(s0));
 8011c66:	6a3a      	ldr	r2, [r7, #32]
 8011c68:	687b      	ldr	r3, [r7, #4]
 8011c6a:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + sizeof(s0),     &s1, sizeof(s1));
 8011c6c:	687b      	ldr	r3, [r7, #4]
 8011c6e:	3304      	adds	r3, #4
 8011c70:	69fa      	ldr	r2, [r7, #28]
 8011c72:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 2 * sizeof(s0), &s2, sizeof(s2));
 8011c74:	687b      	ldr	r3, [r7, #4]
 8011c76:	3308      	adds	r3, #8
 8011c78:	69ba      	ldr	r2, [r7, #24]
 8011c7a:	601a      	str	r2, [r3, #0]
    XMEMCPY(outBlock + 3 * sizeof(s0), &s3, sizeof(s3));
 8011c7c:	687b      	ldr	r3, [r7, #4]
 8011c7e:	330c      	adds	r3, #12
 8011c80:	697a      	ldr	r2, [r7, #20]
 8011c82:	601a      	str	r2, [r3, #0]

}
 8011c84:	bf00      	nop
 8011c86:	3738      	adds	r7, #56	@ 0x38
 8011c88:	46bd      	mov	sp, r7
 8011c8a:	bd80      	pop	{r7, pc}
 8011c8c:	08032328 	.word	0x08032328
 8011c90:	08033328 	.word	0x08033328

08011c94 <wc_AesDecrypt>:

#if !defined(WC_AES_BITSLICED) || defined(WOLFSSL_AES_DIRECT)
/* Software AES - ECB Decrypt */
static WARN_UNUSED_RESULT int wc_AesDecrypt(
    Aes* aes, const byte* inBlock, byte* outBlock)
{
 8011c94:	b580      	push	{r7, lr}
 8011c96:	b086      	sub	sp, #24
 8011c98:	af00      	add	r7, sp, #0
 8011c9a:	60f8      	str	r0, [r7, #12]
 8011c9c:	60b9      	str	r1, [r7, #8]
 8011c9e:	607a      	str	r2, [r7, #4]
#if defined(MAX3266X_CB)
    int ret_cb;
#endif
    word32 r;

    if (aes == NULL) {
 8011ca0:	68fb      	ldr	r3, [r7, #12]
 8011ca2:	2b00      	cmp	r3, #0
 8011ca4:	d102      	bne.n	8011cac <wc_AesDecrypt+0x18>
        return BAD_FUNC_ARG;
 8011ca6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8011caa:	e014      	b.n	8011cd6 <wc_AesDecrypt+0x42>
        if (ret < 0)
            return ret;
    }
#endif

    r = aes->rounds >> 1;
 8011cac:	68fb      	ldr	r3, [r7, #12]
 8011cae:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011cb2:	085b      	lsrs	r3, r3, #1
 8011cb4:	617b      	str	r3, [r7, #20]

    if (r > 7 || r == 0) {
 8011cb6:	697b      	ldr	r3, [r7, #20]
 8011cb8:	2b07      	cmp	r3, #7
 8011cba:	d802      	bhi.n	8011cc2 <wc_AesDecrypt+0x2e>
 8011cbc:	697b      	ldr	r3, [r7, #20]
 8011cbe:	2b00      	cmp	r3, #0
 8011cc0:	d102      	bne.n	8011cc8 <wc_AesDecrypt+0x34>
        WOLFSSL_ERROR_VERBOSE(KEYUSAGE_E);
        return KEYUSAGE_E;
 8011cc2:	f06f 03e1 	mvn.w	r3, #225	@ 0xe1
 8011cc6:	e006      	b.n	8011cd6 <wc_AesDecrypt+0x42>
            return ret_cb;
        /* fall-through when unavailable */
    }
#endif

    AesDecrypt_C(aes, inBlock, outBlock, r);
 8011cc8:	697b      	ldr	r3, [r7, #20]
 8011cca:	687a      	ldr	r2, [r7, #4]
 8011ccc:	68b9      	ldr	r1, [r7, #8]
 8011cce:	68f8      	ldr	r0, [r7, #12]
 8011cd0:	f7fe ff02 	bl	8010ad8 <AesDecrypt_C>

    return 0;
 8011cd4:	2300      	movs	r3, #0
} /* wc_AesDecrypt[_SW]() */
 8011cd6:	4618      	mov	r0, r3
 8011cd8:	3718      	adds	r7, #24
 8011cda:	46bd      	mov	sp, r7
 8011cdc:	bd80      	pop	{r7, pc}
	...

08011ce0 <AesSetKey_C>:
 * @param [in]  key    Block to encrypt.
 * @param [in]  keySz  Number of bytes in key.
 * @param [in]  dir    Direction of crypt: AES_ENCRYPTION or AES_DECRYPTION.
 */
static void AesSetKey_C(Aes* aes, const byte* key, word32 keySz, int dir)
{
 8011ce0:	b580      	push	{r7, lr}
 8011ce2:	b088      	sub	sp, #32
 8011ce4:	af00      	add	r7, sp, #0
 8011ce6:	60f8      	str	r0, [r7, #12]
 8011ce8:	60b9      	str	r1, [r7, #8]
 8011cea:	607a      	str	r2, [r7, #4]
 8011cec:	603b      	str	r3, [r7, #0]
#ifdef WC_C_DYNAMIC_FALLBACK
    word32* rk = aes->key_C_fallback;
#else
    word32* rk = aes->key;
 8011cee:	68fb      	ldr	r3, [r7, #12]
 8011cf0:	61fb      	str	r3, [r7, #28]
#endif
    word32 temp;
    unsigned int i = 0;
 8011cf2:	2300      	movs	r3, #0
 8011cf4:	61bb      	str	r3, [r7, #24]

    XMEMCPY(rk, key, keySz);
 8011cf6:	687a      	ldr	r2, [r7, #4]
 8011cf8:	68b9      	ldr	r1, [r7, #8]
 8011cfa:	69f8      	ldr	r0, [r7, #28]
 8011cfc:	f016 fc52 	bl	80285a4 <memcpy>
#if defined(LITTLE_ENDIAN_ORDER) && !defined(WOLFSSL_PIC32MZ_CRYPT) && \
    (!defined(WOLFSSL_ESP32_CRYPT) || defined(NO_WOLFSSL_ESP32_CRYPT_AES)) && \
    !defined(MAX3266X_AES)
    /* Always reverse words when using only SW */
    {
        ByteReverseWords(rk, rk, keySz);
 8011d00:	687a      	ldr	r2, [r7, #4]
 8011d02:	69f9      	ldr	r1, [r7, #28]
 8011d04:	69f8      	ldr	r0, [r7, #28]
 8011d06:	f7fd fc8d 	bl	800f624 <ByteReverseWords>
            /* If we don't need SW fallback, don't need to reverse words. */
        #endif /* NEED_AES_HW_FALLBACK */
    #endif /* WOLFSSL_ESPIDF */
#endif /* LITTLE_ENDIAN_ORDER, etc */

    switch (keySz) {
 8011d0a:	687b      	ldr	r3, [r7, #4]
 8011d0c:	2b20      	cmp	r3, #32
 8011d0e:	f000 80e5 	beq.w	8011edc <AesSetKey_C+0x1fc>
 8011d12:	687b      	ldr	r3, [r7, #4]
 8011d14:	2b20      	cmp	r3, #32
 8011d16:	f200 8193 	bhi.w	8012040 <AesSetKey_C+0x360>
 8011d1a:	687b      	ldr	r3, [r7, #4]
 8011d1c:	2b10      	cmp	r3, #16
 8011d1e:	d003      	beq.n	8011d28 <AesSetKey_C+0x48>
 8011d20:	687b      	ldr	r3, [r7, #4]
 8011d22:	2b18      	cmp	r3, #24
 8011d24:	d061      	beq.n	8011dea <AesSetKey_C+0x10a>
 8011d26:	e18b      	b.n	8012040 <AesSetKey_C+0x360>
        temp = (word32)-1;
        wc_MemZero_Add("wc_AesSetKeyLocal temp", &temp, sizeof(temp));
    #endif
        while (1)
        {
            temp  = rk[3];
 8011d28:	69fb      	ldr	r3, [r7, #28]
 8011d2a:	68db      	ldr	r3, [r3, #12]
 8011d2c:	613b      	str	r3, [r7, #16]
            rk[4] = rk[0] ^
 8011d2e:	69fb      	ldr	r3, [r7, #28]
 8011d30:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011d32:	693b      	ldr	r3, [r7, #16]
 8011d34:	0c1b      	lsrs	r3, r3, #16
 8011d36:	b2db      	uxtb	r3, r3
 8011d38:	4966      	ldr	r1, [pc, #408]	@ (8011ed4 <AesSetKey_C+0x1f4>)
 8011d3a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011d3e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011d42:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[4] = rk[0] ^
 8011d46:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011d48:	693b      	ldr	r3, [r7, #16]
 8011d4a:	0a1b      	lsrs	r3, r3, #8
 8011d4c:	b2db      	uxtb	r3, r3
 8011d4e:	4961      	ldr	r1, [pc, #388]	@ (8011ed4 <AesSetKey_C+0x1f4>)
 8011d50:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011d54:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011d58:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011d5c:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011d5e:	693b      	ldr	r3, [r7, #16]
 8011d60:	b2db      	uxtb	r3, r3
 8011d62:	4619      	mov	r1, r3
 8011d64:	4b5b      	ldr	r3, [pc, #364]	@ (8011ed4 <AesSetKey_C+0x1f4>)
 8011d66:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8011d6a:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011d6e:	405a      	eors	r2, r3
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011d70:	693b      	ldr	r3, [r7, #16]
 8011d72:	0e1b      	lsrs	r3, r3, #24
 8011d74:	b2db      	uxtb	r3, r3
 8011d76:	4957      	ldr	r1, [pc, #348]	@ (8011ed4 <AesSetKey_C+0x1f4>)
 8011d78:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011d7c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011d80:	b2db      	uxtb	r3, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011d82:	ea82 0103 	eor.w	r1, r2, r3
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3))) ^
        #endif
                rcon[i];
 8011d86:	4a54      	ldr	r2, [pc, #336]	@ (8011ed8 <AesSetKey_C+0x1f8>)
 8011d88:	69bb      	ldr	r3, [r7, #24]
 8011d8a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[4] = rk[0] ^
 8011d8e:	69fb      	ldr	r3, [r7, #28]
 8011d90:	3310      	adds	r3, #16
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011d92:	404a      	eors	r2, r1
            rk[4] = rk[0] ^
 8011d94:	601a      	str	r2, [r3, #0]
            rk[5] = rk[1] ^ rk[4];
 8011d96:	69fb      	ldr	r3, [r7, #28]
 8011d98:	3304      	adds	r3, #4
 8011d9a:	6819      	ldr	r1, [r3, #0]
 8011d9c:	69fb      	ldr	r3, [r7, #28]
 8011d9e:	3310      	adds	r3, #16
 8011da0:	681a      	ldr	r2, [r3, #0]
 8011da2:	69fb      	ldr	r3, [r7, #28]
 8011da4:	3314      	adds	r3, #20
 8011da6:	404a      	eors	r2, r1
 8011da8:	601a      	str	r2, [r3, #0]
            rk[6] = rk[2] ^ rk[5];
 8011daa:	69fb      	ldr	r3, [r7, #28]
 8011dac:	3308      	adds	r3, #8
 8011dae:	6819      	ldr	r1, [r3, #0]
 8011db0:	69fb      	ldr	r3, [r7, #28]
 8011db2:	3314      	adds	r3, #20
 8011db4:	681a      	ldr	r2, [r3, #0]
 8011db6:	69fb      	ldr	r3, [r7, #28]
 8011db8:	3318      	adds	r3, #24
 8011dba:	404a      	eors	r2, r1
 8011dbc:	601a      	str	r2, [r3, #0]
            rk[7] = rk[3] ^ rk[6];
 8011dbe:	69fb      	ldr	r3, [r7, #28]
 8011dc0:	330c      	adds	r3, #12
 8011dc2:	6819      	ldr	r1, [r3, #0]
 8011dc4:	69fb      	ldr	r3, [r7, #28]
 8011dc6:	3318      	adds	r3, #24
 8011dc8:	681a      	ldr	r2, [r3, #0]
 8011dca:	69fb      	ldr	r3, [r7, #28]
 8011dcc:	331c      	adds	r3, #28
 8011dce:	404a      	eors	r2, r1
 8011dd0:	601a      	str	r2, [r3, #0]
            if (++i == 10)
 8011dd2:	69bb      	ldr	r3, [r7, #24]
 8011dd4:	3301      	adds	r3, #1
 8011dd6:	61bb      	str	r3, [r7, #24]
 8011dd8:	69bb      	ldr	r3, [r7, #24]
 8011dda:	2b0a      	cmp	r3, #10
 8011ddc:	d003      	beq.n	8011de6 <AesSetKey_C+0x106>
                break;
            rk += 4;
 8011dde:	69fb      	ldr	r3, [r7, #28]
 8011de0:	3310      	adds	r3, #16
 8011de2:	61fb      	str	r3, [r7, #28]
            temp  = rk[3];
 8011de4:	e7a0      	b.n	8011d28 <AesSetKey_C+0x48>
                break;
 8011de6:	bf00      	nop
        }
        break;
 8011de8:	e12a      	b.n	8012040 <AesSetKey_C+0x360>
        wc_MemZero_Add("wc_AesSetKeyLocal temp", &temp, sizeof(temp));
    #endif
        /* for (;;) here triggers a bug in VC60 SP4 w/ Pro Pack */
        while (1)
        {
            temp = rk[ 5];
 8011dea:	69fb      	ldr	r3, [r7, #28]
 8011dec:	695b      	ldr	r3, [r3, #20]
 8011dee:	613b      	str	r3, [r7, #16]
            rk[ 6] = rk[ 0] ^
 8011df0:	69fb      	ldr	r3, [r7, #28]
 8011df2:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011df4:	693b      	ldr	r3, [r7, #16]
 8011df6:	0c1b      	lsrs	r3, r3, #16
 8011df8:	b2db      	uxtb	r3, r3
 8011dfa:	4936      	ldr	r1, [pc, #216]	@ (8011ed4 <AesSetKey_C+0x1f4>)
 8011dfc:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011e00:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011e04:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[ 6] = rk[ 0] ^
 8011e08:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011e0a:	693b      	ldr	r3, [r7, #16]
 8011e0c:	0a1b      	lsrs	r3, r3, #8
 8011e0e:	b2db      	uxtb	r3, r3
 8011e10:	4930      	ldr	r1, [pc, #192]	@ (8011ed4 <AesSetKey_C+0x1f4>)
 8011e12:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011e16:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011e1a:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011e1e:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011e20:	693b      	ldr	r3, [r7, #16]
 8011e22:	b2db      	uxtb	r3, r3
 8011e24:	4619      	mov	r1, r3
 8011e26:	4b2b      	ldr	r3, [pc, #172]	@ (8011ed4 <AesSetKey_C+0x1f4>)
 8011e28:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8011e2c:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011e30:	405a      	eors	r2, r3
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011e32:	693b      	ldr	r3, [r7, #16]
 8011e34:	0e1b      	lsrs	r3, r3, #24
 8011e36:	b2db      	uxtb	r3, r3
 8011e38:	4926      	ldr	r1, [pc, #152]	@ (8011ed4 <AesSetKey_C+0x1f4>)
 8011e3a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011e3e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011e42:	b2db      	uxtb	r3, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011e44:	ea82 0103 	eor.w	r1, r2, r3
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3))) ^
        #endif
                rcon[i];
 8011e48:	4a23      	ldr	r2, [pc, #140]	@ (8011ed8 <AesSetKey_C+0x1f8>)
 8011e4a:	69bb      	ldr	r3, [r7, #24]
 8011e4c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[ 6] = rk[ 0] ^
 8011e50:	69fb      	ldr	r3, [r7, #28]
 8011e52:	3318      	adds	r3, #24
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011e54:	404a      	eors	r2, r1
            rk[ 6] = rk[ 0] ^
 8011e56:	601a      	str	r2, [r3, #0]
            rk[ 7] = rk[ 1] ^ rk[ 6];
 8011e58:	69fb      	ldr	r3, [r7, #28]
 8011e5a:	3304      	adds	r3, #4
 8011e5c:	6819      	ldr	r1, [r3, #0]
 8011e5e:	69fb      	ldr	r3, [r7, #28]
 8011e60:	3318      	adds	r3, #24
 8011e62:	681a      	ldr	r2, [r3, #0]
 8011e64:	69fb      	ldr	r3, [r7, #28]
 8011e66:	331c      	adds	r3, #28
 8011e68:	404a      	eors	r2, r1
 8011e6a:	601a      	str	r2, [r3, #0]
            rk[ 8] = rk[ 2] ^ rk[ 7];
 8011e6c:	69fb      	ldr	r3, [r7, #28]
 8011e6e:	3308      	adds	r3, #8
 8011e70:	6819      	ldr	r1, [r3, #0]
 8011e72:	69fb      	ldr	r3, [r7, #28]
 8011e74:	331c      	adds	r3, #28
 8011e76:	681a      	ldr	r2, [r3, #0]
 8011e78:	69fb      	ldr	r3, [r7, #28]
 8011e7a:	3320      	adds	r3, #32
 8011e7c:	404a      	eors	r2, r1
 8011e7e:	601a      	str	r2, [r3, #0]
            rk[ 9] = rk[ 3] ^ rk[ 8];
 8011e80:	69fb      	ldr	r3, [r7, #28]
 8011e82:	330c      	adds	r3, #12
 8011e84:	6819      	ldr	r1, [r3, #0]
 8011e86:	69fb      	ldr	r3, [r7, #28]
 8011e88:	3320      	adds	r3, #32
 8011e8a:	681a      	ldr	r2, [r3, #0]
 8011e8c:	69fb      	ldr	r3, [r7, #28]
 8011e8e:	3324      	adds	r3, #36	@ 0x24
 8011e90:	404a      	eors	r2, r1
 8011e92:	601a      	str	r2, [r3, #0]
            if (++i == 8)
 8011e94:	69bb      	ldr	r3, [r7, #24]
 8011e96:	3301      	adds	r3, #1
 8011e98:	61bb      	str	r3, [r7, #24]
 8011e9a:	69bb      	ldr	r3, [r7, #24]
 8011e9c:	2b08      	cmp	r3, #8
 8011e9e:	d017      	beq.n	8011ed0 <AesSetKey_C+0x1f0>
                break;
            rk[10] = rk[ 4] ^ rk[ 9];
 8011ea0:	69fb      	ldr	r3, [r7, #28]
 8011ea2:	3310      	adds	r3, #16
 8011ea4:	6819      	ldr	r1, [r3, #0]
 8011ea6:	69fb      	ldr	r3, [r7, #28]
 8011ea8:	3324      	adds	r3, #36	@ 0x24
 8011eaa:	681a      	ldr	r2, [r3, #0]
 8011eac:	69fb      	ldr	r3, [r7, #28]
 8011eae:	3328      	adds	r3, #40	@ 0x28
 8011eb0:	404a      	eors	r2, r1
 8011eb2:	601a      	str	r2, [r3, #0]
            rk[11] = rk[ 5] ^ rk[10];
 8011eb4:	69fb      	ldr	r3, [r7, #28]
 8011eb6:	3314      	adds	r3, #20
 8011eb8:	6819      	ldr	r1, [r3, #0]
 8011eba:	69fb      	ldr	r3, [r7, #28]
 8011ebc:	3328      	adds	r3, #40	@ 0x28
 8011ebe:	681a      	ldr	r2, [r3, #0]
 8011ec0:	69fb      	ldr	r3, [r7, #28]
 8011ec2:	332c      	adds	r3, #44	@ 0x2c
 8011ec4:	404a      	eors	r2, r1
 8011ec6:	601a      	str	r2, [r3, #0]
            rk += 6;
 8011ec8:	69fb      	ldr	r3, [r7, #28]
 8011eca:	3318      	adds	r3, #24
 8011ecc:	61fb      	str	r3, [r7, #28]
            temp = rk[ 5];
 8011ece:	e78c      	b.n	8011dea <AesSetKey_C+0x10a>
                break;
 8011ed0:	bf00      	nop
        }
        break;
 8011ed2:	e0b5      	b.n	8012040 <AesSetKey_C+0x360>
 8011ed4:	08031328 	.word	0x08031328
 8011ed8:	08031300 	.word	0x08031300
        temp = (word32)-1;
        wc_MemZero_Add("wc_AesSetKeyLocal temp", &temp, sizeof(temp));
    #endif
        while (1)
        {
            temp = rk[ 7];
 8011edc:	69fb      	ldr	r3, [r7, #28]
 8011ede:	69db      	ldr	r3, [r3, #28]
 8011ee0:	613b      	str	r3, [r7, #16]
            rk[ 8] = rk[ 0] ^
 8011ee2:	69fb      	ldr	r3, [r7, #28]
 8011ee4:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011ee6:	693b      	ldr	r3, [r7, #16]
 8011ee8:	0c1b      	lsrs	r3, r3, #16
 8011eea:	b2db      	uxtb	r3, r3
 8011eec:	499a      	ldr	r1, [pc, #616]	@ (8012158 <AesSetKey_C+0x478>)
 8011eee:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011ef2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011ef6:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[ 8] = rk[ 0] ^
 8011efa:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011efc:	693b      	ldr	r3, [r7, #16]
 8011efe:	0a1b      	lsrs	r3, r3, #8
 8011f00:	b2db      	uxtb	r3, r3
 8011f02:	4995      	ldr	r1, [pc, #596]	@ (8012158 <AesSetKey_C+0x478>)
 8011f04:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011f08:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011f0c:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 8011f10:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011f12:	693b      	ldr	r3, [r7, #16]
 8011f14:	b2db      	uxtb	r3, r3
 8011f16:	4619      	mov	r1, r3
 8011f18:	4b8f      	ldr	r3, [pc, #572]	@ (8012158 <AesSetKey_C+0x478>)
 8011f1a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8011f1e:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 8011f22:	405a      	eors	r2, r3
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011f24:	693b      	ldr	r3, [r7, #16]
 8011f26:	0e1b      	lsrs	r3, r3, #24
 8011f28:	b2db      	uxtb	r3, r3
 8011f2a:	498b      	ldr	r1, [pc, #556]	@ (8012158 <AesSetKey_C+0x478>)
 8011f2c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011f30:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011f34:	b2db      	uxtb	r3, r3
                (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 8011f36:	ea82 0103 	eor.w	r1, r2, r3
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3))) ^
        #endif
                rcon[i];
 8011f3a:	4a88      	ldr	r2, [pc, #544]	@ (801215c <AesSetKey_C+0x47c>)
 8011f3c:	69bb      	ldr	r3, [r7, #24]
 8011f3e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[ 8] = rk[ 0] ^
 8011f42:	69fb      	ldr	r3, [r7, #28]
 8011f44:	3320      	adds	r3, #32
                (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 8011f46:	404a      	eors	r2, r1
            rk[ 8] = rk[ 0] ^
 8011f48:	601a      	str	r2, [r3, #0]
            rk[ 9] = rk[ 1] ^ rk[ 8];
 8011f4a:	69fb      	ldr	r3, [r7, #28]
 8011f4c:	3304      	adds	r3, #4
 8011f4e:	6819      	ldr	r1, [r3, #0]
 8011f50:	69fb      	ldr	r3, [r7, #28]
 8011f52:	3320      	adds	r3, #32
 8011f54:	681a      	ldr	r2, [r3, #0]
 8011f56:	69fb      	ldr	r3, [r7, #28]
 8011f58:	3324      	adds	r3, #36	@ 0x24
 8011f5a:	404a      	eors	r2, r1
 8011f5c:	601a      	str	r2, [r3, #0]
            rk[10] = rk[ 2] ^ rk[ 9];
 8011f5e:	69fb      	ldr	r3, [r7, #28]
 8011f60:	3308      	adds	r3, #8
 8011f62:	6819      	ldr	r1, [r3, #0]
 8011f64:	69fb      	ldr	r3, [r7, #28]
 8011f66:	3324      	adds	r3, #36	@ 0x24
 8011f68:	681a      	ldr	r2, [r3, #0]
 8011f6a:	69fb      	ldr	r3, [r7, #28]
 8011f6c:	3328      	adds	r3, #40	@ 0x28
 8011f6e:	404a      	eors	r2, r1
 8011f70:	601a      	str	r2, [r3, #0]
            rk[11] = rk[ 3] ^ rk[10];
 8011f72:	69fb      	ldr	r3, [r7, #28]
 8011f74:	330c      	adds	r3, #12
 8011f76:	6819      	ldr	r1, [r3, #0]
 8011f78:	69fb      	ldr	r3, [r7, #28]
 8011f7a:	3328      	adds	r3, #40	@ 0x28
 8011f7c:	681a      	ldr	r2, [r3, #0]
 8011f7e:	69fb      	ldr	r3, [r7, #28]
 8011f80:	332c      	adds	r3, #44	@ 0x2c
 8011f82:	404a      	eors	r2, r1
 8011f84:	601a      	str	r2, [r3, #0]
            if (++i == 7)
 8011f86:	69bb      	ldr	r3, [r7, #24]
 8011f88:	3301      	adds	r3, #1
 8011f8a:	61bb      	str	r3, [r7, #24]
 8011f8c:	69bb      	ldr	r3, [r7, #24]
 8011f8e:	2b07      	cmp	r3, #7
 8011f90:	d054      	beq.n	801203c <AesSetKey_C+0x35c>
                break;
            temp = rk[11];
 8011f92:	69fb      	ldr	r3, [r7, #28]
 8011f94:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011f96:	613b      	str	r3, [r7, #16]
            rk[12] = rk[ 4] ^
 8011f98:	69fb      	ldr	r3, [r7, #28]
 8011f9a:	3310      	adds	r3, #16
 8011f9c:	681a      	ldr	r2, [r3, #0]
        #ifndef WOLFSSL_AES_SMALL_TABLES
                (GetTable(Te[2], GETBYTE(temp, 3)) & 0xff000000) ^
 8011f9e:	693b      	ldr	r3, [r7, #16]
 8011fa0:	0e1b      	lsrs	r3, r3, #24
 8011fa2:	b2db      	uxtb	r3, r3
 8011fa4:	496c      	ldr	r1, [pc, #432]	@ (8012158 <AesSetKey_C+0x478>)
 8011fa6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8011faa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011fae:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
            rk[12] = rk[ 4] ^
 8011fb2:	405a      	eors	r2, r3
                (GetTable(Te[3], GETBYTE(temp, 2)) & 0x00ff0000) ^
 8011fb4:	693b      	ldr	r3, [r7, #16]
 8011fb6:	0c1b      	lsrs	r3, r3, #16
 8011fb8:	b2db      	uxtb	r3, r3
 8011fba:	4967      	ldr	r1, [pc, #412]	@ (8012158 <AesSetKey_C+0x478>)
 8011fbc:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 8011fc0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011fc4:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
                (GetTable(Te[2], GETBYTE(temp, 3)) & 0xff000000) ^
 8011fc8:	405a      	eors	r2, r3
                (GetTable(Te[0], GETBYTE(temp, 1)) & 0x0000ff00) ^
 8011fca:	693b      	ldr	r3, [r7, #16]
 8011fcc:	0a1b      	lsrs	r3, r3, #8
 8011fce:	b2db      	uxtb	r3, r3
 8011fd0:	4619      	mov	r1, r3
 8011fd2:	4b61      	ldr	r3, [pc, #388]	@ (8012158 <AesSetKey_C+0x478>)
 8011fd4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8011fd8:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
                (GetTable(Te[3], GETBYTE(temp, 2)) & 0x00ff0000) ^
 8011fdc:	ea82 0103 	eor.w	r1, r2, r3
                (GetTable(Te[1], GETBYTE(temp, 0)) & 0x000000ff);
 8011fe0:	693b      	ldr	r3, [r7, #16]
 8011fe2:	b2db      	uxtb	r3, r3
 8011fe4:	4a5c      	ldr	r2, [pc, #368]	@ (8012158 <AesSetKey_C+0x478>)
 8011fe6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8011fea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8011fee:	b2da      	uxtb	r2, r3
            rk[12] = rk[ 4] ^
 8011ff0:	69fb      	ldr	r3, [r7, #28]
 8011ff2:	3330      	adds	r3, #48	@ 0x30
                (GetTable(Te[0], GETBYTE(temp, 1)) & 0x0000ff00) ^
 8011ff4:	404a      	eors	r2, r1
            rk[12] = rk[ 4] ^
 8011ff6:	601a      	str	r2, [r3, #0]
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 3)) << 24) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 2)) << 16) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 1)) <<  8) ^
                ((word32)GetTable8(Tsbox, GETBYTE(temp, 0)));
        #endif
            rk[13] = rk[ 5] ^ rk[12];
 8011ff8:	69fb      	ldr	r3, [r7, #28]
 8011ffa:	3314      	adds	r3, #20
 8011ffc:	6819      	ldr	r1, [r3, #0]
 8011ffe:	69fb      	ldr	r3, [r7, #28]
 8012000:	3330      	adds	r3, #48	@ 0x30
 8012002:	681a      	ldr	r2, [r3, #0]
 8012004:	69fb      	ldr	r3, [r7, #28]
 8012006:	3334      	adds	r3, #52	@ 0x34
 8012008:	404a      	eors	r2, r1
 801200a:	601a      	str	r2, [r3, #0]
            rk[14] = rk[ 6] ^ rk[13];
 801200c:	69fb      	ldr	r3, [r7, #28]
 801200e:	3318      	adds	r3, #24
 8012010:	6819      	ldr	r1, [r3, #0]
 8012012:	69fb      	ldr	r3, [r7, #28]
 8012014:	3334      	adds	r3, #52	@ 0x34
 8012016:	681a      	ldr	r2, [r3, #0]
 8012018:	69fb      	ldr	r3, [r7, #28]
 801201a:	3338      	adds	r3, #56	@ 0x38
 801201c:	404a      	eors	r2, r1
 801201e:	601a      	str	r2, [r3, #0]
            rk[15] = rk[ 7] ^ rk[14];
 8012020:	69fb      	ldr	r3, [r7, #28]
 8012022:	331c      	adds	r3, #28
 8012024:	6819      	ldr	r1, [r3, #0]
 8012026:	69fb      	ldr	r3, [r7, #28]
 8012028:	3338      	adds	r3, #56	@ 0x38
 801202a:	681a      	ldr	r2, [r3, #0]
 801202c:	69fb      	ldr	r3, [r7, #28]
 801202e:	333c      	adds	r3, #60	@ 0x3c
 8012030:	404a      	eors	r2, r1
 8012032:	601a      	str	r2, [r3, #0]

            rk += 8;
 8012034:	69fb      	ldr	r3, [r7, #28]
 8012036:	3320      	adds	r3, #32
 8012038:	61fb      	str	r3, [r7, #28]
            temp = rk[ 7];
 801203a:	e74f      	b.n	8011edc <AesSetKey_C+0x1fc>
                break;
 801203c:	bf00      	nop
        }
        break;
 801203e:	bf00      	nop
#endif /* 256 */
    } /* switch */
    ForceZero(&temp, sizeof(temp));
 8012040:	f107 0310 	add.w	r3, r7, #16
 8012044:	2104      	movs	r1, #4
 8012046:	4618      	mov	r0, r3
 8012048:	f7fd fb91 	bl	800f76e <ForceZero>

#if defined(HAVE_AES_DECRYPT) && !defined(MAX3266X_AES)
    if (dir == AES_DECRYPTION) {
 801204c:	683b      	ldr	r3, [r7, #0]
 801204e:	2b01      	cmp	r3, #1
 8012050:	f040 819d 	bne.w	801238e <AesSetKey_C+0x6ae>
        unsigned int j;

#ifdef WC_C_DYNAMIC_FALLBACK
        rk = aes->key_C_fallback;
#else
        rk = aes->key;
 8012054:	68fb      	ldr	r3, [r7, #12]
 8012056:	61fb      	str	r3, [r7, #28]
#endif

        /* invert the order of the round keys: */
        for (i = 0, j = 4* aes->rounds; i < j; i += 4, j -= 4) {
 8012058:	2300      	movs	r3, #0
 801205a:	61bb      	str	r3, [r7, #24]
 801205c:	68fb      	ldr	r3, [r7, #12]
 801205e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012062:	009b      	lsls	r3, r3, #2
 8012064:	617b      	str	r3, [r7, #20]
 8012066:	e069      	b.n	801213c <AesSetKey_C+0x45c>
            temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;
 8012068:	69bb      	ldr	r3, [r7, #24]
 801206a:	009b      	lsls	r3, r3, #2
 801206c:	69fa      	ldr	r2, [r7, #28]
 801206e:	4413      	add	r3, r2
 8012070:	681b      	ldr	r3, [r3, #0]
 8012072:	613b      	str	r3, [r7, #16]
 8012074:	697b      	ldr	r3, [r7, #20]
 8012076:	009b      	lsls	r3, r3, #2
 8012078:	69fa      	ldr	r2, [r7, #28]
 801207a:	441a      	add	r2, r3
 801207c:	69bb      	ldr	r3, [r7, #24]
 801207e:	009b      	lsls	r3, r3, #2
 8012080:	69f9      	ldr	r1, [r7, #28]
 8012082:	440b      	add	r3, r1
 8012084:	6812      	ldr	r2, [r2, #0]
 8012086:	601a      	str	r2, [r3, #0]
 8012088:	697b      	ldr	r3, [r7, #20]
 801208a:	009b      	lsls	r3, r3, #2
 801208c:	69fa      	ldr	r2, [r7, #28]
 801208e:	4413      	add	r3, r2
 8012090:	693a      	ldr	r2, [r7, #16]
 8012092:	601a      	str	r2, [r3, #0]
            temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;
 8012094:	69bb      	ldr	r3, [r7, #24]
 8012096:	3301      	adds	r3, #1
 8012098:	009b      	lsls	r3, r3, #2
 801209a:	69fa      	ldr	r2, [r7, #28]
 801209c:	4413      	add	r3, r2
 801209e:	681b      	ldr	r3, [r3, #0]
 80120a0:	613b      	str	r3, [r7, #16]
 80120a2:	697b      	ldr	r3, [r7, #20]
 80120a4:	3301      	adds	r3, #1
 80120a6:	009b      	lsls	r3, r3, #2
 80120a8:	69fa      	ldr	r2, [r7, #28]
 80120aa:	441a      	add	r2, r3
 80120ac:	69bb      	ldr	r3, [r7, #24]
 80120ae:	3301      	adds	r3, #1
 80120b0:	009b      	lsls	r3, r3, #2
 80120b2:	69f9      	ldr	r1, [r7, #28]
 80120b4:	440b      	add	r3, r1
 80120b6:	6812      	ldr	r2, [r2, #0]
 80120b8:	601a      	str	r2, [r3, #0]
 80120ba:	697b      	ldr	r3, [r7, #20]
 80120bc:	3301      	adds	r3, #1
 80120be:	009b      	lsls	r3, r3, #2
 80120c0:	69fa      	ldr	r2, [r7, #28]
 80120c2:	4413      	add	r3, r2
 80120c4:	693a      	ldr	r2, [r7, #16]
 80120c6:	601a      	str	r2, [r3, #0]
            temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;
 80120c8:	69bb      	ldr	r3, [r7, #24]
 80120ca:	3302      	adds	r3, #2
 80120cc:	009b      	lsls	r3, r3, #2
 80120ce:	69fa      	ldr	r2, [r7, #28]
 80120d0:	4413      	add	r3, r2
 80120d2:	681b      	ldr	r3, [r3, #0]
 80120d4:	613b      	str	r3, [r7, #16]
 80120d6:	697b      	ldr	r3, [r7, #20]
 80120d8:	3302      	adds	r3, #2
 80120da:	009b      	lsls	r3, r3, #2
 80120dc:	69fa      	ldr	r2, [r7, #28]
 80120de:	441a      	add	r2, r3
 80120e0:	69bb      	ldr	r3, [r7, #24]
 80120e2:	3302      	adds	r3, #2
 80120e4:	009b      	lsls	r3, r3, #2
 80120e6:	69f9      	ldr	r1, [r7, #28]
 80120e8:	440b      	add	r3, r1
 80120ea:	6812      	ldr	r2, [r2, #0]
 80120ec:	601a      	str	r2, [r3, #0]
 80120ee:	697b      	ldr	r3, [r7, #20]
 80120f0:	3302      	adds	r3, #2
 80120f2:	009b      	lsls	r3, r3, #2
 80120f4:	69fa      	ldr	r2, [r7, #28]
 80120f6:	4413      	add	r3, r2
 80120f8:	693a      	ldr	r2, [r7, #16]
 80120fa:	601a      	str	r2, [r3, #0]
            temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
 80120fc:	69bb      	ldr	r3, [r7, #24]
 80120fe:	3303      	adds	r3, #3
 8012100:	009b      	lsls	r3, r3, #2
 8012102:	69fa      	ldr	r2, [r7, #28]
 8012104:	4413      	add	r3, r2
 8012106:	681b      	ldr	r3, [r3, #0]
 8012108:	613b      	str	r3, [r7, #16]
 801210a:	697b      	ldr	r3, [r7, #20]
 801210c:	3303      	adds	r3, #3
 801210e:	009b      	lsls	r3, r3, #2
 8012110:	69fa      	ldr	r2, [r7, #28]
 8012112:	441a      	add	r2, r3
 8012114:	69bb      	ldr	r3, [r7, #24]
 8012116:	3303      	adds	r3, #3
 8012118:	009b      	lsls	r3, r3, #2
 801211a:	69f9      	ldr	r1, [r7, #28]
 801211c:	440b      	add	r3, r1
 801211e:	6812      	ldr	r2, [r2, #0]
 8012120:	601a      	str	r2, [r3, #0]
 8012122:	697b      	ldr	r3, [r7, #20]
 8012124:	3303      	adds	r3, #3
 8012126:	009b      	lsls	r3, r3, #2
 8012128:	69fa      	ldr	r2, [r7, #28]
 801212a:	4413      	add	r3, r2
 801212c:	693a      	ldr	r2, [r7, #16]
 801212e:	601a      	str	r2, [r3, #0]
        for (i = 0, j = 4* aes->rounds; i < j; i += 4, j -= 4) {
 8012130:	69bb      	ldr	r3, [r7, #24]
 8012132:	3304      	adds	r3, #4
 8012134:	61bb      	str	r3, [r7, #24]
 8012136:	697b      	ldr	r3, [r7, #20]
 8012138:	3b04      	subs	r3, #4
 801213a:	617b      	str	r3, [r7, #20]
 801213c:	69ba      	ldr	r2, [r7, #24]
 801213e:	697b      	ldr	r3, [r7, #20]
 8012140:	429a      	cmp	r2, r3
 8012142:	d391      	bcc.n	8012068 <AesSetKey_C+0x388>
        }
        ForceZero(&temp, sizeof(temp));
 8012144:	f107 0310 	add.w	r3, r7, #16
 8012148:	2104      	movs	r1, #4
 801214a:	4618      	mov	r0, r3
 801214c:	f7fd fb0f 	bl	800f76e <ForceZero>
    #if !defined(WOLFSSL_AES_SMALL_TABLES)
        /* apply the inverse MixColumn transform to all round keys but the
           first and the last: */
        for (i = 1; i < aes->rounds; i++) {
 8012150:	2301      	movs	r3, #1
 8012152:	61bb      	str	r3, [r7, #24]
 8012154:	e114      	b.n	8012380 <AesSetKey_C+0x6a0>
 8012156:	bf00      	nop
 8012158:	08031328 	.word	0x08031328
 801215c:	08031300 	.word	0x08031300
            rk += 4;
 8012160:	69fb      	ldr	r3, [r7, #28]
 8012162:	3310      	adds	r3, #16
 8012164:	61fb      	str	r3, [r7, #28]
            rk[0] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[0], 3)) & 0xff) ^
 8012166:	69fb      	ldr	r3, [r7, #28]
 8012168:	681b      	ldr	r3, [r3, #0]
 801216a:	0e1b      	lsrs	r3, r3, #24
 801216c:	b2db      	uxtb	r3, r3
 801216e:	4a8a      	ldr	r2, [pc, #552]	@ (8012398 <AesSetKey_C+0x6b8>)
 8012170:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012174:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012178:	b2db      	uxtb	r3, r3
 801217a:	4a88      	ldr	r2, [pc, #544]	@ (801239c <AesSetKey_C+0x6bc>)
 801217c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[0], 2)) & 0xff) ^
 8012180:	69fb      	ldr	r3, [r7, #28]
 8012182:	681b      	ldr	r3, [r3, #0]
 8012184:	0c1b      	lsrs	r3, r3, #16
 8012186:	b2db      	uxtb	r3, r3
 8012188:	4983      	ldr	r1, [pc, #524]	@ (8012398 <AesSetKey_C+0x6b8>)
 801218a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801218e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012192:	b2db      	uxtb	r3, r3
 8012194:	4981      	ldr	r1, [pc, #516]	@ (801239c <AesSetKey_C+0x6bc>)
 8012196:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801219a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[0], 3)) & 0xff) ^
 801219e:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 80121a0:	69fb      	ldr	r3, [r7, #28]
 80121a2:	681b      	ldr	r3, [r3, #0]
 80121a4:	0a1b      	lsrs	r3, r3, #8
 80121a6:	b2db      	uxtb	r3, r3
 80121a8:	497b      	ldr	r1, [pc, #492]	@ (8012398 <AesSetKey_C+0x6b8>)
 80121aa:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80121ae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80121b2:	b2db      	uxtb	r3, r3
 80121b4:	4979      	ldr	r1, [pc, #484]	@ (801239c <AesSetKey_C+0x6bc>)
 80121b6:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80121ba:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[0], 2)) & 0xff) ^
 80121be:	405a      	eors	r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[0], 0)) & 0xff);
 80121c0:	69fb      	ldr	r3, [r7, #28]
 80121c2:	681b      	ldr	r3, [r3, #0]
 80121c4:	b2db      	uxtb	r3, r3
 80121c6:	4974      	ldr	r1, [pc, #464]	@ (8012398 <AesSetKey_C+0x6b8>)
 80121c8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80121cc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80121d0:	b2db      	uxtb	r3, r3
 80121d2:	4972      	ldr	r1, [pc, #456]	@ (801239c <AesSetKey_C+0x6bc>)
 80121d4:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80121d8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 80121dc:	405a      	eors	r2, r3
            rk[0] =
 80121de:	69fb      	ldr	r3, [r7, #28]
 80121e0:	601a      	str	r2, [r3, #0]
            rk[1] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[1], 3)) & 0xff) ^
 80121e2:	69fb      	ldr	r3, [r7, #28]
 80121e4:	3304      	adds	r3, #4
 80121e6:	681b      	ldr	r3, [r3, #0]
 80121e8:	0e1b      	lsrs	r3, r3, #24
 80121ea:	b2db      	uxtb	r3, r3
 80121ec:	4a6a      	ldr	r2, [pc, #424]	@ (8012398 <AesSetKey_C+0x6b8>)
 80121ee:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80121f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80121f6:	b2db      	uxtb	r3, r3
 80121f8:	4a68      	ldr	r2, [pc, #416]	@ (801239c <AesSetKey_C+0x6bc>)
 80121fa:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[1], 2)) & 0xff) ^
 80121fe:	69fb      	ldr	r3, [r7, #28]
 8012200:	3304      	adds	r3, #4
 8012202:	681b      	ldr	r3, [r3, #0]
 8012204:	0c1b      	lsrs	r3, r3, #16
 8012206:	b2db      	uxtb	r3, r3
 8012208:	4963      	ldr	r1, [pc, #396]	@ (8012398 <AesSetKey_C+0x6b8>)
 801220a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801220e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012212:	b2db      	uxtb	r3, r3
 8012214:	4961      	ldr	r1, [pc, #388]	@ (801239c <AesSetKey_C+0x6bc>)
 8012216:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801221a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[1], 3)) & 0xff) ^
 801221e:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 8012220:	69fb      	ldr	r3, [r7, #28]
 8012222:	3304      	adds	r3, #4
 8012224:	681b      	ldr	r3, [r3, #0]
 8012226:	0a1b      	lsrs	r3, r3, #8
 8012228:	b2db      	uxtb	r3, r3
 801222a:	495b      	ldr	r1, [pc, #364]	@ (8012398 <AesSetKey_C+0x6b8>)
 801222c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012230:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012234:	b2db      	uxtb	r3, r3
 8012236:	4959      	ldr	r1, [pc, #356]	@ (801239c <AesSetKey_C+0x6bc>)
 8012238:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801223c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[1], 2)) & 0xff) ^
 8012240:	ea82 0103 	eor.w	r1, r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[1], 0)) & 0xff);
 8012244:	69fb      	ldr	r3, [r7, #28]
 8012246:	3304      	adds	r3, #4
 8012248:	681b      	ldr	r3, [r3, #0]
 801224a:	b2db      	uxtb	r3, r3
 801224c:	4a52      	ldr	r2, [pc, #328]	@ (8012398 <AesSetKey_C+0x6b8>)
 801224e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012252:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012256:	b2db      	uxtb	r3, r3
 8012258:	4a50      	ldr	r2, [pc, #320]	@ (801239c <AesSetKey_C+0x6bc>)
 801225a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801225e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[1] =
 8012262:	69fb      	ldr	r3, [r7, #28]
 8012264:	3304      	adds	r3, #4
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 8012266:	404a      	eors	r2, r1
            rk[1] =
 8012268:	601a      	str	r2, [r3, #0]
            rk[2] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[2], 3)) & 0xff) ^
 801226a:	69fb      	ldr	r3, [r7, #28]
 801226c:	3308      	adds	r3, #8
 801226e:	681b      	ldr	r3, [r3, #0]
 8012270:	0e1b      	lsrs	r3, r3, #24
 8012272:	b2db      	uxtb	r3, r3
 8012274:	4a48      	ldr	r2, [pc, #288]	@ (8012398 <AesSetKey_C+0x6b8>)
 8012276:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801227a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801227e:	b2db      	uxtb	r3, r3
 8012280:	4a46      	ldr	r2, [pc, #280]	@ (801239c <AesSetKey_C+0x6bc>)
 8012282:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[2], 2)) & 0xff) ^
 8012286:	69fb      	ldr	r3, [r7, #28]
 8012288:	3308      	adds	r3, #8
 801228a:	681b      	ldr	r3, [r3, #0]
 801228c:	0c1b      	lsrs	r3, r3, #16
 801228e:	b2db      	uxtb	r3, r3
 8012290:	4941      	ldr	r1, [pc, #260]	@ (8012398 <AesSetKey_C+0x6b8>)
 8012292:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012296:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801229a:	b2db      	uxtb	r3, r3
 801229c:	493f      	ldr	r1, [pc, #252]	@ (801239c <AesSetKey_C+0x6bc>)
 801229e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80122a2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[2], 3)) & 0xff) ^
 80122a6:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 80122a8:	69fb      	ldr	r3, [r7, #28]
 80122aa:	3308      	adds	r3, #8
 80122ac:	681b      	ldr	r3, [r3, #0]
 80122ae:	0a1b      	lsrs	r3, r3, #8
 80122b0:	b2db      	uxtb	r3, r3
 80122b2:	4939      	ldr	r1, [pc, #228]	@ (8012398 <AesSetKey_C+0x6b8>)
 80122b4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80122b8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80122bc:	b2db      	uxtb	r3, r3
 80122be:	4937      	ldr	r1, [pc, #220]	@ (801239c <AesSetKey_C+0x6bc>)
 80122c0:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80122c4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[2], 2)) & 0xff) ^
 80122c8:	ea82 0103 	eor.w	r1, r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[2], 0)) & 0xff);
 80122cc:	69fb      	ldr	r3, [r7, #28]
 80122ce:	3308      	adds	r3, #8
 80122d0:	681b      	ldr	r3, [r3, #0]
 80122d2:	b2db      	uxtb	r3, r3
 80122d4:	4a30      	ldr	r2, [pc, #192]	@ (8012398 <AesSetKey_C+0x6b8>)
 80122d6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80122da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80122de:	b2db      	uxtb	r3, r3
 80122e0:	4a2e      	ldr	r2, [pc, #184]	@ (801239c <AesSetKey_C+0x6bc>)
 80122e2:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 80122e6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[2] =
 80122ea:	69fb      	ldr	r3, [r7, #28]
 80122ec:	3308      	adds	r3, #8
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 80122ee:	404a      	eors	r2, r1
            rk[2] =
 80122f0:	601a      	str	r2, [r3, #0]
            rk[3] =
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[3], 3)) & 0xff) ^
 80122f2:	69fb      	ldr	r3, [r7, #28]
 80122f4:	330c      	adds	r3, #12
 80122f6:	681b      	ldr	r3, [r3, #0]
 80122f8:	0e1b      	lsrs	r3, r3, #24
 80122fa:	b2db      	uxtb	r3, r3
 80122fc:	4a26      	ldr	r2, [pc, #152]	@ (8012398 <AesSetKey_C+0x6b8>)
 80122fe:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012302:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012306:	b2db      	uxtb	r3, r3
 8012308:	4a24      	ldr	r2, [pc, #144]	@ (801239c <AesSetKey_C+0x6bc>)
 801230a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[3], 2)) & 0xff) ^
 801230e:	69fb      	ldr	r3, [r7, #28]
 8012310:	330c      	adds	r3, #12
 8012312:	681b      	ldr	r3, [r3, #0]
 8012314:	0c1b      	lsrs	r3, r3, #16
 8012316:	b2db      	uxtb	r3, r3
 8012318:	491f      	ldr	r1, [pc, #124]	@ (8012398 <AesSetKey_C+0x6b8>)
 801231a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801231e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012322:	b2db      	uxtb	r3, r3
 8012324:	491d      	ldr	r1, [pc, #116]	@ (801239c <AesSetKey_C+0x6bc>)
 8012326:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 801232a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[3], 3)) & 0xff) ^
 801232e:	405a      	eors	r2, r3
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 8012330:	69fb      	ldr	r3, [r7, #28]
 8012332:	330c      	adds	r3, #12
 8012334:	681b      	ldr	r3, [r3, #0]
 8012336:	0a1b      	lsrs	r3, r3, #8
 8012338:	b2db      	uxtb	r3, r3
 801233a:	4917      	ldr	r1, [pc, #92]	@ (8012398 <AesSetKey_C+0x6b8>)
 801233c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012340:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8012344:	b2db      	uxtb	r3, r3
 8012346:	4915      	ldr	r1, [pc, #84]	@ (801239c <AesSetKey_C+0x6bc>)
 8012348:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 801234c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[3], 2)) & 0xff) ^
 8012350:	ea82 0103 	eor.w	r1, r2, r3
                GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[3], 0)) & 0xff);
 8012354:	69fb      	ldr	r3, [r7, #28]
 8012356:	330c      	adds	r3, #12
 8012358:	681b      	ldr	r3, [r3, #0]
 801235a:	b2db      	uxtb	r3, r3
 801235c:	4a0e      	ldr	r2, [pc, #56]	@ (8012398 <AesSetKey_C+0x6b8>)
 801235e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8012362:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012366:	b2db      	uxtb	r3, r3
 8012368:	4a0c      	ldr	r2, [pc, #48]	@ (801239c <AesSetKey_C+0x6bc>)
 801236a:	f503 7340 	add.w	r3, r3, #768	@ 0x300
 801236e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
            rk[3] =
 8012372:	69fb      	ldr	r3, [r7, #28]
 8012374:	330c      	adds	r3, #12
                GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 8012376:	404a      	eors	r2, r1
            rk[3] =
 8012378:	601a      	str	r2, [r3, #0]
        for (i = 1; i < aes->rounds; i++) {
 801237a:	69bb      	ldr	r3, [r7, #24]
 801237c:	3301      	adds	r3, #1
 801237e:	61bb      	str	r3, [r7, #24]
 8012380:	68fb      	ldr	r3, [r7, #12]
 8012382:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012386:	69ba      	ldr	r2, [r7, #24]
 8012388:	429a      	cmp	r2, r3
 801238a:	f4ff aee9 	bcc.w	8012160 <AesSetKey_C+0x480>
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(&temp, sizeof(temp));
#else
    (void)temp;
#endif
}
 801238e:	bf00      	nop
 8012390:	3720      	adds	r7, #32
 8012392:	46bd      	mov	sp, r7
 8012394:	bd80      	pop	{r7, pc}
 8012396:	bf00      	nop
 8012398:	08031328 	.word	0x08031328
 801239c:	08032328 	.word	0x08032328

080123a0 <wc_AesSetKeyLocal>:
#ifndef WOLFSSL_RISCV_ASM
    /* Software AES - SetKey */
    static WARN_UNUSED_RESULT int wc_AesSetKeyLocal(
        Aes* aes, const byte* userKey, word32 keylen, const byte* iv, int dir,
        int checkKeyLen)
    {
 80123a0:	b580      	push	{r7, lr}
 80123a2:	b086      	sub	sp, #24
 80123a4:	af00      	add	r7, sp, #0
 80123a6:	60f8      	str	r0, [r7, #12]
 80123a8:	60b9      	str	r1, [r7, #8]
 80123aa:	607a      	str	r2, [r7, #4]
 80123ac:	603b      	str	r3, [r7, #0]
    #ifdef WOLFSSL_IMX6_CAAM_BLOB
        byte   local[32];
        word32 localSz = 32;
    #endif

        if (aes == NULL)
 80123ae:	68fb      	ldr	r3, [r7, #12]
 80123b0:	2b00      	cmp	r3, #0
 80123b2:	d102      	bne.n	80123ba <wc_AesSetKeyLocal+0x1a>
            return BAD_FUNC_ARG;
 80123b4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80123b8:	e054      	b.n	8012464 <wc_AesSetKeyLocal+0xc4>
        ret = wc_debug_CipherLifecycleCheck(aes->CipherLifecycleTag, 0);
        if (ret < 0)
            return ret;
#endif

        switch (keylen) {
 80123ba:	687b      	ldr	r3, [r7, #4]
 80123bc:	3b10      	subs	r3, #16
 80123be:	2b10      	cmp	r3, #16
 80123c0:	bf8c      	ite	hi
 80123c2:	2201      	movhi	r2, #1
 80123c4:	2200      	movls	r2, #0
 80123c6:	b2d2      	uxtb	r2, r2
 80123c8:	2a00      	cmp	r2, #0
 80123ca:	d10b      	bne.n	80123e4 <wc_AesSetKeyLocal+0x44>
 80123cc:	4a27      	ldr	r2, [pc, #156]	@ (801246c <wc_AesSetKeyLocal+0xcc>)
 80123ce:	fa22 f303 	lsr.w	r3, r2, r3
 80123d2:	f003 0301 	and.w	r3, r3, #1
 80123d6:	2b00      	cmp	r3, #0
 80123d8:	bf14      	ite	ne
 80123da:	2301      	movne	r3, #1
 80123dc:	2300      	moveq	r3, #0
 80123de:	b2db      	uxtb	r3, r3
 80123e0:	2b00      	cmp	r3, #0
 80123e2:	d102      	bne.n	80123ea <wc_AesSetKeyLocal+0x4a>
        defined(WOLFSSL_AES_256)
        case 32:
    #endif
            break;
        default:
            return BAD_FUNC_ARG;
 80123e4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80123e8:	e03c      	b.n	8012464 <wc_AesSetKeyLocal+0xc4>
            break;
 80123ea:	bf00      	nop
            }
            XMEMCPY(aes->devKey, userKey, keylen);
        }
    #endif

        if (checkKeyLen) {
 80123ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80123ee:	2b00      	cmp	r3, #0
 80123f0:	d00b      	beq.n	801240a <wc_AesSetKeyLocal+0x6a>
            if (keylen != 16 && keylen != 24 && keylen != 32) {
 80123f2:	687b      	ldr	r3, [r7, #4]
 80123f4:	2b10      	cmp	r3, #16
 80123f6:	d008      	beq.n	801240a <wc_AesSetKeyLocal+0x6a>
 80123f8:	687b      	ldr	r3, [r7, #4]
 80123fa:	2b18      	cmp	r3, #24
 80123fc:	d005      	beq.n	801240a <wc_AesSetKeyLocal+0x6a>
 80123fe:	687b      	ldr	r3, [r7, #4]
 8012400:	2b20      	cmp	r3, #32
 8012402:	d002      	beq.n	801240a <wc_AesSetKeyLocal+0x6a>
                return BAD_FUNC_ARG;
 8012404:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8012408:	e02c      	b.n	8012464 <wc_AesSetKeyLocal+0xc4>
    #if defined(WOLFSSL_AES_COUNTER) || defined(WOLFSSL_AES_CFB) || \
        defined(WOLFSSL_AES_OFB) || defined(WOLFSSL_AES_XTS)
        aes->left = 0;
    #endif

        aes->keylen = (int)keylen;
 801240a:	687a      	ldr	r2, [r7, #4]
 801240c:	68fb      	ldr	r3, [r7, #12]
 801240e:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
        aes->rounds = (keylen/4) + 6;
 8012412:	687b      	ldr	r3, [r7, #4]
 8012414:	089b      	lsrs	r3, r3, #2
 8012416:	1d9a      	adds	r2, r3, #6
 8012418:	68fb      	ldr	r3, [r7, #12]
 801241a:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
        ret = wc_AesSetIV(aes, iv);
 801241e:	6839      	ldr	r1, [r7, #0]
 8012420:	68f8      	ldr	r0, [r7, #12]
 8012422:	f000 f847 	bl	80124b4 <wc_AesSetIV>
 8012426:	6178      	str	r0, [r7, #20]
        if (ret != 0)
 8012428:	697b      	ldr	r3, [r7, #20]
 801242a:	2b00      	cmp	r3, #0
 801242c:	d001      	beq.n	8012432 <wc_AesSetKeyLocal+0x92>
            return ret;
 801242e:	697b      	ldr	r3, [r7, #20]
 8012430:	e018      	b.n	8012464 <wc_AesSetKeyLocal+0xc4>
            aes->init = 0;
        }
        (void)dir;
    #endif

        if (keylen > sizeof(aes->key)) {
 8012432:	687b      	ldr	r3, [r7, #4]
 8012434:	2bf0      	cmp	r3, #240	@ 0xf0
 8012436:	d902      	bls.n	801243e <wc_AesSetKeyLocal+0x9e>
            return BAD_FUNC_ARG;
 8012438:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801243c:	e012      	b.n	8012464 <wc_AesSetKeyLocal+0xc4>
            }
            return ret;
        }
#endif

        XMEMCPY(aes->key, userKey, keylen);
 801243e:	68fb      	ldr	r3, [r7, #12]
 8012440:	687a      	ldr	r2, [r7, #4]
 8012442:	68b9      	ldr	r1, [r7, #8]
 8012444:	4618      	mov	r0, r3
 8012446:	f016 f8ad 	bl	80285a4 <memcpy>
    #if defined(LITTLE_ENDIAN_ORDER) && !defined(WOLFSSL_PIC32MZ_CRYPT) && \
        (!defined(WOLFSSL_ESP32_CRYPT) || defined(NO_WOLFSSL_ESP32_CRYPT_AES)) \
        && !defined(MAX3266X_AES)

        /* software */
        ByteReverseWords(aes->key, aes->key, keylen);
 801244a:	68fb      	ldr	r3, [r7, #12]
 801244c:	68f9      	ldr	r1, [r7, #12]
 801244e:	687a      	ldr	r2, [r7, #4]
 8012450:	4618      	mov	r0, r3
 8012452:	f7fd f8e7 	bl	800f624 <ByteReverseWords>
        }
    #endif
#endif /* !WC_AES_BITSLICED */

#ifdef NEED_AES_TABLES
        AesSetKey_C(aes, userKey, keylen, dir);
 8012456:	6a3b      	ldr	r3, [r7, #32]
 8012458:	687a      	ldr	r2, [r7, #4]
 801245a:	68b9      	ldr	r1, [r7, #8]
 801245c:	68f8      	ldr	r0, [r7, #12]
 801245e:	f7ff fc3f 	bl	8011ce0 <AesSetKey_C>
        aes->ctx.cfd = -1;
    #endif
    #ifdef WOLFSSL_IMX6_CAAM_BLOB
        ForceZero(local, sizeof(local));
    #endif
        return ret;
 8012462:	697b      	ldr	r3, [r7, #20]
    } /* wc_AesSetKeyLocal */
 8012464:	4618      	mov	r0, r3
 8012466:	3718      	adds	r7, #24
 8012468:	46bd      	mov	sp, r7
 801246a:	bd80      	pop	{r7, pc}
 801246c:	00010101 	.word	0x00010101

08012470 <wc_AesSetKey>:

    int wc_AesSetKey(Aes* aes, const byte* userKey, word32 keylen,
            const byte* iv, int dir)
    {
 8012470:	b580      	push	{r7, lr}
 8012472:	b086      	sub	sp, #24
 8012474:	af02      	add	r7, sp, #8
 8012476:	60f8      	str	r0, [r7, #12]
 8012478:	60b9      	str	r1, [r7, #8]
 801247a:	607a      	str	r2, [r7, #4]
 801247c:	603b      	str	r3, [r7, #0]
        if (aes == NULL) {
 801247e:	68fb      	ldr	r3, [r7, #12]
 8012480:	2b00      	cmp	r3, #0
 8012482:	d102      	bne.n	801248a <wc_AesSetKey+0x1a>
            return BAD_FUNC_ARG;
 8012484:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8012488:	e010      	b.n	80124ac <wc_AesSetKey+0x3c>
        }
        if (keylen > sizeof(aes->key)) {
 801248a:	687b      	ldr	r3, [r7, #4]
 801248c:	2bf0      	cmp	r3, #240	@ 0xf0
 801248e:	d902      	bls.n	8012496 <wc_AesSetKey+0x26>
            return BAD_FUNC_ARG;
 8012490:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8012494:	e00a      	b.n	80124ac <wc_AesSetKey+0x3c>
                           keylen);
        #endif
        }
    #endif /* WOLFSSL_ESPIDF && NEED_AES_HW_FALLBACK */

        return wc_AesSetKeyLocal(aes, userKey, keylen, iv, dir, 1);
 8012496:	2301      	movs	r3, #1
 8012498:	9301      	str	r3, [sp, #4]
 801249a:	69bb      	ldr	r3, [r7, #24]
 801249c:	9300      	str	r3, [sp, #0]
 801249e:	683b      	ldr	r3, [r7, #0]
 80124a0:	687a      	ldr	r2, [r7, #4]
 80124a2:	68b9      	ldr	r1, [r7, #8]
 80124a4:	68f8      	ldr	r0, [r7, #12]
 80124a6:	f7ff ff7b 	bl	80123a0 <wc_AesSetKeyLocal>
 80124aa:	4603      	mov	r3, r0

    } /* wc_AesSetKey() */
 80124ac:	4618      	mov	r0, r3
 80124ae:	3710      	adds	r7, #16
 80124b0:	46bd      	mov	sp, r7
 80124b2:	bd80      	pop	{r7, pc}

080124b4 <wc_AesSetIV>:
#endif /* wc_AesSetKey block */


/* wc_AesSetIV is shared between software and hardware */
int wc_AesSetIV(Aes* aes, const byte* iv)
{
 80124b4:	b580      	push	{r7, lr}
 80124b6:	b082      	sub	sp, #8
 80124b8:	af00      	add	r7, sp, #0
 80124ba:	6078      	str	r0, [r7, #4]
 80124bc:	6039      	str	r1, [r7, #0]
    if (aes == NULL)
 80124be:	687b      	ldr	r3, [r7, #4]
 80124c0:	2b00      	cmp	r3, #0
 80124c2:	d102      	bne.n	80124ca <wc_AesSetIV+0x16>
        return BAD_FUNC_ARG;
 80124c4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80124c8:	e012      	b.n	80124f0 <wc_AesSetIV+0x3c>
        if (ret < 0)
            return ret;
    }
#endif

    if (iv)
 80124ca:	683b      	ldr	r3, [r7, #0]
 80124cc:	2b00      	cmp	r3, #0
 80124ce:	d007      	beq.n	80124e0 <wc_AesSetIV+0x2c>
        XMEMCPY(aes->reg, iv, WC_AES_BLOCK_SIZE);
 80124d0:	687b      	ldr	r3, [r7, #4]
 80124d2:	33f8      	adds	r3, #248	@ 0xf8
 80124d4:	2210      	movs	r2, #16
 80124d6:	6839      	ldr	r1, [r7, #0]
 80124d8:	4618      	mov	r0, r3
 80124da:	f016 f863 	bl	80285a4 <memcpy>
 80124de:	e006      	b.n	80124ee <wc_AesSetIV+0x3a>
    else
        XMEMSET(aes->reg,  0, WC_AES_BLOCK_SIZE);
 80124e0:	687b      	ldr	r3, [r7, #4]
 80124e2:	33f8      	adds	r3, #248	@ 0xf8
 80124e4:	2210      	movs	r2, #16
 80124e6:	2100      	movs	r1, #0
 80124e8:	4618      	mov	r0, r3
 80124ea:	f015 fff1 	bl	80284d0 <memset>
    defined(WOLFSSL_AES_OFB) || defined(WOLFSSL_AES_XTS)
    /* Clear any unused bytes from last cipher op. */
    aes->left = 0;
#endif

    return 0;
 80124ee:	2300      	movs	r3, #0
}
 80124f0:	4618      	mov	r0, r3
 80124f2:	3708      	adds	r7, #8
 80124f4:	46bd      	mov	sp, r7
 80124f6:	bd80      	pop	{r7, pc}

080124f8 <wc_AesCbcEncrypt>:

#ifdef NEED_SW_AESCBC
    /* Software AES - CBC Encrypt */

int wc_AesCbcEncrypt(Aes* aes, byte* out, const byte* in, word32 sz)
    {
 80124f8:	b580      	push	{r7, lr}
 80124fa:	b086      	sub	sp, #24
 80124fc:	af00      	add	r7, sp, #0
 80124fe:	60f8      	str	r0, [r7, #12]
 8012500:	60b9      	str	r1, [r7, #8]
 8012502:	607a      	str	r2, [r7, #4]
 8012504:	603b      	str	r3, [r7, #0]
        word32 blocks;
        int ret;

        if (aes == NULL || out == NULL || in == NULL) {
 8012506:	68fb      	ldr	r3, [r7, #12]
 8012508:	2b00      	cmp	r3, #0
 801250a:	d005      	beq.n	8012518 <wc_AesCbcEncrypt+0x20>
 801250c:	68bb      	ldr	r3, [r7, #8]
 801250e:	2b00      	cmp	r3, #0
 8012510:	d002      	beq.n	8012518 <wc_AesCbcEncrypt+0x20>
 8012512:	687b      	ldr	r3, [r7, #4]
 8012514:	2b00      	cmp	r3, #0
 8012516:	d102      	bne.n	801251e <wc_AesCbcEncrypt+0x26>
            return BAD_FUNC_ARG;
 8012518:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801251c:	e033      	b.n	8012586 <wc_AesCbcEncrypt+0x8e>
        }

        if (sz == 0) {
 801251e:	683b      	ldr	r3, [r7, #0]
 8012520:	2b00      	cmp	r3, #0
 8012522:	d101      	bne.n	8012528 <wc_AesCbcEncrypt+0x30>
            return 0;
 8012524:	2300      	movs	r3, #0
 8012526:	e02e      	b.n	8012586 <wc_AesCbcEncrypt+0x8e>
        }

        blocks = sz / WC_AES_BLOCK_SIZE;
 8012528:	683b      	ldr	r3, [r7, #0]
 801252a:	091b      	lsrs	r3, r3, #4
 801252c:	617b      	str	r3, [r7, #20]
            ret = 0;
        }
        else
    #endif
        {
            ret = 0;
 801252e:	2300      	movs	r3, #0
 8012530:	613b      	str	r3, [r7, #16]
            while (blocks--) {
 8012532:	e020      	b.n	8012576 <wc_AesCbcEncrypt+0x7e>
                xorbuf((byte*)aes->reg, in, WC_AES_BLOCK_SIZE);
 8012534:	68fb      	ldr	r3, [r7, #12]
 8012536:	33f8      	adds	r3, #248	@ 0xf8
 8012538:	2210      	movs	r2, #16
 801253a:	6879      	ldr	r1, [r7, #4]
 801253c:	4618      	mov	r0, r3
 801253e:	f7fd f8bc 	bl	800f6ba <xorbuf>
                ret = wc_AesEncrypt(aes, (byte*)aes->reg, (byte*)aes->reg);
 8012542:	68fb      	ldr	r3, [r7, #12]
 8012544:	f103 01f8 	add.w	r1, r3, #248	@ 0xf8
 8012548:	68fb      	ldr	r3, [r7, #12]
 801254a:	33f8      	adds	r3, #248	@ 0xf8
 801254c:	461a      	mov	r2, r3
 801254e:	68f8      	ldr	r0, [r7, #12]
 8012550:	f7fe fa52 	bl	80109f8 <wc_AesEncrypt>
 8012554:	6138      	str	r0, [r7, #16]
                if (ret != 0)
 8012556:	693b      	ldr	r3, [r7, #16]
 8012558:	2b00      	cmp	r3, #0
 801255a:	d112      	bne.n	8012582 <wc_AesCbcEncrypt+0x8a>
                    break;
                XMEMCPY(out, aes->reg, WC_AES_BLOCK_SIZE);
 801255c:	68fb      	ldr	r3, [r7, #12]
 801255e:	33f8      	adds	r3, #248	@ 0xf8
 8012560:	2210      	movs	r2, #16
 8012562:	4619      	mov	r1, r3
 8012564:	68b8      	ldr	r0, [r7, #8]
 8012566:	f016 f81d 	bl	80285a4 <memcpy>

                out += WC_AES_BLOCK_SIZE;
 801256a:	68bb      	ldr	r3, [r7, #8]
 801256c:	3310      	adds	r3, #16
 801256e:	60bb      	str	r3, [r7, #8]
                in  += WC_AES_BLOCK_SIZE;
 8012570:	687b      	ldr	r3, [r7, #4]
 8012572:	3310      	adds	r3, #16
 8012574:	607b      	str	r3, [r7, #4]
            while (blocks--) {
 8012576:	697b      	ldr	r3, [r7, #20]
 8012578:	1e5a      	subs	r2, r3, #1
 801257a:	617a      	str	r2, [r7, #20]
 801257c:	2b00      	cmp	r3, #0
 801257e:	d1d9      	bne.n	8012534 <wc_AesCbcEncrypt+0x3c>
 8012580:	e000      	b.n	8012584 <wc_AesCbcEncrypt+0x8c>
                    break;
 8012582:	bf00      	nop

    #ifdef WOLFSSL_AESNI
        VECTOR_REGISTERS_POP;
    #endif

        return ret;
 8012584:	693b      	ldr	r3, [r7, #16]
    } /* wc_AesCbcEncrypt */
 8012586:	4618      	mov	r0, r3
 8012588:	3718      	adds	r7, #24
 801258a:	46bd      	mov	sp, r7
 801258c:	bd80      	pop	{r7, pc}

0801258e <wc_AesCbcDecrypt>:

#ifdef HAVE_AES_DECRYPT
    /* Software AES - CBC Decrypt */
    int wc_AesCbcDecrypt(Aes* aes, byte* out, const byte* in, word32 sz)
    {
 801258e:	b580      	push	{r7, lr}
 8012590:	b086      	sub	sp, #24
 8012592:	af00      	add	r7, sp, #0
 8012594:	60f8      	str	r0, [r7, #12]
 8012596:	60b9      	str	r1, [r7, #8]
 8012598:	607a      	str	r2, [r7, #4]
 801259a:	603b      	str	r3, [r7, #0]
        word32 blocks;
        int ret;

        if (aes == NULL || out == NULL || in == NULL) {
 801259c:	68fb      	ldr	r3, [r7, #12]
 801259e:	2b00      	cmp	r3, #0
 80125a0:	d005      	beq.n	80125ae <wc_AesCbcDecrypt+0x20>
 80125a2:	68bb      	ldr	r3, [r7, #8]
 80125a4:	2b00      	cmp	r3, #0
 80125a6:	d002      	beq.n	80125ae <wc_AesCbcDecrypt+0x20>
 80125a8:	687b      	ldr	r3, [r7, #4]
 80125aa:	2b00      	cmp	r3, #0
 80125ac:	d102      	bne.n	80125b4 <wc_AesCbcDecrypt+0x26>
            return BAD_FUNC_ARG;
 80125ae:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80125b2:	e042      	b.n	801263a <wc_AesCbcDecrypt+0xac>
        }

        if (sz == 0) {
 80125b4:	683b      	ldr	r3, [r7, #0]
 80125b6:	2b00      	cmp	r3, #0
 80125b8:	d101      	bne.n	80125be <wc_AesCbcDecrypt+0x30>
            return 0;
 80125ba:	2300      	movs	r3, #0
 80125bc:	e03d      	b.n	801263a <wc_AesCbcDecrypt+0xac>
                          "unsupported keylen = %d", aes->keylen);
        #endif
        }
    #endif

        blocks = sz / WC_AES_BLOCK_SIZE;
 80125be:	683b      	ldr	r3, [r7, #0]
 80125c0:	091b      	lsrs	r3, r3, #4
 80125c2:	617b      	str	r3, [r7, #20]
        if (sz % WC_AES_BLOCK_SIZE) {
 80125c4:	683b      	ldr	r3, [r7, #0]
 80125c6:	f003 030f 	and.w	r3, r3, #15
 80125ca:	2b00      	cmp	r3, #0
 80125cc:	d002      	beq.n	80125d4 <wc_AesCbcDecrypt+0x46>
#ifdef WOLFSSL_AES_CBC_LENGTH_CHECKS
            return BAD_LENGTH_E;
#else
            return BAD_FUNC_ARG;
 80125ce:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80125d2:	e032      	b.n	801263a <wc_AesCbcDecrypt+0xac>
            ret = 0;
        }
        else
    #endif
        {
            ret = 0;
 80125d4:	2300      	movs	r3, #0
 80125d6:	613b      	str	r3, [r7, #16]

                    blocks = 0;
                }
            }
#else
            while (blocks--) {
 80125d8:	e029      	b.n	801262e <wc_AesCbcDecrypt+0xa0>
                XMEMCPY(aes->tmp, in, WC_AES_BLOCK_SIZE);
 80125da:	68fb      	ldr	r3, [r7, #12]
 80125dc:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 80125e0:	2210      	movs	r2, #16
 80125e2:	6879      	ldr	r1, [r7, #4]
 80125e4:	4618      	mov	r0, r3
 80125e6:	f015 ffdd 	bl	80285a4 <memcpy>
                ret = wc_AesDecrypt(aes, in, out);
 80125ea:	68ba      	ldr	r2, [r7, #8]
 80125ec:	6879      	ldr	r1, [r7, #4]
 80125ee:	68f8      	ldr	r0, [r7, #12]
 80125f0:	f7ff fb50 	bl	8011c94 <wc_AesDecrypt>
 80125f4:	6138      	str	r0, [r7, #16]
                if (ret != 0)
 80125f6:	693b      	ldr	r3, [r7, #16]
 80125f8:	2b00      	cmp	r3, #0
 80125fa:	d001      	beq.n	8012600 <wc_AesCbcDecrypt+0x72>
                    return ret;
 80125fc:	693b      	ldr	r3, [r7, #16]
 80125fe:	e01c      	b.n	801263a <wc_AesCbcDecrypt+0xac>
                xorbuf(out, (byte*)aes->reg, WC_AES_BLOCK_SIZE);
 8012600:	68fb      	ldr	r3, [r7, #12]
 8012602:	33f8      	adds	r3, #248	@ 0xf8
 8012604:	2210      	movs	r2, #16
 8012606:	4619      	mov	r1, r3
 8012608:	68b8      	ldr	r0, [r7, #8]
 801260a:	f7fd f856 	bl	800f6ba <xorbuf>
                /* store iv for next call */
                XMEMCPY(aes->reg, aes->tmp, WC_AES_BLOCK_SIZE);
 801260e:	68fb      	ldr	r3, [r7, #12]
 8012610:	f103 00f8 	add.w	r0, r3, #248	@ 0xf8
 8012614:	68fb      	ldr	r3, [r7, #12]
 8012616:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 801261a:	2210      	movs	r2, #16
 801261c:	4619      	mov	r1, r3
 801261e:	f015 ffc1 	bl	80285a4 <memcpy>

                out += WC_AES_BLOCK_SIZE;
 8012622:	68bb      	ldr	r3, [r7, #8]
 8012624:	3310      	adds	r3, #16
 8012626:	60bb      	str	r3, [r7, #8]
                in  += WC_AES_BLOCK_SIZE;
 8012628:	687b      	ldr	r3, [r7, #4]
 801262a:	3310      	adds	r3, #16
 801262c:	607b      	str	r3, [r7, #4]
            while (blocks--) {
 801262e:	697b      	ldr	r3, [r7, #20]
 8012630:	1e5a      	subs	r2, r3, #1
 8012632:	617a      	str	r2, [r7, #20]
 8012634:	2b00      	cmp	r3, #0
 8012636:	d1d0      	bne.n	80125da <wc_AesCbcDecrypt+0x4c>
#endif
        }

        VECTOR_REGISTERS_POP;

        return ret;
 8012638:	693b      	ldr	r3, [r7, #16]
    }
 801263a:	4618      	mov	r0, r3
 801263c:	3718      	adds	r7, #24
 801263e:	46bd      	mov	sp, r7
 8012640:	bd80      	pop	{r7, pc}

08012642 <wc_AesInit>:
}
#endif /* !WC_NO_CONSTRUCTORS */

/* Initialize Aes */
int wc_AesInit(Aes* aes, void* heap, int devId)
{
 8012642:	b580      	push	{r7, lr}
 8012644:	b086      	sub	sp, #24
 8012646:	af00      	add	r7, sp, #0
 8012648:	60f8      	str	r0, [r7, #12]
 801264a:	60b9      	str	r1, [r7, #8]
 801264c:	607a      	str	r2, [r7, #4]
    int ret = 0;
 801264e:	2300      	movs	r3, #0
 8012650:	617b      	str	r3, [r7, #20]

    if (aes == NULL)
 8012652:	68fb      	ldr	r3, [r7, #12]
 8012654:	2b00      	cmp	r3, #0
 8012656:	d102      	bne.n	801265e <wc_AesInit+0x1c>
        return BAD_FUNC_ARG;
 8012658:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801265c:	e00a      	b.n	8012674 <wc_AesInit+0x32>

    XMEMSET(aes, 0, sizeof(*aes));
 801265e:	f44f 72a6 	mov.w	r2, #332	@ 0x14c
 8012662:	2100      	movs	r1, #0
 8012664:	68f8      	ldr	r0, [r7, #12]
 8012666:	f015 ff33 	bl	80284d0 <memset>

    aes->heap = heap;
 801266a:	68fb      	ldr	r3, [r7, #12]
 801266c:	68ba      	ldr	r2, [r7, #8]
 801266e:	f8c3 2148 	str.w	r2, [r3, #328]	@ 0x148
#ifdef WC_DEBUG_CIPHER_LIFECYCLE
    if (ret == 0)
        ret = wc_debug_CipherLifecycleInit(&aes->CipherLifecycleTag, aes->heap);
#endif

    return ret;
 8012672:	697b      	ldr	r3, [r7, #20]
}
 8012674:	4618      	mov	r0, r3
 8012676:	3718      	adds	r7, #24
 8012678:	46bd      	mov	sp, r7
 801267a:	bd80      	pop	{r7, pc}

0801267c <wc_AesFree>:
}
#endif

/* Free Aes resources */
void wc_AesFree(Aes* aes)
{
 801267c:	b580      	push	{r7, lr}
 801267e:	b082      	sub	sp, #8
 8012680:	af00      	add	r7, sp, #0
 8012682:	6078      	str	r0, [r7, #4]
    if (aes == NULL) {
 8012684:	687b      	ldr	r3, [r7, #4]
 8012686:	2b00      	cmp	r3, #0
 8012688:	d005      	beq.n	8012696 <wc_AesFree+0x1a>
    defined(WOLFSSL_RENESAS_FSPSM_CRYPTONLY)) && \
    !defined(NO_WOLFSSL_RENESAS_FSPSM_AES))
    wc_fspsm_Aesfree(aes);
#endif

    ForceZero(aes, sizeof(Aes));
 801268a:	f44f 71a6 	mov.w	r1, #332	@ 0x14c
 801268e:	6878      	ldr	r0, [r7, #4]
 8012690:	f7fd f86d 	bl	800f76e <ForceZero>
 8012694:	e000      	b.n	8012698 <wc_AesFree+0x1c>
        return;
 8012696:	bf00      	nop

#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(aes, sizeof(Aes));
#endif
}
 8012698:	3708      	adds	r7, #8
 801269a:	46bd      	mov	sp, r7
 801269c:	bd80      	pop	{r7, pc}

0801269e <ForceZero>:
{
 801269e:	b480      	push	{r7}
 80126a0:	b085      	sub	sp, #20
 80126a2:	af00      	add	r7, sp, #0
 80126a4:	6078      	str	r0, [r7, #4]
 80126a6:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 80126a8:	687b      	ldr	r3, [r7, #4]
 80126aa:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 80126ac:	e004      	b.n	80126b8 <ForceZero+0x1a>
 80126ae:	68fb      	ldr	r3, [r7, #12]
 80126b0:	1c5a      	adds	r2, r3, #1
 80126b2:	60fa      	str	r2, [r7, #12]
 80126b4:	2200      	movs	r2, #0
 80126b6:	701a      	strb	r2, [r3, #0]
 80126b8:	683b      	ldr	r3, [r7, #0]
 80126ba:	1e5a      	subs	r2, r3, #1
 80126bc:	603a      	str	r2, [r7, #0]
 80126be:	2b00      	cmp	r3, #0
 80126c0:	d1f5      	bne.n	80126ae <ForceZero+0x10>
}
 80126c2:	bf00      	nop
 80126c4:	bf00      	nop
 80126c6:	3714      	adds	r7, #20
 80126c8:	46bd      	mov	sp, r7
 80126ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126ce:	4770      	bx	lr

080126d0 <min>:
    {
 80126d0:	b480      	push	{r7}
 80126d2:	b083      	sub	sp, #12
 80126d4:	af00      	add	r7, sp, #0
 80126d6:	6078      	str	r0, [r7, #4]
 80126d8:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 80126da:	687a      	ldr	r2, [r7, #4]
 80126dc:	683b      	ldr	r3, [r7, #0]
 80126de:	4293      	cmp	r3, r2
 80126e0:	bf28      	it	cs
 80126e2:	4613      	movcs	r3, r2
    }
 80126e4:	4618      	mov	r0, r3
 80126e6:	370c      	adds	r7, #12
 80126e8:	46bd      	mov	sp, r7
 80126ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126ee:	4770      	bx	lr

080126f0 <CopyString>:
}
#endif /* WOLFCRYPT_ONLY && !NO_HASH_WRAPPER &&
        * (!NO_SESSION_CACHE || HAVE_SESSION_TICKET) */

WC_MISC_STATIC WC_INLINE char* CopyString(const char* src, int srcLen,
        void* heap, int type) {
 80126f0:	b580      	push	{r7, lr}
 80126f2:	b086      	sub	sp, #24
 80126f4:	af00      	add	r7, sp, #0
 80126f6:	60f8      	str	r0, [r7, #12]
 80126f8:	60b9      	str	r1, [r7, #8]
 80126fa:	607a      	str	r2, [r7, #4]
 80126fc:	603b      	str	r3, [r7, #0]
    char* dst = NULL;
 80126fe:	2300      	movs	r3, #0
 8012700:	617b      	str	r3, [r7, #20]

    if (src == NULL)
 8012702:	68fb      	ldr	r3, [r7, #12]
 8012704:	2b00      	cmp	r3, #0
 8012706:	d101      	bne.n	801270c <CopyString+0x1c>
        return NULL;
 8012708:	2300      	movs	r3, #0
 801270a:	e01c      	b.n	8012746 <CopyString+0x56>

    if (srcLen <= 0)
 801270c:	68bb      	ldr	r3, [r7, #8]
 801270e:	2b00      	cmp	r3, #0
 8012710:	dc04      	bgt.n	801271c <CopyString+0x2c>
        srcLen = (int)XSTRLEN(src);
 8012712:	68f8      	ldr	r0, [r7, #12]
 8012714:	f7ed fd66 	bl	80001e4 <strlen>
 8012718:	4603      	mov	r3, r0
 801271a:	60bb      	str	r3, [r7, #8]

    dst = (char*)XMALLOC((size_t)srcLen + 1, heap, type);
 801271c:	68bb      	ldr	r3, [r7, #8]
 801271e:	3301      	adds	r3, #1
 8012720:	4618      	mov	r0, r3
 8012722:	f00c f9b7 	bl	801ea94 <wolfSSL_Malloc>
 8012726:	6178      	str	r0, [r7, #20]
    if (dst != NULL) {
 8012728:	697b      	ldr	r3, [r7, #20]
 801272a:	2b00      	cmp	r3, #0
 801272c:	d00a      	beq.n	8012744 <CopyString+0x54>
        XMEMCPY(dst, src, (size_t)srcLen);
 801272e:	68bb      	ldr	r3, [r7, #8]
 8012730:	461a      	mov	r2, r3
 8012732:	68f9      	ldr	r1, [r7, #12]
 8012734:	6978      	ldr	r0, [r7, #20]
 8012736:	f015 ff35 	bl	80285a4 <memcpy>
        dst[srcLen] = '\0';
 801273a:	68bb      	ldr	r3, [r7, #8]
 801273c:	697a      	ldr	r2, [r7, #20]
 801273e:	4413      	add	r3, r2
 8012740:	2200      	movs	r2, #0
 8012742:	701a      	strb	r2, [r3, #0]
    }

    return dst;
 8012744:	697b      	ldr	r3, [r7, #20]
}
 8012746:	4618      	mov	r0, r3
 8012748:	3718      	adds	r7, #24
 801274a:	46bd      	mov	sp, r7
 801274c:	bd80      	pop	{r7, pc}

0801274e <BytePrecision>:
 *
 * @param [in] value  Value to be encoded.
 * @return  Number of bytes to encode value.
 */
static word32 BytePrecision(word32 value)
{
 801274e:	b480      	push	{r7}
 8012750:	b085      	sub	sp, #20
 8012752:	af00      	add	r7, sp, #0
 8012754:	6078      	str	r0, [r7, #4]
    word32 i;
    for (i = (word32)sizeof(value); i; --i)
 8012756:	2304      	movs	r3, #4
 8012758:	60fb      	str	r3, [r7, #12]
 801275a:	e00a      	b.n	8012772 <BytePrecision+0x24>
        if (value >> ((i - 1) * WOLFSSL_BIT_SIZE))
 801275c:	68fb      	ldr	r3, [r7, #12]
 801275e:	3b01      	subs	r3, #1
 8012760:	00db      	lsls	r3, r3, #3
 8012762:	687a      	ldr	r2, [r7, #4]
 8012764:	fa22 f303 	lsr.w	r3, r2, r3
 8012768:	2b00      	cmp	r3, #0
 801276a:	d106      	bne.n	801277a <BytePrecision+0x2c>
    for (i = (word32)sizeof(value); i; --i)
 801276c:	68fb      	ldr	r3, [r7, #12]
 801276e:	3b01      	subs	r3, #1
 8012770:	60fb      	str	r3, [r7, #12]
 8012772:	68fb      	ldr	r3, [r7, #12]
 8012774:	2b00      	cmp	r3, #0
 8012776:	d1f1      	bne.n	801275c <BytePrecision+0xe>
 8012778:	e000      	b.n	801277c <BytePrecision+0x2e>
            break;
 801277a:	bf00      	nop

    return i;
 801277c:	68fb      	ldr	r3, [r7, #12]
}
 801277e:	4618      	mov	r0, r3
 8012780:	3714      	adds	r7, #20
 8012782:	46bd      	mov	sp, r7
 8012784:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012788:	4770      	bx	lr

0801278a <SetASNLength>:
 * @param [in]      length  Value to encode.
 * @param [in, out] output  Buffer to encode into.
 * @return  Number of bytes used in encoding.
 */
WOLFSSL_LOCAL word32 SetASNLength(word32 length, byte* output)
{
 801278a:	b580      	push	{r7, lr}
 801278c:	b084      	sub	sp, #16
 801278e:	af00      	add	r7, sp, #0
 8012790:	6078      	str	r0, [r7, #4]
 8012792:	6039      	str	r1, [r7, #0]
    word32 i = 0;
 8012794:	2300      	movs	r3, #0
 8012796:	60fb      	str	r3, [r7, #12]

    if (length < ASN_LONG_LENGTH)
 8012798:	687b      	ldr	r3, [r7, #4]
 801279a:	2b7f      	cmp	r3, #127	@ 0x7f
 801279c:	d808      	bhi.n	80127b0 <SetASNLength+0x26>
        output[i++] = (byte)length;
 801279e:	68fb      	ldr	r3, [r7, #12]
 80127a0:	1c5a      	adds	r2, r3, #1
 80127a2:	60fa      	str	r2, [r7, #12]
 80127a4:	683a      	ldr	r2, [r7, #0]
 80127a6:	4413      	add	r3, r2
 80127a8:	687a      	ldr	r2, [r7, #4]
 80127aa:	b2d2      	uxtb	r2, r2
 80127ac:	701a      	strb	r2, [r3, #0]
 80127ae:	e026      	b.n	80127fe <SetASNLength+0x74>
    else {
        word32 j;

        output[i++] = (byte)(BytePrecision(length) | ASN_LONG_LENGTH);
 80127b0:	6878      	ldr	r0, [r7, #4]
 80127b2:	f7ff ffcc 	bl	801274e <BytePrecision>
 80127b6:	4603      	mov	r3, r0
 80127b8:	b2da      	uxtb	r2, r3
 80127ba:	68fb      	ldr	r3, [r7, #12]
 80127bc:	1c59      	adds	r1, r3, #1
 80127be:	60f9      	str	r1, [r7, #12]
 80127c0:	6839      	ldr	r1, [r7, #0]
 80127c2:	440b      	add	r3, r1
 80127c4:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 80127c8:	b2d2      	uxtb	r2, r2
 80127ca:	701a      	strb	r2, [r3, #0]

        for (j = BytePrecision(length); j; --j) {
 80127cc:	6878      	ldr	r0, [r7, #4]
 80127ce:	f7ff ffbe 	bl	801274e <BytePrecision>
 80127d2:	60b8      	str	r0, [r7, #8]
 80127d4:	e010      	b.n	80127f8 <SetASNLength+0x6e>
            output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));
 80127d6:	68bb      	ldr	r3, [r7, #8]
 80127d8:	3b01      	subs	r3, #1
 80127da:	00db      	lsls	r3, r3, #3
 80127dc:	687a      	ldr	r2, [r7, #4]
 80127de:	fa22 f103 	lsr.w	r1, r2, r3
 80127e2:	683a      	ldr	r2, [r7, #0]
 80127e4:	68fb      	ldr	r3, [r7, #12]
 80127e6:	4413      	add	r3, r2
 80127e8:	b2ca      	uxtb	r2, r1
 80127ea:	701a      	strb	r2, [r3, #0]
            i++;
 80127ec:	68fb      	ldr	r3, [r7, #12]
 80127ee:	3301      	adds	r3, #1
 80127f0:	60fb      	str	r3, [r7, #12]
        for (j = BytePrecision(length); j; --j) {
 80127f2:	68bb      	ldr	r3, [r7, #8]
 80127f4:	3b01      	subs	r3, #1
 80127f6:	60bb      	str	r3, [r7, #8]
 80127f8:	68bb      	ldr	r3, [r7, #8]
 80127fa:	2b00      	cmp	r3, #0
 80127fc:	d1eb      	bne.n	80127d6 <SetASNLength+0x4c>
        }
    }

    return i;
 80127fe:	68fb      	ldr	r3, [r7, #12]
}
 8012800:	4618      	mov	r0, r3
 8012802:	3710      	adds	r7, #16
 8012804:	46bd      	mov	sp, r7
 8012806:	bd80      	pop	{r7, pc}

08012808 <SizeASNLength>:
 *
 * @param [in] length  Value to encode.
 * @return  Number of bytes required to encode.
 */
static word32 SizeASNLength(word32 length)
{
 8012808:	b580      	push	{r7, lr}
 801280a:	b082      	sub	sp, #8
 801280c:	af00      	add	r7, sp, #0
 801280e:	6078      	str	r0, [r7, #4]
    return 1 + ((length >= ASN_LONG_LENGTH) ? BytePrecision(length) : 0);
 8012810:	687b      	ldr	r3, [r7, #4]
 8012812:	2b7f      	cmp	r3, #127	@ 0x7f
 8012814:	d905      	bls.n	8012822 <SizeASNLength+0x1a>
 8012816:	6878      	ldr	r0, [r7, #4]
 8012818:	f7ff ff99 	bl	801274e <BytePrecision>
 801281c:	4603      	mov	r3, r0
 801281e:	3301      	adds	r3, #1
 8012820:	e000      	b.n	8012824 <SizeASNLength+0x1c>
 8012822:	2301      	movs	r3, #1
}
 8012824:	4618      	mov	r0, r3
 8012826:	3708      	adds	r7, #8
 8012828:	46bd      	mov	sp, r7
 801282a:	bd80      	pop	{r7, pc}

0801282c <SizeASN_Num>:
 * @param [in] bits  Maximum number of bits to encode.
 * @param [in] tag   BER tag e.g. INTEGER, BIT_STRING, etc.
 * @return  Number of bytes to the ASN.1 item.
 */
static word32 SizeASN_Num(word32 n, int bits, byte tag)
{
 801282c:	b480      	push	{r7}
 801282e:	b087      	sub	sp, #28
 8012830:	af00      	add	r7, sp, #0
 8012832:	60f8      	str	r0, [r7, #12]
 8012834:	60b9      	str	r1, [r7, #8]
 8012836:	4613      	mov	r3, r2
 8012838:	71fb      	strb	r3, [r7, #7]
    int    j;
    word32 len;

    len = 1 + 1 + (word32)bits / 8;
 801283a:	68bb      	ldr	r3, [r7, #8]
 801283c:	08db      	lsrs	r3, r3, #3
 801283e:	3302      	adds	r3, #2
 8012840:	613b      	str	r3, [r7, #16]
    /* Discover actual size by checking for high zeros. */
    for (j = bits - 8; j > 0; j -= 8) {
 8012842:	68bb      	ldr	r3, [r7, #8]
 8012844:	3b08      	subs	r3, #8
 8012846:	617b      	str	r3, [r7, #20]
 8012848:	e00b      	b.n	8012862 <SizeASN_Num+0x36>
        if (n >> j)
 801284a:	68fa      	ldr	r2, [r7, #12]
 801284c:	697b      	ldr	r3, [r7, #20]
 801284e:	fa22 f303 	lsr.w	r3, r2, r3
 8012852:	2b00      	cmp	r3, #0
 8012854:	d109      	bne.n	801286a <SizeASN_Num+0x3e>
            break;
        len--;
 8012856:	693b      	ldr	r3, [r7, #16]
 8012858:	3b01      	subs	r3, #1
 801285a:	613b      	str	r3, [r7, #16]
    for (j = bits - 8; j > 0; j -= 8) {
 801285c:	697b      	ldr	r3, [r7, #20]
 801285e:	3b08      	subs	r3, #8
 8012860:	617b      	str	r3, [r7, #20]
 8012862:	697b      	ldr	r3, [r7, #20]
 8012864:	2b00      	cmp	r3, #0
 8012866:	dcf0      	bgt.n	801284a <SizeASN_Num+0x1e>
 8012868:	e000      	b.n	801286c <SizeASN_Num+0x40>
            break;
 801286a:	bf00      	nop
    }
    if (tag == ASN_BIT_STRING)
 801286c:	79fb      	ldrb	r3, [r7, #7]
 801286e:	2b03      	cmp	r3, #3
 8012870:	d103      	bne.n	801287a <SizeASN_Num+0x4e>
        len++;
 8012872:	693b      	ldr	r3, [r7, #16]
 8012874:	3301      	adds	r3, #1
 8012876:	613b      	str	r3, [r7, #16]
 8012878:	e00d      	b.n	8012896 <SizeASN_Num+0x6a>
    else if ((tag == ASN_INTEGER) && (((n >> j) & 0x80) == 0x80))
 801287a:	79fb      	ldrb	r3, [r7, #7]
 801287c:	2b02      	cmp	r3, #2
 801287e:	d10a      	bne.n	8012896 <SizeASN_Num+0x6a>
 8012880:	68fa      	ldr	r2, [r7, #12]
 8012882:	697b      	ldr	r3, [r7, #20]
 8012884:	fa22 f303 	lsr.w	r3, r2, r3
 8012888:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 801288c:	2b00      	cmp	r3, #0
 801288e:	d002      	beq.n	8012896 <SizeASN_Num+0x6a>
        len++;
 8012890:	693b      	ldr	r3, [r7, #16]
 8012892:	3301      	adds	r3, #1
 8012894:	613b      	str	r3, [r7, #16]

    return len;
 8012896:	693b      	ldr	r3, [r7, #16]
}
 8012898:	4618      	mov	r0, r3
 801289a:	371c      	adds	r7, #28
 801289c:	46bd      	mov	sp, r7
 801289e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128a2:	4770      	bx	lr

080128a4 <SizeASN_CalcDataLength>:
 *                         known.
 * @param [in]      idx    Index of item working on.
 */
static void SizeASN_CalcDataLength(const ASNItem* asn, ASNSetData *data,
                                   int idx, int maxIdx)
{
 80128a4:	b480      	push	{r7}
 80128a6:	b087      	sub	sp, #28
 80128a8:	af00      	add	r7, sp, #0
 80128aa:	60f8      	str	r0, [r7, #12]
 80128ac:	60b9      	str	r1, [r7, #8]
 80128ae:	607a      	str	r2, [r7, #4]
 80128b0:	603b      	str	r3, [r7, #0]
    int j;

    data[idx].data.buffer.length = 0;
 80128b2:	687a      	ldr	r2, [r7, #4]
 80128b4:	4613      	mov	r3, r2
 80128b6:	009b      	lsls	r3, r3, #2
 80128b8:	4413      	add	r3, r2
 80128ba:	009b      	lsls	r3, r3, #2
 80128bc:	461a      	mov	r2, r3
 80128be:	68bb      	ldr	r3, [r7, #8]
 80128c0:	4413      	add	r3, r2
 80128c2:	2200      	movs	r2, #0
 80128c4:	60da      	str	r2, [r3, #12]
    /* Sum the item length of all items underneath. */
    for (j = idx + 1; j < maxIdx; j++) {
 80128c6:	687b      	ldr	r3, [r7, #4]
 80128c8:	3301      	adds	r3, #1
 80128ca:	617b      	str	r3, [r7, #20]
 80128cc:	e073      	b.n	80129b6 <SizeASN_CalcDataLength+0x112>
        /* Stop looking if the next ASN.1 is same level or higher. */
        if (asn[j].depth <= asn[idx].depth)
 80128ce:	697b      	ldr	r3, [r7, #20]
 80128d0:	009b      	lsls	r3, r3, #2
 80128d2:	68fa      	ldr	r2, [r7, #12]
 80128d4:	4413      	add	r3, r2
 80128d6:	781a      	ldrb	r2, [r3, #0]
 80128d8:	687b      	ldr	r3, [r7, #4]
 80128da:	009b      	lsls	r3, r3, #2
 80128dc:	68f9      	ldr	r1, [r7, #12]
 80128de:	440b      	add	r3, r1
 80128e0:	781b      	ldrb	r3, [r3, #0]
 80128e2:	429a      	cmp	r2, r3
 80128e4:	d96c      	bls.n	80129c0 <SizeASN_CalcDataLength+0x11c>
            break;
        /* Only add in length if it is one level below. */
        if (asn[j].depth - 1 == asn[idx].depth) {
 80128e6:	697b      	ldr	r3, [r7, #20]
 80128e8:	009b      	lsls	r3, r3, #2
 80128ea:	68fa      	ldr	r2, [r7, #12]
 80128ec:	4413      	add	r3, r2
 80128ee:	781b      	ldrb	r3, [r3, #0]
 80128f0:	3b01      	subs	r3, #1
 80128f2:	687a      	ldr	r2, [r7, #4]
 80128f4:	0092      	lsls	r2, r2, #2
 80128f6:	68f9      	ldr	r1, [r7, #12]
 80128f8:	440a      	add	r2, r1
 80128fa:	7812      	ldrb	r2, [r2, #0]
 80128fc:	4293      	cmp	r3, r2
 80128fe:	d157      	bne.n	80129b0 <SizeASN_CalcDataLength+0x10c>
            data[idx].data.buffer.length += data[j].length;
 8012900:	687a      	ldr	r2, [r7, #4]
 8012902:	4613      	mov	r3, r2
 8012904:	009b      	lsls	r3, r3, #2
 8012906:	4413      	add	r3, r2
 8012908:	009b      	lsls	r3, r3, #2
 801290a:	461a      	mov	r2, r3
 801290c:	68bb      	ldr	r3, [r7, #8]
 801290e:	4413      	add	r3, r2
 8012910:	68d8      	ldr	r0, [r3, #12]
 8012912:	697a      	ldr	r2, [r7, #20]
 8012914:	4613      	mov	r3, r2
 8012916:	009b      	lsls	r3, r3, #2
 8012918:	4413      	add	r3, r2
 801291a:	009b      	lsls	r3, r3, #2
 801291c:	461a      	mov	r2, r3
 801291e:	68bb      	ldr	r3, [r7, #8]
 8012920:	4413      	add	r3, r2
 8012922:	6859      	ldr	r1, [r3, #4]
 8012924:	687a      	ldr	r2, [r7, #4]
 8012926:	4613      	mov	r3, r2
 8012928:	009b      	lsls	r3, r3, #2
 801292a:	4413      	add	r3, r2
 801292c:	009b      	lsls	r3, r3, #2
 801292e:	461a      	mov	r2, r3
 8012930:	68bb      	ldr	r3, [r7, #8]
 8012932:	4413      	add	r3, r2
 8012934:	1842      	adds	r2, r0, r1
 8012936:	60da      	str	r2, [r3, #12]
            /* The length of a header only item doesn't include the data unless
             * a replacement buffer is supplied.
             */
            if (asn[j].headerOnly && data[j].data.buffer.data == NULL &&
 8012938:	697b      	ldr	r3, [r7, #20]
 801293a:	009b      	lsls	r3, r3, #2
 801293c:	68fa      	ldr	r2, [r7, #12]
 801293e:	4413      	add	r3, r2
 8012940:	789b      	ldrb	r3, [r3, #2]
 8012942:	f003 0302 	and.w	r3, r3, #2
 8012946:	b2db      	uxtb	r3, r3
 8012948:	2b00      	cmp	r3, #0
 801294a:	d031      	beq.n	80129b0 <SizeASN_CalcDataLength+0x10c>
 801294c:	697a      	ldr	r2, [r7, #20]
 801294e:	4613      	mov	r3, r2
 8012950:	009b      	lsls	r3, r3, #2
 8012952:	4413      	add	r3, r2
 8012954:	009b      	lsls	r3, r3, #2
 8012956:	461a      	mov	r2, r3
 8012958:	68bb      	ldr	r3, [r7, #8]
 801295a:	4413      	add	r3, r2
 801295c:	689b      	ldr	r3, [r3, #8]
 801295e:	2b00      	cmp	r3, #0
 8012960:	d126      	bne.n	80129b0 <SizeASN_CalcDataLength+0x10c>
                    data[j].dataType != ASN_DATA_TYPE_REPLACE_BUFFER) {
 8012962:	697a      	ldr	r2, [r7, #20]
 8012964:	4613      	mov	r3, r2
 8012966:	009b      	lsls	r3, r3, #2
 8012968:	4413      	add	r3, r2
 801296a:	009b      	lsls	r3, r3, #2
 801296c:	461a      	mov	r2, r3
 801296e:	68bb      	ldr	r3, [r7, #8]
 8012970:	4413      	add	r3, r2
 8012972:	7c1b      	ldrb	r3, [r3, #16]
            if (asn[j].headerOnly && data[j].data.buffer.data == NULL &&
 8012974:	2b07      	cmp	r3, #7
 8012976:	d01b      	beq.n	80129b0 <SizeASN_CalcDataLength+0x10c>
                data[idx].data.buffer.length += data[j].data.buffer.length;
 8012978:	687a      	ldr	r2, [r7, #4]
 801297a:	4613      	mov	r3, r2
 801297c:	009b      	lsls	r3, r3, #2
 801297e:	4413      	add	r3, r2
 8012980:	009b      	lsls	r3, r3, #2
 8012982:	461a      	mov	r2, r3
 8012984:	68bb      	ldr	r3, [r7, #8]
 8012986:	4413      	add	r3, r2
 8012988:	68d8      	ldr	r0, [r3, #12]
 801298a:	697a      	ldr	r2, [r7, #20]
 801298c:	4613      	mov	r3, r2
 801298e:	009b      	lsls	r3, r3, #2
 8012990:	4413      	add	r3, r2
 8012992:	009b      	lsls	r3, r3, #2
 8012994:	461a      	mov	r2, r3
 8012996:	68bb      	ldr	r3, [r7, #8]
 8012998:	4413      	add	r3, r2
 801299a:	68d9      	ldr	r1, [r3, #12]
 801299c:	687a      	ldr	r2, [r7, #4]
 801299e:	4613      	mov	r3, r2
 80129a0:	009b      	lsls	r3, r3, #2
 80129a2:	4413      	add	r3, r2
 80129a4:	009b      	lsls	r3, r3, #2
 80129a6:	461a      	mov	r2, r3
 80129a8:	68bb      	ldr	r3, [r7, #8]
 80129aa:	4413      	add	r3, r2
 80129ac:	1842      	adds	r2, r0, r1
 80129ae:	60da      	str	r2, [r3, #12]
    for (j = idx + 1; j < maxIdx; j++) {
 80129b0:	697b      	ldr	r3, [r7, #20]
 80129b2:	3301      	adds	r3, #1
 80129b4:	617b      	str	r3, [r7, #20]
 80129b6:	697a      	ldr	r2, [r7, #20]
 80129b8:	683b      	ldr	r3, [r7, #0]
 80129ba:	429a      	cmp	r2, r3
 80129bc:	db87      	blt.n	80128ce <SizeASN_CalcDataLength+0x2a>
            }
        }
    }
}
 80129be:	e000      	b.n	80129c2 <SizeASN_CalcDataLength+0x11e>
            break;
 80129c0:	bf00      	nop
}
 80129c2:	bf00      	nop
 80129c4:	371c      	adds	r7, #28
 80129c6:	46bd      	mov	sp, r7
 80129c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80129cc:	4770      	bx	lr
	...

080129d0 <SizeASN_Items>:
 * @param [out]     encSz  Length of the DER encoding.
 * @return  0 on success.
 * @return  BAD_STATE_E when the data type is not supported.
 */
int SizeASN_Items(const ASNItem* asn, ASNSetData *data, int count, int* encSz)
{
 80129d0:	b580      	push	{r7, lr}
 80129d2:	b08a      	sub	sp, #40	@ 0x28
 80129d4:	af00      	add	r7, sp, #0
 80129d6:	60f8      	str	r0, [r7, #12]
 80129d8:	60b9      	str	r1, [r7, #8]
 80129da:	607a      	str	r2, [r7, #4]
 80129dc:	603b      	str	r3, [r7, #0]
    int    i;
    word32 sz = 0;
 80129de:	2300      	movs	r3, #0
 80129e0:	623b      	str	r3, [r7, #32]

#ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
    WOLFSSL_ENTER("SizeASN_Items");
#endif

    for (i = count - 1; i >= 0; i--) {
 80129e2:	687b      	ldr	r3, [r7, #4]
 80129e4:	3b01      	subs	r3, #1
 80129e6:	627b      	str	r3, [r7, #36]	@ 0x24
 80129e8:	e16c      	b.n	8012cc4 <SizeASN_Items+0x2f4>
        /* Skip this ASN.1 item when encoding. */
        if (data[i].noOut) {
 80129ea:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80129ec:	4613      	mov	r3, r2
 80129ee:	009b      	lsls	r3, r3, #2
 80129f0:	4413      	add	r3, r2
 80129f2:	009b      	lsls	r3, r3, #2
 80129f4:	461a      	mov	r2, r3
 80129f6:	68bb      	ldr	r3, [r7, #8]
 80129f8:	4413      	add	r3, r2
 80129fa:	7c5b      	ldrb	r3, [r3, #17]
 80129fc:	2b00      	cmp	r3, #0
 80129fe:	d00a      	beq.n	8012a16 <SizeASN_Items+0x46>
            /* Set the offset to the current size - used in writing DER. */
            data[i].offset = sz;
 8012a00:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012a02:	4613      	mov	r3, r2
 8012a04:	009b      	lsls	r3, r3, #2
 8012a06:	4413      	add	r3, r2
 8012a08:	009b      	lsls	r3, r3, #2
 8012a0a:	461a      	mov	r2, r3
 8012a0c:	68bb      	ldr	r3, [r7, #8]
 8012a0e:	4413      	add	r3, r2
 8012a10:	6a3a      	ldr	r2, [r7, #32]
 8012a12:	601a      	str	r2, [r3, #0]
            continue;
 8012a14:	e153      	b.n	8012cbe <SizeASN_Items+0x2ee>
        }

        len = 0;
 8012a16:	2300      	movs	r3, #0
 8012a18:	61fb      	str	r3, [r7, #28]
        switch (data[i].dataType) {
 8012a1a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012a1c:	4613      	mov	r3, r2
 8012a1e:	009b      	lsls	r3, r3, #2
 8012a20:	4413      	add	r3, r2
 8012a22:	009b      	lsls	r3, r3, #2
 8012a24:	461a      	mov	r2, r3
 8012a26:	68bb      	ldr	r3, [r7, #8]
 8012a28:	4413      	add	r3, r2
 8012a2a:	7c1b      	ldrb	r3, [r3, #16]
 8012a2c:	2b08      	cmp	r3, #8
 8012a2e:	f200 812e 	bhi.w	8012c8e <SizeASN_Items+0x2be>
 8012a32:	a201      	add	r2, pc, #4	@ (adr r2, 8012a38 <SizeASN_Items+0x68>)
 8012a34:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012a38:	08012b21 	.word	0x08012b21
 8012a3c:	08012a5d 	.word	0x08012a5d
 8012a40:	08012a87 	.word	0x08012a87
 8012a44:	08012c8f 	.word	0x08012c8f
 8012a48:	08012c8f 	.word	0x08012c8f
 8012a4c:	08012c8f 	.word	0x08012c8f
 8012a50:	08012c8f 	.word	0x08012c8f
 8012a54:	08012b0b 	.word	0x08012b0b
 8012a58:	08012ab1 	.word	0x08012ab1
            /* Calculate the size of the number of different sizes. */
            case ASN_DATA_TYPE_WORD8:
                len = SizeASN_Num(data[i].data.u8, 8, asn[i].tag);
 8012a5c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012a5e:	4613      	mov	r3, r2
 8012a60:	009b      	lsls	r3, r3, #2
 8012a62:	4413      	add	r3, r2
 8012a64:	009b      	lsls	r3, r3, #2
 8012a66:	461a      	mov	r2, r3
 8012a68:	68bb      	ldr	r3, [r7, #8]
 8012a6a:	4413      	add	r3, r2
 8012a6c:	7a1b      	ldrb	r3, [r3, #8]
 8012a6e:	4618      	mov	r0, r3
 8012a70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012a72:	009b      	lsls	r3, r3, #2
 8012a74:	68fa      	ldr	r2, [r7, #12]
 8012a76:	4413      	add	r3, r2
 8012a78:	785b      	ldrb	r3, [r3, #1]
 8012a7a:	461a      	mov	r2, r3
 8012a7c:	2108      	movs	r1, #8
 8012a7e:	f7ff fed5 	bl	801282c <SizeASN_Num>
 8012a82:	61f8      	str	r0, [r7, #28]
                break;
 8012a84:	e103      	b.n	8012c8e <SizeASN_Items+0x2be>
            case ASN_DATA_TYPE_WORD16:
                len = SizeASN_Num(data[i].data.u16, 16, asn[i].tag);
 8012a86:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012a88:	4613      	mov	r3, r2
 8012a8a:	009b      	lsls	r3, r3, #2
 8012a8c:	4413      	add	r3, r2
 8012a8e:	009b      	lsls	r3, r3, #2
 8012a90:	461a      	mov	r2, r3
 8012a92:	68bb      	ldr	r3, [r7, #8]
 8012a94:	4413      	add	r3, r2
 8012a96:	891b      	ldrh	r3, [r3, #8]
 8012a98:	4618      	mov	r0, r3
 8012a9a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012a9c:	009b      	lsls	r3, r3, #2
 8012a9e:	68fa      	ldr	r2, [r7, #12]
 8012aa0:	4413      	add	r3, r2
 8012aa2:	785b      	ldrb	r3, [r3, #1]
 8012aa4:	461a      	mov	r2, r3
 8012aa6:	2110      	movs	r1, #16
 8012aa8:	f7ff fec0 	bl	801282c <SizeASN_Num>
 8012aac:	61f8      	str	r0, [r7, #28]
                break;
 8012aae:	e0ee      	b.n	8012c8e <SizeASN_Items+0x2be>
                break;
        #endif

            case ASN_DATA_TYPE_MP:
                /* Calculate the size of the MP integer data. */
                length = mp_unsigned_bin_size(data[i].data.mp);
 8012ab0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012ab2:	4613      	mov	r3, r2
 8012ab4:	009b      	lsls	r3, r3, #2
 8012ab6:	4413      	add	r3, r2
 8012ab8:	009b      	lsls	r3, r3, #2
 8012aba:	461a      	mov	r2, r3
 8012abc:	68bb      	ldr	r3, [r7, #8]
 8012abe:	4413      	add	r3, r2
 8012ac0:	689b      	ldr	r3, [r3, #8]
 8012ac2:	4618      	mov	r0, r3
 8012ac4:	f013 ff9a 	bl	80269fc <mp_unsigned_bin_size>
 8012ac8:	6138      	str	r0, [r7, #16]
                length += mp_leading_bit(data[i].data.mp) ? 1 : 0;
 8012aca:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012acc:	4613      	mov	r3, r2
 8012ace:	009b      	lsls	r3, r3, #2
 8012ad0:	4413      	add	r3, r2
 8012ad2:	009b      	lsls	r3, r3, #2
 8012ad4:	461a      	mov	r2, r3
 8012ad6:	68bb      	ldr	r3, [r7, #8]
 8012ad8:	4413      	add	r3, r2
 8012ada:	689b      	ldr	r3, [r3, #8]
 8012adc:	4618      	mov	r0, r3
 8012ade:	f014 f855 	bl	8026b8c <mp_leading_bit>
 8012ae2:	4603      	mov	r3, r0
 8012ae4:	2b00      	cmp	r3, #0
 8012ae6:	bf14      	ite	ne
 8012ae8:	2301      	movne	r3, #1
 8012aea:	2300      	moveq	r3, #0
 8012aec:	b2db      	uxtb	r3, r3
 8012aee:	461a      	mov	r2, r3
 8012af0:	693b      	ldr	r3, [r7, #16]
 8012af2:	4413      	add	r3, r2
 8012af4:	613b      	str	r3, [r7, #16]
                len = (word32)SizeASNHeader((word32)length) + (word32)length;
 8012af6:	693b      	ldr	r3, [r7, #16]
 8012af8:	4618      	mov	r0, r3
 8012afa:	f7ff fe85 	bl	8012808 <SizeASNLength>
 8012afe:	4602      	mov	r2, r0
 8012b00:	693b      	ldr	r3, [r7, #16]
 8012b02:	4413      	add	r3, r2
 8012b04:	3301      	adds	r3, #1
 8012b06:	61fb      	str	r3, [r7, #28]
                break;
 8012b08:	e0c1      	b.n	8012c8e <SizeASN_Items+0x2be>

            case ASN_DATA_TYPE_REPLACE_BUFFER:
                /* Buffer is put in directly - use the length. */
                len = data[i].data.buffer.length;
 8012b0a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012b0c:	4613      	mov	r3, r2
 8012b0e:	009b      	lsls	r3, r3, #2
 8012b10:	4413      	add	r3, r2
 8012b12:	009b      	lsls	r3, r3, #2
 8012b14:	461a      	mov	r2, r3
 8012b16:	68bb      	ldr	r3, [r7, #8]
 8012b18:	4413      	add	r3, r2
 8012b1a:	68db      	ldr	r3, [r3, #12]
 8012b1c:	61fb      	str	r3, [r7, #28]
                break;
 8012b1e:	e0b6      	b.n	8012c8e <SizeASN_Items+0x2be>

            case ASN_DATA_TYPE_NONE:
                /* Calculate the size based on the data to be included.
                 * Mostly used for constructed items.
                 */
                if (asn[i].headerOnly) {
 8012b20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012b22:	009b      	lsls	r3, r3, #2
 8012b24:	68fa      	ldr	r2, [r7, #12]
 8012b26:	4413      	add	r3, r2
 8012b28:	789b      	ldrb	r3, [r3, #2]
 8012b2a:	f003 0302 	and.w	r3, r3, #2
 8012b2e:	b2db      	uxtb	r3, r3
 8012b30:	2b00      	cmp	r3, #0
 8012b32:	d040      	beq.n	8012bb6 <SizeASN_Items+0x1e6>
                    if (data[i].data.buffer.data != NULL) {
 8012b34:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012b36:	4613      	mov	r3, r2
 8012b38:	009b      	lsls	r3, r3, #2
 8012b3a:	4413      	add	r3, r2
 8012b3c:	009b      	lsls	r3, r3, #2
 8012b3e:	461a      	mov	r2, r3
 8012b40:	68bb      	ldr	r3, [r7, #8]
 8012b42:	4413      	add	r3, r2
 8012b44:	689b      	ldr	r3, [r3, #8]
 8012b46:	2b00      	cmp	r3, #0
 8012b48:	d02d      	beq.n	8012ba6 <SizeASN_Items+0x1d6>
                        /* Force all child nodes to be ignored. Buffer
                         * overwrites children. */
                        {
                            int ii;
                            for (ii = i + 1; ii < count; ii++) {
 8012b4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012b4c:	3301      	adds	r3, #1
 8012b4e:	617b      	str	r3, [r7, #20]
 8012b50:	e024      	b.n	8012b9c <SizeASN_Items+0x1cc>
                                if (asn[ii].depth <= asn[i].depth)
 8012b52:	697b      	ldr	r3, [r7, #20]
 8012b54:	009b      	lsls	r3, r3, #2
 8012b56:	68fa      	ldr	r2, [r7, #12]
 8012b58:	4413      	add	r3, r2
 8012b5a:	781a      	ldrb	r2, [r3, #0]
 8012b5c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012b5e:	009b      	lsls	r3, r3, #2
 8012b60:	68f9      	ldr	r1, [r7, #12]
 8012b62:	440b      	add	r3, r1
 8012b64:	781b      	ldrb	r3, [r3, #0]
 8012b66:	429a      	cmp	r2, r3
 8012b68:	d924      	bls.n	8012bb4 <SizeASN_Items+0x1e4>
                                    break;
                                sz -= data[ii].length;
 8012b6a:	697a      	ldr	r2, [r7, #20]
 8012b6c:	4613      	mov	r3, r2
 8012b6e:	009b      	lsls	r3, r3, #2
 8012b70:	4413      	add	r3, r2
 8012b72:	009b      	lsls	r3, r3, #2
 8012b74:	461a      	mov	r2, r3
 8012b76:	68bb      	ldr	r3, [r7, #8]
 8012b78:	4413      	add	r3, r2
 8012b7a:	685b      	ldr	r3, [r3, #4]
 8012b7c:	6a3a      	ldr	r2, [r7, #32]
 8012b7e:	1ad3      	subs	r3, r2, r3
 8012b80:	623b      	str	r3, [r7, #32]
                                data[ii].noOut = 1;
 8012b82:	697a      	ldr	r2, [r7, #20]
 8012b84:	4613      	mov	r3, r2
 8012b86:	009b      	lsls	r3, r3, #2
 8012b88:	4413      	add	r3, r2
 8012b8a:	009b      	lsls	r3, r3, #2
 8012b8c:	461a      	mov	r2, r3
 8012b8e:	68bb      	ldr	r3, [r7, #8]
 8012b90:	4413      	add	r3, r2
 8012b92:	2201      	movs	r2, #1
 8012b94:	745a      	strb	r2, [r3, #17]
                            for (ii = i + 1; ii < count; ii++) {
 8012b96:	697b      	ldr	r3, [r7, #20]
 8012b98:	3301      	adds	r3, #1
 8012b9a:	617b      	str	r3, [r7, #20]
 8012b9c:	697a      	ldr	r2, [r7, #20]
 8012b9e:	687b      	ldr	r3, [r7, #4]
 8012ba0:	429a      	cmp	r2, r3
 8012ba2:	dbd6      	blt.n	8012b52 <SizeASN_Items+0x182>
 8012ba4:	e007      	b.n	8012bb6 <SizeASN_Items+0x1e6>
                        }
                    }
                    else {
                        /* Calculate data length from items below if no buffer
                         * supplied. */
                        SizeASN_CalcDataLength(asn, data, i, count);
 8012ba6:	687b      	ldr	r3, [r7, #4]
 8012ba8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012baa:	68b9      	ldr	r1, [r7, #8]
 8012bac:	68f8      	ldr	r0, [r7, #12]
 8012bae:	f7ff fe79 	bl	80128a4 <SizeASN_CalcDataLength>
 8012bb2:	e000      	b.n	8012bb6 <SizeASN_Items+0x1e6>
                                    break;
 8012bb4:	bf00      	nop
                    }
                }
                if (asn[i].tag == ASN_BOOLEAN) {
 8012bb6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012bb8:	009b      	lsls	r3, r3, #2
 8012bba:	68fa      	ldr	r2, [r7, #12]
 8012bbc:	4413      	add	r3, r2
 8012bbe:	785b      	ldrb	r3, [r3, #1]
 8012bc0:	2b01      	cmp	r3, #1
 8012bc2:	d102      	bne.n	8012bca <SizeASN_Items+0x1fa>
                    dataLen = 1;
 8012bc4:	2301      	movs	r3, #1
 8012bc6:	61bb      	str	r3, [r7, #24]
 8012bc8:	e009      	b.n	8012bde <SizeASN_Items+0x20e>
                }
                else {
                    dataLen = data[i].data.buffer.length;
 8012bca:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012bcc:	4613      	mov	r3, r2
 8012bce:	009b      	lsls	r3, r3, #2
 8012bd0:	4413      	add	r3, r2
 8012bd2:	009b      	lsls	r3, r3, #2
 8012bd4:	461a      	mov	r2, r3
 8012bd6:	68bb      	ldr	r3, [r7, #8]
 8012bd8:	4413      	add	r3, r2
 8012bda:	68db      	ldr	r3, [r3, #12]
 8012bdc:	61bb      	str	r3, [r7, #24]
                }
                /* BIT_STRING and INTEGER have one byte prepended. */
                if ((asn[i].tag == ASN_BIT_STRING) ||
 8012bde:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012be0:	009b      	lsls	r3, r3, #2
 8012be2:	68fa      	ldr	r2, [r7, #12]
 8012be4:	4413      	add	r3, r2
 8012be6:	785b      	ldrb	r3, [r3, #1]
 8012be8:	2b03      	cmp	r3, #3
 8012bea:	d01e      	beq.n	8012c2a <SizeASN_Items+0x25a>
                                                   ASNIntMSBSet(asn, data, i)) {
 8012bec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012bee:	009b      	lsls	r3, r3, #2
 8012bf0:	68fa      	ldr	r2, [r7, #12]
 8012bf2:	4413      	add	r3, r2
 8012bf4:	785b      	ldrb	r3, [r3, #1]
                if ((asn[i].tag == ASN_BIT_STRING) ||
 8012bf6:	2b02      	cmp	r3, #2
 8012bf8:	d127      	bne.n	8012c4a <SizeASN_Items+0x27a>
                                                   ASNIntMSBSet(asn, data, i)) {
 8012bfa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012bfc:	4613      	mov	r3, r2
 8012bfe:	009b      	lsls	r3, r3, #2
 8012c00:	4413      	add	r3, r2
 8012c02:	009b      	lsls	r3, r3, #2
 8012c04:	461a      	mov	r2, r3
 8012c06:	68bb      	ldr	r3, [r7, #8]
 8012c08:	4413      	add	r3, r2
 8012c0a:	689b      	ldr	r3, [r3, #8]
 8012c0c:	2b00      	cmp	r3, #0
 8012c0e:	d01c      	beq.n	8012c4a <SizeASN_Items+0x27a>
 8012c10:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c12:	4613      	mov	r3, r2
 8012c14:	009b      	lsls	r3, r3, #2
 8012c16:	4413      	add	r3, r2
 8012c18:	009b      	lsls	r3, r3, #2
 8012c1a:	461a      	mov	r2, r3
 8012c1c:	68bb      	ldr	r3, [r7, #8]
 8012c1e:	4413      	add	r3, r2
 8012c20:	689b      	ldr	r3, [r3, #8]
 8012c22:	781b      	ldrb	r3, [r3, #0]
 8012c24:	b25b      	sxtb	r3, r3
 8012c26:	2b00      	cmp	r3, #0
 8012c28:	da0f      	bge.n	8012c4a <SizeASN_Items+0x27a>
                    dataLen++;
 8012c2a:	69bb      	ldr	r3, [r7, #24]
 8012c2c:	3301      	adds	r3, #1
 8012c2e:	61bb      	str	r3, [r7, #24]
                    /* ASN.1 items are below and cannot include extra byte. */
                    if (asn[i].headerOnly) {
 8012c30:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012c32:	009b      	lsls	r3, r3, #2
 8012c34:	68fa      	ldr	r2, [r7, #12]
 8012c36:	4413      	add	r3, r2
 8012c38:	789b      	ldrb	r3, [r3, #2]
 8012c3a:	f003 0302 	and.w	r3, r3, #2
 8012c3e:	b2db      	uxtb	r3, r3
 8012c40:	2b00      	cmp	r3, #0
 8012c42:	d002      	beq.n	8012c4a <SizeASN_Items+0x27a>
                        len++;
 8012c44:	69fb      	ldr	r3, [r7, #28]
 8012c46:	3301      	adds	r3, #1
 8012c48:	61fb      	str	r3, [r7, #28]
                    }
                }
                /* Add in the size of tag and length. */
                len += SizeASNHeader(dataLen);
 8012c4a:	69b8      	ldr	r0, [r7, #24]
 8012c4c:	f7ff fddc 	bl	8012808 <SizeASNLength>
 8012c50:	4603      	mov	r3, r0
 8012c52:	3301      	adds	r3, #1
 8012c54:	69fa      	ldr	r2, [r7, #28]
 8012c56:	4413      	add	r3, r2
 8012c58:	61fb      	str	r3, [r7, #28]
                /* Include data in length if not header only or if
                 * buffer supplied. */
                if (!asn[i].headerOnly || data[i].data.buffer.data != NULL) {
 8012c5a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012c5c:	009b      	lsls	r3, r3, #2
 8012c5e:	68fa      	ldr	r2, [r7, #12]
 8012c60:	4413      	add	r3, r2
 8012c62:	789b      	ldrb	r3, [r3, #2]
 8012c64:	f003 0302 	and.w	r3, r3, #2
 8012c68:	b2db      	uxtb	r3, r3
 8012c6a:	2b00      	cmp	r3, #0
 8012c6c:	d00a      	beq.n	8012c84 <SizeASN_Items+0x2b4>
 8012c6e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c70:	4613      	mov	r3, r2
 8012c72:	009b      	lsls	r3, r3, #2
 8012c74:	4413      	add	r3, r2
 8012c76:	009b      	lsls	r3, r3, #2
 8012c78:	461a      	mov	r2, r3
 8012c7a:	68bb      	ldr	r3, [r7, #8]
 8012c7c:	4413      	add	r3, r2
 8012c7e:	689b      	ldr	r3, [r3, #8]
 8012c80:	2b00      	cmp	r3, #0
 8012c82:	d003      	beq.n	8012c8c <SizeASN_Items+0x2bc>
                    len += dataLen;
 8012c84:	69fa      	ldr	r2, [r7, #28]
 8012c86:	69bb      	ldr	r3, [r7, #24]
 8012c88:	4413      	add	r3, r2
 8012c8a:	61fb      	str	r3, [r7, #28]
                }
                break;
 8012c8c:	bf00      	nop
                return BAD_STATE_E;
        #endif
        }

        /* Set the total length of the item. */
        data[i].length = len;
 8012c8e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012c90:	4613      	mov	r3, r2
 8012c92:	009b      	lsls	r3, r3, #2
 8012c94:	4413      	add	r3, r2
 8012c96:	009b      	lsls	r3, r3, #2
 8012c98:	461a      	mov	r2, r3
 8012c9a:	68bb      	ldr	r3, [r7, #8]
 8012c9c:	4413      	add	r3, r2
 8012c9e:	69fa      	ldr	r2, [r7, #28]
 8012ca0:	605a      	str	r2, [r3, #4]
        /* Add length to total size. */
        sz += len;
 8012ca2:	6a3a      	ldr	r2, [r7, #32]
 8012ca4:	69fb      	ldr	r3, [r7, #28]
 8012ca6:	4413      	add	r3, r2
 8012ca8:	623b      	str	r3, [r7, #32]
        /* Set the offset to the current size - used in writing DER. */
        data[i].offset = sz;
 8012caa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012cac:	4613      	mov	r3, r2
 8012cae:	009b      	lsls	r3, r3, #2
 8012cb0:	4413      	add	r3, r2
 8012cb2:	009b      	lsls	r3, r3, #2
 8012cb4:	461a      	mov	r2, r3
 8012cb6:	68bb      	ldr	r3, [r7, #8]
 8012cb8:	4413      	add	r3, r2
 8012cba:	6a3a      	ldr	r2, [r7, #32]
 8012cbc:	601a      	str	r2, [r3, #0]
    for (i = count - 1; i >= 0; i--) {
 8012cbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012cc0:	3b01      	subs	r3, #1
 8012cc2:	627b      	str	r3, [r7, #36]	@ 0x24
 8012cc4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012cc6:	2b00      	cmp	r3, #0
 8012cc8:	f6bf ae8f 	bge.w	80129ea <SizeASN_Items+0x1a>
                data[i].offset, data[i].length, asn[i].constructed ? '+' : ' ',
                asn[i].depth, "", TagString(asn[i].tag));
    #endif
    }

    *encSz = (int)sz;
 8012ccc:	6a3a      	ldr	r2, [r7, #32]
 8012cce:	683b      	ldr	r3, [r7, #0]
 8012cd0:	601a      	str	r2, [r3, #0]
    return 0;
 8012cd2:	2300      	movs	r3, #0
}
 8012cd4:	4618      	mov	r0, r3
 8012cd6:	3728      	adds	r7, #40	@ 0x28
 8012cd8:	46bd      	mov	sp, r7
 8012cda:	bd80      	pop	{r7, pc}

08012cdc <SetASN_Num>:
 * @param [in] n     Number to be encoded.
 * @param [in] bits  Maximum number of bits to encode.
 * @param [in] tag   DER tag e.g. INTEGER, BIT_STRING, etc.
 */
static void SetASN_Num(word32 n, int bits, byte* out, byte tag)
{
 8012cdc:	b480      	push	{r7}
 8012cde:	b089      	sub	sp, #36	@ 0x24
 8012ce0:	af00      	add	r7, sp, #0
 8012ce2:	60f8      	str	r0, [r7, #12]
 8012ce4:	60b9      	str	r1, [r7, #8]
 8012ce6:	607a      	str	r2, [r7, #4]
 8012ce8:	70fb      	strb	r3, [r7, #3]
    byte   len;

    /* Encoding: Tag (1 byte) | Length (1 byte) | Data (number) */

    /* Data will start at index 2 unless BIT_STRING or INTEGER */
    idx = 2;
 8012cea:	2302      	movs	r3, #2
 8012cec:	61bb      	str	r3, [r7, #24]

    /* Set the length of the number based on maximum bit length. */
    len = (byte)(bits / 8);
 8012cee:	68bb      	ldr	r3, [r7, #8]
 8012cf0:	2b00      	cmp	r3, #0
 8012cf2:	da00      	bge.n	8012cf6 <SetASN_Num+0x1a>
 8012cf4:	3307      	adds	r3, #7
 8012cf6:	10db      	asrs	r3, r3, #3
 8012cf8:	75fb      	strb	r3, [r7, #23]
    /* Discover actual size by checking for leading zero bytes. */
    for (j = bits - 8; j > 0; j -= 8) {
 8012cfa:	68bb      	ldr	r3, [r7, #8]
 8012cfc:	3b08      	subs	r3, #8
 8012cfe:	61fb      	str	r3, [r7, #28]
 8012d00:	e00b      	b.n	8012d1a <SetASN_Num+0x3e>
        if ((n >> j) != 0) {
 8012d02:	68fa      	ldr	r2, [r7, #12]
 8012d04:	69fb      	ldr	r3, [r7, #28]
 8012d06:	fa22 f303 	lsr.w	r3, r2, r3
 8012d0a:	2b00      	cmp	r3, #0
 8012d0c:	d109      	bne.n	8012d22 <SetASN_Num+0x46>
            break;
        }
        len--;
 8012d0e:	7dfb      	ldrb	r3, [r7, #23]
 8012d10:	3b01      	subs	r3, #1
 8012d12:	75fb      	strb	r3, [r7, #23]
    for (j = bits - 8; j > 0; j -= 8) {
 8012d14:	69fb      	ldr	r3, [r7, #28]
 8012d16:	3b08      	subs	r3, #8
 8012d18:	61fb      	str	r3, [r7, #28]
 8012d1a:	69fb      	ldr	r3, [r7, #28]
 8012d1c:	2b00      	cmp	r3, #0
 8012d1e:	dcf0      	bgt.n	8012d02 <SetASN_Num+0x26>
 8012d20:	e000      	b.n	8012d24 <SetASN_Num+0x48>
            break;
 8012d22:	bf00      	nop
    /* Keep j, index of first non-zero byte, for writing out. */

    /* A BIT_STRING has the number of unused bits in last byte prepended to
     * data.
     */
    if (tag == ASN_BIT_STRING) {
 8012d24:	78fb      	ldrb	r3, [r7, #3]
 8012d26:	2b03      	cmp	r3, #3
 8012d28:	d124      	bne.n	8012d74 <SetASN_Num+0x98>
        byte unusedBits = 0;
 8012d2a:	2300      	movs	r3, #0
 8012d2c:	75bb      	strb	r3, [r7, #22]
        byte lastByte = (byte)(n >> j);
 8012d2e:	68fa      	ldr	r2, [r7, #12]
 8012d30:	69fb      	ldr	r3, [r7, #28]
 8012d32:	fa22 f303 	lsr.w	r3, r2, r3
 8012d36:	757b      	strb	r3, [r7, #21]

        /* Quick check last bit. */
        if ((lastByte & 0x01) == 0x00) {
 8012d38:	7d7b      	ldrb	r3, [r7, #21]
 8012d3a:	f003 0301 	and.w	r3, r3, #1
 8012d3e:	2b00      	cmp	r3, #0
 8012d40:	d10e      	bne.n	8012d60 <SetASN_Num+0x84>
            unusedBits++;
 8012d42:	7dbb      	ldrb	r3, [r7, #22]
 8012d44:	3301      	adds	r3, #1
 8012d46:	75bb      	strb	r3, [r7, #22]
            /* Check each bit for first least significant bit set. */
            while (((lastByte >> unusedBits) & 0x01) == 0x00)
 8012d48:	e002      	b.n	8012d50 <SetASN_Num+0x74>
                unusedBits++;
 8012d4a:	7dbb      	ldrb	r3, [r7, #22]
 8012d4c:	3301      	adds	r3, #1
 8012d4e:	75bb      	strb	r3, [r7, #22]
            while (((lastByte >> unusedBits) & 0x01) == 0x00)
 8012d50:	7d7a      	ldrb	r2, [r7, #21]
 8012d52:	7dbb      	ldrb	r3, [r7, #22]
 8012d54:	fa42 f303 	asr.w	r3, r2, r3
 8012d58:	f003 0301 	and.w	r3, r3, #1
 8012d5c:	2b00      	cmp	r3, #0
 8012d5e:	d0f4      	beq.n	8012d4a <SetASN_Num+0x6e>
        }
        /* Add unused bits byte. */
        len++;
 8012d60:	7dfb      	ldrb	r3, [r7, #23]
 8012d62:	3301      	adds	r3, #1
 8012d64:	75fb      	strb	r3, [r7, #23]
        out[idx++] = unusedBits;
 8012d66:	69bb      	ldr	r3, [r7, #24]
 8012d68:	1c5a      	adds	r2, r3, #1
 8012d6a:	61ba      	str	r2, [r7, #24]
 8012d6c:	687a      	ldr	r2, [r7, #4]
 8012d6e:	4413      	add	r3, r2
 8012d70:	7dba      	ldrb	r2, [r7, #22]
 8012d72:	701a      	strb	r2, [r3, #0]
    }

    /* An INTEGER has a prepended byte if MSB of number is 1 - makes encoded
     * value positive. */
    if ((tag == ASN_INTEGER) && (((n >> j) & 0x80) == 0x80)) {
 8012d74:	78fb      	ldrb	r3, [r7, #3]
 8012d76:	2b02      	cmp	r3, #2
 8012d78:	d111      	bne.n	8012d9e <SetASN_Num+0xc2>
 8012d7a:	68fa      	ldr	r2, [r7, #12]
 8012d7c:	69fb      	ldr	r3, [r7, #28]
 8012d7e:	fa22 f303 	lsr.w	r3, r2, r3
 8012d82:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8012d86:	2b00      	cmp	r3, #0
 8012d88:	d009      	beq.n	8012d9e <SetASN_Num+0xc2>
        len++;
 8012d8a:	7dfb      	ldrb	r3, [r7, #23]
 8012d8c:	3301      	adds	r3, #1
 8012d8e:	75fb      	strb	r3, [r7, #23]
        out[idx++] = 0;
 8012d90:	69bb      	ldr	r3, [r7, #24]
 8012d92:	1c5a      	adds	r2, r3, #1
 8012d94:	61ba      	str	r2, [r7, #24]
 8012d96:	687a      	ldr	r2, [r7, #4]
 8012d98:	4413      	add	r3, r2
 8012d9a:	2200      	movs	r2, #0
 8012d9c:	701a      	strb	r2, [r3, #0]
    }

    /* Go back and put in length. */
    out[1] = len;
 8012d9e:	687b      	ldr	r3, [r7, #4]
 8012da0:	3301      	adds	r3, #1
 8012da2:	7dfa      	ldrb	r2, [r7, #23]
 8012da4:	701a      	strb	r2, [r3, #0]
    /* Place in the required bytes of the number. */
    for (; j >= 0; j -= 8)
 8012da6:	e00d      	b.n	8012dc4 <SetASN_Num+0xe8>
        out[idx++] = (byte)(n >> j);
 8012da8:	68fa      	ldr	r2, [r7, #12]
 8012daa:	69fb      	ldr	r3, [r7, #28]
 8012dac:	fa22 f103 	lsr.w	r1, r2, r3
 8012db0:	69bb      	ldr	r3, [r7, #24]
 8012db2:	1c5a      	adds	r2, r3, #1
 8012db4:	61ba      	str	r2, [r7, #24]
 8012db6:	687a      	ldr	r2, [r7, #4]
 8012db8:	4413      	add	r3, r2
 8012dba:	b2ca      	uxtb	r2, r1
 8012dbc:	701a      	strb	r2, [r3, #0]
    for (; j >= 0; j -= 8)
 8012dbe:	69fb      	ldr	r3, [r7, #28]
 8012dc0:	3b08      	subs	r3, #8
 8012dc2:	61fb      	str	r3, [r7, #28]
 8012dc4:	69fb      	ldr	r3, [r7, #28]
 8012dc6:	2b00      	cmp	r3, #0
 8012dc8:	daee      	bge.n	8012da8 <SetASN_Num+0xcc>
}
 8012dca:	bf00      	nop
 8012dcc:	bf00      	nop
 8012dce:	3724      	adds	r7, #36	@ 0x24
 8012dd0:	46bd      	mov	sp, r7
 8012dd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012dd6:	4770      	bx	lr

08012dd8 <SetASN_Items>:
 * @param [in]      count   Count of items to encode.
 * @param [in, out] output  Buffer to write encoding into.
 * @return  Size of the DER encoding in bytes.
 */
int SetASN_Items(const ASNItem* asn, ASNSetData *data, int count, byte* output)
{
 8012dd8:	b580      	push	{r7, lr}
 8012dda:	b08c      	sub	sp, #48	@ 0x30
 8012ddc:	af00      	add	r7, sp, #0
 8012dde:	60f8      	str	r0, [r7, #12]
 8012de0:	60b9      	str	r1, [r7, #8]
 8012de2:	607a      	str	r2, [r7, #4]
 8012de4:	603b      	str	r3, [r7, #0]
    WOLFSSL_ENTER("SetASN_Items");
#endif

    /* Offset of first item is the total length.
     * SizeASN_Items() calculated this. */
    sz = data[0].offset;
 8012de6:	68bb      	ldr	r3, [r7, #8]
 8012de8:	681b      	ldr	r3, [r3, #0]
 8012dea:	623b      	str	r3, [r7, #32]

    /* Write out each item. */
    for (i = 0; i < count; i++) {
 8012dec:	2300      	movs	r3, #0
 8012dee:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012df0:	e1fe      	b.n	80131f0 <SetASN_Items+0x418>
        /* Skip items not writing out. */
        if (data[i].noOut)
 8012df2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012df4:	4613      	mov	r3, r2
 8012df6:	009b      	lsls	r3, r3, #2
 8012df8:	4413      	add	r3, r2
 8012dfa:	009b      	lsls	r3, r3, #2
 8012dfc:	461a      	mov	r2, r3
 8012dfe:	68bb      	ldr	r3, [r7, #8]
 8012e00:	4413      	add	r3, r2
 8012e02:	7c5b      	ldrb	r3, [r3, #17]
 8012e04:	2b00      	cmp	r3, #0
 8012e06:	f040 81eb 	bne.w	80131e0 <SetASN_Items+0x408>
            continue;

        /* Start position to write item based on reverse offsets. */
        out = output + sz - data[i].offset;
 8012e0a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012e0c:	4613      	mov	r3, r2
 8012e0e:	009b      	lsls	r3, r3, #2
 8012e10:	4413      	add	r3, r2
 8012e12:	009b      	lsls	r3, r3, #2
 8012e14:	461a      	mov	r2, r3
 8012e16:	68bb      	ldr	r3, [r7, #8]
 8012e18:	4413      	add	r3, r2
 8012e1a:	681b      	ldr	r3, [r3, #0]
 8012e1c:	6a3a      	ldr	r2, [r7, #32]
 8012e1e:	1ad3      	subs	r3, r2, r3
 8012e20:	683a      	ldr	r2, [r7, #0]
 8012e22:	4413      	add	r3, r2
 8012e24:	61fb      	str	r3, [r7, #28]
        /* Index from start of item out. */
        idx = 0;
 8012e26:	2300      	movs	r3, #0
 8012e28:	62bb      	str	r3, [r7, #40]	@ 0x28

        if (data[i].dataType != ASN_DATA_TYPE_REPLACE_BUFFER) {
 8012e2a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012e2c:	4613      	mov	r3, r2
 8012e2e:	009b      	lsls	r3, r3, #2
 8012e30:	4413      	add	r3, r2
 8012e32:	009b      	lsls	r3, r3, #2
 8012e34:	461a      	mov	r2, r3
 8012e36:	68bb      	ldr	r3, [r7, #8]
 8012e38:	4413      	add	r3, r2
 8012e3a:	7c1b      	ldrb	r3, [r3, #16]
 8012e3c:	2b07      	cmp	r3, #7
 8012e3e:	d019      	beq.n	8012e74 <SetASN_Items+0x9c>
            /* Put in the tag - not dumping in DER from buffer. */
            out[idx++] = asn[i].tag |
 8012e40:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012e42:	009b      	lsls	r3, r3, #2
 8012e44:	68fa      	ldr	r2, [r7, #12]
 8012e46:	4413      	add	r3, r2
 8012e48:	785b      	ldrb	r3, [r3, #1]
 8012e4a:	b25a      	sxtb	r2, r3
                         (asn[i].constructed ? ASN_CONSTRUCTED : 0);
 8012e4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012e4e:	009b      	lsls	r3, r3, #2
 8012e50:	68f9      	ldr	r1, [r7, #12]
 8012e52:	440b      	add	r3, r1
 8012e54:	789b      	ldrb	r3, [r3, #2]
 8012e56:	b25b      	sxtb	r3, r3
 8012e58:	015b      	lsls	r3, r3, #5
 8012e5a:	b25b      	sxtb	r3, r3
 8012e5c:	f003 0320 	and.w	r3, r3, #32
 8012e60:	b25b      	sxtb	r3, r3
            out[idx++] = asn[i].tag |
 8012e62:	4313      	orrs	r3, r2
 8012e64:	b259      	sxtb	r1, r3
 8012e66:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012e68:	1c5a      	adds	r2, r3, #1
 8012e6a:	62ba      	str	r2, [r7, #40]	@ 0x28
 8012e6c:	69fa      	ldr	r2, [r7, #28]
 8012e6e:	4413      	add	r3, r2
 8012e70:	b2ca      	uxtb	r2, r1
 8012e72:	701a      	strb	r2, [r3, #0]
                sz - data[i].offset,
                data[i].length, asn[i].constructed ? '+' : ' ', asn[i].depth,
                "", TagString(asn[i].tag));
    #endif

        switch (data[i].dataType) {
 8012e74:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012e76:	4613      	mov	r3, r2
 8012e78:	009b      	lsls	r3, r3, #2
 8012e7a:	4413      	add	r3, r2
 8012e7c:	009b      	lsls	r3, r3, #2
 8012e7e:	461a      	mov	r2, r3
 8012e80:	68bb      	ldr	r3, [r7, #8]
 8012e82:	4413      	add	r3, r2
 8012e84:	7c1b      	ldrb	r3, [r3, #16]
 8012e86:	2b08      	cmp	r3, #8
 8012e88:	f200 81af 	bhi.w	80131ea <SetASN_Items+0x412>
 8012e8c:	a201      	add	r2, pc, #4	@ (adr r2, 8012e94 <SetASN_Items+0xbc>)
 8012e8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012e92:	bf00      	nop
 8012e94:	08013021 	.word	0x08013021
 8012e98:	08012eb9 	.word	0x08012eb9
 8012e9c:	08012ee1 	.word	0x08012ee1
 8012ea0:	080131eb 	.word	0x080131eb
 8012ea4:	080131eb 	.word	0x080131eb
 8012ea8:	080131eb 	.word	0x080131eb
 8012eac:	080131eb 	.word	0x080131eb
 8012eb0:	08012fbf 	.word	0x08012fbf
 8012eb4:	08012f09 	.word	0x08012f09
            /* Write out the length and data of a number. */
            case ASN_DATA_TYPE_WORD8:
                SetASN_Num(data[i].data.u8, 8, out, asn[i].tag);
 8012eb8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012eba:	4613      	mov	r3, r2
 8012ebc:	009b      	lsls	r3, r3, #2
 8012ebe:	4413      	add	r3, r2
 8012ec0:	009b      	lsls	r3, r3, #2
 8012ec2:	461a      	mov	r2, r3
 8012ec4:	68bb      	ldr	r3, [r7, #8]
 8012ec6:	4413      	add	r3, r2
 8012ec8:	7a1b      	ldrb	r3, [r3, #8]
 8012eca:	4618      	mov	r0, r3
 8012ecc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012ece:	009b      	lsls	r3, r3, #2
 8012ed0:	68fa      	ldr	r2, [r7, #12]
 8012ed2:	4413      	add	r3, r2
 8012ed4:	785b      	ldrb	r3, [r3, #1]
 8012ed6:	69fa      	ldr	r2, [r7, #28]
 8012ed8:	2108      	movs	r1, #8
 8012eda:	f7ff feff 	bl	8012cdc <SetASN_Num>
                break;
 8012ede:	e184      	b.n	80131ea <SetASN_Items+0x412>
            case ASN_DATA_TYPE_WORD16:
                SetASN_Num(data[i].data.u16, 16, out, asn[i].tag);
 8012ee0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012ee2:	4613      	mov	r3, r2
 8012ee4:	009b      	lsls	r3, r3, #2
 8012ee6:	4413      	add	r3, r2
 8012ee8:	009b      	lsls	r3, r3, #2
 8012eea:	461a      	mov	r2, r3
 8012eec:	68bb      	ldr	r3, [r7, #8]
 8012eee:	4413      	add	r3, r2
 8012ef0:	891b      	ldrh	r3, [r3, #8]
 8012ef2:	4618      	mov	r0, r3
 8012ef4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012ef6:	009b      	lsls	r3, r3, #2
 8012ef8:	68fa      	ldr	r2, [r7, #12]
 8012efa:	4413      	add	r3, r2
 8012efc:	785b      	ldrb	r3, [r3, #1]
 8012efe:	69fa      	ldr	r2, [r7, #28]
 8012f00:	2110      	movs	r1, #16
 8012f02:	f7ff feeb 	bl	8012cdc <SetASN_Num>
                break;
 8012f06:	e170      	b.n	80131ea <SetASN_Items+0x412>
        #endif

            /* Write out the length and data of a multi-precision number. */
            case ASN_DATA_TYPE_MP:
                /* Get length in bytes. */
                length = mp_unsigned_bin_size(data[i].data.mp);
 8012f08:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012f0a:	4613      	mov	r3, r2
 8012f0c:	009b      	lsls	r3, r3, #2
 8012f0e:	4413      	add	r3, r2
 8012f10:	009b      	lsls	r3, r3, #2
 8012f12:	461a      	mov	r2, r3
 8012f14:	68bb      	ldr	r3, [r7, #8]
 8012f16:	4413      	add	r3, r2
 8012f18:	689b      	ldr	r3, [r3, #8]
 8012f1a:	4618      	mov	r0, r3
 8012f1c:	f013 fd6e 	bl	80269fc <mp_unsigned_bin_size>
 8012f20:	61b8      	str	r0, [r7, #24]
                /* Add one for leading zero to make encoding a positive num. */
                length += mp_leading_bit(data[i].data.mp) ? 1 : 0;
 8012f22:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012f24:	4613      	mov	r3, r2
 8012f26:	009b      	lsls	r3, r3, #2
 8012f28:	4413      	add	r3, r2
 8012f2a:	009b      	lsls	r3, r3, #2
 8012f2c:	461a      	mov	r2, r3
 8012f2e:	68bb      	ldr	r3, [r7, #8]
 8012f30:	4413      	add	r3, r2
 8012f32:	689b      	ldr	r3, [r3, #8]
 8012f34:	4618      	mov	r0, r3
 8012f36:	f013 fe29 	bl	8026b8c <mp_leading_bit>
 8012f3a:	4603      	mov	r3, r0
 8012f3c:	2b00      	cmp	r3, #0
 8012f3e:	bf14      	ite	ne
 8012f40:	2301      	movne	r3, #1
 8012f42:	2300      	moveq	r3, #0
 8012f44:	b2db      	uxtb	r3, r3
 8012f46:	461a      	mov	r2, r3
 8012f48:	69bb      	ldr	r3, [r7, #24]
 8012f4a:	4413      	add	r3, r2
 8012f4c:	61bb      	str	r3, [r7, #24]
                /* Write out length. */
                idx += SetASNLength((word32)length, out + idx);
 8012f4e:	69b8      	ldr	r0, [r7, #24]
 8012f50:	69fa      	ldr	r2, [r7, #28]
 8012f52:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012f54:	4413      	add	r3, r2
 8012f56:	4619      	mov	r1, r3
 8012f58:	f7ff fc17 	bl	801278a <SetASNLength>
 8012f5c:	4602      	mov	r2, r0
 8012f5e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012f60:	4413      	add	r3, r2
 8012f62:	62bb      	str	r3, [r7, #40]	@ 0x28
                /* Write out leading zero to make positive. */
                if (mp_leading_bit(data[i].data.mp)) {
 8012f64:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012f66:	4613      	mov	r3, r2
 8012f68:	009b      	lsls	r3, r3, #2
 8012f6a:	4413      	add	r3, r2
 8012f6c:	009b      	lsls	r3, r3, #2
 8012f6e:	461a      	mov	r2, r3
 8012f70:	68bb      	ldr	r3, [r7, #8]
 8012f72:	4413      	add	r3, r2
 8012f74:	689b      	ldr	r3, [r3, #8]
 8012f76:	4618      	mov	r0, r3
 8012f78:	f013 fe08 	bl	8026b8c <mp_leading_bit>
 8012f7c:	4603      	mov	r3, r0
 8012f7e:	2b00      	cmp	r3, #0
 8012f80:	d006      	beq.n	8012f90 <SetASN_Items+0x1b8>
                    out[idx++] = 0;
 8012f82:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012f84:	1c5a      	adds	r2, r3, #1
 8012f86:	62ba      	str	r2, [r7, #40]	@ 0x28
 8012f88:	69fa      	ldr	r2, [r7, #28]
 8012f8a:	4413      	add	r3, r2
 8012f8c:	2200      	movs	r2, #0
 8012f8e:	701a      	strb	r2, [r3, #0]
                }
                /* Encode number in big-endian byte array. */
                err = mp_to_unsigned_bin(data[i].data.mp, out + idx);
 8012f90:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012f92:	4613      	mov	r3, r2
 8012f94:	009b      	lsls	r3, r3, #2
 8012f96:	4413      	add	r3, r2
 8012f98:	009b      	lsls	r3, r3, #2
 8012f9a:	461a      	mov	r2, r3
 8012f9c:	68bb      	ldr	r3, [r7, #8]
 8012f9e:	4413      	add	r3, r2
 8012fa0:	6898      	ldr	r0, [r3, #8]
 8012fa2:	69fa      	ldr	r2, [r7, #28]
 8012fa4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012fa6:	4413      	add	r3, r2
 8012fa8:	4619      	mov	r1, r3
 8012faa:	f013 fd33 	bl	8026a14 <mp_to_unsigned_bin>
 8012fae:	6178      	str	r0, [r7, #20]
                if (err != MP_OKAY) {
 8012fb0:	697b      	ldr	r3, [r7, #20]
 8012fb2:	2b00      	cmp	r3, #0
 8012fb4:	f000 8116 	beq.w	80131e4 <SetASN_Items+0x40c>
                    WOLFSSL_MSG("SetASN_Items: Failed to write mp_int");
                    return MP_TO_E;
 8012fb8:	f06f 0370 	mvn.w	r3, #112	@ 0x70
 8012fbc:	e11e      	b.n	80131fc <SetASN_Items+0x424>
                }
                break;

            case ASN_DATA_TYPE_REPLACE_BUFFER:
                if (data[i].data.buffer.data == NULL) {
 8012fbe:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012fc0:	4613      	mov	r3, r2
 8012fc2:	009b      	lsls	r3, r3, #2
 8012fc4:	4413      	add	r3, r2
 8012fc6:	009b      	lsls	r3, r3, #2
 8012fc8:	461a      	mov	r2, r3
 8012fca:	68bb      	ldr	r3, [r7, #8]
 8012fcc:	4413      	add	r3, r2
 8012fce:	689b      	ldr	r3, [r3, #8]
 8012fd0:	2b00      	cmp	r3, #0
 8012fd2:	d10c      	bne.n	8012fee <SetASN_Items+0x216>
                    /* Return pointer for caller to use. */
                    data[i].data.buffer.data = out + idx;
 8012fd4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012fd6:	4613      	mov	r3, r2
 8012fd8:	009b      	lsls	r3, r3, #2
 8012fda:	4413      	add	r3, r2
 8012fdc:	009b      	lsls	r3, r3, #2
 8012fde:	461a      	mov	r2, r3
 8012fe0:	68bb      	ldr	r3, [r7, #8]
 8012fe2:	4413      	add	r3, r2
 8012fe4:	69f9      	ldr	r1, [r7, #28]
 8012fe6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8012fe8:	440a      	add	r2, r1
 8012fea:	609a      	str	r2, [r3, #8]
                else {
                    /* Dump in the DER encoded data. */
                    XMEMCPY(out + idx, data[i].data.buffer.data,
                            data[i].data.buffer.length);
                }
                break;
 8012fec:	e0fd      	b.n	80131ea <SetASN_Items+0x412>
                    XMEMCPY(out + idx, data[i].data.buffer.data,
 8012fee:	69fa      	ldr	r2, [r7, #28]
 8012ff0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012ff2:	18d0      	adds	r0, r2, r3
 8012ff4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012ff6:	4613      	mov	r3, r2
 8012ff8:	009b      	lsls	r3, r3, #2
 8012ffa:	4413      	add	r3, r2
 8012ffc:	009b      	lsls	r3, r3, #2
 8012ffe:	461a      	mov	r2, r3
 8013000:	68bb      	ldr	r3, [r7, #8]
 8013002:	4413      	add	r3, r2
 8013004:	6899      	ldr	r1, [r3, #8]
 8013006:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013008:	4613      	mov	r3, r2
 801300a:	009b      	lsls	r3, r3, #2
 801300c:	4413      	add	r3, r2
 801300e:	009b      	lsls	r3, r3, #2
 8013010:	461a      	mov	r2, r3
 8013012:	68bb      	ldr	r3, [r7, #8]
 8013014:	4413      	add	r3, r2
 8013016:	68db      	ldr	r3, [r3, #12]
 8013018:	461a      	mov	r2, r3
 801301a:	f015 fac3 	bl	80285a4 <memcpy>
                break;
 801301e:	e0e4      	b.n	80131ea <SetASN_Items+0x412>

            case ASN_DATA_TYPE_NONE:
                if (asn[i].tag == ASN_BOOLEAN) {
 8013020:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013022:	009b      	lsls	r3, r3, #2
 8013024:	68fa      	ldr	r2, [r7, #12]
 8013026:	4413      	add	r3, r2
 8013028:	785b      	ldrb	r3, [r3, #1]
 801302a:	2b01      	cmp	r3, #1
 801302c:	d11a      	bne.n	8013064 <SetASN_Items+0x28c>
                    /* Always one byte of data. */
                    out[idx++] = 1;
 801302e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013030:	1c5a      	adds	r2, r3, #1
 8013032:	62ba      	str	r2, [r7, #40]	@ 0x28
 8013034:	69fa      	ldr	r2, [r7, #28]
 8013036:	4413      	add	r3, r2
 8013038:	2201      	movs	r2, #1
 801303a:	701a      	strb	r2, [r3, #0]
                    /* TRUE = 0xff, FALSE = 0x00 */
                    out[idx] = data[i].data.u8 ? 0xffU : 0x00U;
 801303c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801303e:	4613      	mov	r3, r2
 8013040:	009b      	lsls	r3, r3, #2
 8013042:	4413      	add	r3, r2
 8013044:	009b      	lsls	r3, r3, #2
 8013046:	461a      	mov	r2, r3
 8013048:	68bb      	ldr	r3, [r7, #8]
 801304a:	4413      	add	r3, r2
 801304c:	7a1b      	ldrb	r3, [r3, #8]
 801304e:	2b00      	cmp	r3, #0
 8013050:	d001      	beq.n	8013056 <SetASN_Items+0x27e>
 8013052:	21ff      	movs	r1, #255	@ 0xff
 8013054:	e000      	b.n	8013058 <SetASN_Items+0x280>
 8013056:	2100      	movs	r1, #0
 8013058:	69fa      	ldr	r2, [r7, #28]
 801305a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801305c:	4413      	add	r3, r2
 801305e:	460a      	mov	r2, r1
 8013060:	701a      	strb	r2, [r3, #0]
                        /* Allow data to come from output buffer. */
                        XMEMMOVE(out + idx, data[i].data.buffer.data,
                                 data[i].data.buffer.length);
                    }
                }
                break;
 8013062:	e0c1      	b.n	80131e8 <SetASN_Items+0x410>
                else if (asn[i].tag == ASN_TAG_NULL) {
 8013064:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013066:	009b      	lsls	r3, r3, #2
 8013068:	68fa      	ldr	r2, [r7, #12]
 801306a:	4413      	add	r3, r2
 801306c:	785b      	ldrb	r3, [r3, #1]
 801306e:	2b05      	cmp	r3, #5
 8013070:	d105      	bne.n	801307e <SetASN_Items+0x2a6>
                    out[idx] = 0;
 8013072:	69fa      	ldr	r2, [r7, #28]
 8013074:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013076:	4413      	add	r3, r2
 8013078:	2200      	movs	r2, #0
 801307a:	701a      	strb	r2, [r3, #0]
                break;
 801307c:	e0b4      	b.n	80131e8 <SetASN_Items+0x410>
                    word32 dataLen = data[i].data.buffer.length;
 801307e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013080:	4613      	mov	r3, r2
 8013082:	009b      	lsls	r3, r3, #2
 8013084:	4413      	add	r3, r2
 8013086:	009b      	lsls	r3, r3, #2
 8013088:	461a      	mov	r2, r3
 801308a:	68bb      	ldr	r3, [r7, #8]
 801308c:	4413      	add	r3, r2
 801308e:	68db      	ldr	r3, [r3, #12]
 8013090:	627b      	str	r3, [r7, #36]	@ 0x24
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 8013092:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013094:	009b      	lsls	r3, r3, #2
 8013096:	68fa      	ldr	r2, [r7, #12]
 8013098:	4413      	add	r3, r2
 801309a:	785b      	ldrb	r3, [r3, #1]
 801309c:	2b03      	cmp	r3, #3
 801309e:	d01e      	beq.n	80130de <SetASN_Items+0x306>
                                                   ASNIntMSBSet(asn, data, i)) {
 80130a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80130a2:	009b      	lsls	r3, r3, #2
 80130a4:	68fa      	ldr	r2, [r7, #12]
 80130a6:	4413      	add	r3, r2
 80130a8:	785b      	ldrb	r3, [r3, #1]
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 80130aa:	2b02      	cmp	r3, #2
 80130ac:	d11a      	bne.n	80130e4 <SetASN_Items+0x30c>
                                                   ASNIntMSBSet(asn, data, i)) {
 80130ae:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80130b0:	4613      	mov	r3, r2
 80130b2:	009b      	lsls	r3, r3, #2
 80130b4:	4413      	add	r3, r2
 80130b6:	009b      	lsls	r3, r3, #2
 80130b8:	461a      	mov	r2, r3
 80130ba:	68bb      	ldr	r3, [r7, #8]
 80130bc:	4413      	add	r3, r2
 80130be:	689b      	ldr	r3, [r3, #8]
 80130c0:	2b00      	cmp	r3, #0
 80130c2:	d00f      	beq.n	80130e4 <SetASN_Items+0x30c>
 80130c4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80130c6:	4613      	mov	r3, r2
 80130c8:	009b      	lsls	r3, r3, #2
 80130ca:	4413      	add	r3, r2
 80130cc:	009b      	lsls	r3, r3, #2
 80130ce:	461a      	mov	r2, r3
 80130d0:	68bb      	ldr	r3, [r7, #8]
 80130d2:	4413      	add	r3, r2
 80130d4:	689b      	ldr	r3, [r3, #8]
 80130d6:	781b      	ldrb	r3, [r3, #0]
 80130d8:	b25b      	sxtb	r3, r3
 80130da:	2b00      	cmp	r3, #0
 80130dc:	da02      	bge.n	80130e4 <SetASN_Items+0x30c>
                        dataLen++;
 80130de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80130e0:	3301      	adds	r3, #1
 80130e2:	627b      	str	r3, [r7, #36]	@ 0x24
                    idx += SetASNLength(dataLen, out + idx);
 80130e4:	69fa      	ldr	r2, [r7, #28]
 80130e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80130e8:	4413      	add	r3, r2
 80130ea:	4619      	mov	r1, r3
 80130ec:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 80130ee:	f7ff fb4c 	bl	801278a <SetASNLength>
 80130f2:	4602      	mov	r2, r0
 80130f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80130f6:	4413      	add	r3, r2
 80130f8:	62bb      	str	r3, [r7, #40]	@ 0x28
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 80130fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80130fc:	009b      	lsls	r3, r3, #2
 80130fe:	68fa      	ldr	r2, [r7, #12]
 8013100:	4413      	add	r3, r2
 8013102:	785b      	ldrb	r3, [r3, #1]
 8013104:	2b03      	cmp	r3, #3
 8013106:	d01e      	beq.n	8013146 <SetASN_Items+0x36e>
                                                   ASNIntMSBSet(asn, data, i)) {
 8013108:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801310a:	009b      	lsls	r3, r3, #2
 801310c:	68fa      	ldr	r2, [r7, #12]
 801310e:	4413      	add	r3, r2
 8013110:	785b      	ldrb	r3, [r3, #1]
                    if ((asn[i].tag == ASN_BIT_STRING) ||
 8013112:	2b02      	cmp	r3, #2
 8013114:	d11e      	bne.n	8013154 <SetASN_Items+0x37c>
                                                   ASNIntMSBSet(asn, data, i)) {
 8013116:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013118:	4613      	mov	r3, r2
 801311a:	009b      	lsls	r3, r3, #2
 801311c:	4413      	add	r3, r2
 801311e:	009b      	lsls	r3, r3, #2
 8013120:	461a      	mov	r2, r3
 8013122:	68bb      	ldr	r3, [r7, #8]
 8013124:	4413      	add	r3, r2
 8013126:	689b      	ldr	r3, [r3, #8]
 8013128:	2b00      	cmp	r3, #0
 801312a:	d013      	beq.n	8013154 <SetASN_Items+0x37c>
 801312c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801312e:	4613      	mov	r3, r2
 8013130:	009b      	lsls	r3, r3, #2
 8013132:	4413      	add	r3, r2
 8013134:	009b      	lsls	r3, r3, #2
 8013136:	461a      	mov	r2, r3
 8013138:	68bb      	ldr	r3, [r7, #8]
 801313a:	4413      	add	r3, r2
 801313c:	689b      	ldr	r3, [r3, #8]
 801313e:	781b      	ldrb	r3, [r3, #0]
 8013140:	b25b      	sxtb	r3, r3
 8013142:	2b00      	cmp	r3, #0
 8013144:	da06      	bge.n	8013154 <SetASN_Items+0x37c>
                        out[idx++] = 0x00;
 8013146:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013148:	1c5a      	adds	r2, r3, #1
 801314a:	62ba      	str	r2, [r7, #40]	@ 0x28
 801314c:	69fa      	ldr	r2, [r7, #28]
 801314e:	4413      	add	r3, r2
 8013150:	2200      	movs	r2, #0
 8013152:	701a      	strb	r2, [r3, #0]
                    if (data[i].data.buffer.data == NULL) {
 8013154:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013156:	4613      	mov	r3, r2
 8013158:	009b      	lsls	r3, r3, #2
 801315a:	4413      	add	r3, r2
 801315c:	009b      	lsls	r3, r3, #2
 801315e:	461a      	mov	r2, r3
 8013160:	68bb      	ldr	r3, [r7, #8]
 8013162:	4413      	add	r3, r2
 8013164:	689b      	ldr	r3, [r3, #8]
 8013166:	2b00      	cmp	r3, #0
 8013168:	d10c      	bne.n	8013184 <SetASN_Items+0x3ac>
                        data[i].data.buffer.data = out + idx;
 801316a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801316c:	4613      	mov	r3, r2
 801316e:	009b      	lsls	r3, r3, #2
 8013170:	4413      	add	r3, r2
 8013172:	009b      	lsls	r3, r3, #2
 8013174:	461a      	mov	r2, r3
 8013176:	68bb      	ldr	r3, [r7, #8]
 8013178:	4413      	add	r3, r2
 801317a:	69f9      	ldr	r1, [r7, #28]
 801317c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801317e:	440a      	add	r2, r1
 8013180:	609a      	str	r2, [r3, #8]
                break;
 8013182:	e031      	b.n	80131e8 <SetASN_Items+0x410>
                    else if (!asn[i].headerOnly ||
 8013184:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013186:	009b      	lsls	r3, r3, #2
 8013188:	68fa      	ldr	r2, [r7, #12]
 801318a:	4413      	add	r3, r2
 801318c:	789b      	ldrb	r3, [r3, #2]
 801318e:	f003 0302 	and.w	r3, r3, #2
 8013192:	b2db      	uxtb	r3, r3
 8013194:	2b00      	cmp	r3, #0
 8013196:	d00a      	beq.n	80131ae <SetASN_Items+0x3d6>
                            data[i].data.buffer.data != NULL) {
 8013198:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801319a:	4613      	mov	r3, r2
 801319c:	009b      	lsls	r3, r3, #2
 801319e:	4413      	add	r3, r2
 80131a0:	009b      	lsls	r3, r3, #2
 80131a2:	461a      	mov	r2, r3
 80131a4:	68bb      	ldr	r3, [r7, #8]
 80131a6:	4413      	add	r3, r2
 80131a8:	689b      	ldr	r3, [r3, #8]
                    else if (!asn[i].headerOnly ||
 80131aa:	2b00      	cmp	r3, #0
 80131ac:	d01c      	beq.n	80131e8 <SetASN_Items+0x410>
                        XMEMMOVE(out + idx, data[i].data.buffer.data,
 80131ae:	69fa      	ldr	r2, [r7, #28]
 80131b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80131b2:	18d0      	adds	r0, r2, r3
 80131b4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80131b6:	4613      	mov	r3, r2
 80131b8:	009b      	lsls	r3, r3, #2
 80131ba:	4413      	add	r3, r2
 80131bc:	009b      	lsls	r3, r3, #2
 80131be:	461a      	mov	r2, r3
 80131c0:	68bb      	ldr	r3, [r7, #8]
 80131c2:	4413      	add	r3, r2
 80131c4:	6899      	ldr	r1, [r3, #8]
 80131c6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80131c8:	4613      	mov	r3, r2
 80131ca:	009b      	lsls	r3, r3, #2
 80131cc:	4413      	add	r3, r2
 80131ce:	009b      	lsls	r3, r3, #2
 80131d0:	461a      	mov	r2, r3
 80131d2:	68bb      	ldr	r3, [r7, #8]
 80131d4:	4413      	add	r3, r2
 80131d6:	68db      	ldr	r3, [r3, #12]
 80131d8:	461a      	mov	r2, r3
 80131da:	f015 f95f 	bl	802849c <memmove>
                break;
 80131de:	e003      	b.n	80131e8 <SetASN_Items+0x410>
            continue;
 80131e0:	bf00      	nop
 80131e2:	e002      	b.n	80131ea <SetASN_Items+0x412>
                break;
 80131e4:	bf00      	nop
 80131e6:	e000      	b.n	80131ea <SetASN_Items+0x412>
                break;
 80131e8:	bf00      	nop
    for (i = 0; i < count; i++) {
 80131ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80131ec:	3301      	adds	r3, #1
 80131ee:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80131f0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80131f2:	687b      	ldr	r3, [r7, #4]
 80131f4:	429a      	cmp	r2, r3
 80131f6:	f6ff adfc 	blt.w	8012df2 <SetASN_Items+0x1a>
                return BAD_STATE_E;
        #endif
        }
    }

    return (int)sz;
 80131fa:	6a3b      	ldr	r3, [r7, #32]
}
 80131fc:	4618      	mov	r0, r3
 80131fe:	3730      	adds	r7, #48	@ 0x30
 8013200:	46bd      	mov	sp, r7
 8013202:	bd80      	pop	{r7, pc}

08013204 <GetASN_Integer>:
 * @return  ASN_PARSE_E when 0 is not required but seen.
 * @return  ASN_EXPECT_0_E when 0 is required and not seen.
 */
static int GetASN_Integer(const byte* input, word32 idx, int length,
                          int positive)
{
 8013204:	b480      	push	{r7}
 8013206:	b085      	sub	sp, #20
 8013208:	af00      	add	r7, sp, #0
 801320a:	60f8      	str	r0, [r7, #12]
 801320c:	60b9      	str	r1, [r7, #8]
 801320e:	607a      	str	r2, [r7, #4]
 8013210:	603b      	str	r3, [r7, #0]
#if !defined(HAVE_SELFTEST) && !defined(HAVE_FIPS) || \
    (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))
    /* Check contents consist of one or more octets. */
    if (length == 0) {
 8013212:	687b      	ldr	r3, [r7, #4]
 8013214:	2b00      	cmp	r3, #0
 8013216:	d102      	bne.n	801321e <GetASN_Integer+0x1a>
        WOLFSSL_MSG("Zero length INTEGER not allowed");
        return ASN_PARSE_E;
 8013218:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801321c:	e035      	b.n	801328a <GetASN_Integer+0x86>
    }
#endif
    if (input[idx] == 0) {
 801321e:	68fa      	ldr	r2, [r7, #12]
 8013220:	68bb      	ldr	r3, [r7, #8]
 8013222:	4413      	add	r3, r2
 8013224:	781b      	ldrb	r3, [r3, #0]
 8013226:	2b00      	cmp	r3, #0
 8013228:	d10d      	bne.n	8013246 <GetASN_Integer+0x42>
        /* Check leading zero byte required. */
        if ((length > 1) && ((input[idx + 1] & 0x80) == 0)) {
 801322a:	687b      	ldr	r3, [r7, #4]
 801322c:	2b01      	cmp	r3, #1
 801322e:	dd2b      	ble.n	8013288 <GetASN_Integer+0x84>
 8013230:	68bb      	ldr	r3, [r7, #8]
 8013232:	3301      	adds	r3, #1
 8013234:	68fa      	ldr	r2, [r7, #12]
 8013236:	4413      	add	r3, r2
 8013238:	781b      	ldrb	r3, [r3, #0]
 801323a:	b25b      	sxtb	r3, r3
 801323c:	2b00      	cmp	r3, #0
 801323e:	db23      	blt.n	8013288 <GetASN_Integer+0x84>
            WOLFSSL_MSG("Zero not required on INTEGER");
        #ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
            return ASN_PARSE_E;
 8013240:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013244:	e021      	b.n	801328a <GetASN_Integer+0x86>
        }
    }
    /* check for invalid padding on negative integer.
     * c.f. X.690 (ISO/IEC 8825-2:2003 (E)) 10.4.6; RFC 5280 4.1
     */
    else if ((length > 1) && (input[idx] == 0xff) &&
 8013246:	687b      	ldr	r3, [r7, #4]
 8013248:	2b01      	cmp	r3, #1
 801324a:	dd10      	ble.n	801326e <GetASN_Integer+0x6a>
 801324c:	68fa      	ldr	r2, [r7, #12]
 801324e:	68bb      	ldr	r3, [r7, #8]
 8013250:	4413      	add	r3, r2
 8013252:	781b      	ldrb	r3, [r3, #0]
 8013254:	2bff      	cmp	r3, #255	@ 0xff
 8013256:	d10a      	bne.n	801326e <GetASN_Integer+0x6a>
             ((input[idx + 1] & 0x80) != 0)) {
 8013258:	68bb      	ldr	r3, [r7, #8]
 801325a:	3301      	adds	r3, #1
 801325c:	68fa      	ldr	r2, [r7, #12]
 801325e:	4413      	add	r3, r2
 8013260:	781b      	ldrb	r3, [r3, #0]
 8013262:	b25b      	sxtb	r3, r3
    else if ((length > 1) && (input[idx] == 0xff) &&
 8013264:	2b00      	cmp	r3, #0
 8013266:	da02      	bge.n	801326e <GetASN_Integer+0x6a>
        WOLFSSL_MSG("Bad INTEGER encoding of negative");
    #ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
        return ASN_EXPECT_0_E;
 8013268:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 801326c:	e00d      	b.n	801328a <GetASN_Integer+0x86>
    #endif /* WOLFSSL_ASN_INT_LEAD_0_ANY */
    }
    /* Check whether a leading zero byte was required. */
    else if (positive && (input[idx] & 0x80)) {
 801326e:	683b      	ldr	r3, [r7, #0]
 8013270:	2b00      	cmp	r3, #0
 8013272:	d009      	beq.n	8013288 <GetASN_Integer+0x84>
 8013274:	68fa      	ldr	r2, [r7, #12]
 8013276:	68bb      	ldr	r3, [r7, #8]
 8013278:	4413      	add	r3, r2
 801327a:	781b      	ldrb	r3, [r3, #0]
 801327c:	b25b      	sxtb	r3, r3
 801327e:	2b00      	cmp	r3, #0
 8013280:	da02      	bge.n	8013288 <GetASN_Integer+0x84>
        WOLFSSL_MSG("INTEGER is negative");
    #ifndef WOLFSSL_ASN_INT_LEAD_0_ANY
        return ASN_EXPECT_0_E;
 8013282:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 8013286:	e000      	b.n	801328a <GetASN_Integer+0x86>
    #endif /* WOLFSSL_ASN_INT_LEAD_0_ANY */
    }

    return 0;
 8013288:	2300      	movs	r3, #0
}
 801328a:	4618      	mov	r0, r3
 801328c:	3714      	adds	r7, #20
 801328e:	46bd      	mov	sp, r7
 8013290:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013294:	4770      	bx	lr

08013296 <GetASN_BitString>:
 * @param [in] length  Length of input data.
 * @return  0 on success.
 * @return  ASN_PARSE_E when unused bits is invalid.
 */
int GetASN_BitString(const byte* input, word32 idx, int length)
{
 8013296:	b480      	push	{r7}
 8013298:	b085      	sub	sp, #20
 801329a:	af00      	add	r7, sp, #0
 801329c:	60f8      	str	r0, [r7, #12]
 801329e:	60b9      	str	r1, [r7, #8]
 80132a0:	607a      	str	r2, [r7, #4]
#if !defined(HAVE_SELFTEST) && !defined(HAVE_FIPS) || \
    (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))
    /* Check contents consist of one or more octets. */
    if (length == 0) {
 80132a2:	687b      	ldr	r3, [r7, #4]
 80132a4:	2b00      	cmp	r3, #0
 80132a6:	d102      	bne.n	80132ae <GetASN_BitString+0x18>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG("Zero length BIT STRING not allowed");
    #endif
        return ASN_PARSE_E;
 80132a8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80132ac:	e01f      	b.n	80132ee <GetASN_BitString+0x58>
    }
#endif
    /* Ensure unused bits value is valid range. */
    if (input[idx] > 7) {
 80132ae:	68fa      	ldr	r2, [r7, #12]
 80132b0:	68bb      	ldr	r3, [r7, #8]
 80132b2:	4413      	add	r3, r2
 80132b4:	781b      	ldrb	r3, [r3, #0]
 80132b6:	2b07      	cmp	r3, #7
 80132b8:	d902      	bls.n	80132c0 <GetASN_BitString+0x2a>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG_VSNPRINTF("BIT STRING unused bits too big: %d > 7",
                input[idx]);
    #endif
        return ASN_PARSE_E;
 80132ba:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80132be:	e016      	b.n	80132ee <GetASN_BitString+0x58>
    }
    /* Ensure unused bits are zero. */
    if ((byte)(input[idx + (word32)length - 1] << (8 - input[idx])) != 0) {
 80132c0:	687a      	ldr	r2, [r7, #4]
 80132c2:	68bb      	ldr	r3, [r7, #8]
 80132c4:	4413      	add	r3, r2
 80132c6:	3b01      	subs	r3, #1
 80132c8:	68fa      	ldr	r2, [r7, #12]
 80132ca:	4413      	add	r3, r2
 80132cc:	781b      	ldrb	r3, [r3, #0]
 80132ce:	4619      	mov	r1, r3
 80132d0:	68fa      	ldr	r2, [r7, #12]
 80132d2:	68bb      	ldr	r3, [r7, #8]
 80132d4:	4413      	add	r3, r2
 80132d6:	781b      	ldrb	r3, [r3, #0]
 80132d8:	f1c3 0308 	rsb	r3, r3, #8
 80132dc:	fa01 f303 	lsl.w	r3, r1, r3
 80132e0:	b2db      	uxtb	r3, r3
 80132e2:	2b00      	cmp	r3, #0
 80132e4:	d002      	beq.n	80132ec <GetASN_BitString+0x56>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG_VSNPRINTF("BIT STRING unused bits used: %d %02x",
                input[idx], input[idx + length - 1]);
    #endif
        return ASN_PARSE_E;
 80132e6:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80132ea:	e000      	b.n	80132ee <GetASN_BitString+0x58>
    }

    return 0;
 80132ec:	2300      	movs	r3, #0
}
 80132ee:	4618      	mov	r0, r3
 80132f0:	3714      	adds	r7, #20
 80132f2:	46bd      	mov	sp, r7
 80132f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80132f8:	4770      	bx	lr

080132fa <GetASN_UTF8String>:
 * @param [in] length  Length of input data.
 * @return  0 on success.
 * @return  ASN_PARSE_E when data is invalid.
 */
static int GetASN_UTF8String(const byte* input, word32 idx, int length)
{
 80132fa:	b480      	push	{r7}
 80132fc:	b089      	sub	sp, #36	@ 0x24
 80132fe:	af00      	add	r7, sp, #0
 8013300:	60f8      	str	r0, [r7, #12]
 8013302:	60b9      	str	r1, [r7, #8]
 8013304:	607a      	str	r2, [r7, #4]
    int ret = 0;
 8013306:	2300      	movs	r3, #0
 8013308:	61fb      	str	r3, [r7, #28]
    word32 i = 0;
 801330a:	2300      	movs	r3, #0
 801330c:	61bb      	str	r3, [r7, #24]

    while ((ret == 0) && ((int)i < length)) {
 801330e:	e058      	b.n	80133c2 <GetASN_UTF8String+0xc8>
        int cnt;

        /* Check code points and get count of following bytes. */
        if ((input[idx + i] & 0x80) == 0x00) {
 8013310:	68ba      	ldr	r2, [r7, #8]
 8013312:	69bb      	ldr	r3, [r7, #24]
 8013314:	4413      	add	r3, r2
 8013316:	68fa      	ldr	r2, [r7, #12]
 8013318:	4413      	add	r3, r2
 801331a:	781b      	ldrb	r3, [r3, #0]
 801331c:	b25b      	sxtb	r3, r3
 801331e:	2b00      	cmp	r3, #0
 8013320:	db02      	blt.n	8013328 <GetASN_UTF8String+0x2e>
            cnt = 0;
 8013322:	2300      	movs	r3, #0
 8013324:	617b      	str	r3, [r7, #20]
 8013326:	e02a      	b.n	801337e <GetASN_UTF8String+0x84>
        }
        else if ((input[idx + i] & 0xe0) == 0xc0) {
 8013328:	68ba      	ldr	r2, [r7, #8]
 801332a:	69bb      	ldr	r3, [r7, #24]
 801332c:	4413      	add	r3, r2
 801332e:	68fa      	ldr	r2, [r7, #12]
 8013330:	4413      	add	r3, r2
 8013332:	781b      	ldrb	r3, [r3, #0]
 8013334:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
 8013338:	2bc0      	cmp	r3, #192	@ 0xc0
 801333a:	d102      	bne.n	8013342 <GetASN_UTF8String+0x48>
            cnt = 1;
 801333c:	2301      	movs	r3, #1
 801333e:	617b      	str	r3, [r7, #20]
 8013340:	e01d      	b.n	801337e <GetASN_UTF8String+0x84>
        }
        else if ((input[idx + i] & 0xf0) == 0xe0) {
 8013342:	68ba      	ldr	r2, [r7, #8]
 8013344:	69bb      	ldr	r3, [r7, #24]
 8013346:	4413      	add	r3, r2
 8013348:	68fa      	ldr	r2, [r7, #12]
 801334a:	4413      	add	r3, r2
 801334c:	781b      	ldrb	r3, [r3, #0]
 801334e:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8013352:	2be0      	cmp	r3, #224	@ 0xe0
 8013354:	d102      	bne.n	801335c <GetASN_UTF8String+0x62>
            cnt = 2;
 8013356:	2302      	movs	r3, #2
 8013358:	617b      	str	r3, [r7, #20]
 801335a:	e010      	b.n	801337e <GetASN_UTF8String+0x84>
        }
        else if ((input[idx + i] & 0xf8) == 0xf0) {
 801335c:	68ba      	ldr	r2, [r7, #8]
 801335e:	69bb      	ldr	r3, [r7, #24]
 8013360:	4413      	add	r3, r2
 8013362:	68fa      	ldr	r2, [r7, #12]
 8013364:	4413      	add	r3, r2
 8013366:	781b      	ldrb	r3, [r3, #0]
 8013368:	f003 03f8 	and.w	r3, r3, #248	@ 0xf8
 801336c:	2bf0      	cmp	r3, #240	@ 0xf0
 801336e:	d102      	bne.n	8013376 <GetASN_UTF8String+0x7c>
            cnt = 3;
 8013370:	2303      	movs	r3, #3
 8013372:	617b      	str	r3, [r7, #20]
 8013374:	e003      	b.n	801337e <GetASN_UTF8String+0x84>
        }
        else {
            WOLFSSL_MSG("Invalid character in UTF8STRING\n");
            ret = ASN_PARSE_E;
 8013376:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801337a:	61fb      	str	r3, [r7, #28]
            break;
 801337c:	e028      	b.n	80133d0 <GetASN_UTF8String+0xd6>
        }

        /* Have checked first byte. */
        i++;
 801337e:	69bb      	ldr	r3, [r7, #24]
 8013380:	3301      	adds	r3, #1
 8013382:	61bb      	str	r3, [r7, #24]
        /* Check each following byte. */
        for (; cnt > 0; cnt--) {
 8013384:	e01a      	b.n	80133bc <GetASN_UTF8String+0xc2>
            /* Check we have enough data. */
            if ((int)i == length) {
 8013386:	69bb      	ldr	r3, [r7, #24]
 8013388:	687a      	ldr	r2, [r7, #4]
 801338a:	429a      	cmp	r2, r3
 801338c:	d103      	bne.n	8013396 <GetASN_UTF8String+0x9c>
                WOLFSSL_MSG("Missing character in UTF8STRING\n");
                ret = ASN_PARSE_E;
 801338e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013392:	61fb      	str	r3, [r7, #28]
                break;
 8013394:	e015      	b.n	80133c2 <GetASN_UTF8String+0xc8>
            }
            /* Check following byte has top bit set. */
            if ((input[idx + i] & 0x80) != 0x80) {
 8013396:	68ba      	ldr	r2, [r7, #8]
 8013398:	69bb      	ldr	r3, [r7, #24]
 801339a:	4413      	add	r3, r2
 801339c:	68fa      	ldr	r2, [r7, #12]
 801339e:	4413      	add	r3, r2
 80133a0:	781b      	ldrb	r3, [r3, #0]
 80133a2:	b25b      	sxtb	r3, r3
 80133a4:	2b00      	cmp	r3, #0
 80133a6:	db03      	blt.n	80133b0 <GetASN_UTF8String+0xb6>
                WOLFSSL_MSG("Invalid character in UTF8STRING\n");
                ret = ASN_PARSE_E;
 80133a8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80133ac:	61fb      	str	r3, [r7, #28]
                break;
 80133ae:	e008      	b.n	80133c2 <GetASN_UTF8String+0xc8>
            }
            i++;
 80133b0:	69bb      	ldr	r3, [r7, #24]
 80133b2:	3301      	adds	r3, #1
 80133b4:	61bb      	str	r3, [r7, #24]
        for (; cnt > 0; cnt--) {
 80133b6:	697b      	ldr	r3, [r7, #20]
 80133b8:	3b01      	subs	r3, #1
 80133ba:	617b      	str	r3, [r7, #20]
 80133bc:	697b      	ldr	r3, [r7, #20]
 80133be:	2b00      	cmp	r3, #0
 80133c0:	dce1      	bgt.n	8013386 <GetASN_UTF8String+0x8c>
    while ((ret == 0) && ((int)i < length)) {
 80133c2:	69fb      	ldr	r3, [r7, #28]
 80133c4:	2b00      	cmp	r3, #0
 80133c6:	d103      	bne.n	80133d0 <GetASN_UTF8String+0xd6>
 80133c8:	69bb      	ldr	r3, [r7, #24]
 80133ca:	687a      	ldr	r2, [r7, #4]
 80133cc:	429a      	cmp	r2, r3
 80133ce:	dc9f      	bgt.n	8013310 <GetASN_UTF8String+0x16>
        }
    }

    return ret;
 80133d0:	69fb      	ldr	r3, [r7, #28]
}
 80133d2:	4618      	mov	r0, r3
 80133d4:	3724      	adds	r7, #36	@ 0x24
 80133d6:	46bd      	mov	sp, r7
 80133d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80133dc:	4770      	bx	lr

080133de <GetASN_ObjectId>:
 * @param [in] length  Length of input data.
 * @return  0 on success.
 * @return  ASN_PARSE_E when data is invalid.
 */
static int GetASN_ObjectId(const byte* input, word32 idx, int length)
{
 80133de:	b480      	push	{r7}
 80133e0:	b087      	sub	sp, #28
 80133e2:	af00      	add	r7, sp, #0
 80133e4:	60f8      	str	r0, [r7, #12]
 80133e6:	60b9      	str	r1, [r7, #8]
 80133e8:	607a      	str	r2, [r7, #4]
    int ret = 0;
 80133ea:	2300      	movs	r3, #0
 80133ec:	617b      	str	r3, [r7, #20]

    /* OID data must be at least 3 bytes. */
    if (length < 3) {
 80133ee:	687b      	ldr	r3, [r7, #4]
 80133f0:	2b02      	cmp	r3, #2
 80133f2:	dc03      	bgt.n	80133fc <GetASN_ObjectId+0x1e>
    #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
        WOLFSSL_MSG_VSNPRINTF("OID length must be 3 or more: %d", length);
    #else
        WOLFSSL_MSG("OID length less than 3");
    #endif
        ret = ASN_PARSE_E;
 80133f4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80133f8:	617b      	str	r3, [r7, #20]
 80133fa:	e00c      	b.n	8013416 <GetASN_ObjectId+0x38>
    }
    /* Last octet of a sub-identifier has bit 8 clear. Last octet must be last
     * of a subidentifier. Ensure last octet hasn't got top bit set.
     */
    else if ((input[(int)idx + length - 1] & 0x80) == 0x80) {
 80133fc:	68ba      	ldr	r2, [r7, #8]
 80133fe:	687b      	ldr	r3, [r7, #4]
 8013400:	4413      	add	r3, r2
 8013402:	3b01      	subs	r3, #1
 8013404:	68fa      	ldr	r2, [r7, #12]
 8013406:	4413      	add	r3, r2
 8013408:	781b      	ldrb	r3, [r3, #0]
 801340a:	b25b      	sxtb	r3, r3
 801340c:	2b00      	cmp	r3, #0
 801340e:	da02      	bge.n	8013416 <GetASN_ObjectId+0x38>
        WOLFSSL_MSG("OID last octet has top bit set");
        ret = ASN_PARSE_E;
 8013410:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013414:	617b      	str	r3, [r7, #20]
    }

    return ret;
 8013416:	697b      	ldr	r3, [r7, #20]
}
 8013418:	4618      	mov	r0, r3
 801341a:	371c      	adds	r7, #28
 801341c:	46bd      	mov	sp, r7
 801341e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013422:	4770      	bx	lr

08013424 <GetASN_StoreData>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
static int GetASN_StoreData(const ASNItem* asn, ASNGetData* data,
                            const byte* input, word32 idx, int len,
                            int zeroPadded)
{
 8013424:	b590      	push	{r4, r7, lr}
 8013426:	b08b      	sub	sp, #44	@ 0x2c
 8013428:	af02      	add	r7, sp, #8
 801342a:	60f8      	str	r0, [r7, #12]
 801342c:	60b9      	str	r1, [r7, #8]
 801342e:	607a      	str	r2, [r7, #4]
 8013430:	603b      	str	r3, [r7, #0]
    int i;
    int err;

    /* Parse data based on data type to extract. */
    switch (data->dataType) {
 8013432:	68bb      	ldr	r3, [r7, #8]
 8013434:	7e1b      	ldrb	r3, [r3, #24]
 8013436:	2b0b      	cmp	r3, #11
 8013438:	f200 8162 	bhi.w	8013700 <GetASN_StoreData+0x2dc>
 801343c:	a201      	add	r2, pc, #4	@ (adr r2, 8013444 <GetASN_StoreData+0x20>)
 801343e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013442:	bf00      	nop
 8013444:	08013643 	.word	0x08013643
 8013448:	08013475 	.word	0x08013475
 801344c:	08013491 	.word	0x08013491
 8013450:	08013701 	.word	0x08013701
 8013454:	080134ef 	.word	0x080134ef
 8013458:	08013549 	.word	0x08013549
 801345c:	08013579 	.word	0x08013579
 8013460:	08013701 	.word	0x08013701
 8013464:	080135ab 	.word	0x080135ab
 8013468:	080135c1 	.word	0x080135c1
 801346c:	080135ab 	.word	0x080135ab
 8013470:	080135ed 	.word	0x080135ed
        /* Parse a data into a number of specified bits. */
        case ASN_DATA_TYPE_WORD8:
            /* Check data is small enough to fit. */
            if (len != 1) {
 8013474:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013476:	2b01      	cmp	r3, #1
 8013478:	d002      	beq.n	8013480 <GetASN_StoreData+0x5c>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Expecting one byte: %d", len);
            #endif
                return ASN_PARSE_E;
 801347a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801347e:	e140      	b.n	8013702 <GetASN_StoreData+0x2de>
            }
            /* Fill number with all of data. */
            *data->data.u8 = input[idx];
 8013480:	687a      	ldr	r2, [r7, #4]
 8013482:	683b      	ldr	r3, [r7, #0]
 8013484:	441a      	add	r2, r3
 8013486:	68bb      	ldr	r3, [r7, #8]
 8013488:	689b      	ldr	r3, [r3, #8]
 801348a:	7812      	ldrb	r2, [r2, #0]
 801348c:	701a      	strb	r2, [r3, #0]
            break;
 801348e:	e137      	b.n	8013700 <GetASN_StoreData+0x2dc>
        case ASN_DATA_TYPE_WORD16:
            /* Check data is small enough to fit. */
            if (len == 0 || len > 2) {
 8013490:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013492:	2b00      	cmp	r3, #0
 8013494:	d002      	beq.n	801349c <GetASN_StoreData+0x78>
 8013496:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013498:	2b02      	cmp	r3, #2
 801349a:	dd02      	ble.n	80134a2 <GetASN_StoreData+0x7e>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Expecting 1 or 2 bytes: %d", len);
            #endif
                return ASN_PARSE_E;
 801349c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80134a0:	e12f      	b.n	8013702 <GetASN_StoreData+0x2de>
            }
            /* Fill number with all of data. */
            *data->data.u16 = 0;
 80134a2:	68bb      	ldr	r3, [r7, #8]
 80134a4:	689b      	ldr	r3, [r3, #8]
 80134a6:	2200      	movs	r2, #0
 80134a8:	801a      	strh	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 80134aa:	2300      	movs	r3, #0
 80134ac:	61fb      	str	r3, [r7, #28]
 80134ae:	e019      	b.n	80134e4 <GetASN_StoreData+0xc0>
                *data->data.u16 = (word16)(*data->data.u16 << 8U);
 80134b0:	68bb      	ldr	r3, [r7, #8]
 80134b2:	689b      	ldr	r3, [r3, #8]
 80134b4:	881a      	ldrh	r2, [r3, #0]
 80134b6:	68bb      	ldr	r3, [r7, #8]
 80134b8:	689b      	ldr	r3, [r3, #8]
 80134ba:	0212      	lsls	r2, r2, #8
 80134bc:	b292      	uxth	r2, r2
 80134be:	801a      	strh	r2, [r3, #0]
                *data->data.u16 = (word16)(*data->data.u16 | input[idx + (word32)i]);
 80134c0:	68bb      	ldr	r3, [r7, #8]
 80134c2:	689b      	ldr	r3, [r3, #8]
 80134c4:	881a      	ldrh	r2, [r3, #0]
 80134c6:	69f9      	ldr	r1, [r7, #28]
 80134c8:	683b      	ldr	r3, [r7, #0]
 80134ca:	440b      	add	r3, r1
 80134cc:	6879      	ldr	r1, [r7, #4]
 80134ce:	440b      	add	r3, r1
 80134d0:	781b      	ldrb	r3, [r3, #0]
 80134d2:	4619      	mov	r1, r3
 80134d4:	68bb      	ldr	r3, [r7, #8]
 80134d6:	689b      	ldr	r3, [r3, #8]
 80134d8:	430a      	orrs	r2, r1
 80134da:	b292      	uxth	r2, r2
 80134dc:	801a      	strh	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 80134de:	69fb      	ldr	r3, [r7, #28]
 80134e0:	3301      	adds	r3, #1
 80134e2:	61fb      	str	r3, [r7, #28]
 80134e4:	69fa      	ldr	r2, [r7, #28]
 80134e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134e8:	429a      	cmp	r2, r3
 80134ea:	dbe1      	blt.n	80134b0 <GetASN_StoreData+0x8c>
            }
            break;
 80134ec:	e108      	b.n	8013700 <GetASN_StoreData+0x2dc>
        case ASN_DATA_TYPE_WORD32:
            /* Check data is small enough to fit. */
            if (len == 0 || len > 4) {
 80134ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134f0:	2b00      	cmp	r3, #0
 80134f2:	d002      	beq.n	80134fa <GetASN_StoreData+0xd6>
 80134f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80134f6:	2b04      	cmp	r3, #4
 80134f8:	dd02      	ble.n	8013500 <GetASN_StoreData+0xdc>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Expecting 1 to 4 bytes: %d", len);
            #endif
                return ASN_PARSE_E;
 80134fa:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80134fe:	e100      	b.n	8013702 <GetASN_StoreData+0x2de>
            }
            /* Fill number with all of data. */
            *data->data.u32 = 0;
 8013500:	68bb      	ldr	r3, [r7, #8]
 8013502:	689b      	ldr	r3, [r3, #8]
 8013504:	2200      	movs	r2, #0
 8013506:	601a      	str	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 8013508:	2300      	movs	r3, #0
 801350a:	61fb      	str	r3, [r7, #28]
 801350c:	e017      	b.n	801353e <GetASN_StoreData+0x11a>
                *data->data.u32 <<= 8;
 801350e:	68bb      	ldr	r3, [r7, #8]
 8013510:	689b      	ldr	r3, [r3, #8]
 8013512:	681a      	ldr	r2, [r3, #0]
 8013514:	68bb      	ldr	r3, [r7, #8]
 8013516:	689b      	ldr	r3, [r3, #8]
 8013518:	0212      	lsls	r2, r2, #8
 801351a:	601a      	str	r2, [r3, #0]
                *data->data.u32 |= input[idx + (word32)i] ;
 801351c:	68bb      	ldr	r3, [r7, #8]
 801351e:	689b      	ldr	r3, [r3, #8]
 8013520:	681a      	ldr	r2, [r3, #0]
 8013522:	69f9      	ldr	r1, [r7, #28]
 8013524:	683b      	ldr	r3, [r7, #0]
 8013526:	440b      	add	r3, r1
 8013528:	6879      	ldr	r1, [r7, #4]
 801352a:	440b      	add	r3, r1
 801352c:	781b      	ldrb	r3, [r3, #0]
 801352e:	4619      	mov	r1, r3
 8013530:	68bb      	ldr	r3, [r7, #8]
 8013532:	689b      	ldr	r3, [r3, #8]
 8013534:	430a      	orrs	r2, r1
 8013536:	601a      	str	r2, [r3, #0]
            for (i = 0; i < len; i++) {
 8013538:	69fb      	ldr	r3, [r7, #28]
 801353a:	3301      	adds	r3, #1
 801353c:	61fb      	str	r3, [r7, #28]
 801353e:	69fa      	ldr	r2, [r7, #28]
 8013540:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013542:	429a      	cmp	r2, r3
 8013544:	dbe3      	blt.n	801350e <GetASN_StoreData+0xea>
            }
            break;
 8013546:	e0db      	b.n	8013700 <GetASN_StoreData+0x2dc>

        case ASN_DATA_TYPE_BUFFER:
            /* Check buffer is big enough to hold data. */
            if (len > (int)*data->data.buffer.length) {
 8013548:	68bb      	ldr	r3, [r7, #8]
 801354a:	68db      	ldr	r3, [r3, #12]
 801354c:	681b      	ldr	r3, [r3, #0]
 801354e:	461a      	mov	r2, r3
 8013550:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013552:	4293      	cmp	r3, r2
 8013554:	dd02      	ble.n	801355c <GetASN_StoreData+0x138>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Buffer too small for data: %d %d", len,
                        *data->data.buffer.length);
            #endif
                return ASN_PARSE_E;
 8013556:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801355a:	e0d2      	b.n	8013702 <GetASN_StoreData+0x2de>
            }
            /* Copy in data and record actual length seen. */
            XMEMCPY(data->data.buffer.data, input + idx, (size_t)len);
 801355c:	68bb      	ldr	r3, [r7, #8]
 801355e:	6898      	ldr	r0, [r3, #8]
 8013560:	687a      	ldr	r2, [r7, #4]
 8013562:	683b      	ldr	r3, [r7, #0]
 8013564:	4413      	add	r3, r2
 8013566:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013568:	4619      	mov	r1, r3
 801356a:	f015 f81b 	bl	80285a4 <memcpy>
            *data->data.buffer.length = (word32)len;
 801356e:	68bb      	ldr	r3, [r7, #8]
 8013570:	68db      	ldr	r3, [r3, #12]
 8013572:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013574:	601a      	str	r2, [r3, #0]
            break;
 8013576:	e0c3      	b.n	8013700 <GetASN_StoreData+0x2dc>

        case ASN_DATA_TYPE_EXP_BUFFER:
            /* Check data is same size expected. */
            if (len != (int)data->data.ref.length) {
 8013578:	68bb      	ldr	r3, [r7, #8]
 801357a:	68db      	ldr	r3, [r3, #12]
 801357c:	461a      	mov	r2, r3
 801357e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013580:	4293      	cmp	r3, r2
 8013582:	d002      	beq.n	801358a <GetASN_StoreData+0x166>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Data not expected length: %d %d", len,
                        data->data.ref.length);
            #endif
                return ASN_PARSE_E;
 8013584:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013588:	e0bb      	b.n	8013702 <GetASN_StoreData+0x2de>
            }
            /* Check data is same as expected. */
            if (XMEMCMP(data->data.ref.data, input + idx, (size_t)len) != 0) {
 801358a:	68bb      	ldr	r3, [r7, #8]
 801358c:	6898      	ldr	r0, [r3, #8]
 801358e:	687a      	ldr	r2, [r7, #4]
 8013590:	683b      	ldr	r3, [r7, #0]
 8013592:	4413      	add	r3, r2
 8013594:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013596:	4619      	mov	r1, r3
 8013598:	f014 ff70 	bl	802847c <memcmp>
 801359c:	4603      	mov	r3, r0
 801359e:	2b00      	cmp	r3, #0
 80135a0:	f000 80a9 	beq.w	80136f6 <GetASN_StoreData+0x2d2>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Data not as expected");
            #endif
                return ASN_PARSE_E;
 80135a4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80135a8:	e0ab      	b.n	8013702 <GetASN_StoreData+0x2de>
            break;

        case ASN_DATA_TYPE_MP:
        case ASN_DATA_TYPE_MP_POS_NEG:
            /* Initialize mp_int and read in big-endian byte array. */
            if (mp_init(data->data.mp) != MP_OKAY) {
 80135aa:	68bb      	ldr	r3, [r7, #8]
 80135ac:	689b      	ldr	r3, [r3, #8]
 80135ae:	4618      	mov	r0, r3
 80135b0:	f013 f875 	bl	802669e <mp_init>
 80135b4:	4603      	mov	r3, r0
 80135b6:	2b00      	cmp	r3, #0
 80135b8:	d002      	beq.n	80135c0 <GetASN_StoreData+0x19c>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Failed to init mp: %p", data->data.mp);
            #endif
                return MP_INIT_E;
 80135ba:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 80135be:	e0a0      	b.n	8013702 <GetASN_StoreData+0x2de>
            }
            FALL_THROUGH;
        case ASN_DATA_TYPE_MP_INITED:
            err = mp_read_unsigned_bin(data->data.mp, (byte*)input + idx,
 80135c0:	68bb      	ldr	r3, [r7, #8]
 80135c2:	6898      	ldr	r0, [r3, #8]
 80135c4:	687a      	ldr	r2, [r7, #4]
 80135c6:	683b      	ldr	r3, [r7, #0]
 80135c8:	4413      	add	r3, r2
 80135ca:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80135cc:	4619      	mov	r1, r3
 80135ce:	f013 fa3f 	bl	8026a50 <mp_read_unsigned_bin>
 80135d2:	61b8      	str	r0, [r7, #24]
                                       (word32)len);
            if (err != 0) {
 80135d4:	69bb      	ldr	r3, [r7, #24]
 80135d6:	2b00      	cmp	r3, #0
 80135d8:	f000 808f 	beq.w	80136fa <GetASN_StoreData+0x2d6>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Failed to read mp: %d", err);
            #endif
                mp_clear(data->data.mp);
 80135dc:	68bb      	ldr	r3, [r7, #8]
 80135de:	689b      	ldr	r3, [r3, #8]
 80135e0:	4618      	mov	r0, r3
 80135e2:	f013 f8e6 	bl	80267b2 <mp_clear>
                return ASN_GETINT_E;
 80135e6:	f06f 038d 	mvn.w	r3, #141	@ 0x8d
 80135ea:	e08a      	b.n	8013702 <GetASN_StoreData+0x2de>
        #endif
            break;

        case ASN_DATA_TYPE_CHOICE:
            /* Check if tag matched any of the choices specified. */
            for (i = 0; data->data.choice[i] != 0; i++)
 80135ec:	2300      	movs	r3, #0
 80135ee:	61fb      	str	r3, [r7, #28]
 80135f0:	e00b      	b.n	801360a <GetASN_StoreData+0x1e6>
                if (data->data.choice[i] == data->tag)
 80135f2:	68bb      	ldr	r3, [r7, #8]
 80135f4:	689a      	ldr	r2, [r3, #8]
 80135f6:	69fb      	ldr	r3, [r7, #28]
 80135f8:	4413      	add	r3, r2
 80135fa:	781a      	ldrb	r2, [r3, #0]
 80135fc:	68bb      	ldr	r3, [r7, #8]
 80135fe:	7e5b      	ldrb	r3, [r3, #25]
 8013600:	429a      	cmp	r2, r3
 8013602:	d00a      	beq.n	801361a <GetASN_StoreData+0x1f6>
            for (i = 0; data->data.choice[i] != 0; i++)
 8013604:	69fb      	ldr	r3, [r7, #28]
 8013606:	3301      	adds	r3, #1
 8013608:	61fb      	str	r3, [r7, #28]
 801360a:	68bb      	ldr	r3, [r7, #8]
 801360c:	689a      	ldr	r2, [r3, #8]
 801360e:	69fb      	ldr	r3, [r7, #28]
 8013610:	4413      	add	r3, r2
 8013612:	781b      	ldrb	r3, [r3, #0]
 8013614:	2b00      	cmp	r3, #0
 8013616:	d1ec      	bne.n	80135f2 <GetASN_StoreData+0x1ce>
 8013618:	e000      	b.n	801361c <GetASN_StoreData+0x1f8>
                    break;
 801361a:	bf00      	nop
            if (data->data.choice[i] == 0) {
 801361c:	68bb      	ldr	r3, [r7, #8]
 801361e:	689a      	ldr	r2, [r3, #8]
 8013620:	69fb      	ldr	r3, [r7, #28]
 8013622:	4413      	add	r3, r2
 8013624:	781b      	ldrb	r3, [r3, #0]
 8013626:	2b00      	cmp	r3, #0
 8013628:	d102      	bne.n	8013630 <GetASN_StoreData+0x20c>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Tag didn't match a choice");
            #endif
                return ASN_PARSE_E;
 801362a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801362e:	e068      	b.n	8013702 <GetASN_StoreData+0x2de>
            }

            /* Store data pointer and length for caller. */
            data->data.ref.data = input + idx;
 8013630:	687a      	ldr	r2, [r7, #4]
 8013632:	683b      	ldr	r3, [r7, #0]
 8013634:	441a      	add	r2, r3
 8013636:	68bb      	ldr	r3, [r7, #8]
 8013638:	609a      	str	r2, [r3, #8]
            data->data.ref.length = (word32)len;
 801363a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801363c:	68bb      	ldr	r3, [r7, #8]
 801363e:	60da      	str	r2, [r3, #12]
            break;
 8013640:	e05e      	b.n	8013700 <GetASN_StoreData+0x2dc>

        case ASN_DATA_TYPE_NONE:
            /* Default behaviour based on tag. */
            if (asn->tag == ASN_BOOLEAN) {
 8013642:	68fb      	ldr	r3, [r7, #12]
 8013644:	785b      	ldrb	r3, [r3, #1]
 8013646:	2b01      	cmp	r3, #1
 8013648:	d119      	bne.n	801367e <GetASN_StoreData+0x25a>
                /* BOOLEAN has only one byte of data in BER. */
                if (len != 1) {
 801364a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801364c:	2b01      	cmp	r3, #1
 801364e:	d002      	beq.n	8013656 <GetASN_StoreData+0x232>
                #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                    WOLFSSL_MSG_VSNPRINTF("BOOLEAN length too long: %d", len);
                #endif
                    return ASN_PARSE_E;
 8013650:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013654:	e055      	b.n	8013702 <GetASN_StoreData+0x2de>
                }
                if (data->data.u8 == NULL)
 8013656:	68bb      	ldr	r3, [r7, #8]
 8013658:	689b      	ldr	r3, [r3, #8]
 801365a:	2b00      	cmp	r3, #0
 801365c:	d102      	bne.n	8013664 <GetASN_StoreData+0x240>
                    return BAD_STATE_E;
 801365e:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 8013662:	e04e      	b.n	8013702 <GetASN_StoreData+0x2de>
                /* Store C boolean value. */
                *data->data.u8 = (input[idx] != 0);
 8013664:	687a      	ldr	r2, [r7, #4]
 8013666:	683b      	ldr	r3, [r7, #0]
 8013668:	4413      	add	r3, r2
 801366a:	781b      	ldrb	r3, [r3, #0]
 801366c:	2b00      	cmp	r3, #0
 801366e:	bf14      	ite	ne
 8013670:	2301      	movne	r3, #1
 8013672:	2300      	moveq	r3, #0
 8013674:	b2da      	uxtb	r2, r3
 8013676:	68bb      	ldr	r3, [r7, #8]
 8013678:	689b      	ldr	r3, [r3, #8]
 801367a:	701a      	strb	r2, [r3, #0]
                break;
 801367c:	e040      	b.n	8013700 <GetASN_StoreData+0x2dc>
            }
            if (asn->tag == ASN_TAG_NULL) {
 801367e:	68fb      	ldr	r3, [r7, #12]
 8013680:	785b      	ldrb	r3, [r3, #1]
 8013682:	2b05      	cmp	r3, #5
 8013684:	d10b      	bne.n	801369e <GetASN_StoreData+0x27a>
                /* NULL has no data in BER. */
                if (len != 0) {
 8013686:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013688:	2b00      	cmp	r3, #0
 801368a:	d002      	beq.n	8013692 <GetASN_StoreData+0x26e>
                #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                    WOLFSSL_MSG_VSNPRINTF("NULL length too long: %d", len);
                #endif
                    return ASN_EXPECT_0_E;
 801368c:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 8013690:	e037      	b.n	8013702 <GetASN_StoreData+0x2de>
                }
                data->data.ref.data = input + idx;
 8013692:	687a      	ldr	r2, [r7, #4]
 8013694:	683b      	ldr	r3, [r7, #0]
 8013696:	441a      	add	r2, r3
 8013698:	68bb      	ldr	r3, [r7, #8]
 801369a:	609a      	str	r2, [r3, #8]
                break;
 801369c:	e030      	b.n	8013700 <GetASN_StoreData+0x2dc>
            }
            if (asn->tag == ASN_OBJECT_ID) {
 801369e:	68fb      	ldr	r3, [r7, #12]
 80136a0:	785b      	ldrb	r3, [r3, #1]
 80136a2:	2b06      	cmp	r3, #6
 80136a4:	d11e      	bne.n	80136e4 <GetASN_StoreData+0x2c0>
                word32 oidIdx = 0;
 80136a6:	2300      	movs	r3, #0
 80136a8:	617b      	str	r3, [r7, #20]
                /* Store OID data pointer and length */
                data->data.oid.data = input + idx;
 80136aa:	687a      	ldr	r2, [r7, #4]
 80136ac:	683b      	ldr	r3, [r7, #0]
 80136ae:	441a      	add	r2, r3
 80136b0:	68bb      	ldr	r3, [r7, #8]
 80136b2:	609a      	str	r2, [r3, #8]
                data->data.oid.length = (word32)len;
 80136b4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80136b6:	68bb      	ldr	r3, [r7, #8]
 80136b8:	60da      	str	r2, [r3, #12]
                /* Get the OID sum. */
                err = GetOID(input + idx, &oidIdx, &data->data.oid.sum,
 80136ba:	687a      	ldr	r2, [r7, #4]
 80136bc:	683b      	ldr	r3, [r7, #0]
 80136be:	18d0      	adds	r0, r2, r3
 80136c0:	68bb      	ldr	r3, [r7, #8]
 80136c2:	f103 0214 	add.w	r2, r3, #20
 80136c6:	68bb      	ldr	r3, [r7, #8]
 80136c8:	691c      	ldr	r4, [r3, #16]
 80136ca:	f107 0114 	add.w	r1, r7, #20
 80136ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80136d0:	9300      	str	r3, [sp, #0]
 80136d2:	4623      	mov	r3, r4
 80136d4:	f001 f812 	bl	80146fc <GetOID>
 80136d8:	61b8      	str	r0, [r7, #24]
                        data->data.oid.type, len);
                if (err < 0) {
 80136da:	69bb      	ldr	r3, [r7, #24]
 80136dc:	2b00      	cmp	r3, #0
 80136de:	da0e      	bge.n	80136fe <GetASN_StoreData+0x2da>
                #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                    WOLFSSL_MSG_VSNPRINTF("OID check failed: %d", err);
                #endif
                    return err;
 80136e0:	69bb      	ldr	r3, [r7, #24]
 80136e2:	e00e      	b.n	8013702 <GetASN_StoreData+0x2de>
                }
                break;
            }

            /* Otherwise store data pointer and length. */
            data->data.ref.data = input + idx;
 80136e4:	687a      	ldr	r2, [r7, #4]
 80136e6:	683b      	ldr	r3, [r7, #0]
 80136e8:	441a      	add	r2, r3
 80136ea:	68bb      	ldr	r3, [r7, #8]
 80136ec:	609a      	str	r2, [r3, #8]
            data->data.ref.length = (word32)len;
 80136ee:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80136f0:	68bb      	ldr	r3, [r7, #8]
 80136f2:	60da      	str	r2, [r3, #12]
            break;
 80136f4:	e004      	b.n	8013700 <GetASN_StoreData+0x2dc>
            break;
 80136f6:	bf00      	nop
 80136f8:	e002      	b.n	8013700 <GetASN_StoreData+0x2dc>
            break;
 80136fa:	bf00      	nop
 80136fc:	e000      	b.n	8013700 <GetASN_StoreData+0x2dc>
                break;
 80136fe:	bf00      	nop
        #endif
            return BAD_STATE_E;
    #endif
    }

    return 0;
 8013700:	2300      	movs	r3, #0
}
 8013702:	4618      	mov	r0, r3
 8013704:	3724      	adds	r7, #36	@ 0x24
 8013706:	46bd      	mov	sp, r7
 8013708:	bd90      	pop	{r4, r7, pc}
 801370a:	bf00      	nop

0801370c <GetASN_Items>:
 * @return  BAD_STATE_E when the data type is not supported.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int GetASN_Items(const ASNItem* asn, ASNGetData *data, int count, int complete,
                 const byte* input, word32* inOutIdx, word32 length)
{
 801370c:	b590      	push	{r4, r7, lr}
 801370e:	b09b      	sub	sp, #108	@ 0x6c
 8013710:	af02      	add	r7, sp, #8
 8013712:	60f8      	str	r0, [r7, #12]
 8013714:	60b9      	str	r1, [r7, #8]
 8013716:	607a      	str	r2, [r7, #4]
 8013718:	603b      	str	r3, [r7, #0]
    int    i;
    int    j;
    int    err;
    int    len;
    /* Current index into buffer. */
    word32 idx = *inOutIdx;
 801371a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801371c:	681b      	ldr	r3, [r3, #0]
 801371e:	633b      	str	r3, [r7, #48]	@ 0x30
    /* Declare the end index array. */
    word32 endIdx[GET_ASN_MAX_DEPTH];
    /* Set choices to -1 to indicate they haven't been seen or found. */
    signed char   choiceMet[GET_ASN_MAX_CHOICES] = { -1, -1 };
 8013720:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8013724:	823b      	strh	r3, [r7, #16]
    /* Not matching a choice right now. */
    int    choice = 0;
 8013726:	2300      	movs	r3, #0
 8013728:	657b      	str	r3, [r7, #84]	@ 0x54
#ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
    WOLFSSL_ENTER("GetASN_Items");
#endif

    /* Set the end index at each depth to be the length. */
    for (i=0; i<GET_ASN_MAX_DEPTH; i++) {
 801372a:	2300      	movs	r3, #0
 801372c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801372e:	e009      	b.n	8013744 <GetASN_Items+0x38>
        endIdx[i] = length;
 8013730:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013732:	009b      	lsls	r3, r3, #2
 8013734:	3360      	adds	r3, #96	@ 0x60
 8013736:	443b      	add	r3, r7
 8013738:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801373a:	f843 2c4c 	str.w	r2, [r3, #-76]
    for (i=0; i<GET_ASN_MAX_DEPTH; i++) {
 801373e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013740:	3301      	adds	r3, #1
 8013742:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8013744:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013746:	2b06      	cmp	r3, #6
 8013748:	ddf2      	ble.n	8013730 <GetASN_Items+0x24>
    }

    /* Start depth at first items depth. */
    minDepth = depth = asn[0].depth;
 801374a:	68fb      	ldr	r3, [r7, #12]
 801374c:	781b      	ldrb	r3, [r3, #0]
 801374e:	653b      	str	r3, [r7, #80]	@ 0x50
 8013750:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013752:	64fb      	str	r3, [r7, #76]	@ 0x4c
    /* Check every ASN.1 item. */
    for (i = 0; i < count; i++) {
 8013754:	2300      	movs	r3, #0
 8013756:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8013758:	e245      	b.n	8013be6 <GetASN_Items+0x4da>
        /* Store offset of ASN.1 item. */
        data[i].offset = idx;
 801375a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801375c:	4613      	mov	r3, r2
 801375e:	00db      	lsls	r3, r3, #3
 8013760:	1a9b      	subs	r3, r3, r2
 8013762:	009b      	lsls	r3, r3, #2
 8013764:	461a      	mov	r2, r3
 8013766:	68bb      	ldr	r3, [r7, #8]
 8013768:	4413      	add	r3, r2
 801376a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801376c:	601a      	str	r2, [r3, #0]
        /* Length of data in ASN.1 item starts empty. */
        data[i].length = 0;
 801376e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013770:	4613      	mov	r3, r2
 8013772:	00db      	lsls	r3, r3, #3
 8013774:	1a9b      	subs	r3, r3, r2
 8013776:	009b      	lsls	r3, r3, #2
 8013778:	461a      	mov	r2, r3
 801377a:	68bb      	ldr	r3, [r7, #8]
 801377c:	4413      	add	r3, r2
 801377e:	2200      	movs	r2, #0
 8013780:	605a      	str	r2, [r3, #4]
        /* Get current item depth. */
        depth = asn[i].depth;
 8013782:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013784:	009b      	lsls	r3, r3, #2
 8013786:	68fa      	ldr	r2, [r7, #12]
 8013788:	4413      	add	r3, r2
 801378a:	781b      	ldrb	r3, [r3, #0]
 801378c:	653b      	str	r3, [r7, #80]	@ 0x50
            WOLFSSL_MSG("Depth in template too large");
            return ASN_PARSE_E;
        }
    #endif
        /* Keep track of minimum depth. */
        if (depth < minDepth) {
 801378e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8013790:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8013792:	429a      	cmp	r2, r3
 8013794:	da01      	bge.n	801379a <GetASN_Items+0x8e>
            minDepth = depth;
 8013796:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013798:	64fb      	str	r3, [r7, #76]	@ 0x4c
        }

        /* Reset choice if different from previous. */
        if (choice > 0 && asn[i].optional != choice) {
 801379a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801379c:	2b00      	cmp	r3, #0
 801379e:	dd0a      	ble.n	80137b6 <GetASN_Items+0xaa>
 80137a0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80137a2:	009b      	lsls	r3, r3, #2
 80137a4:	68fa      	ldr	r2, [r7, #12]
 80137a6:	4413      	add	r3, r2
 80137a8:	78db      	ldrb	r3, [r3, #3]
 80137aa:	461a      	mov	r2, r3
 80137ac:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80137ae:	4293      	cmp	r3, r2
 80137b0:	d001      	beq.n	80137b6 <GetASN_Items+0xaa>
            choice = 0;
 80137b2:	2300      	movs	r3, #0
 80137b4:	657b      	str	r3, [r7, #84]	@ 0x54
        }
        /* Check if first of numbered choice. */
        if (choice == 0 && asn[i].optional > 1) {
 80137b6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80137b8:	2b00      	cmp	r3, #0
 80137ba:	d122      	bne.n	8013802 <GetASN_Items+0xf6>
 80137bc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80137be:	009b      	lsls	r3, r3, #2
 80137c0:	68fa      	ldr	r2, [r7, #12]
 80137c2:	4413      	add	r3, r2
 80137c4:	78db      	ldrb	r3, [r3, #3]
 80137c6:	2b01      	cmp	r3, #1
 80137c8:	d91b      	bls.n	8013802 <GetASN_Items+0xf6>
            choice = asn[i].optional;
 80137ca:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80137cc:	009b      	lsls	r3, r3, #2
 80137ce:	68fa      	ldr	r2, [r7, #12]
 80137d0:	4413      	add	r3, r2
 80137d2:	78db      	ldrb	r3, [r3, #3]
 80137d4:	657b      	str	r3, [r7, #84]	@ 0x54
            tmpScharVal = choiceMet[choice - 2];
 80137d6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80137d8:	3b02      	subs	r3, #2
 80137da:	3360      	adds	r3, #96	@ 0x60
 80137dc:	443b      	add	r3, r7
 80137de:	f813 3c50 	ldrb.w	r3, [r3, #-80]
 80137e2:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
            XFENCE(); /* Prevent memory access */
 80137e6:	f3bf 8f5b 	dmb	ish
            if (tmpScharVal == -1) {
 80137ea:	f997 3047 	ldrsb.w	r3, [r7, #71]	@ 0x47
 80137ee:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80137f2:	d106      	bne.n	8013802 <GetASN_Items+0xf6>
                /* Choice seen but not found a match yet. */
                choiceMet[choice - 2] = 0;
 80137f4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80137f6:	3b02      	subs	r3, #2
 80137f8:	3360      	adds	r3, #96	@ 0x60
 80137fa:	443b      	add	r3, r7
 80137fc:	2200      	movs	r2, #0
 80137fe:	f803 2c50 	strb.w	r2, [r3, #-80]
            }
        }

        /* Check for end of data or not a choice and tag not matching. */
        tmpW32Val = endIdx[depth];
 8013802:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013804:	009b      	lsls	r3, r3, #2
 8013806:	3360      	adds	r3, #96	@ 0x60
 8013808:	443b      	add	r3, r7
 801380a:	f853 3c4c 	ldr.w	r3, [r3, #-76]
 801380e:	643b      	str	r3, [r7, #64]	@ 0x40
        XFENCE(); /* Prevent memory access */
 8013810:	f3bf 8f5b 	dmb	ish
        if (idx == tmpW32Val || (data[i].dataType != ASN_DATA_TYPE_CHOICE &&
 8013814:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013816:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8013818:	429a      	cmp	r2, r3
 801381a:	d017      	beq.n	801384c <GetASN_Items+0x140>
 801381c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801381e:	4613      	mov	r3, r2
 8013820:	00db      	lsls	r3, r3, #3
 8013822:	1a9b      	subs	r3, r3, r2
 8013824:	009b      	lsls	r3, r3, #2
 8013826:	461a      	mov	r2, r3
 8013828:	68bb      	ldr	r3, [r7, #8]
 801382a:	4413      	add	r3, r2
 801382c:	7e1b      	ldrb	r3, [r3, #24]
 801382e:	2b0b      	cmp	r3, #11
 8013830:	d06e      	beq.n	8013910 <GetASN_Items+0x204>
                              (input[idx] & ~ASN_CONSTRUCTED) != asn[i].tag)) {
 8013832:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013834:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013836:	4413      	add	r3, r2
 8013838:	781b      	ldrb	r3, [r3, #0]
 801383a:	f023 0320 	bic.w	r3, r3, #32
 801383e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013840:	0092      	lsls	r2, r2, #2
 8013842:	68f9      	ldr	r1, [r7, #12]
 8013844:	440a      	add	r2, r1
 8013846:	7852      	ldrb	r2, [r2, #1]
        if (idx == tmpW32Val || (data[i].dataType != ASN_DATA_TYPE_CHOICE &&
 8013848:	4293      	cmp	r3, r2
 801384a:	d061      	beq.n	8013910 <GetASN_Items+0x204>
            if (asn[i].optional) {
 801384c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801384e:	009b      	lsls	r3, r3, #2
 8013850:	68fa      	ldr	r2, [r7, #12]
 8013852:	4413      	add	r3, r2
 8013854:	78db      	ldrb	r3, [r3, #3]
 8013856:	2b00      	cmp	r3, #0
 8013858:	d030      	beq.n	80138bc <GetASN_Items+0x1b0>
                /* Skip over ASN.1 items underneath this optional item. */
                for (j = i + 1; j < count; j++) {
 801385a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801385c:	3301      	adds	r3, #1
 801385e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013860:	e022      	b.n	80138a8 <GetASN_Items+0x19c>
                    if (asn[i].depth >= asn[j].depth)
 8013862:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013864:	009b      	lsls	r3, r3, #2
 8013866:	68fa      	ldr	r2, [r7, #12]
 8013868:	4413      	add	r3, r2
 801386a:	781a      	ldrb	r2, [r3, #0]
 801386c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801386e:	009b      	lsls	r3, r3, #2
 8013870:	68f9      	ldr	r1, [r7, #12]
 8013872:	440b      	add	r3, r1
 8013874:	781b      	ldrb	r3, [r3, #0]
 8013876:	429a      	cmp	r2, r3
 8013878:	d21b      	bcs.n	80138b2 <GetASN_Items+0x1a6>
                        break;
                    data[j].offset = idx;
 801387a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801387c:	4613      	mov	r3, r2
 801387e:	00db      	lsls	r3, r3, #3
 8013880:	1a9b      	subs	r3, r3, r2
 8013882:	009b      	lsls	r3, r3, #2
 8013884:	461a      	mov	r2, r3
 8013886:	68bb      	ldr	r3, [r7, #8]
 8013888:	4413      	add	r3, r2
 801388a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801388c:	601a      	str	r2, [r3, #0]
                    data[j].length = 0;
 801388e:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8013890:	4613      	mov	r3, r2
 8013892:	00db      	lsls	r3, r3, #3
 8013894:	1a9b      	subs	r3, r3, r2
 8013896:	009b      	lsls	r3, r3, #2
 8013898:	461a      	mov	r2, r3
 801389a:	68bb      	ldr	r3, [r7, #8]
 801389c:	4413      	add	r3, r2
 801389e:	2200      	movs	r2, #0
 80138a0:	605a      	str	r2, [r3, #4]
                for (j = i + 1; j < count; j++) {
 80138a2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80138a4:	3301      	adds	r3, #1
 80138a6:	65bb      	str	r3, [r7, #88]	@ 0x58
 80138a8:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80138aa:	687b      	ldr	r3, [r7, #4]
 80138ac:	429a      	cmp	r2, r3
 80138ae:	dbd8      	blt.n	8013862 <GetASN_Items+0x156>
 80138b0:	e000      	b.n	80138b4 <GetASN_Items+0x1a8>
                        break;
 80138b2:	bf00      	nop
                }
                i = j - 1;
 80138b4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80138b6:	3b01      	subs	r3, #1
 80138b8:	65fb      	str	r3, [r7, #92]	@ 0x5c
                continue;
 80138ba:	e191      	b.n	8013be0 <GetASN_Items+0x4d4>
            }

            /* Check for end of data. */
            if (idx == length) {
 80138bc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80138be:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 80138c0:	429a      	cmp	r2, r3
 80138c2:	d102      	bne.n	80138ca <GetASN_Items+0x1be>
                    asn[i].constructed ? '+' : ' ', asn[i].depth, "",
                    TagString(asn[i].tag), 6 - asn[i].depth, "");
                WOLFSSL_MSG_VSNPRINTF("Index past end of data: %d %d", idx,
                        length);
        #endif
                return BUFFER_E;
 80138c4:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80138c8:	e1c3      	b.n	8013c52 <GetASN_Items+0x546>
                asn[i].constructed ? '+' : ' ', asn[i].depth, "",
                TagString(asn[i].tag), 6 - asn[i].depth, "",
                input[idx], TagString(input[idx]));
        #endif
            /* Check for end of data at this depth. */
            if (idx == endIdx[depth]) {
 80138ca:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80138cc:	009b      	lsls	r3, r3, #2
 80138ce:	3360      	adds	r3, #96	@ 0x60
 80138d0:	443b      	add	r3, r7
 80138d2:	f853 2c4c 	ldr.w	r2, [r3, #-76]
 80138d6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80138d8:	429a      	cmp	r2, r3
 80138da:	d102      	bne.n	80138e2 <GetASN_Items+0x1d6>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF("Index past outer item: %d %d", idx,
                        endIdx[depth]);
            #endif
                return ASN_PARSE_E;
 80138dc:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80138e0:	e1b7      	b.n	8013c52 <GetASN_Items+0x546>
            }

            /* Expecting an OBJECT_ID */
            if (asn[i].tag == ASN_OBJECT_ID) {
 80138e2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80138e4:	009b      	lsls	r3, r3, #2
 80138e6:	68fa      	ldr	r2, [r7, #12]
 80138e8:	4413      	add	r3, r2
 80138ea:	785b      	ldrb	r3, [r3, #1]
 80138ec:	2b06      	cmp	r3, #6
 80138ee:	d102      	bne.n	80138f6 <GetASN_Items+0x1ea>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Expecting OBJECT ID");
            #endif
                return ASN_OBJECT_ID_E;
 80138f0:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 80138f4:	e1ad      	b.n	8013c52 <GetASN_Items+0x546>
            }
            /* Expecting a BIT_STRING */
            if (asn[i].tag == ASN_BIT_STRING) {
 80138f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80138f8:	009b      	lsls	r3, r3, #2
 80138fa:	68fa      	ldr	r2, [r7, #12]
 80138fc:	4413      	add	r3, r2
 80138fe:	785b      	ldrb	r3, [r3, #1]
 8013900:	2b03      	cmp	r3, #3
 8013902:	d102      	bne.n	801390a <GetASN_Items+0x1fe>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG("Expecting BIT STRING");
            #endif
                return ASN_BITSTR_E;
 8013904:	f06f 0392 	mvn.w	r3, #146	@ 0x92
 8013908:	e1a3      	b.n	8013c52 <GetASN_Items+0x546>
            }
            /* Not the expected tag. */
        #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
            WOLFSSL_MSG("Bad tag");
        #endif
            return ASN_PARSE_E;
 801390a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801390e:	e1a0      	b.n	8013c52 <GetASN_Items+0x546>
        }

        /* Store found tag in data. */
        data[i].tag = input[idx];
 8013910:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013912:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013914:	18d1      	adds	r1, r2, r3
 8013916:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013918:	4613      	mov	r3, r2
 801391a:	00db      	lsls	r3, r3, #3
 801391c:	1a9b      	subs	r3, r3, r2
 801391e:	009b      	lsls	r3, r3, #2
 8013920:	461a      	mov	r2, r3
 8013922:	68bb      	ldr	r3, [r7, #8]
 8013924:	4413      	add	r3, r2
 8013926:	780a      	ldrb	r2, [r1, #0]
 8013928:	765a      	strb	r2, [r3, #25]
        XFENCE(); /* Prevent memory access */
 801392a:	f3bf 8f5b 	dmb	ish
        if (data[i].dataType != ASN_DATA_TYPE_CHOICE) {
 801392e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013930:	4613      	mov	r3, r2
 8013932:	00db      	lsls	r3, r3, #3
 8013934:	1a9b      	subs	r3, r3, r2
 8013936:	009b      	lsls	r3, r3, #2
 8013938:	461a      	mov	r2, r3
 801393a:	68bb      	ldr	r3, [r7, #8]
 801393c:	4413      	add	r3, r2
 801393e:	7e1b      	ldrb	r3, [r3, #24]
 8013940:	2b0b      	cmp	r3, #11
 8013942:	d01a      	beq.n	801397a <GetASN_Items+0x26e>
            int constructed = (input[idx] & ASN_CONSTRUCTED) == ASN_CONSTRUCTED;
 8013944:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013946:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013948:	4413      	add	r3, r2
 801394a:	781b      	ldrb	r3, [r3, #0]
 801394c:	f003 0320 	and.w	r3, r3, #32
 8013950:	2b00      	cmp	r3, #0
 8013952:	bf14      	ite	ne
 8013954:	2301      	movne	r3, #1
 8013956:	2300      	moveq	r3, #0
 8013958:	b2db      	uxtb	r3, r3
 801395a:	63fb      	str	r3, [r7, #60]	@ 0x3c
            /* Check constructed match expected for non-choice ASN.1 item. */
            if (asn[i].constructed != constructed) {
 801395c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801395e:	009b      	lsls	r3, r3, #2
 8013960:	68fa      	ldr	r2, [r7, #12]
 8013962:	4413      	add	r3, r2
 8013964:	789b      	ldrb	r3, [r3, #2]
 8013966:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801396a:	b2db      	uxtb	r3, r3
 801396c:	461a      	mov	r2, r3
 801396e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8013970:	4293      	cmp	r3, r2
 8013972:	d002      	beq.n	801397a <GetASN_Items+0x26e>
                }
                else {
                    WOLFSSL_MSG("Not expected to be constructed");
                }
            #endif
                return ASN_PARSE_E;
 8013974:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013978:	e16b      	b.n	8013c52 <GetASN_Items+0x546>
            }
        }
        /* Move index to start of length. */
        idx++;
 801397a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801397c:	3301      	adds	r3, #1
 801397e:	633b      	str	r3, [r7, #48]	@ 0x30
        /* Get the encoded length. */
        if (GetASN_Length(input, &idx, &len, endIdx[depth], 1) < 0) {
 8013980:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013982:	009b      	lsls	r3, r3, #2
 8013984:	3360      	adds	r3, #96	@ 0x60
 8013986:	443b      	add	r3, r7
 8013988:	f853 3c4c 	ldr.w	r3, [r3, #-76]
 801398c:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 8013990:	f107 0130 	add.w	r1, r7, #48	@ 0x30
 8013994:	2001      	movs	r0, #1
 8013996:	9000      	str	r0, [sp, #0]
 8013998:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801399a:	f000 f9c2 	bl	8013d22 <GetLength_ex>
 801399e:	4603      	mov	r3, r0
 80139a0:	2b00      	cmp	r3, #0
 80139a2:	da02      	bge.n	80139aa <GetASN_Items+0x29e>
        #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
            WOLFSSL_MSG_VSNPRINTF("%2d: idx=%d len=%d end=%d", i, idx, len,
                    endIdx[depth]);
        #endif
            return ASN_PARSE_E;
 80139a4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80139a8:	e153      	b.n	8013c52 <GetASN_Items+0x546>
        }
        /* Store length of data. */
        data[i].length = (word32)len;
 80139aa:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80139ac:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80139ae:	4613      	mov	r3, r2
 80139b0:	00db      	lsls	r3, r3, #3
 80139b2:	1a9b      	subs	r3, r3, r2
 80139b4:	009b      	lsls	r3, r3, #2
 80139b6:	461a      	mov	r2, r3
 80139b8:	68bb      	ldr	r3, [r7, #8]
 80139ba:	4413      	add	r3, r2
 80139bc:	460a      	mov	r2, r1
 80139be:	605a      	str	r2, [r3, #4]
        /* Note the max length of items under this one. */
        endIdx[depth + 1] = idx + (word32)len;
 80139c0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80139c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80139c4:	4619      	mov	r1, r3
 80139c6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80139c8:	3301      	adds	r3, #1
 80139ca:	440a      	add	r2, r1
 80139cc:	009b      	lsls	r3, r3, #2
 80139ce:	3360      	adds	r3, #96	@ 0x60
 80139d0:	443b      	add	r3, r7
 80139d2:	f843 2c4c 	str.w	r2, [r3, #-76]
        if (choice > 1) {
 80139d6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80139d8:	2b01      	cmp	r3, #1
 80139da:	dd06      	ble.n	80139ea <GetASN_Items+0x2de>
            /* Note we found a number choice. */
            choiceMet[choice - 2] = 1;
 80139dc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80139de:	3b02      	subs	r3, #2
 80139e0:	3360      	adds	r3, #96	@ 0x60
 80139e2:	443b      	add	r3, r7
 80139e4:	2201      	movs	r2, #1
 80139e6:	f803 2c50 	strb.w	r2, [r3, #-80]
                data[i].offset, data[i].length, asn[i].constructed ? '+' : ' ',
                asn[i].depth, "", TagString(data[i].tag));
    #endif

        /* Assume no zero padding on INTEGER. */
        zeroPadded = 0;
 80139ea:	2300      	movs	r3, #0
 80139ec:	64bb      	str	r3, [r7, #72]	@ 0x48
        /* Check data types that prepended a byte. */
        if (asn[i].tag == ASN_INTEGER) {
 80139ee:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80139f0:	009b      	lsls	r3, r3, #2
 80139f2:	68fa      	ldr	r2, [r7, #12]
 80139f4:	4413      	add	r3, r2
 80139f6:	785b      	ldrb	r3, [r3, #1]
 80139f8:	2b02      	cmp	r3, #2
 80139fa:	d136      	bne.n	8013a6a <GetASN_Items+0x35e>
            /* Check validity of first byte. */
            err = GetASN_Integer(input, idx, len,
 80139fc:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80139fe:	6b78      	ldr	r0, [r7, #52]	@ 0x34
                    data[i].dataType == ASN_DATA_TYPE_MP ||
 8013a00:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013a02:	4613      	mov	r3, r2
 8013a04:	00db      	lsls	r3, r3, #3
 8013a06:	1a9b      	subs	r3, r3, r2
 8013a08:	009b      	lsls	r3, r3, #2
 8013a0a:	461a      	mov	r2, r3
 8013a0c:	68bb      	ldr	r3, [r7, #8]
 8013a0e:	4413      	add	r3, r2
 8013a10:	7e1b      	ldrb	r3, [r3, #24]
            err = GetASN_Integer(input, idx, len,
 8013a12:	2b08      	cmp	r3, #8
 8013a14:	d00a      	beq.n	8013a2c <GetASN_Items+0x320>
                    data[i].dataType == ASN_DATA_TYPE_MP_INITED);
 8013a16:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013a18:	4613      	mov	r3, r2
 8013a1a:	00db      	lsls	r3, r3, #3
 8013a1c:	1a9b      	subs	r3, r3, r2
 8013a1e:	009b      	lsls	r3, r3, #2
 8013a20:	461a      	mov	r2, r3
 8013a22:	68bb      	ldr	r3, [r7, #8]
 8013a24:	4413      	add	r3, r2
 8013a26:	7e1b      	ldrb	r3, [r3, #24]
            err = GetASN_Integer(input, idx, len,
 8013a28:	2b09      	cmp	r3, #9
 8013a2a:	d101      	bne.n	8013a30 <GetASN_Items+0x324>
 8013a2c:	2301      	movs	r3, #1
 8013a2e:	e000      	b.n	8013a32 <GetASN_Items+0x326>
 8013a30:	2300      	movs	r3, #0
 8013a32:	4602      	mov	r2, r0
 8013a34:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013a36:	f7ff fbe5 	bl	8013204 <GetASN_Integer>
 8013a3a:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013a3c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013a3e:	2b00      	cmp	r3, #0
 8013a40:	d001      	beq.n	8013a46 <GetASN_Items+0x33a>
                return err;
 8013a42:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013a44:	e105      	b.n	8013c52 <GetASN_Items+0x546>
            if (len > 1 && input[idx] == 0) {
 8013a46:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013a48:	2b01      	cmp	r3, #1
 8013a4a:	dd59      	ble.n	8013b00 <GetASN_Items+0x3f4>
 8013a4c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a4e:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013a50:	4413      	add	r3, r2
 8013a52:	781b      	ldrb	r3, [r3, #0]
 8013a54:	2b00      	cmp	r3, #0
 8013a56:	d153      	bne.n	8013b00 <GetASN_Items+0x3f4>
                zeroPadded = 1;
 8013a58:	2301      	movs	r3, #1
 8013a5a:	64bb      	str	r3, [r7, #72]	@ 0x48
                /* Move over prepended byte. */
                idx++;
 8013a5c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a5e:	3301      	adds	r3, #1
 8013a60:	633b      	str	r3, [r7, #48]	@ 0x30
                len--;
 8013a62:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013a64:	3b01      	subs	r3, #1
 8013a66:	637b      	str	r3, [r7, #52]	@ 0x34
 8013a68:	e04a      	b.n	8013b00 <GetASN_Items+0x3f4>
            }
        }
        else if (asn[i].tag == ASN_BIT_STRING) {
 8013a6a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013a6c:	009b      	lsls	r3, r3, #2
 8013a6e:	68fa      	ldr	r2, [r7, #12]
 8013a70:	4413      	add	r3, r2
 8013a72:	785b      	ldrb	r3, [r3, #1]
 8013a74:	2b03      	cmp	r3, #3
 8013a76:	d112      	bne.n	8013a9e <GetASN_Items+0x392>
            /* Check prepended byte is correct. */
            err = GetASN_BitString(input, idx, len);
 8013a78:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a7a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013a7c:	4619      	mov	r1, r3
 8013a7e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013a80:	f7ff fc09 	bl	8013296 <GetASN_BitString>
 8013a84:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013a86:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013a88:	2b00      	cmp	r3, #0
 8013a8a:	d001      	beq.n	8013a90 <GetASN_Items+0x384>
                return err;
 8013a8c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013a8e:	e0e0      	b.n	8013c52 <GetASN_Items+0x546>
            /* Move over prepended byte. */
            idx++;
 8013a90:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013a92:	3301      	adds	r3, #1
 8013a94:	633b      	str	r3, [r7, #48]	@ 0x30
            len--;
 8013a96:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013a98:	3b01      	subs	r3, #1
 8013a9a:	637b      	str	r3, [r7, #52]	@ 0x34
 8013a9c:	e030      	b.n	8013b00 <GetASN_Items+0x3f4>
        }
    #ifndef WOLFSSL_NO_ASN_STRICT
        else if ((asn[i].tag == ASN_UTF8STRING) ||
 8013a9e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013aa0:	009b      	lsls	r3, r3, #2
 8013aa2:	68fa      	ldr	r2, [r7, #12]
 8013aa4:	4413      	add	r3, r2
 8013aa6:	785b      	ldrb	r3, [r3, #1]
 8013aa8:	2b0c      	cmp	r3, #12
 8013aaa:	d00a      	beq.n	8013ac2 <GetASN_Items+0x3b6>
                 (data[i].tag == ASN_UTF8STRING)) {
 8013aac:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013aae:	4613      	mov	r3, r2
 8013ab0:	00db      	lsls	r3, r3, #3
 8013ab2:	1a9b      	subs	r3, r3, r2
 8013ab4:	009b      	lsls	r3, r3, #2
 8013ab6:	461a      	mov	r2, r3
 8013ab8:	68bb      	ldr	r3, [r7, #8]
 8013aba:	4413      	add	r3, r2
 8013abc:	7e5b      	ldrb	r3, [r3, #25]
        else if ((asn[i].tag == ASN_UTF8STRING) ||
 8013abe:	2b0c      	cmp	r3, #12
 8013ac0:	d10b      	bne.n	8013ada <GetASN_Items+0x3ce>
            /* Check validity of data. */
            err = GetASN_UTF8String(input, idx, len);
 8013ac2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013ac4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013ac6:	4619      	mov	r1, r3
 8013ac8:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013aca:	f7ff fc16 	bl	80132fa <GetASN_UTF8String>
 8013ace:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013ad0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013ad2:	2b00      	cmp	r3, #0
 8013ad4:	d014      	beq.n	8013b00 <GetASN_Items+0x3f4>
                return err;
 8013ad6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013ad8:	e0bb      	b.n	8013c52 <GetASN_Items+0x546>
        }
    #endif
        else if (asn[i].tag == ASN_OBJECT_ID) {
 8013ada:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013adc:	009b      	lsls	r3, r3, #2
 8013ade:	68fa      	ldr	r2, [r7, #12]
 8013ae0:	4413      	add	r3, r2
 8013ae2:	785b      	ldrb	r3, [r3, #1]
 8013ae4:	2b06      	cmp	r3, #6
 8013ae6:	d10b      	bne.n	8013b00 <GetASN_Items+0x3f4>
            /* Check validity of data. */
            err = GetASN_ObjectId(input, idx, len);
 8013ae8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013aea:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013aec:	4619      	mov	r1, r3
 8013aee:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8013af0:	f7ff fc75 	bl	80133de <GetASN_ObjectId>
 8013af4:	63b8      	str	r0, [r7, #56]	@ 0x38
            if (err != 0)
 8013af6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013af8:	2b00      	cmp	r3, #0
 8013afa:	d001      	beq.n	8013b00 <GetASN_Items+0x3f4>
                return err;
 8013afc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013afe:	e0a8      	b.n	8013c52 <GetASN_Items+0x546>
        }

        /* Don't parse data if only header required. */
        if (asn[i].headerOnly) {
 8013b00:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013b02:	009b      	lsls	r3, r3, #2
 8013b04:	68fa      	ldr	r2, [r7, #12]
 8013b06:	4413      	add	r3, r2
 8013b08:	789b      	ldrb	r3, [r3, #2]
 8013b0a:	f003 0302 	and.w	r3, r3, #2
 8013b0e:	b2db      	uxtb	r3, r3
 8013b10:	2b00      	cmp	r3, #0
 8013b12:	d017      	beq.n	8013b44 <GetASN_Items+0x438>
            /* Store reference to data and length. */
            data[i].data.ref.data = input + idx;
 8013b14:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8013b16:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013b18:	4613      	mov	r3, r2
 8013b1a:	00db      	lsls	r3, r3, #3
 8013b1c:	1a9b      	subs	r3, r3, r2
 8013b1e:	009b      	lsls	r3, r3, #2
 8013b20:	461a      	mov	r2, r3
 8013b22:	68bb      	ldr	r3, [r7, #8]
 8013b24:	4413      	add	r3, r2
 8013b26:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013b28:	440a      	add	r2, r1
 8013b2a:	609a      	str	r2, [r3, #8]
            data[i].data.ref.length = (word32)len;
 8013b2c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8013b2e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013b30:	4613      	mov	r3, r2
 8013b32:	00db      	lsls	r3, r3, #3
 8013b34:	1a9b      	subs	r3, r3, r2
 8013b36:	009b      	lsls	r3, r3, #2
 8013b38:	461a      	mov	r2, r3
 8013b3a:	68bb      	ldr	r3, [r7, #8]
 8013b3c:	4413      	add	r3, r2
 8013b3e:	460a      	mov	r2, r1
 8013b40:	60da      	str	r2, [r3, #12]
            continue;
 8013b42:	e04d      	b.n	8013be0 <GetASN_Items+0x4d4>
        }

        /* Store the data at idx in the ASN data item. */
        err = GetASN_StoreData(&asn[i], &data[i], input, idx, len, zeroPadded);
 8013b44:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013b46:	009b      	lsls	r3, r3, #2
 8013b48:	68fa      	ldr	r2, [r7, #12]
 8013b4a:	18d0      	adds	r0, r2, r3
 8013b4c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013b4e:	4613      	mov	r3, r2
 8013b50:	00db      	lsls	r3, r3, #3
 8013b52:	1a9b      	subs	r3, r3, r2
 8013b54:	009b      	lsls	r3, r3, #2
 8013b56:	461a      	mov	r2, r3
 8013b58:	68bb      	ldr	r3, [r7, #8]
 8013b5a:	1899      	adds	r1, r3, r2
 8013b5c:	6b3c      	ldr	r4, [r7, #48]	@ 0x30
 8013b5e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013b60:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8013b62:	9201      	str	r2, [sp, #4]
 8013b64:	9300      	str	r3, [sp, #0]
 8013b66:	4623      	mov	r3, r4
 8013b68:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8013b6a:	f7ff fc5b 	bl	8013424 <GetASN_StoreData>
 8013b6e:	63b8      	str	r0, [r7, #56]	@ 0x38
        if (err != 0) {
 8013b70:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013b72:	2b00      	cmp	r3, #0
 8013b74:	d001      	beq.n	8013b7a <GetASN_Items+0x46e>
            return err;
 8013b76:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013b78:	e06b      	b.n	8013c52 <GetASN_Items+0x546>
        }

        /* Move index to next item. */
        idx += (word32)len;
 8013b7a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013b7c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013b7e:	4413      	add	r3, r2
 8013b80:	633b      	str	r3, [r7, #48]	@ 0x30

        /* When matched numbered choice ... */
        if (asn[i].optional > 1) {
 8013b82:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013b84:	009b      	lsls	r3, r3, #2
 8013b86:	68fa      	ldr	r2, [r7, #12]
 8013b88:	4413      	add	r3, r2
 8013b8a:	78db      	ldrb	r3, [r3, #3]
 8013b8c:	2b01      	cmp	r3, #1
 8013b8e:	d927      	bls.n	8013be0 <GetASN_Items+0x4d4>
            /* Skip over other ASN.1 items of the same number. */
            for (j = i + 1; j < count; j++) {
 8013b90:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013b92:	3301      	adds	r3, #1
 8013b94:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013b96:	e01a      	b.n	8013bce <GetASN_Items+0x4c2>
                if (asn[j].depth <= asn[i].depth &&
 8013b98:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013b9a:	009b      	lsls	r3, r3, #2
 8013b9c:	68fa      	ldr	r2, [r7, #12]
 8013b9e:	4413      	add	r3, r2
 8013ba0:	781a      	ldrb	r2, [r3, #0]
 8013ba2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013ba4:	009b      	lsls	r3, r3, #2
 8013ba6:	68f9      	ldr	r1, [r7, #12]
 8013ba8:	440b      	add	r3, r1
 8013baa:	781b      	ldrb	r3, [r3, #0]
 8013bac:	429a      	cmp	r2, r3
 8013bae:	d80b      	bhi.n	8013bc8 <GetASN_Items+0x4bc>
                                           asn[j].optional != asn[i].optional) {
 8013bb0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013bb2:	009b      	lsls	r3, r3, #2
 8013bb4:	68fa      	ldr	r2, [r7, #12]
 8013bb6:	4413      	add	r3, r2
 8013bb8:	78da      	ldrb	r2, [r3, #3]
 8013bba:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013bbc:	009b      	lsls	r3, r3, #2
 8013bbe:	68f9      	ldr	r1, [r7, #12]
 8013bc0:	440b      	add	r3, r1
 8013bc2:	78db      	ldrb	r3, [r3, #3]
                if (asn[j].depth <= asn[i].depth &&
 8013bc4:	429a      	cmp	r2, r3
 8013bc6:	d107      	bne.n	8013bd8 <GetASN_Items+0x4cc>
            for (j = i + 1; j < count; j++) {
 8013bc8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013bca:	3301      	adds	r3, #1
 8013bcc:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013bce:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8013bd0:	687b      	ldr	r3, [r7, #4]
 8013bd2:	429a      	cmp	r2, r3
 8013bd4:	dbe0      	blt.n	8013b98 <GetASN_Items+0x48c>
 8013bd6:	e000      	b.n	8013bda <GetASN_Items+0x4ce>
                   break;
 8013bd8:	bf00      	nop
                }
            }
            i = j - 1;
 8013bda:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013bdc:	3b01      	subs	r3, #1
 8013bde:	65fb      	str	r3, [r7, #92]	@ 0x5c
    for (i = 0; i < count; i++) {
 8013be0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8013be2:	3301      	adds	r3, #1
 8013be4:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8013be6:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8013be8:	687b      	ldr	r3, [r7, #4]
 8013bea:	429a      	cmp	r2, r3
 8013bec:	f6ff adb5 	blt.w	801375a <GetASN_Items+0x4e>
        }
    }

    if (complete) {
 8013bf0:	683b      	ldr	r3, [r7, #0]
 8013bf2:	2b00      	cmp	r3, #0
 8013bf4:	d015      	beq.n	8013c22 <GetASN_Items+0x516>
        /* When expecting ASN.1 items to completely use data, check we did. */
        for (j = depth; j > minDepth; j--) {
 8013bf6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8013bf8:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013bfa:	e00e      	b.n	8013c1a <GetASN_Items+0x50e>
            if (idx < endIdx[j]) {
 8013bfc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013bfe:	009b      	lsls	r3, r3, #2
 8013c00:	3360      	adds	r3, #96	@ 0x60
 8013c02:	443b      	add	r3, r7
 8013c04:	f853 2c4c 	ldr.w	r2, [r3, #-76]
 8013c08:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013c0a:	429a      	cmp	r2, r3
 8013c0c:	d902      	bls.n	8013c14 <GetASN_Items+0x508>
            #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                WOLFSSL_MSG_VSNPRINTF(
                    "More data in constructed item at depth: %d", j - 1);
            #endif
                return ASN_PARSE_E;
 8013c0e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013c12:	e01e      	b.n	8013c52 <GetASN_Items+0x546>
        for (j = depth; j > minDepth; j--) {
 8013c14:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013c16:	3b01      	subs	r3, #1
 8013c18:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013c1a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8013c1c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8013c1e:	429a      	cmp	r2, r3
 8013c20:	dcec      	bgt.n	8013bfc <GetASN_Items+0x4f0>
            }
        }
    }

    /* Check all choices where met - found an item for them. */
    for (j = 0; j < GET_ASN_MAX_CHOICES; j++) {
 8013c22:	2300      	movs	r3, #0
 8013c24:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013c26:	e00d      	b.n	8013c44 <GetASN_Items+0x538>
        if (choiceMet[j] == 0) {
 8013c28:	f107 0210 	add.w	r2, r7, #16
 8013c2c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013c2e:	4413      	add	r3, r2
 8013c30:	f993 3000 	ldrsb.w	r3, [r3]
 8013c34:	2b00      	cmp	r3, #0
 8013c36:	d102      	bne.n	8013c3e <GetASN_Items+0x532>
        #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
            WOLFSSL_MSG_VSNPRINTF("No choice seen: %d", j + 2);
        #endif
            return ASN_PARSE_E;
 8013c38:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013c3c:	e009      	b.n	8013c52 <GetASN_Items+0x546>
    for (j = 0; j < GET_ASN_MAX_CHOICES; j++) {
 8013c3e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013c40:	3301      	adds	r3, #1
 8013c42:	65bb      	str	r3, [r7, #88]	@ 0x58
 8013c44:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8013c46:	2b01      	cmp	r3, #1
 8013c48:	ddee      	ble.n	8013c28 <GetASN_Items+0x51c>
        }
    }

    /* Return index after ASN.1 data has been parsed. */
    *inOutIdx = idx;
 8013c4a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013c4c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8013c4e:	601a      	str	r2, [r3, #0]

    return 0;
 8013c50:	2300      	movs	r3, #0
}
 8013c52:	4618      	mov	r0, r3
 8013c54:	3764      	adds	r7, #100	@ 0x64
 8013c56:	46bd      	mov	sp, r7
 8013c58:	bd90      	pop	{r4, r7, pc}

08013c5a <GetASN_Sequence>:
 * @return  BUFFER_E when not enough data to complete decode.
 * @return  ASN_PARSE when decoding failed.
 */
static int GetASN_Sequence(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx, int complete)
{
 8013c5a:	b580      	push	{r7, lr}
 8013c5c:	b088      	sub	sp, #32
 8013c5e:	af02      	add	r7, sp, #8
 8013c60:	60f8      	str	r0, [r7, #12]
 8013c62:	60b9      	str	r1, [r7, #8]
 8013c64:	607a      	str	r2, [r7, #4]
 8013c66:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8013c68:	2300      	movs	r3, #0
 8013c6a:	617b      	str	r3, [r7, #20]
    word32 idx = *inOutIdx;
 8013c6c:	68bb      	ldr	r3, [r7, #8]
 8013c6e:	681b      	ldr	r3, [r3, #0]
 8013c70:	613b      	str	r3, [r7, #16]

    /* Check buffer big enough for tag. */
    if (idx + 1 > maxIdx) {
 8013c72:	693b      	ldr	r3, [r7, #16]
 8013c74:	3301      	adds	r3, #1
 8013c76:	683a      	ldr	r2, [r7, #0]
 8013c78:	429a      	cmp	r2, r3
 8013c7a:	d202      	bcs.n	8013c82 <GetASN_Sequence+0x28>
        ret = BUFFER_E;
 8013c7c:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013c80:	617b      	str	r3, [r7, #20]
    }
    /* Check it is a constructed SEQUENCE. */
    if ((ret == 0) && (input[idx++] != (ASN_SEQUENCE | ASN_CONSTRUCTED))) {
 8013c82:	697b      	ldr	r3, [r7, #20]
 8013c84:	2b00      	cmp	r3, #0
 8013c86:	d10a      	bne.n	8013c9e <GetASN_Sequence+0x44>
 8013c88:	693b      	ldr	r3, [r7, #16]
 8013c8a:	1c5a      	adds	r2, r3, #1
 8013c8c:	613a      	str	r2, [r7, #16]
 8013c8e:	68fa      	ldr	r2, [r7, #12]
 8013c90:	4413      	add	r3, r2
 8013c92:	781b      	ldrb	r3, [r3, #0]
 8013c94:	2b30      	cmp	r3, #48	@ 0x30
 8013c96:	d002      	beq.n	8013c9e <GetASN_Sequence+0x44>
        ret = ASN_PARSE_E;
 8013c98:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013c9c:	617b      	str	r3, [r7, #20]
    }
    /* Get the length. */
    if ((ret == 0) && (GetASN_Length(input, &idx, len, maxIdx, 1) < 0)) {
 8013c9e:	697b      	ldr	r3, [r7, #20]
 8013ca0:	2b00      	cmp	r3, #0
 8013ca2:	d10e      	bne.n	8013cc2 <GetASN_Sequence+0x68>
 8013ca4:	f107 0110 	add.w	r1, r7, #16
 8013ca8:	2301      	movs	r3, #1
 8013caa:	9300      	str	r3, [sp, #0]
 8013cac:	683b      	ldr	r3, [r7, #0]
 8013cae:	687a      	ldr	r2, [r7, #4]
 8013cb0:	68f8      	ldr	r0, [r7, #12]
 8013cb2:	f000 f836 	bl	8013d22 <GetLength_ex>
 8013cb6:	4603      	mov	r3, r0
 8013cb8:	2b00      	cmp	r3, #0
 8013cba:	da02      	bge.n	8013cc2 <GetASN_Sequence+0x68>
        ret = ASN_PARSE_E;
 8013cbc:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013cc0:	617b      	str	r3, [r7, #20]
    }
    /* Check all data used if complete set. */
    if ((ret == 0) && complete && (idx + (word32)*len != maxIdx)) {
 8013cc2:	697b      	ldr	r3, [r7, #20]
 8013cc4:	2b00      	cmp	r3, #0
 8013cc6:	d10d      	bne.n	8013ce4 <GetASN_Sequence+0x8a>
 8013cc8:	6a3b      	ldr	r3, [r7, #32]
 8013cca:	2b00      	cmp	r3, #0
 8013ccc:	d00a      	beq.n	8013ce4 <GetASN_Sequence+0x8a>
 8013cce:	687b      	ldr	r3, [r7, #4]
 8013cd0:	681b      	ldr	r3, [r3, #0]
 8013cd2:	461a      	mov	r2, r3
 8013cd4:	693b      	ldr	r3, [r7, #16]
 8013cd6:	4413      	add	r3, r2
 8013cd8:	683a      	ldr	r2, [r7, #0]
 8013cda:	429a      	cmp	r2, r3
 8013cdc:	d002      	beq.n	8013ce4 <GetASN_Sequence+0x8a>
        ret = ASN_PARSE_E;
 8013cde:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013ce2:	617b      	str	r3, [r7, #20]
    }
    if (ret == 0) {
 8013ce4:	697b      	ldr	r3, [r7, #20]
 8013ce6:	2b00      	cmp	r3, #0
 8013ce8:	d102      	bne.n	8013cf0 <GetASN_Sequence+0x96>
        /* Return index of next byte of encoded data. */
        *inOutIdx = idx;
 8013cea:	693a      	ldr	r2, [r7, #16]
 8013cec:	68bb      	ldr	r3, [r7, #8]
 8013cee:	601a      	str	r2, [r3, #0]
    }

    return ret;
 8013cf0:	697b      	ldr	r3, [r7, #20]
}
 8013cf2:	4618      	mov	r0, r3
 8013cf4:	3718      	adds	r7, #24
 8013cf6:	46bd      	mov	sp, r7
 8013cf8:	bd80      	pop	{r7, pc}

08013cfa <GetLength>:
 * @return  Length on success.
 * @return  ASN_PARSE_E if the encoding is invalid.
 * @return  BUFFER_E when not enough data to complete decode.
 */
int GetLength(const byte* input, word32* inOutIdx, int* len, word32 maxIdx)
{
 8013cfa:	b580      	push	{r7, lr}
 8013cfc:	b086      	sub	sp, #24
 8013cfe:	af02      	add	r7, sp, #8
 8013d00:	60f8      	str	r0, [r7, #12]
 8013d02:	60b9      	str	r1, [r7, #8]
 8013d04:	607a      	str	r2, [r7, #4]
 8013d06:	603b      	str	r3, [r7, #0]
    return GetLength_ex(input, inOutIdx, len, maxIdx, 1);
 8013d08:	2301      	movs	r3, #1
 8013d0a:	9300      	str	r3, [sp, #0]
 8013d0c:	683b      	ldr	r3, [r7, #0]
 8013d0e:	687a      	ldr	r2, [r7, #4]
 8013d10:	68b9      	ldr	r1, [r7, #8]
 8013d12:	68f8      	ldr	r0, [r7, #12]
 8013d14:	f000 f805 	bl	8013d22 <GetLength_ex>
 8013d18:	4603      	mov	r3, r0
}
 8013d1a:	4618      	mov	r0, r3
 8013d1c:	3710      	adds	r7, #16
 8013d1e:	46bd      	mov	sp, r7
 8013d20:	bd80      	pop	{r7, pc}

08013d22 <GetLength_ex>:
 * @return  ASN_PARSE_E if the encoding is invalid.
 * @return  BUFFER_E when not enough data to complete decode.
 */
int GetLength_ex(const byte* input, word32* inOutIdx, int* len, word32 maxIdx,
                 int check)
{
 8013d22:	b480      	push	{r7}
 8013d24:	b08b      	sub	sp, #44	@ 0x2c
 8013d26:	af00      	add	r7, sp, #0
 8013d28:	60f8      	str	r0, [r7, #12]
 8013d2a:	60b9      	str	r1, [r7, #8]
 8013d2c:	607a      	str	r2, [r7, #4]
 8013d2e:	603b      	str	r3, [r7, #0]
    int     length = 0;
 8013d30:	2300      	movs	r3, #0
 8013d32:	627b      	str	r3, [r7, #36]	@ 0x24
    word32  idx = (word32)*inOutIdx;
 8013d34:	68bb      	ldr	r3, [r7, #8]
 8013d36:	681b      	ldr	r3, [r3, #0]
 8013d38:	623b      	str	r3, [r7, #32]
    byte    b;

    /* Ensure zero return length on error. */
    *len = 0;
 8013d3a:	687b      	ldr	r3, [r7, #4]
 8013d3c:	2200      	movs	r2, #0
 8013d3e:	601a      	str	r2, [r3, #0]

    /* Check there is at least one byte available containing length information.
     */
    if ((idx + 1) > maxIdx) {
 8013d40:	6a3b      	ldr	r3, [r7, #32]
 8013d42:	3301      	adds	r3, #1
 8013d44:	683a      	ldr	r2, [r7, #0]
 8013d46:	429a      	cmp	r2, r3
 8013d48:	d202      	bcs.n	8013d50 <GetLength_ex+0x2e>
        WOLFSSL_MSG("GetLength - bad index on input");
        return BUFFER_E;
 8013d4a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013d4e:	e066      	b.n	8013e1e <GetLength_ex+0xfc>
    }

    /* Get the first length byte. */
    b = input[idx++];
 8013d50:	6a3b      	ldr	r3, [r7, #32]
 8013d52:	1c5a      	adds	r2, r3, #1
 8013d54:	623a      	str	r2, [r7, #32]
 8013d56:	68fa      	ldr	r2, [r7, #12]
 8013d58:	4413      	add	r3, r2
 8013d5a:	781b      	ldrb	r3, [r3, #0]
 8013d5c:	75fb      	strb	r3, [r7, #23]
    /* Check if the first byte indicates the count of bytes. */
    if (b >= ASN_LONG_LENGTH) {
 8013d5e:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8013d62:	2b00      	cmp	r3, #0
 8013d64:	da43      	bge.n	8013dee <GetLength_ex+0xcc>
        /* Bottom 7 bits are the number of bytes to calculate length with.
         * Note: 0 indicates indefinite length encoding *not* 0 bytes of length.
         */
        int bytes = (int)(b & 0x7F);
 8013d66:	7dfb      	ldrb	r3, [r7, #23]
 8013d68:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8013d6c:	61fb      	str	r3, [r7, #28]
        int minLen;

        /* Calculate minimum length to be encoded with bytes. */
        if (b == ASN_INDEF_LENGTH) {
 8013d6e:	7dfb      	ldrb	r3, [r7, #23]
 8013d70:	2b80      	cmp	r3, #128	@ 0x80
 8013d72:	d102      	bne.n	8013d7a <GetLength_ex+0x58>
            /* Indefinite length encoding - no length bytes. */
            minLen = 0;
 8013d74:	2300      	movs	r3, #0
 8013d76:	61bb      	str	r3, [r7, #24]
 8013d78:	e012      	b.n	8013da0 <GetLength_ex+0x7e>
        }
        else if (bytes == 1) {
 8013d7a:	69fb      	ldr	r3, [r7, #28]
 8013d7c:	2b01      	cmp	r3, #1
 8013d7e:	d102      	bne.n	8013d86 <GetLength_ex+0x64>
            minLen = 0x80;
 8013d80:	2380      	movs	r3, #128	@ 0x80
 8013d82:	61bb      	str	r3, [r7, #24]
 8013d84:	e00c      	b.n	8013da0 <GetLength_ex+0x7e>
        }
        /* Only support up to the number of bytes that fit into return var. */
        else if (bytes > (int)sizeof(length)) {
 8013d86:	69fb      	ldr	r3, [r7, #28]
 8013d88:	2b04      	cmp	r3, #4
 8013d8a:	dd02      	ble.n	8013d92 <GetLength_ex+0x70>
            WOLFSSL_MSG("GetLength - overlong data length spec");
            return ASN_PARSE_E;
 8013d8c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013d90:	e045      	b.n	8013e1e <GetLength_ex+0xfc>
        }
        else {
            minLen = 1 << ((bytes - 1) * 8);
 8013d92:	69fb      	ldr	r3, [r7, #28]
 8013d94:	3b01      	subs	r3, #1
 8013d96:	00db      	lsls	r3, r3, #3
 8013d98:	2201      	movs	r2, #1
 8013d9a:	fa02 f303 	lsl.w	r3, r2, r3
 8013d9e:	61bb      	str	r3, [r7, #24]
        }

        /* Check the number of bytes required are available. */
        if ((idx + (word32)bytes) > maxIdx) {
 8013da0:	69fa      	ldr	r2, [r7, #28]
 8013da2:	6a3b      	ldr	r3, [r7, #32]
 8013da4:	4413      	add	r3, r2
 8013da6:	683a      	ldr	r2, [r7, #0]
 8013da8:	429a      	cmp	r2, r3
 8013daa:	d20e      	bcs.n	8013dca <GetLength_ex+0xa8>
            WOLFSSL_MSG("GetLength - bad long length");
            return BUFFER_E;
 8013dac:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013db0:	e035      	b.n	8013e1e <GetLength_ex+0xfc>
        }

        /* Big-endian encoding of number. */
        while (bytes--) {
            b = input[idx++];
 8013db2:	6a3b      	ldr	r3, [r7, #32]
 8013db4:	1c5a      	adds	r2, r3, #1
 8013db6:	623a      	str	r2, [r7, #32]
 8013db8:	68fa      	ldr	r2, [r7, #12]
 8013dba:	4413      	add	r3, r2
 8013dbc:	781b      	ldrb	r3, [r3, #0]
 8013dbe:	75fb      	strb	r3, [r7, #23]
            length = (length << 8) | b;
 8013dc0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013dc2:	021a      	lsls	r2, r3, #8
 8013dc4:	7dfb      	ldrb	r3, [r7, #23]
 8013dc6:	4313      	orrs	r3, r2
 8013dc8:	627b      	str	r3, [r7, #36]	@ 0x24
        while (bytes--) {
 8013dca:	69fb      	ldr	r3, [r7, #28]
 8013dcc:	1e5a      	subs	r2, r3, #1
 8013dce:	61fa      	str	r2, [r7, #28]
 8013dd0:	2b00      	cmp	r3, #0
 8013dd2:	d1ee      	bne.n	8013db2 <GetLength_ex+0x90>
        }
        /* Negative value indicates we overflowed the signed int. */
        if (length < 0) {
 8013dd4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013dd6:	2b00      	cmp	r3, #0
 8013dd8:	da02      	bge.n	8013de0 <GetLength_ex+0xbe>
            return ASN_PARSE_E;
 8013dda:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013dde:	e01e      	b.n	8013e1e <GetLength_ex+0xfc>
        }
        /* Don't allow lengths that are longer than strictly required. */
        if (length < minLen) {
 8013de0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013de2:	69bb      	ldr	r3, [r7, #24]
 8013de4:	429a      	cmp	r2, r3
 8013de6:	da04      	bge.n	8013df2 <GetLength_ex+0xd0>
            return ASN_PARSE_E;
 8013de8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013dec:	e017      	b.n	8013e1e <GetLength_ex+0xfc>
        }
    }
    else {
        /* Length in first byte. */
        length = b;
 8013dee:	7dfb      	ldrb	r3, [r7, #23]
 8013df0:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    /* When requested, check the buffer has at least length bytes left. */
    if (check && ((idx + (word32)length) > maxIdx)) {
 8013df2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013df4:	2b00      	cmp	r3, #0
 8013df6:	d008      	beq.n	8013e0a <GetLength_ex+0xe8>
 8013df8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013dfa:	6a3b      	ldr	r3, [r7, #32]
 8013dfc:	4413      	add	r3, r2
 8013dfe:	683a      	ldr	r2, [r7, #0]
 8013e00:	429a      	cmp	r2, r3
 8013e02:	d202      	bcs.n	8013e0a <GetLength_ex+0xe8>
        WOLFSSL_MSG("GetLength - value exceeds buffer length");
        return BUFFER_E;
 8013e04:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013e08:	e009      	b.n	8013e1e <GetLength_ex+0xfc>
    }

    /* Return index after length encoding. */
    *inOutIdx = idx;
 8013e0a:	68bb      	ldr	r3, [r7, #8]
 8013e0c:	6a3a      	ldr	r2, [r7, #32]
 8013e0e:	601a      	str	r2, [r3, #0]
    /* Return length if valid. */
    if (length > 0) {
 8013e10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013e12:	2b00      	cmp	r3, #0
 8013e14:	dd02      	ble.n	8013e1c <GetLength_ex+0xfa>
        *len = length;
 8013e16:	687b      	ldr	r3, [r7, #4]
 8013e18:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8013e1a:	601a      	str	r2, [r3, #0]
    }

    /* Return length calculated or error code. */
    return length;
 8013e1c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8013e1e:	4618      	mov	r0, r3
 8013e20:	372c      	adds	r7, #44	@ 0x2c
 8013e22:	46bd      	mov	sp, r7
 8013e24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013e28:	4770      	bx	lr

08013e2a <GetASNTag>:
 * return  0 on success
 * return  BAD_FUNC_ARG when tag, inOutIdx or input is NULL.
 * return  BUFFER_E when not enough space in buffer for tag.
 */
int GetASNTag(const byte* input, word32* inOutIdx, byte* tag, word32 maxIdx)
{
 8013e2a:	b480      	push	{r7}
 8013e2c:	b087      	sub	sp, #28
 8013e2e:	af00      	add	r7, sp, #0
 8013e30:	60f8      	str	r0, [r7, #12]
 8013e32:	60b9      	str	r1, [r7, #8]
 8013e34:	607a      	str	r2, [r7, #4]
 8013e36:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8013e38:	2300      	movs	r3, #0
 8013e3a:	617b      	str	r3, [r7, #20]
    word32 idx = 0;
 8013e3c:	2300      	movs	r3, #0
 8013e3e:	613b      	str	r3, [r7, #16]

    /* Check validity of parameters. */
    if ((tag == NULL) || (inOutIdx == NULL) || (input == NULL)) {
 8013e40:	687b      	ldr	r3, [r7, #4]
 8013e42:	2b00      	cmp	r3, #0
 8013e44:	d005      	beq.n	8013e52 <GetASNTag+0x28>
 8013e46:	68bb      	ldr	r3, [r7, #8]
 8013e48:	2b00      	cmp	r3, #0
 8013e4a:	d002      	beq.n	8013e52 <GetASNTag+0x28>
 8013e4c:	68fb      	ldr	r3, [r7, #12]
 8013e4e:	2b00      	cmp	r3, #0
 8013e50:	d102      	bne.n	8013e58 <GetASNTag+0x2e>
        ret = BAD_FUNC_ARG;
 8013e52:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8013e56:	617b      	str	r3, [r7, #20]
    }
    if (ret == 0) {
 8013e58:	697b      	ldr	r3, [r7, #20]
 8013e5a:	2b00      	cmp	r3, #0
 8013e5c:	d10a      	bne.n	8013e74 <GetASNTag+0x4a>
        /* Get index and ensure space for tag. */
        idx = *inOutIdx;
 8013e5e:	68bb      	ldr	r3, [r7, #8]
 8013e60:	681b      	ldr	r3, [r3, #0]
 8013e62:	613b      	str	r3, [r7, #16]
        if (idx + ASN_TAG_SZ > maxIdx) {
 8013e64:	693b      	ldr	r3, [r7, #16]
 8013e66:	3301      	adds	r3, #1
 8013e68:	683a      	ldr	r2, [r7, #0]
 8013e6a:	429a      	cmp	r2, r3
 8013e6c:	d202      	bcs.n	8013e74 <GetASNTag+0x4a>
            WOLFSSL_MSG("Buffer too small for ASN tag");
            ret = BUFFER_E;
 8013e6e:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8013e72:	617b      	str	r3, [r7, #20]
        }
    }
    if (ret == 0) {
 8013e74:	697b      	ldr	r3, [r7, #20]
 8013e76:	2b00      	cmp	r3, #0
 8013e78:	d109      	bne.n	8013e8e <GetASNTag+0x64>
        /* Return the tag and the index after tag. */
        *tag = input[idx];
 8013e7a:	68fa      	ldr	r2, [r7, #12]
 8013e7c:	693b      	ldr	r3, [r7, #16]
 8013e7e:	4413      	add	r3, r2
 8013e80:	781a      	ldrb	r2, [r3, #0]
 8013e82:	687b      	ldr	r3, [r7, #4]
 8013e84:	701a      	strb	r2, [r3, #0]
        *inOutIdx = idx + ASN_TAG_SZ;
 8013e86:	693b      	ldr	r3, [r7, #16]
 8013e88:	1c5a      	adds	r2, r3, #1
 8013e8a:	68bb      	ldr	r3, [r7, #8]
 8013e8c:	601a      	str	r2, [r3, #0]
    }
    /* Return error code. */
    return ret;
 8013e8e:	697b      	ldr	r3, [r7, #20]
}
 8013e90:	4618      	mov	r0, r3
 8013e92:	371c      	adds	r7, #28
 8013e94:	46bd      	mov	sp, r7
 8013e96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013e9a:	4770      	bx	lr

08013e9c <GetASNHeader_ex>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the expected tag is not found or length is invalid.
 */
static int GetASNHeader_ex(const byte* input, byte tag, word32* inOutIdx,
                           int* len, word32 maxIdx, int check)
{
 8013e9c:	b580      	push	{r7, lr}
 8013e9e:	b08a      	sub	sp, #40	@ 0x28
 8013ea0:	af02      	add	r7, sp, #8
 8013ea2:	60f8      	str	r0, [r7, #12]
 8013ea4:	607a      	str	r2, [r7, #4]
 8013ea6:	603b      	str	r3, [r7, #0]
 8013ea8:	460b      	mov	r3, r1
 8013eaa:	72fb      	strb	r3, [r7, #11]
    int    ret = 0;
 8013eac:	2300      	movs	r3, #0
 8013eae:	61fb      	str	r3, [r7, #28]
    word32 idx = *inOutIdx;
 8013eb0:	687b      	ldr	r3, [r7, #4]
 8013eb2:	681b      	ldr	r3, [r3, #0]
 8013eb4:	61bb      	str	r3, [r7, #24]
    byte   tagFound;
    int    length = 0;
 8013eb6:	2300      	movs	r3, #0
 8013eb8:	613b      	str	r3, [r7, #16]

    /* Get tag/type. */
    if (GetASNTag(input, &idx, &tagFound, maxIdx) != 0) {
 8013eba:	f107 0217 	add.w	r2, r7, #23
 8013ebe:	f107 0118 	add.w	r1, r7, #24
 8013ec2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013ec4:	68f8      	ldr	r0, [r7, #12]
 8013ec6:	f7ff ffb0 	bl	8013e2a <GetASNTag>
 8013eca:	4603      	mov	r3, r0
 8013ecc:	2b00      	cmp	r3, #0
 8013ece:	d002      	beq.n	8013ed6 <GetASNHeader_ex+0x3a>
        ret = ASN_PARSE_E;
 8013ed0:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013ed4:	61fb      	str	r3, [r7, #28]
    }
    /* Ensure tag is the expected value. */
    if ((ret == 0) && (tagFound != tag)) {
 8013ed6:	69fb      	ldr	r3, [r7, #28]
 8013ed8:	2b00      	cmp	r3, #0
 8013eda:	d106      	bne.n	8013eea <GetASNHeader_ex+0x4e>
 8013edc:	7dfb      	ldrb	r3, [r7, #23]
 8013ede:	7afa      	ldrb	r2, [r7, #11]
 8013ee0:	429a      	cmp	r2, r3
 8013ee2:	d002      	beq.n	8013eea <GetASNHeader_ex+0x4e>
        ret = ASN_PARSE_E;
 8013ee4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013ee8:	61fb      	str	r3, [r7, #28]
    }
    /* Get the encoded length. */
    if ((ret == 0) && (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)) {
 8013eea:	69fb      	ldr	r3, [r7, #28]
 8013eec:	2b00      	cmp	r3, #0
 8013eee:	d10f      	bne.n	8013f10 <GetASNHeader_ex+0x74>
 8013ef0:	f107 0210 	add.w	r2, r7, #16
 8013ef4:	f107 0118 	add.w	r1, r7, #24
 8013ef8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8013efa:	9300      	str	r3, [sp, #0]
 8013efc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013efe:	68f8      	ldr	r0, [r7, #12]
 8013f00:	f7ff ff0f 	bl	8013d22 <GetLength_ex>
 8013f04:	4603      	mov	r3, r0
 8013f06:	2b00      	cmp	r3, #0
 8013f08:	da02      	bge.n	8013f10 <GetASNHeader_ex+0x74>
        ret = ASN_PARSE_E;
 8013f0a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013f0e:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0 && tag == ASN_OBJECT_ID) {
 8013f10:	69fb      	ldr	r3, [r7, #28]
 8013f12:	2b00      	cmp	r3, #0
 8013f14:	d117      	bne.n	8013f46 <GetASNHeader_ex+0xaa>
 8013f16:	7afb      	ldrb	r3, [r7, #11]
 8013f18:	2b06      	cmp	r3, #6
 8013f1a:	d114      	bne.n	8013f46 <GetASNHeader_ex+0xaa>
        if (length < 3) {
 8013f1c:	693b      	ldr	r3, [r7, #16]
 8013f1e:	2b02      	cmp	r3, #2
 8013f20:	dc03      	bgt.n	8013f2a <GetASNHeader_ex+0x8e>
            /* OID data must be at least 3 bytes. */
            WOLFSSL_MSG("OID length less than 3");
            ret = ASN_PARSE_E;
 8013f22:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013f26:	61fb      	str	r3, [r7, #28]
 8013f28:	e00d      	b.n	8013f46 <GetASNHeader_ex+0xaa>
        }
        else if ((input[(int)idx + length - 1] & 0x80) == 0x80) {
 8013f2a:	69bb      	ldr	r3, [r7, #24]
 8013f2c:	461a      	mov	r2, r3
 8013f2e:	693b      	ldr	r3, [r7, #16]
 8013f30:	4413      	add	r3, r2
 8013f32:	3b01      	subs	r3, #1
 8013f34:	68fa      	ldr	r2, [r7, #12]
 8013f36:	4413      	add	r3, r2
 8013f38:	781b      	ldrb	r3, [r3, #0]
 8013f3a:	b25b      	sxtb	r3, r3
 8013f3c:	2b00      	cmp	r3, #0
 8013f3e:	da02      	bge.n	8013f46 <GetASNHeader_ex+0xaa>
            /* Last octet of a sub-identifier has bit 8 clear. Last octet must be
            * last of a subidentifier. Ensure last octet hasn't got top bit set. */
            WOLFSSL_MSG("OID last octet has top bit set");
            ret = ASN_PARSE_E;
 8013f40:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8013f44:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 8013f46:	69fb      	ldr	r3, [r7, #28]
 8013f48:	2b00      	cmp	r3, #0
 8013f4a:	d107      	bne.n	8013f5c <GetASNHeader_ex+0xc0>
        /* Return the length of data and index after header. */
        *len      = length;
 8013f4c:	693a      	ldr	r2, [r7, #16]
 8013f4e:	683b      	ldr	r3, [r7, #0]
 8013f50:	601a      	str	r2, [r3, #0]
        *inOutIdx = idx;
 8013f52:	69ba      	ldr	r2, [r7, #24]
 8013f54:	687b      	ldr	r3, [r7, #4]
 8013f56:	601a      	str	r2, [r3, #0]
        ret = length;
 8013f58:	693b      	ldr	r3, [r7, #16]
 8013f5a:	61fb      	str	r3, [r7, #28]
    }
    /* Return number of data bytes or error code. */
    return ret;
 8013f5c:	69fb      	ldr	r3, [r7, #28]
}
 8013f5e:	4618      	mov	r0, r3
 8013f60:	3720      	adds	r7, #32
 8013f62:	46bd      	mov	sp, r7
 8013f64:	bd80      	pop	{r7, pc}

08013f66 <GetASNHeader>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the expected tag is not found or length is invalid.
 */
int GetASNHeader(const byte* input, byte tag, word32* inOutIdx, int* len,
                        word32 maxIdx)
{
 8013f66:	b580      	push	{r7, lr}
 8013f68:	b086      	sub	sp, #24
 8013f6a:	af02      	add	r7, sp, #8
 8013f6c:	60f8      	str	r0, [r7, #12]
 8013f6e:	607a      	str	r2, [r7, #4]
 8013f70:	603b      	str	r3, [r7, #0]
 8013f72:	460b      	mov	r3, r1
 8013f74:	72fb      	strb	r3, [r7, #11]
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
 8013f76:	7af9      	ldrb	r1, [r7, #11]
 8013f78:	2301      	movs	r3, #1
 8013f7a:	9301      	str	r3, [sp, #4]
 8013f7c:	69bb      	ldr	r3, [r7, #24]
 8013f7e:	9300      	str	r3, [sp, #0]
 8013f80:	683b      	ldr	r3, [r7, #0]
 8013f82:	687a      	ldr	r2, [r7, #4]
 8013f84:	68f8      	ldr	r0, [r7, #12]
 8013f86:	f7ff ff89 	bl	8013e9c <GetASNHeader_ex>
 8013f8a:	4603      	mov	r3, r0
}
 8013f8c:	4618      	mov	r0, r3
 8013f8e:	3710      	adds	r7, #16
 8013f90:	46bd      	mov	sp, r7
 8013f92:	bd80      	pop	{r7, pc}

08013f94 <GetSequence>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the tag is not a SEQUENCE or length is invalid.
 */
int GetSequence(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx)
{
 8013f94:	b580      	push	{r7, lr}
 8013f96:	b086      	sub	sp, #24
 8013f98:	af02      	add	r7, sp, #8
 8013f9a:	60f8      	str	r0, [r7, #12]
 8013f9c:	60b9      	str	r1, [r7, #8]
 8013f9e:	607a      	str	r2, [r7, #4]
 8013fa0:	603b      	str	r3, [r7, #0]
    return GetASNHeader(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,
 8013fa2:	683b      	ldr	r3, [r7, #0]
 8013fa4:	9300      	str	r3, [sp, #0]
 8013fa6:	687b      	ldr	r3, [r7, #4]
 8013fa8:	68ba      	ldr	r2, [r7, #8]
 8013faa:	2130      	movs	r1, #48	@ 0x30
 8013fac:	68f8      	ldr	r0, [r7, #12]
 8013fae:	f7ff ffda 	bl	8013f66 <GetASNHeader>
 8013fb2:	4603      	mov	r3, r0
                        maxIdx);
}
 8013fb4:	4618      	mov	r0, r3
 8013fb6:	3710      	adds	r7, #16
 8013fb8:	46bd      	mov	sp, r7
 8013fba:	bd80      	pop	{r7, pc}

08013fbc <GetSequence_ex>:
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the tag is not a SEQUENCE or length is invalid.
 */
int GetSequence_ex(const byte* input, word32* inOutIdx, int* len,
                           word32 maxIdx, int check)
{
 8013fbc:	b580      	push	{r7, lr}
 8013fbe:	b086      	sub	sp, #24
 8013fc0:	af02      	add	r7, sp, #8
 8013fc2:	60f8      	str	r0, [r7, #12]
 8013fc4:	60b9      	str	r1, [r7, #8]
 8013fc6:	607a      	str	r2, [r7, #4]
 8013fc8:	603b      	str	r3, [r7, #0]
    return GetASNHeader_ex(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,
 8013fca:	69bb      	ldr	r3, [r7, #24]
 8013fcc:	9301      	str	r3, [sp, #4]
 8013fce:	683b      	ldr	r3, [r7, #0]
 8013fd0:	9300      	str	r3, [sp, #0]
 8013fd2:	687b      	ldr	r3, [r7, #4]
 8013fd4:	68ba      	ldr	r2, [r7, #8]
 8013fd6:	2130      	movs	r1, #48	@ 0x30
 8013fd8:	68f8      	ldr	r0, [r7, #12]
 8013fda:	f7ff ff5f 	bl	8013e9c <GetASNHeader_ex>
 8013fde:	4603      	mov	r3, r0
                        maxIdx, check);
}
 8013fe0:	4618      	mov	r0, r3
 8013fe2:	3710      	adds	r7, #16
 8013fe4:	46bd      	mov	sp, r7
 8013fe6:	bd80      	pop	{r7, pc}

08013fe8 <GetOctetString>:
 * @return  Number of bytes in the ASN.1 data on success.
 * @return  BUFFER_E when there is not enough data to parse.
 * @return  ASN_PARSE_E when the tag is not a OCTET STRING or length is invalid.
 */
int GetOctetString(const byte* input, word32* inOutIdx, int* len, word32 maxIdx)
{
 8013fe8:	b580      	push	{r7, lr}
 8013fea:	b086      	sub	sp, #24
 8013fec:	af02      	add	r7, sp, #8
 8013fee:	60f8      	str	r0, [r7, #12]
 8013ff0:	60b9      	str	r1, [r7, #8]
 8013ff2:	607a      	str	r2, [r7, #4]
 8013ff4:	603b      	str	r3, [r7, #0]
    return GetASNHeader(input, ASN_OCTET_STRING, inOutIdx, len, maxIdx);
 8013ff6:	683b      	ldr	r3, [r7, #0]
 8013ff8:	9300      	str	r3, [sp, #0]
 8013ffa:	687b      	ldr	r3, [r7, #4]
 8013ffc:	68ba      	ldr	r2, [r7, #8]
 8013ffe:	2104      	movs	r1, #4
 8014000:	68f8      	ldr	r0, [r7, #12]
 8014002:	f7ff ffb0 	bl	8013f66 <GetASNHeader>
 8014006:	4603      	mov	r3, r0
}
 8014008:	4618      	mov	r0, r3
 801400a:	3710      	adds	r7, #16
 801400c:	46bd      	mov	sp, r7
 801400e:	bd80      	pop	{r7, pc}

08014010 <CheckBitString>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_EXPECT_0_E when unused bits is not zero when expected.
 */
int CheckBitString(const byte* input, word32* inOutIdx, int* len,
                          word32 maxIdx, int zeroBits, byte* unusedBits)
{
 8014010:	b580      	push	{r7, lr}
 8014012:	b092      	sub	sp, #72	@ 0x48
 8014014:	af04      	add	r7, sp, #16
 8014016:	60f8      	str	r0, [r7, #12]
 8014018:	60b9      	str	r1, [r7, #8]
 801401a:	607a      	str	r2, [r7, #4]
 801401c:	603b      	str	r3, [r7, #0]

    return 0;
#else
    ASNGetData dataASN[bitStringASN_Length];
    int ret;
    int bits = 0;
 801401e:	2300      	movs	r3, #0
 8014020:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Parse BIT_STRING and check validity of unused bits. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 8014022:	f107 0314 	add.w	r3, r7, #20
 8014026:	221c      	movs	r2, #28
 8014028:	2100      	movs	r1, #0
 801402a:	4618      	mov	r0, r3
 801402c:	f014 fa50 	bl	80284d0 <memset>
    /* Decode BIT_STRING. */
    ret = GetASN_Items(bitStringASN, dataASN, bitStringASN_Length, 0, input,
 8014030:	f107 0114 	add.w	r1, r7, #20
 8014034:	683b      	ldr	r3, [r7, #0]
 8014036:	9302      	str	r3, [sp, #8]
 8014038:	68bb      	ldr	r3, [r7, #8]
 801403a:	9301      	str	r3, [sp, #4]
 801403c:	68fb      	ldr	r3, [r7, #12]
 801403e:	9300      	str	r3, [sp, #0]
 8014040:	2300      	movs	r3, #0
 8014042:	2201      	movs	r2, #1
 8014044:	4814      	ldr	r0, [pc, #80]	@ (8014098 <CheckBitString+0x88>)
 8014046:	f7ff fb61 	bl	801370c <GetASN_Items>
 801404a:	6378      	str	r0, [r7, #52]	@ 0x34
            inOutIdx, maxIdx);
    if (ret == 0) {
 801404c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801404e:	2b00      	cmp	r3, #0
 8014050:	d10c      	bne.n	801406c <CheckBitString+0x5c>
        /* Get unused bits from dynamic ASN.1 data. */
        bits = GetASNItem_UnusedBits(dataASN[BITSTRINGASN_IDX_BIT_STR]);
 8014052:	69fb      	ldr	r3, [r7, #28]
 8014054:	3b01      	subs	r3, #1
 8014056:	781b      	ldrb	r3, [r3, #0]
 8014058:	633b      	str	r3, [r7, #48]	@ 0x30
        /* Check unused bits is 0 when expected. */
        if (zeroBits && (bits != 0)) {
 801405a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801405c:	2b00      	cmp	r3, #0
 801405e:	d005      	beq.n	801406c <CheckBitString+0x5c>
 8014060:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014062:	2b00      	cmp	r3, #0
 8014064:	d002      	beq.n	801406c <CheckBitString+0x5c>
            ret = ASN_EXPECT_0_E;
 8014066:	f06f 0391 	mvn.w	r3, #145	@ 0x91
 801406a:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }
    if (ret == 0) {
 801406c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801406e:	2b00      	cmp	r3, #0
 8014070:	d10d      	bne.n	801408e <CheckBitString+0x7e>
        /* Return length of data and unused bits if required. */
        if (len != NULL) {
 8014072:	687b      	ldr	r3, [r7, #4]
 8014074:	2b00      	cmp	r3, #0
 8014076:	d003      	beq.n	8014080 <CheckBitString+0x70>
            *len = (int)dataASN[BITSTRINGASN_IDX_BIT_STR].data.ref.length;
 8014078:	6a3b      	ldr	r3, [r7, #32]
 801407a:	461a      	mov	r2, r3
 801407c:	687b      	ldr	r3, [r7, #4]
 801407e:	601a      	str	r2, [r3, #0]
        }
        if (unusedBits != NULL) {
 8014080:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8014082:	2b00      	cmp	r3, #0
 8014084:	d003      	beq.n	801408e <CheckBitString+0x7e>
            *unusedBits = (byte)bits;
 8014086:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014088:	b2da      	uxtb	r2, r3
 801408a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801408c:	701a      	strb	r2, [r3, #0]
        }
    }

    return ret;
 801408e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
#endif
}
 8014090:	4618      	mov	r0, r3
 8014092:	3738      	adds	r7, #56	@ 0x38
 8014094:	46bd      	mov	sp, r7
 8014096:	bd80      	pop	{r7, pc}
 8014098:	08033428 	.word	0x08033428

0801409c <OidFromId>:
 * @param [out] oidSz  Length of OID byte array returned.
 * @return  Array of bytes for the OID.
 * @return  NULL when ID/type not recognized.
 */
const byte* OidFromId(word32 id, word32 type, word32* oidSz)
{
 801409c:	b580      	push	{r7, lr}
 801409e:	b086      	sub	sp, #24
 80140a0:	af00      	add	r7, sp, #0
 80140a2:	60f8      	str	r0, [r7, #12]
 80140a4:	60b9      	str	r1, [r7, #8]
 80140a6:	607a      	str	r2, [r7, #4]
    const byte* oid = NULL;
 80140a8:	2300      	movs	r3, #0
 80140aa:	617b      	str	r3, [r7, #20]

    *oidSz = 0;
 80140ac:	687b      	ldr	r3, [r7, #4]
 80140ae:	2200      	movs	r2, #0
 80140b0:	601a      	str	r2, [r3, #0]

    switch (type) {
 80140b2:	68bb      	ldr	r3, [r7, #8]
 80140b4:	2b13      	cmp	r3, #19
 80140b6:	f200 82ca 	bhi.w	801464e <OidFromId+0x5b2>
 80140ba:	a201      	add	r2, pc, #4	@ (adr r2, 80140c0 <OidFromId+0x24>)
 80140bc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80140c0:	08014111 	.word	0x08014111
 80140c4:	08014129 	.word	0x08014129
 80140c8:	08014177 	.word	0x08014177
 80140cc:	080141e5 	.word	0x080141e5
 80140d0:	080141f5 	.word	0x080141f5
 80140d4:	0801464f 	.word	0x0801464f
 80140d8:	08014309 	.word	0x08014309
 80140dc:	080144a5 	.word	0x080144a5
 80140e0:	080144cd 	.word	0x080144cd
 80140e4:	080144e3 	.word	0x080144e3
 80140e8:	080144f9 	.word	0x080144f9
 80140ec:	08014597 	.word	0x08014597
 80140f0:	080145cf 	.word	0x080145cf
 80140f4:	0801461f 	.word	0x0801461f
 80140f8:	080145af 	.word	0x080145af
 80140fc:	08014635 	.word	0x08014635
 8014100:	0801464f 	.word	0x0801464f
 8014104:	0801464f 	.word	0x0801464f
 8014108:	0801464f 	.word	0x0801464f
 801410c:	0801464f 	.word	0x0801464f

        case oidHashType:
            switch (id) {
 8014110:	68fb      	ldr	r3, [r7, #12]
 8014112:	f5b3 7fcf 	cmp.w	r3, #414	@ 0x19e
 8014116:	d105      	bne.n	8014124 <OidFromId+0x88>
                    *oidSz = sizeof(hashSha224hOid);
                    break;
            #endif
            #ifndef NO_SHA256
                case SHA256h:
                    oid = hashSha256hOid;
 8014118:	4bb6      	ldr	r3, [pc, #728]	@ (80143f4 <OidFromId+0x358>)
 801411a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(hashSha256hOid);
 801411c:	687b      	ldr	r3, [r7, #4]
 801411e:	2209      	movs	r2, #9
 8014120:	601a      	str	r2, [r3, #0]
                    break;
 8014122:	e000      	b.n	8014126 <OidFromId+0x8a>
                    *oidSz = sizeof(hashSha3_512hOid);
                    break;
            #endif /* WOLFSSL_NOSHA3_512 */
            #endif /* WOLFSSL_SHA3 */
                default:
                    break;
 8014124:	bf00      	nop
            }
            break;
 8014126:	e293      	b.n	8014650 <OidFromId+0x5b4>

        case oidSigType:
            switch (id) {
 8014128:	68fb      	ldr	r3, [r7, #12]
 801412a:	f240 228f 	movw	r2, #655	@ 0x28f
 801412e:	4293      	cmp	r3, r2
 8014130:	d00d      	beq.n	801414e <OidFromId+0xb2>
 8014132:	68fb      	ldr	r3, [r7, #12]
 8014134:	f5b3 7f24 	cmp.w	r3, #656	@ 0x290
 8014138:	d21b      	bcs.n	8014172 <OidFromId+0xd6>
 801413a:	68fb      	ldr	r3, [r7, #12]
 801413c:	f5b3 7f03 	cmp.w	r3, #524	@ 0x20c
 8014140:	d011      	beq.n	8014166 <OidFromId+0xca>
 8014142:	68fb      	ldr	r3, [r7, #12]
 8014144:	f240 228e 	movw	r2, #654	@ 0x28e
 8014148:	4293      	cmp	r3, r2
 801414a:	d006      	beq.n	801415a <OidFromId+0xbe>
                    oid = sigSphincsSmall_Level5Oid;
                    *oidSz = sizeof(sigSphincsSmall_Level5Oid);
                    break;
                #endif /* HAVE_SPHINCS */
                default:
                    break;
 801414c:	e011      	b.n	8014172 <OidFromId+0xd6>
                    oid = sigSha256wRsaOid;
 801414e:	4baa      	ldr	r3, [pc, #680]	@ (80143f8 <OidFromId+0x35c>)
 8014150:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigSha256wRsaOid);
 8014152:	687b      	ldr	r3, [r7, #4]
 8014154:	2209      	movs	r2, #9
 8014156:	601a      	str	r2, [r3, #0]
                    break;
 8014158:	e00c      	b.n	8014174 <OidFromId+0xd8>
                    oid = sigRsaSsaPssOid;
 801415a:	4ba8      	ldr	r3, [pc, #672]	@ (80143fc <OidFromId+0x360>)
 801415c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigRsaSsaPssOid);
 801415e:	687b      	ldr	r3, [r7, #4]
 8014160:	2209      	movs	r2, #9
 8014162:	601a      	str	r2, [r3, #0]
                    break;
 8014164:	e006      	b.n	8014174 <OidFromId+0xd8>
                    oid = sigSha256wEcdsaOid;
 8014166:	4ba6      	ldr	r3, [pc, #664]	@ (8014400 <OidFromId+0x364>)
 8014168:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(sigSha256wEcdsaOid);
 801416a:	687b      	ldr	r3, [r7, #4]
 801416c:	2208      	movs	r2, #8
 801416e:	601a      	str	r2, [r3, #0]
                    break;
 8014170:	e000      	b.n	8014174 <OidFromId+0xd8>
                    break;
 8014172:	bf00      	nop
            }
            break;
 8014174:	e26c      	b.n	8014650 <OidFromId+0x5b4>

        case oidKeyType:
            switch (id) {
 8014176:	68fb      	ldr	r3, [r7, #12]
 8014178:	f240 228e 	movw	r2, #654	@ 0x28e
 801417c:	4293      	cmp	r3, r2
 801417e:	d01d      	beq.n	80141bc <OidFromId+0x120>
 8014180:	68fb      	ldr	r3, [r7, #12]
 8014182:	f240 228e 	movw	r2, #654	@ 0x28e
 8014186:	4293      	cmp	r3, r2
 8014188:	d82a      	bhi.n	80141e0 <OidFromId+0x144>
 801418a:	68fb      	ldr	r3, [r7, #12]
 801418c:	f240 2287 	movw	r2, #647	@ 0x287
 8014190:	4293      	cmp	r3, r2
 8014192:	d01f      	beq.n	80141d4 <OidFromId+0x138>
 8014194:	68fb      	ldr	r3, [r7, #12]
 8014196:	f5b3 7f22 	cmp.w	r3, #648	@ 0x288
 801419a:	d221      	bcs.n	80141e0 <OidFromId+0x144>
 801419c:	68fb      	ldr	r3, [r7, #12]
 801419e:	f240 2206 	movw	r2, #518	@ 0x206
 80141a2:	4293      	cmp	r3, r2
 80141a4:	d010      	beq.n	80141c8 <OidFromId+0x12c>
 80141a6:	68fb      	ldr	r3, [r7, #12]
 80141a8:	f240 2285 	movw	r2, #645	@ 0x285
 80141ac:	4293      	cmp	r3, r2
 80141ae:	d117      	bne.n	80141e0 <OidFromId+0x144>
                    *oidSz = sizeof(keyDsaOid);
                    break;
                #endif /* NO_DSA */
            #ifndef NO_RSA
                case RSAk:
                    oid = keyRsaOid;
 80141b0:	4b94      	ldr	r3, [pc, #592]	@ (8014404 <OidFromId+0x368>)
 80141b2:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyRsaOid);
 80141b4:	687b      	ldr	r3, [r7, #4]
 80141b6:	2209      	movs	r2, #9
 80141b8:	601a      	str	r2, [r3, #0]
                    break;
 80141ba:	e012      	b.n	80141e2 <OidFromId+0x146>
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                    oid = keyRsaPssOid;
 80141bc:	4b92      	ldr	r3, [pc, #584]	@ (8014408 <OidFromId+0x36c>)
 80141be:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyRsaPssOid);
 80141c0:	687b      	ldr	r3, [r7, #4]
 80141c2:	2209      	movs	r2, #9
 80141c4:	601a      	str	r2, [r3, #0]
                    break;
 80141c6:	e00c      	b.n	80141e2 <OidFromId+0x146>
                #endif
            #endif /* NO_RSA */
                #ifdef HAVE_ECC
                case ECDSAk:
                    oid = keyEcdsaOid;
 80141c8:	4b90      	ldr	r3, [pc, #576]	@ (801440c <OidFromId+0x370>)
 80141ca:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyEcdsaOid);
 80141cc:	687b      	ldr	r3, [r7, #4]
 80141ce:	2207      	movs	r2, #7
 80141d0:	601a      	str	r2, [r3, #0]
                    break;
 80141d2:	e006      	b.n	80141e2 <OidFromId+0x146>
                    *oidSz = sizeof(keyCurve448Oid);
                    break;
                #endif /* HAVE_CURVE448 */
                #ifndef NO_DH
                case DHk:
                    oid = keyDhOid;
 80141d4:	4b8e      	ldr	r3, [pc, #568]	@ (8014410 <OidFromId+0x374>)
 80141d6:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(keyDhOid);
 80141d8:	687b      	ldr	r3, [r7, #4]
 80141da:	2209      	movs	r2, #9
 80141dc:	601a      	str	r2, [r3, #0]
                    break;
 80141de:	e000      	b.n	80141e2 <OidFromId+0x146>
                    oid = keySphincsSmall_Level5Oid;
                    *oidSz = sizeof(keySphincsSmall_Level5Oid);
                    break;
                #endif /* HAVE_SPHINCS */
                default:
                    break;
 80141e0:	bf00      	nop
            }
            break;
 80141e2:	e235      	b.n	8014650 <OidFromId+0x5b4>

        #ifdef HAVE_ECC
        case oidCurveType:
            if (wc_ecc_get_oid(id, &oid, oidSz) < 0) {
 80141e4:	f107 0314 	add.w	r3, r7, #20
 80141e8:	687a      	ldr	r2, [r7, #4]
 80141ea:	4619      	mov	r1, r3
 80141ec:	68f8      	ldr	r0, [r7, #12]
 80141ee:	f00a f869 	bl	801e2c4 <wc_ecc_get_oid>
                WOLFSSL_MSG("ECC OID not found");
            }
            break;
 80141f2:	e22d      	b.n	8014650 <OidFromId+0x5b4>
        #endif /* HAVE_ECC */

        case oidBlkType:
            switch (id) {
 80141f4:	68fb      	ldr	r3, [r7, #12]
 80141f6:	f5a3 73cf 	sub.w	r3, r3, #414	@ 0x19e
 80141fa:	2b2c      	cmp	r3, #44	@ 0x2c
 80141fc:	f200 8082 	bhi.w	8014304 <OidFromId+0x268>
 8014200:	a201      	add	r2, pc, #4	@ (adr r2, 8014208 <OidFromId+0x16c>)
 8014202:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014206:	bf00      	nop
 8014208:	080142bd 	.word	0x080142bd
 801420c:	08014305 	.word	0x08014305
 8014210:	08014305 	.word	0x08014305
 8014214:	08014305 	.word	0x08014305
 8014218:	080142e1 	.word	0x080142e1
 801421c:	08014305 	.word	0x08014305
 8014220:	08014305 	.word	0x08014305
 8014224:	08014305 	.word	0x08014305
 8014228:	08014305 	.word	0x08014305
 801422c:	08014305 	.word	0x08014305
 8014230:	08014305 	.word	0x08014305
 8014234:	08014305 	.word	0x08014305
 8014238:	08014305 	.word	0x08014305
 801423c:	08014305 	.word	0x08014305
 8014240:	08014305 	.word	0x08014305
 8014244:	08014305 	.word	0x08014305
 8014248:	08014305 	.word	0x08014305
 801424c:	08014305 	.word	0x08014305
 8014250:	08014305 	.word	0x08014305
 8014254:	08014305 	.word	0x08014305
 8014258:	080142c9 	.word	0x080142c9
 801425c:	08014305 	.word	0x08014305
 8014260:	08014305 	.word	0x08014305
 8014264:	08014305 	.word	0x08014305
 8014268:	080142ed 	.word	0x080142ed
 801426c:	08014305 	.word	0x08014305
 8014270:	08014305 	.word	0x08014305
 8014274:	08014305 	.word	0x08014305
 8014278:	08014305 	.word	0x08014305
 801427c:	08014305 	.word	0x08014305
 8014280:	08014305 	.word	0x08014305
 8014284:	08014305 	.word	0x08014305
 8014288:	08014305 	.word	0x08014305
 801428c:	08014305 	.word	0x08014305
 8014290:	08014305 	.word	0x08014305
 8014294:	08014305 	.word	0x08014305
 8014298:	08014305 	.word	0x08014305
 801429c:	08014305 	.word	0x08014305
 80142a0:	08014305 	.word	0x08014305
 80142a4:	08014305 	.word	0x08014305
 80142a8:	080142d5 	.word	0x080142d5
 80142ac:	08014305 	.word	0x08014305
 80142b0:	08014305 	.word	0x08014305
 80142b4:	08014305 	.word	0x08014305
 80142b8:	080142f9 	.word	0x080142f9
    #ifdef HAVE_AES_CBC
        #ifdef WOLFSSL_AES_128
                case AES128CBCb:
                    oid = blkAes128CbcOid;
 80142bc:	4b55      	ldr	r3, [pc, #340]	@ (8014414 <OidFromId+0x378>)
 80142be:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes128CbcOid);
 80142c0:	687b      	ldr	r3, [r7, #4]
 80142c2:	2209      	movs	r2, #9
 80142c4:	601a      	str	r2, [r3, #0]
                    break;
 80142c6:	e01e      	b.n	8014306 <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_192
                case AES192CBCb:
                    oid = blkAes192CbcOid;
 80142c8:	4b53      	ldr	r3, [pc, #332]	@ (8014418 <OidFromId+0x37c>)
 80142ca:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes192CbcOid);
 80142cc:	687b      	ldr	r3, [r7, #4]
 80142ce:	2209      	movs	r2, #9
 80142d0:	601a      	str	r2, [r3, #0]
                    break;
 80142d2:	e018      	b.n	8014306 <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_256
                case AES256CBCb:
                    oid = blkAes256CbcOid;
 80142d4:	4b51      	ldr	r3, [pc, #324]	@ (801441c <OidFromId+0x380>)
 80142d6:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes256CbcOid);
 80142d8:	687b      	ldr	r3, [r7, #4]
 80142da:	2209      	movs	r2, #9
 80142dc:	601a      	str	r2, [r3, #0]
                    break;
 80142de:	e012      	b.n	8014306 <OidFromId+0x26a>
        #endif
    #endif /* HAVE_AES_CBC */
    #ifdef HAVE_AESGCM
        #ifdef WOLFSSL_AES_128
                case AES128GCMb:
                    oid = blkAes128GcmOid;
 80142e0:	4b4f      	ldr	r3, [pc, #316]	@ (8014420 <OidFromId+0x384>)
 80142e2:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes128GcmOid);
 80142e4:	687b      	ldr	r3, [r7, #4]
 80142e6:	2209      	movs	r2, #9
 80142e8:	601a      	str	r2, [r3, #0]
                    break;
 80142ea:	e00c      	b.n	8014306 <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_192
                case AES192GCMb:
                    oid = blkAes192GcmOid;
 80142ec:	4b4d      	ldr	r3, [pc, #308]	@ (8014424 <OidFromId+0x388>)
 80142ee:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes192GcmOid);
 80142f0:	687b      	ldr	r3, [r7, #4]
 80142f2:	2209      	movs	r2, #9
 80142f4:	601a      	str	r2, [r3, #0]
                    break;
 80142f6:	e006      	b.n	8014306 <OidFromId+0x26a>
        #endif
        #ifdef WOLFSSL_AES_256
                case AES256GCMb:
                    oid = blkAes256GcmOid;
 80142f8:	4b4b      	ldr	r3, [pc, #300]	@ (8014428 <OidFromId+0x38c>)
 80142fa:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(blkAes256GcmOid);
 80142fc:	687b      	ldr	r3, [r7, #4]
 80142fe:	2209      	movs	r2, #9
 8014300:	601a      	str	r2, [r3, #0]
                    break;
 8014302:	e000      	b.n	8014306 <OidFromId+0x26a>
                    oid = blkDes3CbcOid;
                    *oidSz = sizeof(blkDes3CbcOid);
                    break;
    #endif /* !NO_DES3 */
                default:
                    break;
 8014304:	bf00      	nop
            }
            break;
 8014306:	e1a3      	b.n	8014650 <OidFromId+0x5b4>
            }
            break;
        #endif /* HAVE_OCSP */

        case oidCertExtType:
            switch (id) {
 8014308:	68fb      	ldr	r3, [r7, #12]
 801430a:	2b45      	cmp	r3, #69	@ 0x45
 801430c:	f000 8098 	beq.w	8014440 <OidFromId+0x3a4>
 8014310:	68fb      	ldr	r3, [r7, #12]
 8014312:	2b45      	cmp	r3, #69	@ 0x45
 8014314:	f0c0 80c4 	bcc.w	80144a0 <OidFromId+0x404>
 8014318:	68fb      	ldr	r3, [r7, #12]
 801431a:	2ba8      	cmp	r3, #168	@ 0xa8
 801431c:	f200 80c0 	bhi.w	80144a0 <OidFromId+0x404>
 8014320:	68fb      	ldr	r3, [r7, #12]
 8014322:	2b80      	cmp	r3, #128	@ 0x80
 8014324:	f0c0 80bc 	bcc.w	80144a0 <OidFromId+0x404>
 8014328:	68fb      	ldr	r3, [r7, #12]
 801432a:	3b80      	subs	r3, #128	@ 0x80
 801432c:	2b28      	cmp	r3, #40	@ 0x28
 801432e:	f200 80b7 	bhi.w	80144a0 <OidFromId+0x404>
 8014332:	a201      	add	r2, pc, #4	@ (adr r2, 8014338 <OidFromId+0x29c>)
 8014334:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014338:	08014459 	.word	0x08014459
 801433c:	08014471 	.word	0x08014471
 8014340:	080144a1 	.word	0x080144a1
 8014344:	080143e9 	.word	0x080143e9
 8014348:	080144a1 	.word	0x080144a1
 801434c:	080143dd 	.word	0x080143dd
 8014350:	080144a1 	.word	0x080144a1
 8014354:	080144a1 	.word	0x080144a1
 8014358:	080144a1 	.word	0x080144a1
 801435c:	080144a1 	.word	0x080144a1
 8014360:	080144a1 	.word	0x080144a1
 8014364:	080144a1 	.word	0x080144a1
 8014368:	080144a1 	.word	0x080144a1
 801436c:	080144a1 	.word	0x080144a1
 8014370:	080144a1 	.word	0x080144a1
 8014374:	080144a1 	.word	0x080144a1
 8014378:	08014495 	.word	0x08014495
 801437c:	08014435 	.word	0x08014435
 8014380:	08014465 	.word	0x08014465
 8014384:	080144a1 	.word	0x080144a1
 8014388:	080144a1 	.word	0x080144a1
 801438c:	0801444d 	.word	0x0801444d
 8014390:	080144a1 	.word	0x080144a1
 8014394:	08014489 	.word	0x08014489
 8014398:	080144a1 	.word	0x080144a1
 801439c:	080144a1 	.word	0x080144a1
 80143a0:	080144a1 	.word	0x080144a1
 80143a4:	080144a1 	.word	0x080144a1
 80143a8:	080144a1 	.word	0x080144a1
 80143ac:	080144a1 	.word	0x080144a1
 80143b0:	080144a1 	.word	0x080144a1
 80143b4:	080144a1 	.word	0x080144a1
 80143b8:	080144a1 	.word	0x080144a1
 80143bc:	080144a1 	.word	0x080144a1
 80143c0:	080144a1 	.word	0x080144a1
 80143c4:	080144a1 	.word	0x080144a1
 80143c8:	080144a1 	.word	0x080144a1
 80143cc:	080144a1 	.word	0x080144a1
 80143d0:	080144a1 	.word	0x080144a1
 80143d4:	080144a1 	.word	0x080144a1
 80143d8:	0801447d 	.word	0x0801447d
                case BASIC_CA_OID:
                    oid = extBasicCaOid;
 80143dc:	4b13      	ldr	r3, [pc, #76]	@ (801442c <OidFromId+0x390>)
 80143de:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extBasicCaOid);
 80143e0:	687b      	ldr	r3, [r7, #4]
 80143e2:	2203      	movs	r2, #3
 80143e4:	601a      	str	r2, [r3, #0]
                    break;
 80143e6:	e05c      	b.n	80144a2 <OidFromId+0x406>
                case ALT_NAMES_OID:
                    oid = extAltNamesOid;
 80143e8:	4b11      	ldr	r3, [pc, #68]	@ (8014430 <OidFromId+0x394>)
 80143ea:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAltNamesOid);
 80143ec:	687b      	ldr	r3, [r7, #4]
 80143ee:	2203      	movs	r2, #3
 80143f0:	601a      	str	r2, [r3, #0]
                    break;
 80143f2:	e056      	b.n	80144a2 <OidFromId+0x406>
 80143f4:	0803342c 	.word	0x0803342c
 80143f8:	08033440 	.word	0x08033440
 80143fc:	0803344c 	.word	0x0803344c
 8014400:	08033458 	.word	0x08033458
 8014404:	08033460 	.word	0x08033460
 8014408:	0803346c 	.word	0x0803346c
 801440c:	08033478 	.word	0x08033478
 8014410:	08033480 	.word	0x08033480
 8014414:	0803348c 	.word	0x0803348c
 8014418:	08033498 	.word	0x08033498
 801441c:	080334a4 	.word	0x080334a4
 8014420:	080334b0 	.word	0x080334b0
 8014424:	080334bc 	.word	0x080334bc
 8014428:	080334c8 	.word	0x080334c8
 801442c:	08033500 	.word	0x08033500
 8014430:	08033504 	.word	0x08033504
                case CRL_DIST_OID:
                    oid = extCrlDistOid;
 8014434:	4b89      	ldr	r3, [pc, #548]	@ (801465c <OidFromId+0x5c0>)
 8014436:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCrlDistOid);
 8014438:	687b      	ldr	r3, [r7, #4]
 801443a:	2203      	movs	r2, #3
 801443c:	601a      	str	r2, [r3, #0]
                    break;
 801443e:	e030      	b.n	80144a2 <OidFromId+0x406>
                case AUTH_INFO_OID:
                    oid = extAuthInfoOid;
 8014440:	4b87      	ldr	r3, [pc, #540]	@ (8014660 <OidFromId+0x5c4>)
 8014442:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoOid);
 8014444:	687b      	ldr	r3, [r7, #4]
 8014446:	2208      	movs	r2, #8
 8014448:	601a      	str	r2, [r3, #0]
                    break;
 801444a:	e02a      	b.n	80144a2 <OidFromId+0x406>
                case AUTH_KEY_OID:
                    oid = extAuthKeyOid;
 801444c:	4b85      	ldr	r3, [pc, #532]	@ (8014664 <OidFromId+0x5c8>)
 801444e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthKeyOid);
 8014450:	687b      	ldr	r3, [r7, #4]
 8014452:	2203      	movs	r2, #3
 8014454:	601a      	str	r2, [r3, #0]
                    break;
 8014456:	e024      	b.n	80144a2 <OidFromId+0x406>
                case SUBJ_KEY_OID:
                    oid = extSubjKeyOid;
 8014458:	4b83      	ldr	r3, [pc, #524]	@ (8014668 <OidFromId+0x5cc>)
 801445a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extSubjKeyOid);
 801445c:	687b      	ldr	r3, [r7, #4]
 801445e:	2203      	movs	r2, #3
 8014460:	601a      	str	r2, [r3, #0]
                    break;
 8014462:	e01e      	b.n	80144a2 <OidFromId+0x406>
                case CERT_POLICY_OID:
                    oid = extCertPolicyOid;
 8014464:	4b81      	ldr	r3, [pc, #516]	@ (801466c <OidFromId+0x5d0>)
 8014466:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCertPolicyOid);
 8014468:	687b      	ldr	r3, [r7, #4]
 801446a:	2203      	movs	r2, #3
 801446c:	601a      	str	r2, [r3, #0]
                    break;
 801446e:	e018      	b.n	80144a2 <OidFromId+0x406>
                case KEY_USAGE_OID:
                    oid = extKeyUsageOid;
 8014470:	4b7f      	ldr	r3, [pc, #508]	@ (8014670 <OidFromId+0x5d4>)
 8014472:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extKeyUsageOid);
 8014474:	687b      	ldr	r3, [r7, #4]
 8014476:	2203      	movs	r2, #3
 8014478:	601a      	str	r2, [r3, #0]
                    break;
 801447a:	e012      	b.n	80144a2 <OidFromId+0x406>
                case INHIBIT_ANY_OID:
                    oid = extInhibitAnyOid;
 801447c:	4b7d      	ldr	r3, [pc, #500]	@ (8014674 <OidFromId+0x5d8>)
 801447e:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extInhibitAnyOid);
 8014480:	687b      	ldr	r3, [r7, #4]
 8014482:	2203      	movs	r2, #3
 8014484:	601a      	str	r2, [r3, #0]
                    break;
 8014486:	e00c      	b.n	80144a2 <OidFromId+0x406>
                case EXT_KEY_USAGE_OID:
                    oid = extExtKeyUsageOid;
 8014488:	4b7b      	ldr	r3, [pc, #492]	@ (8014678 <OidFromId+0x5dc>)
 801448a:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageOid);
 801448c:	687b      	ldr	r3, [r7, #4]
 801448e:	2203      	movs	r2, #3
 8014490:	601a      	str	r2, [r3, #0]
                    break;
 8014492:	e006      	b.n	80144a2 <OidFromId+0x406>
            #ifndef IGNORE_NAME_CONSTRAINTS
                case NAME_CONS_OID:
                    oid = extNameConsOid;
 8014494:	4b79      	ldr	r3, [pc, #484]	@ (801467c <OidFromId+0x5e0>)
 8014496:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extNameConsOid);
 8014498:	687b      	ldr	r3, [r7, #4]
 801449a:	2203      	movs	r2, #3
 801449c:	601a      	str	r2, [r3, #0]
                    break;
 801449e:	e000      	b.n	80144a2 <OidFromId+0x406>
                    oid = extSubjInfoAccessOid;
                    *oidSz = sizeof(extSubjInfoAccessOid);
                    break;
            #endif
                default:
                    break;
 80144a0:	bf00      	nop
            }
            break;
 80144a2:	e0d5      	b.n	8014650 <OidFromId+0x5b4>
            }
            #endif
            break;

        case oidCertAuthInfoType:
            switch (id) {
 80144a4:	68fb      	ldr	r3, [r7, #12]
 80144a6:	2b74      	cmp	r3, #116	@ 0x74
 80144a8:	d003      	beq.n	80144b2 <OidFromId+0x416>
 80144aa:	68fb      	ldr	r3, [r7, #12]
 80144ac:	2b75      	cmp	r3, #117	@ 0x75
 80144ae:	d006      	beq.n	80144be <OidFromId+0x422>
                    oid = extAuthInfoCaRespOid;
                    *oidSz = sizeof(extAuthInfoCaRespOid);
                    break;
                #endif /* WOLFSSL_SUBJ_INFO_ACC */
                default:
                    break;
 80144b0:	e00b      	b.n	80144ca <OidFromId+0x42e>
                    oid = extAuthInfoOcspOid;
 80144b2:	4b73      	ldr	r3, [pc, #460]	@ (8014680 <OidFromId+0x5e4>)
 80144b4:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoOcspOid);
 80144b6:	687b      	ldr	r3, [r7, #4]
 80144b8:	2208      	movs	r2, #8
 80144ba:	601a      	str	r2, [r3, #0]
                    break;
 80144bc:	e005      	b.n	80144ca <OidFromId+0x42e>
                    oid = extAuthInfoCaIssuerOid;
 80144be:	4b71      	ldr	r3, [pc, #452]	@ (8014684 <OidFromId+0x5e8>)
 80144c0:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAuthInfoCaIssuerOid);
 80144c2:	687b      	ldr	r3, [r7, #4]
 80144c4:	2208      	movs	r2, #8
 80144c6:	601a      	str	r2, [r3, #0]
                    break;
 80144c8:	bf00      	nop
            }
            break;
 80144ca:	e0c1      	b.n	8014650 <OidFromId+0x5b4>

        case oidCertPolicyType:
            switch (id) {
 80144cc:	68fb      	ldr	r3, [r7, #12]
 80144ce:	2b92      	cmp	r3, #146	@ 0x92
 80144d0:	d105      	bne.n	80144de <OidFromId+0x442>
                case CP_ANY_OID:
                    oid = extCertPolicyAnyOid;
 80144d2:	4b6d      	ldr	r3, [pc, #436]	@ (8014688 <OidFromId+0x5ec>)
 80144d4:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extCertPolicyAnyOid);
 80144d6:	687b      	ldr	r3, [r7, #4]
 80144d8:	2204      	movs	r2, #4
 80144da:	601a      	str	r2, [r3, #0]
                    break;
 80144dc:	e000      	b.n	80144e0 <OidFromId+0x444>
                    oid = extCertPolicyFpkiPiviAuthOid;
                    *oidSz = sizeof(extCertPolicyFpkiPiviAuthOid);
                    break;
                #endif /* WOLFSSL_FPKI */
                default:
                    break;
 80144de:	bf00      	nop
            }
            break;
 80144e0:	e0b6      	b.n	8014650 <OidFromId+0x5b4>

        case oidCertAltNameType:
            switch (id) {
 80144e2:	68fb      	ldr	r3, [r7, #12]
 80144e4:	2b4f      	cmp	r3, #79	@ 0x4f
 80144e6:	d105      	bne.n	80144f4 <OidFromId+0x458>
                case HW_NAME_OID:
                    oid = extAltNamesHwNameOid;
 80144e8:	4b68      	ldr	r3, [pc, #416]	@ (801468c <OidFromId+0x5f0>)
 80144ea:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extAltNamesHwNameOid);
 80144ec:	687b      	ldr	r3, [r7, #4]
 80144ee:	2208      	movs	r2, #8
 80144f0:	601a      	str	r2, [r3, #0]
                    break;
 80144f2:	e000      	b.n	80144f6 <OidFromId+0x45a>
                default:
                    break;
 80144f4:	bf00      	nop
            }
            break;
 80144f6:	e0ab      	b.n	8014650 <OidFromId+0x5b4>

        case oidCertKeyUseType:
            switch (id) {
 80144f8:	68fb      	ldr	r3, [r7, #12]
 80144fa:	2b4f      	cmp	r3, #79	@ 0x4f
 80144fc:	d81c      	bhi.n	8014538 <OidFromId+0x49c>
 80144fe:	68fb      	ldr	r3, [r7, #12]
 8014500:	2b47      	cmp	r3, #71	@ 0x47
 8014502:	d346      	bcc.n	8014592 <OidFromId+0x4f6>
 8014504:	68fb      	ldr	r3, [r7, #12]
 8014506:	3b47      	subs	r3, #71	@ 0x47
 8014508:	2b08      	cmp	r3, #8
 801450a:	d842      	bhi.n	8014592 <OidFromId+0x4f6>
 801450c:	a201      	add	r2, pc, #4	@ (adr r2, 8014514 <OidFromId+0x478>)
 801450e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014512:	bf00      	nop
 8014514:	0801454b 	.word	0x0801454b
 8014518:	08014557 	.word	0x08014557
 801451c:	08014563 	.word	0x08014563
 8014520:	0801456f 	.word	0x0801456f
 8014524:	08014593 	.word	0x08014593
 8014528:	08014593 	.word	0x08014593
 801452c:	08014593 	.word	0x08014593
 8014530:	0801457b 	.word	0x0801457b
 8014534:	08014587 	.word	0x08014587
 8014538:	68fb      	ldr	r3, [r7, #12]
 801453a:	2b97      	cmp	r3, #151	@ 0x97
 801453c:	d129      	bne.n	8014592 <OidFromId+0x4f6>
                case EKU_ANY_OID:
                    oid = extExtKeyUsageAnyOid;
 801453e:	4b54      	ldr	r3, [pc, #336]	@ (8014690 <OidFromId+0x5f4>)
 8014540:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageAnyOid);
 8014542:	687b      	ldr	r3, [r7, #4]
 8014544:	2204      	movs	r2, #4
 8014546:	601a      	str	r2, [r3, #0]
                    break;
 8014548:	e024      	b.n	8014594 <OidFromId+0x4f8>
                case EKU_SERVER_AUTH_OID:
                    oid = extExtKeyUsageServerAuthOid;
 801454a:	4b52      	ldr	r3, [pc, #328]	@ (8014694 <OidFromId+0x5f8>)
 801454c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageServerAuthOid);
 801454e:	687b      	ldr	r3, [r7, #4]
 8014550:	2208      	movs	r2, #8
 8014552:	601a      	str	r2, [r3, #0]
                    break;
 8014554:	e01e      	b.n	8014594 <OidFromId+0x4f8>
                case EKU_CLIENT_AUTH_OID:
                    oid = extExtKeyUsageClientAuthOid;
 8014556:	4b50      	ldr	r3, [pc, #320]	@ (8014698 <OidFromId+0x5fc>)
 8014558:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageClientAuthOid);
 801455a:	687b      	ldr	r3, [r7, #4]
 801455c:	2208      	movs	r2, #8
 801455e:	601a      	str	r2, [r3, #0]
                    break;
 8014560:	e018      	b.n	8014594 <OidFromId+0x4f8>
                case EKU_CODESIGNING_OID:
                    oid = extExtKeyUsageCodeSigningOid;
 8014562:	4b4e      	ldr	r3, [pc, #312]	@ (801469c <OidFromId+0x600>)
 8014564:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageCodeSigningOid);
 8014566:	687b      	ldr	r3, [r7, #4]
 8014568:	2208      	movs	r2, #8
 801456a:	601a      	str	r2, [r3, #0]
                    break;
 801456c:	e012      	b.n	8014594 <OidFromId+0x4f8>
                case EKU_EMAILPROTECT_OID:
                    oid = extExtKeyUsageEmailProtectOid;
 801456e:	4b4c      	ldr	r3, [pc, #304]	@ (80146a0 <OidFromId+0x604>)
 8014570:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageEmailProtectOid);
 8014572:	687b      	ldr	r3, [r7, #4]
 8014574:	2208      	movs	r2, #8
 8014576:	601a      	str	r2, [r3, #0]
                    break;
 8014578:	e00c      	b.n	8014594 <OidFromId+0x4f8>
                case EKU_TIMESTAMP_OID:
                    oid = extExtKeyUsageTimestampOid;
 801457a:	4b4a      	ldr	r3, [pc, #296]	@ (80146a4 <OidFromId+0x608>)
 801457c:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageTimestampOid);
 801457e:	687b      	ldr	r3, [r7, #4]
 8014580:	2208      	movs	r2, #8
 8014582:	601a      	str	r2, [r3, #0]
                    break;
 8014584:	e006      	b.n	8014594 <OidFromId+0x4f8>
                case EKU_OCSP_SIGN_OID:
                    oid = extExtKeyUsageOcspSignOid;
 8014586:	4b48      	ldr	r3, [pc, #288]	@ (80146a8 <OidFromId+0x60c>)
 8014588:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(extExtKeyUsageOcspSignOid);
 801458a:	687b      	ldr	r3, [r7, #4]
 801458c:	2208      	movs	r2, #8
 801458e:	601a      	str	r2, [r3, #0]
                    break;
 8014590:	e000      	b.n	8014594 <OidFromId+0x4f8>
                    oid = extExtKeyUsageSshKpClientAuthOid;
                    *oidSz = sizeof(extExtKeyUsageSshKpClientAuthOid);
                    break;
                #endif /* WOLFSSL_WOLFSSH */
                default:
                    break;
 8014592:	bf00      	nop
            }
            break;
 8014594:	e05c      	b.n	8014650 <OidFromId+0x5b4>

        case oidKdfType:
            switch (id) {
 8014596:	68fb      	ldr	r3, [r7, #12]
 8014598:	f5b3 7f25 	cmp.w	r3, #660	@ 0x294
 801459c:	d105      	bne.n	80145aa <OidFromId+0x50e>
                case PBKDF2_OID:
                    oid = pbkdf2Oid;
 801459e:	4b43      	ldr	r3, [pc, #268]	@ (80146ac <OidFromId+0x610>)
 80145a0:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(pbkdf2Oid);
 80145a2:	687b      	ldr	r3, [r7, #4]
 80145a4:	2209      	movs	r2, #9
 80145a6:	601a      	str	r2, [r3, #0]
                    break;
 80145a8:	e000      	b.n	80145ac <OidFromId+0x510>
                default:
                    break;
 80145aa:	bf00      	nop
            }
            break;
 80145ac:	e050      	b.n	8014650 <OidFromId+0x5b4>

        case oidPBEType:
            switch (id) {
 80145ae:	68fb      	ldr	r3, [r7, #12]
 80145b0:	2b0d      	cmp	r3, #13
 80145b2:	d004      	beq.n	80145be <OidFromId+0x522>
 80145b4:	68fb      	ldr	r3, [r7, #12]
 80145b6:	f240 2295 	movw	r2, #661	@ 0x295
 80145ba:	4293      	cmp	r3, r2
 80145bc:	d105      	bne.n	80145ca <OidFromId+0x52e>
                    *oidSz = sizeof(pbe40Rc2Cbc);
                    break;
        #endif
                case PBES2_SUM:
                case PBES2:
                    oid = pbes2;
 80145be:	4b3c      	ldr	r3, [pc, #240]	@ (80146b0 <OidFromId+0x614>)
 80145c0:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(pbes2);
 80145c2:	687b      	ldr	r3, [r7, #4]
 80145c4:	2209      	movs	r2, #9
 80145c6:	601a      	str	r2, [r3, #0]
                    break;
 80145c8:	e000      	b.n	80145cc <OidFromId+0x530>
                default:
                    break;
 80145ca:	bf00      	nop
            }
            break;
 80145cc:	e040      	b.n	8014650 <OidFromId+0x5b4>

        case oidKeyWrapType:
            switch (id) {
 80145ce:	68fb      	ldr	r3, [r7, #12]
 80145d0:	f240 12c9 	movw	r2, #457	@ 0x1c9
 80145d4:	4293      	cmp	r3, r2
 80145d6:	d01a      	beq.n	801460e <OidFromId+0x572>
 80145d8:	68fb      	ldr	r3, [r7, #12]
 80145da:	f5b3 7fe5 	cmp.w	r3, #458	@ 0x1ca
 80145de:	d21c      	bcs.n	801461a <OidFromId+0x57e>
 80145e0:	68fb      	ldr	r3, [r7, #12]
 80145e2:	f240 12a1 	movw	r2, #417	@ 0x1a1
 80145e6:	4293      	cmp	r3, r2
 80145e8:	d005      	beq.n	80145f6 <OidFromId+0x55a>
 80145ea:	68fb      	ldr	r3, [r7, #12]
 80145ec:	f240 12b5 	movw	r2, #437	@ 0x1b5
 80145f0:	4293      	cmp	r3, r2
 80145f2:	d006      	beq.n	8014602 <OidFromId+0x566>
                    oid = wrapPwriKekOid;
                    *oidSz = sizeof(wrapPwriKekOid);
                    break;
            #endif
                default:
                    break;
 80145f4:	e011      	b.n	801461a <OidFromId+0x57e>
                    oid = wrapAes128Oid;
 80145f6:	4b2f      	ldr	r3, [pc, #188]	@ (80146b4 <OidFromId+0x618>)
 80145f8:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes128Oid);
 80145fa:	687b      	ldr	r3, [r7, #4]
 80145fc:	2209      	movs	r2, #9
 80145fe:	601a      	str	r2, [r3, #0]
                    break;
 8014600:	e00c      	b.n	801461c <OidFromId+0x580>
                    oid = wrapAes192Oid;
 8014602:	4b2d      	ldr	r3, [pc, #180]	@ (80146b8 <OidFromId+0x61c>)
 8014604:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes192Oid);
 8014606:	687b      	ldr	r3, [r7, #4]
 8014608:	2209      	movs	r2, #9
 801460a:	601a      	str	r2, [r3, #0]
                    break;
 801460c:	e006      	b.n	801461c <OidFromId+0x580>
                    oid = wrapAes256Oid;
 801460e:	4b2b      	ldr	r3, [pc, #172]	@ (80146bc <OidFromId+0x620>)
 8014610:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(wrapAes256Oid);
 8014612:	687b      	ldr	r3, [r7, #4]
 8014614:	2209      	movs	r2, #9
 8014616:	601a      	str	r2, [r3, #0]
                    break;
 8014618:	e000      	b.n	801461c <OidFromId+0x580>
                    break;
 801461a:	bf00      	nop
            }
            break;
 801461c:	e018      	b.n	8014650 <OidFromId+0x5b4>

        case oidCmsKeyAgreeType:
            switch (id) {
 801461e:	68fb      	ldr	r3, [r7, #12]
 8014620:	2bbd      	cmp	r3, #189	@ 0xbd
 8014622:	d105      	bne.n	8014630 <OidFromId+0x594>
                    *oidSz = sizeof(dhSinglePass_stdDH_sha224kdf_Oid);
                    break;
            #endif
            #ifndef NO_SHA256
                case dhSinglePass_stdDH_sha256kdf_scheme:
                    oid = dhSinglePass_stdDH_sha256kdf_Oid;
 8014624:	4b26      	ldr	r3, [pc, #152]	@ (80146c0 <OidFromId+0x624>)
 8014626:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(dhSinglePass_stdDH_sha256kdf_Oid);
 8014628:	687b      	ldr	r3, [r7, #4]
 801462a:	2206      	movs	r2, #6
 801462c:	601a      	str	r2, [r3, #0]
                    break;
 801462e:	e000      	b.n	8014632 <OidFromId+0x596>
                    oid = dhSinglePass_stdDH_sha512kdf_Oid;
                    *oidSz = sizeof(dhSinglePass_stdDH_sha512kdf_Oid);
                    break;
            #endif
                default:
                    break;
 8014630:	bf00      	nop
            }
            break;
 8014632:	e00d      	b.n	8014650 <OidFromId+0x5b4>

#ifndef NO_HMAC
        case oidHmacType:
            switch (id) {
 8014634:	68fb      	ldr	r3, [r7, #12]
 8014636:	f240 228d 	movw	r2, #653	@ 0x28d
 801463a:	4293      	cmp	r3, r2
 801463c:	d105      	bne.n	801464a <OidFromId+0x5ae>
                    *oidSz = sizeof(hmacSha224Oid);
                    break;
        #endif
        #ifndef NO_SHA256
                case HMAC_SHA256_OID:
                    oid = hmacSha256Oid;
 801463e:	4b21      	ldr	r3, [pc, #132]	@ (80146c4 <OidFromId+0x628>)
 8014640:	617b      	str	r3, [r7, #20]
                    *oidSz = sizeof(hmacSha256Oid);
 8014642:	687b      	ldr	r3, [r7, #4]
 8014644:	2208      	movs	r2, #8
 8014646:	601a      	str	r2, [r3, #0]
                    break;
 8014648:	e000      	b.n	801464c <OidFromId+0x5b0>
                    oid = hmacSha512Oid;
                    *oidSz = sizeof(hmacSha512Oid);
                    break;
        #endif
                default:
                    break;
 801464a:	bf00      	nop
            }
            break;
 801464c:	e000      	b.n	8014650 <OidFromId+0x5b4>
            }
            break;
#endif /* WOLFSSL_SUBJ_DIR_ATTR */
        case oidIgnoreType:
        default:
            break;
 801464e:	bf00      	nop
    }

    return oid;
 8014650:	697b      	ldr	r3, [r7, #20]
}
 8014652:	4618      	mov	r0, r3
 8014654:	3718      	adds	r7, #24
 8014656:	46bd      	mov	sp, r7
 8014658:	bd80      	pop	{r7, pc}
 801465a:	bf00      	nop
 801465c:	08033508 	.word	0x08033508
 8014660:	0803350c 	.word	0x0803350c
 8014664:	08033514 	.word	0x08033514
 8014668:	08033518 	.word	0x08033518
 801466c:	0803351c 	.word	0x0803351c
 8014670:	08033520 	.word	0x08033520
 8014674:	08033524 	.word	0x08033524
 8014678:	08033528 	.word	0x08033528
 801467c:	0803352c 	.word	0x0803352c
 8014680:	08033530 	.word	0x08033530
 8014684:	08033538 	.word	0x08033538
 8014688:	08033540 	.word	0x08033540
 801468c:	08033544 	.word	0x08033544
 8014690:	0803354c 	.word	0x0803354c
 8014694:	08033550 	.word	0x08033550
 8014698:	08033558 	.word	0x08033558
 801469c:	08033560 	.word	0x08033560
 80146a0:	08033568 	.word	0x08033568
 80146a4:	08033570 	.word	0x08033570
 80146a8:	08033578 	.word	0x08033578
 80146ac:	0803358c 	.word	0x0803358c
 80146b0:	08033598 	.word	0x08033598
 80146b4:	080334d4 	.word	0x080334d4
 80146b8:	080334e0 	.word	0x080334e0
 80146bc:	080334ec 	.word	0x080334ec
 80146c0:	080334f8 	.word	0x080334f8
 80146c4:	08033438 	.word	0x08033438

080146c8 <CheckCurve>:
 * @param [in]  oid  OID id.
 * @return  ECC set id on success.
 * @return  ECC_CURVE_OID_E when OID id is 0 or not supported.
 */
static int CheckCurve(word32 oid)
{
 80146c8:	b580      	push	{r7, lr}
 80146ca:	b084      	sub	sp, #16
 80146cc:	af00      	add	r7, sp, #0
 80146ce:	6078      	str	r0, [r7, #4]
    int ret;
    word32 oidSz;

    /* Lookup OID id. */
    ret = wc_ecc_get_oid(oid, NULL, &oidSz);
 80146d0:	f107 0308 	add.w	r3, r7, #8
 80146d4:	461a      	mov	r2, r3
 80146d6:	2100      	movs	r1, #0
 80146d8:	6878      	ldr	r0, [r7, #4]
 80146da:	f009 fdf3 	bl	801e2c4 <wc_ecc_get_oid>
 80146de:	60f8      	str	r0, [r7, #12]
    /* Check for error or zero length OID size (can't get OID for encoding). */
    if ((ret < 0) || (oidSz == 0)) {
 80146e0:	68fb      	ldr	r3, [r7, #12]
 80146e2:	2b00      	cmp	r3, #0
 80146e4:	db02      	blt.n	80146ec <CheckCurve+0x24>
 80146e6:	68bb      	ldr	r3, [r7, #8]
 80146e8:	2b00      	cmp	r3, #0
 80146ea:	d102      	bne.n	80146f2 <CheckCurve+0x2a>
        WOLFSSL_MSG("CheckCurve not found");
        WOLFSSL_ERROR_VERBOSE(ECC_CURVE_OID_E);
        ret = ECC_CURVE_OID_E;
 80146ec:	f06f 03ab 	mvn.w	r3, #171	@ 0xab
 80146f0:	60fb      	str	r3, [r7, #12]
    }

    /* Return ECC set id or error code. */
    return ret;
 80146f2:	68fb      	ldr	r3, [r7, #12]
}
 80146f4:	4618      	mov	r0, r3
 80146f6:	3710      	adds	r7, #16
 80146f8:	46bd      	mov	sp, r7
 80146fa:	bd80      	pop	{r7, pc}

080146fc <GetOID>:
 * @return  BUFFER_E when not enough bytes for proper decode. (ASN_DUMP_OID and
 *          HAVE_OID_DECODING)
 */
static int GetOID(const byte* input, word32* inOutIdx, word32* oid,
                  word32 oidType, int length)
{
 80146fc:	b580      	push	{r7, lr}
 80146fe:	b08a      	sub	sp, #40	@ 0x28
 8014700:	af00      	add	r7, sp, #0
 8014702:	60f8      	str	r0, [r7, #12]
 8014704:	60b9      	str	r1, [r7, #8]
 8014706:	607a      	str	r2, [r7, #4]
 8014708:	603b      	str	r3, [r7, #0]
    int    ret = 0;
 801470a:	2300      	movs	r3, #0
 801470c:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 idx = *inOutIdx;
 801470e:	68bb      	ldr	r3, [r7, #8]
 8014710:	681b      	ldr	r3, [r3, #0]
 8014712:	623b      	str	r3, [r7, #32]
#ifndef NO_VERIFY_OID
    word32 actualOidSz;
    const byte* actualOid;
    const byte* checkOid = NULL;
 8014714:	2300      	movs	r3, #0
 8014716:	61fb      	str	r3, [r7, #28]
#endif /* NO_VERIFY_OID */
#if defined(HAVE_SPHINCS)
    word32 found_collision = 0;
#endif
    (void)oidType;
    *oid = 0;
 8014718:	687b      	ldr	r3, [r7, #4]
 801471a:	2200      	movs	r2, #0
 801471c:	601a      	str	r2, [r3, #0]

#ifndef NO_VERIFY_OID
    /* Keep references to OID data and length for check. */
    actualOid = &input[idx];
 801471e:	68fa      	ldr	r2, [r7, #12]
 8014720:	6a3b      	ldr	r3, [r7, #32]
 8014722:	4413      	add	r3, r2
 8014724:	61bb      	str	r3, [r7, #24]
    actualOidSz = (word32)length;
 8014726:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014728:	617b      	str	r3, [r7, #20]
        found_collision = SPHINCS_FAST_LEVEL3k;
    }
#endif /* HAVE_SPHINCS */

    /* Sum it up for now. */
    while (length--) {
 801472a:	e00b      	b.n	8014744 <GetOID+0x48>
        /* odd HC08 compiler behavior here when input[idx++] */
        *oid += (word32)input[idx];
 801472c:	687b      	ldr	r3, [r7, #4]
 801472e:	681b      	ldr	r3, [r3, #0]
 8014730:	68f9      	ldr	r1, [r7, #12]
 8014732:	6a3a      	ldr	r2, [r7, #32]
 8014734:	440a      	add	r2, r1
 8014736:	7812      	ldrb	r2, [r2, #0]
 8014738:	441a      	add	r2, r3
 801473a:	687b      	ldr	r3, [r7, #4]
 801473c:	601a      	str	r2, [r3, #0]
        idx++;
 801473e:	6a3b      	ldr	r3, [r7, #32]
 8014740:	3301      	adds	r3, #1
 8014742:	623b      	str	r3, [r7, #32]
    while (length--) {
 8014744:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014746:	1e5a      	subs	r2, r3, #1
 8014748:	633a      	str	r2, [r7, #48]	@ 0x30
 801474a:	2b00      	cmp	r3, #0
 801474c:	d1ee      	bne.n	801472c <GetOID+0x30>
        *oid = found_collision;
    }
#endif /* HAVE_SPHINCS */

    /* Return the index after the OID data. */
    *inOutIdx = idx;
 801474e:	68bb      	ldr	r3, [r7, #8]
 8014750:	6a3a      	ldr	r2, [r7, #32]
 8014752:	601a      	str	r2, [r3, #0]

#ifndef NO_VERIFY_OID
    /* 'Ignore' type means we don't care which OID it is. */
    if (oidType != oidIgnoreType) {
 8014754:	683b      	ldr	r3, [r7, #0]
 8014756:	2b15      	cmp	r3, #21
 8014758:	d01e      	beq.n	8014798 <GetOID+0x9c>
        /* Get the OID data for the id-type. */
        checkOid = OidFromId(*oid, oidType, &checkOidSz);
 801475a:	687b      	ldr	r3, [r7, #4]
 801475c:	681b      	ldr	r3, [r3, #0]
 801475e:	f107 0210 	add.w	r2, r7, #16
 8014762:	6839      	ldr	r1, [r7, #0]
 8014764:	4618      	mov	r0, r3
 8014766:	f7ff fc99 	bl	801409c <OidFromId>
 801476a:	61f8      	str	r0, [r7, #28]
        /* TODO: Want to fail when checkOid is NULL.
         * Can't as too many situations where unknown OID is to be
         * supported. Extra parameter for must not be NULL?
         */
        /* Check that the OID data matches what we found for the OID id. */
        if ((ret == 0) && (checkOid != NULL) && ((checkOidSz != actualOidSz) ||
 801476c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801476e:	2b00      	cmp	r3, #0
 8014770:	d112      	bne.n	8014798 <GetOID+0x9c>
 8014772:	69fb      	ldr	r3, [r7, #28]
 8014774:	2b00      	cmp	r3, #0
 8014776:	d00f      	beq.n	8014798 <GetOID+0x9c>
 8014778:	693b      	ldr	r3, [r7, #16]
 801477a:	697a      	ldr	r2, [r7, #20]
 801477c:	429a      	cmp	r2, r3
 801477e:	d108      	bne.n	8014792 <GetOID+0x96>
                (XMEMCMP(actualOid, checkOid, checkOidSz) != 0))) {
 8014780:	693b      	ldr	r3, [r7, #16]
 8014782:	461a      	mov	r2, r3
 8014784:	69f9      	ldr	r1, [r7, #28]
 8014786:	69b8      	ldr	r0, [r7, #24]
 8014788:	f013 fe78 	bl	802847c <memcmp>
 801478c:	4603      	mov	r3, r0
        if ((ret == 0) && (checkOid != NULL) && ((checkOidSz != actualOidSz) ||
 801478e:	2b00      	cmp	r3, #0
 8014790:	d002      	beq.n	8014798 <GetOID+0x9c>
            WOLFSSL_MSG("OID Check Failed");
            WOLFSSL_ERROR_VERBOSE(ASN_UNKNOWN_OID_E);
            ret = ASN_UNKNOWN_OID_E;
 8014792:	f06f 0393 	mvn.w	r3, #147	@ 0x93
 8014796:	627b      	str	r3, [r7, #36]	@ 0x24
        }
    }
#endif /* NO_VERIFY_OID */

    return ret;
 8014798:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 801479a:	4618      	mov	r0, r3
 801479c:	3728      	adds	r7, #40	@ 0x28
 801479e:	46bd      	mov	sp, r7
 80147a0:	bd80      	pop	{r7, pc}
	...

080147a4 <GetAlgoIdImpl>:
#define algoIdASN_Length (sizeof(algoIdASN) / sizeof(ASNItem))
#endif

static int GetAlgoIdImpl(const byte* input, word32* inOutIdx, word32* oid,
                     word32 oidType, word32 maxIdx, byte *absentParams)
{
 80147a4:	b580      	push	{r7, lr}
 80147a6:	b08c      	sub	sp, #48	@ 0x30
 80147a8:	af04      	add	r7, sp, #16
 80147aa:	60f8      	str	r0, [r7, #12]
 80147ac:	60b9      	str	r1, [r7, #8]
 80147ae:	607a      	str	r2, [r7, #4]
 80147b0:	603b      	str	r3, [r7, #0]

    *inOutIdx = idx;

    return 0;
#else
    DECL_ASNGETDATA(dataASN, algoIdASN_Length);
 80147b2:	2300      	movs	r3, #0
 80147b4:	61fb      	str	r3, [r7, #28]
    int ret = 0;
 80147b6:	2300      	movs	r3, #0
 80147b8:	61bb      	str	r3, [r7, #24]

    WOLFSSL_ENTER("GetAlgoId");

    CALLOC_ASNGETDATA(dataASN, algoIdASN_Length, ret, NULL);
 80147ba:	69bb      	ldr	r3, [r7, #24]
 80147bc:	2b00      	cmp	r3, #0
 80147be:	d109      	bne.n	80147d4 <GetAlgoIdImpl+0x30>
 80147c0:	2054      	movs	r0, #84	@ 0x54
 80147c2:	f00a f967 	bl	801ea94 <wolfSSL_Malloc>
 80147c6:	61f8      	str	r0, [r7, #28]
 80147c8:	69fb      	ldr	r3, [r7, #28]
 80147ca:	2b00      	cmp	r3, #0
 80147cc:	d102      	bne.n	80147d4 <GetAlgoIdImpl+0x30>
 80147ce:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80147d2:	61bb      	str	r3, [r7, #24]
 80147d4:	69bb      	ldr	r3, [r7, #24]
 80147d6:	2b00      	cmp	r3, #0
 80147d8:	d104      	bne.n	80147e4 <GetAlgoIdImpl+0x40>
 80147da:	2254      	movs	r2, #84	@ 0x54
 80147dc:	2100      	movs	r1, #0
 80147de:	69f8      	ldr	r0, [r7, #28]
 80147e0:	f013 fe76 	bl	80284d0 <memset>
    if (ret == 0) {
 80147e4:	69bb      	ldr	r3, [r7, #24]
 80147e6:	2b00      	cmp	r3, #0
 80147e8:	d110      	bne.n	801480c <GetAlgoIdImpl+0x68>
        /* Set OID type expected. */
        GetASN_OID(&dataASN[ALGOIDASN_IDX_OID], oidType);
 80147ea:	69fb      	ldr	r3, [r7, #28]
 80147ec:	331c      	adds	r3, #28
 80147ee:	683a      	ldr	r2, [r7, #0]
 80147f0:	611a      	str	r2, [r3, #16]
        /* Decode the algorithm identifier. */
        ret = GetASN_Items(algoIdASN, dataASN, algoIdASN_Length, 0, input,
 80147f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80147f4:	9302      	str	r3, [sp, #8]
 80147f6:	68bb      	ldr	r3, [r7, #8]
 80147f8:	9301      	str	r3, [sp, #4]
 80147fa:	68fb      	ldr	r3, [r7, #12]
 80147fc:	9300      	str	r3, [sp, #0]
 80147fe:	2300      	movs	r3, #0
 8014800:	2203      	movs	r2, #3
 8014802:	69f9      	ldr	r1, [r7, #28]
 8014804:	4813      	ldr	r0, [pc, #76]	@ (8014854 <GetAlgoIdImpl+0xb0>)
 8014806:	f7fe ff81 	bl	801370c <GetASN_Items>
 801480a:	61b8      	str	r0, [r7, #24]
            inOutIdx, maxIdx);
    }
    if (ret == 0) {
 801480c:	69bb      	ldr	r3, [r7, #24]
 801480e:	2b00      	cmp	r3, #0
 8014810:	d10f      	bne.n	8014832 <GetAlgoIdImpl+0x8e>
        /* Return the OID id/sum. */
        *oid = dataASN[ALGOIDASN_IDX_OID].data.oid.sum;
 8014812:	69fb      	ldr	r3, [r7, #28]
 8014814:	331c      	adds	r3, #28
 8014816:	695a      	ldr	r2, [r3, #20]
 8014818:	687b      	ldr	r3, [r7, #4]
 801481a:	601a      	str	r2, [r3, #0]

        if ((absentParams != NULL) &&
 801481c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801481e:	2b00      	cmp	r3, #0
 8014820:	d007      	beq.n	8014832 <GetAlgoIdImpl+0x8e>
            (dataASN[ALGOIDASN_IDX_NULL].tag == ASN_TAG_NULL)) {
 8014822:	69fb      	ldr	r3, [r7, #28]
 8014824:	3338      	adds	r3, #56	@ 0x38
 8014826:	7e5b      	ldrb	r3, [r3, #25]
        if ((absentParams != NULL) &&
 8014828:	2b05      	cmp	r3, #5
 801482a:	d102      	bne.n	8014832 <GetAlgoIdImpl+0x8e>
            *absentParams = FALSE;
 801482c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801482e:	2200      	movs	r2, #0
 8014830:	701a      	strb	r2, [r3, #0]
        }
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8014832:	69fb      	ldr	r3, [r7, #28]
 8014834:	2b00      	cmp	r3, #0
 8014836:	d007      	beq.n	8014848 <GetAlgoIdImpl+0xa4>
 8014838:	69fb      	ldr	r3, [r7, #28]
 801483a:	617b      	str	r3, [r7, #20]
 801483c:	697b      	ldr	r3, [r7, #20]
 801483e:	2b00      	cmp	r3, #0
 8014840:	d002      	beq.n	8014848 <GetAlgoIdImpl+0xa4>
 8014842:	6978      	ldr	r0, [r7, #20]
 8014844:	f00a f942 	bl	801eacc <wolfSSL_Free>
    return ret;
 8014848:	69bb      	ldr	r3, [r7, #24]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801484a:	4618      	mov	r0, r3
 801484c:	3720      	adds	r7, #32
 801484e:	46bd      	mov	sp, r7
 8014850:	bd80      	pop	{r7, pc}
 8014852:	bf00      	nop
 8014854:	080335d4 	.word	0x080335d4

08014858 <GetAlgoId>:
 * @return  ASN_PARSE_E when encoding is invalid.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int GetAlgoId(const byte* input, word32* inOutIdx, word32* oid,
                     word32 oidType, word32 maxIdx)
{
 8014858:	b580      	push	{r7, lr}
 801485a:	b086      	sub	sp, #24
 801485c:	af02      	add	r7, sp, #8
 801485e:	60f8      	str	r0, [r7, #12]
 8014860:	60b9      	str	r1, [r7, #8]
 8014862:	607a      	str	r2, [r7, #4]
 8014864:	603b      	str	r3, [r7, #0]
    return GetAlgoIdImpl(input, inOutIdx, oid, oidType, maxIdx, NULL);
 8014866:	2300      	movs	r3, #0
 8014868:	9301      	str	r3, [sp, #4]
 801486a:	69bb      	ldr	r3, [r7, #24]
 801486c:	9300      	str	r3, [sp, #0]
 801486e:	683b      	ldr	r3, [r7, #0]
 8014870:	687a      	ldr	r2, [r7, #4]
 8014872:	68b9      	ldr	r1, [r7, #8]
 8014874:	68f8      	ldr	r0, [r7, #12]
 8014876:	f7ff ff95 	bl	80147a4 <GetAlgoIdImpl>
 801487a:	4603      	mov	r3, r0
}
 801487c:	4618      	mov	r0, r3
 801487e:	3710      	adds	r7, #16
 8014880:	46bd      	mov	sp, r7
 8014882:	bd80      	pop	{r7, pc}

08014884 <RsaPssHashOidToType>:
 * @param  [out]  type  Hash type.
 * @return  0 on success.
 * @return  ASN_PARSE_E when hash OID not supported for RSA PSS.
 */
static int RsaPssHashOidToType(word32 oid, enum wc_HashType* type)
{
 8014884:	b480      	push	{r7}
 8014886:	b085      	sub	sp, #20
 8014888:	af00      	add	r7, sp, #0
 801488a:	6078      	str	r0, [r7, #4]
 801488c:	6039      	str	r1, [r7, #0]
    int ret = 0;
 801488e:	2300      	movs	r3, #0
 8014890:	60fb      	str	r3, [r7, #12]

    switch (oid) {
 8014892:	687b      	ldr	r3, [r7, #4]
 8014894:	f5b3 7fcf 	cmp.w	r3, #414	@ 0x19e
 8014898:	d103      	bne.n	80148a2 <RsaPssHashOidToType+0x1e>
        *type = WC_HASH_TYPE_SHA224;
        break;
#endif
#ifndef NO_SHA256
    case SHA256h:
        *type = WC_HASH_TYPE_SHA256;
 801489a:	683b      	ldr	r3, [r7, #0]
 801489c:	2206      	movs	r2, #6
 801489e:	701a      	strb	r2, [r3, #0]
        break;
 80148a0:	e003      	b.n	80148aa <RsaPssHashOidToType+0x26>
        break;
    /* TODO: SHA512_224h */
    /* TODO: SHA512_256h */
#endif
    default:
        ret = ASN_PARSE_E;
 80148a2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80148a6:	60fb      	str	r3, [r7, #12]
        break;
 80148a8:	bf00      	nop
    }

    return ret;
 80148aa:	68fb      	ldr	r3, [r7, #12]
}
 80148ac:	4618      	mov	r0, r3
 80148ae:	3714      	adds	r7, #20
 80148b0:	46bd      	mov	sp, r7
 80148b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80148b6:	4770      	bx	lr

080148b8 <RsaPssHashOidToMgf1>:
 * @param  [out]  mgf   MGF type.
 * @return  0 on success.
 * @return  ASN_PARSE_E when hash OID not supported for RSA PSS.
 */
static int RsaPssHashOidToMgf1(word32 oid, int* mgf)
{
 80148b8:	b480      	push	{r7}
 80148ba:	b085      	sub	sp, #20
 80148bc:	af00      	add	r7, sp, #0
 80148be:	6078      	str	r0, [r7, #4]
 80148c0:	6039      	str	r1, [r7, #0]
    int ret = 0;
 80148c2:	2300      	movs	r3, #0
 80148c4:	60fb      	str	r3, [r7, #12]

    switch (oid) {
 80148c6:	687b      	ldr	r3, [r7, #4]
 80148c8:	f5b3 7fcf 	cmp.w	r3, #414	@ 0x19e
 80148cc:	d103      	bne.n	80148d6 <RsaPssHashOidToMgf1+0x1e>
        *mgf = WC_MGF1SHA224;
        break;
#endif
#ifndef NO_SHA256
    case SHA256h:
        *mgf = WC_MGF1SHA256;
 80148ce:	683b      	ldr	r3, [r7, #0]
 80148d0:	2201      	movs	r2, #1
 80148d2:	601a      	str	r2, [r3, #0]
        break;
 80148d4:	e003      	b.n	80148de <RsaPssHashOidToMgf1+0x26>
        break;
    /* TODO: SHA512_224h */
    /* TODO: SHA512_256h */
#endif
    default:
        ret = ASN_PARSE_E;
 80148d6:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80148da:	60fb      	str	r3, [r7, #12]
        break;
 80148dc:	bf00      	nop
    }

    return ret;
 80148de:	68fb      	ldr	r3, [r7, #12]
}
 80148e0:	4618      	mov	r0, r3
 80148e2:	3714      	adds	r7, #20
 80148e4:	46bd      	mov	sp, r7
 80148e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80148ea:	4770      	bx	lr

080148ec <RsaPssHashOidToSigOid>:
 * @param  [out]  sigOid  Signature OID to pass wto HashForSignature().
 * @return  0 on success.
 * @return  ASN_PARSE_E when hash OID not supported for RSA PSS.
 */
static int RsaPssHashOidToSigOid(word32 oid, word32* sigOid)
{
 80148ec:	b480      	push	{r7}
 80148ee:	b085      	sub	sp, #20
 80148f0:	af00      	add	r7, sp, #0
 80148f2:	6078      	str	r0, [r7, #4]
 80148f4:	6039      	str	r1, [r7, #0]
    int ret = 0;
 80148f6:	2300      	movs	r3, #0
 80148f8:	60fb      	str	r3, [r7, #12]

    switch (oid) {
 80148fa:	687b      	ldr	r3, [r7, #4]
 80148fc:	2b06      	cmp	r3, #6
 80148fe:	d104      	bne.n	801490a <RsaPssHashOidToSigOid+0x1e>
        *sigOid = CTC_SHA224wRSA;
        break;
#endif
#ifndef NO_SHA256
    case WC_HASH_TYPE_SHA256:
        *sigOid = CTC_SHA256wRSA;
 8014900:	683b      	ldr	r3, [r7, #0]
 8014902:	f240 228f 	movw	r2, #655	@ 0x28f
 8014906:	601a      	str	r2, [r3, #0]
        break;
 8014908:	e003      	b.n	8014912 <RsaPssHashOidToSigOid+0x26>
#endif
    /* TODO: SHA512_224h */
    /* TODO: SHA512_256h */
    /* Not supported by HashForSignature() */
    default:
        ret = ASN_PARSE_E;
 801490a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801490e:	60fb      	str	r3, [r7, #12]
        break;
 8014910:	bf00      	nop
    }

    return ret;
 8014912:	68fb      	ldr	r3, [r7, #12]
}
 8014914:	4618      	mov	r0, r3
 8014916:	3714      	adds	r7, #20
 8014918:	46bd      	mov	sp, r7
 801491a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801491e:	4770      	bx	lr

08014920 <DecodeRsaPssParams>:
 * @return  ASN_PARSE_E when the decoding fails.
 * @return  0 on success.
 */
static int DecodeRsaPssParams(const byte* params, word32 sz,
    enum wc_HashType* hash, int* mgf, int* saltLen)
{
 8014920:	b580      	push	{r7, lr}
 8014922:	b090      	sub	sp, #64	@ 0x40
 8014924:	af04      	add	r7, sp, #16
 8014926:	60f8      	str	r0, [r7, #12]
 8014928:	60b9      	str	r1, [r7, #8]
 801492a:	607a      	str	r2, [r7, #4]
 801492c:	603b      	str	r3, [r7, #0]
        ret = ASN_PARSE_E;
    }

    return ret;
#else
    DECL_ASNGETDATA(dataASN, rsaPssParamsASN_Length);
 801492e:	2300      	movs	r3, #0
 8014930:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int ret = 0;
 8014932:	2300      	movs	r3, #0
 8014934:	62bb      	str	r3, [r7, #40]	@ 0x28
    word16 sLen = 20;
 8014936:	2314      	movs	r3, #20
 8014938:	837b      	strh	r3, [r7, #26]

    if (params == NULL) {
 801493a:	68fb      	ldr	r3, [r7, #12]
 801493c:	2b00      	cmp	r3, #0
 801493e:	d102      	bne.n	8014946 <DecodeRsaPssParams+0x26>
        ret = BAD_FUNC_ARG;
 8014940:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014944:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    CALLOC_ASNGETDATA(dataASN, rsaPssParamsASN_Length, ret, NULL);
 8014946:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014948:	2b00      	cmp	r3, #0
 801494a:	d10a      	bne.n	8014962 <DecodeRsaPssParams+0x42>
 801494c:	f44f 70d2 	mov.w	r0, #420	@ 0x1a4
 8014950:	f00a f8a0 	bl	801ea94 <wolfSSL_Malloc>
 8014954:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8014956:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014958:	2b00      	cmp	r3, #0
 801495a:	d102      	bne.n	8014962 <DecodeRsaPssParams+0x42>
 801495c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014960:	62bb      	str	r3, [r7, #40]	@ 0x28
 8014962:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014964:	2b00      	cmp	r3, #0
 8014966:	d105      	bne.n	8014974 <DecodeRsaPssParams+0x54>
 8014968:	f44f 72d2 	mov.w	r2, #420	@ 0x1a4
 801496c:	2100      	movs	r1, #0
 801496e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8014970:	f013 fdae 	bl	80284d0 <memset>
    if (ret == 0) {
 8014974:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014976:	2b00      	cmp	r3, #0
 8014978:	d128      	bne.n	80149cc <DecodeRsaPssParams+0xac>
        word32 inOutIdx = 0;
 801497a:	2300      	movs	r3, #0
 801497c:	617b      	str	r3, [r7, #20]
        /* Default values. */
        *hash = WC_HASH_TYPE_SHA;
 801497e:	687b      	ldr	r3, [r7, #4]
 8014980:	2204      	movs	r2, #4
 8014982:	701a      	strb	r2, [r3, #0]
        *mgf = WC_MGF1SHA1;
 8014984:	683b      	ldr	r3, [r7, #0]
 8014986:	221a      	movs	r2, #26
 8014988:	601a      	str	r2, [r3, #0]

        /* Set OID type expected. */
        GetASN_OID(&dataASN[RSAPSSPARAMSASN_IDX_HASHOID], oidHashType);
 801498a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801498c:	3354      	adds	r3, #84	@ 0x54
 801498e:	2200      	movs	r2, #0
 8014990:	611a      	str	r2, [r3, #16]
        GetASN_OID(&dataASN[RSAPSSPARAMSASN_IDX_MGFHOID], oidHashType);
 8014992:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014994:	33fc      	adds	r3, #252	@ 0xfc
 8014996:	2200      	movs	r2, #0
 8014998:	611a      	str	r2, [r3, #16]
        /* Place the salt length into 16-bit var sLen. */
        GetASN_Int16Bit(&dataASN[RSAPSSPARAMSASN_IDX_SALTLENINT], &sLen);
 801499a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801499c:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 80149a0:	2202      	movs	r2, #2
 80149a2:	761a      	strb	r2, [r3, #24]
 80149a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80149a6:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 80149aa:	f107 021a 	add.w	r2, r7, #26
 80149ae:	609a      	str	r2, [r3, #8]
        /* Decode the algorithm identifier. */
        ret = GetASN_Items(rsaPssParamsASN, dataASN, rsaPssParamsASN_Length, 1,
 80149b0:	68bb      	ldr	r3, [r7, #8]
 80149b2:	9302      	str	r3, [sp, #8]
 80149b4:	f107 0314 	add.w	r3, r7, #20
 80149b8:	9301      	str	r3, [sp, #4]
 80149ba:	68fb      	ldr	r3, [r7, #12]
 80149bc:	9300      	str	r3, [sp, #0]
 80149be:	2301      	movs	r3, #1
 80149c0:	220f      	movs	r2, #15
 80149c2:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80149c4:	481e      	ldr	r0, [pc, #120]	@ (8014a40 <DecodeRsaPssParams+0x120>)
 80149c6:	f7fe fea1 	bl	801370c <GetASN_Items>
 80149ca:	62b8      	str	r0, [r7, #40]	@ 0x28
            params, &inOutIdx, sz);
    }
    if ((ret == 0) && (dataASN[RSAPSSPARAMSASN_IDX_HASHOID].tag != 0)) {
 80149cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80149ce:	2b00      	cmp	r3, #0
 80149d0:	d10d      	bne.n	80149ee <DecodeRsaPssParams+0xce>
 80149d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80149d4:	3354      	adds	r3, #84	@ 0x54
 80149d6:	7e5b      	ldrb	r3, [r3, #25]
 80149d8:	2b00      	cmp	r3, #0
 80149da:	d008      	beq.n	80149ee <DecodeRsaPssParams+0xce>
        word32 oid = dataASN[RSAPSSPARAMSASN_IDX_HASHOID].data.oid.sum;
 80149dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80149de:	3354      	adds	r3, #84	@ 0x54
 80149e0:	695b      	ldr	r3, [r3, #20]
 80149e2:	627b      	str	r3, [r7, #36]	@ 0x24
        ret = RsaPssHashOidToType(oid, hash);
 80149e4:	6879      	ldr	r1, [r7, #4]
 80149e6:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 80149e8:	f7ff ff4c 	bl	8014884 <RsaPssHashOidToType>
 80149ec:	62b8      	str	r0, [r7, #40]	@ 0x28
    }
    if ((ret == 0) && (dataASN[RSAPSSPARAMSASN_IDX_MGFHOID].tag != 0)) {
 80149ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80149f0:	2b00      	cmp	r3, #0
 80149f2:	d10d      	bne.n	8014a10 <DecodeRsaPssParams+0xf0>
 80149f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80149f6:	33fc      	adds	r3, #252	@ 0xfc
 80149f8:	7e5b      	ldrb	r3, [r3, #25]
 80149fa:	2b00      	cmp	r3, #0
 80149fc:	d008      	beq.n	8014a10 <DecodeRsaPssParams+0xf0>
        word32 oid = dataASN[RSAPSSPARAMSASN_IDX_MGFHOID].data.oid.sum;
 80149fe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014a00:	33fc      	adds	r3, #252	@ 0xfc
 8014a02:	695b      	ldr	r3, [r3, #20]
 8014a04:	623b      	str	r3, [r7, #32]
        ret = RsaPssHashOidToMgf1(oid, mgf);
 8014a06:	6839      	ldr	r1, [r7, #0]
 8014a08:	6a38      	ldr	r0, [r7, #32]
 8014a0a:	f7ff ff55 	bl	80148b8 <RsaPssHashOidToMgf1>
 8014a0e:	62b8      	str	r0, [r7, #40]	@ 0x28
    }
    if (ret == 0) {
 8014a10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014a12:	2b00      	cmp	r3, #0
 8014a14:	d103      	bne.n	8014a1e <DecodeRsaPssParams+0xfe>
        *saltLen = sLen;
 8014a16:	8b7b      	ldrh	r3, [r7, #26]
 8014a18:	461a      	mov	r2, r3
 8014a1a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014a1c:	601a      	str	r2, [r3, #0]
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8014a1e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014a20:	2b00      	cmp	r3, #0
 8014a22:	d007      	beq.n	8014a34 <DecodeRsaPssParams+0x114>
 8014a24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014a26:	61fb      	str	r3, [r7, #28]
 8014a28:	69fb      	ldr	r3, [r7, #28]
 8014a2a:	2b00      	cmp	r3, #0
 8014a2c:	d002      	beq.n	8014a34 <DecodeRsaPssParams+0x114>
 8014a2e:	69f8      	ldr	r0, [r7, #28]
 8014a30:	f00a f84c 	bl	801eacc <wolfSSL_Free>
    return ret;
 8014a34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8014a36:	4618      	mov	r0, r3
 8014a38:	3730      	adds	r7, #48	@ 0x30
 8014a3a:	46bd      	mov	sp, r7
 8014a3c:	bd80      	pop	{r7, pc}
 8014a3e:	bf00      	nop
 8014a40:	080335e0 	.word	0x080335e0

08014a44 <GetRsaInt>:
 * @param [in] idx  Index of number.
 * @return  A pointer to an mp_int when valid index.
 * @return  NULL when invalid index.
 */
static mp_int* GetRsaInt(RsaKey* key, int idx)
{
 8014a44:	b480      	push	{r7}
 8014a46:	b083      	sub	sp, #12
 8014a48:	af00      	add	r7, sp, #0
 8014a4a:	6078      	str	r0, [r7, #4]
 8014a4c:	6039      	str	r1, [r7, #0]
    /* Cast key to byte array to and use offset to get to mp_int field. */
    return (mp_int*)(((byte*)key) + rsaIntOffset[idx]);
 8014a4e:	4a06      	ldr	r2, [pc, #24]	@ (8014a68 <GetRsaInt+0x24>)
 8014a50:	683b      	ldr	r3, [r7, #0]
 8014a52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014a56:	687a      	ldr	r2, [r7, #4]
 8014a58:	4413      	add	r3, r2
}
 8014a5a:	4618      	mov	r0, r3
 8014a5c:	370c      	adds	r7, #12
 8014a5e:	46bd      	mov	sp, r7
 8014a60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a64:	4770      	bx	lr
 8014a66:	bf00      	nop
 8014a68:	200000b0 	.word	0x200000b0

08014a6c <_RsaPrivateKeyDecode>:
 * @return  MP_INIT_E when the unable to initialize an mp_int.
 * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
 */
static int _RsaPrivateKeyDecode(const byte* input, word32* inOutIdx,
    RsaKey* key, int* keySz, word32 inSz)
{
 8014a6c:	b590      	push	{r4, r7, lr}
 8014a6e:	b091      	sub	sp, #68	@ 0x44
 8014a70:	af04      	add	r7, sp, #16
 8014a72:	60f8      	str	r0, [r7, #12]
 8014a74:	60b9      	str	r1, [r7, #8]
 8014a76:	607a      	str	r2, [r7, #4]
 8014a78:	603b      	str	r3, [r7, #0]
    #endif
    }

    return 0;
#else
    DECL_ASNGETDATA(dataASN, rsaKeyASN_Length);
 8014a7a:	2300      	movs	r3, #0
 8014a7c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int        ret = 0;
 8014a7e:	2300      	movs	r3, #0
 8014a80:	62bb      	str	r3, [r7, #40]	@ 0x28
    byte       version = (byte)-1;
 8014a82:	23ff      	movs	r3, #255	@ 0xff
 8014a84:	76fb      	strb	r3, [r7, #27]
#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)
    word32 algId = 0;
 8014a86:	2300      	movs	r3, #0
 8014a88:	617b      	str	r3, [r7, #20]
#endif
    void*      heap = NULL;
 8014a8a:	2300      	movs	r3, #0
 8014a8c:	623b      	str	r3, [r7, #32]

    /* Check validity of parameters. */
    if ((inOutIdx == NULL) || (input == NULL) || ((key == NULL) &&
 8014a8e:	68bb      	ldr	r3, [r7, #8]
 8014a90:	2b00      	cmp	r3, #0
 8014a92:	d008      	beq.n	8014aa6 <_RsaPrivateKeyDecode+0x3a>
 8014a94:	68fb      	ldr	r3, [r7, #12]
 8014a96:	2b00      	cmp	r3, #0
 8014a98:	d005      	beq.n	8014aa6 <_RsaPrivateKeyDecode+0x3a>
 8014a9a:	687b      	ldr	r3, [r7, #4]
 8014a9c:	2b00      	cmp	r3, #0
 8014a9e:	d105      	bne.n	8014aac <_RsaPrivateKeyDecode+0x40>
 8014aa0:	683b      	ldr	r3, [r7, #0]
 8014aa2:	2b00      	cmp	r3, #0
 8014aa4:	d102      	bne.n	8014aac <_RsaPrivateKeyDecode+0x40>
            (keySz == NULL))) {
        ret = BAD_FUNC_ARG;
 8014aa6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014aaa:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    if ((ret == 0) && (key != NULL)) {
 8014aac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014aae:	2b00      	cmp	r3, #0
 8014ab0:	d108      	bne.n	8014ac4 <_RsaPrivateKeyDecode+0x58>
 8014ab2:	687b      	ldr	r3, [r7, #4]
 8014ab4:	2b00      	cmp	r3, #0
 8014ab6:	d005      	beq.n	8014ac4 <_RsaPrivateKeyDecode+0x58>
        heap = key->heap;
 8014ab8:	687b      	ldr	r3, [r7, #4]
 8014aba:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8014abe:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 8014ac2:	623b      	str	r3, [r7, #32]
    }

#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)
    if (ret == 0) {
 8014ac4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014ac6:	2b00      	cmp	r3, #0
 8014ac8:	d106      	bne.n	8014ad8 <_RsaPrivateKeyDecode+0x6c>
        /* if has pkcs8 header skip it */
        if (ToTraditionalInline_ex(input, inOutIdx, inSz, &algId) < 0) {
 8014aca:	f107 0314 	add.w	r3, r7, #20
 8014ace:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8014ad0:	68b9      	ldr	r1, [r7, #8]
 8014ad2:	68f8      	ldr	r0, [r7, #12]
 8014ad4:	f000 f9dc 	bl	8014e90 <ToTraditionalInline_ex>
        }
    }
#endif

    (void)heap;
    CALLOC_ASNGETDATA(dataASN, rsaKeyASN_Length, ret, heap);
 8014ad8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014ada:	2b00      	cmp	r3, #0
 8014adc:	d10a      	bne.n	8014af4 <_RsaPrivateKeyDecode+0x88>
 8014ade:	f44f 708c 	mov.w	r0, #280	@ 0x118
 8014ae2:	f009 ffd7 	bl	801ea94 <wolfSSL_Malloc>
 8014ae6:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8014ae8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014aea:	2b00      	cmp	r3, #0
 8014aec:	d102      	bne.n	8014af4 <_RsaPrivateKeyDecode+0x88>
 8014aee:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014af2:	62bb      	str	r3, [r7, #40]	@ 0x28
 8014af4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014af6:	2b00      	cmp	r3, #0
 8014af8:	d105      	bne.n	8014b06 <_RsaPrivateKeyDecode+0x9a>
 8014afa:	f44f 728c 	mov.w	r2, #280	@ 0x118
 8014afe:	2100      	movs	r1, #0
 8014b00:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8014b02:	f013 fce5 	bl	80284d0 <memset>

    if (ret == 0) {
 8014b06:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014b08:	2b00      	cmp	r3, #0
 8014b0a:	d13d      	bne.n	8014b88 <_RsaPrivateKeyDecode+0x11c>
        /* Register variable to hold version field. */
        GetASN_Int8Bit(&dataASN[RSAKEYASN_IDX_VER], &version);
 8014b0c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b0e:	331c      	adds	r3, #28
 8014b10:	2201      	movs	r2, #1
 8014b12:	761a      	strb	r2, [r3, #24]
 8014b14:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b16:	331c      	adds	r3, #28
 8014b18:	f107 021b 	add.w	r2, r7, #27
 8014b1c:	609a      	str	r2, [r3, #8]
    #else
        #define RSA_ASN_INTS        RSA_INTS
        /* Extracting all data from BER encoding. */
        #define RSA_ASN_COMPLETE    1
    #endif
        if (key != NULL) {
 8014b1e:	687b      	ldr	r3, [r7, #4]
 8014b20:	2b00      	cmp	r3, #0
 8014b22:	d024      	beq.n	8014b6e <_RsaPrivateKeyDecode+0x102>
            int i;
            /* Extract all public fields. */
            for (i = 0; i < RSA_ASN_INTS; i++) {
 8014b24:	2300      	movs	r3, #0
 8014b26:	627b      	str	r3, [r7, #36]	@ 0x24
 8014b28:	e01e      	b.n	8014b68 <_RsaPrivateKeyDecode+0xfc>
                GetASN_MP(&dataASN[(byte)RSAKEYASN_IDX_N + i],
 8014b2a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b2c:	3302      	adds	r3, #2
 8014b2e:	461a      	mov	r2, r3
 8014b30:	4613      	mov	r3, r2
 8014b32:	00db      	lsls	r3, r3, #3
 8014b34:	1a9b      	subs	r3, r3, r2
 8014b36:	009b      	lsls	r3, r3, #2
 8014b38:	461a      	mov	r2, r3
 8014b3a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b3c:	4413      	add	r3, r2
 8014b3e:	2208      	movs	r2, #8
 8014b40:	761a      	strb	r2, [r3, #24]
 8014b42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b44:	3302      	adds	r3, #2
 8014b46:	461a      	mov	r2, r3
 8014b48:	4613      	mov	r3, r2
 8014b4a:	00db      	lsls	r3, r3, #3
 8014b4c:	1a9b      	subs	r3, r3, r2
 8014b4e:	009b      	lsls	r3, r3, #2
 8014b50:	461a      	mov	r2, r3
 8014b52:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014b54:	189c      	adds	r4, r3, r2
 8014b56:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8014b58:	6878      	ldr	r0, [r7, #4]
 8014b5a:	f7ff ff73 	bl	8014a44 <GetRsaInt>
 8014b5e:	4603      	mov	r3, r0
 8014b60:	60a3      	str	r3, [r4, #8]
            for (i = 0; i < RSA_ASN_INTS; i++) {
 8014b62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b64:	3301      	adds	r3, #1
 8014b66:	627b      	str	r3, [r7, #36]	@ 0x24
 8014b68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b6a:	2b07      	cmp	r3, #7
 8014b6c:	dddd      	ble.n	8014b2a <_RsaPrivateKeyDecode+0xbe>
                    GetRsaInt(key, i));
            }
        }
        /* Parse BER encoding for RSA private key. */
        ret = GetASN_Items(rsaKeyASN, dataASN, rsaKeyASN_Length,
 8014b6e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014b70:	9302      	str	r3, [sp, #8]
 8014b72:	68bb      	ldr	r3, [r7, #8]
 8014b74:	9301      	str	r3, [sp, #4]
 8014b76:	68fb      	ldr	r3, [r7, #12]
 8014b78:	9300      	str	r3, [sp, #0]
 8014b7a:	2301      	movs	r3, #1
 8014b7c:	220a      	movs	r2, #10
 8014b7e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8014b80:	4822      	ldr	r0, [pc, #136]	@ (8014c0c <_RsaPrivateKeyDecode+0x1a0>)
 8014b82:	f7fe fdc3 	bl	801370c <GetASN_Items>
 8014b86:	62b8      	str	r0, [r7, #40]	@ 0x28
    }
    /* Check version: 0 - two prime, 1 - multi-prime
     * Multi-prime has optional sequence after coefficient for extra primes.
     * If extra primes, parsing will fail as not all the buffer was used.
     */
    if ((ret == 0) && (version > PKCS1v1)) {
 8014b88:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014b8a:	2b00      	cmp	r3, #0
 8014b8c:	d105      	bne.n	8014b9a <_RsaPrivateKeyDecode+0x12e>
 8014b8e:	7efb      	ldrb	r3, [r7, #27]
 8014b90:	2b01      	cmp	r3, #1
 8014b92:	d902      	bls.n	8014b9a <_RsaPrivateKeyDecode+0x12e>
        ret = ASN_PARSE_E;
 8014b94:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014b98:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
    if ((ret == 0) && (key != NULL)) {
 8014b9a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014b9c:	2b00      	cmp	r3, #0
 8014b9e:	d10a      	bne.n	8014bb6 <_RsaPrivateKeyDecode+0x14a>
 8014ba0:	687b      	ldr	r3, [r7, #4]
 8014ba2:	2b00      	cmp	r3, #0
 8014ba4:	d007      	beq.n	8014bb6 <_RsaPrivateKeyDecode+0x14a>
    #if !defined(WOLFSSL_RSA_PUBLIC_ONLY)
        /* RSA key object has all private key values. */
        key->type = RSA_PRIVATE;
 8014ba6:	687b      	ldr	r3, [r7, #4]
 8014ba8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8014bac:	461a      	mov	r2, r3
 8014bae:	2301      	movs	r3, #1
 8014bb0:	f8c2 3168 	str.w	r3, [r2, #360]	@ 0x168
 8014bb4:	e01a      	b.n	8014bec <_RsaPrivateKeyDecode+0x180>
    #ifdef WOLFSSL_XILINX_CRYPT
        if (wc_InitRsaHw(key) != 0)
            ret = BAD_STATE_E;
    #endif
    }
    else if (ret == 0) {
 8014bb6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014bb8:	2b00      	cmp	r3, #0
 8014bba:	d117      	bne.n	8014bec <_RsaPrivateKeyDecode+0x180>
        /* Not filling in key but do want key size. */
        *keySz = (int)dataASN[(byte)RSAKEYASN_IDX_N].length;
 8014bbc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014bbe:	3338      	adds	r3, #56	@ 0x38
 8014bc0:	685b      	ldr	r3, [r3, #4]
 8014bc2:	461a      	mov	r2, r3
 8014bc4:	683b      	ldr	r3, [r7, #0]
 8014bc6:	601a      	str	r2, [r3, #0]
        /* Check whether first byte of data is 0x00 and drop it. */
        if (input[(int)dataASN[RSAKEYASN_IDX_E].offset - *keySz] == 0) {
 8014bc8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014bca:	3354      	adds	r3, #84	@ 0x54
 8014bcc:	681b      	ldr	r3, [r3, #0]
 8014bce:	461a      	mov	r2, r3
 8014bd0:	683b      	ldr	r3, [r7, #0]
 8014bd2:	681b      	ldr	r3, [r3, #0]
 8014bd4:	1ad3      	subs	r3, r2, r3
 8014bd6:	461a      	mov	r2, r3
 8014bd8:	68fb      	ldr	r3, [r7, #12]
 8014bda:	4413      	add	r3, r2
 8014bdc:	781b      	ldrb	r3, [r3, #0]
 8014bde:	2b00      	cmp	r3, #0
 8014be0:	d104      	bne.n	8014bec <_RsaPrivateKeyDecode+0x180>
            (*keySz)--;
 8014be2:	683b      	ldr	r3, [r7, #0]
 8014be4:	681b      	ldr	r3, [r3, #0]
 8014be6:	1e5a      	subs	r2, r3, #1
 8014be8:	683b      	ldr	r3, [r7, #0]
 8014bea:	601a      	str	r2, [r3, #0]
        }
    }

    FREE_ASNGETDATA(dataASN, heap);
 8014bec:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014bee:	2b00      	cmp	r3, #0
 8014bf0:	d007      	beq.n	8014c02 <_RsaPrivateKeyDecode+0x196>
 8014bf2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014bf4:	61fb      	str	r3, [r7, #28]
 8014bf6:	69fb      	ldr	r3, [r7, #28]
 8014bf8:	2b00      	cmp	r3, #0
 8014bfa:	d002      	beq.n	8014c02 <_RsaPrivateKeyDecode+0x196>
 8014bfc:	69f8      	ldr	r0, [r7, #28]
 8014bfe:	f009 ff65 	bl	801eacc <wolfSSL_Free>
    return ret;
 8014c02:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8014c04:	4618      	mov	r0, r3
 8014c06:	3734      	adds	r7, #52	@ 0x34
 8014c08:	46bd      	mov	sp, r7
 8014c0a:	bd90      	pop	{r4, r7, pc}
 8014c0c:	0803361c 	.word	0x0803361c

08014c10 <wc_RsaPrivateKeyDecode>:
 * @return  MP_INIT_E when the unable to initialize an mp_int.
 * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
 */
int wc_RsaPrivateKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,
    word32 inSz)
{
 8014c10:	b580      	push	{r7, lr}
 8014c12:	b086      	sub	sp, #24
 8014c14:	af02      	add	r7, sp, #8
 8014c16:	60f8      	str	r0, [r7, #12]
 8014c18:	60b9      	str	r1, [r7, #8]
 8014c1a:	607a      	str	r2, [r7, #4]
 8014c1c:	603b      	str	r3, [r7, #0]
    if (key == NULL) {
 8014c1e:	687b      	ldr	r3, [r7, #4]
 8014c20:	2b00      	cmp	r3, #0
 8014c22:	d102      	bne.n	8014c2a <wc_RsaPrivateKeyDecode+0x1a>
        return BAD_FUNC_ARG;
 8014c24:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014c28:	e008      	b.n	8014c3c <wc_RsaPrivateKeyDecode+0x2c>
    }
    return _RsaPrivateKeyDecode(input, inOutIdx, key, NULL, inSz);
 8014c2a:	683b      	ldr	r3, [r7, #0]
 8014c2c:	9300      	str	r3, [sp, #0]
 8014c2e:	2300      	movs	r3, #0
 8014c30:	687a      	ldr	r2, [r7, #4]
 8014c32:	68b9      	ldr	r1, [r7, #8]
 8014c34:	68f8      	ldr	r0, [r7, #12]
 8014c36:	f7ff ff19 	bl	8014a6c <_RsaPrivateKeyDecode>
 8014c3a:	4603      	mov	r3, r0
}
 8014c3c:	4618      	mov	r0, r3
 8014c3e:	3710      	adds	r7, #16
 8014c40:	46bd      	mov	sp, r7
 8014c42:	bd80      	pop	{r7, pc}

08014c44 <wc_RsaPrivateKeyValidate>:
 * @return  MP_INIT_E when the unable to initialize an mp_int.
 * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
 */
int wc_RsaPrivateKeyValidate(const byte* input, word32* inOutIdx, int* keySz,
     word32 inSz)
{
 8014c44:	b580      	push	{r7, lr}
 8014c46:	b086      	sub	sp, #24
 8014c48:	af02      	add	r7, sp, #8
 8014c4a:	60f8      	str	r0, [r7, #12]
 8014c4c:	60b9      	str	r1, [r7, #8]
 8014c4e:	607a      	str	r2, [r7, #4]
 8014c50:	603b      	str	r3, [r7, #0]
    return _RsaPrivateKeyDecode(input, inOutIdx, NULL, keySz, inSz);
 8014c52:	683b      	ldr	r3, [r7, #0]
 8014c54:	9300      	str	r3, [sp, #0]
 8014c56:	687b      	ldr	r3, [r7, #4]
 8014c58:	2200      	movs	r2, #0
 8014c5a:	68b9      	ldr	r1, [r7, #8]
 8014c5c:	68f8      	ldr	r0, [r7, #12]
 8014c5e:	f7ff ff05 	bl	8014a6c <_RsaPrivateKeyDecode>
 8014c62:	4603      	mov	r3, r0
}
 8014c64:	4618      	mov	r0, r3
 8014c66:	3710      	adds	r7, #16
 8014c68:	46bd      	mov	sp, r7
 8014c6a:	bd80      	pop	{r7, pc}

08014c6c <ToTraditionalInline_ex2>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
int ToTraditionalInline_ex2(const byte* input, word32* inOutIdx, word32 sz,
                            word32* algId, word32* eccOid)
{
 8014c6c:	b580      	push	{r7, lr}
 8014c6e:	b094      	sub	sp, #80	@ 0x50
 8014c70:	af04      	add	r7, sp, #16
 8014c72:	60f8      	str	r0, [r7, #12]
 8014c74:	60b9      	str	r1, [r7, #8]
 8014c76:	607a      	str	r2, [r7, #4]
 8014c78:	603b      	str	r3, [r7, #0]

    *inOutIdx = idx;

    return length;
#else
    DECL_ASNGETDATA(dataASN, pkcs8KeyASN_Length);
 8014c7a:	2300      	movs	r3, #0
 8014c7c:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ret = 0;
 8014c7e:	2300      	movs	r3, #0
 8014c80:	63bb      	str	r3, [r7, #56]	@ 0x38
    word32 oid = 9;
 8014c82:	2309      	movs	r3, #9
 8014c84:	637b      	str	r3, [r7, #52]	@ 0x34
    byte version = 0;
 8014c86:	2300      	movs	r3, #0
 8014c88:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
    word32 idx;

    (void)eccOid;

    /* Check validity of parameters. */
    if (input == NULL || inOutIdx == NULL) {
 8014c8c:	68fb      	ldr	r3, [r7, #12]
 8014c8e:	2b00      	cmp	r3, #0
 8014c90:	d002      	beq.n	8014c98 <ToTraditionalInline_ex2+0x2c>
 8014c92:	68bb      	ldr	r3, [r7, #8]
 8014c94:	2b00      	cmp	r3, #0
 8014c96:	d102      	bne.n	8014c9e <ToTraditionalInline_ex2+0x32>
        return BAD_FUNC_ARG;
 8014c98:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014c9c:	e0f2      	b.n	8014e84 <ToTraditionalInline_ex2+0x218>
    }

    idx = *inOutIdx;
 8014c9e:	68bb      	ldr	r3, [r7, #8]
 8014ca0:	681b      	ldr	r3, [r3, #0]
 8014ca2:	61fb      	str	r3, [r7, #28]

    CALLOC_ASNGETDATA(dataASN, pkcs8KeyASN_Length, ret, NULL);
 8014ca4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014ca6:	2b00      	cmp	r3, #0
 8014ca8:	d109      	bne.n	8014cbe <ToTraditionalInline_ex2+0x52>
 8014caa:	20fc      	movs	r0, #252	@ 0xfc
 8014cac:	f009 fef2 	bl	801ea94 <wolfSSL_Malloc>
 8014cb0:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8014cb2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014cb4:	2b00      	cmp	r3, #0
 8014cb6:	d102      	bne.n	8014cbe <ToTraditionalInline_ex2+0x52>
 8014cb8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014cbc:	63bb      	str	r3, [r7, #56]	@ 0x38
 8014cbe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014cc0:	2b00      	cmp	r3, #0
 8014cc2:	d104      	bne.n	8014cce <ToTraditionalInline_ex2+0x62>
 8014cc4:	22fc      	movs	r2, #252	@ 0xfc
 8014cc6:	2100      	movs	r1, #0
 8014cc8:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8014cca:	f013 fc01 	bl	80284d0 <memset>

    if (ret == 0) {
 8014cce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014cd0:	2b00      	cmp	r3, #0
 8014cd2:	d11e      	bne.n	8014d12 <ToTraditionalInline_ex2+0xa6>
        /* Get version, check key type and curve type. */
        GetASN_Int8Bit(&dataASN[PKCS8KEYASN_IDX_VER], &version);
 8014cd4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014cd6:	331c      	adds	r3, #28
 8014cd8:	2201      	movs	r2, #1
 8014cda:	761a      	strb	r2, [r3, #24]
 8014cdc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014cde:	331c      	adds	r3, #28
 8014ce0:	f107 0223 	add.w	r2, r7, #35	@ 0x23
 8014ce4:	609a      	str	r2, [r3, #8]
        GetASN_OID(&dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_KEY], oidKeyType);
 8014ce6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014ce8:	3354      	adds	r3, #84	@ 0x54
 8014cea:	2202      	movs	r2, #2
 8014cec:	611a      	str	r2, [r3, #16]
        GetASN_OID(&dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE], oidCurveType);
 8014cee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014cf0:	3370      	adds	r3, #112	@ 0x70
 8014cf2:	2203      	movs	r2, #3
 8014cf4:	611a      	str	r2, [r3, #16]
        /* Parse data. */
        ret = GetASN_Items(pkcs8KeyASN, dataASN, pkcs8KeyASN_Length, 1, input,
 8014cf6:	687b      	ldr	r3, [r7, #4]
 8014cf8:	9302      	str	r3, [sp, #8]
 8014cfa:	f107 031c 	add.w	r3, r7, #28
 8014cfe:	9301      	str	r3, [sp, #4]
 8014d00:	68fb      	ldr	r3, [r7, #12]
 8014d02:	9300      	str	r3, [sp, #0]
 8014d04:	2301      	movs	r3, #1
 8014d06:	2209      	movs	r2, #9
 8014d08:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8014d0a:	4860      	ldr	r0, [pc, #384]	@ (8014e8c <ToTraditionalInline_ex2+0x220>)
 8014d0c:	f7fe fcfe 	bl	801370c <GetASN_Items>
 8014d10:	63b8      	str	r0, [r7, #56]	@ 0x38
                           &idx, sz);
    }

    if (ret == 0) {
 8014d12:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014d14:	2b00      	cmp	r3, #0
 8014d16:	d10a      	bne.n	8014d2e <ToTraditionalInline_ex2+0xc2>
        /* Key type OID. */
        oid = dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_KEY].data.oid.sum;
 8014d18:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d1a:	3354      	adds	r3, #84	@ 0x54
 8014d1c:	695b      	ldr	r3, [r3, #20]
 8014d1e:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Version 1 includes an optional public key.
         * If public key is included then the parsing will fail as it did not
         * use all the data.
         */
        if (version > PKCS8v1) {
 8014d20:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8014d24:	2b01      	cmp	r3, #1
 8014d26:	d902      	bls.n	8014d2e <ToTraditionalInline_ex2+0xc2>
            ret = ASN_PARSE_E;
 8014d28:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014d2c:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
    }
    if (ret == 0) {
 8014d2e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014d30:	2b00      	cmp	r3, #0
 8014d32:	f040 8089 	bne.w	8014e48 <ToTraditionalInline_ex2+0x1dc>
        switch (oid) {
 8014d36:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d38:	f240 228e 	movw	r2, #654	@ 0x28e
 8014d3c:	4293      	cmp	r3, r2
 8014d3e:	d025      	beq.n	8014d8c <ToTraditionalInline_ex2+0x120>
 8014d40:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d42:	f240 228e 	movw	r2, #654	@ 0x28e
 8014d46:	4293      	cmp	r3, r2
 8014d48:	d875      	bhi.n	8014e36 <ToTraditionalInline_ex2+0x1ca>
 8014d4a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d4c:	f240 2287 	movw	r2, #647	@ 0x287
 8014d50:	4293      	cmp	r3, r2
 8014d52:	d062      	beq.n	8014e1a <ToTraditionalInline_ex2+0x1ae>
 8014d54:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d56:	f5b3 7f22 	cmp.w	r3, #648	@ 0x288
 8014d5a:	d26c      	bcs.n	8014e36 <ToTraditionalInline_ex2+0x1ca>
 8014d5c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d5e:	f240 2206 	movw	r2, #518	@ 0x206
 8014d62:	4293      	cmp	r3, r2
 8014d64:	d046      	beq.n	8014df4 <ToTraditionalInline_ex2+0x188>
 8014d66:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014d68:	f240 2285 	movw	r2, #645	@ 0x285
 8014d6c:	4293      	cmp	r3, r2
 8014d6e:	d162      	bne.n	8014e36 <ToTraditionalInline_ex2+0x1ca>
    #ifndef NO_RSA
            case RSAk:
                /* Must have NULL item but not OBJECT_ID item. */
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag == 0) ||
 8014d70:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d72:	338c      	adds	r3, #140	@ 0x8c
 8014d74:	7e5b      	ldrb	r3, [r3, #25]
 8014d76:	2b00      	cmp	r3, #0
 8014d78:	d004      	beq.n	8014d84 <ToTraditionalInline_ex2+0x118>
                    (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE].tag != 0)) {
 8014d7a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d7c:	3370      	adds	r3, #112	@ 0x70
 8014d7e:	7e5b      	ldrb	r3, [r3, #25]
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag == 0) ||
 8014d80:	2b00      	cmp	r3, #0
 8014d82:	d05a      	beq.n	8014e3a <ToTraditionalInline_ex2+0x1ce>
                    ret = ASN_PARSE_E;
 8014d84:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014d88:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                break;
 8014d8a:	e056      	b.n	8014e3a <ToTraditionalInline_ex2+0x1ce>
        #ifdef WC_RSA_PSS
            case RSAPSSk:
                /* Must not have NULL item. */
                if (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) {
 8014d8c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d8e:	338c      	adds	r3, #140	@ 0x8c
 8014d90:	7e5b      	ldrb	r3, [r3, #25]
 8014d92:	2b00      	cmp	r3, #0
 8014d94:	d002      	beq.n	8014d9c <ToTraditionalInline_ex2+0x130>
                    ret = ASN_PARSE_E;
 8014d96:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014d9a:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                if (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_PARAM_SEQ].tag != 0) {
 8014d9c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014d9e:	33a8      	adds	r3, #168	@ 0xa8
 8014da0:	7e5b      	ldrb	r3, [r3, #25]
 8014da2:	2b00      	cmp	r3, #0
 8014da4:	d04b      	beq.n	8014e3e <ToTraditionalInline_ex2+0x1d2>
                    enum wc_HashType hash;
                    int mgf;
                    int saltLen;
                    const byte* params = GetASNItem_Addr(
 8014da6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014da8:	33a8      	adds	r3, #168	@ 0xa8
 8014daa:	681b      	ldr	r3, [r3, #0]
 8014dac:	68fa      	ldr	r2, [r7, #12]
 8014dae:	4413      	add	r3, r2
 8014db0:	633b      	str	r3, [r7, #48]	@ 0x30
                        dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_PARAM_SEQ], input);
                    word32 paramsSz = GetASNItem_Length(
 8014db2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014db4:	33a8      	adds	r3, #168	@ 0xa8
 8014db6:	685b      	ldr	r3, [r3, #4]
 8014db8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014dba:	32a8      	adds	r2, #168	@ 0xa8
 8014dbc:	6891      	ldr	r1, [r2, #8]
 8014dbe:	68fa      	ldr	r2, [r7, #12]
 8014dc0:	1a8a      	subs	r2, r1, r2
 8014dc2:	441a      	add	r2, r3
 8014dc4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014dc6:	33a8      	adds	r3, #168	@ 0xa8
 8014dc8:	681b      	ldr	r3, [r3, #0]
 8014dca:	1ad3      	subs	r3, r2, r3
 8014dcc:	62fb      	str	r3, [r7, #44]	@ 0x2c
                        dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_PARAM_SEQ], input);

                    /* Validate the private key parameters. */
                    ret = DecodeRsaPssParams(params, paramsSz, &hash, &mgf,
 8014dce:	f107 0114 	add.w	r1, r7, #20
 8014dd2:	f107 021b 	add.w	r2, r7, #27
 8014dd6:	f107 0310 	add.w	r3, r7, #16
 8014dda:	9300      	str	r3, [sp, #0]
 8014ddc:	460b      	mov	r3, r1
 8014dde:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8014de0:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8014de2:	f7ff fd9d 	bl	8014920 <DecodeRsaPssParams>
 8014de6:	63b8      	str	r0, [r7, #56]	@ 0x38
                        &saltLen);
                    if (ret != 0) {
 8014de8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014dea:	2b00      	cmp	r3, #0
 8014dec:	d027      	beq.n	8014e3e <ToTraditionalInline_ex2+0x1d2>
                        return ASN_PARSE_E;
 8014dee:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014df2:	e047      	b.n	8014e84 <ToTraditionalInline_ex2+0x218>
        #endif
    #endif
        #ifdef HAVE_ECC
            case ECDSAk:
                /* Must not have NULL item. */
                if (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) {
 8014df4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014df6:	338c      	adds	r3, #140	@ 0x8c
 8014df8:	7e5b      	ldrb	r3, [r3, #25]
 8014dfa:	2b00      	cmp	r3, #0
 8014dfc:	d002      	beq.n	8014e04 <ToTraditionalInline_ex2+0x198>
                    ret = ASN_PARSE_E;
 8014dfe:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014e02:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                if (eccOid != NULL) {
 8014e04:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8014e06:	2b00      	cmp	r3, #0
 8014e08:	d01b      	beq.n	8014e42 <ToTraditionalInline_ex2+0x1d6>
                    ASNGetData* oidCurve =
 8014e0a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e0c:	3370      	adds	r3, #112	@ 0x70
 8014e0e:	62bb      	str	r3, [r7, #40]	@ 0x28
                        &dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE];
                    *eccOid = oidCurve->data.oid.sum;
 8014e10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014e12:	695a      	ldr	r2, [r3, #20]
 8014e14:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8014e16:	601a      	str	r2, [r3, #0]
                }
                break;
 8014e18:	e013      	b.n	8014e42 <ToTraditionalInline_ex2+0x1d6>
                break;
        #endif
        #ifndef NO_DH
            case DHk:
                /* Neither NULL item nor OBJECT_ID item allowed. */
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) ||
 8014e1a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e1c:	338c      	adds	r3, #140	@ 0x8c
 8014e1e:	7e5b      	ldrb	r3, [r3, #25]
 8014e20:	2b00      	cmp	r3, #0
 8014e22:	d104      	bne.n	8014e2e <ToTraditionalInline_ex2+0x1c2>
                    (dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_OID_CURVE].tag != 0)) {
 8014e24:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e26:	3370      	adds	r3, #112	@ 0x70
 8014e28:	7e5b      	ldrb	r3, [r3, #25]
                if ((dataASN[PKCS8KEYASN_IDX_PKEY_ALGO_NULL].tag != 0) ||
 8014e2a:	2b00      	cmp	r3, #0
 8014e2c:	d00b      	beq.n	8014e46 <ToTraditionalInline_ex2+0x1da>
                    ret = ASN_PARSE_E;
 8014e2e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014e32:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
                break;
 8014e34:	e007      	b.n	8014e46 <ToTraditionalInline_ex2+0x1da>
        #endif
            /* DSAk not supported. */
            /* Falcon, Dilithium and Sphincs not supported. */
            /* Ignore OID lookup failures. */
            default:
                break;
 8014e36:	bf00      	nop
 8014e38:	e006      	b.n	8014e48 <ToTraditionalInline_ex2+0x1dc>
                break;
 8014e3a:	bf00      	nop
 8014e3c:	e004      	b.n	8014e48 <ToTraditionalInline_ex2+0x1dc>
                break;
 8014e3e:	bf00      	nop
 8014e40:	e002      	b.n	8014e48 <ToTraditionalInline_ex2+0x1dc>
                break;
 8014e42:	bf00      	nop
 8014e44:	e000      	b.n	8014e48 <ToTraditionalInline_ex2+0x1dc>
                break;
 8014e46:	bf00      	nop
        }
    }
    if (ret == 0) {
 8014e48:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8014e4a:	2b00      	cmp	r3, #0
 8014e4c:	d10e      	bne.n	8014e6c <ToTraditionalInline_ex2+0x200>
        /* Return algorithm id of internal key. */
        *algId = oid;
 8014e4e:	683b      	ldr	r3, [r7, #0]
 8014e50:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8014e52:	601a      	str	r2, [r3, #0]
        /* Return index to start of internal key. */
        *inOutIdx = GetASNItem_DataIdx(dataASN[PKCS8KEYASN_IDX_PKEY_DATA], input);
 8014e54:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e56:	33c4      	adds	r3, #196	@ 0xc4
 8014e58:	689a      	ldr	r2, [r3, #8]
 8014e5a:	68fb      	ldr	r3, [r7, #12]
 8014e5c:	1ad3      	subs	r3, r2, r3
 8014e5e:	461a      	mov	r2, r3
 8014e60:	68bb      	ldr	r3, [r7, #8]
 8014e62:	601a      	str	r2, [r3, #0]
        /* Return value is length of internal key. */
        ret = (int)dataASN[PKCS8KEYASN_IDX_PKEY_DATA].data.ref.length;
 8014e64:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e66:	33c4      	adds	r3, #196	@ 0xc4
 8014e68:	68db      	ldr	r3, [r3, #12]
 8014e6a:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8014e6c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e6e:	2b00      	cmp	r3, #0
 8014e70:	d007      	beq.n	8014e82 <ToTraditionalInline_ex2+0x216>
 8014e72:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014e74:	627b      	str	r3, [r7, #36]	@ 0x24
 8014e76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014e78:	2b00      	cmp	r3, #0
 8014e7a:	d002      	beq.n	8014e82 <ToTraditionalInline_ex2+0x216>
 8014e7c:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8014e7e:	f009 fe25 	bl	801eacc <wolfSSL_Free>
    return ret;
 8014e82:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif
}
 8014e84:	4618      	mov	r0, r3
 8014e86:	3740      	adds	r7, #64	@ 0x40
 8014e88:	46bd      	mov	sp, r7
 8014e8a:	bd80      	pop	{r7, pc}
 8014e8c:	08033644 	.word	0x08033644

08014e90 <ToTraditionalInline_ex>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
int ToTraditionalInline_ex(const byte* input, word32* inOutIdx, word32 sz,
                           word32* algId)
{
 8014e90:	b580      	push	{r7, lr}
 8014e92:	b086      	sub	sp, #24
 8014e94:	af02      	add	r7, sp, #8
 8014e96:	60f8      	str	r0, [r7, #12]
 8014e98:	60b9      	str	r1, [r7, #8]
 8014e9a:	607a      	str	r2, [r7, #4]
 8014e9c:	603b      	str	r3, [r7, #0]
    return ToTraditionalInline_ex2(input, inOutIdx, sz, algId, NULL);
 8014e9e:	2300      	movs	r3, #0
 8014ea0:	9300      	str	r3, [sp, #0]
 8014ea2:	683b      	ldr	r3, [r7, #0]
 8014ea4:	687a      	ldr	r2, [r7, #4]
 8014ea6:	68b9      	ldr	r1, [r7, #8]
 8014ea8:	68f8      	ldr	r0, [r7, #12]
 8014eaa:	f7ff fedf 	bl	8014c6c <ToTraditionalInline_ex2>
 8014eae:	4603      	mov	r3, r0
}
 8014eb0:	4618      	mov	r0, r3
 8014eb2:	3710      	adds	r7, #16
 8014eb4:	46bd      	mov	sp, r7
 8014eb6:	bd80      	pop	{r7, pc}

08014eb8 <wc_RsaPublicKeyDecode_ex>:
 * @return  ASN_BITSTR_E when the expected BIT_STRING tag is not found.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int wc_RsaPublicKeyDecode_ex(const byte* input, word32* inOutIdx, word32 inSz,
    const byte** n, word32* nSz, const byte** e, word32* eSz)
{
 8014eb8:	b580      	push	{r7, lr}
 8014eba:	b092      	sub	sp, #72	@ 0x48
 8014ebc:	af04      	add	r7, sp, #16
 8014ebe:	60f8      	str	r0, [r7, #12]
 8014ec0:	60b9      	str	r1, [r7, #8]
 8014ec2:	607a      	str	r2, [r7, #4]
 8014ec4:	603b      	str	r3, [r7, #0]
        *e = &input[*inOutIdx];
    *inOutIdx += (word32)length;

    return ret;
#else
    DECL_ASNGETDATA(dataASN, rsaPublicKeyASN_Length);
 8014ec6:	2300      	movs	r3, #0
 8014ec8:	637b      	str	r3, [r7, #52]	@ 0x34
    int ret = 0;
 8014eca:	2300      	movs	r3, #0
 8014ecc:	633b      	str	r3, [r7, #48]	@ 0x30
#ifdef WC_RSA_PSS
    word32 oid = RSAk;
 8014ece:	f240 2385 	movw	r3, #645	@ 0x285
 8014ed2:	62fb      	str	r3, [r7, #44]	@ 0x2c
#endif

    /* Check validity of parameters. */
    if (input == NULL || inOutIdx == NULL) {
 8014ed4:	68fb      	ldr	r3, [r7, #12]
 8014ed6:	2b00      	cmp	r3, #0
 8014ed8:	d002      	beq.n	8014ee0 <wc_RsaPublicKeyDecode_ex+0x28>
 8014eda:	68bb      	ldr	r3, [r7, #8]
 8014edc:	2b00      	cmp	r3, #0
 8014ede:	d102      	bne.n	8014ee6 <wc_RsaPublicKeyDecode_ex+0x2e>
        ret = BAD_FUNC_ARG;
 8014ee0:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8014ee4:	633b      	str	r3, [r7, #48]	@ 0x30
    }

    CALLOC_ASNGETDATA(dataASN, rsaPublicKeyASN_Length, ret, NULL);
 8014ee6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ee8:	2b00      	cmp	r3, #0
 8014eea:	d109      	bne.n	8014f00 <wc_RsaPublicKeyDecode_ex+0x48>
 8014eec:	20fc      	movs	r0, #252	@ 0xfc
 8014eee:	f009 fdd1 	bl	801ea94 <wolfSSL_Malloc>
 8014ef2:	6378      	str	r0, [r7, #52]	@ 0x34
 8014ef4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014ef6:	2b00      	cmp	r3, #0
 8014ef8:	d102      	bne.n	8014f00 <wc_RsaPublicKeyDecode_ex+0x48>
 8014efa:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8014efe:	633b      	str	r3, [r7, #48]	@ 0x30
 8014f00:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f02:	2b00      	cmp	r3, #0
 8014f04:	d104      	bne.n	8014f10 <wc_RsaPublicKeyDecode_ex+0x58>
 8014f06:	22fc      	movs	r2, #252	@ 0xfc
 8014f08:	2100      	movs	r1, #0
 8014f0a:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8014f0c:	f013 fae0 	bl	80284d0 <memset>

    if (ret == 0) {
 8014f10:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f12:	2b00      	cmp	r3, #0
 8014f14:	d122      	bne.n	8014f5c <wc_RsaPublicKeyDecode_ex+0xa4>
        /* Try decoding PKCS #1 public key by ignoring rest of ASN.1. */
        ret = GetASN_Items(&rsaPublicKeyASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_SEQ],
 8014f16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f18:	f103 01a8 	add.w	r1, r3, #168	@ 0xa8
 8014f1c:	687b      	ldr	r3, [r7, #4]
 8014f1e:	9302      	str	r3, [sp, #8]
 8014f20:	68bb      	ldr	r3, [r7, #8]
 8014f22:	9301      	str	r3, [sp, #4]
 8014f24:	68fb      	ldr	r3, [r7, #12]
 8014f26:	9300      	str	r3, [sp, #0]
 8014f28:	2300      	movs	r3, #0
 8014f2a:	2203      	movs	r2, #3
 8014f2c:	4851      	ldr	r0, [pc, #324]	@ (8015074 <wc_RsaPublicKeyDecode_ex+0x1bc>)
 8014f2e:	f7fe fbed 	bl	801370c <GetASN_Items>
 8014f32:	6338      	str	r0, [r7, #48]	@ 0x30
           &dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_SEQ],
           (int)(rsaPublicKeyASN_Length - RSAPUBLICKEYASN_IDX_PUBKEY_RSA_SEQ),
           0, input, inOutIdx, inSz);
        if (ret != 0) {
 8014f34:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f36:	2b00      	cmp	r3, #0
 8014f38:	d010      	beq.n	8014f5c <wc_RsaPublicKeyDecode_ex+0xa4>
            /* Didn't work - try whole SubjectKeyInfo instead. */
        #ifdef WC_RSA_PSS
            /* Could be RSA or RSA PSS key. */
            GetASN_OID(&dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID], oidKeyType);
 8014f3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f3c:	3338      	adds	r3, #56	@ 0x38
 8014f3e:	2202      	movs	r2, #2
 8014f40:	611a      	str	r2, [r3, #16]
            /* Set the OID to expect. */
            GetASN_ExpBuffer(&dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID],
                    keyRsaOid, sizeof(keyRsaOid));
        #endif
            /* Decode SubjectKeyInfo. */
            ret = GetASN_Items(rsaPublicKeyASN, dataASN,
 8014f42:	687b      	ldr	r3, [r7, #4]
 8014f44:	9302      	str	r3, [sp, #8]
 8014f46:	68bb      	ldr	r3, [r7, #8]
 8014f48:	9301      	str	r3, [sp, #4]
 8014f4a:	68fb      	ldr	r3, [r7, #12]
 8014f4c:	9300      	str	r3, [sp, #0]
 8014f4e:	2301      	movs	r3, #1
 8014f50:	2209      	movs	r2, #9
 8014f52:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8014f54:	4848      	ldr	r0, [pc, #288]	@ (8015078 <wc_RsaPublicKeyDecode_ex+0x1c0>)
 8014f56:	f7fe fbd9 	bl	801370c <GetASN_Items>
 8014f5a:	6338      	str	r0, [r7, #48]	@ 0x30
                               rsaPublicKeyASN_Length, 1, input, inOutIdx,
                               inSz);
        }
    }
#ifdef WC_RSA_PSS
    if ((ret == 0) && (dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID].tag != 0)) {
 8014f5c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f5e:	2b00      	cmp	r3, #0
 8014f60:	d115      	bne.n	8014f8e <wc_RsaPublicKeyDecode_ex+0xd6>
 8014f62:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f64:	3338      	adds	r3, #56	@ 0x38
 8014f66:	7e5b      	ldrb	r3, [r3, #25]
 8014f68:	2b00      	cmp	r3, #0
 8014f6a:	d010      	beq.n	8014f8e <wc_RsaPublicKeyDecode_ex+0xd6>
        /* Two possible OIDs supported - RSA and RSA PSS. */
        oid = dataASN[RSAPUBLICKEYASN_IDX_ALGOID_OID].data.oid.sum;
 8014f6c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f6e:	3338      	adds	r3, #56	@ 0x38
 8014f70:	695b      	ldr	r3, [r3, #20]
 8014f72:	62fb      	str	r3, [r7, #44]	@ 0x2c
        if ((oid != RSAk) && (oid != RSAPSSk)) {
 8014f74:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014f76:	f240 2285 	movw	r2, #645	@ 0x285
 8014f7a:	4293      	cmp	r3, r2
 8014f7c:	d007      	beq.n	8014f8e <wc_RsaPublicKeyDecode_ex+0xd6>
 8014f7e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014f80:	f240 228e 	movw	r2, #654	@ 0x28e
 8014f84:	4293      	cmp	r3, r2
 8014f86:	d002      	beq.n	8014f8e <wc_RsaPublicKeyDecode_ex+0xd6>
            ret = ASN_PARSE_E;
 8014f88:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014f8c:	633b      	str	r3, [r7, #48]	@ 0x30
        }
    }
    if ((ret == 0) && (dataASN[RSAPUBLICKEYASN_IDX_ALGOID_P_SEQ].tag != 0)) {
 8014f8e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f90:	2b00      	cmp	r3, #0
 8014f92:	d13b      	bne.n	801500c <wc_RsaPublicKeyDecode_ex+0x154>
 8014f94:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014f96:	3370      	adds	r3, #112	@ 0x70
 8014f98:	7e5b      	ldrb	r3, [r3, #25]
 8014f9a:	2b00      	cmp	r3, #0
 8014f9c:	d036      	beq.n	801500c <wc_RsaPublicKeyDecode_ex+0x154>
        /* Can't have NULL and SEQ. */
        if (dataASN[RSAPUBLICKEYASN_IDX_ALGOID_NULL].tag != 0) {
 8014f9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014fa0:	3354      	adds	r3, #84	@ 0x54
 8014fa2:	7e5b      	ldrb	r3, [r3, #25]
 8014fa4:	2b00      	cmp	r3, #0
 8014fa6:	d002      	beq.n	8014fae <wc_RsaPublicKeyDecode_ex+0xf6>
            ret = ASN_PARSE_E;
 8014fa8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014fac:	633b      	str	r3, [r7, #48]	@ 0x30
        }
        /* SEQ present only with RSA PSS. */
        if ((ret == 0) && (oid != RSAPSSk)) {
 8014fae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014fb0:	2b00      	cmp	r3, #0
 8014fb2:	d107      	bne.n	8014fc4 <wc_RsaPublicKeyDecode_ex+0x10c>
 8014fb4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8014fb6:	f240 228e 	movw	r2, #654	@ 0x28e
 8014fba:	4293      	cmp	r3, r2
 8014fbc:	d002      	beq.n	8014fc4 <wc_RsaPublicKeyDecode_ex+0x10c>
            ret = ASN_PARSE_E;
 8014fbe:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8014fc2:	633b      	str	r3, [r7, #48]	@ 0x30
        }
        if (ret == 0) {
 8014fc4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014fc6:	2b00      	cmp	r3, #0
 8014fc8:	d120      	bne.n	801500c <wc_RsaPublicKeyDecode_ex+0x154>
            enum wc_HashType hash;
            int mgf;
            int saltLen;
            const byte* params = GetASNItem_Addr(
 8014fca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014fcc:	3370      	adds	r3, #112	@ 0x70
 8014fce:	681b      	ldr	r3, [r3, #0]
 8014fd0:	68fa      	ldr	r2, [r7, #12]
 8014fd2:	4413      	add	r3, r2
 8014fd4:	62bb      	str	r3, [r7, #40]	@ 0x28
                dataASN[RSAPUBLICKEYASN_IDX_ALGOID_P_SEQ], input);
            word32 paramsSz = GetASNItem_Length(
 8014fd6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014fd8:	3370      	adds	r3, #112	@ 0x70
 8014fda:	685b      	ldr	r3, [r3, #4]
 8014fdc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8014fde:	3270      	adds	r2, #112	@ 0x70
 8014fe0:	6891      	ldr	r1, [r2, #8]
 8014fe2:	68fa      	ldr	r2, [r7, #12]
 8014fe4:	1a8a      	subs	r2, r1, r2
 8014fe6:	441a      	add	r2, r3
 8014fe8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8014fea:	3370      	adds	r3, #112	@ 0x70
 8014fec:	681b      	ldr	r3, [r3, #0]
 8014fee:	1ad3      	subs	r3, r2, r3
 8014ff0:	627b      	str	r3, [r7, #36]	@ 0x24
                dataASN[RSAPUBLICKEYASN_IDX_ALGOID_P_SEQ], input);

            /* Validate the private key parameters. */
            ret = DecodeRsaPssParams(params, paramsSz, &hash, &mgf, &saltLen);
 8014ff2:	f107 0118 	add.w	r1, r7, #24
 8014ff6:	f107 021f 	add.w	r2, r7, #31
 8014ffa:	f107 0314 	add.w	r3, r7, #20
 8014ffe:	9300      	str	r3, [sp, #0]
 8015000:	460b      	mov	r3, r1
 8015002:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8015004:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8015006:	f7ff fc8b 	bl	8014920 <DecodeRsaPssParams>
 801500a:	6338      	str	r0, [r7, #48]	@ 0x30
            /* TODO: store parameters so that usage can be checked. */
        }
    }
#endif
    if (ret == 0) {
 801500c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801500e:	2b00      	cmp	r3, #0
 8015010:	d11f      	bne.n	8015052 <wc_RsaPublicKeyDecode_ex+0x19a>
        /* Return the buffers and lengths asked for. */
        if (n != NULL) {
 8015012:	683b      	ldr	r3, [r7, #0]
 8015014:	2b00      	cmp	r3, #0
 8015016:	d004      	beq.n	8015022 <wc_RsaPublicKeyDecode_ex+0x16a>
            *n   = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_N].data.ref.data;
 8015018:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801501a:	33c4      	adds	r3, #196	@ 0xc4
 801501c:	689a      	ldr	r2, [r3, #8]
 801501e:	683b      	ldr	r3, [r7, #0]
 8015020:	601a      	str	r2, [r3, #0]
        }
        if (nSz != NULL) {
 8015022:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015024:	2b00      	cmp	r3, #0
 8015026:	d004      	beq.n	8015032 <wc_RsaPublicKeyDecode_ex+0x17a>
            *nSz = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_N].data.ref.length;
 8015028:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801502a:	33c4      	adds	r3, #196	@ 0xc4
 801502c:	68da      	ldr	r2, [r3, #12]
 801502e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015030:	601a      	str	r2, [r3, #0]
        }
        if (e != NULL) {
 8015032:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015034:	2b00      	cmp	r3, #0
 8015036:	d004      	beq.n	8015042 <wc_RsaPublicKeyDecode_ex+0x18a>
            *e   = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_E].data.ref.data;
 8015038:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801503a:	33e0      	adds	r3, #224	@ 0xe0
 801503c:	689a      	ldr	r2, [r3, #8]
 801503e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015040:	601a      	str	r2, [r3, #0]
        }
        if (eSz != NULL) {
 8015042:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015044:	2b00      	cmp	r3, #0
 8015046:	d004      	beq.n	8015052 <wc_RsaPublicKeyDecode_ex+0x19a>
            *eSz = dataASN[RSAPUBLICKEYASN_IDX_PUBKEY_RSA_E].data.ref.length;
 8015048:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801504a:	33e0      	adds	r3, #224	@ 0xe0
 801504c:	68da      	ldr	r2, [r3, #12]
 801504e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015050:	601a      	str	r2, [r3, #0]
        }
    }

    FREE_ASNGETDATA(dataASN, NULL);
 8015052:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015054:	2b00      	cmp	r3, #0
 8015056:	d007      	beq.n	8015068 <wc_RsaPublicKeyDecode_ex+0x1b0>
 8015058:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801505a:	623b      	str	r3, [r7, #32]
 801505c:	6a3b      	ldr	r3, [r7, #32]
 801505e:	2b00      	cmp	r3, #0
 8015060:	d002      	beq.n	8015068 <wc_RsaPublicKeyDecode_ex+0x1b0>
 8015062:	6a38      	ldr	r0, [r7, #32]
 8015064:	f009 fd32 	bl	801eacc <wolfSSL_Free>
    return ret;
 8015068:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801506a:	4618      	mov	r0, r3
 801506c:	3738      	adds	r7, #56	@ 0x38
 801506e:	46bd      	mov	sp, r7
 8015070:	bd80      	pop	{r7, pc}
 8015072:	bf00      	nop
 8015074:	08033680 	.word	0x08033680
 8015078:	08033668 	.word	0x08033668

0801507c <wc_RsaPublicKeyDecode>:
 * @return  ASN_BITSTR_E when the expected BIT_STRING tag is not found.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int wc_RsaPublicKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,
                       word32 inSz)
{
 801507c:	b590      	push	{r4, r7, lr}
 801507e:	b08f      	sub	sp, #60	@ 0x3c
 8015080:	af04      	add	r7, sp, #16
 8015082:	60f8      	str	r0, [r7, #12]
 8015084:	60b9      	str	r1, [r7, #8]
 8015086:	607a      	str	r2, [r7, #4]
 8015088:	603b      	str	r3, [r7, #0]
    int ret;
    const byte *n = NULL, *e = NULL;
 801508a:	2300      	movs	r3, #0
 801508c:	623b      	str	r3, [r7, #32]
 801508e:	2300      	movs	r3, #0
 8015090:	61fb      	str	r3, [r7, #28]
    word32 nSz = 0, eSz = 0;
 8015092:	2300      	movs	r3, #0
 8015094:	61bb      	str	r3, [r7, #24]
 8015096:	2300      	movs	r3, #0
 8015098:	617b      	str	r3, [r7, #20]

    if (key == NULL)
 801509a:	687b      	ldr	r3, [r7, #4]
 801509c:	2b00      	cmp	r3, #0
 801509e:	d102      	bne.n	80150a6 <wc_RsaPublicKeyDecode+0x2a>
        return BAD_FUNC_ARG;
 80150a0:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80150a4:	e01f      	b.n	80150e6 <wc_RsaPublicKeyDecode+0x6a>

    ret = wc_RsaPublicKeyDecode_ex(input, inOutIdx, inSz, &n, &nSz, &e, &eSz);
 80150a6:	f107 0220 	add.w	r2, r7, #32
 80150aa:	f107 0314 	add.w	r3, r7, #20
 80150ae:	9302      	str	r3, [sp, #8]
 80150b0:	f107 031c 	add.w	r3, r7, #28
 80150b4:	9301      	str	r3, [sp, #4]
 80150b6:	f107 0318 	add.w	r3, r7, #24
 80150ba:	9300      	str	r3, [sp, #0]
 80150bc:	4613      	mov	r3, r2
 80150be:	683a      	ldr	r2, [r7, #0]
 80150c0:	68b9      	ldr	r1, [r7, #8]
 80150c2:	68f8      	ldr	r0, [r7, #12]
 80150c4:	f7ff fef8 	bl	8014eb8 <wc_RsaPublicKeyDecode_ex>
 80150c8:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret == 0) {
 80150ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80150cc:	2b00      	cmp	r3, #0
 80150ce:	d109      	bne.n	80150e4 <wc_RsaPublicKeyDecode+0x68>
        ret = wc_RsaPublicKeyDecodeRaw(n, nSz, e, eSz, key);
 80150d0:	6a38      	ldr	r0, [r7, #32]
 80150d2:	69b9      	ldr	r1, [r7, #24]
 80150d4:	69fa      	ldr	r2, [r7, #28]
 80150d6:	697c      	ldr	r4, [r7, #20]
 80150d8:	687b      	ldr	r3, [r7, #4]
 80150da:	9300      	str	r3, [sp, #0]
 80150dc:	4623      	mov	r3, r4
 80150de:	f005 f813 	bl	801a108 <wc_RsaPublicKeyDecodeRaw>
 80150e2:	6278      	str	r0, [r7, #36]	@ 0x24
    }

    return ret;
 80150e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 80150e6:	4618      	mov	r0, r3
 80150e8:	372c      	adds	r7, #44	@ 0x2c
 80150ea:	46bd      	mov	sp, r7
 80150ec:	bd90      	pop	{r4, r7, pc}

080150ee <InitDecodedCert>:
 * @param [in]      inSz    Size of DER data in buffer in bytes.
 * @param [in]      heap    Dynamic memory hint.
 */
void InitDecodedCert(DecodedCert* cert,
                     const byte* source, word32 inSz, void* heap)
{
 80150ee:	b580      	push	{r7, lr}
 80150f0:	b086      	sub	sp, #24
 80150f2:	af02      	add	r7, sp, #8
 80150f4:	60f8      	str	r0, [r7, #12]
 80150f6:	60b9      	str	r1, [r7, #8]
 80150f8:	607a      	str	r2, [r7, #4]
 80150fa:	603b      	str	r3, [r7, #0]
    InitDecodedCert_ex(cert, source, inSz, heap, INVALID_DEVID);
 80150fc:	f06f 0301 	mvn.w	r3, #1
 8015100:	9300      	str	r3, [sp, #0]
 8015102:	683b      	ldr	r3, [r7, #0]
 8015104:	687a      	ldr	r2, [r7, #4]
 8015106:	68b9      	ldr	r1, [r7, #8]
 8015108:	68f8      	ldr	r0, [r7, #12]
 801510a:	f000 f804 	bl	8015116 <InitDecodedCert_ex>
}
 801510e:	bf00      	nop
 8015110:	3710      	adds	r7, #16
 8015112:	46bd      	mov	sp, r7
 8015114:	bd80      	pop	{r7, pc}

08015116 <InitDecodedCert_ex>:
 * @param [in]      heap    Dynamic memory hint.
 * @param [in]      devId   Crypto callback ID to use.
 */
void InitDecodedCert_ex(DecodedCert* cert,
                     const byte* source, word32 inSz, void* heap, int devId)
{
 8015116:	b580      	push	{r7, lr}
 8015118:	b084      	sub	sp, #16
 801511a:	af00      	add	r7, sp, #0
 801511c:	60f8      	str	r0, [r7, #12]
 801511e:	60b9      	str	r1, [r7, #8]
 8015120:	607a      	str	r2, [r7, #4]
 8015122:	603b      	str	r3, [r7, #0]
    if (cert != NULL) {
 8015124:	68fb      	ldr	r3, [r7, #12]
 8015126:	2b00      	cmp	r3, #0
 8015128:	d029      	beq.n	801517e <InitDecodedCert_ex+0x68>
        XMEMSET(cert, 0, sizeof(DecodedCert));
 801512a:	f44f 6297 	mov.w	r2, #1208	@ 0x4b8
 801512e:	2100      	movs	r1, #0
 8015130:	68f8      	ldr	r0, [r7, #12]
 8015132:	f013 f9cd 	bl	80284d0 <memset>

        cert->subjectCNEnc    = CTC_UTF8;
 8015136:	68fb      	ldr	r3, [r7, #12]
 8015138:	220c      	movs	r2, #12
 801513a:	f883 208c 	strb.w	r2, [r3, #140]	@ 0x8c
        cert->issuer[0]       = '\0';
 801513e:	68fb      	ldr	r3, [r7, #12]
 8015140:	2200      	movs	r2, #0
 8015142:	f883 208d 	strb.w	r2, [r3, #141]	@ 0x8d
        cert->subject[0]      = '\0';
 8015146:	68fb      	ldr	r3, [r7, #12]
 8015148:	2200      	movs	r2, #0
 801514a:	f883 21f5 	strb.w	r2, [r3, #501]	@ 0x1f5
        cert->source          = source;  /* don't own */
 801514e:	68fb      	ldr	r3, [r7, #12]
 8015150:	68ba      	ldr	r2, [r7, #8]
 8015152:	f8c3 2364 	str.w	r2, [r3, #868]	@ 0x364
        cert->maxIdx          = inSz;    /* can't go over this index */
 8015156:	68fb      	ldr	r3, [r7, #12]
 8015158:	687a      	ldr	r2, [r7, #4]
 801515a:	f8c3 236c 	str.w	r2, [r3, #876]	@ 0x36c
        cert->heap            = heap;
 801515e:	68fb      	ldr	r3, [r7, #12]
 8015160:	683a      	ldr	r2, [r7, #0]
 8015162:	f8c3 2370 	str.w	r2, [r3, #880]	@ 0x370
        cert->maxPathLen      = WOLFSSL_MAX_PATH_LEN;
 8015166:	68fb      	ldr	r3, [r7, #12]
 8015168:	227f      	movs	r2, #127	@ 0x7f
 801516a:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d
        cert->issuerOEnc     = CTC_UTF8;
        cert->issuerOUEnc    = CTC_UTF8;
    #endif /* WOLFSSL_HAVE_ISSUER_NAMES */
    #endif /* WOLFSSL_CERT_GEN || WOLFSSL_CERT_EXT */

        InitSignatureCtx(&cert->sigCtx, heap, devId);
 801516e:	68fb      	ldr	r3, [r7, #12]
 8015170:	f203 4374 	addw	r3, r3, #1140	@ 0x474
 8015174:	69ba      	ldr	r2, [r7, #24]
 8015176:	6839      	ldr	r1, [r7, #0]
 8015178:	4618      	mov	r0, r3
 801517a:	f000 ff6b 	bl	8016054 <InitSignatureCtx>
    }
}
 801517e:	bf00      	nop
 8015180:	3710      	adds	r7, #16
 8015182:	46bd      	mov	sp, r7
 8015184:	bd80      	pop	{r7, pc}

08015186 <FreeAltNames>:
 *
 * @param [in, out] altNames  Alternative names.
 * @param [in]      heap      Dynamic memory hint.
 */
void FreeAltNames(DNS_entry* altNames, void* heap)
{
 8015186:	b580      	push	{r7, lr}
 8015188:	b086      	sub	sp, #24
 801518a:	af00      	add	r7, sp, #0
 801518c:	6078      	str	r0, [r7, #4]
 801518e:	6039      	str	r1, [r7, #0]
    (void)heap;

    while (altNames) {
 8015190:	e015      	b.n	80151be <FreeAltNames+0x38>
        DNS_entry* tmp = altNames->next;
 8015192:	687b      	ldr	r3, [r7, #4]
 8015194:	681b      	ldr	r3, [r3, #0]
 8015196:	617b      	str	r3, [r7, #20]

        XFREE(altNames->name, heap, DYNAMIC_TYPE_ALTNAME);
 8015198:	687b      	ldr	r3, [r7, #4]
 801519a:	68db      	ldr	r3, [r3, #12]
 801519c:	613b      	str	r3, [r7, #16]
 801519e:	693b      	ldr	r3, [r7, #16]
 80151a0:	2b00      	cmp	r3, #0
 80151a2:	d002      	beq.n	80151aa <FreeAltNames+0x24>
 80151a4:	6938      	ldr	r0, [r7, #16]
 80151a6:	f009 fc91 	bl	801eacc <wolfSSL_Free>
        XFREE(altNames->ipString, heap, DYNAMIC_TYPE_ALTNAME);
    #endif
    #ifdef WOLFSSL_RID_ALT_NAME
        XFREE(altNames->ridString, heap, DYNAMIC_TYPE_ALTNAME);
    #endif
        XFREE(altNames,       heap, DYNAMIC_TYPE_ALTNAME);
 80151aa:	687b      	ldr	r3, [r7, #4]
 80151ac:	60fb      	str	r3, [r7, #12]
 80151ae:	68fb      	ldr	r3, [r7, #12]
 80151b0:	2b00      	cmp	r3, #0
 80151b2:	d002      	beq.n	80151ba <FreeAltNames+0x34>
 80151b4:	68f8      	ldr	r0, [r7, #12]
 80151b6:	f009 fc89 	bl	801eacc <wolfSSL_Free>
        altNames = tmp;
 80151ba:	697b      	ldr	r3, [r7, #20]
 80151bc:	607b      	str	r3, [r7, #4]
    while (altNames) {
 80151be:	687b      	ldr	r3, [r7, #4]
 80151c0:	2b00      	cmp	r3, #0
 80151c2:	d1e6      	bne.n	8015192 <FreeAltNames+0xc>
    }
}
 80151c4:	bf00      	nop
 80151c6:	bf00      	nop
 80151c8:	3718      	adds	r7, #24
 80151ca:	46bd      	mov	sp, r7
 80151cc:	bd80      	pop	{r7, pc}

080151ce <AltNameNew>:

/* malloc and initialize a new alt name structure */
DNS_entry* AltNameNew(void* heap)
{
 80151ce:	b580      	push	{r7, lr}
 80151d0:	b084      	sub	sp, #16
 80151d2:	af00      	add	r7, sp, #0
 80151d4:	6078      	str	r0, [r7, #4]
    DNS_entry* ret;
    ret = (DNS_entry*)XMALLOC(sizeof(DNS_entry), heap, DYNAMIC_TYPE_ALTNAME);
 80151d6:	2010      	movs	r0, #16
 80151d8:	f009 fc5c 	bl	801ea94 <wolfSSL_Malloc>
 80151dc:	60f8      	str	r0, [r7, #12]
    if (ret != NULL) {
 80151de:	68fb      	ldr	r3, [r7, #12]
 80151e0:	2b00      	cmp	r3, #0
 80151e2:	d004      	beq.n	80151ee <AltNameNew+0x20>
        XMEMSET(ret, 0, sizeof(DNS_entry));
 80151e4:	2210      	movs	r2, #16
 80151e6:	2100      	movs	r1, #0
 80151e8:	68f8      	ldr	r0, [r7, #12]
 80151ea:	f013 f971 	bl	80284d0 <memset>
    }
    (void)heap;
    return ret;
 80151ee:	68fb      	ldr	r3, [r7, #12]
}
 80151f0:	4618      	mov	r0, r3
 80151f2:	3710      	adds	r7, #16
 80151f4:	46bd      	mov	sp, r7
 80151f6:	bd80      	pop	{r7, pc}

080151f8 <AltNameDup>:

DNS_entry* AltNameDup(DNS_entry* from, void* heap)
{
 80151f8:	b580      	push	{r7, lr}
 80151fa:	b084      	sub	sp, #16
 80151fc:	af00      	add	r7, sp, #0
 80151fe:	6078      	str	r0, [r7, #4]
 8015200:	6039      	str	r1, [r7, #0]
    DNS_entry* ret;

    ret = AltNameNew(heap);
 8015202:	6838      	ldr	r0, [r7, #0]
 8015204:	f7ff ffe3 	bl	80151ce <AltNameNew>
 8015208:	60f8      	str	r0, [r7, #12]
    if (ret == NULL) {
 801520a:	68fb      	ldr	r3, [r7, #12]
 801520c:	2b00      	cmp	r3, #0
 801520e:	d101      	bne.n	8015214 <AltNameDup+0x1c>
        WOLFSSL_MSG("\tOut of Memory");
        return NULL;
 8015210:	2300      	movs	r3, #0
 8015212:	e01d      	b.n	8015250 <AltNameDup+0x58>
    }

    ret->type = from->type;
 8015214:	687b      	ldr	r3, [r7, #4]
 8015216:	685a      	ldr	r2, [r3, #4]
 8015218:	68fb      	ldr	r3, [r7, #12]
 801521a:	605a      	str	r2, [r3, #4]
    ret->len = from->len;
 801521c:	687b      	ldr	r3, [r7, #4]
 801521e:	689a      	ldr	r2, [r3, #8]
 8015220:	68fb      	ldr	r3, [r7, #12]
 8015222:	609a      	str	r2, [r3, #8]


    ret->name = CopyString(from->name, from->len, heap, DYNAMIC_TYPE_ALTNAME);
 8015224:	687b      	ldr	r3, [r7, #4]
 8015226:	68d8      	ldr	r0, [r3, #12]
 8015228:	687b      	ldr	r3, [r7, #4]
 801522a:	6899      	ldr	r1, [r3, #8]
 801522c:	231d      	movs	r3, #29
 801522e:	683a      	ldr	r2, [r7, #0]
 8015230:	f7fd fa5e 	bl	80126f0 <CopyString>
 8015234:	4602      	mov	r2, r0
 8015236:	68fb      	ldr	r3, [r7, #12]
 8015238:	60da      	str	r2, [r3, #12]
    ret->ipString = CopyString(from->ipString, 0, heap, DYNAMIC_TYPE_ALTNAME);
#endif
#ifdef WOLFSSL_RID_ALT_NAME
    ret->ridString = CopyString(from->ridString, 0, heap, DYNAMIC_TYPE_ALTNAME);
#endif
    if (ret->name == NULL
 801523a:	68fb      	ldr	r3, [r7, #12]
 801523c:	68db      	ldr	r3, [r3, #12]
 801523e:	2b00      	cmp	r3, #0
 8015240:	d105      	bne.n	801524e <AltNameDup+0x56>
#ifdef WOLFSSL_RID_ALT_NAME
            || (from->ridString != NULL && ret->ridString == NULL)
#endif
            ) {
        WOLFSSL_MSG("\tOut of Memory");
        FreeAltNames(ret, heap);
 8015242:	6839      	ldr	r1, [r7, #0]
 8015244:	68f8      	ldr	r0, [r7, #12]
 8015246:	f7ff ff9e 	bl	8015186 <FreeAltNames>
        return NULL;
 801524a:	2300      	movs	r3, #0
 801524c:	e000      	b.n	8015250 <AltNameDup+0x58>

#ifdef WOLFSSL_FPKI
    ret->oidSum = from->oidSum;
#endif

    return ret;
 801524e:	68fb      	ldr	r3, [r7, #12]
}
 8015250:	4618      	mov	r0, r3
 8015252:	3710      	adds	r7, #16
 8015254:	46bd      	mov	sp, r7
 8015256:	bd80      	pop	{r7, pc}

08015258 <FreeNameSubtrees>:
 *
 * @param [in, out] names  Subtree names.
 * @param [in]      heap   Dynamic memory hint.
 */
void FreeNameSubtrees(Base_entry* names, void* heap)
{
 8015258:	b580      	push	{r7, lr}
 801525a:	b086      	sub	sp, #24
 801525c:	af00      	add	r7, sp, #0
 801525e:	6078      	str	r0, [r7, #4]
 8015260:	6039      	str	r1, [r7, #0]
    (void)heap;

    while (names) {
 8015262:	e015      	b.n	8015290 <FreeNameSubtrees+0x38>
        Base_entry* tmp = names->next;
 8015264:	687b      	ldr	r3, [r7, #4]
 8015266:	681b      	ldr	r3, [r3, #0]
 8015268:	617b      	str	r3, [r7, #20]

        XFREE(names->name, heap, DYNAMIC_TYPE_ALTNAME);
 801526a:	687b      	ldr	r3, [r7, #4]
 801526c:	685b      	ldr	r3, [r3, #4]
 801526e:	613b      	str	r3, [r7, #16]
 8015270:	693b      	ldr	r3, [r7, #16]
 8015272:	2b00      	cmp	r3, #0
 8015274:	d002      	beq.n	801527c <FreeNameSubtrees+0x24>
 8015276:	6938      	ldr	r0, [r7, #16]
 8015278:	f009 fc28 	bl	801eacc <wolfSSL_Free>
        XFREE(names,       heap, DYNAMIC_TYPE_ALTNAME);
 801527c:	687b      	ldr	r3, [r7, #4]
 801527e:	60fb      	str	r3, [r7, #12]
 8015280:	68fb      	ldr	r3, [r7, #12]
 8015282:	2b00      	cmp	r3, #0
 8015284:	d002      	beq.n	801528c <FreeNameSubtrees+0x34>
 8015286:	68f8      	ldr	r0, [r7, #12]
 8015288:	f009 fc20 	bl	801eacc <wolfSSL_Free>
        names = tmp;
 801528c:	697b      	ldr	r3, [r7, #20]
 801528e:	607b      	str	r3, [r7, #4]
    while (names) {
 8015290:	687b      	ldr	r3, [r7, #4]
 8015292:	2b00      	cmp	r3, #0
 8015294:	d1e6      	bne.n	8015264 <FreeNameSubtrees+0xc>
    }
}
 8015296:	bf00      	nop
 8015298:	bf00      	nop
 801529a:	3718      	adds	r7, #24
 801529c:	46bd      	mov	sp, r7
 801529e:	bd80      	pop	{r7, pc}

080152a0 <FreeDecodedCert>:
/* Free the decoded cert object's dynamic data.
 *
 * @param [in, out] cert  Decoded certificate object.
 */
void FreeDecodedCert(DecodedCert* cert)
{
 80152a0:	b580      	push	{r7, lr}
 80152a2:	b084      	sub	sp, #16
 80152a4:	af00      	add	r7, sp, #0
 80152a6:	6078      	str	r0, [r7, #4]
    if (cert == NULL)
 80152a8:	687b      	ldr	r3, [r7, #4]
 80152aa:	2b00      	cmp	r3, #0
 80152ac:	f000 8085 	beq.w	80153ba <FreeDecodedCert+0x11a>
        return;
    if (cert->subjectCNStored == 1) {
 80152b0:	687b      	ldr	r3, [r7, #4]
 80152b2:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80152b6:	f003 0301 	and.w	r3, r3, #1
 80152ba:	b2db      	uxtb	r3, r3
 80152bc:	2b00      	cmp	r3, #0
 80152be:	d009      	beq.n	80152d4 <FreeDecodedCert+0x34>
        XFREE(cert->subjectCN, cert->heap, DYNAMIC_TYPE_SUBJECT_CN);
 80152c0:	687b      	ldr	r3, [r7, #4]
 80152c2:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 80152c6:	60fb      	str	r3, [r7, #12]
 80152c8:	68fb      	ldr	r3, [r7, #12]
 80152ca:	2b00      	cmp	r3, #0
 80152cc:	d002      	beq.n	80152d4 <FreeDecodedCert+0x34>
 80152ce:	68f8      	ldr	r0, [r7, #12]
 80152d0:	f009 fbfc 	bl	801eacc <wolfSSL_Free>
    }
    if (cert->pubKeyStored == 1) {
 80152d4:	687b      	ldr	r3, [r7, #4]
 80152d6:	689b      	ldr	r3, [r3, #8]
 80152d8:	2b01      	cmp	r3, #1
 80152da:	d108      	bne.n	80152ee <FreeDecodedCert+0x4e>
        XFREE((void*)cert->publicKey, cert->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 80152dc:	687b      	ldr	r3, [r7, #4]
 80152de:	681b      	ldr	r3, [r3, #0]
 80152e0:	60bb      	str	r3, [r7, #8]
 80152e2:	68bb      	ldr	r3, [r7, #8]
 80152e4:	2b00      	cmp	r3, #0
 80152e6:	d002      	beq.n	80152ee <FreeDecodedCert+0x4e>
 80152e8:	68b8      	ldr	r0, [r7, #8]
 80152ea:	f009 fbef 	bl	801eacc <wolfSSL_Free>
    }
    if (cert->weOwnAltNames && cert->altNames)
 80152ee:	687b      	ldr	r3, [r7, #4]
 80152f0:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80152f4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80152f8:	b2db      	uxtb	r3, r3
 80152fa:	2b00      	cmp	r3, #0
 80152fc:	d00c      	beq.n	8015318 <FreeDecodedCert+0x78>
 80152fe:	687b      	ldr	r3, [r7, #4]
 8015300:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8015302:	2b00      	cmp	r3, #0
 8015304:	d008      	beq.n	8015318 <FreeDecodedCert+0x78>
        FreeAltNames(cert->altNames, cert->heap);
 8015306:	687b      	ldr	r3, [r7, #4]
 8015308:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 801530a:	687b      	ldr	r3, [r7, #4]
 801530c:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8015310:	4619      	mov	r1, r3
 8015312:	4610      	mov	r0, r2
 8015314:	f7ff ff37 	bl	8015186 <FreeAltNames>
#ifndef IGNORE_NAME_CONSTRAINTS
    if (cert->altEmailNames)
 8015318:	687b      	ldr	r3, [r7, #4]
 801531a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801531c:	2b00      	cmp	r3, #0
 801531e:	d008      	beq.n	8015332 <FreeDecodedCert+0x92>
        FreeAltNames(cert->altEmailNames, cert->heap);
 8015320:	687b      	ldr	r3, [r7, #4]
 8015322:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8015324:	687b      	ldr	r3, [r7, #4]
 8015326:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 801532a:	4619      	mov	r1, r3
 801532c:	4610      	mov	r0, r2
 801532e:	f7ff ff2a 	bl	8015186 <FreeAltNames>
    if (cert->altDirNames)
 8015332:	687b      	ldr	r3, [r7, #4]
 8015334:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8015336:	2b00      	cmp	r3, #0
 8015338:	d008      	beq.n	801534c <FreeDecodedCert+0xac>
        FreeAltNames(cert->altDirNames, cert->heap);
 801533a:	687b      	ldr	r3, [r7, #4]
 801533c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 801533e:	687b      	ldr	r3, [r7, #4]
 8015340:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8015344:	4619      	mov	r1, r3
 8015346:	4610      	mov	r0, r2
 8015348:	f7ff ff1d 	bl	8015186 <FreeAltNames>
    if (cert->permittedNames)
 801534c:	687b      	ldr	r3, [r7, #4]
 801534e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8015350:	2b00      	cmp	r3, #0
 8015352:	d008      	beq.n	8015366 <FreeDecodedCert+0xc6>
        FreeNameSubtrees(cert->permittedNames, cert->heap);
 8015354:	687b      	ldr	r3, [r7, #4]
 8015356:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8015358:	687b      	ldr	r3, [r7, #4]
 801535a:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 801535e:	4619      	mov	r1, r3
 8015360:	4610      	mov	r0, r2
 8015362:	f7ff ff79 	bl	8015258 <FreeNameSubtrees>
    if (cert->excludedNames)
 8015366:	687b      	ldr	r3, [r7, #4]
 8015368:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801536a:	2b00      	cmp	r3, #0
 801536c:	d008      	beq.n	8015380 <FreeDecodedCert+0xe0>
        FreeNameSubtrees(cert->excludedNames, cert->heap);
 801536e:	687b      	ldr	r3, [r7, #4]
 8015370:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8015372:	687b      	ldr	r3, [r7, #4]
 8015374:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8015378:	4619      	mov	r1, r3
 801537a:	4610      	mov	r0, r2
 801537c:	f7ff ff6c 	bl	8015258 <FreeNameSubtrees>
    XFREE(cert->deviceType, cert->heap, DYNAMIC_TYPE_X509_EXT);
    XFREE(cert->hwType, cert->heap, DYNAMIC_TYPE_X509_EXT);
    XFREE(cert->hwSerialNum, cert->heap, DYNAMIC_TYPE_X509_EXT);
#endif /* WOLFSSL_SEP */
#ifdef WOLFSSL_X509_NAME_AVAILABLE
    if (cert->issuerName != NULL)
 8015380:	687b      	ldr	r3, [r7, #4]
 8015382:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
 8015386:	2b00      	cmp	r3, #0
 8015388:	d005      	beq.n	8015396 <FreeDecodedCert+0xf6>
        wolfSSL_X509_NAME_free((WOLFSSL_X509_NAME*)cert->issuerName);
 801538a:	687b      	ldr	r3, [r7, #4]
 801538c:	f8d3 3464 	ldr.w	r3, [r3, #1124]	@ 0x464
 8015390:	4618      	mov	r0, r3
 8015392:	f7f9 f8f6 	bl	800e582 <wolfSSL_X509_NAME_free>
    if (cert->subjectName != NULL)
 8015396:	687b      	ldr	r3, [r7, #4]
 8015398:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
 801539c:	2b00      	cmp	r3, #0
 801539e:	d005      	beq.n	80153ac <FreeDecodedCert+0x10c>
        wolfSSL_X509_NAME_free((WOLFSSL_X509_NAME*)cert->subjectName);
 80153a0:	687b      	ldr	r3, [r7, #4]
 80153a2:	f8d3 3468 	ldr.w	r3, [r3, #1128]	@ 0x468
 80153a6:	4618      	mov	r0, r3
 80153a8:	f7f9 f8eb 	bl	800e582 <wolfSSL_X509_NAME_free>
#endif /* WOLFSSL_X509_NAME_AVAILABLE */
#if defined(WOLFSSL_RENESAS_TSIP_TLS) || defined(WOLFSSL_RENESAS_FSPSM_TLS)
    XFREE(cert->sce_tsip_encRsaKeyIdx, cert->heap, DYNAMIC_TYPE_RSA);
#endif
    FreeSignatureCtx(&cert->sigCtx);
 80153ac:	687b      	ldr	r3, [r7, #4]
 80153ae:	f203 4374 	addw	r3, r3, #1140	@ 0x474
 80153b2:	4618      	mov	r0, r3
 80153b4:	f000 fe66 	bl	8016084 <FreeSignatureCtx>
 80153b8:	e000      	b.n	80153bc <FreeDecodedCert+0x11c>
        return;
 80153ba:	bf00      	nop
}
 80153bc:	3710      	adds	r7, #16
 80153be:	46bd      	mov	sp, r7
 80153c0:	bd80      	pop	{r7, pc}
	...

080153c4 <StoreRsaKey>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
static int StoreRsaKey(DecodedCert* cert, const byte* source, word32* srcIdx,
                       word32 maxIdx)
{
 80153c4:	b580      	push	{r7, lr}
 80153c6:	b098      	sub	sp, #96	@ 0x60
 80153c8:	af04      	add	r7, sp, #16
 80153ca:	60f8      	str	r0, [r7, #12]
 80153cc:	60b9      	str	r1, [r7, #8]
 80153ce:	607a      	str	r2, [r7, #4]
 80153d0:	603b      	str	r3, [r7, #0]
#else
    ASNGetData dataASN[rsaCertKeyASN_Length];
    int ret;

    /* No dynamic data. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 80153d2:	f107 0314 	add.w	r3, r7, #20
 80153d6:	2238      	movs	r2, #56	@ 0x38
 80153d8:	2100      	movs	r1, #0
 80153da:	4618      	mov	r0, r3
 80153dc:	f013 f878 	bl	80284d0 <memset>
    /* Decode the header before the key data. */
    ret = GetASN_Items(rsaCertKeyASN, dataASN, rsaCertKeyASN_Length, 1, source,
 80153e0:	f107 0114 	add.w	r1, r7, #20
 80153e4:	683b      	ldr	r3, [r7, #0]
 80153e6:	9302      	str	r3, [sp, #8]
 80153e8:	687b      	ldr	r3, [r7, #4]
 80153ea:	9301      	str	r3, [sp, #4]
 80153ec:	68bb      	ldr	r3, [r7, #8]
 80153ee:	9300      	str	r3, [sp, #0]
 80153f0:	2301      	movs	r3, #1
 80153f2:	2202      	movs	r2, #2
 80153f4:	4808      	ldr	r0, [pc, #32]	@ (8015418 <StoreRsaKey+0x54>)
 80153f6:	f7fe f989 	bl	801370c <GetASN_Items>
 80153fa:	64f8      	str	r0, [r7, #76]	@ 0x4c
                       srcIdx, maxIdx);
    if (ret == 0) {
 80153fc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80153fe:	2b00      	cmp	r3, #0
 8015400:	d105      	bne.n	801540e <StoreRsaKey+0x4a>
        /* Store the pointer and length in certificate object starting at
         * SEQUENCE. */
        GetASN_GetConstRef(&dataASN[RSACERTKEYASN_IDX_STR],
 8015402:	69fa      	ldr	r2, [r7, #28]
 8015404:	68fb      	ldr	r3, [r7, #12]
 8015406:	601a      	str	r2, [r3, #0]
 8015408:	6a3a      	ldr	r2, [r7, #32]
 801540a:	68fb      	ldr	r3, [r7, #12]
 801540c:	605a      	str	r2, [r3, #4]
        ret = CalcHashId_ex(cert->publicKey, cert->pubKeySize,
                         cert->subjectKeyHash, HashIdAlg(cert->signatureOID));
    #endif
    }

    return ret;
 801540e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015410:	4618      	mov	r0, r3
 8015412:	3750      	adds	r7, #80	@ 0x50
 8015414:	46bd      	mov	sp, r7
 8015416:	bd80      	pop	{r7, pc}
 8015418:	080336a4 	.word	0x080336a4

0801541c <StoreEccKey>:
 *          non-zero length.
 * @return  ASN_OBJECT_ID_E when the expected OBJECT_ID tag is not found.
 */
static int StoreEccKey(DecodedCert* cert, const byte* source, word32* srcIdx,
                       word32 maxIdx, const byte* pubKey, word32 pubKeyLen)
{
 801541c:	b580      	push	{r7, lr}
 801541e:	b08c      	sub	sp, #48	@ 0x30
 8015420:	af04      	add	r7, sp, #16
 8015422:	60f8      	str	r0, [r7, #12]
 8015424:	60b9      	str	r1, [r7, #8]
 8015426:	607a      	str	r2, [r7, #4]
 8015428:	603b      	str	r3, [r7, #0]
    cert->pubKeyStored = 1;
    cert->pubKeySize   = pubKeyLen;

    return 0;
#else
    int ret = 0;
 801542a:	2300      	movs	r3, #0
 801542c:	61fb      	str	r3, [r7, #28]
    DECL_ASNGETDATA(dataASN, eccCertKeyASN_Length);
 801542e:	2300      	movs	r3, #0
 8015430:	61bb      	str	r3, [r7, #24]
    byte* publicKey;

    /* Validate parameters. */
    if (pubKey == NULL) {
 8015432:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015434:	2b00      	cmp	r3, #0
 8015436:	d102      	bne.n	801543e <StoreEccKey+0x22>
        ret = BAD_FUNC_ARG;
 8015438:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801543c:	61fb      	str	r3, [r7, #28]
    }

    /* Clear dynamic data and check OID is a curve. */
    CALLOC_ASNGETDATA(dataASN, eccCertKeyASN_Length, ret, cert->heap);
 801543e:	69fb      	ldr	r3, [r7, #28]
 8015440:	2b00      	cmp	r3, #0
 8015442:	d109      	bne.n	8015458 <StoreEccKey+0x3c>
 8015444:	2054      	movs	r0, #84	@ 0x54
 8015446:	f009 fb25 	bl	801ea94 <wolfSSL_Malloc>
 801544a:	61b8      	str	r0, [r7, #24]
 801544c:	69bb      	ldr	r3, [r7, #24]
 801544e:	2b00      	cmp	r3, #0
 8015450:	d102      	bne.n	8015458 <StoreEccKey+0x3c>
 8015452:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015456:	61fb      	str	r3, [r7, #28]
 8015458:	69fb      	ldr	r3, [r7, #28]
 801545a:	2b00      	cmp	r3, #0
 801545c:	d104      	bne.n	8015468 <StoreEccKey+0x4c>
 801545e:	2254      	movs	r2, #84	@ 0x54
 8015460:	2100      	movs	r1, #0
 8015462:	69b8      	ldr	r0, [r7, #24]
 8015464:	f013 f834 	bl	80284d0 <memset>
    if (ret == 0) {
 8015468:	69fb      	ldr	r3, [r7, #28]
 801546a:	2b00      	cmp	r3, #0
 801546c:	d10f      	bne.n	801548e <StoreEccKey+0x72>
        GetASN_OID(&dataASN[ECCCERTKEYASN_IDX_OID], oidCurveType);
 801546e:	69bb      	ldr	r3, [r7, #24]
 8015470:	2203      	movs	r2, #3
 8015472:	611a      	str	r2, [r3, #16]
        /* Parse ECC public key header. */
        ret = GetASN_Items(eccCertKeyASN, dataASN, eccCertKeyASN_Length, 1,
 8015474:	683b      	ldr	r3, [r7, #0]
 8015476:	9302      	str	r3, [sp, #8]
 8015478:	687b      	ldr	r3, [r7, #4]
 801547a:	9301      	str	r3, [sp, #4]
 801547c:	68bb      	ldr	r3, [r7, #8]
 801547e:	9300      	str	r3, [sp, #0]
 8015480:	2301      	movs	r3, #1
 8015482:	2203      	movs	r2, #3
 8015484:	69b9      	ldr	r1, [r7, #24]
 8015486:	4820      	ldr	r0, [pc, #128]	@ (8015508 <StoreEccKey+0xec>)
 8015488:	f7fe f940 	bl	801370c <GetASN_Items>
 801548c:	61f8      	str	r0, [r7, #28]
                source, srcIdx, maxIdx);
    }
    if (ret == 0) {
 801548e:	69fb      	ldr	r3, [r7, #28]
 8015490:	2b00      	cmp	r3, #0
 8015492:	d129      	bne.n	80154e8 <StoreEccKey+0xcc>
        if (dataASN[ECCCERTKEYASN_IDX_OID].tag != 0) {
 8015494:	69bb      	ldr	r3, [r7, #24]
 8015496:	7e5b      	ldrb	r3, [r3, #25]
 8015498:	2b00      	cmp	r3, #0
 801549a:	d005      	beq.n	80154a8 <StoreEccKey+0x8c>
            /* Store curve OID. */
            cert->pkCurveOID = dataASN[ECCCERTKEYASN_IDX_OID].data.oid.sum;
 801549c:	69bb      	ldr	r3, [r7, #24]
 801549e:	695a      	ldr	r2, [r3, #20]
 80154a0:	68fb      	ldr	r3, [r7, #12]
 80154a2:	f8c3 2440 	str.w	r2, [r3, #1088]	@ 0x440
 80154a6:	e002      	b.n	80154ae <StoreEccKey+0x92>
                    dataASN[ECCCERTKEYASN_IDX_PARAMS].data.ref.data,
                    dataASN[ECCCERTKEYASN_IDX_PARAMS].data.ref.length, NULL,
                    NULL, &cert->pkCurveSize);
    #else
            /* Explicit parameters not supported in build configuration. */
            ret = ASN_PARSE_E;
 80154a8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80154ac:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
    #endif
        /* Store public key data length. */
        cert->pubKeySize = pubKeyLen;
 80154ae:	68fb      	ldr	r3, [r7, #12]
 80154b0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80154b2:	605a      	str	r2, [r3, #4]
        /* Must allocated space for key.
         * Don't memcpy into constant pointer so use temp. */
        publicKey = (byte*)XMALLOC(cert->pubKeySize, cert->heap,
 80154b4:	68fb      	ldr	r3, [r7, #12]
 80154b6:	685b      	ldr	r3, [r3, #4]
 80154b8:	4618      	mov	r0, r3
 80154ba:	f009 faeb 	bl	801ea94 <wolfSSL_Malloc>
 80154be:	6178      	str	r0, [r7, #20]
                                   DYNAMIC_TYPE_PUBLIC_KEY);
        if (publicKey == NULL) {
 80154c0:	697b      	ldr	r3, [r7, #20]
 80154c2:	2b00      	cmp	r3, #0
 80154c4:	d103      	bne.n	80154ce <StoreEccKey+0xb2>
            ret = MEMORY_E;
 80154c6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80154ca:	61fb      	str	r3, [r7, #28]
 80154cc:	e00c      	b.n	80154e8 <StoreEccKey+0xcc>
        }
        else {
            /* Copy in whole public key and store pointer. */
            XMEMCPY(publicKey, pubKey, cert->pubKeySize);
 80154ce:	68fb      	ldr	r3, [r7, #12]
 80154d0:	685b      	ldr	r3, [r3, #4]
 80154d2:	461a      	mov	r2, r3
 80154d4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 80154d6:	6978      	ldr	r0, [r7, #20]
 80154d8:	f013 f864 	bl	80285a4 <memcpy>
            cert->publicKey = publicKey;
 80154dc:	68fb      	ldr	r3, [r7, #12]
 80154de:	697a      	ldr	r2, [r7, #20]
 80154e0:	601a      	str	r2, [r3, #0]
            /* Indicate publicKey needs to be freed. */
            cert->pubKeyStored = 1;
 80154e2:	68fb      	ldr	r3, [r7, #12]
 80154e4:	2201      	movs	r2, #1
 80154e6:	609a      	str	r2, [r3, #8]
        }
    }
    FREE_ASNGETDATA(dataASN, cert->heap);
 80154e8:	69bb      	ldr	r3, [r7, #24]
 80154ea:	2b00      	cmp	r3, #0
 80154ec:	d007      	beq.n	80154fe <StoreEccKey+0xe2>
 80154ee:	69bb      	ldr	r3, [r7, #24]
 80154f0:	613b      	str	r3, [r7, #16]
 80154f2:	693b      	ldr	r3, [r7, #16]
 80154f4:	2b00      	cmp	r3, #0
 80154f6:	d002      	beq.n	80154fe <StoreEccKey+0xe2>
 80154f8:	6938      	ldr	r0, [r7, #16]
 80154fa:	f009 fae7 	bl	801eacc <wolfSSL_Free>

    return ret;
 80154fe:	69fb      	ldr	r3, [r7, #28]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015500:	4618      	mov	r0, r3
 8015502:	3720      	adds	r7, #32
 8015504:	46bd      	mov	sp, r7
 8015506:	bd80      	pop	{r7, pc}
 8015508:	080336ac 	.word	0x080336ac

0801550c <GetCertKey>:
 *          is invalid.
 * @return  BUFFER_E when data in buffer is too small.
 */
static int GetCertKey(DecodedCert* cert, const byte* source, word32* inOutIdx,
                      word32 maxIdx)
{
 801550c:	b590      	push	{r4, r7, lr}
 801550e:	b095      	sub	sp, #84	@ 0x54
 8015510:	af02      	add	r7, sp, #8
 8015512:	60f8      	str	r0, [r7, #12]
 8015514:	60b9      	str	r1, [r7, #8]
 8015516:	607a      	str	r2, [r7, #4]
 8015518:	603b      	str	r3, [r7, #0]
    word32 srcIdx = *inOutIdx;
 801551a:	687b      	ldr	r3, [r7, #4]
 801551c:	681b      	ldr	r3, [r3, #0]
 801551e:	637b      	str	r3, [r7, #52]	@ 0x34
#if defined(HAVE_ECC) || !defined(NO_DSA)
    int pubLen;
#endif
#if defined(HAVE_ECC) || !defined(NO_DSA)
    int pubIdx = (int)srcIdx;
 8015520:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015522:	643b      	str	r3, [r7, #64]	@ 0x40
#endif
    int ret = 0;
 8015524:	2300      	movs	r3, #0
 8015526:	647b      	str	r3, [r7, #68]	@ 0x44
    int length;

    /* Validate parameters. */
    if (source == NULL) {
 8015528:	68bb      	ldr	r3, [r7, #8]
 801552a:	2b00      	cmp	r3, #0
 801552c:	d102      	bne.n	8015534 <GetCertKey+0x28>
        return ASN_PARSE_E;
 801552e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015532:	e0db      	b.n	80156ec <GetCertKey+0x1e0>

#ifndef WOLFSSL_ASN_TEMPLATE
    if (GetSequence(source, &srcIdx, &length, maxIdx) < 0)
#else
    /* Get SEQUENCE and expect all data to be accounted for. */
    if (GetASN_Sequence(source, &srcIdx, &length, maxIdx, 1) != 0)
 8015534:	f107 0230 	add.w	r2, r7, #48	@ 0x30
 8015538:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 801553c:	2301      	movs	r3, #1
 801553e:	9300      	str	r3, [sp, #0]
 8015540:	683b      	ldr	r3, [r7, #0]
 8015542:	68b8      	ldr	r0, [r7, #8]
 8015544:	f7fe fb89 	bl	8013c5a <GetASN_Sequence>
 8015548:	4603      	mov	r3, r0
 801554a:	2b00      	cmp	r3, #0
 801554c:	d002      	beq.n	8015554 <GetCertKey+0x48>
#endif
    {
        return ASN_PARSE_E;
 801554e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015552:	e0cb      	b.n	80156ec <GetCertKey+0x1e0>
    }

#if defined(HAVE_ECC) || !defined(NO_DSA)
    pubLen = (int)srcIdx - pubIdx + length;
 8015554:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015556:	461a      	mov	r2, r3
 8015558:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801555a:	1ad2      	subs	r2, r2, r3
 801555c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801555e:	4413      	add	r3, r2
 8015560:	63fb      	str	r3, [r7, #60]	@ 0x3c
#endif
    maxIdx = srcIdx + (word32)length;
 8015562:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015564:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8015566:	4413      	add	r3, r2
 8015568:	603b      	str	r3, [r7, #0]

    /* Decode the algorithm identifier for the key. */
    if (GetAlgoId(source, &srcIdx, &cert->keyOID, oidKeyType, maxIdx) < 0) {
 801556a:	68fb      	ldr	r3, [r7, #12]
 801556c:	f103 021c 	add.w	r2, r3, #28
 8015570:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8015574:	683b      	ldr	r3, [r7, #0]
 8015576:	9300      	str	r3, [sp, #0]
 8015578:	2302      	movs	r3, #2
 801557a:	68b8      	ldr	r0, [r7, #8]
 801557c:	f7ff f96c 	bl	8014858 <GetAlgoId>
 8015580:	4603      	mov	r3, r0
 8015582:	2b00      	cmp	r3, #0
 8015584:	da02      	bge.n	801558c <GetCertKey+0x80>
        return ASN_PARSE_E;
 8015586:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801558a:	e0af      	b.n	80156ec <GetCertKey+0x1e0>
    }

    (void)length;

    /* Parse each type of public key. */
    switch (cert->keyOID) {
 801558c:	68fb      	ldr	r3, [r7, #12]
 801558e:	69db      	ldr	r3, [r3, #28]
 8015590:	f240 228e 	movw	r2, #654	@ 0x28e
 8015594:	4293      	cmp	r3, r2
 8015596:	d00e      	beq.n	80155b6 <GetCertKey+0xaa>
 8015598:	f240 228e 	movw	r2, #654	@ 0x28e
 801559c:	4293      	cmp	r3, r2
 801559e:	f200 809e 	bhi.w	80156de <GetCertKey+0x1d2>
 80155a2:	f240 2206 	movw	r2, #518	@ 0x206
 80155a6:	4293      	cmp	r3, r2
 80155a8:	f000 8089 	beq.w	80156be <GetCertKey+0x1b2>
 80155ac:	f240 2285 	movw	r2, #645	@ 0x285
 80155b0:	4293      	cmp	r3, r2
 80155b2:	d07b      	beq.n	80156ac <GetCertKey+0x1a0>
 80155b4:	e093      	b.n	80156de <GetCertKey+0x1d2>
#ifndef NO_RSA
    #ifdef WC_RSA_PSS
        case RSAPSSk:
            if (srcIdx != maxIdx &&
 80155b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80155b8:	683a      	ldr	r2, [r7, #0]
 80155ba:	429a      	cmp	r2, r3
 80155bc:	d076      	beq.n	80156ac <GetCertKey+0x1a0>
                          source[srcIdx] == (ASN_SEQUENCE | ASN_CONSTRUCTED)) {
 80155be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80155c0:	68ba      	ldr	r2, [r7, #8]
 80155c2:	4413      	add	r3, r2
 80155c4:	781b      	ldrb	r3, [r3, #0]
            if (srcIdx != maxIdx &&
 80155c6:	2b30      	cmp	r3, #48	@ 0x30
 80155c8:	d170      	bne.n	80156ac <GetCertKey+0x1a0>
                word32 seqIdx = srcIdx;
 80155ca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80155cc:	63bb      	str	r3, [r7, #56]	@ 0x38
                int seqLen;
                /* Not set when -1. */
                enum wc_HashType hash = WC_HASH_TYPE_NONE;
 80155ce:	2300      	movs	r3, #0
 80155d0:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
                int mgf = -1;
 80155d4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80155d8:	627b      	str	r3, [r7, #36]	@ 0x24
                int saltLen = 0;
 80155da:	2300      	movs	r3, #0
 80155dc:	623b      	str	r3, [r7, #32]
                /* Defaults for sig algorithm parameters. */
                enum wc_HashType sigHash = WC_HASH_TYPE_SHA;
 80155de:	2304      	movs	r3, #4
 80155e0:	77fb      	strb	r3, [r7, #31]
                int sigMgf = WC_MGF1SHA1;
 80155e2:	231a      	movs	r3, #26
 80155e4:	61bb      	str	r3, [r7, #24]
                int sigSaltLen = 20;
 80155e6:	2314      	movs	r3, #20
 80155e8:	617b      	str	r3, [r7, #20]

                if (GetSequence(source, &srcIdx, &seqLen, maxIdx) < 0) {
 80155ea:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 80155ee:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 80155f2:	683b      	ldr	r3, [r7, #0]
 80155f4:	68b8      	ldr	r0, [r7, #8]
 80155f6:	f7fe fccd 	bl	8013f94 <GetSequence>
 80155fa:	4603      	mov	r3, r0
 80155fc:	2b00      	cmp	r3, #0
 80155fe:	da02      	bge.n	8015606 <GetCertKey+0xfa>
                    return ASN_PARSE_E;
 8015600:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015604:	e072      	b.n	80156ec <GetCertKey+0x1e0>
                }
                /* Get the pubic key parameters. */
                ret = DecodeRsaPssParams(source + seqIdx,
 8015606:	68ba      	ldr	r2, [r7, #8]
 8015608:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801560a:	18d0      	adds	r0, r2, r3
                    (word32)seqLen + srcIdx - seqIdx, &hash, &mgf, &saltLen);
 801560c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801560e:	461a      	mov	r2, r3
 8015610:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015612:	441a      	add	r2, r3
                ret = DecodeRsaPssParams(source + seqIdx,
 8015614:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015616:	1ad1      	subs	r1, r2, r3
 8015618:	f107 0424 	add.w	r4, r7, #36	@ 0x24
 801561c:	f107 022b 	add.w	r2, r7, #43	@ 0x2b
 8015620:	f107 0320 	add.w	r3, r7, #32
 8015624:	9300      	str	r3, [sp, #0]
 8015626:	4623      	mov	r3, r4
 8015628:	f7ff f97a 	bl	8014920 <DecodeRsaPssParams>
 801562c:	6478      	str	r0, [r7, #68]	@ 0x44
                if (ret != 0) {
 801562e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015630:	2b00      	cmp	r3, #0
 8015632:	d002      	beq.n	801563a <GetCertKey+0x12e>
                    return ASN_PARSE_E;
 8015634:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015638:	e058      	b.n	80156ec <GetCertKey+0x1e0>
                }
                /* Get the signature parameters. */
                ret = DecodeRsaPssParams(source + cert->sigParamsIndex,
 801563a:	68fb      	ldr	r3, [r7, #12]
 801563c:	6a1b      	ldr	r3, [r3, #32]
 801563e:	68ba      	ldr	r2, [r7, #8]
 8015640:	18d0      	adds	r0, r2, r3
 8015642:	68fb      	ldr	r3, [r7, #12]
 8015644:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 8015646:	f107 0418 	add.w	r4, r7, #24
 801564a:	f107 021f 	add.w	r2, r7, #31
 801564e:	f107 0314 	add.w	r3, r7, #20
 8015652:	9300      	str	r3, [sp, #0]
 8015654:	4623      	mov	r3, r4
 8015656:	f7ff f963 	bl	8014920 <DecodeRsaPssParams>
 801565a:	6478      	str	r0, [r7, #68]	@ 0x44
                    cert->sigParamsLength, &sigHash, &sigMgf, &sigSaltLen);
                if (ret != 0) {
 801565c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801565e:	2b00      	cmp	r3, #0
 8015660:	d002      	beq.n	8015668 <GetCertKey+0x15c>
                    return ASN_PARSE_E;
 8015662:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015666:	e041      	b.n	80156ec <GetCertKey+0x1e0>
                }
                /* Validated signature params match public key params. */
                if (hash != WC_HASH_TYPE_NONE && hash != sigHash) {
 8015668:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 801566c:	2b00      	cmp	r3, #0
 801566e:	d007      	beq.n	8015680 <GetCertKey+0x174>
 8015670:	f897 202b 	ldrb.w	r2, [r7, #43]	@ 0x2b
 8015674:	7ffb      	ldrb	r3, [r7, #31]
 8015676:	429a      	cmp	r2, r3
 8015678:	d002      	beq.n	8015680 <GetCertKey+0x174>
                    WOLFSSL_MSG("RSA PSS: hash not matching signature hash");
                    return ASN_PARSE_E;
 801567a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801567e:	e035      	b.n	80156ec <GetCertKey+0x1e0>
                }
                if (mgf != -1 && mgf != sigMgf) {
 8015680:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015682:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8015686:	d006      	beq.n	8015696 <GetCertKey+0x18a>
 8015688:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801568a:	69bb      	ldr	r3, [r7, #24]
 801568c:	429a      	cmp	r2, r3
 801568e:	d002      	beq.n	8015696 <GetCertKey+0x18a>
                    WOLFSSL_MSG("RSA PSS: MGF not matching signature MGF");
                    return ASN_PARSE_E;
 8015690:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015694:	e02a      	b.n	80156ec <GetCertKey+0x1e0>
                }
                if (saltLen > sigSaltLen) {
 8015696:	6a3a      	ldr	r2, [r7, #32]
 8015698:	697b      	ldr	r3, [r7, #20]
 801569a:	429a      	cmp	r2, r3
 801569c:	dd02      	ble.n	80156a4 <GetCertKey+0x198>
                    WOLFSSL_MSG("RSA PSS: sig salt length too small");
                    return ASN_PARSE_E;
 801569e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80156a2:	e023      	b.n	80156ec <GetCertKey+0x1e0>
                }
                srcIdx += (word32)seqLen;
 80156a4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80156a6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80156a8:	4413      	add	r3, r2
 80156aa:	637b      	str	r3, [r7, #52]	@ 0x34
            }
            FALL_THROUGH;
    #endif /* WC_RSA_PSS */
        case RSAk:
            ret = StoreRsaKey(cert, source, &srcIdx, maxIdx);
 80156ac:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 80156b0:	683b      	ldr	r3, [r7, #0]
 80156b2:	68b9      	ldr	r1, [r7, #8]
 80156b4:	68f8      	ldr	r0, [r7, #12]
 80156b6:	f7ff fe85 	bl	80153c4 <StoreRsaKey>
 80156ba:	6478      	str	r0, [r7, #68]	@ 0x44
            break;
 80156bc:	e012      	b.n	80156e4 <GetCertKey+0x1d8>
    #ifdef HAVE_ECC
    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        case SM2k:
    #endif
        case ECDSAk:
            ret = StoreEccKey(cert, source, &srcIdx, maxIdx, source + pubIdx,
 80156be:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80156c0:	68ba      	ldr	r2, [r7, #8]
 80156c2:	4413      	add	r3, r2
 80156c4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80156c6:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 80156ca:	9201      	str	r2, [sp, #4]
 80156cc:	9300      	str	r3, [sp, #0]
 80156ce:	683b      	ldr	r3, [r7, #0]
 80156d0:	460a      	mov	r2, r1
 80156d2:	68b9      	ldr	r1, [r7, #8]
 80156d4:	68f8      	ldr	r0, [r7, #12]
 80156d6:	f7ff fea1 	bl	801541c <StoreEccKey>
 80156da:	6478      	str	r0, [r7, #68]	@ 0x44
                              (word32)pubLen);
            break;
 80156dc:	e002      	b.n	80156e4 <GetCertKey+0x1d8>
            break;
    #endif /* NO_DSA */
        default:
            WOLFSSL_MSG("Unknown or not compiled in key OID");
            WOLFSSL_ERROR_VERBOSE(ASN_UNKNOWN_OID_E);
            ret = ASN_UNKNOWN_OID_E;
 80156de:	f06f 0393 	mvn.w	r3, #147	@ 0x93
 80156e2:	647b      	str	r3, [r7, #68]	@ 0x44
    }

    /* Return index after public key. */
    *inOutIdx = srcIdx;
 80156e4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80156e6:	687b      	ldr	r3, [r7, #4]
 80156e8:	601a      	str	r2, [r3, #0]

    /* Return error code. */
    return ret;
 80156ea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 80156ec:	4618      	mov	r0, r3
 80156ee:	374c      	adds	r7, #76	@ 0x4c
 80156f0:	46bd      	mov	sp, r7
 80156f2:	bd90      	pop	{r4, r7, pc}

080156f4 <HashIdAlg>:
 *
 * @param [in] oidSum  Signature id.
 * @return  Hash algorithm id.
 */
int HashIdAlg(word32 oidSum)
{
 80156f4:	b480      	push	{r7}
 80156f6:	b083      	sub	sp, #12
 80156f8:	af00      	add	r7, sp, #0
 80156fa:	6078      	str	r0, [r7, #4]
    if (oidSum == SM2k) {
        return WC_SM3;
    }
#endif
#if defined(NO_SHA) || (!defined(NO_SHA256) && defined(WC_ASN_HASH_SHA256))
    return WC_SHA256;
 80156fc:	2306      	movs	r3, #6
#else
    return WC_SHA;
#endif
}
 80156fe:	4618      	mov	r0, r3
 8015700:	370c      	adds	r7, #12
 8015702:	46bd      	mov	sp, r7
 8015704:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015708:	4770      	bx	lr

0801570a <CalcHashId>:
 * @param [out] hash  Buffer to hold hash.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
int CalcHashId(const byte* data, word32 len, byte* hash)
{
 801570a:	b580      	push	{r7, lr}
 801570c:	b084      	sub	sp, #16
 801570e:	af00      	add	r7, sp, #0
 8015710:	60f8      	str	r0, [r7, #12]
 8015712:	60b9      	str	r1, [r7, #8]
 8015714:	607a      	str	r2, [r7, #4]
    /* Use default hash algorithm. */
    return CalcHashId_ex(data, len, hash,
 8015716:	2306      	movs	r3, #6
 8015718:	687a      	ldr	r2, [r7, #4]
 801571a:	68b9      	ldr	r1, [r7, #8]
 801571c:	68f8      	ldr	r0, [r7, #12]
 801571e:	f000 f805 	bl	801572c <CalcHashId_ex>
 8015722:	4603      	mov	r3, r0
        WC_SHA256
#else
        WC_SHA
#endif
        );
}
 8015724:	4618      	mov	r0, r3
 8015726:	3710      	adds	r7, #16
 8015728:	46bd      	mov	sp, r7
 801572a:	bd80      	pop	{r7, pc}

0801572c <CalcHashId_ex>:
 * @param [out] hash  Buffer to hold hash.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
int CalcHashId_ex(const byte* data, word32 len, byte* hash, int hashAlg)
{
 801572c:	b580      	push	{r7, lr}
 801572e:	b086      	sub	sp, #24
 8015730:	af00      	add	r7, sp, #0
 8015732:	60f8      	str	r0, [r7, #12]
 8015734:	60b9      	str	r1, [r7, #8]
 8015736:	607a      	str	r2, [r7, #4]
 8015738:	603b      	str	r3, [r7, #0]
        ret = wc_Sm3Hash(data, len, hash);
    }
    else
#endif
#if defined(NO_SHA) || (!defined(NO_SHA256) && defined(WC_ASN_HASH_SHA256))
    if (hashAlg == WC_SHA256) {
 801573a:	683b      	ldr	r3, [r7, #0]
 801573c:	2b06      	cmp	r3, #6
 801573e:	d106      	bne.n	801574e <CalcHashId_ex+0x22>
        ret = wc_Sha256Hash(data, len, hash);
 8015740:	687a      	ldr	r2, [r7, #4]
 8015742:	68b9      	ldr	r1, [r7, #8]
 8015744:	68f8      	ldr	r0, [r7, #12]
 8015746:	f008 feff 	bl	801e548 <wc_Sha256Hash>
 801574a:	6178      	str	r0, [r7, #20]
 801574c:	e002      	b.n	8015754 <CalcHashId_ex+0x28>
    (void)data;
    (void)len;
    (void)hash;
#endif
    {
        ret = NOT_COMPILED_IN;
 801574e:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 8015752:	617b      	str	r3, [r7, #20]
    }

    return ret;
 8015754:	697b      	ldr	r3, [r7, #20]
}
 8015756:	4618      	mov	r0, r3
 8015758:	3718      	adds	r7, #24
 801575a:	46bd      	mov	sp, r7
 801575c:	bd80      	pop	{r7, pc}

0801575e <GetHashId>:
 * @param [out] hash  Buffer to hold hash.
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int GetHashId(const byte* id, int length, byte* hash, int hashAlg)
{
 801575e:	b580      	push	{r7, lr}
 8015760:	b086      	sub	sp, #24
 8015762:	af00      	add	r7, sp, #0
 8015764:	60f8      	str	r0, [r7, #12]
 8015766:	60b9      	str	r1, [r7, #8]
 8015768:	607a      	str	r2, [r7, #4]
 801576a:	603b      	str	r3, [r7, #0]
    int ret;

#if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
    if (length == wc_HashGetDigestSize(wc_HashTypeConvert(hashAlg)))
#else
    if (length == KEYID_SIZE)
 801576c:	68bb      	ldr	r3, [r7, #8]
 801576e:	2b20      	cmp	r3, #32
 8015770:	d108      	bne.n	8015784 <GetHashId+0x26>
#endif
    {
    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        XMEMSET(hash + length, 0, KEYID_SIZE - length);
    #endif
        XMEMCPY(hash, id, (size_t)length);
 8015772:	68bb      	ldr	r3, [r7, #8]
 8015774:	461a      	mov	r2, r3
 8015776:	68f9      	ldr	r1, [r7, #12]
 8015778:	6878      	ldr	r0, [r7, #4]
 801577a:	f012 ff13 	bl	80285a4 <memcpy>
        ret = 0;
 801577e:	2300      	movs	r3, #0
 8015780:	617b      	str	r3, [r7, #20]
 8015782:	e006      	b.n	8015792 <GetHashId+0x34>
    }
    else {
        ret = CalcHashId_ex(id, (word32)length, hash, hashAlg);
 8015784:	68b9      	ldr	r1, [r7, #8]
 8015786:	683b      	ldr	r3, [r7, #0]
 8015788:	687a      	ldr	r2, [r7, #4]
 801578a:	68f8      	ldr	r0, [r7, #12]
 801578c:	f7ff ffce 	bl	801572c <CalcHashId_ex>
 8015790:	6178      	str	r0, [r7, #20]
    }

    return ret;
 8015792:	697b      	ldr	r3, [r7, #20]
}
 8015794:	4618      	mov	r0, r3
 8015796:	3718      	adds	r7, #24
 8015798:	46bd      	mov	sp, r7
 801579a:	bd80      	pop	{r7, pc}

0801579c <AddDNSEntryToList>:
 * @param [in, out] lst      Linked list of DNS name entries.
 * @param [in]      entry    Entry to add to the list
 * @return  0 on success.
 */
static int AddDNSEntryToList(DNS_entry** lst, DNS_entry* entry)
{
 801579c:	b480      	push	{r7}
 801579e:	b085      	sub	sp, #20
 80157a0:	af00      	add	r7, sp, #0
 80157a2:	6078      	str	r0, [r7, #4]
 80157a4:	6039      	str	r1, [r7, #0]
#if defined(OPENSSL_EXTRA) && !defined(WOLFSSL_ALT_NAMES_NO_REV)
    entry->next = NULL;
 80157a6:	683b      	ldr	r3, [r7, #0]
 80157a8:	2200      	movs	r2, #0
 80157aa:	601a      	str	r2, [r3, #0]
    if (*lst == NULL) {
 80157ac:	687b      	ldr	r3, [r7, #4]
 80157ae:	681b      	ldr	r3, [r3, #0]
 80157b0:	2b00      	cmp	r3, #0
 80157b2:	d103      	bne.n	80157bc <AddDNSEntryToList+0x20>
        /* First on list */
        *lst = entry;
 80157b4:	687b      	ldr	r3, [r7, #4]
 80157b6:	683a      	ldr	r2, [r7, #0]
 80157b8:	601a      	str	r2, [r3, #0]
 80157ba:	e00d      	b.n	80157d8 <AddDNSEntryToList+0x3c>
    }
    else {
        DNS_entry* temp = *lst;
 80157bc:	687b      	ldr	r3, [r7, #4]
 80157be:	681b      	ldr	r3, [r3, #0]
 80157c0:	60fb      	str	r3, [r7, #12]

        /* Find end */
        for (; (temp->next != NULL); temp = temp->next);
 80157c2:	e002      	b.n	80157ca <AddDNSEntryToList+0x2e>
 80157c4:	68fb      	ldr	r3, [r7, #12]
 80157c6:	681b      	ldr	r3, [r3, #0]
 80157c8:	60fb      	str	r3, [r7, #12]
 80157ca:	68fb      	ldr	r3, [r7, #12]
 80157cc:	681b      	ldr	r3, [r3, #0]
 80157ce:	2b00      	cmp	r3, #0
 80157d0:	d1f8      	bne.n	80157c4 <AddDNSEntryToList+0x28>

        /* Add to end */
        temp->next = entry;
 80157d2:	68fb      	ldr	r3, [r7, #12]
 80157d4:	683a      	ldr	r2, [r7, #0]
 80157d6:	601a      	str	r2, [r3, #0]
    /* Prepend entry to linked list. */
    entry->next = *lst;
    *lst = entry;
#endif

    return 0;
 80157d8:	2300      	movs	r3, #0
}
 80157da:	4618      	mov	r0, r3
 80157dc:	3714      	adds	r7, #20
 80157de:	46bd      	mov	sp, r7
 80157e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80157e4:	4770      	bx	lr

080157e6 <SetDNSEntry>:
 * @return  0 on success.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int SetDNSEntry(void* heap, const char* str, int strLen,
                       int type, DNS_entry** entries)
{
 80157e6:	b580      	push	{r7, lr}
 80157e8:	b088      	sub	sp, #32
 80157ea:	af00      	add	r7, sp, #0
 80157ec:	60f8      	str	r0, [r7, #12]
 80157ee:	60b9      	str	r1, [r7, #8]
 80157f0:	607a      	str	r2, [r7, #4]
 80157f2:	603b      	str	r3, [r7, #0]
    DNS_entry* dnsEntry;
    int ret = 0;
 80157f4:	2300      	movs	r3, #0
 80157f6:	61fb      	str	r3, [r7, #28]

    /* TODO: consider one malloc. */
    /* Allocate DNS Entry object. */
    dnsEntry = AltNameNew(heap);
 80157f8:	68f8      	ldr	r0, [r7, #12]
 80157fa:	f7ff fce8 	bl	80151ce <AltNameNew>
 80157fe:	61b8      	str	r0, [r7, #24]
    if (dnsEntry == NULL) {
 8015800:	69bb      	ldr	r3, [r7, #24]
 8015802:	2b00      	cmp	r3, #0
 8015804:	d102      	bne.n	801580c <SetDNSEntry+0x26>
        ret = MEMORY_E;
 8015806:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801580a:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 801580c:	69fb      	ldr	r3, [r7, #28]
 801580e:	2b00      	cmp	r3, #0
 8015810:	d10e      	bne.n	8015830 <SetDNSEntry+0x4a>
        /* Allocate DNS Entry name - length of string plus 1 for NUL. */
        dnsEntry->name = (char*)XMALLOC((size_t)strLen + 1, heap,
 8015812:	687b      	ldr	r3, [r7, #4]
 8015814:	3301      	adds	r3, #1
 8015816:	4618      	mov	r0, r3
 8015818:	f009 f93c 	bl	801ea94 <wolfSSL_Malloc>
 801581c:	4602      	mov	r2, r0
 801581e:	69bb      	ldr	r3, [r7, #24]
 8015820:	60da      	str	r2, [r3, #12]
                                                          DYNAMIC_TYPE_ALTNAME);
        if (dnsEntry->name == NULL) {
 8015822:	69bb      	ldr	r3, [r7, #24]
 8015824:	68db      	ldr	r3, [r3, #12]
 8015826:	2b00      	cmp	r3, #0
 8015828:	d102      	bne.n	8015830 <SetDNSEntry+0x4a>
            ret = MEMORY_E;
 801582a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801582e:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 8015830:	69fb      	ldr	r3, [r7, #28]
 8015832:	2b00      	cmp	r3, #0
 8015834:	d112      	bne.n	801585c <SetDNSEntry+0x76>
        /* Set tag type, name length, name and NUL terminate name. */
        dnsEntry->type = type;
 8015836:	69bb      	ldr	r3, [r7, #24]
 8015838:	683a      	ldr	r2, [r7, #0]
 801583a:	605a      	str	r2, [r3, #4]
        dnsEntry->len = strLen;
 801583c:	69bb      	ldr	r3, [r7, #24]
 801583e:	687a      	ldr	r2, [r7, #4]
 8015840:	609a      	str	r2, [r3, #8]
        XMEMCPY(dnsEntry->name, str, (size_t)strLen);
 8015842:	69bb      	ldr	r3, [r7, #24]
 8015844:	68db      	ldr	r3, [r3, #12]
 8015846:	687a      	ldr	r2, [r7, #4]
 8015848:	68b9      	ldr	r1, [r7, #8]
 801584a:	4618      	mov	r0, r3
 801584c:	f012 feaa 	bl	80285a4 <memcpy>
        dnsEntry->name[strLen] = '\0';
 8015850:	69bb      	ldr	r3, [r7, #24]
 8015852:	68da      	ldr	r2, [r3, #12]
 8015854:	687b      	ldr	r3, [r7, #4]
 8015856:	4413      	add	r3, r2
 8015858:	2200      	movs	r2, #0
 801585a:	701a      	strb	r2, [r3, #0]
#ifdef WOLFSSL_IP_ALT_NAME
    /* store IP addresses as a string */
    if (ret == 0 && type == ASN_IP_TYPE)
        ret = GenerateDNSEntryIPString(dnsEntry, heap);
#endif
    if (ret == 0) {
 801585c:	69fb      	ldr	r3, [r7, #28]
 801585e:	2b00      	cmp	r3, #0
 8015860:	d104      	bne.n	801586c <SetDNSEntry+0x86>
        ret = AddDNSEntryToList(entries, dnsEntry);
 8015862:	69b9      	ldr	r1, [r7, #24]
 8015864:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8015866:	f7ff ff99 	bl	801579c <AddDNSEntryToList>
 801586a:	61f8      	str	r0, [r7, #28]
    }

    /* failure cleanup */
    if (ret != 0 && dnsEntry != NULL) {
 801586c:	69fb      	ldr	r3, [r7, #28]
 801586e:	2b00      	cmp	r3, #0
 8015870:	d013      	beq.n	801589a <SetDNSEntry+0xb4>
 8015872:	69bb      	ldr	r3, [r7, #24]
 8015874:	2b00      	cmp	r3, #0
 8015876:	d010      	beq.n	801589a <SetDNSEntry+0xb4>
        XFREE(dnsEntry->name, heap, DYNAMIC_TYPE_ALTNAME);
 8015878:	69bb      	ldr	r3, [r7, #24]
 801587a:	68db      	ldr	r3, [r3, #12]
 801587c:	617b      	str	r3, [r7, #20]
 801587e:	697b      	ldr	r3, [r7, #20]
 8015880:	2b00      	cmp	r3, #0
 8015882:	d002      	beq.n	801588a <SetDNSEntry+0xa4>
 8015884:	6978      	ldr	r0, [r7, #20]
 8015886:	f009 f921 	bl	801eacc <wolfSSL_Free>
        XFREE(dnsEntry, heap, DYNAMIC_TYPE_ALTNAME);
 801588a:	69bb      	ldr	r3, [r7, #24]
 801588c:	613b      	str	r3, [r7, #16]
 801588e:	693b      	ldr	r3, [r7, #16]
 8015890:	2b00      	cmp	r3, #0
 8015892:	d002      	beq.n	801589a <SetDNSEntry+0xb4>
 8015894:	6938      	ldr	r0, [r7, #16]
 8015896:	f009 f919 	bl	801eacc <wolfSSL_Free>
    }

    return ret;
 801589a:	69fb      	ldr	r3, [r7, #28]
}
 801589c:	4618      	mov	r0, r3
 801589e:	3720      	adds	r7, #32
 80158a0:	46bd      	mov	sp, r7
 80158a2:	bd80      	pop	{r7, pc}

080158a4 <SetSubject>:
 * @param [in]      tag     BER tag representing encoding of string.
 * @return  0 on success, negative values on failure.
 */
static int SetSubject(DecodedCert* cert, int id, byte* str, int strLen,
                      byte tag)
{
 80158a4:	b480      	push	{r7}
 80158a6:	b087      	sub	sp, #28
 80158a8:	af00      	add	r7, sp, #0
 80158aa:	60f8      	str	r0, [r7, #12]
 80158ac:	60b9      	str	r1, [r7, #8]
 80158ae:	607a      	str	r2, [r7, #4]
 80158b0:	603b      	str	r3, [r7, #0]
    int ret = 0;
 80158b2:	2300      	movs	r3, #0
 80158b4:	617b      	str	r3, [r7, #20]

    /* Put string and encoding into certificate. */
    if (id == ASN_COMMON_NAME) {
 80158b6:	68bb      	ldr	r3, [r7, #8]
 80158b8:	2b03      	cmp	r3, #3
 80158ba:	d10d      	bne.n	80158d8 <SetSubject+0x34>
        cert->subjectCN = (char *)str;
 80158bc:	68fb      	ldr	r3, [r7, #12]
 80158be:	687a      	ldr	r2, [r7, #4]
 80158c0:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        cert->subjectCNLen = (int)strLen;
 80158c4:	68fb      	ldr	r3, [r7, #12]
 80158c6:	683a      	ldr	r2, [r7, #0]
 80158c8:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        cert->subjectCNEnc = (char)tag;
 80158cc:	68fb      	ldr	r3, [r7, #12]
 80158ce:	f897 2020 	ldrb.w	r2, [r7, #32]
 80158d2:	f883 208c 	strb.w	r2, [r3, #140]	@ 0x8c
 80158d6:	e00b      	b.n	80158f0 <SetSubject+0x4c>
        SetCertNameSubjectEnc(cert, id, tag);
    }
#endif
#if !defined(IGNORE_NAME_CONSTRAINTS) || \
     defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_CERT_EXT)
    else if (id == ASN_EMAIL) {
 80158d8:	68bb      	ldr	r3, [r7, #8]
 80158da:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80158de:	d107      	bne.n	80158f0 <SetSubject+0x4c>
        cert->subjectEmail = (char*)str;
 80158e0:	68fb      	ldr	r3, [r7, #12]
 80158e2:	687a      	ldr	r2, [r7, #4]
 80158e4:	f8c3 245c 	str.w	r2, [r3, #1116]	@ 0x45c
        cert->subjectEmailLen = strLen;
 80158e8:	68fb      	ldr	r3, [r7, #12]
 80158ea:	683a      	ldr	r2, [r7, #0]
 80158ec:	f8c3 2460 	str.w	r2, [r3, #1120]	@ 0x460
        cert->subjectJSLen = strLen;
        cert->subjectJSEnc = (char)tag;
    }
#endif

    return ret;
 80158f0:	697b      	ldr	r3, [r7, #20]
}
 80158f2:	4618      	mov	r0, r3
 80158f4:	371c      	adds	r7, #28
 80158f6:	46bd      	mov	sp, r7
 80158f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80158fc:	4770      	bx	lr
	...

08015900 <GetRDN>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  ASN_PARSE_E when type not supported.
 */
static int GetRDN(DecodedCert* cert, char* full, word32* idx, int* nid,
                  int isSubject, ASNGetData* dataASN)
{
 8015900:	b580      	push	{r7, lr}
 8015902:	b090      	sub	sp, #64	@ 0x40
 8015904:	af02      	add	r7, sp, #8
 8015906:	60f8      	str	r0, [r7, #12]
 8015908:	60b9      	str	r1, [r7, #8]
 801590a:	607a      	str	r2, [r7, #4]
 801590c:	603b      	str	r3, [r7, #0]
    int         ret = 0;
 801590e:	2300      	movs	r3, #0
 8015910:	637b      	str	r3, [r7, #52]	@ 0x34
    const char* typeStr = NULL;
 8015912:	2300      	movs	r3, #0
 8015914:	633b      	str	r3, [r7, #48]	@ 0x30
    byte        typeStrLen = 0;
 8015916:	2300      	movs	r3, #0
 8015918:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    byte*       oid;
    word32      oidSz;
    int         id = 0;
 801591c:	2300      	movs	r3, #0
 801591e:	62bb      	str	r3, [r7, #40]	@ 0x28

    (void)nid;

    /* Get name type OID from data items. */
    GetASN_OIDData(&dataASN[RDNASN_IDX_ATTR_TYPE], &oid, &oidSz);
 8015920:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015922:	3338      	adds	r3, #56	@ 0x38
 8015924:	689b      	ldr	r3, [r3, #8]
 8015926:	623b      	str	r3, [r7, #32]
 8015928:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801592a:	3338      	adds	r3, #56	@ 0x38
 801592c:	68db      	ldr	r3, [r3, #12]
 801592e:	61fb      	str	r3, [r7, #28]

    /* v1 name types */
    if ((oidSz == 3) && (oid[0] == 0x55) && (oid[1] == 0x04)) {
 8015930:	69fb      	ldr	r3, [r7, #28]
 8015932:	2b03      	cmp	r3, #3
 8015934:	d146      	bne.n	80159c4 <GetRDN+0xc4>
 8015936:	6a3b      	ldr	r3, [r7, #32]
 8015938:	781b      	ldrb	r3, [r3, #0]
 801593a:	2b55      	cmp	r3, #85	@ 0x55
 801593c:	d142      	bne.n	80159c4 <GetRDN+0xc4>
 801593e:	6a3b      	ldr	r3, [r7, #32]
 8015940:	3301      	adds	r3, #1
 8015942:	781b      	ldrb	r3, [r3, #0]
 8015944:	2b04      	cmp	r3, #4
 8015946:	d13d      	bne.n	80159c4 <GetRDN+0xc4>
        id = oid[2];
 8015948:	6a3b      	ldr	r3, [r7, #32]
 801594a:	3302      	adds	r3, #2
 801594c:	781b      	ldrb	r3, [r3, #0]
 801594e:	62bb      	str	r3, [r7, #40]	@ 0x28
        /* Check range of supported ids in table. */
        if (ValidCertNameSubject(id)) {
 8015950:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015952:	2b02      	cmp	r3, #2
 8015954:	f340 80ed 	ble.w	8015b32 <GetRDN+0x232>
 8015958:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801595a:	3b02      	subs	r3, #2
 801595c:	2210      	movs	r2, #16
 801595e:	4293      	cmp	r3, r2
 8015960:	f300 80e7 	bgt.w	8015b32 <GetRDN+0x232>
 8015964:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015966:	1eda      	subs	r2, r3, #3
 8015968:	499c      	ldr	r1, [pc, #624]	@ (8015bdc <GetRDN+0x2dc>)
 801596a:	4613      	mov	r3, r2
 801596c:	005b      	lsls	r3, r3, #1
 801596e:	4413      	add	r3, r2
 8015970:	009b      	lsls	r3, r3, #2
 8015972:	440b      	add	r3, r1
 8015974:	3304      	adds	r3, #4
 8015976:	781b      	ldrb	r3, [r3, #0]
 8015978:	2b00      	cmp	r3, #0
 801597a:	f000 80da 	beq.w	8015b32 <GetRDN+0x232>
            /* Get the type string, length and NID from table. */
            typeStr = GetCertNameSubjectStr(id);
 801597e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015980:	1eda      	subs	r2, r3, #3
 8015982:	4996      	ldr	r1, [pc, #600]	@ (8015bdc <GetRDN+0x2dc>)
 8015984:	4613      	mov	r3, r2
 8015986:	005b      	lsls	r3, r3, #1
 8015988:	4413      	add	r3, r2
 801598a:	009b      	lsls	r3, r3, #2
 801598c:	440b      	add	r3, r1
 801598e:	681b      	ldr	r3, [r3, #0]
 8015990:	633b      	str	r3, [r7, #48]	@ 0x30
            typeStrLen = GetCertNameSubjectStrLen(id);
 8015992:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015994:	1eda      	subs	r2, r3, #3
 8015996:	4991      	ldr	r1, [pc, #580]	@ (8015bdc <GetRDN+0x2dc>)
 8015998:	4613      	mov	r3, r2
 801599a:	005b      	lsls	r3, r3, #1
 801599c:	4413      	add	r3, r2
 801599e:	009b      	lsls	r3, r3, #2
 80159a0:	440b      	add	r3, r1
 80159a2:	3304      	adds	r3, #4
 80159a4:	781b      	ldrb	r3, [r3, #0]
 80159a6:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            *nid = GetCertNameSubjectNID(id);
 80159aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80159ac:	1eda      	subs	r2, r3, #3
 80159ae:	498b      	ldr	r1, [pc, #556]	@ (8015bdc <GetRDN+0x2dc>)
 80159b0:	4613      	mov	r3, r2
 80159b2:	005b      	lsls	r3, r3, #1
 80159b4:	4413      	add	r3, r2
 80159b6:	009b      	lsls	r3, r3, #2
 80159b8:	440b      	add	r3, r1
 80159ba:	3308      	adds	r3, #8
 80159bc:	681a      	ldr	r2, [r3, #0]
 80159be:	683b      	ldr	r3, [r7, #0]
 80159c0:	601a      	str	r2, [r3, #0]
        if (ValidCertNameSubject(id)) {
 80159c2:	e0b6      	b.n	8015b32 <GetRDN+0x232>
        #endif
        }
    }
    else if (oidSz == sizeof(attrEmailOid) && XMEMCMP(oid, attrEmailOid, oidSz) == 0) {
 80159c4:	69fb      	ldr	r3, [r7, #28]
 80159c6:	2b09      	cmp	r3, #9
 80159c8:	d114      	bne.n	80159f4 <GetRDN+0xf4>
 80159ca:	6a3b      	ldr	r3, [r7, #32]
 80159cc:	69fa      	ldr	r2, [r7, #28]
 80159ce:	4984      	ldr	r1, [pc, #528]	@ (8015be0 <GetRDN+0x2e0>)
 80159d0:	4618      	mov	r0, r3
 80159d2:	f012 fd53 	bl	802847c <memcmp>
 80159d6:	4603      	mov	r3, r0
 80159d8:	2b00      	cmp	r3, #0
 80159da:	d10b      	bne.n	80159f4 <GetRDN+0xf4>
        /* Set the email id, type string, length and NID. */
        id = ASN_EMAIL;
 80159dc:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80159e0:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr =  WOLFSSL_EMAIL_ADDR;
 80159e2:	4b80      	ldr	r3, [pc, #512]	@ (8015be4 <GetRDN+0x2e4>)
 80159e4:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_EMAIL_ADDR) - 1;
 80159e6:	230e      	movs	r3, #14
 80159e8:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_emailAddress;
 80159ec:	683b      	ldr	r3, [r7, #0]
 80159ee:	2230      	movs	r2, #48	@ 0x30
 80159f0:	601a      	str	r2, [r3, #0]
 80159f2:	e09f      	b.n	8015b34 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(uidOid) && XMEMCMP(oid, uidOid, oidSz) == 0) {
 80159f4:	69fb      	ldr	r3, [r7, #28]
 80159f6:	2b0a      	cmp	r3, #10
 80159f8:	d114      	bne.n	8015a24 <GetRDN+0x124>
 80159fa:	6a3b      	ldr	r3, [r7, #32]
 80159fc:	69fa      	ldr	r2, [r7, #28]
 80159fe:	497a      	ldr	r1, [pc, #488]	@ (8015be8 <GetRDN+0x2e8>)
 8015a00:	4618      	mov	r0, r3
 8015a02:	f012 fd3b 	bl	802847c <memcmp>
 8015a06:	4603      	mov	r3, r0
 8015a08:	2b00      	cmp	r3, #0
 8015a0a:	d10b      	bne.n	8015a24 <GetRDN+0x124>
        /* Set the user id, type string, length and NID. */
        id = ASN_USER_ID;
 8015a0c:	2312      	movs	r3, #18
 8015a0e:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_USER_ID;
 8015a10:	4b76      	ldr	r3, [pc, #472]	@ (8015bec <GetRDN+0x2ec>)
 8015a12:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_USER_ID) - 1;
 8015a14:	2305      	movs	r3, #5
 8015a16:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_userId;
 8015a1a:	683b      	ldr	r3, [r7, #0]
 8015a1c:	f44f 72e5 	mov.w	r2, #458	@ 0x1ca
 8015a20:	601a      	str	r2, [r3, #0]
 8015a22:	e087      	b.n	8015b34 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(dcOid) && XMEMCMP(oid, dcOid, oidSz) == 0) {
 8015a24:	69fb      	ldr	r3, [r7, #28]
 8015a26:	2b0a      	cmp	r3, #10
 8015a28:	d114      	bne.n	8015a54 <GetRDN+0x154>
 8015a2a:	6a3b      	ldr	r3, [r7, #32]
 8015a2c:	69fa      	ldr	r2, [r7, #28]
 8015a2e:	4970      	ldr	r1, [pc, #448]	@ (8015bf0 <GetRDN+0x2f0>)
 8015a30:	4618      	mov	r0, r3
 8015a32:	f012 fd23 	bl	802847c <memcmp>
 8015a36:	4603      	mov	r3, r0
 8015a38:	2b00      	cmp	r3, #0
 8015a3a:	d10b      	bne.n	8015a54 <GetRDN+0x154>
        /* Set the domain component, type string, length and NID. */
        id = ASN_DC;
 8015a3c:	f44f 7381 	mov.w	r3, #258	@ 0x102
 8015a40:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_DOMAIN_COMPONENT;
 8015a42:	4b6c      	ldr	r3, [pc, #432]	@ (8015bf4 <GetRDN+0x2f4>)
 8015a44:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_DOMAIN_COMPONENT) - 1;
 8015a46:	2304      	movs	r3, #4
 8015a48:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_domainComponent;
 8015a4c:	683b      	ldr	r3, [r7, #0]
 8015a4e:	2219      	movs	r2, #25
 8015a50:	601a      	str	r2, [r3, #0]
 8015a52:	e06f      	b.n	8015b34 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(rfc822Mlbx) && XMEMCMP(oid, rfc822Mlbx, oidSz) == 0) {
 8015a54:	69fb      	ldr	r3, [r7, #28]
 8015a56:	2b0a      	cmp	r3, #10
 8015a58:	d114      	bne.n	8015a84 <GetRDN+0x184>
 8015a5a:	6a3b      	ldr	r3, [r7, #32]
 8015a5c:	69fa      	ldr	r2, [r7, #28]
 8015a5e:	4966      	ldr	r1, [pc, #408]	@ (8015bf8 <GetRDN+0x2f8>)
 8015a60:	4618      	mov	r0, r3
 8015a62:	f012 fd0b 	bl	802847c <memcmp>
 8015a66:	4603      	mov	r3, r0
 8015a68:	2b00      	cmp	r3, #0
 8015a6a:	d10b      	bne.n	8015a84 <GetRDN+0x184>
        /* Set the RFC822 mailbox, type string, length and NID. */
        id = ASN_RFC822_MAILBOX;
 8015a6c:	2314      	movs	r3, #20
 8015a6e:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_RFC822_MAILBOX;
 8015a70:	4b62      	ldr	r3, [pc, #392]	@ (8015bfc <GetRDN+0x2fc>)
 8015a72:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_RFC822_MAILBOX) - 1;
 8015a74:	230f      	movs	r3, #15
 8015a76:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_rfc822Mailbox;
 8015a7a:	683b      	ldr	r3, [r7, #0]
 8015a7c:	f44f 72e6 	mov.w	r2, #460	@ 0x1cc
 8015a80:	601a      	str	r2, [r3, #0]
 8015a82:	e057      	b.n	8015b34 <GetRDN+0x234>
    #endif
    }
    else if (oidSz == sizeof(fvrtDrk) && XMEMCMP(oid, fvrtDrk, oidSz) == 0) {
 8015a84:	69fb      	ldr	r3, [r7, #28]
 8015a86:	2b0a      	cmp	r3, #10
 8015a88:	d114      	bne.n	8015ab4 <GetRDN+0x1b4>
 8015a8a:	6a3b      	ldr	r3, [r7, #32]
 8015a8c:	69fa      	ldr	r2, [r7, #28]
 8015a8e:	495c      	ldr	r1, [pc, #368]	@ (8015c00 <GetRDN+0x300>)
 8015a90:	4618      	mov	r0, r3
 8015a92:	f012 fcf3 	bl	802847c <memcmp>
 8015a96:	4603      	mov	r3, r0
 8015a98:	2b00      	cmp	r3, #0
 8015a9a:	d10b      	bne.n	8015ab4 <GetRDN+0x1b4>
        /* Set the favourite drink, type string, length and NID. */
        id = ASN_FAVOURITE_DRINK;
 8015a9c:	2313      	movs	r3, #19
 8015a9e:	62bb      	str	r3, [r7, #40]	@ 0x28
        typeStr = WOLFSSL_FAVOURITE_DRINK;
 8015aa0:	4b58      	ldr	r3, [pc, #352]	@ (8015c04 <GetRDN+0x304>)
 8015aa2:	633b      	str	r3, [r7, #48]	@ 0x30
        typeStrLen = sizeof(WOLFSSL_FAVOURITE_DRINK) - 1;
 8015aa4:	2310      	movs	r3, #16
 8015aa6:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    #ifdef WOLFSSL_X509_NAME_AVAILABLE
        *nid = WC_NID_favouriteDrink;
 8015aaa:	683b      	ldr	r3, [r7, #0]
 8015aac:	f44f 72e7 	mov.w	r2, #462	@ 0x1ce
 8015ab0:	601a      	str	r2, [r3, #0]
 8015ab2:	e03f      	b.n	8015b34 <GetRDN+0x234>
        *nid = WC_NID_pkcs9_contentType;
    #endif
    }
#endif
    /* Other OIDs that start with the same values. */
    else if (oidSz == sizeof(dcOid) && XMEMCMP(oid, dcOid, oidSz-1) == 0) {
 8015ab4:	69fb      	ldr	r3, [r7, #28]
 8015ab6:	2b0a      	cmp	r3, #10
 8015ab8:	d10d      	bne.n	8015ad6 <GetRDN+0x1d6>
 8015aba:	6a38      	ldr	r0, [r7, #32]
 8015abc:	69fb      	ldr	r3, [r7, #28]
 8015abe:	3b01      	subs	r3, #1
 8015ac0:	461a      	mov	r2, r3
 8015ac2:	494b      	ldr	r1, [pc, #300]	@ (8015bf0 <GetRDN+0x2f0>)
 8015ac4:	f012 fcda 	bl	802847c <memcmp>
 8015ac8:	4603      	mov	r3, r0
 8015aca:	2b00      	cmp	r3, #0
 8015acc:	d103      	bne.n	8015ad6 <GetRDN+0x1d6>
        WOLFSSL_MSG("Unknown pilot attribute type");
        WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
        ret = ASN_PARSE_E;
 8015ace:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015ad2:	637b      	str	r3, [r7, #52]	@ 0x34
 8015ad4:	e02e      	b.n	8015b34 <GetRDN+0x234>
    }
    else if (oidSz == ASN_JOI_PREFIX_SZ + 1 &&
 8015ad6:	69fb      	ldr	r3, [r7, #28]
 8015ad8:	2b0b      	cmp	r3, #11
 8015ada:	d12b      	bne.n	8015b34 <GetRDN+0x234>
                         XMEMCMP(oid, ASN_JOI_PREFIX, ASN_JOI_PREFIX_SZ) == 0) {
 8015adc:	6a3b      	ldr	r3, [r7, #32]
 8015ade:	220a      	movs	r2, #10
 8015ae0:	4949      	ldr	r1, [pc, #292]	@ (8015c08 <GetRDN+0x308>)
 8015ae2:	4618      	mov	r0, r3
 8015ae4:	f012 fcca 	bl	802847c <memcmp>
 8015ae8:	4603      	mov	r3, r0
    else if (oidSz == ASN_JOI_PREFIX_SZ + 1 &&
 8015aea:	2b00      	cmp	r3, #0
 8015aec:	d122      	bne.n	8015b34 <GetRDN+0x234>
        /* Set the jurisdiction id. */
        id = 0x200 + oid[ASN_JOI_PREFIX_SZ];
 8015aee:	6a3b      	ldr	r3, [r7, #32]
 8015af0:	330a      	adds	r3, #10
 8015af2:	781b      	ldrb	r3, [r3, #0]
 8015af4:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 8015af8:	62bb      	str	r3, [r7, #40]	@ 0x28

        /* Set the jurisdiction type string, length and NID if known. */
        if (oid[ASN_JOI_PREFIX_SZ] == ASN_JOI_C) {
 8015afa:	6a3b      	ldr	r3, [r7, #32]
 8015afc:	330a      	adds	r3, #10
 8015afe:	781b      	ldrb	r3, [r3, #0]
 8015b00:	2b03      	cmp	r3, #3
 8015b02:	d108      	bne.n	8015b16 <GetRDN+0x216>
            typeStr = WOLFSSL_JOI_C;
 8015b04:	4b41      	ldr	r3, [pc, #260]	@ (8015c0c <GetRDN+0x30c>)
 8015b06:	633b      	str	r3, [r7, #48]	@ 0x30
            typeStrLen = sizeof(WOLFSSL_JOI_C) - 1;
 8015b08:	230f      	movs	r3, #15
 8015b0a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            *nid = WC_NID_jurisdictionCountryName;
 8015b0e:	683b      	ldr	r3, [r7, #0]
 8015b10:	220c      	movs	r2, #12
 8015b12:	601a      	str	r2, [r3, #0]
 8015b14:	e00e      	b.n	8015b34 <GetRDN+0x234>
        #endif /* WOLFSSL_X509_NAME_AVAILABLE */
        }
        else if (oid[ASN_JOI_PREFIX_SZ] == ASN_JOI_ST) {
 8015b16:	6a3b      	ldr	r3, [r7, #32]
 8015b18:	330a      	adds	r3, #10
 8015b1a:	781b      	ldrb	r3, [r3, #0]
 8015b1c:	2b02      	cmp	r3, #2
 8015b1e:	d109      	bne.n	8015b34 <GetRDN+0x234>
            typeStr = WOLFSSL_JOI_ST;
 8015b20:	4b3b      	ldr	r3, [pc, #236]	@ (8015c10 <GetRDN+0x310>)
 8015b22:	633b      	str	r3, [r7, #48]	@ 0x30
            typeStrLen = sizeof(WOLFSSL_JOI_ST) - 1;
 8015b24:	2310      	movs	r3, #16
 8015b26:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            *nid = WC_NID_jurisdictionStateOrProvinceName;
 8015b2a:	683b      	ldr	r3, [r7, #0]
 8015b2c:	220d      	movs	r2, #13
 8015b2e:	601a      	str	r2, [r3, #0]
 8015b30:	e000      	b.n	8015b34 <GetRDN+0x234>
        if (ValidCertNameSubject(id)) {
 8015b32:	bf00      	nop
        else {
            WOLFSSL_MSG("Unknown Jurisdiction, skipping");
        }
    }

    if ((ret == 0) && (typeStr != NULL)) {
 8015b34:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015b36:	2b00      	cmp	r3, #0
 8015b38:	d14b      	bne.n	8015bd2 <GetRDN+0x2d2>
 8015b3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015b3c:	2b00      	cmp	r3, #0
 8015b3e:	d048      	beq.n	8015bd2 <GetRDN+0x2d2>
        /* OID type to store for subject name and add to full string. */
        byte*  str;
        word32 strLen;
        byte   tag = dataASN[RDNASN_IDX_ATTR_VAL].tag;
 8015b40:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015b42:	3354      	adds	r3, #84	@ 0x54
 8015b44:	7e5b      	ldrb	r3, [r3, #25]
 8015b46:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        /* Get the string reference and length. */
        GetASN_GetRef(&dataASN[RDNASN_IDX_ATTR_VAL], &str, &strLen);
 8015b4a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015b4c:	3354      	adds	r3, #84	@ 0x54
 8015b4e:	689b      	ldr	r3, [r3, #8]
 8015b50:	61bb      	str	r3, [r7, #24]
 8015b52:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015b54:	3354      	adds	r3, #84	@ 0x54
 8015b56:	68db      	ldr	r3, [r3, #12]
 8015b58:	617b      	str	r3, [r7, #20]

        if (isSubject) {
 8015b5a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015b5c:	2b00      	cmp	r3, #0
 8015b5e:	d00b      	beq.n	8015b78 <GetRDN+0x278>
            /* Store subject field components. */
            ret = SetSubject(cert, id, str, (int)strLen, tag);
 8015b60:	69ba      	ldr	r2, [r7, #24]
 8015b62:	697b      	ldr	r3, [r7, #20]
 8015b64:	4619      	mov	r1, r3
 8015b66:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8015b6a:	9300      	str	r3, [sp, #0]
 8015b6c:	460b      	mov	r3, r1
 8015b6e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8015b70:	68f8      	ldr	r0, [r7, #12]
 8015b72:	f7ff fe97 	bl	80158a4 <SetSubject>
 8015b76:	6378      	str	r0, [r7, #52]	@ 0x34
        /* Put issuer common name string and encoding into certificate. */
        else {
            ret = SetIssuer(cert, id, str, (int)strLen, tag);
        }
    #endif
        if (ret == 0) {
 8015b78:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015b7a:	2b00      	cmp	r3, #0
 8015b7c:	d129      	bne.n	8015bd2 <GetRDN+0x2d2>
            /* Check there is space for this in the full name string and
             * terminating NUL character. */
            if ((typeStrLen + strLen) < (word32)(WC_ASN_NAME_MAX - *idx))
 8015b7e:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
 8015b82:	697b      	ldr	r3, [r7, #20]
 8015b84:	441a      	add	r2, r3
 8015b86:	687b      	ldr	r3, [r7, #4]
 8015b88:	681b      	ldr	r3, [r3, #0]
 8015b8a:	f5c3 73b4 	rsb	r3, r3, #360	@ 0x168
 8015b8e:	429a      	cmp	r2, r3
 8015b90:	d21f      	bcs.n	8015bd2 <GetRDN+0x2d2>
            {
                /* Add RDN to full string. */
                XMEMCPY(&full[*idx], typeStr, typeStrLen);
 8015b92:	687b      	ldr	r3, [r7, #4]
 8015b94:	681b      	ldr	r3, [r3, #0]
 8015b96:	68ba      	ldr	r2, [r7, #8]
 8015b98:	4413      	add	r3, r2
 8015b9a:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
 8015b9e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8015ba0:	4618      	mov	r0, r3
 8015ba2:	f012 fcff 	bl	80285a4 <memcpy>
                *idx += typeStrLen;
 8015ba6:	687b      	ldr	r3, [r7, #4]
 8015ba8:	681a      	ldr	r2, [r3, #0]
 8015baa:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8015bae:	441a      	add	r2, r3
 8015bb0:	687b      	ldr	r3, [r7, #4]
 8015bb2:	601a      	str	r2, [r3, #0]
                XMEMCPY(&full[*idx], str, strLen);
 8015bb4:	687b      	ldr	r3, [r7, #4]
 8015bb6:	681b      	ldr	r3, [r3, #0]
 8015bb8:	68ba      	ldr	r2, [r7, #8]
 8015bba:	4413      	add	r3, r2
 8015bbc:	69b9      	ldr	r1, [r7, #24]
 8015bbe:	697a      	ldr	r2, [r7, #20]
 8015bc0:	4618      	mov	r0, r3
 8015bc2:	f012 fcef 	bl	80285a4 <memcpy>
                *idx += strLen;
 8015bc6:	687b      	ldr	r3, [r7, #4]
 8015bc8:	681a      	ldr	r2, [r3, #0]
 8015bca:	697b      	ldr	r3, [r7, #20]
 8015bcc:	441a      	add	r2, r3
 8015bce:	687b      	ldr	r3, [r7, #4]
 8015bd0:	601a      	str	r2, [r3, #0]
                WOLFSSL_MSG("ASN Name too big, skipping");
            }
        }
    }

    return ret;
 8015bd2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8015bd4:	4618      	mov	r0, r3
 8015bd6:	3738      	adds	r7, #56	@ 0x38
 8015bd8:	46bd      	mov	sp, r7
 8015bda:	bd80      	pop	{r7, pc}
 8015bdc:	080336b8 	.word	0x080336b8
 8015be0:	08033580 	.word	0x08033580
 8015be4:	0802f7fc 	.word	0x0802f7fc
 8015be8:	080335a4 	.word	0x080335a4
 8015bec:	0802f80c 	.word	0x0802f80c
 8015bf0:	080335c8 	.word	0x080335c8
 8015bf4:	0802f814 	.word	0x0802f814
 8015bf8:	080335b0 	.word	0x080335b0
 8015bfc:	0802f81c 	.word	0x0802f81c
 8015c00:	080335bc 	.word	0x080335bc
 8015c04:	0802f82c 	.word	0x0802f82c
 8015c08:	0802f840 	.word	0x0802f840
 8015c0c:	0802f84c 	.word	0x0802f84c
 8015c10:	0802f85c 	.word	0x0802f85c

08015c14 <GetCertName>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int GetCertName(DecodedCert* cert, char* full, byte* hash, int nameType,
                       const byte* input, word32* inOutIdx, word32 maxIdx)
{
 8015c14:	b5b0      	push	{r4, r5, r7, lr}
 8015c16:	b094      	sub	sp, #80	@ 0x50
 8015c18:	af04      	add	r7, sp, #16
 8015c1a:	60f8      	str	r0, [r7, #12]
 8015c1c:	60b9      	str	r1, [r7, #8]
 8015c1e:	607a      	str	r2, [r7, #4]
 8015c20:	603b      	str	r3, [r7, #0]

    *inOutIdx = srcIdx;

    return 0;
#else
    DECL_ASNGETDATA(dataASN, rdnASN_Length);
 8015c22:	2300      	movs	r3, #0
 8015c24:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int    ret = 0;
 8015c26:	2300      	movs	r3, #0
 8015c28:	63bb      	str	r3, [r7, #56]	@ 0x38
    word32 idx = 0;
 8015c2a:	2300      	movs	r3, #0
 8015c2c:	627b      	str	r3, [r7, #36]	@ 0x24
    int    len = 0;
 8015c2e:	2300      	movs	r3, #0
 8015c30:	623b      	str	r3, [r7, #32]
    word32 srcIdx = *inOutIdx;
 8015c32:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8015c34:	681b      	ldr	r3, [r3, #0]
 8015c36:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_X509_NAME_AVAILABLE
    WOLFSSL_X509_NAME* dName = NULL;
 8015c38:	2300      	movs	r3, #0
 8015c3a:	637b      	str	r3, [r7, #52]	@ 0x34
    WOLFSSL_MSG("Getting Cert Name");

    /* For OCSP, RFC2560 section 4.1.1 states the issuer hash should be
     * calculated over the entire DER encoding of the Name field, including
     * the tag and length. */
    if (CalcHashId_ex(input + srcIdx, maxIdx - srcIdx, hash,
 8015c3c:	69fb      	ldr	r3, [r7, #28]
 8015c3e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8015c40:	18d4      	adds	r4, r2, r3
 8015c42:	69fb      	ldr	r3, [r7, #28]
 8015c44:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8015c46:	1ad5      	subs	r5, r2, r3
 8015c48:	68fb      	ldr	r3, [r7, #12]
 8015c4a:	699b      	ldr	r3, [r3, #24]
 8015c4c:	4618      	mov	r0, r3
 8015c4e:	f7ff fd51 	bl	80156f4 <HashIdAlg>
 8015c52:	4603      	mov	r3, r0
 8015c54:	687a      	ldr	r2, [r7, #4]
 8015c56:	4629      	mov	r1, r5
 8015c58:	4620      	mov	r0, r4
 8015c5a:	f7ff fd67 	bl	801572c <CalcHashId_ex>
 8015c5e:	4603      	mov	r3, r0
 8015c60:	2b00      	cmp	r3, #0
 8015c62:	d002      	beq.n	8015c6a <GetCertName+0x56>
            HashIdAlg(cert->signatureOID)) != 0) {
        ret = ASN_PARSE_E;
 8015c64:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015c68:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    CALLOC_ASNGETDATA(dataASN, rdnASN_Length, ret, cert->heap);
 8015c6a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015c6c:	2b00      	cmp	r3, #0
 8015c6e:	d109      	bne.n	8015c84 <GetCertName+0x70>
 8015c70:	2070      	movs	r0, #112	@ 0x70
 8015c72:	f008 ff0f 	bl	801ea94 <wolfSSL_Malloc>
 8015c76:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8015c78:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015c7a:	2b00      	cmp	r3, #0
 8015c7c:	d102      	bne.n	8015c84 <GetCertName+0x70>
 8015c7e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015c82:	63bb      	str	r3, [r7, #56]	@ 0x38
 8015c84:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015c86:	2b00      	cmp	r3, #0
 8015c88:	d104      	bne.n	8015c94 <GetCertName+0x80>
 8015c8a:	2270      	movs	r2, #112	@ 0x70
 8015c8c:	2100      	movs	r1, #0
 8015c8e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8015c90:	f012 fc1e 	bl	80284d0 <memset>

#ifdef WOLFSSL_X509_NAME_AVAILABLE
    if (ret == 0) {
 8015c94:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015c96:	2b00      	cmp	r3, #0
 8015c98:	d10c      	bne.n	8015cb4 <GetCertName+0xa0>
        /* Create an X509_NAME to hold data for OpenSSL compatibility APIs. */
        dName = wolfSSL_X509_NAME_new_ex(cert->heap);
 8015c9a:	68fb      	ldr	r3, [r7, #12]
 8015c9c:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8015ca0:	4618      	mov	r0, r3
 8015ca2:	f7f8 fc84 	bl	800e5ae <wolfSSL_X509_NAME_new_ex>
 8015ca6:	6378      	str	r0, [r7, #52]	@ 0x34
        if (dName == NULL) {
 8015ca8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015caa:	2b00      	cmp	r3, #0
 8015cac:	d102      	bne.n	8015cb4 <GetCertName+0xa0>
            ret = MEMORY_E;
 8015cae:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015cb2:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
    }
#endif /* WOLFSSL_X509_NAME_AVAILABLE */

    if (ret == 0) {
 8015cb4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015cb6:	2b00      	cmp	r3, #0
 8015cb8:	d10a      	bne.n	8015cd0 <GetCertName+0xbc>
        /* Expecting a SEQUENCE using up all data. */
        ret = GetASN_Sequence(input, &srcIdx, &len, maxIdx, 1);
 8015cba:	f107 0220 	add.w	r2, r7, #32
 8015cbe:	f107 011c 	add.w	r1, r7, #28
 8015cc2:	2301      	movs	r3, #1
 8015cc4:	9300      	str	r3, [sp, #0]
 8015cc6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8015cc8:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8015cca:	f7fd ffc6 	bl	8013c5a <GetASN_Sequence>
 8015cce:	63b8      	str	r0, [r7, #56]	@ 0x38
    }
    if (ret == 0) {
 8015cd0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015cd2:	2b00      	cmp	r3, #0
 8015cd4:	f040 808a 	bne.w	8015dec <GetCertName+0x1d8>
            cert->issuerRawLen = len;
        }
    #endif
    #if !defined(IGNORE_NAME_CONSTRAINTS) || defined(WOLFSSL_CERT_EXT)
        /* Store pointer and length to raw subject. */
        if (nameType == ASN_SUBJECT) {
 8015cd8:	683b      	ldr	r3, [r7, #0]
 8015cda:	2b01      	cmp	r3, #1
 8015cdc:	d17f      	bne.n	8015dde <GetCertName+0x1ca>
            cert->subjectRaw = &input[srcIdx];
 8015cde:	69fb      	ldr	r3, [r7, #28]
 8015ce0:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8015ce2:	441a      	add	r2, r3
 8015ce4:	68fb      	ldr	r3, [r7, #12]
 8015ce6:	f8c3 2454 	str.w	r2, [r3, #1108]	@ 0x454
            cert->subjectRawLen = len;
 8015cea:	6a3a      	ldr	r2, [r7, #32]
 8015cec:	68fb      	ldr	r3, [r7, #12]
 8015cee:	f8c3 2458 	str.w	r2, [r3, #1112]	@ 0x458
        }
    #endif

        /* Process all RDNs in name. */
        while ((ret == 0) && (srcIdx < maxIdx)) {
 8015cf2:	e074      	b.n	8015dde <GetCertName+0x1ca>
            int nid = 0;
 8015cf4:	2300      	movs	r3, #0
 8015cf6:	61bb      	str	r3, [r7, #24]

            /* Initialize for data and setup RDN choice. */
            GetASN_Choice(&dataASN[RDNASN_IDX_ATTR_VAL], rdnChoice);
 8015cf8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015cfa:	3354      	adds	r3, #84	@ 0x54
 8015cfc:	220b      	movs	r2, #11
 8015cfe:	761a      	strb	r2, [r3, #24]
 8015d00:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d02:	3354      	adds	r3, #84	@ 0x54
 8015d04:	4a4f      	ldr	r2, [pc, #316]	@ (8015e44 <GetCertName+0x230>)
 8015d06:	609a      	str	r2, [r3, #8]
            /* Ignore type OID as too many to store in table. */
            GetASN_OID(&dataASN[RDNASN_IDX_ATTR_TYPE], oidIgnoreType);
 8015d08:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d0a:	3338      	adds	r3, #56	@ 0x38
 8015d0c:	2215      	movs	r2, #21
 8015d0e:	611a      	str	r2, [r3, #16]
            /* Parse RDN. */
            ret = GetASN_Items(rdnASN, dataASN, rdnASN_Length, 1, input,
 8015d10:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8015d12:	9302      	str	r3, [sp, #8]
 8015d14:	f107 031c 	add.w	r3, r7, #28
 8015d18:	9301      	str	r3, [sp, #4]
 8015d1a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8015d1c:	9300      	str	r3, [sp, #0]
 8015d1e:	2301      	movs	r3, #1
 8015d20:	2204      	movs	r2, #4
 8015d22:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8015d24:	4848      	ldr	r0, [pc, #288]	@ (8015e48 <GetCertName+0x234>)
 8015d26:	f7fd fcf1 	bl	801370c <GetASN_Items>
 8015d2a:	63b8      	str	r0, [r7, #56]	@ 0x38
                               &srcIdx, maxIdx);
            if (ret == 0) {
 8015d2c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015d2e:	2b00      	cmp	r3, #0
 8015d30:	d113      	bne.n	8015d5a <GetCertName+0x146>
                /* Put RDN data into certificate. */
                ret = GetRDN(cert, full, &idx, &nid, nameType == ASN_SUBJECT,
 8015d32:	683b      	ldr	r3, [r7, #0]
 8015d34:	2b01      	cmp	r3, #1
 8015d36:	bf0c      	ite	eq
 8015d38:	2301      	moveq	r3, #1
 8015d3a:	2300      	movne	r3, #0
 8015d3c:	b2db      	uxtb	r3, r3
 8015d3e:	4618      	mov	r0, r3
 8015d40:	f107 0118 	add.w	r1, r7, #24
 8015d44:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 8015d48:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d4a:	9301      	str	r3, [sp, #4]
 8015d4c:	9000      	str	r0, [sp, #0]
 8015d4e:	460b      	mov	r3, r1
 8015d50:	68b9      	ldr	r1, [r7, #8]
 8015d52:	68f8      	ldr	r0, [r7, #12]
 8015d54:	f7ff fdd4 	bl	8015900 <GetRDN>
 8015d58:	63b8      	str	r0, [r7, #56]	@ 0x38
                             dataASN);
            }
        #ifdef WOLFSSL_X509_NAME_AVAILABLE
            /* TODO: push this back up to ssl.c
             * (do parsing for WOLFSSL_X509_NAME on demand) */
            if (ret == 0) {
 8015d5a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015d5c:	2b00      	cmp	r3, #0
 8015d5e:	d13e      	bne.n	8015dde <GetCertName+0x1ca>
                int enc;
                byte*  str;
                word32 strLen;
                byte   tag = dataASN[RDNASN_IDX_ATTR_VAL].tag;
 8015d60:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d62:	3354      	adds	r3, #84	@ 0x54
 8015d64:	7e5b      	ldrb	r3, [r3, #25]
 8015d66:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

                /* Get string reference. */
                GetASN_GetRef(&dataASN[RDNASN_IDX_ATTR_VAL], &str, &strLen);
 8015d6a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d6c:	3354      	adds	r3, #84	@ 0x54
 8015d6e:	689b      	ldr	r3, [r3, #8]
 8015d70:	617b      	str	r3, [r7, #20]
 8015d72:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015d74:	3354      	adds	r3, #84	@ 0x54
 8015d76:	68db      	ldr	r3, [r3, #12]
 8015d78:	613b      	str	r3, [r7, #16]

            #ifndef WOLFSSL_NO_ASN_STRICT
                /* RFC 5280 section 4.1.2.4 lists a DirectoryString as being
                 * 1..MAX in length */
                if (ret == 0 && strLen < 1) {
 8015d7a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015d7c:	2b00      	cmp	r3, #0
 8015d7e:	d105      	bne.n	8015d8c <GetCertName+0x178>
 8015d80:	693b      	ldr	r3, [r7, #16]
 8015d82:	2b00      	cmp	r3, #0
 8015d84:	d102      	bne.n	8015d8c <GetCertName+0x178>
                    WOLFSSL_MSG("Non conforming DirectoryString of length 0 was"
                                " found");
                    WOLFSSL_MSG("Use WOLFSSL_NO_ASN_STRICT if wanting to allow"
                                " empty DirectoryString's");
                    ret = ASN_PARSE_E;
 8015d86:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015d8a:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
            #endif

                /* Convert BER tag to a OpenSSL type. */
                switch (tag) {
 8015d8c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8015d90:	2b0c      	cmp	r3, #12
 8015d92:	d002      	beq.n	8015d9a <GetCertName+0x186>
 8015d94:	2b13      	cmp	r3, #19
 8015d96:	d004      	beq.n	8015da2 <GetCertName+0x18e>
 8015d98:	e006      	b.n	8015da8 <GetCertName+0x194>
                    case CTC_UTF8:
                        enc = WOLFSSL_MBSTRING_UTF8;
 8015d9a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8015d9e:	633b      	str	r3, [r7, #48]	@ 0x30
                        break;
 8015da0:	e005      	b.n	8015dae <GetCertName+0x19a>
                    case CTC_PRINTABLE:
                        enc = WOLFSSL_V_ASN1_PRINTABLESTRING;
 8015da2:	2313      	movs	r3, #19
 8015da4:	633b      	str	r3, [r7, #48]	@ 0x30
                        break;
 8015da6:	e002      	b.n	8015dae <GetCertName+0x19a>
                    default:
                        WOLFSSL_MSG("Unknown encoding type, default UTF8");
                        enc = WOLFSSL_MBSTRING_UTF8;
 8015da8:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8015dac:	633b      	str	r3, [r7, #48]	@ 0x30
                }
                if (nid != 0) {
 8015dae:	69bb      	ldr	r3, [r7, #24]
 8015db0:	2b00      	cmp	r3, #0
 8015db2:	d014      	beq.n	8015dde <GetCertName+0x1ca>
                    /* Add an entry to the X509_NAME. */
                    if (wolfSSL_X509_NAME_add_entry_by_NID(dName, nid, enc, str,
 8015db4:	69b9      	ldr	r1, [r7, #24]
 8015db6:	697b      	ldr	r3, [r7, #20]
 8015db8:	693a      	ldr	r2, [r7, #16]
 8015dba:	4610      	mov	r0, r2
 8015dbc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8015dc0:	9202      	str	r2, [sp, #8]
 8015dc2:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8015dc6:	9201      	str	r2, [sp, #4]
 8015dc8:	9000      	str	r0, [sp, #0]
 8015dca:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8015dcc:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8015dce:	f7f8 fe83 	bl	800ead8 <wolfSSL_X509_NAME_add_entry_by_NID>
 8015dd2:	4603      	mov	r3, r0
 8015dd4:	2b01      	cmp	r3, #1
 8015dd6:	d002      	beq.n	8015dde <GetCertName+0x1ca>
                            (int)strLen, -1, -1) != WOLFSSL_SUCCESS) {
                        ret = ASN_PARSE_E;
 8015dd8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8015ddc:	63bb      	str	r3, [r7, #56]	@ 0x38
        while ((ret == 0) && (srcIdx < maxIdx)) {
 8015dde:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015de0:	2b00      	cmp	r3, #0
 8015de2:	d103      	bne.n	8015dec <GetCertName+0x1d8>
 8015de4:	69fb      	ldr	r3, [r7, #28]
 8015de6:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8015de8:	429a      	cmp	r2, r3
 8015dea:	d883      	bhi.n	8015cf4 <GetCertName+0xe0>
                }
            }
        #endif
        }
    }
    if (ret == 0) {
 8015dec:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015dee:	2b00      	cmp	r3, #0
 8015df0:	d114      	bne.n	8015e1c <GetCertName+0x208>
        /* Terminate string. */
        full[idx] = 0;
 8015df2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015df4:	68ba      	ldr	r2, [r7, #8]
 8015df6:	4413      	add	r3, r2
 8015df8:	2200      	movs	r2, #0
 8015dfa:	701a      	strb	r2, [r3, #0]
        /* Return index into encoding after name. */
        *inOutIdx = srcIdx;
 8015dfc:	69fa      	ldr	r2, [r7, #28]
 8015dfe:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8015e00:	601a      	str	r2, [r3, #0]

#ifdef WOLFSSL_X509_NAME_AVAILABLE
        /* Store X509_NAME in certificate. */
        if (nameType == ASN_ISSUER) {
 8015e02:	683b      	ldr	r3, [r7, #0]
 8015e04:	2b00      	cmp	r3, #0
 8015e06:	d104      	bne.n	8015e12 <GetCertName+0x1fe>
            (defined(HAVE_PKCS7) || defined(WOLFSSL_CERT_EXT))
            dName->rawLen = (int)min((word32)cert->issuerRawLen,
                WC_ASN_NAME_MAX);
            XMEMCPY(dName->raw, cert->issuerRaw, (size_t)dName->rawLen);
        #endif
            cert->issuerName = dName;
 8015e08:	68fb      	ldr	r3, [r7, #12]
 8015e0a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8015e0c:	f8c3 2464 	str.w	r2, [r3, #1124]	@ 0x464
 8015e10:	e007      	b.n	8015e22 <GetCertName+0x20e>
        #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX)
            dName->rawLen = (int)min((word32)cert->subjectRawLen,
                WC_ASN_NAME_MAX);
            XMEMCPY(dName->raw, cert->subjectRaw, (size_t)dName->rawLen);
        #endif
            cert->subjectName = dName;
 8015e12:	68fb      	ldr	r3, [r7, #12]
 8015e14:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8015e16:	f8c3 2468 	str.w	r2, [r3, #1128]	@ 0x468
 8015e1a:	e002      	b.n	8015e22 <GetCertName+0x20e>
        }
    }
    else {
        /* Dispose of unused X509_NAME. */
        wolfSSL_X509_NAME_free(dName);
 8015e1c:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8015e1e:	f7f8 fbb0 	bl	800e582 <wolfSSL_X509_NAME_free>
#endif
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8015e22:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015e24:	2b00      	cmp	r3, #0
 8015e26:	d007      	beq.n	8015e38 <GetCertName+0x224>
 8015e28:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015e2a:	62bb      	str	r3, [r7, #40]	@ 0x28
 8015e2c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015e2e:	2b00      	cmp	r3, #0
 8015e30:	d002      	beq.n	8015e38 <GetCertName+0x224>
 8015e32:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8015e34:	f008 fe4a 	bl	801eacc <wolfSSL_Free>
    return ret;
 8015e38:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015e3a:	4618      	mov	r0, r3
 8015e3c:	3740      	adds	r7, #64	@ 0x40
 8015e3e:	46bd      	mov	sp, r7
 8015e40:	bdb0      	pop	{r4, r5, r7, pc}
 8015e42:	bf00      	nop
 8015e44:	08033788 	.word	0x08033788
 8015e48:	08033778 	.word	0x08033778

08015e4c <DecodeToKey>:
 * @return  ASN_OBJECT_ID_E when the expected OBJECT_ID tag is not found.
 * @return  ASN_BITSTR_E when the expected BIT_STRING tag is not found.
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set.
 */
int DecodeToKey(DecodedCert* cert, int verify)
{
 8015e4c:	b580      	push	{r7, lr}
 8015e4e:	b086      	sub	sp, #24
 8015e50:	af02      	add	r7, sp, #8
 8015e52:	6078      	str	r0, [r7, #4]
 8015e54:	6039      	str	r1, [r7, #0]
        return badDate;

    return ret;
#else
    int ret;
    int badDate = 0;
 8015e56:	2300      	movs	r3, #0
 8015e58:	60bb      	str	r3, [r7, #8]
     * This is required to parse a potential alternative public key in the
     * SubjectAlternativeKey extension. */
    ret = DecodeCertInternal(cert, verify, NULL, &badDate, 0, 0);
#else
    /* Call internal version and stop after public key. */
    ret = DecodeCertInternal(cert, verify, NULL, &badDate, 0, 1);
 8015e5a:	f107 0308 	add.w	r3, r7, #8
 8015e5e:	2201      	movs	r2, #1
 8015e60:	9201      	str	r2, [sp, #4]
 8015e62:	2200      	movs	r2, #0
 8015e64:	9200      	str	r2, [sp, #0]
 8015e66:	2200      	movs	r2, #0
 8015e68:	6839      	ldr	r1, [r7, #0]
 8015e6a:	6878      	ldr	r0, [r7, #4]
 8015e6c:	f002 f8ae 	bl	8017fcc <DecodeCertInternal>
 8015e70:	60f8      	str	r0, [r7, #12]
#endif
    /* Always return date errors. */
    if (ret == 0) {
 8015e72:	68fb      	ldr	r3, [r7, #12]
 8015e74:	2b00      	cmp	r3, #0
 8015e76:	d101      	bne.n	8015e7c <DecodeToKey+0x30>
        ret = badDate;
 8015e78:	68bb      	ldr	r3, [r7, #8]
 8015e7a:	60fb      	str	r3, [r7, #12]
    }
    return ret;
 8015e7c:	68fb      	ldr	r3, [r7, #12]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8015e7e:	4618      	mov	r0, r3
 8015e80:	3710      	adds	r7, #16
 8015e82:	46bd      	mov	sp, r7
 8015e84:	bd80      	pop	{r7, pc}

08015e86 <SetLength>:
 * @param [in]  length  Value to encode.
 * @param [out] output  Buffer to encode into.
 * @return  Number of bytes encoded.
 */
word32 SetLength(word32 length, byte* output)
{
 8015e86:	b580      	push	{r7, lr}
 8015e88:	b084      	sub	sp, #16
 8015e8a:	af00      	add	r7, sp, #0
 8015e8c:	6078      	str	r0, [r7, #4]
 8015e8e:	6039      	str	r1, [r7, #0]
    /* Start encoding at start of buffer. */
    word32 i = 0;
 8015e90:	2300      	movs	r3, #0
 8015e92:	60fb      	str	r3, [r7, #12]

    if (length < ASN_LONG_LENGTH) {
 8015e94:	687b      	ldr	r3, [r7, #4]
 8015e96:	2b7f      	cmp	r3, #127	@ 0x7f
 8015e98:	d80c      	bhi.n	8015eb4 <SetLength+0x2e>
        /* Only one byte needed to encode. */
        if (output) {
 8015e9a:	683b      	ldr	r3, [r7, #0]
 8015e9c:	2b00      	cmp	r3, #0
 8015e9e:	d005      	beq.n	8015eac <SetLength+0x26>
            /* Write out length value. */
            output[i] = (byte)length;
 8015ea0:	683a      	ldr	r2, [r7, #0]
 8015ea2:	68fb      	ldr	r3, [r7, #12]
 8015ea4:	4413      	add	r3, r2
 8015ea6:	687a      	ldr	r2, [r7, #4]
 8015ea8:	b2d2      	uxtb	r2, r2
 8015eaa:	701a      	strb	r2, [r3, #0]
        }
        /* Skip over length. */
        i++;
 8015eac:	68fb      	ldr	r3, [r7, #12]
 8015eae:	3301      	adds	r3, #1
 8015eb0:	60fb      	str	r3, [r7, #12]
 8015eb2:	e02a      	b.n	8015f0a <SetLength+0x84>
    }
    else {
        /* Calculate the number of bytes required to encode value. */
        byte j = (byte)BytePrecision(length);
 8015eb4:	6878      	ldr	r0, [r7, #4]
 8015eb6:	f7fc fc4a 	bl	801274e <BytePrecision>
 8015eba:	4603      	mov	r3, r0
 8015ebc:	72fb      	strb	r3, [r7, #11]

        if (output) {
 8015ebe:	683b      	ldr	r3, [r7, #0]
 8015ec0:	2b00      	cmp	r3, #0
 8015ec2:	d007      	beq.n	8015ed4 <SetLength+0x4e>
            /* Encode count byte. */
            output[i] = (byte)(j | ASN_LONG_LENGTH);
 8015ec4:	683a      	ldr	r2, [r7, #0]
 8015ec6:	68fb      	ldr	r3, [r7, #12]
 8015ec8:	4413      	add	r3, r2
 8015eca:	7afa      	ldrb	r2, [r7, #11]
 8015ecc:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 8015ed0:	b2d2      	uxtb	r2, r2
 8015ed2:	701a      	strb	r2, [r3, #0]
        }
        /* Skip over count byte. */
        i++;
 8015ed4:	68fb      	ldr	r3, [r7, #12]
 8015ed6:	3301      	adds	r3, #1
 8015ed8:	60fb      	str	r3, [r7, #12]

        /* Encode value as a big-endian byte array. */
        for (; j > 0; --j) {
 8015eda:	e013      	b.n	8015f04 <SetLength+0x7e>
            if (output) {
 8015edc:	683b      	ldr	r3, [r7, #0]
 8015ede:	2b00      	cmp	r3, #0
 8015ee0:	d00a      	beq.n	8015ef8 <SetLength+0x72>
                /* Encode next most-significant byte. */
                output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));
 8015ee2:	7afb      	ldrb	r3, [r7, #11]
 8015ee4:	3b01      	subs	r3, #1
 8015ee6:	00db      	lsls	r3, r3, #3
 8015ee8:	687a      	ldr	r2, [r7, #4]
 8015eea:	fa22 f103 	lsr.w	r1, r2, r3
 8015eee:	683a      	ldr	r2, [r7, #0]
 8015ef0:	68fb      	ldr	r3, [r7, #12]
 8015ef2:	4413      	add	r3, r2
 8015ef4:	b2ca      	uxtb	r2, r1
 8015ef6:	701a      	strb	r2, [r3, #0]
            }
            /* Skip over byte. */
            i++;
 8015ef8:	68fb      	ldr	r3, [r7, #12]
 8015efa:	3301      	adds	r3, #1
 8015efc:	60fb      	str	r3, [r7, #12]
        for (; j > 0; --j) {
 8015efe:	7afb      	ldrb	r3, [r7, #11]
 8015f00:	3b01      	subs	r3, #1
 8015f02:	72fb      	strb	r3, [r7, #11]
 8015f04:	7afb      	ldrb	r3, [r7, #11]
 8015f06:	2b00      	cmp	r3, #0
 8015f08:	d1e8      	bne.n	8015edc <SetLength+0x56>
        }
    }

    /* Return number of bytes in encoded length. */
    return i;
 8015f0a:	68fb      	ldr	r3, [r7, #12]
}
 8015f0c:	4618      	mov	r0, r3
 8015f0e:	3710      	adds	r7, #16
 8015f10:	46bd      	mov	sp, r7
 8015f12:	bd80      	pop	{r7, pc}

08015f14 <IsSigAlgoECDSA>:
 * @param [in] algoOID  Signature algorithm identifier.
 * @return  1 when algorithm is using ECDSA.
 * @return  0 otherwise.
 */
static WC_INLINE int IsSigAlgoECDSA(word32 algoOID)
{
 8015f14:	b480      	push	{r7}
 8015f16:	b083      	sub	sp, #12
 8015f18:	af00      	add	r7, sp, #0
 8015f1a:	6078      	str	r0, [r7, #4]
    /* ECDSA sigAlgo must not have ASN1 NULL parameters */
    if (algoOID == CTC_SHAwECDSA || algoOID == CTC_SHA256wECDSA ||
 8015f1c:	687b      	ldr	r3, [r7, #4]
 8015f1e:	f5b3 7f02 	cmp.w	r3, #520	@ 0x208
 8015f22:	d00d      	beq.n	8015f40 <IsSigAlgoECDSA+0x2c>
 8015f24:	687b      	ldr	r3, [r7, #4]
 8015f26:	f5b3 7f03 	cmp.w	r3, #524	@ 0x20c
 8015f2a:	d009      	beq.n	8015f40 <IsSigAlgoECDSA+0x2c>
 8015f2c:	687b      	ldr	r3, [r7, #4]
 8015f2e:	f240 220d 	movw	r2, #525	@ 0x20d
 8015f32:	4293      	cmp	r3, r2
 8015f34:	d004      	beq.n	8015f40 <IsSigAlgoECDSA+0x2c>
        algoOID == CTC_SHA384wECDSA || algoOID == CTC_SHA512wECDSA) {
 8015f36:	687b      	ldr	r3, [r7, #4]
 8015f38:	f240 220e 	movw	r2, #526	@ 0x20e
 8015f3c:	4293      	cmp	r3, r2
 8015f3e:	d101      	bne.n	8015f44 <IsSigAlgoECDSA+0x30>
        return 1;
 8015f40:	2301      	movs	r3, #1
 8015f42:	e000      	b.n	8015f46 <IsSigAlgoECDSA+0x32>
    }

    return 0;
 8015f44:	2300      	movs	r3, #0
}
 8015f46:	4618      	mov	r0, r3
 8015f48:	370c      	adds	r7, #12
 8015f4a:	46bd      	mov	sp, r7
 8015f4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f50:	4770      	bx	lr

08015f52 <IsSigAlgoECC>:
 * @param [in] algoOID  Algorithm OID.
 * @return  1 when is EC signing algorithm.
 * @return  0 otherwise.
 */
static WC_INLINE int IsSigAlgoECC(word32 algoOID)
{
 8015f52:	b580      	push	{r7, lr}
 8015f54:	b082      	sub	sp, #8
 8015f56:	af00      	add	r7, sp, #0
 8015f58:	6078      	str	r0, [r7, #4]
    (void)algoOID;

    return (0
        #ifdef HAVE_ECC
              || IsSigAlgoECDSA(algoOID)
 8015f5a:	6878      	ldr	r0, [r7, #4]
 8015f5c:	f7ff ffda 	bl	8015f14 <IsSigAlgoECDSA>
 8015f60:	4603      	mov	r3, r0
 8015f62:	2b00      	cmp	r3, #0
 8015f64:	bf14      	ite	ne
 8015f66:	2301      	movne	r3, #1
 8015f68:	2300      	moveq	r3, #0
 8015f6a:	b2db      	uxtb	r3, r3
              || (algoOID == SPHINCS_SMALL_LEVEL1k)
              || (algoOID == SPHINCS_SMALL_LEVEL3k)
              || (algoOID == SPHINCS_SMALL_LEVEL5k)
        #endif
    );
}
 8015f6c:	4618      	mov	r0, r3
 8015f6e:	3708      	adds	r7, #8
 8015f70:	46bd      	mov	sp, r7
 8015f72:	bd80      	pop	{r7, pc}

08015f74 <wc_EncodeSignature>:
 * @return  Encoded data size on success.
 * @return  0 when dynamic memory allocation fails.
 */
word32 wc_EncodeSignature(byte* out, const byte* digest, word32 digSz,
                          int hashOID)
{
 8015f74:	b590      	push	{r4, r7, lr}
 8015f76:	b091      	sub	sp, #68	@ 0x44
 8015f78:	af00      	add	r7, sp, #0
 8015f7a:	60f8      	str	r0, [r7, #12]
 8015f7c:	60b9      	str	r1, [r7, #8]
 8015f7e:	607a      	str	r2, [r7, #4]
 8015f80:	603b      	str	r3, [r7, #0]
    XMEMCPY(out + seqSz, algoArray, algoSz);
    XMEMCPY(out + seqSz + algoSz, digArray, encDigSz);

    return encDigSz + algoSz + seqSz;
#else
    DECL_ASNSETDATA(dataASN, digestInfoASN_Length);
 8015f82:	2300      	movs	r3, #0
 8015f84:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ret = 0;
 8015f86:	2300      	movs	r3, #0
 8015f88:	63bb      	str	r3, [r7, #56]	@ 0x38
    int sz = 0;
 8015f8a:	2300      	movs	r3, #0
 8015f8c:	633b      	str	r3, [r7, #48]	@ 0x30
    unsigned char dgst[WC_MAX_DIGEST_SIZE];

    CALLOC_ASNSETDATA(dataASN, digestInfoASN_Length, ret, NULL);
 8015f8e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015f90:	2b00      	cmp	r3, #0
 8015f92:	d109      	bne.n	8015fa8 <wc_EncodeSignature+0x34>
 8015f94:	208c      	movs	r0, #140	@ 0x8c
 8015f96:	f008 fd7d 	bl	801ea94 <wolfSSL_Malloc>
 8015f9a:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8015f9c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015f9e:	2b00      	cmp	r3, #0
 8015fa0:	d102      	bne.n	8015fa8 <wc_EncodeSignature+0x34>
 8015fa2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8015fa6:	63bb      	str	r3, [r7, #56]	@ 0x38
 8015fa8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015faa:	2b00      	cmp	r3, #0
 8015fac:	d104      	bne.n	8015fb8 <wc_EncodeSignature+0x44>
 8015fae:	2264      	movs	r2, #100	@ 0x64
 8015fb0:	2100      	movs	r1, #0
 8015fb2:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8015fb4:	f012 fa8c 	bl	80284d0 <memset>

    if (ret == 0) {
 8015fb8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015fba:	2b00      	cmp	r3, #0
 8015fbc:	d12a      	bne.n	8016014 <wc_EncodeSignature+0xa0>
        /* Set hash OID and type. */
        SetASN_OID(&dataASN[DIGESTINFOASN_IDX_DIGALGO_OID], (word32)hashOID,
 8015fbe:	6838      	ldr	r0, [r7, #0]
 8015fc0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015fc2:	3328      	adds	r3, #40	@ 0x28
 8015fc4:	f103 020c 	add.w	r2, r3, #12
 8015fc8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015fca:	f103 0428 	add.w	r4, r3, #40	@ 0x28
 8015fce:	2100      	movs	r1, #0
 8015fd0:	f7fe f864 	bl	801409c <OidFromId>
 8015fd4:	4603      	mov	r3, r0
 8015fd6:	60a3      	str	r3, [r4, #8]
                   oidHashType);
        /* Set digest. */
        if (digest == out) {
 8015fd8:	68ba      	ldr	r2, [r7, #8]
 8015fda:	68fb      	ldr	r3, [r7, #12]
 8015fdc:	429a      	cmp	r2, r3
 8015fde:	d109      	bne.n	8015ff4 <wc_EncodeSignature+0x80>
            XMEMCPY(dgst, digest, digSz);
 8015fe0:	f107 0310 	add.w	r3, r7, #16
 8015fe4:	687a      	ldr	r2, [r7, #4]
 8015fe6:	68b9      	ldr	r1, [r7, #8]
 8015fe8:	4618      	mov	r0, r3
 8015fea:	f012 fadb 	bl	80285a4 <memcpy>
            digest = dgst;
 8015fee:	f107 0310 	add.w	r3, r7, #16
 8015ff2:	60bb      	str	r3, [r7, #8]
        }
        SetASN_Buffer(&dataASN[DIGESTINFOASN_IDX_DIGEST], digest, digSz);
 8015ff4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015ff6:	3350      	adds	r3, #80	@ 0x50
 8015ff8:	68ba      	ldr	r2, [r7, #8]
 8015ffa:	609a      	str	r2, [r3, #8]
 8015ffc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015ffe:	3350      	adds	r3, #80	@ 0x50
 8016000:	687a      	ldr	r2, [r7, #4]
 8016002:	60da      	str	r2, [r3, #12]

        /* Calculate size of encoding. */
        ret = SizeASN_Items(digestInfoASN, dataASN, digestInfoASN_Length, &sz);
 8016004:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8016008:	2205      	movs	r2, #5
 801600a:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 801600c:	4810      	ldr	r0, [pc, #64]	@ (8016050 <wc_EncodeSignature+0xdc>)
 801600e:	f7fc fcdf 	bl	80129d0 <SizeASN_Items>
 8016012:	63b8      	str	r0, [r7, #56]	@ 0x38
    }
    if (ret == 0) {
 8016014:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8016016:	2b00      	cmp	r3, #0
 8016018:	d108      	bne.n	801602c <wc_EncodeSignature+0xb8>
        /* Encode PKCS#1 v1.5 RSA signature. */
        SetASN_Items(digestInfoASN, dataASN, digestInfoASN_Length, out);
 801601a:	68fb      	ldr	r3, [r7, #12]
 801601c:	2205      	movs	r2, #5
 801601e:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8016020:	480b      	ldr	r0, [pc, #44]	@ (8016050 <wc_EncodeSignature+0xdc>)
 8016022:	f7fc fed9 	bl	8012dd8 <SetASN_Items>
        ret = sz;
 8016026:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016028:	63bb      	str	r3, [r7, #56]	@ 0x38
 801602a:	e001      	b.n	8016030 <wc_EncodeSignature+0xbc>
    }
    else {
        /* Unsigned return type so 0 indicates error. */
        ret = 0;
 801602c:	2300      	movs	r3, #0
 801602e:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    FREE_ASNSETDATA(dataASN, NULL);
 8016030:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016032:	2b00      	cmp	r3, #0
 8016034:	d007      	beq.n	8016046 <wc_EncodeSignature+0xd2>
 8016036:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016038:	637b      	str	r3, [r7, #52]	@ 0x34
 801603a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801603c:	2b00      	cmp	r3, #0
 801603e:	d002      	beq.n	8016046 <wc_EncodeSignature+0xd2>
 8016040:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8016042:	f008 fd43 	bl	801eacc <wolfSSL_Free>
    return (word32)ret;
 8016046:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif
}
 8016048:	4618      	mov	r0, r3
 801604a:	3744      	adds	r7, #68	@ 0x44
 801604c:	46bd      	mov	sp, r7
 801604e:	bd90      	pop	{r4, r7, pc}
 8016050:	08033790 	.word	0x08033790

08016054 <InitSignatureCtx>:
 * @param [in, out] sigCtx  Signature context object.
 * @param [in]      heap    Dynamic memory hint.
 * @param [in]      devId   Hardware device identifier.
 */
void InitSignatureCtx(SignatureCtx* sigCtx, void* heap, int devId)
{
 8016054:	b580      	push	{r7, lr}
 8016056:	b084      	sub	sp, #16
 8016058:	af00      	add	r7, sp, #0
 801605a:	60f8      	str	r0, [r7, #12]
 801605c:	60b9      	str	r1, [r7, #8]
 801605e:	607a      	str	r2, [r7, #4]
    if (sigCtx) {
 8016060:	68fb      	ldr	r3, [r7, #12]
 8016062:	2b00      	cmp	r3, #0
 8016064:	d00a      	beq.n	801607c <InitSignatureCtx+0x28>
        XMEMSET(sigCtx, 0, sizeof(SignatureCtx));
 8016066:	2238      	movs	r2, #56	@ 0x38
 8016068:	2100      	movs	r1, #0
 801606a:	68f8      	ldr	r0, [r7, #12]
 801606c:	f012 fa30 	bl	80284d0 <memset>
        sigCtx->devId = devId;
 8016070:	68fb      	ldr	r3, [r7, #12]
 8016072:	687a      	ldr	r2, [r7, #4]
 8016074:	619a      	str	r2, [r3, #24]
        sigCtx->heap = heap;
 8016076:	68fb      	ldr	r3, [r7, #12]
 8016078:	68ba      	ldr	r2, [r7, #8]
 801607a:	601a      	str	r2, [r3, #0]
    }
}
 801607c:	bf00      	nop
 801607e:	3710      	adds	r7, #16
 8016080:	46bd      	mov	sp, r7
 8016082:	bd80      	pop	{r7, pc}

08016084 <FreeSignatureCtx>:
/* Free dynamic data in a signature context object.
 *
 * @param [in, out] sigCtx  Signature context object.
 */
void FreeSignatureCtx(SignatureCtx* sigCtx)
{
 8016084:	b580      	push	{r7, lr}
 8016086:	b086      	sub	sp, #24
 8016088:	af00      	add	r7, sp, #0
 801608a:	6078      	str	r0, [r7, #4]
    if (sigCtx == NULL)
 801608c:	687b      	ldr	r3, [r7, #4]
 801608e:	2b00      	cmp	r3, #0
 8016090:	d059      	beq.n	8016146 <FreeSignatureCtx+0xc2>
        return;

    XFREE(sigCtx->digest, sigCtx->heap, DYNAMIC_TYPE_DIGEST);
 8016092:	687b      	ldr	r3, [r7, #4]
 8016094:	685b      	ldr	r3, [r3, #4]
 8016096:	617b      	str	r3, [r7, #20]
 8016098:	697b      	ldr	r3, [r7, #20]
 801609a:	2b00      	cmp	r3, #0
 801609c:	d002      	beq.n	80160a4 <FreeSignatureCtx+0x20>
 801609e:	6978      	ldr	r0, [r7, #20]
 80160a0:	f008 fd14 	bl	801eacc <wolfSSL_Free>
    sigCtx->digest = NULL;
 80160a4:	687b      	ldr	r3, [r7, #4]
 80160a6:	2200      	movs	r2, #0
 80160a8:	605a      	str	r2, [r3, #4]
#if !(defined(NO_RSA) && defined(NO_DSA))
    XFREE(sigCtx->sigCpy, sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);
 80160aa:	687b      	ldr	r3, [r7, #4]
 80160ac:	68db      	ldr	r3, [r3, #12]
 80160ae:	613b      	str	r3, [r7, #16]
 80160b0:	693b      	ldr	r3, [r7, #16]
 80160b2:	2b00      	cmp	r3, #0
 80160b4:	d002      	beq.n	80160bc <FreeSignatureCtx+0x38>
 80160b6:	6938      	ldr	r0, [r7, #16]
 80160b8:	f008 fd08 	bl	801eacc <wolfSSL_Free>
    sigCtx->sigCpy = NULL;
 80160bc:	687b      	ldr	r3, [r7, #4]
 80160be:	2200      	movs	r2, #0
 80160c0:	60da      	str	r2, [r3, #12]
#endif
#ifndef NO_ASN_CRYPT
    if (sigCtx->key.ptr) {
 80160c2:	687b      	ldr	r3, [r7, #4]
 80160c4:	695b      	ldr	r3, [r3, #20]
 80160c6:	2b00      	cmp	r3, #0
 80160c8:	d039      	beq.n	801613e <FreeSignatureCtx+0xba>
        switch (sigCtx->keyOID) {
 80160ca:	687b      	ldr	r3, [r7, #4]
 80160cc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80160ce:	f240 228e 	movw	r2, #654	@ 0x28e
 80160d2:	4293      	cmp	r3, r2
 80160d4:	d00b      	beq.n	80160ee <FreeSignatureCtx+0x6a>
 80160d6:	f240 228e 	movw	r2, #654	@ 0x28e
 80160da:	4293      	cmp	r3, r2
 80160dc:	d82b      	bhi.n	8016136 <FreeSignatureCtx+0xb2>
 80160de:	f240 2206 	movw	r2, #518	@ 0x206
 80160e2:	4293      	cmp	r3, r2
 80160e4:	d015      	beq.n	8016112 <FreeSignatureCtx+0x8e>
 80160e6:	f240 2285 	movw	r2, #645	@ 0x285
 80160ea:	4293      	cmp	r3, r2
 80160ec:	d123      	bne.n	8016136 <FreeSignatureCtx+0xb2>
        #ifndef NO_RSA
            #ifdef WC_RSA_PSS
            case RSAPSSk:
            #endif
            case RSAk:
                wc_FreeRsaKey(sigCtx->key.rsa);
 80160ee:	687b      	ldr	r3, [r7, #4]
 80160f0:	695b      	ldr	r3, [r3, #20]
 80160f2:	4618      	mov	r0, r3
 80160f4:	f009 ff52 	bl	801ff9c <wc_FreeRsaKey>
                XFREE(sigCtx->key.rsa, sigCtx->heap, DYNAMIC_TYPE_RSA);
 80160f8:	687b      	ldr	r3, [r7, #4]
 80160fa:	695b      	ldr	r3, [r3, #20]
 80160fc:	60fb      	str	r3, [r7, #12]
 80160fe:	68fb      	ldr	r3, [r7, #12]
 8016100:	2b00      	cmp	r3, #0
 8016102:	d002      	beq.n	801610a <FreeSignatureCtx+0x86>
 8016104:	68f8      	ldr	r0, [r7, #12]
 8016106:	f008 fce1 	bl	801eacc <wolfSSL_Free>
                sigCtx->key.rsa = NULL;
 801610a:	687b      	ldr	r3, [r7, #4]
 801610c:	2200      	movs	r2, #0
 801610e:	615a      	str	r2, [r3, #20]
                break;
 8016110:	e012      	b.n	8016138 <FreeSignatureCtx+0xb4>
                    XFREE(sigCtx->key.ecc->nb_ctx, sigCtx->heap,
                          DYNAMIC_TYPE_TMP_BUFFER);
                }
            #endif /* WC_ECC_NONBLOCK && WOLFSSL_ASYNC_CRYPT_SW &&
                      WC_ASYNC_ENABLE_ECC */
                wc_ecc_free(sigCtx->key.ecc);
 8016112:	687b      	ldr	r3, [r7, #4]
 8016114:	695b      	ldr	r3, [r3, #20]
 8016116:	4618      	mov	r0, r3
 8016118:	f006 ff05 	bl	801cf26 <wc_ecc_free>
                XFREE(sigCtx->key.ecc, sigCtx->heap, DYNAMIC_TYPE_ECC);
 801611c:	687b      	ldr	r3, [r7, #4]
 801611e:	695b      	ldr	r3, [r3, #20]
 8016120:	60bb      	str	r3, [r7, #8]
 8016122:	68bb      	ldr	r3, [r7, #8]
 8016124:	2b00      	cmp	r3, #0
 8016126:	d002      	beq.n	801612e <FreeSignatureCtx+0xaa>
 8016128:	68b8      	ldr	r0, [r7, #8]
 801612a:	f008 fccf 	bl	801eacc <wolfSSL_Free>
                sigCtx->key.ecc = NULL;
 801612e:	687b      	ldr	r3, [r7, #4]
 8016130:	2200      	movs	r2, #0
 8016132:	615a      	str	r2, [r3, #20]
                break;
 8016134:	e000      	b.n	8016138 <FreeSignatureCtx+0xb4>
                      DYNAMIC_TYPE_SPHINCS);
                sigCtx->key.sphincs = NULL;
                break;
        #endif /* HAVE_SPHINCS */
            default:
                break;
 8016136:	bf00      	nop
        } /* switch (keyOID) */
        sigCtx->key.ptr = NULL;
 8016138:	687b      	ldr	r3, [r7, #4]
 801613a:	2200      	movs	r2, #0
 801613c:	615a      	str	r2, [r3, #20]
    }
#endif

    /* reset state, we are done */
    sigCtx->state = SIG_STATE_BEGIN;
 801613e:	687b      	ldr	r3, [r7, #4]
 8016140:	2200      	movs	r2, #0
 8016142:	61da      	str	r2, [r3, #28]
 8016144:	e000      	b.n	8016148 <FreeSignatureCtx+0xc4>
        return;
 8016146:	bf00      	nop
}
 8016148:	3718      	adds	r7, #24
 801614a:	46bd      	mov	sp, r7
 801614c:	bd80      	pop	{r7, pc}

0801614e <HashForSignature>:

#if !defined(NO_ASN_CRYPT) && !defined(NO_HASH_WRAPPER)
static int HashForSignature(const byte* buf, word32 bufSz, word32 sigOID,
                            byte* digest, int* typeH, int* digestSz, int verify)
{
 801614e:	b580      	push	{r7, lr}
 8016150:	b086      	sub	sp, #24
 8016152:	af00      	add	r7, sp, #0
 8016154:	60f8      	str	r0, [r7, #12]
 8016156:	60b9      	str	r1, [r7, #8]
 8016158:	607a      	str	r2, [r7, #4]
 801615a:	603b      	str	r3, [r7, #0]
    int ret = 0;
 801615c:	2300      	movs	r3, #0
 801615e:	617b      	str	r3, [r7, #20]

    switch (sigOID) {
 8016160:	687b      	ldr	r3, [r7, #4]
 8016162:	f240 228f 	movw	r2, #655	@ 0x28f
 8016166:	4293      	cmp	r3, r2
 8016168:	d00b      	beq.n	8016182 <HashForSignature+0x34>
 801616a:	687b      	ldr	r3, [r7, #4]
 801616c:	f5b3 7f24 	cmp.w	r3, #656	@ 0x290
 8016170:	d218      	bcs.n	80161a4 <HashForSignature+0x56>
 8016172:	687b      	ldr	r3, [r7, #4]
 8016174:	f5b3 7fd0 	cmp.w	r3, #416	@ 0x1a0
 8016178:	d003      	beq.n	8016182 <HashForSignature+0x34>
 801617a:	687b      	ldr	r3, [r7, #4]
 801617c:	f5b3 7f03 	cmp.w	r3, #524	@ 0x20c
 8016180:	d110      	bne.n	80161a4 <HashForSignature+0x56>
    #endif
    #ifndef NO_SHA256
        case CTC_SHA256wRSA:
        case CTC_SHA256wECDSA:
        case CTC_SHA256wDSA:
            if ((ret = wc_Sha256Hash(buf, bufSz, digest)) == 0) {
 8016182:	683a      	ldr	r2, [r7, #0]
 8016184:	68b9      	ldr	r1, [r7, #8]
 8016186:	68f8      	ldr	r0, [r7, #12]
 8016188:	f008 f9de 	bl	801e548 <wc_Sha256Hash>
 801618c:	6178      	str	r0, [r7, #20]
 801618e:	697b      	ldr	r3, [r7, #20]
 8016190:	2b00      	cmp	r3, #0
 8016192:	d10b      	bne.n	80161ac <HashForSignature+0x5e>
                *typeH    = SHA256h;
 8016194:	6a3b      	ldr	r3, [r7, #32]
 8016196:	f44f 72cf 	mov.w	r2, #414	@ 0x19e
 801619a:	601a      	str	r2, [r3, #0]
                *digestSz = WC_SHA256_DIGEST_SIZE;
 801619c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801619e:	2220      	movs	r2, #32
 80161a0:	601a      	str	r2, [r3, #0]
            }
            break;
 80161a2:	e003      	b.n	80161ac <HashForSignature+0x5e>
            /* Hashes done in signing operation. */
            break;
    #endif

        default:
            ret = HASH_TYPE_E;
 80161a4:	f06f 03e7 	mvn.w	r3, #231	@ 0xe7
 80161a8:	617b      	str	r3, [r7, #20]
 80161aa:	e000      	b.n	80161ae <HashForSignature+0x60>
            break;
 80161ac:	bf00      	nop
    (void)digest;
    (void)digestSz;
    (void)typeH;
    (void)verify;

    return ret;
 80161ae:	697b      	ldr	r3, [r7, #20]
}
 80161b0:	4618      	mov	r0, r3
 80161b2:	3718      	adds	r7, #24
 80161b4:	46bd      	mov	sp, r7
 80161b6:	bd80      	pop	{r7, pc}

080161b8 <ConfirmSignature>:
    const byte* buf, word32 bufSz,
    const byte* key, word32 keySz, word32 keyOID,
    const byte* sig, word32 sigSz, word32 sigOID,
    const byte* sigParams, word32 sigParamsSz,
    byte* rsaKeyIdx)
{
 80161b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80161bc:	b092      	sub	sp, #72	@ 0x48
 80161be:	af04      	add	r7, sp, #16
 80161c0:	6178      	str	r0, [r7, #20]
 80161c2:	6139      	str	r1, [r7, #16]
 80161c4:	60fa      	str	r2, [r7, #12]
 80161c6:	60bb      	str	r3, [r7, #8]
    int ret = WC_NO_ERR_TRACE(ASN_SIG_CONFIRM_E); /* default to failure */
 80161c8:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 80161cc:	637b      	str	r3, [r7, #52]	@ 0x34
#if defined(WOLFSSL_RENESAS_TSIP_TLS) || defined(WOLFSSL_RENESAS_FSPSM_TLS)
    CertAttribute* certatt = NULL;
#endif

    if (sigCtx == NULL || buf == NULL || bufSz == 0 || key == NULL ||
 80161ce:	697b      	ldr	r3, [r7, #20]
 80161d0:	2b00      	cmp	r3, #0
 80161d2:	d011      	beq.n	80161f8 <ConfirmSignature+0x40>
 80161d4:	693b      	ldr	r3, [r7, #16]
 80161d6:	2b00      	cmp	r3, #0
 80161d8:	d00e      	beq.n	80161f8 <ConfirmSignature+0x40>
 80161da:	68fb      	ldr	r3, [r7, #12]
 80161dc:	2b00      	cmp	r3, #0
 80161de:	d00b      	beq.n	80161f8 <ConfirmSignature+0x40>
 80161e0:	68bb      	ldr	r3, [r7, #8]
 80161e2:	2b00      	cmp	r3, #0
 80161e4:	d008      	beq.n	80161f8 <ConfirmSignature+0x40>
 80161e6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80161e8:	2b00      	cmp	r3, #0
 80161ea:	d005      	beq.n	80161f8 <ConfirmSignature+0x40>
        keySz == 0 || sig == NULL || sigSz == 0) {
 80161ec:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80161ee:	2b00      	cmp	r3, #0
 80161f0:	d002      	beq.n	80161f8 <ConfirmSignature+0x40>
 80161f2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80161f4:	2b00      	cmp	r3, #0
 80161f6:	d102      	bne.n	80161fe <ConfirmSignature+0x46>
        return BAD_FUNC_ARG;
 80161f8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80161fc:	e219      	b.n	8016632 <ConfirmSignature+0x47a>
        certatt->certSz = bufSz;
    }
#endif

#ifndef NO_ASN_CRYPT
    switch (sigCtx->state) {
 80161fe:	697b      	ldr	r3, [r7, #20]
 8016200:	69db      	ldr	r3, [r3, #28]
 8016202:	2b04      	cmp	r3, #4
 8016204:	f200 8202 	bhi.w	801660c <ConfirmSignature+0x454>
 8016208:	a201      	add	r2, pc, #4	@ (adr r2, 8016210 <ConfirmSignature+0x58>)
 801620a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801620e:	bf00      	nop
 8016210:	08016225 	.word	0x08016225
 8016214:	08016261 	.word	0x08016261
 8016218:	0801630f 	.word	0x0801630f
 801621c:	08016449 	.word	0x08016449
 8016220:	080164ff 	.word	0x080164ff
        case SIG_STATE_BEGIN:
        {
            sigCtx->keyOID = keyOID; /* must set early for cleanup */
 8016224:	697b      	ldr	r3, [r7, #20]
 8016226:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8016228:	629a      	str	r2, [r3, #40]	@ 0x28

            sigCtx->digest = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, sigCtx->heap,
 801622a:	2020      	movs	r0, #32
 801622c:	f008 fc32 	bl	801ea94 <wolfSSL_Malloc>
 8016230:	4602      	mov	r2, r0
 8016232:	697b      	ldr	r3, [r7, #20]
 8016234:	605a      	str	r2, [r3, #4]
                                                    DYNAMIC_TYPE_DIGEST);
            if (sigCtx->digest == NULL) {
 8016236:	697b      	ldr	r3, [r7, #20]
 8016238:	685b      	ldr	r3, [r3, #4]
 801623a:	2b00      	cmp	r3, #0
 801623c:	d103      	bne.n	8016246 <ConfirmSignature+0x8e>
                ERROR_OUT(MEMORY_E, exit_cs);
 801623e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8016242:	637b      	str	r3, [r7, #52]	@ 0x34
 8016244:	e1f1      	b.n	801662a <ConfirmSignature+0x472>
            }

        #if !defined(NO_RSA) && defined(WC_RSA_PSS)
            /* RSA PSS Defaults */
            sigCtx->hash = WC_HASH_TYPE_SHA;
 8016246:	697b      	ldr	r3, [r7, #20]
 8016248:	2204      	movs	r2, #4
 801624a:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c
            sigCtx->mgf = WC_MGF1SHA1;
 801624e:	697b      	ldr	r3, [r7, #20]
 8016250:	221a      	movs	r2, #26
 8016252:	631a      	str	r2, [r3, #48]	@ 0x30
            sigCtx->saltLen = 20;
 8016254:	697b      	ldr	r3, [r7, #20]
 8016256:	2214      	movs	r2, #20
 8016258:	635a      	str	r2, [r3, #52]	@ 0x34
        #endif

            sigCtx->state = SIG_STATE_HASH;
 801625a:	697b      	ldr	r3, [r7, #20]
 801625c:	2201      	movs	r2, #1
 801625e:	61da      	str	r2, [r3, #28]
        FALL_THROUGH;

        case SIG_STATE_HASH:
        {
        #if !defined(NO_RSA) && defined(WC_RSA_PSS)
            if (sigOID == RSAPSSk) {
 8016260:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8016262:	f240 228e 	movw	r2, #654	@ 0x28e
 8016266:	4293      	cmp	r3, r2
 8016268:	d139      	bne.n	80162de <ConfirmSignature+0x126>
                word32 fakeSigOID = 0;
 801626a:	2300      	movs	r3, #0
 801626c:	623b      	str	r3, [r7, #32]
                ret = DecodeRsaPssParams(sigParams, sigParamsSz, &sigCtx->hash,
 801626e:	697b      	ldr	r3, [r7, #20]
 8016270:	f103 022c 	add.w	r2, r3, #44	@ 0x2c
 8016274:	697b      	ldr	r3, [r7, #20]
 8016276:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 801627a:	697b      	ldr	r3, [r7, #20]
 801627c:	3334      	adds	r3, #52	@ 0x34
 801627e:	9300      	str	r3, [sp, #0]
 8016280:	460b      	mov	r3, r1
 8016282:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8016284:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8016286:	f7fe fb4b 	bl	8014920 <DecodeRsaPssParams>
 801628a:	6378      	str	r0, [r7, #52]	@ 0x34
                    &sigCtx->mgf, &sigCtx->saltLen);
                if (ret != 0) {
 801628c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801628e:	2b00      	cmp	r3, #0
 8016290:	f040 81be 	bne.w	8016610 <ConfirmSignature+0x458>
                    goto exit_cs;
                }
                ret = RsaPssHashOidToSigOid(sigCtx->hash, &fakeSigOID);
 8016294:	697b      	ldr	r3, [r7, #20]
 8016296:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
 801629a:	461a      	mov	r2, r3
 801629c:	f107 0320 	add.w	r3, r7, #32
 80162a0:	4619      	mov	r1, r3
 80162a2:	4610      	mov	r0, r2
 80162a4:	f7fe fb22 	bl	80148ec <RsaPssHashOidToSigOid>
 80162a8:	6378      	str	r0, [r7, #52]	@ 0x34
                if (ret != 0) {
 80162aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80162ac:	2b00      	cmp	r3, #0
 80162ae:	f040 81b1 	bne.w	8016614 <ConfirmSignature+0x45c>
                    goto exit_cs;
                }
                /* Decode parameters. */
                ret = HashForSignature(buf, bufSz, fakeSigOID, sigCtx->digest,
 80162b2:	6a39      	ldr	r1, [r7, #32]
 80162b4:	697b      	ldr	r3, [r7, #20]
 80162b6:	6858      	ldr	r0, [r3, #4]
 80162b8:	697b      	ldr	r3, [r7, #20]
 80162ba:	3320      	adds	r3, #32
 80162bc:	697a      	ldr	r2, [r7, #20]
 80162be:	3224      	adds	r2, #36	@ 0x24
 80162c0:	2401      	movs	r4, #1
 80162c2:	9402      	str	r4, [sp, #8]
 80162c4:	9201      	str	r2, [sp, #4]
 80162c6:	9300      	str	r3, [sp, #0]
 80162c8:	4603      	mov	r3, r0
 80162ca:	460a      	mov	r2, r1
 80162cc:	68f9      	ldr	r1, [r7, #12]
 80162ce:	6938      	ldr	r0, [r7, #16]
 80162d0:	f7ff ff3d 	bl	801614e <HashForSignature>
 80162d4:	6378      	str	r0, [r7, #52]	@ 0x34
                    &sigCtx->typeH, &sigCtx->digestSz, 1);
                if (ret != 0) {
 80162d6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80162d8:	2b00      	cmp	r3, #0
 80162da:	d015      	beq.n	8016308 <ConfirmSignature+0x150>
                    goto exit_cs;
 80162dc:	e1a5      	b.n	801662a <ConfirmSignature+0x472>
                ; /* SM2 hash requires public key. Done later. */
            }
            else
        #endif
            {
                ret = HashForSignature(buf, bufSz, sigOID, sigCtx->digest,
 80162de:	697b      	ldr	r3, [r7, #20]
 80162e0:	6859      	ldr	r1, [r3, #4]
 80162e2:	697b      	ldr	r3, [r7, #20]
 80162e4:	3320      	adds	r3, #32
 80162e6:	697a      	ldr	r2, [r7, #20]
 80162e8:	3224      	adds	r2, #36	@ 0x24
 80162ea:	2001      	movs	r0, #1
 80162ec:	9002      	str	r0, [sp, #8]
 80162ee:	9201      	str	r2, [sp, #4]
 80162f0:	9300      	str	r3, [sp, #0]
 80162f2:	460b      	mov	r3, r1
 80162f4:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80162f6:	68f9      	ldr	r1, [r7, #12]
 80162f8:	6938      	ldr	r0, [r7, #16]
 80162fa:	f7ff ff28 	bl	801614e <HashForSignature>
 80162fe:	6378      	str	r0, [r7, #52]	@ 0x34
                                       &sigCtx->typeH, &sigCtx->digestSz, 1);
                if (ret != 0) {
 8016300:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016302:	2b00      	cmp	r3, #0
 8016304:	f040 8188 	bne.w	8016618 <ConfirmSignature+0x460>
                    goto exit_cs;
                }
            }

            sigCtx->state = SIG_STATE_KEY;
 8016308:	697b      	ldr	r3, [r7, #20]
 801630a:	2202      	movs	r2, #2
 801630c:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_HASH */
        FALL_THROUGH;

        case SIG_STATE_KEY:
        {
            switch (keyOID) {
 801630e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016310:	f240 228e 	movw	r2, #654	@ 0x28e
 8016314:	4293      	cmp	r3, r2
 8016316:	d00f      	beq.n	8016338 <ConfirmSignature+0x180>
 8016318:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801631a:	f240 228e 	movw	r2, #654	@ 0x28e
 801631e:	4293      	cmp	r3, r2
 8016320:	f200 8086 	bhi.w	8016430 <ConfirmSignature+0x278>
 8016324:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016326:	f240 2206 	movw	r2, #518	@ 0x206
 801632a:	4293      	cmp	r3, r2
 801632c:	d051      	beq.n	80163d2 <ConfirmSignature+0x21a>
 801632e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016330:	f240 2285 	movw	r2, #645	@ 0x285
 8016334:	4293      	cmp	r3, r2
 8016336:	d17b      	bne.n	8016430 <ConfirmSignature+0x278>
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                #endif
                case RSAk:
                {
                    word32 idx = 0;
 8016338:	2300      	movs	r3, #0
 801633a:	61fb      	str	r3, [r7, #28]

                    sigCtx->key.rsa = (RsaKey*)XMALLOC(sizeof(RsaKey),
 801633c:	f241 107c 	movw	r0, #4476	@ 0x117c
 8016340:	f008 fba8 	bl	801ea94 <wolfSSL_Malloc>
 8016344:	4602      	mov	r2, r0
 8016346:	697b      	ldr	r3, [r7, #20]
 8016348:	615a      	str	r2, [r3, #20]
                                                sigCtx->heap, DYNAMIC_TYPE_RSA);
                    if (sigCtx->key.rsa == NULL) {
 801634a:	697b      	ldr	r3, [r7, #20]
 801634c:	695b      	ldr	r3, [r3, #20]
 801634e:	2b00      	cmp	r3, #0
 8016350:	d103      	bne.n	801635a <ConfirmSignature+0x1a2>
                        ERROR_OUT(MEMORY_E, exit_cs);
 8016352:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8016356:	637b      	str	r3, [r7, #52]	@ 0x34
 8016358:	e167      	b.n	801662a <ConfirmSignature+0x472>
                    }
                    if ((ret = wc_InitRsaKey_ex(sigCtx->key.rsa, sigCtx->heap,
 801635a:	697b      	ldr	r3, [r7, #20]
 801635c:	6958      	ldr	r0, [r3, #20]
 801635e:	697b      	ldr	r3, [r7, #20]
 8016360:	6819      	ldr	r1, [r3, #0]
 8016362:	697b      	ldr	r3, [r7, #20]
 8016364:	699b      	ldr	r3, [r3, #24]
 8016366:	461a      	mov	r2, r3
 8016368:	f009 fd84 	bl	801fe74 <wc_InitRsaKey_ex>
 801636c:	6378      	str	r0, [r7, #52]	@ 0x34
 801636e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016370:	2b00      	cmp	r3, #0
 8016372:	f040 8153 	bne.w	801661c <ConfirmSignature+0x464>
                                                        sigCtx->devId)) != 0) {
                        goto exit_cs;
                    }
                    sigCtx->sigCpy = (byte*)XMALLOC(sigSz, sigCtx->heap,
 8016376:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8016378:	f008 fb8c 	bl	801ea94 <wolfSSL_Malloc>
 801637c:	4602      	mov	r2, r0
 801637e:	697b      	ldr	r3, [r7, #20]
 8016380:	60da      	str	r2, [r3, #12]
                                                        DYNAMIC_TYPE_SIGNATURE);
                    if (sigCtx->sigCpy == NULL) {
 8016382:	697b      	ldr	r3, [r7, #20]
 8016384:	68db      	ldr	r3, [r3, #12]
 8016386:	2b00      	cmp	r3, #0
 8016388:	d103      	bne.n	8016392 <ConfirmSignature+0x1da>
                        ERROR_OUT(MEMORY_E, exit_cs);
 801638a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801638e:	637b      	str	r3, [r7, #52]	@ 0x34
 8016390:	e14b      	b.n	801662a <ConfirmSignature+0x472>
                    }
                    if (sigSz > MAX_ENCODED_SIG_SZ) {
 8016392:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8016394:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8016398:	d903      	bls.n	80163a2 <ConfirmSignature+0x1ea>
                        WOLFSSL_MSG("Verify Signature is too big");
                        ERROR_OUT(BUFFER_E, exit_cs);
 801639a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801639e:	637b      	str	r3, [r7, #52]	@ 0x34
 80163a0:	e143      	b.n	801662a <ConfirmSignature+0x472>
                    }
                    if ((ret = wc_RsaPublicKeyDecode(key, &idx, sigCtx->key.rsa,
 80163a2:	697b      	ldr	r3, [r7, #20]
 80163a4:	695a      	ldr	r2, [r3, #20]
 80163a6:	f107 011c 	add.w	r1, r7, #28
 80163aa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80163ac:	68b8      	ldr	r0, [r7, #8]
 80163ae:	f7fe fe65 	bl	801507c <wc_RsaPublicKeyDecode>
 80163b2:	6378      	str	r0, [r7, #52]	@ 0x34
 80163b4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80163b6:	2b00      	cmp	r3, #0
 80163b8:	f040 8132 	bne.w	8016620 <ConfirmSignature+0x468>
                                                                 keySz)) != 0) {
                        WOLFSSL_MSG("ASN Key decode error RSA");
                        WOLFSSL_ERROR_VERBOSE(ret);
                        goto exit_cs;
                    }
                    XMEMCPY(sigCtx->sigCpy, sig, sigSz);
 80163bc:	697b      	ldr	r3, [r7, #20]
 80163be:	68db      	ldr	r3, [r3, #12]
 80163c0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80163c2:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 80163c4:	4618      	mov	r0, r3
 80163c6:	f012 f8ed 	bl	80285a4 <memcpy>
                    sigCtx->out = NULL;
 80163ca:	697b      	ldr	r3, [r7, #20]
 80163cc:	2200      	movs	r2, #0
 80163ce:	609a      	str	r2, [r3, #8]
 80163d0:	e033      	b.n	801643a <ConfirmSignature+0x282>
            #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                case SM2k:
            #endif
                case ECDSAk:
                {
                    word32 idx = 0;
 80163d2:	2300      	movs	r3, #0
 80163d4:	61bb      	str	r3, [r7, #24]
                defined(WC_ASYNC_ENABLE_ECC)
                    ecc_nb_ctx_t* nbCtx;
            #endif /* WC_ECC_NONBLOCK && WOLFSSL_ASYNC_CRYPT_SW &&
                      WC_ASYNC_ENABLE_ECC */

                    sigCtx->verify = 0;
 80163d6:	697b      	ldr	r3, [r7, #20]
 80163d8:	2200      	movs	r2, #0
 80163da:	611a      	str	r2, [r3, #16]
                    sigCtx->key.ecc = (ecc_key*)XMALLOC(sizeof(ecc_key),
 80163dc:	f44f 70b8 	mov.w	r0, #368	@ 0x170
 80163e0:	f008 fb58 	bl	801ea94 <wolfSSL_Malloc>
 80163e4:	4602      	mov	r2, r0
 80163e6:	697b      	ldr	r3, [r7, #20]
 80163e8:	615a      	str	r2, [r3, #20]
                                                sigCtx->heap, DYNAMIC_TYPE_ECC);
                    if (sigCtx->key.ecc == NULL) {
 80163ea:	697b      	ldr	r3, [r7, #20]
 80163ec:	695b      	ldr	r3, [r3, #20]
 80163ee:	2b00      	cmp	r3, #0
 80163f0:	d103      	bne.n	80163fa <ConfirmSignature+0x242>
                        ERROR_OUT(MEMORY_E, exit_cs);
 80163f2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80163f6:	637b      	str	r3, [r7, #52]	@ 0x34
 80163f8:	e117      	b.n	801662a <ConfirmSignature+0x472>
                    }
                    if ((ret = wc_ecc_init_ex(sigCtx->key.ecc, sigCtx->heap,
 80163fa:	697b      	ldr	r3, [r7, #20]
 80163fc:	6958      	ldr	r0, [r3, #20]
 80163fe:	697b      	ldr	r3, [r7, #20]
 8016400:	6819      	ldr	r1, [r3, #0]
 8016402:	697b      	ldr	r3, [r7, #20]
 8016404:	699b      	ldr	r3, [r3, #24]
 8016406:	461a      	mov	r2, r3
 8016408:	f006 fcf2 	bl	801cdf0 <wc_ecc_init_ex>
 801640c:	6378      	str	r0, [r7, #52]	@ 0x34
 801640e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016410:	2b00      	cmp	r3, #0
 8016412:	f2c0 8107 	blt.w	8016624 <ConfirmSignature+0x46c>
                            goto exit_cs;
                        }
                    }
            #endif /* WC_ECC_NONBLOCK && WOLFSSL_ASYNC_CRYPT_SW &&
                      WC_ASYNC_ENABLE_ECC */
                    ret = wc_EccPublicKeyDecode(key, &idx, sigCtx->key.ecc,
 8016416:	697b      	ldr	r3, [r7, #20]
 8016418:	695a      	ldr	r2, [r3, #20]
 801641a:	f107 0118 	add.w	r1, r7, #24
 801641e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8016420:	68b8      	ldr	r0, [r7, #8]
 8016422:	f003 fd95 	bl	8019f50 <wc_EccPublicKeyDecode>
 8016426:	6378      	str	r0, [r7, #52]	@ 0x34
                                                                         keySz);
                    if (ret < 0) {
 8016428:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801642a:	2b00      	cmp	r3, #0
 801642c:	da04      	bge.n	8016438 <ConfirmSignature+0x280>
                        WOLFSSL_MSG("ASN Key import error ECC");
                        WOLFSSL_ERROR_VERBOSE(ret);
                        goto exit_cs;
 801642e:	e0fc      	b.n	801662a <ConfirmSignature+0x472>
                    break;
                }
            #endif /* HAVE_SPHINCS */
                default:
                    WOLFSSL_MSG("Verify Key type unknown");
                    ret = ASN_UNKNOWN_OID_E;
 8016430:	f06f 0393 	mvn.w	r3, #147	@ 0x93
 8016434:	637b      	str	r3, [r7, #52]	@ 0x34
                    WOLFSSL_ERROR_VERBOSE(ret);
                    break;
 8016436:	e000      	b.n	801643a <ConfirmSignature+0x282>
                    break;
 8016438:	bf00      	nop
            } /* switch (keyOID) */

            if (ret != 0) {
 801643a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801643c:	2b00      	cmp	r3, #0
 801643e:	f040 80f3 	bne.w	8016628 <ConfirmSignature+0x470>
                goto exit_cs;
            }

            sigCtx->state = SIG_STATE_DO;
 8016442:	697b      	ldr	r3, [r7, #20]
 8016444:	2203      	movs	r2, #3
 8016446:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_KEY */
        FALL_THROUGH;

        case SIG_STATE_DO:
        {
            switch (keyOID) {
 8016448:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801644a:	f240 228e 	movw	r2, #654	@ 0x28e
 801644e:	4293      	cmp	r3, r2
 8016450:	d00e      	beq.n	8016470 <ConfirmSignature+0x2b8>
 8016452:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016454:	f240 228e 	movw	r2, #654	@ 0x28e
 8016458:	4293      	cmp	r3, r2
 801645a:	d845      	bhi.n	80164e8 <ConfirmSignature+0x330>
 801645c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801645e:	f240 2206 	movw	r2, #518	@ 0x206
 8016462:	4293      	cmp	r3, r2
 8016464:	d02d      	beq.n	80164c2 <ConfirmSignature+0x30a>
 8016466:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016468:	f240 2285 	movw	r2, #645	@ 0x285
 801646c:	4293      	cmp	r3, r2
 801646e:	d13b      	bne.n	80164e8 <ConfirmSignature+0x330>
            #ifndef NO_RSA
                case RSAk:
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                if (sigOID == RSAPSSk) {
 8016470:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8016472:	f240 228e 	movw	r2, #654	@ 0x28e
 8016476:	4293      	cmp	r3, r2
 8016478:	d117      	bne.n	80164aa <ConfirmSignature+0x2f2>
                    /* TODO: pkCbRsaPss - RSA PSS callback. */
                    ret = wc_RsaPSS_VerifyInline_ex(sigCtx->sigCpy, sigSz,
 801647a:	697b      	ldr	r3, [r7, #20]
 801647c:	68d8      	ldr	r0, [r3, #12]
 801647e:	697b      	ldr	r3, [r7, #20]
 8016480:	f103 0408 	add.w	r4, r3, #8
 8016484:	697b      	ldr	r3, [r7, #20]
 8016486:	f893 502c 	ldrb.w	r5, [r3, #44]	@ 0x2c
 801648a:	697b      	ldr	r3, [r7, #20]
 801648c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801648e:	697a      	ldr	r2, [r7, #20]
 8016490:	6b52      	ldr	r2, [r2, #52]	@ 0x34
                        &sigCtx->out, sigCtx->hash, sigCtx->mgf,
                        sigCtx->saltLen, sigCtx->key.rsa);
 8016492:	6979      	ldr	r1, [r7, #20]
 8016494:	6949      	ldr	r1, [r1, #20]
                    ret = wc_RsaPSS_VerifyInline_ex(sigCtx->sigCpy, sigSz,
 8016496:	9102      	str	r1, [sp, #8]
 8016498:	9201      	str	r2, [sp, #4]
 801649a:	9300      	str	r3, [sp, #0]
 801649c:	462b      	mov	r3, r5
 801649e:	4622      	mov	r2, r4
 80164a0:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80164a2:	f00a fedf 	bl	8021264 <wc_RsaPSS_VerifyInline_ex>
 80164a6:	6378      	str	r0, [r7, #52]	@ 0x34
                    {
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
                                                 &sigCtx->out, sigCtx->key.rsa);
                    }
                }
                break;
 80164a8:	e01f      	b.n	80164ea <ConfirmSignature+0x332>
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
 80164aa:	697b      	ldr	r3, [r7, #20]
 80164ac:	68d8      	ldr	r0, [r3, #12]
 80164ae:	697b      	ldr	r3, [r7, #20]
 80164b0:	f103 0208 	add.w	r2, r3, #8
                                                 &sigCtx->out, sigCtx->key.rsa);
 80164b4:	697b      	ldr	r3, [r7, #20]
 80164b6:	695b      	ldr	r3, [r3, #20]
                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,
 80164b8:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80164ba:	f00a fea4 	bl	8021206 <wc_RsaSSL_VerifyInline>
 80164be:	6378      	str	r0, [r7, #52]	@ 0x34
                break;
 80164c0:	e013      	b.n	80164ea <ConfirmSignature+0x332>
                    if (!sigCtx->pkCbEcc ||
                        ret == WC_NO_ERR_TRACE(CRYPTOCB_UNAVAILABLE))
                #endif /* WOLFSSL_RENESAS_FSPSM_TLS */
                #endif /* HAVE_PK_CALLBACKS */
                    {
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 80164c2:	697b      	ldr	r3, [r7, #20]
 80164c4:	6859      	ldr	r1, [r3, #4]
                            (word32)sigCtx->digestSz, &sigCtx->verify,
 80164c6:	697b      	ldr	r3, [r7, #20]
 80164c8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 80164ca:	4618      	mov	r0, r3
 80164cc:	697b      	ldr	r3, [r7, #20]
 80164ce:	3310      	adds	r3, #16
                            sigCtx->key.ecc);
 80164d0:	697a      	ldr	r2, [r7, #20]
 80164d2:	6952      	ldr	r2, [r2, #20]
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
 80164d4:	9201      	str	r2, [sp, #4]
 80164d6:	9300      	str	r3, [sp, #0]
 80164d8:	4603      	mov	r3, r0
 80164da:	460a      	mov	r2, r1
 80164dc:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80164de:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 80164e0:	f007 f9b2 	bl	801d848 <wc_ecc_verify_hash>
 80164e4:	6378      	str	r0, [r7, #52]	@ 0x34
                    }
                    break;
 80164e6:	e000      	b.n	80164ea <ConfirmSignature+0x332>
                                                sigCtx->key.sphincs);
                    break;
                }
            #endif /* HAVE_SPHINCS */
                default:
                    break;
 80164e8:	bf00      	nop
            if (ret == WC_NO_ERR_TRACE(WC_PENDING_E)) {
                goto exit_cs;
            }
        #endif

            if (ret < 0) {
 80164ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80164ec:	2b00      	cmp	r3, #0
 80164ee:	da03      	bge.n	80164f8 <ConfirmSignature+0x340>
                /* treat all errors as ASN_SIG_CONFIRM_E */
                ret = ASN_SIG_CONFIRM_E;
 80164f0:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 80164f4:	637b      	str	r3, [r7, #52]	@ 0x34
                WOLFSSL_ERROR_VERBOSE(ret);
                goto exit_cs;
 80164f6:	e098      	b.n	801662a <ConfirmSignature+0x472>
            }

            sigCtx->state = SIG_STATE_CHECK;
 80164f8:	697b      	ldr	r3, [r7, #20]
 80164fa:	2204      	movs	r2, #4
 80164fc:	61da      	str	r2, [r3, #28]
        } /* SIG_STATE_DO */
        FALL_THROUGH;

        case SIG_STATE_CHECK:
        {
            switch (keyOID) {
 80164fe:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016500:	f240 228e 	movw	r2, #654	@ 0x28e
 8016504:	4293      	cmp	r3, r2
 8016506:	d00e      	beq.n	8016526 <ConfirmSignature+0x36e>
 8016508:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801650a:	f240 228e 	movw	r2, #654	@ 0x28e
 801650e:	4293      	cmp	r3, r2
 8016510:	d878      	bhi.n	8016604 <ConfirmSignature+0x44c>
 8016512:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8016514:	f240 2206 	movw	r2, #518	@ 0x206
 8016518:	4293      	cmp	r3, r2
 801651a:	d068      	beq.n	80165ee <ConfirmSignature+0x436>
 801651c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801651e:	f240 2285 	movw	r2, #645	@ 0x285
 8016522:	4293      	cmp	r3, r2
 8016524:	d16e      	bne.n	8016604 <ConfirmSignature+0x44c>
            #ifndef NO_RSA
                case RSAk:
                #ifdef WC_RSA_PSS
                case RSAPSSk:
                if (sigOID == RSAPSSk) {
 8016526:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8016528:	f240 228e 	movw	r2, #654	@ 0x28e
 801652c:	4293      	cmp	r3, r2
 801652e:	d123      	bne.n	8016578 <ConfirmSignature+0x3c0>
                       (HAVE_FIPS_VERSION == 2))
                    ret = wc_RsaPSS_CheckPadding_ex(sigCtx->digest,
                        sigCtx->digestSz, sigCtx->out, ret, sigCtx->hash,
                        sigCtx->saltLen, 0);
                #else
                    ret = wc_RsaPSS_CheckPadding_ex2(sigCtx->digest,
 8016530:	697b      	ldr	r3, [r7, #20]
 8016532:	685e      	ldr	r6, [r3, #4]
                        (word32)sigCtx->digestSz, sigCtx->out, (word32)ret, sigCtx->hash,
 8016534:	697b      	ldr	r3, [r7, #20]
 8016536:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                    ret = wc_RsaPSS_CheckPadding_ex2(sigCtx->digest,
 8016538:	4698      	mov	r8, r3
 801653a:	697b      	ldr	r3, [r7, #20]
 801653c:	689b      	ldr	r3, [r3, #8]
 801653e:	607b      	str	r3, [r7, #4]
 8016540:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8016542:	6039      	str	r1, [r7, #0]
 8016544:	697b      	ldr	r3, [r7, #20]
 8016546:	f893 402c 	ldrb.w	r4, [r3, #44]	@ 0x2c
 801654a:	697b      	ldr	r3, [r7, #20]
 801654c:	6b5d      	ldr	r5, [r3, #52]	@ 0x34
                        sigCtx->saltLen, wc_RsaEncryptSize(sigCtx->key.rsa) * 8,
 801654e:	697b      	ldr	r3, [r7, #20]
 8016550:	695b      	ldr	r3, [r3, #20]
 8016552:	4618      	mov	r0, r3
 8016554:	f00a ff4c 	bl	80213f0 <wc_RsaEncryptSize>
 8016558:	4603      	mov	r3, r0
                    ret = wc_RsaPSS_CheckPadding_ex2(sigCtx->digest,
 801655a:	00db      	lsls	r3, r3, #3
 801655c:	697a      	ldr	r2, [r7, #20]
 801655e:	6812      	ldr	r2, [r2, #0]
 8016560:	9203      	str	r2, [sp, #12]
 8016562:	9302      	str	r3, [sp, #8]
 8016564:	9501      	str	r5, [sp, #4]
 8016566:	9400      	str	r4, [sp, #0]
 8016568:	683b      	ldr	r3, [r7, #0]
 801656a:	687a      	ldr	r2, [r7, #4]
 801656c:	4641      	mov	r1, r8
 801656e:	4630      	mov	r0, r6
 8016570:	f00a fea7 	bl	80212c2 <wc_RsaPSS_CheckPadding_ex2>
 8016574:	6378      	str	r0, [r7, #52]	@ 0x34
                        sigCtx->heap);
                #endif
                    break;
 8016576:	e048      	b.n	801660a <ConfirmSignature+0x452>
                #if defined(WOLFSSL_RENESAS_TSIP_TLS) || \
                                            defined(WOLFSSL_RENESAS_FSPSM_TLS)
                    if (sigCtx->CertAtt.verifyByTSIP_SCE == 1) break;
                #endif
                #ifdef WOLFSSL_SMALL_STACK
                    byte* encodedSig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,
 8016578:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801657c:	f008 fa8a 	bl	801ea94 <wolfSSL_Malloc>
 8016580:	6338      	str	r0, [r7, #48]	@ 0x30
                                        sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);
                    if (encodedSig == NULL) {
 8016582:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016584:	2b00      	cmp	r3, #0
 8016586:	d103      	bne.n	8016590 <ConfirmSignature+0x3d8>
                        ERROR_OUT(MEMORY_E, exit_cs);
 8016588:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801658c:	637b      	str	r3, [r7, #52]	@ 0x34
 801658e:	e04c      	b.n	801662a <ConfirmSignature+0x472>
                    }
                #else
                    byte encodedSig[MAX_ENCODED_SIG_SZ];
                #endif

                    verifySz = ret;
 8016590:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016592:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    /* make sure we're right justified */
                    encodedSigSz = (int)wc_EncodeSignature(encodedSig,
                            sigCtx->digest, (word32)sigCtx->digestSz,
 8016594:	697b      	ldr	r3, [r7, #20]
 8016596:	6859      	ldr	r1, [r3, #4]
 8016598:	697b      	ldr	r3, [r7, #20]
 801659a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                    encodedSigSz = (int)wc_EncodeSignature(encodedSig,
 801659c:	461a      	mov	r2, r3
 801659e:	697b      	ldr	r3, [r7, #20]
 80165a0:	6a1b      	ldr	r3, [r3, #32]
 80165a2:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80165a4:	f7ff fce6 	bl	8015f74 <wc_EncodeSignature>
 80165a8:	4603      	mov	r3, r0
 80165aa:	62bb      	str	r3, [r7, #40]	@ 0x28
                            sigCtx->typeH);
                    if (encodedSigSz == verifySz && sigCtx->out != NULL &&
 80165ac:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80165ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80165b0:	429a      	cmp	r2, r3
 80165b2:	d110      	bne.n	80165d6 <ConfirmSignature+0x41e>
 80165b4:	697b      	ldr	r3, [r7, #20]
 80165b6:	689b      	ldr	r3, [r3, #8]
 80165b8:	2b00      	cmp	r3, #0
 80165ba:	d00c      	beq.n	80165d6 <ConfirmSignature+0x41e>
                        XMEMCMP(sigCtx->out, encodedSig,
 80165bc:	697b      	ldr	r3, [r7, #20]
 80165be:	689b      	ldr	r3, [r3, #8]
 80165c0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80165c2:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80165c4:	4618      	mov	r0, r3
 80165c6:	f011 ff59 	bl	802847c <memcmp>
 80165ca:	4603      	mov	r3, r0
                    if (encodedSigSz == verifySz && sigCtx->out != NULL &&
 80165cc:	2b00      	cmp	r3, #0
 80165ce:	d102      	bne.n	80165d6 <ConfirmSignature+0x41e>
                            (size_t)encodedSigSz) == 0) {
                        ret = 0;
 80165d0:	2300      	movs	r3, #0
 80165d2:	637b      	str	r3, [r7, #52]	@ 0x34
 80165d4:	e002      	b.n	80165dc <ConfirmSignature+0x424>
                    }
                    else {
                        WOLFSSL_MSG("RSA SSL verify match encode error");
                        ret = ASN_SIG_CONFIRM_E;
 80165d6:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 80165da:	637b      	str	r3, [r7, #52]	@ 0x34
                        WOLFSSL_ERROR_VERBOSE(ret);
                    }

                #ifdef WOLFSSL_SMALL_STACK
                    XFREE(encodedSig, sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);
 80165dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80165de:	627b      	str	r3, [r7, #36]	@ 0x24
 80165e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80165e2:	2b00      	cmp	r3, #0
 80165e4:	d010      	beq.n	8016608 <ConfirmSignature+0x450>
 80165e6:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 80165e8:	f008 fa70 	bl	801eacc <wolfSSL_Free>
                #endif
                    break;
 80165ec:	e00c      	b.n	8016608 <ConfirmSignature+0x450>
            #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                case SM2k:
            #endif
                case ECDSAk:
                {
                    if (sigCtx->verify == 1) {
 80165ee:	697b      	ldr	r3, [r7, #20]
 80165f0:	691b      	ldr	r3, [r3, #16]
 80165f2:	2b01      	cmp	r3, #1
 80165f4:	d102      	bne.n	80165fc <ConfirmSignature+0x444>
                        ret = 0;
 80165f6:	2300      	movs	r3, #0
 80165f8:	637b      	str	r3, [r7, #52]	@ 0x34
                    else {
                        WOLFSSL_MSG("ECC Verify didn't match");
                        ret = ASN_SIG_CONFIRM_E;
                        WOLFSSL_ERROR_VERBOSE(ret);
                    }
                    break;
 80165fa:	e006      	b.n	801660a <ConfirmSignature+0x452>
                        ret = ASN_SIG_CONFIRM_E;
 80165fc:	f06f 039a 	mvn.w	r3, #154	@ 0x9a
 8016600:	637b      	str	r3, [r7, #52]	@ 0x34
                    break;
 8016602:	e002      	b.n	801660a <ConfirmSignature+0x452>
                    }
                    break;
                }
            #endif /* HAVE_SPHINCS */
                default:
                    break;
 8016604:	bf00      	nop
 8016606:	e010      	b.n	801662a <ConfirmSignature+0x472>
                    break;
 8016608:	bf00      	nop
            }  /* switch (keyOID) */

            break;
 801660a:	e00e      	b.n	801662a <ConfirmSignature+0x472>
        } /* SIG_STATE_CHECK */

        default:
            break;
 801660c:	bf00      	nop
 801660e:	e00c      	b.n	801662a <ConfirmSignature+0x472>
                    goto exit_cs;
 8016610:	bf00      	nop
 8016612:	e00a      	b.n	801662a <ConfirmSignature+0x472>
                    goto exit_cs;
 8016614:	bf00      	nop
 8016616:	e008      	b.n	801662a <ConfirmSignature+0x472>
                    goto exit_cs;
 8016618:	bf00      	nop
 801661a:	e006      	b.n	801662a <ConfirmSignature+0x472>
                        goto exit_cs;
 801661c:	bf00      	nop
 801661e:	e004      	b.n	801662a <ConfirmSignature+0x472>
                        goto exit_cs;
 8016620:	bf00      	nop
 8016622:	e002      	b.n	801662a <ConfirmSignature+0x472>
                        goto exit_cs;
 8016624:	bf00      	nop
 8016626:	e000      	b.n	801662a <ConfirmSignature+0x472>
                goto exit_cs;
 8016628:	bf00      	nop
#ifdef WOLFSSL_ASYNC_CRYPT
    if (ret == WC_NO_ERR_TRACE(WC_PENDING_E))
        return ret;
#endif

    FreeSignatureCtx(sigCtx);
 801662a:	6978      	ldr	r0, [r7, #20]
 801662c:	f7ff fd2a 	bl	8016084 <FreeSignatureCtx>

    return ret;
 8016630:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8016632:	4618      	mov	r0, r3
 8016634:	3738      	adds	r7, #56	@ 0x38
 8016636:	46bd      	mov	sp, r7
 8016638:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801663c <MatchBaseName>:

#ifndef IGNORE_NAME_CONSTRAINTS

static int MatchBaseName(int type, const char* name, int nameSz,
                         const char* base, int baseSz)
{
 801663c:	b580      	push	{r7, lr}
 801663e:	b088      	sub	sp, #32
 8016640:	af00      	add	r7, sp, #0
 8016642:	60f8      	str	r0, [r7, #12]
 8016644:	60b9      	str	r1, [r7, #8]
 8016646:	607a      	str	r2, [r7, #4]
 8016648:	603b      	str	r3, [r7, #0]
    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||
 801664a:	683b      	ldr	r3, [r7, #0]
 801664c:	2b00      	cmp	r3, #0
 801664e:	d019      	beq.n	8016684 <MatchBaseName+0x48>
 8016650:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016652:	2b00      	cmp	r3, #0
 8016654:	dd16      	ble.n	8016684 <MatchBaseName+0x48>
 8016656:	68bb      	ldr	r3, [r7, #8]
 8016658:	2b00      	cmp	r3, #0
 801665a:	d013      	beq.n	8016684 <MatchBaseName+0x48>
 801665c:	687b      	ldr	r3, [r7, #4]
 801665e:	2b00      	cmp	r3, #0
 8016660:	dd10      	ble.n	8016684 <MatchBaseName+0x48>
            name[0] == '.' || nameSz < baseSz ||
 8016662:	68bb      	ldr	r3, [r7, #8]
 8016664:	781b      	ldrb	r3, [r3, #0]
    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||
 8016666:	2b2e      	cmp	r3, #46	@ 0x2e
 8016668:	d00c      	beq.n	8016684 <MatchBaseName+0x48>
            name[0] == '.' || nameSz < baseSz ||
 801666a:	687a      	ldr	r2, [r7, #4]
 801666c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801666e:	429a      	cmp	r2, r3
 8016670:	db08      	blt.n	8016684 <MatchBaseName+0x48>
 8016672:	68fb      	ldr	r3, [r7, #12]
 8016674:	2b01      	cmp	r3, #1
 8016676:	d007      	beq.n	8016688 <MatchBaseName+0x4c>
            (type != ASN_RFC822_TYPE && type != ASN_DNS_TYPE &&
 8016678:	68fb      	ldr	r3, [r7, #12]
 801667a:	2b02      	cmp	r3, #2
 801667c:	d004      	beq.n	8016688 <MatchBaseName+0x4c>
 801667e:	68fb      	ldr	r3, [r7, #12]
 8016680:	2b04      	cmp	r3, #4
 8016682:	d001      	beq.n	8016688 <MatchBaseName+0x4c>
             type != ASN_DIR_TYPE)) {
        return 0;
 8016684:	2300      	movs	r3, #0
 8016686:	e0a2      	b.n	80167ce <MatchBaseName+0x192>
    }

    if (type == ASN_DIR_TYPE)
 8016688:	68fb      	ldr	r3, [r7, #12]
 801668a:	2b04      	cmp	r3, #4
 801668c:	d10c      	bne.n	80166a8 <MatchBaseName+0x6c>
        return XMEMCMP(name, base, (size_t)baseSz) == 0;
 801668e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016690:	461a      	mov	r2, r3
 8016692:	6839      	ldr	r1, [r7, #0]
 8016694:	68b8      	ldr	r0, [r7, #8]
 8016696:	f011 fef1 	bl	802847c <memcmp>
 801669a:	4603      	mov	r3, r0
 801669c:	2b00      	cmp	r3, #0
 801669e:	bf0c      	ite	eq
 80166a0:	2301      	moveq	r3, #1
 80166a2:	2300      	movne	r3, #0
 80166a4:	b2db      	uxtb	r3, r3
 80166a6:	e092      	b.n	80167ce <MatchBaseName+0x192>

    /* If an email type, handle special cases where the base is only
     * a domain, or is an email address itself. */
    if (type == ASN_RFC822_TYPE) {
 80166a8:	68fb      	ldr	r3, [r7, #12]
 80166aa:	2b01      	cmp	r3, #1
 80166ac:	d146      	bne.n	801673c <MatchBaseName+0x100>
        const char* p = NULL;
 80166ae:	2300      	movs	r3, #0
 80166b0:	61fb      	str	r3, [r7, #28]
        int count = 0;
 80166b2:	2300      	movs	r3, #0
 80166b4:	61bb      	str	r3, [r7, #24]

        if (base[0] != '.') {
 80166b6:	683b      	ldr	r3, [r7, #0]
 80166b8:	781b      	ldrb	r3, [r3, #0]
 80166ba:	2b2e      	cmp	r3, #46	@ 0x2e
 80166bc:	d018      	beq.n	80166f0 <MatchBaseName+0xb4>
            p = base;
 80166be:	683b      	ldr	r3, [r7, #0]
 80166c0:	61fb      	str	r3, [r7, #28]
            count = 0;
 80166c2:	2300      	movs	r3, #0
 80166c4:	61bb      	str	r3, [r7, #24]

            /* find the '@' in the base */
            while (*p != '@' && count < baseSz) {
 80166c6:	e005      	b.n	80166d4 <MatchBaseName+0x98>
                count++;
 80166c8:	69bb      	ldr	r3, [r7, #24]
 80166ca:	3301      	adds	r3, #1
 80166cc:	61bb      	str	r3, [r7, #24]
                p++;
 80166ce:	69fb      	ldr	r3, [r7, #28]
 80166d0:	3301      	adds	r3, #1
 80166d2:	61fb      	str	r3, [r7, #28]
            while (*p != '@' && count < baseSz) {
 80166d4:	69fb      	ldr	r3, [r7, #28]
 80166d6:	781b      	ldrb	r3, [r3, #0]
 80166d8:	2b40      	cmp	r3, #64	@ 0x40
 80166da:	d003      	beq.n	80166e4 <MatchBaseName+0xa8>
 80166dc:	69ba      	ldr	r2, [r7, #24]
 80166de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80166e0:	429a      	cmp	r2, r3
 80166e2:	dbf1      	blt.n	80166c8 <MatchBaseName+0x8c>
            }

            /* No '@' in base, reset p to NULL */
            if (count >= baseSz)
 80166e4:	69ba      	ldr	r2, [r7, #24]
 80166e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80166e8:	429a      	cmp	r2, r3
 80166ea:	db01      	blt.n	80166f0 <MatchBaseName+0xb4>
                p = NULL;
 80166ec:	2300      	movs	r3, #0
 80166ee:	61fb      	str	r3, [r7, #28]
        }

        if (p == NULL) {
 80166f0:	69fb      	ldr	r3, [r7, #28]
 80166f2:	2b00      	cmp	r3, #0
 80166f4:	d122      	bne.n	801673c <MatchBaseName+0x100>
            /* Base isn't an email address, it is a domain name,
             * wind the name forward one character past its '@'. */
            p = name;
 80166f6:	68bb      	ldr	r3, [r7, #8]
 80166f8:	61fb      	str	r3, [r7, #28]
            count = 0;
 80166fa:	2300      	movs	r3, #0
 80166fc:	61bb      	str	r3, [r7, #24]
            while (*p != '@' && count < baseSz) {
 80166fe:	e005      	b.n	801670c <MatchBaseName+0xd0>
                count++;
 8016700:	69bb      	ldr	r3, [r7, #24]
 8016702:	3301      	adds	r3, #1
 8016704:	61bb      	str	r3, [r7, #24]
                p++;
 8016706:	69fb      	ldr	r3, [r7, #28]
 8016708:	3301      	adds	r3, #1
 801670a:	61fb      	str	r3, [r7, #28]
            while (*p != '@' && count < baseSz) {
 801670c:	69fb      	ldr	r3, [r7, #28]
 801670e:	781b      	ldrb	r3, [r3, #0]
 8016710:	2b40      	cmp	r3, #64	@ 0x40
 8016712:	d003      	beq.n	801671c <MatchBaseName+0xe0>
 8016714:	69ba      	ldr	r2, [r7, #24]
 8016716:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016718:	429a      	cmp	r2, r3
 801671a:	dbf1      	blt.n	8016700 <MatchBaseName+0xc4>
            }

            if (count < baseSz && *p == '@') {
 801671c:	69ba      	ldr	r2, [r7, #24]
 801671e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016720:	429a      	cmp	r2, r3
 8016722:	da0b      	bge.n	801673c <MatchBaseName+0x100>
 8016724:	69fb      	ldr	r3, [r7, #28]
 8016726:	781b      	ldrb	r3, [r3, #0]
 8016728:	2b40      	cmp	r3, #64	@ 0x40
 801672a:	d107      	bne.n	801673c <MatchBaseName+0x100>
                name = p + 1;
 801672c:	69fb      	ldr	r3, [r7, #28]
 801672e:	3301      	adds	r3, #1
 8016730:	60bb      	str	r3, [r7, #8]
                nameSz -= count + 1;
 8016732:	69bb      	ldr	r3, [r7, #24]
 8016734:	3301      	adds	r3, #1
 8016736:	687a      	ldr	r2, [r7, #4]
 8016738:	1ad3      	subs	r3, r2, r3
 801673a:	607b      	str	r3, [r7, #4]
    /* RFC 5280 section 4.2.1.10
     * "...Any DNS name that can be constructed by simply adding zero or more
     *  labels to the left-hand side of the name satisfies the name constraint."
     * i.e www.host.example.com works for host.example.com name constraint and
     * host1.example.com does not. */
    if (type == ASN_DNS_TYPE || (type == ASN_RFC822_TYPE && base[0] == '.')) {
 801673c:	68fb      	ldr	r3, [r7, #12]
 801673e:	2b02      	cmp	r3, #2
 8016740:	d006      	beq.n	8016750 <MatchBaseName+0x114>
 8016742:	68fb      	ldr	r3, [r7, #12]
 8016744:	2b01      	cmp	r3, #1
 8016746:	d13e      	bne.n	80167c6 <MatchBaseName+0x18a>
 8016748:	683b      	ldr	r3, [r7, #0]
 801674a:	781b      	ldrb	r3, [r3, #0]
 801674c:	2b2e      	cmp	r3, #46	@ 0x2e
 801674e:	d13a      	bne.n	80167c6 <MatchBaseName+0x18a>
        int szAdjust = nameSz - baseSz;
 8016750:	687a      	ldr	r2, [r7, #4]
 8016752:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016754:	1ad3      	subs	r3, r2, r3
 8016756:	617b      	str	r3, [r7, #20]
        name += szAdjust;
 8016758:	697b      	ldr	r3, [r7, #20]
 801675a:	68ba      	ldr	r2, [r7, #8]
 801675c:	4413      	add	r3, r2
 801675e:	60bb      	str	r3, [r7, #8]
        nameSz -= szAdjust;
 8016760:	687a      	ldr	r2, [r7, #4]
 8016762:	697b      	ldr	r3, [r7, #20]
 8016764:	1ad3      	subs	r3, r2, r3
 8016766:	607b      	str	r3, [r7, #4]
    }

    while (nameSz > 0) {
 8016768:	e02d      	b.n	80167c6 <MatchBaseName+0x18a>
        if (XTOLOWER((unsigned char)*name) !=
 801676a:	68bb      	ldr	r3, [r7, #8]
 801676c:	781b      	ldrb	r3, [r3, #0]
 801676e:	74fb      	strb	r3, [r7, #19]
 8016770:	7cfb      	ldrb	r3, [r7, #19]
 8016772:	3301      	adds	r3, #1
 8016774:	4a18      	ldr	r2, [pc, #96]	@ (80167d8 <MatchBaseName+0x19c>)
 8016776:	4413      	add	r3, r2
 8016778:	781b      	ldrb	r3, [r3, #0]
 801677a:	f003 0303 	and.w	r3, r3, #3
 801677e:	2b01      	cmp	r3, #1
 8016780:	d103      	bne.n	801678a <MatchBaseName+0x14e>
 8016782:	7cfb      	ldrb	r3, [r7, #19]
 8016784:	f103 0220 	add.w	r2, r3, #32
 8016788:	e000      	b.n	801678c <MatchBaseName+0x150>
 801678a:	7cfa      	ldrb	r2, [r7, #19]
                                               XTOLOWER((unsigned char)*base))
 801678c:	683b      	ldr	r3, [r7, #0]
 801678e:	781b      	ldrb	r3, [r3, #0]
 8016790:	74bb      	strb	r3, [r7, #18]
 8016792:	7cbb      	ldrb	r3, [r7, #18]
 8016794:	3301      	adds	r3, #1
 8016796:	4910      	ldr	r1, [pc, #64]	@ (80167d8 <MatchBaseName+0x19c>)
 8016798:	440b      	add	r3, r1
 801679a:	781b      	ldrb	r3, [r3, #0]
 801679c:	f003 0303 	and.w	r3, r3, #3
 80167a0:	2b01      	cmp	r3, #1
 80167a2:	d102      	bne.n	80167aa <MatchBaseName+0x16e>
 80167a4:	7cbb      	ldrb	r3, [r7, #18]
 80167a6:	3320      	adds	r3, #32
 80167a8:	e000      	b.n	80167ac <MatchBaseName+0x170>
 80167aa:	7cbb      	ldrb	r3, [r7, #18]
        if (XTOLOWER((unsigned char)*name) !=
 80167ac:	429a      	cmp	r2, r3
 80167ae:	d001      	beq.n	80167b4 <MatchBaseName+0x178>
            return 0;
 80167b0:	2300      	movs	r3, #0
 80167b2:	e00c      	b.n	80167ce <MatchBaseName+0x192>
        name++;
 80167b4:	68bb      	ldr	r3, [r7, #8]
 80167b6:	3301      	adds	r3, #1
 80167b8:	60bb      	str	r3, [r7, #8]
        base++;
 80167ba:	683b      	ldr	r3, [r7, #0]
 80167bc:	3301      	adds	r3, #1
 80167be:	603b      	str	r3, [r7, #0]
        nameSz--;
 80167c0:	687b      	ldr	r3, [r7, #4]
 80167c2:	3b01      	subs	r3, #1
 80167c4:	607b      	str	r3, [r7, #4]
    while (nameSz > 0) {
 80167c6:	687b      	ldr	r3, [r7, #4]
 80167c8:	2b00      	cmp	r3, #0
 80167ca:	dcce      	bgt.n	801676a <MatchBaseName+0x12e>
    }

    return 1;
 80167cc:	2301      	movs	r3, #1
}
 80167ce:	4618      	mov	r0, r3
 80167d0:	3720      	adds	r7, #32
 80167d2:	46bd      	mov	sp, r7
 80167d4:	bd80      	pop	{r7, pc}
 80167d6:	bf00      	nop
 80167d8:	08033c9c 	.word	0x08033c9c

080167dc <PermittedListOk>:
 * nameType Type of DNS name to currently searching
 * return 1 if found in list or if not needed
 * return 0 if not found in the list but is needed
 */
static int PermittedListOk(DNS_entry* name, Base_entry* dnsList, byte nameType)
{
 80167dc:	b590      	push	{r4, r7, lr}
 80167de:	b08b      	sub	sp, #44	@ 0x2c
 80167e0:	af02      	add	r7, sp, #8
 80167e2:	60f8      	str	r0, [r7, #12]
 80167e4:	60b9      	str	r1, [r7, #8]
 80167e6:	4613      	mov	r3, r2
 80167e8:	71fb      	strb	r3, [r7, #7]
    Base_entry* current = dnsList;
 80167ea:	68bb      	ldr	r3, [r7, #8]
 80167ec:	61fb      	str	r3, [r7, #28]
    int match = 0;
 80167ee:	2300      	movs	r3, #0
 80167f0:	61bb      	str	r3, [r7, #24]
    int need  = 0;
 80167f2:	2300      	movs	r3, #0
 80167f4:	617b      	str	r3, [r7, #20]
    int ret   = 1; /* is ok unless needed and no match found */
 80167f6:	2301      	movs	r3, #1
 80167f8:	613b      	str	r3, [r7, #16]

    while (current != NULL) {
 80167fa:	e022      	b.n	8016842 <PermittedListOk+0x66>
        if (current->type == nameType) {
 80167fc:	69fb      	ldr	r3, [r7, #28]
 80167fe:	7b1b      	ldrb	r3, [r3, #12]
 8016800:	79fa      	ldrb	r2, [r7, #7]
 8016802:	429a      	cmp	r2, r3
 8016804:	d11a      	bne.n	801683c <PermittedListOk+0x60>
            need = 1; /* restriction on permitted names is set for this type */
 8016806:	2301      	movs	r3, #1
 8016808:	617b      	str	r3, [r7, #20]
            if (name->len >= current->nameSz &&
 801680a:	68fb      	ldr	r3, [r7, #12]
 801680c:	689a      	ldr	r2, [r3, #8]
 801680e:	69fb      	ldr	r3, [r7, #28]
 8016810:	689b      	ldr	r3, [r3, #8]
 8016812:	429a      	cmp	r2, r3
 8016814:	db12      	blt.n	801683c <PermittedListOk+0x60>
                MatchBaseName(nameType, name->name, name->len,
 8016816:	79f8      	ldrb	r0, [r7, #7]
 8016818:	68fb      	ldr	r3, [r7, #12]
 801681a:	68d9      	ldr	r1, [r3, #12]
 801681c:	68fb      	ldr	r3, [r7, #12]
 801681e:	689a      	ldr	r2, [r3, #8]
                              current->name, current->nameSz)) {
 8016820:	69fb      	ldr	r3, [r7, #28]
 8016822:	685c      	ldr	r4, [r3, #4]
                MatchBaseName(nameType, name->name, name->len,
 8016824:	69fb      	ldr	r3, [r7, #28]
 8016826:	689b      	ldr	r3, [r3, #8]
 8016828:	9300      	str	r3, [sp, #0]
 801682a:	4623      	mov	r3, r4
 801682c:	f7ff ff06 	bl	801663c <MatchBaseName>
 8016830:	4603      	mov	r3, r0
            if (name->len >= current->nameSz &&
 8016832:	2b00      	cmp	r3, #0
 8016834:	d002      	beq.n	801683c <PermittedListOk+0x60>
                match = 1; /* found the current name in the permitted list*/
 8016836:	2301      	movs	r3, #1
 8016838:	61bb      	str	r3, [r7, #24]
                break;
 801683a:	e005      	b.n	8016848 <PermittedListOk+0x6c>
            }
        }
        current = current->next;
 801683c:	69fb      	ldr	r3, [r7, #28]
 801683e:	681b      	ldr	r3, [r3, #0]
 8016840:	61fb      	str	r3, [r7, #28]
    while (current != NULL) {
 8016842:	69fb      	ldr	r3, [r7, #28]
 8016844:	2b00      	cmp	r3, #0
 8016846:	d1d9      	bne.n	80167fc <PermittedListOk+0x20>
    }

    /* check if permitted name restriction was set and no matching name found */
    if (need && !match)
 8016848:	697b      	ldr	r3, [r7, #20]
 801684a:	2b00      	cmp	r3, #0
 801684c:	d004      	beq.n	8016858 <PermittedListOk+0x7c>
 801684e:	69bb      	ldr	r3, [r7, #24]
 8016850:	2b00      	cmp	r3, #0
 8016852:	d101      	bne.n	8016858 <PermittedListOk+0x7c>
        ret = 0;
 8016854:	2300      	movs	r3, #0
 8016856:	613b      	str	r3, [r7, #16]

    return ret;
 8016858:	693b      	ldr	r3, [r7, #16]
}
 801685a:	4618      	mov	r0, r3
 801685c:	3724      	adds	r7, #36	@ 0x24
 801685e:	46bd      	mov	sp, r7
 8016860:	bd90      	pop	{r4, r7, pc}

08016862 <IsInExcludedList>:
 * dnsList  The list to search through
 * nameType Type of DNS name to currently searching
 * return 1 if found in list and 0 if not found in the list
 */
static int IsInExcludedList(DNS_entry* name, Base_entry* dnsList, byte nameType)
{
 8016862:	b590      	push	{r4, r7, lr}
 8016864:	b089      	sub	sp, #36	@ 0x24
 8016866:	af02      	add	r7, sp, #8
 8016868:	60f8      	str	r0, [r7, #12]
 801686a:	60b9      	str	r1, [r7, #8]
 801686c:	4613      	mov	r3, r2
 801686e:	71fb      	strb	r3, [r7, #7]
    int ret = 0; /* default of not found in the list */
 8016870:	2300      	movs	r3, #0
 8016872:	617b      	str	r3, [r7, #20]
    Base_entry* current = dnsList;
 8016874:	68bb      	ldr	r3, [r7, #8]
 8016876:	613b      	str	r3, [r7, #16]

    while (current != NULL) {
 8016878:	e020      	b.n	80168bc <IsInExcludedList+0x5a>
        if (current->type == nameType) {
 801687a:	693b      	ldr	r3, [r7, #16]
 801687c:	7b1b      	ldrb	r3, [r3, #12]
 801687e:	79fa      	ldrb	r2, [r7, #7]
 8016880:	429a      	cmp	r2, r3
 8016882:	d118      	bne.n	80168b6 <IsInExcludedList+0x54>
            if (name->len >= current->nameSz &&
 8016884:	68fb      	ldr	r3, [r7, #12]
 8016886:	689a      	ldr	r2, [r3, #8]
 8016888:	693b      	ldr	r3, [r7, #16]
 801688a:	689b      	ldr	r3, [r3, #8]
 801688c:	429a      	cmp	r2, r3
 801688e:	db12      	blt.n	80168b6 <IsInExcludedList+0x54>
                MatchBaseName(nameType, name->name, name->len,
 8016890:	79f8      	ldrb	r0, [r7, #7]
 8016892:	68fb      	ldr	r3, [r7, #12]
 8016894:	68d9      	ldr	r1, [r3, #12]
 8016896:	68fb      	ldr	r3, [r7, #12]
 8016898:	689a      	ldr	r2, [r3, #8]
                              current->name, current->nameSz)) {
 801689a:	693b      	ldr	r3, [r7, #16]
 801689c:	685c      	ldr	r4, [r3, #4]
                MatchBaseName(nameType, name->name, name->len,
 801689e:	693b      	ldr	r3, [r7, #16]
 80168a0:	689b      	ldr	r3, [r3, #8]
 80168a2:	9300      	str	r3, [sp, #0]
 80168a4:	4623      	mov	r3, r4
 80168a6:	f7ff fec9 	bl	801663c <MatchBaseName>
 80168aa:	4603      	mov	r3, r0
            if (name->len >= current->nameSz &&
 80168ac:	2b00      	cmp	r3, #0
 80168ae:	d002      	beq.n	80168b6 <IsInExcludedList+0x54>
                ret = 1;
 80168b0:	2301      	movs	r3, #1
 80168b2:	617b      	str	r3, [r7, #20]
                break;
 80168b4:	e005      	b.n	80168c2 <IsInExcludedList+0x60>
            }
        }
        current = current->next;
 80168b6:	693b      	ldr	r3, [r7, #16]
 80168b8:	681b      	ldr	r3, [r3, #0]
 80168ba:	613b      	str	r3, [r7, #16]
    while (current != NULL) {
 80168bc:	693b      	ldr	r3, [r7, #16]
 80168be:	2b00      	cmp	r3, #0
 80168c0:	d1db      	bne.n	801687a <IsInExcludedList+0x18>
    }

    return ret;
 80168c2:	697b      	ldr	r3, [r7, #20]
}
 80168c4:	4618      	mov	r0, r3
 80168c6:	371c      	adds	r7, #28
 80168c8:	46bd      	mov	sp, r7
 80168ca:	bd90      	pop	{r4, r7, pc}

080168cc <ConfirmNameConstraints>:


static int ConfirmNameConstraints(Signer* signer, DecodedCert* cert)
{
 80168cc:	b580      	push	{r7, lr}
 80168ce:	b08a      	sub	sp, #40	@ 0x28
 80168d0:	af00      	add	r7, sp, #0
 80168d2:	6078      	str	r0, [r7, #4]
 80168d4:	6039      	str	r1, [r7, #0]
    const byte nameTypes[] = {ASN_RFC822_TYPE, ASN_DNS_TYPE, ASN_DIR_TYPE};
 80168d6:	4a5a      	ldr	r2, [pc, #360]	@ (8016a40 <ConfirmNameConstraints+0x174>)
 80168d8:	f107 031c 	add.w	r3, r7, #28
 80168dc:	6812      	ldr	r2, [r2, #0]
 80168de:	4611      	mov	r1, r2
 80168e0:	8019      	strh	r1, [r3, #0]
 80168e2:	3302      	adds	r3, #2
 80168e4:	0c12      	lsrs	r2, r2, #16
 80168e6:	701a      	strb	r2, [r3, #0]
    int i;

    if (signer == NULL || cert == NULL)
 80168e8:	687b      	ldr	r3, [r7, #4]
 80168ea:	2b00      	cmp	r3, #0
 80168ec:	d002      	beq.n	80168f4 <ConfirmNameConstraints+0x28>
 80168ee:	683b      	ldr	r3, [r7, #0]
 80168f0:	2b00      	cmp	r3, #0
 80168f2:	d101      	bne.n	80168f8 <ConfirmNameConstraints+0x2c>
        return 0;
 80168f4:	2300      	movs	r3, #0
 80168f6:	e09e      	b.n	8016a36 <ConfirmNameConstraints+0x16a>

    if (signer->excludedNames == NULL && signer->permittedNames == NULL)
 80168f8:	687b      	ldr	r3, [r7, #4]
 80168fa:	69db      	ldr	r3, [r3, #28]
 80168fc:	2b00      	cmp	r3, #0
 80168fe:	d105      	bne.n	801690c <ConfirmNameConstraints+0x40>
 8016900:	687b      	ldr	r3, [r7, #4]
 8016902:	699b      	ldr	r3, [r3, #24]
 8016904:	2b00      	cmp	r3, #0
 8016906:	d101      	bne.n	801690c <ConfirmNameConstraints+0x40>
        return 1;
 8016908:	2301      	movs	r3, #1
 801690a:	e094      	b.n	8016a36 <ConfirmNameConstraints+0x16a>

    for (i=0; i < (int)sizeof(nameTypes); i++) {
 801690c:	2300      	movs	r3, #0
 801690e:	627b      	str	r3, [r7, #36]	@ 0x24
 8016910:	e08c      	b.n	8016a2c <ConfirmNameConstraints+0x160>
        byte nameType = nameTypes[i];
 8016912:	f107 021c 	add.w	r2, r7, #28
 8016916:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016918:	4413      	add	r3, r2
 801691a:	781b      	ldrb	r3, [r3, #0]
 801691c:	77fb      	strb	r3, [r7, #31]
        DNS_entry* name = NULL;
 801691e:	2300      	movs	r3, #0
 8016920:	623b      	str	r3, [r7, #32]
        DNS_entry  subjectDnsName; /* temporary node used for subject name */

        XMEMSET(&subjectDnsName, 0, sizeof(DNS_entry));
 8016922:	f107 030c 	add.w	r3, r7, #12
 8016926:	2210      	movs	r2, #16
 8016928:	2100      	movs	r1, #0
 801692a:	4618      	mov	r0, r3
 801692c:	f011 fdd0 	bl	80284d0 <memset>
        switch (nameType) {
 8016930:	7ffb      	ldrb	r3, [r7, #31]
 8016932:	2b04      	cmp	r3, #4
 8016934:	d01e      	beq.n	8016974 <ConfirmNameConstraints+0xa8>
 8016936:	2b04      	cmp	r3, #4
 8016938:	dc31      	bgt.n	801699e <ConfirmNameConstraints+0xd2>
 801693a:	2b01      	cmp	r3, #1
 801693c:	d005      	beq.n	801694a <ConfirmNameConstraints+0x7e>
 801693e:	2b02      	cmp	r3, #2
 8016940:	d12d      	bne.n	801699e <ConfirmNameConstraints+0xd2>
            case ASN_DNS_TYPE:
                /* Should it also consider CN in subject? It could use
                 * subjectDnsName too */
                name = cert->altNames;
 8016942:	683b      	ldr	r3, [r7, #0]
 8016944:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8016946:	623b      	str	r3, [r7, #32]
                break;
 8016948:	e02e      	b.n	80169a8 <ConfirmNameConstraints+0xdc>
            case ASN_RFC822_TYPE:
                /* Shouldn't it validate E= in subject as well? */
                name = cert->altEmailNames;
 801694a:	683b      	ldr	r3, [r7, #0]
 801694c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801694e:	623b      	str	r3, [r7, #32]

                /* Add subject email for checking. */
                if (cert->subjectEmail != NULL) {
 8016950:	683b      	ldr	r3, [r7, #0]
 8016952:	f8d3 345c 	ldr.w	r3, [r3, #1116]	@ 0x45c
 8016956:	2b00      	cmp	r3, #0
 8016958:	d023      	beq.n	80169a2 <ConfirmNameConstraints+0xd6>
                     * "When constraints are imposed on the rfc822Name name
                     * form, but the certificate does not include a subject
                     * alternative name, the rfc822Name constraint MUST be
                     * applied to the attribute of type emailAddress in the
                     * subject distinguished name" */
                    subjectDnsName.next = NULL;
 801695a:	2300      	movs	r3, #0
 801695c:	60fb      	str	r3, [r7, #12]
                    subjectDnsName.type = ASN_RFC822_TYPE;
 801695e:	2301      	movs	r3, #1
 8016960:	613b      	str	r3, [r7, #16]
                    subjectDnsName.len  = cert->subjectEmailLen;
 8016962:	683b      	ldr	r3, [r7, #0]
 8016964:	f8d3 3460 	ldr.w	r3, [r3, #1120]	@ 0x460
 8016968:	617b      	str	r3, [r7, #20]
                    subjectDnsName.name = (char *)cert->subjectEmail;
 801696a:	683b      	ldr	r3, [r7, #0]
 801696c:	f8d3 345c 	ldr.w	r3, [r3, #1116]	@ 0x45c
 8016970:	61bb      	str	r3, [r7, #24]
                }
                break;
 8016972:	e016      	b.n	80169a2 <ConfirmNameConstraints+0xd6>
            case ASN_DIR_TYPE:
            #ifndef WOLFSSL_NO_ASN_STRICT
                name = cert->altDirNames;
 8016974:	683b      	ldr	r3, [r7, #0]
 8016976:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8016978:	623b      	str	r3, [r7, #32]
                    "Restrictions of the form directoryName MUST be
                    applied to the subject field .... and to any names
                    of type directoryName in the subjectAltName
                    extension"
                */
                if (cert->subjectRaw != NULL) {
 801697a:	683b      	ldr	r3, [r7, #0]
 801697c:	f8d3 3454 	ldr.w	r3, [r3, #1108]	@ 0x454
 8016980:	2b00      	cmp	r3, #0
 8016982:	d010      	beq.n	80169a6 <ConfirmNameConstraints+0xda>
                    subjectDnsName.next = NULL;
 8016984:	2300      	movs	r3, #0
 8016986:	60fb      	str	r3, [r7, #12]
                    subjectDnsName.type = ASN_DIR_TYPE;
 8016988:	2304      	movs	r3, #4
 801698a:	613b      	str	r3, [r7, #16]
                    subjectDnsName.len = cert->subjectRawLen;
 801698c:	683b      	ldr	r3, [r7, #0]
 801698e:	f8d3 3458 	ldr.w	r3, [r3, #1112]	@ 0x458
 8016992:	617b      	str	r3, [r7, #20]
                    subjectDnsName.name = (char *)cert->subjectRaw;
 8016994:	683b      	ldr	r3, [r7, #0]
 8016996:	f8d3 3454 	ldr.w	r3, [r3, #1108]	@ 0x454
 801699a:	61bb      	str	r3, [r7, #24]
                }
                break;
 801699c:	e003      	b.n	80169a6 <ConfirmNameConstraints+0xda>
            default:
                /* Other types of names are ignored for now.
                 * Shouldn't it be rejected if it there is a altNamesByType[nameType]
                 * and signer->extNameConstraintCrit is set? */
                return 0;
 801699e:	2300      	movs	r3, #0
 80169a0:	e049      	b.n	8016a36 <ConfirmNameConstraints+0x16a>
                break;
 80169a2:	bf00      	nop
 80169a4:	e01c      	b.n	80169e0 <ConfirmNameConstraints+0x114>
                break;
 80169a6:	bf00      	nop
        }

        while (name != NULL) {
 80169a8:	e01a      	b.n	80169e0 <ConfirmNameConstraints+0x114>
            if (IsInExcludedList(name, signer->excludedNames, nameType) == 1) {
 80169aa:	687b      	ldr	r3, [r7, #4]
 80169ac:	69db      	ldr	r3, [r3, #28]
 80169ae:	7ffa      	ldrb	r2, [r7, #31]
 80169b0:	4619      	mov	r1, r3
 80169b2:	6a38      	ldr	r0, [r7, #32]
 80169b4:	f7ff ff55 	bl	8016862 <IsInExcludedList>
 80169b8:	4603      	mov	r3, r0
 80169ba:	2b01      	cmp	r3, #1
 80169bc:	d101      	bne.n	80169c2 <ConfirmNameConstraints+0xf6>
                WOLFSSL_MSG("Excluded name was found!");
                return 0;
 80169be:	2300      	movs	r3, #0
 80169c0:	e039      	b.n	8016a36 <ConfirmNameConstraints+0x16a>
            }

            /* Check against the permitted list */
            if (PermittedListOk(name, signer->permittedNames, nameType) != 1) {
 80169c2:	687b      	ldr	r3, [r7, #4]
 80169c4:	699b      	ldr	r3, [r3, #24]
 80169c6:	7ffa      	ldrb	r2, [r7, #31]
 80169c8:	4619      	mov	r1, r3
 80169ca:	6a38      	ldr	r0, [r7, #32]
 80169cc:	f7ff ff06 	bl	80167dc <PermittedListOk>
 80169d0:	4603      	mov	r3, r0
 80169d2:	2b01      	cmp	r3, #1
 80169d4:	d001      	beq.n	80169da <ConfirmNameConstraints+0x10e>
                WOLFSSL_MSG("Permitted name was not found!");
                return 0;
 80169d6:	2300      	movs	r3, #0
 80169d8:	e02d      	b.n	8016a36 <ConfirmNameConstraints+0x16a>
            }

            name = name->next;
 80169da:	6a3b      	ldr	r3, [r7, #32]
 80169dc:	681b      	ldr	r3, [r3, #0]
 80169de:	623b      	str	r3, [r7, #32]
        while (name != NULL) {
 80169e0:	6a3b      	ldr	r3, [r7, #32]
 80169e2:	2b00      	cmp	r3, #0
 80169e4:	d1e1      	bne.n	80169aa <ConfirmNameConstraints+0xde>
        }

        /* handle comparing against subject name too */
        if (subjectDnsName.len > 0 && subjectDnsName.name != NULL) {
 80169e6:	697b      	ldr	r3, [r7, #20]
 80169e8:	2b00      	cmp	r3, #0
 80169ea:	dd1c      	ble.n	8016a26 <ConfirmNameConstraints+0x15a>
 80169ec:	69bb      	ldr	r3, [r7, #24]
 80169ee:	2b00      	cmp	r3, #0
 80169f0:	d019      	beq.n	8016a26 <ConfirmNameConstraints+0x15a>
            if (IsInExcludedList(&subjectDnsName, signer->excludedNames,
 80169f2:	687b      	ldr	r3, [r7, #4]
 80169f4:	69d9      	ldr	r1, [r3, #28]
 80169f6:	7ffa      	ldrb	r2, [r7, #31]
 80169f8:	f107 030c 	add.w	r3, r7, #12
 80169fc:	4618      	mov	r0, r3
 80169fe:	f7ff ff30 	bl	8016862 <IsInExcludedList>
 8016a02:	4603      	mov	r3, r0
 8016a04:	2b01      	cmp	r3, #1
 8016a06:	d101      	bne.n	8016a0c <ConfirmNameConstraints+0x140>
                        nameType) == 1) {
                WOLFSSL_MSG("Excluded name was found!");
                return 0;
 8016a08:	2300      	movs	r3, #0
 8016a0a:	e014      	b.n	8016a36 <ConfirmNameConstraints+0x16a>
            }

            /* Check against the permitted list */
            if (PermittedListOk(&subjectDnsName, signer->permittedNames,
 8016a0c:	687b      	ldr	r3, [r7, #4]
 8016a0e:	6999      	ldr	r1, [r3, #24]
 8016a10:	7ffa      	ldrb	r2, [r7, #31]
 8016a12:	f107 030c 	add.w	r3, r7, #12
 8016a16:	4618      	mov	r0, r3
 8016a18:	f7ff fee0 	bl	80167dc <PermittedListOk>
 8016a1c:	4603      	mov	r3, r0
 8016a1e:	2b01      	cmp	r3, #1
 8016a20:	d001      	beq.n	8016a26 <ConfirmNameConstraints+0x15a>
                        nameType) != 1) {
                WOLFSSL_MSG("Permitted name was not found!");
                return 0;
 8016a22:	2300      	movs	r3, #0
 8016a24:	e007      	b.n	8016a36 <ConfirmNameConstraints+0x16a>
    for (i=0; i < (int)sizeof(nameTypes); i++) {
 8016a26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016a28:	3301      	adds	r3, #1
 8016a2a:	627b      	str	r3, [r7, #36]	@ 0x24
 8016a2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016a2e:	2b02      	cmp	r3, #2
 8016a30:	f77f af6f 	ble.w	8016912 <ConfirmNameConstraints+0x46>
            }
        }
    }

    return 1;
 8016a34:	2301      	movs	r3, #1
}
 8016a36:	4618      	mov	r0, r3
 8016a38:	3728      	adds	r7, #40	@ 0x28
 8016a3a:	46bd      	mov	sp, r7
 8016a3c:	bd80      	pop	{r7, pc}
 8016a3e:	bf00      	nop
 8016a40:	0802f870 	.word	0x0802f870

08016a44 <DecodeGeneralName>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int DecodeGeneralName(const byte* input, word32* inOutIdx, byte tag,
                             int len, DecodedCert* cert)
{
 8016a44:	b580      	push	{r7, lr}
 8016a46:	b08c      	sub	sp, #48	@ 0x30
 8016a48:	af02      	add	r7, sp, #8
 8016a4a:	60f8      	str	r0, [r7, #12]
 8016a4c:	60b9      	str	r1, [r7, #8]
 8016a4e:	603b      	str	r3, [r7, #0]
 8016a50:	4613      	mov	r3, r2
 8016a52:	71fb      	strb	r3, [r7, #7]
    int ret = 0;
 8016a54:	2300      	movs	r3, #0
 8016a56:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 idx = *inOutIdx;
 8016a58:	68bb      	ldr	r3, [r7, #8]
 8016a5a:	681b      	ldr	r3, [r3, #0]
 8016a5c:	623b      	str	r3, [r7, #32]

    /* GeneralName choice: dnsName */
    if (tag == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE)) {
 8016a5e:	79fb      	ldrb	r3, [r7, #7]
 8016a60:	2b82      	cmp	r3, #130	@ 0x82
 8016a62:	d116      	bne.n	8016a92 <DecodeGeneralName+0x4e>
        ret = SetDNSEntry(cert->heap, (const char*)(input + idx), len,
 8016a64:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016a66:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016a6a:	68fa      	ldr	r2, [r7, #12]
 8016a6c:	6a3b      	ldr	r3, [r7, #32]
 8016a6e:	18d1      	adds	r1, r2, r3
 8016a70:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016a72:	332c      	adds	r3, #44	@ 0x2c
 8016a74:	9300      	str	r3, [sp, #0]
 8016a76:	2302      	movs	r3, #2
 8016a78:	683a      	ldr	r2, [r7, #0]
 8016a7a:	f7fe feb4 	bl	80157e6 <SetDNSEntry>
 8016a7e:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_DNS_TYPE, &cert->altNames);
        if (ret == 0) {
 8016a80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016a82:	2b00      	cmp	r3, #0
 8016a84:	f040 809b 	bne.w	8016bbe <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016a88:	683b      	ldr	r3, [r7, #0]
 8016a8a:	6a3a      	ldr	r2, [r7, #32]
 8016a8c:	4413      	add	r3, r2
 8016a8e:	623b      	str	r3, [r7, #32]
 8016a90:	e095      	b.n	8016bbe <DecodeGeneralName+0x17a>
        }
    }
#ifndef IGNORE_NAME_CONSTRAINTS
    /* GeneralName choice: directoryName */
    else if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_DIR_TYPE)) {
 8016a92:	79fb      	ldrb	r3, [r7, #7]
 8016a94:	2ba4      	cmp	r3, #164	@ 0xa4
 8016a96:	d129      	bne.n	8016aec <DecodeGeneralName+0xa8>
        int strLen;
        word32 idxDir = idx;
 8016a98:	6a3b      	ldr	r3, [r7, #32]
 8016a9a:	617b      	str	r3, [r7, #20]

        /* Expecting a SEQUENCE using up all data. */
        if (GetASN_Sequence(input, &idxDir, &strLen, idx + (word32)len, 1) < 0)
 8016a9c:	683a      	ldr	r2, [r7, #0]
 8016a9e:	6a3b      	ldr	r3, [r7, #32]
 8016aa0:	4413      	add	r3, r2
 8016aa2:	f107 0218 	add.w	r2, r7, #24
 8016aa6:	f107 0114 	add.w	r1, r7, #20
 8016aaa:	2001      	movs	r0, #1
 8016aac:	9000      	str	r0, [sp, #0]
 8016aae:	68f8      	ldr	r0, [r7, #12]
 8016ab0:	f7fd f8d3 	bl	8013c5a <GetASN_Sequence>
 8016ab4:	4603      	mov	r3, r0
 8016ab6:	2b00      	cmp	r3, #0
 8016ab8:	da02      	bge.n	8016ac0 <DecodeGeneralName+0x7c>
        {
            WOLFSSL_MSG("\tfail: seq length");
            return ASN_PARSE_E;
 8016aba:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016abe:	e085      	b.n	8016bcc <DecodeGeneralName+0x188>
        }

        ret = SetDNSEntry(cert->heap, (const char*)(input + idxDir), strLen,
 8016ac0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016ac2:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016ac6:	697b      	ldr	r3, [r7, #20]
 8016ac8:	68fa      	ldr	r2, [r7, #12]
 8016aca:	18d1      	adds	r1, r2, r3
 8016acc:	69ba      	ldr	r2, [r7, #24]
 8016ace:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016ad0:	3334      	adds	r3, #52	@ 0x34
 8016ad2:	9300      	str	r3, [sp, #0]
 8016ad4:	2304      	movs	r3, #4
 8016ad6:	f7fe fe86 	bl	80157e6 <SetDNSEntry>
 8016ada:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_DIR_TYPE, &cert->altDirNames);
        if (ret == 0) {
 8016adc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016ade:	2b00      	cmp	r3, #0
 8016ae0:	d16d      	bne.n	8016bbe <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016ae2:	683b      	ldr	r3, [r7, #0]
 8016ae4:	6a3a      	ldr	r2, [r7, #32]
 8016ae6:	4413      	add	r3, r2
 8016ae8:	623b      	str	r3, [r7, #32]
 8016aea:	e068      	b.n	8016bbe <DecodeGeneralName+0x17a>
        }
    }
    /* GeneralName choice: rfc822Name */
    else if (tag == (ASN_CONTEXT_SPECIFIC | ASN_RFC822_TYPE)) {
 8016aec:	79fb      	ldrb	r3, [r7, #7]
 8016aee:	2b81      	cmp	r3, #129	@ 0x81
 8016af0:	d115      	bne.n	8016b1e <DecodeGeneralName+0xda>
        ret = SetDNSEntry(cert->heap, (const char*)(input + idx), len,
 8016af2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016af4:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016af8:	68fa      	ldr	r2, [r7, #12]
 8016afa:	6a3b      	ldr	r3, [r7, #32]
 8016afc:	18d1      	adds	r1, r2, r3
 8016afe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016b00:	3330      	adds	r3, #48	@ 0x30
 8016b02:	9300      	str	r3, [sp, #0]
 8016b04:	2301      	movs	r3, #1
 8016b06:	683a      	ldr	r2, [r7, #0]
 8016b08:	f7fe fe6d 	bl	80157e6 <SetDNSEntry>
 8016b0c:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_RFC822_TYPE, &cert->altEmailNames);
        if (ret == 0) {
 8016b0e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016b10:	2b00      	cmp	r3, #0
 8016b12:	d154      	bne.n	8016bbe <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016b14:	683b      	ldr	r3, [r7, #0]
 8016b16:	6a3a      	ldr	r2, [r7, #32]
 8016b18:	4413      	add	r3, r2
 8016b1a:	623b      	str	r3, [r7, #32]
 8016b1c:	e04f      	b.n	8016bbe <DecodeGeneralName+0x17a>
        }
    }
    /* GeneralName choice: uniformResourceIdentifier */
    else if (tag == (ASN_CONTEXT_SPECIFIC | ASN_URI_TYPE)) {
 8016b1e:	79fb      	ldrb	r3, [r7, #7]
 8016b20:	2b86      	cmp	r3, #134	@ 0x86
 8016b22:	d148      	bne.n	8016bb6 <DecodeGeneralName+0x172>
            hier-part, it must come after the ':' (see RFC 3986 Sec 3). */
        {
            int i;

            /* skip past scheme (i.e http,ftp,...) finding first ':' char */
            for (i = 0; i < len; i++) {
 8016b24:	2300      	movs	r3, #0
 8016b26:	61fb      	str	r3, [r7, #28]
 8016b28:	e014      	b.n	8016b54 <DecodeGeneralName+0x110>
                if (input[idx + (word32)i] == ':') {
 8016b2a:	69fa      	ldr	r2, [r7, #28]
 8016b2c:	6a3b      	ldr	r3, [r7, #32]
 8016b2e:	4413      	add	r3, r2
 8016b30:	68fa      	ldr	r2, [r7, #12]
 8016b32:	4413      	add	r3, r2
 8016b34:	781b      	ldrb	r3, [r3, #0]
 8016b36:	2b3a      	cmp	r3, #58	@ 0x3a
 8016b38:	d011      	beq.n	8016b5e <DecodeGeneralName+0x11a>
                    break;
                }
                if (input[idx + (word32)i] == '/') {
 8016b3a:	69fa      	ldr	r2, [r7, #28]
 8016b3c:	6a3b      	ldr	r3, [r7, #32]
 8016b3e:	4413      	add	r3, r2
 8016b40:	68fa      	ldr	r2, [r7, #12]
 8016b42:	4413      	add	r3, r2
 8016b44:	781b      	ldrb	r3, [r3, #0]
 8016b46:	2b2f      	cmp	r3, #47	@ 0x2f
 8016b48:	d101      	bne.n	8016b4e <DecodeGeneralName+0x10a>
                    i = len; /* error, found relative path since '/' was
 8016b4a:	683b      	ldr	r3, [r7, #0]
 8016b4c:	61fb      	str	r3, [r7, #28]
            for (i = 0; i < len; i++) {
 8016b4e:	69fb      	ldr	r3, [r7, #28]
 8016b50:	3301      	adds	r3, #1
 8016b52:	61fb      	str	r3, [r7, #28]
 8016b54:	69fa      	ldr	r2, [r7, #28]
 8016b56:	683b      	ldr	r3, [r7, #0]
 8016b58:	429a      	cmp	r2, r3
 8016b5a:	dbe6      	blt.n	8016b2a <DecodeGeneralName+0xe6>
 8016b5c:	e000      	b.n	8016b60 <DecodeGeneralName+0x11c>
                    break;
 8016b5e:	bf00      	nop
                              * value in next if statement. */
                }
            }

            /* test hier-part is empty */
            if (i == 0 || i == len) {
 8016b60:	69fb      	ldr	r3, [r7, #28]
 8016b62:	2b00      	cmp	r3, #0
 8016b64:	d003      	beq.n	8016b6e <DecodeGeneralName+0x12a>
 8016b66:	69fa      	ldr	r2, [r7, #28]
 8016b68:	683b      	ldr	r3, [r7, #0]
 8016b6a:	429a      	cmp	r2, r3
 8016b6c:	d102      	bne.n	8016b74 <DecodeGeneralName+0x130>
                WOLFSSL_MSG("\tEmpty or malformed URI");
                WOLFSSL_ERROR_VERBOSE(ASN_ALT_NAME_E);
                return ASN_ALT_NAME_E;
 8016b6e:	f06f 03a0 	mvn.w	r3, #160	@ 0xa0
 8016b72:	e02b      	b.n	8016bcc <DecodeGeneralName+0x188>
            }

            /* test if scheme is missing  */
            if (input[idx + (word32)i] != ':') {
 8016b74:	69fa      	ldr	r2, [r7, #28]
 8016b76:	6a3b      	ldr	r3, [r7, #32]
 8016b78:	4413      	add	r3, r2
 8016b7a:	68fa      	ldr	r2, [r7, #12]
 8016b7c:	4413      	add	r3, r2
 8016b7e:	781b      	ldrb	r3, [r3, #0]
 8016b80:	2b3a      	cmp	r3, #58	@ 0x3a
 8016b82:	d002      	beq.n	8016b8a <DecodeGeneralName+0x146>
                WOLFSSL_MSG("\tAlt Name must be absolute URI");
                WOLFSSL_ERROR_VERBOSE(ASN_ALT_NAME_E);
                return ASN_ALT_NAME_E;
 8016b84:	f06f 03a0 	mvn.w	r3, #160	@ 0xa0
 8016b88:	e020      	b.n	8016bcc <DecodeGeneralName+0x188>
            }
        }
    #endif

        ret = SetDNSEntry(cert->heap, (const char*)(input + idx), len,
 8016b8a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016b8c:	f8d3 0370 	ldr.w	r0, [r3, #880]	@ 0x370
 8016b90:	68fa      	ldr	r2, [r7, #12]
 8016b92:	6a3b      	ldr	r3, [r7, #32]
 8016b94:	18d1      	adds	r1, r2, r3
 8016b96:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016b98:	332c      	adds	r3, #44	@ 0x2c
 8016b9a:	9300      	str	r3, [sp, #0]
 8016b9c:	2306      	movs	r3, #6
 8016b9e:	683a      	ldr	r2, [r7, #0]
 8016ba0:	f7fe fe21 	bl	80157e6 <SetDNSEntry>
 8016ba4:	6278      	str	r0, [r7, #36]	@ 0x24
                ASN_URI_TYPE, &cert->altNames);
        if (ret == 0) {
 8016ba6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016ba8:	2b00      	cmp	r3, #0
 8016baa:	d108      	bne.n	8016bbe <DecodeGeneralName+0x17a>
            idx += (word32)len;
 8016bac:	683b      	ldr	r3, [r7, #0]
 8016bae:	6a3a      	ldr	r2, [r7, #32]
 8016bb0:	4413      	add	r3, r2
 8016bb2:	623b      	str	r3, [r7, #32]
 8016bb4:	e003      	b.n	8016bbe <DecodeGeneralName+0x17a>
    }
#endif
    /* GeneralName choice: dNSName, x400Address, ediPartyName */
    else {
        WOLFSSL_MSG("\tUnsupported name type, skipping");
        idx += (word32)len;
 8016bb6:	683b      	ldr	r3, [r7, #0]
 8016bb8:	6a3a      	ldr	r2, [r7, #32]
 8016bba:	4413      	add	r3, r2
 8016bbc:	623b      	str	r3, [r7, #32]
    }

    if (ret == 0) {
 8016bbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016bc0:	2b00      	cmp	r3, #0
 8016bc2:	d102      	bne.n	8016bca <DecodeGeneralName+0x186>
        /* Return index of next encoded byte. */
        *inOutIdx = idx;
 8016bc4:	68bb      	ldr	r3, [r7, #8]
 8016bc6:	6a3a      	ldr	r2, [r7, #32]
 8016bc8:	601a      	str	r2, [r3, #0]
    }
    return ret;
 8016bca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8016bcc:	4618      	mov	r0, r3
 8016bce:	3728      	adds	r7, #40	@ 0x28
 8016bd0:	46bd      	mov	sp, r7
 8016bd2:	bd80      	pop	{r7, pc}

08016bd4 <DecodeAltNames>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 * @return  MEMORY_E when dynamic memory allocation fails.
 */
static int DecodeAltNames(const byte* input, word32 sz, DecodedCert* cert)
{
 8016bd4:	b580      	push	{r7, lr}
 8016bd6:	b094      	sub	sp, #80	@ 0x50
 8016bd8:	af04      	add	r7, sp, #16
 8016bda:	60f8      	str	r0, [r7, #12]
 8016bdc:	60b9      	str	r1, [r7, #8]
 8016bde:	607a      	str	r2, [r7, #4]
        }
    }

    return 0;
#else
    word32 idx = 0;
 8016be0:	2300      	movs	r3, #0
 8016be2:	637b      	str	r3, [r7, #52]	@ 0x34
    int length = 0;
 8016be4:	2300      	movs	r3, #0
 8016be6:	633b      	str	r3, [r7, #48]	@ 0x30
    int ret = 0;
 8016be8:	2300      	movs	r3, #0
 8016bea:	63fb      	str	r3, [r7, #60]	@ 0x3c
    word32 numNames = 0;
 8016bec:	2300      	movs	r3, #0
 8016bee:	63bb      	str	r3, [r7, #56]	@ 0x38

    WOLFSSL_ENTER("DecodeAltNames");

    /* Get SEQUENCE and expect all data to be accounted for. */
    if (GetASN_Sequence(input, &idx, &length, sz, 1) != 0) {
 8016bf0:	f107 0230 	add.w	r2, r7, #48	@ 0x30
 8016bf4:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8016bf8:	2301      	movs	r3, #1
 8016bfa:	9300      	str	r3, [sp, #0]
 8016bfc:	68bb      	ldr	r3, [r7, #8]
 8016bfe:	68f8      	ldr	r0, [r7, #12]
 8016c00:	f7fd f82b 	bl	8013c5a <GetASN_Sequence>
 8016c04:	4603      	mov	r3, r0
 8016c06:	2b00      	cmp	r3, #0
 8016c08:	d002      	beq.n	8016c10 <DecodeAltNames+0x3c>
        WOLFSSL_MSG("\tBad Sequence");
        ret = ASN_PARSE_E;
 8016c0a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016c0e:	63fb      	str	r3, [r7, #60]	@ 0x3c
    }

    if ((ret == 0) && (length == 0)) {
 8016c10:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016c12:	2b00      	cmp	r3, #0
 8016c14:	d105      	bne.n	8016c22 <DecodeAltNames+0x4e>
 8016c16:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016c18:	2b00      	cmp	r3, #0
 8016c1a:	d102      	bne.n	8016c22 <DecodeAltNames+0x4e>
        /* RFC 5280 4.2.1.6.  Subject Alternative Name
           If the subjectAltName extension is present, the sequence MUST
           contain at least one entry. */
        WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
        ret = ASN_PARSE_E;
 8016c1c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016c20:	63fb      	str	r3, [r7, #60]	@ 0x3c
    }
    if (ret == 0) {
 8016c22:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016c24:	2b00      	cmp	r3, #0
 8016c26:	d147      	bne.n	8016cb8 <DecodeAltNames+0xe4>
    #ifdef OPENSSL_ALL
        cert->extSubjAltNameSrc = input;
        cert->extSubjAltNameSz = sz;
    #endif

        cert->weOwnAltNames = 1;
 8016c28:	687a      	ldr	r2, [r7, #4]
 8016c2a:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8016c2e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8016c32:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4

        if ((word32)length + idx != sz) {
 8016c36:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8016c38:	461a      	mov	r2, r3
 8016c3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016c3c:	4413      	add	r3, r2
 8016c3e:	68ba      	ldr	r2, [r7, #8]
 8016c40:	429a      	cmp	r2, r3
 8016c42:	d039      	beq.n	8016cb8 <DecodeAltNames+0xe4>
            ret = ASN_PARSE_E;
 8016c44:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016c48:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
    }

    while ((ret == 0) && (idx < sz)) {
 8016c4a:	e035      	b.n	8016cb8 <DecodeAltNames+0xe4>
        ASNGetData dataASN[altNameASN_Length];

        numNames++;
 8016c4c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8016c4e:	3301      	adds	r3, #1
 8016c50:	63bb      	str	r3, [r7, #56]	@ 0x38
        if (numNames > WOLFSSL_MAX_ALT_NAMES) {
 8016c52:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8016c54:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8016c58:	d903      	bls.n	8016c62 <DecodeAltNames+0x8e>
            WOLFSSL_MSG("\tToo many subject alternative names");
            ret = ASN_ALT_NAME_E;
 8016c5a:	f06f 03a0 	mvn.w	r3, #160	@ 0xa0
 8016c5e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8016c60:	e031      	b.n	8016cc6 <DecodeAltNames+0xf2>
            break;
        }

        /* Clear dynamic data items. */
        XMEMSET(dataASN, 0, sizeof(dataASN));
 8016c62:	f107 0314 	add.w	r3, r7, #20
 8016c66:	221c      	movs	r2, #28
 8016c68:	2100      	movs	r1, #0
 8016c6a:	4618      	mov	r0, r3
 8016c6c:	f011 fc30 	bl	80284d0 <memset>
        /* Parse GeneralName with the choices supported. */
        GetASN_Choice(&dataASN[ALTNAMEASN_IDX_GN], generalNameChoice);
 8016c70:	230b      	movs	r3, #11
 8016c72:	f887 302c 	strb.w	r3, [r7, #44]	@ 0x2c
 8016c76:	4b16      	ldr	r3, [pc, #88]	@ (8016cd0 <DecodeAltNames+0xfc>)
 8016c78:	61fb      	str	r3, [r7, #28]
        /* Decode a GeneralName choice. */
        ret = GetASN_Items(altNameASN, dataASN, altNameASN_Length, 0, input,
 8016c7a:	f107 0114 	add.w	r1, r7, #20
 8016c7e:	68bb      	ldr	r3, [r7, #8]
 8016c80:	9302      	str	r3, [sp, #8]
 8016c82:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 8016c86:	9301      	str	r3, [sp, #4]
 8016c88:	68fb      	ldr	r3, [r7, #12]
 8016c8a:	9300      	str	r3, [sp, #0]
 8016c8c:	2300      	movs	r3, #0
 8016c8e:	2201      	movs	r2, #1
 8016c90:	4810      	ldr	r0, [pc, #64]	@ (8016cd4 <DecodeAltNames+0x100>)
 8016c92:	f7fc fd3b 	bl	801370c <GetASN_Items>
 8016c96:	63f8      	str	r0, [r7, #60]	@ 0x3c
                           &idx, sz);
        if (ret == 0) {
 8016c98:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016c9a:	2b00      	cmp	r3, #0
 8016c9c:	d10c      	bne.n	8016cb8 <DecodeAltNames+0xe4>
            ret = DecodeGeneralName(input, &idx, dataASN[ALTNAMEASN_IDX_GN].tag,
 8016c9e:	f897 202d 	ldrb.w	r2, [r7, #45]	@ 0x2d
                                  (int)dataASN[ALTNAMEASN_IDX_GN].length, cert);
 8016ca2:	69bb      	ldr	r3, [r7, #24]
            ret = DecodeGeneralName(input, &idx, dataASN[ALTNAMEASN_IDX_GN].tag,
 8016ca4:	4618      	mov	r0, r3
 8016ca6:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 8016caa:	687b      	ldr	r3, [r7, #4]
 8016cac:	9300      	str	r3, [sp, #0]
 8016cae:	4603      	mov	r3, r0
 8016cb0:	68f8      	ldr	r0, [r7, #12]
 8016cb2:	f7ff fec7 	bl	8016a44 <DecodeGeneralName>
 8016cb6:	63f8      	str	r0, [r7, #60]	@ 0x3c
    while ((ret == 0) && (idx < sz)) {
 8016cb8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8016cba:	2b00      	cmp	r3, #0
 8016cbc:	d103      	bne.n	8016cc6 <DecodeAltNames+0xf2>
 8016cbe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016cc0:	68ba      	ldr	r2, [r7, #8]
 8016cc2:	429a      	cmp	r2, r3
 8016cc4:	d8c2      	bhi.n	8016c4c <DecodeAltNames+0x78>
        }
    }

    return ret;
 8016cc6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
#endif
}
 8016cc8:	4618      	mov	r0, r3
 8016cca:	3740      	adds	r7, #64	@ 0x40
 8016ccc:	46bd      	mov	sp, r7
 8016cce:	bd80      	pop	{r7, pc}
 8016cd0:	080337a4 	.word	0x080337a4
 8016cd4:	080337b0 	.word	0x080337b0

08016cd8 <DecodeBasicCaConstraint>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 */
static int DecodeBasicCaConstraint(const byte* input, int sz, DecodedCert* cert)
{
 8016cd8:	b580      	push	{r7, lr}
 8016cda:	b08e      	sub	sp, #56	@ 0x38
 8016cdc:	af04      	add	r7, sp, #16
 8016cde:	60f8      	str	r0, [r7, #12]
 8016ce0:	60b9      	str	r1, [r7, #8]
 8016ce2:	607a      	str	r2, [r7, #4]
    cert->pathLength = (byte)ret;
    cert->pathLengthSet = 1;

    return 0;
#else
    DECL_ASNGETDATA(dataASN, basicConsASN_Length);
 8016ce4:	2300      	movs	r3, #0
 8016ce6:	627b      	str	r3, [r7, #36]	@ 0x24
    int ret = 0;
 8016ce8:	2300      	movs	r3, #0
 8016cea:	623b      	str	r3, [r7, #32]
    word32 idx = 0;
 8016cec:	2300      	movs	r3, #0
 8016cee:	61bb      	str	r3, [r7, #24]
    byte isCA = 0;
 8016cf0:	2300      	movs	r3, #0
 8016cf2:	75fb      	strb	r3, [r7, #23]

    WOLFSSL_ENTER("DecodeBasicCaConstraint");

    CALLOC_ASNGETDATA(dataASN, basicConsASN_Length, ret, cert->heap);
 8016cf4:	6a3b      	ldr	r3, [r7, #32]
 8016cf6:	2b00      	cmp	r3, #0
 8016cf8:	d109      	bne.n	8016d0e <DecodeBasicCaConstraint+0x36>
 8016cfa:	2054      	movs	r0, #84	@ 0x54
 8016cfc:	f007 feca 	bl	801ea94 <wolfSSL_Malloc>
 8016d00:	6278      	str	r0, [r7, #36]	@ 0x24
 8016d02:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d04:	2b00      	cmp	r3, #0
 8016d06:	d102      	bne.n	8016d0e <DecodeBasicCaConstraint+0x36>
 8016d08:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8016d0c:	623b      	str	r3, [r7, #32]
 8016d0e:	6a3b      	ldr	r3, [r7, #32]
 8016d10:	2b00      	cmp	r3, #0
 8016d12:	d104      	bne.n	8016d1e <DecodeBasicCaConstraint+0x46>
 8016d14:	2254      	movs	r2, #84	@ 0x54
 8016d16:	2100      	movs	r1, #0
 8016d18:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8016d1a:	f011 fbd9 	bl	80284d0 <memset>

    if (ret == 0) {
 8016d1e:	6a3b      	ldr	r3, [r7, #32]
 8016d20:	2b00      	cmp	r3, #0
 8016d22:	d120      	bne.n	8016d66 <DecodeBasicCaConstraint+0x8e>
        /* Get the CA boolean and path length when present. */
        GetASN_Boolean(&dataASN[BASICCONSASN_IDX_CA], &isCA);
 8016d24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d26:	331c      	adds	r3, #28
 8016d28:	2200      	movs	r2, #0
 8016d2a:	761a      	strb	r2, [r3, #24]
 8016d2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d2e:	331c      	adds	r3, #28
 8016d30:	f107 0217 	add.w	r2, r7, #23
 8016d34:	609a      	str	r2, [r3, #8]
        GetASN_Int8Bit(&dataASN[BASICCONSASN_IDX_PLEN], &cert->pathLength);
 8016d36:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d38:	3338      	adds	r3, #56	@ 0x38
 8016d3a:	2201      	movs	r2, #1
 8016d3c:	761a      	strb	r2, [r3, #24]
 8016d3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d40:	3338      	adds	r3, #56	@ 0x38
 8016d42:	687a      	ldr	r2, [r7, #4]
 8016d44:	f202 421c 	addw	r2, r2, #1052	@ 0x41c
 8016d48:	609a      	str	r2, [r3, #8]

        ret = GetASN_Items(basicConsASN, dataASN, basicConsASN_Length, 1, input,
 8016d4a:	68bb      	ldr	r3, [r7, #8]
 8016d4c:	9302      	str	r3, [sp, #8]
 8016d4e:	f107 0318 	add.w	r3, r7, #24
 8016d52:	9301      	str	r3, [sp, #4]
 8016d54:	68fb      	ldr	r3, [r7, #12]
 8016d56:	9300      	str	r3, [sp, #0]
 8016d58:	2301      	movs	r3, #1
 8016d5a:	2203      	movs	r2, #3
 8016d5c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8016d5e:	482e      	ldr	r0, [pc, #184]	@ (8016e18 <DecodeBasicCaConstraint+0x140>)
 8016d60:	f7fc fcd4 	bl	801370c <GetASN_Items>
 8016d64:	6238      	str	r0, [r7, #32]
                           &idx, (word32)sz);
    }

    /* Empty SEQUENCE is OK - nothing to store. */
    if ((ret == 0) && (dataASN[BASICCONSASN_IDX_SEQ].length != 0)) {
 8016d66:	6a3b      	ldr	r3, [r7, #32]
 8016d68:	2b00      	cmp	r3, #0
 8016d6a:	d145      	bne.n	8016df8 <DecodeBasicCaConstraint+0x120>
 8016d6c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d6e:	685b      	ldr	r3, [r3, #4]
 8016d70:	2b00      	cmp	r3, #0
 8016d72:	d041      	beq.n	8016df8 <DecodeBasicCaConstraint+0x120>
        /* Bad encoding when CA Boolean is false
         * (default when not present). */
#if !defined(ASN_TEMPLATE_SKIP_ISCA_CHECK) && \
    !defined(WOLFSSL_ALLOW_ENCODING_CA_FALSE)
        if ((dataASN[BASICCONSASN_IDX_CA].length != 0) && (!isCA)) {
 8016d74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016d76:	331c      	adds	r3, #28
 8016d78:	685b      	ldr	r3, [r3, #4]
 8016d7a:	2b00      	cmp	r3, #0
 8016d7c:	d005      	beq.n	8016d8a <DecodeBasicCaConstraint+0xb2>
 8016d7e:	7dfb      	ldrb	r3, [r7, #23]
 8016d80:	2b00      	cmp	r3, #0
 8016d82:	d102      	bne.n	8016d8a <DecodeBasicCaConstraint+0xb2>
            WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
            ret = ASN_PARSE_E;
 8016d84:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016d88:	623b      	str	r3, [r7, #32]
        }
#endif
        /* Path length must be a 7-bit value. */
        if ((ret == 0) && (cert->pathLength >= (1 << 7))) {
 8016d8a:	6a3b      	ldr	r3, [r7, #32]
 8016d8c:	2b00      	cmp	r3, #0
 8016d8e:	d108      	bne.n	8016da2 <DecodeBasicCaConstraint+0xca>
 8016d90:	687b      	ldr	r3, [r7, #4]
 8016d92:	f893 341c 	ldrb.w	r3, [r3, #1052]	@ 0x41c
 8016d96:	b25b      	sxtb	r3, r3
 8016d98:	2b00      	cmp	r3, #0
 8016d9a:	da02      	bge.n	8016da2 <DecodeBasicCaConstraint+0xca>
            WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
            ret = ASN_PARSE_E;
 8016d9c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016da0:	623b      	str	r3, [r7, #32]
        }
        if ((ret == 0) && cert->pathLength > WOLFSSL_MAX_PATH_LEN) {
 8016da2:	6a3b      	ldr	r3, [r7, #32]
 8016da4:	2b00      	cmp	r3, #0
 8016da6:	d108      	bne.n	8016dba <DecodeBasicCaConstraint+0xe2>
 8016da8:	687b      	ldr	r3, [r7, #4]
 8016daa:	f893 341c 	ldrb.w	r3, [r3, #1052]	@ 0x41c
 8016dae:	b25b      	sxtb	r3, r3
 8016db0:	2b00      	cmp	r3, #0
 8016db2:	da02      	bge.n	8016dba <DecodeBasicCaConstraint+0xe2>
            WOLFSSL_ERROR_VERBOSE(ASN_PATHLEN_SIZE_E);
            ret = ASN_PATHLEN_SIZE_E;
 8016db4:	f06f 03ec 	mvn.w	r3, #236	@ 0xec
 8016db8:	623b      	str	r3, [r7, #32]
        }
        /* Store CA boolean and whether a path length was seen. */
        if (ret == 0) {
 8016dba:	6a3b      	ldr	r3, [r7, #32]
 8016dbc:	2b00      	cmp	r3, #0
 8016dbe:	d11b      	bne.n	8016df8 <DecodeBasicCaConstraint+0x120>
            /* isCA in certificate is a 1 bit of a byte. */
            cert->isCA = isCA ? 1 : 0;
 8016dc0:	7dfb      	ldrb	r3, [r7, #23]
 8016dc2:	2b00      	cmp	r3, #0
 8016dc4:	bf14      	ite	ne
 8016dc6:	2301      	movne	r3, #1
 8016dc8:	2300      	moveq	r3, #0
 8016dca:	b2d9      	uxtb	r1, r3
 8016dcc:	687a      	ldr	r2, [r7, #4]
 8016dce:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8016dd2:	f361 1304 	bfi	r3, r1, #4, #1
 8016dd6:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->pathLengthSet = (dataASN[BASICCONSASN_IDX_PLEN].length > 0);
 8016dda:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016ddc:	3338      	adds	r3, #56	@ 0x38
 8016dde:	685b      	ldr	r3, [r3, #4]
 8016de0:	2b00      	cmp	r3, #0
 8016de2:	bf14      	ite	ne
 8016de4:	2301      	movne	r3, #1
 8016de6:	2300      	moveq	r3, #0
 8016de8:	b2d9      	uxtb	r1, r3
 8016dea:	687a      	ldr	r2, [r7, #4]
 8016dec:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8016df0:	f361 1345 	bfi	r3, r1, #5, #1
 8016df4:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
        }
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8016df8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016dfa:	2b00      	cmp	r3, #0
 8016dfc:	d007      	beq.n	8016e0e <DecodeBasicCaConstraint+0x136>
 8016dfe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016e00:	61fb      	str	r3, [r7, #28]
 8016e02:	69fb      	ldr	r3, [r7, #28]
 8016e04:	2b00      	cmp	r3, #0
 8016e06:	d002      	beq.n	8016e0e <DecodeBasicCaConstraint+0x136>
 8016e08:	69f8      	ldr	r0, [r7, #28]
 8016e0a:	f007 fe5f 	bl	801eacc <wolfSSL_Free>
    return ret;
 8016e0e:	6a3b      	ldr	r3, [r7, #32]
#endif
}
 8016e10:	4618      	mov	r0, r3
 8016e12:	3728      	adds	r7, #40	@ 0x28
 8016e14:	46bd      	mov	sp, r7
 8016e16:	bd80      	pop	{r7, pc}
 8016e18:	080337b4 	.word	0x080337b4

08016e1c <DecodePolicyConstraints>:


static int DecodePolicyConstraints(const byte* input, int sz, DecodedCert* cert)
{
 8016e1c:	b580      	push	{r7, lr}
 8016e1e:	b08a      	sub	sp, #40	@ 0x28
 8016e20:	af00      	add	r7, sp, #0
 8016e22:	60f8      	str	r0, [r7, #12]
 8016e24:	60b9      	str	r1, [r7, #8]
 8016e26:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 8016e28:	2300      	movs	r3, #0
 8016e2a:	623b      	str	r3, [r7, #32]
    int length = 0;
 8016e2c:	2300      	movs	r3, #0
 8016e2e:	61fb      	str	r3, [r7, #28]
    int skipLength = 0;
 8016e30:	2300      	movs	r3, #0
 8016e32:	61bb      	str	r3, [r7, #24]
    int ret;
    byte tag;

    WOLFSSL_ENTER("DecodePolicyConstraints");

    if (GetSequence(input, &idx, &length, (word32)sz) < 0) {
 8016e34:	68bb      	ldr	r3, [r7, #8]
 8016e36:	f107 021c 	add.w	r2, r7, #28
 8016e3a:	f107 0120 	add.w	r1, r7, #32
 8016e3e:	68f8      	ldr	r0, [r7, #12]
 8016e40:	f7fd f8a8 	bl	8013f94 <GetSequence>
 8016e44:	4603      	mov	r3, r0
 8016e46:	2b00      	cmp	r3, #0
 8016e48:	da02      	bge.n	8016e50 <DecodePolicyConstraints+0x34>
        WOLFSSL_MSG("\tfail: bad SEQUENCE");
        return ASN_PARSE_E;
 8016e4a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016e4e:	e04f      	b.n	8016ef0 <DecodePolicyConstraints+0xd4>
    }

    if (length == 0)
 8016e50:	69fb      	ldr	r3, [r7, #28]
 8016e52:	2b00      	cmp	r3, #0
 8016e54:	d102      	bne.n	8016e5c <DecodePolicyConstraints+0x40>
        return ASN_PARSE_E;
 8016e56:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016e5a:	e049      	b.n	8016ef0 <DecodePolicyConstraints+0xd4>

    if (GetASNTag(input, &idx, &tag, (word32)sz) < 0) {
 8016e5c:	68bb      	ldr	r3, [r7, #8]
 8016e5e:	f107 0217 	add.w	r2, r7, #23
 8016e62:	f107 0120 	add.w	r1, r7, #32
 8016e66:	68f8      	ldr	r0, [r7, #12]
 8016e68:	f7fc ffdf 	bl	8013e2a <GetASNTag>
 8016e6c:	4603      	mov	r3, r0
 8016e6e:	2b00      	cmp	r3, #0
 8016e70:	da02      	bge.n	8016e78 <DecodePolicyConstraints+0x5c>
        WOLFSSL_MSG("\tfail: bad TAG");
        return ASN_PARSE_E;
 8016e72:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016e76:	e03b      	b.n	8016ef0 <DecodePolicyConstraints+0xd4>
    }

    if (tag == (ASN_CONTEXT_SPECIFIC | 0)) {
 8016e78:	7dfb      	ldrb	r3, [r7, #23]
 8016e7a:	2b80      	cmp	r3, #128	@ 0x80
 8016e7c:	d107      	bne.n	8016e8e <DecodePolicyConstraints+0x72>
        /* requireExplicitPolicy */
        cert->extPolicyConstRxpSet = 1;
 8016e7e:	687a      	ldr	r2, [r7, #4]
 8016e80:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8016e84:	f043 0320 	orr.w	r3, r3, #32
 8016e88:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
 8016e8c:	e00d      	b.n	8016eaa <DecodePolicyConstraints+0x8e>
    }
    else if (tag == (ASN_CONTEXT_SPECIFIC | 1)) {
 8016e8e:	7dfb      	ldrb	r3, [r7, #23]
 8016e90:	2b81      	cmp	r3, #129	@ 0x81
 8016e92:	d107      	bne.n	8016ea4 <DecodePolicyConstraints+0x88>
        /* inhibitPolicyMapping */
        cert->extPolicyConstIpmSet = 1;
 8016e94:	687a      	ldr	r2, [r7, #4]
 8016e96:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8016e9a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8016e9e:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
 8016ea2:	e002      	b.n	8016eaa <DecodePolicyConstraints+0x8e>
    }
    else {
        WOLFSSL_MSG("\tfail: invalid TAG");
        return ASN_PARSE_E;
 8016ea4:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8016ea8:	e022      	b.n	8016ef0 <DecodePolicyConstraints+0xd4>
    }

    ret = GetLength(input, &idx, &skipLength, (word32)sz);
 8016eaa:	68bb      	ldr	r3, [r7, #8]
 8016eac:	f107 0218 	add.w	r2, r7, #24
 8016eb0:	f107 0120 	add.w	r1, r7, #32
 8016eb4:	68f8      	ldr	r0, [r7, #12]
 8016eb6:	f7fc ff20 	bl	8013cfa <GetLength>
 8016eba:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret < 0) {
 8016ebc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016ebe:	2b00      	cmp	r3, #0
 8016ec0:	da01      	bge.n	8016ec6 <DecodePolicyConstraints+0xaa>
        WOLFSSL_MSG("\tfail: invalid length");
        return ret;
 8016ec2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016ec4:	e014      	b.n	8016ef0 <DecodePolicyConstraints+0xd4>
    }
    if (skipLength > 1) {
 8016ec6:	69bb      	ldr	r3, [r7, #24]
 8016ec8:	2b01      	cmp	r3, #1
 8016eca:	dd02      	ble.n	8016ed2 <DecodePolicyConstraints+0xb6>
        WOLFSSL_MSG("\tfail: skip value too big");
        return BUFFER_E;
 8016ecc:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8016ed0:	e00e      	b.n	8016ef0 <DecodePolicyConstraints+0xd4>
    }
    if (idx >= (word32)sz) {
 8016ed2:	6a3a      	ldr	r2, [r7, #32]
 8016ed4:	68bb      	ldr	r3, [r7, #8]
 8016ed6:	429a      	cmp	r2, r3
 8016ed8:	d302      	bcc.n	8016ee0 <DecodePolicyConstraints+0xc4>
        WOLFSSL_MSG("\tfail: no policy const skip to read");
        return BUFFER_E;
 8016eda:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8016ede:	e007      	b.n	8016ef0 <DecodePolicyConstraints+0xd4>
    }
    cert->policyConstSkip = input[idx];
 8016ee0:	6a3b      	ldr	r3, [r7, #32]
 8016ee2:	68fa      	ldr	r2, [r7, #12]
 8016ee4:	4413      	add	r3, r2
 8016ee6:	781a      	ldrb	r2, [r3, #0]
 8016ee8:	687b      	ldr	r3, [r7, #4]
 8016eea:	f883 241e 	strb.w	r2, [r3, #1054]	@ 0x41e

    return 0;
 8016eee:	2300      	movs	r3, #0
}
 8016ef0:	4618      	mov	r0, r3
 8016ef2:	3728      	adds	r7, #40	@ 0x28
 8016ef4:	46bd      	mov	sp, r7
 8016ef6:	bd80      	pop	{r7, pc}

08016ef8 <DecodeCrlDist>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  BUFFER_E when data in buffer is too small.
 */
static int DecodeCrlDist(const byte* input, word32 sz, DecodedCert* cert)
{
 8016ef8:	b580      	push	{r7, lr}
 8016efa:	b08e      	sub	sp, #56	@ 0x38
 8016efc:	af04      	add	r7, sp, #16
 8016efe:	60f8      	str	r0, [r7, #12]
 8016f00:	60b9      	str	r1, [r7, #8]
 8016f02:	607a      	str	r2, [r7, #4]
                   "but we only use the first one.");
    }

    return 0;
#else
    DECL_ASNGETDATA(dataASN, crlDistASN_Length);
 8016f04:	2300      	movs	r3, #0
 8016f06:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 idx = 0;
 8016f08:	2300      	movs	r3, #0
 8016f0a:	61bb      	str	r3, [r7, #24]
    int ret = 0;
 8016f0c:	2300      	movs	r3, #0
 8016f0e:	623b      	str	r3, [r7, #32]
    word16 reason;
#endif

    WOLFSSL_ENTER("DecodeCrlDist");

    CALLOC_ASNGETDATA(dataASN, crlDistASN_Length, ret, cert->heap);
 8016f10:	6a3b      	ldr	r3, [r7, #32]
 8016f12:	2b00      	cmp	r3, #0
 8016f14:	d109      	bne.n	8016f2a <DecodeCrlDist+0x32>
 8016f16:	20e0      	movs	r0, #224	@ 0xe0
 8016f18:	f007 fdbc 	bl	801ea94 <wolfSSL_Malloc>
 8016f1c:	6278      	str	r0, [r7, #36]	@ 0x24
 8016f1e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f20:	2b00      	cmp	r3, #0
 8016f22:	d102      	bne.n	8016f2a <DecodeCrlDist+0x32>
 8016f24:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8016f28:	623b      	str	r3, [r7, #32]
 8016f2a:	6a3b      	ldr	r3, [r7, #32]
 8016f2c:	2b00      	cmp	r3, #0
 8016f2e:	d104      	bne.n	8016f3a <DecodeCrlDist+0x42>
 8016f30:	22e0      	movs	r2, #224	@ 0xe0
 8016f32:	2100      	movs	r1, #0
 8016f34:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8016f36:	f011 facb 	bl	80284d0 <memset>

    cert->extCrlInfoRaw = input;
 8016f3a:	687b      	ldr	r3, [r7, #4]
 8016f3c:	68fa      	ldr	r2, [r7, #12]
 8016f3e:	f8c3 23b4 	str.w	r2, [r3, #948]	@ 0x3b4
    cert->extCrlInfoRawSz = (int)sz;
 8016f42:	68ba      	ldr	r2, [r7, #8]
 8016f44:	687b      	ldr	r3, [r7, #4]
 8016f46:	f8c3 23b8 	str.w	r2, [r3, #952]	@ 0x3b8

    if  (ret == 0) {
 8016f4a:	6a3b      	ldr	r3, [r7, #32]
 8016f4c:	2b00      	cmp	r3, #0
 8016f4e:	d115      	bne.n	8016f7c <DecodeCrlDist+0x84>
        /* Get the GeneralName choice */
        GetASN_Choice(&dataASN[CRLDISTASN_IDX_DP_DISTPOINT_FN_GN], generalNameChoice);
 8016f50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f52:	3370      	adds	r3, #112	@ 0x70
 8016f54:	220b      	movs	r2, #11
 8016f56:	761a      	strb	r2, [r3, #24]
 8016f58:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f5a:	3370      	adds	r3, #112	@ 0x70
 8016f5c:	4a1c      	ldr	r2, [pc, #112]	@ (8016fd0 <DecodeCrlDist+0xd8>)
 8016f5e:	609a      	str	r2, [r3, #8]
        /* Parse CRL distribution point. */
        ret = GetASN_Items(crlDistASN, dataASN, crlDistASN_Length, 0, input,
 8016f60:	68bb      	ldr	r3, [r7, #8]
 8016f62:	9302      	str	r3, [sp, #8]
 8016f64:	f107 0318 	add.w	r3, r7, #24
 8016f68:	9301      	str	r3, [sp, #4]
 8016f6a:	68fb      	ldr	r3, [r7, #12]
 8016f6c:	9300      	str	r3, [sp, #0]
 8016f6e:	2300      	movs	r3, #0
 8016f70:	2208      	movs	r2, #8
 8016f72:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8016f74:	4817      	ldr	r0, [pc, #92]	@ (8016fd4 <DecodeCrlDist+0xdc>)
 8016f76:	f7fc fbc9 	bl	801370c <GetASN_Items>
 8016f7a:	6238      	str	r0, [r7, #32]
                           &idx, sz);
    }
    if (ret == 0) {
 8016f7c:	6a3b      	ldr	r3, [r7, #32]
 8016f7e:	2b00      	cmp	r3, #0
 8016f80:	d113      	bne.n	8016faa <DecodeCrlDist+0xb2>
        /* If the choice was a URI, store it in certificate. */
        if (dataASN[CRLDISTASN_IDX_DP_DISTPOINT_FN_GN].tag == GENERALNAME_URI) {
 8016f82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f84:	3370      	adds	r3, #112	@ 0x70
 8016f86:	7e5b      	ldrb	r3, [r3, #25]
 8016f88:	2b86      	cmp	r3, #134	@ 0x86
 8016f8a:	d10e      	bne.n	8016faa <DecodeCrlDist+0xb2>
            word32 sz32;
            GetASN_GetConstRef(&dataASN[CRLDISTASN_IDX_DP_DISTPOINT_FN_GN],
 8016f8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f8e:	3370      	adds	r3, #112	@ 0x70
 8016f90:	689a      	ldr	r2, [r3, #8]
 8016f92:	687b      	ldr	r3, [r7, #4]
 8016f94:	f8c3 23bc 	str.w	r2, [r3, #956]	@ 0x3bc
 8016f98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016f9a:	3370      	adds	r3, #112	@ 0x70
 8016f9c:	68db      	ldr	r3, [r3, #12]
 8016f9e:	617b      	str	r3, [r7, #20]
                    &cert->extCrlInfo, &sz32);
            cert->extCrlInfoSz = (int)sz32;
 8016fa0:	697b      	ldr	r3, [r7, #20]
 8016fa2:	461a      	mov	r2, r3
 8016fa4:	687b      	ldr	r3, [r7, #4]
 8016fa6:	f8c3 23c0 	str.w	r2, [r3, #960]	@ 0x3c0
        }
    #endif
    }

    /* Only parsing the first one. */
    if (ret == 0 && idx < (word32)sz) {
 8016faa:	6a3b      	ldr	r3, [r7, #32]
 8016fac:	2b00      	cmp	r3, #0
        WOLFSSL_MSG("\tThere are more CRL Distribution Point records, "
                    "but we only use the first one.");
    }
    /* TODO: validate other points. */

    FREE_ASNGETDATA(dataASN, cert->heap);
 8016fae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016fb0:	2b00      	cmp	r3, #0
 8016fb2:	d007      	beq.n	8016fc4 <DecodeCrlDist+0xcc>
 8016fb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016fb6:	61fb      	str	r3, [r7, #28]
 8016fb8:	69fb      	ldr	r3, [r7, #28]
 8016fba:	2b00      	cmp	r3, #0
 8016fbc:	d002      	beq.n	8016fc4 <DecodeCrlDist+0xcc>
 8016fbe:	69f8      	ldr	r0, [r7, #28]
 8016fc0:	f007 fd84 	bl	801eacc <wolfSSL_Free>
    return ret;
 8016fc4:	6a3b      	ldr	r3, [r7, #32]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8016fc6:	4618      	mov	r0, r3
 8016fc8:	3728      	adds	r7, #40	@ 0x28
 8016fca:	46bd      	mov	sp, r7
 8016fcc:	bd80      	pop	{r7, pc}
 8016fce:	bf00      	nop
 8016fd0:	080337a4 	.word	0x080337a4
 8016fd4:	080337c0 	.word	0x080337c0

08016fd8 <DecodeAuthInfo>:
 * @return  BUFFER_E when data in buffer is too small.
 * @return  ASN_OBJECT_ID_E when the expected OBJECT_ID tag is not found.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
static int DecodeAuthInfo(const byte* input, word32 sz, DecodedCert* cert)
{
 8016fd8:	b580      	push	{r7, lr}
 8016fda:	b0a2      	sub	sp, #136	@ 0x88
 8016fdc:	af04      	add	r7, sp, #16
 8016fde:	60f8      	str	r0, [r7, #12]
 8016fe0:	60b9      	str	r1, [r7, #8]
 8016fe2:	607a      	str	r2, [r7, #4]
        idx += (word32)length;
    }

    return 0;
#else
    word32 idx = 0;
 8016fe4:	2300      	movs	r3, #0
 8016fe6:	673b      	str	r3, [r7, #112]	@ 0x70
    int length = 0;
 8016fe8:	2300      	movs	r3, #0
 8016fea:	66fb      	str	r3, [r7, #108]	@ 0x6c
    int ret    = 0;
 8016fec:	2300      	movs	r3, #0
 8016fee:	677b      	str	r3, [r7, #116]	@ 0x74

    WOLFSSL_ENTER("DecodeAuthInfo");

    /* Unwrap the list of AIAs */
    if (GetASN_Sequence(input, &idx, &length, sz, 1) < 0) {
 8016ff0:	f107 026c 	add.w	r2, r7, #108	@ 0x6c
 8016ff4:	f107 0170 	add.w	r1, r7, #112	@ 0x70
 8016ff8:	2301      	movs	r3, #1
 8016ffa:	9300      	str	r3, [sp, #0]
 8016ffc:	68bb      	ldr	r3, [r7, #8]
 8016ffe:	68f8      	ldr	r0, [r7, #12]
 8017000:	f7fc fe2b 	bl	8013c5a <GetASN_Sequence>
 8017004:	4603      	mov	r3, r0
 8017006:	2b00      	cmp	r3, #0
 8017008:	da52      	bge.n	80170b0 <DecodeAuthInfo+0xd8>
        ret = ASN_PARSE_E;
 801700a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801700e:	677b      	str	r3, [r7, #116]	@ 0x74
    }

    while ((ret == 0) && (idx < (word32)sz)) {
 8017010:	e04e      	b.n	80170b0 <DecodeAuthInfo+0xd8>
        ASNGetData dataASN[accessDescASN_Length];

        /* Clear dynamic data and retrieve OID and name. */
        XMEMSET(dataASN, 0, sizeof(dataASN));
 8017012:	f107 0314 	add.w	r3, r7, #20
 8017016:	2254      	movs	r2, #84	@ 0x54
 8017018:	2100      	movs	r1, #0
 801701a:	4618      	mov	r0, r3
 801701c:	f011 fa58 	bl	80284d0 <memset>
        GetASN_OID(&dataASN[ACCESSDESCASN_IDX_METH], oidCertAuthInfoType);
 8017020:	2307      	movs	r3, #7
 8017022:	643b      	str	r3, [r7, #64]	@ 0x40
        GetASN_Choice(&dataASN[ACCESSDESCASN_IDX_LOC], generalNameChoice);
 8017024:	230b      	movs	r3, #11
 8017026:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
 801702a:	4b27      	ldr	r3, [pc, #156]	@ (80170c8 <DecodeAuthInfo+0xf0>)
 801702c:	657b      	str	r3, [r7, #84]	@ 0x54
        /* Parse AccessDescription. */
        ret = GetASN_Items(accessDescASN, dataASN, accessDescASN_Length, 0,
 801702e:	f107 0114 	add.w	r1, r7, #20
 8017032:	68bb      	ldr	r3, [r7, #8]
 8017034:	9302      	str	r3, [sp, #8]
 8017036:	f107 0370 	add.w	r3, r7, #112	@ 0x70
 801703a:	9301      	str	r3, [sp, #4]
 801703c:	68fb      	ldr	r3, [r7, #12]
 801703e:	9300      	str	r3, [sp, #0]
 8017040:	2300      	movs	r3, #0
 8017042:	2203      	movs	r2, #3
 8017044:	4821      	ldr	r0, [pc, #132]	@ (80170cc <DecodeAuthInfo+0xf4>)
 8017046:	f7fc fb61 	bl	801370c <GetASN_Items>
 801704a:	6778      	str	r0, [r7, #116]	@ 0x74
                           input, &idx, sz);
        if (ret == 0) {
 801704c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801704e:	2b00      	cmp	r3, #0
 8017050:	d12e      	bne.n	80170b0 <DecodeAuthInfo+0xd8>
            word32 sz32;

            /* Check we have OCSP and URI. */
            if ((dataASN[ACCESSDESCASN_IDX_METH].data.oid.sum == AIA_OCSP_OID) &&
 8017052:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8017054:	2b74      	cmp	r3, #116	@ 0x74
 8017056:	d114      	bne.n	8017082 <DecodeAuthInfo+0xaa>
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 8017058:	f897 3065 	ldrb.w	r3, [r7, #101]	@ 0x65
            if ((dataASN[ACCESSDESCASN_IDX_METH].data.oid.sum == AIA_OCSP_OID) &&
 801705c:	2b86      	cmp	r3, #134	@ 0x86
 801705e:	d110      	bne.n	8017082 <DecodeAuthInfo+0xaa>
                    (cert->extAuthInfo == NULL)) {
 8017060:	687b      	ldr	r3, [r7, #4]
 8017062:	f8d3 33a4 	ldr.w	r3, [r3, #932]	@ 0x3a4
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 8017066:	2b00      	cmp	r3, #0
 8017068:	d10b      	bne.n	8017082 <DecodeAuthInfo+0xaa>
                /* Store URI for OCSP lookup. */
                GetASN_GetConstRef(&dataASN[ACCESSDESCASN_IDX_LOC],
 801706a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801706c:	687b      	ldr	r3, [r7, #4]
 801706e:	f8c3 23a4 	str.w	r2, [r3, #932]	@ 0x3a4
 8017072:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017074:	66bb      	str	r3, [r7, #104]	@ 0x68
                        &cert->extAuthInfo, &sz32);
                cert->extAuthInfoSz = (int)sz32;
 8017076:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017078:	461a      	mov	r2, r3
 801707a:	687b      	ldr	r3, [r7, #4]
 801707c:	f8c3 23a8 	str.w	r2, [r3, #936]	@ 0x3a8
 8017080:	e016      	b.n	80170b0 <DecodeAuthInfo+0xd8>
            }
        #ifdef WOLFSSL_ASN_CA_ISSUER
            /* Check we have CA Issuer and URI. */
            else if ((dataASN[ACCESSDESCASN_IDX_METH].data.oid.sum ==
 8017082:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8017084:	2b75      	cmp	r3, #117	@ 0x75
 8017086:	d113      	bne.n	80170b0 <DecodeAuthInfo+0xd8>
                        AIA_CA_ISSUER_OID) &&
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 8017088:	f897 3065 	ldrb.w	r3, [r7, #101]	@ 0x65
                        AIA_CA_ISSUER_OID) &&
 801708c:	2b86      	cmp	r3, #134	@ 0x86
 801708e:	d10f      	bne.n	80170b0 <DecodeAuthInfo+0xd8>
                    (cert->extAuthInfoCaIssuer == NULL)) {
 8017090:	687b      	ldr	r3, [r7, #4]
 8017092:	f8d3 33ac 	ldr.w	r3, [r3, #940]	@ 0x3ac
                    (dataASN[ACCESSDESCASN_IDX_LOC].tag == GENERALNAME_URI) &&
 8017096:	2b00      	cmp	r3, #0
 8017098:	d10a      	bne.n	80170b0 <DecodeAuthInfo+0xd8>
                /* Set CaIssuers entry */
                GetASN_GetConstRef(&dataASN[ACCESSDESCASN_IDX_LOC],
 801709a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801709c:	687b      	ldr	r3, [r7, #4]
 801709e:	f8c3 23ac 	str.w	r2, [r3, #940]	@ 0x3ac
 80170a2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80170a4:	66bb      	str	r3, [r7, #104]	@ 0x68
                        &cert->extAuthInfoCaIssuer, &sz32);
                cert->extAuthInfoCaIssuerSz = (int)sz32;
 80170a6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80170a8:	461a      	mov	r2, r3
 80170aa:	687b      	ldr	r3, [r7, #4]
 80170ac:	f8c3 23b0 	str.w	r2, [r3, #944]	@ 0x3b0
    while ((ret == 0) && (idx < (word32)sz)) {
 80170b0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80170b2:	2b00      	cmp	r3, #0
 80170b4:	d103      	bne.n	80170be <DecodeAuthInfo+0xe6>
 80170b6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80170b8:	68ba      	ldr	r2, [r7, #8]
 80170ba:	429a      	cmp	r2, r3
 80170bc:	d8a9      	bhi.n	8017012 <DecodeAuthInfo+0x3a>
        #endif
            /* Otherwise skip. */
        }
    }

    return ret;
 80170be:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
#endif
}
 80170c0:	4618      	mov	r0, r3
 80170c2:	3778      	adds	r7, #120	@ 0x78
 80170c4:	46bd      	mov	sp, r7
 80170c6:	bd80      	pop	{r7, pc}
 80170c8:	080337a4 	.word	0x080337a4
 80170cc:	080337e0 	.word	0x080337e0

080170d0 <DecodeAuthKeyId>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  BUFFER_E when data in buffer is too small.
 */
static int DecodeAuthKeyId(const byte* input, word32 sz, DecodedCert* cert)
{
 80170d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80170d2:	b095      	sub	sp, #84	@ 0x54
 80170d4:	af04      	add	r7, sp, #16
 80170d6:	60f8      	str	r0, [r7, #12]
 80170d8:	60b9      	str	r1, [r7, #8]
 80170da:	607a      	str	r2, [r7, #4]
#endif /* OPENSSL_EXTRA */

    return GetHashId(input + idx, length, cert->extAuthKeyId,
        HashIdAlg(cert->signatureOID));
#else
    DECL_ASNGETDATA(dataASN, authKeyIdASN_Length);
 80170dc:	2300      	movs	r3, #0
 80170de:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ret = 0;
 80170e0:	2300      	movs	r3, #0
 80170e2:	63bb      	str	r3, [r7, #56]	@ 0x38

    WOLFSSL_ENTER("DecodeAuthKeyId");

    CALLOC_ASNGETDATA(dataASN, authKeyIdASN_Length, ret, cert->heap);
 80170e4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80170e6:	2b00      	cmp	r3, #0
 80170e8:	d109      	bne.n	80170fe <DecodeAuthKeyId+0x2e>
 80170ea:	2070      	movs	r0, #112	@ 0x70
 80170ec:	f007 fcd2 	bl	801ea94 <wolfSSL_Malloc>
 80170f0:	63f8      	str	r0, [r7, #60]	@ 0x3c
 80170f2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80170f4:	2b00      	cmp	r3, #0
 80170f6:	d102      	bne.n	80170fe <DecodeAuthKeyId+0x2e>
 80170f8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80170fc:	63bb      	str	r3, [r7, #56]	@ 0x38
 80170fe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017100:	2b00      	cmp	r3, #0
 8017102:	d104      	bne.n	801710e <DecodeAuthKeyId+0x3e>
 8017104:	2270      	movs	r2, #112	@ 0x70
 8017106:	2100      	movs	r1, #0
 8017108:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801710a:	f011 f9e1 	bl	80284d0 <memset>

    if (ret == 0) {
 801710e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017110:	2b00      	cmp	r3, #0
 8017112:	d10f      	bne.n	8017134 <DecodeAuthKeyId+0x64>
        /* Parse an authority key identifier. */
        word32 idx = 0;
 8017114:	2300      	movs	r3, #0
 8017116:	633b      	str	r3, [r7, #48]	@ 0x30
        ret = GetASN_Items(authKeyIdASN, dataASN, authKeyIdASN_Length, 1, input,
 8017118:	68bb      	ldr	r3, [r7, #8]
 801711a:	9302      	str	r3, [sp, #8]
 801711c:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8017120:	9301      	str	r3, [sp, #4]
 8017122:	68fb      	ldr	r3, [r7, #12]
 8017124:	9300      	str	r3, [sp, #0]
 8017126:	2301      	movs	r3, #1
 8017128:	2204      	movs	r2, #4
 801712a:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 801712c:	484d      	ldr	r0, [pc, #308]	@ (8017264 <DecodeAuthKeyId+0x194>)
 801712e:	f7fc faed 	bl	801370c <GetASN_Items>
 8017132:	63b8      	str	r0, [r7, #56]	@ 0x38
                           &idx, sz);
    }
    /* Each field is optional */
    if (ret == 0 && dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data != NULL) {
 8017134:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017136:	2b00      	cmp	r3, #0
 8017138:	d126      	bne.n	8017188 <DecodeAuthKeyId+0xb8>
 801713a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801713c:	331c      	adds	r3, #28
 801713e:	689b      	ldr	r3, [r3, #8]
 8017140:	2b00      	cmp	r3, #0
 8017142:	d021      	beq.n	8017188 <DecodeAuthKeyId+0xb8>
#ifdef OPENSSL_EXTRA
        GetASN_GetConstRef(&dataASN[AUTHKEYIDASN_IDX_KEYID],
 8017144:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017146:	331c      	adds	r3, #28
 8017148:	689a      	ldr	r2, [r3, #8]
 801714a:	687b      	ldr	r3, [r7, #4]
 801714c:	f8c3 2438 	str.w	r2, [r3, #1080]	@ 0x438
 8017150:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017152:	331c      	adds	r3, #28
 8017154:	68da      	ldr	r2, [r3, #12]
 8017156:	687b      	ldr	r3, [r7, #4]
 8017158:	f8c3 2408 	str.w	r2, [r3, #1032]	@ 0x408
                &cert->extAuthKeyIdSrc, &cert->extAuthKeyIdSz);
#endif /* OPENSSL_EXTRA */
        /* Get the hash or hash of the hash if wrong size. */
        ret = GetHashId(dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data,
 801715c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801715e:	331c      	adds	r3, #28
 8017160:	689c      	ldr	r4, [r3, #8]
                    (int)dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.length,
 8017162:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017164:	331c      	adds	r3, #28
 8017166:	68db      	ldr	r3, [r3, #12]
        ret = GetHashId(dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data,
 8017168:	461e      	mov	r6, r3
                    cert->extAuthKeyId, HashIdAlg(cert->signatureOID));
 801716a:	687b      	ldr	r3, [r7, #4]
 801716c:	f503 757a 	add.w	r5, r3, #1000	@ 0x3e8
        ret = GetHashId(dataASN[AUTHKEYIDASN_IDX_KEYID].data.ref.data,
 8017170:	687b      	ldr	r3, [r7, #4]
 8017172:	699b      	ldr	r3, [r3, #24]
 8017174:	4618      	mov	r0, r3
 8017176:	f7fe fabd 	bl	80156f4 <HashIdAlg>
 801717a:	4603      	mov	r3, r0
 801717c:	462a      	mov	r2, r5
 801717e:	4631      	mov	r1, r6
 8017180:	4620      	mov	r0, r4
 8017182:	f7fe faec 	bl	801575e <GetHashId>
 8017186:	63b8      	str	r0, [r7, #56]	@ 0x38
    }
#ifdef WOLFSSL_AKID_NAME
    if (ret == 0 && dataASN[AUTHKEYIDASN_IDX_ISSUER].data.ref.data != NULL) {
 8017188:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801718a:	2b00      	cmp	r3, #0
 801718c:	d130      	bne.n	80171f0 <DecodeAuthKeyId+0x120>
 801718e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017190:	3338      	adds	r3, #56	@ 0x38
 8017192:	689b      	ldr	r3, [r3, #8]
 8017194:	2b00      	cmp	r3, #0
 8017196:	d02b      	beq.n	80171f0 <DecodeAuthKeyId+0x120>
        /* We only support using one (first) name. Parse the name to perform
         * a sanity check. */
        word32 idx = 0;
 8017198:	2300      	movs	r3, #0
 801719a:	62fb      	str	r3, [r7, #44]	@ 0x2c
        ASNGetData nameASN[altNameASN_Length];
        XMEMSET(nameASN, 0, sizeof(nameASN));
 801719c:	f107 0310 	add.w	r3, r7, #16
 80171a0:	221c      	movs	r2, #28
 80171a2:	2100      	movs	r1, #0
 80171a4:	4618      	mov	r0, r3
 80171a6:	f011 f993 	bl	80284d0 <memset>
        /* Parse GeneralName with the choices supported. */
        GetASN_Choice(&nameASN[ALTNAMEASN_IDX_GN], generalNameChoice);
 80171aa:	230b      	movs	r3, #11
 80171ac:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
 80171b0:	4b2d      	ldr	r3, [pc, #180]	@ (8017268 <DecodeAuthKeyId+0x198>)
 80171b2:	61bb      	str	r3, [r7, #24]
        /* Decode a GeneralName choice. */
        ret = GetASN_Items(altNameASN, nameASN, altNameASN_Length, 0,
                dataASN[AUTHKEYIDASN_IDX_ISSUER].data.ref.data, &idx,
 80171b4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80171b6:	3338      	adds	r3, #56	@ 0x38
        ret = GetASN_Items(altNameASN, nameASN, altNameASN_Length, 0,
 80171b8:	689b      	ldr	r3, [r3, #8]
                dataASN[AUTHKEYIDASN_IDX_ISSUER].data.ref.length);
 80171ba:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80171bc:	3238      	adds	r2, #56	@ 0x38
        ret = GetASN_Items(altNameASN, nameASN, altNameASN_Length, 0,
 80171be:	68d2      	ldr	r2, [r2, #12]
 80171c0:	f107 0110 	add.w	r1, r7, #16
 80171c4:	9202      	str	r2, [sp, #8]
 80171c6:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 80171ca:	9201      	str	r2, [sp, #4]
 80171cc:	9300      	str	r3, [sp, #0]
 80171ce:	2300      	movs	r3, #0
 80171d0:	2201      	movs	r2, #1
 80171d2:	4826      	ldr	r0, [pc, #152]	@ (801726c <DecodeAuthKeyId+0x19c>)
 80171d4:	f7fc fa9a 	bl	801370c <GetASN_Items>
 80171d8:	63b8      	str	r0, [r7, #56]	@ 0x38

        if (ret == 0) {
 80171da:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80171dc:	2b00      	cmp	r3, #0
 80171de:	d107      	bne.n	80171f0 <DecodeAuthKeyId+0x120>
            GetASN_GetConstRef(&nameASN[ALTNAMEASN_IDX_GN],
 80171e0:	69ba      	ldr	r2, [r7, #24]
 80171e2:	687b      	ldr	r3, [r7, #4]
 80171e4:	f8c3 240c 	str.w	r2, [r3, #1036]	@ 0x40c
 80171e8:	69fa      	ldr	r2, [r7, #28]
 80171ea:	687b      	ldr	r3, [r7, #4]
 80171ec:	f8c3 2410 	str.w	r2, [r3, #1040]	@ 0x410
                    &cert->extAuthKeyIdIssuer, &cert->extAuthKeyIdIssuerSz);
        }
    }
    if (ret == 0 && dataASN[AUTHKEYIDASN_IDX_SERIAL].data.ref.data != NULL) {
 80171f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80171f2:	2b00      	cmp	r3, #0
 80171f4:	d110      	bne.n	8017218 <DecodeAuthKeyId+0x148>
 80171f6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80171f8:	3354      	adds	r3, #84	@ 0x54
 80171fa:	689b      	ldr	r3, [r3, #8]
 80171fc:	2b00      	cmp	r3, #0
 80171fe:	d00b      	beq.n	8017218 <DecodeAuthKeyId+0x148>
        GetASN_GetConstRef(&dataASN[AUTHKEYIDASN_IDX_SERIAL],
 8017200:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017202:	3354      	adds	r3, #84	@ 0x54
 8017204:	689a      	ldr	r2, [r3, #8]
 8017206:	687b      	ldr	r3, [r7, #4]
 8017208:	f8c3 2414 	str.w	r2, [r3, #1044]	@ 0x414
 801720c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801720e:	3354      	adds	r3, #84	@ 0x54
 8017210:	68da      	ldr	r2, [r3, #12]
 8017212:	687b      	ldr	r3, [r7, #4]
 8017214:	f8c3 2418 	str.w	r2, [r3, #1048]	@ 0x418
                &cert->extAuthKeyIdIssuerSN, &cert->extAuthKeyIdIssuerSNSz);
    }
    if (ret == 0) {
 8017218:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801721a:	2b00      	cmp	r3, #0
 801721c:	d107      	bne.n	801722e <DecodeAuthKeyId+0x15e>
        if ((cert->extAuthKeyIdIssuerSz > 0) ^
 801721e:	687b      	ldr	r3, [r7, #4]
 8017220:	f8d3 3410 	ldr.w	r3, [r3, #1040]	@ 0x410
 8017224:	2b00      	cmp	r3, #0
                (cert->extAuthKeyIdIssuerSNSz > 0)) {
 8017226:	687b      	ldr	r3, [r7, #4]
 8017228:	f8d3 3418 	ldr.w	r3, [r3, #1048]	@ 0x418
        if ((cert->extAuthKeyIdIssuerSz > 0) ^
 801722c:	2b00      	cmp	r3, #0
            WOLFSSL_MSG("authorityCertIssuer and authorityCertSerialNumber MUST"
                       " both be present or both be absent");
        }
    }
#endif /* WOLFSSL_AKID_NAME */
    if (ret == 0) {
 801722e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017230:	2b00      	cmp	r3, #0
 8017232:	d107      	bne.n	8017244 <DecodeAuthKeyId+0x174>
#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_AKID_NAME)
        /* Store the raw authority key id. */
        cert->extRawAuthKeyIdSrc = input;
 8017234:	687b      	ldr	r3, [r7, #4]
 8017236:	68fa      	ldr	r2, [r7, #12]
 8017238:	f8c3 2430 	str.w	r2, [r3, #1072]	@ 0x430
        cert->extRawAuthKeyIdSz = sz;
 801723c:	687b      	ldr	r3, [r7, #4]
 801723e:	68ba      	ldr	r2, [r7, #8]
 8017240:	f8c3 2434 	str.w	r2, [r3, #1076]	@ 0x434
#endif /* OPENSSL_EXTRA */
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8017244:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017246:	2b00      	cmp	r3, #0
 8017248:	d007      	beq.n	801725a <DecodeAuthKeyId+0x18a>
 801724a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801724c:	637b      	str	r3, [r7, #52]	@ 0x34
 801724e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8017250:	2b00      	cmp	r3, #0
 8017252:	d002      	beq.n	801725a <DecodeAuthKeyId+0x18a>
 8017254:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8017256:	f007 fc39 	bl	801eacc <wolfSSL_Free>
    return ret;
 801725a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801725c:	4618      	mov	r0, r3
 801725e:	3744      	adds	r7, #68	@ 0x44
 8017260:	46bd      	mov	sp, r7
 8017262:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017264:	080337ec 	.word	0x080337ec
 8017268:	080337a4 	.word	0x080337a4
 801726c:	080337b0 	.word	0x080337b0

08017270 <DecodeSubjKeyId>:
 * @return  ASN_PARSE_E when the OCTET_STRING tag is not found or length is
 *          invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeSubjKeyId(const byte* input, word32 sz, DecodedCert* cert)
{
 8017270:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017272:	b089      	sub	sp, #36	@ 0x24
 8017274:	af00      	add	r7, sp, #0
 8017276:	60f8      	str	r0, [r7, #12]
 8017278:	60b9      	str	r1, [r7, #8]
 801727a:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 801727c:	2300      	movs	r3, #0
 801727e:	61bb      	str	r3, [r7, #24]
    int length = 0;
 8017280:	2300      	movs	r3, #0
 8017282:	617b      	str	r3, [r7, #20]
    int ret = 0;
 8017284:	2300      	movs	r3, #0
 8017286:	61fb      	str	r3, [r7, #28]

    WOLFSSL_ENTER("DecodeSubjKeyId");

    ret = GetOctetString(input, &idx, &length, sz);
 8017288:	f107 0214 	add.w	r2, r7, #20
 801728c:	f107 0118 	add.w	r1, r7, #24
 8017290:	68bb      	ldr	r3, [r7, #8]
 8017292:	68f8      	ldr	r0, [r7, #12]
 8017294:	f7fc fea8 	bl	8013fe8 <GetOctetString>
 8017298:	61f8      	str	r0, [r7, #28]
    if (ret > 0) {
 801729a:	69fb      	ldr	r3, [r7, #28]
 801729c:	2b00      	cmp	r3, #0
 801729e:	dd1d      	ble.n	80172dc <DecodeSubjKeyId+0x6c>
        cert->extSubjKeyIdSz = (word32)length;
 80172a0:	697b      	ldr	r3, [r7, #20]
 80172a2:	461a      	mov	r2, r3
 80172a4:	687b      	ldr	r3, [r7, #4]
 80172a6:	f8c3 23e4 	str.w	r2, [r3, #996]	@ 0x3e4
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        cert->extSubjKeyIdSrc = &input[idx];
 80172aa:	69bb      	ldr	r3, [r7, #24]
 80172ac:	68fa      	ldr	r2, [r7, #12]
 80172ae:	441a      	add	r2, r3
 80172b0:	687b      	ldr	r3, [r7, #4]
 80172b2:	f8c3 243c 	str.w	r2, [r3, #1084]	@ 0x43c
    #endif /* OPENSSL_EXTRA */

        /* Get the hash or hash of the hash if wrong size. */
        ret = GetHashId(input + idx, length, cert->extSubjKeyId,
 80172b6:	69bb      	ldr	r3, [r7, #24]
 80172b8:	68fa      	ldr	r2, [r7, #12]
 80172ba:	18d4      	adds	r4, r2, r3
 80172bc:	697d      	ldr	r5, [r7, #20]
 80172be:	687b      	ldr	r3, [r7, #4]
 80172c0:	f503 7671 	add.w	r6, r3, #964	@ 0x3c4
 80172c4:	687b      	ldr	r3, [r7, #4]
 80172c6:	699b      	ldr	r3, [r3, #24]
 80172c8:	4618      	mov	r0, r3
 80172ca:	f7fe fa13 	bl	80156f4 <HashIdAlg>
 80172ce:	4603      	mov	r3, r0
 80172d0:	4632      	mov	r2, r6
 80172d2:	4629      	mov	r1, r5
 80172d4:	4620      	mov	r0, r4
 80172d6:	f7fe fa42 	bl	801575e <GetHashId>
 80172da:	61f8      	str	r0, [r7, #28]
            HashIdAlg(cert->signatureOID));
    }

    return ret;
 80172dc:	69fb      	ldr	r3, [r7, #28]
}
 80172de:	4618      	mov	r0, r3
 80172e0:	3724      	adds	r7, #36	@ 0x24
 80172e2:	46bd      	mov	sp, r7
 80172e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080172e8 <DecodeKeyUsage>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeKeyUsage(const byte* input, word32 sz, DecodedCert* cert)
{
 80172e8:	b580      	push	{r7, lr}
 80172ea:	b094      	sub	sp, #80	@ 0x50
 80172ec:	af04      	add	r7, sp, #16
 80172ee:	60f8      	str	r0, [r7, #12]
 80172f0:	60b9      	str	r1, [r7, #8]
 80172f2:	607a      	str	r2, [r7, #4]
        cert->extKeyUsage |= (word16)(input[idx+1] << 8);

    return 0;
#else
    ASNGetData dataASN[keyUsageASN_Length];
    word32 idx = 0;
 80172f4:	2300      	movs	r3, #0
 80172f6:	61fb      	str	r3, [r7, #28]
    byte keyUsage[2];
    word32 keyUsageSz = sizeof(keyUsage);
 80172f8:	2302      	movs	r3, #2
 80172fa:	617b      	str	r3, [r7, #20]
    int ret;
    WOLFSSL_ENTER("DecodeKeyUsage");

    /* Clear dynamic data and set where to store extended key usage. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 80172fc:	f107 0320 	add.w	r3, r7, #32
 8017300:	221c      	movs	r2, #28
 8017302:	2100      	movs	r1, #0
 8017304:	4618      	mov	r0, r3
 8017306:	f011 f8e3 	bl	80284d0 <memset>
    XMEMSET(keyUsage, 0, sizeof(keyUsage));
 801730a:	f107 0318 	add.w	r3, r7, #24
 801730e:	2202      	movs	r2, #2
 8017310:	2100      	movs	r1, #0
 8017312:	4618      	mov	r0, r3
 8017314:	f011 f8dc 	bl	80284d0 <memset>
    GetASN_Buffer(&dataASN[KEYUSAGEASN_IDX_STR], keyUsage, &keyUsageSz);
 8017318:	2305      	movs	r3, #5
 801731a:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
 801731e:	f107 0318 	add.w	r3, r7, #24
 8017322:	62bb      	str	r3, [r7, #40]	@ 0x28
 8017324:	f107 0314 	add.w	r3, r7, #20
 8017328:	62fb      	str	r3, [r7, #44]	@ 0x2c
    /* Parse key usage. */
    ret = GetASN_Items(keyUsageASN, dataASN, keyUsageASN_Length, 0, input,
 801732a:	f107 0120 	add.w	r1, r7, #32
 801732e:	68bb      	ldr	r3, [r7, #8]
 8017330:	9302      	str	r3, [sp, #8]
 8017332:	f107 031c 	add.w	r3, r7, #28
 8017336:	9301      	str	r3, [sp, #4]
 8017338:	68fb      	ldr	r3, [r7, #12]
 801733a:	9300      	str	r3, [sp, #0]
 801733c:	2300      	movs	r3, #0
 801733e:	2201      	movs	r2, #1
 8017340:	480f      	ldr	r0, [pc, #60]	@ (8017380 <DecodeKeyUsage+0x98>)
 8017342:	f7fc f9e3 	bl	801370c <GetASN_Items>
 8017346:	63f8      	str	r0, [r7, #60]	@ 0x3c
                        &idx, sz);
    if (ret == 0) {
 8017348:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801734a:	2b00      	cmp	r3, #0
 801734c:	d112      	bne.n	8017374 <DecodeKeyUsage+0x8c>
        /* Decode the bit string number as LE */
        cert->extKeyUsage = (word16)(keyUsage[0]);
 801734e:	7e3b      	ldrb	r3, [r7, #24]
 8017350:	461a      	mov	r2, r3
 8017352:	687b      	ldr	r3, [r7, #4]
 8017354:	f8a3 2420 	strh.w	r2, [r3, #1056]	@ 0x420
        if (keyUsageSz == 2)
 8017358:	697b      	ldr	r3, [r7, #20]
 801735a:	2b02      	cmp	r3, #2
 801735c:	d10a      	bne.n	8017374 <DecodeKeyUsage+0x8c>
            cert->extKeyUsage |= (word16)(keyUsage[1] << 8);
 801735e:	687b      	ldr	r3, [r7, #4]
 8017360:	f8b3 2420 	ldrh.w	r2, [r3, #1056]	@ 0x420
 8017364:	7e7b      	ldrb	r3, [r7, #25]
 8017366:	021b      	lsls	r3, r3, #8
 8017368:	b29b      	uxth	r3, r3
 801736a:	4313      	orrs	r3, r2
 801736c:	b29a      	uxth	r2, r3
 801736e:	687b      	ldr	r3, [r7, #4]
 8017370:	f8a3 2420 	strh.w	r2, [r3, #1056]	@ 0x420
    }
    return ret;
 8017374:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8017376:	4618      	mov	r0, r3
 8017378:	3740      	adds	r7, #64	@ 0x40
 801737a:	46bd      	mov	sp, r7
 801737c:	bd80      	pop	{r7, pc}
 801737e:	bf00      	nop
 8017380:	080337fc 	.word	0x080337fc

08017384 <DecodeExtKeyUsage>:
 * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
 *          is invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeExtKeyUsage(const byte* input, word32 sz, DecodedCert* cert)
{
 8017384:	b580      	push	{r7, lr}
 8017386:	b092      	sub	sp, #72	@ 0x48
 8017388:	af04      	add	r7, sp, #16
 801738a:	60f8      	str	r0, [r7, #12]
 801738c:	60b9      	str	r1, [r7, #8]
 801738e:	607a      	str	r2, [r7, #4]
    #endif
    }

    return 0;
#else
    word32 idx = 0;
 8017390:	2300      	movs	r3, #0
 8017392:	633b      	str	r3, [r7, #48]	@ 0x30
    int length;
    int ret = 0;
 8017394:	2300      	movs	r3, #0
 8017396:	637b      	str	r3, [r7, #52]	@ 0x34

    WOLFSSL_ENTER("DecodeExtKeyUsage");

    /* Strip SEQUENCE OF and expect to account for all the data. */
    if (GetASN_Sequence(input, &idx, &length, sz, 1) < 0) {
 8017398:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 801739c:	f107 0130 	add.w	r1, r7, #48	@ 0x30
 80173a0:	2301      	movs	r3, #1
 80173a2:	9300      	str	r3, [sp, #0]
 80173a4:	68bb      	ldr	r3, [r7, #8]
 80173a6:	68f8      	ldr	r0, [r7, #12]
 80173a8:	f7fc fc57 	bl	8013c5a <GetASN_Sequence>
 80173ac:	4603      	mov	r3, r0
 80173ae:	2b00      	cmp	r3, #0
 80173b0:	da02      	bge.n	80173b8 <DecodeExtKeyUsage+0x34>
        WOLFSSL_MSG("\tfail: should be a SEQUENCE");
        ret = ASN_PARSE_E;
 80173b2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80173b6:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    if (ret == 0) {
 80173b8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80173ba:	2b00      	cmp	r3, #0
 80173bc:	f040 809b 	bne.w	80174f6 <DecodeExtKeyUsage+0x172>
    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
        /* Keep reference for WOLFSSL_X509. */
        cert->extExtKeyUsageSrc = input + idx;
 80173c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80173c2:	68fa      	ldr	r2, [r7, #12]
 80173c4:	441a      	add	r2, r3
 80173c6:	687b      	ldr	r3, [r7, #4]
 80173c8:	f8c3 2424 	str.w	r2, [r3, #1060]	@ 0x424
        cert->extExtKeyUsageSz = (word32)length;
 80173cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80173ce:	461a      	mov	r2, r3
 80173d0:	687b      	ldr	r3, [r7, #4]
 80173d2:	f8c3 2428 	str.w	r2, [r3, #1064]	@ 0x428
    #endif
    }

    /* Check all OIDs. */
    while ((ret == 0) && (idx < (word32)sz)) {
 80173d6:	e08e      	b.n	80174f6 <DecodeExtKeyUsage+0x172>
        ASNGetData dataASN[keyPurposeIdASN_Length];

        /* Clear dynamic data items and set OID type expected. */
        XMEMSET(dataASN, 0, sizeof(dataASN));
 80173d8:	f107 0310 	add.w	r3, r7, #16
 80173dc:	221c      	movs	r2, #28
 80173de:	2100      	movs	r1, #0
 80173e0:	4618      	mov	r0, r3
 80173e2:	f011 f875 	bl	80284d0 <memset>
        GetASN_OID(&dataASN[KEYPURPOSEIDASN_IDX_OID], oidIgnoreType);
 80173e6:	2315      	movs	r3, #21
 80173e8:	623b      	str	r3, [r7, #32]
        /* Decode KeyPurposeId. */
        ret = GetASN_Items(keyPurposeIdASN, dataASN, keyPurposeIdASN_Length, 0,
 80173ea:	f107 0110 	add.w	r1, r7, #16
 80173ee:	68bb      	ldr	r3, [r7, #8]
 80173f0:	9302      	str	r3, [sp, #8]
 80173f2:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 80173f6:	9301      	str	r3, [sp, #4]
 80173f8:	68fb      	ldr	r3, [r7, #12]
 80173fa:	9300      	str	r3, [sp, #0]
 80173fc:	2300      	movs	r3, #0
 80173fe:	2201      	movs	r2, #1
 8017400:	4843      	ldr	r0, [pc, #268]	@ (8017510 <DecodeExtKeyUsage+0x18c>)
 8017402:	f7fc f983 	bl	801370c <GetASN_Items>
 8017406:	6378      	str	r0, [r7, #52]	@ 0x34
                           input, &idx, sz);
        /* Skip unknown OIDs. */
        if (ret == WC_NO_ERR_TRACE(ASN_UNKNOWN_OID_E)) {
 8017408:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801740a:	f113 0f94 	cmn.w	r3, #148	@ 0x94
 801740e:	d102      	bne.n	8017416 <DecodeExtKeyUsage+0x92>
            ret = 0;
 8017410:	2300      	movs	r3, #0
 8017412:	637b      	str	r3, [r7, #52]	@ 0x34
 8017414:	e06f      	b.n	80174f6 <DecodeExtKeyUsage+0x172>
        }
        else if (ret == 0) {
 8017416:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8017418:	2b00      	cmp	r3, #0
 801741a:	d16c      	bne.n	80174f6 <DecodeExtKeyUsage+0x172>
            /* Store the bit for the OID. */
            switch (dataASN[KEYPURPOSEIDASN_IDX_OID].data.oid.sum) {
 801741c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801741e:	2b4f      	cmp	r3, #79	@ 0x4f
 8017420:	d81a      	bhi.n	8017458 <DecodeExtKeyUsage+0xd4>
 8017422:	2b47      	cmp	r3, #71	@ 0x47
 8017424:	d360      	bcc.n	80174e8 <DecodeExtKeyUsage+0x164>
 8017426:	3b47      	subs	r3, #71	@ 0x47
 8017428:	2b08      	cmp	r3, #8
 801742a:	d85d      	bhi.n	80174e8 <DecodeExtKeyUsage+0x164>
 801742c:	a201      	add	r2, pc, #4	@ (adr r2, 8017434 <DecodeExtKeyUsage+0xb0>)
 801742e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017432:	bf00      	nop
 8017434:	08017471 	.word	0x08017471
 8017438:	08017485 	.word	0x08017485
 801743c:	08017499 	.word	0x08017499
 8017440:	080174ad 	.word	0x080174ad
 8017444:	080174e9 	.word	0x080174e9
 8017448:	080174e9 	.word	0x080174e9
 801744c:	080174e9 	.word	0x080174e9
 8017450:	080174c1 	.word	0x080174c1
 8017454:	080174d5 	.word	0x080174d5
 8017458:	2b97      	cmp	r3, #151	@ 0x97
 801745a:	d145      	bne.n	80174e8 <DecodeExtKeyUsage+0x164>
                case EKU_ANY_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_ANY;
 801745c:	687b      	ldr	r3, [r7, #4]
 801745e:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 8017462:	f043 0301 	orr.w	r3, r3, #1
 8017466:	b2da      	uxtb	r2, r3
 8017468:	687b      	ldr	r3, [r7, #4]
 801746a:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 801746e:	e03b      	b.n	80174e8 <DecodeExtKeyUsage+0x164>
                case EKU_SERVER_AUTH_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_SERVER_AUTH;
 8017470:	687b      	ldr	r3, [r7, #4]
 8017472:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 8017476:	f043 0302 	orr.w	r3, r3, #2
 801747a:	b2da      	uxtb	r2, r3
 801747c:	687b      	ldr	r3, [r7, #4]
 801747e:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 8017482:	e031      	b.n	80174e8 <DecodeExtKeyUsage+0x164>
                case EKU_CLIENT_AUTH_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_CLIENT_AUTH;
 8017484:	687b      	ldr	r3, [r7, #4]
 8017486:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 801748a:	f043 0304 	orr.w	r3, r3, #4
 801748e:	b2da      	uxtb	r2, r3
 8017490:	687b      	ldr	r3, [r7, #4]
 8017492:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 8017496:	e027      	b.n	80174e8 <DecodeExtKeyUsage+0x164>
                case EKU_CODESIGNING_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_CODESIGN;
 8017498:	687b      	ldr	r3, [r7, #4]
 801749a:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 801749e:	f043 0308 	orr.w	r3, r3, #8
 80174a2:	b2da      	uxtb	r2, r3
 80174a4:	687b      	ldr	r3, [r7, #4]
 80174a6:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 80174aa:	e01d      	b.n	80174e8 <DecodeExtKeyUsage+0x164>
                case EKU_EMAILPROTECT_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_EMAILPROT;
 80174ac:	687b      	ldr	r3, [r7, #4]
 80174ae:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 80174b2:	f043 0310 	orr.w	r3, r3, #16
 80174b6:	b2da      	uxtb	r2, r3
 80174b8:	687b      	ldr	r3, [r7, #4]
 80174ba:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 80174be:	e013      	b.n	80174e8 <DecodeExtKeyUsage+0x164>
                case EKU_TIMESTAMP_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_TIMESTAMP;
 80174c0:	687b      	ldr	r3, [r7, #4]
 80174c2:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 80174c6:	f043 0320 	orr.w	r3, r3, #32
 80174ca:	b2da      	uxtb	r2, r3
 80174cc:	687b      	ldr	r3, [r7, #4]
 80174ce:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 80174d2:	e009      	b.n	80174e8 <DecodeExtKeyUsage+0x164>
                case EKU_OCSP_SIGN_OID:
                    cert->extExtKeyUsage |= EXTKEYUSE_OCSP_SIGN;
 80174d4:	687b      	ldr	r3, [r7, #4]
 80174d6:	f893 3422 	ldrb.w	r3, [r3, #1058]	@ 0x422
 80174da:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80174de:	b2da      	uxtb	r2, r3
 80174e0:	687b      	ldr	r3, [r7, #4]
 80174e2:	f883 2422 	strb.w	r2, [r3, #1058]	@ 0x422
                    break;
 80174e6:	bf00      	nop
            }

        #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
            /* Keep count for WOLFSSL_X509. */
            cert->extExtKeyUsageCount++;
 80174e8:	687b      	ldr	r3, [r7, #4]
 80174ea:	f8d3 342c 	ldr.w	r3, [r3, #1068]	@ 0x42c
 80174ee:	1c5a      	adds	r2, r3, #1
 80174f0:	687b      	ldr	r3, [r7, #4]
 80174f2:	f8c3 242c 	str.w	r2, [r3, #1068]	@ 0x42c
    while ((ret == 0) && (idx < (word32)sz)) {
 80174f6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80174f8:	2b00      	cmp	r3, #0
 80174fa:	d104      	bne.n	8017506 <DecodeExtKeyUsage+0x182>
 80174fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80174fe:	68ba      	ldr	r2, [r7, #8]
 8017500:	429a      	cmp	r2, r3
 8017502:	f63f af69 	bhi.w	80173d8 <DecodeExtKeyUsage+0x54>
        #endif
        }
    }

    return ret;
 8017506:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8017508:	4618      	mov	r0, r3
 801750a:	3738      	adds	r7, #56	@ 0x38
 801750c:	46bd      	mov	sp, r7
 801750e:	bd80      	pop	{r7, pc}
 8017510:	08033800 	.word	0x08033800

08017514 <DecodeNsCertType>:

#ifndef IGNORE_NETSCAPE_CERT_TYPE

static int DecodeNsCertType(const byte* input, int sz, DecodedCert* cert)
{
 8017514:	b580      	push	{r7, lr}
 8017516:	b088      	sub	sp, #32
 8017518:	af02      	add	r7, sp, #8
 801751a:	60f8      	str	r0, [r7, #12]
 801751c:	60b9      	str	r1, [r7, #8]
 801751e:	607a      	str	r2, [r7, #4]
    word32 idx = 0;
 8017520:	2300      	movs	r3, #0
 8017522:	617b      	str	r3, [r7, #20]
    int len = 0;
 8017524:	2300      	movs	r3, #0
 8017526:	613b      	str	r3, [r7, #16]

    WOLFSSL_ENTER("DecodeNsCertType");

    if (CheckBitString(input, &idx, &len, (word32)sz, 0, NULL) < 0)
 8017528:	68bb      	ldr	r3, [r7, #8]
 801752a:	f107 0210 	add.w	r2, r7, #16
 801752e:	f107 0114 	add.w	r1, r7, #20
 8017532:	2000      	movs	r0, #0
 8017534:	9001      	str	r0, [sp, #4]
 8017536:	2000      	movs	r0, #0
 8017538:	9000      	str	r0, [sp, #0]
 801753a:	68f8      	ldr	r0, [r7, #12]
 801753c:	f7fc fd68 	bl	8014010 <CheckBitString>
 8017540:	4603      	mov	r3, r0
 8017542:	2b00      	cmp	r3, #0
 8017544:	da02      	bge.n	801754c <DecodeNsCertType+0x38>
        return ASN_PARSE_E;
 8017546:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801754a:	e00e      	b.n	801756a <DecodeNsCertType+0x56>

    /* Don't need to worry about unused bits as CheckBitString makes sure
     * they're zero. */
    if (idx < (word32)sz)
 801754c:	697a      	ldr	r2, [r7, #20]
 801754e:	68bb      	ldr	r3, [r7, #8]
 8017550:	429a      	cmp	r2, r3
 8017552:	d208      	bcs.n	8017566 <DecodeNsCertType+0x52>
        cert->nsCertType = input[idx];
 8017554:	697b      	ldr	r3, [r7, #20]
 8017556:	68fa      	ldr	r2, [r7, #12]
 8017558:	4413      	add	r3, r2
 801755a:	781a      	ldrb	r2, [r3, #0]
 801755c:	687b      	ldr	r3, [r7, #4]
 801755e:	f883 246c 	strb.w	r2, [r3, #1132]	@ 0x46c
    else
        return ASN_PARSE_E;

    return 0;
 8017562:	2300      	movs	r3, #0
 8017564:	e001      	b.n	801756a <DecodeNsCertType+0x56>
        return ASN_PARSE_E;
 8017566:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
}
 801756a:	4618      	mov	r0, r3
 801756c:	3718      	adds	r7, #24
 801756e:	46bd      	mov	sp, r7
 8017570:	bd80      	pop	{r7, pc}

08017572 <DecodeSubtreeGeneralName>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  ASN_PARSE_E when SEQUENCE is not found as expected.
 */
static int DecodeSubtreeGeneralName(const byte* input, word32 sz, byte tag,
                                    Base_entry** head, void* heap)
{
 8017572:	b580      	push	{r7, lr}
 8017574:	b08c      	sub	sp, #48	@ 0x30
 8017576:	af02      	add	r7, sp, #8
 8017578:	60f8      	str	r0, [r7, #12]
 801757a:	60b9      	str	r1, [r7, #8]
 801757c:	603b      	str	r3, [r7, #0]
 801757e:	4613      	mov	r3, r2
 8017580:	71fb      	strb	r3, [r7, #7]
    Base_entry* entry = NULL;
 8017582:	2300      	movs	r3, #0
 8017584:	627b      	str	r3, [r7, #36]	@ 0x24
    word32 nameIdx = 0;
 8017586:	2300      	movs	r3, #0
 8017588:	617b      	str	r3, [r7, #20]
    word32 len = sz;
 801758a:	68bb      	ldr	r3, [r7, #8]
 801758c:	623b      	str	r3, [r7, #32]
    int strLen;
    int ret = 0;
 801758e:	2300      	movs	r3, #0
 8017590:	61fb      	str	r3, [r7, #28]

    (void)heap;

    /* if constructed has leading sequence */
    if ((tag & ASN_CONSTRUCTED) == ASN_CONSTRUCTED) {
 8017592:	79fb      	ldrb	r3, [r7, #7]
 8017594:	f003 0320 	and.w	r3, r3, #32
 8017598:	2b00      	cmp	r3, #0
 801759a:	d015      	beq.n	80175c8 <DecodeSubtreeGeneralName+0x56>
        ret = GetASN_Sequence(input, &nameIdx, &strLen, sz, 0);
 801759c:	f107 0210 	add.w	r2, r7, #16
 80175a0:	f107 0114 	add.w	r1, r7, #20
 80175a4:	2300      	movs	r3, #0
 80175a6:	9300      	str	r3, [sp, #0]
 80175a8:	68bb      	ldr	r3, [r7, #8]
 80175aa:	68f8      	ldr	r0, [r7, #12]
 80175ac:	f7fc fb55 	bl	8013c5a <GetASN_Sequence>
 80175b0:	61f8      	str	r0, [r7, #28]
        if (ret < 0) {
 80175b2:	69fb      	ldr	r3, [r7, #28]
 80175b4:	2b00      	cmp	r3, #0
 80175b6:	da03      	bge.n	80175c0 <DecodeSubtreeGeneralName+0x4e>
            ret = ASN_PARSE_E;
 80175b8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80175bc:	61fb      	str	r3, [r7, #28]
 80175be:	e003      	b.n	80175c8 <DecodeSubtreeGeneralName+0x56>
        }
        else {
            len = (word32)strLen;
 80175c0:	693b      	ldr	r3, [r7, #16]
 80175c2:	623b      	str	r3, [r7, #32]
            ret = 0;
 80175c4:	2300      	movs	r3, #0
 80175c6:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 80175c8:	69fb      	ldr	r3, [r7, #28]
 80175ca:	2b00      	cmp	r3, #0
 80175cc:	d109      	bne.n	80175e2 <DecodeSubtreeGeneralName+0x70>
        /* TODO: consider one malloc. */
        /* Allocate Base Entry object. */
        entry = (Base_entry*)XMALLOC(sizeof(Base_entry), heap,
 80175ce:	2010      	movs	r0, #16
 80175d0:	f007 fa60 	bl	801ea94 <wolfSSL_Malloc>
 80175d4:	6278      	str	r0, [r7, #36]	@ 0x24
                                     DYNAMIC_TYPE_ALTNAME);
        if (entry == NULL) {
 80175d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80175d8:	2b00      	cmp	r3, #0
 80175da:	d102      	bne.n	80175e2 <DecodeSubtreeGeneralName+0x70>
            ret = MEMORY_E;
 80175dc:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80175e0:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 80175e2:	69fb      	ldr	r3, [r7, #28]
 80175e4:	2b00      	cmp	r3, #0
 80175e6:	d116      	bne.n	8017616 <DecodeSubtreeGeneralName+0xa4>
        /* Allocate name. */
        entry->name = (char*)XMALLOC(len + 1, heap, DYNAMIC_TYPE_ALTNAME);
 80175e8:	6a3b      	ldr	r3, [r7, #32]
 80175ea:	3301      	adds	r3, #1
 80175ec:	4618      	mov	r0, r3
 80175ee:	f007 fa51 	bl	801ea94 <wolfSSL_Malloc>
 80175f2:	4602      	mov	r2, r0
 80175f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80175f6:	605a      	str	r2, [r3, #4]
        if (entry->name == NULL) {
 80175f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80175fa:	685b      	ldr	r3, [r3, #4]
 80175fc:	2b00      	cmp	r3, #0
 80175fe:	d10a      	bne.n	8017616 <DecodeSubtreeGeneralName+0xa4>
            XFREE(entry, heap, DYNAMIC_TYPE_ALTNAME);
 8017600:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017602:	61bb      	str	r3, [r7, #24]
 8017604:	69bb      	ldr	r3, [r7, #24]
 8017606:	2b00      	cmp	r3, #0
 8017608:	d002      	beq.n	8017610 <DecodeSubtreeGeneralName+0x9e>
 801760a:	69b8      	ldr	r0, [r7, #24]
 801760c:	f007 fa5e 	bl	801eacc <wolfSSL_Free>
            ret = MEMORY_E;
 8017610:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8017614:	61fb      	str	r3, [r7, #28]
        }
    }
    if (ret == 0) {
 8017616:	69fb      	ldr	r3, [r7, #28]
 8017618:	2b00      	cmp	r3, #0
 801761a:	d11e      	bne.n	801765a <DecodeSubtreeGeneralName+0xe8>
        /* Store name, size and tag in object. */
        XMEMCPY(entry->name, &input[nameIdx], len);
 801761c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801761e:	6858      	ldr	r0, [r3, #4]
 8017620:	697b      	ldr	r3, [r7, #20]
 8017622:	68fa      	ldr	r2, [r7, #12]
 8017624:	4413      	add	r3, r2
 8017626:	6a3a      	ldr	r2, [r7, #32]
 8017628:	4619      	mov	r1, r3
 801762a:	f010 ffbb 	bl	80285a4 <memcpy>
        entry->name[len] = '\0';
 801762e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017630:	685a      	ldr	r2, [r3, #4]
 8017632:	6a3b      	ldr	r3, [r7, #32]
 8017634:	4413      	add	r3, r2
 8017636:	2200      	movs	r2, #0
 8017638:	701a      	strb	r2, [r3, #0]
        entry->nameSz = (int)len;
 801763a:	6a3a      	ldr	r2, [r7, #32]
 801763c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801763e:	609a      	str	r2, [r3, #8]
        entry->type = tag & ASN_TYPE_MASK;
 8017640:	79fb      	ldrb	r3, [r7, #7]
 8017642:	f003 031f 	and.w	r3, r3, #31
 8017646:	b2da      	uxtb	r2, r3
 8017648:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801764a:	731a      	strb	r2, [r3, #12]

        /* Put entry at front of linked list. */
        entry->next = *head;
 801764c:	683b      	ldr	r3, [r7, #0]
 801764e:	681a      	ldr	r2, [r3, #0]
 8017650:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017652:	601a      	str	r2, [r3, #0]
        *head = entry;
 8017654:	683b      	ldr	r3, [r7, #0]
 8017656:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8017658:	601a      	str	r2, [r3, #0]
    }

    return ret;
 801765a:	69fb      	ldr	r3, [r7, #28]
}
 801765c:	4618      	mov	r0, r3
 801765e:	3728      	adds	r7, #40	@ 0x28
 8017660:	46bd      	mov	sp, r7
 8017662:	bd80      	pop	{r7, pc}

08017664 <DecodeSubtree>:
 * @return  MEMORY_E when dynamic memory allocation fails.
 * @return  ASN_PARSE_E when SEQUENCE is not found as expected.
 */
static int DecodeSubtree(const byte* input, word32 sz, Base_entry** head,
                         word32 limit, void* heap)
{
 8017664:	b580      	push	{r7, lr}
 8017666:	b090      	sub	sp, #64	@ 0x40
 8017668:	af04      	add	r7, sp, #16
 801766a:	60f8      	str	r0, [r7, #12]
 801766c:	60b9      	str	r1, [r7, #8]
 801766e:	607a      	str	r2, [r7, #4]
 8017670:	603b      	str	r3, [r7, #0]
        idx += (word32)seqLength;
    }

    return ret;
#else
    DECL_ASNGETDATA(dataASN, subTreeASN_Length);
 8017672:	2300      	movs	r3, #0
 8017674:	62fb      	str	r3, [r7, #44]	@ 0x2c
    word32 idx = 0;
 8017676:	2300      	movs	r3, #0
 8017678:	61bb      	str	r3, [r7, #24]
    int ret = 0;
 801767a:	2300      	movs	r3, #0
 801767c:	62bb      	str	r3, [r7, #40]	@ 0x28
    word32 cnt = 0;
 801767e:	2300      	movs	r3, #0
 8017680:	627b      	str	r3, [r7, #36]	@ 0x24

    (void)heap;

    ALLOC_ASNGETDATA(dataASN, subTreeASN_Length, ret, heap);
 8017682:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017684:	2b00      	cmp	r3, #0
 8017686:	d16b      	bne.n	8017760 <DecodeSubtree+0xfc>
 8017688:	2070      	movs	r0, #112	@ 0x70
 801768a:	f007 fa03 	bl	801ea94 <wolfSSL_Malloc>
 801768e:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8017690:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017692:	2b00      	cmp	r3, #0
 8017694:	d164      	bne.n	8017760 <DecodeSubtree+0xfc>
 8017696:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801769a:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Process all subtrees. */
    while ((ret == 0) && (idx < (word32)sz)) {
 801769c:	e060      	b.n	8017760 <DecodeSubtree+0xfc>
        byte minVal = 0;
 801769e:	2300      	movs	r3, #0
 80176a0:	75fb      	strb	r3, [r7, #23]
        byte maxVal = 0;
 80176a2:	2300      	movs	r3, #0
 80176a4:	75bb      	strb	r3, [r7, #22]
        if (limit > 0) {
 80176a6:	683b      	ldr	r3, [r7, #0]
 80176a8:	2b00      	cmp	r3, #0
 80176aa:	d00a      	beq.n	80176c2 <DecodeSubtree+0x5e>
            cnt++;
 80176ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80176ae:	3301      	adds	r3, #1
 80176b0:	627b      	str	r3, [r7, #36]	@ 0x24
            if (cnt > limit) {
 80176b2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80176b4:	683b      	ldr	r3, [r7, #0]
 80176b6:	429a      	cmp	r2, r3
 80176b8:	d903      	bls.n	80176c2 <DecodeSubtree+0x5e>
                WOLFSSL_MSG("too many name constraints");
                ret = ASN_NAME_INVALID_E;
 80176ba:	f06f 03c5 	mvn.w	r3, #197	@ 0xc5
 80176be:	62bb      	str	r3, [r7, #40]	@ 0x28
 80176c0:	e055      	b.n	801776e <DecodeSubtree+0x10a>
        }

        /* Clear dynamic data and set choice for GeneralName and location to
         * store minimum and maximum.
         */
        XMEMSET(dataASN, 0, sizeof(*dataASN) * subTreeASN_Length);
 80176c2:	2270      	movs	r2, #112	@ 0x70
 80176c4:	2100      	movs	r1, #0
 80176c6:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80176c8:	f010 ff02 	bl	80284d0 <memset>
        GetASN_Choice(&dataASN[SUBTREEASN_IDX_BASE], generalNameChoice);
 80176cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176ce:	331c      	adds	r3, #28
 80176d0:	220b      	movs	r2, #11
 80176d2:	761a      	strb	r2, [r3, #24]
 80176d4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176d6:	331c      	adds	r3, #28
 80176d8:	4a2d      	ldr	r2, [pc, #180]	@ (8017790 <DecodeSubtree+0x12c>)
 80176da:	609a      	str	r2, [r3, #8]
        GetASN_Int8Bit(&dataASN[SUBTREEASN_IDX_MIN], &minVal);
 80176dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176de:	3338      	adds	r3, #56	@ 0x38
 80176e0:	2201      	movs	r2, #1
 80176e2:	761a      	strb	r2, [r3, #24]
 80176e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176e6:	3338      	adds	r3, #56	@ 0x38
 80176e8:	f107 0217 	add.w	r2, r7, #23
 80176ec:	609a      	str	r2, [r3, #8]
        GetASN_Int8Bit(&dataASN[SUBTREEASN_IDX_MAX], &maxVal);
 80176ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176f0:	3354      	adds	r3, #84	@ 0x54
 80176f2:	2201      	movs	r2, #1
 80176f4:	761a      	strb	r2, [r3, #24]
 80176f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80176f8:	3354      	adds	r3, #84	@ 0x54
 80176fa:	f107 0216 	add.w	r2, r7, #22
 80176fe:	609a      	str	r2, [r3, #8]
        /* Parse GeneralSubtree. */
        ret = GetASN_Items(subTreeASN, dataASN, subTreeASN_Length, 0, input,
 8017700:	68bb      	ldr	r3, [r7, #8]
 8017702:	9302      	str	r3, [sp, #8]
 8017704:	f107 0318 	add.w	r3, r7, #24
 8017708:	9301      	str	r3, [sp, #4]
 801770a:	68fb      	ldr	r3, [r7, #12]
 801770c:	9300      	str	r3, [sp, #0]
 801770e:	2300      	movs	r3, #0
 8017710:	2204      	movs	r2, #4
 8017712:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8017714:	481f      	ldr	r0, [pc, #124]	@ (8017794 <DecodeSubtree+0x130>)
 8017716:	f7fb fff9 	bl	801370c <GetASN_Items>
 801771a:	62b8      	str	r0, [r7, #40]	@ 0x28
                           &idx, sz);
        if (ret == 0) {
 801771c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801771e:	2b00      	cmp	r3, #0
 8017720:	d11e      	bne.n	8017760 <DecodeSubtree+0xfc>
            byte t = dataASN[SUBTREEASN_IDX_BASE].tag;
 8017722:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017724:	331c      	adds	r3, #28
 8017726:	7e5b      	ldrb	r3, [r3, #25]
 8017728:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23

            /* Check GeneralName tag is one of the types we can handle. */
            if (t == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE) ||
 801772c:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8017730:	2b82      	cmp	r3, #130	@ 0x82
 8017732:	d007      	beq.n	8017744 <DecodeSubtree+0xe0>
 8017734:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8017738:	2b81      	cmp	r3, #129	@ 0x81
 801773a:	d003      	beq.n	8017744 <DecodeSubtree+0xe0>
                t == (ASN_CONTEXT_SPECIFIC | ASN_RFC822_TYPE) ||
 801773c:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8017740:	2ba4      	cmp	r3, #164	@ 0xa4
 8017742:	d10d      	bne.n	8017760 <DecodeSubtree+0xfc>
                t == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_DIR_TYPE)) {
                /* Parse the general name and store a new entry. */
                ret = DecodeSubtreeGeneralName(input +
                    GetASNItem_DataIdx(dataASN[SUBTREEASN_IDX_BASE], input),
 8017744:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017746:	331c      	adds	r3, #28
                ret = DecodeSubtreeGeneralName(input +
 8017748:	6898      	ldr	r0, [r3, #8]
                    dataASN[SUBTREEASN_IDX_BASE].length, t, head, heap);
 801774a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801774c:	331c      	adds	r3, #28
                ret = DecodeSubtreeGeneralName(input +
 801774e:	6859      	ldr	r1, [r3, #4]
 8017750:	f897 2023 	ldrb.w	r2, [r7, #35]	@ 0x23
 8017754:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017756:	9300      	str	r3, [sp, #0]
 8017758:	687b      	ldr	r3, [r7, #4]
 801775a:	f7ff ff0a 	bl	8017572 <DecodeSubtreeGeneralName>
 801775e:	62b8      	str	r0, [r7, #40]	@ 0x28
    while ((ret == 0) && (idx < (word32)sz)) {
 8017760:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017762:	2b00      	cmp	r3, #0
 8017764:	d103      	bne.n	801776e <DecodeSubtree+0x10a>
 8017766:	69bb      	ldr	r3, [r7, #24]
 8017768:	68ba      	ldr	r2, [r7, #8]
 801776a:	429a      	cmp	r2, r3
 801776c:	d897      	bhi.n	801769e <DecodeSubtree+0x3a>
            }
            /* Skip entry. */
        }
    }

    FREE_ASNGETDATA(dataASN, heap);
 801776e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017770:	2b00      	cmp	r3, #0
 8017772:	d007      	beq.n	8017784 <DecodeSubtree+0x120>
 8017774:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017776:	61fb      	str	r3, [r7, #28]
 8017778:	69fb      	ldr	r3, [r7, #28]
 801777a:	2b00      	cmp	r3, #0
 801777c:	d002      	beq.n	8017784 <DecodeSubtree+0x120>
 801777e:	69f8      	ldr	r0, [r7, #28]
 8017780:	f007 f9a4 	bl	801eacc <wolfSSL_Free>
    return ret;
 8017784:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif
}
 8017786:	4618      	mov	r0, r3
 8017788:	3730      	adds	r7, #48	@ 0x30
 801778a:	46bd      	mov	sp, r7
 801778c:	bd80      	pop	{r7, pc}
 801778e:	bf00      	nop
 8017790:	080337a4 	.word	0x080337a4
 8017794:	08033804 	.word	0x08033804

08017798 <DecodeNameConstraints>:
 *          is invalid.
 * @return  MEMORY_E on dynamic memory allocation failure.
 */
static int DecodeNameConstraints(const byte* input, word32 sz,
    DecodedCert* cert)
{
 8017798:	b580      	push	{r7, lr}
 801779a:	b08c      	sub	sp, #48	@ 0x30
 801779c:	af04      	add	r7, sp, #16
 801779e:	60f8      	str	r0, [r7, #12]
 80177a0:	60b9      	str	r1, [r7, #8]
 80177a2:	607a      	str	r2, [r7, #4]
        idx += (word32)length;
    }

    return 0;
#else
    DECL_ASNGETDATA(dataASN, nameConstraintsASN_Length);
 80177a4:	2300      	movs	r3, #0
 80177a6:	61fb      	str	r3, [r7, #28]
    word32 idx = 0;
 80177a8:	2300      	movs	r3, #0
 80177aa:	613b      	str	r3, [r7, #16]
    int    ret = 0;
 80177ac:	2300      	movs	r3, #0
 80177ae:	61bb      	str	r3, [r7, #24]

    CALLOC_ASNGETDATA(dataASN, nameConstraintsASN_Length, ret, cert->heap);
 80177b0:	69bb      	ldr	r3, [r7, #24]
 80177b2:	2b00      	cmp	r3, #0
 80177b4:	d109      	bne.n	80177ca <DecodeNameConstraints+0x32>
 80177b6:	2054      	movs	r0, #84	@ 0x54
 80177b8:	f007 f96c 	bl	801ea94 <wolfSSL_Malloc>
 80177bc:	61f8      	str	r0, [r7, #28]
 80177be:	69fb      	ldr	r3, [r7, #28]
 80177c0:	2b00      	cmp	r3, #0
 80177c2:	d102      	bne.n	80177ca <DecodeNameConstraints+0x32>
 80177c4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80177c8:	61bb      	str	r3, [r7, #24]
 80177ca:	69bb      	ldr	r3, [r7, #24]
 80177cc:	2b00      	cmp	r3, #0
 80177ce:	d104      	bne.n	80177da <DecodeNameConstraints+0x42>
 80177d0:	2254      	movs	r2, #84	@ 0x54
 80177d2:	2100      	movs	r1, #0
 80177d4:	69f8      	ldr	r0, [r7, #28]
 80177d6:	f010 fe7b 	bl	80284d0 <memset>

    if (ret == 0) {
 80177da:	69bb      	ldr	r3, [r7, #24]
 80177dc:	2b00      	cmp	r3, #0
 80177de:	d10d      	bne.n	80177fc <DecodeNameConstraints+0x64>
        /* Parse NameConstraints. */
        ret = GetASN_Items(nameConstraintsASN, dataASN,
 80177e0:	68bb      	ldr	r3, [r7, #8]
 80177e2:	9302      	str	r3, [sp, #8]
 80177e4:	f107 0310 	add.w	r3, r7, #16
 80177e8:	9301      	str	r3, [sp, #4]
 80177ea:	68fb      	ldr	r3, [r7, #12]
 80177ec:	9300      	str	r3, [sp, #0]
 80177ee:	2301      	movs	r3, #1
 80177f0:	2203      	movs	r2, #3
 80177f2:	69f9      	ldr	r1, [r7, #28]
 80177f4:	4822      	ldr	r0, [pc, #136]	@ (8017880 <DecodeNameConstraints+0xe8>)
 80177f6:	f7fb ff89 	bl	801370c <GetASN_Items>
 80177fa:	61b8      	str	r0, [r7, #24]
                           nameConstraintsASN_Length, 1, input, &idx, sz);
    }
    if (ret == 0) {
 80177fc:	69bb      	ldr	r3, [r7, #24]
 80177fe:	2b00      	cmp	r3, #0
 8017800:	d115      	bne.n	801782e <DecodeNameConstraints+0x96>
        /* If there was a permittedSubtrees then parse it. */
        if (dataASN[NAMECONSTRAINTSASN_IDX_PERMIT].data.ref.data != NULL) {
 8017802:	69fb      	ldr	r3, [r7, #28]
 8017804:	331c      	adds	r3, #28
 8017806:	689b      	ldr	r3, [r3, #8]
 8017808:	2b00      	cmp	r3, #0
 801780a:	d010      	beq.n	801782e <DecodeNameConstraints+0x96>
            ret = DecodeSubtree(
                    dataASN[NAMECONSTRAINTSASN_IDX_PERMIT].data.ref.data,
 801780c:	69fb      	ldr	r3, [r7, #28]
 801780e:	331c      	adds	r3, #28
            ret = DecodeSubtree(
 8017810:	6898      	ldr	r0, [r3, #8]
                    dataASN[NAMECONSTRAINTSASN_IDX_PERMIT].data.ref.length,
 8017812:	69fb      	ldr	r3, [r7, #28]
 8017814:	331c      	adds	r3, #28
            ret = DecodeSubtree(
 8017816:	68d9      	ldr	r1, [r3, #12]
 8017818:	687b      	ldr	r3, [r7, #4]
 801781a:	f103 0238 	add.w	r2, r3, #56	@ 0x38
 801781e:	687b      	ldr	r3, [r7, #4]
 8017820:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8017824:	9300      	str	r3, [sp, #0]
 8017826:	2380      	movs	r3, #128	@ 0x80
 8017828:	f7ff ff1c 	bl	8017664 <DecodeSubtree>
 801782c:	61b8      	str	r0, [r7, #24]
                    &cert->permittedNames, WOLFSSL_MAX_NAME_CONSTRAINTS,
                    cert->heap);
        }
    }
    if (ret == 0) {
 801782e:	69bb      	ldr	r3, [r7, #24]
 8017830:	2b00      	cmp	r3, #0
 8017832:	d115      	bne.n	8017860 <DecodeNameConstraints+0xc8>
        /* If there was a excludedSubtrees then parse it. */
        if (dataASN[NAMECONSTRAINTSASN_IDX_EXCLUDE].data.ref.data != NULL) {
 8017834:	69fb      	ldr	r3, [r7, #28]
 8017836:	3338      	adds	r3, #56	@ 0x38
 8017838:	689b      	ldr	r3, [r3, #8]
 801783a:	2b00      	cmp	r3, #0
 801783c:	d010      	beq.n	8017860 <DecodeNameConstraints+0xc8>
            ret = DecodeSubtree(
                    dataASN[NAMECONSTRAINTSASN_IDX_EXCLUDE].data.ref.data,
 801783e:	69fb      	ldr	r3, [r7, #28]
 8017840:	3338      	adds	r3, #56	@ 0x38
            ret = DecodeSubtree(
 8017842:	6898      	ldr	r0, [r3, #8]
                    dataASN[NAMECONSTRAINTSASN_IDX_EXCLUDE].data.ref.length,
 8017844:	69fb      	ldr	r3, [r7, #28]
 8017846:	3338      	adds	r3, #56	@ 0x38
            ret = DecodeSubtree(
 8017848:	68d9      	ldr	r1, [r3, #12]
 801784a:	687b      	ldr	r3, [r7, #4]
 801784c:	f103 023c 	add.w	r2, r3, #60	@ 0x3c
 8017850:	687b      	ldr	r3, [r7, #4]
 8017852:	f8d3 3370 	ldr.w	r3, [r3, #880]	@ 0x370
 8017856:	9300      	str	r3, [sp, #0]
 8017858:	2380      	movs	r3, #128	@ 0x80
 801785a:	f7ff ff03 	bl	8017664 <DecodeSubtree>
 801785e:	61b8      	str	r0, [r7, #24]
                    &cert->excludedNames, WOLFSSL_MAX_NAME_CONSTRAINTS,
                    cert->heap);
        }
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8017860:	69fb      	ldr	r3, [r7, #28]
 8017862:	2b00      	cmp	r3, #0
 8017864:	d007      	beq.n	8017876 <DecodeNameConstraints+0xde>
 8017866:	69fb      	ldr	r3, [r7, #28]
 8017868:	617b      	str	r3, [r7, #20]
 801786a:	697b      	ldr	r3, [r7, #20]
 801786c:	2b00      	cmp	r3, #0
 801786e:	d002      	beq.n	8017876 <DecodeNameConstraints+0xde>
 8017870:	6978      	ldr	r0, [r7, #20]
 8017872:	f007 f92b 	bl	801eacc <wolfSSL_Free>

    return ret;
 8017876:	69bb      	ldr	r3, [r7, #24]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8017878:	4618      	mov	r0, r3
 801787a:	3720      	adds	r7, #32
 801787c:	46bd      	mov	sp, r7
 801787e:	bd80      	pop	{r7, pc}
 8017880:	08033814 	.word	0x08033814

08017884 <DecodeExtensionType>:
 * @return  Other negative values on error.
 */
static int DecodeExtensionType(const byte* input, word32 length, word32 oid,
                               byte critical, DecodedCert* cert,
                               int *isUnknownExt)
{
 8017884:	b580      	push	{r7, lr}
 8017886:	b086      	sub	sp, #24
 8017888:	af00      	add	r7, sp, #0
 801788a:	60f8      	str	r0, [r7, #12]
 801788c:	60b9      	str	r1, [r7, #8]
 801788e:	607a      	str	r2, [r7, #4]
 8017890:	70fb      	strb	r3, [r7, #3]
    int ret = 0;
 8017892:	2300      	movs	r3, #0
 8017894:	617b      	str	r3, [r7, #20]
    word32 idx = 0;
 8017896:	2300      	movs	r3, #0
 8017898:	613b      	str	r3, [r7, #16]

    if (isUnknownExt != NULL)
 801789a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801789c:	2b00      	cmp	r3, #0
 801789e:	d002      	beq.n	80178a6 <DecodeExtensionType+0x22>
        *isUnknownExt = 0;
 80178a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80178a2:	2200      	movs	r2, #0
 80178a4:	601a      	str	r2, [r3, #0]

    switch (oid) {
 80178a6:	687b      	ldr	r3, [r7, #4]
 80178a8:	f240 22f1 	movw	r2, #753	@ 0x2f1
 80178ac:	4293      	cmp	r3, r2
 80178ae:	f000 8243 	beq.w	8017d38 <DecodeExtensionType+0x4b4>
 80178b2:	687b      	ldr	r3, [r7, #4]
 80178b4:	f240 22f1 	movw	r2, #753	@ 0x2f1
 80178b8:	4293      	cmp	r3, r2
 80178ba:	f200 8278 	bhi.w	8017dae <DecodeExtensionType+0x52a>
 80178be:	687b      	ldr	r3, [r7, #4]
 80178c0:	2b45      	cmp	r3, #69	@ 0x45
 80178c2:	f000 80c2 	beq.w	8017a4a <DecodeExtensionType+0x1c6>
 80178c6:	687b      	ldr	r3, [r7, #4]
 80178c8:	2b45      	cmp	r3, #69	@ 0x45
 80178ca:	f0c0 8270 	bcc.w	8017dae <DecodeExtensionType+0x52a>
 80178ce:	687b      	ldr	r3, [r7, #4]
 80178d0:	2ba8      	cmp	r3, #168	@ 0xa8
 80178d2:	f200 826c 	bhi.w	8017dae <DecodeExtensionType+0x52a>
 80178d6:	687b      	ldr	r3, [r7, #4]
 80178d8:	2b80      	cmp	r3, #128	@ 0x80
 80178da:	f0c0 8268 	bcc.w	8017dae <DecodeExtensionType+0x52a>
 80178de:	687b      	ldr	r3, [r7, #4]
 80178e0:	3b80      	subs	r3, #128	@ 0x80
 80178e2:	2b28      	cmp	r3, #40	@ 0x28
 80178e4:	f200 8263 	bhi.w	8017dae <DecodeExtensionType+0x52a>
 80178e8:	a201      	add	r2, pc, #4	@ (adr r2, 80178f0 <DecodeExtensionType+0x6c>)
 80178ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80178ee:	bf00      	nop
 80178f0:	08017b73 	.word	0x08017b73
 80178f4:	08017bf1 	.word	0x08017bf1
 80178f8:	08017daf 	.word	0x08017daf
 80178fc:	08017ab9 	.word	0x08017ab9
 8017900:	08017daf 	.word	0x08017daf
 8017904:	08017995 	.word	0x08017995
 8017908:	08017daf 	.word	0x08017daf
 801790c:	08017daf 	.word	0x08017daf
 8017910:	08017daf 	.word	0x08017daf
 8017914:	08017daf 	.word	0x08017daf
 8017918:	08017daf 	.word	0x08017daf
 801791c:	08017daf 	.word	0x08017daf
 8017920:	08017daf 	.word	0x08017daf
 8017924:	08017daf 	.word	0x08017daf
 8017928:	08017daf 	.word	0x08017daf
 801792c:	08017daf 	.word	0x08017daf
 8017930:	08017ca5 	.word	0x08017ca5
 8017934:	080179f1 	.word	0x080179f1
 8017938:	08017be1 	.word	0x08017be1
 801793c:	08017daf 	.word	0x08017daf
 8017940:	08017daf 	.word	0x08017daf
 8017944:	08017b05 	.word	0x08017b05
 8017948:	08017d53 	.word	0x08017d53
 801794c:	08017c4b 	.word	0x08017c4b
 8017950:	08017daf 	.word	0x08017daf
 8017954:	08017daf 	.word	0x08017daf
 8017958:	08017daf 	.word	0x08017daf
 801795c:	08017daf 	.word	0x08017daf
 8017960:	08017daf 	.word	0x08017daf
 8017964:	08017daf 	.word	0x08017daf
 8017968:	08017daf 	.word	0x08017daf
 801796c:	08017daf 	.word	0x08017daf
 8017970:	08017daf 	.word	0x08017daf
 8017974:	08017daf 	.word	0x08017daf
 8017978:	08017daf 	.word	0x08017daf
 801797c:	08017daf 	.word	0x08017daf
 8017980:	08017daf 	.word	0x08017daf
 8017984:	08017daf 	.word	0x08017daf
 8017988:	08017daf 	.word	0x08017daf
 801798c:	08017daf 	.word	0x08017daf
 8017990:	08017d13 	.word	0x08017d13
        /* Basic Constraints. */
        case BASIC_CA_OID:
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
 8017994:	6a3b      	ldr	r3, [r7, #32]
 8017996:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 801799a:	f003 0308 	and.w	r3, r3, #8
 801799e:	b2db      	uxtb	r3, r3
 80179a0:	2b00      	cmp	r3, #0
 80179a2:	d11e      	bne.n	80179e2 <DecodeExtensionType+0x15e>
 80179a4:	6a3a      	ldr	r2, [r7, #32]
 80179a6:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 80179aa:	f043 0308 	orr.w	r3, r3, #8
 80179ae:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extBasicConstCrit = critical ? 1 : 0;
 80179b2:	78fb      	ldrb	r3, [r7, #3]
 80179b4:	2b00      	cmp	r3, #0
 80179b6:	bf14      	ite	ne
 80179b8:	2301      	movne	r3, #1
 80179ba:	2300      	moveq	r3, #0
 80179bc:	b2d9      	uxtb	r1, r3
 80179be:	6a3a      	ldr	r2, [r7, #32]
 80179c0:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 80179c4:	f361 1304 	bfi	r3, r1, #4, #1
 80179c8:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            if (DecodeBasicCaConstraint(input, (int)length, cert) < 0) {
 80179cc:	68bb      	ldr	r3, [r7, #8]
 80179ce:	6a3a      	ldr	r2, [r7, #32]
 80179d0:	4619      	mov	r1, r3
 80179d2:	68f8      	ldr	r0, [r7, #12]
 80179d4:	f7ff f980 	bl	8016cd8 <DecodeBasicCaConstraint>
 80179d8:	4603      	mov	r3, r0
 80179da:	2b00      	cmp	r3, #0
 80179dc:	f280 81f4 	bge.w	8017dc8 <DecodeExtensionType+0x544>
 80179e0:	e002      	b.n	80179e8 <DecodeExtensionType+0x164>
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
 80179e2:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 80179e6:	e207      	b.n	8017df8 <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 80179e8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80179ec:	617b      	str	r3, [r7, #20]
            }
            break;
 80179ee:	e1eb      	b.n	8017dc8 <DecodeExtensionType+0x544>

        /* CRL Distribution point. */
        case CRL_DIST_OID:
            VERIFY_AND_SET_OID(cert->extCRLdistSet);
 80179f0:	6a3b      	ldr	r3, [r7, #32]
 80179f2:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 80179f6:	f003 0302 	and.w	r3, r3, #2
 80179fa:	b2db      	uxtb	r3, r3
 80179fc:	2b00      	cmp	r3, #0
 80179fe:	d11d      	bne.n	8017a3c <DecodeExtensionType+0x1b8>
 8017a00:	6a3a      	ldr	r2, [r7, #32]
 8017a02:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017a06:	f043 0302 	orr.w	r3, r3, #2
 8017a0a:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extCRLdistCrit = critical ? 1 : 0;
 8017a0e:	78fb      	ldrb	r3, [r7, #3]
 8017a10:	2b00      	cmp	r3, #0
 8017a12:	bf14      	ite	ne
 8017a14:	2301      	movne	r3, #1
 8017a16:	2300      	moveq	r3, #0
 8017a18:	b2d9      	uxtb	r1, r3
 8017a1a:	6a3a      	ldr	r2, [r7, #32]
 8017a1c:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017a20:	f361 0382 	bfi	r3, r1, #2, #1
 8017a24:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            if (DecodeCrlDist(input, length, cert) < 0) {
 8017a28:	6a3a      	ldr	r2, [r7, #32]
 8017a2a:	68b9      	ldr	r1, [r7, #8]
 8017a2c:	68f8      	ldr	r0, [r7, #12]
 8017a2e:	f7ff fa63 	bl	8016ef8 <DecodeCrlDist>
 8017a32:	4603      	mov	r3, r0
 8017a34:	2b00      	cmp	r3, #0
 8017a36:	f280 81c9 	bge.w	8017dcc <DecodeExtensionType+0x548>
 8017a3a:	e002      	b.n	8017a42 <DecodeExtensionType+0x1be>
            VERIFY_AND_SET_OID(cert->extCRLdistSet);
 8017a3c:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017a40:	e1da      	b.n	8017df8 <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017a42:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017a46:	617b      	str	r3, [r7, #20]
            }
            break;
 8017a48:	e1c0      	b.n	8017dcc <DecodeExtensionType+0x548>

        /* Authority information access. */
        case AUTH_INFO_OID:
            VERIFY_AND_SET_OID(cert->extAuthInfoSet);
 8017a4a:	6a3b      	ldr	r3, [r7, #32]
 8017a4c:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017a50:	f003 0304 	and.w	r3, r3, #4
 8017a54:	b2db      	uxtb	r3, r3
 8017a56:	2b00      	cmp	r3, #0
 8017a58:	d117      	bne.n	8017a8a <DecodeExtensionType+0x206>
 8017a5a:	6a3a      	ldr	r2, [r7, #32]
 8017a5c:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017a60:	f043 0304 	orr.w	r3, r3, #4
 8017a64:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extAuthInfoCrit = critical ? 1 : 0;
 8017a68:	78fb      	ldrb	r3, [r7, #3]
 8017a6a:	2b00      	cmp	r3, #0
 8017a6c:	bf14      	ite	ne
 8017a6e:	2301      	movne	r3, #1
 8017a70:	2300      	moveq	r3, #0
 8017a72:	b2d9      	uxtb	r1, r3
 8017a74:	6a3a      	ldr	r2, [r7, #32]
 8017a76:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017a7a:	f361 03c3 	bfi	r3, r1, #3, #1
 8017a7e:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
        #ifndef WOLFSSL_ALLOW_CRIT_AIA
            /* This check is added due to RFC 5280 section 4.2.2.1
            * stating that conforming CA's must mark this extension
            * as non-critical. When parsing extensions check that
            * certificate was made in compliance with this. */
            if (critical) {
 8017a82:	78fb      	ldrb	r3, [r7, #3]
 8017a84:	2b00      	cmp	r3, #0
 8017a86:	d006      	beq.n	8017a96 <DecodeExtensionType+0x212>
 8017a88:	e002      	b.n	8017a90 <DecodeExtensionType+0x20c>
            VERIFY_AND_SET_OID(cert->extAuthInfoSet);
 8017a8a:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017a8e:	e1b3      	b.n	8017df8 <DecodeExtensionType+0x574>
                WOLFSSL_MSG("Critical Authority Information Access is not"
                            "allowed");
                WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_AIA if wanted");
                ret = ASN_CRIT_EXT_E;
 8017a90:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017a94:	617b      	str	r3, [r7, #20]
            }
        #endif
            if ((ret == 0) && (DecodeAuthInfo(input, length, cert) < 0)) {
 8017a96:	697b      	ldr	r3, [r7, #20]
 8017a98:	2b00      	cmp	r3, #0
 8017a9a:	f040 8199 	bne.w	8017dd0 <DecodeExtensionType+0x54c>
 8017a9e:	6a3a      	ldr	r2, [r7, #32]
 8017aa0:	68b9      	ldr	r1, [r7, #8]
 8017aa2:	68f8      	ldr	r0, [r7, #12]
 8017aa4:	f7ff fa98 	bl	8016fd8 <DecodeAuthInfo>
 8017aa8:	4603      	mov	r3, r0
 8017aaa:	2b00      	cmp	r3, #0
 8017aac:	f280 8190 	bge.w	8017dd0 <DecodeExtensionType+0x54c>
                ret = ASN_PARSE_E;
 8017ab0:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017ab4:	617b      	str	r3, [r7, #20]
            }
            break;
 8017ab6:	e18b      	b.n	8017dd0 <DecodeExtensionType+0x54c>

        /* Subject alternative name. */
        case ALT_NAMES_OID:
            VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
 8017ab8:	6a3b      	ldr	r3, [r7, #32]
 8017aba:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017abe:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8017ac2:	b2db      	uxtb	r3, r3
 8017ac4:	2b00      	cmp	r3, #0
 8017ac6:	d11a      	bne.n	8017afe <DecodeExtensionType+0x27a>
 8017ac8:	6a3a      	ldr	r2, [r7, #32]
 8017aca:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017ace:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8017ad2:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extSubjAltNameCrit = critical ? 1 : 0;
 8017ad6:	78fb      	ldrb	r3, [r7, #3]
 8017ad8:	2b00      	cmp	r3, #0
 8017ada:	bf14      	ite	ne
 8017adc:	2301      	movne	r3, #1
 8017ade:	2300      	moveq	r3, #0
 8017ae0:	b2d9      	uxtb	r1, r3
 8017ae2:	6a3a      	ldr	r2, [r7, #32]
 8017ae4:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017ae8:	f361 1386 	bfi	r3, r1, #6, #1
 8017aec:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            ret = DecodeAltNames(input, length, cert);
 8017af0:	6a3a      	ldr	r2, [r7, #32]
 8017af2:	68b9      	ldr	r1, [r7, #8]
 8017af4:	68f8      	ldr	r0, [r7, #12]
 8017af6:	f7ff f86d 	bl	8016bd4 <DecodeAltNames>
 8017afa:	6178      	str	r0, [r7, #20]
            break;
 8017afc:	e17b      	b.n	8017df6 <DecodeExtensionType+0x572>
            VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
 8017afe:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017b02:	e179      	b.n	8017df8 <DecodeExtensionType+0x574>

        /* Authority Key Identifier. */
        case AUTH_KEY_OID:
            VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
 8017b04:	6a3b      	ldr	r3, [r7, #32]
 8017b06:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017b0a:	f003 0304 	and.w	r3, r3, #4
 8017b0e:	b2db      	uxtb	r3, r3
 8017b10:	2b00      	cmp	r3, #0
 8017b12:	d117      	bne.n	8017b44 <DecodeExtensionType+0x2c0>
 8017b14:	6a3a      	ldr	r2, [r7, #32]
 8017b16:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017b1a:	f043 0304 	orr.w	r3, r3, #4
 8017b1e:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extAuthKeyIdCrit = critical ? 1 : 0;
 8017b22:	78fb      	ldrb	r3, [r7, #3]
 8017b24:	2b00      	cmp	r3, #0
 8017b26:	bf14      	ite	ne
 8017b28:	2301      	movne	r3, #1
 8017b2a:	2300      	moveq	r3, #0
 8017b2c:	b2d9      	uxtb	r1, r3
 8017b2e:	6a3a      	ldr	r2, [r7, #32]
 8017b30:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017b34:	f361 13c7 	bfi	r3, r1, #7, #1
 8017b38:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
        #ifndef WOLFSSL_ALLOW_CRIT_AKID
            /* This check is added due to RFC 5280 section 4.2.1.1
             * stating that conforming CA's must mark this extension
             * as non-critical. When parsing extensions check that
             * certificate was made in compliance with this. */
            if (critical) {
 8017b3c:	78fb      	ldrb	r3, [r7, #3]
 8017b3e:	2b00      	cmp	r3, #0
 8017b40:	d006      	beq.n	8017b50 <DecodeExtensionType+0x2cc>
 8017b42:	e002      	b.n	8017b4a <DecodeExtensionType+0x2c6>
            VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
 8017b44:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017b48:	e156      	b.n	8017df8 <DecodeExtensionType+0x574>
                WOLFSSL_MSG("Critical Auth Key ID is not allowed");
                WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_AKID if wanted");
                ret = ASN_CRIT_EXT_E;
 8017b4a:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017b4e:	617b      	str	r3, [r7, #20]
            }
        #endif
            if ((ret == 0) && (DecodeAuthKeyId(input, length, cert) < 0)) {
 8017b50:	697b      	ldr	r3, [r7, #20]
 8017b52:	2b00      	cmp	r3, #0
 8017b54:	f040 813e 	bne.w	8017dd4 <DecodeExtensionType+0x550>
 8017b58:	6a3a      	ldr	r2, [r7, #32]
 8017b5a:	68b9      	ldr	r1, [r7, #8]
 8017b5c:	68f8      	ldr	r0, [r7, #12]
 8017b5e:	f7ff fab7 	bl	80170d0 <DecodeAuthKeyId>
 8017b62:	4603      	mov	r3, r0
 8017b64:	2b00      	cmp	r3, #0
 8017b66:	f280 8135 	bge.w	8017dd4 <DecodeExtensionType+0x550>
                ret = ASN_PARSE_E;
 8017b6a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017b6e:	617b      	str	r3, [r7, #20]
            }
            break;
 8017b70:	e130      	b.n	8017dd4 <DecodeExtensionType+0x550>

        /* Subject Key Identifier. */
        case SUBJ_KEY_OID:
            VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
 8017b72:	6a3b      	ldr	r3, [r7, #32]
 8017b74:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017b78:	f003 0302 	and.w	r3, r3, #2
 8017b7c:	b2db      	uxtb	r3, r3
 8017b7e:	2b00      	cmp	r3, #0
 8017b80:	d117      	bne.n	8017bb2 <DecodeExtensionType+0x32e>
 8017b82:	6a3a      	ldr	r2, [r7, #32]
 8017b84:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017b88:	f043 0302 	orr.w	r3, r3, #2
 8017b8c:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extSubjKeyIdCrit = critical ? 1 : 0;
 8017b90:	78fb      	ldrb	r3, [r7, #3]
 8017b92:	2b00      	cmp	r3, #0
 8017b94:	bf14      	ite	ne
 8017b96:	2301      	movne	r3, #1
 8017b98:	2300      	moveq	r3, #0
 8017b9a:	b2d9      	uxtb	r1, r3
 8017b9c:	6a3a      	ldr	r2, [r7, #32]
 8017b9e:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017ba2:	f361 0341 	bfi	r3, r1, #1, #1
 8017ba6:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
        #ifndef WOLFSSL_ALLOW_CRIT_SKID
            /* This check is added due to RFC 5280 section 4.2.1.2
             * stating that conforming CA's must mark this extension
             * as non-critical. When parsing extensions check that
             * certificate was made in compliance with this. */
            if (critical) {
 8017baa:	78fb      	ldrb	r3, [r7, #3]
 8017bac:	2b00      	cmp	r3, #0
 8017bae:	d006      	beq.n	8017bbe <DecodeExtensionType+0x33a>
 8017bb0:	e002      	b.n	8017bb8 <DecodeExtensionType+0x334>
            VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
 8017bb2:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017bb6:	e11f      	b.n	8017df8 <DecodeExtensionType+0x574>
                WOLFSSL_MSG("Critical Subject Key ID is not allowed");
                WOLFSSL_MSG("Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted");
                ret = ASN_CRIT_EXT_E;
 8017bb8:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017bbc:	617b      	str	r3, [r7, #20]
            }
        #endif

            if ((ret == 0) && (DecodeSubjKeyId(input, length, cert) < 0)) {
 8017bbe:	697b      	ldr	r3, [r7, #20]
 8017bc0:	2b00      	cmp	r3, #0
 8017bc2:	f040 8109 	bne.w	8017dd8 <DecodeExtensionType+0x554>
 8017bc6:	6a3a      	ldr	r2, [r7, #32]
 8017bc8:	68b9      	ldr	r1, [r7, #8]
 8017bca:	68f8      	ldr	r0, [r7, #12]
 8017bcc:	f7ff fb50 	bl	8017270 <DecodeSubjKeyId>
 8017bd0:	4603      	mov	r3, r0
 8017bd2:	2b00      	cmp	r3, #0
 8017bd4:	f280 8100 	bge.w	8017dd8 <DecodeExtensionType+0x554>
                ret = ASN_PARSE_E;
 8017bd8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017bdc:	617b      	str	r3, [r7, #20]
            }
            break;
 8017bde:	e0fb      	b.n	8017dd8 <DecodeExtensionType+0x554>
                ret = ASN_PARSE_E;
            }
        #else
            WOLFSSL_MSG("Certificate Policy extension not supported.");
            #ifndef WOLFSSL_NO_ASN_STRICT
            if (critical) {
 8017be0:	78fb      	ldrb	r3, [r7, #3]
 8017be2:	2b00      	cmp	r3, #0
 8017be4:	f000 80fa 	beq.w	8017ddc <DecodeExtensionType+0x558>
                WOLFSSL_ERROR_VERBOSE(ASN_CRIT_EXT_E);
                ret = ASN_CRIT_EXT_E;
 8017be8:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017bec:	617b      	str	r3, [r7, #20]
            }
            #endif
        #endif
            break;
 8017bee:	e0f5      	b.n	8017ddc <DecodeExtensionType+0x558>

        /* Key usage. */
        case KEY_USAGE_OID:
            VERIFY_AND_SET_OID(cert->extKeyUsageSet);
 8017bf0:	6a3b      	ldr	r3, [r7, #32]
 8017bf2:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017bf6:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8017bfa:	b2db      	uxtb	r3, r3
 8017bfc:	2b00      	cmp	r3, #0
 8017bfe:	d11d      	bne.n	8017c3c <DecodeExtensionType+0x3b8>
 8017c00:	6a3a      	ldr	r2, [r7, #32]
 8017c02:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017c06:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8017c0a:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extKeyUsageCrit = critical ? 1 : 0;
 8017c0e:	78fb      	ldrb	r3, [r7, #3]
 8017c10:	2b00      	cmp	r3, #0
 8017c12:	bf14      	ite	ne
 8017c14:	2301      	movne	r3, #1
 8017c16:	2300      	moveq	r3, #0
 8017c18:	b2d9      	uxtb	r1, r3
 8017c1a:	6a3a      	ldr	r2, [r7, #32]
 8017c1c:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017c20:	f361 0382 	bfi	r3, r1, #2, #1
 8017c24:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
            if (DecodeKeyUsage(input, length, cert) < 0) {
 8017c28:	6a3a      	ldr	r2, [r7, #32]
 8017c2a:	68b9      	ldr	r1, [r7, #8]
 8017c2c:	68f8      	ldr	r0, [r7, #12]
 8017c2e:	f7ff fb5b 	bl	80172e8 <DecodeKeyUsage>
 8017c32:	4603      	mov	r3, r0
 8017c34:	2b00      	cmp	r3, #0
 8017c36:	f280 80d3 	bge.w	8017de0 <DecodeExtensionType+0x55c>
 8017c3a:	e002      	b.n	8017c42 <DecodeExtensionType+0x3be>
            VERIFY_AND_SET_OID(cert->extKeyUsageSet);
 8017c3c:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017c40:	e0da      	b.n	8017df8 <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017c42:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017c46:	617b      	str	r3, [r7, #20]
            }
            break;
 8017c48:	e0ca      	b.n	8017de0 <DecodeExtensionType+0x55c>

        /* Extended key usage. */
        case EXT_KEY_USAGE_OID:
            VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
 8017c4a:	6a3b      	ldr	r3, [r7, #32]
 8017c4c:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017c50:	f003 0301 	and.w	r3, r3, #1
 8017c54:	b2db      	uxtb	r3, r3
 8017c56:	2b00      	cmp	r3, #0
 8017c58:	d11d      	bne.n	8017c96 <DecodeExtensionType+0x412>
 8017c5a:	6a3a      	ldr	r2, [r7, #32]
 8017c5c:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017c60:	f043 0301 	orr.w	r3, r3, #1
 8017c64:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extExtKeyUsageCrit = critical ? 1 : 0;
 8017c68:	78fb      	ldrb	r3, [r7, #3]
 8017c6a:	2b00      	cmp	r3, #0
 8017c6c:	bf14      	ite	ne
 8017c6e:	2301      	movne	r3, #1
 8017c70:	2300      	moveq	r3, #0
 8017c72:	b2d9      	uxtb	r1, r3
 8017c74:	6a3a      	ldr	r2, [r7, #32]
 8017c76:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017c7a:	f361 03c3 	bfi	r3, r1, #3, #1
 8017c7e:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
            if (DecodeExtKeyUsage(input, length, cert) < 0) {
 8017c82:	6a3a      	ldr	r2, [r7, #32]
 8017c84:	68b9      	ldr	r1, [r7, #8]
 8017c86:	68f8      	ldr	r0, [r7, #12]
 8017c88:	f7ff fb7c 	bl	8017384 <DecodeExtKeyUsage>
 8017c8c:	4603      	mov	r3, r0
 8017c8e:	2b00      	cmp	r3, #0
 8017c90:	f280 80a8 	bge.w	8017de4 <DecodeExtensionType+0x560>
 8017c94:	e002      	b.n	8017c9c <DecodeExtensionType+0x418>
            VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
 8017c96:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017c9a:	e0ad      	b.n	8017df8 <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017c9c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017ca0:	617b      	str	r3, [r7, #20]
            }
            break;
 8017ca2:	e09f      	b.n	8017de4 <DecodeExtensionType+0x560>
        case NAME_CONS_OID:
        #ifndef WOLFSSL_NO_ASN_STRICT
            /* Verify RFC 5280 Sec 4.2.1.10 rule:
                "The name constraints extension,
                which MUST be used only in a CA certificate" */
            if (!cert->isCA) {
 8017ca4:	6a3b      	ldr	r3, [r7, #32]
 8017ca6:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017caa:	f003 0310 	and.w	r3, r3, #16
 8017cae:	b2db      	uxtb	r3, r3
 8017cb0:	2b00      	cmp	r3, #0
 8017cb2:	d102      	bne.n	8017cba <DecodeExtensionType+0x436>
                WOLFSSL_MSG("Name constraints allowed only for CA certs");
                WOLFSSL_ERROR_VERBOSE(ASN_NAME_INVALID_E);
                ret = ASN_NAME_INVALID_E;
 8017cb4:	f06f 03c5 	mvn.w	r3, #197	@ 0xc5
 8017cb8:	617b      	str	r3, [r7, #20]
            }
        #endif
            VERIFY_AND_SET_OID(cert->extNameConstraintSet);
 8017cba:	6a3b      	ldr	r3, [r7, #32]
 8017cbc:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8017cc0:	f003 0308 	and.w	r3, r3, #8
 8017cc4:	b2db      	uxtb	r3, r3
 8017cc6:	2b00      	cmp	r3, #0
 8017cc8:	d11c      	bne.n	8017d04 <DecodeExtensionType+0x480>
 8017cca:	6a3a      	ldr	r2, [r7, #32]
 8017ccc:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8017cd0:	f043 0308 	orr.w	r3, r3, #8
 8017cd4:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
            cert->extNameConstraintCrit = critical ? 1 : 0;
 8017cd8:	78fb      	ldrb	r3, [r7, #3]
 8017cda:	2b00      	cmp	r3, #0
 8017cdc:	bf14      	ite	ne
 8017cde:	2301      	movne	r3, #1
 8017ce0:	2300      	moveq	r3, #0
 8017ce2:	b2d9      	uxtb	r1, r3
 8017ce4:	6a3a      	ldr	r2, [r7, #32]
 8017ce6:	f892 34b7 	ldrb.w	r3, [r2, #1207]	@ 0x4b7
 8017cea:	f361 0300 	bfi	r3, r1, #0, #1
 8017cee:	f882 34b7 	strb.w	r3, [r2, #1207]	@ 0x4b7
            if (DecodeNameConstraints(input, length, cert) < 0) {
 8017cf2:	6a3a      	ldr	r2, [r7, #32]
 8017cf4:	68b9      	ldr	r1, [r7, #8]
 8017cf6:	68f8      	ldr	r0, [r7, #12]
 8017cf8:	f7ff fd4e 	bl	8017798 <DecodeNameConstraints>
 8017cfc:	4603      	mov	r3, r0
 8017cfe:	2b00      	cmp	r3, #0
 8017d00:	da72      	bge.n	8017de8 <DecodeExtensionType+0x564>
 8017d02:	e002      	b.n	8017d0a <DecodeExtensionType+0x486>
            VERIFY_AND_SET_OID(cert->extNameConstraintSet);
 8017d04:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017d08:	e076      	b.n	8017df8 <DecodeExtensionType+0x574>
                ret = ASN_PARSE_E;
 8017d0a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017d0e:	617b      	str	r3, [r7, #20]
            }
            break;
 8017d10:	e06a      	b.n	8017de8 <DecodeExtensionType+0x564>
        #endif /* IGNORE_NAME_CONSTRAINTS */

        /* Inhibit anyPolicy. */
        case INHIBIT_ANY_OID:
            VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
 8017d12:	6a3b      	ldr	r3, [r7, #32]
 8017d14:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 8017d18:	f003 0301 	and.w	r3, r3, #1
 8017d1c:	b2db      	uxtb	r3, r3
 8017d1e:	2b00      	cmp	r3, #0
 8017d20:	d107      	bne.n	8017d32 <DecodeExtensionType+0x4ae>
 8017d22:	6a3a      	ldr	r2, [r7, #32]
 8017d24:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017d28:	f043 0301 	orr.w	r3, r3, #1
 8017d2c:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            WOLFSSL_MSG("Inhibit anyPolicy extension not supported yet.");
            break;
 8017d30:	e061      	b.n	8017df6 <DecodeExtensionType+0x572>
            VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
 8017d32:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017d36:	e05f      	b.n	8017df8 <DecodeExtensionType+0x574>

   #ifndef IGNORE_NETSCAPE_CERT_TYPE
        /* Netscape's certificate type. */
        case NETSCAPE_CT_OID:
            if (DecodeNsCertType(input, (int)length, cert) < 0)
 8017d38:	68bb      	ldr	r3, [r7, #8]
 8017d3a:	6a3a      	ldr	r2, [r7, #32]
 8017d3c:	4619      	mov	r1, r3
 8017d3e:	68f8      	ldr	r0, [r7, #12]
 8017d40:	f7ff fbe8 	bl	8017514 <DecodeNsCertType>
 8017d44:	4603      	mov	r3, r0
 8017d46:	2b00      	cmp	r3, #0
 8017d48:	da50      	bge.n	8017dec <DecodeExtensionType+0x568>
                ret = ASN_PARSE_E;
 8017d4a:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017d4e:	617b      	str	r3, [r7, #20]
            break;
 8017d50:	e04c      	b.n	8017dec <DecodeExtensionType+0x568>
                ret = ASN_PARSE_E;
            }
            break;
    #endif
        case POLICY_CONST_OID:
            VERIFY_AND_SET_OID(cert->extPolicyConstSet);
 8017d52:	6a3b      	ldr	r3, [r7, #32]
 8017d54:	f893 34b5 	ldrb.w	r3, [r3, #1205]	@ 0x4b5
 8017d58:	f003 0310 	and.w	r3, r3, #16
 8017d5c:	b2db      	uxtb	r3, r3
 8017d5e:	2b00      	cmp	r3, #0
 8017d60:	d11f      	bne.n	8017da2 <DecodeExtensionType+0x51e>
 8017d62:	6a3a      	ldr	r2, [r7, #32]
 8017d64:	f892 34b5 	ldrb.w	r3, [r2, #1205]	@ 0x4b5
 8017d68:	f043 0310 	orr.w	r3, r3, #16
 8017d6c:	f882 34b5 	strb.w	r3, [r2, #1205]	@ 0x4b5
            cert->extPolicyConstCrit = critical ? 1 : 0;
 8017d70:	78fb      	ldrb	r3, [r7, #3]
 8017d72:	2b00      	cmp	r3, #0
 8017d74:	bf14      	ite	ne
 8017d76:	2301      	movne	r3, #1
 8017d78:	2300      	moveq	r3, #0
 8017d7a:	b2d9      	uxtb	r1, r3
 8017d7c:	6a3a      	ldr	r2, [r7, #32]
 8017d7e:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 8017d82:	f361 1345 	bfi	r3, r1, #5, #1
 8017d86:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
            if (DecodePolicyConstraints(&input[idx], (int)length, cert) < 0)
 8017d8a:	68fa      	ldr	r2, [r7, #12]
 8017d8c:	693b      	ldr	r3, [r7, #16]
 8017d8e:	4413      	add	r3, r2
 8017d90:	68b9      	ldr	r1, [r7, #8]
 8017d92:	6a3a      	ldr	r2, [r7, #32]
 8017d94:	4618      	mov	r0, r3
 8017d96:	f7ff f841 	bl	8016e1c <DecodePolicyConstraints>
 8017d9a:	4603      	mov	r3, r0
 8017d9c:	2b00      	cmp	r3, #0
 8017d9e:	da27      	bge.n	8017df0 <DecodeExtensionType+0x56c>
 8017da0:	e002      	b.n	8017da8 <DecodeExtensionType+0x524>
            VERIFY_AND_SET_OID(cert->extPolicyConstSet);
 8017da2:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 8017da6:	e027      	b.n	8017df8 <DecodeExtensionType+0x574>
                return ASN_PARSE_E;
 8017da8:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8017dac:	e024      	b.n	8017df8 <DecodeExtensionType+0x574>
            if (DecodeAltSigVal(&input[idx], length, cert) < 0)
                return ASN_PARSE_E;
            break;
    #endif /* WOLFSSL_DUAL_ALG_CERTS */
        default:
            if (isUnknownExt != NULL)
 8017dae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017db0:	2b00      	cmp	r3, #0
 8017db2:	d002      	beq.n	8017dba <DecodeExtensionType+0x536>
                *isUnknownExt = 1;
 8017db4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017db6:	2201      	movs	r2, #1
 8017db8:	601a      	str	r2, [r3, #0]
        #ifndef WOLFSSL_NO_ASN_STRICT
            /* While it is a failure to not support critical extensions,
             * still parse the certificate ignoring the unsupported
             * extension to allow caller to accept it with the verify
             * callback. */
            if (critical) {
 8017dba:	78fb      	ldrb	r3, [r7, #3]
 8017dbc:	2b00      	cmp	r3, #0
 8017dbe:	d019      	beq.n	8017df4 <DecodeExtensionType+0x570>
                WOLFSSL_ERROR_VERBOSE(ASN_CRIT_EXT_E);
                ret = ASN_CRIT_EXT_E;
 8017dc0:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017dc4:	617b      	str	r3, [r7, #20]
            }
        #endif
            break;
 8017dc6:	e015      	b.n	8017df4 <DecodeExtensionType+0x570>
            break;
 8017dc8:	bf00      	nop
 8017dca:	e014      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017dcc:	bf00      	nop
 8017dce:	e012      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017dd0:	bf00      	nop
 8017dd2:	e010      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017dd4:	bf00      	nop
 8017dd6:	e00e      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017dd8:	bf00      	nop
 8017dda:	e00c      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017ddc:	bf00      	nop
 8017dde:	e00a      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017de0:	bf00      	nop
 8017de2:	e008      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017de4:	bf00      	nop
 8017de6:	e006      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017de8:	bf00      	nop
 8017dea:	e004      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017dec:	bf00      	nop
 8017dee:	e002      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017df0:	bf00      	nop
 8017df2:	e000      	b.n	8017df6 <DecodeExtensionType+0x572>
            break;
 8017df4:	bf00      	nop
    }

    return ret;
 8017df6:	697b      	ldr	r3, [r7, #20]
}
 8017df8:	4618      	mov	r0, r3
 8017dfa:	3718      	adds	r7, #24
 8017dfc:	46bd      	mov	sp, r7
 8017dfe:	bd80      	pop	{r7, pc}

08017e00 <DecodeCertExtensions>:
/*
 *  Processing the Certificate Extensions. This does not modify the current
 *  index. It is works starting with the recorded extensions pointer.
 */
static int DecodeCertExtensions(DecodedCert* cert)
{
 8017e00:	b580      	push	{r7, lr}
 8017e02:	b0a0      	sub	sp, #128	@ 0x80
 8017e04:	af04      	add	r7, sp, #16
 8017e06:	6078      	str	r0, [r7, #4]

    ret = criticalFail ? ASN_CRIT_EXT_E : 0;
end:
    return ret;
#else
    DECL_ASNGETDATA(dataASN, certExtASN_Length);
 8017e08:	2300      	movs	r3, #0
 8017e0a:	66fb      	str	r3, [r7, #108]	@ 0x6c
    ASNGetData dataExtsASN[certExtHdrASN_Length];
    int ret = 0;
 8017e0c:	2300      	movs	r3, #0
 8017e0e:	66bb      	str	r3, [r7, #104]	@ 0x68
    const byte* input = cert->extensions;
 8017e10:	687b      	ldr	r3, [r7, #4]
 8017e12:	f8d3 3398 	ldr.w	r3, [r3, #920]	@ 0x398
 8017e16:	663b      	str	r3, [r7, #96]	@ 0x60
    int sz = cert->extensionsSz;
 8017e18:	687b      	ldr	r3, [r7, #4]
 8017e1a:	f8d3 339c 	ldr.w	r3, [r3, #924]	@ 0x39c
 8017e1e:	65fb      	str	r3, [r7, #92]	@ 0x5c
    word32 idx = 0;
 8017e20:	2300      	movs	r3, #0
 8017e22:	613b      	str	r3, [r7, #16]
    int criticalRet = 0;
 8017e24:	2300      	movs	r3, #0
 8017e26:	667b      	str	r3, [r7, #100]	@ 0x64
    int offset = 0;
 8017e28:	2300      	movs	r3, #0
 8017e2a:	65bb      	str	r3, [r7, #88]	@ 0x58

    WOLFSSL_ENTER("DecodeCertExtensions");

    if (input == NULL || sz == 0)
 8017e2c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017e2e:	2b00      	cmp	r3, #0
 8017e30:	d002      	beq.n	8017e38 <DecodeCertExtensions+0x38>
 8017e32:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017e34:	2b00      	cmp	r3, #0
 8017e36:	d102      	bne.n	8017e3e <DecodeCertExtensions+0x3e>
        ret = BAD_FUNC_ARG;
 8017e38:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8017e3c:	66bb      	str	r3, [r7, #104]	@ 0x68

    ALLOC_ASNGETDATA(dataASN, certExtASN_Length, ret, cert->heap);
 8017e3e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017e40:	2b00      	cmp	r3, #0
 8017e42:	d109      	bne.n	8017e58 <DecodeCertExtensions+0x58>
 8017e44:	2070      	movs	r0, #112	@ 0x70
 8017e46:	f006 fe25 	bl	801ea94 <wolfSSL_Malloc>
 8017e4a:	66f8      	str	r0, [r7, #108]	@ 0x6c
 8017e4c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017e4e:	2b00      	cmp	r3, #0
 8017e50:	d102      	bne.n	8017e58 <DecodeCertExtensions+0x58>
 8017e52:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8017e56:	66bb      	str	r3, [r7, #104]	@ 0x68
#ifdef WOLFSSL_CERT_REQ
    if (cert->isCSR) {
        offset = CERTEXTHDRASN_IDX_EXTSEQ;
    }
#endif
    if (ret == 0) {
 8017e58:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017e5a:	2b00      	cmp	r3, #0
 8017e5c:	d16e      	bne.n	8017f3c <DecodeCertExtensions+0x13c>
        /* Clear dynamic data. */
        XMEMSET(dataExtsASN, 0, sizeof(dataExtsASN));
 8017e5e:	f107 0314 	add.w	r3, r7, #20
 8017e62:	2238      	movs	r2, #56	@ 0x38
 8017e64:	2100      	movs	r1, #0
 8017e66:	4618      	mov	r0, r3
 8017e68:	f010 fb32 	bl	80284d0 <memset>
        /* Parse extensions header. */
        ret = GetASN_Items(certExtHdrASN + offset, dataExtsASN + offset,
 8017e6c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017e6e:	009b      	lsls	r3, r3, #2
 8017e70:	4a40      	ldr	r2, [pc, #256]	@ (8017f74 <DecodeCertExtensions+0x174>)
 8017e72:	1898      	adds	r0, r3, r2
 8017e74:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8017e76:	4613      	mov	r3, r2
 8017e78:	00db      	lsls	r3, r3, #3
 8017e7a:	1a9b      	subs	r3, r3, r2
 8017e7c:	009b      	lsls	r3, r3, #2
 8017e7e:	461a      	mov	r2, r3
 8017e80:	f107 0314 	add.w	r3, r7, #20
 8017e84:	1899      	adds	r1, r3, r2
                           (int)(certExtHdrASN_Length - (size_t)offset), 0,
 8017e86:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017e88:	f1c3 0302 	rsb	r3, r3, #2
        ret = GetASN_Items(certExtHdrASN + offset, dataExtsASN + offset,
 8017e8c:	461a      	mov	r2, r3
 8017e8e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017e90:	9302      	str	r3, [sp, #8]
 8017e92:	f107 0310 	add.w	r3, r7, #16
 8017e96:	9301      	str	r3, [sp, #4]
 8017e98:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017e9a:	9300      	str	r3, [sp, #0]
 8017e9c:	2300      	movs	r3, #0
 8017e9e:	f7fb fc35 	bl	801370c <GetASN_Items>
 8017ea2:	66b8      	str	r0, [r7, #104]	@ 0x68
                           input, &idx, (word32)sz);
    }
    /* Parse each extension. */
    while ((ret == 0) && (idx < (word32)sz)) {
 8017ea4:	e04a      	b.n	8017f3c <DecodeCertExtensions+0x13c>
        byte critical = 0;
 8017ea6:	2300      	movs	r3, #0
 8017ea8:	73fb      	strb	r3, [r7, #15]
        int isUnknownExt = 0;
 8017eaa:	2300      	movs	r3, #0
 8017eac:	60bb      	str	r3, [r7, #8]

        /* Clear dynamic data. */
        XMEMSET(dataASN, 0, sizeof(*dataASN) * certExtASN_Length);
 8017eae:	2270      	movs	r2, #112	@ 0x70
 8017eb0:	2100      	movs	r1, #0
 8017eb2:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8017eb4:	f010 fb0c 	bl	80284d0 <memset>
        /* Ensure OID is an extension type. */
        GetASN_OID(&dataASN[CERTEXTASN_IDX_OID], oidCertExtType);
 8017eb8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017eba:	331c      	adds	r3, #28
 8017ebc:	2206      	movs	r2, #6
 8017ebe:	611a      	str	r2, [r3, #16]
        /* Set criticality variable. */
        GetASN_Int8Bit(&dataASN[CERTEXTASN_IDX_CRIT], &critical);
 8017ec0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017ec2:	3338      	adds	r3, #56	@ 0x38
 8017ec4:	2201      	movs	r2, #1
 8017ec6:	761a      	strb	r2, [r3, #24]
 8017ec8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017eca:	3338      	adds	r3, #56	@ 0x38
 8017ecc:	f107 020f 	add.w	r2, r7, #15
 8017ed0:	609a      	str	r2, [r3, #8]
        /* Parse extension wrapper. */
        ret = GetASN_Items(certExtASN, dataASN, certExtASN_Length, 0, input,
 8017ed2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017ed4:	9302      	str	r3, [sp, #8]
 8017ed6:	f107 0310 	add.w	r3, r7, #16
 8017eda:	9301      	str	r3, [sp, #4]
 8017edc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017ede:	9300      	str	r3, [sp, #0]
 8017ee0:	2300      	movs	r3, #0
 8017ee2:	2204      	movs	r2, #4
 8017ee4:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8017ee6:	4824      	ldr	r0, [pc, #144]	@ (8017f78 <DecodeCertExtensions+0x178>)
 8017ee8:	f7fb fc10 	bl	801370c <GetASN_Items>
 8017eec:	66b8      	str	r0, [r7, #104]	@ 0x68
                           &idx, (word32)sz);
        if (ret == 0) {
 8017eee:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017ef0:	2b00      	cmp	r3, #0
 8017ef2:	d11a      	bne.n	8017f2a <DecodeCertExtensions+0x12a>
            word32 oid = dataASN[CERTEXTASN_IDX_OID].data.oid.sum;
 8017ef4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017ef6:	331c      	adds	r3, #28
 8017ef8:	695b      	ldr	r3, [r3, #20]
 8017efa:	657b      	str	r3, [r7, #84]	@ 0x54
            word32 length = dataASN[CERTEXTASN_IDX_VAL].length;
 8017efc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017efe:	3354      	adds	r3, #84	@ 0x54
 8017f00:	685b      	ldr	r3, [r3, #4]
 8017f02:	653b      	str	r3, [r7, #80]	@ 0x50

            /* Decode the extension by type. */
            ret = DecodeExtensionType(input + idx, length, oid, critical, cert,
 8017f04:	693b      	ldr	r3, [r7, #16]
 8017f06:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8017f08:	18d0      	adds	r0, r2, r3
 8017f0a:	7bfa      	ldrb	r2, [r7, #15]
 8017f0c:	f107 0308 	add.w	r3, r7, #8
 8017f10:	9301      	str	r3, [sp, #4]
 8017f12:	687b      	ldr	r3, [r7, #4]
 8017f14:	9300      	str	r3, [sp, #0]
 8017f16:	4613      	mov	r3, r2
 8017f18:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8017f1a:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8017f1c:	f7ff fcb2 	bl	8017884 <DecodeExtensionType>
 8017f20:	66b8      	str	r0, [r7, #104]	@ 0x68
#else
            (void)isUnknownExt;
#endif

            /* Move index on to next extension. */
            idx += length;
 8017f22:	693a      	ldr	r2, [r7, #16]
 8017f24:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8017f26:	4413      	add	r3, r2
 8017f28:	613b      	str	r3, [r7, #16]
        }
        /* Don't fail criticality until all other extensions have been checked.
         */
        if (ret == WC_NO_ERR_TRACE(ASN_CRIT_EXT_E)) {
 8017f2a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017f2c:	f113 0fa0 	cmn.w	r3, #160	@ 0xa0
 8017f30:	d104      	bne.n	8017f3c <DecodeCertExtensions+0x13c>
            criticalRet = ASN_CRIT_EXT_E;
 8017f32:	f06f 039f 	mvn.w	r3, #159	@ 0x9f
 8017f36:	667b      	str	r3, [r7, #100]	@ 0x64
            ret = 0;
 8017f38:	2300      	movs	r3, #0
 8017f3a:	66bb      	str	r3, [r7, #104]	@ 0x68
    while ((ret == 0) && (idx < (word32)sz)) {
 8017f3c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017f3e:	2b00      	cmp	r3, #0
 8017f40:	d103      	bne.n	8017f4a <DecodeCertExtensions+0x14a>
 8017f42:	693a      	ldr	r2, [r7, #16]
 8017f44:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017f46:	429a      	cmp	r2, r3
 8017f48:	d3ad      	bcc.n	8017ea6 <DecodeCertExtensions+0xa6>
        }
    }

    if (ret == 0) {
 8017f4a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017f4c:	2b00      	cmp	r3, #0
 8017f4e:	d101      	bne.n	8017f54 <DecodeCertExtensions+0x154>
        /* Use criticality return. */
        ret = criticalRet;
 8017f50:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8017f52:	66bb      	str	r3, [r7, #104]	@ 0x68
    }

    FREE_ASNGETDATA(dataASN, cert->heap);
 8017f54:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017f56:	2b00      	cmp	r3, #0
 8017f58:	d007      	beq.n	8017f6a <DecodeCertExtensions+0x16a>
 8017f5a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8017f5c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8017f5e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017f60:	2b00      	cmp	r3, #0
 8017f62:	d002      	beq.n	8017f6a <DecodeCertExtensions+0x16a>
 8017f64:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8017f66:	f006 fdb1 	bl	801eacc <wolfSSL_Free>
    return ret;
 8017f6a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
#endif
}
 8017f6c:	4618      	mov	r0, r3
 8017f6e:	3770      	adds	r7, #112	@ 0x70
 8017f70:	46bd      	mov	sp, r7
 8017f72:	bd80      	pop	{r7, pc}
 8017f74:	08033820 	.word	0x08033820
 8017f78:	08033828 	.word	0x08033828

08017f7c <CheckDate>:
 * @return  ASN_DATE_SZ_E when time data is not supported.
 * @return  ASN_BEFORE_DATE_E when ASN_BEFORE date is invalid.
 * @return  ASN_AFTER_DATE_E when ASN_AFTER date is invalid.
 */
static int CheckDate(ASNGetData *dataASN, int dateType)
{
 8017f7c:	b480      	push	{r7}
 8017f7e:	b085      	sub	sp, #20
 8017f80:	af00      	add	r7, sp, #0
 8017f82:	6078      	str	r0, [r7, #4]
 8017f84:	6039      	str	r1, [r7, #0]
    int ret = 0;
 8017f86:	2300      	movs	r3, #0
 8017f88:	60fb      	str	r3, [r7, #12]

    /* Check BER tag is valid. */
    if ((dataASN->tag != ASN_UTC_TIME) &&
 8017f8a:	687b      	ldr	r3, [r7, #4]
 8017f8c:	7e5b      	ldrb	r3, [r3, #25]
 8017f8e:	2b17      	cmp	r3, #23
 8017f90:	d006      	beq.n	8017fa0 <CheckDate+0x24>
            (dataASN->tag != ASN_GENERALIZED_TIME)) {
 8017f92:	687b      	ldr	r3, [r7, #4]
 8017f94:	7e5b      	ldrb	r3, [r3, #25]
    if ((dataASN->tag != ASN_UTC_TIME) &&
 8017f96:	2b18      	cmp	r3, #24
 8017f98:	d002      	beq.n	8017fa0 <CheckDate+0x24>
        ret = ASN_TIME_E;
 8017f9a:	f06f 0398 	mvn.w	r3, #152	@ 0x98
 8017f9e:	60fb      	str	r3, [r7, #12]
    }
    /* Check date length is valid. */
    if ((ret == 0) && ((dataASN->length > MAX_DATE_SIZE) ||
 8017fa0:	68fb      	ldr	r3, [r7, #12]
 8017fa2:	2b00      	cmp	r3, #0
 8017fa4:	d10a      	bne.n	8017fbc <CheckDate+0x40>
 8017fa6:	687b      	ldr	r3, [r7, #4]
 8017fa8:	685b      	ldr	r3, [r3, #4]
 8017faa:	2b20      	cmp	r3, #32
 8017fac:	d803      	bhi.n	8017fb6 <CheckDate+0x3a>
                       (dataASN->length < MIN_DATE_SIZE))) {
 8017fae:	687b      	ldr	r3, [r7, #4]
 8017fb0:	685b      	ldr	r3, [r3, #4]
    if ((ret == 0) && ((dataASN->length > MAX_DATE_SIZE) ||
 8017fb2:	2b0b      	cmp	r3, #11
 8017fb4:	d802      	bhi.n	8017fbc <CheckDate+0x40>
        ret = ASN_DATE_SZ_E;
 8017fb6:	f06f 0394 	mvn.w	r3, #148	@ 0x94
 8017fba:	60fb      	str	r3, [r7, #12]
        }
    }
#endif
    (void)dateType;

    return ret;
 8017fbc:	68fb      	ldr	r3, [r7, #12]
}
 8017fbe:	4618      	mov	r0, r3
 8017fc0:	3714      	adds	r7, #20
 8017fc2:	46bd      	mov	sp, r7
 8017fc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017fc8:	4770      	bx	lr
	...

08017fcc <DecodeCertInternal>:
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
static int DecodeCertInternal(DecodedCert* cert, int verify, int* criticalExt,
                              int* badDateRet, int stopAtPubKey,
                              int stopAfterPubKey)
{
 8017fcc:	b580      	push	{r7, lr}
 8017fce:	b09c      	sub	sp, #112	@ 0x70
 8017fd0:	af04      	add	r7, sp, #16
 8017fd2:	60f8      	str	r0, [r7, #12]
 8017fd4:	60b9      	str	r1, [r7, #8]
 8017fd6:	607a      	str	r2, [r7, #4]
 8017fd8:	603b      	str	r3, [r7, #0]
    DECL_ASNGETDATA(dataASN, x509CertASN_Length);
 8017fda:	2300      	movs	r3, #0
 8017fdc:	65fb      	str	r3, [r7, #92]	@ 0x5c
    int ret = 0;
 8017fde:	2300      	movs	r3, #0
 8017fe0:	65bb      	str	r3, [r7, #88]	@ 0x58
    int badDate = 0;
 8017fe2:	2300      	movs	r3, #0
 8017fe4:	657b      	str	r3, [r7, #84]	@ 0x54
    byte version = 0;
 8017fe6:	2300      	movs	r3, #0
 8017fe8:	76fb      	strb	r3, [r7, #27]
    word32 idx;
    word32 serialSz = 0;
 8017fea:	2300      	movs	r3, #0
 8017fec:	613b      	str	r3, [r7, #16]
    const unsigned char* issuer = NULL;
 8017fee:	2300      	movs	r3, #0
 8017ff0:	653b      	str	r3, [r7, #80]	@ 0x50
    word32 issuerSz = 0;
 8017ff2:	2300      	movs	r3, #0
 8017ff4:	64fb      	str	r3, [r7, #76]	@ 0x4c
    const unsigned char* subject = NULL;
 8017ff6:	2300      	movs	r3, #0
 8017ff8:	64bb      	str	r3, [r7, #72]	@ 0x48
    word32 subjectSz = 0;
 8017ffa:	2300      	movs	r3, #0
 8017ffc:	647b      	str	r3, [r7, #68]	@ 0x44
    word32 pubKeyOffset = 0;
 8017ffe:	2300      	movs	r3, #0
 8018000:	643b      	str	r3, [r7, #64]	@ 0x40
    word32 pubKeyEnd = 0;
 8018002:	2300      	movs	r3, #0
 8018004:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int done = 0;
 8018006:	2300      	movs	r3, #0
 8018008:	63bb      	str	r3, [r7, #56]	@ 0x38
    else {
        ret = 0;    /* proceed to the original x509 parsing */
    }
#endif /* HAVE_RPK */

    CALLOC_ASNGETDATA(dataASN, x509CertASN_Length, ret, cert->heap);
 801800a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801800c:	2b00      	cmp	r3, #0
 801800e:	d10a      	bne.n	8018026 <DecodeCertInternal+0x5a>
 8018010:	f44f 7060 	mov.w	r0, #896	@ 0x380
 8018014:	f006 fd3e 	bl	801ea94 <wolfSSL_Malloc>
 8018018:	65f8      	str	r0, [r7, #92]	@ 0x5c
 801801a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801801c:	2b00      	cmp	r3, #0
 801801e:	d102      	bne.n	8018026 <DecodeCertInternal+0x5a>
 8018020:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8018024:	65bb      	str	r3, [r7, #88]	@ 0x58
 8018026:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018028:	2b00      	cmp	r3, #0
 801802a:	d105      	bne.n	8018038 <DecodeCertInternal+0x6c>
 801802c:	f44f 7260 	mov.w	r2, #896	@ 0x380
 8018030:	2100      	movs	r1, #0
 8018032:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8018034:	f010 fa4c 	bl	80284d0 <memset>

    if (ret == 0) {
 8018038:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801803a:	2b00      	cmp	r3, #0
 801803c:	d141      	bne.n	80180c2 <DecodeCertInternal+0xf6>
        version = 0;
 801803e:	2300      	movs	r3, #0
 8018040:	76fb      	strb	r3, [r7, #27]
        serialSz = EXTERNAL_SERIAL_SIZE;
 8018042:	2320      	movs	r3, #32
 8018044:	613b      	str	r3, [r7, #16]

        /* Get the version and put the serial number into the buffer. */
        GetASN_Int8Bit(&dataASN[X509CERTASN_IDX_TBS_VER_INT], &version);
 8018046:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018048:	3354      	adds	r3, #84	@ 0x54
 801804a:	2201      	movs	r2, #1
 801804c:	761a      	strb	r2, [r3, #24]
 801804e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018050:	3354      	adds	r3, #84	@ 0x54
 8018052:	f107 021b 	add.w	r2, r7, #27
 8018056:	609a      	str	r2, [r3, #8]
        GetASN_Buffer(&dataASN[X509CERTASN_IDX_TBS_SERIAL], cert->serial,
 8018058:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801805a:	3370      	adds	r3, #112	@ 0x70
 801805c:	2205      	movs	r2, #5
 801805e:	761a      	strb	r2, [r3, #24]
 8018060:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018062:	3370      	adds	r3, #112	@ 0x70
 8018064:	68fa      	ldr	r2, [r7, #12]
 8018066:	f502 725d 	add.w	r2, r2, #884	@ 0x374
 801806a:	609a      	str	r2, [r3, #8]
 801806c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801806e:	3370      	adds	r3, #112	@ 0x70
 8018070:	f107 0210 	add.w	r2, r7, #16
 8018074:	60da      	str	r2, [r3, #12]
                &serialSz);
        /* Check OID types for signature, algorithm, ECC curve and sigAlg. */
        GetASN_OID(&dataASN[X509CERTASN_IDX_TBS_ALGOID_OID], oidSigType);
 8018076:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018078:	33a8      	adds	r3, #168	@ 0xa8
 801807a:	2201      	movs	r2, #1
 801807c:	611a      	str	r2, [r3, #16]
        GetASN_OID(&dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_ALGO_OID],
 801807e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018080:	f503 73fc 	add.w	r3, r3, #504	@ 0x1f8
 8018084:	2202      	movs	r2, #2
 8018086:	611a      	str	r2, [r3, #16]
                oidKeyType);
        GetASN_OID(&dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_ALGO_CURVEID],
 8018088:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801808a:	f503 730c 	add.w	r3, r3, #560	@ 0x230
 801808e:	2203      	movs	r2, #3
 8018090:	611a      	str	r2, [r3, #16]
                oidCurveType);
        GetASN_OID(&dataASN[X509CERTASN_IDX_SIGALGO_OID], oidSigType);
 8018092:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018094:	f503 7344 	add.w	r3, r3, #784	@ 0x310
 8018098:	2201      	movs	r2, #1
 801809a:	611a      	str	r2, [r3, #16]
        /* Parse the X509 certificate. */
        ret = GetASN_Items(x509CertASN, dataASN, x509CertASN_Length, 1,
 801809c:	68fb      	ldr	r3, [r7, #12]
 801809e:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 80180a2:	68fa      	ldr	r2, [r7, #12]
 80180a4:	f502 725a 	add.w	r2, r2, #872	@ 0x368
 80180a8:	68f9      	ldr	r1, [r7, #12]
 80180aa:	f8d1 136c 	ldr.w	r1, [r1, #876]	@ 0x36c
 80180ae:	9102      	str	r1, [sp, #8]
 80180b0:	9201      	str	r2, [sp, #4]
 80180b2:	9300      	str	r3, [sp, #0]
 80180b4:	2301      	movs	r3, #1
 80180b6:	2220      	movs	r2, #32
 80180b8:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80180ba:	48a6      	ldr	r0, [pc, #664]	@ (8018354 <DecodeCertInternal+0x388>)
 80180bc:	f7fb fb26 	bl	801370c <GetASN_Items>
 80180c0:	65b8      	str	r0, [r7, #88]	@ 0x58
            ret = ASN_PARSE_E;
        }
#endif
    }
    /* Check version is valid/supported - can't be negative. */
    if ((ret == 0) && (version > MAX_X509_VERSION)) {
 80180c2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80180c4:	2b00      	cmp	r3, #0
 80180c6:	d105      	bne.n	80180d4 <DecodeCertInternal+0x108>
 80180c8:	7efb      	ldrb	r3, [r7, #27]
 80180ca:	2b03      	cmp	r3, #3
 80180cc:	d902      	bls.n	80180d4 <DecodeCertInternal+0x108>
        WOLFSSL_MSG("Unexpected certificate version");
        WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
        ret = ASN_PARSE_E;
 80180ce:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80180d2:	65bb      	str	r3, [r7, #88]	@ 0x58
    }
    if (ret == 0) {
 80180d4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80180d6:	2b00      	cmp	r3, #0
 80180d8:	f040 8107 	bne.w	80182ea <DecodeCertInternal+0x31e>
        int i;

        pubKeyOffset = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_SEQ].offset;
 80180dc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80180de:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 80180e2:	681b      	ldr	r3, [r3, #0]
 80180e4:	643b      	str	r3, [r7, #64]	@ 0x40
        /* Set fields extracted from data. */
        cert->version = version;
 80180e6:	7efb      	ldrb	r3, [r7, #27]
 80180e8:	461a      	mov	r2, r3
 80180ea:	68fb      	ldr	r3, [r7, #12]
 80180ec:	629a      	str	r2, [r3, #40]	@ 0x28
        cert->serialSz = (int)serialSz;
 80180ee:	693b      	ldr	r3, [r7, #16]
 80180f0:	461a      	mov	r2, r3
 80180f2:	68fb      	ldr	r3, [r7, #12]
 80180f4:	f8c3 2394 	str.w	r2, [r3, #916]	@ 0x394
        !defined(WOLFSSL_ASN_ALLOW_0_SERIAL)
        /* RFC 5280 section 4.1.2.2 states that non-conforming CAs may issue
         * a negative or zero serial number and should be handled gracefully.
         * Since it is a non-conforming CA that issues a serial of 0 then we
         * treat it as an error here. */
        if (cert->serialSz == 1 && cert->serial[0] == 0) {
 80180f8:	68fb      	ldr	r3, [r7, #12]
 80180fa:	f8d3 3394 	ldr.w	r3, [r3, #916]	@ 0x394
 80180fe:	2b01      	cmp	r3, #1
 8018100:	d107      	bne.n	8018112 <DecodeCertInternal+0x146>
 8018102:	68fb      	ldr	r3, [r7, #12]
 8018104:	f893 3374 	ldrb.w	r3, [r3, #884]	@ 0x374
 8018108:	2b00      	cmp	r3, #0
 801810a:	d102      	bne.n	8018112 <DecodeCertInternal+0x146>
            WOLFSSL_MSG("Error serial number of 0, use WOLFSSL_NO_ASN_STRICT "
                "if wanted");
            ret = ASN_PARSE_E;
 801810c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8018110:	65bb      	str	r3, [r7, #88]	@ 0x58
        }
    #endif
        if (cert->serialSz == 0) {
 8018112:	68fb      	ldr	r3, [r7, #12]
 8018114:	f8d3 3394 	ldr.w	r3, [r3, #916]	@ 0x394
 8018118:	2b00      	cmp	r3, #0
 801811a:	d102      	bne.n	8018122 <DecodeCertInternal+0x156>
            WOLFSSL_MSG("Error serial size is zero. Should be at least one "
                        "even with no serial number.");
            ret = ASN_PARSE_E;
 801811c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8018120:	65bb      	str	r3, [r7, #88]	@ 0x58
        }

        cert->signatureOID = dataASN[X509CERTASN_IDX_TBS_ALGOID_OID].data.oid.sum;
 8018122:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018124:	33a8      	adds	r3, #168	@ 0xa8
 8018126:	695a      	ldr	r2, [r3, #20]
 8018128:	68fb      	ldr	r3, [r7, #12]
 801812a:	619a      	str	r2, [r3, #24]
        cert->keyOID = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_ALGO_OID].data.oid.sum;
 801812c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801812e:	f503 73fc 	add.w	r3, r3, #504	@ 0x1f8
 8018132:	695a      	ldr	r2, [r3, #20]
 8018134:	68fb      	ldr	r3, [r7, #12]
 8018136:	61da      	str	r2, [r3, #28]
        cert->certBegin = dataASN[X509CERTASN_IDX_TBS_SEQ].offset;
 8018138:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801813a:	331c      	adds	r3, #28
 801813c:	681a      	ldr	r2, [r3, #0]
 801813e:	68fb      	ldr	r3, [r7, #12]
 8018140:	60da      	str	r2, [r3, #12]

        /* No bad date error - don't always care. */
        badDate = 0;
 8018142:	2300      	movs	r3, #0
 8018144:	657b      	str	r3, [r7, #84]	@ 0x54
        /* Find the item with the ASN_BEFORE date and check it. */
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTB_UTC].tag != 0)
 8018146:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018148:	f503 739a 	add.w	r3, r3, #308	@ 0x134
 801814c:	7e5b      	ldrb	r3, [r3, #25]
                ? X509CERTASN_IDX_TBS_VALIDITY_NOTB_UTC
                : X509CERTASN_IDX_TBS_VALIDITY_NOTB_GT;
 801814e:	2b00      	cmp	r3, #0
 8018150:	d001      	beq.n	8018156 <DecodeCertInternal+0x18a>
 8018152:	230b      	movs	r3, #11
 8018154:	e000      	b.n	8018158 <DecodeCertInternal+0x18c>
 8018156:	230c      	movs	r3, #12
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTB_UTC].tag != 0)
 8018158:	633b      	str	r3, [r7, #48]	@ 0x30
        if ((CheckDate(&dataASN[i], ASN_BEFORE) < 0) && (verify != NO_VERIFY) &&
 801815a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801815c:	4613      	mov	r3, r2
 801815e:	00db      	lsls	r3, r3, #3
 8018160:	1a9b      	subs	r3, r3, r2
 8018162:	009b      	lsls	r3, r3, #2
 8018164:	461a      	mov	r2, r3
 8018166:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018168:	4413      	add	r3, r2
 801816a:	2100      	movs	r1, #0
 801816c:	4618      	mov	r0, r3
 801816e:	f7ff ff05 	bl	8017f7c <CheckDate>
 8018172:	4603      	mov	r3, r0
 8018174:	2b00      	cmp	r3, #0
 8018176:	da08      	bge.n	801818a <DecodeCertInternal+0x1be>
 8018178:	68bb      	ldr	r3, [r7, #8]
 801817a:	2b00      	cmp	r3, #0
 801817c:	d005      	beq.n	801818a <DecodeCertInternal+0x1be>
 801817e:	68bb      	ldr	r3, [r7, #8]
 8018180:	2b05      	cmp	r3, #5
 8018182:	d002      	beq.n	801818a <DecodeCertInternal+0x1be>
                (verify != VERIFY_SKIP_DATE)) {
            badDate = ASN_BEFORE_DATE_E;
 8018184:	f06f 0395 	mvn.w	r3, #149	@ 0x95
 8018188:	657b      	str	r3, [r7, #84]	@ 0x54
        }
        /* Store reference to ASN_BEFORE date. */
        cert->beforeDate = GetASNItem_Addr(dataASN[i], cert->source);
 801818a:	68fb      	ldr	r3, [r7, #12]
 801818c:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 8018190:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018192:	4613      	mov	r3, r2
 8018194:	00db      	lsls	r3, r3, #3
 8018196:	1a9b      	subs	r3, r3, r2
 8018198:	009b      	lsls	r3, r3, #2
 801819a:	461a      	mov	r2, r3
 801819c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801819e:	4413      	add	r3, r2
 80181a0:	681b      	ldr	r3, [r3, #0]
 80181a2:	18ca      	adds	r2, r1, r3
 80181a4:	68fb      	ldr	r3, [r7, #12]
 80181a6:	f8c3 2444 	str.w	r2, [r3, #1092]	@ 0x444
        cert->beforeDateLen = (int)GetASNItem_Length(dataASN[i], cert->source);
 80181aa:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80181ac:	4613      	mov	r3, r2
 80181ae:	00db      	lsls	r3, r3, #3
 80181b0:	1a9b      	subs	r3, r3, r2
 80181b2:	009b      	lsls	r3, r3, #2
 80181b4:	461a      	mov	r2, r3
 80181b6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181b8:	4413      	add	r3, r2
 80181ba:	6859      	ldr	r1, [r3, #4]
 80181bc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80181be:	4613      	mov	r3, r2
 80181c0:	00db      	lsls	r3, r3, #3
 80181c2:	1a9b      	subs	r3, r3, r2
 80181c4:	009b      	lsls	r3, r3, #2
 80181c6:	461a      	mov	r2, r3
 80181c8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181ca:	4413      	add	r3, r2
 80181cc:	689a      	ldr	r2, [r3, #8]
 80181ce:	68fb      	ldr	r3, [r7, #12]
 80181d0:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 80181d4:	1ad3      	subs	r3, r2, r3
 80181d6:	4419      	add	r1, r3
 80181d8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80181da:	4613      	mov	r3, r2
 80181dc:	00db      	lsls	r3, r3, #3
 80181de:	1a9b      	subs	r3, r3, r2
 80181e0:	009b      	lsls	r3, r3, #2
 80181e2:	461a      	mov	r2, r3
 80181e4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181e6:	4413      	add	r3, r2
 80181e8:	681b      	ldr	r3, [r3, #0]
 80181ea:	1acb      	subs	r3, r1, r3
 80181ec:	461a      	mov	r2, r3
 80181ee:	68fb      	ldr	r3, [r7, #12]
 80181f0:	f8c3 2448 	str.w	r2, [r3, #1096]	@ 0x448

        /* Find the item with the ASN_AFTER date and check it. */
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTA_UTC].tag != 0)
 80181f4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80181f6:	f503 73b6 	add.w	r3, r3, #364	@ 0x16c
 80181fa:	7e5b      	ldrb	r3, [r3, #25]
                ? X509CERTASN_IDX_TBS_VALIDITY_NOTA_UTC
                : X509CERTASN_IDX_TBS_VALIDITY_NOTA_GT;
 80181fc:	2b00      	cmp	r3, #0
 80181fe:	d001      	beq.n	8018204 <DecodeCertInternal+0x238>
 8018200:	230d      	movs	r3, #13
 8018202:	e000      	b.n	8018206 <DecodeCertInternal+0x23a>
 8018204:	230e      	movs	r3, #14
        i = (dataASN[X509CERTASN_IDX_TBS_VALIDITY_NOTA_UTC].tag != 0)
 8018206:	633b      	str	r3, [r7, #48]	@ 0x30
        if ((CheckDate(&dataASN[i], ASN_AFTER) < 0) && (verify != NO_VERIFY) &&
 8018208:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801820a:	4613      	mov	r3, r2
 801820c:	00db      	lsls	r3, r3, #3
 801820e:	1a9b      	subs	r3, r3, r2
 8018210:	009b      	lsls	r3, r3, #2
 8018212:	461a      	mov	r2, r3
 8018214:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018216:	4413      	add	r3, r2
 8018218:	2101      	movs	r1, #1
 801821a:	4618      	mov	r0, r3
 801821c:	f7ff feae 	bl	8017f7c <CheckDate>
 8018220:	4603      	mov	r3, r0
 8018222:	2b00      	cmp	r3, #0
 8018224:	da08      	bge.n	8018238 <DecodeCertInternal+0x26c>
 8018226:	68bb      	ldr	r3, [r7, #8]
 8018228:	2b00      	cmp	r3, #0
 801822a:	d005      	beq.n	8018238 <DecodeCertInternal+0x26c>
 801822c:	68bb      	ldr	r3, [r7, #8]
 801822e:	2b05      	cmp	r3, #5
 8018230:	d002      	beq.n	8018238 <DecodeCertInternal+0x26c>
                (verify != VERIFY_SKIP_DATE)) {
            badDate = ASN_AFTER_DATE_E;
 8018232:	f06f 0396 	mvn.w	r3, #150	@ 0x96
 8018236:	657b      	str	r3, [r7, #84]	@ 0x54
        }
        /* Store reference to ASN_AFTER date. */
        cert->afterDate = GetASNItem_Addr(dataASN[i], cert->source);
 8018238:	68fb      	ldr	r3, [r7, #12]
 801823a:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 801823e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018240:	4613      	mov	r3, r2
 8018242:	00db      	lsls	r3, r3, #3
 8018244:	1a9b      	subs	r3, r3, r2
 8018246:	009b      	lsls	r3, r3, #2
 8018248:	461a      	mov	r2, r3
 801824a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801824c:	4413      	add	r3, r2
 801824e:	681b      	ldr	r3, [r3, #0]
 8018250:	18ca      	adds	r2, r1, r3
 8018252:	68fb      	ldr	r3, [r7, #12]
 8018254:	f8c3 244c 	str.w	r2, [r3, #1100]	@ 0x44c
        cert->afterDateLen = (int)GetASNItem_Length(dataASN[i], cert->source);
 8018258:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801825a:	4613      	mov	r3, r2
 801825c:	00db      	lsls	r3, r3, #3
 801825e:	1a9b      	subs	r3, r3, r2
 8018260:	009b      	lsls	r3, r3, #2
 8018262:	461a      	mov	r2, r3
 8018264:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018266:	4413      	add	r3, r2
 8018268:	6859      	ldr	r1, [r3, #4]
 801826a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801826c:	4613      	mov	r3, r2
 801826e:	00db      	lsls	r3, r3, #3
 8018270:	1a9b      	subs	r3, r3, r2
 8018272:	009b      	lsls	r3, r3, #2
 8018274:	461a      	mov	r2, r3
 8018276:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018278:	4413      	add	r3, r2
 801827a:	689a      	ldr	r2, [r3, #8]
 801827c:	68fb      	ldr	r3, [r7, #12]
 801827e:	f8d3 3364 	ldr.w	r3, [r3, #868]	@ 0x364
 8018282:	1ad3      	subs	r3, r2, r3
 8018284:	4419      	add	r1, r3
 8018286:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018288:	4613      	mov	r3, r2
 801828a:	00db      	lsls	r3, r3, #3
 801828c:	1a9b      	subs	r3, r3, r2
 801828e:	009b      	lsls	r3, r3, #2
 8018290:	461a      	mov	r2, r3
 8018292:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018294:	4413      	add	r3, r2
 8018296:	681b      	ldr	r3, [r3, #0]
 8018298:	1acb      	subs	r3, r1, r3
 801829a:	461a      	mov	r2, r3
 801829c:	68fb      	ldr	r3, [r7, #12]
 801829e:	f8c3 2450 	str.w	r2, [r3, #1104]	@ 0x450

        /* Get the issuer name. */
        issuer = cert->source + dataASN[X509CERTASN_IDX_TBS_ISSUER_SEQ].offset;
 80182a2:	68fb      	ldr	r3, [r7, #12]
 80182a4:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 80182a8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182aa:	33fc      	adds	r3, #252	@ 0xfc
 80182ac:	681b      	ldr	r3, [r3, #0]
 80182ae:	4413      	add	r3, r2
 80182b0:	653b      	str	r3, [r7, #80]	@ 0x50
        issuerSz = dataASN[X509CERTASN_IDX_TBS_VALIDITY_SEQ].offset -
 80182b2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182b4:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 80182b8:	681a      	ldr	r2, [r3, #0]
            dataASN[X509CERTASN_IDX_TBS_ISSUER_SEQ].offset;
 80182ba:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182bc:	33fc      	adds	r3, #252	@ 0xfc
 80182be:	681b      	ldr	r3, [r3, #0]
        issuerSz = dataASN[X509CERTASN_IDX_TBS_VALIDITY_SEQ].offset -
 80182c0:	1ad3      	subs	r3, r2, r3
 80182c2:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Get the subject name. */
        subject = cert->source +
 80182c4:	68fb      	ldr	r3, [r7, #12]
 80182c6:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
            dataASN[X509CERTASN_IDX_TBS_SUBJECT_SEQ].offset;
 80182ca:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182cc:	f503 73d2 	add.w	r3, r3, #420	@ 0x1a4
 80182d0:	681b      	ldr	r3, [r3, #0]
        subject = cert->source +
 80182d2:	4413      	add	r3, r2
 80182d4:	64bb      	str	r3, [r7, #72]	@ 0x48
        subjectSz = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_SEQ].offset -
 80182d6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182d8:	f503 73e0 	add.w	r3, r3, #448	@ 0x1c0
 80182dc:	681a      	ldr	r2, [r3, #0]
            dataASN[X509CERTASN_IDX_TBS_SUBJECT_SEQ].offset;
 80182de:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80182e0:	f503 73d2 	add.w	r3, r3, #420	@ 0x1a4
 80182e4:	681b      	ldr	r3, [r3, #0]
        subjectSz = dataASN[X509CERTASN_IDX_TBS_SPUBKEYINFO_SEQ].offset -
 80182e6:	1ad3      	subs	r3, r2, r3
 80182e8:	647b      	str	r3, [r7, #68]	@ 0x44
    }
    if ((ret == 0) && stopAtPubKey) {
 80182ea:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80182ec:	2b00      	cmp	r3, #0
 80182ee:	d10a      	bne.n	8018306 <DecodeCertInternal+0x33a>
 80182f0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80182f2:	2b00      	cmp	r3, #0
 80182f4:	d007      	beq.n	8018306 <DecodeCertInternal+0x33a>
        /* Return any bad date error through badDateRet and return offset of
         * subjectPublicKeyInfo.
         */
        if (badDateRet != NULL) {
 80182f6:	683b      	ldr	r3, [r7, #0]
 80182f8:	2b00      	cmp	r3, #0
 80182fa:	d002      	beq.n	8018302 <DecodeCertInternal+0x336>
            *badDateRet = badDate;
 80182fc:	683b      	ldr	r3, [r7, #0]
 80182fe:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8018300:	601a      	str	r2, [r3, #0]
        }
        done = 1;
 8018302:	2301      	movs	r3, #1
 8018304:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    if ((ret == 0) && (!done)) {
 8018306:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018308:	2b00      	cmp	r3, #0
 801830a:	f040 80a7 	bne.w	801845c <DecodeCertInternal+0x490>
 801830e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018310:	2b00      	cmp	r3, #0
 8018312:	f040 80a3 	bne.w	801845c <DecodeCertInternal+0x490>
        /* Store the signature information. */
        cert->sigIndex = dataASN[X509CERTASN_IDX_SIGALGO_SEQ].offset;
 8018316:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018318:	f503 733d 	add.w	r3, r3, #756	@ 0x2f4
 801831c:	681a      	ldr	r2, [r3, #0]
 801831e:	68fb      	ldr	r3, [r7, #12]
 8018320:	611a      	str	r2, [r3, #16]
        GetASN_GetConstRef(&dataASN[X509CERTASN_IDX_SIGNATURE],
 8018322:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018324:	f503 7359 	add.w	r3, r3, #868	@ 0x364
 8018328:	689a      	ldr	r2, [r3, #8]
 801832a:	68fb      	ldr	r3, [r7, #12]
 801832c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
 8018330:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018332:	f503 7359 	add.w	r3, r3, #868	@ 0x364
 8018336:	68da      	ldr	r2, [r3, #12]
 8018338:	68fb      	ldr	r3, [r7, #12]
 801833a:	615a      	str	r2, [r3, #20]
                &cert->signature, &cert->sigLength);
        /* Make sure 'signature' and 'signatureAlgorithm' are the same. */
        if (dataASN[X509CERTASN_IDX_SIGALGO_OID].data.oid.sum
 801833c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801833e:	f503 7344 	add.w	r3, r3, #784	@ 0x310
 8018342:	695a      	ldr	r2, [r3, #20]
                != cert->signatureOID) {
 8018344:	68fb      	ldr	r3, [r7, #12]
 8018346:	699b      	ldr	r3, [r3, #24]
        if (dataASN[X509CERTASN_IDX_SIGALGO_OID].data.oid.sum
 8018348:	429a      	cmp	r2, r3
 801834a:	d005      	beq.n	8018358 <DecodeCertInternal+0x38c>
            WOLFSSL_ERROR_VERBOSE(ASN_SIG_OID_E);
            ret = ASN_SIG_OID_E;
 801834c:	f06f 0397 	mvn.w	r3, #151	@ 0x97
 8018350:	65bb      	str	r3, [r7, #88]	@ 0x58
 8018352:	e083      	b.n	801845c <DecodeCertInternal+0x490>
 8018354:	08033838 	.word	0x08033838
        }
        /* Parameters not allowed after ECDSA or EdDSA algorithm OID. */
        else if (IsSigAlgoECC(cert->signatureOID)) {
 8018358:	68fb      	ldr	r3, [r7, #12]
 801835a:	699b      	ldr	r3, [r3, #24]
 801835c:	4618      	mov	r0, r3
 801835e:	f7fd fdf8 	bl	8015f52 <IsSigAlgoECC>
 8018362:	4603      	mov	r3, r0
 8018364:	2b00      	cmp	r3, #0
 8018366:	d012      	beq.n	801838e <DecodeCertInternal+0x3c2>
        #ifndef WOLFSSL_ECC_SIGALG_PARAMS_NULL_ALLOWED
            if (dataASN[X509CERTASN_IDX_SIGALGO_PARAMS_NULL].tag != 0) {
 8018368:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801836a:	f503 734b 	add.w	r3, r3, #812	@ 0x32c
 801836e:	7e5b      	ldrb	r3, [r3, #25]
 8018370:	2b00      	cmp	r3, #0
 8018372:	d002      	beq.n	801837a <DecodeCertInternal+0x3ae>
                WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                ret = ASN_PARSE_E;
 8018374:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8018378:	65bb      	str	r3, [r7, #88]	@ 0x58
            }
        #endif
        #ifdef WC_RSA_PSS
            if (dataASN[X509CERTASN_IDX_SIGALGO_PARAMS].tag != 0) {
 801837a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801837c:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 8018380:	7e5b      	ldrb	r3, [r3, #25]
 8018382:	2b00      	cmp	r3, #0
 8018384:	d06a      	beq.n	801845c <DecodeCertInternal+0x490>
                WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                ret = ASN_PARSE_E;
 8018386:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801838a:	65bb      	str	r3, [r7, #88]	@ 0x58
 801838c:	e066      	b.n	801845c <DecodeCertInternal+0x490>
            }
        #endif
        }
    #ifdef WC_RSA_PSS
        /* Check parameters starting with a SEQUENCE. */
        else if (dataASN[X509CERTASN_IDX_SIGALGO_PARAMS].tag != 0) {
 801838e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018390:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 8018394:	7e5b      	ldrb	r3, [r3, #25]
 8018396:	2b00      	cmp	r3, #0
 8018398:	d060      	beq.n	801845c <DecodeCertInternal+0x490>
            word32 oid = dataASN[X509CERTASN_IDX_SIGALGO_OID].data.oid.sum;
 801839a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801839c:	f503 7344 	add.w	r3, r3, #784	@ 0x310
 80183a0:	695b      	ldr	r3, [r3, #20]
 80183a2:	62fb      	str	r3, [r7, #44]	@ 0x2c
            word32 sigAlgParamsSz = 0;
 80183a4:	2300      	movs	r3, #0
 80183a6:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Parameters only with RSA PSS. */
            if (oid != CTC_RSASSAPSS) {
 80183a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80183aa:	f240 228e 	movw	r2, #654	@ 0x28e
 80183ae:	4293      	cmp	r3, r2
 80183b0:	d002      	beq.n	80183b8 <DecodeCertInternal+0x3ec>
                WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                ret = ASN_PARSE_E;
 80183b2:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 80183b6:	65bb      	str	r3, [r7, #88]	@ 0x58
            }
            if (ret == 0) {
 80183b8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80183ba:	2b00      	cmp	r3, #0
 80183bc:	d142      	bne.n	8018444 <DecodeCertInternal+0x478>
                word32 tbsParamsSz;
                const byte* sigAlgParams;

                /* Check RSA PSS parameters are the same. */
                tbsParams =
                    GetASNItem_Addr(dataASN[X509CERTASN_IDX_TBS_ALGOID_PARAMS],
 80183be:	68fb      	ldr	r3, [r7, #12]
 80183c0:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 80183c4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183c6:	33e0      	adds	r3, #224	@ 0xe0
 80183c8:	681b      	ldr	r3, [r3, #0]
                tbsParams =
 80183ca:	4413      	add	r3, r2
 80183cc:	62bb      	str	r3, [r7, #40]	@ 0x28
                        cert->source);
                tbsParamsSz =
                    GetASNItem_Length(dataASN[X509CERTASN_IDX_TBS_ALGOID_PARAMS],
 80183ce:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183d0:	33e0      	adds	r3, #224	@ 0xe0
 80183d2:	685b      	ldr	r3, [r3, #4]
 80183d4:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80183d6:	32e0      	adds	r2, #224	@ 0xe0
 80183d8:	6891      	ldr	r1, [r2, #8]
 80183da:	68fa      	ldr	r2, [r7, #12]
 80183dc:	f8d2 2364 	ldr.w	r2, [r2, #868]	@ 0x364
 80183e0:	1a8a      	subs	r2, r1, r2
 80183e2:	441a      	add	r2, r3
 80183e4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183e6:	33e0      	adds	r3, #224	@ 0xe0
 80183e8:	681b      	ldr	r3, [r3, #0]
                tbsParamsSz =
 80183ea:	1ad3      	subs	r3, r2, r3
 80183ec:	627b      	str	r3, [r7, #36]	@ 0x24
                        cert->source);
                sigAlgParams =
                    GetASNItem_Addr(dataASN[X509CERTASN_IDX_SIGALGO_PARAMS],
 80183ee:	68fb      	ldr	r3, [r7, #12]
 80183f0:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 80183f4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80183f6:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 80183fa:	681b      	ldr	r3, [r3, #0]
                sigAlgParams =
 80183fc:	4413      	add	r3, r2
 80183fe:	623b      	str	r3, [r7, #32]
                        cert->source);
                sigAlgParamsSz =
                    GetASNItem_Length(dataASN[X509CERTASN_IDX_SIGALGO_PARAMS],
 8018400:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018402:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 8018406:	685b      	ldr	r3, [r3, #4]
 8018408:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801840a:	f502 7252 	add.w	r2, r2, #840	@ 0x348
 801840e:	6891      	ldr	r1, [r2, #8]
 8018410:	68fa      	ldr	r2, [r7, #12]
 8018412:	f8d2 2364 	ldr.w	r2, [r2, #868]	@ 0x364
 8018416:	1a8a      	subs	r2, r1, r2
 8018418:	441a      	add	r2, r3
 801841a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801841c:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 8018420:	681b      	ldr	r3, [r3, #0]
                sigAlgParamsSz =
 8018422:	1ad3      	subs	r3, r2, r3
 8018424:	637b      	str	r3, [r7, #52]	@ 0x34
                        cert->source);
                if ((tbsParamsSz != sigAlgParamsSz) ||
 8018426:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018428:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801842a:	429a      	cmp	r2, r3
 801842c:	d107      	bne.n	801843e <DecodeCertInternal+0x472>
                        (XMEMCMP(tbsParams, sigAlgParams, tbsParamsSz) != 0)) {
 801842e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018430:	6a39      	ldr	r1, [r7, #32]
 8018432:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8018434:	f010 f822 	bl	802847c <memcmp>
 8018438:	4603      	mov	r3, r0
                if ((tbsParamsSz != sigAlgParamsSz) ||
 801843a:	2b00      	cmp	r3, #0
 801843c:	d002      	beq.n	8018444 <DecodeCertInternal+0x478>
                    WOLFSSL_ERROR_VERBOSE(ASN_PARSE_E);
                    ret = ASN_PARSE_E;
 801843e:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8018442:	65bb      	str	r3, [r7, #88]	@ 0x58
                }
            }
            if (ret == 0) {
 8018444:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018446:	2b00      	cmp	r3, #0
 8018448:	d108      	bne.n	801845c <DecodeCertInternal+0x490>
                /* Store parameters for use in signature verification. */
                cert->sigParamsIndex =
                    dataASN[X509CERTASN_IDX_SIGALGO_PARAMS].offset;
 801844a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801844c:	f503 7352 	add.w	r3, r3, #840	@ 0x348
 8018450:	681a      	ldr	r2, [r3, #0]
                cert->sigParamsIndex =
 8018452:	68fb      	ldr	r3, [r7, #12]
 8018454:	621a      	str	r2, [r3, #32]
                cert->sigParamsLength = sigAlgParamsSz;
 8018456:	68fb      	ldr	r3, [r7, #12]
 8018458:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801845a:	625a      	str	r2, [r3, #36]	@ 0x24
            }
        }
    #endif
    }
    if ((ret == 0) && (!done)) {
 801845c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801845e:	2b00      	cmp	r3, #0
 8018460:	d112      	bne.n	8018488 <DecodeCertInternal+0x4bc>
 8018462:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018464:	2b00      	cmp	r3, #0
 8018466:	d10f      	bne.n	8018488 <DecodeCertInternal+0x4bc>
        pubKeyEnd = dataASN[X509CERTASN_IDX_TBS_ISSUERUID].offset;
 8018468:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801846a:	f503 7321 	add.w	r3, r3, #644	@ 0x284
 801846e:	681b      	ldr	r3, [r3, #0]
 8018470:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if (stopAfterPubKey) {
 8018472:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8018474:	2b00      	cmp	r3, #0
 8018476:	d007      	beq.n	8018488 <DecodeCertInternal+0x4bc>
            /* Return any bad date error through badDateRed and return offset
             * after subjectPublicKeyInfo.
             */
            if (badDateRet != NULL) {
 8018478:	683b      	ldr	r3, [r7, #0]
 801847a:	2b00      	cmp	r3, #0
 801847c:	d002      	beq.n	8018484 <DecodeCertInternal+0x4b8>
                *badDateRet = badDate;
 801847e:	683b      	ldr	r3, [r7, #0]
 8018480:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8018482:	601a      	str	r2, [r3, #0]
            }
            done = 1;
 8018484:	2301      	movs	r3, #1
 8018486:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
    }
    if ((ret == 0) && (!done) &&
 8018488:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801848a:	2b00      	cmp	r3, #0
 801848c:	d141      	bne.n	8018512 <DecodeCertInternal+0x546>
 801848e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018490:	2b00      	cmp	r3, #0
 8018492:	d13e      	bne.n	8018512 <DecodeCertInternal+0x546>
            (dataASN[X509CERTASN_IDX_TBS_EXT_SEQ].data.ref.data != NULL)) {
 8018494:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018496:	f503 7336 	add.w	r3, r3, #728	@ 0x2d8
 801849a:	689b      	ldr	r3, [r3, #8]
    if ((ret == 0) && (!done) &&
 801849c:	2b00      	cmp	r3, #0
 801849e:	d038      	beq.n	8018512 <DecodeCertInternal+0x546>
    #ifndef ALLOW_V1_EXTENSIONS
        /* Certificate extensions were only defined in version 2. */
        if (cert->version < 2) {
 80184a0:	68fb      	ldr	r3, [r7, #12]
 80184a2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80184a4:	2b01      	cmp	r3, #1
 80184a6:	dc02      	bgt.n	80184ae <DecodeCertInternal+0x4e2>
            WOLFSSL_MSG("\tv1 and v2 certs not allowed extensions");
            WOLFSSL_ERROR_VERBOSE(ASN_VERSION_E);
            ret = ASN_VERSION_E;
 80184a8:	f06f 038c 	mvn.w	r3, #140	@ 0x8c
 80184ac:	65bb      	str	r3, [r7, #88]	@ 0x58
        }
    #endif
        if (ret == 0) {
 80184ae:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80184b0:	2b00      	cmp	r3, #0
 80184b2:	d12e      	bne.n	8018512 <DecodeCertInternal+0x546>
            /* Save references to extension data. */
            cert->extensions    = GetASNItem_Addr(
 80184b4:	68fb      	ldr	r3, [r7, #12]
 80184b6:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 80184ba:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184bc:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 80184c0:	681b      	ldr	r3, [r3, #0]
 80184c2:	441a      	add	r2, r3
 80184c4:	68fb      	ldr	r3, [r7, #12]
 80184c6:	f8c3 2398 	str.w	r2, [r3, #920]	@ 0x398
                    dataASN[X509CERTASN_IDX_TBS_EXT], cert->source);
            cert->extensionsSz  = (int)GetASNItem_Length(
 80184ca:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184cc:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 80184d0:	685b      	ldr	r3, [r3, #4]
 80184d2:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80184d4:	f502 722f 	add.w	r2, r2, #700	@ 0x2bc
 80184d8:	6891      	ldr	r1, [r2, #8]
 80184da:	68fa      	ldr	r2, [r7, #12]
 80184dc:	f8d2 2364 	ldr.w	r2, [r2, #868]	@ 0x364
 80184e0:	1a8a      	subs	r2, r1, r2
 80184e2:	441a      	add	r2, r3
 80184e4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184e6:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 80184ea:	681b      	ldr	r3, [r3, #0]
 80184ec:	1ad3      	subs	r3, r2, r3
 80184ee:	461a      	mov	r2, r3
 80184f0:	68fb      	ldr	r3, [r7, #12]
 80184f2:	f8c3 239c 	str.w	r2, [r3, #924]	@ 0x39c
                    dataASN[X509CERTASN_IDX_TBS_EXT], cert->source);
            cert->extensionsIdx = dataASN[X509CERTASN_IDX_TBS_EXT].offset;
 80184f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80184f8:	f503 732f 	add.w	r3, r3, #700	@ 0x2bc
 80184fc:	681a      	ldr	r2, [r3, #0]
 80184fe:	68fb      	ldr	r3, [r7, #12]
 8018500:	f8c3 23a0 	str.w	r2, [r3, #928]	@ 0x3a0
            /* Advance past extensions. */
            cert->srcIdx = dataASN[X509CERTASN_IDX_SIGALGO_SEQ].offset;
 8018504:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018506:	f503 733d 	add.w	r3, r3, #756	@ 0x2f4
 801850a:	681a      	ldr	r2, [r3, #0]
 801850c:	68fb      	ldr	r3, [r7, #12]
 801850e:	f8c3 2368 	str.w	r2, [r3, #872]	@ 0x368
        }
    }

    /* Dispose of memory before allocating for extension decoding. */
    FREE_ASNGETDATA(dataASN, cert->heap);
 8018512:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8018514:	2b00      	cmp	r3, #0
 8018516:	d007      	beq.n	8018528 <DecodeCertInternal+0x55c>
 8018518:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801851a:	61fb      	str	r3, [r7, #28]
 801851c:	69fb      	ldr	r3, [r7, #28]
 801851e:	2b00      	cmp	r3, #0
 8018520:	d002      	beq.n	8018528 <DecodeCertInternal+0x55c>
 8018522:	69f8      	ldr	r0, [r7, #28]
 8018524:	f006 fad2 	bl	801eacc <wolfSSL_Free>

    if ((ret == 0) && (issuer != NULL)) {
 8018528:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801852a:	2b00      	cmp	r3, #0
 801852c:	d116      	bne.n	801855c <DecodeCertInternal+0x590>
 801852e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018530:	2b00      	cmp	r3, #0
 8018532:	d013      	beq.n	801855c <DecodeCertInternal+0x590>
        idx = 0;
 8018534:	2300      	movs	r3, #0
 8018536:	617b      	str	r3, [r7, #20]
        /* Put issuer into cert and calculate hash. */
        ret = GetCertName(cert, cert->issuer, cert->issuerHash, ASN_ISSUER, issuer,
 8018538:	68fb      	ldr	r3, [r7, #12]
 801853a:	f103 018d 	add.w	r1, r3, #141	@ 0x8d
 801853e:	68fb      	ldr	r3, [r7, #12]
 8018540:	f103 0260 	add.w	r2, r3, #96	@ 0x60
 8018544:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8018546:	9302      	str	r3, [sp, #8]
 8018548:	f107 0314 	add.w	r3, r7, #20
 801854c:	9301      	str	r3, [sp, #4]
 801854e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018550:	9300      	str	r3, [sp, #0]
 8018552:	2300      	movs	r3, #0
 8018554:	68f8      	ldr	r0, [r7, #12]
 8018556:	f7fd fb5d 	bl	8015c14 <GetCertName>
 801855a:	65b8      	str	r0, [r7, #88]	@ 0x58
            &idx, issuerSz);
    }
    if ((ret == 0) && (subject != NULL)) {
 801855c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801855e:	2b00      	cmp	r3, #0
 8018560:	d116      	bne.n	8018590 <DecodeCertInternal+0x5c4>
 8018562:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8018564:	2b00      	cmp	r3, #0
 8018566:	d013      	beq.n	8018590 <DecodeCertInternal+0x5c4>
        idx = 0;
 8018568:	2300      	movs	r3, #0
 801856a:	617b      	str	r3, [r7, #20]
        /* Put subject into cert and calculate hash. */
        ret = GetCertName(cert, cert->subject, cert->subjectHash, ASN_SUBJECT,
 801856c:	68fb      	ldr	r3, [r7, #12]
 801856e:	f203 11f5 	addw	r1, r3, #501	@ 0x1f5
 8018572:	68fb      	ldr	r3, [r7, #12]
 8018574:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 8018578:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801857a:	9302      	str	r3, [sp, #8]
 801857c:	f107 0314 	add.w	r3, r7, #20
 8018580:	9301      	str	r3, [sp, #4]
 8018582:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8018584:	9300      	str	r3, [sp, #0]
 8018586:	2301      	movs	r3, #1
 8018588:	68f8      	ldr	r0, [r7, #12]
 801858a:	f7fd fb43 	bl	8015c14 <GetCertName>
 801858e:	65b8      	str	r0, [r7, #88]	@ 0x58
            subject, &idx, subjectSz);
    }
    if (ret == 0) {
 8018590:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018592:	2b00      	cmp	r3, #0
 8018594:	d11a      	bne.n	80185cc <DecodeCertInternal+0x600>
            cert->selfSigned = 1;
        }
        else
    #endif
        {
            cert->selfSigned = (XMEMCMP(cert->issuerHash, cert->subjectHash,
 8018596:	68fb      	ldr	r3, [r7, #12]
 8018598:	f103 0060 	add.w	r0, r3, #96	@ 0x60
 801859c:	68fb      	ldr	r3, [r7, #12]
 801859e:	3340      	adds	r3, #64	@ 0x40
 80185a0:	2220      	movs	r2, #32
 80185a2:	4619      	mov	r1, r3
 80185a4:	f00f ff6a 	bl	802847c <memcmp>
 80185a8:	4603      	mov	r3, r0
                                        KEYID_SIZE) == 0);
 80185aa:	2b00      	cmp	r3, #0
 80185ac:	bf0c      	ite	eq
 80185ae:	2301      	moveq	r3, #1
 80185b0:	2300      	movne	r3, #0
 80185b2:	b2d9      	uxtb	r1, r3
            cert->selfSigned = (XMEMCMP(cert->issuerHash, cert->subjectHash,
 80185b4:	68fa      	ldr	r2, [r7, #12]
 80185b6:	f892 34b6 	ldrb.w	r3, [r2, #1206]	@ 0x4b6
 80185ba:	f361 0341 	bfi	r3, r1, #1, #1
 80185be:	f882 34b6 	strb.w	r3, [r2, #1206]	@ 0x4b6
        }
        if (stopAtPubKey) {
 80185c2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80185c4:	2b00      	cmp	r3, #0
 80185c6:	d001      	beq.n	80185cc <DecodeCertInternal+0x600>
            ret = (int)pubKeyOffset;
 80185c8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80185ca:	65bb      	str	r3, [r7, #88]	@ 0x58
        }
    }

    if ((ret == 0) && (!stopAtPubKey)) {
 80185cc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80185ce:	2b00      	cmp	r3, #0
 80185d0:	d10e      	bne.n	80185f0 <DecodeCertInternal+0x624>
 80185d2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80185d4:	2b00      	cmp	r3, #0
 80185d6:	d10b      	bne.n	80185f0 <DecodeCertInternal+0x624>
        /* Parse the public key. */
        idx = pubKeyOffset;
 80185d8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80185da:	617b      	str	r3, [r7, #20]
        ret = GetCertKey(cert, cert->source, &idx, pubKeyEnd);
 80185dc:	68fb      	ldr	r3, [r7, #12]
 80185de:	f8d3 1364 	ldr.w	r1, [r3, #868]	@ 0x364
 80185e2:	f107 0214 	add.w	r2, r7, #20
 80185e6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80185e8:	68f8      	ldr	r0, [r7, #12]
 80185ea:	f7fc ff8f 	bl	801550c <GetCertKey>
 80185ee:	65b8      	str	r0, [r7, #88]	@ 0x58
    }
    if ((ret == 0) && (!stopAtPubKey) && (!stopAfterPubKey) &&
 80185f0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80185f2:	2b00      	cmp	r3, #0
 80185f4:	d11e      	bne.n	8018634 <DecodeCertInternal+0x668>
 80185f6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80185f8:	2b00      	cmp	r3, #0
 80185fa:	d11b      	bne.n	8018634 <DecodeCertInternal+0x668>
 80185fc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80185fe:	2b00      	cmp	r3, #0
 8018600:	d118      	bne.n	8018634 <DecodeCertInternal+0x668>
            (cert->extensions != NULL)) {
 8018602:	68fb      	ldr	r3, [r7, #12]
 8018604:	f8d3 3398 	ldr.w	r3, [r3, #920]	@ 0x398
    if ((ret == 0) && (!stopAtPubKey) && (!stopAfterPubKey) &&
 8018608:	2b00      	cmp	r3, #0
 801860a:	d013      	beq.n	8018634 <DecodeCertInternal+0x668>
        /* Decode the extension data starting at [3]. */
        ret = DecodeCertExtensions(cert);
 801860c:	68f8      	ldr	r0, [r7, #12]
 801860e:	f7ff fbf7 	bl	8017e00 <DecodeCertExtensions>
 8018612:	65b8      	str	r0, [r7, #88]	@ 0x58
        if (criticalExt != NULL) {
 8018614:	687b      	ldr	r3, [r7, #4]
 8018616:	2b00      	cmp	r3, #0
 8018618:	d00c      	beq.n	8018634 <DecodeCertInternal+0x668>
            if (ret == WC_NO_ERR_TRACE(ASN_CRIT_EXT_E)) {
 801861a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801861c:	f113 0fa0 	cmn.w	r3, #160	@ 0xa0
 8018620:	d105      	bne.n	801862e <DecodeCertInternal+0x662>
                /* Return critical extension not recognized. */
                *criticalExt = ret;
 8018622:	687b      	ldr	r3, [r7, #4]
 8018624:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8018626:	601a      	str	r2, [r3, #0]
                ret = 0;
 8018628:	2300      	movs	r3, #0
 801862a:	65bb      	str	r3, [r7, #88]	@ 0x58
 801862c:	e002      	b.n	8018634 <DecodeCertInternal+0x668>
            }
            else {
                /* No critical extension error. */
                *criticalExt = 0;
 801862e:	687b      	ldr	r3, [r7, #4]
 8018630:	2200      	movs	r2, #0
 8018632:	601a      	str	r2, [r3, #0]
            }
        }
    }

    if ((ret == 0) && (!done) && (badDate != 0)) {
 8018634:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8018636:	2b00      	cmp	r3, #0
 8018638:	d107      	bne.n	801864a <DecodeCertInternal+0x67e>
 801863a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801863c:	2b00      	cmp	r3, #0
 801863e:	d104      	bne.n	801864a <DecodeCertInternal+0x67e>
 8018640:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8018642:	2b00      	cmp	r3, #0
 8018644:	d001      	beq.n	801864a <DecodeCertInternal+0x67e>
        /* Parsed whole certificate fine but return any date errors. */
        ret = badDate;
 8018646:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8018648:	65bb      	str	r3, [r7, #88]	@ 0x58
    }

    return ret;
 801864a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
}
 801864c:	4618      	mov	r0, r3
 801864e:	3760      	adds	r7, #96	@ 0x60
 8018650:	46bd      	mov	sp, r7
 8018652:	bd80      	pop	{r7, pc}

08018654 <DecodeCert>:
 * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
 *          non-zero length.
 * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
 */
int DecodeCert(DecodedCert* cert, int verify, int* criticalExt)
{
 8018654:	b580      	push	{r7, lr}
 8018656:	b086      	sub	sp, #24
 8018658:	af02      	add	r7, sp, #8
 801865a:	60f8      	str	r0, [r7, #12]
 801865c:	60b9      	str	r1, [r7, #8]
 801865e:	607a      	str	r2, [r7, #4]
    return DecodeCertInternal(cert, verify, criticalExt, NULL, 0, 0);
 8018660:	2300      	movs	r3, #0
 8018662:	9301      	str	r3, [sp, #4]
 8018664:	2300      	movs	r3, #0
 8018666:	9300      	str	r3, [sp, #0]
 8018668:	2300      	movs	r3, #0
 801866a:	687a      	ldr	r2, [r7, #4]
 801866c:	68b9      	ldr	r1, [r7, #8]
 801866e:	68f8      	ldr	r0, [r7, #12]
 8018670:	f7ff fcac 	bl	8017fcc <DecodeCertInternal>
 8018674:	4603      	mov	r3, r0
}
 8018676:	4618      	mov	r0, r3
 8018678:	3710      	adds	r7, #16
 801867a:	46bd      	mov	sp, r7
 801867c:	bd80      	pop	{r7, pc}

0801867e <ParseCert>:
#endif /* WOLFSSL_CERT_REQ */

#endif

int ParseCert(DecodedCert* cert, int type, int verify, void* cm)
{
 801867e:	b580      	push	{r7, lr}
 8018680:	b088      	sub	sp, #32
 8018682:	af02      	add	r7, sp, #8
 8018684:	60f8      	str	r0, [r7, #12]
 8018686:	60b9      	str	r1, [r7, #8]
 8018688:	607a      	str	r2, [r7, #4]
 801868a:	603b      	str	r3, [r7, #0]
#if (!defined(WOLFSSL_NO_MALLOC) && !defined(NO_WOLFSSL_CM_VERIFY)) || \
    defined(WOLFSSL_DYN_CERT)
    char* ptr;
#endif

    ret = ParseCertRelative(cert, type, verify, cm, NULL);
 801868c:	2300      	movs	r3, #0
 801868e:	9300      	str	r3, [sp, #0]
 8018690:	683b      	ldr	r3, [r7, #0]
 8018692:	687a      	ldr	r2, [r7, #4]
 8018694:	68b9      	ldr	r1, [r7, #8]
 8018696:	68f8      	ldr	r0, [r7, #12]
 8018698:	f000 f869 	bl	801876e <ParseCertRelative>
 801869c:	6178      	str	r0, [r7, #20]
    if (ret < 0)
 801869e:	697b      	ldr	r3, [r7, #20]
 80186a0:	2b00      	cmp	r3, #0
 80186a2:	da01      	bge.n	80186a8 <ParseCert+0x2a>
        return ret;
 80186a4:	697b      	ldr	r3, [r7, #20]
 80186a6:	e05e      	b.n	8018766 <ParseCert+0xe8>

#if (!defined(WOLFSSL_NO_MALLOC) && !defined(NO_WOLFSSL_CM_VERIFY)) || \
    defined(WOLFSSL_DYN_CERT)
    /* cert->subjectCN not stored as copy of WOLFSSL_NO_MALLOC defined */
    if (cert->subjectCNLen > 0) {
 80186a8:	68fb      	ldr	r3, [r7, #12]
 80186aa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80186ae:	2b00      	cmp	r3, #0
 80186b0:	dd2a      	ble.n	8018708 <ParseCert+0x8a>
        ptr = (char*)XMALLOC((size_t)cert->subjectCNLen + 1, cert->heap,
 80186b2:	68fb      	ldr	r3, [r7, #12]
 80186b4:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80186b8:	3301      	adds	r3, #1
 80186ba:	4618      	mov	r0, r3
 80186bc:	f006 f9ea 	bl	801ea94 <wolfSSL_Malloc>
 80186c0:	6138      	str	r0, [r7, #16]
                              DYNAMIC_TYPE_SUBJECT_CN);
        if (ptr == NULL)
 80186c2:	693b      	ldr	r3, [r7, #16]
 80186c4:	2b00      	cmp	r3, #0
 80186c6:	d102      	bne.n	80186ce <ParseCert+0x50>
            return MEMORY_E;
 80186c8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80186cc:	e04b      	b.n	8018766 <ParseCert+0xe8>
        XMEMCPY(ptr, cert->subjectCN, (size_t)cert->subjectCNLen);
 80186ce:	68fb      	ldr	r3, [r7, #12]
 80186d0:	f8d3 1084 	ldr.w	r1, [r3, #132]	@ 0x84
 80186d4:	68fb      	ldr	r3, [r7, #12]
 80186d6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80186da:	461a      	mov	r2, r3
 80186dc:	6938      	ldr	r0, [r7, #16]
 80186de:	f00f ff61 	bl	80285a4 <memcpy>
        ptr[cert->subjectCNLen] = '\0';
 80186e2:	68fb      	ldr	r3, [r7, #12]
 80186e4:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80186e8:	461a      	mov	r2, r3
 80186ea:	693b      	ldr	r3, [r7, #16]
 80186ec:	4413      	add	r3, r2
 80186ee:	2200      	movs	r2, #0
 80186f0:	701a      	strb	r2, [r3, #0]
        cert->subjectCN = ptr;
 80186f2:	68fb      	ldr	r3, [r7, #12]
 80186f4:	693a      	ldr	r2, [r7, #16]
 80186f6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        cert->subjectCNStored = 1;
 80186fa:	68fa      	ldr	r2, [r7, #12]
 80186fc:	f892 34b4 	ldrb.w	r3, [r2, #1204]	@ 0x4b4
 8018700:	f043 0301 	orr.w	r3, r3, #1
 8018704:	f882 34b4 	strb.w	r3, [r2, #1204]	@ 0x4b4
#endif

#if (!defined(WOLFSSL_NO_MALLOC) && !defined(NO_WOLFSSL_CM_VERIFY)) || \
    defined(WOLFSSL_DYN_CERT)
    /* cert->publicKey not stored as copy if WOLFSSL_NO_MALLOC defined */
    if ((cert->keyOID == RSAk
 8018708:	68fb      	ldr	r3, [r7, #12]
 801870a:	69db      	ldr	r3, [r3, #28]
 801870c:	f240 2285 	movw	r2, #645	@ 0x285
 8018710:	4293      	cmp	r3, r2
 8018712:	d005      	beq.n	8018720 <ParseCert+0xa2>
    #ifdef WC_RSA_PSS
         || cert->keyOID == RSAPSSk
 8018714:	68fb      	ldr	r3, [r7, #12]
 8018716:	69db      	ldr	r3, [r3, #28]
 8018718:	f240 228e 	movw	r2, #654	@ 0x28e
 801871c:	4293      	cmp	r3, r2
 801871e:	d121      	bne.n	8018764 <ParseCert+0xe6>
    #endif
         ) && cert->publicKey != NULL && cert->pubKeySize > 0) {
 8018720:	68fb      	ldr	r3, [r7, #12]
 8018722:	681b      	ldr	r3, [r3, #0]
 8018724:	2b00      	cmp	r3, #0
 8018726:	d01d      	beq.n	8018764 <ParseCert+0xe6>
 8018728:	68fb      	ldr	r3, [r7, #12]
 801872a:	685b      	ldr	r3, [r3, #4]
 801872c:	2b00      	cmp	r3, #0
 801872e:	d019      	beq.n	8018764 <ParseCert+0xe6>
        ptr = (char*)XMALLOC(cert->pubKeySize, cert->heap,
 8018730:	68fb      	ldr	r3, [r7, #12]
 8018732:	685b      	ldr	r3, [r3, #4]
 8018734:	4618      	mov	r0, r3
 8018736:	f006 f9ad 	bl	801ea94 <wolfSSL_Malloc>
 801873a:	6138      	str	r0, [r7, #16]
                              DYNAMIC_TYPE_PUBLIC_KEY);
        if (ptr == NULL)
 801873c:	693b      	ldr	r3, [r7, #16]
 801873e:	2b00      	cmp	r3, #0
 8018740:	d102      	bne.n	8018748 <ParseCert+0xca>
            return MEMORY_E;
 8018742:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8018746:	e00e      	b.n	8018766 <ParseCert+0xe8>
        XMEMCPY(ptr, cert->publicKey, cert->pubKeySize);
 8018748:	68fb      	ldr	r3, [r7, #12]
 801874a:	6819      	ldr	r1, [r3, #0]
 801874c:	68fb      	ldr	r3, [r7, #12]
 801874e:	685b      	ldr	r3, [r3, #4]
 8018750:	461a      	mov	r2, r3
 8018752:	6938      	ldr	r0, [r7, #16]
 8018754:	f00f ff26 	bl	80285a4 <memcpy>
        cert->publicKey = (byte *)ptr;
 8018758:	68fb      	ldr	r3, [r7, #12]
 801875a:	693a      	ldr	r2, [r7, #16]
 801875c:	601a      	str	r2, [r3, #0]
        cert->pubKeyStored = 1;
 801875e:	68fb      	ldr	r3, [r7, #12]
 8018760:	2201      	movs	r2, #1
 8018762:	609a      	str	r2, [r3, #8]
    }
#endif

    return ret;
 8018764:	697b      	ldr	r3, [r7, #20]
}
 8018766:	4618      	mov	r0, r3
 8018768:	3718      	adds	r7, #24
 801876a:	46bd      	mov	sp, r7
 801876c:	bd80      	pop	{r7, pc}

0801876e <ParseCertRelative>:
    }
    return NULL;
}

int ParseCertRelative(DecodedCert* cert, int type, int verify, void* cm, Signer *extraCAList)
{
 801876e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8018772:	b092      	sub	sp, #72	@ 0x48
 8018774:	af08      	add	r7, sp, #32
 8018776:	6178      	str	r0, [r7, #20]
 8018778:	6139      	str	r1, [r7, #16]
 801877a:	60fa      	str	r2, [r7, #12]
 801877c:	60bb      	str	r3, [r7, #8]
    int    ret = 0;
 801877e:	2300      	movs	r3, #0
 8018780:	627b      	str	r3, [r7, #36]	@ 0x24
    int    idx = 0;
#endif
    byte*  sce_tsip_encRsaKeyIdx;
    (void)extraCAList;

    if (cert == NULL) {
 8018782:	697b      	ldr	r3, [r7, #20]
 8018784:	2b00      	cmp	r3, #0
 8018786:	d102      	bne.n	801878e <ParseCertRelative+0x20>
        return BAD_FUNC_ARG;
 8018788:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801878c:	e202      	b.n	8018b94 <ParseCertRelative+0x426>
#ifdef WOLFSSL_CERT_REQ
    if (type == CERTREQ_TYPE)
        cert->isCSR = 1;
#endif

    if (cert->sigCtx.state == SIG_STATE_BEGIN) {
 801878e:	697b      	ldr	r3, [r7, #20]
 8018790:	f8d3 3490 	ldr.w	r3, [r3, #1168]	@ 0x490
 8018794:	2b00      	cmp	r3, #0
 8018796:	f040 816f 	bne.w	8018a78 <ParseCertRelative+0x30a>
            }
        }
        else
#endif
        {
            ret = DecodeCert(cert, verify, &cert->criticalExt);
 801879a:	697b      	ldr	r3, [r7, #20]
 801879c:	f503 6396 	add.w	r3, r3, #1200	@ 0x4b0
 80187a0:	461a      	mov	r2, r3
 80187a2:	68f9      	ldr	r1, [r7, #12]
 80187a4:	6978      	ldr	r0, [r7, #20]
 80187a6:	f7ff ff55 	bl	8018654 <DecodeCert>
 80187aa:	6278      	str	r0, [r7, #36]	@ 0x24
            if (ret == WC_NO_ERR_TRACE(ASN_BEFORE_DATE_E) ||
 80187ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80187ae:	f113 0f96 	cmn.w	r3, #150	@ 0x96
 80187b2:	d003      	beq.n	80187bc <ParseCertRelative+0x4e>
 80187b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80187b6:	f113 0f97 	cmn.w	r3, #151	@ 0x97
 80187ba:	d109      	bne.n	80187d0 <ParseCertRelative+0x62>
                ret == WC_NO_ERR_TRACE(ASN_AFTER_DATE_E)) {
                cert->badDate = ret;
 80187bc:	697b      	ldr	r3, [r7, #20]
 80187be:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80187c0:	f8c3 24ac 	str.w	r2, [r3, #1196]	@ 0x4ac
                if (verify == VERIFY_SKIP_DATE)
 80187c4:	68fb      	ldr	r3, [r7, #12]
 80187c6:	2b05      	cmp	r3, #5
 80187c8:	d107      	bne.n	80187da <ParseCertRelative+0x6c>
                    ret = 0;
 80187ca:	2300      	movs	r3, #0
 80187cc:	627b      	str	r3, [r7, #36]	@ 0x24
                if (verify == VERIFY_SKIP_DATE)
 80187ce:	e004      	b.n	80187da <ParseCertRelative+0x6c>
            }
            else if (ret < 0) {
 80187d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80187d2:	2b00      	cmp	r3, #0
 80187d4:	da01      	bge.n	80187da <ParseCertRelative+0x6c>
                WOLFSSL_ERROR_VERBOSE(ret);
                return ret;
 80187d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80187d8:	e1dc      	b.n	8018b94 <ParseCertRelative+0x426>

    #ifndef ALLOW_INVALID_CERTSIGN
        /* https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.9
         *   If the cA boolean is not asserted, then the keyCertSign bit in the
         *   key usage extension MUST NOT be asserted. */
        if (!cert->isCA && cert->extKeyUsageSet &&
 80187da:	697b      	ldr	r3, [r7, #20]
 80187dc:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80187e0:	f003 0310 	and.w	r3, r3, #16
 80187e4:	b2db      	uxtb	r3, r3
 80187e6:	2b00      	cmp	r3, #0
 80187e8:	d111      	bne.n	801880e <ParseCertRelative+0xa0>
 80187ea:	697b      	ldr	r3, [r7, #20]
 80187ec:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80187f0:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 80187f4:	b2db      	uxtb	r3, r3
 80187f6:	2b00      	cmp	r3, #0
 80187f8:	d009      	beq.n	801880e <ParseCertRelative+0xa0>
                (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0) {
 80187fa:	697b      	ldr	r3, [r7, #20]
 80187fc:	f8b3 3420 	ldrh.w	r3, [r3, #1056]	@ 0x420
 8018800:	f003 0304 	and.w	r3, r3, #4
        if (!cert->isCA && cert->extKeyUsageSet &&
 8018804:	2b00      	cmp	r3, #0
 8018806:	d002      	beq.n	801880e <ParseCertRelative+0xa0>
            WOLFSSL_ERROR_VERBOSE(KEYUSAGE_E);
            return KEYUSAGE_E;
 8018808:	f06f 03e1 	mvn.w	r3, #225	@ 0xe1
 801880c:	e1c2      	b.n	8018b94 <ParseCertRelative+0x426>
        }
    #endif

    #ifndef NO_SKID
        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
 801880e:	697b      	ldr	r3, [r7, #20]
 8018810:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018814:	f003 0302 	and.w	r3, r3, #2
 8018818:	b2db      	uxtb	r3, r3
 801881a:	2b00      	cmp	r3, #0
 801881c:	d13a      	bne.n	8018894 <ParseCertRelative+0x126>
 801881e:	697b      	ldr	r3, [r7, #20]
 8018820:	681b      	ldr	r3, [r3, #0]
 8018822:	2b00      	cmp	r3, #0
 8018824:	d036      	beq.n	8018894 <ParseCertRelative+0x126>
                                                         cert->pubKeySize > 0) {
 8018826:	697b      	ldr	r3, [r7, #20]
 8018828:	685b      	ldr	r3, [r3, #4]
        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
 801882a:	2b00      	cmp	r3, #0
 801882c:	d032      	beq.n	8018894 <ParseCertRelative+0x126>
            if (cert->signatureOID == CTC_SM3wSM2) {
 801882e:	697b      	ldr	r3, [r7, #20]
 8018830:	699b      	ldr	r3, [r3, #24]
 8018832:	f5b3 7f39 	cmp.w	r3, #740	@ 0x2e4
 8018836:	d115      	bne.n	8018864 <ParseCertRelative+0xf6>
                /* TODO: GmSSL creates IDs this way but whole public key info
                 * block should be hashed. */
                ret = CalcHashId_ex(cert->publicKey + cert->pubKeySize - 65, 65,
 8018838:	697b      	ldr	r3, [r7, #20]
 801883a:	681a      	ldr	r2, [r3, #0]
 801883c:	697b      	ldr	r3, [r7, #20]
 801883e:	685b      	ldr	r3, [r3, #4]
 8018840:	3b41      	subs	r3, #65	@ 0x41
 8018842:	18d4      	adds	r4, r2, r3
                    cert->extSubjKeyId, HashIdAlg(cert->signatureOID));
 8018844:	697b      	ldr	r3, [r7, #20]
 8018846:	f503 7571 	add.w	r5, r3, #964	@ 0x3c4
                ret = CalcHashId_ex(cert->publicKey + cert->pubKeySize - 65, 65,
 801884a:	697b      	ldr	r3, [r7, #20]
 801884c:	699b      	ldr	r3, [r3, #24]
 801884e:	4618      	mov	r0, r3
 8018850:	f7fc ff50 	bl	80156f4 <HashIdAlg>
 8018854:	4603      	mov	r3, r0
 8018856:	462a      	mov	r2, r5
 8018858:	2141      	movs	r1, #65	@ 0x41
 801885a:	4620      	mov	r0, r4
 801885c:	f7fc ff66 	bl	801572c <CalcHashId_ex>
 8018860:	6278      	str	r0, [r7, #36]	@ 0x24
 8018862:	e012      	b.n	801888a <ParseCertRelative+0x11c>
            }
            else {
                ret = CalcHashId_ex(cert->publicKey, cert->pubKeySize,
 8018864:	697b      	ldr	r3, [r7, #20]
 8018866:	681c      	ldr	r4, [r3, #0]
 8018868:	697b      	ldr	r3, [r7, #20]
 801886a:	685d      	ldr	r5, [r3, #4]
                    cert->extSubjKeyId, HashIdAlg(cert->signatureOID));
 801886c:	697b      	ldr	r3, [r7, #20]
 801886e:	f503 7671 	add.w	r6, r3, #964	@ 0x3c4
                ret = CalcHashId_ex(cert->publicKey, cert->pubKeySize,
 8018872:	697b      	ldr	r3, [r7, #20]
 8018874:	699b      	ldr	r3, [r3, #24]
 8018876:	4618      	mov	r0, r3
 8018878:	f7fc ff3c 	bl	80156f4 <HashIdAlg>
 801887c:	4603      	mov	r3, r0
 801887e:	4632      	mov	r2, r6
 8018880:	4629      	mov	r1, r5
 8018882:	4620      	mov	r0, r4
 8018884:	f7fc ff52 	bl	801572c <CalcHashId_ex>
 8018888:	6278      	str	r0, [r7, #36]	@ 0x24
            }
            if (ret != 0) {
 801888a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801888c:	2b00      	cmp	r3, #0
 801888e:	d001      	beq.n	8018894 <ParseCertRelative+0x126>
                WOLFSSL_ERROR_VERBOSE(ret);
                return ret;
 8018890:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018892:	e17f      	b.n	8018b94 <ParseCertRelative+0x426>
            }
        }
    #endif /* !NO_SKID */

        if (!cert->selfSigned || (verify != NO_VERIFY && type != CA_TYPE &&
 8018894:	697b      	ldr	r3, [r7, #20]
 8018896:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 801889a:	f003 0302 	and.w	r3, r3, #2
 801889e:	b2db      	uxtb	r3, r3
 80188a0:	2b00      	cmp	r3, #0
 80188a2:	d00b      	beq.n	80188bc <ParseCertRelative+0x14e>
 80188a4:	68fb      	ldr	r3, [r7, #12]
 80188a6:	2b00      	cmp	r3, #0
 80188a8:	f000 8090 	beq.w	80189cc <ParseCertRelative+0x25e>
 80188ac:	693b      	ldr	r3, [r7, #16]
 80188ae:	2b06      	cmp	r3, #6
 80188b0:	f000 808c 	beq.w	80189cc <ParseCertRelative+0x25e>
 80188b4:	693b      	ldr	r3, [r7, #16]
 80188b6:	2b11      	cmp	r3, #17
 80188b8:	f000 8088 	beq.w	80189cc <ParseCertRelative+0x25e>
                                                   type != TRUSTED_PEER_TYPE)) {
            cert->ca = NULL;
 80188bc:	697b      	ldr	r3, [r7, #20]
 80188be:	2200      	movs	r2, #0
 80188c0:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
        if (extraCAList != NULL) {
            cert->ca = findSignerByName(extraCAList, cert->issuerHash);
        }
#endif
    #ifndef NO_SKID
            if (cert->ca == NULL && cert->extAuthKeyIdSet) {
 80188c4:	697b      	ldr	r3, [r7, #20]
 80188c6:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 80188ca:	2b00      	cmp	r3, #0
 80188cc:	d12c      	bne.n	8018928 <ParseCertRelative+0x1ba>
 80188ce:	697b      	ldr	r3, [r7, #20]
 80188d0:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80188d4:	f003 0304 	and.w	r3, r3, #4
 80188d8:	b2db      	uxtb	r3, r3
 80188da:	2b00      	cmp	r3, #0
 80188dc:	d024      	beq.n	8018928 <ParseCertRelative+0x1ba>
                cert->ca = GetCA(cm, cert->extAuthKeyId);
 80188de:	697b      	ldr	r3, [r7, #20]
 80188e0:	f503 737a 	add.w	r3, r3, #1000	@ 0x3e8
 80188e4:	4619      	mov	r1, r3
 80188e6:	68b8      	ldr	r0, [r7, #8]
 80188e8:	f7f3 fcfa 	bl	800c2e0 <GetCA>
 80188ec:	4602      	mov	r2, r0
 80188ee:	697b      	ldr	r3, [r7, #20]
 80188f0:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
        #ifdef WOLFSSL_AKID_NAME
                if (cert->ca == NULL) {
 80188f4:	697b      	ldr	r3, [r7, #20]
 80188f6:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 80188fa:	2b00      	cmp	r3, #0
 80188fc:	d114      	bne.n	8018928 <ParseCertRelative+0x1ba>
                    cert->ca = GetCAByAKID(cm, cert->extAuthKeyIdIssuer,
 80188fe:	697b      	ldr	r3, [r7, #20]
 8018900:	f8d3 140c 	ldr.w	r1, [r3, #1036]	@ 0x40c
 8018904:	697b      	ldr	r3, [r7, #20]
 8018906:	f8d3 2410 	ldr.w	r2, [r3, #1040]	@ 0x410
 801890a:	697b      	ldr	r3, [r7, #20]
 801890c:	f8d3 0414 	ldr.w	r0, [r3, #1044]	@ 0x414
 8018910:	697b      	ldr	r3, [r7, #20]
 8018912:	f8d3 3418 	ldr.w	r3, [r3, #1048]	@ 0x418
 8018916:	9300      	str	r3, [sp, #0]
 8018918:	4603      	mov	r3, r0
 801891a:	68b8      	ldr	r0, [r7, #8]
 801891c:	f7f3 fd26 	bl	800c36c <GetCAByAKID>
 8018920:	4602      	mov	r2, r0
 8018922:	697b      	ldr	r3, [r7, #20]
 8018924:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
                        cert->extAuthKeyIdIssuerSz, cert->extAuthKeyIdIssuerSN,
                        cert->extAuthKeyIdIssuerSNSz);
                }
        #endif
            }
            if (cert->ca == NULL && cert->extSubjKeyIdSet
 8018928:	697b      	ldr	r3, [r7, #20]
 801892a:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 801892e:	2b00      	cmp	r3, #0
 8018930:	d115      	bne.n	801895e <ParseCertRelative+0x1f0>
 8018932:	697b      	ldr	r3, [r7, #20]
 8018934:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018938:	f003 0302 	and.w	r3, r3, #2
 801893c:	b2db      	uxtb	r3, r3
 801893e:	2b00      	cmp	r3, #0
 8018940:	d00d      	beq.n	801895e <ParseCertRelative+0x1f0>
                                 && verify != VERIFY_OCSP) {
 8018942:	68fb      	ldr	r3, [r7, #12]
 8018944:	2b03      	cmp	r3, #3
 8018946:	d00a      	beq.n	801895e <ParseCertRelative+0x1f0>
                cert->ca = GetCA(cm, cert->extSubjKeyId);
 8018948:	697b      	ldr	r3, [r7, #20]
 801894a:	f503 7371 	add.w	r3, r3, #964	@ 0x3c4
 801894e:	4619      	mov	r1, r3
 8018950:	68b8      	ldr	r0, [r7, #8]
 8018952:	f7f3 fcc5 	bl	800c2e0 <GetCA>
 8018956:	4602      	mov	r2, r0
 8018958:	697b      	ldr	r3, [r7, #20]
 801895a:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
            }
            if (cert->ca != NULL && XMEMCMP(cert->issuerHash,
 801895e:	697b      	ldr	r3, [r7, #20]
 8018960:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018964:	2b00      	cmp	r3, #0
 8018966:	d011      	beq.n	801898c <ParseCertRelative+0x21e>
 8018968:	697b      	ldr	r3, [r7, #20]
 801896a:	f103 0060 	add.w	r0, r3, #96	@ 0x60
 801896e:	697b      	ldr	r3, [r7, #20]
 8018970:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018974:	3320      	adds	r3, #32
 8018976:	2220      	movs	r2, #32
 8018978:	4619      	mov	r1, r3
 801897a:	f00f fd7f 	bl	802847c <memcmp>
 801897e:	4603      	mov	r3, r0
 8018980:	2b00      	cmp	r3, #0
 8018982:	d003      	beq.n	801898c <ParseCertRelative+0x21e>
                    cert->ca->subjectNameHash, KEYID_SIZE) != 0) {
                cert->ca = NULL;
 8018984:	697b      	ldr	r3, [r7, #20]
 8018986:	2200      	movs	r2, #0
 8018988:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
            }
            if (cert->ca == NULL) {
 801898c:	697b      	ldr	r3, [r7, #20]
 801898e:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018992:	2b00      	cmp	r3, #0
 8018994:	d11a      	bne.n	80189cc <ParseCertRelative+0x25e>
                cert->ca = GetCAByName(cm, cert->issuerHash);
 8018996:	697b      	ldr	r3, [r7, #20]
 8018998:	3360      	adds	r3, #96	@ 0x60
 801899a:	4619      	mov	r1, r3
 801899c:	68b8      	ldr	r0, [r7, #8]
 801899e:	f7f3 fd5d 	bl	800c45c <GetCAByName>
 80189a2:	4602      	mov	r2, r0
 80189a4:	697b      	ldr	r3, [r7, #20]
 80189a6:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
                /* If AKID is available then this CA doesn't have the public
                 * key required */
                if (cert->ca && cert->extAuthKeyIdSet) {
 80189aa:	697b      	ldr	r3, [r7, #20]
 80189ac:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 80189b0:	2b00      	cmp	r3, #0
 80189b2:	d00b      	beq.n	80189cc <ParseCertRelative+0x25e>
 80189b4:	697b      	ldr	r3, [r7, #20]
 80189b6:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80189ba:	f003 0304 	and.w	r3, r3, #4
 80189be:	b2db      	uxtb	r3, r3
 80189c0:	2b00      	cmp	r3, #0
 80189c2:	d003      	beq.n	80189cc <ParseCertRelative+0x25e>
                    WOLFSSL_MSG("CA SKID doesn't match AKID");
                    cert->ca = NULL;
 80189c4:	697b      	ldr	r3, [r7, #20]
 80189c6:	2200      	movs	r2, #0
 80189c8:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
                WOLFSSL_MSG("CA found");
            }
        }

        /* Set to WOLFSSL_MAX_PATH_LEN by default in InitDecodedCert_ex */
        if (cert->pathLengthSet)
 80189cc:	697b      	ldr	r3, [r7, #20]
 80189ce:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 80189d2:	f003 0320 	and.w	r3, r3, #32
 80189d6:	b2db      	uxtb	r3, r3
 80189d8:	2b00      	cmp	r3, #0
 80189da:	d005      	beq.n	80189e8 <ParseCertRelative+0x27a>
            cert->maxPathLen = cert->pathLength;
 80189dc:	697b      	ldr	r3, [r7, #20]
 80189de:	f893 241c 	ldrb.w	r2, [r3, #1052]	@ 0x41c
 80189e2:	697b      	ldr	r3, [r7, #20]
 80189e4:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d

        if (!cert->selfSigned) {
 80189e8:	697b      	ldr	r3, [r7, #20]
 80189ea:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 80189ee:	f003 0302 	and.w	r3, r3, #2
 80189f2:	b2db      	uxtb	r3, r3
 80189f4:	2b00      	cmp	r3, #0
 80189f6:	d13f      	bne.n	8018a78 <ParseCertRelative+0x30a>
            /* Need to perform a pathlen check on anything that will be used
             * to sign certificates later on. Otherwise, pathLen doesn't
             * mean anything.
             * Nothing to check if we don't have the issuer of this cert. */
            if (type != CERT_TYPE && cert->isCA && cert->extKeyUsageSet &&
 80189f8:	693b      	ldr	r3, [r7, #16]
 80189fa:	2b00      	cmp	r3, #0
 80189fc:	d03c      	beq.n	8018a78 <ParseCertRelative+0x30a>
 80189fe:	697b      	ldr	r3, [r7, #20]
 8018a00:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018a04:	f003 0310 	and.w	r3, r3, #16
 8018a08:	b2db      	uxtb	r3, r3
 8018a0a:	2b00      	cmp	r3, #0
 8018a0c:	d034      	beq.n	8018a78 <ParseCertRelative+0x30a>
 8018a0e:	697b      	ldr	r3, [r7, #20]
 8018a10:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018a14:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8018a18:	b2db      	uxtb	r3, r3
 8018a1a:	2b00      	cmp	r3, #0
 8018a1c:	d02c      	beq.n	8018a78 <ParseCertRelative+0x30a>
                (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0 && cert->ca) {
 8018a1e:	697b      	ldr	r3, [r7, #20]
 8018a20:	f8b3 3420 	ldrh.w	r3, [r3, #1056]	@ 0x420
 8018a24:	f003 0304 	and.w	r3, r3, #4
            if (type != CERT_TYPE && cert->isCA && cert->extKeyUsageSet &&
 8018a28:	2b00      	cmp	r3, #0
 8018a2a:	d025      	beq.n	8018a78 <ParseCertRelative+0x30a>
                (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0 && cert->ca) {
 8018a2c:	697b      	ldr	r3, [r7, #20]
 8018a2e:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a32:	2b00      	cmp	r3, #0
 8018a34:	d020      	beq.n	8018a78 <ParseCertRelative+0x30a>
                if (cert->ca->maxPathLen == 0) {
 8018a36:	697b      	ldr	r3, [r7, #20]
 8018a38:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a3c:	7a9b      	ldrb	r3, [r3, #10]
 8018a3e:	2b00      	cmp	r3, #0
 8018a40:	d109      	bne.n	8018a56 <ParseCertRelative+0x2e8>
                    /* This cert CAN NOT be used as an intermediate cert. The
                     * issuer does not allow it. */
                    cert->maxPathLen = 0;
 8018a42:	697b      	ldr	r3, [r7, #20]
 8018a44:	2200      	movs	r2, #0
 8018a46:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d
                    if (verify != NO_VERIFY) {
 8018a4a:	68fb      	ldr	r3, [r7, #12]
 8018a4c:	2b00      	cmp	r3, #0
 8018a4e:	d013      	beq.n	8018a78 <ParseCertRelative+0x30a>
                        WOLFSSL_MSG("\tNon-entity cert, maxPathLen is 0");
                        WOLFSSL_MSG("\tmaxPathLen status: ERROR");
                        WOLFSSL_ERROR_VERBOSE(ASN_PATHLEN_INV_E);
                        return ASN_PATHLEN_INV_E;
 8018a50:	f06f 03ed 	mvn.w	r3, #237	@ 0xed
 8018a54:	e09e      	b.n	8018b94 <ParseCertRelative+0x426>
                    }
                }
                else {
                    cert->maxPathLen = (byte)min(cert->ca->maxPathLen - 1U,
 8018a56:	697b      	ldr	r3, [r7, #20]
 8018a58:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a5c:	7a9b      	ldrb	r3, [r3, #10]
 8018a5e:	1e5a      	subs	r2, r3, #1
                                           cert->maxPathLen);
 8018a60:	697b      	ldr	r3, [r7, #20]
 8018a62:	f893 341d 	ldrb.w	r3, [r3, #1053]	@ 0x41d
                    cert->maxPathLen = (byte)min(cert->ca->maxPathLen - 1U,
 8018a66:	4619      	mov	r1, r3
 8018a68:	4610      	mov	r0, r2
 8018a6a:	f7f9 fe31 	bl	80126d0 <min>
 8018a6e:	4603      	mov	r3, r0
 8018a70:	b2da      	uxtb	r2, r3
 8018a72:	697b      	ldr	r3, [r7, #20]
 8018a74:	f883 241d 	strb.w	r2, [r3, #1053]	@ 0x41d
    }

    sce_tsip_encRsaKeyIdx = cert->sce_tsip_encRsaKeyIdx;

#else
    sce_tsip_encRsaKeyIdx = NULL;
 8018a78:	2300      	movs	r3, #0
 8018a7a:	623b      	str	r3, [r7, #32]
#endif

    if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {
 8018a7c:	68fb      	ldr	r3, [r7, #12]
 8018a7e:	2b00      	cmp	r3, #0
 8018a80:	d072      	beq.n	8018b68 <ParseCertRelative+0x3fa>
 8018a82:	693b      	ldr	r3, [r7, #16]
 8018a84:	2b06      	cmp	r3, #6
 8018a86:	d06f      	beq.n	8018b68 <ParseCertRelative+0x3fa>
 8018a88:	693b      	ldr	r3, [r7, #16]
 8018a8a:	2b11      	cmp	r3, #17
 8018a8c:	d06c      	beq.n	8018b68 <ParseCertRelative+0x3fa>
        if (cert->ca) {
 8018a8e:	697b      	ldr	r3, [r7, #20]
 8018a90:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018a94:	2b00      	cmp	r3, #0
 8018a96:	d064      	beq.n	8018b62 <ParseCertRelative+0x3f4>
            if (verify == VERIFY || verify == VERIFY_OCSP ||
 8018a98:	68fb      	ldr	r3, [r7, #12]
 8018a9a:	2b01      	cmp	r3, #1
 8018a9c:	d005      	beq.n	8018aaa <ParseCertRelative+0x33c>
 8018a9e:	68fb      	ldr	r3, [r7, #12]
 8018aa0:	2b03      	cmp	r3, #3
 8018aa2:	d002      	beq.n	8018aaa <ParseCertRelative+0x33c>
 8018aa4:	68fb      	ldr	r3, [r7, #12]
 8018aa6:	2b05      	cmp	r3, #5
 8018aa8:	d142      	bne.n	8018b30 <ParseCertRelative+0x3c2>
                                                 verify == VERIFY_SKIP_DATE) {
                word32 keyOID = cert->ca->keyOID;
 8018aaa:	697b      	ldr	r3, [r7, #20]
 8018aac:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018ab0:	685b      	ldr	r3, [r3, #4]
 8018ab2:	61fb      	str	r3, [r7, #28]
                if (cert->selfSigned && (cert->signatureOID == CTC_SM3wSM2)) {
                    keyOID = SM2k;
                }
            #endif
                /* try to confirm/verify signature */
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018ab4:	697b      	ldr	r3, [r7, #20]
 8018ab6:	f203 4c74 	addw	ip, r3, #1140	@ 0x474
                        cert->source + cert->certBegin,
 8018aba:	697b      	ldr	r3, [r7, #20]
 8018abc:	f8d3 2364 	ldr.w	r2, [r3, #868]	@ 0x364
 8018ac0:	697b      	ldr	r3, [r7, #20]
 8018ac2:	68db      	ldr	r3, [r3, #12]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018ac4:	eb02 0e03 	add.w	lr, r2, r3
                        cert->sigIndex - cert->certBegin,
 8018ac8:	697b      	ldr	r3, [r7, #20]
 8018aca:	691a      	ldr	r2, [r3, #16]
 8018acc:	697b      	ldr	r3, [r7, #20]
 8018ace:	68db      	ldr	r3, [r3, #12]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018ad0:	eba2 0803 	sub.w	r8, r2, r3
                        cert->ca->publicKey, cert->ca->pubKeySize,
 8018ad4:	697b      	ldr	r3, [r7, #20]
 8018ad6:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018ada:	68db      	ldr	r3, [r3, #12]
 8018adc:	607b      	str	r3, [r7, #4]
                        cert->ca->publicKey, cert->ca->pubKeySize,
 8018ade:	697b      	ldr	r3, [r7, #20]
 8018ae0:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018ae4:	681b      	ldr	r3, [r3, #0]
 8018ae6:	697a      	ldr	r2, [r7, #20]
 8018ae8:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
 8018aec:	6979      	ldr	r1, [r7, #20]
 8018aee:	6949      	ldr	r1, [r1, #20]
 8018af0:	6978      	ldr	r0, [r7, #20]
 8018af2:	6980      	ldr	r0, [r0, #24]
                        keyOID, cert->signature, cert->sigLength,
                        cert->signatureOID,
                    #ifdef WC_RSA_PSS
                        cert->source + cert->sigParamsIndex,
 8018af4:	697c      	ldr	r4, [r7, #20]
 8018af6:	f8d4 5364 	ldr.w	r5, [r4, #868]	@ 0x364
 8018afa:	697c      	ldr	r4, [r7, #20]
 8018afc:	6a24      	ldr	r4, [r4, #32]
                if ((ret = ConfirmSignature(&cert->sigCtx,
 8018afe:	442c      	add	r4, r5
 8018b00:	697d      	ldr	r5, [r7, #20]
 8018b02:	6a6d      	ldr	r5, [r5, #36]	@ 0x24
 8018b04:	6a3e      	ldr	r6, [r7, #32]
 8018b06:	9607      	str	r6, [sp, #28]
 8018b08:	9506      	str	r5, [sp, #24]
 8018b0a:	9405      	str	r4, [sp, #20]
 8018b0c:	9004      	str	r0, [sp, #16]
 8018b0e:	9103      	str	r1, [sp, #12]
 8018b10:	9202      	str	r2, [sp, #8]
 8018b12:	69fa      	ldr	r2, [r7, #28]
 8018b14:	9201      	str	r2, [sp, #4]
 8018b16:	9300      	str	r3, [sp, #0]
 8018b18:	687b      	ldr	r3, [r7, #4]
 8018b1a:	4642      	mov	r2, r8
 8018b1c:	4671      	mov	r1, lr
 8018b1e:	4660      	mov	r0, ip
 8018b20:	f7fd fb4a 	bl	80161b8 <ConfirmSignature>
 8018b24:	6278      	str	r0, [r7, #36]	@ 0x24
 8018b26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b28:	2b00      	cmp	r3, #0
 8018b2a:	d001      	beq.n	8018b30 <ParseCertRelative+0x3c2>
                        sce_tsip_encRsaKeyIdx)) != 0) {
                    if (ret != WC_NO_ERR_TRACE(WC_PENDING_E)) {
                        WOLFSSL_MSG("Confirm signature failed");
                    }
                    WOLFSSL_ERROR_VERBOSE(ret);
                    return ret;
 8018b2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b2e:	e031      	b.n	8018b94 <ParseCertRelative+0x426>
                    }
                }
            #endif /* WOLFSSL_DUAL_ALG_CERTS */
            }
        #ifndef IGNORE_NAME_CONSTRAINTS
            if (verify == VERIFY || verify == VERIFY_OCSP ||
 8018b30:	68fb      	ldr	r3, [r7, #12]
 8018b32:	2b01      	cmp	r3, #1
 8018b34:	d008      	beq.n	8018b48 <ParseCertRelative+0x3da>
 8018b36:	68fb      	ldr	r3, [r7, #12]
 8018b38:	2b03      	cmp	r3, #3
 8018b3a:	d005      	beq.n	8018b48 <ParseCertRelative+0x3da>
 8018b3c:	68fb      	ldr	r3, [r7, #12]
 8018b3e:	2b04      	cmp	r3, #4
 8018b40:	d002      	beq.n	8018b48 <ParseCertRelative+0x3da>
                        verify == VERIFY_NAME || verify == VERIFY_SKIP_DATE) {
 8018b42:	68fb      	ldr	r3, [r7, #12]
 8018b44:	2b05      	cmp	r3, #5
 8018b46:	d10f      	bne.n	8018b68 <ParseCertRelative+0x3fa>
                /* check that this cert's name is permitted by the signer's
                 * name constraints */
                if (!ConfirmNameConstraints(cert->ca, cert)) {
 8018b48:	697b      	ldr	r3, [r7, #20]
 8018b4a:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8018b4e:	6979      	ldr	r1, [r7, #20]
 8018b50:	4618      	mov	r0, r3
 8018b52:	f7fd febb 	bl	80168cc <ConfirmNameConstraints>
 8018b56:	4603      	mov	r3, r0
 8018b58:	2b00      	cmp	r3, #0
 8018b5a:	d105      	bne.n	8018b68 <ParseCertRelative+0x3fa>
                    WOLFSSL_MSG("Confirm name constraint failed");
                    WOLFSSL_ERROR_VERBOSE(ASN_NAME_INVALID_E);
                    return ASN_NAME_INVALID_E;
 8018b5c:	f06f 03c5 	mvn.w	r3, #197	@ 0xc5
 8018b60:	e018      	b.n	8018b94 <ParseCertRelative+0x426>
            }
            else
#endif
            {
                WOLFSSL_ERROR_VERBOSE(ASN_NO_SIGNER_E);
                return ASN_NO_SIGNER_E;
 8018b62:	f06f 03bb 	mvn.w	r3, #187	@ 0xbb
 8018b66:	e015      	b.n	8018b94 <ParseCertRelative+0x426>

#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)
exit_pcr:
#endif

    if (cert->badDate != 0) {
 8018b68:	697b      	ldr	r3, [r7, #20]
 8018b6a:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	@ 0x4ac
 8018b6e:	2b00      	cmp	r3, #0
 8018b70:	d006      	beq.n	8018b80 <ParseCertRelative+0x412>
        if (verify != VERIFY_SKIP_DATE) {
 8018b72:	68fb      	ldr	r3, [r7, #12]
 8018b74:	2b05      	cmp	r3, #5
 8018b76:	d003      	beq.n	8018b80 <ParseCertRelative+0x412>
            return cert->badDate;
 8018b78:	697b      	ldr	r3, [r7, #20]
 8018b7a:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	@ 0x4ac
 8018b7e:	e009      	b.n	8018b94 <ParseCertRelative+0x426>
        }
        WOLFSSL_MSG("Date error: Verify option is skipping");
    }

    if (cert->criticalExt != 0)
 8018b80:	697b      	ldr	r3, [r7, #20]
 8018b82:	f8d3 34b0 	ldr.w	r3, [r3, #1200]	@ 0x4b0
 8018b86:	2b00      	cmp	r3, #0
 8018b88:	d003      	beq.n	8018b92 <ParseCertRelative+0x424>
        return cert->criticalExt;
 8018b8a:	697b      	ldr	r3, [r7, #20]
 8018b8c:	f8d3 34b0 	ldr.w	r3, [r3, #1200]	@ 0x4b0
 8018b90:	e000      	b.n	8018b94 <ParseCertRelative+0x426>

    return ret;
 8018b92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8018b94:	4618      	mov	r0, r3
 8018b96:	3728      	adds	r7, #40	@ 0x28
 8018b98:	46bd      	mov	sp, r7
 8018b9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08018b9e <FillSigner>:

int FillSigner(Signer* signer, DecodedCert* cert, int type, DerBuffer *der)
{
 8018b9e:	b580      	push	{r7, lr}
 8018ba0:	b086      	sub	sp, #24
 8018ba2:	af00      	add	r7, sp, #0
 8018ba4:	60f8      	str	r0, [r7, #12]
 8018ba6:	60b9      	str	r1, [r7, #8]
 8018ba8:	607a      	str	r2, [r7, #4]
 8018baa:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8018bac:	2300      	movs	r3, #0
 8018bae:	617b      	str	r3, [r7, #20]

    if (signer == NULL || cert == NULL)
 8018bb0:	68fb      	ldr	r3, [r7, #12]
 8018bb2:	2b00      	cmp	r3, #0
 8018bb4:	d002      	beq.n	8018bbc <FillSigner+0x1e>
 8018bb6:	68bb      	ldr	r3, [r7, #8]
 8018bb8:	2b00      	cmp	r3, #0
 8018bba:	d102      	bne.n	8018bc2 <FillSigner+0x24>
        return BAD_FUNC_ARG;
 8018bbc:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8018bc0:	e08c      	b.n	8018cdc <FillSigner+0x13e>
        }
    }
#endif /* WOLFSSL_DUAL_ALG_CERTS */

#if defined(WOLFSSL_AKID_NAME) || defined(HAVE_CRL)
    if (ret == 0 && signer != NULL)
 8018bc2:	697b      	ldr	r3, [r7, #20]
 8018bc4:	2b00      	cmp	r3, #0
 8018bc6:	d10f      	bne.n	8018be8 <FillSigner+0x4a>
 8018bc8:	68fb      	ldr	r3, [r7, #12]
 8018bca:	2b00      	cmp	r3, #0
 8018bcc:	d00c      	beq.n	8018be8 <FillSigner+0x4a>
        ret = CalcHashId(cert->serial, (word32)cert->serialSz,
 8018bce:	68bb      	ldr	r3, [r7, #8]
 8018bd0:	f503 705d 	add.w	r0, r3, #884	@ 0x374
 8018bd4:	68bb      	ldr	r3, [r7, #8]
 8018bd6:	f8d3 3394 	ldr.w	r3, [r3, #916]	@ 0x394
 8018bda:	4619      	mov	r1, r3
                         signer->serialHash);
 8018bdc:	68fb      	ldr	r3, [r7, #12]
 8018bde:	3360      	adds	r3, #96	@ 0x60
        ret = CalcHashId(cert->serial, (word32)cert->serialSz,
 8018be0:	461a      	mov	r2, r3
 8018be2:	f7fc fd92 	bl	801570a <CalcHashId>
 8018be6:	6178      	str	r0, [r7, #20]
#endif
    if (ret == 0 && signer != NULL) {
 8018be8:	697b      	ldr	r3, [r7, #20]
 8018bea:	2b00      	cmp	r3, #0
 8018bec:	d175      	bne.n	8018cda <FillSigner+0x13c>
 8018bee:	68fb      	ldr	r3, [r7, #12]
 8018bf0:	2b00      	cmp	r3, #0
 8018bf2:	d072      	beq.n	8018cda <FillSigner+0x13c>
    if (ret == 0 && signer != NULL) {
        XMEMCPY(signer->derCert->buffer, der->buffer, der->length);
    #else
    (void)der;
    #endif
        signer->keyOID         = cert->keyOID;
 8018bf4:	68bb      	ldr	r3, [r7, #8]
 8018bf6:	69da      	ldr	r2, [r3, #28]
 8018bf8:	68fb      	ldr	r3, [r7, #12]
 8018bfa:	605a      	str	r2, [r3, #4]
        if (cert->pubKeyStored) {
 8018bfc:	68bb      	ldr	r3, [r7, #8]
 8018bfe:	689b      	ldr	r3, [r3, #8]
 8018c00:	2b00      	cmp	r3, #0
 8018c02:	d007      	beq.n	8018c14 <FillSigner+0x76>
            signer->publicKey      = cert->publicKey;
 8018c04:	68bb      	ldr	r3, [r7, #8]
 8018c06:	681a      	ldr	r2, [r3, #0]
 8018c08:	68fb      	ldr	r3, [r7, #12]
 8018c0a:	60da      	str	r2, [r3, #12]
            signer->pubKeySize     = cert->pubKeySize;
 8018c0c:	68bb      	ldr	r3, [r7, #8]
 8018c0e:	685a      	ldr	r2, [r3, #4]
 8018c10:	68fb      	ldr	r3, [r7, #12]
 8018c12:	601a      	str	r2, [r3, #0]
        }

        if (cert->subjectCNStored) {
 8018c14:	68bb      	ldr	r3, [r7, #8]
 8018c16:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018c1a:	f003 0301 	and.w	r3, r3, #1
 8018c1e:	b2db      	uxtb	r3, r3
 8018c20:	2b00      	cmp	r3, #0
 8018c22:	d009      	beq.n	8018c38 <FillSigner+0x9a>
            signer->nameLen        = cert->subjectCNLen;
 8018c24:	68bb      	ldr	r3, [r7, #8]
 8018c26:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 8018c2a:	68fb      	ldr	r3, [r7, #12]
 8018c2c:	611a      	str	r2, [r3, #16]
            signer->name           = cert->subjectCN;
 8018c2e:	68bb      	ldr	r3, [r7, #8]
 8018c30:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 8018c34:	68fb      	ldr	r3, [r7, #12]
 8018c36:	615a      	str	r2, [r3, #20]
        }
        signer->maxPathLen     = cert->maxPathLen;
 8018c38:	68bb      	ldr	r3, [r7, #8]
 8018c3a:	f893 241d 	ldrb.w	r2, [r3, #1053]	@ 0x41d
 8018c3e:	68fb      	ldr	r3, [r7, #12]
 8018c40:	729a      	strb	r2, [r3, #10]
        signer->selfSigned     = cert->selfSigned;
 8018c42:	68bb      	ldr	r3, [r7, #8]
 8018c44:	f893 34b6 	ldrb.w	r3, [r3, #1206]	@ 0x4b6
 8018c48:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8018c4c:	b2d9      	uxtb	r1, r3
 8018c4e:	68fa      	ldr	r2, [r7, #12]
 8018c50:	7ad3      	ldrb	r3, [r2, #11]
 8018c52:	f361 0300 	bfi	r3, r1, #0, #1
 8018c56:	72d3      	strb	r3, [r2, #11]
    #ifndef IGNORE_NAME_CONSTRAINTS
        signer->permittedNames = cert->permittedNames;
 8018c58:	68bb      	ldr	r3, [r7, #8]
 8018c5a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8018c5c:	68fb      	ldr	r3, [r7, #12]
 8018c5e:	619a      	str	r2, [r3, #24]
        signer->excludedNames  = cert->excludedNames;
 8018c60:	68bb      	ldr	r3, [r7, #8]
 8018c62:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8018c64:	68fb      	ldr	r3, [r7, #12]
 8018c66:	61da      	str	r2, [r3, #28]
    #endif
    #ifndef NO_SKID
        XMEMCPY(signer->subjectKeyIdHash, cert->extSubjKeyId,
 8018c68:	68fb      	ldr	r3, [r7, #12]
 8018c6a:	f103 0040 	add.w	r0, r3, #64	@ 0x40
 8018c6e:	68bb      	ldr	r3, [r7, #8]
 8018c70:	f503 7371 	add.w	r3, r3, #964	@ 0x3c4
 8018c74:	2220      	movs	r2, #32
 8018c76:	4619      	mov	r1, r3
 8018c78:	f00f fc94 	bl	80285a4 <memcpy>
                SIGNER_DIGEST_SIZE);
    #endif
        XMEMCPY(signer->subjectNameHash, cert->subjectHash,
 8018c7c:	68fb      	ldr	r3, [r7, #12]
 8018c7e:	f103 0020 	add.w	r0, r3, #32
 8018c82:	68bb      	ldr	r3, [r7, #8]
 8018c84:	3340      	adds	r3, #64	@ 0x40
 8018c86:	2220      	movs	r2, #32
 8018c88:	4619      	mov	r1, r3
 8018c8a:	f00f fc8b 	bl	80285a4 <memcpy>
    #endif
    #ifdef HAVE_OCSP
        XMEMCPY(signer->subjectKeyHash, cert->subjectKeyHash,
                KEYID_SIZE);
    #endif
        signer->keyUsage = cert->extKeyUsageSet ? cert->extKeyUsage
 8018c8e:	68bb      	ldr	r3, [r7, #8]
 8018c90:	f893 34b4 	ldrb.w	r3, [r3, #1204]	@ 0x4b4
 8018c94:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8018c98:	b2db      	uxtb	r3, r3
 8018c9a:	2b00      	cmp	r3, #0
 8018c9c:	d003      	beq.n	8018ca6 <FillSigner+0x108>
 8018c9e:	68bb      	ldr	r3, [r7, #8]
 8018ca0:	f8b3 2420 	ldrh.w	r2, [r3, #1056]	@ 0x420
 8018ca4:	e001      	b.n	8018caa <FillSigner+0x10c>
 8018ca6:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8018caa:	68fb      	ldr	r3, [r7, #12]
 8018cac:	811a      	strh	r2, [r3, #8]
                                                : 0xFFFF;
        signer->next    = NULL; /* If Key Usage not set, all uses valid. */
 8018cae:	68fb      	ldr	r3, [r7, #12]
 8018cb0:	2200      	movs	r2, #0
 8018cb2:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        cert->publicKey = 0;    /* in case lock fails don't free here.   */
 8018cb6:	68bb      	ldr	r3, [r7, #8]
 8018cb8:	2200      	movs	r2, #0
 8018cba:	601a      	str	r2, [r3, #0]
        cert->subjectCN = 0;
 8018cbc:	68bb      	ldr	r3, [r7, #8]
 8018cbe:	2200      	movs	r2, #0
 8018cc0:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
    #ifndef IGNORE_NAME_CONSTRAINTS
        cert->permittedNames = NULL;
 8018cc4:	68bb      	ldr	r3, [r7, #8]
 8018cc6:	2200      	movs	r2, #0
 8018cc8:	639a      	str	r2, [r3, #56]	@ 0x38
        cert->excludedNames = NULL;
 8018cca:	68bb      	ldr	r3, [r7, #8]
 8018ccc:	2200      	movs	r2, #0
 8018cce:	63da      	str	r2, [r3, #60]	@ 0x3c
    #endif
        signer->type = (byte)type;
 8018cd0:	687b      	ldr	r3, [r7, #4]
 8018cd2:	b2da      	uxtb	r2, r3
 8018cd4:	68fb      	ldr	r3, [r7, #12]
 8018cd6:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80
    }
    return ret;
 8018cda:	697b      	ldr	r3, [r7, #20]
}
 8018cdc:	4618      	mov	r0, r3
 8018cde:	3718      	adds	r7, #24
 8018ce0:	46bd      	mov	sp, r7
 8018ce2:	bd80      	pop	{r7, pc}

08018ce4 <MakeSigner>:

/* Create and init an new signer */
Signer* MakeSigner(void* heap)
{
 8018ce4:	b580      	push	{r7, lr}
 8018ce6:	b084      	sub	sp, #16
 8018ce8:	af00      	add	r7, sp, #0
 8018cea:	6078      	str	r0, [r7, #4]
    Signer* signer = (Signer*) XMALLOC(sizeof(Signer), heap,
 8018cec:	2088      	movs	r0, #136	@ 0x88
 8018cee:	f005 fed1 	bl	801ea94 <wolfSSL_Malloc>
 8018cf2:	60f8      	str	r0, [r7, #12]
                                       DYNAMIC_TYPE_SIGNER);
    if (signer) {
 8018cf4:	68fb      	ldr	r3, [r7, #12]
 8018cf6:	2b00      	cmp	r3, #0
 8018cf8:	d004      	beq.n	8018d04 <MakeSigner+0x20>
        XMEMSET(signer, 0, sizeof(Signer));
 8018cfa:	2288      	movs	r2, #136	@ 0x88
 8018cfc:	2100      	movs	r1, #0
 8018cfe:	68f8      	ldr	r0, [r7, #12]
 8018d00:	f00f fbe6 	bl	80284d0 <memset>
    }
    (void)heap;

    return signer;
 8018d04:	68fb      	ldr	r3, [r7, #12]
}
 8018d06:	4618      	mov	r0, r3
 8018d08:	3710      	adds	r7, #16
 8018d0a:	46bd      	mov	sp, r7
 8018d0c:	bd80      	pop	{r7, pc}

08018d0e <FreeSigner>:
 * @param [in, out] signer  On in, signer object.
 *                          On out, pointer is no longer valid.
 * @param [in]      heap    Dynamic memory hint.
 */
void FreeSigner(Signer* signer, void* heap)
{
 8018d0e:	b580      	push	{r7, lr}
 8018d10:	b086      	sub	sp, #24
 8018d12:	af00      	add	r7, sp, #0
 8018d14:	6078      	str	r0, [r7, #4]
 8018d16:	6039      	str	r1, [r7, #0]
    (void)signer;
    (void)heap;
    XFREE(signer->name, heap, DYNAMIC_TYPE_SUBJECT_CN);
 8018d18:	687b      	ldr	r3, [r7, #4]
 8018d1a:	695b      	ldr	r3, [r3, #20]
 8018d1c:	617b      	str	r3, [r7, #20]
 8018d1e:	697b      	ldr	r3, [r7, #20]
 8018d20:	2b00      	cmp	r3, #0
 8018d22:	d002      	beq.n	8018d2a <FreeSigner+0x1c>
 8018d24:	6978      	ldr	r0, [r7, #20]
 8018d26:	f005 fed1 	bl	801eacc <wolfSSL_Free>
    XFREE((void*)signer->publicKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);
 8018d2a:	687b      	ldr	r3, [r7, #4]
 8018d2c:	68db      	ldr	r3, [r3, #12]
 8018d2e:	613b      	str	r3, [r7, #16]
 8018d30:	693b      	ldr	r3, [r7, #16]
 8018d32:	2b00      	cmp	r3, #0
 8018d34:	d002      	beq.n	8018d3c <FreeSigner+0x2e>
 8018d36:	6938      	ldr	r0, [r7, #16]
 8018d38:	f005 fec8 	bl	801eacc <wolfSSL_Free>
#ifdef WOLFSSL_DUAL_ALG_CERTS
    XFREE(signer->sapkiDer, heap, DYNAMIC_TYPE_PUBLIC_KEY);
#endif
#ifndef IGNORE_NAME_CONSTRAINTS
    if (signer->permittedNames)
 8018d3c:	687b      	ldr	r3, [r7, #4]
 8018d3e:	699b      	ldr	r3, [r3, #24]
 8018d40:	2b00      	cmp	r3, #0
 8018d42:	d005      	beq.n	8018d50 <FreeSigner+0x42>
        FreeNameSubtrees(signer->permittedNames, heap);
 8018d44:	687b      	ldr	r3, [r7, #4]
 8018d46:	699b      	ldr	r3, [r3, #24]
 8018d48:	6839      	ldr	r1, [r7, #0]
 8018d4a:	4618      	mov	r0, r3
 8018d4c:	f7fc fa84 	bl	8015258 <FreeNameSubtrees>
    if (signer->excludedNames)
 8018d50:	687b      	ldr	r3, [r7, #4]
 8018d52:	69db      	ldr	r3, [r3, #28]
 8018d54:	2b00      	cmp	r3, #0
 8018d56:	d005      	beq.n	8018d64 <FreeSigner+0x56>
        FreeNameSubtrees(signer->excludedNames, heap);
 8018d58:	687b      	ldr	r3, [r7, #4]
 8018d5a:	69db      	ldr	r3, [r3, #28]
 8018d5c:	6839      	ldr	r1, [r7, #0]
 8018d5e:	4618      	mov	r0, r3
 8018d60:	f7fc fa7a 	bl	8015258 <FreeNameSubtrees>
#endif
#ifdef WOLFSSL_SIGNER_DER_CERT
    FreeDer(&signer->derCert);
#endif
    XFREE(signer, heap, DYNAMIC_TYPE_SIGNER);
 8018d64:	687b      	ldr	r3, [r7, #4]
 8018d66:	60fb      	str	r3, [r7, #12]
 8018d68:	68fb      	ldr	r3, [r7, #12]
 8018d6a:	2b00      	cmp	r3, #0
 8018d6c:	d002      	beq.n	8018d74 <FreeSigner+0x66>
 8018d6e:	68f8      	ldr	r0, [r7, #12]
 8018d70:	f005 feac 	bl	801eacc <wolfSSL_Free>
}
 8018d74:	bf00      	nop
 8018d76:	3718      	adds	r7, #24
 8018d78:	46bd      	mov	sp, r7
 8018d7a:	bd80      	pop	{r7, pc}

08018d7c <FreeSignerTable>:
 * @param [in, out] table   Array of signer objects.
 * @param [in]      rows    Number of entries in table.
 * @param [in]      heap    Dynamic memory hint.
 */
void FreeSignerTable(Signer** table, int rows, void* heap)
{
 8018d7c:	b580      	push	{r7, lr}
 8018d7e:	b088      	sub	sp, #32
 8018d80:	af00      	add	r7, sp, #0
 8018d82:	60f8      	str	r0, [r7, #12]
 8018d84:	60b9      	str	r1, [r7, #8]
 8018d86:	607a      	str	r2, [r7, #4]
    int i;

    for (i = 0; i < rows; i++) {
 8018d88:	2300      	movs	r3, #0
 8018d8a:	61fb      	str	r3, [r7, #28]
 8018d8c:	e01c      	b.n	8018dc8 <FreeSignerTable+0x4c>
        Signer* signer = table[i];
 8018d8e:	69fb      	ldr	r3, [r7, #28]
 8018d90:	009b      	lsls	r3, r3, #2
 8018d92:	68fa      	ldr	r2, [r7, #12]
 8018d94:	4413      	add	r3, r2
 8018d96:	681b      	ldr	r3, [r3, #0]
 8018d98:	61bb      	str	r3, [r7, #24]
        while (signer) {
 8018d9a:	e009      	b.n	8018db0 <FreeSignerTable+0x34>
            Signer* next = signer->next;
 8018d9c:	69bb      	ldr	r3, [r7, #24]
 8018d9e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8018da2:	617b      	str	r3, [r7, #20]
            FreeSigner(signer, heap);
 8018da4:	6879      	ldr	r1, [r7, #4]
 8018da6:	69b8      	ldr	r0, [r7, #24]
 8018da8:	f7ff ffb1 	bl	8018d0e <FreeSigner>
            signer = next;
 8018dac:	697b      	ldr	r3, [r7, #20]
 8018dae:	61bb      	str	r3, [r7, #24]
        while (signer) {
 8018db0:	69bb      	ldr	r3, [r7, #24]
 8018db2:	2b00      	cmp	r3, #0
 8018db4:	d1f2      	bne.n	8018d9c <FreeSignerTable+0x20>
        }
        table[i] = NULL;
 8018db6:	69fb      	ldr	r3, [r7, #28]
 8018db8:	009b      	lsls	r3, r3, #2
 8018dba:	68fa      	ldr	r2, [r7, #12]
 8018dbc:	4413      	add	r3, r2
 8018dbe:	2200      	movs	r2, #0
 8018dc0:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rows; i++) {
 8018dc2:	69fb      	ldr	r3, [r7, #28]
 8018dc4:	3301      	adds	r3, #1
 8018dc6:	61fb      	str	r3, [r7, #28]
 8018dc8:	69fa      	ldr	r2, [r7, #28]
 8018dca:	68bb      	ldr	r3, [r7, #8]
 8018dcc:	429a      	cmp	r2, r3
 8018dce:	dbde      	blt.n	8018d8e <FreeSignerTable+0x12>
    }
}
 8018dd0:	bf00      	nop
 8018dd2:	bf00      	nop
 8018dd4:	3720      	adds	r7, #32
 8018dd6:	46bd      	mov	sp, r7
 8018dd8:	bd80      	pop	{r7, pc}
	...

08018ddc <AllocDer>:
#ifndef NO_CERTS

/* TODO: consider moving PEM code out to a different file. */

int AllocDer(DerBuffer** pDer, word32 length, int type, void* heap)
{
 8018ddc:	b580      	push	{r7, lr}
 8018dde:	b088      	sub	sp, #32
 8018de0:	af00      	add	r7, sp, #0
 8018de2:	60f8      	str	r0, [r7, #12]
 8018de4:	60b9      	str	r1, [r7, #8]
 8018de6:	607a      	str	r2, [r7, #4]
 8018de8:	603b      	str	r3, [r7, #0]
    int ret = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 8018dea:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8018dee:	61fb      	str	r3, [r7, #28]
    if (pDer) {
 8018df0:	68fb      	ldr	r3, [r7, #12]
 8018df2:	2b00      	cmp	r3, #0
 8018df4:	f000 80a1 	beq.w	8018f3a <AllocDer+0x15e>
        int dynType = 0;
 8018df8:	2300      	movs	r3, #0
 8018dfa:	61bb      	str	r3, [r7, #24]
        DerBuffer* der;

        /* Determine dynamic type */
        switch (type) {
 8018dfc:	687b      	ldr	r3, [r7, #4]
 8018dfe:	2b2a      	cmp	r3, #42	@ 0x2a
 8018e00:	d86a      	bhi.n	8018ed8 <AllocDer+0xfc>
 8018e02:	a201      	add	r2, pc, #4	@ (adr r2, 8018e08 <AllocDer+0x2c>)
 8018e04:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018e08:	08018ebb 	.word	0x08018ebb
 8018e0c:	08018ed9 	.word	0x08018ed9
 8018e10:	08018ed9 	.word	0x08018ed9
 8018e14:	08018ed9 	.word	0x08018ed9
 8018e18:	08018ed9 	.word	0x08018ed9
 8018e1c:	08018ec1 	.word	0x08018ec1
 8018e20:	08018eb5 	.word	0x08018eb5
 8018e24:	08018ed9 	.word	0x08018ed9
 8018e28:	08018ed9 	.word	0x08018ed9
 8018e2c:	08018ed9 	.word	0x08018ed9
 8018e30:	08018ed9 	.word	0x08018ed9
 8018e34:	08018ec7 	.word	0x08018ec7
 8018e38:	08018ecd 	.word	0x08018ecd
 8018e3c:	08018ed3 	.word	0x08018ed3
 8018e40:	08018ed9 	.word	0x08018ed9
 8018e44:	08018ed9 	.word	0x08018ed9
 8018e48:	08018ed9 	.word	0x08018ed9
 8018e4c:	08018ed9 	.word	0x08018ed9
 8018e50:	08018ed9 	.word	0x08018ed9
 8018e54:	08018ed9 	.word	0x08018ed9
 8018e58:	08018ed9 	.word	0x08018ed9
 8018e5c:	08018ed9 	.word	0x08018ed9
 8018e60:	08018ed9 	.word	0x08018ed9
 8018e64:	08018ed9 	.word	0x08018ed9
 8018e68:	08018ed9 	.word	0x08018ed9
 8018e6c:	08018ed9 	.word	0x08018ed9
 8018e70:	08018ed9 	.word	0x08018ed9
 8018e74:	08018ed9 	.word	0x08018ed9
 8018e78:	08018ed9 	.word	0x08018ed9
 8018e7c:	08018ed9 	.word	0x08018ed9
 8018e80:	08018ed9 	.word	0x08018ed9
 8018e84:	08018ed9 	.word	0x08018ed9
 8018e88:	08018ed9 	.word	0x08018ed9
 8018e8c:	08018ed9 	.word	0x08018ed9
 8018e90:	08018ed9 	.word	0x08018ed9
 8018e94:	08018ed9 	.word	0x08018ed9
 8018e98:	08018ed9 	.word	0x08018ed9
 8018e9c:	08018ed9 	.word	0x08018ed9
 8018ea0:	08018ed9 	.word	0x08018ed9
 8018ea4:	08018ed9 	.word	0x08018ed9
 8018ea8:	08018ed9 	.word	0x08018ed9
 8018eac:	08018ed9 	.word	0x08018ed9
 8018eb0:	08018ebb 	.word	0x08018ebb
            case CA_TYPE:   dynType = DYNAMIC_TYPE_CA;   break;
 8018eb4:	2301      	movs	r3, #1
 8018eb6:	61bb      	str	r3, [r7, #24]
 8018eb8:	e011      	b.n	8018ede <AllocDer+0x102>
            case CHAIN_CERT_TYPE:
            case CERT_TYPE: dynType = DYNAMIC_TYPE_CERT; break;
 8018eba:	2302      	movs	r3, #2
 8018ebc:	61bb      	str	r3, [r7, #24]
 8018ebe:	e00e      	b.n	8018ede <AllocDer+0x102>
            case CRL_TYPE:  dynType = DYNAMIC_TYPE_CRL;  break;
 8018ec0:	2316      	movs	r3, #22
 8018ec2:	61bb      	str	r3, [r7, #24]
 8018ec4:	e00b      	b.n	8018ede <AllocDer+0x102>
            case DSA_TYPE:  dynType = DYNAMIC_TYPE_DSA;  break;
 8018ec6:	2315      	movs	r3, #21
 8018ec8:	61bb      	str	r3, [r7, #24]
 8018eca:	e008      	b.n	8018ede <AllocDer+0x102>
            case ECC_TYPE:  dynType = DYNAMIC_TYPE_ECC;  break;
 8018ecc:	2325      	movs	r3, #37	@ 0x25
 8018ece:	61bb      	str	r3, [r7, #24]
 8018ed0:	e005      	b.n	8018ede <AllocDer+0x102>
            case RSA_TYPE:  dynType = DYNAMIC_TYPE_RSA;  break;
 8018ed2:	230a      	movs	r3, #10
 8018ed4:	61bb      	str	r3, [r7, #24]
 8018ed6:	e002      	b.n	8018ede <AllocDer+0x102>
            default:        dynType = DYNAMIC_TYPE_KEY;  break;
 8018ed8:	2303      	movs	r3, #3
 8018eda:	61bb      	str	r3, [r7, #24]
 8018edc:	bf00      	nop
        }

        /* Setup new buffer */
        *pDer = (DerBuffer*)XMALLOC(sizeof(DerBuffer) + length, heap, dynType);
 8018ede:	68bb      	ldr	r3, [r7, #8]
 8018ee0:	3314      	adds	r3, #20
 8018ee2:	4618      	mov	r0, r3
 8018ee4:	f005 fdd6 	bl	801ea94 <wolfSSL_Malloc>
 8018ee8:	4602      	mov	r2, r0
 8018eea:	68fb      	ldr	r3, [r7, #12]
 8018eec:	601a      	str	r2, [r3, #0]
        if (*pDer == NULL) {
 8018eee:	68fb      	ldr	r3, [r7, #12]
 8018ef0:	681b      	ldr	r3, [r3, #0]
 8018ef2:	2b00      	cmp	r3, #0
 8018ef4:	d102      	bne.n	8018efc <AllocDer+0x120>
            return MEMORY_E;
 8018ef6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8018efa:	e022      	b.n	8018f42 <AllocDer+0x166>
        }
        XMEMSET(*pDer, 0, sizeof(DerBuffer) + length);
 8018efc:	68fb      	ldr	r3, [r7, #12]
 8018efe:	6818      	ldr	r0, [r3, #0]
 8018f00:	68bb      	ldr	r3, [r7, #8]
 8018f02:	3314      	adds	r3, #20
 8018f04:	461a      	mov	r2, r3
 8018f06:	2100      	movs	r1, #0
 8018f08:	f00f fae2 	bl	80284d0 <memset>

        der = *pDer;
 8018f0c:	68fb      	ldr	r3, [r7, #12]
 8018f0e:	681b      	ldr	r3, [r3, #0]
 8018f10:	617b      	str	r3, [r7, #20]
        der->type = type;
 8018f12:	697b      	ldr	r3, [r7, #20]
 8018f14:	687a      	ldr	r2, [r7, #4]
 8018f16:	60da      	str	r2, [r3, #12]
        der->dynType = dynType; /* Cache this for FreeDer */
 8018f18:	697b      	ldr	r3, [r7, #20]
 8018f1a:	69ba      	ldr	r2, [r7, #24]
 8018f1c:	611a      	str	r2, [r3, #16]
        der->heap = heap;
 8018f1e:	697b      	ldr	r3, [r7, #20]
 8018f20:	683a      	ldr	r2, [r7, #0]
 8018f22:	605a      	str	r2, [r3, #4]
        der->buffer = (byte*)der + sizeof(DerBuffer);
 8018f24:	697b      	ldr	r3, [r7, #20]
 8018f26:	f103 0214 	add.w	r2, r3, #20
 8018f2a:	697b      	ldr	r3, [r7, #20]
 8018f2c:	601a      	str	r2, [r3, #0]
        der->length = length;
 8018f2e:	697b      	ldr	r3, [r7, #20]
 8018f30:	68ba      	ldr	r2, [r7, #8]
 8018f32:	609a      	str	r2, [r3, #8]
        ret = 0; /* Success */
 8018f34:	2300      	movs	r3, #0
 8018f36:	61fb      	str	r3, [r7, #28]
 8018f38:	e002      	b.n	8018f40 <AllocDer+0x164>
    } else {
        ret = BAD_FUNC_ARG;
 8018f3a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8018f3e:	61fb      	str	r3, [r7, #28]
    }
    return ret;
 8018f40:	69fb      	ldr	r3, [r7, #28]
}
 8018f42:	4618      	mov	r0, r3
 8018f44:	3720      	adds	r7, #32
 8018f46:	46bd      	mov	sp, r7
 8018f48:	bd80      	pop	{r7, pc}
 8018f4a:	bf00      	nop

08018f4c <AllocCopyDer>:

int AllocCopyDer(DerBuffer** pDer, const unsigned char* buff, word32 length,
    int type, void* heap)
{
 8018f4c:	b580      	push	{r7, lr}
 8018f4e:	b086      	sub	sp, #24
 8018f50:	af00      	add	r7, sp, #0
 8018f52:	60f8      	str	r0, [r7, #12]
 8018f54:	60b9      	str	r1, [r7, #8]
 8018f56:	607a      	str	r2, [r7, #4]
 8018f58:	603b      	str	r3, [r7, #0]
    int ret = AllocDer(pDer, length, type, heap);
 8018f5a:	6a3b      	ldr	r3, [r7, #32]
 8018f5c:	683a      	ldr	r2, [r7, #0]
 8018f5e:	6879      	ldr	r1, [r7, #4]
 8018f60:	68f8      	ldr	r0, [r7, #12]
 8018f62:	f7ff ff3b 	bl	8018ddc <AllocDer>
 8018f66:	6178      	str	r0, [r7, #20]
    if (ret == 0) {
 8018f68:	697b      	ldr	r3, [r7, #20]
 8018f6a:	2b00      	cmp	r3, #0
 8018f6c:	d107      	bne.n	8018f7e <AllocCopyDer+0x32>
        XMEMCPY((*pDer)->buffer, buff, length);
 8018f6e:	68fb      	ldr	r3, [r7, #12]
 8018f70:	681b      	ldr	r3, [r3, #0]
 8018f72:	681b      	ldr	r3, [r3, #0]
 8018f74:	687a      	ldr	r2, [r7, #4]
 8018f76:	68b9      	ldr	r1, [r7, #8]
 8018f78:	4618      	mov	r0, r3
 8018f7a:	f00f fb13 	bl	80285a4 <memcpy>
    }

    return ret;
 8018f7e:	697b      	ldr	r3, [r7, #20]
}
 8018f80:	4618      	mov	r0, r3
 8018f82:	3718      	adds	r7, #24
 8018f84:	46bd      	mov	sp, r7
 8018f86:	bd80      	pop	{r7, pc}

08018f88 <FreeDer>:

void FreeDer(DerBuffer** pDer)
{
 8018f88:	b580      	push	{r7, lr}
 8018f8a:	b084      	sub	sp, #16
 8018f8c:	af00      	add	r7, sp, #0
 8018f8e:	6078      	str	r0, [r7, #4]
    if (pDer && *pDer) {
 8018f90:	687b      	ldr	r3, [r7, #4]
 8018f92:	2b00      	cmp	r3, #0
 8018f94:	d02b      	beq.n	8018fee <FreeDer+0x66>
 8018f96:	687b      	ldr	r3, [r7, #4]
 8018f98:	681b      	ldr	r3, [r3, #0]
 8018f9a:	2b00      	cmp	r3, #0
 8018f9c:	d027      	beq.n	8018fee <FreeDer+0x66>
        DerBuffer* der = (DerBuffer*)*pDer;
 8018f9e:	687b      	ldr	r3, [r7, #4]
 8018fa0:	681b      	ldr	r3, [r3, #0]
 8018fa2:	60fb      	str	r3, [r7, #12]

        /* ForceZero private keys */
        if (((der->type == PRIVATEKEY_TYPE) ||
 8018fa4:	68fb      	ldr	r3, [r7, #12]
 8018fa6:	68db      	ldr	r3, [r3, #12]
 8018fa8:	2b01      	cmp	r3, #1
 8018faa:	d003      	beq.n	8018fb4 <FreeDer+0x2c>
             (der->type == ALT_PRIVATEKEY_TYPE)) && der->buffer != NULL) {
 8018fac:	68fb      	ldr	r3, [r7, #12]
 8018fae:	68db      	ldr	r3, [r3, #12]
        if (((der->type == PRIVATEKEY_TYPE) ||
 8018fb0:	2b02      	cmp	r3, #2
 8018fb2:	d10b      	bne.n	8018fcc <FreeDer+0x44>
             (der->type == ALT_PRIVATEKEY_TYPE)) && der->buffer != NULL) {
 8018fb4:	68fb      	ldr	r3, [r7, #12]
 8018fb6:	681b      	ldr	r3, [r3, #0]
 8018fb8:	2b00      	cmp	r3, #0
 8018fba:	d007      	beq.n	8018fcc <FreeDer+0x44>
            ForceZero(der->buffer, der->length);
 8018fbc:	68fb      	ldr	r3, [r7, #12]
 8018fbe:	681a      	ldr	r2, [r3, #0]
 8018fc0:	68fb      	ldr	r3, [r7, #12]
 8018fc2:	689b      	ldr	r3, [r3, #8]
 8018fc4:	4619      	mov	r1, r3
 8018fc6:	4610      	mov	r0, r2
 8018fc8:	f7f9 fb69 	bl	801269e <ForceZero>
        }
        der->buffer = NULL;
 8018fcc:	68fb      	ldr	r3, [r7, #12]
 8018fce:	2200      	movs	r2, #0
 8018fd0:	601a      	str	r2, [r3, #0]
        der->length = 0;
 8018fd2:	68fb      	ldr	r3, [r7, #12]
 8018fd4:	2200      	movs	r2, #0
 8018fd6:	609a      	str	r2, [r3, #8]
        XFREE(der, der->heap, der->dynType);
 8018fd8:	68fb      	ldr	r3, [r7, #12]
 8018fda:	60bb      	str	r3, [r7, #8]
 8018fdc:	68bb      	ldr	r3, [r7, #8]
 8018fde:	2b00      	cmp	r3, #0
 8018fe0:	d002      	beq.n	8018fe8 <FreeDer+0x60>
 8018fe2:	68b8      	ldr	r0, [r7, #8]
 8018fe4:	f005 fd72 	bl	801eacc <wolfSSL_Free>

        *pDer = NULL;
 8018fe8:	687b      	ldr	r3, [r7, #4]
 8018fea:	2200      	movs	r2, #0
 8018fec:	601a      	str	r2, [r3, #0]
    }
}
 8018fee:	bf00      	nop
 8018ff0:	3710      	adds	r7, #16
 8018ff2:	46bd      	mov	sp, r7
 8018ff4:	bd80      	pop	{r7, pc}

08018ff6 <SkipEndOfLineChars>:
                                             "-----END X509 CRL-----");

#ifdef WOLFSSL_PEM_TO_DER
static WC_INLINE const char* SkipEndOfLineChars(const char* line,
                                                const char* endOfLine)
{
 8018ff6:	b480      	push	{r7}
 8018ff8:	b083      	sub	sp, #12
 8018ffa:	af00      	add	r7, sp, #0
 8018ffc:	6078      	str	r0, [r7, #4]
 8018ffe:	6039      	str	r1, [r7, #0]
    /* eat end of line characters */
    while (line < endOfLine &&
 8019000:	e002      	b.n	8019008 <SkipEndOfLineChars+0x12>
              (line[0] == '\r' || line[0] == '\n')) {
        line++;
 8019002:	687b      	ldr	r3, [r7, #4]
 8019004:	3301      	adds	r3, #1
 8019006:	607b      	str	r3, [r7, #4]
    while (line < endOfLine &&
 8019008:	687a      	ldr	r2, [r7, #4]
 801900a:	683b      	ldr	r3, [r7, #0]
 801900c:	429a      	cmp	r2, r3
 801900e:	d207      	bcs.n	8019020 <SkipEndOfLineChars+0x2a>
              (line[0] == '\r' || line[0] == '\n')) {
 8019010:	687b      	ldr	r3, [r7, #4]
 8019012:	781b      	ldrb	r3, [r3, #0]
    while (line < endOfLine &&
 8019014:	2b0d      	cmp	r3, #13
 8019016:	d0f4      	beq.n	8019002 <SkipEndOfLineChars+0xc>
              (line[0] == '\r' || line[0] == '\n')) {
 8019018:	687b      	ldr	r3, [r7, #4]
 801901a:	781b      	ldrb	r3, [r3, #0]
 801901c:	2b0a      	cmp	r3, #10
 801901e:	d0f0      	beq.n	8019002 <SkipEndOfLineChars+0xc>
    }
    return line;
 8019020:	687b      	ldr	r3, [r7, #4]
}
 8019022:	4618      	mov	r0, r3
 8019024:	370c      	adds	r7, #12
 8019026:	46bd      	mov	sp, r7
 8019028:	f85d 7b04 	ldr.w	r7, [sp], #4
 801902c:	4770      	bx	lr
	...

08019030 <wc_PemGetHeaderFooter>:
#endif

int wc_PemGetHeaderFooter(int type, const char** header, const char** footer)
{
 8019030:	b480      	push	{r7}
 8019032:	b087      	sub	sp, #28
 8019034:	af00      	add	r7, sp, #0
 8019036:	60f8      	str	r0, [r7, #12]
 8019038:	60b9      	str	r1, [r7, #8]
 801903a:	607a      	str	r2, [r7, #4]
    int ret = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 801903c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8019040:	617b      	str	r3, [r7, #20]

    switch (type) {
 8019042:	68fb      	ldr	r3, [r7, #12]
 8019044:	2b2a      	cmp	r3, #42	@ 0x2a
 8019046:	f200 80fe 	bhi.w	8019246 <wc_PemGetHeaderFooter+0x216>
 801904a:	a201      	add	r2, pc, #4	@ (adr r2, 8019050 <wc_PemGetHeaderFooter+0x20>)
 801904c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019050:	080190fd 	.word	0x080190fd
 8019054:	080191b1 	.word	0x080191b1
 8019058:	08019247 	.word	0x08019247
 801905c:	08019139 	.word	0x08019139
 8019060:	08019247 	.word	0x08019247
 8019064:	0801911b 	.word	0x0801911b
 8019068:	080190fd 	.word	0x080190fd
 801906c:	08019175 	.word	0x08019175
 8019070:	08019247 	.word	0x08019247
 8019074:	08019247 	.word	0x08019247
 8019078:	08019247 	.word	0x08019247
 801907c:	08019247 	.word	0x08019247
 8019080:	08019175 	.word	0x08019175
 8019084:	080191b1 	.word	0x080191b1
 8019088:	080191cf 	.word	0x080191cf
 801908c:	080191ed 	.word	0x080191ed
 8019090:	080191cf 	.word	0x080191cf
 8019094:	080190fd 	.word	0x080190fd
 8019098:	08019247 	.word	0x08019247
 801909c:	08019247 	.word	0x08019247
 80190a0:	08019247 	.word	0x08019247
 80190a4:	08019247 	.word	0x08019247
 80190a8:	0801920b 	.word	0x0801920b
 80190ac:	08019229 	.word	0x08019229
 80190b0:	08019247 	.word	0x08019247
 80190b4:	0801920b 	.word	0x0801920b
 80190b8:	08019157 	.word	0x08019157
 80190bc:	08019247 	.word	0x08019247
 80190c0:	08019247 	.word	0x08019247
 80190c4:	08019247 	.word	0x08019247
 80190c8:	08019247 	.word	0x08019247
 80190cc:	08019247 	.word	0x08019247
 80190d0:	08019247 	.word	0x08019247
 80190d4:	08019247 	.word	0x08019247
 80190d8:	08019247 	.word	0x08019247
 80190dc:	08019247 	.word	0x08019247
 80190e0:	08019247 	.word	0x08019247
 80190e4:	08019247 	.word	0x08019247
 80190e8:	08019247 	.word	0x08019247
 80190ec:	08019247 	.word	0x08019247
 80190f0:	08019247 	.word	0x08019247
 80190f4:	08019193 	.word	0x08019193
 80190f8:	080190fd 	.word	0x080190fd
        case CA_TYPE:       /* same as below */
        case TRUSTED_PEER_TYPE:
        case CHAIN_CERT_TYPE:
        case CERT_TYPE:
            if (header) *header = BEGIN_CERT;
 80190fc:	68bb      	ldr	r3, [r7, #8]
 80190fe:	2b00      	cmp	r3, #0
 8019100:	d002      	beq.n	8019108 <wc_PemGetHeaderFooter+0xd8>
 8019102:	4a56      	ldr	r2, [pc, #344]	@ (801925c <wc_PemGetHeaderFooter+0x22c>)
 8019104:	68bb      	ldr	r3, [r7, #8]
 8019106:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_CERT;
 8019108:	687b      	ldr	r3, [r7, #4]
 801910a:	2b00      	cmp	r3, #0
 801910c:	d002      	beq.n	8019114 <wc_PemGetHeaderFooter+0xe4>
 801910e:	4a54      	ldr	r2, [pc, #336]	@ (8019260 <wc_PemGetHeaderFooter+0x230>)
 8019110:	687b      	ldr	r3, [r7, #4]
 8019112:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019114:	2300      	movs	r3, #0
 8019116:	617b      	str	r3, [r7, #20]
            break;
 8019118:	e099      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>

        case CRL_TYPE:
            if (header) *header = BEGIN_X509_CRL;
 801911a:	68bb      	ldr	r3, [r7, #8]
 801911c:	2b00      	cmp	r3, #0
 801911e:	d002      	beq.n	8019126 <wc_PemGetHeaderFooter+0xf6>
 8019120:	4a50      	ldr	r2, [pc, #320]	@ (8019264 <wc_PemGetHeaderFooter+0x234>)
 8019122:	68bb      	ldr	r3, [r7, #8]
 8019124:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_X509_CRL;
 8019126:	687b      	ldr	r3, [r7, #4]
 8019128:	2b00      	cmp	r3, #0
 801912a:	d002      	beq.n	8019132 <wc_PemGetHeaderFooter+0x102>
 801912c:	4a4e      	ldr	r2, [pc, #312]	@ (8019268 <wc_PemGetHeaderFooter+0x238>)
 801912e:	687b      	ldr	r3, [r7, #4]
 8019130:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019132:	2300      	movs	r3, #0
 8019134:	617b      	str	r3, [r7, #20]
            break;
 8019136:	e08a      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>
    #ifndef NO_DH
        case DH_PARAM_TYPE:
            if (header) *header = BEGIN_DH_PARAM;
 8019138:	68bb      	ldr	r3, [r7, #8]
 801913a:	2b00      	cmp	r3, #0
 801913c:	d002      	beq.n	8019144 <wc_PemGetHeaderFooter+0x114>
 801913e:	4a4b      	ldr	r2, [pc, #300]	@ (801926c <wc_PemGetHeaderFooter+0x23c>)
 8019140:	68bb      	ldr	r3, [r7, #8]
 8019142:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_DH_PARAM;
 8019144:	687b      	ldr	r3, [r7, #4]
 8019146:	2b00      	cmp	r3, #0
 8019148:	d002      	beq.n	8019150 <wc_PemGetHeaderFooter+0x120>
 801914a:	4a49      	ldr	r2, [pc, #292]	@ (8019270 <wc_PemGetHeaderFooter+0x240>)
 801914c:	687b      	ldr	r3, [r7, #4]
 801914e:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019150:	2300      	movs	r3, #0
 8019152:	617b      	str	r3, [r7, #20]
            break;
 8019154:	e07b      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>
        case X942_PARAM_TYPE:
            if (header) *header = BEGIN_X942_PARAM;
 8019156:	68bb      	ldr	r3, [r7, #8]
 8019158:	2b00      	cmp	r3, #0
 801915a:	d002      	beq.n	8019162 <wc_PemGetHeaderFooter+0x132>
 801915c:	4a45      	ldr	r2, [pc, #276]	@ (8019274 <wc_PemGetHeaderFooter+0x244>)
 801915e:	68bb      	ldr	r3, [r7, #8]
 8019160:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_X942_PARAM;
 8019162:	687b      	ldr	r3, [r7, #4]
 8019164:	2b00      	cmp	r3, #0
 8019166:	d002      	beq.n	801916e <wc_PemGetHeaderFooter+0x13e>
 8019168:	4a43      	ldr	r2, [pc, #268]	@ (8019278 <wc_PemGetHeaderFooter+0x248>)
 801916a:	687b      	ldr	r3, [r7, #4]
 801916c:	601a      	str	r2, [r3, #0]
            ret = 0;
 801916e:	2300      	movs	r3, #0
 8019170:	617b      	str	r3, [r7, #20]
            break;
 8019172:	e06c      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>
            break;
    #endif
    #ifdef HAVE_ECC
        case ECC_TYPE:
        case ECC_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_EC_PRIV;
 8019174:	68bb      	ldr	r3, [r7, #8]
 8019176:	2b00      	cmp	r3, #0
 8019178:	d002      	beq.n	8019180 <wc_PemGetHeaderFooter+0x150>
 801917a:	4a40      	ldr	r2, [pc, #256]	@ (801927c <wc_PemGetHeaderFooter+0x24c>)
 801917c:	68bb      	ldr	r3, [r7, #8]
 801917e:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_EC_PRIV;
 8019180:	687b      	ldr	r3, [r7, #4]
 8019182:	2b00      	cmp	r3, #0
 8019184:	d002      	beq.n	801918c <wc_PemGetHeaderFooter+0x15c>
 8019186:	4a3e      	ldr	r2, [pc, #248]	@ (8019280 <wc_PemGetHeaderFooter+0x250>)
 8019188:	687b      	ldr	r3, [r7, #4]
 801918a:	601a      	str	r2, [r3, #0]
            ret = 0;
 801918c:	2300      	movs	r3, #0
 801918e:	617b      	str	r3, [r7, #20]
            break;
 8019190:	e05d      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>
    #ifdef OPENSSL_EXTRA
        case ECC_PARAM_TYPE:
            if (header) *header = BEGIN_EC_PARAM;
 8019192:	68bb      	ldr	r3, [r7, #8]
 8019194:	2b00      	cmp	r3, #0
 8019196:	d002      	beq.n	801919e <wc_PemGetHeaderFooter+0x16e>
 8019198:	4a3a      	ldr	r2, [pc, #232]	@ (8019284 <wc_PemGetHeaderFooter+0x254>)
 801919a:	68bb      	ldr	r3, [r7, #8]
 801919c:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_EC_PARAM;
 801919e:	687b      	ldr	r3, [r7, #4]
 80191a0:	2b00      	cmp	r3, #0
 80191a2:	d002      	beq.n	80191aa <wc_PemGetHeaderFooter+0x17a>
 80191a4:	4a38      	ldr	r2, [pc, #224]	@ (8019288 <wc_PemGetHeaderFooter+0x258>)
 80191a6:	687b      	ldr	r3, [r7, #4]
 80191a8:	601a      	str	r2, [r3, #0]
            ret = 0;
 80191aa:	2300      	movs	r3, #0
 80191ac:	617b      	str	r3, [r7, #20]
            break;
 80191ae:	e04e      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>
        case RSA_TYPE:
        case PRIVATEKEY_TYPE:
    #ifdef WOLFSSL_DUAL_ALG_CERTS
        case ALT_PRIVATEKEY_TYPE:
    #endif
            if (header) *header = BEGIN_RSA_PRIV;
 80191b0:	68bb      	ldr	r3, [r7, #8]
 80191b2:	2b00      	cmp	r3, #0
 80191b4:	d002      	beq.n	80191bc <wc_PemGetHeaderFooter+0x18c>
 80191b6:	4a35      	ldr	r2, [pc, #212]	@ (801928c <wc_PemGetHeaderFooter+0x25c>)
 80191b8:	68bb      	ldr	r3, [r7, #8]
 80191ba:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_RSA_PRIV;
 80191bc:	687b      	ldr	r3, [r7, #4]
 80191be:	2b00      	cmp	r3, #0
 80191c0:	d002      	beq.n	80191c8 <wc_PemGetHeaderFooter+0x198>
 80191c2:	4a33      	ldr	r2, [pc, #204]	@ (8019290 <wc_PemGetHeaderFooter+0x260>)
 80191c4:	687b      	ldr	r3, [r7, #4]
 80191c6:	601a      	str	r2, [r3, #0]
            ret = 0;
 80191c8:	2300      	movs	r3, #0
 80191ca:	617b      	str	r3, [r7, #20]
            break;
 80191cc:	e03f      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>
            ret = 0;
            break;
#endif /* HAVE_SPHINCS */
        case PUBLICKEY_TYPE:
        case ECC_PUBLICKEY_TYPE:
            if (header) *header = BEGIN_PUB_KEY;
 80191ce:	68bb      	ldr	r3, [r7, #8]
 80191d0:	2b00      	cmp	r3, #0
 80191d2:	d002      	beq.n	80191da <wc_PemGetHeaderFooter+0x1aa>
 80191d4:	4a2f      	ldr	r2, [pc, #188]	@ (8019294 <wc_PemGetHeaderFooter+0x264>)
 80191d6:	68bb      	ldr	r3, [r7, #8]
 80191d8:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_PUB_KEY;
 80191da:	687b      	ldr	r3, [r7, #4]
 80191dc:	2b00      	cmp	r3, #0
 80191de:	d002      	beq.n	80191e6 <wc_PemGetHeaderFooter+0x1b6>
 80191e0:	4a2d      	ldr	r2, [pc, #180]	@ (8019298 <wc_PemGetHeaderFooter+0x268>)
 80191e2:	687b      	ldr	r3, [r7, #4]
 80191e4:	601a      	str	r2, [r3, #0]
            ret = 0;
 80191e6:	2300      	movs	r3, #0
 80191e8:	617b      	str	r3, [r7, #20]
            break;
 80191ea:	e030      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>
        case RSA_PUBLICKEY_TYPE:
            if (header) *header = BEGIN_RSA_PUB;
 80191ec:	68bb      	ldr	r3, [r7, #8]
 80191ee:	2b00      	cmp	r3, #0
 80191f0:	d002      	beq.n	80191f8 <wc_PemGetHeaderFooter+0x1c8>
 80191f2:	4a2a      	ldr	r2, [pc, #168]	@ (801929c <wc_PemGetHeaderFooter+0x26c>)
 80191f4:	68bb      	ldr	r3, [r7, #8]
 80191f6:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_RSA_PUB;
 80191f8:	687b      	ldr	r3, [r7, #4]
 80191fa:	2b00      	cmp	r3, #0
 80191fc:	d002      	beq.n	8019204 <wc_PemGetHeaderFooter+0x1d4>
 80191fe:	4a28      	ldr	r2, [pc, #160]	@ (80192a0 <wc_PemGetHeaderFooter+0x270>)
 8019200:	687b      	ldr	r3, [r7, #4]
 8019202:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019204:	2300      	movs	r3, #0
 8019206:	617b      	str	r3, [r7, #20]
            break;
 8019208:	e021      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>
    #ifndef NO_DH
        case DH_PRIVATEKEY_TYPE:
    #endif
        case PKCS8_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_PRIV_KEY;
 801920a:	68bb      	ldr	r3, [r7, #8]
 801920c:	2b00      	cmp	r3, #0
 801920e:	d002      	beq.n	8019216 <wc_PemGetHeaderFooter+0x1e6>
 8019210:	4a24      	ldr	r2, [pc, #144]	@ (80192a4 <wc_PemGetHeaderFooter+0x274>)
 8019212:	68bb      	ldr	r3, [r7, #8]
 8019214:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_PRIV_KEY;
 8019216:	687b      	ldr	r3, [r7, #4]
 8019218:	2b00      	cmp	r3, #0
 801921a:	d002      	beq.n	8019222 <wc_PemGetHeaderFooter+0x1f2>
 801921c:	4a22      	ldr	r2, [pc, #136]	@ (80192a8 <wc_PemGetHeaderFooter+0x278>)
 801921e:	687b      	ldr	r3, [r7, #4]
 8019220:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019222:	2300      	movs	r3, #0
 8019224:	617b      	str	r3, [r7, #20]
            break;
 8019226:	e012      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>
        case PKCS8_ENC_PRIVATEKEY_TYPE:
            if (header) *header = BEGIN_ENC_PRIV_KEY;
 8019228:	68bb      	ldr	r3, [r7, #8]
 801922a:	2b00      	cmp	r3, #0
 801922c:	d002      	beq.n	8019234 <wc_PemGetHeaderFooter+0x204>
 801922e:	4a1f      	ldr	r2, [pc, #124]	@ (80192ac <wc_PemGetHeaderFooter+0x27c>)
 8019230:	68bb      	ldr	r3, [r7, #8]
 8019232:	601a      	str	r2, [r3, #0]
            if (footer) *footer = END_ENC_PRIV_KEY;
 8019234:	687b      	ldr	r3, [r7, #4]
 8019236:	2b00      	cmp	r3, #0
 8019238:	d002      	beq.n	8019240 <wc_PemGetHeaderFooter+0x210>
 801923a:	4a1d      	ldr	r2, [pc, #116]	@ (80192b0 <wc_PemGetHeaderFooter+0x280>)
 801923c:	687b      	ldr	r3, [r7, #4]
 801923e:	601a      	str	r2, [r3, #0]
            ret = 0;
 8019240:	2300      	movs	r3, #0
 8019242:	617b      	str	r3, [r7, #20]
            break;
 8019244:	e003      	b.n	801924e <wc_PemGetHeaderFooter+0x21e>
        default:
            ret = BAD_FUNC_ARG;
 8019246:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801924a:	617b      	str	r3, [r7, #20]
            break;
 801924c:	bf00      	nop
    }
    return ret;
 801924e:	697b      	ldr	r3, [r7, #20]
}
 8019250:	4618      	mov	r0, r3
 8019252:	371c      	adds	r7, #28
 8019254:	46bd      	mov	sp, r7
 8019256:	f85d 7b04 	ldr.w	r7, [sp], #4
 801925a:	4770      	bx	lr
 801925c:	0802f880 	.word	0x0802f880
 8019260:	0802f89c 	.word	0x0802f89c
 8019264:	0802f93c 	.word	0x0802f93c
 8019268:	0802f958 	.word	0x0802f958
 801926c:	0802f8b8 	.word	0x0802f8b8
 8019270:	0802f8d8 	.word	0x0802f8d8
 8019274:	0802f8f4 	.word	0x0802f8f4
 8019278:	0802f918 	.word	0x0802f918
 801927c:	0802fa74 	.word	0x0802fa74
 8019280:	0802fa94 	.word	0x0802fa94
 8019284:	0802fab4 	.word	0x0802fab4
 8019288:	0802fad4 	.word	0x0802fad4
 801928c:	0802f970 	.word	0x0802f970
 8019290:	0802f990 	.word	0x0802f990
 8019294:	0802fb30 	.word	0x0802fb30
 8019298:	0802fb4c 	.word	0x0802fb4c
 801929c:	0802f9b0 	.word	0x0802f9b0
 80192a0:	0802f9d0 	.word	0x0802f9d0
 80192a4:	0802f9f0 	.word	0x0802f9f0
 80192a8:	0802fa0c 	.word	0x0802fa0c
 80192ac:	0802fa28 	.word	0x0802fa28
 80192b0:	0802fa50 	.word	0x0802fa50

080192b4 <wc_EncryptedInfoGet>:
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_256)
    static wcchar kEncTypeAesCbc256 = "AES-256-CBC";
#endif

int wc_EncryptedInfoGet(EncryptedInfo* info, const char* cipherInfo)
{
 80192b4:	b580      	push	{r7, lr}
 80192b6:	b084      	sub	sp, #16
 80192b8:	af00      	add	r7, sp, #0
 80192ba:	6078      	str	r0, [r7, #4]
 80192bc:	6039      	str	r1, [r7, #0]
    int ret = 0;
 80192be:	2300      	movs	r3, #0
 80192c0:	60fb      	str	r3, [r7, #12]

    if (info == NULL || cipherInfo == NULL)
 80192c2:	687b      	ldr	r3, [r7, #4]
 80192c4:	2b00      	cmp	r3, #0
 80192c6:	d002      	beq.n	80192ce <wc_EncryptedInfoGet+0x1a>
 80192c8:	683b      	ldr	r3, [r7, #0]
 80192ca:	2b00      	cmp	r3, #0
 80192cc:	d102      	bne.n	80192d4 <wc_EncryptedInfoGet+0x20>
        return BAD_FUNC_ARG;
 80192ce:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80192d2:	e045      	b.n	8019360 <wc_EncryptedInfoGet+0xac>
#endif
    }
    else
#endif /* !NO_DES3 */
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_128)
    if (XSTRCMP(cipherInfo, kEncTypeAesCbc128) == 0) {
 80192d4:	4b24      	ldr	r3, [pc, #144]	@ (8019368 <wc_EncryptedInfoGet+0xb4>)
 80192d6:	4619      	mov	r1, r3
 80192d8:	6838      	ldr	r0, [r7, #0]
 80192da:	f7e6 ff79 	bl	80001d0 <strcmp>
 80192de:	4603      	mov	r3, r0
 80192e0:	2b00      	cmp	r3, #0
 80192e2:	d10d      	bne.n	8019300 <wc_EncryptedInfoGet+0x4c>
        info->cipherType = WC_CIPHER_AES_CBC;
 80192e4:	687b      	ldr	r3, [r7, #4]
 80192e6:	2202      	movs	r2, #2
 80192e8:	60da      	str	r2, [r3, #12]
        info->keySz = AES_128_KEY_SIZE;
 80192ea:	687b      	ldr	r3, [r7, #4]
 80192ec:	2210      	movs	r2, #16
 80192ee:	611a      	str	r2, [r3, #16]
        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;
 80192f0:	687b      	ldr	r3, [r7, #4]
 80192f2:	695b      	ldr	r3, [r3, #20]
 80192f4:	2b00      	cmp	r3, #0
 80192f6:	d132      	bne.n	801935e <wc_EncryptedInfoGet+0xaa>
 80192f8:	687b      	ldr	r3, [r7, #4]
 80192fa:	2210      	movs	r2, #16
 80192fc:	615a      	str	r2, [r3, #20]
 80192fe:	e02e      	b.n	801935e <wc_EncryptedInfoGet+0xaa>
    }
    else
#endif
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_192)
    if (XSTRCMP(cipherInfo, kEncTypeAesCbc192) == 0) {
 8019300:	4b1a      	ldr	r3, [pc, #104]	@ (801936c <wc_EncryptedInfoGet+0xb8>)
 8019302:	4619      	mov	r1, r3
 8019304:	6838      	ldr	r0, [r7, #0]
 8019306:	f7e6 ff63 	bl	80001d0 <strcmp>
 801930a:	4603      	mov	r3, r0
 801930c:	2b00      	cmp	r3, #0
 801930e:	d10d      	bne.n	801932c <wc_EncryptedInfoGet+0x78>
        info->cipherType = WC_CIPHER_AES_CBC;
 8019310:	687b      	ldr	r3, [r7, #4]
 8019312:	2202      	movs	r2, #2
 8019314:	60da      	str	r2, [r3, #12]
        info->keySz = AES_192_KEY_SIZE;
 8019316:	687b      	ldr	r3, [r7, #4]
 8019318:	2218      	movs	r2, #24
 801931a:	611a      	str	r2, [r3, #16]
        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;
 801931c:	687b      	ldr	r3, [r7, #4]
 801931e:	695b      	ldr	r3, [r3, #20]
 8019320:	2b00      	cmp	r3, #0
 8019322:	d11c      	bne.n	801935e <wc_EncryptedInfoGet+0xaa>
 8019324:	687b      	ldr	r3, [r7, #4]
 8019326:	2210      	movs	r2, #16
 8019328:	615a      	str	r2, [r3, #20]
 801932a:	e018      	b.n	801935e <wc_EncryptedInfoGet+0xaa>
    }
    else
#endif
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_256)
    if (XSTRCMP(cipherInfo, kEncTypeAesCbc256) == 0) {
 801932c:	4b10      	ldr	r3, [pc, #64]	@ (8019370 <wc_EncryptedInfoGet+0xbc>)
 801932e:	4619      	mov	r1, r3
 8019330:	6838      	ldr	r0, [r7, #0]
 8019332:	f7e6 ff4d 	bl	80001d0 <strcmp>
 8019336:	4603      	mov	r3, r0
 8019338:	2b00      	cmp	r3, #0
 801933a:	d10d      	bne.n	8019358 <wc_EncryptedInfoGet+0xa4>
        info->cipherType = WC_CIPHER_AES_CBC;
 801933c:	687b      	ldr	r3, [r7, #4]
 801933e:	2202      	movs	r2, #2
 8019340:	60da      	str	r2, [r3, #12]
        info->keySz = AES_256_KEY_SIZE;
 8019342:	687b      	ldr	r3, [r7, #4]
 8019344:	2220      	movs	r2, #32
 8019346:	611a      	str	r2, [r3, #16]
        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;
 8019348:	687b      	ldr	r3, [r7, #4]
 801934a:	695b      	ldr	r3, [r3, #20]
 801934c:	2b00      	cmp	r3, #0
 801934e:	d106      	bne.n	801935e <wc_EncryptedInfoGet+0xaa>
 8019350:	687b      	ldr	r3, [r7, #4]
 8019352:	2210      	movs	r2, #16
 8019354:	615a      	str	r2, [r3, #20]
 8019356:	e002      	b.n	801935e <wc_EncryptedInfoGet+0xaa>
    }
    else
#endif
    {
        ret = NOT_COMPILED_IN;
 8019358:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 801935c:	60fb      	str	r3, [r7, #12]
    }
    return ret;
 801935e:	68fb      	ldr	r3, [r7, #12]
}
 8019360:	4618      	mov	r0, r3
 8019362:	3710      	adds	r7, #16
 8019364:	46bd      	mov	sp, r7
 8019366:	bd80      	pop	{r7, pc}
 8019368:	0802fb80 	.word	0x0802fb80
 801936c:	0802fb8c 	.word	0x0802fb8c
 8019370:	0802fb98 	.word	0x0802fb98

08019374 <wc_EncryptedInfoParse>:

int wc_EncryptedInfoParse(EncryptedInfo* info, const char** pBuffer,
                          size_t bufSz)
{
 8019374:	b590      	push	{r4, r7, lr}
 8019376:	b08f      	sub	sp, #60	@ 0x3c
 8019378:	af00      	add	r7, sp, #0
 801937a:	60f8      	str	r0, [r7, #12]
 801937c:	60b9      	str	r1, [r7, #8]
 801937e:	607a      	str	r2, [r7, #4]
    int         err = 0;
 8019380:	2300      	movs	r3, #0
 8019382:	637b      	str	r3, [r7, #52]	@ 0x34
    const char* bufferStart;
    const char* bufferEnd;
    char*       line;

    if (info == NULL || pBuffer == NULL || bufSz == 0)
 8019384:	68fb      	ldr	r3, [r7, #12]
 8019386:	2b00      	cmp	r3, #0
 8019388:	d005      	beq.n	8019396 <wc_EncryptedInfoParse+0x22>
 801938a:	68bb      	ldr	r3, [r7, #8]
 801938c:	2b00      	cmp	r3, #0
 801938e:	d002      	beq.n	8019396 <wc_EncryptedInfoParse+0x22>
 8019390:	687b      	ldr	r3, [r7, #4]
 8019392:	2b00      	cmp	r3, #0
 8019394:	d102      	bne.n	801939c <wc_EncryptedInfoParse+0x28>
        return BAD_FUNC_ARG;
 8019396:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801939a:	e106      	b.n	80195aa <wc_EncryptedInfoParse+0x236>

    bufferStart = *pBuffer;
 801939c:	68bb      	ldr	r3, [r7, #8]
 801939e:	681b      	ldr	r3, [r3, #0]
 80193a0:	62bb      	str	r3, [r7, #40]	@ 0x28
    bufferEnd = bufferStart + bufSz;
 80193a2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80193a4:	687b      	ldr	r3, [r7, #4]
 80193a6:	4413      	add	r3, r2
 80193a8:	627b      	str	r3, [r7, #36]	@ 0x24

    /* find encrypted info marker */
    line = XSTRNSTR(bufferStart, kProcTypeHeader,
 80193aa:	4c82      	ldr	r4, [pc, #520]	@ (80195b4 <wc_EncryptedInfoParse+0x240>)
 80193ac:	214c      	movs	r1, #76	@ 0x4c
 80193ae:	6878      	ldr	r0, [r7, #4]
 80193b0:	f7f9 f98e 	bl	80126d0 <min>
 80193b4:	4603      	mov	r3, r0
 80193b6:	461a      	mov	r2, r3
 80193b8:	4621      	mov	r1, r4
 80193ba:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80193bc:	f00e f810 	bl	80273e0 <mystrnstr>
 80193c0:	6238      	str	r0, [r7, #32]
                    min((word32)bufSz, PEM_LINE_LEN));
    if (line != NULL) {
 80193c2:	6a3b      	ldr	r3, [r7, #32]
 80193c4:	2b00      	cmp	r3, #0
 80193c6:	f000 80ef 	beq.w	80195a8 <wc_EncryptedInfoParse+0x234>
        word32      lineSz;
        char*       finish;
        char*       start;
        word32      startSz;
        const char* newline = NULL;
 80193ca:	2300      	movs	r3, #0
 80193cc:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if (line >= bufferEnd) {
 80193ce:	6a3a      	ldr	r2, [r7, #32]
 80193d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80193d2:	429a      	cmp	r2, r3
 80193d4:	d302      	bcc.n	80193dc <wc_EncryptedInfoParse+0x68>
            return BUFFER_E;
 80193d6:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80193da:	e0e6      	b.n	80195aa <wc_EncryptedInfoParse+0x236>
        }

        lineSz = (word32)(bufferEnd - line);
 80193dc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80193de:	6a3b      	ldr	r3, [r7, #32]
 80193e0:	1ad3      	subs	r3, r2, r3
 80193e2:	61fb      	str	r3, [r7, #28]

        /* find DEC-Info marker */
        start = XSTRNSTR(line, kDecInfoHeader, min(lineSz, PEM_LINE_LEN));
 80193e4:	4c74      	ldr	r4, [pc, #464]	@ (80195b8 <wc_EncryptedInfoParse+0x244>)
 80193e6:	214c      	movs	r1, #76	@ 0x4c
 80193e8:	69f8      	ldr	r0, [r7, #28]
 80193ea:	f7f9 f971 	bl	80126d0 <min>
 80193ee:	4603      	mov	r3, r0
 80193f0:	461a      	mov	r2, r3
 80193f2:	4621      	mov	r1, r4
 80193f4:	6a38      	ldr	r0, [r7, #32]
 80193f6:	f00d fff3 	bl	80273e0 <mystrnstr>
 80193fa:	6338      	str	r0, [r7, #48]	@ 0x30

        if (start == NULL)
 80193fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80193fe:	2b00      	cmp	r3, #0
 8019400:	d102      	bne.n	8019408 <wc_EncryptedInfoParse+0x94>
            return BUFFER_E;
 8019402:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019406:	e0d0      	b.n	80195aa <wc_EncryptedInfoParse+0x236>

        /* skip dec-info and ": " */
        start += XSTRLEN(kDecInfoHeader);
 8019408:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801940a:	3308      	adds	r3, #8
 801940c:	633b      	str	r3, [r7, #48]	@ 0x30
        if (start >= bufferEnd)
 801940e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8019410:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019412:	429a      	cmp	r2, r3
 8019414:	d302      	bcc.n	801941c <wc_EncryptedInfoParse+0xa8>
            return BUFFER_E;
 8019416:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801941a:	e0c6      	b.n	80195aa <wc_EncryptedInfoParse+0x236>

        if (start[0] == ':') {
 801941c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801941e:	781b      	ldrb	r3, [r3, #0]
 8019420:	2b3a      	cmp	r3, #58	@ 0x3a
 8019422:	d109      	bne.n	8019438 <wc_EncryptedInfoParse+0xc4>
            start++;
 8019424:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019426:	3301      	adds	r3, #1
 8019428:	633b      	str	r3, [r7, #48]	@ 0x30
            if (start >= bufferEnd)
 801942a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801942c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801942e:	429a      	cmp	r2, r3
 8019430:	d302      	bcc.n	8019438 <wc_EncryptedInfoParse+0xc4>
                return BUFFER_E;
 8019432:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019436:	e0b8      	b.n	80195aa <wc_EncryptedInfoParse+0x236>
        }
        if (start[0] == ' ')
 8019438:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801943a:	781b      	ldrb	r3, [r3, #0]
 801943c:	2b20      	cmp	r3, #32
 801943e:	d102      	bne.n	8019446 <wc_EncryptedInfoParse+0xd2>
            start++;
 8019440:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019442:	3301      	adds	r3, #1
 8019444:	633b      	str	r3, [r7, #48]	@ 0x30

        startSz = (word32)(bufferEnd - start);
 8019446:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8019448:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801944a:	1ad3      	subs	r3, r2, r3
 801944c:	61bb      	str	r3, [r7, #24]
        finish = XSTRNSTR(start, ",", min(startSz, PEM_LINE_LEN));
 801944e:	214c      	movs	r1, #76	@ 0x4c
 8019450:	69b8      	ldr	r0, [r7, #24]
 8019452:	f7f9 f93d 	bl	80126d0 <min>
 8019456:	4603      	mov	r3, r0
 8019458:	461a      	mov	r2, r3
 801945a:	4958      	ldr	r1, [pc, #352]	@ (80195bc <wc_EncryptedInfoParse+0x248>)
 801945c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801945e:	f00d ffbf 	bl	80273e0 <mystrnstr>
 8019462:	6178      	str	r0, [r7, #20]

        if ((start != NULL) && (finish != NULL) && (start < finish)) {
 8019464:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019466:	2b00      	cmp	r3, #0
 8019468:	f000 809b 	beq.w	80195a2 <wc_EncryptedInfoParse+0x22e>
 801946c:	697b      	ldr	r3, [r7, #20]
 801946e:	2b00      	cmp	r3, #0
 8019470:	f000 8097 	beq.w	80195a2 <wc_EncryptedInfoParse+0x22e>
 8019474:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8019476:	697b      	ldr	r3, [r7, #20]
 8019478:	429a      	cmp	r2, r3
 801947a:	f080 8092 	bcs.w	80195a2 <wc_EncryptedInfoParse+0x22e>
            word32 finishSz;

            if (finish >= bufferEnd) {
 801947e:	697a      	ldr	r2, [r7, #20]
 8019480:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019482:	429a      	cmp	r2, r3
 8019484:	d302      	bcc.n	801948c <wc_EncryptedInfoParse+0x118>
                return BUFFER_E;
 8019486:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801948a:	e08e      	b.n	80195aa <wc_EncryptedInfoParse+0x236>
            }

            finishSz = (word32)(bufferEnd - finish);
 801948c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801948e:	697b      	ldr	r3, [r7, #20]
 8019490:	1ad3      	subs	r3, r2, r3
 8019492:	613b      	str	r3, [r7, #16]
            newline = XSTRNSTR(finish, "\r", min(finishSz, PEM_LINE_LEN));
 8019494:	214c      	movs	r1, #76	@ 0x4c
 8019496:	6938      	ldr	r0, [r7, #16]
 8019498:	f7f9 f91a 	bl	80126d0 <min>
 801949c:	4603      	mov	r3, r0
 801949e:	461a      	mov	r2, r3
 80194a0:	4947      	ldr	r1, [pc, #284]	@ (80195c0 <wc_EncryptedInfoParse+0x24c>)
 80194a2:	6978      	ldr	r0, [r7, #20]
 80194a4:	f00d ff9c 	bl	80273e0 <mystrnstr>
 80194a8:	62f8      	str	r0, [r7, #44]	@ 0x2c

            /* get cipher name */
            if (NAME_SZ < (finish - start)) /* buffer size of info->name */
 80194aa:	697a      	ldr	r2, [r7, #20]
 80194ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80194ae:	1ad3      	subs	r3, r2, r3
 80194b0:	2b50      	cmp	r3, #80	@ 0x50
 80194b2:	dd02      	ble.n	80194ba <wc_EncryptedInfoParse+0x146>
                return BUFFER_E;
 80194b4:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80194b8:	e077      	b.n	80195aa <wc_EncryptedInfoParse+0x236>
            if (XMEMCPY(info->name, start, (size_t)(finish - start)) == NULL)
 80194ba:	68fb      	ldr	r3, [r7, #12]
 80194bc:	f103 0018 	add.w	r0, r3, #24
 80194c0:	697a      	ldr	r2, [r7, #20]
 80194c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80194c4:	1ad3      	subs	r3, r2, r3
 80194c6:	461a      	mov	r2, r3
 80194c8:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80194ca:	f00f f86b 	bl	80285a4 <memcpy>
 80194ce:	4603      	mov	r3, r0
 80194d0:	2b00      	cmp	r3, #0
 80194d2:	d102      	bne.n	80194da <wc_EncryptedInfoParse+0x166>
                return BUFFER_E;
 80194d4:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80194d8:	e067      	b.n	80195aa <wc_EncryptedInfoParse+0x236>
            info->name[finish - start] = '\0'; /* null term */
 80194da:	697a      	ldr	r2, [r7, #20]
 80194dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80194de:	1ad3      	subs	r3, r2, r3
 80194e0:	68fa      	ldr	r2, [r7, #12]
 80194e2:	4413      	add	r3, r2
 80194e4:	2200      	movs	r2, #0
 80194e6:	761a      	strb	r2, [r3, #24]

            /* populate info */
            err = wc_EncryptedInfoGet(info, info->name);
 80194e8:	68fb      	ldr	r3, [r7, #12]
 80194ea:	3318      	adds	r3, #24
 80194ec:	4619      	mov	r1, r3
 80194ee:	68f8      	ldr	r0, [r7, #12]
 80194f0:	f7ff fee0 	bl	80192b4 <wc_EncryptedInfoGet>
 80194f4:	6378      	str	r0, [r7, #52]	@ 0x34
            if (err != 0)
 80194f6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80194f8:	2b00      	cmp	r3, #0
 80194fa:	d001      	beq.n	8019500 <wc_EncryptedInfoParse+0x18c>
                return err;
 80194fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80194fe:	e054      	b.n	80195aa <wc_EncryptedInfoParse+0x236>

            /* get IV */
            if (finishSz < info->ivSz + 1)
 8019500:	68fb      	ldr	r3, [r7, #12]
 8019502:	695b      	ldr	r3, [r3, #20]
 8019504:	3301      	adds	r3, #1
 8019506:	693a      	ldr	r2, [r7, #16]
 8019508:	429a      	cmp	r2, r3
 801950a:	d202      	bcs.n	8019512 <wc_EncryptedInfoParse+0x19e>
                return BUFFER_E;
 801950c:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019510:	e04b      	b.n	80195aa <wc_EncryptedInfoParse+0x236>

            if (newline == NULL) {
 8019512:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019514:	2b00      	cmp	r3, #0
 8019516:	d10a      	bne.n	801952e <wc_EncryptedInfoParse+0x1ba>
                newline = XSTRNSTR(finish, "\n", min(finishSz,
 8019518:	214c      	movs	r1, #76	@ 0x4c
 801951a:	6938      	ldr	r0, [r7, #16]
 801951c:	f7f9 f8d8 	bl	80126d0 <min>
 8019520:	4603      	mov	r3, r0
 8019522:	461a      	mov	r2, r3
 8019524:	4927      	ldr	r1, [pc, #156]	@ (80195c4 <wc_EncryptedInfoParse+0x250>)
 8019526:	6978      	ldr	r0, [r7, #20]
 8019528:	f00d ff5a 	bl	80273e0 <mystrnstr>
 801952c:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                                     PEM_LINE_LEN));
            }
            if ((newline != NULL) && (newline > finish)) {
 801952e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019530:	2b00      	cmp	r3, #0
 8019532:	d033      	beq.n	801959c <wc_EncryptedInfoParse+0x228>
 8019534:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019536:	697b      	ldr	r3, [r7, #20]
 8019538:	429a      	cmp	r2, r3
 801953a:	d92f      	bls.n	801959c <wc_EncryptedInfoParse+0x228>
                finish++;
 801953c:	697b      	ldr	r3, [r7, #20]
 801953e:	3301      	adds	r3, #1
 8019540:	617b      	str	r3, [r7, #20]
                info->ivSz = (word32)(newline - finish);
 8019542:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019544:	697b      	ldr	r3, [r7, #20]
 8019546:	1ad3      	subs	r3, r2, r3
 8019548:	461a      	mov	r2, r3
 801954a:	68fb      	ldr	r3, [r7, #12]
 801954c:	615a      	str	r2, [r3, #20]
                if (info->ivSz > IV_SZ)
 801954e:	68fb      	ldr	r3, [r7, #12]
 8019550:	695b      	ldr	r3, [r3, #20]
 8019552:	2b20      	cmp	r3, #32
 8019554:	d902      	bls.n	801955c <wc_EncryptedInfoParse+0x1e8>
                    return BUFFER_E;
 8019556:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801955a:	e026      	b.n	80195aa <wc_EncryptedInfoParse+0x236>
                if (XMEMCPY(info->iv, finish, info->ivSz) == NULL)
 801955c:	68fb      	ldr	r3, [r7, #12]
 801955e:	f103 0068 	add.w	r0, r3, #104	@ 0x68
 8019562:	68fb      	ldr	r3, [r7, #12]
 8019564:	695b      	ldr	r3, [r3, #20]
 8019566:	461a      	mov	r2, r3
 8019568:	6979      	ldr	r1, [r7, #20]
 801956a:	f00f f81b 	bl	80285a4 <memcpy>
 801956e:	4603      	mov	r3, r0
 8019570:	2b00      	cmp	r3, #0
 8019572:	d102      	bne.n	801957a <wc_EncryptedInfoParse+0x206>
                    return BUFFER_E;
 8019574:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019578:	e017      	b.n	80195aa <wc_EncryptedInfoParse+0x236>
                info->set = 1;
 801957a:	68fa      	ldr	r2, [r7, #12]
 801957c:	f892 3088 	ldrb.w	r3, [r2, #136]	@ 0x88
 8019580:	f043 0301 	orr.w	r3, r3, #1
 8019584:	f882 3088 	strb.w	r3, [r2, #136]	@ 0x88
        if ((start != NULL) && (finish != NULL) && (start < finish)) {
 8019588:	bf00      	nop
        }
        else
            return BUFFER_E;

        /* eat end of line characters */
        newline = SkipEndOfLineChars(newline, bufferEnd);
 801958a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801958c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801958e:	f7ff fd32 	bl	8018ff6 <SkipEndOfLineChars>
 8019592:	62f8      	str	r0, [r7, #44]	@ 0x2c

        /* return new headerEnd */

        *pBuffer = newline;
 8019594:	68bb      	ldr	r3, [r7, #8]
 8019596:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019598:	601a      	str	r2, [r3, #0]
 801959a:	e005      	b.n	80195a8 <wc_EncryptedInfoParse+0x234>
                return BUFFER_E;
 801959c:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80195a0:	e003      	b.n	80195aa <wc_EncryptedInfoParse+0x236>
            return BUFFER_E;
 80195a2:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80195a6:	e000      	b.n	80195aa <wc_EncryptedInfoParse+0x236>
    }

    return err;
 80195a8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 80195aa:	4618      	mov	r0, r3
 80195ac:	373c      	adds	r7, #60	@ 0x3c
 80195ae:	46bd      	mov	sp, r7
 80195b0:	bd90      	pop	{r4, r7, pc}
 80195b2:	bf00      	nop
 80195b4:	0802fb68 	.word	0x0802fb68
 80195b8:	0802fb74 	.word	0x0802fb74
 80195bc:	0802fba4 	.word	0x0802fba4
 80195c0:	0802fba8 	.word	0x0802fba8
 80195c4:	0802fbac 	.word	0x0802fbac

080195c8 <PemToDer>:

/* Remove PEM header/footer, convert to ASN1, store any encrypted data
   info->consumed tracks of PEM bytes consumed in case multiple parts */
int PemToDer(const unsigned char* buff, long longSz, int type,
              DerBuffer** pDer, void* heap, EncryptedInfo* info, int* keyFormat)
{
 80195c8:	b590      	push	{r4, r7, lr}
 80195ca:	b0c3      	sub	sp, #268	@ 0x10c
 80195cc:	af02      	add	r7, sp, #8
 80195ce:	60f8      	str	r0, [r7, #12]
 80195d0:	60b9      	str	r1, [r7, #8]
 80195d2:	607a      	str	r2, [r7, #4]
 80195d4:	f507 7280 	add.w	r2, r7, #256	@ 0x100
 80195d8:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 80195dc:	6013      	str	r3, [r2, #0]
    const char* header      = NULL;
 80195de:	2300      	movs	r3, #0
 80195e0:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    const char* footer      = NULL;
 80195e4:	2300      	movs	r3, #0
 80195e6:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    const char* headerEnd   = NULL;
 80195ea:	2300      	movs	r3, #0
 80195ec:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    const char* footerEnd   = NULL;
 80195f0:	2300      	movs	r3, #0
 80195f2:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    const char* consumedEnd = NULL;
 80195f6:	2300      	movs	r3, #0
 80195f8:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    const char* bufferEnd   = (const char*)(buff + longSz);
 80195fc:	68bb      	ldr	r3, [r7, #8]
 80195fe:	68fa      	ldr	r2, [r7, #12]
 8019600:	4413      	add	r3, r2
 8019602:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    long        neededSz;
    int         ret         = 0;
 8019606:	2300      	movs	r3, #0
 8019608:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    word32      sz          = (word32)longSz;
 801960c:	68bb      	ldr	r3, [r7, #8]
 801960e:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    int         encrypted_key = 0;
 8019612:	2300      	movs	r3, #0
 8019614:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    DerBuffer*  der;
    word32      algId = 0;
 8019618:	2300      	movs	r3, #0
 801961a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
#endif

    WOLFSSL_ENTER("PemToDer");

    /* get PEM header and footer based on type */
    ret = wc_PemGetHeaderFooter(type, &header, &footer);
 801961e:	f107 02c0 	add.w	r2, r7, #192	@ 0xc0
 8019622:	f107 03c4 	add.w	r3, r7, #196	@ 0xc4
 8019626:	4619      	mov	r1, r3
 8019628:	6878      	ldr	r0, [r7, #4]
 801962a:	f7ff fd01 	bl	8019030 <wc_PemGetHeaderFooter>
 801962e:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
    if (ret != 0)
 8019632:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019636:	2b00      	cmp	r3, #0
 8019638:	d002      	beq.n	8019640 <PemToDer+0x78>
        return ret;
 801963a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801963e:	e36c      	b.n	8019d1a <PemToDer+0x752>

    /* map header if not found for type */
    for (;;) {
        headerEnd = XSTRNSTR((char*)buff, header, sz);
 8019640:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019644:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8019648:	4619      	mov	r1, r3
 801964a:	68f8      	ldr	r0, [r7, #12]
 801964c:	f00d fec8 	bl	80273e0 <mystrnstr>
 8019650:	4603      	mov	r3, r0
 8019652:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
        if (headerEnd) {
 8019656:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801965a:	2b00      	cmp	r3, #0
 801965c:	d150      	bne.n	8019700 <PemToDer+0x138>
            break;
        }

        if (type == PRIVATEKEY_TYPE
 801965e:	687b      	ldr	r3, [r7, #4]
 8019660:	2b01      	cmp	r3, #1
 8019662:	d12f      	bne.n	80196c4 <PemToDer+0xfc>
#ifdef WOLFSSL_DUAL_ALG_CERTS
            || type == ALT_PRIVATEKEY_TYPE
#endif
           ) {
            if (header == BEGIN_RSA_PRIV) {
 8019664:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019668:	4aa1      	ldr	r2, [pc, #644]	@ (80198f0 <PemToDer+0x328>)
 801966a:	4293      	cmp	r3, r2
 801966c:	d106      	bne.n	801967c <PemToDer+0xb4>
                header = BEGIN_PRIV_KEY;
 801966e:	4ba1      	ldr	r3, [pc, #644]	@ (80198f4 <PemToDer+0x32c>)
 8019670:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_PRIV_KEY;
 8019674:	4ba0      	ldr	r3, [pc, #640]	@ (80198f8 <PemToDer+0x330>)
 8019676:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 801967a:	e7e1      	b.n	8019640 <PemToDer+0x78>
            }
            else if (header == BEGIN_PRIV_KEY) {
 801967c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019680:	4a9c      	ldr	r2, [pc, #624]	@ (80198f4 <PemToDer+0x32c>)
 8019682:	4293      	cmp	r3, r2
 8019684:	d106      	bne.n	8019694 <PemToDer+0xcc>
                header = BEGIN_ENC_PRIV_KEY;
 8019686:	4b9d      	ldr	r3, [pc, #628]	@ (80198fc <PemToDer+0x334>)
 8019688:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_ENC_PRIV_KEY;
 801968c:	4b9c      	ldr	r3, [pc, #624]	@ (8019900 <PemToDer+0x338>)
 801968e:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8019692:	e7d5      	b.n	8019640 <PemToDer+0x78>
            }
#ifdef HAVE_ECC
            else if (header == BEGIN_ENC_PRIV_KEY) {
 8019694:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019698:	4a98      	ldr	r2, [pc, #608]	@ (80198fc <PemToDer+0x334>)
 801969a:	4293      	cmp	r3, r2
 801969c:	d106      	bne.n	80196ac <PemToDer+0xe4>
                header = BEGIN_EC_PRIV;
 801969e:	4b99      	ldr	r3, [pc, #612]	@ (8019904 <PemToDer+0x33c>)
 80196a0:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_EC_PRIV;
 80196a4:	4b98      	ldr	r3, [pc, #608]	@ (8019908 <PemToDer+0x340>)
 80196a6:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80196aa:	e7c9      	b.n	8019640 <PemToDer+0x78>
            }
            else if (header == BEGIN_EC_PRIV) {
 80196ac:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80196b0:	4a94      	ldr	r2, [pc, #592]	@ (8019904 <PemToDer+0x33c>)
 80196b2:	4293      	cmp	r3, r2
 80196b4:	d126      	bne.n	8019704 <PemToDer+0x13c>
                header = BEGIN_DSA_PRIV;
 80196b6:	4b95      	ldr	r3, [pc, #596]	@ (801990c <PemToDer+0x344>)
 80196b8:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_DSA_PRIV;
 80196bc:	4b94      	ldr	r3, [pc, #592]	@ (8019910 <PemToDer+0x348>)
 80196be:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80196c2:	e7bd      	b.n	8019640 <PemToDer+0x78>
            #else
                break;
            #endif
            }
        }
        else if (type == PUBLICKEY_TYPE) {
 80196c4:	687b      	ldr	r3, [r7, #4]
 80196c6:	2b0e      	cmp	r3, #14
 80196c8:	d10b      	bne.n	80196e2 <PemToDer+0x11a>
            if (header == BEGIN_PUB_KEY) {
 80196ca:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80196ce:	4a91      	ldr	r2, [pc, #580]	@ (8019914 <PemToDer+0x34c>)
 80196d0:	4293      	cmp	r3, r2
 80196d2:	d119      	bne.n	8019708 <PemToDer+0x140>
                header = BEGIN_RSA_PUB;
 80196d4:	4b90      	ldr	r3, [pc, #576]	@ (8019918 <PemToDer+0x350>)
 80196d6:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_RSA_PUB;
 80196da:	4b90      	ldr	r3, [pc, #576]	@ (801991c <PemToDer+0x354>)
 80196dc:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80196e0:	e7ae      	b.n	8019640 <PemToDer+0x78>
            else {
                break;
            }
        }
#if defined(HAVE_ECC) && defined(OPENSSL_EXTRA)
        else if (type == ECC_PARAM_TYPE) {
 80196e2:	687b      	ldr	r3, [r7, #4]
 80196e4:	2b29      	cmp	r3, #41	@ 0x29
 80196e6:	d111      	bne.n	801970c <PemToDer+0x144>
            if (header == BEGIN_EC_PARAM) {
 80196e8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80196ec:	4a8c      	ldr	r2, [pc, #560]	@ (8019920 <PemToDer+0x358>)
 80196ee:	4293      	cmp	r3, r2
 80196f0:	d10e      	bne.n	8019710 <PemToDer+0x148>
                header = BEGIN_EC_PARAM;
 80196f2:	4b8b      	ldr	r3, [pc, #556]	@ (8019920 <PemToDer+0x358>)
 80196f4:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = END_EC_PARAM;
 80196f8:	4b8a      	ldr	r3, [pc, #552]	@ (8019924 <PemToDer+0x35c>)
 80196fa:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
        headerEnd = XSTRNSTR((char*)buff, header, sz);
 80196fe:	e79f      	b.n	8019640 <PemToDer+0x78>
            break;
 8019700:	bf00      	nop
 8019702:	e006      	b.n	8019712 <PemToDer+0x14a>
                break;
 8019704:	bf00      	nop
 8019706:	e004      	b.n	8019712 <PemToDer+0x14a>
                break;
 8019708:	bf00      	nop
 801970a:	e002      	b.n	8019712 <PemToDer+0x14a>
            header =  BEGIN_X509_CRL;
            footer = END_X509_CRL;
        }
#endif
        else {
            break;
 801970c:	bf00      	nop
 801970e:	e000      	b.n	8019712 <PemToDer+0x14a>
                break;
 8019710:	bf00      	nop
        }
    }

    if (!headerEnd) {
 8019712:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019716:	2b00      	cmp	r3, #0
 8019718:	f040 8110 	bne.w	801993c <PemToDer+0x374>
#ifdef OPENSSL_EXTRA
        if (type == PRIVATEKEY_TYPE
 801971c:	687b      	ldr	r3, [r7, #4]
 801971e:	2b01      	cmp	r3, #1
 8019720:	f040 80d4 	bne.w	80198cc <PemToDer+0x304>
#ifdef WOLFSSL_DUAL_ALG_CERTS
            || type == ALT_PRIVATEKEY_TYPE
#endif
           ) {
            /* see if there is a -----BEGIN * PRIVATE KEY----- header */
            headerEnd = XSTRNSTR((char*)buff, PRIV_KEY_SUFFIX, sz);
 8019724:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8019728:	497f      	ldr	r1, [pc, #508]	@ (8019928 <PemToDer+0x360>)
 801972a:	68f8      	ldr	r0, [r7, #12]
 801972c:	f00d fe58 	bl	80273e0 <mystrnstr>
 8019730:	4603      	mov	r3, r0
 8019732:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
            if (headerEnd) {
 8019736:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801973a:	2b00      	cmp	r3, #0
 801973c:	f000 80c6 	beq.w	80198cc <PemToDer+0x304>
                const char* beginEnd;
                unsigned int endLen;

                beginEnd = headerEnd + XSTR_SIZEOF(PRIV_KEY_SUFFIX);
 8019740:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019744:	3310      	adds	r3, #16
 8019746:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
                if (beginEnd >= (char*)buff + sz) {
 801974a:	68fa      	ldr	r2, [r7, #12]
 801974c:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8019750:	4413      	add	r3, r2
 8019752:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8019756:	429a      	cmp	r2, r3
 8019758:	d307      	bcc.n	801976a <PemToDer+0x1a2>
                    return BUFFER_E;
 801975a:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801975e:	e2dc      	b.n	8019d1a <PemToDer+0x752>
                /* back up to BEGIN_PRIV_KEY_PREFIX */
                while (headerEnd > (char*)buff &&
                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,
                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&
                        *headerEnd != '\n') {
                    headerEnd--;
 8019760:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019764:	3b01      	subs	r3, #1
 8019766:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
                while (headerEnd > (char*)buff &&
 801976a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&
 801976e:	68fa      	ldr	r2, [r7, #12]
 8019770:	429a      	cmp	r2, r3
 8019772:	d20e      	bcs.n	8019792 <PemToDer+0x1ca>
                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,
 8019774:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019778:	220a      	movs	r2, #10
 801977a:	496c      	ldr	r1, [pc, #432]	@ (801992c <PemToDer+0x364>)
 801977c:	4618      	mov	r0, r3
 801977e:	f00e feaf 	bl	80284e0 <strncmp>
 8019782:	4603      	mov	r3, r0
                while (headerEnd > (char*)buff &&
 8019784:	2b00      	cmp	r3, #0
 8019786:	d004      	beq.n	8019792 <PemToDer+0x1ca>
                        *headerEnd != '\n') {
 8019788:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801978c:	781b      	ldrb	r3, [r3, #0]
                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&
 801978e:	2b0a      	cmp	r3, #10
 8019790:	d1e6      	bne.n	8019760 <PemToDer+0x198>
                }
                if (headerEnd <= (char*)buff ||
 8019792:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019796:	68fa      	ldr	r2, [r7, #12]
 8019798:	429a      	cmp	r2, r3
 801979a:	d210      	bcs.n	80197be <PemToDer+0x1f6>
                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,
 801979c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80197a0:	220a      	movs	r2, #10
 80197a2:	4962      	ldr	r1, [pc, #392]	@ (801992c <PemToDer+0x364>)
 80197a4:	4618      	mov	r0, r3
 80197a6:	f00e fe9b 	bl	80284e0 <strncmp>
 80197aa:	4603      	mov	r3, r0
                if (headerEnd <= (char*)buff ||
 80197ac:	2b00      	cmp	r3, #0
 80197ae:	d106      	bne.n	80197be <PemToDer+0x1f6>
                        XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 ||
                        beginEnd - headerEnd > PEM_LINE_LEN) {
 80197b0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80197b4:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80197b8:	1ad3      	subs	r3, r2, r3
                        XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 ||
 80197ba:	2b4c      	cmp	r3, #76	@ 0x4c
 80197bc:	dd0c      	ble.n	80197d8 <PemToDer+0x210>
                    WOLFSSL_MSG("Couldn't find PEM header");
                    WOLFSSL_ERROR(ASN_NO_PEM_HEADER);
 80197be:	2300      	movs	r3, #0
 80197c0:	9300      	str	r3, [sp, #0]
 80197c2:	4b5b      	ldr	r3, [pc, #364]	@ (8019930 <PemToDer+0x368>)
 80197c4:	f246 32f1 	movw	r2, #25585	@ 0x63f1
 80197c8:	495a      	ldr	r1, [pc, #360]	@ (8019934 <PemToDer+0x36c>)
 80197ca:	f06f 00a1 	mvn.w	r0, #161	@ 0xa1
 80197ce:	f005 f915 	bl	801e9fc <WOLFSSL_ERROR_LINE>
                    return ASN_NO_PEM_HEADER;
 80197d2:	f06f 03a1 	mvn.w	r3, #161	@ 0xa1
 80197d6:	e2a0      	b.n	8019d1a <PemToDer+0x752>
                }

                /* headerEnd now points to beginning of header */
                XMEMCPY(beginBuf, headerEnd, (size_t)(beginEnd - headerEnd));
 80197d8:	f8d7 10bc 	ldr.w	r1, [r7, #188]	@ 0xbc
 80197dc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80197e0:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80197e4:	1ad3      	subs	r3, r2, r3
 80197e6:	461a      	mov	r2, r3
 80197e8:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 80197ec:	4618      	mov	r0, r3
 80197ee:	f00e fed9 	bl	80285a4 <memcpy>
                beginBuf[beginEnd - headerEnd] = '\0';
 80197f2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80197f6:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 80197fa:	1ad3      	subs	r3, r2, r3
 80197fc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8019800:	443b      	add	r3, r7
 8019802:	2200      	movs	r2, #0
 8019804:	f803 2c9c 	strb.w	r2, [r3, #-156]
                /* look for matching footer */
                footer = XSTRNSTR(beginEnd,
 8019808:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 801980c:	330a      	adds	r3, #10
 801980e:	68f9      	ldr	r1, [r7, #12]
 8019810:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 8019814:	4411      	add	r1, r2
 8019816:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801981a:	1a8a      	subs	r2, r1, r2
 801981c:	4619      	mov	r1, r3
 801981e:	f8d7 00e4 	ldr.w	r0, [r7, #228]	@ 0xe4
 8019822:	f00d fddd 	bl	80273e0 <mystrnstr>
 8019826:	4603      	mov	r3, r0
 8019828:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
                                beginBuf + XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX),
                                (unsigned int)((char*)buff + sz - beginEnd));
                if (!footer) {
 801982c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8019830:	2b00      	cmp	r3, #0
 8019832:	d10c      	bne.n	801984e <PemToDer+0x286>
                    WOLFSSL_MSG("Couldn't find PEM footer");
                    WOLFSSL_ERROR(ASN_NO_PEM_HEADER);
 8019834:	2300      	movs	r3, #0
 8019836:	9300      	str	r3, [sp, #0]
 8019838:	4b3d      	ldr	r3, [pc, #244]	@ (8019930 <PemToDer+0x368>)
 801983a:	f246 32fe 	movw	r2, #25598	@ 0x63fe
 801983e:	493d      	ldr	r1, [pc, #244]	@ (8019934 <PemToDer+0x36c>)
 8019840:	f06f 00a1 	mvn.w	r0, #161	@ 0xa1
 8019844:	f005 f8da 	bl	801e9fc <WOLFSSL_ERROR_LINE>
                    return ASN_NO_PEM_HEADER;
 8019848:	f06f 03a1 	mvn.w	r3, #161	@ 0xa1
 801984c:	e265      	b.n	8019d1a <PemToDer+0x752>
                }

                footer -= XSTR_SIZEOF(END_PRIV_KEY_PREFIX);
 801984e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8019852:	3b08      	subs	r3, #8
 8019854:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
                if (footer > (char*)buff + sz - XSTR_SIZEOF(END_PRIV_KEY_PREFIX)
 8019858:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 801985c:	3b08      	subs	r3, #8
 801985e:	68fa      	ldr	r2, [r7, #12]
 8019860:	441a      	add	r2, r3
 8019862:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8019866:	429a      	cmp	r2, r3
 8019868:	d309      	bcc.n	801987e <PemToDer+0x2b6>
                        || XSTRNCMP(footer, END_PRIV_KEY_PREFIX,
 801986a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801986e:	2208      	movs	r2, #8
 8019870:	4931      	ldr	r1, [pc, #196]	@ (8019938 <PemToDer+0x370>)
 8019872:	4618      	mov	r0, r3
 8019874:	f00e fe34 	bl	80284e0 <strncmp>
 8019878:	4603      	mov	r3, r0
 801987a:	2b00      	cmp	r3, #0
 801987c:	d002      	beq.n	8019884 <PemToDer+0x2bc>
                            XSTR_SIZEOF(END_PRIV_KEY_PREFIX)) != 0) {
                    WOLFSSL_MSG("Unexpected footer for PEM");
                    return BUFFER_E;
 801987e:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019882:	e24a      	b.n	8019d1a <PemToDer+0x752>
                }

                endLen = (unsigned int)((size_t)(beginEnd - headerEnd) -
 8019884:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019888:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801988c:	1ad3      	subs	r3, r2, r3
 801988e:	3b02      	subs	r3, #2
 8019890:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
                            (XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX) -
                                    XSTR_SIZEOF(END_PRIV_KEY_PREFIX)));
                XMEMCPY(endBuf, footer, (size_t)endLen);
 8019894:	f8d7 10c0 	ldr.w	r1, [r7, #192]	@ 0xc0
 8019898:	f107 0314 	add.w	r3, r7, #20
 801989c:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80198a0:	4618      	mov	r0, r3
 80198a2:	f00e fe7f 	bl	80285a4 <memcpy>
                endBuf[endLen] = '\0';
 80198a6:	f107 0214 	add.w	r2, r7, #20
 80198aa:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80198ae:	4413      	add	r3, r2
 80198b0:	2200      	movs	r2, #0
 80198b2:	701a      	strb	r2, [r3, #0]

                header = beginBuf;
 80198b4:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 80198b8:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                footer = endBuf;
 80198bc:	f107 0314 	add.w	r3, r7, #20
 80198c0:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
                headerEnd = beginEnd;
 80198c4:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80198c8:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
            }
        }

        if (!headerEnd) {
 80198cc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80198d0:	2b00      	cmp	r3, #0
 80198d2:	d13e      	bne.n	8019952 <PemToDer+0x38a>
            WOLFSSL_MSG("Couldn't find PEM header");
            WOLFSSL_ERROR(ASN_NO_PEM_HEADER);
 80198d4:	2300      	movs	r3, #0
 80198d6:	9300      	str	r3, [sp, #0]
 80198d8:	4b15      	ldr	r3, [pc, #84]	@ (8019930 <PemToDer+0x368>)
 80198da:	f246 4218 	movw	r2, #25624	@ 0x6418
 80198de:	4915      	ldr	r1, [pc, #84]	@ (8019934 <PemToDer+0x36c>)
 80198e0:	f06f 00a1 	mvn.w	r0, #161	@ 0xa1
 80198e4:	f005 f88a 	bl	801e9fc <WOLFSSL_ERROR_LINE>
            return ASN_NO_PEM_HEADER;
 80198e8:	f06f 03a1 	mvn.w	r3, #161	@ 0xa1
 80198ec:	e215      	b.n	8019d1a <PemToDer+0x752>
 80198ee:	bf00      	nop
 80198f0:	0802f970 	.word	0x0802f970
 80198f4:	0802f9f0 	.word	0x0802f9f0
 80198f8:	0802fa0c 	.word	0x0802fa0c
 80198fc:	0802fa28 	.word	0x0802fa28
 8019900:	0802fa50 	.word	0x0802fa50
 8019904:	0802fa74 	.word	0x0802fa74
 8019908:	0802fa94 	.word	0x0802fa94
 801990c:	0802faf0 	.word	0x0802faf0
 8019910:	0802fb10 	.word	0x0802fb10
 8019914:	0802fb30 	.word	0x0802fb30
 8019918:	0802f9b0 	.word	0x0802f9b0
 801991c:	0802f9d0 	.word	0x0802f9d0
 8019920:	0802fab4 	.word	0x0802fab4
 8019924:	0802fad4 	.word	0x0802fad4
 8019928:	080338c4 	.word	0x080338c4
 801992c:	080338b8 	.word	0x080338b8
 8019930:	0802fbc8 	.word	0x0802fbc8
 8019934:	08033910 	.word	0x08033910
 8019938:	080338d8 	.word	0x080338d8
#else
        WOLFSSL_MSG("Couldn't find PEM header");
        return ASN_NO_PEM_HEADER;
#endif
    } else {
        headerEnd += XSTRLEN(header);
 801993c:	f8d7 40bc 	ldr.w	r4, [r7, #188]	@ 0xbc
 8019940:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019944:	4618      	mov	r0, r3
 8019946:	f7e6 fc4d 	bl	80001e4 <strlen>
 801994a:	4603      	mov	r3, r0
 801994c:	4423      	add	r3, r4
 801994e:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    }

    /* eat end of line characters */
    headerEnd = SkipEndOfLineChars(headerEnd, bufferEnd);
 8019952:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019956:	f8d7 10ec 	ldr.w	r1, [r7, #236]	@ 0xec
 801995a:	4618      	mov	r0, r3
 801995c:	f7ff fb4b 	bl	8018ff6 <SkipEndOfLineChars>
 8019960:	4603      	mov	r3, r0
 8019962:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc

    if (keyFormat) {
 8019966:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801996a:	2b00      	cmp	r3, #0
 801996c:	d016      	beq.n	801999c <PemToDer+0x3d4>
        /* keyFormat is Key_Sum enum */
        if (type == PRIVATEKEY_TYPE
 801996e:	687b      	ldr	r3, [r7, #4]
 8019970:	2b01      	cmp	r3, #1
 8019972:	d113      	bne.n	801999c <PemToDer+0x3d4>
        #ifdef WOLFSSL_DUAL_ALG_CERTS
            || type == ALT_PRIVATEKEY_TYPE
        #endif
           ) {
        #ifndef NO_RSA
            if (header == BEGIN_RSA_PRIV)
 8019974:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019978:	4aaf      	ldr	r2, [pc, #700]	@ (8019c38 <PemToDer+0x670>)
 801997a:	4293      	cmp	r3, r2
 801997c:	d104      	bne.n	8019988 <PemToDer+0x3c0>
                *keyFormat = RSAk;
 801997e:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019982:	f240 2285 	movw	r2, #645	@ 0x285
 8019986:	601a      	str	r2, [r3, #0]
        #endif
        #ifdef HAVE_ECC
            if (header == BEGIN_EC_PRIV)
 8019988:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801998c:	4aab      	ldr	r2, [pc, #684]	@ (8019c3c <PemToDer+0x674>)
 801998e:	4293      	cmp	r3, r2
 8019990:	d104      	bne.n	801999c <PemToDer+0x3d4>
                *keyFormat = ECDSAk;
 8019992:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019996:	f240 2206 	movw	r2, #518	@ 0x206
 801999a:	601a      	str	r2, [r3, #0]
        }
    #endif
    }

#ifdef WOLFSSL_ENCRYPTED_KEYS
    if (info) {
 801999c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80199a0:	2b00      	cmp	r3, #0
 80199a2:	d021      	beq.n	80199e8 <PemToDer+0x420>
        ret = wc_EncryptedInfoParse(info, &headerEnd,
                                    (size_t)(bufferEnd - headerEnd));
 80199a4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80199a8:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 80199ac:	1ad3      	subs	r3, r2, r3
        ret = wc_EncryptedInfoParse(info, &headerEnd,
 80199ae:	461a      	mov	r2, r3
 80199b0:	f107 03bc 	add.w	r3, r7, #188	@ 0xbc
 80199b4:	4619      	mov	r1, r3
 80199b6:	f8d7 0114 	ldr.w	r0, [r7, #276]	@ 0x114
 80199ba:	f7ff fcdb 	bl	8019374 <wc_EncryptedInfoParse>
 80199be:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
        if (ret < 0)
 80199c2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80199c6:	2b00      	cmp	r3, #0
 80199c8:	da02      	bge.n	80199d0 <PemToDer+0x408>
            return ret;
 80199ca:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80199ce:	e1a4      	b.n	8019d1a <PemToDer+0x752>
        if (info->set)
 80199d0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80199d4:	f893 3088 	ldrb.w	r3, [r3, #136]	@ 0x88
 80199d8:	f003 0301 	and.w	r3, r3, #1
 80199dc:	b2db      	uxtb	r3, r3
 80199de:	2b00      	cmp	r3, #0
 80199e0:	d002      	beq.n	80199e8 <PemToDer+0x420>
            encrypted_key = 1;
 80199e2:	2301      	movs	r3, #1
 80199e4:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    }
#endif /* WOLFSSL_ENCRYPTED_KEYS */

    /* find footer */
    footerEnd = XSTRNSTR(headerEnd, footer, (unsigned int)((char*)buff +
 80199e8:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 80199ec:	f8d7 10c0 	ldr.w	r1, [r7, #192]	@ 0xc0
 80199f0:	68fa      	ldr	r2, [r7, #12]
 80199f2:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80199f6:	441a      	add	r2, r3
 80199f8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80199fc:	1ad3      	subs	r3, r2, r3
 80199fe:	461a      	mov	r2, r3
 8019a00:	f00d fcee 	bl	80273e0 <mystrnstr>
 8019a04:	f8c7 00f0 	str.w	r0, [r7, #240]	@ 0xf0
        sz - headerEnd));
    if (!footerEnd) {
 8019a08:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8019a0c:	2b00      	cmp	r3, #0
 8019a0e:	d10a      	bne.n	8019a26 <PemToDer+0x45e>
        if (info)
 8019a10:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019a14:	2b00      	cmp	r3, #0
 8019a16:	d003      	beq.n	8019a20 <PemToDer+0x458>
            info->consumed = longSz; /* No more certs if no footer */
 8019a18:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019a1c:	68ba      	ldr	r2, [r7, #8]
 8019a1e:	601a      	str	r2, [r3, #0]
        return BUFFER_E;
 8019a20:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019a24:	e179      	b.n	8019d1a <PemToDer+0x752>
    }

    consumedEnd = footerEnd + XSTRLEN(footer);
 8019a26:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8019a2a:	4618      	mov	r0, r3
 8019a2c:	f7e6 fbda 	bl	80001e4 <strlen>
 8019a30:	4602      	mov	r2, r0
 8019a32:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8019a36:	4413      	add	r3, r2
 8019a38:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    if (consumedEnd < bufferEnd) { /* handle no end of line on last line */
 8019a3c:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8019a40:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 8019a44:	429a      	cmp	r2, r3
 8019a46:	d217      	bcs.n	8019a78 <PemToDer+0x4b0>
        /* eat end of line characters */
        consumedEnd = SkipEndOfLineChars(consumedEnd, bufferEnd);
 8019a48:	f8d7 10ec 	ldr.w	r1, [r7, #236]	@ 0xec
 8019a4c:	f8d7 00fc 	ldr.w	r0, [r7, #252]	@ 0xfc
 8019a50:	f7ff fad1 	bl	8018ff6 <SkipEndOfLineChars>
 8019a54:	f8c7 00fc 	str.w	r0, [r7, #252]	@ 0xfc
        /* skip possible null term */
        if (consumedEnd < bufferEnd && consumedEnd[0] == '\0')
 8019a58:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8019a5c:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 8019a60:	429a      	cmp	r2, r3
 8019a62:	d209      	bcs.n	8019a78 <PemToDer+0x4b0>
 8019a64:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8019a68:	781b      	ldrb	r3, [r3, #0]
 8019a6a:	2b00      	cmp	r3, #0
 8019a6c:	d104      	bne.n	8019a78 <PemToDer+0x4b0>
            consumedEnd++;
 8019a6e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8019a72:	3301      	adds	r3, #1
 8019a74:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    }

    if (info)
 8019a78:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019a7c:	2b00      	cmp	r3, #0
 8019a7e:	d006      	beq.n	8019a8e <PemToDer+0x4c6>
        info->consumed = (long)(consumedEnd - (const char*)buff);
 8019a80:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8019a84:	68fb      	ldr	r3, [r7, #12]
 8019a86:	1ad2      	subs	r2, r2, r3
 8019a88:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019a8c:	601a      	str	r2, [r3, #0]

    /* set up der buffer */
    neededSz = (long)(footerEnd - headerEnd);
 8019a8e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8019a92:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8019a96:	1ad3      	subs	r3, r2, r3
 8019a98:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    if (neededSz > (long)sz || neededSz <= 0)
 8019a9c:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8019aa0:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8019aa4:	429a      	cmp	r2, r3
 8019aa6:	dc03      	bgt.n	8019ab0 <PemToDer+0x4e8>
 8019aa8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8019aac:	2b00      	cmp	r3, #0
 8019aae:	dc02      	bgt.n	8019ab6 <PemToDer+0x4ee>
        return BUFFER_E;
 8019ab0:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019ab4:	e131      	b.n	8019d1a <PemToDer+0x752>

    ret = AllocDer(pDer, (word32)neededSz, type, heap);
 8019ab6:	f8d7 10dc 	ldr.w	r1, [r7, #220]	@ 0xdc
 8019aba:	f507 7380 	add.w	r3, r7, #256	@ 0x100
 8019abe:	f5a3 7080 	sub.w	r0, r3, #256	@ 0x100
 8019ac2:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8019ac6:	687a      	ldr	r2, [r7, #4]
 8019ac8:	6800      	ldr	r0, [r0, #0]
 8019aca:	f7ff f987 	bl	8018ddc <AllocDer>
 8019ace:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
    if (ret < 0) {
 8019ad2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019ad6:	2b00      	cmp	r3, #0
 8019ad8:	da02      	bge.n	8019ae0 <PemToDer+0x518>
        return ret;
 8019ada:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019ade:	e11c      	b.n	8019d1a <PemToDer+0x752>
    }
    der = *pDer;
 8019ae0:	f507 7380 	add.w	r3, r7, #256	@ 0x100
 8019ae4:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 8019ae8:	681b      	ldr	r3, [r3, #0]
 8019aea:	681b      	ldr	r3, [r3, #0]
 8019aec:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8

    if (Base64_Decode((byte*)headerEnd, (word32)neededSz,
 8019af0:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8019af4:	f8d7 10dc 	ldr.w	r1, [r7, #220]	@ 0xdc
 8019af8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019afc:	681a      	ldr	r2, [r3, #0]
 8019afe:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019b02:	3308      	adds	r3, #8
 8019b04:	f000 fc14 	bl	801a330 <Base64_Decode>
 8019b08:	4603      	mov	r3, r0
 8019b0a:	2b00      	cmp	r3, #0
 8019b0c:	da0c      	bge.n	8019b28 <PemToDer+0x560>
                      der->buffer, &der->length) < 0) {
        WOLFSSL_ERROR(BUFFER_E);
 8019b0e:	2300      	movs	r3, #0
 8019b10:	9300      	str	r3, [sp, #0]
 8019b12:	4b4b      	ldr	r3, [pc, #300]	@ (8019c40 <PemToDer+0x678>)
 8019b14:	f246 4272 	movw	r2, #25714	@ 0x6472
 8019b18:	494a      	ldr	r1, [pc, #296]	@ (8019c44 <PemToDer+0x67c>)
 8019b1a:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 8019b1e:	f004 ff6d 	bl	801e9fc <WOLFSSL_ERROR_LINE>
        return BUFFER_E;
 8019b22:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8019b26:	e0f8      	b.n	8019d1a <PemToDer+0x752>
    }

    if ((header == BEGIN_PRIV_KEY
 8019b28:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019b2c:	4a46      	ldr	r2, [pc, #280]	@ (8019c48 <PemToDer+0x680>)
 8019b2e:	4293      	cmp	r3, r2
 8019b30:	d00a      	beq.n	8019b48 <PemToDer+0x580>
#ifdef OPENSSL_EXTRA
         || header == beginBuf
 8019b32:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8019b36:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 8019b3a:	429a      	cmp	r2, r3
 8019b3c:	d004      	beq.n	8019b48 <PemToDer+0x580>
#endif
#ifdef HAVE_ECC
         || header == BEGIN_EC_PRIV
 8019b3e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019b42:	4a3e      	ldr	r2, [pc, #248]	@ (8019c3c <PemToDer+0x674>)
 8019b44:	4293      	cmp	r3, r2
 8019b46:	d124      	bne.n	8019b92 <PemToDer+0x5ca>
#endif
        ) && !encrypted_key)
 8019b48:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8019b4c:	2b00      	cmp	r3, #0
 8019b4e:	d120      	bne.n	8019b92 <PemToDer+0x5ca>
    {
        /* detect pkcs8 key and get alg type */
        /* keep PKCS8 header */
        idx = 0;
 8019b50:	2300      	movs	r3, #0
 8019b52:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
        ret = ToTraditionalInline_ex(der->buffer, &idx, der->length, &algId);
 8019b56:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019b5a:	6818      	ldr	r0, [r3, #0]
 8019b5c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019b60:	689a      	ldr	r2, [r3, #8]
 8019b62:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 8019b66:	f107 01b4 	add.w	r1, r7, #180	@ 0xb4
 8019b6a:	f7fb f991 	bl	8014e90 <ToTraditionalInline_ex>
 8019b6e:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
        if (ret > 0) {
 8019b72:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019b76:	2b00      	cmp	r3, #0
 8019b78:	dd09      	ble.n	8019b8e <PemToDer+0x5c6>
            if (keyFormat)
 8019b7a:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019b7e:	2b00      	cmp	r3, #0
 8019b80:	d005      	beq.n	8019b8e <PemToDer+0x5c6>
                *keyFormat = (int)algId;
 8019b82:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8019b86:	461a      	mov	r2, r3
 8019b88:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019b8c:	601a      	str	r2, [r3, #0]
        }
        else {
            /* ignore failure here and assume key is not pkcs8 wrapped */
        }
        return 0;
 8019b8e:	2300      	movs	r3, #0
 8019b90:	e0c3      	b.n	8019d1a <PemToDer+0x752>
    }

#ifdef WOLFSSL_ENCRYPTED_KEYS
    if (encrypted_key || header == BEGIN_ENC_PRIV_KEY) {
 8019b92:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8019b96:	2b00      	cmp	r3, #0
 8019b98:	d105      	bne.n	8019ba6 <PemToDer+0x5de>
 8019b9a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019b9e:	4a2b      	ldr	r2, [pc, #172]	@ (8019c4c <PemToDer+0x684>)
 8019ba0:	4293      	cmp	r3, r2
 8019ba2:	f040 80b8 	bne.w	8019d16 <PemToDer+0x74e>
        int   passwordSz = NAME_SZ;
 8019ba6:	2350      	movs	r3, #80	@ 0x50
 8019ba8:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    #ifdef WOLFSSL_SMALL_STACK
        char* password = NULL;
 8019bac:	2300      	movs	r3, #0
 8019bae:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    #else
        char  password[NAME_SZ];
    #endif

        if (!info || !info->passwd_cb) {
 8019bb2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019bb6:	2b00      	cmp	r3, #0
 8019bb8:	d004      	beq.n	8019bc4 <PemToDer+0x5fc>
 8019bba:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019bbe:	685b      	ldr	r3, [r3, #4]
 8019bc0:	2b00      	cmp	r3, #0
 8019bc2:	d102      	bne.n	8019bca <PemToDer+0x602>
            WOLFSSL_MSG("No password callback set");
            WOLFSSL_ERROR_VERBOSE(NO_PASSWORD);
            return NO_PASSWORD;
 8019bc4:	f06f 03af 	mvn.w	r3, #175	@ 0xaf
 8019bc8:	e0a7      	b.n	8019d1a <PemToDer+0x752>
        }

    #ifdef WOLFSSL_SMALL_STACK
        password = (char*)XMALLOC(passwordSz, heap, DYNAMIC_TYPE_STRING);
 8019bca:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019bce:	4618      	mov	r0, r3
 8019bd0:	f004 ff60 	bl	801ea94 <wolfSSL_Malloc>
 8019bd4:	f8c7 00d0 	str.w	r0, [r7, #208]	@ 0xd0
        if (password == NULL) {
 8019bd8:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8019bdc:	2b00      	cmp	r3, #0
 8019bde:	d102      	bne.n	8019be6 <PemToDer+0x61e>
            return MEMORY_E;
 8019be0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8019be4:	e099      	b.n	8019d1a <PemToDer+0x752>
        }
    #endif

        /* get password */
        ret = info->passwd_cb(password, passwordSz, PEM_PASS_READ,
 8019be6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019bea:	685c      	ldr	r4, [r3, #4]
 8019bec:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019bf0:	689b      	ldr	r3, [r3, #8]
 8019bf2:	2200      	movs	r2, #0
 8019bf4:	f8d7 10d4 	ldr.w	r1, [r7, #212]	@ 0xd4
 8019bf8:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 8019bfc:	47a0      	blx	r4
 8019bfe:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
            info->passwd_userdata);
        if (ret >= 0) {
 8019c02:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019c06:	2b00      	cmp	r3, #0
 8019c08:	db6f      	blt.n	8019cea <PemToDer+0x722>
            passwordSz = ret;
 8019c0a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019c0e:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
        #ifdef WOLFSSL_CHECK_MEM_ZERO
            wc_MemZero_Add("PEM password", password, passwordSz);
        #endif

            /* convert and adjust length */
            if (header == BEGIN_ENC_PRIV_KEY) {
 8019c12:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8019c16:	4a0d      	ldr	r2, [pc, #52]	@ (8019c4c <PemToDer+0x684>)
 8019c18:	4293      	cmp	r3, r2
 8019c1a:	d104      	bne.n	8019c26 <PemToDer+0x65e>
                        ret = 0;
                    }
                }
            #else
                WOLFSSL_ERROR_VERBOSE(NOT_COMPILED_IN);
                ret = NOT_COMPILED_IN;
 8019c1c:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 8019c20:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8019c24:	e04c      	b.n	8019cc0 <PemToDer+0x6f8>
            #endif
            }
            /* decrypt the key */
            else {
                if (passwordSz == 0) {
 8019c26:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019c2a:	2b00      	cmp	r3, #0
 8019c2c:	d110      	bne.n	8019c50 <PemToDer+0x688>
                    /* The key is encrypted but does not have a password */
                    WOLFSSL_MSG("No password for encrypted key");
                    WOLFSSL_ERROR_VERBOSE(NO_PASSWORD);
                    ret = NO_PASSWORD;
 8019c2e:	f06f 03af 	mvn.w	r3, #175	@ 0xaf
 8019c32:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8019c36:	e043      	b.n	8019cc0 <PemToDer+0x6f8>
 8019c38:	0802f970 	.word	0x0802f970
 8019c3c:	0802fa74 	.word	0x0802fa74
 8019c40:	0802fbc8 	.word	0x0802fbc8
 8019c44:	08033910 	.word	0x08033910
 8019c48:	0802f9f0 	.word	0x0802f9f0
 8019c4c:	0802fa28 	.word	0x0802fa28
                else {
                #if ((defined(WOLFSSL_ENCRYPTED_KEYS) && !defined(NO_DES3)) || \
                         (!defined(NO_AES) && defined(HAVE_AES_CBC) && \
                          defined(HAVE_AES_DECRYPT))) && \
                        !defined(NO_WOLFSSL_SKIP_TRAILING_PAD)
                    int     padVal = 0;
 8019c50:	2300      	movs	r3, #0
 8019c52:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
                #endif

                    ret = wc_BufferKeyDecrypt(info, der->buffer, der->length,
 8019c56:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c5a:	6819      	ldr	r1, [r3, #0]
 8019c5c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c60:	689a      	ldr	r2, [r3, #8]
 8019c62:	2303      	movs	r3, #3
 8019c64:	9301      	str	r3, [sp, #4]
 8019c66:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019c6a:	9300      	str	r3, [sp, #0]
 8019c6c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8019c70:	f8d7 0114 	ldr.w	r0, [r7, #276]	@ 0x114
 8019c74:	f00d fa95 	bl	80271a2 <wc_BufferKeyDecrypt>
 8019c78:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
                        }
                    }
                #endif /* !NO_DES3 */
                #if !defined(NO_AES) && defined(HAVE_AES_CBC) && \
                    defined(HAVE_AES_DECRYPT)
                    if (info->cipherType == WC_CIPHER_AES_CBC) {
 8019c7c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8019c80:	68db      	ldr	r3, [r3, #12]
 8019c82:	2b02      	cmp	r3, #2
 8019c84:	d11c      	bne.n	8019cc0 <PemToDer+0x6f8>
                        if (der->length > WC_AES_BLOCK_SIZE) {
 8019c86:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c8a:	689b      	ldr	r3, [r3, #8]
 8019c8c:	2b10      	cmp	r3, #16
 8019c8e:	d917      	bls.n	8019cc0 <PemToDer+0x6f8>
                            padVal = der->buffer[der->length-1];
 8019c90:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c94:	681a      	ldr	r2, [r3, #0]
 8019c96:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019c9a:	689b      	ldr	r3, [r3, #8]
 8019c9c:	3b01      	subs	r3, #1
 8019c9e:	4413      	add	r3, r2
 8019ca0:	781b      	ldrb	r3, [r3, #0]
 8019ca2:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
                            if (padVal <= WC_AES_BLOCK_SIZE) {
 8019ca6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8019caa:	2b10      	cmp	r3, #16
 8019cac:	dc08      	bgt.n	8019cc0 <PemToDer+0x6f8>
                                der->length -= (word32)padVal;
 8019cae:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019cb2:	689a      	ldr	r2, [r3, #8]
 8019cb4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8019cb8:	1ad2      	subs	r2, r2, r3
 8019cba:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8019cbe:	609a      	str	r2, [r3, #8]
                #endif
#endif /* !NO_WOLFSSL_SKIP_TRAILING_PAD */
                }
            }
#ifdef OPENSSL_EXTRA
            if (ret) {
 8019cc0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8019cc4:	2b00      	cmp	r3, #0
 8019cc6:	d008      	beq.n	8019cda <PemToDer+0x712>
                WOLFSSL_PEMerr(0, WOLFSSL_PEM_R_BAD_DECRYPT_E);
 8019cc8:	f246 43fd 	movw	r3, #25853	@ 0x64fd
 8019ccc:	9300      	str	r3, [sp, #0]
 8019cce:	4b15      	ldr	r3, [pc, #84]	@ (8019d24 <PemToDer+0x75c>)
 8019cd0:	4a15      	ldr	r2, [pc, #84]	@ (8019d28 <PemToDer+0x760>)
 8019cd2:	2100      	movs	r1, #0
 8019cd4:	2009      	movs	r0, #9
 8019cd6:	f7f3 ff8d 	bl	800dbf4 <wolfSSL_ERR_put_error>
            }
#endif
            ForceZero(password, (word32)passwordSz);
 8019cda:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8019cde:	4619      	mov	r1, r3
 8019ce0:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 8019ce4:	f7f8 fcdb 	bl	801269e <ForceZero>
 8019ce8:	e009      	b.n	8019cfe <PemToDer+0x736>
        }
#ifdef OPENSSL_EXTRA
        else {
            WOLFSSL_PEMerr(0, WOLFSSL_PEM_R_BAD_PASSWORD_READ_E);
 8019cea:	f246 5304 	movw	r3, #25860	@ 0x6504
 8019cee:	9300      	str	r3, [sp, #0]
 8019cf0:	4b0c      	ldr	r3, [pc, #48]	@ (8019d24 <PemToDer+0x75c>)
 8019cf2:	f46f 72fe 	mvn.w	r2, #508	@ 0x1fc
 8019cf6:	2100      	movs	r1, #0
 8019cf8:	2009      	movs	r0, #9
 8019cfa:	f7f3 ff7b 	bl	800dbf4 <wolfSSL_ERR_put_error>
        }
#endif

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(password, heap, DYNAMIC_TYPE_STRING);
 8019cfe:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8019d02:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8019d06:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8019d0a:	2b00      	cmp	r3, #0
 8019d0c:	d003      	beq.n	8019d16 <PemToDer+0x74e>
 8019d0e:	f8d7 00c8 	ldr.w	r0, [r7, #200]	@ 0xc8
 8019d12:	f004 fedb 	bl	801eacc <wolfSSL_Free>
        wc_MemZero_Check(password, NAME_SZ);
    #endif
    }
#endif /* WOLFSSL_ENCRYPTED_KEYS */

    return ret;
 8019d16:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
}
 8019d1a:	4618      	mov	r0, r3
 8019d1c:	f507 7782 	add.w	r7, r7, #260	@ 0x104
 8019d20:	46bd      	mov	sp, r7
 8019d22:	bd90      	pop	{r4, r7, pc}
 8019d24:	0802fbc8 	.word	0x0802fbc8
 8019d28:	fffffe02 	.word	0xfffffe02

08019d2c <DecodeECC_DSA_Sig_Ex>:
    return DecodeECC_DSA_Sig_Ex(sig, sigLen, r, s, 1);
}

int DecodeECC_DSA_Sig_Ex(const byte* sig, word32 sigLen, mp_int* r, mp_int* s,
    int init)
{
 8019d2c:	b580      	push	{r7, lr}
 8019d2e:	b0a0      	sub	sp, #128	@ 0x80
 8019d30:	af04      	add	r7, sp, #16
 8019d32:	60f8      	str	r0, [r7, #12]
 8019d34:	60b9      	str	r1, [r7, #8]
 8019d36:	607a      	str	r2, [r7, #4]
 8019d38:	603b      	str	r3, [r7, #0]
#endif

    return 0;
#else
    ASNGetData dataASN[dsaSigASN_Length];
    word32 idx = 0;
 8019d3a:	2300      	movs	r3, #0
 8019d3c:	617b      	str	r3, [r7, #20]
    int ret;

    /* Clear dynamic data and set mp_ints to put r and s into. */
    XMEMSET(dataASN, 0, sizeof(dataASN));
 8019d3e:	f107 0318 	add.w	r3, r7, #24
 8019d42:	2254      	movs	r2, #84	@ 0x54
 8019d44:	2100      	movs	r1, #0
 8019d46:	4618      	mov	r0, r3
 8019d48:	f00e fbc2 	bl	80284d0 <memset>
    if (init) {
 8019d4c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8019d4e:	2b00      	cmp	r3, #0
 8019d50:	d00a      	beq.n	8019d68 <DecodeECC_DSA_Sig_Ex+0x3c>
        GetASN_MP(&dataASN[DSASIGASN_IDX_R], r);
 8019d52:	2308      	movs	r3, #8
 8019d54:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
 8019d58:	687b      	ldr	r3, [r7, #4]
 8019d5a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        GetASN_MP(&dataASN[DSASIGASN_IDX_S], s);
 8019d5c:	2308      	movs	r3, #8
 8019d5e:	f887 3068 	strb.w	r3, [r7, #104]	@ 0x68
 8019d62:	683b      	ldr	r3, [r7, #0]
 8019d64:	65bb      	str	r3, [r7, #88]	@ 0x58
 8019d66:	e009      	b.n	8019d7c <DecodeECC_DSA_Sig_Ex+0x50>
    }
    else {
        GetASN_MP_Inited(&dataASN[DSASIGASN_IDX_R], r);
 8019d68:	2309      	movs	r3, #9
 8019d6a:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
 8019d6e:	687b      	ldr	r3, [r7, #4]
 8019d70:	63fb      	str	r3, [r7, #60]	@ 0x3c
        GetASN_MP_Inited(&dataASN[DSASIGASN_IDX_S], s);
 8019d72:	2309      	movs	r3, #9
 8019d74:	f887 3068 	strb.w	r3, [r7, #104]	@ 0x68
 8019d78:	683b      	ldr	r3, [r7, #0]
 8019d7a:	65bb      	str	r3, [r7, #88]	@ 0x58
    }

    /* Decode the DSA signature. */
    ret = GetASN_Items(dsaSigASN, dataASN, dsaSigASN_Length, 0, sig, &idx,
 8019d7c:	f107 0118 	add.w	r1, r7, #24
 8019d80:	68bb      	ldr	r3, [r7, #8]
 8019d82:	9302      	str	r3, [sp, #8]
 8019d84:	f107 0314 	add.w	r3, r7, #20
 8019d88:	9301      	str	r3, [sp, #4]
 8019d8a:	68fb      	ldr	r3, [r7, #12]
 8019d8c:	9300      	str	r3, [sp, #0]
 8019d8e:	2300      	movs	r3, #0
 8019d90:	2203      	movs	r2, #3
 8019d92:	4811      	ldr	r0, [pc, #68]	@ (8019dd8 <DecodeECC_DSA_Sig_Ex+0xac>)
 8019d94:	f7f9 fcba 	bl	801370c <GetASN_Items>
 8019d98:	66f8      	str	r0, [r7, #108]	@ 0x6c
                       sigLen);

    if (ret != 0) {
 8019d9a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8019d9c:	2b00      	cmp	r3, #0
 8019d9e:	d002      	beq.n	8019da6 <DecodeECC_DSA_Sig_Ex+0x7a>
        ret = ASN_ECC_KEY_E;
 8019da0:	f06f 03aa 	mvn.w	r3, #170	@ 0xaa
 8019da4:	66fb      	str	r3, [r7, #108]	@ 0x6c
    }

#ifndef NO_STRICT_ECDSA_LEN
    /* sanity check that the index has been advanced all the way to the end of
     * the buffer */
    if ((ret == 0) && (idx != sigLen)) {
 8019da6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8019da8:	2b00      	cmp	r3, #0
 8019daa:	d106      	bne.n	8019dba <DecodeECC_DSA_Sig_Ex+0x8e>
 8019dac:	697b      	ldr	r3, [r7, #20]
 8019dae:	68ba      	ldr	r2, [r7, #8]
 8019db0:	429a      	cmp	r2, r3
 8019db2:	d002      	beq.n	8019dba <DecodeECC_DSA_Sig_Ex+0x8e>
        ret = ASN_ECC_KEY_E;
 8019db4:	f06f 03aa 	mvn.w	r3, #170	@ 0xaa
 8019db8:	66fb      	str	r3, [r7, #108]	@ 0x6c
    }
#endif
    if (ret != 0) {
 8019dba:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8019dbc:	2b00      	cmp	r3, #0
 8019dbe:	d005      	beq.n	8019dcc <DecodeECC_DSA_Sig_Ex+0xa0>
        mp_clear(r);
 8019dc0:	6878      	ldr	r0, [r7, #4]
 8019dc2:	f00c fcf6 	bl	80267b2 <mp_clear>
        mp_clear(s);
 8019dc6:	6838      	ldr	r0, [r7, #0]
 8019dc8:	f00c fcf3 	bl	80267b2 <mp_clear>
    }

    return ret;
 8019dcc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 8019dce:	4618      	mov	r0, r3
 8019dd0:	3770      	adds	r7, #112	@ 0x70
 8019dd2:	46bd      	mov	sp, r7
 8019dd4:	bd80      	pop	{r7, pc}
 8019dd6:	bf00      	nop
 8019dd8:	080338e4 	.word	0x080338e4

08019ddc <wc_EccPrivateKeyDecode>:
#endif

WOLFSSL_ABI
int wc_EccPrivateKeyDecode(const byte* input, word32* inOutIdx, ecc_key* key,
                        word32 inSz)
{
 8019ddc:	b590      	push	{r4, r7, lr}
 8019dde:	b091      	sub	sp, #68	@ 0x44
 8019de0:	af04      	add	r7, sp, #16
 8019de2:	60f8      	str	r0, [r7, #12]
 8019de4:	60b9      	str	r1, [r7, #8]
 8019de6:	607a      	str	r2, [r7, #4]
 8019de8:	603b      	str	r3, [r7, #0]
    XFREE(pub,  key->heap, DYNAMIC_TYPE_TMP_BUFFER);
#endif

    return ret;
#else
    DECL_ASNGETDATA(dataASN, eccKeyASN_Length);
 8019dea:	2300      	movs	r3, #0
 8019dec:	62fb      	str	r3, [r7, #44]	@ 0x2c
    byte version = 0;
 8019dee:	2300      	movs	r3, #0
 8019df0:	77fb      	strb	r3, [r7, #31]
    int ret = 0;
 8019df2:	2300      	movs	r3, #0
 8019df4:	62bb      	str	r3, [r7, #40]	@ 0x28
    int curve_id = ECC_CURVE_DEF;
 8019df6:	2300      	movs	r3, #0
 8019df8:	627b      	str	r3, [r7, #36]	@ 0x24
#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12) || defined(WOLFSSL_SM2)
    word32 algId = 0;
 8019dfa:	2300      	movs	r3, #0
 8019dfc:	61bb      	str	r3, [r7, #24]
    word32 eccOid = 0;
 8019dfe:	2300      	movs	r3, #0
 8019e00:	617b      	str	r3, [r7, #20]
#endif

    /* Validate parameters. */
    if ((input == NULL) || (inOutIdx == NULL) || (key == NULL) || (inSz == 0)) {
 8019e02:	68fb      	ldr	r3, [r7, #12]
 8019e04:	2b00      	cmp	r3, #0
 8019e06:	d008      	beq.n	8019e1a <wc_EccPrivateKeyDecode+0x3e>
 8019e08:	68bb      	ldr	r3, [r7, #8]
 8019e0a:	2b00      	cmp	r3, #0
 8019e0c:	d005      	beq.n	8019e1a <wc_EccPrivateKeyDecode+0x3e>
 8019e0e:	687b      	ldr	r3, [r7, #4]
 8019e10:	2b00      	cmp	r3, #0
 8019e12:	d002      	beq.n	8019e1a <wc_EccPrivateKeyDecode+0x3e>
 8019e14:	683b      	ldr	r3, [r7, #0]
 8019e16:	2b00      	cmp	r3, #0
 8019e18:	d102      	bne.n	8019e20 <wc_EccPrivateKeyDecode+0x44>
        ret = BAD_FUNC_ARG;
 8019e1a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8019e1e:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12) || defined(WOLFSSL_SM2)
    /* if has pkcs8 header skip it */
    if (ToTraditionalInline_ex2(input, inOutIdx, inSz, &algId, &eccOid) < 0) {
 8019e20:	f107 0218 	add.w	r2, r7, #24
 8019e24:	f107 0314 	add.w	r3, r7, #20
 8019e28:	9300      	str	r3, [sp, #0]
 8019e2a:	4613      	mov	r3, r2
 8019e2c:	683a      	ldr	r2, [r7, #0]
 8019e2e:	68b9      	ldr	r1, [r7, #8]
 8019e30:	68f8      	ldr	r0, [r7, #12]
 8019e32:	f7fa ff1b 	bl	8014c6c <ToTraditionalInline_ex2>
 8019e36:	4603      	mov	r3, r0
 8019e38:	2b00      	cmp	r3, #0
 8019e3a:	db06      	blt.n	8019e4a <wc_EccPrivateKeyDecode+0x6e>
        /* ignore error, did not have pkcs8 header */
    }
    else {
        curve_id = wc_ecc_get_oid(eccOid, NULL, NULL);
 8019e3c:	697b      	ldr	r3, [r7, #20]
 8019e3e:	2200      	movs	r2, #0
 8019e40:	2100      	movs	r1, #0
 8019e42:	4618      	mov	r0, r3
 8019e44:	f004 fa3e 	bl	801e2c4 <wc_ecc_get_oid>
 8019e48:	6278      	str	r0, [r7, #36]	@ 0x24
    }
#endif

    CALLOC_ASNGETDATA(dataASN, eccKeyASN_Length, ret, key->heap);
 8019e4a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019e4c:	2b00      	cmp	r3, #0
 8019e4e:	d109      	bne.n	8019e64 <wc_EccPrivateKeyDecode+0x88>
 8019e50:	20e0      	movs	r0, #224	@ 0xe0
 8019e52:	f004 fe1f 	bl	801ea94 <wolfSSL_Malloc>
 8019e56:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8019e58:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019e5a:	2b00      	cmp	r3, #0
 8019e5c:	d102      	bne.n	8019e64 <wc_EccPrivateKeyDecode+0x88>
 8019e5e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8019e62:	62bb      	str	r3, [r7, #40]	@ 0x28
 8019e64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019e66:	2b00      	cmp	r3, #0
 8019e68:	d104      	bne.n	8019e74 <wc_EccPrivateKeyDecode+0x98>
 8019e6a:	22e0      	movs	r2, #224	@ 0xe0
 8019e6c:	2100      	movs	r1, #0
 8019e6e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8019e70:	f00e fb2e 	bl	80284d0 <memset>

    if (ret == 0) {
 8019e74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019e76:	2b00      	cmp	r3, #0
 8019e78:	d119      	bne.n	8019eae <wc_EccPrivateKeyDecode+0xd2>
        /* Get the version and set the expected OID type. */
        GetASN_Int8Bit(&dataASN[ECCKEYASN_IDX_VER], &version);
 8019e7a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019e7c:	331c      	adds	r3, #28
 8019e7e:	2201      	movs	r2, #1
 8019e80:	761a      	strb	r2, [r3, #24]
 8019e82:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019e84:	331c      	adds	r3, #28
 8019e86:	f107 021f 	add.w	r2, r7, #31
 8019e8a:	609a      	str	r2, [r3, #8]
        GetASN_OID(&dataASN[ECCKEYASN_IDX_CURVEID], oidCurveType);
 8019e8c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019e8e:	3370      	adds	r3, #112	@ 0x70
 8019e90:	2203      	movs	r2, #3
 8019e92:	611a      	str	r2, [r3, #16]
        /* Decode the private ECC key. */
        ret = GetASN_Items(eccKeyASN, dataASN, eccKeyASN_Length, 1, input,
 8019e94:	683b      	ldr	r3, [r7, #0]
 8019e96:	9302      	str	r3, [sp, #8]
 8019e98:	68bb      	ldr	r3, [r7, #8]
 8019e9a:	9301      	str	r3, [sp, #4]
 8019e9c:	68fb      	ldr	r3, [r7, #12]
 8019e9e:	9300      	str	r3, [sp, #0]
 8019ea0:	2301      	movs	r3, #1
 8019ea2:	2208      	movs	r2, #8
 8019ea4:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8019ea6:	4829      	ldr	r0, [pc, #164]	@ (8019f4c <wc_EccPrivateKeyDecode+0x170>)
 8019ea8:	f7f9 fc30 	bl	801370c <GetASN_Items>
 8019eac:	62b8      	str	r0, [r7, #40]	@ 0x28
                           inOutIdx, inSz);
    }
    /* Only version 1 supported. */
    if (ret == 0) {
 8019eae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019eb0:	2b00      	cmp	r3, #0
 8019eb2:	d105      	bne.n	8019ec0 <wc_EccPrivateKeyDecode+0xe4>
        if (version != 1) {
 8019eb4:	7ffb      	ldrb	r3, [r7, #31]
 8019eb6:	2b01      	cmp	r3, #1
 8019eb8:	d002      	beq.n	8019ec0 <wc_EccPrivateKeyDecode+0xe4>
            ret = ASN_PARSE_E;
 8019eba:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8019ebe:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
    }
    /* Curve Parameters are optional. */
    if ((ret == 0) && (dataASN[ECCKEYASN_IDX_PARAMS].tag != 0)) {
 8019ec0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019ec2:	2b00      	cmp	r3, #0
 8019ec4:	d11a      	bne.n	8019efc <wc_EccPrivateKeyDecode+0x120>
 8019ec6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019ec8:	3354      	adds	r3, #84	@ 0x54
 8019eca:	7e5b      	ldrb	r3, [r3, #25]
 8019ecc:	2b00      	cmp	r3, #0
 8019ece:	d015      	beq.n	8019efc <wc_EccPrivateKeyDecode+0x120>
        if (dataASN[ECCKEYASN_IDX_CURVEID].tag != 0) {
 8019ed0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019ed2:	3370      	adds	r3, #112	@ 0x70
 8019ed4:	7e5b      	ldrb	r3, [r3, #25]
 8019ed6:	2b00      	cmp	r3, #0
 8019ed8:	d00d      	beq.n	8019ef6 <wc_EccPrivateKeyDecode+0x11a>
            /* Named curve - check and get id. */
            curve_id = CheckCurve(dataASN[ECCKEYASN_IDX_CURVEID].data.oid.sum);
 8019eda:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019edc:	3370      	adds	r3, #112	@ 0x70
 8019ede:	695b      	ldr	r3, [r3, #20]
 8019ee0:	4618      	mov	r0, r3
 8019ee2:	f7fa fbf1 	bl	80146c8 <CheckCurve>
 8019ee6:	6278      	str	r0, [r7, #36]	@ 0x24
            if (curve_id < 0) {
 8019ee8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019eea:	2b00      	cmp	r3, #0
 8019eec:	da06      	bge.n	8019efc <wc_EccPrivateKeyDecode+0x120>
                ret = ECC_CURVE_OID_E;
 8019eee:	f06f 03ab 	mvn.w	r3, #171	@ 0xab
 8019ef2:	62bb      	str	r3, [r7, #40]	@ 0x28
 8019ef4:	e002      	b.n	8019efc <wc_EccPrivateKeyDecode+0x120>
                    dataASN[ECCKEYASN_IDX_CURVEPARAMS].data.ref.data,
                    dataASN[ECCKEYASN_IDX_CURVEPARAMS].data.ref.length, key,
                    key->heap, NULL);
    #else
            /* Explicit parameters not supported in build configuration. */
            ret = ASN_PARSE_E;
 8019ef6:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 8019efa:	62bb      	str	r3, [r7, #40]	@ 0x28
    #endif
        }
    }
    if (ret == 0) {
 8019efc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019efe:	2b00      	cmp	r3, #0
 8019f00:	d113      	bne.n	8019f2a <wc_EccPrivateKeyDecode+0x14e>
        /* Import private key value and public point (may be NULL). */
        ret = wc_ecc_import_private_key_ex(
                dataASN[ECCKEYASN_IDX_PKEY].data.ref.data,
 8019f02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f04:	3338      	adds	r3, #56	@ 0x38
        ret = wc_ecc_import_private_key_ex(
 8019f06:	6898      	ldr	r0, [r3, #8]
                dataASN[ECCKEYASN_IDX_PKEY].data.ref.length,
 8019f08:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f0a:	3338      	adds	r3, #56	@ 0x38
        ret = wc_ecc_import_private_key_ex(
 8019f0c:	68d9      	ldr	r1, [r3, #12]
                dataASN[ECCKEYASN_IDX_PUBKEY_VAL].data.ref.data,
 8019f0e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f10:	33c4      	adds	r3, #196	@ 0xc4
        ret = wc_ecc_import_private_key_ex(
 8019f12:	689a      	ldr	r2, [r3, #8]
                dataASN[ECCKEYASN_IDX_PUBKEY_VAL].data.ref.length,
 8019f14:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f16:	33c4      	adds	r3, #196	@ 0xc4
        ret = wc_ecc_import_private_key_ex(
 8019f18:	68dc      	ldr	r4, [r3, #12]
 8019f1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019f1c:	9301      	str	r3, [sp, #4]
 8019f1e:	687b      	ldr	r3, [r7, #4]
 8019f20:	9300      	str	r3, [sp, #0]
 8019f22:	4623      	mov	r3, r4
 8019f24:	f004 f933 	bl	801e18e <wc_ecc_import_private_key_ex>
 8019f28:	62b8      	str	r0, [r7, #40]	@ 0x28
                key, curve_id);
    }

    FREE_ASNGETDATA(dataASN, key->heap);
 8019f2a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f2c:	2b00      	cmp	r3, #0
 8019f2e:	d007      	beq.n	8019f40 <wc_EccPrivateKeyDecode+0x164>
 8019f30:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019f32:	623b      	str	r3, [r7, #32]
 8019f34:	6a3b      	ldr	r3, [r7, #32]
 8019f36:	2b00      	cmp	r3, #0
 8019f38:	d002      	beq.n	8019f40 <wc_EccPrivateKeyDecode+0x164>
 8019f3a:	6a38      	ldr	r0, [r7, #32]
 8019f3c:	f004 fdc6 	bl	801eacc <wolfSSL_Free>
    return ret;
 8019f40:	6abb      	ldr	r3, [r7, #40]	@ 0x28
#endif
}
 8019f42:	4618      	mov	r0, r3
 8019f44:	3734      	adds	r7, #52	@ 0x34
 8019f46:	46bd      	mov	sp, r7
 8019f48:	bd90      	pop	{r4, r7, pc}
 8019f4a:	bf00      	nop
 8019f4c:	080338f0 	.word	0x080338f0

08019f50 <wc_EccPublicKeyDecode>:
#endif /* WOLFSSL_CUSTOM_CURVES */

WOLFSSL_ABI
int wc_EccPublicKeyDecode(const byte* input, word32* inOutIdx,
                          ecc_key* key, word32 inSz)
{
 8019f50:	b580      	push	{r7, lr}
 8019f52:	b08e      	sub	sp, #56	@ 0x38
 8019f54:	af04      	add	r7, sp, #16
 8019f56:	60f8      	str	r0, [r7, #12]
 8019f58:	60b9      	str	r1, [r7, #8]
 8019f5a:	607a      	str	r2, [r7, #4]
 8019f5c:	603b      	str	r3, [r7, #0]
    *inOutIdx += (word32)length;

    return 0;
#else
    /* eccKeyASN is longer than eccPublicKeyASN. */
    DECL_ASNGETDATA(dataASN, eccKeyASN_Length);
 8019f5e:	2300      	movs	r3, #0
 8019f60:	627b      	str	r3, [r7, #36]	@ 0x24
    int ret = 0;
 8019f62:	2300      	movs	r3, #0
 8019f64:	623b      	str	r3, [r7, #32]
    int curve_id = ECC_CURVE_DEF;
 8019f66:	2300      	movs	r3, #0
 8019f68:	61fb      	str	r3, [r7, #28]
    int oidIdx = ECCPUBLICKEYASN_IDX_ALGOID_CURVEID;
 8019f6a:	2303      	movs	r3, #3
 8019f6c:	61bb      	str	r3, [r7, #24]
#ifdef WOLFSSL_CUSTOM_CURVES
    int specIdx = ECCPUBLICKEYASN_IDX_ALGOID_PARAMS;
#endif
    int pubIdx = ECCPUBLICKEYASN_IDX_PUBKEY;
 8019f6e:	2305      	movs	r3, #5
 8019f70:	617b      	str	r3, [r7, #20]

    if ((input == NULL) || (inOutIdx == NULL) || (key == NULL) || (inSz == 0)) {
 8019f72:	68fb      	ldr	r3, [r7, #12]
 8019f74:	2b00      	cmp	r3, #0
 8019f76:	d008      	beq.n	8019f8a <wc_EccPublicKeyDecode+0x3a>
 8019f78:	68bb      	ldr	r3, [r7, #8]
 8019f7a:	2b00      	cmp	r3, #0
 8019f7c:	d005      	beq.n	8019f8a <wc_EccPublicKeyDecode+0x3a>
 8019f7e:	687b      	ldr	r3, [r7, #4]
 8019f80:	2b00      	cmp	r3, #0
 8019f82:	d002      	beq.n	8019f8a <wc_EccPublicKeyDecode+0x3a>
 8019f84:	683b      	ldr	r3, [r7, #0]
 8019f86:	2b00      	cmp	r3, #0
 8019f88:	d102      	bne.n	8019f90 <wc_EccPublicKeyDecode+0x40>
        ret = BAD_FUNC_ARG;
 8019f8a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8019f8e:	623b      	str	r3, [r7, #32]
    }

    ALLOC_ASNGETDATA(dataASN, eccKeyASN_Length, ret, key->heap);
 8019f90:	6a3b      	ldr	r3, [r7, #32]
 8019f92:	2b00      	cmp	r3, #0
 8019f94:	d109      	bne.n	8019faa <wc_EccPublicKeyDecode+0x5a>
 8019f96:	20e0      	movs	r0, #224	@ 0xe0
 8019f98:	f004 fd7c 	bl	801ea94 <wolfSSL_Malloc>
 8019f9c:	6278      	str	r0, [r7, #36]	@ 0x24
 8019f9e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019fa0:	2b00      	cmp	r3, #0
 8019fa2:	d102      	bne.n	8019faa <wc_EccPublicKeyDecode+0x5a>
 8019fa4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8019fa8:	623b      	str	r3, [r7, #32]

    if (ret == 0) {
 8019faa:	6a3b      	ldr	r3, [r7, #32]
 8019fac:	2b00      	cmp	r3, #0
 8019fae:	d150      	bne.n	801a052 <wc_EccPublicKeyDecode+0x102>
        /* Clear dynamic data for ECC public key. */
        XMEMSET(dataASN, 0, sizeof(*dataASN) * eccPublicKeyASN_Length);
 8019fb0:	22a8      	movs	r2, #168	@ 0xa8
 8019fb2:	2100      	movs	r1, #0
 8019fb4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8019fb6:	f00e fa8b 	bl	80284d0 <memset>
#if !defined(WOLFSSL_SM2) || !defined(WOLFSSL_SM3)
        /* Set required ECDSA OID and ignore the curve OID type. */
        GetASN_ExpBuffer(&dataASN[ECCPUBLICKEYASN_IDX_ALGOID_OID], keyEcdsaOid,
 8019fba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019fbc:	3338      	adds	r3, #56	@ 0x38
 8019fbe:	2206      	movs	r2, #6
 8019fc0:	761a      	strb	r2, [r3, #24]
 8019fc2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019fc4:	3338      	adds	r3, #56	@ 0x38
 8019fc6:	4a4d      	ldr	r2, [pc, #308]	@ (801a0fc <wc_EccPublicKeyDecode+0x1ac>)
 8019fc8:	609a      	str	r2, [r3, #8]
 8019fca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019fcc:	3338      	adds	r3, #56	@ 0x38
 8019fce:	2207      	movs	r2, #7
 8019fd0:	60da      	str	r2, [r3, #12]
                sizeof(keyEcdsaOid));
#else
        GetASN_OID(&dataASN[ECCPUBLICKEYASN_IDX_ALGOID_OID], oidKeyType);
#endif
        GetASN_OID(&dataASN[oidIdx], oidCurveType);
 8019fd2:	69ba      	ldr	r2, [r7, #24]
 8019fd4:	4613      	mov	r3, r2
 8019fd6:	00db      	lsls	r3, r3, #3
 8019fd8:	1a9b      	subs	r3, r3, r2
 8019fda:	009b      	lsls	r3, r3, #2
 8019fdc:	461a      	mov	r2, r3
 8019fde:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019fe0:	4413      	add	r3, r2
 8019fe2:	2203      	movs	r2, #3
 8019fe4:	611a      	str	r2, [r3, #16]
        /* Decode the public ECC key. */
        ret = GetASN_Items(eccPublicKeyASN, dataASN, eccPublicKeyASN_Length, 1,
 8019fe6:	683b      	ldr	r3, [r7, #0]
 8019fe8:	9302      	str	r3, [sp, #8]
 8019fea:	68bb      	ldr	r3, [r7, #8]
 8019fec:	9301      	str	r3, [sp, #4]
 8019fee:	68fb      	ldr	r3, [r7, #12]
 8019ff0:	9300      	str	r3, [sp, #0]
 8019ff2:	2301      	movs	r3, #1
 8019ff4:	2206      	movs	r2, #6
 8019ff6:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8019ff8:	4841      	ldr	r0, [pc, #260]	@ (801a100 <wc_EccPublicKeyDecode+0x1b0>)
 8019ffa:	f7f9 fb87 	bl	801370c <GetASN_Items>
 8019ffe:	6238      	str	r0, [r7, #32]
                           input, inOutIdx, inSz);
        if (ret != 0) {
 801a000:	6a3b      	ldr	r3, [r7, #32]
 801a002:	2b00      	cmp	r3, #0
 801a004:	d025      	beq.n	801a052 <wc_EccPublicKeyDecode+0x102>
            oidIdx = ECCKEYASN_IDX_CURVEID;
 801a006:	2304      	movs	r3, #4
 801a008:	61bb      	str	r3, [r7, #24]
        #ifdef WOLFSSL_CUSTOM_CURVES
            specIdx = ECCKEYASN_IDX_CURVEPARAMS;
        #endif
            pubIdx = ECCKEYASN_IDX_PUBKEY_VAL;
 801a00a:	2307      	movs	r3, #7
 801a00c:	617b      	str	r3, [r7, #20]

            /* Clear dynamic data for ECC private key. */
            XMEMSET(dataASN, 0, sizeof(*dataASN) * eccKeyASN_Length);
 801a00e:	22e0      	movs	r2, #224	@ 0xe0
 801a010:	2100      	movs	r1, #0
 801a012:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801a014:	f00e fa5c 	bl	80284d0 <memset>
            /* Check named curve OID type. */
            GetASN_OID(&dataASN[oidIdx], oidCurveType);
 801a018:	69ba      	ldr	r2, [r7, #24]
 801a01a:	4613      	mov	r3, r2
 801a01c:	00db      	lsls	r3, r3, #3
 801a01e:	1a9b      	subs	r3, r3, r2
 801a020:	009b      	lsls	r3, r3, #2
 801a022:	461a      	mov	r2, r3
 801a024:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a026:	4413      	add	r3, r2
 801a028:	2203      	movs	r2, #3
 801a02a:	611a      	str	r2, [r3, #16]
            /* Try private key format .*/
            ret = GetASN_Items(eccKeyASN, dataASN, eccKeyASN_Length, 1, input,
 801a02c:	683b      	ldr	r3, [r7, #0]
 801a02e:	9302      	str	r3, [sp, #8]
 801a030:	68bb      	ldr	r3, [r7, #8]
 801a032:	9301      	str	r3, [sp, #4]
 801a034:	68fb      	ldr	r3, [r7, #12]
 801a036:	9300      	str	r3, [sp, #0]
 801a038:	2301      	movs	r3, #1
 801a03a:	2208      	movs	r2, #8
 801a03c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801a03e:	4831      	ldr	r0, [pc, #196]	@ (801a104 <wc_EccPublicKeyDecode+0x1b4>)
 801a040:	f7f9 fb64 	bl	801370c <GetASN_Items>
 801a044:	6238      	str	r0, [r7, #32]
                               inOutIdx, inSz);
            if (ret != 0) {
 801a046:	6a3b      	ldr	r3, [r7, #32]
 801a048:	2b00      	cmp	r3, #0
 801a04a:	d002      	beq.n	801a052 <wc_EccPublicKeyDecode+0x102>
                ret = ASN_PARSE_E;
 801a04c:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801a050:	623b      	str	r3, [r7, #32]
        if ((oidSum != ECDSAk) && (oidSum != SM2k)) {
            ret = ASN_PARSE_E;
        }
    }
#endif
    if (ret == 0) {
 801a052:	6a3b      	ldr	r3, [r7, #32]
 801a054:	2b00      	cmp	r3, #0
 801a056:	d121      	bne.n	801a09c <wc_EccPublicKeyDecode+0x14c>
        if (dataASN[oidIdx].tag != 0) {
 801a058:	69ba      	ldr	r2, [r7, #24]
 801a05a:	4613      	mov	r3, r2
 801a05c:	00db      	lsls	r3, r3, #3
 801a05e:	1a9b      	subs	r3, r3, r2
 801a060:	009b      	lsls	r3, r3, #2
 801a062:	461a      	mov	r2, r3
 801a064:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a066:	4413      	add	r3, r2
 801a068:	7e5b      	ldrb	r3, [r3, #25]
 801a06a:	2b00      	cmp	r3, #0
 801a06c:	d013      	beq.n	801a096 <wc_EccPublicKeyDecode+0x146>
            /* Named curve - check and get id. */
            curve_id = CheckCurve(dataASN[oidIdx].data.oid.sum);
 801a06e:	69ba      	ldr	r2, [r7, #24]
 801a070:	4613      	mov	r3, r2
 801a072:	00db      	lsls	r3, r3, #3
 801a074:	1a9b      	subs	r3, r3, r2
 801a076:	009b      	lsls	r3, r3, #2
 801a078:	461a      	mov	r2, r3
 801a07a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a07c:	4413      	add	r3, r2
 801a07e:	695b      	ldr	r3, [r3, #20]
 801a080:	4618      	mov	r0, r3
 801a082:	f7fa fb21 	bl	80146c8 <CheckCurve>
 801a086:	61f8      	str	r0, [r7, #28]
            if (curve_id < 0) {
 801a088:	69fb      	ldr	r3, [r7, #28]
 801a08a:	2b00      	cmp	r3, #0
 801a08c:	da06      	bge.n	801a09c <wc_EccPublicKeyDecode+0x14c>
                ret = ASN_OBJECT_ID_E;
 801a08e:	f06f 038f 	mvn.w	r3, #143	@ 0x8f
 801a092:	623b      	str	r3, [r7, #32]
 801a094:	e002      	b.n	801a09c <wc_EccPublicKeyDecode+0x14c>
            ret = EccSpecifiedECDomainDecode(dataASN[specIdx].data.ref.data,
                                         dataASN[specIdx].data.ref.length, key,
                                         key->heap, NULL);
        #else
            /* Explicit parameters not supported in build configuration. */
            ret = ASN_PARSE_E;
 801a096:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801a09a:	623b      	str	r3, [r7, #32]
        #endif
        }
    }
    if (ret == 0) {
 801a09c:	6a3b      	ldr	r3, [r7, #32]
 801a09e:	2b00      	cmp	r3, #0
 801a0a0:	d11c      	bne.n	801a0dc <wc_EccPublicKeyDecode+0x18c>
        /* Import public point. */
        ret = wc_ecc_import_x963_ex(dataASN[pubIdx].data.ref.data,
 801a0a2:	697a      	ldr	r2, [r7, #20]
 801a0a4:	4613      	mov	r3, r2
 801a0a6:	00db      	lsls	r3, r3, #3
 801a0a8:	1a9b      	subs	r3, r3, r2
 801a0aa:	009b      	lsls	r3, r3, #2
 801a0ac:	461a      	mov	r2, r3
 801a0ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a0b0:	4413      	add	r3, r2
 801a0b2:	6898      	ldr	r0, [r3, #8]
                dataASN[pubIdx].data.ref.length, key, curve_id);
 801a0b4:	697a      	ldr	r2, [r7, #20]
 801a0b6:	4613      	mov	r3, r2
 801a0b8:	00db      	lsls	r3, r3, #3
 801a0ba:	1a9b      	subs	r3, r3, r2
 801a0bc:	009b      	lsls	r3, r3, #2
 801a0be:	461a      	mov	r2, r3
 801a0c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a0c2:	4413      	add	r3, r2
        ret = wc_ecc_import_x963_ex(dataASN[pubIdx].data.ref.data,
 801a0c4:	68d9      	ldr	r1, [r3, #12]
 801a0c6:	69fb      	ldr	r3, [r7, #28]
 801a0c8:	687a      	ldr	r2, [r7, #4]
 801a0ca:	f003 ffa5 	bl	801e018 <wc_ecc_import_x963_ex>
 801a0ce:	6238      	str	r0, [r7, #32]
        if (ret != 0) {
 801a0d0:	6a3b      	ldr	r3, [r7, #32]
 801a0d2:	2b00      	cmp	r3, #0
 801a0d4:	d002      	beq.n	801a0dc <wc_EccPublicKeyDecode+0x18c>
            ret = ASN_ECC_KEY_E;
 801a0d6:	f06f 03aa 	mvn.w	r3, #170	@ 0xaa
 801a0da:	623b      	str	r3, [r7, #32]
        }
    }

    FREE_ASNGETDATA(dataASN, key->heap);
 801a0dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a0de:	2b00      	cmp	r3, #0
 801a0e0:	d007      	beq.n	801a0f2 <wc_EccPublicKeyDecode+0x1a2>
 801a0e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801a0e4:	613b      	str	r3, [r7, #16]
 801a0e6:	693b      	ldr	r3, [r7, #16]
 801a0e8:	2b00      	cmp	r3, #0
 801a0ea:	d002      	beq.n	801a0f2 <wc_EccPublicKeyDecode+0x1a2>
 801a0ec:	6938      	ldr	r0, [r7, #16]
 801a0ee:	f004 fced 	bl	801eacc <wolfSSL_Free>
    return ret;
 801a0f2:	6a3b      	ldr	r3, [r7, #32]
#endif /* WOLFSSL_ASN_TEMPLATE */
}
 801a0f4:	4618      	mov	r0, r3
 801a0f6:	3728      	adds	r7, #40	@ 0x28
 801a0f8:	46bd      	mov	sp, r7
 801a0fa:	bd80      	pop	{r7, pc}
 801a0fc:	08033478 	.word	0x08033478
 801a100:	0803368c 	.word	0x0803368c
 801a104:	080338f0 	.word	0x080338f0

0801a108 <wc_RsaPublicKeyDecodeRaw>:
#if !defined(NO_RSA) && (!defined(NO_BIG_INT) || defined(WOLFSSL_SP_MATH))
/* import RSA public key elements (n, e) into RsaKey structure (key) */
/* this function does not use any ASN.1 parsing */
int wc_RsaPublicKeyDecodeRaw(const byte* n, word32 nSz, const byte* e,
                             word32 eSz, RsaKey* key)
{
 801a108:	b580      	push	{r7, lr}
 801a10a:	b084      	sub	sp, #16
 801a10c:	af00      	add	r7, sp, #0
 801a10e:	60f8      	str	r0, [r7, #12]
 801a110:	60b9      	str	r1, [r7, #8]
 801a112:	607a      	str	r2, [r7, #4]
 801a114:	603b      	str	r3, [r7, #0]
    if (n == NULL || e == NULL || key == NULL)
 801a116:	68fb      	ldr	r3, [r7, #12]
 801a118:	2b00      	cmp	r3, #0
 801a11a:	d005      	beq.n	801a128 <wc_RsaPublicKeyDecodeRaw+0x20>
 801a11c:	687b      	ldr	r3, [r7, #4]
 801a11e:	2b00      	cmp	r3, #0
 801a120:	d002      	beq.n	801a128 <wc_RsaPublicKeyDecodeRaw+0x20>
 801a122:	69bb      	ldr	r3, [r7, #24]
 801a124:	2b00      	cmp	r3, #0
 801a126:	d102      	bne.n	801a12e <wc_RsaPublicKeyDecodeRaw+0x26>
        return BAD_FUNC_ARG;
 801a128:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a12c:	e049      	b.n	801a1c2 <wc_RsaPublicKeyDecodeRaw+0xba>

    key->type = RSA_PUBLIC;
 801a12e:	69bb      	ldr	r3, [r7, #24]
 801a130:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801a134:	461a      	mov	r2, r3
 801a136:	2300      	movs	r3, #0
 801a138:	f8c2 3168 	str.w	r3, [r2, #360]	@ 0x168

    if (mp_init(&key->n) != MP_OKAY)
 801a13c:	69bb      	ldr	r3, [r7, #24]
 801a13e:	4618      	mov	r0, r3
 801a140:	f00c faad 	bl	802669e <mp_init>
 801a144:	4603      	mov	r3, r0
 801a146:	2b00      	cmp	r3, #0
 801a148:	d002      	beq.n	801a150 <wc_RsaPublicKeyDecodeRaw+0x48>
        return MP_INIT_E;
 801a14a:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 801a14e:	e038      	b.n	801a1c2 <wc_RsaPublicKeyDecodeRaw+0xba>

    if (mp_read_unsigned_bin(&key->n, n, nSz) != 0) {
 801a150:	69bb      	ldr	r3, [r7, #24]
 801a152:	68ba      	ldr	r2, [r7, #8]
 801a154:	68f9      	ldr	r1, [r7, #12]
 801a156:	4618      	mov	r0, r3
 801a158:	f00c fc7a 	bl	8026a50 <mp_read_unsigned_bin>
 801a15c:	4603      	mov	r3, r0
 801a15e:	2b00      	cmp	r3, #0
 801a160:	d006      	beq.n	801a170 <wc_RsaPublicKeyDecodeRaw+0x68>
        mp_clear(&key->n);
 801a162:	69bb      	ldr	r3, [r7, #24]
 801a164:	4618      	mov	r0, r3
 801a166:	f00c fb24 	bl	80267b2 <mp_clear>
        return ASN_GETINT_E;
 801a16a:	f06f 038d 	mvn.w	r3, #141	@ 0x8d
 801a16e:	e028      	b.n	801a1c2 <wc_RsaPublicKeyDecodeRaw+0xba>
        mp_clear(&key->n);
        return ASN_GETINT_E;
    }
#endif /* HAVE_WOLF_BIGINT */

    if (mp_init(&key->e) != MP_OKAY) {
 801a170:	69bb      	ldr	r3, [r7, #24]
 801a172:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a176:	4618      	mov	r0, r3
 801a178:	f00c fa91 	bl	802669e <mp_init>
 801a17c:	4603      	mov	r3, r0
 801a17e:	2b00      	cmp	r3, #0
 801a180:	d006      	beq.n	801a190 <wc_RsaPublicKeyDecodeRaw+0x88>
        mp_clear(&key->n);
 801a182:	69bb      	ldr	r3, [r7, #24]
 801a184:	4618      	mov	r0, r3
 801a186:	f00c fb14 	bl	80267b2 <mp_clear>
        return MP_INIT_E;
 801a18a:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 801a18e:	e018      	b.n	801a1c2 <wc_RsaPublicKeyDecodeRaw+0xba>
    }

    if (mp_read_unsigned_bin(&key->e, e, eSz) != 0) {
 801a190:	69bb      	ldr	r3, [r7, #24]
 801a192:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a196:	683a      	ldr	r2, [r7, #0]
 801a198:	6879      	ldr	r1, [r7, #4]
 801a19a:	4618      	mov	r0, r3
 801a19c:	f00c fc58 	bl	8026a50 <mp_read_unsigned_bin>
 801a1a0:	4603      	mov	r3, r0
 801a1a2:	2b00      	cmp	r3, #0
 801a1a4:	d00c      	beq.n	801a1c0 <wc_RsaPublicKeyDecodeRaw+0xb8>
        mp_clear(&key->n);
 801a1a6:	69bb      	ldr	r3, [r7, #24]
 801a1a8:	4618      	mov	r0, r3
 801a1aa:	f00c fb02 	bl	80267b2 <mp_clear>
        mp_clear(&key->e);
 801a1ae:	69bb      	ldr	r3, [r7, #24]
 801a1b0:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a1b4:	4618      	mov	r0, r3
 801a1b6:	f00c fafc 	bl	80267b2 <mp_clear>
        return ASN_GETINT_E;
 801a1ba:	f06f 038d 	mvn.w	r3, #141	@ 0x8d
 801a1be:	e000      	b.n	801a1c2 <wc_RsaPublicKeyDecodeRaw+0xba>
    if (wc_InitRsaHw(key) != 0) {
        return BAD_STATE_E;
    }
#endif

    return 0;
 801a1c0:	2300      	movs	r3, #0
}
 801a1c2:	4618      	mov	r0, r3
 801a1c4:	3710      	adds	r7, #16
 801a1c6:	46bd      	mov	sp, r7
 801a1c8:	bd80      	pop	{r7, pc}
	...

0801a1cc <Base64_Char2Val>:
/* 0x78: x y z           */    49,  50,  51
                            };
#define BASE64DECODE_SZ    (byte)(sizeof(base64Decode))

static WC_INLINE byte Base64_Char2Val(byte c)
{
 801a1cc:	b480      	push	{r7}
 801a1ce:	b085      	sub	sp, #20
 801a1d0:	af00      	add	r7, sp, #0
 801a1d2:	4603      	mov	r3, r0
 801a1d4:	71fb      	strb	r3, [r7, #7]
     * 64 bytes in a cache line - first line has 64, second has 16
     */
    byte v;
    byte mask;

    c = (byte)(c - BASE64_MIN);
 801a1d6:	79fb      	ldrb	r3, [r7, #7]
 801a1d8:	3b2b      	subs	r3, #43	@ 0x2b
 801a1da:	71fb      	strb	r3, [r7, #7]
    mask = (byte)((((byte)(0x3f - c)) >> 7) - 1);
 801a1dc:	79fb      	ldrb	r3, [r7, #7]
 801a1de:	f1c3 033f 	rsb	r3, r3, #63	@ 0x3f
 801a1e2:	b2db      	uxtb	r3, r3
 801a1e4:	09db      	lsrs	r3, r3, #7
 801a1e6:	b2db      	uxtb	r3, r3
 801a1e8:	3b01      	subs	r3, #1
 801a1ea:	73fb      	strb	r3, [r7, #15]
    /* Load a value from the first cache line and use when mask set. */
    v  = (byte)(base64Decode[ c & 0x3f        ] &   mask);
 801a1ec:	79fb      	ldrb	r3, [r7, #7]
 801a1ee:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801a1f2:	4a0f      	ldr	r2, [pc, #60]	@ (801a230 <Base64_Char2Val+0x64>)
 801a1f4:	5cd2      	ldrb	r2, [r2, r3]
 801a1f6:	7bfb      	ldrb	r3, [r7, #15]
 801a1f8:	4013      	ands	r3, r2
 801a1fa:	73bb      	strb	r3, [r7, #14]
    /* Load a value from the second cache line and use when mask not set. */
    v |= (byte)(base64Decode[(c & 0x0f) | 0x40] & (~mask));
 801a1fc:	79fb      	ldrb	r3, [r7, #7]
 801a1fe:	f003 030f 	and.w	r3, r3, #15
 801a202:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801a206:	4a0a      	ldr	r2, [pc, #40]	@ (801a230 <Base64_Char2Val+0x64>)
 801a208:	5cd3      	ldrb	r3, [r2, r3]
 801a20a:	b25a      	sxtb	r2, r3
 801a20c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801a210:	43db      	mvns	r3, r3
 801a212:	b25b      	sxtb	r3, r3
 801a214:	4013      	ands	r3, r2
 801a216:	b25b      	sxtb	r3, r3
 801a218:	b2da      	uxtb	r2, r3
 801a21a:	7bbb      	ldrb	r3, [r7, #14]
 801a21c:	4313      	orrs	r3, r2
 801a21e:	73bb      	strb	r3, [r7, #14]

    return v;
 801a220:	7bbb      	ldrb	r3, [r7, #14]
#else
    return base64Decode[c - BASE64_MIN];
#endif
}
 801a222:	4618      	mov	r0, r3
 801a224:	3714      	adds	r7, #20
 801a226:	46bd      	mov	sp, r7
 801a228:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a22c:	4770      	bx	lr
 801a22e:	bf00      	nop
 801a230:	0803391c 	.word	0x0803391c

0801a234 <Base64_SkipNewline>:
#endif

int Base64_SkipNewline(const byte* in, word32 *inLen,
  word32 *outJ)
{
 801a234:	b480      	push	{r7}
 801a236:	b089      	sub	sp, #36	@ 0x24
 801a238:	af00      	add	r7, sp, #0
 801a23a:	60f8      	str	r0, [r7, #12]
 801a23c:	60b9      	str	r1, [r7, #8]
 801a23e:	607a      	str	r2, [r7, #4]
    word32 len = *inLen;
 801a240:	68bb      	ldr	r3, [r7, #8]
 801a242:	681b      	ldr	r3, [r3, #0]
 801a244:	61fb      	str	r3, [r7, #28]
    word32 j = *outJ;
 801a246:	687b      	ldr	r3, [r7, #4]
 801a248:	681b      	ldr	r3, [r3, #0]
 801a24a:	61bb      	str	r3, [r7, #24]
    byte curChar;

    if (len == 0) {
 801a24c:	69fb      	ldr	r3, [r7, #28]
 801a24e:	2b00      	cmp	r3, #0
 801a250:	d102      	bne.n	801a258 <Base64_SkipNewline+0x24>
        return BUFFER_E;
 801a252:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801a256:	e065      	b.n	801a324 <Base64_SkipNewline+0xf0>
    }
    curChar = in[j];
 801a258:	68fa      	ldr	r2, [r7, #12]
 801a25a:	69bb      	ldr	r3, [r7, #24]
 801a25c:	4413      	add	r3, r2
 801a25e:	781b      	ldrb	r3, [r3, #0]
 801a260:	75fb      	strb	r3, [r7, #23]

    while (len > 1 && curChar == ' ') {
 801a262:	e00a      	b.n	801a27a <Base64_SkipNewline+0x46>
        /* skip whitespace in the middle or end of line */
        curChar = in[++j];
 801a264:	69bb      	ldr	r3, [r7, #24]
 801a266:	3301      	adds	r3, #1
 801a268:	61bb      	str	r3, [r7, #24]
 801a26a:	68fa      	ldr	r2, [r7, #12]
 801a26c:	69bb      	ldr	r3, [r7, #24]
 801a26e:	4413      	add	r3, r2
 801a270:	781b      	ldrb	r3, [r3, #0]
 801a272:	75fb      	strb	r3, [r7, #23]
        len--;
 801a274:	69fb      	ldr	r3, [r7, #28]
 801a276:	3b01      	subs	r3, #1
 801a278:	61fb      	str	r3, [r7, #28]
    while (len > 1 && curChar == ' ') {
 801a27a:	69fb      	ldr	r3, [r7, #28]
 801a27c:	2b01      	cmp	r3, #1
 801a27e:	d902      	bls.n	801a286 <Base64_SkipNewline+0x52>
 801a280:	7dfb      	ldrb	r3, [r7, #23]
 801a282:	2b20      	cmp	r3, #32
 801a284:	d0ee      	beq.n	801a264 <Base64_SkipNewline+0x30>
    }
    if (len && (curChar == '\r' || curChar == '\n')) {
 801a286:	69fb      	ldr	r3, [r7, #28]
 801a288:	2b00      	cmp	r3, #0
 801a28a:	d038      	beq.n	801a2fe <Base64_SkipNewline+0xca>
 801a28c:	7dfb      	ldrb	r3, [r7, #23]
 801a28e:	2b0d      	cmp	r3, #13
 801a290:	d002      	beq.n	801a298 <Base64_SkipNewline+0x64>
 801a292:	7dfb      	ldrb	r3, [r7, #23]
 801a294:	2b0a      	cmp	r3, #10
 801a296:	d132      	bne.n	801a2fe <Base64_SkipNewline+0xca>
        j++;
 801a298:	69bb      	ldr	r3, [r7, #24]
 801a29a:	3301      	adds	r3, #1
 801a29c:	61bb      	str	r3, [r7, #24]
        len--;
 801a29e:	69fb      	ldr	r3, [r7, #28]
 801a2a0:	3b01      	subs	r3, #1
 801a2a2:	61fb      	str	r3, [r7, #28]
        if (curChar == '\r') {
 801a2a4:	7dfb      	ldrb	r3, [r7, #23]
 801a2a6:	2b0d      	cmp	r3, #13
 801a2a8:	d10c      	bne.n	801a2c4 <Base64_SkipNewline+0x90>
            if (len) {
 801a2aa:	69fb      	ldr	r3, [r7, #28]
 801a2ac:	2b00      	cmp	r3, #0
 801a2ae:	d009      	beq.n	801a2c4 <Base64_SkipNewline+0x90>
                curChar = in[j++];
 801a2b0:	69bb      	ldr	r3, [r7, #24]
 801a2b2:	1c5a      	adds	r2, r3, #1
 801a2b4:	61ba      	str	r2, [r7, #24]
 801a2b6:	68fa      	ldr	r2, [r7, #12]
 801a2b8:	4413      	add	r3, r2
 801a2ba:	781b      	ldrb	r3, [r3, #0]
 801a2bc:	75fb      	strb	r3, [r7, #23]
                len--;
 801a2be:	69fb      	ldr	r3, [r7, #28]
 801a2c0:	3b01      	subs	r3, #1
 801a2c2:	61fb      	str	r3, [r7, #28]
            }
        }
        if (curChar != '\n') {
 801a2c4:	7dfb      	ldrb	r3, [r7, #23]
 801a2c6:	2b0a      	cmp	r3, #10
 801a2c8:	d002      	beq.n	801a2d0 <Base64_SkipNewline+0x9c>
            WOLFSSL_MSG("Bad end of line in Base64 Decode");
            return ASN_INPUT_E;
 801a2ca:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a2ce:	e029      	b.n	801a324 <Base64_SkipNewline+0xf0>
        }

        if (len) {
 801a2d0:	69fb      	ldr	r3, [r7, #28]
 801a2d2:	2b00      	cmp	r3, #0
 801a2d4:	d013      	beq.n	801a2fe <Base64_SkipNewline+0xca>
            curChar = in[j];
 801a2d6:	68fa      	ldr	r2, [r7, #12]
 801a2d8:	69bb      	ldr	r3, [r7, #24]
 801a2da:	4413      	add	r3, r2
 801a2dc:	781b      	ldrb	r3, [r3, #0]
 801a2de:	75fb      	strb	r3, [r7, #23]
        }
    }
    while (len && curChar == ' ') {
 801a2e0:	e00d      	b.n	801a2fe <Base64_SkipNewline+0xca>
        if (--len > 0) {
 801a2e2:	69fb      	ldr	r3, [r7, #28]
 801a2e4:	3b01      	subs	r3, #1
 801a2e6:	61fb      	str	r3, [r7, #28]
 801a2e8:	69fb      	ldr	r3, [r7, #28]
 801a2ea:	2b00      	cmp	r3, #0
 801a2ec:	d007      	beq.n	801a2fe <Base64_SkipNewline+0xca>
            curChar = in[++j];
 801a2ee:	69bb      	ldr	r3, [r7, #24]
 801a2f0:	3301      	adds	r3, #1
 801a2f2:	61bb      	str	r3, [r7, #24]
 801a2f4:	68fa      	ldr	r2, [r7, #12]
 801a2f6:	69bb      	ldr	r3, [r7, #24]
 801a2f8:	4413      	add	r3, r2
 801a2fa:	781b      	ldrb	r3, [r3, #0]
 801a2fc:	75fb      	strb	r3, [r7, #23]
    while (len && curChar == ' ') {
 801a2fe:	69fb      	ldr	r3, [r7, #28]
 801a300:	2b00      	cmp	r3, #0
 801a302:	d002      	beq.n	801a30a <Base64_SkipNewline+0xd6>
 801a304:	7dfb      	ldrb	r3, [r7, #23]
 801a306:	2b20      	cmp	r3, #32
 801a308:	d0eb      	beq.n	801a2e2 <Base64_SkipNewline+0xae>
        }
    }
    if (!len) {
 801a30a:	69fb      	ldr	r3, [r7, #28]
 801a30c:	2b00      	cmp	r3, #0
 801a30e:	d102      	bne.n	801a316 <Base64_SkipNewline+0xe2>
        return BUFFER_E;
 801a310:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801a314:	e006      	b.n	801a324 <Base64_SkipNewline+0xf0>
    }
    *inLen = len;
 801a316:	68bb      	ldr	r3, [r7, #8]
 801a318:	69fa      	ldr	r2, [r7, #28]
 801a31a:	601a      	str	r2, [r3, #0]
    *outJ = j;
 801a31c:	687b      	ldr	r3, [r7, #4]
 801a31e:	69ba      	ldr	r2, [r7, #24]
 801a320:	601a      	str	r2, [r3, #0]
    return 0;
 801a322:	2300      	movs	r3, #0
}
 801a324:	4618      	mov	r0, r3
 801a326:	3724      	adds	r7, #36	@ 0x24
 801a328:	46bd      	mov	sp, r7
 801a32a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a32e:	4770      	bx	lr

0801a330 <Base64_Decode>:

int Base64_Decode(const byte* in, word32 inLen, byte* out, word32* outLen)
{
 801a330:	b580      	push	{r7, lr}
 801a332:	b08e      	sub	sp, #56	@ 0x38
 801a334:	af00      	add	r7, sp, #0
 801a336:	60f8      	str	r0, [r7, #12]
 801a338:	60b9      	str	r1, [r7, #8]
 801a33a:	607a      	str	r2, [r7, #4]
 801a33c:	603b      	str	r3, [r7, #0]
    word32 i = 0;
 801a33e:	2300      	movs	r3, #0
 801a340:	637b      	str	r3, [r7, #52]	@ 0x34
    word32 j = 0;
 801a342:	2300      	movs	r3, #0
 801a344:	617b      	str	r3, [r7, #20]
    word32 plainSz = inLen - ((inLen + (BASE64_LINE_SZ - 1)) / BASE64_LINE_SZ );
 801a346:	68ba      	ldr	r2, [r7, #8]
 801a348:	68bb      	ldr	r3, [r7, #8]
 801a34a:	333f      	adds	r3, #63	@ 0x3f
 801a34c:	099b      	lsrs	r3, r3, #6
 801a34e:	1ad3      	subs	r3, r2, r3
 801a350:	62bb      	str	r3, [r7, #40]	@ 0x28
    int ret;
#ifndef BASE64_NO_TABLE
    const byte maxIdx = BASE64DECODE_SZ + BASE64_MIN - 1;
 801a352:	237a      	movs	r3, #122	@ 0x7a
 801a354:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
#endif

    plainSz = (plainSz * 3 + 3) / 4;
 801a358:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801a35a:	1c5a      	adds	r2, r3, #1
 801a35c:	4613      	mov	r3, r2
 801a35e:	005b      	lsls	r3, r3, #1
 801a360:	4413      	add	r3, r2
 801a362:	089b      	lsrs	r3, r3, #2
 801a364:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (plainSz > *outLen) return BAD_FUNC_ARG;
 801a366:	683b      	ldr	r3, [r7, #0]
 801a368:	681b      	ldr	r3, [r3, #0]
 801a36a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801a36c:	429a      	cmp	r2, r3
 801a36e:	f240 812c 	bls.w	801a5ca <Base64_Decode+0x29a>
 801a372:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a376:	e143      	b.n	801a600 <Base64_Decode+0x2d0>

    while (inLen > 3) {
        int pad3 = 0;
 801a378:	2300      	movs	r3, #0
 801a37a:	633b      	str	r3, [r7, #48]	@ 0x30
        int pad4 = 0;
 801a37c:	2300      	movs	r3, #0
 801a37e:	62fb      	str	r3, [r7, #44]	@ 0x2c
        byte b1, b2, b3;
        byte e1, e2, e3, e4;

        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a380:	f107 0214 	add.w	r2, r7, #20
 801a384:	f107 0308 	add.w	r3, r7, #8
 801a388:	4619      	mov	r1, r3
 801a38a:	68f8      	ldr	r0, [r7, #12]
 801a38c:	f7ff ff52 	bl	801a234 <Base64_SkipNewline>
 801a390:	6238      	str	r0, [r7, #32]
 801a392:	6a3b      	ldr	r3, [r7, #32]
 801a394:	2b00      	cmp	r3, #0
 801a396:	d006      	beq.n	801a3a6 <Base64_Decode+0x76>
            if (ret == WC_NO_ERR_TRACE(BUFFER_E)) {
 801a398:	6a3b      	ldr	r3, [r7, #32]
 801a39a:	f113 0f84 	cmn.w	r3, #132	@ 0x84
 801a39e:	f000 8119 	beq.w	801a5d4 <Base64_Decode+0x2a4>
                /* Running out of buffer here is not an error */
                break;
            }
            return ret;
 801a3a2:	6a3b      	ldr	r3, [r7, #32]
 801a3a4:	e12c      	b.n	801a600 <Base64_Decode+0x2d0>
        }
        e1 = in[j++];
 801a3a6:	697b      	ldr	r3, [r7, #20]
 801a3a8:	1c5a      	adds	r2, r3, #1
 801a3aa:	617a      	str	r2, [r7, #20]
 801a3ac:	68fa      	ldr	r2, [r7, #12]
 801a3ae:	4413      	add	r3, r2
 801a3b0:	781b      	ldrb	r3, [r3, #0]
 801a3b2:	77fb      	strb	r3, [r7, #31]
        if (e1 == '\0') {
 801a3b4:	7ffb      	ldrb	r3, [r7, #31]
 801a3b6:	2b00      	cmp	r3, #0
 801a3b8:	f000 810e 	beq.w	801a5d8 <Base64_Decode+0x2a8>
            break;
        }
        inLen--;
 801a3bc:	68bb      	ldr	r3, [r7, #8]
 801a3be:	3b01      	subs	r3, #1
 801a3c0:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a3c2:	f107 0214 	add.w	r2, r7, #20
 801a3c6:	f107 0308 	add.w	r3, r7, #8
 801a3ca:	4619      	mov	r1, r3
 801a3cc:	68f8      	ldr	r0, [r7, #12]
 801a3ce:	f7ff ff31 	bl	801a234 <Base64_SkipNewline>
 801a3d2:	6238      	str	r0, [r7, #32]
 801a3d4:	6a3b      	ldr	r3, [r7, #32]
 801a3d6:	2b00      	cmp	r3, #0
 801a3d8:	d001      	beq.n	801a3de <Base64_Decode+0xae>
            return ret;
 801a3da:	6a3b      	ldr	r3, [r7, #32]
 801a3dc:	e110      	b.n	801a600 <Base64_Decode+0x2d0>
        }
        e2 = in[j++];
 801a3de:	697b      	ldr	r3, [r7, #20]
 801a3e0:	1c5a      	adds	r2, r3, #1
 801a3e2:	617a      	str	r2, [r7, #20]
 801a3e4:	68fa      	ldr	r2, [r7, #12]
 801a3e6:	4413      	add	r3, r2
 801a3e8:	781b      	ldrb	r3, [r3, #0]
 801a3ea:	77bb      	strb	r3, [r7, #30]
        inLen--;
 801a3ec:	68bb      	ldr	r3, [r7, #8]
 801a3ee:	3b01      	subs	r3, #1
 801a3f0:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a3f2:	f107 0214 	add.w	r2, r7, #20
 801a3f6:	f107 0308 	add.w	r3, r7, #8
 801a3fa:	4619      	mov	r1, r3
 801a3fc:	68f8      	ldr	r0, [r7, #12]
 801a3fe:	f7ff ff19 	bl	801a234 <Base64_SkipNewline>
 801a402:	6238      	str	r0, [r7, #32]
 801a404:	6a3b      	ldr	r3, [r7, #32]
 801a406:	2b00      	cmp	r3, #0
 801a408:	d001      	beq.n	801a40e <Base64_Decode+0xde>
            return ret;
 801a40a:	6a3b      	ldr	r3, [r7, #32]
 801a40c:	e0f8      	b.n	801a600 <Base64_Decode+0x2d0>
        }
        e3 = in[j++];
 801a40e:	697b      	ldr	r3, [r7, #20]
 801a410:	1c5a      	adds	r2, r3, #1
 801a412:	617a      	str	r2, [r7, #20]
 801a414:	68fa      	ldr	r2, [r7, #12]
 801a416:	4413      	add	r3, r2
 801a418:	781b      	ldrb	r3, [r3, #0]
 801a41a:	777b      	strb	r3, [r7, #29]
        inLen--;
 801a41c:	68bb      	ldr	r3, [r7, #8]
 801a41e:	3b01      	subs	r3, #1
 801a420:	60bb      	str	r3, [r7, #8]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 801a422:	f107 0214 	add.w	r2, r7, #20
 801a426:	f107 0308 	add.w	r3, r7, #8
 801a42a:	4619      	mov	r1, r3
 801a42c:	68f8      	ldr	r0, [r7, #12]
 801a42e:	f7ff ff01 	bl	801a234 <Base64_SkipNewline>
 801a432:	6238      	str	r0, [r7, #32]
 801a434:	6a3b      	ldr	r3, [r7, #32]
 801a436:	2b00      	cmp	r3, #0
 801a438:	d001      	beq.n	801a43e <Base64_Decode+0x10e>
            return ret;
 801a43a:	6a3b      	ldr	r3, [r7, #32]
 801a43c:	e0e0      	b.n	801a600 <Base64_Decode+0x2d0>
        }
        e4 = in[j++];
 801a43e:	697b      	ldr	r3, [r7, #20]
 801a440:	1c5a      	adds	r2, r3, #1
 801a442:	617a      	str	r2, [r7, #20]
 801a444:	68fa      	ldr	r2, [r7, #12]
 801a446:	4413      	add	r3, r2
 801a448:	781b      	ldrb	r3, [r3, #0]
 801a44a:	773b      	strb	r3, [r7, #28]
        inLen--;
 801a44c:	68bb      	ldr	r3, [r7, #8]
 801a44e:	3b01      	subs	r3, #1
 801a450:	60bb      	str	r3, [r7, #8]

        if (e3 == PAD)
 801a452:	7f7b      	ldrb	r3, [r7, #29]
 801a454:	2b3d      	cmp	r3, #61	@ 0x3d
 801a456:	d101      	bne.n	801a45c <Base64_Decode+0x12c>
            pad3 = 1;
 801a458:	2301      	movs	r3, #1
 801a45a:	633b      	str	r3, [r7, #48]	@ 0x30
        if (e4 == PAD)
 801a45c:	7f3b      	ldrb	r3, [r7, #28]
 801a45e:	2b3d      	cmp	r3, #61	@ 0x3d
 801a460:	d101      	bne.n	801a466 <Base64_Decode+0x136>
            pad4 = 1;
 801a462:	2301      	movs	r3, #1
 801a464:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if (pad3 && !pad4)
 801a466:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801a468:	2b00      	cmp	r3, #0
 801a46a:	d005      	beq.n	801a478 <Base64_Decode+0x148>
 801a46c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a46e:	2b00      	cmp	r3, #0
 801a470:	d102      	bne.n	801a478 <Base64_Decode+0x148>
            return ASN_INPUT_E;
 801a472:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a476:	e0c3      	b.n	801a600 <Base64_Decode+0x2d0>

#ifndef BASE64_NO_TABLE
        if (e1 < BASE64_MIN || e2 < BASE64_MIN || e3 < BASE64_MIN ||
 801a478:	7ffb      	ldrb	r3, [r7, #31]
 801a47a:	2b2a      	cmp	r3, #42	@ 0x2a
 801a47c:	d908      	bls.n	801a490 <Base64_Decode+0x160>
 801a47e:	7fbb      	ldrb	r3, [r7, #30]
 801a480:	2b2a      	cmp	r3, #42	@ 0x2a
 801a482:	d905      	bls.n	801a490 <Base64_Decode+0x160>
 801a484:	7f7b      	ldrb	r3, [r7, #29]
 801a486:	2b2a      	cmp	r3, #42	@ 0x2a
 801a488:	d902      	bls.n	801a490 <Base64_Decode+0x160>
 801a48a:	7f3b      	ldrb	r3, [r7, #28]
 801a48c:	2b2a      	cmp	r3, #42	@ 0x2a
 801a48e:	d802      	bhi.n	801a496 <Base64_Decode+0x166>
                                                              e4 < BASE64_MIN) {
            WOLFSSL_MSG("Bad Base64 Decode data, too small");
            return ASN_INPUT_E;
 801a490:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a494:	e0b4      	b.n	801a600 <Base64_Decode+0x2d0>
        }

        if (e1 > maxIdx || e2 > maxIdx || e3 > maxIdx || e4 > maxIdx) {
 801a496:	7ffa      	ldrb	r2, [r7, #31]
 801a498:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a49c:	429a      	cmp	r2, r3
 801a49e:	d80e      	bhi.n	801a4be <Base64_Decode+0x18e>
 801a4a0:	7fba      	ldrb	r2, [r7, #30]
 801a4a2:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a4a6:	429a      	cmp	r2, r3
 801a4a8:	d809      	bhi.n	801a4be <Base64_Decode+0x18e>
 801a4aa:	7f7a      	ldrb	r2, [r7, #29]
 801a4ac:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a4b0:	429a      	cmp	r2, r3
 801a4b2:	d804      	bhi.n	801a4be <Base64_Decode+0x18e>
 801a4b4:	7f3a      	ldrb	r2, [r7, #28]
 801a4b6:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801a4ba:	429a      	cmp	r2, r3
 801a4bc:	d902      	bls.n	801a4c4 <Base64_Decode+0x194>
            WOLFSSL_MSG("Bad Base64 Decode data, too big");
            return ASN_INPUT_E;
 801a4be:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a4c2:	e09d      	b.n	801a600 <Base64_Decode+0x2d0>
        }
#endif

        if (i + 1 + !pad3 + !pad4 > *outLen) {
 801a4c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801a4c6:	2b00      	cmp	r3, #0
 801a4c8:	bf0c      	ite	eq
 801a4ca:	2301      	moveq	r3, #1
 801a4cc:	2300      	movne	r3, #0
 801a4ce:	b2db      	uxtb	r3, r3
 801a4d0:	461a      	mov	r2, r3
 801a4d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a4d4:	4413      	add	r3, r2
 801a4d6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801a4d8:	2a00      	cmp	r2, #0
 801a4da:	bf0c      	ite	eq
 801a4dc:	2201      	moveq	r2, #1
 801a4de:	2200      	movne	r2, #0
 801a4e0:	b2d2      	uxtb	r2, r2
 801a4e2:	4413      	add	r3, r2
 801a4e4:	1c5a      	adds	r2, r3, #1
 801a4e6:	683b      	ldr	r3, [r7, #0]
 801a4e8:	681b      	ldr	r3, [r3, #0]
 801a4ea:	429a      	cmp	r2, r3
 801a4ec:	d902      	bls.n	801a4f4 <Base64_Decode+0x1c4>
            WOLFSSL_MSG("Bad Base64 Decode out buffer, too small");
            return BAD_FUNC_ARG;
 801a4ee:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a4f2:	e085      	b.n	801a600 <Base64_Decode+0x2d0>
        }

        e1 = Base64_Char2Val(e1);
 801a4f4:	7ffb      	ldrb	r3, [r7, #31]
 801a4f6:	4618      	mov	r0, r3
 801a4f8:	f7ff fe68 	bl	801a1cc <Base64_Char2Val>
 801a4fc:	4603      	mov	r3, r0
 801a4fe:	77fb      	strb	r3, [r7, #31]
        e2 = Base64_Char2Val(e2);
 801a500:	7fbb      	ldrb	r3, [r7, #30]
 801a502:	4618      	mov	r0, r3
 801a504:	f7ff fe62 	bl	801a1cc <Base64_Char2Val>
 801a508:	4603      	mov	r3, r0
 801a50a:	77bb      	strb	r3, [r7, #30]
        e3 = (byte)((e3 == PAD) ? 0 : Base64_Char2Val(e3));
 801a50c:	7f7b      	ldrb	r3, [r7, #29]
 801a50e:	2b3d      	cmp	r3, #61	@ 0x3d
 801a510:	d005      	beq.n	801a51e <Base64_Decode+0x1ee>
 801a512:	7f7b      	ldrb	r3, [r7, #29]
 801a514:	4618      	mov	r0, r3
 801a516:	f7ff fe59 	bl	801a1cc <Base64_Char2Val>
 801a51a:	4603      	mov	r3, r0
 801a51c:	e000      	b.n	801a520 <Base64_Decode+0x1f0>
 801a51e:	2300      	movs	r3, #0
 801a520:	777b      	strb	r3, [r7, #29]
        e4 = (byte)((e4 == PAD) ? 0 : Base64_Char2Val(e4));
 801a522:	7f3b      	ldrb	r3, [r7, #28]
 801a524:	2b3d      	cmp	r3, #61	@ 0x3d
 801a526:	d005      	beq.n	801a534 <Base64_Decode+0x204>
 801a528:	7f3b      	ldrb	r3, [r7, #28]
 801a52a:	4618      	mov	r0, r3
 801a52c:	f7ff fe4e 	bl	801a1cc <Base64_Char2Val>
 801a530:	4603      	mov	r3, r0
 801a532:	e000      	b.n	801a536 <Base64_Decode+0x206>
 801a534:	2300      	movs	r3, #0
 801a536:	773b      	strb	r3, [r7, #28]

        if (e1 == BAD || e2 == BAD || e3 == BAD || e4 == BAD) {
 801a538:	7ffb      	ldrb	r3, [r7, #31]
 801a53a:	2bff      	cmp	r3, #255	@ 0xff
 801a53c:	d008      	beq.n	801a550 <Base64_Decode+0x220>
 801a53e:	7fbb      	ldrb	r3, [r7, #30]
 801a540:	2bff      	cmp	r3, #255	@ 0xff
 801a542:	d005      	beq.n	801a550 <Base64_Decode+0x220>
 801a544:	7f7b      	ldrb	r3, [r7, #29]
 801a546:	2bff      	cmp	r3, #255	@ 0xff
 801a548:	d002      	beq.n	801a550 <Base64_Decode+0x220>
 801a54a:	7f3b      	ldrb	r3, [r7, #28]
 801a54c:	2bff      	cmp	r3, #255	@ 0xff
 801a54e:	d102      	bne.n	801a556 <Base64_Decode+0x226>
            WOLFSSL_MSG("Bad Base64 Decode bad character");
            return ASN_INPUT_E;
 801a550:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a554:	e054      	b.n	801a600 <Base64_Decode+0x2d0>
        }

        b1 = (byte)((e1 << 2) | (e2 >> 4));
 801a556:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801a55a:	009b      	lsls	r3, r3, #2
 801a55c:	b25a      	sxtb	r2, r3
 801a55e:	7fbb      	ldrb	r3, [r7, #30]
 801a560:	091b      	lsrs	r3, r3, #4
 801a562:	b2db      	uxtb	r3, r3
 801a564:	b25b      	sxtb	r3, r3
 801a566:	4313      	orrs	r3, r2
 801a568:	b25b      	sxtb	r3, r3
 801a56a:	76fb      	strb	r3, [r7, #27]
        b2 = (byte)(((e2 & 0xF) << 4) | (e3 >> 2));
 801a56c:	f997 301e 	ldrsb.w	r3, [r7, #30]
 801a570:	011b      	lsls	r3, r3, #4
 801a572:	b25a      	sxtb	r2, r3
 801a574:	7f7b      	ldrb	r3, [r7, #29]
 801a576:	089b      	lsrs	r3, r3, #2
 801a578:	b2db      	uxtb	r3, r3
 801a57a:	b25b      	sxtb	r3, r3
 801a57c:	4313      	orrs	r3, r2
 801a57e:	b25b      	sxtb	r3, r3
 801a580:	76bb      	strb	r3, [r7, #26]
        b3 = (byte)(((e3 & 0x3) << 6) | e4);
 801a582:	f997 301d 	ldrsb.w	r3, [r7, #29]
 801a586:	019b      	lsls	r3, r3, #6
 801a588:	b25a      	sxtb	r2, r3
 801a58a:	f997 301c 	ldrsb.w	r3, [r7, #28]
 801a58e:	4313      	orrs	r3, r2
 801a590:	b25b      	sxtb	r3, r3
 801a592:	767b      	strb	r3, [r7, #25]

        out[i++] = b1;
 801a594:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a596:	1c5a      	adds	r2, r3, #1
 801a598:	637a      	str	r2, [r7, #52]	@ 0x34
 801a59a:	687a      	ldr	r2, [r7, #4]
 801a59c:	4413      	add	r3, r2
 801a59e:	7efa      	ldrb	r2, [r7, #27]
 801a5a0:	701a      	strb	r2, [r3, #0]
        if (!pad3)
 801a5a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801a5a4:	2b00      	cmp	r3, #0
 801a5a6:	d106      	bne.n	801a5b6 <Base64_Decode+0x286>
            out[i++] = b2;
 801a5a8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a5aa:	1c5a      	adds	r2, r3, #1
 801a5ac:	637a      	str	r2, [r7, #52]	@ 0x34
 801a5ae:	687a      	ldr	r2, [r7, #4]
 801a5b0:	4413      	add	r3, r2
 801a5b2:	7eba      	ldrb	r2, [r7, #26]
 801a5b4:	701a      	strb	r2, [r3, #0]
        if (!pad4)
 801a5b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801a5b8:	2b00      	cmp	r3, #0
 801a5ba:	d10f      	bne.n	801a5dc <Base64_Decode+0x2ac>
            out[i++] = b3;
 801a5bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a5be:	1c5a      	adds	r2, r3, #1
 801a5c0:	637a      	str	r2, [r7, #52]	@ 0x34
 801a5c2:	687a      	ldr	r2, [r7, #4]
 801a5c4:	4413      	add	r3, r2
 801a5c6:	7e7a      	ldrb	r2, [r7, #25]
 801a5c8:	701a      	strb	r2, [r3, #0]
    while (inLen > 3) {
 801a5ca:	68bb      	ldr	r3, [r7, #8]
 801a5cc:	2b03      	cmp	r3, #3
 801a5ce:	f63f aed3 	bhi.w	801a378 <Base64_Decode+0x48>
 801a5d2:	e004      	b.n	801a5de <Base64_Decode+0x2ae>
                break;
 801a5d4:	bf00      	nop
 801a5d6:	e002      	b.n	801a5de <Base64_Decode+0x2ae>
            break;
 801a5d8:	bf00      	nop
 801a5da:	e000      	b.n	801a5de <Base64_Decode+0x2ae>
        else
            break;
 801a5dc:	bf00      	nop
    }
/* If the output buffer has a room for an extra byte, add a null terminator */
    if (out && *outLen > i)
 801a5de:	687b      	ldr	r3, [r7, #4]
 801a5e0:	2b00      	cmp	r3, #0
 801a5e2:	d009      	beq.n	801a5f8 <Base64_Decode+0x2c8>
 801a5e4:	683b      	ldr	r3, [r7, #0]
 801a5e6:	681b      	ldr	r3, [r3, #0]
 801a5e8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801a5ea:	429a      	cmp	r2, r3
 801a5ec:	d204      	bcs.n	801a5f8 <Base64_Decode+0x2c8>
        out[i]= '\0';
 801a5ee:	687a      	ldr	r2, [r7, #4]
 801a5f0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801a5f2:	4413      	add	r3, r2
 801a5f4:	2200      	movs	r2, #0
 801a5f6:	701a      	strb	r2, [r3, #0]

    *outLen = i;
 801a5f8:	683b      	ldr	r3, [r7, #0]
 801a5fa:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801a5fc:	601a      	str	r2, [r3, #0]

    return 0;
 801a5fe:	2300      	movs	r3, #0
}
 801a600:	4618      	mov	r0, r3
 801a602:	3738      	adds	r7, #56	@ 0x38
 801a604:	46bd      	mov	sp, r7
 801a606:	bd80      	pop	{r7, pc}

0801a608 <Base16_Decode>:
                           BAD, BAD,  /* G - ` */
                           10, 11, 12, 13, 14, 15   /* lower case a-f */
                         };  /* A starts at 0x41 not 0x3A */

int Base16_Decode(const byte* in, word32 inLen, byte* out, word32* outLen)
{
 801a608:	b480      	push	{r7}
 801a60a:	b089      	sub	sp, #36	@ 0x24
 801a60c:	af00      	add	r7, sp, #0
 801a60e:	60f8      	str	r0, [r7, #12]
 801a610:	60b9      	str	r1, [r7, #8]
 801a612:	607a      	str	r2, [r7, #4]
 801a614:	603b      	str	r3, [r7, #0]
    word32 inIdx  = 0;
 801a616:	2300      	movs	r3, #0
 801a618:	61fb      	str	r3, [r7, #28]
    word32 outIdx = 0;
 801a61a:	2300      	movs	r3, #0
 801a61c:	61bb      	str	r3, [r7, #24]

    if (in == NULL || out == NULL || outLen == NULL)
 801a61e:	68fb      	ldr	r3, [r7, #12]
 801a620:	2b00      	cmp	r3, #0
 801a622:	d005      	beq.n	801a630 <Base16_Decode+0x28>
 801a624:	687b      	ldr	r3, [r7, #4]
 801a626:	2b00      	cmp	r3, #0
 801a628:	d002      	beq.n	801a630 <Base16_Decode+0x28>
 801a62a:	683b      	ldr	r3, [r7, #0]
 801a62c:	2b00      	cmp	r3, #0
 801a62e:	d102      	bne.n	801a636 <Base16_Decode+0x2e>
        return BAD_FUNC_ARG;
 801a630:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a634:	e084      	b.n	801a740 <Base16_Decode+0x138>

    if (inLen == 1 && *outLen && in) {
 801a636:	68bb      	ldr	r3, [r7, #8]
 801a638:	2b01      	cmp	r3, #1
 801a63a:	d12a      	bne.n	801a692 <Base16_Decode+0x8a>
 801a63c:	683b      	ldr	r3, [r7, #0]
 801a63e:	681b      	ldr	r3, [r3, #0]
 801a640:	2b00      	cmp	r3, #0
 801a642:	d026      	beq.n	801a692 <Base16_Decode+0x8a>
 801a644:	68fb      	ldr	r3, [r7, #12]
 801a646:	2b00      	cmp	r3, #0
 801a648:	d023      	beq.n	801a692 <Base16_Decode+0x8a>
        byte b = (byte)(in[inIdx++] - BASE16_MIN);  /* 0 starts at 0x30 */
 801a64a:	69fb      	ldr	r3, [r7, #28]
 801a64c:	1c5a      	adds	r2, r3, #1
 801a64e:	61fa      	str	r2, [r7, #28]
 801a650:	68fa      	ldr	r2, [r7, #12]
 801a652:	4413      	add	r3, r2
 801a654:	781b      	ldrb	r3, [r3, #0]
 801a656:	3b30      	subs	r3, #48	@ 0x30
 801a658:	75fb      	strb	r3, [r7, #23]

        /* sanity check */
        if (b >=  sizeof(hexDecode)/sizeof(hexDecode[0]))
 801a65a:	7dfb      	ldrb	r3, [r7, #23]
 801a65c:	2b36      	cmp	r3, #54	@ 0x36
 801a65e:	d902      	bls.n	801a666 <Base16_Decode+0x5e>
            return ASN_INPUT_E;
 801a660:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a664:	e06c      	b.n	801a740 <Base16_Decode+0x138>

        b  = hexDecode[b];
 801a666:	7dfb      	ldrb	r3, [r7, #23]
 801a668:	4a38      	ldr	r2, [pc, #224]	@ (801a74c <Base16_Decode+0x144>)
 801a66a:	5cd3      	ldrb	r3, [r2, r3]
 801a66c:	75fb      	strb	r3, [r7, #23]

        if (b == BAD)
 801a66e:	7dfb      	ldrb	r3, [r7, #23]
 801a670:	2bff      	cmp	r3, #255	@ 0xff
 801a672:	d102      	bne.n	801a67a <Base16_Decode+0x72>
            return ASN_INPUT_E;
 801a674:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a678:	e062      	b.n	801a740 <Base16_Decode+0x138>

        out[outIdx++] = b;
 801a67a:	69bb      	ldr	r3, [r7, #24]
 801a67c:	1c5a      	adds	r2, r3, #1
 801a67e:	61ba      	str	r2, [r7, #24]
 801a680:	687a      	ldr	r2, [r7, #4]
 801a682:	4413      	add	r3, r2
 801a684:	7dfa      	ldrb	r2, [r7, #23]
 801a686:	701a      	strb	r2, [r3, #0]

        *outLen = outIdx;
 801a688:	683b      	ldr	r3, [r7, #0]
 801a68a:	69ba      	ldr	r2, [r7, #24]
 801a68c:	601a      	str	r2, [r3, #0]
        return 0;
 801a68e:	2300      	movs	r3, #0
 801a690:	e056      	b.n	801a740 <Base16_Decode+0x138>
    }

    if (inLen % 2)
 801a692:	68bb      	ldr	r3, [r7, #8]
 801a694:	f003 0301 	and.w	r3, r3, #1
 801a698:	2b00      	cmp	r3, #0
 801a69a:	d002      	beq.n	801a6a2 <Base16_Decode+0x9a>
        return BAD_FUNC_ARG;
 801a69c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a6a0:	e04e      	b.n	801a740 <Base16_Decode+0x138>

    if (*outLen < (inLen / 2))
 801a6a2:	683b      	ldr	r3, [r7, #0]
 801a6a4:	681a      	ldr	r2, [r3, #0]
 801a6a6:	68bb      	ldr	r3, [r7, #8]
 801a6a8:	085b      	lsrs	r3, r3, #1
 801a6aa:	429a      	cmp	r2, r3
 801a6ac:	d241      	bcs.n	801a732 <Base16_Decode+0x12a>
        return BAD_FUNC_ARG;
 801a6ae:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a6b2:	e045      	b.n	801a740 <Base16_Decode+0x138>

    while (inLen) {
        byte b  = (byte)(in[inIdx++] - BASE16_MIN);  /* 0 starts at 0x30 */
 801a6b4:	69fb      	ldr	r3, [r7, #28]
 801a6b6:	1c5a      	adds	r2, r3, #1
 801a6b8:	61fa      	str	r2, [r7, #28]
 801a6ba:	68fa      	ldr	r2, [r7, #12]
 801a6bc:	4413      	add	r3, r2
 801a6be:	781b      	ldrb	r3, [r3, #0]
 801a6c0:	3b30      	subs	r3, #48	@ 0x30
 801a6c2:	75bb      	strb	r3, [r7, #22]
        byte b2 = (byte)(in[inIdx++] - BASE16_MIN);
 801a6c4:	69fb      	ldr	r3, [r7, #28]
 801a6c6:	1c5a      	adds	r2, r3, #1
 801a6c8:	61fa      	str	r2, [r7, #28]
 801a6ca:	68fa      	ldr	r2, [r7, #12]
 801a6cc:	4413      	add	r3, r2
 801a6ce:	781b      	ldrb	r3, [r3, #0]
 801a6d0:	3b30      	subs	r3, #48	@ 0x30
 801a6d2:	757b      	strb	r3, [r7, #21]

        /* sanity checks */
        if (b >=  sizeof(hexDecode)/sizeof(hexDecode[0]))
 801a6d4:	7dbb      	ldrb	r3, [r7, #22]
 801a6d6:	2b36      	cmp	r3, #54	@ 0x36
 801a6d8:	d902      	bls.n	801a6e0 <Base16_Decode+0xd8>
            return ASN_INPUT_E;
 801a6da:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a6de:	e02f      	b.n	801a740 <Base16_Decode+0x138>
        if (b2 >= sizeof(hexDecode)/sizeof(hexDecode[0]))
 801a6e0:	7d7b      	ldrb	r3, [r7, #21]
 801a6e2:	2b36      	cmp	r3, #54	@ 0x36
 801a6e4:	d902      	bls.n	801a6ec <Base16_Decode+0xe4>
            return ASN_INPUT_E;
 801a6e6:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a6ea:	e029      	b.n	801a740 <Base16_Decode+0x138>

        b  = hexDecode[b];
 801a6ec:	7dbb      	ldrb	r3, [r7, #22]
 801a6ee:	4a17      	ldr	r2, [pc, #92]	@ (801a74c <Base16_Decode+0x144>)
 801a6f0:	5cd3      	ldrb	r3, [r2, r3]
 801a6f2:	75bb      	strb	r3, [r7, #22]
        b2 = hexDecode[b2];
 801a6f4:	7d7b      	ldrb	r3, [r7, #21]
 801a6f6:	4a15      	ldr	r2, [pc, #84]	@ (801a74c <Base16_Decode+0x144>)
 801a6f8:	5cd3      	ldrb	r3, [r2, r3]
 801a6fa:	757b      	strb	r3, [r7, #21]

        if (b == BAD || b2 == BAD)
 801a6fc:	7dbb      	ldrb	r3, [r7, #22]
 801a6fe:	2bff      	cmp	r3, #255	@ 0xff
 801a700:	d002      	beq.n	801a708 <Base16_Decode+0x100>
 801a702:	7d7b      	ldrb	r3, [r7, #21]
 801a704:	2bff      	cmp	r3, #255	@ 0xff
 801a706:	d102      	bne.n	801a70e <Base16_Decode+0x106>
            return ASN_INPUT_E;
 801a708:	f06f 0399 	mvn.w	r3, #153	@ 0x99
 801a70c:	e018      	b.n	801a740 <Base16_Decode+0x138>

        out[outIdx++] = (byte)((b << 4) | b2);
 801a70e:	f997 3016 	ldrsb.w	r3, [r7, #22]
 801a712:	011b      	lsls	r3, r3, #4
 801a714:	b25a      	sxtb	r2, r3
 801a716:	f997 3015 	ldrsb.w	r3, [r7, #21]
 801a71a:	4313      	orrs	r3, r2
 801a71c:	b259      	sxtb	r1, r3
 801a71e:	69bb      	ldr	r3, [r7, #24]
 801a720:	1c5a      	adds	r2, r3, #1
 801a722:	61ba      	str	r2, [r7, #24]
 801a724:	687a      	ldr	r2, [r7, #4]
 801a726:	4413      	add	r3, r2
 801a728:	b2ca      	uxtb	r2, r1
 801a72a:	701a      	strb	r2, [r3, #0]
        inLen -= 2;
 801a72c:	68bb      	ldr	r3, [r7, #8]
 801a72e:	3b02      	subs	r3, #2
 801a730:	60bb      	str	r3, [r7, #8]
    while (inLen) {
 801a732:	68bb      	ldr	r3, [r7, #8]
 801a734:	2b00      	cmp	r3, #0
 801a736:	d1bd      	bne.n	801a6b4 <Base16_Decode+0xac>
    }

    *outLen = outIdx;
 801a738:	683b      	ldr	r3, [r7, #0]
 801a73a:	69ba      	ldr	r2, [r7, #24]
 801a73c:	601a      	str	r2, [r3, #0]
    return 0;
 801a73e:	2300      	movs	r3, #0
}
 801a740:	4618      	mov	r0, r3
 801a742:	3724      	adds	r7, #36	@ 0x24
 801a744:	46bd      	mov	sp, r7
 801a746:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a74a:	4770      	bx	lr
 801a74c:	0803396c 	.word	0x0803396c

0801a750 <wc_FreeDhKey>:
    return wc_InitDhKey_ex(key, NULL, INVALID_DEVID);
}


int wc_FreeDhKey(DhKey* key)
{
 801a750:	b580      	push	{r7, lr}
 801a752:	b082      	sub	sp, #8
 801a754:	af00      	add	r7, sp, #0
 801a756:	6078      	str	r0, [r7, #4]
    if (key) {
 801a758:	687b      	ldr	r3, [r7, #4]
 801a75a:	2b00      	cmp	r3, #0
 801a75c:	d00f      	beq.n	801a77e <wc_FreeDhKey+0x2e>
        mp_clear(&key->p);
 801a75e:	687b      	ldr	r3, [r7, #4]
 801a760:	4618      	mov	r0, r3
 801a762:	f00c f826 	bl	80267b2 <mp_clear>
        mp_clear(&key->g);
 801a766:	687b      	ldr	r3, [r7, #4]
 801a768:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801a76c:	4618      	mov	r0, r3
 801a76e:	f00c f820 	bl	80267b2 <mp_clear>
        mp_clear(&key->q);
 801a772:	687b      	ldr	r3, [r7, #4]
 801a774:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 801a778:	4618      	mov	r0, r3
 801a77a:	f00c f81a 	bl	80267b2 <mp_clear>
    #endif
    #ifdef WOLFSSL_KCAPI_DH
        KcapiDh_Free(key);
    #endif
    }
    return 0;
 801a77e:	2300      	movs	r3, #0
}
 801a780:	4618      	mov	r0, r3
 801a782:	3708      	adds	r7, #8
 801a784:	46bd      	mov	sp, r7
 801a786:	bd80      	pop	{r7, pc}

0801a788 <ForceZero>:
{
 801a788:	b480      	push	{r7}
 801a78a:	b085      	sub	sp, #20
 801a78c:	af00      	add	r7, sp, #0
 801a78e:	6078      	str	r0, [r7, #4]
 801a790:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801a792:	687b      	ldr	r3, [r7, #4]
 801a794:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801a796:	e004      	b.n	801a7a2 <ForceZero+0x1a>
 801a798:	68fb      	ldr	r3, [r7, #12]
 801a79a:	1c5a      	adds	r2, r3, #1
 801a79c:	60fa      	str	r2, [r7, #12]
 801a79e:	2200      	movs	r2, #0
 801a7a0:	701a      	strb	r2, [r3, #0]
 801a7a2:	683b      	ldr	r3, [r7, #0]
 801a7a4:	1e5a      	subs	r2, r3, #1
 801a7a6:	603a      	str	r2, [r7, #0]
 801a7a8:	2b00      	cmp	r3, #0
 801a7aa:	d1f5      	bne.n	801a798 <ForceZero+0x10>
}
 801a7ac:	bf00      	nop
 801a7ae:	bf00      	nop
 801a7b0:	3714      	adds	r7, #20
 801a7b2:	46bd      	mov	sp, r7
 801a7b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a7b8:	4770      	bx	lr

0801a7ba <wc_ecc_curve_cache_free_spec_item>:
    #define FREE_CURVE_SPECS() WC_DO_NOTHING
#endif /* ECC_CACHE_CURVE */

static void wc_ecc_curve_cache_free_spec_item(ecc_curve_spec* curve, mp_int* item,
    byte mask)
{
 801a7ba:	b580      	push	{r7, lr}
 801a7bc:	b084      	sub	sp, #16
 801a7be:	af00      	add	r7, sp, #0
 801a7c0:	60f8      	str	r0, [r7, #12]
 801a7c2:	60b9      	str	r1, [r7, #8]
 801a7c4:	4613      	mov	r3, r2
 801a7c6:	71fb      	strb	r3, [r7, #7]
    if (item) {
 801a7c8:	68bb      	ldr	r3, [r7, #8]
 801a7ca:	2b00      	cmp	r3, #0
 801a7cc:	d002      	beq.n	801a7d4 <wc_ecc_curve_cache_free_spec_item+0x1a>
    #ifdef HAVE_WOLF_BIGINT
        wc_bigint_free(&item->raw);
    #endif
        mp_clear(item);
 801a7ce:	68b8      	ldr	r0, [r7, #8]
 801a7d0:	f00b ffef 	bl	80267b2 <mp_clear>
    }
    curve->load_mask = (byte)(curve->load_mask & ~mask);
 801a7d4:	68fb      	ldr	r3, [r7, #12]
 801a7d6:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a7da:	b25a      	sxtb	r2, r3
 801a7dc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801a7e0:	43db      	mvns	r3, r3
 801a7e2:	b25b      	sxtb	r3, r3
 801a7e4:	4013      	ands	r3, r2
 801a7e6:	b25b      	sxtb	r3, r3
 801a7e8:	b2da      	uxtb	r2, r3
 801a7ea:	68fb      	ldr	r3, [r7, #12]
 801a7ec:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
}
 801a7f0:	bf00      	nop
 801a7f2:	3710      	adds	r7, #16
 801a7f4:	46bd      	mov	sp, r7
 801a7f6:	bd80      	pop	{r7, pc}

0801a7f8 <wc_ecc_curve_cache_free_spec>:
static void wc_ecc_curve_cache_free_spec(ecc_curve_spec* curve)
{
 801a7f8:	b580      	push	{r7, lr}
 801a7fa:	b082      	sub	sp, #8
 801a7fc:	af00      	add	r7, sp, #0
 801a7fe:	6078      	str	r0, [r7, #4]
    if (curve == NULL) {
 801a800:	687b      	ldr	r3, [r7, #4]
 801a802:	2b00      	cmp	r3, #0
 801a804:	d058      	beq.n	801a8b8 <wc_ecc_curve_cache_free_spec+0xc0>
        return;
    }

    if (curve->load_mask & ECC_CURVE_FIELD_PRIME)
 801a806:	687b      	ldr	r3, [r7, #4]
 801a808:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a80c:	f003 0301 	and.w	r3, r3, #1
 801a810:	2b00      	cmp	r3, #0
 801a812:	d006      	beq.n	801a822 <wc_ecc_curve_cache_free_spec+0x2a>
        wc_ecc_curve_cache_free_spec_item(curve, curve->prime, ECC_CURVE_FIELD_PRIME);
 801a814:	687b      	ldr	r3, [r7, #4]
 801a816:	685b      	ldr	r3, [r3, #4]
 801a818:	2201      	movs	r2, #1
 801a81a:	4619      	mov	r1, r3
 801a81c:	6878      	ldr	r0, [r7, #4]
 801a81e:	f7ff ffcc 	bl	801a7ba <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_AF)
 801a822:	687b      	ldr	r3, [r7, #4]
 801a824:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a828:	f003 0302 	and.w	r3, r3, #2
 801a82c:	2b00      	cmp	r3, #0
 801a82e:	d006      	beq.n	801a83e <wc_ecc_curve_cache_free_spec+0x46>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Af, ECC_CURVE_FIELD_AF);
 801a830:	687b      	ldr	r3, [r7, #4]
 801a832:	689b      	ldr	r3, [r3, #8]
 801a834:	2202      	movs	r2, #2
 801a836:	4619      	mov	r1, r3
 801a838:	6878      	ldr	r0, [r7, #4]
 801a83a:	f7ff ffbe 	bl	801a7ba <wc_ecc_curve_cache_free_spec_item>
#ifdef USE_ECC_B_PARAM
    if (curve->load_mask & ECC_CURVE_FIELD_BF)
 801a83e:	687b      	ldr	r3, [r7, #4]
 801a840:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a844:	f003 0304 	and.w	r3, r3, #4
 801a848:	2b00      	cmp	r3, #0
 801a84a:	d006      	beq.n	801a85a <wc_ecc_curve_cache_free_spec+0x62>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Bf, ECC_CURVE_FIELD_BF);
 801a84c:	687b      	ldr	r3, [r7, #4]
 801a84e:	68db      	ldr	r3, [r3, #12]
 801a850:	2204      	movs	r2, #4
 801a852:	4619      	mov	r1, r3
 801a854:	6878      	ldr	r0, [r7, #4]
 801a856:	f7ff ffb0 	bl	801a7ba <wc_ecc_curve_cache_free_spec_item>
#endif
    if (curve->load_mask & ECC_CURVE_FIELD_ORDER)
 801a85a:	687b      	ldr	r3, [r7, #4]
 801a85c:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a860:	f003 0308 	and.w	r3, r3, #8
 801a864:	2b00      	cmp	r3, #0
 801a866:	d006      	beq.n	801a876 <wc_ecc_curve_cache_free_spec+0x7e>
        wc_ecc_curve_cache_free_spec_item(curve, curve->order, ECC_CURVE_FIELD_ORDER);
 801a868:	687b      	ldr	r3, [r7, #4]
 801a86a:	691b      	ldr	r3, [r3, #16]
 801a86c:	2208      	movs	r2, #8
 801a86e:	4619      	mov	r1, r3
 801a870:	6878      	ldr	r0, [r7, #4]
 801a872:	f7ff ffa2 	bl	801a7ba <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_GX)
 801a876:	687b      	ldr	r3, [r7, #4]
 801a878:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a87c:	f003 0310 	and.w	r3, r3, #16
 801a880:	2b00      	cmp	r3, #0
 801a882:	d006      	beq.n	801a892 <wc_ecc_curve_cache_free_spec+0x9a>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Gx, ECC_CURVE_FIELD_GX);
 801a884:	687b      	ldr	r3, [r7, #4]
 801a886:	695b      	ldr	r3, [r3, #20]
 801a888:	2210      	movs	r2, #16
 801a88a:	4619      	mov	r1, r3
 801a88c:	6878      	ldr	r0, [r7, #4]
 801a88e:	f7ff ff94 	bl	801a7ba <wc_ecc_curve_cache_free_spec_item>
    if (curve->load_mask & ECC_CURVE_FIELD_GY)
 801a892:	687b      	ldr	r3, [r7, #4]
 801a894:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a898:	f003 0320 	and.w	r3, r3, #32
 801a89c:	2b00      	cmp	r3, #0
 801a89e:	d006      	beq.n	801a8ae <wc_ecc_curve_cache_free_spec+0xb6>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Gy, ECC_CURVE_FIELD_GY);
 801a8a0:	687b      	ldr	r3, [r7, #4]
 801a8a2:	699b      	ldr	r3, [r3, #24]
 801a8a4:	2220      	movs	r2, #32
 801a8a6:	4619      	mov	r1, r3
 801a8a8:	6878      	ldr	r0, [r7, #4]
 801a8aa:	f7ff ff86 	bl	801a7ba <wc_ecc_curve_cache_free_spec_item>

    curve->load_mask = 0;
 801a8ae:	687b      	ldr	r3, [r7, #4]
 801a8b0:	2200      	movs	r2, #0
 801a8b2:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
 801a8b6:	e000      	b.n	801a8ba <wc_ecc_curve_cache_free_spec+0xc2>
        return;
 801a8b8:	bf00      	nop
}
 801a8ba:	3708      	adds	r7, #8
 801a8bc:	46bd      	mov	sp, r7
 801a8be:	bd80      	pop	{r7, pc}

0801a8c0 <wc_ecc_curve_free>:

static void wc_ecc_curve_free(ecc_curve_spec* curve)
{
 801a8c0:	b580      	push	{r7, lr}
 801a8c2:	b082      	sub	sp, #8
 801a8c4:	af00      	add	r7, sp, #0
 801a8c6:	6078      	str	r0, [r7, #4]
    if (curve) {
 801a8c8:	687b      	ldr	r3, [r7, #4]
 801a8ca:	2b00      	cmp	r3, #0
 801a8cc:	d002      	beq.n	801a8d4 <wc_ecc_curve_free+0x14>
            wc_ecc_curve_cache_free_spec(curve);
            XFREE(curve, NULL, DYNAMIC_TYPE_ECC);
        }
        #endif
    #else
        wc_ecc_curve_cache_free_spec(curve);
 801a8ce:	6878      	ldr	r0, [r7, #4]
 801a8d0:	f7ff ff92 	bl	801a7f8 <wc_ecc_curve_cache_free_spec>
    #endif
    }
}
 801a8d4:	bf00      	nop
 801a8d6:	3708      	adds	r7, #8
 801a8d8:	46bd      	mov	sp, r7
 801a8da:	bd80      	pop	{r7, pc}

0801a8dc <wc_ecc_curve_cache_load_item>:

static int wc_ecc_curve_cache_load_item(ecc_curve_spec* curve, const char* src,
    mp_int** dst, byte mask)
{
 801a8dc:	b580      	push	{r7, lr}
 801a8de:	b086      	sub	sp, #24
 801a8e0:	af00      	add	r7, sp, #0
 801a8e2:	60f8      	str	r0, [r7, #12]
 801a8e4:	60b9      	str	r1, [r7, #8]
 801a8e6:	607a      	str	r2, [r7, #4]
 801a8e8:	70fb      	strb	r3, [r7, #3]
    int err;

#ifndef ECC_CACHE_CURVE
    /* get mp_int from temp */
    if (curve->spec_use >= curve->spec_count) {
 801a8ea:	68fb      	ldr	r3, [r7, #12]
 801a8ec:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801a8ee:	68fb      	ldr	r3, [r7, #12]
 801a8f0:	6a1b      	ldr	r3, [r3, #32]
 801a8f2:	429a      	cmp	r2, r3
 801a8f4:	d302      	bcc.n	801a8fc <wc_ecc_curve_cache_load_item+0x20>
        WOLFSSL_MSG("Invalid DECLARE_CURVE_SPECS count");
        return ECC_BAD_ARG_E;
 801a8f6:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801a8fa:	e028      	b.n	801a94e <wc_ecc_curve_cache_load_item+0x72>
    }
#ifdef WOLFSSL_SP_MATH_ALL
    *dst = (mp_int*)(curve->spec_ints + MP_INT_SIZEOF(MP_BITS_CNT(
        MAX_ECC_BITS_USE)) * curve->spec_use++);
#else
    *dst = &curve->spec_ints[curve->spec_use++];
 801a8fc:	68fb      	ldr	r3, [r7, #12]
 801a8fe:	69da      	ldr	r2, [r3, #28]
 801a900:	68fb      	ldr	r3, [r7, #12]
 801a902:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a904:	1c58      	adds	r0, r3, #1
 801a906:	68f9      	ldr	r1, [r7, #12]
 801a908:	6248      	str	r0, [r1, #36]	@ 0x24
 801a90a:	f44f 710b 	mov.w	r1, #556	@ 0x22c
 801a90e:	fb01 f303 	mul.w	r3, r1, r3
 801a912:	441a      	add	r2, r3
 801a914:	687b      	ldr	r3, [r7, #4]
 801a916:	601a      	str	r2, [r3, #0]
#endif

#ifdef WOLFSSL_SP_MATH_ALL
    err = mp_init_size(*dst, MP_BITS_CNT(MAX_ECC_BITS_USE));
#else
    err = mp_init(*dst);
 801a918:	687b      	ldr	r3, [r7, #4]
 801a91a:	681b      	ldr	r3, [r3, #0]
 801a91c:	4618      	mov	r0, r3
 801a91e:	f00b febe 	bl	802669e <mp_init>
 801a922:	6178      	str	r0, [r7, #20]
#endif
    if (err == MP_OKAY) {
 801a924:	697b      	ldr	r3, [r7, #20]
 801a926:	2b00      	cmp	r3, #0
 801a928:	d110      	bne.n	801a94c <wc_ecc_curve_cache_load_item+0x70>
        curve->load_mask |= mask;
 801a92a:	68fb      	ldr	r3, [r7, #12]
 801a92c:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
 801a930:	78fb      	ldrb	r3, [r7, #3]
 801a932:	4313      	orrs	r3, r2
 801a934:	b2da      	uxtb	r2, r3
 801a936:	68fb      	ldr	r3, [r7, #12]
 801a938:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

        err = mp_read_radix(*dst, src, MP_RADIX_HEX);
 801a93c:	687b      	ldr	r3, [r7, #4]
 801a93e:	681b      	ldr	r3, [r3, #0]
 801a940:	2210      	movs	r2, #16
 801a942:	68b9      	ldr	r1, [r7, #8]
 801a944:	4618      	mov	r0, r3
 801a946:	f00c fb55 	bl	8026ff4 <mp_read_radix>
 801a94a:	6178      	str	r0, [r7, #20]
    #ifdef HAVE_WOLF_BIGINT
        if (err == MP_OKAY)
            err = wc_mp_to_bigint(*dst, &(*dst)->raw);
    #endif
    }
    return err;
 801a94c:	697b      	ldr	r3, [r7, #20]
}
 801a94e:	4618      	mov	r0, r3
 801a950:	3718      	adds	r7, #24
 801a952:	46bd      	mov	sp, r7
 801a954:	bd80      	pop	{r7, pc}

0801a956 <wc_ecc_curve_load>:

static int wc_ecc_curve_load(const ecc_set_type* dp, ecc_curve_spec** pCurve,
    byte load_mask)
{
 801a956:	b580      	push	{r7, lr}
 801a958:	b088      	sub	sp, #32
 801a95a:	af00      	add	r7, sp, #0
 801a95c:	60f8      	str	r0, [r7, #12]
 801a95e:	60b9      	str	r1, [r7, #8]
 801a960:	4613      	mov	r3, r2
 801a962:	71fb      	strb	r3, [r7, #7]
    int ret = 0;
 801a964:	2300      	movs	r3, #0
 801a966:	61fb      	str	r3, [r7, #28]
    ecc_curve_spec* curve;
    byte load_items = 0; /* mask of items to load */
 801a968:	2300      	movs	r3, #0
 801a96a:	76fb      	strb	r3, [r7, #27]
#ifdef ECC_CACHE_CURVE
    int x;
#endif

    if (dp == NULL || pCurve == NULL)
 801a96c:	68fb      	ldr	r3, [r7, #12]
 801a96e:	2b00      	cmp	r3, #0
 801a970:	d002      	beq.n	801a978 <wc_ecc_curve_load+0x22>
 801a972:	68bb      	ldr	r3, [r7, #8]
 801a974:	2b00      	cmp	r3, #0
 801a976:	d102      	bne.n	801a97e <wc_ecc_curve_load+0x28>
        return BAD_FUNC_ARG;
 801a978:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801a97c:	e094      	b.n	801aaa8 <wc_ecc_curve_load+0x152>
#endif /* WOLFSSL_NO_MALLOC */

    /* return new or cached curve */
    *pCurve = curve;
#else
    curve = *pCurve;
 801a97e:	68bb      	ldr	r3, [r7, #8]
 801a980:	681b      	ldr	r3, [r3, #0]
 801a982:	617b      	str	r3, [r7, #20]
#endif /* ECC_CACHE_CURVE */

    /* make sure the curve is initialized */
    if (curve->dp != dp) {
 801a984:	697b      	ldr	r3, [r7, #20]
 801a986:	681b      	ldr	r3, [r3, #0]
 801a988:	68fa      	ldr	r2, [r7, #12]
 801a98a:	429a      	cmp	r2, r3
 801a98c:	d003      	beq.n	801a996 <wc_ecc_curve_load+0x40>
        curve->load_mask = 0;
 801a98e:	697b      	ldr	r3, [r7, #20]
 801a990:	2200      	movs	r2, #0
 801a992:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
        curve->order = &curve->order_lcl;
        curve->Gx = &curve->Gx_lcl;
        curve->Gy = &curve->Gy_lcl;
    #endif
    }
    curve->dp = dp; /* set dp info */
 801a996:	697b      	ldr	r3, [r7, #20]
 801a998:	68fa      	ldr	r2, [r7, #12]
 801a99a:	601a      	str	r2, [r3, #0]

    /* determine items to load */
    load_items = (byte)(((byte)~(word32)curve->load_mask) & load_mask);
 801a99c:	697b      	ldr	r3, [r7, #20]
 801a99e:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801a9a2:	43db      	mvns	r3, r3
 801a9a4:	b2da      	uxtb	r2, r3
 801a9a6:	79fb      	ldrb	r3, [r7, #7]
 801a9a8:	4013      	ands	r3, r2
 801a9aa:	76fb      	strb	r3, [r7, #27]
    curve->load_mask |= load_items;
 801a9ac:	697b      	ldr	r3, [r7, #20]
 801a9ae:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
 801a9b2:	7efb      	ldrb	r3, [r7, #27]
 801a9b4:	4313      	orrs	r3, r2
 801a9b6:	b2da      	uxtb	r2, r3
 801a9b8:	697b      	ldr	r3, [r7, #20]
 801a9ba:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

    /* load items */
    if (load_items & ECC_CURVE_FIELD_PRIME)
 801a9be:	7efb      	ldrb	r3, [r7, #27]
 801a9c0:	f003 0301 	and.w	r3, r3, #1
 801a9c4:	2b00      	cmp	r3, #0
 801a9c6:	d00b      	beq.n	801a9e0 <wc_ecc_curve_load+0x8a>
        ret += wc_ecc_curve_cache_load_item(curve, dp->prime, &curve->prime,
 801a9c8:	68fb      	ldr	r3, [r7, #12]
 801a9ca:	68d9      	ldr	r1, [r3, #12]
 801a9cc:	697b      	ldr	r3, [r7, #20]
 801a9ce:	1d1a      	adds	r2, r3, #4
 801a9d0:	2301      	movs	r3, #1
 801a9d2:	6978      	ldr	r0, [r7, #20]
 801a9d4:	f7ff ff82 	bl	801a8dc <wc_ecc_curve_cache_load_item>
 801a9d8:	4602      	mov	r2, r0
 801a9da:	69fb      	ldr	r3, [r7, #28]
 801a9dc:	4413      	add	r3, r2
 801a9de:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_PRIME);
    if (load_items & ECC_CURVE_FIELD_AF)
 801a9e0:	7efb      	ldrb	r3, [r7, #27]
 801a9e2:	f003 0302 	and.w	r3, r3, #2
 801a9e6:	2b00      	cmp	r3, #0
 801a9e8:	d00c      	beq.n	801aa04 <wc_ecc_curve_load+0xae>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Af, &curve->Af,
 801a9ea:	68fb      	ldr	r3, [r7, #12]
 801a9ec:	6919      	ldr	r1, [r3, #16]
 801a9ee:	697b      	ldr	r3, [r7, #20]
 801a9f0:	f103 0208 	add.w	r2, r3, #8
 801a9f4:	2302      	movs	r3, #2
 801a9f6:	6978      	ldr	r0, [r7, #20]
 801a9f8:	f7ff ff70 	bl	801a8dc <wc_ecc_curve_cache_load_item>
 801a9fc:	4602      	mov	r2, r0
 801a9fe:	69fb      	ldr	r3, [r7, #28]
 801aa00:	4413      	add	r3, r2
 801aa02:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_AF);
#ifdef USE_ECC_B_PARAM
    if (load_items & ECC_CURVE_FIELD_BF)
 801aa04:	7efb      	ldrb	r3, [r7, #27]
 801aa06:	f003 0304 	and.w	r3, r3, #4
 801aa0a:	2b00      	cmp	r3, #0
 801aa0c:	d00c      	beq.n	801aa28 <wc_ecc_curve_load+0xd2>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Bf, &curve->Bf,
 801aa0e:	68fb      	ldr	r3, [r7, #12]
 801aa10:	6959      	ldr	r1, [r3, #20]
 801aa12:	697b      	ldr	r3, [r7, #20]
 801aa14:	f103 020c 	add.w	r2, r3, #12
 801aa18:	2304      	movs	r3, #4
 801aa1a:	6978      	ldr	r0, [r7, #20]
 801aa1c:	f7ff ff5e 	bl	801a8dc <wc_ecc_curve_cache_load_item>
 801aa20:	4602      	mov	r2, r0
 801aa22:	69fb      	ldr	r3, [r7, #28]
 801aa24:	4413      	add	r3, r2
 801aa26:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_BF);
#endif
    if (load_items & ECC_CURVE_FIELD_ORDER)
 801aa28:	7efb      	ldrb	r3, [r7, #27]
 801aa2a:	f003 0308 	and.w	r3, r3, #8
 801aa2e:	2b00      	cmp	r3, #0
 801aa30:	d00c      	beq.n	801aa4c <wc_ecc_curve_load+0xf6>
        ret += wc_ecc_curve_cache_load_item(curve, dp->order, &curve->order,
 801aa32:	68fb      	ldr	r3, [r7, #12]
 801aa34:	6999      	ldr	r1, [r3, #24]
 801aa36:	697b      	ldr	r3, [r7, #20]
 801aa38:	f103 0210 	add.w	r2, r3, #16
 801aa3c:	2308      	movs	r3, #8
 801aa3e:	6978      	ldr	r0, [r7, #20]
 801aa40:	f7ff ff4c 	bl	801a8dc <wc_ecc_curve_cache_load_item>
 801aa44:	4602      	mov	r2, r0
 801aa46:	69fb      	ldr	r3, [r7, #28]
 801aa48:	4413      	add	r3, r2
 801aa4a:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_ORDER);
    if (load_items & ECC_CURVE_FIELD_GX)
 801aa4c:	7efb      	ldrb	r3, [r7, #27]
 801aa4e:	f003 0310 	and.w	r3, r3, #16
 801aa52:	2b00      	cmp	r3, #0
 801aa54:	d00c      	beq.n	801aa70 <wc_ecc_curve_load+0x11a>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Gx, &curve->Gx,
 801aa56:	68fb      	ldr	r3, [r7, #12]
 801aa58:	69d9      	ldr	r1, [r3, #28]
 801aa5a:	697b      	ldr	r3, [r7, #20]
 801aa5c:	f103 0214 	add.w	r2, r3, #20
 801aa60:	2310      	movs	r3, #16
 801aa62:	6978      	ldr	r0, [r7, #20]
 801aa64:	f7ff ff3a 	bl	801a8dc <wc_ecc_curve_cache_load_item>
 801aa68:	4602      	mov	r2, r0
 801aa6a:	69fb      	ldr	r3, [r7, #28]
 801aa6c:	4413      	add	r3, r2
 801aa6e:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_GX);
    if (load_items & ECC_CURVE_FIELD_GY)
 801aa70:	7efb      	ldrb	r3, [r7, #27]
 801aa72:	f003 0320 	and.w	r3, r3, #32
 801aa76:	2b00      	cmp	r3, #0
 801aa78:	d00c      	beq.n	801aa94 <wc_ecc_curve_load+0x13e>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Gy, &curve->Gy,
 801aa7a:	68fb      	ldr	r3, [r7, #12]
 801aa7c:	6a19      	ldr	r1, [r3, #32]
 801aa7e:	697b      	ldr	r3, [r7, #20]
 801aa80:	f103 0218 	add.w	r2, r3, #24
 801aa84:	2320      	movs	r3, #32
 801aa86:	6978      	ldr	r0, [r7, #20]
 801aa88:	f7ff ff28 	bl	801a8dc <wc_ecc_curve_cache_load_item>
 801aa8c:	4602      	mov	r2, r0
 801aa8e:	69fb      	ldr	r3, [r7, #28]
 801aa90:	4413      	add	r3, r2
 801aa92:	61fb      	str	r3, [r7, #28]
            ECC_CURVE_FIELD_GY);

    /* check for error */
    if (ret != 0) {
 801aa94:	69fb      	ldr	r3, [r7, #28]
 801aa96:	2b00      	cmp	r3, #0
 801aa98:	d005      	beq.n	801aaa6 <wc_ecc_curve_load+0x150>
        wc_ecc_curve_free(curve);
 801aa9a:	6978      	ldr	r0, [r7, #20]
 801aa9c:	f7ff ff10 	bl	801a8c0 <wc_ecc_curve_free>
        ret = MP_READ_E;
 801aaa0:	f06f 036e 	mvn.w	r3, #110	@ 0x6e
 801aaa4:	61fb      	str	r3, [r7, #28]

#if defined(ECC_CACHE_CURVE) && !defined(SINGLE_THREADED)
    wc_UnLockMutex(&ecc_curve_cache_mutex);
#endif

    return ret;
 801aaa6:	69fb      	ldr	r3, [r7, #28]
}
 801aaa8:	4618      	mov	r0, r3
 801aaaa:	3720      	adds	r7, #32
 801aaac:	46bd      	mov	sp, r7
 801aaae:	bd80      	pop	{r7, pc}

0801aab0 <wc_ecc_set_curve>:
        return NULL;
    return ecc_sets[curve_idx].name;
}

int wc_ecc_set_curve(ecc_key* key, int keysize, int curve_id)
{
 801aab0:	b480      	push	{r7}
 801aab2:	b087      	sub	sp, #28
 801aab4:	af00      	add	r7, sp, #0
 801aab6:	60f8      	str	r0, [r7, #12]
 801aab8:	60b9      	str	r1, [r7, #8]
 801aaba:	607a      	str	r2, [r7, #4]
    if (key == NULL || (keysize <= 0 && curve_id < 0)) {
 801aabc:	68fb      	ldr	r3, [r7, #12]
 801aabe:	2b00      	cmp	r3, #0
 801aac0:	d005      	beq.n	801aace <wc_ecc_set_curve+0x1e>
 801aac2:	68bb      	ldr	r3, [r7, #8]
 801aac4:	2b00      	cmp	r3, #0
 801aac6:	dc05      	bgt.n	801aad4 <wc_ecc_set_curve+0x24>
 801aac8:	687b      	ldr	r3, [r7, #4]
 801aaca:	2b00      	cmp	r3, #0
 801aacc:	da02      	bge.n	801aad4 <wc_ecc_set_curve+0x24>
        return BAD_FUNC_ARG;
 801aace:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801aad2:	e052      	b.n	801ab7a <wc_ecc_set_curve+0xca>
    }

    if (keysize > ECC_MAXSIZE) {
 801aad4:	68bb      	ldr	r3, [r7, #8]
 801aad6:	2b42      	cmp	r3, #66	@ 0x42
 801aad8:	dd02      	ble.n	801aae0 <wc_ecc_set_curve+0x30>
        return ECC_BAD_ARG_E;
 801aada:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801aade:	e04c      	b.n	801ab7a <wc_ecc_set_curve+0xca>
    }

    /* handle custom case */
    if (key->idx != ECC_CUSTOM_IDX) {
 801aae0:	68fb      	ldr	r3, [r7, #12]
 801aae2:	685b      	ldr	r3, [r3, #4]
 801aae4:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801aae8:	d046      	beq.n	801ab78 <wc_ecc_set_curve+0xc8>
        int x;

        /* default values */
        key->idx = 0;
 801aaea:	68fb      	ldr	r3, [r7, #12]
 801aaec:	2200      	movs	r2, #0
 801aaee:	605a      	str	r2, [r3, #4]
        key->dp = NULL;
 801aaf0:	68fb      	ldr	r3, [r7, #12]
 801aaf2:	2200      	movs	r2, #0
 801aaf4:	611a      	str	r2, [r3, #16]

        /* find ecc_set based on curve_id or key size */
        for (x = 0; ecc_sets[x].size != 0; x++) {
 801aaf6:	2300      	movs	r3, #0
 801aaf8:	617b      	str	r3, [r7, #20]
 801aafa:	e01b      	b.n	801ab34 <wc_ecc_set_curve+0x84>
            if (curve_id > ECC_CURVE_DEF) {
 801aafc:	687b      	ldr	r3, [r7, #4]
 801aafe:	2b00      	cmp	r3, #0
 801ab00:	dd0b      	ble.n	801ab1a <wc_ecc_set_curve+0x6a>
                if (curve_id == ecc_sets[x].id)
 801ab02:	4a21      	ldr	r2, [pc, #132]	@ (801ab88 <wc_ecc_set_curve+0xd8>)
 801ab04:	697b      	ldr	r3, [r7, #20]
 801ab06:	2134      	movs	r1, #52	@ 0x34
 801ab08:	fb01 f303 	mul.w	r3, r1, r3
 801ab0c:	4413      	add	r3, r2
 801ab0e:	3304      	adds	r3, #4
 801ab10:	681b      	ldr	r3, [r3, #0]
 801ab12:	687a      	ldr	r2, [r7, #4]
 801ab14:	429a      	cmp	r2, r3
 801ab16:	d10a      	bne.n	801ab2e <wc_ecc_set_curve+0x7e>
                  break;
 801ab18:	e017      	b.n	801ab4a <wc_ecc_set_curve+0x9a>
            }
            else if (keysize <= ecc_sets[x].size) {
 801ab1a:	4a1b      	ldr	r2, [pc, #108]	@ (801ab88 <wc_ecc_set_curve+0xd8>)
 801ab1c:	697b      	ldr	r3, [r7, #20]
 801ab1e:	2134      	movs	r1, #52	@ 0x34
 801ab20:	fb01 f303 	mul.w	r3, r1, r3
 801ab24:	4413      	add	r3, r2
 801ab26:	681b      	ldr	r3, [r3, #0]
 801ab28:	68ba      	ldr	r2, [r7, #8]
 801ab2a:	429a      	cmp	r2, r3
 801ab2c:	dd0c      	ble.n	801ab48 <wc_ecc_set_curve+0x98>
        for (x = 0; ecc_sets[x].size != 0; x++) {
 801ab2e:	697b      	ldr	r3, [r7, #20]
 801ab30:	3301      	adds	r3, #1
 801ab32:	617b      	str	r3, [r7, #20]
 801ab34:	4a14      	ldr	r2, [pc, #80]	@ (801ab88 <wc_ecc_set_curve+0xd8>)
 801ab36:	697b      	ldr	r3, [r7, #20]
 801ab38:	2134      	movs	r1, #52	@ 0x34
 801ab3a:	fb01 f303 	mul.w	r3, r1, r3
 801ab3e:	4413      	add	r3, r2
 801ab40:	681b      	ldr	r3, [r3, #0]
 801ab42:	2b00      	cmp	r3, #0
 801ab44:	d1da      	bne.n	801aafc <wc_ecc_set_curve+0x4c>
 801ab46:	e000      	b.n	801ab4a <wc_ecc_set_curve+0x9a>
                break;
 801ab48:	bf00      	nop
            }
        }
        if (ecc_sets[x].size == 0) {
 801ab4a:	4a0f      	ldr	r2, [pc, #60]	@ (801ab88 <wc_ecc_set_curve+0xd8>)
 801ab4c:	697b      	ldr	r3, [r7, #20]
 801ab4e:	2134      	movs	r1, #52	@ 0x34
 801ab50:	fb01 f303 	mul.w	r3, r1, r3
 801ab54:	4413      	add	r3, r2
 801ab56:	681b      	ldr	r3, [r3, #0]
 801ab58:	2b00      	cmp	r3, #0
 801ab5a:	d102      	bne.n	801ab62 <wc_ecc_set_curve+0xb2>
            WOLFSSL_MSG("ECC Curve not found");
            return ECC_CURVE_OID_E;
 801ab5c:	f06f 03ab 	mvn.w	r3, #171	@ 0xab
 801ab60:	e00b      	b.n	801ab7a <wc_ecc_set_curve+0xca>
        }

        key->idx = x;
 801ab62:	68fb      	ldr	r3, [r7, #12]
 801ab64:	697a      	ldr	r2, [r7, #20]
 801ab66:	605a      	str	r2, [r3, #4]
        key->dp  = &ecc_sets[x];
 801ab68:	697b      	ldr	r3, [r7, #20]
 801ab6a:	2234      	movs	r2, #52	@ 0x34
 801ab6c:	fb02 f303 	mul.w	r3, r2, r3
 801ab70:	4a05      	ldr	r2, [pc, #20]	@ (801ab88 <wc_ecc_set_curve+0xd8>)
 801ab72:	441a      	add	r2, r3
 801ab74:	68fb      	ldr	r3, [r7, #12]
 801ab76:	611a      	str	r2, [r3, #16]
    }

    return 0;
 801ab78:	2300      	movs	r3, #0
}
 801ab7a:	4618      	mov	r0, r3
 801ab7c:	371c      	adds	r7, #28
 801ab7e:	46bd      	mov	sp, r7
 801ab80:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ab84:	4770      	bx	lr
 801ab86:	bf00      	nop
 801ab88:	080339ac 	.word	0x080339ac

0801ab8c <alt_fp_init>:


#ifdef ALT_ECC_SIZE
static void alt_fp_init(mp_int* a)
{
 801ab8c:	b580      	push	{r7, lr}
 801ab8e:	b082      	sub	sp, #8
 801ab90:	af00      	add	r7, sp, #0
 801ab92:	6078      	str	r0, [r7, #4]
    a->size = FP_SIZE_ECC;
 801ab94:	687b      	ldr	r3, [r7, #4]
 801ab96:	2211      	movs	r2, #17
 801ab98:	609a      	str	r2, [r3, #8]
    mp_zero(a);
 801ab9a:	6878      	ldr	r0, [r7, #4]
 801ab9c:	f00b fd9c 	bl	80266d8 <fp_zero>
}
 801aba0:	bf00      	nop
 801aba2:	3708      	adds	r7, #8
 801aba4:	46bd      	mov	sp, r7
 801aba6:	bd80      	pop	{r7, pc}

0801aba8 <_ecc_projective_add_point>:
   mp       The "b" value from montgomery_setup()
   return   MP_OKAY on success
*/
static int _ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,
                                     mp_int* a, mp_int* modulus, mp_digit mp)
{
 801aba8:	b580      	push	{r7, lr}
 801abaa:	b0a6      	sub	sp, #152	@ 0x98
 801abac:	af02      	add	r7, sp, #8
 801abae:	60f8      	str	r0, [r7, #12]
 801abb0:	60b9      	str	r1, [r7, #8]
 801abb2:	607a      	str	r2, [r7, #4]
 801abb4:	603b      	str	r3, [r7, #0]
#if !defined(WOLFSSL_SP_MATH)
   DECL_MP_INT_SIZE_DYN(t1, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801abb6:	2300      	movs	r3, #0
 801abb8:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
   DECL_MP_INT_SIZE_DYN(t2, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801abbc:	2300      	movs	r3, #0
 801abbe:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
#ifdef ALT_ECC_SIZE
   DECL_MP_INT_SIZE_DYN(rx, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801abc2:	2300      	movs	r3, #0
 801abc4:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
   DECL_MP_INT_SIZE_DYN(ry, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801abc8:	2300      	movs	r3, #0
 801abca:	67fb      	str	r3, [r7, #124]	@ 0x7c
   DECL_MP_INT_SIZE_DYN(rz, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801abcc:	2300      	movs	r3, #0
 801abce:	67bb      	str	r3, [r7, #120]	@ 0x78
#endif
   mp_int  *x, *y, *z;
   int     err;

   /* if Q == R then swap P and Q, so we don't require a local x,y,z */
   if (Q == R) {
 801abd0:	68ba      	ldr	r2, [r7, #8]
 801abd2:	687b      	ldr	r3, [r7, #4]
 801abd4:	429a      	cmp	r2, r3
 801abd6:	d105      	bne.n	801abe4 <_ecc_projective_add_point+0x3c>
      ecc_point* tPt  = P;
 801abd8:	68fb      	ldr	r3, [r7, #12]
 801abda:	677b      	str	r3, [r7, #116]	@ 0x74
      P = Q;
 801abdc:	68bb      	ldr	r3, [r7, #8]
 801abde:	60fb      	str	r3, [r7, #12]
      Q = tPt;
 801abe0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801abe2:	60bb      	str	r3, [r7, #8]
   }
   else
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#endif /* WOLFSSL_SMALL_STACK */
   {
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801abe4:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801abe8:	f003 ff54 	bl	801ea94 <wolfSSL_Malloc>
 801abec:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
 801abf0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801abf4:	2b00      	cmp	r3, #0
 801abf6:	d006      	beq.n	801ac06 <_ecc_projective_add_point+0x5e>
 801abf8:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801abfc:	2100      	movs	r1, #0
 801abfe:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ac02:	f00d fc65 	bl	80284d0 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801ac06:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801ac0a:	f003 ff43 	bl	801ea94 <wolfSSL_Malloc>
 801ac0e:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
 801ac12:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ac16:	2b00      	cmp	r3, #0
 801ac18:	d006      	beq.n	801ac28 <_ecc_projective_add_point+0x80>
 801ac1a:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801ac1e:	2100      	movs	r1, #0
 801ac20:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ac24:	f00d fc54 	bl	80284d0 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (t1 == NULL || t2 == NULL) {
 801ac28:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ac2c:	2b00      	cmp	r3, #0
 801ac2e:	d003      	beq.n	801ac38 <_ecc_projective_add_point+0x90>
 801ac30:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ac34:	2b00      	cmp	r3, #0
 801ac36:	d115      	bne.n	801ac64 <_ecc_projective_add_point+0xbc>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801ac38:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ac3c:	617b      	str	r3, [r7, #20]
 801ac3e:	697b      	ldr	r3, [r7, #20]
 801ac40:	2b00      	cmp	r3, #0
 801ac42:	d002      	beq.n	801ac4a <_ecc_projective_add_point+0xa2>
 801ac44:	6978      	ldr	r0, [r7, #20]
 801ac46:	f003 ff41 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801ac4a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ac4e:	613b      	str	r3, [r7, #16]
 801ac50:	693b      	ldr	r3, [r7, #16]
 801ac52:	2b00      	cmp	r3, #0
 801ac54:	d002      	beq.n	801ac5c <_ecc_projective_add_point+0xb4>
 801ac56:	6938      	ldr	r0, [r7, #16]
 801ac58:	f003 ff38 	bl	801eacc <wolfSSL_Free>
         return MEMORY_E;
 801ac5c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801ac60:	f000 bc2d 	b.w	801b4be <_ecc_projective_add_point+0x916>
      }
   #endif
#ifdef ALT_ECC_SIZE
      NEW_MP_INT_SIZE(rx, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801ac64:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801ac68:	f003 ff14 	bl	801ea94 <wolfSSL_Malloc>
 801ac6c:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
 801ac70:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ac74:	2b00      	cmp	r3, #0
 801ac76:	d006      	beq.n	801ac86 <_ecc_projective_add_point+0xde>
 801ac78:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801ac7c:	2100      	movs	r1, #0
 801ac7e:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801ac82:	f00d fc25 	bl	80284d0 <memset>
      NEW_MP_INT_SIZE(ry, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801ac86:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801ac8a:	f003 ff03 	bl	801ea94 <wolfSSL_Malloc>
 801ac8e:	67f8      	str	r0, [r7, #124]	@ 0x7c
 801ac90:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ac92:	2b00      	cmp	r3, #0
 801ac94:	d005      	beq.n	801aca2 <_ecc_projective_add_point+0xfa>
 801ac96:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801ac9a:	2100      	movs	r1, #0
 801ac9c:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801ac9e:	f00d fc17 	bl	80284d0 <memset>
      NEW_MP_INT_SIZE(rz, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801aca2:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801aca6:	f003 fef5 	bl	801ea94 <wolfSSL_Malloc>
 801acaa:	67b8      	str	r0, [r7, #120]	@ 0x78
 801acac:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801acae:	2b00      	cmp	r3, #0
 801acb0:	d005      	beq.n	801acbe <_ecc_projective_add_point+0x116>
 801acb2:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801acb6:	2100      	movs	r1, #0
 801acb8:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 801acba:	f00d fc09 	bl	80284d0 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (rx == NULL || ry == NULL || rz == NULL) {
 801acbe:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801acc2:	2b00      	cmp	r3, #0
 801acc4:	d005      	beq.n	801acd2 <_ecc_projective_add_point+0x12a>
 801acc6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801acc8:	2b00      	cmp	r3, #0
 801acca:	d002      	beq.n	801acd2 <_ecc_projective_add_point+0x12a>
 801accc:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801acce:	2b00      	cmp	r3, #0
 801acd0:	d12d      	bne.n	801ad2e <_ecc_projective_add_point+0x186>
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801acd2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801acd4:	62bb      	str	r3, [r7, #40]	@ 0x28
 801acd6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801acd8:	2b00      	cmp	r3, #0
 801acda:	d002      	beq.n	801ace2 <_ecc_projective_add_point+0x13a>
 801acdc:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801acde:	f003 fef5 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801ace2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ace4:	627b      	str	r3, [r7, #36]	@ 0x24
 801ace6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ace8:	2b00      	cmp	r3, #0
 801acea:	d002      	beq.n	801acf2 <_ecc_projective_add_point+0x14a>
 801acec:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801acee:	f003 feed 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801acf2:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801acf6:	623b      	str	r3, [r7, #32]
 801acf8:	6a3b      	ldr	r3, [r7, #32]
 801acfa:	2b00      	cmp	r3, #0
 801acfc:	d002      	beq.n	801ad04 <_ecc_projective_add_point+0x15c>
 801acfe:	6a38      	ldr	r0, [r7, #32]
 801ad00:	f003 fee4 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801ad04:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ad08:	61fb      	str	r3, [r7, #28]
 801ad0a:	69fb      	ldr	r3, [r7, #28]
 801ad0c:	2b00      	cmp	r3, #0
 801ad0e:	d002      	beq.n	801ad16 <_ecc_projective_add_point+0x16e>
 801ad10:	69f8      	ldr	r0, [r7, #28]
 801ad12:	f003 fedb 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801ad16:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ad1a:	61bb      	str	r3, [r7, #24]
 801ad1c:	69bb      	ldr	r3, [r7, #24]
 801ad1e:	2b00      	cmp	r3, #0
 801ad20:	d002      	beq.n	801ad28 <_ecc_projective_add_point+0x180>
 801ad22:	69b8      	ldr	r0, [r7, #24]
 801ad24:	f003 fed2 	bl	801eacc <wolfSSL_Free>
         return MEMORY_E;
 801ad28:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801ad2c:	e3c7      	b.n	801b4be <_ecc_projective_add_point+0x916>
      }
   #endif
#endif
   }

   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
 801ad2e:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ad32:	f00b fcb4 	bl	802669e <mp_init>
 801ad36:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801ad3a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ad3e:	2b00      	cmp	r3, #0
 801ad40:	d105      	bne.n	801ad4e <_ecc_projective_add_point+0x1a6>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
 801ad42:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ad46:	f00b fcaa 	bl	802669e <mp_init>
 801ad4a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801ad4e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ad52:	2b00      	cmp	r3, #0
 801ad54:	d02d      	beq.n	801adb2 <_ecc_projective_add_point+0x20a>
      if (R->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801ad56:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ad58:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801ad5a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ad5c:	2b00      	cmp	r3, #0
 801ad5e:	d002      	beq.n	801ad66 <_ecc_projective_add_point+0x1be>
 801ad60:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801ad62:	f003 feb3 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801ad66:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ad68:	63bb      	str	r3, [r7, #56]	@ 0x38
 801ad6a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801ad6c:	2b00      	cmp	r3, #0
 801ad6e:	d002      	beq.n	801ad76 <_ecc_projective_add_point+0x1ce>
 801ad70:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801ad72:	f003 feab 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801ad76:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ad7a:	637b      	str	r3, [r7, #52]	@ 0x34
 801ad7c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ad7e:	2b00      	cmp	r3, #0
 801ad80:	d002      	beq.n	801ad88 <_ecc_projective_add_point+0x1e0>
 801ad82:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801ad84:	f003 fea2 	bl	801eacc <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801ad88:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ad8c:	633b      	str	r3, [r7, #48]	@ 0x30
 801ad8e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ad90:	2b00      	cmp	r3, #0
 801ad92:	d002      	beq.n	801ad9a <_ecc_projective_add_point+0x1f2>
 801ad94:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801ad96:	f003 fe99 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801ad9a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ad9e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801ada0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ada2:	2b00      	cmp	r3, #0
 801ada4:	d002      	beq.n	801adac <_ecc_projective_add_point+0x204>
 801ada6:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801ada8:	f003 fe90 	bl	801eacc <wolfSSL_Free>
      }
      return err;
 801adac:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801adb0:	e385      	b.n	801b4be <_ecc_projective_add_point+0x916>
   }

   /* should we dbl instead? */
   if (err == MP_OKAY) {
 801adb2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801adb6:	2b00      	cmp	r3, #0
 801adb8:	d10b      	bne.n	801add2 <_ecc_projective_add_point+0x22a>
#ifdef ECC_TIMING_RESISTANT
      err = mp_submod_ct(modulus, Q->y, modulus, t1);
 801adba:	68bb      	ldr	r3, [r7, #8]
 801adbc:	6859      	ldr	r1, [r3, #4]
 801adbe:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801adc2:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801adc6:	f8d7 0098 	ldr.w	r0, [r7, #152]	@ 0x98
 801adca:	f00b fd81 	bl	80268d0 <mp_submod_ct>
 801adce:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
#else
      err = mp_sub(modulus, Q->y, t1);
#endif
   }
   if (err == MP_OKAY) {
 801add2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801add6:	2b00      	cmp	r3, #0
 801add8:	d171      	bne.n	801aebe <_ecc_projective_add_point+0x316>
      if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&
 801adda:	68fb      	ldr	r3, [r7, #12]
 801addc:	681a      	ldr	r2, [r3, #0]
 801adde:	68bb      	ldr	r3, [r7, #8]
 801ade0:	681b      	ldr	r3, [r3, #0]
 801ade2:	4619      	mov	r1, r3
 801ade4:	4610      	mov	r0, r2
 801ade6:	f00b fded 	bl	80269c4 <mp_cmp>
 801adea:	4603      	mov	r3, r0
 801adec:	2b00      	cmp	r3, #0
 801adee:	d166      	bne.n	801aebe <_ecc_projective_add_point+0x316>
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 801adf0:	68bb      	ldr	r3, [r7, #8]
 801adf2:	689b      	ldr	r3, [r3, #8]
 801adf4:	4618      	mov	r0, r3
 801adf6:	f00c fb56 	bl	80274a6 <get_digit_count>
 801adfa:	4603      	mov	r3, r0
      if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&
 801adfc:	2b00      	cmp	r3, #0
 801adfe:	d05e      	beq.n	801aebe <_ecc_projective_add_point+0x316>
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 801ae00:	68fb      	ldr	r3, [r7, #12]
 801ae02:	689a      	ldr	r2, [r3, #8]
 801ae04:	68bb      	ldr	r3, [r7, #8]
 801ae06:	689b      	ldr	r3, [r3, #8]
 801ae08:	4619      	mov	r1, r3
 801ae0a:	4610      	mov	r0, r2
 801ae0c:	f00b fdda 	bl	80269c4 <mp_cmp>
 801ae10:	4603      	mov	r3, r0
 801ae12:	2b00      	cmp	r3, #0
 801ae14:	d153      	bne.n	801aebe <_ecc_projective_add_point+0x316>
           (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {
 801ae16:	68fb      	ldr	r3, [r7, #12]
 801ae18:	685a      	ldr	r2, [r3, #4]
 801ae1a:	68bb      	ldr	r3, [r7, #8]
 801ae1c:	685b      	ldr	r3, [r3, #4]
 801ae1e:	4619      	mov	r1, r3
 801ae20:	4610      	mov	r0, r2
 801ae22:	f00b fdcf 	bl	80269c4 <mp_cmp>
 801ae26:	4603      	mov	r3, r0
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
 801ae28:	2b00      	cmp	r3, #0
 801ae2a:	d009      	beq.n	801ae40 <_ecc_projective_add_point+0x298>
           (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {
 801ae2c:	68fb      	ldr	r3, [r7, #12]
 801ae2e:	685b      	ldr	r3, [r3, #4]
 801ae30:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801ae34:	4618      	mov	r0, r3
 801ae36:	f00b fdc5 	bl	80269c4 <mp_cmp>
 801ae3a:	4603      	mov	r3, r0
 801ae3c:	2b00      	cmp	r3, #0
 801ae3e:	d13e      	bne.n	801aebe <_ecc_projective_add_point+0x316>
          mp_clear(t1);
 801ae40:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ae44:	f00b fcb5 	bl	80267b2 <mp_clear>
          mp_clear(t2);
 801ae48:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ae4c:	f00b fcb1 	bl	80267b2 <mp_clear>
         if (R->key == NULL)
      #endif
   #endif
         {
         #ifdef ALT_ECC_SIZE
            FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801ae50:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ae52:	673b      	str	r3, [r7, #112]	@ 0x70
 801ae54:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801ae56:	2b00      	cmp	r3, #0
 801ae58:	d002      	beq.n	801ae60 <_ecc_projective_add_point+0x2b8>
 801ae5a:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ae5c:	f003 fe36 	bl	801eacc <wolfSSL_Free>
            FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801ae60:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801ae62:	66fb      	str	r3, [r7, #108]	@ 0x6c
 801ae64:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801ae66:	2b00      	cmp	r3, #0
 801ae68:	d002      	beq.n	801ae70 <_ecc_projective_add_point+0x2c8>
 801ae6a:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801ae6c:	f003 fe2e 	bl	801eacc <wolfSSL_Free>
            FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801ae70:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801ae74:	66bb      	str	r3, [r7, #104]	@ 0x68
 801ae76:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801ae78:	2b00      	cmp	r3, #0
 801ae7a:	d002      	beq.n	801ae82 <_ecc_projective_add_point+0x2da>
 801ae7c:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 801ae7e:	f003 fe25 	bl	801eacc <wolfSSL_Free>
         #endif
            FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801ae82:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ae86:	667b      	str	r3, [r7, #100]	@ 0x64
 801ae88:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801ae8a:	2b00      	cmp	r3, #0
 801ae8c:	d002      	beq.n	801ae94 <_ecc_projective_add_point+0x2ec>
 801ae8e:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801ae90:	f003 fe1c 	bl	801eacc <wolfSSL_Free>
            FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801ae94:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ae98:	663b      	str	r3, [r7, #96]	@ 0x60
 801ae9a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801ae9c:	2b00      	cmp	r3, #0
 801ae9e:	d002      	beq.n	801aea6 <_ecc_projective_add_point+0x2fe>
 801aea0:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 801aea2:	f003 fe13 	bl	801eacc <wolfSSL_Free>
         }
         return _ecc_projective_dbl_point(P, R, a, modulus, mp);
 801aea6:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801aeaa:	9300      	str	r3, [sp, #0]
 801aeac:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801aeb0:	683a      	ldr	r2, [r7, #0]
 801aeb2:	6879      	ldr	r1, [r7, #4]
 801aeb4:	68f8      	ldr	r0, [r7, #12]
 801aeb6:	f000 fb06 	bl	801b4c6 <_ecc_projective_dbl_point>
 801aeba:	4603      	mov	r3, r0
 801aebc:	e2ff      	b.n	801b4be <_ecc_projective_add_point+0x916>
      }
   }

   if (err != MP_OKAY) {
 801aebe:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801aec2:	2b00      	cmp	r3, #0
 801aec4:	f040 82c1 	bne.w	801b44a <_ecc_projective_add_point+0x8a2>

/* If use ALT_ECC_SIZE we need to use local stack variable since
   ecc_point x,y,z is reduced size */
#ifdef ALT_ECC_SIZE
   /* Use local stack variable */
   x = rx;
 801aec8:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801aecc:	65fb      	str	r3, [r7, #92]	@ 0x5c
   y = ry;
 801aece:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801aed0:	65bb      	str	r3, [r7, #88]	@ 0x58
   z = rz;
 801aed2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801aed4:	657b      	str	r3, [r7, #84]	@ 0x54

   err = INIT_MP_INT_SIZE(x, mp_bitsused(modulus));
 801aed6:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801aed8:	f00b fbe1 	bl	802669e <mp_init>
 801aedc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801aee0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801aee4:	2b00      	cmp	r3, #0
 801aee6:	d104      	bne.n	801aef2 <_ecc_projective_add_point+0x34a>
      err = INIT_MP_INT_SIZE(y, mp_bitsused(modulus));
 801aee8:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801aeea:	f00b fbd8 	bl	802669e <mp_init>
 801aeee:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err == MP_OKAY) {
 801aef2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801aef6:	2b00      	cmp	r3, #0
 801aef8:	d104      	bne.n	801af04 <_ecc_projective_add_point+0x35c>
      err = INIT_MP_INT_SIZE(z, mp_bitsused(modulus));
 801aefa:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801aefc:	f00b fbcf 	bl	802669e <mp_init>
 801af00:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801af04:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af08:	2b00      	cmp	r3, #0
 801af0a:	f040 82a0 	bne.w	801b44e <_ecc_projective_add_point+0x8a6>
   x = R->x;
   y = R->y;
   z = R->z;
#endif

   if (err == MP_OKAY)
 801af0e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af12:	2b00      	cmp	r3, #0
 801af14:	d107      	bne.n	801af26 <_ecc_projective_add_point+0x37e>
       err = mp_copy(P->x, x);
 801af16:	68fb      	ldr	r3, [r7, #12]
 801af18:	681b      	ldr	r3, [r3, #0]
 801af1a:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801af1c:	4618      	mov	r0, r3
 801af1e:	f00b fe0a 	bl	8026b36 <mp_copy>
 801af22:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801af26:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af2a:	2b00      	cmp	r3, #0
 801af2c:	d107      	bne.n	801af3e <_ecc_projective_add_point+0x396>
       err = mp_copy(P->y, y);
 801af2e:	68fb      	ldr	r3, [r7, #12]
 801af30:	685b      	ldr	r3, [r3, #4]
 801af32:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801af34:	4618      	mov	r0, r3
 801af36:	f00b fdfe 	bl	8026b36 <mp_copy>
 801af3a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801af3e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af42:	2b00      	cmp	r3, #0
 801af44:	d107      	bne.n	801af56 <_ecc_projective_add_point+0x3ae>
       err = mp_copy(P->z, z);
 801af46:	68fb      	ldr	r3, [r7, #12]
 801af48:	689b      	ldr	r3, [r3, #8]
 801af4a:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 801af4c:	4618      	mov	r0, r3
 801af4e:	f00b fdf2 	bl	8026b36 <mp_copy>
 801af52:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* if Z is one then these are no-operations */
   if (err == MP_OKAY) {
 801af56:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af5a:	2b00      	cmp	r3, #0
 801af5c:	d16d      	bne.n	801b03a <_ecc_projective_add_point+0x492>
       if (!mp_iszero(Q->z)) {
 801af5e:	68bb      	ldr	r3, [r7, #8]
 801af60:	689b      	ldr	r3, [r3, #8]
 801af62:	4618      	mov	r0, r3
 801af64:	f00b fdf5 	bl	8026b52 <mp_iszero>
 801af68:	4603      	mov	r3, r0
 801af6a:	2b00      	cmp	r3, #0
 801af6c:	d165      	bne.n	801b03a <_ecc_projective_add_point+0x492>
           /* T1 = Z' * Z' */
           err = mp_sqr(Q->z, t1);
 801af6e:	68bb      	ldr	r3, [r7, #8]
 801af70:	689b      	ldr	r3, [r3, #8]
 801af72:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801af76:	4618      	mov	r0, r3
 801af78:	f00c f87c 	bl	8027074 <mp_sqr>
 801af7c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801af80:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801af84:	2b00      	cmp	r3, #0
 801af86:	d109      	bne.n	801af9c <_ecc_projective_add_point+0x3f4>
               err = mp_montgomery_reduce(t1, modulus, mp);
 801af88:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801af8c:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801af90:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801af94:	f00c f83e 	bl	8027014 <mp_montgomery_reduce>
 801af98:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

           /* X = X * T1 */
           if (err == MP_OKAY)
 801af9c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801afa0:	2b00      	cmp	r3, #0
 801afa2:	d107      	bne.n	801afb4 <_ecc_projective_add_point+0x40c>
               err = mp_mul(t1, x, x);
 801afa4:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801afa6:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801afa8:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801afac:	f00b fc6b 	bl	8026886 <mp_mul>
 801afb0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801afb4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801afb8:	2b00      	cmp	r3, #0
 801afba:	d108      	bne.n	801afce <_ecc_projective_add_point+0x426>
               err = mp_montgomery_reduce(x, modulus, mp);
 801afbc:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801afc0:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801afc4:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801afc6:	f00c f825 	bl	8027014 <mp_montgomery_reduce>
 801afca:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

           /* T1 = Z' * T1 */
           if (err == MP_OKAY)
 801afce:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801afd2:	2b00      	cmp	r3, #0
 801afd4:	d10a      	bne.n	801afec <_ecc_projective_add_point+0x444>
               err = mp_mul(Q->z, t1, t1);
 801afd6:	68bb      	ldr	r3, [r7, #8]
 801afd8:	689b      	ldr	r3, [r3, #8]
 801afda:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801afde:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801afe2:	4618      	mov	r0, r3
 801afe4:	f00b fc4f 	bl	8026886 <mp_mul>
 801afe8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801afec:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801aff0:	2b00      	cmp	r3, #0
 801aff2:	d109      	bne.n	801b008 <_ecc_projective_add_point+0x460>
               err = mp_montgomery_reduce(t1, modulus, mp);
 801aff4:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801aff8:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801affc:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b000:	f00c f808 	bl	8027014 <mp_montgomery_reduce>
 801b004:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

           /* Y = Y * T1 */
           if (err == MP_OKAY)
 801b008:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b00c:	2b00      	cmp	r3, #0
 801b00e:	d107      	bne.n	801b020 <_ecc_projective_add_point+0x478>
               err = mp_mul(t1, y, y);
 801b010:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801b012:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801b014:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b018:	f00b fc35 	bl	8026886 <mp_mul>
 801b01c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801b020:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b024:	2b00      	cmp	r3, #0
 801b026:	d108      	bne.n	801b03a <_ecc_projective_add_point+0x492>
               err = mp_montgomery_reduce(y, modulus, mp);
 801b028:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b02c:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b030:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b032:	f00b ffef 	bl	8027014 <mp_montgomery_reduce>
 801b036:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
       }
   }

   /* T1 = Z*Z */
   if (err == MP_OKAY)
 801b03a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b03e:	2b00      	cmp	r3, #0
 801b040:	d106      	bne.n	801b050 <_ecc_projective_add_point+0x4a8>
       err = mp_sqr(z, t1);
 801b042:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b046:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b048:	f00c f814 	bl	8027074 <mp_sqr>
 801b04c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b050:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b054:	2b00      	cmp	r3, #0
 801b056:	d109      	bne.n	801b06c <_ecc_projective_add_point+0x4c4>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b058:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b05c:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b060:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b064:	f00b ffd6 	bl	8027014 <mp_montgomery_reduce>
 801b068:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = X' * T1 */
   if (err == MP_OKAY)
 801b06c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b070:	2b00      	cmp	r3, #0
 801b072:	d10a      	bne.n	801b08a <_ecc_projective_add_point+0x4e2>
       err = mp_mul(Q->x, t1, t2);
 801b074:	68bb      	ldr	r3, [r7, #8]
 801b076:	681b      	ldr	r3, [r3, #0]
 801b078:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b07c:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b080:	4618      	mov	r0, r3
 801b082:	f00b fc00 	bl	8026886 <mp_mul>
 801b086:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b08a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b08e:	2b00      	cmp	r3, #0
 801b090:	d109      	bne.n	801b0a6 <_ecc_projective_add_point+0x4fe>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b092:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b096:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b09a:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b09e:	f00b ffb9 	bl	8027014 <mp_montgomery_reduce>
 801b0a2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = Z * T1 */
   if (err == MP_OKAY)
 801b0a6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b0aa:	2b00      	cmp	r3, #0
 801b0ac:	d108      	bne.n	801b0c0 <_ecc_projective_add_point+0x518>
       err = mp_mul(z, t1, t1);
 801b0ae:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b0b2:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b0b6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b0b8:	f00b fbe5 	bl	8026886 <mp_mul>
 801b0bc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b0c0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b0c4:	2b00      	cmp	r3, #0
 801b0c6:	d109      	bne.n	801b0dc <_ecc_projective_add_point+0x534>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b0c8:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b0cc:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b0d0:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b0d4:	f00b ff9e 	bl	8027014 <mp_montgomery_reduce>
 801b0d8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = Y' * T1 */
   if (err == MP_OKAY)
 801b0dc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b0e0:	2b00      	cmp	r3, #0
 801b0e2:	d10a      	bne.n	801b0fa <_ecc_projective_add_point+0x552>
       err = mp_mul(Q->y, t1, t1);
 801b0e4:	68bb      	ldr	r3, [r7, #8]
 801b0e6:	685b      	ldr	r3, [r3, #4]
 801b0e8:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b0ec:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b0f0:	4618      	mov	r0, r3
 801b0f2:	f00b fbc8 	bl	8026886 <mp_mul>
 801b0f6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b0fa:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b0fe:	2b00      	cmp	r3, #0
 801b100:	d109      	bne.n	801b116 <_ecc_projective_add_point+0x56e>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b102:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b106:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b10a:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b10e:	f00b ff81 	bl	8027014 <mp_montgomery_reduce>
 801b112:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y - T1 */
   if (err == MP_OKAY)
 801b116:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b11a:	2b00      	cmp	r3, #0
 801b11c:	d109      	bne.n	801b132 <_ecc_projective_add_point+0x58a>
       err = mp_submod_ct(y, t1, modulus, y);
 801b11e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801b120:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b124:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b128:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b12a:	f00b fbd1 	bl	80268d0 <mp_submod_ct>
 801b12e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T1 = 2T1 */
   if (err == MP_OKAY)
 801b132:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b136:	2b00      	cmp	r3, #0
 801b138:	d10b      	bne.n	801b152 <_ecc_projective_add_point+0x5aa>
       err = mp_addmod_ct(t1, t1, modulus, t1);
 801b13a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b13e:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b142:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b146:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b14a:	f00b fbd3 	bl	80268f4 <mp_addmod_ct>
 801b14e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T1 = Y + T1 */
   if (err == MP_OKAY)
 801b152:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b156:	2b00      	cmp	r3, #0
 801b158:	d10a      	bne.n	801b170 <_ecc_projective_add_point+0x5c8>
       err = mp_addmod_ct(t1, y, modulus, t1);
 801b15a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b15e:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b162:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801b164:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b168:	f00b fbc4 	bl	80268f4 <mp_addmod_ct>
 801b16c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* X = X - T2 */
   if (err == MP_OKAY)
 801b170:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b174:	2b00      	cmp	r3, #0
 801b176:	d109      	bne.n	801b18c <_ecc_projective_add_point+0x5e4>
       err = mp_submod_ct(x, t2, modulus, x);
 801b178:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801b17a:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b17e:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b182:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b184:	f00b fba4 	bl	80268d0 <mp_submod_ct>
 801b188:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = 2T2 */
   if (err == MP_OKAY)
 801b18c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b190:	2b00      	cmp	r3, #0
 801b192:	d10b      	bne.n	801b1ac <_ecc_projective_add_point+0x604>
       err = mp_addmod_ct(t2, t2, modulus, t2);
 801b194:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b198:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b19c:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b1a0:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b1a4:	f00b fba6 	bl	80268f4 <mp_addmod_ct>
 801b1a8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = X + T2 */
   if (err == MP_OKAY)
 801b1ac:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b1b0:	2b00      	cmp	r3, #0
 801b1b2:	d10a      	bne.n	801b1ca <_ecc_projective_add_point+0x622>
       err = mp_addmod_ct(t2, x, modulus, t2);
 801b1b4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b1b8:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b1bc:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b1be:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b1c2:	f00b fb97 	bl	80268f4 <mp_addmod_ct>
 801b1c6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   if (err == MP_OKAY) {
 801b1ca:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b1ce:	2b00      	cmp	r3, #0
 801b1d0:	d11d      	bne.n	801b20e <_ecc_projective_add_point+0x666>
       if (!mp_iszero(Q->z)) {
 801b1d2:	68bb      	ldr	r3, [r7, #8]
 801b1d4:	689b      	ldr	r3, [r3, #8]
 801b1d6:	4618      	mov	r0, r3
 801b1d8:	f00b fcbb 	bl	8026b52 <mp_iszero>
 801b1dc:	4603      	mov	r3, r0
 801b1de:	2b00      	cmp	r3, #0
 801b1e0:	d115      	bne.n	801b20e <_ecc_projective_add_point+0x666>
           /* Z = Z * Z' */
           err = mp_mul(z, Q->z, z);
 801b1e2:	68bb      	ldr	r3, [r7, #8]
 801b1e4:	689b      	ldr	r3, [r3, #8]
 801b1e6:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801b1e8:	4619      	mov	r1, r3
 801b1ea:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b1ec:	f00b fb4b 	bl	8026886 <mp_mul>
 801b1f0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
           if (err == MP_OKAY)
 801b1f4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b1f8:	2b00      	cmp	r3, #0
 801b1fa:	d108      	bne.n	801b20e <_ecc_projective_add_point+0x666>
               err = mp_montgomery_reduce(z, modulus, mp);
 801b1fc:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b200:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b204:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b206:	f00b ff05 	bl	8027014 <mp_montgomery_reduce>
 801b20a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
       }
   }

   /* Z = Z * X */
   if (err == MP_OKAY)
 801b20e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b212:	2b00      	cmp	r3, #0
 801b214:	d106      	bne.n	801b224 <_ecc_projective_add_point+0x67c>
       err = mp_mul(z, x, z);
 801b216:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801b218:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b21a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b21c:	f00b fb33 	bl	8026886 <mp_mul>
 801b220:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b224:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b228:	2b00      	cmp	r3, #0
 801b22a:	d108      	bne.n	801b23e <_ecc_projective_add_point+0x696>
       err = mp_montgomery_reduce(z, modulus, mp);
 801b22c:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b230:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b234:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b236:	f00b feed 	bl	8027014 <mp_montgomery_reduce>
 801b23a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = T1 * X  */
   if (err == MP_OKAY)
 801b23e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b242:	2b00      	cmp	r3, #0
 801b244:	d108      	bne.n	801b258 <_ecc_projective_add_point+0x6b0>
       err = mp_mul(t1, x, t1);
 801b246:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b24a:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b24c:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b250:	f00b fb19 	bl	8026886 <mp_mul>
 801b254:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b258:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b25c:	2b00      	cmp	r3, #0
 801b25e:	d109      	bne.n	801b274 <_ecc_projective_add_point+0x6cc>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b260:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b264:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b268:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b26c:	f00b fed2 	bl	8027014 <mp_montgomery_reduce>
 801b270:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = X * X */
   if (err == MP_OKAY)
 801b274:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b278:	2b00      	cmp	r3, #0
 801b27a:	d105      	bne.n	801b288 <_ecc_projective_add_point+0x6e0>
       err = mp_sqr(x, x);
 801b27c:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b27e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b280:	f00b fef8 	bl	8027074 <mp_sqr>
 801b284:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b288:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b28c:	2b00      	cmp	r3, #0
 801b28e:	d108      	bne.n	801b2a2 <_ecc_projective_add_point+0x6fa>
       err = mp_montgomery_reduce(x, modulus, mp);
 801b290:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b294:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b298:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b29a:	f00b febb 	bl	8027014 <mp_montgomery_reduce>
 801b29e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = T2 * x */
   if (err == MP_OKAY)
 801b2a2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b2a6:	2b00      	cmp	r3, #0
 801b2a8:	d108      	bne.n	801b2bc <_ecc_projective_add_point+0x714>
       err = mp_mul(t2, x, t2);
 801b2aa:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b2ae:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b2b0:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b2b4:	f00b fae7 	bl	8026886 <mp_mul>
 801b2b8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b2bc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b2c0:	2b00      	cmp	r3, #0
 801b2c2:	d109      	bne.n	801b2d8 <_ecc_projective_add_point+0x730>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b2c4:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b2c8:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b2cc:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b2d0:	f00b fea0 	bl	8027014 <mp_montgomery_reduce>
 801b2d4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = T1 * X  */
   if (err == MP_OKAY)
 801b2d8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b2dc:	2b00      	cmp	r3, #0
 801b2de:	d108      	bne.n	801b2f2 <_ecc_projective_add_point+0x74a>
       err = mp_mul(t1, x, t1);
 801b2e0:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 801b2e4:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b2e6:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b2ea:	f00b facc 	bl	8026886 <mp_mul>
 801b2ee:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b2f2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b2f6:	2b00      	cmp	r3, #0
 801b2f8:	d109      	bne.n	801b30e <_ecc_projective_add_point+0x766>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b2fa:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b2fe:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b302:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b306:	f00b fe85 	bl	8027014 <mp_montgomery_reduce>
 801b30a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = Y*Y */
   if (err == MP_OKAY)
 801b30e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b312:	2b00      	cmp	r3, #0
 801b314:	d105      	bne.n	801b322 <_ecc_projective_add_point+0x77a>
       err = mp_sqr(y, x);
 801b316:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b318:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b31a:	f00b feab 	bl	8027074 <mp_sqr>
 801b31e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b322:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b326:	2b00      	cmp	r3, #0
 801b328:	d108      	bne.n	801b33c <_ecc_projective_add_point+0x794>
       err = mp_montgomery_reduce(x, modulus, mp);
 801b32a:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b32e:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b332:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b334:	f00b fe6e 	bl	8027014 <mp_montgomery_reduce>
 801b338:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = X - T2 */
   if (err == MP_OKAY)
 801b33c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b340:	2b00      	cmp	r3, #0
 801b342:	d109      	bne.n	801b358 <_ecc_projective_add_point+0x7b0>
       err = mp_submod_ct(x, t2, modulus, x);
 801b344:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801b346:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b34a:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b34e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b350:	f00b fabe 	bl	80268d0 <mp_submod_ct>
 801b354:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = T2 - X */
   if (err == MP_OKAY)
 801b358:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b35c:	2b00      	cmp	r3, #0
 801b35e:	d10a      	bne.n	801b376 <_ecc_projective_add_point+0x7ce>
       err = mp_submod_ct(t2, x, modulus, t2);
 801b360:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b364:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b368:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b36a:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b36e:	f00b faaf 	bl	80268d0 <mp_submod_ct>
 801b372:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = T2 - X */
   if (err == MP_OKAY)
 801b376:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b37a:	2b00      	cmp	r3, #0
 801b37c:	d10a      	bne.n	801b394 <_ecc_projective_add_point+0x7ec>
       err = mp_submod_ct(t2, x, modulus, t2);
 801b37e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b382:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b386:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b388:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b38c:	f00b faa0 	bl	80268d0 <mp_submod_ct>
 801b390:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* T2 = T2 * Y */
   if (err == MP_OKAY)
 801b394:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b398:	2b00      	cmp	r3, #0
 801b39a:	d108      	bne.n	801b3ae <_ecc_projective_add_point+0x806>
       err = mp_mul(t2, y, t2);
 801b39c:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b3a0:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801b3a2:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b3a6:	f00b fa6e 	bl	8026886 <mp_mul>
 801b3aa:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b3ae:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3b2:	2b00      	cmp	r3, #0
 801b3b4:	d109      	bne.n	801b3ca <_ecc_projective_add_point+0x822>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b3b6:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801b3ba:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b3be:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b3c2:	f00b fe27 	bl	8027014 <mp_montgomery_reduce>
 801b3c6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = T2 - T1 */
   if (err == MP_OKAY)
 801b3ca:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3ce:	2b00      	cmp	r3, #0
 801b3d0:	d10a      	bne.n	801b3e8 <_ecc_projective_add_point+0x840>
       err = mp_submod_ct(t2, t1, modulus, y);
 801b3d2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801b3d4:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b3d8:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b3dc:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b3e0:	f00b fa76 	bl	80268d0 <mp_submod_ct>
 801b3e4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* Y = Y/2 */
   if (err == MP_OKAY)
 801b3e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b3ec:	2b00      	cmp	r3, #0
 801b3ee:	d107      	bne.n	801b400 <_ecc_projective_add_point+0x858>
       err = mp_div_2_mod_ct(y, modulus, y);
 801b3f0:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801b3f2:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801b3f6:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b3f8:	f00b fe4a 	bl	8027090 <mp_div_2_mod_ct>
 801b3fc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

#ifdef ALT_ECC_SIZE
   if (err == MP_OKAY)
 801b400:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b404:	2b00      	cmp	r3, #0
 801b406:	d107      	bne.n	801b418 <_ecc_projective_add_point+0x870>
       err = mp_copy(x, R->x);
 801b408:	687b      	ldr	r3, [r7, #4]
 801b40a:	681b      	ldr	r3, [r3, #0]
 801b40c:	4619      	mov	r1, r3
 801b40e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801b410:	f00b fb91 	bl	8026b36 <mp_copy>
 801b414:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b418:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b41c:	2b00      	cmp	r3, #0
 801b41e:	d107      	bne.n	801b430 <_ecc_projective_add_point+0x888>
       err = mp_copy(y, R->y);
 801b420:	687b      	ldr	r3, [r7, #4]
 801b422:	685b      	ldr	r3, [r3, #4]
 801b424:	4619      	mov	r1, r3
 801b426:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801b428:	f00b fb85 	bl	8026b36 <mp_copy>
 801b42c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b430:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b434:	2b00      	cmp	r3, #0
 801b436:	d10c      	bne.n	801b452 <_ecc_projective_add_point+0x8aa>
       err = mp_copy(z, R->z);
 801b438:	687b      	ldr	r3, [r7, #4]
 801b43a:	689b      	ldr	r3, [r3, #8]
 801b43c:	4619      	mov	r1, r3
 801b43e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b440:	f00b fb79 	bl	8026b36 <mp_copy>
 801b444:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
 801b448:	e004      	b.n	801b454 <_ecc_projective_add_point+0x8ac>
      goto done;
 801b44a:	bf00      	nop
 801b44c:	e002      	b.n	801b454 <_ecc_projective_add_point+0x8ac>
      goto done;
 801b44e:	bf00      	nop
 801b450:	e000      	b.n	801b454 <_ecc_projective_add_point+0x8ac>
#endif

done:
 801b452:	bf00      	nop

   /* clean up */
   mp_clear(t1);
 801b454:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b458:	f00b f9ab 	bl	80267b2 <mp_clear>
   mp_clear(t2);
 801b45c:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b460:	f00b f9a7 	bl	80267b2 <mp_clear>
   if (R->key == NULL)
#endif
#endif
   {
   #ifdef ALT_ECC_SIZE
      FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b464:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b466:	653b      	str	r3, [r7, #80]	@ 0x50
 801b468:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b46a:	2b00      	cmp	r3, #0
 801b46c:	d002      	beq.n	801b474 <_ecc_projective_add_point+0x8cc>
 801b46e:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801b470:	f003 fb2c 	bl	801eacc <wolfSSL_Free>
      FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b474:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b476:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801b478:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b47a:	2b00      	cmp	r3, #0
 801b47c:	d002      	beq.n	801b484 <_ecc_projective_add_point+0x8dc>
 801b47e:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801b480:	f003 fb24 	bl	801eacc <wolfSSL_Free>
      FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b484:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b488:	64bb      	str	r3, [r7, #72]	@ 0x48
 801b48a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b48c:	2b00      	cmp	r3, #0
 801b48e:	d002      	beq.n	801b496 <_ecc_projective_add_point+0x8ee>
 801b490:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801b492:	f003 fb1b 	bl	801eacc <wolfSSL_Free>
   #endif
      FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b496:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b49a:	647b      	str	r3, [r7, #68]	@ 0x44
 801b49c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b49e:	2b00      	cmp	r3, #0
 801b4a0:	d002      	beq.n	801b4a8 <_ecc_projective_add_point+0x900>
 801b4a2:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801b4a4:	f003 fb12 	bl	801eacc <wolfSSL_Free>
      FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b4a8:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b4ac:	643b      	str	r3, [r7, #64]	@ 0x40
 801b4ae:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b4b0:	2b00      	cmp	r3, #0
 801b4b2:	d002      	beq.n	801b4ba <_ecc_projective_add_point+0x912>
 801b4b4:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801b4b6:	f003 fb09 	bl	801eacc <wolfSSL_Free>
   }

   return err;
 801b4ba:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
                                         R->x, R->y, R->z);
    }
#endif
    return ECC_BAD_ARG_E;
#endif
}
 801b4be:	4618      	mov	r0, r3
 801b4c0:	3790      	adds	r7, #144	@ 0x90
 801b4c2:	46bd      	mov	sp, r7
 801b4c4:	bd80      	pop	{r7, pc}

0801b4c6 <_ecc_projective_dbl_point>:
   mp       The "b" value from montgomery_setup()
   return   MP_OKAY on success
*/
static int _ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,
                                     mp_int* modulus, mp_digit mp)
{
 801b4c6:	b580      	push	{r7, lr}
 801b4c8:	b0a4      	sub	sp, #144	@ 0x90
 801b4ca:	af00      	add	r7, sp, #0
 801b4cc:	60f8      	str	r0, [r7, #12]
 801b4ce:	60b9      	str	r1, [r7, #8]
 801b4d0:	607a      	str	r2, [r7, #4]
 801b4d2:	603b      	str	r3, [r7, #0]
#if !defined(WOLFSSL_SP_MATH)
   DECL_MP_INT_SIZE_DYN(t1, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b4d4:	2300      	movs	r3, #0
 801b4d6:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
   DECL_MP_INT_SIZE_DYN(t2, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b4da:	2300      	movs	r3, #0
 801b4dc:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
#ifdef ALT_ECC_SIZE
   DECL_MP_INT_SIZE_DYN(rx, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b4e0:	2300      	movs	r3, #0
 801b4e2:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
   DECL_MP_INT_SIZE_DYN(ry, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b4e6:	2300      	movs	r3, #0
 801b4e8:	67fb      	str	r3, [r7, #124]	@ 0x7c
   DECL_MP_INT_SIZE_DYN(rz, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801b4ea:	2300      	movs	r3, #0
 801b4ec:	67bb      	str	r3, [r7, #120]	@ 0x78
   }
   else
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#endif
   {
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b4ee:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b4f2:	f003 facf 	bl	801ea94 <wolfSSL_Malloc>
 801b4f6:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
 801b4fa:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b4fe:	2b00      	cmp	r3, #0
 801b500:	d006      	beq.n	801b510 <_ecc_projective_dbl_point+0x4a>
 801b502:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b506:	2100      	movs	r1, #0
 801b508:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b50c:	f00c ffe0 	bl	80284d0 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b510:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b514:	f003 fabe 	bl	801ea94 <wolfSSL_Malloc>
 801b518:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
 801b51c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b520:	2b00      	cmp	r3, #0
 801b522:	d006      	beq.n	801b532 <_ecc_projective_dbl_point+0x6c>
 801b524:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b528:	2100      	movs	r1, #0
 801b52a:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b52e:	f00c ffcf 	bl	80284d0 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (t1 == NULL || t2 == NULL) {
 801b532:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b536:	2b00      	cmp	r3, #0
 801b538:	d003      	beq.n	801b542 <_ecc_projective_dbl_point+0x7c>
 801b53a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b53e:	2b00      	cmp	r3, #0
 801b540:	d114      	bne.n	801b56c <_ecc_projective_dbl_point+0xa6>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b542:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b546:	61bb      	str	r3, [r7, #24]
 801b548:	69bb      	ldr	r3, [r7, #24]
 801b54a:	2b00      	cmp	r3, #0
 801b54c:	d002      	beq.n	801b554 <_ecc_projective_dbl_point+0x8e>
 801b54e:	69b8      	ldr	r0, [r7, #24]
 801b550:	f003 fabc 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b554:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b558:	617b      	str	r3, [r7, #20]
 801b55a:	697b      	ldr	r3, [r7, #20]
 801b55c:	2b00      	cmp	r3, #0
 801b55e:	d002      	beq.n	801b566 <_ecc_projective_dbl_point+0xa0>
 801b560:	6978      	ldr	r0, [r7, #20]
 801b562:	f003 fab3 	bl	801eacc <wolfSSL_Free>
         return MEMORY_E;
 801b566:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801b56a:	e2c1      	b.n	801baf0 <_ecc_projective_dbl_point+0x62a>
      }
   #endif
   #ifdef ALT_ECC_SIZE
      NEW_MP_INT_SIZE(rx, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b56c:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b570:	f003 fa90 	bl	801ea94 <wolfSSL_Malloc>
 801b574:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
 801b578:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b57c:	2b00      	cmp	r3, #0
 801b57e:	d006      	beq.n	801b58e <_ecc_projective_dbl_point+0xc8>
 801b580:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b584:	2100      	movs	r1, #0
 801b586:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801b58a:	f00c ffa1 	bl	80284d0 <memset>
      NEW_MP_INT_SIZE(ry, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b58e:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b592:	f003 fa7f 	bl	801ea94 <wolfSSL_Malloc>
 801b596:	67f8      	str	r0, [r7, #124]	@ 0x7c
 801b598:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b59a:	2b00      	cmp	r3, #0
 801b59c:	d005      	beq.n	801b5aa <_ecc_projective_dbl_point+0xe4>
 801b59e:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b5a2:	2100      	movs	r1, #0
 801b5a4:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801b5a6:	f00c ff93 	bl	80284d0 <memset>
      NEW_MP_INT_SIZE(rz, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801b5aa:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801b5ae:	f003 fa71 	bl	801ea94 <wolfSSL_Malloc>
 801b5b2:	67b8      	str	r0, [r7, #120]	@ 0x78
 801b5b4:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b5b6:	2b00      	cmp	r3, #0
 801b5b8:	d005      	beq.n	801b5c6 <_ecc_projective_dbl_point+0x100>
 801b5ba:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801b5be:	2100      	movs	r1, #0
 801b5c0:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 801b5c2:	f00c ff85 	bl	80284d0 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (rx == NULL || ry == NULL || rz == NULL) {
 801b5c6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b5ca:	2b00      	cmp	r3, #0
 801b5cc:	d005      	beq.n	801b5da <_ecc_projective_dbl_point+0x114>
 801b5ce:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b5d0:	2b00      	cmp	r3, #0
 801b5d2:	d002      	beq.n	801b5da <_ecc_projective_dbl_point+0x114>
 801b5d4:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b5d6:	2b00      	cmp	r3, #0
 801b5d8:	d12d      	bne.n	801b636 <_ecc_projective_dbl_point+0x170>
          FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b5da:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b5dc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801b5de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b5e0:	2b00      	cmp	r3, #0
 801b5e2:	d002      	beq.n	801b5ea <_ecc_projective_dbl_point+0x124>
 801b5e4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801b5e6:	f003 fa71 	bl	801eacc <wolfSSL_Free>
          FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b5ea:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b5ec:	62bb      	str	r3, [r7, #40]	@ 0x28
 801b5ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801b5f0:	2b00      	cmp	r3, #0
 801b5f2:	d002      	beq.n	801b5fa <_ecc_projective_dbl_point+0x134>
 801b5f4:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801b5f6:	f003 fa69 	bl	801eacc <wolfSSL_Free>
          FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b5fa:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b5fe:	627b      	str	r3, [r7, #36]	@ 0x24
 801b600:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801b602:	2b00      	cmp	r3, #0
 801b604:	d002      	beq.n	801b60c <_ecc_projective_dbl_point+0x146>
 801b606:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801b608:	f003 fa60 	bl	801eacc <wolfSSL_Free>
          FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b60c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b610:	623b      	str	r3, [r7, #32]
 801b612:	6a3b      	ldr	r3, [r7, #32]
 801b614:	2b00      	cmp	r3, #0
 801b616:	d002      	beq.n	801b61e <_ecc_projective_dbl_point+0x158>
 801b618:	6a38      	ldr	r0, [r7, #32]
 801b61a:	f003 fa57 	bl	801eacc <wolfSSL_Free>
          FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b61e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b622:	61fb      	str	r3, [r7, #28]
 801b624:	69fb      	ldr	r3, [r7, #28]
 801b626:	2b00      	cmp	r3, #0
 801b628:	d002      	beq.n	801b630 <_ecc_projective_dbl_point+0x16a>
 801b62a:	69f8      	ldr	r0, [r7, #28]
 801b62c:	f003 fa4e 	bl	801eacc <wolfSSL_Free>
          return MEMORY_E;
 801b630:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801b634:	e25c      	b.n	801baf0 <_ecc_projective_dbl_point+0x62a>
      }
   #endif
   #endif
   }

   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
 801b636:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b63a:	f00b f830 	bl	802669e <mp_init>
 801b63e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801b642:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b646:	2b00      	cmp	r3, #0
 801b648:	d105      	bne.n	801b656 <_ecc_projective_dbl_point+0x190>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
 801b64a:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b64e:	f00b f826 	bl	802669e <mp_init>
 801b652:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801b656:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b65a:	2b00      	cmp	r3, #0
 801b65c:	d02d      	beq.n	801b6ba <_ecc_projective_dbl_point+0x1f4>
      if (R->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b65e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b660:	643b      	str	r3, [r7, #64]	@ 0x40
 801b662:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b664:	2b00      	cmp	r3, #0
 801b666:	d002      	beq.n	801b66e <_ecc_projective_dbl_point+0x1a8>
 801b668:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801b66a:	f003 fa2f 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b66e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b670:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801b672:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b674:	2b00      	cmp	r3, #0
 801b676:	d002      	beq.n	801b67e <_ecc_projective_dbl_point+0x1b8>
 801b678:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801b67a:	f003 fa27 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b67e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b682:	63bb      	str	r3, [r7, #56]	@ 0x38
 801b684:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b686:	2b00      	cmp	r3, #0
 801b688:	d002      	beq.n	801b690 <_ecc_projective_dbl_point+0x1ca>
 801b68a:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801b68c:	f003 fa1e 	bl	801eacc <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b690:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b694:	637b      	str	r3, [r7, #52]	@ 0x34
 801b696:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b698:	2b00      	cmp	r3, #0
 801b69a:	d002      	beq.n	801b6a2 <_ecc_projective_dbl_point+0x1dc>
 801b69c:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801b69e:	f003 fa15 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b6a2:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b6a6:	633b      	str	r3, [r7, #48]	@ 0x30
 801b6a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b6aa:	2b00      	cmp	r3, #0
 801b6ac:	d002      	beq.n	801b6b4 <_ecc_projective_dbl_point+0x1ee>
 801b6ae:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801b6b0:	f003 fa0c 	bl	801eacc <wolfSSL_Free>
      }
      return err;
 801b6b4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b6b8:	e21a      	b.n	801baf0 <_ecc_projective_dbl_point+0x62a>

/* If use ALT_ECC_SIZE we need to use local stack variable since
   ecc_point x,y,z is reduced size */
#ifdef ALT_ECC_SIZE
   /* Use local stack variable */
   x = rx;
 801b6ba:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b6be:	677b      	str	r3, [r7, #116]	@ 0x74
   y = ry;
 801b6c0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b6c2:	673b      	str	r3, [r7, #112]	@ 0x70
   z = rz;
 801b6c4:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b6c6:	66fb      	str	r3, [r7, #108]	@ 0x6c

   err = INIT_MP_INT_SIZE(x, mp_bitsused(modulus));
 801b6c8:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b6ca:	f00a ffe8 	bl	802669e <mp_init>
 801b6ce:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY) {
 801b6d2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b6d6:	2b00      	cmp	r3, #0
 801b6d8:	d104      	bne.n	801b6e4 <_ecc_projective_dbl_point+0x21e>
      err = INIT_MP_INT_SIZE(y, mp_bitsused(modulus));
 801b6da:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b6dc:	f00a ffdf 	bl	802669e <mp_init>
 801b6e0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err == MP_OKAY) {
 801b6e4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b6e8:	2b00      	cmp	r3, #0
 801b6ea:	d104      	bne.n	801b6f6 <_ecc_projective_dbl_point+0x230>
      err = INIT_MP_INT_SIZE(z, mp_bitsused(modulus));
 801b6ec:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b6ee:	f00a ffd6 	bl	802669e <mp_init>
 801b6f2:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }
   if (err != MP_OKAY) {
 801b6f6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b6fa:	2b00      	cmp	r3, #0
 801b6fc:	d02d      	beq.n	801b75a <_ecc_projective_dbl_point+0x294>
      if (R->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801b6fe:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b700:	657b      	str	r3, [r7, #84]	@ 0x54
 801b702:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b704:	2b00      	cmp	r3, #0
 801b706:	d002      	beq.n	801b70e <_ecc_projective_dbl_point+0x248>
 801b708:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801b70a:	f003 f9df 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801b70e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801b710:	653b      	str	r3, [r7, #80]	@ 0x50
 801b712:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b714:	2b00      	cmp	r3, #0
 801b716:	d002      	beq.n	801b71e <_ecc_projective_dbl_point+0x258>
 801b718:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801b71a:	f003 f9d7 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801b71e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801b722:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801b724:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b726:	2b00      	cmp	r3, #0
 801b728:	d002      	beq.n	801b730 <_ecc_projective_dbl_point+0x26a>
 801b72a:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801b72c:	f003 f9ce 	bl	801eacc <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801b730:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b734:	64bb      	str	r3, [r7, #72]	@ 0x48
 801b736:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b738:	2b00      	cmp	r3, #0
 801b73a:	d002      	beq.n	801b742 <_ecc_projective_dbl_point+0x27c>
 801b73c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801b73e:	f003 f9c5 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801b742:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b746:	647b      	str	r3, [r7, #68]	@ 0x44
 801b748:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b74a:	2b00      	cmp	r3, #0
 801b74c:	d002      	beq.n	801b754 <_ecc_projective_dbl_point+0x28e>
 801b74e:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801b750:	f003 f9bc 	bl	801eacc <wolfSSL_Free>
      }
      return err;
 801b754:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b758:	e1ca      	b.n	801baf0 <_ecc_projective_dbl_point+0x62a>
   x = R->x;
   y = R->y;
   z = R->z;
#endif

   if (err == MP_OKAY)
 801b75a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b75e:	2b00      	cmp	r3, #0
 801b760:	d107      	bne.n	801b772 <_ecc_projective_dbl_point+0x2ac>
       err = mp_copy(P->x, x);
 801b762:	68fb      	ldr	r3, [r7, #12]
 801b764:	681b      	ldr	r3, [r3, #0]
 801b766:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b768:	4618      	mov	r0, r3
 801b76a:	f00b f9e4 	bl	8026b36 <mp_copy>
 801b76e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b772:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b776:	2b00      	cmp	r3, #0
 801b778:	d107      	bne.n	801b78a <_ecc_projective_dbl_point+0x2c4>
       err = mp_copy(P->y, y);
 801b77a:	68fb      	ldr	r3, [r7, #12]
 801b77c:	685b      	ldr	r3, [r3, #4]
 801b77e:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b780:	4618      	mov	r0, r3
 801b782:	f00b f9d8 	bl	8026b36 <mp_copy>
 801b786:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b78a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b78e:	2b00      	cmp	r3, #0
 801b790:	d107      	bne.n	801b7a2 <_ecc_projective_dbl_point+0x2dc>
       err = mp_copy(P->z, z);
 801b792:	68fb      	ldr	r3, [r7, #12]
 801b794:	689b      	ldr	r3, [r3, #8]
 801b796:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801b798:	4618      	mov	r0, r3
 801b79a:	f00b f9cc 	bl	8026b36 <mp_copy>
 801b79e:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T1 = Z * Z */
   if (err == MP_OKAY)
 801b7a2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b7a6:	2b00      	cmp	r3, #0
 801b7a8:	d106      	bne.n	801b7b8 <_ecc_projective_dbl_point+0x2f2>
       err = mp_sqr(z, t1);
 801b7aa:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b7ae:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b7b0:	f00b fc60 	bl	8027074 <mp_sqr>
 801b7b4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b7b8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b7bc:	2b00      	cmp	r3, #0
 801b7be:	d108      	bne.n	801b7d2 <_ecc_projective_dbl_point+0x30c>
       err = mp_montgomery_reduce(t1, modulus, mp);
 801b7c0:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b7c4:	6839      	ldr	r1, [r7, #0]
 801b7c6:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b7ca:	f00b fc23 	bl	8027014 <mp_montgomery_reduce>
 801b7ce:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Z = Y * Z */
   if (err == MP_OKAY)
 801b7d2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b7d6:	2b00      	cmp	r3, #0
 801b7d8:	d106      	bne.n	801b7e8 <_ecc_projective_dbl_point+0x322>
       err = mp_mul(z, y, z);
 801b7da:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801b7dc:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b7de:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b7e0:	f00b f851 	bl	8026886 <mp_mul>
 801b7e4:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b7e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b7ec:	2b00      	cmp	r3, #0
 801b7ee:	d107      	bne.n	801b800 <_ecc_projective_dbl_point+0x33a>
       err = mp_montgomery_reduce(z, modulus, mp);
 801b7f0:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b7f4:	6839      	ldr	r1, [r7, #0]
 801b7f6:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b7f8:	f00b fc0c 	bl	8027014 <mp_montgomery_reduce>
 801b7fc:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Z = 2Z */
   if (err == MP_OKAY)
 801b800:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b804:	2b00      	cmp	r3, #0
 801b806:	d107      	bne.n	801b818 <_ecc_projective_dbl_point+0x352>
       err = mp_addmod_ct(z, z, modulus, z);
 801b808:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801b80a:	683a      	ldr	r2, [r7, #0]
 801b80c:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801b80e:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801b810:	f00b f870 	bl	80268f4 <mp_addmod_ct>
 801b814:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   {
      /* assumes "a" == 3 */
      (void)a;

      /* T2 = X - T1 */
      if (err == MP_OKAY)
 801b818:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b81c:	2b00      	cmp	r3, #0
 801b81e:	d109      	bne.n	801b834 <_ecc_projective_dbl_point+0x36e>
          err = mp_submod_ct(x, t1, modulus, t2);
 801b820:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801b824:	683a      	ldr	r2, [r7, #0]
 801b826:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801b82a:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b82c:	f00b f850 	bl	80268d0 <mp_submod_ct>
 801b830:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      /* T1 = X + T1 */
      if (err == MP_OKAY)
 801b834:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b838:	2b00      	cmp	r3, #0
 801b83a:	d109      	bne.n	801b850 <_ecc_projective_dbl_point+0x38a>
          err = mp_addmod_ct(t1, x, modulus, t1);
 801b83c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b840:	683a      	ldr	r2, [r7, #0]
 801b842:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b844:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b848:	f00b f854 	bl	80268f4 <mp_addmod_ct>
 801b84c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      /* T2 = T1 * T2 */
      if (err == MP_OKAY)
 801b850:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b854:	2b00      	cmp	r3, #0
 801b856:	d109      	bne.n	801b86c <_ecc_projective_dbl_point+0x3a6>
          err = mp_mul(t1, t2, t2);
 801b858:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b85c:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b860:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b864:	f00b f80f 	bl	8026886 <mp_mul>
 801b868:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      if (err == MP_OKAY)
 801b86c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b870:	2b00      	cmp	r3, #0
 801b872:	d108      	bne.n	801b886 <_ecc_projective_dbl_point+0x3c0>
          err = mp_montgomery_reduce(t2, modulus, mp);
 801b874:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b878:	6839      	ldr	r1, [r7, #0]
 801b87a:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b87e:	f00b fbc9 	bl	8027014 <mp_montgomery_reduce>
 801b882:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

      /* T1 = 2T2 */
      if (err == MP_OKAY)
 801b886:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b88a:	2b00      	cmp	r3, #0
 801b88c:	d10a      	bne.n	801b8a4 <_ecc_projective_dbl_point+0x3de>
          err = mp_addmod_ct(t2, t2, modulus, t1);
 801b88e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b892:	683a      	ldr	r2, [r7, #0]
 801b894:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b898:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b89c:	f00b f82a 	bl	80268f4 <mp_addmod_ct>
 801b8a0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
      /* T1 = T1 + T2 */
      if (err == MP_OKAY)
 801b8a4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8a8:	2b00      	cmp	r3, #0
 801b8aa:	d10a      	bne.n	801b8c2 <_ecc_projective_dbl_point+0x3fc>
          err = mp_addmod_ct(t1, t2, modulus, t1);
 801b8ac:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801b8b0:	683a      	ldr	r2, [r7, #0]
 801b8b2:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b8b6:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b8ba:	f00b f81b 	bl	80268f4 <mp_addmod_ct>
 801b8be:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   }

   /* Y = 2Y */
   if (err == MP_OKAY)
 801b8c2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8c6:	2b00      	cmp	r3, #0
 801b8c8:	d107      	bne.n	801b8da <_ecc_projective_dbl_point+0x414>
       err = mp_addmod_ct(y, y, modulus, y);
 801b8ca:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801b8cc:	683a      	ldr	r2, [r7, #0]
 801b8ce:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b8d0:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b8d2:	f00b f80f 	bl	80268f4 <mp_addmod_ct>
 801b8d6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* Y = Y * Y */
   if (err == MP_OKAY)
 801b8da:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8de:	2b00      	cmp	r3, #0
 801b8e0:	d105      	bne.n	801b8ee <_ecc_projective_dbl_point+0x428>
       err = mp_sqr(y, y);
 801b8e2:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b8e4:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b8e6:	f00b fbc5 	bl	8027074 <mp_sqr>
 801b8ea:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b8ee:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b8f2:	2b00      	cmp	r3, #0
 801b8f4:	d107      	bne.n	801b906 <_ecc_projective_dbl_point+0x440>
       err = mp_montgomery_reduce(y, modulus, mp);
 801b8f6:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b8fa:	6839      	ldr	r1, [r7, #0]
 801b8fc:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b8fe:	f00b fb89 	bl	8027014 <mp_montgomery_reduce>
 801b902:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = Y * Y */
   if (err == MP_OKAY)
 801b906:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b90a:	2b00      	cmp	r3, #0
 801b90c:	d106      	bne.n	801b91c <_ecc_projective_dbl_point+0x456>
       err = mp_sqr(y, t2);
 801b90e:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801b912:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b914:	f00b fbae 	bl	8027074 <mp_sqr>
 801b918:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b91c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b920:	2b00      	cmp	r3, #0
 801b922:	d108      	bne.n	801b936 <_ecc_projective_dbl_point+0x470>
       err = mp_montgomery_reduce(t2, modulus, mp);
 801b924:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b928:	6839      	ldr	r1, [r7, #0]
 801b92a:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b92e:	f00b fb71 	bl	8027014 <mp_montgomery_reduce>
 801b932:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* T2 = T2/2 */
   if (err == MP_OKAY)
 801b936:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b93a:	2b00      	cmp	r3, #0
 801b93c:	d108      	bne.n	801b950 <_ecc_projective_dbl_point+0x48a>
       err = mp_div_2_mod_ct(t2, modulus, t2);
 801b93e:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801b942:	6839      	ldr	r1, [r7, #0]
 801b944:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801b948:	f00b fba2 	bl	8027090 <mp_div_2_mod_ct>
 801b94c:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y * X */
   if (err == MP_OKAY)
 801b950:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b954:	2b00      	cmp	r3, #0
 801b956:	d106      	bne.n	801b966 <_ecc_projective_dbl_point+0x4a0>
       err = mp_mul(y, x, y);
 801b958:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801b95a:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b95c:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b95e:	f00a ff92 	bl	8026886 <mp_mul>
 801b962:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b966:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b96a:	2b00      	cmp	r3, #0
 801b96c:	d107      	bne.n	801b97e <_ecc_projective_dbl_point+0x4b8>
       err = mp_montgomery_reduce(y, modulus, mp);
 801b96e:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b972:	6839      	ldr	r1, [r7, #0]
 801b974:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b976:	f00b fb4d 	bl	8027014 <mp_montgomery_reduce>
 801b97a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = T1 * T1 */
   if (err == MP_OKAY)
 801b97e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b982:	2b00      	cmp	r3, #0
 801b984:	d106      	bne.n	801b994 <_ecc_projective_dbl_point+0x4ce>
       err = mp_sqr(t1, x);
 801b986:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b988:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801b98c:	f00b fb72 	bl	8027074 <mp_sqr>
 801b990:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801b994:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b998:	2b00      	cmp	r3, #0
 801b99a:	d107      	bne.n	801b9ac <_ecc_projective_dbl_point+0x4e6>
       err = mp_montgomery_reduce(x, modulus, mp);
 801b99c:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801b9a0:	6839      	ldr	r1, [r7, #0]
 801b9a2:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b9a4:	f00b fb36 	bl	8027014 <mp_montgomery_reduce>
 801b9a8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* X = X - Y */
   if (err == MP_OKAY)
 801b9ac:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9b0:	2b00      	cmp	r3, #0
 801b9b2:	d107      	bne.n	801b9c4 <_ecc_projective_dbl_point+0x4fe>
       err = mp_submod_ct(x, y, modulus, x);
 801b9b4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801b9b6:	683a      	ldr	r2, [r7, #0]
 801b9b8:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b9ba:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b9bc:	f00a ff88 	bl	80268d0 <mp_submod_ct>
 801b9c0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* X = X - Y */
   if (err == MP_OKAY)
 801b9c4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9c8:	2b00      	cmp	r3, #0
 801b9ca:	d107      	bne.n	801b9dc <_ecc_projective_dbl_point+0x516>
       err = mp_submod_ct(x, y, modulus, x);
 801b9cc:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801b9ce:	683a      	ldr	r2, [r7, #0]
 801b9d0:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801b9d2:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801b9d4:	f00a ff7c 	bl	80268d0 <mp_submod_ct>
 801b9d8:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y - X */
   if (err == MP_OKAY)
 801b9dc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9e0:	2b00      	cmp	r3, #0
 801b9e2:	d107      	bne.n	801b9f4 <_ecc_projective_dbl_point+0x52e>
       err = mp_submod_ct(y, x, modulus, y);
 801b9e4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801b9e6:	683a      	ldr	r2, [r7, #0]
 801b9e8:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 801b9ea:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801b9ec:	f00a ff70 	bl	80268d0 <mp_submod_ct>
 801b9f0:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   /* Y = Y * T1 */
   if (err == MP_OKAY)
 801b9f4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801b9f8:	2b00      	cmp	r3, #0
 801b9fa:	d107      	bne.n	801ba0c <_ecc_projective_dbl_point+0x546>
       err = mp_mul(y, t1, y);
 801b9fc:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801b9fe:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801ba02:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba04:	f00a ff3f 	bl	8026886 <mp_mul>
 801ba08:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801ba0c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba10:	2b00      	cmp	r3, #0
 801ba12:	d107      	bne.n	801ba24 <_ecc_projective_dbl_point+0x55e>
       err = mp_montgomery_reduce(y, modulus, mp);
 801ba14:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801ba18:	6839      	ldr	r1, [r7, #0]
 801ba1a:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba1c:	f00b fafa 	bl	8027014 <mp_montgomery_reduce>
 801ba20:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

   /* Y = Y - T2 */
   if (err == MP_OKAY)
 801ba24:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba28:	2b00      	cmp	r3, #0
 801ba2a:	d108      	bne.n	801ba3e <_ecc_projective_dbl_point+0x578>
       err = mp_submod_ct(y, t2, modulus, y);
 801ba2c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801ba2e:	683a      	ldr	r2, [r7, #0]
 801ba30:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801ba34:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba36:	f00a ff4b 	bl	80268d0 <mp_submod_ct>
 801ba3a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c

#ifdef ALT_ECC_SIZE
   if (err == MP_OKAY)
 801ba3e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba42:	2b00      	cmp	r3, #0
 801ba44:	d107      	bne.n	801ba56 <_ecc_projective_dbl_point+0x590>
       err = mp_copy(x, R->x);
 801ba46:	68bb      	ldr	r3, [r7, #8]
 801ba48:	681b      	ldr	r3, [r3, #0]
 801ba4a:	4619      	mov	r1, r3
 801ba4c:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801ba4e:	f00b f872 	bl	8026b36 <mp_copy>
 801ba52:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801ba56:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba5a:	2b00      	cmp	r3, #0
 801ba5c:	d107      	bne.n	801ba6e <_ecc_projective_dbl_point+0x5a8>
       err = mp_copy(y, R->y);
 801ba5e:	68bb      	ldr	r3, [r7, #8]
 801ba60:	685b      	ldr	r3, [r3, #4]
 801ba62:	4619      	mov	r1, r3
 801ba64:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801ba66:	f00b f866 	bl	8026b36 <mp_copy>
 801ba6a:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
   if (err == MP_OKAY)
 801ba6e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801ba72:	2b00      	cmp	r3, #0
 801ba74:	d107      	bne.n	801ba86 <_ecc_projective_dbl_point+0x5c0>
       err = mp_copy(z, R->z);
 801ba76:	68bb      	ldr	r3, [r7, #8]
 801ba78:	689b      	ldr	r3, [r3, #8]
 801ba7a:	4619      	mov	r1, r3
 801ba7c:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801ba7e:	f00b f85a 	bl	8026b36 <mp_copy>
 801ba82:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
#endif

   /* clean up */
   mp_clear(t1);
 801ba86:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ba8a:	f00a fe92 	bl	80267b2 <mp_clear>
   mp_clear(t2);
 801ba8e:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ba92:	f00a fe8e 	bl	80267b2 <mp_clear>
   if (R->key == NULL)
#endif
#endif
   {
    #ifdef ALT_ECC_SIZE
       FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801ba96:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801ba98:	66bb      	str	r3, [r7, #104]	@ 0x68
 801ba9a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801ba9c:	2b00      	cmp	r3, #0
 801ba9e:	d002      	beq.n	801baa6 <_ecc_projective_dbl_point+0x5e0>
 801baa0:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 801baa2:	f003 f813 	bl	801eacc <wolfSSL_Free>
       FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801baa6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801baa8:	667b      	str	r3, [r7, #100]	@ 0x64
 801baaa:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801baac:	2b00      	cmp	r3, #0
 801baae:	d002      	beq.n	801bab6 <_ecc_projective_dbl_point+0x5f0>
 801bab0:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801bab2:	f003 f80b 	bl	801eacc <wolfSSL_Free>
       FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801bab6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801baba:	663b      	str	r3, [r7, #96]	@ 0x60
 801babc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801babe:	2b00      	cmp	r3, #0
 801bac0:	d002      	beq.n	801bac8 <_ecc_projective_dbl_point+0x602>
 801bac2:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 801bac4:	f003 f802 	bl	801eacc <wolfSSL_Free>
    #endif
       FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bac8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801bacc:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801bace:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801bad0:	2b00      	cmp	r3, #0
 801bad2:	d002      	beq.n	801bada <_ecc_projective_dbl_point+0x614>
 801bad4:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801bad6:	f002 fff9 	bl	801eacc <wolfSSL_Free>
       FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bada:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801bade:	65bb      	str	r3, [r7, #88]	@ 0x58
 801bae0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801bae2:	2b00      	cmp	r3, #0
 801bae4:	d002      	beq.n	801baec <_ecc_projective_dbl_point+0x626>
 801bae6:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801bae8:	f002 fff0 	bl	801eacc <wolfSSL_Free>
    }

   return err;
 801baec:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
        return sp_ecc_proj_dbl_point_521(P->x, P->y, P->z, R->x, R->y, R->z);
    }
#endif
    return ECC_BAD_ARG_E;
#endif
}
 801baf0:	4618      	mov	r0, r3
 801baf2:	3790      	adds	r7, #144	@ 0x90
 801baf4:	46bd      	mov	sp, r7
 801baf6:	bd80      	pop	{r7, pc}

0801baf8 <ecc_map_ex>:
  mp       The "b" value from montgomery_setup()
  ct       Operation should be constant time.
  return   MP_OKAY on success
*/
int ecc_map_ex(ecc_point* P, mp_int* modulus, mp_digit mp, int ct)
{
 801baf8:	b580      	push	{r7, lr}
 801bafa:	b09e      	sub	sp, #120	@ 0x78
 801bafc:	af00      	add	r7, sp, #0
 801bafe:	60f8      	str	r0, [r7, #12]
 801bb00:	60b9      	str	r1, [r7, #8]
 801bb02:	607a      	str	r2, [r7, #4]
 801bb04:	603b      	str	r3, [r7, #0]
   int err = MP_OKAY;
 801bb06:	2300      	movs	r3, #0
 801bb08:	677b      	str	r3, [r7, #116]	@ 0x74
#if !defined(WOLFSSL_SP_MATH)
   DECL_MP_INT_SIZE_DYN(t1, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bb0a:	2300      	movs	r3, #0
 801bb0c:	673b      	str	r3, [r7, #112]	@ 0x70
   DECL_MP_INT_SIZE_DYN(t2, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bb0e:	2300      	movs	r3, #0
 801bb10:	66fb      	str	r3, [r7, #108]	@ 0x6c
#ifdef ALT_ECC_SIZE
   DECL_MP_INT_SIZE_DYN(rx, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bb12:	2300      	movs	r3, #0
 801bb14:	66bb      	str	r3, [r7, #104]	@ 0x68
   DECL_MP_INT_SIZE_DYN(ry, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bb16:	2300      	movs	r3, #0
 801bb18:	667b      	str	r3, [r7, #100]	@ 0x64
   DECL_MP_INT_SIZE_DYN(rz, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801bb1a:	2300      	movs	r3, #0
 801bb1c:	663b      	str	r3, [r7, #96]	@ 0x60
#endif
   mp_int *x, *y, *z;

   (void)ct;

   if (P == NULL || modulus == NULL)
 801bb1e:	68fb      	ldr	r3, [r7, #12]
 801bb20:	2b00      	cmp	r3, #0
 801bb22:	d002      	beq.n	801bb2a <ecc_map_ex+0x32>
 801bb24:	68bb      	ldr	r3, [r7, #8]
 801bb26:	2b00      	cmp	r3, #0
 801bb28:	d102      	bne.n	801bb30 <ecc_map_ex+0x38>
       return ECC_BAD_ARG_E;
 801bb2a:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801bb2e:	e1f7      	b.n	801bf20 <ecc_map_ex+0x428>

   /* special case for point at infinity */
   if (mp_cmp_d(P->z, 0) == MP_EQ) {
 801bb30:	68fb      	ldr	r3, [r7, #12]
 801bb32:	689b      	ldr	r3, [r3, #8]
 801bb34:	2100      	movs	r1, #0
 801bb36:	4618      	mov	r0, r3
 801bb38:	f00a ff52 	bl	80269e0 <mp_cmp_d>
 801bb3c:	4603      	mov	r3, r0
 801bb3e:	2b00      	cmp	r3, #0
 801bb40:	d11c      	bne.n	801bb7c <ecc_map_ex+0x84>
       err = mp_set(P->x, 0);
 801bb42:	68fb      	ldr	r3, [r7, #12]
 801bb44:	681b      	ldr	r3, [r3, #0]
 801bb46:	2100      	movs	r1, #0
 801bb48:	4618      	mov	r0, r3
 801bb4a:	f00b fab1 	bl	80270b0 <mp_set>
 801bb4e:	6778      	str	r0, [r7, #116]	@ 0x74
       if (err == MP_OKAY)
 801bb50:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bb52:	2b00      	cmp	r3, #0
 801bb54:	d106      	bne.n	801bb64 <ecc_map_ex+0x6c>
           err = mp_set(P->y, 0);
 801bb56:	68fb      	ldr	r3, [r7, #12]
 801bb58:	685b      	ldr	r3, [r3, #4]
 801bb5a:	2100      	movs	r1, #0
 801bb5c:	4618      	mov	r0, r3
 801bb5e:	f00b faa7 	bl	80270b0 <mp_set>
 801bb62:	6778      	str	r0, [r7, #116]	@ 0x74
       if (err == MP_OKAY)
 801bb64:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bb66:	2b00      	cmp	r3, #0
 801bb68:	d106      	bne.n	801bb78 <ecc_map_ex+0x80>
           err = mp_set(P->z, 1);
 801bb6a:	68fb      	ldr	r3, [r7, #12]
 801bb6c:	689b      	ldr	r3, [r3, #8]
 801bb6e:	2101      	movs	r1, #1
 801bb70:	4618      	mov	r0, r3
 801bb72:	f00b fa9d 	bl	80270b0 <mp_set>
 801bb76:	6778      	str	r0, [r7, #116]	@ 0x74
       return err;
 801bb78:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bb7a:	e1d1      	b.n	801bf20 <ecc_map_ex+0x428>
   }
   else
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#endif
   {
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bb7c:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bb80:	f002 ff88 	bl	801ea94 <wolfSSL_Malloc>
 801bb84:	6738      	str	r0, [r7, #112]	@ 0x70
 801bb86:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bb88:	2b00      	cmp	r3, #0
 801bb8a:	d005      	beq.n	801bb98 <ecc_map_ex+0xa0>
 801bb8c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bb90:	2100      	movs	r1, #0
 801bb92:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bb94:	f00c fc9c 	bl	80284d0 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bb98:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bb9c:	f002 ff7a 	bl	801ea94 <wolfSSL_Malloc>
 801bba0:	66f8      	str	r0, [r7, #108]	@ 0x6c
 801bba2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bba4:	2b00      	cmp	r3, #0
 801bba6:	d005      	beq.n	801bbb4 <ecc_map_ex+0xbc>
 801bba8:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bbac:	2100      	movs	r1, #0
 801bbae:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801bbb0:	f00c fc8e 	bl	80284d0 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (t1 == NULL || t2 == NULL) {
 801bbb4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bbb6:	2b00      	cmp	r3, #0
 801bbb8:	d002      	beq.n	801bbc0 <ecc_map_ex+0xc8>
 801bbba:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bbbc:	2b00      	cmp	r3, #0
 801bbbe:	d112      	bne.n	801bbe6 <ecc_map_ex+0xee>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bbc0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bbc2:	617b      	str	r3, [r7, #20]
 801bbc4:	697b      	ldr	r3, [r7, #20]
 801bbc6:	2b00      	cmp	r3, #0
 801bbc8:	d002      	beq.n	801bbd0 <ecc_map_ex+0xd8>
 801bbca:	6978      	ldr	r0, [r7, #20]
 801bbcc:	f002 ff7e 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bbd0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bbd2:	613b      	str	r3, [r7, #16]
 801bbd4:	693b      	ldr	r3, [r7, #16]
 801bbd6:	2b00      	cmp	r3, #0
 801bbd8:	d002      	beq.n	801bbe0 <ecc_map_ex+0xe8>
 801bbda:	6938      	ldr	r0, [r7, #16]
 801bbdc:	f002 ff76 	bl	801eacc <wolfSSL_Free>
         return MEMORY_E;
 801bbe0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801bbe4:	e19c      	b.n	801bf20 <ecc_map_ex+0x428>
      }
   #endif
   #ifdef ALT_ECC_SIZE
      NEW_MP_INT_SIZE(rx, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bbe6:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bbea:	f002 ff53 	bl	801ea94 <wolfSSL_Malloc>
 801bbee:	66b8      	str	r0, [r7, #104]	@ 0x68
 801bbf0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bbf2:	2b00      	cmp	r3, #0
 801bbf4:	d005      	beq.n	801bc02 <ecc_map_ex+0x10a>
 801bbf6:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bbfa:	2100      	movs	r1, #0
 801bbfc:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 801bbfe:	f00c fc67 	bl	80284d0 <memset>
      NEW_MP_INT_SIZE(ry, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bc02:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bc06:	f002 ff45 	bl	801ea94 <wolfSSL_Malloc>
 801bc0a:	6678      	str	r0, [r7, #100]	@ 0x64
 801bc0c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bc0e:	2b00      	cmp	r3, #0
 801bc10:	d005      	beq.n	801bc1e <ecc_map_ex+0x126>
 801bc12:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bc16:	2100      	movs	r1, #0
 801bc18:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801bc1a:	f00c fc59 	bl	80284d0 <memset>
      NEW_MP_INT_SIZE(rz, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801bc1e:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801bc22:	f002 ff37 	bl	801ea94 <wolfSSL_Malloc>
 801bc26:	6638      	str	r0, [r7, #96]	@ 0x60
 801bc28:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bc2a:	2b00      	cmp	r3, #0
 801bc2c:	d005      	beq.n	801bc3a <ecc_map_ex+0x142>
 801bc2e:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801bc32:	2100      	movs	r1, #0
 801bc34:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 801bc36:	f00c fc4b 	bl	80284d0 <memset>
   #ifdef MP_INT_SIZE_CHECK_NULL
      if (rx == NULL || ry == NULL || rz == NULL) {
 801bc3a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bc3c:	2b00      	cmp	r3, #0
 801bc3e:	d005      	beq.n	801bc4c <ecc_map_ex+0x154>
 801bc40:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bc42:	2b00      	cmp	r3, #0
 801bc44:	d002      	beq.n	801bc4c <ecc_map_ex+0x154>
 801bc46:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bc48:	2b00      	cmp	r3, #0
 801bc4a:	d12a      	bne.n	801bca2 <ecc_map_ex+0x1aa>
          FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801bc4c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bc4e:	62bb      	str	r3, [r7, #40]	@ 0x28
 801bc50:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801bc52:	2b00      	cmp	r3, #0
 801bc54:	d002      	beq.n	801bc5c <ecc_map_ex+0x164>
 801bc56:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bc58:	f002 ff38 	bl	801eacc <wolfSSL_Free>
          FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801bc5c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bc5e:	627b      	str	r3, [r7, #36]	@ 0x24
 801bc60:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801bc62:	2b00      	cmp	r3, #0
 801bc64:	d002      	beq.n	801bc6c <ecc_map_ex+0x174>
 801bc66:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801bc68:	f002 ff30 	bl	801eacc <wolfSSL_Free>
          FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801bc6c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bc6e:	623b      	str	r3, [r7, #32]
 801bc70:	6a3b      	ldr	r3, [r7, #32]
 801bc72:	2b00      	cmp	r3, #0
 801bc74:	d002      	beq.n	801bc7c <ecc_map_ex+0x184>
 801bc76:	6a38      	ldr	r0, [r7, #32]
 801bc78:	f002 ff28 	bl	801eacc <wolfSSL_Free>
          FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bc7c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bc7e:	61fb      	str	r3, [r7, #28]
 801bc80:	69fb      	ldr	r3, [r7, #28]
 801bc82:	2b00      	cmp	r3, #0
 801bc84:	d002      	beq.n	801bc8c <ecc_map_ex+0x194>
 801bc86:	69f8      	ldr	r0, [r7, #28]
 801bc88:	f002 ff20 	bl	801eacc <wolfSSL_Free>
          FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bc8c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bc8e:	61bb      	str	r3, [r7, #24]
 801bc90:	69bb      	ldr	r3, [r7, #24]
 801bc92:	2b00      	cmp	r3, #0
 801bc94:	d002      	beq.n	801bc9c <ecc_map_ex+0x1a4>
 801bc96:	69b8      	ldr	r0, [r7, #24]
 801bc98:	f002 ff18 	bl	801eacc <wolfSSL_Free>
          return MEMORY_E;
 801bc9c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801bca0:	e13e      	b.n	801bf20 <ecc_map_ex+0x428>
      }
   #endif
   #endif
   }

   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
 801bca2:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bca4:	f00a fcfb 	bl	802669e <mp_init>
 801bca8:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY) {
 801bcaa:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bcac:	2b00      	cmp	r3, #0
 801bcae:	d103      	bne.n	801bcb8 <ecc_map_ex+0x1c0>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
 801bcb0:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801bcb2:	f00a fcf4 	bl	802669e <mp_init>
 801bcb6:	6778      	str	r0, [r7, #116]	@ 0x74
   }
   if (err != MP_OKAY) {
 801bcb8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bcba:	2b00      	cmp	r3, #0
 801bcbc:	d02a      	beq.n	801bd14 <ecc_map_ex+0x21c>
      if (P->key == NULL)
   #endif
#endif
      {
      #ifdef ALT_ECC_SIZE
         FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801bcbe:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bcc0:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801bcc2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801bcc4:	2b00      	cmp	r3, #0
 801bcc6:	d002      	beq.n	801bcce <ecc_map_ex+0x1d6>
 801bcc8:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801bcca:	f002 feff 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801bcce:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bcd0:	63bb      	str	r3, [r7, #56]	@ 0x38
 801bcd2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801bcd4:	2b00      	cmp	r3, #0
 801bcd6:	d002      	beq.n	801bcde <ecc_map_ex+0x1e6>
 801bcd8:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801bcda:	f002 fef7 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801bcde:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bce0:	637b      	str	r3, [r7, #52]	@ 0x34
 801bce2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801bce4:	2b00      	cmp	r3, #0
 801bce6:	d002      	beq.n	801bcee <ecc_map_ex+0x1f6>
 801bce8:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801bcea:	f002 feef 	bl	801eacc <wolfSSL_Free>
      #endif
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801bcee:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bcf0:	633b      	str	r3, [r7, #48]	@ 0x30
 801bcf2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801bcf4:	2b00      	cmp	r3, #0
 801bcf6:	d002      	beq.n	801bcfe <ecc_map_ex+0x206>
 801bcf8:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801bcfa:	f002 fee7 	bl	801eacc <wolfSSL_Free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bcfe:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bd00:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801bd02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bd04:	2b00      	cmp	r3, #0
 801bd06:	d002      	beq.n	801bd0e <ecc_map_ex+0x216>
 801bd08:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801bd0a:	f002 fedf 	bl	801eacc <wolfSSL_Free>
      }
      return MEMORY_E;
 801bd0e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801bd12:	e105      	b.n	801bf20 <ecc_map_ex+0x428>
   }

#ifdef ALT_ECC_SIZE
   /* Use local stack variable */
   x = rx;
 801bd14:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bd16:	65fb      	str	r3, [r7, #92]	@ 0x5c
   y = ry;
 801bd18:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bd1a:	65bb      	str	r3, [r7, #88]	@ 0x58
   z = rz;
 801bd1c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bd1e:	657b      	str	r3, [r7, #84]	@ 0x54

   err = INIT_MP_INT_SIZE(x, mp_bitsused(modulus));
 801bd20:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801bd22:	f00a fcbc 	bl	802669e <mp_init>
 801bd26:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY) {
 801bd28:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd2a:	2b00      	cmp	r3, #0
 801bd2c:	d103      	bne.n	801bd36 <ecc_map_ex+0x23e>
      err = INIT_MP_INT_SIZE(y, mp_bitsused(modulus));
 801bd2e:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801bd30:	f00a fcb5 	bl	802669e <mp_init>
 801bd34:	6778      	str	r0, [r7, #116]	@ 0x74
   }
   if (err == MP_OKAY) {
 801bd36:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd38:	2b00      	cmp	r3, #0
 801bd3a:	d103      	bne.n	801bd44 <ecc_map_ex+0x24c>
      err = INIT_MP_INT_SIZE(z, mp_bitsused(modulus));
 801bd3c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bd3e:	f00a fcae 	bl	802669e <mp_init>
 801bd42:	6778      	str	r0, [r7, #116]	@ 0x74
   }
   if (err != MP_OKAY) {
 801bd44:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd46:	2b00      	cmp	r3, #0
 801bd48:	f040 80b6 	bne.w	801beb8 <ecc_map_ex+0x3c0>
      goto done;
   }

   if (err == MP_OKAY)
 801bd4c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd4e:	2b00      	cmp	r3, #0
 801bd50:	d106      	bne.n	801bd60 <ecc_map_ex+0x268>
      err = mp_copy(P->x, x);
 801bd52:	68fb      	ldr	r3, [r7, #12]
 801bd54:	681b      	ldr	r3, [r3, #0]
 801bd56:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801bd58:	4618      	mov	r0, r3
 801bd5a:	f00a feec 	bl	8026b36 <mp_copy>
 801bd5e:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bd60:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd62:	2b00      	cmp	r3, #0
 801bd64:	d106      	bne.n	801bd74 <ecc_map_ex+0x27c>
      err = mp_copy(P->y, y);
 801bd66:	68fb      	ldr	r3, [r7, #12]
 801bd68:	685b      	ldr	r3, [r3, #4]
 801bd6a:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 801bd6c:	4618      	mov	r0, r3
 801bd6e:	f00a fee2 	bl	8026b36 <mp_copy>
 801bd72:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bd74:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd76:	2b00      	cmp	r3, #0
 801bd78:	d106      	bne.n	801bd88 <ecc_map_ex+0x290>
      err = mp_copy(P->z, z);
 801bd7a:	68fb      	ldr	r3, [r7, #12]
 801bd7c:	689b      	ldr	r3, [r3, #8]
 801bd7e:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 801bd80:	4618      	mov	r0, r3
 801bd82:	f00a fed8 	bl	8026b36 <mp_copy>
 801bd86:	6778      	str	r0, [r7, #116]	@ 0x74

   if (err != MP_OKAY) {
 801bd88:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd8a:	2b00      	cmp	r3, #0
 801bd8c:	f040 8096 	bne.w	801bebc <ecc_map_ex+0x3c4>
   y = P->y;
   z = P->z;
#endif

   /* get 1/z */
   if (err == MP_OKAY) {
 801bd90:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bd92:	2b00      	cmp	r3, #0
 801bd94:	d122      	bne.n	801bddc <ecc_map_ex+0x2e4>
#if defined(ECC_TIMING_RESISTANT) && (defined(USE_FAST_MATH) || \
                       defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_SP_MATH_ALL))
       if (ct) {
 801bd96:	683b      	ldr	r3, [r7, #0]
 801bd98:	2b00      	cmp	r3, #0
 801bd9a:	d010      	beq.n	801bdbe <ecc_map_ex+0x2c6>
           err = mp_invmod_mont_ct(z, modulus, t1, mp);
 801bd9c:	687b      	ldr	r3, [r7, #4]
 801bd9e:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801bda0:	68b9      	ldr	r1, [r7, #8]
 801bda2:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bda4:	f00a fdd8 	bl	8026958 <mp_invmod_mont_ct>
 801bda8:	6778      	str	r0, [r7, #116]	@ 0x74
           if (err == MP_OKAY)
 801bdaa:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bdac:	2b00      	cmp	r3, #0
 801bdae:	d115      	bne.n	801bddc <ecc_map_ex+0x2e4>
               err = mp_montgomery_reduce(t1, modulus, mp);
 801bdb0:	687a      	ldr	r2, [r7, #4]
 801bdb2:	68b9      	ldr	r1, [r7, #8]
 801bdb4:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bdb6:	f00b f92d 	bl	8027014 <mp_montgomery_reduce>
 801bdba:	6778      	str	r0, [r7, #116]	@ 0x74
 801bdbc:	e00e      	b.n	801bddc <ecc_map_ex+0x2e4>
       }
       else
#endif
       {
           /* first map z back to normal */
           err = mp_montgomery_reduce(z, modulus, mp);
 801bdbe:	687a      	ldr	r2, [r7, #4]
 801bdc0:	68b9      	ldr	r1, [r7, #8]
 801bdc2:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bdc4:	f00b f926 	bl	8027014 <mp_montgomery_reduce>
 801bdc8:	6778      	str	r0, [r7, #116]	@ 0x74
           if (err == MP_OKAY)
 801bdca:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bdcc:	2b00      	cmp	r3, #0
 801bdce:	d105      	bne.n	801bddc <ecc_map_ex+0x2e4>
               err = mp_invmod(z, modulus, t1);
 801bdd0:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801bdd2:	68b9      	ldr	r1, [r7, #8]
 801bdd4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801bdd6:	f00a fdaf 	bl	8026938 <mp_invmod>
 801bdda:	6778      	str	r0, [r7, #116]	@ 0x74
       }
   }

   /* get 1/z^2 and 1/z^3 */
   if (err == MP_OKAY)
 801bddc:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bdde:	2b00      	cmp	r3, #0
 801bde0:	d104      	bne.n	801bdec <ecc_map_ex+0x2f4>
       err = mp_sqr(t1, t2);
 801bde2:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801bde4:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bde6:	f00b f945 	bl	8027074 <mp_sqr>
 801bdea:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bdec:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bdee:	2b00      	cmp	r3, #0
 801bdf0:	d105      	bne.n	801bdfe <ecc_map_ex+0x306>
       err = mp_mod(t2, modulus, t2);
 801bdf2:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801bdf4:	68b9      	ldr	r1, [r7, #8]
 801bdf6:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801bdf8:	f00a fd8e 	bl	8026918 <mp_mod>
 801bdfc:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bdfe:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be00:	2b00      	cmp	r3, #0
 801be02:	d105      	bne.n	801be10 <ecc_map_ex+0x318>
       err = mp_mul(t1, t2, t1);
 801be04:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801be06:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801be08:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801be0a:	f00a fd3c 	bl	8026886 <mp_mul>
 801be0e:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be10:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be12:	2b00      	cmp	r3, #0
 801be14:	d105      	bne.n	801be22 <ecc_map_ex+0x32a>
       err = mp_mod(t1, modulus, t1);
 801be16:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801be18:	68b9      	ldr	r1, [r7, #8]
 801be1a:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801be1c:	f00a fd7c 	bl	8026918 <mp_mod>
 801be20:	6778      	str	r0, [r7, #116]	@ 0x74

   /* multiply against x/y */
   if (err == MP_OKAY)
 801be22:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be24:	2b00      	cmp	r3, #0
 801be26:	d105      	bne.n	801be34 <ecc_map_ex+0x33c>
       err = mp_mul(x, t2, x);
 801be28:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801be2a:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801be2c:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801be2e:	f00a fd2a 	bl	8026886 <mp_mul>
 801be32:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be34:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be36:	2b00      	cmp	r3, #0
 801be38:	d105      	bne.n	801be46 <ecc_map_ex+0x34e>
       err = mp_montgomery_reduce(x, modulus, mp);
 801be3a:	687a      	ldr	r2, [r7, #4]
 801be3c:	68b9      	ldr	r1, [r7, #8]
 801be3e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801be40:	f00b f8e8 	bl	8027014 <mp_montgomery_reduce>
 801be44:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be46:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be48:	2b00      	cmp	r3, #0
 801be4a:	d105      	bne.n	801be58 <ecc_map_ex+0x360>
       err = mp_mul(y, t1, y);
 801be4c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801be4e:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 801be50:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801be52:	f00a fd18 	bl	8026886 <mp_mul>
 801be56:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be58:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be5a:	2b00      	cmp	r3, #0
 801be5c:	d105      	bne.n	801be6a <ecc_map_ex+0x372>
       err = mp_montgomery_reduce(y, modulus, mp);
 801be5e:	687a      	ldr	r2, [r7, #4]
 801be60:	68b9      	ldr	r1, [r7, #8]
 801be62:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801be64:	f00b f8d6 	bl	8027014 <mp_montgomery_reduce>
 801be68:	6778      	str	r0, [r7, #116]	@ 0x74

   if (err == MP_OKAY)
 801be6a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be6c:	2b00      	cmp	r3, #0
 801be6e:	d104      	bne.n	801be7a <ecc_map_ex+0x382>
       err = mp_set(z, 1);
 801be70:	2101      	movs	r1, #1
 801be72:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801be74:	f00b f91c 	bl	80270b0 <mp_set>
 801be78:	6778      	str	r0, [r7, #116]	@ 0x74

#ifdef ALT_ECC_SIZE
   /* return result */
   if (err == MP_OKAY)
 801be7a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be7c:	2b00      	cmp	r3, #0
 801be7e:	d106      	bne.n	801be8e <ecc_map_ex+0x396>
      err = mp_copy(x, P->x);
 801be80:	68fb      	ldr	r3, [r7, #12]
 801be82:	681b      	ldr	r3, [r3, #0]
 801be84:	4619      	mov	r1, r3
 801be86:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801be88:	f00a fe55 	bl	8026b36 <mp_copy>
 801be8c:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801be8e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801be90:	2b00      	cmp	r3, #0
 801be92:	d106      	bne.n	801bea2 <ecc_map_ex+0x3aa>
      err = mp_copy(y, P->y);
 801be94:	68fb      	ldr	r3, [r7, #12]
 801be96:	685b      	ldr	r3, [r3, #4]
 801be98:	4619      	mov	r1, r3
 801be9a:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801be9c:	f00a fe4b 	bl	8026b36 <mp_copy>
 801bea0:	6778      	str	r0, [r7, #116]	@ 0x74
   if (err == MP_OKAY)
 801bea2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801bea4:	2b00      	cmp	r3, #0
 801bea6:	d10b      	bne.n	801bec0 <ecc_map_ex+0x3c8>
      err = mp_copy(z, P->z);
 801bea8:	68fb      	ldr	r3, [r7, #12]
 801beaa:	689b      	ldr	r3, [r3, #8]
 801beac:	4619      	mov	r1, r3
 801beae:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801beb0:	f00a fe41 	bl	8026b36 <mp_copy>
 801beb4:	6778      	str	r0, [r7, #116]	@ 0x74
 801beb6:	e004      	b.n	801bec2 <ecc_map_ex+0x3ca>
      goto done;
 801beb8:	bf00      	nop
 801beba:	e002      	b.n	801bec2 <ecc_map_ex+0x3ca>
      goto done;
 801bebc:	bf00      	nop
 801bebe:	e000      	b.n	801bec2 <ecc_map_ex+0x3ca>

done:
 801bec0:	bf00      	nop
#endif

   /* clean up */
   mp_clear(t1);
 801bec2:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801bec4:	f00a fc75 	bl	80267b2 <mp_clear>
   mp_clear(t2);
 801bec8:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801beca:	f00a fc72 	bl	80267b2 <mp_clear>
   if (P->key == NULL)
#endif
#endif
   {
   #ifdef ALT_ECC_SIZE
      FREE_MP_INT_SIZE(rz, NULL, DYNAMIC_TYPE_ECC);
 801bece:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801bed0:	653b      	str	r3, [r7, #80]	@ 0x50
 801bed2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801bed4:	2b00      	cmp	r3, #0
 801bed6:	d002      	beq.n	801bede <ecc_map_ex+0x3e6>
 801bed8:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801beda:	f002 fdf7 	bl	801eacc <wolfSSL_Free>
      FREE_MP_INT_SIZE(ry, NULL, DYNAMIC_TYPE_ECC);
 801bede:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801bee0:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801bee2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801bee4:	2b00      	cmp	r3, #0
 801bee6:	d002      	beq.n	801beee <ecc_map_ex+0x3f6>
 801bee8:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801beea:	f002 fdef 	bl	801eacc <wolfSSL_Free>
      FREE_MP_INT_SIZE(rx, NULL, DYNAMIC_TYPE_ECC);
 801beee:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801bef0:	64bb      	str	r3, [r7, #72]	@ 0x48
 801bef2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801bef4:	2b00      	cmp	r3, #0
 801bef6:	d002      	beq.n	801befe <ecc_map_ex+0x406>
 801bef8:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801befa:	f002 fde7 	bl	801eacc <wolfSSL_Free>
   #endif
      FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 801befe:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801bf00:	647b      	str	r3, [r7, #68]	@ 0x44
 801bf02:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801bf04:	2b00      	cmp	r3, #0
 801bf06:	d002      	beq.n	801bf0e <ecc_map_ex+0x416>
 801bf08:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801bf0a:	f002 fddf 	bl	801eacc <wolfSSL_Free>
      FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 801bf0e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801bf10:	643b      	str	r3, [r7, #64]	@ 0x40
 801bf12:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801bf14:	2b00      	cmp	r3, #0
 801bf16:	d002      	beq.n	801bf1e <ecc_map_ex+0x426>
 801bf18:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801bf1a:	f002 fdd7 	bl	801eacc <wolfSSL_Free>
   }

   return err;
 801bf1e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
#endif

   WOLFSSL_LEAVE("ecc_map_ex (SP Math)", err);
   return err;
#endif /* WOLFSSL_SP_MATH */
}
 801bf20:	4618      	mov	r0, r3
 801bf22:	3778      	adds	r7, #120	@ 0x78
 801bf24:	46bd      	mov	sp, r7
 801bf26:	bd80      	pop	{r7, pc}

0801bf28 <ecc_map>:
#endif /* !FREESCALE_LTC_ECC && !WOLFSSL_STM32_PKA */

int ecc_map(ecc_point* P, mp_int* modulus, mp_digit mp)
{
 801bf28:	b580      	push	{r7, lr}
 801bf2a:	b084      	sub	sp, #16
 801bf2c:	af00      	add	r7, sp, #0
 801bf2e:	60f8      	str	r0, [r7, #12]
 801bf30:	60b9      	str	r1, [r7, #8]
 801bf32:	607a      	str	r2, [r7, #4]
    return ecc_map_ex(P, modulus, mp, 0);
 801bf34:	2300      	movs	r3, #0
 801bf36:	687a      	ldr	r2, [r7, #4]
 801bf38:	68b9      	ldr	r1, [r7, #8]
 801bf3a:	68f8      	ldr	r0, [r7, #12]
 801bf3c:	f7ff fddc 	bl	801baf8 <ecc_map_ex>
 801bf40:	4603      	mov	r3, r0
}
 801bf42:	4618      	mov	r0, r3
 801bf44:	3710      	adds	r7, #16
 801bf46:	46bd      	mov	sp, r7
 801bf48:	bd80      	pop	{r7, pc}

0801bf4a <wc_ecc_gen_z>:

#else

static int wc_ecc_gen_z(WC_RNG* rng, int size, ecc_point* p, mp_int* modulus,
    mp_digit mp, mp_int* tx, mp_int* ty, mp_int* mu)
{
 801bf4a:	b580      	push	{r7, lr}
 801bf4c:	b086      	sub	sp, #24
 801bf4e:	af00      	add	r7, sp, #0
 801bf50:	60f8      	str	r0, [r7, #12]
 801bf52:	60b9      	str	r1, [r7, #8]
 801bf54:	607a      	str	r2, [r7, #4]
 801bf56:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801bf58:	2300      	movs	r3, #0
 801bf5a:	617b      	str	r3, [r7, #20]

    err = mp_montgomery_calc_normalization(mu, modulus);
 801bf5c:	6839      	ldr	r1, [r7, #0]
 801bf5e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801bf60:	f00a fe2d 	bl	8026bbe <mp_montgomery_calc_normalization>
 801bf64:	6178      	str	r0, [r7, #20]
    /* Generate random value to multiply into p->z. */
    if (err == MP_OKAY)
 801bf66:	697b      	ldr	r3, [r7, #20]
 801bf68:	2b00      	cmp	r3, #0
 801bf6a:	d106      	bne.n	801bf7a <wc_ecc_gen_z+0x30>
        err = wc_ecc_gen_k(rng, size, ty, modulus);
 801bf6c:	683b      	ldr	r3, [r7, #0]
 801bf6e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801bf70:	68b9      	ldr	r1, [r7, #8]
 801bf72:	68f8      	ldr	r0, [r7, #12]
 801bf74:	f000 fdf8 	bl	801cb68 <wc_ecc_gen_k>
 801bf78:	6178      	str	r0, [r7, #20]
    /* Convert to montogmery form. */
    if (err == MP_OKAY)
 801bf7a:	697b      	ldr	r3, [r7, #20]
 801bf7c:	2b00      	cmp	r3, #0
 801bf7e:	d106      	bne.n	801bf8e <wc_ecc_gen_z+0x44>
        err = mp_mulmod(ty, mu, modulus, ty);
 801bf80:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801bf82:	683a      	ldr	r2, [r7, #0]
 801bf84:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801bf86:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bf88:	f00a fc8d 	bl	80268a6 <mp_mulmod>
 801bf8c:	6178      	str	r0, [r7, #20]
    /* Multiply random value into p->z. */
    if (err == MP_OKAY)
 801bf8e:	697b      	ldr	r3, [r7, #20]
 801bf90:	2b00      	cmp	r3, #0
 801bf92:	d108      	bne.n	801bfa6 <wc_ecc_gen_z+0x5c>
        err = mp_mul(p->z, ty, p->z);
 801bf94:	687b      	ldr	r3, [r7, #4]
 801bf96:	6898      	ldr	r0, [r3, #8]
 801bf98:	687b      	ldr	r3, [r7, #4]
 801bf9a:	689b      	ldr	r3, [r3, #8]
 801bf9c:	461a      	mov	r2, r3
 801bf9e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801bfa0:	f00a fc71 	bl	8026886 <mp_mul>
 801bfa4:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801bfa6:	697b      	ldr	r3, [r7, #20]
 801bfa8:	2b00      	cmp	r3, #0
 801bfaa:	d107      	bne.n	801bfbc <wc_ecc_gen_z+0x72>
        err = mp_montgomery_reduce(p->z, modulus, mp);
 801bfac:	687b      	ldr	r3, [r7, #4]
 801bfae:	689b      	ldr	r3, [r3, #8]
 801bfb0:	6a3a      	ldr	r2, [r7, #32]
 801bfb2:	6839      	ldr	r1, [r7, #0]
 801bfb4:	4618      	mov	r0, r3
 801bfb6:	f00b f82d 	bl	8027014 <mp_montgomery_reduce>
 801bfba:	6178      	str	r0, [r7, #20]
    /* Square random value for X (X' = X / Z^2). */
    if (err == MP_OKAY)
 801bfbc:	697b      	ldr	r3, [r7, #20]
 801bfbe:	2b00      	cmp	r3, #0
 801bfc0:	d104      	bne.n	801bfcc <wc_ecc_gen_z+0x82>
        err = mp_sqr(ty, tx);
 801bfc2:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801bfc4:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bfc6:	f00b f855 	bl	8027074 <mp_sqr>
 801bfca:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801bfcc:	697b      	ldr	r3, [r7, #20]
 801bfce:	2b00      	cmp	r3, #0
 801bfd0:	d105      	bne.n	801bfde <wc_ecc_gen_z+0x94>
        err = mp_montgomery_reduce(tx, modulus, mp);
 801bfd2:	6a3a      	ldr	r2, [r7, #32]
 801bfd4:	6839      	ldr	r1, [r7, #0]
 801bfd6:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801bfd8:	f00b f81c 	bl	8027014 <mp_montgomery_reduce>
 801bfdc:	6178      	str	r0, [r7, #20]
    /* Multiply square of random by random value for Y. */
    if (err == MP_OKAY)
 801bfde:	697b      	ldr	r3, [r7, #20]
 801bfe0:	2b00      	cmp	r3, #0
 801bfe2:	d105      	bne.n	801bff0 <wc_ecc_gen_z+0xa6>
        err = mp_mul(ty, tx, ty);
 801bfe4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801bfe6:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801bfe8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bfea:	f00a fc4c 	bl	8026886 <mp_mul>
 801bfee:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801bff0:	697b      	ldr	r3, [r7, #20]
 801bff2:	2b00      	cmp	r3, #0
 801bff4:	d105      	bne.n	801c002 <wc_ecc_gen_z+0xb8>
        err = mp_montgomery_reduce(ty, modulus, mp);
 801bff6:	6a3a      	ldr	r2, [r7, #32]
 801bff8:	6839      	ldr	r1, [r7, #0]
 801bffa:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801bffc:	f00b f80a 	bl	8027014 <mp_montgomery_reduce>
 801c000:	6178      	str	r0, [r7, #20]
    /* Multiply square into X. */
    if (err == MP_OKAY)
 801c002:	697b      	ldr	r3, [r7, #20]
 801c004:	2b00      	cmp	r3, #0
 801c006:	d108      	bne.n	801c01a <wc_ecc_gen_z+0xd0>
        err = mp_mul(p->x, tx, p->x);
 801c008:	687b      	ldr	r3, [r7, #4]
 801c00a:	6818      	ldr	r0, [r3, #0]
 801c00c:	687b      	ldr	r3, [r7, #4]
 801c00e:	681b      	ldr	r3, [r3, #0]
 801c010:	461a      	mov	r2, r3
 801c012:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c014:	f00a fc37 	bl	8026886 <mp_mul>
 801c018:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801c01a:	697b      	ldr	r3, [r7, #20]
 801c01c:	2b00      	cmp	r3, #0
 801c01e:	d107      	bne.n	801c030 <wc_ecc_gen_z+0xe6>
        err = mp_montgomery_reduce(p->x, modulus, mp);
 801c020:	687b      	ldr	r3, [r7, #4]
 801c022:	681b      	ldr	r3, [r3, #0]
 801c024:	6a3a      	ldr	r2, [r7, #32]
 801c026:	6839      	ldr	r1, [r7, #0]
 801c028:	4618      	mov	r0, r3
 801c02a:	f00a fff3 	bl	8027014 <mp_montgomery_reduce>
 801c02e:	6178      	str	r0, [r7, #20]
    /* Multiply cube into Y (Y' = Y / Z^3). */
    if (err == MP_OKAY)
 801c030:	697b      	ldr	r3, [r7, #20]
 801c032:	2b00      	cmp	r3, #0
 801c034:	d108      	bne.n	801c048 <wc_ecc_gen_z+0xfe>
        err = mp_mul(p->y, ty, p->y);
 801c036:	687b      	ldr	r3, [r7, #4]
 801c038:	6858      	ldr	r0, [r3, #4]
 801c03a:	687b      	ldr	r3, [r7, #4]
 801c03c:	685b      	ldr	r3, [r3, #4]
 801c03e:	461a      	mov	r2, r3
 801c040:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801c042:	f00a fc20 	bl	8026886 <mp_mul>
 801c046:	6178      	str	r0, [r7, #20]
    if (err == MP_OKAY)
 801c048:	697b      	ldr	r3, [r7, #20]
 801c04a:	2b00      	cmp	r3, #0
 801c04c:	d107      	bne.n	801c05e <wc_ecc_gen_z+0x114>
        err = mp_montgomery_reduce(p->y, modulus, mp);
 801c04e:	687b      	ldr	r3, [r7, #4]
 801c050:	685b      	ldr	r3, [r3, #4]
 801c052:	6a3a      	ldr	r2, [r7, #32]
 801c054:	6839      	ldr	r1, [r7, #0]
 801c056:	4618      	mov	r0, r3
 801c058:	f00a ffdc 	bl	8027014 <mp_montgomery_reduce>
 801c05c:	6178      	str	r0, [r7, #20]

    return err;
 801c05e:	697b      	ldr	r3, [r7, #20]
}
 801c060:	4618      	mov	r0, r3
 801c062:	3718      	adds	r7, #24
 801c064:	46bd      	mov	sp, r7
 801c066:	bd80      	pop	{r7, pc}

0801c068 <ecc_mulmod>:
 *
 * Assumes: k < order.
 */
static int ecc_mulmod(const mp_int* k, ecc_point* P, ecc_point* Q,
    ecc_point** R, mp_int* a, mp_int* modulus, mp_digit mp, WC_RNG* rng)
{
 801c068:	b590      	push	{r4, r7, lr}
 801c06a:	b097      	sub	sp, #92	@ 0x5c
 801c06c:	af04      	add	r7, sp, #16
 801c06e:	60f8      	str	r0, [r7, #12]
 801c070:	60b9      	str	r1, [r7, #8]
 801c072:	607a      	str	r2, [r7, #4]
 801c074:	603b      	str	r3, [r7, #0]
    int      err = MP_OKAY;
 801c076:	2300      	movs	r3, #0
 801c078:	647b      	str	r3, [r7, #68]	@ 0x44
    int      bytes = (mp_count_bits(modulus) + 7) / 8;
 801c07a:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801c07c:	f00a fd7a 	bl	8026b74 <mp_count_bits>
 801c080:	4603      	mov	r3, r0
 801c082:	3307      	adds	r3, #7
 801c084:	2b00      	cmp	r3, #0
 801c086:	da00      	bge.n	801c08a <ecc_mulmod+0x22>
 801c088:	3307      	adds	r3, #7
 801c08a:	10db      	asrs	r3, r3, #3
 801c08c:	62bb      	str	r3, [r7, #40]	@ 0x28
    int      i;
    int      j = 1;
 801c08e:	2301      	movs	r3, #1
 801c090:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int      cnt = DIGIT_BIT;
 801c092:	2320      	movs	r3, #32
 801c094:	63bb      	str	r3, [r7, #56]	@ 0x38
    int      t = 0;
 801c096:	2300      	movs	r3, #0
 801c098:	637b      	str	r3, [r7, #52]	@ 0x34
    mp_digit b;
    mp_digit v = 0;
 801c09a:	2300      	movs	r3, #0
 801c09c:	633b      	str	r3, [r7, #48]	@ 0x30
    mp_int*  kt = R[2]->x;
 801c09e:	683b      	ldr	r3, [r7, #0]
 801c0a0:	3308      	adds	r3, #8
 801c0a2:	681b      	ldr	r3, [r3, #0]
 801c0a4:	681b      	ldr	r3, [r3, #0]
 801c0a6:	627b      	str	r3, [r7, #36]	@ 0x24
#ifndef WC_NO_CACHE_RESISTANT
    /* First bit always 1 (fix at end) and swap equals first bit */
    int      swap = 1;
 801c0a8:	2301      	movs	r3, #1
 801c0aa:	62fb      	str	r3, [r7, #44]	@ 0x2c
#ifdef WOLFSSL_SMALL_STACK
    mp_int*  tmp = NULL;
 801c0ac:	2300      	movs	r3, #0
 801c0ae:	623b      	str	r3, [r7, #32]
#endif
    int      infinity;

#ifndef WC_NO_CACHE_RESISTANT
#ifdef WOLFSSL_SMALL_STACK
    tmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
 801c0b0:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801c0b4:	f002 fcee 	bl	801ea94 <wolfSSL_Malloc>
 801c0b8:	6238      	str	r0, [r7, #32]
    if (tmp == NULL) {
 801c0ba:	6a3b      	ldr	r3, [r7, #32]
 801c0bc:	2b00      	cmp	r3, #0
 801c0be:	d102      	bne.n	801c0c6 <ecc_mulmod+0x5e>
        err = MEMORY_E;
 801c0c0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c0c4:	647b      	str	r3, [r7, #68]	@ 0x44
    }
#endif
    if (err == MP_OKAY)
 801c0c6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c0c8:	2b00      	cmp	r3, #0
 801c0ca:	d103      	bne.n	801c0d4 <ecc_mulmod+0x6c>
        err = mp_init(tmp);
 801c0cc:	6a38      	ldr	r0, [r7, #32]
 801c0ce:	f00a fae6 	bl	802669e <mp_init>
 801c0d2:	6478      	str	r0, [r7, #68]	@ 0x44
#endif

    /* Step 1: R[0] = P; R[1] = P */
    /* R[0] = P */
    if (err == MP_OKAY)
 801c0d4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c0d6:	2b00      	cmp	r3, #0
 801c0d8:	d109      	bne.n	801c0ee <ecc_mulmod+0x86>
        err = mp_copy(P->x, R[0]->x);
 801c0da:	68bb      	ldr	r3, [r7, #8]
 801c0dc:	681a      	ldr	r2, [r3, #0]
 801c0de:	683b      	ldr	r3, [r7, #0]
 801c0e0:	681b      	ldr	r3, [r3, #0]
 801c0e2:	681b      	ldr	r3, [r3, #0]
 801c0e4:	4619      	mov	r1, r3
 801c0e6:	4610      	mov	r0, r2
 801c0e8:	f00a fd25 	bl	8026b36 <mp_copy>
 801c0ec:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c0ee:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c0f0:	2b00      	cmp	r3, #0
 801c0f2:	d109      	bne.n	801c108 <ecc_mulmod+0xa0>
        err = mp_copy(P->y, R[0]->y);
 801c0f4:	68bb      	ldr	r3, [r7, #8]
 801c0f6:	685a      	ldr	r2, [r3, #4]
 801c0f8:	683b      	ldr	r3, [r7, #0]
 801c0fa:	681b      	ldr	r3, [r3, #0]
 801c0fc:	685b      	ldr	r3, [r3, #4]
 801c0fe:	4619      	mov	r1, r3
 801c100:	4610      	mov	r0, r2
 801c102:	f00a fd18 	bl	8026b36 <mp_copy>
 801c106:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c108:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c10a:	2b00      	cmp	r3, #0
 801c10c:	d109      	bne.n	801c122 <ecc_mulmod+0xba>
        err = mp_copy(P->z, R[0]->z);
 801c10e:	68bb      	ldr	r3, [r7, #8]
 801c110:	689a      	ldr	r2, [r3, #8]
 801c112:	683b      	ldr	r3, [r7, #0]
 801c114:	681b      	ldr	r3, [r3, #0]
 801c116:	689b      	ldr	r3, [r3, #8]
 801c118:	4619      	mov	r1, r3
 801c11a:	4610      	mov	r0, r2
 801c11c:	f00a fd0b 	bl	8026b36 <mp_copy>
 801c120:	6478      	str	r0, [r7, #68]	@ 0x44

    /* R[1] = P */
    if (err == MP_OKAY)
 801c122:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c124:	2b00      	cmp	r3, #0
 801c126:	d10a      	bne.n	801c13e <ecc_mulmod+0xd6>
        err = mp_copy(P->x, R[1]->x);
 801c128:	68bb      	ldr	r3, [r7, #8]
 801c12a:	681a      	ldr	r2, [r3, #0]
 801c12c:	683b      	ldr	r3, [r7, #0]
 801c12e:	3304      	adds	r3, #4
 801c130:	681b      	ldr	r3, [r3, #0]
 801c132:	681b      	ldr	r3, [r3, #0]
 801c134:	4619      	mov	r1, r3
 801c136:	4610      	mov	r0, r2
 801c138:	f00a fcfd 	bl	8026b36 <mp_copy>
 801c13c:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c13e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c140:	2b00      	cmp	r3, #0
 801c142:	d10a      	bne.n	801c15a <ecc_mulmod+0xf2>
        err = mp_copy(P->y, R[1]->y);
 801c144:	68bb      	ldr	r3, [r7, #8]
 801c146:	685a      	ldr	r2, [r3, #4]
 801c148:	683b      	ldr	r3, [r7, #0]
 801c14a:	3304      	adds	r3, #4
 801c14c:	681b      	ldr	r3, [r3, #0]
 801c14e:	685b      	ldr	r3, [r3, #4]
 801c150:	4619      	mov	r1, r3
 801c152:	4610      	mov	r0, r2
 801c154:	f00a fcef 	bl	8026b36 <mp_copy>
 801c158:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c15a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c15c:	2b00      	cmp	r3, #0
 801c15e:	d10a      	bne.n	801c176 <ecc_mulmod+0x10e>
        err = mp_copy(P->z, R[1]->z);
 801c160:	68bb      	ldr	r3, [r7, #8]
 801c162:	689a      	ldr	r2, [r3, #8]
 801c164:	683b      	ldr	r3, [r7, #0]
 801c166:	3304      	adds	r3, #4
 801c168:	681b      	ldr	r3, [r3, #0]
 801c16a:	689b      	ldr	r3, [r3, #8]
 801c16c:	4619      	mov	r1, r3
 801c16e:	4610      	mov	r0, r2
 801c170:	f00a fce1 	bl	8026b36 <mp_copy>
 801c174:	6478      	str	r0, [r7, #68]	@ 0x44

    /* Randomize z ordinates to obfuscate timing. */
    if ((err == MP_OKAY) && (rng != NULL))
 801c176:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c178:	2b00      	cmp	r3, #0
 801c17a:	d119      	bne.n	801c1b0 <ecc_mulmod+0x148>
 801c17c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801c17e:	2b00      	cmp	r3, #0
 801c180:	d016      	beq.n	801c1b0 <ecc_mulmod+0x148>
        err = wc_ecc_gen_z(rng, bytes, R[0], modulus, mp, R[2]->x, R[2]->y, kt);
 801c182:	683b      	ldr	r3, [r7, #0]
 801c184:	6818      	ldr	r0, [r3, #0]
 801c186:	683b      	ldr	r3, [r7, #0]
 801c188:	3308      	adds	r3, #8
 801c18a:	681b      	ldr	r3, [r3, #0]
 801c18c:	681b      	ldr	r3, [r3, #0]
 801c18e:	683a      	ldr	r2, [r7, #0]
 801c190:	3208      	adds	r2, #8
 801c192:	6812      	ldr	r2, [r2, #0]
 801c194:	6852      	ldr	r2, [r2, #4]
 801c196:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c198:	9103      	str	r1, [sp, #12]
 801c19a:	9202      	str	r2, [sp, #8]
 801c19c:	9301      	str	r3, [sp, #4]
 801c19e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c1a0:	9300      	str	r3, [sp, #0]
 801c1a2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c1a4:	4602      	mov	r2, r0
 801c1a6:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801c1a8:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801c1aa:	f7ff fece 	bl	801bf4a <wc_ecc_gen_z>
 801c1ae:	6478      	str	r0, [r7, #68]	@ 0x44
    if ((err == MP_OKAY) && (rng != NULL))
 801c1b0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c1b2:	2b00      	cmp	r3, #0
 801c1b4:	d11a      	bne.n	801c1ec <ecc_mulmod+0x184>
 801c1b6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801c1b8:	2b00      	cmp	r3, #0
 801c1ba:	d017      	beq.n	801c1ec <ecc_mulmod+0x184>
        err = wc_ecc_gen_z(rng, bytes, R[1], modulus, mp, R[2]->x, R[2]->y, kt);
 801c1bc:	683b      	ldr	r3, [r7, #0]
 801c1be:	3304      	adds	r3, #4
 801c1c0:	6818      	ldr	r0, [r3, #0]
 801c1c2:	683b      	ldr	r3, [r7, #0]
 801c1c4:	3308      	adds	r3, #8
 801c1c6:	681b      	ldr	r3, [r3, #0]
 801c1c8:	681b      	ldr	r3, [r3, #0]
 801c1ca:	683a      	ldr	r2, [r7, #0]
 801c1cc:	3208      	adds	r2, #8
 801c1ce:	6812      	ldr	r2, [r2, #0]
 801c1d0:	6852      	ldr	r2, [r2, #4]
 801c1d2:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c1d4:	9103      	str	r1, [sp, #12]
 801c1d6:	9202      	str	r2, [sp, #8]
 801c1d8:	9301      	str	r3, [sp, #4]
 801c1da:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c1dc:	9300      	str	r3, [sp, #0]
 801c1de:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c1e0:	4602      	mov	r2, r0
 801c1e2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801c1e4:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801c1e6:	f7ff feb0 	bl	801bf4a <wc_ecc_gen_z>
 801c1ea:	6478      	str	r0, [r7, #68]	@ 0x44

    if (err == MP_OKAY) {
 801c1ec:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c1ee:	2b00      	cmp	r3, #0
 801c1f0:	d114      	bne.n	801c21c <ecc_mulmod+0x1b4>
        /* Order could be one greater than the size of the modulus. */
        t = mp_count_bits(modulus) + 1;
 801c1f2:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801c1f4:	f00a fcbe 	bl	8026b74 <mp_count_bits>
 801c1f8:	4603      	mov	r3, r0
 801c1fa:	3301      	adds	r3, #1
 801c1fc:	637b      	str	r3, [r7, #52]	@ 0x34
        v = k->dp[0] >> 1;
 801c1fe:	68fb      	ldr	r3, [r7, #12]
 801c200:	68db      	ldr	r3, [r3, #12]
 801c202:	085b      	lsrs	r3, r3, #1
 801c204:	633b      	str	r3, [r7, #48]	@ 0x30
        if (cnt > t) {
 801c206:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c208:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c20a:	429a      	cmp	r2, r3
 801c20c:	dd01      	ble.n	801c212 <ecc_mulmod+0x1aa>
            cnt = t;
 801c20e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c210:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
        err = mp_copy(k, kt);
 801c212:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c214:	68f8      	ldr	r0, [r7, #12]
 801c216:	f00a fc8e 	bl	8026b36 <mp_copy>
 801c21a:	6478      	str	r0, [r7, #68]	@ 0x44
    }
    if (err == MP_OKAY) {
 801c21c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c21e:	2b00      	cmp	r3, #0
 801c220:	d101      	bne.n	801c226 <ecc_mulmod+0x1be>
        err = mp_grow(kt, (int)modulus->used + 1);
 801c222:	2300      	movs	r3, #0
 801c224:	647b      	str	r3, [r7, #68]	@ 0x44
    }
    /* Step 2: for j = 1 to t-1 do */
    for (i = 1; (err == MP_OKAY) && (i < t); i++) {
 801c226:	2301      	movs	r3, #1
 801c228:	643b      	str	r3, [r7, #64]	@ 0x40
 801c22a:	e079      	b.n	801c320 <ecc_mulmod+0x2b8>
        if (--cnt == 0) {
 801c22c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801c22e:	3b01      	subs	r3, #1
 801c230:	63bb      	str	r3, [r7, #56]	@ 0x38
 801c232:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801c234:	2b00      	cmp	r3, #0
 801c236:	d10a      	bne.n	801c24e <ecc_mulmod+0x1e6>
            v = kt->dp[j++];
 801c238:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c23a:	1c5a      	adds	r2, r3, #1
 801c23c:	63fa      	str	r2, [r7, #60]	@ 0x3c
 801c23e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801c240:	3302      	adds	r3, #2
 801c242:	009b      	lsls	r3, r3, #2
 801c244:	4413      	add	r3, r2
 801c246:	685b      	ldr	r3, [r3, #4]
 801c248:	633b      	str	r3, [r7, #48]	@ 0x30
            cnt = DIGIT_BIT;
 801c24a:	2320      	movs	r3, #32
 801c24c:	63bb      	str	r3, [r7, #56]	@ 0x38
        }

        /* Step 3: b = 1 - k[j]; R[b] = 2*R[b] + R[k[j]] */
        b = v & 1;
 801c24e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c250:	f003 0301 	and.w	r3, r3, #1
 801c254:	61fb      	str	r3, [r7, #28]
        v >>= 1;
 801c256:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c258:	085b      	lsrs	r3, r3, #1
 801c25a:	633b      	str	r3, [r7, #48]	@ 0x30
            err = ecc_projective_add_point_safe(R[b^1], R[b], R[b^1], a,
                                                        modulus, mp, &infinity);
        }
#else
        /* Swap R[0] and R[1] if other index is needed. */
        swap ^= (int)b;
 801c25c:	69fb      	ldr	r3, [r7, #28]
 801c25e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801c260:	4053      	eors	r3, r2
 801c262:	62fb      	str	r3, [r7, #44]	@ 0x2c
        if (err == MP_OKAY) {
 801c264:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c266:	2b00      	cmp	r3, #0
 801c268:	d10e      	bne.n	801c288 <ecc_mulmod+0x220>
            err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, swap,
 801c26a:	683b      	ldr	r3, [r7, #0]
 801c26c:	681b      	ldr	r3, [r3, #0]
 801c26e:	6818      	ldr	r0, [r3, #0]
 801c270:	683b      	ldr	r3, [r7, #0]
 801c272:	3304      	adds	r3, #4
 801c274:	681b      	ldr	r3, [r3, #0]
 801c276:	6819      	ldr	r1, [r3, #0]
 801c278:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c27a:	681a      	ldr	r2, [r3, #0]
 801c27c:	6a3b      	ldr	r3, [r7, #32]
 801c27e:	9300      	str	r3, [sp, #0]
 801c280:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c282:	f00a fd2d 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c286:	6478      	str	r0, [r7, #68]	@ 0x44
                tmp);
        }
        if (err == MP_OKAY) {
 801c288:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c28a:	2b00      	cmp	r3, #0
 801c28c:	d10e      	bne.n	801c2ac <ecc_mulmod+0x244>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used, swap,
 801c28e:	683b      	ldr	r3, [r7, #0]
 801c290:	681b      	ldr	r3, [r3, #0]
 801c292:	6858      	ldr	r0, [r3, #4]
 801c294:	683b      	ldr	r3, [r7, #0]
 801c296:	3304      	adds	r3, #4
 801c298:	681b      	ldr	r3, [r3, #0]
 801c29a:	6859      	ldr	r1, [r3, #4]
 801c29c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c29e:	681a      	ldr	r2, [r3, #0]
 801c2a0:	6a3b      	ldr	r3, [r7, #32]
 801c2a2:	9300      	str	r3, [sp, #0]
 801c2a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c2a6:	f00a fd1b 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c2aa:	6478      	str	r0, [r7, #68]	@ 0x44
                tmp);
        }
        if (err == MP_OKAY) {
 801c2ac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c2ae:	2b00      	cmp	r3, #0
 801c2b0:	d10e      	bne.n	801c2d0 <ecc_mulmod+0x268>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used, swap,
 801c2b2:	683b      	ldr	r3, [r7, #0]
 801c2b4:	681b      	ldr	r3, [r3, #0]
 801c2b6:	6898      	ldr	r0, [r3, #8]
 801c2b8:	683b      	ldr	r3, [r7, #0]
 801c2ba:	3304      	adds	r3, #4
 801c2bc:	681b      	ldr	r3, [r3, #0]
 801c2be:	6899      	ldr	r1, [r3, #8]
 801c2c0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c2c2:	681a      	ldr	r2, [r3, #0]
 801c2c4:	6a3b      	ldr	r3, [r7, #32]
 801c2c6:	9300      	str	r3, [sp, #0]
 801c2c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c2ca:	f00a fd09 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c2ce:	6478      	str	r0, [r7, #68]	@ 0x44
                tmp);
        }
        swap = (int)b;
 801c2d0:	69fb      	ldr	r3, [r7, #28]
 801c2d2:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if (err == MP_OKAY)
 801c2d4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c2d6:	2b00      	cmp	r3, #0
 801c2d8:	d10a      	bne.n	801c2f0 <ecc_mulmod+0x288>
            err = ecc_projective_dbl_point_safe(R[0], R[0], a, modulus, mp);
 801c2da:	683b      	ldr	r3, [r7, #0]
 801c2dc:	6818      	ldr	r0, [r3, #0]
 801c2de:	683b      	ldr	r3, [r7, #0]
 801c2e0:	6819      	ldr	r1, [r3, #0]
 801c2e2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c2e4:	9300      	str	r3, [sp, #0]
 801c2e6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c2e8:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801c2ea:	f000 ff48 	bl	801d17e <ecc_projective_dbl_point_safe>
 801c2ee:	6478      	str	r0, [r7, #68]	@ 0x44
        if (err == MP_OKAY) {
 801c2f0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c2f2:	2b00      	cmp	r3, #0
 801c2f4:	d111      	bne.n	801c31a <ecc_mulmod+0x2b2>
            err = ecc_projective_add_point_safe(R[0], R[1], R[0], a, modulus,
 801c2f6:	683b      	ldr	r3, [r7, #0]
 801c2f8:	6818      	ldr	r0, [r3, #0]
 801c2fa:	683b      	ldr	r3, [r7, #0]
 801c2fc:	3304      	adds	r3, #4
 801c2fe:	6819      	ldr	r1, [r3, #0]
 801c300:	683b      	ldr	r3, [r7, #0]
 801c302:	681a      	ldr	r2, [r3, #0]
 801c304:	f107 0314 	add.w	r3, r7, #20
 801c308:	9302      	str	r3, [sp, #8]
 801c30a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c30c:	9301      	str	r3, [sp, #4]
 801c30e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c310:	9300      	str	r3, [sp, #0]
 801c312:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801c314:	f000 fe2f 	bl	801cf76 <ecc_projective_add_point_safe>
 801c318:	6478      	str	r0, [r7, #68]	@ 0x44
    for (i = 1; (err == MP_OKAY) && (i < t); i++) {
 801c31a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c31c:	3301      	adds	r3, #1
 801c31e:	643b      	str	r3, [r7, #64]	@ 0x40
 801c320:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c322:	2b00      	cmp	r3, #0
 801c324:	d104      	bne.n	801c330 <ecc_mulmod+0x2c8>
 801c326:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801c328:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c32a:	429a      	cmp	r2, r3
 801c32c:	f6ff af7e 	blt.w	801c22c <ecc_mulmod+0x1c4>
#endif /* WC_NO_CACHE_RESISTANT */
    }
    /* Step 4: end for */
#ifndef WC_NO_CACHE_RESISTANT
    /* Swap back if last bit is 0. */
    swap ^= 1;
 801c330:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c332:	f083 0301 	eor.w	r3, r3, #1
 801c336:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if (err == MP_OKAY) {
 801c338:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c33a:	2b00      	cmp	r3, #0
 801c33c:	d10e      	bne.n	801c35c <ecc_mulmod+0x2f4>
        err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, swap,
 801c33e:	683b      	ldr	r3, [r7, #0]
 801c340:	681b      	ldr	r3, [r3, #0]
 801c342:	6818      	ldr	r0, [r3, #0]
 801c344:	683b      	ldr	r3, [r7, #0]
 801c346:	3304      	adds	r3, #4
 801c348:	681b      	ldr	r3, [r3, #0]
 801c34a:	6819      	ldr	r1, [r3, #0]
 801c34c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c34e:	681a      	ldr	r2, [r3, #0]
 801c350:	6a3b      	ldr	r3, [r7, #32]
 801c352:	9300      	str	r3, [sp, #0]
 801c354:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c356:	f00a fcc3 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c35a:	6478      	str	r0, [r7, #68]	@ 0x44
            tmp);
    }
    if (err == MP_OKAY) {
 801c35c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c35e:	2b00      	cmp	r3, #0
 801c360:	d10e      	bne.n	801c380 <ecc_mulmod+0x318>
        err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used, swap,
 801c362:	683b      	ldr	r3, [r7, #0]
 801c364:	681b      	ldr	r3, [r3, #0]
 801c366:	6858      	ldr	r0, [r3, #4]
 801c368:	683b      	ldr	r3, [r7, #0]
 801c36a:	3304      	adds	r3, #4
 801c36c:	681b      	ldr	r3, [r3, #0]
 801c36e:	6859      	ldr	r1, [r3, #4]
 801c370:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c372:	681a      	ldr	r2, [r3, #0]
 801c374:	6a3b      	ldr	r3, [r7, #32]
 801c376:	9300      	str	r3, [sp, #0]
 801c378:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c37a:	f00a fcb1 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c37e:	6478      	str	r0, [r7, #68]	@ 0x44
            tmp);
    }
    if (err == MP_OKAY) {
 801c380:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c382:	2b00      	cmp	r3, #0
 801c384:	d10e      	bne.n	801c3a4 <ecc_mulmod+0x33c>
        err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used, swap,
 801c386:	683b      	ldr	r3, [r7, #0]
 801c388:	681b      	ldr	r3, [r3, #0]
 801c38a:	6898      	ldr	r0, [r3, #8]
 801c38c:	683b      	ldr	r3, [r7, #0]
 801c38e:	3304      	adds	r3, #4
 801c390:	681b      	ldr	r3, [r3, #0]
 801c392:	6899      	ldr	r1, [r3, #8]
 801c394:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c396:	681a      	ldr	r2, [r3, #0]
 801c398:	6a3b      	ldr	r3, [r7, #32]
 801c39a:	9300      	str	r3, [sp, #0]
 801c39c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c39e:	f00a fc9f 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c3a2:	6478      	str	r0, [r7, #68]	@ 0x44
    }
#endif

    /* Step 5: b = k[0]; R[b] = R[b] - P */
    /* R[2] = -P */
    if (err == MP_OKAY)
 801c3a4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c3a6:	2b00      	cmp	r3, #0
 801c3a8:	d10a      	bne.n	801c3c0 <ecc_mulmod+0x358>
        err = mp_copy(P->x, R[2]->x);
 801c3aa:	68bb      	ldr	r3, [r7, #8]
 801c3ac:	681a      	ldr	r2, [r3, #0]
 801c3ae:	683b      	ldr	r3, [r7, #0]
 801c3b0:	3308      	adds	r3, #8
 801c3b2:	681b      	ldr	r3, [r3, #0]
 801c3b4:	681b      	ldr	r3, [r3, #0]
 801c3b6:	4619      	mov	r1, r3
 801c3b8:	4610      	mov	r0, r2
 801c3ba:	f00a fbbc 	bl	8026b36 <mp_copy>
 801c3be:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c3c0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c3c2:	2b00      	cmp	r3, #0
 801c3c4:	d10a      	bne.n	801c3dc <ecc_mulmod+0x374>
        err = mp_sub(modulus, P->y, R[2]->y);
 801c3c6:	68bb      	ldr	r3, [r7, #8]
 801c3c8:	6859      	ldr	r1, [r3, #4]
 801c3ca:	683b      	ldr	r3, [r7, #0]
 801c3cc:	3308      	adds	r3, #8
 801c3ce:	681b      	ldr	r3, [r3, #0]
 801c3d0:	685b      	ldr	r3, [r3, #4]
 801c3d2:	461a      	mov	r2, r3
 801c3d4:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801c3d6:	f00a fa46 	bl	8026866 <mp_sub>
 801c3da:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c3dc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c3de:	2b00      	cmp	r3, #0
 801c3e0:	d10a      	bne.n	801c3f8 <ecc_mulmod+0x390>
        err = mp_copy(P->z, R[2]->z);
 801c3e2:	68bb      	ldr	r3, [r7, #8]
 801c3e4:	689a      	ldr	r2, [r3, #8]
 801c3e6:	683b      	ldr	r3, [r7, #0]
 801c3e8:	3308      	adds	r3, #8
 801c3ea:	681b      	ldr	r3, [r3, #0]
 801c3ec:	689b      	ldr	r3, [r3, #8]
 801c3ee:	4619      	mov	r1, r3
 801c3f0:	4610      	mov	r0, r2
 801c3f2:	f00a fba0 	bl	8026b36 <mp_copy>
 801c3f6:	6478      	str	r0, [r7, #68]	@ 0x44
    /* Subtract point by adding negative. */
    if (err == MP_OKAY) {
 801c3f8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c3fa:	2b00      	cmp	r3, #0
 801c3fc:	f040 8089 	bne.w	801c512 <ecc_mulmod+0x4aa>
        b = k->dp[0] & 1;
 801c400:	68fb      	ldr	r3, [r7, #12]
 801c402:	68db      	ldr	r3, [r3, #12]
 801c404:	f003 0301 	and.w	r3, r3, #1
 801c408:	61fb      	str	r3, [r7, #28]
#ifdef WC_NO_CACHE_RESISTANT
        err = ecc_projective_add_point_safe(R[b], R[2], R[b], a, modulus, mp,
                                                                     &infinity);
#else
        /* Swap R[0] and R[1], if necessary, to operate on the one we want. */
        err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, (int)b,
 801c40a:	683b      	ldr	r3, [r7, #0]
 801c40c:	681b      	ldr	r3, [r3, #0]
 801c40e:	6818      	ldr	r0, [r3, #0]
 801c410:	683b      	ldr	r3, [r7, #0]
 801c412:	3304      	adds	r3, #4
 801c414:	681b      	ldr	r3, [r3, #0]
 801c416:	6819      	ldr	r1, [r3, #0]
 801c418:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c41a:	681a      	ldr	r2, [r3, #0]
 801c41c:	69fc      	ldr	r4, [r7, #28]
 801c41e:	6a3b      	ldr	r3, [r7, #32]
 801c420:	9300      	str	r3, [sp, #0]
 801c422:	4623      	mov	r3, r4
 801c424:	f00a fc5c 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c428:	6478      	str	r0, [r7, #68]	@ 0x44
            tmp);
        if (err == MP_OKAY) {
 801c42a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c42c:	2b00      	cmp	r3, #0
 801c42e:	d10f      	bne.n	801c450 <ecc_mulmod+0x3e8>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used,
 801c430:	683b      	ldr	r3, [r7, #0]
 801c432:	681b      	ldr	r3, [r3, #0]
 801c434:	6858      	ldr	r0, [r3, #4]
 801c436:	683b      	ldr	r3, [r7, #0]
 801c438:	3304      	adds	r3, #4
 801c43a:	681b      	ldr	r3, [r3, #0]
 801c43c:	6859      	ldr	r1, [r3, #4]
 801c43e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c440:	681a      	ldr	r2, [r3, #0]
 801c442:	69fc      	ldr	r4, [r7, #28]
 801c444:	6a3b      	ldr	r3, [r7, #32]
 801c446:	9300      	str	r3, [sp, #0]
 801c448:	4623      	mov	r3, r4
 801c44a:	f00a fc49 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c44e:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY) {
 801c450:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c452:	2b00      	cmp	r3, #0
 801c454:	d10f      	bne.n	801c476 <ecc_mulmod+0x40e>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used,
 801c456:	683b      	ldr	r3, [r7, #0]
 801c458:	681b      	ldr	r3, [r3, #0]
 801c45a:	6898      	ldr	r0, [r3, #8]
 801c45c:	683b      	ldr	r3, [r7, #0]
 801c45e:	3304      	adds	r3, #4
 801c460:	681b      	ldr	r3, [r3, #0]
 801c462:	6899      	ldr	r1, [r3, #8]
 801c464:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c466:	681a      	ldr	r2, [r3, #0]
 801c468:	69fc      	ldr	r4, [r7, #28]
 801c46a:	6a3b      	ldr	r3, [r7, #32]
 801c46c:	9300      	str	r3, [sp, #0]
 801c46e:	4623      	mov	r3, r4
 801c470:	f00a fc36 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c474:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY)
 801c476:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c478:	2b00      	cmp	r3, #0
 801c47a:	d111      	bne.n	801c4a0 <ecc_mulmod+0x438>
            err = ecc_projective_add_point_safe(R[0], R[2], R[0], a, modulus,
 801c47c:	683b      	ldr	r3, [r7, #0]
 801c47e:	6818      	ldr	r0, [r3, #0]
 801c480:	683b      	ldr	r3, [r7, #0]
 801c482:	3308      	adds	r3, #8
 801c484:	6819      	ldr	r1, [r3, #0]
 801c486:	683b      	ldr	r3, [r7, #0]
 801c488:	681a      	ldr	r2, [r3, #0]
 801c48a:	f107 0314 	add.w	r3, r7, #20
 801c48e:	9302      	str	r3, [sp, #8]
 801c490:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801c492:	9301      	str	r3, [sp, #4]
 801c494:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c496:	9300      	str	r3, [sp, #0]
 801c498:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801c49a:	f000 fd6c 	bl	801cf76 <ecc_projective_add_point_safe>
 801c49e:	6478      	str	r0, [r7, #68]	@ 0x44
                                                                 mp, &infinity);
        /* Swap back if necessary. */
        if (err == MP_OKAY) {
 801c4a0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c4a2:	2b00      	cmp	r3, #0
 801c4a4:	d10f      	bne.n	801c4c6 <ecc_mulmod+0x45e>
            err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used,
 801c4a6:	683b      	ldr	r3, [r7, #0]
 801c4a8:	681b      	ldr	r3, [r3, #0]
 801c4aa:	6818      	ldr	r0, [r3, #0]
 801c4ac:	683b      	ldr	r3, [r7, #0]
 801c4ae:	3304      	adds	r3, #4
 801c4b0:	681b      	ldr	r3, [r3, #0]
 801c4b2:	6819      	ldr	r1, [r3, #0]
 801c4b4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c4b6:	681a      	ldr	r2, [r3, #0]
 801c4b8:	69fc      	ldr	r4, [r7, #28]
 801c4ba:	6a3b      	ldr	r3, [r7, #32]
 801c4bc:	9300      	str	r3, [sp, #0]
 801c4be:	4623      	mov	r3, r4
 801c4c0:	f00a fc0e 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c4c4:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY) {
 801c4c6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c4c8:	2b00      	cmp	r3, #0
 801c4ca:	d10f      	bne.n	801c4ec <ecc_mulmod+0x484>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used,
 801c4cc:	683b      	ldr	r3, [r7, #0]
 801c4ce:	681b      	ldr	r3, [r3, #0]
 801c4d0:	6858      	ldr	r0, [r3, #4]
 801c4d2:	683b      	ldr	r3, [r7, #0]
 801c4d4:	3304      	adds	r3, #4
 801c4d6:	681b      	ldr	r3, [r3, #0]
 801c4d8:	6859      	ldr	r1, [r3, #4]
 801c4da:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c4dc:	681a      	ldr	r2, [r3, #0]
 801c4de:	69fc      	ldr	r4, [r7, #28]
 801c4e0:	6a3b      	ldr	r3, [r7, #32]
 801c4e2:	9300      	str	r3, [sp, #0]
 801c4e4:	4623      	mov	r3, r4
 801c4e6:	f00a fbfb 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c4ea:	6478      	str	r0, [r7, #68]	@ 0x44
                (int)b, tmp);
        }
        if (err == MP_OKAY) {
 801c4ec:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c4ee:	2b00      	cmp	r3, #0
 801c4f0:	d10f      	bne.n	801c512 <ecc_mulmod+0x4aa>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used,
 801c4f2:	683b      	ldr	r3, [r7, #0]
 801c4f4:	681b      	ldr	r3, [r3, #0]
 801c4f6:	6898      	ldr	r0, [r3, #8]
 801c4f8:	683b      	ldr	r3, [r7, #0]
 801c4fa:	3304      	adds	r3, #4
 801c4fc:	681b      	ldr	r3, [r3, #0]
 801c4fe:	6899      	ldr	r1, [r3, #8]
 801c500:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801c502:	681a      	ldr	r2, [r3, #0]
 801c504:	69fc      	ldr	r4, [r7, #28]
 801c506:	6a3b      	ldr	r3, [r7, #32]
 801c508:	9300      	str	r3, [sp, #0]
 801c50a:	4623      	mov	r3, r4
 801c50c:	f00a fbe8 	bl	8026ce0 <mp_cond_swap_ct_ex>
 801c510:	6478      	str	r0, [r7, #68]	@ 0x44
        }
#endif
    }

    /* Step 6: return R[0] */
    if (err == MP_OKAY)
 801c512:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c514:	2b00      	cmp	r3, #0
 801c516:	d109      	bne.n	801c52c <ecc_mulmod+0x4c4>
        err = mp_copy(R[0]->x, Q->x);
 801c518:	683b      	ldr	r3, [r7, #0]
 801c51a:	681b      	ldr	r3, [r3, #0]
 801c51c:	681a      	ldr	r2, [r3, #0]
 801c51e:	687b      	ldr	r3, [r7, #4]
 801c520:	681b      	ldr	r3, [r3, #0]
 801c522:	4619      	mov	r1, r3
 801c524:	4610      	mov	r0, r2
 801c526:	f00a fb06 	bl	8026b36 <mp_copy>
 801c52a:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c52c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c52e:	2b00      	cmp	r3, #0
 801c530:	d109      	bne.n	801c546 <ecc_mulmod+0x4de>
        err = mp_copy(R[0]->y, Q->y);
 801c532:	683b      	ldr	r3, [r7, #0]
 801c534:	681b      	ldr	r3, [r3, #0]
 801c536:	685a      	ldr	r2, [r3, #4]
 801c538:	687b      	ldr	r3, [r7, #4]
 801c53a:	685b      	ldr	r3, [r3, #4]
 801c53c:	4619      	mov	r1, r3
 801c53e:	4610      	mov	r0, r2
 801c540:	f00a faf9 	bl	8026b36 <mp_copy>
 801c544:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err == MP_OKAY)
 801c546:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c548:	2b00      	cmp	r3, #0
 801c54a:	d109      	bne.n	801c560 <ecc_mulmod+0x4f8>
        err = mp_copy(R[0]->z, Q->z);
 801c54c:	683b      	ldr	r3, [r7, #0]
 801c54e:	681b      	ldr	r3, [r3, #0]
 801c550:	689a      	ldr	r2, [r3, #8]
 801c552:	687b      	ldr	r3, [r7, #4]
 801c554:	689b      	ldr	r3, [r3, #8]
 801c556:	4619      	mov	r1, r3
 801c558:	4610      	mov	r0, r2
 801c55a:	f00a faec 	bl	8026b36 <mp_copy>
 801c55e:	6478      	str	r0, [r7, #68]	@ 0x44

#if defined(WOLFSSL_SMALL_STACK) && !defined(WC_NO_CACHE_RESISTANT)
    XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
 801c560:	6a3b      	ldr	r3, [r7, #32]
 801c562:	61bb      	str	r3, [r7, #24]
 801c564:	69bb      	ldr	r3, [r7, #24]
 801c566:	2b00      	cmp	r3, #0
 801c568:	d002      	beq.n	801c570 <ecc_mulmod+0x508>
 801c56a:	69b8      	ldr	r0, [r7, #24]
 801c56c:	f002 faae 	bl	801eacc <wolfSSL_Free>
#endif

    return err;
 801c570:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 801c572:	4618      	mov	r0, r3
 801c574:	374c      	adds	r7, #76	@ 0x4c
 801c576:	46bd      	mov	sp, r7
 801c578:	bd90      	pop	{r4, r7, pc}

0801c57a <ecc_point_to_mont>:
 * @return  0 on success.
 * @return  -ve on failure.
 */
static int ecc_point_to_mont(ecc_point* p, ecc_point* r, mp_int* modulus,
                             void* heap)
{
 801c57a:	b580      	push	{r7, lr}
 801c57c:	b088      	sub	sp, #32
 801c57e:	af00      	add	r7, sp, #0
 801c580:	60f8      	str	r0, [r7, #12]
 801c582:	60b9      	str	r1, [r7, #8]
 801c584:	607a      	str	r2, [r7, #4]
 801c586:	603b      	str	r3, [r7, #0]
   int err = MP_OKAY;
 801c588:	2300      	movs	r3, #0
 801c58a:	61fb      	str	r3, [r7, #28]
   DECL_MP_INT_SIZE_DYN(mu, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801c58c:	2300      	movs	r3, #0
 801c58e:	61bb      	str	r3, [r7, #24]

   (void)heap;

   NEW_MP_INT_SIZE(mu, mp_bitsused(modulus), heap, DYNAMIC_TYPE_ECC);
 801c590:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801c594:	f002 fa7e 	bl	801ea94 <wolfSSL_Malloc>
 801c598:	61b8      	str	r0, [r7, #24]
 801c59a:	69bb      	ldr	r3, [r7, #24]
 801c59c:	2b00      	cmp	r3, #0
 801c59e:	d005      	beq.n	801c5ac <ecc_point_to_mont+0x32>
 801c5a0:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801c5a4:	2100      	movs	r1, #0
 801c5a6:	69b8      	ldr	r0, [r7, #24]
 801c5a8:	f00b ff92 	bl	80284d0 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
   if (mu == NULL)
 801c5ac:	69bb      	ldr	r3, [r7, #24]
 801c5ae:	2b00      	cmp	r3, #0
 801c5b0:	d102      	bne.n	801c5b8 <ecc_point_to_mont+0x3e>
       err = MEMORY_E;
 801c5b2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c5b6:	61fb      	str	r3, [r7, #28]
#endif
   if (err == MP_OKAY)
 801c5b8:	69fb      	ldr	r3, [r7, #28]
 801c5ba:	2b00      	cmp	r3, #0
 801c5bc:	d103      	bne.n	801c5c6 <ecc_point_to_mont+0x4c>
       err = INIT_MP_INT_SIZE(mu, mp_bitsused(modulus));
 801c5be:	69b8      	ldr	r0, [r7, #24]
 801c5c0:	f00a f86d 	bl	802669e <mp_init>
 801c5c4:	61f8      	str	r0, [r7, #28]
   if (err == MP_OKAY) {
 801c5c6:	69fb      	ldr	r3, [r7, #28]
 801c5c8:	2b00      	cmp	r3, #0
 801c5ca:	d154      	bne.n	801c676 <ecc_point_to_mont+0xfc>
       err = mp_montgomery_calc_normalization(mu, modulus);
 801c5cc:	6879      	ldr	r1, [r7, #4]
 801c5ce:	69b8      	ldr	r0, [r7, #24]
 801c5d0:	f00a faf5 	bl	8026bbe <mp_montgomery_calc_normalization>
 801c5d4:	61f8      	str	r0, [r7, #28]

       if (err == MP_OKAY) {
 801c5d6:	69fb      	ldr	r3, [r7, #28]
 801c5d8:	2b00      	cmp	r3, #0
 801c5da:	d149      	bne.n	801c670 <ecc_point_to_mont+0xf6>
           if (mp_cmp_d(mu, 1) == MP_EQ) {
 801c5dc:	2101      	movs	r1, #1
 801c5de:	69b8      	ldr	r0, [r7, #24]
 801c5e0:	f00a f9fe 	bl	80269e0 <mp_cmp_d>
 801c5e4:	4603      	mov	r3, r0
 801c5e6:	2b00      	cmp	r3, #0
 801c5e8:	d121      	bne.n	801c62e <ecc_point_to_mont+0xb4>
               err = mp_copy(p->x, r->x);
 801c5ea:	68fb      	ldr	r3, [r7, #12]
 801c5ec:	681a      	ldr	r2, [r3, #0]
 801c5ee:	68bb      	ldr	r3, [r7, #8]
 801c5f0:	681b      	ldr	r3, [r3, #0]
 801c5f2:	4619      	mov	r1, r3
 801c5f4:	4610      	mov	r0, r2
 801c5f6:	f00a fa9e 	bl	8026b36 <mp_copy>
 801c5fa:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c5fc:	69fb      	ldr	r3, [r7, #28]
 801c5fe:	2b00      	cmp	r3, #0
 801c600:	d108      	bne.n	801c614 <ecc_point_to_mont+0x9a>
                   err = mp_copy(p->y, r->y);
 801c602:	68fb      	ldr	r3, [r7, #12]
 801c604:	685a      	ldr	r2, [r3, #4]
 801c606:	68bb      	ldr	r3, [r7, #8]
 801c608:	685b      	ldr	r3, [r3, #4]
 801c60a:	4619      	mov	r1, r3
 801c60c:	4610      	mov	r0, r2
 801c60e:	f00a fa92 	bl	8026b36 <mp_copy>
 801c612:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c614:	69fb      	ldr	r3, [r7, #28]
 801c616:	2b00      	cmp	r3, #0
 801c618:	d12a      	bne.n	801c670 <ecc_point_to_mont+0xf6>
                   err = mp_copy(p->z, r->z);
 801c61a:	68fb      	ldr	r3, [r7, #12]
 801c61c:	689a      	ldr	r2, [r3, #8]
 801c61e:	68bb      	ldr	r3, [r7, #8]
 801c620:	689b      	ldr	r3, [r3, #8]
 801c622:	4619      	mov	r1, r3
 801c624:	4610      	mov	r0, r2
 801c626:	f00a fa86 	bl	8026b36 <mp_copy>
 801c62a:	61f8      	str	r0, [r7, #28]
 801c62c:	e020      	b.n	801c670 <ecc_point_to_mont+0xf6>
           }
           else {
               err = mp_mulmod(p->x, mu, modulus, r->x);
 801c62e:	68fb      	ldr	r3, [r7, #12]
 801c630:	6818      	ldr	r0, [r3, #0]
 801c632:	68bb      	ldr	r3, [r7, #8]
 801c634:	681b      	ldr	r3, [r3, #0]
 801c636:	687a      	ldr	r2, [r7, #4]
 801c638:	69b9      	ldr	r1, [r7, #24]
 801c63a:	f00a f934 	bl	80268a6 <mp_mulmod>
 801c63e:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c640:	69fb      	ldr	r3, [r7, #28]
 801c642:	2b00      	cmp	r3, #0
 801c644:	d108      	bne.n	801c658 <ecc_point_to_mont+0xde>
                   err = mp_mulmod(p->y, mu, modulus, r->y);
 801c646:	68fb      	ldr	r3, [r7, #12]
 801c648:	6858      	ldr	r0, [r3, #4]
 801c64a:	68bb      	ldr	r3, [r7, #8]
 801c64c:	685b      	ldr	r3, [r3, #4]
 801c64e:	687a      	ldr	r2, [r7, #4]
 801c650:	69b9      	ldr	r1, [r7, #24]
 801c652:	f00a f928 	bl	80268a6 <mp_mulmod>
 801c656:	61f8      	str	r0, [r7, #28]
               if (err == MP_OKAY)
 801c658:	69fb      	ldr	r3, [r7, #28]
 801c65a:	2b00      	cmp	r3, #0
 801c65c:	d108      	bne.n	801c670 <ecc_point_to_mont+0xf6>
                   err = mp_mulmod(p->z, mu, modulus, r->z);
 801c65e:	68fb      	ldr	r3, [r7, #12]
 801c660:	6898      	ldr	r0, [r3, #8]
 801c662:	68bb      	ldr	r3, [r7, #8]
 801c664:	689b      	ldr	r3, [r3, #8]
 801c666:	687a      	ldr	r2, [r7, #4]
 801c668:	69b9      	ldr	r1, [r7, #24]
 801c66a:	f00a f91c 	bl	80268a6 <mp_mulmod>
 801c66e:	61f8      	str	r0, [r7, #28]
           }
       }

       mp_clear(mu);
 801c670:	69b8      	ldr	r0, [r7, #24]
 801c672:	f00a f89e 	bl	80267b2 <mp_clear>
   }

   FREE_MP_INT_SIZE(mu, heap, DYNAMIC_TYPE_ECC);
 801c676:	69bb      	ldr	r3, [r7, #24]
 801c678:	617b      	str	r3, [r7, #20]
 801c67a:	697b      	ldr	r3, [r7, #20]
 801c67c:	2b00      	cmp	r3, #0
 801c67e:	d002      	beq.n	801c686 <ecc_point_to_mont+0x10c>
 801c680:	6978      	ldr	r0, [r7, #20]
 801c682:	f002 fa23 	bl	801eacc <wolfSSL_Free>
   return err;
 801c686:	69fb      	ldr	r3, [r7, #28]
}
 801c688:	4618      	mov	r0, r3
 801c68a:	3720      	adds	r7, #32
 801c68c:	46bd      	mov	sp, r7
 801c68e:	bd80      	pop	{r7, pc}

0801c690 <ecc_check_order_minus_1>:
#ifndef FP_ECC
#if !defined(WOLFSSL_SP_MATH)
#ifdef ECC_TIMING_RESISTANT
static int ecc_check_order_minus_1(const mp_int* k, ecc_point* tG, ecc_point* R,
   mp_int* modulus, mp_int* order)
{
 801c690:	b580      	push	{r7, lr}
 801c692:	b088      	sub	sp, #32
 801c694:	af00      	add	r7, sp, #0
 801c696:	60f8      	str	r0, [r7, #12]
 801c698:	60b9      	str	r1, [r7, #8]
 801c69a:	607a      	str	r2, [r7, #4]
 801c69c:	603b      	str	r3, [r7, #0]
    int err;
    DECL_MP_INT_SIZE_DYN(t, mp_bitsused(order), MAX_ECC_BITS_USE);
 801c69e:	2300      	movs	r3, #0
 801c6a0:	61bb      	str	r3, [r7, #24]

    NEW_MP_INT_SIZE(t, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
 801c6a2:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801c6a6:	f002 f9f5 	bl	801ea94 <wolfSSL_Malloc>
 801c6aa:	61b8      	str	r0, [r7, #24]
 801c6ac:	69bb      	ldr	r3, [r7, #24]
 801c6ae:	2b00      	cmp	r3, #0
 801c6b0:	d005      	beq.n	801c6be <ecc_check_order_minus_1+0x2e>
 801c6b2:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801c6b6:	2100      	movs	r1, #0
 801c6b8:	69b8      	ldr	r0, [r7, #24]
 801c6ba:	f00b ff09 	bl	80284d0 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (t == NULL) {
 801c6be:	69bb      	ldr	r3, [r7, #24]
 801c6c0:	2b00      	cmp	r3, #0
 801c6c2:	d103      	bne.n	801c6cc <ecc_check_order_minus_1+0x3c>
        err = MEMORY_E;
 801c6c4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c6c8:	61fb      	str	r3, [r7, #28]
 801c6ca:	e003      	b.n	801c6d4 <ecc_check_order_minus_1+0x44>
    }
    else
#endif
    {
        err = INIT_MP_INT_SIZE(t, mp_bitsused(modulus));
 801c6cc:	69b8      	ldr	r0, [r7, #24]
 801c6ce:	f009 ffe6 	bl	802669e <mp_init>
 801c6d2:	61f8      	str	r0, [r7, #28]
    }
    if (err == MP_OKAY) {
 801c6d4:	69fb      	ldr	r3, [r7, #28]
 801c6d6:	2b00      	cmp	r3, #0
 801c6d8:	d141      	bne.n	801c75e <ecc_check_order_minus_1+0xce>
        /* Check for k == order - 1. Result will be 0 point which is not correct
         * Calculates order / 2 and adds order / 2 + 1 and gets infinity.
         * (with constant time implementation)
         */
        err = mp_sub_d(order, 1, t);
 801c6da:	69ba      	ldr	r2, [r7, #24]
 801c6dc:	2101      	movs	r1, #1
 801c6de:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801c6e0:	f00a f9c6 	bl	8026a70 <mp_sub_d>
 801c6e4:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY) {
 801c6e6:	69fb      	ldr	r3, [r7, #28]
 801c6e8:	2b00      	cmp	r3, #0
 801c6ea:	d135      	bne.n	801c758 <ecc_check_order_minus_1+0xc8>
            int kIsMinusOne = (mp_cmp((mp_int*)k, t) == MP_EQ);
 801c6ec:	69b9      	ldr	r1, [r7, #24]
 801c6ee:	68f8      	ldr	r0, [r7, #12]
 801c6f0:	f00a f968 	bl	80269c4 <mp_cmp>
 801c6f4:	4603      	mov	r3, r0
 801c6f6:	2b00      	cmp	r3, #0
 801c6f8:	bf0c      	ite	eq
 801c6fa:	2301      	moveq	r3, #1
 801c6fc:	2300      	movne	r3, #0
 801c6fe:	b2db      	uxtb	r3, r3
 801c700:	617b      	str	r3, [r7, #20]
            err = mp_cond_copy(tG->x, kIsMinusOne, R->x);
 801c702:	68bb      	ldr	r3, [r7, #8]
 801c704:	6818      	ldr	r0, [r3, #0]
 801c706:	687b      	ldr	r3, [r7, #4]
 801c708:	681b      	ldr	r3, [r3, #0]
 801c70a:	461a      	mov	r2, r3
 801c70c:	6979      	ldr	r1, [r7, #20]
 801c70e:	f00a fefc 	bl	802750a <mp_cond_copy>
 801c712:	61f8      	str	r0, [r7, #28]
            if (err == MP_OKAY) {
 801c714:	69fb      	ldr	r3, [r7, #28]
 801c716:	2b00      	cmp	r3, #0
 801c718:	d107      	bne.n	801c72a <ecc_check_order_minus_1+0x9a>
                err = mp_sub(modulus, tG->y, t);
 801c71a:	68bb      	ldr	r3, [r7, #8]
 801c71c:	685b      	ldr	r3, [r3, #4]
 801c71e:	69ba      	ldr	r2, [r7, #24]
 801c720:	4619      	mov	r1, r3
 801c722:	6838      	ldr	r0, [r7, #0]
 801c724:	f00a f89f 	bl	8026866 <mp_sub>
 801c728:	61f8      	str	r0, [r7, #28]
            }
            if (err == MP_OKAY) {
 801c72a:	69fb      	ldr	r3, [r7, #28]
 801c72c:	2b00      	cmp	r3, #0
 801c72e:	d107      	bne.n	801c740 <ecc_check_order_minus_1+0xb0>
                err = mp_cond_copy(t, kIsMinusOne, R->y);
 801c730:	687b      	ldr	r3, [r7, #4]
 801c732:	685b      	ldr	r3, [r3, #4]
 801c734:	461a      	mov	r2, r3
 801c736:	6979      	ldr	r1, [r7, #20]
 801c738:	69b8      	ldr	r0, [r7, #24]
 801c73a:	f00a fee6 	bl	802750a <mp_cond_copy>
 801c73e:	61f8      	str	r0, [r7, #28]
            }
            if (err == MP_OKAY) {
 801c740:	69fb      	ldr	r3, [r7, #28]
 801c742:	2b00      	cmp	r3, #0
 801c744:	d108      	bne.n	801c758 <ecc_check_order_minus_1+0xc8>
                err = mp_cond_copy(tG->z, kIsMinusOne, R->z);
 801c746:	68bb      	ldr	r3, [r7, #8]
 801c748:	6898      	ldr	r0, [r3, #8]
 801c74a:	687b      	ldr	r3, [r7, #4]
 801c74c:	689b      	ldr	r3, [r3, #8]
 801c74e:	461a      	mov	r2, r3
 801c750:	6979      	ldr	r1, [r7, #20]
 801c752:	f00a feda 	bl	802750a <mp_cond_copy>
 801c756:	61f8      	str	r0, [r7, #28]
            }
        }

        mp_free(t);
 801c758:	69b8      	ldr	r0, [r7, #24]
 801c75a:	f00a f839 	bl	80267d0 <mp_free>
    }

    FREE_MP_INT_SIZE(t, NULL, DYNAMIC_TYPE_ECC);
 801c75e:	69bb      	ldr	r3, [r7, #24]
 801c760:	613b      	str	r3, [r7, #16]
 801c762:	693b      	ldr	r3, [r7, #16]
 801c764:	2b00      	cmp	r3, #0
 801c766:	d002      	beq.n	801c76e <ecc_check_order_minus_1+0xde>
 801c768:	6938      	ldr	r0, [r7, #16]
 801c76a:	f002 f9af 	bl	801eacc <wolfSSL_Free>
    return err;
 801c76e:	69fb      	ldr	r3, [r7, #28]
}
 801c770:	4618      	mov	r0, r3
 801c772:	3720      	adds	r7, #32
 801c774:	46bd      	mov	sp, r7
 801c776:	bd80      	pop	{r7, pc}

0801c778 <wc_ecc_mulmod_ex2>:
*/
int wc_ecc_mulmod_ex2(const mp_int* k, ecc_point* G, ecc_point* R, mp_int* a,
                      mp_int* modulus, mp_int* order, WC_RNG* rng, int map,
                      void* heap)
#if !defined(WOLFSSL_SP_MATH)
{
 801c778:	b590      	push	{r4, r7, lr}
 801c77a:	b091      	sub	sp, #68	@ 0x44
 801c77c:	af04      	add	r7, sp, #16
 801c77e:	60f8      	str	r0, [r7, #12]
 801c780:	60b9      	str	r1, [r7, #8]
 801c782:	607a      	str	r2, [r7, #4]
 801c784:	603b      	str	r3, [r7, #0]
#ifdef WOLFSSL_SMALL_STACK_CACHE
   ecc_key       key;
#endif
   mp_digit      mp;

   if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
 801c786:	68fb      	ldr	r3, [r7, #12]
 801c788:	2b00      	cmp	r3, #0
 801c78a:	d008      	beq.n	801c79e <wc_ecc_mulmod_ex2+0x26>
 801c78c:	68bb      	ldr	r3, [r7, #8]
 801c78e:	2b00      	cmp	r3, #0
 801c790:	d005      	beq.n	801c79e <wc_ecc_mulmod_ex2+0x26>
 801c792:	687b      	ldr	r3, [r7, #4]
 801c794:	2b00      	cmp	r3, #0
 801c796:	d002      	beq.n	801c79e <wc_ecc_mulmod_ex2+0x26>
 801c798:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c79a:	2b00      	cmp	r3, #0
 801c79c:	d102      	bne.n	801c7a4 <wc_ecc_mulmod_ex2+0x2c>
      return ECC_BAD_ARG_E;
 801c79e:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801c7a2:	e096      	b.n	801c8d2 <wc_ecc_mulmod_ex2+0x15a>
      }
   }
   else
#endif
   /* k can't have more bits than order */
   if (mp_count_bits(k) > mp_count_bits(order)) {
 801c7a4:	68f8      	ldr	r0, [r7, #12]
 801c7a6:	f00a f9e5 	bl	8026b74 <mp_count_bits>
 801c7aa:	4604      	mov	r4, r0
 801c7ac:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c7ae:	f00a f9e1 	bl	8026b74 <mp_count_bits>
 801c7b2:	4603      	mov	r3, r0
 801c7b4:	429c      	cmp	r4, r3
 801c7b6:	dd02      	ble.n	801c7be <wc_ecc_mulmod_ex2+0x46>
      WOLFSSL_MSG("Private key length is greater than order in bits.");
      return ECC_OUT_OF_RANGE_E;
 801c7b8:	f06f 03d8 	mvn.w	r3, #216	@ 0xd8
 801c7bc:	e089      	b.n	801c8d2 <wc_ecc_mulmod_ex2+0x15a>
   }

   /* init variables */
   tG = NULL;
 801c7be:	2300      	movs	r3, #0
 801c7c0:	627b      	str	r3, [r7, #36]	@ 0x24
   XMEMSET(M, 0, sizeof(M));
 801c7c2:	f107 0318 	add.w	r3, r7, #24
 801c7c6:	220c      	movs	r2, #12
 801c7c8:	2100      	movs	r1, #0
 801c7ca:	4618      	mov	r0, r3
 801c7cc:	f00b fe80 	bl	80284d0 <memset>
      goto exit;
   R->key = &key;
#endif /* WOLFSSL_SMALL_STACK_CACHE */

   /* alloc ram for window temps */
   for (i = 0; i < M_POINTS; i++) {
 801c7d0:	2300      	movs	r3, #0
 801c7d2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c7d4:	e00f      	b.n	801c7f6 <wc_ecc_mulmod_ex2+0x7e>
   #ifdef WOLFSSL_NO_MALLOC
      M[i] = &lcl_M[i];
   #endif
      err = wc_ecc_new_point_ex(&M[i], heap);
 801c7d6:	f107 0218 	add.w	r2, r7, #24
 801c7da:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c7dc:	009b      	lsls	r3, r3, #2
 801c7de:	4413      	add	r3, r2
 801c7e0:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801c7e2:	4618      	mov	r0, r3
 801c7e4:	f000 f879 	bl	801c8da <wc_ecc_new_point_ex>
 801c7e8:	62b8      	str	r0, [r7, #40]	@ 0x28
      if (err != MP_OKAY) {
 801c7ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c7ec:	2b00      	cmp	r3, #0
 801c7ee:	d14e      	bne.n	801c88e <wc_ecc_mulmod_ex2+0x116>
   for (i = 0; i < M_POINTS; i++) {
 801c7f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c7f2:	3301      	adds	r3, #1
 801c7f4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c7f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c7f8:	2b02      	cmp	r3, #2
 801c7fa:	ddec      	ble.n	801c7d6 <wc_ecc_mulmod_ex2+0x5e>

   /* make a copy of G in case R==G */
#ifdef WOLFSSL_NO_MALLOC
   tG = &lcl_tG;
#endif
   err = wc_ecc_new_point_ex(&tG, heap);
 801c7fc:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 801c800:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801c802:	4618      	mov	r0, r3
 801c804:	f000 f869 	bl	801c8da <wc_ecc_new_point_ex>
 801c808:	62b8      	str	r0, [r7, #40]	@ 0x28
   if (err != MP_OKAY) {
 801c80a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c80c:	2b00      	cmp	r3, #0
 801c80e:	d140      	bne.n	801c892 <wc_ecc_mulmod_ex2+0x11a>
       goto exit;
   }
   if ((err = ecc_point_to_mont(G, tG, modulus, heap)) != MP_OKAY) {
 801c810:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c812:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801c814:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801c816:	68b8      	ldr	r0, [r7, #8]
 801c818:	f7ff feaf 	bl	801c57a <ecc_point_to_mont>
 801c81c:	62b8      	str	r0, [r7, #40]	@ 0x28
 801c81e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c820:	2b00      	cmp	r3, #0
 801c822:	d138      	bne.n	801c896 <wc_ecc_mulmod_ex2+0x11e>
       goto exit;
   }

   /* init montgomery reduction */
   if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {
 801c824:	f107 0314 	add.w	r3, r7, #20
 801c828:	4619      	mov	r1, r3
 801c82a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801c82c:	f00a fc14 	bl	8027058 <mp_montgomery_setup>
 801c830:	62b8      	str	r0, [r7, #40]	@ 0x28
 801c832:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c834:	2b00      	cmp	r3, #0
 801c836:	d130      	bne.n	801c89a <wc_ecc_mulmod_ex2+0x122>
      goto exit;
   }

   err = ecc_mulmod(k, tG, R, M, a, modulus, mp, rng);
 801c838:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c83a:	697b      	ldr	r3, [r7, #20]
 801c83c:	f107 0018 	add.w	r0, r7, #24
 801c840:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801c842:	9203      	str	r2, [sp, #12]
 801c844:	9302      	str	r3, [sp, #8]
 801c846:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c848:	9301      	str	r3, [sp, #4]
 801c84a:	683b      	ldr	r3, [r7, #0]
 801c84c:	9300      	str	r3, [sp, #0]
 801c84e:	4603      	mov	r3, r0
 801c850:	687a      	ldr	r2, [r7, #4]
 801c852:	68f8      	ldr	r0, [r7, #12]
 801c854:	f7ff fc08 	bl	801c068 <ecc_mulmod>
 801c858:	62b8      	str	r0, [r7, #40]	@ 0x28
#ifdef ECC_TIMING_RESISTANT
   if (err == MP_OKAY) {
 801c85a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c85c:	2b00      	cmp	r3, #0
 801c85e:	d108      	bne.n	801c872 <wc_ecc_mulmod_ex2+0xfa>
       err = ecc_check_order_minus_1(k, tG, R, modulus, order);
 801c860:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c862:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801c864:	9300      	str	r3, [sp, #0]
 801c866:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801c868:	687a      	ldr	r2, [r7, #4]
 801c86a:	68f8      	ldr	r0, [r7, #12]
 801c86c:	f7ff ff10 	bl	801c690 <ecc_check_order_minus_1>
 801c870:	62b8      	str	r0, [r7, #40]	@ 0x28
   }
#else
   (void)order;
#endif
   /* map R back from projective space */
   if (err == MP_OKAY && map)
 801c872:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c874:	2b00      	cmp	r3, #0
 801c876:	d112      	bne.n	801c89e <wc_ecc_mulmod_ex2+0x126>
 801c878:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801c87a:	2b00      	cmp	r3, #0
 801c87c:	d00f      	beq.n	801c89e <wc_ecc_mulmod_ex2+0x126>
      err = ecc_map(R, modulus, mp);
 801c87e:	697b      	ldr	r3, [r7, #20]
 801c880:	461a      	mov	r2, r3
 801c882:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 801c884:	6878      	ldr	r0, [r7, #4]
 801c886:	f7ff fb4f 	bl	801bf28 <ecc_map>
 801c88a:	62b8      	str	r0, [r7, #40]	@ 0x28
 801c88c:	e008      	b.n	801c8a0 <wc_ecc_mulmod_ex2+0x128>
         goto exit;
 801c88e:	bf00      	nop
 801c890:	e006      	b.n	801c8a0 <wc_ecc_mulmod_ex2+0x128>
       goto exit;
 801c892:	bf00      	nop
 801c894:	e004      	b.n	801c8a0 <wc_ecc_mulmod_ex2+0x128>
       goto exit;
 801c896:	bf00      	nop
 801c898:	e002      	b.n	801c8a0 <wc_ecc_mulmod_ex2+0x128>
      goto exit;
 801c89a:	bf00      	nop
 801c89c:	e000      	b.n	801c8a0 <wc_ecc_mulmod_ex2+0x128>

exit:
 801c89e:	bf00      	nop

   /* done */
   wc_ecc_del_point_ex(tG, heap);
 801c8a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c8a2:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801c8a4:	4618      	mov	r0, r3
 801c8a6:	f000 f86d 	bl	801c984 <wc_ecc_del_point_ex>
   for (i = 0; i < M_POINTS; i++) {
 801c8aa:	2300      	movs	r3, #0
 801c8ac:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c8ae:	e00c      	b.n	801c8ca <wc_ecc_mulmod_ex2+0x152>
      wc_ecc_del_point_ex(M[i], heap);
 801c8b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c8b2:	009b      	lsls	r3, r3, #2
 801c8b4:	3330      	adds	r3, #48	@ 0x30
 801c8b6:	443b      	add	r3, r7
 801c8b8:	f853 3c18 	ldr.w	r3, [r3, #-24]
 801c8bc:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801c8be:	4618      	mov	r0, r3
 801c8c0:	f000 f860 	bl	801c984 <wc_ecc_del_point_ex>
   for (i = 0; i < M_POINTS; i++) {
 801c8c4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c8c6:	3301      	adds	r3, #1
 801c8c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c8ca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c8cc:	2b02      	cmp	r3, #2
 801c8ce:	ddef      	ble.n	801c8b0 <wc_ecc_mulmod_ex2+0x138>
#ifdef WOLFSSL_SMALL_STACK_CACHE
   R->key = NULL;
   ecc_key_tmp_final(&key, heap);
#endif /* WOLFSSL_SMALL_STACK_CACHE */

   return err;
 801c8d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
}
 801c8d2:	4618      	mov	r0, r3
 801c8d4:	3734      	adds	r7, #52	@ 0x34
 801c8d6:	46bd      	mov	sp, r7
 801c8d8:	bd90      	pop	{r4, r7, pc}

0801c8da <wc_ecc_new_point_ex>:
 * Allocate a new ECC point (if one not provided)
 * use a heap hint when creating new ecc_point
 * return an allocated point on success or NULL on failure
*/
static int wc_ecc_new_point_ex(ecc_point** point, void* heap)
{
 801c8da:	b580      	push	{r7, lr}
 801c8dc:	b084      	sub	sp, #16
 801c8de:	af00      	add	r7, sp, #0
 801c8e0:	6078      	str	r0, [r7, #4]
 801c8e2:	6039      	str	r1, [r7, #0]
   int err = MP_OKAY;
 801c8e4:	2300      	movs	r3, #0
 801c8e6:	60bb      	str	r3, [r7, #8]
   ecc_point* p;

   if (point == NULL) {
 801c8e8:	687b      	ldr	r3, [r7, #4]
 801c8ea:	2b00      	cmp	r3, #0
 801c8ec:	d102      	bne.n	801c8f4 <wc_ecc_new_point_ex+0x1a>
       return BAD_FUNC_ARG;
 801c8ee:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801c8f2:	e043      	b.n	801c97c <wc_ecc_new_point_ex+0xa2>
   }

   p = *point;
 801c8f4:	687b      	ldr	r3, [r7, #4]
 801c8f6:	681b      	ldr	r3, [r3, #0]
 801c8f8:	60fb      	str	r3, [r7, #12]
   if (p == NULL) {
 801c8fa:	68fb      	ldr	r3, [r7, #12]
 801c8fc:	2b00      	cmp	r3, #0
 801c8fe:	d104      	bne.n	801c90a <wc_ecc_new_point_ex+0x30>
      p = (ecc_point*)XMALLOC(sizeof(ecc_point), heap, DYNAMIC_TYPE_ECC);
 801c900:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801c904:	f002 f8c6 	bl	801ea94 <wolfSSL_Malloc>
 801c908:	60f8      	str	r0, [r7, #12]
   }
   if (p == NULL) {
 801c90a:	68fb      	ldr	r3, [r7, #12]
 801c90c:	2b00      	cmp	r3, #0
 801c90e:	d102      	bne.n	801c916 <wc_ecc_new_point_ex+0x3c>
      return MEMORY_E;
 801c910:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801c914:	e032      	b.n	801c97c <wc_ecc_new_point_ex+0xa2>
   }
   XMEMSET(p, 0, sizeof(ecc_point));
 801c916:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801c91a:	2100      	movs	r1, #0
 801c91c:	68f8      	ldr	r0, [r7, #12]
 801c91e:	f00b fdd7 	bl	80284d0 <memset>

   if (*point == NULL)
 801c922:	687b      	ldr	r3, [r7, #4]
 801c924:	681b      	ldr	r3, [r3, #0]
 801c926:	2b00      	cmp	r3, #0
 801c928:	d106      	bne.n	801c938 <wc_ecc_new_point_ex+0x5e>
       p->isAllocated = 1;
 801c92a:	68fa      	ldr	r2, [r7, #12]
 801c92c:	f892 30fc 	ldrb.w	r3, [r2, #252]	@ 0xfc
 801c930:	f043 0301 	orr.w	r3, r3, #1
 801c934:	f882 30fc 	strb.w	r3, [r2, #252]	@ 0xfc
      if (p->isAllocated)
          XFREE(p, heap, DYNAMIC_TYPE_ECC);
      p = NULL;
   }
#else
   p->x = (mp_int*)&p->xyz[0];
 801c938:	68fb      	ldr	r3, [r7, #12]
 801c93a:	f103 020c 	add.w	r2, r3, #12
 801c93e:	68fb      	ldr	r3, [r7, #12]
 801c940:	601a      	str	r2, [r3, #0]
   p->y = (mp_int*)&p->xyz[1];
 801c942:	68fb      	ldr	r3, [r7, #12]
 801c944:	f103 025c 	add.w	r2, r3, #92	@ 0x5c
 801c948:	68fb      	ldr	r3, [r7, #12]
 801c94a:	605a      	str	r2, [r3, #4]
   p->z = (mp_int*)&p->xyz[2];
 801c94c:	68fb      	ldr	r3, [r7, #12]
 801c94e:	f103 02ac 	add.w	r2, r3, #172	@ 0xac
 801c952:	68fb      	ldr	r3, [r7, #12]
 801c954:	609a      	str	r2, [r3, #8]
   alt_fp_init(p->x);
 801c956:	68fb      	ldr	r3, [r7, #12]
 801c958:	681b      	ldr	r3, [r3, #0]
 801c95a:	4618      	mov	r0, r3
 801c95c:	f7fe f916 	bl	801ab8c <alt_fp_init>
   alt_fp_init(p->y);
 801c960:	68fb      	ldr	r3, [r7, #12]
 801c962:	685b      	ldr	r3, [r3, #4]
 801c964:	4618      	mov	r0, r3
 801c966:	f7fe f911 	bl	801ab8c <alt_fp_init>
   alt_fp_init(p->z);
 801c96a:	68fb      	ldr	r3, [r7, #12]
 801c96c:	689b      	ldr	r3, [r3, #8]
 801c96e:	4618      	mov	r0, r3
 801c970:	f7fe f90c 	bl	801ab8c <alt_fp_init>
#endif

   *point = p;
 801c974:	687b      	ldr	r3, [r7, #4]
 801c976:	68fa      	ldr	r2, [r7, #12]
 801c978:	601a      	str	r2, [r3, #0]
   (void)heap;
   return err;
 801c97a:	68bb      	ldr	r3, [r7, #8]
} /* wc_ecc_new_point_ex */
 801c97c:	4618      	mov	r0, r3
 801c97e:	3710      	adds	r7, #16
 801c980:	46bd      	mov	sp, r7
 801c982:	bd80      	pop	{r7, pc}

0801c984 <wc_ecc_del_point_ex>:

/** Free an ECC point from memory
  p   The point to free
*/
static void wc_ecc_del_point_ex(ecc_point* p, void* heap)
{
 801c984:	b580      	push	{r7, lr}
 801c986:	b084      	sub	sp, #16
 801c988:	af00      	add	r7, sp, #0
 801c98a:	6078      	str	r0, [r7, #4]
 801c98c:	6039      	str	r1, [r7, #0]
   if (p != NULL) {
 801c98e:	687b      	ldr	r3, [r7, #4]
 801c990:	2b00      	cmp	r3, #0
 801c992:	d01e      	beq.n	801c9d2 <wc_ecc_del_point_ex+0x4e>
      mp_clear(p->x);
 801c994:	687b      	ldr	r3, [r7, #4]
 801c996:	681b      	ldr	r3, [r3, #0]
 801c998:	4618      	mov	r0, r3
 801c99a:	f009 ff0a 	bl	80267b2 <mp_clear>
      mp_clear(p->y);
 801c99e:	687b      	ldr	r3, [r7, #4]
 801c9a0:	685b      	ldr	r3, [r3, #4]
 801c9a2:	4618      	mov	r0, r3
 801c9a4:	f009 ff05 	bl	80267b2 <mp_clear>
      mp_clear(p->z);
 801c9a8:	687b      	ldr	r3, [r7, #4]
 801c9aa:	689b      	ldr	r3, [r3, #8]
 801c9ac:	4618      	mov	r0, r3
 801c9ae:	f009 ff00 	bl	80267b2 <mp_clear>
      if (p->isAllocated)
 801c9b2:	687b      	ldr	r3, [r7, #4]
 801c9b4:	f893 30fc 	ldrb.w	r3, [r3, #252]	@ 0xfc
 801c9b8:	f003 0301 	and.w	r3, r3, #1
 801c9bc:	b2db      	uxtb	r3, r3
 801c9be:	2b00      	cmp	r3, #0
 801c9c0:	d007      	beq.n	801c9d2 <wc_ecc_del_point_ex+0x4e>
          XFREE(p, heap, DYNAMIC_TYPE_ECC);
 801c9c2:	687b      	ldr	r3, [r7, #4]
 801c9c4:	60fb      	str	r3, [r7, #12]
 801c9c6:	68fb      	ldr	r3, [r7, #12]
 801c9c8:	2b00      	cmp	r3, #0
 801c9ca:	d002      	beq.n	801c9d2 <wc_ecc_del_point_ex+0x4e>
 801c9cc:	68f8      	ldr	r0, [r7, #12]
 801c9ce:	f002 f87d 	bl	801eacc <wolfSSL_Free>
   }
   (void)heap;
}
 801c9d2:	bf00      	nop
 801c9d4:	3710      	adds	r7, #16
 801c9d6:	46bd      	mov	sp, r7
 801c9d8:	bd80      	pop	{r7, pc}

0801c9da <wc_ecc_del_point>:
void wc_ecc_del_point_h(ecc_point* p, void* heap)
{
   wc_ecc_del_point_ex(p, heap);
}
void wc_ecc_del_point(ecc_point* p)
{
 801c9da:	b580      	push	{r7, lr}
 801c9dc:	b082      	sub	sp, #8
 801c9de:	af00      	add	r7, sp, #0
 801c9e0:	6078      	str	r0, [r7, #4]
    wc_ecc_del_point_ex(p, NULL);
 801c9e2:	2100      	movs	r1, #0
 801c9e4:	6878      	ldr	r0, [r7, #4]
 801c9e6:	f7ff ffcd 	bl	801c984 <wc_ecc_del_point_ex>
}
 801c9ea:	bf00      	nop
 801c9ec:	3708      	adds	r7, #8
 801c9ee:	46bd      	mov	sp, r7
 801c9f0:	bd80      	pop	{r7, pc}

0801c9f2 <wc_ecc_copy_point>:
/** Copy the value of a point to an other one
  p    The point to copy
  r    The created point
*/
int wc_ecc_copy_point(const ecc_point* p, ecc_point *r)
{
 801c9f2:	b580      	push	{r7, lr}
 801c9f4:	b084      	sub	sp, #16
 801c9f6:	af00      	add	r7, sp, #0
 801c9f8:	6078      	str	r0, [r7, #4]
 801c9fa:	6039      	str	r1, [r7, #0]
    int ret;

    /* prevents null arguments */
    if (p == NULL || r == NULL)
 801c9fc:	687b      	ldr	r3, [r7, #4]
 801c9fe:	2b00      	cmp	r3, #0
 801ca00:	d002      	beq.n	801ca08 <wc_ecc_copy_point+0x16>
 801ca02:	683b      	ldr	r3, [r7, #0]
 801ca04:	2b00      	cmp	r3, #0
 801ca06:	d102      	bne.n	801ca0e <wc_ecc_copy_point+0x1c>
        return ECC_BAD_ARG_E;
 801ca08:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801ca0c:	e02a      	b.n	801ca64 <wc_ecc_copy_point+0x72>

    ret = mp_copy(p->x, r->x);
 801ca0e:	687b      	ldr	r3, [r7, #4]
 801ca10:	681a      	ldr	r2, [r3, #0]
 801ca12:	683b      	ldr	r3, [r7, #0]
 801ca14:	681b      	ldr	r3, [r3, #0]
 801ca16:	4619      	mov	r1, r3
 801ca18:	4610      	mov	r0, r2
 801ca1a:	f00a f88c 	bl	8026b36 <mp_copy>
 801ca1e:	60f8      	str	r0, [r7, #12]
    if (ret != MP_OKAY)
 801ca20:	68fb      	ldr	r3, [r7, #12]
 801ca22:	2b00      	cmp	r3, #0
 801ca24:	d001      	beq.n	801ca2a <wc_ecc_copy_point+0x38>
        return ret;
 801ca26:	68fb      	ldr	r3, [r7, #12]
 801ca28:	e01c      	b.n	801ca64 <wc_ecc_copy_point+0x72>
    ret = mp_copy(p->y, r->y);
 801ca2a:	687b      	ldr	r3, [r7, #4]
 801ca2c:	685a      	ldr	r2, [r3, #4]
 801ca2e:	683b      	ldr	r3, [r7, #0]
 801ca30:	685b      	ldr	r3, [r3, #4]
 801ca32:	4619      	mov	r1, r3
 801ca34:	4610      	mov	r0, r2
 801ca36:	f00a f87e 	bl	8026b36 <mp_copy>
 801ca3a:	60f8      	str	r0, [r7, #12]
    if (ret != MP_OKAY)
 801ca3c:	68fb      	ldr	r3, [r7, #12]
 801ca3e:	2b00      	cmp	r3, #0
 801ca40:	d001      	beq.n	801ca46 <wc_ecc_copy_point+0x54>
        return ret;
 801ca42:	68fb      	ldr	r3, [r7, #12]
 801ca44:	e00e      	b.n	801ca64 <wc_ecc_copy_point+0x72>
    ret = mp_copy(p->z, r->z);
 801ca46:	687b      	ldr	r3, [r7, #4]
 801ca48:	689a      	ldr	r2, [r3, #8]
 801ca4a:	683b      	ldr	r3, [r7, #0]
 801ca4c:	689b      	ldr	r3, [r3, #8]
 801ca4e:	4619      	mov	r1, r3
 801ca50:	4610      	mov	r0, r2
 801ca52:	f00a f870 	bl	8026b36 <mp_copy>
 801ca56:	60f8      	str	r0, [r7, #12]
    if (ret != MP_OKAY)
 801ca58:	68fb      	ldr	r3, [r7, #12]
 801ca5a:	2b00      	cmp	r3, #0
 801ca5c:	d001      	beq.n	801ca62 <wc_ecc_copy_point+0x70>
        return ret;
 801ca5e:	68fb      	ldr	r3, [r7, #12]
 801ca60:	e000      	b.n	801ca64 <wc_ecc_copy_point+0x72>

    return MP_OKAY;
 801ca62:	2300      	movs	r3, #0
}
 801ca64:	4618      	mov	r0, r3
 801ca66:	3710      	adds	r7, #16
 801ca68:	46bd      	mov	sp, r7
 801ca6a:	bd80      	pop	{r7, pc}

0801ca6c <wc_ecc_is_valid_idx>:
/** Returns whether an ECC idx is valid or not
  n      The idx number to check
  return 1 if valid, 0 if not
*/
int wc_ecc_is_valid_idx(int n)
{
 801ca6c:	b480      	push	{r7}
 801ca6e:	b085      	sub	sp, #20
 801ca70:	af00      	add	r7, sp, #0
 801ca72:	6078      	str	r0, [r7, #4]
   int x;

   if (n >= (int)ECC_SET_COUNT)
 801ca74:	687b      	ldr	r3, [r7, #4]
 801ca76:	2b01      	cmp	r3, #1
 801ca78:	dd01      	ble.n	801ca7e <wc_ecc_is_valid_idx+0x12>
       return 0;
 801ca7a:	2300      	movs	r3, #0
 801ca7c:	e019      	b.n	801cab2 <wc_ecc_is_valid_idx+0x46>

   for (x = 0; ecc_sets[x].size != 0; x++)
 801ca7e:	2300      	movs	r3, #0
 801ca80:	60fb      	str	r3, [r7, #12]
 801ca82:	e002      	b.n	801ca8a <wc_ecc_is_valid_idx+0x1e>
 801ca84:	68fb      	ldr	r3, [r7, #12]
 801ca86:	3301      	adds	r3, #1
 801ca88:	60fb      	str	r3, [r7, #12]
 801ca8a:	4a0d      	ldr	r2, [pc, #52]	@ (801cac0 <wc_ecc_is_valid_idx+0x54>)
 801ca8c:	68fb      	ldr	r3, [r7, #12]
 801ca8e:	2134      	movs	r1, #52	@ 0x34
 801ca90:	fb01 f303 	mul.w	r3, r1, r3
 801ca94:	4413      	add	r3, r2
 801ca96:	681b      	ldr	r3, [r3, #0]
 801ca98:	2b00      	cmp	r3, #0
 801ca9a:	d1f3      	bne.n	801ca84 <wc_ecc_is_valid_idx+0x18>
       ;
   /* -1 is a valid index --- indicating that the domain params
      were supplied by the user */
   if ((n >= ECC_CUSTOM_IDX) && (n < x)) {
 801ca9c:	687b      	ldr	r3, [r7, #4]
 801ca9e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801caa2:	db05      	blt.n	801cab0 <wc_ecc_is_valid_idx+0x44>
 801caa4:	687a      	ldr	r2, [r7, #4]
 801caa6:	68fb      	ldr	r3, [r7, #12]
 801caa8:	429a      	cmp	r2, r3
 801caaa:	da01      	bge.n	801cab0 <wc_ecc_is_valid_idx+0x44>
      return 1;
 801caac:	2301      	movs	r3, #1
 801caae:	e000      	b.n	801cab2 <wc_ecc_is_valid_idx+0x46>
   }

   return 0;
 801cab0:	2300      	movs	r3, #0
}
 801cab2:	4618      	mov	r0, r3
 801cab4:	3714      	adds	r7, #20
 801cab6:	46bd      	mov	sp, r7
 801cab8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cabc:	4770      	bx	lr
 801cabe:	bf00      	nop
 801cac0:	080339ac 	.word	0x080339ac

0801cac4 <wc_ecc_get_curve_idx>:

int wc_ecc_get_curve_idx(int curve_id)
{
 801cac4:	b480      	push	{r7}
 801cac6:	b085      	sub	sp, #20
 801cac8:	af00      	add	r7, sp, #0
 801caca:	6078      	str	r0, [r7, #4]
    int curve_idx;
    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 801cacc:	2300      	movs	r3, #0
 801cace:	60fb      	str	r3, [r7, #12]
 801cad0:	e00d      	b.n	801caee <wc_ecc_get_curve_idx+0x2a>
        if (curve_id == ecc_sets[curve_idx].id)
 801cad2:	4a16      	ldr	r2, [pc, #88]	@ (801cb2c <wc_ecc_get_curve_idx+0x68>)
 801cad4:	68fb      	ldr	r3, [r7, #12]
 801cad6:	2134      	movs	r1, #52	@ 0x34
 801cad8:	fb01 f303 	mul.w	r3, r1, r3
 801cadc:	4413      	add	r3, r2
 801cade:	3304      	adds	r3, #4
 801cae0:	681b      	ldr	r3, [r3, #0]
 801cae2:	687a      	ldr	r2, [r7, #4]
 801cae4:	429a      	cmp	r2, r3
 801cae6:	d00c      	beq.n	801cb02 <wc_ecc_get_curve_idx+0x3e>
    for (curve_idx = 0; ecc_sets[curve_idx].size != 0; curve_idx++) {
 801cae8:	68fb      	ldr	r3, [r7, #12]
 801caea:	3301      	adds	r3, #1
 801caec:	60fb      	str	r3, [r7, #12]
 801caee:	4a0f      	ldr	r2, [pc, #60]	@ (801cb2c <wc_ecc_get_curve_idx+0x68>)
 801caf0:	68fb      	ldr	r3, [r7, #12]
 801caf2:	2134      	movs	r1, #52	@ 0x34
 801caf4:	fb01 f303 	mul.w	r3, r1, r3
 801caf8:	4413      	add	r3, r2
 801cafa:	681b      	ldr	r3, [r3, #0]
 801cafc:	2b00      	cmp	r3, #0
 801cafe:	d1e8      	bne.n	801cad2 <wc_ecc_get_curve_idx+0xe>
 801cb00:	e000      	b.n	801cb04 <wc_ecc_get_curve_idx+0x40>
            break;
 801cb02:	bf00      	nop
    }
    if (ecc_sets[curve_idx].size == 0) {
 801cb04:	4a09      	ldr	r2, [pc, #36]	@ (801cb2c <wc_ecc_get_curve_idx+0x68>)
 801cb06:	68fb      	ldr	r3, [r7, #12]
 801cb08:	2134      	movs	r1, #52	@ 0x34
 801cb0a:	fb01 f303 	mul.w	r3, r1, r3
 801cb0e:	4413      	add	r3, r2
 801cb10:	681b      	ldr	r3, [r3, #0]
 801cb12:	2b00      	cmp	r3, #0
 801cb14:	d102      	bne.n	801cb1c <wc_ecc_get_curve_idx+0x58>
        return ECC_CURVE_INVALID;
 801cb16:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801cb1a:	e000      	b.n	801cb1e <wc_ecc_get_curve_idx+0x5a>
    }
    return curve_idx;
 801cb1c:	68fb      	ldr	r3, [r7, #12]
}
 801cb1e:	4618      	mov	r0, r3
 801cb20:	3714      	adds	r7, #20
 801cb22:	46bd      	mov	sp, r7
 801cb24:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cb28:	4770      	bx	lr
 801cb2a:	bf00      	nop
 801cb2c:	080339ac 	.word	0x080339ac

0801cb30 <wc_ecc_get_curve_size_from_id>:
 *
 * id      curve id, from ecc_curve_id enum in ecc.h
 * return  curve size, from ecc_sets[] on success, negative on error
 */
int wc_ecc_get_curve_size_from_id(int curve_id)
{
 801cb30:	b580      	push	{r7, lr}
 801cb32:	b084      	sub	sp, #16
 801cb34:	af00      	add	r7, sp, #0
 801cb36:	6078      	str	r0, [r7, #4]
    int curve_idx = wc_ecc_get_curve_idx(curve_id);
 801cb38:	6878      	ldr	r0, [r7, #4]
 801cb3a:	f7ff ffc3 	bl	801cac4 <wc_ecc_get_curve_idx>
 801cb3e:	60f8      	str	r0, [r7, #12]
    if (curve_idx == ECC_CURVE_INVALID)
 801cb40:	68fb      	ldr	r3, [r7, #12]
 801cb42:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801cb46:	d102      	bne.n	801cb4e <wc_ecc_get_curve_size_from_id+0x1e>
        return ECC_BAD_ARG_E;
 801cb48:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801cb4c:	e006      	b.n	801cb5c <wc_ecc_get_curve_size_from_id+0x2c>
    return ecc_sets[curve_idx].size;
 801cb4e:	4a05      	ldr	r2, [pc, #20]	@ (801cb64 <wc_ecc_get_curve_size_from_id+0x34>)
 801cb50:	68fb      	ldr	r3, [r7, #12]
 801cb52:	2134      	movs	r1, #52	@ 0x34
 801cb54:	fb01 f303 	mul.w	r3, r1, r3
 801cb58:	4413      	add	r3, r2
 801cb5a:	681b      	ldr	r3, [r3, #0]
}
 801cb5c:	4618      	mov	r0, r3
 801cb5e:	3710      	adds	r7, #16
 801cb60:	46bd      	mov	sp, r7
 801cb62:	bd80      	pop	{r7, pc}
 801cb64:	080339ac 	.word	0x080339ac

0801cb68 <wc_ecc_gen_k>:
}
#endif

/* generate random and ensure its greater than 0 and less than order */
int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)
{
 801cb68:	b580      	push	{r7, lr}
 801cb6a:	b098      	sub	sp, #96	@ 0x60
 801cb6c:	af00      	add	r7, sp, #0
 801cb6e:	60f8      	str	r0, [r7, #12]
 801cb70:	60b9      	str	r1, [r7, #8]
 801cb72:	607a      	str	r2, [r7, #4]
 801cb74:	603b      	str	r3, [r7, #0]
#ifndef WC_NO_RNG
#ifndef WOLFSSL_ECC_GEN_REJECT_SAMPLING
    int err;
    byte buf[ECC_MAXSIZE_GEN];

    if (rng == NULL || size < 0 || size + 8 > ECC_MAXSIZE_GEN || k == NULL ||
 801cb76:	68fb      	ldr	r3, [r7, #12]
 801cb78:	2b00      	cmp	r3, #0
 801cb7a:	d00b      	beq.n	801cb94 <wc_ecc_gen_k+0x2c>
 801cb7c:	68bb      	ldr	r3, [r7, #8]
 801cb7e:	2b00      	cmp	r3, #0
 801cb80:	db08      	blt.n	801cb94 <wc_ecc_gen_k+0x2c>
 801cb82:	68bb      	ldr	r3, [r7, #8]
 801cb84:	2b42      	cmp	r3, #66	@ 0x42
 801cb86:	dc05      	bgt.n	801cb94 <wc_ecc_gen_k+0x2c>
 801cb88:	687b      	ldr	r3, [r7, #4]
 801cb8a:	2b00      	cmp	r3, #0
 801cb8c:	d002      	beq.n	801cb94 <wc_ecc_gen_k+0x2c>
 801cb8e:	683b      	ldr	r3, [r7, #0]
 801cb90:	2b00      	cmp	r3, #0
 801cb92:	d102      	bne.n	801cb9a <wc_ecc_gen_k+0x32>
                                                                order == NULL) {
        return BAD_FUNC_ARG;
 801cb94:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801cb98:	e039      	b.n	801cc0e <wc_ecc_gen_k+0xa6>
    }

    /* generate 8 extra bytes to mitigate bias from the modulo operation below */
    /* see section A.1.2 in 'Suite B Implementor's Guide to FIPS 186-3 (ECDSA)' */
    size += 8;
 801cb9a:	68bb      	ldr	r3, [r7, #8]
 801cb9c:	3308      	adds	r3, #8
 801cb9e:	60bb      	str	r3, [r7, #8]

    /* make up random string */
    err = wc_RNG_GenerateBlock(rng, buf, (word32)size);
 801cba0:	68ba      	ldr	r2, [r7, #8]
 801cba2:	f107 0310 	add.w	r3, r7, #16
 801cba6:	4619      	mov	r1, r3
 801cba8:	68f8      	ldr	r0, [r7, #12]
 801cbaa:	f002 fcfa 	bl	801f5a2 <wc_RNG_GenerateBlock>
 801cbae:	65f8      	str	r0, [r7, #92]	@ 0x5c
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Add("wc_ecc_gen_k buf", buf, size);
#endif

    /* load random buffer data into k */
    if (err == 0)
 801cbb0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801cbb2:	2b00      	cmp	r3, #0
 801cbb4:	d107      	bne.n	801cbc6 <wc_ecc_gen_k+0x5e>
        err = mp_read_unsigned_bin(k, buf, (word32)size);
 801cbb6:	f107 0310 	add.w	r3, r7, #16
 801cbba:	68ba      	ldr	r2, [r7, #8]
 801cbbc:	4619      	mov	r1, r3
 801cbbe:	6878      	ldr	r0, [r7, #4]
 801cbc0:	f009 ff46 	bl	8026a50 <mp_read_unsigned_bin>
 801cbc4:	65f8      	str	r0, [r7, #92]	@ 0x5c

    /* the key should be smaller than the order of base point */
    if (err == MP_OKAY) {
 801cbc6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801cbc8:	2b00      	cmp	r3, #0
 801cbca:	d10d      	bne.n	801cbe8 <wc_ecc_gen_k+0x80>
        if (mp_cmp(k, order) != MP_LT) {
 801cbcc:	6839      	ldr	r1, [r7, #0]
 801cbce:	6878      	ldr	r0, [r7, #4]
 801cbd0:	f009 fef8 	bl	80269c4 <mp_cmp>
 801cbd4:	4603      	mov	r3, r0
 801cbd6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801cbda:	d005      	beq.n	801cbe8 <wc_ecc_gen_k+0x80>
            err = mp_mod(k, order, k);
 801cbdc:	687a      	ldr	r2, [r7, #4]
 801cbde:	6839      	ldr	r1, [r7, #0]
 801cbe0:	6878      	ldr	r0, [r7, #4]
 801cbe2:	f009 fe99 	bl	8026918 <mp_mod>
 801cbe6:	65f8      	str	r0, [r7, #92]	@ 0x5c
        }
    }

    /* quick sanity check to make sure we're not dealing with a 0 key */
    if (err == MP_OKAY) {
 801cbe8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801cbea:	2b00      	cmp	r3, #0
 801cbec:	d108      	bne.n	801cc00 <wc_ecc_gen_k+0x98>
        if (mp_iszero(k) == MP_YES)
 801cbee:	6878      	ldr	r0, [r7, #4]
 801cbf0:	f009 ffaf 	bl	8026b52 <mp_iszero>
 801cbf4:	4603      	mov	r3, r0
 801cbf6:	2b01      	cmp	r3, #1
 801cbf8:	d102      	bne.n	801cc00 <wc_ecc_gen_k+0x98>
          err = MP_ZERO_E;
 801cbfa:	f06f 0378 	mvn.w	r3, #120	@ 0x78
 801cbfe:	65fb      	str	r3, [r7, #92]	@ 0x5c
    }

    ForceZero(buf, ECC_MAXSIZE_GEN);
 801cc00:	f107 0310 	add.w	r3, r7, #16
 801cc04:	214a      	movs	r1, #74	@ 0x4a
 801cc06:	4618      	mov	r0, r3
 801cc08:	f7fd fdbe 	bl	801a788 <ForceZero>
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(buf, ECC_MAXSIZE_GEN);
#endif

    return err;
 801cc0c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    (void)size;
    (void)k;
    (void)order;
    return NOT_COMPILED_IN;
#endif /* !WC_NO_RNG */
}
 801cc0e:	4618      	mov	r0, r3
 801cc10:	3760      	adds	r7, #96	@ 0x60
 801cc12:	46bd      	mov	sp, r7
 801cc14:	bd80      	pop	{r7, pc}

0801cc16 <wc_ecc_reset>:

static WC_INLINE void wc_ecc_reset(ecc_key* key)
{
 801cc16:	b480      	push	{r7}
 801cc18:	b083      	sub	sp, #12
 801cc1a:	af00      	add	r7, sp, #0
 801cc1c:	6078      	str	r0, [r7, #4]
    /* make sure required key variables are reset */
    key->state = ECC_STATE_NONE;
 801cc1e:	687b      	ldr	r3, [r7, #4]
 801cc20:	2200      	movs	r2, #0
 801cc22:	609a      	str	r2, [r3, #8]
}
 801cc24:	bf00      	nop
 801cc26:	370c      	adds	r7, #12
 801cc28:	46bd      	mov	sp, r7
 801cc2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cc2e:	4770      	bx	lr

0801cc30 <ecc_make_pub_ex>:
 *
 * returns MP_OKAY on success
 */
static int ecc_make_pub_ex(ecc_key* key, ecc_curve_spec* curve,
        ecc_point* pubOut, WC_RNG* rng)
{
 801cc30:	b5b0      	push	{r4, r5, r7, lr}
 801cc32:	b08e      	sub	sp, #56	@ 0x38
 801cc34:	af06      	add	r7, sp, #24
 801cc36:	60f8      	str	r0, [r7, #12]
 801cc38:	60b9      	str	r1, [r7, #8]
 801cc3a:	607a      	str	r2, [r7, #4]
 801cc3c:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801cc3e:	2300      	movs	r3, #0
 801cc40:	61fb      	str	r3, [r7, #28]
    ecc_point* pub;
#endif /* HAVE_ECC_MAKE_PUB */

    (void)rng;

    if (key == NULL) {
 801cc42:	68fb      	ldr	r3, [r7, #12]
 801cc44:	2b00      	cmp	r3, #0
 801cc46:	d102      	bne.n	801cc4e <ecc_make_pub_ex+0x1e>
        return BAD_FUNC_ARG;
 801cc48:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801cc4c:	e0cc      	b.n	801cde8 <ecc_make_pub_ex+0x1b8>

    SAVE_VECTOR_REGISTERS(return _svr_ret;);

#ifdef HAVE_ECC_MAKE_PUB
    /* if ecc_point passed in then use it as output for public key point */
    if (pubOut != NULL) {
 801cc4e:	687b      	ldr	r3, [r7, #4]
 801cc50:	2b00      	cmp	r3, #0
 801cc52:	d002      	beq.n	801cc5a <ecc_make_pub_ex+0x2a>
        pub = pubOut;
 801cc54:	687b      	ldr	r3, [r7, #4]
 801cc56:	61bb      	str	r3, [r7, #24]
 801cc58:	e005      	b.n	801cc66 <ecc_make_pub_ex+0x36>
    }
    else {
        /* caching public key making it a ECC_PRIVATEKEY instead of
           ECC_PRIVATEKEY_ONLY */
        pub = &key->pubkey;
 801cc5a:	68fb      	ldr	r3, [r7, #12]
 801cc5c:	3318      	adds	r3, #24
 801cc5e:	61bb      	str	r3, [r7, #24]
        key->type = ECC_PRIVATEKEY_ONLY;
 801cc60:	68fb      	ldr	r3, [r7, #12]
 801cc62:	2203      	movs	r2, #3
 801cc64:	601a      	str	r2, [r3, #0]
    }

    if ((err == MP_OKAY) && (mp_iszero(ecc_get_k(key)) ||
 801cc66:	69fb      	ldr	r3, [r7, #28]
 801cc68:	2b00      	cmp	r3, #0
 801cc6a:	d11e      	bne.n	801ccaa <ecc_make_pub_ex+0x7a>
 801cc6c:	68fb      	ldr	r3, [r7, #12]
 801cc6e:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cc72:	4618      	mov	r0, r3
 801cc74:	f009 ff6d 	bl	8026b52 <mp_iszero>
 801cc78:	4603      	mov	r3, r0
 801cc7a:	2b00      	cmp	r3, #0
 801cc7c:	d112      	bne.n	801cca4 <ecc_make_pub_ex+0x74>
            mp_isneg(ecc_get_k(key)) ||
 801cc7e:	68fb      	ldr	r3, [r7, #12]
 801cc80:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cc84:	685b      	ldr	r3, [r3, #4]
    if ((err == MP_OKAY) && (mp_iszero(ecc_get_k(key)) ||
 801cc86:	2b00      	cmp	r3, #0
 801cc88:	d10c      	bne.n	801cca4 <ecc_make_pub_ex+0x74>
            (mp_cmp(ecc_get_k(key), curve->order) != MP_LT))) {
 801cc8a:	68fb      	ldr	r3, [r7, #12]
 801cc8c:	f8d3 2118 	ldr.w	r2, [r3, #280]	@ 0x118
 801cc90:	68bb      	ldr	r3, [r7, #8]
 801cc92:	691b      	ldr	r3, [r3, #16]
 801cc94:	4619      	mov	r1, r3
 801cc96:	4610      	mov	r0, r2
 801cc98:	f009 fe94 	bl	80269c4 <mp_cmp>
 801cc9c:	4603      	mov	r3, r0
            mp_isneg(ecc_get_k(key)) ||
 801cc9e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801cca2:	d002      	beq.n	801ccaa <ecc_make_pub_ex+0x7a>
        err = ECC_PRIV_KEY_E;
 801cca4:	f06f 03d7 	mvn.w	r3, #215	@ 0xd7
 801cca8:	61fb      	str	r3, [r7, #28]
    }

    if (err == MP_OKAY) {
 801ccaa:	69fb      	ldr	r3, [r7, #28]
 801ccac:	2b00      	cmp	r3, #0
 801ccae:	d11d      	bne.n	801ccec <ecc_make_pub_ex+0xbc>
    #ifndef ALT_ECC_SIZE
        err = mp_init_multi(pub->x, pub->y, pub->z, NULL, NULL, NULL);
    #else
        pub->x = (mp_int*)&pub->xyz[0];
 801ccb0:	69bb      	ldr	r3, [r7, #24]
 801ccb2:	f103 020c 	add.w	r2, r3, #12
 801ccb6:	69bb      	ldr	r3, [r7, #24]
 801ccb8:	601a      	str	r2, [r3, #0]
        pub->y = (mp_int*)&pub->xyz[1];
 801ccba:	69bb      	ldr	r3, [r7, #24]
 801ccbc:	f103 025c 	add.w	r2, r3, #92	@ 0x5c
 801ccc0:	69bb      	ldr	r3, [r7, #24]
 801ccc2:	605a      	str	r2, [r3, #4]
        pub->z = (mp_int*)&pub->xyz[2];
 801ccc4:	69bb      	ldr	r3, [r7, #24]
 801ccc6:	f103 02ac 	add.w	r2, r3, #172	@ 0xac
 801ccca:	69bb      	ldr	r3, [r7, #24]
 801cccc:	609a      	str	r2, [r3, #8]
        alt_fp_init(pub->x);
 801ccce:	69bb      	ldr	r3, [r7, #24]
 801ccd0:	681b      	ldr	r3, [r3, #0]
 801ccd2:	4618      	mov	r0, r3
 801ccd4:	f7fd ff5a 	bl	801ab8c <alt_fp_init>
        alt_fp_init(pub->y);
 801ccd8:	69bb      	ldr	r3, [r7, #24]
 801ccda:	685b      	ldr	r3, [r3, #4]
 801ccdc:	4618      	mov	r0, r3
 801ccde:	f7fd ff55 	bl	801ab8c <alt_fp_init>
        alt_fp_init(pub->z);
 801cce2:	69bb      	ldr	r3, [r7, #24]
 801cce4:	689b      	ldr	r3, [r3, #8]
 801cce6:	4618      	mov	r0, r3
 801cce8:	f7fd ff50 	bl	801ab8c <alt_fp_init>
#endif /* WOLFSSL_HAVE_SP_ECC */

#if defined(WOLFSSL_SP_MATH)
        err = WC_KEY_SIZE_E;
#else
    if (err == MP_OKAY) {
 801ccec:	69fb      	ldr	r3, [r7, #28]
 801ccee:	2b00      	cmp	r3, #0
 801ccf0:	d16f      	bne.n	801cdd2 <ecc_make_pub_ex+0x1a2>
        /* Multi-Precision Math: compute public curve */
        mp_digit mp = 0;
 801ccf2:	2300      	movs	r3, #0
 801ccf4:	617b      	str	r3, [r7, #20]
        ecc_point* base = NULL;
 801ccf6:	2300      	movs	r3, #0
 801ccf8:	613b      	str	r3, [r7, #16]
    #ifdef WOLFSSL_NO_MALLOC
        ecc_point  lcl_base;
        base = &lcl_base;
    #endif
        err = wc_ecc_new_point_ex(&base, key->heap);
 801ccfa:	68fb      	ldr	r3, [r7, #12]
 801ccfc:	695a      	ldr	r2, [r3, #20]
 801ccfe:	f107 0310 	add.w	r3, r7, #16
 801cd02:	4611      	mov	r1, r2
 801cd04:	4618      	mov	r0, r3
 801cd06:	f7ff fde8 	bl	801c8da <wc_ecc_new_point_ex>
 801cd0a:	61f8      	str	r0, [r7, #28]

        /* read in the x/y for this key */
        if (err == MP_OKAY)
 801cd0c:	69fb      	ldr	r3, [r7, #28]
 801cd0e:	2b00      	cmp	r3, #0
 801cd10:	d108      	bne.n	801cd24 <ecc_make_pub_ex+0xf4>
            err = mp_copy(curve->Gx, base->x);
 801cd12:	68bb      	ldr	r3, [r7, #8]
 801cd14:	695a      	ldr	r2, [r3, #20]
 801cd16:	693b      	ldr	r3, [r7, #16]
 801cd18:	681b      	ldr	r3, [r3, #0]
 801cd1a:	4619      	mov	r1, r3
 801cd1c:	4610      	mov	r0, r2
 801cd1e:	f009 ff0a 	bl	8026b36 <mp_copy>
 801cd22:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801cd24:	69fb      	ldr	r3, [r7, #28]
 801cd26:	2b00      	cmp	r3, #0
 801cd28:	d108      	bne.n	801cd3c <ecc_make_pub_ex+0x10c>
            err = mp_copy(curve->Gy, base->y);
 801cd2a:	68bb      	ldr	r3, [r7, #8]
 801cd2c:	699a      	ldr	r2, [r3, #24]
 801cd2e:	693b      	ldr	r3, [r7, #16]
 801cd30:	685b      	ldr	r3, [r3, #4]
 801cd32:	4619      	mov	r1, r3
 801cd34:	4610      	mov	r0, r2
 801cd36:	f009 fefe 	bl	8026b36 <mp_copy>
 801cd3a:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801cd3c:	69fb      	ldr	r3, [r7, #28]
 801cd3e:	2b00      	cmp	r3, #0
 801cd40:	d108      	bne.n	801cd54 <ecc_make_pub_ex+0x124>
            err = mp_montgomery_setup(curve->prime, &mp);
 801cd42:	68bb      	ldr	r3, [r7, #8]
 801cd44:	685b      	ldr	r3, [r3, #4]
 801cd46:	f107 0214 	add.w	r2, r7, #20
 801cd4a:	4611      	mov	r1, r2
 801cd4c:	4618      	mov	r0, r3
 801cd4e:	f00a f983 	bl	8027058 <mp_montgomery_setup>
 801cd52:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801cd54:	69fb      	ldr	r3, [r7, #28]
 801cd56:	2b00      	cmp	r3, #0
 801cd58:	d106      	bne.n	801cd68 <ecc_make_pub_ex+0x138>
            err = mp_set(base->z, 1);
 801cd5a:	693b      	ldr	r3, [r7, #16]
 801cd5c:	689b      	ldr	r3, [r3, #8]
 801cd5e:	2101      	movs	r1, #1
 801cd60:	4618      	mov	r0, r3
 801cd62:	f00a f9a5 	bl	80270b0 <mp_set>
 801cd66:	61f8      	str	r0, [r7, #28]

        /* make the public key */
        if (err == MP_OKAY) {
 801cd68:	69fb      	ldr	r3, [r7, #28]
 801cd6a:	2b00      	cmp	r3, #0
 801cd6c:	d11f      	bne.n	801cdae <ecc_make_pub_ex+0x17e>
            /* Map in a separate call as this should be constant time */
            err = wc_ecc_mulmod_ex2(ecc_get_k(key), base, pub, curve->Af,
 801cd6e:	68fb      	ldr	r3, [r7, #12]
 801cd70:	f8d3 0118 	ldr.w	r0, [r3, #280]	@ 0x118
 801cd74:	693c      	ldr	r4, [r7, #16]
 801cd76:	68bb      	ldr	r3, [r7, #8]
 801cd78:	689d      	ldr	r5, [r3, #8]
 801cd7a:	68bb      	ldr	r3, [r7, #8]
 801cd7c:	685b      	ldr	r3, [r3, #4]
 801cd7e:	68ba      	ldr	r2, [r7, #8]
 801cd80:	6912      	ldr	r2, [r2, #16]
 801cd82:	68f9      	ldr	r1, [r7, #12]
 801cd84:	6949      	ldr	r1, [r1, #20]
 801cd86:	9104      	str	r1, [sp, #16]
 801cd88:	2100      	movs	r1, #0
 801cd8a:	9103      	str	r1, [sp, #12]
 801cd8c:	6839      	ldr	r1, [r7, #0]
 801cd8e:	9102      	str	r1, [sp, #8]
 801cd90:	9201      	str	r2, [sp, #4]
 801cd92:	9300      	str	r3, [sp, #0]
 801cd94:	462b      	mov	r3, r5
 801cd96:	69ba      	ldr	r2, [r7, #24]
 801cd98:	4621      	mov	r1, r4
 801cd9a:	f7ff fced 	bl	801c778 <wc_ecc_mulmod_ex2>
 801cd9e:	61f8      	str	r0, [r7, #28]
                                 curve->prime, curve->order, rng, 0, key->heap);
            if (err == WC_NO_ERR_TRACE(MP_MEM)) {
 801cda0:	69fb      	ldr	r3, [r7, #28]
 801cda2:	f113 0f61 	cmn.w	r3, #97	@ 0x61
 801cda6:	d102      	bne.n	801cdae <ecc_make_pub_ex+0x17e>
               err = MEMORY_E;
 801cda8:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801cdac:	61fb      	str	r3, [r7, #28]
            }
        }
        if (err == MP_OKAY) {
 801cdae:	69fb      	ldr	r3, [r7, #28]
 801cdb0:	2b00      	cmp	r3, #0
 801cdb2:	d107      	bne.n	801cdc4 <ecc_make_pub_ex+0x194>
            /* Use constant time map if compiled in */
            err = ecc_map_ex(pub, curve->prime, mp, 1);
 801cdb4:	68bb      	ldr	r3, [r7, #8]
 801cdb6:	6859      	ldr	r1, [r3, #4]
 801cdb8:	697a      	ldr	r2, [r7, #20]
 801cdba:	2301      	movs	r3, #1
 801cdbc:	69b8      	ldr	r0, [r7, #24]
 801cdbe:	f7fe fe9b 	bl	801baf8 <ecc_map_ex>
 801cdc2:	61f8      	str	r0, [r7, #28]
        }

        wc_ecc_del_point_ex(base, key->heap);
 801cdc4:	693a      	ldr	r2, [r7, #16]
 801cdc6:	68fb      	ldr	r3, [r7, #12]
 801cdc8:	695b      	ldr	r3, [r3, #20]
 801cdca:	4619      	mov	r1, r3
 801cdcc:	4610      	mov	r0, r2
 801cdce:	f7ff fdd9 	bl	801c984 <wc_ecc_del_point_ex>
    (void)curve;
    err = NOT_COMPILED_IN;
#endif /* HAVE_ECC_MAKE_PUB */

    /* change key state if public part is cached */
    if (key->type == ECC_PRIVATEKEY_ONLY && pubOut == NULL) {
 801cdd2:	68fb      	ldr	r3, [r7, #12]
 801cdd4:	681b      	ldr	r3, [r3, #0]
 801cdd6:	2b03      	cmp	r3, #3
 801cdd8:	d105      	bne.n	801cde6 <ecc_make_pub_ex+0x1b6>
 801cdda:	687b      	ldr	r3, [r7, #4]
 801cddc:	2b00      	cmp	r3, #0
 801cdde:	d102      	bne.n	801cde6 <ecc_make_pub_ex+0x1b6>
        key->type = ECC_PRIVATEKEY;
 801cde0:	68fb      	ldr	r3, [r7, #12]
 801cde2:	2202      	movs	r2, #2
 801cde4:	601a      	str	r2, [r3, #0]
    }

    RESTORE_VECTOR_REGISTERS();

    return err;
 801cde6:	69fb      	ldr	r3, [r7, #28]
}
 801cde8:	4618      	mov	r0, r3
 801cdea:	3720      	adds	r7, #32
 801cdec:	46bd      	mov	sp, r7
 801cdee:	bdb0      	pop	{r4, r5, r7, pc}

0801cdf0 <wc_ecc_init_ex>:
}

/* Setup dynamic pointers if using normal math for proper freeing */
WOLFSSL_ABI
int wc_ecc_init_ex(ecc_key* key, void* heap, int devId)
{
 801cdf0:	b580      	push	{r7, lr}
 801cdf2:	b086      	sub	sp, #24
 801cdf4:	af00      	add	r7, sp, #0
 801cdf6:	60f8      	str	r0, [r7, #12]
 801cdf8:	60b9      	str	r1, [r7, #8]
 801cdfa:	607a      	str	r2, [r7, #4]
    int ret      = 0;
 801cdfc:	2300      	movs	r3, #0
 801cdfe:	617b      	str	r3, [r7, #20]

    if (key == NULL) {
 801ce00:	68fb      	ldr	r3, [r7, #12]
 801ce02:	2b00      	cmp	r3, #0
 801ce04:	d102      	bne.n	801ce0c <wc_ecc_init_ex+0x1c>
        return BAD_FUNC_ARG;
 801ce06:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801ce0a:	e036      	b.n	801ce7a <wc_ecc_init_ex+0x8a>

#ifdef ECC_DUMP_OID
    wc_ecc_dump_oids();
#endif

    XMEMSET(key, 0, sizeof(ecc_key));
 801ce0c:	f44f 72b8 	mov.w	r2, #368	@ 0x170
 801ce10:	2100      	movs	r1, #0
 801ce12:	68f8      	ldr	r0, [r7, #12]
 801ce14:	f00b fb5c 	bl	80284d0 <memset>
    key->state = ECC_STATE_NONE;
 801ce18:	68fb      	ldr	r3, [r7, #12]
 801ce1a:	2200      	movs	r2, #0
 801ce1c:	609a      	str	r2, [r3, #8]
    key->slot = ATECC_INVALID_SLOT;
#elif defined(WOLFSSL_KCAPI_ECC)
    key->handle = NULL;
#else
#ifdef ALT_ECC_SIZE
    key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
 801ce1e:	68fb      	ldr	r3, [r7, #12]
 801ce20:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 801ce24:	68fb      	ldr	r3, [r7, #12]
 801ce26:	619a      	str	r2, [r3, #24]
    key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
 801ce28:	68fb      	ldr	r3, [r7, #12]
 801ce2a:	f103 0274 	add.w	r2, r3, #116	@ 0x74
 801ce2e:	68fb      	ldr	r3, [r7, #12]
 801ce30:	61da      	str	r2, [r3, #28]
    key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
 801ce32:	68fb      	ldr	r3, [r7, #12]
 801ce34:	f103 02c4 	add.w	r2, r3, #196	@ 0xc4
 801ce38:	68fb      	ldr	r3, [r7, #12]
 801ce3a:	621a      	str	r2, [r3, #32]
    alt_fp_init(key->pubkey.x);
 801ce3c:	68fb      	ldr	r3, [r7, #12]
 801ce3e:	699b      	ldr	r3, [r3, #24]
 801ce40:	4618      	mov	r0, r3
 801ce42:	f7fd fea3 	bl	801ab8c <alt_fp_init>
    alt_fp_init(key->pubkey.y);
 801ce46:	68fb      	ldr	r3, [r7, #12]
 801ce48:	69db      	ldr	r3, [r3, #28]
 801ce4a:	4618      	mov	r0, r3
 801ce4c:	f7fd fe9e 	bl	801ab8c <alt_fp_init>
    alt_fp_init(key->pubkey.z);
 801ce50:	68fb      	ldr	r3, [r7, #12]
 801ce52:	6a1b      	ldr	r3, [r3, #32]
 801ce54:	4618      	mov	r0, r3
 801ce56:	f7fd fe99 	bl	801ab8c <alt_fp_init>
    key->k = (mp_int*)key->ka;
 801ce5a:	68fb      	ldr	r3, [r7, #12]
 801ce5c:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
 801ce60:	68fb      	ldr	r3, [r7, #12]
 801ce62:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
    alt_fp_init(key->k);
 801ce66:	68fb      	ldr	r3, [r7, #12]
 801ce68:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801ce6c:	4618      	mov	r0, r3
 801ce6e:	f7fd fe8d 	bl	801ab8c <alt_fp_init>

#ifdef WOLFSSL_HEAP_TEST
    (void)heap;
    key->heap = (void*)WOLFSSL_HEAP_TEST;
#else
    key->heap = heap;
 801ce72:	68fb      	ldr	r3, [r7, #12]
 801ce74:	68ba      	ldr	r2, [r7, #8]
 801ce76:	615a      	str	r2, [r3, #20]
        WOLFSSL_MSG("Can't initialize Xsecure");
        return WC_HW_E;
    }
#endif

    return ret;
 801ce78:	697b      	ldr	r3, [r7, #20]
}
 801ce7a:	4618      	mov	r0, r3
 801ce7c:	3718      	adds	r7, #24
 801ce7e:	46bd      	mov	sp, r7
 801ce80:	bd80      	pop	{r7, pc}

0801ce82 <wc_ecc_get_curve_order_bit_count>:
    return 0;
}


static int wc_ecc_get_curve_order_bit_count(const ecc_set_type* dp)
{
 801ce82:	b580      	push	{r7, lr}
 801ce84:	b094      	sub	sp, #80	@ 0x50
 801ce86:	af00      	add	r7, sp, #0
 801ce88:	6078      	str	r0, [r7, #4]
    int err = MP_OKAY;
 801ce8a:	2300      	movs	r3, #0
 801ce8c:	64fb      	str	r3, [r7, #76]	@ 0x4c
    int orderBits;
    DECLARE_CURVE_SPECS(1);
 801ce8e:	2300      	movs	r3, #0
 801ce90:	64bb      	str	r3, [r7, #72]	@ 0x48
 801ce92:	f107 0310 	add.w	r3, r7, #16
 801ce96:	60fb      	str	r3, [r7, #12]
 801ce98:	68fb      	ldr	r3, [r7, #12]
 801ce9a:	222c      	movs	r2, #44	@ 0x2c
 801ce9c:	2100      	movs	r1, #0
 801ce9e:	4618      	mov	r0, r3
 801cea0:	f00b fb16 	bl	80284d0 <memset>
 801cea4:	68fb      	ldr	r3, [r7, #12]
 801cea6:	2201      	movs	r2, #1
 801cea8:	621a      	str	r2, [r3, #32]

    ALLOC_CURVE_SPECS(1, err);
 801ceaa:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801ceae:	f001 fdf1 	bl	801ea94 <wolfSSL_Malloc>
 801ceb2:	64b8      	str	r0, [r7, #72]	@ 0x48
 801ceb4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801ceb6:	2b00      	cmp	r3, #0
 801ceb8:	d103      	bne.n	801cec2 <wc_ecc_get_curve_order_bit_count+0x40>
 801ceba:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801cebe:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801cec0:	e002      	b.n	801cec8 <wc_ecc_get_curve_order_bit_count+0x46>
 801cec2:	68fb      	ldr	r3, [r7, #12]
 801cec4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801cec6:	61da      	str	r2, [r3, #28]
    if (err == MP_OKAY) {
 801cec8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ceca:	2b00      	cmp	r3, #0
 801cecc:	d107      	bne.n	801cede <wc_ecc_get_curve_order_bit_count+0x5c>
        err = wc_ecc_curve_load(dp, &curve, ECC_CURVE_FIELD_ORDER);
 801cece:	f107 030c 	add.w	r3, r7, #12
 801ced2:	2208      	movs	r2, #8
 801ced4:	4619      	mov	r1, r3
 801ced6:	6878      	ldr	r0, [r7, #4]
 801ced8:	f7fd fd3d 	bl	801a956 <wc_ecc_curve_load>
 801cedc:	64f8      	str	r0, [r7, #76]	@ 0x4c
    }

    if (err != 0) {
 801cede:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801cee0:	2b00      	cmp	r3, #0
 801cee2:	d009      	beq.n	801cef8 <wc_ecc_get_curve_order_bit_count+0x76>
       FREE_CURVE_SPECS();
 801cee4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801cee6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801cee8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ceea:	2b00      	cmp	r3, #0
 801ceec:	d002      	beq.n	801cef4 <wc_ecc_get_curve_order_bit_count+0x72>
 801ceee:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801cef0:	f001 fdec 	bl	801eacc <wolfSSL_Free>
       return err;
 801cef4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801cef6:	e012      	b.n	801cf1e <wc_ecc_get_curve_order_bit_count+0x9c>
    }
    orderBits = mp_count_bits(curve->order);
 801cef8:	68fb      	ldr	r3, [r7, #12]
 801cefa:	691b      	ldr	r3, [r3, #16]
 801cefc:	4618      	mov	r0, r3
 801cefe:	f009 fe39 	bl	8026b74 <mp_count_bits>
 801cf02:	6478      	str	r0, [r7, #68]	@ 0x44

    wc_ecc_curve_free(curve);
 801cf04:	68fb      	ldr	r3, [r7, #12]
 801cf06:	4618      	mov	r0, r3
 801cf08:	f7fd fcda 	bl	801a8c0 <wc_ecc_curve_free>
    FREE_CURVE_SPECS();
 801cf0c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801cf0e:	643b      	str	r3, [r7, #64]	@ 0x40
 801cf10:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801cf12:	2b00      	cmp	r3, #0
 801cf14:	d002      	beq.n	801cf1c <wc_ecc_get_curve_order_bit_count+0x9a>
 801cf16:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801cf18:	f001 fdd8 	bl	801eacc <wolfSSL_Free>
    return orderBits;
 801cf1c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 801cf1e:	4618      	mov	r0, r3
 801cf20:	3750      	adds	r7, #80	@ 0x50
 801cf22:	46bd      	mov	sp, r7
 801cf24:	bd80      	pop	{r7, pc}

0801cf26 <wc_ecc_free>:
  Free an ECC key from memory
  key   The key you wish to free
*/
WOLFSSL_ABI
int wc_ecc_free(ecc_key* key)
{
 801cf26:	b580      	push	{r7, lr}
 801cf28:	b082      	sub	sp, #8
 801cf2a:	af00      	add	r7, sp, #0
 801cf2c:	6078      	str	r0, [r7, #4]
    if (key == NULL) {
 801cf2e:	687b      	ldr	r3, [r7, #4]
 801cf30:	2b00      	cmp	r3, #0
 801cf32:	d101      	bne.n	801cf38 <wc_ecc_free+0x12>
        return 0;
 801cf34:	2300      	movs	r3, #0
 801cf36:	e01a      	b.n	801cf6e <wc_ecc_free+0x48>

#ifdef WOLFSSL_MAXQ10XX_CRYPTO
    wc_MAXQ10XX_EccFree(key);
#endif

    mp_clear(key->pubkey.x);
 801cf38:	687b      	ldr	r3, [r7, #4]
 801cf3a:	699b      	ldr	r3, [r3, #24]
 801cf3c:	4618      	mov	r0, r3
 801cf3e:	f009 fc38 	bl	80267b2 <mp_clear>
    mp_clear(key->pubkey.y);
 801cf42:	687b      	ldr	r3, [r7, #4]
 801cf44:	69db      	ldr	r3, [r3, #28]
 801cf46:	4618      	mov	r0, r3
 801cf48:	f009 fc33 	bl	80267b2 <mp_clear>
    mp_clear(key->pubkey.z);
 801cf4c:	687b      	ldr	r3, [r7, #4]
 801cf4e:	6a1b      	ldr	r3, [r3, #32]
 801cf50:	4618      	mov	r0, r3
 801cf52:	f009 fc2e 	bl	80267b2 <mp_clear>

#ifdef ALT_ECC_SIZE
    if (key->k)
 801cf56:	687b      	ldr	r3, [r7, #4]
 801cf58:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cf5c:	2b00      	cmp	r3, #0
 801cf5e:	d005      	beq.n	801cf6c <wc_ecc_free+0x46>
#endif
        mp_forcezero(key->k);
 801cf60:	687b      	ldr	r3, [r7, #4]
 801cf62:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801cf66:	4618      	mov	r0, r3
 801cf68:	f009 fc0e 	bl	8026788 <mp_forcezero>

#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(key, sizeof(ecc_key));
#endif

    return 0;
 801cf6c:	2300      	movs	r3, #0
}
 801cf6e:	4618      	mov	r0, r3
 801cf70:	3708      	adds	r7, #8
 801cf72:	46bd      	mov	sp, r7
 801cf74:	bd80      	pop	{r7, pc}

0801cf76 <ecc_projective_add_point_safe>:
 *           (Result was: z == 0, x and/or y not 0)
 *        -> Need to set result to infinity.
 */
int ecc_projective_add_point_safe(ecc_point* A, ecc_point* B, ecc_point* R,
    mp_int* a, mp_int* modulus, mp_digit mp, int* infinity)
{
 801cf76:	b580      	push	{r7, lr}
 801cf78:	b088      	sub	sp, #32
 801cf7a:	af02      	add	r7, sp, #8
 801cf7c:	60f8      	str	r0, [r7, #12]
 801cf7e:	60b9      	str	r1, [r7, #8]
 801cf80:	607a      	str	r2, [r7, #4]
 801cf82:	603b      	str	r3, [r7, #0]
    int err;

    if (mp_iszero(A->x) && mp_iszero(A->y)) {
 801cf84:	68fb      	ldr	r3, [r7, #12]
 801cf86:	681b      	ldr	r3, [r3, #0]
 801cf88:	4618      	mov	r0, r3
 801cf8a:	f009 fde2 	bl	8026b52 <mp_iszero>
 801cf8e:	4603      	mov	r3, r0
 801cf90:	2b00      	cmp	r3, #0
 801cf92:	d00d      	beq.n	801cfb0 <ecc_projective_add_point_safe+0x3a>
 801cf94:	68fb      	ldr	r3, [r7, #12]
 801cf96:	685b      	ldr	r3, [r3, #4]
 801cf98:	4618      	mov	r0, r3
 801cf9a:	f009 fdda 	bl	8026b52 <mp_iszero>
 801cf9e:	4603      	mov	r3, r0
 801cfa0:	2b00      	cmp	r3, #0
 801cfa2:	d005      	beq.n	801cfb0 <ecc_projective_add_point_safe+0x3a>
        /* A is infinity. */
        err = wc_ecc_copy_point(B, R);
 801cfa4:	6879      	ldr	r1, [r7, #4]
 801cfa6:	68b8      	ldr	r0, [r7, #8]
 801cfa8:	f7ff fd23 	bl	801c9f2 <wc_ecc_copy_point>
 801cfac:	6178      	str	r0, [r7, #20]
 801cfae:	e0e1      	b.n	801d174 <ecc_projective_add_point_safe+0x1fe>
    }
    else if (mp_iszero(B->x) && mp_iszero(B->y)) {
 801cfb0:	68bb      	ldr	r3, [r7, #8]
 801cfb2:	681b      	ldr	r3, [r3, #0]
 801cfb4:	4618      	mov	r0, r3
 801cfb6:	f009 fdcc 	bl	8026b52 <mp_iszero>
 801cfba:	4603      	mov	r3, r0
 801cfbc:	2b00      	cmp	r3, #0
 801cfbe:	d00d      	beq.n	801cfdc <ecc_projective_add_point_safe+0x66>
 801cfc0:	68bb      	ldr	r3, [r7, #8]
 801cfc2:	685b      	ldr	r3, [r3, #4]
 801cfc4:	4618      	mov	r0, r3
 801cfc6:	f009 fdc4 	bl	8026b52 <mp_iszero>
 801cfca:	4603      	mov	r3, r0
 801cfcc:	2b00      	cmp	r3, #0
 801cfce:	d005      	beq.n	801cfdc <ecc_projective_add_point_safe+0x66>
        /* B is infinity. */
        err = wc_ecc_copy_point(A, R);
 801cfd0:	6879      	ldr	r1, [r7, #4]
 801cfd2:	68f8      	ldr	r0, [r7, #12]
 801cfd4:	f7ff fd0d 	bl	801c9f2 <wc_ecc_copy_point>
 801cfd8:	6178      	str	r0, [r7, #20]
 801cfda:	e0cb      	b.n	801d174 <ecc_projective_add_point_safe+0x1fe>
    }
    else if ((mp_cmp(A->x, B->x) == MP_EQ) && (mp_cmp(A->z, B->z) == MP_EQ)) {
 801cfdc:	68fb      	ldr	r3, [r7, #12]
 801cfde:	681a      	ldr	r2, [r3, #0]
 801cfe0:	68bb      	ldr	r3, [r7, #8]
 801cfe2:	681b      	ldr	r3, [r3, #0]
 801cfe4:	4619      	mov	r1, r3
 801cfe6:	4610      	mov	r0, r2
 801cfe8:	f009 fcec 	bl	80269c4 <mp_cmp>
 801cfec:	4603      	mov	r3, r0
 801cfee:	2b00      	cmp	r3, #0
 801cff0:	d144      	bne.n	801d07c <ecc_projective_add_point_safe+0x106>
 801cff2:	68fb      	ldr	r3, [r7, #12]
 801cff4:	689a      	ldr	r2, [r3, #8]
 801cff6:	68bb      	ldr	r3, [r7, #8]
 801cff8:	689b      	ldr	r3, [r3, #8]
 801cffa:	4619      	mov	r1, r3
 801cffc:	4610      	mov	r0, r2
 801cffe:	f009 fce1 	bl	80269c4 <mp_cmp>
 801d002:	4603      	mov	r3, r0
 801d004:	2b00      	cmp	r3, #0
 801d006:	d139      	bne.n	801d07c <ecc_projective_add_point_safe+0x106>
        /* x ordinattes the same. */
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d008:	68fb      	ldr	r3, [r7, #12]
 801d00a:	685a      	ldr	r2, [r3, #4]
 801d00c:	68bb      	ldr	r3, [r7, #8]
 801d00e:	685b      	ldr	r3, [r3, #4]
 801d010:	4619      	mov	r1, r3
 801d012:	4610      	mov	r0, r2
 801d014:	f009 fcd6 	bl	80269c4 <mp_cmp>
 801d018:	4603      	mov	r3, r0
 801d01a:	2b00      	cmp	r3, #0
 801d01c:	d109      	bne.n	801d032 <ecc_projective_add_point_safe+0xbc>
            /* A = B */
            err = _ecc_projective_dbl_point(B, R, a, modulus, mp);
 801d01e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d020:	9300      	str	r3, [sp, #0]
 801d022:	6a3b      	ldr	r3, [r7, #32]
 801d024:	683a      	ldr	r2, [r7, #0]
 801d026:	6879      	ldr	r1, [r7, #4]
 801d028:	68b8      	ldr	r0, [r7, #8]
 801d02a:	f7fe fa4c 	bl	801b4c6 <_ecc_projective_dbl_point>
 801d02e:	6178      	str	r0, [r7, #20]
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d030:	e09d      	b.n	801d16e <ecc_projective_add_point_safe+0x1f8>
        }
        else {
            /* A = -B */
            err = mp_set(R->x, 0);
 801d032:	687b      	ldr	r3, [r7, #4]
 801d034:	681b      	ldr	r3, [r3, #0]
 801d036:	2100      	movs	r1, #0
 801d038:	4618      	mov	r0, r3
 801d03a:	f00a f839 	bl	80270b0 <mp_set>
 801d03e:	6178      	str	r0, [r7, #20]
            if (err == MP_OKAY)
 801d040:	697b      	ldr	r3, [r7, #20]
 801d042:	2b00      	cmp	r3, #0
 801d044:	d106      	bne.n	801d054 <ecc_projective_add_point_safe+0xde>
                err = mp_set(R->y, 0);
 801d046:	687b      	ldr	r3, [r7, #4]
 801d048:	685b      	ldr	r3, [r3, #4]
 801d04a:	2100      	movs	r1, #0
 801d04c:	4618      	mov	r0, r3
 801d04e:	f00a f82f 	bl	80270b0 <mp_set>
 801d052:	6178      	str	r0, [r7, #20]
            if (err == MP_OKAY)
 801d054:	697b      	ldr	r3, [r7, #20]
 801d056:	2b00      	cmp	r3, #0
 801d058:	d106      	bne.n	801d068 <ecc_projective_add_point_safe+0xf2>
                err = mp_set(R->z, 1);
 801d05a:	687b      	ldr	r3, [r7, #4]
 801d05c:	689b      	ldr	r3, [r3, #8]
 801d05e:	2101      	movs	r1, #1
 801d060:	4618      	mov	r0, r3
 801d062:	f00a f825 	bl	80270b0 <mp_set>
 801d066:	6178      	str	r0, [r7, #20]
            if ((err == MP_OKAY) && (infinity != NULL))
 801d068:	697b      	ldr	r3, [r7, #20]
 801d06a:	2b00      	cmp	r3, #0
 801d06c:	d17f      	bne.n	801d16e <ecc_projective_add_point_safe+0x1f8>
 801d06e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d070:	2b00      	cmp	r3, #0
 801d072:	d07c      	beq.n	801d16e <ecc_projective_add_point_safe+0x1f8>
                *infinity = 1;
 801d074:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d076:	2201      	movs	r2, #1
 801d078:	601a      	str	r2, [r3, #0]
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d07a:	e078      	b.n	801d16e <ecc_projective_add_point_safe+0x1f8>
        }
    }
    else {
        err = _ecc_projective_add_point(A, B, R, a, modulus, mp);
 801d07c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d07e:	9301      	str	r3, [sp, #4]
 801d080:	6a3b      	ldr	r3, [r7, #32]
 801d082:	9300      	str	r3, [sp, #0]
 801d084:	683b      	ldr	r3, [r7, #0]
 801d086:	687a      	ldr	r2, [r7, #4]
 801d088:	68b9      	ldr	r1, [r7, #8]
 801d08a:	68f8      	ldr	r0, [r7, #12]
 801d08c:	f7fd fd8c 	bl	801aba8 <_ecc_projective_add_point>
 801d090:	6178      	str	r0, [r7, #20]
        if ((err == MP_OKAY) && mp_iszero(R->z)) {
 801d092:	697b      	ldr	r3, [r7, #20]
 801d094:	2b00      	cmp	r3, #0
 801d096:	d16d      	bne.n	801d174 <ecc_projective_add_point_safe+0x1fe>
 801d098:	687b      	ldr	r3, [r7, #4]
 801d09a:	689b      	ldr	r3, [r3, #8]
 801d09c:	4618      	mov	r0, r3
 801d09e:	f009 fd58 	bl	8026b52 <mp_iszero>
 801d0a2:	4603      	mov	r3, r0
 801d0a4:	2b00      	cmp	r3, #0
 801d0a6:	d065      	beq.n	801d174 <ecc_projective_add_point_safe+0x1fe>
            /* When all zero then should have done a double */
            if (mp_iszero(R->x) && mp_iszero(R->y)) {
 801d0a8:	687b      	ldr	r3, [r7, #4]
 801d0aa:	681b      	ldr	r3, [r3, #0]
 801d0ac:	4618      	mov	r0, r3
 801d0ae:	f009 fd50 	bl	8026b52 <mp_iszero>
 801d0b2:	4603      	mov	r3, r0
 801d0b4:	2b00      	cmp	r3, #0
 801d0b6:	d035      	beq.n	801d124 <ecc_projective_add_point_safe+0x1ae>
 801d0b8:	687b      	ldr	r3, [r7, #4]
 801d0ba:	685b      	ldr	r3, [r3, #4]
 801d0bc:	4618      	mov	r0, r3
 801d0be:	f009 fd48 	bl	8026b52 <mp_iszero>
 801d0c2:	4603      	mov	r3, r0
 801d0c4:	2b00      	cmp	r3, #0
 801d0c6:	d02d      	beq.n	801d124 <ecc_projective_add_point_safe+0x1ae>
                if (mp_iszero(B->z)) {
 801d0c8:	68bb      	ldr	r3, [r7, #8]
 801d0ca:	689b      	ldr	r3, [r3, #8]
 801d0cc:	4618      	mov	r0, r3
 801d0ce:	f009 fd40 	bl	8026b52 <mp_iszero>
 801d0d2:	4603      	mov	r3, r0
 801d0d4:	2b00      	cmp	r3, #0
 801d0d6:	d01b      	beq.n	801d110 <ecc_projective_add_point_safe+0x19a>
                    err = wc_ecc_copy_point(B, R);
 801d0d8:	6879      	ldr	r1, [r7, #4]
 801d0da:	68b8      	ldr	r0, [r7, #8]
 801d0dc:	f7ff fc89 	bl	801c9f2 <wc_ecc_copy_point>
 801d0e0:	6178      	str	r0, [r7, #20]
                    if (err == MP_OKAY) {
 801d0e2:	697b      	ldr	r3, [r7, #20]
 801d0e4:	2b00      	cmp	r3, #0
 801d0e6:	d106      	bne.n	801d0f6 <ecc_projective_add_point_safe+0x180>
                        err = mp_montgomery_calc_normalization(R->z, modulus);
 801d0e8:	687b      	ldr	r3, [r7, #4]
 801d0ea:	689b      	ldr	r3, [r3, #8]
 801d0ec:	6a39      	ldr	r1, [r7, #32]
 801d0ee:	4618      	mov	r0, r3
 801d0f0:	f009 fd65 	bl	8026bbe <mp_montgomery_calc_normalization>
 801d0f4:	6178      	str	r0, [r7, #20]
                    }
                    if (err == MP_OKAY) {
 801d0f6:	697b      	ldr	r3, [r7, #20]
 801d0f8:	2b00      	cmp	r3, #0
 801d0fa:	d13a      	bne.n	801d172 <ecc_projective_add_point_safe+0x1fc>
                        err = _ecc_projective_dbl_point(R, R, a, modulus, mp);
 801d0fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d0fe:	9300      	str	r3, [sp, #0]
 801d100:	6a3b      	ldr	r3, [r7, #32]
 801d102:	683a      	ldr	r2, [r7, #0]
 801d104:	6879      	ldr	r1, [r7, #4]
 801d106:	6878      	ldr	r0, [r7, #4]
 801d108:	f7fe f9dd 	bl	801b4c6 <_ecc_projective_dbl_point>
 801d10c:	6178      	str	r0, [r7, #20]
                if (mp_iszero(B->z)) {
 801d10e:	e030      	b.n	801d172 <ecc_projective_add_point_safe+0x1fc>
                    }
                }
                else {
                    err = _ecc_projective_dbl_point(B, R, a, modulus, mp);
 801d110:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d112:	9300      	str	r3, [sp, #0]
 801d114:	6a3b      	ldr	r3, [r7, #32]
 801d116:	683a      	ldr	r2, [r7, #0]
 801d118:	6879      	ldr	r1, [r7, #4]
 801d11a:	68b8      	ldr	r0, [r7, #8]
 801d11c:	f7fe f9d3 	bl	801b4c6 <_ecc_projective_dbl_point>
 801d120:	6178      	str	r0, [r7, #20]
                if (mp_iszero(B->z)) {
 801d122:	e026      	b.n	801d172 <ecc_projective_add_point_safe+0x1fc>
                }
            }
            /* When only Z zero then result is infinity */
            else {
                err = mp_set(R->x, 0);
 801d124:	687b      	ldr	r3, [r7, #4]
 801d126:	681b      	ldr	r3, [r3, #0]
 801d128:	2100      	movs	r1, #0
 801d12a:	4618      	mov	r0, r3
 801d12c:	f009 ffc0 	bl	80270b0 <mp_set>
 801d130:	6178      	str	r0, [r7, #20]
                if (err == MP_OKAY)
 801d132:	697b      	ldr	r3, [r7, #20]
 801d134:	2b00      	cmp	r3, #0
 801d136:	d106      	bne.n	801d146 <ecc_projective_add_point_safe+0x1d0>
                    err = mp_set(R->y, 0);
 801d138:	687b      	ldr	r3, [r7, #4]
 801d13a:	685b      	ldr	r3, [r3, #4]
 801d13c:	2100      	movs	r1, #0
 801d13e:	4618      	mov	r0, r3
 801d140:	f009 ffb6 	bl	80270b0 <mp_set>
 801d144:	6178      	str	r0, [r7, #20]
                if (err == MP_OKAY)
 801d146:	697b      	ldr	r3, [r7, #20]
 801d148:	2b00      	cmp	r3, #0
 801d14a:	d106      	bne.n	801d15a <ecc_projective_add_point_safe+0x1e4>
                    err = mp_set(R->z, 1);
 801d14c:	687b      	ldr	r3, [r7, #4]
 801d14e:	689b      	ldr	r3, [r3, #8]
 801d150:	2101      	movs	r1, #1
 801d152:	4618      	mov	r0, r3
 801d154:	f009 ffac 	bl	80270b0 <mp_set>
 801d158:	6178      	str	r0, [r7, #20]
                if ((err == MP_OKAY) && (infinity != NULL))
 801d15a:	697b      	ldr	r3, [r7, #20]
 801d15c:	2b00      	cmp	r3, #0
 801d15e:	d109      	bne.n	801d174 <ecc_projective_add_point_safe+0x1fe>
 801d160:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d162:	2b00      	cmp	r3, #0
 801d164:	d006      	beq.n	801d174 <ecc_projective_add_point_safe+0x1fe>
                    *infinity = 1;
 801d166:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d168:	2201      	movs	r2, #1
 801d16a:	601a      	str	r2, [r3, #0]
 801d16c:	e002      	b.n	801d174 <ecc_projective_add_point_safe+0x1fe>
        if (mp_cmp(A->y, B->y) == MP_EQ) {
 801d16e:	bf00      	nop
 801d170:	e000      	b.n	801d174 <ecc_projective_add_point_safe+0x1fe>
                if (mp_iszero(B->z)) {
 801d172:	bf00      	nop
            }
        }
    }

    return err;
 801d174:	697b      	ldr	r3, [r7, #20]
}
 801d176:	4618      	mov	r0, r3
 801d178:	3718      	adds	r7, #24
 801d17a:	46bd      	mov	sp, r7
 801d17c:	bd80      	pop	{r7, pc}

0801d17e <ecc_projective_dbl_point_safe>:
 * Double infinity -> infinity.
 * Otherwise do normal double - which can't lead to infinity as odd order.
 */
int ecc_projective_dbl_point_safe(ecc_point *P, ecc_point *R, mp_int* a,
                                  mp_int* modulus, mp_digit mp)
{
 801d17e:	b580      	push	{r7, lr}
 801d180:	b088      	sub	sp, #32
 801d182:	af02      	add	r7, sp, #8
 801d184:	60f8      	str	r0, [r7, #12]
 801d186:	60b9      	str	r1, [r7, #8]
 801d188:	607a      	str	r2, [r7, #4]
 801d18a:	603b      	str	r3, [r7, #0]
    int err;

    if (mp_iszero(P->x) && mp_iszero(P->y)) {
 801d18c:	68fb      	ldr	r3, [r7, #12]
 801d18e:	681b      	ldr	r3, [r3, #0]
 801d190:	4618      	mov	r0, r3
 801d192:	f009 fcde 	bl	8026b52 <mp_iszero>
 801d196:	4603      	mov	r3, r0
 801d198:	2b00      	cmp	r3, #0
 801d19a:	d00d      	beq.n	801d1b8 <ecc_projective_dbl_point_safe+0x3a>
 801d19c:	68fb      	ldr	r3, [r7, #12]
 801d19e:	685b      	ldr	r3, [r3, #4]
 801d1a0:	4618      	mov	r0, r3
 801d1a2:	f009 fcd6 	bl	8026b52 <mp_iszero>
 801d1a6:	4603      	mov	r3, r0
 801d1a8:	2b00      	cmp	r3, #0
 801d1aa:	d005      	beq.n	801d1b8 <ecc_projective_dbl_point_safe+0x3a>
        /* P is infinity. */
        err = wc_ecc_copy_point(P, R);
 801d1ac:	68b9      	ldr	r1, [r7, #8]
 801d1ae:	68f8      	ldr	r0, [r7, #12]
 801d1b0:	f7ff fc1f 	bl	801c9f2 <wc_ecc_copy_point>
 801d1b4:	6178      	str	r0, [r7, #20]
 801d1b6:	e02e      	b.n	801d216 <ecc_projective_dbl_point_safe+0x98>
    }
    else {
        err = _ecc_projective_dbl_point(P, R, a, modulus, mp);
 801d1b8:	6a3b      	ldr	r3, [r7, #32]
 801d1ba:	9300      	str	r3, [sp, #0]
 801d1bc:	683b      	ldr	r3, [r7, #0]
 801d1be:	687a      	ldr	r2, [r7, #4]
 801d1c0:	68b9      	ldr	r1, [r7, #8]
 801d1c2:	68f8      	ldr	r0, [r7, #12]
 801d1c4:	f7fe f97f 	bl	801b4c6 <_ecc_projective_dbl_point>
 801d1c8:	6178      	str	r0, [r7, #20]
        if ((err == MP_OKAY) && mp_iszero(R->z)) {
 801d1ca:	697b      	ldr	r3, [r7, #20]
 801d1cc:	2b00      	cmp	r3, #0
 801d1ce:	d122      	bne.n	801d216 <ecc_projective_dbl_point_safe+0x98>
 801d1d0:	68bb      	ldr	r3, [r7, #8]
 801d1d2:	689b      	ldr	r3, [r3, #8]
 801d1d4:	4618      	mov	r0, r3
 801d1d6:	f009 fcbc 	bl	8026b52 <mp_iszero>
 801d1da:	4603      	mov	r3, r0
 801d1dc:	2b00      	cmp	r3, #0
 801d1de:	d01a      	beq.n	801d216 <ecc_projective_dbl_point_safe+0x98>
           err = mp_set(R->x, 0);
 801d1e0:	68bb      	ldr	r3, [r7, #8]
 801d1e2:	681b      	ldr	r3, [r3, #0]
 801d1e4:	2100      	movs	r1, #0
 801d1e6:	4618      	mov	r0, r3
 801d1e8:	f009 ff62 	bl	80270b0 <mp_set>
 801d1ec:	6178      	str	r0, [r7, #20]
           if (err == MP_OKAY)
 801d1ee:	697b      	ldr	r3, [r7, #20]
 801d1f0:	2b00      	cmp	r3, #0
 801d1f2:	d106      	bne.n	801d202 <ecc_projective_dbl_point_safe+0x84>
               err = mp_set(R->y, 0);
 801d1f4:	68bb      	ldr	r3, [r7, #8]
 801d1f6:	685b      	ldr	r3, [r3, #4]
 801d1f8:	2100      	movs	r1, #0
 801d1fa:	4618      	mov	r0, r3
 801d1fc:	f009 ff58 	bl	80270b0 <mp_set>
 801d200:	6178      	str	r0, [r7, #20]
           if (err == MP_OKAY)
 801d202:	697b      	ldr	r3, [r7, #20]
 801d204:	2b00      	cmp	r3, #0
 801d206:	d106      	bne.n	801d216 <ecc_projective_dbl_point_safe+0x98>
               err = mp_set(R->z, 1);
 801d208:	68bb      	ldr	r3, [r7, #8]
 801d20a:	689b      	ldr	r3, [r3, #8]
 801d20c:	2101      	movs	r1, #1
 801d20e:	4618      	mov	r0, r3
 801d210:	f009 ff4e 	bl	80270b0 <mp_set>
 801d214:	6178      	str	r0, [r7, #20]
        }
    }

    return err;
 801d216:	697b      	ldr	r3, [r7, #20]
}
 801d218:	4618      	mov	r0, r3
 801d21a:	3718      	adds	r7, #24
 801d21c:	46bd      	mov	sp, r7
 801d21e:	bd80      	pop	{r7, pc}

0801d220 <ecc_mont_norm_points>:
    !defined(WOLFSSL_KCAPI_ECC) && !defined(WOLF_CRYPTO_CB_ONLY_ECC)
#ifdef ECC_SHAMIR

static int ecc_mont_norm_points(ecc_point* A, ecc_point* Am, ecc_point* B,
    ecc_point* Bm, mp_int* modulus, void* heap)
{
 801d220:	b580      	push	{r7, lr}
 801d222:	b088      	sub	sp, #32
 801d224:	af00      	add	r7, sp, #0
 801d226:	60f8      	str	r0, [r7, #12]
 801d228:	60b9      	str	r1, [r7, #8]
 801d22a:	607a      	str	r2, [r7, #4]
 801d22c:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801d22e:	2300      	movs	r3, #0
 801d230:	61fb      	str	r3, [r7, #28]
    DECL_MP_INT_SIZE_DYN(mu, mp_bitsused(modulus), MAX_ECC_BITS_USE);
 801d232:	2300      	movs	r3, #0
 801d234:	61bb      	str	r3, [r7, #24]

    (void)heap;

    NEW_MP_INT_SIZE(mu, mp_bitsused(modulus), heap, DYNAMIC_TYPE_ECC);
 801d236:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801d23a:	f001 fc2b 	bl	801ea94 <wolfSSL_Malloc>
 801d23e:	61b8      	str	r0, [r7, #24]
 801d240:	69bb      	ldr	r3, [r7, #24]
 801d242:	2b00      	cmp	r3, #0
 801d244:	d005      	beq.n	801d252 <ecc_mont_norm_points+0x32>
 801d246:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801d24a:	2100      	movs	r1, #0
 801d24c:	69b8      	ldr	r0, [r7, #24]
 801d24e:	f00b f93f 	bl	80284d0 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (mu == NULL)
 801d252:	69bb      	ldr	r3, [r7, #24]
 801d254:	2b00      	cmp	r3, #0
 801d256:	d102      	bne.n	801d25e <ecc_mont_norm_points+0x3e>
       err = MEMORY_E;
 801d258:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801d25c:	61fb      	str	r3, [r7, #28]
#endif
    if (err == MP_OKAY) {
 801d25e:	69fb      	ldr	r3, [r7, #28]
 801d260:	2b00      	cmp	r3, #0
 801d262:	d103      	bne.n	801d26c <ecc_mont_norm_points+0x4c>
        err = INIT_MP_INT_SIZE(mu, mp_bitsused(modulus));
 801d264:	69b8      	ldr	r0, [r7, #24]
 801d266:	f009 fa1a 	bl	802669e <mp_init>
 801d26a:	61f8      	str	r0, [r7, #28]
    }
    if (err == MP_OKAY) {
 801d26c:	69fb      	ldr	r3, [r7, #28]
 801d26e:	2b00      	cmp	r3, #0
 801d270:	d14f      	bne.n	801d312 <ecc_mont_norm_points+0xf2>
        err = mp_montgomery_calc_normalization(mu, modulus);
 801d272:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801d274:	69b8      	ldr	r0, [r7, #24]
 801d276:	f009 fca2 	bl	8026bbe <mp_montgomery_calc_normalization>
 801d27a:	61f8      	str	r0, [r7, #28]

        if (err == MP_OKAY) {
 801d27c:	69fb      	ldr	r3, [r7, #28]
 801d27e:	2b00      	cmp	r3, #0
 801d280:	d108      	bne.n	801d294 <ecc_mont_norm_points+0x74>
            /* copy ones ... */
            err = mp_mulmod(A->x, mu, modulus, Am->x);
 801d282:	68fb      	ldr	r3, [r7, #12]
 801d284:	6818      	ldr	r0, [r3, #0]
 801d286:	68bb      	ldr	r3, [r7, #8]
 801d288:	681b      	ldr	r3, [r3, #0]
 801d28a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d28c:	69b9      	ldr	r1, [r7, #24]
 801d28e:	f009 fb0a 	bl	80268a6 <mp_mulmod>
 801d292:	61f8      	str	r0, [r7, #28]
        }

        if (err == MP_OKAY)
 801d294:	69fb      	ldr	r3, [r7, #28]
 801d296:	2b00      	cmp	r3, #0
 801d298:	d108      	bne.n	801d2ac <ecc_mont_norm_points+0x8c>
            err = mp_mulmod(A->y, mu, modulus, Am->y);
 801d29a:	68fb      	ldr	r3, [r7, #12]
 801d29c:	6858      	ldr	r0, [r3, #4]
 801d29e:	68bb      	ldr	r3, [r7, #8]
 801d2a0:	685b      	ldr	r3, [r3, #4]
 801d2a2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d2a4:	69b9      	ldr	r1, [r7, #24]
 801d2a6:	f009 fafe 	bl	80268a6 <mp_mulmod>
 801d2aa:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801d2ac:	69fb      	ldr	r3, [r7, #28]
 801d2ae:	2b00      	cmp	r3, #0
 801d2b0:	d108      	bne.n	801d2c4 <ecc_mont_norm_points+0xa4>
            err = mp_mulmod(A->z, mu, modulus, Am->z);
 801d2b2:	68fb      	ldr	r3, [r7, #12]
 801d2b4:	6898      	ldr	r0, [r3, #8]
 801d2b6:	68bb      	ldr	r3, [r7, #8]
 801d2b8:	689b      	ldr	r3, [r3, #8]
 801d2ba:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d2bc:	69b9      	ldr	r1, [r7, #24]
 801d2be:	f009 faf2 	bl	80268a6 <mp_mulmod>
 801d2c2:	61f8      	str	r0, [r7, #28]

        if (err == MP_OKAY)
 801d2c4:	69fb      	ldr	r3, [r7, #28]
 801d2c6:	2b00      	cmp	r3, #0
 801d2c8:	d108      	bne.n	801d2dc <ecc_mont_norm_points+0xbc>
            err = mp_mulmod(B->x, mu, modulus, Bm->x);
 801d2ca:	687b      	ldr	r3, [r7, #4]
 801d2cc:	6818      	ldr	r0, [r3, #0]
 801d2ce:	683b      	ldr	r3, [r7, #0]
 801d2d0:	681b      	ldr	r3, [r3, #0]
 801d2d2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d2d4:	69b9      	ldr	r1, [r7, #24]
 801d2d6:	f009 fae6 	bl	80268a6 <mp_mulmod>
 801d2da:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801d2dc:	69fb      	ldr	r3, [r7, #28]
 801d2de:	2b00      	cmp	r3, #0
 801d2e0:	d108      	bne.n	801d2f4 <ecc_mont_norm_points+0xd4>
            err = mp_mulmod(B->y, mu, modulus, Bm->y);
 801d2e2:	687b      	ldr	r3, [r7, #4]
 801d2e4:	6858      	ldr	r0, [r3, #4]
 801d2e6:	683b      	ldr	r3, [r7, #0]
 801d2e8:	685b      	ldr	r3, [r3, #4]
 801d2ea:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d2ec:	69b9      	ldr	r1, [r7, #24]
 801d2ee:	f009 fada 	bl	80268a6 <mp_mulmod>
 801d2f2:	61f8      	str	r0, [r7, #28]
        if (err == MP_OKAY)
 801d2f4:	69fb      	ldr	r3, [r7, #28]
 801d2f6:	2b00      	cmp	r3, #0
 801d2f8:	d108      	bne.n	801d30c <ecc_mont_norm_points+0xec>
            err = mp_mulmod(B->z, mu, modulus, Bm->z);
 801d2fa:	687b      	ldr	r3, [r7, #4]
 801d2fc:	6898      	ldr	r0, [r3, #8]
 801d2fe:	683b      	ldr	r3, [r7, #0]
 801d300:	689b      	ldr	r3, [r3, #8]
 801d302:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d304:	69b9      	ldr	r1, [r7, #24]
 801d306:	f009 face 	bl	80268a6 <mp_mulmod>
 801d30a:	61f8      	str	r0, [r7, #28]

        /* done with mu */
        mp_clear(mu);
 801d30c:	69b8      	ldr	r0, [r7, #24]
 801d30e:	f009 fa50 	bl	80267b2 <mp_clear>
    }

    FREE_MP_INT_SIZE(mu, heap, DYNAMIC_TYPE_ECC);
 801d312:	69bb      	ldr	r3, [r7, #24]
 801d314:	617b      	str	r3, [r7, #20]
 801d316:	697b      	ldr	r3, [r7, #20]
 801d318:	2b00      	cmp	r3, #0
 801d31a:	d002      	beq.n	801d322 <ecc_mont_norm_points+0x102>
 801d31c:	6978      	ldr	r0, [r7, #20]
 801d31e:	f001 fbd5 	bl	801eacc <wolfSSL_Free>

    return err;
 801d322:	69fb      	ldr	r3, [r7, #28]
}
 801d324:	4618      	mov	r0, r3
 801d326:	3720      	adds	r7, #32
 801d328:	46bd      	mov	sp, r7
 801d32a:	bd80      	pop	{r7, pc}

0801d32c <ecc_mul2add>:
int ecc_mul2add(ecc_point* A, mp_int* kA,
                    ecc_point* B, mp_int* kB,
                    ecc_point* C, mp_int* a, mp_int* modulus,
                    void* heap)
#endif
{
 801d32c:	b590      	push	{r4, r7, lr}
 801d32e:	b0a1      	sub	sp, #132	@ 0x84
 801d330:	af04      	add	r7, sp, #16
 801d332:	60f8      	str	r0, [r7, #12]
 801d334:	60b9      	str	r1, [r7, #8]
 801d336:	607a      	str	r2, [r7, #4]
 801d338:	603b      	str	r3, [r7, #0]
#ifdef WOLFSSL_SMALL_STACK_CACHE
  ecc_key        *key = NULL;
#endif
#ifdef WOLFSSL_SMALL_STACK
  ecc_point**    precomp = NULL;
 801d33a:	2300      	movs	r3, #0
 801d33c:	657b      	str	r3, [r7, #84]	@ 0x54
  unsigned int  bitbufA, bitbufB, lenA, lenB, len, nA, nB, nibble;
#ifdef WOLFSSL_NO_MALLOC
  unsigned char tA[ECC_BUFSIZE];
  unsigned char tB[ECC_BUFSIZE];
#else
  unsigned char* tA = NULL;
 801d33e:	2300      	movs	r3, #0
 801d340:	653b      	str	r3, [r7, #80]	@ 0x50
  unsigned char* tB = NULL;
 801d342:	2300      	movs	r3, #0
 801d344:	64fb      	str	r3, [r7, #76]	@ 0x4c
#endif
  int            err = MP_OKAY, first, x, y;
 801d346:	2300      	movs	r3, #0
 801d348:	663b      	str	r3, [r7, #96]	@ 0x60
  mp_digit       mp = 0;
 801d34a:	2300      	movs	r3, #0
 801d34c:	617b      	str	r3, [r7, #20]

  /* argchks */
  if (A == NULL || kA == NULL || B == NULL || kB == NULL || C == NULL ||
 801d34e:	68fb      	ldr	r3, [r7, #12]
 801d350:	2b00      	cmp	r3, #0
 801d352:	d010      	beq.n	801d376 <ecc_mul2add+0x4a>
 801d354:	68bb      	ldr	r3, [r7, #8]
 801d356:	2b00      	cmp	r3, #0
 801d358:	d00d      	beq.n	801d376 <ecc_mul2add+0x4a>
 801d35a:	687b      	ldr	r3, [r7, #4]
 801d35c:	2b00      	cmp	r3, #0
 801d35e:	d00a      	beq.n	801d376 <ecc_mul2add+0x4a>
 801d360:	683b      	ldr	r3, [r7, #0]
 801d362:	2b00      	cmp	r3, #0
 801d364:	d007      	beq.n	801d376 <ecc_mul2add+0x4a>
 801d366:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d36a:	2b00      	cmp	r3, #0
 801d36c:	d003      	beq.n	801d376 <ecc_mul2add+0x4a>
 801d36e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d372:	2b00      	cmp	r3, #0
 801d374:	d102      	bne.n	801d37c <ecc_mul2add+0x50>
                                                         modulus == NULL) {
     return ECC_BAD_ARG_E;
 801d376:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801d37a:	e261      	b.n	801d840 <ecc_mul2add+0x514>
  }

#ifndef WOLFSSL_NO_MALLOC
  /* allocate memory */
  tA = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d37c:	f240 1001 	movw	r0, #257	@ 0x101
 801d380:	f001 fb88 	bl	801ea94 <wolfSSL_Malloc>
 801d384:	6538      	str	r0, [r7, #80]	@ 0x50
  if (tA == NULL) {
 801d386:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d388:	2b00      	cmp	r3, #0
 801d38a:	d102      	bne.n	801d392 <ecc_mul2add+0x66>
     return MP_MEM;
 801d38c:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 801d390:	e256      	b.n	801d840 <ecc_mul2add+0x514>
  }
  tB = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d392:	f240 1001 	movw	r0, #257	@ 0x101
 801d396:	f001 fb7d 	bl	801ea94 <wolfSSL_Malloc>
 801d39a:	64f8      	str	r0, [r7, #76]	@ 0x4c
  if (tB == NULL) {
 801d39c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d39e:	2b00      	cmp	r3, #0
 801d3a0:	d10a      	bne.n	801d3b8 <ecc_mul2add+0x8c>
     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d3a2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d3a4:	61fb      	str	r3, [r7, #28]
 801d3a6:	69fb      	ldr	r3, [r7, #28]
 801d3a8:	2b00      	cmp	r3, #0
 801d3aa:	d002      	beq.n	801d3b2 <ecc_mul2add+0x86>
 801d3ac:	69f8      	ldr	r0, [r7, #28]
 801d3ae:	f001 fb8d 	bl	801eacc <wolfSSL_Free>
     return MP_MEM;
 801d3b2:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 801d3b6:	e243      	b.n	801d840 <ecc_mul2add+0x514>
     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
     return MP_MEM;
  }
#endif
#ifdef WOLFSSL_SMALL_STACK
  precomp = (ecc_point**)XMALLOC(sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ, heap,
 801d3b8:	2040      	movs	r0, #64	@ 0x40
 801d3ba:	f001 fb6b 	bl	801ea94 <wolfSSL_Malloc>
 801d3be:	6578      	str	r0, [r7, #84]	@ 0x54
                                                       DYNAMIC_TYPE_ECC_BUFFER);
  if (precomp == NULL) {
 801d3c0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d3c2:	2b00      	cmp	r3, #0
 801d3c4:	d112      	bne.n	801d3ec <ecc_mul2add+0xc0>
     XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d3c6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d3c8:	627b      	str	r3, [r7, #36]	@ 0x24
 801d3ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801d3cc:	2b00      	cmp	r3, #0
 801d3ce:	d002      	beq.n	801d3d6 <ecc_mul2add+0xaa>
 801d3d0:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801d3d2:	f001 fb7b 	bl	801eacc <wolfSSL_Free>
     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d3d6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d3d8:	623b      	str	r3, [r7, #32]
 801d3da:	6a3b      	ldr	r3, [r7, #32]
 801d3dc:	2b00      	cmp	r3, #0
 801d3de:	d002      	beq.n	801d3e6 <ecc_mul2add+0xba>
 801d3e0:	6a38      	ldr	r0, [r7, #32]
 801d3e2:	f001 fb73 	bl	801eacc <wolfSSL_Free>
  #ifdef WOLFSSL_SMALL_STACK_CACHE
     XFREE(key, heap, DYNAMIC_TYPE_ECC_BUFFER);
  #endif
     return MP_MEM;
 801d3e6:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 801d3ea:	e229      	b.n	801d840 <ecc_mul2add+0x514>
  }
  C->key = key;
#endif /* WOLFSSL_SMALL_STACK_CACHE */

  /* init variables */
  XMEMSET(tA, 0, ECC_BUFSIZE);
 801d3ec:	f240 1201 	movw	r2, #257	@ 0x101
 801d3f0:	2100      	movs	r1, #0
 801d3f2:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801d3f4:	f00b f86c 	bl	80284d0 <memset>
  XMEMSET(tB, 0, ECC_BUFSIZE);
 801d3f8:	f240 1201 	movw	r2, #257	@ 0x101
 801d3fc:	2100      	movs	r1, #0
 801d3fe:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801d400:	f00b f866 	bl	80284d0 <memset>
#ifndef WOLFSSL_SMALL_STACK
  XMEMSET(precomp, 0, sizeof(precomp));
#else
  XMEMSET(precomp, 0, sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ);
 801d404:	2240      	movs	r2, #64	@ 0x40
 801d406:	2100      	movs	r1, #0
 801d408:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801d40a:	f00b f861 	bl	80284d0 <memset>
  wc_MemZero_Add("ecc_mul2add tA", tA, ECC_BUFSIZE);
  wc_MemZero_Add("ecc_mul2add tB", tB, ECC_BUFSIZE);
#endif

  /* get sizes */
  lenA = (unsigned int)mp_unsigned_bin_size(kA);
 801d40e:	68b8      	ldr	r0, [r7, #8]
 801d410:	f009 faf4 	bl	80269fc <mp_unsigned_bin_size>
 801d414:	4603      	mov	r3, r0
 801d416:	64bb      	str	r3, [r7, #72]	@ 0x48
  lenB = (unsigned int)mp_unsigned_bin_size(kB);
 801d418:	6838      	ldr	r0, [r7, #0]
 801d41a:	f009 faef 	bl	80269fc <mp_unsigned_bin_size>
 801d41e:	4603      	mov	r3, r0
 801d420:	647b      	str	r3, [r7, #68]	@ 0x44
  len  = MAX(lenA, lenB);
 801d422:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801d424:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d426:	4293      	cmp	r3, r2
 801d428:	bf38      	it	cc
 801d42a:	4613      	movcc	r3, r2
 801d42c:	643b      	str	r3, [r7, #64]	@ 0x40

  /* sanity check */
  if ((lenA > ECC_BUFSIZE) || (lenB > ECC_BUFSIZE)) {
 801d42e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d430:	f5b3 7f81 	cmp.w	r3, #258	@ 0x102
 801d434:	d203      	bcs.n	801d43e <ecc_mul2add+0x112>
 801d436:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d438:	f5b3 7f81 	cmp.w	r3, #258	@ 0x102
 801d43c:	d302      	bcc.n	801d444 <ecc_mul2add+0x118>
    err = BAD_FUNC_ARG;
 801d43e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801d442:	663b      	str	r3, [r7, #96]	@ 0x60
  }

  if (err == MP_OKAY) {
 801d444:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d446:	2b00      	cmp	r3, #0
 801d448:	d131      	bne.n	801d4ae <ecc_mul2add+0x182>
    /* extract and justify kA */
    err = mp_to_unsigned_bin(kA, (len - lenA) + tA);
 801d44a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801d44c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d44e:	1ad3      	subs	r3, r2, r3
 801d450:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801d452:	4413      	add	r3, r2
 801d454:	4619      	mov	r1, r3
 801d456:	68b8      	ldr	r0, [r7, #8]
 801d458:	f009 fadc 	bl	8026a14 <mp_to_unsigned_bin>
 801d45c:	6638      	str	r0, [r7, #96]	@ 0x60

    /* extract and justify kB */
    if (err == MP_OKAY)
 801d45e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d460:	2b00      	cmp	r3, #0
 801d462:	d109      	bne.n	801d478 <ecc_mul2add+0x14c>
        err = mp_to_unsigned_bin(kB, (len - lenB) + tB);
 801d464:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801d466:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d468:	1ad3      	subs	r3, r2, r3
 801d46a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801d46c:	4413      	add	r3, r2
 801d46e:	4619      	mov	r1, r3
 801d470:	6838      	ldr	r0, [r7, #0]
 801d472:	f009 facf 	bl	8026a14 <mp_to_unsigned_bin>
 801d476:	6638      	str	r0, [r7, #96]	@ 0x60

    /* allocate the table */
    if (err == MP_OKAY) {
 801d478:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d47a:	2b00      	cmp	r3, #0
 801d47c:	d117      	bne.n	801d4ae <ecc_mul2add+0x182>
        for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d47e:	2300      	movs	r3, #0
 801d480:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d482:	e00f      	b.n	801d4a4 <ecc_mul2add+0x178>
        #ifdef WOLFSSL_NO_MALLOC
            precomp[x] = &lcl_precomp[x];
        #endif
            err = wc_ecc_new_point_ex(&precomp[x], heap);
 801d484:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d486:	009b      	lsls	r3, r3, #2
 801d488:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d48a:	4413      	add	r3, r2
 801d48c:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 801d490:	4618      	mov	r0, r3
 801d492:	f7ff fa22 	bl	801c8da <wc_ecc_new_point_ex>
 801d496:	6638      	str	r0, [r7, #96]	@ 0x60
            if (err != MP_OKAY)
 801d498:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d49a:	2b00      	cmp	r3, #0
 801d49c:	d106      	bne.n	801d4ac <ecc_mul2add+0x180>
        for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d49e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d4a0:	3301      	adds	r3, #1
 801d4a2:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d4a4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d4a6:	2b0f      	cmp	r3, #15
 801d4a8:	ddec      	ble.n	801d484 <ecc_mul2add+0x158>
 801d4aa:	e000      	b.n	801d4ae <ecc_mul2add+0x182>
                break;
 801d4ac:	bf00      	nop
        #endif
        }
    }
  }

  if (err == MP_OKAY)
 801d4ae:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d4b0:	2b00      	cmp	r3, #0
 801d4b2:	d107      	bne.n	801d4c4 <ecc_mul2add+0x198>
    /* init montgomery reduction */
    err = mp_montgomery_setup(modulus, &mp);
 801d4b4:	f107 0314 	add.w	r3, r7, #20
 801d4b8:	4619      	mov	r1, r3
 801d4ba:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801d4be:	f009 fdcb 	bl	8027058 <mp_montgomery_setup>
 801d4c2:	6638      	str	r0, [r7, #96]	@ 0x60

  if (err == MP_OKAY) {
 801d4c4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d4c6:	2b00      	cmp	r3, #0
 801d4c8:	d111      	bne.n	801d4ee <ecc_mul2add+0x1c2>
    err = ecc_mont_norm_points(A, precomp[1], B, precomp[1<<2], modulus, heap);
 801d4ca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d4cc:	3304      	adds	r3, #4
 801d4ce:	6819      	ldr	r1, [r3, #0]
 801d4d0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d4d2:	3310      	adds	r3, #16
 801d4d4:	681a      	ldr	r2, [r3, #0]
 801d4d6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801d4da:	9301      	str	r3, [sp, #4]
 801d4dc:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d4e0:	9300      	str	r3, [sp, #0]
 801d4e2:	4613      	mov	r3, r2
 801d4e4:	687a      	ldr	r2, [r7, #4]
 801d4e6:	68f8      	ldr	r0, [r7, #12]
 801d4e8:	f7ff fe9a 	bl	801d220 <ecc_mont_norm_points>
 801d4ec:	6638      	str	r0, [r7, #96]	@ 0x60
  }

  if (err == MP_OKAY) {
 801d4ee:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d4f0:	2b00      	cmp	r3, #0
 801d4f2:	d10e      	bne.n	801d512 <ecc_mul2add+0x1e6>
    /* precomp [i,0](A + B) table */
    err = ecc_projective_dbl_point_safe(precomp[1], precomp[2], a, modulus, mp);
 801d4f4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d4f6:	3304      	adds	r3, #4
 801d4f8:	6818      	ldr	r0, [r3, #0]
 801d4fa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d4fc:	3308      	adds	r3, #8
 801d4fe:	6819      	ldr	r1, [r3, #0]
 801d500:	697b      	ldr	r3, [r7, #20]
 801d502:	9300      	str	r3, [sp, #0]
 801d504:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d508:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d50c:	f7ff fe37 	bl	801d17e <ecc_projective_dbl_point_safe>
 801d510:	6638      	str	r0, [r7, #96]	@ 0x60
  }
  if (err == MP_OKAY) {
 801d512:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d514:	2b00      	cmp	r3, #0
 801d516:	d114      	bne.n	801d542 <ecc_mul2add+0x216>
    err = ecc_projective_add_point_safe(precomp[1], precomp[2], precomp[3],
 801d518:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d51a:	3304      	adds	r3, #4
 801d51c:	6818      	ldr	r0, [r3, #0]
 801d51e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d520:	3308      	adds	r3, #8
 801d522:	6819      	ldr	r1, [r3, #0]
 801d524:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d526:	330c      	adds	r3, #12
 801d528:	681a      	ldr	r2, [r3, #0]
 801d52a:	697b      	ldr	r3, [r7, #20]
 801d52c:	2400      	movs	r4, #0
 801d52e:	9402      	str	r4, [sp, #8]
 801d530:	9301      	str	r3, [sp, #4]
 801d532:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d536:	9300      	str	r3, [sp, #0]
 801d538:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d53c:	f7ff fd1b 	bl	801cf76 <ecc_projective_add_point_safe>
 801d540:	6638      	str	r0, [r7, #96]	@ 0x60
                                                          a, modulus, mp, NULL);
  }

  if (err == MP_OKAY) {
 801d542:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d544:	2b00      	cmp	r3, #0
 801d546:	d10e      	bne.n	801d566 <ecc_mul2add+0x23a>
    /* precomp [0,i](A + B) table */
    err = ecc_projective_dbl_point_safe(precomp[4], precomp[8], a, modulus, mp);
 801d548:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d54a:	3310      	adds	r3, #16
 801d54c:	6818      	ldr	r0, [r3, #0]
 801d54e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d550:	3320      	adds	r3, #32
 801d552:	6819      	ldr	r1, [r3, #0]
 801d554:	697b      	ldr	r3, [r7, #20]
 801d556:	9300      	str	r3, [sp, #0]
 801d558:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d55c:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d560:	f7ff fe0d 	bl	801d17e <ecc_projective_dbl_point_safe>
 801d564:	6638      	str	r0, [r7, #96]	@ 0x60
  }
  if (err == MP_OKAY) {
 801d566:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d568:	2b00      	cmp	r3, #0
 801d56a:	d114      	bne.n	801d596 <ecc_mul2add+0x26a>
    err = ecc_projective_add_point_safe(precomp[4], precomp[8], precomp[12], a,
 801d56c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d56e:	3310      	adds	r3, #16
 801d570:	6818      	ldr	r0, [r3, #0]
 801d572:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d574:	3320      	adds	r3, #32
 801d576:	6819      	ldr	r1, [r3, #0]
 801d578:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d57a:	3330      	adds	r3, #48	@ 0x30
 801d57c:	681a      	ldr	r2, [r3, #0]
 801d57e:	697b      	ldr	r3, [r7, #20]
 801d580:	2400      	movs	r4, #0
 801d582:	9402      	str	r4, [sp, #8]
 801d584:	9301      	str	r3, [sp, #4]
 801d586:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d58a:	9300      	str	r3, [sp, #0]
 801d58c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d590:	f7ff fcf1 	bl	801cf76 <ecc_projective_add_point_safe>
 801d594:	6638      	str	r0, [r7, #96]	@ 0x60
                                                             modulus, mp, NULL);
  }

  if (err == MP_OKAY) {
 801d596:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d598:	2b00      	cmp	r3, #0
 801d59a:	d132      	bne.n	801d602 <ecc_mul2add+0x2d6>
    /* precomp [i,j](A + B) table (i != 0, j != 0) */
    for (x = 1; x < 4; x++) {
 801d59c:	2301      	movs	r3, #1
 801d59e:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d5a0:	e02c      	b.n	801d5fc <ecc_mul2add+0x2d0>
      for (y = 1; y < 4; y++) {
 801d5a2:	2301      	movs	r3, #1
 801d5a4:	65bb      	str	r3, [r7, #88]	@ 0x58
 801d5a6:	e023      	b.n	801d5f0 <ecc_mul2add+0x2c4>
        if (err == MP_OKAY) {
 801d5a8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d5aa:	2b00      	cmp	r3, #0
 801d5ac:	d11d      	bne.n	801d5ea <ecc_mul2add+0x2be>
          err = ecc_projective_add_point_safe(precomp[x], precomp[(y<<2)],
 801d5ae:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d5b0:	009b      	lsls	r3, r3, #2
 801d5b2:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d5b4:	4413      	add	r3, r2
 801d5b6:	6818      	ldr	r0, [r3, #0]
 801d5b8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d5ba:	011b      	lsls	r3, r3, #4
 801d5bc:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d5be:	4413      	add	r3, r2
 801d5c0:	6819      	ldr	r1, [r3, #0]
                                                  precomp[x+(y<<2)], a, modulus,
 801d5c2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d5c4:	009a      	lsls	r2, r3, #2
 801d5c6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d5c8:	4413      	add	r3, r2
 801d5ca:	009b      	lsls	r3, r3, #2
 801d5cc:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d5ce:	4413      	add	r3, r2
          err = ecc_projective_add_point_safe(precomp[x], precomp[(y<<2)],
 801d5d0:	681a      	ldr	r2, [r3, #0]
 801d5d2:	697b      	ldr	r3, [r7, #20]
 801d5d4:	2400      	movs	r4, #0
 801d5d6:	9402      	str	r4, [sp, #8]
 801d5d8:	9301      	str	r3, [sp, #4]
 801d5da:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d5de:	9300      	str	r3, [sp, #0]
 801d5e0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d5e4:	f7ff fcc7 	bl	801cf76 <ecc_projective_add_point_safe>
 801d5e8:	6638      	str	r0, [r7, #96]	@ 0x60
      for (y = 1; y < 4; y++) {
 801d5ea:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d5ec:	3301      	adds	r3, #1
 801d5ee:	65bb      	str	r3, [r7, #88]	@ 0x58
 801d5f0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d5f2:	2b03      	cmp	r3, #3
 801d5f4:	ddd8      	ble.n	801d5a8 <ecc_mul2add+0x27c>
    for (x = 1; x < 4; x++) {
 801d5f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d5f8:	3301      	adds	r3, #1
 801d5fa:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d5fc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d5fe:	2b03      	cmp	r3, #3
 801d600:	ddcf      	ble.n	801d5a2 <ecc_mul2add+0x276>
        }
      }
    }
  }

  if (err == MP_OKAY) {
 801d602:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d604:	2b00      	cmp	r3, #0
 801d606:	f040 80d9 	bne.w	801d7bc <ecc_mul2add+0x490>
    nibble  = 3;
 801d60a:	2303      	movs	r3, #3
 801d60c:	667b      	str	r3, [r7, #100]	@ 0x64
    first   = 1;
 801d60e:	2301      	movs	r3, #1
 801d610:	61bb      	str	r3, [r7, #24]
    bitbufA = tA[0];
 801d612:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d614:	781b      	ldrb	r3, [r3, #0]
 801d616:	66fb      	str	r3, [r7, #108]	@ 0x6c
    bitbufB = tB[0];
 801d618:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d61a:	781b      	ldrb	r3, [r3, #0]
 801d61c:	66bb      	str	r3, [r7, #104]	@ 0x68

    /* for every byte of the multiplicands */
    for (x = 0; x < (int)len || nibble != 3; ) {
 801d61e:	2300      	movs	r3, #0
 801d620:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d622:	e0ba      	b.n	801d79a <ecc_mul2add+0x46e>
        /* grab a nibble */
        if (++nibble == 4) {
 801d624:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d626:	3301      	adds	r3, #1
 801d628:	667b      	str	r3, [r7, #100]	@ 0x64
 801d62a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d62c:	2b04      	cmp	r3, #4
 801d62e:	d113      	bne.n	801d658 <ecc_mul2add+0x32c>
            if (x == (int)len) break;
 801d630:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801d632:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801d634:	429a      	cmp	r2, r3
 801d636:	f000 80ba 	beq.w	801d7ae <ecc_mul2add+0x482>
            bitbufA = tA[x];
 801d63a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d63c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801d63e:	4413      	add	r3, r2
 801d640:	781b      	ldrb	r3, [r3, #0]
 801d642:	66fb      	str	r3, [r7, #108]	@ 0x6c
            bitbufB = tB[x];
 801d644:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d646:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801d648:	4413      	add	r3, r2
 801d64a:	781b      	ldrb	r3, [r3, #0]
 801d64c:	66bb      	str	r3, [r7, #104]	@ 0x68
            nibble  = 0;
 801d64e:	2300      	movs	r3, #0
 801d650:	667b      	str	r3, [r7, #100]	@ 0x64
            x++;
 801d652:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d654:	3301      	adds	r3, #1
 801d656:	65fb      	str	r3, [r7, #92]	@ 0x5c
        }

        /* extract two bits from both, shift/update */
        nA = (bitbufA >> 6) & 0x03;
 801d658:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801d65a:	099b      	lsrs	r3, r3, #6
 801d65c:	f003 0303 	and.w	r3, r3, #3
 801d660:	63fb      	str	r3, [r7, #60]	@ 0x3c
        nB = (bitbufB >> 6) & 0x03;
 801d662:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801d664:	099b      	lsrs	r3, r3, #6
 801d666:	f003 0303 	and.w	r3, r3, #3
 801d66a:	63bb      	str	r3, [r7, #56]	@ 0x38
        bitbufA = (bitbufA << 2) & 0xFF;
 801d66c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801d66e:	009b      	lsls	r3, r3, #2
 801d670:	b2db      	uxtb	r3, r3
 801d672:	66fb      	str	r3, [r7, #108]	@ 0x6c
        bitbufB = (bitbufB << 2) & 0xFF;
 801d674:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801d676:	009b      	lsls	r3, r3, #2
 801d678:	b2db      	uxtb	r3, r3
 801d67a:	66bb      	str	r3, [r7, #104]	@ 0x68

        /* if both zero, if first, continue */
        if ((nA == 0) && (nB == 0) && (first == 1)) {
 801d67c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d67e:	2b00      	cmp	r3, #0
 801d680:	d106      	bne.n	801d690 <ecc_mul2add+0x364>
 801d682:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d684:	2b00      	cmp	r3, #0
 801d686:	d103      	bne.n	801d690 <ecc_mul2add+0x364>
 801d688:	69bb      	ldr	r3, [r7, #24]
 801d68a:	2b01      	cmp	r3, #1
 801d68c:	f000 8084 	beq.w	801d798 <ecc_mul2add+0x46c>
            continue;
        }

        /* double twice, only if this isn't the first */
        if (first == 0) {
 801d690:	69bb      	ldr	r3, [r7, #24]
 801d692:	2b00      	cmp	r3, #0
 801d694:	d11f      	bne.n	801d6d6 <ecc_mul2add+0x3aa>
            /* double twice */
            if (err == MP_OKAY)
 801d696:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d698:	2b00      	cmp	r3, #0
 801d69a:	d10c      	bne.n	801d6b6 <ecc_mul2add+0x38a>
                err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
 801d69c:	697b      	ldr	r3, [r7, #20]
 801d69e:	9300      	str	r3, [sp, #0]
 801d6a0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d6a4:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d6a8:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
 801d6ac:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d6b0:	f7ff fd65 	bl	801d17e <ecc_projective_dbl_point_safe>
 801d6b4:	6638      	str	r0, [r7, #96]	@ 0x60
            if (err == MP_OKAY)
 801d6b6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d6b8:	2b00      	cmp	r3, #0
 801d6ba:	d17a      	bne.n	801d7b2 <ecc_mul2add+0x486>
                err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
 801d6bc:	697b      	ldr	r3, [r7, #20]
 801d6be:	9300      	str	r3, [sp, #0]
 801d6c0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d6c4:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 801d6c8:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
 801d6cc:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d6d0:	f7ff fd55 	bl	801d17e <ecc_projective_dbl_point_safe>
 801d6d4:	6638      	str	r0, [r7, #96]	@ 0x60
            else
                break;
        }

        /* if not both zero */
        if ((nA != 0) || (nB != 0)) {
 801d6d6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d6d8:	2b00      	cmp	r3, #0
 801d6da:	d102      	bne.n	801d6e2 <ecc_mul2add+0x3b6>
 801d6dc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d6de:	2b00      	cmp	r3, #0
 801d6e0:	d05b      	beq.n	801d79a <ecc_mul2add+0x46e>
            unsigned int i = nA + (nB<<2);
 801d6e2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d6e4:	009b      	lsls	r3, r3, #2
 801d6e6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801d6e8:	4413      	add	r3, r2
 801d6ea:	637b      	str	r3, [r7, #52]	@ 0x34
            if (first == 1) {
 801d6ec:	69bb      	ldr	r3, [r7, #24]
 801d6ee:	2b01      	cmp	r3, #1
 801d6f0:	d135      	bne.n	801d75e <ecc_mul2add+0x432>
                /* if first, copy from table */
                first = 0;
 801d6f2:	2300      	movs	r3, #0
 801d6f4:	61bb      	str	r3, [r7, #24]
                if (err == MP_OKAY)
 801d6f6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d6f8:	2b00      	cmp	r3, #0
 801d6fa:	d10d      	bne.n	801d718 <ecc_mul2add+0x3ec>
                    err = mp_copy(precomp[i]->x, C->x);
 801d6fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d6fe:	009b      	lsls	r3, r3, #2
 801d700:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d702:	4413      	add	r3, r2
 801d704:	681b      	ldr	r3, [r3, #0]
 801d706:	681a      	ldr	r2, [r3, #0]
 801d708:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d70c:	681b      	ldr	r3, [r3, #0]
 801d70e:	4619      	mov	r1, r3
 801d710:	4610      	mov	r0, r2
 801d712:	f009 fa10 	bl	8026b36 <mp_copy>
 801d716:	6638      	str	r0, [r7, #96]	@ 0x60

                if (err == MP_OKAY)
 801d718:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d71a:	2b00      	cmp	r3, #0
 801d71c:	d10d      	bne.n	801d73a <ecc_mul2add+0x40e>
                    err = mp_copy(precomp[i]->y, C->y);
 801d71e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d720:	009b      	lsls	r3, r3, #2
 801d722:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d724:	4413      	add	r3, r2
 801d726:	681b      	ldr	r3, [r3, #0]
 801d728:	685a      	ldr	r2, [r3, #4]
 801d72a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d72e:	685b      	ldr	r3, [r3, #4]
 801d730:	4619      	mov	r1, r3
 801d732:	4610      	mov	r0, r2
 801d734:	f009 f9ff 	bl	8026b36 <mp_copy>
 801d738:	6638      	str	r0, [r7, #96]	@ 0x60

                if (err == MP_OKAY)
 801d73a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d73c:	2b00      	cmp	r3, #0
 801d73e:	d13a      	bne.n	801d7b6 <ecc_mul2add+0x48a>
                    err = mp_copy(precomp[i]->z, C->z);
 801d740:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d742:	009b      	lsls	r3, r3, #2
 801d744:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d746:	4413      	add	r3, r2
 801d748:	681b      	ldr	r3, [r3, #0]
 801d74a:	689a      	ldr	r2, [r3, #8]
 801d74c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d750:	689b      	ldr	r3, [r3, #8]
 801d752:	4619      	mov	r1, r3
 801d754:	4610      	mov	r0, r2
 801d756:	f009 f9ee 	bl	8026b36 <mp_copy>
 801d75a:	6638      	str	r0, [r7, #96]	@ 0x60
 801d75c:	e01d      	b.n	801d79a <ecc_mul2add+0x46e>
                else
                    break;
            } else {
                /* if not first, add from table */
                if (err == MP_OKAY)
 801d75e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d760:	2b00      	cmp	r3, #0
 801d762:	d115      	bne.n	801d790 <ecc_mul2add+0x464>
                    err = ecc_projective_add_point_safe(C, precomp[i],
 801d764:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d766:	009b      	lsls	r3, r3, #2
 801d768:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d76a:	4413      	add	r3, r2
 801d76c:	6819      	ldr	r1, [r3, #0]
 801d76e:	697b      	ldr	r3, [r7, #20]
 801d770:	f107 0218 	add.w	r2, r7, #24
 801d774:	9202      	str	r2, [sp, #8]
 801d776:	9301      	str	r3, [sp, #4]
 801d778:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801d77c:	9300      	str	r3, [sp, #0]
 801d77e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801d782:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801d786:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d78a:	f7ff fbf4 	bl	801cf76 <ecc_projective_add_point_safe>
 801d78e:	6638      	str	r0, [r7, #96]	@ 0x60
                                                        C, a, modulus, mp,
                                                        &first);
                if (err != MP_OKAY)
 801d790:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d792:	2b00      	cmp	r3, #0
 801d794:	d111      	bne.n	801d7ba <ecc_mul2add+0x48e>
 801d796:	e000      	b.n	801d79a <ecc_mul2add+0x46e>
            continue;
 801d798:	bf00      	nop
    for (x = 0; x < (int)len || nibble != 3; ) {
 801d79a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801d79c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801d79e:	429a      	cmp	r2, r3
 801d7a0:	f6ff af40 	blt.w	801d624 <ecc_mul2add+0x2f8>
 801d7a4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d7a6:	2b03      	cmp	r3, #3
 801d7a8:	f47f af3c 	bne.w	801d624 <ecc_mul2add+0x2f8>
 801d7ac:	e006      	b.n	801d7bc <ecc_mul2add+0x490>
            if (x == (int)len) break;
 801d7ae:	bf00      	nop
 801d7b0:	e004      	b.n	801d7bc <ecc_mul2add+0x490>
                break;
 801d7b2:	bf00      	nop
 801d7b4:	e002      	b.n	801d7bc <ecc_mul2add+0x490>
                    break;
 801d7b6:	bf00      	nop
 801d7b8:	e000      	b.n	801d7bc <ecc_mul2add+0x490>
                    break;
 801d7ba:	bf00      	nop
        }
    }
  }

  /* reduce to affine */
  if (err == MP_OKAY)
 801d7bc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d7be:	2b00      	cmp	r3, #0
 801d7c0:	d108      	bne.n	801d7d4 <ecc_mul2add+0x4a8>
    err = ecc_map(C, modulus, mp);
 801d7c2:	697b      	ldr	r3, [r7, #20]
 801d7c4:	461a      	mov	r2, r3
 801d7c6:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 801d7ca:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801d7ce:	f7fe fbab 	bl	801bf28 <ecc_map>
 801d7d2:	6638      	str	r0, [r7, #96]	@ 0x60

  /* clean up */
  for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d7d4:	2300      	movs	r3, #0
 801d7d6:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d7d8:	e00c      	b.n	801d7f4 <ecc_mul2add+0x4c8>
     wc_ecc_del_point_ex(precomp[x], heap);
 801d7da:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d7dc:	009b      	lsls	r3, r3, #2
 801d7de:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801d7e0:	4413      	add	r3, r2
 801d7e2:	681b      	ldr	r3, [r3, #0]
 801d7e4:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 801d7e8:	4618      	mov	r0, r3
 801d7ea:	f7ff f8cb 	bl	801c984 <wc_ecc_del_point_ex>
  for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 801d7ee:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d7f0:	3301      	adds	r3, #1
 801d7f2:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801d7f4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d7f6:	2b0f      	cmp	r3, #15
 801d7f8:	ddef      	ble.n	801d7da <ecc_mul2add+0x4ae>
  }

  ForceZero(tA, ECC_BUFSIZE);
 801d7fa:	f240 1101 	movw	r1, #257	@ 0x101
 801d7fe:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801d800:	f7fc ffc2 	bl	801a788 <ForceZero>
  ForceZero(tB, ECC_BUFSIZE);
 801d804:	f240 1101 	movw	r1, #257	@ 0x101
 801d808:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801d80a:	f7fc ffbd 	bl	801a788 <ForceZero>
  XFREE(key->t1, heap, DYNAMIC_TYPE_ECC);
  XFREE(key, heap, DYNAMIC_TYPE_ECC_BUFFER);
  C->key = NULL;
#endif
#ifdef WOLFSSL_SMALL_STACK
  XFREE(precomp, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d80e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801d810:	633b      	str	r3, [r7, #48]	@ 0x30
 801d812:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801d814:	2b00      	cmp	r3, #0
 801d816:	d002      	beq.n	801d81e <ecc_mul2add+0x4f2>
 801d818:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801d81a:	f001 f957 	bl	801eacc <wolfSSL_Free>
#endif
#ifndef WOLFSSL_NO_MALLOC
  XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d81e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d820:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801d822:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801d824:	2b00      	cmp	r3, #0
 801d826:	d002      	beq.n	801d82e <ecc_mul2add+0x502>
 801d828:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801d82a:	f001 f94f 	bl	801eacc <wolfSSL_Free>
  XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
 801d82e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801d830:	62bb      	str	r3, [r7, #40]	@ 0x28
 801d832:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d834:	2b00      	cmp	r3, #0
 801d836:	d002      	beq.n	801d83e <ecc_mul2add+0x512>
 801d838:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801d83a:	f001 f947 	bl	801eacc <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
  wc_MemZero_Check(tB, ECC_BUFSIZE);
  wc_MemZero_Check(tA, ECC_BUFSIZE);
#endif
  return err;
 801d83e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
}
 801d840:	4618      	mov	r0, r3
 801d842:	3774      	adds	r7, #116	@ 0x74
 801d844:	46bd      	mov	sp, r7
 801d846:	bd90      	pop	{r4, r7, pc}

0801d848 <wc_ecc_verify_hash>:
             is valid or invalid. Other negative values are returned on error.
 */
WOLFSSL_ABI
int wc_ecc_verify_hash(const byte* sig, word32 siglen, const byte* hash,
                       word32 hashlen, int* res, ecc_key* key)
{
 801d848:	b580      	push	{r7, lr}
 801d84a:	b092      	sub	sp, #72	@ 0x48
 801d84c:	af02      	add	r7, sp, #8
 801d84e:	60f8      	str	r0, [r7, #12]
 801d850:	60b9      	str	r1, [r7, #8]
 801d852:	607a      	str	r2, [r7, #4]
 801d854:	603b      	str	r3, [r7, #0]
    int err;

#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
    mp_int *r = NULL, *s = NULL;
#else
    DECL_MP_INT_SIZE_DYN(r, ECC_KEY_MAX_BITS(key), MAX_ECC_BITS_USE);
 801d856:	2300      	movs	r3, #0
 801d858:	63bb      	str	r3, [r7, #56]	@ 0x38
    DECL_MP_INT_SIZE_DYN(s, ECC_KEY_MAX_BITS(key), MAX_ECC_BITS_USE);
 801d85a:	2300      	movs	r3, #0
 801d85c:	637b      	str	r3, [r7, #52]	@ 0x34
#endif
#ifdef NO_ASN
    word32 keySz;
#endif

    if (sig == NULL || hash == NULL || res == NULL || key == NULL) {
 801d85e:	68fb      	ldr	r3, [r7, #12]
 801d860:	2b00      	cmp	r3, #0
 801d862:	d008      	beq.n	801d876 <wc_ecc_verify_hash+0x2e>
 801d864:	687b      	ldr	r3, [r7, #4]
 801d866:	2b00      	cmp	r3, #0
 801d868:	d005      	beq.n	801d876 <wc_ecc_verify_hash+0x2e>
 801d86a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d86c:	2b00      	cmp	r3, #0
 801d86e:	d002      	beq.n	801d876 <wc_ecc_verify_hash+0x2e>
 801d870:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d872:	2b00      	cmp	r3, #0
 801d874:	d102      	bne.n	801d87c <wc_ecc_verify_hash+0x34>
        return ECC_BAD_ARG_E;
 801d876:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801d87a:	e0d7      	b.n	801da2c <wc_ecc_verify_hash+0x1e4>
    if (err != 0)
        return err;
    r = key->r;
    s = key->s;
#else
    NEW_MP_INT_SIZE(r, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap,
 801d87c:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801d880:	f001 f908 	bl	801ea94 <wolfSSL_Malloc>
 801d884:	63b8      	str	r0, [r7, #56]	@ 0x38
 801d886:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d888:	2b00      	cmp	r3, #0
 801d88a:	d005      	beq.n	801d898 <wc_ecc_verify_hash+0x50>
 801d88c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801d890:	2100      	movs	r1, #0
 801d892:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801d894:	f00a fe1c 	bl	80284d0 <memset>
        DYNAMIC_TYPE_ECC);
    #ifdef MP_INT_SIZE_CHECK_NULL
    if (r == NULL)
 801d898:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d89a:	2b00      	cmp	r3, #0
 801d89c:	d102      	bne.n	801d8a4 <wc_ecc_verify_hash+0x5c>
        return MEMORY_E;
 801d89e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801d8a2:	e0c3      	b.n	801da2c <wc_ecc_verify_hash+0x1e4>
    #endif
    NEW_MP_INT_SIZE(s, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap,
 801d8a4:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801d8a8:	f001 f8f4 	bl	801ea94 <wolfSSL_Malloc>
 801d8ac:	6378      	str	r0, [r7, #52]	@ 0x34
 801d8ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d8b0:	2b00      	cmp	r3, #0
 801d8b2:	d005      	beq.n	801d8c0 <wc_ecc_verify_hash+0x78>
 801d8b4:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801d8b8:	2100      	movs	r1, #0
 801d8ba:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801d8bc:	f00a fe08 	bl	80284d0 <memset>
        DYNAMIC_TYPE_ECC);
    #ifdef MP_INT_SIZE_CHECK_NULL
    if (s == NULL) {
 801d8c0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d8c2:	2b00      	cmp	r3, #0
 801d8c4:	d10a      	bne.n	801d8dc <wc_ecc_verify_hash+0x94>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801d8c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d8c8:	613b      	str	r3, [r7, #16]
 801d8ca:	693b      	ldr	r3, [r7, #16]
 801d8cc:	2b00      	cmp	r3, #0
 801d8ce:	d002      	beq.n	801d8d6 <wc_ecc_verify_hash+0x8e>
 801d8d0:	6938      	ldr	r0, [r7, #16]
 801d8d2:	f001 f8fb 	bl	801eacc <wolfSSL_Free>
        return MEMORY_E;
 801d8d6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801d8da:	e0a7      	b.n	801da2c <wc_ecc_verify_hash+0x1e4>
    }
    #endif
    err = INIT_MP_INT_SIZE(r, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801d8dc:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801d8de:	f008 fede 	bl	802669e <mp_init>
 801d8e2:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if (err != 0) {
 801d8e4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d8e6:	2b00      	cmp	r3, #0
 801d8e8:	d011      	beq.n	801d90e <wc_ecc_verify_hash+0xc6>
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801d8ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d8ec:	61bb      	str	r3, [r7, #24]
 801d8ee:	69bb      	ldr	r3, [r7, #24]
 801d8f0:	2b00      	cmp	r3, #0
 801d8f2:	d002      	beq.n	801d8fa <wc_ecc_verify_hash+0xb2>
 801d8f4:	69b8      	ldr	r0, [r7, #24]
 801d8f6:	f001 f8e9 	bl	801eacc <wolfSSL_Free>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801d8fa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d8fc:	617b      	str	r3, [r7, #20]
 801d8fe:	697b      	ldr	r3, [r7, #20]
 801d900:	2b00      	cmp	r3, #0
 801d902:	d002      	beq.n	801d90a <wc_ecc_verify_hash+0xc2>
 801d904:	6978      	ldr	r0, [r7, #20]
 801d906:	f001 f8e1 	bl	801eacc <wolfSSL_Free>
        return err;
 801d90a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d90c:	e08e      	b.n	801da2c <wc_ecc_verify_hash+0x1e4>
    }
    err = INIT_MP_INT_SIZE(s, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801d90e:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801d910:	f008 fec5 	bl	802669e <mp_init>
 801d914:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if (err != 0) {
 801d916:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d918:	2b00      	cmp	r3, #0
 801d91a:	d011      	beq.n	801d940 <wc_ecc_verify_hash+0xf8>
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801d91c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d91e:	623b      	str	r3, [r7, #32]
 801d920:	6a3b      	ldr	r3, [r7, #32]
 801d922:	2b00      	cmp	r3, #0
 801d924:	d002      	beq.n	801d92c <wc_ecc_verify_hash+0xe4>
 801d926:	6a38      	ldr	r0, [r7, #32]
 801d928:	f001 f8d0 	bl	801eacc <wolfSSL_Free>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801d92c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d92e:	61fb      	str	r3, [r7, #28]
 801d930:	69fb      	ldr	r3, [r7, #28]
 801d932:	2b00      	cmp	r3, #0
 801d934:	d002      	beq.n	801d93c <wc_ecc_verify_hash+0xf4>
 801d936:	69f8      	ldr	r0, [r7, #28]
 801d938:	f001 f8c8 	bl	801eacc <wolfSSL_Free>
        return err;
 801d93c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d93e:	e075      	b.n	801da2c <wc_ecc_verify_hash+0x1e4>
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    switch (key->state) {
 801d940:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d942:	689b      	ldr	r3, [r3, #8]
 801d944:	2b07      	cmp	r3, #7
 801d946:	d856      	bhi.n	801d9f6 <wc_ecc_verify_hash+0x1ae>
 801d948:	a201      	add	r2, pc, #4	@ (adr r2, 801d950 <wc_ecc_verify_hash+0x108>)
 801d94a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d94e:	bf00      	nop
 801d950:	0801d971 	.word	0x0801d971
 801d954:	0801d9f7 	.word	0x0801d9f7
 801d958:	0801d9f7 	.word	0x0801d9f7
 801d95c:	0801d9f7 	.word	0x0801d9f7
 801d960:	0801d9f7 	.word	0x0801d9f7
 801d964:	0801d971 	.word	0x0801d971
 801d968:	0801d995 	.word	0x0801d995
 801d96c:	0801d9eb 	.word	0x0801d9eb
        case ECC_STATE_NONE:
        case ECC_STATE_VERIFY_DECODE:
            key->state = ECC_STATE_VERIFY_DECODE;
 801d970:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d972:	2205      	movs	r2, #5
 801d974:	609a      	str	r2, [r3, #8]

            /* default to invalid signature */
            *res = 0;
 801d976:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d978:	2200      	movs	r2, #0
 801d97a:	601a      	str	r2, [r3, #0]
             * the rest of this function will execute, and everything
             * gets cleaned up at the end. */
            err = DecodeECC_DSA_Sig(sig, siglen, r, s);
        #else
            /* r and s are initialized. */
            err = DecodeECC_DSA_Sig_Ex(sig, siglen, r, s, 0);
 801d97c:	2300      	movs	r3, #0
 801d97e:	9300      	str	r3, [sp, #0]
 801d980:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d982:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801d984:	68b9      	ldr	r1, [r7, #8]
 801d986:	68f8      	ldr	r0, [r7, #12]
 801d988:	f7fc f9d0 	bl	8019d2c <DecodeECC_DSA_Sig_Ex>
 801d98c:	63f8      	str	r0, [r7, #60]	@ 0x3c
        #endif
            if (err < 0) {
 801d98e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d990:	2b00      	cmp	r3, #0
 801d992:	db34      	blt.n	801d9fe <wc_ecc_verify_hash+0x1b6>
            mp_read_unsigned_bin(s, sig + keySz, keySz);
    #endif /* !NO_ASN */
            FALL_THROUGH;

        case ECC_STATE_VERIFY_DO:
            key->state = ECC_STATE_VERIFY_DO;
 801d994:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d996:	2206      	movs	r2, #6
 801d998:	609a      	str	r2, [r3, #8]
        #ifdef WOLFSSL_ASYNC_CRYPT
            if (key->type == ECC_PRIVATEKEY_ONLY) {
                isPrivateKeyOnly = 1;
            }
        #endif
            err = wc_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
 801d99a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d99c:	9301      	str	r3, [sp, #4]
 801d99e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d9a0:	9300      	str	r3, [sp, #0]
 801d9a2:	683b      	ldr	r3, [r7, #0]
 801d9a4:	687a      	ldr	r2, [r7, #4]
 801d9a6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801d9a8:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801d9aa:	f000 fa34 	bl	801de16 <wc_ecc_verify_hash_ex>
 801d9ae:	63f8      	str	r0, [r7, #60]	@ 0x3c

        #ifndef WOLFSSL_ASYNC_CRYPT
            /* done with R/S */
            mp_clear(r);
 801d9b0:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801d9b2:	f008 fefe 	bl	80267b2 <mp_clear>
            mp_clear(s);
 801d9b6:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801d9b8:	f008 fefb 	bl	80267b2 <mp_clear>
            FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801d9bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801d9be:	633b      	str	r3, [r7, #48]	@ 0x30
 801d9c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801d9c2:	2b00      	cmp	r3, #0
 801d9c4:	d002      	beq.n	801d9cc <wc_ecc_verify_hash+0x184>
 801d9c6:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801d9c8:	f001 f880 	bl	801eacc <wolfSSL_Free>
            FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801d9cc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801d9ce:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801d9d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801d9d2:	2b00      	cmp	r3, #0
 801d9d4:	d002      	beq.n	801d9dc <wc_ecc_verify_hash+0x194>
 801d9d6:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801d9d8:	f001 f878 	bl	801eacc <wolfSSL_Free>
        #ifdef MP_INT_SIZE_CHECK_NULL
            r = NULL;
 801d9dc:	2300      	movs	r3, #0
 801d9de:	63bb      	str	r3, [r7, #56]	@ 0x38
            s = NULL;
 801d9e0:	2300      	movs	r3, #0
 801d9e2:	637b      	str	r3, [r7, #52]	@ 0x34
        #endif
        #endif

            if (err < 0) {
 801d9e4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801d9e6:	2b00      	cmp	r3, #0
 801d9e8:	db0b      	blt.n	801da02 <wc_ecc_verify_hash+0x1ba>
                break;
            }
            FALL_THROUGH;

        case ECC_STATE_VERIFY_RES:
            key->state = ECC_STATE_VERIFY_RES;
 801d9ea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801d9ec:	2207      	movs	r2, #7
 801d9ee:	609a      	str	r2, [r3, #8]
            err = 0;
 801d9f0:	2300      	movs	r3, #0
 801d9f2:	63fb      	str	r3, [r7, #60]	@ 0x3c
            break;
 801d9f4:	e006      	b.n	801da04 <wc_ecc_verify_hash+0x1bc>

        default:
            err = BAD_STATE_E;
 801d9f6:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 801d9fa:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801d9fc:	e002      	b.n	801da04 <wc_ecc_verify_hash+0x1bc>
                break;
 801d9fe:	bf00      	nop
 801da00:	e000      	b.n	801da04 <wc_ecc_verify_hash+0x1bc>
                break;
 801da02:	bf00      	nop

    /* cleanup */
#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
    wc_ecc_free_async(key);
#else
    FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
 801da04:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801da06:	62bb      	str	r3, [r7, #40]	@ 0x28
 801da08:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801da0a:	2b00      	cmp	r3, #0
 801da0c:	d002      	beq.n	801da14 <wc_ecc_verify_hash+0x1cc>
 801da0e:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801da10:	f001 f85c 	bl	801eacc <wolfSSL_Free>
    FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 801da14:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801da16:	627b      	str	r3, [r7, #36]	@ 0x24
 801da18:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801da1a:	2b00      	cmp	r3, #0
 801da1c:	d002      	beq.n	801da24 <wc_ecc_verify_hash+0x1dc>
 801da1e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801da20:	f001 f854 	bl	801eacc <wolfSSL_Free>
#endif

    /* make sure required variables are reset */
    wc_ecc_reset(key);
 801da24:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801da26:	f7ff f8f6 	bl	801cc16 <wc_ecc_reset>
    return err;
 801da2a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
#endif /* !WOLF_CRYPTO_CB_ONLY_ECC */
}
 801da2c:	4618      	mov	r0, r3
 801da2e:	3740      	adds	r7, #64	@ 0x40
 801da30:	46bd      	mov	sp, r7
 801da32:	bd80      	pop	{r7, pc}

0801da34 <wc_ecc_check_r_s_range>:
#ifndef WOLF_CRYPTO_CB_ONLY_ECC

#if !defined(WOLFSSL_STM32_PKA) && !defined(WOLFSSL_PSOC6_CRYPTO) && \
    !defined(WOLF_CRYPTO_CB_ONLY_ECC)
static int wc_ecc_check_r_s_range(ecc_key* key, mp_int* r, mp_int* s)
{
 801da34:	b580      	push	{r7, lr}
 801da36:	b094      	sub	sp, #80	@ 0x50
 801da38:	af00      	add	r7, sp, #0
 801da3a:	60f8      	str	r0, [r7, #12]
 801da3c:	60b9      	str	r1, [r7, #8]
 801da3e:	607a      	str	r2, [r7, #4]
    int err = MP_OKAY;
 801da40:	2300      	movs	r3, #0
 801da42:	64fb      	str	r3, [r7, #76]	@ 0x4c
    DECLARE_CURVE_SPECS(1);
 801da44:	2300      	movs	r3, #0
 801da46:	64bb      	str	r3, [r7, #72]	@ 0x48
 801da48:	f107 0314 	add.w	r3, r7, #20
 801da4c:	613b      	str	r3, [r7, #16]
 801da4e:	693b      	ldr	r3, [r7, #16]
 801da50:	222c      	movs	r2, #44	@ 0x2c
 801da52:	2100      	movs	r1, #0
 801da54:	4618      	mov	r0, r3
 801da56:	f00a fd3b 	bl	80284d0 <memset>
 801da5a:	693b      	ldr	r3, [r7, #16]
 801da5c:	2201      	movs	r2, #1
 801da5e:	621a      	str	r2, [r3, #32]

    ALLOC_CURVE_SPECS(1, err);
 801da60:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801da64:	f001 f816 	bl	801ea94 <wolfSSL_Malloc>
 801da68:	64b8      	str	r0, [r7, #72]	@ 0x48
 801da6a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801da6c:	2b00      	cmp	r3, #0
 801da6e:	d103      	bne.n	801da78 <wc_ecc_check_r_s_range+0x44>
 801da70:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801da74:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801da76:	e002      	b.n	801da7e <wc_ecc_check_r_s_range+0x4a>
 801da78:	693b      	ldr	r3, [r7, #16]
 801da7a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801da7c:	61da      	str	r2, [r3, #28]
    if (err == MP_OKAY) {
 801da7e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801da80:	2b00      	cmp	r3, #0
 801da82:	d108      	bne.n	801da96 <wc_ecc_check_r_s_range+0x62>
        err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
 801da84:	68fb      	ldr	r3, [r7, #12]
 801da86:	691b      	ldr	r3, [r3, #16]
 801da88:	f107 0110 	add.w	r1, r7, #16
 801da8c:	2208      	movs	r2, #8
 801da8e:	4618      	mov	r0, r3
 801da90:	f7fc ff61 	bl	801a956 <wc_ecc_curve_load>
 801da94:	64f8      	str	r0, [r7, #76]	@ 0x4c
    }
    if (err != 0) {
 801da96:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801da98:	2b00      	cmp	r3, #0
 801da9a:	d009      	beq.n	801dab0 <wc_ecc_check_r_s_range+0x7c>
        FREE_CURVE_SPECS();
 801da9c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801da9e:	643b      	str	r3, [r7, #64]	@ 0x40
 801daa0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801daa2:	2b00      	cmp	r3, #0
 801daa4:	d002      	beq.n	801daac <wc_ecc_check_r_s_range+0x78>
 801daa6:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801daa8:	f001 f810 	bl	801eacc <wolfSSL_Free>
        return err;
 801daac:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801daae:	e03b      	b.n	801db28 <wc_ecc_check_r_s_range+0xf4>
    }

    if (mp_iszero(r) || mp_iszero(s)) {
 801dab0:	68b8      	ldr	r0, [r7, #8]
 801dab2:	f009 f84e 	bl	8026b52 <mp_iszero>
 801dab6:	4603      	mov	r3, r0
 801dab8:	2b00      	cmp	r3, #0
 801daba:	d105      	bne.n	801dac8 <wc_ecc_check_r_s_range+0x94>
 801dabc:	6878      	ldr	r0, [r7, #4]
 801dabe:	f009 f848 	bl	8026b52 <mp_iszero>
 801dac2:	4603      	mov	r3, r0
 801dac4:	2b00      	cmp	r3, #0
 801dac6:	d002      	beq.n	801dace <wc_ecc_check_r_s_range+0x9a>
        err = MP_ZERO_E;
 801dac8:	f06f 0378 	mvn.w	r3, #120	@ 0x78
 801dacc:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
    if ((err == 0) && (mp_cmp(r, curve->order) != MP_LT)) {
 801dace:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dad0:	2b00      	cmp	r3, #0
 801dad2:	d10c      	bne.n	801daee <wc_ecc_check_r_s_range+0xba>
 801dad4:	693b      	ldr	r3, [r7, #16]
 801dad6:	691b      	ldr	r3, [r3, #16]
 801dad8:	4619      	mov	r1, r3
 801dada:	68b8      	ldr	r0, [r7, #8]
 801dadc:	f008 ff72 	bl	80269c4 <mp_cmp>
 801dae0:	4603      	mov	r3, r0
 801dae2:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801dae6:	d002      	beq.n	801daee <wc_ecc_check_r_s_range+0xba>
        err = MP_VAL;
 801dae8:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 801daec:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
    if ((err == 0) && (mp_cmp(s, curve->order) != MP_LT)) {
 801daee:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801daf0:	2b00      	cmp	r3, #0
 801daf2:	d10c      	bne.n	801db0e <wc_ecc_check_r_s_range+0xda>
 801daf4:	693b      	ldr	r3, [r7, #16]
 801daf6:	691b      	ldr	r3, [r3, #16]
 801daf8:	4619      	mov	r1, r3
 801dafa:	6878      	ldr	r0, [r7, #4]
 801dafc:	f008 ff62 	bl	80269c4 <mp_cmp>
 801db00:	4603      	mov	r3, r0
 801db02:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801db06:	d002      	beq.n	801db0e <wc_ecc_check_r_s_range+0xda>
        err = MP_VAL;
 801db08:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 801db0c:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }

    wc_ecc_curve_free(curve);
 801db0e:	693b      	ldr	r3, [r7, #16]
 801db10:	4618      	mov	r0, r3
 801db12:	f7fc fed5 	bl	801a8c0 <wc_ecc_curve_free>
    FREE_CURVE_SPECS();
 801db16:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801db18:	647b      	str	r3, [r7, #68]	@ 0x44
 801db1a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db1c:	2b00      	cmp	r3, #0
 801db1e:	d002      	beq.n	801db26 <wc_ecc_check_r_s_range+0xf2>
 801db20:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801db22:	f000 ffd3 	bl	801eacc <wolfSSL_Free>
    return err;
 801db26:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 801db28:	4618      	mov	r0, r3
 801db2a:	3750      	adds	r7, #80	@ 0x50
 801db2c:	46bd      	mov	sp, r7
 801db2e:	bd80      	pop	{r7, pc}

0801db30 <ecc_verify_hash_sp>:
#endif /* !WOLFSSL_STM32_PKA && !WOLFSSL_PSOC6_CRYPTO */

#ifdef HAVE_ECC_VERIFY_HELPER
static int ecc_verify_hash_sp(mp_int *r, mp_int *s, const byte* hash,
    word32 hashlen, int* res, ecc_key* key)
{
 801db30:	b480      	push	{r7}
 801db32:	b085      	sub	sp, #20
 801db34:	af00      	add	r7, sp, #0
 801db36:	60f8      	str	r0, [r7, #12]
 801db38:	60b9      	str	r1, [r7, #8]
 801db3a:	607a      	str	r2, [r7, #4]
 801db3c:	603b      	str	r3, [r7, #0]
        }
    #endif
    }
#endif

    return NOT_COMPILED_IN;
 801db3e:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
}
 801db42:	4618      	mov	r0, r3
 801db44:	3714      	adds	r7, #20
 801db46:	46bd      	mov	sp, r7
 801db48:	f85d 7b04 	ldr.w	r7, [sp], #4
 801db4c:	4770      	bx	lr

0801db4e <ecc_verify_hash>:

#if !defined(WOLFSSL_SP_MATH) || defined(FREESCALE_LTC_ECC)
static int ecc_verify_hash(mp_int *r, mp_int *s, const byte* hash,
    word32 hashlen, int* res, ecc_key* key, ecc_curve_spec* curve)
{
 801db4e:	b5b0      	push	{r4, r5, r7, lr}
 801db50:	b096      	sub	sp, #88	@ 0x58
 801db52:	af04      	add	r7, sp, #16
 801db54:	60f8      	str	r0, [r7, #12]
 801db56:	60b9      	str	r1, [r7, #8]
 801db58:	607a      	str	r2, [r7, #4]
 801db5a:	603b      	str	r3, [r7, #0]
   int        err;
   ecc_point* mG = NULL;
 801db5c:	2300      	movs	r3, #0
 801db5e:	61bb      	str	r3, [r7, #24]
   ecc_point* mQ = NULL;
 801db60:	2300      	movs	r3, #0
 801db62:	617b      	str	r3, [r7, #20]
#ifdef WOLFSSL_NO_MALLOC
   ecc_point  lcl_mG;
   ecc_point  lcl_mQ;
#endif
   DECL_MP_INT_SIZE_DYN(w, ECC_KEY_MAX_BITS_NONULLCHECK(key), MAX_ECC_BITS_USE);
 801db64:	2300      	movs	r3, #0
 801db66:	637b      	str	r3, [r7, #52]	@ 0x34
#if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
   DECL_MP_INT_SIZE_DYN(e_lcl, ECC_KEY_MAX_BITS_NONULLCHECK(key), MAX_ECC_BITS_USE);
 801db68:	2300      	movs	r3, #0
 801db6a:	633b      	str	r3, [r7, #48]	@ 0x30
#endif
   mp_int*    e;
   mp_int*    v = NULL;      /* Will be w. */
 801db6c:	2300      	movs	r3, #0
 801db6e:	643b      	str	r3, [r7, #64]	@ 0x40
#if defined(WOLFSSL_CHECK_VER_FAULTS) && defined(WOLFSSL_NO_MALLOC)
   mp_int     u1tmp[1];
   mp_int     u2tmp[1];
#endif
   mp_int*    u1 = NULL;     /* Will be e. */
 801db70:	2300      	movs	r3, #0
 801db72:	63fb      	str	r3, [r7, #60]	@ 0x3c
   mp_int*    u2 = NULL;     /* Will be w. */
 801db74:	2300      	movs	r3, #0
 801db76:	63bb      	str	r3, [r7, #56]	@ 0x38
   }
   e = key->e;

   err = mp_init(e);
#else
   NEW_MP_INT_SIZE(e_lcl, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap, DYNAMIC_TYPE_ECC);
 801db78:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801db7c:	f000 ff8a 	bl	801ea94 <wolfSSL_Malloc>
 801db80:	6338      	str	r0, [r7, #48]	@ 0x30
 801db82:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801db84:	2b00      	cmp	r3, #0
 801db86:	d005      	beq.n	801db94 <ecc_verify_hash+0x46>
 801db88:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801db8c:	2100      	movs	r1, #0
 801db8e:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801db90:	f00a fc9e 	bl	80284d0 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
   if (e_lcl == NULL) {
 801db94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801db96:	2b00      	cmp	r3, #0
 801db98:	d102      	bne.n	801dba0 <ecc_verify_hash+0x52>
       return MEMORY_E;
 801db9a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801db9e:	e136      	b.n	801de0e <ecc_verify_hash+0x2c0>
   }
#endif
   e = e_lcl;
 801dba0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801dba2:	62fb      	str	r3, [r7, #44]	@ 0x2c

   err = INIT_MP_INT_SIZE(e, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801dba4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dba6:	f008 fd7a 	bl	802669e <mp_init>
 801dbaa:	6478      	str	r0, [r7, #68]	@ 0x44
#endif /* WOLFSSL_ASYNC_CRYPT && HAVE_CAVIUM_V */
   if (err != MP_OKAY) {
 801dbac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dbae:	2b00      	cmp	r3, #0
 801dbb0:	d00a      	beq.n	801dbc8 <ecc_verify_hash+0x7a>
#ifdef WOLFSSL_SMALL_STACK
   #if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
      XFREE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
 801dbb2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801dbb4:	61fb      	str	r3, [r7, #28]
 801dbb6:	69fb      	ldr	r3, [r7, #28]
 801dbb8:	2b00      	cmp	r3, #0
 801dbba:	d002      	beq.n	801dbc2 <ecc_verify_hash+0x74>
 801dbbc:	69f8      	ldr	r0, [r7, #28]
 801dbbe:	f000 ff85 	bl	801eacc <wolfSSL_Free>
   #endif
#endif
      return MEMORY_E;
 801dbc2:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801dbc6:	e122      	b.n	801de0e <ecc_verify_hash+0x2c0>
   }

   /* read hash */
   if (err == MP_OKAY) {
 801dbc8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dbca:	2b00      	cmp	r3, #0
 801dbcc:	d127      	bne.n	801dc1e <ecc_verify_hash+0xd0>
       /* we may need to truncate if hash is longer than key size */
       unsigned int orderBits = (unsigned int)mp_count_bits(curve->order);
 801dbce:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dbd0:	691b      	ldr	r3, [r3, #16]
 801dbd2:	4618      	mov	r0, r3
 801dbd4:	f008 ffce 	bl	8026b74 <mp_count_bits>
 801dbd8:	4603      	mov	r3, r0
 801dbda:	62bb      	str	r3, [r7, #40]	@ 0x28

       /* truncate down to byte size, may be all that's needed */
       if ( (WOLFSSL_BIT_SIZE * hashlen) > orderBits)
 801dbdc:	683b      	ldr	r3, [r7, #0]
 801dbde:	00db      	lsls	r3, r3, #3
 801dbe0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801dbe2:	429a      	cmp	r2, r3
 801dbe4:	d203      	bcs.n	801dbee <ecc_verify_hash+0xa0>
           hashlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;
 801dbe6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801dbe8:	3307      	adds	r3, #7
 801dbea:	08db      	lsrs	r3, r3, #3
 801dbec:	603b      	str	r3, [r7, #0]
       err = mp_read_unsigned_bin(e, hash, hashlen);
 801dbee:	683b      	ldr	r3, [r7, #0]
 801dbf0:	461a      	mov	r2, r3
 801dbf2:	6879      	ldr	r1, [r7, #4]
 801dbf4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dbf6:	f008 ff2b 	bl	8026a50 <mp_read_unsigned_bin>
 801dbfa:	6478      	str	r0, [r7, #68]	@ 0x44

       /* may still need bit truncation too */
       if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * hashlen) > orderBits)
 801dbfc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dbfe:	2b00      	cmp	r3, #0
 801dc00:	d10d      	bne.n	801dc1e <ecc_verify_hash+0xd0>
 801dc02:	683b      	ldr	r3, [r7, #0]
 801dc04:	00db      	lsls	r3, r3, #3
 801dc06:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801dc08:	429a      	cmp	r2, r3
 801dc0a:	d208      	bcs.n	801dc1e <ecc_verify_hash+0xd0>
           mp_rshb(e, (int)(WOLFSSL_BIT_SIZE - (orderBits & 0x7)));
 801dc0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801dc0e:	f003 0307 	and.w	r3, r3, #7
 801dc12:	f1c3 0308 	rsb	r3, r3, #8
 801dc16:	4619      	mov	r1, r3
 801dc18:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dc1a:	f008 ffc3 	bl	8026ba4 <mp_rshb>
      }
   #endif /* HAVE_CAVIUM_V || HAVE_INTEL_QA */
   }
#endif /* WOLFSSL_ASYNC_CRYPT && WC_ASYNC_ENABLE_ECC */

   NEW_MP_INT_SIZE(w, ECC_KEY_MAX_BITS_NONULLCHECK(key), key->heap, DYNAMIC_TYPE_ECC);
 801dc1e:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 801dc22:	f000 ff37 	bl	801ea94 <wolfSSL_Malloc>
 801dc26:	6378      	str	r0, [r7, #52]	@ 0x34
 801dc28:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dc2a:	2b00      	cmp	r3, #0
 801dc2c:	d005      	beq.n	801dc3a <ecc_verify_hash+0xec>
 801dc2e:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 801dc32:	2100      	movs	r1, #0
 801dc34:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dc36:	f00a fc4b 	bl	80284d0 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
   if (w == NULL) {
 801dc3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dc3c:	2b00      	cmp	r3, #0
 801dc3e:	d102      	bne.n	801dc46 <ecc_verify_hash+0xf8>
       err = MEMORY_E;
 801dc40:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801dc44:	647b      	str	r3, [r7, #68]	@ 0x44
   }
#endif

   if (err == MP_OKAY) {
 801dc46:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc48:	2b00      	cmp	r3, #0
 801dc4a:	d105      	bne.n	801dc58 <ecc_verify_hash+0x10a>
    #else
        u1 = u1tmp;
        u2 = u2tmp;
    #endif
#else
       u1 = e;
 801dc4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801dc4e:	63fb      	str	r3, [r7, #60]	@ 0x3c
       u2 = w;
 801dc50:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dc52:	63bb      	str	r3, [r7, #56]	@ 0x38
#endif
       v = w;
 801dc54:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dc56:	643b      	str	r3, [r7, #64]	@ 0x40
   }
   if (err == MP_OKAY) {
 801dc58:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc5a:	2b00      	cmp	r3, #0
 801dc5c:	d103      	bne.n	801dc66 <ecc_verify_hash+0x118>
       err = INIT_MP_INT_SIZE(w, ECC_KEY_MAX_BITS_NONULLCHECK(key));
 801dc5e:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dc60:	f008 fd1d 	bl	802669e <mp_init>
 801dc64:	6478      	str	r0, [r7, #68]	@ 0x44
       err = INIT_MP_INT_SIZE(u2, ECC_KEY_MAX_BITS_NONULLCHECK(key));
   }
#endif

   /* allocate points */
   if (err == MP_OKAY) {
 801dc66:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc68:	2b00      	cmp	r3, #0
 801dc6a:	d108      	bne.n	801dc7e <ecc_verify_hash+0x130>
   #ifdef WOLFSSL_NO_MALLOC
       mG = &lcl_mG;
   #endif
       err = wc_ecc_new_point_ex(&mG, key->heap);
 801dc6c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dc6e:	695a      	ldr	r2, [r3, #20]
 801dc70:	f107 0318 	add.w	r3, r7, #24
 801dc74:	4611      	mov	r1, r2
 801dc76:	4618      	mov	r0, r3
 801dc78:	f7fe fe2f 	bl	801c8da <wc_ecc_new_point_ex>
 801dc7c:	6478      	str	r0, [r7, #68]	@ 0x44
   }
   if (err == MP_OKAY) {
 801dc7e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc80:	2b00      	cmp	r3, #0
 801dc82:	d108      	bne.n	801dc96 <ecc_verify_hash+0x148>
   #ifdef WOLFSSL_NO_MALLOC
       mQ = &lcl_mQ;
   #endif
       err = wc_ecc_new_point_ex(&mQ, key->heap);
 801dc84:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dc86:	695a      	ldr	r2, [r3, #20]
 801dc88:	f107 0314 	add.w	r3, r7, #20
 801dc8c:	4611      	mov	r1, r2
 801dc8e:	4618      	mov	r0, r3
 801dc90:	f7fe fe23 	bl	801c8da <wc_ecc_new_point_ex>
 801dc94:	6478      	str	r0, [r7, #68]	@ 0x44
   }

   /*  w  = s^-1 mod n */
   if (err == MP_OKAY)
 801dc96:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc98:	2b00      	cmp	r3, #0
 801dc9a:	d107      	bne.n	801dcac <ecc_verify_hash+0x15e>
       err = mp_invmod(s, curve->order, w);
 801dc9c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dc9e:	691b      	ldr	r3, [r3, #16]
 801dca0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801dca2:	4619      	mov	r1, r3
 801dca4:	68b8      	ldr	r0, [r7, #8]
 801dca6:	f008 fe47 	bl	8026938 <mp_invmod>
 801dcaa:	6478      	str	r0, [r7, #68]	@ 0x44

   /* u1 = ew */
   if (err == MP_OKAY)
 801dcac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dcae:	2b00      	cmp	r3, #0
 801dcb0:	d107      	bne.n	801dcc2 <ecc_verify_hash+0x174>
       err = mp_mulmod(e, w, curve->order, u1);
 801dcb2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dcb4:	691a      	ldr	r2, [r3, #16]
 801dcb6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801dcb8:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801dcba:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dcbc:	f008 fdf3 	bl	80268a6 <mp_mulmod>
 801dcc0:	6478      	str	r0, [r7, #68]	@ 0x44
        err = BAD_STATE_E;
    }
#endif

   /* u2 = rw */
   if (err == MP_OKAY)
 801dcc2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dcc4:	2b00      	cmp	r3, #0
 801dcc6:	d107      	bne.n	801dcd8 <ecc_verify_hash+0x18a>
       err = mp_mulmod(r, w, curve->order, u2);
 801dcc8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dcca:	691a      	ldr	r2, [r3, #16]
 801dccc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801dcce:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801dcd0:	68f8      	ldr	r0, [r7, #12]
 801dcd2:	f008 fde8 	bl	80268a6 <mp_mulmod>
 801dcd6:	6478      	str	r0, [r7, #68]	@ 0x44
        err = BAD_STATE_E;
    }
#endif

   /* find mG and mQ */
   if (err == MP_OKAY)
 801dcd8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dcda:	2b00      	cmp	r3, #0
 801dcdc:	d108      	bne.n	801dcf0 <ecc_verify_hash+0x1a2>
       err = mp_copy(curve->Gx, mG->x);
 801dcde:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dce0:	695a      	ldr	r2, [r3, #20]
 801dce2:	69bb      	ldr	r3, [r7, #24]
 801dce4:	681b      	ldr	r3, [r3, #0]
 801dce6:	4619      	mov	r1, r3
 801dce8:	4610      	mov	r0, r2
 801dcea:	f008 ff24 	bl	8026b36 <mp_copy>
 801dcee:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801dcf0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dcf2:	2b00      	cmp	r3, #0
 801dcf4:	d108      	bne.n	801dd08 <ecc_verify_hash+0x1ba>
       err = mp_copy(curve->Gy, mG->y);
 801dcf6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dcf8:	699a      	ldr	r2, [r3, #24]
 801dcfa:	69bb      	ldr	r3, [r7, #24]
 801dcfc:	685b      	ldr	r3, [r3, #4]
 801dcfe:	4619      	mov	r1, r3
 801dd00:	4610      	mov	r0, r2
 801dd02:	f008 ff18 	bl	8026b36 <mp_copy>
 801dd06:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801dd08:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd0a:	2b00      	cmp	r3, #0
 801dd0c:	d106      	bne.n	801dd1c <ecc_verify_hash+0x1ce>
       err = mp_set(mG->z, 1);
 801dd0e:	69bb      	ldr	r3, [r7, #24]
 801dd10:	689b      	ldr	r3, [r3, #8]
 801dd12:	2101      	movs	r1, #1
 801dd14:	4618      	mov	r0, r3
 801dd16:	f009 f9cb 	bl	80270b0 <mp_set>
 801dd1a:	6478      	str	r0, [r7, #68]	@ 0x44

   if (err == MP_OKAY)
 801dd1c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd1e:	2b00      	cmp	r3, #0
 801dd20:	d108      	bne.n	801dd34 <ecc_verify_hash+0x1e6>
       err = mp_copy(key->pubkey.x, mQ->x);
 801dd22:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dd24:	699a      	ldr	r2, [r3, #24]
 801dd26:	697b      	ldr	r3, [r7, #20]
 801dd28:	681b      	ldr	r3, [r3, #0]
 801dd2a:	4619      	mov	r1, r3
 801dd2c:	4610      	mov	r0, r2
 801dd2e:	f008 ff02 	bl	8026b36 <mp_copy>
 801dd32:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801dd34:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd36:	2b00      	cmp	r3, #0
 801dd38:	d108      	bne.n	801dd4c <ecc_verify_hash+0x1fe>
       err = mp_copy(key->pubkey.y, mQ->y);
 801dd3a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dd3c:	69da      	ldr	r2, [r3, #28]
 801dd3e:	697b      	ldr	r3, [r7, #20]
 801dd40:	685b      	ldr	r3, [r3, #4]
 801dd42:	4619      	mov	r1, r3
 801dd44:	4610      	mov	r0, r2
 801dd46:	f008 fef6 	bl	8026b36 <mp_copy>
 801dd4a:	6478      	str	r0, [r7, #68]	@ 0x44
   if (err == MP_OKAY)
 801dd4c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd4e:	2b00      	cmp	r3, #0
 801dd50:	d108      	bne.n	801dd64 <ecc_verify_hash+0x216>
       err = mp_copy(key->pubkey.z, mQ->z);
 801dd52:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dd54:	6a1a      	ldr	r2, [r3, #32]
 801dd56:	697b      	ldr	r3, [r7, #20]
 801dd58:	689b      	ldr	r3, [r3, #8]
 801dd5a:	4619      	mov	r1, r3
 801dd5c:	4610      	mov	r0, r2
 801dd5e:	f008 feea 	bl	8026b36 <mp_copy>
 801dd62:	6478      	str	r0, [r7, #68]	@ 0x44
        if (err == MP_OKAY)
            err = ecc_map(mG, curve->prime, mp);
    }
#else
    /* use Shamir's trick to compute u1*mG + u2*mQ using half the doubles */
    if (err == MP_OKAY) {
 801dd64:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd66:	2b00      	cmp	r3, #0
 801dd68:	d113      	bne.n	801dd92 <ecc_verify_hash+0x244>
        err = ecc_mul2add(mG, u1, mQ, u2, mG, curve->Af, curve->prime,
 801dd6a:	69bc      	ldr	r4, [r7, #24]
 801dd6c:	697d      	ldr	r5, [r7, #20]
 801dd6e:	69bb      	ldr	r3, [r7, #24]
 801dd70:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 801dd72:	6892      	ldr	r2, [r2, #8]
 801dd74:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 801dd76:	6849      	ldr	r1, [r1, #4]
 801dd78:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801dd7a:	6940      	ldr	r0, [r0, #20]
 801dd7c:	9003      	str	r0, [sp, #12]
 801dd7e:	9102      	str	r1, [sp, #8]
 801dd80:	9201      	str	r2, [sp, #4]
 801dd82:	9300      	str	r3, [sp, #0]
 801dd84:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801dd86:	462a      	mov	r2, r5
 801dd88:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 801dd8a:	4620      	mov	r0, r4
 801dd8c:	f7ff face 	bl	801d32c <ecc_mul2add>
 801dd90:	6478      	str	r0, [r7, #68]	@ 0x44
    }
#endif /* ECC_SHAMIR */
#endif /* FREESCALE_LTC_ECC */

   /* v = X_x1 mod n */
   if (err == MP_OKAY)
 801dd92:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dd94:	2b00      	cmp	r3, #0
 801dd96:	d108      	bne.n	801ddaa <ecc_verify_hash+0x25c>
       err = mp_mod(mG->x, curve->order, v);
 801dd98:	69bb      	ldr	r3, [r7, #24]
 801dd9a:	6818      	ldr	r0, [r3, #0]
 801dd9c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801dd9e:	691b      	ldr	r3, [r3, #16]
 801dda0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801dda2:	4619      	mov	r1, r3
 801dda4:	f008 fdb8 	bl	8026918 <mp_mod>
 801dda8:	6478      	str	r0, [r7, #68]	@ 0x44

   /* does v == r */
   if (err == MP_OKAY) {
 801ddaa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ddac:	2b00      	cmp	r3, #0
 801ddae:	d109      	bne.n	801ddc4 <ecc_verify_hash+0x276>
       if (mp_cmp(v, r) == MP_EQ)
 801ddb0:	68f9      	ldr	r1, [r7, #12]
 801ddb2:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801ddb4:	f008 fe06 	bl	80269c4 <mp_cmp>
 801ddb8:	4603      	mov	r3, r0
 801ddba:	2b00      	cmp	r3, #0
 801ddbc:	d102      	bne.n	801ddc4 <ecc_verify_hash+0x276>
           *res = 1;
 801ddbe:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801ddc0:	2201      	movs	r2, #1
 801ddc2:	601a      	str	r2, [r3, #0]
           *res = 0;
#endif
   }

   /* cleanup */
   wc_ecc_del_point_ex(mG, key->heap);
 801ddc4:	69ba      	ldr	r2, [r7, #24]
 801ddc6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ddc8:	695b      	ldr	r3, [r3, #20]
 801ddca:	4619      	mov	r1, r3
 801ddcc:	4610      	mov	r0, r2
 801ddce:	f7fe fdd9 	bl	801c984 <wc_ecc_del_point_ex>
   wc_ecc_del_point_ex(mQ, key->heap);
 801ddd2:	697a      	ldr	r2, [r7, #20]
 801ddd4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ddd6:	695b      	ldr	r3, [r3, #20]
 801ddd8:	4619      	mov	r1, r3
 801ddda:	4610      	mov	r0, r2
 801dddc:	f7fe fdd2 	bl	801c984 <wc_ecc_del_point_ex>

   mp_clear(e);
 801dde0:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801dde2:	f008 fce6 	bl	80267b2 <mp_clear>
   mp_clear(w);
 801dde6:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dde8:	f008 fce3 	bl	80267b2 <mp_clear>
   FREE_MP_INT_SIZE(w, key->heap, DYNAMIC_TYPE_ECC);
 801ddec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ddee:	627b      	str	r3, [r7, #36]	@ 0x24
 801ddf0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ddf2:	2b00      	cmp	r3, #0
 801ddf4:	d002      	beq.n	801ddfc <ecc_verify_hash+0x2ae>
 801ddf6:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801ddf8:	f000 fe68 	bl	801eacc <wolfSSL_Free>
   XFREE(u1, key->heap, DYNAMIC_TYPE_ECC);
   XFREE(u2, key->heap, DYNAMIC_TYPE_ECC);
#endif
#endif
#if !defined(WOLFSSL_ASYNC_CRYPT) || !defined(HAVE_CAVIUM_V)
   FREE_MP_INT_SIZE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
 801ddfc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ddfe:	623b      	str	r3, [r7, #32]
 801de00:	6a3b      	ldr	r3, [r7, #32]
 801de02:	2b00      	cmp	r3, #0
 801de04:	d002      	beq.n	801de0c <ecc_verify_hash+0x2be>
 801de06:	6a38      	ldr	r0, [r7, #32]
 801de08:	f000 fe60 	bl	801eacc <wolfSSL_Free>
#endif

   return err;
 801de0c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 801de0e:	4618      	mov	r0, r3
 801de10:	3748      	adds	r7, #72	@ 0x48
 801de12:	46bd      	mov	sp, r7
 801de14:	bdb0      	pop	{r4, r5, r7, pc}

0801de16 <wc_ecc_verify_hash_ex>:
               Caller should check the *res value to determine if the signature
               is valid or invalid. Other negative values are returned on error.
*/
int wc_ecc_verify_hash_ex(mp_int *r, mp_int *s, const byte* hash,
                    word32 hashlen, int* res, ecc_key* key)
{
 801de16:	b580      	push	{r7, lr}
 801de18:	b09e      	sub	sp, #120	@ 0x78
 801de1a:	af04      	add	r7, sp, #16
 801de1c:	60f8      	str	r0, [r7, #12]
 801de1e:	60b9      	str	r1, [r7, #8]
 801de20:	607a      	str	r2, [r7, #4]
 801de22:	603b      	str	r3, [r7, #0]
    return stm32_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
#elif defined(WOLFSSL_PSOC6_CRYPTO)
    return psoc6_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
#else
   int           err;
   word32        keySz = 0;
 801de24:	2300      	movs	r3, #0
 801de26:	65bb      	str	r3, [r7, #88]	@ 0x58
   byte sigRS[MAX_ECC_BYTES*2];
#elif defined(WOLFSSL_XILINX_CRYPT_VERSAL)
   byte sigRS[ECC_MAX_CRYPTO_HW_SIZE * 2];
   byte hashcopy[ECC_MAX_CRYPTO_HW_SIZE] = {0};
#else
   int curveLoaded = 0;
 801de28:	2300      	movs	r3, #0
 801de2a:	663b      	str	r3, [r7, #96]	@ 0x60
   DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
 801de2c:	2300      	movs	r3, #0
 801de2e:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801de30:	f107 0318 	add.w	r3, r7, #24
 801de34:	617b      	str	r3, [r7, #20]
 801de36:	697b      	ldr	r3, [r7, #20]
 801de38:	222c      	movs	r2, #44	@ 0x2c
 801de3a:	2100      	movs	r1, #0
 801de3c:	4618      	mov	r0, r3
 801de3e:	f00a fb47 	bl	80284d0 <memset>
 801de42:	697b      	ldr	r3, [r7, #20]
 801de44:	2206      	movs	r2, #6
 801de46:	621a      	str	r2, [r3, #32]
#endif

   if (r == NULL || s == NULL || hash == NULL || res == NULL || key == NULL)
 801de48:	68fb      	ldr	r3, [r7, #12]
 801de4a:	2b00      	cmp	r3, #0
 801de4c:	d00b      	beq.n	801de66 <wc_ecc_verify_hash_ex+0x50>
 801de4e:	68bb      	ldr	r3, [r7, #8]
 801de50:	2b00      	cmp	r3, #0
 801de52:	d008      	beq.n	801de66 <wc_ecc_verify_hash_ex+0x50>
 801de54:	687b      	ldr	r3, [r7, #4]
 801de56:	2b00      	cmp	r3, #0
 801de58:	d005      	beq.n	801de66 <wc_ecc_verify_hash_ex+0x50>
 801de5a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801de5c:	2b00      	cmp	r3, #0
 801de5e:	d002      	beq.n	801de66 <wc_ecc_verify_hash_ex+0x50>
 801de60:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801de62:	2b00      	cmp	r3, #0
 801de64:	d102      	bne.n	801de6c <wc_ecc_verify_hash_ex+0x56>
       return ECC_BAD_ARG_E;
 801de66:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801de6a:	e0d1      	b.n	801e010 <wc_ecc_verify_hash_ex+0x1fa>

   /* default to invalid signature */
   *res = 0;
 801de6c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801de6e:	2200      	movs	r2, #0
 801de70:	601a      	str	r2, [r3, #0]

   /* is the IDX valid ?  */
   if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {
 801de72:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801de74:	685b      	ldr	r3, [r3, #4]
 801de76:	4618      	mov	r0, r3
 801de78:	f7fe fdf8 	bl	801ca6c <wc_ecc_is_valid_idx>
 801de7c:	4603      	mov	r3, r0
 801de7e:	2b00      	cmp	r3, #0
 801de80:	d003      	beq.n	801de8a <wc_ecc_verify_hash_ex+0x74>
 801de82:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801de84:	691b      	ldr	r3, [r3, #16]
 801de86:	2b00      	cmp	r3, #0
 801de88:	d102      	bne.n	801de90 <wc_ecc_verify_hash_ex+0x7a>
      return ECC_BAD_ARG_E;
 801de8a:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801de8e:	e0bf      	b.n	801e010 <wc_ecc_verify_hash_ex+0x1fa>
   }

   err = wc_ecc_check_r_s_range(key, r, s);
 801de90:	68ba      	ldr	r2, [r7, #8]
 801de92:	68f9      	ldr	r1, [r7, #12]
 801de94:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801de96:	f7ff fdcd 	bl	801da34 <wc_ecc_check_r_s_range>
 801de9a:	6678      	str	r0, [r7, #100]	@ 0x64
   if (err != MP_OKAY) {
 801de9c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801de9e:	2b00      	cmp	r3, #0
 801dea0:	d001      	beq.n	801dea6 <wc_ecc_verify_hash_ex+0x90>
      return err;
 801dea2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801dea4:	e0b4      	b.n	801e010 <wc_ecc_verify_hash_ex+0x1fa>
   }

   keySz = (word32)key->dp->size;
 801dea6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801dea8:	691b      	ldr	r3, [r3, #16]
 801deaa:	681b      	ldr	r3, [r3, #0]
 801deac:	65bb      	str	r3, [r7, #88]	@ 0x58
    }
#endif

#else
  /* checking if private key with no public part */
  if (key->type == ECC_PRIVATEKEY_ONLY) {
 801deae:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801deb0:	681b      	ldr	r3, [r3, #0]
 801deb2:	2b03      	cmp	r3, #3
 801deb4:	d143      	bne.n	801df3e <wc_ecc_verify_hash_ex+0x128>
      WOLFSSL_MSG("Verify called with private key, generating public part");
      ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 801deb6:	f640 5008 	movw	r0, #3336	@ 0xd08
 801deba:	f000 fdeb 	bl	801ea94 <wolfSSL_Malloc>
 801debe:	65f8      	str	r0, [r7, #92]	@ 0x5c
 801dec0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dec2:	2b00      	cmp	r3, #0
 801dec4:	d103      	bne.n	801dece <wc_ecc_verify_hash_ex+0xb8>
 801dec6:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801deca:	667b      	str	r3, [r7, #100]	@ 0x64
 801decc:	e002      	b.n	801ded4 <wc_ecc_verify_hash_ex+0xbe>
 801dece:	697b      	ldr	r3, [r7, #20]
 801ded0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801ded2:	61da      	str	r2, [r3, #28]
      if (err != MP_OKAY) {
 801ded4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801ded6:	2b00      	cmp	r3, #0
 801ded8:	d001      	beq.n	801dede <wc_ecc_verify_hash_ex+0xc8>
          return err;
 801deda:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801dedc:	e098      	b.n	801e010 <wc_ecc_verify_hash_ex+0x1fa>
      }
      err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 801dede:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801dee0:	691b      	ldr	r3, [r3, #16]
 801dee2:	f107 0114 	add.w	r1, r7, #20
 801dee6:	223f      	movs	r2, #63	@ 0x3f
 801dee8:	4618      	mov	r0, r3
 801deea:	f7fc fd34 	bl	801a956 <wc_ecc_curve_load>
 801deee:	6678      	str	r0, [r7, #100]	@ 0x64
      if (err != MP_OKAY) {
 801def0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801def2:	2b00      	cmp	r3, #0
 801def4:	d009      	beq.n	801df0a <wc_ecc_verify_hash_ex+0xf4>
          FREE_CURVE_SPECS();
 801def6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801def8:	653b      	str	r3, [r7, #80]	@ 0x50
 801defa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801defc:	2b00      	cmp	r3, #0
 801defe:	d002      	beq.n	801df06 <wc_ecc_verify_hash_ex+0xf0>
 801df00:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801df02:	f000 fde3 	bl	801eacc <wolfSSL_Free>
          return err;
 801df06:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801df08:	e082      	b.n	801e010 <wc_ecc_verify_hash_ex+0x1fa>
      }
      err = ecc_make_pub_ex(key, curve, NULL, NULL);
 801df0a:	6979      	ldr	r1, [r7, #20]
 801df0c:	2300      	movs	r3, #0
 801df0e:	2200      	movs	r2, #0
 801df10:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801df12:	f7fe fe8d 	bl	801cc30 <ecc_make_pub_ex>
 801df16:	6678      	str	r0, [r7, #100]	@ 0x64
      if (err != MP_OKAY) {
 801df18:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801df1a:	2b00      	cmp	r3, #0
 801df1c:	d00d      	beq.n	801df3a <wc_ecc_verify_hash_ex+0x124>
           WOLFSSL_MSG("Unable to extract public key");
           wc_ecc_curve_free(curve);
 801df1e:	697b      	ldr	r3, [r7, #20]
 801df20:	4618      	mov	r0, r3
 801df22:	f7fc fccd 	bl	801a8c0 <wc_ecc_curve_free>
           FREE_CURVE_SPECS();
 801df26:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801df28:	657b      	str	r3, [r7, #84]	@ 0x54
 801df2a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801df2c:	2b00      	cmp	r3, #0
 801df2e:	d002      	beq.n	801df36 <wc_ecc_verify_hash_ex+0x120>
 801df30:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 801df32:	f000 fdcb 	bl	801eacc <wolfSSL_Free>
           return err;
 801df36:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801df38:	e06a      	b.n	801e010 <wc_ecc_verify_hash_ex+0x1fa>
      }
      curveLoaded = 1;
 801df3a:	2301      	movs	r3, #1
 801df3c:	663b      	str	r3, [r7, #96]	@ 0x60
  }

  err = ecc_verify_hash_sp(r, s, hash, hashlen, res, key);
 801df3e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801df40:	9301      	str	r3, [sp, #4]
 801df42:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801df44:	9300      	str	r3, [sp, #0]
 801df46:	683b      	ldr	r3, [r7, #0]
 801df48:	687a      	ldr	r2, [r7, #4]
 801df4a:	68b9      	ldr	r1, [r7, #8]
 801df4c:	68f8      	ldr	r0, [r7, #12]
 801df4e:	f7ff fdef 	bl	801db30 <ecc_verify_hash_sp>
 801df52:	6678      	str	r0, [r7, #100]	@ 0x64
  if (err != WC_NO_ERR_TRACE(NOT_COMPILED_IN)) {
 801df54:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801df56:	f113 0fae 	cmn.w	r3, #174	@ 0xae
 801df5a:	d010      	beq.n	801df7e <wc_ecc_verify_hash_ex+0x168>
      if (curveLoaded) {
 801df5c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801df5e:	2b00      	cmp	r3, #0
 801df60:	d00b      	beq.n	801df7a <wc_ecc_verify_hash_ex+0x164>
           wc_ecc_curve_free(curve);
 801df62:	697b      	ldr	r3, [r7, #20]
 801df64:	4618      	mov	r0, r3
 801df66:	f7fc fcab 	bl	801a8c0 <wc_ecc_curve_free>
           FREE_CURVE_SPECS();
 801df6a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801df6c:	647b      	str	r3, [r7, #68]	@ 0x44
 801df6e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801df70:	2b00      	cmp	r3, #0
 801df72:	d002      	beq.n	801df7a <wc_ecc_verify_hash_ex+0x164>
 801df74:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801df76:	f000 fda9 	bl	801eacc <wolfSSL_Free>
      }
      return err;
 801df7a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801df7c:	e048      	b.n	801e010 <wc_ecc_verify_hash_ex+0x1fa>
  }

#if !defined(WOLFSSL_SP_MATH) || defined(FREESCALE_LTC_ECC)
   if (!curveLoaded) {
 801df7e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801df80:	2b00      	cmp	r3, #0
 801df82:	d12b      	bne.n	801dfdc <wc_ecc_verify_hash_ex+0x1c6>
       err = 0; /* potential for NOT_COMPILED_IN error from SP attempt */
 801df84:	2300      	movs	r3, #0
 801df86:	667b      	str	r3, [r7, #100]	@ 0x64
       ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 801df88:	f640 5008 	movw	r0, #3336	@ 0xd08
 801df8c:	f000 fd82 	bl	801ea94 <wolfSSL_Malloc>
 801df90:	65f8      	str	r0, [r7, #92]	@ 0x5c
 801df92:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801df94:	2b00      	cmp	r3, #0
 801df96:	d103      	bne.n	801dfa0 <wc_ecc_verify_hash_ex+0x18a>
 801df98:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801df9c:	667b      	str	r3, [r7, #100]	@ 0x64
 801df9e:	e002      	b.n	801dfa6 <wc_ecc_verify_hash_ex+0x190>
 801dfa0:	697b      	ldr	r3, [r7, #20]
 801dfa2:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801dfa4:	61da      	str	r2, [r3, #28]
       if (err != 0) {
 801dfa6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801dfa8:	2b00      	cmp	r3, #0
 801dfaa:	d001      	beq.n	801dfb0 <wc_ecc_verify_hash_ex+0x19a>
          return err;
 801dfac:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801dfae:	e02f      	b.n	801e010 <wc_ecc_verify_hash_ex+0x1fa>
       }
       /* read in the specs for this curve */
       err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 801dfb0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801dfb2:	691b      	ldr	r3, [r3, #16]
 801dfb4:	f107 0114 	add.w	r1, r7, #20
 801dfb8:	223f      	movs	r2, #63	@ 0x3f
 801dfba:	4618      	mov	r0, r3
 801dfbc:	f7fc fccb 	bl	801a956 <wc_ecc_curve_load>
 801dfc0:	6678      	str	r0, [r7, #100]	@ 0x64
       if (err != 0) {
 801dfc2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801dfc4:	2b00      	cmp	r3, #0
 801dfc6:	d009      	beq.n	801dfdc <wc_ecc_verify_hash_ex+0x1c6>
          FREE_CURVE_SPECS();
 801dfc8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801dfca:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801dfcc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801dfce:	2b00      	cmp	r3, #0
 801dfd0:	d002      	beq.n	801dfd8 <wc_ecc_verify_hash_ex+0x1c2>
 801dfd2:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801dfd4:	f000 fd7a 	bl	801eacc <wolfSSL_Free>
          return err;
 801dfd8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801dfda:	e019      	b.n	801e010 <wc_ecc_verify_hash_ex+0x1fa>
       }
   }

   err = ecc_verify_hash(r, s, hash, hashlen, res, key, curve);
 801dfdc:	697b      	ldr	r3, [r7, #20]
 801dfde:	9302      	str	r3, [sp, #8]
 801dfe0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801dfe2:	9301      	str	r3, [sp, #4]
 801dfe4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801dfe6:	9300      	str	r3, [sp, #0]
 801dfe8:	683b      	ldr	r3, [r7, #0]
 801dfea:	687a      	ldr	r2, [r7, #4]
 801dfec:	68b9      	ldr	r1, [r7, #8]
 801dfee:	68f8      	ldr	r0, [r7, #12]
 801dff0:	f7ff fdad 	bl	801db4e <ecc_verify_hash>
 801dff4:	6678      	str	r0, [r7, #100]	@ 0x64
#endif /* !WOLFSSL_SP_MATH || FREESCALE_LTC_ECC */

   (void)curveLoaded;
   wc_ecc_curve_free(curve);
 801dff6:	697b      	ldr	r3, [r7, #20]
 801dff8:	4618      	mov	r0, r3
 801dffa:	f7fc fc61 	bl	801a8c0 <wc_ecc_curve_free>
   FREE_CURVE_SPECS();
 801dffe:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e000:	64bb      	str	r3, [r7, #72]	@ 0x48
 801e002:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801e004:	2b00      	cmp	r3, #0
 801e006:	d002      	beq.n	801e00e <wc_ecc_verify_hash_ex+0x1f8>
 801e008:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801e00a:	f000 fd5f 	bl	801eacc <wolfSSL_Free>
#endif /* HAVE_ECC_VERIFY_HELPER */

   (void)keySz;
   (void)hashlen;

   return err;
 801e00e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
#endif /* WOLFSSL_STM32_PKA */
}
 801e010:	4618      	mov	r0, r3
 801e012:	3768      	adds	r7, #104	@ 0x68
 801e014:	46bd      	mov	sp, r7
 801e016:	bd80      	pop	{r7, pc}

0801e018 <wc_ecc_import_x963_ex>:

#ifdef HAVE_ECC_KEY_IMPORT
/* import public ECC key in ANSI X9.63 format */
int wc_ecc_import_x963_ex(const byte* in, word32 inLen, ecc_key* key,
                          int curve_id)
{
 801e018:	b580      	push	{r7, lr}
 801e01a:	b088      	sub	sp, #32
 801e01c:	af00      	add	r7, sp, #0
 801e01e:	60f8      	str	r0, [r7, #12]
 801e020:	60b9      	str	r1, [r7, #8]
 801e022:	607a      	str	r2, [r7, #4]
 801e024:	603b      	str	r3, [r7, #0]
    int err = MP_OKAY;
 801e026:	2300      	movs	r3, #0
 801e028:	61fb      	str	r3, [r7, #28]
#ifdef HAVE_COMP_KEY
    int compressed = 0;
#endif
    int keysize = 0;
 801e02a:	2300      	movs	r3, #0
 801e02c:	61bb      	str	r3, [r7, #24]
    byte pointType;
#ifdef WOLFSSL_CRYPTOCELL
    const CRYS_ECPKI_Domain_t* pDomain;
    CRYS_ECPKI_BUILD_TempData_t tempBuff;
#endif
    if (in == NULL || key == NULL)
 801e02e:	68fb      	ldr	r3, [r7, #12]
 801e030:	2b00      	cmp	r3, #0
 801e032:	d002      	beq.n	801e03a <wc_ecc_import_x963_ex+0x22>
 801e034:	687b      	ldr	r3, [r7, #4]
 801e036:	2b00      	cmp	r3, #0
 801e038:	d102      	bne.n	801e040 <wc_ecc_import_x963_ex+0x28>
        return BAD_FUNC_ARG;
 801e03a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e03e:	e0a2      	b.n	801e186 <wc_ecc_import_x963_ex+0x16e>

    /* must be odd */
    if ((inLen & 1) == 0) {
 801e040:	68bb      	ldr	r3, [r7, #8]
 801e042:	f003 0301 	and.w	r3, r3, #1
 801e046:	2b00      	cmp	r3, #0
 801e048:	d102      	bne.n	801e050 <wc_ecc_import_x963_ex+0x38>
        return ECC_BAD_ARG_E;
 801e04a:	f06f 03a9 	mvn.w	r3, #169	@ 0xa9
 801e04e:	e09a      	b.n	801e186 <wc_ecc_import_x963_ex+0x16e>
    }

    /* make sure required variables are reset */
    wc_ecc_reset(key);
 801e050:	6878      	ldr	r0, [r7, #4]
 801e052:	f7fe fde0 	bl	801cc16 <wc_ecc_reset>

    /* init key */
    #ifdef ALT_ECC_SIZE
        key->pubkey.x = (mp_int*)&key->pubkey.xyz[0];
 801e056:	687b      	ldr	r3, [r7, #4]
 801e058:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 801e05c:	687b      	ldr	r3, [r7, #4]
 801e05e:	619a      	str	r2, [r3, #24]
        key->pubkey.y = (mp_int*)&key->pubkey.xyz[1];
 801e060:	687b      	ldr	r3, [r7, #4]
 801e062:	f103 0274 	add.w	r2, r3, #116	@ 0x74
 801e066:	687b      	ldr	r3, [r7, #4]
 801e068:	61da      	str	r2, [r3, #28]
        key->pubkey.z = (mp_int*)&key->pubkey.xyz[2];
 801e06a:	687b      	ldr	r3, [r7, #4]
 801e06c:	f103 02c4 	add.w	r2, r3, #196	@ 0xc4
 801e070:	687b      	ldr	r3, [r7, #4]
 801e072:	621a      	str	r2, [r3, #32]
        alt_fp_init(key->pubkey.x);
 801e074:	687b      	ldr	r3, [r7, #4]
 801e076:	699b      	ldr	r3, [r3, #24]
 801e078:	4618      	mov	r0, r3
 801e07a:	f7fc fd87 	bl	801ab8c <alt_fp_init>
        alt_fp_init(key->pubkey.y);
 801e07e:	687b      	ldr	r3, [r7, #4]
 801e080:	69db      	ldr	r3, [r3, #28]
 801e082:	4618      	mov	r0, r3
 801e084:	f7fc fd82 	bl	801ab8c <alt_fp_init>
        alt_fp_init(key->pubkey.z);
 801e088:	687b      	ldr	r3, [r7, #4]
 801e08a:	6a1b      	ldr	r3, [r3, #32]
 801e08c:	4618      	mov	r0, r3
 801e08e:	f7fc fd7d 	bl	801ab8c <alt_fp_init>
        key->k = (mp_int*)key->ka;
 801e092:	687b      	ldr	r3, [r7, #4]
 801e094:	f503 728e 	add.w	r2, r3, #284	@ 0x11c
 801e098:	687b      	ldr	r3, [r7, #4]
 801e09a:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
        alt_fp_init(key->k);
 801e09e:	687b      	ldr	r3, [r7, #4]
 801e0a0:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801e0a4:	4618      	mov	r0, r3
 801e0a6:	f7fc fd71 	bl	801ab8c <alt_fp_init>
    #else
                                                                key->kb, key->ku
    #endif
                            );
    #endif
    if (err != MP_OKAY)
 801e0aa:	69fb      	ldr	r3, [r7, #28]
 801e0ac:	2b00      	cmp	r3, #0
 801e0ae:	d002      	beq.n	801e0b6 <wc_ecc_import_x963_ex+0x9e>
        return MEMORY_E;
 801e0b0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e0b4:	e067      	b.n	801e186 <wc_ecc_import_x963_ex+0x16e>
#endif

    SAVE_VECTOR_REGISTERS(return _svr_ret;);

    /* check for point type (4, 2, or 3) */
    pointType = in[0];
 801e0b6:	68fb      	ldr	r3, [r7, #12]
 801e0b8:	781b      	ldrb	r3, [r3, #0]
 801e0ba:	75fb      	strb	r3, [r7, #23]
    if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&
 801e0bc:	7dfb      	ldrb	r3, [r7, #23]
 801e0be:	2b04      	cmp	r3, #4
 801e0c0:	d008      	beq.n	801e0d4 <wc_ecc_import_x963_ex+0xbc>
 801e0c2:	7dfb      	ldrb	r3, [r7, #23]
 801e0c4:	2b02      	cmp	r3, #2
 801e0c6:	d005      	beq.n	801e0d4 <wc_ecc_import_x963_ex+0xbc>
 801e0c8:	7dfb      	ldrb	r3, [r7, #23]
 801e0ca:	2b03      	cmp	r3, #3
 801e0cc:	d002      	beq.n	801e0d4 <wc_ecc_import_x963_ex+0xbc>
                                         pointType != ECC_POINT_COMP_ODD) {
        err = ASN_PARSE_E;
 801e0ce:	f06f 038b 	mvn.w	r3, #139	@ 0x8b
 801e0d2:	61fb      	str	r3, [r7, #28]
    }

    if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {
 801e0d4:	7dfb      	ldrb	r3, [r7, #23]
 801e0d6:	2b02      	cmp	r3, #2
 801e0d8:	d002      	beq.n	801e0e0 <wc_ecc_import_x963_ex+0xc8>
 801e0da:	7dfb      	ldrb	r3, [r7, #23]
 801e0dc:	2b03      	cmp	r3, #3
 801e0de:	d102      	bne.n	801e0e6 <wc_ecc_import_x963_ex+0xce>
    #ifdef HAVE_COMP_KEY
        compressed = 1;
    #else
        err = NOT_COMPILED_IN;
 801e0e0:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 801e0e4:	61fb      	str	r3, [r7, #28]
    #endif
    }

    /* adjust to skip first byte */
    inLen -= 1;
 801e0e6:	68bb      	ldr	r3, [r7, #8]
 801e0e8:	3b01      	subs	r3, #1
 801e0ea:	60bb      	str	r3, [r7, #8]
    in += 1;
 801e0ec:	68fb      	ldr	r3, [r7, #12]
 801e0ee:	3301      	adds	r3, #1
 801e0f0:	60fb      	str	r3, [r7, #12]
    }
#elif defined(WOLFSSL_KCAPI_ECC)
    XMEMCPY(key->pubkey_raw, (byte*)in, inLen);
#endif

    if (err == MP_OKAY) {
 801e0f2:	69fb      	ldr	r3, [r7, #28]
 801e0f4:	2b00      	cmp	r3, #0
 801e0f6:	d10b      	bne.n	801e110 <wc_ecc_import_x963_ex+0xf8>
        if (compressed)
            inLen = inLen*2 + 1;  /* used uncompressed len */
    #endif

        /* determine key size */
        keysize = (int)(inLen>>1);
 801e0f8:	68bb      	ldr	r3, [r7, #8]
 801e0fa:	085b      	lsrs	r3, r3, #1
 801e0fc:	61bb      	str	r3, [r7, #24]
        /* NOTE: FIPS v6.0.0 or greater, no restriction on imported keys, only
         *       on created keys or signatures */
        err = wc_ecc_set_curve(key, keysize, curve_id);
 801e0fe:	683a      	ldr	r2, [r7, #0]
 801e100:	69b9      	ldr	r1, [r7, #24]
 801e102:	6878      	ldr	r0, [r7, #4]
 801e104:	f7fc fcd4 	bl	801aab0 <wc_ecc_set_curve>
 801e108:	61f8      	str	r0, [r7, #28]
        key->type = ECC_PUBLICKEY;
 801e10a:	687b      	ldr	r3, [r7, #4]
 801e10c:	2201      	movs	r2, #1
 801e10e:	601a      	str	r2, [r3, #0]
    }

    /* read data */
    if (err == MP_OKAY)
 801e110:	69fb      	ldr	r3, [r7, #28]
 801e112:	2b00      	cmp	r3, #0
 801e114:	d107      	bne.n	801e126 <wc_ecc_import_x963_ex+0x10e>
        err = mp_read_unsigned_bin(key->pubkey.x, in, (word32)keysize);
 801e116:	687b      	ldr	r3, [r7, #4]
 801e118:	699b      	ldr	r3, [r3, #24]
 801e11a:	69ba      	ldr	r2, [r7, #24]
 801e11c:	68f9      	ldr	r1, [r7, #12]
 801e11e:	4618      	mov	r0, r3
 801e120:	f008 fc96 	bl	8026a50 <mp_read_unsigned_bin>
 801e124:	61f8      	str	r0, [r7, #28]
        }
#endif
    }
#endif /* HAVE_COMP_KEY */

    if (err == MP_OKAY) {
 801e126:	69fb      	ldr	r3, [r7, #28]
 801e128:	2b00      	cmp	r3, #0
 801e12a:	d109      	bne.n	801e140 <wc_ecc_import_x963_ex+0x128>
    #ifdef HAVE_COMP_KEY
        if (compressed == 0)
    #endif
        {
            err = mp_read_unsigned_bin(key->pubkey.y, in + keysize,
 801e12c:	687b      	ldr	r3, [r7, #4]
 801e12e:	69d8      	ldr	r0, [r3, #28]
 801e130:	69bb      	ldr	r3, [r7, #24]
 801e132:	68fa      	ldr	r2, [r7, #12]
 801e134:	4413      	add	r3, r2
 801e136:	69ba      	ldr	r2, [r7, #24]
 801e138:	4619      	mov	r1, r3
 801e13a:	f008 fc89 	bl	8026a50 <mp_read_unsigned_bin>
 801e13e:	61f8      	str	r0, [r7, #28]
                (word32)keysize);
        }
    }
    if (err == MP_OKAY)
 801e140:	69fb      	ldr	r3, [r7, #28]
 801e142:	2b00      	cmp	r3, #0
 801e144:	d106      	bne.n	801e154 <wc_ecc_import_x963_ex+0x13c>
        err = mp_set(key->pubkey.z, 1);
 801e146:	687b      	ldr	r3, [r7, #4]
 801e148:	6a1b      	ldr	r3, [r3, #32]
 801e14a:	2101      	movs	r1, #1
 801e14c:	4618      	mov	r0, r3
 801e14e:	f008 ffaf 	bl	80270b0 <mp_set>
 801e152:	61f8      	str	r0, [r7, #28]
    if (err == MP_OKAY) {
        err = wc_MAXQ10XX_EccSetKey(key, keysize);
    }
#endif

    if (err != MP_OKAY) {
 801e154:	69fb      	ldr	r3, [r7, #28]
 801e156:	2b00      	cmp	r3, #0
 801e158:	d014      	beq.n	801e184 <wc_ecc_import_x963_ex+0x16c>
        mp_clear(key->pubkey.x);
 801e15a:	687b      	ldr	r3, [r7, #4]
 801e15c:	699b      	ldr	r3, [r3, #24]
 801e15e:	4618      	mov	r0, r3
 801e160:	f008 fb27 	bl	80267b2 <mp_clear>
        mp_clear(key->pubkey.y);
 801e164:	687b      	ldr	r3, [r7, #4]
 801e166:	69db      	ldr	r3, [r3, #28]
 801e168:	4618      	mov	r0, r3
 801e16a:	f008 fb22 	bl	80267b2 <mp_clear>
        mp_clear(key->pubkey.z);
 801e16e:	687b      	ldr	r3, [r7, #4]
 801e170:	6a1b      	ldr	r3, [r3, #32]
 801e172:	4618      	mov	r0, r3
 801e174:	f008 fb1d 	bl	80267b2 <mp_clear>
        mp_clear(key->k);
 801e178:	687b      	ldr	r3, [r7, #4]
 801e17a:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801e17e:	4618      	mov	r0, r3
 801e180:	f008 fb17 	bl	80267b2 <mp_clear>
    }

    RESTORE_VECTOR_REGISTERS();

    return err;
 801e184:	69fb      	ldr	r3, [r7, #28]
}
 801e186:	4618      	mov	r0, r3
 801e188:	3720      	adds	r7, #32
 801e18a:	46bd      	mov	sp, r7
 801e18c:	bd80      	pop	{r7, pc}

0801e18e <wc_ecc_import_private_key_ex>:
#ifdef HAVE_ECC_KEY_IMPORT
/* import private key, public part optional if (pub) passed as NULL */
int wc_ecc_import_private_key_ex(const byte* priv, word32 privSz,
                                 const byte* pub, word32 pubSz, ecc_key* key,
                                 int curve_id)
{
 801e18e:	b580      	push	{r7, lr}
 801e190:	b086      	sub	sp, #24
 801e192:	af00      	add	r7, sp, #0
 801e194:	60f8      	str	r0, [r7, #12]
 801e196:	60b9      	str	r1, [r7, #8]
 801e198:	607a      	str	r2, [r7, #4]
 801e19a:	603b      	str	r3, [r7, #0]
    int ret;
#ifdef WOLFSSL_CRYPTOCELL
    const CRYS_ECPKI_Domain_t* pDomain;
#endif
    if (key == NULL || priv == NULL)
 801e19c:	6a3b      	ldr	r3, [r7, #32]
 801e19e:	2b00      	cmp	r3, #0
 801e1a0:	d002      	beq.n	801e1a8 <wc_ecc_import_private_key_ex+0x1a>
 801e1a2:	68fb      	ldr	r3, [r7, #12]
 801e1a4:	2b00      	cmp	r3, #0
 801e1a6:	d102      	bne.n	801e1ae <wc_ecc_import_private_key_ex+0x20>
        return BAD_FUNC_ARG;
 801e1a8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e1ac:	e036      	b.n	801e21c <wc_ecc_import_private_key_ex+0x8e>

    /* public optional, NULL if only importing private */
    if (pub != NULL) {
 801e1ae:	687b      	ldr	r3, [r7, #4]
 801e1b0:	2b00      	cmp	r3, #0
 801e1b2:	d017      	beq.n	801e1e4 <wc_ecc_import_private_key_ex+0x56>
    #ifndef NO_ASN
        word32 idx = 0;
 801e1b4:	2300      	movs	r3, #0
 801e1b6:	613b      	str	r3, [r7, #16]
        ret = wc_ecc_import_x963_ex(pub, pubSz, key, curve_id);
 801e1b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e1ba:	6a3a      	ldr	r2, [r7, #32]
 801e1bc:	6839      	ldr	r1, [r7, #0]
 801e1be:	6878      	ldr	r0, [r7, #4]
 801e1c0:	f7ff ff2a 	bl	801e018 <wc_ecc_import_x963_ex>
 801e1c4:	6178      	str	r0, [r7, #20]
        if (ret < 0)
 801e1c6:	697b      	ldr	r3, [r7, #20]
 801e1c8:	2b00      	cmp	r3, #0
 801e1ca:	da07      	bge.n	801e1dc <wc_ecc_import_private_key_ex+0x4e>
            ret = wc_EccPublicKeyDecode(pub, &idx, key, pubSz);
 801e1cc:	f107 0110 	add.w	r1, r7, #16
 801e1d0:	683b      	ldr	r3, [r7, #0]
 801e1d2:	6a3a      	ldr	r2, [r7, #32]
 801e1d4:	6878      	ldr	r0, [r7, #4]
 801e1d6:	f7fb febb 	bl	8019f50 <wc_EccPublicKeyDecode>
 801e1da:	6178      	str	r0, [r7, #20]
        key->type = ECC_PRIVATEKEY;
 801e1dc:	6a3b      	ldr	r3, [r7, #32]
 801e1de:	2202      	movs	r2, #2
 801e1e0:	601a      	str	r2, [r3, #0]
 801e1e2:	e00c      	b.n	801e1fe <wc_ecc_import_private_key_ex+0x70>
        ret = NOT_COMPILED_IN;
    #endif
    }
    else {
        /* make sure required variables are reset */
        wc_ecc_reset(key);
 801e1e4:	6a38      	ldr	r0, [r7, #32]
 801e1e6:	f7fe fd16 	bl	801cc16 <wc_ecc_reset>

        /* set key size */
        /* NOTE: FIPS v6.0.0 or greater, no restriction on imported keys, only
         *       on created keys or signatures */
        ret = wc_ecc_set_curve(key, (int)privSz, curve_id);
 801e1ea:	68bb      	ldr	r3, [r7, #8]
 801e1ec:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801e1ee:	4619      	mov	r1, r3
 801e1f0:	6a38      	ldr	r0, [r7, #32]
 801e1f2:	f7fc fc5d 	bl	801aab0 <wc_ecc_set_curve>
 801e1f6:	6178      	str	r0, [r7, #20]
        key->type = ECC_PRIVATEKEY_ONLY;
 801e1f8:	6a3b      	ldr	r3, [r7, #32]
 801e1fa:	2203      	movs	r2, #3
 801e1fc:	601a      	str	r2, [r3, #0]
    }

    if (ret != 0)
 801e1fe:	697b      	ldr	r3, [r7, #20]
 801e200:	2b00      	cmp	r3, #0
 801e202:	d001      	beq.n	801e208 <wc_ecc_import_private_key_ex+0x7a>
        return ret;
 801e204:	697b      	ldr	r3, [r7, #20]
 801e206:	e009      	b.n	801e21c <wc_ecc_import_private_key_ex+0x8e>

#ifdef WOLFSSL_VALIDATE_ECC_IMPORT
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
#endif

    ret = mp_read_unsigned_bin(key->k, priv, privSz);
 801e208:	6a3b      	ldr	r3, [r7, #32]
 801e20a:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
 801e20e:	68ba      	ldr	r2, [r7, #8]
 801e210:	68f9      	ldr	r1, [r7, #12]
 801e212:	4618      	mov	r0, r3
 801e214:	f008 fc1c 	bl	8026a50 <mp_read_unsigned_bin>
 801e218:	6178      	str	r0, [r7, #20]
    if (ret == 0) {
        ret = silabs_ecc_import(key, key->dp->size, (pub != NULL), 1);
    }
#endif

    return ret;
 801e21a:	697b      	ldr	r3, [r7, #20]
}
 801e21c:	4618      	mov	r0, r3
 801e21e:	3718      	adds	r7, #24
 801e220:	46bd      	mov	sp, r7
 801e222:	bd80      	pop	{r7, pc}

0801e224 <wc_ecc_size>:
#endif

/* key size in octets */
WOLFSSL_ABI
int wc_ecc_size(ecc_key* key)
{
 801e224:	b480      	push	{r7}
 801e226:	b083      	sub	sp, #12
 801e228:	af00      	add	r7, sp, #0
 801e22a:	6078      	str	r0, [r7, #4]
    if (key == NULL || key->dp == NULL)
 801e22c:	687b      	ldr	r3, [r7, #4]
 801e22e:	2b00      	cmp	r3, #0
 801e230:	d003      	beq.n	801e23a <wc_ecc_size+0x16>
 801e232:	687b      	ldr	r3, [r7, #4]
 801e234:	691b      	ldr	r3, [r3, #16]
 801e236:	2b00      	cmp	r3, #0
 801e238:	d101      	bne.n	801e23e <wc_ecc_size+0x1a>
        return 0;
 801e23a:	2300      	movs	r3, #0
 801e23c:	e002      	b.n	801e244 <wc_ecc_size+0x20>

    return key->dp->size;
 801e23e:	687b      	ldr	r3, [r7, #4]
 801e240:	691b      	ldr	r3, [r3, #16]
 801e242:	681b      	ldr	r3, [r3, #0]
}
 801e244:	4618      	mov	r0, r3
 801e246:	370c      	adds	r7, #12
 801e248:	46bd      	mov	sp, r7
 801e24a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e24e:	4770      	bx	lr

0801e250 <wc_ecc_sig_size>:
}

/* maximum signature size based on actual key curve */
WOLFSSL_ABI
int wc_ecc_sig_size(const ecc_key* key)
{
 801e250:	b580      	push	{r7, lr}
 801e252:	b086      	sub	sp, #24
 801e254:	af00      	add	r7, sp, #0
 801e256:	6078      	str	r0, [r7, #4]
    int maxSigSz;
    int orderBits, keySz;

    if (key == NULL || key->dp == NULL)
 801e258:	687b      	ldr	r3, [r7, #4]
 801e25a:	2b00      	cmp	r3, #0
 801e25c:	d003      	beq.n	801e266 <wc_ecc_sig_size+0x16>
 801e25e:	687b      	ldr	r3, [r7, #4]
 801e260:	691b      	ldr	r3, [r3, #16]
 801e262:	2b00      	cmp	r3, #0
 801e264:	d101      	bne.n	801e26a <wc_ecc_sig_size+0x1a>
        return 0;
 801e266:	2300      	movs	r3, #0
 801e268:	e028      	b.n	801e2bc <wc_ecc_sig_size+0x6c>

    /* the signature r and s will always be less than order */
    /* if the order MSB (top bit of byte) is set then ASN encoding needs
        extra byte for r and s, so add 2 */
    keySz = key->dp->size;
 801e26a:	687b      	ldr	r3, [r7, #4]
 801e26c:	691b      	ldr	r3, [r3, #16]
 801e26e:	681b      	ldr	r3, [r3, #0]
 801e270:	613b      	str	r3, [r7, #16]
    orderBits = wc_ecc_get_curve_order_bit_count(key->dp);
 801e272:	687b      	ldr	r3, [r7, #4]
 801e274:	691b      	ldr	r3, [r3, #16]
 801e276:	4618      	mov	r0, r3
 801e278:	f7fe fe03 	bl	801ce82 <wc_ecc_get_curve_order_bit_count>
 801e27c:	60f8      	str	r0, [r7, #12]
    if (orderBits > keySz * 8) {
 801e27e:	693b      	ldr	r3, [r7, #16]
 801e280:	00db      	lsls	r3, r3, #3
 801e282:	68fa      	ldr	r2, [r7, #12]
 801e284:	429a      	cmp	r2, r3
 801e286:	dd06      	ble.n	801e296 <wc_ecc_sig_size+0x46>
        keySz = (orderBits + 7) / 8;
 801e288:	68fb      	ldr	r3, [r7, #12]
 801e28a:	3307      	adds	r3, #7
 801e28c:	2b00      	cmp	r3, #0
 801e28e:	da00      	bge.n	801e292 <wc_ecc_sig_size+0x42>
 801e290:	3307      	adds	r3, #7
 801e292:	10db      	asrs	r3, r3, #3
 801e294:	613b      	str	r3, [r7, #16]
    }
    /* maximum possible signature header size is 7 bytes */
    maxSigSz = (keySz * 2) + SIG_HEADER_SZ;
 801e296:	693b      	ldr	r3, [r7, #16]
 801e298:	005b      	lsls	r3, r3, #1
 801e29a:	3307      	adds	r3, #7
 801e29c:	617b      	str	r3, [r7, #20]
    if ((orderBits % 8) == 0) {
 801e29e:	68fb      	ldr	r3, [r7, #12]
 801e2a0:	f003 0307 	and.w	r3, r3, #7
 801e2a4:	2b00      	cmp	r3, #0
 801e2a6:	d102      	bne.n	801e2ae <wc_ecc_sig_size+0x5e>
        /* MSB can be set, so add 2 */
        maxSigSz += ECC_MAX_PAD_SZ;
 801e2a8:	697b      	ldr	r3, [r7, #20]
 801e2aa:	3302      	adds	r3, #2
 801e2ac:	617b      	str	r3, [r7, #20]
    }
    /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */
    if (maxSigSz < (128 + 2)) {
 801e2ae:	697b      	ldr	r3, [r7, #20]
 801e2b0:	2b81      	cmp	r3, #129	@ 0x81
 801e2b2:	dc02      	bgt.n	801e2ba <wc_ecc_sig_size+0x6a>
        maxSigSz -= 1;
 801e2b4:	697b      	ldr	r3, [r7, #20]
 801e2b6:	3b01      	subs	r3, #1
 801e2b8:	617b      	str	r3, [r7, #20]
    }

    return maxSigSz;
 801e2ba:	697b      	ldr	r3, [r7, #20]
}
 801e2bc:	4618      	mov	r0, r3
 801e2be:	3718      	adds	r7, #24
 801e2c0:	46bd      	mov	sp, r7
 801e2c2:	bd80      	pop	{r7, pc}

0801e2c4 <wc_ecc_get_oid>:
#endif
}
#endif /* HAVE_OID_ENCODING */

int wc_ecc_get_oid(word32 oidSum, const byte** oid, word32* oidSz)
{
 801e2c4:	b480      	push	{r7}
 801e2c6:	b087      	sub	sp, #28
 801e2c8:	af00      	add	r7, sp, #0
 801e2ca:	60f8      	str	r0, [r7, #12]
 801e2cc:	60b9      	str	r1, [r7, #8]
 801e2ce:	607a      	str	r2, [r7, #4]
    int x;
    int ret = WC_NO_ERR_TRACE(NOT_COMPILED_IN);
 801e2d0:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 801e2d4:	613b      	str	r3, [r7, #16]
#ifdef HAVE_OID_ENCODING
    oid_cache_t* o = NULL;
#endif

    if (oidSum == 0) {
 801e2d6:	68fb      	ldr	r3, [r7, #12]
 801e2d8:	2b00      	cmp	r3, #0
 801e2da:	d102      	bne.n	801e2e2 <wc_ecc_get_oid+0x1e>
        return BAD_FUNC_ARG;
 801e2dc:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e2e0:	e03e      	b.n	801e360 <wc_ecc_get_oid+0x9c>
        return BAD_MUTEX_E;
    }
#endif

    /* find matching OID sum (based on encoded value) */
    for (x = 0; ecc_sets[x].size != 0; x++) {
 801e2e2:	2300      	movs	r3, #0
 801e2e4:	617b      	str	r3, [r7, #20]
 801e2e6:	e031      	b.n	801e34c <wc_ecc_get_oid+0x88>
        if (ecc_sets[x].oidSum == oidSum) {
 801e2e8:	4a20      	ldr	r2, [pc, #128]	@ (801e36c <wc_ecc_get_oid+0xa8>)
 801e2ea:	697b      	ldr	r3, [r7, #20]
 801e2ec:	2134      	movs	r1, #52	@ 0x34
 801e2ee:	fb01 f303 	mul.w	r3, r1, r3
 801e2f2:	4413      	add	r3, r2
 801e2f4:	332c      	adds	r3, #44	@ 0x2c
 801e2f6:	681b      	ldr	r3, [r3, #0]
 801e2f8:	68fa      	ldr	r2, [r7, #12]
 801e2fa:	429a      	cmp	r2, r3
 801e2fc:	d123      	bne.n	801e346 <wc_ecc_get_oid+0x82>
            if (ret == 0) {
                ret = ecc_sets[x].id;
            }
            break;
        #else
            if (oidSz) {
 801e2fe:	687b      	ldr	r3, [r7, #4]
 801e300:	2b00      	cmp	r3, #0
 801e302:	d009      	beq.n	801e318 <wc_ecc_get_oid+0x54>
                *oidSz = ecc_sets[x].oidSz;
 801e304:	4a19      	ldr	r2, [pc, #100]	@ (801e36c <wc_ecc_get_oid+0xa8>)
 801e306:	697b      	ldr	r3, [r7, #20]
 801e308:	2134      	movs	r1, #52	@ 0x34
 801e30a:	fb01 f303 	mul.w	r3, r1, r3
 801e30e:	4413      	add	r3, r2
 801e310:	3328      	adds	r3, #40	@ 0x28
 801e312:	681a      	ldr	r2, [r3, #0]
 801e314:	687b      	ldr	r3, [r7, #4]
 801e316:	601a      	str	r2, [r3, #0]
            }
            if (oid) {
 801e318:	68bb      	ldr	r3, [r7, #8]
 801e31a:	2b00      	cmp	r3, #0
 801e31c:	d009      	beq.n	801e332 <wc_ecc_get_oid+0x6e>
                *oid = ecc_sets[x].oid;
 801e31e:	4a13      	ldr	r2, [pc, #76]	@ (801e36c <wc_ecc_get_oid+0xa8>)
 801e320:	697b      	ldr	r3, [r7, #20]
 801e322:	2134      	movs	r1, #52	@ 0x34
 801e324:	fb01 f303 	mul.w	r3, r1, r3
 801e328:	4413      	add	r3, r2
 801e32a:	3324      	adds	r3, #36	@ 0x24
 801e32c:	681a      	ldr	r2, [r3, #0]
 801e32e:	68bb      	ldr	r3, [r7, #8]
 801e330:	601a      	str	r2, [r3, #0]
            }
            ret = ecc_sets[x].id;
 801e332:	4a0e      	ldr	r2, [pc, #56]	@ (801e36c <wc_ecc_get_oid+0xa8>)
 801e334:	697b      	ldr	r3, [r7, #20]
 801e336:	2134      	movs	r1, #52	@ 0x34
 801e338:	fb01 f303 	mul.w	r3, r1, r3
 801e33c:	4413      	add	r3, r2
 801e33e:	3304      	adds	r3, #4
 801e340:	681b      	ldr	r3, [r3, #0]
 801e342:	613b      	str	r3, [r7, #16]
            break;
 801e344:	e00b      	b.n	801e35e <wc_ecc_get_oid+0x9a>
    for (x = 0; ecc_sets[x].size != 0; x++) {
 801e346:	697b      	ldr	r3, [r7, #20]
 801e348:	3301      	adds	r3, #1
 801e34a:	617b      	str	r3, [r7, #20]
 801e34c:	4a07      	ldr	r2, [pc, #28]	@ (801e36c <wc_ecc_get_oid+0xa8>)
 801e34e:	697b      	ldr	r3, [r7, #20]
 801e350:	2134      	movs	r1, #52	@ 0x34
 801e352:	fb01 f303 	mul.w	r3, r1, r3
 801e356:	4413      	add	r3, r2
 801e358:	681b      	ldr	r3, [r3, #0]
 801e35a:	2b00      	cmp	r3, #0
 801e35c:	d1c4      	bne.n	801e2e8 <wc_ecc_get_oid+0x24>

#ifdef HAVE_OID_ENCODING
    wc_UnLockMutex(&ecc_oid_cache_lock);
#endif

    return ret;
 801e35e:	693b      	ldr	r3, [r7, #16]
}
 801e360:	4618      	mov	r0, r3
 801e362:	371c      	adds	r7, #28
 801e364:	46bd      	mov	sp, r7
 801e366:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e36a:	4770      	bx	lr
 801e36c:	080339ac 	.word	0x080339ac

0801e370 <wc_HashGetDigestSize>:

#ifndef NO_HASH_WRAPPER

/* Get Hash digest size */
int wc_HashGetDigestSize(enum wc_HashType hash_type)
{
 801e370:	b480      	push	{r7}
 801e372:	b085      	sub	sp, #20
 801e374:	af00      	add	r7, sp, #0
 801e376:	4603      	mov	r3, r0
 801e378:	71fb      	strb	r3, [r7, #7]
    int dig_size = WC_NO_ERR_TRACE(HASH_TYPE_E);
 801e37a:	f06f 03e7 	mvn.w	r3, #231	@ 0xe7
 801e37e:	60fb      	str	r3, [r7, #12]
    switch(hash_type)
 801e380:	79fb      	ldrb	r3, [r7, #7]
 801e382:	3b01      	subs	r3, #1
 801e384:	2b10      	cmp	r3, #16
 801e386:	d828      	bhi.n	801e3da <wc_HashGetDigestSize+0x6a>
 801e388:	a201      	add	r2, pc, #4	@ (adr r2, 801e390 <wc_HashGetDigestSize+0x20>)
 801e38a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e38e:	bf00      	nop
 801e390:	0801e3e3 	.word	0x0801e3e3
 801e394:	0801e3e3 	.word	0x0801e3e3
 801e398:	0801e3e3 	.word	0x0801e3e3
 801e39c:	0801e3e3 	.word	0x0801e3e3
 801e3a0:	0801e3e3 	.word	0x0801e3e3
 801e3a4:	0801e3d5 	.word	0x0801e3d5
 801e3a8:	0801e3e3 	.word	0x0801e3e3
 801e3ac:	0801e3e3 	.word	0x0801e3e3
 801e3b0:	0801e3e3 	.word	0x0801e3e3
 801e3b4:	0801e3e3 	.word	0x0801e3e3
 801e3b8:	0801e3e3 	.word	0x0801e3e3
 801e3bc:	0801e3e3 	.word	0x0801e3e3
 801e3c0:	0801e3e3 	.word	0x0801e3e3
 801e3c4:	0801e3e3 	.word	0x0801e3e3
 801e3c8:	0801e3e3 	.word	0x0801e3e3
 801e3cc:	0801e3e3 	.word	0x0801e3e3
 801e3d0:	0801e3e3 	.word	0x0801e3e3
            dig_size = WC_SHA224_DIGEST_SIZE;
        #endif
            break;
        case WC_HASH_TYPE_SHA256:
        #ifndef NO_SHA256
            dig_size = WC_SHA256_DIGEST_SIZE;
 801e3d4:	2320      	movs	r3, #32
 801e3d6:	60fb      	str	r3, [r7, #12]
        #endif
            break;
 801e3d8:	e004      	b.n	801e3e4 <wc_HashGetDigestSize+0x74>
    #if defined(WOLFSSL_SHA3) && defined(WOLFSSL_SHAKE256)
        case WC_HASH_TYPE_SHAKE256:
    #endif
        case WC_HASH_TYPE_NONE:
        default:
            dig_size = BAD_FUNC_ARG;
 801e3da:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e3de:	60fb      	str	r3, [r7, #12]
            break;
 801e3e0:	e000      	b.n	801e3e4 <wc_HashGetDigestSize+0x74>
            break;
 801e3e2:	bf00      	nop
    }
    return dig_size;
 801e3e4:	68fb      	ldr	r3, [r7, #12]
}
 801e3e6:	4618      	mov	r0, r3
 801e3e8:	3714      	adds	r7, #20
 801e3ea:	46bd      	mov	sp, r7
 801e3ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e3f0:	4770      	bx	lr
 801e3f2:	bf00      	nop

0801e3f4 <wc_Hash_ex>:
}

/* Generic Hashing Wrapper */
int wc_Hash_ex(enum wc_HashType hash_type, const byte* data,
    word32 data_len, byte* hash, word32 hash_len, void* heap, int devId)
{
 801e3f4:	b580      	push	{r7, lr}
 801e3f6:	b088      	sub	sp, #32
 801e3f8:	af02      	add	r7, sp, #8
 801e3fa:	60b9      	str	r1, [r7, #8]
 801e3fc:	607a      	str	r2, [r7, #4]
 801e3fe:	603b      	str	r3, [r7, #0]
 801e400:	4603      	mov	r3, r0
 801e402:	73fb      	strb	r3, [r7, #15]
    int ret = WC_NO_ERR_TRACE(HASH_TYPE_E); /* Default to hash type error */
 801e404:	f06f 03e7 	mvn.w	r3, #231	@ 0xe7
 801e408:	617b      	str	r3, [r7, #20]
    int dig_size;

    /* Validate hash buffer size */
    dig_size = wc_HashGetDigestSize(hash_type);
 801e40a:	7bfb      	ldrb	r3, [r7, #15]
 801e40c:	4618      	mov	r0, r3
 801e40e:	f7ff ffaf 	bl	801e370 <wc_HashGetDigestSize>
 801e412:	6138      	str	r0, [r7, #16]
    if (dig_size < 0) {
 801e414:	693b      	ldr	r3, [r7, #16]
 801e416:	2b00      	cmp	r3, #0
 801e418:	da01      	bge.n	801e41e <wc_Hash_ex+0x2a>
        return dig_size;
 801e41a:	693b      	ldr	r3, [r7, #16]
 801e41c:	e03c      	b.n	801e498 <wc_Hash_ex+0xa4>
    }

    if (hash_len < (word32)dig_size) {
 801e41e:	693b      	ldr	r3, [r7, #16]
 801e420:	6a3a      	ldr	r2, [r7, #32]
 801e422:	429a      	cmp	r2, r3
 801e424:	d202      	bcs.n	801e42c <wc_Hash_ex+0x38>
        return BUFFER_E;
 801e426:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 801e42a:	e035      	b.n	801e498 <wc_Hash_ex+0xa4>
    (void)data;
    (void)data_len;
    (void)hash;
    (void)hash_len;

    switch(hash_type)
 801e42c:	7bfb      	ldrb	r3, [r7, #15]
 801e42e:	3b03      	subs	r3, #3
 801e430:	2b0e      	cmp	r3, #14
 801e432:	d82b      	bhi.n	801e48c <wc_Hash_ex+0x98>
 801e434:	a201      	add	r2, pc, #4	@ (adr r2, 801e43c <wc_Hash_ex+0x48>)
 801e436:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e43a:	bf00      	nop
 801e43c:	0801e495 	.word	0x0801e495
 801e440:	0801e495 	.word	0x0801e495
 801e444:	0801e495 	.word	0x0801e495
 801e448:	0801e479 	.word	0x0801e479
 801e44c:	0801e495 	.word	0x0801e495
 801e450:	0801e495 	.word	0x0801e495
 801e454:	0801e495 	.word	0x0801e495
 801e458:	0801e495 	.word	0x0801e495
 801e45c:	0801e495 	.word	0x0801e495
 801e460:	0801e495 	.word	0x0801e495
 801e464:	0801e495 	.word	0x0801e495
 801e468:	0801e48d 	.word	0x0801e48d
 801e46c:	0801e48d 	.word	0x0801e48d
 801e470:	0801e495 	.word	0x0801e495
 801e474:	0801e495 	.word	0x0801e495
            ret = wc_Sha224Hash_ex(data, data_len, hash, heap, devId);
#endif
            break;
        case WC_HASH_TYPE_SHA256:
#ifndef NO_SHA256
            ret = wc_Sha256Hash_ex(data, data_len, hash, heap, devId);
 801e478:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e47a:	9300      	str	r3, [sp, #0]
 801e47c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e47e:	683a      	ldr	r2, [r7, #0]
 801e480:	6879      	ldr	r1, [r7, #4]
 801e482:	68b8      	ldr	r0, [r7, #8]
 801e484:	f000 f826 	bl	801e4d4 <wc_Sha256Hash_ex>
 801e488:	6178      	str	r0, [r7, #20]
#endif
            break;
 801e48a:	e004      	b.n	801e496 <wc_Hash_ex+0xa2>
    #if defined(WOLFSSL_SHA3) && defined(WOLFSSL_SHAKE256)
        case WC_HASH_TYPE_SHAKE256:
    #endif
        case WC_HASH_TYPE_NONE:
        default:
            ret = BAD_FUNC_ARG;
 801e48c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e490:	617b      	str	r3, [r7, #20]
            break;
 801e492:	e000      	b.n	801e496 <wc_Hash_ex+0xa2>
            break;
 801e494:	bf00      	nop
    }
    return ret;
 801e496:	697b      	ldr	r3, [r7, #20]
}
 801e498:	4618      	mov	r0, r3
 801e49a:	3718      	adds	r7, #24
 801e49c:	46bd      	mov	sp, r7
 801e49e:	bd80      	pop	{r7, pc}

0801e4a0 <wc_Hash>:
int wc_Hash(enum wc_HashType hash_type, const byte* data,
    word32 data_len, byte* hash, word32 hash_len)
{
 801e4a0:	b580      	push	{r7, lr}
 801e4a2:	b088      	sub	sp, #32
 801e4a4:	af04      	add	r7, sp, #16
 801e4a6:	60b9      	str	r1, [r7, #8]
 801e4a8:	607a      	str	r2, [r7, #4]
 801e4aa:	603b      	str	r3, [r7, #0]
 801e4ac:	4603      	mov	r3, r0
 801e4ae:	73fb      	strb	r3, [r7, #15]
    return wc_Hash_ex(hash_type, data, data_len, hash, hash_len,
 801e4b0:	7bf8      	ldrb	r0, [r7, #15]
 801e4b2:	f06f 0301 	mvn.w	r3, #1
 801e4b6:	9302      	str	r3, [sp, #8]
 801e4b8:	2300      	movs	r3, #0
 801e4ba:	9301      	str	r3, [sp, #4]
 801e4bc:	69bb      	ldr	r3, [r7, #24]
 801e4be:	9300      	str	r3, [sp, #0]
 801e4c0:	683b      	ldr	r3, [r7, #0]
 801e4c2:	687a      	ldr	r2, [r7, #4]
 801e4c4:	68b9      	ldr	r1, [r7, #8]
 801e4c6:	f7ff ff95 	bl	801e3f4 <wc_Hash_ex>
 801e4ca:	4603      	mov	r3, r0
        NULL, INVALID_DEVID);
}
 801e4cc:	4618      	mov	r0, r3
 801e4ce:	3710      	adds	r7, #16
 801e4d0:	46bd      	mov	sp, r7
 801e4d2:	bd80      	pop	{r7, pc}

0801e4d4 <wc_Sha256Hash_ex>:
#endif /* WOLFSSL_SHA224 */

#if !defined(NO_SHA256)
    int wc_Sha256Hash_ex(const byte* data, word32 len, byte* hash,
        void* heap, int devId)
    {
 801e4d4:	b580      	push	{r7, lr}
 801e4d6:	b088      	sub	sp, #32
 801e4d8:	af00      	add	r7, sp, #0
 801e4da:	60f8      	str	r0, [r7, #12]
 801e4dc:	60b9      	str	r1, [r7, #8]
 801e4de:	607a      	str	r2, [r7, #4]
 801e4e0:	603b      	str	r3, [r7, #0]
        int ret = 0;
 801e4e2:	2300      	movs	r3, #0
 801e4e4:	61fb      	str	r3, [r7, #28]
    #else
        wc_Sha256 sha256[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        sha256 = (wc_Sha256*)XMALLOC(sizeof(wc_Sha256), NULL,
 801e4e6:	2070      	movs	r0, #112	@ 0x70
 801e4e8:	f000 fad4 	bl	801ea94 <wolfSSL_Malloc>
 801e4ec:	61b8      	str	r0, [r7, #24]
            DYNAMIC_TYPE_TMP_BUFFER);
        if (sha256 == NULL)
 801e4ee:	69bb      	ldr	r3, [r7, #24]
 801e4f0:	2b00      	cmp	r3, #0
 801e4f2:	d102      	bne.n	801e4fa <wc_Sha256Hash_ex+0x26>
            return MEMORY_E;
 801e4f4:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e4f8:	e022      	b.n	801e540 <wc_Sha256Hash_ex+0x6c>
    #endif

        if ((ret = wc_InitSha256_ex(sha256, heap, devId)) != 0) {
 801e4fa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801e4fc:	6839      	ldr	r1, [r7, #0]
 801e4fe:	69b8      	ldr	r0, [r7, #24]
 801e500:	f003 f86c 	bl	80215dc <wc_InitSha256_ex>
 801e504:	61f8      	str	r0, [r7, #28]
 801e506:	69fb      	ldr	r3, [r7, #28]
 801e508:	2b00      	cmp	r3, #0
 801e50a:	d110      	bne.n	801e52e <wc_Sha256Hash_ex+0x5a>
            WOLFSSL_MSG("InitSha256 failed");
        }
        else {
            if ((ret = wc_Sha256Update(sha256, data, len)) != 0) {
 801e50c:	68ba      	ldr	r2, [r7, #8]
 801e50e:	68f9      	ldr	r1, [r7, #12]
 801e510:	69b8      	ldr	r0, [r7, #24]
 801e512:	f003 fca6 	bl	8021e62 <wc_Sha256Update>
 801e516:	61f8      	str	r0, [r7, #28]
 801e518:	69fb      	ldr	r3, [r7, #28]
 801e51a:	2b00      	cmp	r3, #0
 801e51c:	d104      	bne.n	801e528 <wc_Sha256Hash_ex+0x54>
                WOLFSSL_MSG("Sha256Update failed");
            }
            else if ((ret = wc_Sha256Final(sha256, hash)) != 0) {
 801e51e:	6879      	ldr	r1, [r7, #4]
 801e520:	69b8      	ldr	r0, [r7, #24]
 801e522:	f003 fd3c 	bl	8021f9e <wc_Sha256Final>
 801e526:	61f8      	str	r0, [r7, #28]
                WOLFSSL_MSG("Sha256Final failed");
            }
            wc_Sha256Free(sha256);
 801e528:	69b8      	ldr	r0, [r7, #24]
 801e52a:	f003 fd74 	bl	8022016 <wc_Sha256Free>
        }


    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha256, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 801e52e:	69bb      	ldr	r3, [r7, #24]
 801e530:	617b      	str	r3, [r7, #20]
 801e532:	697b      	ldr	r3, [r7, #20]
 801e534:	2b00      	cmp	r3, #0
 801e536:	d002      	beq.n	801e53e <wc_Sha256Hash_ex+0x6a>
 801e538:	6978      	ldr	r0, [r7, #20]
 801e53a:	f000 fac7 	bl	801eacc <wolfSSL_Free>
    #endif

        return ret;
 801e53e:	69fb      	ldr	r3, [r7, #28]
    }
 801e540:	4618      	mov	r0, r3
 801e542:	3720      	adds	r7, #32
 801e544:	46bd      	mov	sp, r7
 801e546:	bd80      	pop	{r7, pc}

0801e548 <wc_Sha256Hash>:
    int wc_Sha256Hash(const byte* data, word32 len, byte* hash)
    {
 801e548:	b580      	push	{r7, lr}
 801e54a:	b088      	sub	sp, #32
 801e54c:	af02      	add	r7, sp, #8
 801e54e:	60f8      	str	r0, [r7, #12]
 801e550:	60b9      	str	r1, [r7, #8]
 801e552:	607a      	str	r2, [r7, #4]
        int devId = INVALID_DEVID;
 801e554:	f06f 0301 	mvn.w	r3, #1
 801e558:	617b      	str	r3, [r7, #20]
        /* find devId if its not an empty hash */
        if (data != NULL && len > 0) {
            devId = wc_CryptoCb_DefaultDevID();
        }
    #endif
        return wc_Sha256Hash_ex(data, len, hash, NULL, devId);
 801e55a:	697b      	ldr	r3, [r7, #20]
 801e55c:	9300      	str	r3, [sp, #0]
 801e55e:	2300      	movs	r3, #0
 801e560:	687a      	ldr	r2, [r7, #4]
 801e562:	68b9      	ldr	r1, [r7, #8]
 801e564:	68f8      	ldr	r0, [r7, #12]
 801e566:	f7ff ffb5 	bl	801e4d4 <wc_Sha256Hash_ex>
 801e56a:	4603      	mov	r3, r0
    }
 801e56c:	4618      	mov	r0, r3
 801e56e:	3718      	adds	r7, #24
 801e570:	46bd      	mov	sp, r7
 801e572:	bd80      	pop	{r7, pc}

0801e574 <ForceZero>:
{
 801e574:	b480      	push	{r7}
 801e576:	b085      	sub	sp, #20
 801e578:	af00      	add	r7, sp, #0
 801e57a:	6078      	str	r0, [r7, #4]
 801e57c:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801e57e:	687b      	ldr	r3, [r7, #4]
 801e580:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801e582:	e004      	b.n	801e58e <ForceZero+0x1a>
 801e584:	68fb      	ldr	r3, [r7, #12]
 801e586:	1c5a      	adds	r2, r3, #1
 801e588:	60fa      	str	r2, [r7, #12]
 801e58a:	2200      	movs	r2, #0
 801e58c:	701a      	strb	r2, [r3, #0]
 801e58e:	683b      	ldr	r3, [r7, #0]
 801e590:	1e5a      	subs	r2, r3, #1
 801e592:	603a      	str	r2, [r7, #0]
 801e594:	2b00      	cmp	r3, #0
 801e596:	d1f5      	bne.n	801e584 <ForceZero+0x10>
}
 801e598:	bf00      	nop
 801e59a:	bf00      	nop
 801e59c:	3714      	adds	r7, #20
 801e59e:	46bd      	mov	sp, r7
 801e5a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e5a4:	4770      	bx	lr

0801e5a6 <wc_HmacFree>:
}
#endif /* WOLF_PRIVATE_KEY_ID */

/* Free Hmac from use with async device */
void wc_HmacFree(Hmac* hmac)
{
 801e5a6:	b580      	push	{r7, lr}
 801e5a8:	b082      	sub	sp, #8
 801e5aa:	af00      	add	r7, sp, #0
 801e5ac:	6078      	str	r0, [r7, #4]
    if (hmac == NULL)
 801e5ae:	687b      	ldr	r3, [r7, #4]
 801e5b0:	2b00      	cmp	r3, #0
 801e5b2:	d010      	beq.n	801e5d6 <wc_HmacFree+0x30>

#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_HMAC)
    wolfAsync_DevCtxFree(&hmac->asyncDev, WOLFSSL_ASYNC_MARKER_HMAC);
#endif /* WOLFSSL_ASYNC_CRYPT */

    switch (hmac->macType) {
 801e5b4:	687b      	ldr	r3, [r7, #4]
 801e5b6:	f893 3114 	ldrb.w	r3, [r3, #276]	@ 0x114
 801e5ba:	2b06      	cmp	r3, #6
 801e5bc:	d104      	bne.n	801e5c8 <wc_HmacFree+0x22>
            wc_Sha224Free(&hmac->hash.sha224);
            break;
    #endif /* WOLFSSL_SHA224 */
    #ifndef NO_SHA256
        case WC_SHA256:
            wc_Sha256Free(&hmac->hash.sha256);
 801e5be:	687b      	ldr	r3, [r7, #4]
 801e5c0:	4618      	mov	r0, r3
 801e5c2:	f003 fd28 	bl	8022016 <wc_Sha256Free>
            break;
 801e5c6:	e000      	b.n	801e5ca <wc_HmacFree+0x24>
            wc_Sm3Free(&hmac->hash.sm3);
            break;
    #endif

        default:
            break;
 801e5c8:	bf00      	nop
    }

    ForceZero(hmac, sizeof(*hmac));
 801e5ca:	f44f 718c 	mov.w	r1, #280	@ 0x118
 801e5ce:	6878      	ldr	r0, [r7, #4]
 801e5d0:	f7ff ffd0 	bl	801e574 <ForceZero>
 801e5d4:	e000      	b.n	801e5d8 <wc_HmacFree+0x32>
        return;
 801e5d6:	bf00      	nop
}
 801e5d8:	3708      	adds	r7, #8
 801e5da:	46bd      	mov	sp, r7
 801e5dc:	bd80      	pop	{r7, pc}
	...

0801e5e0 <wc_LoggingInit>:
#define ERRQ_LOCK()            wc_LockMutex(&wc_error_mutex)
#define ERRQ_UNLOCK()          wc_UnLockMutex(&wc_error_mutex)

/* Internal function that is called by wolfCrypt_Init() */
int wc_LoggingInit(void)
{
 801e5e0:	b580      	push	{r7, lr}
 801e5e2:	af00      	add	r7, sp, #0
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (ERRQ_MUTEX_INIT() != 0) {
 801e5e4:	480b      	ldr	r0, [pc, #44]	@ (801e614 <wc_LoggingInit+0x34>)
 801e5e6:	f008 fecf 	bl	8027388 <wc_InitMutex>
 801e5ea:	4603      	mov	r3, r0
 801e5ec:	2b00      	cmp	r3, #0
 801e5ee:	d002      	beq.n	801e5f6 <wc_LoggingInit+0x16>
        WOLFSSL_MSG("Bad Init Mutex");
        return BAD_MUTEX_E;
 801e5f0:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 801e5f4:	e00c      	b.n	801e610 <wc_LoggingInit+0x30>
    }
#endif
    wc_errors_count = 0;
 801e5f6:	4b08      	ldr	r3, [pc, #32]	@ (801e618 <wc_LoggingInit+0x38>)
 801e5f8:	2200      	movs	r2, #0
 801e5fa:	601a      	str	r2, [r3, #0]
    wc_errors          = NULL;
 801e5fc:	4b07      	ldr	r3, [pc, #28]	@ (801e61c <wc_LoggingInit+0x3c>)
 801e5fe:	2200      	movs	r2, #0
 801e600:	601a      	str	r2, [r3, #0]
    wc_current_node    = NULL;
 801e602:	4b07      	ldr	r3, [pc, #28]	@ (801e620 <wc_LoggingInit+0x40>)
 801e604:	2200      	movs	r2, #0
 801e606:	601a      	str	r2, [r3, #0]
    wc_last_node       = NULL;
 801e608:	4b06      	ldr	r3, [pc, #24]	@ (801e624 <wc_LoggingInit+0x44>)
 801e60a:	2200      	movs	r2, #0
 801e60c:	601a      	str	r2, [r3, #0]
    return 0;
 801e60e:	2300      	movs	r3, #0
}
 801e610:	4618      	mov	r0, r3
 801e612:	bd80      	pop	{r7, pc}
 801e614:	20002704 	.word	0x20002704
 801e618:	200026f4 	.word	0x200026f4
 801e61c:	200026f0 	.word	0x200026f0
 801e620:	200026fc 	.word	0x200026fc
 801e624:	200026f8 	.word	0x200026f8

0801e628 <wc_LoggingCleanup>:


/* internal function that is called by wolfCrypt_Cleanup */
int wc_LoggingCleanup(void)
{
 801e628:	b580      	push	{r7, lr}
 801e62a:	af00      	add	r7, sp, #0
    /* clear logging entries */
    wc_ClearErrorNodes();
 801e62c:	f000 f9d4 	bl	801e9d8 <wc_ClearErrorNodes>
    /* free mutex */
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (ERRQ_MUTEX_FREE() != 0) {
 801e630:	4805      	ldr	r0, [pc, #20]	@ (801e648 <wc_LoggingCleanup+0x20>)
 801e632:	f008 feb4 	bl	802739e <wc_FreeMutex>
 801e636:	4603      	mov	r3, r0
 801e638:	2b00      	cmp	r3, #0
 801e63a:	d002      	beq.n	801e642 <wc_LoggingCleanup+0x1a>
        WOLFSSL_MSG("Bad Mutex free");
        return BAD_MUTEX_E;
 801e63c:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 801e640:	e000      	b.n	801e644 <wc_LoggingCleanup+0x1c>
    }
#endif
    return 0;
 801e642:	2300      	movs	r3, #0
}
 801e644:	4618      	mov	r0, r3
 801e646:	bd80      	pop	{r7, pc}
 801e648:	20002704 	.word	0x20002704

0801e64c <peekErrorNode>:

static int peekErrorNode(int idx, const char **file, const char **reason,
        int *line)
{
 801e64c:	b480      	push	{r7}
 801e64e:	b087      	sub	sp, #28
 801e650:	af00      	add	r7, sp, #0
 801e652:	60f8      	str	r0, [r7, #12]
 801e654:	60b9      	str	r1, [r7, #8]
 801e656:	607a      	str	r2, [r7, #4]
 801e658:	603b      	str	r3, [r7, #0]
    struct wc_error_queue* err;

    if (idx < 0) {
 801e65a:	68fb      	ldr	r3, [r7, #12]
 801e65c:	2b00      	cmp	r3, #0
 801e65e:	da03      	bge.n	801e668 <peekErrorNode+0x1c>
        err = wc_last_node;
 801e660:	4b20      	ldr	r3, [pc, #128]	@ (801e6e4 <peekErrorNode+0x98>)
 801e662:	681b      	ldr	r3, [r3, #0]
 801e664:	617b      	str	r3, [r7, #20]
 801e666:	e015      	b.n	801e694 <peekErrorNode+0x48>
    }
    else {
        int i;

        err = (struct wc_error_queue*)wc_errors;
 801e668:	4b1f      	ldr	r3, [pc, #124]	@ (801e6e8 <peekErrorNode+0x9c>)
 801e66a:	681b      	ldr	r3, [r3, #0]
 801e66c:	617b      	str	r3, [r7, #20]
        for (i = 0; i < idx; i++) {
 801e66e:	2300      	movs	r3, #0
 801e670:	613b      	str	r3, [r7, #16]
 801e672:	e00b      	b.n	801e68c <peekErrorNode+0x40>
            if (err == NULL) {
 801e674:	697b      	ldr	r3, [r7, #20]
 801e676:	2b00      	cmp	r3, #0
 801e678:	d102      	bne.n	801e680 <peekErrorNode+0x34>
                WOLFSSL_MSG("Error node not found. Bad index?");
                return BAD_FUNC_ARG;
 801e67a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801e67e:	e02a      	b.n	801e6d6 <peekErrorNode+0x8a>
            }
            err = err->next;
 801e680:	697b      	ldr	r3, [r7, #20]
 801e682:	685b      	ldr	r3, [r3, #4]
 801e684:	617b      	str	r3, [r7, #20]
        for (i = 0; i < idx; i++) {
 801e686:	693b      	ldr	r3, [r7, #16]
 801e688:	3301      	adds	r3, #1
 801e68a:	613b      	str	r3, [r7, #16]
 801e68c:	693a      	ldr	r2, [r7, #16]
 801e68e:	68fb      	ldr	r3, [r7, #12]
 801e690:	429a      	cmp	r2, r3
 801e692:	dbef      	blt.n	801e674 <peekErrorNode+0x28>
        }
    }

    if (err == NULL) {
 801e694:	697b      	ldr	r3, [r7, #20]
 801e696:	2b00      	cmp	r3, #0
 801e698:	d102      	bne.n	801e6a0 <peekErrorNode+0x54>
        WOLFSSL_MSG("No Errors in queue");
        return BAD_STATE_E;
 801e69a:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 801e69e:	e01a      	b.n	801e6d6 <peekErrorNode+0x8a>
    }

    if (file != NULL) {
 801e6a0:	68bb      	ldr	r3, [r7, #8]
 801e6a2:	2b00      	cmp	r3, #0
 801e6a4:	d004      	beq.n	801e6b0 <peekErrorNode+0x64>
        *file = err->file;
 801e6a6:	697b      	ldr	r3, [r7, #20]
 801e6a8:	f103 025c 	add.w	r2, r3, #92	@ 0x5c
 801e6ac:	68bb      	ldr	r3, [r7, #8]
 801e6ae:	601a      	str	r2, [r3, #0]
    }
    if (reason != NULL) {
 801e6b0:	687b      	ldr	r3, [r7, #4]
 801e6b2:	2b00      	cmp	r3, #0
 801e6b4:	d004      	beq.n	801e6c0 <peekErrorNode+0x74>
        *reason = err->error;
 801e6b6:	697b      	ldr	r3, [r7, #20]
 801e6b8:	f103 020c 	add.w	r2, r3, #12
 801e6bc:	687b      	ldr	r3, [r7, #4]
 801e6be:	601a      	str	r2, [r3, #0]
    }
    if (line != NULL) {
 801e6c0:	683b      	ldr	r3, [r7, #0]
 801e6c2:	2b00      	cmp	r3, #0
 801e6c4:	d004      	beq.n	801e6d0 <peekErrorNode+0x84>
        *line = err->line;
 801e6c6:	697b      	ldr	r3, [r7, #20]
 801e6c8:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
 801e6cc:	683b      	ldr	r3, [r7, #0]
 801e6ce:	601a      	str	r2, [r3, #0]
    }

    return err->value;
 801e6d0:	697b      	ldr	r3, [r7, #20]
 801e6d2:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
}
 801e6d6:	4618      	mov	r0, r3
 801e6d8:	371c      	adds	r7, #28
 801e6da:	46bd      	mov	sp, r7
 801e6dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e6e0:	4770      	bx	lr
 801e6e2:	bf00      	nop
 801e6e4:	200026f8 	.word	0x200026f8
 801e6e8:	200026f0 	.word	0x200026f0

0801e6ec <wc_PeekErrorNode>:
 * Returns a negative value in error case, on success returns the nodes error
 * value which is positive (absolute value)
 */
int wc_PeekErrorNode(int idx, const char **file, const char **reason,
        int *line)
{
 801e6ec:	b580      	push	{r7, lr}
 801e6ee:	b086      	sub	sp, #24
 801e6f0:	af00      	add	r7, sp, #0
 801e6f2:	60f8      	str	r0, [r7, #12]
 801e6f4:	60b9      	str	r1, [r7, #8]
 801e6f6:	607a      	str	r2, [r7, #4]
 801e6f8:	603b      	str	r3, [r7, #0]
    int ret;

    if (ERRQ_LOCK() != 0) {
 801e6fa:	480c      	ldr	r0, [pc, #48]	@ (801e72c <wc_PeekErrorNode+0x40>)
 801e6fc:	f008 fe5a 	bl	80273b4 <wc_LockMutex>
 801e700:	4603      	mov	r3, r0
 801e702:	2b00      	cmp	r3, #0
 801e704:	d002      	beq.n	801e70c <wc_PeekErrorNode+0x20>
        WOLFSSL_MSG("Lock debug mutex failed");
        return BAD_MUTEX_E;
 801e706:	f06f 0369 	mvn.w	r3, #105	@ 0x69
 801e70a:	e00a      	b.n	801e722 <wc_PeekErrorNode+0x36>
    }
    ret = peekErrorNode(idx, file, reason, line);
 801e70c:	683b      	ldr	r3, [r7, #0]
 801e70e:	687a      	ldr	r2, [r7, #4]
 801e710:	68b9      	ldr	r1, [r7, #8]
 801e712:	68f8      	ldr	r0, [r7, #12]
 801e714:	f7ff ff9a 	bl	801e64c <peekErrorNode>
 801e718:	6178      	str	r0, [r7, #20]
    ERRQ_UNLOCK();
 801e71a:	4804      	ldr	r0, [pc, #16]	@ (801e72c <wc_PeekErrorNode+0x40>)
 801e71c:	f008 fe55 	bl	80273ca <wc_UnLockMutex>
    return ret;
 801e720:	697b      	ldr	r3, [r7, #20]
}
 801e722:	4618      	mov	r0, r3
 801e724:	3718      	adds	r7, #24
 801e726:	46bd      	mov	sp, r7
 801e728:	bd80      	pop	{r7, pc}
 801e72a:	bf00      	nop
 801e72c:	20002704 	.word	0x20002704

0801e730 <wc_AddErrorNode>:

/* create new error node and add it to the queue
 * buffers are assumed to be of size WOLFSSL_MAX_ERROR_SZ for this internal
 * function. */
int wc_AddErrorNode(int error, int line, char* buf, char* file)
{
 801e730:	b580      	push	{r7, lr}
 801e732:	b088      	sub	sp, #32
 801e734:	af00      	add	r7, sp, #0
 801e736:	60f8      	str	r0, [r7, #12]
 801e738:	60b9      	str	r1, [r7, #8]
 801e73a:	607a      	str	r2, [r7, #4]
 801e73c:	603b      	str	r3, [r7, #0]
    struct wc_error_queue* err;

    if (wc_errors_count >= ERROR_QUEUE_MAX) {
 801e73e:	4b44      	ldr	r3, [pc, #272]	@ (801e850 <wc_AddErrorNode+0x120>)
 801e740:	681b      	ldr	r3, [r3, #0]
 801e742:	2b63      	cmp	r3, #99	@ 0x63
 801e744:	dd02      	ble.n	801e74c <wc_AddErrorNode+0x1c>
        WOLFSSL_MSG("Error queue is full, at ERROR_QUEUE_MAX");
        return MEMORY_E;
 801e746:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e74a:	e07d      	b.n	801e848 <wc_AddErrorNode+0x118>
    }

    err = (struct wc_error_queue*)XMALLOC(
 801e74c:	20b4      	movs	r0, #180	@ 0xb4
 801e74e:	f000 f9a1 	bl	801ea94 <wolfSSL_Malloc>
 801e752:	61b8      	str	r0, [r7, #24]
            sizeof(struct wc_error_queue), wc_error_heap, DYNAMIC_TYPE_LOG);
    if (err == NULL) {
 801e754:	69bb      	ldr	r3, [r7, #24]
 801e756:	2b00      	cmp	r3, #0
 801e758:	d102      	bne.n	801e760 <wc_AddErrorNode+0x30>
        WOLFSSL_MSG("Unable to create error node for log");
        return MEMORY_E;
 801e75a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801e75e:	e073      	b.n	801e848 <wc_AddErrorNode+0x118>
    }
    else {
        int sz;

        XMEMSET(err, 0, sizeof(struct wc_error_queue));
 801e760:	22b4      	movs	r2, #180	@ 0xb4
 801e762:	2100      	movs	r1, #0
 801e764:	69b8      	ldr	r0, [r7, #24]
 801e766:	f009 feb3 	bl	80284d0 <memset>
        err->heap = wc_error_heap;
 801e76a:	4b3a      	ldr	r3, [pc, #232]	@ (801e854 <wc_AddErrorNode+0x124>)
 801e76c:	681a      	ldr	r2, [r3, #0]
 801e76e:	69bb      	ldr	r3, [r7, #24]
 801e770:	601a      	str	r2, [r3, #0]
        sz = (int)XSTRLEN(buf);
 801e772:	6878      	ldr	r0, [r7, #4]
 801e774:	f7e1 fd36 	bl	80001e4 <strlen>
 801e778:	4603      	mov	r3, r0
 801e77a:	61fb      	str	r3, [r7, #28]
        if (sz > WOLFSSL_MAX_ERROR_SZ - 1) {
 801e77c:	69fb      	ldr	r3, [r7, #28]
 801e77e:	2b4f      	cmp	r3, #79	@ 0x4f
 801e780:	dd01      	ble.n	801e786 <wc_AddErrorNode+0x56>
            sz = WOLFSSL_MAX_ERROR_SZ - 1;
 801e782:	234f      	movs	r3, #79	@ 0x4f
 801e784:	61fb      	str	r3, [r7, #28]
        }
        if (sz > 0) {
 801e786:	69fb      	ldr	r3, [r7, #28]
 801e788:	2b00      	cmp	r3, #0
 801e78a:	dd06      	ble.n	801e79a <wc_AddErrorNode+0x6a>
            XMEMCPY(err->error, buf, sz);
 801e78c:	69bb      	ldr	r3, [r7, #24]
 801e78e:	330c      	adds	r3, #12
 801e790:	69fa      	ldr	r2, [r7, #28]
 801e792:	6879      	ldr	r1, [r7, #4]
 801e794:	4618      	mov	r0, r3
 801e796:	f009 ff05 	bl	80285a4 <memcpy>
        }

        sz = (int)XSTRLEN(file);
 801e79a:	6838      	ldr	r0, [r7, #0]
 801e79c:	f7e1 fd22 	bl	80001e4 <strlen>
 801e7a0:	4603      	mov	r3, r0
 801e7a2:	61fb      	str	r3, [r7, #28]
        if (sz > WOLFSSL_MAX_ERROR_SZ - 1) {
 801e7a4:	69fb      	ldr	r3, [r7, #28]
 801e7a6:	2b4f      	cmp	r3, #79	@ 0x4f
 801e7a8:	dd01      	ble.n	801e7ae <wc_AddErrorNode+0x7e>
            sz = WOLFSSL_MAX_ERROR_SZ - 1;
 801e7aa:	234f      	movs	r3, #79	@ 0x4f
 801e7ac:	61fb      	str	r3, [r7, #28]
        }
        if (sz > 0) {
 801e7ae:	69fb      	ldr	r3, [r7, #28]
 801e7b0:	2b00      	cmp	r3, #0
 801e7b2:	dd06      	ble.n	801e7c2 <wc_AddErrorNode+0x92>
            XMEMCPY(err->file, file, sz);
 801e7b4:	69bb      	ldr	r3, [r7, #24]
 801e7b6:	335c      	adds	r3, #92	@ 0x5c
 801e7b8:	69fa      	ldr	r2, [r7, #28]
 801e7ba:	6839      	ldr	r1, [r7, #0]
 801e7bc:	4618      	mov	r0, r3
 801e7be:	f009 fef1 	bl	80285a4 <memcpy>
        }

        err->value = error;
 801e7c2:	69bb      	ldr	r3, [r7, #24]
 801e7c4:	68fa      	ldr	r2, [r7, #12]
 801e7c6:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
        err->line  = line;
 801e7ca:	69bb      	ldr	r3, [r7, #24]
 801e7cc:	68ba      	ldr	r2, [r7, #8]
 801e7ce:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

        /* make sure is terminated */
        err->error[WOLFSSL_MAX_ERROR_SZ - 1] = '\0';
 801e7d2:	69bb      	ldr	r3, [r7, #24]
 801e7d4:	2200      	movs	r2, #0
 801e7d6:	f883 205b 	strb.w	r2, [r3, #91]	@ 0x5b
        err->file[WOLFSSL_MAX_ERROR_SZ - 1]  = '\0';
 801e7da:	69bb      	ldr	r3, [r7, #24]
 801e7dc:	2200      	movs	r2, #0
 801e7de:	f883 20ab 	strb.w	r2, [r3, #171]	@ 0xab


        /* since is queue place new node at last of the list */
        if (wc_last_node == NULL) {
 801e7e2:	4b1d      	ldr	r3, [pc, #116]	@ (801e858 <wc_AddErrorNode+0x128>)
 801e7e4:	681b      	ldr	r3, [r3, #0]
 801e7e6:	2b00      	cmp	r3, #0
 801e7e8:	d116      	bne.n	801e818 <wc_AddErrorNode+0xe8>
            /* case of first node added to queue */
            if (wc_errors != NULL) {
 801e7ea:	4b1c      	ldr	r3, [pc, #112]	@ (801e85c <wc_AddErrorNode+0x12c>)
 801e7ec:	681b      	ldr	r3, [r3, #0]
 801e7ee:	2b00      	cmp	r3, #0
 801e7f0:	d008      	beq.n	801e804 <wc_AddErrorNode+0xd4>
                WOLFSSL_MSG("ERROR in adding new node to logging queue!!");
                /* In the event both wc_last_node and wc_errors are NULL, err
                 * goes unassigned to external wc_errors, wc_last_node. Free
                 * err in this instance since wc_ClearErrorNodes will not
                 */
                XFREE(err, wc_error_heap, DYNAMIC_TYPE_LOG);
 801e7f2:	69bb      	ldr	r3, [r7, #24]
 801e7f4:	617b      	str	r3, [r7, #20]
 801e7f6:	697b      	ldr	r3, [r7, #20]
 801e7f8:	2b00      	cmp	r3, #0
 801e7fa:	d01f      	beq.n	801e83c <wc_AddErrorNode+0x10c>
 801e7fc:	6978      	ldr	r0, [r7, #20]
 801e7fe:	f000 f965 	bl	801eacc <wolfSSL_Free>
 801e802:	e01b      	b.n	801e83c <wc_AddErrorNode+0x10c>
            }
            else {
                wc_errors    = err;
 801e804:	4a15      	ldr	r2, [pc, #84]	@ (801e85c <wc_AddErrorNode+0x12c>)
 801e806:	69bb      	ldr	r3, [r7, #24]
 801e808:	6013      	str	r3, [r2, #0]
                wc_last_node = err;
 801e80a:	4a13      	ldr	r2, [pc, #76]	@ (801e858 <wc_AddErrorNode+0x128>)
 801e80c:	69bb      	ldr	r3, [r7, #24]
 801e80e:	6013      	str	r3, [r2, #0]
                wc_current_node = err;
 801e810:	4a13      	ldr	r2, [pc, #76]	@ (801e860 <wc_AddErrorNode+0x130>)
 801e812:	69bb      	ldr	r3, [r7, #24]
 801e814:	6013      	str	r3, [r2, #0]
 801e816:	e011      	b.n	801e83c <wc_AddErrorNode+0x10c>
            }
        }
        else {
            wc_last_node->next = err;
 801e818:	4b0f      	ldr	r3, [pc, #60]	@ (801e858 <wc_AddErrorNode+0x128>)
 801e81a:	681b      	ldr	r3, [r3, #0]
 801e81c:	69ba      	ldr	r2, [r7, #24]
 801e81e:	605a      	str	r2, [r3, #4]
            err->prev = wc_last_node;
 801e820:	4b0d      	ldr	r3, [pc, #52]	@ (801e858 <wc_AddErrorNode+0x128>)
 801e822:	681a      	ldr	r2, [r3, #0]
 801e824:	69bb      	ldr	r3, [r7, #24]
 801e826:	609a      	str	r2, [r3, #8]
            wc_last_node = err;
 801e828:	4a0b      	ldr	r2, [pc, #44]	@ (801e858 <wc_AddErrorNode+0x128>)
 801e82a:	69bb      	ldr	r3, [r7, #24]
 801e82c:	6013      	str	r3, [r2, #0]

            /* check the case where have read to the end of the queue and the
             * current node to read needs updated */
            if (wc_current_node == NULL) {
 801e82e:	4b0c      	ldr	r3, [pc, #48]	@ (801e860 <wc_AddErrorNode+0x130>)
 801e830:	681b      	ldr	r3, [r3, #0]
 801e832:	2b00      	cmp	r3, #0
 801e834:	d102      	bne.n	801e83c <wc_AddErrorNode+0x10c>
                wc_current_node = err;
 801e836:	4a0a      	ldr	r2, [pc, #40]	@ (801e860 <wc_AddErrorNode+0x130>)
 801e838:	69bb      	ldr	r3, [r7, #24]
 801e83a:	6013      	str	r3, [r2, #0]
            }
        }
        wc_errors_count++;
 801e83c:	4b04      	ldr	r3, [pc, #16]	@ (801e850 <wc_AddErrorNode+0x120>)
 801e83e:	681b      	ldr	r3, [r3, #0]
 801e840:	3301      	adds	r3, #1
 801e842:	4a03      	ldr	r2, [pc, #12]	@ (801e850 <wc_AddErrorNode+0x120>)
 801e844:	6013      	str	r3, [r2, #0]
    }
    return 0;
 801e846:	2300      	movs	r3, #0
}
 801e848:	4618      	mov	r0, r3
 801e84a:	3720      	adds	r7, #32
 801e84c:	46bd      	mov	sp, r7
 801e84e:	bd80      	pop	{r7, pc}
 801e850:	200026f4 	.word	0x200026f4
 801e854:	20002700 	.word	0x20002700
 801e858:	200026f8 	.word	0x200026f8
 801e85c:	200026f0 	.word	0x200026f0
 801e860:	200026fc 	.word	0x200026fc

0801e864 <removeErrorNode>:
    }
    return ret;
}

static void removeErrorNode(int idx)
{
 801e864:	b580      	push	{r7, lr}
 801e866:	b084      	sub	sp, #16
 801e868:	af00      	add	r7, sp, #0
 801e86a:	6078      	str	r0, [r7, #4]
    struct wc_error_queue* current;

    if (idx == -1) {
 801e86c:	687b      	ldr	r3, [r7, #4]
 801e86e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 801e872:	d103      	bne.n	801e87c <removeErrorNode+0x18>
        current = wc_last_node;
 801e874:	4b30      	ldr	r3, [pc, #192]	@ (801e938 <removeErrorNode+0xd4>)
 801e876:	681b      	ldr	r3, [r3, #0]
 801e878:	60fb      	str	r3, [r7, #12]
 801e87a:	e00f      	b.n	801e89c <removeErrorNode+0x38>
    }
    else {
        current = (struct wc_error_queue*)wc_errors;
 801e87c:	4b2f      	ldr	r3, [pc, #188]	@ (801e93c <removeErrorNode+0xd8>)
 801e87e:	681b      	ldr	r3, [r3, #0]
 801e880:	60fb      	str	r3, [r7, #12]
        for (; current != NULL && idx > 0; idx--)
 801e882:	e005      	b.n	801e890 <removeErrorNode+0x2c>
             current = current->next;
 801e884:	68fb      	ldr	r3, [r7, #12]
 801e886:	685b      	ldr	r3, [r3, #4]
 801e888:	60fb      	str	r3, [r7, #12]
        for (; current != NULL && idx > 0; idx--)
 801e88a:	687b      	ldr	r3, [r7, #4]
 801e88c:	3b01      	subs	r3, #1
 801e88e:	607b      	str	r3, [r7, #4]
 801e890:	68fb      	ldr	r3, [r7, #12]
 801e892:	2b00      	cmp	r3, #0
 801e894:	d002      	beq.n	801e89c <removeErrorNode+0x38>
 801e896:	687b      	ldr	r3, [r7, #4]
 801e898:	2b00      	cmp	r3, #0
 801e89a:	dcf3      	bgt.n	801e884 <removeErrorNode+0x20>
    }
    if (current != NULL) {
 801e89c:	68fb      	ldr	r3, [r7, #12]
 801e89e:	2b00      	cmp	r3, #0
 801e8a0:	d046      	beq.n	801e930 <removeErrorNode+0xcc>
        if (current->prev != NULL)
 801e8a2:	68fb      	ldr	r3, [r7, #12]
 801e8a4:	689b      	ldr	r3, [r3, #8]
 801e8a6:	2b00      	cmp	r3, #0
 801e8a8:	d004      	beq.n	801e8b4 <removeErrorNode+0x50>
            current->prev->next = current->next;
 801e8aa:	68fb      	ldr	r3, [r7, #12]
 801e8ac:	689b      	ldr	r3, [r3, #8]
 801e8ae:	68fa      	ldr	r2, [r7, #12]
 801e8b0:	6852      	ldr	r2, [r2, #4]
 801e8b2:	605a      	str	r2, [r3, #4]
        if (current->next != NULL)
 801e8b4:	68fb      	ldr	r3, [r7, #12]
 801e8b6:	685b      	ldr	r3, [r3, #4]
 801e8b8:	2b00      	cmp	r3, #0
 801e8ba:	d004      	beq.n	801e8c6 <removeErrorNode+0x62>
            current->next->prev = current->prev;
 801e8bc:	68fb      	ldr	r3, [r7, #12]
 801e8be:	685b      	ldr	r3, [r3, #4]
 801e8c0:	68fa      	ldr	r2, [r7, #12]
 801e8c2:	6892      	ldr	r2, [r2, #8]
 801e8c4:	609a      	str	r2, [r3, #8]
        if (wc_last_node == current)
 801e8c6:	4b1c      	ldr	r3, [pc, #112]	@ (801e938 <removeErrorNode+0xd4>)
 801e8c8:	681b      	ldr	r3, [r3, #0]
 801e8ca:	68fa      	ldr	r2, [r7, #12]
 801e8cc:	429a      	cmp	r2, r3
 801e8ce:	d103      	bne.n	801e8d8 <removeErrorNode+0x74>
            wc_last_node = current->prev;
 801e8d0:	68fb      	ldr	r3, [r7, #12]
 801e8d2:	689b      	ldr	r3, [r3, #8]
 801e8d4:	4a18      	ldr	r2, [pc, #96]	@ (801e938 <removeErrorNode+0xd4>)
 801e8d6:	6013      	str	r3, [r2, #0]
        if (wc_errors == current)
 801e8d8:	4b18      	ldr	r3, [pc, #96]	@ (801e93c <removeErrorNode+0xd8>)
 801e8da:	681b      	ldr	r3, [r3, #0]
 801e8dc:	68fa      	ldr	r2, [r7, #12]
 801e8de:	429a      	cmp	r2, r3
 801e8e0:	d103      	bne.n	801e8ea <removeErrorNode+0x86>
            wc_errors = current->next;
 801e8e2:	68fb      	ldr	r3, [r7, #12]
 801e8e4:	685b      	ldr	r3, [r3, #4]
 801e8e6:	4a15      	ldr	r2, [pc, #84]	@ (801e93c <removeErrorNode+0xd8>)
 801e8e8:	6013      	str	r3, [r2, #0]
        if (wc_current_node == current)
 801e8ea:	4b15      	ldr	r3, [pc, #84]	@ (801e940 <removeErrorNode+0xdc>)
 801e8ec:	681b      	ldr	r3, [r3, #0]
 801e8ee:	68fa      	ldr	r2, [r7, #12]
 801e8f0:	429a      	cmp	r2, r3
 801e8f2:	d103      	bne.n	801e8fc <removeErrorNode+0x98>
            wc_current_node = current->next;
 801e8f4:	68fb      	ldr	r3, [r7, #12]
 801e8f6:	685b      	ldr	r3, [r3, #4]
 801e8f8:	4a11      	ldr	r2, [pc, #68]	@ (801e940 <removeErrorNode+0xdc>)
 801e8fa:	6013      	str	r3, [r2, #0]
        XFREE(current, current->heap, DYNAMIC_TYPE_LOG);
 801e8fc:	68fb      	ldr	r3, [r7, #12]
 801e8fe:	60bb      	str	r3, [r7, #8]
 801e900:	68bb      	ldr	r3, [r7, #8]
 801e902:	2b00      	cmp	r3, #0
 801e904:	d002      	beq.n	801e90c <removeErrorNode+0xa8>
 801e906:	68b8      	ldr	r0, [r7, #8]
 801e908:	f000 f8e0 	bl	801eacc <wolfSSL_Free>
        wc_errors_count--;
 801e90c:	4b0d      	ldr	r3, [pc, #52]	@ (801e944 <removeErrorNode+0xe0>)
 801e90e:	681b      	ldr	r3, [r3, #0]
 801e910:	3b01      	subs	r3, #1
 801e912:	4a0c      	ldr	r2, [pc, #48]	@ (801e944 <removeErrorNode+0xe0>)
 801e914:	6013      	str	r3, [r2, #0]

        /* last node left in list was free'd, reset list head */
        if (wc_errors_count == 0) {
 801e916:	4b0b      	ldr	r3, [pc, #44]	@ (801e944 <removeErrorNode+0xe0>)
 801e918:	681b      	ldr	r3, [r3, #0]
 801e91a:	2b00      	cmp	r3, #0
 801e91c:	d108      	bne.n	801e930 <removeErrorNode+0xcc>
            wc_errors       = NULL;
 801e91e:	4b07      	ldr	r3, [pc, #28]	@ (801e93c <removeErrorNode+0xd8>)
 801e920:	2200      	movs	r2, #0
 801e922:	601a      	str	r2, [r3, #0]
            wc_last_node    = NULL;
 801e924:	4b04      	ldr	r3, [pc, #16]	@ (801e938 <removeErrorNode+0xd4>)
 801e926:	2200      	movs	r2, #0
 801e928:	601a      	str	r2, [r3, #0]
            wc_current_node = NULL;
 801e92a:	4b05      	ldr	r3, [pc, #20]	@ (801e940 <removeErrorNode+0xdc>)
 801e92c:	2200      	movs	r2, #0
 801e92e:	601a      	str	r2, [r3, #0]
        }
    }
}
 801e930:	bf00      	nop
 801e932:	3710      	adds	r7, #16
 801e934:	46bd      	mov	sp, r7
 801e936:	bd80      	pop	{r7, pc}
 801e938:	200026f8 	.word	0x200026f8
 801e93c:	200026f0 	.word	0x200026f0
 801e940:	200026fc 	.word	0x200026fc
 801e944:	200026f4 	.word	0x200026f4

0801e948 <wc_RemoveErrorNode>:
 * idx : if -1 then the most recent node is looked at,
 *       otherwise search through queue for node at the given index starting
 *          from the absolute head wc_errors
 */
void wc_RemoveErrorNode(int idx)
{
 801e948:	b580      	push	{r7, lr}
 801e94a:	b082      	sub	sp, #8
 801e94c:	af00      	add	r7, sp, #0
 801e94e:	6078      	str	r0, [r7, #4]
    if (ERRQ_LOCK() != 0) {
 801e950:	4808      	ldr	r0, [pc, #32]	@ (801e974 <wc_RemoveErrorNode+0x2c>)
 801e952:	f008 fd2f 	bl	80273b4 <wc_LockMutex>
 801e956:	4603      	mov	r3, r0
 801e958:	2b00      	cmp	r3, #0
 801e95a:	d106      	bne.n	801e96a <wc_RemoveErrorNode+0x22>
        WOLFSSL_MSG("Lock debug mutex failed");
        return;
    }

    removeErrorNode(idx);
 801e95c:	6878      	ldr	r0, [r7, #4]
 801e95e:	f7ff ff81 	bl	801e864 <removeErrorNode>

    ERRQ_UNLOCK();
 801e962:	4804      	ldr	r0, [pc, #16]	@ (801e974 <wc_RemoveErrorNode+0x2c>)
 801e964:	f008 fd31 	bl	80273ca <wc_UnLockMutex>
 801e968:	e000      	b.n	801e96c <wc_RemoveErrorNode+0x24>
        return;
 801e96a:	bf00      	nop
}
 801e96c:	3708      	adds	r7, #8
 801e96e:	46bd      	mov	sp, r7
 801e970:	bd80      	pop	{r7, pc}
 801e972:	bf00      	nop
 801e974:	20002704 	.word	0x20002704

0801e978 <clearErrorNodes>:

static void clearErrorNodes(void)
{
 801e978:	b580      	push	{r7, lr}
 801e97a:	b084      	sub	sp, #16
 801e97c:	af00      	add	r7, sp, #0
    struct wc_error_queue* current;
    struct wc_error_queue* next;
    /* free all nodes from error queue (even previously 'pulled' ones) starting
     * at the lists absolute head of wc_errors */

    current = (struct wc_error_queue*)wc_errors;
 801e97e:	4b12      	ldr	r3, [pc, #72]	@ (801e9c8 <clearErrorNodes+0x50>)
 801e980:	681b      	ldr	r3, [r3, #0]
 801e982:	60fb      	str	r3, [r7, #12]
    while (current != NULL) {
 801e984:	e00c      	b.n	801e9a0 <clearErrorNodes+0x28>
        next = current->next;
 801e986:	68fb      	ldr	r3, [r7, #12]
 801e988:	685b      	ldr	r3, [r3, #4]
 801e98a:	60bb      	str	r3, [r7, #8]
        XFREE(current, current->heap, DYNAMIC_TYPE_LOG);
 801e98c:	68fb      	ldr	r3, [r7, #12]
 801e98e:	607b      	str	r3, [r7, #4]
 801e990:	687b      	ldr	r3, [r7, #4]
 801e992:	2b00      	cmp	r3, #0
 801e994:	d002      	beq.n	801e99c <clearErrorNodes+0x24>
 801e996:	6878      	ldr	r0, [r7, #4]
 801e998:	f000 f898 	bl	801eacc <wolfSSL_Free>
        current = next;
 801e99c:	68bb      	ldr	r3, [r7, #8]
 801e99e:	60fb      	str	r3, [r7, #12]
    while (current != NULL) {
 801e9a0:	68fb      	ldr	r3, [r7, #12]
 801e9a2:	2b00      	cmp	r3, #0
 801e9a4:	d1ef      	bne.n	801e986 <clearErrorNodes+0xe>
    }

    wc_errors_count = 0;
 801e9a6:	4b09      	ldr	r3, [pc, #36]	@ (801e9cc <clearErrorNodes+0x54>)
 801e9a8:	2200      	movs	r2, #0
 801e9aa:	601a      	str	r2, [r3, #0]
    wc_errors       = NULL;
 801e9ac:	4b06      	ldr	r3, [pc, #24]	@ (801e9c8 <clearErrorNodes+0x50>)
 801e9ae:	2200      	movs	r2, #0
 801e9b0:	601a      	str	r2, [r3, #0]
    wc_last_node    = NULL;
 801e9b2:	4b07      	ldr	r3, [pc, #28]	@ (801e9d0 <clearErrorNodes+0x58>)
 801e9b4:	2200      	movs	r2, #0
 801e9b6:	601a      	str	r2, [r3, #0]
    wc_current_node = NULL;
 801e9b8:	4b06      	ldr	r3, [pc, #24]	@ (801e9d4 <clearErrorNodes+0x5c>)
 801e9ba:	2200      	movs	r2, #0
 801e9bc:	601a      	str	r2, [r3, #0]
}
 801e9be:	bf00      	nop
 801e9c0:	3710      	adds	r7, #16
 801e9c2:	46bd      	mov	sp, r7
 801e9c4:	bd80      	pop	{r7, pc}
 801e9c6:	bf00      	nop
 801e9c8:	200026f0 	.word	0x200026f0
 801e9cc:	200026f4 	.word	0x200026f4
 801e9d0:	200026f8 	.word	0x200026f8
 801e9d4:	200026fc 	.word	0x200026fc

0801e9d8 <wc_ClearErrorNodes>:

/* Clears out the list of error nodes.
 */
void wc_ClearErrorNodes(void)
{
 801e9d8:	b580      	push	{r7, lr}
 801e9da:	af00      	add	r7, sp, #0
    if (ERRQ_LOCK() != 0) {
 801e9dc:	4806      	ldr	r0, [pc, #24]	@ (801e9f8 <wc_ClearErrorNodes+0x20>)
 801e9de:	f008 fce9 	bl	80273b4 <wc_LockMutex>
 801e9e2:	4603      	mov	r3, r0
 801e9e4:	2b00      	cmp	r3, #0
 801e9e6:	d105      	bne.n	801e9f4 <wc_ClearErrorNodes+0x1c>
        WOLFSSL_MSG("Lock debug mutex failed");
        return;
    }

    clearErrorNodes();
 801e9e8:	f7ff ffc6 	bl	801e978 <clearErrorNodes>

    ERRQ_UNLOCK();
 801e9ec:	4802      	ldr	r0, [pc, #8]	@ (801e9f8 <wc_ClearErrorNodes+0x20>)
 801e9ee:	f008 fcec 	bl	80273ca <wc_UnLockMutex>
 801e9f2:	e000      	b.n	801e9f6 <wc_ClearErrorNodes+0x1e>
        return;
 801e9f4:	bf00      	nop
}
 801e9f6:	bd80      	pop	{r7, pc}
 801e9f8:	20002704 	.word	0x20002704

0801e9fc <WOLFSSL_ERROR_LINE>:
void WOLFSSL_ERROR_LINE(int error, const char* func, unsigned int line,
        const char* file, void* usrCtx)
#else
void WOLFSSL_ERROR(int error)
#endif
{
 801e9fc:	b580      	push	{r7, lr}
 801e9fe:	b09a      	sub	sp, #104	@ 0x68
 801ea00:	af02      	add	r7, sp, #8
 801ea02:	60f8      	str	r0, [r7, #12]
 801ea04:	60b9      	str	r1, [r7, #8]
 801ea06:	607a      	str	r2, [r7, #4]
 801ea08:	603b      	str	r3, [r7, #0]

    #ifdef WOLFSSL_HAVE_ERROR_QUEUE
        (void)usrCtx; /* a user ctx for future flexibility */
        (void)func;

        if (ERRQ_LOCK() != 0) {
 801ea0a:	481f      	ldr	r0, [pc, #124]	@ (801ea88 <WOLFSSL_ERROR_LINE+0x8c>)
 801ea0c:	f008 fcd2 	bl	80273b4 <wc_LockMutex>
 801ea10:	4603      	mov	r3, r0
 801ea12:	2b00      	cmp	r3, #0
 801ea14:	d007      	beq.n	801ea26 <WOLFSSL_ERROR_LINE+0x2a>
            WOLFSSL_MSG("Lock debug mutex failed");
            (void)XSNPRINTF(buffer, sizeof(buffer),
 801ea16:	f107 0010 	add.w	r0, r7, #16
 801ea1a:	68fb      	ldr	r3, [r7, #12]
 801ea1c:	4a1b      	ldr	r2, [pc, #108]	@ (801ea8c <WOLFSSL_ERROR_LINE+0x90>)
 801ea1e:	2150      	movs	r1, #80	@ 0x50
 801ea20:	f009 fcf6 	bl	8028410 <sniprintf>
    #ifdef DEBUG_WOLFSSL
        if (loggingEnabled)
            wolfssl_log(ERROR_LOG, NULL, 0, buffer);
    #endif
    }
}
 801ea24:	e02c      	b.n	801ea80 <WOLFSSL_ERROR_LINE+0x84>
            if (error != WC_NO_ERR_TRACE(WANT_READ) &&
 801ea26:	68fb      	ldr	r3, [r7, #12]
 801ea28:	f46f 72a1 	mvn.w	r2, #322	@ 0x142
 801ea2c:	4293      	cmp	r3, r2
 801ea2e:	d01d      	beq.n	801ea6c <WOLFSSL_ERROR_LINE+0x70>
 801ea30:	68fb      	ldr	r3, [r7, #12]
 801ea32:	f46f 72a3 	mvn.w	r2, #326	@ 0x146
 801ea36:	4293      	cmp	r3, r2
 801ea38:	d018      	beq.n	801ea6c <WOLFSSL_ERROR_LINE+0x70>
            if (error < 0)
 801ea3a:	68fb      	ldr	r3, [r7, #12]
 801ea3c:	2b00      	cmp	r3, #0
 801ea3e:	da02      	bge.n	801ea46 <WOLFSSL_ERROR_LINE+0x4a>
                error = error - (2 * error); /* get absolute value */
 801ea40:	68fb      	ldr	r3, [r7, #12]
 801ea42:	425b      	negs	r3, r3
 801ea44:	60fb      	str	r3, [r7, #12]
            (void)XSNPRINTF(buffer, sizeof(buffer),
 801ea46:	f107 0010 	add.w	r0, r7, #16
 801ea4a:	683b      	ldr	r3, [r7, #0]
 801ea4c:	9301      	str	r3, [sp, #4]
 801ea4e:	687b      	ldr	r3, [r7, #4]
 801ea50:	9300      	str	r3, [sp, #0]
 801ea52:	68fb      	ldr	r3, [r7, #12]
 801ea54:	4a0e      	ldr	r2, [pc, #56]	@ (801ea90 <WOLFSSL_ERROR_LINE+0x94>)
 801ea56:	2150      	movs	r1, #80	@ 0x50
 801ea58:	f009 fcda 	bl	8028410 <sniprintf>
            if (wc_AddErrorNode(error, (int)line, buffer, (char*)file) != 0) {
 801ea5c:	6879      	ldr	r1, [r7, #4]
 801ea5e:	f107 0210 	add.w	r2, r7, #16
 801ea62:	683b      	ldr	r3, [r7, #0]
 801ea64:	68f8      	ldr	r0, [r7, #12]
 801ea66:	f7ff fe63 	bl	801e730 <wc_AddErrorNode>
 801ea6a:	e006      	b.n	801ea7a <WOLFSSL_ERROR_LINE+0x7e>
                (void)XSNPRINTF(buffer, sizeof(buffer),
 801ea6c:	f107 0010 	add.w	r0, r7, #16
 801ea70:	68fb      	ldr	r3, [r7, #12]
 801ea72:	4a06      	ldr	r2, [pc, #24]	@ (801ea8c <WOLFSSL_ERROR_LINE+0x90>)
 801ea74:	2150      	movs	r1, #80	@ 0x50
 801ea76:	f009 fccb 	bl	8028410 <sniprintf>
            ERRQ_UNLOCK();
 801ea7a:	4803      	ldr	r0, [pc, #12]	@ (801ea88 <WOLFSSL_ERROR_LINE+0x8c>)
 801ea7c:	f008 fca5 	bl	80273ca <wc_UnLockMutex>
}
 801ea80:	bf00      	nop
 801ea82:	3760      	adds	r7, #96	@ 0x60
 801ea84:	46bd      	mov	sp, r7
 801ea86:	bd80      	pop	{r7, pc}
 801ea88:	20002704 	.word	0x20002704
 801ea8c:	0802febc 	.word	0x0802febc
 801ea90:	0802fee0 	.word	0x0802fee0

0801ea94 <wolfSSL_Malloc>:
#ifdef WOLFSSL_DEBUG_MEMORY
void* wolfSSL_Malloc(size_t size, const char* func, unsigned int line)
#else
void* wolfSSL_Malloc(size_t size)
#endif
{
 801ea94:	b580      	push	{r7, lr}
 801ea96:	b084      	sub	sp, #16
 801ea98:	af00      	add	r7, sp, #0
 801ea9a:	6078      	str	r0, [r7, #4]
    void* res = 0;
 801ea9c:	2300      	movs	r3, #0
 801ea9e:	60fb      	str	r3, [r7, #12]
#ifdef WOLFSSL_CHECK_MEM_ZERO
    /* Space for requested size. */
    size += MEM_ALIGN;
#endif

    if (malloc_function) {
 801eaa0:	4b09      	ldr	r3, [pc, #36]	@ (801eac8 <wolfSSL_Malloc+0x34>)
 801eaa2:	681b      	ldr	r3, [r3, #0]
 801eaa4:	2b00      	cmp	r3, #0
 801eaa6:	d005      	beq.n	801eab4 <wolfSSL_Malloc+0x20>
    #ifdef WOLFSSL_DEBUG_MEMORY
        res = malloc_function(size, func, line);
    #else
        res = malloc_function(size);
 801eaa8:	4b07      	ldr	r3, [pc, #28]	@ (801eac8 <wolfSSL_Malloc+0x34>)
 801eaaa:	681b      	ldr	r3, [r3, #0]
 801eaac:	6878      	ldr	r0, [r7, #4]
 801eaae:	4798      	blx	r3
 801eab0:	60f8      	str	r0, [r7, #12]
 801eab2:	e004      	b.n	801eabe <wolfSSL_Malloc+0x2a>
            WOLFSSL_MSG("Malloc too big!");
            return NULL;
        }
        #endif

        res = malloc(size); /* native heap */
 801eab4:	6878      	ldr	r0, [r7, #4]
 801eab6:	f009 fbbf 	bl	8028238 <malloc>
 801eaba:	4603      	mov	r3, r0
 801eabc:	60fb      	str	r3, [r7, #12]
        gMemFailCount = gMemFailCountSeed; /* reset */
        return NULL;
    }
#endif

    return res;
 801eabe:	68fb      	ldr	r3, [r7, #12]
}
 801eac0:	4618      	mov	r0, r3
 801eac2:	3710      	adds	r7, #16
 801eac4:	46bd      	mov	sp, r7
 801eac6:	bd80      	pop	{r7, pc}
 801eac8:	20002708 	.word	0x20002708

0801eacc <wolfSSL_Free>:
#ifdef WOLFSSL_DEBUG_MEMORY
void wolfSSL_Free(void *ptr, const char* func, unsigned int line)
#else
void wolfSSL_Free(void *ptr)
#endif
{
 801eacc:	b580      	push	{r7, lr}
 801eace:	b082      	sub	sp, #8
 801ead0:	af00      	add	r7, sp, #0
 801ead2:	6078      	str	r0, [r7, #4]
#endif
#ifdef WOLFSSL_MEM_FAIL_COUNT
    wc_MemFailCount_FreeMem();
#endif

    if (free_function) {
 801ead4:	4b07      	ldr	r3, [pc, #28]	@ (801eaf4 <wolfSSL_Free+0x28>)
 801ead6:	681b      	ldr	r3, [r3, #0]
 801ead8:	2b00      	cmp	r3, #0
 801eada:	d004      	beq.n	801eae6 <wolfSSL_Free+0x1a>
    #ifdef WOLFSSL_DEBUG_MEMORY
        free_function(ptr, func, line);
    #else
        free_function(ptr);
 801eadc:	4b05      	ldr	r3, [pc, #20]	@ (801eaf4 <wolfSSL_Free+0x28>)
 801eade:	681b      	ldr	r3, [r3, #0]
 801eae0:	6878      	ldr	r0, [r7, #4]
 801eae2:	4798      	blx	r3
        free(ptr); /* native heap */
    #else
        WOLFSSL_MSG("No free available");
    #endif
    }
}
 801eae4:	e002      	b.n	801eaec <wolfSSL_Free+0x20>
        free(ptr); /* native heap */
 801eae6:	6878      	ldr	r0, [r7, #4]
 801eae8:	f009 fbae 	bl	8028248 <free>
}
 801eaec:	bf00      	nop
 801eaee:	3708      	adds	r7, #8
 801eaf0:	46bd      	mov	sp, r7
 801eaf2:	bd80      	pop	{r7, pc}
 801eaf4:	2000270c 	.word	0x2000270c

0801eaf8 <rotlFixed>:
    {
 801eaf8:	b480      	push	{r7}
 801eafa:	b083      	sub	sp, #12
 801eafc:	af00      	add	r7, sp, #0
 801eafe:	6078      	str	r0, [r7, #4]
 801eb00:	6039      	str	r1, [r7, #0]
        return (x << y) | (x >> (sizeof(x) * 8 - y));
 801eb02:	687a      	ldr	r2, [r7, #4]
 801eb04:	683b      	ldr	r3, [r7, #0]
 801eb06:	f1c3 0320 	rsb	r3, r3, #32
 801eb0a:	fa62 f303 	ror.w	r3, r2, r3
    }
 801eb0e:	4618      	mov	r0, r3
 801eb10:	370c      	adds	r7, #12
 801eb12:	46bd      	mov	sp, r7
 801eb14:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eb18:	4770      	bx	lr

0801eb1a <ByteReverseWord32>:
{
 801eb1a:	b580      	push	{r7, lr}
 801eb1c:	b082      	sub	sp, #8
 801eb1e:	af00      	add	r7, sp, #0
 801eb20:	6078      	str	r0, [r7, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 801eb22:	687b      	ldr	r3, [r7, #4]
 801eb24:	0a1b      	lsrs	r3, r3, #8
 801eb26:	f003 12ff 	and.w	r2, r3, #16711935	@ 0xff00ff
 801eb2a:	687b      	ldr	r3, [r7, #4]
 801eb2c:	021b      	lsls	r3, r3, #8
 801eb2e:	f003 23ff 	and.w	r3, r3, #4278255360	@ 0xff00ff00
 801eb32:	4313      	orrs	r3, r2
 801eb34:	607b      	str	r3, [r7, #4]
    return rotlFixed(value, 16U);
 801eb36:	2110      	movs	r1, #16
 801eb38:	6878      	ldr	r0, [r7, #4]
 801eb3a:	f7ff ffdd 	bl	801eaf8 <rotlFixed>
 801eb3e:	4603      	mov	r3, r0
}
 801eb40:	4618      	mov	r0, r3
 801eb42:	3708      	adds	r7, #8
 801eb44:	46bd      	mov	sp, r7
 801eb46:	bd80      	pop	{r7, pc}

0801eb48 <ForceZero>:
{
 801eb48:	b480      	push	{r7}
 801eb4a:	b085      	sub	sp, #20
 801eb4c:	af00      	add	r7, sp, #0
 801eb4e:	6078      	str	r0, [r7, #4]
 801eb50:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801eb52:	687b      	ldr	r3, [r7, #4]
 801eb54:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801eb56:	e004      	b.n	801eb62 <ForceZero+0x1a>
 801eb58:	68fb      	ldr	r3, [r7, #12]
 801eb5a:	1c5a      	adds	r2, r3, #1
 801eb5c:	60fa      	str	r2, [r7, #12]
 801eb5e:	2200      	movs	r2, #0
 801eb60:	701a      	strb	r2, [r3, #0]
 801eb62:	683b      	ldr	r3, [r7, #0]
 801eb64:	1e5a      	subs	r2, r3, #1
 801eb66:	603a      	str	r2, [r7, #0]
 801eb68:	2b00      	cmp	r3, #0
 801eb6a:	d1f5      	bne.n	801eb58 <ForceZero+0x10>
}
 801eb6c:	bf00      	nop
 801eb6e:	bf00      	nop
 801eb70:	3714      	adds	r7, #20
 801eb72:	46bd      	mov	sp, r7
 801eb74:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eb78:	4770      	bx	lr

0801eb7a <ConstantCompare>:
{
 801eb7a:	b480      	push	{r7}
 801eb7c:	b087      	sub	sp, #28
 801eb7e:	af00      	add	r7, sp, #0
 801eb80:	60f8      	str	r0, [r7, #12]
 801eb82:	60b9      	str	r1, [r7, #8]
 801eb84:	607a      	str	r2, [r7, #4]
    int compareSum = 0;
 801eb86:	2300      	movs	r3, #0
 801eb88:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801eb8a:	2300      	movs	r3, #0
 801eb8c:	617b      	str	r3, [r7, #20]
 801eb8e:	e010      	b.n	801ebb2 <ConstantCompare+0x38>
        compareSum |= a[i] ^ b[i];
 801eb90:	697b      	ldr	r3, [r7, #20]
 801eb92:	68fa      	ldr	r2, [r7, #12]
 801eb94:	4413      	add	r3, r2
 801eb96:	781a      	ldrb	r2, [r3, #0]
 801eb98:	697b      	ldr	r3, [r7, #20]
 801eb9a:	68b9      	ldr	r1, [r7, #8]
 801eb9c:	440b      	add	r3, r1
 801eb9e:	781b      	ldrb	r3, [r3, #0]
 801eba0:	4053      	eors	r3, r2
 801eba2:	b2db      	uxtb	r3, r3
 801eba4:	461a      	mov	r2, r3
 801eba6:	693b      	ldr	r3, [r7, #16]
 801eba8:	4313      	orrs	r3, r2
 801ebaa:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801ebac:	697b      	ldr	r3, [r7, #20]
 801ebae:	3301      	adds	r3, #1
 801ebb0:	617b      	str	r3, [r7, #20]
 801ebb2:	697a      	ldr	r2, [r7, #20]
 801ebb4:	687b      	ldr	r3, [r7, #4]
 801ebb6:	429a      	cmp	r2, r3
 801ebb8:	dbea      	blt.n	801eb90 <ConstantCompare+0x16>
    return compareSum;
 801ebba:	693b      	ldr	r3, [r7, #16]
}
 801ebbc:	4618      	mov	r0, r3
 801ebbe:	371c      	adds	r7, #28
 801ebc0:	46bd      	mov	sp, r7
 801ebc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ebc6:	4770      	bx	lr

0801ebc8 <min>:
    {
 801ebc8:	b480      	push	{r7}
 801ebca:	b083      	sub	sp, #12
 801ebcc:	af00      	add	r7, sp, #0
 801ebce:	6078      	str	r0, [r7, #4]
 801ebd0:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 801ebd2:	687a      	ldr	r2, [r7, #4]
 801ebd4:	683b      	ldr	r3, [r7, #0]
 801ebd6:	4293      	cmp	r3, r2
 801ebd8:	bf28      	it	cs
 801ebda:	4613      	movcs	r3, r2
    }
 801ebdc:	4618      	mov	r0, r3
 801ebde:	370c      	adds	r7, #12
 801ebe0:	46bd      	mov	sp, r7
 801ebe2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ebe6:	4770      	bx	lr

0801ebe8 <Hash_df>:
/* Hash Derivation Function */
/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_df(DRBG_internal* drbg, byte* out, word32 outSz, byte type,
                                                  const byte* inA, word32 inASz,
                                                  const byte* inB, word32 inBSz)
{
 801ebe8:	b580      	push	{r7, lr}
 801ebea:	b0a8      	sub	sp, #160	@ 0xa0
 801ebec:	af00      	add	r7, sp, #0
 801ebee:	60f8      	str	r0, [r7, #12]
 801ebf0:	60b9      	str	r1, [r7, #8]
 801ebf2:	607a      	str	r2, [r7, #4]
 801ebf4:	70fb      	strb	r3, [r7, #3]
    int ret = DRBG_FAILURE;
 801ebf6:	2301      	movs	r3, #1
 801ebf8:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    byte ctr;
    word32 i;
    word32 len;
    word32 bits = (outSz * 8); /* reverse byte order */
 801ebfc:	687b      	ldr	r3, [r7, #4]
 801ebfe:	00db      	lsls	r3, r3, #3
 801ec00:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    byte* digest;
#else
    byte digest[WC_SHA256_DIGEST_SIZE];
#endif

    if (drbg == NULL) {
 801ec04:	68fb      	ldr	r3, [r7, #12]
 801ec06:	2b00      	cmp	r3, #0
 801ec08:	d101      	bne.n	801ec0e <Hash_df+0x26>
        return DRBG_FAILURE;
 801ec0a:	2301      	movs	r3, #1
 801ec0c:	e0d8      	b.n	801edc0 <Hash_df+0x1d8>
    }

#ifdef WOLFSSL_SMALL_STACK
    digest = (byte*)XMALLOC(WC_SHA256_DIGEST_SIZE, drbg->heap,
 801ec0e:	2020      	movs	r0, #32
 801ec10:	f7ff ff40 	bl	801ea94 <wolfSSL_Malloc>
 801ec14:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
        DYNAMIC_TYPE_DIGEST);
    if (digest == NULL)
 801ec18:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801ec1c:	2b00      	cmp	r3, #0
 801ec1e:	d101      	bne.n	801ec24 <Hash_df+0x3c>
        return DRBG_FAILURE;
 801ec20:	2301      	movs	r3, #1
 801ec22:	e0cd      	b.n	801edc0 <Hash_df+0x1d8>
#endif

#ifdef LITTLE_ENDIAN_ORDER
    bits = ByteReverseWord32(bits);
 801ec24:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ec28:	4618      	mov	r0, r3
 801ec2a:	f7ff ff76 	bl	801eb1a <ByteReverseWord32>
 801ec2e:	4603      	mov	r3, r0
 801ec30:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
#endif
    len = (outSz / OUTPUT_BLOCK_LEN)
 801ec34:	687b      	ldr	r3, [r7, #4]
 801ec36:	095b      	lsrs	r3, r3, #5
        + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 801ec38:	687a      	ldr	r2, [r7, #4]
 801ec3a:	f002 021f 	and.w	r2, r2, #31
 801ec3e:	2a00      	cmp	r2, #0
 801ec40:	d001      	beq.n	801ec46 <Hash_df+0x5e>
 801ec42:	2201      	movs	r2, #1
 801ec44:	e000      	b.n	801ec48 <Hash_df+0x60>
 801ec46:	2200      	movs	r2, #0
    len = (outSz / OUTPUT_BLOCK_LEN)
 801ec48:	4413      	add	r3, r2
 801ec4a:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90

    ctr = 1;
 801ec4e:	2301      	movs	r3, #1
 801ec50:	f887 308b 	strb.w	r3, [r7, #139]	@ 0x8b
    for (i = 0; i < len; i++) {
 801ec54:	2300      	movs	r3, #0
 801ec56:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 801ec5a:	e090      	b.n	801ed7e <Hash_df+0x196>
#ifndef WOLFSSL_SMALL_STACK_CACHE
    #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    #else
        ret = wc_InitSha256(sha);
 801ec5c:	f107 0314 	add.w	r3, r7, #20
 801ec60:	4618      	mov	r0, r3
 801ec62:	f003 f9c7 	bl	8021ff4 <wc_InitSha256>
 801ec66:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
    #endif
        if (ret != 0)
 801ec6a:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ec6e:	2b00      	cmp	r3, #0
 801ec70:	f040 808d 	bne.w	801ed8e <Hash_df+0x1a6>
            break;
#endif
        ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));
 801ec74:	f107 018b 	add.w	r1, r7, #139	@ 0x8b
 801ec78:	f107 0314 	add.w	r3, r7, #20
 801ec7c:	2201      	movs	r2, #1
 801ec7e:	4618      	mov	r0, r3
 801ec80:	f003 f8ef 	bl	8021e62 <wc_Sha256Update>
 801ec84:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        if (ret == 0) {
 801ec88:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ec8c:	2b00      	cmp	r3, #0
 801ec8e:	d10f      	bne.n	801ecb0 <Hash_df+0xc8>
            ctr++;
 801ec90:	f897 308b 	ldrb.w	r3, [r7, #139]	@ 0x8b
 801ec94:	3301      	adds	r3, #1
 801ec96:	b2db      	uxtb	r3, r3
 801ec98:	f887 308b 	strb.w	r3, [r7, #139]	@ 0x8b
            ret = wc_Sha256Update(sha, (byte*)&bits, sizeof(bits));
 801ec9c:	f107 0184 	add.w	r1, r7, #132	@ 0x84
 801eca0:	f107 0314 	add.w	r3, r7, #20
 801eca4:	2204      	movs	r2, #4
 801eca6:	4618      	mov	r0, r3
 801eca8:	f003 f8db 	bl	8021e62 <wc_Sha256Update>
 801ecac:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        }

        if (ret == 0) {
 801ecb0:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ecb4:	2b00      	cmp	r3, #0
 801ecb6:	d10b      	bne.n	801ecd0 <Hash_df+0xe8>
            /* churning V is the only string that doesn't have the type added */
            if (type != drbgInitV)
 801ecb8:	78fb      	ldrb	r3, [r7, #3]
 801ecba:	2b04      	cmp	r3, #4
 801ecbc:	d008      	beq.n	801ecd0 <Hash_df+0xe8>
                ret = wc_Sha256Update(sha, &type, sizeof(type));
 801ecbe:	1cf9      	adds	r1, r7, #3
 801ecc0:	f107 0314 	add.w	r3, r7, #20
 801ecc4:	2201      	movs	r2, #1
 801ecc6:	4618      	mov	r0, r3
 801ecc8:	f003 f8cb 	bl	8021e62 <wc_Sha256Update>
 801eccc:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        }
        if (ret == 0)
 801ecd0:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ecd4:	2b00      	cmp	r3, #0
 801ecd6:	d10a      	bne.n	801ecee <Hash_df+0x106>
            ret = wc_Sha256Update(sha, inA, inASz);
 801ecd8:	f107 0314 	add.w	r3, r7, #20
 801ecdc:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801ece0:	f8d7 10a8 	ldr.w	r1, [r7, #168]	@ 0xa8
 801ece4:	4618      	mov	r0, r3
 801ece6:	f003 f8bc 	bl	8021e62 <wc_Sha256Update>
 801ecea:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        if (ret == 0) {
 801ecee:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ecf2:	2b00      	cmp	r3, #0
 801ecf4:	d112      	bne.n	801ed1c <Hash_df+0x134>
            if (inB != NULL && inBSz > 0)
 801ecf6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801ecfa:	2b00      	cmp	r3, #0
 801ecfc:	d00e      	beq.n	801ed1c <Hash_df+0x134>
 801ecfe:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801ed02:	2b00      	cmp	r3, #0
 801ed04:	d00a      	beq.n	801ed1c <Hash_df+0x134>
                ret = wc_Sha256Update(sha, inB, inBSz);
 801ed06:	f107 0314 	add.w	r3, r7, #20
 801ed0a:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 801ed0e:	f8d7 10b0 	ldr.w	r1, [r7, #176]	@ 0xb0
 801ed12:	4618      	mov	r0, r3
 801ed14:	f003 f8a5 	bl	8021e62 <wc_Sha256Update>
 801ed18:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
        }
        if (ret == 0)
 801ed1c:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ed20:	2b00      	cmp	r3, #0
 801ed22:	d108      	bne.n	801ed36 <Hash_df+0x14e>
            ret = wc_Sha256Final(sha, digest);
 801ed24:	f107 0314 	add.w	r3, r7, #20
 801ed28:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 801ed2c:	4618      	mov	r0, r3
 801ed2e:	f003 f936 	bl	8021f9e <wc_Sha256Final>
 801ed32:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c

#ifndef WOLFSSL_SMALL_STACK_CACHE
        wc_Sha256Free(sha);
 801ed36:	f107 0314 	add.w	r3, r7, #20
 801ed3a:	4618      	mov	r0, r3
 801ed3c:	f003 f96b 	bl	8022016 <wc_Sha256Free>
#endif
        if (ret == 0) {
 801ed40:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ed44:	2b00      	cmp	r3, #0
 801ed46:	d115      	bne.n	801ed74 <Hash_df+0x18c>
            if (outSz > OUTPUT_BLOCK_LEN) {
 801ed48:	687b      	ldr	r3, [r7, #4]
 801ed4a:	2b20      	cmp	r3, #32
 801ed4c:	d90c      	bls.n	801ed68 <Hash_df+0x180>
                XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
 801ed4e:	2220      	movs	r2, #32
 801ed50:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 801ed54:	68b8      	ldr	r0, [r7, #8]
 801ed56:	f009 fc25 	bl	80285a4 <memcpy>
                outSz -= OUTPUT_BLOCK_LEN;
 801ed5a:	687b      	ldr	r3, [r7, #4]
 801ed5c:	3b20      	subs	r3, #32
 801ed5e:	607b      	str	r3, [r7, #4]
                out += OUTPUT_BLOCK_LEN;
 801ed60:	68bb      	ldr	r3, [r7, #8]
 801ed62:	3320      	adds	r3, #32
 801ed64:	60bb      	str	r3, [r7, #8]
 801ed66:	e005      	b.n	801ed74 <Hash_df+0x18c>
            }
            else {
                XMEMCPY(out, digest, outSz);
 801ed68:	687a      	ldr	r2, [r7, #4]
 801ed6a:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 801ed6e:	68b8      	ldr	r0, [r7, #8]
 801ed70:	f009 fc18 	bl	80285a4 <memcpy>
    for (i = 0; i < len; i++) {
 801ed74:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ed78:	3301      	adds	r3, #1
 801ed7a:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 801ed7e:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801ed82:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801ed86:	429a      	cmp	r2, r3
 801ed88:	f4ff af68 	bcc.w	801ec5c <Hash_df+0x74>
 801ed8c:	e000      	b.n	801ed90 <Hash_df+0x1a8>
            break;
 801ed8e:	bf00      	nop
            }
        }
    }

    ForceZero(digest, WC_SHA256_DIGEST_SIZE);
 801ed90:	2120      	movs	r1, #32
 801ed92:	f8d7 0094 	ldr.w	r0, [r7, #148]	@ 0x94
 801ed96:	f7ff fed7 	bl	801eb48 <ForceZero>

#ifdef WOLFSSL_SMALL_STACK
    XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801ed9a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801ed9e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801eda2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801eda6:	2b00      	cmp	r3, #0
 801eda8:	d003      	beq.n	801edb2 <Hash_df+0x1ca>
 801edaa:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801edae:	f7ff fe8d 	bl	801eacc <wolfSSL_Free>
#endif

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801edb2:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801edb6:	2b00      	cmp	r3, #0
 801edb8:	bf14      	ite	ne
 801edba:	2301      	movne	r3, #1
 801edbc:	2300      	moveq	r3, #0
 801edbe:	b2db      	uxtb	r3, r3
}
 801edc0:	4618      	mov	r0, r3
 801edc2:	37a0      	adds	r7, #160	@ 0xa0
 801edc4:	46bd      	mov	sp, r7
 801edc6:	bd80      	pop	{r7, pc}

0801edc8 <Hash_DRBG_Reseed>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Reseed(DRBG_internal* drbg, const byte* seed, word32 seedSz)
{
 801edc8:	b580      	push	{r7, lr}
 801edca:	b08c      	sub	sp, #48	@ 0x30
 801edcc:	af04      	add	r7, sp, #16
 801edce:	60f8      	str	r0, [r7, #12]
 801edd0:	60b9      	str	r1, [r7, #8]
 801edd2:	607a      	str	r2, [r7, #4]
    byte* newV;
#else
    byte newV[DRBG_SEED_LEN];
#endif

    if (drbg == NULL) {
 801edd4:	68fb      	ldr	r3, [r7, #12]
 801edd6:	2b00      	cmp	r3, #0
 801edd8:	d101      	bne.n	801edde <Hash_DRBG_Reseed+0x16>
        return DRBG_FAILURE;
 801edda:	2301      	movs	r3, #1
 801eddc:	e04d      	b.n	801ee7a <Hash_DRBG_Reseed+0xb2>
    }

#ifdef WOLFSSL_SMALL_STACK
    newV = (byte*)XMALLOC(DRBG_SEED_LEN, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801edde:	2037      	movs	r0, #55	@ 0x37
 801ede0:	f7ff fe58 	bl	801ea94 <wolfSSL_Malloc>
 801ede4:	61b8      	str	r0, [r7, #24]
    if (newV == NULL) {
 801ede6:	69bb      	ldr	r3, [r7, #24]
 801ede8:	2b00      	cmp	r3, #0
 801edea:	d102      	bne.n	801edf2 <Hash_DRBG_Reseed+0x2a>
        return MEMORY_E;
 801edec:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801edf0:	e043      	b.n	801ee7a <Hash_DRBG_Reseed+0xb2>
    }
#endif
    XMEMSET(newV, 0, DRBG_SEED_LEN);
 801edf2:	2237      	movs	r2, #55	@ 0x37
 801edf4:	2100      	movs	r1, #0
 801edf6:	69b8      	ldr	r0, [r7, #24]
 801edf8:	f009 fb6a 	bl	80284d0 <memset>

    ret = Hash_df(drbg, newV, DRBG_SEED_LEN, drbgReseed,
                drbg->V, sizeof(drbg->V), seed, seedSz);
 801edfc:	68fb      	ldr	r3, [r7, #12]
 801edfe:	3304      	adds	r3, #4
    ret = Hash_df(drbg, newV, DRBG_SEED_LEN, drbgReseed,
 801ee00:	687a      	ldr	r2, [r7, #4]
 801ee02:	9203      	str	r2, [sp, #12]
 801ee04:	68ba      	ldr	r2, [r7, #8]
 801ee06:	9202      	str	r2, [sp, #8]
 801ee08:	2237      	movs	r2, #55	@ 0x37
 801ee0a:	9201      	str	r2, [sp, #4]
 801ee0c:	9300      	str	r3, [sp, #0]
 801ee0e:	2301      	movs	r3, #1
 801ee10:	2237      	movs	r2, #55	@ 0x37
 801ee12:	69b9      	ldr	r1, [r7, #24]
 801ee14:	68f8      	ldr	r0, [r7, #12]
 801ee16:	f7ff fee7 	bl	801ebe8 <Hash_df>
 801ee1a:	61f8      	str	r0, [r7, #28]
    if (ret == DRBG_SUCCESS) {
 801ee1c:	69fb      	ldr	r3, [r7, #28]
 801ee1e:	2b00      	cmp	r3, #0
 801ee20:	d11c      	bne.n	801ee5c <Hash_DRBG_Reseed+0x94>
        XMEMCPY(drbg->V, newV, sizeof(drbg->V));
 801ee22:	68fb      	ldr	r3, [r7, #12]
 801ee24:	3304      	adds	r3, #4
 801ee26:	2237      	movs	r2, #55	@ 0x37
 801ee28:	69b9      	ldr	r1, [r7, #24]
 801ee2a:	4618      	mov	r0, r3
 801ee2c:	f009 fbba 	bl	80285a4 <memcpy>
        ForceZero(newV, DRBG_SEED_LEN);
 801ee30:	2137      	movs	r1, #55	@ 0x37
 801ee32:	69b8      	ldr	r0, [r7, #24]
 801ee34:	f7ff fe88 	bl	801eb48 <ForceZero>

        ret = Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
 801ee38:	68fb      	ldr	r3, [r7, #12]
 801ee3a:	f103 013b 	add.w	r1, r3, #59	@ 0x3b
 801ee3e:	68fb      	ldr	r3, [r7, #12]
 801ee40:	3304      	adds	r3, #4
 801ee42:	2200      	movs	r2, #0
 801ee44:	9203      	str	r2, [sp, #12]
 801ee46:	2200      	movs	r2, #0
 801ee48:	9202      	str	r2, [sp, #8]
 801ee4a:	2237      	movs	r2, #55	@ 0x37
 801ee4c:	9201      	str	r2, [sp, #4]
 801ee4e:	9300      	str	r3, [sp, #0]
 801ee50:	2300      	movs	r3, #0
 801ee52:	2237      	movs	r2, #55	@ 0x37
 801ee54:	68f8      	ldr	r0, [r7, #12]
 801ee56:	f7ff fec7 	bl	801ebe8 <Hash_df>
 801ee5a:	61f8      	str	r0, [r7, #28]
                                    sizeof(drbg->V), NULL, 0);
    }
    if (ret == DRBG_SUCCESS) {
 801ee5c:	69fb      	ldr	r3, [r7, #28]
 801ee5e:	2b00      	cmp	r3, #0
 801ee60:	d102      	bne.n	801ee68 <Hash_DRBG_Reseed+0xa0>
        drbg->reseedCtr = 1;
 801ee62:	68fb      	ldr	r3, [r7, #12]
 801ee64:	2201      	movs	r2, #1
 801ee66:	601a      	str	r2, [r3, #0]
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(newV, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801ee68:	69bb      	ldr	r3, [r7, #24]
 801ee6a:	617b      	str	r3, [r7, #20]
 801ee6c:	697b      	ldr	r3, [r7, #20]
 801ee6e:	2b00      	cmp	r3, #0
 801ee70:	d002      	beq.n	801ee78 <Hash_DRBG_Reseed+0xb0>
 801ee72:	6978      	ldr	r0, [r7, #20]
 801ee74:	f7ff fe2a 	bl	801eacc <wolfSSL_Free>
#endif
    return ret;
 801ee78:	69fb      	ldr	r3, [r7, #28]
}
 801ee7a:	4618      	mov	r0, r3
 801ee7c:	3720      	adds	r7, #32
 801ee7e:	46bd      	mov	sp, r7
 801ee80:	bd80      	pop	{r7, pc}

0801ee82 <array_add_one>:

    return Hash_DRBG_Reseed((DRBG_internal *)rng->drbg, seed, seedSz);
}

static WC_INLINE void array_add_one(byte* data, word32 dataSz)
{
 801ee82:	b480      	push	{r7}
 801ee84:	b085      	sub	sp, #20
 801ee86:	af00      	add	r7, sp, #0
 801ee88:	6078      	str	r0, [r7, #4]
 801ee8a:	6039      	str	r1, [r7, #0]
    int i;
    for (i = (int)dataSz - 1; i >= 0; i--) {
 801ee8c:	683b      	ldr	r3, [r7, #0]
 801ee8e:	3b01      	subs	r3, #1
 801ee90:	60fb      	str	r3, [r7, #12]
 801ee92:	e00f      	b.n	801eeb4 <array_add_one+0x32>
        data[i]++;
 801ee94:	68fb      	ldr	r3, [r7, #12]
 801ee96:	687a      	ldr	r2, [r7, #4]
 801ee98:	4413      	add	r3, r2
 801ee9a:	781a      	ldrb	r2, [r3, #0]
 801ee9c:	3201      	adds	r2, #1
 801ee9e:	b2d2      	uxtb	r2, r2
 801eea0:	701a      	strb	r2, [r3, #0]
        if (data[i] != 0) break;
 801eea2:	68fb      	ldr	r3, [r7, #12]
 801eea4:	687a      	ldr	r2, [r7, #4]
 801eea6:	4413      	add	r3, r2
 801eea8:	781b      	ldrb	r3, [r3, #0]
 801eeaa:	2b00      	cmp	r3, #0
 801eeac:	d106      	bne.n	801eebc <array_add_one+0x3a>
    for (i = (int)dataSz - 1; i >= 0; i--) {
 801eeae:	68fb      	ldr	r3, [r7, #12]
 801eeb0:	3b01      	subs	r3, #1
 801eeb2:	60fb      	str	r3, [r7, #12]
 801eeb4:	68fb      	ldr	r3, [r7, #12]
 801eeb6:	2b00      	cmp	r3, #0
 801eeb8:	daec      	bge.n	801ee94 <array_add_one+0x12>
    }
}
 801eeba:	e000      	b.n	801eebe <array_add_one+0x3c>
        if (data[i] != 0) break;
 801eebc:	bf00      	nop
}
 801eebe:	bf00      	nop
 801eec0:	3714      	adds	r7, #20
 801eec2:	46bd      	mov	sp, r7
 801eec4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eec8:	4770      	bx	lr

0801eeca <Hash_gen>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_gen(DRBG_internal* drbg, byte* out, word32 outSz, const byte* V)
{
 801eeca:	b580      	push	{r7, lr}
 801eecc:	b0aa      	sub	sp, #168	@ 0xa8
 801eece:	af00      	add	r7, sp, #0
 801eed0:	60f8      	str	r0, [r7, #12]
 801eed2:	60b9      	str	r1, [r7, #8]
 801eed4:	607a      	str	r2, [r7, #4]
 801eed6:	603b      	str	r3, [r7, #0]
    int ret = DRBG_FAILURE;
 801eed8:	2301      	movs	r3, #1
 801eeda:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    wc_Sha256* sha = &drbg->sha256;
#else
    wc_Sha256 sha[1];
#endif

    if (drbg == NULL) {
 801eede:	68fb      	ldr	r3, [r7, #12]
 801eee0:	2b00      	cmp	r3, #0
 801eee2:	d101      	bne.n	801eee8 <Hash_gen+0x1e>
        return DRBG_FAILURE;
 801eee4:	2301      	movs	r3, #1
 801eee6:	e0c6      	b.n	801f076 <Hash_gen+0x1ac>
    }

#ifdef WOLFSSL_SMALL_STACK
    data = (byte*)XMALLOC(DRBG_SEED_LEN, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801eee8:	2037      	movs	r0, #55	@ 0x37
 801eeea:	f7ff fdd3 	bl	801ea94 <wolfSSL_Malloc>
 801eeee:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
    digest = (byte*)XMALLOC(WC_SHA256_DIGEST_SIZE, drbg->heap,
 801eef2:	2020      	movs	r0, #32
 801eef4:	f7ff fdce 	bl	801ea94 <wolfSSL_Malloc>
 801eef8:	f8c7 0098 	str.w	r0, [r7, #152]	@ 0x98
        DYNAMIC_TYPE_DIGEST);
    if (data == NULL || digest == NULL) {
 801eefc:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ef00:	2b00      	cmp	r3, #0
 801ef02:	d003      	beq.n	801ef0c <Hash_gen+0x42>
 801ef04:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ef08:	2b00      	cmp	r3, #0
 801ef0a:	d119      	bne.n	801ef40 <Hash_gen+0x76>
        XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801ef0c:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801ef10:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 801ef14:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801ef18:	2b00      	cmp	r3, #0
 801ef1a:	d003      	beq.n	801ef24 <Hash_gen+0x5a>
 801ef1c:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801ef20:	f7ff fdd4 	bl	801eacc <wolfSSL_Free>
        XFREE(data, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801ef24:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ef28:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 801ef2c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ef30:	2b00      	cmp	r3, #0
 801ef32:	d003      	beq.n	801ef3c <Hash_gen+0x72>
 801ef34:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801ef38:	f7ff fdc8 	bl	801eacc <wolfSSL_Free>
        return DRBG_FAILURE;
 801ef3c:	2301      	movs	r3, #1
 801ef3e:	e09a      	b.n	801f076 <Hash_gen+0x1ac>
#endif

    /* Special case: outSz is 0 and out is NULL. wc_Generate a block to save for
     * the continuous test. */

    if (outSz == 0) {
 801ef40:	687b      	ldr	r3, [r7, #4]
 801ef42:	2b00      	cmp	r3, #0
 801ef44:	d101      	bne.n	801ef4a <Hash_gen+0x80>
        outSz = 1;
 801ef46:	2301      	movs	r3, #1
 801ef48:	607b      	str	r3, [r7, #4]
    }

    len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
 801ef4a:	687b      	ldr	r3, [r7, #4]
 801ef4c:	095b      	lsrs	r3, r3, #5
 801ef4e:	687a      	ldr	r2, [r7, #4]
 801ef50:	f002 021f 	and.w	r2, r2, #31
 801ef54:	2a00      	cmp	r2, #0
 801ef56:	d001      	beq.n	801ef5c <Hash_gen+0x92>
 801ef58:	2201      	movs	r2, #1
 801ef5a:	e000      	b.n	801ef5e <Hash_gen+0x94>
 801ef5c:	2200      	movs	r2, #0
 801ef5e:	4413      	add	r3, r2
 801ef60:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    XMEMCPY(data, V, DRBG_SEED_LEN);
 801ef64:	2237      	movs	r2, #55	@ 0x37
 801ef66:	6839      	ldr	r1, [r7, #0]
 801ef68:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801ef6c:	f009 fb1a 	bl	80285a4 <memcpy>
    for (i = 0; i < len; i++) {
 801ef70:	2300      	movs	r3, #0
 801ef72:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801ef76:	e052      	b.n	801f01e <Hash_gen+0x154>
#ifndef WOLFSSL_SMALL_STACK_CACHE
    #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    #else
        ret = wc_InitSha256(sha);
 801ef78:	f107 0314 	add.w	r3, r7, #20
 801ef7c:	4618      	mov	r0, r3
 801ef7e:	f003 f839 	bl	8021ff4 <wc_InitSha256>
 801ef82:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
    #endif
        if (ret == 0)
 801ef86:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801ef8a:	2b00      	cmp	r3, #0
 801ef8c:	d109      	bne.n	801efa2 <Hash_gen+0xd8>
#endif
            ret = wc_Sha256Update(sha, data, DRBG_SEED_LEN);
 801ef8e:	f107 0314 	add.w	r3, r7, #20
 801ef92:	2237      	movs	r2, #55	@ 0x37
 801ef94:	f8d7 109c 	ldr.w	r1, [r7, #156]	@ 0x9c
 801ef98:	4618      	mov	r0, r3
 801ef9a:	f002 ff62 	bl	8021e62 <wc_Sha256Update>
 801ef9e:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
        if (ret == 0)
 801efa2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801efa6:	2b00      	cmp	r3, #0
 801efa8:	d108      	bne.n	801efbc <Hash_gen+0xf2>
            ret = wc_Sha256Final(sha, digest);
 801efaa:	f107 0314 	add.w	r3, r7, #20
 801efae:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801efb2:	4618      	mov	r0, r3
 801efb4:	f002 fff3 	bl	8021f9e <wc_Sha256Final>
 801efb8:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
#ifndef WOLFSSL_SMALL_STACK_CACHE
        wc_Sha256Free(sha);
 801efbc:	f107 0314 	add.w	r3, r7, #20
 801efc0:	4618      	mov	r0, r3
 801efc2:	f003 f828 	bl	8022016 <wc_Sha256Free>
#endif

        if (ret == 0) {
 801efc6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801efca:	2b00      	cmp	r3, #0
 801efcc:	d12e      	bne.n	801f02c <Hash_gen+0x162>
            if (out != NULL && outSz != 0) {
 801efce:	68bb      	ldr	r3, [r7, #8]
 801efd0:	2b00      	cmp	r3, #0
 801efd2:	d01f      	beq.n	801f014 <Hash_gen+0x14a>
 801efd4:	687b      	ldr	r3, [r7, #4]
 801efd6:	2b00      	cmp	r3, #0
 801efd8:	d01c      	beq.n	801f014 <Hash_gen+0x14a>
                if (outSz >= OUTPUT_BLOCK_LEN) {
 801efda:	687b      	ldr	r3, [r7, #4]
 801efdc:	2b1f      	cmp	r3, #31
 801efde:	d911      	bls.n	801f004 <Hash_gen+0x13a>
                    XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
 801efe0:	2220      	movs	r2, #32
 801efe2:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801efe6:	68b8      	ldr	r0, [r7, #8]
 801efe8:	f009 fadc 	bl	80285a4 <memcpy>
                    outSz -= OUTPUT_BLOCK_LEN;
 801efec:	687b      	ldr	r3, [r7, #4]
 801efee:	3b20      	subs	r3, #32
 801eff0:	607b      	str	r3, [r7, #4]
                    out += OUTPUT_BLOCK_LEN;
 801eff2:	68bb      	ldr	r3, [r7, #8]
 801eff4:	3320      	adds	r3, #32
 801eff6:	60bb      	str	r3, [r7, #8]
                    array_add_one(data, DRBG_SEED_LEN);
 801eff8:	2137      	movs	r1, #55	@ 0x37
 801effa:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801effe:	f7ff ff40 	bl	801ee82 <array_add_one>
 801f002:	e007      	b.n	801f014 <Hash_gen+0x14a>
                }
                else {
                    XMEMCPY(out, digest, outSz);
 801f004:	687a      	ldr	r2, [r7, #4]
 801f006:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 801f00a:	68b8      	ldr	r0, [r7, #8]
 801f00c:	f009 faca 	bl	80285a4 <memcpy>
                    outSz = 0;
 801f010:	2300      	movs	r3, #0
 801f012:	607b      	str	r3, [r7, #4]
    for (i = 0; i < len; i++) {
 801f014:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801f018:	3301      	adds	r3, #1
 801f01a:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801f01e:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 801f022:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f026:	429a      	cmp	r2, r3
 801f028:	d3a6      	bcc.n	801ef78 <Hash_gen+0xae>
 801f02a:	e000      	b.n	801f02e <Hash_gen+0x164>
                }
            }
        }
        else {
            /* wc_Sha256Update or wc_Sha256Final returned error */
            break;
 801f02c:	bf00      	nop
        }
    }
    ForceZero(data, DRBG_SEED_LEN);
 801f02e:	2137      	movs	r1, #55	@ 0x37
 801f030:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801f034:	f7ff fd88 	bl	801eb48 <ForceZero>

#ifdef WOLFSSL_SMALL_STACK
    XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801f038:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801f03c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 801f040:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801f044:	2b00      	cmp	r3, #0
 801f046:	d003      	beq.n	801f050 <Hash_gen+0x186>
 801f048:	f8d7 0090 	ldr.w	r0, [r7, #144]	@ 0x90
 801f04c:	f7ff fd3e 	bl	801eacc <wolfSSL_Free>
    XFREE(data, drbg->heap, DYNAMIC_TYPE_TMP_BUFFER);
 801f050:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801f054:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801f058:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801f05c:	2b00      	cmp	r3, #0
 801f05e:	d003      	beq.n	801f068 <Hash_gen+0x19e>
 801f060:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801f064:	f7ff fd32 	bl	801eacc <wolfSSL_Free>
#endif

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801f068:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 801f06c:	2b00      	cmp	r3, #0
 801f06e:	bf14      	ite	ne
 801f070:	2301      	movne	r3, #1
 801f072:	2300      	moveq	r3, #0
 801f074:	b2db      	uxtb	r3, r3
}
 801f076:	4618      	mov	r0, r3
 801f078:	37a8      	adds	r7, #168	@ 0xa8
 801f07a:	46bd      	mov	sp, r7
 801f07c:	bd80      	pop	{r7, pc}

0801f07e <array_add>:

static WC_INLINE void array_add(byte* d, word32 dLen, const byte* s, word32 sLen)
{
 801f07e:	b480      	push	{r7}
 801f080:	b089      	sub	sp, #36	@ 0x24
 801f082:	af00      	add	r7, sp, #0
 801f084:	60f8      	str	r0, [r7, #12]
 801f086:	60b9      	str	r1, [r7, #8]
 801f088:	607a      	str	r2, [r7, #4]
 801f08a:	603b      	str	r3, [r7, #0]
    if (dLen > 0 && sLen > 0 && dLen >= sLen) {
 801f08c:	68bb      	ldr	r3, [r7, #8]
 801f08e:	2b00      	cmp	r3, #0
 801f090:	d047      	beq.n	801f122 <array_add+0xa4>
 801f092:	683b      	ldr	r3, [r7, #0]
 801f094:	2b00      	cmp	r3, #0
 801f096:	d044      	beq.n	801f122 <array_add+0xa4>
 801f098:	68ba      	ldr	r2, [r7, #8]
 801f09a:	683b      	ldr	r3, [r7, #0]
 801f09c:	429a      	cmp	r2, r3
 801f09e:	d340      	bcc.n	801f122 <array_add+0xa4>
        int sIdx, dIdx;
        word16 carry = 0;
 801f0a0:	2300      	movs	r3, #0
 801f0a2:	82fb      	strh	r3, [r7, #22]

        dIdx = (int)dLen - 1;
 801f0a4:	68bb      	ldr	r3, [r7, #8]
 801f0a6:	3b01      	subs	r3, #1
 801f0a8:	61bb      	str	r3, [r7, #24]
        for (sIdx = (int)sLen - 1; sIdx >= 0; sIdx--) {
 801f0aa:	683b      	ldr	r3, [r7, #0]
 801f0ac:	3b01      	subs	r3, #1
 801f0ae:	61fb      	str	r3, [r7, #28]
 801f0b0:	e01c      	b.n	801f0ec <array_add+0x6e>
            carry = (word16)(carry + d[dIdx] + s[sIdx]);
 801f0b2:	69bb      	ldr	r3, [r7, #24]
 801f0b4:	68fa      	ldr	r2, [r7, #12]
 801f0b6:	4413      	add	r3, r2
 801f0b8:	781b      	ldrb	r3, [r3, #0]
 801f0ba:	461a      	mov	r2, r3
 801f0bc:	8afb      	ldrh	r3, [r7, #22]
 801f0be:	4413      	add	r3, r2
 801f0c0:	b29b      	uxth	r3, r3
 801f0c2:	69fa      	ldr	r2, [r7, #28]
 801f0c4:	6879      	ldr	r1, [r7, #4]
 801f0c6:	440a      	add	r2, r1
 801f0c8:	7812      	ldrb	r2, [r2, #0]
 801f0ca:	4413      	add	r3, r2
 801f0cc:	82fb      	strh	r3, [r7, #22]
            d[dIdx] = (byte)carry;
 801f0ce:	69bb      	ldr	r3, [r7, #24]
 801f0d0:	68fa      	ldr	r2, [r7, #12]
 801f0d2:	4413      	add	r3, r2
 801f0d4:	8afa      	ldrh	r2, [r7, #22]
 801f0d6:	b2d2      	uxtb	r2, r2
 801f0d8:	701a      	strb	r2, [r3, #0]
            carry >>= 8;
 801f0da:	8afb      	ldrh	r3, [r7, #22]
 801f0dc:	0a1b      	lsrs	r3, r3, #8
 801f0de:	82fb      	strh	r3, [r7, #22]
            dIdx--;
 801f0e0:	69bb      	ldr	r3, [r7, #24]
 801f0e2:	3b01      	subs	r3, #1
 801f0e4:	61bb      	str	r3, [r7, #24]
        for (sIdx = (int)sLen - 1; sIdx >= 0; sIdx--) {
 801f0e6:	69fb      	ldr	r3, [r7, #28]
 801f0e8:	3b01      	subs	r3, #1
 801f0ea:	61fb      	str	r3, [r7, #28]
 801f0ec:	69fb      	ldr	r3, [r7, #28]
 801f0ee:	2b00      	cmp	r3, #0
 801f0f0:	dadf      	bge.n	801f0b2 <array_add+0x34>
        }

        for (; dIdx >= 0; dIdx--) {
 801f0f2:	e013      	b.n	801f11c <array_add+0x9e>
            carry = (word16)(carry + d[dIdx]);
 801f0f4:	69bb      	ldr	r3, [r7, #24]
 801f0f6:	68fa      	ldr	r2, [r7, #12]
 801f0f8:	4413      	add	r3, r2
 801f0fa:	781b      	ldrb	r3, [r3, #0]
 801f0fc:	461a      	mov	r2, r3
 801f0fe:	8afb      	ldrh	r3, [r7, #22]
 801f100:	4413      	add	r3, r2
 801f102:	82fb      	strh	r3, [r7, #22]
            d[dIdx] = (byte)carry;
 801f104:	69bb      	ldr	r3, [r7, #24]
 801f106:	68fa      	ldr	r2, [r7, #12]
 801f108:	4413      	add	r3, r2
 801f10a:	8afa      	ldrh	r2, [r7, #22]
 801f10c:	b2d2      	uxtb	r2, r2
 801f10e:	701a      	strb	r2, [r3, #0]
            carry >>= 8;
 801f110:	8afb      	ldrh	r3, [r7, #22]
 801f112:	0a1b      	lsrs	r3, r3, #8
 801f114:	82fb      	strh	r3, [r7, #22]
        for (; dIdx >= 0; dIdx--) {
 801f116:	69bb      	ldr	r3, [r7, #24]
 801f118:	3b01      	subs	r3, #1
 801f11a:	61bb      	str	r3, [r7, #24]
 801f11c:	69bb      	ldr	r3, [r7, #24]
 801f11e:	2b00      	cmp	r3, #0
 801f120:	dae8      	bge.n	801f0f4 <array_add+0x76>
        }
    }
}
 801f122:	bf00      	nop
 801f124:	3724      	adds	r7, #36	@ 0x24
 801f126:	46bd      	mov	sp, r7
 801f128:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f12c:	4770      	bx	lr
	...

0801f130 <Hash_DRBG_Generate>:

/* Returns: DRBG_SUCCESS, DRBG_NEED_RESEED, or DRBG_FAILURE */
static int Hash_DRBG_Generate(DRBG_internal* drbg, byte* out, word32 outSz)
{
 801f130:	b580      	push	{r7, lr}
 801f132:	b0a6      	sub	sp, #152	@ 0x98
 801f134:	af00      	add	r7, sp, #0
 801f136:	60f8      	str	r0, [r7, #12]
 801f138:	60b9      	str	r1, [r7, #8]
 801f13a:	607a      	str	r2, [r7, #4]
    wc_Sha256 sha[1];
#endif
    byte type;
    word32 reseedCtr;

    if (drbg == NULL) {
 801f13c:	68fb      	ldr	r3, [r7, #12]
 801f13e:	2b00      	cmp	r3, #0
 801f140:	d101      	bne.n	801f146 <Hash_DRBG_Generate+0x16>
        return DRBG_FAILURE;
 801f142:	2301      	movs	r3, #1
 801f144:	e09b      	b.n	801f27e <Hash_DRBG_Generate+0x14e>
    }

    if (drbg->reseedCtr == RESEED_INTERVAL) {
 801f146:	68fb      	ldr	r3, [r7, #12]
 801f148:	681b      	ldr	r3, [r3, #0]
 801f14a:	4a4f      	ldr	r2, [pc, #316]	@ (801f288 <Hash_DRBG_Generate+0x158>)
 801f14c:	4293      	cmp	r3, r2
 801f14e:	d101      	bne.n	801f154 <Hash_DRBG_Generate+0x24>
#if FIPS_VERSION3_GE(6,0,0)
        printf("Reseed triggered\n");
#endif
        return DRBG_NEED_RESEED;
 801f150:	2302      	movs	r3, #2
 801f152:	e094      	b.n	801f27e <Hash_DRBG_Generate+0x14e>
    }
    else {
    #ifndef WOLFSSL_SMALL_STACK
        byte digest[WC_SHA256_DIGEST_SIZE];
    #else
        byte* digest = (byte*)XMALLOC(WC_SHA256_DIGEST_SIZE, drbg->heap,
 801f154:	2020      	movs	r0, #32
 801f156:	f7ff fc9d 	bl	801ea94 <wolfSSL_Malloc>
 801f15a:	f8c7 0090 	str.w	r0, [r7, #144]	@ 0x90
            DYNAMIC_TYPE_DIGEST);
        if (digest == NULL)
 801f15e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801f162:	2b00      	cmp	r3, #0
 801f164:	d101      	bne.n	801f16a <Hash_DRBG_Generate+0x3a>
            return DRBG_FAILURE;
 801f166:	2301      	movs	r3, #1
 801f168:	e089      	b.n	801f27e <Hash_DRBG_Generate+0x14e>
    #endif

        type = drbgGenerateH;
 801f16a:	2303      	movs	r3, #3
 801f16c:	76fb      	strb	r3, [r7, #27]
        reseedCtr = drbg->reseedCtr;
 801f16e:	68fb      	ldr	r3, [r7, #12]
 801f170:	681b      	ldr	r3, [r3, #0]
 801f172:	617b      	str	r3, [r7, #20]

        ret = Hash_gen(drbg, out, outSz, drbg->V);
 801f174:	68fb      	ldr	r3, [r7, #12]
 801f176:	3304      	adds	r3, #4
 801f178:	687a      	ldr	r2, [r7, #4]
 801f17a:	68b9      	ldr	r1, [r7, #8]
 801f17c:	68f8      	ldr	r0, [r7, #12]
 801f17e:	f7ff fea4 	bl	801eeca <Hash_gen>
 801f182:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
        if (ret == DRBG_SUCCESS) {
 801f186:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f18a:	2b00      	cmp	r3, #0
 801f18c:	d15f      	bne.n	801f24e <Hash_DRBG_Generate+0x11e>
#ifndef WOLFSSL_SMALL_STACK_CACHE
        #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
            ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
        #else
            ret = wc_InitSha256(sha);
 801f18e:	f107 031c 	add.w	r3, r7, #28
 801f192:	4618      	mov	r0, r3
 801f194:	f002 ff2e 	bl	8021ff4 <wc_InitSha256>
 801f198:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
        #endif
            if (ret == 0)
 801f19c:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f1a0:	2b00      	cmp	r3, #0
 801f1a2:	d109      	bne.n	801f1b8 <Hash_DRBG_Generate+0x88>
#endif
                ret = wc_Sha256Update(sha, &type, sizeof(type));
 801f1a4:	f107 011b 	add.w	r1, r7, #27
 801f1a8:	f107 031c 	add.w	r3, r7, #28
 801f1ac:	2201      	movs	r2, #1
 801f1ae:	4618      	mov	r0, r3
 801f1b0:	f002 fe57 	bl	8021e62 <wc_Sha256Update>
 801f1b4:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
            if (ret == 0)
 801f1b8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f1bc:	2b00      	cmp	r3, #0
 801f1be:	d109      	bne.n	801f1d4 <Hash_DRBG_Generate+0xa4>
                ret = wc_Sha256Update(sha, drbg->V, sizeof(drbg->V));
 801f1c0:	68fb      	ldr	r3, [r7, #12]
 801f1c2:	1d19      	adds	r1, r3, #4
 801f1c4:	f107 031c 	add.w	r3, r7, #28
 801f1c8:	2237      	movs	r2, #55	@ 0x37
 801f1ca:	4618      	mov	r0, r3
 801f1cc:	f002 fe49 	bl	8021e62 <wc_Sha256Update>
 801f1d0:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
            if (ret == 0)
 801f1d4:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f1d8:	2b00      	cmp	r3, #0
 801f1da:	d108      	bne.n	801f1ee <Hash_DRBG_Generate+0xbe>
                ret = wc_Sha256Final(sha, digest);
 801f1dc:	f107 031c 	add.w	r3, r7, #28
 801f1e0:	f8d7 1090 	ldr.w	r1, [r7, #144]	@ 0x90
 801f1e4:	4618      	mov	r0, r3
 801f1e6:	f002 feda 	bl	8021f9e <wc_Sha256Final>
 801f1ea:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94

#ifndef WOLFSSL_SMALL_STACK_CACHE
            wc_Sha256Free(sha);
 801f1ee:	f107 031c 	add.w	r3, r7, #28
 801f1f2:	4618      	mov	r0, r3
 801f1f4:	f002 ff0f 	bl	8022016 <wc_Sha256Free>
#endif

            if (ret == 0) {
 801f1f8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f1fc:	2b00      	cmp	r3, #0
 801f1fe:	d121      	bne.n	801f244 <Hash_DRBG_Generate+0x114>
                array_add(drbg->V, sizeof(drbg->V), digest, WC_SHA256_DIGEST_SIZE);
 801f200:	68fb      	ldr	r3, [r7, #12]
 801f202:	1d18      	adds	r0, r3, #4
 801f204:	2320      	movs	r3, #32
 801f206:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 801f20a:	2137      	movs	r1, #55	@ 0x37
 801f20c:	f7ff ff37 	bl	801f07e <array_add>
                array_add(drbg->V, sizeof(drbg->V), drbg->C, sizeof(drbg->C));
 801f210:	68fb      	ldr	r3, [r7, #12]
 801f212:	1d18      	adds	r0, r3, #4
 801f214:	68fb      	ldr	r3, [r7, #12]
 801f216:	f103 023b 	add.w	r2, r3, #59	@ 0x3b
 801f21a:	2337      	movs	r3, #55	@ 0x37
 801f21c:	2137      	movs	r1, #55	@ 0x37
 801f21e:	f7ff ff2e 	bl	801f07e <array_add>
            #ifdef LITTLE_ENDIAN_ORDER
                reseedCtr = ByteReverseWord32(reseedCtr);
 801f222:	697b      	ldr	r3, [r7, #20]
 801f224:	4618      	mov	r0, r3
 801f226:	f7ff fc78 	bl	801eb1a <ByteReverseWord32>
 801f22a:	4603      	mov	r3, r0
 801f22c:	617b      	str	r3, [r7, #20]
            #endif
                array_add(drbg->V, sizeof(drbg->V),
 801f22e:	68fb      	ldr	r3, [r7, #12]
 801f230:	1d18      	adds	r0, r3, #4
 801f232:	f107 0214 	add.w	r2, r7, #20
 801f236:	2304      	movs	r3, #4
 801f238:	2137      	movs	r1, #55	@ 0x37
 801f23a:	f7ff ff20 	bl	801f07e <array_add>
                                          (byte*)&reseedCtr, sizeof(reseedCtr));
                ret = DRBG_SUCCESS;
 801f23e:	2300      	movs	r3, #0
 801f240:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
            }
            drbg->reseedCtr++;
 801f244:	68fb      	ldr	r3, [r7, #12]
 801f246:	681b      	ldr	r3, [r3, #0]
 801f248:	1c5a      	adds	r2, r3, #1
 801f24a:	68fb      	ldr	r3, [r7, #12]
 801f24c:	601a      	str	r2, [r3, #0]
        }
        ForceZero(digest, WC_SHA256_DIGEST_SIZE);
 801f24e:	2120      	movs	r1, #32
 801f250:	f8d7 0090 	ldr.w	r0, [r7, #144]	@ 0x90
 801f254:	f7ff fc78 	bl	801eb48 <ForceZero>
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(digest, drbg->heap, DYNAMIC_TYPE_DIGEST);
 801f258:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 801f25c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801f260:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801f264:	2b00      	cmp	r3, #0
 801f266:	d003      	beq.n	801f270 <Hash_DRBG_Generate+0x140>
 801f268:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801f26c:	f7ff fc2e 	bl	801eacc <wolfSSL_Free>
    #endif
    }

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801f270:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801f274:	2b00      	cmp	r3, #0
 801f276:	bf14      	ite	ne
 801f278:	2301      	movne	r3, #1
 801f27a:	2300      	moveq	r3, #0
 801f27c:	b2db      	uxtb	r3, r3
}
 801f27e:	4618      	mov	r0, r3
 801f280:	3798      	adds	r7, #152	@ 0x98
 801f282:	46bd      	mov	sp, r7
 801f284:	bd80      	pop	{r7, pc}
 801f286:	bf00      	nop
 801f288:	000f4240 	.word	0x000f4240

0801f28c <Hash_DRBG_Instantiate>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Instantiate(DRBG_internal* drbg, const byte* seed, word32 seedSz,
                                             const byte* nonce, word32 nonceSz,
                                             void* heap, int devId)
{
 801f28c:	b580      	push	{r7, lr}
 801f28e:	b08a      	sub	sp, #40	@ 0x28
 801f290:	af04      	add	r7, sp, #16
 801f292:	60f8      	str	r0, [r7, #12]
 801f294:	60b9      	str	r1, [r7, #8]
 801f296:	607a      	str	r2, [r7, #4]
 801f298:	603b      	str	r3, [r7, #0]
    int ret = DRBG_FAILURE;
 801f29a:	2301      	movs	r3, #1
 801f29c:	617b      	str	r3, [r7, #20]

    XMEMSET(drbg, 0, sizeof(DRBG_internal));
 801f29e:	2278      	movs	r2, #120	@ 0x78
 801f2a0:	2100      	movs	r1, #0
 801f2a2:	68f8      	ldr	r0, [r7, #12]
 801f2a4:	f009 f914 	bl	80284d0 <memset>
    drbg->heap = heap;
 801f2a8:	68fb      	ldr	r3, [r7, #12]
 801f2aa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801f2ac:	675a      	str	r2, [r3, #116]	@ 0x74
    #endif
    if (ret != 0)
        return ret;
#endif

    if (Hash_df(drbg, drbg->V, sizeof(drbg->V), drbgInitV, seed, seedSz,
 801f2ae:	68fb      	ldr	r3, [r7, #12]
 801f2b0:	1d19      	adds	r1, r3, #4
 801f2b2:	6a3b      	ldr	r3, [r7, #32]
 801f2b4:	9303      	str	r3, [sp, #12]
 801f2b6:	683b      	ldr	r3, [r7, #0]
 801f2b8:	9302      	str	r3, [sp, #8]
 801f2ba:	687b      	ldr	r3, [r7, #4]
 801f2bc:	9301      	str	r3, [sp, #4]
 801f2be:	68bb      	ldr	r3, [r7, #8]
 801f2c0:	9300      	str	r3, [sp, #0]
 801f2c2:	2304      	movs	r3, #4
 801f2c4:	2237      	movs	r2, #55	@ 0x37
 801f2c6:	68f8      	ldr	r0, [r7, #12]
 801f2c8:	f7ff fc8e 	bl	801ebe8 <Hash_df>
 801f2cc:	4603      	mov	r3, r0
 801f2ce:	2b00      	cmp	r3, #0
 801f2d0:	d118      	bne.n	801f304 <Hash_DRBG_Instantiate+0x78>
                                              nonce, nonceSz) == DRBG_SUCCESS &&
        Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
 801f2d2:	68fb      	ldr	r3, [r7, #12]
 801f2d4:	f103 013b 	add.w	r1, r3, #59	@ 0x3b
 801f2d8:	68fb      	ldr	r3, [r7, #12]
 801f2da:	3304      	adds	r3, #4
 801f2dc:	2200      	movs	r2, #0
 801f2de:	9203      	str	r2, [sp, #12]
 801f2e0:	2200      	movs	r2, #0
 801f2e2:	9202      	str	r2, [sp, #8]
 801f2e4:	2237      	movs	r2, #55	@ 0x37
 801f2e6:	9201      	str	r2, [sp, #4]
 801f2e8:	9300      	str	r3, [sp, #0]
 801f2ea:	2300      	movs	r3, #0
 801f2ec:	2237      	movs	r2, #55	@ 0x37
 801f2ee:	68f8      	ldr	r0, [r7, #12]
 801f2f0:	f7ff fc7a 	bl	801ebe8 <Hash_df>
 801f2f4:	4603      	mov	r3, r0
                                              nonce, nonceSz) == DRBG_SUCCESS &&
 801f2f6:	2b00      	cmp	r3, #0
 801f2f8:	d104      	bne.n	801f304 <Hash_DRBG_Instantiate+0x78>
                                    sizeof(drbg->V), NULL, 0) == DRBG_SUCCESS) {

        drbg->reseedCtr = 1;
 801f2fa:	68fb      	ldr	r3, [r7, #12]
 801f2fc:	2201      	movs	r2, #1
 801f2fe:	601a      	str	r2, [r3, #0]
        ret = DRBG_SUCCESS;
 801f300:	2300      	movs	r3, #0
 801f302:	617b      	str	r3, [r7, #20]
    }

    return ret;
 801f304:	697b      	ldr	r3, [r7, #20]
}
 801f306:	4618      	mov	r0, r3
 801f308:	3718      	adds	r7, #24
 801f30a:	46bd      	mov	sp, r7
 801f30c:	bd80      	pop	{r7, pc}

0801f30e <Hash_DRBG_Uninstantiate>:

/* Returns: DRBG_SUCCESS or DRBG_FAILURE */
static int Hash_DRBG_Uninstantiate(DRBG_internal* drbg)
{
 801f30e:	b580      	push	{r7, lr}
 801f310:	b086      	sub	sp, #24
 801f312:	af00      	add	r7, sp, #0
 801f314:	6078      	str	r0, [r7, #4]
    word32 i;
    int    compareSum = 0;
 801f316:	2300      	movs	r3, #0
 801f318:	613b      	str	r3, [r7, #16]
    byte*  compareDrbg = (byte*)drbg;
 801f31a:	687b      	ldr	r3, [r7, #4]
 801f31c:	60fb      	str	r3, [r7, #12]

#ifdef WOLFSSL_SMALL_STACK_CACHE
    wc_Sha256Free(&drbg->sha256);
#endif

    ForceZero(drbg, sizeof(DRBG_internal));
 801f31e:	2178      	movs	r1, #120	@ 0x78
 801f320:	6878      	ldr	r0, [r7, #4]
 801f322:	f7ff fc11 	bl	801eb48 <ForceZero>

    for (i = 0; i < sizeof(DRBG_internal); i++) {
 801f326:	2300      	movs	r3, #0
 801f328:	617b      	str	r3, [r7, #20]
 801f32a:	e00a      	b.n	801f342 <Hash_DRBG_Uninstantiate+0x34>
        compareSum |= compareDrbg[i] ^ 0;
 801f32c:	68fa      	ldr	r2, [r7, #12]
 801f32e:	697b      	ldr	r3, [r7, #20]
 801f330:	4413      	add	r3, r2
 801f332:	781b      	ldrb	r3, [r3, #0]
 801f334:	461a      	mov	r2, r3
 801f336:	693b      	ldr	r3, [r7, #16]
 801f338:	4313      	orrs	r3, r2
 801f33a:	613b      	str	r3, [r7, #16]
    for (i = 0; i < sizeof(DRBG_internal); i++) {
 801f33c:	697b      	ldr	r3, [r7, #20]
 801f33e:	3301      	adds	r3, #1
 801f340:	617b      	str	r3, [r7, #20]
 801f342:	697b      	ldr	r3, [r7, #20]
 801f344:	2b77      	cmp	r3, #119	@ 0x77
 801f346:	d9f1      	bls.n	801f32c <Hash_DRBG_Uninstantiate+0x1e>
    }

    return (compareSum == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
 801f348:	693b      	ldr	r3, [r7, #16]
 801f34a:	2b00      	cmp	r3, #0
 801f34c:	bf14      	ite	ne
 801f34e:	2301      	movne	r3, #1
 801f350:	2300      	moveq	r3, #0
 801f352:	b2db      	uxtb	r3, r3
}
 801f354:	4618      	mov	r0, r3
 801f356:	3718      	adds	r7, #24
 801f358:	46bd      	mov	sp, r7
 801f35a:	bd80      	pop	{r7, pc}

0801f35c <wc_RNG_TestSeed>:


int wc_RNG_TestSeed(const byte* seed, word32 seedSz)
{
 801f35c:	b580      	push	{r7, lr}
 801f35e:	b086      	sub	sp, #24
 801f360:	af00      	add	r7, sp, #0
 801f362:	6078      	str	r0, [r7, #4]
 801f364:	6039      	str	r1, [r7, #0]
    int ret = 0;
 801f366:	2300      	movs	r3, #0
 801f368:	617b      	str	r3, [r7, #20]

    /* Check the seed for duplicate words. */
    word32 seedIdx = 0;
 801f36a:	2300      	movs	r3, #0
 801f36c:	613b      	str	r3, [r7, #16]
    word32 scratchSz = min(SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ);
 801f36e:	683b      	ldr	r3, [r7, #0]
 801f370:	3b04      	subs	r3, #4
 801f372:	4619      	mov	r1, r3
 801f374:	2004      	movs	r0, #4
 801f376:	f7ff fc27 	bl	801ebc8 <min>
 801f37a:	60f8      	str	r0, [r7, #12]

    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
 801f37c:	e01b      	b.n	801f3b6 <wc_RNG_TestSeed+0x5a>
        if (ConstantCompare(seed + seedIdx,
 801f37e:	687a      	ldr	r2, [r7, #4]
 801f380:	693b      	ldr	r3, [r7, #16]
 801f382:	18d0      	adds	r0, r2, r3
                            seed + seedIdx + scratchSz,
 801f384:	693a      	ldr	r2, [r7, #16]
 801f386:	68fb      	ldr	r3, [r7, #12]
 801f388:	4413      	add	r3, r2
        if (ConstantCompare(seed + seedIdx,
 801f38a:	687a      	ldr	r2, [r7, #4]
 801f38c:	4413      	add	r3, r2
 801f38e:	68fa      	ldr	r2, [r7, #12]
 801f390:	4619      	mov	r1, r3
 801f392:	f7ff fbf2 	bl	801eb7a <ConstantCompare>
 801f396:	4603      	mov	r3, r0
 801f398:	2b00      	cmp	r3, #0
 801f39a:	d101      	bne.n	801f3a0 <wc_RNG_TestSeed+0x44>
                            (int)scratchSz) == 0) {

            ret = DRBG_CONT_FAILURE;
 801f39c:	2303      	movs	r3, #3
 801f39e:	617b      	str	r3, [r7, #20]
        }
        seedIdx += SEED_BLOCK_SZ;
 801f3a0:	693b      	ldr	r3, [r7, #16]
 801f3a2:	3304      	adds	r3, #4
 801f3a4:	613b      	str	r3, [r7, #16]
        scratchSz = min(SEED_BLOCK_SZ, (seedSz - seedIdx));
 801f3a6:	683a      	ldr	r2, [r7, #0]
 801f3a8:	693b      	ldr	r3, [r7, #16]
 801f3aa:	1ad3      	subs	r3, r2, r3
 801f3ac:	4619      	mov	r1, r3
 801f3ae:	2004      	movs	r0, #4
 801f3b0:	f7ff fc0a 	bl	801ebc8 <min>
 801f3b4:	60f8      	str	r0, [r7, #12]
    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
 801f3b6:	683b      	ldr	r3, [r7, #0]
 801f3b8:	3b04      	subs	r3, #4
 801f3ba:	693a      	ldr	r2, [r7, #16]
 801f3bc:	429a      	cmp	r2, r3
 801f3be:	d3de      	bcc.n	801f37e <wc_RNG_TestSeed+0x22>
    }

    return ret;
 801f3c0:	697b      	ldr	r3, [r7, #20]
}
 801f3c2:	4618      	mov	r0, r3
 801f3c4:	3718      	adds	r7, #24
 801f3c6:	46bd      	mov	sp, r7
 801f3c8:	bd80      	pop	{r7, pc}

0801f3ca <_InitRng>:

#endif /* HAVE_ENTROPY_MEMUSE */

static int _InitRng(WC_RNG* rng, byte* nonce, word32 nonceSz,
                    void* heap, int devId)
{
 801f3ca:	b590      	push	{r4, r7, lr}
 801f3cc:	b08f      	sub	sp, #60	@ 0x3c
 801f3ce:	af04      	add	r7, sp, #16
 801f3d0:	60f8      	str	r0, [r7, #12]
 801f3d2:	60b9      	str	r1, [r7, #8]
 801f3d4:	607a      	str	r2, [r7, #4]
 801f3d6:	603b      	str	r3, [r7, #0]
    int ret = 0;
 801f3d8:	2300      	movs	r3, #0
 801f3da:	627b      	str	r3, [r7, #36]	@ 0x24
#ifdef HAVE_HASHDRBG
    word32 seedSz = SEED_SZ + SEED_BLOCK_SZ;
 801f3dc:	2324      	movs	r3, #36	@ 0x24
 801f3de:	623b      	str	r3, [r7, #32]
#endif

    (void)nonce;
    (void)nonceSz;

    if (rng == NULL)
 801f3e0:	68fb      	ldr	r3, [r7, #12]
 801f3e2:	2b00      	cmp	r3, #0
 801f3e4:	d102      	bne.n	801f3ec <_InitRng+0x22>
        return BAD_FUNC_ARG;
 801f3e6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f3ea:	e0a7      	b.n	801f53c <_InitRng+0x172>
    if (nonce == NULL && nonceSz != 0)
 801f3ec:	68bb      	ldr	r3, [r7, #8]
 801f3ee:	2b00      	cmp	r3, #0
 801f3f0:	d105      	bne.n	801f3fe <_InitRng+0x34>
 801f3f2:	687b      	ldr	r3, [r7, #4]
 801f3f4:	2b00      	cmp	r3, #0
 801f3f6:	d002      	beq.n	801f3fe <_InitRng+0x34>
        return BAD_FUNC_ARG;
 801f3f8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f3fc:	e09e      	b.n	801f53c <_InitRng+0x172>

#ifdef WOLFSSL_HEAP_TEST
    rng->heap = (void*)WOLFSSL_HEAP_TEST;
    (void)heap;
#else
    rng->heap = heap;
 801f3fe:	68fb      	ldr	r3, [r7, #12]
 801f400:	683a      	ldr	r2, [r7, #0]
 801f402:	605a      	str	r2, [r3, #4]
    (void)devId;
#endif

#ifdef HAVE_HASHDRBG
    /* init the DBRG to known values */
    rng->drbg = NULL;
 801f404:	68fb      	ldr	r3, [r7, #12]
 801f406:	2200      	movs	r2, #0
 801f408:	609a      	str	r2, [r3, #8]
    rng->status = DRBG_NOT_INIT;
 801f40a:	68fb      	ldr	r3, [r7, #12]
 801f40c:	2200      	movs	r2, #0
 801f40e:	731a      	strb	r2, [r3, #12]
    ret = 0; /* success */
#else

 /* not CUSTOM_RAND_GENERATE_BLOCK follows */
#ifdef HAVE_HASHDRBG
    if (nonceSz == 0) {
 801f410:	687b      	ldr	r3, [r7, #4]
 801f412:	2b00      	cmp	r3, #0
 801f414:	d101      	bne.n	801f41a <_InitRng+0x50>
        seedSz = MAX_SEED_SZ;
 801f416:	2334      	movs	r3, #52	@ 0x34
 801f418:	623b      	str	r3, [r7, #32]
    }

    ret = wc_RNG_HealthTestLocal(0, rng->heap, devId);
 801f41a:	68fb      	ldr	r3, [r7, #12]
 801f41c:	685b      	ldr	r3, [r3, #4]
 801f41e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f420:	4619      	mov	r1, r3
 801f422:	2000      	movs	r0, #0
 801f424:	f000 fa02 	bl	801f82c <wc_RNG_HealthTestLocal>
 801f428:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret != 0) {
 801f42a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f42c:	2b00      	cmp	r3, #0
 801f42e:	d002      	beq.n	801f436 <_InitRng+0x6c>
        #if defined(DEBUG_WOLFSSL)
        WOLFSSL_MSG_EX("wc_RNG_HealthTestLocal failed err = %d", ret);
        #endif
        ret = DRBG_CONT_FAILURE;
 801f430:	2303      	movs	r3, #3
 801f432:	627b      	str	r3, [r7, #36]	@ 0x24
 801f434:	e061      	b.n	801f4fa <_InitRng+0x130>
    }
    else {
    #ifndef WOLFSSL_SMALL_STACK
        byte seed[MAX_SEED_SZ];
    #else
        byte* seed = (byte*)XMALLOC(MAX_SEED_SZ, rng->heap,
 801f436:	2034      	movs	r0, #52	@ 0x34
 801f438:	f7ff fb2c 	bl	801ea94 <wolfSSL_Malloc>
 801f43c:	61f8      	str	r0, [r7, #28]
            DYNAMIC_TYPE_SEED);
        if (seed == NULL)
 801f43e:	69fb      	ldr	r3, [r7, #28]
 801f440:	2b00      	cmp	r3, #0
 801f442:	d102      	bne.n	801f44a <_InitRng+0x80>
            return MEMORY_E;
 801f444:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f448:	e078      	b.n	801f53c <_InitRng+0x172>
    #endif

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
        rng->drbg =
                (struct DRBG*)XMALLOC(sizeof(DRBG_internal), rng->heap,
 801f44a:	2078      	movs	r0, #120	@ 0x78
 801f44c:	f7ff fb22 	bl	801ea94 <wolfSSL_Malloc>
 801f450:	4602      	mov	r2, r0
        rng->drbg =
 801f452:	68fb      	ldr	r3, [r7, #12]
 801f454:	609a      	str	r2, [r3, #8]
                                                          DYNAMIC_TYPE_RNG);
        if (rng->drbg == NULL) {
 801f456:	68fb      	ldr	r3, [r7, #12]
 801f458:	689b      	ldr	r3, [r3, #8]
 801f45a:	2b00      	cmp	r3, #0
 801f45c:	d105      	bne.n	801f46a <_InitRng+0xa0>
    #if defined(DEBUG_WOLFSSL)
            WOLFSSL_MSG_EX("_InitRng XMALLOC failed to allocate %d bytes",
                           sizeof(DRBG_internal));
    #endif
            ret = MEMORY_E;
 801f45e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f462:	627b      	str	r3, [r7, #36]	@ 0x24
            rng->status = DRBG_FAILED;
 801f464:	68fb      	ldr	r3, [r7, #12]
 801f466:	2202      	movs	r2, #2
 801f468:	731a      	strb	r2, [r3, #12]
        }
#else
        rng->drbg = (struct DRBG*)&rng->drbg_data;
#endif /* WOLFSSL_NO_MALLOC or WOLFSSL_STATIC_MEMORY */

        if (ret != 0) {
 801f46a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f46c:	2b00      	cmp	r3, #0
 801f46e:	d138      	bne.n	801f4e2 <_InitRng+0x118>
                if (ret != 0) {
                    ret = DRBG_FAILURE;
                }
            }
#else
            ret = wc_GenerateSeed(&rng->seed, seed, seedSz);
 801f470:	68fb      	ldr	r3, [r7, #12]
 801f472:	6a3a      	ldr	r2, [r7, #32]
 801f474:	69f9      	ldr	r1, [r7, #28]
 801f476:	4618      	mov	r0, r3
 801f478:	f000 fa7e 	bl	801f978 <wc_GenerateSeed>
 801f47c:	6278      	str	r0, [r7, #36]	@ 0x24
#endif /* WC_RNG_SEED_CB */
            if (ret == 0)
 801f47e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f480:	2b00      	cmp	r3, #0
 801f482:	d105      	bne.n	801f490 <_InitRng+0xc6>
                ret = wc_RNG_TestSeed(seed, seedSz);
 801f484:	6a39      	ldr	r1, [r7, #32]
 801f486:	69f8      	ldr	r0, [r7, #28]
 801f488:	f7ff ff68 	bl	801f35c <wc_RNG_TestSeed>
 801f48c:	6278      	str	r0, [r7, #36]	@ 0x24
 801f48e:	e004      	b.n	801f49a <_InitRng+0xd0>
            else {
    #if defined(DEBUG_WOLFSSL)
                WOLFSSL_MSG_EX("wc_RNG_TestSeed failed... %d", ret);
    #endif
                ret = DRBG_FAILURE;
 801f490:	2301      	movs	r3, #1
 801f492:	627b      	str	r3, [r7, #36]	@ 0x24
                rng->status = DRBG_FAILED;
 801f494:	68fb      	ldr	r3, [r7, #12]
 801f496:	2202      	movs	r2, #2
 801f498:	731a      	strb	r2, [r3, #12]
            }

            if (ret == DRBG_SUCCESS)
 801f49a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f49c:	2b00      	cmp	r3, #0
 801f49e:	d111      	bne.n	801f4c4 <_InitRng+0xfa>
                ret = Hash_DRBG_Instantiate((DRBG_internal *)rng->drbg,
 801f4a0:	68fb      	ldr	r3, [r7, #12]
 801f4a2:	6898      	ldr	r0, [r3, #8]
                            seed + SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ,
 801f4a4:	69fb      	ldr	r3, [r7, #28]
 801f4a6:	1d19      	adds	r1, r3, #4
                ret = Hash_DRBG_Instantiate((DRBG_internal *)rng->drbg,
 801f4a8:	6a3b      	ldr	r3, [r7, #32]
 801f4aa:	1f1c      	subs	r4, r3, #4
 801f4ac:	68fb      	ldr	r3, [r7, #12]
 801f4ae:	685b      	ldr	r3, [r3, #4]
 801f4b0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f4b2:	9202      	str	r2, [sp, #8]
 801f4b4:	9301      	str	r3, [sp, #4]
 801f4b6:	687b      	ldr	r3, [r7, #4]
 801f4b8:	9300      	str	r3, [sp, #0]
 801f4ba:	68bb      	ldr	r3, [r7, #8]
 801f4bc:	4622      	mov	r2, r4
 801f4be:	f7ff fee5 	bl	801f28c <Hash_DRBG_Instantiate>
 801f4c2:	6278      	str	r0, [r7, #36]	@ 0x24
                            nonce, nonceSz, rng->heap, devId);

            if (ret != DRBG_SUCCESS) {
 801f4c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f4c6:	2b00      	cmp	r3, #0
 801f4c8:	d00b      	beq.n	801f4e2 <_InitRng+0x118>
            #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
                XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
 801f4ca:	68fb      	ldr	r3, [r7, #12]
 801f4cc:	689b      	ldr	r3, [r3, #8]
 801f4ce:	61bb      	str	r3, [r7, #24]
 801f4d0:	69bb      	ldr	r3, [r7, #24]
 801f4d2:	2b00      	cmp	r3, #0
 801f4d4:	d002      	beq.n	801f4dc <_InitRng+0x112>
 801f4d6:	69b8      	ldr	r0, [r7, #24]
 801f4d8:	f7ff faf8 	bl	801eacc <wolfSSL_Free>
            #endif
                rng->drbg = NULL;
 801f4dc:	68fb      	ldr	r3, [r7, #12]
 801f4de:	2200      	movs	r2, #0
 801f4e0:	609a      	str	r2, [r3, #8]
            }
        } /* ret == 0 */

        ForceZero(seed, seedSz);
 801f4e2:	6a39      	ldr	r1, [r7, #32]
 801f4e4:	69f8      	ldr	r0, [r7, #28]
 801f4e6:	f7ff fb2f 	bl	801eb48 <ForceZero>
    #ifdef WOLFSSL_SMALL_STACK
        XFREE(seed, rng->heap, DYNAMIC_TYPE_SEED);
 801f4ea:	69fb      	ldr	r3, [r7, #28]
 801f4ec:	617b      	str	r3, [r7, #20]
 801f4ee:	697b      	ldr	r3, [r7, #20]
 801f4f0:	2b00      	cmp	r3, #0
 801f4f2:	d002      	beq.n	801f4fa <_InitRng+0x130>
 801f4f4:	6978      	ldr	r0, [r7, #20]
 801f4f6:	f7ff fae9 	bl	801eacc <wolfSSL_Free>
    #endif
    } /* else swc_RNG_HealthTestLocal was successful */

    if (ret == DRBG_SUCCESS) {
 801f4fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f4fc:	2b00      	cmp	r3, #0
 801f4fe:	d105      	bne.n	801f50c <_InitRng+0x142>
        wc_MemZero_Add("DRBG V", &drbg->V, sizeof(drbg->V));
        wc_MemZero_Add("DRBG C", &drbg->C, sizeof(drbg->C));
    #endif
#endif

        rng->status = DRBG_OK;
 801f500:	68fb      	ldr	r3, [r7, #12]
 801f502:	2201      	movs	r2, #1
 801f504:	731a      	strb	r2, [r3, #12]
        ret = 0;
 801f506:	2300      	movs	r3, #0
 801f508:	627b      	str	r3, [r7, #36]	@ 0x24
 801f50a:	e016      	b.n	801f53a <_InitRng+0x170>
    }
    else if (ret == DRBG_CONT_FAILURE) {
 801f50c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f50e:	2b03      	cmp	r3, #3
 801f510:	d106      	bne.n	801f520 <_InitRng+0x156>
        rng->status = DRBG_CONT_FAILED;
 801f512:	68fb      	ldr	r3, [r7, #12]
 801f514:	2203      	movs	r2, #3
 801f516:	731a      	strb	r2, [r3, #12]
        ret = DRBG_CONT_FIPS_E;
 801f518:	f06f 03d0 	mvn.w	r3, #208	@ 0xd0
 801f51c:	627b      	str	r3, [r7, #36]	@ 0x24
 801f51e:	e00c      	b.n	801f53a <_InitRng+0x170>
    }
    else if (ret == DRBG_FAILURE) {
 801f520:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f522:	2b01      	cmp	r3, #1
 801f524:	d106      	bne.n	801f534 <_InitRng+0x16a>
        rng->status = DRBG_FAILED;
 801f526:	68fb      	ldr	r3, [r7, #12]
 801f528:	2202      	movs	r2, #2
 801f52a:	731a      	strb	r2, [r3, #12]
        ret = RNG_FAILURE_E;
 801f52c:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f530:	627b      	str	r3, [r7, #36]	@ 0x24
 801f532:	e002      	b.n	801f53a <_InitRng+0x170>
    }
    else {
        rng->status = DRBG_FAILED;
 801f534:	68fb      	ldr	r3, [r7, #12]
 801f536:	2202      	movs	r2, #2
 801f538:	731a      	strb	r2, [r3, #12]
    }
#endif /* HAVE_HASHDRBG */
#endif /* CUSTOM_RAND_GENERATE_BLOCK */

    return ret;
 801f53a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 801f53c:	4618      	mov	r0, r3
 801f53e:	372c      	adds	r7, #44	@ 0x2c
 801f540:	46bd      	mov	sp, r7
 801f542:	bd90      	pop	{r4, r7, pc}

0801f544 <wc_rng_free>:
}


WOLFSSL_ABI
void wc_rng_free(WC_RNG* rng)
{
 801f544:	b580      	push	{r7, lr}
 801f546:	b084      	sub	sp, #16
 801f548:	af00      	add	r7, sp, #0
 801f54a:	6078      	str	r0, [r7, #4]
    if (rng) {
 801f54c:	687b      	ldr	r3, [r7, #4]
 801f54e:	2b00      	cmp	r3, #0
 801f550:	d011      	beq.n	801f576 <wc_rng_free+0x32>
        void* heap = rng->heap;
 801f552:	687b      	ldr	r3, [r7, #4]
 801f554:	685b      	ldr	r3, [r3, #4]
 801f556:	60fb      	str	r3, [r7, #12]

        wc_FreeRng(rng);
 801f558:	6878      	ldr	r0, [r7, #4]
 801f55a:	f000 f8c3 	bl	801f6e4 <wc_FreeRng>
        ForceZero(rng, sizeof(WC_RNG));
 801f55e:	2110      	movs	r1, #16
 801f560:	6878      	ldr	r0, [r7, #4]
 801f562:	f7ff faf1 	bl	801eb48 <ForceZero>
        XFREE(rng, heap, DYNAMIC_TYPE_RNG);
 801f566:	687b      	ldr	r3, [r7, #4]
 801f568:	60bb      	str	r3, [r7, #8]
 801f56a:	68bb      	ldr	r3, [r7, #8]
 801f56c:	2b00      	cmp	r3, #0
 801f56e:	d002      	beq.n	801f576 <wc_rng_free+0x32>
 801f570:	68b8      	ldr	r0, [r7, #8]
 801f572:	f7ff faab 	bl	801eacc <wolfSSL_Free>
        (void)heap;
    }
}
 801f576:	bf00      	nop
 801f578:	3710      	adds	r7, #16
 801f57a:	46bd      	mov	sp, r7
 801f57c:	bd80      	pop	{r7, pc}

0801f57e <wc_InitRng>:

WOLFSSL_ABI
int wc_InitRng(WC_RNG* rng)
{
 801f57e:	b580      	push	{r7, lr}
 801f580:	b084      	sub	sp, #16
 801f582:	af02      	add	r7, sp, #8
 801f584:	6078      	str	r0, [r7, #4]
    return _InitRng(rng, NULL, 0, NULL, INVALID_DEVID);
 801f586:	f06f 0301 	mvn.w	r3, #1
 801f58a:	9300      	str	r3, [sp, #0]
 801f58c:	2300      	movs	r3, #0
 801f58e:	2200      	movs	r2, #0
 801f590:	2100      	movs	r1, #0
 801f592:	6878      	ldr	r0, [r7, #4]
 801f594:	f7ff ff19 	bl	801f3ca <_InitRng>
 801f598:	4603      	mov	r3, r0
}
 801f59a:	4618      	mov	r0, r3
 801f59c:	3708      	adds	r7, #8
 801f59e:	46bd      	mov	sp, r7
 801f5a0:	bd80      	pop	{r7, pc}

0801f5a2 <wc_RNG_GenerateBlock>:


/* place a generated block in output */
WOLFSSL_ABI
int wc_RNG_GenerateBlock(WC_RNG* rng, byte* output, word32 sz)
{
 801f5a2:	b580      	push	{r7, lr}
 801f5a4:	b088      	sub	sp, #32
 801f5a6:	af00      	add	r7, sp, #0
 801f5a8:	60f8      	str	r0, [r7, #12]
 801f5aa:	60b9      	str	r1, [r7, #8]
 801f5ac:	607a      	str	r2, [r7, #4]
    int ret;

    if (rng == NULL || output == NULL)
 801f5ae:	68fb      	ldr	r3, [r7, #12]
 801f5b0:	2b00      	cmp	r3, #0
 801f5b2:	d002      	beq.n	801f5ba <wc_RNG_GenerateBlock+0x18>
 801f5b4:	68bb      	ldr	r3, [r7, #8]
 801f5b6:	2b00      	cmp	r3, #0
 801f5b8:	d102      	bne.n	801f5c0 <wc_RNG_GenerateBlock+0x1e>
        return BAD_FUNC_ARG;
 801f5ba:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f5be:	e08d      	b.n	801f6dc <wc_RNG_GenerateBlock+0x13a>

    if (sz == 0)
 801f5c0:	687b      	ldr	r3, [r7, #4]
 801f5c2:	2b00      	cmp	r3, #0
 801f5c4:	d101      	bne.n	801f5ca <wc_RNG_GenerateBlock+0x28>
        return 0;
 801f5c6:	2300      	movs	r3, #0
 801f5c8:	e088      	b.n	801f6dc <wc_RNG_GenerateBlock+0x13a>
    XMEMSET(output, 0, sz);
    ret = (int)CUSTOM_RAND_GENERATE_BLOCK(output, sz);
#else

#ifdef HAVE_HASHDRBG
    if (sz > RNG_MAX_BLOCK_LEN)
 801f5ca:	687b      	ldr	r3, [r7, #4]
 801f5cc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 801f5d0:	d902      	bls.n	801f5d8 <wc_RNG_GenerateBlock+0x36>
        return BAD_FUNC_ARG;
 801f5d2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f5d6:	e081      	b.n	801f6dc <wc_RNG_GenerateBlock+0x13a>

    if (rng->status != DRBG_OK)
 801f5d8:	68fb      	ldr	r3, [r7, #12]
 801f5da:	7b1b      	ldrb	r3, [r3, #12]
 801f5dc:	2b01      	cmp	r3, #1
 801f5de:	d002      	beq.n	801f5e6 <wc_RNG_GenerateBlock+0x44>
        return RNG_FAILURE_E;
 801f5e0:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f5e4:	e07a      	b.n	801f6dc <wc_RNG_GenerateBlock+0x13a>

    ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
 801f5e6:	68fb      	ldr	r3, [r7, #12]
 801f5e8:	689b      	ldr	r3, [r3, #8]
 801f5ea:	687a      	ldr	r2, [r7, #4]
 801f5ec:	68b9      	ldr	r1, [r7, #8]
 801f5ee:	4618      	mov	r0, r3
 801f5f0:	f7ff fd9e 	bl	801f130 <Hash_DRBG_Generate>
 801f5f4:	61f8      	str	r0, [r7, #28]
    if (ret == DRBG_NEED_RESEED) {
 801f5f6:	69fb      	ldr	r3, [r7, #28]
 801f5f8:	2b02      	cmp	r3, #2
 801f5fa:	d158      	bne.n	801f6ae <wc_RNG_GenerateBlock+0x10c>
        int devId = INVALID_DEVID;
 801f5fc:	f06f 0301 	mvn.w	r3, #1
 801f600:	61bb      	str	r3, [r7, #24]
    #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
        devId = rng->devId;
    #endif
        if (wc_RNG_HealthTestLocal(1, rng->heap, devId) == 0) {
 801f602:	68fb      	ldr	r3, [r7, #12]
 801f604:	685b      	ldr	r3, [r3, #4]
 801f606:	69ba      	ldr	r2, [r7, #24]
 801f608:	4619      	mov	r1, r3
 801f60a:	2001      	movs	r0, #1
 801f60c:	f000 f90e 	bl	801f82c <wc_RNG_HealthTestLocal>
 801f610:	4603      	mov	r3, r0
 801f612:	2b00      	cmp	r3, #0
 801f614:	d149      	bne.n	801f6aa <wc_RNG_GenerateBlock+0x108>
        #ifndef WOLFSSL_SMALL_STACK
            byte newSeed[SEED_SZ + SEED_BLOCK_SZ];
            ret = DRBG_SUCCESS;
        #else
            byte* newSeed = (byte*)XMALLOC(SEED_SZ + SEED_BLOCK_SZ, rng->heap,
 801f616:	2024      	movs	r0, #36	@ 0x24
 801f618:	f7ff fa3c 	bl	801ea94 <wolfSSL_Malloc>
 801f61c:	6178      	str	r0, [r7, #20]
                DYNAMIC_TYPE_SEED);
            ret = (newSeed == NULL) ? MEMORY_E : DRBG_SUCCESS;
 801f61e:	697b      	ldr	r3, [r7, #20]
 801f620:	2b00      	cmp	r3, #0
 801f622:	d102      	bne.n	801f62a <wc_RNG_GenerateBlock+0x88>
 801f624:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f628:	e000      	b.n	801f62c <wc_RNG_GenerateBlock+0x8a>
 801f62a:	2300      	movs	r3, #0
 801f62c:	61fb      	str	r3, [r7, #28]
        #endif
            if (ret == DRBG_SUCCESS) {
 801f62e:	69fb      	ldr	r3, [r7, #28]
 801f630:	2b00      	cmp	r3, #0
 801f632:	d10b      	bne.n	801f64c <wc_RNG_GenerateBlock+0xaa>
                    if (ret != 0) {
                        ret = DRBG_FAILURE;
                    }
                }
            #else
                ret = wc_GenerateSeed(&rng->seed, newSeed,
 801f634:	68fb      	ldr	r3, [r7, #12]
 801f636:	2224      	movs	r2, #36	@ 0x24
 801f638:	6979      	ldr	r1, [r7, #20]
 801f63a:	4618      	mov	r0, r3
 801f63c:	f000 f99c 	bl	801f978 <wc_GenerateSeed>
 801f640:	61f8      	str	r0, [r7, #28]
                                  SEED_SZ + SEED_BLOCK_SZ);
            #endif
                if (ret != 0)
 801f642:	69fb      	ldr	r3, [r7, #28]
 801f644:	2b00      	cmp	r3, #0
 801f646:	d001      	beq.n	801f64c <wc_RNG_GenerateBlock+0xaa>
                    ret = DRBG_FAILURE;
 801f648:	2301      	movs	r3, #1
 801f64a:	61fb      	str	r3, [r7, #28]
            }
            if (ret == DRBG_SUCCESS)
 801f64c:	69fb      	ldr	r3, [r7, #28]
 801f64e:	2b00      	cmp	r3, #0
 801f650:	d104      	bne.n	801f65c <wc_RNG_GenerateBlock+0xba>
                ret = wc_RNG_TestSeed(newSeed, SEED_SZ + SEED_BLOCK_SZ);
 801f652:	2124      	movs	r1, #36	@ 0x24
 801f654:	6978      	ldr	r0, [r7, #20]
 801f656:	f7ff fe81 	bl	801f35c <wc_RNG_TestSeed>
 801f65a:	61f8      	str	r0, [r7, #28]

            if (ret == DRBG_SUCCESS)
 801f65c:	69fb      	ldr	r3, [r7, #28]
 801f65e:	2b00      	cmp	r3, #0
 801f660:	d108      	bne.n	801f674 <wc_RNG_GenerateBlock+0xd2>
                ret = Hash_DRBG_Reseed((DRBG_internal *)rng->drbg,
 801f662:	68fb      	ldr	r3, [r7, #12]
 801f664:	6898      	ldr	r0, [r3, #8]
                                       newSeed + SEED_BLOCK_SZ, SEED_SZ);
 801f666:	697b      	ldr	r3, [r7, #20]
 801f668:	3304      	adds	r3, #4
                ret = Hash_DRBG_Reseed((DRBG_internal *)rng->drbg,
 801f66a:	2220      	movs	r2, #32
 801f66c:	4619      	mov	r1, r3
 801f66e:	f7ff fbab 	bl	801edc8 <Hash_DRBG_Reseed>
 801f672:	61f8      	str	r0, [r7, #28]
            if (ret == DRBG_SUCCESS)
 801f674:	69fb      	ldr	r3, [r7, #28]
 801f676:	2b00      	cmp	r3, #0
 801f678:	d107      	bne.n	801f68a <wc_RNG_GenerateBlock+0xe8>
                ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
 801f67a:	68fb      	ldr	r3, [r7, #12]
 801f67c:	689b      	ldr	r3, [r3, #8]
 801f67e:	687a      	ldr	r2, [r7, #4]
 801f680:	68b9      	ldr	r1, [r7, #8]
 801f682:	4618      	mov	r0, r3
 801f684:	f7ff fd54 	bl	801f130 <Hash_DRBG_Generate>
 801f688:	61f8      	str	r0, [r7, #28]

        #ifdef WOLFSSL_SMALL_STACK
            if (newSeed != NULL) {
 801f68a:	697b      	ldr	r3, [r7, #20]
 801f68c:	2b00      	cmp	r3, #0
 801f68e:	d003      	beq.n	801f698 <wc_RNG_GenerateBlock+0xf6>
                ForceZero(newSeed, SEED_SZ + SEED_BLOCK_SZ);
 801f690:	2124      	movs	r1, #36	@ 0x24
 801f692:	6978      	ldr	r0, [r7, #20]
 801f694:	f7ff fa58 	bl	801eb48 <ForceZero>
            }
            XFREE(newSeed, rng->heap, DYNAMIC_TYPE_SEED);
 801f698:	697b      	ldr	r3, [r7, #20]
 801f69a:	613b      	str	r3, [r7, #16]
 801f69c:	693b      	ldr	r3, [r7, #16]
 801f69e:	2b00      	cmp	r3, #0
 801f6a0:	d005      	beq.n	801f6ae <wc_RNG_GenerateBlock+0x10c>
 801f6a2:	6938      	ldr	r0, [r7, #16]
 801f6a4:	f7ff fa12 	bl	801eacc <wolfSSL_Free>
 801f6a8:	e001      	b.n	801f6ae <wc_RNG_GenerateBlock+0x10c>
        #else
            ForceZero(newSeed, sizeof(newSeed));
        #endif
        }
        else {
            ret = DRBG_CONT_FAILURE;
 801f6aa:	2303      	movs	r3, #3
 801f6ac:	61fb      	str	r3, [r7, #28]
        }
    }

    if (ret == DRBG_SUCCESS) {
 801f6ae:	69fb      	ldr	r3, [r7, #28]
 801f6b0:	2b00      	cmp	r3, #0
 801f6b2:	d102      	bne.n	801f6ba <wc_RNG_GenerateBlock+0x118>
        ret = 0;
 801f6b4:	2300      	movs	r3, #0
 801f6b6:	61fb      	str	r3, [r7, #28]
 801f6b8:	e00f      	b.n	801f6da <wc_RNG_GenerateBlock+0x138>
    }
    else if (ret == DRBG_CONT_FAILURE) {
 801f6ba:	69fb      	ldr	r3, [r7, #28]
 801f6bc:	2b03      	cmp	r3, #3
 801f6be:	d106      	bne.n	801f6ce <wc_RNG_GenerateBlock+0x12c>
        ret = DRBG_CONT_FIPS_E;
 801f6c0:	f06f 03d0 	mvn.w	r3, #208	@ 0xd0
 801f6c4:	61fb      	str	r3, [r7, #28]
        rng->status = DRBG_CONT_FAILED;
 801f6c6:	68fb      	ldr	r3, [r7, #12]
 801f6c8:	2203      	movs	r2, #3
 801f6ca:	731a      	strb	r2, [r3, #12]
 801f6cc:	e005      	b.n	801f6da <wc_RNG_GenerateBlock+0x138>
    }
    else {
        ret = RNG_FAILURE_E;
 801f6ce:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f6d2:	61fb      	str	r3, [r7, #28]
        rng->status = DRBG_FAILED;
 801f6d4:	68fb      	ldr	r3, [r7, #12]
 801f6d6:	2202      	movs	r2, #2
 801f6d8:	731a      	strb	r2, [r3, #12]
    ret = RNG_FAILURE_E;

#endif /* HAVE_HASHDRBG */
#endif /* CUSTOM_RAND_GENERATE_BLOCK */

    return ret;
 801f6da:	69fb      	ldr	r3, [r7, #28]
}
 801f6dc:	4618      	mov	r0, r3
 801f6de:	3720      	adds	r7, #32
 801f6e0:	46bd      	mov	sp, r7
 801f6e2:	bd80      	pop	{r7, pc}

0801f6e4 <wc_FreeRng>:
    return wc_RNG_GenerateBlock(rng, b, 1);
}


int wc_FreeRng(WC_RNG* rng)
{
 801f6e4:	b580      	push	{r7, lr}
 801f6e6:	b084      	sub	sp, #16
 801f6e8:	af00      	add	r7, sp, #0
 801f6ea:	6078      	str	r0, [r7, #4]
    int ret = 0;
 801f6ec:	2300      	movs	r3, #0
 801f6ee:	60fb      	str	r3, [r7, #12]

    if (rng == NULL)
 801f6f0:	687b      	ldr	r3, [r7, #4]
 801f6f2:	2b00      	cmp	r3, #0
 801f6f4:	d102      	bne.n	801f6fc <wc_FreeRng+0x18>
        return BAD_FUNC_ARG;
 801f6f6:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f6fa:	e01e      	b.n	801f73a <wc_FreeRng+0x56>
#if defined(WOLFSSL_ASYNC_CRYPT)
    wolfAsync_DevCtxFree(&rng->asyncDev, WOLFSSL_ASYNC_MARKER_RNG);
#endif

#ifdef HAVE_HASHDRBG
    if (rng->drbg != NULL) {
 801f6fc:	687b      	ldr	r3, [r7, #4]
 801f6fe:	689b      	ldr	r3, [r3, #8]
 801f700:	2b00      	cmp	r3, #0
 801f702:	d016      	beq.n	801f732 <wc_FreeRng+0x4e>
      if (Hash_DRBG_Uninstantiate((DRBG_internal *)rng->drbg) != DRBG_SUCCESS)
 801f704:	687b      	ldr	r3, [r7, #4]
 801f706:	689b      	ldr	r3, [r3, #8]
 801f708:	4618      	mov	r0, r3
 801f70a:	f7ff fe00 	bl	801f30e <Hash_DRBG_Uninstantiate>
 801f70e:	4603      	mov	r3, r0
 801f710:	2b00      	cmp	r3, #0
 801f712:	d002      	beq.n	801f71a <wc_FreeRng+0x36>
            ret = RNG_FAILURE_E;
 801f714:	f06f 03c6 	mvn.w	r3, #198	@ 0xc6
 801f718:	60fb      	str	r3, [r7, #12]

    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
        XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
 801f71a:	687b      	ldr	r3, [r7, #4]
 801f71c:	689b      	ldr	r3, [r3, #8]
 801f71e:	60bb      	str	r3, [r7, #8]
 801f720:	68bb      	ldr	r3, [r7, #8]
 801f722:	2b00      	cmp	r3, #0
 801f724:	d002      	beq.n	801f72c <wc_FreeRng+0x48>
 801f726:	68b8      	ldr	r0, [r7, #8]
 801f728:	f7ff f9d0 	bl	801eacc <wolfSSL_Free>
    #elif defined(WOLFSSL_CHECK_MEM_ZERO)
        wc_MemZero_Check(rng->drbg, sizeof(DRBG_internal));
    #endif
        rng->drbg = NULL;
 801f72c:	687b      	ldr	r3, [r7, #4]
 801f72e:	2200      	movs	r2, #0
 801f730:	609a      	str	r2, [r3, #8]
    }

    rng->status = DRBG_NOT_INIT;
 801f732:	687b      	ldr	r3, [r7, #4]
 801f734:	2200      	movs	r2, #0
 801f736:	731a      	strb	r2, [r3, #12]
    /* don't overwrite previously set error */
    if (wc_VersalTrngReset() && !ret)
        ret = WC_HW_E;
#endif

    return ret;
 801f738:	68fb      	ldr	r3, [r7, #12]
}
 801f73a:	4618      	mov	r0, r3
 801f73c:	3710      	adds	r7, #16
 801f73e:	46bd      	mov	sp, r7
 801f740:	bd80      	pop	{r7, pc}

0801f742 <wc_RNG_HealthTest_ex>:
int wc_RNG_HealthTest_ex(int reseed, const byte* nonce, word32 nonceSz,
                                  const byte* seedA, word32 seedASz,
                                  const byte* seedB, word32 seedBSz,
                                  byte* output, word32 outputSz,
                                  void* heap, int devId)
{
 801f742:	b580      	push	{r7, lr}
 801f744:	b08c      	sub	sp, #48	@ 0x30
 801f746:	af04      	add	r7, sp, #16
 801f748:	60f8      	str	r0, [r7, #12]
 801f74a:	60b9      	str	r1, [r7, #8]
 801f74c:	607a      	str	r2, [r7, #4]
 801f74e:	603b      	str	r3, [r7, #0]
    int ret = -1;
 801f750:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f754:	61fb      	str	r3, [r7, #28]
    DRBG_internal* drbg;
#ifndef WOLFSSL_SMALL_STACK
    DRBG_internal  drbg_var;
#endif

    if (seedA == NULL || output == NULL) {
 801f756:	683b      	ldr	r3, [r7, #0]
 801f758:	2b00      	cmp	r3, #0
 801f75a:	d002      	beq.n	801f762 <wc_RNG_HealthTest_ex+0x20>
 801f75c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801f75e:	2b00      	cmp	r3, #0
 801f760:	d102      	bne.n	801f768 <wc_RNG_HealthTest_ex+0x26>
        return BAD_FUNC_ARG;
 801f762:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f766:	e05d      	b.n	801f824 <wc_RNG_HealthTest_ex+0xe2>
    }

    if (reseed != 0 && seedB == NULL) {
 801f768:	68fb      	ldr	r3, [r7, #12]
 801f76a:	2b00      	cmp	r3, #0
 801f76c:	d005      	beq.n	801f77a <wc_RNG_HealthTest_ex+0x38>
 801f76e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f770:	2b00      	cmp	r3, #0
 801f772:	d102      	bne.n	801f77a <wc_RNG_HealthTest_ex+0x38>
        return BAD_FUNC_ARG;
 801f774:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801f778:	e054      	b.n	801f824 <wc_RNG_HealthTest_ex+0xe2>
    }

    if (outputSz != RNG_HEALTH_TEST_CHECK_SIZE) {
 801f77a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801f77c:	2b80      	cmp	r3, #128	@ 0x80
 801f77e:	d001      	beq.n	801f784 <wc_RNG_HealthTest_ex+0x42>
        return ret;
 801f780:	69fb      	ldr	r3, [r7, #28]
 801f782:	e04f      	b.n	801f824 <wc_RNG_HealthTest_ex+0xe2>
    }

#ifdef WOLFSSL_SMALL_STACK
    drbg = (DRBG_internal*)XMALLOC(sizeof(DRBG_internal), heap,
 801f784:	2078      	movs	r0, #120	@ 0x78
 801f786:	f7ff f985 	bl	801ea94 <wolfSSL_Malloc>
 801f78a:	61b8      	str	r0, [r7, #24]
        DYNAMIC_TYPE_RNG);
    if (drbg == NULL) {
 801f78c:	69bb      	ldr	r3, [r7, #24]
 801f78e:	2b00      	cmp	r3, #0
 801f790:	d102      	bne.n	801f798 <wc_RNG_HealthTest_ex+0x56>
        return MEMORY_E;
 801f792:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f796:	e045      	b.n	801f824 <wc_RNG_HealthTest_ex+0xe2>
    }
#else
    drbg = &drbg_var;
#endif

    if (Hash_DRBG_Instantiate(drbg, seedA, seedASz, nonce, nonceSz,
 801f798:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801f79a:	9302      	str	r3, [sp, #8]
 801f79c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801f79e:	9301      	str	r3, [sp, #4]
 801f7a0:	687b      	ldr	r3, [r7, #4]
 801f7a2:	9300      	str	r3, [sp, #0]
 801f7a4:	68bb      	ldr	r3, [r7, #8]
 801f7a6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801f7a8:	6839      	ldr	r1, [r7, #0]
 801f7aa:	69b8      	ldr	r0, [r7, #24]
 801f7ac:	f7ff fd6e 	bl	801f28c <Hash_DRBG_Instantiate>
 801f7b0:	4603      	mov	r3, r0
 801f7b2:	2b00      	cmp	r3, #0
 801f7b4:	d11d      	bne.n	801f7f2 <wc_RNG_HealthTest_ex+0xb0>
                              heap, devId) != 0) {
        goto exit_rng_ht;
    }

    if (reseed) {
 801f7b6:	68fb      	ldr	r3, [r7, #12]
 801f7b8:	2b00      	cmp	r3, #0
 801f7ba:	d007      	beq.n	801f7cc <wc_RNG_HealthTest_ex+0x8a>
        if (Hash_DRBG_Reseed(drbg, seedB, seedBSz) != 0) {
 801f7bc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801f7be:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801f7c0:	69b8      	ldr	r0, [r7, #24]
 801f7c2:	f7ff fb01 	bl	801edc8 <Hash_DRBG_Reseed>
 801f7c6:	4603      	mov	r3, r0
 801f7c8:	2b00      	cmp	r3, #0
 801f7ca:	d114      	bne.n	801f7f6 <wc_RNG_HealthTest_ex+0xb4>
    /* This call to generate is prescribed by the NIST DRBGVS
     * procedure. The results are thrown away. The known
     * answer test checks the second block of DRBG out of
     * the generator to ensure the internal state is updated
     * as expected. */
    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
 801f7cc:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f7ce:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801f7d0:	69b8      	ldr	r0, [r7, #24]
 801f7d2:	f7ff fcad 	bl	801f130 <Hash_DRBG_Generate>
 801f7d6:	4603      	mov	r3, r0
 801f7d8:	2b00      	cmp	r3, #0
 801f7da:	d10e      	bne.n	801f7fa <wc_RNG_HealthTest_ex+0xb8>
        goto exit_rng_ht;
    }

    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
 801f7dc:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801f7de:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801f7e0:	69b8      	ldr	r0, [r7, #24]
 801f7e2:	f7ff fca5 	bl	801f130 <Hash_DRBG_Generate>
 801f7e6:	4603      	mov	r3, r0
 801f7e8:	2b00      	cmp	r3, #0
 801f7ea:	d108      	bne.n	801f7fe <wc_RNG_HealthTest_ex+0xbc>
        goto exit_rng_ht;
    }

    /* Mark success */
    ret = 0;
 801f7ec:	2300      	movs	r3, #0
 801f7ee:	61fb      	str	r3, [r7, #28]
 801f7f0:	e006      	b.n	801f800 <wc_RNG_HealthTest_ex+0xbe>
        goto exit_rng_ht;
 801f7f2:	bf00      	nop
 801f7f4:	e004      	b.n	801f800 <wc_RNG_HealthTest_ex+0xbe>
            goto exit_rng_ht;
 801f7f6:	bf00      	nop
 801f7f8:	e002      	b.n	801f800 <wc_RNG_HealthTest_ex+0xbe>
        goto exit_rng_ht;
 801f7fa:	bf00      	nop
 801f7fc:	e000      	b.n	801f800 <wc_RNG_HealthTest_ex+0xbe>
        goto exit_rng_ht;
 801f7fe:	bf00      	nop

exit_rng_ht:

    /* This is safe to call even if Hash_DRBG_Instantiate fails */
    if (Hash_DRBG_Uninstantiate(drbg) != 0) {
 801f800:	69b8      	ldr	r0, [r7, #24]
 801f802:	f7ff fd84 	bl	801f30e <Hash_DRBG_Uninstantiate>
 801f806:	4603      	mov	r3, r0
 801f808:	2b00      	cmp	r3, #0
 801f80a:	d002      	beq.n	801f812 <wc_RNG_HealthTest_ex+0xd0>
        ret = -1;
 801f80c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f810:	61fb      	str	r3, [r7, #28]
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(drbg, heap, DYNAMIC_TYPE_RNG);
 801f812:	69bb      	ldr	r3, [r7, #24]
 801f814:	617b      	str	r3, [r7, #20]
 801f816:	697b      	ldr	r3, [r7, #20]
 801f818:	2b00      	cmp	r3, #0
 801f81a:	d002      	beq.n	801f822 <wc_RNG_HealthTest_ex+0xe0>
 801f81c:	6978      	ldr	r0, [r7, #20]
 801f81e:	f7ff f955 	bl	801eacc <wolfSSL_Free>
#endif

    return ret;
 801f822:	69fb      	ldr	r3, [r7, #28]
}
 801f824:	4618      	mov	r0, r3
 801f826:	3720      	adds	r7, #32
 801f828:	46bd      	mov	sp, r7
 801f82a:	bd80      	pop	{r7, pc}

0801f82c <wc_RNG_HealthTestLocal>:
    0xd4, 0x31, 0xf4, 0xc9, 0xf7, 0x04, 0x27, 0xdf
};


static int wc_RNG_HealthTestLocal(int reseed, void* heap, int devId)
{
 801f82c:	b580      	push	{r7, lr}
 801f82e:	b094      	sub	sp, #80	@ 0x50
 801f830:	af08      	add	r7, sp, #32
 801f832:	60f8      	str	r0, [r7, #12]
 801f834:	60b9      	str	r1, [r7, #8]
 801f836:	607a      	str	r2, [r7, #4]
    int ret = 0;
 801f838:	2300      	movs	r3, #0
 801f83a:	62fb      	str	r3, [r7, #44]	@ 0x2c
#else
    byte  check[RNG_HEALTH_TEST_CHECK_SIZE];
#endif

#ifdef WOLFSSL_SMALL_STACK
    check = (byte*)XMALLOC(RNG_HEALTH_TEST_CHECK_SIZE, NULL,
 801f83c:	2080      	movs	r0, #128	@ 0x80
 801f83e:	f7ff f929 	bl	801ea94 <wolfSSL_Malloc>
 801f842:	62b8      	str	r0, [r7, #40]	@ 0x28
                           DYNAMIC_TYPE_TMP_BUFFER);
    if (check == NULL) {
 801f844:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f846:	2b00      	cmp	r3, #0
 801f848:	d102      	bne.n	801f850 <wc_RNG_HealthTestLocal+0x24>
        return MEMORY_E;
 801f84a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 801f84e:	e085      	b.n	801f95c <wc_RNG_HealthTestLocal+0x130>
    }
#endif

    if (reseed) {
 801f850:	68fb      	ldr	r3, [r7, #12]
 801f852:	2b00      	cmp	r3, #0
 801f854:	d029      	beq.n	801f8aa <wc_RNG_HealthTestLocal+0x7e>
        else {
            XMEMCPY_P(seedA, seedA_data, sizeof(seedA_data));
            XMEMCPY_P(reseedSeedA, reseedSeedA_data, sizeof(reseedSeedA_data));
            XMEMCPY_P(outputA, outputA_data, sizeof(outputA_data));
#else
        const byte* seedA = seedA_data;
 801f856:	4b43      	ldr	r3, [pc, #268]	@ (801f964 <wc_RNG_HealthTestLocal+0x138>)
 801f858:	61fb      	str	r3, [r7, #28]
        const byte* reseedSeedA = reseedSeedA_data;
 801f85a:	4b43      	ldr	r3, [pc, #268]	@ (801f968 <wc_RNG_HealthTestLocal+0x13c>)
 801f85c:	61bb      	str	r3, [r7, #24]
        const byte* outputA = outputA_data;
 801f85e:	4b43      	ldr	r3, [pc, #268]	@ (801f96c <wc_RNG_HealthTestLocal+0x140>)
 801f860:	617b      	str	r3, [r7, #20]
#endif
        ret = wc_RNG_HealthTest_ex(1, NULL, 0,
 801f862:	687b      	ldr	r3, [r7, #4]
 801f864:	9306      	str	r3, [sp, #24]
 801f866:	68bb      	ldr	r3, [r7, #8]
 801f868:	9305      	str	r3, [sp, #20]
 801f86a:	2380      	movs	r3, #128	@ 0x80
 801f86c:	9304      	str	r3, [sp, #16]
 801f86e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f870:	9303      	str	r3, [sp, #12]
 801f872:	2320      	movs	r3, #32
 801f874:	9302      	str	r3, [sp, #8]
 801f876:	69bb      	ldr	r3, [r7, #24]
 801f878:	9301      	str	r3, [sp, #4]
 801f87a:	2330      	movs	r3, #48	@ 0x30
 801f87c:	9300      	str	r3, [sp, #0]
 801f87e:	69fb      	ldr	r3, [r7, #28]
 801f880:	2200      	movs	r2, #0
 801f882:	2100      	movs	r1, #0
 801f884:	2001      	movs	r0, #1
 801f886:	f7ff ff5c 	bl	801f742 <wc_RNG_HealthTest_ex>
 801f88a:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                   seedA, sizeof(seedA_data),
                                   reseedSeedA, sizeof(reseedSeedA_data),
                                   check, RNG_HEALTH_TEST_CHECK_SIZE,
                                   heap, devId);
        if (ret == 0) {
 801f88c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f88e:	2b00      	cmp	r3, #0
 801f890:	d15b      	bne.n	801f94a <wc_RNG_HealthTestLocal+0x11e>
            if (ConstantCompare(check, outputA,
 801f892:	2280      	movs	r2, #128	@ 0x80
 801f894:	6979      	ldr	r1, [r7, #20]
 801f896:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801f898:	f7ff f96f 	bl	801eb7a <ConstantCompare>
 801f89c:	4603      	mov	r3, r0
 801f89e:	2b00      	cmp	r3, #0
 801f8a0:	d053      	beq.n	801f94a <wc_RNG_HealthTestLocal+0x11e>
                                RNG_HEALTH_TEST_CHECK_SIZE) != 0)
                ret = -1;
 801f8a2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f8a6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801f8a8:	e04f      	b.n	801f94a <wc_RNG_HealthTestLocal+0x11e>
        }
        else {
            XMEMCPY_P(seedB, seedB_data, sizeof(seedB_data));
            XMEMCPY_P(outputB, outputB_data, sizeof(outputB_data));
#else
        const byte* seedB = seedB_data;
 801f8aa:	4b31      	ldr	r3, [pc, #196]	@ (801f970 <wc_RNG_HealthTestLocal+0x144>)
 801f8ac:	627b      	str	r3, [r7, #36]	@ 0x24
        const byte* outputB = outputB_data;
 801f8ae:	4b31      	ldr	r3, [pc, #196]	@ (801f974 <wc_RNG_HealthTestLocal+0x148>)
 801f8b0:	623b      	str	r3, [r7, #32]
        WOLFSSL_MSG_EX("RNG_HEALTH_TEST_CHECK_SIZE = %d",
                        RNG_HEALTH_TEST_CHECK_SIZE);
        WOLFSSL_MSG_EX("sizeof(seedB_data)         = %d",
                        (int)sizeof(outputB_data));
#endif
        ret = wc_RNG_HealthTest_ex(0, NULL, 0,
 801f8b2:	687b      	ldr	r3, [r7, #4]
 801f8b4:	9306      	str	r3, [sp, #24]
 801f8b6:	68bb      	ldr	r3, [r7, #8]
 801f8b8:	9305      	str	r3, [sp, #20]
 801f8ba:	2380      	movs	r3, #128	@ 0x80
 801f8bc:	9304      	str	r3, [sp, #16]
 801f8be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f8c0:	9303      	str	r3, [sp, #12]
 801f8c2:	2300      	movs	r3, #0
 801f8c4:	9302      	str	r3, [sp, #8]
 801f8c6:	2300      	movs	r3, #0
 801f8c8:	9301      	str	r3, [sp, #4]
 801f8ca:	2330      	movs	r3, #48	@ 0x30
 801f8cc:	9300      	str	r3, [sp, #0]
 801f8ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f8d0:	2200      	movs	r2, #0
 801f8d2:	2100      	movs	r1, #0
 801f8d4:	2000      	movs	r0, #0
 801f8d6:	f7ff ff34 	bl	801f742 <wc_RNG_HealthTest_ex>
 801f8da:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                   seedB, sizeof(seedB_data),
                                   NULL, 0,
                                   check, RNG_HEALTH_TEST_CHECK_SIZE,
                                   heap, devId);
        if (ret != 0) {
 801f8dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f8de:	2b00      	cmp	r3, #0
 801f8e0:	d10b      	bne.n	801f8fa <wc_RNG_HealthTestLocal+0xce>
            #if defined(DEBUG_WOLFSSL)
            WOLFSSL_MSG_EX("RNG_HealthTest failed: err = %d", ret);
            #endif
        }
        else {
            ret = ConstantCompare(check, outputB,
 801f8e2:	2280      	movs	r2, #128	@ 0x80
 801f8e4:	6a39      	ldr	r1, [r7, #32]
 801f8e6:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801f8e8:	f7ff f947 	bl	801eb7a <ConstantCompare>
 801f8ec:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                RNG_HEALTH_TEST_CHECK_SIZE);
            if (ret != 0) {
 801f8ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f8f0:	2b00      	cmp	r3, #0
 801f8f2:	d002      	beq.n	801f8fa <wc_RNG_HealthTestLocal+0xce>
                #if defined(DEBUG_WOLFSSL)
                WOLFSSL_MSG_EX("Random ConstantCompare failed: err = %d", ret);
                #endif
                ret = -1;
 801f8f4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f8f8:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* The previous test cases use a large seed instead of a seed and nonce.
         * seedB is actually from a test case with a seed and nonce, and
         * just concatenates them. The pivot point between seed and nonce is
         * byte 32, feed them into the health test separately. */
        if (ret == 0) {
 801f8fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f8fc:	2b00      	cmp	r3, #0
 801f8fe:	d124      	bne.n	801f94a <wc_RNG_HealthTestLocal+0x11e>
            ret = wc_RNG_HealthTest_ex(0,
 801f900:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f902:	f103 0120 	add.w	r1, r3, #32
 801f906:	687b      	ldr	r3, [r7, #4]
 801f908:	9306      	str	r3, [sp, #24]
 801f90a:	68bb      	ldr	r3, [r7, #8]
 801f90c:	9305      	str	r3, [sp, #20]
 801f90e:	2380      	movs	r3, #128	@ 0x80
 801f910:	9304      	str	r3, [sp, #16]
 801f912:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f914:	9303      	str	r3, [sp, #12]
 801f916:	2300      	movs	r3, #0
 801f918:	9302      	str	r3, [sp, #8]
 801f91a:	2300      	movs	r3, #0
 801f91c:	9301      	str	r3, [sp, #4]
 801f91e:	2320      	movs	r3, #32
 801f920:	9300      	str	r3, [sp, #0]
 801f922:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f924:	2210      	movs	r2, #16
 801f926:	2000      	movs	r0, #0
 801f928:	f7ff ff0b 	bl	801f742 <wc_RNG_HealthTest_ex>
 801f92c:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                       seedB + 32, sizeof(seedB_data) - 32,
                                       seedB, 32,
                                       NULL, 0,
                                       check, RNG_HEALTH_TEST_CHECK_SIZE,
                                       heap, devId);
            if (ret == 0) {
 801f92e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f930:	2b00      	cmp	r3, #0
 801f932:	d10a      	bne.n	801f94a <wc_RNG_HealthTestLocal+0x11e>
                if (ConstantCompare(check, outputB, sizeof(outputB_data)) != 0)
 801f934:	2280      	movs	r2, #128	@ 0x80
 801f936:	6a39      	ldr	r1, [r7, #32]
 801f938:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801f93a:	f7ff f91e 	bl	801eb7a <ConstantCompare>
 801f93e:	4603      	mov	r3, r0
 801f940:	2b00      	cmp	r3, #0
 801f942:	d002      	beq.n	801f94a <wc_RNG_HealthTestLocal+0x11e>
                    ret = -1;
 801f944:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801f948:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }
#endif
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(check, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 801f94a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f94c:	613b      	str	r3, [r7, #16]
 801f94e:	693b      	ldr	r3, [r7, #16]
 801f950:	2b00      	cmp	r3, #0
 801f952:	d002      	beq.n	801f95a <wc_RNG_HealthTestLocal+0x12e>
 801f954:	6938      	ldr	r0, [r7, #16]
 801f956:	f7ff f8b9 	bl	801eacc <wolfSSL_Free>
#endif

    return ret;
 801f95a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
 801f95c:	4618      	mov	r0, r3
 801f95e:	3730      	adds	r7, #48	@ 0x30
 801f960:	46bd      	mov	sp, r7
 801f962:	bd80      	pop	{r7, pc}
 801f964:	08033a14 	.word	0x08033a14
 801f968:	08033a44 	.word	0x08033a44
 801f96c:	08033a64 	.word	0x08033a64
 801f970:	08033ae4 	.word	0x08033ae4
 801f974:	08033b14 	.word	0x08033b14

0801f978 <wc_GenerateSeed>:
     /* Generate a RNG seed using the hardware random number generator
      * on the STM32F2/F4/F7/L4. */

    #ifdef WOLFSSL_STM32_CUBEMX
    int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
    {
 801f978:	b580      	push	{r7, lr}
 801f97a:	b08c      	sub	sp, #48	@ 0x30
 801f97c:	af00      	add	r7, sp, #0
 801f97e:	60f8      	str	r0, [r7, #12]
 801f980:	60b9      	str	r1, [r7, #8]
 801f982:	607a      	str	r2, [r7, #4]
        int ret;
        RNG_HandleTypeDef hrng;
        word32 i = 0;
 801f984:	2300      	movs	r3, #0
 801f986:	62fb      	str	r3, [r7, #44]	@ 0x2c
        (void)os;

        ret = wolfSSL_CryptHwMutexLock();
 801f988:	f007 fcd6 	bl	8027338 <wolfSSL_CryptHwMutexLock>
 801f98c:	62b8      	str	r0, [r7, #40]	@ 0x28
        if (ret != 0) {
 801f98e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f990:	2b00      	cmp	r3, #0
 801f992:	d001      	beq.n	801f998 <wc_GenerateSeed+0x20>
            return ret;
 801f994:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f996:	e063      	b.n	801fa60 <wc_GenerateSeed+0xe8>
        }

        /* enable RNG clock source */
        __HAL_RCC_RNG_CLK_ENABLE();
 801f998:	2300      	movs	r3, #0
 801f99a:	617b      	str	r3, [r7, #20]
 801f99c:	4b32      	ldr	r3, [pc, #200]	@ (801fa68 <wc_GenerateSeed+0xf0>)
 801f99e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801f9a0:	4a31      	ldr	r2, [pc, #196]	@ (801fa68 <wc_GenerateSeed+0xf0>)
 801f9a2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801f9a6:	6353      	str	r3, [r2, #52]	@ 0x34
 801f9a8:	4b2f      	ldr	r3, [pc, #188]	@ (801fa68 <wc_GenerateSeed+0xf0>)
 801f9aa:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801f9ac:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801f9b0:	617b      	str	r3, [r7, #20]
 801f9b2:	697b      	ldr	r3, [r7, #20]

        /* enable RNG peripheral */
        XMEMSET(&hrng, 0, sizeof(hrng));
 801f9b4:	f107 0318 	add.w	r3, r7, #24
 801f9b8:	2210      	movs	r2, #16
 801f9ba:	2100      	movs	r1, #0
 801f9bc:	4618      	mov	r0, r3
 801f9be:	f008 fd87 	bl	80284d0 <memset>
        hrng.Instance = RNG;
 801f9c2:	4b2a      	ldr	r3, [pc, #168]	@ (801fa6c <wc_GenerateSeed+0xf4>)
 801f9c4:	61bb      	str	r3, [r7, #24]
        HAL_RNG_Init(&hrng);
 801f9c6:	f107 0318 	add.w	r3, r7, #24
 801f9ca:	4618      	mov	r0, r3
 801f9cc:	f7e5 fb18 	bl	8005000 <HAL_RNG_Init>

        while (i < sz) {
 801f9d0:	e03a      	b.n	801fa48 <wc_GenerateSeed+0xd0>
            /* If not aligned or there is odd/remainder */
            if( (i + sizeof(word32)) > sz ||
 801f9d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f9d4:	3304      	adds	r3, #4
 801f9d6:	687a      	ldr	r2, [r7, #4]
 801f9d8:	429a      	cmp	r2, r3
 801f9da:	d306      	bcc.n	801f9ea <wc_GenerateSeed+0x72>
                ((wc_ptr_t)&output[i] % sizeof(word32)) != 0
 801f9dc:	68ba      	ldr	r2, [r7, #8]
 801f9de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f9e0:	4413      	add	r3, r2
 801f9e2:	f003 0303 	and.w	r3, r3, #3
            if( (i + sizeof(word32)) > sz ||
 801f9e6:	2b00      	cmp	r3, #0
 801f9e8:	d01a      	beq.n	801fa20 <wc_GenerateSeed+0xa8>
            ) {
                /* Single byte at a time */
                uint32_t tmpRng = 0;
 801f9ea:	2300      	movs	r3, #0
 801f9ec:	613b      	str	r3, [r7, #16]
                if (HAL_RNG_GenerateRandomNumber(&hrng, &tmpRng) != HAL_OK) {
 801f9ee:	f107 0210 	add.w	r2, r7, #16
 801f9f2:	f107 0318 	add.w	r3, r7, #24
 801f9f6:	4611      	mov	r1, r2
 801f9f8:	4618      	mov	r0, r3
 801f9fa:	f7e5 fb55 	bl	80050a8 <HAL_RNG_GenerateRandomNumber>
 801f9fe:	4603      	mov	r3, r0
 801fa00:	2b00      	cmp	r3, #0
 801fa02:	d004      	beq.n	801fa0e <wc_GenerateSeed+0x96>
                    wolfSSL_CryptHwMutexUnLock();
 801fa04:	f007 fcac 	bl	8027360 <wolfSSL_CryptHwMutexUnLock>
                    return RAN_BLOCK_E;
 801fa08:	f06f 0368 	mvn.w	r3, #104	@ 0x68
 801fa0c:	e028      	b.n	801fa60 <wc_GenerateSeed+0xe8>
                }
                output[i++] = (byte)tmpRng;
 801fa0e:	6939      	ldr	r1, [r7, #16]
 801fa10:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fa12:	1c5a      	adds	r2, r3, #1
 801fa14:	62fa      	str	r2, [r7, #44]	@ 0x2c
 801fa16:	68ba      	ldr	r2, [r7, #8]
 801fa18:	4413      	add	r3, r2
 801fa1a:	b2ca      	uxtb	r2, r1
 801fa1c:	701a      	strb	r2, [r3, #0]
            ) {
 801fa1e:	e013      	b.n	801fa48 <wc_GenerateSeed+0xd0>
            }
            else {
                /* Use native 32 instruction */
                if (HAL_RNG_GenerateRandomNumber(&hrng, (uint32_t*)&output[i]) != HAL_OK) {
 801fa20:	68ba      	ldr	r2, [r7, #8]
 801fa22:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fa24:	441a      	add	r2, r3
 801fa26:	f107 0318 	add.w	r3, r7, #24
 801fa2a:	4611      	mov	r1, r2
 801fa2c:	4618      	mov	r0, r3
 801fa2e:	f7e5 fb3b 	bl	80050a8 <HAL_RNG_GenerateRandomNumber>
 801fa32:	4603      	mov	r3, r0
 801fa34:	2b00      	cmp	r3, #0
 801fa36:	d004      	beq.n	801fa42 <wc_GenerateSeed+0xca>
                    wolfSSL_CryptHwMutexUnLock();
 801fa38:	f007 fc92 	bl	8027360 <wolfSSL_CryptHwMutexUnLock>
                    return RAN_BLOCK_E;
 801fa3c:	f06f 0368 	mvn.w	r3, #104	@ 0x68
 801fa40:	e00e      	b.n	801fa60 <wc_GenerateSeed+0xe8>
                }
                i += sizeof(word32);
 801fa42:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fa44:	3304      	adds	r3, #4
 801fa46:	62fb      	str	r3, [r7, #44]	@ 0x2c
        while (i < sz) {
 801fa48:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801fa4a:	687b      	ldr	r3, [r7, #4]
 801fa4c:	429a      	cmp	r2, r3
 801fa4e:	d3c0      	bcc.n	801f9d2 <wc_GenerateSeed+0x5a>
            }
        }

        HAL_RNG_DeInit(&hrng);
 801fa50:	f107 0318 	add.w	r3, r7, #24
 801fa54:	4618      	mov	r0, r3
 801fa56:	f7e5 fafd 	bl	8005054 <HAL_RNG_DeInit>

        wolfSSL_CryptHwMutexUnLock();
 801fa5a:	f007 fc81 	bl	8027360 <wolfSSL_CryptHwMutexUnLock>

        return 0;
 801fa5e:	2300      	movs	r3, #0
    }
 801fa60:	4618      	mov	r0, r3
 801fa62:	3730      	adds	r7, #48	@ 0x30
 801fa64:	46bd      	mov	sp, r7
 801fa66:	bd80      	pop	{r7, pc}
 801fa68:	40023800 	.word	0x40023800
 801fa6c:	50060800 	.word	0x50060800

0801fa70 <XorWords>:
{
 801fa70:	b480      	push	{r7}
 801fa72:	b087      	sub	sp, #28
 801fa74:	af00      	add	r7, sp, #0
 801fa76:	60f8      	str	r0, [r7, #12]
 801fa78:	60b9      	str	r1, [r7, #8]
 801fa7a:	607a      	str	r2, [r7, #4]
    for (i = 0; i < n; i++)
 801fa7c:	2300      	movs	r3, #0
 801fa7e:	617b      	str	r3, [r7, #20]
 801fa80:	e010      	b.n	801faa4 <XorWords+0x34>
        *((*r)++) ^= *((*a)++);
 801fa82:	68bb      	ldr	r3, [r7, #8]
 801fa84:	681b      	ldr	r3, [r3, #0]
 801fa86:	1d19      	adds	r1, r3, #4
 801fa88:	68ba      	ldr	r2, [r7, #8]
 801fa8a:	6011      	str	r1, [r2, #0]
 801fa8c:	6819      	ldr	r1, [r3, #0]
 801fa8e:	68fb      	ldr	r3, [r7, #12]
 801fa90:	681b      	ldr	r3, [r3, #0]
 801fa92:	1d18      	adds	r0, r3, #4
 801fa94:	68fa      	ldr	r2, [r7, #12]
 801fa96:	6010      	str	r0, [r2, #0]
 801fa98:	681a      	ldr	r2, [r3, #0]
 801fa9a:	404a      	eors	r2, r1
 801fa9c:	601a      	str	r2, [r3, #0]
    for (i = 0; i < n; i++)
 801fa9e:	697b      	ldr	r3, [r7, #20]
 801faa0:	3301      	adds	r3, #1
 801faa2:	617b      	str	r3, [r7, #20]
 801faa4:	697a      	ldr	r2, [r7, #20]
 801faa6:	687b      	ldr	r3, [r7, #4]
 801faa8:	429a      	cmp	r2, r3
 801faaa:	d3ea      	bcc.n	801fa82 <XorWords+0x12>
}
 801faac:	bf00      	nop
 801faae:	bf00      	nop
 801fab0:	371c      	adds	r7, #28
 801fab2:	46bd      	mov	sp, r7
 801fab4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fab8:	4770      	bx	lr

0801faba <xorbuf>:
{
 801faba:	b580      	push	{r7, lr}
 801fabc:	b08a      	sub	sp, #40	@ 0x28
 801fabe:	af00      	add	r7, sp, #0
 801fac0:	60f8      	str	r0, [r7, #12]
 801fac2:	60b9      	str	r1, [r7, #8]
 801fac4:	607a      	str	r2, [r7, #4]
    b = (byte*)buf;
 801fac6:	68fb      	ldr	r3, [r7, #12]
 801fac8:	623b      	str	r3, [r7, #32]
    m = (const byte*)mask;
 801faca:	68bb      	ldr	r3, [r7, #8]
 801facc:	61fb      	str	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 801face:	6a3a      	ldr	r2, [r7, #32]
            ((wc_ptr_t)m) % WOLFSSL_WORD_SIZE) {
 801fad0:	69fb      	ldr	r3, [r7, #28]
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
 801fad2:	4053      	eors	r3, r2
 801fad4:	f003 0303 	and.w	r3, r3, #3
 801fad8:	2b00      	cmp	r3, #0
 801fada:	d12b      	bne.n	801fb34 <xorbuf+0x7a>
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 801fadc:	e00d      	b.n	801fafa <xorbuf+0x40>
            *(b++) ^= *(m++);
 801fade:	69fb      	ldr	r3, [r7, #28]
 801fae0:	1c5a      	adds	r2, r3, #1
 801fae2:	61fa      	str	r2, [r7, #28]
 801fae4:	7819      	ldrb	r1, [r3, #0]
 801fae6:	6a3b      	ldr	r3, [r7, #32]
 801fae8:	1c5a      	adds	r2, r3, #1
 801faea:	623a      	str	r2, [r7, #32]
 801faec:	781a      	ldrb	r2, [r3, #0]
 801faee:	404a      	eors	r2, r1
 801faf0:	b2d2      	uxtb	r2, r2
 801faf2:	701a      	strb	r2, [r3, #0]
            count--;
 801faf4:	687b      	ldr	r3, [r7, #4]
 801faf6:	3b01      	subs	r3, #1
 801faf8:	607b      	str	r3, [r7, #4]
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
 801fafa:	68fb      	ldr	r3, [r7, #12]
 801fafc:	f003 0303 	and.w	r3, r3, #3
 801fb00:	2b00      	cmp	r3, #0
 801fb02:	d002      	beq.n	801fb0a <xorbuf+0x50>
 801fb04:	687b      	ldr	r3, [r7, #4]
 801fb06:	2b00      	cmp	r3, #0
 801fb08:	d1e9      	bne.n	801fade <xorbuf+0x24>
        tpb.bp = b;
 801fb0a:	6a3b      	ldr	r3, [r7, #32]
 801fb0c:	61bb      	str	r3, [r7, #24]
        tpm.bp = m;
 801fb0e:	69fb      	ldr	r3, [r7, #28]
 801fb10:	617b      	str	r3, [r7, #20]
        XorWords( &tpb.wp, &tpm.wp, count / WOLFSSL_WORD_SIZE);
 801fb12:	687b      	ldr	r3, [r7, #4]
 801fb14:	089a      	lsrs	r2, r3, #2
 801fb16:	f107 0114 	add.w	r1, r7, #20
 801fb1a:	f107 0318 	add.w	r3, r7, #24
 801fb1e:	4618      	mov	r0, r3
 801fb20:	f7ff ffa6 	bl	801fa70 <XorWords>
        b = tpb.bp;
 801fb24:	69bb      	ldr	r3, [r7, #24]
 801fb26:	623b      	str	r3, [r7, #32]
        m = tpm.bp;
 801fb28:	697b      	ldr	r3, [r7, #20]
 801fb2a:	61fb      	str	r3, [r7, #28]
        count %= WOLFSSL_WORD_SIZE;
 801fb2c:	687b      	ldr	r3, [r7, #4]
 801fb2e:	f003 0303 	and.w	r3, r3, #3
 801fb32:	607b      	str	r3, [r7, #4]
    for (i = 0; i < count; i++)
 801fb34:	2300      	movs	r3, #0
 801fb36:	627b      	str	r3, [r7, #36]	@ 0x24
 801fb38:	e010      	b.n	801fb5c <xorbuf+0xa2>
        b[i] ^= m[i];
 801fb3a:	6a3a      	ldr	r2, [r7, #32]
 801fb3c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fb3e:	4413      	add	r3, r2
 801fb40:	7819      	ldrb	r1, [r3, #0]
 801fb42:	69fa      	ldr	r2, [r7, #28]
 801fb44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fb46:	4413      	add	r3, r2
 801fb48:	781a      	ldrb	r2, [r3, #0]
 801fb4a:	6a38      	ldr	r0, [r7, #32]
 801fb4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fb4e:	4403      	add	r3, r0
 801fb50:	404a      	eors	r2, r1
 801fb52:	b2d2      	uxtb	r2, r2
 801fb54:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < count; i++)
 801fb56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801fb58:	3301      	adds	r3, #1
 801fb5a:	627b      	str	r3, [r7, #36]	@ 0x24
 801fb5c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801fb5e:	687b      	ldr	r3, [r7, #4]
 801fb60:	429a      	cmp	r2, r3
 801fb62:	d3ea      	bcc.n	801fb3a <xorbuf+0x80>
}
 801fb64:	bf00      	nop
 801fb66:	bf00      	nop
 801fb68:	3728      	adds	r7, #40	@ 0x28
 801fb6a:	46bd      	mov	sp, r7
 801fb6c:	bd80      	pop	{r7, pc}

0801fb6e <ForceZero>:
{
 801fb6e:	b480      	push	{r7}
 801fb70:	b085      	sub	sp, #20
 801fb72:	af00      	add	r7, sp, #0
 801fb74:	6078      	str	r0, [r7, #4]
 801fb76:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 801fb78:	687b      	ldr	r3, [r7, #4]
 801fb7a:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 801fb7c:	e004      	b.n	801fb88 <ForceZero+0x1a>
 801fb7e:	68fb      	ldr	r3, [r7, #12]
 801fb80:	1c5a      	adds	r2, r3, #1
 801fb82:	60fa      	str	r2, [r7, #12]
 801fb84:	2200      	movs	r2, #0
 801fb86:	701a      	strb	r2, [r3, #0]
 801fb88:	683b      	ldr	r3, [r7, #0]
 801fb8a:	1e5a      	subs	r2, r3, #1
 801fb8c:	603a      	str	r2, [r7, #0]
 801fb8e:	2b00      	cmp	r3, #0
 801fb90:	d1f5      	bne.n	801fb7e <ForceZero+0x10>
}
 801fb92:	bf00      	nop
 801fb94:	bf00      	nop
 801fb96:	3714      	adds	r7, #20
 801fb98:	46bd      	mov	sp, r7
 801fb9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fb9e:	4770      	bx	lr

0801fba0 <ConstantCompare>:
{
 801fba0:	b480      	push	{r7}
 801fba2:	b087      	sub	sp, #28
 801fba4:	af00      	add	r7, sp, #0
 801fba6:	60f8      	str	r0, [r7, #12]
 801fba8:	60b9      	str	r1, [r7, #8]
 801fbaa:	607a      	str	r2, [r7, #4]
    int compareSum = 0;
 801fbac:	2300      	movs	r3, #0
 801fbae:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801fbb0:	2300      	movs	r3, #0
 801fbb2:	617b      	str	r3, [r7, #20]
 801fbb4:	e010      	b.n	801fbd8 <ConstantCompare+0x38>
        compareSum |= a[i] ^ b[i];
 801fbb6:	697b      	ldr	r3, [r7, #20]
 801fbb8:	68fa      	ldr	r2, [r7, #12]
 801fbba:	4413      	add	r3, r2
 801fbbc:	781a      	ldrb	r2, [r3, #0]
 801fbbe:	697b      	ldr	r3, [r7, #20]
 801fbc0:	68b9      	ldr	r1, [r7, #8]
 801fbc2:	440b      	add	r3, r1
 801fbc4:	781b      	ldrb	r3, [r3, #0]
 801fbc6:	4053      	eors	r3, r2
 801fbc8:	b2db      	uxtb	r3, r3
 801fbca:	461a      	mov	r2, r3
 801fbcc:	693b      	ldr	r3, [r7, #16]
 801fbce:	4313      	orrs	r3, r2
 801fbd0:	613b      	str	r3, [r7, #16]
    for (i = 0; i < length; i++) {
 801fbd2:	697b      	ldr	r3, [r7, #20]
 801fbd4:	3301      	adds	r3, #1
 801fbd6:	617b      	str	r3, [r7, #20]
 801fbd8:	697a      	ldr	r2, [r7, #20]
 801fbda:	687b      	ldr	r3, [r7, #4]
 801fbdc:	429a      	cmp	r2, r3
 801fbde:	dbea      	blt.n	801fbb6 <ConstantCompare+0x16>
    return compareSum;
 801fbe0:	693b      	ldr	r3, [r7, #16]
}
 801fbe2:	4618      	mov	r0, r3
 801fbe4:	371c      	adds	r7, #28
 801fbe6:	46bd      	mov	sp, r7
 801fbe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fbec:	4770      	bx	lr

0801fbee <ctMaskGT>:
{
 801fbee:	b480      	push	{r7}
 801fbf0:	b083      	sub	sp, #12
 801fbf2:	af00      	add	r7, sp, #0
 801fbf4:	6078      	str	r0, [r7, #4]
 801fbf6:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)a - (word32)b - 1) >> 31) - 1);
 801fbf8:	687a      	ldr	r2, [r7, #4]
 801fbfa:	683b      	ldr	r3, [r7, #0]
 801fbfc:	1ad3      	subs	r3, r2, r3
 801fbfe:	3b01      	subs	r3, #1
 801fc00:	0fdb      	lsrs	r3, r3, #31
 801fc02:	b2db      	uxtb	r3, r3
 801fc04:	3b01      	subs	r3, #1
 801fc06:	b2db      	uxtb	r3, r3
}
 801fc08:	4618      	mov	r0, r3
 801fc0a:	370c      	adds	r7, #12
 801fc0c:	46bd      	mov	sp, r7
 801fc0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc12:	4770      	bx	lr

0801fc14 <ctMaskGTE>:
{
 801fc14:	b480      	push	{r7}
 801fc16:	b083      	sub	sp, #12
 801fc18:	af00      	add	r7, sp, #0
 801fc1a:	6078      	str	r0, [r7, #4]
 801fc1c:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)a - (word32)b) >> 31) - 1);
 801fc1e:	687a      	ldr	r2, [r7, #4]
 801fc20:	683b      	ldr	r3, [r7, #0]
 801fc22:	1ad3      	subs	r3, r2, r3
 801fc24:	0fdb      	lsrs	r3, r3, #31
 801fc26:	b2db      	uxtb	r3, r3
 801fc28:	3b01      	subs	r3, #1
 801fc2a:	b2db      	uxtb	r3, r3
}
 801fc2c:	4618      	mov	r0, r3
 801fc2e:	370c      	adds	r7, #12
 801fc30:	46bd      	mov	sp, r7
 801fc32:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc36:	4770      	bx	lr

0801fc38 <ctMaskLT>:
{
 801fc38:	b480      	push	{r7}
 801fc3a:	b083      	sub	sp, #12
 801fc3c:	af00      	add	r7, sp, #0
 801fc3e:	6078      	str	r0, [r7, #4]
 801fc40:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)b - (word32)a - 1) >> 31) - 1);
 801fc42:	683a      	ldr	r2, [r7, #0]
 801fc44:	687b      	ldr	r3, [r7, #4]
 801fc46:	1ad3      	subs	r3, r2, r3
 801fc48:	3b01      	subs	r3, #1
 801fc4a:	0fdb      	lsrs	r3, r3, #31
 801fc4c:	b2db      	uxtb	r3, r3
 801fc4e:	3b01      	subs	r3, #1
 801fc50:	b2db      	uxtb	r3, r3
}
 801fc52:	4618      	mov	r0, r3
 801fc54:	370c      	adds	r7, #12
 801fc56:	46bd      	mov	sp, r7
 801fc58:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc5c:	4770      	bx	lr

0801fc5e <ctMaskLTE>:
{
 801fc5e:	b480      	push	{r7}
 801fc60:	b083      	sub	sp, #12
 801fc62:	af00      	add	r7, sp, #0
 801fc64:	6078      	str	r0, [r7, #4]
 801fc66:	6039      	str	r1, [r7, #0]
    return (byte)((((word32)b - (word32)a) >> 31) - 1);
 801fc68:	683a      	ldr	r2, [r7, #0]
 801fc6a:	687b      	ldr	r3, [r7, #4]
 801fc6c:	1ad3      	subs	r3, r2, r3
 801fc6e:	0fdb      	lsrs	r3, r3, #31
 801fc70:	b2db      	uxtb	r3, r3
 801fc72:	3b01      	subs	r3, #1
 801fc74:	b2db      	uxtb	r3, r3
}
 801fc76:	4618      	mov	r0, r3
 801fc78:	370c      	adds	r7, #12
 801fc7a:	46bd      	mov	sp, r7
 801fc7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc80:	4770      	bx	lr

0801fc82 <ctMaskEq>:
{
 801fc82:	b590      	push	{r4, r7, lr}
 801fc84:	b083      	sub	sp, #12
 801fc86:	af00      	add	r7, sp, #0
 801fc88:	6078      	str	r0, [r7, #4]
 801fc8a:	6039      	str	r1, [r7, #0]
    return (byte)((byte)(~ctMaskGT(a, b)) & (byte)(~ctMaskLT(a, b)));
 801fc8c:	6839      	ldr	r1, [r7, #0]
 801fc8e:	6878      	ldr	r0, [r7, #4]
 801fc90:	f7ff ffad 	bl	801fbee <ctMaskGT>
 801fc94:	4603      	mov	r3, r0
 801fc96:	461c      	mov	r4, r3
 801fc98:	6839      	ldr	r1, [r7, #0]
 801fc9a:	6878      	ldr	r0, [r7, #4]
 801fc9c:	f7ff ffcc 	bl	801fc38 <ctMaskLT>
 801fca0:	4603      	mov	r3, r0
 801fca2:	4323      	orrs	r3, r4
 801fca4:	b2db      	uxtb	r3, r3
 801fca6:	43db      	mvns	r3, r3
 801fca8:	b2db      	uxtb	r3, r3
}
 801fcaa:	4618      	mov	r0, r3
 801fcac:	370c      	adds	r7, #12
 801fcae:	46bd      	mov	sp, r7
 801fcb0:	bd90      	pop	{r4, r7, pc}

0801fcb2 <ctMask16GT>:
{
 801fcb2:	b480      	push	{r7}
 801fcb4:	b083      	sub	sp, #12
 801fcb6:	af00      	add	r7, sp, #0
 801fcb8:	6078      	str	r0, [r7, #4]
 801fcba:	6039      	str	r1, [r7, #0]
    return (word16)((((word32)a - (word32)b - 1) >> 31) - 1);
 801fcbc:	687a      	ldr	r2, [r7, #4]
 801fcbe:	683b      	ldr	r3, [r7, #0]
 801fcc0:	1ad3      	subs	r3, r2, r3
 801fcc2:	3b01      	subs	r3, #1
 801fcc4:	0fdb      	lsrs	r3, r3, #31
 801fcc6:	b29b      	uxth	r3, r3
 801fcc8:	3b01      	subs	r3, #1
 801fcca:	b29b      	uxth	r3, r3
}
 801fccc:	4618      	mov	r0, r3
 801fcce:	370c      	adds	r7, #12
 801fcd0:	46bd      	mov	sp, r7
 801fcd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fcd6:	4770      	bx	lr

0801fcd8 <ctMask16LT>:
{
 801fcd8:	b480      	push	{r7}
 801fcda:	b083      	sub	sp, #12
 801fcdc:	af00      	add	r7, sp, #0
 801fcde:	6078      	str	r0, [r7, #4]
 801fce0:	6039      	str	r1, [r7, #0]
    return (word16)((((word32)b - (word32)a - 1) >> 31) - 1);
 801fce2:	683a      	ldr	r2, [r7, #0]
 801fce4:	687b      	ldr	r3, [r7, #4]
 801fce6:	1ad3      	subs	r3, r2, r3
 801fce8:	3b01      	subs	r3, #1
 801fcea:	0fdb      	lsrs	r3, r3, #31
 801fcec:	b29b      	uxth	r3, r3
 801fcee:	3b01      	subs	r3, #1
 801fcf0:	b29b      	uxth	r3, r3
}
 801fcf2:	4618      	mov	r0, r3
 801fcf4:	370c      	adds	r7, #12
 801fcf6:	46bd      	mov	sp, r7
 801fcf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fcfc:	4770      	bx	lr

0801fcfe <ctMask16Eq>:
{
 801fcfe:	b590      	push	{r4, r7, lr}
 801fd00:	b083      	sub	sp, #12
 801fd02:	af00      	add	r7, sp, #0
 801fd04:	6078      	str	r0, [r7, #4]
 801fd06:	6039      	str	r1, [r7, #0]
    return (word16)((word16)(~ctMask16GT(a, b)) & (word16)(~ctMask16LT(a, b)));
 801fd08:	6839      	ldr	r1, [r7, #0]
 801fd0a:	6878      	ldr	r0, [r7, #4]
 801fd0c:	f7ff ffd1 	bl	801fcb2 <ctMask16GT>
 801fd10:	4603      	mov	r3, r0
 801fd12:	461c      	mov	r4, r3
 801fd14:	6839      	ldr	r1, [r7, #0]
 801fd16:	6878      	ldr	r0, [r7, #4]
 801fd18:	f7ff ffde 	bl	801fcd8 <ctMask16LT>
 801fd1c:	4603      	mov	r3, r0
 801fd1e:	4323      	orrs	r3, r4
 801fd20:	b29b      	uxth	r3, r3
 801fd22:	43db      	mvns	r3, r3
 801fd24:	b29b      	uxth	r3, r3
}
 801fd26:	4618      	mov	r0, r3
 801fd28:	370c      	adds	r7, #12
 801fd2a:	46bd      	mov	sp, r7
 801fd2c:	bd90      	pop	{r4, r7, pc}

0801fd2e <ctMaskNotEq>:
{
 801fd2e:	b590      	push	{r4, r7, lr}
 801fd30:	b083      	sub	sp, #12
 801fd32:	af00      	add	r7, sp, #0
 801fd34:	6078      	str	r0, [r7, #4]
 801fd36:	6039      	str	r1, [r7, #0]
    return (byte)((byte)ctMaskGT(a, b) | (byte)ctMaskLT(a, b));
 801fd38:	6839      	ldr	r1, [r7, #0]
 801fd3a:	6878      	ldr	r0, [r7, #4]
 801fd3c:	f7ff ff57 	bl	801fbee <ctMaskGT>
 801fd40:	4603      	mov	r3, r0
 801fd42:	461c      	mov	r4, r3
 801fd44:	6839      	ldr	r1, [r7, #0]
 801fd46:	6878      	ldr	r0, [r7, #4]
 801fd48:	f7ff ff76 	bl	801fc38 <ctMaskLT>
 801fd4c:	4603      	mov	r3, r0
 801fd4e:	4323      	orrs	r3, r4
 801fd50:	b2db      	uxtb	r3, r3
}
 801fd52:	4618      	mov	r0, r3
 801fd54:	370c      	adds	r7, #12
 801fd56:	46bd      	mov	sp, r7
 801fd58:	bd90      	pop	{r4, r7, pc}

0801fd5a <ctMaskSelInt>:
{
 801fd5a:	b480      	push	{r7}
 801fd5c:	b085      	sub	sp, #20
 801fd5e:	af00      	add	r7, sp, #0
 801fd60:	4603      	mov	r3, r0
 801fd62:	60b9      	str	r1, [r7, #8]
 801fd64:	607a      	str	r2, [r7, #4]
 801fd66:	73fb      	strb	r3, [r7, #15]
    return (b & (~(signed int)(signed char)m)) |
 801fd68:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801fd6c:	43da      	mvns	r2, r3
 801fd6e:	687b      	ldr	r3, [r7, #4]
 801fd70:	401a      	ands	r2, r3
           (a & ( (signed int)(signed char)m));
 801fd72:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801fd76:	4619      	mov	r1, r3
 801fd78:	68bb      	ldr	r3, [r7, #8]
 801fd7a:	400b      	ands	r3, r1
    return (b & (~(signed int)(signed char)m)) |
 801fd7c:	4313      	orrs	r3, r2
}
 801fd7e:	4618      	mov	r0, r3
 801fd80:	3714      	adds	r7, #20
 801fd82:	46bd      	mov	sp, r7
 801fd84:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fd88:	4770      	bx	lr

0801fd8a <ctMaskSelWord32>:
{
 801fd8a:	b480      	push	{r7}
 801fd8c:	b085      	sub	sp, #20
 801fd8e:	af00      	add	r7, sp, #0
 801fd90:	4603      	mov	r3, r0
 801fd92:	60b9      	str	r1, [r7, #8]
 801fd94:	607a      	str	r2, [r7, #4]
 801fd96:	73fb      	strb	r3, [r7, #15]
    return (((word32)b & (word32)(~(signed int)(signed char)m)) |
 801fd98:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801fd9c:	43db      	mvns	r3, r3
 801fd9e:	461a      	mov	r2, r3
 801fda0:	687b      	ldr	r3, [r7, #4]
 801fda2:	401a      	ands	r2, r3
            ((word32)a & (word32)( (signed int)(signed char)m)));
 801fda4:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801fda8:	4619      	mov	r1, r3
 801fdaa:	68bb      	ldr	r3, [r7, #8]
 801fdac:	400b      	ands	r3, r1
    return (((word32)b & (word32)(~(signed int)(signed char)m)) |
 801fdae:	4313      	orrs	r3, r2
}
 801fdb0:	4618      	mov	r0, r3
 801fdb2:	3714      	adds	r7, #20
 801fdb4:	46bd      	mov	sp, r7
 801fdb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fdba:	4770      	bx	lr

0801fdbc <wc_RsaCleanup>:
    RSA_STATE_DECRYPT_UNPAD,
    RSA_STATE_DECRYPT_RES
};

static void wc_RsaCleanup(RsaKey* key)
{
 801fdbc:	b580      	push	{r7, lr}
 801fdbe:	b084      	sub	sp, #16
 801fdc0:	af00      	add	r7, sp, #0
 801fdc2:	6078      	str	r0, [r7, #4]
#if !defined(WOLFSSL_NO_MALLOC) && (defined(WOLFSSL_ASYNC_CRYPT) || \
    (!defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)))
    if (key != NULL) {
 801fdc4:	687b      	ldr	r3, [r7, #4]
 801fdc6:	2b00      	cmp	r3, #0
 801fdc8:	d050      	beq.n	801fe6c <wc_RsaCleanup+0xb0>
    #ifndef WOLFSSL_RSA_PUBLIC_ONLY
        /* if private operation zero temp buffer */
        if ((key->data != NULL && key->dataLen > 0) &&
 801fdca:	687b      	ldr	r3, [r7, #4]
 801fdcc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fdd0:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 801fdd4:	2b00      	cmp	r3, #0
 801fdd6:	d022      	beq.n	801fe1e <wc_RsaCleanup+0x62>
 801fdd8:	687b      	ldr	r3, [r7, #4]
 801fdda:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fdde:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 801fde2:	2b00      	cmp	r3, #0
 801fde4:	d01b      	beq.n	801fe1e <wc_RsaCleanup+0x62>
            (key->type == RSA_PRIVATE_DECRYPT ||
 801fde6:	687b      	ldr	r3, [r7, #4]
 801fde8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fdec:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
        if ((key->data != NULL && key->dataLen > 0) &&
 801fdf0:	2b03      	cmp	r3, #3
 801fdf2:	d006      	beq.n	801fe02 <wc_RsaCleanup+0x46>
             key->type == RSA_PRIVATE_ENCRYPT)) {
 801fdf4:	687b      	ldr	r3, [r7, #4]
 801fdf6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fdfa:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
            (key->type == RSA_PRIVATE_DECRYPT ||
 801fdfe:	2b02      	cmp	r3, #2
 801fe00:	d10d      	bne.n	801fe1e <wc_RsaCleanup+0x62>
            ForceZero(key->data, key->dataLen);
 801fe02:	687b      	ldr	r3, [r7, #4]
 801fe04:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe08:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
 801fe0c:	687b      	ldr	r3, [r7, #4]
 801fe0e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe12:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 801fe16:	4619      	mov	r1, r3
 801fe18:	4610      	mov	r0, r2
 801fe1a:	f7ff fea8 	bl	801fb6e <ForceZero>
        }
    #endif
        /* make sure any allocated memory is free'd */
        if (key->dataIsAlloc) {
 801fe1e:	687b      	ldr	r3, [r7, #4]
 801fe20:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe24:	f893 3178 	ldrb.w	r3, [r3, #376]	@ 0x178
 801fe28:	2b00      	cmp	r3, #0
 801fe2a:	d011      	beq.n	801fe50 <wc_RsaCleanup+0x94>
            XFREE(key->data, key->heap, DYNAMIC_TYPE_WOLF_BIGINT);
 801fe2c:	687b      	ldr	r3, [r7, #4]
 801fe2e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe32:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 801fe36:	60fb      	str	r3, [r7, #12]
 801fe38:	68fb      	ldr	r3, [r7, #12]
 801fe3a:	2b00      	cmp	r3, #0
 801fe3c:	d002      	beq.n	801fe44 <wc_RsaCleanup+0x88>
 801fe3e:	68f8      	ldr	r0, [r7, #12]
 801fe40:	f7fe fe44 	bl	801eacc <wolfSSL_Free>
            key->dataIsAlloc = 0;
 801fe44:	687b      	ldr	r3, [r7, #4]
 801fe46:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe4a:	2200      	movs	r2, #0
 801fe4c:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
        }

        key->data = NULL;
 801fe50:	687b      	ldr	r3, [r7, #4]
 801fe52:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe56:	461a      	mov	r2, r3
 801fe58:	2300      	movs	r3, #0
 801fe5a:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
        key->dataLen = 0;
 801fe5e:	687b      	ldr	r3, [r7, #4]
 801fe60:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fe64:	461a      	mov	r2, r3
 801fe66:	2300      	movs	r3, #0
 801fe68:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170
    }
#else
    (void)key;
#endif
}
 801fe6c:	bf00      	nop
 801fe6e:	3710      	adds	r7, #16
 801fe70:	46bd      	mov	sp, r7
 801fe72:	bd80      	pop	{r7, pc}

0801fe74 <wc_InitRsaKey_ex>:
    return 0;
}
#endif /* !WC_NO_CONSTRUCTORS */

int wc_InitRsaKey_ex(RsaKey* key, void* heap, int devId)
{
 801fe74:	b5b0      	push	{r4, r5, r7, lr}
 801fe76:	b088      	sub	sp, #32
 801fe78:	af02      	add	r7, sp, #8
 801fe7a:	60f8      	str	r0, [r7, #12]
 801fe7c:	60b9      	str	r1, [r7, #8]
 801fe7e:	607a      	str	r2, [r7, #4]
    int ret = 0;
 801fe80:	2300      	movs	r3, #0
 801fe82:	617b      	str	r3, [r7, #20]

    if (key == NULL) {
 801fe84:	68fb      	ldr	r3, [r7, #12]
 801fe86:	2b00      	cmp	r3, #0
 801fe88:	d102      	bne.n	801fe90 <wc_InitRsaKey_ex+0x1c>
        return BAD_FUNC_ARG;
 801fe8a:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801fe8e:	e071      	b.n	801ff74 <wc_InitRsaKey_ex+0x100>
    }

    XMEMSET(key, 0, sizeof(RsaKey));
 801fe90:	f241 127c 	movw	r2, #4476	@ 0x117c
 801fe94:	2100      	movs	r1, #0
 801fe96:	68f8      	ldr	r0, [r7, #12]
 801fe98:	f008 fb1a 	bl	80284d0 <memset>

    key->type = RSA_TYPE_UNKNOWN;
 801fe9c:	68fb      	ldr	r3, [r7, #12]
 801fe9e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fea2:	461a      	mov	r2, r3
 801fea4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801fea8:	f8c2 3168 	str.w	r3, [r2, #360]	@ 0x168
    key->state = RSA_STATE_NONE;
 801feac:	68fb      	ldr	r3, [r7, #12]
 801feae:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801feb2:	461a      	mov	r2, r3
 801feb4:	2300      	movs	r3, #0
 801feb6:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
    key->heap = heap;
 801feba:	68fb      	ldr	r3, [r7, #12]
 801febc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fec0:	461a      	mov	r2, r3
 801fec2:	68bb      	ldr	r3, [r7, #8]
 801fec4:	f8c2 3160 	str.w	r3, [r2, #352]	@ 0x160
#if !defined(WOLFSSL_NO_MALLOC) && (defined(WOLFSSL_ASYNC_CRYPT) || \
    (!defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE)))
    key->dataIsAlloc = 0;
 801fec8:	68fb      	ldr	r3, [r7, #12]
 801feca:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fece:	2200      	movs	r2, #0
 801fed0:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
#endif
    key->data = NULL;
 801fed4:	68fb      	ldr	r3, [r7, #12]
 801fed6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801feda:	461a      	mov	r2, r3
 801fedc:	2300      	movs	r3, #0
 801fede:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
    key->dataLen = 0;
 801fee2:	68fb      	ldr	r3, [r7, #12]
 801fee4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fee8:	461a      	mov	r2, r3
 801feea:	2300      	movs	r3, #0
 801feec:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170
#ifdef WC_RSA_BLINDING
    key->rng = NULL;
 801fef0:	68fb      	ldr	r3, [r7, #12]
 801fef2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801fef6:	461a      	mov	r2, r3
 801fef8:	2300      	movs	r3, #0
 801fefa:	f8c2 3174 	str.w	r3, [r2, #372]	@ 0x174
        }
    #endif /* WC_ASYNC_ENABLE_RSA */
#endif /* WOLFSSL_ASYNC_CRYPT */

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
    ret = mp_init_multi(&key->n, &key->e, NULL, NULL, NULL, NULL);
 801fefe:	68f8      	ldr	r0, [r7, #12]
 801ff00:	68fb      	ldr	r3, [r7, #12]
 801ff02:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 801ff06:	2300      	movs	r3, #0
 801ff08:	9301      	str	r3, [sp, #4]
 801ff0a:	2300      	movs	r3, #0
 801ff0c:	9300      	str	r3, [sp, #0]
 801ff0e:	2300      	movs	r3, #0
 801ff10:	2200      	movs	r2, #0
 801ff12:	f006 fc68 	bl	80267e6 <mp_init_multi>
 801ff16:	6178      	str	r0, [r7, #20]
    if (ret != MP_OKAY)
 801ff18:	697b      	ldr	r3, [r7, #20]
 801ff1a:	2b00      	cmp	r3, #0
 801ff1c:	d001      	beq.n	801ff22 <wc_InitRsaKey_ex+0xae>
        return ret;
 801ff1e:	697b      	ldr	r3, [r7, #20]
 801ff20:	e028      	b.n	801ff74 <wc_InitRsaKey_ex+0x100>

#if !defined(WOLFSSL_KEY_GEN) && !defined(OPENSSL_EXTRA) && defined(RSA_LOW_MEM)
    ret = mp_init_multi(&key->d, &key->p, &key->q, NULL, NULL, NULL);
#else
    ret = mp_init_multi(&key->d, &key->p, &key->q, &key->dP, &key->dQ, &key->u);
 801ff22:	68fb      	ldr	r3, [r7, #12]
 801ff24:	f503 608b 	add.w	r0, r3, #1112	@ 0x458
 801ff28:	68fb      	ldr	r3, [r7, #12]
 801ff2a:	f203 6184 	addw	r1, r3, #1668	@ 0x684
 801ff2e:	68fb      	ldr	r3, [r7, #12]
 801ff30:	f503 640b 	add.w	r4, r3, #2224	@ 0x8b0
 801ff34:	68fb      	ldr	r3, [r7, #12]
 801ff36:	f603 25dc 	addw	r5, r3, #2780	@ 0xadc
 801ff3a:	68fb      	ldr	r3, [r7, #12]
 801ff3c:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 801ff40:	68fa      	ldr	r2, [r7, #12]
 801ff42:	f602 7234 	addw	r2, r2, #3892	@ 0xf34
 801ff46:	9201      	str	r2, [sp, #4]
 801ff48:	9300      	str	r3, [sp, #0]
 801ff4a:	462b      	mov	r3, r5
 801ff4c:	4622      	mov	r2, r4
 801ff4e:	f006 fc4a 	bl	80267e6 <mp_init_multi>
 801ff52:	6178      	str	r0, [r7, #20]
#endif
    if (ret != MP_OKAY) {
 801ff54:	697b      	ldr	r3, [r7, #20]
 801ff56:	2b00      	cmp	r3, #0
 801ff58:	d00b      	beq.n	801ff72 <wc_InitRsaKey_ex+0xfe>
        mp_clear(&key->n);
 801ff5a:	68fb      	ldr	r3, [r7, #12]
 801ff5c:	4618      	mov	r0, r3
 801ff5e:	f006 fc28 	bl	80267b2 <mp_clear>
        mp_clear(&key->e);
 801ff62:	68fb      	ldr	r3, [r7, #12]
 801ff64:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 801ff68:	4618      	mov	r0, r3
 801ff6a:	f006 fc22 	bl	80267b2 <mp_clear>
        return ret;
 801ff6e:	697b      	ldr	r3, [r7, #20]
 801ff70:	e000      	b.n	801ff74 <wc_InitRsaKey_ex+0x100>
    key->ctx.wrapped_pri2048_key = NULL;
    key->ctx.wrapped_pub2048_key = NULL;
    key->ctx.keySz = 0;
#endif

    return ret;
 801ff72:	697b      	ldr	r3, [r7, #20]
}
 801ff74:	4618      	mov	r0, r3
 801ff76:	3718      	adds	r7, #24
 801ff78:	46bd      	mov	sp, r7
 801ff7a:	bdb0      	pop	{r4, r5, r7, pc}

0801ff7c <wc_InitRsaKey>:

int wc_InitRsaKey(RsaKey* key, void* heap)
{
 801ff7c:	b580      	push	{r7, lr}
 801ff7e:	b082      	sub	sp, #8
 801ff80:	af00      	add	r7, sp, #0
 801ff82:	6078      	str	r0, [r7, #4]
 801ff84:	6039      	str	r1, [r7, #0]
    return wc_InitRsaKey_ex(key, heap, INVALID_DEVID);
 801ff86:	f06f 0201 	mvn.w	r2, #1
 801ff8a:	6839      	ldr	r1, [r7, #0]
 801ff8c:	6878      	ldr	r0, [r7, #4]
 801ff8e:	f7ff ff71 	bl	801fe74 <wc_InitRsaKey_ex>
 801ff92:	4603      	mov	r3, r0
}
 801ff94:	4618      	mov	r0, r3
 801ff96:	3708      	adds	r7, #8
 801ff98:	46bd      	mov	sp, r7
 801ff9a:	bd80      	pop	{r7, pc}

0801ff9c <wc_FreeRsaKey>:
    return se050_rsa_get_key_id(key, keyId);
}
#endif /* WOLFSSL_SE050 */

int wc_FreeRsaKey(RsaKey* key)
{
 801ff9c:	b580      	push	{r7, lr}
 801ff9e:	b084      	sub	sp, #16
 801ffa0:	af00      	add	r7, sp, #0
 801ffa2:	6078      	str	r0, [r7, #4]
    int ret = 0;
 801ffa4:	2300      	movs	r3, #0
 801ffa6:	60fb      	str	r3, [r7, #12]

    if (key == NULL) {
 801ffa8:	687b      	ldr	r3, [r7, #4]
 801ffaa:	2b00      	cmp	r3, #0
 801ffac:	d102      	bne.n	801ffb4 <wc_FreeRsaKey+0x18>
        return BAD_FUNC_ARG;
 801ffae:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 801ffb2:	e05d      	b.n	8020070 <wc_FreeRsaKey+0xd4>
    }

    wc_RsaCleanup(key);
 801ffb4:	6878      	ldr	r0, [r7, #4]
 801ffb6:	f7ff ff01 	bl	801fdbc <wc_RsaCleanup>
#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_RSA)
    wolfAsync_DevCtxFree(&key->asyncDev, WOLFSSL_ASYNC_MARKER_RSA);
#endif

#ifndef WOLFSSL_RSA_PUBLIC_ONLY
    if (key->type == RSA_PRIVATE) {
 801ffba:	687b      	ldr	r3, [r7, #4]
 801ffbc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801ffc0:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
 801ffc4:	2b01      	cmp	r3, #1
 801ffc6:	d124      	bne.n	8020012 <wc_FreeRsaKey+0x76>
#if defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)
        mp_forcezero(&key->u);
 801ffc8:	687b      	ldr	r3, [r7, #4]
 801ffca:	f603 7334 	addw	r3, r3, #3892	@ 0xf34
 801ffce:	4618      	mov	r0, r3
 801ffd0:	f006 fbda 	bl	8026788 <mp_forcezero>
        mp_forcezero(&key->dQ);
 801ffd4:	687b      	ldr	r3, [r7, #4]
 801ffd6:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 801ffda:	4618      	mov	r0, r3
 801ffdc:	f006 fbd4 	bl	8026788 <mp_forcezero>
        mp_forcezero(&key->dP);
 801ffe0:	687b      	ldr	r3, [r7, #4]
 801ffe2:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 801ffe6:	4618      	mov	r0, r3
 801ffe8:	f006 fbce 	bl	8026788 <mp_forcezero>
#endif
        mp_forcezero(&key->q);
 801ffec:	687b      	ldr	r3, [r7, #4]
 801ffee:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 801fff2:	4618      	mov	r0, r3
 801fff4:	f006 fbc8 	bl	8026788 <mp_forcezero>
        mp_forcezero(&key->p);
 801fff8:	687b      	ldr	r3, [r7, #4]
 801fffa:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 801fffe:	4618      	mov	r0, r3
 8020000:	f006 fbc2 	bl	8026788 <mp_forcezero>
        mp_forcezero(&key->d);
 8020004:	687b      	ldr	r3, [r7, #4]
 8020006:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 802000a:	4618      	mov	r0, r3
 802000c:	f006 fbbc 	bl	8026788 <mp_forcezero>
 8020010:	e023      	b.n	802005a <wc_FreeRsaKey+0xbe>
    }
    else {
        /* private part */
#if defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)
        mp_clear(&key->u);
 8020012:	687b      	ldr	r3, [r7, #4]
 8020014:	f603 7334 	addw	r3, r3, #3892	@ 0xf34
 8020018:	4618      	mov	r0, r3
 802001a:	f006 fbca 	bl	80267b2 <mp_clear>
        mp_clear(&key->dQ);
 802001e:	687b      	ldr	r3, [r7, #4]
 8020020:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 8020024:	4618      	mov	r0, r3
 8020026:	f006 fbc4 	bl	80267b2 <mp_clear>
        mp_clear(&key->dP);
 802002a:	687b      	ldr	r3, [r7, #4]
 802002c:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 8020030:	4618      	mov	r0, r3
 8020032:	f006 fbbe 	bl	80267b2 <mp_clear>
#endif
        mp_clear(&key->q);
 8020036:	687b      	ldr	r3, [r7, #4]
 8020038:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 802003c:	4618      	mov	r0, r3
 802003e:	f006 fbb8 	bl	80267b2 <mp_clear>
        mp_clear(&key->p);
 8020042:	687b      	ldr	r3, [r7, #4]
 8020044:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8020048:	4618      	mov	r0, r3
 802004a:	f006 fbb2 	bl	80267b2 <mp_clear>
        mp_clear(&key->d);
 802004e:	687b      	ldr	r3, [r7, #4]
 8020050:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8020054:	4618      	mov	r0, r3
 8020056:	f006 fbac 	bl	80267b2 <mp_clear>
    }
#endif /* WOLFSSL_RSA_PUBLIC_ONLY */

    /* public part */
    mp_clear(&key->e);
 802005a:	687b      	ldr	r3, [r7, #4]
 802005c:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8020060:	4618      	mov	r0, r3
 8020062:	f006 fba6 	bl	80267b2 <mp_clear>
    mp_clear(&key->n);
 8020066:	687b      	ldr	r3, [r7, #4]
 8020068:	4618      	mov	r0, r3
 802006a:	f006 fba2 	bl	80267b2 <mp_clear>

#if defined(WOLFSSL_RENESAS_FSPSM_CRYPTONLY)
    wc_fspsm_RsaKeyFree(key);
#endif

    return ret;
 802006e:	68fb      	ldr	r3, [r7, #12]
}
 8020070:	4618      	mov	r0, r3
 8020072:	3710      	adds	r7, #16
 8020074:	46bd      	mov	sp, r7
 8020076:	bd80      	pop	{r7, pc}

08020078 <RsaMGF1>:
   outSz: size of output buffer
 */
#if !defined(NO_SHA) || !defined(NO_SHA256) || defined(WOLFSSL_SHA384) || defined(WOLFSSL_SHA512)
static int RsaMGF1(enum wc_HashType hType, byte* seed, word32 seedSz,
                                        byte* out, word32 outSz, void* heap)
{
 8020078:	b580      	push	{r7, lr}
 802007a:	b09a      	sub	sp, #104	@ 0x68
 802007c:	af02      	add	r7, sp, #8
 802007e:	60b9      	str	r1, [r7, #8]
 8020080:	607a      	str	r2, [r7, #4]
 8020082:	603b      	str	r3, [r7, #0]
 8020084:	4603      	mov	r3, r0
 8020086:	73fb      	strb	r3, [r7, #15]
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    byte* tmp = NULL;
 8020088:	2300      	movs	r3, #0
 802008a:	65fb      	str	r3, [r7, #92]	@ 0x5c
    byte   tmpF = 0;     /* 1 if dynamic memory needs freed */
 802008c:	2300      	movs	r3, #0
 802008e:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
#else
    byte tmp[RSA_MAX_SIZE/8];
#endif
    /* needs to be large enough for seed size plus counter(4) */
    byte  tmpA[WC_MAX_DIGEST_SIZE + 4];
    word32 tmpSz = 0;
 8020092:	2300      	movs	r3, #0
 8020094:	657b      	str	r3, [r7, #84]	@ 0x54
    word32 counter;
    word32 idx;
#ifdef WOLFSSL_SMALL_STACK_CACHE
    wc_HashAlg *hash;
#endif
    hLen    = wc_HashGetDigestSize(hType);
 8020096:	7bfb      	ldrb	r3, [r7, #15]
 8020098:	4618      	mov	r0, r3
 802009a:	f7fe f969 	bl	801e370 <wc_HashGetDigestSize>
 802009e:	6478      	str	r0, [r7, #68]	@ 0x44
    counter = 0;
 80200a0:	2300      	movs	r3, #0
 80200a2:	653b      	str	r3, [r7, #80]	@ 0x50
    idx     = 0;
 80200a4:	2300      	movs	r3, #0
 80200a6:	64fb      	str	r3, [r7, #76]	@ 0x4c

    (void)heap;

    XMEMSET(tmpA, 0, sizeof(tmpA));
 80200a8:	f107 0314 	add.w	r3, r7, #20
 80200ac:	2224      	movs	r2, #36	@ 0x24
 80200ae:	2100      	movs	r1, #0
 80200b0:	4618      	mov	r0, r3
 80200b2:	f008 fa0d 	bl	80284d0 <memset>
    /* check error return of wc_HashGetDigestSize */
    if (hLen < 0) {
 80200b6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80200b8:	2b00      	cmp	r3, #0
 80200ba:	da01      	bge.n	80200c0 <RsaMGF1+0x48>
        return hLen;
 80200bc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80200be:	e08f      	b.n	80201e0 <RsaMGF1+0x168>
    }

    /* if tmp is not large enough than use some dynamic memory */
    if ((seedSz + 4) > sizeof(tmpA) || (word32)hLen > sizeof(tmpA)) {
 80200c0:	687b      	ldr	r3, [r7, #4]
 80200c2:	3304      	adds	r3, #4
 80200c4:	2b24      	cmp	r3, #36	@ 0x24
 80200c6:	d802      	bhi.n	80200ce <RsaMGF1+0x56>
 80200c8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80200ca:	2b24      	cmp	r3, #36	@ 0x24
 80200cc:	d914      	bls.n	80200f8 <RsaMGF1+0x80>
        /* find largest amount of memory needed which will be the max of
         * hLen and (seedSz + 4) since tmp is used to store the hash digest */
        tmpSz = ((seedSz + 4) > (word32)hLen)? seedSz + 4: (word32)hLen;
 80200ce:	687b      	ldr	r3, [r7, #4]
 80200d0:	1d1a      	adds	r2, r3, #4
 80200d2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80200d4:	4293      	cmp	r3, r2
 80200d6:	bf38      	it	cc
 80200d8:	4613      	movcc	r3, r2
 80200da:	657b      	str	r3, [r7, #84]	@ 0x54
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
        tmp = (byte*)XMALLOC(tmpSz, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80200dc:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80200de:	f7fe fcd9 	bl	801ea94 <wolfSSL_Malloc>
 80200e2:	65f8      	str	r0, [r7, #92]	@ 0x5c
        if (tmp == NULL) {
 80200e4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80200e6:	2b00      	cmp	r3, #0
 80200e8:	d102      	bne.n	80200f0 <RsaMGF1+0x78>
            return MEMORY_E;
 80200ea:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80200ee:	e077      	b.n	80201e0 <RsaMGF1+0x168>
        }
        tmpF = 1; /* make sure to free memory when done */
 80200f0:	2301      	movs	r3, #1
 80200f2:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
 80200f6:	e007      	b.n	8020108 <RsaMGF1+0x90>
#endif
    }
    else {
        /* use array on the stack */
    #ifndef WOLFSSL_SMALL_STACK_CACHE
        tmpSz = sizeof(tmpA);
 80200f8:	2324      	movs	r3, #36	@ 0x24
 80200fa:	657b      	str	r3, [r7, #84]	@ 0x54
    #endif
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
        tmp  = tmpA;
 80200fc:	f107 0314 	add.w	r3, r7, #20
 8020100:	65fb      	str	r3, [r7, #92]	@ 0x5c
        tmpF = 0; /* no need to free memory at end */
 8020102:	2300      	movs	r3, #0
 8020104:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
        return ret;
    }
#endif

    do {
        int i = 0;
 8020108:	2300      	movs	r3, #0
 802010a:	64bb      	str	r3, [r7, #72]	@ 0x48
        XMEMCPY(tmp, seed, seedSz);
 802010c:	687a      	ldr	r2, [r7, #4]
 802010e:	68b9      	ldr	r1, [r7, #8]
 8020110:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8020112:	f008 fa47 	bl	80285a4 <memcpy>

        /* counter to byte array appended to tmp */
        tmp[seedSz]     = (byte)((counter >> 24) & 0xFF);
 8020116:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020118:	0e19      	lsrs	r1, r3, #24
 802011a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802011c:	687b      	ldr	r3, [r7, #4]
 802011e:	4413      	add	r3, r2
 8020120:	b2ca      	uxtb	r2, r1
 8020122:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 1] = (byte)((counter >> 16) & 0xFF);
 8020124:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020126:	0c19      	lsrs	r1, r3, #16
 8020128:	687b      	ldr	r3, [r7, #4]
 802012a:	3301      	adds	r3, #1
 802012c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802012e:	4413      	add	r3, r2
 8020130:	b2ca      	uxtb	r2, r1
 8020132:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 2] = (byte)((counter >>  8) & 0xFF);
 8020134:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020136:	0a19      	lsrs	r1, r3, #8
 8020138:	687b      	ldr	r3, [r7, #4]
 802013a:	3302      	adds	r3, #2
 802013c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802013e:	4413      	add	r3, r2
 8020140:	b2ca      	uxtb	r2, r1
 8020142:	701a      	strb	r2, [r3, #0]
        tmp[seedSz + 3] = (byte)((counter)       & 0xFF);
 8020144:	687b      	ldr	r3, [r7, #4]
 8020146:	3303      	adds	r3, #3
 8020148:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802014a:	4413      	add	r3, r2
 802014c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802014e:	b2d2      	uxtb	r2, r2
 8020150:	701a      	strb	r2, [r3, #0]
        ret = wc_HashUpdate(hash, hType, tmp, (seedSz + 4));
        if (ret == 0) {
            ret = wc_HashFinal(hash, hType, tmp);
        }
#else
        ret = wc_Hash(hType, tmp, (seedSz + 4), tmp, tmpSz);
 8020152:	687b      	ldr	r3, [r7, #4]
 8020154:	1d1a      	adds	r2, r3, #4
 8020156:	7bf8      	ldrb	r0, [r7, #15]
 8020158:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802015a:	9300      	str	r3, [sp, #0]
 802015c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802015e:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8020160:	f7fe f99e 	bl	801e4a0 <wc_Hash>
 8020164:	6438      	str	r0, [r7, #64]	@ 0x40
#endif
        if (ret != 0) {
 8020166:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020168:	2b00      	cmp	r3, #0
 802016a:	d00d      	beq.n	8020188 <RsaMGF1+0x110>
            /* check for if dynamic memory was needed, then free */
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
            if (tmpF) {
 802016c:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 8020170:	2b00      	cmp	r3, #0
 8020172:	d007      	beq.n	8020184 <RsaMGF1+0x10c>
                XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8020174:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8020176:	63bb      	str	r3, [r7, #56]	@ 0x38
 8020178:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802017a:	2b00      	cmp	r3, #0
 802017c:	d002      	beq.n	8020184 <RsaMGF1+0x10c>
 802017e:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8020180:	f7fe fca4 	bl	801eacc <wolfSSL_Free>
            }
#endif
            return ret;
 8020184:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020186:	e02b      	b.n	80201e0 <RsaMGF1+0x168>
        }

        for (i = 0; i < hLen && idx < outSz; i++) {
 8020188:	2300      	movs	r3, #0
 802018a:	64bb      	str	r3, [r7, #72]	@ 0x48
 802018c:	e00c      	b.n	80201a8 <RsaMGF1+0x130>
            out[idx++] = tmp[i];
 802018e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020190:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8020192:	441a      	add	r2, r3
 8020194:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020196:	1c59      	adds	r1, r3, #1
 8020198:	64f9      	str	r1, [r7, #76]	@ 0x4c
 802019a:	6839      	ldr	r1, [r7, #0]
 802019c:	440b      	add	r3, r1
 802019e:	7812      	ldrb	r2, [r2, #0]
 80201a0:	701a      	strb	r2, [r3, #0]
        for (i = 0; i < hLen && idx < outSz; i++) {
 80201a2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80201a4:	3301      	adds	r3, #1
 80201a6:	64bb      	str	r3, [r7, #72]	@ 0x48
 80201a8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80201aa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80201ac:	429a      	cmp	r2, r3
 80201ae:	da03      	bge.n	80201b8 <RsaMGF1+0x140>
 80201b0:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80201b2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80201b4:	429a      	cmp	r2, r3
 80201b6:	d3ea      	bcc.n	802018e <RsaMGF1+0x116>
        }
        counter++;
 80201b8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80201ba:	3301      	adds	r3, #1
 80201bc:	653b      	str	r3, [r7, #80]	@ 0x50
    } while (idx < outSz);
 80201be:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80201c0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80201c2:	429a      	cmp	r2, r3
 80201c4:	d3a0      	bcc.n	8020108 <RsaMGF1+0x90>
#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    /* check for if dynamic memory was needed, then free */
    if (tmpF) {
 80201c6:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 80201ca:	2b00      	cmp	r3, #0
 80201cc:	d007      	beq.n	80201de <RsaMGF1+0x166>
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80201ce:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80201d0:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80201d2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80201d4:	2b00      	cmp	r3, #0
 80201d6:	d002      	beq.n	80201de <RsaMGF1+0x166>
 80201d8:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80201da:	f7fe fc77 	bl	801eacc <wolfSSL_Free>
#ifdef WOLFSSL_SMALL_STACK_CACHE
    wc_HashFree(hash, hType);
    XFREE(hash, heap, DYNAMIC_TYPE_DIGEST);
#endif

    return 0;
 80201de:	2300      	movs	r3, #0
}
 80201e0:	4618      	mov	r0, r3
 80201e2:	3760      	adds	r7, #96	@ 0x60
 80201e4:	46bd      	mov	sp, r7
 80201e6:	bd80      	pop	{r7, pc}

080201e8 <RsaMGF>:
/* helper function to direct which mask generation function is used
   switched on type input
 */
static int RsaMGF(int type, byte* seed, word32 seedSz, byte* out,
                                                    word32 outSz, void* heap)
{
 80201e8:	b580      	push	{r7, lr}
 80201ea:	b088      	sub	sp, #32
 80201ec:	af02      	add	r7, sp, #8
 80201ee:	60f8      	str	r0, [r7, #12]
 80201f0:	60b9      	str	r1, [r7, #8]
 80201f2:	607a      	str	r2, [r7, #4]
 80201f4:	603b      	str	r3, [r7, #0]
    int ret;

    switch(type) {
 80201f6:	68fb      	ldr	r3, [r7, #12]
 80201f8:	2b01      	cmp	r3, #1
 80201fa:	d10b      	bne.n	8020214 <RsaMGF+0x2c>
        case WC_MGF1SHA224:
            ret = RsaMGF1(WC_HASH_TYPE_SHA224, seed, seedSz, out, outSz, heap);
            break;
    #endif
        case WC_MGF1SHA256:
            ret = RsaMGF1(WC_HASH_TYPE_SHA256, seed, seedSz, out, outSz, heap);
 80201fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80201fe:	9301      	str	r3, [sp, #4]
 8020200:	6a3b      	ldr	r3, [r7, #32]
 8020202:	9300      	str	r3, [sp, #0]
 8020204:	683b      	ldr	r3, [r7, #0]
 8020206:	687a      	ldr	r2, [r7, #4]
 8020208:	68b9      	ldr	r1, [r7, #8]
 802020a:	2006      	movs	r0, #6
 802020c:	f7ff ff34 	bl	8020078 <RsaMGF1>
 8020210:	6178      	str	r0, [r7, #20]
            break;
 8020212:	e002      	b.n	802021a <RsaMGF+0x32>
            break;
        #endif
    #endif
        default:
            WOLFSSL_MSG("Unknown MGF type: check build options");
            ret = BAD_FUNC_ARG;
 8020214:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020218:	617b      	str	r3, [r7, #20]
    (void)seedSz;
    (void)out;
    (void)outSz;
    (void)heap;

    return ret;
 802021a:	697b      	ldr	r3, [r7, #20]
}
 802021c:	4618      	mov	r0, r3
 802021e:	3718      	adds	r7, #24
 8020220:	46bd      	mov	sp, r7
 8020222:	bd80      	pop	{r7, pc}

08020224 <RsaUnPad_OAEP>:
/* UnPad plaintext, set start to *output, return length of plaintext,
 * < 0 on error */
static int RsaUnPad_OAEP(byte *pkcsBlock, unsigned int pkcsBlockLen,
                            byte **output, enum wc_HashType hType, int mgf,
                            byte* optLabel, word32 labelLen, void* heap)
{
 8020224:	b580      	push	{r7, lr}
 8020226:	b098      	sub	sp, #96	@ 0x60
 8020228:	af02      	add	r7, sp, #8
 802022a:	60f8      	str	r0, [r7, #12]
 802022c:	60b9      	str	r1, [r7, #8]
 802022e:	607a      	str	r2, [r7, #4]
 8020230:	70fb      	strb	r3, [r7, #3]
    word32 idx;
    word32 i;
    word32 inc;

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    byte* tmp  = NULL;
 8020232:	2300      	movs	r3, #0
 8020234:	64bb      	str	r3, [r7, #72]	@ 0x48
#else
    byte tmp[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];
#endif

    /* no label is allowed, but catch if no label provided and length > 0 */
    if (optLabel == NULL && labelLen > 0) {
 8020236:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8020238:	2b00      	cmp	r3, #0
 802023a:	d105      	bne.n	8020248 <RsaUnPad_OAEP+0x24>
 802023c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802023e:	2b00      	cmp	r3, #0
 8020240:	d002      	beq.n	8020248 <RsaUnPad_OAEP+0x24>
        return BUFFER_E;
 8020242:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8020246:	e0e9      	b.n	802041c <RsaUnPad_OAEP+0x1f8>
    }

    ret = wc_HashGetDigestSize(hType);
 8020248:	78fb      	ldrb	r3, [r7, #3]
 802024a:	4618      	mov	r0, r3
 802024c:	f7fe f890 	bl	801e370 <wc_HashGetDigestSize>
 8020250:	6478      	str	r0, [r7, #68]	@ 0x44
    if ((ret < 0) || (pkcsBlockLen < (2 * (word32)ret + 2))) {
 8020252:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020254:	2b00      	cmp	r3, #0
 8020256:	db05      	blt.n	8020264 <RsaUnPad_OAEP+0x40>
 8020258:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802025a:	3301      	adds	r3, #1
 802025c:	005b      	lsls	r3, r3, #1
 802025e:	68ba      	ldr	r2, [r7, #8]
 8020260:	429a      	cmp	r2, r3
 8020262:	d202      	bcs.n	802026a <RsaUnPad_OAEP+0x46>
        return BAD_FUNC_ARG;
 8020264:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020268:	e0d8      	b.n	802041c <RsaUnPad_OAEP+0x1f8>
    }
    hLen = (word32)ret;
 802026a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802026c:	643b      	str	r3, [r7, #64]	@ 0x40

#if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
    tmp = (byte*)XMALLOC(pkcsBlockLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 802026e:	68b8      	ldr	r0, [r7, #8]
 8020270:	f7fe fc10 	bl	801ea94 <wolfSSL_Malloc>
 8020274:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (tmp == NULL) {
 8020276:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020278:	2b00      	cmp	r3, #0
 802027a:	d102      	bne.n	8020282 <RsaUnPad_OAEP+0x5e>
        return MEMORY_E;
 802027c:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020280:	e0cc      	b.n	802041c <RsaUnPad_OAEP+0x1f8>
    }
#endif
    XMEMSET(tmp, 0, pkcsBlockLen);
 8020282:	68ba      	ldr	r2, [r7, #8]
 8020284:	2100      	movs	r1, #0
 8020286:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8020288:	f008 f922 	bl	80284d0 <memset>
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Add("OAEP UnPad temp", tmp, pkcsBlockLen);
#endif

    /* find seedMask value */
    if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 802028c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802028e:	3301      	adds	r3, #1
 8020290:	68fa      	ldr	r2, [r7, #12]
 8020292:	18d1      	adds	r1, r2, r3
                            pkcsBlockLen - hLen - 1, tmp, hLen, heap)) != 0) {
 8020294:	68ba      	ldr	r2, [r7, #8]
 8020296:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020298:	1ad3      	subs	r3, r2, r3
    if ((ret = RsaMGF(mgf, (byte*)(pkcsBlock + (hLen + 1)),
 802029a:	1e5a      	subs	r2, r3, #1
 802029c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802029e:	9301      	str	r3, [sp, #4]
 80202a0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80202a2:	9300      	str	r3, [sp, #0]
 80202a4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80202a6:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80202a8:	f7ff ff9e 	bl	80201e8 <RsaMGF>
 80202ac:	6478      	str	r0, [r7, #68]	@ 0x44
 80202ae:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80202b0:	2b00      	cmp	r3, #0
 80202b2:	d009      	beq.n	80202c8 <RsaUnPad_OAEP+0xa4>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80202b4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80202b6:	637b      	str	r3, [r7, #52]	@ 0x34
 80202b8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80202ba:	2b00      	cmp	r3, #0
 80202bc:	d002      	beq.n	80202c4 <RsaUnPad_OAEP+0xa0>
 80202be:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80202c0:	f7fe fc04 	bl	801eacc <wolfSSL_Free>
#endif
        return ret;
 80202c4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80202c6:	e0a9      	b.n	802041c <RsaUnPad_OAEP+0x1f8>
    }

    /* xor seedMask value with maskedSeed to get seed value */
    xorbuf(tmp, pkcsBlock + 1, hLen);
 80202c8:	68fb      	ldr	r3, [r7, #12]
 80202ca:	3301      	adds	r3, #1
 80202cc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80202ce:	4619      	mov	r1, r3
 80202d0:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80202d2:	f7ff fbf2 	bl	801faba <xorbuf>

    /* get dbMask value */
    if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 80202d6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80202d8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80202da:	18d1      	adds	r1, r2, r3
                                       pkcsBlockLen - hLen - 1, heap)) != 0) {
 80202dc:	68ba      	ldr	r2, [r7, #8]
 80202de:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80202e0:	1ad3      	subs	r3, r2, r3
    if ((ret = RsaMGF(mgf, tmp, hLen, tmp + hLen,
 80202e2:	3b01      	subs	r3, #1
 80202e4:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80202e6:	9201      	str	r2, [sp, #4]
 80202e8:	9300      	str	r3, [sp, #0]
 80202ea:	460b      	mov	r3, r1
 80202ec:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80202ee:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 80202f0:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80202f2:	f7ff ff79 	bl	80201e8 <RsaMGF>
 80202f6:	6478      	str	r0, [r7, #68]	@ 0x44
 80202f8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80202fa:	2b00      	cmp	r3, #0
 80202fc:	d00d      	beq.n	802031a <RsaUnPad_OAEP+0xf6>
        ForceZero(tmp, hLen);
 80202fe:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8020300:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8020302:	f7ff fc34 	bl	801fb6e <ForceZero>
#ifdef WOLFSSL_SMALL_STACK
        XFREE(tmp, NULL, DYNAMIC_TYPE_RSA_BUFFER);
 8020306:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020308:	63bb      	str	r3, [r7, #56]	@ 0x38
 802030a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802030c:	2b00      	cmp	r3, #0
 802030e:	d002      	beq.n	8020316 <RsaUnPad_OAEP+0xf2>
 8020310:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8020312:	f7fe fbdb 	bl	801eacc <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
        wc_MemZero_Check(tmp, hLen);
#endif
        return ret;
 8020316:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020318:	e080      	b.n	802041c <RsaUnPad_OAEP+0x1f8>
    }

    /* get DB value by doing maskedDB xor dbMask */
    xorbuf(pkcsBlock + hLen + 1, tmp + hLen, pkcsBlockLen - hLen - 1);
 802031a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802031c:	3301      	adds	r3, #1
 802031e:	68fa      	ldr	r2, [r7, #12]
 8020320:	18d0      	adds	r0, r2, r3
 8020322:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8020324:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020326:	18d1      	adds	r1, r2, r3
 8020328:	68ba      	ldr	r2, [r7, #8]
 802032a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802032c:	1ad3      	subs	r3, r2, r3
 802032e:	3b01      	subs	r3, #1
 8020330:	461a      	mov	r2, r3
 8020332:	f7ff fbc2 	bl	801faba <xorbuf>

    ForceZero(tmp, pkcsBlockLen);
 8020336:	68b9      	ldr	r1, [r7, #8]
 8020338:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 802033a:	f7ff fc18 	bl	801fb6e <ForceZero>
#ifdef WOLFSSL_SMALL_STACK
    /* done with use of tmp buffer */
    XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 802033e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020340:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8020342:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020344:	2b00      	cmp	r3, #0
 8020346:	d002      	beq.n	802034e <RsaUnPad_OAEP+0x12a>
 8020348:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 802034a:	f7fe fbbf 	bl	801eacc <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
    wc_MemZero_Check(tmp, pkcsBlockLen);
#endif

    /* advance idx to index of PS and msg separator, account for PS size of 0*/
    idx = hLen + 1 + hLen;
 802034e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020350:	005b      	lsls	r3, r3, #1
 8020352:	3301      	adds	r3, #1
 8020354:	657b      	str	r3, [r7, #84]	@ 0x54
    /* Don't reveal length of message: look at every byte. */
    inc = 1;
 8020356:	2301      	movs	r3, #1
 8020358:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (i = hLen + 1 + hLen; i < pkcsBlockLen - 1; i++) {
 802035a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802035c:	005b      	lsls	r3, r3, #1
 802035e:	3301      	adds	r3, #1
 8020360:	653b      	str	r3, [r7, #80]	@ 0x50
 8020362:	e010      	b.n	8020386 <RsaUnPad_OAEP+0x162>
        /* Looking for non-zero byte. */
        inc &= 1 - (((word32)0 - pkcsBlock[i]) >> 31);
 8020364:	68fa      	ldr	r2, [r7, #12]
 8020366:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020368:	4413      	add	r3, r2
 802036a:	781b      	ldrb	r3, [r3, #0]
 802036c:	425b      	negs	r3, r3
 802036e:	17db      	asrs	r3, r3, #31
 8020370:	3301      	adds	r3, #1
 8020372:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020374:	4013      	ands	r3, r2
 8020376:	64fb      	str	r3, [r7, #76]	@ 0x4c
        idx += inc;
 8020378:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802037a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802037c:	4413      	add	r3, r2
 802037e:	657b      	str	r3, [r7, #84]	@ 0x54
    for (i = hLen + 1 + hLen; i < pkcsBlockLen - 1; i++) {
 8020380:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020382:	3301      	adds	r3, #1
 8020384:	653b      	str	r3, [r7, #80]	@ 0x50
 8020386:	68bb      	ldr	r3, [r7, #8]
 8020388:	3b01      	subs	r3, #1
 802038a:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802038c:	429a      	cmp	r2, r3
 802038e:	d3e9      	bcc.n	8020364 <RsaUnPad_OAEP+0x140>
    }

    /* create hash of label for comparison with hash sent */
    if ((ret = wc_Hash(hType, optLabel, labelLen, h, hLen)) != 0) {
 8020390:	f107 0214 	add.w	r2, r7, #20
 8020394:	78f8      	ldrb	r0, [r7, #3]
 8020396:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020398:	9300      	str	r3, [sp, #0]
 802039a:	4613      	mov	r3, r2
 802039c:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 802039e:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 80203a0:	f7fe f87e 	bl	801e4a0 <wc_Hash>
 80203a4:	6478      	str	r0, [r7, #68]	@ 0x44
 80203a6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80203a8:	2b00      	cmp	r3, #0
 80203aa:	d001      	beq.n	80203b0 <RsaUnPad_OAEP+0x18c>
        return ret;
 80203ac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80203ae:	e035      	b.n	802041c <RsaUnPad_OAEP+0x1f8>
       Comparison of lHash, Y, and separator value needs to all happen in
       constant time.
       Attackers should not be able to get error condition from the timing of
       these checks.
     */
    ret = 0;
 80203b0:	2300      	movs	r3, #0
 80203b2:	647b      	str	r3, [r7, #68]	@ 0x44
    ret |= ConstantCompare(pkcsBlock + hLen + 1, h, (int)hLen);
 80203b4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80203b6:	3301      	adds	r3, #1
 80203b8:	68fa      	ldr	r2, [r7, #12]
 80203ba:	4413      	add	r3, r2
 80203bc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80203be:	f107 0114 	add.w	r1, r7, #20
 80203c2:	4618      	mov	r0, r3
 80203c4:	f7ff fbec 	bl	801fba0 <ConstantCompare>
 80203c8:	4602      	mov	r2, r0
 80203ca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80203cc:	4313      	orrs	r3, r2
 80203ce:	647b      	str	r3, [r7, #68]	@ 0x44
    ret += pkcsBlock[idx++] ^ 0x01; /* separator value is 0x01 */
 80203d0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80203d2:	1c5a      	adds	r2, r3, #1
 80203d4:	657a      	str	r2, [r7, #84]	@ 0x54
 80203d6:	68fa      	ldr	r2, [r7, #12]
 80203d8:	4413      	add	r3, r2
 80203da:	781b      	ldrb	r3, [r3, #0]
 80203dc:	f083 0301 	eor.w	r3, r3, #1
 80203e0:	b2db      	uxtb	r3, r3
 80203e2:	461a      	mov	r2, r3
 80203e4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80203e6:	4413      	add	r3, r2
 80203e8:	647b      	str	r3, [r7, #68]	@ 0x44
    ret += pkcsBlock[0]     ^ 0x00; /* Y, the first value, should be 0 */
 80203ea:	68fb      	ldr	r3, [r7, #12]
 80203ec:	781b      	ldrb	r3, [r3, #0]
 80203ee:	461a      	mov	r2, r3
 80203f0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80203f2:	4413      	add	r3, r2
 80203f4:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Return 0 data length on error. */
    idx = ctMaskSelWord32(ctMaskEq(ret, 0), idx, pkcsBlockLen);
 80203f6:	2100      	movs	r1, #0
 80203f8:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 80203fa:	f7ff fc42 	bl	801fc82 <ctMaskEq>
 80203fe:	4603      	mov	r3, r0
 8020400:	68ba      	ldr	r2, [r7, #8]
 8020402:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8020404:	4618      	mov	r0, r3
 8020406:	f7ff fcc0 	bl	801fd8a <ctMaskSelWord32>
 802040a:	6578      	str	r0, [r7, #84]	@ 0x54

    /* adjust pointer to correct location in array and return size of M */
    *output = (byte*)(pkcsBlock + idx);
 802040c:	68fa      	ldr	r2, [r7, #12]
 802040e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8020410:	441a      	add	r2, r3
 8020412:	687b      	ldr	r3, [r7, #4]
 8020414:	601a      	str	r2, [r3, #0]
    return (int)(pkcsBlockLen - idx);
 8020416:	68ba      	ldr	r2, [r7, #8]
 8020418:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802041a:	1ad3      	subs	r3, r2, r3
}
 802041c:	4618      	mov	r0, r3
 802041e:	3758      	adds	r7, #88	@ 0x58
 8020420:	46bd      	mov	sp, r7
 8020422:	bd80      	pop	{r7, pc}

08020424 <RsaUnPad_PSS>:
                 and other negative values on error.
 */
static int RsaUnPad_PSS(byte *pkcsBlock, unsigned int pkcsBlockLen,
                        byte **output, enum wc_HashType hType, int mgf,
                        int saltLen, int bits, void* heap)
{
 8020424:	b580      	push	{r7, lr}
 8020426:	b090      	sub	sp, #64	@ 0x40
 8020428:	af02      	add	r7, sp, #8
 802042a:	60f8      	str	r0, [r7, #12]
 802042c:	60b9      	str	r1, [r7, #8]
 802042e:	607a      	str	r2, [r7, #4]
 8020430:	70fb      	strb	r3, [r7, #3]
    if (pkcsBlockLen > RSA_MAX_SIZE/8) {
        return MEMORY_E;
    }
#endif

    hLen = wc_HashGetDigestSize(hType);
 8020432:	78fb      	ldrb	r3, [r7, #3]
 8020434:	4618      	mov	r0, r3
 8020436:	f7fd ff9b 	bl	801e370 <wc_HashGetDigestSize>
 802043a:	6338      	str	r0, [r7, #48]	@ 0x30
    if (hLen < 0)
 802043c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802043e:	2b00      	cmp	r3, #0
 8020440:	da01      	bge.n	8020446 <RsaUnPad_PSS+0x22>
        return hLen;
 8020442:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020444:	e0e3      	b.n	802060e <RsaUnPad_PSS+0x1ea>
    bits = (bits - 1) & 0x7;
 8020446:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020448:	3b01      	subs	r3, #1
 802044a:	f003 0307 	and.w	r3, r3, #7
 802044e:	64bb      	str	r3, [r7, #72]	@ 0x48
    if ((pkcsBlock[0] & (0xff << bits)) != 0) {
 8020450:	68fb      	ldr	r3, [r7, #12]
 8020452:	781b      	ldrb	r3, [r3, #0]
 8020454:	4619      	mov	r1, r3
 8020456:	22ff      	movs	r2, #255	@ 0xff
 8020458:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802045a:	fa02 f303 	lsl.w	r3, r2, r3
 802045e:	400b      	ands	r3, r1
 8020460:	2b00      	cmp	r3, #0
 8020462:	d002      	beq.n	802046a <RsaUnPad_PSS+0x46>
        return BAD_PADDING_E;
 8020464:	f06f 03c0 	mvn.w	r3, #192	@ 0xc0
 8020468:	e0d1      	b.n	802060e <RsaUnPad_PSS+0x1ea>
    }
    if (bits == 0) {
 802046a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802046c:	2b00      	cmp	r3, #0
 802046e:	d105      	bne.n	802047c <RsaUnPad_PSS+0x58>
        pkcsBlock++;
 8020470:	68fb      	ldr	r3, [r7, #12]
 8020472:	3301      	adds	r3, #1
 8020474:	60fb      	str	r3, [r7, #12]
        pkcsBlockLen--;
 8020476:	68bb      	ldr	r3, [r7, #8]
 8020478:	3b01      	subs	r3, #1
 802047a:	60bb      	str	r3, [r7, #8]
    }
    maskLen = (int)pkcsBlockLen - 1 - hLen;
 802047c:	68bb      	ldr	r3, [r7, #8]
 802047e:	1e5a      	subs	r2, r3, #1
 8020480:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020482:	1ad3      	subs	r3, r2, r3
 8020484:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if (maskLen < 0) {
 8020486:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020488:	2b00      	cmp	r3, #0
 802048a:	da02      	bge.n	8020492 <RsaUnPad_PSS+0x6e>
        WOLFSSL_MSG("RsaUnPad_PSS: Hash too large");
        return WC_KEY_SIZE_E;
 802048c:	f06f 03e9 	mvn.w	r3, #233	@ 0xe9
 8020490:	e0bd      	b.n	802060e <RsaUnPad_PSS+0x1ea>
    }

    if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
 8020492:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8020494:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8020498:	d102      	bne.n	80204a0 <RsaUnPad_PSS+0x7c>
        saltLen = hLen;
 802049a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802049c:	647b      	str	r3, [r7, #68]	@ 0x44
 802049e:	e00d      	b.n	80204bc <RsaUnPad_PSS+0x98>
            if (orig_bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE)
                saltLen = RSA_PSS_SALT_MAX_SZ;
        #endif
    }
#ifndef WOLFSSL_PSS_LONG_SALT
    else if (saltLen > hLen)
 80204a0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80204a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80204a4:	429a      	cmp	r2, r3
 80204a6:	dd02      	ble.n	80204ae <RsaUnPad_PSS+0x8a>
        return PSS_SALTLEN_E;
 80204a8:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80204ac:	e0af      	b.n	802060e <RsaUnPad_PSS+0x1ea>
#endif
#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
    else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT)
 80204ae:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80204b0:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80204b4:	da02      	bge.n	80204bc <RsaUnPad_PSS+0x98>
        return PSS_SALTLEN_E;
 80204b6:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80204ba:	e0a8      	b.n	802060e <RsaUnPad_PSS+0x1ea>
    if (maskLen < saltLen + 1) {
 80204bc:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80204be:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80204c0:	429a      	cmp	r2, r3
 80204c2:	db02      	blt.n	80204ca <RsaUnPad_PSS+0xa6>
        return PSS_SALTLEN_E;
 80204c4:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80204c8:	e0a1      	b.n	802060e <RsaUnPad_PSS+0x1ea>
    if (saltLen != RSA_PSS_SALT_LEN_DISCOVER && maskLen < saltLen + 1) {
        return WC_KEY_SIZE_E;
    }
#endif

    if (pkcsBlock[pkcsBlockLen - 1] != RSA_PSS_PAD_TERM) {
 80204ca:	68bb      	ldr	r3, [r7, #8]
 80204cc:	3b01      	subs	r3, #1
 80204ce:	68fa      	ldr	r2, [r7, #12]
 80204d0:	4413      	add	r3, r2
 80204d2:	781b      	ldrb	r3, [r3, #0]
 80204d4:	2bbc      	cmp	r3, #188	@ 0xbc
 80204d6:	d002      	beq.n	80204de <RsaUnPad_PSS+0xba>
        WOLFSSL_MSG("RsaUnPad_PSS: Padding Term Error");
        return BAD_PADDING_E;
 80204d8:	f06f 03c0 	mvn.w	r3, #192	@ 0xc0
 80204dc:	e097      	b.n	802060e <RsaUnPad_PSS+0x1ea>
    }

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
    tmp = (byte*)XMALLOC((size_t)maskLen, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80204de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80204e0:	4618      	mov	r0, r3
 80204e2:	f7fe fad7 	bl	801ea94 <wolfSSL_Malloc>
 80204e6:	62b8      	str	r0, [r7, #40]	@ 0x28
    if (tmp == NULL) {
 80204e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80204ea:	2b00      	cmp	r3, #0
 80204ec:	d102      	bne.n	80204f4 <RsaUnPad_PSS+0xd0>
        return MEMORY_E;
 80204ee:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80204f2:	e08c      	b.n	802060e <RsaUnPad_PSS+0x1ea>
    }
#endif

    if ((ret = RsaMGF(mgf, pkcsBlock + maskLen, (word32)hLen, tmp, (word32)maskLen,
 80204f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80204f6:	68fa      	ldr	r2, [r7, #12]
 80204f8:	18d1      	adds	r1, r2, r3
 80204fa:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80204fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80204fe:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020500:	9201      	str	r2, [sp, #4]
 8020502:	9300      	str	r3, [sp, #0]
 8020504:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020506:	4602      	mov	r2, r0
 8020508:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 802050a:	f7ff fe6d 	bl	80201e8 <RsaMGF>
 802050e:	6278      	str	r0, [r7, #36]	@ 0x24
 8020510:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020512:	2b00      	cmp	r3, #0
 8020514:	d009      	beq.n	802052a <RsaUnPad_PSS+0x106>
                                                                  heap)) != 0) {
        #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
        XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8020516:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020518:	617b      	str	r3, [r7, #20]
 802051a:	697b      	ldr	r3, [r7, #20]
 802051c:	2b00      	cmp	r3, #0
 802051e:	d002      	beq.n	8020526 <RsaUnPad_PSS+0x102>
 8020520:	6978      	ldr	r0, [r7, #20]
 8020522:	f7fe fad3 	bl	801eacc <wolfSSL_Free>
        #endif
        return ret;
 8020526:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020528:	e071      	b.n	802060e <RsaUnPad_PSS+0x1ea>
    }

    tmp[0] &= (byte)((1 << bits) - 1);
 802052a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802052c:	781a      	ldrb	r2, [r3, #0]
 802052e:	2101      	movs	r1, #1
 8020530:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020532:	fa01 f303 	lsl.w	r3, r1, r3
 8020536:	b2db      	uxtb	r3, r3
 8020538:	3b01      	subs	r3, #1
 802053a:	b2db      	uxtb	r3, r3
 802053c:	4013      	ands	r3, r2
 802053e:	b2da      	uxtb	r2, r3
 8020540:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020542:	701a      	strb	r2, [r3, #0]
    pkcsBlock[0] &= (byte)((1 << bits) - 1);
 8020544:	68fb      	ldr	r3, [r7, #12]
 8020546:	781a      	ldrb	r2, [r3, #0]
 8020548:	2101      	movs	r1, #1
 802054a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802054c:	fa01 f303 	lsl.w	r3, r1, r3
 8020550:	b2db      	uxtb	r3, r3
 8020552:	3b01      	subs	r3, #1
 8020554:	b2db      	uxtb	r3, r3
 8020556:	4013      	ands	r3, r2
 8020558:	b2da      	uxtb	r2, r3
 802055a:	68fb      	ldr	r3, [r7, #12]
 802055c:	701a      	strb	r2, [r3, #0]
        saltLen = maskLen - (i + 1);
    }
    else
#endif
    {
        for (i = 0; i < maskLen - 1 - saltLen; i++) {
 802055e:	2300      	movs	r3, #0
 8020560:	637b      	str	r3, [r7, #52]	@ 0x34
 8020562:	e017      	b.n	8020594 <RsaUnPad_PSS+0x170>
            if (tmp[i] != pkcsBlock[i]) {
 8020564:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020566:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8020568:	4413      	add	r3, r2
 802056a:	781a      	ldrb	r2, [r3, #0]
 802056c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802056e:	68f9      	ldr	r1, [r7, #12]
 8020570:	440b      	add	r3, r1
 8020572:	781b      	ldrb	r3, [r3, #0]
 8020574:	429a      	cmp	r2, r3
 8020576:	d00a      	beq.n	802058e <RsaUnPad_PSS+0x16a>
                #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
                XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 8020578:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802057a:	61bb      	str	r3, [r7, #24]
 802057c:	69bb      	ldr	r3, [r7, #24]
 802057e:	2b00      	cmp	r3, #0
 8020580:	d002      	beq.n	8020588 <RsaUnPad_PSS+0x164>
 8020582:	69b8      	ldr	r0, [r7, #24]
 8020584:	f7fe faa2 	bl	801eacc <wolfSSL_Free>
                #endif
                WOLFSSL_MSG("RsaUnPad_PSS: Padding Error Match");
                return PSS_SALTLEN_E;
 8020588:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 802058c:	e03f      	b.n	802060e <RsaUnPad_PSS+0x1ea>
        for (i = 0; i < maskLen - 1 - saltLen; i++) {
 802058e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020590:	3301      	adds	r3, #1
 8020592:	637b      	str	r3, [r7, #52]	@ 0x34
 8020594:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020596:	1e5a      	subs	r2, r3, #1
 8020598:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802059a:	1ad3      	subs	r3, r2, r3
 802059c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802059e:	429a      	cmp	r2, r3
 80205a0:	dbe0      	blt.n	8020564 <RsaUnPad_PSS+0x140>
            }
        }
        if (tmp[i] != (pkcsBlock[i] ^ 0x01)) {
 80205a2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80205a4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80205a6:	4413      	add	r3, r2
 80205a8:	781a      	ldrb	r2, [r3, #0]
 80205aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80205ac:	68f9      	ldr	r1, [r7, #12]
 80205ae:	440b      	add	r3, r1
 80205b0:	781b      	ldrb	r3, [r3, #0]
 80205b2:	f083 0301 	eor.w	r3, r3, #1
 80205b6:	b2db      	uxtb	r3, r3
 80205b8:	429a      	cmp	r2, r3
 80205ba:	d00a      	beq.n	80205d2 <RsaUnPad_PSS+0x1ae>
            #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
            XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80205bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80205be:	61fb      	str	r3, [r7, #28]
 80205c0:	69fb      	ldr	r3, [r7, #28]
 80205c2:	2b00      	cmp	r3, #0
 80205c4:	d002      	beq.n	80205cc <RsaUnPad_PSS+0x1a8>
 80205c6:	69f8      	ldr	r0, [r7, #28]
 80205c8:	f7fe fa80 	bl	801eacc <wolfSSL_Free>
            #endif
            WOLFSSL_MSG("RsaUnPad_PSS: Padding Error End");
            return PSS_SALTLEN_E;
 80205cc:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 80205d0:	e01d      	b.n	802060e <RsaUnPad_PSS+0x1ea>
        }
    }
    xorbuf(pkcsBlock + i, tmp + i, (word32)(maskLen - i));
 80205d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80205d4:	68fa      	ldr	r2, [r7, #12]
 80205d6:	18d0      	adds	r0, r2, r3
 80205d8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80205da:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80205dc:	18d1      	adds	r1, r2, r3
 80205de:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80205e0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80205e2:	1ad3      	subs	r3, r2, r3
 80205e4:	461a      	mov	r2, r3
 80205e6:	f7ff fa68 	bl	801faba <xorbuf>

#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
    XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);
 80205ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80205ec:	623b      	str	r3, [r7, #32]
 80205ee:	6a3b      	ldr	r3, [r7, #32]
 80205f0:	2b00      	cmp	r3, #0
 80205f2:	d002      	beq.n	80205fa <RsaUnPad_PSS+0x1d6>
 80205f4:	6a38      	ldr	r0, [r7, #32]
 80205f6:	f7fe fa69 	bl	801eacc <wolfSSL_Free>
#endif

    *output = pkcsBlock + maskLen - saltLen;
 80205fa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80205fc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80205fe:	1ad3      	subs	r3, r2, r3
 8020600:	68fa      	ldr	r2, [r7, #12]
 8020602:	441a      	add	r2, r3
 8020604:	687b      	ldr	r3, [r7, #4]
 8020606:	601a      	str	r2, [r3, #0]
    return saltLen + hLen;
 8020608:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 802060a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802060c:	4413      	add	r3, r2
}
 802060e:	4618      	mov	r0, r3
 8020610:	3738      	adds	r7, #56	@ 0x38
 8020612:	46bd      	mov	sp, r7
 8020614:	bd80      	pop	{r7, pc}

08020616 <RsaUnPad>:

/* UnPad plaintext, set start to *output, return length of plaintext,
 * < 0 on error */
static int RsaUnPad(const byte *pkcsBlock, unsigned int pkcsBlockLen,
                    byte **output, byte padValue)
{
 8020616:	b590      	push	{r4, r7, lr}
 8020618:	b089      	sub	sp, #36	@ 0x24
 802061a:	af00      	add	r7, sp, #0
 802061c:	60f8      	str	r0, [r7, #12]
 802061e:	60b9      	str	r1, [r7, #8]
 8020620:	607a      	str	r2, [r7, #4]
 8020622:	70fb      	strb	r3, [r7, #3]
    int    ret = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 8020624:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020628:	61fb      	str	r3, [r7, #28]
    word16 i;

    if (output == NULL || pkcsBlockLen < 2 || pkcsBlockLen > 0xFFFF) {
 802062a:	687b      	ldr	r3, [r7, #4]
 802062c:	2b00      	cmp	r3, #0
 802062e:	d006      	beq.n	802063e <RsaUnPad+0x28>
 8020630:	68bb      	ldr	r3, [r7, #8]
 8020632:	2b01      	cmp	r3, #1
 8020634:	d903      	bls.n	802063e <RsaUnPad+0x28>
 8020636:	68bb      	ldr	r3, [r7, #8]
 8020638:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 802063c:	d302      	bcc.n	8020644 <RsaUnPad+0x2e>
        return BAD_FUNC_ARG;
 802063e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020642:	e0a7      	b.n	8020794 <RsaUnPad+0x17e>
    }

    if (padValue == RSA_BLOCK_TYPE_1) {
 8020644:	78fb      	ldrb	r3, [r7, #3]
 8020646:	2b01      	cmp	r3, #1
 8020648:	d134      	bne.n	80206b4 <RsaUnPad+0x9e>
        /* First byte must be 0x00 and Second byte, block type, 0x01 */
        if (pkcsBlock[0] != 0 || pkcsBlock[1] != RSA_BLOCK_TYPE_1) {
 802064a:	68fb      	ldr	r3, [r7, #12]
 802064c:	781b      	ldrb	r3, [r3, #0]
 802064e:	2b00      	cmp	r3, #0
 8020650:	d104      	bne.n	802065c <RsaUnPad+0x46>
 8020652:	68fb      	ldr	r3, [r7, #12]
 8020654:	3301      	adds	r3, #1
 8020656:	781b      	ldrb	r3, [r3, #0]
 8020658:	2b01      	cmp	r3, #1
 802065a:	d002      	beq.n	8020662 <RsaUnPad+0x4c>
            WOLFSSL_MSG("RsaUnPad error, invalid formatting");
            return RSA_PAD_E;
 802065c:	f06f 03c8 	mvn.w	r3, #200	@ 0xc8
 8020660:	e098      	b.n	8020794 <RsaUnPad+0x17e>
        }

        /* check the padding until we find the separator */
        for (i = 2; i < pkcsBlockLen; ) {
 8020662:	2302      	movs	r3, #2
 8020664:	837b      	strh	r3, [r7, #26]
 8020666:	e008      	b.n	802067a <RsaUnPad+0x64>
            if (pkcsBlock[i++] != 0xFF) {
 8020668:	8b7b      	ldrh	r3, [r7, #26]
 802066a:	1c5a      	adds	r2, r3, #1
 802066c:	837a      	strh	r2, [r7, #26]
 802066e:	461a      	mov	r2, r3
 8020670:	68fb      	ldr	r3, [r7, #12]
 8020672:	4413      	add	r3, r2
 8020674:	781b      	ldrb	r3, [r3, #0]
 8020676:	2bff      	cmp	r3, #255	@ 0xff
 8020678:	d104      	bne.n	8020684 <RsaUnPad+0x6e>
        for (i = 2; i < pkcsBlockLen; ) {
 802067a:	8b7b      	ldrh	r3, [r7, #26]
 802067c:	68ba      	ldr	r2, [r7, #8]
 802067e:	429a      	cmp	r2, r3
 8020680:	d8f2      	bhi.n	8020668 <RsaUnPad+0x52>
 8020682:	e000      	b.n	8020686 <RsaUnPad+0x70>
                break;
 8020684:	bf00      	nop
            }
        }

        /* Minimum of 11 bytes of pre-message data and must have separator. */
        if (i < RSA_MIN_PAD_SZ || pkcsBlock[i-1] != 0) {
 8020686:	8b7b      	ldrh	r3, [r7, #26]
 8020688:	2b0a      	cmp	r3, #10
 802068a:	d906      	bls.n	802069a <RsaUnPad+0x84>
 802068c:	8b7b      	ldrh	r3, [r7, #26]
 802068e:	3b01      	subs	r3, #1
 8020690:	68fa      	ldr	r2, [r7, #12]
 8020692:	4413      	add	r3, r2
 8020694:	781b      	ldrb	r3, [r3, #0]
 8020696:	2b00      	cmp	r3, #0
 8020698:	d002      	beq.n	80206a0 <RsaUnPad+0x8a>
            WOLFSSL_MSG("RsaUnPad error, bad formatting");
            return RSA_PAD_E;
 802069a:	f06f 03c8 	mvn.w	r3, #200	@ 0xc8
 802069e:	e079      	b.n	8020794 <RsaUnPad+0x17e>
        }

        *output = (byte *)(pkcsBlock + i);
 80206a0:	8b7b      	ldrh	r3, [r7, #26]
 80206a2:	68fa      	ldr	r2, [r7, #12]
 80206a4:	441a      	add	r2, r3
 80206a6:	687b      	ldr	r3, [r7, #4]
 80206a8:	601a      	str	r2, [r3, #0]
        ret = (int)pkcsBlockLen - i;
 80206aa:	68ba      	ldr	r2, [r7, #8]
 80206ac:	8b7b      	ldrh	r3, [r7, #26]
 80206ae:	1ad3      	subs	r3, r2, r3
 80206b0:	61fb      	str	r3, [r7, #28]
 80206b2:	e06e      	b.n	8020792 <RsaUnPad+0x17c>
    }
#ifndef WOLFSSL_RSA_VERIFY_ONLY
    else {
        unsigned int j;
        word16 pastSep = 0;
 80206b4:	2300      	movs	r3, #0
 80206b6:	827b      	strh	r3, [r7, #18]
        byte   invalid = 0;
 80206b8:	2300      	movs	r3, #0
 80206ba:	747b      	strb	r3, [r7, #17]

        i = 0;
 80206bc:	2300      	movs	r3, #0
 80206be:	837b      	strh	r3, [r7, #26]
        /* Decrypted with private key - unpad must be constant time. */
        for (j = 2; j < pkcsBlockLen; j++) {
 80206c0:	2302      	movs	r3, #2
 80206c2:	617b      	str	r3, [r7, #20]
 80206c4:	e029      	b.n	802071a <RsaUnPad+0x104>
           /* Update i if not passed the separator and at separator. */
            i |= (word16)(~pastSep) & ctMask16Eq(pkcsBlock[j], 0x00) &
 80206c6:	8a7b      	ldrh	r3, [r7, #18]
 80206c8:	43db      	mvns	r3, r3
 80206ca:	b29c      	uxth	r4, r3
 80206cc:	68fa      	ldr	r2, [r7, #12]
 80206ce:	697b      	ldr	r3, [r7, #20]
 80206d0:	4413      	add	r3, r2
 80206d2:	781b      	ldrb	r3, [r3, #0]
 80206d4:	2100      	movs	r1, #0
 80206d6:	4618      	mov	r0, r3
 80206d8:	f7ff fb11 	bl	801fcfe <ctMask16Eq>
 80206dc:	4603      	mov	r3, r0
 80206de:	4023      	ands	r3, r4
 80206e0:	b29a      	uxth	r2, r3
                (word16)(j + 1);
 80206e2:	697b      	ldr	r3, [r7, #20]
 80206e4:	b29b      	uxth	r3, r3
 80206e6:	3301      	adds	r3, #1
 80206e8:	b29b      	uxth	r3, r3
            i |= (word16)(~pastSep) & ctMask16Eq(pkcsBlock[j], 0x00) &
 80206ea:	4013      	ands	r3, r2
 80206ec:	b29b      	uxth	r3, r3
 80206ee:	b21a      	sxth	r2, r3
 80206f0:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80206f4:	4313      	orrs	r3, r2
 80206f6:	b21b      	sxth	r3, r3
 80206f8:	837b      	strh	r3, [r7, #26]
            pastSep |= ctMask16Eq(pkcsBlock[j], 0x00);
 80206fa:	68fa      	ldr	r2, [r7, #12]
 80206fc:	697b      	ldr	r3, [r7, #20]
 80206fe:	4413      	add	r3, r2
 8020700:	781b      	ldrb	r3, [r3, #0]
 8020702:	2100      	movs	r1, #0
 8020704:	4618      	mov	r0, r3
 8020706:	f7ff fafa 	bl	801fcfe <ctMask16Eq>
 802070a:	4603      	mov	r3, r0
 802070c:	461a      	mov	r2, r3
 802070e:	8a7b      	ldrh	r3, [r7, #18]
 8020710:	4313      	orrs	r3, r2
 8020712:	827b      	strh	r3, [r7, #18]
        for (j = 2; j < pkcsBlockLen; j++) {
 8020714:	697b      	ldr	r3, [r7, #20]
 8020716:	3301      	adds	r3, #1
 8020718:	617b      	str	r3, [r7, #20]
 802071a:	697a      	ldr	r2, [r7, #20]
 802071c:	68bb      	ldr	r3, [r7, #8]
 802071e:	429a      	cmp	r2, r3
 8020720:	d3d1      	bcc.n	80206c6 <RsaUnPad+0xb0>
        }

        /* Minimum of 11 bytes of pre-message data - including leading 0x00. */
        invalid |= ctMaskLT(i, RSA_MIN_PAD_SZ);
 8020722:	8b7b      	ldrh	r3, [r7, #26]
 8020724:	210b      	movs	r1, #11
 8020726:	4618      	mov	r0, r3
 8020728:	f7ff fa86 	bl	801fc38 <ctMaskLT>
 802072c:	4603      	mov	r3, r0
 802072e:	461a      	mov	r2, r3
 8020730:	7c7b      	ldrb	r3, [r7, #17]
 8020732:	4313      	orrs	r3, r2
 8020734:	747b      	strb	r3, [r7, #17]
        /* Must have seen separator. */
        invalid |= (byte)~pastSep;
 8020736:	8a7b      	ldrh	r3, [r7, #18]
 8020738:	b2db      	uxtb	r3, r3
 802073a:	43db      	mvns	r3, r3
 802073c:	b2da      	uxtb	r2, r3
 802073e:	7c7b      	ldrb	r3, [r7, #17]
 8020740:	4313      	orrs	r3, r2
 8020742:	747b      	strb	r3, [r7, #17]
        /* First byte must be 0x00. */
        invalid |= ctMaskNotEq(pkcsBlock[0], 0x00);
 8020744:	68fb      	ldr	r3, [r7, #12]
 8020746:	781b      	ldrb	r3, [r3, #0]
 8020748:	2100      	movs	r1, #0
 802074a:	4618      	mov	r0, r3
 802074c:	f7ff faef 	bl	801fd2e <ctMaskNotEq>
 8020750:	4603      	mov	r3, r0
 8020752:	461a      	mov	r2, r3
 8020754:	7c7b      	ldrb	r3, [r7, #17]
 8020756:	4313      	orrs	r3, r2
 8020758:	747b      	strb	r3, [r7, #17]
        /* Check against expected block type: padValue */
        invalid |= ctMaskNotEq(pkcsBlock[1], padValue);
 802075a:	68fb      	ldr	r3, [r7, #12]
 802075c:	3301      	adds	r3, #1
 802075e:	781b      	ldrb	r3, [r3, #0]
 8020760:	461a      	mov	r2, r3
 8020762:	78fb      	ldrb	r3, [r7, #3]
 8020764:	4619      	mov	r1, r3
 8020766:	4610      	mov	r0, r2
 8020768:	f7ff fae1 	bl	801fd2e <ctMaskNotEq>
 802076c:	4603      	mov	r3, r0
 802076e:	461a      	mov	r2, r3
 8020770:	7c7b      	ldrb	r3, [r7, #17]
 8020772:	4313      	orrs	r3, r2
 8020774:	747b      	strb	r3, [r7, #17]

        *output = (byte *)(pkcsBlock + i);
 8020776:	8b7b      	ldrh	r3, [r7, #26]
 8020778:	68fa      	ldr	r2, [r7, #12]
 802077a:	441a      	add	r2, r3
 802077c:	687b      	ldr	r3, [r7, #4]
 802077e:	601a      	str	r2, [r3, #0]
        ret = ((int)-1 + (int)(invalid >> 7)) & ((int)pkcsBlockLen - i);
 8020780:	7c7b      	ldrb	r3, [r7, #17]
 8020782:	09db      	lsrs	r3, r3, #7
 8020784:	b2db      	uxtb	r3, r3
 8020786:	1e5a      	subs	r2, r3, #1
 8020788:	68b9      	ldr	r1, [r7, #8]
 802078a:	8b7b      	ldrh	r3, [r7, #26]
 802078c:	1acb      	subs	r3, r1, r3
 802078e:	4013      	ands	r3, r2
 8020790:	61fb      	str	r3, [r7, #28]
    }
#endif

    return ret;
 8020792:	69fb      	ldr	r3, [r7, #28]
}
 8020794:	4618      	mov	r0, r3
 8020796:	3724      	adds	r7, #36	@ 0x24
 8020798:	46bd      	mov	sp, r7
 802079a:	bd90      	pop	{r4, r7, pc}

0802079c <wc_RsaUnPad_ex>:
 */
int wc_RsaUnPad_ex(byte* pkcsBlock, word32 pkcsBlockLen, byte** out,
                   byte padValue, int padType, enum wc_HashType hType,
                   int mgf, byte* optLabel, word32 labelLen, int saltLen,
                   int bits, void* heap)
{
 802079c:	b580      	push	{r7, lr}
 802079e:	b08a      	sub	sp, #40	@ 0x28
 80207a0:	af04      	add	r7, sp, #16
 80207a2:	60f8      	str	r0, [r7, #12]
 80207a4:	60b9      	str	r1, [r7, #8]
 80207a6:	607a      	str	r2, [r7, #4]
 80207a8:	70fb      	strb	r3, [r7, #3]
    int ret;

    switch (padType) {
 80207aa:	6a3b      	ldr	r3, [r7, #32]
 80207ac:	2b02      	cmp	r3, #2
 80207ae:	d023      	beq.n	80207f8 <wc_RsaUnPad_ex+0x5c>
 80207b0:	6a3b      	ldr	r3, [r7, #32]
 80207b2:	2b02      	cmp	r3, #2
 80207b4:	dc32      	bgt.n	802081c <wc_RsaUnPad_ex+0x80>
 80207b6:	6a3b      	ldr	r3, [r7, #32]
 80207b8:	2b00      	cmp	r3, #0
 80207ba:	d003      	beq.n	80207c4 <wc_RsaUnPad_ex+0x28>
 80207bc:	6a3b      	ldr	r3, [r7, #32]
 80207be:	2b01      	cmp	r3, #1
 80207c0:	d008      	beq.n	80207d4 <wc_RsaUnPad_ex+0x38>
 80207c2:	e02b      	b.n	802081c <wc_RsaUnPad_ex+0x80>
        case WC_RSA_PKCSV15_PAD:
            /*WOLFSSL_MSG("wolfSSL Using RSA PKCSV15 un-padding");*/
            ret = RsaUnPad(pkcsBlock, pkcsBlockLen, out, padValue);
 80207c4:	78fb      	ldrb	r3, [r7, #3]
 80207c6:	687a      	ldr	r2, [r7, #4]
 80207c8:	68b9      	ldr	r1, [r7, #8]
 80207ca:	68f8      	ldr	r0, [r7, #12]
 80207cc:	f7ff ff23 	bl	8020616 <RsaUnPad>
 80207d0:	6178      	str	r0, [r7, #20]
            break;
 80207d2:	e026      	b.n	8020822 <wc_RsaUnPad_ex+0x86>

    #ifndef WC_NO_RSA_OAEP
        case WC_RSA_OAEP_PAD:
            WOLFSSL_MSG("wolfSSL Using RSA OAEP un-padding");
            ret = RsaUnPad_OAEP((byte*)pkcsBlock, pkcsBlockLen, out,
 80207d4:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
 80207d8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80207da:	9303      	str	r3, [sp, #12]
 80207dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80207de:	9302      	str	r3, [sp, #8]
 80207e0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80207e2:	9301      	str	r3, [sp, #4]
 80207e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80207e6:	9300      	str	r3, [sp, #0]
 80207e8:	4613      	mov	r3, r2
 80207ea:	687a      	ldr	r2, [r7, #4]
 80207ec:	68b9      	ldr	r1, [r7, #8]
 80207ee:	68f8      	ldr	r0, [r7, #12]
 80207f0:	f7ff fd18 	bl	8020224 <RsaUnPad_OAEP>
 80207f4:	6178      	str	r0, [r7, #20]
                                        hType, mgf, optLabel, labelLen, heap);
            break;
 80207f6:	e014      	b.n	8020822 <wc_RsaUnPad_ex+0x86>
    #endif

    #ifdef WC_RSA_PSS
        case WC_RSA_PSS_PAD:
            WOLFSSL_MSG("wolfSSL Using RSA PSS un-padding");
            ret = RsaUnPad_PSS((byte*)pkcsBlock, pkcsBlockLen, out, hType, mgf,
 80207f8:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
 80207fc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80207fe:	9303      	str	r3, [sp, #12]
 8020800:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8020802:	9302      	str	r3, [sp, #8]
 8020804:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020806:	9301      	str	r3, [sp, #4]
 8020808:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802080a:	9300      	str	r3, [sp, #0]
 802080c:	4613      	mov	r3, r2
 802080e:	687a      	ldr	r2, [r7, #4]
 8020810:	68b9      	ldr	r1, [r7, #8]
 8020812:	68f8      	ldr	r0, [r7, #12]
 8020814:	f7ff fe06 	bl	8020424 <RsaUnPad_PSS>
 8020818:	6178      	str	r0, [r7, #20]
                                                           saltLen, bits, heap);
            break;
 802081a:	e002      	b.n	8020822 <wc_RsaUnPad_ex+0x86>
            break;
    #endif /* WC_RSA_NO_PADDING */

        default:
            WOLFSSL_MSG("Unknown RSA UnPad Type");
            ret = RSA_PAD_E;
 802081c:	f06f 03c8 	mvn.w	r3, #200	@ 0xc8
 8020820:	617b      	str	r3, [r7, #20]
    (void)labelLen;
    (void)saltLen;
    (void)bits;
    (void)heap;

    return ret;
 8020822:	697b      	ldr	r3, [r7, #20]
}
 8020824:	4618      	mov	r0, r3
 8020826:	3718      	adds	r7, #24
 8020828:	46bd      	mov	sp, r7
 802082a:	bd80      	pop	{r7, pc}

0802082c <RsaFunctionPrivate>:
#endif

#if !defined(WOLFSSL_SP_MATH)
#if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)
static int RsaFunctionPrivate(mp_int* tmp, RsaKey* key, WC_RNG* rng)
{
 802082c:	b580      	push	{r7, lr}
 802082e:	b08e      	sub	sp, #56	@ 0x38
 8020830:	af00      	add	r7, sp, #0
 8020832:	60f8      	str	r0, [r7, #12]
 8020834:	60b9      	str	r1, [r7, #8]
 8020836:	607a      	str	r2, [r7, #4]
    int    ret = 0;
 8020838:	2300      	movs	r3, #0
 802083a:	637b      	str	r3, [r7, #52]	@ 0x34
#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
    mp_digit mp = 0;
 802083c:	2300      	movs	r3, #0
 802083e:	613b      	str	r3, [r7, #16]
    DECL_MP_INT_SIZE_DYN(rnd, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020840:	2300      	movs	r3, #0
 8020842:	633b      	str	r3, [r7, #48]	@ 0x30
    DECL_MP_INT_SIZE_DYN(rndi, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020844:	2300      	movs	r3, #0
 8020846:	62fb      	str	r3, [r7, #44]	@ 0x2c
#endif /* WC_RSA_BLINDING && !WC_NO_RNG */

    (void)rng;

#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
    NEW_MP_INT_SIZE(rnd, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020848:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 802084c:	f7fe f922 	bl	801ea94 <wolfSSL_Malloc>
 8020850:	6338      	str	r0, [r7, #48]	@ 0x30
 8020852:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020854:	2b00      	cmp	r3, #0
 8020856:	d005      	beq.n	8020864 <RsaFunctionPrivate+0x38>
 8020858:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 802085c:	2100      	movs	r1, #0
 802085e:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020860:	f007 fe36 	bl	80284d0 <memset>
    NEW_MP_INT_SIZE(rndi, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020864:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8020868:	f7fe f914 	bl	801ea94 <wolfSSL_Malloc>
 802086c:	62f8      	str	r0, [r7, #44]	@ 0x2c
 802086e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020870:	2b00      	cmp	r3, #0
 8020872:	d005      	beq.n	8020880 <RsaFunctionPrivate+0x54>
 8020874:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8020878:	2100      	movs	r1, #0
 802087a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 802087c:	f007 fe28 	bl	80284d0 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if ((rnd == NULL) || (rndi == NULL)) {
 8020880:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020882:	2b00      	cmp	r3, #0
 8020884:	d002      	beq.n	802088c <RsaFunctionPrivate+0x60>
 8020886:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020888:	2b00      	cmp	r3, #0
 802088a:	d112      	bne.n	80208b2 <RsaFunctionPrivate+0x86>
        FREE_MP_INT_SIZE(rnd, key->heap, DYNAMIC_TYPE_RSA);
 802088c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802088e:	61bb      	str	r3, [r7, #24]
 8020890:	69bb      	ldr	r3, [r7, #24]
 8020892:	2b00      	cmp	r3, #0
 8020894:	d002      	beq.n	802089c <RsaFunctionPrivate+0x70>
 8020896:	69b8      	ldr	r0, [r7, #24]
 8020898:	f7fe f918 	bl	801eacc <wolfSSL_Free>
        FREE_MP_INT_SIZE(rndi, key->heap, DYNAMIC_TYPE_RSA);
 802089c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802089e:	617b      	str	r3, [r7, #20]
 80208a0:	697b      	ldr	r3, [r7, #20]
 80208a2:	2b00      	cmp	r3, #0
 80208a4:	d002      	beq.n	80208ac <RsaFunctionPrivate+0x80>
 80208a6:	6978      	ldr	r0, [r7, #20]
 80208a8:	f7fe f910 	bl	801eacc <wolfSSL_Free>
        return MEMORY_E;
 80208ac:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80208b0:	e15d      	b.n	8020b6e <RsaFunctionPrivate+0x342>
    }
#endif

    if ((INIT_MP_INT_SIZE(rnd, mp_bitsused(&key->n)) != MP_OKAY) ||
 80208b2:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80208b4:	f005 fef3 	bl	802669e <mp_init>
 80208b8:	4603      	mov	r3, r0
 80208ba:	2b00      	cmp	r3, #0
 80208bc:	d105      	bne.n	80208ca <RsaFunctionPrivate+0x9e>
            (INIT_MP_INT_SIZE(rndi, mp_bitsused(&key->n)) != MP_OKAY)) {
 80208be:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80208c0:	f005 feed 	bl	802669e <mp_init>
 80208c4:	4603      	mov	r3, r0
    if ((INIT_MP_INT_SIZE(rnd, mp_bitsused(&key->n)) != MP_OKAY) ||
 80208c6:	2b00      	cmp	r3, #0
 80208c8:	d002      	beq.n	80208d0 <RsaFunctionPrivate+0xa4>
        ret = MP_INIT_E;
 80208ca:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 80208ce:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    if (ret == 0) {
 80208d0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80208d2:	2b00      	cmp	r3, #0
 80208d4:	d10a      	bne.n	80208ec <RsaFunctionPrivate+0xc0>
        /* blind */
        ret = mp_rand(rnd, get_digit_count(&key->n), rng);
 80208d6:	68bb      	ldr	r3, [r7, #8]
 80208d8:	4618      	mov	r0, r3
 80208da:	f006 fde4 	bl	80274a6 <get_digit_count>
 80208de:	4603      	mov	r3, r0
 80208e0:	687a      	ldr	r2, [r7, #4]
 80208e2:	4619      	mov	r1, r3
 80208e4:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80208e6:	f006 fea2 	bl	802762e <mp_rand>
 80208ea:	6378      	str	r0, [r7, #52]	@ 0x34
    }
    if (ret == 0) {
 80208ec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80208ee:	2b00      	cmp	r3, #0
 80208f0:	d10b      	bne.n	802090a <RsaFunctionPrivate+0xde>
        /* rndi = 1/rnd mod n */
        if (mp_invmod(rnd, &key->n, rndi) != MP_OKAY) {
 80208f2:	68bb      	ldr	r3, [r7, #8]
 80208f4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80208f6:	4619      	mov	r1, r3
 80208f8:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80208fa:	f006 f81d 	bl	8026938 <mp_invmod>
 80208fe:	4603      	mov	r3, r0
 8020900:	2b00      	cmp	r3, #0
 8020902:	d002      	beq.n	802090a <RsaFunctionPrivate+0xde>
            ret = MP_INVMOD_E;
 8020904:	f06f 0376 	mvn.w	r3, #118	@ 0x76
 8020908:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }
    if (ret == 0) {
 802090a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802090c:	2b00      	cmp	r3, #0
 802090e:	d10d      	bne.n	802092c <RsaFunctionPrivate+0x100>
        mp_memzero_add("RSA Private rndi", rndi);
    #endif

        /* rnd = rnd^e */
    #ifndef WOLFSSL_SP_MATH_ALL
        if (mp_exptmod(rnd, &key->e, &key->n, rnd) != MP_OKAY) {
 8020910:	68bb      	ldr	r3, [r7, #8]
 8020912:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 8020916:	68ba      	ldr	r2, [r7, #8]
 8020918:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802091a:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 802091c:	f006 f82e 	bl	802697c <mp_exptmod>
 8020920:	4603      	mov	r3, r0
 8020922:	2b00      	cmp	r3, #0
 8020924:	d002      	beq.n	802092c <RsaFunctionPrivate+0x100>
            ret = MP_EXPTMOD_E;
 8020926:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 802092a:	637b      	str	r3, [r7, #52]	@ 0x34
            ret = MP_EXPTMOD_E;
        }
    #endif
    }

    if (ret == 0) {
 802092c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802092e:	2b00      	cmp	r3, #0
 8020930:	d10b      	bne.n	802094a <RsaFunctionPrivate+0x11e>
        /* tmp = tmp*rnd mod n */
        if (mp_mulmod(tmp, rnd, &key->n, tmp) != MP_OKAY) {
 8020932:	68ba      	ldr	r2, [r7, #8]
 8020934:	68fb      	ldr	r3, [r7, #12]
 8020936:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8020938:	68f8      	ldr	r0, [r7, #12]
 802093a:	f005 ffb4 	bl	80268a6 <mp_mulmod>
 802093e:	4603      	mov	r3, r0
 8020940:	2b00      	cmp	r3, #0
 8020942:	d002      	beq.n	802094a <RsaFunctionPrivate+0x11e>
            ret = MP_MULMOD_E;
 8020944:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020948:	637b      	str	r3, [r7, #52]	@ 0x34
        if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY) {
            ret = MP_EXPTMOD_E;
        }
    }
#else
    if (ret == 0 && (mp_iszero(&key->p) || mp_iszero(&key->q) ||
 802094a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802094c:	2b00      	cmp	r3, #0
 802094e:	d132      	bne.n	80209b6 <RsaFunctionPrivate+0x18a>
 8020950:	68bb      	ldr	r3, [r7, #8]
 8020952:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8020956:	4618      	mov	r0, r3
 8020958:	f006 f8fb 	bl	8026b52 <mp_iszero>
 802095c:	4603      	mov	r3, r0
 802095e:	2b00      	cmp	r3, #0
 8020960:	d11a      	bne.n	8020998 <RsaFunctionPrivate+0x16c>
 8020962:	68bb      	ldr	r3, [r7, #8]
 8020964:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8020968:	4618      	mov	r0, r3
 802096a:	f006 f8f2 	bl	8026b52 <mp_iszero>
 802096e:	4603      	mov	r3, r0
 8020970:	2b00      	cmp	r3, #0
 8020972:	d111      	bne.n	8020998 <RsaFunctionPrivate+0x16c>
            mp_iszero(&key->dP) || mp_iszero(&key->dQ))) {
 8020974:	68bb      	ldr	r3, [r7, #8]
 8020976:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 802097a:	4618      	mov	r0, r3
 802097c:	f006 f8e9 	bl	8026b52 <mp_iszero>
 8020980:	4603      	mov	r3, r0
    if (ret == 0 && (mp_iszero(&key->p) || mp_iszero(&key->q) ||
 8020982:	2b00      	cmp	r3, #0
 8020984:	d108      	bne.n	8020998 <RsaFunctionPrivate+0x16c>
            mp_iszero(&key->dP) || mp_iszero(&key->dQ))) {
 8020986:	68bb      	ldr	r3, [r7, #8]
 8020988:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 802098c:	4618      	mov	r0, r3
 802098e:	f006 f8e0 	bl	8026b52 <mp_iszero>
 8020992:	4603      	mov	r3, r0
 8020994:	2b00      	cmp	r3, #0
 8020996:	d00e      	beq.n	80209b6 <RsaFunctionPrivate+0x18a>
        if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY) {
 8020998:	68bb      	ldr	r3, [r7, #8]
 802099a:	f503 618b 	add.w	r1, r3, #1112	@ 0x458
 802099e:	68ba      	ldr	r2, [r7, #8]
 80209a0:	68fb      	ldr	r3, [r7, #12]
 80209a2:	68f8      	ldr	r0, [r7, #12]
 80209a4:	f005 ffea 	bl	802697c <mp_exptmod>
 80209a8:	4603      	mov	r3, r0
 80209aa:	2b00      	cmp	r3, #0
 80209ac:	d070      	beq.n	8020a90 <RsaFunctionPrivate+0x264>
            ret = MP_EXPTMOD_E;
 80209ae:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 80209b2:	637b      	str	r3, [r7, #52]	@ 0x34
        if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY) {
 80209b4:	e06c      	b.n	8020a90 <RsaFunctionPrivate+0x264>
        }
    }
    else if (ret == 0) {
 80209b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80209b8:	2b00      	cmp	r3, #0
 80209ba:	d169      	bne.n	8020a90 <RsaFunctionPrivate+0x264>
        mp_int* tmpa = tmp;
 80209bc:	68fb      	ldr	r3, [r7, #12]
 80209be:	62bb      	str	r3, [r7, #40]	@ 0x28
#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
        mp_int* tmpb = rnd;
 80209c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80209c2:	627b      	str	r3, [r7, #36]	@ 0x24
            mp_memzero_add("RSA Sync tmpb", tmpb);
        }
    #endif

        /* tmpb = tmp^dQ mod q */
        if (ret == 0 && mp_exptmod(tmp, &key->dQ, &key->q, tmpb) != MP_OKAY)
 80209c4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80209c6:	2b00      	cmp	r3, #0
 80209c8:	d10f      	bne.n	80209ea <RsaFunctionPrivate+0x1be>
 80209ca:	68bb      	ldr	r3, [r7, #8]
 80209cc:	f603 5108 	addw	r1, r3, #3336	@ 0xd08
 80209d0:	68bb      	ldr	r3, [r7, #8]
 80209d2:	f503 620b 	add.w	r2, r3, #2224	@ 0x8b0
 80209d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80209d8:	68f8      	ldr	r0, [r7, #12]
 80209da:	f005 ffcf 	bl	802697c <mp_exptmod>
 80209de:	4603      	mov	r3, r0
 80209e0:	2b00      	cmp	r3, #0
 80209e2:	d002      	beq.n	80209ea <RsaFunctionPrivate+0x1be>
            ret = MP_EXPTMOD_E;
 80209e4:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 80209e8:	637b      	str	r3, [r7, #52]	@ 0x34

        /* tmpa = tmp^dP mod p */
        if (ret == 0 && mp_exptmod(tmp, &key->dP, &key->p, tmpa) != MP_OKAY)
 80209ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80209ec:	2b00      	cmp	r3, #0
 80209ee:	d10f      	bne.n	8020a10 <RsaFunctionPrivate+0x1e4>
 80209f0:	68bb      	ldr	r3, [r7, #8]
 80209f2:	f603 21dc 	addw	r1, r3, #2780	@ 0xadc
 80209f6:	68bb      	ldr	r3, [r7, #8]
 80209f8:	f203 6284 	addw	r2, r3, #1668	@ 0x684
 80209fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80209fe:	68f8      	ldr	r0, [r7, #12]
 8020a00:	f005 ffbc 	bl	802697c <mp_exptmod>
 8020a04:	4603      	mov	r3, r0
 8020a06:	2b00      	cmp	r3, #0
 8020a08:	d002      	beq.n	8020a10 <RsaFunctionPrivate+0x1e4>
            ret = MP_EXPTMOD_E;
 8020a0a:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 8020a0e:	637b      	str	r3, [r7, #52]	@ 0x34
    #if (defined(WOLFSSL_SP_MATH) || (defined(WOLFSSL_SP_MATH_ALL)) && \
                                              !defined(WOLFSSL_SP_INT_NEGATIVE))
        if (ret == 0 && mp_submod(tmpa, tmpb, &key->p, tmp) != MP_OKAY)
            ret = MP_SUB_E;
    #else
        if (ret == 0 && mp_sub(tmpa, tmpb, tmp) != MP_OKAY)
 8020a10:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020a12:	2b00      	cmp	r3, #0
 8020a14:	d10a      	bne.n	8020a2c <RsaFunctionPrivate+0x200>
 8020a16:	68fa      	ldr	r2, [r7, #12]
 8020a18:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8020a1a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8020a1c:	f005 ff23 	bl	8026866 <mp_sub>
 8020a20:	4603      	mov	r3, r0
 8020a22:	2b00      	cmp	r3, #0
 8020a24:	d002      	beq.n	8020a2c <RsaFunctionPrivate+0x200>
            ret = MP_SUB_E;
 8020a26:	f06f 0371 	mvn.w	r3, #113	@ 0x71
 8020a2a:	637b      	str	r3, [r7, #52]	@ 0x34
    #endif

        if (ret == 0 && mp_mulmod(tmp, &key->u, &key->p, tmp) != MP_OKAY)
 8020a2c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020a2e:	2b00      	cmp	r3, #0
 8020a30:	d10f      	bne.n	8020a52 <RsaFunctionPrivate+0x226>
 8020a32:	68bb      	ldr	r3, [r7, #8]
 8020a34:	f603 7134 	addw	r1, r3, #3892	@ 0xf34
 8020a38:	68bb      	ldr	r3, [r7, #8]
 8020a3a:	f203 6284 	addw	r2, r3, #1668	@ 0x684
 8020a3e:	68fb      	ldr	r3, [r7, #12]
 8020a40:	68f8      	ldr	r0, [r7, #12]
 8020a42:	f005 ff30 	bl	80268a6 <mp_mulmod>
 8020a46:	4603      	mov	r3, r0
 8020a48:	2b00      	cmp	r3, #0
 8020a4a:	d002      	beq.n	8020a52 <RsaFunctionPrivate+0x226>
            ret = MP_MULMOD_E;
 8020a4c:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020a50:	637b      	str	r3, [r7, #52]	@ 0x34

        /* tmp = tmpb + q * tmp */
        if (ret == 0 && mp_mul(tmp, &key->q, tmp) != MP_OKAY)
 8020a52:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020a54:	2b00      	cmp	r3, #0
 8020a56:	d10d      	bne.n	8020a74 <RsaFunctionPrivate+0x248>
 8020a58:	68bb      	ldr	r3, [r7, #8]
 8020a5a:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8020a5e:	68fa      	ldr	r2, [r7, #12]
 8020a60:	4619      	mov	r1, r3
 8020a62:	68f8      	ldr	r0, [r7, #12]
 8020a64:	f005 ff0f 	bl	8026886 <mp_mul>
 8020a68:	4603      	mov	r3, r0
 8020a6a:	2b00      	cmp	r3, #0
 8020a6c:	d002      	beq.n	8020a74 <RsaFunctionPrivate+0x248>
            ret = MP_MUL_E;
 8020a6e:	f06f 0373 	mvn.w	r3, #115	@ 0x73
 8020a72:	637b      	str	r3, [r7, #52]	@ 0x34

        if (ret == 0 && mp_add(tmp, tmpb, tmp) != MP_OKAY)
 8020a74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020a76:	2b00      	cmp	r3, #0
 8020a78:	d10a      	bne.n	8020a90 <RsaFunctionPrivate+0x264>
 8020a7a:	68fa      	ldr	r2, [r7, #12]
 8020a7c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8020a7e:	68f8      	ldr	r0, [r7, #12]
 8020a80:	f005 fee1 	bl	8026846 <mp_add>
 8020a84:	4603      	mov	r3, r0
 8020a86:	2b00      	cmp	r3, #0
 8020a88:	d002      	beq.n	8020a90 <RsaFunctionPrivate+0x264>
            ret = MP_ADD_E;
 8020a8a:	f06f 0372 	mvn.w	r3, #114	@ 0x72
 8020a8e:	637b      	str	r3, [r7, #52]	@ 0x34

#if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)
    /* Multiply result (tmp) by blinding invertor (rndi).
     * Use Montgomery form to make operation more constant time.
     */
    if ((ret == 0) && (mp_montgomery_setup(&key->n, &mp) != MP_OKAY)) {
 8020a90:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020a92:	2b00      	cmp	r3, #0
 8020a94:	d10c      	bne.n	8020ab0 <RsaFunctionPrivate+0x284>
 8020a96:	68bb      	ldr	r3, [r7, #8]
 8020a98:	f107 0210 	add.w	r2, r7, #16
 8020a9c:	4611      	mov	r1, r2
 8020a9e:	4618      	mov	r0, r3
 8020aa0:	f006 fada 	bl	8027058 <mp_montgomery_setup>
 8020aa4:	4603      	mov	r3, r0
 8020aa6:	2b00      	cmp	r3, #0
 8020aa8:	d002      	beq.n	8020ab0 <RsaFunctionPrivate+0x284>
        ret = MP_MULMOD_E;
 8020aaa:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020aae:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    if ((ret == 0) && (mp_montgomery_calc_normalization(rnd, &key->n) !=
 8020ab0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020ab2:	2b00      	cmp	r3, #0
 8020ab4:	d10a      	bne.n	8020acc <RsaFunctionPrivate+0x2a0>
 8020ab6:	68bb      	ldr	r3, [r7, #8]
 8020ab8:	4619      	mov	r1, r3
 8020aba:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020abc:	f006 f87f 	bl	8026bbe <mp_montgomery_calc_normalization>
 8020ac0:	4603      	mov	r3, r0
 8020ac2:	2b00      	cmp	r3, #0
 8020ac4:	d002      	beq.n	8020acc <RsaFunctionPrivate+0x2a0>
            MP_OKAY)) {
        ret = MP_MULMOD_E;
 8020ac6:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020aca:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Convert blinding invert to Montgomery form. */
    if ((ret == 0) && (mp_mul(rndi, rnd, rndi) != MP_OKAY)) {
 8020acc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020ace:	2b00      	cmp	r3, #0
 8020ad0:	d10a      	bne.n	8020ae8 <RsaFunctionPrivate+0x2bc>
 8020ad2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020ad4:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8020ad6:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020ad8:	f005 fed5 	bl	8026886 <mp_mul>
 8020adc:	4603      	mov	r3, r0
 8020ade:	2b00      	cmp	r3, #0
 8020ae0:	d002      	beq.n	8020ae8 <RsaFunctionPrivate+0x2bc>
        ret = MP_MULMOD_E;
 8020ae2:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020ae6:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    if ((ret == 0) && (mp_mod(rndi, &key->n, rndi) != MP_OKAY)) {
 8020ae8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020aea:	2b00      	cmp	r3, #0
 8020aec:	d10b      	bne.n	8020b06 <RsaFunctionPrivate+0x2da>
 8020aee:	68bb      	ldr	r3, [r7, #8]
 8020af0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020af2:	4619      	mov	r1, r3
 8020af4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020af6:	f005 ff0f 	bl	8026918 <mp_mod>
 8020afa:	4603      	mov	r3, r0
 8020afc:	2b00      	cmp	r3, #0
 8020afe:	d002      	beq.n	8020b06 <RsaFunctionPrivate+0x2da>
        ret = MP_MULMOD_E;
 8020b00:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020b04:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Multiply result by blinding invert. */
    if ((ret == 0) && (mp_mul(tmp, rndi, tmp) != MP_OKAY)) {
 8020b06:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020b08:	2b00      	cmp	r3, #0
 8020b0a:	d10a      	bne.n	8020b22 <RsaFunctionPrivate+0x2f6>
 8020b0c:	68fa      	ldr	r2, [r7, #12]
 8020b0e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8020b10:	68f8      	ldr	r0, [r7, #12]
 8020b12:	f005 feb8 	bl	8026886 <mp_mul>
 8020b16:	4603      	mov	r3, r0
 8020b18:	2b00      	cmp	r3, #0
 8020b1a:	d002      	beq.n	8020b22 <RsaFunctionPrivate+0x2f6>
        ret = MP_MULMOD_E;
 8020b1c:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020b20:	637b      	str	r3, [r7, #52]	@ 0x34
    }
    /* Reduce result. */
    if ((ret == 0) && (mp_montgomery_reduce_ct(tmp, &key->n, mp) != MP_OKAY)) {
 8020b22:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020b24:	2b00      	cmp	r3, #0
 8020b26:	d10b      	bne.n	8020b40 <RsaFunctionPrivate+0x314>
 8020b28:	68b9      	ldr	r1, [r7, #8]
 8020b2a:	693a      	ldr	r2, [r7, #16]
 8020b2c:	2301      	movs	r3, #1
 8020b2e:	68f8      	ldr	r0, [r7, #12]
 8020b30:	f006 fa80 	bl	8027034 <mp_montgomery_reduce_ex>
 8020b34:	4603      	mov	r3, r0
 8020b36:	2b00      	cmp	r3, #0
 8020b38:	d002      	beq.n	8020b40 <RsaFunctionPrivate+0x314>
        ret = MP_MULMOD_E;
 8020b3a:	f06f 0374 	mvn.w	r3, #116	@ 0x74
 8020b3e:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    mp_forcezero(rndi);
 8020b40:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020b42:	f005 fe21 	bl	8026788 <mp_forcezero>
    mp_forcezero(rnd);
 8020b46:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020b48:	f005 fe1e 	bl	8026788 <mp_forcezero>
    FREE_MP_INT_SIZE(rndi, key->heap, DYNAMIC_TYPE_RSA);
 8020b4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020b4e:	623b      	str	r3, [r7, #32]
 8020b50:	6a3b      	ldr	r3, [r7, #32]
 8020b52:	2b00      	cmp	r3, #0
 8020b54:	d002      	beq.n	8020b5c <RsaFunctionPrivate+0x330>
 8020b56:	6a38      	ldr	r0, [r7, #32]
 8020b58:	f7fd ffb8 	bl	801eacc <wolfSSL_Free>
    FREE_MP_INT_SIZE(rnd, key->heap, DYNAMIC_TYPE_RSA);
 8020b5c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020b5e:	61fb      	str	r3, [r7, #28]
 8020b60:	69fb      	ldr	r3, [r7, #28]
 8020b62:	2b00      	cmp	r3, #0
 8020b64:	d002      	beq.n	8020b6c <RsaFunctionPrivate+0x340>
 8020b66:	69f8      	ldr	r0, [r7, #28]
 8020b68:	f7fd ffb0 	bl	801eacc <wolfSSL_Free>
#if !defined(MP_INT_SIZE_CHECK_NULL) && defined(WOLFSSL_CHECK_MEM_ZERO)
    mp_memzero_check(rnd);
    mp_memzero_check(rndi);
#endif
#endif /* WC_RSA_BLINDING && !WC_NO_RNG */
    return ret;
 8020b6c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8020b6e:	4618      	mov	r0, r3
 8020b70:	3738      	adds	r7, #56	@ 0x38
 8020b72:	46bd      	mov	sp, r7
 8020b74:	bd80      	pop	{r7, pc}

08020b76 <RsaFunctionSync>:
#endif

static int RsaFunctionSync(const byte* in, word32 inLen, byte* out,
    word32* outLen, int type, RsaKey* key, WC_RNG* rng)
{
 8020b76:	b580      	push	{r7, lr}
 8020b78:	b088      	sub	sp, #32
 8020b7a:	af00      	add	r7, sp, #0
 8020b7c:	60f8      	str	r0, [r7, #12]
 8020b7e:	60b9      	str	r1, [r7, #8]
 8020b80:	607a      	str	r2, [r7, #4]
 8020b82:	603b      	str	r3, [r7, #0]
    DECL_MP_INT_SIZE_DYN(tmp, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020b84:	2300      	movs	r3, #0
 8020b86:	61bb      	str	r3, [r7, #24]
    int    ret = 0;
 8020b88:	2300      	movs	r3, #0
 8020b8a:	61fb      	str	r3, [r7, #28]

    (void)rng;

    NEW_MP_INT_SIZE(tmp, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020b8c:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8020b90:	f7fd ff80 	bl	801ea94 <wolfSSL_Malloc>
 8020b94:	61b8      	str	r0, [r7, #24]
 8020b96:	69bb      	ldr	r3, [r7, #24]
 8020b98:	2b00      	cmp	r3, #0
 8020b9a:	d005      	beq.n	8020ba8 <RsaFunctionSync+0x32>
 8020b9c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8020ba0:	2100      	movs	r1, #0
 8020ba2:	69b8      	ldr	r0, [r7, #24]
 8020ba4:	f007 fc94 	bl	80284d0 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (tmp == NULL) {
 8020ba8:	69bb      	ldr	r3, [r7, #24]
 8020baa:	2b00      	cmp	r3, #0
 8020bac:	d102      	bne.n	8020bb4 <RsaFunctionSync+0x3e>
        WOLFSSL_MSG("NEW_MP_INT_SIZE tmp is NULL, return MEMORY_E");
        return MEMORY_E;
 8020bae:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020bb2:	e05c      	b.n	8020c6e <RsaFunctionSync+0xf8>
    }
#endif

    if (INIT_MP_INT_SIZE(tmp, mp_bitsused(&key->n)) != MP_OKAY) {
 8020bb4:	69b8      	ldr	r0, [r7, #24]
 8020bb6:	f005 fd72 	bl	802669e <mp_init>
 8020bba:	4603      	mov	r3, r0
 8020bbc:	2b00      	cmp	r3, #0
 8020bbe:	d002      	beq.n	8020bc6 <RsaFunctionSync+0x50>
        WOLFSSL_MSG("INIT_MP_INT_SIZE failed.");
        ret = MP_INIT_E;
 8020bc0:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8020bc4:	61fb      	str	r3, [r7, #28]
    }

#ifndef TEST_UNPAD_CONSTANT_TIME
    if (ret == 0 && mp_read_unsigned_bin(tmp, in, inLen) != MP_OKAY)
 8020bc6:	69fb      	ldr	r3, [r7, #28]
 8020bc8:	2b00      	cmp	r3, #0
 8020bca:	d10b      	bne.n	8020be4 <RsaFunctionSync+0x6e>
 8020bcc:	68bb      	ldr	r3, [r7, #8]
 8020bce:	461a      	mov	r2, r3
 8020bd0:	68f9      	ldr	r1, [r7, #12]
 8020bd2:	69b8      	ldr	r0, [r7, #24]
 8020bd4:	f005 ff3c 	bl	8026a50 <mp_read_unsigned_bin>
 8020bd8:	4603      	mov	r3, r0
 8020bda:	2b00      	cmp	r3, #0
 8020bdc:	d002      	beq.n	8020be4 <RsaFunctionSync+0x6e>
        ret = MP_READ_E;
 8020bde:	f06f 036e 	mvn.w	r3, #110	@ 0x6e
 8020be2:	61fb      	str	r3, [r7, #28]
    if (ret == 0) {
        mp_memzero_add("RSA sync tmp", tmp);
    }
#endif

    if (ret == 0) {
 8020be4:	69fb      	ldr	r3, [r7, #28]
 8020be6:	2b00      	cmp	r3, #0
 8020be8:	d125      	bne.n	8020c36 <RsaFunctionSync+0xc0>
        switch(type) {
 8020bea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020bec:	2b01      	cmp	r3, #1
 8020bee:	dc03      	bgt.n	8020bf8 <RsaFunctionSync+0x82>
 8020bf0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020bf2:	2b00      	cmp	r3, #0
 8020bf4:	da0b      	bge.n	8020c0e <RsaFunctionSync+0x98>
 8020bf6:	e019      	b.n	8020c2c <RsaFunctionSync+0xb6>
 8020bf8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020bfa:	3b02      	subs	r3, #2
 8020bfc:	2b01      	cmp	r3, #1
 8020bfe:	d815      	bhi.n	8020c2c <RsaFunctionSync+0xb6>
    #if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)
        case RSA_PRIVATE_DECRYPT:
        case RSA_PRIVATE_ENCRYPT:
        {
            ret = RsaFunctionPrivate(tmp, key, rng);
 8020c00:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8020c02:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8020c04:	69b8      	ldr	r0, [r7, #24]
 8020c06:	f7ff fe11 	bl	802082c <RsaFunctionPrivate>
 8020c0a:	61f8      	str	r0, [r7, #28]
            break;
 8020c0c:	e013      	b.n	8020c36 <RsaFunctionSync+0xc0>
        }
    #endif
        case RSA_PUBLIC_ENCRYPT:
        case RSA_PUBLIC_DECRYPT:
            if (mp_exptmod_nct(tmp, &key->e, &key->n, tmp) != MP_OKAY) {
 8020c0e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020c10:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 8020c14:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020c16:	69bb      	ldr	r3, [r7, #24]
 8020c18:	69b8      	ldr	r0, [r7, #24]
 8020c1a:	f005 fec1 	bl	80269a0 <mp_exptmod_nct>
 8020c1e:	4603      	mov	r3, r0
 8020c20:	2b00      	cmp	r3, #0
 8020c22:	d007      	beq.n	8020c34 <RsaFunctionSync+0xbe>
                WOLFSSL_MSG("mp_exptmod_nct failed");
                ret = MP_EXPTMOD_E;
 8020c24:	f06f 036f 	mvn.w	r3, #111	@ 0x6f
 8020c28:	61fb      	str	r3, [r7, #28]
            }
            break;
 8020c2a:	e003      	b.n	8020c34 <RsaFunctionSync+0xbe>
        default:
            ret = RSA_WRONG_TYPE_E;
 8020c2c:	f06f 0381 	mvn.w	r3, #129	@ 0x81
 8020c30:	61fb      	str	r3, [r7, #28]
            break;
 8020c32:	e000      	b.n	8020c36 <RsaFunctionSync+0xc0>
            break;
 8020c34:	bf00      	nop
        }
    }

    if (ret == 0) {
 8020c36:	69fb      	ldr	r3, [r7, #28]
 8020c38:	2b00      	cmp	r3, #0
 8020c3a:	d10c      	bne.n	8020c56 <RsaFunctionSync+0xe0>
        WOLFSSL_MSG("mp_to_unsigned_bin_len_ct...");
        if (mp_to_unsigned_bin_len_ct(tmp, out, (int)*outLen) != MP_OKAY) {
 8020c3c:	683b      	ldr	r3, [r7, #0]
 8020c3e:	681b      	ldr	r3, [r3, #0]
 8020c40:	461a      	mov	r2, r3
 8020c42:	6879      	ldr	r1, [r7, #4]
 8020c44:	69b8      	ldr	r0, [r7, #24]
 8020c46:	f005 fef3 	bl	8026a30 <mp_to_unsigned_bin_len>
 8020c4a:	4603      	mov	r3, r0
 8020c4c:	2b00      	cmp	r3, #0
 8020c4e:	d002      	beq.n	8020c56 <RsaFunctionSync+0xe0>
            WOLFSSL_MSG("mp_to_unsigned_bin_len_ct failed");
            ret = MP_TO_E;
 8020c50:	f06f 0370 	mvn.w	r3, #112	@ 0x70
 8020c54:	61fb      	str	r3, [r7, #28]
    (void)type;
    (void)key;
    XMEMCPY(out, in, inLen);
#endif

    mp_forcezero(tmp);
 8020c56:	69b8      	ldr	r0, [r7, #24]
 8020c58:	f005 fd96 	bl	8026788 <mp_forcezero>
    FREE_MP_INT_SIZE(tmp, key->heap, DYNAMIC_TYPE_RSA);
 8020c5c:	69bb      	ldr	r3, [r7, #24]
 8020c5e:	617b      	str	r3, [r7, #20]
 8020c60:	697b      	ldr	r3, [r7, #20]
 8020c62:	2b00      	cmp	r3, #0
 8020c64:	d002      	beq.n	8020c6c <RsaFunctionSync+0xf6>
 8020c66:	6978      	ldr	r0, [r7, #20]
 8020c68:	f7fd ff30 	bl	801eacc <wolfSSL_Free>
#if !defined(MP_INT_SIZE_CHECK_NULL) && defined(WOLFSSL_CHECK_MEM_ZERO)
    mp_memzero_check(tmp);
#endif
    return ret;
 8020c6c:	69fb      	ldr	r3, [r7, #28]
}
 8020c6e:	4618      	mov	r0, r3
 8020c70:	3720      	adds	r7, #32
 8020c72:	46bd      	mov	sp, r7
 8020c74:	bd80      	pop	{r7, pc}

08020c76 <wc_RsaFunctionSync>:
#endif /* !WOLFSSL_SP_MATH */

static int wc_RsaFunctionSync(const byte* in, word32 inLen, byte* out,
                          word32* outLen, int type, RsaKey* key, WC_RNG* rng)
{
 8020c76:	b580      	push	{r7, lr}
 8020c78:	b08a      	sub	sp, #40	@ 0x28
 8020c7a:	af04      	add	r7, sp, #16
 8020c7c:	60f8      	str	r0, [r7, #12]
 8020c7e:	60b9      	str	r1, [r7, #8]
 8020c80:	607a      	str	r2, [r7, #4]
 8020c82:	603b      	str	r3, [r7, #0]
    int ret;
    word32 keyLen;

    ret = wc_RsaEncryptSize(key);
 8020c84:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8020c86:	f000 fbb3 	bl	80213f0 <wc_RsaEncryptSize>
 8020c8a:	6178      	str	r0, [r7, #20]
    if (ret < 0) {
 8020c8c:	697b      	ldr	r3, [r7, #20]
 8020c8e:	2b00      	cmp	r3, #0
 8020c90:	da01      	bge.n	8020c96 <wc_RsaFunctionSync+0x20>
#ifdef DEBUG_WOLFSSL
        WOLFSSL_MSG_EX("wc_RsaEncryptSize failed err = %d", ret);
#endif
        return ret;
 8020c92:	697b      	ldr	r3, [r7, #20]
 8020c94:	e02d      	b.n	8020cf2 <wc_RsaFunctionSync+0x7c>
    }
    keyLen = (word32)ret;
 8020c96:	697b      	ldr	r3, [r7, #20]
 8020c98:	613b      	str	r3, [r7, #16]

    if (inLen > keyLen) {
 8020c9a:	68ba      	ldr	r2, [r7, #8]
 8020c9c:	693b      	ldr	r3, [r7, #16]
 8020c9e:	429a      	cmp	r2, r3
 8020ca0:	d902      	bls.n	8020ca8 <wc_RsaFunctionSync+0x32>
        WOLFSSL_MSG("Expected that inLen be no longer RSA key length");
        return BAD_FUNC_ARG;
 8020ca2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020ca6:	e024      	b.n	8020cf2 <wc_RsaFunctionSync+0x7c>
    }
    if (keyLen > *outLen) {
 8020ca8:	683b      	ldr	r3, [r7, #0]
 8020caa:	681b      	ldr	r3, [r3, #0]
 8020cac:	693a      	ldr	r2, [r7, #16]
 8020cae:	429a      	cmp	r2, r3
 8020cb0:	d902      	bls.n	8020cb8 <wc_RsaFunctionSync+0x42>
        WOLFSSL_MSG("Expected that outLen be no shorter RSA key length");
        return RSA_BUFFER_E;
 8020cb2:	f06f 0382 	mvn.w	r3, #130	@ 0x82
 8020cb6:	e01c      	b.n	8020cf2 <wc_RsaFunctionSync+0x7c>
    }

    if (mp_iseven(&key->n)) {
 8020cb8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020cba:	681b      	ldr	r3, [r3, #0]
 8020cbc:	2b00      	cmp	r3, #0
 8020cbe:	dd08      	ble.n	8020cd2 <wc_RsaFunctionSync+0x5c>
 8020cc0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020cc2:	68db      	ldr	r3, [r3, #12]
 8020cc4:	f003 0301 	and.w	r3, r3, #1
 8020cc8:	2b00      	cmp	r3, #0
 8020cca:	d102      	bne.n	8020cd2 <wc_RsaFunctionSync+0x5c>
        WOLFSSL_MSG("MP_VAL is even");
        return MP_VAL;
 8020ccc:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8020cd0:	e00f      	b.n	8020cf2 <wc_RsaFunctionSync+0x7c>
#else
    WOLFSSL_MSG("SP Key Size Error");
    return WC_KEY_SIZE_E;
#endif
#else
    *outLen = keyLen;
 8020cd2:	683b      	ldr	r3, [r7, #0]
 8020cd4:	693a      	ldr	r2, [r7, #16]
 8020cd6:	601a      	str	r2, [r3, #0]
    return RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
 8020cd8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020cda:	9302      	str	r3, [sp, #8]
 8020cdc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020cde:	9301      	str	r3, [sp, #4]
 8020ce0:	6a3b      	ldr	r3, [r7, #32]
 8020ce2:	9300      	str	r3, [sp, #0]
 8020ce4:	683b      	ldr	r3, [r7, #0]
 8020ce6:	687a      	ldr	r2, [r7, #4]
 8020ce8:	68b9      	ldr	r1, [r7, #8]
 8020cea:	68f8      	ldr	r0, [r7, #12]
 8020cec:	f7ff ff43 	bl	8020b76 <RsaFunctionSync>
 8020cf0:	4603      	mov	r3, r0
#endif /* WOLFSSL_SP_MATH */
}
 8020cf2:	4618      	mov	r0, r3
 8020cf4:	3718      	adds	r7, #24
 8020cf6:	46bd      	mov	sp, r7
 8020cf8:	bd80      	pop	{r7, pc}

08020cfa <RsaFunctionCheckIn>:
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(TEST_UNPAD_CONSTANT_TIME) && \
    !defined(NO_RSA_BOUNDS_CHECK)
/* Check that 1 < in < n-1. (Requirement of 800-56B.) */
int RsaFunctionCheckIn(const byte* in, word32 inLen, RsaKey* key,
    int checkSmallCt)
{
 8020cfa:	b580      	push	{r7, lr}
 8020cfc:	b088      	sub	sp, #32
 8020cfe:	af00      	add	r7, sp, #0
 8020d00:	60f8      	str	r0, [r7, #12]
 8020d02:	60b9      	str	r1, [r7, #8]
 8020d04:	607a      	str	r2, [r7, #4]
 8020d06:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8020d08:	2300      	movs	r3, #0
 8020d0a:	61fb      	str	r3, [r7, #28]
    DECL_MP_INT_SIZE_DYN(c, mp_bitsused(&key->n), RSA_MAX_SIZE);
 8020d0c:	2300      	movs	r3, #0
 8020d0e:	61bb      	str	r3, [r7, #24]

    NEW_MP_INT_SIZE(c, mp_bitsused(&key->n), key->heap, DYNAMIC_TYPE_RSA);
 8020d10:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8020d14:	f7fd febe 	bl	801ea94 <wolfSSL_Malloc>
 8020d18:	61b8      	str	r0, [r7, #24]
 8020d1a:	69bb      	ldr	r3, [r7, #24]
 8020d1c:	2b00      	cmp	r3, #0
 8020d1e:	d005      	beq.n	8020d2c <RsaFunctionCheckIn+0x32>
 8020d20:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8020d24:	2100      	movs	r1, #0
 8020d26:	69b8      	ldr	r0, [r7, #24]
 8020d28:	f007 fbd2 	bl	80284d0 <memset>
#ifdef MP_INT_SIZE_CHECK_NULL
    if (c == NULL)
 8020d2c:	69bb      	ldr	r3, [r7, #24]
 8020d2e:	2b00      	cmp	r3, #0
 8020d30:	d102      	bne.n	8020d38 <RsaFunctionCheckIn+0x3e>
        ret = MEMORY_E;
 8020d32:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020d36:	61fb      	str	r3, [r7, #28]
#endif

    if (ret == 0 && INIT_MP_INT_SIZE(c, mp_bitsused(&key->n)) != MP_OKAY) {
 8020d38:	69fb      	ldr	r3, [r7, #28]
 8020d3a:	2b00      	cmp	r3, #0
 8020d3c:	d108      	bne.n	8020d50 <RsaFunctionCheckIn+0x56>
 8020d3e:	69b8      	ldr	r0, [r7, #24]
 8020d40:	f005 fcad 	bl	802669e <mp_init>
 8020d44:	4603      	mov	r3, r0
 8020d46:	2b00      	cmp	r3, #0
 8020d48:	d002      	beq.n	8020d50 <RsaFunctionCheckIn+0x56>
        ret = MP_INIT_E;
 8020d4a:	f06f 036d 	mvn.w	r3, #109	@ 0x6d
 8020d4e:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020d50:	69fb      	ldr	r3, [r7, #28]
 8020d52:	2b00      	cmp	r3, #0
 8020d54:	d10b      	bne.n	8020d6e <RsaFunctionCheckIn+0x74>
        if (mp_read_unsigned_bin(c, in, inLen) != 0)
 8020d56:	68bb      	ldr	r3, [r7, #8]
 8020d58:	461a      	mov	r2, r3
 8020d5a:	68f9      	ldr	r1, [r7, #12]
 8020d5c:	69b8      	ldr	r0, [r7, #24]
 8020d5e:	f005 fe77 	bl	8026a50 <mp_read_unsigned_bin>
 8020d62:	4603      	mov	r3, r0
 8020d64:	2b00      	cmp	r3, #0
 8020d66:	d002      	beq.n	8020d6e <RsaFunctionCheckIn+0x74>
            ret = MP_READ_E;
 8020d68:	f06f 036e 	mvn.w	r3, #110	@ 0x6e
 8020d6c:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020d6e:	69fb      	ldr	r3, [r7, #28]
 8020d70:	2b00      	cmp	r3, #0
 8020d72:	d10c      	bne.n	8020d8e <RsaFunctionCheckIn+0x94>
        /* check c > 1 */
        if (checkSmallCt && (mp_cmp_d(c, 1) != MP_GT))
 8020d74:	683b      	ldr	r3, [r7, #0]
 8020d76:	2b00      	cmp	r3, #0
 8020d78:	d009      	beq.n	8020d8e <RsaFunctionCheckIn+0x94>
 8020d7a:	2101      	movs	r1, #1
 8020d7c:	69b8      	ldr	r0, [r7, #24]
 8020d7e:	f005 fe2f 	bl	80269e0 <mp_cmp_d>
 8020d82:	4603      	mov	r3, r0
 8020d84:	2b01      	cmp	r3, #1
 8020d86:	d002      	beq.n	8020d8e <RsaFunctionCheckIn+0x94>
            ret = RSA_OUT_OF_RANGE_E;
 8020d88:	f06f 03fc 	mvn.w	r3, #252	@ 0xfc
 8020d8c:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020d8e:	69fb      	ldr	r3, [r7, #28]
 8020d90:	2b00      	cmp	r3, #0
 8020d92:	d10a      	bne.n	8020daa <RsaFunctionCheckIn+0xb0>
        /* add c+1 */
        if (mp_add_d(c, 1, c) != MP_OKAY)
 8020d94:	69ba      	ldr	r2, [r7, #24]
 8020d96:	2101      	movs	r1, #1
 8020d98:	69b8      	ldr	r0, [r7, #24]
 8020d9a:	f005 ffe0 	bl	8026d5e <mp_add_d>
 8020d9e:	4603      	mov	r3, r0
 8020da0:	2b00      	cmp	r3, #0
 8020da2:	d002      	beq.n	8020daa <RsaFunctionCheckIn+0xb0>
            ret = MP_ADD_E;
 8020da4:	f06f 0372 	mvn.w	r3, #114	@ 0x72
 8020da8:	61fb      	str	r3, [r7, #28]
    }
    if (ret == 0) {
 8020daa:	69fb      	ldr	r3, [r7, #28]
 8020dac:	2b00      	cmp	r3, #0
 8020dae:	d10b      	bne.n	8020dc8 <RsaFunctionCheckIn+0xce>
        /* check c+1 < n */
        if (mp_cmp(c, &key->n) != MP_LT)
 8020db0:	687b      	ldr	r3, [r7, #4]
 8020db2:	4619      	mov	r1, r3
 8020db4:	69b8      	ldr	r0, [r7, #24]
 8020db6:	f005 fe05 	bl	80269c4 <mp_cmp>
 8020dba:	4603      	mov	r3, r0
 8020dbc:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8020dc0:	d002      	beq.n	8020dc8 <RsaFunctionCheckIn+0xce>
            ret = RSA_OUT_OF_RANGE_E;
 8020dc2:	f06f 03fc 	mvn.w	r3, #252	@ 0xfc
 8020dc6:	61fb      	str	r3, [r7, #28]
    }
    mp_clear(c);
 8020dc8:	69b8      	ldr	r0, [r7, #24]
 8020dca:	f005 fcf2 	bl	80267b2 <mp_clear>

    FREE_MP_INT_SIZE(c, key->heap, DYNAMIC_TYPE_RSA);
 8020dce:	69bb      	ldr	r3, [r7, #24]
 8020dd0:	617b      	str	r3, [r7, #20]
 8020dd2:	697b      	ldr	r3, [r7, #20]
 8020dd4:	2b00      	cmp	r3, #0
 8020dd6:	d002      	beq.n	8020dde <RsaFunctionCheckIn+0xe4>
 8020dd8:	6978      	ldr	r0, [r7, #20]
 8020dda:	f7fd fe77 	bl	801eacc <wolfSSL_Free>

    return ret;
 8020dde:	69fb      	ldr	r3, [r7, #28]
}
 8020de0:	4618      	mov	r0, r3
 8020de2:	3720      	adds	r7, #32
 8020de4:	46bd      	mov	sp, r7
 8020de6:	bd80      	pop	{r7, pc}

08020de8 <wc_RsaFunction_ex>:
#endif /* WOLF_CRYPTO_CB_ONLY_RSA */

static int wc_RsaFunction_ex(const byte* in, word32 inLen, byte* out,
                             word32* outLen, int type, RsaKey* key, WC_RNG* rng,
                             int checkSmallCt)
{
 8020de8:	b580      	push	{r7, lr}
 8020dea:	b08a      	sub	sp, #40	@ 0x28
 8020dec:	af04      	add	r7, sp, #16
 8020dee:	60f8      	str	r0, [r7, #12]
 8020df0:	60b9      	str	r1, [r7, #8]
 8020df2:	607a      	str	r2, [r7, #4]
 8020df4:	603b      	str	r3, [r7, #0]
    int ret = 0;
 8020df6:	2300      	movs	r3, #0
 8020df8:	617b      	str	r3, [r7, #20]
    (void)checkSmallCt;
#if defined(WOLF_CRYPTO_CB) && defined(WOLF_CRYPTO_CB_RSA_PAD)
    RsaPadding padding;
#endif

    if (key == NULL || in == NULL || inLen == 0 || out == NULL ||
 8020dfa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020dfc:	2b00      	cmp	r3, #0
 8020dfe:	d013      	beq.n	8020e28 <wc_RsaFunction_ex+0x40>
 8020e00:	68fb      	ldr	r3, [r7, #12]
 8020e02:	2b00      	cmp	r3, #0
 8020e04:	d010      	beq.n	8020e28 <wc_RsaFunction_ex+0x40>
 8020e06:	68bb      	ldr	r3, [r7, #8]
 8020e08:	2b00      	cmp	r3, #0
 8020e0a:	d00d      	beq.n	8020e28 <wc_RsaFunction_ex+0x40>
 8020e0c:	687b      	ldr	r3, [r7, #4]
 8020e0e:	2b00      	cmp	r3, #0
 8020e10:	d00a      	beq.n	8020e28 <wc_RsaFunction_ex+0x40>
 8020e12:	683b      	ldr	r3, [r7, #0]
 8020e14:	2b00      	cmp	r3, #0
 8020e16:	d007      	beq.n	8020e28 <wc_RsaFunction_ex+0x40>
            outLen == NULL || *outLen == 0 || type == RSA_TYPE_UNKNOWN) {
 8020e18:	683b      	ldr	r3, [r7, #0]
 8020e1a:	681b      	ldr	r3, [r3, #0]
 8020e1c:	2b00      	cmp	r3, #0
 8020e1e:	d003      	beq.n	8020e28 <wc_RsaFunction_ex+0x40>
 8020e20:	6a3b      	ldr	r3, [r7, #32]
 8020e22:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8020e26:	d102      	bne.n	8020e2e <wc_RsaFunction_ex+0x46>
        return BAD_FUNC_ARG;
 8020e28:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020e2c:	e034      	b.n	8020e98 <wc_RsaFunction_ex+0xb0>
#else /* !WOLF_CRYPTO_CB_ONLY_RSA */
    SAVE_VECTOR_REGISTERS(return _svr_ret;);

#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(TEST_UNPAD_CONSTANT_TIME) && \
    !defined(NO_RSA_BOUNDS_CHECK)
    if (type == RSA_PRIVATE_DECRYPT &&
 8020e2e:	6a3b      	ldr	r3, [r7, #32]
 8020e30:	2b03      	cmp	r3, #3
 8020e32:	d112      	bne.n	8020e5a <wc_RsaFunction_ex+0x72>
        key->state == RSA_STATE_DECRYPT_EXPTMOD) {
 8020e34:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020e36:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020e3a:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
    if (type == RSA_PRIVATE_DECRYPT &&
 8020e3e:	2b04      	cmp	r3, #4
 8020e40:	d10b      	bne.n	8020e5a <wc_RsaFunction_ex+0x72>

        ret = RsaFunctionCheckIn(in, inLen, key, checkSmallCt);
 8020e42:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020e44:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8020e46:	68b9      	ldr	r1, [r7, #8]
 8020e48:	68f8      	ldr	r0, [r7, #12]
 8020e4a:	f7ff ff56 	bl	8020cfa <RsaFunctionCheckIn>
 8020e4e:	6178      	str	r0, [r7, #20]
        if (ret != 0) {
 8020e50:	697b      	ldr	r3, [r7, #20]
 8020e52:	2b00      	cmp	r3, #0
 8020e54:	d001      	beq.n	8020e5a <wc_RsaFunction_ex+0x72>
            RESTORE_VECTOR_REGISTERS();
            return ret;
 8020e56:	697b      	ldr	r3, [r7, #20]
 8020e58:	e01e      	b.n	8020e98 <wc_RsaFunction_ex+0xb0>
        ret = wc_RsaFunctionNonBlock(in, inLen, out, outLen, type, key);
    }
    else
#endif
    {
        ret = wc_RsaFunctionSync(in, inLen, out, outLen, type, key, rng);
 8020e5a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020e5c:	9302      	str	r3, [sp, #8]
 8020e5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020e60:	9301      	str	r3, [sp, #4]
 8020e62:	6a3b      	ldr	r3, [r7, #32]
 8020e64:	9300      	str	r3, [sp, #0]
 8020e66:	683b      	ldr	r3, [r7, #0]
 8020e68:	687a      	ldr	r2, [r7, #4]
 8020e6a:	68b9      	ldr	r1, [r7, #8]
 8020e6c:	68f8      	ldr	r0, [r7, #12]
 8020e6e:	f7ff ff02 	bl	8020c76 <wc_RsaFunctionSync>
 8020e72:	6178      	str	r0, [r7, #20]
    }

    RESTORE_VECTOR_REGISTERS();

    /* handle error */
    if (ret < 0 && ret != WC_NO_ERR_TRACE(WC_PENDING_E)
 8020e74:	697b      	ldr	r3, [r7, #20]
 8020e76:	2b00      	cmp	r3, #0
 8020e78:	da0d      	bge.n	8020e96 <wc_RsaFunction_ex+0xae>
 8020e7a:	697b      	ldr	r3, [r7, #20]
 8020e7c:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 8020e80:	d009      	beq.n	8020e96 <wc_RsaFunction_ex+0xae>
        if (ret == WC_NO_ERR_TRACE(MP_EXPTMOD_E)) {
            /* This can happen due to incorrectly set FP_MAX_BITS or missing XREALLOC */
            WOLFSSL_MSG("RSA_FUNCTION MP_EXPTMOD_E: memory/config problem");
        }

        key->state = RSA_STATE_NONE;
 8020e82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020e84:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020e88:	461a      	mov	r2, r3
 8020e8a:	2300      	movs	r3, #0
 8020e8c:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
        wc_RsaCleanup(key);
 8020e90:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8020e92:	f7fe ff93 	bl	801fdbc <wc_RsaCleanup>
    }
    return ret;
 8020e96:	697b      	ldr	r3, [r7, #20]
#endif /* !WOLF_CRYPTO_CB_ONLY_RSA */
}
 8020e98:	4618      	mov	r0, r3
 8020e9a:	3718      	adds	r7, #24
 8020e9c:	46bd      	mov	sp, r7
 8020e9e:	bd80      	pop	{r7, pc}

08020ea0 <RsaPrivateDecryptEx>:
                            word32 outLen, byte** outPtr, RsaKey* key,
                            int rsa_type, byte pad_value, int pad_type,
                            enum wc_HashType hash, int mgf,
                            byte* label, word32 labelSz, int saltLen,
                            WC_RNG* rng)
{
 8020ea0:	b5b0      	push	{r4, r5, r7, lr}
 8020ea2:	b092      	sub	sp, #72	@ 0x48
 8020ea4:	af08      	add	r7, sp, #32
 8020ea6:	60f8      	str	r0, [r7, #12]
 8020ea8:	60b9      	str	r1, [r7, #8]
 8020eaa:	607a      	str	r2, [r7, #4]
 8020eac:	603b      	str	r3, [r7, #0]
    int ret = WC_NO_ERR_TRACE(RSA_WRONG_TYPE_E);
 8020eae:	f06f 0381 	mvn.w	r3, #129	@ 0x81
 8020eb2:	627b      	str	r3, [r7, #36]	@ 0x24
    byte* pad = NULL;
 8020eb4:	2300      	movs	r3, #0
 8020eb6:	613b      	str	r3, [r7, #16]
#if defined(WOLF_CRYPTO_CB) && defined(WOLF_CRYPTO_CB_RSA_PAD)
    RsaPadding padding;
#endif

    if (in == NULL || inLen == 0 || out == NULL || key == NULL) {
 8020eb8:	68fb      	ldr	r3, [r7, #12]
 8020eba:	2b00      	cmp	r3, #0
 8020ebc:	d008      	beq.n	8020ed0 <RsaPrivateDecryptEx+0x30>
 8020ebe:	68bb      	ldr	r3, [r7, #8]
 8020ec0:	2b00      	cmp	r3, #0
 8020ec2:	d005      	beq.n	8020ed0 <RsaPrivateDecryptEx+0x30>
 8020ec4:	687b      	ldr	r3, [r7, #4]
 8020ec6:	2b00      	cmp	r3, #0
 8020ec8:	d002      	beq.n	8020ed0 <RsaPrivateDecryptEx+0x30>
 8020eca:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020ecc:	2b00      	cmp	r3, #0
 8020ece:	d102      	bne.n	8020ed6 <RsaPrivateDecryptEx+0x36>
        return BAD_FUNC_ARG;
 8020ed0:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8020ed4:	e164      	b.n	80211a0 <RsaPrivateDecryptEx+0x300>
    }

    switch (key->state) {
 8020ed6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020ed8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020edc:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 8020ee0:	2b06      	cmp	r3, #6
 8020ee2:	f200 8145 	bhi.w	8021170 <RsaPrivateDecryptEx+0x2d0>
 8020ee6:	a201      	add	r2, pc, #4	@ (adr r2, 8020eec <RsaPrivateDecryptEx+0x4c>)
 8020ee8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8020eec:	08020f09 	.word	0x08020f09
 8020ef0:	08021171 	.word	0x08021171
 8020ef4:	08021171 	.word	0x08021171
 8020ef8:	08021171 	.word	0x08021171
 8020efc:	08020fb3 	.word	0x08020fb3
 8020f00:	08021017 	.word	0x08021017
 8020f04:	08021179 	.word	0x08021179
    case RSA_STATE_NONE:
        key->dataLen = inLen;
 8020f08:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f0a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f0e:	461a      	mov	r2, r3
 8020f10:	68bb      	ldr	r3, [r7, #8]
 8020f12:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170


#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
        /* verify the tmp ptr is NULL, otherwise indicates bad state */
        if (key->data != NULL) {
 8020f16:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f18:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f1c:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8020f20:	2b00      	cmp	r3, #0
 8020f22:	d003      	beq.n	8020f2c <RsaPrivateDecryptEx+0x8c>
            ret = BAD_STATE_E;
 8020f24:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 8020f28:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 8020f2a:	e128      	b.n	802117e <RsaPrivateDecryptEx+0x2de>
        }

        /* if not doing this inline then allocate a buffer for it */
        if (outPtr == NULL) {
 8020f2c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8020f2e:	2b00      	cmp	r3, #0
 8020f30:	d12b      	bne.n	8020f8a <RsaPrivateDecryptEx+0xea>
            key->data = (byte*)XMALLOC(inLen, key->heap,
 8020f32:	68b8      	ldr	r0, [r7, #8]
 8020f34:	f7fd fdae 	bl	801ea94 <wolfSSL_Malloc>
 8020f38:	4602      	mov	r2, r0
 8020f3a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f3c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f40:	f8c3 2164 	str.w	r2, [r3, #356]	@ 0x164
                                                      DYNAMIC_TYPE_WOLF_BIGINT);
            key->dataIsAlloc = 1;
 8020f44:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f46:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f4a:	2201      	movs	r2, #1
 8020f4c:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
            if (key->data == NULL) {
 8020f50:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f52:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f56:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8020f5a:	2b00      	cmp	r3, #0
 8020f5c:	d103      	bne.n	8020f66 <RsaPrivateDecryptEx+0xc6>
                ret = MEMORY_E;
 8020f5e:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8020f62:	627b      	str	r3, [r7, #36]	@ 0x24
                break;
 8020f64:	e10b      	b.n	802117e <RsaPrivateDecryptEx+0x2de>
            }
            XMEMCPY(key->data, in, inLen);
 8020f66:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f68:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f6c:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 8020f70:	68ba      	ldr	r2, [r7, #8]
 8020f72:	68f9      	ldr	r1, [r7, #12]
 8020f74:	4618      	mov	r0, r3
 8020f76:	f007 fb15 	bl	80285a4 <memcpy>
            key->dataLen = inLen;
 8020f7a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f7c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f80:	461a      	mov	r2, r3
 8020f82:	68bb      	ldr	r3, [r7, #8]
 8020f84:	f8c2 3170 	str.w	r3, [r2, #368]	@ 0x170
 8020f88:	e00c      	b.n	8020fa4 <RsaPrivateDecryptEx+0x104>
        }
        else {
            key->dataIsAlloc = 0;
 8020f8a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f8c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f90:	2200      	movs	r2, #0
 8020f92:	f883 2178 	strb.w	r2, [r3, #376]	@ 0x178
            key->data = out;
 8020f96:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020f98:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020f9c:	461a      	mov	r2, r3
 8020f9e:	687b      	ldr	r3, [r7, #4]
 8020fa0:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
        }
#endif

        key->state = RSA_STATE_DECRYPT_EXPTMOD;
 8020fa4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020fa6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020faa:	461a      	mov	r2, r3
 8020fac:	2304      	movs	r3, #4
 8020fae:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
        }
    }
#endif
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
        ret = wc_RsaFunction_ex(key->data, inLen, key->data, &key->dataLen,
 8020fb2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020fb4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020fb8:	f8d3 0164 	ldr.w	r0, [r3, #356]	@ 0x164
 8020fbc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020fbe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8020fc2:	f8d3 1164 	ldr.w	r1, [r3, #356]	@ 0x164
 8020fc6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020fc8:	f503 538b 	add.w	r3, r3, #4448	@ 0x1160
 8020fcc:	3310      	adds	r3, #16
 8020fce:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8020fd0:	2a01      	cmp	r2, #1
 8020fd2:	bf14      	ite	ne
 8020fd4:	2201      	movne	r2, #1
 8020fd6:	2200      	moveq	r2, #0
 8020fd8:	b2d2      	uxtb	r2, r2
 8020fda:	9203      	str	r2, [sp, #12]
 8020fdc:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8020fde:	9202      	str	r2, [sp, #8]
 8020fe0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8020fe2:	9201      	str	r2, [sp, #4]
 8020fe4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8020fe6:	9200      	str	r2, [sp, #0]
 8020fe8:	460a      	mov	r2, r1
 8020fea:	68b9      	ldr	r1, [r7, #8]
 8020fec:	f7ff fefc 	bl	8020de8 <wc_RsaFunction_ex>
 8020ff0:	6278      	str	r0, [r7, #36]	@ 0x24
#else
        ret = wc_RsaFunction_ex(in, inLen, out, &key->dataLen, rsa_type, key,
                                              rng, pad_type != WC_RSA_OAEP_PAD);
#endif

        if (ret >= 0 || ret == WC_NO_ERR_TRACE(WC_PENDING_E)) {
 8020ff2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020ff4:	2b00      	cmp	r3, #0
 8020ff6:	da03      	bge.n	8021000 <RsaPrivateDecryptEx+0x160>
 8020ff8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020ffa:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 8020ffe:	d106      	bne.n	802100e <RsaPrivateDecryptEx+0x16e>
            key->state = RSA_STATE_DECRYPT_UNPAD;
 8021000:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021002:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021006:	461a      	mov	r2, r3
 8021008:	2305      	movs	r3, #5
 802100a:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
        }
        if (ret < 0) {
 802100e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021010:	2b00      	cmp	r3, #0
 8021012:	f2c0 80b3 	blt.w	802117c <RsaPrivateDecryptEx+0x2dc>
        FALL_THROUGH;

    case RSA_STATE_DECRYPT_UNPAD:
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
        ret = wc_RsaUnPad_ex(key->data,
 8021016:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021018:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802101c:	f8d3 4164 	ldr.w	r4, [r3, #356]	@ 0x164
 8021020:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021022:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021026:	f8d3 5170 	ldr.w	r5, [r3, #368]	@ 0x170
            key->dataLen, &pad, pad_value, pad_type, hash, mgf,
            label, labelSz, saltLen, mp_count_bits(&key->n), key->heap);
 802102a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
        ret = wc_RsaUnPad_ex(key->data,
 802102c:	4618      	mov	r0, r3
 802102e:	f005 fda1 	bl	8026b74 <mp_count_bits>
 8021032:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021034:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021038:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
 802103c:	f897 1044 	ldrb.w	r1, [r7, #68]	@ 0x44
 8021040:	f107 0210 	add.w	r2, r7, #16
 8021044:	9307      	str	r3, [sp, #28]
 8021046:	9006      	str	r0, [sp, #24]
 8021048:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802104a:	9305      	str	r3, [sp, #20]
 802104c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802104e:	9304      	str	r3, [sp, #16]
 8021050:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8021052:	9303      	str	r3, [sp, #12]
 8021054:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8021056:	9302      	str	r3, [sp, #8]
 8021058:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 802105c:	9301      	str	r3, [sp, #4]
 802105e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8021060:	9300      	str	r3, [sp, #0]
 8021062:	460b      	mov	r3, r1
 8021064:	4629      	mov	r1, r5
 8021066:	4620      	mov	r0, r4
 8021068:	f7ff fb98 	bl	802079c <wc_RsaUnPad_ex>
 802106c:	6278      	str	r0, [r7, #36]	@ 0x24
#else
        ret = wc_RsaUnPad_ex(out,
            key->dataLen, &pad, pad_value, pad_type, hash, mgf, label,
            labelSz, saltLen, mp_count_bits(&key->n), key->heap);
#endif
        if (rsa_type == RSA_PUBLIC_DECRYPT && ret > (int)outLen) {
 802106e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8021070:	2b01      	cmp	r3, #1
 8021072:	d107      	bne.n	8021084 <RsaPrivateDecryptEx+0x1e4>
 8021074:	683b      	ldr	r3, [r7, #0]
 8021076:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8021078:	429a      	cmp	r2, r3
 802107a:	dd03      	ble.n	8021084 <RsaPrivateDecryptEx+0x1e4>
            ret = RSA_BUFFER_E;
 802107c:	f06f 0382 	mvn.w	r3, #130	@ 0x82
 8021080:	627b      	str	r3, [r7, #36]	@ 0x24
 8021082:	e06d      	b.n	8021160 <RsaPrivateDecryptEx+0x2c0>
        }
        else if (ret >= 0 && pad != NULL) {
 8021084:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021086:	2b00      	cmp	r3, #0
 8021088:	db6a      	blt.n	8021160 <RsaPrivateDecryptEx+0x2c0>
 802108a:	693b      	ldr	r3, [r7, #16]
 802108c:	2b00      	cmp	r3, #0
 802108e:	d067      	beq.n	8021160 <RsaPrivateDecryptEx+0x2c0>
            /* only copy output if not inline */
            if (outPtr == NULL) {
 8021090:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8021092:	2b00      	cmp	r3, #0
 8021094:	d148      	bne.n	8021128 <RsaPrivateDecryptEx+0x288>
#if !defined(WOLFSSL_RSA_VERIFY_ONLY) && !defined(WOLFSSL_RSA_VERIFY_INLINE) && \
    !defined(WOLFSSL_NO_MALLOC)
                if (rsa_type == RSA_PRIVATE_DECRYPT) {
 8021096:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8021098:	2b03      	cmp	r3, #3
 802109a:	d13e      	bne.n	802111a <RsaPrivateDecryptEx+0x27a>
                    word32 i = 0;
 802109c:	2300      	movs	r3, #0
 802109e:	623b      	str	r3, [r7, #32]
                    word32 j;
                    int start = (int)((size_t)pad - (size_t)key->data);
 80210a0:	693b      	ldr	r3, [r7, #16]
 80210a2:	461a      	mov	r2, r3
 80210a4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80210a6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80210aa:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
 80210ae:	1ad3      	subs	r3, r2, r3
 80210b0:	61bb      	str	r3, [r7, #24]

                    for (j = 0; j < key->dataLen; j++) {
 80210b2:	2300      	movs	r3, #0
 80210b4:	61fb      	str	r3, [r7, #28]
 80210b6:	e027      	b.n	8021108 <RsaPrivateDecryptEx+0x268>
                        signed char c;
                        out[i] = key->data[j];
 80210b8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80210ba:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80210be:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
 80210c2:	69fb      	ldr	r3, [r7, #28]
 80210c4:	441a      	add	r2, r3
 80210c6:	6879      	ldr	r1, [r7, #4]
 80210c8:	6a3b      	ldr	r3, [r7, #32]
 80210ca:	440b      	add	r3, r1
 80210cc:	7812      	ldrb	r2, [r2, #0]
 80210ce:	701a      	strb	r2, [r3, #0]
                        c  = (signed char)ctMaskGTE((int)j, start);
 80210d0:	69fb      	ldr	r3, [r7, #28]
 80210d2:	69b9      	ldr	r1, [r7, #24]
 80210d4:	4618      	mov	r0, r3
 80210d6:	f7fe fd9d 	bl	801fc14 <ctMaskGTE>
 80210da:	4603      	mov	r3, r0
 80210dc:	75fb      	strb	r3, [r7, #23]
                        c &= (signed char)ctMaskLT((int)i, (int)outLen);
 80210de:	6a3b      	ldr	r3, [r7, #32]
 80210e0:	683a      	ldr	r2, [r7, #0]
 80210e2:	4611      	mov	r1, r2
 80210e4:	4618      	mov	r0, r3
 80210e6:	f7fe fda7 	bl	801fc38 <ctMaskLT>
 80210ea:	4603      	mov	r3, r0
 80210ec:	b25a      	sxtb	r2, r3
 80210ee:	7dfb      	ldrb	r3, [r7, #23]
 80210f0:	4013      	ands	r3, r2
 80210f2:	75fb      	strb	r3, [r7, #23]
                        /* 0 - no add, -1 add */
                        i += (word32)((byte)(-c));
 80210f4:	7dfb      	ldrb	r3, [r7, #23]
 80210f6:	425b      	negs	r3, r3
 80210f8:	b2db      	uxtb	r3, r3
 80210fa:	461a      	mov	r2, r3
 80210fc:	6a3b      	ldr	r3, [r7, #32]
 80210fe:	4413      	add	r3, r2
 8021100:	623b      	str	r3, [r7, #32]
                    for (j = 0; j < key->dataLen; j++) {
 8021102:	69fb      	ldr	r3, [r7, #28]
 8021104:	3301      	adds	r3, #1
 8021106:	61fb      	str	r3, [r7, #28]
 8021108:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802110a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802110e:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 8021112:	69fa      	ldr	r2, [r7, #28]
 8021114:	429a      	cmp	r2, r3
 8021116:	d3cf      	bcc.n	80210b8 <RsaPrivateDecryptEx+0x218>
 8021118:	e009      	b.n	802112e <RsaPrivateDecryptEx+0x28e>
                    }
                }
                else
#endif
                {
                    XMEMCPY(out, pad, (size_t)ret);
 802111a:	693b      	ldr	r3, [r7, #16]
 802111c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802111e:	4619      	mov	r1, r3
 8021120:	6878      	ldr	r0, [r7, #4]
 8021122:	f007 fa3f 	bl	80285a4 <memcpy>
 8021126:	e002      	b.n	802112e <RsaPrivateDecryptEx+0x28e>
                }
            }
            else {
                *outPtr = pad;
 8021128:	693a      	ldr	r2, [r7, #16]
 802112a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802112c:	601a      	str	r2, [r3, #0]
            }

#if !defined(WOLFSSL_RSA_VERIFY_ONLY)
            ret = ctMaskSelInt(ctMaskLTE(ret, (int)outLen), ret,
 802112e:	683b      	ldr	r3, [r7, #0]
 8021130:	4619      	mov	r1, r3
 8021132:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021134:	f7fe fd93 	bl	801fc5e <ctMaskLTE>
 8021138:	4603      	mov	r3, r0
 802113a:	f06f 0282 	mvn.w	r2, #130	@ 0x82
 802113e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8021140:	4618      	mov	r0, r3
 8021142:	f7fe fe0a 	bl	801fd5a <ctMaskSelInt>
 8021146:	6278      	str	r0, [r7, #36]	@ 0x24
                               WC_NO_ERR_TRACE(RSA_BUFFER_E));
    #ifndef WOLFSSL_RSA_DECRYPT_TO_0_LEN
            ret = ctMaskSelInt(ctMaskNotEq(ret, 0), ret,
 8021148:	2100      	movs	r1, #0
 802114a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 802114c:	f7fe fdef 	bl	801fd2e <ctMaskNotEq>
 8021150:	4603      	mov	r3, r0
 8021152:	f06f 0282 	mvn.w	r2, #130	@ 0x82
 8021156:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8021158:	4618      	mov	r0, r3
 802115a:	f7fe fdfe 	bl	801fd5a <ctMaskSelInt>
 802115e:	6278      	str	r0, [r7, #36]	@ 0x24
            if (outLen < (word32)ret)
                ret = RSA_BUFFER_E;
#endif
        }

        key->state = RSA_STATE_DECRYPT_RES;
 8021160:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021162:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021166:	461a      	mov	r2, r3
 8021168:	2306      	movs	r3, #6
 802116a:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
                if (outPtr)
                    *outPtr = in;
            }
        }
    #endif
        break;
 802116e:	e003      	b.n	8021178 <RsaPrivateDecryptEx+0x2d8>

    default:
        ret = BAD_STATE_E;
 8021170:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 8021174:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
 8021176:	e002      	b.n	802117e <RsaPrivateDecryptEx+0x2de>
        break;
 8021178:	bf00      	nop
 802117a:	e000      	b.n	802117e <RsaPrivateDecryptEx+0x2de>
            break;
 802117c:	bf00      	nop
    }

    /* if async pending then return and skip done cleanup below */
    if (ret == WC_NO_ERR_TRACE(WC_PENDING_E)
 802117e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021180:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 8021184:	d101      	bne.n	802118a <RsaPrivateDecryptEx+0x2ea>
    #ifdef WC_RSA_NONBLOCK
        || ret == FP_WOULDBLOCK
    #endif
    ) {
        return ret;
 8021186:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021188:	e00a      	b.n	80211a0 <RsaPrivateDecryptEx+0x300>
    }

    key->state = RSA_STATE_NONE;
 802118a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802118c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021190:	461a      	mov	r2, r3
 8021192:	2300      	movs	r3, #0
 8021194:	f8c2 316c 	str.w	r3, [r2, #364]	@ 0x16c
    wc_RsaCleanup(key);
 8021198:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 802119a:	f7fe fe0f 	bl	801fdbc <wc_RsaCleanup>

    return ret;
 802119e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 80211a0:	4618      	mov	r0, r3
 80211a2:	3728      	adds	r7, #40	@ 0x28
 80211a4:	46bd      	mov	sp, r7
 80211a6:	bdb0      	pop	{r4, r5, r7, pc}

080211a8 <wc_RsaPrivateDecrypt>:
#endif /* WC_NO_RSA_OAEP */


int wc_RsaPrivateDecrypt(const byte* in, word32 inLen, byte* out,
                                                 word32 outLen, RsaKey* key)
{
 80211a8:	b580      	push	{r7, lr}
 80211aa:	b092      	sub	sp, #72	@ 0x48
 80211ac:	af0c      	add	r7, sp, #48	@ 0x30
 80211ae:	60f8      	str	r0, [r7, #12]
 80211b0:	60b9      	str	r1, [r7, #8]
 80211b2:	607a      	str	r2, [r7, #4]
 80211b4:	603b      	str	r3, [r7, #0]
    WC_RNG* rng;
    int ret;
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 80211b6:	6a3b      	ldr	r3, [r7, #32]
 80211b8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80211bc:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 80211c0:	617b      	str	r3, [r7, #20]
#else
    rng = NULL;
#endif
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
    ret = RsaPrivateDecryptEx(in, inLen, out, outLen, NULL, key,
 80211c2:	697b      	ldr	r3, [r7, #20]
 80211c4:	930a      	str	r3, [sp, #40]	@ 0x28
 80211c6:	2300      	movs	r3, #0
 80211c8:	9309      	str	r3, [sp, #36]	@ 0x24
 80211ca:	2300      	movs	r3, #0
 80211cc:	9308      	str	r3, [sp, #32]
 80211ce:	2300      	movs	r3, #0
 80211d0:	9307      	str	r3, [sp, #28]
 80211d2:	2300      	movs	r3, #0
 80211d4:	9306      	str	r3, [sp, #24]
 80211d6:	2300      	movs	r3, #0
 80211d8:	9305      	str	r3, [sp, #20]
 80211da:	2300      	movs	r3, #0
 80211dc:	9304      	str	r3, [sp, #16]
 80211de:	2302      	movs	r3, #2
 80211e0:	9303      	str	r3, [sp, #12]
 80211e2:	2303      	movs	r3, #3
 80211e4:	9302      	str	r3, [sp, #8]
 80211e6:	6a3b      	ldr	r3, [r7, #32]
 80211e8:	9301      	str	r3, [sp, #4]
 80211ea:	2300      	movs	r3, #0
 80211ec:	9300      	str	r3, [sp, #0]
 80211ee:	683b      	ldr	r3, [r7, #0]
 80211f0:	687a      	ldr	r2, [r7, #4]
 80211f2:	68b9      	ldr	r1, [r7, #8]
 80211f4:	68f8      	ldr	r0, [r7, #12]
 80211f6:	f7ff fe53 	bl	8020ea0 <RsaPrivateDecryptEx>
 80211fa:	6138      	str	r0, [r7, #16]
        RSA_PRIVATE_DECRYPT, RSA_BLOCK_TYPE_2, WC_RSA_PKCSV15_PAD,
        WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
    RESTORE_VECTOR_REGISTERS();
    return ret;
 80211fc:	693b      	ldr	r3, [r7, #16]
}
 80211fe:	4618      	mov	r0, r3
 8021200:	3718      	adds	r7, #24
 8021202:	46bd      	mov	sp, r7
 8021204:	bd80      	pop	{r7, pc}

08021206 <wc_RsaSSL_VerifyInline>:
#endif /* WC_NO_RSA_OAEP || WC_RSA_NO_PADDING */
#endif /* WOLFSSL_RSA_PUBLIC_ONLY */

#if !defined(WOLFSSL_CRYPTOCELL)
int wc_RsaSSL_VerifyInline(byte* in, word32 inLen, byte** out, RsaKey* key)
{
 8021206:	b580      	push	{r7, lr}
 8021208:	b092      	sub	sp, #72	@ 0x48
 802120a:	af0c      	add	r7, sp, #48	@ 0x30
 802120c:	60f8      	str	r0, [r7, #12]
 802120e:	60b9      	str	r1, [r7, #8]
 8021210:	607a      	str	r2, [r7, #4]
 8021212:	603b      	str	r3, [r7, #0]
    WC_RNG* rng;
    int ret;
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 8021214:	683b      	ldr	r3, [r7, #0]
 8021216:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802121a:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 802121e:	617b      	str	r3, [r7, #20]
#else
    rng = NULL;
#endif
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
    ret = RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 8021220:	697b      	ldr	r3, [r7, #20]
 8021222:	930a      	str	r3, [sp, #40]	@ 0x28
 8021224:	2300      	movs	r3, #0
 8021226:	9309      	str	r3, [sp, #36]	@ 0x24
 8021228:	2300      	movs	r3, #0
 802122a:	9308      	str	r3, [sp, #32]
 802122c:	2300      	movs	r3, #0
 802122e:	9307      	str	r3, [sp, #28]
 8021230:	2300      	movs	r3, #0
 8021232:	9306      	str	r3, [sp, #24]
 8021234:	2300      	movs	r3, #0
 8021236:	9305      	str	r3, [sp, #20]
 8021238:	2300      	movs	r3, #0
 802123a:	9304      	str	r3, [sp, #16]
 802123c:	2301      	movs	r3, #1
 802123e:	9303      	str	r3, [sp, #12]
 8021240:	2301      	movs	r3, #1
 8021242:	9302      	str	r3, [sp, #8]
 8021244:	683b      	ldr	r3, [r7, #0]
 8021246:	9301      	str	r3, [sp, #4]
 8021248:	687b      	ldr	r3, [r7, #4]
 802124a:	9300      	str	r3, [sp, #0]
 802124c:	68bb      	ldr	r3, [r7, #8]
 802124e:	68fa      	ldr	r2, [r7, #12]
 8021250:	68b9      	ldr	r1, [r7, #8]
 8021252:	68f8      	ldr	r0, [r7, #12]
 8021254:	f7ff fe24 	bl	8020ea0 <RsaPrivateDecryptEx>
 8021258:	6138      	str	r0, [r7, #16]
        RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PKCSV15_PAD,
        WC_HASH_TYPE_NONE, WC_MGF1NONE, NULL, 0, 0, rng);
    RESTORE_VECTOR_REGISTERS();
    return ret;
 802125a:	693b      	ldr	r3, [r7, #16]
}
 802125c:	4618      	mov	r0, r3
 802125e:	3718      	adds	r7, #24
 8021260:	46bd      	mov	sp, r7
 8021262:	bd80      	pop	{r7, pc}

08021264 <wc_RsaPSS_VerifyInline_ex>:
 * returns the length of the PSS data on success and negative indicates failure.
 */
int wc_RsaPSS_VerifyInline_ex(byte* in, word32 inLen, byte** out,
                              enum wc_HashType hash, int mgf, int saltLen,
                              RsaKey* key)
{
 8021264:	b580      	push	{r7, lr}
 8021266:	b092      	sub	sp, #72	@ 0x48
 8021268:	af0c      	add	r7, sp, #48	@ 0x30
 802126a:	60f8      	str	r0, [r7, #12]
 802126c:	60b9      	str	r1, [r7, #8]
 802126e:	607a      	str	r2, [r7, #4]
 8021270:	70fb      	strb	r3, [r7, #3]
    WC_RNG* rng;
    int ret;
#ifdef WC_RSA_BLINDING
    rng = key->rng;
 8021272:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021274:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8021278:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 802127c:	617b      	str	r3, [r7, #20]
#else
    rng = NULL;
#endif
    SAVE_VECTOR_REGISTERS(return _svr_ret;);
    ret = RsaPrivateDecryptEx(in, inLen, in, inLen, out, key,
 802127e:	697b      	ldr	r3, [r7, #20]
 8021280:	930a      	str	r3, [sp, #40]	@ 0x28
 8021282:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021284:	9309      	str	r3, [sp, #36]	@ 0x24
 8021286:	2300      	movs	r3, #0
 8021288:	9308      	str	r3, [sp, #32]
 802128a:	2300      	movs	r3, #0
 802128c:	9307      	str	r3, [sp, #28]
 802128e:	6a3b      	ldr	r3, [r7, #32]
 8021290:	9306      	str	r3, [sp, #24]
 8021292:	78fb      	ldrb	r3, [r7, #3]
 8021294:	9305      	str	r3, [sp, #20]
 8021296:	2302      	movs	r3, #2
 8021298:	9304      	str	r3, [sp, #16]
 802129a:	2301      	movs	r3, #1
 802129c:	9303      	str	r3, [sp, #12]
 802129e:	2301      	movs	r3, #1
 80212a0:	9302      	str	r3, [sp, #8]
 80212a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80212a4:	9301      	str	r3, [sp, #4]
 80212a6:	687b      	ldr	r3, [r7, #4]
 80212a8:	9300      	str	r3, [sp, #0]
 80212aa:	68bb      	ldr	r3, [r7, #8]
 80212ac:	68fa      	ldr	r2, [r7, #12]
 80212ae:	68b9      	ldr	r1, [r7, #8]
 80212b0:	68f8      	ldr	r0, [r7, #12]
 80212b2:	f7ff fdf5 	bl	8020ea0 <RsaPrivateDecryptEx>
 80212b6:	6138      	str	r0, [r7, #16]
        RSA_PUBLIC_DECRYPT, RSA_BLOCK_TYPE_1, WC_RSA_PSS_PAD,
        hash, mgf, NULL, 0, saltLen, rng);
    RESTORE_VECTOR_REGISTERS();
    return ret;
 80212b8:	693b      	ldr	r3, [r7, #16]
}
 80212ba:	4618      	mov	r0, r3
 80212bc:	3718      	adds	r7, #24
 80212be:	46bd      	mov	sp, r7
 80212c0:	bd80      	pop	{r7, pc}

080212c2 <wc_RsaPSS_CheckPadding_ex2>:
 * algorithm length and 0 on success.
 */
int wc_RsaPSS_CheckPadding_ex2(const byte* in, word32 inSz, byte* sig,
                               word32 sigSz, enum wc_HashType hashType,
                               int saltLen, int bits, void* heap)
{
 80212c2:	b580      	push	{r7, lr}
 80212c4:	b09c      	sub	sp, #112	@ 0x70
 80212c6:	af02      	add	r7, sp, #8
 80212c8:	60f8      	str	r0, [r7, #12]
 80212ca:	60b9      	str	r1, [r7, #8]
 80212cc:	607a      	str	r2, [r7, #4]
 80212ce:	603b      	str	r3, [r7, #0]
    int ret = 0;
 80212d0:	2300      	movs	r3, #0
 80212d2:	667b      	str	r3, [r7, #100]	@ 0x64
    byte sigCheckBuf[WC_MAX_DIGEST_SIZE*2 + RSA_PSS_PAD_SZ];
    byte *sigCheck = sigCheckBuf;
 80212d4:	f107 0314 	add.w	r3, r7, #20
 80212d8:	663b      	str	r3, [r7, #96]	@ 0x60

    (void)bits;

    if (in == NULL || sig == NULL ||
 80212da:	68fb      	ldr	r3, [r7, #12]
 80212dc:	2b00      	cmp	r3, #0
 80212de:	d00c      	beq.n	80212fa <wc_RsaPSS_CheckPadding_ex2+0x38>
 80212e0:	687b      	ldr	r3, [r7, #4]
 80212e2:	2b00      	cmp	r3, #0
 80212e4:	d009      	beq.n	80212fa <wc_RsaPSS_CheckPadding_ex2+0x38>
                               inSz != (word32)wc_HashGetDigestSize(hashType)) {
 80212e6:	f897 3070 	ldrb.w	r3, [r7, #112]	@ 0x70
 80212ea:	4618      	mov	r0, r3
 80212ec:	f7fd f840 	bl	801e370 <wc_HashGetDigestSize>
 80212f0:	4603      	mov	r3, r0
 80212f2:	461a      	mov	r2, r3
    if (in == NULL || sig == NULL ||
 80212f4:	68bb      	ldr	r3, [r7, #8]
 80212f6:	4293      	cmp	r3, r2
 80212f8:	d002      	beq.n	8021300 <wc_RsaPSS_CheckPadding_ex2+0x3e>
        ret = BAD_FUNC_ARG;
 80212fa:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80212fe:	667b      	str	r3, [r7, #100]	@ 0x64
    }

    if (ret == 0) {
 8021300:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8021302:	2b00      	cmp	r3, #0
 8021304:	d115      	bne.n	8021332 <wc_RsaPSS_CheckPadding_ex2+0x70>
        if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
 8021306:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8021308:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 802130c:	d102      	bne.n	8021314 <wc_RsaPSS_CheckPadding_ex2+0x52>
            saltLen = (int)inSz;
 802130e:	68bb      	ldr	r3, [r7, #8]
 8021310:	677b      	str	r3, [r7, #116]	@ 0x74
 8021312:	e00e      	b.n	8021332 <wc_RsaPSS_CheckPadding_ex2+0x70>
                    saltLen = RSA_PSS_SALT_MAX_SZ;
                }
            #endif
        }
#ifndef WOLFSSL_PSS_LONG_SALT
        else if (saltLen > (int)inSz) {
 8021314:	68bb      	ldr	r3, [r7, #8]
 8021316:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8021318:	429a      	cmp	r2, r3
 802131a:	dd03      	ble.n	8021324 <wc_RsaPSS_CheckPadding_ex2+0x62>
            ret = PSS_SALTLEN_E;
 802131c:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8021320:	667b      	str	r3, [r7, #100]	@ 0x64
 8021322:	e006      	b.n	8021332 <wc_RsaPSS_CheckPadding_ex2+0x70>
        }
#endif
#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
        else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {
 8021324:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8021326:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 802132a:	da02      	bge.n	8021332 <wc_RsaPSS_CheckPadding_ex2+0x70>
            ret = PSS_SALTLEN_E;
 802132c:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 8021330:	667b      	str	r3, [r7, #100]	@ 0x64
        }
#endif
    }

    /* Sig = Salt | Exp Hash */
    if (ret == 0) {
 8021332:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8021334:	2b00      	cmp	r3, #0
 8021336:	d113      	bne.n	8021360 <wc_RsaPSS_CheckPadding_ex2+0x9e>
        word32 totalSz;
        if ((WC_SAFE_SUM_WORD32(inSz, (word32)saltLen, totalSz) == 0) ||
 8021338:	68bb      	ldr	r3, [r7, #8]
 802133a:	43da      	mvns	r2, r3
 802133c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802133e:	429a      	cmp	r2, r3
 8021340:	d308      	bcc.n	8021354 <wc_RsaPSS_CheckPadding_ex2+0x92>
 8021342:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8021344:	68ba      	ldr	r2, [r7, #8]
 8021346:	4413      	add	r3, r2
 8021348:	65fb      	str	r3, [r7, #92]	@ 0x5c
 802134a:	683a      	ldr	r2, [r7, #0]
 802134c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802134e:	429a      	cmp	r2, r3
 8021350:	d006      	beq.n	8021360 <wc_RsaPSS_CheckPadding_ex2+0x9e>
 8021352:	e002      	b.n	802135a <wc_RsaPSS_CheckPadding_ex2+0x98>
 8021354:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8021358:	65fb      	str	r3, [r7, #92]	@ 0x5c
            (sigSz != totalSz))
        {
            ret = PSS_SALTLEN_E;
 802135a:	f06f 03f9 	mvn.w	r3, #249	@ 0xf9
 802135e:	667b      	str	r3, [r7, #100]	@ 0x64
        if (sigCheck == NULL) {
            ret = MEMORY_E;
        }
    }
#else
    if (ret == 0 && sizeof(sigCheckBuf) < (RSA_PSS_PAD_SZ + inSz + (word32)saltLen)) {
 8021360:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8021362:	2b00      	cmp	r3, #0
 8021364:	d108      	bne.n	8021378 <wc_RsaPSS_CheckPadding_ex2+0xb6>
 8021366:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8021368:	68bb      	ldr	r3, [r7, #8]
 802136a:	4413      	add	r3, r2
 802136c:	3308      	adds	r3, #8
 802136e:	2b48      	cmp	r3, #72	@ 0x48
 8021370:	d902      	bls.n	8021378 <wc_RsaPSS_CheckPadding_ex2+0xb6>
        ret = BUFFER_E;
 8021372:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8021376:	667b      	str	r3, [r7, #100]	@ 0x64
    }
#endif

    /* Exp Hash = HASH(8 * 0x00 | Message Hash | Salt) */
    if (ret == 0) {
 8021378:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802137a:	2b00      	cmp	r3, #0
 802137c:	d122      	bne.n	80213c4 <wc_RsaPSS_CheckPadding_ex2+0x102>
        XMEMSET(sigCheck, 0, RSA_PSS_PAD_SZ);
 802137e:	2208      	movs	r2, #8
 8021380:	2100      	movs	r1, #0
 8021382:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8021384:	f007 f8a4 	bl	80284d0 <memset>
        XMEMCPY(sigCheck + RSA_PSS_PAD_SZ, in, inSz);
 8021388:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802138a:	3308      	adds	r3, #8
 802138c:	68ba      	ldr	r2, [r7, #8]
 802138e:	68f9      	ldr	r1, [r7, #12]
 8021390:	4618      	mov	r0, r3
 8021392:	f007 f907 	bl	80285a4 <memcpy>
        XMEMCPY(sigCheck + RSA_PSS_PAD_SZ + inSz, sig, (size_t)saltLen);
 8021396:	68bb      	ldr	r3, [r7, #8]
 8021398:	3308      	adds	r3, #8
 802139a:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 802139c:	4413      	add	r3, r2
 802139e:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80213a0:	6879      	ldr	r1, [r7, #4]
 80213a2:	4618      	mov	r0, r3
 80213a4:	f007 f8fe 	bl	80285a4 <memcpy>
        ret = wc_Hash(hashType, sigCheck, RSA_PSS_PAD_SZ + inSz + (word32)saltLen,
 80213a8:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80213aa:	68bb      	ldr	r3, [r7, #8]
 80213ac:	4413      	add	r3, r2
 80213ae:	f103 0208 	add.w	r2, r3, #8
 80213b2:	f897 0070 	ldrb.w	r0, [r7, #112]	@ 0x70
 80213b6:	68bb      	ldr	r3, [r7, #8]
 80213b8:	9300      	str	r3, [sp, #0]
 80213ba:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80213bc:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80213be:	f7fd f86f 	bl	801e4a0 <wc_Hash>
 80213c2:	6678      	str	r0, [r7, #100]	@ 0x64
                      sigCheck, inSz);
    }
    if (ret == 0) {
 80213c4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80213c6:	2b00      	cmp	r3, #0
 80213c8:	d10d      	bne.n	80213e6 <wc_RsaPSS_CheckPadding_ex2+0x124>
        if (XMEMCMP(sigCheck, sig + saltLen, inSz) != 0) {
 80213ca:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80213cc:	687a      	ldr	r2, [r7, #4]
 80213ce:	4413      	add	r3, r2
 80213d0:	68ba      	ldr	r2, [r7, #8]
 80213d2:	4619      	mov	r1, r3
 80213d4:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80213d6:	f007 f851 	bl	802847c <memcmp>
 80213da:	4603      	mov	r3, r0
 80213dc:	2b00      	cmp	r3, #0
 80213de:	d002      	beq.n	80213e6 <wc_RsaPSS_CheckPadding_ex2+0x124>
            WOLFSSL_MSG("RsaPSS_CheckPadding: Padding Error");
            ret = BAD_PADDING_E;
 80213e0:	f06f 03c0 	mvn.w	r3, #192	@ 0xc0
 80213e4:	667b      	str	r3, [r7, #100]	@ 0x64
        XFREE(sigCheck, heap, DYNAMIC_TYPE_RSA_BUFFER);
    }
#endif

    (void)heap; /* unused if memory is disabled */
    return ret;
 80213e6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
}
 80213e8:	4618      	mov	r0, r3
 80213ea:	3768      	adds	r7, #104	@ 0x68
 80213ec:	46bd      	mov	sp, r7
 80213ee:	bd80      	pop	{r7, pc}

080213f0 <wc_RsaEncryptSize>:
}
#endif
#endif

int wc_RsaEncryptSize(const RsaKey* key)
{
 80213f0:	b580      	push	{r7, lr}
 80213f2:	b084      	sub	sp, #16
 80213f4:	af00      	add	r7, sp, #0
 80213f6:	6078      	str	r0, [r7, #4]
    int ret;

    if (key == NULL) {
 80213f8:	687b      	ldr	r3, [r7, #4]
 80213fa:	2b00      	cmp	r3, #0
 80213fc:	d102      	bne.n	8021404 <wc_RsaEncryptSize+0x14>
        return BAD_FUNC_ARG;
 80213fe:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8021402:	e005      	b.n	8021410 <wc_RsaEncryptSize+0x20>
    }

    ret = mp_unsigned_bin_size(&key->n);
 8021404:	687b      	ldr	r3, [r7, #4]
 8021406:	4618      	mov	r0, r3
 8021408:	f005 faf8 	bl	80269fc <mp_unsigned_bin_size>
 802140c:	60f8      	str	r0, [r7, #12]
            ret = 2048/8; /* hardware handles, use 2048-bit as default */
        }
    }
#endif

    return ret;
 802140e:	68fb      	ldr	r3, [r7, #12]
}
 8021410:	4618      	mov	r0, r3
 8021412:	3710      	adds	r7, #16
 8021414:	46bd      	mov	sp, r7
 8021416:	bd80      	pop	{r7, pc}

08021418 <wc_RsaSetRNG>:
#endif /* WOLFSSL_KEY_GEN */


#ifdef WC_RSA_BLINDING
int wc_RsaSetRNG(RsaKey* key, WC_RNG* rng)
{
 8021418:	b480      	push	{r7}
 802141a:	b083      	sub	sp, #12
 802141c:	af00      	add	r7, sp, #0
 802141e:	6078      	str	r0, [r7, #4]
 8021420:	6039      	str	r1, [r7, #0]
    if (key == NULL || rng == NULL)
 8021422:	687b      	ldr	r3, [r7, #4]
 8021424:	2b00      	cmp	r3, #0
 8021426:	d002      	beq.n	802142e <wc_RsaSetRNG+0x16>
 8021428:	683b      	ldr	r3, [r7, #0]
 802142a:	2b00      	cmp	r3, #0
 802142c:	d102      	bne.n	8021434 <wc_RsaSetRNG+0x1c>
        return BAD_FUNC_ARG;
 802142e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8021432:	e007      	b.n	8021444 <wc_RsaSetRNG+0x2c>

    key->rng = rng;
 8021434:	687b      	ldr	r3, [r7, #4]
 8021436:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 802143a:	461a      	mov	r2, r3
 802143c:	683b      	ldr	r3, [r7, #0]
 802143e:	f8c2 3174 	str.w	r3, [r2, #372]	@ 0x174

    return 0;
 8021442:	2300      	movs	r3, #0
}
 8021444:	4618      	mov	r0, r3
 8021446:	370c      	adds	r7, #12
 8021448:	46bd      	mov	sp, r7
 802144a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802144e:	4770      	bx	lr

08021450 <rotlFixed>:
    {
 8021450:	b480      	push	{r7}
 8021452:	b083      	sub	sp, #12
 8021454:	af00      	add	r7, sp, #0
 8021456:	6078      	str	r0, [r7, #4]
 8021458:	6039      	str	r1, [r7, #0]
        return (x << y) | (x >> (sizeof(x) * 8 - y));
 802145a:	687a      	ldr	r2, [r7, #4]
 802145c:	683b      	ldr	r3, [r7, #0]
 802145e:	f1c3 0320 	rsb	r3, r3, #32
 8021462:	fa62 f303 	ror.w	r3, r2, r3
    }
 8021466:	4618      	mov	r0, r3
 8021468:	370c      	adds	r7, #12
 802146a:	46bd      	mov	sp, r7
 802146c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021470:	4770      	bx	lr

08021472 <rotrFixed>:
    {
 8021472:	b480      	push	{r7}
 8021474:	b083      	sub	sp, #12
 8021476:	af00      	add	r7, sp, #0
 8021478:	6078      	str	r0, [r7, #4]
 802147a:	6039      	str	r1, [r7, #0]
        return (x >> y) | (x << (sizeof(x) * 8 - y));
 802147c:	687a      	ldr	r2, [r7, #4]
 802147e:	683b      	ldr	r3, [r7, #0]
 8021480:	fa62 f303 	ror.w	r3, r2, r3
    }
 8021484:	4618      	mov	r0, r3
 8021486:	370c      	adds	r7, #12
 8021488:	46bd      	mov	sp, r7
 802148a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802148e:	4770      	bx	lr

08021490 <ByteReverseWord32>:
{
 8021490:	b580      	push	{r7, lr}
 8021492:	b082      	sub	sp, #8
 8021494:	af00      	add	r7, sp, #0
 8021496:	6078      	str	r0, [r7, #4]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
 8021498:	687b      	ldr	r3, [r7, #4]
 802149a:	0a1b      	lsrs	r3, r3, #8
 802149c:	f003 12ff 	and.w	r2, r3, #16711935	@ 0xff00ff
 80214a0:	687b      	ldr	r3, [r7, #4]
 80214a2:	021b      	lsls	r3, r3, #8
 80214a4:	f003 23ff 	and.w	r3, r3, #4278255360	@ 0xff00ff00
 80214a8:	4313      	orrs	r3, r2
 80214aa:	607b      	str	r3, [r7, #4]
    return rotlFixed(value, 16U);
 80214ac:	2110      	movs	r1, #16
 80214ae:	6878      	ldr	r0, [r7, #4]
 80214b0:	f7ff ffce 	bl	8021450 <rotlFixed>
 80214b4:	4603      	mov	r3, r0
}
 80214b6:	4618      	mov	r0, r3
 80214b8:	3708      	adds	r7, #8
 80214ba:	46bd      	mov	sp, r7
 80214bc:	bd80      	pop	{r7, pc}

080214be <ByteReverseWords>:
{
 80214be:	b590      	push	{r4, r7, lr}
 80214c0:	b087      	sub	sp, #28
 80214c2:	af00      	add	r7, sp, #0
 80214c4:	60f8      	str	r0, [r7, #12]
 80214c6:	60b9      	str	r1, [r7, #8]
 80214c8:	607a      	str	r2, [r7, #4]
        word32 count = byteCount/(word32)sizeof(word32);
 80214ca:	687b      	ldr	r3, [r7, #4]
 80214cc:	089b      	lsrs	r3, r3, #2
 80214ce:	613b      	str	r3, [r7, #16]
        for (i = 0; i < count; i++)
 80214d0:	2300      	movs	r3, #0
 80214d2:	617b      	str	r3, [r7, #20]
 80214d4:	e010      	b.n	80214f8 <ByteReverseWords+0x3a>
            out[i] = ByteReverseWord32(in[i]);
 80214d6:	697b      	ldr	r3, [r7, #20]
 80214d8:	009b      	lsls	r3, r3, #2
 80214da:	68ba      	ldr	r2, [r7, #8]
 80214dc:	4413      	add	r3, r2
 80214de:	6819      	ldr	r1, [r3, #0]
 80214e0:	697b      	ldr	r3, [r7, #20]
 80214e2:	009b      	lsls	r3, r3, #2
 80214e4:	68fa      	ldr	r2, [r7, #12]
 80214e6:	18d4      	adds	r4, r2, r3
 80214e8:	4608      	mov	r0, r1
 80214ea:	f7ff ffd1 	bl	8021490 <ByteReverseWord32>
 80214ee:	4603      	mov	r3, r0
 80214f0:	6023      	str	r3, [r4, #0]
        for (i = 0; i < count; i++)
 80214f2:	697b      	ldr	r3, [r7, #20]
 80214f4:	3301      	adds	r3, #1
 80214f6:	617b      	str	r3, [r7, #20]
 80214f8:	697a      	ldr	r2, [r7, #20]
 80214fa:	693b      	ldr	r3, [r7, #16]
 80214fc:	429a      	cmp	r2, r3
 80214fe:	d3ea      	bcc.n	80214d6 <ByteReverseWords+0x18>
}
 8021500:	bf00      	nop
 8021502:	bf00      	nop
 8021504:	371c      	adds	r7, #28
 8021506:	46bd      	mov	sp, r7
 8021508:	bd90      	pop	{r4, r7, pc}

0802150a <ForceZero>:
{
 802150a:	b480      	push	{r7}
 802150c:	b085      	sub	sp, #20
 802150e:	af00      	add	r7, sp, #0
 8021510:	6078      	str	r0, [r7, #4]
 8021512:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 8021514:	687b      	ldr	r3, [r7, #4]
 8021516:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 8021518:	e004      	b.n	8021524 <ForceZero+0x1a>
 802151a:	68fb      	ldr	r3, [r7, #12]
 802151c:	1c5a      	adds	r2, r3, #1
 802151e:	60fa      	str	r2, [r7, #12]
 8021520:	2200      	movs	r2, #0
 8021522:	701a      	strb	r2, [r3, #0]
 8021524:	683b      	ldr	r3, [r7, #0]
 8021526:	1e5a      	subs	r2, r3, #1
 8021528:	603a      	str	r2, [r7, #0]
 802152a:	2b00      	cmp	r3, #0
 802152c:	d1f5      	bne.n	802151a <ForceZero+0x10>
}
 802152e:	bf00      	nop
 8021530:	bf00      	nop
 8021532:	3714      	adds	r7, #20
 8021534:	46bd      	mov	sp, r7
 8021536:	f85d 7b04 	ldr.w	r7, [sp], #4
 802153a:	4770      	bx	lr

0802153c <min>:
    {
 802153c:	b480      	push	{r7}
 802153e:	b083      	sub	sp, #12
 8021540:	af00      	add	r7, sp, #0
 8021542:	6078      	str	r0, [r7, #4]
 8021544:	6039      	str	r1, [r7, #0]
        return a > b ? b : a;
 8021546:	687a      	ldr	r2, [r7, #4]
 8021548:	683b      	ldr	r3, [r7, #0]
 802154a:	4293      	cmp	r3, r2
 802154c:	bf28      	it	cs
 802154e:	4613      	movcs	r3, r2
    }
 8021550:	4618      	mov	r0, r3
 8021552:	370c      	adds	r7, #12
 8021554:	46bd      	mov	sp, r7
 8021556:	f85d 7b04 	ldr.w	r7, [sp], #4
 802155a:	4770      	bx	lr

0802155c <InitSha256>:
#endif
static void Sha256_SetTransform(SHA256_SETTRANSFORM_ARGS);
#endif

static int InitSha256(wc_Sha256* sha256)
{
 802155c:	b580      	push	{r7, lr}
 802155e:	b082      	sub	sp, #8
 8021560:	af00      	add	r7, sp, #0
 8021562:	6078      	str	r0, [r7, #4]
    XMEMSET(sha256->digest, 0, sizeof(sha256->digest));
 8021564:	687b      	ldr	r3, [r7, #4]
 8021566:	2220      	movs	r2, #32
 8021568:	2100      	movs	r1, #0
 802156a:	4618      	mov	r0, r3
 802156c:	f006 ffb0 	bl	80284d0 <memset>
    sha256->digest[0] = 0x6A09E667L;
 8021570:	687b      	ldr	r3, [r7, #4]
 8021572:	4a12      	ldr	r2, [pc, #72]	@ (80215bc <InitSha256+0x60>)
 8021574:	601a      	str	r2, [r3, #0]
    sha256->digest[1] = 0xBB67AE85L;
 8021576:	687b      	ldr	r3, [r7, #4]
 8021578:	4a11      	ldr	r2, [pc, #68]	@ (80215c0 <InitSha256+0x64>)
 802157a:	605a      	str	r2, [r3, #4]
    sha256->digest[2] = 0x3C6EF372L;
 802157c:	687b      	ldr	r3, [r7, #4]
 802157e:	4a11      	ldr	r2, [pc, #68]	@ (80215c4 <InitSha256+0x68>)
 8021580:	609a      	str	r2, [r3, #8]
    sha256->digest[3] = 0xA54FF53AL;
 8021582:	687b      	ldr	r3, [r7, #4]
 8021584:	4a10      	ldr	r2, [pc, #64]	@ (80215c8 <InitSha256+0x6c>)
 8021586:	60da      	str	r2, [r3, #12]
    sha256->digest[4] = 0x510E527FL;
 8021588:	687b      	ldr	r3, [r7, #4]
 802158a:	4a10      	ldr	r2, [pc, #64]	@ (80215cc <InitSha256+0x70>)
 802158c:	611a      	str	r2, [r3, #16]
    sha256->digest[5] = 0x9B05688CL;
 802158e:	687b      	ldr	r3, [r7, #4]
 8021590:	4a0f      	ldr	r2, [pc, #60]	@ (80215d0 <InitSha256+0x74>)
 8021592:	615a      	str	r2, [r3, #20]
    sha256->digest[6] = 0x1F83D9ABL;
 8021594:	687b      	ldr	r3, [r7, #4]
 8021596:	4a0f      	ldr	r2, [pc, #60]	@ (80215d4 <InitSha256+0x78>)
 8021598:	619a      	str	r2, [r3, #24]
    sha256->digest[7] = 0x5BE0CD19L;
 802159a:	687b      	ldr	r3, [r7, #4]
 802159c:	4a0e      	ldr	r2, [pc, #56]	@ (80215d8 <InitSha256+0x7c>)
 802159e:	61da      	str	r2, [r3, #28]

    sha256->buffLen = 0;
 80215a0:	687b      	ldr	r3, [r7, #4]
 80215a2:	2200      	movs	r2, #0
 80215a4:	661a      	str	r2, [r3, #96]	@ 0x60
    sha256->loLen   = 0;
 80215a6:	687b      	ldr	r3, [r7, #4]
 80215a8:	2200      	movs	r2, #0
 80215aa:	665a      	str	r2, [r3, #100]	@ 0x64
    sha256->hiLen   = 0;
 80215ac:	687b      	ldr	r3, [r7, #4]
 80215ae:	2200      	movs	r2, #0
 80215b0:	669a      	str	r2, [r3, #104]	@ 0x68

#ifdef HAVE_ARIA
    sha256->hSession = NULL;
#endif

    return 0;
 80215b2:	2300      	movs	r3, #0
}
 80215b4:	4618      	mov	r0, r3
 80215b6:	3708      	adds	r7, #8
 80215b8:	46bd      	mov	sp, r7
 80215ba:	bd80      	pop	{r7, pc}
 80215bc:	6a09e667 	.word	0x6a09e667
 80215c0:	bb67ae85 	.word	0xbb67ae85
 80215c4:	3c6ef372 	.word	0x3c6ef372
 80215c8:	a54ff53a 	.word	0xa54ff53a
 80215cc:	510e527f 	.word	0x510e527f
 80215d0:	9b05688c 	.word	0x9b05688c
 80215d4:	1f83d9ab 	.word	0x1f83d9ab
 80215d8:	5be0cd19 	.word	0x5be0cd19

080215dc <wc_InitSha256_ex>:

#else
    #define NEED_SOFT_SHA256

    int wc_InitSha256_ex(wc_Sha256* sha256, void* heap, int devId)
    {
 80215dc:	b580      	push	{r7, lr}
 80215de:	b086      	sub	sp, #24
 80215e0:	af00      	add	r7, sp, #0
 80215e2:	60f8      	str	r0, [r7, #12]
 80215e4:	60b9      	str	r1, [r7, #8]
 80215e6:	607a      	str	r2, [r7, #4]
        int ret = 0;
 80215e8:	2300      	movs	r3, #0
 80215ea:	617b      	str	r3, [r7, #20]
        if (sha256 == NULL)
 80215ec:	68fb      	ldr	r3, [r7, #12]
 80215ee:	2b00      	cmp	r3, #0
 80215f0:	d102      	bne.n	80215f8 <wc_InitSha256_ex+0x1c>
            return BAD_FUNC_ARG;
 80215f2:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80215f6:	e00c      	b.n	8021612 <wc_InitSha256_ex+0x36>
        ret = InitSha256(sha256);
 80215f8:	68f8      	ldr	r0, [r7, #12]
 80215fa:	f7ff ffaf 	bl	802155c <InitSha256>
 80215fe:	6178      	str	r0, [r7, #20]
        if (ret != 0)
 8021600:	697b      	ldr	r3, [r7, #20]
 8021602:	2b00      	cmp	r3, #0
 8021604:	d001      	beq.n	802160a <wc_InitSha256_ex+0x2e>
            return ret;
 8021606:	697b      	ldr	r3, [r7, #20]
 8021608:	e003      	b.n	8021612 <wc_InitSha256_ex+0x36>

        sha256->heap = heap;
 802160a:	68fb      	ldr	r3, [r7, #12]
 802160c:	68ba      	ldr	r2, [r7, #8]
 802160e:	66da      	str	r2, [r3, #108]	@ 0x6c
    #endif /* WOLFSSL_ASYNC_CRYPT */
    #ifdef WOLFSSL_IMXRT1170_CAAM
         ret = wc_CAAM_HashInit(&sha256->hndl, &sha256->ctx, WC_HASH_TYPE_SHA256);
    #endif

        return ret;
 8021610:	697b      	ldr	r3, [r7, #20]
    }
 8021612:	4618      	mov	r0, r3
 8021614:	3718      	adds	r7, #24
 8021616:	46bd      	mov	sp, r7
 8021618:	bd80      	pop	{r7, pc}
	...

0802161c <Transform_Sha256>:
         t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
         d(j) += t0; \
         h(j)  = t0 + t1

    static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
    {
 802161c:	b5b0      	push	{r4, r5, r7, lr}
 802161e:	b090      	sub	sp, #64	@ 0x40
 8021620:	af00      	add	r7, sp, #0
 8021622:	6078      	str	r0, [r7, #4]
 8021624:	6039      	str	r1, [r7, #0]
                return MEMORY_E;
            sha256->W = W;
        }
    #elif defined(WOLFSSL_SMALL_STACK)
        word32* W;
        W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
 8021626:	f44f 7080 	mov.w	r0, #256	@ 0x100
 802162a:	f7fd fa33 	bl	801ea94 <wolfSSL_Malloc>
 802162e:	63b8      	str	r0, [r7, #56]	@ 0x38
                                                       DYNAMIC_TYPE_TMP_BUFFER);
        if (W == NULL)
 8021630:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8021632:	2b00      	cmp	r3, #0
 8021634:	d102      	bne.n	802163c <Transform_Sha256+0x20>
            return MEMORY_E;
 8021636:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 802163a:	e364      	b.n	8021d06 <Transform_Sha256+0x6ea>
    #else
        word32 W[WC_SHA256_BLOCK_SIZE];
    #endif

        /* Copy context->state[] to working vars */
        for (i = 0; i < 8; i++)
 802163c:	2300      	movs	r3, #0
 802163e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021640:	e00c      	b.n	802165c <Transform_Sha256+0x40>
            S[i] = sha256->digest[i];
 8021642:	687b      	ldr	r3, [r7, #4]
 8021644:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8021646:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 802164a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802164c:	009b      	lsls	r3, r3, #2
 802164e:	3340      	adds	r3, #64	@ 0x40
 8021650:	443b      	add	r3, r7
 8021652:	f843 2c34 	str.w	r2, [r3, #-52]
        for (i = 0; i < 8; i++)
 8021656:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021658:	3301      	adds	r3, #1
 802165a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802165c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802165e:	2b07      	cmp	r3, #7
 8021660:	ddef      	ble.n	8021642 <Transform_Sha256+0x26>

        for (i = 0; i < 16; i++)
 8021662:	2300      	movs	r3, #0
 8021664:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021666:	e00d      	b.n	8021684 <Transform_Sha256+0x68>
            W[i] = *((const word32*)&data[i*(int)sizeof(word32)]);
 8021668:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802166a:	009b      	lsls	r3, r3, #2
 802166c:	461a      	mov	r2, r3
 802166e:	683b      	ldr	r3, [r7, #0]
 8021670:	441a      	add	r2, r3
 8021672:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021674:	009b      	lsls	r3, r3, #2
 8021676:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021678:	440b      	add	r3, r1
 802167a:	6812      	ldr	r2, [r2, #0]
 802167c:	601a      	str	r2, [r3, #0]
        for (i = 0; i < 16; i++)
 802167e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021680:	3301      	adds	r3, #1
 8021682:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021684:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021686:	2b0f      	cmp	r3, #15
 8021688:	ddee      	ble.n	8021668 <Transform_Sha256+0x4c>

        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 802168a:	2310      	movs	r3, #16
 802168c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802168e:	e066      	b.n	802175e <Transform_Sha256+0x142>
            W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
 8021690:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021692:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8021696:	3b02      	subs	r3, #2
 8021698:	009b      	lsls	r3, r3, #2
 802169a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 802169c:	4413      	add	r3, r2
 802169e:	681b      	ldr	r3, [r3, #0]
 80216a0:	2111      	movs	r1, #17
 80216a2:	4618      	mov	r0, r3
 80216a4:	f7ff fee5 	bl	8021472 <rotrFixed>
 80216a8:	4604      	mov	r4, r0
 80216aa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80216ac:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80216b0:	3b02      	subs	r3, #2
 80216b2:	009b      	lsls	r3, r3, #2
 80216b4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80216b6:	4413      	add	r3, r2
 80216b8:	681b      	ldr	r3, [r3, #0]
 80216ba:	2113      	movs	r1, #19
 80216bc:	4618      	mov	r0, r3
 80216be:	f7ff fed8 	bl	8021472 <rotrFixed>
 80216c2:	4603      	mov	r3, r0
 80216c4:	ea84 0203 	eor.w	r2, r4, r3
 80216c8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80216ca:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80216ce:	3b02      	subs	r3, #2
 80216d0:	009b      	lsls	r3, r3, #2
 80216d2:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80216d4:	440b      	add	r3, r1
 80216d6:	681b      	ldr	r3, [r3, #0]
 80216d8:	0a9b      	lsrs	r3, r3, #10
 80216da:	405a      	eors	r2, r3
 80216dc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80216de:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80216e2:	3b07      	subs	r3, #7
 80216e4:	009b      	lsls	r3, r3, #2
 80216e6:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80216e8:	440b      	add	r3, r1
 80216ea:	681b      	ldr	r3, [r3, #0]
 80216ec:	18d4      	adds	r4, r2, r3
 80216ee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80216f0:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80216f4:	3b0f      	subs	r3, #15
 80216f6:	009b      	lsls	r3, r3, #2
 80216f8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80216fa:	4413      	add	r3, r2
 80216fc:	681b      	ldr	r3, [r3, #0]
 80216fe:	2107      	movs	r1, #7
 8021700:	4618      	mov	r0, r3
 8021702:	f7ff feb6 	bl	8021472 <rotrFixed>
 8021706:	4605      	mov	r5, r0
 8021708:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802170a:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 802170e:	3b0f      	subs	r3, #15
 8021710:	009b      	lsls	r3, r3, #2
 8021712:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8021714:	4413      	add	r3, r2
 8021716:	681b      	ldr	r3, [r3, #0]
 8021718:	2112      	movs	r1, #18
 802171a:	4618      	mov	r0, r3
 802171c:	f7ff fea9 	bl	8021472 <rotrFixed>
 8021720:	4603      	mov	r3, r0
 8021722:	ea85 0203 	eor.w	r2, r5, r3
 8021726:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021728:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 802172c:	3b0f      	subs	r3, #15
 802172e:	009b      	lsls	r3, r3, #2
 8021730:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021732:	440b      	add	r3, r1
 8021734:	681b      	ldr	r3, [r3, #0]
 8021736:	08db      	lsrs	r3, r3, #3
 8021738:	4053      	eors	r3, r2
 802173a:	18e1      	adds	r1, r4, r3
 802173c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802173e:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8021742:	3b10      	subs	r3, #16
 8021744:	009b      	lsls	r3, r3, #2
 8021746:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8021748:	4413      	add	r3, r2
 802174a:	681a      	ldr	r2, [r3, #0]
 802174c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802174e:	009b      	lsls	r3, r3, #2
 8021750:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8021752:	4403      	add	r3, r0
 8021754:	440a      	add	r2, r1
 8021756:	601a      	str	r2, [r3, #0]
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
 8021758:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802175a:	3301      	adds	r3, #1
 802175c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802175e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021760:	2b3f      	cmp	r3, #63	@ 0x3f
 8021762:	dd95      	ble.n	8021690 <Transform_Sha256+0x74>
                RND(j);
            }
        }
    #else
        /* partially loop unrolled */
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 8021764:	2300      	movs	r3, #0
 8021766:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021768:	e2a3      	b.n	8021cb2 <Transform_Sha256+0x696>
            RND(0); RND(1); RND(2); RND(3);
 802176a:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 802176c:	69fb      	ldr	r3, [r7, #28]
 802176e:	2106      	movs	r1, #6
 8021770:	4618      	mov	r0, r3
 8021772:	f7ff fe7e 	bl	8021472 <rotrFixed>
 8021776:	4605      	mov	r5, r0
 8021778:	69fb      	ldr	r3, [r7, #28]
 802177a:	210b      	movs	r1, #11
 802177c:	4618      	mov	r0, r3
 802177e:	f7ff fe78 	bl	8021472 <rotrFixed>
 8021782:	4603      	mov	r3, r0
 8021784:	405d      	eors	r5, r3
 8021786:	69fb      	ldr	r3, [r7, #28]
 8021788:	2119      	movs	r1, #25
 802178a:	4618      	mov	r0, r3
 802178c:	f7ff fe71 	bl	8021472 <rotrFixed>
 8021790:	4603      	mov	r3, r0
 8021792:	406b      	eors	r3, r5
 8021794:	18e2      	adds	r2, r4, r3
 8021796:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8021798:	69f8      	ldr	r0, [r7, #28]
 802179a:	6a3c      	ldr	r4, [r7, #32]
 802179c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802179e:	4063      	eors	r3, r4
 80217a0:	4003      	ands	r3, r0
 80217a2:	404b      	eors	r3, r1
 80217a4:	441a      	add	r2, r3
 80217a6:	49bd      	ldr	r1, [pc, #756]	@ (8021a9c <Transform_Sha256+0x480>)
 80217a8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80217aa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80217ae:	441a      	add	r2, r3
 80217b0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80217b2:	009b      	lsls	r3, r3, #2
 80217b4:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80217b6:	440b      	add	r3, r1
 80217b8:	681b      	ldr	r3, [r3, #0]
 80217ba:	4413      	add	r3, r2
 80217bc:	633b      	str	r3, [r7, #48]	@ 0x30
 80217be:	68fb      	ldr	r3, [r7, #12]
 80217c0:	2102      	movs	r1, #2
 80217c2:	4618      	mov	r0, r3
 80217c4:	f7ff fe55 	bl	8021472 <rotrFixed>
 80217c8:	4604      	mov	r4, r0
 80217ca:	68fb      	ldr	r3, [r7, #12]
 80217cc:	210d      	movs	r1, #13
 80217ce:	4618      	mov	r0, r3
 80217d0:	f7ff fe4f 	bl	8021472 <rotrFixed>
 80217d4:	4603      	mov	r3, r0
 80217d6:	405c      	eors	r4, r3
 80217d8:	68fb      	ldr	r3, [r7, #12]
 80217da:	2116      	movs	r1, #22
 80217dc:	4618      	mov	r0, r3
 80217de:	f7ff fe48 	bl	8021472 <rotrFixed>
 80217e2:	4603      	mov	r3, r0
 80217e4:	ea84 0203 	eor.w	r2, r4, r3
 80217e8:	68f9      	ldr	r1, [r7, #12]
 80217ea:	693b      	ldr	r3, [r7, #16]
 80217ec:	4319      	orrs	r1, r3
 80217ee:	697b      	ldr	r3, [r7, #20]
 80217f0:	4019      	ands	r1, r3
 80217f2:	68f8      	ldr	r0, [r7, #12]
 80217f4:	693b      	ldr	r3, [r7, #16]
 80217f6:	4003      	ands	r3, r0
 80217f8:	430b      	orrs	r3, r1
 80217fa:	4413      	add	r3, r2
 80217fc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80217fe:	69ba      	ldr	r2, [r7, #24]
 8021800:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021802:	4413      	add	r3, r2
 8021804:	61bb      	str	r3, [r7, #24]
 8021806:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021808:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802180a:	4413      	add	r3, r2
 802180c:	62bb      	str	r3, [r7, #40]	@ 0x28
 802180e:	6a7c      	ldr	r4, [r7, #36]	@ 0x24
 8021810:	69bb      	ldr	r3, [r7, #24]
 8021812:	2106      	movs	r1, #6
 8021814:	4618      	mov	r0, r3
 8021816:	f7ff fe2c 	bl	8021472 <rotrFixed>
 802181a:	4605      	mov	r5, r0
 802181c:	69bb      	ldr	r3, [r7, #24]
 802181e:	210b      	movs	r1, #11
 8021820:	4618      	mov	r0, r3
 8021822:	f7ff fe26 	bl	8021472 <rotrFixed>
 8021826:	4603      	mov	r3, r0
 8021828:	405d      	eors	r5, r3
 802182a:	69bb      	ldr	r3, [r7, #24]
 802182c:	2119      	movs	r1, #25
 802182e:	4618      	mov	r0, r3
 8021830:	f7ff fe1f 	bl	8021472 <rotrFixed>
 8021834:	4603      	mov	r3, r0
 8021836:	406b      	eors	r3, r5
 8021838:	18e2      	adds	r2, r4, r3
 802183a:	6a39      	ldr	r1, [r7, #32]
 802183c:	69b8      	ldr	r0, [r7, #24]
 802183e:	69fc      	ldr	r4, [r7, #28]
 8021840:	6a3b      	ldr	r3, [r7, #32]
 8021842:	4063      	eors	r3, r4
 8021844:	4003      	ands	r3, r0
 8021846:	404b      	eors	r3, r1
 8021848:	441a      	add	r2, r3
 802184a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802184c:	3301      	adds	r3, #1
 802184e:	4993      	ldr	r1, [pc, #588]	@ (8021a9c <Transform_Sha256+0x480>)
 8021850:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021854:	441a      	add	r2, r3
 8021856:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021858:	3301      	adds	r3, #1
 802185a:	009b      	lsls	r3, r3, #2
 802185c:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 802185e:	440b      	add	r3, r1
 8021860:	681b      	ldr	r3, [r3, #0]
 8021862:	4413      	add	r3, r2
 8021864:	633b      	str	r3, [r7, #48]	@ 0x30
 8021866:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021868:	2102      	movs	r1, #2
 802186a:	4618      	mov	r0, r3
 802186c:	f7ff fe01 	bl	8021472 <rotrFixed>
 8021870:	4604      	mov	r4, r0
 8021872:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021874:	210d      	movs	r1, #13
 8021876:	4618      	mov	r0, r3
 8021878:	f7ff fdfb 	bl	8021472 <rotrFixed>
 802187c:	4603      	mov	r3, r0
 802187e:	405c      	eors	r4, r3
 8021880:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021882:	2116      	movs	r1, #22
 8021884:	4618      	mov	r0, r3
 8021886:	f7ff fdf4 	bl	8021472 <rotrFixed>
 802188a:	4603      	mov	r3, r0
 802188c:	ea84 0203 	eor.w	r2, r4, r3
 8021890:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8021892:	68fb      	ldr	r3, [r7, #12]
 8021894:	4319      	orrs	r1, r3
 8021896:	693b      	ldr	r3, [r7, #16]
 8021898:	4019      	ands	r1, r3
 802189a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 802189c:	68fb      	ldr	r3, [r7, #12]
 802189e:	4003      	ands	r3, r0
 80218a0:	430b      	orrs	r3, r1
 80218a2:	4413      	add	r3, r2
 80218a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80218a6:	697a      	ldr	r2, [r7, #20]
 80218a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80218aa:	4413      	add	r3, r2
 80218ac:	617b      	str	r3, [r7, #20]
 80218ae:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80218b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80218b2:	4413      	add	r3, r2
 80218b4:	627b      	str	r3, [r7, #36]	@ 0x24
 80218b6:	6a3c      	ldr	r4, [r7, #32]
 80218b8:	697b      	ldr	r3, [r7, #20]
 80218ba:	2106      	movs	r1, #6
 80218bc:	4618      	mov	r0, r3
 80218be:	f7ff fdd8 	bl	8021472 <rotrFixed>
 80218c2:	4605      	mov	r5, r0
 80218c4:	697b      	ldr	r3, [r7, #20]
 80218c6:	210b      	movs	r1, #11
 80218c8:	4618      	mov	r0, r3
 80218ca:	f7ff fdd2 	bl	8021472 <rotrFixed>
 80218ce:	4603      	mov	r3, r0
 80218d0:	405d      	eors	r5, r3
 80218d2:	697b      	ldr	r3, [r7, #20]
 80218d4:	2119      	movs	r1, #25
 80218d6:	4618      	mov	r0, r3
 80218d8:	f7ff fdcb 	bl	8021472 <rotrFixed>
 80218dc:	4603      	mov	r3, r0
 80218de:	406b      	eors	r3, r5
 80218e0:	18e2      	adds	r2, r4, r3
 80218e2:	69f9      	ldr	r1, [r7, #28]
 80218e4:	6978      	ldr	r0, [r7, #20]
 80218e6:	69bc      	ldr	r4, [r7, #24]
 80218e8:	69fb      	ldr	r3, [r7, #28]
 80218ea:	4063      	eors	r3, r4
 80218ec:	4003      	ands	r3, r0
 80218ee:	404b      	eors	r3, r1
 80218f0:	441a      	add	r2, r3
 80218f2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80218f4:	3302      	adds	r3, #2
 80218f6:	4969      	ldr	r1, [pc, #420]	@ (8021a9c <Transform_Sha256+0x480>)
 80218f8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80218fc:	441a      	add	r2, r3
 80218fe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021900:	3302      	adds	r3, #2
 8021902:	009b      	lsls	r3, r3, #2
 8021904:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021906:	440b      	add	r3, r1
 8021908:	681b      	ldr	r3, [r3, #0]
 802190a:	4413      	add	r3, r2
 802190c:	633b      	str	r3, [r7, #48]	@ 0x30
 802190e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021910:	2102      	movs	r1, #2
 8021912:	4618      	mov	r0, r3
 8021914:	f7ff fdad 	bl	8021472 <rotrFixed>
 8021918:	4604      	mov	r4, r0
 802191a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802191c:	210d      	movs	r1, #13
 802191e:	4618      	mov	r0, r3
 8021920:	f7ff fda7 	bl	8021472 <rotrFixed>
 8021924:	4603      	mov	r3, r0
 8021926:	405c      	eors	r4, r3
 8021928:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802192a:	2116      	movs	r1, #22
 802192c:	4618      	mov	r0, r3
 802192e:	f7ff fda0 	bl	8021472 <rotrFixed>
 8021932:	4603      	mov	r3, r0
 8021934:	ea84 0203 	eor.w	r2, r4, r3
 8021938:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 802193a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802193c:	4319      	orrs	r1, r3
 802193e:	68fb      	ldr	r3, [r7, #12]
 8021940:	4019      	ands	r1, r3
 8021942:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021944:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021946:	4003      	ands	r3, r0
 8021948:	430b      	orrs	r3, r1
 802194a:	4413      	add	r3, r2
 802194c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802194e:	693a      	ldr	r2, [r7, #16]
 8021950:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021952:	4413      	add	r3, r2
 8021954:	613b      	str	r3, [r7, #16]
 8021956:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021958:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802195a:	4413      	add	r3, r2
 802195c:	623b      	str	r3, [r7, #32]
 802195e:	69fc      	ldr	r4, [r7, #28]
 8021960:	693b      	ldr	r3, [r7, #16]
 8021962:	2106      	movs	r1, #6
 8021964:	4618      	mov	r0, r3
 8021966:	f7ff fd84 	bl	8021472 <rotrFixed>
 802196a:	4605      	mov	r5, r0
 802196c:	693b      	ldr	r3, [r7, #16]
 802196e:	210b      	movs	r1, #11
 8021970:	4618      	mov	r0, r3
 8021972:	f7ff fd7e 	bl	8021472 <rotrFixed>
 8021976:	4603      	mov	r3, r0
 8021978:	405d      	eors	r5, r3
 802197a:	693b      	ldr	r3, [r7, #16]
 802197c:	2119      	movs	r1, #25
 802197e:	4618      	mov	r0, r3
 8021980:	f7ff fd77 	bl	8021472 <rotrFixed>
 8021984:	4603      	mov	r3, r0
 8021986:	406b      	eors	r3, r5
 8021988:	18e2      	adds	r2, r4, r3
 802198a:	69b9      	ldr	r1, [r7, #24]
 802198c:	6938      	ldr	r0, [r7, #16]
 802198e:	697c      	ldr	r4, [r7, #20]
 8021990:	69bb      	ldr	r3, [r7, #24]
 8021992:	4063      	eors	r3, r4
 8021994:	4003      	ands	r3, r0
 8021996:	404b      	eors	r3, r1
 8021998:	441a      	add	r2, r3
 802199a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802199c:	3303      	adds	r3, #3
 802199e:	493f      	ldr	r1, [pc, #252]	@ (8021a9c <Transform_Sha256+0x480>)
 80219a0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80219a4:	441a      	add	r2, r3
 80219a6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80219a8:	3303      	adds	r3, #3
 80219aa:	009b      	lsls	r3, r3, #2
 80219ac:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80219ae:	440b      	add	r3, r1
 80219b0:	681b      	ldr	r3, [r3, #0]
 80219b2:	4413      	add	r3, r2
 80219b4:	633b      	str	r3, [r7, #48]	@ 0x30
 80219b6:	6a3b      	ldr	r3, [r7, #32]
 80219b8:	2102      	movs	r1, #2
 80219ba:	4618      	mov	r0, r3
 80219bc:	f7ff fd59 	bl	8021472 <rotrFixed>
 80219c0:	4604      	mov	r4, r0
 80219c2:	6a3b      	ldr	r3, [r7, #32]
 80219c4:	210d      	movs	r1, #13
 80219c6:	4618      	mov	r0, r3
 80219c8:	f7ff fd53 	bl	8021472 <rotrFixed>
 80219cc:	4603      	mov	r3, r0
 80219ce:	405c      	eors	r4, r3
 80219d0:	6a3b      	ldr	r3, [r7, #32]
 80219d2:	2116      	movs	r1, #22
 80219d4:	4618      	mov	r0, r3
 80219d6:	f7ff fd4c 	bl	8021472 <rotrFixed>
 80219da:	4603      	mov	r3, r0
 80219dc:	ea84 0203 	eor.w	r2, r4, r3
 80219e0:	6a39      	ldr	r1, [r7, #32]
 80219e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80219e4:	4319      	orrs	r1, r3
 80219e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80219e8:	4019      	ands	r1, r3
 80219ea:	6a38      	ldr	r0, [r7, #32]
 80219ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80219ee:	4003      	ands	r3, r0
 80219f0:	430b      	orrs	r3, r1
 80219f2:	4413      	add	r3, r2
 80219f4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80219f6:	68fa      	ldr	r2, [r7, #12]
 80219f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80219fa:	4413      	add	r3, r2
 80219fc:	60fb      	str	r3, [r7, #12]
 80219fe:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021a00:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021a02:	4413      	add	r3, r2
 8021a04:	61fb      	str	r3, [r7, #28]
            RND(4); RND(5); RND(6); RND(7);
 8021a06:	69bc      	ldr	r4, [r7, #24]
 8021a08:	68fb      	ldr	r3, [r7, #12]
 8021a0a:	2106      	movs	r1, #6
 8021a0c:	4618      	mov	r0, r3
 8021a0e:	f7ff fd30 	bl	8021472 <rotrFixed>
 8021a12:	4605      	mov	r5, r0
 8021a14:	68fb      	ldr	r3, [r7, #12]
 8021a16:	210b      	movs	r1, #11
 8021a18:	4618      	mov	r0, r3
 8021a1a:	f7ff fd2a 	bl	8021472 <rotrFixed>
 8021a1e:	4603      	mov	r3, r0
 8021a20:	405d      	eors	r5, r3
 8021a22:	68fb      	ldr	r3, [r7, #12]
 8021a24:	2119      	movs	r1, #25
 8021a26:	4618      	mov	r0, r3
 8021a28:	f7ff fd23 	bl	8021472 <rotrFixed>
 8021a2c:	4603      	mov	r3, r0
 8021a2e:	406b      	eors	r3, r5
 8021a30:	18e2      	adds	r2, r4, r3
 8021a32:	6979      	ldr	r1, [r7, #20]
 8021a34:	68f8      	ldr	r0, [r7, #12]
 8021a36:	693c      	ldr	r4, [r7, #16]
 8021a38:	697b      	ldr	r3, [r7, #20]
 8021a3a:	4063      	eors	r3, r4
 8021a3c:	4003      	ands	r3, r0
 8021a3e:	404b      	eors	r3, r1
 8021a40:	441a      	add	r2, r3
 8021a42:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021a44:	3304      	adds	r3, #4
 8021a46:	4915      	ldr	r1, [pc, #84]	@ (8021a9c <Transform_Sha256+0x480>)
 8021a48:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021a4c:	441a      	add	r2, r3
 8021a4e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021a50:	3304      	adds	r3, #4
 8021a52:	009b      	lsls	r3, r3, #2
 8021a54:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021a56:	440b      	add	r3, r1
 8021a58:	681b      	ldr	r3, [r3, #0]
 8021a5a:	4413      	add	r3, r2
 8021a5c:	633b      	str	r3, [r7, #48]	@ 0x30
 8021a5e:	69fb      	ldr	r3, [r7, #28]
 8021a60:	2102      	movs	r1, #2
 8021a62:	4618      	mov	r0, r3
 8021a64:	f7ff fd05 	bl	8021472 <rotrFixed>
 8021a68:	4604      	mov	r4, r0
 8021a6a:	69fb      	ldr	r3, [r7, #28]
 8021a6c:	210d      	movs	r1, #13
 8021a6e:	4618      	mov	r0, r3
 8021a70:	f7ff fcff 	bl	8021472 <rotrFixed>
 8021a74:	4603      	mov	r3, r0
 8021a76:	405c      	eors	r4, r3
 8021a78:	69fb      	ldr	r3, [r7, #28]
 8021a7a:	2116      	movs	r1, #22
 8021a7c:	4618      	mov	r0, r3
 8021a7e:	f7ff fcf8 	bl	8021472 <rotrFixed>
 8021a82:	4603      	mov	r3, r0
 8021a84:	ea84 0203 	eor.w	r2, r4, r3
 8021a88:	69f9      	ldr	r1, [r7, #28]
 8021a8a:	6a3b      	ldr	r3, [r7, #32]
 8021a8c:	4319      	orrs	r1, r3
 8021a8e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021a90:	4019      	ands	r1, r3
 8021a92:	69f8      	ldr	r0, [r7, #28]
 8021a94:	6a3b      	ldr	r3, [r7, #32]
 8021a96:	4003      	ands	r3, r0
 8021a98:	430b      	orrs	r3, r1
 8021a9a:	e001      	b.n	8021aa0 <Transform_Sha256+0x484>
 8021a9c:	08033b94 	.word	0x08033b94
 8021aa0:	4413      	add	r3, r2
 8021aa2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021aa4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8021aa6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021aa8:	4413      	add	r3, r2
 8021aaa:	62bb      	str	r3, [r7, #40]	@ 0x28
 8021aac:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021aae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021ab0:	4413      	add	r3, r2
 8021ab2:	61bb      	str	r3, [r7, #24]
 8021ab4:	697c      	ldr	r4, [r7, #20]
 8021ab6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021ab8:	2106      	movs	r1, #6
 8021aba:	4618      	mov	r0, r3
 8021abc:	f7ff fcd9 	bl	8021472 <rotrFixed>
 8021ac0:	4605      	mov	r5, r0
 8021ac2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021ac4:	210b      	movs	r1, #11
 8021ac6:	4618      	mov	r0, r3
 8021ac8:	f7ff fcd3 	bl	8021472 <rotrFixed>
 8021acc:	4603      	mov	r3, r0
 8021ace:	405d      	eors	r5, r3
 8021ad0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021ad2:	2119      	movs	r1, #25
 8021ad4:	4618      	mov	r0, r3
 8021ad6:	f7ff fccc 	bl	8021472 <rotrFixed>
 8021ada:	4603      	mov	r3, r0
 8021adc:	406b      	eors	r3, r5
 8021ade:	18e2      	adds	r2, r4, r3
 8021ae0:	6939      	ldr	r1, [r7, #16]
 8021ae2:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8021ae4:	68fc      	ldr	r4, [r7, #12]
 8021ae6:	693b      	ldr	r3, [r7, #16]
 8021ae8:	4063      	eors	r3, r4
 8021aea:	4003      	ands	r3, r0
 8021aec:	404b      	eors	r3, r1
 8021aee:	441a      	add	r2, r3
 8021af0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021af2:	3305      	adds	r3, #5
 8021af4:	4986      	ldr	r1, [pc, #536]	@ (8021d10 <Transform_Sha256+0x6f4>)
 8021af6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021afa:	441a      	add	r2, r3
 8021afc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021afe:	3305      	adds	r3, #5
 8021b00:	009b      	lsls	r3, r3, #2
 8021b02:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021b04:	440b      	add	r3, r1
 8021b06:	681b      	ldr	r3, [r3, #0]
 8021b08:	4413      	add	r3, r2
 8021b0a:	633b      	str	r3, [r7, #48]	@ 0x30
 8021b0c:	69bb      	ldr	r3, [r7, #24]
 8021b0e:	2102      	movs	r1, #2
 8021b10:	4618      	mov	r0, r3
 8021b12:	f7ff fcae 	bl	8021472 <rotrFixed>
 8021b16:	4604      	mov	r4, r0
 8021b18:	69bb      	ldr	r3, [r7, #24]
 8021b1a:	210d      	movs	r1, #13
 8021b1c:	4618      	mov	r0, r3
 8021b1e:	f7ff fca8 	bl	8021472 <rotrFixed>
 8021b22:	4603      	mov	r3, r0
 8021b24:	405c      	eors	r4, r3
 8021b26:	69bb      	ldr	r3, [r7, #24]
 8021b28:	2116      	movs	r1, #22
 8021b2a:	4618      	mov	r0, r3
 8021b2c:	f7ff fca1 	bl	8021472 <rotrFixed>
 8021b30:	4603      	mov	r3, r0
 8021b32:	ea84 0203 	eor.w	r2, r4, r3
 8021b36:	69b9      	ldr	r1, [r7, #24]
 8021b38:	69fb      	ldr	r3, [r7, #28]
 8021b3a:	4319      	orrs	r1, r3
 8021b3c:	6a3b      	ldr	r3, [r7, #32]
 8021b3e:	4019      	ands	r1, r3
 8021b40:	69b8      	ldr	r0, [r7, #24]
 8021b42:	69fb      	ldr	r3, [r7, #28]
 8021b44:	4003      	ands	r3, r0
 8021b46:	430b      	orrs	r3, r1
 8021b48:	4413      	add	r3, r2
 8021b4a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021b4c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8021b4e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021b50:	4413      	add	r3, r2
 8021b52:	627b      	str	r3, [r7, #36]	@ 0x24
 8021b54:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021b56:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021b58:	4413      	add	r3, r2
 8021b5a:	617b      	str	r3, [r7, #20]
 8021b5c:	693c      	ldr	r4, [r7, #16]
 8021b5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021b60:	2106      	movs	r1, #6
 8021b62:	4618      	mov	r0, r3
 8021b64:	f7ff fc85 	bl	8021472 <rotrFixed>
 8021b68:	4605      	mov	r5, r0
 8021b6a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021b6c:	210b      	movs	r1, #11
 8021b6e:	4618      	mov	r0, r3
 8021b70:	f7ff fc7f 	bl	8021472 <rotrFixed>
 8021b74:	4603      	mov	r3, r0
 8021b76:	405d      	eors	r5, r3
 8021b78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021b7a:	2119      	movs	r1, #25
 8021b7c:	4618      	mov	r0, r3
 8021b7e:	f7ff fc78 	bl	8021472 <rotrFixed>
 8021b82:	4603      	mov	r3, r0
 8021b84:	406b      	eors	r3, r5
 8021b86:	18e2      	adds	r2, r4, r3
 8021b88:	68f9      	ldr	r1, [r7, #12]
 8021b8a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021b8c:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8021b8e:	68fb      	ldr	r3, [r7, #12]
 8021b90:	4063      	eors	r3, r4
 8021b92:	4003      	ands	r3, r0
 8021b94:	404b      	eors	r3, r1
 8021b96:	441a      	add	r2, r3
 8021b98:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021b9a:	3306      	adds	r3, #6
 8021b9c:	495c      	ldr	r1, [pc, #368]	@ (8021d10 <Transform_Sha256+0x6f4>)
 8021b9e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021ba2:	441a      	add	r2, r3
 8021ba4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021ba6:	3306      	adds	r3, #6
 8021ba8:	009b      	lsls	r3, r3, #2
 8021baa:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021bac:	440b      	add	r3, r1
 8021bae:	681b      	ldr	r3, [r3, #0]
 8021bb0:	4413      	add	r3, r2
 8021bb2:	633b      	str	r3, [r7, #48]	@ 0x30
 8021bb4:	697b      	ldr	r3, [r7, #20]
 8021bb6:	2102      	movs	r1, #2
 8021bb8:	4618      	mov	r0, r3
 8021bba:	f7ff fc5a 	bl	8021472 <rotrFixed>
 8021bbe:	4604      	mov	r4, r0
 8021bc0:	697b      	ldr	r3, [r7, #20]
 8021bc2:	210d      	movs	r1, #13
 8021bc4:	4618      	mov	r0, r3
 8021bc6:	f7ff fc54 	bl	8021472 <rotrFixed>
 8021bca:	4603      	mov	r3, r0
 8021bcc:	405c      	eors	r4, r3
 8021bce:	697b      	ldr	r3, [r7, #20]
 8021bd0:	2116      	movs	r1, #22
 8021bd2:	4618      	mov	r0, r3
 8021bd4:	f7ff fc4d 	bl	8021472 <rotrFixed>
 8021bd8:	4603      	mov	r3, r0
 8021bda:	ea84 0203 	eor.w	r2, r4, r3
 8021bde:	6979      	ldr	r1, [r7, #20]
 8021be0:	69bb      	ldr	r3, [r7, #24]
 8021be2:	4319      	orrs	r1, r3
 8021be4:	69fb      	ldr	r3, [r7, #28]
 8021be6:	4019      	ands	r1, r3
 8021be8:	6978      	ldr	r0, [r7, #20]
 8021bea:	69bb      	ldr	r3, [r7, #24]
 8021bec:	4003      	ands	r3, r0
 8021bee:	430b      	orrs	r3, r1
 8021bf0:	4413      	add	r3, r2
 8021bf2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021bf4:	6a3a      	ldr	r2, [r7, #32]
 8021bf6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021bf8:	4413      	add	r3, r2
 8021bfa:	623b      	str	r3, [r7, #32]
 8021bfc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021bfe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021c00:	4413      	add	r3, r2
 8021c02:	613b      	str	r3, [r7, #16]
 8021c04:	68fc      	ldr	r4, [r7, #12]
 8021c06:	6a3b      	ldr	r3, [r7, #32]
 8021c08:	2106      	movs	r1, #6
 8021c0a:	4618      	mov	r0, r3
 8021c0c:	f7ff fc31 	bl	8021472 <rotrFixed>
 8021c10:	4605      	mov	r5, r0
 8021c12:	6a3b      	ldr	r3, [r7, #32]
 8021c14:	210b      	movs	r1, #11
 8021c16:	4618      	mov	r0, r3
 8021c18:	f7ff fc2b 	bl	8021472 <rotrFixed>
 8021c1c:	4603      	mov	r3, r0
 8021c1e:	405d      	eors	r5, r3
 8021c20:	6a3b      	ldr	r3, [r7, #32]
 8021c22:	2119      	movs	r1, #25
 8021c24:	4618      	mov	r0, r3
 8021c26:	f7ff fc24 	bl	8021472 <rotrFixed>
 8021c2a:	4603      	mov	r3, r0
 8021c2c:	406b      	eors	r3, r5
 8021c2e:	18e2      	adds	r2, r4, r3
 8021c30:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8021c32:	6a38      	ldr	r0, [r7, #32]
 8021c34:	6a7c      	ldr	r4, [r7, #36]	@ 0x24
 8021c36:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021c38:	4063      	eors	r3, r4
 8021c3a:	4003      	ands	r3, r0
 8021c3c:	404b      	eors	r3, r1
 8021c3e:	441a      	add	r2, r3
 8021c40:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021c42:	3307      	adds	r3, #7
 8021c44:	4932      	ldr	r1, [pc, #200]	@ (8021d10 <Transform_Sha256+0x6f4>)
 8021c46:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8021c4a:	441a      	add	r2, r3
 8021c4c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021c4e:	3307      	adds	r3, #7
 8021c50:	009b      	lsls	r3, r3, #2
 8021c52:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8021c54:	440b      	add	r3, r1
 8021c56:	681b      	ldr	r3, [r3, #0]
 8021c58:	4413      	add	r3, r2
 8021c5a:	633b      	str	r3, [r7, #48]	@ 0x30
 8021c5c:	693b      	ldr	r3, [r7, #16]
 8021c5e:	2102      	movs	r1, #2
 8021c60:	4618      	mov	r0, r3
 8021c62:	f7ff fc06 	bl	8021472 <rotrFixed>
 8021c66:	4604      	mov	r4, r0
 8021c68:	693b      	ldr	r3, [r7, #16]
 8021c6a:	210d      	movs	r1, #13
 8021c6c:	4618      	mov	r0, r3
 8021c6e:	f7ff fc00 	bl	8021472 <rotrFixed>
 8021c72:	4603      	mov	r3, r0
 8021c74:	405c      	eors	r4, r3
 8021c76:	693b      	ldr	r3, [r7, #16]
 8021c78:	2116      	movs	r1, #22
 8021c7a:	4618      	mov	r0, r3
 8021c7c:	f7ff fbf9 	bl	8021472 <rotrFixed>
 8021c80:	4603      	mov	r3, r0
 8021c82:	ea84 0203 	eor.w	r2, r4, r3
 8021c86:	6939      	ldr	r1, [r7, #16]
 8021c88:	697b      	ldr	r3, [r7, #20]
 8021c8a:	4319      	orrs	r1, r3
 8021c8c:	69bb      	ldr	r3, [r7, #24]
 8021c8e:	4019      	ands	r1, r3
 8021c90:	6938      	ldr	r0, [r7, #16]
 8021c92:	697b      	ldr	r3, [r7, #20]
 8021c94:	4003      	ands	r3, r0
 8021c96:	430b      	orrs	r3, r1
 8021c98:	4413      	add	r3, r2
 8021c9a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8021c9c:	69fa      	ldr	r2, [r7, #28]
 8021c9e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8021ca0:	4413      	add	r3, r2
 8021ca2:	61fb      	str	r3, [r7, #28]
 8021ca4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8021ca6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021ca8:	4413      	add	r3, r2
 8021caa:	60fb      	str	r3, [r7, #12]
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 8021cac:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021cae:	3308      	adds	r3, #8
 8021cb0:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021cb2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021cb4:	2b3f      	cmp	r3, #63	@ 0x3f
 8021cb6:	f77f ad58 	ble.w	802176a <Transform_Sha256+0x14e>
        }
    #endif /* USE_SLOW_SHA256 */

        /* Add the working vars back into digest state[] */
        for (i = 0; i < 8; i++) {
 8021cba:	2300      	movs	r3, #0
 8021cbc:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021cbe:	e011      	b.n	8021ce4 <Transform_Sha256+0x6c8>
            sha256->digest[i] += S[i];
 8021cc0:	687b      	ldr	r3, [r7, #4]
 8021cc2:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8021cc4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8021cc8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021cca:	009b      	lsls	r3, r3, #2
 8021ccc:	3340      	adds	r3, #64	@ 0x40
 8021cce:	443b      	add	r3, r7
 8021cd0:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8021cd4:	18d1      	adds	r1, r2, r3
 8021cd6:	687b      	ldr	r3, [r7, #4]
 8021cd8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8021cda:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = 0; i < 8; i++) {
 8021cde:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021ce0:	3301      	adds	r3, #1
 8021ce2:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8021ce4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8021ce6:	2b07      	cmp	r3, #7
 8021ce8:	ddea      	ble.n	8021cc0 <Transform_Sha256+0x6a4>
        }

    #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_CACHE)
        ForceZero(W, sizeof(word32) * WC_SHA256_BLOCK_SIZE);
 8021cea:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8021cee:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8021cf0:	f7ff fc0b 	bl	802150a <ForceZero>
        XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8021cf4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8021cf6:	637b      	str	r3, [r7, #52]	@ 0x34
 8021cf8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8021cfa:	2b00      	cmp	r3, #0
 8021cfc:	d002      	beq.n	8021d04 <Transform_Sha256+0x6e8>
 8021cfe:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8021d00:	f7fc fee4 	bl	801eacc <wolfSSL_Free>
    #endif
        return 0;
 8021d04:	2300      	movs	r3, #0
    }
 8021d06:	4618      	mov	r0, r3
 8021d08:	3740      	adds	r7, #64	@ 0x40
 8021d0a:	46bd      	mov	sp, r7
 8021d0c:	bdb0      	pop	{r4, r5, r7, pc}
 8021d0e:	bf00      	nop
 8021d10:	08033b94 	.word	0x08033b94

08021d14 <AddLength>:


#ifdef XTRANSFORM

    static WC_INLINE void AddLength(wc_Sha256* sha256, word32 len)
    {
 8021d14:	b480      	push	{r7}
 8021d16:	b085      	sub	sp, #20
 8021d18:	af00      	add	r7, sp, #0
 8021d1a:	6078      	str	r0, [r7, #4]
 8021d1c:	6039      	str	r1, [r7, #0]
        word32 tmp = sha256->loLen;
 8021d1e:	687b      	ldr	r3, [r7, #4]
 8021d20:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021d22:	60fb      	str	r3, [r7, #12]
        if ((sha256->loLen += len) < tmp) {
 8021d24:	687b      	ldr	r3, [r7, #4]
 8021d26:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 8021d28:	683b      	ldr	r3, [r7, #0]
 8021d2a:	441a      	add	r2, r3
 8021d2c:	687b      	ldr	r3, [r7, #4]
 8021d2e:	665a      	str	r2, [r3, #100]	@ 0x64
 8021d30:	687b      	ldr	r3, [r7, #4]
 8021d32:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021d34:	68fa      	ldr	r2, [r7, #12]
 8021d36:	429a      	cmp	r2, r3
 8021d38:	d904      	bls.n	8021d44 <AddLength+0x30>
            sha256->hiLen++;                       /* carry low to high */
 8021d3a:	687b      	ldr	r3, [r7, #4]
 8021d3c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8021d3e:	1c5a      	adds	r2, r3, #1
 8021d40:	687b      	ldr	r3, [r7, #4]
 8021d42:	669a      	str	r2, [r3, #104]	@ 0x68
        }
    }
 8021d44:	bf00      	nop
 8021d46:	3714      	adds	r7, #20
 8021d48:	46bd      	mov	sp, r7
 8021d4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d4e:	4770      	bx	lr

08021d50 <Sha256Update>:

    /* do block size increments/updates */
    static WC_INLINE int Sha256Update(wc_Sha256* sha256, const byte* data,
        word32 len)
    {
 8021d50:	b580      	push	{r7, lr}
 8021d52:	b088      	sub	sp, #32
 8021d54:	af00      	add	r7, sp, #0
 8021d56:	60f8      	str	r0, [r7, #12]
 8021d58:	60b9      	str	r1, [r7, #8]
 8021d5a:	607a      	str	r2, [r7, #4]
        int ret = 0;
 8021d5c:	2300      	movs	r3, #0
 8021d5e:	61fb      	str	r3, [r7, #28]
        word32 blocksLen;
        byte* local;

        /* check that internal buffLen is valid */
        if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE) {
 8021d60:	68fb      	ldr	r3, [r7, #12]
 8021d62:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021d64:	2b3f      	cmp	r3, #63	@ 0x3f
 8021d66:	d902      	bls.n	8021d6e <Sha256Update+0x1e>
            return BUFFER_E;
 8021d68:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 8021d6c:	e075      	b.n	8021e5a <Sha256Update+0x10a>
        }

        /* add length for final */
        AddLength(sha256, len);
 8021d6e:	6879      	ldr	r1, [r7, #4]
 8021d70:	68f8      	ldr	r0, [r7, #12]
 8021d72:	f7ff ffcf 	bl	8021d14 <AddLength>

        local = (byte*)sha256->buffer;
 8021d76:	68fb      	ldr	r3, [r7, #12]
 8021d78:	3320      	adds	r3, #32
 8021d7a:	61bb      	str	r3, [r7, #24]

        /* process any remainder from previous operation */
        if (sha256->buffLen > 0) {
 8021d7c:	68fb      	ldr	r3, [r7, #12]
 8021d7e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021d80:	2b00      	cmp	r3, #0
 8021d82:	d056      	beq.n	8021e32 <Sha256Update+0xe2>
            blocksLen = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
 8021d84:	68fb      	ldr	r3, [r7, #12]
 8021d86:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021d88:	f1c3 0340 	rsb	r3, r3, #64	@ 0x40
 8021d8c:	4619      	mov	r1, r3
 8021d8e:	6878      	ldr	r0, [r7, #4]
 8021d90:	f7ff fbd4 	bl	802153c <min>
 8021d94:	6178      	str	r0, [r7, #20]
            XMEMCPY(&local[sha256->buffLen], data, blocksLen);
 8021d96:	68fb      	ldr	r3, [r7, #12]
 8021d98:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021d9a:	69ba      	ldr	r2, [r7, #24]
 8021d9c:	4413      	add	r3, r2
 8021d9e:	697a      	ldr	r2, [r7, #20]
 8021da0:	68b9      	ldr	r1, [r7, #8]
 8021da2:	4618      	mov	r0, r3
 8021da4:	f006 fbfe 	bl	80285a4 <memcpy>

            sha256->buffLen += blocksLen;
 8021da8:	68fb      	ldr	r3, [r7, #12]
 8021daa:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8021dac:	697b      	ldr	r3, [r7, #20]
 8021dae:	441a      	add	r2, r3
 8021db0:	68fb      	ldr	r3, [r7, #12]
 8021db2:	661a      	str	r2, [r3, #96]	@ 0x60
            data            += blocksLen;
 8021db4:	68ba      	ldr	r2, [r7, #8]
 8021db6:	697b      	ldr	r3, [r7, #20]
 8021db8:	4413      	add	r3, r2
 8021dba:	60bb      	str	r3, [r7, #8]
            len             -= blocksLen;
 8021dbc:	687a      	ldr	r2, [r7, #4]
 8021dbe:	697b      	ldr	r3, [r7, #20]
 8021dc0:	1ad3      	subs	r3, r2, r3
 8021dc2:	607b      	str	r3, [r7, #4]

            if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
 8021dc4:	68fb      	ldr	r3, [r7, #12]
 8021dc6:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021dc8:	2b40      	cmp	r3, #64	@ 0x40
 8021dca:	d132      	bne.n	8021e32 <Sha256Update+0xe2>
                    esp_sha_try_hw_lock(&sha256->ctx);
                }
            #endif

            if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
                ByteReverseWords(sha256->buffer, sha256->buffer,
 8021dcc:	68fb      	ldr	r3, [r7, #12]
 8021dce:	f103 0020 	add.w	r0, r3, #32
 8021dd2:	68fb      	ldr	r3, [r7, #12]
 8021dd4:	3320      	adds	r3, #32
 8021dd6:	2240      	movs	r2, #64	@ 0x40
 8021dd8:	4619      	mov	r1, r3
 8021dda:	f7ff fb70 	bl	80214be <ByteReverseWords>
                    #endif
                    esp_sha256_process(sha256, (const byte*)local);
                }
            #else
                /* Always SW */
                ret = XTRANSFORM(sha256, (const byte*)local);
 8021dde:	69b9      	ldr	r1, [r7, #24]
 8021de0:	68f8      	ldr	r0, [r7, #12]
 8021de2:	f7ff fc1b 	bl	802161c <Transform_Sha256>
 8021de6:	61f8      	str	r0, [r7, #28]
            #endif
                if (ret == 0)
 8021de8:	69fb      	ldr	r3, [r7, #28]
 8021dea:	2b00      	cmp	r3, #0
 8021dec:	d103      	bne.n	8021df6 <Sha256Update+0xa6>
                    sha256->buffLen = 0;
 8021dee:	68fb      	ldr	r3, [r7, #12]
 8021df0:	2200      	movs	r2, #0
 8021df2:	661a      	str	r2, [r3, #96]	@ 0x60
 8021df4:	e01d      	b.n	8021e32 <Sha256Update+0xe2>
                else
                    len = 0; /* error */
 8021df6:	2300      	movs	r3, #0
 8021df8:	607b      	str	r3, [r7, #4]
    #endif /* XTRANSFORM_LEN */
    #if !defined(XTRANSFORM_LEN) || \
        (defined(WOLFSSL_X86_64_BUILD) && defined(USE_INTEL_SPEEDUP) && \
         (defined(HAVE_INTEL_AVX1) || defined(HAVE_INTEL_AVX2)))
        {
            while (len >= WC_SHA256_BLOCK_SIZE) {
 8021dfa:	e01a      	b.n	8021e32 <Sha256Update+0xe2>
                word32* local32 = sha256->buffer;
 8021dfc:	68fb      	ldr	r3, [r7, #12]
 8021dfe:	3320      	adds	r3, #32
 8021e00:	613b      	str	r3, [r7, #16]
                    local32 = (word32*)data;
                }
                else
            #endif
                {
                    XMEMCPY(local32, data, WC_SHA256_BLOCK_SIZE);
 8021e02:	2240      	movs	r2, #64	@ 0x40
 8021e04:	68b9      	ldr	r1, [r7, #8]
 8021e06:	6938      	ldr	r0, [r7, #16]
 8021e08:	f006 fbcc 	bl	80285a4 <memcpy>
                }

                data += WC_SHA256_BLOCK_SIZE;
 8021e0c:	68bb      	ldr	r3, [r7, #8]
 8021e0e:	3340      	adds	r3, #64	@ 0x40
 8021e10:	60bb      	str	r3, [r7, #8]
                len  -= WC_SHA256_BLOCK_SIZE;
 8021e12:	687b      	ldr	r3, [r7, #4]
 8021e14:	3b40      	subs	r3, #64	@ 0x40
 8021e16:	607b      	str	r3, [r7, #4]
                    esp_sha_try_hw_lock(&sha256->ctx);
                }
            #endif

            if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
                ByteReverseWords(local32, local32, WC_SHA256_BLOCK_SIZE);
 8021e18:	2240      	movs	r2, #64	@ 0x40
 8021e1a:	6939      	ldr	r1, [r7, #16]
 8021e1c:	6938      	ldr	r0, [r7, #16]
 8021e1e:	f7ff fb4e 	bl	80214be <ByteReverseWords>
                else {
                    ESP_LOGV(TAG, "Sha256Update process hardware");
                    esp_sha256_process(sha256, (const byte*)local32);
                }
            #else
                ret = XTRANSFORM(sha256, (const byte*)local32);
 8021e22:	6939      	ldr	r1, [r7, #16]
 8021e24:	68f8      	ldr	r0, [r7, #12]
 8021e26:	f7ff fbf9 	bl	802161c <Transform_Sha256>
 8021e2a:	61f8      	str	r0, [r7, #28]
            #endif

                if (ret != 0)
 8021e2c:	69fb      	ldr	r3, [r7, #28]
 8021e2e:	2b00      	cmp	r3, #0
 8021e30:	d103      	bne.n	8021e3a <Sha256Update+0xea>
            while (len >= WC_SHA256_BLOCK_SIZE) {
 8021e32:	687b      	ldr	r3, [r7, #4]
 8021e34:	2b3f      	cmp	r3, #63	@ 0x3f
 8021e36:	d8e1      	bhi.n	8021dfc <Sha256Update+0xac>
 8021e38:	e000      	b.n	8021e3c <Sha256Update+0xec>
                    break;
 8021e3a:	bf00      	nop
            }
        }
    #endif

        /* save remainder */
        if (ret == 0 && len > 0) {
 8021e3c:	69fb      	ldr	r3, [r7, #28]
 8021e3e:	2b00      	cmp	r3, #0
 8021e40:	d10a      	bne.n	8021e58 <Sha256Update+0x108>
 8021e42:	687b      	ldr	r3, [r7, #4]
 8021e44:	2b00      	cmp	r3, #0
 8021e46:	d007      	beq.n	8021e58 <Sha256Update+0x108>
            XMEMCPY(local, data, len);
 8021e48:	687a      	ldr	r2, [r7, #4]
 8021e4a:	68b9      	ldr	r1, [r7, #8]
 8021e4c:	69b8      	ldr	r0, [r7, #24]
 8021e4e:	f006 fba9 	bl	80285a4 <memcpy>
            sha256->buffLen = len;
 8021e52:	68fb      	ldr	r3, [r7, #12]
 8021e54:	687a      	ldr	r2, [r7, #4]
 8021e56:	661a      	str	r2, [r3, #96]	@ 0x60
        }

        return ret;
 8021e58:	69fb      	ldr	r3, [r7, #28]
    }
 8021e5a:	4618      	mov	r0, r3
 8021e5c:	3720      	adds	r7, #32
 8021e5e:	46bd      	mov	sp, r7
 8021e60:	bd80      	pop	{r7, pc}

08021e62 <wc_Sha256Update>:
#if defined(WOLFSSL_KCAPI_HASH)
    /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */

#else
    int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
    {
 8021e62:	b580      	push	{r7, lr}
 8021e64:	b084      	sub	sp, #16
 8021e66:	af00      	add	r7, sp, #0
 8021e68:	60f8      	str	r0, [r7, #12]
 8021e6a:	60b9      	str	r1, [r7, #8]
 8021e6c:	607a      	str	r2, [r7, #4]
        if (sha256 == NULL) {
 8021e6e:	68fb      	ldr	r3, [r7, #12]
 8021e70:	2b00      	cmp	r3, #0
 8021e72:	d102      	bne.n	8021e7a <wc_Sha256Update+0x18>
            return BAD_FUNC_ARG;
 8021e74:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8021e78:	e013      	b.n	8021ea2 <wc_Sha256Update+0x40>
        }
        if (data == NULL && len == 0) {
 8021e7a:	68bb      	ldr	r3, [r7, #8]
 8021e7c:	2b00      	cmp	r3, #0
 8021e7e:	d104      	bne.n	8021e8a <wc_Sha256Update+0x28>
 8021e80:	687b      	ldr	r3, [r7, #4]
 8021e82:	2b00      	cmp	r3, #0
 8021e84:	d101      	bne.n	8021e8a <wc_Sha256Update+0x28>
            /* valid, but do nothing */
            return 0;
 8021e86:	2300      	movs	r3, #0
 8021e88:	e00b      	b.n	8021ea2 <wc_Sha256Update+0x40>
        }
        if (data == NULL) {
 8021e8a:	68bb      	ldr	r3, [r7, #8]
 8021e8c:	2b00      	cmp	r3, #0
 8021e8e:	d102      	bne.n	8021e96 <wc_Sha256Update+0x34>
            return BAD_FUNC_ARG;
 8021e90:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8021e94:	e005      	b.n	8021ea2 <wc_Sha256Update+0x40>
            return IntelQaSymSha256(&sha256->asyncDev, NULL, data, len);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        return Sha256Update(sha256, data, len);
 8021e96:	687a      	ldr	r2, [r7, #4]
 8021e98:	68b9      	ldr	r1, [r7, #8]
 8021e9a:	68f8      	ldr	r0, [r7, #12]
 8021e9c:	f7ff ff58 	bl	8021d50 <Sha256Update>
 8021ea0:	4603      	mov	r3, r0
    }
 8021ea2:	4618      	mov	r0, r3
 8021ea4:	3710      	adds	r7, #16
 8021ea6:	46bd      	mov	sp, r7
 8021ea8:	bd80      	pop	{r7, pc}

08021eaa <Sha256Final>:
#endif

    static WC_INLINE int Sha256Final(wc_Sha256* sha256)
    {
 8021eaa:	b580      	push	{r7, lr}
 8021eac:	b084      	sub	sp, #16
 8021eae:	af00      	add	r7, sp, #0
 8021eb0:	6078      	str	r0, [r7, #4]
        int ret;
        byte* local;

        /* we'll add a 0x80 byte at the end,
        ** so make sure we have appropriate buffer length. */
        if (sha256->buffLen > WC_SHA256_BLOCK_SIZE - 1) {
 8021eb2:	687b      	ldr	r3, [r7, #4]
 8021eb4:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021eb6:	2b3f      	cmp	r3, #63	@ 0x3f
 8021eb8:	d902      	bls.n	8021ec0 <Sha256Final+0x16>
            /* exit with error code if there's a bad buffer size in buffLen */
            return BAD_STATE_E;
 8021eba:	f06f 03bf 	mvn.w	r3, #191	@ 0xbf
 8021ebe:	e06a      	b.n	8021f96 <Sha256Final+0xec>
        } /* buffLen check */

        local = (byte*)sha256->buffer;
 8021ec0:	687b      	ldr	r3, [r7, #4]
 8021ec2:	3320      	adds	r3, #32
 8021ec4:	60fb      	str	r3, [r7, #12]
        local[sha256->buffLen++] = 0x80; /* add 1 */
 8021ec6:	687b      	ldr	r3, [r7, #4]
 8021ec8:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021eca:	1c59      	adds	r1, r3, #1
 8021ecc:	687a      	ldr	r2, [r7, #4]
 8021ece:	6611      	str	r1, [r2, #96]	@ 0x60
 8021ed0:	68fa      	ldr	r2, [r7, #12]
 8021ed2:	4413      	add	r3, r2
 8021ed4:	2280      	movs	r2, #128	@ 0x80
 8021ed6:	701a      	strb	r2, [r3, #0]

        /* pad with zeros */
        if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
 8021ed8:	687b      	ldr	r3, [r7, #4]
 8021eda:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021edc:	2b38      	cmp	r3, #56	@ 0x38
 8021ede:	d925      	bls.n	8021f2c <Sha256Final+0x82>
            if (sha256->buffLen < WC_SHA256_BLOCK_SIZE) {
 8021ee0:	687b      	ldr	r3, [r7, #4]
 8021ee2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021ee4:	2b3f      	cmp	r3, #63	@ 0x3f
 8021ee6:	d80b      	bhi.n	8021f00 <Sha256Final+0x56>
                XMEMSET(&local[sha256->buffLen], 0,
 8021ee8:	687b      	ldr	r3, [r7, #4]
 8021eea:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021eec:	68fa      	ldr	r2, [r7, #12]
 8021eee:	18d0      	adds	r0, r2, r3
 8021ef0:	687b      	ldr	r3, [r7, #4]
 8021ef2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021ef4:	f1c3 0340 	rsb	r3, r3, #64	@ 0x40
 8021ef8:	461a      	mov	r2, r3
 8021efa:	2100      	movs	r1, #0
 8021efc:	f006 fae8 	bl	80284d0 <memset>
                esp_sha_try_hw_lock(&sha256->ctx);
            }
        #endif

        if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
            ByteReverseWords(sha256->buffer, sha256->buffer,
 8021f00:	687b      	ldr	r3, [r7, #4]
 8021f02:	f103 0020 	add.w	r0, r3, #32
 8021f06:	687b      	ldr	r3, [r7, #4]
 8021f08:	3320      	adds	r3, #32
 8021f0a:	2240      	movs	r2, #64	@ 0x40
 8021f0c:	4619      	mov	r1, r3
 8021f0e:	f7ff fad6 	bl	80214be <ByteReverseWords>
            }
            else {
                ret = esp_sha256_process(sha256, (const byte*)local);
            }
        #else
            ret = XTRANSFORM(sha256, (const byte*)local);
 8021f12:	68f9      	ldr	r1, [r7, #12]
 8021f14:	6878      	ldr	r0, [r7, #4]
 8021f16:	f7ff fb81 	bl	802161c <Transform_Sha256>
 8021f1a:	60b8      	str	r0, [r7, #8]
        #endif
            if (ret != 0)
 8021f1c:	68bb      	ldr	r3, [r7, #8]
 8021f1e:	2b00      	cmp	r3, #0
 8021f20:	d001      	beq.n	8021f26 <Sha256Final+0x7c>
                return ret;
 8021f22:	68bb      	ldr	r3, [r7, #8]
 8021f24:	e037      	b.n	8021f96 <Sha256Final+0xec>

            sha256->buffLen = 0;
 8021f26:	687b      	ldr	r3, [r7, #4]
 8021f28:	2200      	movs	r2, #0
 8021f2a:	661a      	str	r2, [r3, #96]	@ 0x60
        }
        XMEMSET(&local[sha256->buffLen], 0,
 8021f2c:	687b      	ldr	r3, [r7, #4]
 8021f2e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021f30:	68fa      	ldr	r2, [r7, #12]
 8021f32:	18d0      	adds	r0, r2, r3
 8021f34:	687b      	ldr	r3, [r7, #4]
 8021f36:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8021f38:	f1c3 0338 	rsb	r3, r3, #56	@ 0x38
 8021f3c:	461a      	mov	r2, r3
 8021f3e:	2100      	movs	r1, #0
 8021f40:	f006 fac6 	bl	80284d0 <memset>
            WC_SHA256_PAD_SIZE - sha256->buffLen);

        /* put 64 bit length in separate 32 bit parts */
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 8021f44:	687b      	ldr	r3, [r7, #4]
 8021f46:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021f48:	0f5a      	lsrs	r2, r3, #29
                                                         (sha256->hiLen << 3);
 8021f4a:	687b      	ldr	r3, [r7, #4]
 8021f4c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8021f4e:	00db      	lsls	r3, r3, #3
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
 8021f50:	441a      	add	r2, r3
 8021f52:	687b      	ldr	r3, [r7, #4]
 8021f54:	669a      	str	r2, [r3, #104]	@ 0x68
        sha256->loLen = sha256->loLen << 3;
 8021f56:	687b      	ldr	r3, [r7, #4]
 8021f58:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8021f5a:	00da      	lsls	r2, r3, #3
 8021f5c:	687b      	ldr	r3, [r7, #4]
 8021f5e:	665a      	str	r2, [r3, #100]	@ 0x64
        }
    #endif

        /* store lengths */
        if (SHA256_UPDATE_REV_BYTES(&sha256->ctx)) {
            ByteReverseWords(sha256->buffer, sha256->buffer,
 8021f60:	687b      	ldr	r3, [r7, #4]
 8021f62:	f103 0020 	add.w	r0, r3, #32
 8021f66:	687b      	ldr	r3, [r7, #4]
 8021f68:	3320      	adds	r3, #32
 8021f6a:	2238      	movs	r2, #56	@ 0x38
 8021f6c:	4619      	mov	r1, r3
 8021f6e:	f7ff faa6 	bl	80214be <ByteReverseWords>
                WC_SHA256_PAD_SIZE);
        }
        /* ! 64-bit length ordering dependent on digest endian type ! */
        XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
 8021f72:	68fb      	ldr	r3, [r7, #12]
 8021f74:	3338      	adds	r3, #56	@ 0x38
 8021f76:	687a      	ldr	r2, [r7, #4]
 8021f78:	3268      	adds	r2, #104	@ 0x68
 8021f7a:	6812      	ldr	r2, [r2, #0]
 8021f7c:	601a      	str	r2, [r3, #0]
        XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
 8021f7e:	68fb      	ldr	r3, [r7, #12]
 8021f80:	333c      	adds	r3, #60	@ 0x3c
 8021f82:	687a      	ldr	r2, [r7, #4]
 8021f84:	3264      	adds	r2, #100	@ 0x64
 8021f86:	6812      	ldr	r2, [r2, #0]
 8021f88:	601a      	str	r2, [r3, #0]
        }
        else {
            ret = esp_sha256_digest_process(sha256, 1);
        }
    #else
        ret = XTRANSFORM(sha256, (const byte*)local);
 8021f8a:	68f9      	ldr	r1, [r7, #12]
 8021f8c:	6878      	ldr	r0, [r7, #4]
 8021f8e:	f7ff fb45 	bl	802161c <Transform_Sha256>
 8021f92:	60b8      	str	r0, [r7, #8]
    #endif

        return ret;
 8021f94:	68bb      	ldr	r3, [r7, #8]
    }
 8021f96:	4618      	mov	r0, r3
 8021f98:	3710      	adds	r7, #16
 8021f9a:	46bd      	mov	sp, r7
 8021f9c:	bd80      	pop	{r7, pc}

08021f9e <wc_Sha256Final>:

        return 0;
    }

    int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
    {
 8021f9e:	b580      	push	{r7, lr}
 8021fa0:	b084      	sub	sp, #16
 8021fa2:	af00      	add	r7, sp, #0
 8021fa4:	6078      	str	r0, [r7, #4]
 8021fa6:	6039      	str	r1, [r7, #0]
        int ret;

        if (sha256 == NULL || hash == NULL) {
 8021fa8:	687b      	ldr	r3, [r7, #4]
 8021faa:	2b00      	cmp	r3, #0
 8021fac:	d002      	beq.n	8021fb4 <wc_Sha256Final+0x16>
 8021fae:	683b      	ldr	r3, [r7, #0]
 8021fb0:	2b00      	cmp	r3, #0
 8021fb2:	d102      	bne.n	8021fba <wc_Sha256Final+0x1c>
            return BAD_FUNC_ARG;
 8021fb4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8021fb8:	e018      	b.n	8021fec <wc_Sha256Final+0x4e>
                                            WC_SHA256_DIGEST_SIZE);
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Final(sha256);
 8021fba:	6878      	ldr	r0, [r7, #4]
 8021fbc:	f7ff ff75 	bl	8021eaa <Sha256Final>
 8021fc0:	60f8      	str	r0, [r7, #12]
        if (ret != 0) {
 8021fc2:	68fb      	ldr	r3, [r7, #12]
 8021fc4:	2b00      	cmp	r3, #0
 8021fc6:	d001      	beq.n	8021fcc <wc_Sha256Final+0x2e>
            return ret;
 8021fc8:	68fb      	ldr	r3, [r7, #12]
 8021fca:	e00f      	b.n	8021fec <wc_Sha256Final+0x4e>
        }

    #if defined(LITTLE_ENDIAN_ORDER)
        if (SHA256_REV_BYTES(&sha256->ctx)) {
            ByteReverseWords(sha256->digest, sha256->digest,
 8021fcc:	687b      	ldr	r3, [r7, #4]
 8021fce:	6879      	ldr	r1, [r7, #4]
 8021fd0:	2220      	movs	r2, #32
 8021fd2:	4618      	mov	r0, r3
 8021fd4:	f7ff fa73 	bl	80214be <ByteReverseWords>
                WC_SHA256_DIGEST_SIZE);
        }
    #endif
        XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
 8021fd8:	687b      	ldr	r3, [r7, #4]
 8021fda:	2220      	movs	r2, #32
 8021fdc:	4619      	mov	r1, r3
 8021fde:	6838      	ldr	r0, [r7, #0]
 8021fe0:	f006 fae0 	bl	80285a4 <memcpy>

        return InitSha256(sha256);  /* reset state */
 8021fe4:	6878      	ldr	r0, [r7, #4]
 8021fe6:	f7ff fab9 	bl	802155c <InitSha256>
 8021fea:	4603      	mov	r3, r0
    }
 8021fec:	4618      	mov	r0, r3
 8021fee:	3710      	adds	r7, #16
 8021ff0:	46bd      	mov	sp, r7
 8021ff2:	bd80      	pop	{r7, pc}

08021ff4 <wc_InitSha256>:
#endif /* !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH)  */
#endif /*  WOLFSSL_SHA224 */


int wc_InitSha256(wc_Sha256* sha256)
{
 8021ff4:	b580      	push	{r7, lr}
 8021ff6:	b084      	sub	sp, #16
 8021ff8:	af00      	add	r7, sp, #0
 8021ffa:	6078      	str	r0, [r7, #4]
    int devId = INVALID_DEVID;
 8021ffc:	f06f 0301 	mvn.w	r3, #1
 8022000:	60fb      	str	r3, [r7, #12]

#ifdef WOLF_CRYPTO_CB
    devId = wc_CryptoCb_DefaultDevID();
#endif
    return wc_InitSha256_ex(sha256, NULL, devId);
 8022002:	68fa      	ldr	r2, [r7, #12]
 8022004:	2100      	movs	r1, #0
 8022006:	6878      	ldr	r0, [r7, #4]
 8022008:	f7ff fae8 	bl	80215dc <wc_InitSha256_ex>
 802200c:	4603      	mov	r3, r0
}
 802200e:	4618      	mov	r0, r3
 8022010:	3710      	adds	r7, #16
 8022012:	46bd      	mov	sp, r7
 8022014:	bd80      	pop	{r7, pc}

08022016 <wc_Sha256Free>:

#if !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH)
    /* implemented in wolfcrypt/src/port/psa/psa_hash.c */

void wc_Sha256Free(wc_Sha256* sha256)
{
 8022016:	b580      	push	{r7, lr}
 8022018:	b082      	sub	sp, #8
 802201a:	af00      	add	r7, sp, #0
 802201c:	6078      	str	r0, [r7, #4]
    if (sha256 == NULL)
 802201e:	687b      	ldr	r3, [r7, #4]
 8022020:	2b00      	cmp	r3, #0
 8022022:	d004      	beq.n	802202e <wc_Sha256Free+0x18>
    }
    else {
        ESP_LOGV(TAG, "Hardware unlock not needed in wc_Sha256Free.");
    }
#endif
    ForceZero(sha256, sizeof(*sha256));
 8022024:	2170      	movs	r1, #112	@ 0x70
 8022026:	6878      	ldr	r0, [r7, #4]
 8022028:	f7ff fa6f 	bl	802150a <ForceZero>
 802202c:	e000      	b.n	8022030 <wc_Sha256Free+0x1a>
        return;
 802202e:	bf00      	nop
} /* wc_Sha256Free */
 8022030:	3708      	adds	r7, #8
 8022032:	46bd      	mov	sp, r7
 8022034:	bd80      	pop	{r7, pc}

08022036 <wc_SignatureGetSize>:
}
#endif /* !NO_RSA && !NO_ASN */

int wc_SignatureGetSize(enum wc_SignatureType sig_type,
    const void* key, word32 key_len)
{
 8022036:	b580      	push	{r7, lr}
 8022038:	b086      	sub	sp, #24
 802203a:	af00      	add	r7, sp, #0
 802203c:	4603      	mov	r3, r0
 802203e:	60b9      	str	r1, [r7, #8]
 8022040:	607a      	str	r2, [r7, #4]
 8022042:	73fb      	strb	r3, [r7, #15]
    int sig_len = WC_NO_ERR_TRACE(BAD_FUNC_ARG);
 8022044:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8022048:	617b      	str	r3, [r7, #20]

    /* Suppress possible unused args if all signature types are disabled */
    (void)key;
    (void)key_len;

    switch(sig_type) {
 802204a:	7bfb      	ldrb	r3, [r7, #15]
 802204c:	2b01      	cmp	r3, #1
 802204e:	d005      	beq.n	802205c <wc_SignatureGetSize+0x26>
 8022050:	2b00      	cmp	r3, #0
 8022052:	dd16      	ble.n	8022082 <wc_SignatureGetSize+0x4c>
 8022054:	3b02      	subs	r3, #2
 8022056:	2b01      	cmp	r3, #1
 8022058:	d813      	bhi.n	8022082 <wc_SignatureGetSize+0x4c>
 802205a:	e008      	b.n	802206e <wc_SignatureGetSize+0x38>
        case WC_SIGNATURE_TYPE_ECC:
#ifdef HAVE_ECC
            /* Sanity check that void* key is at least ecc_key in size */
            if (key_len >= sizeof(ecc_key)) {
 802205c:	687b      	ldr	r3, [r7, #4]
 802205e:	f5b3 7fb8 	cmp.w	r3, #368	@ 0x170
 8022062:	d312      	bcc.n	802208a <wc_SignatureGetSize+0x54>
                sig_len = wc_ecc_sig_size((ecc_key*)key);
 8022064:	68b8      	ldr	r0, [r7, #8]
 8022066:	f7fc f8f3 	bl	801e250 <wc_ecc_sig_size>
 802206a:	6178      	str	r0, [r7, #20]
                WOLFSSL_MSG("wc_SignatureGetSize: Invalid ECC key size");
            }
#else
            sig_len = SIG_TYPE_E;
#endif
            break;
 802206c:	e00d      	b.n	802208a <wc_SignatureGetSize+0x54>

        case WC_SIGNATURE_TYPE_RSA_W_ENC:
        case WC_SIGNATURE_TYPE_RSA:
#ifndef NO_RSA
            /* Sanity check that void* key is at least RsaKey in size */
            if (key_len >= sizeof(RsaKey)) {
 802206e:	687b      	ldr	r3, [r7, #4]
 8022070:	f241 127b 	movw	r2, #4475	@ 0x117b
 8022074:	4293      	cmp	r3, r2
 8022076:	d90a      	bls.n	802208e <wc_SignatureGetSize+0x58>
                sig_len = wc_RsaEncryptSize((RsaKey*)key);
 8022078:	68b8      	ldr	r0, [r7, #8]
 802207a:	f7ff f9b9 	bl	80213f0 <wc_RsaEncryptSize>
 802207e:	6178      	str	r0, [r7, #20]
                WOLFSSL_MSG("wc_SignatureGetSize: Invalid RsaKey key size");
            }
#else
            sig_len = SIG_TYPE_E;
#endif
            break;
 8022080:	e005      	b.n	802208e <wc_SignatureGetSize+0x58>

        case WC_SIGNATURE_TYPE_NONE:
        default:
            sig_len = BAD_FUNC_ARG;
 8022082:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8022086:	617b      	str	r3, [r7, #20]
            break;
 8022088:	e002      	b.n	8022090 <wc_SignatureGetSize+0x5a>
            break;
 802208a:	bf00      	nop
 802208c:	e000      	b.n	8022090 <wc_SignatureGetSize+0x5a>
            break;
 802208e:	bf00      	nop
    }
    return sig_len;
 8022090:	697b      	ldr	r3, [r7, #20]
}
 8022092:	4618      	mov	r0, r3
 8022094:	3718      	adds	r7, #24
 8022096:	46bd      	mov	sp, r7
 8022098:	bd80      	pop	{r7, pc}

0802209a <wc_SignatureVerifyHash>:
int wc_SignatureVerifyHash(
    enum wc_HashType hash_type, enum wc_SignatureType sig_type,
    const byte* hash_data, word32 hash_len,
    const byte* sig, word32 sig_len,
    const void* key, word32 key_len)
{
 802209a:	b580      	push	{r7, lr}
 802209c:	b08c      	sub	sp, #48	@ 0x30
 802209e:	af02      	add	r7, sp, #8
 80220a0:	60ba      	str	r2, [r7, #8]
 80220a2:	607b      	str	r3, [r7, #4]
 80220a4:	4603      	mov	r3, r0
 80220a6:	73fb      	strb	r3, [r7, #15]
 80220a8:	460b      	mov	r3, r1
 80220aa:	73bb      	strb	r3, [r7, #14]
    int ret;

    /* Check arguments */
    if (hash_data == NULL || hash_len == 0 ||
 80220ac:	68bb      	ldr	r3, [r7, #8]
 80220ae:	2b00      	cmp	r3, #0
 80220b0:	d00e      	beq.n	80220d0 <wc_SignatureVerifyHash+0x36>
 80220b2:	687b      	ldr	r3, [r7, #4]
 80220b4:	2b00      	cmp	r3, #0
 80220b6:	d00b      	beq.n	80220d0 <wc_SignatureVerifyHash+0x36>
 80220b8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80220ba:	2b00      	cmp	r3, #0
 80220bc:	d008      	beq.n	80220d0 <wc_SignatureVerifyHash+0x36>
        sig == NULL || sig_len == 0 ||
 80220be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80220c0:	2b00      	cmp	r3, #0
 80220c2:	d005      	beq.n	80220d0 <wc_SignatureVerifyHash+0x36>
 80220c4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80220c6:	2b00      	cmp	r3, #0
 80220c8:	d002      	beq.n	80220d0 <wc_SignatureVerifyHash+0x36>
        key == NULL || key_len == 0) {
 80220ca:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80220cc:	2b00      	cmp	r3, #0
 80220ce:	d102      	bne.n	80220d6 <wc_SignatureVerifyHash+0x3c>
        return BAD_FUNC_ARG;
 80220d0:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80220d4:	e098      	b.n	8022208 <wc_SignatureVerifyHash+0x16e>
    }

    /* Validate signature len (1 to max is okay) */
    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {
 80220d6:	7bbb      	ldrb	r3, [r7, #14]
 80220d8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80220da:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80220dc:	4618      	mov	r0, r3
 80220de:	f7ff ffaa 	bl	8022036 <wc_SignatureGetSize>
 80220e2:	4602      	mov	r2, r0
 80220e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80220e6:	429a      	cmp	r2, r3
 80220e8:	da02      	bge.n	80220f0 <wc_SignatureVerifyHash+0x56>
        WOLFSSL_MSG("wc_SignatureVerify: Invalid sig type/len");
        return BAD_FUNC_ARG;
 80220ea:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80220ee:	e08b      	b.n	8022208 <wc_SignatureVerifyHash+0x16e>
    }

    /* Validate hash size */
    ret = wc_HashGetDigestSize(hash_type);
 80220f0:	7bfb      	ldrb	r3, [r7, #15]
 80220f2:	4618      	mov	r0, r3
 80220f4:	f7fc f93c 	bl	801e370 <wc_HashGetDigestSize>
 80220f8:	6278      	str	r0, [r7, #36]	@ 0x24
    if (ret < 0) {
 80220fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80220fc:	2b00      	cmp	r3, #0
 80220fe:	da01      	bge.n	8022104 <wc_SignatureVerifyHash+0x6a>
        WOLFSSL_MSG("wc_SignatureVerify: Invalid hash type/len");
        return ret;
 8022100:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022102:	e081      	b.n	8022208 <wc_SignatureVerifyHash+0x16e>
    }
    ret = 0;
 8022104:	2300      	movs	r3, #0
 8022106:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Verify signature using hash */
    switch (sig_type) {
 8022108:	7bbb      	ldrb	r3, [r7, #14]
 802210a:	2b01      	cmp	r3, #1
 802210c:	d005      	beq.n	802211a <wc_SignatureVerifyHash+0x80>
 802210e:	2b00      	cmp	r3, #0
 8022110:	dd72      	ble.n	80221f8 <wc_SignatureVerifyHash+0x15e>
 8022112:	3b02      	subs	r3, #2
 8022114:	2b01      	cmp	r3, #1
 8022116:	d86f      	bhi.n	80221f8 <wc_SignatureVerifyHash+0x15e>
 8022118:	e01e      	b.n	8022158 <wc_SignatureVerifyHash+0xbe>
        case WC_SIGNATURE_TYPE_ECC:
        {
#if defined(HAVE_ECC) && defined(HAVE_ECC_VERIFY)
            int is_valid_sig = 0;
 802211a:	2300      	movs	r3, #0
 802211c:	617b      	str	r3, [r7, #20]
            do {
            #ifdef WOLFSSL_ASYNC_CRYPT
                ret = wc_AsyncWait(ret, &((ecc_key*)key)->asyncDev,
                    WC_ASYNC_FLAG_CALL_AGAIN);
            #endif
            if (ret >= 0)
 802211e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022120:	2b00      	cmp	r3, #0
 8022122:	db0b      	blt.n	802213c <wc_SignatureVerifyHash+0xa2>
                ret = wc_ecc_verify_hash(sig, sig_len, hash_data, hash_len,
 8022124:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022126:	9301      	str	r3, [sp, #4]
 8022128:	f107 0314 	add.w	r3, r7, #20
 802212c:	9300      	str	r3, [sp, #0]
 802212e:	687b      	ldr	r3, [r7, #4]
 8022130:	68ba      	ldr	r2, [r7, #8]
 8022132:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8022134:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8022136:	f7fb fb87 	bl	801d848 <wc_ecc_verify_hash>
 802213a:	6278      	str	r0, [r7, #36]	@ 0x24
                    &is_valid_sig, (ecc_key*)key);
            } while (ret == WC_NO_ERR_TRACE(WC_PENDING_E));
 802213c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802213e:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 8022142:	d0ec      	beq.n	802211e <wc_SignatureVerifyHash+0x84>
            if (ret != 0 || is_valid_sig != 1) {
 8022144:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022146:	2b00      	cmp	r3, #0
 8022148:	d102      	bne.n	8022150 <wc_SignatureVerifyHash+0xb6>
 802214a:	697b      	ldr	r3, [r7, #20]
 802214c:	2b01      	cmp	r3, #1
 802214e:	d057      	beq.n	8022200 <wc_SignatureVerifyHash+0x166>
                ret = SIG_VERIFY_E;
 8022150:	f06f 03e4 	mvn.w	r3, #228	@ 0xe4
 8022154:	627b      	str	r3, [r7, #36]	@ 0x24
            }
#else
            ret = SIG_TYPE_E;
#endif
            break;
 8022156:	e053      	b.n	8022200 <wc_SignatureVerifyHash+0x166>
        if (ret != 0) {
            ret = SIG_VERIFY_E;
        }
    #else

            word32 plain_len = hash_len;
 8022158:	687b      	ldr	r3, [r7, #4]
 802215a:	623b      	str	r3, [r7, #32]
        #else
            ALIGN64 byte plain_data[MAX_ENCODED_SIG_SZ];
        #endif

            /* Make sure the plain text output is at least key size */
            if (plain_len < sig_len) {
 802215c:	6a3a      	ldr	r2, [r7, #32]
 802215e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022160:	429a      	cmp	r2, r3
 8022162:	d201      	bcs.n	8022168 <wc_SignatureVerifyHash+0xce>
                plain_len = sig_len;
 8022164:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022166:	623b      	str	r3, [r7, #32]
            }
        #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
            plain_data = (byte*)XMALLOC(plain_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8022168:	6a38      	ldr	r0, [r7, #32]
 802216a:	f7fc fc93 	bl	801ea94 <wolfSSL_Malloc>
 802216e:	61f8      	str	r0, [r7, #28]
            if (plain_data)
 8022170:	69fb      	ldr	r3, [r7, #28]
 8022172:	2b00      	cmp	r3, #0
 8022174:	d03c      	beq.n	80221f0 <wc_SignatureVerifyHash+0x156>
        #else
            if (plain_len <= sizeof(plain_data))
        #endif
            {
                byte* plain_ptr = NULL;
 8022176:	2300      	movs	r3, #0
 8022178:	613b      	str	r3, [r7, #16]
                XMEMSET(plain_data, 0, plain_len);
 802217a:	6a3a      	ldr	r2, [r7, #32]
 802217c:	2100      	movs	r1, #0
 802217e:	69f8      	ldr	r0, [r7, #28]
 8022180:	f006 f9a6 	bl	80284d0 <memset>
                XMEMCPY(plain_data, sig, sig_len);
 8022184:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8022186:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8022188:	69f8      	ldr	r0, [r7, #28]
 802218a:	f006 fa0b 	bl	80285a4 <memcpy>
                do {
                #ifdef WOLFSSL_ASYNC_CRYPT
                    ret = wc_AsyncWait(ret, &((RsaKey*)key)->asyncDev,
                        WC_ASYNC_FLAG_CALL_AGAIN);
                #endif
                if (ret >= 0)
 802218e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022190:	2b00      	cmp	r3, #0
 8022192:	db07      	blt.n	80221a4 <wc_SignatureVerifyHash+0x10a>
                        ret = wc_RsaSSL_VerifyInline(plain_data, sig_len,
 8022194:	f107 0210 	add.w	r2, r7, #16
 8022198:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802219a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 802219c:	69f8      	ldr	r0, [r7, #28]
 802219e:	f7ff f832 	bl	8021206 <wc_RsaSSL_VerifyInline>
 80221a2:	6278      	str	r0, [r7, #36]	@ 0x24
                            &plain_ptr, (RsaKey*)key);
                } while (ret == WC_NO_ERR_TRACE(WC_PENDING_E));
 80221a4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80221a6:	f113 0f6c 	cmn.w	r3, #108	@ 0x6c
 80221aa:	d0f0      	beq.n	802218e <wc_SignatureVerifyHash+0xf4>
                if (ret >= 0 && plain_ptr) {
 80221ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80221ae:	2b00      	cmp	r3, #0
 80221b0:	db15      	blt.n	80221de <wc_SignatureVerifyHash+0x144>
 80221b2:	693b      	ldr	r3, [r7, #16]
 80221b4:	2b00      	cmp	r3, #0
 80221b6:	d012      	beq.n	80221de <wc_SignatureVerifyHash+0x144>
                    if ((word32)ret == hash_len &&
 80221b8:	687b      	ldr	r3, [r7, #4]
 80221ba:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80221bc:	429a      	cmp	r2, r3
 80221be:	d10b      	bne.n	80221d8 <wc_SignatureVerifyHash+0x13e>
                            XMEMCMP(plain_ptr, hash_data, hash_len) == 0) {
 80221c0:	693b      	ldr	r3, [r7, #16]
 80221c2:	687a      	ldr	r2, [r7, #4]
 80221c4:	68b9      	ldr	r1, [r7, #8]
 80221c6:	4618      	mov	r0, r3
 80221c8:	f006 f958 	bl	802847c <memcmp>
 80221cc:	4603      	mov	r3, r0
                    if ((word32)ret == hash_len &&
 80221ce:	2b00      	cmp	r3, #0
 80221d0:	d102      	bne.n	80221d8 <wc_SignatureVerifyHash+0x13e>
                        ret = 0; /* Success */
 80221d2:	2300      	movs	r3, #0
 80221d4:	627b      	str	r3, [r7, #36]	@ 0x24
 80221d6:	e002      	b.n	80221de <wc_SignatureVerifyHash+0x144>
                    }
                    else {
                        ret = SIG_VERIFY_E;
 80221d8:	f06f 03e4 	mvn.w	r3, #228	@ 0xe4
 80221dc:	627b      	str	r3, [r7, #36]	@ 0x24
                    }
                }
            #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
                XFREE(plain_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80221de:	69fb      	ldr	r3, [r7, #28]
 80221e0:	61bb      	str	r3, [r7, #24]
 80221e2:	69bb      	ldr	r3, [r7, #24]
 80221e4:	2b00      	cmp	r3, #0
 80221e6:	d00d      	beq.n	8022204 <wc_SignatureVerifyHash+0x16a>
 80221e8:	69b8      	ldr	r0, [r7, #24]
 80221ea:	f7fc fc6f 	bl	801eacc <wolfSSL_Free>
                WOLFSSL_MSG("RSA Signature Verify failed!");
            }
#else
            ret = SIG_TYPE_E;
#endif
            break;
 80221ee:	e009      	b.n	8022204 <wc_SignatureVerifyHash+0x16a>
                ret = MEMORY_E;
 80221f0:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 80221f4:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 80221f6:	e005      	b.n	8022204 <wc_SignatureVerifyHash+0x16a>
        }

        case WC_SIGNATURE_TYPE_NONE:
        default:
            ret = BAD_FUNC_ARG;
 80221f8:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80221fc:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 80221fe:	e002      	b.n	8022206 <wc_SignatureVerifyHash+0x16c>
            break;
 8022200:	bf00      	nop
 8022202:	e000      	b.n	8022206 <wc_SignatureVerifyHash+0x16c>
            break;
 8022204:	bf00      	nop
    }

    return ret;
 8022206:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8022208:	4618      	mov	r0, r3
 802220a:	3728      	adds	r7, #40	@ 0x28
 802220c:	46bd      	mov	sp, r7
 802220e:	bd80      	pop	{r7, pc}

08022210 <ForceZero>:
{
 8022210:	b480      	push	{r7}
 8022212:	b085      	sub	sp, #20
 8022214:	af00      	add	r7, sp, #0
 8022216:	6078      	str	r0, [r7, #4]
 8022218:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 802221a:	687b      	ldr	r3, [r7, #4]
 802221c:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 802221e:	e004      	b.n	802222a <ForceZero+0x1a>
 8022220:	68fb      	ldr	r3, [r7, #12]
 8022222:	1c5a      	adds	r2, r3, #1
 8022224:	60fa      	str	r2, [r7, #12]
 8022226:	2200      	movs	r2, #0
 8022228:	701a      	strb	r2, [r3, #0]
 802222a:	683b      	ldr	r3, [r7, #0]
 802222c:	1e5a      	subs	r2, r3, #1
 802222e:	603a      	str	r2, [r7, #0]
 8022230:	2b00      	cmp	r3, #0
 8022232:	d1f5      	bne.n	8022220 <ForceZero+0x10>
}
 8022234:	bf00      	nop
 8022236:	bf00      	nop
 8022238:	3714      	adds	r7, #20
 802223a:	46bd      	mov	sp, r7
 802223c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022240:	4770      	bx	lr

08022242 <HexCharToByte>:
{
 8022242:	b480      	push	{r7}
 8022244:	b085      	sub	sp, #20
 8022246:	af00      	add	r7, sp, #0
 8022248:	4603      	mov	r3, r0
 802224a:	71fb      	strb	r3, [r7, #7]
    signed char ret = (signed char)ch;
 802224c:	79fb      	ldrb	r3, [r7, #7]
 802224e:	73fb      	strb	r3, [r7, #15]
    if (ret >= '0' && ret <= '9')
 8022250:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8022254:	2b2f      	cmp	r3, #47	@ 0x2f
 8022256:	dd08      	ble.n	802226a <HexCharToByte+0x28>
 8022258:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802225c:	2b39      	cmp	r3, #57	@ 0x39
 802225e:	dc04      	bgt.n	802226a <HexCharToByte+0x28>
        ret = (signed char)(ret - '0');
 8022260:	7bfb      	ldrb	r3, [r7, #15]
 8022262:	3b30      	subs	r3, #48	@ 0x30
 8022264:	b2db      	uxtb	r3, r3
 8022266:	73fb      	strb	r3, [r7, #15]
 8022268:	e01b      	b.n	80222a2 <HexCharToByte+0x60>
    else if (ret >= 'A' && ret <= 'F')
 802226a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802226e:	2b40      	cmp	r3, #64	@ 0x40
 8022270:	dd08      	ble.n	8022284 <HexCharToByte+0x42>
 8022272:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8022276:	2b46      	cmp	r3, #70	@ 0x46
 8022278:	dc04      	bgt.n	8022284 <HexCharToByte+0x42>
        ret = (signed char)(ret - ('A' - 10));
 802227a:	7bfb      	ldrb	r3, [r7, #15]
 802227c:	3b37      	subs	r3, #55	@ 0x37
 802227e:	b2db      	uxtb	r3, r3
 8022280:	73fb      	strb	r3, [r7, #15]
 8022282:	e00e      	b.n	80222a2 <HexCharToByte+0x60>
    else if (ret >= 'a' && ret <= 'f')
 8022284:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8022288:	2b60      	cmp	r3, #96	@ 0x60
 802228a:	dd08      	ble.n	802229e <HexCharToByte+0x5c>
 802228c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8022290:	2b66      	cmp	r3, #102	@ 0x66
 8022292:	dc04      	bgt.n	802229e <HexCharToByte+0x5c>
        ret = (signed char)(ret - ('a' - 10));
 8022294:	7bfb      	ldrb	r3, [r7, #15]
 8022296:	3b57      	subs	r3, #87	@ 0x57
 8022298:	b2db      	uxtb	r3, r3
 802229a:	73fb      	strb	r3, [r7, #15]
 802229c:	e001      	b.n	80222a2 <HexCharToByte+0x60>
        ret = -1; /* error case - return code must be signed */
 802229e:	23ff      	movs	r3, #255	@ 0xff
 80222a0:	73fb      	strb	r3, [r7, #15]
    return ret;
 80222a2:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 80222a6:	4618      	mov	r0, r3
 80222a8:	3714      	adds	r7, #20
 80222aa:	46bd      	mov	sp, r7
 80222ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80222b0:	4770      	bx	lr

080222b2 <CharIsWhiteSpace>:
{
 80222b2:	b480      	push	{r7}
 80222b4:	b083      	sub	sp, #12
 80222b6:	af00      	add	r7, sp, #0
 80222b8:	4603      	mov	r3, r0
 80222ba:	71fb      	strb	r3, [r7, #7]
    switch (ch) {
 80222bc:	79fb      	ldrb	r3, [r7, #7]
 80222be:	2b0a      	cmp	r3, #10
 80222c0:	dc02      	bgt.n	80222c8 <CharIsWhiteSpace+0x16>
 80222c2:	2b09      	cmp	r3, #9
 80222c4:	da02      	bge.n	80222cc <CharIsWhiteSpace+0x1a>
 80222c6:	e003      	b.n	80222d0 <CharIsWhiteSpace+0x1e>
 80222c8:	2b20      	cmp	r3, #32
 80222ca:	d101      	bne.n	80222d0 <CharIsWhiteSpace+0x1e>
            return 1;
 80222cc:	2301      	movs	r3, #1
 80222ce:	e000      	b.n	80222d2 <CharIsWhiteSpace+0x20>
            return 0;
 80222d0:	2300      	movs	r3, #0
}
 80222d2:	4618      	mov	r0, r3
 80222d4:	370c      	adds	r7, #12
 80222d6:	46bd      	mov	sp, r7
 80222d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80222dc:	4770      	bx	lr

080222de <fp_add>:


/* Functions */

int fp_add(fp_int *a, fp_int *b, fp_int *c)
{
 80222de:	b580      	push	{r7, lr}
 80222e0:	b088      	sub	sp, #32
 80222e2:	af00      	add	r7, sp, #0
 80222e4:	60f8      	str	r0, [r7, #12]
 80222e6:	60b9      	str	r1, [r7, #8]
 80222e8:	607a      	str	r2, [r7, #4]
  int sa, sb;
  int ret = FP_OKAY;
 80222ea:	2300      	movs	r3, #0
 80222ec:	61fb      	str	r3, [r7, #28]

  /* get sign of both inputs */
  sa = a->sign;
 80222ee:	68fb      	ldr	r3, [r7, #12]
 80222f0:	685b      	ldr	r3, [r3, #4]
 80222f2:	61bb      	str	r3, [r7, #24]
  sb = b->sign;
 80222f4:	68bb      	ldr	r3, [r7, #8]
 80222f6:	685b      	ldr	r3, [r3, #4]
 80222f8:	617b      	str	r3, [r7, #20]

  /* handle two cases, not four */
  if (sa == sb) {
 80222fa:	69ba      	ldr	r2, [r7, #24]
 80222fc:	697b      	ldr	r3, [r7, #20]
 80222fe:	429a      	cmp	r2, r3
 8022300:	d109      	bne.n	8022316 <fp_add+0x38>
    /* both positive or both negative */
    /* add their magnitudes, copy the sign */
    c->sign = sa;
 8022302:	687b      	ldr	r3, [r7, #4]
 8022304:	69ba      	ldr	r2, [r7, #24]
 8022306:	605a      	str	r2, [r3, #4]
    ret = s_fp_add (a, b, c);
 8022308:	687a      	ldr	r2, [r7, #4]
 802230a:	68b9      	ldr	r1, [r7, #8]
 802230c:	68f8      	ldr	r0, [r7, #12]
 802230e:	f000 f820 	bl	8022352 <s_fp_add>
 8022312:	61f8      	str	r0, [r7, #28]
 8022314:	e018      	b.n	8022348 <fp_add+0x6a>
  } else {
    /* one positive, the other negative */
    /* subtract the one with the greater magnitude from */
    /* the one of the lesser magnitude.  The result gets */
    /* the sign of the one with the greater magnitude. */
    if (fp_cmp_mag (a, b) == FP_LT) {
 8022316:	68b9      	ldr	r1, [r7, #8]
 8022318:	68f8      	ldr	r0, [r7, #12]
 802231a:	f003 fc1a 	bl	8025b52 <fp_cmp_mag>
 802231e:	4603      	mov	r3, r0
 8022320:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8022324:	d108      	bne.n	8022338 <fp_add+0x5a>
      c->sign = sb;
 8022326:	687b      	ldr	r3, [r7, #4]
 8022328:	697a      	ldr	r2, [r7, #20]
 802232a:	605a      	str	r2, [r3, #4]
      s_fp_sub (b, a, c);
 802232c:	687a      	ldr	r2, [r7, #4]
 802232e:	68f9      	ldr	r1, [r7, #12]
 8022330:	68b8      	ldr	r0, [r7, #8]
 8022332:	f000 f8f6 	bl	8022522 <s_fp_sub>
 8022336:	e007      	b.n	8022348 <fp_add+0x6a>
    } else {
      c->sign = sa;
 8022338:	687b      	ldr	r3, [r7, #4]
 802233a:	69ba      	ldr	r2, [r7, #24]
 802233c:	605a      	str	r2, [r3, #4]
      s_fp_sub (a, b, c);
 802233e:	687a      	ldr	r2, [r7, #4]
 8022340:	68b9      	ldr	r1, [r7, #8]
 8022342:	68f8      	ldr	r0, [r7, #12]
 8022344:	f000 f8ed 	bl	8022522 <s_fp_sub>
    }
  }

  return ret;
 8022348:	69fb      	ldr	r3, [r7, #28]
}
 802234a:	4618      	mov	r0, r3
 802234c:	3720      	adds	r7, #32
 802234e:	46bd      	mov	sp, r7
 8022350:	bd80      	pop	{r7, pc}

08022352 <s_fp_add>:

/* unsigned addition */
int s_fp_add(fp_int *a, fp_int *b, fp_int *c)
{
 8022352:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022356:	b08d      	sub	sp, #52	@ 0x34
 8022358:	af00      	add	r7, sp, #0
 802235a:	6178      	str	r0, [r7, #20]
 802235c:	6139      	str	r1, [r7, #16]
 802235e:	60fa      	str	r2, [r7, #12]
  int      x, y, oldused;
  fp_word  t;

  y       = MAX(a->used, b->used);
 8022360:	693b      	ldr	r3, [r7, #16]
 8022362:	681a      	ldr	r2, [r3, #0]
 8022364:	697b      	ldr	r3, [r7, #20]
 8022366:	681b      	ldr	r3, [r3, #0]
 8022368:	4293      	cmp	r3, r2
 802236a:	bfb8      	it	lt
 802236c:	4613      	movlt	r3, r2
 802236e:	61fb      	str	r3, [r7, #28]
  oldused = MIN(c->used, FP_SIZE);   /* help static analysis w/ largest size */
 8022370:	68fb      	ldr	r3, [r7, #12]
 8022372:	681b      	ldr	r3, [r3, #0]
 8022374:	2b88      	cmp	r3, #136	@ 0x88
 8022376:	bfa8      	it	ge
 8022378:	2388      	movge	r3, #136	@ 0x88
 802237a:	61bb      	str	r3, [r7, #24]
  c->used = y;
 802237c:	68fb      	ldr	r3, [r7, #12]
 802237e:	69fa      	ldr	r2, [r7, #28]
 8022380:	601a      	str	r2, [r3, #0]

  t = 0;
 8022382:	f04f 0200 	mov.w	r2, #0
 8022386:	f04f 0300 	mov.w	r3, #0
 802238a:	e9c7 2308 	strd	r2, r3, [r7, #32]
      t        >>= DIGIT_BIT;
  }

#else
  /* the original code */
  for (x = 0; x < y; x++) {
 802238e:	2300      	movs	r3, #0
 8022390:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8022392:	e033      	b.n	80223fc <s_fp_add+0xaa>
      t         += ((fp_word)a->dp[x]) + ((fp_word)b->dp[x]);
 8022394:	697a      	ldr	r2, [r7, #20]
 8022396:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022398:	3302      	adds	r3, #2
 802239a:	009b      	lsls	r3, r3, #2
 802239c:	4413      	add	r3, r2
 802239e:	685b      	ldr	r3, [r3, #4]
 80223a0:	2200      	movs	r2, #0
 80223a2:	4698      	mov	r8, r3
 80223a4:	4691      	mov	r9, r2
 80223a6:	693a      	ldr	r2, [r7, #16]
 80223a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80223aa:	3302      	adds	r3, #2
 80223ac:	009b      	lsls	r3, r3, #2
 80223ae:	4413      	add	r3, r2
 80223b0:	685b      	ldr	r3, [r3, #4]
 80223b2:	2200      	movs	r2, #0
 80223b4:	469a      	mov	sl, r3
 80223b6:	4693      	mov	fp, r2
 80223b8:	eb18 040a 	adds.w	r4, r8, sl
 80223bc:	eb49 050b 	adc.w	r5, r9, fp
 80223c0:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80223c4:	1911      	adds	r1, r2, r4
 80223c6:	6039      	str	r1, [r7, #0]
 80223c8:	416b      	adcs	r3, r5
 80223ca:	607b      	str	r3, [r7, #4]
 80223cc:	e9d7 2300 	ldrd	r2, r3, [r7]
 80223d0:	e9c7 2308 	strd	r2, r3, [r7, #32]
      c->dp[x]   = (fp_digit)t;
 80223d4:	6a3a      	ldr	r2, [r7, #32]
 80223d6:	68f9      	ldr	r1, [r7, #12]
 80223d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80223da:	3302      	adds	r3, #2
 80223dc:	009b      	lsls	r3, r3, #2
 80223de:	440b      	add	r3, r1
 80223e0:	605a      	str	r2, [r3, #4]
      t        >>= DIGIT_BIT;
 80223e2:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 80223e6:	f04f 0200 	mov.w	r2, #0
 80223ea:	f04f 0300 	mov.w	r3, #0
 80223ee:	000a      	movs	r2, r1
 80223f0:	2300      	movs	r3, #0
 80223f2:	e9c7 2308 	strd	r2, r3, [r7, #32]
  for (x = 0; x < y; x++) {
 80223f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80223f8:	3301      	adds	r3, #1
 80223fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80223fc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80223fe:	69fb      	ldr	r3, [r7, #28]
 8022400:	429a      	cmp	r2, r3
 8022402:	dbc7      	blt.n	8022394 <s_fp_add+0x42>
  }
#endif /* HONOR_MATH_USED_LENGTH */

  if (t != 0) {
 8022404:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8022408:	4313      	orrs	r3, r2
 802240a:	d013      	beq.n	8022434 <s_fp_add+0xe2>
     if (x == FP_SIZE)
 802240c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802240e:	2b88      	cmp	r3, #136	@ 0x88
 8022410:	d102      	bne.n	8022418 <s_fp_add+0xc6>
         return FP_VAL;
 8022412:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022416:	e03e      	b.n	8022496 <s_fp_add+0x144>
     c->dp[c->used++] = (fp_digit)t;
 8022418:	68fb      	ldr	r3, [r7, #12]
 802241a:	681b      	ldr	r3, [r3, #0]
 802241c:	1c59      	adds	r1, r3, #1
 802241e:	68fa      	ldr	r2, [r7, #12]
 8022420:	6011      	str	r1, [r2, #0]
 8022422:	6a3a      	ldr	r2, [r7, #32]
 8022424:	68f9      	ldr	r1, [r7, #12]
 8022426:	3302      	adds	r3, #2
 8022428:	009b      	lsls	r3, r3, #2
 802242a:	440b      	add	r3, r1
 802242c:	605a      	str	r2, [r3, #4]
     ++x;
 802242e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022430:	3301      	adds	r3, #1
 8022432:	62fb      	str	r3, [r7, #44]	@ 0x2c
  }

  c->used = x;
 8022434:	68fb      	ldr	r3, [r7, #12]
 8022436:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8022438:	601a      	str	r2, [r3, #0]

  /* zero any excess digits on the destination that we didn't write to */
  for (; x < oldused; x++) {
 802243a:	e009      	b.n	8022450 <s_fp_add+0xfe>
     c->dp[x] = 0;
 802243c:	68fa      	ldr	r2, [r7, #12]
 802243e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022440:	3302      	adds	r3, #2
 8022442:	009b      	lsls	r3, r3, #2
 8022444:	4413      	add	r3, r2
 8022446:	2200      	movs	r2, #0
 8022448:	605a      	str	r2, [r3, #4]
  for (; x < oldused; x++) {
 802244a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802244c:	3301      	adds	r3, #1
 802244e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8022450:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8022452:	69bb      	ldr	r3, [r7, #24]
 8022454:	429a      	cmp	r2, r3
 8022456:	dbf1      	blt.n	802243c <s_fp_add+0xea>
  }
  fp_clamp(c);
 8022458:	e004      	b.n	8022464 <s_fp_add+0x112>
 802245a:	68fb      	ldr	r3, [r7, #12]
 802245c:	681b      	ldr	r3, [r3, #0]
 802245e:	1e5a      	subs	r2, r3, #1
 8022460:	68fb      	ldr	r3, [r7, #12]
 8022462:	601a      	str	r2, [r3, #0]
 8022464:	68fb      	ldr	r3, [r7, #12]
 8022466:	681b      	ldr	r3, [r3, #0]
 8022468:	2b00      	cmp	r3, #0
 802246a:	d009      	beq.n	8022480 <s_fp_add+0x12e>
 802246c:	68fb      	ldr	r3, [r7, #12]
 802246e:	681b      	ldr	r3, [r3, #0]
 8022470:	3b01      	subs	r3, #1
 8022472:	68fa      	ldr	r2, [r7, #12]
 8022474:	3302      	adds	r3, #2
 8022476:	009b      	lsls	r3, r3, #2
 8022478:	4413      	add	r3, r2
 802247a:	685b      	ldr	r3, [r3, #4]
 802247c:	2b00      	cmp	r3, #0
 802247e:	d0ec      	beq.n	802245a <s_fp_add+0x108>
 8022480:	68fb      	ldr	r3, [r7, #12]
 8022482:	681b      	ldr	r3, [r3, #0]
 8022484:	2b00      	cmp	r3, #0
 8022486:	d002      	beq.n	802248e <s_fp_add+0x13c>
 8022488:	68fb      	ldr	r3, [r7, #12]
 802248a:	685b      	ldr	r3, [r3, #4]
 802248c:	e000      	b.n	8022490 <s_fp_add+0x13e>
 802248e:	2300      	movs	r3, #0
 8022490:	68fa      	ldr	r2, [r7, #12]
 8022492:	6053      	str	r3, [r2, #4]
  return FP_OKAY;
 8022494:	2300      	movs	r3, #0
}
 8022496:	4618      	mov	r0, r3
 8022498:	3734      	adds	r7, #52	@ 0x34
 802249a:	46bd      	mov	sp, r7
 802249c:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80224a0:	4770      	bx	lr

080224a2 <fp_sub>:

/* c = a - b */
int fp_sub(fp_int *a, fp_int *b, fp_int *c)
{
 80224a2:	b580      	push	{r7, lr}
 80224a4:	b088      	sub	sp, #32
 80224a6:	af00      	add	r7, sp, #0
 80224a8:	60f8      	str	r0, [r7, #12]
 80224aa:	60b9      	str	r1, [r7, #8]
 80224ac:	607a      	str	r2, [r7, #4]
  int sa, sb;
  int ret = FP_OKAY;
 80224ae:	2300      	movs	r3, #0
 80224b0:	61fb      	str	r3, [r7, #28]

  sa = a->sign;
 80224b2:	68fb      	ldr	r3, [r7, #12]
 80224b4:	685b      	ldr	r3, [r3, #4]
 80224b6:	61bb      	str	r3, [r7, #24]
  sb = b->sign;
 80224b8:	68bb      	ldr	r3, [r7, #8]
 80224ba:	685b      	ldr	r3, [r3, #4]
 80224bc:	617b      	str	r3, [r7, #20]

  if (sa != sb) {
 80224be:	69ba      	ldr	r2, [r7, #24]
 80224c0:	697b      	ldr	r3, [r7, #20]
 80224c2:	429a      	cmp	r2, r3
 80224c4:	d009      	beq.n	80224da <fp_sub+0x38>
    /* subtract a negative from a positive, OR */
    /* subtract a positive from a negative. */
    /* In either case, ADD their magnitudes, */
    /* and use the sign of the first number. */
    c->sign = sa;
 80224c6:	687b      	ldr	r3, [r7, #4]
 80224c8:	69ba      	ldr	r2, [r7, #24]
 80224ca:	605a      	str	r2, [r3, #4]
    ret = s_fp_add (a, b, c);
 80224cc:	687a      	ldr	r2, [r7, #4]
 80224ce:	68b9      	ldr	r1, [r7, #8]
 80224d0:	68f8      	ldr	r0, [r7, #12]
 80224d2:	f7ff ff3e 	bl	8022352 <s_fp_add>
 80224d6:	61f8      	str	r0, [r7, #28]
 80224d8:	e01e      	b.n	8022518 <fp_sub+0x76>
  } else {
    /* subtract a positive from a positive, OR */
    /* subtract a negative from a negative. */
    /* First, take the difference between their */
    /* magnitudes, then... */
    if (fp_cmp_mag (a, b) != FP_LT) {
 80224da:	68b9      	ldr	r1, [r7, #8]
 80224dc:	68f8      	ldr	r0, [r7, #12]
 80224de:	f003 fb38 	bl	8025b52 <fp_cmp_mag>
 80224e2:	4603      	mov	r3, r0
 80224e4:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80224e8:	d008      	beq.n	80224fc <fp_sub+0x5a>
      /* Copy the sign from the first */
      c->sign = sa;
 80224ea:	687b      	ldr	r3, [r7, #4]
 80224ec:	69ba      	ldr	r2, [r7, #24]
 80224ee:	605a      	str	r2, [r3, #4]
      /* The first has a larger or equal magnitude */
      s_fp_sub (a, b, c);
 80224f0:	687a      	ldr	r2, [r7, #4]
 80224f2:	68b9      	ldr	r1, [r7, #8]
 80224f4:	68f8      	ldr	r0, [r7, #12]
 80224f6:	f000 f814 	bl	8022522 <s_fp_sub>
 80224fa:	e00d      	b.n	8022518 <fp_sub+0x76>
    } else {
      /* The result has the *opposite* sign from */
      /* the first number. */
      c->sign = (sa == FP_ZPOS) ? FP_NEG : FP_ZPOS;
 80224fc:	69bb      	ldr	r3, [r7, #24]
 80224fe:	2b00      	cmp	r3, #0
 8022500:	bf0c      	ite	eq
 8022502:	2301      	moveq	r3, #1
 8022504:	2300      	movne	r3, #0
 8022506:	b2db      	uxtb	r3, r3
 8022508:	461a      	mov	r2, r3
 802250a:	687b      	ldr	r3, [r7, #4]
 802250c:	605a      	str	r2, [r3, #4]
      /* The second has a larger magnitude */
      s_fp_sub (b, a, c);
 802250e:	687a      	ldr	r2, [r7, #4]
 8022510:	68f9      	ldr	r1, [r7, #12]
 8022512:	68b8      	ldr	r0, [r7, #8]
 8022514:	f000 f805 	bl	8022522 <s_fp_sub>
    }
  }
  return ret;
 8022518:	69fb      	ldr	r3, [r7, #28]
}
 802251a:	4618      	mov	r0, r3
 802251c:	3720      	adds	r7, #32
 802251e:	46bd      	mov	sp, r7
 8022520:	bd80      	pop	{r7, pc}

08022522 <s_fp_sub>:

/* unsigned subtraction ||a|| >= ||b|| ALWAYS! */
void s_fp_sub(fp_int *a, fp_int *b, fp_int *c)
{
 8022522:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022526:	b095      	sub	sp, #84	@ 0x54
 8022528:	af00      	add	r7, sp, #0
 802252a:	6378      	str	r0, [r7, #52]	@ 0x34
 802252c:	6339      	str	r1, [r7, #48]	@ 0x30
 802252e:	62fa      	str	r2, [r7, #44]	@ 0x2c
  int      x, oldbused, oldused;
  fp_word  t;

  oldused  = c->used;
 8022530:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022532:	681b      	ldr	r3, [r3, #0]
 8022534:	63fb      	str	r3, [r7, #60]	@ 0x3c
  oldbused = b->used;
 8022536:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022538:	681b      	ldr	r3, [r3, #0]
 802253a:	63bb      	str	r3, [r7, #56]	@ 0x38
  c->used  = a->used;
 802253c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802253e:	681a      	ldr	r2, [r3, #0]
 8022540:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022542:	601a      	str	r2, [r3, #0]
  t       = 0;
 8022544:	f04f 0200 	mov.w	r2, #0
 8022548:	f04f 0300 	mov.w	r3, #0
 802254c:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
  for (x = 0; x < oldbused; x++) {
 8022550:	2300      	movs	r3, #0
 8022552:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8022554:	e040      	b.n	80225d8 <s_fp_sub+0xb6>
     t         = ((fp_word)a->dp[x]) - (((fp_word)b->dp[x]) + t);
 8022556:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8022558:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802255a:	3302      	adds	r3, #2
 802255c:	009b      	lsls	r3, r3, #2
 802255e:	4413      	add	r3, r2
 8022560:	685b      	ldr	r3, [r3, #4]
 8022562:	2200      	movs	r2, #0
 8022564:	61bb      	str	r3, [r7, #24]
 8022566:	61fa      	str	r2, [r7, #28]
 8022568:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802256a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802256c:	3302      	adds	r3, #2
 802256e:	009b      	lsls	r3, r3, #2
 8022570:	4413      	add	r3, r2
 8022572:	685b      	ldr	r3, [r3, #4]
 8022574:	2200      	movs	r2, #0
 8022576:	623b      	str	r3, [r7, #32]
 8022578:	627a      	str	r2, [r7, #36]	@ 0x24
 802257a:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 802257e:	6a39      	ldr	r1, [r7, #32]
 8022580:	188c      	adds	r4, r1, r2
 8022582:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8022584:	eb41 0503 	adc.w	r5, r1, r3
 8022588:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 802258c:	460b      	mov	r3, r1
 802258e:	1b1b      	subs	r3, r3, r4
 8022590:	613b      	str	r3, [r7, #16]
 8022592:	4613      	mov	r3, r2
 8022594:	eb63 0305 	sbc.w	r3, r3, r5
 8022598:	617b      	str	r3, [r7, #20]
 802259a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 802259e:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
     c->dp[x]  = (fp_digit)t;
 80225a2:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 80225a4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80225a6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80225a8:	3302      	adds	r3, #2
 80225aa:	009b      	lsls	r3, r3, #2
 80225ac:	4413      	add	r3, r2
 80225ae:	6059      	str	r1, [r3, #4]
     t         = (t >> DIGIT_BIT)&1;
 80225b0:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80225b4:	f04f 0000 	mov.w	r0, #0
 80225b8:	f04f 0100 	mov.w	r1, #0
 80225bc:	0018      	movs	r0, r3
 80225be:	2100      	movs	r1, #0
 80225c0:	f000 0301 	and.w	r3, r0, #1
 80225c4:	60bb      	str	r3, [r7, #8]
 80225c6:	2300      	movs	r3, #0
 80225c8:	60fb      	str	r3, [r7, #12]
 80225ca:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80225ce:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
  for (x = 0; x < oldbused; x++) {
 80225d2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80225d4:	3301      	adds	r3, #1
 80225d6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80225d8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80225da:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80225dc:	429a      	cmp	r2, r3
 80225de:	dbba      	blt.n	8022556 <s_fp_sub+0x34>
  }
  for (; x < a->used; x++) {
 80225e0:	e02b      	b.n	802263a <s_fp_sub+0x118>
     t         = ((fp_word)a->dp[x]) - t;
 80225e2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80225e4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80225e6:	3302      	adds	r3, #2
 80225e8:	009b      	lsls	r3, r3, #2
 80225ea:	4413      	add	r3, r2
 80225ec:	685b      	ldr	r3, [r3, #4]
 80225ee:	2200      	movs	r2, #0
 80225f0:	4698      	mov	r8, r3
 80225f2:	4691      	mov	r9, r2
 80225f4:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80225f8:	ebb8 0a02 	subs.w	sl, r8, r2
 80225fc:	eb69 0b03 	sbc.w	fp, r9, r3
 8022600:	e9c7 ab10 	strd	sl, fp, [r7, #64]	@ 0x40
     c->dp[x]  = (fp_digit)t;
 8022604:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8022606:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8022608:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802260a:	3302      	adds	r3, #2
 802260c:	009b      	lsls	r3, r3, #2
 802260e:	440b      	add	r3, r1
 8022610:	605a      	str	r2, [r3, #4]
     t         = (t >> DIGIT_BIT)&1;
 8022612:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 8022616:	f04f 0200 	mov.w	r2, #0
 802261a:	f04f 0300 	mov.w	r3, #0
 802261e:	000a      	movs	r2, r1
 8022620:	2300      	movs	r3, #0
 8022622:	f002 0301 	and.w	r3, r2, #1
 8022626:	603b      	str	r3, [r7, #0]
 8022628:	2300      	movs	r3, #0
 802262a:	607b      	str	r3, [r7, #4]
 802262c:	e9d7 3400 	ldrd	r3, r4, [r7]
 8022630:	e9c7 3410 	strd	r3, r4, [r7, #64]	@ 0x40
  for (; x < a->used; x++) {
 8022634:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022636:	3301      	adds	r3, #1
 8022638:	64fb      	str	r3, [r7, #76]	@ 0x4c
 802263a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802263c:	681b      	ldr	r3, [r3, #0]
 802263e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8022640:	429a      	cmp	r2, r3
 8022642:	dbce      	blt.n	80225e2 <s_fp_sub+0xc0>
   }

  /* zero any excess digits on the destination that we didn't write to */
  for (; x < oldused; x++) {
 8022644:	e009      	b.n	802265a <s_fp_sub+0x138>
     c->dp[x] = 0;
 8022646:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8022648:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802264a:	3302      	adds	r3, #2
 802264c:	009b      	lsls	r3, r3, #2
 802264e:	4413      	add	r3, r2
 8022650:	2200      	movs	r2, #0
 8022652:	605a      	str	r2, [r3, #4]
  for (; x < oldused; x++) {
 8022654:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022656:	3301      	adds	r3, #1
 8022658:	64fb      	str	r3, [r7, #76]	@ 0x4c
 802265a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802265c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802265e:	429a      	cmp	r2, r3
 8022660:	dbf1      	blt.n	8022646 <s_fp_sub+0x124>
  }
  fp_clamp(c);
 8022662:	e004      	b.n	802266e <s_fp_sub+0x14c>
 8022664:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022666:	681b      	ldr	r3, [r3, #0]
 8022668:	1e5a      	subs	r2, r3, #1
 802266a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802266c:	601a      	str	r2, [r3, #0]
 802266e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022670:	681b      	ldr	r3, [r3, #0]
 8022672:	2b00      	cmp	r3, #0
 8022674:	d009      	beq.n	802268a <s_fp_sub+0x168>
 8022676:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022678:	681b      	ldr	r3, [r3, #0]
 802267a:	3b01      	subs	r3, #1
 802267c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802267e:	3302      	adds	r3, #2
 8022680:	009b      	lsls	r3, r3, #2
 8022682:	4413      	add	r3, r2
 8022684:	685b      	ldr	r3, [r3, #4]
 8022686:	2b00      	cmp	r3, #0
 8022688:	d0ec      	beq.n	8022664 <s_fp_sub+0x142>
 802268a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802268c:	681b      	ldr	r3, [r3, #0]
 802268e:	2b00      	cmp	r3, #0
 8022690:	d002      	beq.n	8022698 <s_fp_sub+0x176>
 8022692:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022694:	685b      	ldr	r3, [r3, #4]
 8022696:	e000      	b.n	802269a <s_fp_sub+0x178>
 8022698:	2300      	movs	r3, #0
 802269a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802269c:	6053      	str	r3, [r2, #4]
}
 802269e:	bf00      	nop
 80226a0:	3754      	adds	r7, #84	@ 0x54
 80226a2:	46bd      	mov	sp, r7
 80226a4:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80226a8:	4770      	bx	lr

080226aa <fp_mul>:

/* c = a * b */
int fp_mul(fp_int *A, fp_int *B, fp_int *C)
{
 80226aa:	b580      	push	{r7, lr}
 80226ac:	b088      	sub	sp, #32
 80226ae:	af00      	add	r7, sp, #0
 80226b0:	60f8      	str	r0, [r7, #12]
 80226b2:	60b9      	str	r1, [r7, #8]
 80226b4:	607a      	str	r2, [r7, #4]
    int   ret = FP_OKAY;
 80226b6:	2300      	movs	r3, #0
 80226b8:	61fb      	str	r3, [r7, #28]
    int   y, yy, oldused;

    oldused = C->used;
 80226ba:	687b      	ldr	r3, [r7, #4]
 80226bc:	681b      	ldr	r3, [r3, #0]
 80226be:	617b      	str	r3, [r7, #20]

    y  = MAX(A->used, B->used);
 80226c0:	68bb      	ldr	r3, [r7, #8]
 80226c2:	681a      	ldr	r2, [r3, #0]
 80226c4:	68fb      	ldr	r3, [r7, #12]
 80226c6:	681b      	ldr	r3, [r3, #0]
 80226c8:	4293      	cmp	r3, r2
 80226ca:	bfb8      	it	lt
 80226cc:	4613      	movlt	r3, r2
 80226ce:	61bb      	str	r3, [r7, #24]
    yy = MIN(A->used, B->used);
 80226d0:	68bb      	ldr	r3, [r7, #8]
 80226d2:	681a      	ldr	r2, [r3, #0]
 80226d4:	68fb      	ldr	r3, [r7, #12]
 80226d6:	681b      	ldr	r3, [r3, #0]
 80226d8:	4293      	cmp	r3, r2
 80226da:	bfa8      	it	ge
 80226dc:	4613      	movge	r3, r2
 80226de:	613b      	str	r3, [r7, #16]

    /* fail if we are out of range */
    if (y + yy >= FP_SIZE) {
 80226e0:	69ba      	ldr	r2, [r7, #24]
 80226e2:	693b      	ldr	r3, [r7, #16]
 80226e4:	4413      	add	r3, r2
 80226e6:	2b87      	cmp	r3, #135	@ 0x87
 80226e8:	dd03      	ble.n	80226f2 <fp_mul+0x48>
       ret = FP_VAL;
 80226ea:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80226ee:	61fb      	str	r3, [r7, #28]
       goto clean;
 80226f0:	e005      	b.n	80226fe <fp_mul+0x54>
        if (yy >= 56 && y <= 64) {
           ret = fp_mul_comba64(A,B,C);
           goto clean;
        }
#endif
        ret = fp_mul_comba(A,B,C);
 80226f2:	687a      	ldr	r2, [r7, #4]
 80226f4:	68b9      	ldr	r1, [r7, #8]
 80226f6:	68f8      	ldr	r0, [r7, #12]
 80226f8:	f000 f9bb 	bl	8022a72 <fp_mul_comba>
 80226fc:	61f8      	str	r0, [r7, #28]

clean:
    /* zero any excess digits on the destination that we didn't write to */
    for (y = C->used; y >= 0 && y < oldused; y++) {
 80226fe:	687b      	ldr	r3, [r7, #4]
 8022700:	681b      	ldr	r3, [r3, #0]
 8022702:	61bb      	str	r3, [r7, #24]
 8022704:	e009      	b.n	802271a <fp_mul+0x70>
        C->dp[y] = 0;
 8022706:	687a      	ldr	r2, [r7, #4]
 8022708:	69bb      	ldr	r3, [r7, #24]
 802270a:	3302      	adds	r3, #2
 802270c:	009b      	lsls	r3, r3, #2
 802270e:	4413      	add	r3, r2
 8022710:	2200      	movs	r2, #0
 8022712:	605a      	str	r2, [r3, #4]
    for (y = C->used; y >= 0 && y < oldused; y++) {
 8022714:	69bb      	ldr	r3, [r7, #24]
 8022716:	3301      	adds	r3, #1
 8022718:	61bb      	str	r3, [r7, #24]
 802271a:	69bb      	ldr	r3, [r7, #24]
 802271c:	2b00      	cmp	r3, #0
 802271e:	db03      	blt.n	8022728 <fp_mul+0x7e>
 8022720:	69ba      	ldr	r2, [r7, #24]
 8022722:	697b      	ldr	r3, [r7, #20]
 8022724:	429a      	cmp	r2, r3
 8022726:	dbee      	blt.n	8022706 <fp_mul+0x5c>
    }

    return ret;
 8022728:	69fb      	ldr	r3, [r7, #28]
}
 802272a:	4618      	mov	r0, r3
 802272c:	3720      	adds	r7, #32
 802272e:	46bd      	mov	sp, r7
 8022730:	bd80      	pop	{r7, pc}

08022732 <fp_mul_2>:

int fp_mul_2(fp_int * a, fp_int * b)
{
 8022732:	b480      	push	{r7}
 8022734:	b089      	sub	sp, #36	@ 0x24
 8022736:	af00      	add	r7, sp, #0
 8022738:	6078      	str	r0, [r7, #4]
 802273a:	6039      	str	r1, [r7, #0]
  int     x, oldused;

  /* Make sure value to double and result are in range. */
  if ((a->used > (FP_SIZE-1)) || ((a->used == (FP_SIZE - 1)) &&
 802273c:	687b      	ldr	r3, [r7, #4]
 802273e:	681b      	ldr	r3, [r3, #0]
 8022740:	2b87      	cmp	r3, #135	@ 0x87
 8022742:	dc08      	bgt.n	8022756 <fp_mul_2+0x24>
 8022744:	687b      	ldr	r3, [r7, #4]
 8022746:	681b      	ldr	r3, [r3, #0]
 8022748:	2b87      	cmp	r3, #135	@ 0x87
 802274a:	d107      	bne.n	802275c <fp_mul_2+0x2a>
              ((a->dp[FP_SIZE - 1] & ((fp_digit)1 << (DIGIT_BIT - 1))) != 0))) {
 802274c:	687b      	ldr	r3, [r7, #4]
 802274e:	f8d3 3228 	ldr.w	r3, [r3, #552]	@ 0x228
  if ((a->used > (FP_SIZE-1)) || ((a->used == (FP_SIZE - 1)) &&
 8022752:	2b00      	cmp	r3, #0
 8022754:	da02      	bge.n	802275c <fp_mul_2+0x2a>
    return FP_VAL;
 8022756:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802275a:	e052      	b.n	8022802 <fp_mul_2+0xd0>
  }

  oldused = b->used;
 802275c:	683b      	ldr	r3, [r7, #0]
 802275e:	681b      	ldr	r3, [r3, #0]
 8022760:	60fb      	str	r3, [r7, #12]
  b->used = a->used;
 8022762:	687b      	ldr	r3, [r7, #4]
 8022764:	681a      	ldr	r2, [r3, #0]
 8022766:	683b      	ldr	r3, [r7, #0]
 8022768:	601a      	str	r2, [r3, #0]

  {
    fp_digit r, rr, *tmpa, *tmpb;

    /* alias for source */
    tmpa = a->dp;
 802276a:	687b      	ldr	r3, [r7, #4]
 802276c:	330c      	adds	r3, #12
 802276e:	617b      	str	r3, [r7, #20]

    /* alias for dest */
    tmpb = b->dp;
 8022770:	683b      	ldr	r3, [r7, #0]
 8022772:	330c      	adds	r3, #12
 8022774:	613b      	str	r3, [r7, #16]

    /* carry */
    r = 0;
 8022776:	2300      	movs	r3, #0
 8022778:	61bb      	str	r3, [r7, #24]
    for (x = 0; x < a->used; x++) {
 802277a:	2300      	movs	r3, #0
 802277c:	61fb      	str	r3, [r7, #28]
 802277e:	e013      	b.n	80227a8 <fp_mul_2+0x76>

      /* get what will be the *next* carry bit from the
       * MSB of the current digit
       */
      rr = *tmpa >> ((fp_digit)(DIGIT_BIT - 1));
 8022780:	697b      	ldr	r3, [r7, #20]
 8022782:	681b      	ldr	r3, [r3, #0]
 8022784:	0fdb      	lsrs	r3, r3, #31
 8022786:	60bb      	str	r3, [r7, #8]

      /* now shift up this digit, add in the carry [from the previous] */
      *tmpb++ = ((*tmpa++ << ((fp_digit)1)) | r);
 8022788:	697b      	ldr	r3, [r7, #20]
 802278a:	1d1a      	adds	r2, r3, #4
 802278c:	617a      	str	r2, [r7, #20]
 802278e:	681b      	ldr	r3, [r3, #0]
 8022790:	0059      	lsls	r1, r3, #1
 8022792:	693b      	ldr	r3, [r7, #16]
 8022794:	1d1a      	adds	r2, r3, #4
 8022796:	613a      	str	r2, [r7, #16]
 8022798:	69ba      	ldr	r2, [r7, #24]
 802279a:	430a      	orrs	r2, r1
 802279c:	601a      	str	r2, [r3, #0]

      /* copy the carry that would be from the source
       * digit into the next iteration
       */
      r = rr;
 802279e:	68bb      	ldr	r3, [r7, #8]
 80227a0:	61bb      	str	r3, [r7, #24]
    for (x = 0; x < a->used; x++) {
 80227a2:	69fb      	ldr	r3, [r7, #28]
 80227a4:	3301      	adds	r3, #1
 80227a6:	61fb      	str	r3, [r7, #28]
 80227a8:	687b      	ldr	r3, [r7, #4]
 80227aa:	681b      	ldr	r3, [r3, #0]
 80227ac:	69fa      	ldr	r2, [r7, #28]
 80227ae:	429a      	cmp	r2, r3
 80227b0:	dbe6      	blt.n	8022780 <fp_mul_2+0x4e>
    }

    /* new leading digit? */
    if (r != 0) {
 80227b2:	69bb      	ldr	r3, [r7, #24]
 80227b4:	2b00      	cmp	r3, #0
 80227b6:	d007      	beq.n	80227c8 <fp_mul_2+0x96>
      /* add a MSB which is always 1 at this point */
      *tmpb = 1;
 80227b8:	693b      	ldr	r3, [r7, #16]
 80227ba:	2201      	movs	r2, #1
 80227bc:	601a      	str	r2, [r3, #0]
      ++(b->used);
 80227be:	683b      	ldr	r3, [r7, #0]
 80227c0:	681b      	ldr	r3, [r3, #0]
 80227c2:	1c5a      	adds	r2, r3, #1
 80227c4:	683b      	ldr	r3, [r7, #0]
 80227c6:	601a      	str	r2, [r3, #0]
    }

    /* zero any excess digits on the destination that we didn't write to */
    tmpb = b->dp + b->used;
 80227c8:	683b      	ldr	r3, [r7, #0]
 80227ca:	f103 020c 	add.w	r2, r3, #12
 80227ce:	683b      	ldr	r3, [r7, #0]
 80227d0:	681b      	ldr	r3, [r3, #0]
 80227d2:	009b      	lsls	r3, r3, #2
 80227d4:	4413      	add	r3, r2
 80227d6:	613b      	str	r3, [r7, #16]
    for (x = b->used; x < oldused; x++) {
 80227d8:	683b      	ldr	r3, [r7, #0]
 80227da:	681b      	ldr	r3, [r3, #0]
 80227dc:	61fb      	str	r3, [r7, #28]
 80227de:	e007      	b.n	80227f0 <fp_mul_2+0xbe>
      *tmpb++ = 0;
 80227e0:	693b      	ldr	r3, [r7, #16]
 80227e2:	1d1a      	adds	r2, r3, #4
 80227e4:	613a      	str	r2, [r7, #16]
 80227e6:	2200      	movs	r2, #0
 80227e8:	601a      	str	r2, [r3, #0]
    for (x = b->used; x < oldused; x++) {
 80227ea:	69fb      	ldr	r3, [r7, #28]
 80227ec:	3301      	adds	r3, #1
 80227ee:	61fb      	str	r3, [r7, #28]
 80227f0:	69fa      	ldr	r2, [r7, #28]
 80227f2:	68fb      	ldr	r3, [r7, #12]
 80227f4:	429a      	cmp	r2, r3
 80227f6:	dbf3      	blt.n	80227e0 <fp_mul_2+0xae>
    }
  }
  b->sign = a->sign;
 80227f8:	687b      	ldr	r3, [r7, #4]
 80227fa:	685a      	ldr	r2, [r3, #4]
 80227fc:	683b      	ldr	r3, [r7, #0]
 80227fe:	605a      	str	r2, [r3, #4]

  return FP_OKAY;
 8022800:	2300      	movs	r3, #0
}
 8022802:	4618      	mov	r0, r3
 8022804:	3724      	adds	r7, #36	@ 0x24
 8022806:	46bd      	mov	sp, r7
 8022808:	f85d 7b04 	ldr.w	r7, [sp], #4
 802280c:	4770      	bx	lr

0802280e <fp_mul_d>:

/* c = a * b */
int fp_mul_d(fp_int *a, fp_digit b, fp_int *c)
{
 802280e:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022812:	b08b      	sub	sp, #44	@ 0x2c
 8022814:	af00      	add	r7, sp, #0
 8022816:	6178      	str	r0, [r7, #20]
 8022818:	6139      	str	r1, [r7, #16]
 802281a:	60fa      	str	r2, [r7, #12]
   fp_word  w;
   int      x, oldused;

   oldused = c->used;
 802281c:	68fb      	ldr	r3, [r7, #12]
 802281e:	681b      	ldr	r3, [r3, #0]
 8022820:	61bb      	str	r3, [r7, #24]
   c->used = a->used;
 8022822:	697b      	ldr	r3, [r7, #20]
 8022824:	681a      	ldr	r2, [r3, #0]
 8022826:	68fb      	ldr	r3, [r7, #12]
 8022828:	601a      	str	r2, [r3, #0]
   c->sign = a->sign;
 802282a:	697b      	ldr	r3, [r7, #20]
 802282c:	685a      	ldr	r2, [r3, #4]
 802282e:	68fb      	ldr	r3, [r7, #12]
 8022830:	605a      	str	r2, [r3, #4]
   w       = 0;
 8022832:	f04f 0200 	mov.w	r2, #0
 8022836:	f04f 0300 	mov.w	r3, #0
 802283a:	e9c7 2308 	strd	r2, r3, [r7, #32]
   for (x = 0; x < a->used; x++) {
 802283e:	2300      	movs	r3, #0
 8022840:	61fb      	str	r3, [r7, #28]
 8022842:	e033      	b.n	80228ac <fp_mul_d+0x9e>
       w         = ((fp_word)a->dp[x]) * ((fp_word)b) + w;
 8022844:	697a      	ldr	r2, [r7, #20]
 8022846:	69fb      	ldr	r3, [r7, #28]
 8022848:	3302      	adds	r3, #2
 802284a:	009b      	lsls	r3, r3, #2
 802284c:	4413      	add	r3, r2
 802284e:	685b      	ldr	r3, [r3, #4]
 8022850:	2200      	movs	r2, #0
 8022852:	4698      	mov	r8, r3
 8022854:	4691      	mov	r9, r2
 8022856:	693b      	ldr	r3, [r7, #16]
 8022858:	2200      	movs	r2, #0
 802285a:	469a      	mov	sl, r3
 802285c:	4693      	mov	fp, r2
 802285e:	fb0a f209 	mul.w	r2, sl, r9
 8022862:	fb08 f30b 	mul.w	r3, r8, fp
 8022866:	4413      	add	r3, r2
 8022868:	fba8 450a 	umull	r4, r5, r8, sl
 802286c:	442b      	add	r3, r5
 802286e:	461d      	mov	r5, r3
 8022870:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8022874:	1911      	adds	r1, r2, r4
 8022876:	6039      	str	r1, [r7, #0]
 8022878:	416b      	adcs	r3, r5
 802287a:	607b      	str	r3, [r7, #4]
 802287c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8022880:	e9c7 2308 	strd	r2, r3, [r7, #32]
       c->dp[x]  = (fp_digit)w;
 8022884:	6a3a      	ldr	r2, [r7, #32]
 8022886:	68f9      	ldr	r1, [r7, #12]
 8022888:	69fb      	ldr	r3, [r7, #28]
 802288a:	3302      	adds	r3, #2
 802288c:	009b      	lsls	r3, r3, #2
 802288e:	440b      	add	r3, r1
 8022890:	605a      	str	r2, [r3, #4]
       w         = w >> DIGIT_BIT;
 8022892:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8022896:	f04f 0200 	mov.w	r2, #0
 802289a:	f04f 0300 	mov.w	r3, #0
 802289e:	000a      	movs	r2, r1
 80228a0:	2300      	movs	r3, #0
 80228a2:	e9c7 2308 	strd	r2, r3, [r7, #32]
   for (x = 0; x < a->used; x++) {
 80228a6:	69fb      	ldr	r3, [r7, #28]
 80228a8:	3301      	adds	r3, #1
 80228aa:	61fb      	str	r3, [r7, #28]
 80228ac:	697b      	ldr	r3, [r7, #20]
 80228ae:	681b      	ldr	r3, [r3, #0]
 80228b0:	69fa      	ldr	r2, [r7, #28]
 80228b2:	429a      	cmp	r2, r3
 80228b4:	dbc6      	blt.n	8022844 <fp_mul_d+0x36>
   }
   if (w != 0) {
 80228b6:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80228ba:	4313      	orrs	r3, r2
 80228bc:	d01f      	beq.n	80228fe <fp_mul_d+0xf0>
      if (a->used == FP_SIZE)
 80228be:	697b      	ldr	r3, [r7, #20]
 80228c0:	681b      	ldr	r3, [r3, #0]
 80228c2:	2b88      	cmp	r3, #136	@ 0x88
 80228c4:	d102      	bne.n	80228cc <fp_mul_d+0xbe>
          return FP_VAL;
 80228c6:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80228ca:	e03e      	b.n	802294a <fp_mul_d+0x13c>
      c->dp[c->used++] = (fp_digit) w;
 80228cc:	68fb      	ldr	r3, [r7, #12]
 80228ce:	681b      	ldr	r3, [r3, #0]
 80228d0:	1c59      	adds	r1, r3, #1
 80228d2:	68fa      	ldr	r2, [r7, #12]
 80228d4:	6011      	str	r1, [r2, #0]
 80228d6:	6a3a      	ldr	r2, [r7, #32]
 80228d8:	68f9      	ldr	r1, [r7, #12]
 80228da:	3302      	adds	r3, #2
 80228dc:	009b      	lsls	r3, r3, #2
 80228de:	440b      	add	r3, r1
 80228e0:	605a      	str	r2, [r3, #4]
      ++x;
 80228e2:	69fb      	ldr	r3, [r7, #28]
 80228e4:	3301      	adds	r3, #1
 80228e6:	61fb      	str	r3, [r7, #28]
   }

   /* zero any excess digits on the destination that we didn't write to */
   /* also checking FP_SIZE here for static analysis */
   for (; x < oldused && x < FP_SIZE; x++) {
 80228e8:	e009      	b.n	80228fe <fp_mul_d+0xf0>
      c->dp[x] = 0;
 80228ea:	68fa      	ldr	r2, [r7, #12]
 80228ec:	69fb      	ldr	r3, [r7, #28]
 80228ee:	3302      	adds	r3, #2
 80228f0:	009b      	lsls	r3, r3, #2
 80228f2:	4413      	add	r3, r2
 80228f4:	2200      	movs	r2, #0
 80228f6:	605a      	str	r2, [r3, #4]
   for (; x < oldused && x < FP_SIZE; x++) {
 80228f8:	69fb      	ldr	r3, [r7, #28]
 80228fa:	3301      	adds	r3, #1
 80228fc:	61fb      	str	r3, [r7, #28]
 80228fe:	69fa      	ldr	r2, [r7, #28]
 8022900:	69bb      	ldr	r3, [r7, #24]
 8022902:	429a      	cmp	r2, r3
 8022904:	da08      	bge.n	8022918 <fp_mul_d+0x10a>
 8022906:	69fb      	ldr	r3, [r7, #28]
 8022908:	2b87      	cmp	r3, #135	@ 0x87
 802290a:	ddee      	ble.n	80228ea <fp_mul_d+0xdc>
   }

   fp_clamp(c);
 802290c:	e004      	b.n	8022918 <fp_mul_d+0x10a>
 802290e:	68fb      	ldr	r3, [r7, #12]
 8022910:	681b      	ldr	r3, [r3, #0]
 8022912:	1e5a      	subs	r2, r3, #1
 8022914:	68fb      	ldr	r3, [r7, #12]
 8022916:	601a      	str	r2, [r3, #0]
 8022918:	68fb      	ldr	r3, [r7, #12]
 802291a:	681b      	ldr	r3, [r3, #0]
 802291c:	2b00      	cmp	r3, #0
 802291e:	d009      	beq.n	8022934 <fp_mul_d+0x126>
 8022920:	68fb      	ldr	r3, [r7, #12]
 8022922:	681b      	ldr	r3, [r3, #0]
 8022924:	3b01      	subs	r3, #1
 8022926:	68fa      	ldr	r2, [r7, #12]
 8022928:	3302      	adds	r3, #2
 802292a:	009b      	lsls	r3, r3, #2
 802292c:	4413      	add	r3, r2
 802292e:	685b      	ldr	r3, [r3, #4]
 8022930:	2b00      	cmp	r3, #0
 8022932:	d0ec      	beq.n	802290e <fp_mul_d+0x100>
 8022934:	68fb      	ldr	r3, [r7, #12]
 8022936:	681b      	ldr	r3, [r3, #0]
 8022938:	2b00      	cmp	r3, #0
 802293a:	d002      	beq.n	8022942 <fp_mul_d+0x134>
 802293c:	68fb      	ldr	r3, [r7, #12]
 802293e:	685b      	ldr	r3, [r3, #4]
 8022940:	e000      	b.n	8022944 <fp_mul_d+0x136>
 8022942:	2300      	movs	r3, #0
 8022944:	68fa      	ldr	r2, [r7, #12]
 8022946:	6053      	str	r3, [r2, #4]
   return FP_OKAY;
 8022948:	2300      	movs	r3, #0
}
 802294a:	4618      	mov	r0, r3
 802294c:	372c      	adds	r7, #44	@ 0x2c
 802294e:	46bd      	mov	sp, r7
 8022950:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022954:	4770      	bx	lr

08022956 <fp_mul_2d>:

/* c = a * 2**d */
int fp_mul_2d(fp_int *a, int b, fp_int *c)
{
 8022956:	b580      	push	{r7, lr}
 8022958:	b08a      	sub	sp, #40	@ 0x28
 802295a:	af00      	add	r7, sp, #0
 802295c:	60f8      	str	r0, [r7, #12]
 802295e:	60b9      	str	r1, [r7, #8]
 8022960:	607a      	str	r2, [r7, #4]
   fp_digit carry, carrytmp, shift;
   int x;

   /* copy it */
   fp_copy(a, c);
 8022962:	6879      	ldr	r1, [r7, #4]
 8022964:	68f8      	ldr	r0, [r7, #12]
 8022966:	f004 f893 	bl	8026a90 <fp_copy>

   /* handle whole digits */
   if (b >= DIGIT_BIT) {
 802296a:	68bb      	ldr	r3, [r7, #8]
 802296c:	2b1f      	cmp	r3, #31
 802296e:	dd0e      	ble.n	802298e <fp_mul_2d+0x38>
      int ret = fp_lshd(c, b/DIGIT_BIT);
 8022970:	68bb      	ldr	r3, [r7, #8]
 8022972:	2b00      	cmp	r3, #0
 8022974:	da00      	bge.n	8022978 <fp_mul_2d+0x22>
 8022976:	331f      	adds	r3, #31
 8022978:	115b      	asrs	r3, r3, #5
 802297a:	4619      	mov	r1, r3
 802297c:	6878      	ldr	r0, [r7, #4]
 802297e:	f003 fd0d 	bl	802639c <fp_lshd>
 8022982:	61f8      	str	r0, [r7, #28]
      if (ret != FP_OKAY)
 8022984:	69fb      	ldr	r3, [r7, #28]
 8022986:	2b00      	cmp	r3, #0
 8022988:	d001      	beq.n	802298e <fp_mul_2d+0x38>
         return ret;
 802298a:	69fb      	ldr	r3, [r7, #28]
 802298c:	e06d      	b.n	8022a6a <fp_mul_2d+0x114>
   }
   b %= DIGIT_BIT;
 802298e:	68bb      	ldr	r3, [r7, #8]
 8022990:	425a      	negs	r2, r3
 8022992:	f003 031f 	and.w	r3, r3, #31
 8022996:	f002 021f 	and.w	r2, r2, #31
 802299a:	bf58      	it	pl
 802299c:	4253      	negpl	r3, r2
 802299e:	60bb      	str	r3, [r7, #8]

   /* shift the digits */
   if (b != 0) {
 80229a0:	68bb      	ldr	r3, [r7, #8]
 80229a2:	2b00      	cmp	r3, #0
 80229a4:	d048      	beq.n	8022a38 <fp_mul_2d+0xe2>
      carry = 0;
 80229a6:	2300      	movs	r3, #0
 80229a8:	627b      	str	r3, [r7, #36]	@ 0x24
      shift = DIGIT_BIT - b;
 80229aa:	68bb      	ldr	r3, [r7, #8]
 80229ac:	f1c3 0320 	rsb	r3, r3, #32
 80229b0:	61bb      	str	r3, [r7, #24]
      for (x = 0; x < c->used; x++) {
 80229b2:	2300      	movs	r3, #0
 80229b4:	623b      	str	r3, [r7, #32]
 80229b6:	e01e      	b.n	80229f6 <fp_mul_2d+0xa0>
          carrytmp = c->dp[x] >> shift;
 80229b8:	687a      	ldr	r2, [r7, #4]
 80229ba:	6a3b      	ldr	r3, [r7, #32]
 80229bc:	3302      	adds	r3, #2
 80229be:	009b      	lsls	r3, r3, #2
 80229c0:	4413      	add	r3, r2
 80229c2:	685a      	ldr	r2, [r3, #4]
 80229c4:	69bb      	ldr	r3, [r7, #24]
 80229c6:	fa22 f303 	lsr.w	r3, r2, r3
 80229ca:	617b      	str	r3, [r7, #20]
          c->dp[x] = (c->dp[x] << b) + carry;
 80229cc:	687a      	ldr	r2, [r7, #4]
 80229ce:	6a3b      	ldr	r3, [r7, #32]
 80229d0:	3302      	adds	r3, #2
 80229d2:	009b      	lsls	r3, r3, #2
 80229d4:	4413      	add	r3, r2
 80229d6:	685a      	ldr	r2, [r3, #4]
 80229d8:	68bb      	ldr	r3, [r7, #8]
 80229da:	409a      	lsls	r2, r3
 80229dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80229de:	441a      	add	r2, r3
 80229e0:	6879      	ldr	r1, [r7, #4]
 80229e2:	6a3b      	ldr	r3, [r7, #32]
 80229e4:	3302      	adds	r3, #2
 80229e6:	009b      	lsls	r3, r3, #2
 80229e8:	440b      	add	r3, r1
 80229ea:	605a      	str	r2, [r3, #4]
          carry = carrytmp;
 80229ec:	697b      	ldr	r3, [r7, #20]
 80229ee:	627b      	str	r3, [r7, #36]	@ 0x24
      for (x = 0; x < c->used; x++) {
 80229f0:	6a3b      	ldr	r3, [r7, #32]
 80229f2:	3301      	adds	r3, #1
 80229f4:	623b      	str	r3, [r7, #32]
 80229f6:	687b      	ldr	r3, [r7, #4]
 80229f8:	681b      	ldr	r3, [r3, #0]
 80229fa:	6a3a      	ldr	r2, [r7, #32]
 80229fc:	429a      	cmp	r2, r3
 80229fe:	dbdb      	blt.n	80229b8 <fp_mul_2d+0x62>
      }
      /* store last carry if room */
      if (carry && x < FP_SIZE) {
 8022a00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022a02:	2b00      	cmp	r3, #0
 8022a04:	d00d      	beq.n	8022a22 <fp_mul_2d+0xcc>
 8022a06:	6a3b      	ldr	r3, [r7, #32]
 8022a08:	2b87      	cmp	r3, #135	@ 0x87
 8022a0a:	dc0a      	bgt.n	8022a22 <fp_mul_2d+0xcc>
         c->dp[c->used++] = carry;
 8022a0c:	687b      	ldr	r3, [r7, #4]
 8022a0e:	681b      	ldr	r3, [r3, #0]
 8022a10:	1c59      	adds	r1, r3, #1
 8022a12:	687a      	ldr	r2, [r7, #4]
 8022a14:	6011      	str	r1, [r2, #0]
 8022a16:	687a      	ldr	r2, [r7, #4]
 8022a18:	3302      	adds	r3, #2
 8022a1a:	009b      	lsls	r3, r3, #2
 8022a1c:	4413      	add	r3, r2
 8022a1e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8022a20:	605a      	str	r2, [r3, #4]
      }
      if (x == FP_SIZE)
 8022a22:	6a3b      	ldr	r3, [r7, #32]
 8022a24:	2b88      	cmp	r3, #136	@ 0x88
 8022a26:	d107      	bne.n	8022a38 <fp_mul_2d+0xe2>
         return FP_VAL;
 8022a28:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022a2c:	e01d      	b.n	8022a6a <fp_mul_2d+0x114>
   }
   fp_clamp(c);
 8022a2e:	687b      	ldr	r3, [r7, #4]
 8022a30:	681b      	ldr	r3, [r3, #0]
 8022a32:	1e5a      	subs	r2, r3, #1
 8022a34:	687b      	ldr	r3, [r7, #4]
 8022a36:	601a      	str	r2, [r3, #0]
 8022a38:	687b      	ldr	r3, [r7, #4]
 8022a3a:	681b      	ldr	r3, [r3, #0]
 8022a3c:	2b00      	cmp	r3, #0
 8022a3e:	d009      	beq.n	8022a54 <fp_mul_2d+0xfe>
 8022a40:	687b      	ldr	r3, [r7, #4]
 8022a42:	681b      	ldr	r3, [r3, #0]
 8022a44:	3b01      	subs	r3, #1
 8022a46:	687a      	ldr	r2, [r7, #4]
 8022a48:	3302      	adds	r3, #2
 8022a4a:	009b      	lsls	r3, r3, #2
 8022a4c:	4413      	add	r3, r2
 8022a4e:	685b      	ldr	r3, [r3, #4]
 8022a50:	2b00      	cmp	r3, #0
 8022a52:	d0ec      	beq.n	8022a2e <fp_mul_2d+0xd8>
 8022a54:	687b      	ldr	r3, [r7, #4]
 8022a56:	681b      	ldr	r3, [r3, #0]
 8022a58:	2b00      	cmp	r3, #0
 8022a5a:	d002      	beq.n	8022a62 <fp_mul_2d+0x10c>
 8022a5c:	687b      	ldr	r3, [r7, #4]
 8022a5e:	685b      	ldr	r3, [r3, #4]
 8022a60:	e000      	b.n	8022a64 <fp_mul_2d+0x10e>
 8022a62:	2300      	movs	r3, #0
 8022a64:	687a      	ldr	r2, [r7, #4]
 8022a66:	6053      	str	r3, [r2, #4]
   return FP_OKAY;
 8022a68:	2300      	movs	r3, #0
}
 8022a6a:	4618      	mov	r0, r3
 8022a6c:	3728      	adds	r7, #40	@ 0x28
 8022a6e:	46bd      	mov	sp, r7
 8022a70:	bd80      	pop	{r7, pc}

08022a72 <fp_mul_comba>:
}
#endif

/*  C = (A * B)   */
int fp_mul_comba(fp_int *A, fp_int *B, fp_int *C)
{
 8022a72:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8022a76:	b0a0      	sub	sp, #128	@ 0x80
 8022a78:	af00      	add	r7, sp, #0
 8022a7a:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8022a7c:	62b9      	str	r1, [r7, #40]	@ 0x28
 8022a7e:	627a      	str	r2, [r7, #36]	@ 0x24
   int       ret = 0;
 8022a80:	2300      	movs	r3, #0
 8022a82:	65fb      	str	r3, [r7, #92]	@ 0x5c
   fp_int    tmp[1];
#else
   fp_int    *tmp;
#endif

   if (A->used + B->used >= FP_SIZE) return FP_VAL;
 8022a84:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022a86:	681a      	ldr	r2, [r3, #0]
 8022a88:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022a8a:	681b      	ldr	r3, [r3, #0]
 8022a8c:	4413      	add	r3, r2
 8022a8e:	2b87      	cmp	r3, #135	@ 0x87
 8022a90:	dd02      	ble.n	8022a98 <fp_mul_comba+0x26>
 8022a92:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022a96:	e0f4      	b.n	8022c82 <fp_mul_comba+0x210>

   IF_HAVE_INTEL_MULX(ret = fp_mul_comba_mulx(A, B, C), return ret) ;

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8022a98:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8022a9c:	f7fb fffa 	bl	801ea94 <wolfSSL_Malloc>
 8022aa0:	65b8      	str	r0, [r7, #88]	@ 0x58
   if (tmp == NULL)
 8022aa2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8022aa4:	2b00      	cmp	r3, #0
 8022aa6:	d102      	bne.n	8022aae <fp_mul_comba+0x3c>
       return FP_MEM;
 8022aa8:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8022aac:	e0e9      	b.n	8022c82 <fp_mul_comba+0x210>
#endif

   COMBA_START;
   COMBA_CLEAR;
 8022aae:	2300      	movs	r3, #0
 8022ab0:	66bb      	str	r3, [r7, #104]	@ 0x68
 8022ab2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022ab4:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8022ab6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022ab8:	673b      	str	r3, [r7, #112]	@ 0x70

   /* get size of output and trim */
   pa = A->used + B->used;
 8022aba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022abc:	681a      	ldr	r2, [r3, #0]
 8022abe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022ac0:	681b      	ldr	r3, [r3, #0]
 8022ac2:	4413      	add	r3, r2
 8022ac4:	677b      	str	r3, [r7, #116]	@ 0x74
   if (pa >= FP_SIZE) {
 8022ac6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022ac8:	2b87      	cmp	r3, #135	@ 0x87
 8022aca:	dd01      	ble.n	8022ad0 <fp_mul_comba+0x5e>
      pa = FP_SIZE-1;
 8022acc:	2387      	movs	r3, #135	@ 0x87
 8022ace:	677b      	str	r3, [r7, #116]	@ 0x74
   }

   /* Always take branch to use tmp variable. This avoids a cache attack for
    * determining if C equals A */
   if (1) {
      fp_init(tmp);
 8022ad0:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8022ad2:	f003 fdf3 	bl	80266bc <fp_init>
      dst = tmp;
 8022ad6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8022ad8:	657b      	str	r3, [r7, #84]	@ 0x54
   }

   for (ix = 0; ix < pa; ix++) {
 8022ada:	2300      	movs	r3, #0
 8022adc:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8022ade:	e096      	b.n	8022c0e <fp_mul_comba+0x19c>
      /* get offsets into the two bignums */
      ty = MIN(ix, (B->used > 0 ? B->used - 1 : 0));
 8022ae0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022ae2:	681b      	ldr	r3, [r3, #0]
 8022ae4:	2b01      	cmp	r3, #1
 8022ae6:	bfb8      	it	lt
 8022ae8:	2301      	movlt	r3, #1
 8022aea:	1e5a      	subs	r2, r3, #1
 8022aec:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8022aee:	4293      	cmp	r3, r2
 8022af0:	bfa8      	it	ge
 8022af2:	4613      	movge	r3, r2
 8022af4:	64fb      	str	r3, [r7, #76]	@ 0x4c
      tx = ix - ty;
 8022af6:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8022af8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022afa:	1ad3      	subs	r3, r2, r3
 8022afc:	64bb      	str	r3, [r7, #72]	@ 0x48

      /* setup temp aliases */
      tmpx = A->dp + tx;
 8022afe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022b00:	f103 020c 	add.w	r2, r3, #12
 8022b04:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022b06:	009b      	lsls	r3, r3, #2
 8022b08:	4413      	add	r3, r2
 8022b0a:	667b      	str	r3, [r7, #100]	@ 0x64
      tmpy = B->dp + ty;
 8022b0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022b0e:	f103 020c 	add.w	r2, r3, #12
 8022b12:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022b14:	009b      	lsls	r3, r3, #2
 8022b16:	4413      	add	r3, r2
 8022b18:	663b      	str	r3, [r7, #96]	@ 0x60

      /* this is the number of times the loop will iterate, essentially its
         while (tx++ < a->used && ty-- >= 0) { ... }
       */
      iy = MIN(A->used-tx, ty+1);
 8022b1a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022b1c:	681a      	ldr	r2, [r3, #0]
 8022b1e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022b20:	1ad2      	subs	r2, r2, r3
 8022b22:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022b24:	4293      	cmp	r3, r2
 8022b26:	db04      	blt.n	8022b32 <fp_mul_comba+0xc0>
 8022b28:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022b2a:	681a      	ldr	r2, [r3, #0]
 8022b2c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022b2e:	1ad3      	subs	r3, r2, r3
 8022b30:	e001      	b.n	8022b36 <fp_mul_comba+0xc4>
 8022b32:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022b34:	3301      	adds	r3, #1
 8022b36:	647b      	str	r3, [r7, #68]	@ 0x44

      /* execute loop */
      COMBA_FORWARD;
 8022b38:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022b3a:	673b      	str	r3, [r7, #112]	@ 0x70
 8022b3c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022b3e:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8022b40:	2300      	movs	r3, #0
 8022b42:	66bb      	str	r3, [r7, #104]	@ 0x68
      for (iz = 0; iz < iy; ++iz) {
 8022b44:	2300      	movs	r3, #0
 8022b46:	67bb      	str	r3, [r7, #120]	@ 0x78
 8022b48:	e053      	b.n	8022bf2 <fp_mul_comba+0x180>
          fp_digit _tmpx = *tmpx++;
 8022b4a:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022b4c:	1d13      	adds	r3, r2, #4
 8022b4e:	667b      	str	r3, [r7, #100]	@ 0x64
 8022b50:	6813      	ldr	r3, [r2, #0]
 8022b52:	643b      	str	r3, [r7, #64]	@ 0x40
          fp_digit _tmpy = *tmpy--;
 8022b54:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8022b56:	1f13      	subs	r3, r2, #4
 8022b58:	663b      	str	r3, [r7, #96]	@ 0x60
 8022b5a:	6813      	ldr	r3, [r2, #0]
 8022b5c:	63fb      	str	r3, [r7, #60]	@ 0x3c
          MULADD(_tmpx, _tmpy);
 8022b5e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8022b60:	2200      	movs	r2, #0
 8022b62:	613b      	str	r3, [r7, #16]
 8022b64:	617a      	str	r2, [r7, #20]
 8022b66:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8022b68:	2200      	movs	r2, #0
 8022b6a:	4698      	mov	r8, r3
 8022b6c:	4691      	mov	r9, r2
 8022b6e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8022b70:	2200      	movs	r2, #0
 8022b72:	469a      	mov	sl, r3
 8022b74:	4693      	mov	fp, r2
 8022b76:	fb0a f209 	mul.w	r2, sl, r9
 8022b7a:	fb08 f30b 	mul.w	r3, r8, fp
 8022b7e:	4413      	add	r3, r2
 8022b80:	fba8 450a 	umull	r4, r5, r8, sl
 8022b84:	442b      	add	r3, r5
 8022b86:	461d      	mov	r5, r3
 8022b88:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8022b8c:	460b      	mov	r3, r1
 8022b8e:	191b      	adds	r3, r3, r4
 8022b90:	60bb      	str	r3, [r7, #8]
 8022b92:	4613      	mov	r3, r2
 8022b94:	416b      	adcs	r3, r5
 8022b96:	60fb      	str	r3, [r7, #12]
 8022b98:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8022b9c:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
 8022ba0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022ba2:	673b      	str	r3, [r7, #112]	@ 0x70
 8022ba4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022ba6:	2200      	movs	r2, #0
 8022ba8:	61bb      	str	r3, [r7, #24]
 8022baa:	61fa      	str	r2, [r7, #28]
 8022bac:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8022bb0:	f04f 0000 	mov.w	r0, #0
 8022bb4:	f04f 0100 	mov.w	r1, #0
 8022bb8:	0018      	movs	r0, r3
 8022bba:	2100      	movs	r1, #0
 8022bbc:	69bb      	ldr	r3, [r7, #24]
 8022bbe:	181b      	adds	r3, r3, r0
 8022bc0:	603b      	str	r3, [r7, #0]
 8022bc2:	69fb      	ldr	r3, [r7, #28]
 8022bc4:	414b      	adcs	r3, r1
 8022bc6:	607b      	str	r3, [r7, #4]
 8022bc8:	e9d7 2300 	ldrd	r2, r3, [r7]
 8022bcc:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
 8022bd0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022bd2:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8022bd4:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8022bd8:	f04f 0000 	mov.w	r0, #0
 8022bdc:	f04f 0100 	mov.w	r1, #0
 8022be0:	0018      	movs	r0, r3
 8022be2:	2100      	movs	r1, #0
 8022be4:	4602      	mov	r2, r0
 8022be6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022be8:	4413      	add	r3, r2
 8022bea:	66bb      	str	r3, [r7, #104]	@ 0x68
      for (iz = 0; iz < iy; ++iz) {
 8022bec:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8022bee:	3301      	adds	r3, #1
 8022bf0:	67bb      	str	r3, [r7, #120]	@ 0x78
 8022bf2:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8022bf4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022bf6:	429a      	cmp	r2, r3
 8022bf8:	dba7      	blt.n	8022b4a <fp_mul_comba+0xd8>
      }

      /* store term */
      COMBA_STORE(dst->dp[ix]);
 8022bfa:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8022bfc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8022bfe:	3302      	adds	r3, #2
 8022c00:	009a      	lsls	r2, r3, #2
 8022c02:	440a      	add	r2, r1
 8022c04:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8022c06:	6053      	str	r3, [r2, #4]
   for (ix = 0; ix < pa; ix++) {
 8022c08:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8022c0a:	3301      	adds	r3, #1
 8022c0c:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8022c0e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8022c10:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022c12:	429a      	cmp	r2, r3
 8022c14:	f6ff af64 	blt.w	8022ae0 <fp_mul_comba+0x6e>
  }
  COMBA_FINI;

  dst->used = pa;
 8022c18:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c1a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022c1c:	601a      	str	r2, [r3, #0]

  /* warning: WOLFSSL_SP_INT_NEGATIVE may disable negative numbers */
  dst->sign = A->sign ^ B->sign;
 8022c1e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022c20:	685a      	ldr	r2, [r3, #4]
 8022c22:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022c24:	685b      	ldr	r3, [r3, #4]
 8022c26:	405a      	eors	r2, r3
 8022c28:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c2a:	605a      	str	r2, [r3, #4]
  fp_clamp(dst);
 8022c2c:	e004      	b.n	8022c38 <fp_mul_comba+0x1c6>
 8022c2e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c30:	681b      	ldr	r3, [r3, #0]
 8022c32:	1e5a      	subs	r2, r3, #1
 8022c34:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c36:	601a      	str	r2, [r3, #0]
 8022c38:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c3a:	681b      	ldr	r3, [r3, #0]
 8022c3c:	2b00      	cmp	r3, #0
 8022c3e:	d009      	beq.n	8022c54 <fp_mul_comba+0x1e2>
 8022c40:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c42:	681b      	ldr	r3, [r3, #0]
 8022c44:	3b01      	subs	r3, #1
 8022c46:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8022c48:	3302      	adds	r3, #2
 8022c4a:	009b      	lsls	r3, r3, #2
 8022c4c:	4413      	add	r3, r2
 8022c4e:	685b      	ldr	r3, [r3, #4]
 8022c50:	2b00      	cmp	r3, #0
 8022c52:	d0ec      	beq.n	8022c2e <fp_mul_comba+0x1bc>
 8022c54:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c56:	681b      	ldr	r3, [r3, #0]
 8022c58:	2b00      	cmp	r3, #0
 8022c5a:	d002      	beq.n	8022c62 <fp_mul_comba+0x1f0>
 8022c5c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022c5e:	685b      	ldr	r3, [r3, #4]
 8022c60:	e000      	b.n	8022c64 <fp_mul_comba+0x1f2>
 8022c62:	2300      	movs	r3, #0
 8022c64:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8022c66:	6053      	str	r3, [r2, #4]
  fp_copy(dst, C);
 8022c68:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8022c6a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8022c6c:	f003 ff10 	bl	8026a90 <fp_copy>

  /* Variables used but not seen by cppcheck. */
  (void)c0; (void)c1; (void)c2;

#ifdef WOLFSSL_SMALL_STACK
  XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8022c70:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8022c72:	653b      	str	r3, [r7, #80]	@ 0x50
 8022c74:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8022c76:	2b00      	cmp	r3, #0
 8022c78:	d002      	beq.n	8022c80 <fp_mul_comba+0x20e>
 8022c7a:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8022c7c:	f7fb ff26 	bl	801eacc <wolfSSL_Free>
#endif
  return ret;
 8022c80:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
}
 8022c82:	4618      	mov	r0, r3
 8022c84:	3780      	adds	r7, #128	@ 0x80
 8022c86:	46bd      	mov	sp, r7
 8022c88:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08022c8c <fp_div>:

/* a/b => cb + d == a */
int fp_div(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 8022c8c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8022c90:	b09e      	sub	sp, #120	@ 0x78
 8022c92:	af00      	add	r7, sp, #0
 8022c94:	6178      	str	r0, [r7, #20]
 8022c96:	6139      	str	r1, [r7, #16]
 8022c98:	60fa      	str	r2, [r7, #12]
 8022c9a:	60bb      	str	r3, [r7, #8]
#else
  fp_int  *q, *x, *y, *t1, *t2;
#endif

  /* is divisor zero ? */
  if (fp_iszero (b) == FP_YES) {
 8022c9c:	693b      	ldr	r3, [r7, #16]
 8022c9e:	681b      	ldr	r3, [r3, #0]
 8022ca0:	2b00      	cmp	r3, #0
 8022ca2:	d102      	bne.n	8022caa <fp_div+0x1e>
    return FP_VAL;
 8022ca4:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8022ca8:	e2e0      	b.n	802326c <fp_div+0x5e0>
  }

  /* if a < b then q=0, r = a */
  if (fp_cmp_mag (a, b) == FP_LT)
 8022caa:	6939      	ldr	r1, [r7, #16]
 8022cac:	6978      	ldr	r0, [r7, #20]
 8022cae:	f002 ff50 	bl	8025b52 <fp_cmp_mag>
 8022cb2:	4603      	mov	r3, r0
 8022cb4:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8022cb8:	d10e      	bne.n	8022cd8 <fp_div+0x4c>
  {
    if (d != NULL) {
 8022cba:	68bb      	ldr	r3, [r7, #8]
 8022cbc:	2b00      	cmp	r3, #0
 8022cbe:	d003      	beq.n	8022cc8 <fp_div+0x3c>
      fp_copy (a, d);
 8022cc0:	68b9      	ldr	r1, [r7, #8]
 8022cc2:	6978      	ldr	r0, [r7, #20]
 8022cc4:	f003 fee4 	bl	8026a90 <fp_copy>
    }
    if (c != NULL) {
 8022cc8:	68fb      	ldr	r3, [r7, #12]
 8022cca:	2b00      	cmp	r3, #0
 8022ccc:	d002      	beq.n	8022cd4 <fp_div+0x48>
      fp_zero (c);
 8022cce:	68f8      	ldr	r0, [r7, #12]
 8022cd0:	f003 fd02 	bl	80266d8 <fp_zero>
    }
    return FP_OKAY;
 8022cd4:	2300      	movs	r3, #0
 8022cd6:	e2c9      	b.n	802326c <fp_div+0x5e0>
  }

#ifdef WOLFSSL_SMALL_STACK          /* 0  1  2  3   4  */
  /* allocate 5 elements of fp_int for q, x, y, t1, t2 */
  q = (fp_int*)XMALLOC(sizeof(fp_int) * 5, NULL, DYNAMIC_TYPE_BIGINT);
 8022cd8:	f640 20dc 	movw	r0, #2780	@ 0xadc
 8022cdc:	f7fb feda 	bl	801ea94 <wolfSSL_Malloc>
 8022ce0:	66f8      	str	r0, [r7, #108]	@ 0x6c
  if (q == NULL) {
 8022ce2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022ce4:	2b00      	cmp	r3, #0
 8022ce6:	d102      	bne.n	8022cee <fp_div+0x62>
      return FP_MEM;
 8022ce8:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8022cec:	e2be      	b.n	802326c <fp_div+0x5e0>
  }
  x = &q[1]; y = &q[2]; t1 = &q[3]; t2 = &q[4];
 8022cee:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022cf0:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8022cf4:	66bb      	str	r3, [r7, #104]	@ 0x68
 8022cf6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022cf8:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8022cfc:	667b      	str	r3, [r7, #100]	@ 0x64
 8022cfe:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022d00:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8022d04:	663b      	str	r3, [r7, #96]	@ 0x60
 8022d06:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022d08:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8022d0c:	65fb      	str	r3, [r7, #92]	@ 0x5c
#endif

  fp_init(q);
 8022d0e:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8022d10:	f003 fcd4 	bl	80266bc <fp_init>
  /* qb + d = a, and b is an integer > 0, therefore q <= a */
  q->used = a->used;
 8022d14:	697b      	ldr	r3, [r7, #20]
 8022d16:	681a      	ldr	r2, [r3, #0]
 8022d18:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022d1a:	601a      	str	r2, [r3, #0]

  fp_init(t1);
 8022d1c:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8022d1e:	f003 fccd 	bl	80266bc <fp_init>
  fp_init(t2);
 8022d22:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8022d24:	f003 fcca 	bl	80266bc <fp_init>
  ** Init a copy (x) of the input (a)
  **
  ** ALERT: Not calling fp_init_copy() as some compiler optimization settings
  ** such as -O2 will complain that (x) or (y) "may be used uninitialized".
  ** The fp_init() is here only to appease the compiler.  */
  fp_init(x);
 8022d28:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8022d2a:	f003 fcc7 	bl	80266bc <fp_init>
  fp_copy(a, x); /* copy (src = a) to (dst = x) */
 8022d2e:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8022d30:	6978      	ldr	r0, [r7, #20]
 8022d32:	f003 fead 	bl	8026a90 <fp_copy>

  fp_init(y);
 8022d36:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8022d38:	f003 fcc0 	bl	80266bc <fp_init>
  fp_copy(b, y); /* copy (src = b) to (dst = y) */
 8022d3c:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8022d3e:	6938      	ldr	r0, [r7, #16]
 8022d40:	f003 fea6 	bl	8026a90 <fp_copy>

  /* fix the sign */
  neg = (a->sign == b->sign) ? FP_ZPOS : FP_NEG;
 8022d44:	697b      	ldr	r3, [r7, #20]
 8022d46:	685a      	ldr	r2, [r3, #4]
 8022d48:	693b      	ldr	r3, [r7, #16]
 8022d4a:	685b      	ldr	r3, [r3, #4]
 8022d4c:	429a      	cmp	r2, r3
 8022d4e:	bf14      	ite	ne
 8022d50:	2301      	movne	r3, #1
 8022d52:	2300      	moveq	r3, #0
 8022d54:	b2db      	uxtb	r3, r3
 8022d56:	65bb      	str	r3, [r7, #88]	@ 0x58
  x->sign = y->sign = FP_ZPOS;
 8022d58:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8022d5a:	2200      	movs	r2, #0
 8022d5c:	605a      	str	r2, [r3, #4]
 8022d5e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8022d60:	685a      	ldr	r2, [r3, #4]
 8022d62:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022d64:	605a      	str	r2, [r3, #4]

  /* normalize both x and y, ensure that y >= b/2, [b == 2**DIGIT_BIT] */
  norm = fp_count_bits(y) % DIGIT_BIT;
 8022d66:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8022d68:	f003 fabc 	bl	80262e4 <fp_count_bits>
 8022d6c:	4603      	mov	r3, r0
 8022d6e:	425a      	negs	r2, r3
 8022d70:	f003 031f 	and.w	r3, r3, #31
 8022d74:	f002 021f 	and.w	r2, r2, #31
 8022d78:	bf58      	it	pl
 8022d7a:	4253      	negpl	r3, r2
 8022d7c:	673b      	str	r3, [r7, #112]	@ 0x70
  if (norm < (int)(DIGIT_BIT-1)) {
 8022d7e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8022d80:	2b1e      	cmp	r3, #30
 8022d82:	dc29      	bgt.n	8022dd8 <fp_div+0x14c>
    norm = (DIGIT_BIT-1) - norm;
 8022d84:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8022d86:	f1c3 031f 	rsb	r3, r3, #31
 8022d8a:	673b      	str	r3, [r7, #112]	@ 0x70
    ret = fp_mul_2d (x, norm, x);
 8022d8c:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022d8e:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8022d90:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8022d92:	f7ff fde0 	bl	8022956 <fp_mul_2d>
 8022d96:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 8022d98:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022d9a:	2b00      	cmp	r3, #0
 8022d9c:	d009      	beq.n	8022db2 <fp_div+0x126>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8022d9e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022da0:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8022da2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8022da4:	2b00      	cmp	r3, #0
 8022da6:	d002      	beq.n	8022dae <fp_div+0x122>
 8022da8:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8022daa:	f7fb fe8f 	bl	801eacc <wolfSSL_Free>
    #endif
      return ret;
 8022dae:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022db0:	e25c      	b.n	802326c <fp_div+0x5e0>
    }
    ret = fp_mul_2d (y, norm, y);
 8022db2:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022db4:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8022db6:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8022db8:	f7ff fdcd 	bl	8022956 <fp_mul_2d>
 8022dbc:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 8022dbe:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022dc0:	2b00      	cmp	r3, #0
 8022dc2:	d00b      	beq.n	8022ddc <fp_div+0x150>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8022dc4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022dc6:	653b      	str	r3, [r7, #80]	@ 0x50
 8022dc8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8022dca:	2b00      	cmp	r3, #0
 8022dcc:	d002      	beq.n	8022dd4 <fp_div+0x148>
 8022dce:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8022dd0:	f7fb fe7c 	bl	801eacc <wolfSSL_Free>
    #endif
      return ret;
 8022dd4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022dd6:	e249      	b.n	802326c <fp_div+0x5e0>
    }
  } else {
    norm = 0;
 8022dd8:	2300      	movs	r3, #0
 8022dda:	673b      	str	r3, [r7, #112]	@ 0x70
  }

  /* note hac does 0 based, so if used==5 then its 0,1,2,3,4, e.g. use 4 */
  n = x->used - 1;
 8022ddc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022dde:	681b      	ldr	r3, [r3, #0]
 8022de0:	3b01      	subs	r3, #1
 8022de2:	64bb      	str	r3, [r7, #72]	@ 0x48
  t = y->used - 1;
 8022de4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8022de6:	681b      	ldr	r3, [r3, #0]
 8022de8:	3b01      	subs	r3, #1
 8022dea:	647b      	str	r3, [r7, #68]	@ 0x44

  /* while (x >= y*b**n-t) do { q[n-t] += 1; x -= y*b**{n-t} } */
  ret = fp_lshd (y, n - t); /* y = y*b**{n-t} */
 8022dec:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8022dee:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022df0:	1ad3      	subs	r3, r2, r3
 8022df2:	4619      	mov	r1, r3
 8022df4:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8022df6:	f003 fad1 	bl	802639c <fp_lshd>
 8022dfa:	6578      	str	r0, [r7, #84]	@ 0x54
  if (ret != FP_OKAY) {
 8022dfc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022dfe:	2b00      	cmp	r3, #0
 8022e00:	d02a      	beq.n	8022e58 <fp_div+0x1cc>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8022e02:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022e04:	61bb      	str	r3, [r7, #24]
 8022e06:	69bb      	ldr	r3, [r7, #24]
 8022e08:	2b00      	cmp	r3, #0
 8022e0a:	d002      	beq.n	8022e12 <fp_div+0x186>
 8022e0c:	69b8      	ldr	r0, [r7, #24]
 8022e0e:	f7fb fe5d 	bl	801eacc <wolfSSL_Free>
  #endif
    return ret;
 8022e12:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022e14:	e22a      	b.n	802326c <fp_div+0x5e0>
  }

  while (fp_cmp (x, y) != FP_LT) {
    ++(q->dp[n - t]);
 8022e16:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8022e18:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022e1a:	1ad2      	subs	r2, r2, r3
 8022e1c:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8022e1e:	1c93      	adds	r3, r2, #2
 8022e20:	009b      	lsls	r3, r3, #2
 8022e22:	440b      	add	r3, r1
 8022e24:	685b      	ldr	r3, [r3, #4]
 8022e26:	1c59      	adds	r1, r3, #1
 8022e28:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8022e2a:	1c93      	adds	r3, r2, #2
 8022e2c:	009b      	lsls	r3, r3, #2
 8022e2e:	4403      	add	r3, r0
 8022e30:	6059      	str	r1, [r3, #4]
    ret = fp_sub (x, y, x);
 8022e32:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022e34:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8022e36:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8022e38:	f7ff fb33 	bl	80224a2 <fp_sub>
 8022e3c:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 8022e3e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022e40:	2b00      	cmp	r3, #0
 8022e42:	d009      	beq.n	8022e58 <fp_div+0x1cc>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8022e44:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022e46:	61fb      	str	r3, [r7, #28]
 8022e48:	69fb      	ldr	r3, [r7, #28]
 8022e4a:	2b00      	cmp	r3, #0
 8022e4c:	d002      	beq.n	8022e54 <fp_div+0x1c8>
 8022e4e:	69f8      	ldr	r0, [r7, #28]
 8022e50:	f7fb fe3c 	bl	801eacc <wolfSSL_Free>
    #endif
      return ret;
 8022e54:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022e56:	e209      	b.n	802326c <fp_div+0x5e0>
  while (fp_cmp (x, y) != FP_LT) {
 8022e58:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8022e5a:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8022e5c:	f002 fe14 	bl	8025a88 <fp_cmp>
 8022e60:	4603      	mov	r3, r0
 8022e62:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8022e66:	d1d6      	bne.n	8022e16 <fp_div+0x18a>
    }
  }

  /* reset y by shifting it back down */
  fp_rshd (y, n - t);
 8022e68:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8022e6a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022e6c:	1ad3      	subs	r3, r2, r3
 8022e6e:	4619      	mov	r1, r3
 8022e70:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8022e72:	f003 fb78 	bl	8026566 <fp_rshd>

  /* step 3. for i from n down to (t + 1) */
  for (i = n; i >= (t + 1); i--) {
 8022e76:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022e78:	677b      	str	r3, [r7, #116]	@ 0x74
 8022e7a:	e179      	b.n	8023170 <fp_div+0x4e4>
    if (i > x->used) {
 8022e7c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8022e7e:	681b      	ldr	r3, [r3, #0]
 8022e80:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022e82:	429a      	cmp	r2, r3
 8022e84:	f300 8170 	bgt.w	8023168 <fp_div+0x4dc>
      continue;
    }

    /* step 3.1 if xi == yt then set q{i-t-1} to b-1,
     * otherwise set q{i-t-1} to (xi*b + x{i-1})/yt */
    if (x->dp[i] == y->dp[t]) {
 8022e88:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022e8a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022e8c:	3302      	adds	r3, #2
 8022e8e:	009b      	lsls	r3, r3, #2
 8022e90:	4413      	add	r3, r2
 8022e92:	685a      	ldr	r2, [r3, #4]
 8022e94:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8022e96:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022e98:	3302      	adds	r3, #2
 8022e9a:	009b      	lsls	r3, r3, #2
 8022e9c:	440b      	add	r3, r1
 8022e9e:	685b      	ldr	r3, [r3, #4]
 8022ea0:	429a      	cmp	r2, r3
 8022ea2:	d10b      	bne.n	8022ebc <fp_div+0x230>
      q->dp[i - t - 1] = (fp_digit) ((((fp_word)1) << DIGIT_BIT) - 1);
 8022ea4:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022ea6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022ea8:	1ad3      	subs	r3, r2, r3
 8022eaa:	3b01      	subs	r3, #1
 8022eac:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8022eae:	3302      	adds	r3, #2
 8022eb0:	009b      	lsls	r3, r3, #2
 8022eb2:	4413      	add	r3, r2
 8022eb4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 8022eb8:	605a      	str	r2, [r3, #4]
 8022eba:	e03f      	b.n	8022f3c <fp_div+0x2b0>
    } else {
      fp_word tmp;
      tmp = ((fp_word) x->dp[i]) << ((fp_word) DIGIT_BIT);
 8022ebc:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022ebe:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022ec0:	3302      	adds	r3, #2
 8022ec2:	009b      	lsls	r3, r3, #2
 8022ec4:	4413      	add	r3, r2
 8022ec6:	685b      	ldr	r3, [r3, #4]
 8022ec8:	2200      	movs	r2, #0
 8022eca:	469a      	mov	sl, r3
 8022ecc:	4693      	mov	fp, r2
 8022ece:	f04f 0200 	mov.w	r2, #0
 8022ed2:	f04f 0300 	mov.w	r3, #0
 8022ed6:	4653      	mov	r3, sl
 8022ed8:	2200      	movs	r2, #0
 8022eda:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
      tmp |= ((fp_word) x->dp[i - 1]);
 8022ede:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022ee0:	3b01      	subs	r3, #1
 8022ee2:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8022ee4:	3302      	adds	r3, #2
 8022ee6:	009b      	lsls	r3, r3, #2
 8022ee8:	4413      	add	r3, r2
 8022eea:	685b      	ldr	r3, [r3, #4]
 8022eec:	2200      	movs	r2, #0
 8022eee:	461c      	mov	r4, r3
 8022ef0:	4615      	mov	r5, r2
 8022ef2:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 8022ef6:	ea42 0804 	orr.w	r8, r2, r4
 8022efa:	ea43 0905 	orr.w	r9, r3, r5
 8022efe:	e9c7 890e 	strd	r8, r9, [r7, #56]	@ 0x38
#ifdef WOLFSSL_LINUXKM
      /* Linux kernel macro for in-place 64 bit integer division. */
      do_div(tmp, (fp_word)y->dp[t]);
#else
      tmp /= ((fp_word)y->dp[t]);
 8022f02:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022f04:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f06:	3302      	adds	r3, #2
 8022f08:	009b      	lsls	r3, r3, #2
 8022f0a:	4413      	add	r3, r2
 8022f0c:	685b      	ldr	r3, [r3, #4]
 8022f0e:	2200      	movs	r2, #0
 8022f10:	603b      	str	r3, [r7, #0]
 8022f12:	607a      	str	r2, [r7, #4]
 8022f14:	e9d7 2300 	ldrd	r2, r3, [r7]
 8022f18:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 8022f1c:	f7dd f9c0 	bl	80002a0 <__aeabi_uldivmod>
 8022f20:	4602      	mov	r2, r0
 8022f22:	460b      	mov	r3, r1
 8022f24:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
#endif
      q->dp[i - t - 1] = (fp_digit) (tmp);
 8022f28:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022f2a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f2c:	1ad3      	subs	r3, r2, r3
 8022f2e:	3b01      	subs	r3, #1
 8022f30:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8022f32:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8022f34:	3302      	adds	r3, #2
 8022f36:	009b      	lsls	r3, r3, #2
 8022f38:	440b      	add	r3, r1
 8022f3a:	605a      	str	r2, [r3, #4]
    /* while (q{i-t-1} * (yt * b + y{t-1})) >
             xi * b**2 + xi-1 * b + xi-2

       do q{i-t-1} -= 1;
    */
    q->dp[i - t - 1] = (q->dp[i - t - 1] + 1);
 8022f3c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022f3e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f40:	1ad3      	subs	r3, r2, r3
 8022f42:	3b01      	subs	r3, #1
 8022f44:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8022f46:	3302      	adds	r3, #2
 8022f48:	009b      	lsls	r3, r3, #2
 8022f4a:	4413      	add	r3, r2
 8022f4c:	685a      	ldr	r2, [r3, #4]
 8022f4e:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8022f50:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f52:	1acb      	subs	r3, r1, r3
 8022f54:	3b01      	subs	r3, #1
 8022f56:	3201      	adds	r2, #1
 8022f58:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8022f5a:	3302      	adds	r3, #2
 8022f5c:	009b      	lsls	r3, r3, #2
 8022f5e:	440b      	add	r3, r1
 8022f60:	605a      	str	r2, [r3, #4]
    do {
      q->dp[i - t - 1] = (q->dp[i - t - 1] - 1);
 8022f62:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022f64:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f66:	1ad3      	subs	r3, r2, r3
 8022f68:	3b01      	subs	r3, #1
 8022f6a:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8022f6c:	3302      	adds	r3, #2
 8022f6e:	009b      	lsls	r3, r3, #2
 8022f70:	4413      	add	r3, r2
 8022f72:	685a      	ldr	r2, [r3, #4]
 8022f74:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8022f76:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f78:	1acb      	subs	r3, r1, r3
 8022f7a:	3b01      	subs	r3, #1
 8022f7c:	3a01      	subs	r2, #1
 8022f7e:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8022f80:	3302      	adds	r3, #2
 8022f82:	009b      	lsls	r3, r3, #2
 8022f84:	440b      	add	r3, r1
 8022f86:	605a      	str	r2, [r3, #4]

      /* find left hand */
      fp_zero (t1);
 8022f88:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8022f8a:	f003 fba5 	bl	80266d8 <fp_zero>
      t1->dp[0] = (t - 1 < 0) ? 0 : y->dp[t - 1];
 8022f8e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f90:	2b00      	cmp	r3, #0
 8022f92:	dd07      	ble.n	8022fa4 <fp_div+0x318>
 8022f94:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022f96:	3b01      	subs	r3, #1
 8022f98:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022f9a:	3302      	adds	r3, #2
 8022f9c:	009b      	lsls	r3, r3, #2
 8022f9e:	4413      	add	r3, r2
 8022fa0:	685b      	ldr	r3, [r3, #4]
 8022fa2:	e000      	b.n	8022fa6 <fp_div+0x31a>
 8022fa4:	2300      	movs	r3, #0
 8022fa6:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8022fa8:	60d3      	str	r3, [r2, #12]
      t1->dp[1] = y->dp[t];
 8022faa:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8022fac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022fae:	3302      	adds	r3, #2
 8022fb0:	009b      	lsls	r3, r3, #2
 8022fb2:	4413      	add	r3, r2
 8022fb4:	685a      	ldr	r2, [r3, #4]
 8022fb6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8022fb8:	611a      	str	r2, [r3, #16]
      t1->used = 2;
 8022fba:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8022fbc:	2202      	movs	r2, #2
 8022fbe:	601a      	str	r2, [r3, #0]
      ret = fp_mul_d (t1, q->dp[i - t - 1], t1);
 8022fc0:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8022fc2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8022fc4:	1ad3      	subs	r3, r2, r3
 8022fc6:	3b01      	subs	r3, #1
 8022fc8:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8022fca:	3302      	adds	r3, #2
 8022fcc:	009b      	lsls	r3, r3, #2
 8022fce:	4413      	add	r3, r2
 8022fd0:	685b      	ldr	r3, [r3, #4]
 8022fd2:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8022fd4:	4619      	mov	r1, r3
 8022fd6:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8022fd8:	f7ff fc19 	bl	802280e <fp_mul_d>
 8022fdc:	6578      	str	r0, [r7, #84]	@ 0x54
      if (ret != FP_OKAY) {
 8022fde:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022fe0:	2b00      	cmp	r3, #0
 8022fe2:	d009      	beq.n	8022ff8 <fp_div+0x36c>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8022fe4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8022fe6:	623b      	str	r3, [r7, #32]
 8022fe8:	6a3b      	ldr	r3, [r7, #32]
 8022fea:	2b00      	cmp	r3, #0
 8022fec:	d002      	beq.n	8022ff4 <fp_div+0x368>
 8022fee:	6a38      	ldr	r0, [r7, #32]
 8022ff0:	f7fb fd6c 	bl	801eacc <wolfSSL_Free>
      #endif
        return ret;
 8022ff4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8022ff6:	e139      	b.n	802326c <fp_div+0x5e0>
      }

      /* find right hand */
      t2->dp[0] = (i - 2 < 0) ? 0 : x->dp[i - 2];
 8022ff8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8022ffa:	2b01      	cmp	r3, #1
 8022ffc:	dd07      	ble.n	802300e <fp_div+0x382>
 8022ffe:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023000:	3b02      	subs	r3, #2
 8023002:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023004:	3302      	adds	r3, #2
 8023006:	009b      	lsls	r3, r3, #2
 8023008:	4413      	add	r3, r2
 802300a:	685b      	ldr	r3, [r3, #4]
 802300c:	e000      	b.n	8023010 <fp_div+0x384>
 802300e:	2300      	movs	r3, #0
 8023010:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023012:	60d3      	str	r3, [r2, #12]
      t2->dp[1] = (i - 1 < 0) ? 0 : x->dp[i - 1];
 8023014:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023016:	2b00      	cmp	r3, #0
 8023018:	dd07      	ble.n	802302a <fp_div+0x39e>
 802301a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802301c:	3b01      	subs	r3, #1
 802301e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023020:	3302      	adds	r3, #2
 8023022:	009b      	lsls	r3, r3, #2
 8023024:	4413      	add	r3, r2
 8023026:	685b      	ldr	r3, [r3, #4]
 8023028:	e000      	b.n	802302c <fp_div+0x3a0>
 802302a:	2300      	movs	r3, #0
 802302c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802302e:	6113      	str	r3, [r2, #16]
      t2->dp[2] = x->dp[i];
 8023030:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023032:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023034:	3302      	adds	r3, #2
 8023036:	009b      	lsls	r3, r3, #2
 8023038:	4413      	add	r3, r2
 802303a:	685a      	ldr	r2, [r3, #4]
 802303c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802303e:	615a      	str	r2, [r3, #20]
      t2->used = 3;
 8023040:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023042:	2203      	movs	r2, #3
 8023044:	601a      	str	r2, [r3, #0]
    } while (fp_cmp_mag(t1, t2) == FP_GT);
 8023046:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023048:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 802304a:	f002 fd82 	bl	8025b52 <fp_cmp_mag>
 802304e:	4603      	mov	r3, r0
 8023050:	2b01      	cmp	r3, #1
 8023052:	d086      	beq.n	8022f62 <fp_div+0x2d6>

    /* step 3.3 x = x - q{i-t-1} * y * b**{i-t-1} */
    ret = fp_mul_d (y, q->dp[i - t - 1], t1);
 8023054:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8023056:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023058:	1ad3      	subs	r3, r2, r3
 802305a:	3b01      	subs	r3, #1
 802305c:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802305e:	3302      	adds	r3, #2
 8023060:	009b      	lsls	r3, r3, #2
 8023062:	4413      	add	r3, r2
 8023064:	685b      	ldr	r3, [r3, #4]
 8023066:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8023068:	4619      	mov	r1, r3
 802306a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 802306c:	f7ff fbcf 	bl	802280e <fp_mul_d>
 8023070:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 8023072:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023074:	2b00      	cmp	r3, #0
 8023076:	d009      	beq.n	802308c <fp_div+0x400>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023078:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802307a:	627b      	str	r3, [r7, #36]	@ 0x24
 802307c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802307e:	2b00      	cmp	r3, #0
 8023080:	d002      	beq.n	8023088 <fp_div+0x3fc>
 8023082:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8023084:	f7fb fd22 	bl	801eacc <wolfSSL_Free>
    #endif
      return ret;
 8023088:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802308a:	e0ef      	b.n	802326c <fp_div+0x5e0>
    }
    ret = fp_lshd  (t1, i - t - 1);
 802308c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802308e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023090:	1ad3      	subs	r3, r2, r3
 8023092:	3b01      	subs	r3, #1
 8023094:	4619      	mov	r1, r3
 8023096:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8023098:	f003 f980 	bl	802639c <fp_lshd>
 802309c:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 802309e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230a0:	2b00      	cmp	r3, #0
 80230a2:	d009      	beq.n	80230b8 <fp_div+0x42c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 80230a4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80230a6:	62bb      	str	r3, [r7, #40]	@ 0x28
 80230a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80230aa:	2b00      	cmp	r3, #0
 80230ac:	d002      	beq.n	80230b4 <fp_div+0x428>
 80230ae:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80230b0:	f7fb fd0c 	bl	801eacc <wolfSSL_Free>
    #endif
      return ret;
 80230b4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230b6:	e0d9      	b.n	802326c <fp_div+0x5e0>
    }
    ret = fp_sub   (x, t1, x);
 80230b8:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80230ba:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80230bc:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 80230be:	f7ff f9f0 	bl	80224a2 <fp_sub>
 80230c2:	6578      	str	r0, [r7, #84]	@ 0x54
    if (ret != FP_OKAY) {
 80230c4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230c6:	2b00      	cmp	r3, #0
 80230c8:	d009      	beq.n	80230de <fp_div+0x452>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 80230ca:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80230cc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80230ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80230d0:	2b00      	cmp	r3, #0
 80230d2:	d002      	beq.n	80230da <fp_div+0x44e>
 80230d4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80230d6:	f7fb fcf9 	bl	801eacc <wolfSSL_Free>
    #endif
      return ret;
 80230da:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80230dc:	e0c6      	b.n	802326c <fp_div+0x5e0>
    }

    /* if x < 0 then { x = x + y*b**{i-t-1}; q{i-t-1} -= 1; } */
    if (x->sign == FP_NEG) {
 80230de:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80230e0:	685b      	ldr	r3, [r3, #4]
 80230e2:	2b01      	cmp	r3, #1
 80230e4:	d141      	bne.n	802316a <fp_div+0x4de>
      fp_copy (y, t1);
 80230e6:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80230e8:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80230ea:	f003 fcd1 	bl	8026a90 <fp_copy>
      ret = fp_lshd (t1, i - t - 1);
 80230ee:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80230f0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80230f2:	1ad3      	subs	r3, r2, r3
 80230f4:	3b01      	subs	r3, #1
 80230f6:	4619      	mov	r1, r3
 80230f8:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80230fa:	f003 f94f 	bl	802639c <fp_lshd>
 80230fe:	6578      	str	r0, [r7, #84]	@ 0x54
      if (ret != FP_OKAY) {
 8023100:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023102:	2b00      	cmp	r3, #0
 8023104:	d009      	beq.n	802311a <fp_div+0x48e>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 8023106:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023108:	633b      	str	r3, [r7, #48]	@ 0x30
 802310a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802310c:	2b00      	cmp	r3, #0
 802310e:	d002      	beq.n	8023116 <fp_div+0x48a>
 8023110:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8023112:	f7fb fcdb 	bl	801eacc <wolfSSL_Free>
      #endif
        return ret;
 8023116:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023118:	e0a8      	b.n	802326c <fp_div+0x5e0>
      }
      ret = fp_add (x, t1, x);
 802311a:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 802311c:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 802311e:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023120:	f7ff f8dd 	bl	80222de <fp_add>
 8023124:	6578      	str	r0, [r7, #84]	@ 0x54
      if (ret != FP_OKAY) {
 8023126:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023128:	2b00      	cmp	r3, #0
 802312a:	d009      	beq.n	8023140 <fp_div+0x4b4>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 802312c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802312e:	637b      	str	r3, [r7, #52]	@ 0x34
 8023130:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023132:	2b00      	cmp	r3, #0
 8023134:	d002      	beq.n	802313c <fp_div+0x4b0>
 8023136:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8023138:	f7fb fcc8 	bl	801eacc <wolfSSL_Free>
      #endif
        return ret;
 802313c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802313e:	e095      	b.n	802326c <fp_div+0x5e0>
      }
      q->dp[i - t - 1] = q->dp[i - t - 1] - 1;
 8023140:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8023142:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023144:	1ad3      	subs	r3, r2, r3
 8023146:	3b01      	subs	r3, #1
 8023148:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802314a:	3302      	adds	r3, #2
 802314c:	009b      	lsls	r3, r3, #2
 802314e:	4413      	add	r3, r2
 8023150:	685a      	ldr	r2, [r3, #4]
 8023152:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8023154:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023156:	1acb      	subs	r3, r1, r3
 8023158:	3b01      	subs	r3, #1
 802315a:	3a01      	subs	r2, #1
 802315c:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 802315e:	3302      	adds	r3, #2
 8023160:	009b      	lsls	r3, r3, #2
 8023162:	440b      	add	r3, r1
 8023164:	605a      	str	r2, [r3, #4]
 8023166:	e000      	b.n	802316a <fp_div+0x4de>
      continue;
 8023168:	bf00      	nop
  for (i = n; i >= (t + 1); i--) {
 802316a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802316c:	3b01      	subs	r3, #1
 802316e:	677b      	str	r3, [r7, #116]	@ 0x74
 8023170:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8023172:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023174:	429a      	cmp	r2, r3
 8023176:	f6ff ae81 	blt.w	8022e7c <fp_div+0x1f0>
  /* now q is the quotient and x is the remainder
   * [which we have to normalize]
   */

  /* get sign before writing to c */
  x->sign = x->used == 0 ? FP_ZPOS : a->sign;
 802317a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802317c:	681b      	ldr	r3, [r3, #0]
 802317e:	2b00      	cmp	r3, #0
 8023180:	d002      	beq.n	8023188 <fp_div+0x4fc>
 8023182:	697b      	ldr	r3, [r7, #20]
 8023184:	685b      	ldr	r3, [r3, #4]
 8023186:	e000      	b.n	802318a <fp_div+0x4fe>
 8023188:	2300      	movs	r3, #0
 802318a:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 802318c:	6053      	str	r3, [r2, #4]

  if (c != NULL) {
 802318e:	68fb      	ldr	r3, [r7, #12]
 8023190:	2b00      	cmp	r3, #0
 8023192:	d024      	beq.n	80231de <fp_div+0x552>
    fp_clamp (q);
 8023194:	e004      	b.n	80231a0 <fp_div+0x514>
 8023196:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023198:	681b      	ldr	r3, [r3, #0]
 802319a:	1e5a      	subs	r2, r3, #1
 802319c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802319e:	601a      	str	r2, [r3, #0]
 80231a0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80231a2:	681b      	ldr	r3, [r3, #0]
 80231a4:	2b00      	cmp	r3, #0
 80231a6:	d009      	beq.n	80231bc <fp_div+0x530>
 80231a8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80231aa:	681b      	ldr	r3, [r3, #0]
 80231ac:	3b01      	subs	r3, #1
 80231ae:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80231b0:	3302      	adds	r3, #2
 80231b2:	009b      	lsls	r3, r3, #2
 80231b4:	4413      	add	r3, r2
 80231b6:	685b      	ldr	r3, [r3, #4]
 80231b8:	2b00      	cmp	r3, #0
 80231ba:	d0ec      	beq.n	8023196 <fp_div+0x50a>
 80231bc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80231be:	681b      	ldr	r3, [r3, #0]
 80231c0:	2b00      	cmp	r3, #0
 80231c2:	d002      	beq.n	80231ca <fp_div+0x53e>
 80231c4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80231c6:	685b      	ldr	r3, [r3, #4]
 80231c8:	e000      	b.n	80231cc <fp_div+0x540>
 80231ca:	2300      	movs	r3, #0
 80231cc:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80231ce:	6053      	str	r3, [r2, #4]
    fp_copy (q, c);
 80231d0:	68f9      	ldr	r1, [r7, #12]
 80231d2:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 80231d4:	f003 fc5c 	bl	8026a90 <fp_copy>
    c->sign = neg;
 80231d8:	68fb      	ldr	r3, [r7, #12]
 80231da:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80231dc:	605a      	str	r2, [r3, #4]
  }

  if (d != NULL) {
 80231de:	68bb      	ldr	r3, [r7, #8]
 80231e0:	2b00      	cmp	r3, #0
 80231e2:	d03a      	beq.n	802325a <fp_div+0x5ce>
    fp_div_2d (x, norm, x, NULL);
 80231e4:	2300      	movs	r3, #0
 80231e6:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80231e8:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80231ea:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 80231ec:	f000 f986 	bl	80234fc <fp_div_2d>

    /* zero any excess digits on the destination that we didn't write to */
    for (i = b->used; i < x->used; i++) {
 80231f0:	693b      	ldr	r3, [r7, #16]
 80231f2:	681b      	ldr	r3, [r3, #0]
 80231f4:	677b      	str	r3, [r7, #116]	@ 0x74
 80231f6:	e009      	b.n	802320c <fp_div+0x580>
        x->dp[i] = 0;
 80231f8:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80231fa:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80231fc:	3302      	adds	r3, #2
 80231fe:	009b      	lsls	r3, r3, #2
 8023200:	4413      	add	r3, r2
 8023202:	2200      	movs	r2, #0
 8023204:	605a      	str	r2, [r3, #4]
    for (i = b->used; i < x->used; i++) {
 8023206:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023208:	3301      	adds	r3, #1
 802320a:	677b      	str	r3, [r7, #116]	@ 0x74
 802320c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802320e:	681b      	ldr	r3, [r3, #0]
 8023210:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8023212:	429a      	cmp	r2, r3
 8023214:	dbf0      	blt.n	80231f8 <fp_div+0x56c>
    }
    fp_clamp(x);
 8023216:	e004      	b.n	8023222 <fp_div+0x596>
 8023218:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802321a:	681b      	ldr	r3, [r3, #0]
 802321c:	1e5a      	subs	r2, r3, #1
 802321e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023220:	601a      	str	r2, [r3, #0]
 8023222:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023224:	681b      	ldr	r3, [r3, #0]
 8023226:	2b00      	cmp	r3, #0
 8023228:	d009      	beq.n	802323e <fp_div+0x5b2>
 802322a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802322c:	681b      	ldr	r3, [r3, #0]
 802322e:	3b01      	subs	r3, #1
 8023230:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023232:	3302      	adds	r3, #2
 8023234:	009b      	lsls	r3, r3, #2
 8023236:	4413      	add	r3, r2
 8023238:	685b      	ldr	r3, [r3, #4]
 802323a:	2b00      	cmp	r3, #0
 802323c:	d0ec      	beq.n	8023218 <fp_div+0x58c>
 802323e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023240:	681b      	ldr	r3, [r3, #0]
 8023242:	2b00      	cmp	r3, #0
 8023244:	d002      	beq.n	802324c <fp_div+0x5c0>
 8023246:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023248:	685b      	ldr	r3, [r3, #4]
 802324a:	e000      	b.n	802324e <fp_div+0x5c2>
 802324c:	2300      	movs	r3, #0
 802324e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023250:	6053      	str	r3, [r2, #4]
    fp_copy (x, d);
 8023252:	68b9      	ldr	r1, [r7, #8]
 8023254:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023256:	f003 fc1b 	bl	8026a90 <fp_copy>
  }

#ifdef WOLFSSL_SMALL_STACK
  XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 802325a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802325c:	643b      	str	r3, [r7, #64]	@ 0x40
 802325e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8023260:	2b00      	cmp	r3, #0
 8023262:	d002      	beq.n	802326a <fp_div+0x5de>
 8023264:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8023266:	f7fb fc31 	bl	801eacc <wolfSSL_Free>
#endif
  return FP_OKAY;
 802326a:	2300      	movs	r3, #0
}
 802326c:	4618      	mov	r0, r3
 802326e:	3778      	adds	r7, #120	@ 0x78
 8023270:	46bd      	mov	sp, r7
 8023272:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08023276 <fp_div_2>:

/* b = a/2 */
void fp_div_2(fp_int * a, fp_int * b)
{
 8023276:	b480      	push	{r7}
 8023278:	b089      	sub	sp, #36	@ 0x24
 802327a:	af00      	add	r7, sp, #0
 802327c:	6078      	str	r0, [r7, #4]
 802327e:	6039      	str	r1, [r7, #0]
  int     x, oldused;

  oldused = b->used;
 8023280:	683b      	ldr	r3, [r7, #0]
 8023282:	681b      	ldr	r3, [r3, #0]
 8023284:	60fb      	str	r3, [r7, #12]
  b->used = a->used;
 8023286:	687b      	ldr	r3, [r7, #4]
 8023288:	681a      	ldr	r2, [r3, #0]
 802328a:	683b      	ldr	r3, [r7, #0]
 802328c:	601a      	str	r2, [r3, #0]
  {
    fp_digit r, rr, *tmpa, *tmpb;

    /* source alias */
    tmpa = a->dp + b->used - 1;
 802328e:	687b      	ldr	r3, [r7, #4]
 8023290:	f103 020c 	add.w	r2, r3, #12
 8023294:	683b      	ldr	r3, [r7, #0]
 8023296:	681b      	ldr	r3, [r3, #0]
 8023298:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 802329c:	3b01      	subs	r3, #1
 802329e:	009b      	lsls	r3, r3, #2
 80232a0:	4413      	add	r3, r2
 80232a2:	617b      	str	r3, [r7, #20]

    /* dest alias */
    tmpb = b->dp + b->used - 1;
 80232a4:	683b      	ldr	r3, [r7, #0]
 80232a6:	f103 020c 	add.w	r2, r3, #12
 80232aa:	683b      	ldr	r3, [r7, #0]
 80232ac:	681b      	ldr	r3, [r3, #0]
 80232ae:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80232b2:	3b01      	subs	r3, #1
 80232b4:	009b      	lsls	r3, r3, #2
 80232b6:	4413      	add	r3, r2
 80232b8:	613b      	str	r3, [r7, #16]

    /* carry */
    r = 0;
 80232ba:	2300      	movs	r3, #0
 80232bc:	61bb      	str	r3, [r7, #24]
    for (x = b->used - 1; x >= 0; x--) {
 80232be:	683b      	ldr	r3, [r7, #0]
 80232c0:	681b      	ldr	r3, [r3, #0]
 80232c2:	3b01      	subs	r3, #1
 80232c4:	61fb      	str	r3, [r7, #28]
 80232c6:	e015      	b.n	80232f4 <fp_div_2+0x7e>
      /* get the carry for the next iteration */
      rr = *tmpa & 1;
 80232c8:	697b      	ldr	r3, [r7, #20]
 80232ca:	681b      	ldr	r3, [r3, #0]
 80232cc:	f003 0301 	and.w	r3, r3, #1
 80232d0:	60bb      	str	r3, [r7, #8]

      /* shift the current digit, add in carry and store */
      *tmpb-- = (*tmpa-- >> 1) | (r << (DIGIT_BIT - 1));
 80232d2:	697b      	ldr	r3, [r7, #20]
 80232d4:	1f1a      	subs	r2, r3, #4
 80232d6:	617a      	str	r2, [r7, #20]
 80232d8:	681b      	ldr	r3, [r3, #0]
 80232da:	0859      	lsrs	r1, r3, #1
 80232dc:	69bb      	ldr	r3, [r7, #24]
 80232de:	07da      	lsls	r2, r3, #31
 80232e0:	693b      	ldr	r3, [r7, #16]
 80232e2:	1f18      	subs	r0, r3, #4
 80232e4:	6138      	str	r0, [r7, #16]
 80232e6:	430a      	orrs	r2, r1
 80232e8:	601a      	str	r2, [r3, #0]

      /* forward carry to next iteration */
      r = rr;
 80232ea:	68bb      	ldr	r3, [r7, #8]
 80232ec:	61bb      	str	r3, [r7, #24]
    for (x = b->used - 1; x >= 0; x--) {
 80232ee:	69fb      	ldr	r3, [r7, #28]
 80232f0:	3b01      	subs	r3, #1
 80232f2:	61fb      	str	r3, [r7, #28]
 80232f4:	69fb      	ldr	r3, [r7, #28]
 80232f6:	2b00      	cmp	r3, #0
 80232f8:	dae6      	bge.n	80232c8 <fp_div_2+0x52>
    }

    /* zero any excess digits on the destination that we didn't write to */
    tmpb = b->dp + b->used;
 80232fa:	683b      	ldr	r3, [r7, #0]
 80232fc:	f103 020c 	add.w	r2, r3, #12
 8023300:	683b      	ldr	r3, [r7, #0]
 8023302:	681b      	ldr	r3, [r3, #0]
 8023304:	009b      	lsls	r3, r3, #2
 8023306:	4413      	add	r3, r2
 8023308:	613b      	str	r3, [r7, #16]
    for (x = b->used; x < oldused; x++) {
 802330a:	683b      	ldr	r3, [r7, #0]
 802330c:	681b      	ldr	r3, [r3, #0]
 802330e:	61fb      	str	r3, [r7, #28]
 8023310:	e007      	b.n	8023322 <fp_div_2+0xac>
      *tmpb++ = 0;
 8023312:	693b      	ldr	r3, [r7, #16]
 8023314:	1d1a      	adds	r2, r3, #4
 8023316:	613a      	str	r2, [r7, #16]
 8023318:	2200      	movs	r2, #0
 802331a:	601a      	str	r2, [r3, #0]
    for (x = b->used; x < oldused; x++) {
 802331c:	69fb      	ldr	r3, [r7, #28]
 802331e:	3301      	adds	r3, #1
 8023320:	61fb      	str	r3, [r7, #28]
 8023322:	69fa      	ldr	r2, [r7, #28]
 8023324:	68fb      	ldr	r3, [r7, #12]
 8023326:	429a      	cmp	r2, r3
 8023328:	dbf3      	blt.n	8023312 <fp_div_2+0x9c>
    }
  }
  b->sign = a->sign;
 802332a:	687b      	ldr	r3, [r7, #4]
 802332c:	685a      	ldr	r2, [r3, #4]
 802332e:	683b      	ldr	r3, [r7, #0]
 8023330:	605a      	str	r2, [r3, #4]
  fp_clamp (b);
 8023332:	e004      	b.n	802333e <fp_div_2+0xc8>
 8023334:	683b      	ldr	r3, [r7, #0]
 8023336:	681b      	ldr	r3, [r3, #0]
 8023338:	1e5a      	subs	r2, r3, #1
 802333a:	683b      	ldr	r3, [r7, #0]
 802333c:	601a      	str	r2, [r3, #0]
 802333e:	683b      	ldr	r3, [r7, #0]
 8023340:	681b      	ldr	r3, [r3, #0]
 8023342:	2b00      	cmp	r3, #0
 8023344:	d009      	beq.n	802335a <fp_div_2+0xe4>
 8023346:	683b      	ldr	r3, [r7, #0]
 8023348:	681b      	ldr	r3, [r3, #0]
 802334a:	3b01      	subs	r3, #1
 802334c:	683a      	ldr	r2, [r7, #0]
 802334e:	3302      	adds	r3, #2
 8023350:	009b      	lsls	r3, r3, #2
 8023352:	4413      	add	r3, r2
 8023354:	685b      	ldr	r3, [r3, #4]
 8023356:	2b00      	cmp	r3, #0
 8023358:	d0ec      	beq.n	8023334 <fp_div_2+0xbe>
 802335a:	683b      	ldr	r3, [r7, #0]
 802335c:	681b      	ldr	r3, [r3, #0]
 802335e:	2b00      	cmp	r3, #0
 8023360:	d002      	beq.n	8023368 <fp_div_2+0xf2>
 8023362:	683b      	ldr	r3, [r7, #0]
 8023364:	685b      	ldr	r3, [r3, #4]
 8023366:	e000      	b.n	802336a <fp_div_2+0xf4>
 8023368:	2300      	movs	r3, #0
 802336a:	683a      	ldr	r2, [r7, #0]
 802336c:	6053      	str	r3, [r2, #4]
}
 802336e:	bf00      	nop
 8023370:	3724      	adds	r7, #36	@ 0x24
 8023372:	46bd      	mov	sp, r7
 8023374:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023378:	4770      	bx	lr

0802337a <fp_div_2_mod_ct>:

/* c = a / 2 (mod b) - constant time (a < b and positive) */
int fp_div_2_mod_ct(fp_int *a, fp_int *b, fp_int *c)
{
 802337a:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 802337e:	b08d      	sub	sp, #52	@ 0x34
 8023380:	af00      	add	r7, sp, #0
 8023382:	6178      	str	r0, [r7, #20]
 8023384:	6139      	str	r1, [r7, #16]
 8023386:	60fa      	str	r2, [r7, #12]
  fp_word  w = 0;
 8023388:	f04f 0200 	mov.w	r2, #0
 802338c:	f04f 0300 	mov.w	r3, #0
 8023390:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
  fp_digit mask;
  int i;

  mask = (fp_digit)0 - (a->dp[0] & 1);
 8023394:	697b      	ldr	r3, [r7, #20]
 8023396:	68db      	ldr	r3, [r3, #12]
 8023398:	f003 0301 	and.w	r3, r3, #1
 802339c:	425b      	negs	r3, r3
 802339e:	623b      	str	r3, [r7, #32]
  for (i = 0; i < b->used; i++) {
 80233a0:	2300      	movs	r3, #0
 80233a2:	627b      	str	r3, [r7, #36]	@ 0x24
 80233a4:	e047      	b.n	8023436 <fp_div_2_mod_ct+0xbc>
      fp_digit mask_a = (fp_digit)0 - (i < a->used);
 80233a6:	697b      	ldr	r3, [r7, #20]
 80233a8:	681b      	ldr	r3, [r3, #0]
 80233aa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80233ac:	429a      	cmp	r2, r3
 80233ae:	bfb4      	ite	lt
 80233b0:	2301      	movlt	r3, #1
 80233b2:	2300      	movge	r3, #0
 80233b4:	b2db      	uxtb	r3, r3
 80233b6:	425b      	negs	r3, r3
 80233b8:	61fb      	str	r3, [r7, #28]

      w         += b->dp[i] & mask;
 80233ba:	693a      	ldr	r2, [r7, #16]
 80233bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80233be:	3302      	adds	r3, #2
 80233c0:	009b      	lsls	r3, r3, #2
 80233c2:	4413      	add	r3, r2
 80233c4:	685a      	ldr	r2, [r3, #4]
 80233c6:	6a3b      	ldr	r3, [r7, #32]
 80233c8:	4013      	ands	r3, r2
 80233ca:	2200      	movs	r2, #0
 80233cc:	461c      	mov	r4, r3
 80233ce:	4615      	mov	r5, r2
 80233d0:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 80233d4:	eb12 0a04 	adds.w	sl, r2, r4
 80233d8:	eb43 0b05 	adc.w	fp, r3, r5
 80233dc:	e9c7 ab0a 	strd	sl, fp, [r7, #40]	@ 0x28
      w         += a->dp[i] & mask_a;
 80233e0:	697a      	ldr	r2, [r7, #20]
 80233e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80233e4:	3302      	adds	r3, #2
 80233e6:	009b      	lsls	r3, r3, #2
 80233e8:	4413      	add	r3, r2
 80233ea:	685a      	ldr	r2, [r3, #4]
 80233ec:	69fb      	ldr	r3, [r7, #28]
 80233ee:	4013      	ands	r3, r2
 80233f0:	2200      	movs	r2, #0
 80233f2:	4698      	mov	r8, r3
 80233f4:	4691      	mov	r9, r2
 80233f6:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 80233fa:	eb12 0108 	adds.w	r1, r2, r8
 80233fe:	6039      	str	r1, [r7, #0]
 8023400:	eb43 0309 	adc.w	r3, r3, r9
 8023404:	607b      	str	r3, [r7, #4]
 8023406:	e9d7 2300 	ldrd	r2, r3, [r7]
 802340a:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
      c->dp[i]   = (fp_digit)w;
 802340e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023410:	68f9      	ldr	r1, [r7, #12]
 8023412:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023414:	3302      	adds	r3, #2
 8023416:	009b      	lsls	r3, r3, #2
 8023418:	440b      	add	r3, r1
 802341a:	605a      	str	r2, [r3, #4]
      w        >>= DIGIT_BIT;
 802341c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8023420:	f04f 0200 	mov.w	r2, #0
 8023424:	f04f 0300 	mov.w	r3, #0
 8023428:	000a      	movs	r2, r1
 802342a:	2300      	movs	r3, #0
 802342c:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
  for (i = 0; i < b->used; i++) {
 8023430:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023432:	3301      	adds	r3, #1
 8023434:	627b      	str	r3, [r7, #36]	@ 0x24
 8023436:	693b      	ldr	r3, [r7, #16]
 8023438:	681b      	ldr	r3, [r3, #0]
 802343a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802343c:	429a      	cmp	r2, r3
 802343e:	dbb2      	blt.n	80233a6 <fp_div_2_mod_ct+0x2c>
  }
  for (i = 0; i < b->used-1; i++) {
 8023440:	2300      	movs	r3, #0
 8023442:	627b      	str	r3, [r7, #36]	@ 0x24
 8023444:	e018      	b.n	8023478 <fp_div_2_mod_ct+0xfe>
      c->dp[i] = (c->dp[i] >> 1) | (c->dp[i+1] << (DIGIT_BIT - 1));
 8023446:	68fa      	ldr	r2, [r7, #12]
 8023448:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802344a:	3302      	adds	r3, #2
 802344c:	009b      	lsls	r3, r3, #2
 802344e:	4413      	add	r3, r2
 8023450:	685b      	ldr	r3, [r3, #4]
 8023452:	085a      	lsrs	r2, r3, #1
 8023454:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023456:	3301      	adds	r3, #1
 8023458:	68f9      	ldr	r1, [r7, #12]
 802345a:	3302      	adds	r3, #2
 802345c:	009b      	lsls	r3, r3, #2
 802345e:	440b      	add	r3, r1
 8023460:	685b      	ldr	r3, [r3, #4]
 8023462:	07db      	lsls	r3, r3, #31
 8023464:	431a      	orrs	r2, r3
 8023466:	68f9      	ldr	r1, [r7, #12]
 8023468:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802346a:	3302      	adds	r3, #2
 802346c:	009b      	lsls	r3, r3, #2
 802346e:	440b      	add	r3, r1
 8023470:	605a      	str	r2, [r3, #4]
  for (i = 0; i < b->used-1; i++) {
 8023472:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023474:	3301      	adds	r3, #1
 8023476:	627b      	str	r3, [r7, #36]	@ 0x24
 8023478:	693b      	ldr	r3, [r7, #16]
 802347a:	681b      	ldr	r3, [r3, #0]
 802347c:	3b01      	subs	r3, #1
 802347e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8023480:	429a      	cmp	r2, r3
 8023482:	dbe0      	blt.n	8023446 <fp_div_2_mod_ct+0xcc>
  }
  c->dp[i] = (c->dp[i] >> 1) | ((fp_digit)w << (DIGIT_BIT - 1));
 8023484:	68fa      	ldr	r2, [r7, #12]
 8023486:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023488:	3302      	adds	r3, #2
 802348a:	009b      	lsls	r3, r3, #2
 802348c:	4413      	add	r3, r2
 802348e:	685b      	ldr	r3, [r3, #4]
 8023490:	085a      	lsrs	r2, r3, #1
 8023492:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023494:	07db      	lsls	r3, r3, #31
 8023496:	431a      	orrs	r2, r3
 8023498:	68f9      	ldr	r1, [r7, #12]
 802349a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802349c:	3302      	adds	r3, #2
 802349e:	009b      	lsls	r3, r3, #2
 80234a0:	440b      	add	r3, r1
 80234a2:	605a      	str	r2, [r3, #4]
  c->used = i + 1;
 80234a4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80234a6:	1c5a      	adds	r2, r3, #1
 80234a8:	68fb      	ldr	r3, [r7, #12]
 80234aa:	601a      	str	r2, [r3, #0]
  c->sign = FP_ZPOS;
 80234ac:	68fb      	ldr	r3, [r7, #12]
 80234ae:	2200      	movs	r2, #0
 80234b0:	605a      	str	r2, [r3, #4]
  fp_clamp(c);
 80234b2:	e004      	b.n	80234be <fp_div_2_mod_ct+0x144>
 80234b4:	68fb      	ldr	r3, [r7, #12]
 80234b6:	681b      	ldr	r3, [r3, #0]
 80234b8:	1e5a      	subs	r2, r3, #1
 80234ba:	68fb      	ldr	r3, [r7, #12]
 80234bc:	601a      	str	r2, [r3, #0]
 80234be:	68fb      	ldr	r3, [r7, #12]
 80234c0:	681b      	ldr	r3, [r3, #0]
 80234c2:	2b00      	cmp	r3, #0
 80234c4:	d009      	beq.n	80234da <fp_div_2_mod_ct+0x160>
 80234c6:	68fb      	ldr	r3, [r7, #12]
 80234c8:	681b      	ldr	r3, [r3, #0]
 80234ca:	3b01      	subs	r3, #1
 80234cc:	68fa      	ldr	r2, [r7, #12]
 80234ce:	3302      	adds	r3, #2
 80234d0:	009b      	lsls	r3, r3, #2
 80234d2:	4413      	add	r3, r2
 80234d4:	685b      	ldr	r3, [r3, #4]
 80234d6:	2b00      	cmp	r3, #0
 80234d8:	d0ec      	beq.n	80234b4 <fp_div_2_mod_ct+0x13a>
 80234da:	68fb      	ldr	r3, [r7, #12]
 80234dc:	681b      	ldr	r3, [r3, #0]
 80234de:	2b00      	cmp	r3, #0
 80234e0:	d002      	beq.n	80234e8 <fp_div_2_mod_ct+0x16e>
 80234e2:	68fb      	ldr	r3, [r7, #12]
 80234e4:	685b      	ldr	r3, [r3, #4]
 80234e6:	e000      	b.n	80234ea <fp_div_2_mod_ct+0x170>
 80234e8:	2300      	movs	r3, #0
 80234ea:	68fa      	ldr	r2, [r7, #12]
 80234ec:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 80234ee:	2300      	movs	r3, #0
}
 80234f0:	4618      	mov	r0, r3
 80234f2:	3734      	adds	r7, #52	@ 0x34
 80234f4:	46bd      	mov	sp, r7
 80234f6:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80234fa:	4770      	bx	lr

080234fc <fp_div_2d>:

/* c = a / 2**b */
void fp_div_2d(fp_int *a, int b, fp_int *c, fp_int *d)
{
 80234fc:	b580      	push	{r7, lr}
 80234fe:	b086      	sub	sp, #24
 8023500:	af00      	add	r7, sp, #0
 8023502:	60f8      	str	r0, [r7, #12]
 8023504:	60b9      	str	r1, [r7, #8]
 8023506:	607a      	str	r2, [r7, #4]
 8023508:	603b      	str	r3, [r7, #0]
  int      D;

  /* if the shift count is <= 0 then we do no work */
  if (b <= 0) {
 802350a:	68bb      	ldr	r3, [r7, #8]
 802350c:	2b00      	cmp	r3, #0
 802350e:	dc0a      	bgt.n	8023526 <fp_div_2d+0x2a>
    fp_copy (a, c);
 8023510:	6879      	ldr	r1, [r7, #4]
 8023512:	68f8      	ldr	r0, [r7, #12]
 8023514:	f003 fabc 	bl	8026a90 <fp_copy>
    if (d != NULL) {
 8023518:	683b      	ldr	r3, [r7, #0]
 802351a:	2b00      	cmp	r3, #0
 802351c:	d05a      	beq.n	80235d4 <fp_div_2d+0xd8>
      fp_zero (d);
 802351e:	6838      	ldr	r0, [r7, #0]
 8023520:	f003 f8da 	bl	80266d8 <fp_zero>
    }
    return;
 8023524:	e056      	b.n	80235d4 <fp_div_2d+0xd8>
  }

  /* get the remainder before a is changed in calculating c */
  if (a == c && d != NULL) {
 8023526:	68fa      	ldr	r2, [r7, #12]
 8023528:	687b      	ldr	r3, [r7, #4]
 802352a:	429a      	cmp	r2, r3
 802352c:	d107      	bne.n	802353e <fp_div_2d+0x42>
 802352e:	683b      	ldr	r3, [r7, #0]
 8023530:	2b00      	cmp	r3, #0
 8023532:	d004      	beq.n	802353e <fp_div_2d+0x42>
    fp_mod_2d (a, b, d);
 8023534:	683a      	ldr	r2, [r7, #0]
 8023536:	68b9      	ldr	r1, [r7, #8]
 8023538:	68f8      	ldr	r0, [r7, #12]
 802353a:	f000 f88f 	bl	802365c <fp_mod_2d>
  }

  /* copy */
  fp_copy(a, c);
 802353e:	6879      	ldr	r1, [r7, #4]
 8023540:	68f8      	ldr	r0, [r7, #12]
 8023542:	f003 faa5 	bl	8026a90 <fp_copy>

  /* shift by as many digits in the bit count */
  if (b >= (int)DIGIT_BIT) {
 8023546:	68bb      	ldr	r3, [r7, #8]
 8023548:	2b1f      	cmp	r3, #31
 802354a:	dd08      	ble.n	802355e <fp_div_2d+0x62>
    fp_rshd (c, b / DIGIT_BIT);
 802354c:	68bb      	ldr	r3, [r7, #8]
 802354e:	2b00      	cmp	r3, #0
 8023550:	da00      	bge.n	8023554 <fp_div_2d+0x58>
 8023552:	331f      	adds	r3, #31
 8023554:	115b      	asrs	r3, r3, #5
 8023556:	4619      	mov	r1, r3
 8023558:	6878      	ldr	r0, [r7, #4]
 802355a:	f003 f804 	bl	8026566 <fp_rshd>
  }

  /* shift any bit count < DIGIT_BIT */
  D = (b % DIGIT_BIT);
 802355e:	68bb      	ldr	r3, [r7, #8]
 8023560:	425a      	negs	r2, r3
 8023562:	f003 031f 	and.w	r3, r3, #31
 8023566:	f002 021f 	and.w	r2, r2, #31
 802356a:	bf58      	it	pl
 802356c:	4253      	negpl	r3, r2
 802356e:	617b      	str	r3, [r7, #20]
  if (D != 0) {
 8023570:	697b      	ldr	r3, [r7, #20]
 8023572:	2b00      	cmp	r3, #0
 8023574:	d003      	beq.n	802357e <fp_div_2d+0x82>
    fp_rshb(c, D);
 8023576:	6979      	ldr	r1, [r7, #20]
 8023578:	6878      	ldr	r0, [r7, #4]
 802357a:	f002 ff70 	bl	802645e <fp_rshb>
  }

  /* get the remainder if a is not changed in calculating c */
  if (a != c && d != NULL) {
 802357e:	68fa      	ldr	r2, [r7, #12]
 8023580:	687b      	ldr	r3, [r7, #4]
 8023582:	429a      	cmp	r2, r3
 8023584:	d00d      	beq.n	80235a2 <fp_div_2d+0xa6>
 8023586:	683b      	ldr	r3, [r7, #0]
 8023588:	2b00      	cmp	r3, #0
 802358a:	d00a      	beq.n	80235a2 <fp_div_2d+0xa6>
    fp_mod_2d (a, b, d);
 802358c:	683a      	ldr	r2, [r7, #0]
 802358e:	68b9      	ldr	r1, [r7, #8]
 8023590:	68f8      	ldr	r0, [r7, #12]
 8023592:	f000 f863 	bl	802365c <fp_mod_2d>
  }

  fp_clamp (c);
 8023596:	e004      	b.n	80235a2 <fp_div_2d+0xa6>
 8023598:	687b      	ldr	r3, [r7, #4]
 802359a:	681b      	ldr	r3, [r3, #0]
 802359c:	1e5a      	subs	r2, r3, #1
 802359e:	687b      	ldr	r3, [r7, #4]
 80235a0:	601a      	str	r2, [r3, #0]
 80235a2:	687b      	ldr	r3, [r7, #4]
 80235a4:	681b      	ldr	r3, [r3, #0]
 80235a6:	2b00      	cmp	r3, #0
 80235a8:	d009      	beq.n	80235be <fp_div_2d+0xc2>
 80235aa:	687b      	ldr	r3, [r7, #4]
 80235ac:	681b      	ldr	r3, [r3, #0]
 80235ae:	3b01      	subs	r3, #1
 80235b0:	687a      	ldr	r2, [r7, #4]
 80235b2:	3302      	adds	r3, #2
 80235b4:	009b      	lsls	r3, r3, #2
 80235b6:	4413      	add	r3, r2
 80235b8:	685b      	ldr	r3, [r3, #4]
 80235ba:	2b00      	cmp	r3, #0
 80235bc:	d0ec      	beq.n	8023598 <fp_div_2d+0x9c>
 80235be:	687b      	ldr	r3, [r7, #4]
 80235c0:	681b      	ldr	r3, [r3, #0]
 80235c2:	2b00      	cmp	r3, #0
 80235c4:	d002      	beq.n	80235cc <fp_div_2d+0xd0>
 80235c6:	687b      	ldr	r3, [r7, #4]
 80235c8:	685b      	ldr	r3, [r3, #4]
 80235ca:	e000      	b.n	80235ce <fp_div_2d+0xd2>
 80235cc:	2300      	movs	r3, #0
 80235ce:	687a      	ldr	r2, [r7, #4]
 80235d0:	6053      	str	r3, [r2, #4]
 80235d2:	e000      	b.n	80235d6 <fp_div_2d+0xda>
    return;
 80235d4:	bf00      	nop
}
 80235d6:	3718      	adds	r7, #24
 80235d8:	46bd      	mov	sp, r7
 80235da:	bd80      	pop	{r7, pc}

080235dc <fp_mod>:

/* c = a mod b, 0 <= c < b  */
int fp_mod(fp_int *a, fp_int *b, fp_int *c)
{
 80235dc:	b580      	push	{r7, lr}
 80235de:	b088      	sub	sp, #32
 80235e0:	af00      	add	r7, sp, #0
 80235e2:	60f8      	str	r0, [r7, #12]
 80235e4:	60b9      	str	r1, [r7, #8]
 80235e6:	607a      	str	r2, [r7, #4]
   fp_int *t;
#endif
   int    err;

#ifdef WOLFSSL_SMALL_STACK
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 80235e8:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 80235ec:	f7fb fa52 	bl	801ea94 <wolfSSL_Malloc>
 80235f0:	61b8      	str	r0, [r7, #24]
   if (t == NULL)
 80235f2:	69bb      	ldr	r3, [r7, #24]
 80235f4:	2b00      	cmp	r3, #0
 80235f6:	d102      	bne.n	80235fe <fp_mod+0x22>
       return FP_MEM;
 80235f8:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80235fc:	e02a      	b.n	8023654 <fp_mod+0x78>
#endif

   fp_init(t);
 80235fe:	69b8      	ldr	r0, [r7, #24]
 8023600:	f003 f85c 	bl	80266bc <fp_init>
   err = fp_div(a, b, NULL, t);
 8023604:	69bb      	ldr	r3, [r7, #24]
 8023606:	2200      	movs	r2, #0
 8023608:	68b9      	ldr	r1, [r7, #8]
 802360a:	68f8      	ldr	r0, [r7, #12]
 802360c:	f7ff fb3e 	bl	8022c8c <fp_div>
 8023610:	61f8      	str	r0, [r7, #28]
   if (err == FP_OKAY) {
 8023612:	69fb      	ldr	r3, [r7, #28]
 8023614:	2b00      	cmp	r3, #0
 8023616:	d114      	bne.n	8023642 <fp_mod+0x66>
      if (!fp_iszero(t) && (t->sign != b->sign)) {
 8023618:	69bb      	ldr	r3, [r7, #24]
 802361a:	681b      	ldr	r3, [r3, #0]
 802361c:	2b00      	cmp	r3, #0
 802361e:	d00c      	beq.n	802363a <fp_mod+0x5e>
 8023620:	69bb      	ldr	r3, [r7, #24]
 8023622:	685a      	ldr	r2, [r3, #4]
 8023624:	68bb      	ldr	r3, [r7, #8]
 8023626:	685b      	ldr	r3, [r3, #4]
 8023628:	429a      	cmp	r2, r3
 802362a:	d006      	beq.n	802363a <fp_mod+0x5e>
         err = fp_add(t, b, c);
 802362c:	687a      	ldr	r2, [r7, #4]
 802362e:	68b9      	ldr	r1, [r7, #8]
 8023630:	69b8      	ldr	r0, [r7, #24]
 8023632:	f7fe fe54 	bl	80222de <fp_add>
 8023636:	61f8      	str	r0, [r7, #28]
 8023638:	e003      	b.n	8023642 <fp_mod+0x66>
      } else {
         fp_copy(t, c);
 802363a:	6879      	ldr	r1, [r7, #4]
 802363c:	69b8      	ldr	r0, [r7, #24]
 802363e:	f003 fa27 	bl	8026a90 <fp_copy>
     }
  }

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 8023642:	69bb      	ldr	r3, [r7, #24]
 8023644:	617b      	str	r3, [r7, #20]
 8023646:	697b      	ldr	r3, [r7, #20]
 8023648:	2b00      	cmp	r3, #0
 802364a:	d002      	beq.n	8023652 <fp_mod+0x76>
 802364c:	6978      	ldr	r0, [r7, #20]
 802364e:	f7fb fa3d 	bl	801eacc <wolfSSL_Free>
#endif
  return err;
 8023652:	69fb      	ldr	r3, [r7, #28]
}
 8023654:	4618      	mov	r0, r3
 8023656:	3720      	adds	r7, #32
 8023658:	46bd      	mov	sp, r7
 802365a:	bd80      	pop	{r7, pc}

0802365c <fp_mod_2d>:

/* c = a mod 2**d */
void fp_mod_2d(fp_int *a, int b, fp_int *c)
{
 802365c:	b580      	push	{r7, lr}
 802365e:	b088      	sub	sp, #32
 8023660:	af00      	add	r7, sp, #0
 8023662:	60f8      	str	r0, [r7, #12]
 8023664:	60b9      	str	r1, [r7, #8]
 8023666:	607a      	str	r2, [r7, #4]
   unsigned int x;
   unsigned int bmax;

   /* zero if count less than or equal to zero */
   if (b <= 0) {
 8023668:	68bb      	ldr	r3, [r7, #8]
 802366a:	2b00      	cmp	r3, #0
 802366c:	dc03      	bgt.n	8023676 <fp_mod_2d+0x1a>
      fp_zero(c);
 802366e:	6878      	ldr	r0, [r7, #4]
 8023670:	f003 f832 	bl	80266d8 <fp_zero>
      return;
 8023674:	e0b7      	b.n	80237e6 <fp_mod_2d+0x18a>
   }

   /* get copy of input */
   fp_copy(a, c);
 8023676:	6879      	ldr	r1, [r7, #4]
 8023678:	68f8      	ldr	r0, [r7, #12]
 802367a:	f003 fa09 	bl	8026a90 <fp_copy>

   /* if 2**d is larger than we just return */
   if (c->sign == FP_ZPOS && b >= (DIGIT_BIT * a->used)) {
 802367e:	687b      	ldr	r3, [r7, #4]
 8023680:	685b      	ldr	r3, [r3, #4]
 8023682:	2b00      	cmp	r3, #0
 8023684:	d106      	bne.n	8023694 <fp_mod_2d+0x38>
 8023686:	68fb      	ldr	r3, [r7, #12]
 8023688:	681b      	ldr	r3, [r3, #0]
 802368a:	015b      	lsls	r3, r3, #5
 802368c:	68ba      	ldr	r2, [r7, #8]
 802368e:	429a      	cmp	r2, r3
 8023690:	f280 80a6 	bge.w	80237e0 <fp_mod_2d+0x184>
      return;
   }

   bmax = ((unsigned int)b + DIGIT_BIT - 1) / DIGIT_BIT;
 8023694:	68bb      	ldr	r3, [r7, #8]
 8023696:	331f      	adds	r3, #31
 8023698:	095b      	lsrs	r3, r3, #5
 802369a:	617b      	str	r3, [r7, #20]

   /* If a is negative and bmax is greater than or equal to FP_SIZE, then the
    * result can't fit within c. Just return. */
   if (c->sign == FP_NEG && bmax >= FP_SIZE) {
 802369c:	687b      	ldr	r3, [r7, #4]
 802369e:	685b      	ldr	r3, [r3, #4]
 80236a0:	2b01      	cmp	r3, #1
 80236a2:	d103      	bne.n	80236ac <fp_mod_2d+0x50>
 80236a4:	697b      	ldr	r3, [r7, #20]
 80236a6:	2b87      	cmp	r3, #135	@ 0x87
 80236a8:	f200 809c 	bhi.w	80237e4 <fp_mod_2d+0x188>
      return;
   }

  /* zero digits above the last digit of the modulus */
   for (x = bmax; x < (unsigned int)c->used; x++) {
 80236ac:	697b      	ldr	r3, [r7, #20]
 80236ae:	61fb      	str	r3, [r7, #28]
 80236b0:	e009      	b.n	80236c6 <fp_mod_2d+0x6a>
    c->dp[x] = 0;
 80236b2:	687a      	ldr	r2, [r7, #4]
 80236b4:	69fb      	ldr	r3, [r7, #28]
 80236b6:	3302      	adds	r3, #2
 80236b8:	009b      	lsls	r3, r3, #2
 80236ba:	4413      	add	r3, r2
 80236bc:	2200      	movs	r2, #0
 80236be:	605a      	str	r2, [r3, #4]
   for (x = bmax; x < (unsigned int)c->used; x++) {
 80236c0:	69fb      	ldr	r3, [r7, #28]
 80236c2:	3301      	adds	r3, #1
 80236c4:	61fb      	str	r3, [r7, #28]
 80236c6:	687b      	ldr	r3, [r7, #4]
 80236c8:	681b      	ldr	r3, [r3, #0]
 80236ca:	461a      	mov	r2, r3
 80236cc:	69fb      	ldr	r3, [r7, #28]
 80236ce:	4293      	cmp	r3, r2
 80236d0:	d3ef      	bcc.n	80236b2 <fp_mod_2d+0x56>
  }

  if (c->sign == FP_NEG) {
 80236d2:	687b      	ldr	r3, [r7, #4]
 80236d4:	685b      	ldr	r3, [r3, #4]
 80236d6:	2b01      	cmp	r3, #1
 80236d8:	d142      	bne.n	8023760 <fp_mod_2d+0x104>
     fp_digit carry = 0;
 80236da:	2300      	movs	r3, #0
 80236dc:	61bb      	str	r3, [r7, #24]
     /* negate value */
     for (x = 0; x < (unsigned int)c->used; x++) {
 80236de:	2300      	movs	r3, #0
 80236e0:	61fb      	str	r3, [r7, #28]
 80236e2:	e021      	b.n	8023728 <fp_mod_2d+0xcc>
         fp_digit next = c->dp[x] > 0;
 80236e4:	687a      	ldr	r2, [r7, #4]
 80236e6:	69fb      	ldr	r3, [r7, #28]
 80236e8:	3302      	adds	r3, #2
 80236ea:	009b      	lsls	r3, r3, #2
 80236ec:	4413      	add	r3, r2
 80236ee:	685b      	ldr	r3, [r3, #4]
 80236f0:	2b00      	cmp	r3, #0
 80236f2:	bf14      	ite	ne
 80236f4:	2301      	movne	r3, #1
 80236f6:	2300      	moveq	r3, #0
 80236f8:	b2db      	uxtb	r3, r3
 80236fa:	613b      	str	r3, [r7, #16]
         c->dp[x] = (fp_digit)0 - c->dp[x] - carry;
 80236fc:	687a      	ldr	r2, [r7, #4]
 80236fe:	69fb      	ldr	r3, [r7, #28]
 8023700:	3302      	adds	r3, #2
 8023702:	009b      	lsls	r3, r3, #2
 8023704:	4413      	add	r3, r2
 8023706:	685b      	ldr	r3, [r3, #4]
 8023708:	425a      	negs	r2, r3
 802370a:	69bb      	ldr	r3, [r7, #24]
 802370c:	1ad2      	subs	r2, r2, r3
 802370e:	6879      	ldr	r1, [r7, #4]
 8023710:	69fb      	ldr	r3, [r7, #28]
 8023712:	3302      	adds	r3, #2
 8023714:	009b      	lsls	r3, r3, #2
 8023716:	440b      	add	r3, r1
 8023718:	605a      	str	r2, [r3, #4]
         carry |= next;
 802371a:	69ba      	ldr	r2, [r7, #24]
 802371c:	693b      	ldr	r3, [r7, #16]
 802371e:	4313      	orrs	r3, r2
 8023720:	61bb      	str	r3, [r7, #24]
     for (x = 0; x < (unsigned int)c->used; x++) {
 8023722:	69fb      	ldr	r3, [r7, #28]
 8023724:	3301      	adds	r3, #1
 8023726:	61fb      	str	r3, [r7, #28]
 8023728:	687b      	ldr	r3, [r7, #4]
 802372a:	681b      	ldr	r3, [r3, #0]
 802372c:	461a      	mov	r2, r3
 802372e:	69fb      	ldr	r3, [r7, #28]
 8023730:	4293      	cmp	r3, r2
 8023732:	d3d7      	bcc.n	80236e4 <fp_mod_2d+0x88>
     }
     for (; x < bmax; x++) {
 8023734:	e00a      	b.n	802374c <fp_mod_2d+0xf0>
         c->dp[x] = (fp_digit)0 - carry;
 8023736:	69bb      	ldr	r3, [r7, #24]
 8023738:	425a      	negs	r2, r3
 802373a:	6879      	ldr	r1, [r7, #4]
 802373c:	69fb      	ldr	r3, [r7, #28]
 802373e:	3302      	adds	r3, #2
 8023740:	009b      	lsls	r3, r3, #2
 8023742:	440b      	add	r3, r1
 8023744:	605a      	str	r2, [r3, #4]
     for (; x < bmax; x++) {
 8023746:	69fb      	ldr	r3, [r7, #28]
 8023748:	3301      	adds	r3, #1
 802374a:	61fb      	str	r3, [r7, #28]
 802374c:	69fa      	ldr	r2, [r7, #28]
 802374e:	697b      	ldr	r3, [r7, #20]
 8023750:	429a      	cmp	r2, r3
 8023752:	d3f0      	bcc.n	8023736 <fp_mod_2d+0xda>
     }
     c->used = (int)bmax;
 8023754:	697a      	ldr	r2, [r7, #20]
 8023756:	687b      	ldr	r3, [r7, #4]
 8023758:	601a      	str	r2, [r3, #0]
     c->sign = FP_ZPOS;
 802375a:	687b      	ldr	r3, [r7, #4]
 802375c:	2200      	movs	r2, #0
 802375e:	605a      	str	r2, [r3, #4]
  }

  /* clear the digit that is not completely outside/inside the modulus */
  x = DIGIT_BIT - (b % DIGIT_BIT);
 8023760:	68bb      	ldr	r3, [r7, #8]
 8023762:	425a      	negs	r2, r3
 8023764:	f003 031f 	and.w	r3, r3, #31
 8023768:	f002 021f 	and.w	r2, r2, #31
 802376c:	bf58      	it	pl
 802376e:	4253      	negpl	r3, r2
 8023770:	f1c3 0320 	rsb	r3, r3, #32
 8023774:	61fb      	str	r3, [r7, #28]
  if (x != DIGIT_BIT) {
 8023776:	69fb      	ldr	r3, [r7, #28]
 8023778:	2b20      	cmp	r3, #32
 802377a:	d018      	beq.n	80237ae <fp_mod_2d+0x152>
     c->dp[bmax - 1] &= ~((fp_digit)0) >> x;
 802377c:	697b      	ldr	r3, [r7, #20]
 802377e:	3b01      	subs	r3, #1
 8023780:	687a      	ldr	r2, [r7, #4]
 8023782:	3302      	adds	r3, #2
 8023784:	009b      	lsls	r3, r3, #2
 8023786:	4413      	add	r3, r2
 8023788:	6859      	ldr	r1, [r3, #4]
 802378a:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 802378e:	69fb      	ldr	r3, [r7, #28]
 8023790:	40da      	lsrs	r2, r3
 8023792:	697b      	ldr	r3, [r7, #20]
 8023794:	3b01      	subs	r3, #1
 8023796:	400a      	ands	r2, r1
 8023798:	6879      	ldr	r1, [r7, #4]
 802379a:	3302      	adds	r3, #2
 802379c:	009b      	lsls	r3, r3, #2
 802379e:	440b      	add	r3, r1
 80237a0:	605a      	str	r2, [r3, #4]
  }

  fp_clamp (c);
 80237a2:	e004      	b.n	80237ae <fp_mod_2d+0x152>
 80237a4:	687b      	ldr	r3, [r7, #4]
 80237a6:	681b      	ldr	r3, [r3, #0]
 80237a8:	1e5a      	subs	r2, r3, #1
 80237aa:	687b      	ldr	r3, [r7, #4]
 80237ac:	601a      	str	r2, [r3, #0]
 80237ae:	687b      	ldr	r3, [r7, #4]
 80237b0:	681b      	ldr	r3, [r3, #0]
 80237b2:	2b00      	cmp	r3, #0
 80237b4:	d009      	beq.n	80237ca <fp_mod_2d+0x16e>
 80237b6:	687b      	ldr	r3, [r7, #4]
 80237b8:	681b      	ldr	r3, [r3, #0]
 80237ba:	3b01      	subs	r3, #1
 80237bc:	687a      	ldr	r2, [r7, #4]
 80237be:	3302      	adds	r3, #2
 80237c0:	009b      	lsls	r3, r3, #2
 80237c2:	4413      	add	r3, r2
 80237c4:	685b      	ldr	r3, [r3, #4]
 80237c6:	2b00      	cmp	r3, #0
 80237c8:	d0ec      	beq.n	80237a4 <fp_mod_2d+0x148>
 80237ca:	687b      	ldr	r3, [r7, #4]
 80237cc:	681b      	ldr	r3, [r3, #0]
 80237ce:	2b00      	cmp	r3, #0
 80237d0:	d002      	beq.n	80237d8 <fp_mod_2d+0x17c>
 80237d2:	687b      	ldr	r3, [r7, #4]
 80237d4:	685b      	ldr	r3, [r3, #4]
 80237d6:	e000      	b.n	80237da <fp_mod_2d+0x17e>
 80237d8:	2300      	movs	r3, #0
 80237da:	687a      	ldr	r2, [r7, #4]
 80237dc:	6053      	str	r3, [r2, #4]
 80237de:	e002      	b.n	80237e6 <fp_mod_2d+0x18a>
      return;
 80237e0:	bf00      	nop
 80237e2:	e000      	b.n	80237e6 <fp_mod_2d+0x18a>
      return;
 80237e4:	bf00      	nop
}
 80237e6:	3720      	adds	r7, #32
 80237e8:	46bd      	mov	sp, r7
 80237ea:	bd80      	pop	{r7, pc}

080237ec <fp_invmod_slow>:

static int fp_invmod_slow (fp_int * a, fp_int * b, fp_int * c)
{
 80237ec:	b580      	push	{r7, lr}
 80237ee:	b09e      	sub	sp, #120	@ 0x78
 80237f0:	af00      	add	r7, sp, #0
 80237f2:	60f8      	str	r0, [r7, #12]
 80237f4:	60b9      	str	r1, [r7, #8]
 80237f6:	607a      	str	r2, [r7, #4]
  fp_int  *x, *y, *u, *v, *A, *B, *C, *D;
#endif
  int     err;

  /* b cannot be negative */
  if (b->sign == FP_NEG || fp_iszero(b) == FP_YES) {
 80237f8:	68bb      	ldr	r3, [r7, #8]
 80237fa:	685b      	ldr	r3, [r3, #4]
 80237fc:	2b01      	cmp	r3, #1
 80237fe:	d003      	beq.n	8023808 <fp_invmod_slow+0x1c>
 8023800:	68bb      	ldr	r3, [r7, #8]
 8023802:	681b      	ldr	r3, [r3, #0]
 8023804:	2b00      	cmp	r3, #0
 8023806:	d102      	bne.n	802380e <fp_invmod_slow+0x22>
    return FP_VAL;
 8023808:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802380c:	e239      	b.n	8023c82 <fp_invmod_slow+0x496>
  }
  if (fp_iszero(a) == FP_YES) {
 802380e:	68fb      	ldr	r3, [r7, #12]
 8023810:	681b      	ldr	r3, [r3, #0]
 8023812:	2b00      	cmp	r3, #0
 8023814:	d102      	bne.n	802381c <fp_invmod_slow+0x30>
    return FP_VAL;
 8023816:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802381a:	e232      	b.n	8023c82 <fp_invmod_slow+0x496>
  }

#ifdef WOLFSSL_SMALL_STACK
  x = (fp_int*)XMALLOC(sizeof(fp_int) * 8, NULL, DYNAMIC_TYPE_BIGINT);
 802381c:	f44f 508b 	mov.w	r0, #4448	@ 0x1160
 8023820:	f7fb f938 	bl	801ea94 <wolfSSL_Malloc>
 8023824:	6778      	str	r0, [r7, #116]	@ 0x74
  if (x == NULL) {
 8023826:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023828:	2b00      	cmp	r3, #0
 802382a:	d102      	bne.n	8023832 <fp_invmod_slow+0x46>
      return FP_MEM;
 802382c:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8023830:	e227      	b.n	8023c82 <fp_invmod_slow+0x496>
  }
  y = &x[1]; u = &x[2]; v = &x[3]; A = &x[4]; B = &x[5]; C = &x[6]; D = &x[7];
 8023832:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023834:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8023838:	673b      	str	r3, [r7, #112]	@ 0x70
 802383a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802383c:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8023840:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8023842:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023844:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8023848:	66bb      	str	r3, [r7, #104]	@ 0x68
 802384a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802384c:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8023850:	667b      	str	r3, [r7, #100]	@ 0x64
 8023852:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023854:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 8023858:	663b      	str	r3, [r7, #96]	@ 0x60
 802385a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802385c:	f603 5308 	addw	r3, r3, #3336	@ 0xd08
 8023860:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8023862:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023864:	f603 7334 	addw	r3, r3, #3892	@ 0xf34
 8023868:	65bb      	str	r3, [r7, #88]	@ 0x58
#endif

  /* init temps */
  fp_init(x);    fp_init(y);
 802386a:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 802386c:	f002 ff26 	bl	80266bc <fp_init>
 8023870:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8023872:	f002 ff23 	bl	80266bc <fp_init>
  fp_init(u);    fp_init(v);
 8023876:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023878:	f002 ff20 	bl	80266bc <fp_init>
 802387c:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 802387e:	f002 ff1d 	bl	80266bc <fp_init>
  fp_init(A);    fp_init(B);
 8023882:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023884:	f002 ff1a 	bl	80266bc <fp_init>
 8023888:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 802388a:	f002 ff17 	bl	80266bc <fp_init>
  fp_init(C);    fp_init(D);
 802388e:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023890:	f002 ff14 	bl	80266bc <fp_init>
 8023894:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023896:	f002 ff11 	bl	80266bc <fp_init>

  /* x = a, y = b */
  if ((err = fp_mod(a, b, x)) != FP_OKAY) {
 802389a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802389c:	68b9      	ldr	r1, [r7, #8]
 802389e:	68f8      	ldr	r0, [r7, #12]
 80238a0:	f7ff fe9c 	bl	80235dc <fp_mod>
 80238a4:	6578      	str	r0, [r7, #84]	@ 0x54
 80238a6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80238a8:	2b00      	cmp	r3, #0
 80238aa:	d009      	beq.n	80238c0 <fp_invmod_slow+0xd4>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80238ac:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80238ae:	613b      	str	r3, [r7, #16]
 80238b0:	693b      	ldr	r3, [r7, #16]
 80238b2:	2b00      	cmp	r3, #0
 80238b4:	d002      	beq.n	80238bc <fp_invmod_slow+0xd0>
 80238b6:	6938      	ldr	r0, [r7, #16]
 80238b8:	f7fb f908 	bl	801eacc <wolfSSL_Free>
  #endif
    return err;
 80238bc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80238be:	e1e0      	b.n	8023c82 <fp_invmod_slow+0x496>
  }
  fp_copy(b, y);
 80238c0:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80238c2:	68b8      	ldr	r0, [r7, #8]
 80238c4:	f003 f8e4 	bl	8026a90 <fp_copy>

  if (fp_iszero(x) == FP_YES) {
 80238c8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80238ca:	681b      	ldr	r3, [r3, #0]
 80238cc:	2b00      	cmp	r3, #0
 80238ce:	d10a      	bne.n	80238e6 <fp_invmod_slow+0xfa>
    /* invmod doesn't exist for this a and b */
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80238d0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80238d2:	617b      	str	r3, [r7, #20]
 80238d4:	697b      	ldr	r3, [r7, #20]
 80238d6:	2b00      	cmp	r3, #0
 80238d8:	d002      	beq.n	80238e0 <fp_invmod_slow+0xf4>
 80238da:	6978      	ldr	r0, [r7, #20]
 80238dc:	f7fb f8f6 	bl	801eacc <wolfSSL_Free>
  #endif
    return FP_VAL;
 80238e0:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80238e4:	e1cd      	b.n	8023c82 <fp_invmod_slow+0x496>
  }

  /* 2. [modified] if x,y are both even then return an error! */
  if (fp_iseven(x) == FP_YES && fp_iseven(y) == FP_YES) {
 80238e6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80238e8:	681b      	ldr	r3, [r3, #0]
 80238ea:	2b00      	cmp	r3, #0
 80238ec:	dd07      	ble.n	80238fe <fp_invmod_slow+0x112>
 80238ee:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80238f0:	68db      	ldr	r3, [r3, #12]
 80238f2:	f003 0301 	and.w	r3, r3, #1
 80238f6:	2b00      	cmp	r3, #0
 80238f8:	d101      	bne.n	80238fe <fp_invmod_slow+0x112>
 80238fa:	2301      	movs	r3, #1
 80238fc:	e000      	b.n	8023900 <fp_invmod_slow+0x114>
 80238fe:	2300      	movs	r3, #0
 8023900:	2b01      	cmp	r3, #1
 8023902:	d119      	bne.n	8023938 <fp_invmod_slow+0x14c>
 8023904:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8023906:	681b      	ldr	r3, [r3, #0]
 8023908:	2b00      	cmp	r3, #0
 802390a:	dd07      	ble.n	802391c <fp_invmod_slow+0x130>
 802390c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 802390e:	68db      	ldr	r3, [r3, #12]
 8023910:	f003 0301 	and.w	r3, r3, #1
 8023914:	2b00      	cmp	r3, #0
 8023916:	d101      	bne.n	802391c <fp_invmod_slow+0x130>
 8023918:	2301      	movs	r3, #1
 802391a:	e000      	b.n	802391e <fp_invmod_slow+0x132>
 802391c:	2300      	movs	r3, #0
 802391e:	2b01      	cmp	r3, #1
 8023920:	d10a      	bne.n	8023938 <fp_invmod_slow+0x14c>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023922:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023924:	653b      	str	r3, [r7, #80]	@ 0x50
 8023926:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8023928:	2b00      	cmp	r3, #0
 802392a:	d002      	beq.n	8023932 <fp_invmod_slow+0x146>
 802392c:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 802392e:	f7fb f8cd 	bl	801eacc <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023932:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023936:	e1a4      	b.n	8023c82 <fp_invmod_slow+0x496>
  }

  /* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
  fp_copy (x, u);
 8023938:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 802393a:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 802393c:	f003 f8a8 	bl	8026a90 <fp_copy>
  fp_copy (y, v);
 8023940:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023942:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8023944:	f003 f8a4 	bl	8026a90 <fp_copy>
  fp_set (A, 1);
 8023948:	2101      	movs	r1, #1
 802394a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 802394c:	f002 fc87 	bl	802625e <fp_set>
  fp_set (D, 1);
 8023950:	2101      	movs	r1, #1
 8023952:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023954:	f002 fc83 	bl	802625e <fp_set>

top:
  /* 4.  while u is even do */
  while (fp_iseven (u) == FP_YES) {
 8023958:	e04f      	b.n	80239fa <fp_invmod_slow+0x20e>
    /* 4.1 u = u/2 */
    fp_div_2 (u, u);
 802395a:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 802395c:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 802395e:	f7ff fc8a 	bl	8023276 <fp_div_2>

    /* 4.2 if A or B is odd then */
    if (fp_isodd (A) == FP_YES || fp_isodd (B) == FP_YES) {
 8023962:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8023964:	681b      	ldr	r3, [r3, #0]
 8023966:	2b00      	cmp	r3, #0
 8023968:	dd07      	ble.n	802397a <fp_invmod_slow+0x18e>
 802396a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802396c:	68db      	ldr	r3, [r3, #12]
 802396e:	f003 0301 	and.w	r3, r3, #1
 8023972:	2b00      	cmp	r3, #0
 8023974:	d001      	beq.n	802397a <fp_invmod_slow+0x18e>
 8023976:	2301      	movs	r3, #1
 8023978:	e000      	b.n	802397c <fp_invmod_slow+0x190>
 802397a:	2300      	movs	r3, #0
 802397c:	2b01      	cmp	r3, #1
 802397e:	d00e      	beq.n	802399e <fp_invmod_slow+0x1b2>
 8023980:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8023982:	681b      	ldr	r3, [r3, #0]
 8023984:	2b00      	cmp	r3, #0
 8023986:	dd07      	ble.n	8023998 <fp_invmod_slow+0x1ac>
 8023988:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 802398a:	68db      	ldr	r3, [r3, #12]
 802398c:	f003 0301 	and.w	r3, r3, #1
 8023990:	2b00      	cmp	r3, #0
 8023992:	d001      	beq.n	8023998 <fp_invmod_slow+0x1ac>
 8023994:	2301      	movs	r3, #1
 8023996:	e000      	b.n	802399a <fp_invmod_slow+0x1ae>
 8023998:	2300      	movs	r3, #0
 802399a:	2b01      	cmp	r3, #1
 802399c:	d125      	bne.n	80239ea <fp_invmod_slow+0x1fe>
      /* A = (A+y)/2, B = (B-x)/2 */
      err = fp_add (A, y, A);
 802399e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80239a0:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80239a2:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80239a4:	f7fe fc9b 	bl	80222de <fp_add>
 80239a8:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 80239aa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80239ac:	2b00      	cmp	r3, #0
 80239ae:	d009      	beq.n	80239c4 <fp_invmod_slow+0x1d8>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80239b0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80239b2:	61bb      	str	r3, [r7, #24]
 80239b4:	69bb      	ldr	r3, [r7, #24]
 80239b6:	2b00      	cmp	r3, #0
 80239b8:	d002      	beq.n	80239c0 <fp_invmod_slow+0x1d4>
 80239ba:	69b8      	ldr	r0, [r7, #24]
 80239bc:	f7fb f886 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 80239c0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80239c2:	e15e      	b.n	8023c82 <fp_invmod_slow+0x496>
      }
      err = fp_sub (B, x, B);
 80239c4:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80239c6:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 80239c8:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80239ca:	f7fe fd6a 	bl	80224a2 <fp_sub>
 80239ce:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 80239d0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80239d2:	2b00      	cmp	r3, #0
 80239d4:	d009      	beq.n	80239ea <fp_invmod_slow+0x1fe>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 80239d6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80239d8:	61fb      	str	r3, [r7, #28]
 80239da:	69fb      	ldr	r3, [r7, #28]
 80239dc:	2b00      	cmp	r3, #0
 80239de:	d002      	beq.n	80239e6 <fp_invmod_slow+0x1fa>
 80239e0:	69f8      	ldr	r0, [r7, #28]
 80239e2:	f7fb f873 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 80239e6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80239e8:	e14b      	b.n	8023c82 <fp_invmod_slow+0x496>
      }
    }
    /* A = A/2, B = B/2 */
    fp_div_2 (A, A);
 80239ea:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 80239ec:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 80239ee:	f7ff fc42 	bl	8023276 <fp_div_2>
    fp_div_2 (B, B);
 80239f2:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80239f4:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80239f6:	f7ff fc3e 	bl	8023276 <fp_div_2>
  while (fp_iseven (u) == FP_YES) {
 80239fa:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80239fc:	681b      	ldr	r3, [r3, #0]
 80239fe:	2b00      	cmp	r3, #0
 8023a00:	dd07      	ble.n	8023a12 <fp_invmod_slow+0x226>
 8023a02:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023a04:	68db      	ldr	r3, [r3, #12]
 8023a06:	f003 0301 	and.w	r3, r3, #1
 8023a0a:	2b00      	cmp	r3, #0
 8023a0c:	d101      	bne.n	8023a12 <fp_invmod_slow+0x226>
 8023a0e:	2301      	movs	r3, #1
 8023a10:	e000      	b.n	8023a14 <fp_invmod_slow+0x228>
 8023a12:	2300      	movs	r3, #0
 8023a14:	2b01      	cmp	r3, #1
 8023a16:	d0a0      	beq.n	802395a <fp_invmod_slow+0x16e>
  }

  /* 5.  while v is even do */
  while (fp_iseven (v) == FP_YES) {
 8023a18:	e04f      	b.n	8023aba <fp_invmod_slow+0x2ce>
    /* 5.1 v = v/2 */
    fp_div_2 (v, v);
 8023a1a:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023a1c:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023a1e:	f7ff fc2a 	bl	8023276 <fp_div_2>

    /* 5.2 if C or D is odd then */
    if (fp_isodd (C) == FP_YES || fp_isodd (D) == FP_YES) {
 8023a22:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023a24:	681b      	ldr	r3, [r3, #0]
 8023a26:	2b00      	cmp	r3, #0
 8023a28:	dd07      	ble.n	8023a3a <fp_invmod_slow+0x24e>
 8023a2a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023a2c:	68db      	ldr	r3, [r3, #12]
 8023a2e:	f003 0301 	and.w	r3, r3, #1
 8023a32:	2b00      	cmp	r3, #0
 8023a34:	d001      	beq.n	8023a3a <fp_invmod_slow+0x24e>
 8023a36:	2301      	movs	r3, #1
 8023a38:	e000      	b.n	8023a3c <fp_invmod_slow+0x250>
 8023a3a:	2300      	movs	r3, #0
 8023a3c:	2b01      	cmp	r3, #1
 8023a3e:	d00e      	beq.n	8023a5e <fp_invmod_slow+0x272>
 8023a40:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8023a42:	681b      	ldr	r3, [r3, #0]
 8023a44:	2b00      	cmp	r3, #0
 8023a46:	dd07      	ble.n	8023a58 <fp_invmod_slow+0x26c>
 8023a48:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8023a4a:	68db      	ldr	r3, [r3, #12]
 8023a4c:	f003 0301 	and.w	r3, r3, #1
 8023a50:	2b00      	cmp	r3, #0
 8023a52:	d001      	beq.n	8023a58 <fp_invmod_slow+0x26c>
 8023a54:	2301      	movs	r3, #1
 8023a56:	e000      	b.n	8023a5a <fp_invmod_slow+0x26e>
 8023a58:	2300      	movs	r3, #0
 8023a5a:	2b01      	cmp	r3, #1
 8023a5c:	d125      	bne.n	8023aaa <fp_invmod_slow+0x2be>
      /* C = (C+y)/2, D = (D-x)/2 */
      err = fp_add (C, y, C);
 8023a5e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023a60:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8023a62:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023a64:	f7fe fc3b 	bl	80222de <fp_add>
 8023a68:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 8023a6a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023a6c:	2b00      	cmp	r3, #0
 8023a6e:	d009      	beq.n	8023a84 <fp_invmod_slow+0x298>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023a70:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023a72:	623b      	str	r3, [r7, #32]
 8023a74:	6a3b      	ldr	r3, [r7, #32]
 8023a76:	2b00      	cmp	r3, #0
 8023a78:	d002      	beq.n	8023a80 <fp_invmod_slow+0x294>
 8023a7a:	6a38      	ldr	r0, [r7, #32]
 8023a7c:	f7fb f826 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 8023a80:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023a82:	e0fe      	b.n	8023c82 <fp_invmod_slow+0x496>
      }
      err = fp_sub (D, x, D);
 8023a84:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8023a86:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8023a88:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023a8a:	f7fe fd0a 	bl	80224a2 <fp_sub>
 8023a8e:	6578      	str	r0, [r7, #84]	@ 0x54
      if (err != FP_OKAY) {
 8023a90:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023a92:	2b00      	cmp	r3, #0
 8023a94:	d009      	beq.n	8023aaa <fp_invmod_slow+0x2be>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023a96:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023a98:	627b      	str	r3, [r7, #36]	@ 0x24
 8023a9a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023a9c:	2b00      	cmp	r3, #0
 8023a9e:	d002      	beq.n	8023aa6 <fp_invmod_slow+0x2ba>
 8023aa0:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8023aa2:	f7fb f813 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 8023aa6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023aa8:	e0eb      	b.n	8023c82 <fp_invmod_slow+0x496>
      }
    }
    /* C = C/2, D = D/2 */
    fp_div_2 (C, C);
 8023aaa:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023aac:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023aae:	f7ff fbe2 	bl	8023276 <fp_div_2>
    fp_div_2 (D, D);
 8023ab2:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 8023ab4:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023ab6:	f7ff fbde 	bl	8023276 <fp_div_2>
  while (fp_iseven (v) == FP_YES) {
 8023aba:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023abc:	681b      	ldr	r3, [r3, #0]
 8023abe:	2b00      	cmp	r3, #0
 8023ac0:	dd07      	ble.n	8023ad2 <fp_invmod_slow+0x2e6>
 8023ac2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8023ac4:	68db      	ldr	r3, [r3, #12]
 8023ac6:	f003 0301 	and.w	r3, r3, #1
 8023aca:	2b00      	cmp	r3, #0
 8023acc:	d101      	bne.n	8023ad2 <fp_invmod_slow+0x2e6>
 8023ace:	2301      	movs	r3, #1
 8023ad0:	e000      	b.n	8023ad4 <fp_invmod_slow+0x2e8>
 8023ad2:	2300      	movs	r3, #0
 8023ad4:	2b01      	cmp	r3, #1
 8023ad6:	d0a0      	beq.n	8023a1a <fp_invmod_slow+0x22e>
  }

  /* 6.  if u >= v then */
  if (fp_cmp (u, v) != FP_LT) {
 8023ad8:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023ada:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023adc:	f001 ffd4 	bl	8025a88 <fp_cmp>
 8023ae0:	4603      	mov	r3, r0
 8023ae2:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023ae6:	d038      	beq.n	8023b5a <fp_invmod_slow+0x36e>
    /* u = u - v, A = A - C, B = B - D */
    err = fp_sub (u, v, u);
 8023ae8:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8023aea:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8023aec:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8023aee:	f7fe fcd8 	bl	80224a2 <fp_sub>
 8023af2:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023af4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023af6:	2b00      	cmp	r3, #0
 8023af8:	d009      	beq.n	8023b0e <fp_invmod_slow+0x322>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023afa:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023afc:	63bb      	str	r3, [r7, #56]	@ 0x38
 8023afe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8023b00:	2b00      	cmp	r3, #0
 8023b02:	d002      	beq.n	8023b0a <fp_invmod_slow+0x31e>
 8023b04:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8023b06:	f7fa ffe1 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023b0a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b0c:	e0b9      	b.n	8023c82 <fp_invmod_slow+0x496>
    }
    err = fp_sub (A, C, A);
 8023b0e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8023b10:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023b12:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8023b14:	f7fe fcc5 	bl	80224a2 <fp_sub>
 8023b18:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023b1a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b1c:	2b00      	cmp	r3, #0
 8023b1e:	d009      	beq.n	8023b34 <fp_invmod_slow+0x348>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023b20:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b22:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8023b24:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8023b26:	2b00      	cmp	r3, #0
 8023b28:	d002      	beq.n	8023b30 <fp_invmod_slow+0x344>
 8023b2a:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8023b2c:	f7fa ffce 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023b30:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b32:	e0a6      	b.n	8023c82 <fp_invmod_slow+0x496>
    }
    err = fp_sub (B, D, B);
 8023b34:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8023b36:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 8023b38:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8023b3a:	f7fe fcb2 	bl	80224a2 <fp_sub>
 8023b3e:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023b40:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b42:	2b00      	cmp	r3, #0
 8023b44:	d042      	beq.n	8023bcc <fp_invmod_slow+0x3e0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023b46:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b48:	643b      	str	r3, [r7, #64]	@ 0x40
 8023b4a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8023b4c:	2b00      	cmp	r3, #0
 8023b4e:	d002      	beq.n	8023b56 <fp_invmod_slow+0x36a>
 8023b50:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8023b52:	f7fa ffbb 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023b56:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b58:	e093      	b.n	8023c82 <fp_invmod_slow+0x496>
    }
  } else {
    /* v - v - u, C = C - A, D = D - B */
    err = fp_sub (v, u, v);
 8023b5a:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8023b5c:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8023b5e:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023b60:	f7fe fc9f 	bl	80224a2 <fp_sub>
 8023b64:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023b66:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b68:	2b00      	cmp	r3, #0
 8023b6a:	d009      	beq.n	8023b80 <fp_invmod_slow+0x394>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023b6c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b6e:	647b      	str	r3, [r7, #68]	@ 0x44
 8023b70:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023b72:	2b00      	cmp	r3, #0
 8023b74:	d002      	beq.n	8023b7c <fp_invmod_slow+0x390>
 8023b76:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8023b78:	f7fa ffa8 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023b7c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b7e:	e080      	b.n	8023c82 <fp_invmod_slow+0x496>
    }
    err = fp_sub (C, A, C);
 8023b80:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023b82:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8023b84:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023b86:	f7fe fc8c 	bl	80224a2 <fp_sub>
 8023b8a:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023b8c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023b8e:	2b00      	cmp	r3, #0
 8023b90:	d009      	beq.n	8023ba6 <fp_invmod_slow+0x3ba>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023b92:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023b94:	64bb      	str	r3, [r7, #72]	@ 0x48
 8023b96:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8023b98:	2b00      	cmp	r3, #0
 8023b9a:	d002      	beq.n	8023ba2 <fp_invmod_slow+0x3b6>
 8023b9c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023b9e:	f7fa ff95 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023ba2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023ba4:	e06d      	b.n	8023c82 <fp_invmod_slow+0x496>
    }
    err = fp_sub (D, B, D);
 8023ba6:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8023ba8:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8023baa:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023bac:	f7fe fc79 	bl	80224a2 <fp_sub>
 8023bb0:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023bb2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023bb4:	2b00      	cmp	r3, #0
 8023bb6:	d009      	beq.n	8023bcc <fp_invmod_slow+0x3e0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023bb8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023bba:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8023bbc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8023bbe:	2b00      	cmp	r3, #0
 8023bc0:	d002      	beq.n	8023bc8 <fp_invmod_slow+0x3dc>
 8023bc2:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023bc4:	f7fa ff82 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023bc8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023bca:	e05a      	b.n	8023c82 <fp_invmod_slow+0x496>
    }
  }

  /* if not zero goto step 4 */
  if (fp_iszero (u) == FP_NO)
 8023bcc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8023bce:	681b      	ldr	r3, [r3, #0]
 8023bd0:	2b00      	cmp	r3, #0
 8023bd2:	d000      	beq.n	8023bd6 <fp_invmod_slow+0x3ea>
    goto top;
 8023bd4:	e6c0      	b.n	8023958 <fp_invmod_slow+0x16c>

  /* now a = C, b = D, gcd == g*v */

  /* if v != 1 then there is no inverse */
  if (fp_cmp_d (v, 1) != FP_EQ) {
 8023bd6:	2101      	movs	r1, #1
 8023bd8:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 8023bda:	f001 ff82 	bl	8025ae2 <fp_cmp_d>
 8023bde:	4603      	mov	r3, r0
 8023be0:	2b00      	cmp	r3, #0
 8023be2:	d01d      	beq.n	8023c20 <fp_invmod_slow+0x434>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023be4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023be6:	62bb      	str	r3, [r7, #40]	@ 0x28
 8023be8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023bea:	2b00      	cmp	r3, #0
 8023bec:	d002      	beq.n	8023bf4 <fp_invmod_slow+0x408>
 8023bee:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8023bf0:	f7fa ff6c 	bl	801eacc <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023bf4:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023bf8:	e043      	b.n	8023c82 <fp_invmod_slow+0x496>
  }

  /* if its too low */
  while (fp_cmp_d(C, 0) == FP_LT) {
    err = fp_add(C, b, C);
 8023bfa:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023bfc:	68b9      	ldr	r1, [r7, #8]
 8023bfe:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023c00:	f7fe fb6d 	bl	80222de <fp_add>
 8023c04:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023c06:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023c08:	2b00      	cmp	r3, #0
 8023c0a:	d009      	beq.n	8023c20 <fp_invmod_slow+0x434>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023c0c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c0e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8023c10:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023c12:	2b00      	cmp	r3, #0
 8023c14:	d002      	beq.n	8023c1c <fp_invmod_slow+0x430>
 8023c16:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8023c18:	f7fa ff58 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023c1c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023c1e:	e030      	b.n	8023c82 <fp_invmod_slow+0x496>
  while (fp_cmp_d(C, 0) == FP_LT) {
 8023c20:	2100      	movs	r1, #0
 8023c22:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023c24:	f001 ff5d 	bl	8025ae2 <fp_cmp_d>
 8023c28:	4603      	mov	r3, r0
 8023c2a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023c2e:	d0e4      	beq.n	8023bfa <fp_invmod_slow+0x40e>
    }
  }

  /* too big */
  while (fp_cmp_mag(C, b) != FP_LT) {
 8023c30:	e012      	b.n	8023c58 <fp_invmod_slow+0x46c>
    err = fp_sub(C, b, C);
 8023c32:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8023c34:	68b9      	ldr	r1, [r7, #8]
 8023c36:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023c38:	f7fe fc33 	bl	80224a2 <fp_sub>
 8023c3c:	6578      	str	r0, [r7, #84]	@ 0x54
    if (err != FP_OKAY) {
 8023c3e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023c40:	2b00      	cmp	r3, #0
 8023c42:	d009      	beq.n	8023c58 <fp_invmod_slow+0x46c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023c44:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c46:	633b      	str	r3, [r7, #48]	@ 0x30
 8023c48:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023c4a:	2b00      	cmp	r3, #0
 8023c4c:	d002      	beq.n	8023c54 <fp_invmod_slow+0x468>
 8023c4e:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8023c50:	f7fa ff3c 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023c54:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023c56:	e014      	b.n	8023c82 <fp_invmod_slow+0x496>
  while (fp_cmp_mag(C, b) != FP_LT) {
 8023c58:	68b9      	ldr	r1, [r7, #8]
 8023c5a:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023c5c:	f001 ff79 	bl	8025b52 <fp_cmp_mag>
 8023c60:	4603      	mov	r3, r0
 8023c62:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023c66:	d1e4      	bne.n	8023c32 <fp_invmod_slow+0x446>
    }
  }

  /* C is now the inverse */
  fp_copy(C, c);
 8023c68:	6879      	ldr	r1, [r7, #4]
 8023c6a:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023c6c:	f002 ff10 	bl	8026a90 <fp_copy>
#ifdef WOLFSSL_SMALL_STACK
  XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023c70:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8023c72:	637b      	str	r3, [r7, #52]	@ 0x34
 8023c74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023c76:	2b00      	cmp	r3, #0
 8023c78:	d002      	beq.n	8023c80 <fp_invmod_slow+0x494>
 8023c7a:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8023c7c:	f7fa ff26 	bl	801eacc <wolfSSL_Free>
#endif
  return FP_OKAY;
 8023c80:	2300      	movs	r3, #0
}
 8023c82:	4618      	mov	r0, r3
 8023c84:	3778      	adds	r7, #120	@ 0x78
 8023c86:	46bd      	mov	sp, r7
 8023c88:	bd80      	pop	{r7, pc}

08023c8a <fp_invmod>:

/* c = 1/a (mod b) for odd b only */
int fp_invmod(fp_int *a, fp_int *b, fp_int *c)
{
 8023c8a:	b580      	push	{r7, lr}
 8023c8c:	b098      	sub	sp, #96	@ 0x60
 8023c8e:	af00      	add	r7, sp, #0
 8023c90:	60f8      	str	r0, [r7, #12]
 8023c92:	60b9      	str	r1, [r7, #8]
 8023c94:	607a      	str	r2, [r7, #4]
#else
  fp_int  *x, *y, *u, *v, *B, *D;
#endif
  int     err;

  if (b->sign == FP_NEG || fp_iszero(b) == FP_YES) {
 8023c96:	68bb      	ldr	r3, [r7, #8]
 8023c98:	685b      	ldr	r3, [r3, #4]
 8023c9a:	2b01      	cmp	r3, #1
 8023c9c:	d003      	beq.n	8023ca6 <fp_invmod+0x1c>
 8023c9e:	68bb      	ldr	r3, [r7, #8]
 8023ca0:	681b      	ldr	r3, [r3, #0]
 8023ca2:	2b00      	cmp	r3, #0
 8023ca4:	d102      	bne.n	8023cac <fp_invmod+0x22>
    return FP_VAL;
 8023ca6:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023caa:	e1ad      	b.n	8024008 <fp_invmod+0x37e>
  }

  /* [modified] sanity check on "a" */
  if (fp_iszero(a) == FP_YES) {
 8023cac:	68fb      	ldr	r3, [r7, #12]
 8023cae:	681b      	ldr	r3, [r3, #0]
 8023cb0:	2b00      	cmp	r3, #0
 8023cb2:	d102      	bne.n	8023cba <fp_invmod+0x30>
    return FP_VAL; /* can not divide by 0 here */
 8023cb4:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023cb8:	e1a6      	b.n	8024008 <fp_invmod+0x37e>
  }

  /* 2. [modified] b must be odd   */
  if (fp_iseven(b) == FP_YES) {
 8023cba:	68bb      	ldr	r3, [r7, #8]
 8023cbc:	681b      	ldr	r3, [r3, #0]
 8023cbe:	2b00      	cmp	r3, #0
 8023cc0:	dd07      	ble.n	8023cd2 <fp_invmod+0x48>
 8023cc2:	68bb      	ldr	r3, [r7, #8]
 8023cc4:	68db      	ldr	r3, [r3, #12]
 8023cc6:	f003 0301 	and.w	r3, r3, #1
 8023cca:	2b00      	cmp	r3, #0
 8023ccc:	d101      	bne.n	8023cd2 <fp_invmod+0x48>
 8023cce:	2301      	movs	r3, #1
 8023cd0:	e000      	b.n	8023cd4 <fp_invmod+0x4a>
 8023cd2:	2300      	movs	r3, #0
 8023cd4:	2b01      	cmp	r3, #1
 8023cd6:	d106      	bne.n	8023ce6 <fp_invmod+0x5c>
    return fp_invmod_slow(a,b,c);
 8023cd8:	687a      	ldr	r2, [r7, #4]
 8023cda:	68b9      	ldr	r1, [r7, #8]
 8023cdc:	68f8      	ldr	r0, [r7, #12]
 8023cde:	f7ff fd85 	bl	80237ec <fp_invmod_slow>
 8023ce2:	4603      	mov	r3, r0
 8023ce4:	e190      	b.n	8024008 <fp_invmod+0x37e>
  }

#ifdef WOLFSSL_SMALL_STACK
  x = (fp_int*)XMALLOC(sizeof(fp_int) * 6, NULL, DYNAMIC_TYPE_BIGINT);
 8023ce6:	f640 5008 	movw	r0, #3336	@ 0xd08
 8023cea:	f7fa fed3 	bl	801ea94 <wolfSSL_Malloc>
 8023cee:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (x == NULL) {
 8023cf0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023cf2:	2b00      	cmp	r3, #0
 8023cf4:	d102      	bne.n	8023cfc <fp_invmod+0x72>
      return FP_MEM;
 8023cf6:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8023cfa:	e185      	b.n	8024008 <fp_invmod+0x37e>
  }
  y = &x[1]; u = &x[2]; v = &x[3]; B = &x[4]; D = &x[5];
 8023cfc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023cfe:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8023d02:	65bb      	str	r3, [r7, #88]	@ 0x58
 8023d04:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d06:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8023d0a:	657b      	str	r3, [r7, #84]	@ 0x54
 8023d0c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d0e:	f203 6384 	addw	r3, r3, #1668	@ 0x684
 8023d12:	653b      	str	r3, [r7, #80]	@ 0x50
 8023d14:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d16:	f503 630b 	add.w	r3, r3, #2224	@ 0x8b0
 8023d1a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8023d1c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d1e:	f603 23dc 	addw	r3, r3, #2780	@ 0xadc
 8023d22:	64bb      	str	r3, [r7, #72]	@ 0x48
#endif

  /* init all our temps */
  fp_init(x);  fp_init(y);
 8023d24:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023d26:	f002 fcc9 	bl	80266bc <fp_init>
 8023d2a:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023d2c:	f002 fcc6 	bl	80266bc <fp_init>
  fp_init(u);  fp_init(v);
 8023d30:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8023d32:	f002 fcc3 	bl	80266bc <fp_init>
 8023d36:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8023d38:	f002 fcc0 	bl	80266bc <fp_init>
  fp_init(B);  fp_init(D);
 8023d3c:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023d3e:	f002 fcbd 	bl	80266bc <fp_init>
 8023d42:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023d44:	f002 fcba 	bl	80266bc <fp_init>

  if (fp_iszero(a) == FP_YES) {
 8023d48:	68fb      	ldr	r3, [r7, #12]
 8023d4a:	681b      	ldr	r3, [r3, #0]
 8023d4c:	2b00      	cmp	r3, #0
 8023d4e:	d10a      	bne.n	8023d66 <fp_invmod+0xdc>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023d50:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d52:	613b      	str	r3, [r7, #16]
 8023d54:	693b      	ldr	r3, [r7, #16]
 8023d56:	2b00      	cmp	r3, #0
 8023d58:	d002      	beq.n	8023d60 <fp_invmod+0xd6>
 8023d5a:	6938      	ldr	r0, [r7, #16]
 8023d5c:	f7fa feb6 	bl	801eacc <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023d60:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023d64:	e150      	b.n	8024008 <fp_invmod+0x37e>
  }

  /* x == modulus, y == value to invert */
  fp_copy(b, x);
 8023d66:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023d68:	68b8      	ldr	r0, [r7, #8]
 8023d6a:	f002 fe91 	bl	8026a90 <fp_copy>

  /* we need y = |a| */
  if ((err = mp_mod(a, b, y)) != FP_OKAY) {
 8023d6e:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8023d70:	68b9      	ldr	r1, [r7, #8]
 8023d72:	68f8      	ldr	r0, [r7, #12]
 8023d74:	f002 fdd0 	bl	8026918 <mp_mod>
 8023d78:	6478      	str	r0, [r7, #68]	@ 0x44
 8023d7a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023d7c:	2b00      	cmp	r3, #0
 8023d7e:	d009      	beq.n	8023d94 <fp_invmod+0x10a>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023d80:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d82:	617b      	str	r3, [r7, #20]
 8023d84:	697b      	ldr	r3, [r7, #20]
 8023d86:	2b00      	cmp	r3, #0
 8023d88:	d002      	beq.n	8023d90 <fp_invmod+0x106>
 8023d8a:	6978      	ldr	r0, [r7, #20]
 8023d8c:	f7fa fe9e 	bl	801eacc <wolfSSL_Free>
  #endif
    return err;
 8023d90:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023d92:	e139      	b.n	8024008 <fp_invmod+0x37e>
  }

  if (fp_iszero(y) == FP_YES) {
 8023d94:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8023d96:	681b      	ldr	r3, [r3, #0]
 8023d98:	2b00      	cmp	r3, #0
 8023d9a:	d10a      	bne.n	8023db2 <fp_invmod+0x128>
    /* invmod doesn't exist for this a and b */
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023d9c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023d9e:	61bb      	str	r3, [r7, #24]
 8023da0:	69bb      	ldr	r3, [r7, #24]
 8023da2:	2b00      	cmp	r3, #0
 8023da4:	d002      	beq.n	8023dac <fp_invmod+0x122>
 8023da6:	69b8      	ldr	r0, [r7, #24]
 8023da8:	f7fa fe90 	bl	801eacc <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023dac:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023db0:	e12a      	b.n	8024008 <fp_invmod+0x37e>
  }

  /* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
  fp_copy(x, u);
 8023db2:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8023db4:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8023db6:	f002 fe6b 	bl	8026a90 <fp_copy>
  fp_copy(y, v);
 8023dba:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8023dbc:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8023dbe:	f002 fe67 	bl	8026a90 <fp_copy>
  fp_set (D, 1);
 8023dc2:	2101      	movs	r1, #1
 8023dc4:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023dc6:	f002 fa4a 	bl	802625e <fp_set>

top:
  /* 4.  while u is even do */
  while (fp_iseven (u) == FP_YES) {
 8023dca:	e029      	b.n	8023e20 <fp_invmod+0x196>
    /* 4.1 u = u/2 */
    fp_div_2 (u, u);
 8023dcc:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8023dce:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8023dd0:	f7ff fa51 	bl	8023276 <fp_div_2>

    /* 4.2 if B is odd then */
    if (fp_isodd (B) == FP_YES) {
 8023dd4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8023dd6:	681b      	ldr	r3, [r3, #0]
 8023dd8:	2b00      	cmp	r3, #0
 8023dda:	dd07      	ble.n	8023dec <fp_invmod+0x162>
 8023ddc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8023dde:	68db      	ldr	r3, [r3, #12]
 8023de0:	f003 0301 	and.w	r3, r3, #1
 8023de4:	2b00      	cmp	r3, #0
 8023de6:	d001      	beq.n	8023dec <fp_invmod+0x162>
 8023de8:	2301      	movs	r3, #1
 8023dea:	e000      	b.n	8023dee <fp_invmod+0x164>
 8023dec:	2300      	movs	r3, #0
 8023dee:	2b01      	cmp	r3, #1
 8023df0:	d112      	bne.n	8023e18 <fp_invmod+0x18e>
      err = fp_sub (B, x, B);
 8023df2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8023df4:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023df6:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023df8:	f7fe fb53 	bl	80224a2 <fp_sub>
 8023dfc:	6478      	str	r0, [r7, #68]	@ 0x44
      if (err != FP_OKAY) {
 8023dfe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023e00:	2b00      	cmp	r3, #0
 8023e02:	d009      	beq.n	8023e18 <fp_invmod+0x18e>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023e04:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023e06:	61fb      	str	r3, [r7, #28]
 8023e08:	69fb      	ldr	r3, [r7, #28]
 8023e0a:	2b00      	cmp	r3, #0
 8023e0c:	d002      	beq.n	8023e14 <fp_invmod+0x18a>
 8023e0e:	69f8      	ldr	r0, [r7, #28]
 8023e10:	f7fa fe5c 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 8023e14:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023e16:	e0f7      	b.n	8024008 <fp_invmod+0x37e>
      }
    }
    /* B = B/2 */
    fp_div_2 (B, B);
 8023e18:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8023e1a:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023e1c:	f7ff fa2b 	bl	8023276 <fp_div_2>
  while (fp_iseven (u) == FP_YES) {
 8023e20:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023e22:	681b      	ldr	r3, [r3, #0]
 8023e24:	2b00      	cmp	r3, #0
 8023e26:	dd07      	ble.n	8023e38 <fp_invmod+0x1ae>
 8023e28:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023e2a:	68db      	ldr	r3, [r3, #12]
 8023e2c:	f003 0301 	and.w	r3, r3, #1
 8023e30:	2b00      	cmp	r3, #0
 8023e32:	d101      	bne.n	8023e38 <fp_invmod+0x1ae>
 8023e34:	2301      	movs	r3, #1
 8023e36:	e000      	b.n	8023e3a <fp_invmod+0x1b0>
 8023e38:	2300      	movs	r3, #0
 8023e3a:	2b01      	cmp	r3, #1
 8023e3c:	d0c6      	beq.n	8023dcc <fp_invmod+0x142>
  }

  /* 5.  while v is even do */
  while (fp_iseven (v) == FP_YES) {
 8023e3e:	e029      	b.n	8023e94 <fp_invmod+0x20a>
    /* 5.1 v = v/2 */
    fp_div_2 (v, v);
 8023e40:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8023e42:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8023e44:	f7ff fa17 	bl	8023276 <fp_div_2>

    /* 5.2 if D is odd then */
    if (fp_isodd (D) == FP_YES) {
 8023e48:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8023e4a:	681b      	ldr	r3, [r3, #0]
 8023e4c:	2b00      	cmp	r3, #0
 8023e4e:	dd07      	ble.n	8023e60 <fp_invmod+0x1d6>
 8023e50:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8023e52:	68db      	ldr	r3, [r3, #12]
 8023e54:	f003 0301 	and.w	r3, r3, #1
 8023e58:	2b00      	cmp	r3, #0
 8023e5a:	d001      	beq.n	8023e60 <fp_invmod+0x1d6>
 8023e5c:	2301      	movs	r3, #1
 8023e5e:	e000      	b.n	8023e62 <fp_invmod+0x1d8>
 8023e60:	2300      	movs	r3, #0
 8023e62:	2b01      	cmp	r3, #1
 8023e64:	d112      	bne.n	8023e8c <fp_invmod+0x202>
      /* D = (D-x)/2 */
      err = fp_sub (D, x, D);
 8023e66:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8023e68:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 8023e6a:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023e6c:	f7fe fb19 	bl	80224a2 <fp_sub>
 8023e70:	6478      	str	r0, [r7, #68]	@ 0x44
      if (err != FP_OKAY) {
 8023e72:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023e74:	2b00      	cmp	r3, #0
 8023e76:	d009      	beq.n	8023e8c <fp_invmod+0x202>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023e78:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023e7a:	623b      	str	r3, [r7, #32]
 8023e7c:	6a3b      	ldr	r3, [r7, #32]
 8023e7e:	2b00      	cmp	r3, #0
 8023e80:	d002      	beq.n	8023e88 <fp_invmod+0x1fe>
 8023e82:	6a38      	ldr	r0, [r7, #32]
 8023e84:	f7fa fe22 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 8023e88:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023e8a:	e0bd      	b.n	8024008 <fp_invmod+0x37e>
      }
    }
    /* D = D/2 */
    fp_div_2 (D, D);
 8023e8c:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8023e8e:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023e90:	f7ff f9f1 	bl	8023276 <fp_div_2>
  while (fp_iseven (v) == FP_YES) {
 8023e94:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8023e96:	681b      	ldr	r3, [r3, #0]
 8023e98:	2b00      	cmp	r3, #0
 8023e9a:	dd07      	ble.n	8023eac <fp_invmod+0x222>
 8023e9c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8023e9e:	68db      	ldr	r3, [r3, #12]
 8023ea0:	f003 0301 	and.w	r3, r3, #1
 8023ea4:	2b00      	cmp	r3, #0
 8023ea6:	d101      	bne.n	8023eac <fp_invmod+0x222>
 8023ea8:	2301      	movs	r3, #1
 8023eaa:	e000      	b.n	8023eae <fp_invmod+0x224>
 8023eac:	2300      	movs	r3, #0
 8023eae:	2b01      	cmp	r3, #1
 8023eb0:	d0c6      	beq.n	8023e40 <fp_invmod+0x1b6>
  }

  /* 6.  if u >= v then */
  if (fp_cmp (u, v) != FP_LT) {
 8023eb2:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8023eb4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8023eb6:	f001 fde7 	bl	8025a88 <fp_cmp>
 8023eba:	4603      	mov	r3, r0
 8023ebc:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023ec0:	d025      	beq.n	8023f0e <fp_invmod+0x284>
    /* u = u - v, B = B - D */
    err = fp_sub (u, v, u);
 8023ec2:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8023ec4:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8023ec6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8023ec8:	f7fe faeb 	bl	80224a2 <fp_sub>
 8023ecc:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023ece:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023ed0:	2b00      	cmp	r3, #0
 8023ed2:	d009      	beq.n	8023ee8 <fp_invmod+0x25e>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023ed4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023ed6:	637b      	str	r3, [r7, #52]	@ 0x34
 8023ed8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023eda:	2b00      	cmp	r3, #0
 8023edc:	d002      	beq.n	8023ee4 <fp_invmod+0x25a>
 8023ede:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8023ee0:	f7fa fdf4 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023ee4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023ee6:	e08f      	b.n	8024008 <fp_invmod+0x37e>
    }
    err = fp_sub (B, D, B);
 8023ee8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8023eea:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8023eec:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8023eee:	f7fe fad8 	bl	80224a2 <fp_sub>
 8023ef2:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023ef4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023ef6:	2b00      	cmp	r3, #0
 8023ef8:	d02f      	beq.n	8023f5a <fp_invmod+0x2d0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023efa:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023efc:	63bb      	str	r3, [r7, #56]	@ 0x38
 8023efe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8023f00:	2b00      	cmp	r3, #0
 8023f02:	d002      	beq.n	8023f0a <fp_invmod+0x280>
 8023f04:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8023f06:	f7fa fde1 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023f0a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f0c:	e07c      	b.n	8024008 <fp_invmod+0x37e>
    }
  } else {
    /* v - v - u, D = D - B */
    err = fp_sub (v, u, v);
 8023f0e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8023f10:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8023f12:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8023f14:	f7fe fac5 	bl	80224a2 <fp_sub>
 8023f18:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023f1a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f1c:	2b00      	cmp	r3, #0
 8023f1e:	d009      	beq.n	8023f34 <fp_invmod+0x2aa>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f20:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023f22:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8023f24:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8023f26:	2b00      	cmp	r3, #0
 8023f28:	d002      	beq.n	8023f30 <fp_invmod+0x2a6>
 8023f2a:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8023f2c:	f7fa fdce 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023f30:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f32:	e069      	b.n	8024008 <fp_invmod+0x37e>
    }
    err = fp_sub (D, B, D);
 8023f34:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8023f36:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8023f38:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023f3a:	f7fe fab2 	bl	80224a2 <fp_sub>
 8023f3e:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023f40:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f42:	2b00      	cmp	r3, #0
 8023f44:	d009      	beq.n	8023f5a <fp_invmod+0x2d0>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f46:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023f48:	643b      	str	r3, [r7, #64]	@ 0x40
 8023f4a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8023f4c:	2b00      	cmp	r3, #0
 8023f4e:	d002      	beq.n	8023f56 <fp_invmod+0x2cc>
 8023f50:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8023f52:	f7fa fdbb 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023f56:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f58:	e056      	b.n	8024008 <fp_invmod+0x37e>
    }
  }

  /* if not zero goto step 4 */
  if (fp_iszero (u) == FP_NO) {
 8023f5a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8023f5c:	681b      	ldr	r3, [r3, #0]
 8023f5e:	2b00      	cmp	r3, #0
 8023f60:	d000      	beq.n	8023f64 <fp_invmod+0x2da>
    goto top;
 8023f62:	e732      	b.n	8023dca <fp_invmod+0x140>
  }

  /* now a = C, b = D, gcd == g*v */

  /* if v != 1 then there is no inverse */
  if (fp_cmp_d (v, 1) != FP_EQ) {
 8023f64:	2101      	movs	r1, #1
 8023f66:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8023f68:	f001 fdbb 	bl	8025ae2 <fp_cmp_d>
 8023f6c:	4603      	mov	r3, r0
 8023f6e:	2b00      	cmp	r3, #0
 8023f70:	d01d      	beq.n	8023fae <fp_invmod+0x324>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f72:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023f74:	627b      	str	r3, [r7, #36]	@ 0x24
 8023f76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023f78:	2b00      	cmp	r3, #0
 8023f7a:	d002      	beq.n	8023f82 <fp_invmod+0x2f8>
 8023f7c:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8023f7e:	f7fa fda5 	bl	801eacc <wolfSSL_Free>
  #endif
    return FP_VAL;
 8023f82:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8023f86:	e03f      	b.n	8024008 <fp_invmod+0x37e>
  }

  /* b is now the inverse */
  while (D->sign == FP_NEG) {
    err = fp_add (D, b, D);
 8023f88:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8023f8a:	68b9      	ldr	r1, [r7, #8]
 8023f8c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023f8e:	f7fe f9a6 	bl	80222de <fp_add>
 8023f92:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023f94:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f96:	2b00      	cmp	r3, #0
 8023f98:	d009      	beq.n	8023fae <fp_invmod+0x324>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023f9a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023f9c:	62bb      	str	r3, [r7, #40]	@ 0x28
 8023f9e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023fa0:	2b00      	cmp	r3, #0
 8023fa2:	d002      	beq.n	8023faa <fp_invmod+0x320>
 8023fa4:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8023fa6:	f7fa fd91 	bl	801eacc <wolfSSL_Free>
    #endif
      return FP_OKAY;
 8023faa:	2300      	movs	r3, #0
 8023fac:	e02c      	b.n	8024008 <fp_invmod+0x37e>
  while (D->sign == FP_NEG) {
 8023fae:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8023fb0:	685b      	ldr	r3, [r3, #4]
 8023fb2:	2b01      	cmp	r3, #1
 8023fb4:	d0e8      	beq.n	8023f88 <fp_invmod+0x2fe>
    }
  }
  /* too big */
  while (fp_cmp_mag(D, b) != FP_LT) {
 8023fb6:	e012      	b.n	8023fde <fp_invmod+0x354>
    err = fp_sub(D, b, D);
 8023fb8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8023fba:	68b9      	ldr	r1, [r7, #8]
 8023fbc:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023fbe:	f7fe fa70 	bl	80224a2 <fp_sub>
 8023fc2:	6478      	str	r0, [r7, #68]	@ 0x44
    if (err != FP_OKAY) {
 8023fc4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023fc6:	2b00      	cmp	r3, #0
 8023fc8:	d009      	beq.n	8023fde <fp_invmod+0x354>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023fca:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023fcc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8023fce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023fd0:	2b00      	cmp	r3, #0
 8023fd2:	d002      	beq.n	8023fda <fp_invmod+0x350>
 8023fd4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8023fd6:	f7fa fd79 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8023fda:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023fdc:	e014      	b.n	8024008 <fp_invmod+0x37e>
  while (fp_cmp_mag(D, b) != FP_LT) {
 8023fde:	68b9      	ldr	r1, [r7, #8]
 8023fe0:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023fe2:	f001 fdb6 	bl	8025b52 <fp_cmp_mag>
 8023fe6:	4603      	mov	r3, r0
 8023fe8:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8023fec:	d1e4      	bne.n	8023fb8 <fp_invmod+0x32e>
    }
  }
  fp_copy (D, c);
 8023fee:	6879      	ldr	r1, [r7, #4]
 8023ff0:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8023ff2:	f002 fd4d 	bl	8026a90 <fp_copy>
#ifdef WOLFSSL_SMALL_STACK
  XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 8023ff6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8023ff8:	633b      	str	r3, [r7, #48]	@ 0x30
 8023ffa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023ffc:	2b00      	cmp	r3, #0
 8023ffe:	d002      	beq.n	8024006 <fp_invmod+0x37c>
 8024000:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8024002:	f7fa fd63 	bl	801eacc <wolfSSL_Free>
#endif
  return FP_OKAY;
 8024006:	2300      	movs	r3, #0
}
 8024008:	4618      	mov	r0, r3
 802400a:	3760      	adds	r7, #96	@ 0x60
 802400c:	46bd      	mov	sp, r7
 802400e:	bd80      	pop	{r7, pc}

08024010 <fp_invmod_mont_ct>:

#define CT_INV_MOD_PRE_CNT      8

/* modulus (b) must be greater than 2 and a prime */
int fp_invmod_mont_ct(fp_int *a, fp_int *b, fp_int *c, fp_digit mp)
{
 8024010:	b580      	push	{r7, lr}
 8024012:	b08c      	sub	sp, #48	@ 0x30
 8024014:	af00      	add	r7, sp, #0
 8024016:	60f8      	str	r0, [r7, #12]
 8024018:	60b9      	str	r1, [r7, #8]
 802401a:	607a      	str	r2, [r7, #4]
 802401c:	603b      	str	r3, [r7, #0]
  int i, j, err = FP_OKAY;
 802401e:	2300      	movs	r3, #0
 8024020:	627b      	str	r3, [r7, #36]	@ 0x24
  fp_int* t;
  fp_int* e;
  fp_int* pre;
#endif

  if ((a->used * 2 > FP_SIZE) || (b->used * 2 > FP_SIZE)) {
 8024022:	68fb      	ldr	r3, [r7, #12]
 8024024:	681b      	ldr	r3, [r3, #0]
 8024026:	005b      	lsls	r3, r3, #1
 8024028:	2b88      	cmp	r3, #136	@ 0x88
 802402a:	dc04      	bgt.n	8024036 <fp_invmod_mont_ct+0x26>
 802402c:	68bb      	ldr	r3, [r7, #8]
 802402e:	681b      	ldr	r3, [r3, #0]
 8024030:	005b      	lsls	r3, r3, #1
 8024032:	2b88      	cmp	r3, #136	@ 0x88
 8024034:	dd02      	ble.n	802403c <fp_invmod_mont_ct+0x2c>
    return FP_VAL;
 8024036:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802403a:	e128      	b.n	802428e <fp_invmod_mont_ct+0x27e>
  }

#ifdef WOLFSSL_SMALL_STACK
  t = (fp_int*)XMALLOC(sizeof(fp_int) * (2 + CT_INV_MOD_PRE_CNT), NULL,
 802403c:	f241 50b8 	movw	r0, #5560	@ 0x15b8
 8024040:	f7fa fd28 	bl	801ea94 <wolfSSL_Malloc>
 8024044:	6238      	str	r0, [r7, #32]
                                                           DYNAMIC_TYPE_BIGINT);
  if (t == NULL)
 8024046:	6a3b      	ldr	r3, [r7, #32]
 8024048:	2b00      	cmp	r3, #0
 802404a:	d102      	bne.n	8024052 <fp_invmod_mont_ct+0x42>
    return FP_MEM;
 802404c:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8024050:	e11d      	b.n	802428e <fp_invmod_mont_ct+0x27e>
  e = t + 1;
 8024052:	6a3b      	ldr	r3, [r7, #32]
 8024054:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024058:	61fb      	str	r3, [r7, #28]
  pre = t + 2;
 802405a:	6a3b      	ldr	r3, [r7, #32]
 802405c:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024060:	61bb      	str	r3, [r7, #24]
#endif

  fp_init(t);
 8024062:	6a38      	ldr	r0, [r7, #32]
 8024064:	f002 fb2a 	bl	80266bc <fp_init>
  fp_init(e);
 8024068:	69f8      	ldr	r0, [r7, #28]
 802406a:	f002 fb27 	bl	80266bc <fp_init>

  fp_init(&pre[0]);
 802406e:	69b8      	ldr	r0, [r7, #24]
 8024070:	f002 fb24 	bl	80266bc <fp_init>
  fp_copy(a, &pre[0]);
 8024074:	69b9      	ldr	r1, [r7, #24]
 8024076:	68f8      	ldr	r0, [r7, #12]
 8024078:	f002 fd0a 	bl	8026a90 <fp_copy>
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
 802407c:	2301      	movs	r3, #1
 802407e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024080:	e059      	b.n	8024136 <fp_invmod_mont_ct+0x126>
    fp_init(&pre[i]);
 8024082:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024084:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024088:	fb02 f303 	mul.w	r3, r2, r3
 802408c:	69ba      	ldr	r2, [r7, #24]
 802408e:	4413      	add	r3, r2
 8024090:	4618      	mov	r0, r3
 8024092:	f002 fb13 	bl	80266bc <fp_init>
    err |= fp_sqr(&pre[i-1], &pre[i]);
 8024096:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024098:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 802409c:	fb02 f303 	mul.w	r3, r2, r3
 80240a0:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 80240a4:	69ba      	ldr	r2, [r7, #24]
 80240a6:	18d0      	adds	r0, r2, r3
 80240a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80240aa:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80240ae:	fb02 f303 	mul.w	r3, r2, r3
 80240b2:	69ba      	ldr	r2, [r7, #24]
 80240b4:	4413      	add	r3, r2
 80240b6:	4619      	mov	r1, r3
 80240b8:	f001 fa9f 	bl	80255fa <fp_sqr>
 80240bc:	4602      	mov	r2, r0
 80240be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80240c0:	4313      	orrs	r3, r2
 80240c2:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(&pre[i], b, mp);
 80240c4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80240c6:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80240ca:	fb02 f303 	mul.w	r3, r2, r3
 80240ce:	69ba      	ldr	r2, [r7, #24]
 80240d0:	4413      	add	r3, r2
 80240d2:	683a      	ldr	r2, [r7, #0]
 80240d4:	68b9      	ldr	r1, [r7, #8]
 80240d6:	4618      	mov	r0, r3
 80240d8:	f001 ff4b 	bl	8025f72 <fp_montgomery_reduce>
 80240dc:	4602      	mov	r2, r0
 80240de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80240e0:	4313      	orrs	r3, r2
 80240e2:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_mul(&pre[i], a, &pre[i]);
 80240e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80240e6:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80240ea:	fb02 f303 	mul.w	r3, r2, r3
 80240ee:	69ba      	ldr	r2, [r7, #24]
 80240f0:	18d0      	adds	r0, r2, r3
 80240f2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80240f4:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80240f8:	fb02 f303 	mul.w	r3, r2, r3
 80240fc:	69ba      	ldr	r2, [r7, #24]
 80240fe:	4413      	add	r3, r2
 8024100:	461a      	mov	r2, r3
 8024102:	68f9      	ldr	r1, [r7, #12]
 8024104:	f7fe fad1 	bl	80226aa <fp_mul>
 8024108:	4602      	mov	r2, r0
 802410a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802410c:	4313      	orrs	r3, r2
 802410e:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(&pre[i], b, mp);
 8024110:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024112:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024116:	fb02 f303 	mul.w	r3, r2, r3
 802411a:	69ba      	ldr	r2, [r7, #24]
 802411c:	4413      	add	r3, r2
 802411e:	683a      	ldr	r2, [r7, #0]
 8024120:	68b9      	ldr	r1, [r7, #8]
 8024122:	4618      	mov	r0, r3
 8024124:	f001 ff25 	bl	8025f72 <fp_montgomery_reduce>
 8024128:	4602      	mov	r2, r0
 802412a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802412c:	4313      	orrs	r3, r2
 802412e:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
 8024130:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024132:	3301      	adds	r3, #1
 8024134:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024136:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024138:	2b07      	cmp	r3, #7
 802413a:	dda2      	ble.n	8024082 <fp_invmod_mont_ct+0x72>
  }

  err |= fp_sub_d(b, 2, e);
 802413c:	69fa      	ldr	r2, [r7, #28]
 802413e:	2102      	movs	r1, #2
 8024140:	68b8      	ldr	r0, [r7, #8]
 8024142:	f002 fa70 	bl	8026626 <fp_sub_d>
 8024146:	4602      	mov	r2, r0
 8024148:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802414a:	4313      	orrs	r3, r2
 802414c:	627b      	str	r3, [r7, #36]	@ 0x24
  /* Highest bit is always set. */
  j = 1;
 802414e:	2301      	movs	r3, #1
 8024150:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = fp_count_bits(e)-2; i >= 0; i--) {
 8024152:	69f8      	ldr	r0, [r7, #28]
 8024154:	f002 f8c6 	bl	80262e4 <fp_count_bits>
 8024158:	4603      	mov	r3, r0
 802415a:	3b02      	subs	r3, #2
 802415c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802415e:	e010      	b.n	8024182 <fp_invmod_mont_ct+0x172>
      if (!fp_is_bit_set(e, i) || j == CT_INV_MOD_PRE_CNT)
 8024160:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024162:	4619      	mov	r1, r3
 8024164:	69f8      	ldr	r0, [r7, #28]
 8024166:	f002 f893 	bl	8026290 <fp_is_bit_set>
 802416a:	4603      	mov	r3, r0
 802416c:	2b00      	cmp	r3, #0
 802416e:	d00b      	beq.n	8024188 <fp_invmod_mont_ct+0x178>
 8024170:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8024172:	2b08      	cmp	r3, #8
 8024174:	d008      	beq.n	8024188 <fp_invmod_mont_ct+0x178>
          break;
      j++;
 8024176:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8024178:	3301      	adds	r3, #1
 802417a:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = fp_count_bits(e)-2; i >= 0; i--) {
 802417c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802417e:	3b01      	subs	r3, #1
 8024180:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024182:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024184:	2b00      	cmp	r3, #0
 8024186:	daeb      	bge.n	8024160 <fp_invmod_mont_ct+0x150>
  }
  fp_copy(&pre[j-1], t);
 8024188:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802418a:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 802418e:	fb02 f303 	mul.w	r3, r2, r3
 8024192:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 8024196:	69ba      	ldr	r2, [r7, #24]
 8024198:	4413      	add	r3, r2
 802419a:	6a39      	ldr	r1, [r7, #32]
 802419c:	4618      	mov	r0, r3
 802419e:	f002 fc77 	bl	8026a90 <fp_copy>
  j = 0;
 80241a2:	2300      	movs	r3, #0
 80241a4:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (; i >= 0; i--) {
 80241a6:	e043      	b.n	8024230 <fp_invmod_mont_ct+0x220>
    int set = fp_is_bit_set(e, i);
 80241a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80241aa:	4619      	mov	r1, r3
 80241ac:	69f8      	ldr	r0, [r7, #28]
 80241ae:	f002 f86f 	bl	8026290 <fp_is_bit_set>
 80241b2:	6138      	str	r0, [r7, #16]

    if ((j == CT_INV_MOD_PRE_CNT) || (!set && j > 0)) {
 80241b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80241b6:	2b08      	cmp	r3, #8
 80241b8:	d005      	beq.n	80241c6 <fp_invmod_mont_ct+0x1b6>
 80241ba:	693b      	ldr	r3, [r7, #16]
 80241bc:	2b00      	cmp	r3, #0
 80241be:	d11f      	bne.n	8024200 <fp_invmod_mont_ct+0x1f0>
 80241c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80241c2:	2b00      	cmp	r3, #0
 80241c4:	dd1c      	ble.n	8024200 <fp_invmod_mont_ct+0x1f0>
      err |= fp_mul(t, &pre[j-1], t);
 80241c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80241c8:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 80241cc:	fb02 f303 	mul.w	r3, r2, r3
 80241d0:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 80241d4:	69ba      	ldr	r2, [r7, #24]
 80241d6:	4413      	add	r3, r2
 80241d8:	6a3a      	ldr	r2, [r7, #32]
 80241da:	4619      	mov	r1, r3
 80241dc:	6a38      	ldr	r0, [r7, #32]
 80241de:	f7fe fa64 	bl	80226aa <fp_mul>
 80241e2:	4602      	mov	r2, r0
 80241e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80241e6:	4313      	orrs	r3, r2
 80241e8:	627b      	str	r3, [r7, #36]	@ 0x24
      err |= fp_montgomery_reduce(t, b, mp);
 80241ea:	683a      	ldr	r2, [r7, #0]
 80241ec:	68b9      	ldr	r1, [r7, #8]
 80241ee:	6a38      	ldr	r0, [r7, #32]
 80241f0:	f001 febf 	bl	8025f72 <fp_montgomery_reduce>
 80241f4:	4602      	mov	r2, r0
 80241f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80241f8:	4313      	orrs	r3, r2
 80241fa:	627b      	str	r3, [r7, #36]	@ 0x24
      j = 0;
 80241fc:	2300      	movs	r3, #0
 80241fe:	62bb      	str	r3, [r7, #40]	@ 0x28
    }
    err |= fp_sqr(t, t);
 8024200:	6a39      	ldr	r1, [r7, #32]
 8024202:	6a38      	ldr	r0, [r7, #32]
 8024204:	f001 f9f9 	bl	80255fa <fp_sqr>
 8024208:	4602      	mov	r2, r0
 802420a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802420c:	4313      	orrs	r3, r2
 802420e:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(t, b, mp);
 8024210:	683a      	ldr	r2, [r7, #0]
 8024212:	68b9      	ldr	r1, [r7, #8]
 8024214:	6a38      	ldr	r0, [r7, #32]
 8024216:	f001 feac 	bl	8025f72 <fp_montgomery_reduce>
 802421a:	4602      	mov	r2, r0
 802421c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802421e:	4313      	orrs	r3, r2
 8024220:	627b      	str	r3, [r7, #36]	@ 0x24
    j += set;
 8024222:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8024224:	693b      	ldr	r3, [r7, #16]
 8024226:	4413      	add	r3, r2
 8024228:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (; i >= 0; i--) {
 802422a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802422c:	3b01      	subs	r3, #1
 802422e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024230:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024232:	2b00      	cmp	r3, #0
 8024234:	dab8      	bge.n	80241a8 <fp_invmod_mont_ct+0x198>
  }
  if (j > 0) {
 8024236:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8024238:	2b00      	cmp	r3, #0
 802423a:	dd1b      	ble.n	8024274 <fp_invmod_mont_ct+0x264>
    err |= fp_mul(t, &pre[j-1], c);
 802423c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802423e:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024242:	fb02 f303 	mul.w	r3, r2, r3
 8024246:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 802424a:	69ba      	ldr	r2, [r7, #24]
 802424c:	4413      	add	r3, r2
 802424e:	687a      	ldr	r2, [r7, #4]
 8024250:	4619      	mov	r1, r3
 8024252:	6a38      	ldr	r0, [r7, #32]
 8024254:	f7fe fa29 	bl	80226aa <fp_mul>
 8024258:	4602      	mov	r2, r0
 802425a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802425c:	4313      	orrs	r3, r2
 802425e:	627b      	str	r3, [r7, #36]	@ 0x24
    err |= fp_montgomery_reduce(c, b, mp);
 8024260:	683a      	ldr	r2, [r7, #0]
 8024262:	68b9      	ldr	r1, [r7, #8]
 8024264:	6878      	ldr	r0, [r7, #4]
 8024266:	f001 fe84 	bl	8025f72 <fp_montgomery_reduce>
 802426a:	4602      	mov	r2, r0
 802426c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802426e:	4313      	orrs	r3, r2
 8024270:	627b      	str	r3, [r7, #36]	@ 0x24
 8024272:	e003      	b.n	802427c <fp_invmod_mont_ct+0x26c>
  }
  else
    fp_copy(t, c);
 8024274:	6879      	ldr	r1, [r7, #4]
 8024276:	6a38      	ldr	r0, [r7, #32]
 8024278:	f002 fc0a 	bl	8026a90 <fp_copy>

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 802427c:	6a3b      	ldr	r3, [r7, #32]
 802427e:	617b      	str	r3, [r7, #20]
 8024280:	697b      	ldr	r3, [r7, #20]
 8024282:	2b00      	cmp	r3, #0
 8024284:	d002      	beq.n	802428c <fp_invmod_mont_ct+0x27c>
 8024286:	6978      	ldr	r0, [r7, #20]
 8024288:	f7fa fc20 	bl	801eacc <wolfSSL_Free>
#endif

  return err;
 802428c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 802428e:	4618      	mov	r0, r3
 8024290:	3730      	adds	r7, #48	@ 0x30
 8024292:	46bd      	mov	sp, r7
 8024294:	bd80      	pop	{r7, pc}

08024296 <fp_mulmod>:

/* d = a * b (mod c) */
int fp_mulmod(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 8024296:	b580      	push	{r7, lr}
 8024298:	b088      	sub	sp, #32
 802429a:	af00      	add	r7, sp, #0
 802429c:	60f8      	str	r0, [r7, #12]
 802429e:	60b9      	str	r1, [r7, #8]
 80242a0:	607a      	str	r2, [r7, #4]
 80242a2:	603b      	str	r3, [r7, #0]
#else
   fp_int *t;
#endif

#ifdef WOLFSSL_SMALL_STACK
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 80242a4:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 80242a8:	f7fa fbf4 	bl	801ea94 <wolfSSL_Malloc>
 80242ac:	61b8      	str	r0, [r7, #24]
   if (t == NULL)
 80242ae:	69bb      	ldr	r3, [r7, #24]
 80242b0:	2b00      	cmp	r3, #0
 80242b2:	d102      	bne.n	80242ba <fp_mulmod+0x24>
       return FP_MEM;
 80242b4:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80242b8:	e029      	b.n	802430e <fp_mulmod+0x78>
#endif

  fp_init(t);
 80242ba:	69b8      	ldr	r0, [r7, #24]
 80242bc:	f002 f9fe 	bl	80266bc <fp_init>
  err = fp_mul(a, b, t);
 80242c0:	69ba      	ldr	r2, [r7, #24]
 80242c2:	68b9      	ldr	r1, [r7, #8]
 80242c4:	68f8      	ldr	r0, [r7, #12]
 80242c6:	f7fe f9f0 	bl	80226aa <fp_mul>
 80242ca:	61f8      	str	r0, [r7, #28]
  if (err == FP_OKAY) {
 80242cc:	69fb      	ldr	r3, [r7, #28]
 80242ce:	2b00      	cmp	r3, #0
 80242d0:	d114      	bne.n	80242fc <fp_mulmod+0x66>
  #if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    if (d->size < FP_SIZE) {
 80242d2:	683b      	ldr	r3, [r7, #0]
 80242d4:	689b      	ldr	r3, [r3, #8]
 80242d6:	2b87      	cmp	r3, #135	@ 0x87
 80242d8:	dc0a      	bgt.n	80242f0 <fp_mulmod+0x5a>
      err = fp_mod(t, c, t);
 80242da:	69ba      	ldr	r2, [r7, #24]
 80242dc:	6879      	ldr	r1, [r7, #4]
 80242de:	69b8      	ldr	r0, [r7, #24]
 80242e0:	f7ff f97c 	bl	80235dc <fp_mod>
 80242e4:	61f8      	str	r0, [r7, #28]
      fp_copy(t, d);
 80242e6:	6839      	ldr	r1, [r7, #0]
 80242e8:	69b8      	ldr	r0, [r7, #24]
 80242ea:	f002 fbd1 	bl	8026a90 <fp_copy>
 80242ee:	e005      	b.n	80242fc <fp_mulmod+0x66>
    } else
  #endif
    {
      err = fp_mod(t, c, d);
 80242f0:	683a      	ldr	r2, [r7, #0]
 80242f2:	6879      	ldr	r1, [r7, #4]
 80242f4:	69b8      	ldr	r0, [r7, #24]
 80242f6:	f7ff f971 	bl	80235dc <fp_mod>
 80242fa:	61f8      	str	r0, [r7, #28]
    }
  }

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 80242fc:	69bb      	ldr	r3, [r7, #24]
 80242fe:	617b      	str	r3, [r7, #20]
 8024300:	697b      	ldr	r3, [r7, #20]
 8024302:	2b00      	cmp	r3, #0
 8024304:	d002      	beq.n	802430c <fp_mulmod+0x76>
 8024306:	6978      	ldr	r0, [r7, #20]
 8024308:	f7fa fbe0 	bl	801eacc <wolfSSL_Free>
#endif
  return err;
 802430c:	69fb      	ldr	r3, [r7, #28]
}
 802430e:	4618      	mov	r0, r3
 8024310:	3720      	adds	r7, #32
 8024312:	46bd      	mov	sp, r7
 8024314:	bd80      	pop	{r7, pc}

08024316 <fp_submod_ct>:

/* d = a - b (mod c) - constant time (a < c and b < c and all positive)
 * c and d must not be the same pointers.
 */
int fp_submod_ct(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 8024316:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 802431a:	b09b      	sub	sp, #108	@ 0x6c
 802431c:	af00      	add	r7, sp, #0
 802431e:	6578      	str	r0, [r7, #84]	@ 0x54
 8024320:	6539      	str	r1, [r7, #80]	@ 0x50
 8024322:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8024324:	64bb      	str	r3, [r7, #72]	@ 0x48
  fp_sword w;
  fp_digit mask;
  int i;

  if (c->used + 1 > FP_SIZE) {
 8024326:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8024328:	681b      	ldr	r3, [r3, #0]
 802432a:	2b87      	cmp	r3, #135	@ 0x87
 802432c:	dd02      	ble.n	8024334 <fp_submod_ct+0x1e>
    return FP_VAL;
 802432e:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8024332:	e106      	b.n	8024542 <fp_submod_ct+0x22c>
  }
  if (c == d) {
 8024334:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8024336:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024338:	429a      	cmp	r2, r3
 802433a:	d102      	bne.n	8024342 <fp_submod_ct+0x2c>
    return FP_VAL;
 802433c:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8024340:	e0ff      	b.n	8024542 <fp_submod_ct+0x22c>
  }

  /* In constant time, subtract b from a putting result in d. */
  w = 0;
 8024342:	f04f 0200 	mov.w	r2, #0
 8024346:	f04f 0300 	mov.w	r3, #0
 802434a:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 802434e:	2300      	movs	r3, #0
 8024350:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8024352:	e03e      	b.n	80243d2 <fp_submod_ct+0xbc>
    w         += a->dp[i];
 8024354:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8024356:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024358:	3302      	adds	r3, #2
 802435a:	009b      	lsls	r3, r3, #2
 802435c:	4413      	add	r3, r2
 802435e:	685b      	ldr	r3, [r3, #4]
 8024360:	2200      	movs	r2, #0
 8024362:	643b      	str	r3, [r7, #64]	@ 0x40
 8024364:	647a      	str	r2, [r7, #68]	@ 0x44
 8024366:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 802436a:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 802436c:	1851      	adds	r1, r2, r1
 802436e:	62b9      	str	r1, [r7, #40]	@ 0x28
 8024370:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 8024372:	414b      	adcs	r3, r1
 8024374:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024376:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 802437a:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
    w         -= b->dp[i];
 802437e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8024380:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024382:	3302      	adds	r3, #2
 8024384:	009b      	lsls	r3, r3, #2
 8024386:	4413      	add	r3, r2
 8024388:	685b      	ldr	r3, [r3, #4]
 802438a:	2200      	movs	r2, #0
 802438c:	63bb      	str	r3, [r7, #56]	@ 0x38
 802438e:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8024390:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8024394:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8024396:	1a51      	subs	r1, r2, r1
 8024398:	6239      	str	r1, [r7, #32]
 802439a:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 802439c:	eb63 0301 	sbc.w	r3, r3, r1
 80243a0:	627b      	str	r3, [r7, #36]	@ 0x24
 80243a2:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80243a6:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
    d->dp[i]   = (fp_digit)w;
 80243aa:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80243ac:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80243ae:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80243b0:	3302      	adds	r3, #2
 80243b2:	009b      	lsls	r3, r3, #2
 80243b4:	4413      	add	r3, r2
 80243b6:	6059      	str	r1, [r3, #4]
    w        >>= DIGIT_BIT;
 80243b8:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80243bc:	f04f 0000 	mov.w	r0, #0
 80243c0:	f04f 0100 	mov.w	r1, #0
 80243c4:	0018      	movs	r0, r3
 80243c6:	17d9      	asrs	r1, r3, #31
 80243c8:	e9c7 0118 	strd	r0, r1, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 80243cc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80243ce:	3301      	adds	r3, #1
 80243d0:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80243d2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80243d4:	681a      	ldr	r2, [r3, #0]
 80243d6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80243d8:	4293      	cmp	r3, r2
 80243da:	dbbb      	blt.n	8024354 <fp_submod_ct+0x3e>
  }
  w  += a->dp[i];
 80243dc:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80243de:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80243e0:	3302      	adds	r3, #2
 80243e2:	009b      	lsls	r3, r3, #2
 80243e4:	4413      	add	r3, r2
 80243e6:	685b      	ldr	r3, [r3, #4]
 80243e8:	2200      	movs	r2, #0
 80243ea:	461c      	mov	r4, r3
 80243ec:	4615      	mov	r5, r2
 80243ee:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80243f2:	1911      	adds	r1, r2, r4
 80243f4:	61b9      	str	r1, [r7, #24]
 80243f6:	416b      	adcs	r3, r5
 80243f8:	61fb      	str	r3, [r7, #28]
 80243fa:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 80243fe:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
  w  -= b->dp[i];
 8024402:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8024404:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024406:	3302      	adds	r3, #2
 8024408:	009b      	lsls	r3, r3, #2
 802440a:	4413      	add	r3, r2
 802440c:	685b      	ldr	r3, [r3, #4]
 802440e:	2200      	movs	r2, #0
 8024410:	633b      	str	r3, [r7, #48]	@ 0x30
 8024412:	637a      	str	r2, [r7, #52]	@ 0x34
 8024414:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8024418:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 802441c:	4621      	mov	r1, r4
 802441e:	1a51      	subs	r1, r2, r1
 8024420:	6139      	str	r1, [r7, #16]
 8024422:	4629      	mov	r1, r5
 8024424:	eb63 0301 	sbc.w	r3, r3, r1
 8024428:	617b      	str	r3, [r7, #20]
 802442a:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 802442e:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
  w >>= DIGIT_BIT;
 8024432:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
 8024436:	f04f 0200 	mov.w	r2, #0
 802443a:	f04f 0300 	mov.w	r3, #0
 802443e:	000a      	movs	r2, r1
 8024440:	17cb      	asrs	r3, r1, #31
 8024442:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  /* When w is negative then we need to add modulus to make result positive. */
  mask = (fp_digit)0 - (w < 0);
 8024446:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
 802444a:	f04f 0200 	mov.w	r2, #0
 802444e:	f04f 0300 	mov.w	r3, #0
 8024452:	0fca      	lsrs	r2, r1, #31
 8024454:	2300      	movs	r3, #0
 8024456:	b2d3      	uxtb	r3, r2
 8024458:	425b      	negs	r3, r3
 802445a:	65bb      	str	r3, [r7, #88]	@ 0x58
  /* Constant time, conditionally, add modulus to difference. */
  w = 0;
 802445c:	f04f 0200 	mov.w	r2, #0
 8024460:	f04f 0300 	mov.w	r3, #0
 8024464:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 8024468:	2300      	movs	r3, #0
 802446a:	65fb      	str	r3, [r7, #92]	@ 0x5c
 802446c:	e03f      	b.n	80244ee <fp_submod_ct+0x1d8>
    w         += d->dp[i];
 802446e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8024470:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024472:	3302      	adds	r3, #2
 8024474:	009b      	lsls	r3, r3, #2
 8024476:	4413      	add	r3, r2
 8024478:	685b      	ldr	r3, [r3, #4]
 802447a:	2200      	movs	r2, #0
 802447c:	4698      	mov	r8, r3
 802447e:	4691      	mov	r9, r2
 8024480:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8024484:	eb12 0108 	adds.w	r1, r2, r8
 8024488:	60b9      	str	r1, [r7, #8]
 802448a:	eb43 0309 	adc.w	r3, r3, r9
 802448e:	60fb      	str	r3, [r7, #12]
 8024490:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8024494:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
    w         += c->dp[i] & mask;
 8024498:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802449a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802449c:	3302      	adds	r3, #2
 802449e:	009b      	lsls	r3, r3, #2
 80244a0:	4413      	add	r3, r2
 80244a2:	685a      	ldr	r2, [r3, #4]
 80244a4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80244a6:	4013      	ands	r3, r2
 80244a8:	2200      	movs	r2, #0
 80244aa:	469a      	mov	sl, r3
 80244ac:	4693      	mov	fp, r2
 80244ae:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80244b2:	eb12 010a 	adds.w	r1, r2, sl
 80244b6:	6039      	str	r1, [r7, #0]
 80244b8:	eb43 030b 	adc.w	r3, r3, fp
 80244bc:	607b      	str	r3, [r7, #4]
 80244be:	e9d7 3400 	ldrd	r3, r4, [r7]
 80244c2:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
    d->dp[i]   = (fp_digit)w;
 80244c6:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80244c8:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 80244ca:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80244cc:	3302      	adds	r3, #2
 80244ce:	009b      	lsls	r3, r3, #2
 80244d0:	440b      	add	r3, r1
 80244d2:	605a      	str	r2, [r3, #4]
    w        >>= DIGIT_BIT;
 80244d4:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
 80244d8:	f04f 0200 	mov.w	r2, #0
 80244dc:	f04f 0300 	mov.w	r3, #0
 80244e0:	000a      	movs	r2, r1
 80244e2:	17cb      	asrs	r3, r1, #31
 80244e4:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
  for (i = 0; i < c->used; i++) {
 80244e8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80244ea:	3301      	adds	r3, #1
 80244ec:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80244ee:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80244f0:	681b      	ldr	r3, [r3, #0]
 80244f2:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80244f4:	429a      	cmp	r2, r3
 80244f6:	dbba      	blt.n	802446e <fp_submod_ct+0x158>
  }
  /* Result will always have digits equal to or less than those in modulus. */
  d->used = i;
 80244f8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80244fa:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80244fc:	601a      	str	r2, [r3, #0]
  d->sign = FP_ZPOS;
 80244fe:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024500:	2200      	movs	r2, #0
 8024502:	605a      	str	r2, [r3, #4]
  fp_clamp(d);
 8024504:	e004      	b.n	8024510 <fp_submod_ct+0x1fa>
 8024506:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024508:	681b      	ldr	r3, [r3, #0]
 802450a:	1e5a      	subs	r2, r3, #1
 802450c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802450e:	601a      	str	r2, [r3, #0]
 8024510:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024512:	681b      	ldr	r3, [r3, #0]
 8024514:	2b00      	cmp	r3, #0
 8024516:	d009      	beq.n	802452c <fp_submod_ct+0x216>
 8024518:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802451a:	681b      	ldr	r3, [r3, #0]
 802451c:	3b01      	subs	r3, #1
 802451e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8024520:	3302      	adds	r3, #2
 8024522:	009b      	lsls	r3, r3, #2
 8024524:	4413      	add	r3, r2
 8024526:	685b      	ldr	r3, [r3, #4]
 8024528:	2b00      	cmp	r3, #0
 802452a:	d0ec      	beq.n	8024506 <fp_submod_ct+0x1f0>
 802452c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802452e:	681b      	ldr	r3, [r3, #0]
 8024530:	2b00      	cmp	r3, #0
 8024532:	d002      	beq.n	802453a <fp_submod_ct+0x224>
 8024534:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024536:	685b      	ldr	r3, [r3, #4]
 8024538:	e000      	b.n	802453c <fp_submod_ct+0x226>
 802453a:	2300      	movs	r3, #0
 802453c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802453e:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 8024540:	2300      	movs	r3, #0
}
 8024542:	4618      	mov	r0, r3
 8024544:	376c      	adds	r7, #108	@ 0x6c
 8024546:	46bd      	mov	sp, r7
 8024548:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 802454c:	4770      	bx	lr

0802454e <fp_addmod_ct>:

/* d = a + b (mod c) - constant time (a < c and b < c and all positive)
 * c and d must not be the same pointers.
 */
int fp_addmod_ct(fp_int *a, fp_int *b, fp_int *c, fp_int *d)
{
 802454e:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8024552:	b0a5      	sub	sp, #148	@ 0x94
 8024554:	af00      	add	r7, sp, #0
 8024556:	6778      	str	r0, [r7, #116]	@ 0x74
 8024558:	6739      	str	r1, [r7, #112]	@ 0x70
 802455a:	66fa      	str	r2, [r7, #108]	@ 0x6c
 802455c:	66bb      	str	r3, [r7, #104]	@ 0x68
  fp_word  w;
  fp_sword s;
  fp_digit mask;
  int i;

  if (c == d) {
 802455e:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8024560:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024562:	429a      	cmp	r2, r3
 8024564:	d102      	bne.n	802456c <fp_addmod_ct+0x1e>
    return FP_VAL;
 8024566:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802456a:	e11d      	b.n	80247a8 <fp_addmod_ct+0x25a>

  /* Add a to b into d. Do the subtract of modulus but don't store result.
   * When subtract result is negative, the overflow will be negative.
   * Only need to subtract mod when result is positive - overflow is positive.
   */
  w = 0;
 802456c:	f04f 0200 	mov.w	r2, #0
 8024570:	f04f 0300 	mov.w	r3, #0
 8024574:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
  s = 0;
 8024578:	f04f 0200 	mov.w	r2, #0
 802457c:	f04f 0300 	mov.w	r3, #0
 8024580:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
  for (i = 0; i < c->used; i++) {
 8024584:	2300      	movs	r3, #0
 8024586:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8024588:	e06f      	b.n	802466a <fp_addmod_ct+0x11c>
    w         += a->dp[i];
 802458a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 802458c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802458e:	3302      	adds	r3, #2
 8024590:	009b      	lsls	r3, r3, #2
 8024592:	4413      	add	r3, r2
 8024594:	685b      	ldr	r3, [r3, #4]
 8024596:	2200      	movs	r2, #0
 8024598:	663b      	str	r3, [r7, #96]	@ 0x60
 802459a:	667a      	str	r2, [r7, #100]	@ 0x64
 802459c:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 80245a0:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80245a2:	1851      	adds	r1, r2, r1
 80245a4:	6439      	str	r1, [r7, #64]	@ 0x40
 80245a6:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 80245a8:	414b      	adcs	r3, r1
 80245aa:	647b      	str	r3, [r7, #68]	@ 0x44
 80245ac:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80245b0:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    w         += b->dp[i];
 80245b4:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80245b6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80245b8:	3302      	adds	r3, #2
 80245ba:	009b      	lsls	r3, r3, #2
 80245bc:	4413      	add	r3, r2
 80245be:	685b      	ldr	r3, [r3, #4]
 80245c0:	2200      	movs	r2, #0
 80245c2:	65bb      	str	r3, [r7, #88]	@ 0x58
 80245c4:	65fa      	str	r2, [r7, #92]	@ 0x5c
 80245c6:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 80245ca:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 80245cc:	1851      	adds	r1, r2, r1
 80245ce:	63b9      	str	r1, [r7, #56]	@ 0x38
 80245d0:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 80245d2:	414b      	adcs	r3, r1
 80245d4:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80245d6:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 80245da:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    d->dp[i]   = (fp_digit)w;
 80245de:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 80245e2:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80245e4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80245e6:	3302      	adds	r3, #2
 80245e8:	009b      	lsls	r3, r3, #2
 80245ea:	4413      	add	r3, r2
 80245ec:	6059      	str	r1, [r3, #4]
    s         += (fp_digit)w;
 80245ee:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80245f2:	2200      	movs	r2, #0
 80245f4:	653b      	str	r3, [r7, #80]	@ 0x50
 80245f6:	657a      	str	r2, [r7, #84]	@ 0x54
 80245f8:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 80245fc:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 80245fe:	1851      	adds	r1, r2, r1
 8024600:	6339      	str	r1, [r7, #48]	@ 0x30
 8024602:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8024604:	414b      	adcs	r3, r1
 8024606:	637b      	str	r3, [r7, #52]	@ 0x34
 8024608:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 802460c:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
    s         -= c->dp[i];
 8024610:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8024612:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024614:	3302      	adds	r3, #2
 8024616:	009b      	lsls	r3, r3, #2
 8024618:	4413      	add	r3, r2
 802461a:	685b      	ldr	r3, [r3, #4]
 802461c:	2200      	movs	r2, #0
 802461e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8024620:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8024622:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8024626:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8024628:	1a51      	subs	r1, r2, r1
 802462a:	62b9      	str	r1, [r7, #40]	@ 0x28
 802462c:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 802462e:	eb63 0301 	sbc.w	r3, r3, r1
 8024632:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024634:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8024638:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
    w        >>= DIGIT_BIT;
 802463c:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8024640:	f04f 0000 	mov.w	r0, #0
 8024644:	f04f 0100 	mov.w	r1, #0
 8024648:	0018      	movs	r0, r3
 802464a:	2100      	movs	r1, #0
 802464c:	e9c7 0122 	strd	r0, r1, [r7, #136]	@ 0x88
    s        >>= DIGIT_BIT;
 8024650:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8024654:	f04f 0000 	mov.w	r0, #0
 8024658:	f04f 0100 	mov.w	r1, #0
 802465c:	0018      	movs	r0, r3
 802465e:	17d9      	asrs	r1, r3, #31
 8024660:	e9c7 0120 	strd	r0, r1, [r7, #128]	@ 0x80
  for (i = 0; i < c->used; i++) {
 8024664:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024666:	3301      	adds	r3, #1
 8024668:	67fb      	str	r3, [r7, #124]	@ 0x7c
 802466a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 802466c:	681a      	ldr	r2, [r3, #0]
 802466e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024670:	4293      	cmp	r3, r2
 8024672:	db8a      	blt.n	802458a <fp_addmod_ct+0x3c>
  }
  s += (fp_digit)w;
 8024674:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8024678:	2200      	movs	r2, #0
 802467a:	469a      	mov	sl, r3
 802467c:	4693      	mov	fp, r2
 802467e:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8024682:	eb12 010a 	adds.w	r1, r2, sl
 8024686:	6239      	str	r1, [r7, #32]
 8024688:	eb43 030b 	adc.w	r3, r3, fp
 802468c:	627b      	str	r3, [r7, #36]	@ 0x24
 802468e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8024692:	e9c7 2320 	strd	r2, r3, [r7, #128]	@ 0x80
  /* s will be positive when subtracting modulus is needed. */
  mask = (fp_digit)0 - (s >= 0);
 8024696:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 802469a:	43d1      	mvns	r1, r2
 802469c:	61b9      	str	r1, [r7, #24]
 802469e:	43db      	mvns	r3, r3
 80246a0:	61fb      	str	r3, [r7, #28]
 80246a2:	f04f 0200 	mov.w	r2, #0
 80246a6:	f04f 0300 	mov.w	r3, #0
 80246aa:	69f9      	ldr	r1, [r7, #28]
 80246ac:	0fca      	lsrs	r2, r1, #31
 80246ae:	2300      	movs	r3, #0
 80246b0:	b2d3      	uxtb	r3, r2
 80246b2:	425b      	negs	r3, r3
 80246b4:	67bb      	str	r3, [r7, #120]	@ 0x78

  /* Constant time, conditionally, subtract modulus from sum. */
  w = 0;
 80246b6:	f04f 0200 	mov.w	r2, #0
 80246ba:	f04f 0300 	mov.w	r3, #0
 80246be:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
  for (i = 0; i < c->used; i++) {
 80246c2:	2300      	movs	r3, #0
 80246c4:	67fb      	str	r3, [r7, #124]	@ 0x7c
 80246c6:	e045      	b.n	8024754 <fp_addmod_ct+0x206>
    w        += c->dp[i] & mask;
 80246c8:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80246ca:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80246cc:	3302      	adds	r3, #2
 80246ce:	009b      	lsls	r3, r3, #2
 80246d0:	4413      	add	r3, r2
 80246d2:	685a      	ldr	r2, [r3, #4]
 80246d4:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80246d6:	4013      	ands	r3, r2
 80246d8:	2200      	movs	r2, #0
 80246da:	461c      	mov	r4, r3
 80246dc:	4615      	mov	r5, r2
 80246de:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 80246e2:	1911      	adds	r1, r2, r4
 80246e4:	6139      	str	r1, [r7, #16]
 80246e6:	416b      	adcs	r3, r5
 80246e8:	617b      	str	r3, [r7, #20]
 80246ea:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80246ee:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    w         = d->dp[i] - w;
 80246f2:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80246f4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80246f6:	3302      	adds	r3, #2
 80246f8:	009b      	lsls	r3, r3, #2
 80246fa:	4413      	add	r3, r2
 80246fc:	685b      	ldr	r3, [r3, #4]
 80246fe:	2200      	movs	r2, #0
 8024700:	4698      	mov	r8, r3
 8024702:	4691      	mov	r9, r2
 8024704:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 8024708:	ebb8 0102 	subs.w	r1, r8, r2
 802470c:	60b9      	str	r1, [r7, #8]
 802470e:	eb69 0303 	sbc.w	r3, r9, r3
 8024712:	60fb      	str	r3, [r7, #12]
 8024714:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8024718:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
    d->dp[i]  = (fp_digit)w;
 802471c:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8024720:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8024722:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024724:	3302      	adds	r3, #2
 8024726:	009b      	lsls	r3, r3, #2
 8024728:	440b      	add	r3, r1
 802472a:	605a      	str	r2, [r3, #4]
    w         = (w >> DIGIT_BIT)&1;
 802472c:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
 8024730:	f04f 0200 	mov.w	r2, #0
 8024734:	f04f 0300 	mov.w	r3, #0
 8024738:	000a      	movs	r2, r1
 802473a:	2300      	movs	r3, #0
 802473c:	f002 0301 	and.w	r3, r2, #1
 8024740:	603b      	str	r3, [r7, #0]
 8024742:	2300      	movs	r3, #0
 8024744:	607b      	str	r3, [r7, #4]
 8024746:	e9d7 2300 	ldrd	r2, r3, [r7]
 802474a:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
  for (i = 0; i < c->used; i++) {
 802474e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024750:	3301      	adds	r3, #1
 8024752:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8024754:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024756:	681b      	ldr	r3, [r3, #0]
 8024758:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 802475a:	429a      	cmp	r2, r3
 802475c:	dbb4      	blt.n	80246c8 <fp_addmod_ct+0x17a>
  }
  /* Result will always have digits equal to or less than those in modulus. */
  d->used = i;
 802475e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024760:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8024762:	601a      	str	r2, [r3, #0]
  d->sign = FP_ZPOS;
 8024764:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024766:	2200      	movs	r2, #0
 8024768:	605a      	str	r2, [r3, #4]
  fp_clamp(d);
 802476a:	e004      	b.n	8024776 <fp_addmod_ct+0x228>
 802476c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802476e:	681b      	ldr	r3, [r3, #0]
 8024770:	1e5a      	subs	r2, r3, #1
 8024772:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024774:	601a      	str	r2, [r3, #0]
 8024776:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024778:	681b      	ldr	r3, [r3, #0]
 802477a:	2b00      	cmp	r3, #0
 802477c:	d009      	beq.n	8024792 <fp_addmod_ct+0x244>
 802477e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024780:	681b      	ldr	r3, [r3, #0]
 8024782:	3b01      	subs	r3, #1
 8024784:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024786:	3302      	adds	r3, #2
 8024788:	009b      	lsls	r3, r3, #2
 802478a:	4413      	add	r3, r2
 802478c:	685b      	ldr	r3, [r3, #4]
 802478e:	2b00      	cmp	r3, #0
 8024790:	d0ec      	beq.n	802476c <fp_addmod_ct+0x21e>
 8024792:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024794:	681b      	ldr	r3, [r3, #0]
 8024796:	2b00      	cmp	r3, #0
 8024798:	d002      	beq.n	80247a0 <fp_addmod_ct+0x252>
 802479a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 802479c:	685b      	ldr	r3, [r3, #4]
 802479e:	e000      	b.n	80247a2 <fp_addmod_ct+0x254>
 80247a0:	2300      	movs	r3, #0
 80247a2:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80247a4:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 80247a6:	2300      	movs	r3, #0
}
 80247a8:	4618      	mov	r0, r3
 80247aa:	3794      	adds	r7, #148	@ 0x94
 80247ac:	46bd      	mov	sp, r7
 80247ae:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80247b2:	4770      	bx	lr

080247b4 <_fp_exptmod_ct>:
   Based on work by Marc Joye, Sung-Ming Yen, "The Montgomery Powering Ladder",
   Cryptographic Hardware and Embedded Systems, CHES 2002
*/
static int _fp_exptmod_ct(fp_int * G, fp_int * X, int digits, fp_int * P,
                          fp_int * Y)
{
 80247b4:	b590      	push	{r4, r7, lr}
 80247b6:	b095      	sub	sp, #84	@ 0x54
 80247b8:	af00      	add	r7, sp, #0
 80247ba:	60f8      	str	r0, [r7, #12]
 80247bc:	60b9      	str	r1, [r7, #8]
 80247be:	607a      	str	r2, [r7, #4]
 80247c0:	603b      	str	r3, [r7, #0]
#endif
  fp_digit buf, mp;
  int      err, bitcnt, digidx, y;

  /* now setup montgomery  */
  if ((err = fp_montgomery_setup (P, &mp)) != FP_OKAY) {
 80247c2:	f107 0314 	add.w	r3, r7, #20
 80247c6:	4619      	mov	r1, r3
 80247c8:	6838      	ldr	r0, [r7, #0]
 80247ca:	f001 fa0b 	bl	8025be4 <fp_montgomery_setup>
 80247ce:	6438      	str	r0, [r7, #64]	@ 0x40
 80247d0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80247d2:	2b00      	cmp	r3, #0
 80247d4:	d001      	beq.n	80247da <_fp_exptmod_ct+0x26>
     return err;
 80247d6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80247d8:	e146      	b.n	8024a68 <_fp_exptmod_ct+0x2b4>
  }

#ifdef WOLFSSL_SMALL_STACK
#ifndef WC_NO_CACHE_RESISTANT
   R = (fp_int*)XMALLOC(sizeof(fp_int) * 3, NULL, DYNAMIC_TYPE_BIGINT);
 80247da:	f240 6084 	movw	r0, #1668	@ 0x684
 80247de:	f7fa f959 	bl	801ea94 <wolfSSL_Malloc>
 80247e2:	63f8      	str	r0, [r7, #60]	@ 0x3c
#else
   R = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_BIGINT);
#endif
   if (R == NULL)
 80247e4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80247e6:	2b00      	cmp	r3, #0
 80247e8:	d102      	bne.n	80247f0 <_fp_exptmod_ct+0x3c>
       return FP_MEM;
 80247ea:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80247ee:	e13b      	b.n	8024a68 <_fp_exptmod_ct+0x2b4>
#endif
  fp_init(&R[0]);
 80247f0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80247f2:	f001 ff63 	bl	80266bc <fp_init>
  fp_init(&R[1]);
 80247f6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80247f8:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80247fc:	4618      	mov	r0, r3
 80247fe:	f001 ff5d 	bl	80266bc <fp_init>
#ifndef WC_NO_CACHE_RESISTANT
  fp_init(&R[2]);
 8024802:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024804:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024808:	4618      	mov	r0, r3
 802480a:	f001 ff57 	bl	80266bc <fp_init>
#endif

  /* now we need R mod m */
  err = fp_montgomery_calc_normalization (&R[0], P);
 802480e:	6839      	ldr	r1, [r7, #0]
 8024810:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024812:	f001 fa28 	bl	8025c66 <fp_montgomery_calc_normalization>
 8024816:	6438      	str	r0, [r7, #64]	@ 0x40
  if (err != FP_OKAY) {
 8024818:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802481a:	2b00      	cmp	r3, #0
 802481c:	d009      	beq.n	8024832 <_fp_exptmod_ct+0x7e>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 802481e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024820:	61bb      	str	r3, [r7, #24]
 8024822:	69bb      	ldr	r3, [r7, #24]
 8024824:	2b00      	cmp	r3, #0
 8024826:	d002      	beq.n	802482e <_fp_exptmod_ct+0x7a>
 8024828:	69b8      	ldr	r0, [r7, #24]
 802482a:	f7fa f94f 	bl	801eacc <wolfSSL_Free>
  #endif
    return err;
 802482e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024830:	e11a      	b.n	8024a68 <_fp_exptmod_ct+0x2b4>
  }

  /* now set R[0][1] to G * R mod m */
  if (fp_cmp_mag(P, G) != FP_GT) {
 8024832:	68f9      	ldr	r1, [r7, #12]
 8024834:	6838      	ldr	r0, [r7, #0]
 8024836:	f001 f98c 	bl	8025b52 <fp_cmp_mag>
 802483a:	4603      	mov	r3, r0
 802483c:	2b01      	cmp	r3, #1
 802483e:	d015      	beq.n	802486c <_fp_exptmod_ct+0xb8>
     /* G > P so we reduce it first */
     err = fp_mod(G, P, &R[1]);
 8024840:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024842:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024846:	461a      	mov	r2, r3
 8024848:	6839      	ldr	r1, [r7, #0]
 802484a:	68f8      	ldr	r0, [r7, #12]
 802484c:	f7fe fec6 	bl	80235dc <fp_mod>
 8024850:	6438      	str	r0, [r7, #64]	@ 0x40
     if (err != FP_OKAY) {
 8024852:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024854:	2b00      	cmp	r3, #0
 8024856:	d010      	beq.n	802487a <_fp_exptmod_ct+0xc6>
#ifdef WOLFSSL_SMALL_STACK
         XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024858:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802485a:	63bb      	str	r3, [r7, #56]	@ 0x38
 802485c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802485e:	2b00      	cmp	r3, #0
 8024860:	d002      	beq.n	8024868 <_fp_exptmod_ct+0xb4>
 8024862:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8024864:	f7fa f932 	bl	801eacc <wolfSSL_Free>
#endif
         return err;
 8024868:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802486a:	e0fd      	b.n	8024a68 <_fp_exptmod_ct+0x2b4>
     }
  } else {
     fp_copy(G, &R[1]);
 802486c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802486e:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024872:	4619      	mov	r1, r3
 8024874:	68f8      	ldr	r0, [r7, #12]
 8024876:	f002 f90b 	bl	8026a90 <fp_copy>
  }
  err = fp_mulmod (&R[1], &R[0], P, &R[1]);
 802487a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802487c:	f503 700b 	add.w	r0, r3, #556	@ 0x22c
 8024880:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024882:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024886:	683a      	ldr	r2, [r7, #0]
 8024888:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 802488a:	f7ff fd04 	bl	8024296 <fp_mulmod>
 802488e:	6438      	str	r0, [r7, #64]	@ 0x40
  if (err != FP_OKAY) {
 8024890:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024892:	2b00      	cmp	r3, #0
 8024894:	d009      	beq.n	80248aa <_fp_exptmod_ct+0xf6>
#ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024896:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024898:	61fb      	str	r3, [r7, #28]
 802489a:	69fb      	ldr	r3, [r7, #28]
 802489c:	2b00      	cmp	r3, #0
 802489e:	d002      	beq.n	80248a6 <_fp_exptmod_ct+0xf2>
 80248a0:	69f8      	ldr	r0, [r7, #28]
 80248a2:	f7fa f913 	bl	801eacc <wolfSSL_Free>
#endif
      return err;
 80248a6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80248a8:	e0de      	b.n	8024a68 <_fp_exptmod_ct+0x2b4>
  /* for j = t-1 downto 0 do
        r_!k = R0*R1; r_k = r_k^2
  */

  /* set initial mode and bit cnt */
  bitcnt = 1;
 80248aa:	2301      	movs	r3, #1
 80248ac:	64bb      	str	r3, [r7, #72]	@ 0x48
  buf    = 0;
 80248ae:	2300      	movs	r3, #0
 80248b0:	64fb      	str	r3, [r7, #76]	@ 0x4c
  digidx = digits - 1;
 80248b2:	687b      	ldr	r3, [r7, #4]
 80248b4:	3b01      	subs	r3, #1
 80248b6:	647b      	str	r3, [r7, #68]	@ 0x44

  for (;;) {
    /* grab next digit as required */
    if (--bitcnt == 0) {
 80248b8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80248ba:	3b01      	subs	r3, #1
 80248bc:	64bb      	str	r3, [r7, #72]	@ 0x48
 80248be:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80248c0:	2b00      	cmp	r3, #0
 80248c2:	d10f      	bne.n	80248e4 <_fp_exptmod_ct+0x130>
      /* if digidx == -1 we are out of digits so break */
      if (digidx == -1) {
 80248c4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80248c6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80248ca:	f000 80b8 	beq.w	8024a3e <_fp_exptmod_ct+0x28a>
        break;
      }
      /* read next digit and reset bitcnt */
      buf    = X->dp[digidx--];
 80248ce:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80248d0:	1e5a      	subs	r2, r3, #1
 80248d2:	647a      	str	r2, [r7, #68]	@ 0x44
 80248d4:	68ba      	ldr	r2, [r7, #8]
 80248d6:	3302      	adds	r3, #2
 80248d8:	009b      	lsls	r3, r3, #2
 80248da:	4413      	add	r3, r2
 80248dc:	685b      	ldr	r3, [r3, #4]
 80248de:	64fb      	str	r3, [r7, #76]	@ 0x4c
      bitcnt = (int)DIGIT_BIT;
 80248e0:	2320      	movs	r3, #32
 80248e2:	64bb      	str	r3, [r7, #72]	@ 0x48
    }

    /* grab the next msb from the exponent */
    y     = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 80248e4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80248e6:	0fdb      	lsrs	r3, r3, #31
 80248e8:	633b      	str	r3, [r7, #48]	@ 0x30
    buf <<= (fp_digit)1;
 80248ea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80248ec:	005b      	lsls	r3, r3, #1
 80248ee:	64fb      	str	r3, [r7, #76]	@ 0x4c
    #endif
      return err;
    }
#else
    /* do ops */
    err = fp_mul(&R[0], &R[1], &R[2]);
 80248f0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80248f2:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 80248f6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80248f8:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 80248fc:	461a      	mov	r2, r3
 80248fe:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024900:	f7fd fed3 	bl	80226aa <fp_mul>
 8024904:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 8024906:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024908:	2b00      	cmp	r3, #0
 802490a:	d009      	beq.n	8024920 <_fp_exptmod_ct+0x16c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 802490c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802490e:	623b      	str	r3, [r7, #32]
 8024910:	6a3b      	ldr	r3, [r7, #32]
 8024912:	2b00      	cmp	r3, #0
 8024914:	d002      	beq.n	802491c <_fp_exptmod_ct+0x168>
 8024916:	6a38      	ldr	r0, [r7, #32]
 8024918:	f7fa f8d8 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 802491c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802491e:	e0a3      	b.n	8024a68 <_fp_exptmod_ct+0x2b4>
    }
    err = fp_montgomery_reduce(&R[2], P, mp);
 8024920:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024922:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 8024926:	697a      	ldr	r2, [r7, #20]
 8024928:	6839      	ldr	r1, [r7, #0]
 802492a:	4618      	mov	r0, r3
 802492c:	f001 fb21 	bl	8025f72 <fp_montgomery_reduce>
 8024930:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 8024932:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024934:	2b00      	cmp	r3, #0
 8024936:	d009      	beq.n	802494c <_fp_exptmod_ct+0x198>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024938:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802493a:	627b      	str	r3, [r7, #36]	@ 0x24
 802493c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802493e:	2b00      	cmp	r3, #0
 8024940:	d002      	beq.n	8024948 <_fp_exptmod_ct+0x194>
 8024942:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8024944:	f7fa f8c2 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8024948:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802494a:	e08d      	b.n	8024a68 <_fp_exptmod_ct+0x2b4>
    }
    /* instead of using R[y^1] for mul, which leaks key bit to cache monitor,
     * use R[2] as temp, make sure address calc is constant, keep
     * &R[0] and &R[1] in cache */
    fp_copy(&R[2],
 802494c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802494e:	f503 608b 	add.w	r0, r3, #1112	@ 0x458
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y]) +
 8024952:	4a47      	ldr	r2, [pc, #284]	@ (8024a70 <_fp_exptmod_ct+0x2bc>)
 8024954:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024956:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 802495a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802495c:	401a      	ands	r2, r3
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y^1]) ) );
 802495e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024960:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024964:	461c      	mov	r4, r3
 8024966:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024968:	f083 0301 	eor.w	r3, r3, #1
 802496c:	4940      	ldr	r1, [pc, #256]	@ (8024a70 <_fp_exptmod_ct+0x2bc>)
 802496e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8024972:	4023      	ands	r3, r4
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y]) +
 8024974:	4413      	add	r3, r2
    fp_copy(&R[2],
 8024976:	4619      	mov	r1, r3
 8024978:	f002 f88a 	bl	8026a90 <fp_copy>

    /* instead of using R[y] for sqr, which leaks key bit to cache monitor,
     * use R[2] as temp, make sure address calc is constant, keep
     * &R[0] and &R[1] in cache */
    fp_copy((fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 802497c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802497e:	f083 0301 	eor.w	r3, r3, #1
 8024982:	4a3b      	ldr	r2, [pc, #236]	@ (8024a70 <_fp_exptmod_ct+0x2bc>)
 8024984:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8024988:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802498a:	401a      	ands	r2, r3
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y]) ),
 802498c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802498e:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024992:	4618      	mov	r0, r3
 8024994:	4936      	ldr	r1, [pc, #216]	@ (8024a70 <_fp_exptmod_ct+0x2bc>)
 8024996:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024998:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 802499c:	4003      	ands	r3, r0
    fp_copy((fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 802499e:	4413      	add	r3, r2
 80249a0:	461a      	mov	r2, r3
 80249a2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249a4:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 80249a8:	4619      	mov	r1, r3
 80249aa:	4610      	mov	r0, r2
 80249ac:	f002 f870 	bl	8026a90 <fp_copy>
            &R[2]);
    err = fp_sqr(&R[2], &R[2]);
 80249b0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249b2:	f503 628b 	add.w	r2, r3, #1112	@ 0x458
 80249b6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249b8:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 80249bc:	4619      	mov	r1, r3
 80249be:	4610      	mov	r0, r2
 80249c0:	f000 fe1b 	bl	80255fa <fp_sqr>
 80249c4:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 80249c6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80249c8:	2b00      	cmp	r3, #0
 80249ca:	d009      	beq.n	80249e0 <_fp_exptmod_ct+0x22c>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 80249cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249ce:	62bb      	str	r3, [r7, #40]	@ 0x28
 80249d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80249d2:	2b00      	cmp	r3, #0
 80249d4:	d002      	beq.n	80249dc <_fp_exptmod_ct+0x228>
 80249d6:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80249d8:	f7fa f878 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 80249dc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80249de:	e043      	b.n	8024a68 <_fp_exptmod_ct+0x2b4>
    }
    err = fp_montgomery_reduce(&R[2], P, mp);
 80249e0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249e2:	f503 638b 	add.w	r3, r3, #1112	@ 0x458
 80249e6:	697a      	ldr	r2, [r7, #20]
 80249e8:	6839      	ldr	r1, [r7, #0]
 80249ea:	4618      	mov	r0, r3
 80249ec:	f001 fac1 	bl	8025f72 <fp_montgomery_reduce>
 80249f0:	6438      	str	r0, [r7, #64]	@ 0x40
    if (err != FP_OKAY) {
 80249f2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80249f4:	2b00      	cmp	r3, #0
 80249f6:	d009      	beq.n	8024a0c <_fp_exptmod_ct+0x258>
    #ifdef WOLFSSL_SMALL_STACK
      XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 80249f8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80249fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80249fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80249fe:	2b00      	cmp	r3, #0
 8024a00:	d002      	beq.n	8024a08 <_fp_exptmod_ct+0x254>
 8024a02:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8024a04:	f7fa f862 	bl	801eacc <wolfSSL_Free>
    #endif
      return err;
 8024a08:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024a0a:	e02d      	b.n	8024a68 <_fp_exptmod_ct+0x2b4>
    }
    fp_copy(&R[2],
 8024a0c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024a0e:	f503 608b 	add.w	r0, r3, #1112	@ 0x458
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 8024a12:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024a14:	f083 0301 	eor.w	r3, r3, #1
 8024a18:	4a15      	ldr	r2, [pc, #84]	@ (8024a70 <_fp_exptmod_ct+0x2bc>)
 8024a1a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8024a1e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024a20:	401a      	ands	r2, r3
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y]) ) );
 8024a22:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024a24:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024a28:	461c      	mov	r4, r3
 8024a2a:	4911      	ldr	r1, [pc, #68]	@ (8024a70 <_fp_exptmod_ct+0x2bc>)
 8024a2c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024a2e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8024a32:	4023      	ands	r3, r4
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 8024a34:	4413      	add	r3, r2
    fp_copy(&R[2],
 8024a36:	4619      	mov	r1, r3
 8024a38:	f002 f82a 	bl	8026a90 <fp_copy>
    if (--bitcnt == 0) {
 8024a3c:	e73c      	b.n	80248b8 <_fp_exptmod_ct+0x104>
        break;
 8024a3e:	bf00      	nop
#endif /* WC_NO_CACHE_RESISTANT */
  }

   err = fp_montgomery_reduce(&R[0], P, mp);
 8024a40:	697b      	ldr	r3, [r7, #20]
 8024a42:	461a      	mov	r2, r3
 8024a44:	6839      	ldr	r1, [r7, #0]
 8024a46:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024a48:	f001 fa93 	bl	8025f72 <fp_montgomery_reduce>
 8024a4c:	6438      	str	r0, [r7, #64]	@ 0x40
   fp_copy(&R[0], Y);
 8024a4e:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8024a50:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024a52:	f002 f81d 	bl	8026a90 <fp_copy>
#ifdef WOLFSSL_SMALL_STACK
   XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
 8024a56:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024a58:	637b      	str	r3, [r7, #52]	@ 0x34
 8024a5a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8024a5c:	2b00      	cmp	r3, #0
 8024a5e:	d002      	beq.n	8024a66 <_fp_exptmod_ct+0x2b2>
 8024a60:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8024a62:	f7fa f833 	bl	801eacc <wolfSSL_Free>
#endif

   return err;
 8024a66:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
}
 8024a68:	4618      	mov	r0, r3
 8024a6a:	3754      	adds	r7, #84	@ 0x54
 8024a6c:	46bd      	mov	sp, r7
 8024a6e:	bd90      	pop	{r4, r7, pc}
 8024a70:	08033c94 	.word	0x08033c94

08024a74 <_fp_exptmod_nct>:

/* y = g**x (mod b)
 * Some restrictions... x must be positive and < b
 */
static int _fp_exptmod_nct(fp_int * G, fp_int * X, fp_int * P, fp_int * Y)
{
 8024a74:	b580      	push	{r7, lr}
 8024a76:	b0a4      	sub	sp, #144	@ 0x90
 8024a78:	af00      	add	r7, sp, #0
 8024a7a:	60f8      	str	r0, [r7, #12]
 8024a7c:	60b9      	str	r1, [r7, #8]
 8024a7e:	607a      	str	r2, [r7, #4]
 8024a80:	603b      	str	r3, [r7, #0]
#else
  fp_int   M[(1 << 6) + 1];
#endif

  /* find window size */
  x = fp_count_bits (X);
 8024a82:	68b8      	ldr	r0, [r7, #8]
 8024a84:	f001 fc2e 	bl	80262e4 <fp_count_bits>
 8024a88:	6778      	str	r0, [r7, #116]	@ 0x74
  if (x <= 21) {
 8024a8a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024a8c:	2b15      	cmp	r3, #21
 8024a8e:	dc02      	bgt.n	8024a96 <_fp_exptmod_nct+0x22>
    winsize = 1;
 8024a90:	2301      	movs	r3, #1
 8024a92:	673b      	str	r3, [r7, #112]	@ 0x70
 8024a94:	e014      	b.n	8024ac0 <_fp_exptmod_nct+0x4c>
  } else if (x <= 36) {
 8024a96:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024a98:	2b24      	cmp	r3, #36	@ 0x24
 8024a9a:	dc02      	bgt.n	8024aa2 <_fp_exptmod_nct+0x2e>
    winsize = 3;
 8024a9c:	2303      	movs	r3, #3
 8024a9e:	673b      	str	r3, [r7, #112]	@ 0x70
 8024aa0:	e00e      	b.n	8024ac0 <_fp_exptmod_nct+0x4c>
  } else if (x <= 140) {
 8024aa2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024aa4:	2b8c      	cmp	r3, #140	@ 0x8c
 8024aa6:	dc02      	bgt.n	8024aae <_fp_exptmod_nct+0x3a>
    winsize = 4;
 8024aa8:	2304      	movs	r3, #4
 8024aaa:	673b      	str	r3, [r7, #112]	@ 0x70
 8024aac:	e008      	b.n	8024ac0 <_fp_exptmod_nct+0x4c>
  } else if (x <= 450) {
 8024aae:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024ab0:	f5b3 7fe1 	cmp.w	r3, #450	@ 0x1c2
 8024ab4:	dc02      	bgt.n	8024abc <_fp_exptmod_nct+0x48>
    winsize = 5;
 8024ab6:	2305      	movs	r3, #5
 8024ab8:	673b      	str	r3, [r7, #112]	@ 0x70
 8024aba:	e001      	b.n	8024ac0 <_fp_exptmod_nct+0x4c>
  } else {
    winsize = 6;
 8024abc:	2306      	movs	r3, #6
 8024abe:	673b      	str	r3, [r7, #112]	@ 0x70
  }

  /* now setup montgomery  */
  if ((err = fp_montgomery_setup (P, &mp)) != FP_OKAY) {
 8024ac0:	f107 0314 	add.w	r3, r7, #20
 8024ac4:	4619      	mov	r1, r3
 8024ac6:	6878      	ldr	r0, [r7, #4]
 8024ac8:	f001 f88c 	bl	8025be4 <fp_montgomery_setup>
 8024acc:	66f8      	str	r0, [r7, #108]	@ 0x6c
 8024ace:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ad0:	2b00      	cmp	r3, #0
 8024ad2:	d001      	beq.n	8024ad8 <_fp_exptmod_nct+0x64>
     return err;
 8024ad4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ad6:	e2a3      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
  }

#ifndef WOLFSSL_NO_MALLOC
  /* only allocate space for what's needed for window plus res */
  M = (fp_int*)XMALLOC(sizeof(fp_int)*((1 << winsize) + 1), NULL,
 8024ad8:	2201      	movs	r2, #1
 8024ada:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024adc:	fa02 f303 	lsl.w	r3, r2, r3
 8024ae0:	3301      	adds	r3, #1
 8024ae2:	461a      	mov	r2, r3
 8024ae4:	f44f 730b 	mov.w	r3, #556	@ 0x22c
 8024ae8:	fb02 f303 	mul.w	r3, r2, r3
 8024aec:	4618      	mov	r0, r3
 8024aee:	f7f9 ffd1 	bl	801ea94 <wolfSSL_Malloc>
 8024af2:	66b8      	str	r0, [r7, #104]	@ 0x68
                                                           DYNAMIC_TYPE_BIGINT);
  if (M == NULL) {
 8024af4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024af6:	2b00      	cmp	r3, #0
 8024af8:	d102      	bne.n	8024b00 <_fp_exptmod_nct+0x8c>
     return FP_MEM;
 8024afa:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8024afe:	e28f      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
  }
#endif
  res = &M[(word32)(1 << winsize)];
 8024b00:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024b04:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024b06:	fa02 f303 	lsl.w	r3, r2, r3
 8024b0a:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024b0c:	4413      	add	r3, r2
 8024b0e:	667b      	str	r3, [r7, #100]	@ 0x64

  /* init M array */
  for(x = 0; x < (1 << winsize); x++)
 8024b10:	2300      	movs	r3, #0
 8024b12:	677b      	str	r3, [r7, #116]	@ 0x74
 8024b14:	e00c      	b.n	8024b30 <_fp_exptmod_nct+0xbc>
    fp_init(&M[x]);
 8024b16:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024b18:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024b1c:	fb02 f303 	mul.w	r3, r2, r3
 8024b20:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024b22:	4413      	add	r3, r2
 8024b24:	4618      	mov	r0, r3
 8024b26:	f001 fdc9 	bl	80266bc <fp_init>
  for(x = 0; x < (1 << winsize); x++)
 8024b2a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024b2c:	3301      	adds	r3, #1
 8024b2e:	677b      	str	r3, [r7, #116]	@ 0x74
 8024b30:	2201      	movs	r2, #1
 8024b32:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024b34:	fa02 f303 	lsl.w	r3, r2, r3
 8024b38:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024b3a:	429a      	cmp	r2, r3
 8024b3c:	dbeb      	blt.n	8024b16 <_fp_exptmod_nct+0xa2>

  /* setup result */
  fp_init(res);
 8024b3e:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024b40:	f001 fdbc 	bl	80266bc <fp_init>
   *
   * The first half of the table is not computed though except for M[0] and M[1]
   */

  /* now we need R mod m */
  err = fp_montgomery_calc_normalization (res, P);
 8024b44:	6879      	ldr	r1, [r7, #4]
 8024b46:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024b48:	f001 f88d 	bl	8025c66 <fp_montgomery_calc_normalization>
 8024b4c:	66f8      	str	r0, [r7, #108]	@ 0x6c
  if (err != FP_OKAY) {
 8024b4e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024b50:	2b00      	cmp	r3, #0
 8024b52:	d009      	beq.n	8024b68 <_fp_exptmod_nct+0xf4>
#ifndef WOLFSSL_NO_MALLOC
    XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024b54:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024b56:	61bb      	str	r3, [r7, #24]
 8024b58:	69bb      	ldr	r3, [r7, #24]
 8024b5a:	2b00      	cmp	r3, #0
 8024b5c:	d002      	beq.n	8024b64 <_fp_exptmod_nct+0xf0>
 8024b5e:	69b8      	ldr	r0, [r7, #24]
 8024b60:	f7f9 ffb4 	bl	801eacc <wolfSSL_Free>
#endif
    return err;
 8024b64:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024b66:	e25b      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
  }

  /* now set M[1] to G * R mod m */
  if (fp_cmp_mag(P, G) != FP_GT) {
 8024b68:	68f9      	ldr	r1, [r7, #12]
 8024b6a:	6878      	ldr	r0, [r7, #4]
 8024b6c:	f000 fff1 	bl	8025b52 <fp_cmp_mag>
 8024b70:	4603      	mov	r3, r0
 8024b72:	2b01      	cmp	r3, #1
 8024b74:	d015      	beq.n	8024ba2 <_fp_exptmod_nct+0x12e>
     /* G > P so we reduce it first */
     err = fp_mod(G, P, &M[1]);
 8024b76:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024b78:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024b7c:	461a      	mov	r2, r3
 8024b7e:	6879      	ldr	r1, [r7, #4]
 8024b80:	68f8      	ldr	r0, [r7, #12]
 8024b82:	f7fe fd2b 	bl	80235dc <fp_mod>
 8024b86:	66f8      	str	r0, [r7, #108]	@ 0x6c
     if (err != FP_OKAY) {
 8024b88:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024b8a:	2b00      	cmp	r3, #0
 8024b8c:	d010      	beq.n	8024bb0 <_fp_exptmod_nct+0x13c>
     #ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024b8e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024b90:	663b      	str	r3, [r7, #96]	@ 0x60
 8024b92:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8024b94:	2b00      	cmp	r3, #0
 8024b96:	d002      	beq.n	8024b9e <_fp_exptmod_nct+0x12a>
 8024b98:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8024b9a:	f7f9 ff97 	bl	801eacc <wolfSSL_Free>
     #endif
        return err;
 8024b9e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ba0:	e23e      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
     }
  } else {
     fp_copy(G, &M[1]);
 8024ba2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ba4:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024ba8:	4619      	mov	r1, r3
 8024baa:	68f8      	ldr	r0, [r7, #12]
 8024bac:	f001 ff70 	bl	8026a90 <fp_copy>
  }
  err = fp_mulmod (&M[1], res, P, &M[1]);
 8024bb0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024bb2:	f503 700b 	add.w	r0, r3, #556	@ 0x22c
 8024bb6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024bb8:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024bbc:	687a      	ldr	r2, [r7, #4]
 8024bbe:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8024bc0:	f7ff fb69 	bl	8024296 <fp_mulmod>
 8024bc4:	66f8      	str	r0, [r7, #108]	@ 0x6c
  if (err != FP_OKAY) {
 8024bc6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024bc8:	2b00      	cmp	r3, #0
 8024bca:	d009      	beq.n	8024be0 <_fp_exptmod_nct+0x16c>
  #ifndef WOLFSSL_NO_MALLOC
     XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024bcc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024bce:	61fb      	str	r3, [r7, #28]
 8024bd0:	69fb      	ldr	r3, [r7, #28]
 8024bd2:	2b00      	cmp	r3, #0
 8024bd4:	d002      	beq.n	8024bdc <_fp_exptmod_nct+0x168>
 8024bd6:	69f8      	ldr	r0, [r7, #28]
 8024bd8:	f7f9 ff78 	bl	801eacc <wolfSSL_Free>
  #endif
     return err;
 8024bdc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024bde:	e21f      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
  }

  /* compute the value at M[1<<(winsize-1)] by
   * squaring M[1] (winsize-1) times */
  fp_copy (&M[1], &M[(word32)(1 << (winsize - 1))]);
 8024be0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024be2:	f503 700b 	add.w	r0, r3, #556	@ 0x22c
 8024be6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024be8:	3b01      	subs	r3, #1
 8024bea:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024bee:	fa02 f303 	lsl.w	r3, r2, r3
 8024bf2:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024bf4:	4413      	add	r3, r2
 8024bf6:	4619      	mov	r1, r3
 8024bf8:	f001 ff4a 	bl	8026a90 <fp_copy>
  for (x = 0; x < (winsize - 1); x++) {
 8024bfc:	2300      	movs	r3, #0
 8024bfe:	677b      	str	r3, [r7, #116]	@ 0x74
 8024c00:	e03e      	b.n	8024c80 <_fp_exptmod_nct+0x20c>
    err = fp_sqr (&M[(word32)(1 << (winsize - 1))],
 8024c02:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024c04:	3b01      	subs	r3, #1
 8024c06:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024c0a:	fa02 f303 	lsl.w	r3, r2, r3
 8024c0e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024c10:	18d0      	adds	r0, r2, r3
                  &M[(word32)(1 << (winsize - 1))]);
 8024c12:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024c14:	3b01      	subs	r3, #1
 8024c16:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024c1a:	fa02 f303 	lsl.w	r3, r2, r3
    err = fp_sqr (&M[(word32)(1 << (winsize - 1))],
 8024c1e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024c20:	4413      	add	r3, r2
 8024c22:	4619      	mov	r1, r3
 8024c24:	f000 fce9 	bl	80255fa <fp_sqr>
 8024c28:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8024c2a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024c2c:	2b00      	cmp	r3, #0
 8024c2e:	d009      	beq.n	8024c44 <_fp_exptmod_nct+0x1d0>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024c30:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024c32:	623b      	str	r3, [r7, #32]
 8024c34:	6a3b      	ldr	r3, [r7, #32]
 8024c36:	2b00      	cmp	r3, #0
 8024c38:	d002      	beq.n	8024c40 <_fp_exptmod_nct+0x1cc>
 8024c3a:	6a38      	ldr	r0, [r7, #32]
 8024c3c:	f7f9 ff46 	bl	801eacc <wolfSSL_Free>
#endif
      return err;
 8024c40:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024c42:	e1ed      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
    }
    err = fp_montgomery_reduce_ex(&M[(word32)(1 << (winsize - 1))], P, mp, 0);
 8024c44:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024c46:	3b01      	subs	r3, #1
 8024c48:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024c4c:	fa02 f303 	lsl.w	r3, r2, r3
 8024c50:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024c52:	18d0      	adds	r0, r2, r3
 8024c54:	697a      	ldr	r2, [r7, #20]
 8024c56:	2300      	movs	r3, #0
 8024c58:	6879      	ldr	r1, [r7, #4]
 8024c5a:	f001 f856 	bl	8025d0a <fp_montgomery_reduce_ex>
 8024c5e:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8024c60:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024c62:	2b00      	cmp	r3, #0
 8024c64:	d009      	beq.n	8024c7a <_fp_exptmod_nct+0x206>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024c66:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024c68:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c6a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c6c:	2b00      	cmp	r3, #0
 8024c6e:	d002      	beq.n	8024c76 <_fp_exptmod_nct+0x202>
 8024c70:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8024c72:	f7f9 ff2b 	bl	801eacc <wolfSSL_Free>
#endif
      return err;
 8024c76:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024c78:	e1d2      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
  for (x = 0; x < (winsize - 1); x++) {
 8024c7a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024c7c:	3301      	adds	r3, #1
 8024c7e:	677b      	str	r3, [r7, #116]	@ 0x74
 8024c80:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024c82:	3b01      	subs	r3, #1
 8024c84:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024c86:	429a      	cmp	r2, r3
 8024c88:	dbbb      	blt.n	8024c02 <_fp_exptmod_nct+0x18e>
    }
  }

  /* create upper table */
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 8024c8a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024c8c:	3b01      	subs	r3, #1
 8024c8e:	2201      	movs	r2, #1
 8024c90:	fa02 f303 	lsl.w	r3, r2, r3
 8024c94:	3301      	adds	r3, #1
 8024c96:	677b      	str	r3, [r7, #116]	@ 0x74
 8024c98:	e040      	b.n	8024d1c <_fp_exptmod_nct+0x2a8>
    err = fp_mul(&M[x - 1], &M[1], &M[x]);
 8024c9a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024c9c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024ca0:	fb02 f303 	mul.w	r3, r2, r3
 8024ca4:	f5a3 730b 	sub.w	r3, r3, #556	@ 0x22c
 8024ca8:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024caa:	18d0      	adds	r0, r2, r3
 8024cac:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024cae:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 8024cb2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024cb4:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024cb8:	fb02 f303 	mul.w	r3, r2, r3
 8024cbc:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024cbe:	4413      	add	r3, r2
 8024cc0:	461a      	mov	r2, r3
 8024cc2:	f7fd fcf2 	bl	80226aa <fp_mul>
 8024cc6:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8024cc8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024cca:	2b00      	cmp	r3, #0
 8024ccc:	d009      	beq.n	8024ce2 <_fp_exptmod_nct+0x26e>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024cce:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024cd0:	62bb      	str	r3, [r7, #40]	@ 0x28
 8024cd2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8024cd4:	2b00      	cmp	r3, #0
 8024cd6:	d002      	beq.n	8024cde <_fp_exptmod_nct+0x26a>
 8024cd8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8024cda:	f7f9 fef7 	bl	801eacc <wolfSSL_Free>
#endif
      return err;
 8024cde:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ce0:	e19e      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
    }
    err = fp_montgomery_reduce_ex(&M[x], P, mp, 0);
 8024ce2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024ce4:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024ce8:	fb02 f303 	mul.w	r3, r2, r3
 8024cec:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024cee:	18d0      	adds	r0, r2, r3
 8024cf0:	697a      	ldr	r2, [r7, #20]
 8024cf2:	2300      	movs	r3, #0
 8024cf4:	6879      	ldr	r1, [r7, #4]
 8024cf6:	f001 f808 	bl	8025d0a <fp_montgomery_reduce_ex>
 8024cfa:	66f8      	str	r0, [r7, #108]	@ 0x6c
    if (err != FP_OKAY) {
 8024cfc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024cfe:	2b00      	cmp	r3, #0
 8024d00:	d009      	beq.n	8024d16 <_fp_exptmod_nct+0x2a2>
#ifndef WOLFSSL_NO_MALLOC
      XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024d02:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024d04:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8024d06:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8024d08:	2b00      	cmp	r3, #0
 8024d0a:	d002      	beq.n	8024d12 <_fp_exptmod_nct+0x29e>
 8024d0c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8024d0e:	f7f9 fedd 	bl	801eacc <wolfSSL_Free>
#endif
      return err;
 8024d12:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024d14:	e184      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 8024d16:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024d18:	3301      	adds	r3, #1
 8024d1a:	677b      	str	r3, [r7, #116]	@ 0x74
 8024d1c:	2201      	movs	r2, #1
 8024d1e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024d20:	fa02 f303 	lsl.w	r3, r2, r3
 8024d24:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024d26:	429a      	cmp	r2, r3
 8024d28:	dbb7      	blt.n	8024c9a <_fp_exptmod_nct+0x226>
    }
  }

  /* set initial mode and bit cnt */
  mode   = 0;
 8024d2a:	2300      	movs	r3, #0
 8024d2c:	67fb      	str	r3, [r7, #124]	@ 0x7c
  bitcnt = (x % DIGIT_BIT) + 1;
 8024d2e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024d30:	425a      	negs	r2, r3
 8024d32:	f003 031f 	and.w	r3, r3, #31
 8024d36:	f002 021f 	and.w	r2, r2, #31
 8024d3a:	bf58      	it	pl
 8024d3c:	4253      	negpl	r3, r2
 8024d3e:	3301      	adds	r3, #1
 8024d40:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  buf    = 0;
 8024d44:	2300      	movs	r3, #0
 8024d46:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  digidx = X->used - 1;
 8024d4a:	68bb      	ldr	r3, [r7, #8]
 8024d4c:	681b      	ldr	r3, [r3, #0]
 8024d4e:	3b01      	subs	r3, #1
 8024d50:	67bb      	str	r3, [r7, #120]	@ 0x78
  bitcpy = 0;
 8024d52:	2300      	movs	r3, #0
 8024d54:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  bitbuf = 0;
 8024d58:	2300      	movs	r3, #0
 8024d5a:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88

  for (;;) {
    /* grab next digit as required */
    if (--bitcnt == 0) {
 8024d5e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8024d62:	3b01      	subs	r3, #1
 8024d64:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 8024d68:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8024d6c:	2b00      	cmp	r3, #0
 8024d6e:	d111      	bne.n	8024d94 <_fp_exptmod_nct+0x320>
      /* if digidx == -1 we are out of digits so break */
      if (digidx == -1) {
 8024d70:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8024d72:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8024d76:	f000 80ce 	beq.w	8024f16 <_fp_exptmod_nct+0x4a2>
        break;
      }
      /* read next digit and reset bitcnt */
      buf    = X->dp[digidx--];
 8024d7a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8024d7c:	1e5a      	subs	r2, r3, #1
 8024d7e:	67ba      	str	r2, [r7, #120]	@ 0x78
 8024d80:	68ba      	ldr	r2, [r7, #8]
 8024d82:	3302      	adds	r3, #2
 8024d84:	009b      	lsls	r3, r3, #2
 8024d86:	4413      	add	r3, r2
 8024d88:	685b      	ldr	r3, [r3, #4]
 8024d8a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
      bitcnt = (int)DIGIT_BIT;
 8024d8e:	2320      	movs	r3, #32
 8024d90:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    }

    /* grab the next msb from the exponent */
    y     = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 8024d94:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8024d98:	0fdb      	lsrs	r3, r3, #31
 8024d9a:	64bb      	str	r3, [r7, #72]	@ 0x48
    buf <<= (fp_digit)1;
 8024d9c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8024da0:	005b      	lsls	r3, r3, #1
 8024da2:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    /* if the bit is zero and mode == 0 then we ignore it
     * These represent the leading zero bits before the first 1 bit
     * in the exponent.  Technically this opt is not required but it
     * does lower the # of trivial squaring/reductions used
     */
    if (mode == 0 && y == 0) {
 8024da6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024da8:	2b00      	cmp	r3, #0
 8024daa:	d103      	bne.n	8024db4 <_fp_exptmod_nct+0x340>
 8024dac:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024dae:	2b00      	cmp	r3, #0
 8024db0:	f000 80ad 	beq.w	8024f0e <_fp_exptmod_nct+0x49a>
      continue;
    }

    /* if the bit is zero and mode == 1 then we square */
    if (mode == 1 && y == 0) {
 8024db4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024db6:	2b01      	cmp	r3, #1
 8024db8:	d129      	bne.n	8024e0e <_fp_exptmod_nct+0x39a>
 8024dba:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8024dbc:	2b00      	cmp	r3, #0
 8024dbe:	d126      	bne.n	8024e0e <_fp_exptmod_nct+0x39a>
      err = fp_sqr(res, res);
 8024dc0:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8024dc2:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024dc4:	f000 fc19 	bl	80255fa <fp_sqr>
 8024dc8:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024dca:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024dcc:	2b00      	cmp	r3, #0
 8024dce:	d009      	beq.n	8024de4 <_fp_exptmod_nct+0x370>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024dd0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024dd2:	643b      	str	r3, [r7, #64]	@ 0x40
 8024dd4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8024dd6:	2b00      	cmp	r3, #0
 8024dd8:	d002      	beq.n	8024de0 <_fp_exptmod_nct+0x36c>
 8024dda:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8024ddc:	f7f9 fe76 	bl	801eacc <wolfSSL_Free>
#endif
        return err;
 8024de0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024de2:	e11d      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
      }
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024de4:	697a      	ldr	r2, [r7, #20]
 8024de6:	2300      	movs	r3, #0
 8024de8:	6879      	ldr	r1, [r7, #4]
 8024dea:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024dec:	f000 ff8d 	bl	8025d0a <fp_montgomery_reduce_ex>
 8024df0:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024df2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024df4:	2b00      	cmp	r3, #0
 8024df6:	f000 808c 	beq.w	8024f12 <_fp_exptmod_nct+0x49e>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024dfa:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024dfc:	647b      	str	r3, [r7, #68]	@ 0x44
 8024dfe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8024e00:	2b00      	cmp	r3, #0
 8024e02:	d002      	beq.n	8024e0a <_fp_exptmod_nct+0x396>
 8024e04:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8024e06:	f7f9 fe61 	bl	801eacc <wolfSSL_Free>
#endif
        return err;
 8024e0a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e0c:	e108      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
      }
      continue;
    }

    /* else we add it to the window */
    bitbuf |= (y << (winsize - ++bitcpy));
 8024e0e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8024e12:	3301      	adds	r3, #1
 8024e14:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 8024e18:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8024e1a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8024e1e:	1ad3      	subs	r3, r2, r3
 8024e20:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8024e22:	fa02 f303 	lsl.w	r3, r2, r3
 8024e26:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8024e2a:	4313      	orrs	r3, r2
 8024e2c:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    mode    = 2;
 8024e30:	2302      	movs	r3, #2
 8024e32:	67fb      	str	r3, [r7, #124]	@ 0x7c

    if (bitcpy == winsize) {
 8024e34:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8024e38:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024e3a:	429a      	cmp	r2, r3
 8024e3c:	d18f      	bne.n	8024d5e <_fp_exptmod_nct+0x2ea>
      /* ok window is filled so square as required and multiply  */
      /* square first */
      for (x = 0; x < winsize; x++) {
 8024e3e:	2300      	movs	r3, #0
 8024e40:	677b      	str	r3, [r7, #116]	@ 0x74
 8024e42:	e028      	b.n	8024e96 <_fp_exptmod_nct+0x422>
        err = fp_sqr(res, res);
 8024e44:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8024e46:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024e48:	f000 fbd7 	bl	80255fa <fp_sqr>
 8024e4c:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 8024e4e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e50:	2b00      	cmp	r3, #0
 8024e52:	d009      	beq.n	8024e68 <_fp_exptmod_nct+0x3f4>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024e54:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024e56:	633b      	str	r3, [r7, #48]	@ 0x30
 8024e58:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024e5a:	2b00      	cmp	r3, #0
 8024e5c:	d002      	beq.n	8024e64 <_fp_exptmod_nct+0x3f0>
 8024e5e:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8024e60:	f7f9 fe34 	bl	801eacc <wolfSSL_Free>
#endif
          return err;
 8024e64:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e66:	e0db      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
        }
        err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024e68:	697a      	ldr	r2, [r7, #20]
 8024e6a:	2300      	movs	r3, #0
 8024e6c:	6879      	ldr	r1, [r7, #4]
 8024e6e:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024e70:	f000 ff4b 	bl	8025d0a <fp_montgomery_reduce_ex>
 8024e74:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 8024e76:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e78:	2b00      	cmp	r3, #0
 8024e7a:	d009      	beq.n	8024e90 <_fp_exptmod_nct+0x41c>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024e7c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024e7e:	637b      	str	r3, [r7, #52]	@ 0x34
 8024e80:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8024e82:	2b00      	cmp	r3, #0
 8024e84:	d002      	beq.n	8024e8c <_fp_exptmod_nct+0x418>
 8024e86:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8024e88:	f7f9 fe20 	bl	801eacc <wolfSSL_Free>
#endif
          return err;
 8024e8c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024e8e:	e0c7      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
      for (x = 0; x < winsize; x++) {
 8024e90:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024e92:	3301      	adds	r3, #1
 8024e94:	677b      	str	r3, [r7, #116]	@ 0x74
 8024e96:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024e98:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024e9a:	429a      	cmp	r2, r3
 8024e9c:	dbd2      	blt.n	8024e44 <_fp_exptmod_nct+0x3d0>
        }
      }

      /* then multiply */
      err = fp_mul(res, &M[bitbuf], res);
 8024e9e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8024ea2:	f44f 720b 	mov.w	r2, #556	@ 0x22c
 8024ea6:	fb02 f303 	mul.w	r3, r2, r3
 8024eaa:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8024eac:	4413      	add	r3, r2
 8024eae:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8024eb0:	4619      	mov	r1, r3
 8024eb2:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024eb4:	f7fd fbf9 	bl	80226aa <fp_mul>
 8024eb8:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024eba:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ebc:	2b00      	cmp	r3, #0
 8024ebe:	d009      	beq.n	8024ed4 <_fp_exptmod_nct+0x460>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024ec0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024ec2:	63bb      	str	r3, [r7, #56]	@ 0x38
 8024ec4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8024ec6:	2b00      	cmp	r3, #0
 8024ec8:	d002      	beq.n	8024ed0 <_fp_exptmod_nct+0x45c>
 8024eca:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8024ecc:	f7f9 fdfe 	bl	801eacc <wolfSSL_Free>
#endif
        return err;
 8024ed0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ed2:	e0a5      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
      }
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024ed4:	697a      	ldr	r2, [r7, #20]
 8024ed6:	2300      	movs	r3, #0
 8024ed8:	6879      	ldr	r1, [r7, #4]
 8024eda:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024edc:	f000 ff15 	bl	8025d0a <fp_montgomery_reduce_ex>
 8024ee0:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024ee2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024ee4:	2b00      	cmp	r3, #0
 8024ee6:	d009      	beq.n	8024efc <_fp_exptmod_nct+0x488>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024ee8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024eea:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8024eec:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8024eee:	2b00      	cmp	r3, #0
 8024ef0:	d002      	beq.n	8024ef8 <_fp_exptmod_nct+0x484>
 8024ef2:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8024ef4:	f7f9 fdea 	bl	801eacc <wolfSSL_Free>
#endif
        return err;
 8024ef8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024efa:	e091      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
      }

      /* empty window and reset */
      bitcpy = 0;
 8024efc:	2300      	movs	r3, #0
 8024efe:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
      bitbuf = 0;
 8024f02:	2300      	movs	r3, #0
 8024f04:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
      mode   = 1;
 8024f08:	2301      	movs	r3, #1
 8024f0a:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8024f0c:	e727      	b.n	8024d5e <_fp_exptmod_nct+0x2ea>
      continue;
 8024f0e:	bf00      	nop
 8024f10:	e725      	b.n	8024d5e <_fp_exptmod_nct+0x2ea>
      continue;
 8024f12:	bf00      	nop
    if (--bitcnt == 0) {
 8024f14:	e723      	b.n	8024d5e <_fp_exptmod_nct+0x2ea>
        break;
 8024f16:	bf00      	nop
    }
  }

  /* if bits remain then square/multiply */
  if (mode == 2 && bitcpy > 0) {
 8024f18:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8024f1a:	2b02      	cmp	r3, #2
 8024f1c:	d16c      	bne.n	8024ff8 <_fp_exptmod_nct+0x584>
 8024f1e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8024f22:	2b00      	cmp	r3, #0
 8024f24:	dd68      	ble.n	8024ff8 <_fp_exptmod_nct+0x584>
    /* square then multiply if the bit is set */
    for (x = 0; x < bitcpy; x++) {
 8024f26:	2300      	movs	r3, #0
 8024f28:	677b      	str	r3, [r7, #116]	@ 0x74
 8024f2a:	e060      	b.n	8024fee <_fp_exptmod_nct+0x57a>
      err = fp_sqr(res, res);
 8024f2c:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8024f2e:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024f30:	f000 fb63 	bl	80255fa <fp_sqr>
 8024f34:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024f36:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f38:	2b00      	cmp	r3, #0
 8024f3a:	d009      	beq.n	8024f50 <_fp_exptmod_nct+0x4dc>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024f3c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024f3e:	653b      	str	r3, [r7, #80]	@ 0x50
 8024f40:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8024f42:	2b00      	cmp	r3, #0
 8024f44:	d002      	beq.n	8024f4c <_fp_exptmod_nct+0x4d8>
 8024f46:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8024f48:	f7f9 fdc0 	bl	801eacc <wolfSSL_Free>
#endif
        return err;
 8024f4c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f4e:	e067      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
      }
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024f50:	697a      	ldr	r2, [r7, #20]
 8024f52:	2300      	movs	r3, #0
 8024f54:	6879      	ldr	r1, [r7, #4]
 8024f56:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024f58:	f000 fed7 	bl	8025d0a <fp_montgomery_reduce_ex>
 8024f5c:	66f8      	str	r0, [r7, #108]	@ 0x6c
      if (err != FP_OKAY) {
 8024f5e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f60:	2b00      	cmp	r3, #0
 8024f62:	d009      	beq.n	8024f78 <_fp_exptmod_nct+0x504>
#ifndef WOLFSSL_NO_MALLOC
        XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024f64:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024f66:	657b      	str	r3, [r7, #84]	@ 0x54
 8024f68:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8024f6a:	2b00      	cmp	r3, #0
 8024f6c:	d002      	beq.n	8024f74 <_fp_exptmod_nct+0x500>
 8024f6e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8024f70:	f7f9 fdac 	bl	801eacc <wolfSSL_Free>
#endif
        return err;
 8024f74:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024f76:	e053      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
      }

      /* get next bit of the window */
      bitbuf <<= 1;
 8024f78:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8024f7c:	005b      	lsls	r3, r3, #1
 8024f7e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
      if ((bitbuf & (1 << winsize)) != 0) {
 8024f82:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8024f86:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8024f88:	fa42 f303 	asr.w	r3, r2, r3
 8024f8c:	f003 0301 	and.w	r3, r3, #1
 8024f90:	2b00      	cmp	r3, #0
 8024f92:	d029      	beq.n	8024fe8 <_fp_exptmod_nct+0x574>
        /* then multiply */
        err = fp_mul(res, &M[1], res);
 8024f94:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024f96:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8024f9a:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8024f9c:	4619      	mov	r1, r3
 8024f9e:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024fa0:	f7fd fb83 	bl	80226aa <fp_mul>
 8024fa4:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 8024fa6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024fa8:	2b00      	cmp	r3, #0
 8024faa:	d009      	beq.n	8024fc0 <_fp_exptmod_nct+0x54c>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024fac:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024fae:	65bb      	str	r3, [r7, #88]	@ 0x58
 8024fb0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8024fb2:	2b00      	cmp	r3, #0
 8024fb4:	d002      	beq.n	8024fbc <_fp_exptmod_nct+0x548>
 8024fb6:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8024fb8:	f7f9 fd88 	bl	801eacc <wolfSSL_Free>
#endif
          return err;
 8024fbc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024fbe:	e02f      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
        }
        err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024fc0:	697a      	ldr	r2, [r7, #20]
 8024fc2:	2300      	movs	r3, #0
 8024fc4:	6879      	ldr	r1, [r7, #4]
 8024fc6:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8024fc8:	f000 fe9f 	bl	8025d0a <fp_montgomery_reduce_ex>
 8024fcc:	66f8      	str	r0, [r7, #108]	@ 0x6c
        if (err != FP_OKAY) {
 8024fce:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024fd0:	2b00      	cmp	r3, #0
 8024fd2:	d009      	beq.n	8024fe8 <_fp_exptmod_nct+0x574>
#ifndef WOLFSSL_NO_MALLOC
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 8024fd4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8024fd6:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8024fd8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8024fda:	2b00      	cmp	r3, #0
 8024fdc:	d002      	beq.n	8024fe4 <_fp_exptmod_nct+0x570>
 8024fde:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 8024fe0:	f7f9 fd74 	bl	801eacc <wolfSSL_Free>
#endif
          return err;
 8024fe4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8024fe6:	e01b      	b.n	8025020 <_fp_exptmod_nct+0x5ac>
    for (x = 0; x < bitcpy; x++) {
 8024fe8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8024fea:	3301      	adds	r3, #1
 8024fec:	677b      	str	r3, [r7, #116]	@ 0x74
 8024fee:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8024ff0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8024ff4:	429a      	cmp	r2, r3
 8024ff6:	db99      	blt.n	8024f2c <_fp_exptmod_nct+0x4b8>
   * recall that any value in a Montgomery system is
   * actually multiplied by R mod n.  So we have
   * to reduce one more time to cancel out the factor
   * of R.
   */
  err = fp_montgomery_reduce_ex(res, P, mp, 0);
 8024ff8:	697a      	ldr	r2, [r7, #20]
 8024ffa:	2300      	movs	r3, #0
 8024ffc:	6879      	ldr	r1, [r7, #4]
 8024ffe:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 8025000:	f000 fe83 	bl	8025d0a <fp_montgomery_reduce_ex>
 8025004:	66f8      	str	r0, [r7, #108]	@ 0x6c

  /* swap res with Y */
  fp_copy (res, Y);
 8025006:	6839      	ldr	r1, [r7, #0]
 8025008:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 802500a:	f001 fd41 	bl	8026a90 <fp_copy>

#ifndef WOLFSSL_NO_MALLOC
  XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 802500e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8025010:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8025012:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025014:	2b00      	cmp	r3, #0
 8025016:	d002      	beq.n	802501e <_fp_exptmod_nct+0x5aa>
 8025018:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 802501a:	f7f9 fd57 	bl	801eacc <wolfSSL_Free>
#endif
  return err;
 802501e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
}
 8025020:	4618      	mov	r0, r3
 8025022:	3790      	adds	r7, #144	@ 0x90
 8025024:	46bd      	mov	sp, r7
 8025026:	bd80      	pop	{r7, pc}

08025028 <_fp_exptmod_base_2>:
/* y = 2**x (mod b)
 * Some restrictions... x must be positive and < b
 */
static int _fp_exptmod_base_2(fp_int * X, int digits, fp_int * P,
                              fp_int * Y)
{
 8025028:	b580      	push	{r7, lr}
 802502a:	b09c      	sub	sp, #112	@ 0x70
 802502c:	af00      	add	r7, sp, #0
 802502e:	60f8      	str	r0, [r7, #12]
 8025030:	60b9      	str	r1, [r7, #8]
 8025032:	607a      	str	r2, [r7, #4]
 8025034:	603b      	str	r3, [r7, #0]
  fp_int   res[1];
  fp_int   tmp[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
  res = (fp_int*)XMALLOC(2*sizeof(fp_int), NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025036:	f44f 608b 	mov.w	r0, #1112	@ 0x458
 802503a:	f7f9 fd2b 	bl	801ea94 <wolfSSL_Malloc>
 802503e:	6578      	str	r0, [r7, #84]	@ 0x54
  if (res == NULL) {
 8025040:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025042:	2b00      	cmp	r3, #0
 8025044:	d102      	bne.n	802504c <_fp_exptmod_base_2+0x24>
     return FP_MEM;
 8025046:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 802504a:	e15d      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
  }
  tmp = &res[1];
 802504c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802504e:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8025052:	653b      	str	r3, [r7, #80]	@ 0x50
#endif

  /* now setup montgomery  */
  if ((err = fp_montgomery_setup(P, &mp)) != FP_OKAY) {
 8025054:	f107 0314 	add.w	r3, r7, #20
 8025058:	4619      	mov	r1, r3
 802505a:	6878      	ldr	r0, [r7, #4]
 802505c:	f000 fdc2 	bl	8025be4 <fp_montgomery_setup>
 8025060:	64f8      	str	r0, [r7, #76]	@ 0x4c
 8025062:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025064:	2b00      	cmp	r3, #0
 8025066:	d009      	beq.n	802507c <_fp_exptmod_base_2+0x54>
#ifdef WOLFSSL_SMALL_STACK
     XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025068:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802506a:	61bb      	str	r3, [r7, #24]
 802506c:	69bb      	ldr	r3, [r7, #24]
 802506e:	2b00      	cmp	r3, #0
 8025070:	d002      	beq.n	8025078 <_fp_exptmod_base_2+0x50>
 8025072:	69b8      	ldr	r0, [r7, #24]
 8025074:	f7f9 fd2a 	bl	801eacc <wolfSSL_Free>
#endif
     return err;
 8025078:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802507a:	e145      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
  }

  /* setup result */
  fp_init(res);
 802507c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802507e:	f001 fb1d 	bl	80266bc <fp_init>
  fp_init(tmp);
 8025082:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8025084:	f001 fb1a 	bl	80266bc <fp_init>

  err = fp_mul_2d(P, 1 << WINSIZE, tmp);
 8025088:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 802508a:	2108      	movs	r1, #8
 802508c:	6878      	ldr	r0, [r7, #4]
 802508e:	f7fd fc62 	bl	8022956 <fp_mul_2d>
 8025092:	64f8      	str	r0, [r7, #76]	@ 0x4c
  if (err != FP_OKAY) {
 8025094:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025096:	2b00      	cmp	r3, #0
 8025098:	d009      	beq.n	80250ae <_fp_exptmod_base_2+0x86>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802509a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802509c:	61fb      	str	r3, [r7, #28]
 802509e:	69fb      	ldr	r3, [r7, #28]
 80250a0:	2b00      	cmp	r3, #0
 80250a2:	d002      	beq.n	80250aa <_fp_exptmod_base_2+0x82>
 80250a4:	69f8      	ldr	r0, [r7, #28]
 80250a6:	f7f9 fd11 	bl	801eacc <wolfSSL_Free>
  #endif
    return err;
 80250aa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80250ac:	e12c      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
  }

  /* now we need R mod m */
  err = fp_montgomery_calc_normalization(res, P);
 80250ae:	6879      	ldr	r1, [r7, #4]
 80250b0:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80250b2:	f000 fdd8 	bl	8025c66 <fp_montgomery_calc_normalization>
 80250b6:	64f8      	str	r0, [r7, #76]	@ 0x4c
  if (err != FP_OKAY) {
 80250b8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80250ba:	2b00      	cmp	r3, #0
 80250bc:	d009      	beq.n	80250d2 <_fp_exptmod_base_2+0xaa>
  #ifdef WOLFSSL_SMALL_STACK
    XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80250be:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80250c0:	623b      	str	r3, [r7, #32]
 80250c2:	6a3b      	ldr	r3, [r7, #32]
 80250c4:	2b00      	cmp	r3, #0
 80250c6:	d002      	beq.n	80250ce <_fp_exptmod_base_2+0xa6>
 80250c8:	6a38      	ldr	r0, [r7, #32]
 80250ca:	f7f9 fcff 	bl	801eacc <wolfSSL_Free>
  #endif
    return err;
 80250ce:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80250d0:	e11a      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
  }

  /* Get the top bits left over after taking WINSIZE bits starting at the
   * least-significant.
   */
  digidx = digits - 1;
 80250d2:	68bb      	ldr	r3, [r7, #8]
 80250d4:	3b01      	subs	r3, #1
 80250d6:	65fb      	str	r3, [r7, #92]	@ 0x5c
  bitcpy = (digits * DIGIT_BIT) % WINSIZE;
 80250d8:	68bb      	ldr	r3, [r7, #8]
 80250da:	015a      	lsls	r2, r3, #5
 80250dc:	4b8c      	ldr	r3, [pc, #560]	@ (8025310 <_fp_exptmod_base_2+0x2e8>)
 80250de:	fb83 3102 	smull	r3, r1, r3, r2
 80250e2:	17d3      	asrs	r3, r2, #31
 80250e4:	1ac9      	subs	r1, r1, r3
 80250e6:	460b      	mov	r3, r1
 80250e8:	005b      	lsls	r3, r3, #1
 80250ea:	440b      	add	r3, r1
 80250ec:	1ad3      	subs	r3, r2, r3
 80250ee:	667b      	str	r3, [r7, #100]	@ 0x64
  if (bitcpy > 0) {
 80250f0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80250f2:	2b00      	cmp	r3, #0
 80250f4:	dd53      	ble.n	802519e <_fp_exptmod_base_2+0x176>
      bitcnt = (int)DIGIT_BIT - bitcpy;
 80250f6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80250f8:	f1c3 0320 	rsb	r3, r3, #32
 80250fc:	663b      	str	r3, [r7, #96]	@ 0x60
      buf    = X->dp[digidx--];
 80250fe:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8025100:	1e5a      	subs	r2, r3, #1
 8025102:	65fa      	str	r2, [r7, #92]	@ 0x5c
 8025104:	68fa      	ldr	r2, [r7, #12]
 8025106:	3302      	adds	r3, #2
 8025108:	009b      	lsls	r3, r3, #2
 802510a:	4413      	add	r3, r2
 802510c:	685b      	ldr	r3, [r3, #4]
 802510e:	66fb      	str	r3, [r7, #108]	@ 0x6c
      bitbuf = (int)(buf >> bitcnt);
 8025110:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8025112:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8025114:	fa22 f303 	lsr.w	r3, r2, r3
 8025118:	66bb      	str	r3, [r7, #104]	@ 0x68
      /* Multiply montgomery representation of 1 by 2 ^ top */
      err = fp_mul_2d(res, bitbuf, res);
 802511a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802511c:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 802511e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025120:	f7fd fc19 	bl	8022956 <fp_mul_2d>
 8025124:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 8025126:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025128:	2b00      	cmp	r3, #0
 802512a:	d009      	beq.n	8025140 <_fp_exptmod_base_2+0x118>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802512c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802512e:	643b      	str	r3, [r7, #64]	@ 0x40
 8025130:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025132:	2b00      	cmp	r3, #0
 8025134:	d002      	beq.n	802513c <_fp_exptmod_base_2+0x114>
 8025136:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8025138:	f7f9 fcc8 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 802513c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802513e:	e0e3      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
      }
      err = fp_add(res, tmp, res);
 8025140:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8025142:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8025144:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025146:	f7fd f8ca 	bl	80222de <fp_add>
 802514a:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 802514c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802514e:	2b00      	cmp	r3, #0
 8025150:	d009      	beq.n	8025166 <_fp_exptmod_base_2+0x13e>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025152:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025154:	647b      	str	r3, [r7, #68]	@ 0x44
 8025156:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025158:	2b00      	cmp	r3, #0
 802515a:	d002      	beq.n	8025162 <_fp_exptmod_base_2+0x13a>
 802515c:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 802515e:	f7f9 fcb5 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 8025162:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025164:	e0d0      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
      }
      err = fp_mod(res, P, res);
 8025166:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8025168:	6879      	ldr	r1, [r7, #4]
 802516a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802516c:	f7fe fa36 	bl	80235dc <fp_mod>
 8025170:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 8025172:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025174:	2b00      	cmp	r3, #0
 8025176:	d009      	beq.n	802518c <_fp_exptmod_base_2+0x164>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025178:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802517a:	64bb      	str	r3, [r7, #72]	@ 0x48
 802517c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802517e:	2b00      	cmp	r3, #0
 8025180:	d002      	beq.n	8025188 <_fp_exptmod_base_2+0x160>
 8025182:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8025184:	f7f9 fca2 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 8025188:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802518a:	e0bd      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
      }
      /* Move out bits used */
      buf  <<= bitcpy;
 802518c:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 802518e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025190:	fa02 f303 	lsl.w	r3, r2, r3
 8025194:	66fb      	str	r3, [r7, #108]	@ 0x6c
      bitcnt++;
 8025196:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8025198:	3301      	adds	r3, #1
 802519a:	663b      	str	r3, [r7, #96]	@ 0x60
 802519c:	e003      	b.n	80251a6 <_fp_exptmod_base_2+0x17e>
  }
  else {
      bitcnt = 1;
 802519e:	2301      	movs	r3, #1
 80251a0:	663b      	str	r3, [r7, #96]	@ 0x60
      buf    = 0;
 80251a2:	2300      	movs	r3, #0
 80251a4:	66fb      	str	r3, [r7, #108]	@ 0x6c
  }

  /* empty window and reset  */
  bitbuf = 0;
 80251a6:	2300      	movs	r3, #0
 80251a8:	66bb      	str	r3, [r7, #104]	@ 0x68
  bitcpy = 0;
 80251aa:	2300      	movs	r3, #0
 80251ac:	667b      	str	r3, [r7, #100]	@ 0x64

  for (;;) {
    /* grab next digit as required */
    if (--bitcnt == 0) {
 80251ae:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80251b0:	3b01      	subs	r3, #1
 80251b2:	663b      	str	r3, [r7, #96]	@ 0x60
 80251b4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80251b6:	2b00      	cmp	r3, #0
 80251b8:	d10f      	bne.n	80251da <_fp_exptmod_base_2+0x1b2>
      /* if digidx == -1 we are out of digits so break */
      if (digidx == -1) {
 80251ba:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80251bc:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 80251c0:	f000 808d 	beq.w	80252de <_fp_exptmod_base_2+0x2b6>
        break;
      }
      /* read next digit and reset bitcnt */
      buf    = X->dp[digidx--];
 80251c4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80251c6:	1e5a      	subs	r2, r3, #1
 80251c8:	65fa      	str	r2, [r7, #92]	@ 0x5c
 80251ca:	68fa      	ldr	r2, [r7, #12]
 80251cc:	3302      	adds	r3, #2
 80251ce:	009b      	lsls	r3, r3, #2
 80251d0:	4413      	add	r3, r2
 80251d2:	685b      	ldr	r3, [r3, #4]
 80251d4:	66fb      	str	r3, [r7, #108]	@ 0x6c
      bitcnt = (int)DIGIT_BIT;
 80251d6:	2320      	movs	r3, #32
 80251d8:	663b      	str	r3, [r7, #96]	@ 0x60
    }

    /* grab the next msb from the exponent */
    y       = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 80251da:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80251dc:	0fdb      	lsrs	r3, r3, #31
 80251de:	63bb      	str	r3, [r7, #56]	@ 0x38
    buf   <<= (fp_digit)1;
 80251e0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80251e2:	005b      	lsls	r3, r3, #1
 80251e4:	66fb      	str	r3, [r7, #108]	@ 0x6c
    /* add bit to the window */
  #ifndef WC_PROTECT_ENCRYPTED_MEM
    bitbuf |= (y << (WINSIZE - ++bitcpy));
 80251e6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80251e8:	3301      	adds	r3, #1
 80251ea:	667b      	str	r3, [r7, #100]	@ 0x64
 80251ec:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80251ee:	f1c3 0303 	rsb	r3, r3, #3
 80251f2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80251f4:	fa02 f303 	lsl.w	r3, r2, r3
 80251f8:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80251fa:	4313      	orrs	r3, r2
 80251fc:	66bb      	str	r3, [r7, #104]	@ 0x68
  #else
    /* Ensure value changes even when y is zero. */
    bitbuf += (WINMASK + 1) + (y << (WINSIZE - ++bitcpy));
  #endif

    if (bitcpy == WINSIZE) {
 80251fe:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025200:	2b03      	cmp	r3, #3
 8025202:	d1d4      	bne.n	80251ae <_fp_exptmod_base_2+0x186>
      /* ok window is filled so square as required and multiply  */
      /* square first */
      for (x = 0; x < WINSIZE; x++) {
 8025204:	2300      	movs	r3, #0
 8025206:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025208:	e028      	b.n	802525c <_fp_exptmod_base_2+0x234>
        err = fp_sqr(res, res);
 802520a:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 802520c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802520e:	f000 f9f4 	bl	80255fa <fp_sqr>
 8025212:	64f8      	str	r0, [r7, #76]	@ 0x4c
        if (err != FP_OKAY) {
 8025214:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025216:	2b00      	cmp	r3, #0
 8025218:	d009      	beq.n	802522e <_fp_exptmod_base_2+0x206>
        #ifdef WOLFSSL_SMALL_STACK
          XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802521a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802521c:	627b      	str	r3, [r7, #36]	@ 0x24
 802521e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8025220:	2b00      	cmp	r3, #0
 8025222:	d002      	beq.n	802522a <_fp_exptmod_base_2+0x202>
 8025224:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8025226:	f7f9 fc51 	bl	801eacc <wolfSSL_Free>
        #endif
          return err;
 802522a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802522c:	e06c      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
        }
        err = fp_montgomery_reduce(res, P, mp);
 802522e:	697b      	ldr	r3, [r7, #20]
 8025230:	461a      	mov	r2, r3
 8025232:	6879      	ldr	r1, [r7, #4]
 8025234:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025236:	f000 fe9c 	bl	8025f72 <fp_montgomery_reduce>
 802523a:	64f8      	str	r0, [r7, #76]	@ 0x4c
        if (err != FP_OKAY) {
 802523c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 802523e:	2b00      	cmp	r3, #0
 8025240:	d009      	beq.n	8025256 <_fp_exptmod_base_2+0x22e>
        #ifdef WOLFSSL_SMALL_STACK
          XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025242:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025244:	62bb      	str	r3, [r7, #40]	@ 0x28
 8025246:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025248:	2b00      	cmp	r3, #0
 802524a:	d002      	beq.n	8025252 <_fp_exptmod_base_2+0x22a>
 802524c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 802524e:	f7f9 fc3d 	bl	801eacc <wolfSSL_Free>
        #endif
          return err;
 8025252:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025254:	e058      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
      for (x = 0; x < WINSIZE; x++) {
 8025256:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025258:	3301      	adds	r3, #1
 802525a:	65bb      	str	r3, [r7, #88]	@ 0x58
 802525c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 802525e:	2b02      	cmp	r3, #2
 8025260:	ddd3      	ble.n	802520a <_fp_exptmod_base_2+0x1e2>
        }
      }

      /* then multiply by 2^bitbuf */
    #ifndef WC_PROTECT_ENCRYPTED_MEM
      err = fp_mul_2d(res, bitbuf, res);
 8025262:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8025264:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8025266:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8025268:	f7fd fb75 	bl	8022956 <fp_mul_2d>
 802526c:	64f8      	str	r0, [r7, #76]	@ 0x4c
    #else
      /* Get the window bits. */
      err = fp_mul_2d(res, bitbuf & WINMASK, res);
    #endif
      if (err != FP_OKAY) {
 802526e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025270:	2b00      	cmp	r3, #0
 8025272:	d009      	beq.n	8025288 <_fp_exptmod_base_2+0x260>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025274:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025276:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8025278:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802527a:	2b00      	cmp	r3, #0
 802527c:	d002      	beq.n	8025284 <_fp_exptmod_base_2+0x25c>
 802527e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8025280:	f7f9 fc24 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 8025284:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025286:	e03f      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
      }
      /* Add in value to make mod operation take same time */
      err = fp_add(res, tmp, res);
 8025288:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 802528a:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 802528c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 802528e:	f7fd f826 	bl	80222de <fp_add>
 8025292:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 8025294:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025296:	2b00      	cmp	r3, #0
 8025298:	d009      	beq.n	80252ae <_fp_exptmod_base_2+0x286>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 802529a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802529c:	633b      	str	r3, [r7, #48]	@ 0x30
 802529e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80252a0:	2b00      	cmp	r3, #0
 80252a2:	d002      	beq.n	80252aa <_fp_exptmod_base_2+0x282>
 80252a4:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80252a6:	f7f9 fc11 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 80252aa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80252ac:	e02c      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
      }
      err = fp_mod(res, P, res);
 80252ae:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80252b0:	6879      	ldr	r1, [r7, #4]
 80252b2:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80252b4:	f7fe f992 	bl	80235dc <fp_mod>
 80252b8:	64f8      	str	r0, [r7, #76]	@ 0x4c
      if (err != FP_OKAY) {
 80252ba:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80252bc:	2b00      	cmp	r3, #0
 80252be:	d009      	beq.n	80252d4 <_fp_exptmod_base_2+0x2ac>
      #ifdef WOLFSSL_SMALL_STACK
        XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80252c0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80252c2:	637b      	str	r3, [r7, #52]	@ 0x34
 80252c4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80252c6:	2b00      	cmp	r3, #0
 80252c8:	d002      	beq.n	80252d0 <_fp_exptmod_base_2+0x2a8>
 80252ca:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80252cc:	f7f9 fbfe 	bl	801eacc <wolfSSL_Free>
      #endif
        return err;
 80252d0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80252d2:	e019      	b.n	8025308 <_fp_exptmod_base_2+0x2e0>
      }

      /* empty window and reset */
      bitcpy = 0;
 80252d4:	2300      	movs	r3, #0
 80252d6:	667b      	str	r3, [r7, #100]	@ 0x64
    #ifndef WC_PROTECT_ENCRYPTED_MEM
      bitbuf = 0;
 80252d8:	2300      	movs	r3, #0
 80252da:	66bb      	str	r3, [r7, #104]	@ 0x68
    if (--bitcnt == 0) {
 80252dc:	e767      	b.n	80251ae <_fp_exptmod_base_2+0x186>
        break;
 80252de:	bf00      	nop
   * recall that any value in a Montgomery system is
   * actually multiplied by R mod n.  So we have
   * to reduce one more time to cancel out the factor
   * of R.
   */
  err = fp_montgomery_reduce(res, P, mp);
 80252e0:	697b      	ldr	r3, [r7, #20]
 80252e2:	461a      	mov	r2, r3
 80252e4:	6879      	ldr	r1, [r7, #4]
 80252e6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80252e8:	f000 fe43 	bl	8025f72 <fp_montgomery_reduce>
 80252ec:	64f8      	str	r0, [r7, #76]	@ 0x4c

  /* swap res with Y */
  fp_copy(res, Y);
 80252ee:	6839      	ldr	r1, [r7, #0]
 80252f0:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80252f2:	f001 fbcd 	bl	8026a90 <fp_copy>

#ifdef WOLFSSL_SMALL_STACK
  XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80252f6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80252f8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80252fa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80252fc:	2b00      	cmp	r3, #0
 80252fe:	d002      	beq.n	8025306 <_fp_exptmod_base_2+0x2de>
 8025300:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8025302:	f7f9 fbe3 	bl	801eacc <wolfSSL_Free>
#endif
  return err;
 8025306:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 8025308:	4618      	mov	r0, r3
 802530a:	3770      	adds	r7, #112	@ 0x70
 802530c:	46bd      	mov	sp, r7
 802530e:	bd80      	pop	{r7, pc}
 8025310:	55555556 	.word	0x55555556

08025314 <fp_exptmod>:
#undef WINSIZE
#endif

/* Y = (G * X) mod P */
int fp_exptmod(fp_int * G, fp_int * X, fp_int * P, fp_int * Y)
{
 8025314:	b580      	push	{r7, lr}
 8025316:	b08a      	sub	sp, #40	@ 0x28
 8025318:	af02      	add	r7, sp, #8
 802531a:	60f8      	str	r0, [r7, #12]
 802531c:	60b9      	str	r1, [r7, #8]
 802531e:	607a      	str	r2, [r7, #4]
 8025320:	603b      	str	r3, [r7, #0]
#if defined(WOLFSSL_ESP32_CRYPT_RSA_PRI_EXPTMOD)
    int retHW = FP_OKAY;
#endif

   /* handle modulus of zero and prevent overflows */
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
 8025322:	687b      	ldr	r3, [r7, #4]
 8025324:	681b      	ldr	r3, [r3, #0]
 8025326:	2b00      	cmp	r3, #0
 8025328:	d003      	beq.n	8025332 <fp_exptmod+0x1e>
 802532a:	687b      	ldr	r3, [r7, #4]
 802532c:	681b      	ldr	r3, [r3, #0]
 802532e:	2b44      	cmp	r3, #68	@ 0x44
 8025330:	dd02      	ble.n	8025338 <fp_exptmod+0x24>
      return FP_VAL;
 8025332:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025336:	e09c      	b.n	8025472 <fp_exptmod+0x15e>
   }
   if (fp_isone(P)) {
 8025338:	687b      	ldr	r3, [r7, #4]
 802533a:	681b      	ldr	r3, [r3, #0]
 802533c:	2b01      	cmp	r3, #1
 802533e:	d10d      	bne.n	802535c <fp_exptmod+0x48>
 8025340:	687b      	ldr	r3, [r7, #4]
 8025342:	68db      	ldr	r3, [r3, #12]
 8025344:	2b01      	cmp	r3, #1
 8025346:	d109      	bne.n	802535c <fp_exptmod+0x48>
 8025348:	687b      	ldr	r3, [r7, #4]
 802534a:	685b      	ldr	r3, [r3, #4]
 802534c:	2b00      	cmp	r3, #0
 802534e:	d105      	bne.n	802535c <fp_exptmod+0x48>
      fp_set(Y, 0);
 8025350:	2100      	movs	r1, #0
 8025352:	6838      	ldr	r0, [r7, #0]
 8025354:	f000 ff83 	bl	802625e <fp_set>
      return FP_OKAY;
 8025358:	2300      	movs	r3, #0
 802535a:	e08a      	b.n	8025472 <fp_exptmod+0x15e>
   }
   if (fp_iszero(X)) {
 802535c:	68bb      	ldr	r3, [r7, #8]
 802535e:	681b      	ldr	r3, [r3, #0]
 8025360:	2b00      	cmp	r3, #0
 8025362:	d105      	bne.n	8025370 <fp_exptmod+0x5c>
      fp_set(Y, 1);
 8025364:	2101      	movs	r1, #1
 8025366:	6838      	ldr	r0, [r7, #0]
 8025368:	f000 ff79 	bl	802625e <fp_set>
      return FP_OKAY;
 802536c:	2300      	movs	r3, #0
 802536e:	e080      	b.n	8025472 <fp_exptmod+0x15e>
   }
   if (fp_iszero(G)) {
 8025370:	68fb      	ldr	r3, [r7, #12]
 8025372:	681b      	ldr	r3, [r3, #0]
 8025374:	2b00      	cmp	r3, #0
 8025376:	d105      	bne.n	8025384 <fp_exptmod+0x70>
      fp_set(Y, 0);
 8025378:	2100      	movs	r1, #0
 802537a:	6838      	ldr	r0, [r7, #0]
 802537c:	f000 ff6f 	bl	802625e <fp_set>
      return FP_OKAY;
 8025380:	2300      	movs	r3, #0
 8025382:	e076      	b.n	8025472 <fp_exptmod+0x15e>
      } /* switch */
   } /* if validation check */
   /* fall through to software calcs */
#endif /* WOLFSSL_ESP32_CRYPT_RSA_PRI_EXPTMOD */

   if (X->sign == FP_NEG) {
 8025384:	68bb      	ldr	r3, [r7, #8]
 8025386:	685b      	ldr	r3, [r3, #4]
 8025388:	2b01      	cmp	r3, #1
 802538a:	d157      	bne.n	802543c <fp_exptmod+0x128>
   #else
      fp_int *tmp;
   #endif

   #ifdef WOLFSSL_SMALL_STACK
      tmp = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_BIGINT);
 802538c:	f44f 608b 	mov.w	r0, #1112	@ 0x458
 8025390:	f7f9 fb80 	bl	801ea94 <wolfSSL_Malloc>
 8025394:	61b8      	str	r0, [r7, #24]
      if (tmp == NULL)
 8025396:	69bb      	ldr	r3, [r7, #24]
 8025398:	2b00      	cmp	r3, #0
 802539a:	d102      	bne.n	80253a2 <fp_exptmod+0x8e>
          return FP_MEM;
 802539c:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 80253a0:	e067      	b.n	8025472 <fp_exptmod+0x15e>
   #endif

      /* yes, copy G and invmod it */
      fp_init_copy(&tmp[0], G);
 80253a2:	68f9      	ldr	r1, [r7, #12]
 80253a4:	69b8      	ldr	r0, [r7, #24]
 80253a6:	f001 fbb2 	bl	8026b0e <fp_init_copy>
      fp_init_copy(&tmp[1], P);
 80253aa:	69bb      	ldr	r3, [r7, #24]
 80253ac:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253b0:	6879      	ldr	r1, [r7, #4]
 80253b2:	4618      	mov	r0, r3
 80253b4:	f001 fbab 	bl	8026b0e <fp_init_copy>
      tmp[1].sign = FP_ZPOS;
 80253b8:	69bb      	ldr	r3, [r7, #24]
 80253ba:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253be:	2200      	movs	r2, #0
 80253c0:	605a      	str	r2, [r3, #4]
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
 80253c2:	69bb      	ldr	r3, [r7, #24]
 80253c4:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253c8:	69ba      	ldr	r2, [r7, #24]
 80253ca:	4619      	mov	r1, r3
 80253cc:	69b8      	ldr	r0, [r7, #24]
 80253ce:	f7fe fc5c 	bl	8023c8a <fp_invmod>
 80253d2:	61f8      	str	r0, [r7, #28]
      if (err == FP_OKAY) {
 80253d4:	69fb      	ldr	r3, [r7, #28]
 80253d6:	2b00      	cmp	r3, #0
 80253d8:	d126      	bne.n	8025428 <fp_exptmod+0x114>
         fp_copy(X, &tmp[1]);
 80253da:	69bb      	ldr	r3, [r7, #24]
 80253dc:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253e0:	4619      	mov	r1, r3
 80253e2:	68b8      	ldr	r0, [r7, #8]
 80253e4:	f001 fb54 	bl	8026a90 <fp_copy>
         tmp[1].sign = FP_ZPOS;
 80253e8:	69bb      	ldr	r3, [r7, #24]
 80253ea:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253ee:	2200      	movs	r2, #0
 80253f0:	605a      	str	r2, [r3, #4]
   #ifdef TFM_TIMING_RESISTANT
         err =  _fp_exptmod_ct(&tmp[0], &tmp[1], tmp[1].used, P, Y);
 80253f2:	69bb      	ldr	r3, [r7, #24]
 80253f4:	f503 710b 	add.w	r1, r3, #556	@ 0x22c
 80253f8:	69bb      	ldr	r3, [r7, #24]
 80253fa:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 80253fe:	681a      	ldr	r2, [r3, #0]
 8025400:	683b      	ldr	r3, [r7, #0]
 8025402:	9300      	str	r3, [sp, #0]
 8025404:	687b      	ldr	r3, [r7, #4]
 8025406:	69b8      	ldr	r0, [r7, #24]
 8025408:	f7ff f9d4 	bl	80247b4 <_fp_exptmod_ct>
 802540c:	61f8      	str	r0, [r7, #28]
   #else
         err =  _fp_exptmod_nct(&tmp[0], &tmp[1], P, Y);
   #endif
         if ((err == 0) && (P->sign == FP_NEG)) {
 802540e:	69fb      	ldr	r3, [r7, #28]
 8025410:	2b00      	cmp	r3, #0
 8025412:	d109      	bne.n	8025428 <fp_exptmod+0x114>
 8025414:	687b      	ldr	r3, [r7, #4]
 8025416:	685b      	ldr	r3, [r3, #4]
 8025418:	2b01      	cmp	r3, #1
 802541a:	d105      	bne.n	8025428 <fp_exptmod+0x114>
            err = fp_add(Y, P, Y);
 802541c:	683a      	ldr	r2, [r7, #0]
 802541e:	6879      	ldr	r1, [r7, #4]
 8025420:	6838      	ldr	r0, [r7, #0]
 8025422:	f7fc ff5c 	bl	80222de <fp_add>
 8025426:	61f8      	str	r0, [r7, #28]
         }
      }
   #ifdef WOLFSSL_SMALL_STACK
      XFREE(tmp, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8025428:	69bb      	ldr	r3, [r7, #24]
 802542a:	617b      	str	r3, [r7, #20]
 802542c:	697b      	ldr	r3, [r7, #20]
 802542e:	2b00      	cmp	r3, #0
 8025430:	d002      	beq.n	8025438 <fp_exptmod+0x124>
 8025432:	6978      	ldr	r0, [r7, #20]
 8025434:	f7f9 fb4a 	bl	801eacc <wolfSSL_Free>
   #endif
      return err;
 8025438:	69fb      	ldr	r3, [r7, #28]
 802543a:	e01a      	b.n	8025472 <fp_exptmod+0x15e>
#else
      return FP_VAL;
#endif /* POSITIVE_EXP_ONLY check */
   }
   else if (G->used == 1 && G->dp[0] == 2) {
 802543c:	68fb      	ldr	r3, [r7, #12]
 802543e:	681b      	ldr	r3, [r3, #0]
 8025440:	2b01      	cmp	r3, #1
 8025442:	d10c      	bne.n	802545e <fp_exptmod+0x14a>
 8025444:	68fb      	ldr	r3, [r7, #12]
 8025446:	68db      	ldr	r3, [r3, #12]
 8025448:	2b02      	cmp	r3, #2
 802544a:	d108      	bne.n	802545e <fp_exptmod+0x14a>
      return _fp_exptmod_base_2(X, X->used, P, Y);
 802544c:	68bb      	ldr	r3, [r7, #8]
 802544e:	6819      	ldr	r1, [r3, #0]
 8025450:	683b      	ldr	r3, [r7, #0]
 8025452:	687a      	ldr	r2, [r7, #4]
 8025454:	68b8      	ldr	r0, [r7, #8]
 8025456:	f7ff fde7 	bl	8025028 <_fp_exptmod_base_2>
 802545a:	4603      	mov	r3, r0
 802545c:	e009      	b.n	8025472 <fp_exptmod+0x15e>
   }
   else {
      /* Positive exponent so just exptmod */
#ifdef TFM_TIMING_RESISTANT
      return _fp_exptmod_ct(G, X, X->used, P, Y);
 802545e:	68bb      	ldr	r3, [r7, #8]
 8025460:	681a      	ldr	r2, [r3, #0]
 8025462:	683b      	ldr	r3, [r7, #0]
 8025464:	9300      	str	r3, [sp, #0]
 8025466:	687b      	ldr	r3, [r7, #4]
 8025468:	68b9      	ldr	r1, [r7, #8]
 802546a:	68f8      	ldr	r0, [r7, #12]
 802546c:	f7ff f9a2 	bl	80247b4 <_fp_exptmod_ct>
 8025470:	4603      	mov	r3, r0
#else
      return _fp_exptmod_nct(G, X, P, Y);
#endif
   }
}
 8025472:	4618      	mov	r0, r3
 8025474:	3720      	adds	r7, #32
 8025476:	46bd      	mov	sp, r7
 8025478:	bd80      	pop	{r7, pc}

0802547a <fp_exptmod_nct>:
#endif
   }
}

int fp_exptmod_nct(fp_int * G, fp_int * X, fp_int * P, fp_int * Y)
{
 802547a:	b580      	push	{r7, lr}
 802547c:	b088      	sub	sp, #32
 802547e:	af00      	add	r7, sp, #0
 8025480:	60f8      	str	r0, [r7, #12]
 8025482:	60b9      	str	r1, [r7, #8]
 8025484:	607a      	str	r2, [r7, #4]
 8025486:	603b      	str	r3, [r7, #0]
#if defined(WOLFSSL_ESP32_CRYPT_RSA_PRI_EXPTMOD)
   int retHW = FP_OKAY;
#endif

   /* handle modulus of zero and prevent overflows */
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
 8025488:	687b      	ldr	r3, [r7, #4]
 802548a:	681b      	ldr	r3, [r3, #0]
 802548c:	2b00      	cmp	r3, #0
 802548e:	d003      	beq.n	8025498 <fp_exptmod_nct+0x1e>
 8025490:	687b      	ldr	r3, [r7, #4]
 8025492:	681b      	ldr	r3, [r3, #0]
 8025494:	2b44      	cmp	r3, #68	@ 0x44
 8025496:	dd02      	ble.n	802549e <fp_exptmod_nct+0x24>
      return FP_VAL;
 8025498:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802549c:	e07f      	b.n	802559e <fp_exptmod_nct+0x124>
   }
   if (fp_isone(P)) {
 802549e:	687b      	ldr	r3, [r7, #4]
 80254a0:	681b      	ldr	r3, [r3, #0]
 80254a2:	2b01      	cmp	r3, #1
 80254a4:	d10d      	bne.n	80254c2 <fp_exptmod_nct+0x48>
 80254a6:	687b      	ldr	r3, [r7, #4]
 80254a8:	68db      	ldr	r3, [r3, #12]
 80254aa:	2b01      	cmp	r3, #1
 80254ac:	d109      	bne.n	80254c2 <fp_exptmod_nct+0x48>
 80254ae:	687b      	ldr	r3, [r7, #4]
 80254b0:	685b      	ldr	r3, [r3, #4]
 80254b2:	2b00      	cmp	r3, #0
 80254b4:	d105      	bne.n	80254c2 <fp_exptmod_nct+0x48>
      fp_set(Y, 0);
 80254b6:	2100      	movs	r1, #0
 80254b8:	6838      	ldr	r0, [r7, #0]
 80254ba:	f000 fed0 	bl	802625e <fp_set>
      return FP_OKAY;
 80254be:	2300      	movs	r3, #0
 80254c0:	e06d      	b.n	802559e <fp_exptmod_nct+0x124>
   }
   if (fp_iszero(X)) {
 80254c2:	68bb      	ldr	r3, [r7, #8]
 80254c4:	681b      	ldr	r3, [r3, #0]
 80254c6:	2b00      	cmp	r3, #0
 80254c8:	d105      	bne.n	80254d6 <fp_exptmod_nct+0x5c>
      fp_set(Y, 1);
 80254ca:	2101      	movs	r1, #1
 80254cc:	6838      	ldr	r0, [r7, #0]
 80254ce:	f000 fec6 	bl	802625e <fp_set>
      return FP_OKAY;
 80254d2:	2300      	movs	r3, #0
 80254d4:	e063      	b.n	802559e <fp_exptmod_nct+0x124>
   }
   if (fp_iszero(G)) {
 80254d6:	68fb      	ldr	r3, [r7, #12]
 80254d8:	681b      	ldr	r3, [r3, #0]
 80254da:	2b00      	cmp	r3, #0
 80254dc:	d105      	bne.n	80254ea <fp_exptmod_nct+0x70>
      fp_set(Y, 0);
 80254de:	2100      	movs	r1, #0
 80254e0:	6838      	ldr	r0, [r7, #0]
 80254e2:	f000 febc 	bl	802625e <fp_set>
      return FP_OKAY;
 80254e6:	2300      	movs	r3, #0
 80254e8:	e059      	b.n	802559e <fp_exptmod_nct+0x124>
         break;
   }
   /* falling through to SW: */
#endif

   if (X->sign == FP_NEG) {
 80254ea:	68bb      	ldr	r3, [r7, #8]
 80254ec:	685b      	ldr	r3, [r3, #4]
 80254ee:	2b01      	cmp	r3, #1
 80254f0:	d14e      	bne.n	8025590 <fp_exptmod_nct+0x116>
   #else
      fp_int *tmp;
   #endif

   #ifdef WOLFSSL_SMALL_STACK
      tmp = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 80254f2:	f44f 608b 	mov.w	r0, #1112	@ 0x458
 80254f6:	f7f9 facd 	bl	801ea94 <wolfSSL_Malloc>
 80254fa:	61b8      	str	r0, [r7, #24]
      if (tmp == NULL)
 80254fc:	69bb      	ldr	r3, [r7, #24]
 80254fe:	2b00      	cmp	r3, #0
 8025500:	d102      	bne.n	8025508 <fp_exptmod_nct+0x8e>
          return FP_MEM;
 8025502:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8025506:	e04a      	b.n	802559e <fp_exptmod_nct+0x124>
   #endif

      /* yes, copy G and invmod it */
      fp_init_copy(&tmp[0], G);
 8025508:	68f9      	ldr	r1, [r7, #12]
 802550a:	69b8      	ldr	r0, [r7, #24]
 802550c:	f001 faff 	bl	8026b0e <fp_init_copy>
      fp_init_copy(&tmp[1], P);
 8025510:	69bb      	ldr	r3, [r7, #24]
 8025512:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8025516:	6879      	ldr	r1, [r7, #4]
 8025518:	4618      	mov	r0, r3
 802551a:	f001 faf8 	bl	8026b0e <fp_init_copy>
      tmp[1].sign = FP_ZPOS;
 802551e:	69bb      	ldr	r3, [r7, #24]
 8025520:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 8025524:	2200      	movs	r2, #0
 8025526:	605a      	str	r2, [r3, #4]
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
 8025528:	69bb      	ldr	r3, [r7, #24]
 802552a:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
 802552e:	69ba      	ldr	r2, [r7, #24]
 8025530:	4619      	mov	r1, r3
 8025532:	69b8      	ldr	r0, [r7, #24]
 8025534:	f7fe fba9 	bl	8023c8a <fp_invmod>
 8025538:	61f8      	str	r0, [r7, #28]
      if (err == FP_OKAY) {
 802553a:	69fb      	ldr	r3, [r7, #28]
 802553c:	2b00      	cmp	r3, #0
 802553e:	d11d      	bne.n	802557c <fp_exptmod_nct+0x102>
         X->sign = FP_ZPOS;
 8025540:	68bb      	ldr	r3, [r7, #8]
 8025542:	2200      	movs	r2, #0
 8025544:	605a      	str	r2, [r3, #4]
         err =  _fp_exptmod_nct(&tmp[0], X, P, Y);
 8025546:	683b      	ldr	r3, [r7, #0]
 8025548:	687a      	ldr	r2, [r7, #4]
 802554a:	68b9      	ldr	r1, [r7, #8]
 802554c:	69b8      	ldr	r0, [r7, #24]
 802554e:	f7ff fa91 	bl	8024a74 <_fp_exptmod_nct>
 8025552:	61f8      	str	r0, [r7, #28]
         if (X != Y) {
 8025554:	68ba      	ldr	r2, [r7, #8]
 8025556:	683b      	ldr	r3, [r7, #0]
 8025558:	429a      	cmp	r2, r3
 802555a:	d002      	beq.n	8025562 <fp_exptmod_nct+0xe8>
            X->sign = FP_NEG;
 802555c:	68bb      	ldr	r3, [r7, #8]
 802555e:	2201      	movs	r2, #1
 8025560:	605a      	str	r2, [r3, #4]
         }
         if ((err == 0) && (P->sign == FP_NEG)) {
 8025562:	69fb      	ldr	r3, [r7, #28]
 8025564:	2b00      	cmp	r3, #0
 8025566:	d109      	bne.n	802557c <fp_exptmod_nct+0x102>
 8025568:	687b      	ldr	r3, [r7, #4]
 802556a:	685b      	ldr	r3, [r3, #4]
 802556c:	2b01      	cmp	r3, #1
 802556e:	d105      	bne.n	802557c <fp_exptmod_nct+0x102>
            err = fp_add(Y, P, Y);
 8025570:	683a      	ldr	r2, [r7, #0]
 8025572:	6879      	ldr	r1, [r7, #4]
 8025574:	6838      	ldr	r0, [r7, #0]
 8025576:	f7fc feb2 	bl	80222de <fp_add>
 802557a:	61f8      	str	r0, [r7, #28]
         }
      }
   #ifdef WOLFSSL_SMALL_STACK
      XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 802557c:	69bb      	ldr	r3, [r7, #24]
 802557e:	617b      	str	r3, [r7, #20]
 8025580:	697b      	ldr	r3, [r7, #20]
 8025582:	2b00      	cmp	r3, #0
 8025584:	d002      	beq.n	802558c <fp_exptmod_nct+0x112>
 8025586:	6978      	ldr	r0, [r7, #20]
 8025588:	f7f9 faa0 	bl	801eacc <wolfSSL_Free>
   #endif
      return err;
 802558c:	69fb      	ldr	r3, [r7, #28]
 802558e:	e006      	b.n	802559e <fp_exptmod_nct+0x124>
      return FP_VAL;
#endif
   }
   else {
      /* Positive exponent so just exptmod */
      return  _fp_exptmod_nct(G, X, P, Y);
 8025590:	683b      	ldr	r3, [r7, #0]
 8025592:	687a      	ldr	r2, [r7, #4]
 8025594:	68b9      	ldr	r1, [r7, #8]
 8025596:	68f8      	ldr	r0, [r7, #12]
 8025598:	f7ff fa6c 	bl	8024a74 <_fp_exptmod_nct>
 802559c:	4603      	mov	r3, r0
   }
}
 802559e:	4618      	mov	r0, r3
 80255a0:	3720      	adds	r7, #32
 80255a2:	46bd      	mov	sp, r7
 80255a4:	bd80      	pop	{r7, pc}

080255a6 <fp_2expt>:

/* computes a = 2**b */
void fp_2expt(fp_int *a, int b)
{
 80255a6:	b580      	push	{r7, lr}
 80255a8:	b084      	sub	sp, #16
 80255aa:	af00      	add	r7, sp, #0
 80255ac:	6078      	str	r0, [r7, #4]
 80255ae:	6039      	str	r1, [r7, #0]
   int     z;

   /* zero a as per default */
   fp_zero (a);
 80255b0:	6878      	ldr	r0, [r7, #4]
 80255b2:	f001 f891 	bl	80266d8 <fp_zero>

   if (b < 0) {
 80255b6:	683b      	ldr	r3, [r7, #0]
 80255b8:	2b00      	cmp	r3, #0
 80255ba:	db18      	blt.n	80255ee <fp_2expt+0x48>
      return;
   }

   z = b / DIGIT_BIT;
 80255bc:	683b      	ldr	r3, [r7, #0]
 80255be:	2b00      	cmp	r3, #0
 80255c0:	da00      	bge.n	80255c4 <fp_2expt+0x1e>
 80255c2:	331f      	adds	r3, #31
 80255c4:	115b      	asrs	r3, r3, #5
 80255c6:	60fb      	str	r3, [r7, #12]
   if (z >= FP_SIZE) {
 80255c8:	68fb      	ldr	r3, [r7, #12]
 80255ca:	2b87      	cmp	r3, #135	@ 0x87
 80255cc:	dc11      	bgt.n	80255f2 <fp_2expt+0x4c>
      return;
   }

  /* set the used count of where the bit will go */
  a->used = z + 1;
 80255ce:	68fb      	ldr	r3, [r7, #12]
 80255d0:	1c5a      	adds	r2, r3, #1
 80255d2:	687b      	ldr	r3, [r7, #4]
 80255d4:	601a      	str	r2, [r3, #0]

  /* put the single bit in its place */
  a->dp[z] = ((fp_digit)1) << (b % DIGIT_BIT);
 80255d6:	683b      	ldr	r3, [r7, #0]
 80255d8:	f003 031f 	and.w	r3, r3, #31
 80255dc:	2201      	movs	r2, #1
 80255de:	409a      	lsls	r2, r3
 80255e0:	6879      	ldr	r1, [r7, #4]
 80255e2:	68fb      	ldr	r3, [r7, #12]
 80255e4:	3302      	adds	r3, #2
 80255e6:	009b      	lsls	r3, r3, #2
 80255e8:	440b      	add	r3, r1
 80255ea:	605a      	str	r2, [r3, #4]
 80255ec:	e002      	b.n	80255f4 <fp_2expt+0x4e>
      return;
 80255ee:	bf00      	nop
 80255f0:	e000      	b.n	80255f4 <fp_2expt+0x4e>
      return;
 80255f2:	bf00      	nop
}
 80255f4:	3710      	adds	r7, #16
 80255f6:	46bd      	mov	sp, r7
 80255f8:	bd80      	pop	{r7, pc}

080255fa <fp_sqr>:

/* b = a*a  */
int fp_sqr(fp_int *A, fp_int *B)
{
 80255fa:	b580      	push	{r7, lr}
 80255fc:	b086      	sub	sp, #24
 80255fe:	af00      	add	r7, sp, #0
 8025600:	6078      	str	r0, [r7, #4]
 8025602:	6039      	str	r1, [r7, #0]
    int err;
    int y, oldused;

    oldused = B->used;
 8025604:	683b      	ldr	r3, [r7, #0]
 8025606:	681b      	ldr	r3, [r3, #0]
 8025608:	60fb      	str	r3, [r7, #12]
    y = A->used;
 802560a:	687b      	ldr	r3, [r7, #4]
 802560c:	681b      	ldr	r3, [r3, #0]
 802560e:	613b      	str	r3, [r7, #16]

    /* error if we're out of range */
    if (y + y >= FP_SIZE) {
 8025610:	693b      	ldr	r3, [r7, #16]
 8025612:	005b      	lsls	r3, r3, #1
 8025614:	2b87      	cmp	r3, #135	@ 0x87
 8025616:	dd03      	ble.n	8025620 <fp_sqr+0x26>
       err = FP_VAL;
 8025618:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 802561c:	617b      	str	r3, [r7, #20]
       goto clean;
 802561e:	e004      	b.n	802562a <fp_sqr+0x30>
        if (y <= 64) {
           err = fp_sqr_comba64(A,B);
           goto clean;
        }
#endif
       err = fp_sqr_comba(A, B);
 8025620:	6839      	ldr	r1, [r7, #0]
 8025622:	6878      	ldr	r0, [r7, #4]
 8025624:	f000 f81b 	bl	802565e <fp_sqr_comba>
 8025628:	6178      	str	r0, [r7, #20]

clean:
  /* zero any excess digits on the destination that we didn't write to */
  for (y = B->used; y >= 0 && y < oldused; y++) {
 802562a:	683b      	ldr	r3, [r7, #0]
 802562c:	681b      	ldr	r3, [r3, #0]
 802562e:	613b      	str	r3, [r7, #16]
 8025630:	e009      	b.n	8025646 <fp_sqr+0x4c>
    B->dp[y] = 0;
 8025632:	683a      	ldr	r2, [r7, #0]
 8025634:	693b      	ldr	r3, [r7, #16]
 8025636:	3302      	adds	r3, #2
 8025638:	009b      	lsls	r3, r3, #2
 802563a:	4413      	add	r3, r2
 802563c:	2200      	movs	r2, #0
 802563e:	605a      	str	r2, [r3, #4]
  for (y = B->used; y >= 0 && y < oldused; y++) {
 8025640:	693b      	ldr	r3, [r7, #16]
 8025642:	3301      	adds	r3, #1
 8025644:	613b      	str	r3, [r7, #16]
 8025646:	693b      	ldr	r3, [r7, #16]
 8025648:	2b00      	cmp	r3, #0
 802564a:	db03      	blt.n	8025654 <fp_sqr+0x5a>
 802564c:	693a      	ldr	r2, [r7, #16]
 802564e:	68fb      	ldr	r3, [r7, #12]
 8025650:	429a      	cmp	r2, r3
 8025652:	dbee      	blt.n	8025632 <fp_sqr+0x38>
  }

  return err;
 8025654:	697b      	ldr	r3, [r7, #20]
}
 8025656:	4618      	mov	r0, r3
 8025658:	3718      	adds	r7, #24
 802565a:	46bd      	mov	sp, r7
 802565c:	bd80      	pop	{r7, pc}

0802565e <fp_sqr_comba>:

/* generic comba squarer */
int fp_sqr_comba(fp_int *A, fp_int *B)
{
 802565e:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8025662:	b0b6      	sub	sp, #216	@ 0xd8
 8025664:	af00      	add	r7, sp, #0
 8025666:	67f8      	str	r0, [r7, #124]	@ 0x7c
 8025668:	67b9      	str	r1, [r7, #120]	@ 0x78
  int       pa, ix, iz;
  fp_digit  c0, c1, c2;
#ifdef TFM_ISO
  fp_word   tt = 0;
 802566a:	f04f 0200 	mov.w	r2, #0
 802566e:	f04f 0300 	mov.w	r3, #0
 8025672:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
#else
   fp_int    *tmp;
#endif

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8025676:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 802567a:	f7f9 fa0b 	bl	801ea94 <wolfSSL_Malloc>
 802567e:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
   if (tmp == NULL)
 8025682:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8025686:	2b00      	cmp	r3, #0
 8025688:	d102      	bne.n	8025690 <fp_sqr_comba+0x32>
       return FP_MEM;
 802568a:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 802568e:	e1f6      	b.n	8025a7e <fp_sqr_comba+0x420>
#endif

  /* get size of output and trim */
  pa = A->used + A->used;
 8025690:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025692:	681b      	ldr	r3, [r3, #0]
 8025694:	005b      	lsls	r3, r3, #1
 8025696:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  if (pa >= FP_SIZE) {
 802569a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 802569e:	2b87      	cmp	r3, #135	@ 0x87
 80256a0:	dd02      	ble.n	80256a8 <fp_sqr_comba+0x4a>
     pa = FP_SIZE-1;
 80256a2:	2387      	movs	r3, #135	@ 0x87
 80256a4:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
  }

  /* number of output digits to produce */
  COMBA_START;
  COMBA_CLEAR;
 80256a8:	2300      	movs	r3, #0
 80256aa:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80256ae:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80256b2:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 80256b6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80256ba:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8

  if (A == B) {
 80256be:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 80256c0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80256c2:	429a      	cmp	r2, r3
 80256c4:	d108      	bne.n	80256d8 <fp_sqr_comba+0x7a>
     fp_init(tmp);
 80256c6:	f8d7 00a4 	ldr.w	r0, [r7, #164]	@ 0xa4
 80256ca:	f000 fff7 	bl	80266bc <fp_init>
     dst = tmp;
 80256ce:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80256d2:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 80256d6:	e005      	b.n	80256e4 <fp_sqr_comba+0x86>
  } else {
     fp_zero(B);
 80256d8:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80256da:	f000 fffd 	bl	80266d8 <fp_zero>
     dst = B;
 80256de:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80256e0:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  }

  for (ix = 0; ix < pa; ix++) {
 80256e4:	2300      	movs	r3, #0
 80256e6:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 80256ea:	e17f      	b.n	80259ec <fp_sqr_comba+0x38e>
      int      tx, ty, iy;
      fp_digit *tmpy, *tmpx;

      /* get offsets into the two bignums */
      ty = MIN(A->used-1, ix);
 80256ec:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80256ee:	681a      	ldr	r2, [r3, #0]
 80256f0:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80256f4:	4293      	cmp	r3, r2
 80256f6:	db03      	blt.n	8025700 <fp_sqr_comba+0xa2>
 80256f8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80256fa:	681b      	ldr	r3, [r3, #0]
 80256fc:	3b01      	subs	r3, #1
 80256fe:	e001      	b.n	8025704 <fp_sqr_comba+0xa6>
 8025700:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025704:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
      tx = ix - ty;
 8025708:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 802570c:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8025710:	1ad3      	subs	r3, r2, r3
 8025712:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98

      /* setup temp aliases */
      tmpx = A->dp + tx;
 8025716:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8025718:	f103 020c 	add.w	r2, r3, #12
 802571c:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8025720:	009b      	lsls	r3, r3, #2
 8025722:	4413      	add	r3, r2
 8025724:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
      tmpy = A->dp + ty;
 8025728:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802572a:	f103 020c 	add.w	r2, r3, #12
 802572e:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8025732:	009b      	lsls	r3, r3, #2
 8025734:	4413      	add	r3, r2
 8025736:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

      /* this is the number of times the loop will iterate,
         while (tx++ < a->used && ty-- >= 0) { ... }
       */
      iy = MIN(A->used-tx, ty+1);
 802573a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802573c:	681a      	ldr	r2, [r3, #0]
 802573e:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8025742:	1ad2      	subs	r2, r2, r3
 8025744:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 8025748:	4293      	cmp	r3, r2
 802574a:	db05      	blt.n	8025758 <fp_sqr_comba+0xfa>
 802574c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 802574e:	681a      	ldr	r2, [r3, #0]
 8025750:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 8025754:	1ad3      	subs	r3, r2, r3
 8025756:	e002      	b.n	802575e <fp_sqr_comba+0x100>
 8025758:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 802575c:	3301      	adds	r3, #1
 802575e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
      /* now for squaring tx can never equal ty
       * we halve the distance since they approach
       * at a rate of 2x and we have to round because
       * odd cases need to be executed
       */
      iy = MIN(iy, (ty-tx+1)>>1);
 8025762:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8025766:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 802576a:	1ad3      	subs	r3, r2, r3
 802576c:	3301      	adds	r3, #1
 802576e:	105a      	asrs	r2, r3, #1
 8025770:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8025774:	4293      	cmp	r3, r2
 8025776:	bfa8      	it	ge
 8025778:	4613      	movge	r3, r2
 802577a:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

      /* forward carries */
      COMBA_FORWARD;
 802577e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025782:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8025786:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 802578a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 802578e:	2300      	movs	r3, #0
 8025790:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0

      /* execute loop */
      for (iz = 0; iz < iy; iz++) {
 8025794:	2300      	movs	r3, #0
 8025796:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 802579a:	e0a9      	b.n	80258f0 <fp_sqr_comba+0x292>
          SQRADD2(*tmpx++, *tmpy--);
 802579c:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 80257a0:	1d13      	adds	r3, r2, #4
 80257a2:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 80257a6:	6813      	ldr	r3, [r2, #0]
 80257a8:	2200      	movs	r2, #0
 80257aa:	673b      	str	r3, [r7, #112]	@ 0x70
 80257ac:	677a      	str	r2, [r7, #116]	@ 0x74
 80257ae:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 80257b2:	1f13      	subs	r3, r2, #4
 80257b4:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 80257b8:	6813      	ldr	r3, [r2, #0]
 80257ba:	2200      	movs	r2, #0
 80257bc:	66bb      	str	r3, [r7, #104]	@ 0x68
 80257be:	66fa      	str	r2, [r7, #108]	@ 0x6c
 80257c0:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
 80257c4:	460b      	mov	r3, r1
 80257c6:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80257c8:	fb02 f203 	mul.w	r2, r2, r3
 80257cc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80257ce:	e9c7 011c 	strd	r0, r1, [r7, #112]	@ 0x70
 80257d2:	4601      	mov	r1, r0
 80257d4:	fb01 f303 	mul.w	r3, r1, r3
 80257d8:	4413      	add	r3, r2
 80257da:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80257dc:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 80257de:	fba2 8901 	umull	r8, r9, r2, r1
 80257e2:	444b      	add	r3, r9
 80257e4:	4699      	mov	r9, r3
 80257e6:	e9c7 8920 	strd	r8, r9, [r7, #128]	@ 0x80
 80257ea:	e9c7 8920 	strd	r8, r9, [r7, #128]	@ 0x80
 80257ee:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80257f2:	2200      	movs	r2, #0
 80257f4:	663b      	str	r3, [r7, #96]	@ 0x60
 80257f6:	667a      	str	r2, [r7, #100]	@ 0x64
 80257f8:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 80257fc:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 80257fe:	1851      	adds	r1, r2, r1
 8025800:	62b9      	str	r1, [r7, #40]	@ 0x28
 8025802:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8025804:	414b      	adcs	r3, r1
 8025806:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8025808:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 802580c:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 8025810:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8025814:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8025818:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 802581c:	2200      	movs	r2, #0
 802581e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025820:	65fa      	str	r2, [r7, #92]	@ 0x5c
 8025822:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8025826:	f04f 0000 	mov.w	r0, #0
 802582a:	f04f 0100 	mov.w	r1, #0
 802582e:	0018      	movs	r0, r3
 8025830:	2100      	movs	r1, #0
 8025832:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025834:	181b      	adds	r3, r3, r0
 8025836:	623b      	str	r3, [r7, #32]
 8025838:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802583a:	414b      	adcs	r3, r1
 802583c:	627b      	str	r3, [r7, #36]	@ 0x24
 802583e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8025842:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 8025846:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802584a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 802584e:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 8025852:	f04f 0000 	mov.w	r0, #0
 8025856:	f04f 0100 	mov.w	r1, #0
 802585a:	0018      	movs	r0, r3
 802585c:	2100      	movs	r1, #0
 802585e:	4602      	mov	r2, r0
 8025860:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8025864:	4413      	add	r3, r2
 8025866:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 802586a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802586e:	2200      	movs	r2, #0
 8025870:	653b      	str	r3, [r7, #80]	@ 0x50
 8025872:	657a      	str	r2, [r7, #84]	@ 0x54
 8025874:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 8025878:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 802587a:	1851      	adds	r1, r2, r1
 802587c:	61b9      	str	r1, [r7, #24]
 802587e:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8025880:	414b      	adcs	r3, r1
 8025882:	61fb      	str	r3, [r7, #28]
 8025884:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8025888:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 802588c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8025890:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8025894:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025898:	2200      	movs	r2, #0
 802589a:	64bb      	str	r3, [r7, #72]	@ 0x48
 802589c:	64fa      	str	r2, [r7, #76]	@ 0x4c
 802589e:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 80258a2:	f04f 0000 	mov.w	r0, #0
 80258a6:	f04f 0100 	mov.w	r1, #0
 80258aa:	0018      	movs	r0, r3
 80258ac:	2100      	movs	r1, #0
 80258ae:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80258b0:	181b      	adds	r3, r3, r0
 80258b2:	613b      	str	r3, [r7, #16]
 80258b4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80258b6:	414b      	adcs	r3, r1
 80258b8:	617b      	str	r3, [r7, #20]
 80258ba:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80258be:	e9c7 232a 	strd	r2, r3, [r7, #168]	@ 0xa8
 80258c2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80258c6:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 80258ca:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	@ 0xa8
 80258ce:	f04f 0000 	mov.w	r0, #0
 80258d2:	f04f 0100 	mov.w	r1, #0
 80258d6:	0018      	movs	r0, r3
 80258d8:	2100      	movs	r1, #0
 80258da:	4602      	mov	r2, r0
 80258dc:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80258e0:	4413      	add	r3, r2
 80258e2:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
      for (iz = 0; iz < iy; iz++) {
 80258e6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80258ea:	3301      	adds	r3, #1
 80258ec:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 80258f0:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 80258f4:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 80258f8:	429a      	cmp	r2, r3
 80258fa:	f6ff af4f 	blt.w	802579c <fp_sqr_comba+0x13e>
      }

      /* even columns have the square term in them */
      if ((ix&1) == 0) {
 80258fe:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025902:	f003 0301 	and.w	r3, r3, #1
 8025906:	2b00      	cmp	r3, #0
 8025908:	d161      	bne.n	80259ce <fp_sqr_comba+0x370>
          /* TAO change COMBA_ADD back to SQRADD */
          SQRADD(A->dp[ix>>1], A->dp[ix>>1]);
 802590a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 802590e:	2200      	movs	r2, #0
 8025910:	63bb      	str	r3, [r7, #56]	@ 0x38
 8025912:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8025914:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8025918:	105b      	asrs	r3, r3, #1
 802591a:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 802591c:	3302      	adds	r3, #2
 802591e:	009b      	lsls	r3, r3, #2
 8025920:	4413      	add	r3, r2
 8025922:	685b      	ldr	r3, [r3, #4]
 8025924:	2200      	movs	r2, #0
 8025926:	633b      	str	r3, [r7, #48]	@ 0x30
 8025928:	637a      	str	r2, [r7, #52]	@ 0x34
 802592a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 802592e:	105b      	asrs	r3, r3, #1
 8025930:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8025932:	3302      	adds	r3, #2
 8025934:	009b      	lsls	r3, r3, #2
 8025936:	4413      	add	r3, r2
 8025938:	685b      	ldr	r3, [r3, #4]
 802593a:	2200      	movs	r2, #0
 802593c:	469a      	mov	sl, r3
 802593e:	4693      	mov	fp, r2
 8025940:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
 8025944:	460b      	mov	r3, r1
 8025946:	fb0a f203 	mul.w	r2, sl, r3
 802594a:	4603      	mov	r3, r0
 802594c:	fb03 f30b 	mul.w	r3, r3, fp
 8025950:	4413      	add	r3, r2
 8025952:	4602      	mov	r2, r0
 8025954:	fba2 450a 	umull	r4, r5, r2, sl
 8025958:	442b      	add	r3, r5
 802595a:	461d      	mov	r5, r3
 802595c:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 8025960:	460b      	mov	r3, r1
 8025962:	191b      	adds	r3, r3, r4
 8025964:	60bb      	str	r3, [r7, #8]
 8025966:	4613      	mov	r3, r2
 8025968:	416b      	adcs	r3, r5
 802596a:	60fb      	str	r3, [r7, #12]
 802596c:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8025970:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
 8025974:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8025978:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 802597c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8025980:	2200      	movs	r2, #0
 8025982:	643b      	str	r3, [r7, #64]	@ 0x40
 8025984:	647a      	str	r2, [r7, #68]	@ 0x44
 8025986:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 802598a:	f04f 0000 	mov.w	r0, #0
 802598e:	f04f 0100 	mov.w	r1, #0
 8025992:	0018      	movs	r0, r3
 8025994:	2100      	movs	r1, #0
 8025996:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025998:	181b      	adds	r3, r3, r0
 802599a:	603b      	str	r3, [r7, #0]
 802599c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 802599e:	414b      	adcs	r3, r1
 80259a0:	607b      	str	r3, [r7, #4]
 80259a2:	e9d7 2300 	ldrd	r2, r3, [r7]
 80259a6:	e9c7 2322 	strd	r2, r3, [r7, #136]	@ 0x88
 80259aa:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80259ae:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 80259b2:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	@ 0x88
 80259b6:	f04f 0000 	mov.w	r0, #0
 80259ba:	f04f 0100 	mov.w	r1, #0
 80259be:	0018      	movs	r0, r3
 80259c0:	2100      	movs	r1, #0
 80259c2:	4602      	mov	r2, r0
 80259c4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80259c8:	4413      	add	r3, r2
 80259ca:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
      }

      /* store it */
      COMBA_STORE(dst->dp[ix]);
 80259ce:	f8d7 10bc 	ldr.w	r1, [r7, #188]	@ 0xbc
 80259d2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80259d6:	3302      	adds	r3, #2
 80259d8:	009a      	lsls	r2, r3, #2
 80259da:	440a      	add	r2, r1
 80259dc:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 80259e0:	6053      	str	r3, [r2, #4]
  for (ix = 0; ix < pa; ix++) {
 80259e2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 80259e6:	3301      	adds	r3, #1
 80259e8:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 80259ec:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 80259f0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80259f4:	429a      	cmp	r2, r3
 80259f6:	f6ff ae79 	blt.w	80256ec <fp_sqr_comba+0x8e>
  }

  COMBA_FINI;

  /* setup dest */
  dst->used = pa;
 80259fa:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80259fe:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8025a02:	601a      	str	r2, [r3, #0]
  fp_clamp (dst);
 8025a04:	e006      	b.n	8025a14 <fp_sqr_comba+0x3b6>
 8025a06:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a0a:	681b      	ldr	r3, [r3, #0]
 8025a0c:	1e5a      	subs	r2, r3, #1
 8025a0e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a12:	601a      	str	r2, [r3, #0]
 8025a14:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a18:	681b      	ldr	r3, [r3, #0]
 8025a1a:	2b00      	cmp	r3, #0
 8025a1c:	d00b      	beq.n	8025a36 <fp_sqr_comba+0x3d8>
 8025a1e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a22:	681b      	ldr	r3, [r3, #0]
 8025a24:	3b01      	subs	r3, #1
 8025a26:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8025a2a:	3302      	adds	r3, #2
 8025a2c:	009b      	lsls	r3, r3, #2
 8025a2e:	4413      	add	r3, r2
 8025a30:	685b      	ldr	r3, [r3, #4]
 8025a32:	2b00      	cmp	r3, #0
 8025a34:	d0e7      	beq.n	8025a06 <fp_sqr_comba+0x3a8>
 8025a36:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a3a:	681b      	ldr	r3, [r3, #0]
 8025a3c:	2b00      	cmp	r3, #0
 8025a3e:	d003      	beq.n	8025a48 <fp_sqr_comba+0x3ea>
 8025a40:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8025a44:	685b      	ldr	r3, [r3, #4]
 8025a46:	e000      	b.n	8025a4a <fp_sqr_comba+0x3ec>
 8025a48:	2300      	movs	r3, #0
 8025a4a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8025a4e:	6053      	str	r3, [r2, #4]
  if (dst != B) {
 8025a50:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8025a54:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8025a56:	429a      	cmp	r2, r3
 8025a58:	d004      	beq.n	8025a64 <fp_sqr_comba+0x406>
     fp_copy(dst, B);
 8025a5a:	6fb9      	ldr	r1, [r7, #120]	@ 0x78
 8025a5c:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8025a60:	f001 f816 	bl	8026a90 <fp_copy>
#ifdef TFM_ISO
  (void)tt;
#endif

#ifdef WOLFSSL_SMALL_STACK
  XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8025a64:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8025a68:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8025a6c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8025a70:	2b00      	cmp	r3, #0
 8025a72:	d003      	beq.n	8025a7c <fp_sqr_comba+0x41e>
 8025a74:	f8d7 00a0 	ldr.w	r0, [r7, #160]	@ 0xa0
 8025a78:	f7f9 f828 	bl	801eacc <wolfSSL_Free>
#endif
  return FP_OKAY;
 8025a7c:	2300      	movs	r3, #0
}
 8025a7e:	4618      	mov	r0, r3
 8025a80:	37d8      	adds	r7, #216	@ 0xd8
 8025a82:	46bd      	mov	sp, r7
 8025a84:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08025a88 <fp_cmp>:

int fp_cmp(fp_int *a, fp_int *b)
{
 8025a88:	b580      	push	{r7, lr}
 8025a8a:	b082      	sub	sp, #8
 8025a8c:	af00      	add	r7, sp, #0
 8025a8e:	6078      	str	r0, [r7, #4]
 8025a90:	6039      	str	r1, [r7, #0]
   if (a->sign == FP_NEG && b->sign == FP_ZPOS) {
 8025a92:	687b      	ldr	r3, [r7, #4]
 8025a94:	685b      	ldr	r3, [r3, #4]
 8025a96:	2b01      	cmp	r3, #1
 8025a98:	d106      	bne.n	8025aa8 <fp_cmp+0x20>
 8025a9a:	683b      	ldr	r3, [r7, #0]
 8025a9c:	685b      	ldr	r3, [r3, #4]
 8025a9e:	2b00      	cmp	r3, #0
 8025aa0:	d102      	bne.n	8025aa8 <fp_cmp+0x20>
      return FP_LT;
 8025aa2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025aa6:	e018      	b.n	8025ada <fp_cmp+0x52>
   } else if (a->sign == FP_ZPOS && b->sign == FP_NEG) {
 8025aa8:	687b      	ldr	r3, [r7, #4]
 8025aaa:	685b      	ldr	r3, [r3, #4]
 8025aac:	2b00      	cmp	r3, #0
 8025aae:	d105      	bne.n	8025abc <fp_cmp+0x34>
 8025ab0:	683b      	ldr	r3, [r7, #0]
 8025ab2:	685b      	ldr	r3, [r3, #4]
 8025ab4:	2b01      	cmp	r3, #1
 8025ab6:	d101      	bne.n	8025abc <fp_cmp+0x34>
      return FP_GT;
 8025ab8:	2301      	movs	r3, #1
 8025aba:	e00e      	b.n	8025ada <fp_cmp+0x52>
   } else {
      /* compare digits */
      if (a->sign == FP_NEG) {
 8025abc:	687b      	ldr	r3, [r7, #4]
 8025abe:	685b      	ldr	r3, [r3, #4]
 8025ac0:	2b01      	cmp	r3, #1
 8025ac2:	d105      	bne.n	8025ad0 <fp_cmp+0x48>
         /* if negative compare opposite direction */
         return fp_cmp_mag(b, a);
 8025ac4:	6879      	ldr	r1, [r7, #4]
 8025ac6:	6838      	ldr	r0, [r7, #0]
 8025ac8:	f000 f843 	bl	8025b52 <fp_cmp_mag>
 8025acc:	4603      	mov	r3, r0
 8025ace:	e004      	b.n	8025ada <fp_cmp+0x52>
      } else {
         return fp_cmp_mag(a, b);
 8025ad0:	6839      	ldr	r1, [r7, #0]
 8025ad2:	6878      	ldr	r0, [r7, #4]
 8025ad4:	f000 f83d 	bl	8025b52 <fp_cmp_mag>
 8025ad8:	4603      	mov	r3, r0
      }
   }
}
 8025ada:	4618      	mov	r0, r3
 8025adc:	3708      	adds	r7, #8
 8025ade:	46bd      	mov	sp, r7
 8025ae0:	bd80      	pop	{r7, pc}

08025ae2 <fp_cmp_d>:

/* compare against a single digit */
int fp_cmp_d(fp_int *a, fp_digit b)
{
 8025ae2:	b480      	push	{r7}
 8025ae4:	b083      	sub	sp, #12
 8025ae6:	af00      	add	r7, sp, #0
 8025ae8:	6078      	str	r0, [r7, #4]
 8025aea:	6039      	str	r1, [r7, #0]
  /* special case for zero*/
  if (a->used == 0 && b == 0)
 8025aec:	687b      	ldr	r3, [r7, #4]
 8025aee:	681b      	ldr	r3, [r3, #0]
 8025af0:	2b00      	cmp	r3, #0
 8025af2:	d104      	bne.n	8025afe <fp_cmp_d+0x1c>
 8025af4:	683b      	ldr	r3, [r7, #0]
 8025af6:	2b00      	cmp	r3, #0
 8025af8:	d101      	bne.n	8025afe <fp_cmp_d+0x1c>
    return FP_EQ;
 8025afa:	2300      	movs	r3, #0
 8025afc:	e023      	b.n	8025b46 <fp_cmp_d+0x64>

  /* compare based on sign */
  if ((b && a->used == 0) || a->sign == FP_NEG) {
 8025afe:	683b      	ldr	r3, [r7, #0]
 8025b00:	2b00      	cmp	r3, #0
 8025b02:	d003      	beq.n	8025b0c <fp_cmp_d+0x2a>
 8025b04:	687b      	ldr	r3, [r7, #4]
 8025b06:	681b      	ldr	r3, [r3, #0]
 8025b08:	2b00      	cmp	r3, #0
 8025b0a:	d003      	beq.n	8025b14 <fp_cmp_d+0x32>
 8025b0c:	687b      	ldr	r3, [r7, #4]
 8025b0e:	685b      	ldr	r3, [r3, #4]
 8025b10:	2b01      	cmp	r3, #1
 8025b12:	d102      	bne.n	8025b1a <fp_cmp_d+0x38>
    return FP_LT;
 8025b14:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025b18:	e015      	b.n	8025b46 <fp_cmp_d+0x64>
  }

  /* compare based on magnitude */
  if (a->used > 1) {
 8025b1a:	687b      	ldr	r3, [r7, #4]
 8025b1c:	681b      	ldr	r3, [r3, #0]
 8025b1e:	2b01      	cmp	r3, #1
 8025b20:	dd01      	ble.n	8025b26 <fp_cmp_d+0x44>
    return FP_GT;
 8025b22:	2301      	movs	r3, #1
 8025b24:	e00f      	b.n	8025b46 <fp_cmp_d+0x64>
  }

  /* compare the only digit of a to b */
  if (a->dp[0] > b) {
 8025b26:	687b      	ldr	r3, [r7, #4]
 8025b28:	68db      	ldr	r3, [r3, #12]
 8025b2a:	683a      	ldr	r2, [r7, #0]
 8025b2c:	429a      	cmp	r2, r3
 8025b2e:	d201      	bcs.n	8025b34 <fp_cmp_d+0x52>
    return FP_GT;
 8025b30:	2301      	movs	r3, #1
 8025b32:	e008      	b.n	8025b46 <fp_cmp_d+0x64>
  } else if (a->dp[0] < b) {
 8025b34:	687b      	ldr	r3, [r7, #4]
 8025b36:	68db      	ldr	r3, [r3, #12]
 8025b38:	683a      	ldr	r2, [r7, #0]
 8025b3a:	429a      	cmp	r2, r3
 8025b3c:	d902      	bls.n	8025b44 <fp_cmp_d+0x62>
    return FP_LT;
 8025b3e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025b42:	e000      	b.n	8025b46 <fp_cmp_d+0x64>
  } else {
    return FP_EQ;
 8025b44:	2300      	movs	r3, #0
  }

}
 8025b46:	4618      	mov	r0, r3
 8025b48:	370c      	adds	r7, #12
 8025b4a:	46bd      	mov	sp, r7
 8025b4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025b50:	4770      	bx	lr

08025b52 <fp_cmp_mag>:

int fp_cmp_mag(fp_int *a, fp_int *b)
{
 8025b52:	b480      	push	{r7}
 8025b54:	b085      	sub	sp, #20
 8025b56:	af00      	add	r7, sp, #0
 8025b58:	6078      	str	r0, [r7, #4]
 8025b5a:	6039      	str	r1, [r7, #0]
   int x;

   if (a->used > b->used) {
 8025b5c:	687b      	ldr	r3, [r7, #4]
 8025b5e:	681a      	ldr	r2, [r3, #0]
 8025b60:	683b      	ldr	r3, [r7, #0]
 8025b62:	681b      	ldr	r3, [r3, #0]
 8025b64:	429a      	cmp	r2, r3
 8025b66:	dd01      	ble.n	8025b6c <fp_cmp_mag+0x1a>
      return FP_GT;
 8025b68:	2301      	movs	r3, #1
 8025b6a:	e035      	b.n	8025bd8 <fp_cmp_mag+0x86>
   } else if (a->used < b->used) {
 8025b6c:	687b      	ldr	r3, [r7, #4]
 8025b6e:	681a      	ldr	r2, [r3, #0]
 8025b70:	683b      	ldr	r3, [r7, #0]
 8025b72:	681b      	ldr	r3, [r3, #0]
 8025b74:	429a      	cmp	r2, r3
 8025b76:	da02      	bge.n	8025b7e <fp_cmp_mag+0x2c>
      return FP_LT;
 8025b78:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025b7c:	e02c      	b.n	8025bd8 <fp_cmp_mag+0x86>
   } else {
      for (x = a->used - 1; x >= 0; x--) {
 8025b7e:	687b      	ldr	r3, [r7, #4]
 8025b80:	681b      	ldr	r3, [r3, #0]
 8025b82:	3b01      	subs	r3, #1
 8025b84:	60fb      	str	r3, [r7, #12]
 8025b86:	e023      	b.n	8025bd0 <fp_cmp_mag+0x7e>
          if (a->dp[x] > b->dp[x]) {
 8025b88:	687a      	ldr	r2, [r7, #4]
 8025b8a:	68fb      	ldr	r3, [r7, #12]
 8025b8c:	3302      	adds	r3, #2
 8025b8e:	009b      	lsls	r3, r3, #2
 8025b90:	4413      	add	r3, r2
 8025b92:	685a      	ldr	r2, [r3, #4]
 8025b94:	6839      	ldr	r1, [r7, #0]
 8025b96:	68fb      	ldr	r3, [r7, #12]
 8025b98:	3302      	adds	r3, #2
 8025b9a:	009b      	lsls	r3, r3, #2
 8025b9c:	440b      	add	r3, r1
 8025b9e:	685b      	ldr	r3, [r3, #4]
 8025ba0:	429a      	cmp	r2, r3
 8025ba2:	d901      	bls.n	8025ba8 <fp_cmp_mag+0x56>
             return FP_GT;
 8025ba4:	2301      	movs	r3, #1
 8025ba6:	e017      	b.n	8025bd8 <fp_cmp_mag+0x86>
          } else if (a->dp[x] < b->dp[x]) {
 8025ba8:	687a      	ldr	r2, [r7, #4]
 8025baa:	68fb      	ldr	r3, [r7, #12]
 8025bac:	3302      	adds	r3, #2
 8025bae:	009b      	lsls	r3, r3, #2
 8025bb0:	4413      	add	r3, r2
 8025bb2:	685a      	ldr	r2, [r3, #4]
 8025bb4:	6839      	ldr	r1, [r7, #0]
 8025bb6:	68fb      	ldr	r3, [r7, #12]
 8025bb8:	3302      	adds	r3, #2
 8025bba:	009b      	lsls	r3, r3, #2
 8025bbc:	440b      	add	r3, r1
 8025bbe:	685b      	ldr	r3, [r3, #4]
 8025bc0:	429a      	cmp	r2, r3
 8025bc2:	d202      	bcs.n	8025bca <fp_cmp_mag+0x78>
             return FP_LT;
 8025bc4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8025bc8:	e006      	b.n	8025bd8 <fp_cmp_mag+0x86>
      for (x = a->used - 1; x >= 0; x--) {
 8025bca:	68fb      	ldr	r3, [r7, #12]
 8025bcc:	3b01      	subs	r3, #1
 8025bce:	60fb      	str	r3, [r7, #12]
 8025bd0:	68fb      	ldr	r3, [r7, #12]
 8025bd2:	2b00      	cmp	r3, #0
 8025bd4:	dad8      	bge.n	8025b88 <fp_cmp_mag+0x36>
          }
      }
   }
   return FP_EQ;
 8025bd6:	2300      	movs	r3, #0
}
 8025bd8:	4618      	mov	r0, r3
 8025bda:	3714      	adds	r7, #20
 8025bdc:	46bd      	mov	sp, r7
 8025bde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025be2:	4770      	bx	lr

08025be4 <fp_montgomery_setup>:


/* sets up the montgomery reduction */
int fp_montgomery_setup(fp_int *a, fp_digit *rho)
{
 8025be4:	b480      	push	{r7}
 8025be6:	b085      	sub	sp, #20
 8025be8:	af00      	add	r7, sp, #0
 8025bea:	6078      	str	r0, [r7, #4]
 8025bec:	6039      	str	r1, [r7, #0]
 *
 * XA = 1 (mod 2**n)  =>  (X(2-XA)) A = 1 (mod 2**2n)
 *                    =>  2*X*A - X*X*A*A = 1
 *                    =>  2*(1) - (1)     = 1
 */
  b = a->dp[0];
 8025bee:	687b      	ldr	r3, [r7, #4]
 8025bf0:	68db      	ldr	r3, [r3, #12]
 8025bf2:	60fb      	str	r3, [r7, #12]

  if ((b & 1) == 0) {
 8025bf4:	68fb      	ldr	r3, [r7, #12]
 8025bf6:	f003 0301 	and.w	r3, r3, #1
 8025bfa:	2b00      	cmp	r3, #0
 8025bfc:	d102      	bne.n	8025c04 <fp_montgomery_setup+0x20>
    return FP_VAL;
 8025bfe:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025c02:	e02a      	b.n	8025c5a <fp_montgomery_setup+0x76>
  }

  x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
 8025c04:	68fb      	ldr	r3, [r7, #12]
 8025c06:	3302      	adds	r3, #2
 8025c08:	005b      	lsls	r3, r3, #1
 8025c0a:	f003 0308 	and.w	r3, r3, #8
 8025c0e:	68fa      	ldr	r2, [r7, #12]
 8025c10:	4413      	add	r3, r2
 8025c12:	60bb      	str	r3, [r7, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
 8025c14:	68fb      	ldr	r3, [r7, #12]
 8025c16:	68ba      	ldr	r2, [r7, #8]
 8025c18:	fb02 f303 	mul.w	r3, r2, r3
 8025c1c:	f1c3 0202 	rsb	r2, r3, #2
 8025c20:	68bb      	ldr	r3, [r7, #8]
 8025c22:	fb02 f303 	mul.w	r3, r2, r3
 8025c26:	60bb      	str	r3, [r7, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
 8025c28:	68fb      	ldr	r3, [r7, #12]
 8025c2a:	68ba      	ldr	r2, [r7, #8]
 8025c2c:	fb02 f303 	mul.w	r3, r2, r3
 8025c30:	f1c3 0202 	rsb	r2, r3, #2
 8025c34:	68bb      	ldr	r3, [r7, #8]
 8025c36:	fb02 f303 	mul.w	r3, r2, r3
 8025c3a:	60bb      	str	r3, [r7, #8]
  x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
 8025c3c:	68fb      	ldr	r3, [r7, #12]
 8025c3e:	68ba      	ldr	r2, [r7, #8]
 8025c40:	fb02 f303 	mul.w	r3, r2, r3
 8025c44:	f1c3 0202 	rsb	r2, r3, #2
 8025c48:	68bb      	ldr	r3, [r7, #8]
 8025c4a:	fb02 f303 	mul.w	r3, r2, r3
 8025c4e:	60bb      	str	r3, [r7, #8]
#ifdef FP_64BIT
  x *= 2 - b * x;               /* here x*a==1 mod 2**64 */
#endif

  /* rho = -1/m mod b */
  *rho = (fp_digit) (((fp_word) 1 << ((fp_word) DIGIT_BIT)) - ((fp_word)x));
 8025c50:	68bb      	ldr	r3, [r7, #8]
 8025c52:	425a      	negs	r2, r3
 8025c54:	683b      	ldr	r3, [r7, #0]
 8025c56:	601a      	str	r2, [r3, #0]

  return FP_OKAY;
 8025c58:	2300      	movs	r3, #0
}
 8025c5a:	4618      	mov	r0, r3
 8025c5c:	3714      	adds	r7, #20
 8025c5e:	46bd      	mov	sp, r7
 8025c60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025c64:	4770      	bx	lr

08025c66 <fp_montgomery_calc_normalization>:

/* computes a = B**n mod b without division or multiplication useful for
 * normalizing numbers in a Montgomery system.
 */
int fp_montgomery_calc_normalization(fp_int *a, fp_int *b)
{
 8025c66:	b580      	push	{r7, lr}
 8025c68:	b086      	sub	sp, #24
 8025c6a:	af00      	add	r7, sp, #0
 8025c6c:	6078      	str	r0, [r7, #4]
 8025c6e:	6039      	str	r1, [r7, #0]
  int     x, bits;

  /* how many bits of last digit does b use */
  bits = fp_count_bits (b) % DIGIT_BIT;
 8025c70:	6838      	ldr	r0, [r7, #0]
 8025c72:	f000 fb37 	bl	80262e4 <fp_count_bits>
 8025c76:	4603      	mov	r3, r0
 8025c78:	425a      	negs	r2, r3
 8025c7a:	f003 031f 	and.w	r3, r3, #31
 8025c7e:	f002 021f 	and.w	r2, r2, #31
 8025c82:	bf58      	it	pl
 8025c84:	4253      	negpl	r3, r2
 8025c86:	613b      	str	r3, [r7, #16]
  if (!bits) bits = DIGIT_BIT;
 8025c88:	693b      	ldr	r3, [r7, #16]
 8025c8a:	2b00      	cmp	r3, #0
 8025c8c:	d101      	bne.n	8025c92 <fp_montgomery_calc_normalization+0x2c>
 8025c8e:	2320      	movs	r3, #32
 8025c90:	613b      	str	r3, [r7, #16]

  /* compute A = B^(n-1) * 2^(bits-1) */
  if (b->used > 1) {
 8025c92:	683b      	ldr	r3, [r7, #0]
 8025c94:	681b      	ldr	r3, [r3, #0]
 8025c96:	2b01      	cmp	r3, #1
 8025c98:	dd0b      	ble.n	8025cb2 <fp_montgomery_calc_normalization+0x4c>
     fp_2expt (a, (b->used - 1) * DIGIT_BIT + bits - 1);
 8025c9a:	683b      	ldr	r3, [r7, #0]
 8025c9c:	681b      	ldr	r3, [r3, #0]
 8025c9e:	3b01      	subs	r3, #1
 8025ca0:	015a      	lsls	r2, r3, #5
 8025ca2:	693b      	ldr	r3, [r7, #16]
 8025ca4:	4413      	add	r3, r2
 8025ca6:	3b01      	subs	r3, #1
 8025ca8:	4619      	mov	r1, r3
 8025caa:	6878      	ldr	r0, [r7, #4]
 8025cac:	f7ff fc7b 	bl	80255a6 <fp_2expt>
 8025cb0:	e005      	b.n	8025cbe <fp_montgomery_calc_normalization+0x58>
  } else {
     fp_set(a, 1);
 8025cb2:	2101      	movs	r1, #1
 8025cb4:	6878      	ldr	r0, [r7, #4]
 8025cb6:	f000 fad2 	bl	802625e <fp_set>
     bits = 1;
 8025cba:	2301      	movs	r3, #1
 8025cbc:	613b      	str	r3, [r7, #16]
  }

  /* now compute C = A * B mod b */
  for (x = bits - 1; x < (int)DIGIT_BIT; x++) {
 8025cbe:	693b      	ldr	r3, [r7, #16]
 8025cc0:	3b01      	subs	r3, #1
 8025cc2:	617b      	str	r3, [r7, #20]
 8025cc4:	e019      	b.n	8025cfa <fp_montgomery_calc_normalization+0x94>
    int err = fp_mul_2 (a, a);
 8025cc6:	6879      	ldr	r1, [r7, #4]
 8025cc8:	6878      	ldr	r0, [r7, #4]
 8025cca:	f7fc fd32 	bl	8022732 <fp_mul_2>
 8025cce:	60f8      	str	r0, [r7, #12]
    if (err != FP_OKAY) {
 8025cd0:	68fb      	ldr	r3, [r7, #12]
 8025cd2:	2b00      	cmp	r3, #0
 8025cd4:	d001      	beq.n	8025cda <fp_montgomery_calc_normalization+0x74>
      return err;
 8025cd6:	68fb      	ldr	r3, [r7, #12]
 8025cd8:	e013      	b.n	8025d02 <fp_montgomery_calc_normalization+0x9c>
    }
    if (fp_cmp_mag (a, b) != FP_LT) {
 8025cda:	6839      	ldr	r1, [r7, #0]
 8025cdc:	6878      	ldr	r0, [r7, #4]
 8025cde:	f7ff ff38 	bl	8025b52 <fp_cmp_mag>
 8025ce2:	4603      	mov	r3, r0
 8025ce4:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8025ce8:	d004      	beq.n	8025cf4 <fp_montgomery_calc_normalization+0x8e>
      s_fp_sub (a, b, a);
 8025cea:	687a      	ldr	r2, [r7, #4]
 8025cec:	6839      	ldr	r1, [r7, #0]
 8025cee:	6878      	ldr	r0, [r7, #4]
 8025cf0:	f7fc fc17 	bl	8022522 <s_fp_sub>
  for (x = bits - 1; x < (int)DIGIT_BIT; x++) {
 8025cf4:	697b      	ldr	r3, [r7, #20]
 8025cf6:	3301      	adds	r3, #1
 8025cf8:	617b      	str	r3, [r7, #20]
 8025cfa:	697b      	ldr	r3, [r7, #20]
 8025cfc:	2b1f      	cmp	r3, #31
 8025cfe:	dde2      	ble.n	8025cc6 <fp_montgomery_calc_normalization+0x60>
    }
  }
  return FP_OKAY;
 8025d00:	2300      	movs	r3, #0
}
 8025d02:	4618      	mov	r0, r3
 8025d04:	3718      	adds	r7, #24
 8025d06:	46bd      	mov	sp, r7
 8025d08:	bd80      	pop	{r7, pc}

08025d0a <fp_montgomery_reduce_ex>:
}
#endif

/* computes x/R == x (mod N) via Montgomery Reduction */
int fp_montgomery_reduce_ex(fp_int *a, fp_int *m, fp_digit mp, int ct)
{
 8025d0a:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8025d0e:	b09a      	sub	sp, #104	@ 0x68
 8025d10:	af00      	add	r7, sp, #0
 8025d12:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8025d14:	62b9      	str	r1, [r7, #40]	@ 0x28
 8025d16:	627a      	str	r2, [r7, #36]	@ 0x24
 8025d18:	623b      	str	r3, [r7, #32]
#ifndef WOLFSSL_SMALL_STACK
   fp_digit c[FP_SIZE+1];
#else
   fp_digit *c;
#endif
   fp_digit *_c, *tmpm, mu = 0;
 8025d1a:	2300      	movs	r3, #0
 8025d1c:	64fb      	str	r3, [r7, #76]	@ 0x4c
   int      oldused, x, y, pa, err = 0;
 8025d1e:	2300      	movs	r3, #0
 8025d20:	64bb      	str	r3, [r7, #72]	@ 0x48

   IF_HAVE_INTEL_MULX(err=fp_montgomery_reduce_mulx(a, m, mp, ct), return err) ;
   (void)err;

   /* bail if too large */
   if (m->used > (FP_SIZE/2)) {
 8025d22:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025d24:	681b      	ldr	r3, [r3, #0]
 8025d26:	2b44      	cmp	r3, #68	@ 0x44
 8025d28:	dd02      	ble.n	8025d30 <fp_montgomery_reduce_ex+0x26>
      (void)mu;                     /* shut up compiler */
      return FP_VAL;
 8025d2a:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025d2e:	e11b      	b.n	8025f68 <fp_montgomery_reduce_ex+0x25e>
   }
#endif

#ifdef WOLFSSL_SMALL_STACK
   /* only allocate space for what's needed for window plus res */
   c = (fp_digit*)XMALLOC(sizeof(fp_digit)*(FP_SIZE + 1), NULL, DYNAMIC_TYPE_BIGINT);
 8025d30:	f44f 7009 	mov.w	r0, #548	@ 0x224
 8025d34:	f7f8 feae 	bl	801ea94 <wolfSSL_Malloc>
 8025d38:	6478      	str	r0, [r7, #68]	@ 0x44
   if (c == NULL) {
 8025d3a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025d3c:	2b00      	cmp	r3, #0
 8025d3e:	d102      	bne.n	8025d46 <fp_montgomery_reduce_ex+0x3c>
      return FP_MEM;
 8025d40:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8025d44:	e110      	b.n	8025f68 <fp_montgomery_reduce_ex+0x25e>
   }
#endif

   /* now zero the buff */
   XMEMSET(c, 0, sizeof(fp_digit)*(FP_SIZE + 1));
 8025d46:	f44f 7209 	mov.w	r2, #548	@ 0x224
 8025d4a:	2100      	movs	r1, #0
 8025d4c:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8025d4e:	f002 fbbf 	bl	80284d0 <memset>
   pa = m->used;
 8025d52:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025d54:	681b      	ldr	r3, [r3, #0]
 8025d56:	643b      	str	r3, [r7, #64]	@ 0x40

   /* copy the input */
#ifdef TFM_TIMING_RESISTANT
   if (a->used <= m->used) {
 8025d58:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025d5a:	681a      	ldr	r2, [r3, #0]
 8025d5c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025d5e:	681b      	ldr	r3, [r3, #0]
 8025d60:	429a      	cmp	r2, r3
 8025d62:	dc03      	bgt.n	8025d6c <fp_montgomery_reduce_ex+0x62>
      oldused = m->used;
 8025d64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025d66:	681b      	ldr	r3, [r3, #0]
 8025d68:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8025d6a:	e003      	b.n	8025d74 <fp_montgomery_reduce_ex+0x6a>
   }
   else {
      oldused = m->used * 2;
 8025d6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025d6e:	681b      	ldr	r3, [r3, #0]
 8025d70:	005b      	lsls	r3, r3, #1
 8025d72:	65fb      	str	r3, [r7, #92]	@ 0x5c
   }
#else
   oldused = a->used;
#endif
   for (x = 0; x < oldused; x++) {
 8025d74:	2300      	movs	r3, #0
 8025d76:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025d78:	e00d      	b.n	8025d96 <fp_montgomery_reduce_ex+0x8c>
       c[x] = a->dp[x];
 8025d7a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025d7c:	009a      	lsls	r2, r3, #2
 8025d7e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025d80:	1899      	adds	r1, r3, r2
 8025d82:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8025d84:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025d86:	3302      	adds	r3, #2
 8025d88:	009b      	lsls	r3, r3, #2
 8025d8a:	4413      	add	r3, r2
 8025d8c:	685b      	ldr	r3, [r3, #4]
 8025d8e:	600b      	str	r3, [r1, #0]
   for (x = 0; x < oldused; x++) {
 8025d90:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025d92:	3301      	adds	r3, #1
 8025d94:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025d96:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8025d98:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8025d9a:	429a      	cmp	r2, r3
 8025d9c:	dbed      	blt.n	8025d7a <fp_montgomery_reduce_ex+0x70>
   }
   MONT_START;

   for (x = 0; x < pa; x++) {
 8025d9e:	2300      	movs	r3, #0
 8025da0:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025da2:	e07d      	b.n	8025ea0 <fp_montgomery_reduce_ex+0x196>
       fp_digit cy = 0;
 8025da4:	2300      	movs	r3, #0
 8025da6:	653b      	str	r3, [r7, #80]	@ 0x50
       /* get Mu for this round */
       LOOP_START;
 8025da8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025daa:	009a      	lsls	r2, r3, #2
 8025dac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025dae:	4413      	add	r3, r2
 8025db0:	681a      	ldr	r2, [r3, #0]
 8025db2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8025db4:	fb02 f303 	mul.w	r3, r2, r3
 8025db8:	64fb      	str	r3, [r7, #76]	@ 0x4c
       _c   = c + x;
 8025dba:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025dbc:	009a      	lsls	r2, r3, #2
 8025dbe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025dc0:	4413      	add	r3, r2
 8025dc2:	667b      	str	r3, [r7, #100]	@ 0x64
       tmpm = m->dp;
 8025dc4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8025dc6:	330c      	adds	r3, #12
 8025dc8:	663b      	str	r3, [r7, #96]	@ 0x60
       y = 0;
 8025dca:	2300      	movs	r3, #0
 8025dcc:	657b      	str	r3, [r7, #84]	@ 0x54
              INNERMUL8 ;
              _c   += 8;
              tmpm += 8;
           }
#endif
       for (; y < pa; y++) {
 8025dce:	e048      	b.n	8025e62 <fp_montgomery_reduce_ex+0x158>
          INNERMUL;
 8025dd0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025dd2:	681b      	ldr	r3, [r3, #0]
 8025dd4:	2200      	movs	r2, #0
 8025dd6:	61bb      	str	r3, [r7, #24]
 8025dd8:	61fa      	str	r2, [r7, #28]
 8025dda:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8025ddc:	2200      	movs	r2, #0
 8025dde:	613b      	str	r3, [r7, #16]
 8025de0:	617a      	str	r2, [r7, #20]
 8025de2:	69bb      	ldr	r3, [r7, #24]
 8025de4:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8025de8:	4602      	mov	r2, r0
 8025dea:	eb13 0802 	adds.w	r8, r3, r2
 8025dee:	69fb      	ldr	r3, [r7, #28]
 8025df0:	460a      	mov	r2, r1
 8025df2:	eb43 0902 	adc.w	r9, r3, r2
 8025df6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8025df8:	2200      	movs	r2, #0
 8025dfa:	469a      	mov	sl, r3
 8025dfc:	4693      	mov	fp, r2
 8025dfe:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8025e00:	1d13      	adds	r3, r2, #4
 8025e02:	663b      	str	r3, [r7, #96]	@ 0x60
 8025e04:	6813      	ldr	r3, [r2, #0]
 8025e06:	2200      	movs	r2, #0
 8025e08:	60bb      	str	r3, [r7, #8]
 8025e0a:	60fa      	str	r2, [r7, #12]
 8025e0c:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8025e10:	4603      	mov	r3, r0
 8025e12:	fb03 f20b 	mul.w	r2, r3, fp
 8025e16:	460b      	mov	r3, r1
 8025e18:	fb0a f303 	mul.w	r3, sl, r3
 8025e1c:	4413      	add	r3, r2
 8025e1e:	4602      	mov	r2, r0
 8025e20:	fbaa 4502 	umull	r4, r5, sl, r2
 8025e24:	442b      	add	r3, r5
 8025e26:	461d      	mov	r5, r3
 8025e28:	eb18 0304 	adds.w	r3, r8, r4
 8025e2c:	603b      	str	r3, [r7, #0]
 8025e2e:	eb49 0305 	adc.w	r3, r9, r5
 8025e32:	607b      	str	r3, [r7, #4]
 8025e34:	e9d7 2300 	ldrd	r2, r3, [r7]
 8025e38:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
 8025e3c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8025e3e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e40:	601a      	str	r2, [r3, #0]
 8025e42:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8025e46:	f04f 0000 	mov.w	r0, #0
 8025e4a:	f04f 0100 	mov.w	r1, #0
 8025e4e:	0018      	movs	r0, r3
 8025e50:	2100      	movs	r1, #0
 8025e52:	4603      	mov	r3, r0
 8025e54:	653b      	str	r3, [r7, #80]	@ 0x50
          ++_c;
 8025e56:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e58:	3304      	adds	r3, #4
 8025e5a:	667b      	str	r3, [r7, #100]	@ 0x64
       for (; y < pa; y++) {
 8025e5c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8025e5e:	3301      	adds	r3, #1
 8025e60:	657b      	str	r3, [r7, #84]	@ 0x54
 8025e62:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8025e64:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025e66:	429a      	cmp	r2, r3
 8025e68:	dbb2      	blt.n	8025dd0 <fp_montgomery_reduce_ex+0xc6>
       }
       LOOP_END;
       while (cy) { /* //NOLINT(bugprone-infinite-loop) */ /* PROPCARRY is an asm macro */
 8025e6a:	e013      	b.n	8025e94 <fp_montgomery_reduce_ex+0x18a>
           PROPCARRY;
 8025e6c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e6e:	681a      	ldr	r2, [r3, #0]
 8025e70:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8025e72:	441a      	add	r2, r3
 8025e74:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e76:	601a      	str	r2, [r3, #0]
 8025e78:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e7a:	681b      	ldr	r3, [r3, #0]
 8025e7c:	63bb      	str	r3, [r7, #56]	@ 0x38
 8025e7e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8025e80:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8025e82:	429a      	cmp	r2, r3
 8025e84:	bf34      	ite	cc
 8025e86:	2301      	movcc	r3, #1
 8025e88:	2300      	movcs	r3, #0
 8025e8a:	b2db      	uxtb	r3, r3
 8025e8c:	653b      	str	r3, [r7, #80]	@ 0x50
           ++_c;
 8025e8e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8025e90:	3304      	adds	r3, #4
 8025e92:	667b      	str	r3, [r7, #100]	@ 0x64
       while (cy) { /* //NOLINT(bugprone-infinite-loop) */ /* PROPCARRY is an asm macro */
 8025e94:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8025e96:	2b00      	cmp	r3, #0
 8025e98:	d1e8      	bne.n	8025e6c <fp_montgomery_reduce_ex+0x162>
   for (x = 0; x < pa; x++) {
 8025e9a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025e9c:	3301      	adds	r3, #1
 8025e9e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025ea0:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8025ea2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025ea4:	429a      	cmp	r2, r3
 8025ea6:	f6ff af7d 	blt.w	8025da4 <fp_montgomery_reduce_ex+0x9a>
       }
  }

  /* now copy out */
  _c   = c + pa;
 8025eaa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025eac:	009b      	lsls	r3, r3, #2
 8025eae:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8025eb0:	4413      	add	r3, r2
 8025eb2:	667b      	str	r3, [r7, #100]	@ 0x64
  tmpm = a->dp;
 8025eb4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025eb6:	330c      	adds	r3, #12
 8025eb8:	663b      	str	r3, [r7, #96]	@ 0x60
  for (x = 0; x < pa+1; x++) {
 8025eba:	2300      	movs	r3, #0
 8025ebc:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025ebe:	e00a      	b.n	8025ed6 <fp_montgomery_reduce_ex+0x1cc>
     *tmpm++ = *_c++;
 8025ec0:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8025ec2:	1d13      	adds	r3, r2, #4
 8025ec4:	667b      	str	r3, [r7, #100]	@ 0x64
 8025ec6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8025ec8:	1d19      	adds	r1, r3, #4
 8025eca:	6639      	str	r1, [r7, #96]	@ 0x60
 8025ecc:	6812      	ldr	r2, [r2, #0]
 8025ece:	601a      	str	r2, [r3, #0]
  for (x = 0; x < pa+1; x++) {
 8025ed0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025ed2:	3301      	adds	r3, #1
 8025ed4:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025ed6:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8025ed8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025eda:	429a      	cmp	r2, r3
 8025edc:	daf0      	bge.n	8025ec0 <fp_montgomery_reduce_ex+0x1b6>
  }

  /* zero any excess digits on the destination that we didn't write to */
  for (; x < oldused; x++) {
 8025ede:	e007      	b.n	8025ef0 <fp_montgomery_reduce_ex+0x1e6>
     *tmpm++ = 0;
 8025ee0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8025ee2:	1d1a      	adds	r2, r3, #4
 8025ee4:	663a      	str	r2, [r7, #96]	@ 0x60
 8025ee6:	2200      	movs	r2, #0
 8025ee8:	601a      	str	r2, [r3, #0]
  for (; x < oldused; x++) {
 8025eea:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8025eec:	3301      	adds	r3, #1
 8025eee:	65bb      	str	r3, [r7, #88]	@ 0x58
 8025ef0:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8025ef2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8025ef4:	429a      	cmp	r2, r3
 8025ef6:	dbf3      	blt.n	8025ee0 <fp_montgomery_reduce_ex+0x1d6>
  }

  MONT_FINI;

  a->used = pa+1;
 8025ef8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8025efa:	1c5a      	adds	r2, r3, #1
 8025efc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025efe:	601a      	str	r2, [r3, #0]
  fp_clamp(a);
 8025f00:	e004      	b.n	8025f0c <fp_montgomery_reduce_ex+0x202>
 8025f02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025f04:	681b      	ldr	r3, [r3, #0]
 8025f06:	1e5a      	subs	r2, r3, #1
 8025f08:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025f0a:	601a      	str	r2, [r3, #0]
 8025f0c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025f0e:	681b      	ldr	r3, [r3, #0]
 8025f10:	2b00      	cmp	r3, #0
 8025f12:	d009      	beq.n	8025f28 <fp_montgomery_reduce_ex+0x21e>
 8025f14:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025f16:	681b      	ldr	r3, [r3, #0]
 8025f18:	3b01      	subs	r3, #1
 8025f1a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8025f1c:	3302      	adds	r3, #2
 8025f1e:	009b      	lsls	r3, r3, #2
 8025f20:	4413      	add	r3, r2
 8025f22:	685b      	ldr	r3, [r3, #4]
 8025f24:	2b00      	cmp	r3, #0
 8025f26:	d0ec      	beq.n	8025f02 <fp_montgomery_reduce_ex+0x1f8>
 8025f28:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025f2a:	681b      	ldr	r3, [r3, #0]
 8025f2c:	2b00      	cmp	r3, #0
 8025f2e:	d002      	beq.n	8025f36 <fp_montgomery_reduce_ex+0x22c>
 8025f30:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025f32:	685b      	ldr	r3, [r3, #4]
 8025f34:	e000      	b.n	8025f38 <fp_montgomery_reduce_ex+0x22e>
 8025f36:	2300      	movs	r3, #0
 8025f38:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8025f3a:	6053      	str	r3, [r2, #4]

#ifndef WOLFSSL_MONT_RED_CT
  /* if A >= m then A = A - m */
  if (fp_cmp_mag (a, m) != FP_LT) {
 8025f3c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8025f3e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8025f40:	f7ff fe07 	bl	8025b52 <fp_cmp_mag>
 8025f44:	4603      	mov	r3, r0
 8025f46:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8025f4a:	d004      	beq.n	8025f56 <fp_montgomery_reduce_ex+0x24c>
    s_fp_sub (a, m, a);
 8025f4c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8025f4e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8025f50:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8025f52:	f7fc fae6 	bl	8022522 <s_fp_sub>
    s_fp_sub (a, m, a);
  }
#endif

#ifdef WOLFSSL_SMALL_STACK
  XFREE(c, NULL, DYNAMIC_TYPE_BIGINT);
 8025f56:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8025f58:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8025f5a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8025f5c:	2b00      	cmp	r3, #0
 8025f5e:	d002      	beq.n	8025f66 <fp_montgomery_reduce_ex+0x25c>
 8025f60:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8025f62:	f7f8 fdb3 	bl	801eacc <wolfSSL_Free>
#endif
  return FP_OKAY;
 8025f66:	2300      	movs	r3, #0
}
 8025f68:	4618      	mov	r0, r3
 8025f6a:	3768      	adds	r7, #104	@ 0x68
 8025f6c:	46bd      	mov	sp, r7
 8025f6e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08025f72 <fp_montgomery_reduce>:

int fp_montgomery_reduce(fp_int *a, fp_int *m, fp_digit mp)
{
 8025f72:	b580      	push	{r7, lr}
 8025f74:	b084      	sub	sp, #16
 8025f76:	af00      	add	r7, sp, #0
 8025f78:	60f8      	str	r0, [r7, #12]
 8025f7a:	60b9      	str	r1, [r7, #8]
 8025f7c:	607a      	str	r2, [r7, #4]
  return fp_montgomery_reduce_ex(a, m, mp, 1);
 8025f7e:	2301      	movs	r3, #1
 8025f80:	687a      	ldr	r2, [r7, #4]
 8025f82:	68b9      	ldr	r1, [r7, #8]
 8025f84:	68f8      	ldr	r0, [r7, #12]
 8025f86:	f7ff fec0 	bl	8025d0a <fp_montgomery_reduce_ex>
 8025f8a:	4603      	mov	r3, r0
}
 8025f8c:	4618      	mov	r0, r3
 8025f8e:	3710      	adds	r7, #16
 8025f90:	46bd      	mov	sp, r7
 8025f92:	bd80      	pop	{r7, pc}

08025f94 <fp_read_unsigned_bin>:

int fp_read_unsigned_bin(fp_int *a, const unsigned char *b, int c)
{
 8025f94:	b580      	push	{r7, lr}
 8025f96:	b088      	sub	sp, #32
 8025f98:	af00      	add	r7, sp, #0
 8025f9a:	60f8      	str	r0, [r7, #12]
 8025f9c:	60b9      	str	r1, [r7, #8]
 8025f9e:	607a      	str	r2, [r7, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
  const word32 maxC = (a->size * sizeof(fp_digit));
 8025fa0:	68fb      	ldr	r3, [r7, #12]
 8025fa2:	689b      	ldr	r3, [r3, #8]
 8025fa4:	009b      	lsls	r3, r3, #2
 8025fa6:	61fb      	str	r3, [r7, #28]
#else
  const word32 maxC = (FP_SIZE * sizeof(fp_digit));
#endif

  /* zero the int */
  fp_zero (a);
 8025fa8:	68f8      	ldr	r0, [r7, #12]
 8025faa:	f000 fb95 	bl	80266d8 <fp_zero>

  if (c < 0) {
 8025fae:	687b      	ldr	r3, [r7, #4]
 8025fb0:	2b00      	cmp	r3, #0
 8025fb2:	da02      	bge.n	8025fba <fp_read_unsigned_bin+0x26>
      return FP_VAL;
 8025fb4:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8025fb8:	e04e      	b.n	8026058 <fp_read_unsigned_bin+0xc4>
  }

  if (c == 0) {
 8025fba:	687b      	ldr	r3, [r7, #4]
 8025fbc:	2b00      	cmp	r3, #0
 8025fbe:	d101      	bne.n	8025fc4 <fp_read_unsigned_bin+0x30>
      return FP_OKAY;
 8025fc0:	2300      	movs	r3, #0
 8025fc2:	e049      	b.n	8026058 <fp_read_unsigned_bin+0xc4>
  }

  /* if input b excess max, then truncate */
  if ((word32)c > maxC) {
 8025fc4:	687b      	ldr	r3, [r7, #4]
 8025fc6:	69fa      	ldr	r2, [r7, #28]
 8025fc8:	429a      	cmp	r2, r3
 8025fca:	d20b      	bcs.n	8025fe4 <fp_read_unsigned_bin+0x50>
     int excess = (c - maxC);
 8025fcc:	687a      	ldr	r2, [r7, #4]
 8025fce:	69fb      	ldr	r3, [r7, #28]
 8025fd0:	1ad3      	subs	r3, r2, r3
 8025fd2:	61bb      	str	r3, [r7, #24]
     c -= excess;
 8025fd4:	687a      	ldr	r2, [r7, #4]
 8025fd6:	69bb      	ldr	r3, [r7, #24]
 8025fd8:	1ad3      	subs	r3, r2, r3
 8025fda:	607b      	str	r3, [r7, #4]
     b += excess;
 8025fdc:	69bb      	ldr	r3, [r7, #24]
 8025fde:	68ba      	ldr	r2, [r7, #8]
 8025fe0:	4413      	add	r3, r2
 8025fe2:	60bb      	str	r3, [r7, #8]
    (defined(FP_32BIT) || defined(FP_64BIT))
#ifdef FP_32BIT
  /* If we know the endianness of this architecture, and we're using
     32-bit fp_digits, we can optimize this */
  {
     unsigned char *pd = (unsigned char *)a->dp;
 8025fe4:	68fb      	ldr	r3, [r7, #12]
 8025fe6:	330c      	adds	r3, #12
 8025fe8:	617b      	str	r3, [r7, #20]

     a->used = (c + sizeof(fp_digit) - 1)/sizeof(fp_digit);
 8025fea:	687b      	ldr	r3, [r7, #4]
 8025fec:	3303      	adds	r3, #3
 8025fee:	089b      	lsrs	r3, r3, #2
 8025ff0:	461a      	mov	r2, r3
 8025ff2:	68fb      	ldr	r3, [r7, #12]
 8025ff4:	601a      	str	r2, [r3, #0]
                 } while ((c -= 4) > 0);
       }
     }
#else
     /* read the bytes in one at a time. */
     for (c -= 1; c >= 0; c -= 1) {
 8025ff6:	687b      	ldr	r3, [r7, #4]
 8025ff8:	3b01      	subs	r3, #1
 8025ffa:	607b      	str	r3, [r7, #4]
 8025ffc:	e00a      	b.n	8026014 <fp_read_unsigned_bin+0x80>
       pd[c] = *b++;
 8025ffe:	68bb      	ldr	r3, [r7, #8]
 8026000:	1c5a      	adds	r2, r3, #1
 8026002:	60ba      	str	r2, [r7, #8]
 8026004:	687a      	ldr	r2, [r7, #4]
 8026006:	6979      	ldr	r1, [r7, #20]
 8026008:	440a      	add	r2, r1
 802600a:	781b      	ldrb	r3, [r3, #0]
 802600c:	7013      	strb	r3, [r2, #0]
     for (c -= 1; c >= 0; c -= 1) {
 802600e:	687b      	ldr	r3, [r7, #4]
 8026010:	3b01      	subs	r3, #1
 8026012:	607b      	str	r3, [r7, #4]
 8026014:	687b      	ldr	r3, [r7, #4]
 8026016:	2b00      	cmp	r3, #0
 8026018:	daf1      	bge.n	8025ffe <fp_read_unsigned_bin+0x6a>
     if (a->used == 0) {
         a->used = 1;
     }
  }
#endif
  fp_clamp (a);
 802601a:	e004      	b.n	8026026 <fp_read_unsigned_bin+0x92>
 802601c:	68fb      	ldr	r3, [r7, #12]
 802601e:	681b      	ldr	r3, [r3, #0]
 8026020:	1e5a      	subs	r2, r3, #1
 8026022:	68fb      	ldr	r3, [r7, #12]
 8026024:	601a      	str	r2, [r3, #0]
 8026026:	68fb      	ldr	r3, [r7, #12]
 8026028:	681b      	ldr	r3, [r3, #0]
 802602a:	2b00      	cmp	r3, #0
 802602c:	d009      	beq.n	8026042 <fp_read_unsigned_bin+0xae>
 802602e:	68fb      	ldr	r3, [r7, #12]
 8026030:	681b      	ldr	r3, [r3, #0]
 8026032:	3b01      	subs	r3, #1
 8026034:	68fa      	ldr	r2, [r7, #12]
 8026036:	3302      	adds	r3, #2
 8026038:	009b      	lsls	r3, r3, #2
 802603a:	4413      	add	r3, r2
 802603c:	685b      	ldr	r3, [r3, #4]
 802603e:	2b00      	cmp	r3, #0
 8026040:	d0ec      	beq.n	802601c <fp_read_unsigned_bin+0x88>
 8026042:	68fb      	ldr	r3, [r7, #12]
 8026044:	681b      	ldr	r3, [r3, #0]
 8026046:	2b00      	cmp	r3, #0
 8026048:	d002      	beq.n	8026050 <fp_read_unsigned_bin+0xbc>
 802604a:	68fb      	ldr	r3, [r7, #12]
 802604c:	685b      	ldr	r3, [r3, #4]
 802604e:	e000      	b.n	8026052 <fp_read_unsigned_bin+0xbe>
 8026050:	2300      	movs	r3, #0
 8026052:	68fa      	ldr	r2, [r7, #12]
 8026054:	6053      	str	r3, [r2, #4]

  return FP_OKAY;
 8026056:	2300      	movs	r3, #0
}
 8026058:	4618      	mov	r0, r3
 802605a:	3720      	adds	r7, #32
 802605c:	46bd      	mov	sp, r7
 802605e:	bd80      	pop	{r7, pc}

08026060 <fp_to_unsigned_bin_at_pos>:

int fp_to_unsigned_bin_at_pos(int x, fp_int *t, unsigned char *b)
{
 8026060:	b480      	push	{r7}
 8026062:	b089      	sub	sp, #36	@ 0x24
 8026064:	af00      	add	r7, sp, #0
 8026066:	60f8      	str	r0, [r7, #12]
 8026068:	60b9      	str	r1, [r7, #8]
 802606a:	607a      	str	r2, [r7, #4]
#if DIGIT_BIT == 64 || DIGIT_BIT == 32
   int i;
   int j = 0;
 802606c:	2300      	movs	r3, #0
 802606e:	61bb      	str	r3, [r7, #24]
   fp_digit n;

   for (i = 0; i < t->used-1; ) {
 8026070:	2300      	movs	r3, #0
 8026072:	61fb      	str	r3, [r7, #28]
 8026074:	e021      	b.n	80260ba <fp_to_unsigned_bin_at_pos+0x5a>
       b[x++] = (unsigned char)(t->dp[i] >> j);
 8026076:	68ba      	ldr	r2, [r7, #8]
 8026078:	69fb      	ldr	r3, [r7, #28]
 802607a:	3302      	adds	r3, #2
 802607c:	009b      	lsls	r3, r3, #2
 802607e:	4413      	add	r3, r2
 8026080:	685a      	ldr	r2, [r3, #4]
 8026082:	69bb      	ldr	r3, [r7, #24]
 8026084:	fa22 f103 	lsr.w	r1, r2, r3
 8026088:	68fb      	ldr	r3, [r7, #12]
 802608a:	1c5a      	adds	r2, r3, #1
 802608c:	60fa      	str	r2, [r7, #12]
 802608e:	461a      	mov	r2, r3
 8026090:	687b      	ldr	r3, [r7, #4]
 8026092:	4413      	add	r3, r2
 8026094:	b2ca      	uxtb	r2, r1
 8026096:	701a      	strb	r2, [r3, #0]
       j += 8;
 8026098:	69bb      	ldr	r3, [r7, #24]
 802609a:	3308      	adds	r3, #8
 802609c:	61bb      	str	r3, [r7, #24]
       i += j == DIGIT_BIT;
 802609e:	69bb      	ldr	r3, [r7, #24]
 80260a0:	2b20      	cmp	r3, #32
 80260a2:	bf0c      	ite	eq
 80260a4:	2301      	moveq	r3, #1
 80260a6:	2300      	movne	r3, #0
 80260a8:	b2db      	uxtb	r3, r3
 80260aa:	461a      	mov	r2, r3
 80260ac:	69fb      	ldr	r3, [r7, #28]
 80260ae:	4413      	add	r3, r2
 80260b0:	61fb      	str	r3, [r7, #28]
       j &= DIGIT_BIT - 1;
 80260b2:	69bb      	ldr	r3, [r7, #24]
 80260b4:	f003 031f 	and.w	r3, r3, #31
 80260b8:	61bb      	str	r3, [r7, #24]
   for (i = 0; i < t->used-1; ) {
 80260ba:	68bb      	ldr	r3, [r7, #8]
 80260bc:	681b      	ldr	r3, [r3, #0]
 80260be:	3b01      	subs	r3, #1
 80260c0:	69fa      	ldr	r2, [r7, #28]
 80260c2:	429a      	cmp	r2, r3
 80260c4:	dbd7      	blt.n	8026076 <fp_to_unsigned_bin_at_pos+0x16>
   }
   n = t->dp[i];
 80260c6:	68ba      	ldr	r2, [r7, #8]
 80260c8:	69fb      	ldr	r3, [r7, #28]
 80260ca:	3302      	adds	r3, #2
 80260cc:	009b      	lsls	r3, r3, #2
 80260ce:	4413      	add	r3, r2
 80260d0:	685b      	ldr	r3, [r3, #4]
 80260d2:	617b      	str	r3, [r7, #20]
   while (n != 0) {
 80260d4:	e00b      	b.n	80260ee <fp_to_unsigned_bin_at_pos+0x8e>
       b[x++] = (unsigned char)n;
 80260d6:	68fb      	ldr	r3, [r7, #12]
 80260d8:	1c5a      	adds	r2, r3, #1
 80260da:	60fa      	str	r2, [r7, #12]
 80260dc:	461a      	mov	r2, r3
 80260de:	687b      	ldr	r3, [r7, #4]
 80260e0:	4413      	add	r3, r2
 80260e2:	697a      	ldr	r2, [r7, #20]
 80260e4:	b2d2      	uxtb	r2, r2
 80260e6:	701a      	strb	r2, [r3, #0]
       n >>= 8;
 80260e8:	697b      	ldr	r3, [r7, #20]
 80260ea:	0a1b      	lsrs	r3, r3, #8
 80260ec:	617b      	str	r3, [r7, #20]
   while (n != 0) {
 80260ee:	697b      	ldr	r3, [r7, #20]
 80260f0:	2b00      	cmp	r3, #0
 80260f2:	d1f0      	bne.n	80260d6 <fp_to_unsigned_bin_at_pos+0x76>
   }
   return x;
 80260f4:	68fb      	ldr	r3, [r7, #12]
      b[x++] = (unsigned char) (t->dp[0] & 255);
      fp_div_2d (t, 8, t, NULL);
  }
  return x;
#endif
}
 80260f6:	4618      	mov	r0, r3
 80260f8:	3724      	adds	r7, #36	@ 0x24
 80260fa:	46bd      	mov	sp, r7
 80260fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026100:	4770      	bx	lr

08026102 <fp_to_unsigned_bin>:

int fp_to_unsigned_bin(fp_int *a, unsigned char *b)
{
 8026102:	b580      	push	{r7, lr}
 8026104:	b086      	sub	sp, #24
 8026106:	af00      	add	r7, sp, #0
 8026108:	6078      	str	r0, [r7, #4]
 802610a:	6039      	str	r1, [r7, #0]
#else
   fp_int *t;
#endif

#ifdef WOLFSSL_SMALL_STACK
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 802610c:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8026110:	f7f8 fcc0 	bl	801ea94 <wolfSSL_Malloc>
 8026114:	6178      	str	r0, [r7, #20]
   if (t == NULL)
 8026116:	697b      	ldr	r3, [r7, #20]
 8026118:	2b00      	cmp	r3, #0
 802611a:	d102      	bne.n	8026122 <fp_to_unsigned_bin+0x20>
       return FP_MEM;
 802611c:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8026120:	e016      	b.n	8026150 <fp_to_unsigned_bin+0x4e>
#endif

  fp_init_copy(t, a);
 8026122:	6879      	ldr	r1, [r7, #4]
 8026124:	6978      	ldr	r0, [r7, #20]
 8026126:	f000 fcf2 	bl	8026b0e <fp_init_copy>

  x = fp_to_unsigned_bin_at_pos(0, t, b);
 802612a:	683a      	ldr	r2, [r7, #0]
 802612c:	6979      	ldr	r1, [r7, #20]
 802612e:	2000      	movs	r0, #0
 8026130:	f7ff ff96 	bl	8026060 <fp_to_unsigned_bin_at_pos>
 8026134:	6138      	str	r0, [r7, #16]
  mp_reverse (b, x);
 8026136:	6939      	ldr	r1, [r7, #16]
 8026138:	6838      	ldr	r0, [r7, #0]
 802613a:	f001 f983 	bl	8027444 <mp_reverse>

#ifdef WOLFSSL_SMALL_STACK
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 802613e:	697b      	ldr	r3, [r7, #20]
 8026140:	60fb      	str	r3, [r7, #12]
 8026142:	68fb      	ldr	r3, [r7, #12]
 8026144:	2b00      	cmp	r3, #0
 8026146:	d002      	beq.n	802614e <fp_to_unsigned_bin+0x4c>
 8026148:	68f8      	ldr	r0, [r7, #12]
 802614a:	f7f8 fcbf 	bl	801eacc <wolfSSL_Free>
#endif
  return FP_OKAY;
 802614e:	2300      	movs	r3, #0
}
 8026150:	4618      	mov	r0, r3
 8026152:	3718      	adds	r7, #24
 8026154:	46bd      	mov	sp, r7
 8026156:	bd80      	pop	{r7, pc}

08026158 <fp_to_unsigned_bin_len>:

int fp_to_unsigned_bin_len(fp_int *a, unsigned char *b, int c)
{
 8026158:	b480      	push	{r7}
 802615a:	b089      	sub	sp, #36	@ 0x24
 802615c:	af00      	add	r7, sp, #0
 802615e:	60f8      	str	r0, [r7, #12]
 8026160:	60b9      	str	r1, [r7, #8]
 8026162:	607a      	str	r2, [r7, #4]
#if DIGIT_BIT == 64 || DIGIT_BIT == 32 || DIGIT_BIT == 16
  int i = 0;
 8026164:	2300      	movs	r3, #0
 8026166:	61fb      	str	r3, [r7, #28]
  int j = 0;
 8026168:	2300      	movs	r3, #0
 802616a:	61bb      	str	r3, [r7, #24]
  int x;

  for (x=c-1; x >= 0 && i < a->used; x--) {
 802616c:	687b      	ldr	r3, [r7, #4]
 802616e:	3b01      	subs	r3, #1
 8026170:	617b      	str	r3, [r7, #20]
 8026172:	e021      	b.n	80261b8 <fp_to_unsigned_bin_len+0x60>
     b[x] = (unsigned char)(a->dp[i] >> j);
 8026174:	68fa      	ldr	r2, [r7, #12]
 8026176:	69fb      	ldr	r3, [r7, #28]
 8026178:	3302      	adds	r3, #2
 802617a:	009b      	lsls	r3, r3, #2
 802617c:	4413      	add	r3, r2
 802617e:	685a      	ldr	r2, [r3, #4]
 8026180:	69bb      	ldr	r3, [r7, #24]
 8026182:	fa22 f103 	lsr.w	r1, r2, r3
 8026186:	697b      	ldr	r3, [r7, #20]
 8026188:	68ba      	ldr	r2, [r7, #8]
 802618a:	4413      	add	r3, r2
 802618c:	b2ca      	uxtb	r2, r1
 802618e:	701a      	strb	r2, [r3, #0]
     j += 8;
 8026190:	69bb      	ldr	r3, [r7, #24]
 8026192:	3308      	adds	r3, #8
 8026194:	61bb      	str	r3, [r7, #24]
     i += j == DIGIT_BIT;
 8026196:	69bb      	ldr	r3, [r7, #24]
 8026198:	2b20      	cmp	r3, #32
 802619a:	bf0c      	ite	eq
 802619c:	2301      	moveq	r3, #1
 802619e:	2300      	movne	r3, #0
 80261a0:	b2db      	uxtb	r3, r3
 80261a2:	461a      	mov	r2, r3
 80261a4:	69fb      	ldr	r3, [r7, #28]
 80261a6:	4413      	add	r3, r2
 80261a8:	61fb      	str	r3, [r7, #28]
     j &= DIGIT_BIT - 1;
 80261aa:	69bb      	ldr	r3, [r7, #24]
 80261ac:	f003 031f 	and.w	r3, r3, #31
 80261b0:	61bb      	str	r3, [r7, #24]
  for (x=c-1; x >= 0 && i < a->used; x--) {
 80261b2:	697b      	ldr	r3, [r7, #20]
 80261b4:	3b01      	subs	r3, #1
 80261b6:	617b      	str	r3, [r7, #20]
 80261b8:	697b      	ldr	r3, [r7, #20]
 80261ba:	2b00      	cmp	r3, #0
 80261bc:	db0d      	blt.n	80261da <fp_to_unsigned_bin_len+0x82>
 80261be:	68fb      	ldr	r3, [r7, #12]
 80261c0:	681b      	ldr	r3, [r3, #0]
 80261c2:	69fa      	ldr	r2, [r7, #28]
 80261c4:	429a      	cmp	r2, r3
 80261c6:	dbd5      	blt.n	8026174 <fp_to_unsigned_bin_len+0x1c>
  }
  for (; x >= 0; x--) {
 80261c8:	e007      	b.n	80261da <fp_to_unsigned_bin_len+0x82>
     b[x] = 0;
 80261ca:	697b      	ldr	r3, [r7, #20]
 80261cc:	68ba      	ldr	r2, [r7, #8]
 80261ce:	4413      	add	r3, r2
 80261d0:	2200      	movs	r2, #0
 80261d2:	701a      	strb	r2, [r3, #0]
  for (; x >= 0; x--) {
 80261d4:	697b      	ldr	r3, [r7, #20]
 80261d6:	3b01      	subs	r3, #1
 80261d8:	617b      	str	r3, [r7, #20]
 80261da:	697b      	ldr	r3, [r7, #20]
 80261dc:	2b00      	cmp	r3, #0
 80261de:	daf4      	bge.n	80261ca <fp_to_unsigned_bin_len+0x72>
  }
  if (i < a->used - 1) {
 80261e0:	68fb      	ldr	r3, [r7, #12]
 80261e2:	681b      	ldr	r3, [r3, #0]
 80261e4:	3b01      	subs	r3, #1
 80261e6:	69fa      	ldr	r2, [r7, #28]
 80261e8:	429a      	cmp	r2, r3
 80261ea:	da02      	bge.n	80261f2 <fp_to_unsigned_bin_len+0x9a>
      return FP_VAL;
 80261ec:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80261f0:	e014      	b.n	802621c <fp_to_unsigned_bin_len+0xc4>
  }
  if ((i == a->used - 1) && ((a->dp[i] >> j) != 0)) {
 80261f2:	68fb      	ldr	r3, [r7, #12]
 80261f4:	681b      	ldr	r3, [r3, #0]
 80261f6:	3b01      	subs	r3, #1
 80261f8:	69fa      	ldr	r2, [r7, #28]
 80261fa:	429a      	cmp	r2, r3
 80261fc:	d10d      	bne.n	802621a <fp_to_unsigned_bin_len+0xc2>
 80261fe:	68fa      	ldr	r2, [r7, #12]
 8026200:	69fb      	ldr	r3, [r7, #28]
 8026202:	3302      	adds	r3, #2
 8026204:	009b      	lsls	r3, r3, #2
 8026206:	4413      	add	r3, r2
 8026208:	685a      	ldr	r2, [r3, #4]
 802620a:	69bb      	ldr	r3, [r7, #24]
 802620c:	fa22 f303 	lsr.w	r3, r2, r3
 8026210:	2b00      	cmp	r3, #0
 8026212:	d002      	beq.n	802621a <fp_to_unsigned_bin_len+0xc2>
      return FP_VAL;
 8026214:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8026218:	e000      	b.n	802621c <fp_to_unsigned_bin_len+0xc4>
  }

  return FP_OKAY;
 802621a:	2300      	movs	r3, #0
  if (!fp_iszero(t)) {
      return FP_VAL;
  }
  return FP_OKAY;
#endif
}
 802621c:	4618      	mov	r0, r3
 802621e:	3724      	adds	r7, #36	@ 0x24
 8026220:	46bd      	mov	sp, r7
 8026222:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026226:	4770      	bx	lr

08026228 <fp_unsigned_bin_size>:

int fp_unsigned_bin_size(const fp_int *a)
{
 8026228:	b580      	push	{r7, lr}
 802622a:	b084      	sub	sp, #16
 802622c:	af00      	add	r7, sp, #0
 802622e:	6078      	str	r0, [r7, #4]
  int     size = fp_count_bits (a);
 8026230:	6878      	ldr	r0, [r7, #4]
 8026232:	f000 f857 	bl	80262e4 <fp_count_bits>
 8026236:	60f8      	str	r0, [r7, #12]
  return (size / 8 + ((size & 7) != 0 ? 1 : 0));
 8026238:	68fb      	ldr	r3, [r7, #12]
 802623a:	2b00      	cmp	r3, #0
 802623c:	da00      	bge.n	8026240 <fp_unsigned_bin_size+0x18>
 802623e:	3307      	adds	r3, #7
 8026240:	10db      	asrs	r3, r3, #3
 8026242:	461a      	mov	r2, r3
 8026244:	68fb      	ldr	r3, [r7, #12]
 8026246:	f003 0307 	and.w	r3, r3, #7
 802624a:	2b00      	cmp	r3, #0
 802624c:	bf14      	ite	ne
 802624e:	2301      	movne	r3, #1
 8026250:	2300      	moveq	r3, #0
 8026252:	b2db      	uxtb	r3, r3
 8026254:	4413      	add	r3, r2
}
 8026256:	4618      	mov	r0, r3
 8026258:	3710      	adds	r7, #16
 802625a:	46bd      	mov	sp, r7
 802625c:	bd80      	pop	{r7, pc}

0802625e <fp_set>:

void fp_set(fp_int *a, fp_digit b)
{
 802625e:	b580      	push	{r7, lr}
 8026260:	b082      	sub	sp, #8
 8026262:	af00      	add	r7, sp, #0
 8026264:	6078      	str	r0, [r7, #4]
 8026266:	6039      	str	r1, [r7, #0]
   fp_zero(a);
 8026268:	6878      	ldr	r0, [r7, #4]
 802626a:	f000 fa35 	bl	80266d8 <fp_zero>
   a->dp[0] = b;
 802626e:	687b      	ldr	r3, [r7, #4]
 8026270:	683a      	ldr	r2, [r7, #0]
 8026272:	60da      	str	r2, [r3, #12]
   a->used  = a->dp[0] ? 1 : 0;
 8026274:	687b      	ldr	r3, [r7, #4]
 8026276:	68db      	ldr	r3, [r3, #12]
 8026278:	2b00      	cmp	r3, #0
 802627a:	bf14      	ite	ne
 802627c:	2301      	movne	r3, #1
 802627e:	2300      	moveq	r3, #0
 8026280:	b2db      	uxtb	r3, r3
 8026282:	461a      	mov	r2, r3
 8026284:	687b      	ldr	r3, [r7, #4]
 8026286:	601a      	str	r2, [r3, #0]
}
 8026288:	bf00      	nop
 802628a:	3708      	adds	r7, #8
 802628c:	46bd      	mov	sp, r7
 802628e:	bd80      	pop	{r7, pc}

08026290 <fp_is_bit_set>:
  return FP_OKAY;
}

/* check if a bit is set */
int fp_is_bit_set (fp_int *a, fp_digit b)
{
 8026290:	b480      	push	{r7}
 8026292:	b085      	sub	sp, #20
 8026294:	af00      	add	r7, sp, #0
 8026296:	6078      	str	r0, [r7, #4]
 8026298:	6039      	str	r1, [r7, #0]
    fp_digit i;

    if (b > FP_MAX_BITS)
 802629a:	683b      	ldr	r3, [r7, #0]
 802629c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80262a0:	d902      	bls.n	80262a8 <fp_is_bit_set+0x18>
        return FP_VAL;
 80262a2:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80262a6:	e017      	b.n	80262d8 <fp_is_bit_set+0x48>

    i = b/DIGIT_BIT;
 80262a8:	683b      	ldr	r3, [r7, #0]
 80262aa:	095b      	lsrs	r3, r3, #5
 80262ac:	60fb      	str	r3, [r7, #12]

    if ((fp_digit)a->used < i)
 80262ae:	687b      	ldr	r3, [r7, #4]
 80262b0:	681b      	ldr	r3, [r3, #0]
 80262b2:	461a      	mov	r2, r3
 80262b4:	68fb      	ldr	r3, [r7, #12]
 80262b6:	4293      	cmp	r3, r2
 80262b8:	d901      	bls.n	80262be <fp_is_bit_set+0x2e>
        return 0;
 80262ba:	2300      	movs	r3, #0
 80262bc:	e00c      	b.n	80262d8 <fp_is_bit_set+0x48>

    return (int)((a->dp[i] >> b%DIGIT_BIT) & (fp_digit)1);
 80262be:	687a      	ldr	r2, [r7, #4]
 80262c0:	68fb      	ldr	r3, [r7, #12]
 80262c2:	3302      	adds	r3, #2
 80262c4:	009b      	lsls	r3, r3, #2
 80262c6:	4413      	add	r3, r2
 80262c8:	685a      	ldr	r2, [r3, #4]
 80262ca:	683b      	ldr	r3, [r7, #0]
 80262cc:	f003 031f 	and.w	r3, r3, #31
 80262d0:	fa22 f303 	lsr.w	r3, r2, r3
 80262d4:	f003 0301 	and.w	r3, r3, #1
}
 80262d8:	4618      	mov	r0, r3
 80262da:	3714      	adds	r7, #20
 80262dc:	46bd      	mov	sp, r7
 80262de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80262e2:	4770      	bx	lr

080262e4 <fp_count_bits>:

    return MP_OKAY;
}

int fp_count_bits (const fp_int * a)
{
 80262e4:	b480      	push	{r7}
 80262e6:	b085      	sub	sp, #20
 80262e8:	af00      	add	r7, sp, #0
 80262ea:	6078      	str	r0, [r7, #4]
  int     r;
  fp_digit q;

  /* shortcut */
  if (a->used == 0) {
 80262ec:	687b      	ldr	r3, [r7, #4]
 80262ee:	681b      	ldr	r3, [r3, #0]
 80262f0:	2b00      	cmp	r3, #0
 80262f2:	d101      	bne.n	80262f8 <fp_count_bits+0x14>
    return 0;
 80262f4:	2300      	movs	r3, #0
 80262f6:	e018      	b.n	802632a <fp_count_bits+0x46>
  }

  /* get number of digits and add that */
  r = (a->used - 1) * DIGIT_BIT;
 80262f8:	687b      	ldr	r3, [r7, #4]
 80262fa:	681b      	ldr	r3, [r3, #0]
 80262fc:	3b01      	subs	r3, #1
 80262fe:	015b      	lsls	r3, r3, #5
 8026300:	60fb      	str	r3, [r7, #12]

  /* take the last digit and count the bits in it */
  q = a->dp[a->used - 1];
 8026302:	687b      	ldr	r3, [r7, #4]
 8026304:	681b      	ldr	r3, [r3, #0]
 8026306:	3b01      	subs	r3, #1
 8026308:	687a      	ldr	r2, [r7, #4]
 802630a:	3302      	adds	r3, #2
 802630c:	009b      	lsls	r3, r3, #2
 802630e:	4413      	add	r3, r2
 8026310:	685b      	ldr	r3, [r3, #4]
 8026312:	60bb      	str	r3, [r7, #8]
  while (q > ((fp_digit) 0)) {
 8026314:	e005      	b.n	8026322 <fp_count_bits+0x3e>
    ++r;
 8026316:	68fb      	ldr	r3, [r7, #12]
 8026318:	3301      	adds	r3, #1
 802631a:	60fb      	str	r3, [r7, #12]
    q >>= ((fp_digit) 1);
 802631c:	68bb      	ldr	r3, [r7, #8]
 802631e:	085b      	lsrs	r3, r3, #1
 8026320:	60bb      	str	r3, [r7, #8]
  while (q > ((fp_digit) 0)) {
 8026322:	68bb      	ldr	r3, [r7, #8]
 8026324:	2b00      	cmp	r3, #0
 8026326:	d1f6      	bne.n	8026316 <fp_count_bits+0x32>
  }

  return r;
 8026328:	68fb      	ldr	r3, [r7, #12]
}
 802632a:	4618      	mov	r0, r3
 802632c:	3714      	adds	r7, #20
 802632e:	46bd      	mov	sp, r7
 8026330:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026334:	4770      	bx	lr

08026336 <fp_leading_bit>:

int fp_leading_bit(fp_int *a)
{
 8026336:	b480      	push	{r7}
 8026338:	b087      	sub	sp, #28
 802633a:	af00      	add	r7, sp, #0
 802633c:	6078      	str	r0, [r7, #4]
    int bit = 0;
 802633e:	2300      	movs	r3, #0
 8026340:	617b      	str	r3, [r7, #20]

    if (a->used != 0) {
 8026342:	687b      	ldr	r3, [r7, #4]
 8026344:	681b      	ldr	r3, [r3, #0]
 8026346:	2b00      	cmp	r3, #0
 8026348:	d021      	beq.n	802638e <fp_leading_bit+0x58>
        fp_digit q = a->dp[a->used - 1];
 802634a:	687b      	ldr	r3, [r7, #4]
 802634c:	681b      	ldr	r3, [r3, #0]
 802634e:	3b01      	subs	r3, #1
 8026350:	687a      	ldr	r2, [r7, #4]
 8026352:	3302      	adds	r3, #2
 8026354:	009b      	lsls	r3, r3, #2
 8026356:	4413      	add	r3, r2
 8026358:	685b      	ldr	r3, [r3, #4]
 802635a:	613b      	str	r3, [r7, #16]
        int qSz = sizeof(fp_digit);
 802635c:	2304      	movs	r3, #4
 802635e:	60fb      	str	r3, [r7, #12]

        while (qSz > 0) {
 8026360:	e012      	b.n	8026388 <fp_leading_bit+0x52>
            if ((unsigned char)q != 0)
 8026362:	693b      	ldr	r3, [r7, #16]
 8026364:	b2db      	uxtb	r3, r3
 8026366:	2b00      	cmp	r3, #0
 8026368:	d008      	beq.n	802637c <fp_leading_bit+0x46>
                bit = (q & 0x80) != 0;
 802636a:	693b      	ldr	r3, [r7, #16]
 802636c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8026370:	2b00      	cmp	r3, #0
 8026372:	bf14      	ite	ne
 8026374:	2301      	movne	r3, #1
 8026376:	2300      	moveq	r3, #0
 8026378:	b2db      	uxtb	r3, r3
 802637a:	617b      	str	r3, [r7, #20]
            q >>= 8;
 802637c:	693b      	ldr	r3, [r7, #16]
 802637e:	0a1b      	lsrs	r3, r3, #8
 8026380:	613b      	str	r3, [r7, #16]
            qSz--;
 8026382:	68fb      	ldr	r3, [r7, #12]
 8026384:	3b01      	subs	r3, #1
 8026386:	60fb      	str	r3, [r7, #12]
        while (qSz > 0) {
 8026388:	68fb      	ldr	r3, [r7, #12]
 802638a:	2b00      	cmp	r3, #0
 802638c:	dce9      	bgt.n	8026362 <fp_leading_bit+0x2c>
        }
    }

    return bit;
 802638e:	697b      	ldr	r3, [r7, #20]
}
 8026390:	4618      	mov	r0, r3
 8026392:	371c      	adds	r7, #28
 8026394:	46bd      	mov	sp, r7
 8026396:	f85d 7b04 	ldr.w	r7, [sp], #4
 802639a:	4770      	bx	lr

0802639c <fp_lshd>:

int fp_lshd(fp_int *a, int x)
{
 802639c:	b480      	push	{r7}
 802639e:	b085      	sub	sp, #20
 80263a0:	af00      	add	r7, sp, #0
 80263a2:	6078      	str	r0, [r7, #4]
 80263a4:	6039      	str	r1, [r7, #0]
    int y;

    if (a->used + x > FP_SIZE) return FP_VAL;
 80263a6:	687b      	ldr	r3, [r7, #4]
 80263a8:	681a      	ldr	r2, [r3, #0]
 80263aa:	683b      	ldr	r3, [r7, #0]
 80263ac:	4413      	add	r3, r2
 80263ae:	2b88      	cmp	r3, #136	@ 0x88
 80263b0:	dd02      	ble.n	80263b8 <fp_lshd+0x1c>
 80263b2:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 80263b6:	e04c      	b.n	8026452 <fp_lshd+0xb6>

    y = a->used + x - 1;
 80263b8:	687b      	ldr	r3, [r7, #4]
 80263ba:	681a      	ldr	r2, [r3, #0]
 80263bc:	683b      	ldr	r3, [r7, #0]
 80263be:	4413      	add	r3, r2
 80263c0:	3b01      	subs	r3, #1
 80263c2:	60fb      	str	r3, [r7, #12]

    /* store new size */
    a->used = y + 1;
 80263c4:	68fb      	ldr	r3, [r7, #12]
 80263c6:	1c5a      	adds	r2, r3, #1
 80263c8:	687b      	ldr	r3, [r7, #4]
 80263ca:	601a      	str	r2, [r3, #0]

    /* move digits */
    for (; y >= x; y--) {
 80263cc:	e010      	b.n	80263f0 <fp_lshd+0x54>
        a->dp[y] = a->dp[y-x];
 80263ce:	68fa      	ldr	r2, [r7, #12]
 80263d0:	683b      	ldr	r3, [r7, #0]
 80263d2:	1ad3      	subs	r3, r2, r3
 80263d4:	687a      	ldr	r2, [r7, #4]
 80263d6:	3302      	adds	r3, #2
 80263d8:	009b      	lsls	r3, r3, #2
 80263da:	4413      	add	r3, r2
 80263dc:	685a      	ldr	r2, [r3, #4]
 80263de:	6879      	ldr	r1, [r7, #4]
 80263e0:	68fb      	ldr	r3, [r7, #12]
 80263e2:	3302      	adds	r3, #2
 80263e4:	009b      	lsls	r3, r3, #2
 80263e6:	440b      	add	r3, r1
 80263e8:	605a      	str	r2, [r3, #4]
    for (; y >= x; y--) {
 80263ea:	68fb      	ldr	r3, [r7, #12]
 80263ec:	3b01      	subs	r3, #1
 80263ee:	60fb      	str	r3, [r7, #12]
 80263f0:	68fa      	ldr	r2, [r7, #12]
 80263f2:	683b      	ldr	r3, [r7, #0]
 80263f4:	429a      	cmp	r2, r3
 80263f6:	daea      	bge.n	80263ce <fp_lshd+0x32>
    }

    /* zero lower digits */
    for (; y >= 0; y--) {
 80263f8:	e009      	b.n	802640e <fp_lshd+0x72>
        a->dp[y] = 0;
 80263fa:	687a      	ldr	r2, [r7, #4]
 80263fc:	68fb      	ldr	r3, [r7, #12]
 80263fe:	3302      	adds	r3, #2
 8026400:	009b      	lsls	r3, r3, #2
 8026402:	4413      	add	r3, r2
 8026404:	2200      	movs	r2, #0
 8026406:	605a      	str	r2, [r3, #4]
    for (; y >= 0; y--) {
 8026408:	68fb      	ldr	r3, [r7, #12]
 802640a:	3b01      	subs	r3, #1
 802640c:	60fb      	str	r3, [r7, #12]
 802640e:	68fb      	ldr	r3, [r7, #12]
 8026410:	2b00      	cmp	r3, #0
 8026412:	daf2      	bge.n	80263fa <fp_lshd+0x5e>
    }

    /* clamp digits */
    fp_clamp(a);
 8026414:	e004      	b.n	8026420 <fp_lshd+0x84>
 8026416:	687b      	ldr	r3, [r7, #4]
 8026418:	681b      	ldr	r3, [r3, #0]
 802641a:	1e5a      	subs	r2, r3, #1
 802641c:	687b      	ldr	r3, [r7, #4]
 802641e:	601a      	str	r2, [r3, #0]
 8026420:	687b      	ldr	r3, [r7, #4]
 8026422:	681b      	ldr	r3, [r3, #0]
 8026424:	2b00      	cmp	r3, #0
 8026426:	d009      	beq.n	802643c <fp_lshd+0xa0>
 8026428:	687b      	ldr	r3, [r7, #4]
 802642a:	681b      	ldr	r3, [r3, #0]
 802642c:	3b01      	subs	r3, #1
 802642e:	687a      	ldr	r2, [r7, #4]
 8026430:	3302      	adds	r3, #2
 8026432:	009b      	lsls	r3, r3, #2
 8026434:	4413      	add	r3, r2
 8026436:	685b      	ldr	r3, [r3, #4]
 8026438:	2b00      	cmp	r3, #0
 802643a:	d0ec      	beq.n	8026416 <fp_lshd+0x7a>
 802643c:	687b      	ldr	r3, [r7, #4]
 802643e:	681b      	ldr	r3, [r3, #0]
 8026440:	2b00      	cmp	r3, #0
 8026442:	d002      	beq.n	802644a <fp_lshd+0xae>
 8026444:	687b      	ldr	r3, [r7, #4]
 8026446:	685b      	ldr	r3, [r3, #4]
 8026448:	e000      	b.n	802644c <fp_lshd+0xb0>
 802644a:	2300      	movs	r3, #0
 802644c:	687a      	ldr	r2, [r7, #4]
 802644e:	6053      	str	r3, [r2, #4]
    return FP_OKAY;
 8026450:	2300      	movs	r3, #0
}
 8026452:	4618      	mov	r0, r3
 8026454:	3714      	adds	r7, #20
 8026456:	46bd      	mov	sp, r7
 8026458:	f85d 7b04 	ldr.w	r7, [sp], #4
 802645c:	4770      	bx	lr

0802645e <fp_rshb>:


/* right shift by bit count */
void fp_rshb(fp_int *c, int x)
{
 802645e:	b580      	push	{r7, lr}
 8026460:	b088      	sub	sp, #32
 8026462:	af00      	add	r7, sp, #0
 8026464:	6078      	str	r0, [r7, #4]
 8026466:	6039      	str	r1, [r7, #0]
    fp_digit *tmpc, mask, shift;
    fp_digit r, rr;
    fp_digit D = x;
 8026468:	683b      	ldr	r3, [r7, #0]
 802646a:	617b      	str	r3, [r7, #20]

    /* shifting by a negative number not supported, and shifting by
     * zero changes nothing.
     */
    if (x <= 0) return;
 802646c:	683b      	ldr	r3, [r7, #0]
 802646e:	2b00      	cmp	r3, #0
 8026470:	dd71      	ble.n	8026556 <fp_rshb+0xf8>

    /* shift digits first if needed */
    if (x >= DIGIT_BIT) {
 8026472:	683b      	ldr	r3, [r7, #0]
 8026474:	2b1f      	cmp	r3, #31
 8026476:	dd14      	ble.n	80264a2 <fp_rshb+0x44>
        fp_rshd(c, x / DIGIT_BIT);
 8026478:	683b      	ldr	r3, [r7, #0]
 802647a:	2b00      	cmp	r3, #0
 802647c:	da00      	bge.n	8026480 <fp_rshb+0x22>
 802647e:	331f      	adds	r3, #31
 8026480:	115b      	asrs	r3, r3, #5
 8026482:	4619      	mov	r1, r3
 8026484:	6878      	ldr	r0, [r7, #4]
 8026486:	f000 f86e 	bl	8026566 <fp_rshd>
        /* recalculate number of bits to shift */
        D = x % DIGIT_BIT;
 802648a:	683b      	ldr	r3, [r7, #0]
 802648c:	425a      	negs	r2, r3
 802648e:	f003 031f 	and.w	r3, r3, #31
 8026492:	f002 021f 	and.w	r2, r2, #31
 8026496:	bf58      	it	pl
 8026498:	4253      	negpl	r3, r2
 802649a:	617b      	str	r3, [r7, #20]
        /* check if any more shifting needed */
        if (D == 0) return;
 802649c:	697b      	ldr	r3, [r7, #20]
 802649e:	2b00      	cmp	r3, #0
 80264a0:	d05b      	beq.n	802655a <fp_rshb+0xfc>

    }

    /* zero shifted is always zero */
    if (fp_iszero(c)) return;
 80264a2:	687b      	ldr	r3, [r7, #4]
 80264a4:	681b      	ldr	r3, [r3, #0]
 80264a6:	2b00      	cmp	r3, #0
 80264a8:	d059      	beq.n	802655e <fp_rshb+0x100>

    /* mask */
    mask = (((fp_digit)1) << D) - 1;
 80264aa:	2201      	movs	r2, #1
 80264ac:	697b      	ldr	r3, [r7, #20]
 80264ae:	fa02 f303 	lsl.w	r3, r2, r3
 80264b2:	3b01      	subs	r3, #1
 80264b4:	613b      	str	r3, [r7, #16]

    /* shift for lsb */
    shift = DIGIT_BIT - D;
 80264b6:	697b      	ldr	r3, [r7, #20]
 80264b8:	f1c3 0320 	rsb	r3, r3, #32
 80264bc:	60fb      	str	r3, [r7, #12]

    /* alias */
    tmpc = c->dp + (c->used - 1);
 80264be:	687b      	ldr	r3, [r7, #4]
 80264c0:	f103 020c 	add.w	r2, r3, #12
 80264c4:	687b      	ldr	r3, [r7, #4]
 80264c6:	681b      	ldr	r3, [r3, #0]
 80264c8:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80264cc:	3b01      	subs	r3, #1
 80264ce:	009b      	lsls	r3, r3, #2
 80264d0:	4413      	add	r3, r2
 80264d2:	61fb      	str	r3, [r7, #28]

    /* carry */
    r = 0;
 80264d4:	2300      	movs	r3, #0
 80264d6:	61bb      	str	r3, [r7, #24]
    for (x = c->used - 1; x >= 0; x--) {
 80264d8:	687b      	ldr	r3, [r7, #4]
 80264da:	681b      	ldr	r3, [r3, #0]
 80264dc:	3b01      	subs	r3, #1
 80264de:	603b      	str	r3, [r7, #0]
 80264e0:	e017      	b.n	8026512 <fp_rshb+0xb4>
      /* get the lower  bits of this word in a temp */
      rr = *tmpc & mask;
 80264e2:	69fb      	ldr	r3, [r7, #28]
 80264e4:	681b      	ldr	r3, [r3, #0]
 80264e6:	693a      	ldr	r2, [r7, #16]
 80264e8:	4013      	ands	r3, r2
 80264ea:	60bb      	str	r3, [r7, #8]

      /* shift the current word and mix in the carry bits from previous word */
      *tmpc = (*tmpc >> D) | (r << shift);
 80264ec:	69fb      	ldr	r3, [r7, #28]
 80264ee:	681a      	ldr	r2, [r3, #0]
 80264f0:	697b      	ldr	r3, [r7, #20]
 80264f2:	40da      	lsrs	r2, r3
 80264f4:	69b9      	ldr	r1, [r7, #24]
 80264f6:	68fb      	ldr	r3, [r7, #12]
 80264f8:	fa01 f303 	lsl.w	r3, r1, r3
 80264fc:	431a      	orrs	r2, r3
 80264fe:	69fb      	ldr	r3, [r7, #28]
 8026500:	601a      	str	r2, [r3, #0]
      --tmpc;
 8026502:	69fb      	ldr	r3, [r7, #28]
 8026504:	3b04      	subs	r3, #4
 8026506:	61fb      	str	r3, [r7, #28]

      /* set the carry to the carry bits of the current word found above */
      r = rr;
 8026508:	68bb      	ldr	r3, [r7, #8]
 802650a:	61bb      	str	r3, [r7, #24]
    for (x = c->used - 1; x >= 0; x--) {
 802650c:	683b      	ldr	r3, [r7, #0]
 802650e:	3b01      	subs	r3, #1
 8026510:	603b      	str	r3, [r7, #0]
 8026512:	683b      	ldr	r3, [r7, #0]
 8026514:	2b00      	cmp	r3, #0
 8026516:	dae4      	bge.n	80264e2 <fp_rshb+0x84>
    }

    /* clamp digits */
    fp_clamp(c);
 8026518:	e004      	b.n	8026524 <fp_rshb+0xc6>
 802651a:	687b      	ldr	r3, [r7, #4]
 802651c:	681b      	ldr	r3, [r3, #0]
 802651e:	1e5a      	subs	r2, r3, #1
 8026520:	687b      	ldr	r3, [r7, #4]
 8026522:	601a      	str	r2, [r3, #0]
 8026524:	687b      	ldr	r3, [r7, #4]
 8026526:	681b      	ldr	r3, [r3, #0]
 8026528:	2b00      	cmp	r3, #0
 802652a:	d009      	beq.n	8026540 <fp_rshb+0xe2>
 802652c:	687b      	ldr	r3, [r7, #4]
 802652e:	681b      	ldr	r3, [r3, #0]
 8026530:	3b01      	subs	r3, #1
 8026532:	687a      	ldr	r2, [r7, #4]
 8026534:	3302      	adds	r3, #2
 8026536:	009b      	lsls	r3, r3, #2
 8026538:	4413      	add	r3, r2
 802653a:	685b      	ldr	r3, [r3, #4]
 802653c:	2b00      	cmp	r3, #0
 802653e:	d0ec      	beq.n	802651a <fp_rshb+0xbc>
 8026540:	687b      	ldr	r3, [r7, #4]
 8026542:	681b      	ldr	r3, [r3, #0]
 8026544:	2b00      	cmp	r3, #0
 8026546:	d002      	beq.n	802654e <fp_rshb+0xf0>
 8026548:	687b      	ldr	r3, [r7, #4]
 802654a:	685b      	ldr	r3, [r3, #4]
 802654c:	e000      	b.n	8026550 <fp_rshb+0xf2>
 802654e:	2300      	movs	r3, #0
 8026550:	687a      	ldr	r2, [r7, #4]
 8026552:	6053      	str	r3, [r2, #4]
 8026554:	e004      	b.n	8026560 <fp_rshb+0x102>
    if (x <= 0) return;
 8026556:	bf00      	nop
 8026558:	e002      	b.n	8026560 <fp_rshb+0x102>
        if (D == 0) return;
 802655a:	bf00      	nop
 802655c:	e000      	b.n	8026560 <fp_rshb+0x102>
    if (fp_iszero(c)) return;
 802655e:	bf00      	nop
}
 8026560:	3720      	adds	r7, #32
 8026562:	46bd      	mov	sp, r7
 8026564:	bd80      	pop	{r7, pc}

08026566 <fp_rshd>:


void fp_rshd(fp_int *a, int x)
{
 8026566:	b580      	push	{r7, lr}
 8026568:	b084      	sub	sp, #16
 802656a:	af00      	add	r7, sp, #0
 802656c:	6078      	str	r0, [r7, #4]
 802656e:	6039      	str	r1, [r7, #0]
  int y;

  /* too many digits just zero and return */
  if (x >= a->used) {
 8026570:	687b      	ldr	r3, [r7, #4]
 8026572:	681b      	ldr	r3, [r3, #0]
 8026574:	683a      	ldr	r2, [r7, #0]
 8026576:	429a      	cmp	r2, r3
 8026578:	db03      	blt.n	8026582 <fp_rshd+0x1c>
     fp_zero(a);
 802657a:	6878      	ldr	r0, [r7, #4]
 802657c:	f000 f8ac 	bl	80266d8 <fp_zero>
     return;
 8026580:	e04e      	b.n	8026620 <fp_rshd+0xba>
  }

   /* shift */
   for (y = 0; y < a->used - x; y++) {
 8026582:	2300      	movs	r3, #0
 8026584:	60fb      	str	r3, [r7, #12]
 8026586:	e010      	b.n	80265aa <fp_rshd+0x44>
      a->dp[y] = a->dp[y+x];
 8026588:	68fa      	ldr	r2, [r7, #12]
 802658a:	683b      	ldr	r3, [r7, #0]
 802658c:	4413      	add	r3, r2
 802658e:	687a      	ldr	r2, [r7, #4]
 8026590:	3302      	adds	r3, #2
 8026592:	009b      	lsls	r3, r3, #2
 8026594:	4413      	add	r3, r2
 8026596:	685a      	ldr	r2, [r3, #4]
 8026598:	6879      	ldr	r1, [r7, #4]
 802659a:	68fb      	ldr	r3, [r7, #12]
 802659c:	3302      	adds	r3, #2
 802659e:	009b      	lsls	r3, r3, #2
 80265a0:	440b      	add	r3, r1
 80265a2:	605a      	str	r2, [r3, #4]
   for (y = 0; y < a->used - x; y++) {
 80265a4:	68fb      	ldr	r3, [r7, #12]
 80265a6:	3301      	adds	r3, #1
 80265a8:	60fb      	str	r3, [r7, #12]
 80265aa:	687b      	ldr	r3, [r7, #4]
 80265ac:	681a      	ldr	r2, [r3, #0]
 80265ae:	683b      	ldr	r3, [r7, #0]
 80265b0:	1ad3      	subs	r3, r2, r3
 80265b2:	68fa      	ldr	r2, [r7, #12]
 80265b4:	429a      	cmp	r2, r3
 80265b6:	dbe7      	blt.n	8026588 <fp_rshd+0x22>
   }

   /* zero rest */
   for (; y < a->used; y++) {
 80265b8:	e009      	b.n	80265ce <fp_rshd+0x68>
      a->dp[y] = 0;
 80265ba:	687a      	ldr	r2, [r7, #4]
 80265bc:	68fb      	ldr	r3, [r7, #12]
 80265be:	3302      	adds	r3, #2
 80265c0:	009b      	lsls	r3, r3, #2
 80265c2:	4413      	add	r3, r2
 80265c4:	2200      	movs	r2, #0
 80265c6:	605a      	str	r2, [r3, #4]
   for (; y < a->used; y++) {
 80265c8:	68fb      	ldr	r3, [r7, #12]
 80265ca:	3301      	adds	r3, #1
 80265cc:	60fb      	str	r3, [r7, #12]
 80265ce:	687b      	ldr	r3, [r7, #4]
 80265d0:	681b      	ldr	r3, [r3, #0]
 80265d2:	68fa      	ldr	r2, [r7, #12]
 80265d4:	429a      	cmp	r2, r3
 80265d6:	dbf0      	blt.n	80265ba <fp_rshd+0x54>
   }

   /* decrement count */
   a->used -= x;
 80265d8:	687b      	ldr	r3, [r7, #4]
 80265da:	681a      	ldr	r2, [r3, #0]
 80265dc:	683b      	ldr	r3, [r7, #0]
 80265de:	1ad2      	subs	r2, r2, r3
 80265e0:	687b      	ldr	r3, [r7, #4]
 80265e2:	601a      	str	r2, [r3, #0]
   fp_clamp(a);
 80265e4:	e004      	b.n	80265f0 <fp_rshd+0x8a>
 80265e6:	687b      	ldr	r3, [r7, #4]
 80265e8:	681b      	ldr	r3, [r3, #0]
 80265ea:	1e5a      	subs	r2, r3, #1
 80265ec:	687b      	ldr	r3, [r7, #4]
 80265ee:	601a      	str	r2, [r3, #0]
 80265f0:	687b      	ldr	r3, [r7, #4]
 80265f2:	681b      	ldr	r3, [r3, #0]
 80265f4:	2b00      	cmp	r3, #0
 80265f6:	d009      	beq.n	802660c <fp_rshd+0xa6>
 80265f8:	687b      	ldr	r3, [r7, #4]
 80265fa:	681b      	ldr	r3, [r3, #0]
 80265fc:	3b01      	subs	r3, #1
 80265fe:	687a      	ldr	r2, [r7, #4]
 8026600:	3302      	adds	r3, #2
 8026602:	009b      	lsls	r3, r3, #2
 8026604:	4413      	add	r3, r2
 8026606:	685b      	ldr	r3, [r3, #4]
 8026608:	2b00      	cmp	r3, #0
 802660a:	d0ec      	beq.n	80265e6 <fp_rshd+0x80>
 802660c:	687b      	ldr	r3, [r7, #4]
 802660e:	681b      	ldr	r3, [r3, #0]
 8026610:	2b00      	cmp	r3, #0
 8026612:	d002      	beq.n	802661a <fp_rshd+0xb4>
 8026614:	687b      	ldr	r3, [r7, #4]
 8026616:	685b      	ldr	r3, [r3, #4]
 8026618:	e000      	b.n	802661c <fp_rshd+0xb6>
 802661a:	2300      	movs	r3, #0
 802661c:	687a      	ldr	r2, [r7, #4]
 802661e:	6053      	str	r3, [r2, #4]
}
 8026620:	3710      	adds	r7, #16
 8026622:	46bd      	mov	sp, r7
 8026624:	bd80      	pop	{r7, pc}

08026626 <fp_sub_d>:


/* c = a - b */
int fp_sub_d(fp_int *a, fp_digit b, fp_int *c)
{
 8026626:	b580      	push	{r7, lr}
 8026628:	b088      	sub	sp, #32
 802662a:	af00      	add	r7, sp, #0
 802662c:	60f8      	str	r0, [r7, #12]
 802662e:	60b9      	str	r1, [r7, #8]
 8026630:	607a      	str	r2, [r7, #4]
#ifndef WOLFSSL_SMALL_STACK
   fp_int    tmp[1];
#else
   fp_int    *tmp;
#endif
   int       err = FP_OKAY;
 8026632:	2300      	movs	r3, #0
 8026634:	61fb      	str	r3, [r7, #28]

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8026636:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 802663a:	f7f8 fa2b 	bl	801ea94 <wolfSSL_Malloc>
 802663e:	61b8      	str	r0, [r7, #24]
   if (tmp == NULL)
 8026640:	69bb      	ldr	r3, [r7, #24]
 8026642:	2b00      	cmp	r3, #0
 8026644:	d102      	bne.n	802664c <fp_sub_d+0x26>
       return FP_MEM;
 8026646:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 802664a:	e024      	b.n	8026696 <fp_sub_d+0x70>
#endif

   fp_init(tmp);
 802664c:	69b8      	ldr	r0, [r7, #24]
 802664e:	f000 f835 	bl	80266bc <fp_init>
   fp_set(tmp, b);
 8026652:	68b9      	ldr	r1, [r7, #8]
 8026654:	69b8      	ldr	r0, [r7, #24]
 8026656:	f7ff fe02 	bl	802625e <fp_set>
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
   if (c->size < FP_SIZE) {
 802665a:	687b      	ldr	r3, [r7, #4]
 802665c:	689b      	ldr	r3, [r3, #8]
 802665e:	2b87      	cmp	r3, #135	@ 0x87
 8026660:	dc0a      	bgt.n	8026678 <fp_sub_d+0x52>
     err = fp_sub(a, tmp, tmp);
 8026662:	69ba      	ldr	r2, [r7, #24]
 8026664:	69b9      	ldr	r1, [r7, #24]
 8026666:	68f8      	ldr	r0, [r7, #12]
 8026668:	f7fb ff1b 	bl	80224a2 <fp_sub>
 802666c:	61f8      	str	r0, [r7, #28]
     fp_copy(tmp, c);
 802666e:	6879      	ldr	r1, [r7, #4]
 8026670:	69b8      	ldr	r0, [r7, #24]
 8026672:	f000 fa0d 	bl	8026a90 <fp_copy>
 8026676:	e005      	b.n	8026684 <fp_sub_d+0x5e>
   }
   else
#endif
   {
     err = fp_sub(a, tmp, c);
 8026678:	687a      	ldr	r2, [r7, #4]
 802667a:	69b9      	ldr	r1, [r7, #24]
 802667c:	68f8      	ldr	r0, [r7, #12]
 802667e:	f7fb ff10 	bl	80224a2 <fp_sub>
 8026682:	61f8      	str	r0, [r7, #28]
   }

#ifdef WOLFSSL_SMALL_STACK
   XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8026684:	69bb      	ldr	r3, [r7, #24]
 8026686:	617b      	str	r3, [r7, #20]
 8026688:	697b      	ldr	r3, [r7, #20]
 802668a:	2b00      	cmp	r3, #0
 802668c:	d002      	beq.n	8026694 <fp_sub_d+0x6e>
 802668e:	6978      	ldr	r0, [r7, #20]
 8026690:	f7f8 fa1c 	bl	801eacc <wolfSSL_Free>
#endif
   return err;
 8026694:	69fb      	ldr	r3, [r7, #28]
}
 8026696:	4618      	mov	r0, r3
 8026698:	3720      	adds	r7, #32
 802669a:	46bd      	mov	sp, r7
 802669c:	bd80      	pop	{r7, pc}

0802669e <mp_init>:

/* wolfSSL callers from normal lib */

/* init a new mp_int */
int mp_init (mp_int * a)
{
 802669e:	b580      	push	{r7, lr}
 80266a0:	b082      	sub	sp, #8
 80266a2:	af00      	add	r7, sp, #0
 80266a4:	6078      	str	r0, [r7, #4]
  if (a)
 80266a6:	687b      	ldr	r3, [r7, #4]
 80266a8:	2b00      	cmp	r3, #0
 80266aa:	d002      	beq.n	80266b2 <mp_init+0x14>
    fp_init(a);
 80266ac:	6878      	ldr	r0, [r7, #4]
 80266ae:	f000 f805 	bl	80266bc <fp_init>
  return MP_OKAY;
 80266b2:	2300      	movs	r3, #0
}
 80266b4:	4618      	mov	r0, r3
 80266b6:	3708      	adds	r7, #8
 80266b8:	46bd      	mov	sp, r7
 80266ba:	bd80      	pop	{r7, pc}

080266bc <fp_init>:

void fp_init(fp_int *a)
{
 80266bc:	b580      	push	{r7, lr}
 80266be:	b082      	sub	sp, #8
 80266c0:	af00      	add	r7, sp, #0
 80266c2:	6078      	str	r0, [r7, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    a->size = FP_SIZE;
 80266c4:	687b      	ldr	r3, [r7, #4]
 80266c6:	2288      	movs	r2, #136	@ 0x88
 80266c8:	609a      	str	r2, [r3, #8]
#endif
#ifdef HAVE_WOLF_BIGINT
    wc_bigint_init(&a->raw);
#endif
    fp_zero(a);
 80266ca:	6878      	ldr	r0, [r7, #4]
 80266cc:	f000 f804 	bl	80266d8 <fp_zero>
}
 80266d0:	bf00      	nop
 80266d2:	3708      	adds	r7, #8
 80266d4:	46bd      	mov	sp, r7
 80266d6:	bd80      	pop	{r7, pc}

080266d8 <fp_zero>:

void fp_zero(fp_int *a)
{
 80266d8:	b580      	push	{r7, lr}
 80266da:	b084      	sub	sp, #16
 80266dc:	af00      	add	r7, sp, #0
 80266de:	6078      	str	r0, [r7, #4]
    int size;
    a->used = 0;
 80266e0:	687b      	ldr	r3, [r7, #4]
 80266e2:	2200      	movs	r2, #0
 80266e4:	601a      	str	r2, [r3, #0]
    a->sign = FP_ZPOS;
 80266e6:	687b      	ldr	r3, [r7, #4]
 80266e8:	2200      	movs	r2, #0
 80266ea:	605a      	str	r2, [r3, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    size = a->size;
 80266ec:	687b      	ldr	r3, [r7, #4]
 80266ee:	689b      	ldr	r3, [r3, #8]
 80266f0:	60fb      	str	r3, [r7, #12]
#else
    size = FP_SIZE;
#endif
    XMEMSET(a->dp, 0, size * sizeof(fp_digit));
 80266f2:	687b      	ldr	r3, [r7, #4]
 80266f4:	f103 000c 	add.w	r0, r3, #12
 80266f8:	68fb      	ldr	r3, [r7, #12]
 80266fa:	009b      	lsls	r3, r3, #2
 80266fc:	461a      	mov	r2, r3
 80266fe:	2100      	movs	r1, #0
 8026700:	f001 fee6 	bl	80284d0 <memset>
}
 8026704:	bf00      	nop
 8026706:	3710      	adds	r7, #16
 8026708:	46bd      	mov	sp, r7
 802670a:	bd80      	pop	{r7, pc}

0802670c <fp_clear>:

void fp_clear(fp_int *a)
{
 802670c:	b580      	push	{r7, lr}
 802670e:	b084      	sub	sp, #16
 8026710:	af00      	add	r7, sp, #0
 8026712:	6078      	str	r0, [r7, #4]
    int size;
    a->used = 0;
 8026714:	687b      	ldr	r3, [r7, #4]
 8026716:	2200      	movs	r2, #0
 8026718:	601a      	str	r2, [r3, #0]
    a->sign = FP_ZPOS;
 802671a:	687b      	ldr	r3, [r7, #4]
 802671c:	2200      	movs	r2, #0
 802671e:	605a      	str	r2, [r3, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    size = a->size;
 8026720:	687b      	ldr	r3, [r7, #4]
 8026722:	689b      	ldr	r3, [r3, #8]
 8026724:	60fb      	str	r3, [r7, #12]
#else
    size = FP_SIZE;
#endif
    XMEMSET(a->dp, 0, size * sizeof(fp_digit));
 8026726:	687b      	ldr	r3, [r7, #4]
 8026728:	f103 000c 	add.w	r0, r3, #12
 802672c:	68fb      	ldr	r3, [r7, #12]
 802672e:	009b      	lsls	r3, r3, #2
 8026730:	461a      	mov	r2, r3
 8026732:	2100      	movs	r1, #0
 8026734:	f001 fecc 	bl	80284d0 <memset>
    fp_free(a);
 8026738:	6878      	ldr	r0, [r7, #4]
 802673a:	f000 f830 	bl	802679e <fp_free>
}
 802673e:	bf00      	nop
 8026740:	3710      	adds	r7, #16
 8026742:	46bd      	mov	sp, r7
 8026744:	bd80      	pop	{r7, pc}

08026746 <fp_forcezero>:

void fp_forcezero (mp_int * a)
{
 8026746:	b580      	push	{r7, lr}
 8026748:	b084      	sub	sp, #16
 802674a:	af00      	add	r7, sp, #0
 802674c:	6078      	str	r0, [r7, #4]
    int size;

    if (a == NULL)
 802674e:	687b      	ldr	r3, [r7, #4]
 8026750:	2b00      	cmp	r3, #0
 8026752:	d015      	beq.n	8026780 <fp_forcezero+0x3a>
      return;

    a->used = 0;
 8026754:	687b      	ldr	r3, [r7, #4]
 8026756:	2200      	movs	r2, #0
 8026758:	601a      	str	r2, [r3, #0]
    a->sign = FP_ZPOS;
 802675a:	687b      	ldr	r3, [r7, #4]
 802675c:	2200      	movs	r2, #0
 802675e:	605a      	str	r2, [r3, #4]
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
    size = a->size;
 8026760:	687b      	ldr	r3, [r7, #4]
 8026762:	689b      	ldr	r3, [r3, #8]
 8026764:	60fb      	str	r3, [r7, #12]
#else
    size = FP_SIZE;
#endif
    ForceZero(a->dp, size * sizeof(fp_digit));
 8026766:	687b      	ldr	r3, [r7, #4]
 8026768:	f103 020c 	add.w	r2, r3, #12
 802676c:	68fb      	ldr	r3, [r7, #12]
 802676e:	009b      	lsls	r3, r3, #2
 8026770:	4619      	mov	r1, r3
 8026772:	4610      	mov	r0, r2
 8026774:	f7fb fd4c 	bl	8022210 <ForceZero>
#ifdef HAVE_WOLF_BIGINT
    wc_bigint_zero(&a->raw);
#endif
    fp_free(a);
 8026778:	6878      	ldr	r0, [r7, #4]
 802677a:	f000 f810 	bl	802679e <fp_free>
 802677e:	e000      	b.n	8026782 <fp_forcezero+0x3c>
      return;
 8026780:	bf00      	nop
}
 8026782:	3710      	adds	r7, #16
 8026784:	46bd      	mov	sp, r7
 8026786:	bd80      	pop	{r7, pc}

08026788 <mp_forcezero>:

void mp_forcezero (mp_int * a)
{
 8026788:	b580      	push	{r7, lr}
 802678a:	b082      	sub	sp, #8
 802678c:	af00      	add	r7, sp, #0
 802678e:	6078      	str	r0, [r7, #4]
    fp_forcezero(a);
 8026790:	6878      	ldr	r0, [r7, #4]
 8026792:	f7ff ffd8 	bl	8026746 <fp_forcezero>
}
 8026796:	bf00      	nop
 8026798:	3708      	adds	r7, #8
 802679a:	46bd      	mov	sp, r7
 802679c:	bd80      	pop	{r7, pc}

0802679e <fp_free>:

void fp_free(fp_int* a)
{
 802679e:	b480      	push	{r7}
 80267a0:	b083      	sub	sp, #12
 80267a2:	af00      	add	r7, sp, #0
 80267a4:	6078      	str	r0, [r7, #4]
#ifdef HAVE_WOLF_BIGINT
    wc_bigint_free(&a->raw);
#else
    (void)a;
#endif
}
 80267a6:	bf00      	nop
 80267a8:	370c      	adds	r7, #12
 80267aa:	46bd      	mov	sp, r7
 80267ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267b0:	4770      	bx	lr

080267b2 <mp_clear>:


/* clear one (frees)  */
void mp_clear (mp_int * a)
{
 80267b2:	b580      	push	{r7, lr}
 80267b4:	b082      	sub	sp, #8
 80267b6:	af00      	add	r7, sp, #0
 80267b8:	6078      	str	r0, [r7, #4]
    if (a == NULL)
 80267ba:	687b      	ldr	r3, [r7, #4]
 80267bc:	2b00      	cmp	r3, #0
 80267be:	d003      	beq.n	80267c8 <mp_clear+0x16>
        return;
    fp_clear(a);
 80267c0:	6878      	ldr	r0, [r7, #4]
 80267c2:	f7ff ffa3 	bl	802670c <fp_clear>
 80267c6:	e000      	b.n	80267ca <mp_clear+0x18>
        return;
 80267c8:	bf00      	nop
}
 80267ca:	3708      	adds	r7, #8
 80267cc:	46bd      	mov	sp, r7
 80267ce:	bd80      	pop	{r7, pc}

080267d0 <mp_free>:

void mp_free(mp_int* a)
{
 80267d0:	b580      	push	{r7, lr}
 80267d2:	b082      	sub	sp, #8
 80267d4:	af00      	add	r7, sp, #0
 80267d6:	6078      	str	r0, [r7, #4]
    fp_free(a);
 80267d8:	6878      	ldr	r0, [r7, #4]
 80267da:	f7ff ffe0 	bl	802679e <fp_free>
}
 80267de:	bf00      	nop
 80267e0:	3708      	adds	r7, #8
 80267e2:	46bd      	mov	sp, r7
 80267e4:	bd80      	pop	{r7, pc}

080267e6 <mp_init_multi>:

/* handle up to 6 inits */
int mp_init_multi(mp_int* a, mp_int* b, mp_int* c, mp_int* d,
                  mp_int* e, mp_int* f)
{
 80267e6:	b580      	push	{r7, lr}
 80267e8:	b084      	sub	sp, #16
 80267ea:	af00      	add	r7, sp, #0
 80267ec:	60f8      	str	r0, [r7, #12]
 80267ee:	60b9      	str	r1, [r7, #8]
 80267f0:	607a      	str	r2, [r7, #4]
 80267f2:	603b      	str	r3, [r7, #0]
    if (a)
 80267f4:	68fb      	ldr	r3, [r7, #12]
 80267f6:	2b00      	cmp	r3, #0
 80267f8:	d002      	beq.n	8026800 <mp_init_multi+0x1a>
        fp_init(a);
 80267fa:	68f8      	ldr	r0, [r7, #12]
 80267fc:	f7ff ff5e 	bl	80266bc <fp_init>
    if (b)
 8026800:	68bb      	ldr	r3, [r7, #8]
 8026802:	2b00      	cmp	r3, #0
 8026804:	d002      	beq.n	802680c <mp_init_multi+0x26>
        fp_init(b);
 8026806:	68b8      	ldr	r0, [r7, #8]
 8026808:	f7ff ff58 	bl	80266bc <fp_init>
    if (c)
 802680c:	687b      	ldr	r3, [r7, #4]
 802680e:	2b00      	cmp	r3, #0
 8026810:	d002      	beq.n	8026818 <mp_init_multi+0x32>
        fp_init(c);
 8026812:	6878      	ldr	r0, [r7, #4]
 8026814:	f7ff ff52 	bl	80266bc <fp_init>
    if (d)
 8026818:	683b      	ldr	r3, [r7, #0]
 802681a:	2b00      	cmp	r3, #0
 802681c:	d002      	beq.n	8026824 <mp_init_multi+0x3e>
        fp_init(d);
 802681e:	6838      	ldr	r0, [r7, #0]
 8026820:	f7ff ff4c 	bl	80266bc <fp_init>
    if (e)
 8026824:	69bb      	ldr	r3, [r7, #24]
 8026826:	2b00      	cmp	r3, #0
 8026828:	d002      	beq.n	8026830 <mp_init_multi+0x4a>
        fp_init(e);
 802682a:	69b8      	ldr	r0, [r7, #24]
 802682c:	f7ff ff46 	bl	80266bc <fp_init>
    if (f)
 8026830:	69fb      	ldr	r3, [r7, #28]
 8026832:	2b00      	cmp	r3, #0
 8026834:	d002      	beq.n	802683c <mp_init_multi+0x56>
        fp_init(f);
 8026836:	69f8      	ldr	r0, [r7, #28]
 8026838:	f7ff ff40 	bl	80266bc <fp_init>

    return MP_OKAY;
 802683c:	2300      	movs	r3, #0
}
 802683e:	4618      	mov	r0, r3
 8026840:	3710      	adds	r7, #16
 8026842:	46bd      	mov	sp, r7
 8026844:	bd80      	pop	{r7, pc}

08026846 <mp_add>:

/* high level addition (handles signs) */
int mp_add (mp_int * a, mp_int * b, mp_int * c)
{
 8026846:	b580      	push	{r7, lr}
 8026848:	b084      	sub	sp, #16
 802684a:	af00      	add	r7, sp, #0
 802684c:	60f8      	str	r0, [r7, #12]
 802684e:	60b9      	str	r1, [r7, #8]
 8026850:	607a      	str	r2, [r7, #4]
  return fp_add(a, b, c);
 8026852:	687a      	ldr	r2, [r7, #4]
 8026854:	68b9      	ldr	r1, [r7, #8]
 8026856:	68f8      	ldr	r0, [r7, #12]
 8026858:	f7fb fd41 	bl	80222de <fp_add>
 802685c:	4603      	mov	r3, r0
}
 802685e:	4618      	mov	r0, r3
 8026860:	3710      	adds	r7, #16
 8026862:	46bd      	mov	sp, r7
 8026864:	bd80      	pop	{r7, pc}

08026866 <mp_sub>:

/* high level subtraction (handles signs) */
int mp_sub (mp_int * a, mp_int * b, mp_int * c)
{
 8026866:	b580      	push	{r7, lr}
 8026868:	b084      	sub	sp, #16
 802686a:	af00      	add	r7, sp, #0
 802686c:	60f8      	str	r0, [r7, #12]
 802686e:	60b9      	str	r1, [r7, #8]
 8026870:	607a      	str	r2, [r7, #4]
  return fp_sub(a, b, c);
 8026872:	687a      	ldr	r2, [r7, #4]
 8026874:	68b9      	ldr	r1, [r7, #8]
 8026876:	68f8      	ldr	r0, [r7, #12]
 8026878:	f7fb fe13 	bl	80224a2 <fp_sub>
 802687c:	4603      	mov	r3, r0
}
 802687e:	4618      	mov	r0, r3
 8026880:	3710      	adds	r7, #16
 8026882:	46bd      	mov	sp, r7
 8026884:	bd80      	pop	{r7, pc}

08026886 <mp_mul>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_mul(mp_int * a, mp_int * b, mp_int * c)
#else
int mp_mul (mp_int * a, mp_int * b, mp_int * c)
#endif
{
 8026886:	b580      	push	{r7, lr}
 8026888:	b084      	sub	sp, #16
 802688a:	af00      	add	r7, sp, #0
 802688c:	60f8      	str	r0, [r7, #12]
 802688e:	60b9      	str	r1, [r7, #8]
 8026890:	607a      	str	r2, [r7, #4]
  return fp_mul(a, b, c);
 8026892:	687a      	ldr	r2, [r7, #4]
 8026894:	68b9      	ldr	r1, [r7, #8]
 8026896:	68f8      	ldr	r0, [r7, #12]
 8026898:	f7fb ff07 	bl	80226aa <fp_mul>
 802689c:	4603      	mov	r3, r0
}
 802689e:	4618      	mov	r0, r3
 80268a0:	3710      	adds	r7, #16
 80268a2:	46bd      	mov	sp, r7
 80268a4:	bd80      	pop	{r7, pc}

080268a6 <mp_mulmod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_mulmod (mp_int * a, mp_int * b, mp_int * c, mp_int * d)
#else
int mp_mulmod (mp_int * a, mp_int * b, mp_int * c, mp_int * d)
#endif
{
 80268a6:	b580      	push	{r7, lr}
 80268a8:	b086      	sub	sp, #24
 80268aa:	af00      	add	r7, sp, #0
 80268ac:	60f8      	str	r0, [r7, #12]
 80268ae:	60b9      	str	r1, [r7, #8]
 80268b0:	607a      	str	r2, [r7, #4]
 80268b2:	603b      	str	r3, [r7, #0]
   int ret = MP_OKAY;
 80268b4:	2300      	movs	r3, #0
 80268b6:	617b      	str	r3, [r7, #20]
          * Future implementation may consider saving operands,
          * but hard errors should never actually occur. */
         break;
   }
#else /* no HW */
   ret = fp_mulmod(a, b, c, d);
 80268b8:	683b      	ldr	r3, [r7, #0]
 80268ba:	687a      	ldr	r2, [r7, #4]
 80268bc:	68b9      	ldr	r1, [r7, #8]
 80268be:	68f8      	ldr	r0, [r7, #12]
 80268c0:	f7fd fce9 	bl	8024296 <fp_mulmod>
 80268c4:	6178      	str	r0, [r7, #20]
#endif /* WOLFSSL_ESP32_CRYPT_RSA_PRI_MULMOD */
   return ret;
 80268c6:	697b      	ldr	r3, [r7, #20]
}
 80268c8:	4618      	mov	r0, r3
 80268ca:	3718      	adds	r7, #24
 80268cc:	46bd      	mov	sp, r7
 80268ce:	bd80      	pop	{r7, pc}

080268d0 <mp_submod_ct>:
  return fp_addmod(a, b, c, d);
}

/* d = a - b (mod c) - constant time (a < c and b < c) */
int mp_submod_ct(mp_int *a, mp_int *b, mp_int *c, mp_int *d)
{
 80268d0:	b580      	push	{r7, lr}
 80268d2:	b084      	sub	sp, #16
 80268d4:	af00      	add	r7, sp, #0
 80268d6:	60f8      	str	r0, [r7, #12]
 80268d8:	60b9      	str	r1, [r7, #8]
 80268da:	607a      	str	r2, [r7, #4]
 80268dc:	603b      	str	r3, [r7, #0]
  return fp_submod_ct(a, b, c, d);
 80268de:	683b      	ldr	r3, [r7, #0]
 80268e0:	687a      	ldr	r2, [r7, #4]
 80268e2:	68b9      	ldr	r1, [r7, #8]
 80268e4:	68f8      	ldr	r0, [r7, #12]
 80268e6:	f7fd fd16 	bl	8024316 <fp_submod_ct>
 80268ea:	4603      	mov	r3, r0
}
 80268ec:	4618      	mov	r0, r3
 80268ee:	3710      	adds	r7, #16
 80268f0:	46bd      	mov	sp, r7
 80268f2:	bd80      	pop	{r7, pc}

080268f4 <mp_addmod_ct>:

/* d = a + b (mod c) - constant time (a < c and b < c) */
int mp_addmod_ct(mp_int *a, mp_int *b, mp_int *c, mp_int *d)
{
 80268f4:	b580      	push	{r7, lr}
 80268f6:	b084      	sub	sp, #16
 80268f8:	af00      	add	r7, sp, #0
 80268fa:	60f8      	str	r0, [r7, #12]
 80268fc:	60b9      	str	r1, [r7, #8]
 80268fe:	607a      	str	r2, [r7, #4]
 8026900:	603b      	str	r3, [r7, #0]
  return fp_addmod_ct(a, b, c, d);
 8026902:	683b      	ldr	r3, [r7, #0]
 8026904:	687a      	ldr	r2, [r7, #4]
 8026906:	68b9      	ldr	r1, [r7, #8]
 8026908:	68f8      	ldr	r0, [r7, #12]
 802690a:	f7fd fe20 	bl	802454e <fp_addmod_ct>
 802690e:	4603      	mov	r3, r0
}
 8026910:	4618      	mov	r0, r3
 8026912:	3710      	adds	r7, #16
 8026914:	46bd      	mov	sp, r7
 8026916:	bd80      	pop	{r7, pc}

08026918 <mp_mod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_mod (mp_int * a, mp_int * b, mp_int * c)
#else
int mp_mod (mp_int * a, mp_int * b, mp_int * c)
#endif
{
 8026918:	b580      	push	{r7, lr}
 802691a:	b084      	sub	sp, #16
 802691c:	af00      	add	r7, sp, #0
 802691e:	60f8      	str	r0, [r7, #12]
 8026920:	60b9      	str	r1, [r7, #8]
 8026922:	607a      	str	r2, [r7, #4]
  return fp_mod (a, b, c);
 8026924:	687a      	ldr	r2, [r7, #4]
 8026926:	68b9      	ldr	r1, [r7, #8]
 8026928:	68f8      	ldr	r0, [r7, #12]
 802692a:	f7fc fe57 	bl	80235dc <fp_mod>
 802692e:	4603      	mov	r3, r0
}
 8026930:	4618      	mov	r0, r3
 8026932:	3710      	adds	r7, #16
 8026934:	46bd      	mov	sp, r7
 8026936:	bd80      	pop	{r7, pc}

08026938 <mp_invmod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_invmod (mp_int * a, mp_int * b, mp_int * c)
#else
int mp_invmod (mp_int * a, mp_int * b, mp_int * c)
#endif
{
 8026938:	b580      	push	{r7, lr}
 802693a:	b084      	sub	sp, #16
 802693c:	af00      	add	r7, sp, #0
 802693e:	60f8      	str	r0, [r7, #12]
 8026940:	60b9      	str	r1, [r7, #8]
 8026942:	607a      	str	r2, [r7, #4]
  return fp_invmod(a, b, c);
 8026944:	687a      	ldr	r2, [r7, #4]
 8026946:	68b9      	ldr	r1, [r7, #8]
 8026948:	68f8      	ldr	r0, [r7, #12]
 802694a:	f7fd f99e 	bl	8023c8a <fp_invmod>
 802694e:	4603      	mov	r3, r0
}
 8026950:	4618      	mov	r0, r3
 8026952:	3710      	adds	r7, #16
 8026954:	46bd      	mov	sp, r7
 8026956:	bd80      	pop	{r7, pc}

08026958 <mp_invmod_mont_ct>:

/* hac 14.61, pp608 */
int mp_invmod_mont_ct (mp_int * a, mp_int * b, mp_int * c, mp_digit mp)
{
 8026958:	b580      	push	{r7, lr}
 802695a:	b084      	sub	sp, #16
 802695c:	af00      	add	r7, sp, #0
 802695e:	60f8      	str	r0, [r7, #12]
 8026960:	60b9      	str	r1, [r7, #8]
 8026962:	607a      	str	r2, [r7, #4]
 8026964:	603b      	str	r3, [r7, #0]
  return fp_invmod_mont_ct(a, b, c, mp);
 8026966:	683b      	ldr	r3, [r7, #0]
 8026968:	687a      	ldr	r2, [r7, #4]
 802696a:	68b9      	ldr	r1, [r7, #8]
 802696c:	68f8      	ldr	r0, [r7, #12]
 802696e:	f7fd fb4f 	bl	8024010 <fp_invmod_mont_ct>
 8026972:	4603      	mov	r3, r0
}
 8026974:	4618      	mov	r0, r3
 8026976:	3710      	adds	r7, #16
 8026978:	46bd      	mov	sp, r7
 802697a:	bd80      	pop	{r7, pc}

0802697c <mp_exptmod>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_exptmod (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#else
int mp_exptmod (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#endif
{
 802697c:	b580      	push	{r7, lr}
 802697e:	b084      	sub	sp, #16
 8026980:	af00      	add	r7, sp, #0
 8026982:	60f8      	str	r0, [r7, #12]
 8026984:	60b9      	str	r1, [r7, #8]
 8026986:	607a      	str	r2, [r7, #4]
 8026988:	603b      	str	r3, [r7, #0]
  return fp_exptmod(G, X, P, Y);
 802698a:	683b      	ldr	r3, [r7, #0]
 802698c:	687a      	ldr	r2, [r7, #4]
 802698e:	68b9      	ldr	r1, [r7, #8]
 8026990:	68f8      	ldr	r0, [r7, #12]
 8026992:	f7fe fcbf 	bl	8025314 <fp_exptmod>
 8026996:	4603      	mov	r3, r0
}
 8026998:	4618      	mov	r0, r3
 802699a:	3710      	adds	r7, #16
 802699c:	46bd      	mov	sp, r7
 802699e:	bd80      	pop	{r7, pc}

080269a0 <mp_exptmod_nct>:
#if defined(FREESCALE_LTC_TFM)
int wolfcrypt_mp_exptmod_nct (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#else
int mp_exptmod_nct (mp_int * G, mp_int * X, mp_int * P, mp_int * Y)
#endif
{
 80269a0:	b580      	push	{r7, lr}
 80269a2:	b084      	sub	sp, #16
 80269a4:	af00      	add	r7, sp, #0
 80269a6:	60f8      	str	r0, [r7, #12]
 80269a8:	60b9      	str	r1, [r7, #8]
 80269aa:	607a      	str	r2, [r7, #4]
 80269ac:	603b      	str	r3, [r7, #0]
  return fp_exptmod_nct(G, X, P, Y);
 80269ae:	683b      	ldr	r3, [r7, #0]
 80269b0:	687a      	ldr	r2, [r7, #4]
 80269b2:	68b9      	ldr	r1, [r7, #8]
 80269b4:	68f8      	ldr	r0, [r7, #12]
 80269b6:	f7fe fd60 	bl	802547a <fp_exptmod_nct>
 80269ba:	4603      	mov	r3, r0
}
 80269bc:	4618      	mov	r0, r3
 80269be:	3710      	adds	r7, #16
 80269c0:	46bd      	mov	sp, r7
 80269c2:	bd80      	pop	{r7, pc}

080269c4 <mp_cmp>:


/* compare two ints (signed)*/
int mp_cmp (mp_int * a, mp_int * b)
{
 80269c4:	b580      	push	{r7, lr}
 80269c6:	b082      	sub	sp, #8
 80269c8:	af00      	add	r7, sp, #0
 80269ca:	6078      	str	r0, [r7, #4]
 80269cc:	6039      	str	r1, [r7, #0]
  return fp_cmp(a, b);
 80269ce:	6839      	ldr	r1, [r7, #0]
 80269d0:	6878      	ldr	r0, [r7, #4]
 80269d2:	f7ff f859 	bl	8025a88 <fp_cmp>
 80269d6:	4603      	mov	r3, r0
}
 80269d8:	4618      	mov	r0, r3
 80269da:	3708      	adds	r7, #8
 80269dc:	46bd      	mov	sp, r7
 80269de:	bd80      	pop	{r7, pc}

080269e0 <mp_cmp_d>:

/* compare a digit */
int mp_cmp_d(mp_int * a, mp_digit b)
{
 80269e0:	b580      	push	{r7, lr}
 80269e2:	b082      	sub	sp, #8
 80269e4:	af00      	add	r7, sp, #0
 80269e6:	6078      	str	r0, [r7, #4]
 80269e8:	6039      	str	r1, [r7, #0]
  return fp_cmp_d(a, b);
 80269ea:	6839      	ldr	r1, [r7, #0]
 80269ec:	6878      	ldr	r0, [r7, #4]
 80269ee:	f7ff f878 	bl	8025ae2 <fp_cmp_d>
 80269f2:	4603      	mov	r3, r0
}
 80269f4:	4618      	mov	r0, r3
 80269f6:	3708      	adds	r7, #8
 80269f8:	46bd      	mov	sp, r7
 80269fa:	bd80      	pop	{r7, pc}

080269fc <mp_unsigned_bin_size>:

/* get the size for an unsigned equivalent */
int mp_unsigned_bin_size (const mp_int * a)
{
 80269fc:	b580      	push	{r7, lr}
 80269fe:	b082      	sub	sp, #8
 8026a00:	af00      	add	r7, sp, #0
 8026a02:	6078      	str	r0, [r7, #4]
  return fp_unsigned_bin_size(a);
 8026a04:	6878      	ldr	r0, [r7, #4]
 8026a06:	f7ff fc0f 	bl	8026228 <fp_unsigned_bin_size>
 8026a0a:	4603      	mov	r3, r0
}
 8026a0c:	4618      	mov	r0, r3
 8026a0e:	3708      	adds	r7, #8
 8026a10:	46bd      	mov	sp, r7
 8026a12:	bd80      	pop	{r7, pc}

08026a14 <mp_to_unsigned_bin>:
  return fp_to_unsigned_bin_at_pos(x, t, b);
}

/* store in unsigned [big endian] format */
int mp_to_unsigned_bin (mp_int * a, unsigned char *b)
{
 8026a14:	b580      	push	{r7, lr}
 8026a16:	b082      	sub	sp, #8
 8026a18:	af00      	add	r7, sp, #0
 8026a1a:	6078      	str	r0, [r7, #4]
 8026a1c:	6039      	str	r1, [r7, #0]
  return fp_to_unsigned_bin(a,b);
 8026a1e:	6839      	ldr	r1, [r7, #0]
 8026a20:	6878      	ldr	r0, [r7, #4]
 8026a22:	f7ff fb6e 	bl	8026102 <fp_to_unsigned_bin>
 8026a26:	4603      	mov	r3, r0
}
 8026a28:	4618      	mov	r0, r3
 8026a2a:	3708      	adds	r7, #8
 8026a2c:	46bd      	mov	sp, r7
 8026a2e:	bd80      	pop	{r7, pc}

08026a30 <mp_to_unsigned_bin_len>:

int mp_to_unsigned_bin_len(mp_int * a, unsigned char *b, int c)
{
 8026a30:	b580      	push	{r7, lr}
 8026a32:	b084      	sub	sp, #16
 8026a34:	af00      	add	r7, sp, #0
 8026a36:	60f8      	str	r0, [r7, #12]
 8026a38:	60b9      	str	r1, [r7, #8]
 8026a3a:	607a      	str	r2, [r7, #4]
  return fp_to_unsigned_bin_len(a, b, c);
 8026a3c:	687a      	ldr	r2, [r7, #4]
 8026a3e:	68b9      	ldr	r1, [r7, #8]
 8026a40:	68f8      	ldr	r0, [r7, #12]
 8026a42:	f7ff fb89 	bl	8026158 <fp_to_unsigned_bin_len>
 8026a46:	4603      	mov	r3, r0
}
 8026a48:	4618      	mov	r0, r3
 8026a4a:	3710      	adds	r7, #16
 8026a4c:	46bd      	mov	sp, r7
 8026a4e:	bd80      	pop	{r7, pc}

08026a50 <mp_read_unsigned_bin>:
/* reads a unsigned char array, assumes the msb is stored first [big endian] */
int mp_read_unsigned_bin (mp_int * a, const unsigned char *b, int c)
{
 8026a50:	b580      	push	{r7, lr}
 8026a52:	b084      	sub	sp, #16
 8026a54:	af00      	add	r7, sp, #0
 8026a56:	60f8      	str	r0, [r7, #12]
 8026a58:	60b9      	str	r1, [r7, #8]
 8026a5a:	607a      	str	r2, [r7, #4]
  return fp_read_unsigned_bin(a, b, c);
 8026a5c:	687a      	ldr	r2, [r7, #4]
 8026a5e:	68b9      	ldr	r1, [r7, #8]
 8026a60:	68f8      	ldr	r0, [r7, #12]
 8026a62:	f7ff fa97 	bl	8025f94 <fp_read_unsigned_bin>
 8026a66:	4603      	mov	r3, r0
}
 8026a68:	4618      	mov	r0, r3
 8026a6a:	3710      	adds	r7, #16
 8026a6c:	46bd      	mov	sp, r7
 8026a6e:	bd80      	pop	{r7, pc}

08026a70 <mp_sub_d>:


int mp_sub_d(fp_int *a, fp_digit b, fp_int *c)
{
 8026a70:	b580      	push	{r7, lr}
 8026a72:	b084      	sub	sp, #16
 8026a74:	af00      	add	r7, sp, #0
 8026a76:	60f8      	str	r0, [r7, #12]
 8026a78:	60b9      	str	r1, [r7, #8]
 8026a7a:	607a      	str	r2, [r7, #4]
  return fp_sub_d(a, b, c);
 8026a7c:	687a      	ldr	r2, [r7, #4]
 8026a7e:	68b9      	ldr	r1, [r7, #8]
 8026a80:	68f8      	ldr	r0, [r7, #12]
 8026a82:	f7ff fdd0 	bl	8026626 <fp_sub_d>
 8026a86:	4603      	mov	r3, r0
}
 8026a88:	4618      	mov	r0, r3
 8026a8a:	3710      	adds	r7, #16
 8026a8c:	46bd      	mov	sp, r7
 8026a8e:	bd80      	pop	{r7, pc}

08026a90 <fp_copy>:
  return MP_OKAY;
}

/* copy (src = a) to (dst = b) */
void fp_copy(const fp_int *a, fp_int *b)
{
 8026a90:	b580      	push	{r7, lr}
 8026a92:	b084      	sub	sp, #16
 8026a94:	af00      	add	r7, sp, #0
 8026a96:	6078      	str	r0, [r7, #4]
 8026a98:	6039      	str	r1, [r7, #0]
    /* if source and destination are different */
    if (a != b) {
 8026a9a:	687a      	ldr	r2, [r7, #4]
 8026a9c:	683b      	ldr	r3, [r7, #0]
 8026a9e:	429a      	cmp	r2, r3
 8026aa0:	d031      	beq.n	8026b06 <fp_copy+0x76>
#if defined(ALT_ECC_SIZE) || defined(HAVE_WOLF_BIGINT)
        /* verify a will fit in b */
        if (b->size >= a->used) {
 8026aa2:	683b      	ldr	r3, [r7, #0]
 8026aa4:	689a      	ldr	r2, [r3, #8]
 8026aa6:	687b      	ldr	r3, [r7, #4]
 8026aa8:	681b      	ldr	r3, [r3, #0]
 8026aaa:	429a      	cmp	r2, r3
 8026aac:	db2b      	blt.n	8026b06 <fp_copy+0x76>
            int x, oldused;
            oldused = b->used;
 8026aae:	683b      	ldr	r3, [r7, #0]
 8026ab0:	681b      	ldr	r3, [r3, #0]
 8026ab2:	60bb      	str	r3, [r7, #8]
            b->used = a->used;
 8026ab4:	687b      	ldr	r3, [r7, #4]
 8026ab6:	681a      	ldr	r2, [r3, #0]
 8026ab8:	683b      	ldr	r3, [r7, #0]
 8026aba:	601a      	str	r2, [r3, #0]
            b->sign = a->sign;
 8026abc:	687b      	ldr	r3, [r7, #4]
 8026abe:	685a      	ldr	r2, [r3, #4]
 8026ac0:	683b      	ldr	r3, [r7, #0]
 8026ac2:	605a      	str	r2, [r3, #4]

            XMEMCPY(b->dp, a->dp, a->used * sizeof(fp_digit));
 8026ac4:	683b      	ldr	r3, [r7, #0]
 8026ac6:	f103 000c 	add.w	r0, r3, #12
 8026aca:	687b      	ldr	r3, [r7, #4]
 8026acc:	f103 010c 	add.w	r1, r3, #12
 8026ad0:	687b      	ldr	r3, [r7, #4]
 8026ad2:	681b      	ldr	r3, [r3, #0]
 8026ad4:	009b      	lsls	r3, r3, #2
 8026ad6:	461a      	mov	r2, r3
 8026ad8:	f001 fd64 	bl	80285a4 <memcpy>

            /* zero any excess digits on the destination that we didn't write to */
            for (x = b->used; x >= 0 && x < oldused; x++) {
 8026adc:	683b      	ldr	r3, [r7, #0]
 8026ade:	681b      	ldr	r3, [r3, #0]
 8026ae0:	60fb      	str	r3, [r7, #12]
 8026ae2:	e009      	b.n	8026af8 <fp_copy+0x68>
                b->dp[x] = 0;
 8026ae4:	683a      	ldr	r2, [r7, #0]
 8026ae6:	68fb      	ldr	r3, [r7, #12]
 8026ae8:	3302      	adds	r3, #2
 8026aea:	009b      	lsls	r3, r3, #2
 8026aec:	4413      	add	r3, r2
 8026aee:	2200      	movs	r2, #0
 8026af0:	605a      	str	r2, [r3, #4]
            for (x = b->used; x >= 0 && x < oldused; x++) {
 8026af2:	68fb      	ldr	r3, [r7, #12]
 8026af4:	3301      	adds	r3, #1
 8026af6:	60fb      	str	r3, [r7, #12]
 8026af8:	68fb      	ldr	r3, [r7, #12]
 8026afa:	2b00      	cmp	r3, #0
 8026afc:	db03      	blt.n	8026b06 <fp_copy+0x76>
 8026afe:	68fa      	ldr	r2, [r7, #12]
 8026b00:	68bb      	ldr	r3, [r7, #8]
 8026b02:	429a      	cmp	r2, r3
 8026b04:	dbee      	blt.n	8026ae4 <fp_copy+0x54>
        b->used = a->used;
        b->sign = a->sign;
        XMEMCPY(b->dp, a->dp, FP_SIZE * sizeof(fp_digit));
#endif
    }
}
 8026b06:	bf00      	nop
 8026b08:	3710      	adds	r7, #16
 8026b0a:	46bd      	mov	sp, r7
 8026b0c:	bd80      	pop	{r7, pc}

08026b0e <fp_init_copy>:
    return MP_OKAY;
}

/* Copy (dst = a) from (src = b) */
void fp_init_copy(fp_int *a, fp_int* b)
{
 8026b0e:	b580      	push	{r7, lr}
 8026b10:	b082      	sub	sp, #8
 8026b12:	af00      	add	r7, sp, #0
 8026b14:	6078      	str	r0, [r7, #4]
 8026b16:	6039      	str	r1, [r7, #0]
    if (a != b) {
 8026b18:	687a      	ldr	r2, [r7, #4]
 8026b1a:	683b      	ldr	r3, [r7, #0]
 8026b1c:	429a      	cmp	r2, r3
 8026b1e:	d006      	beq.n	8026b2e <fp_init_copy+0x20>
        fp_init(a);
 8026b20:	6878      	ldr	r0, [r7, #4]
 8026b22:	f7ff fdcb 	bl	80266bc <fp_init>
        /* Note reversed parameter order! */
        fp_copy(b, a); /* copy (src = b) to (dst = a) */
 8026b26:	6879      	ldr	r1, [r7, #4]
 8026b28:	6838      	ldr	r0, [r7, #0]
 8026b2a:	f7ff ffb1 	bl	8026a90 <fp_copy>
    }
}
 8026b2e:	bf00      	nop
 8026b30:	3708      	adds	r7, #8
 8026b32:	46bd      	mov	sp, r7
 8026b34:	bd80      	pop	{r7, pc}

08026b36 <mp_copy>:

/* fast math wrappers */
int mp_copy(const fp_int* a, fp_int* b)
{
 8026b36:	b580      	push	{r7, lr}
 8026b38:	b082      	sub	sp, #8
 8026b3a:	af00      	add	r7, sp, #0
 8026b3c:	6078      	str	r0, [r7, #4]
 8026b3e:	6039      	str	r1, [r7, #0]
    fp_copy(a, b);
 8026b40:	6839      	ldr	r1, [r7, #0]
 8026b42:	6878      	ldr	r0, [r7, #4]
 8026b44:	f7ff ffa4 	bl	8026a90 <fp_copy>
    return MP_OKAY;
 8026b48:	2300      	movs	r3, #0
}
 8026b4a:	4618      	mov	r0, r3
 8026b4c:	3708      	adds	r7, #8
 8026b4e:	46bd      	mov	sp, r7
 8026b50:	bd80      	pop	{r7, pc}

08026b52 <mp_iszero>:
{
    return fp_isodd(a);
}

int mp_iszero(const mp_int* a)
{
 8026b52:	b480      	push	{r7}
 8026b54:	b083      	sub	sp, #12
 8026b56:	af00      	add	r7, sp, #0
 8026b58:	6078      	str	r0, [r7, #4]
    return fp_iszero(a);
 8026b5a:	687b      	ldr	r3, [r7, #4]
 8026b5c:	681b      	ldr	r3, [r3, #0]
 8026b5e:	2b00      	cmp	r3, #0
 8026b60:	bf0c      	ite	eq
 8026b62:	2301      	moveq	r3, #1
 8026b64:	2300      	movne	r3, #0
 8026b66:	b2db      	uxtb	r3, r3
}
 8026b68:	4618      	mov	r0, r3
 8026b6a:	370c      	adds	r7, #12
 8026b6c:	46bd      	mov	sp, r7
 8026b6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026b72:	4770      	bx	lr

08026b74 <mp_count_bits>:

int mp_count_bits (const mp_int* a)
{
 8026b74:	b580      	push	{r7, lr}
 8026b76:	b082      	sub	sp, #8
 8026b78:	af00      	add	r7, sp, #0
 8026b7a:	6078      	str	r0, [r7, #4]
    return fp_count_bits(a);
 8026b7c:	6878      	ldr	r0, [r7, #4]
 8026b7e:	f7ff fbb1 	bl	80262e4 <fp_count_bits>
 8026b82:	4603      	mov	r3, r0
}
 8026b84:	4618      	mov	r0, r3
 8026b86:	3708      	adds	r7, #8
 8026b88:	46bd      	mov	sp, r7
 8026b8a:	bd80      	pop	{r7, pc}

08026b8c <mp_leading_bit>:

int mp_leading_bit (mp_int* a)
{
 8026b8c:	b580      	push	{r7, lr}
 8026b8e:	b082      	sub	sp, #8
 8026b90:	af00      	add	r7, sp, #0
 8026b92:	6078      	str	r0, [r7, #4]
    return fp_leading_bit(a);
 8026b94:	6878      	ldr	r0, [r7, #4]
 8026b96:	f7ff fbce 	bl	8026336 <fp_leading_bit>
 8026b9a:	4603      	mov	r3, r0
}
 8026b9c:	4618      	mov	r0, r3
 8026b9e:	3708      	adds	r7, #8
 8026ba0:	46bd      	mov	sp, r7
 8026ba2:	bd80      	pop	{r7, pc}

08026ba4 <mp_rshb>:

void mp_rshb (mp_int* a, int x)
{
 8026ba4:	b580      	push	{r7, lr}
 8026ba6:	b082      	sub	sp, #8
 8026ba8:	af00      	add	r7, sp, #0
 8026baa:	6078      	str	r0, [r7, #4]
 8026bac:	6039      	str	r1, [r7, #0]
    fp_rshb(a, x);
 8026bae:	6839      	ldr	r1, [r7, #0]
 8026bb0:	6878      	ldr	r0, [r7, #4]
 8026bb2:	f7ff fc54 	bl	802645e <fp_rshb>
}
 8026bb6:	bf00      	nop
 8026bb8:	3708      	adds	r7, #8
 8026bba:	46bd      	mov	sp, r7
 8026bbc:	bd80      	pop	{r7, pc}

08026bbe <mp_montgomery_calc_normalization>:
    return fp_sqrmod(a, b, c);
}

/* fast math conversion */
int mp_montgomery_calc_normalization(mp_int *a, mp_int *b)
{
 8026bbe:	b580      	push	{r7, lr}
 8026bc0:	b082      	sub	sp, #8
 8026bc2:	af00      	add	r7, sp, #0
 8026bc4:	6078      	str	r0, [r7, #4]
 8026bc6:	6039      	str	r1, [r7, #0]
    return fp_montgomery_calc_normalization(a, b);
 8026bc8:	6839      	ldr	r1, [r7, #0]
 8026bca:	6878      	ldr	r0, [r7, #4]
 8026bcc:	f7ff f84b 	bl	8025c66 <fp_montgomery_calc_normalization>
 8026bd0:	4603      	mov	r3, r0
}
 8026bd2:	4618      	mov	r0, r3
 8026bd4:	3708      	adds	r7, #8
 8026bd6:	46bd      	mov	sp, r7
 8026bd8:	bd80      	pop	{r7, pc}

08026bda <fp_cond_swap_ct_ex>:

#endif /* WOLFSSL_KEY_GEN || HAVE_ECC */

static int fp_cond_swap_ct_ex(mp_int* a, mp_int* b, int c, int m, mp_int* t)
{
 8026bda:	b480      	push	{r7}
 8026bdc:	b087      	sub	sp, #28
 8026bde:	af00      	add	r7, sp, #0
 8026be0:	60f8      	str	r0, [r7, #12]
 8026be2:	60b9      	str	r1, [r7, #8]
 8026be4:	607a      	str	r2, [r7, #4]
 8026be6:	603b      	str	r3, [r7, #0]
    int i;
    mp_digit mask = (mp_digit)0 - m;
 8026be8:	683b      	ldr	r3, [r7, #0]
 8026bea:	425b      	negs	r3, r3
 8026bec:	613b      	str	r3, [r7, #16]

    t->used = (a->used ^ b->used) & mask;
 8026bee:	68fb      	ldr	r3, [r7, #12]
 8026bf0:	681a      	ldr	r2, [r3, #0]
 8026bf2:	68bb      	ldr	r3, [r7, #8]
 8026bf4:	681b      	ldr	r3, [r3, #0]
 8026bf6:	4053      	eors	r3, r2
 8026bf8:	461a      	mov	r2, r3
 8026bfa:	693b      	ldr	r3, [r7, #16]
 8026bfc:	4013      	ands	r3, r2
 8026bfe:	461a      	mov	r2, r3
 8026c00:	6a3b      	ldr	r3, [r7, #32]
 8026c02:	601a      	str	r2, [r3, #0]
    for (i = 0; i < c; i++) {
 8026c04:	2300      	movs	r3, #0
 8026c06:	617b      	str	r3, [r7, #20]
 8026c08:	e017      	b.n	8026c3a <fp_cond_swap_ct_ex+0x60>
        t->dp[i] = (a->dp[i] ^ b->dp[i]) & mask;
 8026c0a:	68fa      	ldr	r2, [r7, #12]
 8026c0c:	697b      	ldr	r3, [r7, #20]
 8026c0e:	3302      	adds	r3, #2
 8026c10:	009b      	lsls	r3, r3, #2
 8026c12:	4413      	add	r3, r2
 8026c14:	685a      	ldr	r2, [r3, #4]
 8026c16:	68b9      	ldr	r1, [r7, #8]
 8026c18:	697b      	ldr	r3, [r7, #20]
 8026c1a:	3302      	adds	r3, #2
 8026c1c:	009b      	lsls	r3, r3, #2
 8026c1e:	440b      	add	r3, r1
 8026c20:	685b      	ldr	r3, [r3, #4]
 8026c22:	405a      	eors	r2, r3
 8026c24:	693b      	ldr	r3, [r7, #16]
 8026c26:	401a      	ands	r2, r3
 8026c28:	6a39      	ldr	r1, [r7, #32]
 8026c2a:	697b      	ldr	r3, [r7, #20]
 8026c2c:	3302      	adds	r3, #2
 8026c2e:	009b      	lsls	r3, r3, #2
 8026c30:	440b      	add	r3, r1
 8026c32:	605a      	str	r2, [r3, #4]
    for (i = 0; i < c; i++) {
 8026c34:	697b      	ldr	r3, [r7, #20]
 8026c36:	3301      	adds	r3, #1
 8026c38:	617b      	str	r3, [r7, #20]
 8026c3a:	697a      	ldr	r2, [r7, #20]
 8026c3c:	687b      	ldr	r3, [r7, #4]
 8026c3e:	429a      	cmp	r2, r3
 8026c40:	dbe3      	blt.n	8026c0a <fp_cond_swap_ct_ex+0x30>
    }
    a->used ^= t->used;
 8026c42:	68fb      	ldr	r3, [r7, #12]
 8026c44:	681a      	ldr	r2, [r3, #0]
 8026c46:	6a3b      	ldr	r3, [r7, #32]
 8026c48:	681b      	ldr	r3, [r3, #0]
 8026c4a:	405a      	eors	r2, r3
 8026c4c:	68fb      	ldr	r3, [r7, #12]
 8026c4e:	601a      	str	r2, [r3, #0]
    for (i = 0; i < c; i++) {
 8026c50:	2300      	movs	r3, #0
 8026c52:	617b      	str	r3, [r7, #20]
 8026c54:	e015      	b.n	8026c82 <fp_cond_swap_ct_ex+0xa8>
        a->dp[i] ^= t->dp[i];
 8026c56:	68fa      	ldr	r2, [r7, #12]
 8026c58:	697b      	ldr	r3, [r7, #20]
 8026c5a:	3302      	adds	r3, #2
 8026c5c:	009b      	lsls	r3, r3, #2
 8026c5e:	4413      	add	r3, r2
 8026c60:	685a      	ldr	r2, [r3, #4]
 8026c62:	6a39      	ldr	r1, [r7, #32]
 8026c64:	697b      	ldr	r3, [r7, #20]
 8026c66:	3302      	adds	r3, #2
 8026c68:	009b      	lsls	r3, r3, #2
 8026c6a:	440b      	add	r3, r1
 8026c6c:	685b      	ldr	r3, [r3, #4]
 8026c6e:	405a      	eors	r2, r3
 8026c70:	68f9      	ldr	r1, [r7, #12]
 8026c72:	697b      	ldr	r3, [r7, #20]
 8026c74:	3302      	adds	r3, #2
 8026c76:	009b      	lsls	r3, r3, #2
 8026c78:	440b      	add	r3, r1
 8026c7a:	605a      	str	r2, [r3, #4]
    for (i = 0; i < c; i++) {
 8026c7c:	697b      	ldr	r3, [r7, #20]
 8026c7e:	3301      	adds	r3, #1
 8026c80:	617b      	str	r3, [r7, #20]
 8026c82:	697a      	ldr	r2, [r7, #20]
 8026c84:	687b      	ldr	r3, [r7, #4]
 8026c86:	429a      	cmp	r2, r3
 8026c88:	dbe5      	blt.n	8026c56 <fp_cond_swap_ct_ex+0x7c>
    }
    b->used ^= t->used;
 8026c8a:	68bb      	ldr	r3, [r7, #8]
 8026c8c:	681a      	ldr	r2, [r3, #0]
 8026c8e:	6a3b      	ldr	r3, [r7, #32]
 8026c90:	681b      	ldr	r3, [r3, #0]
 8026c92:	405a      	eors	r2, r3
 8026c94:	68bb      	ldr	r3, [r7, #8]
 8026c96:	601a      	str	r2, [r3, #0]
    for (i = 0; i < c; i++) {
 8026c98:	2300      	movs	r3, #0
 8026c9a:	617b      	str	r3, [r7, #20]
 8026c9c:	e015      	b.n	8026cca <fp_cond_swap_ct_ex+0xf0>
        b->dp[i] ^= t->dp[i];
 8026c9e:	68ba      	ldr	r2, [r7, #8]
 8026ca0:	697b      	ldr	r3, [r7, #20]
 8026ca2:	3302      	adds	r3, #2
 8026ca4:	009b      	lsls	r3, r3, #2
 8026ca6:	4413      	add	r3, r2
 8026ca8:	685a      	ldr	r2, [r3, #4]
 8026caa:	6a39      	ldr	r1, [r7, #32]
 8026cac:	697b      	ldr	r3, [r7, #20]
 8026cae:	3302      	adds	r3, #2
 8026cb0:	009b      	lsls	r3, r3, #2
 8026cb2:	440b      	add	r3, r1
 8026cb4:	685b      	ldr	r3, [r3, #4]
 8026cb6:	405a      	eors	r2, r3
 8026cb8:	68b9      	ldr	r1, [r7, #8]
 8026cba:	697b      	ldr	r3, [r7, #20]
 8026cbc:	3302      	adds	r3, #2
 8026cbe:	009b      	lsls	r3, r3, #2
 8026cc0:	440b      	add	r3, r1
 8026cc2:	605a      	str	r2, [r3, #4]
    for (i = 0; i < c; i++) {
 8026cc4:	697b      	ldr	r3, [r7, #20]
 8026cc6:	3301      	adds	r3, #1
 8026cc8:	617b      	str	r3, [r7, #20]
 8026cca:	697a      	ldr	r2, [r7, #20]
 8026ccc:	687b      	ldr	r3, [r7, #4]
 8026cce:	429a      	cmp	r2, r3
 8026cd0:	dbe5      	blt.n	8026c9e <fp_cond_swap_ct_ex+0xc4>
    }

    return FP_OKAY;
 8026cd2:	2300      	movs	r3, #0
}
 8026cd4:	4618      	mov	r0, r3
 8026cd6:	371c      	adds	r7, #28
 8026cd8:	46bd      	mov	sp, r7
 8026cda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026cde:	4770      	bx	lr

08026ce0 <mp_cond_swap_ct_ex>:
}
#endif /* !NO_RSA || !NO_DSA || !NO_DH || WOLFSSL_KEY_GEN */


int mp_cond_swap_ct_ex(mp_int* a, mp_int* b, int c, int m, mp_int* t)
{
 8026ce0:	b580      	push	{r7, lr}
 8026ce2:	b086      	sub	sp, #24
 8026ce4:	af02      	add	r7, sp, #8
 8026ce6:	60f8      	str	r0, [r7, #12]
 8026ce8:	60b9      	str	r1, [r7, #8]
 8026cea:	607a      	str	r2, [r7, #4]
 8026cec:	603b      	str	r3, [r7, #0]
    return fp_cond_swap_ct_ex(a, b, c, m, t);
 8026cee:	69bb      	ldr	r3, [r7, #24]
 8026cf0:	9300      	str	r3, [sp, #0]
 8026cf2:	683b      	ldr	r3, [r7, #0]
 8026cf4:	687a      	ldr	r2, [r7, #4]
 8026cf6:	68b9      	ldr	r1, [r7, #8]
 8026cf8:	68f8      	ldr	r0, [r7, #12]
 8026cfa:	f7ff ff6e 	bl	8026bda <fp_cond_swap_ct_ex>
 8026cfe:	4603      	mov	r3, r0
}
 8026d00:	4618      	mov	r0, r3
 8026d02:	3710      	adds	r7, #16
 8026d04:	46bd      	mov	sp, r7
 8026d06:	bd80      	pop	{r7, pc}

08026d08 <fp_add_d>:
#if defined(HAVE_ECC) || !defined(NO_PWDBASED) || defined(OPENSSL_EXTRA) || \
    defined(WC_RSA_BLINDING) || !defined(NO_DSA) || \
    (!defined(NO_RSA) && !defined(NO_RSA_BOUNDS_CHECK))
/* c = a + b */
int fp_add_d(fp_int *a, fp_digit b, fp_int *c)
{
 8026d08:	b580      	push	{r7, lr}
 8026d0a:	b088      	sub	sp, #32
 8026d0c:	af00      	add	r7, sp, #0
 8026d0e:	60f8      	str	r0, [r7, #12]
 8026d10:	60b9      	str	r1, [r7, #8]
 8026d12:	607a      	str	r2, [r7, #4]
   fp_int* tmp;
#endif
   int     err;

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
 8026d14:	f44f 700b 	mov.w	r0, #556	@ 0x22c
 8026d18:	f7f7 febc 	bl	801ea94 <wolfSSL_Malloc>
 8026d1c:	61f8      	str	r0, [r7, #28]
   if (tmp == NULL)
 8026d1e:	69fb      	ldr	r3, [r7, #28]
 8026d20:	2b00      	cmp	r3, #0
 8026d22:	d102      	bne.n	8026d2a <fp_add_d+0x22>
       return FP_MEM;
 8026d24:	f06f 0360 	mvn.w	r3, #96	@ 0x60
 8026d28:	e015      	b.n	8026d56 <fp_add_d+0x4e>
#endif

   fp_init(tmp);
 8026d2a:	69f8      	ldr	r0, [r7, #28]
 8026d2c:	f7ff fcc6 	bl	80266bc <fp_init>
   fp_set(tmp, b);
 8026d30:	68b9      	ldr	r1, [r7, #8]
 8026d32:	69f8      	ldr	r0, [r7, #28]
 8026d34:	f7ff fa93 	bl	802625e <fp_set>
   err = fp_add(a, tmp, c);
 8026d38:	687a      	ldr	r2, [r7, #4]
 8026d3a:	69f9      	ldr	r1, [r7, #28]
 8026d3c:	68f8      	ldr	r0, [r7, #12]
 8026d3e:	f7fb face 	bl	80222de <fp_add>
 8026d42:	61b8      	str	r0, [r7, #24]

#ifdef WOLFSSL_SMALL_STACK
   XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
 8026d44:	69fb      	ldr	r3, [r7, #28]
 8026d46:	617b      	str	r3, [r7, #20]
 8026d48:	697b      	ldr	r3, [r7, #20]
 8026d4a:	2b00      	cmp	r3, #0
 8026d4c:	d002      	beq.n	8026d54 <fp_add_d+0x4c>
 8026d4e:	6978      	ldr	r0, [r7, #20]
 8026d50:	f7f7 febc 	bl	801eacc <wolfSSL_Free>
#endif
   return err;
 8026d54:	69bb      	ldr	r3, [r7, #24]
}
 8026d56:	4618      	mov	r0, r3
 8026d58:	3720      	adds	r7, #32
 8026d5a:	46bd      	mov	sp, r7
 8026d5c:	bd80      	pop	{r7, pc}

08026d5e <mp_add_d>:

/* external compatibility */
int mp_add_d(fp_int *a, fp_digit b, fp_int *c)
{
 8026d5e:	b580      	push	{r7, lr}
 8026d60:	b084      	sub	sp, #16
 8026d62:	af00      	add	r7, sp, #0
 8026d64:	60f8      	str	r0, [r7, #12]
 8026d66:	60b9      	str	r1, [r7, #8]
 8026d68:	607a      	str	r2, [r7, #4]
    return fp_add_d(a, b, c);
 8026d6a:	687a      	ldr	r2, [r7, #4]
 8026d6c:	68b9      	ldr	r1, [r7, #8]
 8026d6e:	68f8      	ldr	r0, [r7, #12]
 8026d70:	f7ff ffca 	bl	8026d08 <fp_add_d>
 8026d74:	4603      	mov	r3, r0
}
 8026d76:	4618      	mov	r0, r3
 8026d78:	3710      	adds	r7, #16
 8026d7a:	46bd      	mov	sp, r7
 8026d7c:	bd80      	pop	{r7, pc}

08026d7e <fp_read_radix_16>:
#endif

#if defined(OPENSSL_EXTRA) || !defined(NO_DSA) || defined(HAVE_ECC)
#if DIGIT_BIT == 64 || DIGIT_BIT == 32
static int fp_read_radix_16(fp_int *a, const char *str)
{
 8026d7e:	b580      	push	{r7, lr}
 8026d80:	b088      	sub	sp, #32
 8026d82:	af00      	add	r7, sp, #0
 8026d84:	6078      	str	r0, [r7, #4]
 8026d86:	6039      	str	r1, [r7, #0]
  int     i, j, k, neg;
  int     ch;
  /* Skip whitespace at end of line */
  int     eol_done = 0;
 8026d88:	2300      	movs	r3, #0
 8026d8a:	60fb      	str	r3, [r7, #12]

  /* if the leading digit is a
   * minus set the sign to negative.
   */
  if (*str == '-') {
 8026d8c:	683b      	ldr	r3, [r7, #0]
 8026d8e:	781b      	ldrb	r3, [r3, #0]
 8026d90:	2b2d      	cmp	r3, #45	@ 0x2d
 8026d92:	d105      	bne.n	8026da0 <fp_read_radix_16+0x22>
    ++str;
 8026d94:	683b      	ldr	r3, [r7, #0]
 8026d96:	3301      	adds	r3, #1
 8026d98:	603b      	str	r3, [r7, #0]
    neg = FP_NEG;
 8026d9a:	2301      	movs	r3, #1
 8026d9c:	613b      	str	r3, [r7, #16]
 8026d9e:	e001      	b.n	8026da4 <fp_read_radix_16+0x26>
  } else {
    neg = FP_ZPOS;
 8026da0:	2300      	movs	r3, #0
 8026da2:	613b      	str	r3, [r7, #16]
  }

  j = 0;
 8026da4:	2300      	movs	r3, #0
 8026da6:	61bb      	str	r3, [r7, #24]
  k = 0;
 8026da8:	2300      	movs	r3, #0
 8026daa:	617b      	str	r3, [r7, #20]
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
 8026dac:	6838      	ldr	r0, [r7, #0]
 8026dae:	f7d9 fa19 	bl	80001e4 <strlen>
 8026db2:	4603      	mov	r3, r0
 8026db4:	3b01      	subs	r3, #1
 8026db6:	61fb      	str	r3, [r7, #28]
 8026db8:	e04a      	b.n	8026e50 <fp_read_radix_16+0xd2>
      ch = (int)HexCharToByte(str[i]);
 8026dba:	69fb      	ldr	r3, [r7, #28]
 8026dbc:	683a      	ldr	r2, [r7, #0]
 8026dbe:	4413      	add	r3, r2
 8026dc0:	781b      	ldrb	r3, [r3, #0]
 8026dc2:	4618      	mov	r0, r3
 8026dc4:	f7fb fa3d 	bl	8022242 <HexCharToByte>
 8026dc8:	4603      	mov	r3, r0
 8026dca:	60bb      	str	r3, [r7, #8]
      if (ch < 0) {
 8026dcc:	68bb      	ldr	r3, [r7, #8]
 8026dce:	2b00      	cmp	r3, #0
 8026dd0:	da0f      	bge.n	8026df2 <fp_read_radix_16+0x74>
        if (!eol_done && CharIsWhiteSpace(str[i]))
 8026dd2:	68fb      	ldr	r3, [r7, #12]
 8026dd4:	2b00      	cmp	r3, #0
 8026dd6:	d109      	bne.n	8026dec <fp_read_radix_16+0x6e>
 8026dd8:	69fb      	ldr	r3, [r7, #28]
 8026dda:	683a      	ldr	r2, [r7, #0]
 8026ddc:	4413      	add	r3, r2
 8026dde:	781b      	ldrb	r3, [r3, #0]
 8026de0:	4618      	mov	r0, r3
 8026de2:	f7fb fa66 	bl	80222b2 <CharIsWhiteSpace>
 8026de6:	4603      	mov	r3, r0
 8026de8:	2b00      	cmp	r3, #0
 8026dea:	d12d      	bne.n	8026e48 <fp_read_radix_16+0xca>
          continue;
        return FP_VAL;
 8026dec:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8026df0:	e05b      	b.n	8026eaa <fp_read_radix_16+0x12c>
      }
      eol_done = 1;
 8026df2:	2301      	movs	r3, #1
 8026df4:	60fb      	str	r3, [r7, #12]

      k += j == DIGIT_BIT;
 8026df6:	69bb      	ldr	r3, [r7, #24]
 8026df8:	2b20      	cmp	r3, #32
 8026dfa:	bf0c      	ite	eq
 8026dfc:	2301      	moveq	r3, #1
 8026dfe:	2300      	movne	r3, #0
 8026e00:	b2db      	uxtb	r3, r3
 8026e02:	461a      	mov	r2, r3
 8026e04:	697b      	ldr	r3, [r7, #20]
 8026e06:	4413      	add	r3, r2
 8026e08:	617b      	str	r3, [r7, #20]
      j &= DIGIT_BIT - 1;
 8026e0a:	69bb      	ldr	r3, [r7, #24]
 8026e0c:	f003 031f 	and.w	r3, r3, #31
 8026e10:	61bb      	str	r3, [r7, #24]
      if (k >= FP_SIZE)
 8026e12:	697b      	ldr	r3, [r7, #20]
 8026e14:	2b87      	cmp	r3, #135	@ 0x87
 8026e16:	dd02      	ble.n	8026e1e <fp_read_radix_16+0xa0>
          return FP_VAL;
 8026e18:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8026e1c:	e045      	b.n	8026eaa <fp_read_radix_16+0x12c>

      a->dp[k] |= ((fp_digit)ch) << j;
 8026e1e:	687a      	ldr	r2, [r7, #4]
 8026e20:	697b      	ldr	r3, [r7, #20]
 8026e22:	3302      	adds	r3, #2
 8026e24:	009b      	lsls	r3, r3, #2
 8026e26:	4413      	add	r3, r2
 8026e28:	685a      	ldr	r2, [r3, #4]
 8026e2a:	68b9      	ldr	r1, [r7, #8]
 8026e2c:	69bb      	ldr	r3, [r7, #24]
 8026e2e:	fa01 f303 	lsl.w	r3, r1, r3
 8026e32:	431a      	orrs	r2, r3
 8026e34:	6879      	ldr	r1, [r7, #4]
 8026e36:	697b      	ldr	r3, [r7, #20]
 8026e38:	3302      	adds	r3, #2
 8026e3a:	009b      	lsls	r3, r3, #2
 8026e3c:	440b      	add	r3, r1
 8026e3e:	605a      	str	r2, [r3, #4]
      j += 4;
 8026e40:	69bb      	ldr	r3, [r7, #24]
 8026e42:	3304      	adds	r3, #4
 8026e44:	61bb      	str	r3, [r7, #24]
 8026e46:	e000      	b.n	8026e4a <fp_read_radix_16+0xcc>
          continue;
 8026e48:	bf00      	nop
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
 8026e4a:	69fb      	ldr	r3, [r7, #28]
 8026e4c:	3b01      	subs	r3, #1
 8026e4e:	61fb      	str	r3, [r7, #28]
 8026e50:	69fb      	ldr	r3, [r7, #28]
 8026e52:	2b00      	cmp	r3, #0
 8026e54:	dab1      	bge.n	8026dba <fp_read_radix_16+0x3c>
  }

  a->used = k + 1;
 8026e56:	697b      	ldr	r3, [r7, #20]
 8026e58:	1c5a      	adds	r2, r3, #1
 8026e5a:	687b      	ldr	r3, [r7, #4]
 8026e5c:	601a      	str	r2, [r3, #0]
  fp_clamp(a);
 8026e5e:	e004      	b.n	8026e6a <fp_read_radix_16+0xec>
 8026e60:	687b      	ldr	r3, [r7, #4]
 8026e62:	681b      	ldr	r3, [r3, #0]
 8026e64:	1e5a      	subs	r2, r3, #1
 8026e66:	687b      	ldr	r3, [r7, #4]
 8026e68:	601a      	str	r2, [r3, #0]
 8026e6a:	687b      	ldr	r3, [r7, #4]
 8026e6c:	681b      	ldr	r3, [r3, #0]
 8026e6e:	2b00      	cmp	r3, #0
 8026e70:	d009      	beq.n	8026e86 <fp_read_radix_16+0x108>
 8026e72:	687b      	ldr	r3, [r7, #4]
 8026e74:	681b      	ldr	r3, [r3, #0]
 8026e76:	3b01      	subs	r3, #1
 8026e78:	687a      	ldr	r2, [r7, #4]
 8026e7a:	3302      	adds	r3, #2
 8026e7c:	009b      	lsls	r3, r3, #2
 8026e7e:	4413      	add	r3, r2
 8026e80:	685b      	ldr	r3, [r3, #4]
 8026e82:	2b00      	cmp	r3, #0
 8026e84:	d0ec      	beq.n	8026e60 <fp_read_radix_16+0xe2>
 8026e86:	687b      	ldr	r3, [r7, #4]
 8026e88:	681b      	ldr	r3, [r3, #0]
 8026e8a:	2b00      	cmp	r3, #0
 8026e8c:	d002      	beq.n	8026e94 <fp_read_radix_16+0x116>
 8026e8e:	687b      	ldr	r3, [r7, #4]
 8026e90:	685b      	ldr	r3, [r3, #4]
 8026e92:	e000      	b.n	8026e96 <fp_read_radix_16+0x118>
 8026e94:	2300      	movs	r3, #0
 8026e96:	687a      	ldr	r2, [r7, #4]
 8026e98:	6053      	str	r3, [r2, #4]
  /* set the sign only if a != 0 */
  if (fp_iszero(a) != FP_YES) {
 8026e9a:	687b      	ldr	r3, [r7, #4]
 8026e9c:	681b      	ldr	r3, [r3, #0]
 8026e9e:	2b00      	cmp	r3, #0
 8026ea0:	d002      	beq.n	8026ea8 <fp_read_radix_16+0x12a>
     a->sign = neg;
 8026ea2:	687b      	ldr	r3, [r7, #4]
 8026ea4:	693a      	ldr	r2, [r7, #16]
 8026ea6:	605a      	str	r2, [r3, #4]
  }
  return FP_OKAY;
 8026ea8:	2300      	movs	r3, #0
}
 8026eaa:	4618      	mov	r0, r3
 8026eac:	3720      	adds	r7, #32
 8026eae:	46bd      	mov	sp, r7
 8026eb0:	bd80      	pop	{r7, pc}
	...

08026eb4 <fp_read_radix>:
#endif

static int fp_read_radix(fp_int *a, const char *str, int radix)
{
 8026eb4:	b580      	push	{r7, lr}
 8026eb6:	b088      	sub	sp, #32
 8026eb8:	af00      	add	r7, sp, #0
 8026eba:	60f8      	str	r0, [r7, #12]
 8026ebc:	60b9      	str	r1, [r7, #8]
 8026ebe:	607a      	str	r2, [r7, #4]
  int     y, neg;
  char    ch;

  /* set the integer to the default of zero */
  fp_zero (a);
 8026ec0:	68f8      	ldr	r0, [r7, #12]
 8026ec2:	f7ff fc09 	bl	80266d8 <fp_zero>

#if DIGIT_BIT == 64 || DIGIT_BIT == 32
  if (radix == 16)
 8026ec6:	687b      	ldr	r3, [r7, #4]
 8026ec8:	2b10      	cmp	r3, #16
 8026eca:	d105      	bne.n	8026ed8 <fp_read_radix+0x24>
      return fp_read_radix_16(a, str);
 8026ecc:	68b9      	ldr	r1, [r7, #8]
 8026ece:	68f8      	ldr	r0, [r7, #12]
 8026ed0:	f7ff ff55 	bl	8026d7e <fp_read_radix_16>
 8026ed4:	4603      	mov	r3, r0
 8026ed6:	e085      	b.n	8026fe4 <fp_read_radix+0x130>
#endif

  /* make sure the radix is ok */
  if (radix < 2 || radix > 64) {
 8026ed8:	687b      	ldr	r3, [r7, #4]
 8026eda:	2b01      	cmp	r3, #1
 8026edc:	dd02      	ble.n	8026ee4 <fp_read_radix+0x30>
 8026ede:	687b      	ldr	r3, [r7, #4]
 8026ee0:	2b40      	cmp	r3, #64	@ 0x40
 8026ee2:	dd02      	ble.n	8026eea <fp_read_radix+0x36>
    return FP_VAL;
 8026ee4:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8026ee8:	e07c      	b.n	8026fe4 <fp_read_radix+0x130>
  }

  /* if the leading digit is a
   * minus set the sign to negative.
   */
  if (*str == '-') {
 8026eea:	68bb      	ldr	r3, [r7, #8]
 8026eec:	781b      	ldrb	r3, [r3, #0]
 8026eee:	2b2d      	cmp	r3, #45	@ 0x2d
 8026ef0:	d105      	bne.n	8026efe <fp_read_radix+0x4a>
    ++str;
 8026ef2:	68bb      	ldr	r3, [r7, #8]
 8026ef4:	3301      	adds	r3, #1
 8026ef6:	60bb      	str	r3, [r7, #8]
    neg = FP_NEG;
 8026ef8:	2301      	movs	r3, #1
 8026efa:	61bb      	str	r3, [r7, #24]
 8026efc:	e062      	b.n	8026fc4 <fp_read_radix+0x110>
  } else {
    neg = FP_ZPOS;
 8026efe:	2300      	movs	r3, #0
 8026f00:	61bb      	str	r3, [r7, #24]
  }

  /* process each digit of the string */
  while (*str) {
 8026f02:	e05f      	b.n	8026fc4 <fp_read_radix+0x110>
    /* if the radix <= 36 the conversion is case insensitive
     * this allows numbers like 1AB and 1ab to represent the same  value
     * [e.g. in hex]
     */
    ch = (char)((radix <= 36) ? XTOUPPER((unsigned char)*str) : *str);
 8026f04:	687b      	ldr	r3, [r7, #4]
 8026f06:	2b24      	cmp	r3, #36	@ 0x24
 8026f08:	dc11      	bgt.n	8026f2e <fp_read_radix+0x7a>
 8026f0a:	68bb      	ldr	r3, [r7, #8]
 8026f0c:	781b      	ldrb	r3, [r3, #0]
 8026f0e:	75fb      	strb	r3, [r7, #23]
 8026f10:	7dfb      	ldrb	r3, [r7, #23]
 8026f12:	3301      	adds	r3, #1
 8026f14:	4a35      	ldr	r2, [pc, #212]	@ (8026fec <fp_read_radix+0x138>)
 8026f16:	4413      	add	r3, r2
 8026f18:	781b      	ldrb	r3, [r3, #0]
 8026f1a:	f003 0303 	and.w	r3, r3, #3
 8026f1e:	2b02      	cmp	r3, #2
 8026f20:	d102      	bne.n	8026f28 <fp_read_radix+0x74>
 8026f22:	7dfb      	ldrb	r3, [r7, #23]
 8026f24:	3b20      	subs	r3, #32
 8026f26:	e000      	b.n	8026f2a <fp_read_radix+0x76>
 8026f28:	7dfb      	ldrb	r3, [r7, #23]
 8026f2a:	b2db      	uxtb	r3, r3
 8026f2c:	e001      	b.n	8026f32 <fp_read_radix+0x7e>
 8026f2e:	68bb      	ldr	r3, [r7, #8]
 8026f30:	781b      	ldrb	r3, [r3, #0]
 8026f32:	75bb      	strb	r3, [r7, #22]
    for (y = 0; y < 64; y++) {
 8026f34:	2300      	movs	r3, #0
 8026f36:	61fb      	str	r3, [r7, #28]
 8026f38:	e009      	b.n	8026f4e <fp_read_radix+0x9a>
      if (ch == fp_s_rmap[y]) {
 8026f3a:	4a2d      	ldr	r2, [pc, #180]	@ (8026ff0 <fp_read_radix+0x13c>)
 8026f3c:	69fb      	ldr	r3, [r7, #28]
 8026f3e:	4413      	add	r3, r2
 8026f40:	781b      	ldrb	r3, [r3, #0]
 8026f42:	7dba      	ldrb	r2, [r7, #22]
 8026f44:	429a      	cmp	r2, r3
 8026f46:	d006      	beq.n	8026f56 <fp_read_radix+0xa2>
    for (y = 0; y < 64; y++) {
 8026f48:	69fb      	ldr	r3, [r7, #28]
 8026f4a:	3301      	adds	r3, #1
 8026f4c:	61fb      	str	r3, [r7, #28]
 8026f4e:	69fb      	ldr	r3, [r7, #28]
 8026f50:	2b3f      	cmp	r3, #63	@ 0x3f
 8026f52:	ddf2      	ble.n	8026f3a <fp_read_radix+0x86>
 8026f54:	e000      	b.n	8026f58 <fp_read_radix+0xa4>
         break;
 8026f56:	bf00      	nop
      }
    }
    if (y >= radix) {
 8026f58:	69fa      	ldr	r2, [r7, #28]
 8026f5a:	687b      	ldr	r3, [r7, #4]
 8026f5c:	429a      	cmp	r2, r3
 8026f5e:	db12      	blt.n	8026f86 <fp_read_radix+0xd2>
      /* Check if whitespace at end of line */
      while (CharIsWhiteSpace(*str))
 8026f60:	e002      	b.n	8026f68 <fp_read_radix+0xb4>
        ++str;
 8026f62:	68bb      	ldr	r3, [r7, #8]
 8026f64:	3301      	adds	r3, #1
 8026f66:	60bb      	str	r3, [r7, #8]
      while (CharIsWhiteSpace(*str))
 8026f68:	68bb      	ldr	r3, [r7, #8]
 8026f6a:	781b      	ldrb	r3, [r3, #0]
 8026f6c:	4618      	mov	r0, r3
 8026f6e:	f7fb f9a0 	bl	80222b2 <CharIsWhiteSpace>
 8026f72:	4603      	mov	r3, r0
 8026f74:	2b00      	cmp	r3, #0
 8026f76:	d1f4      	bne.n	8026f62 <fp_read_radix+0xae>
      if (*str)
 8026f78:	68bb      	ldr	r3, [r7, #8]
 8026f7a:	781b      	ldrb	r3, [r3, #0]
 8026f7c:	2b00      	cmp	r3, #0
 8026f7e:	d026      	beq.n	8026fce <fp_read_radix+0x11a>
        return FP_VAL;
 8026f80:	f06f 0361 	mvn.w	r3, #97	@ 0x61
 8026f84:	e02e      	b.n	8026fe4 <fp_read_radix+0x130>

    /* if the char was found in the map
     * and is less than the given radix add it
     * to the number, otherwise exit the loop.
     */
    if (y < radix) {
 8026f86:	69fa      	ldr	r2, [r7, #28]
 8026f88:	687b      	ldr	r3, [r7, #4]
 8026f8a:	429a      	cmp	r2, r3
 8026f8c:	da21      	bge.n	8026fd2 <fp_read_radix+0x11e>
      int ret = fp_mul_d (a, (fp_digit) radix, a);
 8026f8e:	687b      	ldr	r3, [r7, #4]
 8026f90:	68fa      	ldr	r2, [r7, #12]
 8026f92:	4619      	mov	r1, r3
 8026f94:	68f8      	ldr	r0, [r7, #12]
 8026f96:	f7fb fc3a 	bl	802280e <fp_mul_d>
 8026f9a:	6138      	str	r0, [r7, #16]
      if (ret != FP_OKAY)
 8026f9c:	693b      	ldr	r3, [r7, #16]
 8026f9e:	2b00      	cmp	r3, #0
 8026fa0:	d001      	beq.n	8026fa6 <fp_read_radix+0xf2>
        return ret;
 8026fa2:	693b      	ldr	r3, [r7, #16]
 8026fa4:	e01e      	b.n	8026fe4 <fp_read_radix+0x130>
      ret = fp_add_d (a, (fp_digit) y, a);
 8026fa6:	69fb      	ldr	r3, [r7, #28]
 8026fa8:	68fa      	ldr	r2, [r7, #12]
 8026faa:	4619      	mov	r1, r3
 8026fac:	68f8      	ldr	r0, [r7, #12]
 8026fae:	f7ff feab 	bl	8026d08 <fp_add_d>
 8026fb2:	6138      	str	r0, [r7, #16]
      if (ret != FP_OKAY)
 8026fb4:	693b      	ldr	r3, [r7, #16]
 8026fb6:	2b00      	cmp	r3, #0
 8026fb8:	d001      	beq.n	8026fbe <fp_read_radix+0x10a>
        return ret;
 8026fba:	693b      	ldr	r3, [r7, #16]
 8026fbc:	e012      	b.n	8026fe4 <fp_read_radix+0x130>
    } else {
      break;
    }
    ++str;
 8026fbe:	68bb      	ldr	r3, [r7, #8]
 8026fc0:	3301      	adds	r3, #1
 8026fc2:	60bb      	str	r3, [r7, #8]
  while (*str) {
 8026fc4:	68bb      	ldr	r3, [r7, #8]
 8026fc6:	781b      	ldrb	r3, [r3, #0]
 8026fc8:	2b00      	cmp	r3, #0
 8026fca:	d19b      	bne.n	8026f04 <fp_read_radix+0x50>
 8026fcc:	e002      	b.n	8026fd4 <fp_read_radix+0x120>
        break;
 8026fce:	bf00      	nop
 8026fd0:	e000      	b.n	8026fd4 <fp_read_radix+0x120>
      break;
 8026fd2:	bf00      	nop
  }

  /* set the sign only if a != 0 */
  if (fp_iszero(a) != FP_YES) {
 8026fd4:	68fb      	ldr	r3, [r7, #12]
 8026fd6:	681b      	ldr	r3, [r3, #0]
 8026fd8:	2b00      	cmp	r3, #0
 8026fda:	d002      	beq.n	8026fe2 <fp_read_radix+0x12e>
     a->sign = neg;
 8026fdc:	68fb      	ldr	r3, [r7, #12]
 8026fde:	69ba      	ldr	r2, [r7, #24]
 8026fe0:	605a      	str	r2, [r3, #4]
  }
  return FP_OKAY;
 8026fe2:	2300      	movs	r3, #0
}
 8026fe4:	4618      	mov	r0, r3
 8026fe6:	3720      	adds	r7, #32
 8026fe8:	46bd      	mov	sp, r7
 8026fea:	bd80      	pop	{r7, pc}
 8026fec:	08033c9c 	.word	0x08033c9c
 8026ff0:	0802ff14 	.word	0x0802ff14

08026ff4 <mp_read_radix>:

/* fast math conversion */
int mp_read_radix(mp_int *a, const char *str, int radix)
{
 8026ff4:	b580      	push	{r7, lr}
 8026ff6:	b084      	sub	sp, #16
 8026ff8:	af00      	add	r7, sp, #0
 8026ffa:	60f8      	str	r0, [r7, #12]
 8026ffc:	60b9      	str	r1, [r7, #8]
 8026ffe:	607a      	str	r2, [r7, #4]
    return fp_read_radix(a, str, radix);
 8027000:	687a      	ldr	r2, [r7, #4]
 8027002:	68b9      	ldr	r1, [r7, #8]
 8027004:	68f8      	ldr	r0, [r7, #12]
 8027006:	f7ff ff55 	bl	8026eb4 <fp_read_radix>
 802700a:	4603      	mov	r3, r0
}
 802700c:	4618      	mov	r0, r3
 802700e:	3710      	adds	r7, #16
 8027010:	46bd      	mov	sp, r7
 8027012:	bd80      	pop	{r7, pc}

08027014 <mp_montgomery_reduce>:
#endif /* !defined(NO_DSA) || defined(HAVE_ECC) */

#if defined(HAVE_ECC) || (!defined(NO_RSA) && defined(WC_RSA_BLINDING))

int mp_montgomery_reduce(fp_int *a, fp_int *m, fp_digit mp)
{
 8027014:	b580      	push	{r7, lr}
 8027016:	b084      	sub	sp, #16
 8027018:	af00      	add	r7, sp, #0
 802701a:	60f8      	str	r0, [r7, #12]
 802701c:	60b9      	str	r1, [r7, #8]
 802701e:	607a      	str	r2, [r7, #4]
    return fp_montgomery_reduce(a, m, mp);
 8027020:	687a      	ldr	r2, [r7, #4]
 8027022:	68b9      	ldr	r1, [r7, #8]
 8027024:	68f8      	ldr	r0, [r7, #12]
 8027026:	f7fe ffa4 	bl	8025f72 <fp_montgomery_reduce>
 802702a:	4603      	mov	r3, r0
}
 802702c:	4618      	mov	r0, r3
 802702e:	3710      	adds	r7, #16
 8027030:	46bd      	mov	sp, r7
 8027032:	bd80      	pop	{r7, pc}

08027034 <mp_montgomery_reduce_ex>:

int mp_montgomery_reduce_ex(fp_int *a, fp_int *m, fp_digit mp, int ct)
{
 8027034:	b580      	push	{r7, lr}
 8027036:	b084      	sub	sp, #16
 8027038:	af00      	add	r7, sp, #0
 802703a:	60f8      	str	r0, [r7, #12]
 802703c:	60b9      	str	r1, [r7, #8]
 802703e:	607a      	str	r2, [r7, #4]
 8027040:	603b      	str	r3, [r7, #0]
    return fp_montgomery_reduce_ex(a, m, mp, ct);
 8027042:	683b      	ldr	r3, [r7, #0]
 8027044:	687a      	ldr	r2, [r7, #4]
 8027046:	68b9      	ldr	r1, [r7, #8]
 8027048:	68f8      	ldr	r0, [r7, #12]
 802704a:	f7fe fe5e 	bl	8025d0a <fp_montgomery_reduce_ex>
 802704e:	4603      	mov	r3, r0
}
 8027050:	4618      	mov	r0, r3
 8027052:	3710      	adds	r7, #16
 8027054:	46bd      	mov	sp, r7
 8027056:	bd80      	pop	{r7, pc}

08027058 <mp_montgomery_setup>:


/* fast math conversion */
int mp_montgomery_setup(fp_int *a, fp_digit *rho)
{
 8027058:	b580      	push	{r7, lr}
 802705a:	b082      	sub	sp, #8
 802705c:	af00      	add	r7, sp, #0
 802705e:	6078      	str	r0, [r7, #4]
 8027060:	6039      	str	r1, [r7, #0]
    return fp_montgomery_setup(a, rho);
 8027062:	6839      	ldr	r1, [r7, #0]
 8027064:	6878      	ldr	r0, [r7, #4]
 8027066:	f7fe fdbd 	bl	8025be4 <fp_montgomery_setup>
 802706a:	4603      	mov	r3, r0
}
 802706c:	4618      	mov	r0, r3
 802706e:	3708      	adds	r7, #8
 8027070:	46bd      	mov	sp, r7
 8027072:	bd80      	pop	{r7, pc}

08027074 <mp_sqr>:

#endif /* HAVE_ECC || (!NO_RSA && WC_RSA_BLINDING) */

/* fast math conversion */
int mp_sqr(fp_int *A, fp_int *B)
{
 8027074:	b580      	push	{r7, lr}
 8027076:	b082      	sub	sp, #8
 8027078:	af00      	add	r7, sp, #0
 802707a:	6078      	str	r0, [r7, #4]
 802707c:	6039      	str	r1, [r7, #0]
    return fp_sqr(A, B);
 802707e:	6839      	ldr	r1, [r7, #0]
 8027080:	6878      	ldr	r0, [r7, #4]
 8027082:	f7fe faba 	bl	80255fa <fp_sqr>
 8027086:	4603      	mov	r3, r0
}
 8027088:	4618      	mov	r0, r3
 802708a:	3708      	adds	r7, #8
 802708c:	46bd      	mov	sp, r7
 802708e:	bd80      	pop	{r7, pc}

08027090 <mp_div_2_mod_ct>:
    return MP_OKAY;
}

/* c = a / 2 (mod b) - constant time (a < b and positive) */
int mp_div_2_mod_ct(mp_int *a, mp_int *b, mp_int *c)
{
 8027090:	b580      	push	{r7, lr}
 8027092:	b084      	sub	sp, #16
 8027094:	af00      	add	r7, sp, #0
 8027096:	60f8      	str	r0, [r7, #12]
 8027098:	60b9      	str	r1, [r7, #8]
 802709a:	607a      	str	r2, [r7, #4]
  return fp_div_2_mod_ct(a, b, c);
 802709c:	687a      	ldr	r2, [r7, #4]
 802709e:	68b9      	ldr	r1, [r7, #8]
 80270a0:	68f8      	ldr	r0, [r7, #12]
 80270a2:	f7fc f96a 	bl	802337a <fp_div_2_mod_ct>
 80270a6:	4603      	mov	r3, r0
}
 80270a8:	4618      	mov	r0, r3
 80270aa:	3710      	adds	r7, #16
 80270ac:	46bd      	mov	sp, r7
 80270ae:	bd80      	pop	{r7, pc}

080270b0 <mp_set>:

#if defined(HAVE_ECC) || !defined(NO_RSA) || !defined(NO_DSA) || \
    defined(WOLFSSL_KEY_GEN)
/* fast math conversion */
int mp_set(fp_int *a, fp_digit b)
{
 80270b0:	b580      	push	{r7, lr}
 80270b2:	b082      	sub	sp, #8
 80270b4:	af00      	add	r7, sp, #0
 80270b6:	6078      	str	r0, [r7, #4]
 80270b8:	6039      	str	r1, [r7, #0]
    fp_set(a,b);
 80270ba:	6839      	ldr	r1, [r7, #0]
 80270bc:	6878      	ldr	r0, [r7, #4]
 80270be:	f7ff f8ce 	bl	802625e <fp_set>
    return MP_OKAY;
 80270c2:	2300      	movs	r3, #0
}
 80270c4:	4618      	mov	r0, r3
 80270c6:	3708      	adds	r7, #8
 80270c8:	46bd      	mov	sp, r7
 80270ca:	bd80      	pop	{r7, pc}

080270cc <ForceZero>:
{
 80270cc:	b480      	push	{r7}
 80270ce:	b085      	sub	sp, #20
 80270d0:	af00      	add	r7, sp, #0
 80270d2:	6078      	str	r0, [r7, #4]
 80270d4:	6039      	str	r1, [r7, #0]
    volatile byte* z = (volatile byte*)mem;
 80270d6:	687b      	ldr	r3, [r7, #4]
 80270d8:	60fb      	str	r3, [r7, #12]
    while (len--) *z++ = 0;
 80270da:	e004      	b.n	80270e6 <ForceZero+0x1a>
 80270dc:	68fb      	ldr	r3, [r7, #12]
 80270de:	1c5a      	adds	r2, r3, #1
 80270e0:	60fa      	str	r2, [r7, #12]
 80270e2:	2200      	movs	r2, #0
 80270e4:	701a      	strb	r2, [r3, #0]
 80270e6:	683b      	ldr	r3, [r7, #0]
 80270e8:	1e5a      	subs	r2, r3, #1
 80270ea:	603a      	str	r2, [r7, #0]
 80270ec:	2b00      	cmp	r3, #0
 80270ee:	d1f5      	bne.n	80270dc <ForceZero+0x10>
}
 80270f0:	bf00      	nop
 80270f2:	bf00      	nop
 80270f4:	3714      	adds	r7, #20
 80270f6:	46bd      	mov	sp, r7
 80270f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80270fc:	4770      	bx	lr

080270fe <wc_AesCbcDecryptWithKey>:

#if !defined(NO_AES) && defined(HAVE_AES_CBC)
#ifdef HAVE_AES_DECRYPT
int wc_AesCbcDecryptWithKey(byte* out, const byte* in, word32 inSz,
                                  const byte* key, word32 keySz, const byte* iv)
{
 80270fe:	b580      	push	{r7, lr}
 8027100:	b08a      	sub	sp, #40	@ 0x28
 8027102:	af02      	add	r7, sp, #8
 8027104:	60f8      	str	r0, [r7, #12]
 8027106:	60b9      	str	r1, [r7, #8]
 8027108:	607a      	str	r2, [r7, #4]
 802710a:	603b      	str	r3, [r7, #0]
    int  ret = 0;
 802710c:	2300      	movs	r3, #0
 802710e:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_SMALL_STACK
    Aes* aes = NULL;
 8027110:	2300      	movs	r3, #0
 8027112:	61bb      	str	r3, [r7, #24]
#else
    Aes  aes[1];
#endif

    if (out == NULL || in == NULL || key == NULL || iv == NULL) {
 8027114:	68fb      	ldr	r3, [r7, #12]
 8027116:	2b00      	cmp	r3, #0
 8027118:	d008      	beq.n	802712c <wc_AesCbcDecryptWithKey+0x2e>
 802711a:	68bb      	ldr	r3, [r7, #8]
 802711c:	2b00      	cmp	r3, #0
 802711e:	d005      	beq.n	802712c <wc_AesCbcDecryptWithKey+0x2e>
 8027120:	683b      	ldr	r3, [r7, #0]
 8027122:	2b00      	cmp	r3, #0
 8027124:	d002      	beq.n	802712c <wc_AesCbcDecryptWithKey+0x2e>
 8027126:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8027128:	2b00      	cmp	r3, #0
 802712a:	d102      	bne.n	8027132 <wc_AesCbcDecryptWithKey+0x34>
        return BAD_FUNC_ARG;
 802712c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8027130:	e033      	b.n	802719a <wc_AesCbcDecryptWithKey+0x9c>
    }

#ifdef WOLFSSL_SMALL_STACK
    aes = (Aes*)XMALLOC(sizeof(Aes), NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8027132:	f44f 70a6 	mov.w	r0, #332	@ 0x14c
 8027136:	f7f7 fcad 	bl	801ea94 <wolfSSL_Malloc>
 802713a:	61b8      	str	r0, [r7, #24]
    if (aes == NULL)
 802713c:	69bb      	ldr	r3, [r7, #24]
 802713e:	2b00      	cmp	r3, #0
 8027140:	d102      	bne.n	8027148 <wc_AesCbcDecryptWithKey+0x4a>
        return MEMORY_E;
 8027142:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 8027146:	e028      	b.n	802719a <wc_AesCbcDecryptWithKey+0x9c>
#endif

    ret = wc_AesInit(aes, NULL, INVALID_DEVID);
 8027148:	f06f 0201 	mvn.w	r2, #1
 802714c:	2100      	movs	r1, #0
 802714e:	69b8      	ldr	r0, [r7, #24]
 8027150:	f7eb fa77 	bl	8012642 <wc_AesInit>
 8027154:	61f8      	str	r0, [r7, #28]
    if (ret == 0) {
 8027156:	69fb      	ldr	r3, [r7, #28]
 8027158:	2b00      	cmp	r3, #0
 802715a:	d115      	bne.n	8027188 <wc_AesCbcDecryptWithKey+0x8a>
        ret = wc_AesSetKey(aes, key, keySz, iv, AES_DECRYPTION);
 802715c:	2301      	movs	r3, #1
 802715e:	9300      	str	r3, [sp, #0]
 8027160:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8027162:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8027164:	6839      	ldr	r1, [r7, #0]
 8027166:	69b8      	ldr	r0, [r7, #24]
 8027168:	f7eb f982 	bl	8012470 <wc_AesSetKey>
 802716c:	61f8      	str	r0, [r7, #28]
        if (ret == 0)
 802716e:	69fb      	ldr	r3, [r7, #28]
 8027170:	2b00      	cmp	r3, #0
 8027172:	d106      	bne.n	8027182 <wc_AesCbcDecryptWithKey+0x84>
            ret = wc_AesCbcDecrypt(aes, out, in, inSz);
 8027174:	687b      	ldr	r3, [r7, #4]
 8027176:	68ba      	ldr	r2, [r7, #8]
 8027178:	68f9      	ldr	r1, [r7, #12]
 802717a:	69b8      	ldr	r0, [r7, #24]
 802717c:	f7eb fa07 	bl	801258e <wc_AesCbcDecrypt>
 8027180:	61f8      	str	r0, [r7, #28]

        wc_AesFree(aes);
 8027182:	69b8      	ldr	r0, [r7, #24]
 8027184:	f7eb fa7a 	bl	801267c <wc_AesFree>
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(aes, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 8027188:	69bb      	ldr	r3, [r7, #24]
 802718a:	617b      	str	r3, [r7, #20]
 802718c:	697b      	ldr	r3, [r7, #20]
 802718e:	2b00      	cmp	r3, #0
 8027190:	d002      	beq.n	8027198 <wc_AesCbcDecryptWithKey+0x9a>
 8027192:	6978      	ldr	r0, [r7, #20]
 8027194:	f7f7 fc9a 	bl	801eacc <wolfSSL_Free>
#endif

    return ret;
 8027198:	69fb      	ldr	r3, [r7, #28]
}
 802719a:	4618      	mov	r0, r3
 802719c:	3720      	adds	r7, #32
 802719e:	46bd      	mov	sp, r7
 80271a0:	bd80      	pop	{r7, pc}

080271a2 <wc_BufferKeyDecrypt>:

#if !defined(NO_ASN) && defined(WOLFSSL_ENCRYPTED_KEYS)

int wc_BufferKeyDecrypt(EncryptedInfo* info, byte* der, word32 derSz,
    const byte* password, int passwordSz, int hashType)
{
 80271a2:	b580      	push	{r7, lr}
 80271a4:	b08a      	sub	sp, #40	@ 0x28
 80271a6:	af02      	add	r7, sp, #8
 80271a8:	60f8      	str	r0, [r7, #12]
 80271aa:	60b9      	str	r1, [r7, #8]
 80271ac:	607a      	str	r2, [r7, #4]
 80271ae:	603b      	str	r3, [r7, #0]
    int ret = WC_NO_ERR_TRACE(NOT_COMPILED_IN);
 80271b0:	f06f 03ad 	mvn.w	r3, #173	@ 0xad
 80271b4:	61fb      	str	r3, [r7, #28]
#ifdef WOLFSSL_SMALL_STACK
    byte* key      = NULL;
 80271b6:	2300      	movs	r3, #0
 80271b8:	61bb      	str	r3, [r7, #24]

    (void)derSz;
    (void)passwordSz;
    (void)hashType;

    if (der == NULL || password == NULL || info == NULL || info->keySz == 0) {
 80271ba:	68bb      	ldr	r3, [r7, #8]
 80271bc:	2b00      	cmp	r3, #0
 80271be:	d009      	beq.n	80271d4 <wc_BufferKeyDecrypt+0x32>
 80271c0:	683b      	ldr	r3, [r7, #0]
 80271c2:	2b00      	cmp	r3, #0
 80271c4:	d006      	beq.n	80271d4 <wc_BufferKeyDecrypt+0x32>
 80271c6:	68fb      	ldr	r3, [r7, #12]
 80271c8:	2b00      	cmp	r3, #0
 80271ca:	d003      	beq.n	80271d4 <wc_BufferKeyDecrypt+0x32>
 80271cc:	68fb      	ldr	r3, [r7, #12]
 80271ce:	691b      	ldr	r3, [r3, #16]
 80271d0:	2b00      	cmp	r3, #0
 80271d2:	d102      	bne.n	80271da <wc_BufferKeyDecrypt+0x38>
        return BAD_FUNC_ARG;
 80271d4:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 80271d8:	e045      	b.n	8027266 <wc_BufferKeyDecrypt+0xc4>
    }

    /* use file's salt for key derivation, hex decode first */
    if (Base16_Decode(info->iv, info->ivSz, info->iv, &info->ivSz) != 0) {
 80271da:	68fb      	ldr	r3, [r7, #12]
 80271dc:	f103 0068 	add.w	r0, r3, #104	@ 0x68
 80271e0:	68fb      	ldr	r3, [r7, #12]
 80271e2:	6959      	ldr	r1, [r3, #20]
 80271e4:	68fb      	ldr	r3, [r7, #12]
 80271e6:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 80271ea:	68fb      	ldr	r3, [r7, #12]
 80271ec:	3314      	adds	r3, #20
 80271ee:	f7f3 fa0b 	bl	801a608 <Base16_Decode>
 80271f2:	4603      	mov	r3, r0
 80271f4:	2b00      	cmp	r3, #0
 80271f6:	d002      	beq.n	80271fe <wc_BufferKeyDecrypt+0x5c>
        WOLFSSL_ERROR_VERBOSE(BUFFER_E);
        return BUFFER_E;
 80271f8:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 80271fc:	e033      	b.n	8027266 <wc_BufferKeyDecrypt+0xc4>
    }
    if (info->ivSz < PKCS5_SALT_SZ) {
 80271fe:	68fb      	ldr	r3, [r7, #12]
 8027200:	695b      	ldr	r3, [r3, #20]
 8027202:	2b07      	cmp	r3, #7
 8027204:	d802      	bhi.n	802720c <wc_BufferKeyDecrypt+0x6a>
        WOLFSSL_ERROR_VERBOSE(BUFFER_E);
        return BUFFER_E;
 8027206:	f06f 0383 	mvn.w	r3, #131	@ 0x83
 802720a:	e02c      	b.n	8027266 <wc_BufferKeyDecrypt+0xc4>
    }

#ifdef WOLFSSL_SMALL_STACK
    key = (byte*)XMALLOC(WC_MAX_SYM_KEY_SIZE, NULL, DYNAMIC_TYPE_SYMMETRIC_KEY);
 802720c:	2020      	movs	r0, #32
 802720e:	f7f7 fc41 	bl	801ea94 <wolfSSL_Malloc>
 8027212:	61b8      	str	r0, [r7, #24]
    if (key == NULL) {
 8027214:	69bb      	ldr	r3, [r7, #24]
 8027216:	2b00      	cmp	r3, #0
 8027218:	d102      	bne.n	8027220 <wc_BufferKeyDecrypt+0x7e>
        return MEMORY_E;
 802721a:	f06f 037c 	mvn.w	r3, #124	@ 0x7c
 802721e:	e022      	b.n	8027266 <wc_BufferKeyDecrypt+0xc4>
#endif
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Add("wc_BufferKeyDecrypt key", key, WC_MAX_SYM_KEY_SIZE);
#endif

    (void)XMEMSET(key, 0, WC_MAX_SYM_KEY_SIZE);
 8027220:	2220      	movs	r2, #32
 8027222:	2100      	movs	r1, #0
 8027224:	69b8      	ldr	r0, [r7, #24]
 8027226:	f001 f953 	bl	80284d0 <memset>
        ret = wc_Des_CbcDecryptWithKey(der, der, derSz, key, info->iv);
    if (info->cipherType == WC_CIPHER_DES3)
        ret = wc_Des3_CbcDecryptWithKey(der, der, derSz, key, info->iv);
#endif /* NO_DES3 */
#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(HAVE_AES_DECRYPT)
    if (info->cipherType == WC_CIPHER_AES_CBC)
 802722a:	68fb      	ldr	r3, [r7, #12]
 802722c:	68db      	ldr	r3, [r3, #12]
 802722e:	2b02      	cmp	r3, #2
 8027230:	d10c      	bne.n	802724c <wc_BufferKeyDecrypt+0xaa>
        ret = wc_AesCbcDecryptWithKey(der, der, derSz, key, info->keySz,
 8027232:	68fb      	ldr	r3, [r7, #12]
 8027234:	691b      	ldr	r3, [r3, #16]
            info->iv);
 8027236:	68fa      	ldr	r2, [r7, #12]
 8027238:	3268      	adds	r2, #104	@ 0x68
        ret = wc_AesCbcDecryptWithKey(der, der, derSz, key, info->keySz,
 802723a:	9201      	str	r2, [sp, #4]
 802723c:	9300      	str	r3, [sp, #0]
 802723e:	69bb      	ldr	r3, [r7, #24]
 8027240:	687a      	ldr	r2, [r7, #4]
 8027242:	68b9      	ldr	r1, [r7, #8]
 8027244:	68b8      	ldr	r0, [r7, #8]
 8027246:	f7ff ff5a 	bl	80270fe <wc_AesCbcDecryptWithKey>
 802724a:	61f8      	str	r0, [r7, #28]
#endif /* !NO_AES && HAVE_AES_CBC && HAVE_AES_DECRYPT */

    ForceZero(key, WC_MAX_SYM_KEY_SIZE);
 802724c:	2120      	movs	r1, #32
 802724e:	69b8      	ldr	r0, [r7, #24]
 8027250:	f7ff ff3c 	bl	80270cc <ForceZero>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(key, NULL, DYNAMIC_TYPE_SYMMETRIC_KEY);
 8027254:	69bb      	ldr	r3, [r7, #24]
 8027256:	617b      	str	r3, [r7, #20]
 8027258:	697b      	ldr	r3, [r7, #20]
 802725a:	2b00      	cmp	r3, #0
 802725c:	d002      	beq.n	8027264 <wc_BufferKeyDecrypt+0xc2>
 802725e:	6978      	ldr	r0, [r7, #20]
 8027260:	f7f7 fc34 	bl	801eacc <wolfSSL_Free>
#elif defined(WOLFSSL_CHECK_MEM_ZERO)
    wc_MemZero_Check(key, WC_MAX_SYM_KEY_SIZE);
#endif

    return ret;
 8027264:	69fb      	ldr	r3, [r7, #28]
}
 8027266:	4618      	mov	r0, r3
 8027268:	3720      	adds	r7, #32
 802726a:	46bd      	mov	sp, r7
 802726c:	bd80      	pop	{r7, pc}
	...

08027270 <wolfCrypt_Init>:
/* Used to initialize state for wolfcrypt
   return 0 on success
 */
WOLFSSL_ABI
int wolfCrypt_Init(void)
{
 8027270:	b580      	push	{r7, lr}
 8027272:	b082      	sub	sp, #8
 8027274:	af00      	add	r7, sp, #0
    int ret = 0;
 8027276:	2300      	movs	r3, #0
 8027278:	607b      	str	r3, [r7, #4]
    if (initRefCount == 0) {
 802727a:	4b10      	ldr	r3, [pc, #64]	@ (80272bc <wolfCrypt_Init+0x4c>)
 802727c:	681b      	ldr	r3, [r3, #0]
 802727e:	2b00      	cmp	r3, #0
 8027280:	d111      	bne.n	80272a6 <wolfCrypt_Init+0x36>
        }
    #endif

    #if WOLFSSL_CRYPT_HW_MUTEX
        /* If crypto hardware mutex protection is enabled, then initialize it */
        ret = wolfSSL_CryptHwMutexInit();
 8027282:	f000 f83d 	bl	8027300 <wolfSSL_CryptHwMutexInit>
 8027286:	6078      	str	r0, [r7, #4]
        if (ret != 0) {
 8027288:	687b      	ldr	r3, [r7, #4]
 802728a:	2b00      	cmp	r3, #0
 802728c:	d001      	beq.n	8027292 <wolfCrypt_Init+0x22>
            WOLFSSL_MSG("Hw crypt mutex init failed");
            return ret;
 802728e:	687b      	ldr	r3, [r7, #4]
 8027290:	e00f      	b.n	80272b2 <wolfCrypt_Init+0x42>
    #ifdef WOLFSSL_AFALG
        WOLFSSL_MSG("Using AF_ALG for crypto acceleration");
    #endif

    #if !defined(WOLFCRYPT_ONLY) && defined(OPENSSL_EXTRA)
        wolfSSL_EVP_init();
 8027292:	f7e4 f81b 	bl	800b2cc <wolfSSL_EVP_init>
    #endif

    #if defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE)
        if ((ret = wc_LoggingInit()) != 0) {
 8027296:	f7f7 f9a3 	bl	801e5e0 <wc_LoggingInit>
 802729a:	6078      	str	r0, [r7, #4]
 802729c:	687b      	ldr	r3, [r7, #4]
 802729e:	2b00      	cmp	r3, #0
 80272a0:	d001      	beq.n	80272a6 <wolfCrypt_Init+0x36>
            WOLFSSL_MSG("Error creating logging mutex");
            return ret;
 80272a2:	687b      	ldr	r3, [r7, #4]
 80272a4:	e005      	b.n	80272b2 <wolfCrypt_Init+0x42>
        if ((ret = wolfSSL_liboqsInit()) != 0) {
            return ret;
        }
#endif
    }
    initRefCount++;
 80272a6:	4b05      	ldr	r3, [pc, #20]	@ (80272bc <wolfCrypt_Init+0x4c>)
 80272a8:	681b      	ldr	r3, [r3, #0]
 80272aa:	3301      	adds	r3, #1
 80272ac:	4a03      	ldr	r2, [pc, #12]	@ (80272bc <wolfCrypt_Init+0x4c>)
 80272ae:	6013      	str	r3, [r2, #0]

    return ret;
 80272b0:	687b      	ldr	r3, [r7, #4]
}
 80272b2:	4618      	mov	r0, r3
 80272b4:	3708      	adds	r7, #8
 80272b6:	46bd      	mov	sp, r7
 80272b8:	bd80      	pop	{r7, pc}
 80272ba:	bf00      	nop
 80272bc:	20002710 	.word	0x20002710

080272c0 <wolfCrypt_Cleanup>:
#endif

/* return success value is the same as wolfCrypt_Init */
WOLFSSL_ABI
int wolfCrypt_Cleanup(void)
{
 80272c0:	b580      	push	{r7, lr}
 80272c2:	b082      	sub	sp, #8
 80272c4:	af00      	add	r7, sp, #0
    int ret = 0;
 80272c6:	2300      	movs	r3, #0
 80272c8:	607b      	str	r3, [r7, #4]

    initRefCount--;
 80272ca:	4b0c      	ldr	r3, [pc, #48]	@ (80272fc <wolfCrypt_Cleanup+0x3c>)
 80272cc:	681b      	ldr	r3, [r3, #0]
 80272ce:	3b01      	subs	r3, #1
 80272d0:	4a0a      	ldr	r2, [pc, #40]	@ (80272fc <wolfCrypt_Cleanup+0x3c>)
 80272d2:	6013      	str	r3, [r2, #0]
    if (initRefCount < 0)
 80272d4:	4b09      	ldr	r3, [pc, #36]	@ (80272fc <wolfCrypt_Cleanup+0x3c>)
 80272d6:	681b      	ldr	r3, [r3, #0]
 80272d8:	2b00      	cmp	r3, #0
 80272da:	da02      	bge.n	80272e2 <wolfCrypt_Cleanup+0x22>
        initRefCount = 0;
 80272dc:	4b07      	ldr	r3, [pc, #28]	@ (80272fc <wolfCrypt_Cleanup+0x3c>)
 80272de:	2200      	movs	r2, #0
 80272e0:	601a      	str	r2, [r3, #0]

    if (initRefCount == 0) {
 80272e2:	4b06      	ldr	r3, [pc, #24]	@ (80272fc <wolfCrypt_Cleanup+0x3c>)
 80272e4:	681b      	ldr	r3, [r3, #0]
 80272e6:	2b00      	cmp	r3, #0
 80272e8:	d102      	bne.n	80272f0 <wolfCrypt_Cleanup+0x30>
        wc_ecc_oid_cache_free();
    #endif
#endif /* HAVE_ECC */

    #if defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE)
        ret = wc_LoggingCleanup();
 80272ea:	f7f7 f99d 	bl	801e628 <wc_LoggingCleanup>
 80272ee:	6078      	str	r0, [r7, #4]

#if defined(HAVE_LIBOQS)
    wolfSSL_liboqsClose();
#endif

    return ret;
 80272f0:	687b      	ldr	r3, [r7, #4]
}
 80272f2:	4618      	mov	r0, r3
 80272f4:	3708      	adds	r7, #8
 80272f6:	46bd      	mov	sp, r7
 80272f8:	bd80      	pop	{r7, pc}
 80272fa:	bf00      	nop
 80272fc:	20002710 	.word	0x20002710

08027300 <wolfSSL_CryptHwMutexInit>:
#ifndef WOLFSSL_MUTEX_INITIALIZER
static int wcCryptHwMutexInit = 0;
#endif

int wolfSSL_CryptHwMutexInit(void)
{
 8027300:	b580      	push	{r7, lr}
 8027302:	b082      	sub	sp, #8
 8027304:	af00      	add	r7, sp, #0
    int ret = 0;
 8027306:	2300      	movs	r3, #0
 8027308:	607b      	str	r3, [r7, #4]
#ifndef WOLFSSL_MUTEX_INITIALIZER
    if (wcCryptHwMutexInit == 0) {
 802730a:	4b09      	ldr	r3, [pc, #36]	@ (8027330 <wolfSSL_CryptHwMutexInit+0x30>)
 802730c:	681b      	ldr	r3, [r3, #0]
 802730e:	2b00      	cmp	r3, #0
 8027310:	d109      	bne.n	8027326 <wolfSSL_CryptHwMutexInit+0x26>
        ret = wc_InitMutex(&wcCryptHwMutex);
 8027312:	4808      	ldr	r0, [pc, #32]	@ (8027334 <wolfSSL_CryptHwMutexInit+0x34>)
 8027314:	f000 f838 	bl	8027388 <wc_InitMutex>
 8027318:	6078      	str	r0, [r7, #4]
        if (ret == 0) {
 802731a:	687b      	ldr	r3, [r7, #4]
 802731c:	2b00      	cmp	r3, #0
 802731e:	d102      	bne.n	8027326 <wolfSSL_CryptHwMutexInit+0x26>
            wcCryptHwMutexInit = 1;
 8027320:	4b03      	ldr	r3, [pc, #12]	@ (8027330 <wolfSSL_CryptHwMutexInit+0x30>)
 8027322:	2201      	movs	r2, #1
 8027324:	601a      	str	r2, [r3, #0]
        }
    }
#endif
    return ret;
 8027326:	687b      	ldr	r3, [r7, #4]
}
 8027328:	4618      	mov	r0, r3
 802732a:	3708      	adds	r7, #8
 802732c:	46bd      	mov	sp, r7
 802732e:	bd80      	pop	{r7, pc}
 8027330:	20002718 	.word	0x20002718
 8027334:	20002714 	.word	0x20002714

08027338 <wolfSSL_CryptHwMutexLock>:
int wolfSSL_CryptHwMutexLock(void)
{
 8027338:	b580      	push	{r7, lr}
 802733a:	b082      	sub	sp, #8
 802733c:	af00      	add	r7, sp, #0
    /* Make sure HW Mutex has been initialized */
    int ret = wolfSSL_CryptHwMutexInit();
 802733e:	f7ff ffdf 	bl	8027300 <wolfSSL_CryptHwMutexInit>
 8027342:	6078      	str	r0, [r7, #4]
    if (ret == 0) {
 8027344:	687b      	ldr	r3, [r7, #4]
 8027346:	2b00      	cmp	r3, #0
 8027348:	d103      	bne.n	8027352 <wolfSSL_CryptHwMutexLock+0x1a>
        ret = wc_LockMutex(&wcCryptHwMutex);
 802734a:	4804      	ldr	r0, [pc, #16]	@ (802735c <wolfSSL_CryptHwMutexLock+0x24>)
 802734c:	f000 f832 	bl	80273b4 <wc_LockMutex>
 8027350:	6078      	str	r0, [r7, #4]
    }
    return ret;
 8027352:	687b      	ldr	r3, [r7, #4]
}
 8027354:	4618      	mov	r0, r3
 8027356:	3708      	adds	r7, #8
 8027358:	46bd      	mov	sp, r7
 802735a:	bd80      	pop	{r7, pc}
 802735c:	20002714 	.word	0x20002714

08027360 <wolfSSL_CryptHwMutexUnLock>:
int wolfSSL_CryptHwMutexUnLock(void)
{
 8027360:	b580      	push	{r7, lr}
 8027362:	af00      	add	r7, sp, #0
    if (wcCryptHwMutexInit) {
 8027364:	4b06      	ldr	r3, [pc, #24]	@ (8027380 <wolfSSL_CryptHwMutexUnLock+0x20>)
 8027366:	681b      	ldr	r3, [r3, #0]
 8027368:	2b00      	cmp	r3, #0
 802736a:	d004      	beq.n	8027376 <wolfSSL_CryptHwMutexUnLock+0x16>
        return wc_UnLockMutex(&wcCryptHwMutex);
 802736c:	4805      	ldr	r0, [pc, #20]	@ (8027384 <wolfSSL_CryptHwMutexUnLock+0x24>)
 802736e:	f000 f82c 	bl	80273ca <wc_UnLockMutex>
 8027372:	4603      	mov	r3, r0
 8027374:	e001      	b.n	802737a <wolfSSL_CryptHwMutexUnLock+0x1a>
    }
    else {
        return BAD_MUTEX_E;
 8027376:	f06f 0369 	mvn.w	r3, #105	@ 0x69
    }
}
 802737a:	4618      	mov	r0, r3
 802737c:	bd80      	pop	{r7, pc}
 802737e:	bf00      	nop
 8027380:	20002718 	.word	0x20002718
 8027384:	20002714 	.word	0x20002714

08027388 <wc_InitMutex>:
    }
#endif /* defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) */
#ifdef SINGLE_THREADED

    int wc_InitMutex(wolfSSL_Mutex* m)
    {
 8027388:	b480      	push	{r7}
 802738a:	b083      	sub	sp, #12
 802738c:	af00      	add	r7, sp, #0
 802738e:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 8027390:	2300      	movs	r3, #0
    }
 8027392:	4618      	mov	r0, r3
 8027394:	370c      	adds	r7, #12
 8027396:	46bd      	mov	sp, r7
 8027398:	f85d 7b04 	ldr.w	r7, [sp], #4
 802739c:	4770      	bx	lr

0802739e <wc_FreeMutex>:

    int wc_FreeMutex(wolfSSL_Mutex *m)
    {
 802739e:	b480      	push	{r7}
 80273a0:	b083      	sub	sp, #12
 80273a2:	af00      	add	r7, sp, #0
 80273a4:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 80273a6:	2300      	movs	r3, #0
    }
 80273a8:	4618      	mov	r0, r3
 80273aa:	370c      	adds	r7, #12
 80273ac:	46bd      	mov	sp, r7
 80273ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273b2:	4770      	bx	lr

080273b4 <wc_LockMutex>:


    int wc_LockMutex(wolfSSL_Mutex *m)
    {
 80273b4:	b480      	push	{r7}
 80273b6:	b083      	sub	sp, #12
 80273b8:	af00      	add	r7, sp, #0
 80273ba:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 80273bc:	2300      	movs	r3, #0
    }
 80273be:	4618      	mov	r0, r3
 80273c0:	370c      	adds	r7, #12
 80273c2:	46bd      	mov	sp, r7
 80273c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273c8:	4770      	bx	lr

080273ca <wc_UnLockMutex>:


    int wc_UnLockMutex(wolfSSL_Mutex *m)
    {
 80273ca:	b480      	push	{r7}
 80273cc:	b083      	sub	sp, #12
 80273ce:	af00      	add	r7, sp, #0
 80273d0:	6078      	str	r0, [r7, #4]
        (void)m;
        return 0;
 80273d2:	2300      	movs	r3, #0
    }
 80273d4:	4618      	mov	r0, r3
 80273d6:	370c      	adds	r7, #12
 80273d8:	46bd      	mov	sp, r7
 80273da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273de:	4770      	bx	lr

080273e0 <mystrnstr>:
#endif /* !NO_ASN_TIME */

#if (!defined(WOLFSSL_LEANPSK) && !defined(STRING_USER)) || \
    defined(USE_WOLF_STRNSTR)
char* mystrnstr(const char* s1, const char* s2, unsigned int n)
{
 80273e0:	b580      	push	{r7, lr}
 80273e2:	b086      	sub	sp, #24
 80273e4:	af00      	add	r7, sp, #0
 80273e6:	60f8      	str	r0, [r7, #12]
 80273e8:	60b9      	str	r1, [r7, #8]
 80273ea:	607a      	str	r2, [r7, #4]
    unsigned int s2_len = (unsigned int)XSTRLEN(s2);
 80273ec:	68b8      	ldr	r0, [r7, #8]
 80273ee:	f7d8 fef9 	bl	80001e4 <strlen>
 80273f2:	6178      	str	r0, [r7, #20]

    if (s2_len == 0)
 80273f4:	697b      	ldr	r3, [r7, #20]
 80273f6:	2b00      	cmp	r3, #0
 80273f8:	d117      	bne.n	802742a <mystrnstr+0x4a>
        return (char*)s1;
 80273fa:	68fb      	ldr	r3, [r7, #12]
 80273fc:	e01e      	b.n	802743c <mystrnstr+0x5c>

    while (n >= s2_len && s1[0]) {
        if (s1[0] == s2[0])
 80273fe:	68fb      	ldr	r3, [r7, #12]
 8027400:	781a      	ldrb	r2, [r3, #0]
 8027402:	68bb      	ldr	r3, [r7, #8]
 8027404:	781b      	ldrb	r3, [r3, #0]
 8027406:	429a      	cmp	r2, r3
 8027408:	d109      	bne.n	802741e <mystrnstr+0x3e>
            if (XMEMCMP(s1, s2, s2_len) == 0)
 802740a:	697a      	ldr	r2, [r7, #20]
 802740c:	68b9      	ldr	r1, [r7, #8]
 802740e:	68f8      	ldr	r0, [r7, #12]
 8027410:	f001 f834 	bl	802847c <memcmp>
 8027414:	4603      	mov	r3, r0
 8027416:	2b00      	cmp	r3, #0
 8027418:	d101      	bne.n	802741e <mystrnstr+0x3e>
                return (char*)s1;
 802741a:	68fb      	ldr	r3, [r7, #12]
 802741c:	e00e      	b.n	802743c <mystrnstr+0x5c>
        s1++;
 802741e:	68fb      	ldr	r3, [r7, #12]
 8027420:	3301      	adds	r3, #1
 8027422:	60fb      	str	r3, [r7, #12]
        n--;
 8027424:	687b      	ldr	r3, [r7, #4]
 8027426:	3b01      	subs	r3, #1
 8027428:	607b      	str	r3, [r7, #4]
    while (n >= s2_len && s1[0]) {
 802742a:	687a      	ldr	r2, [r7, #4]
 802742c:	697b      	ldr	r3, [r7, #20]
 802742e:	429a      	cmp	r2, r3
 8027430:	d303      	bcc.n	802743a <mystrnstr+0x5a>
 8027432:	68fb      	ldr	r3, [r7, #12]
 8027434:	781b      	ldrb	r3, [r3, #0]
 8027436:	2b00      	cmp	r3, #0
 8027438:	d1e1      	bne.n	80273fe <mystrnstr+0x1e>
    }

    return NULL;
 802743a:	2300      	movs	r3, #0
}
 802743c:	4618      	mov	r0, r3
 802743e:	3718      	adds	r7, #24
 8027440:	46bd      	mov	sp, r7
 8027442:	bd80      	pop	{r7, pc}

08027444 <mp_reverse>:
#endif


/* reverse an array, used for radix code */
void mp_reverse(unsigned char *s, int len)
{
 8027444:	b480      	push	{r7}
 8027446:	b087      	sub	sp, #28
 8027448:	af00      	add	r7, sp, #0
 802744a:	6078      	str	r0, [r7, #4]
 802744c:	6039      	str	r1, [r7, #0]
    int ix, iy;

    if (s == NULL)
 802744e:	687b      	ldr	r3, [r7, #4]
 8027450:	2b00      	cmp	r3, #0
 8027452:	d022      	beq.n	802749a <mp_reverse+0x56>
        return;

    ix = 0;
 8027454:	2300      	movs	r3, #0
 8027456:	617b      	str	r3, [r7, #20]
    iy = len - 1;
 8027458:	683b      	ldr	r3, [r7, #0]
 802745a:	3b01      	subs	r3, #1
 802745c:	613b      	str	r3, [r7, #16]
    while (ix < iy) {
 802745e:	e017      	b.n	8027490 <mp_reverse+0x4c>
        unsigned char t = s[ix];
 8027460:	697b      	ldr	r3, [r7, #20]
 8027462:	687a      	ldr	r2, [r7, #4]
 8027464:	4413      	add	r3, r2
 8027466:	781b      	ldrb	r3, [r3, #0]
 8027468:	73fb      	strb	r3, [r7, #15]
        s[ix] = s[iy];
 802746a:	693b      	ldr	r3, [r7, #16]
 802746c:	687a      	ldr	r2, [r7, #4]
 802746e:	441a      	add	r2, r3
 8027470:	697b      	ldr	r3, [r7, #20]
 8027472:	6879      	ldr	r1, [r7, #4]
 8027474:	440b      	add	r3, r1
 8027476:	7812      	ldrb	r2, [r2, #0]
 8027478:	701a      	strb	r2, [r3, #0]
        s[iy] = t;
 802747a:	693b      	ldr	r3, [r7, #16]
 802747c:	687a      	ldr	r2, [r7, #4]
 802747e:	4413      	add	r3, r2
 8027480:	7bfa      	ldrb	r2, [r7, #15]
 8027482:	701a      	strb	r2, [r3, #0]
        ++ix;
 8027484:	697b      	ldr	r3, [r7, #20]
 8027486:	3301      	adds	r3, #1
 8027488:	617b      	str	r3, [r7, #20]
        --iy;
 802748a:	693b      	ldr	r3, [r7, #16]
 802748c:	3b01      	subs	r3, #1
 802748e:	613b      	str	r3, [r7, #16]
    while (ix < iy) {
 8027490:	697a      	ldr	r2, [r7, #20]
 8027492:	693b      	ldr	r3, [r7, #16]
 8027494:	429a      	cmp	r2, r3
 8027496:	dbe3      	blt.n	8027460 <mp_reverse+0x1c>
 8027498:	e000      	b.n	802749c <mp_reverse+0x58>
        return;
 802749a:	bf00      	nop
    }
}
 802749c:	371c      	adds	r7, #28
 802749e:	46bd      	mov	sp, r7
 80274a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80274a4:	4770      	bx	lr

080274a6 <get_digit_count>:

int get_digit_count(const mp_int* a)
{
 80274a6:	b480      	push	{r7}
 80274a8:	b083      	sub	sp, #12
 80274aa:	af00      	add	r7, sp, #0
 80274ac:	6078      	str	r0, [r7, #4]
    if (a == NULL)
 80274ae:	687b      	ldr	r3, [r7, #4]
 80274b0:	2b00      	cmp	r3, #0
 80274b2:	d101      	bne.n	80274b8 <get_digit_count+0x12>
        return 0;
 80274b4:	2300      	movs	r3, #0
 80274b6:	e001      	b.n	80274bc <get_digit_count+0x16>

    return (int)a->used;
 80274b8:	687b      	ldr	r3, [r7, #4]
 80274ba:	681b      	ldr	r3, [r3, #0]
}
 80274bc:	4618      	mov	r0, r3
 80274be:	370c      	adds	r7, #12
 80274c0:	46bd      	mov	sp, r7
 80274c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80274c6:	4770      	bx	lr

080274c8 <get_digit>:

mp_digit get_digit(const mp_int* a, int n)
{
 80274c8:	b480      	push	{r7}
 80274ca:	b083      	sub	sp, #12
 80274cc:	af00      	add	r7, sp, #0
 80274ce:	6078      	str	r0, [r7, #4]
 80274d0:	6039      	str	r1, [r7, #0]
    if (a == NULL)
 80274d2:	687b      	ldr	r3, [r7, #4]
 80274d4:	2b00      	cmp	r3, #0
 80274d6:	d101      	bne.n	80274dc <get_digit+0x14>
        return 0;
 80274d8:	2300      	movs	r3, #0
 80274da:	e010      	b.n	80274fe <get_digit+0x36>

    return (n < 0 || (unsigned int)n >= (unsigned int)a->used) ? 0 : a->dp[n];
 80274dc:	683b      	ldr	r3, [r7, #0]
 80274de:	2b00      	cmp	r3, #0
 80274e0:	db0c      	blt.n	80274fc <get_digit+0x34>
 80274e2:	687b      	ldr	r3, [r7, #4]
 80274e4:	681b      	ldr	r3, [r3, #0]
 80274e6:	461a      	mov	r2, r3
 80274e8:	683b      	ldr	r3, [r7, #0]
 80274ea:	429a      	cmp	r2, r3
 80274ec:	d906      	bls.n	80274fc <get_digit+0x34>
 80274ee:	687a      	ldr	r2, [r7, #4]
 80274f0:	683b      	ldr	r3, [r7, #0]
 80274f2:	3302      	adds	r3, #2
 80274f4:	009b      	lsls	r3, r3, #2
 80274f6:	4413      	add	r3, r2
 80274f8:	685b      	ldr	r3, [r3, #4]
 80274fa:	e000      	b.n	80274fe <get_digit+0x36>
 80274fc:	2300      	movs	r3, #0
}
 80274fe:	4618      	mov	r0, r3
 8027500:	370c      	adds	r7, #12
 8027502:	46bd      	mov	sp, r7
 8027504:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027508:	4770      	bx	lr

0802750a <mp_cond_copy>:
 * b     MP integer to copy into.
 * returns BAD_FUNC_ARG when a or b is NULL, MEMORY_E when growing b fails and
 *         MP_OKAY otherwise.
 */
int mp_cond_copy(mp_int* a, int copy, mp_int* b)
{
 802750a:	b590      	push	{r4, r7, lr}
 802750c:	b089      	sub	sp, #36	@ 0x24
 802750e:	af00      	add	r7, sp, #0
 8027510:	60f8      	str	r0, [r7, #12]
 8027512:	60b9      	str	r1, [r7, #8]
 8027514:	607a      	str	r2, [r7, #4]
    int err = MP_OKAY;
 8027516:	2300      	movs	r3, #0
 8027518:	61fb      	str	r3, [r7, #28]
#if defined(SP_WORD_SIZE) && SP_WORD_SIZE == 8
    unsigned int mask = (unsigned int)0 - copy;
#else
    mp_digit mask = (mp_digit)0 - (mp_digit)copy;
 802751a:	68bb      	ldr	r3, [r7, #8]
 802751c:	425b      	negs	r3, r3
 802751e:	617b      	str	r3, [r7, #20]
#endif

    if (a == NULL || b == NULL)
 8027520:	68fb      	ldr	r3, [r7, #12]
 8027522:	2b00      	cmp	r3, #0
 8027524:	d002      	beq.n	802752c <mp_cond_copy+0x22>
 8027526:	687b      	ldr	r3, [r7, #4]
 8027528:	2b00      	cmp	r3, #0
 802752a:	d102      	bne.n	8027532 <mp_cond_copy+0x28>
        err = BAD_FUNC_ARG;
 802752c:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8027530:	61fb      	str	r3, [r7, #28]

    /* Ensure b has enough space to copy a into */
    if (err == MP_OKAY)
 8027532:	69fb      	ldr	r3, [r7, #28]
 8027534:	2b00      	cmp	r3, #0
 8027536:	d101      	bne.n	802753c <mp_cond_copy+0x32>
        err = mp_grow(b, (int)a->used + 1);
 8027538:	2300      	movs	r3, #0
 802753a:	61fb      	str	r3, [r7, #28]
    if (err == MP_OKAY) {
 802753c:	69fb      	ldr	r3, [r7, #28]
 802753e:	2b00      	cmp	r3, #0
 8027540:	d161      	bne.n	8027606 <mp_cond_copy+0xfc>
         * When mask all set, b ^ b ^ a = a
         */
        /* Conditionally copy all digits and then number of used digits.
         * get_digit() returns 0 when index greater than available digit.
         */
        for (i = 0; i < a->used; i++) {
 8027542:	2300      	movs	r3, #0
 8027544:	61bb      	str	r3, [r7, #24]
 8027546:	e01d      	b.n	8027584 <mp_cond_copy+0x7a>
            b->dp[i] ^= (get_digit(a, (int)i) ^ get_digit(b, (int)i)) & mask;
 8027548:	69b9      	ldr	r1, [r7, #24]
 802754a:	68f8      	ldr	r0, [r7, #12]
 802754c:	f7ff ffbc 	bl	80274c8 <get_digit>
 8027550:	4604      	mov	r4, r0
 8027552:	69b9      	ldr	r1, [r7, #24]
 8027554:	6878      	ldr	r0, [r7, #4]
 8027556:	f7ff ffb7 	bl	80274c8 <get_digit>
 802755a:	4603      	mov	r3, r0
 802755c:	ea84 0203 	eor.w	r2, r4, r3
 8027560:	697b      	ldr	r3, [r7, #20]
 8027562:	401a      	ands	r2, r3
 8027564:	6879      	ldr	r1, [r7, #4]
 8027566:	69bb      	ldr	r3, [r7, #24]
 8027568:	3302      	adds	r3, #2
 802756a:	009b      	lsls	r3, r3, #2
 802756c:	440b      	add	r3, r1
 802756e:	685b      	ldr	r3, [r3, #4]
 8027570:	405a      	eors	r2, r3
 8027572:	6879      	ldr	r1, [r7, #4]
 8027574:	69bb      	ldr	r3, [r7, #24]
 8027576:	3302      	adds	r3, #2
 8027578:	009b      	lsls	r3, r3, #2
 802757a:	440b      	add	r3, r1
 802757c:	605a      	str	r2, [r3, #4]
        for (i = 0; i < a->used; i++) {
 802757e:	69bb      	ldr	r3, [r7, #24]
 8027580:	3301      	adds	r3, #1
 8027582:	61bb      	str	r3, [r7, #24]
 8027584:	68fb      	ldr	r3, [r7, #12]
 8027586:	681b      	ldr	r3, [r3, #0]
 8027588:	69ba      	ldr	r2, [r7, #24]
 802758a:	429a      	cmp	r2, r3
 802758c:	dbdc      	blt.n	8027548 <mp_cond_copy+0x3e>
        }
        for (; i < b->used; i++) {
 802758e:	e01d      	b.n	80275cc <mp_cond_copy+0xc2>
            b->dp[i] ^= (get_digit(a, (int)i) ^ get_digit(b, (int)i)) & mask;
 8027590:	69b9      	ldr	r1, [r7, #24]
 8027592:	68f8      	ldr	r0, [r7, #12]
 8027594:	f7ff ff98 	bl	80274c8 <get_digit>
 8027598:	4604      	mov	r4, r0
 802759a:	69b9      	ldr	r1, [r7, #24]
 802759c:	6878      	ldr	r0, [r7, #4]
 802759e:	f7ff ff93 	bl	80274c8 <get_digit>
 80275a2:	4603      	mov	r3, r0
 80275a4:	ea84 0203 	eor.w	r2, r4, r3
 80275a8:	697b      	ldr	r3, [r7, #20]
 80275aa:	401a      	ands	r2, r3
 80275ac:	6879      	ldr	r1, [r7, #4]
 80275ae:	69bb      	ldr	r3, [r7, #24]
 80275b0:	3302      	adds	r3, #2
 80275b2:	009b      	lsls	r3, r3, #2
 80275b4:	440b      	add	r3, r1
 80275b6:	685b      	ldr	r3, [r3, #4]
 80275b8:	405a      	eors	r2, r3
 80275ba:	6879      	ldr	r1, [r7, #4]
 80275bc:	69bb      	ldr	r3, [r7, #24]
 80275be:	3302      	adds	r3, #2
 80275c0:	009b      	lsls	r3, r3, #2
 80275c2:	440b      	add	r3, r1
 80275c4:	605a      	str	r2, [r3, #4]
        for (; i < b->used; i++) {
 80275c6:	69bb      	ldr	r3, [r7, #24]
 80275c8:	3301      	adds	r3, #1
 80275ca:	61bb      	str	r3, [r7, #24]
 80275cc:	687b      	ldr	r3, [r7, #4]
 80275ce:	681b      	ldr	r3, [r3, #0]
 80275d0:	69ba      	ldr	r2, [r7, #24]
 80275d2:	429a      	cmp	r2, r3
 80275d4:	dbdc      	blt.n	8027590 <mp_cond_copy+0x86>
        }
        b->used ^= (a->used ^ b->used) & (wc_mp_size_t)mask;
 80275d6:	687b      	ldr	r3, [r7, #4]
 80275d8:	681a      	ldr	r2, [r3, #0]
 80275da:	68fb      	ldr	r3, [r7, #12]
 80275dc:	6819      	ldr	r1, [r3, #0]
 80275de:	687b      	ldr	r3, [r7, #4]
 80275e0:	681b      	ldr	r3, [r3, #0]
 80275e2:	4059      	eors	r1, r3
 80275e4:	697b      	ldr	r3, [r7, #20]
 80275e6:	400b      	ands	r3, r1
 80275e8:	405a      	eors	r2, r3
 80275ea:	687b      	ldr	r3, [r7, #4]
 80275ec:	601a      	str	r2, [r3, #0]
#if (!defined(WOLFSSL_SP_MATH) && !defined(WOLFSSL_SP_MATH_ALL)) || \
    defined(WOLFSSL_SP_INT_NEGATIVE)
        b->sign ^= (wc_mp_sign_t)(a->sign ^ b->sign) & (wc_mp_sign_t)mask;
 80275ee:	687b      	ldr	r3, [r7, #4]
 80275f0:	685a      	ldr	r2, [r3, #4]
 80275f2:	68fb      	ldr	r3, [r7, #12]
 80275f4:	6859      	ldr	r1, [r3, #4]
 80275f6:	687b      	ldr	r3, [r7, #4]
 80275f8:	685b      	ldr	r3, [r3, #4]
 80275fa:	4059      	eors	r1, r3
 80275fc:	697b      	ldr	r3, [r7, #20]
 80275fe:	400b      	ands	r3, r1
 8027600:	405a      	eors	r2, r3
 8027602:	687b      	ldr	r3, [r7, #4]
 8027604:	605a      	str	r2, [r3, #4]
#endif
    }

    return err;
 8027606:	69fb      	ldr	r3, [r7, #28]
}
 8027608:	4618      	mov	r0, r3
 802760a:	3724      	adds	r7, #36	@ 0x24
 802760c:	46bd      	mov	sp, r7
 802760e:	bd90      	pop	{r4, r7, pc}

08027610 <get_rand_digit>:
#endif /* HAVE_ECC || WOLFSSL_MP_COND_COPY */


#ifndef WC_NO_RNG
int get_rand_digit(WC_RNG* rng, mp_digit* d)
{
 8027610:	b580      	push	{r7, lr}
 8027612:	b082      	sub	sp, #8
 8027614:	af00      	add	r7, sp, #0
 8027616:	6078      	str	r0, [r7, #4]
 8027618:	6039      	str	r1, [r7, #0]
    return wc_RNG_GenerateBlock(rng, (byte*)d, sizeof(mp_digit));
 802761a:	2204      	movs	r2, #4
 802761c:	6839      	ldr	r1, [r7, #0]
 802761e:	6878      	ldr	r0, [r7, #4]
 8027620:	f7f7 ffbf 	bl	801f5a2 <wc_RNG_GenerateBlock>
 8027624:	4603      	mov	r3, r0
}
 8027626:	4618      	mov	r0, r3
 8027628:	3708      	adds	r7, #8
 802762a:	46bd      	mov	sp, r7
 802762c:	bd80      	pop	{r7, pc}

0802762e <mp_rand>:

int mp_rand(mp_int* a, int digits, WC_RNG* rng)
{
 802762e:	b580      	push	{r7, lr}
 8027630:	b086      	sub	sp, #24
 8027632:	af00      	add	r7, sp, #0
 8027634:	60f8      	str	r0, [r7, #12]
 8027636:	60b9      	str	r1, [r7, #8]
 8027638:	607a      	str	r2, [r7, #4]
    int ret = 0;
 802763a:	2300      	movs	r3, #0
 802763c:	617b      	str	r3, [r7, #20]
    int cnt = digits * (int)sizeof(mp_digit);
 802763e:	68bb      	ldr	r3, [r7, #8]
 8027640:	009b      	lsls	r3, r3, #2
 8027642:	613b      	str	r3, [r7, #16]

    if (rng == NULL) {
 8027644:	687b      	ldr	r3, [r7, #4]
 8027646:	2b00      	cmp	r3, #0
 8027648:	d103      	bne.n	8027652 <mp_rand+0x24>
        ret = MISSING_RNG_E;
 802764a:	f06f 03eb 	mvn.w	r3, #235	@ 0xeb
 802764e:	617b      	str	r3, [r7, #20]
 8027650:	e008      	b.n	8027664 <mp_rand+0x36>
    }
    else if (a == NULL || digits <= 0) {
 8027652:	68fb      	ldr	r3, [r7, #12]
 8027654:	2b00      	cmp	r3, #0
 8027656:	d002      	beq.n	802765e <mp_rand+0x30>
 8027658:	68bb      	ldr	r3, [r7, #8]
 802765a:	2b00      	cmp	r3, #0
 802765c:	dc02      	bgt.n	8027664 <mp_rand+0x36>
        ret = BAD_FUNC_ARG;
 802765e:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8027662:	617b      	str	r3, [r7, #20]
    }
#else
#if defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_SP_MATH_ALL)
    if ((ret == MP_OKAY) && ((unsigned int)digits > a->size))
#else
    if ((ret == MP_OKAY) && (digits > FP_SIZE))
 8027664:	697b      	ldr	r3, [r7, #20]
 8027666:	2b00      	cmp	r3, #0
 8027668:	d105      	bne.n	8027676 <mp_rand+0x48>
 802766a:	68bb      	ldr	r3, [r7, #8]
 802766c:	2b88      	cmp	r3, #136	@ 0x88
 802766e:	dd02      	ble.n	8027676 <mp_rand+0x48>
#endif
    {
        ret = BAD_FUNC_ARG;
 8027670:	f06f 03ac 	mvn.w	r3, #172	@ 0xac
 8027674:	617b      	str	r3, [r7, #20]
    }
    if (ret == MP_OKAY) {
 8027676:	697b      	ldr	r3, [r7, #20]
 8027678:	2b00      	cmp	r3, #0
 802767a:	d102      	bne.n	8027682 <mp_rand+0x54>
        a->used = (wc_mp_size_t)digits;
 802767c:	68fb      	ldr	r3, [r7, #12]
 802767e:	68ba      	ldr	r2, [r7, #8]
 8027680:	601a      	str	r2, [r3, #0]
    }
#endif
    /* fill the data with random bytes */
    if (ret == MP_OKAY) {
 8027682:	697b      	ldr	r3, [r7, #20]
 8027684:	2b00      	cmp	r3, #0
 8027686:	d107      	bne.n	8027698 <mp_rand+0x6a>
        ret = wc_RNG_GenerateBlock(rng, (byte*)a->dp, (word32)cnt);
 8027688:	68fb      	ldr	r3, [r7, #12]
 802768a:	330c      	adds	r3, #12
 802768c:	693a      	ldr	r2, [r7, #16]
 802768e:	4619      	mov	r1, r3
 8027690:	6878      	ldr	r0, [r7, #4]
 8027692:	f7f7 ff86 	bl	801f5a2 <wc_RNG_GenerateBlock>
 8027696:	6178      	str	r0, [r7, #20]
    }
    if (ret == MP_OKAY) {
 8027698:	697b      	ldr	r3, [r7, #20]
 802769a:	2b00      	cmp	r3, #0
 802769c:	d11a      	bne.n	80276d4 <mp_rand+0xa6>
        for (i = 0; i < a->used; i++) {
            a->dp[i] &= MP_MASK;
        }
#endif
        /* ensure top digit is not zero */
        while ((ret == MP_OKAY) && (a->dp[a->used - 1] == 0)) {
 802769e:	e00c      	b.n	80276ba <mp_rand+0x8c>
            ret = get_rand_digit(rng, &a->dp[a->used - 1]);
 80276a0:	68fb      	ldr	r3, [r7, #12]
 80276a2:	681b      	ldr	r3, [r3, #0]
 80276a4:	3b01      	subs	r3, #1
 80276a6:	3302      	adds	r3, #2
 80276a8:	009b      	lsls	r3, r3, #2
 80276aa:	68fa      	ldr	r2, [r7, #12]
 80276ac:	4413      	add	r3, r2
 80276ae:	3304      	adds	r3, #4
 80276b0:	4619      	mov	r1, r3
 80276b2:	6878      	ldr	r0, [r7, #4]
 80276b4:	f7ff ffac 	bl	8027610 <get_rand_digit>
 80276b8:	6178      	str	r0, [r7, #20]
        while ((ret == MP_OKAY) && (a->dp[a->used - 1] == 0)) {
 80276ba:	697b      	ldr	r3, [r7, #20]
 80276bc:	2b00      	cmp	r3, #0
 80276be:	d109      	bne.n	80276d4 <mp_rand+0xa6>
 80276c0:	68fb      	ldr	r3, [r7, #12]
 80276c2:	681b      	ldr	r3, [r3, #0]
 80276c4:	3b01      	subs	r3, #1
 80276c6:	68fa      	ldr	r2, [r7, #12]
 80276c8:	3302      	adds	r3, #2
 80276ca:	009b      	lsls	r3, r3, #2
 80276cc:	4413      	add	r3, r2
 80276ce:	685b      	ldr	r3, [r3, #4]
 80276d0:	2b00      	cmp	r3, #0
 80276d2:	d0e5      	beq.n	80276a0 <mp_rand+0x72>
            a->dp[a->used - 1] &= MP_MASK;
#endif
        }
    }

    return ret;
 80276d4:	697b      	ldr	r3, [r7, #20]
}
 80276d6:	4618      	mov	r0, r3
 80276d8:	3718      	adds	r7, #24
 80276da:	46bd      	mov	sp, r7
 80276dc:	bd80      	pop	{r7, pc}
	...

080276e0 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 80276e0:	b580      	push	{r7, lr}
 80276e2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 80276e4:	2200      	movs	r2, #0
 80276e6:	4912      	ldr	r1, [pc, #72]	@ (8027730 <MX_USB_DEVICE_Init+0x50>)
 80276e8:	4812      	ldr	r0, [pc, #72]	@ (8027734 <MX_USB_DEVICE_Init+0x54>)
 80276ea:	f7df fdd5 	bl	8007298 <USBD_Init>
 80276ee:	4603      	mov	r3, r0
 80276f0:	2b00      	cmp	r3, #0
 80276f2:	d001      	beq.n	80276f8 <MX_USB_DEVICE_Init+0x18>
  {
    Error_Handler();
 80276f4:	f7da f88a 	bl	800180c <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 80276f8:	490f      	ldr	r1, [pc, #60]	@ (8027738 <MX_USB_DEVICE_Init+0x58>)
 80276fa:	480e      	ldr	r0, [pc, #56]	@ (8027734 <MX_USB_DEVICE_Init+0x54>)
 80276fc:	f7df fdfc 	bl	80072f8 <USBD_RegisterClass>
 8027700:	4603      	mov	r3, r0
 8027702:	2b00      	cmp	r3, #0
 8027704:	d001      	beq.n	802770a <MX_USB_DEVICE_Init+0x2a>
  {
    Error_Handler();
 8027706:	f7da f881 	bl	800180c <Error_Handler>
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 802770a:	490c      	ldr	r1, [pc, #48]	@ (802773c <MX_USB_DEVICE_Init+0x5c>)
 802770c:	4809      	ldr	r0, [pc, #36]	@ (8027734 <MX_USB_DEVICE_Init+0x54>)
 802770e:	f7df fcf3 	bl	80070f8 <USBD_CDC_RegisterInterface>
 8027712:	4603      	mov	r3, r0
 8027714:	2b00      	cmp	r3, #0
 8027716:	d001      	beq.n	802771c <MX_USB_DEVICE_Init+0x3c>
  {
    Error_Handler();
 8027718:	f7da f878 	bl	800180c <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 802771c:	4805      	ldr	r0, [pc, #20]	@ (8027734 <MX_USB_DEVICE_Init+0x54>)
 802771e:	f7df fe21 	bl	8007364 <USBD_Start>
 8027722:	4603      	mov	r3, r0
 8027724:	2b00      	cmp	r3, #0
 8027726:	d001      	beq.n	802772c <MX_USB_DEVICE_Init+0x4c>
  {
    Error_Handler();
 8027728:	f7da f870 	bl	800180c <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 802772c:	bf00      	nop
 802772e:	bd80      	pop	{r7, pc}
 8027730:	200000e4 	.word	0x200000e4
 8027734:	2000271c 	.word	0x2000271c
 8027738:	20000030 	.word	0x20000030
 802773c:	200000d0 	.word	0x200000d0

08027740 <CDC_Init_FS>:
/**
  * @brief  Initializes the CDC media low layer over the FS USB IP
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
 8027740:	b580      	push	{r7, lr}
 8027742:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 3 */
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 8027744:	2200      	movs	r2, #0
 8027746:	4905      	ldr	r1, [pc, #20]	@ (802775c <CDC_Init_FS+0x1c>)
 8027748:	4805      	ldr	r0, [pc, #20]	@ (8027760 <CDC_Init_FS+0x20>)
 802774a:	f7df fcef 	bl	800712c <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 802774e:	4905      	ldr	r1, [pc, #20]	@ (8027764 <CDC_Init_FS+0x24>)
 8027750:	4803      	ldr	r0, [pc, #12]	@ (8027760 <CDC_Init_FS+0x20>)
 8027752:	f7df fd0d 	bl	8007170 <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
 8027756:	2300      	movs	r3, #0
  /* USER CODE END 3 */
}
 8027758:	4618      	mov	r0, r3
 802775a:	bd80      	pop	{r7, pc}
 802775c:	200031f8 	.word	0x200031f8
 8027760:	2000271c 	.word	0x2000271c
 8027764:	200029f8 	.word	0x200029f8

08027768 <CDC_DeInit_FS>:
/**
  * @brief  DeInitializes the CDC media low layer
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_DeInit_FS(void)
{
 8027768:	b480      	push	{r7}
 802776a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
 802776c:	2300      	movs	r3, #0
  /* USER CODE END 4 */
}
 802776e:	4618      	mov	r0, r3
 8027770:	46bd      	mov	sp, r7
 8027772:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027776:	4770      	bx	lr

08027778 <CDC_Control_FS>:
  * @param  pbuf: Buffer containing command data (request parameters)
  * @param  length: Number of data to be sent (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
 8027778:	b480      	push	{r7}
 802777a:	b083      	sub	sp, #12
 802777c:	af00      	add	r7, sp, #0
 802777e:	4603      	mov	r3, r0
 8027780:	6039      	str	r1, [r7, #0]
 8027782:	71fb      	strb	r3, [r7, #7]
 8027784:	4613      	mov	r3, r2
 8027786:	80bb      	strh	r3, [r7, #4]
  /* USER CODE BEGIN 5 */
  switch(cmd)
 8027788:	79fb      	ldrb	r3, [r7, #7]
 802778a:	2b23      	cmp	r3, #35	@ 0x23
 802778c:	f200 808c 	bhi.w	80278a8 <CDC_Control_FS+0x130>
 8027790:	a201      	add	r2, pc, #4	@ (adr r2, 8027798 <CDC_Control_FS+0x20>)
 8027792:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8027796:	bf00      	nop
 8027798:	080278a9 	.word	0x080278a9
 802779c:	080278a9 	.word	0x080278a9
 80277a0:	080278a9 	.word	0x080278a9
 80277a4:	080278a9 	.word	0x080278a9
 80277a8:	080278a9 	.word	0x080278a9
 80277ac:	080278a9 	.word	0x080278a9
 80277b0:	080278a9 	.word	0x080278a9
 80277b4:	080278a9 	.word	0x080278a9
 80277b8:	080278a9 	.word	0x080278a9
 80277bc:	080278a9 	.word	0x080278a9
 80277c0:	080278a9 	.word	0x080278a9
 80277c4:	080278a9 	.word	0x080278a9
 80277c8:	080278a9 	.word	0x080278a9
 80277cc:	080278a9 	.word	0x080278a9
 80277d0:	080278a9 	.word	0x080278a9
 80277d4:	080278a9 	.word	0x080278a9
 80277d8:	080278a9 	.word	0x080278a9
 80277dc:	080278a9 	.word	0x080278a9
 80277e0:	080278a9 	.word	0x080278a9
 80277e4:	080278a9 	.word	0x080278a9
 80277e8:	080278a9 	.word	0x080278a9
 80277ec:	080278a9 	.word	0x080278a9
 80277f0:	080278a9 	.word	0x080278a9
 80277f4:	080278a9 	.word	0x080278a9
 80277f8:	080278a9 	.word	0x080278a9
 80277fc:	080278a9 	.word	0x080278a9
 8027800:	080278a9 	.word	0x080278a9
 8027804:	080278a9 	.word	0x080278a9
 8027808:	080278a9 	.word	0x080278a9
 802780c:	080278a9 	.word	0x080278a9
 8027810:	080278a9 	.word	0x080278a9
 8027814:	080278a9 	.word	0x080278a9
 8027818:	08027829 	.word	0x08027829
 802781c:	08027863 	.word	0x08027863
 8027820:	080278a9 	.word	0x080278a9
 8027824:	080278a9 	.word	0x080278a9
  /*                                        3 - Mark                             */
  /*                                        4 - Space                            */
  /* 6      | bDataBits  |   1   | Number Data bits (5, 6, 7, 8 or 16).          */
  /*******************************************************************************/
    case CDC_SET_LINE_CODING:
    	temp[0] = pbuf[0];
 8027828:	683b      	ldr	r3, [r7, #0]
 802782a:	781a      	ldrb	r2, [r3, #0]
 802782c:	4b22      	ldr	r3, [pc, #136]	@ (80278b8 <CDC_Control_FS+0x140>)
 802782e:	701a      	strb	r2, [r3, #0]
    	temp[1] = pbuf[1];
 8027830:	683b      	ldr	r3, [r7, #0]
 8027832:	785a      	ldrb	r2, [r3, #1]
 8027834:	4b20      	ldr	r3, [pc, #128]	@ (80278b8 <CDC_Control_FS+0x140>)
 8027836:	705a      	strb	r2, [r3, #1]
    	temp[2] = pbuf[2];
 8027838:	683b      	ldr	r3, [r7, #0]
 802783a:	789a      	ldrb	r2, [r3, #2]
 802783c:	4b1e      	ldr	r3, [pc, #120]	@ (80278b8 <CDC_Control_FS+0x140>)
 802783e:	709a      	strb	r2, [r3, #2]
    	temp[3] = pbuf[3];
 8027840:	683b      	ldr	r3, [r7, #0]
 8027842:	78da      	ldrb	r2, [r3, #3]
 8027844:	4b1c      	ldr	r3, [pc, #112]	@ (80278b8 <CDC_Control_FS+0x140>)
 8027846:	70da      	strb	r2, [r3, #3]
    	temp[4] = pbuf[4];
 8027848:	683b      	ldr	r3, [r7, #0]
 802784a:	791a      	ldrb	r2, [r3, #4]
 802784c:	4b1a      	ldr	r3, [pc, #104]	@ (80278b8 <CDC_Control_FS+0x140>)
 802784e:	711a      	strb	r2, [r3, #4]
    	temp[5] = pbuf[5];
 8027850:	683b      	ldr	r3, [r7, #0]
 8027852:	795a      	ldrb	r2, [r3, #5]
 8027854:	4b18      	ldr	r3, [pc, #96]	@ (80278b8 <CDC_Control_FS+0x140>)
 8027856:	715a      	strb	r2, [r3, #5]
    	temp[6] = pbuf[6];
 8027858:	683b      	ldr	r3, [r7, #0]
 802785a:	799a      	ldrb	r2, [r3, #6]
 802785c:	4b16      	ldr	r3, [pc, #88]	@ (80278b8 <CDC_Control_FS+0x140>)
 802785e:	719a      	strb	r2, [r3, #6]
    break;
 8027860:	e023      	b.n	80278aa <CDC_Control_FS+0x132>

    case CDC_GET_LINE_CODING:
    	pbuf[0] = temp[0];
 8027862:	4b15      	ldr	r3, [pc, #84]	@ (80278b8 <CDC_Control_FS+0x140>)
 8027864:	781a      	ldrb	r2, [r3, #0]
 8027866:	683b      	ldr	r3, [r7, #0]
 8027868:	701a      	strb	r2, [r3, #0]
    	pbuf[1] = temp[1];
 802786a:	683b      	ldr	r3, [r7, #0]
 802786c:	3301      	adds	r3, #1
 802786e:	4a12      	ldr	r2, [pc, #72]	@ (80278b8 <CDC_Control_FS+0x140>)
 8027870:	7852      	ldrb	r2, [r2, #1]
 8027872:	701a      	strb	r2, [r3, #0]
    	pbuf[2] = temp[2];
 8027874:	683b      	ldr	r3, [r7, #0]
 8027876:	3302      	adds	r3, #2
 8027878:	4a0f      	ldr	r2, [pc, #60]	@ (80278b8 <CDC_Control_FS+0x140>)
 802787a:	7892      	ldrb	r2, [r2, #2]
 802787c:	701a      	strb	r2, [r3, #0]
    	pbuf[3] = temp[3];
 802787e:	683b      	ldr	r3, [r7, #0]
 8027880:	3303      	adds	r3, #3
 8027882:	4a0d      	ldr	r2, [pc, #52]	@ (80278b8 <CDC_Control_FS+0x140>)
 8027884:	78d2      	ldrb	r2, [r2, #3]
 8027886:	701a      	strb	r2, [r3, #0]
    	pbuf[4] = temp[4];
 8027888:	683b      	ldr	r3, [r7, #0]
 802788a:	3304      	adds	r3, #4
 802788c:	4a0a      	ldr	r2, [pc, #40]	@ (80278b8 <CDC_Control_FS+0x140>)
 802788e:	7912      	ldrb	r2, [r2, #4]
 8027890:	701a      	strb	r2, [r3, #0]
    	pbuf[5] = temp[5];
 8027892:	683b      	ldr	r3, [r7, #0]
 8027894:	3305      	adds	r3, #5
 8027896:	4a08      	ldr	r2, [pc, #32]	@ (80278b8 <CDC_Control_FS+0x140>)
 8027898:	7952      	ldrb	r2, [r2, #5]
 802789a:	701a      	strb	r2, [r3, #0]
    	pbuf[6] = temp[6];
 802789c:	683b      	ldr	r3, [r7, #0]
 802789e:	3306      	adds	r3, #6
 80278a0:	4a05      	ldr	r2, [pc, #20]	@ (80278b8 <CDC_Control_FS+0x140>)
 80278a2:	7992      	ldrb	r2, [r2, #6]
 80278a4:	701a      	strb	r2, [r3, #0]
    break;
 80278a6:	e000      	b.n	80278aa <CDC_Control_FS+0x132>
    case CDC_SEND_BREAK:

    break;

  default:
    break;
 80278a8:	bf00      	nop
  }

  return (USBD_OK);
 80278aa:	2300      	movs	r3, #0
  /* USER CODE END 5 */
}
 80278ac:	4618      	mov	r0, r3
 80278ae:	370c      	adds	r7, #12
 80278b0:	46bd      	mov	sp, r7
 80278b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80278b6:	4770      	bx	lr
 80278b8:	200039f8 	.word	0x200039f8

080278bc <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
 80278bc:	b580      	push	{r7, lr}
 80278be:	b082      	sub	sp, #8
 80278c0:	af00      	add	r7, sp, #0
 80278c2:	6078      	str	r0, [r7, #4]
 80278c4:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 80278c6:	6879      	ldr	r1, [r7, #4]
 80278c8:	4822      	ldr	r0, [pc, #136]	@ (8027954 <CDC_Receive_FS+0x98>)
 80278ca:	f7df fc51 	bl	8007170 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 80278ce:	4821      	ldr	r0, [pc, #132]	@ (8027954 <CDC_Receive_FS+0x98>)
 80278d0:	f7df fcac 	bl	800722c <USBD_CDC_ReceivePacket>
  if (*Len == 0 || Buf == NULL) return USBD_OK;
 80278d4:	683b      	ldr	r3, [r7, #0]
 80278d6:	681b      	ldr	r3, [r3, #0]
 80278d8:	2b00      	cmp	r3, #0
 80278da:	d002      	beq.n	80278e2 <CDC_Receive_FS+0x26>
 80278dc:	687b      	ldr	r3, [r7, #4]
 80278de:	2b00      	cmp	r3, #0
 80278e0:	d101      	bne.n	80278e6 <CDC_Receive_FS+0x2a>
 80278e2:	2300      	movs	r3, #0
 80278e4:	e032      	b.n	802794c <CDC_Receive_FS+0x90>
  // spravy sa prijimaju po 64 bytovych kuskoch - paketoch.
  // po odoslani celej spravy posielam dalsiu, ktora sa sklada iba zo znaku '\r', teda dlzka je 1.
  // teoreticky moze nastat edge case kedy povodna sprava sa tak rozkuskuje,
  // ze posledny byte spravy pride sam a sklada sa iba z '\r' co vtedy by nastal problem, ale pre zatial sa to neoplati riesit.
  // uz len to ze som mal pripad ze prijaty paket sa zacina prave na '\r' je celkom uletene.
  if (Buf[0] == '\r' && *Len == 1) {
 80278e6:	687b      	ldr	r3, [r7, #4]
 80278e8:	781b      	ldrb	r3, [r3, #0]
 80278ea:	2b0d      	cmp	r3, #13
 80278ec:	d108      	bne.n	8027900 <CDC_Receive_FS+0x44>
 80278ee:	683b      	ldr	r3, [r7, #0]
 80278f0:	681b      	ldr	r3, [r3, #0]
 80278f2:	2b01      	cmp	r3, #1
 80278f4:	d104      	bne.n	8027900 <CDC_Receive_FS+0x44>
      dataReceivedFlag = 1;
 80278f6:	4b18      	ldr	r3, [pc, #96]	@ (8027958 <CDC_Receive_FS+0x9c>)
 80278f8:	2201      	movs	r2, #1
 80278fa:	701a      	strb	r2, [r3, #0]
      return USBD_OK;
 80278fc:	2300      	movs	r3, #0
 80278fe:	e025      	b.n	802794c <CDC_Receive_FS+0x90>
  }
  // receiveBuffer ma velkost 2500, nie je to dobre ze je to takto hardcoded.
  // ale iba 3. sprava sa k tomu velkostne blizi.
  if ((receiveCounter + *Len) < 2000) {
 8027900:	4b16      	ldr	r3, [pc, #88]	@ (802795c <CDC_Receive_FS+0xa0>)
 8027902:	881b      	ldrh	r3, [r3, #0]
 8027904:	461a      	mov	r2, r3
 8027906:	683b      	ldr	r3, [r7, #0]
 8027908:	681b      	ldr	r3, [r3, #0]
 802790a:	4413      	add	r3, r2
 802790c:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8027910:	d215      	bcs.n	802793e <CDC_Receive_FS+0x82>
      memcpy(&receiveBuffer[receiveCounter], Buf, *Len);
 8027912:	4b12      	ldr	r3, [pc, #72]	@ (802795c <CDC_Receive_FS+0xa0>)
 8027914:	881b      	ldrh	r3, [r3, #0]
 8027916:	461a      	mov	r2, r3
 8027918:	4b11      	ldr	r3, [pc, #68]	@ (8027960 <CDC_Receive_FS+0xa4>)
 802791a:	18d0      	adds	r0, r2, r3
 802791c:	683b      	ldr	r3, [r7, #0]
 802791e:	681b      	ldr	r3, [r3, #0]
 8027920:	461a      	mov	r2, r3
 8027922:	6879      	ldr	r1, [r7, #4]
 8027924:	f000 fe3e 	bl	80285a4 <memcpy>
      receiveCounter += *Len;
 8027928:	683b      	ldr	r3, [r7, #0]
 802792a:	681b      	ldr	r3, [r3, #0]
 802792c:	b29a      	uxth	r2, r3
 802792e:	4b0b      	ldr	r3, [pc, #44]	@ (802795c <CDC_Receive_FS+0xa0>)
 8027930:	881b      	ldrh	r3, [r3, #0]
 8027932:	4413      	add	r3, r2
 8027934:	b29a      	uxth	r2, r3
 8027936:	4b09      	ldr	r3, [pc, #36]	@ (802795c <CDC_Receive_FS+0xa0>)
 8027938:	801a      	strh	r2, [r3, #0]
      // Buffer overflow handler, to je asi nieco do buducna.
      receiveCounter = 0;
      dataReceivedFlag = 0;
      return USBD_FAIL;
  }
  return USBD_OK;
 802793a:	2300      	movs	r3, #0
 802793c:	e006      	b.n	802794c <CDC_Receive_FS+0x90>
      receiveCounter = 0;
 802793e:	4b07      	ldr	r3, [pc, #28]	@ (802795c <CDC_Receive_FS+0xa0>)
 8027940:	2200      	movs	r2, #0
 8027942:	801a      	strh	r2, [r3, #0]
      dataReceivedFlag = 0;
 8027944:	4b04      	ldr	r3, [pc, #16]	@ (8027958 <CDC_Receive_FS+0x9c>)
 8027946:	2200      	movs	r2, #0
 8027948:	701a      	strb	r2, [r3, #0]
      return USBD_FAIL;
 802794a:	2303      	movs	r3, #3
  /* USER CODE END 6 */
}
 802794c:	4618      	mov	r0, r3
 802794e:	3708      	adds	r7, #8
 8027950:	46bd      	mov	sp, r7
 8027952:	bd80      	pop	{r7, pc}
 8027954:	2000271c 	.word	0x2000271c
 8027958:	20001508 	.word	0x20001508
 802795c:	20001cdc 	.word	0x20001cdc
 8027960:	2000150c 	.word	0x2000150c

08027964 <CDC_Transmit_FS>:
  * @param  Buf: Buffer of data to be sent
  * @param  Len: Number of data to be sent (in bytes)
  * @retval USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
 8027964:	b580      	push	{r7, lr}
 8027966:	b084      	sub	sp, #16
 8027968:	af00      	add	r7, sp, #0
 802796a:	6078      	str	r0, [r7, #4]
 802796c:	460b      	mov	r3, r1
 802796e:	807b      	strh	r3, [r7, #2]
  uint8_t result = USBD_OK;
 8027970:	2300      	movs	r3, #0
 8027972:	73fb      	strb	r3, [r7, #15]
  /* USER CODE BEGIN 7 */
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 8027974:	4b0d      	ldr	r3, [pc, #52]	@ (80279ac <CDC_Transmit_FS+0x48>)
 8027976:	f8d3 32bc 	ldr.w	r3, [r3, #700]	@ 0x2bc
 802797a:	60bb      	str	r3, [r7, #8]
  if (hcdc->TxState != 0){
 802797c:	68bb      	ldr	r3, [r7, #8]
 802797e:	f8d3 3214 	ldr.w	r3, [r3, #532]	@ 0x214
 8027982:	2b00      	cmp	r3, #0
 8027984:	d001      	beq.n	802798a <CDC_Transmit_FS+0x26>
    return USBD_BUSY;
 8027986:	2301      	movs	r3, #1
 8027988:	e00b      	b.n	80279a2 <CDC_Transmit_FS+0x3e>
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 802798a:	887b      	ldrh	r3, [r7, #2]
 802798c:	461a      	mov	r2, r3
 802798e:	6879      	ldr	r1, [r7, #4]
 8027990:	4806      	ldr	r0, [pc, #24]	@ (80279ac <CDC_Transmit_FS+0x48>)
 8027992:	f7df fbcb 	bl	800712c <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 8027996:	4805      	ldr	r0, [pc, #20]	@ (80279ac <CDC_Transmit_FS+0x48>)
 8027998:	f7df fc08 	bl	80071ac <USBD_CDC_TransmitPacket>
 802799c:	4603      	mov	r3, r0
 802799e:	73fb      	strb	r3, [r7, #15]
  /* USER CODE END 7 */
  return result;
 80279a0:	7bfb      	ldrb	r3, [r7, #15]
}
 80279a2:	4618      	mov	r0, r3
 80279a4:	3710      	adds	r7, #16
 80279a6:	46bd      	mov	sp, r7
 80279a8:	bd80      	pop	{r7, pc}
 80279aa:	bf00      	nop
 80279ac:	2000271c 	.word	0x2000271c

080279b0 <CDC_TransmitCplt_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_TransmitCplt_FS(uint8_t *Buf, uint32_t *Len, uint8_t epnum)
{
 80279b0:	b480      	push	{r7}
 80279b2:	b087      	sub	sp, #28
 80279b4:	af00      	add	r7, sp, #0
 80279b6:	60f8      	str	r0, [r7, #12]
 80279b8:	60b9      	str	r1, [r7, #8]
 80279ba:	4613      	mov	r3, r2
 80279bc:	71fb      	strb	r3, [r7, #7]
  uint8_t result = USBD_OK;
 80279be:	2300      	movs	r3, #0
 80279c0:	75fb      	strb	r3, [r7, #23]
  /* USER CODE BEGIN 13 */
  UNUSED(Buf);
  UNUSED(Len);
  UNUSED(epnum);
  /* USER CODE END 13 */
  return result;
 80279c2:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 80279c6:	4618      	mov	r0, r3
 80279c8:	371c      	adds	r7, #28
 80279ca:	46bd      	mov	sp, r7
 80279cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80279d0:	4770      	bx	lr
	...

080279d4 <USBD_FS_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80279d4:	b480      	push	{r7}
 80279d6:	b083      	sub	sp, #12
 80279d8:	af00      	add	r7, sp, #0
 80279da:	4603      	mov	r3, r0
 80279dc:	6039      	str	r1, [r7, #0]
 80279de:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 80279e0:	683b      	ldr	r3, [r7, #0]
 80279e2:	2212      	movs	r2, #18
 80279e4:	801a      	strh	r2, [r3, #0]
  return USBD_FS_DeviceDesc;
 80279e6:	4b03      	ldr	r3, [pc, #12]	@ (80279f4 <USBD_FS_DeviceDescriptor+0x20>)
}
 80279e8:	4618      	mov	r0, r3
 80279ea:	370c      	adds	r7, #12
 80279ec:	46bd      	mov	sp, r7
 80279ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80279f2:	4770      	bx	lr
 80279f4:	20000100 	.word	0x20000100

080279f8 <USBD_FS_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80279f8:	b480      	push	{r7}
 80279fa:	b083      	sub	sp, #12
 80279fc:	af00      	add	r7, sp, #0
 80279fe:	4603      	mov	r3, r0
 8027a00:	6039      	str	r1, [r7, #0]
 8027a02:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 8027a04:	683b      	ldr	r3, [r7, #0]
 8027a06:	2204      	movs	r2, #4
 8027a08:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 8027a0a:	4b03      	ldr	r3, [pc, #12]	@ (8027a18 <USBD_FS_LangIDStrDescriptor+0x20>)
}
 8027a0c:	4618      	mov	r0, r3
 8027a0e:	370c      	adds	r7, #12
 8027a10:	46bd      	mov	sp, r7
 8027a12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027a16:	4770      	bx	lr
 8027a18:	20000114 	.word	0x20000114

08027a1c <USBD_FS_ProductStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027a1c:	b580      	push	{r7, lr}
 8027a1e:	b082      	sub	sp, #8
 8027a20:	af00      	add	r7, sp, #0
 8027a22:	4603      	mov	r3, r0
 8027a24:	6039      	str	r1, [r7, #0]
 8027a26:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8027a28:	79fb      	ldrb	r3, [r7, #7]
 8027a2a:	2b00      	cmp	r3, #0
 8027a2c:	d105      	bne.n	8027a3a <USBD_FS_ProductStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8027a2e:	683a      	ldr	r2, [r7, #0]
 8027a30:	4907      	ldr	r1, [pc, #28]	@ (8027a50 <USBD_FS_ProductStrDescriptor+0x34>)
 8027a32:	4808      	ldr	r0, [pc, #32]	@ (8027a54 <USBD_FS_ProductStrDescriptor+0x38>)
 8027a34:	f7e0 fe46 	bl	80086c4 <USBD_GetString>
 8027a38:	e004      	b.n	8027a44 <USBD_FS_ProductStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8027a3a:	683a      	ldr	r2, [r7, #0]
 8027a3c:	4904      	ldr	r1, [pc, #16]	@ (8027a50 <USBD_FS_ProductStrDescriptor+0x34>)
 8027a3e:	4805      	ldr	r0, [pc, #20]	@ (8027a54 <USBD_FS_ProductStrDescriptor+0x38>)
 8027a40:	f7e0 fe40 	bl	80086c4 <USBD_GetString>
  }
  return USBD_StrDesc;
 8027a44:	4b02      	ldr	r3, [pc, #8]	@ (8027a50 <USBD_FS_ProductStrDescriptor+0x34>)
}
 8027a46:	4618      	mov	r0, r3
 8027a48:	3708      	adds	r7, #8
 8027a4a:	46bd      	mov	sp, r7
 8027a4c:	bd80      	pop	{r7, pc}
 8027a4e:	bf00      	nop
 8027a50:	20003a00 	.word	0x20003a00
 8027a54:	0802ff58 	.word	0x0802ff58

08027a58 <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027a58:	b580      	push	{r7, lr}
 8027a5a:	b082      	sub	sp, #8
 8027a5c:	af00      	add	r7, sp, #0
 8027a5e:	4603      	mov	r3, r0
 8027a60:	6039      	str	r1, [r7, #0]
 8027a62:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8027a64:	683a      	ldr	r2, [r7, #0]
 8027a66:	4904      	ldr	r1, [pc, #16]	@ (8027a78 <USBD_FS_ManufacturerStrDescriptor+0x20>)
 8027a68:	4804      	ldr	r0, [pc, #16]	@ (8027a7c <USBD_FS_ManufacturerStrDescriptor+0x24>)
 8027a6a:	f7e0 fe2b 	bl	80086c4 <USBD_GetString>
  return USBD_StrDesc;
 8027a6e:	4b02      	ldr	r3, [pc, #8]	@ (8027a78 <USBD_FS_ManufacturerStrDescriptor+0x20>)
}
 8027a70:	4618      	mov	r0, r3
 8027a72:	3708      	adds	r7, #8
 8027a74:	46bd      	mov	sp, r7
 8027a76:	bd80      	pop	{r7, pc}
 8027a78:	20003a00 	.word	0x20003a00
 8027a7c:	0802ff70 	.word	0x0802ff70

08027a80 <USBD_FS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027a80:	b580      	push	{r7, lr}
 8027a82:	b082      	sub	sp, #8
 8027a84:	af00      	add	r7, sp, #0
 8027a86:	4603      	mov	r3, r0
 8027a88:	6039      	str	r1, [r7, #0]
 8027a8a:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
 8027a8c:	683b      	ldr	r3, [r7, #0]
 8027a8e:	221a      	movs	r2, #26
 8027a90:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
 8027a92:	f000 f843 	bl	8027b1c <Get_SerialNum>
  /* USER CODE BEGIN USBD_FS_SerialStrDescriptor */

  /* USER CODE END USBD_FS_SerialStrDescriptor */
  return (uint8_t *) USBD_StringSerial;
 8027a96:	4b02      	ldr	r3, [pc, #8]	@ (8027aa0 <USBD_FS_SerialStrDescriptor+0x20>)
}
 8027a98:	4618      	mov	r0, r3
 8027a9a:	3708      	adds	r7, #8
 8027a9c:	46bd      	mov	sp, r7
 8027a9e:	bd80      	pop	{r7, pc}
 8027aa0:	20000118 	.word	0x20000118

08027aa4 <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027aa4:	b580      	push	{r7, lr}
 8027aa6:	b082      	sub	sp, #8
 8027aa8:	af00      	add	r7, sp, #0
 8027aaa:	4603      	mov	r3, r0
 8027aac:	6039      	str	r1, [r7, #0]
 8027aae:	71fb      	strb	r3, [r7, #7]
  if(speed == USBD_SPEED_HIGH)
 8027ab0:	79fb      	ldrb	r3, [r7, #7]
 8027ab2:	2b00      	cmp	r3, #0
 8027ab4:	d105      	bne.n	8027ac2 <USBD_FS_ConfigStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8027ab6:	683a      	ldr	r2, [r7, #0]
 8027ab8:	4907      	ldr	r1, [pc, #28]	@ (8027ad8 <USBD_FS_ConfigStrDescriptor+0x34>)
 8027aba:	4808      	ldr	r0, [pc, #32]	@ (8027adc <USBD_FS_ConfigStrDescriptor+0x38>)
 8027abc:	f7e0 fe02 	bl	80086c4 <USBD_GetString>
 8027ac0:	e004      	b.n	8027acc <USBD_FS_ConfigStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8027ac2:	683a      	ldr	r2, [r7, #0]
 8027ac4:	4904      	ldr	r1, [pc, #16]	@ (8027ad8 <USBD_FS_ConfigStrDescriptor+0x34>)
 8027ac6:	4805      	ldr	r0, [pc, #20]	@ (8027adc <USBD_FS_ConfigStrDescriptor+0x38>)
 8027ac8:	f7e0 fdfc 	bl	80086c4 <USBD_GetString>
  }
  return USBD_StrDesc;
 8027acc:	4b02      	ldr	r3, [pc, #8]	@ (8027ad8 <USBD_FS_ConfigStrDescriptor+0x34>)
}
 8027ace:	4618      	mov	r0, r3
 8027ad0:	3708      	adds	r7, #8
 8027ad2:	46bd      	mov	sp, r7
 8027ad4:	bd80      	pop	{r7, pc}
 8027ad6:	bf00      	nop
 8027ad8:	20003a00 	.word	0x20003a00
 8027adc:	0802ff84 	.word	0x0802ff84

08027ae0 <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8027ae0:	b580      	push	{r7, lr}
 8027ae2:	b082      	sub	sp, #8
 8027ae4:	af00      	add	r7, sp, #0
 8027ae6:	4603      	mov	r3, r0
 8027ae8:	6039      	str	r1, [r7, #0]
 8027aea:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8027aec:	79fb      	ldrb	r3, [r7, #7]
 8027aee:	2b00      	cmp	r3, #0
 8027af0:	d105      	bne.n	8027afe <USBD_FS_InterfaceStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8027af2:	683a      	ldr	r2, [r7, #0]
 8027af4:	4907      	ldr	r1, [pc, #28]	@ (8027b14 <USBD_FS_InterfaceStrDescriptor+0x34>)
 8027af6:	4808      	ldr	r0, [pc, #32]	@ (8027b18 <USBD_FS_InterfaceStrDescriptor+0x38>)
 8027af8:	f7e0 fde4 	bl	80086c4 <USBD_GetString>
 8027afc:	e004      	b.n	8027b08 <USBD_FS_InterfaceStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8027afe:	683a      	ldr	r2, [r7, #0]
 8027b00:	4904      	ldr	r1, [pc, #16]	@ (8027b14 <USBD_FS_InterfaceStrDescriptor+0x34>)
 8027b02:	4805      	ldr	r0, [pc, #20]	@ (8027b18 <USBD_FS_InterfaceStrDescriptor+0x38>)
 8027b04:	f7e0 fdde 	bl	80086c4 <USBD_GetString>
  }
  return USBD_StrDesc;
 8027b08:	4b02      	ldr	r3, [pc, #8]	@ (8027b14 <USBD_FS_InterfaceStrDescriptor+0x34>)
}
 8027b0a:	4618      	mov	r0, r3
 8027b0c:	3708      	adds	r7, #8
 8027b0e:	46bd      	mov	sp, r7
 8027b10:	bd80      	pop	{r7, pc}
 8027b12:	bf00      	nop
 8027b14:	20003a00 	.word	0x20003a00
 8027b18:	0802ff90 	.word	0x0802ff90

08027b1c <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
 8027b1c:	b580      	push	{r7, lr}
 8027b1e:	b084      	sub	sp, #16
 8027b20:	af00      	add	r7, sp, #0
  uint32_t deviceserial0;
  uint32_t deviceserial1;
  uint32_t deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 8027b22:	4b0f      	ldr	r3, [pc, #60]	@ (8027b60 <Get_SerialNum+0x44>)
 8027b24:	681b      	ldr	r3, [r3, #0]
 8027b26:	60fb      	str	r3, [r7, #12]
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 8027b28:	4b0e      	ldr	r3, [pc, #56]	@ (8027b64 <Get_SerialNum+0x48>)
 8027b2a:	681b      	ldr	r3, [r3, #0]
 8027b2c:	60bb      	str	r3, [r7, #8]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 8027b2e:	4b0e      	ldr	r3, [pc, #56]	@ (8027b68 <Get_SerialNum+0x4c>)
 8027b30:	681b      	ldr	r3, [r3, #0]
 8027b32:	607b      	str	r3, [r7, #4]

  deviceserial0 += deviceserial2;
 8027b34:	68fa      	ldr	r2, [r7, #12]
 8027b36:	687b      	ldr	r3, [r7, #4]
 8027b38:	4413      	add	r3, r2
 8027b3a:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
 8027b3c:	68fb      	ldr	r3, [r7, #12]
 8027b3e:	2b00      	cmp	r3, #0
 8027b40:	d009      	beq.n	8027b56 <Get_SerialNum+0x3a>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 8027b42:	2208      	movs	r2, #8
 8027b44:	4909      	ldr	r1, [pc, #36]	@ (8027b6c <Get_SerialNum+0x50>)
 8027b46:	68f8      	ldr	r0, [r7, #12]
 8027b48:	f000 f814 	bl	8027b74 <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 8027b4c:	2204      	movs	r2, #4
 8027b4e:	4908      	ldr	r1, [pc, #32]	@ (8027b70 <Get_SerialNum+0x54>)
 8027b50:	68b8      	ldr	r0, [r7, #8]
 8027b52:	f000 f80f 	bl	8027b74 <IntToUnicode>
  }
}
 8027b56:	bf00      	nop
 8027b58:	3710      	adds	r7, #16
 8027b5a:	46bd      	mov	sp, r7
 8027b5c:	bd80      	pop	{r7, pc}
 8027b5e:	bf00      	nop
 8027b60:	1fff7a10 	.word	0x1fff7a10
 8027b64:	1fff7a14 	.word	0x1fff7a14
 8027b68:	1fff7a18 	.word	0x1fff7a18
 8027b6c:	2000011a 	.word	0x2000011a
 8027b70:	2000012a 	.word	0x2000012a

08027b74 <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 8027b74:	b480      	push	{r7}
 8027b76:	b087      	sub	sp, #28
 8027b78:	af00      	add	r7, sp, #0
 8027b7a:	60f8      	str	r0, [r7, #12]
 8027b7c:	60b9      	str	r1, [r7, #8]
 8027b7e:	4613      	mov	r3, r2
 8027b80:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
 8027b82:	2300      	movs	r3, #0
 8027b84:	75fb      	strb	r3, [r7, #23]

  for (idx = 0; idx < len; idx++)
 8027b86:	2300      	movs	r3, #0
 8027b88:	75fb      	strb	r3, [r7, #23]
 8027b8a:	e027      	b.n	8027bdc <IntToUnicode+0x68>
  {
    if (((value >> 28)) < 0xA)
 8027b8c:	68fb      	ldr	r3, [r7, #12]
 8027b8e:	0f1b      	lsrs	r3, r3, #28
 8027b90:	2b09      	cmp	r3, #9
 8027b92:	d80b      	bhi.n	8027bac <IntToUnicode+0x38>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 8027b94:	68fb      	ldr	r3, [r7, #12]
 8027b96:	0f1b      	lsrs	r3, r3, #28
 8027b98:	b2da      	uxtb	r2, r3
 8027b9a:	7dfb      	ldrb	r3, [r7, #23]
 8027b9c:	005b      	lsls	r3, r3, #1
 8027b9e:	4619      	mov	r1, r3
 8027ba0:	68bb      	ldr	r3, [r7, #8]
 8027ba2:	440b      	add	r3, r1
 8027ba4:	3230      	adds	r2, #48	@ 0x30
 8027ba6:	b2d2      	uxtb	r2, r2
 8027ba8:	701a      	strb	r2, [r3, #0]
 8027baa:	e00a      	b.n	8027bc2 <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8027bac:	68fb      	ldr	r3, [r7, #12]
 8027bae:	0f1b      	lsrs	r3, r3, #28
 8027bb0:	b2da      	uxtb	r2, r3
 8027bb2:	7dfb      	ldrb	r3, [r7, #23]
 8027bb4:	005b      	lsls	r3, r3, #1
 8027bb6:	4619      	mov	r1, r3
 8027bb8:	68bb      	ldr	r3, [r7, #8]
 8027bba:	440b      	add	r3, r1
 8027bbc:	3237      	adds	r2, #55	@ 0x37
 8027bbe:	b2d2      	uxtb	r2, r2
 8027bc0:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
 8027bc2:	68fb      	ldr	r3, [r7, #12]
 8027bc4:	011b      	lsls	r3, r3, #4
 8027bc6:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
 8027bc8:	7dfb      	ldrb	r3, [r7, #23]
 8027bca:	005b      	lsls	r3, r3, #1
 8027bcc:	3301      	adds	r3, #1
 8027bce:	68ba      	ldr	r2, [r7, #8]
 8027bd0:	4413      	add	r3, r2
 8027bd2:	2200      	movs	r2, #0
 8027bd4:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
 8027bd6:	7dfb      	ldrb	r3, [r7, #23]
 8027bd8:	3301      	adds	r3, #1
 8027bda:	75fb      	strb	r3, [r7, #23]
 8027bdc:	7dfa      	ldrb	r2, [r7, #23]
 8027bde:	79fb      	ldrb	r3, [r7, #7]
 8027be0:	429a      	cmp	r2, r3
 8027be2:	d3d3      	bcc.n	8027b8c <IntToUnicode+0x18>
  }
}
 8027be4:	bf00      	nop
 8027be6:	bf00      	nop
 8027be8:	371c      	adds	r7, #28
 8027bea:	46bd      	mov	sp, r7
 8027bec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027bf0:	4770      	bx	lr
	...

08027bf4 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8027bf4:	b580      	push	{r7, lr}
 8027bf6:	b08a      	sub	sp, #40	@ 0x28
 8027bf8:	af00      	add	r7, sp, #0
 8027bfa:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8027bfc:	f107 0314 	add.w	r3, r7, #20
 8027c00:	2200      	movs	r2, #0
 8027c02:	601a      	str	r2, [r3, #0]
 8027c04:	605a      	str	r2, [r3, #4]
 8027c06:	609a      	str	r2, [r3, #8]
 8027c08:	60da      	str	r2, [r3, #12]
 8027c0a:	611a      	str	r2, [r3, #16]
  if(pcdHandle->Instance==USB_OTG_FS)
 8027c0c:	687b      	ldr	r3, [r7, #4]
 8027c0e:	681b      	ldr	r3, [r3, #0]
 8027c10:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8027c14:	d147      	bne.n	8027ca6 <HAL_PCD_MspInit+0xb2>
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8027c16:	2300      	movs	r3, #0
 8027c18:	613b      	str	r3, [r7, #16]
 8027c1a:	4b25      	ldr	r3, [pc, #148]	@ (8027cb0 <HAL_PCD_MspInit+0xbc>)
 8027c1c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8027c1e:	4a24      	ldr	r2, [pc, #144]	@ (8027cb0 <HAL_PCD_MspInit+0xbc>)
 8027c20:	f043 0301 	orr.w	r3, r3, #1
 8027c24:	6313      	str	r3, [r2, #48]	@ 0x30
 8027c26:	4b22      	ldr	r3, [pc, #136]	@ (8027cb0 <HAL_PCD_MspInit+0xbc>)
 8027c28:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8027c2a:	f003 0301 	and.w	r3, r3, #1
 8027c2e:	613b      	str	r3, [r7, #16]
 8027c30:	693b      	ldr	r3, [r7, #16]
    PA9     ------> USB_OTG_FS_VBUS
    PA10     ------> USB_OTG_FS_ID
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.Pin = VBUS_FS_Pin;
 8027c32:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8027c36:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8027c38:	2300      	movs	r3, #0
 8027c3a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8027c3c:	2300      	movs	r3, #0
 8027c3e:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);
 8027c40:	f107 0314 	add.w	r3, r7, #20
 8027c44:	4619      	mov	r1, r3
 8027c46:	481b      	ldr	r0, [pc, #108]	@ (8027cb4 <HAL_PCD_MspInit+0xc0>)
 8027c48:	f7da fa10 	bl	800206c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = OTG_FS_ID_Pin|OTG_FS_DM_Pin|OTG_FS_DP_Pin;
 8027c4c:	f44f 53e0 	mov.w	r3, #7168	@ 0x1c00
 8027c50:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8027c52:	2302      	movs	r3, #2
 8027c54:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8027c56:	2300      	movs	r3, #0
 8027c58:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8027c5a:	2300      	movs	r3, #0
 8027c5c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8027c5e:	230a      	movs	r3, #10
 8027c60:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8027c62:	f107 0314 	add.w	r3, r7, #20
 8027c66:	4619      	mov	r1, r3
 8027c68:	4812      	ldr	r0, [pc, #72]	@ (8027cb4 <HAL_PCD_MspInit+0xc0>)
 8027c6a:	f7da f9ff 	bl	800206c <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8027c6e:	4b10      	ldr	r3, [pc, #64]	@ (8027cb0 <HAL_PCD_MspInit+0xbc>)
 8027c70:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8027c72:	4a0f      	ldr	r2, [pc, #60]	@ (8027cb0 <HAL_PCD_MspInit+0xbc>)
 8027c74:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8027c78:	6353      	str	r3, [r2, #52]	@ 0x34
 8027c7a:	2300      	movs	r3, #0
 8027c7c:	60fb      	str	r3, [r7, #12]
 8027c7e:	4b0c      	ldr	r3, [pc, #48]	@ (8027cb0 <HAL_PCD_MspInit+0xbc>)
 8027c80:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8027c82:	4a0b      	ldr	r2, [pc, #44]	@ (8027cb0 <HAL_PCD_MspInit+0xbc>)
 8027c84:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8027c88:	6453      	str	r3, [r2, #68]	@ 0x44
 8027c8a:	4b09      	ldr	r3, [pc, #36]	@ (8027cb0 <HAL_PCD_MspInit+0xbc>)
 8027c8c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8027c8e:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8027c92:	60fb      	str	r3, [r7, #12]
 8027c94:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8027c96:	2200      	movs	r2, #0
 8027c98:	2100      	movs	r1, #0
 8027c9a:	2043      	movs	r0, #67	@ 0x43
 8027c9c:	f7da f993 	bl	8001fc6 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8027ca0:	2043      	movs	r0, #67	@ 0x43
 8027ca2:	f7da f9ac 	bl	8001ffe <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8027ca6:	bf00      	nop
 8027ca8:	3728      	adds	r7, #40	@ 0x28
 8027caa:	46bd      	mov	sp, r7
 8027cac:	bd80      	pop	{r7, pc}
 8027cae:	bf00      	nop
 8027cb0:	40023800 	.word	0x40023800
 8027cb4:	40020000 	.word	0x40020000

08027cb8 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027cb8:	b580      	push	{r7, lr}
 8027cba:	b082      	sub	sp, #8
 8027cbc:	af00      	add	r7, sp, #0
 8027cbe:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8027cc0:	687b      	ldr	r3, [r7, #4]
 8027cc2:	f8d3 24e0 	ldr.w	r2, [r3, #1248]	@ 0x4e0
 8027cc6:	687b      	ldr	r3, [r7, #4]
 8027cc8:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8027ccc:	4619      	mov	r1, r3
 8027cce:	4610      	mov	r0, r2
 8027cd0:	f7df fb95 	bl	80073fe <USBD_LL_SetupStage>
}
 8027cd4:	bf00      	nop
 8027cd6:	3708      	adds	r7, #8
 8027cd8:	46bd      	mov	sp, r7
 8027cda:	bd80      	pop	{r7, pc}

08027cdc <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027cdc:	b580      	push	{r7, lr}
 8027cde:	b082      	sub	sp, #8
 8027ce0:	af00      	add	r7, sp, #0
 8027ce2:	6078      	str	r0, [r7, #4]
 8027ce4:	460b      	mov	r3, r1
 8027ce6:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8027ce8:	687b      	ldr	r3, [r7, #4]
 8027cea:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 8027cee:	78fa      	ldrb	r2, [r7, #3]
 8027cf0:	6879      	ldr	r1, [r7, #4]
 8027cf2:	4613      	mov	r3, r2
 8027cf4:	00db      	lsls	r3, r3, #3
 8027cf6:	4413      	add	r3, r2
 8027cf8:	009b      	lsls	r3, r3, #2
 8027cfa:	440b      	add	r3, r1
 8027cfc:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 8027d00:	681a      	ldr	r2, [r3, #0]
 8027d02:	78fb      	ldrb	r3, [r7, #3]
 8027d04:	4619      	mov	r1, r3
 8027d06:	f7df fbcf 	bl	80074a8 <USBD_LL_DataOutStage>
}
 8027d0a:	bf00      	nop
 8027d0c:	3708      	adds	r7, #8
 8027d0e:	46bd      	mov	sp, r7
 8027d10:	bd80      	pop	{r7, pc}

08027d12 <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027d12:	b580      	push	{r7, lr}
 8027d14:	b082      	sub	sp, #8
 8027d16:	af00      	add	r7, sp, #0
 8027d18:	6078      	str	r0, [r7, #4]
 8027d1a:	460b      	mov	r3, r1
 8027d1c:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8027d1e:	687b      	ldr	r3, [r7, #4]
 8027d20:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 8027d24:	78fa      	ldrb	r2, [r7, #3]
 8027d26:	6879      	ldr	r1, [r7, #4]
 8027d28:	4613      	mov	r3, r2
 8027d2a:	00db      	lsls	r3, r3, #3
 8027d2c:	4413      	add	r3, r2
 8027d2e:	009b      	lsls	r3, r3, #2
 8027d30:	440b      	add	r3, r1
 8027d32:	3320      	adds	r3, #32
 8027d34:	681a      	ldr	r2, [r3, #0]
 8027d36:	78fb      	ldrb	r3, [r7, #3]
 8027d38:	4619      	mov	r1, r3
 8027d3a:	f7df fc68 	bl	800760e <USBD_LL_DataInStage>
}
 8027d3e:	bf00      	nop
 8027d40:	3708      	adds	r7, #8
 8027d42:	46bd      	mov	sp, r7
 8027d44:	bd80      	pop	{r7, pc}

08027d46 <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027d46:	b580      	push	{r7, lr}
 8027d48:	b082      	sub	sp, #8
 8027d4a:	af00      	add	r7, sp, #0
 8027d4c:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8027d4e:	687b      	ldr	r3, [r7, #4]
 8027d50:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027d54:	4618      	mov	r0, r3
 8027d56:	f7df fda2 	bl	800789e <USBD_LL_SOF>
}
 8027d5a:	bf00      	nop
 8027d5c:	3708      	adds	r7, #8
 8027d5e:	46bd      	mov	sp, r7
 8027d60:	bd80      	pop	{r7, pc}

08027d62 <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027d62:	b580      	push	{r7, lr}
 8027d64:	b084      	sub	sp, #16
 8027d66:	af00      	add	r7, sp, #0
 8027d68:	6078      	str	r0, [r7, #4]
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 8027d6a:	2301      	movs	r3, #1
 8027d6c:	73fb      	strb	r3, [r7, #15]

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8027d6e:	687b      	ldr	r3, [r7, #4]
 8027d70:	79db      	ldrb	r3, [r3, #7]
 8027d72:	2b00      	cmp	r3, #0
 8027d74:	d102      	bne.n	8027d7c <HAL_PCD_ResetCallback+0x1a>
  {
    speed = USBD_SPEED_HIGH;
 8027d76:	2300      	movs	r3, #0
 8027d78:	73fb      	strb	r3, [r7, #15]
 8027d7a:	e008      	b.n	8027d8e <HAL_PCD_ResetCallback+0x2c>
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 8027d7c:	687b      	ldr	r3, [r7, #4]
 8027d7e:	79db      	ldrb	r3, [r3, #7]
 8027d80:	2b02      	cmp	r3, #2
 8027d82:	d102      	bne.n	8027d8a <HAL_PCD_ResetCallback+0x28>
  {
    speed = USBD_SPEED_FULL;
 8027d84:	2301      	movs	r3, #1
 8027d86:	73fb      	strb	r3, [r7, #15]
 8027d88:	e001      	b.n	8027d8e <HAL_PCD_ResetCallback+0x2c>
  }
  else
  {
    Error_Handler();
 8027d8a:	f7d9 fd3f 	bl	800180c <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8027d8e:	687b      	ldr	r3, [r7, #4]
 8027d90:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027d94:	7bfa      	ldrb	r2, [r7, #15]
 8027d96:	4611      	mov	r1, r2
 8027d98:	4618      	mov	r0, r3
 8027d9a:	f7df fd3c 	bl	8007816 <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8027d9e:	687b      	ldr	r3, [r7, #4]
 8027da0:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027da4:	4618      	mov	r0, r3
 8027da6:	f7df fce4 	bl	8007772 <USBD_LL_Reset>
}
 8027daa:	bf00      	nop
 8027dac:	3710      	adds	r7, #16
 8027dae:	46bd      	mov	sp, r7
 8027db0:	bd80      	pop	{r7, pc}
	...

08027db4 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027db4:	b580      	push	{r7, lr}
 8027db6:	b082      	sub	sp, #8
 8027db8:	af00      	add	r7, sp, #0
 8027dba:	6078      	str	r0, [r7, #4]
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8027dbc:	687b      	ldr	r3, [r7, #4]
 8027dbe:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027dc2:	4618      	mov	r0, r3
 8027dc4:	f7df fd37 	bl	8007836 <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8027dc8:	687b      	ldr	r3, [r7, #4]
 8027dca:	681b      	ldr	r3, [r3, #0]
 8027dcc:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8027dd0:	681b      	ldr	r3, [r3, #0]
 8027dd2:	687a      	ldr	r2, [r7, #4]
 8027dd4:	6812      	ldr	r2, [r2, #0]
 8027dd6:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 8027dda:	f043 0301 	orr.w	r3, r3, #1
 8027dde:	6013      	str	r3, [r2, #0]
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8027de0:	687b      	ldr	r3, [r7, #4]
 8027de2:	7adb      	ldrb	r3, [r3, #11]
 8027de4:	2b00      	cmp	r3, #0
 8027de6:	d005      	beq.n	8027df4 <HAL_PCD_SuspendCallback+0x40>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8027de8:	4b04      	ldr	r3, [pc, #16]	@ (8027dfc <HAL_PCD_SuspendCallback+0x48>)
 8027dea:	691b      	ldr	r3, [r3, #16]
 8027dec:	4a03      	ldr	r2, [pc, #12]	@ (8027dfc <HAL_PCD_SuspendCallback+0x48>)
 8027dee:	f043 0306 	orr.w	r3, r3, #6
 8027df2:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8027df4:	bf00      	nop
 8027df6:	3708      	adds	r7, #8
 8027df8:	46bd      	mov	sp, r7
 8027dfa:	bd80      	pop	{r7, pc}
 8027dfc:	e000ed00 	.word	0xe000ed00

08027e00 <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027e00:	b580      	push	{r7, lr}
 8027e02:	b082      	sub	sp, #8
 8027e04:	af00      	add	r7, sp, #0
 8027e06:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8027e08:	687b      	ldr	r3, [r7, #4]
 8027e0a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027e0e:	4618      	mov	r0, r3
 8027e10:	f7df fd2d 	bl	800786e <USBD_LL_Resume>
}
 8027e14:	bf00      	nop
 8027e16:	3708      	adds	r7, #8
 8027e18:	46bd      	mov	sp, r7
 8027e1a:	bd80      	pop	{r7, pc}

08027e1c <HAL_PCD_ISOOUTIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027e1c:	b580      	push	{r7, lr}
 8027e1e:	b082      	sub	sp, #8
 8027e20:	af00      	add	r7, sp, #0
 8027e22:	6078      	str	r0, [r7, #4]
 8027e24:	460b      	mov	r3, r1
 8027e26:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8027e28:	687b      	ldr	r3, [r7, #4]
 8027e2a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027e2e:	78fa      	ldrb	r2, [r7, #3]
 8027e30:	4611      	mov	r1, r2
 8027e32:	4618      	mov	r0, r3
 8027e34:	f7df fd85 	bl	8007942 <USBD_LL_IsoOUTIncomplete>
}
 8027e38:	bf00      	nop
 8027e3a:	3708      	adds	r7, #8
 8027e3c:	46bd      	mov	sp, r7
 8027e3e:	bd80      	pop	{r7, pc}

08027e40 <HAL_PCD_ISOINIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027e40:	b580      	push	{r7, lr}
 8027e42:	b082      	sub	sp, #8
 8027e44:	af00      	add	r7, sp, #0
 8027e46:	6078      	str	r0, [r7, #4]
 8027e48:	460b      	mov	r3, r1
 8027e4a:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8027e4c:	687b      	ldr	r3, [r7, #4]
 8027e4e:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027e52:	78fa      	ldrb	r2, [r7, #3]
 8027e54:	4611      	mov	r1, r2
 8027e56:	4618      	mov	r0, r3
 8027e58:	f7df fd41 	bl	80078de <USBD_LL_IsoINIncomplete>
}
 8027e5c:	bf00      	nop
 8027e5e:	3708      	adds	r7, #8
 8027e60:	46bd      	mov	sp, r7
 8027e62:	bd80      	pop	{r7, pc}

08027e64 <HAL_PCD_ConnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027e64:	b580      	push	{r7, lr}
 8027e66:	b082      	sub	sp, #8
 8027e68:	af00      	add	r7, sp, #0
 8027e6a:	6078      	str	r0, [r7, #4]
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8027e6c:	687b      	ldr	r3, [r7, #4]
 8027e6e:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027e72:	4618      	mov	r0, r3
 8027e74:	f7df fd97 	bl	80079a6 <USBD_LL_DevConnected>
}
 8027e78:	bf00      	nop
 8027e7a:	3708      	adds	r7, #8
 8027e7c:	46bd      	mov	sp, r7
 8027e7e:	bd80      	pop	{r7, pc}

08027e80 <HAL_PCD_DisconnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8027e80:	b580      	push	{r7, lr}
 8027e82:	b082      	sub	sp, #8
 8027e84:	af00      	add	r7, sp, #0
 8027e86:	6078      	str	r0, [r7, #4]
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8027e88:	687b      	ldr	r3, [r7, #4]
 8027e8a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8027e8e:	4618      	mov	r0, r3
 8027e90:	f7df fd94 	bl	80079bc <USBD_LL_DevDisconnected>
}
 8027e94:	bf00      	nop
 8027e96:	3708      	adds	r7, #8
 8027e98:	46bd      	mov	sp, r7
 8027e9a:	bd80      	pop	{r7, pc}

08027e9c <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 8027e9c:	b580      	push	{r7, lr}
 8027e9e:	b082      	sub	sp, #8
 8027ea0:	af00      	add	r7, sp, #0
 8027ea2:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 8027ea4:	687b      	ldr	r3, [r7, #4]
 8027ea6:	781b      	ldrb	r3, [r3, #0]
 8027ea8:	2b00      	cmp	r3, #0
 8027eaa:	d13c      	bne.n	8027f26 <USBD_LL_Init+0x8a>
  /* Link the driver to the stack. */
  hpcd_USB_OTG_FS.pData = pdev;
 8027eac:	4a20      	ldr	r2, [pc, #128]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027eae:	687b      	ldr	r3, [r7, #4]
 8027eb0:	f8c2 34e0 	str.w	r3, [r2, #1248]	@ 0x4e0
  pdev->pData = &hpcd_USB_OTG_FS;
 8027eb4:	687b      	ldr	r3, [r7, #4]
 8027eb6:	4a1e      	ldr	r2, [pc, #120]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027eb8:	f8c3 22c8 	str.w	r2, [r3, #712]	@ 0x2c8

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8027ebc:	4b1c      	ldr	r3, [pc, #112]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027ebe:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 8027ec2:	601a      	str	r2, [r3, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 8027ec4:	4b1a      	ldr	r3, [pc, #104]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027ec6:	2204      	movs	r2, #4
 8027ec8:	711a      	strb	r2, [r3, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8027eca:	4b19      	ldr	r3, [pc, #100]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027ecc:	2202      	movs	r2, #2
 8027ece:	71da      	strb	r2, [r3, #7]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8027ed0:	4b17      	ldr	r3, [pc, #92]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027ed2:	2200      	movs	r2, #0
 8027ed4:	719a      	strb	r2, [r3, #6]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8027ed6:	4b16      	ldr	r3, [pc, #88]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027ed8:	2202      	movs	r2, #2
 8027eda:	725a      	strb	r2, [r3, #9]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 8027edc:	4b14      	ldr	r3, [pc, #80]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027ede:	2200      	movs	r2, #0
 8027ee0:	729a      	strb	r2, [r3, #10]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8027ee2:	4b13      	ldr	r3, [pc, #76]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027ee4:	2200      	movs	r2, #0
 8027ee6:	72da      	strb	r2, [r3, #11]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8027ee8:	4b11      	ldr	r3, [pc, #68]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027eea:	2200      	movs	r2, #0
 8027eec:	731a      	strb	r2, [r3, #12]
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 8027eee:	4b10      	ldr	r3, [pc, #64]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027ef0:	2201      	movs	r2, #1
 8027ef2:	739a      	strb	r2, [r3, #14]
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8027ef4:	4b0e      	ldr	r3, [pc, #56]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027ef6:	2200      	movs	r2, #0
 8027ef8:	73da      	strb	r2, [r3, #15]
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8027efa:	480d      	ldr	r0, [pc, #52]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027efc:	f7db f868 	bl	8002fd0 <HAL_PCD_Init>
 8027f00:	4603      	mov	r3, r0
 8027f02:	2b00      	cmp	r3, #0
 8027f04:	d001      	beq.n	8027f0a <USBD_LL_Init+0x6e>
  {
    Error_Handler( );
 8027f06:	f7d9 fc81 	bl	800180c <Error_Handler>
  HAL_PCD_RegisterDataOutStageCallback(&hpcd_USB_OTG_FS, PCD_DataOutStageCallback);
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_OTG_FS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8027f0a:	2180      	movs	r1, #128	@ 0x80
 8027f0c:	4808      	ldr	r0, [pc, #32]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027f0e:	f7dc fa94 	bl	800443a <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8027f12:	2240      	movs	r2, #64	@ 0x40
 8027f14:	2100      	movs	r1, #0
 8027f16:	4806      	ldr	r0, [pc, #24]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027f18:	f7dc fa48 	bl	80043ac <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8027f1c:	2280      	movs	r2, #128	@ 0x80
 8027f1e:	2101      	movs	r1, #1
 8027f20:	4803      	ldr	r0, [pc, #12]	@ (8027f30 <USBD_LL_Init+0x94>)
 8027f22:	f7dc fa43 	bl	80043ac <HAL_PCDEx_SetTxFiFo>
  }
  return USBD_OK;
 8027f26:	2300      	movs	r3, #0
}
 8027f28:	4618      	mov	r0, r3
 8027f2a:	3708      	adds	r7, #8
 8027f2c:	46bd      	mov	sp, r7
 8027f2e:	bd80      	pop	{r7, pc}
 8027f30:	20003c00 	.word	0x20003c00

08027f34 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8027f34:	b580      	push	{r7, lr}
 8027f36:	b084      	sub	sp, #16
 8027f38:	af00      	add	r7, sp, #0
 8027f3a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027f3c:	2300      	movs	r3, #0
 8027f3e:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8027f40:	2300      	movs	r3, #0
 8027f42:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_Start(pdev->pData);
 8027f44:	687b      	ldr	r3, [r7, #4]
 8027f46:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8027f4a:	4618      	mov	r0, r3
 8027f4c:	f7db f94f 	bl	80031ee <HAL_PCD_Start>
 8027f50:	4603      	mov	r3, r0
 8027f52:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8027f54:	7bfb      	ldrb	r3, [r7, #15]
 8027f56:	4618      	mov	r0, r3
 8027f58:	f000 f942 	bl	80281e0 <USBD_Get_USB_Status>
 8027f5c:	4603      	mov	r3, r0
 8027f5e:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8027f60:	7bbb      	ldrb	r3, [r7, #14]
}
 8027f62:	4618      	mov	r0, r3
 8027f64:	3710      	adds	r7, #16
 8027f66:	46bd      	mov	sp, r7
 8027f68:	bd80      	pop	{r7, pc}

08027f6a <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8027f6a:	b580      	push	{r7, lr}
 8027f6c:	b084      	sub	sp, #16
 8027f6e:	af00      	add	r7, sp, #0
 8027f70:	6078      	str	r0, [r7, #4]
 8027f72:	4608      	mov	r0, r1
 8027f74:	4611      	mov	r1, r2
 8027f76:	461a      	mov	r2, r3
 8027f78:	4603      	mov	r3, r0
 8027f7a:	70fb      	strb	r3, [r7, #3]
 8027f7c:	460b      	mov	r3, r1
 8027f7e:	70bb      	strb	r3, [r7, #2]
 8027f80:	4613      	mov	r3, r2
 8027f82:	803b      	strh	r3, [r7, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027f84:	2300      	movs	r3, #0
 8027f86:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8027f88:	2300      	movs	r3, #0
 8027f8a:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8027f8c:	687b      	ldr	r3, [r7, #4]
 8027f8e:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 8027f92:	78bb      	ldrb	r3, [r7, #2]
 8027f94:	883a      	ldrh	r2, [r7, #0]
 8027f96:	78f9      	ldrb	r1, [r7, #3]
 8027f98:	f7db fe23 	bl	8003be2 <HAL_PCD_EP_Open>
 8027f9c:	4603      	mov	r3, r0
 8027f9e:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8027fa0:	7bfb      	ldrb	r3, [r7, #15]
 8027fa2:	4618      	mov	r0, r3
 8027fa4:	f000 f91c 	bl	80281e0 <USBD_Get_USB_Status>
 8027fa8:	4603      	mov	r3, r0
 8027faa:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8027fac:	7bbb      	ldrb	r3, [r7, #14]
}
 8027fae:	4618      	mov	r0, r3
 8027fb0:	3710      	adds	r7, #16
 8027fb2:	46bd      	mov	sp, r7
 8027fb4:	bd80      	pop	{r7, pc}

08027fb6 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8027fb6:	b580      	push	{r7, lr}
 8027fb8:	b084      	sub	sp, #16
 8027fba:	af00      	add	r7, sp, #0
 8027fbc:	6078      	str	r0, [r7, #4]
 8027fbe:	460b      	mov	r3, r1
 8027fc0:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027fc2:	2300      	movs	r3, #0
 8027fc4:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8027fc6:	2300      	movs	r3, #0
 8027fc8:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8027fca:	687b      	ldr	r3, [r7, #4]
 8027fcc:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8027fd0:	78fa      	ldrb	r2, [r7, #3]
 8027fd2:	4611      	mov	r1, r2
 8027fd4:	4618      	mov	r0, r3
 8027fd6:	f7db fe6e 	bl	8003cb6 <HAL_PCD_EP_Close>
 8027fda:	4603      	mov	r3, r0
 8027fdc:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8027fde:	7bfb      	ldrb	r3, [r7, #15]
 8027fe0:	4618      	mov	r0, r3
 8027fe2:	f000 f8fd 	bl	80281e0 <USBD_Get_USB_Status>
 8027fe6:	4603      	mov	r3, r0
 8027fe8:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8027fea:	7bbb      	ldrb	r3, [r7, #14]
}
 8027fec:	4618      	mov	r0, r3
 8027fee:	3710      	adds	r7, #16
 8027ff0:	46bd      	mov	sp, r7
 8027ff2:	bd80      	pop	{r7, pc}

08027ff4 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8027ff4:	b580      	push	{r7, lr}
 8027ff6:	b084      	sub	sp, #16
 8027ff8:	af00      	add	r7, sp, #0
 8027ffa:	6078      	str	r0, [r7, #4]
 8027ffc:	460b      	mov	r3, r1
 8027ffe:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028000:	2300      	movs	r3, #0
 8028002:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028004:	2300      	movs	r3, #0
 8028006:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8028008:	687b      	ldr	r3, [r7, #4]
 802800a:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 802800e:	78fa      	ldrb	r2, [r7, #3]
 8028010:	4611      	mov	r1, r2
 8028012:	4618      	mov	r0, r3
 8028014:	f7db ff26 	bl	8003e64 <HAL_PCD_EP_SetStall>
 8028018:	4603      	mov	r3, r0
 802801a:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 802801c:	7bfb      	ldrb	r3, [r7, #15]
 802801e:	4618      	mov	r0, r3
 8028020:	f000 f8de 	bl	80281e0 <USBD_Get_USB_Status>
 8028024:	4603      	mov	r3, r0
 8028026:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028028:	7bbb      	ldrb	r3, [r7, #14]
}
 802802a:	4618      	mov	r0, r3
 802802c:	3710      	adds	r7, #16
 802802e:	46bd      	mov	sp, r7
 8028030:	bd80      	pop	{r7, pc}

08028032 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8028032:	b580      	push	{r7, lr}
 8028034:	b084      	sub	sp, #16
 8028036:	af00      	add	r7, sp, #0
 8028038:	6078      	str	r0, [r7, #4]
 802803a:	460b      	mov	r3, r1
 802803c:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 802803e:	2300      	movs	r3, #0
 8028040:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028042:	2300      	movs	r3, #0
 8028044:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8028046:	687b      	ldr	r3, [r7, #4]
 8028048:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 802804c:	78fa      	ldrb	r2, [r7, #3]
 802804e:	4611      	mov	r1, r2
 8028050:	4618      	mov	r0, r3
 8028052:	f7db ff6a 	bl	8003f2a <HAL_PCD_EP_ClrStall>
 8028056:	4603      	mov	r3, r0
 8028058:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 802805a:	7bfb      	ldrb	r3, [r7, #15]
 802805c:	4618      	mov	r0, r3
 802805e:	f000 f8bf 	bl	80281e0 <USBD_Get_USB_Status>
 8028062:	4603      	mov	r3, r0
 8028064:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028066:	7bbb      	ldrb	r3, [r7, #14]
}
 8028068:	4618      	mov	r0, r3
 802806a:	3710      	adds	r7, #16
 802806c:	46bd      	mov	sp, r7
 802806e:	bd80      	pop	{r7, pc}

08028070 <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8028070:	b480      	push	{r7}
 8028072:	b085      	sub	sp, #20
 8028074:	af00      	add	r7, sp, #0
 8028076:	6078      	str	r0, [r7, #4]
 8028078:	460b      	mov	r3, r1
 802807a:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 802807c:	687b      	ldr	r3, [r7, #4]
 802807e:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8028082:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
 8028084:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8028088:	2b00      	cmp	r3, #0
 802808a:	da0b      	bge.n	80280a4 <USBD_LL_IsStallEP+0x34>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 802808c:	78fb      	ldrb	r3, [r7, #3]
 802808e:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8028092:	68f9      	ldr	r1, [r7, #12]
 8028094:	4613      	mov	r3, r2
 8028096:	00db      	lsls	r3, r3, #3
 8028098:	4413      	add	r3, r2
 802809a:	009b      	lsls	r3, r3, #2
 802809c:	440b      	add	r3, r1
 802809e:	3316      	adds	r3, #22
 80280a0:	781b      	ldrb	r3, [r3, #0]
 80280a2:	e00b      	b.n	80280bc <USBD_LL_IsStallEP+0x4c>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 80280a4:	78fb      	ldrb	r3, [r7, #3]
 80280a6:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 80280aa:	68f9      	ldr	r1, [r7, #12]
 80280ac:	4613      	mov	r3, r2
 80280ae:	00db      	lsls	r3, r3, #3
 80280b0:	4413      	add	r3, r2
 80280b2:	009b      	lsls	r3, r3, #2
 80280b4:	440b      	add	r3, r1
 80280b6:	f203 2356 	addw	r3, r3, #598	@ 0x256
 80280ba:	781b      	ldrb	r3, [r3, #0]
  }
}
 80280bc:	4618      	mov	r0, r3
 80280be:	3714      	adds	r7, #20
 80280c0:	46bd      	mov	sp, r7
 80280c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80280c6:	4770      	bx	lr

080280c8 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 80280c8:	b580      	push	{r7, lr}
 80280ca:	b084      	sub	sp, #16
 80280cc:	af00      	add	r7, sp, #0
 80280ce:	6078      	str	r0, [r7, #4]
 80280d0:	460b      	mov	r3, r1
 80280d2:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 80280d4:	2300      	movs	r3, #0
 80280d6:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 80280d8:	2300      	movs	r3, #0
 80280da:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 80280dc:	687b      	ldr	r3, [r7, #4]
 80280de:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 80280e2:	78fa      	ldrb	r2, [r7, #3]
 80280e4:	4611      	mov	r1, r2
 80280e6:	4618      	mov	r0, r3
 80280e8:	f7db fd57 	bl	8003b9a <HAL_PCD_SetAddress>
 80280ec:	4603      	mov	r3, r0
 80280ee:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 80280f0:	7bfb      	ldrb	r3, [r7, #15]
 80280f2:	4618      	mov	r0, r3
 80280f4:	f000 f874 	bl	80281e0 <USBD_Get_USB_Status>
 80280f8:	4603      	mov	r3, r0
 80280fa:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 80280fc:	7bbb      	ldrb	r3, [r7, #14]
}
 80280fe:	4618      	mov	r0, r3
 8028100:	3710      	adds	r7, #16
 8028102:	46bd      	mov	sp, r7
 8028104:	bd80      	pop	{r7, pc}

08028106 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8028106:	b580      	push	{r7, lr}
 8028108:	b086      	sub	sp, #24
 802810a:	af00      	add	r7, sp, #0
 802810c:	60f8      	str	r0, [r7, #12]
 802810e:	607a      	str	r2, [r7, #4]
 8028110:	603b      	str	r3, [r7, #0]
 8028112:	460b      	mov	r3, r1
 8028114:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028116:	2300      	movs	r3, #0
 8028118:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 802811a:	2300      	movs	r3, #0
 802811c:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 802811e:	68fb      	ldr	r3, [r7, #12]
 8028120:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 8028124:	7af9      	ldrb	r1, [r7, #11]
 8028126:	683b      	ldr	r3, [r7, #0]
 8028128:	687a      	ldr	r2, [r7, #4]
 802812a:	f7db fe61 	bl	8003df0 <HAL_PCD_EP_Transmit>
 802812e:	4603      	mov	r3, r0
 8028130:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028132:	7dfb      	ldrb	r3, [r7, #23]
 8028134:	4618      	mov	r0, r3
 8028136:	f000 f853 	bl	80281e0 <USBD_Get_USB_Status>
 802813a:	4603      	mov	r3, r0
 802813c:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 802813e:	7dbb      	ldrb	r3, [r7, #22]
}
 8028140:	4618      	mov	r0, r3
 8028142:	3718      	adds	r7, #24
 8028144:	46bd      	mov	sp, r7
 8028146:	bd80      	pop	{r7, pc}

08028148 <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8028148:	b580      	push	{r7, lr}
 802814a:	b086      	sub	sp, #24
 802814c:	af00      	add	r7, sp, #0
 802814e:	60f8      	str	r0, [r7, #12]
 8028150:	607a      	str	r2, [r7, #4]
 8028152:	603b      	str	r3, [r7, #0]
 8028154:	460b      	mov	r3, r1
 8028156:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028158:	2300      	movs	r3, #0
 802815a:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 802815c:	2300      	movs	r3, #0
 802815e:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8028160:	68fb      	ldr	r3, [r7, #12]
 8028162:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 8028166:	7af9      	ldrb	r1, [r7, #11]
 8028168:	683b      	ldr	r3, [r7, #0]
 802816a:	687a      	ldr	r2, [r7, #4]
 802816c:	f7db fded 	bl	8003d4a <HAL_PCD_EP_Receive>
 8028170:	4603      	mov	r3, r0
 8028172:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028174:	7dfb      	ldrb	r3, [r7, #23]
 8028176:	4618      	mov	r0, r3
 8028178:	f000 f832 	bl	80281e0 <USBD_Get_USB_Status>
 802817c:	4603      	mov	r3, r0
 802817e:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 8028180:	7dbb      	ldrb	r3, [r7, #22]
}
 8028182:	4618      	mov	r0, r3
 8028184:	3718      	adds	r7, #24
 8028186:	46bd      	mov	sp, r7
 8028188:	bd80      	pop	{r7, pc}

0802818a <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Received Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 802818a:	b580      	push	{r7, lr}
 802818c:	b082      	sub	sp, #8
 802818e:	af00      	add	r7, sp, #0
 8028190:	6078      	str	r0, [r7, #4]
 8028192:	460b      	mov	r3, r1
 8028194:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8028196:	687b      	ldr	r3, [r7, #4]
 8028198:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 802819c:	78fa      	ldrb	r2, [r7, #3]
 802819e:	4611      	mov	r1, r2
 80281a0:	4618      	mov	r0, r3
 80281a2:	f7db fe0d 	bl	8003dc0 <HAL_PCD_EP_GetRxCount>
 80281a6:	4603      	mov	r3, r0
}
 80281a8:	4618      	mov	r0, r3
 80281aa:	3708      	adds	r7, #8
 80281ac:	46bd      	mov	sp, r7
 80281ae:	bd80      	pop	{r7, pc}

080281b0 <USBD_static_malloc>:
  * @brief  Static single allocation.
  * @param  size: Size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
 80281b0:	b480      	push	{r7}
 80281b2:	b083      	sub	sp, #12
 80281b4:	af00      	add	r7, sp, #0
 80281b6:	6078      	str	r0, [r7, #4]
  static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
 80281b8:	4b03      	ldr	r3, [pc, #12]	@ (80281c8 <USBD_static_malloc+0x18>)
}
 80281ba:	4618      	mov	r0, r3
 80281bc:	370c      	adds	r7, #12
 80281be:	46bd      	mov	sp, r7
 80281c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80281c4:	4770      	bx	lr
 80281c6:	bf00      	nop
 80281c8:	200040e4 	.word	0x200040e4

080281cc <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 80281cc:	b480      	push	{r7}
 80281ce:	b083      	sub	sp, #12
 80281d0:	af00      	add	r7, sp, #0
 80281d2:	6078      	str	r0, [r7, #4]

}
 80281d4:	bf00      	nop
 80281d6:	370c      	adds	r7, #12
 80281d8:	46bd      	mov	sp, r7
 80281da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80281de:	4770      	bx	lr

080281e0 <USBD_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 80281e0:	b480      	push	{r7}
 80281e2:	b085      	sub	sp, #20
 80281e4:	af00      	add	r7, sp, #0
 80281e6:	4603      	mov	r3, r0
 80281e8:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef usb_status = USBD_OK;
 80281ea:	2300      	movs	r3, #0
 80281ec:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 80281ee:	79fb      	ldrb	r3, [r7, #7]
 80281f0:	2b03      	cmp	r3, #3
 80281f2:	d817      	bhi.n	8028224 <USBD_Get_USB_Status+0x44>
 80281f4:	a201      	add	r2, pc, #4	@ (adr r2, 80281fc <USBD_Get_USB_Status+0x1c>)
 80281f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80281fa:	bf00      	nop
 80281fc:	0802820d 	.word	0x0802820d
 8028200:	08028213 	.word	0x08028213
 8028204:	08028219 	.word	0x08028219
 8028208:	0802821f 	.word	0x0802821f
  {
    case HAL_OK :
      usb_status = USBD_OK;
 802820c:	2300      	movs	r3, #0
 802820e:	73fb      	strb	r3, [r7, #15]
    break;
 8028210:	e00b      	b.n	802822a <USBD_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8028212:	2303      	movs	r3, #3
 8028214:	73fb      	strb	r3, [r7, #15]
    break;
 8028216:	e008      	b.n	802822a <USBD_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 8028218:	2301      	movs	r3, #1
 802821a:	73fb      	strb	r3, [r7, #15]
    break;
 802821c:	e005      	b.n	802822a <USBD_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
 802821e:	2303      	movs	r3, #3
 8028220:	73fb      	strb	r3, [r7, #15]
    break;
 8028222:	e002      	b.n	802822a <USBD_Get_USB_Status+0x4a>
    default :
      usb_status = USBD_FAIL;
 8028224:	2303      	movs	r3, #3
 8028226:	73fb      	strb	r3, [r7, #15]
    break;
 8028228:	bf00      	nop
  }
  return usb_status;
 802822a:	7bfb      	ldrb	r3, [r7, #15]
}
 802822c:	4618      	mov	r0, r3
 802822e:	3714      	adds	r7, #20
 8028230:	46bd      	mov	sp, r7
 8028232:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028236:	4770      	bx	lr

08028238 <malloc>:
 8028238:	4b02      	ldr	r3, [pc, #8]	@ (8028244 <malloc+0xc>)
 802823a:	4601      	mov	r1, r0
 802823c:	6818      	ldr	r0, [r3, #0]
 802823e:	f000 b82d 	b.w	802829c <_malloc_r>
 8028242:	bf00      	nop
 8028244:	20000134 	.word	0x20000134

08028248 <free>:
 8028248:	4b02      	ldr	r3, [pc, #8]	@ (8028254 <free+0xc>)
 802824a:	4601      	mov	r1, r0
 802824c:	6818      	ldr	r0, [r3, #0]
 802824e:	f000 b9b7 	b.w	80285c0 <_free_r>
 8028252:	bf00      	nop
 8028254:	20000134 	.word	0x20000134

08028258 <sbrk_aligned>:
 8028258:	b570      	push	{r4, r5, r6, lr}
 802825a:	4e0f      	ldr	r6, [pc, #60]	@ (8028298 <sbrk_aligned+0x40>)
 802825c:	460c      	mov	r4, r1
 802825e:	6831      	ldr	r1, [r6, #0]
 8028260:	4605      	mov	r5, r0
 8028262:	b911      	cbnz	r1, 802826a <sbrk_aligned+0x12>
 8028264:	f000 f962 	bl	802852c <_sbrk_r>
 8028268:	6030      	str	r0, [r6, #0]
 802826a:	4621      	mov	r1, r4
 802826c:	4628      	mov	r0, r5
 802826e:	f000 f95d 	bl	802852c <_sbrk_r>
 8028272:	1c43      	adds	r3, r0, #1
 8028274:	d103      	bne.n	802827e <sbrk_aligned+0x26>
 8028276:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
 802827a:	4620      	mov	r0, r4
 802827c:	bd70      	pop	{r4, r5, r6, pc}
 802827e:	1cc4      	adds	r4, r0, #3
 8028280:	f024 0403 	bic.w	r4, r4, #3
 8028284:	42a0      	cmp	r0, r4
 8028286:	d0f8      	beq.n	802827a <sbrk_aligned+0x22>
 8028288:	1a21      	subs	r1, r4, r0
 802828a:	4628      	mov	r0, r5
 802828c:	f000 f94e 	bl	802852c <_sbrk_r>
 8028290:	3001      	adds	r0, #1
 8028292:	d1f2      	bne.n	802827a <sbrk_aligned+0x22>
 8028294:	e7ef      	b.n	8028276 <sbrk_aligned+0x1e>
 8028296:	bf00      	nop
 8028298:	20004304 	.word	0x20004304

0802829c <_malloc_r>:
 802829c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80282a0:	1ccd      	adds	r5, r1, #3
 80282a2:	f025 0503 	bic.w	r5, r5, #3
 80282a6:	3508      	adds	r5, #8
 80282a8:	2d0c      	cmp	r5, #12
 80282aa:	bf38      	it	cc
 80282ac:	250c      	movcc	r5, #12
 80282ae:	2d00      	cmp	r5, #0
 80282b0:	4606      	mov	r6, r0
 80282b2:	db01      	blt.n	80282b8 <_malloc_r+0x1c>
 80282b4:	42a9      	cmp	r1, r5
 80282b6:	d904      	bls.n	80282c2 <_malloc_r+0x26>
 80282b8:	230c      	movs	r3, #12
 80282ba:	6033      	str	r3, [r6, #0]
 80282bc:	2000      	movs	r0, #0
 80282be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80282c2:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 8028398 <_malloc_r+0xfc>
 80282c6:	f000 f869 	bl	802839c <__malloc_lock>
 80282ca:	f8d8 3000 	ldr.w	r3, [r8]
 80282ce:	461c      	mov	r4, r3
 80282d0:	bb44      	cbnz	r4, 8028324 <_malloc_r+0x88>
 80282d2:	4629      	mov	r1, r5
 80282d4:	4630      	mov	r0, r6
 80282d6:	f7ff ffbf 	bl	8028258 <sbrk_aligned>
 80282da:	1c43      	adds	r3, r0, #1
 80282dc:	4604      	mov	r4, r0
 80282de:	d158      	bne.n	8028392 <_malloc_r+0xf6>
 80282e0:	f8d8 4000 	ldr.w	r4, [r8]
 80282e4:	4627      	mov	r7, r4
 80282e6:	2f00      	cmp	r7, #0
 80282e8:	d143      	bne.n	8028372 <_malloc_r+0xd6>
 80282ea:	2c00      	cmp	r4, #0
 80282ec:	d04b      	beq.n	8028386 <_malloc_r+0xea>
 80282ee:	6823      	ldr	r3, [r4, #0]
 80282f0:	4639      	mov	r1, r7
 80282f2:	4630      	mov	r0, r6
 80282f4:	eb04 0903 	add.w	r9, r4, r3
 80282f8:	f000 f918 	bl	802852c <_sbrk_r>
 80282fc:	4581      	cmp	r9, r0
 80282fe:	d142      	bne.n	8028386 <_malloc_r+0xea>
 8028300:	6821      	ldr	r1, [r4, #0]
 8028302:	1a6d      	subs	r5, r5, r1
 8028304:	4629      	mov	r1, r5
 8028306:	4630      	mov	r0, r6
 8028308:	f7ff ffa6 	bl	8028258 <sbrk_aligned>
 802830c:	3001      	adds	r0, #1
 802830e:	d03a      	beq.n	8028386 <_malloc_r+0xea>
 8028310:	6823      	ldr	r3, [r4, #0]
 8028312:	442b      	add	r3, r5
 8028314:	6023      	str	r3, [r4, #0]
 8028316:	f8d8 3000 	ldr.w	r3, [r8]
 802831a:	685a      	ldr	r2, [r3, #4]
 802831c:	bb62      	cbnz	r2, 8028378 <_malloc_r+0xdc>
 802831e:	f8c8 7000 	str.w	r7, [r8]
 8028322:	e00f      	b.n	8028344 <_malloc_r+0xa8>
 8028324:	6822      	ldr	r2, [r4, #0]
 8028326:	1b52      	subs	r2, r2, r5
 8028328:	d420      	bmi.n	802836c <_malloc_r+0xd0>
 802832a:	2a0b      	cmp	r2, #11
 802832c:	d917      	bls.n	802835e <_malloc_r+0xc2>
 802832e:	1961      	adds	r1, r4, r5
 8028330:	42a3      	cmp	r3, r4
 8028332:	6025      	str	r5, [r4, #0]
 8028334:	bf18      	it	ne
 8028336:	6059      	strne	r1, [r3, #4]
 8028338:	6863      	ldr	r3, [r4, #4]
 802833a:	bf08      	it	eq
 802833c:	f8c8 1000 	streq.w	r1, [r8]
 8028340:	5162      	str	r2, [r4, r5]
 8028342:	604b      	str	r3, [r1, #4]
 8028344:	4630      	mov	r0, r6
 8028346:	f000 f82f 	bl	80283a8 <__malloc_unlock>
 802834a:	f104 000b 	add.w	r0, r4, #11
 802834e:	1d23      	adds	r3, r4, #4
 8028350:	f020 0007 	bic.w	r0, r0, #7
 8028354:	1ac2      	subs	r2, r0, r3
 8028356:	bf1c      	itt	ne
 8028358:	1a1b      	subne	r3, r3, r0
 802835a:	50a3      	strne	r3, [r4, r2]
 802835c:	e7af      	b.n	80282be <_malloc_r+0x22>
 802835e:	6862      	ldr	r2, [r4, #4]
 8028360:	42a3      	cmp	r3, r4
 8028362:	bf0c      	ite	eq
 8028364:	f8c8 2000 	streq.w	r2, [r8]
 8028368:	605a      	strne	r2, [r3, #4]
 802836a:	e7eb      	b.n	8028344 <_malloc_r+0xa8>
 802836c:	4623      	mov	r3, r4
 802836e:	6864      	ldr	r4, [r4, #4]
 8028370:	e7ae      	b.n	80282d0 <_malloc_r+0x34>
 8028372:	463c      	mov	r4, r7
 8028374:	687f      	ldr	r7, [r7, #4]
 8028376:	e7b6      	b.n	80282e6 <_malloc_r+0x4a>
 8028378:	461a      	mov	r2, r3
 802837a:	685b      	ldr	r3, [r3, #4]
 802837c:	42a3      	cmp	r3, r4
 802837e:	d1fb      	bne.n	8028378 <_malloc_r+0xdc>
 8028380:	2300      	movs	r3, #0
 8028382:	6053      	str	r3, [r2, #4]
 8028384:	e7de      	b.n	8028344 <_malloc_r+0xa8>
 8028386:	230c      	movs	r3, #12
 8028388:	6033      	str	r3, [r6, #0]
 802838a:	4630      	mov	r0, r6
 802838c:	f000 f80c 	bl	80283a8 <__malloc_unlock>
 8028390:	e794      	b.n	80282bc <_malloc_r+0x20>
 8028392:	6005      	str	r5, [r0, #0]
 8028394:	e7d6      	b.n	8028344 <_malloc_r+0xa8>
 8028396:	bf00      	nop
 8028398:	20004308 	.word	0x20004308

0802839c <__malloc_lock>:
 802839c:	4801      	ldr	r0, [pc, #4]	@ (80283a4 <__malloc_lock+0x8>)
 802839e:	f000 b8ff 	b.w	80285a0 <__retarget_lock_acquire_recursive>
 80283a2:	bf00      	nop
 80283a4:	20004448 	.word	0x20004448

080283a8 <__malloc_unlock>:
 80283a8:	4801      	ldr	r0, [pc, #4]	@ (80283b0 <__malloc_unlock+0x8>)
 80283aa:	f000 b8fa 	b.w	80285a2 <__retarget_lock_release_recursive>
 80283ae:	bf00      	nop
 80283b0:	20004448 	.word	0x20004448

080283b4 <_realloc_r>:
 80283b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80283b8:	4607      	mov	r7, r0
 80283ba:	4614      	mov	r4, r2
 80283bc:	460d      	mov	r5, r1
 80283be:	b921      	cbnz	r1, 80283ca <_realloc_r+0x16>
 80283c0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80283c4:	4611      	mov	r1, r2
 80283c6:	f7ff bf69 	b.w	802829c <_malloc_r>
 80283ca:	b92a      	cbnz	r2, 80283d8 <_realloc_r+0x24>
 80283cc:	f000 f8f8 	bl	80285c0 <_free_r>
 80283d0:	4625      	mov	r5, r4
 80283d2:	4628      	mov	r0, r5
 80283d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80283d8:	f000 f93c 	bl	8028654 <_malloc_usable_size_r>
 80283dc:	4284      	cmp	r4, r0
 80283de:	4606      	mov	r6, r0
 80283e0:	d802      	bhi.n	80283e8 <_realloc_r+0x34>
 80283e2:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 80283e6:	d8f4      	bhi.n	80283d2 <_realloc_r+0x1e>
 80283e8:	4621      	mov	r1, r4
 80283ea:	4638      	mov	r0, r7
 80283ec:	f7ff ff56 	bl	802829c <_malloc_r>
 80283f0:	4680      	mov	r8, r0
 80283f2:	b908      	cbnz	r0, 80283f8 <_realloc_r+0x44>
 80283f4:	4645      	mov	r5, r8
 80283f6:	e7ec      	b.n	80283d2 <_realloc_r+0x1e>
 80283f8:	42b4      	cmp	r4, r6
 80283fa:	4622      	mov	r2, r4
 80283fc:	4629      	mov	r1, r5
 80283fe:	bf28      	it	cs
 8028400:	4632      	movcs	r2, r6
 8028402:	f000 f8cf 	bl	80285a4 <memcpy>
 8028406:	4629      	mov	r1, r5
 8028408:	4638      	mov	r0, r7
 802840a:	f000 f8d9 	bl	80285c0 <_free_r>
 802840e:	e7f1      	b.n	80283f4 <_realloc_r+0x40>

08028410 <sniprintf>:
 8028410:	b40c      	push	{r2, r3}
 8028412:	b530      	push	{r4, r5, lr}
 8028414:	4b18      	ldr	r3, [pc, #96]	@ (8028478 <sniprintf+0x68>)
 8028416:	1e0c      	subs	r4, r1, #0
 8028418:	681d      	ldr	r5, [r3, #0]
 802841a:	b09d      	sub	sp, #116	@ 0x74
 802841c:	da08      	bge.n	8028430 <sniprintf+0x20>
 802841e:	238b      	movs	r3, #139	@ 0x8b
 8028420:	602b      	str	r3, [r5, #0]
 8028422:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8028426:	b01d      	add	sp, #116	@ 0x74
 8028428:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 802842c:	b002      	add	sp, #8
 802842e:	4770      	bx	lr
 8028430:	f44f 7302 	mov.w	r3, #520	@ 0x208
 8028434:	f8ad 3014 	strh.w	r3, [sp, #20]
 8028438:	f04f 0300 	mov.w	r3, #0
 802843c:	931b      	str	r3, [sp, #108]	@ 0x6c
 802843e:	bf14      	ite	ne
 8028440:	f104 33ff 	addne.w	r3, r4, #4294967295	@ 0xffffffff
 8028444:	4623      	moveq	r3, r4
 8028446:	9304      	str	r3, [sp, #16]
 8028448:	9307      	str	r3, [sp, #28]
 802844a:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 802844e:	9002      	str	r0, [sp, #8]
 8028450:	9006      	str	r0, [sp, #24]
 8028452:	f8ad 3016 	strh.w	r3, [sp, #22]
 8028456:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 8028458:	ab21      	add	r3, sp, #132	@ 0x84
 802845a:	a902      	add	r1, sp, #8
 802845c:	4628      	mov	r0, r5
 802845e:	9301      	str	r3, [sp, #4]
 8028460:	f000 f95c 	bl	802871c <_svfiprintf_r>
 8028464:	1c43      	adds	r3, r0, #1
 8028466:	bfbc      	itt	lt
 8028468:	238b      	movlt	r3, #139	@ 0x8b
 802846a:	602b      	strlt	r3, [r5, #0]
 802846c:	2c00      	cmp	r4, #0
 802846e:	d0da      	beq.n	8028426 <sniprintf+0x16>
 8028470:	9b02      	ldr	r3, [sp, #8]
 8028472:	2200      	movs	r2, #0
 8028474:	701a      	strb	r2, [r3, #0]
 8028476:	e7d6      	b.n	8028426 <sniprintf+0x16>
 8028478:	20000134 	.word	0x20000134

0802847c <memcmp>:
 802847c:	b510      	push	{r4, lr}
 802847e:	3901      	subs	r1, #1
 8028480:	4402      	add	r2, r0
 8028482:	4290      	cmp	r0, r2
 8028484:	d101      	bne.n	802848a <memcmp+0xe>
 8028486:	2000      	movs	r0, #0
 8028488:	e005      	b.n	8028496 <memcmp+0x1a>
 802848a:	7803      	ldrb	r3, [r0, #0]
 802848c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8028490:	42a3      	cmp	r3, r4
 8028492:	d001      	beq.n	8028498 <memcmp+0x1c>
 8028494:	1b18      	subs	r0, r3, r4
 8028496:	bd10      	pop	{r4, pc}
 8028498:	3001      	adds	r0, #1
 802849a:	e7f2      	b.n	8028482 <memcmp+0x6>

0802849c <memmove>:
 802849c:	4288      	cmp	r0, r1
 802849e:	b510      	push	{r4, lr}
 80284a0:	eb01 0402 	add.w	r4, r1, r2
 80284a4:	d902      	bls.n	80284ac <memmove+0x10>
 80284a6:	4284      	cmp	r4, r0
 80284a8:	4623      	mov	r3, r4
 80284aa:	d807      	bhi.n	80284bc <memmove+0x20>
 80284ac:	1e43      	subs	r3, r0, #1
 80284ae:	42a1      	cmp	r1, r4
 80284b0:	d008      	beq.n	80284c4 <memmove+0x28>
 80284b2:	f811 2b01 	ldrb.w	r2, [r1], #1
 80284b6:	f803 2f01 	strb.w	r2, [r3, #1]!
 80284ba:	e7f8      	b.n	80284ae <memmove+0x12>
 80284bc:	4402      	add	r2, r0
 80284be:	4601      	mov	r1, r0
 80284c0:	428a      	cmp	r2, r1
 80284c2:	d100      	bne.n	80284c6 <memmove+0x2a>
 80284c4:	bd10      	pop	{r4, pc}
 80284c6:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80284ca:	f802 4d01 	strb.w	r4, [r2, #-1]!
 80284ce:	e7f7      	b.n	80284c0 <memmove+0x24>

080284d0 <memset>:
 80284d0:	4402      	add	r2, r0
 80284d2:	4603      	mov	r3, r0
 80284d4:	4293      	cmp	r3, r2
 80284d6:	d100      	bne.n	80284da <memset+0xa>
 80284d8:	4770      	bx	lr
 80284da:	f803 1b01 	strb.w	r1, [r3], #1
 80284de:	e7f9      	b.n	80284d4 <memset+0x4>

080284e0 <strncmp>:
 80284e0:	b510      	push	{r4, lr}
 80284e2:	b16a      	cbz	r2, 8028500 <strncmp+0x20>
 80284e4:	3901      	subs	r1, #1
 80284e6:	1884      	adds	r4, r0, r2
 80284e8:	f810 2b01 	ldrb.w	r2, [r0], #1
 80284ec:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80284f0:	429a      	cmp	r2, r3
 80284f2:	d103      	bne.n	80284fc <strncmp+0x1c>
 80284f4:	42a0      	cmp	r0, r4
 80284f6:	d001      	beq.n	80284fc <strncmp+0x1c>
 80284f8:	2a00      	cmp	r2, #0
 80284fa:	d1f5      	bne.n	80284e8 <strncmp+0x8>
 80284fc:	1ad0      	subs	r0, r2, r3
 80284fe:	bd10      	pop	{r4, pc}
 8028500:	4610      	mov	r0, r2
 8028502:	e7fc      	b.n	80284fe <strncmp+0x1e>

08028504 <strncpy>:
 8028504:	b510      	push	{r4, lr}
 8028506:	3901      	subs	r1, #1
 8028508:	4603      	mov	r3, r0
 802850a:	b132      	cbz	r2, 802851a <strncpy+0x16>
 802850c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8028510:	f803 4b01 	strb.w	r4, [r3], #1
 8028514:	3a01      	subs	r2, #1
 8028516:	2c00      	cmp	r4, #0
 8028518:	d1f7      	bne.n	802850a <strncpy+0x6>
 802851a:	441a      	add	r2, r3
 802851c:	2100      	movs	r1, #0
 802851e:	4293      	cmp	r3, r2
 8028520:	d100      	bne.n	8028524 <strncpy+0x20>
 8028522:	bd10      	pop	{r4, pc}
 8028524:	f803 1b01 	strb.w	r1, [r3], #1
 8028528:	e7f9      	b.n	802851e <strncpy+0x1a>
	...

0802852c <_sbrk_r>:
 802852c:	b538      	push	{r3, r4, r5, lr}
 802852e:	4d06      	ldr	r5, [pc, #24]	@ (8028548 <_sbrk_r+0x1c>)
 8028530:	2300      	movs	r3, #0
 8028532:	4604      	mov	r4, r0
 8028534:	4608      	mov	r0, r1
 8028536:	602b      	str	r3, [r5, #0]
 8028538:	f7d9 fb3e 	bl	8001bb8 <_sbrk>
 802853c:	1c43      	adds	r3, r0, #1
 802853e:	d102      	bne.n	8028546 <_sbrk_r+0x1a>
 8028540:	682b      	ldr	r3, [r5, #0]
 8028542:	b103      	cbz	r3, 8028546 <_sbrk_r+0x1a>
 8028544:	6023      	str	r3, [r4, #0]
 8028546:	bd38      	pop	{r3, r4, r5, pc}
 8028548:	20004444 	.word	0x20004444

0802854c <__errno>:
 802854c:	4b01      	ldr	r3, [pc, #4]	@ (8028554 <__errno+0x8>)
 802854e:	6818      	ldr	r0, [r3, #0]
 8028550:	4770      	bx	lr
 8028552:	bf00      	nop
 8028554:	20000134 	.word	0x20000134

08028558 <__libc_init_array>:
 8028558:	b570      	push	{r4, r5, r6, lr}
 802855a:	4d0d      	ldr	r5, [pc, #52]	@ (8028590 <__libc_init_array+0x38>)
 802855c:	4c0d      	ldr	r4, [pc, #52]	@ (8028594 <__libc_init_array+0x3c>)
 802855e:	1b64      	subs	r4, r4, r5
 8028560:	10a4      	asrs	r4, r4, #2
 8028562:	2600      	movs	r6, #0
 8028564:	42a6      	cmp	r6, r4
 8028566:	d109      	bne.n	802857c <__libc_init_array+0x24>
 8028568:	4d0b      	ldr	r5, [pc, #44]	@ (8028598 <__libc_init_array+0x40>)
 802856a:	4c0c      	ldr	r4, [pc, #48]	@ (802859c <__libc_init_array+0x44>)
 802856c:	f000 fb5e 	bl	8028c2c <_init>
 8028570:	1b64      	subs	r4, r4, r5
 8028572:	10a4      	asrs	r4, r4, #2
 8028574:	2600      	movs	r6, #0
 8028576:	42a6      	cmp	r6, r4
 8028578:	d105      	bne.n	8028586 <__libc_init_array+0x2e>
 802857a:	bd70      	pop	{r4, r5, r6, pc}
 802857c:	f855 3b04 	ldr.w	r3, [r5], #4
 8028580:	4798      	blx	r3
 8028582:	3601      	adds	r6, #1
 8028584:	e7ee      	b.n	8028564 <__libc_init_array+0xc>
 8028586:	f855 3b04 	ldr.w	r3, [r5], #4
 802858a:	4798      	blx	r3
 802858c:	3601      	adds	r6, #1
 802858e:	e7f2      	b.n	8028576 <__libc_init_array+0x1e>
 8028590:	08033dd8 	.word	0x08033dd8
 8028594:	08033dd8 	.word	0x08033dd8
 8028598:	08033dd8 	.word	0x08033dd8
 802859c:	08033ddc 	.word	0x08033ddc

080285a0 <__retarget_lock_acquire_recursive>:
 80285a0:	4770      	bx	lr

080285a2 <__retarget_lock_release_recursive>:
 80285a2:	4770      	bx	lr

080285a4 <memcpy>:
 80285a4:	440a      	add	r2, r1
 80285a6:	4291      	cmp	r1, r2
 80285a8:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
 80285ac:	d100      	bne.n	80285b0 <memcpy+0xc>
 80285ae:	4770      	bx	lr
 80285b0:	b510      	push	{r4, lr}
 80285b2:	f811 4b01 	ldrb.w	r4, [r1], #1
 80285b6:	f803 4f01 	strb.w	r4, [r3, #1]!
 80285ba:	4291      	cmp	r1, r2
 80285bc:	d1f9      	bne.n	80285b2 <memcpy+0xe>
 80285be:	bd10      	pop	{r4, pc}

080285c0 <_free_r>:
 80285c0:	b538      	push	{r3, r4, r5, lr}
 80285c2:	4605      	mov	r5, r0
 80285c4:	2900      	cmp	r1, #0
 80285c6:	d041      	beq.n	802864c <_free_r+0x8c>
 80285c8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80285cc:	1f0c      	subs	r4, r1, #4
 80285ce:	2b00      	cmp	r3, #0
 80285d0:	bfb8      	it	lt
 80285d2:	18e4      	addlt	r4, r4, r3
 80285d4:	f7ff fee2 	bl	802839c <__malloc_lock>
 80285d8:	4a1d      	ldr	r2, [pc, #116]	@ (8028650 <_free_r+0x90>)
 80285da:	6813      	ldr	r3, [r2, #0]
 80285dc:	b933      	cbnz	r3, 80285ec <_free_r+0x2c>
 80285de:	6063      	str	r3, [r4, #4]
 80285e0:	6014      	str	r4, [r2, #0]
 80285e2:	4628      	mov	r0, r5
 80285e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80285e8:	f7ff bede 	b.w	80283a8 <__malloc_unlock>
 80285ec:	42a3      	cmp	r3, r4
 80285ee:	d908      	bls.n	8028602 <_free_r+0x42>
 80285f0:	6820      	ldr	r0, [r4, #0]
 80285f2:	1821      	adds	r1, r4, r0
 80285f4:	428b      	cmp	r3, r1
 80285f6:	bf01      	itttt	eq
 80285f8:	6819      	ldreq	r1, [r3, #0]
 80285fa:	685b      	ldreq	r3, [r3, #4]
 80285fc:	1809      	addeq	r1, r1, r0
 80285fe:	6021      	streq	r1, [r4, #0]
 8028600:	e7ed      	b.n	80285de <_free_r+0x1e>
 8028602:	461a      	mov	r2, r3
 8028604:	685b      	ldr	r3, [r3, #4]
 8028606:	b10b      	cbz	r3, 802860c <_free_r+0x4c>
 8028608:	42a3      	cmp	r3, r4
 802860a:	d9fa      	bls.n	8028602 <_free_r+0x42>
 802860c:	6811      	ldr	r1, [r2, #0]
 802860e:	1850      	adds	r0, r2, r1
 8028610:	42a0      	cmp	r0, r4
 8028612:	d10b      	bne.n	802862c <_free_r+0x6c>
 8028614:	6820      	ldr	r0, [r4, #0]
 8028616:	4401      	add	r1, r0
 8028618:	1850      	adds	r0, r2, r1
 802861a:	4283      	cmp	r3, r0
 802861c:	6011      	str	r1, [r2, #0]
 802861e:	d1e0      	bne.n	80285e2 <_free_r+0x22>
 8028620:	6818      	ldr	r0, [r3, #0]
 8028622:	685b      	ldr	r3, [r3, #4]
 8028624:	6053      	str	r3, [r2, #4]
 8028626:	4408      	add	r0, r1
 8028628:	6010      	str	r0, [r2, #0]
 802862a:	e7da      	b.n	80285e2 <_free_r+0x22>
 802862c:	d902      	bls.n	8028634 <_free_r+0x74>
 802862e:	230c      	movs	r3, #12
 8028630:	602b      	str	r3, [r5, #0]
 8028632:	e7d6      	b.n	80285e2 <_free_r+0x22>
 8028634:	6820      	ldr	r0, [r4, #0]
 8028636:	1821      	adds	r1, r4, r0
 8028638:	428b      	cmp	r3, r1
 802863a:	bf04      	itt	eq
 802863c:	6819      	ldreq	r1, [r3, #0]
 802863e:	685b      	ldreq	r3, [r3, #4]
 8028640:	6063      	str	r3, [r4, #4]
 8028642:	bf04      	itt	eq
 8028644:	1809      	addeq	r1, r1, r0
 8028646:	6021      	streq	r1, [r4, #0]
 8028648:	6054      	str	r4, [r2, #4]
 802864a:	e7ca      	b.n	80285e2 <_free_r+0x22>
 802864c:	bd38      	pop	{r3, r4, r5, pc}
 802864e:	bf00      	nop
 8028650:	20004308 	.word	0x20004308

08028654 <_malloc_usable_size_r>:
 8028654:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8028658:	1f18      	subs	r0, r3, #4
 802865a:	2b00      	cmp	r3, #0
 802865c:	bfbc      	itt	lt
 802865e:	580b      	ldrlt	r3, [r1, r0]
 8028660:	18c0      	addlt	r0, r0, r3
 8028662:	4770      	bx	lr

08028664 <__ssputs_r>:
 8028664:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028668:	688e      	ldr	r6, [r1, #8]
 802866a:	461f      	mov	r7, r3
 802866c:	42be      	cmp	r6, r7
 802866e:	680b      	ldr	r3, [r1, #0]
 8028670:	4682      	mov	sl, r0
 8028672:	460c      	mov	r4, r1
 8028674:	4690      	mov	r8, r2
 8028676:	d82d      	bhi.n	80286d4 <__ssputs_r+0x70>
 8028678:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 802867c:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 8028680:	d026      	beq.n	80286d0 <__ssputs_r+0x6c>
 8028682:	6965      	ldr	r5, [r4, #20]
 8028684:	6909      	ldr	r1, [r1, #16]
 8028686:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 802868a:	eba3 0901 	sub.w	r9, r3, r1
 802868e:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8028692:	1c7b      	adds	r3, r7, #1
 8028694:	444b      	add	r3, r9
 8028696:	106d      	asrs	r5, r5, #1
 8028698:	429d      	cmp	r5, r3
 802869a:	bf38      	it	cc
 802869c:	461d      	movcc	r5, r3
 802869e:	0553      	lsls	r3, r2, #21
 80286a0:	d527      	bpl.n	80286f2 <__ssputs_r+0x8e>
 80286a2:	4629      	mov	r1, r5
 80286a4:	f7ff fdfa 	bl	802829c <_malloc_r>
 80286a8:	4606      	mov	r6, r0
 80286aa:	b360      	cbz	r0, 8028706 <__ssputs_r+0xa2>
 80286ac:	6921      	ldr	r1, [r4, #16]
 80286ae:	464a      	mov	r2, r9
 80286b0:	f7ff ff78 	bl	80285a4 <memcpy>
 80286b4:	89a3      	ldrh	r3, [r4, #12]
 80286b6:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 80286ba:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80286be:	81a3      	strh	r3, [r4, #12]
 80286c0:	6126      	str	r6, [r4, #16]
 80286c2:	6165      	str	r5, [r4, #20]
 80286c4:	444e      	add	r6, r9
 80286c6:	eba5 0509 	sub.w	r5, r5, r9
 80286ca:	6026      	str	r6, [r4, #0]
 80286cc:	60a5      	str	r5, [r4, #8]
 80286ce:	463e      	mov	r6, r7
 80286d0:	42be      	cmp	r6, r7
 80286d2:	d900      	bls.n	80286d6 <__ssputs_r+0x72>
 80286d4:	463e      	mov	r6, r7
 80286d6:	6820      	ldr	r0, [r4, #0]
 80286d8:	4632      	mov	r2, r6
 80286da:	4641      	mov	r1, r8
 80286dc:	f7ff fede 	bl	802849c <memmove>
 80286e0:	68a3      	ldr	r3, [r4, #8]
 80286e2:	1b9b      	subs	r3, r3, r6
 80286e4:	60a3      	str	r3, [r4, #8]
 80286e6:	6823      	ldr	r3, [r4, #0]
 80286e8:	4433      	add	r3, r6
 80286ea:	6023      	str	r3, [r4, #0]
 80286ec:	2000      	movs	r0, #0
 80286ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80286f2:	462a      	mov	r2, r5
 80286f4:	f7ff fe5e 	bl	80283b4 <_realloc_r>
 80286f8:	4606      	mov	r6, r0
 80286fa:	2800      	cmp	r0, #0
 80286fc:	d1e0      	bne.n	80286c0 <__ssputs_r+0x5c>
 80286fe:	6921      	ldr	r1, [r4, #16]
 8028700:	4650      	mov	r0, sl
 8028702:	f7ff ff5d 	bl	80285c0 <_free_r>
 8028706:	230c      	movs	r3, #12
 8028708:	f8ca 3000 	str.w	r3, [sl]
 802870c:	89a3      	ldrh	r3, [r4, #12]
 802870e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8028712:	81a3      	strh	r3, [r4, #12]
 8028714:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8028718:	e7e9      	b.n	80286ee <__ssputs_r+0x8a>
	...

0802871c <_svfiprintf_r>:
 802871c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028720:	4698      	mov	r8, r3
 8028722:	898b      	ldrh	r3, [r1, #12]
 8028724:	061b      	lsls	r3, r3, #24
 8028726:	b09d      	sub	sp, #116	@ 0x74
 8028728:	4607      	mov	r7, r0
 802872a:	460d      	mov	r5, r1
 802872c:	4614      	mov	r4, r2
 802872e:	d510      	bpl.n	8028752 <_svfiprintf_r+0x36>
 8028730:	690b      	ldr	r3, [r1, #16]
 8028732:	b973      	cbnz	r3, 8028752 <_svfiprintf_r+0x36>
 8028734:	2140      	movs	r1, #64	@ 0x40
 8028736:	f7ff fdb1 	bl	802829c <_malloc_r>
 802873a:	6028      	str	r0, [r5, #0]
 802873c:	6128      	str	r0, [r5, #16]
 802873e:	b930      	cbnz	r0, 802874e <_svfiprintf_r+0x32>
 8028740:	230c      	movs	r3, #12
 8028742:	603b      	str	r3, [r7, #0]
 8028744:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8028748:	b01d      	add	sp, #116	@ 0x74
 802874a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802874e:	2340      	movs	r3, #64	@ 0x40
 8028750:	616b      	str	r3, [r5, #20]
 8028752:	2300      	movs	r3, #0
 8028754:	9309      	str	r3, [sp, #36]	@ 0x24
 8028756:	2320      	movs	r3, #32
 8028758:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 802875c:	f8cd 800c 	str.w	r8, [sp, #12]
 8028760:	2330      	movs	r3, #48	@ 0x30
 8028762:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 8028900 <_svfiprintf_r+0x1e4>
 8028766:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 802876a:	f04f 0901 	mov.w	r9, #1
 802876e:	4623      	mov	r3, r4
 8028770:	469a      	mov	sl, r3
 8028772:	f813 2b01 	ldrb.w	r2, [r3], #1
 8028776:	b10a      	cbz	r2, 802877c <_svfiprintf_r+0x60>
 8028778:	2a25      	cmp	r2, #37	@ 0x25
 802877a:	d1f9      	bne.n	8028770 <_svfiprintf_r+0x54>
 802877c:	ebba 0b04 	subs.w	fp, sl, r4
 8028780:	d00b      	beq.n	802879a <_svfiprintf_r+0x7e>
 8028782:	465b      	mov	r3, fp
 8028784:	4622      	mov	r2, r4
 8028786:	4629      	mov	r1, r5
 8028788:	4638      	mov	r0, r7
 802878a:	f7ff ff6b 	bl	8028664 <__ssputs_r>
 802878e:	3001      	adds	r0, #1
 8028790:	f000 80a7 	beq.w	80288e2 <_svfiprintf_r+0x1c6>
 8028794:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8028796:	445a      	add	r2, fp
 8028798:	9209      	str	r2, [sp, #36]	@ 0x24
 802879a:	f89a 3000 	ldrb.w	r3, [sl]
 802879e:	2b00      	cmp	r3, #0
 80287a0:	f000 809f 	beq.w	80288e2 <_svfiprintf_r+0x1c6>
 80287a4:	2300      	movs	r3, #0
 80287a6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80287aa:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80287ae:	f10a 0a01 	add.w	sl, sl, #1
 80287b2:	9304      	str	r3, [sp, #16]
 80287b4:	9307      	str	r3, [sp, #28]
 80287b6:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 80287ba:	931a      	str	r3, [sp, #104]	@ 0x68
 80287bc:	4654      	mov	r4, sl
 80287be:	2205      	movs	r2, #5
 80287c0:	f814 1b01 	ldrb.w	r1, [r4], #1
 80287c4:	484e      	ldr	r0, [pc, #312]	@ (8028900 <_svfiprintf_r+0x1e4>)
 80287c6:	f7d7 fd1b 	bl	8000200 <memchr>
 80287ca:	9a04      	ldr	r2, [sp, #16]
 80287cc:	b9d8      	cbnz	r0, 8028806 <_svfiprintf_r+0xea>
 80287ce:	06d0      	lsls	r0, r2, #27
 80287d0:	bf44      	itt	mi
 80287d2:	2320      	movmi	r3, #32
 80287d4:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 80287d8:	0711      	lsls	r1, r2, #28
 80287da:	bf44      	itt	mi
 80287dc:	232b      	movmi	r3, #43	@ 0x2b
 80287de:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 80287e2:	f89a 3000 	ldrb.w	r3, [sl]
 80287e6:	2b2a      	cmp	r3, #42	@ 0x2a
 80287e8:	d015      	beq.n	8028816 <_svfiprintf_r+0xfa>
 80287ea:	9a07      	ldr	r2, [sp, #28]
 80287ec:	4654      	mov	r4, sl
 80287ee:	2000      	movs	r0, #0
 80287f0:	f04f 0c0a 	mov.w	ip, #10
 80287f4:	4621      	mov	r1, r4
 80287f6:	f811 3b01 	ldrb.w	r3, [r1], #1
 80287fa:	3b30      	subs	r3, #48	@ 0x30
 80287fc:	2b09      	cmp	r3, #9
 80287fe:	d94b      	bls.n	8028898 <_svfiprintf_r+0x17c>
 8028800:	b1b0      	cbz	r0, 8028830 <_svfiprintf_r+0x114>
 8028802:	9207      	str	r2, [sp, #28]
 8028804:	e014      	b.n	8028830 <_svfiprintf_r+0x114>
 8028806:	eba0 0308 	sub.w	r3, r0, r8
 802880a:	fa09 f303 	lsl.w	r3, r9, r3
 802880e:	4313      	orrs	r3, r2
 8028810:	9304      	str	r3, [sp, #16]
 8028812:	46a2      	mov	sl, r4
 8028814:	e7d2      	b.n	80287bc <_svfiprintf_r+0xa0>
 8028816:	9b03      	ldr	r3, [sp, #12]
 8028818:	1d19      	adds	r1, r3, #4
 802881a:	681b      	ldr	r3, [r3, #0]
 802881c:	9103      	str	r1, [sp, #12]
 802881e:	2b00      	cmp	r3, #0
 8028820:	bfbb      	ittet	lt
 8028822:	425b      	neglt	r3, r3
 8028824:	f042 0202 	orrlt.w	r2, r2, #2
 8028828:	9307      	strge	r3, [sp, #28]
 802882a:	9307      	strlt	r3, [sp, #28]
 802882c:	bfb8      	it	lt
 802882e:	9204      	strlt	r2, [sp, #16]
 8028830:	7823      	ldrb	r3, [r4, #0]
 8028832:	2b2e      	cmp	r3, #46	@ 0x2e
 8028834:	d10a      	bne.n	802884c <_svfiprintf_r+0x130>
 8028836:	7863      	ldrb	r3, [r4, #1]
 8028838:	2b2a      	cmp	r3, #42	@ 0x2a
 802883a:	d132      	bne.n	80288a2 <_svfiprintf_r+0x186>
 802883c:	9b03      	ldr	r3, [sp, #12]
 802883e:	1d1a      	adds	r2, r3, #4
 8028840:	681b      	ldr	r3, [r3, #0]
 8028842:	9203      	str	r2, [sp, #12]
 8028844:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 8028848:	3402      	adds	r4, #2
 802884a:	9305      	str	r3, [sp, #20]
 802884c:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 8028910 <_svfiprintf_r+0x1f4>
 8028850:	7821      	ldrb	r1, [r4, #0]
 8028852:	2203      	movs	r2, #3
 8028854:	4650      	mov	r0, sl
 8028856:	f7d7 fcd3 	bl	8000200 <memchr>
 802885a:	b138      	cbz	r0, 802886c <_svfiprintf_r+0x150>
 802885c:	9b04      	ldr	r3, [sp, #16]
 802885e:	eba0 000a 	sub.w	r0, r0, sl
 8028862:	2240      	movs	r2, #64	@ 0x40
 8028864:	4082      	lsls	r2, r0
 8028866:	4313      	orrs	r3, r2
 8028868:	3401      	adds	r4, #1
 802886a:	9304      	str	r3, [sp, #16]
 802886c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8028870:	4824      	ldr	r0, [pc, #144]	@ (8028904 <_svfiprintf_r+0x1e8>)
 8028872:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 8028876:	2206      	movs	r2, #6
 8028878:	f7d7 fcc2 	bl	8000200 <memchr>
 802887c:	2800      	cmp	r0, #0
 802887e:	d036      	beq.n	80288ee <_svfiprintf_r+0x1d2>
 8028880:	4b21      	ldr	r3, [pc, #132]	@ (8028908 <_svfiprintf_r+0x1ec>)
 8028882:	bb1b      	cbnz	r3, 80288cc <_svfiprintf_r+0x1b0>
 8028884:	9b03      	ldr	r3, [sp, #12]
 8028886:	3307      	adds	r3, #7
 8028888:	f023 0307 	bic.w	r3, r3, #7
 802888c:	3308      	adds	r3, #8
 802888e:	9303      	str	r3, [sp, #12]
 8028890:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8028892:	4433      	add	r3, r6
 8028894:	9309      	str	r3, [sp, #36]	@ 0x24
 8028896:	e76a      	b.n	802876e <_svfiprintf_r+0x52>
 8028898:	fb0c 3202 	mla	r2, ip, r2, r3
 802889c:	460c      	mov	r4, r1
 802889e:	2001      	movs	r0, #1
 80288a0:	e7a8      	b.n	80287f4 <_svfiprintf_r+0xd8>
 80288a2:	2300      	movs	r3, #0
 80288a4:	3401      	adds	r4, #1
 80288a6:	9305      	str	r3, [sp, #20]
 80288a8:	4619      	mov	r1, r3
 80288aa:	f04f 0c0a 	mov.w	ip, #10
 80288ae:	4620      	mov	r0, r4
 80288b0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80288b4:	3a30      	subs	r2, #48	@ 0x30
 80288b6:	2a09      	cmp	r2, #9
 80288b8:	d903      	bls.n	80288c2 <_svfiprintf_r+0x1a6>
 80288ba:	2b00      	cmp	r3, #0
 80288bc:	d0c6      	beq.n	802884c <_svfiprintf_r+0x130>
 80288be:	9105      	str	r1, [sp, #20]
 80288c0:	e7c4      	b.n	802884c <_svfiprintf_r+0x130>
 80288c2:	fb0c 2101 	mla	r1, ip, r1, r2
 80288c6:	4604      	mov	r4, r0
 80288c8:	2301      	movs	r3, #1
 80288ca:	e7f0      	b.n	80288ae <_svfiprintf_r+0x192>
 80288cc:	ab03      	add	r3, sp, #12
 80288ce:	9300      	str	r3, [sp, #0]
 80288d0:	462a      	mov	r2, r5
 80288d2:	4b0e      	ldr	r3, [pc, #56]	@ (802890c <_svfiprintf_r+0x1f0>)
 80288d4:	a904      	add	r1, sp, #16
 80288d6:	4638      	mov	r0, r7
 80288d8:	f3af 8000 	nop.w
 80288dc:	1c42      	adds	r2, r0, #1
 80288de:	4606      	mov	r6, r0
 80288e0:	d1d6      	bne.n	8028890 <_svfiprintf_r+0x174>
 80288e2:	89ab      	ldrh	r3, [r5, #12]
 80288e4:	065b      	lsls	r3, r3, #25
 80288e6:	f53f af2d 	bmi.w	8028744 <_svfiprintf_r+0x28>
 80288ea:	9809      	ldr	r0, [sp, #36]	@ 0x24
 80288ec:	e72c      	b.n	8028748 <_svfiprintf_r+0x2c>
 80288ee:	ab03      	add	r3, sp, #12
 80288f0:	9300      	str	r3, [sp, #0]
 80288f2:	462a      	mov	r2, r5
 80288f4:	4b05      	ldr	r3, [pc, #20]	@ (802890c <_svfiprintf_r+0x1f0>)
 80288f6:	a904      	add	r1, sp, #16
 80288f8:	4638      	mov	r0, r7
 80288fa:	f000 f879 	bl	80289f0 <_printf_i>
 80288fe:	e7ed      	b.n	80288dc <_svfiprintf_r+0x1c0>
 8028900:	08033d9d 	.word	0x08033d9d
 8028904:	08033da7 	.word	0x08033da7
 8028908:	00000000 	.word	0x00000000
 802890c:	08028665 	.word	0x08028665
 8028910:	08033da3 	.word	0x08033da3

08028914 <_printf_common>:
 8028914:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028918:	4616      	mov	r6, r2
 802891a:	4698      	mov	r8, r3
 802891c:	688a      	ldr	r2, [r1, #8]
 802891e:	690b      	ldr	r3, [r1, #16]
 8028920:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8028924:	4293      	cmp	r3, r2
 8028926:	bfb8      	it	lt
 8028928:	4613      	movlt	r3, r2
 802892a:	6033      	str	r3, [r6, #0]
 802892c:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 8028930:	4607      	mov	r7, r0
 8028932:	460c      	mov	r4, r1
 8028934:	b10a      	cbz	r2, 802893a <_printf_common+0x26>
 8028936:	3301      	adds	r3, #1
 8028938:	6033      	str	r3, [r6, #0]
 802893a:	6823      	ldr	r3, [r4, #0]
 802893c:	0699      	lsls	r1, r3, #26
 802893e:	bf42      	ittt	mi
 8028940:	6833      	ldrmi	r3, [r6, #0]
 8028942:	3302      	addmi	r3, #2
 8028944:	6033      	strmi	r3, [r6, #0]
 8028946:	6825      	ldr	r5, [r4, #0]
 8028948:	f015 0506 	ands.w	r5, r5, #6
 802894c:	d106      	bne.n	802895c <_printf_common+0x48>
 802894e:	f104 0a19 	add.w	sl, r4, #25
 8028952:	68e3      	ldr	r3, [r4, #12]
 8028954:	6832      	ldr	r2, [r6, #0]
 8028956:	1a9b      	subs	r3, r3, r2
 8028958:	42ab      	cmp	r3, r5
 802895a:	dc26      	bgt.n	80289aa <_printf_common+0x96>
 802895c:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 8028960:	6822      	ldr	r2, [r4, #0]
 8028962:	3b00      	subs	r3, #0
 8028964:	bf18      	it	ne
 8028966:	2301      	movne	r3, #1
 8028968:	0692      	lsls	r2, r2, #26
 802896a:	d42b      	bmi.n	80289c4 <_printf_common+0xb0>
 802896c:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 8028970:	4641      	mov	r1, r8
 8028972:	4638      	mov	r0, r7
 8028974:	47c8      	blx	r9
 8028976:	3001      	adds	r0, #1
 8028978:	d01e      	beq.n	80289b8 <_printf_common+0xa4>
 802897a:	6823      	ldr	r3, [r4, #0]
 802897c:	6922      	ldr	r2, [r4, #16]
 802897e:	f003 0306 	and.w	r3, r3, #6
 8028982:	2b04      	cmp	r3, #4
 8028984:	bf02      	ittt	eq
 8028986:	68e5      	ldreq	r5, [r4, #12]
 8028988:	6833      	ldreq	r3, [r6, #0]
 802898a:	1aed      	subeq	r5, r5, r3
 802898c:	68a3      	ldr	r3, [r4, #8]
 802898e:	bf0c      	ite	eq
 8028990:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8028994:	2500      	movne	r5, #0
 8028996:	4293      	cmp	r3, r2
 8028998:	bfc4      	itt	gt
 802899a:	1a9b      	subgt	r3, r3, r2
 802899c:	18ed      	addgt	r5, r5, r3
 802899e:	2600      	movs	r6, #0
 80289a0:	341a      	adds	r4, #26
 80289a2:	42b5      	cmp	r5, r6
 80289a4:	d11a      	bne.n	80289dc <_printf_common+0xc8>
 80289a6:	2000      	movs	r0, #0
 80289a8:	e008      	b.n	80289bc <_printf_common+0xa8>
 80289aa:	2301      	movs	r3, #1
 80289ac:	4652      	mov	r2, sl
 80289ae:	4641      	mov	r1, r8
 80289b0:	4638      	mov	r0, r7
 80289b2:	47c8      	blx	r9
 80289b4:	3001      	adds	r0, #1
 80289b6:	d103      	bne.n	80289c0 <_printf_common+0xac>
 80289b8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80289bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80289c0:	3501      	adds	r5, #1
 80289c2:	e7c6      	b.n	8028952 <_printf_common+0x3e>
 80289c4:	18e1      	adds	r1, r4, r3
 80289c6:	1c5a      	adds	r2, r3, #1
 80289c8:	2030      	movs	r0, #48	@ 0x30
 80289ca:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 80289ce:	4422      	add	r2, r4
 80289d0:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 80289d4:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 80289d8:	3302      	adds	r3, #2
 80289da:	e7c7      	b.n	802896c <_printf_common+0x58>
 80289dc:	2301      	movs	r3, #1
 80289de:	4622      	mov	r2, r4
 80289e0:	4641      	mov	r1, r8
 80289e2:	4638      	mov	r0, r7
 80289e4:	47c8      	blx	r9
 80289e6:	3001      	adds	r0, #1
 80289e8:	d0e6      	beq.n	80289b8 <_printf_common+0xa4>
 80289ea:	3601      	adds	r6, #1
 80289ec:	e7d9      	b.n	80289a2 <_printf_common+0x8e>
	...

080289f0 <_printf_i>:
 80289f0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80289f4:	7e0f      	ldrb	r7, [r1, #24]
 80289f6:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 80289f8:	2f78      	cmp	r7, #120	@ 0x78
 80289fa:	4691      	mov	r9, r2
 80289fc:	4680      	mov	r8, r0
 80289fe:	460c      	mov	r4, r1
 8028a00:	469a      	mov	sl, r3
 8028a02:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 8028a06:	d807      	bhi.n	8028a18 <_printf_i+0x28>
 8028a08:	2f62      	cmp	r7, #98	@ 0x62
 8028a0a:	d80a      	bhi.n	8028a22 <_printf_i+0x32>
 8028a0c:	2f00      	cmp	r7, #0
 8028a0e:	f000 80d1 	beq.w	8028bb4 <_printf_i+0x1c4>
 8028a12:	2f58      	cmp	r7, #88	@ 0x58
 8028a14:	f000 80b8 	beq.w	8028b88 <_printf_i+0x198>
 8028a18:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8028a1c:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 8028a20:	e03a      	b.n	8028a98 <_printf_i+0xa8>
 8028a22:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 8028a26:	2b15      	cmp	r3, #21
 8028a28:	d8f6      	bhi.n	8028a18 <_printf_i+0x28>
 8028a2a:	a101      	add	r1, pc, #4	@ (adr r1, 8028a30 <_printf_i+0x40>)
 8028a2c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8028a30:	08028a89 	.word	0x08028a89
 8028a34:	08028a9d 	.word	0x08028a9d
 8028a38:	08028a19 	.word	0x08028a19
 8028a3c:	08028a19 	.word	0x08028a19
 8028a40:	08028a19 	.word	0x08028a19
 8028a44:	08028a19 	.word	0x08028a19
 8028a48:	08028a9d 	.word	0x08028a9d
 8028a4c:	08028a19 	.word	0x08028a19
 8028a50:	08028a19 	.word	0x08028a19
 8028a54:	08028a19 	.word	0x08028a19
 8028a58:	08028a19 	.word	0x08028a19
 8028a5c:	08028b9b 	.word	0x08028b9b
 8028a60:	08028ac7 	.word	0x08028ac7
 8028a64:	08028b55 	.word	0x08028b55
 8028a68:	08028a19 	.word	0x08028a19
 8028a6c:	08028a19 	.word	0x08028a19
 8028a70:	08028bbd 	.word	0x08028bbd
 8028a74:	08028a19 	.word	0x08028a19
 8028a78:	08028ac7 	.word	0x08028ac7
 8028a7c:	08028a19 	.word	0x08028a19
 8028a80:	08028a19 	.word	0x08028a19
 8028a84:	08028b5d 	.word	0x08028b5d
 8028a88:	6833      	ldr	r3, [r6, #0]
 8028a8a:	1d1a      	adds	r2, r3, #4
 8028a8c:	681b      	ldr	r3, [r3, #0]
 8028a8e:	6032      	str	r2, [r6, #0]
 8028a90:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8028a94:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8028a98:	2301      	movs	r3, #1
 8028a9a:	e09c      	b.n	8028bd6 <_printf_i+0x1e6>
 8028a9c:	6833      	ldr	r3, [r6, #0]
 8028a9e:	6820      	ldr	r0, [r4, #0]
 8028aa0:	1d19      	adds	r1, r3, #4
 8028aa2:	6031      	str	r1, [r6, #0]
 8028aa4:	0606      	lsls	r6, r0, #24
 8028aa6:	d501      	bpl.n	8028aac <_printf_i+0xbc>
 8028aa8:	681d      	ldr	r5, [r3, #0]
 8028aaa:	e003      	b.n	8028ab4 <_printf_i+0xc4>
 8028aac:	0645      	lsls	r5, r0, #25
 8028aae:	d5fb      	bpl.n	8028aa8 <_printf_i+0xb8>
 8028ab0:	f9b3 5000 	ldrsh.w	r5, [r3]
 8028ab4:	2d00      	cmp	r5, #0
 8028ab6:	da03      	bge.n	8028ac0 <_printf_i+0xd0>
 8028ab8:	232d      	movs	r3, #45	@ 0x2d
 8028aba:	426d      	negs	r5, r5
 8028abc:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8028ac0:	4858      	ldr	r0, [pc, #352]	@ (8028c24 <_printf_i+0x234>)
 8028ac2:	230a      	movs	r3, #10
 8028ac4:	e011      	b.n	8028aea <_printf_i+0xfa>
 8028ac6:	6821      	ldr	r1, [r4, #0]
 8028ac8:	6833      	ldr	r3, [r6, #0]
 8028aca:	0608      	lsls	r0, r1, #24
 8028acc:	f853 5b04 	ldr.w	r5, [r3], #4
 8028ad0:	d402      	bmi.n	8028ad8 <_printf_i+0xe8>
 8028ad2:	0649      	lsls	r1, r1, #25
 8028ad4:	bf48      	it	mi
 8028ad6:	b2ad      	uxthmi	r5, r5
 8028ad8:	2f6f      	cmp	r7, #111	@ 0x6f
 8028ada:	4852      	ldr	r0, [pc, #328]	@ (8028c24 <_printf_i+0x234>)
 8028adc:	6033      	str	r3, [r6, #0]
 8028ade:	bf14      	ite	ne
 8028ae0:	230a      	movne	r3, #10
 8028ae2:	2308      	moveq	r3, #8
 8028ae4:	2100      	movs	r1, #0
 8028ae6:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 8028aea:	6866      	ldr	r6, [r4, #4]
 8028aec:	60a6      	str	r6, [r4, #8]
 8028aee:	2e00      	cmp	r6, #0
 8028af0:	db05      	blt.n	8028afe <_printf_i+0x10e>
 8028af2:	6821      	ldr	r1, [r4, #0]
 8028af4:	432e      	orrs	r6, r5
 8028af6:	f021 0104 	bic.w	r1, r1, #4
 8028afa:	6021      	str	r1, [r4, #0]
 8028afc:	d04b      	beq.n	8028b96 <_printf_i+0x1a6>
 8028afe:	4616      	mov	r6, r2
 8028b00:	fbb5 f1f3 	udiv	r1, r5, r3
 8028b04:	fb03 5711 	mls	r7, r3, r1, r5
 8028b08:	5dc7      	ldrb	r7, [r0, r7]
 8028b0a:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8028b0e:	462f      	mov	r7, r5
 8028b10:	42bb      	cmp	r3, r7
 8028b12:	460d      	mov	r5, r1
 8028b14:	d9f4      	bls.n	8028b00 <_printf_i+0x110>
 8028b16:	2b08      	cmp	r3, #8
 8028b18:	d10b      	bne.n	8028b32 <_printf_i+0x142>
 8028b1a:	6823      	ldr	r3, [r4, #0]
 8028b1c:	07df      	lsls	r7, r3, #31
 8028b1e:	d508      	bpl.n	8028b32 <_printf_i+0x142>
 8028b20:	6923      	ldr	r3, [r4, #16]
 8028b22:	6861      	ldr	r1, [r4, #4]
 8028b24:	4299      	cmp	r1, r3
 8028b26:	bfde      	ittt	le
 8028b28:	2330      	movle	r3, #48	@ 0x30
 8028b2a:	f806 3c01 	strble.w	r3, [r6, #-1]
 8028b2e:	f106 36ff 	addle.w	r6, r6, #4294967295	@ 0xffffffff
 8028b32:	1b92      	subs	r2, r2, r6
 8028b34:	6122      	str	r2, [r4, #16]
 8028b36:	f8cd a000 	str.w	sl, [sp]
 8028b3a:	464b      	mov	r3, r9
 8028b3c:	aa03      	add	r2, sp, #12
 8028b3e:	4621      	mov	r1, r4
 8028b40:	4640      	mov	r0, r8
 8028b42:	f7ff fee7 	bl	8028914 <_printf_common>
 8028b46:	3001      	adds	r0, #1
 8028b48:	d14a      	bne.n	8028be0 <_printf_i+0x1f0>
 8028b4a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8028b4e:	b004      	add	sp, #16
 8028b50:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028b54:	6823      	ldr	r3, [r4, #0]
 8028b56:	f043 0320 	orr.w	r3, r3, #32
 8028b5a:	6023      	str	r3, [r4, #0]
 8028b5c:	4832      	ldr	r0, [pc, #200]	@ (8028c28 <_printf_i+0x238>)
 8028b5e:	2778      	movs	r7, #120	@ 0x78
 8028b60:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 8028b64:	6823      	ldr	r3, [r4, #0]
 8028b66:	6831      	ldr	r1, [r6, #0]
 8028b68:	061f      	lsls	r7, r3, #24
 8028b6a:	f851 5b04 	ldr.w	r5, [r1], #4
 8028b6e:	d402      	bmi.n	8028b76 <_printf_i+0x186>
 8028b70:	065f      	lsls	r7, r3, #25
 8028b72:	bf48      	it	mi
 8028b74:	b2ad      	uxthmi	r5, r5
 8028b76:	6031      	str	r1, [r6, #0]
 8028b78:	07d9      	lsls	r1, r3, #31
 8028b7a:	bf44      	itt	mi
 8028b7c:	f043 0320 	orrmi.w	r3, r3, #32
 8028b80:	6023      	strmi	r3, [r4, #0]
 8028b82:	b11d      	cbz	r5, 8028b8c <_printf_i+0x19c>
 8028b84:	2310      	movs	r3, #16
 8028b86:	e7ad      	b.n	8028ae4 <_printf_i+0xf4>
 8028b88:	4826      	ldr	r0, [pc, #152]	@ (8028c24 <_printf_i+0x234>)
 8028b8a:	e7e9      	b.n	8028b60 <_printf_i+0x170>
 8028b8c:	6823      	ldr	r3, [r4, #0]
 8028b8e:	f023 0320 	bic.w	r3, r3, #32
 8028b92:	6023      	str	r3, [r4, #0]
 8028b94:	e7f6      	b.n	8028b84 <_printf_i+0x194>
 8028b96:	4616      	mov	r6, r2
 8028b98:	e7bd      	b.n	8028b16 <_printf_i+0x126>
 8028b9a:	6833      	ldr	r3, [r6, #0]
 8028b9c:	6825      	ldr	r5, [r4, #0]
 8028b9e:	6961      	ldr	r1, [r4, #20]
 8028ba0:	1d18      	adds	r0, r3, #4
 8028ba2:	6030      	str	r0, [r6, #0]
 8028ba4:	062e      	lsls	r6, r5, #24
 8028ba6:	681b      	ldr	r3, [r3, #0]
 8028ba8:	d501      	bpl.n	8028bae <_printf_i+0x1be>
 8028baa:	6019      	str	r1, [r3, #0]
 8028bac:	e002      	b.n	8028bb4 <_printf_i+0x1c4>
 8028bae:	0668      	lsls	r0, r5, #25
 8028bb0:	d5fb      	bpl.n	8028baa <_printf_i+0x1ba>
 8028bb2:	8019      	strh	r1, [r3, #0]
 8028bb4:	2300      	movs	r3, #0
 8028bb6:	6123      	str	r3, [r4, #16]
 8028bb8:	4616      	mov	r6, r2
 8028bba:	e7bc      	b.n	8028b36 <_printf_i+0x146>
 8028bbc:	6833      	ldr	r3, [r6, #0]
 8028bbe:	1d1a      	adds	r2, r3, #4
 8028bc0:	6032      	str	r2, [r6, #0]
 8028bc2:	681e      	ldr	r6, [r3, #0]
 8028bc4:	6862      	ldr	r2, [r4, #4]
 8028bc6:	2100      	movs	r1, #0
 8028bc8:	4630      	mov	r0, r6
 8028bca:	f7d7 fb19 	bl	8000200 <memchr>
 8028bce:	b108      	cbz	r0, 8028bd4 <_printf_i+0x1e4>
 8028bd0:	1b80      	subs	r0, r0, r6
 8028bd2:	6060      	str	r0, [r4, #4]
 8028bd4:	6863      	ldr	r3, [r4, #4]
 8028bd6:	6123      	str	r3, [r4, #16]
 8028bd8:	2300      	movs	r3, #0
 8028bda:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8028bde:	e7aa      	b.n	8028b36 <_printf_i+0x146>
 8028be0:	6923      	ldr	r3, [r4, #16]
 8028be2:	4632      	mov	r2, r6
 8028be4:	4649      	mov	r1, r9
 8028be6:	4640      	mov	r0, r8
 8028be8:	47d0      	blx	sl
 8028bea:	3001      	adds	r0, #1
 8028bec:	d0ad      	beq.n	8028b4a <_printf_i+0x15a>
 8028bee:	6823      	ldr	r3, [r4, #0]
 8028bf0:	079b      	lsls	r3, r3, #30
 8028bf2:	d413      	bmi.n	8028c1c <_printf_i+0x22c>
 8028bf4:	68e0      	ldr	r0, [r4, #12]
 8028bf6:	9b03      	ldr	r3, [sp, #12]
 8028bf8:	4298      	cmp	r0, r3
 8028bfa:	bfb8      	it	lt
 8028bfc:	4618      	movlt	r0, r3
 8028bfe:	e7a6      	b.n	8028b4e <_printf_i+0x15e>
 8028c00:	2301      	movs	r3, #1
 8028c02:	4632      	mov	r2, r6
 8028c04:	4649      	mov	r1, r9
 8028c06:	4640      	mov	r0, r8
 8028c08:	47d0      	blx	sl
 8028c0a:	3001      	adds	r0, #1
 8028c0c:	d09d      	beq.n	8028b4a <_printf_i+0x15a>
 8028c0e:	3501      	adds	r5, #1
 8028c10:	68e3      	ldr	r3, [r4, #12]
 8028c12:	9903      	ldr	r1, [sp, #12]
 8028c14:	1a5b      	subs	r3, r3, r1
 8028c16:	42ab      	cmp	r3, r5
 8028c18:	dcf2      	bgt.n	8028c00 <_printf_i+0x210>
 8028c1a:	e7eb      	b.n	8028bf4 <_printf_i+0x204>
 8028c1c:	2500      	movs	r5, #0
 8028c1e:	f104 0619 	add.w	r6, r4, #25
 8028c22:	e7f5      	b.n	8028c10 <_printf_i+0x220>
 8028c24:	08033dae 	.word	0x08033dae
 8028c28:	08033dbf 	.word	0x08033dbf

08028c2c <_init>:
 8028c2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028c2e:	bf00      	nop
 8028c30:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8028c32:	bc08      	pop	{r3}
 8028c34:	469e      	mov	lr, r3
 8028c36:	4770      	bx	lr

08028c38 <_fini>:
 8028c38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028c3a:	bf00      	nop
 8028c3c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8028c3e:	bc08      	pop	{r3}
 8028c40:	469e      	mov	lr, r3
 8028c42:	4770      	bx	lr
